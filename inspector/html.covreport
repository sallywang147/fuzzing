htmlTagLookup:
 1391|  24.2k|htmlTagLookup(const xmlChar *tag) {
 1392|  24.2k|    if (tag == NULL)
  ------------------
  |  Branch (1392:9): [True: 0, False: 24.2k]
  ------------------
 1393|      0|        return(NULL);
 1394|       |
 1395|  24.2k|    return((const htmlElemDesc *) bsearch(tag, html40ElementTable,
 1396|  24.2k|                sizeof(html40ElementTable) / sizeof(htmlElemDesc),
 1397|  24.2k|                sizeof(htmlElemDesc), htmlCompareTags));
 1398|  24.2k|}
htmlEntityLookup:
 2056|    883|htmlEntityLookup(const xmlChar *name) {
 2057|    883|    unsigned int i;
 2058|       |
 2059|  13.0k|    for (i = 0;i < (sizeof(html40EntitiesTable)/
  ------------------
  |  Branch (2059:16): [True: 13.0k, False: 0]
  ------------------
 2060|  13.0k|                    sizeof(html40EntitiesTable[0]));i++) {
 2061|  13.0k|        if (xmlStrEqual(name, BAD_CAST html40EntitiesTable[i].name)) {
  ------------------
  |  |   35|  13.0k|#define BAD_CAST (xmlChar *)
  ------------------
  |  Branch (2061:13): [True: 883, False: 12.1k]
  ------------------
 2062|    883|            return((htmlEntityDescPtr) &html40EntitiesTable[i]);
 2063|    883|	}
 2064|  13.0k|    }
 2065|      0|    return(NULL);
 2066|    883|}
htmlNewDocNoDtD:
 2434|    182|htmlNewDocNoDtD(const xmlChar *URI, const xmlChar *ExternalID) {
 2435|    182|    xmlDocPtr cur;
 2436|       |
 2437|       |    /*
 2438|       |     * Allocate a new document and fill the fields.
 2439|       |     */
 2440|    182|    cur = (xmlDocPtr) xmlMalloc(sizeof(xmlDoc));
 2441|    182|    if (cur == NULL) {
  ------------------
  |  Branch (2441:9): [True: 2, False: 180]
  ------------------
 2442|      2|	htmlErrMemory(NULL, "HTML document creation failed\n");
 2443|      2|	return(NULL);
 2444|      2|    }
 2445|    180|    memset(cur, 0, sizeof(xmlDoc));
 2446|       |
 2447|    180|    cur->type = XML_HTML_DOCUMENT_NODE;
 2448|    180|    cur->version = NULL;
 2449|    180|    cur->intSubset = NULL;
 2450|    180|    cur->doc = cur;
 2451|    180|    cur->name = NULL;
 2452|    180|    cur->children = NULL;
 2453|    180|    cur->extSubset = NULL;
 2454|    180|    cur->oldNs = NULL;
 2455|    180|    cur->encoding = NULL;
 2456|    180|    cur->standalone = 1;
 2457|    180|    cur->compression = 0;
 2458|    180|    cur->ids = NULL;
 2459|    180|    cur->refs = NULL;
 2460|    180|    cur->_private = NULL;
 2461|    180|    cur->charset = XML_CHAR_ENCODING_UTF8;
 2462|    180|    cur->properties = XML_DOC_HTML | XML_DOC_USERBUILT;
 2463|    180|    if ((ExternalID != NULL) ||
  ------------------
  |  Branch (2463:9): [True: 0, False: 180]
  ------------------
 2464|    180|	(URI != NULL))
  ------------------
  |  Branch (2464:2): [True: 0, False: 180]
  ------------------
 2465|      0|	xmlCreateIntSubset(cur, BAD_CAST "html", ExternalID, URI);
  ------------------
  |  |   35|      0|#define BAD_CAST (xmlChar *)
  ------------------
 2466|    180|    if ((__xmlRegisterCallbacks) && (xmlRegisterNodeDefaultValue))
  ------------------
  |  |  682|      0|    XML_GLOBAL_MACRO(xmlRegisterNodeDefaultValue)
  |  |  ------------------
  |  |  |  |  500|      0|  #define XML_GLOBAL_MACRO(name) (*__##name())
  |  |  ------------------
  ------------------
  |  Branch (2466:9): [True: 0, False: 180]
  |  Branch (2466:37): [True: 0, False: 0]
  ------------------
 2467|      0|	xmlRegisterNodeDefaultValue((xmlNodePtr)cur);
  ------------------
  |  |  682|      0|    XML_GLOBAL_MACRO(xmlRegisterNodeDefaultValue)
  |  |  ------------------
  |  |  |  |  500|      0|  #define XML_GLOBAL_MACRO(name) (*__##name())
  |  |  ------------------
  ------------------
 2468|    180|    return(cur);
 2469|    182|}
htmlParseEntityRef:
 2857|  1.46k|htmlParseEntityRef(htmlParserCtxtPtr ctxt, const xmlChar **str) {
 2858|  1.46k|    const xmlChar *name;
 2859|  1.46k|    const htmlEntityDesc * ent = NULL;
 2860|       |
 2861|  1.46k|    if (str != NULL) *str = NULL;
  ------------------
  |  Branch (2861:9): [True: 1.46k, False: 0]
  ------------------
 2862|  1.46k|    if ((ctxt == NULL) || (ctxt->input == NULL)) return(NULL);
  ------------------
  |  Branch (2862:9): [True: 0, False: 1.46k]
  |  Branch (2862:27): [True: 0, False: 1.46k]
  ------------------
 2863|       |
 2864|  1.46k|    if (CUR == '&') {
  ------------------
  |  |  304|  1.46k|#define CUR (*ctxt->input->cur)
  ------------------
  |  Branch (2864:9): [True: 1.46k, False: 0]
  ------------------
 2865|  1.46k|        NEXT;
  ------------------
  |  |  305|  1.46k|#define NEXT xmlNextChar(ctxt)
  ------------------
 2866|  1.46k|        name = htmlParseName(ctxt);
 2867|  1.46k|	if (name == NULL) {
  ------------------
  |  Branch (2867:6): [True: 21, False: 1.44k]
  ------------------
 2868|     21|	    htmlParseErr(ctxt, XML_ERR_NAME_REQUIRED,
 2869|     21|	                 "htmlParseEntityRef: no name\n", NULL, NULL);
 2870|  1.44k|	} else {
 2871|  1.44k|	    GROW;
  ------------------
  |  |  296|  1.44k|#define GROW if ((ctxt->progressive == 0) &&				\
  |  |  ------------------
  |  |  |  Branch (296:18): [True: 707, False: 741]
  |  |  ------------------
  |  |  297|  1.44k|		 (ctxt->input->end - ctxt->input->cur < INPUT_CHUNK))	\
  |  |  ------------------
  |  |  |  |   97|    707|#define INPUT_CHUNK	250
  |  |  ------------------
  |  |  |  Branch (297:4): [True: 13, False: 694]
  |  |  ------------------
  |  |  298|  1.44k|	xmlParserGrow(ctxt)
  ------------------
 2872|  1.44k|	    if (CUR == ';') {
  ------------------
  |  |  304|  1.44k|#define CUR (*ctxt->input->cur)
  ------------------
  |  Branch (2872:10): [True: 883, False: 565]
  ------------------
 2873|    883|	        if (str != NULL)
  ------------------
  |  Branch (2873:14): [True: 883, False: 0]
  ------------------
 2874|    883|		    *str = name;
 2875|       |
 2876|       |		/*
 2877|       |		 * Lookup the entity in the table.
 2878|       |		 */
 2879|    883|		ent = htmlEntityLookup(name);
 2880|    883|		if (ent != NULL) /* OK that's ugly !!! */
  ------------------
  |  Branch (2880:7): [True: 883, False: 0]
  ------------------
 2881|    883|		    NEXT;
  ------------------
  |  |  305|    883|#define NEXT xmlNextChar(ctxt)
  ------------------
 2882|    883|	    } else {
 2883|    565|		htmlParseErr(ctxt, XML_ERR_ENTITYREF_SEMICOL_MISSING,
 2884|    565|		             "htmlParseEntityRef: expecting ';'\n",
 2885|    565|			     NULL, NULL);
 2886|    565|	        if (str != NULL)
  ------------------
  |  Branch (2886:14): [True: 565, False: 0]
  ------------------
 2887|    565|		    *str = name;
 2888|    565|	    }
 2889|  1.44k|	}
 2890|  1.46k|    }
 2891|  1.46k|    return(ent);
 2892|  1.46k|}
htmlParseCharRef:
 3563|    918|htmlParseCharRef(htmlParserCtxtPtr ctxt) {
 3564|    918|    int val = 0;
 3565|       |
 3566|    918|    if ((ctxt == NULL) || (ctxt->input == NULL)) {
  ------------------
  |  Branch (3566:9): [True: 0, False: 918]
  |  Branch (3566:27): [True: 0, False: 918]
  ------------------
 3567|      0|	htmlParseErr(ctxt, XML_ERR_INTERNAL_ERROR,
 3568|      0|		     "htmlParseCharRef: context error\n",
 3569|      0|		     NULL, NULL);
 3570|      0|        return(0);
 3571|      0|    }
 3572|    918|    if ((CUR == '&') && (NXT(1) == '#') &&
  ------------------
  |  |  304|    918|#define CUR (*ctxt->input->cur)
  ------------------
                  if ((CUR == '&') && (NXT(1) == '#') &&
  ------------------
  |  |  285|    918|#define NXT(val) ctxt->input->cur[(val)]
  ------------------
  |  Branch (3572:9): [True: 918, False: 0]
  |  Branch (3572:25): [True: 918, False: 0]
  ------------------
 3573|    918|        ((NXT(2) == 'x') || NXT(2) == 'X')) {
  ------------------
  |  |  285|    918|#define NXT(val) ctxt->input->cur[(val)]
  ------------------
                      ((NXT(2) == 'x') || NXT(2) == 'X')) {
  ------------------
  |  |  285|    918|#define NXT(val) ctxt->input->cur[(val)]
  ------------------
  |  Branch (3573:10): [True: 0, False: 918]
  |  Branch (3573:29): [True: 0, False: 918]
  ------------------
 3574|      0|	SKIP(3);
  ------------------
  |  |  283|      0|#define SKIP(val) ctxt->input->cur += (val),ctxt->input->col+=(val)
  ------------------
 3575|      0|	while (CUR != ';') {
  ------------------
  |  |  304|      0|#define CUR (*ctxt->input->cur)
  ------------------
  |  Branch (3575:9): [True: 0, False: 0]
  ------------------
 3576|      0|	    if ((CUR >= '0') && (CUR <= '9')) {
  ------------------
  |  |  304|      0|#define CUR (*ctxt->input->cur)
  ------------------
              	    if ((CUR >= '0') && (CUR <= '9')) {
  ------------------
  |  |  304|      0|#define CUR (*ctxt->input->cur)
  ------------------
  |  Branch (3576:10): [True: 0, False: 0]
  |  Branch (3576:26): [True: 0, False: 0]
  ------------------
 3577|      0|                if (val < 0x110000)
  ------------------
  |  Branch (3577:21): [True: 0, False: 0]
  ------------------
 3578|      0|	            val = val * 16 + (CUR - '0');
  ------------------
  |  |  304|      0|#define CUR (*ctxt->input->cur)
  ------------------
 3579|      0|            } else if ((CUR >= 'a') && (CUR <= 'f')) {
  ------------------
  |  |  304|      0|#define CUR (*ctxt->input->cur)
  ------------------
                          } else if ((CUR >= 'a') && (CUR <= 'f')) {
  ------------------
  |  |  304|      0|#define CUR (*ctxt->input->cur)
  ------------------
  |  Branch (3579:24): [True: 0, False: 0]
  |  Branch (3579:40): [True: 0, False: 0]
  ------------------
 3580|      0|                if (val < 0x110000)
  ------------------
  |  Branch (3580:21): [True: 0, False: 0]
  ------------------
 3581|      0|	            val = val * 16 + (CUR - 'a') + 10;
  ------------------
  |  |  304|      0|#define CUR (*ctxt->input->cur)
  ------------------
 3582|      0|            } else if ((CUR >= 'A') && (CUR <= 'F')) {
  ------------------
  |  |  304|      0|#define CUR (*ctxt->input->cur)
  ------------------
                          } else if ((CUR >= 'A') && (CUR <= 'F')) {
  ------------------
  |  |  304|      0|#define CUR (*ctxt->input->cur)
  ------------------
  |  Branch (3582:24): [True: 0, False: 0]
  |  Branch (3582:40): [True: 0, False: 0]
  ------------------
 3583|      0|                if (val < 0x110000)
  ------------------
  |  Branch (3583:21): [True: 0, False: 0]
  ------------------
 3584|      0|	            val = val * 16 + (CUR - 'A') + 10;
  ------------------
  |  |  304|      0|#define CUR (*ctxt->input->cur)
  ------------------
 3585|      0|            } else {
 3586|      0|	        htmlParseErr(ctxt, XML_ERR_INVALID_HEX_CHARREF,
 3587|      0|		             "htmlParseCharRef: missing semicolon\n",
 3588|      0|			     NULL, NULL);
 3589|      0|		break;
 3590|      0|	    }
 3591|      0|	    NEXT;
  ------------------
  |  |  305|      0|#define NEXT xmlNextChar(ctxt)
  ------------------
 3592|      0|	}
 3593|      0|	if (CUR == ';')
  ------------------
  |  |  304|      0|#define CUR (*ctxt->input->cur)
  ------------------
  |  Branch (3593:6): [True: 0, False: 0]
  ------------------
 3594|      0|	    NEXT;
  ------------------
  |  |  305|      0|#define NEXT xmlNextChar(ctxt)
  ------------------
 3595|    918|    } else if  ((CUR == '&') && (NXT(1) == '#')) {
  ------------------
  |  |  304|    918|#define CUR (*ctxt->input->cur)
  ------------------
                  } else if  ((CUR == '&') && (NXT(1) == '#')) {
  ------------------
  |  |  285|    918|#define NXT(val) ctxt->input->cur[(val)]
  ------------------
  |  Branch (3595:17): [True: 918, False: 0]
  |  Branch (3595:33): [True: 918, False: 0]
  ------------------
 3596|    918|	SKIP(2);
  ------------------
  |  |  283|    918|#define SKIP(val) ctxt->input->cur += (val),ctxt->input->col+=(val)
  ------------------
 3597|  3.55k|	while (CUR != ';') {
  ------------------
  |  |  304|  3.55k|#define CUR (*ctxt->input->cur)
  ------------------
  |  Branch (3597:9): [True: 2.64k, False: 916]
  ------------------
 3598|  2.64k|	    if ((CUR >= '0') && (CUR <= '9')) {
  ------------------
  |  |  304|  2.64k|#define CUR (*ctxt->input->cur)
  ------------------
              	    if ((CUR >= '0') && (CUR <= '9')) {
  ------------------
  |  |  304|  2.64k|#define CUR (*ctxt->input->cur)
  ------------------
  |  Branch (3598:10): [True: 2.64k, False: 0]
  |  Branch (3598:26): [True: 2.64k, False: 2]
  ------------------
 3599|  2.64k|                if (val < 0x110000)
  ------------------
  |  Branch (3599:21): [True: 2.64k, False: 0]
  ------------------
 3600|  2.64k|	            val = val * 10 + (CUR - '0');
  ------------------
  |  |  304|  2.64k|#define CUR (*ctxt->input->cur)
  ------------------
 3601|  2.64k|            } else {
 3602|      2|	        htmlParseErr(ctxt, XML_ERR_INVALID_DEC_CHARREF,
 3603|      2|		             "htmlParseCharRef: missing semicolon\n",
 3604|      2|			     NULL, NULL);
 3605|      2|		break;
 3606|      2|	    }
 3607|  2.64k|	    NEXT;
  ------------------
  |  |  305|  2.64k|#define NEXT xmlNextChar(ctxt)
  ------------------
 3608|  2.64k|	}
 3609|    918|	if (CUR == ';')
  ------------------
  |  |  304|    918|#define CUR (*ctxt->input->cur)
  ------------------
  |  Branch (3609:6): [True: 916, False: 2]
  ------------------
 3610|    916|	    NEXT;
  ------------------
  |  |  305|    916|#define NEXT xmlNextChar(ctxt)
  ------------------
 3611|    918|    } else {
 3612|      0|	htmlParseErr(ctxt, XML_ERR_INVALID_CHARREF,
 3613|      0|	             "htmlParseCharRef: invalid value\n", NULL, NULL);
 3614|      0|    }
 3615|       |    /*
 3616|       |     * Check the value IS_CHAR ...
 3617|       |     */
 3618|    918|    if (IS_CHAR(val)) {
  ------------------
  |  |  125|    918|#define IS_CHAR(c)   xmlIsCharQ(c)
  |  |  ------------------
  |  |  |  |  118|    918|#define xmlIsCharQ(c)		(((c) < 0x100) ? \
  |  |  |  |  ------------------
  |  |  |  |  |  Branch (118:24): [True: 916, False: 2]
  |  |  |  |  |  Branch (118:25): [True: 714, False: 204]
  |  |  |  |  ------------------
  |  |  |  |  119|    918|				 xmlIsChar_ch((c)) :\
  |  |  |  |  ------------------
  |  |  |  |  |  |  108|    714|#define xmlIsChar_ch(c)		(((0x9 <= (c)) && ((c) <= 0xa)) || \
  |  |  |  |  |  |  ------------------
  |  |  |  |  |  |  |  Branch (108:28): [True: 712, False: 2]
  |  |  |  |  |  |  |  Branch (108:44): [True: 0, False: 712]
  |  |  |  |  |  |  ------------------
  |  |  |  |  |  |  109|    714|				 ((c) == 0xd) || \
  |  |  |  |  |  |  ------------------
  |  |  |  |  |  |  |  Branch (109:6): [True: 0, False: 714]
  |  |  |  |  |  |  ------------------
  |  |  |  |  |  |  110|    714|				  (0x20 <= (c)))
  |  |  |  |  |  |  ------------------
  |  |  |  |  |  |  |  Branch (110:7): [True: 712, False: 2]
  |  |  |  |  |  |  ------------------
  |  |  |  |  ------------------
  |  |  |  |  120|    918|				(((0x100 <= (c)) && ((c) <= 0xd7ff)) || \
  |  |  |  |  ------------------
  |  |  |  |  |  Branch (120:7): [True: 204, False: 0]
  |  |  |  |  |  Branch (120:25): [True: 204, False: 0]
  |  |  |  |  ------------------
  |  |  |  |  121|    204|				 ((0xe000 <= (c)) && ((c) <= 0xfffd)) || \
  |  |  |  |  ------------------
  |  |  |  |  |  Branch (121:7): [True: 0, False: 0]
  |  |  |  |  |  Branch (121:26): [True: 0, False: 0]
  |  |  |  |  ------------------
  |  |  |  |  122|    204|				 ((0x10000 <= (c)) && ((c) <= 0x10ffff))))
  |  |  |  |  ------------------
  |  |  |  |  |  Branch (122:7): [True: 0, False: 0]
  |  |  |  |  |  Branch (122:27): [True: 0, False: 0]
  |  |  |  |  ------------------
  |  |  ------------------
  ------------------
 3619|    916|        return(val);
 3620|    916|    } else if (val >= 0x110000) {
  ------------------
  |  Branch (3620:16): [True: 0, False: 2]
  ------------------
 3621|      0|	htmlParseErr(ctxt, XML_ERR_INVALID_CHAR,
 3622|      0|		     "htmlParseCharRef: value too large\n", NULL, NULL);
 3623|      2|    } else {
 3624|      2|	htmlParseErrInt(ctxt, XML_ERR_INVALID_CHAR,
 3625|      2|			"htmlParseCharRef: invalid xmlChar value %d\n",
 3626|      2|			val);
 3627|      2|    }
 3628|      2|    return(0);
 3629|    918|}
htmlParseDocument:
 4835|     91|htmlParseDocument(htmlParserCtxtPtr ctxt) {
 4836|     91|    xmlDtdPtr dtd;
 4837|       |
 4838|     91|    xmlInitParser();
 4839|       |
 4840|     91|    if ((ctxt == NULL) || (ctxt->input == NULL)) {
  ------------------
  |  Branch (4840:9): [True: 0, False: 91]
  |  Branch (4840:27): [True: 0, False: 91]
  ------------------
 4841|      0|	htmlParseErr(ctxt, XML_ERR_INTERNAL_ERROR,
 4842|      0|		     "htmlParseDocument: context error\n", NULL, NULL);
 4843|      0|	return(XML_ERR_INTERNAL_ERROR);
 4844|      0|    }
 4845|       |
 4846|       |    /*
 4847|       |     * SAX: beginning of the document processing.
 4848|       |     */
 4849|     91|    if ((ctxt->sax) && (ctxt->sax->setDocumentLocator))
  ------------------
  |  Branch (4849:9): [True: 91, False: 0]
  |  Branch (4849:24): [True: 91, False: 0]
  ------------------
 4850|     91|        ctxt->sax->setDocumentLocator(ctxt->userData, &xmlDefaultSAXLocator);
  ------------------
  |  |  861|     91|  #define xmlDefaultSAXLocator XML_GLOBAL_MACRO(xmlDefaultSAXLocator)
  |  |  ------------------
  |  |  |  |  500|     91|  #define XML_GLOBAL_MACRO(name) (*__##name())
  |  |  ------------------
  ------------------
 4851|       |
 4852|     91|    xmlDetectEncoding(ctxt);
 4853|       |
 4854|       |    /*
 4855|       |     * Wipe out everything which is before the first '<'
 4856|       |     */
 4857|     91|    SKIP_BLANKS;
  ------------------
  |  |  300|     91|#define SKIP_BLANKS htmlSkipBlankChars(ctxt)
  ------------------
 4858|     91|    if (CUR == 0) {
  ------------------
  |  |  304|     91|#define CUR (*ctxt->input->cur)
  ------------------
  |  Branch (4858:9): [True: 3, False: 88]
  ------------------
 4859|      3|	htmlParseErr(ctxt, XML_ERR_DOCUMENT_EMPTY,
 4860|      3|	             "Document is empty\n", NULL, NULL);
 4861|      3|    }
 4862|       |
 4863|     91|    if ((ctxt->sax) && (ctxt->sax->startDocument) && (!ctxt->disableSAX))
  ------------------
  |  Branch (4863:9): [True: 91, False: 0]
  |  Branch (4863:24): [True: 91, False: 0]
  |  Branch (4863:54): [True: 91, False: 0]
  ------------------
 4864|     91|	ctxt->sax->startDocument(ctxt->userData);
 4865|       |
 4866|       |
 4867|       |    /*
 4868|       |     * Parse possible comments and PIs before any content
 4869|       |     */
 4870|     99|    while (((CUR == '<') && (NXT(1) == '!') &&
  ------------------
  |  |  304|     99|#define CUR (*ctxt->input->cur)
  ------------------
                  while (((CUR == '<') && (NXT(1) == '!') &&
  ------------------
  |  |  285|     86|#define NXT(val) ctxt->input->cur[(val)]
  ------------------
  |  Branch (4870:13): [True: 86, False: 13]
  |  Branch (4870:29): [True: 25, False: 61]
  ------------------
 4871|     99|            (NXT(2) == '-') && (NXT(3) == '-')) ||
  ------------------
  |  |  285|     25|#define NXT(val) ctxt->input->cur[(val)]
  ------------------
                          (NXT(2) == '-') && (NXT(3) == '-')) ||
  ------------------
  |  |  285|      7|#define NXT(val) ctxt->input->cur[(val)]
  ------------------
  |  Branch (4871:13): [True: 7, False: 18]
  |  Branch (4871:32): [True: 7, False: 0]
  ------------------
 4872|     99|	   ((CUR == '<') && (NXT(1) == '?'))) {
  ------------------
  |  |  304|     92|#define CUR (*ctxt->input->cur)
  ------------------
              	   ((CUR == '<') && (NXT(1) == '?'))) {
  ------------------
  |  |  285|     79|#define NXT(val) ctxt->input->cur[(val)]
  ------------------
  |  Branch (4872:6): [True: 79, False: 13]
  |  Branch (4872:22): [True: 1, False: 78]
  ------------------
 4873|      8|        htmlParseComment(ctxt);
 4874|      8|        htmlParsePI(ctxt);
 4875|      8|	SKIP_BLANKS;
  ------------------
  |  |  300|      8|#define SKIP_BLANKS htmlSkipBlankChars(ctxt)
  ------------------
 4876|      8|    }
 4877|       |
 4878|       |
 4879|       |    /*
 4880|       |     * Then possibly doc type declaration(s) and more Misc
 4881|       |     * (doctypedecl Misc*)?
 4882|       |     */
 4883|     91|    if ((CUR == '<') && (NXT(1) == '!') &&
  ------------------
  |  |  304|     91|#define CUR (*ctxt->input->cur)
  ------------------
                  if ((CUR == '<') && (NXT(1) == '!') &&
  ------------------
  |  |  285|     78|#define NXT(val) ctxt->input->cur[(val)]
  ------------------
  |  Branch (4883:9): [True: 78, False: 13]
  |  Branch (4883:25): [True: 18, False: 60]
  ------------------
 4884|     91|	(UPP(2) == 'D') && (UPP(3) == 'O') &&
  ------------------
  |  |  287|     18|#define UPP(val) (toupper(ctxt->input->cur[(val)]))
  ------------------
              	(UPP(2) == 'D') && (UPP(3) == 'O') &&
  ------------------
  |  |  287|     18|#define UPP(val) (toupper(ctxt->input->cur[(val)]))
  ------------------
  |  Branch (4884:2): [True: 18, False: 0]
  |  Branch (4884:21): [True: 18, False: 0]
  ------------------
 4885|     91|	(UPP(4) == 'C') && (UPP(5) == 'T') &&
  ------------------
  |  |  287|     18|#define UPP(val) (toupper(ctxt->input->cur[(val)]))
  ------------------
              	(UPP(4) == 'C') && (UPP(5) == 'T') &&
  ------------------
  |  |  287|     18|#define UPP(val) (toupper(ctxt->input->cur[(val)]))
  ------------------
  |  Branch (4885:2): [True: 18, False: 0]
  |  Branch (4885:21): [True: 18, False: 0]
  ------------------
 4886|     91|	(UPP(6) == 'Y') && (UPP(7) == 'P') &&
  ------------------
  |  |  287|     18|#define UPP(val) (toupper(ctxt->input->cur[(val)]))
  ------------------
              	(UPP(6) == 'Y') && (UPP(7) == 'P') &&
  ------------------
  |  |  287|     18|#define UPP(val) (toupper(ctxt->input->cur[(val)]))
  ------------------
  |  Branch (4886:2): [True: 18, False: 0]
  |  Branch (4886:21): [True: 18, False: 0]
  ------------------
 4887|     91|	(UPP(8) == 'E')) {
  ------------------
  |  |  287|     18|#define UPP(val) (toupper(ctxt->input->cur[(val)]))
  ------------------
  |  Branch (4887:2): [True: 18, False: 0]
  ------------------
 4888|     18|	htmlParseDocTypeDecl(ctxt);
 4889|     18|    }
 4890|     91|    SKIP_BLANKS;
  ------------------
  |  |  300|     91|#define SKIP_BLANKS htmlSkipBlankChars(ctxt)
  ------------------
 4891|       |
 4892|       |    /*
 4893|       |     * Parse possible comments and PIs before any content
 4894|       |     */
 4895|    102|    while (((CUR == '<') && (NXT(1) == '!') &&
  ------------------
  |  |  304|    102|#define CUR (*ctxt->input->cur)
  ------------------
                  while (((CUR == '<') && (NXT(1) == '!') &&
  ------------------
  |  |  285|     89|#define NXT(val) ctxt->input->cur[(val)]
  ------------------
  |  Branch (4895:13): [True: 89, False: 13]
  |  Branch (4895:29): [True: 10, False: 79]
  ------------------
 4896|    102|            (NXT(2) == '-') && (NXT(3) == '-')) ||
  ------------------
  |  |  285|     10|#define NXT(val) ctxt->input->cur[(val)]
  ------------------
                          (NXT(2) == '-') && (NXT(3) == '-')) ||
  ------------------
  |  |  285|     10|#define NXT(val) ctxt->input->cur[(val)]
  ------------------
  |  Branch (4896:13): [True: 10, False: 0]
  |  Branch (4896:32): [True: 10, False: 0]
  ------------------
 4897|    102|	   ((CUR == '<') && (NXT(1) == '?'))) {
  ------------------
  |  |  304|     92|#define CUR (*ctxt->input->cur)
  ------------------
              	   ((CUR == '<') && (NXT(1) == '?'))) {
  ------------------
  |  |  285|     79|#define NXT(val) ctxt->input->cur[(val)]
  ------------------
  |  Branch (4897:6): [True: 79, False: 13]
  |  Branch (4897:22): [True: 1, False: 78]
  ------------------
 4898|     11|        htmlParseComment(ctxt);
 4899|     11|        htmlParsePI(ctxt);
 4900|     11|	SKIP_BLANKS;
  ------------------
  |  |  300|     11|#define SKIP_BLANKS htmlSkipBlankChars(ctxt)
  ------------------
 4901|     11|    }
 4902|       |
 4903|       |    /*
 4904|       |     * Time to start parsing the tree itself
 4905|       |     */
 4906|     91|    htmlParseContentInternal(ctxt);
 4907|       |
 4908|       |    /*
 4909|       |     * autoclose
 4910|       |     */
 4911|     91|    if (CUR == 0)
  ------------------
  |  |  304|     91|#define CUR (*ctxt->input->cur)
  ------------------
  |  Branch (4911:9): [True: 90, False: 1]
  ------------------
 4912|     90|	htmlAutoCloseOnEnd(ctxt);
 4913|       |
 4914|       |
 4915|       |    /*
 4916|       |     * SAX: end of the document processing.
 4917|       |     */
 4918|     91|    if ((ctxt->sax) && (ctxt->sax->endDocument != NULL))
  ------------------
  |  Branch (4918:9): [True: 91, False: 0]
  |  Branch (4918:24): [True: 91, False: 0]
  ------------------
 4919|     91|        ctxt->sax->endDocument(ctxt->userData);
 4920|       |
 4921|     91|    if ((!(ctxt->options & HTML_PARSE_NODEFDTD)) && (ctxt->myDoc != NULL)) {
  ------------------
  |  Branch (4921:9): [True: 88, False: 3]
  |  Branch (4921:53): [True: 87, False: 1]
  ------------------
 4922|     87|	dtd = xmlGetIntSubset(ctxt->myDoc);
 4923|     87|	if (dtd == NULL)
  ------------------
  |  Branch (4923:6): [True: 70, False: 17]
  ------------------
 4924|     70|	    ctxt->myDoc->intSubset =
 4925|     70|		xmlCreateIntSubset(ctxt->myDoc, BAD_CAST "html",
  ------------------
  |  |   35|     70|#define BAD_CAST (xmlChar *)
  ------------------
 4926|     70|		    BAD_CAST "-//W3C//DTD HTML 4.0 Transitional//EN",
  ------------------
  |  |   35|     70|#define BAD_CAST (xmlChar *)
  ------------------
 4927|     70|		    BAD_CAST "http://www.w3.org/TR/REC-html40/loose.dtd");
  ------------------
  |  |   35|     70|#define BAD_CAST (xmlChar *)
  ------------------
 4928|     87|    }
 4929|     91|    if (! ctxt->wellFormed) return(-1);
  ------------------
  |  Branch (4929:9): [True: 56, False: 35]
  ------------------
 4930|     35|    return(0);
 4931|     91|}
htmlFreeParserCtxt:
 5064|     98|{
 5065|     98|    xmlFreeParserCtxt(ctxt);
 5066|     98|}
htmlNewParserCtxt:
 5078|     97|{
 5079|     97|    return(htmlNewSAXParserCtxt(NULL, NULL));
 5080|     97|}
htmlNewSAXParserCtxt:
 5095|    193|{
 5096|    193|    xmlParserCtxtPtr ctxt;
 5097|       |
 5098|    193|    ctxt = (xmlParserCtxtPtr) xmlMalloc(sizeof(xmlParserCtxt));
 5099|    193|    if (ctxt == NULL) {
  ------------------
  |  Branch (5099:9): [True: 2, False: 191]
  ------------------
 5100|      2|        htmlErrMemory(NULL, "NewParserCtxt: out of memory\n");
 5101|      2|	return(NULL);
 5102|      2|    }
 5103|    191|    memset(ctxt, 0, sizeof(xmlParserCtxt));
 5104|    191|    if (htmlInitParserCtxt(ctxt, sax, userData) < 0) {
  ------------------
  |  Branch (5104:9): [True: 6, False: 185]
  ------------------
 5105|      6|        htmlFreeParserCtxt(ctxt);
 5106|      6|	return(NULL);
 5107|      6|    }
 5108|    185|    return(ctxt);
 5109|    191|}
htmlCreateMemoryParserCtxt:
 5121|     99|htmlCreateMemoryParserCtxt(const char *buffer, int size) {
 5122|     99|    xmlParserCtxtPtr ctxt;
 5123|     99|    xmlParserInputPtr input;
 5124|     99|    xmlParserInputBufferPtr buf;
 5125|       |
 5126|     99|    if (buffer == NULL)
  ------------------
  |  Branch (5126:9): [True: 0, False: 99]
  ------------------
 5127|      0|	return(NULL);
 5128|     99|    if (size <= 0)
  ------------------
  |  Branch (5128:9): [True: 2, False: 97]
  ------------------
 5129|      2|	return(NULL);
 5130|       |
 5131|     97|    ctxt = htmlNewParserCtxt();
 5132|     97|    if (ctxt == NULL)
  ------------------
  |  Branch (5132:9): [True: 4, False: 93]
  ------------------
 5133|      4|	return(NULL);
 5134|       |
 5135|     93|    buf = xmlParserInputBufferCreateMem(buffer, size, XML_CHAR_ENCODING_NONE);
 5136|     93|    if (buf == NULL) {
  ------------------
  |  Branch (5136:9): [True: 2, False: 91]
  ------------------
 5137|      2|	xmlFreeParserCtxt(ctxt);
 5138|      2|        return(NULL);
 5139|      2|    }
 5140|       |
 5141|     91|    input = xmlNewInputStream(ctxt);
 5142|     91|    if (input == NULL) {
  ------------------
  |  Branch (5142:9): [True: 0, False: 91]
  ------------------
 5143|      0|	xmlFreeParserInputBuffer(buf);
 5144|      0|	xmlFreeParserCtxt(ctxt);
 5145|      0|	return(NULL);
 5146|      0|    }
 5147|       |
 5148|     91|    input->filename = NULL;
 5149|     91|    input->buf = buf;
 5150|     91|    xmlBufResetInput(buf->buffer, input);
 5151|       |
 5152|     91|    inputPush(ctxt, input);
 5153|     91|    return(ctxt);
 5154|     91|}
htmlParseChunk:
 5904|  3.34k|              int terminate) {
 5905|  3.34k|    if ((ctxt == NULL) || (ctxt->input == NULL)) {
  ------------------
  |  Branch (5905:9): [True: 0, False: 3.34k]
  |  Branch (5905:27): [True: 0, False: 3.34k]
  ------------------
 5906|      0|	htmlParseErr(ctxt, XML_ERR_INTERNAL_ERROR,
 5907|      0|		     "htmlParseChunk: context error\n", NULL, NULL);
 5908|      0|	return(XML_ERR_INTERNAL_ERROR);
 5909|      0|    }
 5910|  3.34k|    if ((size > 0) && (chunk != NULL) && (ctxt->input != NULL) &&
  ------------------
  |  Branch (5910:9): [True: 3.24k, False: 92]
  |  Branch (5910:23): [True: 3.24k, False: 0]
  |  Branch (5910:42): [True: 3.24k, False: 0]
  ------------------
 5911|  3.34k|        (ctxt->input->buf != NULL) && (ctxt->instate != XML_PARSER_EOF))  {
  ------------------
  |  Branch (5911:9): [True: 3.24k, False: 0]
  |  Branch (5911:39): [True: 3.24k, False: 1]
  ------------------
 5912|  3.24k|	size_t pos = ctxt->input->cur - ctxt->input->base;
 5913|  3.24k|	int res;
 5914|       |
 5915|  3.24k|	res = xmlParserInputBufferPush(ctxt->input->buf, size, chunk);
 5916|  3.24k|        xmlBufUpdateInput(ctxt->input->buf->buffer, ctxt->input, pos);
 5917|  3.24k|	if (res < 0) {
  ------------------
  |  Branch (5917:6): [True: 0, False: 3.24k]
  ------------------
 5918|      0|            htmlParseErr(ctxt, ctxt->input->buf->error,
 5919|      0|                         "xmlParserInputBufferPush failed", NULL, NULL);
 5920|      0|            xmlHaltParser(ctxt);
 5921|      0|	    return (ctxt->errNo);
 5922|      0|	}
 5923|  3.24k|    }
 5924|  3.34k|    htmlParseTryOrFinish(ctxt, terminate);
 5925|  3.34k|    if (terminate) {
  ------------------
  |  Branch (5925:9): [True: 92, False: 3.24k]
  ------------------
 5926|     92|	if ((ctxt->instate != XML_PARSER_EOF) &&
  ------------------
  |  Branch (5926:6): [True: 1, False: 91]
  ------------------
 5927|     92|	    (ctxt->instate != XML_PARSER_EPILOG) &&
  ------------------
  |  Branch (5927:6): [True: 0, False: 1]
  ------------------
 5928|     92|	    (ctxt->instate != XML_PARSER_MISC)) {
  ------------------
  |  Branch (5928:6): [True: 0, False: 0]
  ------------------
 5929|      0|	    ctxt->errNo = XML_ERR_DOCUMENT_END;
 5930|      0|	    ctxt->wellFormed = 0;
 5931|      0|	}
 5932|     92|	if (ctxt->instate != XML_PARSER_EOF) {
  ------------------
  |  Branch (5932:6): [True: 1, False: 91]
  ------------------
 5933|      1|	    if ((ctxt->sax) && (ctxt->sax->endDocument != NULL))
  ------------------
  |  Branch (5933:10): [True: 1, False: 0]
  |  Branch (5933:25): [True: 1, False: 0]
  ------------------
 5934|      1|		ctxt->sax->endDocument(ctxt->userData);
 5935|      1|	}
 5936|     92|	ctxt->instate = XML_PARSER_EOF;
 5937|     92|    }
 5938|  3.34k|    return((xmlParserErrors) ctxt->errNo);
 5939|  3.34k|}
htmlCreatePushParserCtxt:
 5965|     99|			 xmlCharEncoding enc) {
 5966|     99|    htmlParserCtxtPtr ctxt;
 5967|     99|    htmlParserInputPtr inputStream;
 5968|     99|    xmlParserInputBufferPtr buf;
 5969|       |
 5970|     99|    xmlInitParser();
 5971|       |
 5972|     99|    buf = xmlAllocParserInputBuffer(enc);
 5973|     99|    if (buf == NULL) return(NULL);
  ------------------
  |  Branch (5973:9): [True: 3, False: 96]
  ------------------
 5974|       |
 5975|     96|    ctxt = htmlNewSAXParserCtxt(sax, user_data);
 5976|     96|    if (ctxt == NULL) {
  ------------------
  |  Branch (5976:9): [True: 4, False: 92]
  ------------------
 5977|      4|	xmlFreeParserInputBuffer(buf);
 5978|      4|	return(NULL);
 5979|      4|    }
 5980|     92|    if (filename == NULL) {
  ------------------
  |  Branch (5980:9): [True: 92, False: 0]
  ------------------
 5981|     92|	ctxt->directory = NULL;
 5982|     92|    } else {
 5983|      0|        ctxt->directory = xmlParserGetDirectory(filename);
 5984|      0|    }
 5985|       |
 5986|     92|    inputStream = htmlNewInputStream(ctxt);
 5987|     92|    if (inputStream == NULL) {
  ------------------
  |  Branch (5987:9): [True: 0, False: 92]
  ------------------
 5988|      0|	xmlFreeParserCtxt(ctxt);
 5989|      0|	xmlFreeParserInputBuffer(buf);
 5990|      0|	return(NULL);
 5991|      0|    }
 5992|       |
 5993|     92|    if (filename == NULL)
  ------------------
  |  Branch (5993:9): [True: 92, False: 0]
  ------------------
 5994|     92|	inputStream->filename = NULL;
 5995|      0|    else
 5996|      0|	inputStream->filename = (char *)
 5997|      0|	    xmlCanonicPath((const xmlChar *) filename);
 5998|     92|    inputStream->buf = buf;
 5999|     92|    xmlBufResetInput(buf->buffer, inputStream);
 6000|       |
 6001|     92|    inputPush(ctxt, inputStream);
 6002|       |
 6003|     92|    if ((size > 0) && (chunk != NULL) && (ctxt->input != NULL) &&
  ------------------
  |  Branch (6003:9): [True: 0, False: 92]
  |  Branch (6003:23): [True: 0, False: 0]
  |  Branch (6003:42): [True: 0, False: 0]
  ------------------
 6004|     92|        (ctxt->input->buf != NULL))  {
  ------------------
  |  Branch (6004:9): [True: 0, False: 0]
  ------------------
 6005|      0|	size_t pos = ctxt->input->cur - ctxt->input->base;
 6006|      0|        int res;
 6007|       |
 6008|      0|	res = xmlParserInputBufferPush(ctxt->input->buf, size, chunk);
 6009|      0|        xmlBufUpdateInput(ctxt->input->buf->buffer, ctxt->input, pos);
 6010|      0|        if (res < 0) {
  ------------------
  |  Branch (6010:13): [True: 0, False: 0]
  ------------------
 6011|      0|            htmlParseErr(ctxt, ctxt->input->buf->error,
 6012|      0|                         "xmlParserInputBufferPush failed\n", NULL, NULL);
 6013|      0|            xmlHaltParser(ctxt);
 6014|      0|        }
 6015|      0|    }
 6016|     92|    ctxt->progressive = 1;
 6017|       |
 6018|     92|    return(ctxt);
 6019|     92|}
htmlCtxtUseOptions:
 6454|    183|{
 6455|    183|    if (ctxt == NULL)
  ------------------
  |  Branch (6455:9): [True: 0, False: 183]
  ------------------
 6456|      0|        return(-1);
 6457|       |
 6458|    183|    if (options & HTML_PARSE_NOWARNING) {
  ------------------
  |  Branch (6458:9): [True: 4, False: 179]
  ------------------
 6459|      4|        ctxt->sax->warning = NULL;
 6460|      4|        ctxt->vctxt.warning = NULL;
 6461|      4|        options -= XML_PARSE_NOWARNING;
 6462|      4|	ctxt->options |= XML_PARSE_NOWARNING;
 6463|      4|    }
 6464|    183|    if (options & HTML_PARSE_NOERROR) {
  ------------------
  |  Branch (6464:9): [True: 7, False: 176]
  ------------------
 6465|      7|        ctxt->sax->error = NULL;
 6466|      7|        ctxt->vctxt.error = NULL;
 6467|      7|        ctxt->sax->fatalError = NULL;
 6468|      7|        options -= XML_PARSE_NOERROR;
 6469|      7|	ctxt->options |= XML_PARSE_NOERROR;
 6470|      7|    }
 6471|    183|    if (options & HTML_PARSE_PEDANTIC) {
  ------------------
  |  Branch (6471:9): [True: 0, False: 183]
  ------------------
 6472|      0|        ctxt->pedantic = 1;
 6473|      0|        options -= XML_PARSE_PEDANTIC;
 6474|      0|	ctxt->options |= XML_PARSE_PEDANTIC;
 6475|      0|    } else
 6476|    183|        ctxt->pedantic = 0;
 6477|    183|    if (options & XML_PARSE_NOBLANKS) {
  ------------------
  |  Branch (6477:9): [True: 3, False: 180]
  ------------------
 6478|      3|        ctxt->keepBlanks = 0;
 6479|      3|        ctxt->sax->ignorableWhitespace = xmlSAX2IgnorableWhitespace;
 6480|      3|        options -= XML_PARSE_NOBLANKS;
 6481|      3|	ctxt->options |= XML_PARSE_NOBLANKS;
 6482|      3|    } else
 6483|    180|        ctxt->keepBlanks = 1;
 6484|    183|    if (options & HTML_PARSE_RECOVER) {
  ------------------
  |  Branch (6484:9): [True: 6, False: 177]
  ------------------
 6485|      6|        ctxt->recovery = 1;
 6486|      6|	options -= HTML_PARSE_RECOVER;
 6487|      6|    } else
 6488|    177|        ctxt->recovery = 0;
 6489|    183|    if (options & HTML_PARSE_COMPACT) {
  ------------------
  |  Branch (6489:9): [True: 0, False: 183]
  ------------------
 6490|      0|	ctxt->options |= HTML_PARSE_COMPACT;
 6491|      0|        options -= HTML_PARSE_COMPACT;
 6492|      0|    }
 6493|    183|    if (options & XML_PARSE_HUGE) {
  ------------------
  |  Branch (6493:9): [True: 3, False: 180]
  ------------------
 6494|      3|	ctxt->options |= XML_PARSE_HUGE;
 6495|      3|        options -= XML_PARSE_HUGE;
 6496|      3|    }
 6497|    183|    if (options & HTML_PARSE_NODEFDTD) {
  ------------------
  |  Branch (6497:9): [True: 7, False: 176]
  ------------------
 6498|      7|	ctxt->options |= HTML_PARSE_NODEFDTD;
 6499|      7|        options -= HTML_PARSE_NODEFDTD;
 6500|      7|    }
 6501|    183|    if (options & HTML_PARSE_IGNORE_ENC) {
  ------------------
  |  Branch (6501:9): [True: 3, False: 180]
  ------------------
 6502|      3|	ctxt->options |= HTML_PARSE_IGNORE_ENC;
 6503|      3|        options -= HTML_PARSE_IGNORE_ENC;
 6504|      3|    }
 6505|    183|    if (options & HTML_PARSE_NOIMPLIED) {
  ------------------
  |  Branch (6505:9): [True: 7, False: 176]
  ------------------
 6506|      7|        ctxt->options |= HTML_PARSE_NOIMPLIED;
 6507|      7|        options -= HTML_PARSE_NOIMPLIED;
 6508|      7|    }
 6509|    183|    ctxt->dictNames = 0;
 6510|    183|    ctxt->linenumbers = 1;
 6511|    183|    return (options);
 6512|    183|}
htmlReadMemory:
 6620|     99|{
 6621|     99|    htmlParserCtxtPtr ctxt;
 6622|       |
 6623|     99|    xmlInitParser();
 6624|     99|    ctxt = htmlCreateMemoryParserCtxt(buffer, size);
 6625|     99|    if (ctxt == NULL)
  ------------------
  |  Branch (6625:9): [True: 8, False: 91]
  ------------------
 6626|      8|        return (NULL);
 6627|     91|    return (htmlDoRead(ctxt, URL, encoding, options, 0));
 6628|     99|}
HTMLparser.c:htmlCompareTags:
 1375|   138k|htmlCompareTags(const void *key, const void *member) {
 1376|   138k|    const xmlChar *tag = (const xmlChar *) key;
 1377|   138k|    const htmlElemDesc *desc = (const htmlElemDesc *) member;
 1378|       |
 1379|   138k|    return(xmlStrcasecmp(tag, BAD_CAST desc->name));
  ------------------
  |  |   35|   138k|#define BAD_CAST (xmlChar *)
  ------------------
 1380|   138k|}
HTMLparser.c:htmlCheckAutoClose:
 1443|  19.9k|{
 1444|  19.9k|    htmlStartCloseEntry key;
 1445|  19.9k|    void *res;
 1446|       |
 1447|  19.9k|    key.oldTag = (const char *) oldtag;
 1448|  19.9k|    key.newTag = (const char *) newtag;
 1449|  19.9k|    res = bsearch(&key, htmlStartClose,
 1450|  19.9k|            sizeof(htmlStartClose) / sizeof(htmlStartCloseEntry),
 1451|  19.9k|            sizeof(htmlStartCloseEntry), htmlCompareStartClose);
 1452|  19.9k|    return(res != NULL);
 1453|  19.9k|}
HTMLparser.c:htmlCompareStartClose:
 1419|   158k|htmlCompareStartClose(const void *vkey, const void *member) {
 1420|   158k|    const htmlStartCloseEntry *key = (const htmlStartCloseEntry *) vkey;
 1421|   158k|    const htmlStartCloseEntry *entry = (const htmlStartCloseEntry *) member;
 1422|   158k|    int ret;
 1423|       |
 1424|   158k|    ret = strcmp(key->oldTag, entry->oldTag);
 1425|   158k|    if (ret == 0)
  ------------------
  |  Branch (1425:9): [True: 34.1k, False: 124k]
  ------------------
 1426|  34.1k|        ret = strcmp(key->newTag, entry->newTag);
 1427|       |
 1428|   158k|    return(ret);
 1429|   158k|}
HTMLparser.c:htmlErrMemory:
   62|     14|{
   63|     14|    if ((ctxt != NULL) && (ctxt->disableSAX != 0) &&
  ------------------
  |  Branch (63:9): [True: 4, False: 10]
  |  Branch (63:27): [True: 0, False: 4]
  ------------------
   64|     14|        (ctxt->instate == XML_PARSER_EOF))
  ------------------
  |  Branch (64:9): [True: 0, False: 0]
  ------------------
   65|      0|	return;
   66|     14|    if (ctxt != NULL) {
  ------------------
  |  Branch (66:9): [True: 4, False: 10]
  ------------------
   67|      4|        ctxt->errNo = XML_ERR_NO_MEMORY;
   68|      4|        ctxt->instate = XML_PARSER_EOF;
   69|      4|        ctxt->disableSAX = 1;
   70|      4|    }
   71|     14|    if (extra)
  ------------------
  |  Branch (71:9): [True: 10, False: 4]
  ------------------
   72|     10|        __xmlRaiseError(NULL, NULL, NULL, ctxt, NULL, XML_FROM_PARSER,
   73|     10|                        XML_ERR_NO_MEMORY, XML_ERR_FATAL, NULL, 0, extra,
   74|     10|                        NULL, NULL, 0, 0,
   75|     10|                        "Memory allocation failed : %s\n", extra);
   76|      4|    else
   77|      4|        __xmlRaiseError(NULL, NULL, NULL, ctxt, NULL, XML_FROM_PARSER,
   78|      4|                        XML_ERR_NO_MEMORY, XML_ERR_FATAL, NULL, 0, NULL,
   79|      4|                        NULL, NULL, 0, 0, "Memory allocation failed\n");
   80|     14|}
HTMLparser.c:htmlParseName:
 2600|  1.51k|htmlParseName(htmlParserCtxtPtr ctxt) {
 2601|  1.51k|    const xmlChar *in;
 2602|  1.51k|    const xmlChar *ret;
 2603|  1.51k|    int count = 0;
 2604|       |
 2605|  1.51k|    GROW;
  ------------------
  |  |  296|  1.51k|#define GROW if ((ctxt->progressive == 0) &&				\
  |  |  ------------------
  |  |  |  Branch (296:18): [True: 742, False: 777]
  |  |  ------------------
  |  |  297|  1.51k|		 (ctxt->input->end - ctxt->input->cur < INPUT_CHUNK))	\
  |  |  ------------------
  |  |  |  |   97|    742|#define INPUT_CHUNK	250
  |  |  ------------------
  |  |  |  Branch (297:4): [True: 22, False: 720]
  |  |  ------------------
  |  |  298|  1.51k|	xmlParserGrow(ctxt)
  ------------------
 2606|       |
 2607|       |    /*
 2608|       |     * Accelerator for simple ASCII names
 2609|       |     */
 2610|  1.51k|    in = ctxt->input->cur;
 2611|  1.51k|    if (((*in >= 0x61) && (*in <= 0x7A)) ||
  ------------------
  |  Branch (2611:10): [True: 1.00k, False: 517]
  |  Branch (2611:27): [True: 1.00k, False: 1]
  ------------------
 2612|  1.51k|	((*in >= 0x41) && (*in <= 0x5A)) ||
  ------------------
  |  Branch (2612:3): [True: 495, False: 23]
  |  Branch (2612:20): [True: 486, False: 9]
  ------------------
 2613|  1.51k|	(*in == '_') || (*in == ':')) {
  ------------------
  |  Branch (2613:2): [True: 8, False: 24]
  |  Branch (2613:18): [True: 3, False: 21]
  ------------------
 2614|  1.49k|	in++;
 2615|  7.54k|	while (((*in >= 0x61) && (*in <= 0x7A)) ||
  ------------------
  |  Branch (2615:10): [True: 5.54k, False: 2.00k]
  |  Branch (2615:27): [True: 5.53k, False: 7]
  ------------------
 2616|  7.54k|	       ((*in >= 0x41) && (*in <= 0x5A)) ||
  ------------------
  |  Branch (2616:10): [True: 515, False: 1.49k]
  |  Branch (2616:27): [True: 500, False: 15]
  ------------------
 2617|  7.54k|	       ((*in >= 0x30) && (*in <= 0x39)) ||
  ------------------
  |  Branch (2617:10): [True: 1.45k, False: 50]
  |  Branch (2617:27): [True: 0, False: 1.45k]
  ------------------
 2618|  7.54k|	       (*in == '_') || (*in == '-') ||
  ------------------
  |  Branch (2618:9): [True: 8, False: 1.50k]
  |  Branch (2618:25): [True: 2, False: 1.49k]
  ------------------
 2619|  7.54k|	       (*in == ':') || (*in == '.'))
  ------------------
  |  Branch (2619:9): [True: 0, False: 1.49k]
  |  Branch (2619:25): [True: 0, False: 1.49k]
  ------------------
 2620|  6.04k|	    in++;
 2621|       |
 2622|  1.49k|	if (in == ctxt->input->end)
  ------------------
  |  Branch (2622:6): [True: 0, False: 1.49k]
  ------------------
 2623|      0|	    return(NULL);
 2624|       |
 2625|  1.49k|	if ((*in > 0) && (*in < 0x80)) {
  ------------------
  |  Branch (2625:6): [True: 1.49k, False: 0]
  |  Branch (2625:19): [True: 1.49k, False: 7]
  ------------------
 2626|  1.49k|	    count = in - ctxt->input->cur;
 2627|  1.49k|	    ret = xmlDictLookup(ctxt->dict, ctxt->input->cur, count);
 2628|  1.49k|	    ctxt->input->cur = in;
 2629|  1.49k|	    ctxt->input->col += count;
 2630|  1.49k|	    return(ret);
 2631|  1.49k|	}
 2632|  1.49k|    }
 2633|     28|    return(htmlParseNameComplex(ctxt));
 2634|  1.51k|}
HTMLparser.c:htmlParseNameComplex:
 2637|     35|htmlParseNameComplex(xmlParserCtxtPtr ctxt) {
 2638|     35|    int len = 0, l;
 2639|     35|    int c;
 2640|     35|    int maxLength = (ctxt->options & XML_PARSE_HUGE) ?
  ------------------
  |  Branch (2640:21): [True: 0, False: 35]
  ------------------
 2641|      0|                    XML_MAX_TEXT_LENGTH :
  ------------------
  |  |   42|      0|#define XML_MAX_TEXT_LENGTH 10000000
  ------------------
 2642|     35|                    XML_MAX_NAME_LENGTH;
  ------------------
  |  |   61|     35|#define XML_MAX_NAME_LENGTH 50000
  ------------------
 2643|     35|    const xmlChar *base = ctxt->input->base;
 2644|       |
 2645|       |    /*
 2646|       |     * Handler for more complex cases
 2647|       |     */
 2648|     35|    c = CUR_CHAR(l);
  ------------------
  |  |  323|     35|#define CUR_CHAR(l) htmlCurrentChar(ctxt, &l)
  ------------------
 2649|     35|    if ((c == ' ') || (c == '>') || (c == '/') || /* accelerators */
  ------------------
  |  Branch (2649:9): [True: 16, False: 19]
  |  Branch (2649:23): [True: 0, False: 19]
  |  Branch (2649:37): [True: 0, False: 19]
  ------------------
 2650|     35|	(!IS_LETTER(c) && (c != '_') &&
  ------------------
  |  |  240|     38|#define IS_LETTER(c) (IS_BASECHAR(c) || IS_IDEOGRAPHIC(c))
  |  |  ------------------
  |  |  |  |  161|     19|#define IS_BASECHAR(c) xmlIsBaseCharQ(c)
  |  |  |  |  ------------------
  |  |  |  |  |  |   76|     38|#define xmlIsBaseCharQ(c)	(((c) < 0x100) ? \
  |  |  |  |  |  |  ------------------
  |  |  |  |  |  |  |  Branch (76:27): [True: 9, False: 10]
  |  |  |  |  |  |  |  Branch (76:28): [True: 19, False: 0]
  |  |  |  |  |  |  ------------------
  |  |  |  |  |  |   77|     38|				 xmlIsBaseChar_ch((c)) : \
  |  |  |  |  |  |  ------------------
  |  |  |  |  |  |  |  |   64|     19|#define xmlIsBaseChar_ch(c)	(((0x41 <= (c)) && ((c) <= 0x5a)) || \
  |  |  |  |  |  |  |  |  ------------------
  |  |  |  |  |  |  |  |  |  Branch (64:31): [True: 11, False: 8]
  |  |  |  |  |  |  |  |  |  Branch (64:48): [True: 0, False: 11]
  |  |  |  |  |  |  |  |  ------------------
  |  |  |  |  |  |  |  |   65|     19|				 ((0x61 <= (c)) && ((c) <= 0x7a)) || \
  |  |  |  |  |  |  |  |  ------------------
  |  |  |  |  |  |  |  |  |  Branch (65:7): [True: 11, False: 8]
  |  |  |  |  |  |  |  |  |  Branch (65:24): [True: 4, False: 7]
  |  |  |  |  |  |  |  |  ------------------
  |  |  |  |  |  |  |  |   66|     19|				 ((0xc0 <= (c)) && ((c) <= 0xd6)) || \
  |  |  |  |  |  |  |  |  ------------------
  |  |  |  |  |  |  |  |  |  Branch (66:7): [True: 5, False: 10]
  |  |  |  |  |  |  |  |  |  Branch (66:24): [True: 0, False: 5]
  |  |  |  |  |  |  |  |  ------------------
  |  |  |  |  |  |  |  |   67|     19|				 ((0xd8 <= (c)) && ((c) <= 0xf6)) || \
  |  |  |  |  |  |  |  |  ------------------
  |  |  |  |  |  |  |  |  |  Branch (67:7): [True: 5, False: 10]
  |  |  |  |  |  |  |  |  |  Branch (67:24): [True: 5, False: 0]
  |  |  |  |  |  |  |  |  ------------------
  |  |  |  |  |  |  |  |   68|     19|				  (0xf8 <= (c)))
  |  |  |  |  |  |  |  |  ------------------
  |  |  |  |  |  |  |  |  |  Branch (68:7): [True: 0, False: 10]
  |  |  |  |  |  |  |  |  ------------------
  |  |  |  |  |  |  ------------------
  |  |  |  |  |  |   78|     38|				 xmlCharInRange((c), &xmlIsBaseCharGroup))
  |  |  |  |  ------------------
  |  |  ------------------
  |  |               #define IS_LETTER(c) (IS_BASECHAR(c) || IS_IDEOGRAPHIC(c))
  |  |  ------------------
  |  |  |  |  229|     10|#define IS_IDEOGRAPHIC(c) xmlIsIdeographicQ(c)
  |  |  |  |  ------------------
  |  |  |  |  |  |  184|     10|#define xmlIsIdeographicQ(c)	(((c) < 0x100) ? \
  |  |  |  |  |  |  ------------------
  |  |  |  |  |  |  |  Branch (184:30): [True: 0, False: 10]
  |  |  |  |  |  |  |  Branch (184:31): [True: 10, False: 0]
  |  |  |  |  |  |  ------------------
  |  |  |  |  |  |  185|     10|				 0 :\
  |  |  |  |  |  |  186|     10|				(((0x4e00 <= (c)) && ((c) <= 0x9fa5)) || \
  |  |  |  |  |  |  ------------------
  |  |  |  |  |  |  |  Branch (186:7): [True: 0, False: 0]
  |  |  |  |  |  |  |  Branch (186:26): [True: 0, False: 0]
  |  |  |  |  |  |  ------------------
  |  |  |  |  |  |  187|      0|				 ((c) == 0x3007) || \
  |  |  |  |  |  |  ------------------
  |  |  |  |  |  |  |  Branch (187:6): [True: 0, False: 0]
  |  |  |  |  |  |  ------------------
  |  |  |  |  |  |  188|      0|				 ((0x3021 <= (c)) && ((c) <= 0x3029))))
  |  |  |  |  |  |  ------------------
  |  |  |  |  |  |  |  Branch (188:7): [True: 0, False: 0]
  |  |  |  |  |  |  |  Branch (188:26): [True: 0, False: 0]
  |  |  |  |  |  |  ------------------
  |  |  |  |  ------------------
  |  |  ------------------
  ------------------
  |  Branch (2650:20): [True: 10, False: 0]
  ------------------
 2651|     23|         (c != ':'))) {
  ------------------
  |  Branch (2651:10): [True: 7, False: 3]
  ------------------
 2652|     23|	return(NULL);
 2653|     23|    }
 2654|       |
 2655|     17|    while ((c != ' ') && (c != '>') && (c != '/') && /* test bigname.xml */
  ------------------
  |  Branch (2655:12): [True: 17, False: 0]
  |  Branch (2655:26): [True: 17, False: 0]
  |  Branch (2655:40): [True: 17, False: 0]
  ------------------
 2656|     17|	   ((IS_LETTER(c)) || (IS_DIGIT(c)) ||
  ------------------
  |  |  240|     17|#define IS_LETTER(c) (IS_BASECHAR(c) || IS_IDEOGRAPHIC(c))
  |  |  ------------------
  |  |  |  |  161|     17|#define IS_BASECHAR(c) xmlIsBaseCharQ(c)
  |  |  |  |  ------------------
  |  |  |  |  |  |   76|     34|#define xmlIsBaseCharQ(c)	(((c) < 0x100) ? \
  |  |  |  |  |  |  ------------------
  |  |  |  |  |  |  |  Branch (76:27): [True: 9, False: 8]
  |  |  |  |  |  |  |  Branch (76:28): [True: 17, False: 0]
  |  |  |  |  |  |  ------------------
  |  |  |  |  |  |   77|     34|				 xmlIsBaseChar_ch((c)) : \
  |  |  |  |  |  |  ------------------
  |  |  |  |  |  |  |  |   64|     17|#define xmlIsBaseChar_ch(c)	(((0x41 <= (c)) && ((c) <= 0x5a)) || \
  |  |  |  |  |  |  |  |  ------------------
  |  |  |  |  |  |  |  |  |  Branch (64:31): [True: 9, False: 8]
  |  |  |  |  |  |  |  |  |  Branch (64:48): [True: 0, False: 9]
  |  |  |  |  |  |  |  |  ------------------
  |  |  |  |  |  |  |  |   65|     17|				 ((0x61 <= (c)) && ((c) <= 0x7a)) || \
  |  |  |  |  |  |  |  |  ------------------
  |  |  |  |  |  |  |  |  |  Branch (65:7): [True: 9, False: 8]
  |  |  |  |  |  |  |  |  |  Branch (65:24): [True: 4, False: 5]
  |  |  |  |  |  |  |  |  ------------------
  |  |  |  |  |  |  |  |   66|     17|				 ((0xc0 <= (c)) && ((c) <= 0xd6)) || \
  |  |  |  |  |  |  |  |  ------------------
  |  |  |  |  |  |  |  |  |  Branch (66:7): [True: 5, False: 8]
  |  |  |  |  |  |  |  |  |  Branch (66:24): [True: 0, False: 5]
  |  |  |  |  |  |  |  |  ------------------
  |  |  |  |  |  |  |  |   67|     17|				 ((0xd8 <= (c)) && ((c) <= 0xf6)) || \
  |  |  |  |  |  |  |  |  ------------------
  |  |  |  |  |  |  |  |  |  Branch (67:7): [True: 5, False: 8]
  |  |  |  |  |  |  |  |  |  Branch (67:24): [True: 5, False: 0]
  |  |  |  |  |  |  |  |  ------------------
  |  |  |  |  |  |  |  |   68|     17|				  (0xf8 <= (c)))
  |  |  |  |  |  |  |  |  ------------------
  |  |  |  |  |  |  |  |  |  Branch (68:7): [True: 0, False: 8]
  |  |  |  |  |  |  |  |  ------------------
  |  |  |  |  |  |  ------------------
  |  |  |  |  |  |   78|     34|				 xmlCharInRange((c), &xmlIsBaseCharGroup))
  |  |  |  |  ------------------
  |  |  ------------------
  |  |               #define IS_LETTER(c) (IS_BASECHAR(c) || IS_IDEOGRAPHIC(c))
  |  |  ------------------
  |  |  |  |  229|      8|#define IS_IDEOGRAPHIC(c) xmlIsIdeographicQ(c)
  |  |  |  |  ------------------
  |  |  |  |  |  |  184|      8|#define xmlIsIdeographicQ(c)	(((c) < 0x100) ? \
  |  |  |  |  |  |  ------------------
  |  |  |  |  |  |  |  Branch (184:30): [True: 0, False: 8]
  |  |  |  |  |  |  |  Branch (184:31): [True: 8, False: 0]
  |  |  |  |  |  |  ------------------
  |  |  |  |  |  |  185|      8|				 0 :\
  |  |  |  |  |  |  186|      8|				(((0x4e00 <= (c)) && ((c) <= 0x9fa5)) || \
  |  |  |  |  |  |  ------------------
  |  |  |  |  |  |  |  Branch (186:7): [True: 0, False: 0]
  |  |  |  |  |  |  |  Branch (186:26): [True: 0, False: 0]
  |  |  |  |  |  |  ------------------
  |  |  |  |  |  |  187|      0|				 ((c) == 0x3007) || \
  |  |  |  |  |  |  ------------------
  |  |  |  |  |  |  |  Branch (187:6): [True: 0, False: 0]
  |  |  |  |  |  |  ------------------
  |  |  |  |  |  |  188|      0|				 ((0x3021 <= (c)) && ((c) <= 0x3029))))
  |  |  |  |  |  |  ------------------
  |  |  |  |  |  |  |  Branch (188:7): [True: 0, False: 0]
  |  |  |  |  |  |  |  Branch (188:26): [True: 0, False: 0]
  |  |  |  |  |  |  ------------------
  |  |  |  |  ------------------
  |  |  ------------------
  ------------------
              	   ((IS_LETTER(c)) || (IS_DIGIT(c)) ||
  ------------------
  |  |  171|      8|#define IS_DIGIT(c) xmlIsDigitQ(c)
  |  |  ------------------
  |  |  |  |  152|      8|#define xmlIsDigitQ(c)		(((c) < 0x100) ? \
  |  |  |  |  ------------------
  |  |  |  |  |  Branch (152:26): [True: 8, False: 0]
  |  |  |  |  ------------------
  |  |  |  |  153|      8|				 xmlIsDigit_ch((c)) : \
  |  |  |  |  ------------------
  |  |  |  |  |  |  144|      8|#define xmlIsDigit_ch(c)	(((0x30 <= (c)) && ((c) <= 0x39)))
  |  |  |  |  |  |  ------------------
  |  |  |  |  |  |  |  Branch (144:28): [True: 3, False: 5]
  |  |  |  |  |  |  |  Branch (144:45): [True: 0, False: 3]
  |  |  |  |  |  |  ------------------
  |  |  |  |  ------------------
  |  |  |  |  154|      8|				 xmlCharInRange((c), &xmlIsDigitGroup))
  |  |  ------------------
  ------------------
  |  Branch (2656:24): [True: 0, False: 8]
  ------------------
 2657|     17|            (c == '.') || (c == '-') ||
  ------------------
  |  Branch (2657:13): [True: 0, False: 8]
  |  Branch (2657:27): [True: 0, False: 8]
  ------------------
 2658|     17|	    (c == '_') || (c == ':') ||
  ------------------
  |  Branch (2658:6): [True: 0, False: 8]
  |  Branch (2658:20): [True: 3, False: 5]
  ------------------
 2659|     17|	    (IS_COMBINING(c)) ||
  ------------------
  |  |  189|      5|#define IS_COMBINING(c) xmlIsCombiningQ(c)
  |  |  ------------------
  |  |  |  |  132|      5|#define xmlIsCombiningQ(c)	(((c) < 0x100) ? \
  |  |  |  |  ------------------
  |  |  |  |  |  Branch (132:29): [True: 5, False: 0]
  |  |  |  |  ------------------
  |  |  |  |  133|      5|				 0 : \
  |  |  |  |  134|      5|				 xmlCharInRange((c), &xmlIsCombiningGroup))
  |  |  ------------------
  ------------------
  |  Branch (2659:6): [True: 0, False: 5]
  ------------------
 2660|     17|	    (IS_EXTENDER(c)))) {
  ------------------
  |  |  210|      5|#define IS_EXTENDER(c) xmlIsExtenderQ(c)
  |  |  ------------------
  |  |  |  |  172|      5|#define xmlIsExtenderQ(c)	(((c) < 0x100) ? \
  |  |  |  |  ------------------
  |  |  |  |  |  Branch (172:28): [True: 5, False: 0]
  |  |  |  |  ------------------
  |  |  |  |  173|      5|				 xmlIsExtender_ch((c)) : \
  |  |  |  |  ------------------
  |  |  |  |  |  |  164|      5|#define xmlIsExtender_ch(c)	(((c) == 0xb7))
  |  |  |  |  ------------------
  |  |  |  |  174|      5|				 xmlCharInRange((c), &xmlIsExtenderGroup))
  |  |  ------------------
  ------------------
  |  Branch (2660:6): [True: 0, False: 5]
  ------------------
 2661|     12|	len += l;
 2662|     12|        if (len > maxLength) {
  ------------------
  |  Branch (2662:13): [True: 0, False: 12]
  ------------------
 2663|      0|            htmlParseErr(ctxt, XML_ERR_NAME_TOO_LONG, "name too long", NULL, NULL);
 2664|      0|            return(NULL);
 2665|      0|        }
 2666|     12|	NEXTL(l);
  ------------------
  |  |  310|     12|#define NEXTL(l) do {							\
  |  |  311|     12|    if (*(ctxt->input->cur) == '\n') {					\
  |  |  ------------------
  |  |  |  Branch (311:9): [True: 0, False: 12]
  |  |  ------------------
  |  |  312|      0|	ctxt->input->line++; ctxt->input->col = 1;			\
  |  |  313|     12|    } else ctxt->input->col++;						\
  |  |  314|     12|    ctxt->token = 0; ctxt->input->cur += l;				\
  |  |  315|     12|  } while (0)
  |  |  ------------------
  |  |  |  Branch (315:12): [Folded - Ignored]
  |  |  ------------------
  ------------------
 2667|     12|	c = CUR_CHAR(l);
  ------------------
  |  |  323|     12|#define CUR_CHAR(l) htmlCurrentChar(ctxt, &l)
  ------------------
 2668|     12|	if (ctxt->input->base != base) {
  ------------------
  |  Branch (2668:6): [True: 7, False: 5]
  ------------------
 2669|       |	    /*
 2670|       |	     * We changed encoding from an unknown encoding
 2671|       |	     * Input buffer changed location, so we better start again
 2672|       |	     */
 2673|      7|	    return(htmlParseNameComplex(ctxt));
 2674|      7|	}
 2675|     12|    }
 2676|      5|    if (ctxt->instate == XML_PARSER_EOF)
  ------------------
  |  Branch (2676:9): [True: 0, False: 5]
  ------------------
 2677|      0|        return(NULL);
 2678|       |
 2679|      5|    if (ctxt->input->cur - ctxt->input->base < len) {
  ------------------
  |  Branch (2679:9): [True: 0, False: 5]
  ------------------
 2680|       |        /* Sanity check */
 2681|      0|	htmlParseErr(ctxt, XML_ERR_INTERNAL_ERROR,
 2682|      0|                     "unexpected change of input buffer", NULL, NULL);
 2683|      0|        return (NULL);
 2684|      0|    }
 2685|       |
 2686|      5|    return(xmlDictLookup(ctxt->dict, ctxt->input->cur - len, len));
 2687|      5|}
HTMLparser.c:htmlCurrentChar:
  395|   524k|htmlCurrentChar(xmlParserCtxtPtr ctxt, int *len) {
  396|   524k|    const unsigned char *cur;
  397|   524k|    unsigned char c;
  398|   524k|    unsigned int val;
  399|       |
  400|   524k|    if (ctxt->instate == XML_PARSER_EOF)
  ------------------
  |  Branch (400:9): [True: 0, False: 524k]
  ------------------
  401|      0|	return(0);
  402|       |
  403|   524k|    if (ctxt->token != 0) {
  ------------------
  |  Branch (403:9): [True: 0, False: 524k]
  ------------------
  404|      0|	*len = 0;
  405|      0|	return(ctxt->token);
  406|      0|    }
  407|       |
  408|   524k|    if (ctxt->input->end - ctxt->input->cur < INPUT_CHUNK) {
  ------------------
  |  |   97|   524k|#define INPUT_CHUNK	250
  ------------------
  |  Branch (408:9): [True: 191k, False: 332k]
  ------------------
  409|   191k|        xmlParserGrow(ctxt);
  410|   191k|        if (ctxt->instate == XML_PARSER_EOF)
  ------------------
  |  Branch (410:13): [True: 0, False: 191k]
  ------------------
  411|      0|            return(0);
  412|   191k|    }
  413|       |
  414|   524k|    if ((ctxt->input->flags & XML_INPUT_HAS_ENCODING) == 0) {
  ------------------
  |  |   20|   524k|#define XML_INPUT_HAS_ENCODING      (1u << 0)
  ------------------
  |  Branch (414:9): [True: 167k, False: 357k]
  ------------------
  415|   167k|        xmlChar * guess;
  416|   167k|        xmlCharEncodingHandlerPtr handler;
  417|       |
  418|       |        /*
  419|       |         * Assume it's a fixed length encoding (1) with
  420|       |         * a compatible encoding for the ASCII set, since
  421|       |         * HTML constructs only use < 128 chars
  422|       |         */
  423|   167k|        if (*ctxt->input->cur < 0x80) {
  ------------------
  |  Branch (423:13): [True: 167k, False: 45]
  ------------------
  424|   167k|            *len = 1;
  425|   167k|            if ((*ctxt->input->cur == 0) &&
  ------------------
  |  Branch (425:17): [True: 263, False: 167k]
  ------------------
  426|   167k|                (ctxt->input->cur < ctxt->input->end)) {
  ------------------
  |  Branch (426:17): [True: 163, False: 100]
  ------------------
  427|    163|                htmlParseErrInt(ctxt, XML_ERR_INVALID_CHAR,
  428|    163|                                "Char 0x%X out of allowed range\n", 0);
  429|    163|                return(' ');
  430|    163|            }
  431|   167k|            return(*ctxt->input->cur);
  432|   167k|        }
  433|       |
  434|       |        /*
  435|       |         * Humm this is bad, do an automatic flow conversion
  436|       |         */
  437|     45|        guess = htmlFindEncoding(ctxt);
  438|     45|        if (guess == NULL) {
  ------------------
  |  Branch (438:13): [True: 45, False: 0]
  ------------------
  439|     45|            xmlSwitchEncoding(ctxt, XML_CHAR_ENCODING_8859_1);
  440|     45|        } else {
  441|      0|            handler = xmlFindCharEncodingHandler((const char *) guess);
  442|      0|            if (handler != NULL) {
  ------------------
  |  Branch (442:17): [True: 0, False: 0]
  ------------------
  443|       |                /*
  444|       |                 * Don't use UTF-8 encoder which isn't required and
  445|       |                 * can produce invalid UTF-8.
  446|       |                 */
  447|      0|                if (!xmlStrEqual(BAD_CAST handler->name, BAD_CAST "UTF-8"))
  ------------------
  |  |   35|      0|#define BAD_CAST (xmlChar *)
  ------------------
                              if (!xmlStrEqual(BAD_CAST handler->name, BAD_CAST "UTF-8"))
  ------------------
  |  |   35|      0|#define BAD_CAST (xmlChar *)
  ------------------
  |  Branch (447:21): [True: 0, False: 0]
  ------------------
  448|      0|                    xmlSwitchToEncoding(ctxt, handler);
  449|      0|            } else {
  450|      0|                htmlParseErr(ctxt, XML_ERR_INVALID_ENCODING,
  451|      0|                             "Unsupported encoding %s", guess, NULL);
  452|      0|            }
  453|      0|            xmlFree(guess);
  454|      0|        }
  455|     45|        ctxt->input->flags |= XML_INPUT_HAS_ENCODING;
  ------------------
  |  |   20|     45|#define XML_INPUT_HAS_ENCODING      (1u << 0)
  ------------------
  456|     45|    }
  457|       |
  458|       |    /*
  459|       |     * We are supposed to handle UTF8, check it's valid
  460|       |     * From rfc2044: encoding of the Unicode values on UTF-8:
  461|       |     *
  462|       |     * UCS-4 range (hex.)           UTF-8 octet sequence (binary)
  463|       |     * 0000 0000-0000 007F   0xxxxxxx
  464|       |     * 0000 0080-0000 07FF   110xxxxx 10xxxxxx
  465|       |     * 0000 0800-0000 FFFF   1110xxxx 10xxxxxx 10xxxxxx
  466|       |     *
  467|       |     * Check for the 0x110000 limit too
  468|       |     */
  469|   357k|    cur = ctxt->input->cur;
  470|   357k|    c = *cur;
  471|   357k|    if (c & 0x80) {
  ------------------
  |  Branch (471:9): [True: 13.2k, False: 343k]
  ------------------
  472|  13.2k|        size_t avail;
  473|       |
  474|  13.2k|        if ((c & 0x40) == 0)
  ------------------
  |  Branch (474:13): [True: 0, False: 13.2k]
  ------------------
  475|      0|            goto encoding_error;
  476|       |
  477|  13.2k|        avail = ctxt->input->end - ctxt->input->cur;
  478|       |
  479|  13.2k|        if ((avail < 2) || ((cur[1] & 0xc0) != 0x80))
  ------------------
  |  Branch (479:13): [True: 0, False: 13.2k]
  |  Branch (479:28): [True: 0, False: 13.2k]
  ------------------
  480|      0|            goto encoding_error;
  481|  13.2k|        if ((c & 0xe0) == 0xe0) {
  ------------------
  |  Branch (481:13): [True: 0, False: 13.2k]
  ------------------
  482|      0|            if ((avail < 3) || ((cur[2] & 0xc0) != 0x80))
  ------------------
  |  Branch (482:17): [True: 0, False: 0]
  |  Branch (482:32): [True: 0, False: 0]
  ------------------
  483|      0|                goto encoding_error;
  484|      0|            if ((c & 0xf0) == 0xf0) {
  ------------------
  |  Branch (484:17): [True: 0, False: 0]
  ------------------
  485|      0|                if (((c & 0xf8) != 0xf0) ||
  ------------------
  |  Branch (485:21): [True: 0, False: 0]
  ------------------
  486|      0|                    (avail < 4) || ((cur[3] & 0xc0) != 0x80))
  ------------------
  |  Branch (486:21): [True: 0, False: 0]
  |  Branch (486:36): [True: 0, False: 0]
  ------------------
  487|      0|                    goto encoding_error;
  488|       |                /* 4-byte code */
  489|      0|                *len = 4;
  490|      0|                val = (cur[0] & 0x7) << 18;
  491|      0|                val |= (cur[1] & 0x3f) << 12;
  492|      0|                val |= (cur[2] & 0x3f) << 6;
  493|      0|                val |= cur[3] & 0x3f;
  494|      0|                if (val < 0x10000)
  ------------------
  |  Branch (494:21): [True: 0, False: 0]
  ------------------
  495|      0|                    goto encoding_error;
  496|      0|            } else {
  497|       |              /* 3-byte code */
  498|      0|                *len = 3;
  499|      0|                val = (cur[0] & 0xf) << 12;
  500|      0|                val |= (cur[1] & 0x3f) << 6;
  501|      0|                val |= cur[2] & 0x3f;
  502|      0|                if (val < 0x800)
  ------------------
  |  Branch (502:21): [True: 0, False: 0]
  ------------------
  503|      0|                    goto encoding_error;
  504|      0|            }
  505|  13.2k|        } else {
  506|       |          /* 2-byte code */
  507|  13.2k|            *len = 2;
  508|  13.2k|            val = (cur[0] & 0x1f) << 6;
  509|  13.2k|            val |= cur[1] & 0x3f;
  510|  13.2k|            if (val < 0x80)
  ------------------
  |  Branch (510:17): [True: 0, False: 13.2k]
  ------------------
  511|      0|                goto encoding_error;
  512|  13.2k|        }
  513|  13.2k|        if (!IS_CHAR(val)) {
  ------------------
  |  |  125|  13.2k|#define IS_CHAR(c)   xmlIsCharQ(c)
  |  |  ------------------
  |  |  |  |  118|  13.2k|#define xmlIsCharQ(c)		(((c) < 0x100) ? \
  |  |  |  |  ------------------
  |  |  |  |  |  Branch (118:25): [True: 620, False: 12.6k]
  |  |  |  |  ------------------
  |  |  |  |  119|  13.2k|				 xmlIsChar_ch((c)) :\
  |  |  |  |  ------------------
  |  |  |  |  |  |  108|    620|#define xmlIsChar_ch(c)		(((0x9 <= (c)) && ((c) <= 0xa)) || \
  |  |  |  |  |  |  ------------------
  |  |  |  |  |  |  |  Branch (108:28): [True: 620, False: 0]
  |  |  |  |  |  |  |  Branch (108:44): [True: 0, False: 620]
  |  |  |  |  |  |  ------------------
  |  |  |  |  |  |  109|    620|				 ((c) == 0xd) || \
  |  |  |  |  |  |  ------------------
  |  |  |  |  |  |  |  Branch (109:6): [True: 0, False: 620]
  |  |  |  |  |  |  ------------------
  |  |  |  |  |  |  110|    620|				  (0x20 <= (c)))
  |  |  |  |  |  |  ------------------
  |  |  |  |  |  |  |  Branch (110:7): [True: 620, False: 0]
  |  |  |  |  |  |  ------------------
  |  |  |  |  ------------------
  |  |  |  |  120|  13.2k|				(((0x100 <= (c)) && ((c) <= 0xd7ff)) || \
  |  |  |  |  ------------------
  |  |  |  |  |  Branch (120:7): [True: 12.6k, False: 0]
  |  |  |  |  |  Branch (120:25): [True: 12.6k, False: 0]
  |  |  |  |  ------------------
  |  |  |  |  121|  12.6k|				 ((0xe000 <= (c)) && ((c) <= 0xfffd)) || \
  |  |  |  |  ------------------
  |  |  |  |  |  Branch (121:7): [True: 0, False: 0]
  |  |  |  |  |  Branch (121:26): [True: 0, False: 0]
  |  |  |  |  ------------------
  |  |  |  |  122|  12.6k|				 ((0x10000 <= (c)) && ((c) <= 0x10ffff))))
  |  |  |  |  ------------------
  |  |  |  |  |  Branch (122:7): [True: 0, False: 0]
  |  |  |  |  |  Branch (122:27): [True: 0, False: 0]
  |  |  |  |  ------------------
  |  |  ------------------
  ------------------
  |  Branch (513:13): [True: 0, False: 13.2k]
  ------------------
  514|      0|            htmlParseErrInt(ctxt, XML_ERR_INVALID_CHAR,
  515|      0|                            "Char 0x%X out of allowed range\n", val);
  516|      0|        }
  517|  13.2k|        return(val);
  518|   343k|    } else {
  519|   343k|        if ((*ctxt->input->cur == 0) &&
  ------------------
  |  Branch (519:13): [True: 72, False: 343k]
  ------------------
  520|   343k|            (ctxt->input->cur < ctxt->input->end)) {
  ------------------
  |  Branch (520:13): [True: 14, False: 58]
  ------------------
  521|     14|            htmlParseErrInt(ctxt, XML_ERR_INVALID_CHAR,
  522|     14|                            "Char 0x%X out of allowed range\n", 0);
  523|     14|            *len = 1;
  524|     14|            return(' ');
  525|     14|        }
  526|       |        /* 1-byte code */
  527|   343k|        *len = 1;
  528|   343k|        return(*ctxt->input->cur);
  529|   343k|    }
  530|       |
  531|      0|encoding_error:
  532|      0|    {
  533|      0|        char buffer[150];
  534|       |
  535|      0|	if (ctxt->input->end - ctxt->input->cur >= 4) {
  ------------------
  |  Branch (535:6): [True: 0, False: 0]
  ------------------
  536|      0|	    snprintf(buffer, 149, "Bytes: 0x%02X 0x%02X 0x%02X 0x%02X\n",
  537|      0|			    ctxt->input->cur[0], ctxt->input->cur[1],
  538|      0|			    ctxt->input->cur[2], ctxt->input->cur[3]);
  539|      0|	} else {
  540|      0|	    snprintf(buffer, 149, "Bytes: 0x%02X\n", ctxt->input->cur[0]);
  541|      0|	}
  542|      0|	htmlParseErr(ctxt, XML_ERR_INVALID_ENCODING,
  543|      0|		     "Input is not proper UTF-8, indicate encoding !\n",
  544|      0|		     BAD_CAST buffer, NULL);
  ------------------
  |  |   35|      0|#define BAD_CAST (xmlChar *)
  ------------------
  545|      0|    }
  546|       |
  547|      0|    if ((ctxt->input->flags & XML_INPUT_HAS_ENCODING) == 0)
  ------------------
  |  |   20|      0|#define XML_INPUT_HAS_ENCODING      (1u << 0)
  ------------------
  |  Branch (547:9): [True: 0, False: 0]
  ------------------
  548|      0|        xmlSwitchEncoding(ctxt, XML_CHAR_ENCODING_8859_1);
  549|      0|    *len = 1;
  550|      0|    return(*ctxt->input->cur);
  551|   357k|}
HTMLparser.c:htmlFindEncoding:
  344|     45|htmlFindEncoding(xmlParserCtxtPtr ctxt) {
  345|     45|    const xmlChar *start, *cur, *end;
  346|       |
  347|     45|    if ((ctxt == NULL) || (ctxt->input == NULL) ||
  ------------------
  |  Branch (347:9): [True: 0, False: 45]
  |  Branch (347:27): [True: 0, False: 45]
  ------------------
  348|     45|        (ctxt->input->flags & XML_INPUT_HAS_ENCODING))
  ------------------
  |  |   20|     45|#define XML_INPUT_HAS_ENCODING      (1u << 0)
  ------------------
  |  Branch (348:9): [True: 0, False: 45]
  ------------------
  349|      0|        return(NULL);
  350|     45|    if ((ctxt->input->cur == NULL) || (ctxt->input->end == NULL))
  ------------------
  |  Branch (350:9): [True: 0, False: 45]
  |  Branch (350:39): [True: 0, False: 45]
  ------------------
  351|      0|        return(NULL);
  352|       |
  353|     45|    start = ctxt->input->cur;
  354|     45|    end = ctxt->input->end;
  355|       |    /* we also expect the input buffer to be zero terminated */
  356|     45|    if (*end != 0)
  ------------------
  |  Branch (356:9): [True: 0, False: 45]
  ------------------
  357|      0|        return(NULL);
  358|       |
  359|     45|    cur = xmlStrcasestr(start, BAD_CAST "HTTP-EQUIV");
  ------------------
  |  |   35|     45|#define BAD_CAST (xmlChar *)
  ------------------
  360|     45|    if (cur == NULL)
  ------------------
  |  Branch (360:9): [True: 45, False: 0]
  ------------------
  361|     45|        return(NULL);
  362|      0|    cur = xmlStrcasestr(cur, BAD_CAST  "CONTENT");
  ------------------
  |  |   35|      0|#define BAD_CAST (xmlChar *)
  ------------------
  363|      0|    if (cur == NULL)
  ------------------
  |  Branch (363:9): [True: 0, False: 0]
  ------------------
  364|      0|        return(NULL);
  365|      0|    cur = xmlStrcasestr(cur, BAD_CAST  "CHARSET=");
  ------------------
  |  |   35|      0|#define BAD_CAST (xmlChar *)
  ------------------
  366|      0|    if (cur == NULL)
  ------------------
  |  Branch (366:9): [True: 0, False: 0]
  ------------------
  367|      0|        return(NULL);
  368|      0|    cur += 8;
  369|      0|    start = cur;
  370|      0|    while (((*cur >= 'A') && (*cur <= 'Z')) ||
  ------------------
  |  Branch (370:13): [True: 0, False: 0]
  |  Branch (370:30): [True: 0, False: 0]
  ------------------
  371|      0|           ((*cur >= 'a') && (*cur <= 'z')) ||
  ------------------
  |  Branch (371:13): [True: 0, False: 0]
  |  Branch (371:30): [True: 0, False: 0]
  ------------------
  372|      0|           ((*cur >= '0') && (*cur <= '9')) ||
  ------------------
  |  Branch (372:13): [True: 0, False: 0]
  |  Branch (372:30): [True: 0, False: 0]
  ------------------
  373|      0|           (*cur == '-') || (*cur == '_') || (*cur == ':') || (*cur == '/'))
  ------------------
  |  Branch (373:12): [True: 0, False: 0]
  |  Branch (373:29): [True: 0, False: 0]
  |  Branch (373:46): [True: 0, False: 0]
  |  Branch (373:63): [True: 0, False: 0]
  ------------------
  374|      0|           cur++;
  375|      0|    if (cur == start)
  ------------------
  |  Branch (375:9): [True: 0, False: 0]
  ------------------
  376|      0|        return(NULL);
  377|      0|    return(xmlStrndup(start, cur - start));
  378|      0|}
HTMLparser.c:htmlParseErr:
   95|  1.04k|{
   96|  1.04k|    if ((ctxt != NULL) && (ctxt->disableSAX != 0) &&
  ------------------
  |  Branch (96:9): [True: 1.04k, False: 0]
  |  Branch (96:27): [True: 19, False: 1.03k]
  ------------------
   97|  1.04k|        (ctxt->instate == XML_PARSER_EOF))
  ------------------
  |  Branch (97:9): [True: 1, False: 18]
  ------------------
   98|      1|	return;
   99|  1.04k|    if (ctxt != NULL)
  ------------------
  |  Branch (99:9): [True: 1.04k, False: 0]
  ------------------
  100|  1.04k|	ctxt->errNo = error;
  101|  1.04k|    __xmlRaiseError(NULL, NULL, NULL, ctxt, NULL, XML_FROM_HTML, error,
  102|  1.04k|                    XML_ERR_ERROR, NULL, 0,
  103|  1.04k|		    (const char *) str1, (const char *) str2,
  104|  1.04k|		    NULL, 0, 0,
  105|  1.04k|		    msg, str1, str2);
  106|  1.04k|    if (ctxt != NULL)
  ------------------
  |  Branch (106:9): [True: 1.04k, False: 0]
  ------------------
  107|  1.04k|	ctxt->wellFormed = 0;
  108|  1.04k|}
HTMLparser.c:htmlParseErrInt:
  122|    188|{
  123|    188|    if ((ctxt != NULL) && (ctxt->disableSAX != 0) &&
  ------------------
  |  Branch (123:9): [True: 188, False: 0]
  |  Branch (123:27): [True: 0, False: 188]
  ------------------
  124|    188|        (ctxt->instate == XML_PARSER_EOF))
  ------------------
  |  Branch (124:9): [True: 0, False: 0]
  ------------------
  125|      0|	return;
  126|    188|    if (ctxt != NULL)
  ------------------
  |  Branch (126:9): [True: 188, False: 0]
  ------------------
  127|    188|	ctxt->errNo = error;
  128|    188|    __xmlRaiseError(NULL, NULL, NULL, ctxt, NULL, XML_FROM_HTML, error,
  129|    188|                    XML_ERR_ERROR, NULL, 0, NULL, NULL,
  130|    188|		    NULL, val, 0, msg, val);
  131|    188|    if (ctxt != NULL)
  ------------------
  |  Branch (131:9): [True: 188, False: 0]
  ------------------
  132|    188|	ctxt->wellFormed = 0;
  133|    188|}
HTMLparser.c:htmlParseStartTag:
 3840|  13.1k|htmlParseStartTag(htmlParserCtxtPtr ctxt) {
 3841|  13.1k|    const xmlChar *name;
 3842|  13.1k|    const xmlChar *attname;
 3843|  13.1k|    xmlChar *attvalue;
 3844|  13.1k|    const xmlChar **atts;
 3845|  13.1k|    int nbatts = 0;
 3846|  13.1k|    int maxatts;
 3847|  13.1k|    int meta = 0;
 3848|  13.1k|    int i;
 3849|  13.1k|    int discardtag = 0;
 3850|       |
 3851|  13.1k|    if ((ctxt == NULL) || (ctxt->input == NULL)) {
  ------------------
  |  Branch (3851:9): [True: 0, False: 13.1k]
  |  Branch (3851:27): [True: 0, False: 13.1k]
  ------------------
 3852|      0|	htmlParseErr(ctxt, XML_ERR_INTERNAL_ERROR,
 3853|      0|		     "htmlParseStartTag: context error\n", NULL, NULL);
 3854|      0|	return -1;
 3855|      0|    }
 3856|  13.1k|    if (ctxt->instate == XML_PARSER_EOF)
  ------------------
  |  Branch (3856:9): [True: 0, False: 13.1k]
  ------------------
 3857|      0|        return(-1);
 3858|  13.1k|    if (CUR != '<') return -1;
  ------------------
  |  |  304|  13.1k|#define CUR (*ctxt->input->cur)
  ------------------
  |  Branch (3858:9): [True: 0, False: 13.1k]
  ------------------
 3859|  13.1k|    NEXT;
  ------------------
  |  |  305|  13.1k|#define NEXT xmlNextChar(ctxt)
  ------------------
 3860|       |
 3861|  13.1k|    atts = ctxt->atts;
 3862|  13.1k|    maxatts = ctxt->maxatts;
 3863|       |
 3864|  13.1k|    GROW;
  ------------------
  |  |  296|  13.1k|#define GROW if ((ctxt->progressive == 0) &&				\
  |  |  ------------------
  |  |  |  Branch (296:18): [True: 6.42k, False: 6.73k]
  |  |  ------------------
  |  |  297|  13.1k|		 (ctxt->input->end - ctxt->input->cur < INPUT_CHUNK))	\
  |  |  ------------------
  |  |  |  |   97|  6.42k|#define INPUT_CHUNK	250
  |  |  ------------------
  |  |  |  Branch (297:4): [True: 275, False: 6.15k]
  |  |  ------------------
  |  |  298|  13.1k|	xmlParserGrow(ctxt)
  ------------------
 3865|  13.1k|    name = htmlParseHTMLName(ctxt);
 3866|  13.1k|    if (name == NULL) {
  ------------------
  |  Branch (3866:9): [True: 0, False: 13.1k]
  ------------------
 3867|      0|	htmlParseErr(ctxt, XML_ERR_NAME_REQUIRED,
 3868|      0|	             "htmlParseStartTag: invalid element name\n",
 3869|      0|		     NULL, NULL);
 3870|       |	/* Dump the bogus tag like browsers do */
 3871|      0|	while ((CUR != 0) && (CUR != '>') &&
  ------------------
  |  |  304|      0|#define CUR (*ctxt->input->cur)
  ------------------
              	while ((CUR != 0) && (CUR != '>') &&
  ------------------
  |  |  304|      0|#define CUR (*ctxt->input->cur)
  ------------------
  |  Branch (3871:9): [True: 0, False: 0]
  |  Branch (3871:23): [True: 0, False: 0]
  ------------------
 3872|      0|               (ctxt->instate != XML_PARSER_EOF))
  ------------------
  |  Branch (3872:16): [True: 0, False: 0]
  ------------------
 3873|      0|	    NEXT;
  ------------------
  |  |  305|      0|#define NEXT xmlNextChar(ctxt)
  ------------------
 3874|      0|        return -1;
 3875|      0|    }
 3876|  13.1k|    if (xmlStrEqual(name, BAD_CAST"meta"))
  ------------------
  |  |   35|  13.1k|#define BAD_CAST (xmlChar *)
  ------------------
  |  Branch (3876:9): [True: 57, False: 13.1k]
  ------------------
 3877|     57|	meta = 1;
 3878|       |
 3879|       |    /*
 3880|       |     * Check for auto-closure of HTML elements.
 3881|       |     */
 3882|  13.1k|    htmlAutoClose(ctxt, name);
 3883|       |
 3884|       |    /*
 3885|       |     * Check for implied HTML elements.
 3886|       |     */
 3887|  13.1k|    htmlCheckImplied(ctxt, name);
 3888|       |
 3889|       |    /*
 3890|       |     * Avoid html at any level > 0, head at any level != 1
 3891|       |     * or any attempt to recurse body
 3892|       |     */
 3893|  13.1k|    if ((ctxt->nameNr > 0) && (xmlStrEqual(name, BAD_CAST"html"))) {
  ------------------
  |  |   35|  13.0k|#define BAD_CAST (xmlChar *)
  ------------------
  |  Branch (3893:9): [True: 13.0k, False: 132]
  |  Branch (3893:31): [True: 2, False: 13.0k]
  ------------------
 3894|      2|	htmlParseErr(ctxt, XML_HTML_STRUCURE_ERROR,
 3895|      2|	             "htmlParseStartTag: misplaced <html> tag\n",
 3896|      2|		     name, NULL);
 3897|      2|	discardtag = 1;
 3898|      2|	ctxt->depth++;
 3899|      2|    }
 3900|  13.1k|    if ((ctxt->nameNr != 1) &&
  ------------------
  |  Branch (3900:9): [True: 12.9k, False: 190]
  ------------------
 3901|  13.1k|	(xmlStrEqual(name, BAD_CAST"head"))) {
  ------------------
  |  |   35|  12.9k|#define BAD_CAST (xmlChar *)
  ------------------
  |  Branch (3901:2): [True: 3, False: 12.9k]
  ------------------
 3902|      3|	htmlParseErr(ctxt, XML_HTML_STRUCURE_ERROR,
 3903|      3|	             "htmlParseStartTag: misplaced <head> tag\n",
 3904|      3|		     name, NULL);
 3905|      3|	discardtag = 1;
 3906|      3|	ctxt->depth++;
 3907|      3|    }
 3908|  13.1k|    if (xmlStrEqual(name, BAD_CAST"body")) {
  ------------------
  |  |   35|  13.1k|#define BAD_CAST (xmlChar *)
  ------------------
  |  Branch (3908:9): [True: 116, False: 13.0k]
  ------------------
 3909|    116|	int indx;
 3910|    260|	for (indx = 0;indx < ctxt->nameNr;indx++) {
  ------------------
  |  Branch (3910:16): [True: 144, False: 116]
  ------------------
 3911|    144|	    if (xmlStrEqual(ctxt->nameTab[indx], BAD_CAST"body")) {
  ------------------
  |  |   35|    144|#define BAD_CAST (xmlChar *)
  ------------------
  |  Branch (3911:10): [True: 8, False: 136]
  ------------------
 3912|      8|		htmlParseErr(ctxt, XML_HTML_STRUCURE_ERROR,
 3913|      8|		             "htmlParseStartTag: misplaced <body> tag\n",
 3914|      8|			     name, NULL);
 3915|      8|		discardtag = 1;
 3916|      8|		ctxt->depth++;
 3917|      8|	    }
 3918|    144|	}
 3919|    116|    }
 3920|       |
 3921|       |    /*
 3922|       |     * Now parse the attributes, it ends up with the ending
 3923|       |     *
 3924|       |     * (S Attribute)* S?
 3925|       |     */
 3926|  13.1k|    SKIP_BLANKS;
  ------------------
  |  |  300|  13.1k|#define SKIP_BLANKS htmlSkipBlankChars(ctxt)
  ------------------
 3927|  26.8k|    while ((CUR != 0) &&
  ------------------
  |  |  304|  26.8k|#define CUR (*ctxt->input->cur)
  ------------------
  |  Branch (3927:12): [True: 26.8k, False: 8]
  ------------------
 3928|  26.8k|           (CUR != '>') &&
  ------------------
  |  |  304|  26.8k|#define CUR (*ctxt->input->cur)
  ------------------
  |  Branch (3928:12): [True: 13.7k, False: 13.1k]
  ------------------
 3929|  26.8k|	   ((CUR != '/') || (NXT(1) != '>')) &&
  ------------------
  |  |  304|  13.7k|#define CUR (*ctxt->input->cur)
  ------------------
              	   ((CUR != '/') || (NXT(1) != '>')) &&
  ------------------
  |  |  285|     20|#define NXT(val) ctxt->input->cur[(val)]
  ------------------
  |  Branch (3929:6): [True: 13.7k, False: 20]
  |  Branch (3929:22): [True: 2, False: 18]
  ------------------
 3930|  26.8k|           (ctxt->instate != XML_PARSER_EOF)) {
  ------------------
  |  Branch (3930:12): [True: 13.7k, False: 0]
  ------------------
 3931|  13.7k|	GROW;
  ------------------
  |  |  296|  13.7k|#define GROW if ((ctxt->progressive == 0) &&				\
  |  |  ------------------
  |  |  |  Branch (296:18): [True: 6.72k, False: 7.00k]
  |  |  ------------------
  |  |  297|  13.7k|		 (ctxt->input->end - ctxt->input->cur < INPUT_CHUNK))	\
  |  |  ------------------
  |  |  |  |   97|  6.72k|#define INPUT_CHUNK	250
  |  |  ------------------
  |  |  |  Branch (297:4): [True: 128, False: 6.59k]
  |  |  ------------------
  |  |  298|  13.7k|	xmlParserGrow(ctxt)
  ------------------
 3932|  13.7k|	attname = htmlParseAttribute(ctxt, &attvalue);
 3933|  13.7k|        if (attname != NULL) {
  ------------------
  |  Branch (3933:13): [True: 13.7k, False: 24]
  ------------------
 3934|       |
 3935|       |	    /*
 3936|       |	     * Well formedness requires at most one declaration of an attribute
 3937|       |	     */
 3938|  25.5k|	    for (i = 0; i < nbatts;i += 2) {
  ------------------
  |  Branch (3938:18): [True: 11.8k, False: 13.7k]
  ------------------
 3939|  11.8k|	        if (xmlStrEqual(atts[i], attname)) {
  ------------------
  |  Branch (3939:14): [True: 0, False: 11.8k]
  ------------------
 3940|      0|		    htmlParseErr(ctxt, XML_ERR_ATTRIBUTE_REDEFINED,
 3941|      0|		                 "Attribute %s redefined\n", attname, NULL);
 3942|      0|		    if (attvalue != NULL)
  ------------------
  |  Branch (3942:11): [True: 0, False: 0]
  ------------------
 3943|      0|			xmlFree(attvalue);
 3944|      0|		    goto failed;
 3945|      0|		}
 3946|  11.8k|	    }
 3947|       |
 3948|       |	    /*
 3949|       |	     * Add the pair to atts
 3950|       |	     */
 3951|  13.7k|	    if (atts == NULL) {
  ------------------
  |  Branch (3951:10): [True: 103, False: 13.6k]
  ------------------
 3952|    103|	        maxatts = 22; /* allow for 10 attrs by default */
 3953|    103|	        atts = (const xmlChar **)
 3954|    103|		       xmlMalloc(maxatts * sizeof(xmlChar *));
 3955|    103|		if (atts == NULL) {
  ------------------
  |  Branch (3955:7): [True: 0, False: 103]
  ------------------
 3956|      0|		    htmlErrMemory(ctxt, NULL);
 3957|      0|		    if (attvalue != NULL)
  ------------------
  |  Branch (3957:11): [True: 0, False: 0]
  ------------------
 3958|      0|			xmlFree(attvalue);
 3959|      0|		    goto failed;
 3960|      0|		}
 3961|    103|		ctxt->atts = atts;
 3962|    103|		ctxt->maxatts = maxatts;
 3963|  13.6k|	    } else if (nbatts + 4 > maxatts) {
  ------------------
  |  Branch (3963:17): [True: 0, False: 13.6k]
  ------------------
 3964|      0|	        const xmlChar **n;
 3965|       |
 3966|      0|	        maxatts *= 2;
 3967|      0|	        n = (const xmlChar **) xmlRealloc((void *) atts,
 3968|      0|					     maxatts * sizeof(const xmlChar *));
 3969|      0|		if (n == NULL) {
  ------------------
  |  Branch (3969:7): [True: 0, False: 0]
  ------------------
 3970|      0|		    htmlErrMemory(ctxt, NULL);
 3971|      0|		    if (attvalue != NULL)
  ------------------
  |  Branch (3971:11): [True: 0, False: 0]
  ------------------
 3972|      0|			xmlFree(attvalue);
 3973|      0|		    goto failed;
 3974|      0|		}
 3975|      0|		atts = n;
 3976|      0|		ctxt->atts = atts;
 3977|      0|		ctxt->maxatts = maxatts;
 3978|      0|	    }
 3979|  13.7k|	    atts[nbatts++] = attname;
 3980|  13.7k|	    atts[nbatts++] = attvalue;
 3981|  13.7k|	    atts[nbatts] = NULL;
 3982|  13.7k|	    atts[nbatts + 1] = NULL;
 3983|  13.7k|	}
 3984|     24|	else {
 3985|     24|	    if (attvalue != NULL)
  ------------------
  |  Branch (3985:10): [True: 0, False: 24]
  ------------------
 3986|      0|	        xmlFree(attvalue);
 3987|       |	    /* Dump the bogus attribute string up to the next blank or
 3988|       |	     * the end of the tag. */
 3989|    164|	    while ((CUR != 0) &&
  ------------------
  |  |  304|    164|#define CUR (*ctxt->input->cur)
  ------------------
  |  Branch (3989:13): [True: 160, False: 4]
  ------------------
 3990|    164|	           !(IS_BLANK_CH(CUR)) && (CUR != '>') &&
  ------------------
  |  |  151|    160|#define IS_BLANK_CH(c)  xmlIsBlank_ch(c)
  |  |  ------------------
  |  |  |  |   88|    160|#define xmlIsBlank_ch(c)	(((c) == 0x20) || \
  |  |  |  |  ------------------
  |  |  |  |  |  Branch (88:27): [True: 0, False: 160]
  |  |  |  |  ------------------
  |  |  |  |   89|    160|				 ((0x9 <= (c)) && ((c) <= 0xa)) || \
  |  |  |  |  ------------------
  |  |  |  |  |  Branch (89:7): [True: 156, False: 4]
  |  |  |  |  |  Branch (89:23): [True: 0, False: 156]
  |  |  |  |  ------------------
  |  |  |  |   90|    160|				 ((c) == 0xd))
  |  |  |  |  ------------------
  |  |  |  |  |  Branch (90:6): [True: 0, False: 160]
  |  |  |  |  ------------------
  |  |  ------------------
  ------------------
              	           !(IS_BLANK_CH(CUR)) && (CUR != '>') &&
  ------------------
  |  |  304|    160|#define CUR (*ctxt->input->cur)
  ------------------
  |  Branch (3990:36): [True: 142, False: 18]
  ------------------
 3991|    164|		   ((CUR != '/') || (NXT(1) != '>')) &&
  ------------------
  |  |  304|    142|#define CUR (*ctxt->input->cur)
  ------------------
              		   ((CUR != '/') || (NXT(1) != '>')) &&
  ------------------
  |  |  285|      8|#define NXT(val) ctxt->input->cur[(val)]
  ------------------
  |  Branch (3991:7): [True: 134, False: 8]
  |  Branch (3991:23): [True: 6, False: 2]
  ------------------
 3992|    164|                   (ctxt->instate != XML_PARSER_EOF))
  ------------------
  |  Branch (3992:20): [True: 140, False: 0]
  ------------------
 3993|    140|		NEXT;
  ------------------
  |  |  305|    140|#define NEXT xmlNextChar(ctxt)
  ------------------
 3994|     24|	}
 3995|       |
 3996|  13.7k|failed:
 3997|  13.7k|	SKIP_BLANKS;
  ------------------
  |  |  300|  13.7k|#define SKIP_BLANKS htmlSkipBlankChars(ctxt)
  ------------------
 3998|  13.7k|    }
 3999|       |
 4000|       |    /*
 4001|       |     * Handle specific association to the META tag
 4002|       |     */
 4003|  13.1k|    if (meta && (nbatts != 0))
  ------------------
  |  Branch (4003:9): [True: 57, False: 13.1k]
  |  Branch (4003:17): [True: 57, False: 0]
  ------------------
 4004|     57|	htmlCheckMeta(ctxt, atts);
 4005|       |
 4006|       |    /*
 4007|       |     * SAX: Start of Element !
 4008|       |     */
 4009|  13.1k|    if (!discardtag) {
  ------------------
  |  Branch (4009:9): [True: 13.1k, False: 13]
  ------------------
 4010|  13.1k|	htmlnamePush(ctxt, name);
 4011|  13.1k|	if ((ctxt->sax != NULL) && (ctxt->sax->startElement != NULL)) {
  ------------------
  |  Branch (4011:6): [True: 13.1k, False: 0]
  |  Branch (4011:29): [True: 13.1k, False: 0]
  ------------------
 4012|  13.1k|	    if (nbatts != 0)
  ------------------
  |  Branch (4012:10): [True: 6.84k, False: 6.30k]
  ------------------
 4013|  6.84k|		ctxt->sax->startElement(ctxt->userData, name, atts);
 4014|  6.30k|	    else
 4015|  6.30k|		ctxt->sax->startElement(ctxt->userData, name, NULL);
 4016|  13.1k|	}
 4017|  13.1k|    }
 4018|       |
 4019|  13.1k|    if (atts != NULL) {
  ------------------
  |  Branch (4019:9): [True: 12.6k, False: 472]
  ------------------
 4020|  26.3k|        for (i = 1;i < nbatts;i += 2) {
  ------------------
  |  Branch (4020:20): [True: 13.7k, False: 12.6k]
  ------------------
 4021|  13.7k|	    if (atts[i] != NULL)
  ------------------
  |  Branch (4021:10): [True: 13.6k, False: 50]
  ------------------
 4022|  13.6k|		xmlFree((xmlChar *) atts[i]);
 4023|  13.7k|	}
 4024|  12.6k|    }
 4025|       |
 4026|  13.1k|    return(discardtag);
 4027|  13.1k|}
HTMLparser.c:htmlParseHTMLName:
 2532|  35.5k|htmlParseHTMLName(htmlParserCtxtPtr ctxt) {
 2533|  35.5k|    const xmlChar *ret;
 2534|  35.5k|    int i = 0;
 2535|  35.5k|    xmlChar loc[HTML_PARSER_BUFFER_SIZE];
 2536|       |
 2537|  35.5k|    if (!IS_ASCII_LETTER(CUR) && (CUR != '_') &&
  ------------------
  |  |  258|  71.1k|#define IS_ASCII_LETTER(c)	(((0x41 <= (c)) && ((c) <= 0x5a)) || \
  |  |  ------------------
  |  |  |  Branch (258:30): [True: 35.5k, False: 26]
  |  |  |  Branch (258:47): [True: 11.4k, False: 24.1k]
  |  |  ------------------
  |  |  259|  71.1k|				 ((0x61 <= (c)) && ((c) <= 0x7a)))
  |  |  ------------------
  |  |  |  Branch (259:7): [True: 24.1k, False: 26]
  |  |  |  Branch (259:24): [True: 24.1k, False: 0]
  |  |  ------------------
  ------------------
                  if (!IS_ASCII_LETTER(CUR) && (CUR != '_') &&
  ------------------
  |  |  304|     26|#define CUR (*ctxt->input->cur)
  ------------------
  |  Branch (2537:34): [True: 26, False: 0]
  ------------------
 2538|  35.5k|        (CUR != ':') && (CUR != '.')) return(NULL);
  ------------------
  |  |  304|     26|#define CUR (*ctxt->input->cur)
  ------------------
                      (CUR != ':') && (CUR != '.')) return(NULL);
  ------------------
  |  |  304|     26|#define CUR (*ctxt->input->cur)
  ------------------
  |  Branch (2538:9): [True: 26, False: 0]
  |  Branch (2538:25): [True: 26, False: 0]
  ------------------
 2539|       |
 2540|   159k|    while ((i < HTML_PARSER_BUFFER_SIZE) &&
  ------------------
  |  |   39|   159k|#define HTML_PARSER_BUFFER_SIZE 100
  ------------------
  |  Branch (2540:12): [True: 159k, False: 0]
  ------------------
 2541|   159k|           ((IS_ASCII_LETTER(CUR)) || (IS_ASCII_DIGIT(CUR)) ||
  ------------------
  |  |  258|   159k|#define IS_ASCII_LETTER(c)	(((0x41 <= (c)) && ((c) <= 0x5a)) || \
  |  |  ------------------
  |  |  |  Branch (258:30): [True: 123k, False: 35.9k]
  |  |  |  Branch (258:47): [True: 35.4k, False: 88.0k]
  |  |  ------------------
  |  |  259|   159k|				 ((0x61 <= (c)) && ((c) <= 0x7a)))
  |  |  ------------------
  |  |  |  Branch (259:7): [True: 88.0k, False: 35.9k]
  |  |  |  Branch (259:24): [True: 88.0k, False: 10]
  |  |  ------------------
  ------------------
                         ((IS_ASCII_LETTER(CUR)) || (IS_ASCII_DIGIT(CUR)) ||
  ------------------
  |  |  268|  35.9k|#define IS_ASCII_DIGIT(c)	((0x30 <= (c)) && ((c) <= 0x39))
  |  |  ------------------
  |  |  |  Branch (268:28): [True: 29.0k, False: 6.91k]
  |  |  |  Branch (268:45): [True: 362, False: 28.6k]
  |  |  ------------------
  ------------------
 2542|   159k|	   (CUR == ':') || (CUR == '-') || (CUR == '_') ||
  ------------------
  |  |  304|  35.5k|#define CUR (*ctxt->input->cur)
  ------------------
              	   (CUR == ':') || (CUR == '-') || (CUR == '_') ||
  ------------------
  |  |  304|  35.5k|#define CUR (*ctxt->input->cur)
  ------------------
              	   (CUR == ':') || (CUR == '-') || (CUR == '_') ||
  ------------------
  |  |  304|  35.5k|#define CUR (*ctxt->input->cur)
  ------------------
  |  Branch (2542:5): [True: 10, False: 35.5k]
  |  Branch (2542:21): [True: 19, False: 35.5k]
  |  Branch (2542:37): [True: 0, False: 35.5k]
  ------------------
 2543|   159k|           (CUR == '.'))) {
  ------------------
  |  |  304|  35.5k|#define CUR (*ctxt->input->cur)
  ------------------
  |  Branch (2543:12): [True: 0, False: 35.5k]
  ------------------
 2544|   123k|	if ((CUR >= 'A') && (CUR <= 'Z')) loc[i] = CUR + 0x20;
  ------------------
  |  |  304|   123k|#define CUR (*ctxt->input->cur)
  ------------------
              	if ((CUR >= 'A') && (CUR <= 'Z')) loc[i] = CUR + 0x20;
  ------------------
  |  |  304|   123k|#define CUR (*ctxt->input->cur)
  ------------------
              	if ((CUR >= 'A') && (CUR <= 'Z')) loc[i] = CUR + 0x20;
  ------------------
  |  |  304|  35.4k|#define CUR (*ctxt->input->cur)
  ------------------
  |  Branch (2544:6): [True: 123k, False: 391]
  |  Branch (2544:22): [True: 35.4k, False: 88.0k]
  ------------------
 2545|  88.4k|        else loc[i] = CUR;
  ------------------
  |  |  304|  88.4k|#define CUR (*ctxt->input->cur)
  ------------------
 2546|   123k|	i++;
 2547|       |
 2548|   123k|	NEXT;
  ------------------
  |  |  305|   123k|#define NEXT xmlNextChar(ctxt)
  ------------------
 2549|   123k|    }
 2550|       |
 2551|  35.5k|    ret = xmlDictLookup(ctxt->dict, loc, i);
 2552|  35.5k|    if (ret == NULL)
  ------------------
  |  Branch (2552:9): [True: 0, False: 35.5k]
  ------------------
 2553|      0|        htmlErrMemory(ctxt, NULL);
 2554|       |
 2555|  35.5k|    return(ret);
 2556|  35.5k|}
HTMLparser.c:htmlAutoClose:
 1534|  13.3k|{
 1535|  13.3k|    if (newtag == NULL)
  ------------------
  |  Branch (1535:9): [True: 0, False: 13.3k]
  ------------------
 1536|      0|        return;
 1537|       |
 1538|  13.5k|    while ((ctxt->name != NULL) &&
  ------------------
  |  Branch (1538:12): [True: 13.3k, False: 173]
  ------------------
 1539|  13.5k|           (htmlCheckAutoClose(newtag, ctxt->name))) {
  ------------------
  |  Branch (1539:12): [True: 223, False: 13.1k]
  ------------------
 1540|    223|        if ((ctxt->sax != NULL) && (ctxt->sax->endElement != NULL))
  ------------------
  |  Branch (1540:13): [True: 223, False: 0]
  |  Branch (1540:36): [True: 223, False: 0]
  ------------------
 1541|    223|            ctxt->sax->endElement(ctxt->userData, ctxt->name);
 1542|    223|	htmlnamePop(ctxt);
 1543|    223|    }
 1544|  13.3k|}
HTMLparser.c:htmlCheckImplied:
 1608|  13.1k|htmlCheckImplied(htmlParserCtxtPtr ctxt, const xmlChar *newtag) {
 1609|  13.1k|    int i;
 1610|       |
 1611|  13.1k|    if (ctxt->options & HTML_PARSE_NOIMPLIED)
  ------------------
  |  Branch (1611:9): [True: 4, False: 13.1k]
  ------------------
 1612|      4|        return;
 1613|  13.1k|    if (!htmlOmittedDefaultValue)
  ------------------
  |  Branch (1613:9): [True: 0, False: 13.1k]
  ------------------
 1614|      0|	return;
 1615|  13.1k|    if (xmlStrEqual(newtag, BAD_CAST"html"))
  ------------------
  |  |   35|  13.1k|#define BAD_CAST (xmlChar *)
  ------------------
  |  Branch (1615:9): [True: 134, False: 13.0k]
  ------------------
 1616|    134|	return;
 1617|  13.0k|    if (ctxt->nameNr <= 0) {
  ------------------
  |  Branch (1617:9): [True: 37, False: 13.0k]
  ------------------
 1618|     37|	htmlnamePush(ctxt, BAD_CAST"html");
  ------------------
  |  |   35|     37|#define BAD_CAST (xmlChar *)
  ------------------
 1619|     37|	if ((ctxt->sax != NULL) && (ctxt->sax->startElement != NULL))
  ------------------
  |  Branch (1619:6): [True: 37, False: 0]
  |  Branch (1619:29): [True: 37, False: 0]
  ------------------
 1620|     37|	    ctxt->sax->startElement(ctxt->userData, BAD_CAST"html", NULL);
  ------------------
  |  |   35|     37|#define BAD_CAST (xmlChar *)
  ------------------
 1621|     37|    }
 1622|  13.0k|    if ((xmlStrEqual(newtag, BAD_CAST"body")) || (xmlStrEqual(newtag, BAD_CAST"head")))
  ------------------
  |  |   35|  13.0k|#define BAD_CAST (xmlChar *)
  ------------------
                  if ((xmlStrEqual(newtag, BAD_CAST"body")) || (xmlStrEqual(newtag, BAD_CAST"head")))
  ------------------
  |  |   35|  12.9k|#define BAD_CAST (xmlChar *)
  ------------------
  |  Branch (1622:9): [True: 116, False: 12.9k]
  |  Branch (1622:50): [True: 85, False: 12.8k]
  ------------------
 1623|    201|        return;
 1624|  12.8k|    if ((ctxt->nameNr <= 1) &&
  ------------------
  |  Branch (1624:9): [True: 61, False: 12.7k]
  ------------------
 1625|  12.8k|        ((xmlStrEqual(newtag, BAD_CAST"script")) ||
  ------------------
  |  |   35|     61|#define BAD_CAST (xmlChar *)
  ------------------
  |  Branch (1625:10): [True: 0, False: 61]
  ------------------
 1626|     61|	 (xmlStrEqual(newtag, BAD_CAST"style")) ||
  ------------------
  |  |   35|     61|#define BAD_CAST (xmlChar *)
  ------------------
  |  Branch (1626:3): [True: 0, False: 61]
  ------------------
 1627|     61|	 (xmlStrEqual(newtag, BAD_CAST"meta")) ||
  ------------------
  |  |   35|     61|#define BAD_CAST (xmlChar *)
  ------------------
  |  Branch (1627:3): [True: 0, False: 61]
  ------------------
 1628|     61|	 (xmlStrEqual(newtag, BAD_CAST"link")) ||
  ------------------
  |  |   35|     61|#define BAD_CAST (xmlChar *)
  ------------------
  |  Branch (1628:3): [True: 0, False: 61]
  ------------------
 1629|     61|	 (xmlStrEqual(newtag, BAD_CAST"title")) ||
  ------------------
  |  |   35|     61|#define BAD_CAST (xmlChar *)
  ------------------
  |  Branch (1629:3): [True: 0, False: 61]
  ------------------
 1630|     61|	 (xmlStrEqual(newtag, BAD_CAST"base")))) {
  ------------------
  |  |   35|     61|#define BAD_CAST (xmlChar *)
  ------------------
  |  Branch (1630:3): [True: 0, False: 61]
  ------------------
 1631|      0|        if (ctxt->html >= 3) {
  ------------------
  |  Branch (1631:13): [True: 0, False: 0]
  ------------------
 1632|       |            /* we already saw or generated an <head> before */
 1633|      0|            return;
 1634|      0|        }
 1635|       |        /*
 1636|       |         * dropped OBJECT ... i you put it first BODY will be
 1637|       |         * assumed !
 1638|       |         */
 1639|      0|        htmlnamePush(ctxt, BAD_CAST"head");
  ------------------
  |  |   35|      0|#define BAD_CAST (xmlChar *)
  ------------------
 1640|      0|        if ((ctxt->sax != NULL) && (ctxt->sax->startElement != NULL))
  ------------------
  |  Branch (1640:13): [True: 0, False: 0]
  |  Branch (1640:36): [True: 0, False: 0]
  ------------------
 1641|      0|            ctxt->sax->startElement(ctxt->userData, BAD_CAST"head", NULL);
  ------------------
  |  |   35|      0|#define BAD_CAST (xmlChar *)
  ------------------
 1642|  12.8k|    } else if ((!xmlStrEqual(newtag, BAD_CAST"noframes")) &&
  ------------------
  |  |   35|  12.8k|#define BAD_CAST (xmlChar *)
  ------------------
  |  Branch (1642:16): [True: 12.8k, False: 4]
  ------------------
 1643|  12.8k|	       (!xmlStrEqual(newtag, BAD_CAST"frame")) &&
  ------------------
  |  |   35|  12.8k|#define BAD_CAST (xmlChar *)
  ------------------
  |  Branch (1643:9): [True: 12.8k, False: 12]
  ------------------
 1644|  12.8k|	       (!xmlStrEqual(newtag, BAD_CAST"frameset"))) {
  ------------------
  |  |   35|  12.8k|#define BAD_CAST (xmlChar *)
  ------------------
  |  Branch (1644:9): [True: 12.8k, False: 8]
  ------------------
 1645|  12.8k|        if (ctxt->html >= 10) {
  ------------------
  |  Branch (1645:13): [True: 12.6k, False: 215]
  ------------------
 1646|       |            /* we already saw or generated a <body> before */
 1647|  12.6k|            return;
 1648|  12.6k|        }
 1649|    430|	for (i = 0;i < ctxt->nameNr;i++) {
  ------------------
  |  Branch (1649:13): [True: 375, False: 55]
  ------------------
 1650|    375|	    if (xmlStrEqual(ctxt->nameTab[i], BAD_CAST"body")) {
  ------------------
  |  |   35|    375|#define BAD_CAST (xmlChar *)
  ------------------
  |  Branch (1650:10): [True: 0, False: 375]
  ------------------
 1651|      0|		return;
 1652|      0|	    }
 1653|    375|	    if (xmlStrEqual(ctxt->nameTab[i], BAD_CAST"head")) {
  ------------------
  |  |   35|    375|#define BAD_CAST (xmlChar *)
  ------------------
  |  Branch (1653:10): [True: 160, False: 215]
  ------------------
 1654|    160|		return;
 1655|    160|	    }
 1656|    375|	}
 1657|       |
 1658|     55|	htmlnamePush(ctxt, BAD_CAST"body");
  ------------------
  |  |   35|     55|#define BAD_CAST (xmlChar *)
  ------------------
 1659|     55|	if ((ctxt->sax != NULL) && (ctxt->sax->startElement != NULL))
  ------------------
  |  Branch (1659:6): [True: 55, False: 0]
  |  Branch (1659:29): [True: 55, False: 0]
  ------------------
 1660|     55|	    ctxt->sax->startElement(ctxt->userData, BAD_CAST"body", NULL);
  ------------------
  |  |   35|     55|#define BAD_CAST (xmlChar *)
  ------------------
 1661|     55|    }
 1662|  12.8k|}
HTMLparser.c:htmlParseAttribute:
 3726|  13.7k|htmlParseAttribute(htmlParserCtxtPtr ctxt, xmlChar **value) {
 3727|  13.7k|    const xmlChar *name;
 3728|  13.7k|    xmlChar *val = NULL;
 3729|       |
 3730|  13.7k|    *value = NULL;
 3731|  13.7k|    name = htmlParseHTMLName(ctxt);
 3732|  13.7k|    if (name == NULL) {
  ------------------
  |  Branch (3732:9): [True: 24, False: 13.7k]
  ------------------
 3733|     24|	htmlParseErr(ctxt, XML_ERR_NAME_REQUIRED,
 3734|     24|	             "error parsing attribute name\n", NULL, NULL);
 3735|     24|        return(NULL);
 3736|     24|    }
 3737|       |
 3738|       |    /*
 3739|       |     * read the value
 3740|       |     */
 3741|  13.7k|    SKIP_BLANKS;
  ------------------
  |  |  300|  13.7k|#define SKIP_BLANKS htmlSkipBlankChars(ctxt)
  ------------------
 3742|  13.7k|    if (CUR == '=') {
  ------------------
  |  |  304|  13.7k|#define CUR (*ctxt->input->cur)
  ------------------
  |  Branch (3742:9): [True: 13.6k, False: 50]
  ------------------
 3743|  13.6k|        NEXT;
  ------------------
  |  |  305|  13.6k|#define NEXT xmlNextChar(ctxt)
  ------------------
 3744|  13.6k|	SKIP_BLANKS;
  ------------------
  |  |  300|  13.6k|#define SKIP_BLANKS htmlSkipBlankChars(ctxt)
  ------------------
 3745|  13.6k|	val = htmlParseAttValue(ctxt);
 3746|  13.6k|    }
 3747|       |
 3748|  13.7k|    *value = val;
 3749|  13.7k|    return(name);
 3750|  13.7k|}
HTMLparser.c:htmlParseAttValue:
 2907|  13.6k|htmlParseAttValue(htmlParserCtxtPtr ctxt) {
 2908|  13.6k|    xmlChar *ret = NULL;
 2909|       |
 2910|  13.6k|    if (CUR == '"') {
  ------------------
  |  |  304|  13.6k|#define CUR (*ctxt->input->cur)
  ------------------
  |  Branch (2910:9): [True: 7.71k, False: 5.94k]
  ------------------
 2911|  7.71k|        NEXT;
  ------------------
  |  |  305|  7.71k|#define NEXT xmlNextChar(ctxt)
  ------------------
 2912|  7.71k|	ret = htmlParseHTMLAttribute(ctxt, '"');
 2913|  7.71k|        if (CUR != '"') {
  ------------------
  |  |  304|  7.71k|#define CUR (*ctxt->input->cur)
  ------------------
  |  Branch (2913:13): [True: 2, False: 7.71k]
  ------------------
 2914|      2|	    htmlParseErr(ctxt, XML_ERR_ATTRIBUTE_NOT_FINISHED,
 2915|      2|	                 "AttValue: \" expected\n", NULL, NULL);
 2916|      2|	} else
 2917|  7.71k|	    NEXT;
  ------------------
  |  |  305|  7.71k|#define NEXT xmlNextChar(ctxt)
  ------------------
 2918|  7.71k|    } else if (CUR == '\'') {
  ------------------
  |  |  304|  5.94k|#define CUR (*ctxt->input->cur)
  ------------------
  |  Branch (2918:16): [True: 30, False: 5.91k]
  ------------------
 2919|     30|        NEXT;
  ------------------
  |  |  305|     30|#define NEXT xmlNextChar(ctxt)
  ------------------
 2920|     30|	ret = htmlParseHTMLAttribute(ctxt, '\'');
 2921|     30|        if (CUR != '\'') {
  ------------------
  |  |  304|     30|#define CUR (*ctxt->input->cur)
  ------------------
  |  Branch (2921:13): [True: 0, False: 30]
  ------------------
 2922|      0|	    htmlParseErr(ctxt, XML_ERR_ATTRIBUTE_NOT_FINISHED,
 2923|      0|	                 "AttValue: ' expected\n", NULL, NULL);
 2924|      0|	} else
 2925|     30|	    NEXT;
  ------------------
  |  |  305|     30|#define NEXT xmlNextChar(ctxt)
  ------------------
 2926|  5.91k|    } else {
 2927|       |        /*
 2928|       |	 * That's an HTMLism, the attribute value may not be quoted
 2929|       |	 */
 2930|  5.91k|	ret = htmlParseHTMLAttribute(ctxt, 0);
 2931|  5.91k|	if (ret == NULL) {
  ------------------
  |  Branch (2931:6): [True: 0, False: 5.91k]
  ------------------
 2932|      0|	    htmlParseErr(ctxt, XML_ERR_ATTRIBUTE_WITHOUT_VALUE,
 2933|      0|	                 "AttValue: no value found\n", NULL, NULL);
 2934|      0|	}
 2935|  5.91k|    }
 2936|  13.6k|    return(ret);
 2937|  13.6k|}
HTMLparser.c:htmlParseHTMLAttribute:
 2702|  13.6k|htmlParseHTMLAttribute(htmlParserCtxtPtr ctxt, const xmlChar stop) {
 2703|  13.6k|    xmlChar *buffer = NULL;
 2704|  13.6k|    int buffer_size = 0;
 2705|  13.6k|    int maxLength = (ctxt->options & XML_PARSE_HUGE) ?
  ------------------
  |  Branch (2705:21): [True: 0, False: 13.6k]
  ------------------
 2706|      0|                    XML_MAX_HUGE_LENGTH :
  ------------------
  |  |   49|      0|#define XML_MAX_HUGE_LENGTH 1000000000
  ------------------
 2707|  13.6k|                    XML_MAX_TEXT_LENGTH;
  ------------------
  |  |   42|  13.6k|#define XML_MAX_TEXT_LENGTH 10000000
  ------------------
 2708|  13.6k|    xmlChar *out = NULL;
 2709|  13.6k|    const xmlChar *name = NULL;
 2710|  13.6k|    const xmlChar *cur = NULL;
 2711|  13.6k|    const htmlEntityDesc * ent;
 2712|       |
 2713|       |    /*
 2714|       |     * allocate a translation buffer.
 2715|       |     */
 2716|  13.6k|    buffer_size = HTML_PARSER_BUFFER_SIZE;
  ------------------
  |  |   39|  13.6k|#define HTML_PARSER_BUFFER_SIZE 100
  ------------------
 2717|  13.6k|    buffer = (xmlChar *) xmlMallocAtomic(buffer_size);
 2718|  13.6k|    if (buffer == NULL) {
  ------------------
  |  Branch (2718:9): [True: 0, False: 13.6k]
  ------------------
 2719|      0|	htmlErrMemory(ctxt, "buffer allocation failed\n");
 2720|      0|	return(NULL);
 2721|      0|    }
 2722|  13.6k|    out = buffer;
 2723|       |
 2724|       |    /*
 2725|       |     * Ok loop until we reach one of the ending chars
 2726|       |     */
 2727|   254k|    while ((CUR != 0) && (CUR != stop)) {
  ------------------
  |  |  304|   254k|#define CUR (*ctxt->input->cur)
  ------------------
                  while ((CUR != 0) && (CUR != stop)) {
  ------------------
  |  |  304|   254k|#define CUR (*ctxt->input->cur)
  ------------------
  |  Branch (2727:12): [True: 254k, False: 2]
  |  Branch (2727:26): [True: 246k, False: 7.74k]
  ------------------
 2728|   246k|	if ((stop == 0) && (CUR == '>')) break;
  ------------------
  |  |  304|  36.1k|#define CUR (*ctxt->input->cur)
  ------------------
  |  Branch (2728:6): [True: 36.1k, False: 210k]
  |  Branch (2728:21): [True: 2.32k, False: 33.8k]
  ------------------
 2729|   244k|	if ((stop == 0) && (IS_BLANK_CH(CUR))) break;
  ------------------
  |  |  151|  33.8k|#define IS_BLANK_CH(c)  xmlIsBlank_ch(c)
  |  |  ------------------
  |  |  |  |   88|  33.8k|#define xmlIsBlank_ch(c)	(((c) == 0x20) || \
  |  |  |  |  ------------------
  |  |  |  |  |  Branch (88:27): [True: 3.58k, False: 30.2k]
  |  |  |  |  ------------------
  |  |  |  |   89|  33.8k|				 ((0x9 <= (c)) && ((c) <= 0xa)) || \
  |  |  |  |  ------------------
  |  |  |  |  |  Branch (89:7): [True: 30.2k, False: 0]
  |  |  |  |  |  Branch (89:23): [True: 0, False: 30.2k]
  |  |  |  |  ------------------
  |  |  |  |   90|  33.8k|				 ((c) == 0xd))
  |  |  |  |  ------------------
  |  |  |  |  |  Branch (90:6): [True: 0, False: 30.2k]
  |  |  |  |  ------------------
  |  |  ------------------
  ------------------
  |  Branch (2729:6): [True: 33.8k, False: 210k]
  ------------------
 2730|   241k|        if (CUR == '&') {
  ------------------
  |  |  304|   241k|#define CUR (*ctxt->input->cur)
  ------------------
  |  Branch (2730:13): [True: 1.32k, False: 239k]
  ------------------
 2731|  1.32k|	    if (NXT(1) == '#') {
  ------------------
  |  |  285|  1.32k|#define NXT(val) ctxt->input->cur[(val)]
  ------------------
  |  Branch (2731:10): [True: 714, False: 612]
  ------------------
 2732|    714|		unsigned int c;
 2733|    714|		int bits;
 2734|       |
 2735|    714|		c = htmlParseCharRef(ctxt);
 2736|    714|		if      (c <    0x80)
  ------------------
  |  Branch (2736:12): [True: 714, False: 0]
  ------------------
 2737|    714|		        { *out++  = c;                bits= -6; }
 2738|      0|		else if (c <   0x800)
  ------------------
  |  Branch (2738:12): [True: 0, False: 0]
  ------------------
 2739|      0|		        { *out++  =((c >>  6) & 0x1F) | 0xC0;  bits=  0; }
 2740|      0|		else if (c < 0x10000)
  ------------------
  |  Branch (2740:12): [True: 0, False: 0]
  ------------------
 2741|      0|		        { *out++  =((c >> 12) & 0x0F) | 0xE0;  bits=  6; }
 2742|      0|		else
 2743|      0|		        { *out++  =((c >> 18) & 0x07) | 0xF0;  bits= 12; }
 2744|       |
 2745|    714|		for ( ; bits >= 0; bits-= 6) {
  ------------------
  |  Branch (2745:11): [True: 0, False: 714]
  ------------------
 2746|      0|		    *out++  = ((c >> bits) & 0x3F) | 0x80;
 2747|      0|		}
 2748|       |
 2749|    714|		if (out - buffer > buffer_size - 100) {
  ------------------
  |  Branch (2749:7): [True: 9, False: 705]
  ------------------
 2750|      9|			int indx = out - buffer;
 2751|       |
 2752|      9|			growBuffer(buffer);
  ------------------
  |  | 2033|      9|#define growBuffer(buffer) {						\
  |  | 2034|      9|    xmlChar *tmp;							\
  |  | 2035|      9|    buffer##_size *= 2;							\
  |  | 2036|      9|    tmp = (xmlChar *) xmlRealloc(buffer, buffer##_size); 		\
  |  | 2037|      9|    if (tmp == NULL) {							\
  |  |  ------------------
  |  |  |  Branch (2037:9): [True: 0, False: 9]
  |  |  ------------------
  |  | 2038|      0|	htmlErrMemory(ctxt, "growing buffer\n");			\
  |  | 2039|      0|	xmlFree(buffer);						\
  |  | 2040|      0|	return(NULL);							\
  |  | 2041|      0|    }									\
  |  | 2042|      9|    buffer = tmp;							\
  |  | 2043|      9|}
  ------------------
 2753|      9|			out = &buffer[indx];
 2754|      9|		}
 2755|    714|	    } else {
 2756|    612|		ent = htmlParseEntityRef(ctxt, &name);
 2757|    612|		if (name == NULL) {
  ------------------
  |  Branch (2757:7): [True: 2, False: 610]
  ------------------
 2758|      2|		    *out++ = '&';
 2759|      2|		    if (out - buffer > buffer_size - 100) {
  ------------------
  |  Branch (2759:11): [True: 0, False: 2]
  ------------------
 2760|      0|			int indx = out - buffer;
 2761|       |
 2762|      0|			growBuffer(buffer);
  ------------------
  |  | 2033|      0|#define growBuffer(buffer) {						\
  |  | 2034|      0|    xmlChar *tmp;							\
  |  | 2035|      0|    buffer##_size *= 2;							\
  |  | 2036|      0|    tmp = (xmlChar *) xmlRealloc(buffer, buffer##_size); 		\
  |  | 2037|      0|    if (tmp == NULL) {							\
  |  |  ------------------
  |  |  |  Branch (2037:9): [True: 0, False: 0]
  |  |  ------------------
  |  | 2038|      0|	htmlErrMemory(ctxt, "growing buffer\n");			\
  |  | 2039|      0|	xmlFree(buffer);						\
  |  | 2040|      0|	return(NULL);							\
  |  | 2041|      0|    }									\
  |  | 2042|      0|    buffer = tmp;							\
  |  | 2043|      0|}
  ------------------
 2763|      0|			out = &buffer[indx];
 2764|      0|		    }
 2765|    610|		} else if (ent == NULL) {
  ------------------
  |  Branch (2765:14): [True: 554, False: 56]
  ------------------
 2766|    554|		    *out++ = '&';
 2767|    554|		    cur = name;
 2768|  4.39k|		    while (*cur != 0) {
  ------------------
  |  Branch (2768:14): [True: 3.84k, False: 554]
  ------------------
 2769|  3.84k|			if (out - buffer > buffer_size - 100) {
  ------------------
  |  Branch (2769:8): [True: 18, False: 3.82k]
  ------------------
 2770|     18|			    int indx = out - buffer;
 2771|       |
 2772|     18|			    growBuffer(buffer);
  ------------------
  |  | 2033|     18|#define growBuffer(buffer) {						\
  |  | 2034|     18|    xmlChar *tmp;							\
  |  | 2035|     18|    buffer##_size *= 2;							\
  |  | 2036|     18|    tmp = (xmlChar *) xmlRealloc(buffer, buffer##_size); 		\
  |  | 2037|     18|    if (tmp == NULL) {							\
  |  |  ------------------
  |  |  |  Branch (2037:9): [True: 0, False: 18]
  |  |  ------------------
  |  | 2038|      0|	htmlErrMemory(ctxt, "growing buffer\n");			\
  |  | 2039|      0|	xmlFree(buffer);						\
  |  | 2040|      0|	return(NULL);							\
  |  | 2041|      0|    }									\
  |  | 2042|     18|    buffer = tmp;							\
  |  | 2043|     18|}
  ------------------
 2773|     18|			    out = &buffer[indx];
 2774|     18|			}
 2775|  3.84k|			*out++ = *cur++;
 2776|  3.84k|		    }
 2777|    554|		} else {
 2778|     56|		    unsigned int c;
 2779|     56|		    int bits;
 2780|       |
 2781|     56|		    if (out - buffer > buffer_size - 100) {
  ------------------
  |  Branch (2781:11): [True: 8, False: 48]
  ------------------
 2782|      8|			int indx = out - buffer;
 2783|       |
 2784|      8|			growBuffer(buffer);
  ------------------
  |  | 2033|      8|#define growBuffer(buffer) {						\
  |  | 2034|      8|    xmlChar *tmp;							\
  |  | 2035|      8|    buffer##_size *= 2;							\
  |  | 2036|      8|    tmp = (xmlChar *) xmlRealloc(buffer, buffer##_size); 		\
  |  | 2037|      8|    if (tmp == NULL) {							\
  |  |  ------------------
  |  |  |  Branch (2037:9): [True: 0, False: 8]
  |  |  ------------------
  |  | 2038|      0|	htmlErrMemory(ctxt, "growing buffer\n");			\
  |  | 2039|      0|	xmlFree(buffer);						\
  |  | 2040|      0|	return(NULL);							\
  |  | 2041|      0|    }									\
  |  | 2042|      8|    buffer = tmp;							\
  |  | 2043|      8|}
  ------------------
 2785|      8|			out = &buffer[indx];
 2786|      8|		    }
 2787|     56|		    c = ent->value;
 2788|     56|		    if      (c <    0x80)
  ------------------
  |  Branch (2788:16): [True: 54, False: 2]
  ------------------
 2789|     54|			{ *out++  = c;                bits= -6; }
 2790|      2|		    else if (c <   0x800)
  ------------------
  |  Branch (2790:16): [True: 2, False: 0]
  ------------------
 2791|      2|			{ *out++  =((c >>  6) & 0x1F) | 0xC0;  bits=  0; }
 2792|      0|		    else if (c < 0x10000)
  ------------------
  |  Branch (2792:16): [True: 0, False: 0]
  ------------------
 2793|      0|			{ *out++  =((c >> 12) & 0x0F) | 0xE0;  bits=  6; }
 2794|      0|		    else
 2795|      0|			{ *out++  =((c >> 18) & 0x07) | 0xF0;  bits= 12; }
 2796|       |
 2797|     58|		    for ( ; bits >= 0; bits-= 6) {
  ------------------
  |  Branch (2797:15): [True: 2, False: 56]
  ------------------
 2798|      2|			*out++  = ((c >> bits) & 0x3F) | 0x80;
 2799|      2|		    }
 2800|     56|		}
 2801|    612|	    }
 2802|   239k|	} else {
 2803|   239k|	    unsigned int c;
 2804|   239k|	    int bits, l;
 2805|       |
 2806|   239k|	    if (out - buffer > buffer_size - 100) {
  ------------------
  |  Branch (2806:10): [True: 10.5k, False: 229k]
  ------------------
 2807|  10.5k|		int indx = out - buffer;
 2808|       |
 2809|  10.5k|		growBuffer(buffer);
  ------------------
  |  | 2033|  10.5k|#define growBuffer(buffer) {						\
  |  | 2034|  10.5k|    xmlChar *tmp;							\
  |  | 2035|  10.5k|    buffer##_size *= 2;							\
  |  | 2036|  10.5k|    tmp = (xmlChar *) xmlRealloc(buffer, buffer##_size); 		\
  |  | 2037|  10.5k|    if (tmp == NULL) {							\
  |  |  ------------------
  |  |  |  Branch (2037:9): [True: 0, False: 10.5k]
  |  |  ------------------
  |  | 2038|      0|	htmlErrMemory(ctxt, "growing buffer\n");			\
  |  | 2039|      0|	xmlFree(buffer);						\
  |  | 2040|      0|	return(NULL);							\
  |  | 2041|      0|    }									\
  |  | 2042|  10.5k|    buffer = tmp;							\
  |  | 2043|  10.5k|}
  ------------------
 2810|  10.5k|		out = &buffer[indx];
 2811|  10.5k|	    }
 2812|   239k|	    c = CUR_CHAR(l);
  ------------------
  |  |  323|   239k|#define CUR_CHAR(l) htmlCurrentChar(ctxt, &l)
  ------------------
 2813|   239k|            if (ctxt->instate == XML_PARSER_EOF) {
  ------------------
  |  Branch (2813:17): [True: 0, False: 239k]
  ------------------
 2814|      0|                xmlFree(buffer);
 2815|      0|                return(NULL);
 2816|      0|            }
 2817|   239k|	    if      (c <    0x80)
  ------------------
  |  Branch (2817:15): [True: 239k, False: 166]
  ------------------
 2818|   239k|		    { *out++  = c;                bits= -6; }
 2819|    166|	    else if (c <   0x800)
  ------------------
  |  Branch (2819:15): [True: 166, False: 0]
  ------------------
 2820|    166|		    { *out++  =((c >>  6) & 0x1F) | 0xC0;  bits=  0; }
 2821|      0|	    else if (c < 0x10000)
  ------------------
  |  Branch (2821:15): [True: 0, False: 0]
  ------------------
 2822|      0|		    { *out++  =((c >> 12) & 0x0F) | 0xE0;  bits=  6; }
 2823|      0|	    else
 2824|      0|		    { *out++  =((c >> 18) & 0x07) | 0xF0;  bits= 12; }
 2825|       |
 2826|   239k|	    for ( ; bits >= 0; bits-= 6) {
  ------------------
  |  Branch (2826:14): [True: 166, False: 239k]
  ------------------
 2827|    166|		*out++  = ((c >> bits) & 0x3F) | 0x80;
 2828|    166|	    }
 2829|   239k|	    NEXTL(l);
  ------------------
  |  |  310|   239k|#define NEXTL(l) do {							\
  |  |  311|   239k|    if (*(ctxt->input->cur) == '\n') {					\
  |  |  ------------------
  |  |  |  Branch (311:9): [True: 18, False: 239k]
  |  |  ------------------
  |  |  312|     18|	ctxt->input->line++; ctxt->input->col = 1;			\
  |  |  313|   239k|    } else ctxt->input->col++;						\
  |  |  314|   239k|    ctxt->token = 0; ctxt->input->cur += l;				\
  |  |  315|   239k|  } while (0)
  |  |  ------------------
  |  |  |  Branch (315:12): [Folded - Ignored]
  |  |  ------------------
  ------------------
 2830|   239k|	}
 2831|   241k|        if (out - buffer > maxLength) {
  ------------------
  |  Branch (2831:13): [True: 0, False: 241k]
  ------------------
 2832|      0|            htmlParseErr(ctxt, XML_ERR_ATTRIBUTE_NOT_FINISHED,
 2833|      0|                         "attribute value too long\n", NULL, NULL);
 2834|      0|            xmlFree(buffer);
 2835|      0|            return(NULL);
 2836|      0|        }
 2837|   241k|    }
 2838|  13.6k|    *out = 0;
 2839|  13.6k|    return(buffer);
 2840|  13.6k|}
HTMLparser.c:htmlCheckMeta:
 3792|     57|htmlCheckMeta(htmlParserCtxtPtr ctxt, const xmlChar **atts) {
 3793|     57|    int i;
 3794|     57|    const xmlChar *att, *value;
 3795|     57|    int http = 0;
 3796|     57|    const xmlChar *content = NULL;
 3797|       |
 3798|     57|    if ((ctxt == NULL) || (atts == NULL))
  ------------------
  |  Branch (3798:9): [True: 0, False: 57]
  |  Branch (3798:27): [True: 0, False: 57]
  ------------------
 3799|      0|	return;
 3800|       |
 3801|     57|    i = 0;
 3802|     57|    att = atts[i++];
 3803|    167|    while (att != NULL) {
  ------------------
  |  Branch (3803:12): [True: 110, False: 57]
  ------------------
 3804|    110|	value = atts[i++];
 3805|    110|	if ((value != NULL) && (!xmlStrcasecmp(att, BAD_CAST"http-equiv"))
  ------------------
  |  |   35|    110|#define BAD_CAST (xmlChar *)
  ------------------
  |  Branch (3805:6): [True: 110, False: 0]
  |  Branch (3805:25): [True: 19, False: 91]
  ------------------
 3806|    110|	 && (!xmlStrcasecmp(value, BAD_CAST"Content-Type")))
  ------------------
  |  |   35|     19|#define BAD_CAST (xmlChar *)
  ------------------
  |  Branch (3806:6): [True: 14, False: 5]
  ------------------
 3807|     14|	    http = 1;
 3808|     96|	else if ((value != NULL) && (!xmlStrcasecmp(att, BAD_CAST"charset")))
  ------------------
  |  |   35|     96|#define BAD_CAST (xmlChar *)
  ------------------
  |  Branch (3808:11): [True: 96, False: 0]
  |  Branch (3808:30): [True: 2, False: 94]
  ------------------
 3809|      2|	    xmlSetDeclaredEncoding(ctxt, xmlStrdup(value));
 3810|     94|	else if ((value != NULL) && (!xmlStrcasecmp(att, BAD_CAST"content")))
  ------------------
  |  |   35|     94|#define BAD_CAST (xmlChar *)
  ------------------
  |  Branch (3810:11): [True: 94, False: 0]
  |  Branch (3810:30): [True: 53, False: 41]
  ------------------
 3811|     53|	    content = value;
 3812|    110|	att = atts[i++];
 3813|    110|    }
 3814|     57|    if ((http) && (content != NULL))
  ------------------
  |  Branch (3814:9): [True: 14, False: 43]
  |  Branch (3814:19): [True: 14, False: 0]
  ------------------
 3815|     14|	htmlCheckEncoding(ctxt, content);
 3816|       |
 3817|     57|}
HTMLparser.c:htmlCheckEncoding:
 3763|     14|htmlCheckEncoding(htmlParserCtxtPtr ctxt, const xmlChar *attvalue) {
 3764|     14|    const xmlChar *encoding;
 3765|       |
 3766|     14|    if (!attvalue)
  ------------------
  |  Branch (3766:9): [True: 0, False: 14]
  ------------------
 3767|      0|	return;
 3768|       |
 3769|     14|    encoding = xmlStrcasestr(attvalue, BAD_CAST"charset");
  ------------------
  |  |   35|     14|#define BAD_CAST (xmlChar *)
  ------------------
 3770|     14|    if (encoding != NULL) {
  ------------------
  |  Branch (3770:9): [True: 14, False: 0]
  ------------------
 3771|     14|	encoding += 7;
 3772|     14|    }
 3773|       |    /*
 3774|       |     * skip blank
 3775|       |     */
 3776|     14|    if (encoding && IS_BLANK_CH(*encoding))
  ------------------
  |  |  151|     14|#define IS_BLANK_CH(c)  xmlIsBlank_ch(c)
  |  |  ------------------
  |  |  |  |   88|     14|#define xmlIsBlank_ch(c)	(((c) == 0x20) || \
  |  |  |  |  ------------------
  |  |  |  |  |  Branch (88:27): [True: 0, False: 14]
  |  |  |  |  ------------------
  |  |  |  |   89|     14|				 ((0x9 <= (c)) && ((c) <= 0xa)) || \
  |  |  |  |  ------------------
  |  |  |  |  |  Branch (89:7): [True: 14, False: 0]
  |  |  |  |  |  Branch (89:23): [True: 0, False: 14]
  |  |  |  |  ------------------
  |  |  |  |   90|     14|				 ((c) == 0xd))
  |  |  |  |  ------------------
  |  |  |  |  |  Branch (90:6): [True: 0, False: 14]
  |  |  |  |  ------------------
  |  |  ------------------
  ------------------
  |  Branch (3776:9): [True: 14, False: 0]
  ------------------
 3777|      0|	encoding = xmlStrcasestr(attvalue, BAD_CAST"=");
  ------------------
  |  |   35|      0|#define BAD_CAST (xmlChar *)
  ------------------
 3778|     14|    if (encoding && *encoding == '=') {
  ------------------
  |  Branch (3778:9): [True: 14, False: 0]
  |  Branch (3778:21): [True: 14, False: 0]
  ------------------
 3779|     14|	encoding ++;
 3780|     14|	xmlSetDeclaredEncoding(ctxt, xmlStrdup(encoding));
 3781|     14|    }
 3782|     14|}
HTMLparser.c:htmlnamePush:
  152|  13.2k|{
  153|  13.2k|    if ((ctxt->html < 3) && (xmlStrEqual(value, BAD_CAST "head")))
  ------------------
  |  |   35|    340|#define BAD_CAST (xmlChar *)
  ------------------
  |  Branch (153:9): [True: 340, False: 12.9k]
  |  Branch (153:29): [True: 82, False: 258]
  ------------------
  154|     82|        ctxt->html = 3;
  155|  13.2k|    if ((ctxt->html < 10) && (xmlStrEqual(value, BAD_CAST "body")))
  ------------------
  |  |   35|    602|#define BAD_CAST (xmlChar *)
  ------------------
  |  Branch (155:9): [True: 602, False: 12.6k]
  |  Branch (155:30): [True: 163, False: 439]
  ------------------
  156|    163|        ctxt->html = 10;
  157|  13.2k|    if (ctxt->nameNr >= ctxt->nameMax) {
  ------------------
  |  Branch (157:9): [True: 28, False: 13.2k]
  ------------------
  158|     28|        size_t newSize = ctxt->nameMax * 2;
  159|     28|        const xmlChar **tmp;
  160|       |
  161|     28|        tmp = xmlRealloc((xmlChar **) ctxt->nameTab,
  162|     28|                         newSize * sizeof(ctxt->nameTab[0]));
  163|     28|        if (tmp == NULL) {
  ------------------
  |  Branch (163:13): [True: 0, False: 28]
  ------------------
  164|      0|            htmlErrMemory(ctxt, NULL);
  165|      0|            return (-1);
  166|      0|        }
  167|     28|        ctxt->nameTab = tmp;
  168|     28|        ctxt->nameMax = newSize;
  169|     28|    }
  170|  13.2k|    ctxt->nameTab[ctxt->nameNr] = value;
  171|  13.2k|    ctxt->name = value;
  172|  13.2k|    return (ctxt->nameNr++);
  173|  13.2k|}
HTMLparser.c:htmlnamePop:
  184|  13.2k|{
  185|  13.2k|    const xmlChar *ret;
  186|       |
  187|  13.2k|    if (ctxt->nameNr <= 0)
  ------------------
  |  Branch (187:9): [True: 0, False: 13.2k]
  ------------------
  188|      0|        return (NULL);
  189|  13.2k|    ctxt->nameNr--;
  190|  13.2k|    if (ctxt->nameNr < 0)
  ------------------
  |  Branch (190:9): [True: 0, False: 13.2k]
  ------------------
  191|      0|        return (NULL);
  192|  13.2k|    if (ctxt->nameNr > 0)
  ------------------
  |  Branch (192:9): [True: 13.0k, False: 170]
  ------------------
  193|  13.0k|        ctxt->name = ctxt->nameTab[ctxt->nameNr - 1];
  194|    170|    else
  195|    170|        ctxt->name = NULL;
  196|  13.2k|    ret = ctxt->nameTab[ctxt->nameNr];
  197|  13.2k|    ctxt->nameTab[ctxt->nameNr] = NULL;
  198|  13.2k|    return (ret);
  199|  13.2k|}
HTMLparser.c:htmlParseEndTag:
 4046|  8.69k|{
 4047|  8.69k|    const xmlChar *name;
 4048|  8.69k|    const xmlChar *oldname;
 4049|  8.69k|    int i, ret;
 4050|       |
 4051|  8.69k|    if ((CUR != '<') || (NXT(1) != '/')) {
  ------------------
  |  |  304|  8.69k|#define CUR (*ctxt->input->cur)
  ------------------
                  if ((CUR != '<') || (NXT(1) != '/')) {
  ------------------
  |  |  285|  8.69k|#define NXT(val) ctxt->input->cur[(val)]
  ------------------
  |  Branch (4051:9): [True: 0, False: 8.69k]
  |  Branch (4051:25): [True: 0, False: 8.69k]
  ------------------
 4052|      0|        htmlParseErr(ctxt, XML_ERR_LTSLASH_REQUIRED,
 4053|      0|	             "htmlParseEndTag: '</' not found\n", NULL, NULL);
 4054|      0|        return (0);
 4055|      0|    }
 4056|  8.69k|    SKIP(2);
  ------------------
  |  |  283|  8.69k|#define SKIP(val) ctxt->input->cur += (val),ctxt->input->col+=(val)
  ------------------
 4057|       |
 4058|  8.69k|    name = htmlParseHTMLName(ctxt);
 4059|  8.69k|    if (name == NULL)
  ------------------
  |  Branch (4059:9): [True: 2, False: 8.69k]
  ------------------
 4060|      2|        return (0);
 4061|       |    /*
 4062|       |     * We should definitely be at the ending "S? '>'" part
 4063|       |     */
 4064|  8.69k|    SKIP_BLANKS;
  ------------------
  |  |  300|  8.69k|#define SKIP_BLANKS htmlSkipBlankChars(ctxt)
  ------------------
 4065|  8.69k|    if (CUR != '>') {
  ------------------
  |  |  304|  8.69k|#define CUR (*ctxt->input->cur)
  ------------------
  |  Branch (4065:9): [True: 29, False: 8.66k]
  ------------------
 4066|     29|        htmlParseErr(ctxt, XML_ERR_GT_REQUIRED,
 4067|     29|	             "End tag : expected '>'\n", NULL, NULL);
 4068|       |        /* Skip to next '>' */
 4069|    355|        while ((CUR != 0) && (CUR != '>'))
  ------------------
  |  |  304|    355|#define CUR (*ctxt->input->cur)
  ------------------
                      while ((CUR != 0) && (CUR != '>'))
  ------------------
  |  |  304|    355|#define CUR (*ctxt->input->cur)
  ------------------
  |  Branch (4069:16): [True: 355, False: 0]
  |  Branch (4069:30): [True: 326, False: 29]
  ------------------
 4070|    326|            NEXT;
  ------------------
  |  |  305|    326|#define NEXT xmlNextChar(ctxt)
  ------------------
 4071|     29|    }
 4072|  8.69k|    if (CUR == '>')
  ------------------
  |  |  304|  8.69k|#define CUR (*ctxt->input->cur)
  ------------------
  |  Branch (4072:9): [True: 8.69k, False: 0]
  ------------------
 4073|  8.69k|        NEXT;
  ------------------
  |  |  305|  8.69k|#define NEXT xmlNextChar(ctxt)
  ------------------
 4074|       |
 4075|       |    /*
 4076|       |     * if we ignored misplaced tags in htmlParseStartTag don't pop them
 4077|       |     * out now.
 4078|       |     */
 4079|  8.69k|    if ((ctxt->depth > 0) &&
  ------------------
  |  Branch (4079:9): [True: 22, False: 8.67k]
  ------------------
 4080|  8.69k|        (xmlStrEqual(name, BAD_CAST "html") ||
  ------------------
  |  |   35|     22|#define BAD_CAST (xmlChar *)
  ------------------
  |  Branch (4080:10): [True: 2, False: 20]
  ------------------
 4081|     22|         xmlStrEqual(name, BAD_CAST "body") ||
  ------------------
  |  |   35|     20|#define BAD_CAST (xmlChar *)
  ------------------
  |  Branch (4081:10): [True: 7, False: 13]
  ------------------
 4082|     22|	 xmlStrEqual(name, BAD_CAST "head"))) {
  ------------------
  |  |   35|     13|#define BAD_CAST (xmlChar *)
  ------------------
  |  Branch (4082:3): [True: 3, False: 10]
  ------------------
 4083|     12|	ctxt->depth--;
 4084|     12|	return (0);
 4085|     12|    }
 4086|       |
 4087|       |    /*
 4088|       |     * If the name read is not one of the element in the parsing stack
 4089|       |     * then return, it's just an error.
 4090|       |     */
 4091|  10.2k|    for (i = (ctxt->nameNr - 1); i >= 0; i--) {
  ------------------
  |  Branch (4091:34): [True: 10.0k, False: 185]
  ------------------
 4092|  10.0k|        if (xmlStrEqual(name, ctxt->nameTab[i]))
  ------------------
  |  Branch (4092:13): [True: 8.49k, False: 1.58k]
  ------------------
 4093|  8.49k|            break;
 4094|  10.0k|    }
 4095|  8.68k|    if (i < 0) {
  ------------------
  |  Branch (4095:9): [True: 185, False: 8.49k]
  ------------------
 4096|    185|        htmlParseErr(ctxt, XML_ERR_TAG_NAME_MISMATCH,
 4097|    185|	             "Unexpected end tag : %s\n", name, NULL);
 4098|    185|        return (0);
 4099|    185|    }
 4100|       |
 4101|       |
 4102|       |    /*
 4103|       |     * Check for auto-closure of HTML elements.
 4104|       |     */
 4105|       |
 4106|  8.49k|    htmlAutoCloseOnClose(ctxt, name);
 4107|       |
 4108|       |    /*
 4109|       |     * Well formedness constraints, opening and closing must match.
 4110|       |     * With the exception that the autoclose may have popped stuff out
 4111|       |     * of the stack.
 4112|       |     */
 4113|  8.49k|    if ((ctxt->name != NULL) && (!xmlStrEqual(ctxt->name, name))) {
  ------------------
  |  Branch (4113:9): [True: 8.49k, False: 0]
  |  Branch (4113:33): [True: 6, False: 8.49k]
  ------------------
 4114|      6|        htmlParseErr(ctxt, XML_ERR_TAG_NAME_MISMATCH,
 4115|      6|                     "Opening and ending tag mismatch: %s and %s\n",
 4116|      6|                     name, ctxt->name);
 4117|      6|    }
 4118|       |
 4119|       |    /*
 4120|       |     * SAX: End of Tag
 4121|       |     */
 4122|  8.49k|    oldname = ctxt->name;
 4123|  8.49k|    if ((oldname != NULL) && (xmlStrEqual(oldname, name))) {
  ------------------
  |  Branch (4123:9): [True: 8.49k, False: 0]
  |  Branch (4123:30): [True: 8.49k, False: 6]
  ------------------
 4124|  8.49k|        if ((ctxt->sax != NULL) && (ctxt->sax->endElement != NULL))
  ------------------
  |  Branch (4124:13): [True: 8.49k, False: 0]
  |  Branch (4124:36): [True: 8.49k, False: 0]
  ------------------
 4125|  8.49k|            ctxt->sax->endElement(ctxt->userData, name);
 4126|  8.49k|	htmlNodeInfoPop(ctxt);
 4127|  8.49k|        htmlnamePop(ctxt);
 4128|  8.49k|        ret = 1;
 4129|  8.49k|    } else {
 4130|      6|        ret = 0;
 4131|      6|    }
 4132|       |
 4133|  8.49k|    return (ret);
 4134|  8.68k|}
HTMLparser.c:htmlAutoCloseOnClose:
 1465|  8.49k|{
 1466|  8.49k|    const htmlElemDesc *info;
 1467|  8.49k|    int i, priority;
 1468|       |
 1469|  8.49k|    priority = htmlGetEndPriority(newtag);
 1470|       |
 1471|  8.78k|    for (i = (ctxt->nameNr - 1); i >= 0; i--) {
  ------------------
  |  Branch (1471:34): [True: 8.78k, False: 0]
  ------------------
 1472|       |
 1473|  8.78k|        if (xmlStrEqual(newtag, ctxt->nameTab[i]))
  ------------------
  |  Branch (1473:13): [True: 8.49k, False: 290]
  ------------------
 1474|  8.49k|            break;
 1475|       |        /*
 1476|       |         * A misplaced endtag can only close elements with lower
 1477|       |         * or equal priority, so if we find an element with higher
 1478|       |         * priority before we find an element with
 1479|       |         * matching name, we just ignore this endtag
 1480|       |         */
 1481|    290|        if (htmlGetEndPriority(ctxt->nameTab[i]) > priority)
  ------------------
  |  Branch (1481:13): [True: 6, False: 284]
  ------------------
 1482|      6|            return;
 1483|    290|    }
 1484|  8.49k|    if (i < 0)
  ------------------
  |  Branch (1484:9): [True: 0, False: 8.49k]
  ------------------
 1485|      0|        return;
 1486|       |
 1487|  8.77k|    while (!xmlStrEqual(newtag, ctxt->name)) {
  ------------------
  |  Branch (1487:12): [True: 284, False: 8.49k]
  ------------------
 1488|    284|        info = htmlTagLookup(ctxt->name);
 1489|    284|        if ((info != NULL) && (info->endTag == 3)) {
  ------------------
  |  Branch (1489:13): [True: 278, False: 6]
  |  Branch (1489:31): [True: 113, False: 165]
  ------------------
 1490|    113|            htmlParseErr(ctxt, XML_ERR_TAG_NAME_MISMATCH,
 1491|    113|	                 "Opening and ending tag mismatch: %s and %s\n",
 1492|    113|			 newtag, ctxt->name);
 1493|    113|        }
 1494|    284|        if ((ctxt->sax != NULL) && (ctxt->sax->endElement != NULL))
  ------------------
  |  Branch (1494:13): [True: 284, False: 0]
  |  Branch (1494:36): [True: 284, False: 0]
  ------------------
 1495|    284|            ctxt->sax->endElement(ctxt->userData, ctxt->name);
 1496|    284|	htmlnamePop(ctxt);
 1497|    284|    }
 1498|  8.49k|}
HTMLparser.c:htmlGetEndPriority:
 1407|  8.78k|htmlGetEndPriority (const xmlChar *name) {
 1408|  8.78k|    int i = 0;
 1409|       |
 1410|  91.1k|    while ((htmlEndPriority[i].name != NULL) &&
  ------------------
  |  Branch (1410:12): [True: 84.3k, False: 6.82k]
  ------------------
 1411|  91.1k|	   (!xmlStrEqual((const xmlChar *)htmlEndPriority[i].name, name)))
  ------------------
  |  Branch (1411:5): [True: 82.3k, False: 1.95k]
  ------------------
 1412|  82.3k|	i++;
 1413|       |
 1414|  8.78k|    return(htmlEndPriority[i].priority);
 1415|  8.78k|}
HTMLparser.c:htmlNodeInfoPop:
  241|  8.49k|{
  242|  8.49k|    if (ctxt->nodeInfoNr <= 0)
  ------------------
  |  Branch (242:9): [True: 8.49k, False: 0]
  ------------------
  243|  8.49k|        return (NULL);
  244|      0|    ctxt->nodeInfoNr--;
  245|      0|    if (ctxt->nodeInfoNr < 0)
  ------------------
  |  Branch (245:9): [True: 0, False: 0]
  ------------------
  246|      0|        return (NULL);
  247|      0|    if (ctxt->nodeInfoNr > 0)
  ------------------
  |  Branch (247:9): [True: 0, False: 0]
  ------------------
  248|      0|        ctxt->nodeInfo = &ctxt->nodeInfoTab[ctxt->nodeInfoNr - 1];
  249|      0|    else
  250|      0|        ctxt->nodeInfo = NULL;
  251|      0|    return &ctxt->nodeInfoTab[ctxt->nodeInfoNr];
  252|      0|}
HTMLparser.c:htmlParseHTMLName_nonInvasive:
 2571|  6.64k|htmlParseHTMLName_nonInvasive(htmlParserCtxtPtr ctxt) {
 2572|  6.64k|    int i = 0;
 2573|  6.64k|    xmlChar loc[HTML_PARSER_BUFFER_SIZE];
 2574|       |
 2575|  6.64k|    if (!IS_ASCII_LETTER(NXT(1)) && (NXT(1) != '_') &&
  ------------------
  |  |  258|  13.2k|#define IS_ASCII_LETTER(c)	(((0x41 <= (c)) && ((c) <= 0x5a)) || \
  |  |  ------------------
  |  |  |  Branch (258:30): [True: 6.64k, False: 0]
  |  |  |  Branch (258:47): [True: 3.23k, False: 3.40k]
  |  |  ------------------
  |  |  259|  13.2k|				 ((0x61 <= (c)) && ((c) <= 0x7a)))
  |  |  ------------------
  |  |  |  Branch (259:7): [True: 3.40k, False: 0]
  |  |  |  Branch (259:24): [True: 3.40k, False: 0]
  |  |  ------------------
  ------------------
                  if (!IS_ASCII_LETTER(NXT(1)) && (NXT(1) != '_') &&
  ------------------
  |  |  285|      0|#define NXT(val) ctxt->input->cur[(val)]
  ------------------
  |  Branch (2575:37): [True: 0, False: 0]
  ------------------
 2576|  6.64k|        (NXT(1) != ':')) return(NULL);
  ------------------
  |  |  285|      0|#define NXT(val) ctxt->input->cur[(val)]
  ------------------
  |  Branch (2576:9): [True: 0, False: 0]
  ------------------
 2577|       |
 2578|  24.4k|    while ((i < HTML_PARSER_BUFFER_SIZE) &&
  ------------------
  |  |   39|  24.4k|#define HTML_PARSER_BUFFER_SIZE 100
  ------------------
  |  Branch (2578:12): [True: 24.4k, False: 0]
  ------------------
 2579|  24.4k|           ((IS_ASCII_LETTER(NXT(1+i))) || (IS_ASCII_DIGIT(NXT(1+i))) ||
  ------------------
  |  |  258|  24.4k|#define IS_ASCII_LETTER(c)	(((0x41 <= (c)) && ((c) <= 0x5a)) || \
  |  |  ------------------
  |  |  |  Branch (258:30): [True: 17.7k, False: 6.72k]
  |  |  |  Branch (258:47): [True: 8.97k, False: 8.78k]
  |  |  ------------------
  |  |  259|  24.4k|				 ((0x61 <= (c)) && ((c) <= 0x7a)))
  |  |  ------------------
  |  |  |  Branch (259:7): [True: 8.78k, False: 6.72k]
  |  |  |  Branch (259:24): [True: 8.78k, False: 0]
  |  |  ------------------
  ------------------
                         ((IS_ASCII_LETTER(NXT(1+i))) || (IS_ASCII_DIGIT(NXT(1+i))) ||
  ------------------
  |  |  268|  6.72k|#define IS_ASCII_DIGIT(c)	((0x30 <= (c)) && ((c) <= 0x39))
  |  |  ------------------
  |  |  |  Branch (268:28): [True: 3.22k, False: 3.50k]
  |  |  |  Branch (268:45): [True: 78, False: 3.14k]
  |  |  ------------------
  ------------------
 2580|  24.4k|	   (NXT(1+i) == ':') || (NXT(1+i) == '-') || (NXT(1+i) == '_'))) {
  ------------------
  |  |  285|  6.64k|#define NXT(val) ctxt->input->cur[(val)]
  ------------------
              	   (NXT(1+i) == ':') || (NXT(1+i) == '-') || (NXT(1+i) == '_'))) {
  ------------------
  |  |  285|  6.64k|#define NXT(val) ctxt->input->cur[(val)]
  ------------------
              	   (NXT(1+i) == ':') || (NXT(1+i) == '-') || (NXT(1+i) == '_'))) {
  ------------------
  |  |  285|  6.64k|#define NXT(val) ctxt->input->cur[(val)]
  ------------------
  |  Branch (2580:5): [True: 2, False: 6.64k]
  |  Branch (2580:26): [True: 0, False: 6.64k]
  |  Branch (2580:47): [True: 0, False: 6.64k]
  ------------------
 2581|  17.8k|	if ((NXT(1+i) >= 'A') && (NXT(1+i) <= 'Z')) loc[i] = NXT(1+i) + 0x20;
  ------------------
  |  |  285|  17.8k|#define NXT(val) ctxt->input->cur[(val)]
  ------------------
              	if ((NXT(1+i) >= 'A') && (NXT(1+i) <= 'Z')) loc[i] = NXT(1+i) + 0x20;
  ------------------
  |  |  285|  17.7k|#define NXT(val) ctxt->input->cur[(val)]
  ------------------
              	if ((NXT(1+i) >= 'A') && (NXT(1+i) <= 'Z')) loc[i] = NXT(1+i) + 0x20;
  ------------------
  |  |  285|  8.97k|#define NXT(val) ctxt->input->cur[(val)]
  ------------------
  |  Branch (2581:6): [True: 17.7k, False: 80]
  |  Branch (2581:27): [True: 8.97k, False: 8.78k]
  ------------------
 2582|  8.86k|        else loc[i] = NXT(1+i);
  ------------------
  |  |  285|  8.86k|#define NXT(val) ctxt->input->cur[(val)]
  ------------------
 2583|  17.8k|	i++;
 2584|  17.8k|    }
 2585|       |
 2586|  6.64k|    return(xmlDictLookup(ctxt->dict, loc, i));
 2587|  6.64k|}
HTMLparser.c:htmlParseScript:
 3068|     99|htmlParseScript(htmlParserCtxtPtr ctxt) {
 3069|     99|    xmlChar buf[HTML_PARSER_BIG_BUFFER_SIZE + 5];
 3070|     99|    int nbchar = 0;
 3071|     99|    int cur,l;
 3072|       |
 3073|     99|    cur = CUR_CHAR(l);
  ------------------
  |  |  323|     99|#define CUR_CHAR(l) htmlCurrentChar(ctxt, &l)
  ------------------
 3074|  23.3k|    while (cur != 0) {
  ------------------
  |  Branch (3074:12): [True: 23.3k, False: 0]
  ------------------
 3075|  23.3k|	if ((cur == '<') && (NXT(1) == '/')) {
  ------------------
  |  |  285|    173|#define NXT(val) ctxt->input->cur[(val)]
  ------------------
  |  Branch (3075:6): [True: 173, False: 23.1k]
  |  Branch (3075:22): [True: 99, False: 74]
  ------------------
 3076|       |            /*
 3077|       |             * One should break here, the specification is clear:
 3078|       |             * Authors should therefore escape "</" within the content.
 3079|       |             * Escape mechanisms are specific to each scripting or
 3080|       |             * style sheet language.
 3081|       |             *
 3082|       |             * In recovery mode, only break if end tag match the
 3083|       |             * current tag, effectively ignoring all tags inside the
 3084|       |             * script/style block and treating the entire block as
 3085|       |             * CDATA.
 3086|       |             */
 3087|     99|            if (ctxt->recovery) {
  ------------------
  |  Branch (3087:17): [True: 0, False: 99]
  ------------------
 3088|      0|                if (xmlStrncasecmp(ctxt->name, ctxt->input->cur+2,
  ------------------
  |  Branch (3088:21): [True: 0, False: 0]
  ------------------
 3089|      0|				   xmlStrlen(ctxt->name)) == 0)
 3090|      0|                {
 3091|      0|                    break; /* while */
 3092|      0|                } else {
 3093|      0|		    htmlParseErr(ctxt, XML_ERR_TAG_NAME_MISMATCH,
 3094|      0|				 "Element %s embeds close tag\n",
 3095|      0|		                 ctxt->name, NULL);
 3096|      0|		}
 3097|     99|            } else {
 3098|     99|                if (((NXT(2) >= 'A') && (NXT(2) <= 'Z')) ||
  ------------------
  |  |  285|     99|#define NXT(val) ctxt->input->cur[(val)]
  ------------------
                              if (((NXT(2) >= 'A') && (NXT(2) <= 'Z')) ||
  ------------------
  |  |  285|     99|#define NXT(val) ctxt->input->cur[(val)]
  ------------------
  |  Branch (3098:22): [True: 99, False: 0]
  |  Branch (3098:41): [True: 90, False: 9]
  ------------------
 3099|     99|                    ((NXT(2) >= 'a') && (NXT(2) <= 'z')))
  ------------------
  |  |  285|      9|#define NXT(val) ctxt->input->cur[(val)]
  ------------------
                                  ((NXT(2) >= 'a') && (NXT(2) <= 'z')))
  ------------------
  |  |  285|      9|#define NXT(val) ctxt->input->cur[(val)]
  ------------------
  |  Branch (3099:22): [True: 9, False: 0]
  |  Branch (3099:41): [True: 9, False: 0]
  ------------------
 3100|     99|                {
 3101|     99|                    break; /* while */
 3102|     99|                }
 3103|     99|            }
 3104|     99|	}
 3105|  23.2k|        if (IS_CHAR(cur)) {
  ------------------
  |  |  125|  23.2k|#define IS_CHAR(c)   xmlIsCharQ(c)
  |  |  ------------------
  |  |  |  |  118|  23.2k|#define xmlIsCharQ(c)		(((c) < 0x100) ? \
  |  |  |  |  ------------------
  |  |  |  |  |  Branch (118:24): [True: 23.2k, False: 0]
  |  |  |  |  |  Branch (118:25): [True: 23.2k, False: 18]
  |  |  |  |  ------------------
  |  |  |  |  119|  23.2k|				 xmlIsChar_ch((c)) :\
  |  |  |  |  ------------------
  |  |  |  |  |  |  108|  23.2k|#define xmlIsChar_ch(c)		(((0x9 <= (c)) && ((c) <= 0xa)) || \
  |  |  |  |  |  |  ------------------
  |  |  |  |  |  |  |  Branch (108:28): [True: 23.2k, False: 0]
  |  |  |  |  |  |  |  Branch (108:44): [True: 1.73k, False: 21.4k]
  |  |  |  |  |  |  ------------------
  |  |  |  |  |  |  109|  23.2k|				 ((c) == 0xd) || \
  |  |  |  |  |  |  ------------------
  |  |  |  |  |  |  |  Branch (109:6): [True: 234, False: 21.2k]
  |  |  |  |  |  |  ------------------
  |  |  |  |  |  |  110|  23.2k|				  (0x20 <= (c)))
  |  |  |  |  |  |  ------------------
  |  |  |  |  |  |  |  Branch (110:7): [True: 21.2k, False: 0]
  |  |  |  |  |  |  ------------------
  |  |  |  |  ------------------
  |  |  |  |  120|  23.2k|				(((0x100 <= (c)) && ((c) <= 0xd7ff)) || \
  |  |  |  |  ------------------
  |  |  |  |  |  Branch (120:7): [True: 18, False: 0]
  |  |  |  |  |  Branch (120:25): [True: 18, False: 0]
  |  |  |  |  ------------------
  |  |  |  |  121|     18|				 ((0xe000 <= (c)) && ((c) <= 0xfffd)) || \
  |  |  |  |  ------------------
  |  |  |  |  |  Branch (121:7): [True: 0, False: 0]
  |  |  |  |  |  Branch (121:26): [True: 0, False: 0]
  |  |  |  |  ------------------
  |  |  |  |  122|     18|				 ((0x10000 <= (c)) && ((c) <= 0x10ffff))))
  |  |  |  |  ------------------
  |  |  |  |  |  Branch (122:7): [True: 0, False: 0]
  |  |  |  |  |  Branch (122:27): [True: 0, False: 0]
  |  |  |  |  ------------------
  |  |  ------------------
  ------------------
 3106|  23.2k|	    COPY_BUF(l,buf,nbchar,cur);
  ------------------
  |  |  326|  23.2k|    if (l == 1) b[i++] = v;						\
  |  |  ------------------
  |  |  |  Branch (326:9): [True: 23.2k, False: 30]
  |  |  ------------------
  |  |  327|  23.2k|    else i += xmlCopyChar(l,&b[i],v)
  ------------------
 3107|  23.2k|        } else {
 3108|      0|            htmlParseErrInt(ctxt, XML_ERR_INVALID_CHAR,
 3109|      0|                            "Invalid char in CDATA 0x%X\n", cur);
 3110|      0|        }
 3111|  23.2k|	NEXTL(l);
  ------------------
  |  |  310|  23.2k|#define NEXTL(l) do {							\
  |  |  311|  23.2k|    if (*(ctxt->input->cur) == '\n') {					\
  |  |  ------------------
  |  |  |  Branch (311:9): [True: 522, False: 22.7k]
  |  |  ------------------
  |  |  312|    522|	ctxt->input->line++; ctxt->input->col = 1;			\
  |  |  313|  22.7k|    } else ctxt->input->col++;						\
  |  |  314|  23.2k|    ctxt->token = 0; ctxt->input->cur += l;				\
  |  |  315|  23.2k|  } while (0)
  |  |  ------------------
  |  |  |  Branch (315:12): [Folded - Ignored]
  |  |  ------------------
  ------------------
 3112|  23.2k|	if (nbchar >= HTML_PARSER_BIG_BUFFER_SIZE) {
  ------------------
  |  |   38|  23.2k|#define HTML_PARSER_BIG_BUFFER_SIZE 1000
  ------------------
  |  Branch (3112:6): [True: 6, False: 23.2k]
  ------------------
 3113|      6|            buf[nbchar] = 0;
 3114|      6|	    if (ctxt->sax->cdataBlock!= NULL) {
  ------------------
  |  Branch (3114:10): [True: 6, False: 0]
  ------------------
 3115|       |		/*
 3116|       |		 * Insert as CDATA, which is the same as HTML_PRESERVE_NODE
 3117|       |		 */
 3118|      6|		ctxt->sax->cdataBlock(ctxt->userData, buf, nbchar);
 3119|      6|	    } else if (ctxt->sax->characters != NULL) {
  ------------------
  |  Branch (3119:17): [True: 0, False: 0]
  ------------------
 3120|      0|		ctxt->sax->characters(ctxt->userData, buf, nbchar);
 3121|      0|	    }
 3122|      6|	    nbchar = 0;
 3123|      6|            SHRINK;
  ------------------
  |  |  292|      6|#define SHRINK if ((ctxt->input->cur - ctxt->input->base > 2 * INPUT_CHUNK) && \
  |  |  ------------------
  |  |  |  |   97|      6|#define INPUT_CHUNK	250
  |  |  ------------------
  |  |  |  Branch (292:20): [True: 6, False: 0]
  |  |  ------------------
  |  |  293|      6|		   (ctxt->input->end - ctxt->input->cur < 2 * INPUT_CHUNK)) \
  |  |  ------------------
  |  |  |  |   97|      6|#define INPUT_CHUNK	250
  |  |  ------------------
  |  |  |  Branch (293:6): [True: 0, False: 6]
  |  |  ------------------
  |  |  294|      6|	xmlParserShrink(ctxt)
  ------------------
 3124|      6|	}
 3125|  23.2k|	cur = CUR_CHAR(l);
  ------------------
  |  |  323|  23.2k|#define CUR_CHAR(l) htmlCurrentChar(ctxt, &l)
  ------------------
 3126|  23.2k|    }
 3127|       |
 3128|     99|    if (ctxt->instate == XML_PARSER_EOF)
  ------------------
  |  Branch (3128:9): [True: 0, False: 99]
  ------------------
 3129|      0|        return;
 3130|       |
 3131|     99|    if ((nbchar != 0) && (ctxt->sax != NULL) && (!ctxt->disableSAX)) {
  ------------------
  |  Branch (3131:9): [True: 66, False: 33]
  |  Branch (3131:26): [True: 66, False: 0]
  |  Branch (3131:49): [True: 64, False: 2]
  ------------------
 3132|     64|        buf[nbchar] = 0;
 3133|     64|	if (ctxt->sax->cdataBlock!= NULL) {
  ------------------
  |  Branch (3133:6): [True: 64, False: 0]
  ------------------
 3134|       |	    /*
 3135|       |	     * Insert as CDATA, which is the same as HTML_PRESERVE_NODE
 3136|       |	     */
 3137|     64|	    ctxt->sax->cdataBlock(ctxt->userData, buf, nbchar);
 3138|     64|	} else if (ctxt->sax->characters != NULL) {
  ------------------
  |  Branch (3138:13): [True: 0, False: 0]
  ------------------
 3139|      0|	    ctxt->sax->characters(ctxt->userData, buf, nbchar);
 3140|      0|	}
 3141|     64|    }
 3142|     99|}
HTMLparser.c:htmlSkipBogusComment:
 2507|     10|htmlSkipBogusComment(htmlParserCtxtPtr ctxt) {
 2508|     10|    int c;
 2509|       |
 2510|     10|    htmlParseErr(ctxt, XML_HTML_INCORRECTLY_OPENED_COMMENT,
 2511|     10|                 "Incorrectly opened comment\n", NULL, NULL);
 2512|       |
 2513|    157|    do {
 2514|    157|        c = CUR;
  ------------------
  |  |  304|    157|#define CUR (*ctxt->input->cur)
  ------------------
 2515|    157|        if (c == 0)
  ------------------
  |  Branch (2515:13): [True: 0, False: 157]
  ------------------
 2516|      0|            break;
 2517|    157|        NEXT;
  ------------------
  |  |  305|    157|#define NEXT xmlNextChar(ctxt)
  ------------------
 2518|    157|    } while (c != '>');
  ------------------
  |  Branch (2518:14): [True: 147, False: 10]
  ------------------
 2519|     10|}
HTMLparser.c:htmlParseReference:
 4146|  1.06k|htmlParseReference(htmlParserCtxtPtr ctxt) {
 4147|  1.06k|    const htmlEntityDesc * ent;
 4148|  1.06k|    xmlChar out[6];
 4149|  1.06k|    const xmlChar *name;
 4150|  1.06k|    if (CUR != '&') return;
  ------------------
  |  |  304|  1.06k|#define CUR (*ctxt->input->cur)
  ------------------
  |  Branch (4150:9): [True: 0, False: 1.06k]
  ------------------
 4151|       |
 4152|  1.06k|    if (NXT(1) == '#') {
  ------------------
  |  |  285|  1.06k|#define NXT(val) ctxt->input->cur[(val)]
  ------------------
  |  Branch (4152:9): [True: 204, False: 857]
  ------------------
 4153|    204|	unsigned int c;
 4154|    204|	int bits, i = 0;
 4155|       |
 4156|    204|	c = htmlParseCharRef(ctxt);
 4157|    204|	if (c == 0)
  ------------------
  |  Branch (4157:6): [True: 0, False: 204]
  ------------------
 4158|      0|	    return;
 4159|       |
 4160|    204|        if      (c <    0x80) { out[i++]= c;                bits= -6; }
  ------------------
  |  Branch (4160:18): [True: 0, False: 204]
  ------------------
 4161|    204|        else if (c <   0x800) { out[i++]=((c >>  6) & 0x1F) | 0xC0;  bits=  0; }
  ------------------
  |  Branch (4161:18): [True: 144, False: 60]
  ------------------
 4162|     60|        else if (c < 0x10000) { out[i++]=((c >> 12) & 0x0F) | 0xE0;  bits=  6; }
  ------------------
  |  Branch (4162:18): [True: 60, False: 0]
  ------------------
 4163|      0|        else                  { out[i++]=((c >> 18) & 0x07) | 0xF0;  bits= 12; }
 4164|       |
 4165|    468|        for ( ; bits >= 0; bits-= 6) {
  ------------------
  |  Branch (4165:17): [True: 264, False: 204]
  ------------------
 4166|    264|            out[i++]= ((c >> bits) & 0x3F) | 0x80;
 4167|    264|        }
 4168|    204|	out[i] = 0;
 4169|       |
 4170|    204|	htmlCheckParagraph(ctxt);
 4171|    204|	if ((ctxt->sax != NULL) && (ctxt->sax->characters != NULL))
  ------------------
  |  Branch (4171:6): [True: 204, False: 0]
  |  Branch (4171:29): [True: 204, False: 0]
  ------------------
 4172|    204|	    ctxt->sax->characters(ctxt->userData, out, i);
 4173|    857|    } else {
 4174|    857|	ent = htmlParseEntityRef(ctxt, &name);
 4175|    857|	if (name == NULL) {
  ------------------
  |  Branch (4175:6): [True: 19, False: 838]
  ------------------
 4176|     19|	    htmlCheckParagraph(ctxt);
 4177|     19|	    if ((ctxt->sax != NULL) && (ctxt->sax->characters != NULL))
  ------------------
  |  Branch (4177:10): [True: 19, False: 0]
  |  Branch (4177:33): [True: 19, False: 0]
  ------------------
 4178|     19|	        ctxt->sax->characters(ctxt->userData, BAD_CAST "&", 1);
  ------------------
  |  |   35|     19|#define BAD_CAST (xmlChar *)
  ------------------
 4179|     19|	    return;
 4180|     19|	}
 4181|    838|	if ((ent == NULL) || !(ent->value > 0)) {
  ------------------
  |  Branch (4181:6): [True: 11, False: 827]
  |  Branch (4181:23): [True: 0, False: 827]
  ------------------
 4182|     11|	    htmlCheckParagraph(ctxt);
 4183|     11|	    if ((ctxt->sax != NULL) && (ctxt->sax->characters != NULL)) {
  ------------------
  |  Branch (4183:10): [True: 11, False: 0]
  |  Branch (4183:33): [True: 11, False: 0]
  ------------------
 4184|     11|		ctxt->sax->characters(ctxt->userData, BAD_CAST "&", 1);
  ------------------
  |  |   35|     11|#define BAD_CAST (xmlChar *)
  ------------------
 4185|     11|		ctxt->sax->characters(ctxt->userData, name, xmlStrlen(name));
 4186|       |		/* ctxt->sax->characters(ctxt->userData, BAD_CAST ";", 1); */
 4187|     11|	    }
 4188|    827|	} else {
 4189|    827|	    unsigned int c;
 4190|    827|	    int bits, i = 0;
 4191|       |
 4192|    827|	    c = ent->value;
 4193|    827|	    if      (c <    0x80)
  ------------------
  |  Branch (4193:15): [True: 36, False: 791]
  ------------------
 4194|     36|	            { out[i++]= c;                bits= -6; }
 4195|    791|	    else if (c <   0x800)
  ------------------
  |  Branch (4195:15): [True: 743, False: 48]
  ------------------
 4196|    743|	            { out[i++]=((c >>  6) & 0x1F) | 0xC0;  bits=  0; }
 4197|     48|	    else if (c < 0x10000)
  ------------------
  |  Branch (4197:15): [True: 48, False: 0]
  ------------------
 4198|     48|	            { out[i++]=((c >> 12) & 0x0F) | 0xE0;  bits=  6; }
 4199|      0|	    else
 4200|      0|	            { out[i++]=((c >> 18) & 0x07) | 0xF0;  bits= 12; }
 4201|       |
 4202|  1.66k|	    for ( ; bits >= 0; bits-= 6) {
  ------------------
  |  Branch (4202:14): [True: 839, False: 827]
  ------------------
 4203|    839|		out[i++]= ((c >> bits) & 0x3F) | 0x80;
 4204|    839|	    }
 4205|    827|	    out[i] = 0;
 4206|       |
 4207|    827|	    htmlCheckParagraph(ctxt);
 4208|    827|	    if ((ctxt->sax != NULL) && (ctxt->sax->characters != NULL))
  ------------------
  |  Branch (4208:10): [True: 827, False: 0]
  |  Branch (4208:33): [True: 827, False: 0]
  ------------------
 4209|    827|		ctxt->sax->characters(ctxt->userData, out, i);
 4210|    827|	}
 4211|    838|    }
 4212|  1.06k|}
HTMLparser.c:htmlCheckParagraph:
 1676|  8.82k|htmlCheckParagraph(htmlParserCtxtPtr ctxt) {
 1677|  8.82k|    const xmlChar *tag;
 1678|  8.82k|    int i;
 1679|       |
 1680|  8.82k|    if (ctxt == NULL)
  ------------------
  |  Branch (1680:9): [True: 0, False: 8.82k]
  ------------------
 1681|      0|	return(-1);
 1682|  8.82k|    tag = ctxt->name;
 1683|  8.82k|    if (tag == NULL) {
  ------------------
  |  Branch (1683:9): [True: 21, False: 8.79k]
  ------------------
 1684|     21|	htmlAutoClose(ctxt, BAD_CAST"p");
  ------------------
  |  |   35|     21|#define BAD_CAST (xmlChar *)
  ------------------
 1685|     21|	htmlCheckImplied(ctxt, BAD_CAST"p");
  ------------------
  |  |   35|     21|#define BAD_CAST (xmlChar *)
  ------------------
 1686|     21|	htmlnamePush(ctxt, BAD_CAST"p");
  ------------------
  |  |   35|     21|#define BAD_CAST (xmlChar *)
  ------------------
 1687|     21|	if ((ctxt->sax != NULL) && (ctxt->sax->startElement != NULL))
  ------------------
  |  Branch (1687:6): [True: 21, False: 0]
  |  Branch (1687:29): [True: 21, False: 0]
  ------------------
 1688|     21|	    ctxt->sax->startElement(ctxt->userData, BAD_CAST"p", NULL);
  ------------------
  |  |   35|     21|#define BAD_CAST (xmlChar *)
  ------------------
 1689|     21|	return(1);
 1690|     21|    }
 1691|  8.79k|    if (!htmlOmittedDefaultValue)
  ------------------
  |  Branch (1691:9): [True: 0, False: 8.79k]
  ------------------
 1692|      0|	return(0);
 1693|  26.3k|    for (i = 0; htmlNoContentElements[i] != NULL; i++) {
  ------------------
  |  Branch (1693:17): [True: 17.5k, False: 8.78k]
  ------------------
 1694|  17.5k|	if (xmlStrEqual(tag, BAD_CAST htmlNoContentElements[i])) {
  ------------------
  |  |   35|  17.5k|#define BAD_CAST (xmlChar *)
  ------------------
  |  Branch (1694:6): [True: 10, False: 17.5k]
  ------------------
 1695|     10|	    htmlAutoClose(ctxt, BAD_CAST"p");
  ------------------
  |  |   35|     10|#define BAD_CAST (xmlChar *)
  ------------------
 1696|     10|	    htmlCheckImplied(ctxt, BAD_CAST"p");
  ------------------
  |  |   35|     10|#define BAD_CAST (xmlChar *)
  ------------------
 1697|     10|	    htmlnamePush(ctxt, BAD_CAST"p");
  ------------------
  |  |   35|     10|#define BAD_CAST (xmlChar *)
  ------------------
 1698|     10|	    if ((ctxt->sax != NULL) && (ctxt->sax->startElement != NULL))
  ------------------
  |  Branch (1698:10): [True: 10, False: 0]
  |  Branch (1698:33): [True: 10, False: 0]
  ------------------
 1699|     10|		ctxt->sax->startElement(ctxt->userData, BAD_CAST"p", NULL);
  ------------------
  |  |   35|     10|#define BAD_CAST (xmlChar *)
  ------------------
 1700|     10|	    return(1);
 1701|     10|	}
 1702|  17.5k|    }
 1703|  8.78k|    return(0);
 1704|  8.79k|}
HTMLparser.c:htmlParseCharData:
 3241|  10.8k|htmlParseCharData(htmlParserCtxtPtr ctxt) {
 3242|  10.8k|    htmlParseCharDataInternal(ctxt, 0);
 3243|  10.8k|}
HTMLparser.c:htmlParseCharDataInternal:
 3157|  10.8k|htmlParseCharDataInternal(htmlParserCtxtPtr ctxt, int readahead) {
 3158|  10.8k|    xmlChar buf[HTML_PARSER_BIG_BUFFER_SIZE + 6];
 3159|  10.8k|    int nbchar = 0;
 3160|  10.8k|    int cur, l;
 3161|       |
 3162|  10.8k|    if (readahead)
  ------------------
  |  Branch (3162:9): [True: 0, False: 10.8k]
  ------------------
 3163|      0|        buf[nbchar++] = readahead;
 3164|       |
 3165|  10.8k|    cur = CUR_CHAR(l);
  ------------------
  |  |  323|  10.8k|#define CUR_CHAR(l) htmlCurrentChar(ctxt, &l)
  ------------------
 3166|   232k|    while (((cur != '<') || (ctxt->token == '<')) &&
  ------------------
  |  Branch (3166:13): [True: 221k, False: 10.1k]
  |  Branch (3166:29): [True: 0, False: 10.1k]
  ------------------
 3167|   232k|           ((cur != '&') || (ctxt->token == '&')) &&
  ------------------
  |  Branch (3167:13): [True: 221k, False: 567]
  |  Branch (3167:29): [True: 0, False: 567]
  ------------------
 3168|   232k|	   (cur != 0)) {
  ------------------
  |  Branch (3168:5): [True: 221k, False: 149]
  ------------------
 3169|   221k|	if (!(IS_CHAR(cur))) {
  ------------------
  |  |  125|   221k|#define IS_CHAR(c)   xmlIsCharQ(c)
  |  |  ------------------
  |  |  |  |  118|   221k|#define xmlIsCharQ(c)		(((c) < 0x100) ? \
  |  |  |  |  ------------------
  |  |  |  |  |  Branch (118:25): [True: 208k, False: 12.5k]
  |  |  |  |  ------------------
  |  |  |  |  119|   221k|				 xmlIsChar_ch((c)) :\
  |  |  |  |  ------------------
  |  |  |  |  |  |  108|   208k|#define xmlIsChar_ch(c)		(((0x9 <= (c)) && ((c) <= 0xa)) || \
  |  |  |  |  |  |  ------------------
  |  |  |  |  |  |  |  Branch (108:28): [True: 208k, False: 1]
  |  |  |  |  |  |  |  Branch (108:44): [True: 9.42k, False: 199k]
  |  |  |  |  |  |  ------------------
  |  |  |  |  |  |  109|   208k|				 ((c) == 0xd) || \
  |  |  |  |  |  |  ------------------
  |  |  |  |  |  |  |  Branch (109:6): [True: 2.97k, False: 196k]
  |  |  |  |  |  |  ------------------
  |  |  |  |  |  |  110|   208k|				  (0x20 <= (c)))
  |  |  |  |  |  |  ------------------
  |  |  |  |  |  |  |  Branch (110:7): [True: 196k, False: 3]
  |  |  |  |  |  |  ------------------
  |  |  |  |  ------------------
  |  |  |  |  120|   221k|				(((0x100 <= (c)) && ((c) <= 0xd7ff)) || \
  |  |  |  |  ------------------
  |  |  |  |  |  Branch (120:7): [True: 12.5k, False: 0]
  |  |  |  |  |  Branch (120:25): [True: 12.5k, False: 0]
  |  |  |  |  ------------------
  |  |  |  |  121|  12.5k|				 ((0xe000 <= (c)) && ((c) <= 0xfffd)) || \
  |  |  |  |  ------------------
  |  |  |  |  |  Branch (121:7): [True: 0, False: 0]
  |  |  |  |  |  Branch (121:26): [True: 0, False: 0]
  |  |  |  |  ------------------
  |  |  |  |  122|  12.5k|				 ((0x10000 <= (c)) && ((c) <= 0x10ffff))))
  |  |  |  |  ------------------
  |  |  |  |  |  Branch (122:7): [True: 0, False: 0]
  |  |  |  |  |  Branch (122:27): [True: 0, False: 0]
  |  |  |  |  ------------------
  |  |  ------------------
  ------------------
  |  Branch (3169:6): [True: 3, False: 221k]
  ------------------
 3170|      3|	    htmlParseErrInt(ctxt, XML_ERR_INVALID_CHAR,
 3171|      3|	                "Invalid char in CDATA 0x%X\n", cur);
 3172|   221k|	} else {
 3173|   221k|	    COPY_BUF(l,buf,nbchar,cur);
  ------------------
  |  |  326|   221k|    if (l == 1) b[i++] = v;						\
  |  |  ------------------
  |  |  |  Branch (326:9): [True: 208k, False: 13.0k]
  |  |  ------------------
  |  |  327|   221k|    else i += xmlCopyChar(l,&b[i],v)
  ------------------
 3174|   221k|	}
 3175|   221k|	NEXTL(l);
  ------------------
  |  |  310|   221k|#define NEXTL(l) do {							\
  |  |  311|   221k|    if (*(ctxt->input->cur) == '\n') {					\
  |  |  ------------------
  |  |  |  Branch (311:9): [True: 8.71k, False: 212k]
  |  |  ------------------
  |  |  312|  8.71k|	ctxt->input->line++; ctxt->input->col = 1;			\
  |  |  313|   212k|    } else ctxt->input->col++;						\
  |  |  314|   221k|    ctxt->token = 0; ctxt->input->cur += l;				\
  |  |  315|   221k|  } while (0)
  |  |  ------------------
  |  |  |  Branch (315:12): [Folded - Ignored]
  |  |  ------------------
  ------------------
 3176|   221k|	if (nbchar >= HTML_PARSER_BIG_BUFFER_SIZE) {
  ------------------
  |  |   38|   221k|#define HTML_PARSER_BIG_BUFFER_SIZE 1000
  ------------------
  |  Branch (3176:6): [True: 22, False: 221k]
  ------------------
 3177|     22|            buf[nbchar] = 0;
 3178|       |
 3179|       |	    /*
 3180|       |	     * Ok the segment is to be consumed as chars.
 3181|       |	     */
 3182|     22|	    if ((ctxt->sax != NULL) && (!ctxt->disableSAX)) {
  ------------------
  |  Branch (3182:10): [True: 22, False: 0]
  |  Branch (3182:33): [True: 22, False: 0]
  ------------------
 3183|     22|		if (areBlanks(ctxt, buf, nbchar)) {
  ------------------
  |  Branch (3183:7): [True: 0, False: 22]
  ------------------
 3184|      0|		    if (ctxt->keepBlanks) {
  ------------------
  |  Branch (3184:11): [True: 0, False: 0]
  ------------------
 3185|      0|			if (ctxt->sax->characters != NULL)
  ------------------
  |  Branch (3185:8): [True: 0, False: 0]
  ------------------
 3186|      0|			    ctxt->sax->characters(ctxt->userData, buf, nbchar);
 3187|      0|		    } else {
 3188|      0|			if (ctxt->sax->ignorableWhitespace != NULL)
  ------------------
  |  Branch (3188:8): [True: 0, False: 0]
  ------------------
 3189|      0|			    ctxt->sax->ignorableWhitespace(ctxt->userData,
 3190|      0|			                                   buf, nbchar);
 3191|      0|		    }
 3192|     22|		} else {
 3193|     22|		    htmlCheckParagraph(ctxt);
 3194|     22|		    if (ctxt->sax->characters != NULL)
  ------------------
  |  Branch (3194:11): [True: 22, False: 0]
  ------------------
 3195|     22|			ctxt->sax->characters(ctxt->userData, buf, nbchar);
 3196|     22|		}
 3197|     22|	    }
 3198|     22|	    nbchar = 0;
 3199|     22|            SHRINK;
  ------------------
  |  |  292|     22|#define SHRINK if ((ctxt->input->cur - ctxt->input->base > 2 * INPUT_CHUNK) && \
  |  |  ------------------
  |  |  |  |   97|     22|#define INPUT_CHUNK	250
  |  |  ------------------
  |  |  |  Branch (292:20): [True: 22, False: 0]
  |  |  ------------------
  |  |  293|     22|		   (ctxt->input->end - ctxt->input->cur < 2 * INPUT_CHUNK)) \
  |  |  ------------------
  |  |  |  |   97|     22|#define INPUT_CHUNK	250
  |  |  ------------------
  |  |  |  Branch (293:6): [True: 0, False: 22]
  |  |  ------------------
  |  |  294|     22|	xmlParserShrink(ctxt)
  ------------------
 3200|     22|	}
 3201|   221k|	cur = CUR_CHAR(l);
  ------------------
  |  |  323|   221k|#define CUR_CHAR(l) htmlCurrentChar(ctxt, &l)
  ------------------
 3202|   221k|    }
 3203|  10.8k|    if (ctxt->instate == XML_PARSER_EOF)
  ------------------
  |  Branch (3203:9): [True: 0, False: 10.8k]
  ------------------
 3204|      0|        return;
 3205|  10.8k|    if (nbchar != 0) {
  ------------------
  |  Branch (3205:9): [True: 10.8k, False: 2]
  ------------------
 3206|  10.8k|        buf[nbchar] = 0;
 3207|       |
 3208|       |	/*
 3209|       |	 * Ok the segment is to be consumed as chars.
 3210|       |	 */
 3211|  10.8k|	if ((ctxt->sax != NULL) && (!ctxt->disableSAX)) {
  ------------------
  |  Branch (3211:6): [True: 10.8k, False: 0]
  |  Branch (3211:29): [True: 10.8k, False: 49]
  ------------------
 3212|  10.8k|	    if (areBlanks(ctxt, buf, nbchar)) {
  ------------------
  |  Branch (3212:10): [True: 3.07k, False: 7.73k]
  ------------------
 3213|  3.07k|		if (ctxt->keepBlanks) {
  ------------------
  |  Branch (3213:7): [True: 3.07k, False: 0]
  ------------------
 3214|  3.07k|		    if (ctxt->sax->characters != NULL)
  ------------------
  |  Branch (3214:11): [True: 3.07k, False: 0]
  ------------------
 3215|  3.07k|			ctxt->sax->characters(ctxt->userData, buf, nbchar);
 3216|  3.07k|		} else {
 3217|      0|		    if (ctxt->sax->ignorableWhitespace != NULL)
  ------------------
  |  Branch (3217:11): [True: 0, False: 0]
  ------------------
 3218|      0|			ctxt->sax->ignorableWhitespace(ctxt->userData,
 3219|      0|			                               buf, nbchar);
 3220|      0|		}
 3221|  7.73k|	    } else {
 3222|  7.73k|		htmlCheckParagraph(ctxt);
 3223|  7.73k|		if (ctxt->sax->characters != NULL)
  ------------------
  |  Branch (3223:7): [True: 7.73k, False: 0]
  ------------------
 3224|  7.73k|		    ctxt->sax->characters(ctxt->userData, buf, nbchar);
 3225|  7.73k|	    }
 3226|  10.8k|	}
 3227|  10.8k|    }
 3228|  10.8k|}
HTMLparser.c:areBlanks:
 2367|  10.8k|static int areBlanks(htmlParserCtxtPtr ctxt, const xmlChar *str, int len) {
 2368|  10.8k|    unsigned int i;
 2369|  10.8k|    int j;
 2370|  10.8k|    xmlNodePtr lastChild;
 2371|  10.8k|    xmlDtdPtr dtd;
 2372|       |
 2373|  41.1k|    for (j = 0;j < len;j++)
  ------------------
  |  Branch (2373:16): [True: 35.2k, False: 5.82k]
  ------------------
 2374|  35.2k|        if (!(IS_BLANK_CH(str[j]))) return(0);
  ------------------
  |  |  151|  35.2k|#define IS_BLANK_CH(c)  xmlIsBlank_ch(c)
  |  |  ------------------
  |  |  |  |   88|  35.2k|#define xmlIsBlank_ch(c)	(((c) == 0x20) || \
  |  |  |  |  ------------------
  |  |  |  |  |  Branch (88:27): [True: 21.2k, False: 14.0k]
  |  |  |  |  ------------------
  |  |  |  |   89|  35.2k|				 ((0x9 <= (c)) && ((c) <= 0xa)) || \
  |  |  |  |  ------------------
  |  |  |  |  |  Branch (89:7): [True: 14.0k, False: 0]
  |  |  |  |  |  Branch (89:23): [True: 7.26k, False: 6.76k]
  |  |  |  |  ------------------
  |  |  |  |   90|  35.2k|				 ((c) == 0xd))
  |  |  |  |  ------------------
  |  |  |  |  |  Branch (90:6): [True: 1.74k, False: 5.01k]
  |  |  |  |  ------------------
  |  |  ------------------
  ------------------
 2375|       |
 2376|  5.82k|    if (CUR == 0) return(1);
  ------------------
  |  |  304|  5.82k|#define CUR (*ctxt->input->cur)
  ------------------
  |  Branch (2376:9): [True: 117, False: 5.70k]
  ------------------
 2377|  5.70k|    if (CUR != '<') return(0);
  ------------------
  |  |  304|  5.70k|#define CUR (*ctxt->input->cur)
  ------------------
  |  Branch (2377:9): [True: 166, False: 5.53k]
  ------------------
 2378|  5.53k|    if (ctxt->name == NULL)
  ------------------
  |  Branch (2378:9): [True: 0, False: 5.53k]
  ------------------
 2379|      0|	return(1);
 2380|  5.53k|    if (xmlStrEqual(ctxt->name, BAD_CAST"html"))
  ------------------
  |  |   35|  5.53k|#define BAD_CAST (xmlChar *)
  ------------------
  |  Branch (2380:9): [True: 268, False: 5.26k]
  ------------------
 2381|    268|	return(1);
 2382|  5.26k|    if (xmlStrEqual(ctxt->name, BAD_CAST"head"))
  ------------------
  |  |   35|  5.26k|#define BAD_CAST (xmlChar *)
  ------------------
  |  Branch (2382:9): [True: 180, False: 5.08k]
  ------------------
 2383|    180|	return(1);
 2384|       |
 2385|       |    /* Only strip CDATA children of the body tag for strict HTML DTDs */
 2386|  5.08k|    if (xmlStrEqual(ctxt->name, BAD_CAST "body") && ctxt->myDoc != NULL) {
  ------------------
  |  |   35|  5.08k|#define BAD_CAST (xmlChar *)
  ------------------
  |  Branch (2386:9): [True: 413, False: 4.67k]
  |  Branch (2386:53): [True: 413, False: 0]
  ------------------
 2387|    413|        dtd = xmlGetIntSubset(ctxt->myDoc);
 2388|    413|        if (dtd != NULL && dtd->ExternalID != NULL) {
  ------------------
  |  Branch (2388:13): [True: 77, False: 336]
  |  Branch (2388:28): [True: 60, False: 17]
  ------------------
 2389|     60|            if (!xmlStrcasecmp(dtd->ExternalID, BAD_CAST "-//W3C//DTD HTML 4.01//EN") ||
  ------------------
  |  |   35|     60|#define BAD_CAST (xmlChar *)
  ------------------
  |  Branch (2389:17): [True: 2, False: 58]
  ------------------
 2390|     60|                    !xmlStrcasecmp(dtd->ExternalID, BAD_CAST "-//W3C//DTD HTML 4//EN"))
  ------------------
  |  |   35|     58|#define BAD_CAST (xmlChar *)
  ------------------
  |  Branch (2390:21): [True: 0, False: 58]
  ------------------
 2391|      2|                return(1);
 2392|     60|        }
 2393|    413|    }
 2394|       |
 2395|  5.08k|    if (ctxt->node == NULL) return(0);
  ------------------
  |  Branch (2395:9): [True: 0, False: 5.08k]
  ------------------
 2396|  5.08k|    lastChild = xmlGetLastChild(ctxt->node);
 2397|  5.37k|    while ((lastChild) && (lastChild->type == XML_COMMENT_NODE))
  ------------------
  |  Branch (2397:12): [True: 3.77k, False: 1.59k]
  |  Branch (2397:27): [True: 285, False: 3.49k]
  ------------------
 2398|    285|	lastChild = lastChild->prev;
 2399|  5.08k|    if (lastChild == NULL) {
  ------------------
  |  Branch (2399:9): [True: 1.59k, False: 3.49k]
  ------------------
 2400|  1.59k|        if ((ctxt->node->type != XML_ELEMENT_NODE) &&
  ------------------
  |  Branch (2400:13): [True: 0, False: 1.59k]
  ------------------
 2401|  1.59k|            (ctxt->node->content != NULL)) return(0);
  ------------------
  |  Branch (2401:13): [True: 0, False: 0]
  ------------------
 2402|       |	/* keep ws in constructs like ...<b> </b>...
 2403|       |	   for all tags "b" allowing PCDATA */
 2404|  68.5k|	for ( i = 0; i < sizeof(allowPCData)/sizeof(allowPCData[0]); i++ ) {
  ------------------
  |  Branch (2404:15): [True: 67.7k, False: 816]
  ------------------
 2405|  67.7k|	    if ( xmlStrEqual(ctxt->name, BAD_CAST allowPCData[i]) ) {
  ------------------
  |  |   35|  67.7k|#define BAD_CAST (xmlChar *)
  ------------------
  |  Branch (2405:11): [True: 777, False: 67.0k]
  ------------------
 2406|    777|		return(0);
 2407|    777|	    }
 2408|  67.7k|	}
 2409|  3.49k|    } else if (xmlNodeIsText(lastChild)) {
  ------------------
  |  Branch (2409:16): [True: 432, False: 3.06k]
  ------------------
 2410|    432|        return(0);
 2411|  3.06k|    } else {
 2412|       |	/* keep ws in constructs like <p><b>xy</b> <i>z</i><p>
 2413|       |	   for all tags "p" allowing PCDATA */
 2414|   134k|	for ( i = 0; i < sizeof(allowPCData)/sizeof(allowPCData[0]); i++ ) {
  ------------------
  |  Branch (2414:15): [True: 132k, False: 1.69k]
  ------------------
 2415|   132k|	    if ( xmlStrEqual(lastChild->name, BAD_CAST allowPCData[i]) ) {
  ------------------
  |  |   35|   132k|#define BAD_CAST (xmlChar *)
  ------------------
  |  Branch (2415:11): [True: 1.36k, False: 131k]
  ------------------
 2416|  1.36k|		return(0);
 2417|  1.36k|	    }
 2418|   132k|	}
 2419|  3.06k|    }
 2420|  2.51k|    return(1);
 2421|  5.08k|}
HTMLparser.c:htmlAutoCloseOnEnd:
 1508|    352|{
 1509|    352|    int i;
 1510|       |
 1511|    352|    if (ctxt->nameNr == 0)
  ------------------
  |  Branch (1511:9): [True: 304, False: 48]
  ------------------
 1512|    304|        return;
 1513|    212|    for (i = (ctxt->nameNr - 1); i >= 0; i--) {
  ------------------
  |  Branch (1513:34): [True: 164, False: 48]
  ------------------
 1514|    164|        if ((ctxt->sax != NULL) && (ctxt->sax->endElement != NULL))
  ------------------
  |  Branch (1514:13): [True: 164, False: 0]
  |  Branch (1514:36): [True: 164, False: 0]
  ------------------
 1515|    164|            ctxt->sax->endElement(ctxt->userData, ctxt->name);
 1516|    164|	htmlnamePop(ctxt);
 1517|    164|    }
 1518|     48|}
HTMLparser.c:htmlParseContentInternal:
 4624|     91|htmlParseContentInternal(htmlParserCtxtPtr ctxt) {
 4625|     91|    xmlChar *currentNode;
 4626|     91|    int depth;
 4627|     91|    const xmlChar *name;
 4628|       |
 4629|     91|    depth = ctxt->nameNr;
 4630|     91|    if (depth <= 0) {
  ------------------
  |  Branch (4630:9): [True: 91, False: 0]
  ------------------
 4631|     91|        currentNode = NULL;
 4632|     91|    } else {
 4633|      0|        currentNode = xmlStrdup(ctxt->name);
 4634|      0|        if (currentNode == NULL) {
  ------------------
  |  Branch (4634:13): [True: 0, False: 0]
  ------------------
 4635|      0|            htmlErrMemory(ctxt, NULL);
 4636|      0|            return;
 4637|      0|        }
 4638|      0|    }
 4639|  17.1k|    while (1) {
  ------------------
  |  Branch (4639:12): [Folded - Ignored]
  ------------------
 4640|  17.1k|        GROW;
  ------------------
  |  |  296|  17.1k|#define GROW if ((ctxt->progressive == 0) &&				\
  |  |  ------------------
  |  |  |  Branch (296:18): [True: 17.1k, False: 0]
  |  |  ------------------
  |  |  297|  17.1k|		 (ctxt->input->end - ctxt->input->cur < INPUT_CHUNK))	\
  |  |  ------------------
  |  |  |  |   97|  17.1k|#define INPUT_CHUNK	250
  |  |  ------------------
  |  |  |  Branch (297:4): [True: 1.27k, False: 15.8k]
  |  |  ------------------
  |  |  298|  17.1k|	xmlParserGrow(ctxt)
  ------------------
 4641|       |
 4642|  17.1k|        if (ctxt->instate == XML_PARSER_EOF)
  ------------------
  |  Branch (4642:13): [True: 3, False: 17.1k]
  ------------------
 4643|      3|            break;
 4644|       |
 4645|       |	/*
 4646|       |	 * Our tag or one of it's parent or children is ending.
 4647|       |	 */
 4648|  17.1k|        if ((CUR == '<') && (NXT(1) == '/')) {
  ------------------
  |  |  304|  17.1k|#define CUR (*ctxt->input->cur)
  ------------------
                      if ((CUR == '<') && (NXT(1) == '/')) {
  ------------------
  |  |  285|  11.1k|#define NXT(val) ctxt->input->cur[(val)]
  ------------------
  |  Branch (4648:13): [True: 11.1k, False: 5.97k]
  |  Branch (4648:29): [True: 4.25k, False: 6.90k]
  ------------------
 4649|  4.25k|	    if (htmlParseEndTag(ctxt) &&
  ------------------
  |  Branch (4649:10): [True: 4.15k, False: 102]
  ------------------
 4650|  4.25k|		((currentNode != NULL) || (ctxt->nameNr == 0))) {
  ------------------
  |  Branch (4650:4): [True: 4.15k, False: 1]
  |  Branch (4650:29): [True: 1, False: 0]
  ------------------
 4651|  4.15k|		if (currentNode != NULL)
  ------------------
  |  Branch (4651:7): [True: 4.15k, False: 1]
  ------------------
 4652|  4.15k|		    xmlFree(currentNode);
 4653|       |
 4654|  4.15k|	        depth = ctxt->nameNr;
 4655|  4.15k|                if (depth <= 0) {
  ------------------
  |  Branch (4655:21): [True: 60, False: 4.09k]
  ------------------
 4656|     60|                    currentNode = NULL;
 4657|  4.09k|                } else {
 4658|  4.09k|                    currentNode = xmlStrdup(ctxt->name);
 4659|  4.09k|                    if (currentNode == NULL) {
  ------------------
  |  Branch (4659:25): [True: 0, False: 4.09k]
  ------------------
 4660|      0|                        htmlErrMemory(ctxt, NULL);
 4661|      0|                        break;
 4662|      0|                    }
 4663|  4.09k|                }
 4664|  4.15k|	    }
 4665|  4.25k|	    continue; /* while */
 4666|  4.25k|        }
 4667|       |
 4668|  12.8k|	else if ((CUR == '<') &&
  ------------------
  |  |  304|  12.8k|#define CUR (*ctxt->input->cur)
  ------------------
  |  Branch (4668:11): [True: 6.90k, False: 5.97k]
  ------------------
 4669|  12.8k|	         ((IS_ASCII_LETTER(NXT(1))) ||
  ------------------
  |  |  258|  6.90k|#define IS_ASCII_LETTER(c)	(((0x41 <= (c)) && ((c) <= 0x5a)) || \
  |  |  ------------------
  |  |  |  Branch (258:30): [True: 6.64k, False: 252]
  |  |  |  Branch (258:47): [True: 3.23k, False: 3.41k]
  |  |  ------------------
  |  |  259|  6.90k|				 ((0x61 <= (c)) && ((c) <= 0x7a)))
  |  |  ------------------
  |  |  |  Branch (259:7): [True: 3.40k, False: 253]
  |  |  |  Branch (259:24): [True: 3.40k, False: 2]
  |  |  ------------------
  ------------------
 4670|  6.90k|		  (NXT(1) == '_') || (NXT(1) == ':'))) {
  ------------------
  |  |  285|    255|#define NXT(val) ctxt->input->cur[(val)]
  ------------------
              		  (NXT(1) == '_') || (NXT(1) == ':'))) {
  ------------------
  |  |  285|    255|#define NXT(val) ctxt->input->cur[(val)]
  ------------------
  |  Branch (4670:5): [True: 0, False: 255]
  |  Branch (4670:24): [True: 0, False: 255]
  ------------------
 4671|  6.64k|	    name = htmlParseHTMLName_nonInvasive(ctxt);
 4672|  6.64k|	    if (name == NULL) {
  ------------------
  |  Branch (4672:10): [True: 0, False: 6.64k]
  ------------------
 4673|      0|	        htmlParseErr(ctxt, XML_ERR_NAME_REQUIRED,
 4674|      0|			 "htmlParseStartTag: invalid element name\n",
 4675|      0|			 NULL, NULL);
 4676|       |	        /* Dump the bogus tag like browsers do */
 4677|      0|	        while ((CUR == 0) && (CUR != '>'))
  ------------------
  |  |  304|      0|#define CUR (*ctxt->input->cur)
  ------------------
              	        while ((CUR == 0) && (CUR != '>'))
  ------------------
  |  |  304|      0|#define CUR (*ctxt->input->cur)
  ------------------
  |  Branch (4677:17): [True: 0, False: 0]
  |  Branch (4677:31): [True: 0, False: 0]
  ------------------
 4678|      0|	            NEXT;
  ------------------
  |  |  305|      0|#define NEXT xmlNextChar(ctxt)
  ------------------
 4679|       |
 4680|      0|	        htmlParserFinishElementParsing(ctxt);
 4681|      0|	        if (currentNode != NULL)
  ------------------
  |  Branch (4681:14): [True: 0, False: 0]
  ------------------
 4682|      0|	            xmlFree(currentNode);
 4683|       |
 4684|      0|	        currentNode = xmlStrdup(ctxt->name);
 4685|      0|                if (currentNode == NULL) {
  ------------------
  |  Branch (4685:21): [True: 0, False: 0]
  ------------------
 4686|      0|                    htmlErrMemory(ctxt, NULL);
 4687|      0|                    break;
 4688|      0|                }
 4689|      0|	        depth = ctxt->nameNr;
 4690|      0|	        continue;
 4691|      0|	    }
 4692|       |
 4693|  6.64k|	    if (ctxt->name != NULL) {
  ------------------
  |  Branch (4693:10): [True: 6.56k, False: 76]
  ------------------
 4694|  6.56k|	        if (htmlCheckAutoClose(name, ctxt->name) == 1) {
  ------------------
  |  Branch (4694:14): [True: 109, False: 6.46k]
  ------------------
 4695|    109|	            htmlAutoClose(ctxt, name);
 4696|    109|	            continue;
 4697|    109|	        }
 4698|  6.56k|	    }
 4699|  6.64k|	}
 4700|       |
 4701|       |	/*
 4702|       |	 * Has this node been popped out during parsing of
 4703|       |	 * the next element
 4704|       |	 */
 4705|  12.7k|        if ((ctxt->nameNr > 0) && (depth >= ctxt->nameNr) &&
  ------------------
  |  Branch (4705:13): [True: 12.5k, False: 207]
  |  Branch (4705:35): [True: 12.5k, False: 16]
  ------------------
 4706|  12.7k|	    (!xmlStrEqual(currentNode, ctxt->name)))
  ------------------
  |  Branch (4706:6): [True: 109, False: 12.4k]
  ------------------
 4707|    109|	     {
 4708|    109|	    htmlParserFinishElementParsing(ctxt);
 4709|    109|	    if (currentNode != NULL) xmlFree(currentNode);
  ------------------
  |  Branch (4709:10): [True: 109, False: 0]
  ------------------
 4710|       |
 4711|    109|	    currentNode = xmlStrdup(ctxt->name);
 4712|    109|            if (currentNode == NULL) {
  ------------------
  |  Branch (4712:17): [True: 0, False: 109]
  ------------------
 4713|      0|                htmlErrMemory(ctxt, NULL);
 4714|      0|                break;
 4715|      0|            }
 4716|    109|	    depth = ctxt->nameNr;
 4717|    109|	    continue;
 4718|    109|	}
 4719|       |
 4720|  12.6k|	if ((CUR != 0) && ((xmlStrEqual(currentNode, BAD_CAST"script")) ||
  ------------------
  |  |  304|  12.6k|#define CUR (*ctxt->input->cur)
  ------------------
              	if ((CUR != 0) && ((xmlStrEqual(currentNode, BAD_CAST"script")) ||
  ------------------
  |  |   35|  12.5k|#define BAD_CAST (xmlChar *)
  ------------------
  |  Branch (4720:6): [True: 12.5k, False: 84]
  |  Branch (4720:21): [True: 29, False: 12.5k]
  ------------------
 4721|  12.5k|	    (xmlStrEqual(currentNode, BAD_CAST"style")))) {
  ------------------
  |  |   35|  12.5k|#define BAD_CAST (xmlChar *)
  ------------------
  |  Branch (4721:6): [True: 4, False: 12.5k]
  ------------------
 4722|       |	    /*
 4723|       |	     * Handle SCRIPT/STYLE separately
 4724|       |	     */
 4725|     33|	    htmlParseScript(ctxt);
 4726|     33|	}
 4727|       |
 4728|  12.6k|        else if ((CUR == '<') && (NXT(1) == '!')) {
  ------------------
  |  |  304|  12.6k|#define CUR (*ctxt->input->cur)
  ------------------
                      else if ((CUR == '<') && (NXT(1) == '!')) {
  ------------------
  |  |  285|  6.68k|#define NXT(val) ctxt->input->cur[(val)]
  ------------------
  |  Branch (4728:18): [True: 6.68k, False: 5.94k]
  |  Branch (4728:34): [True: 252, False: 6.43k]
  ------------------
 4729|       |            /*
 4730|       |             * Sometimes DOCTYPE arrives in the middle of the document
 4731|       |             */
 4732|    252|            if ((UPP(2) == 'D') && (UPP(3) == 'O') &&
  ------------------
  |  |  287|    252|#define UPP(val) (toupper(ctxt->input->cur[(val)]))
  ------------------
                          if ((UPP(2) == 'D') && (UPP(3) == 'O') &&
  ------------------
  |  |  287|      5|#define UPP(val) (toupper(ctxt->input->cur[(val)]))
  ------------------
  |  Branch (4732:17): [True: 5, False: 247]
  |  Branch (4732:36): [True: 5, False: 0]
  ------------------
 4733|    252|                (UPP(4) == 'C') && (UPP(5) == 'T') &&
  ------------------
  |  |  287|      5|#define UPP(val) (toupper(ctxt->input->cur[(val)]))
  ------------------
                              (UPP(4) == 'C') && (UPP(5) == 'T') &&
  ------------------
  |  |  287|      5|#define UPP(val) (toupper(ctxt->input->cur[(val)]))
  ------------------
  |  Branch (4733:17): [True: 5, False: 0]
  |  Branch (4733:36): [True: 5, False: 0]
  ------------------
 4734|    252|                (UPP(6) == 'Y') && (UPP(7) == 'P') &&
  ------------------
  |  |  287|      5|#define UPP(val) (toupper(ctxt->input->cur[(val)]))
  ------------------
                              (UPP(6) == 'Y') && (UPP(7) == 'P') &&
  ------------------
  |  |  287|      5|#define UPP(val) (toupper(ctxt->input->cur[(val)]))
  ------------------
  |  Branch (4734:17): [True: 5, False: 0]
  |  Branch (4734:36): [True: 5, False: 0]
  ------------------
 4735|    252|                (UPP(8) == 'E')) {
  ------------------
  |  |  287|      5|#define UPP(val) (toupper(ctxt->input->cur[(val)]))
  ------------------
  |  Branch (4735:17): [True: 5, False: 0]
  ------------------
 4736|      5|                htmlParseErr(ctxt, XML_HTML_STRUCURE_ERROR,
 4737|      5|                             "Misplaced DOCTYPE declaration\n",
 4738|      5|                             BAD_CAST "DOCTYPE" , NULL);
  ------------------
  |  |   35|      5|#define BAD_CAST (xmlChar *)
  ------------------
 4739|      5|                htmlParseDocTypeDecl(ctxt);
 4740|      5|            }
 4741|       |            /*
 4742|       |             * First case :  a comment
 4743|       |             */
 4744|    247|            else if ((NXT(2) == '-') && (NXT(3) == '-')) {
  ------------------
  |  |  285|    247|#define NXT(val) ctxt->input->cur[(val)]
  ------------------
                          else if ((NXT(2) == '-') && (NXT(3) == '-')) {
  ------------------
  |  |  285|    243|#define NXT(val) ctxt->input->cur[(val)]
  ------------------
  |  Branch (4744:22): [True: 243, False: 4]
  |  Branch (4744:41): [True: 243, False: 0]
  ------------------
 4745|    243|                htmlParseComment(ctxt);
 4746|    243|            }
 4747|      4|            else {
 4748|      4|                htmlSkipBogusComment(ctxt);
 4749|      4|            }
 4750|    252|        }
 4751|       |
 4752|       |        /*
 4753|       |         * Second case : a Processing Instruction.
 4754|       |         */
 4755|  12.3k|        else if ((CUR == '<') && (NXT(1) == '?')) {
  ------------------
  |  |  304|  12.3k|#define CUR (*ctxt->input->cur)
  ------------------
                      else if ((CUR == '<') && (NXT(1) == '?')) {
  ------------------
  |  |  285|  6.43k|#define NXT(val) ctxt->input->cur[(val)]
  ------------------
  |  Branch (4755:18): [True: 6.43k, False: 5.94k]
  |  Branch (4755:34): [True: 0, False: 6.43k]
  ------------------
 4756|      0|            htmlParsePI(ctxt);
 4757|      0|        }
 4758|       |
 4759|       |        /*
 4760|       |         * Third case :  a sub-element.
 4761|       |         */
 4762|  12.3k|        else if ((CUR == '<') && IS_ASCII_LETTER(NXT(1))) {
  ------------------
  |  |  304|  12.3k|#define CUR (*ctxt->input->cur)
  ------------------
                      else if ((CUR == '<') && IS_ASCII_LETTER(NXT(1))) {
  ------------------
  |  |  258|  6.43k|#define IS_ASCII_LETTER(c)	(((0x41 <= (c)) && ((c) <= 0x5a)) || \
  |  |  ------------------
  |  |  |  Branch (258:30): [True: 6.43k, False: 0]
  |  |  |  Branch (258:47): [True: 3.18k, False: 3.24k]
  |  |  ------------------
  |  |  259|  6.43k|				 ((0x61 <= (c)) && ((c) <= 0x7a)))
  |  |  ------------------
  |  |  |  Branch (259:7): [True: 3.24k, False: 1]
  |  |  |  Branch (259:24): [True: 3.23k, False: 2]
  |  |  ------------------
  ------------------
  |  Branch (4762:18): [True: 6.43k, False: 5.94k]
  ------------------
 4763|  6.42k|            htmlParseElementInternal(ctxt);
 4764|  6.42k|            if (currentNode != NULL) xmlFree(currentNode);
  ------------------
  |  Branch (4764:17): [True: 6.34k, False: 78]
  ------------------
 4765|       |
 4766|  6.42k|            currentNode = xmlStrdup(ctxt->name);
 4767|  6.42k|            if (currentNode == NULL) {
  ------------------
  |  Branch (4767:17): [True: 4, False: 6.42k]
  ------------------
 4768|      4|                htmlErrMemory(ctxt, NULL);
 4769|      4|                break;
 4770|      4|            }
 4771|  6.42k|            depth = ctxt->nameNr;
 4772|  6.42k|        }
 4773|  5.94k|        else if (CUR == '<') {
  ------------------
  |  |  304|  5.94k|#define CUR (*ctxt->input->cur)
  ------------------
  |  Branch (4773:18): [True: 3, False: 5.94k]
  ------------------
 4774|      3|            if ((ctxt->sax != NULL) && (!ctxt->disableSAX) &&
  ------------------
  |  Branch (4774:17): [True: 3, False: 0]
  |  Branch (4774:40): [True: 3, False: 0]
  ------------------
 4775|      3|                (ctxt->sax->characters != NULL))
  ------------------
  |  Branch (4775:17): [True: 3, False: 0]
  ------------------
 4776|      3|                ctxt->sax->characters(ctxt->userData, BAD_CAST "<", 1);
  ------------------
  |  |   35|      3|#define BAD_CAST (xmlChar *)
  ------------------
 4777|      3|            NEXT;
  ------------------
  |  |  305|      3|#define NEXT xmlNextChar(ctxt)
  ------------------
 4778|      3|        }
 4779|       |
 4780|       |        /*
 4781|       |         * Fourth case : a reference. If if has not been resolved,
 4782|       |         *    parsing returns it's Name, create the node
 4783|       |         */
 4784|  5.94k|        else if (CUR == '&') {
  ------------------
  |  |  304|  5.94k|#define CUR (*ctxt->input->cur)
  ------------------
  |  Branch (4784:18): [True: 515, False: 5.42k]
  ------------------
 4785|    515|            htmlParseReference(ctxt);
 4786|    515|        }
 4787|       |
 4788|       |        /*
 4789|       |         * Fifth case : end of the resource
 4790|       |         */
 4791|  5.42k|        else if (CUR == 0) {
  ------------------
  |  |  304|  5.42k|#define CUR (*ctxt->input->cur)
  ------------------
  |  Branch (4791:18): [True: 84, False: 5.34k]
  ------------------
 4792|     84|            htmlAutoCloseOnEnd(ctxt);
 4793|     84|            break;
 4794|     84|        }
 4795|       |
 4796|       |        /*
 4797|       |         * Last case, text. Note that References are handled directly.
 4798|       |         */
 4799|  5.34k|        else {
 4800|  5.34k|            htmlParseCharData(ctxt);
 4801|  5.34k|        }
 4802|       |
 4803|  12.5k|        SHRINK;
  ------------------
  |  |  292|  12.5k|#define SHRINK if ((ctxt->input->cur - ctxt->input->base > 2 * INPUT_CHUNK) && \
  |  |  ------------------
  |  |  |  |   97|  12.5k|#define INPUT_CHUNK	250
  |  |  ------------------
  |  |  |  Branch (292:20): [True: 9.84k, False: 2.72k]
  |  |  ------------------
  |  |  293|  12.5k|		   (ctxt->input->end - ctxt->input->cur < 2 * INPUT_CHUNK)) \
  |  |  ------------------
  |  |  |  |   97|  9.84k|#define INPUT_CHUNK	250
  |  |  ------------------
  |  |  |  Branch (293:6): [True: 111, False: 9.73k]
  |  |  ------------------
  |  |  294|  12.5k|	xmlParserShrink(ctxt)
  ------------------
 4804|  12.5k|        GROW;
  ------------------
  |  |  296|  12.5k|#define GROW if ((ctxt->progressive == 0) &&				\
  |  |  ------------------
  |  |  |  Branch (296:18): [True: 12.5k, False: 0]
  |  |  ------------------
  |  |  297|  12.5k|		 (ctxt->input->end - ctxt->input->cur < INPUT_CHUNK))	\
  |  |  ------------------
  |  |  |  |   97|  12.5k|#define INPUT_CHUNK	250
  |  |  ------------------
  |  |  |  Branch (297:4): [True: 848, False: 11.7k]
  |  |  ------------------
  |  |  298|  12.5k|	xmlParserGrow(ctxt)
  ------------------
 4805|  12.5k|    }
 4806|     91|    if (currentNode != NULL) xmlFree(currentNode);
  ------------------
  |  Branch (4806:9): [True: 15, False: 76]
  ------------------
 4807|     91|}
HTMLparser.c:htmlParserFinishElementParsing:
 4502|    113|htmlParserFinishElementParsing(htmlParserCtxtPtr ctxt) {
 4503|       |    /*
 4504|       |     * Capture end position and add node
 4505|       |     */
 4506|    113|    if ( ctxt->node != NULL && ctxt->record_info ) {
  ------------------
  |  Branch (4506:10): [True: 113, False: 0]
  |  Branch (4506:32): [True: 0, False: 113]
  ------------------
 4507|      0|       ctxt->nodeInfo->end_pos = ctxt->input->consumed +
 4508|      0|                                (CUR_PTR - ctxt->input->base);
  ------------------
  |  |  289|      0|#define CUR_PTR ctxt->input->cur
  ------------------
 4509|      0|       ctxt->nodeInfo->end_line = ctxt->input->line;
 4510|      0|       ctxt->nodeInfo->node = ctxt->node;
 4511|      0|       xmlParserAddNodeInfo(ctxt, ctxt->nodeInfo);
 4512|      0|       htmlNodeInfoPop(ctxt);
 4513|      0|    }
 4514|    113|    if (CUR == 0) {
  ------------------
  |  |  304|    113|#define CUR (*ctxt->input->cur)
  ------------------
  |  Branch (4514:9): [True: 4, False: 109]
  ------------------
 4515|      4|       htmlAutoCloseOnEnd(ctxt);
 4516|      4|    }
 4517|    113|}
HTMLparser.c:htmlParseElementInternal:
 4531|  6.42k|htmlParseElementInternal(htmlParserCtxtPtr ctxt) {
 4532|  6.42k|    const xmlChar *name;
 4533|  6.42k|    const htmlElemDesc * info;
 4534|  6.42k|    htmlParserNodeInfo node_info = { NULL, 0, 0, 0, 0 };
 4535|  6.42k|    int failed;
 4536|       |
 4537|  6.42k|    if ((ctxt == NULL) || (ctxt->input == NULL)) {
  ------------------
  |  Branch (4537:9): [True: 0, False: 6.42k]
  |  Branch (4537:27): [True: 0, False: 6.42k]
  ------------------
 4538|      0|	htmlParseErr(ctxt, XML_ERR_INTERNAL_ERROR,
 4539|      0|		     "htmlParseElementInternal: context error\n", NULL, NULL);
 4540|      0|	return;
 4541|      0|    }
 4542|       |
 4543|  6.42k|    if (ctxt->instate == XML_PARSER_EOF)
  ------------------
  |  Branch (4543:9): [True: 0, False: 6.42k]
  ------------------
 4544|      0|        return;
 4545|       |
 4546|       |    /* Capture start position */
 4547|  6.42k|    if (ctxt->record_info) {
  ------------------
  |  Branch (4547:9): [True: 0, False: 6.42k]
  ------------------
 4548|      0|        node_info.begin_pos = ctxt->input->consumed +
 4549|      0|                          (CUR_PTR - ctxt->input->base);
  ------------------
  |  |  289|      0|#define CUR_PTR ctxt->input->cur
  ------------------
 4550|      0|	node_info.begin_line = ctxt->input->line;
 4551|      0|    }
 4552|       |
 4553|  6.42k|    failed = htmlParseStartTag(ctxt);
 4554|  6.42k|    name = ctxt->name;
 4555|  6.42k|    if ((failed == -1) || (name == NULL)) {
  ------------------
  |  Branch (4555:9): [True: 0, False: 6.42k]
  |  Branch (4555:27): [True: 0, False: 6.42k]
  ------------------
 4556|      0|	if (CUR == '>')
  ------------------
  |  |  304|      0|#define CUR (*ctxt->input->cur)
  ------------------
  |  Branch (4556:6): [True: 0, False: 0]
  ------------------
 4557|      0|	    NEXT;
  ------------------
  |  |  305|      0|#define NEXT xmlNextChar(ctxt)
  ------------------
 4558|      0|        return;
 4559|      0|    }
 4560|       |
 4561|       |    /*
 4562|       |     * Lookup the info for that element.
 4563|       |     */
 4564|  6.42k|    info = htmlTagLookup(name);
 4565|  6.42k|    if (info == NULL) {
  ------------------
  |  Branch (4565:9): [True: 16, False: 6.41k]
  ------------------
 4566|     16|	htmlParseErr(ctxt, XML_HTML_UNKNOWN_TAG,
 4567|     16|	             "Tag %s invalid\n", name, NULL);
 4568|     16|    }
 4569|       |
 4570|       |    /*
 4571|       |     * Check for an Empty Element labeled the XML/SGML way
 4572|       |     */
 4573|  6.42k|    if ((CUR == '/') && (NXT(1) == '>')) {
  ------------------
  |  |  304|  6.42k|#define CUR (*ctxt->input->cur)
  ------------------
                  if ((CUR == '/') && (NXT(1) == '>')) {
  ------------------
  |  |  285|      9|#define NXT(val) ctxt->input->cur[(val)]
  ------------------
  |  Branch (4573:9): [True: 9, False: 6.41k]
  |  Branch (4573:25): [True: 9, False: 0]
  ------------------
 4574|      9|        SKIP(2);
  ------------------
  |  |  283|      9|#define SKIP(val) ctxt->input->cur += (val),ctxt->input->col+=(val)
  ------------------
 4575|      9|	if ((ctxt->sax != NULL) && (ctxt->sax->endElement != NULL))
  ------------------
  |  Branch (4575:6): [True: 9, False: 0]
  |  Branch (4575:29): [True: 9, False: 0]
  ------------------
 4576|      9|	    ctxt->sax->endElement(ctxt->userData, name);
 4577|      9|	htmlnamePop(ctxt);
 4578|      9|	return;
 4579|      9|    }
 4580|       |
 4581|  6.41k|    if (CUR == '>') {
  ------------------
  |  |  304|  6.41k|#define CUR (*ctxt->input->cur)
  ------------------
  |  Branch (4581:9): [True: 6.41k, False: 4]
  ------------------
 4582|  6.41k|        NEXT;
  ------------------
  |  |  305|  6.41k|#define NEXT xmlNextChar(ctxt)
  ------------------
 4583|  6.41k|    } else {
 4584|      4|	htmlParseErr(ctxt, XML_ERR_GT_REQUIRED,
 4585|      4|	             "Couldn't find end of Start Tag %s\n", name, NULL);
 4586|       |
 4587|       |	/*
 4588|       |	 * end of parsing of this node.
 4589|       |	 */
 4590|      4|	if (xmlStrEqual(name, ctxt->name)) {
  ------------------
  |  Branch (4590:6): [True: 4, False: 0]
  ------------------
 4591|      4|	    nodePop(ctxt);
 4592|      4|	    htmlnamePop(ctxt);
 4593|      4|	}
 4594|       |
 4595|      4|        if (ctxt->record_info)
  ------------------
  |  Branch (4595:13): [True: 0, False: 4]
  ------------------
 4596|      0|            htmlNodeInfoPush(ctxt, &node_info);
 4597|      4|        htmlParserFinishElementParsing(ctxt);
 4598|      4|	return;
 4599|      4|    }
 4600|       |
 4601|       |    /*
 4602|       |     * Check for an Empty Element from DTD definition
 4603|       |     */
 4604|  6.41k|    if ((info != NULL) && (info->empty)) {
  ------------------
  |  Branch (4604:9): [True: 6.40k, False: 13]
  |  Branch (4604:27): [True: 1.97k, False: 4.42k]
  ------------------
 4605|  1.97k|	if ((ctxt->sax != NULL) && (ctxt->sax->endElement != NULL))
  ------------------
  |  Branch (4605:6): [True: 1.97k, False: 0]
  |  Branch (4605:29): [True: 1.97k, False: 0]
  ------------------
 4606|  1.97k|	    ctxt->sax->endElement(ctxt->userData, name);
 4607|  1.97k|	htmlnamePop(ctxt);
 4608|  1.97k|	return;
 4609|  1.97k|    }
 4610|       |
 4611|  4.43k|    if (ctxt->record_info)
  ------------------
  |  Branch (4611:9): [True: 0, False: 4.43k]
  ------------------
 4612|      0|        htmlNodeInfoPush(ctxt, &node_info);
 4613|  4.43k|}
HTMLparser.c:htmlSkipBlankChars:
  563|  63.4k|htmlSkipBlankChars(xmlParserCtxtPtr ctxt) {
  564|  63.4k|    int res = 0;
  565|       |
  566|  63.4k|    while (IS_BLANK_CH(*(ctxt->input->cur))) {
  567|  50.3k|        if (*(ctxt->input->cur) == '\n') {
  ------------------
  |  Branch (567:13): [True: 2.55k, False: 47.7k]
  ------------------
  568|  2.55k|            ctxt->input->line++; ctxt->input->col = 1;
  569|  47.7k|        } else ctxt->input->col++;
  570|  50.3k|        ctxt->input->cur++;
  571|  50.3k|        if (*ctxt->input->cur == 0)
  ------------------
  |  Branch (571:13): [True: 0, False: 50.3k]
  ------------------
  572|      0|            xmlParserGrow(ctxt);
  573|  50.3k|	if (res < INT_MAX)
  ------------------
  |  Branch (573:6): [True: 50.3k, False: 0]
  ------------------
  574|  50.3k|	    res++;
  575|  50.3k|    }
  576|  63.4k|    return(res);
  577|  63.4k|}
HTMLparser.c:htmlParseComment:
 3431|    542|htmlParseComment(htmlParserCtxtPtr ctxt) {
 3432|    542|    xmlChar *buf = NULL;
 3433|    542|    int len;
 3434|    542|    int size = HTML_PARSER_BUFFER_SIZE;
  ------------------
  |  |   39|    542|#define HTML_PARSER_BUFFER_SIZE 100
  ------------------
 3435|    542|    int q, ql;
 3436|    542|    int r, rl;
 3437|    542|    int cur, l;
 3438|    542|    int next, nl;
 3439|    542|    int maxLength = (ctxt->options & XML_PARSE_HUGE) ?
  ------------------
  |  Branch (3439:21): [True: 0, False: 542]
  ------------------
 3440|      0|                    XML_MAX_HUGE_LENGTH :
  ------------------
  |  |   49|      0|#define XML_MAX_HUGE_LENGTH 1000000000
  ------------------
 3441|    542|                    XML_MAX_TEXT_LENGTH;
  ------------------
  |  |   42|    542|#define XML_MAX_TEXT_LENGTH 10000000
  ------------------
 3442|    542|    xmlParserInputState state;
 3443|       |
 3444|       |    /*
 3445|       |     * Check that there is a comment right here.
 3446|       |     */
 3447|    542|    if ((RAW != '<') || (NXT(1) != '!') ||
  ------------------
  |  |  307|    542|#define RAW (ctxt->token ? -1 : (*ctxt->input->cur))
  |  |  ------------------
  |  |  |  Branch (307:14): [True: 0, False: 542]
  |  |  ------------------
  ------------------
                  if ((RAW != '<') || (NXT(1) != '!') ||
  ------------------
  |  |  285|    542|#define NXT(val) ctxt->input->cur[(val)]
  ------------------
  |  Branch (3447:9): [True: 0, False: 542]
  |  Branch (3447:25): [True: 2, False: 540]
  ------------------
 3448|    542|        (NXT(2) != '-') || (NXT(3) != '-')) return;
  ------------------
  |  |  285|    540|#define NXT(val) ctxt->input->cur[(val)]
  ------------------
                      (NXT(2) != '-') || (NXT(3) != '-')) return;
  ------------------
  |  |  285|    540|#define NXT(val) ctxt->input->cur[(val)]
  ------------------
  |  Branch (3448:9): [True: 0, False: 540]
  |  Branch (3448:28): [True: 0, False: 540]
  ------------------
 3449|       |
 3450|    540|    state = ctxt->instate;
 3451|    540|    ctxt->instate = XML_PARSER_COMMENT;
 3452|    540|    SKIP(4);
  ------------------
  |  |  283|    540|#define SKIP(val) ctxt->input->cur += (val),ctxt->input->col+=(val)
  ------------------
 3453|    540|    buf = (xmlChar *) xmlMallocAtomic(size);
 3454|    540|    if (buf == NULL) {
  ------------------
  |  Branch (3454:9): [True: 0, False: 540]
  ------------------
 3455|      0|        htmlErrMemory(ctxt, "buffer allocation failed\n");
 3456|      0|	ctxt->instate = state;
 3457|      0|	return;
 3458|      0|    }
 3459|    540|    len = 0;
 3460|    540|    buf[len] = 0;
 3461|    540|    q = CUR_CHAR(ql);
  ------------------
  |  |  323|    540|#define CUR_CHAR(l) htmlCurrentChar(ctxt, &l)
  ------------------
 3462|    540|    if (q == 0)
  ------------------
  |  Branch (3462:9): [True: 0, False: 540]
  ------------------
 3463|      0|        goto unfinished;
 3464|    540|    if (q == '>') {
  ------------------
  |  Branch (3464:9): [True: 4, False: 536]
  ------------------
 3465|      4|        htmlParseErr(ctxt, XML_ERR_COMMENT_ABRUPTLY_ENDED, "Comment abruptly ended", NULL, NULL);
 3466|      4|        cur = '>';
 3467|      4|        goto finished;
 3468|      4|    }
 3469|    536|    NEXTL(ql);
  ------------------
  |  |  310|    536|#define NEXTL(l) do {							\
  |  |  311|    536|    if (*(ctxt->input->cur) == '\n') {					\
  |  |  ------------------
  |  |  |  Branch (311:9): [True: 18, False: 518]
  |  |  ------------------
  |  |  312|     18|	ctxt->input->line++; ctxt->input->col = 1;			\
  |  |  313|    518|    } else ctxt->input->col++;						\
  |  |  314|    536|    ctxt->token = 0; ctxt->input->cur += l;				\
  |  |  315|    536|  } while (0)
  |  |  ------------------
  |  |  |  Branch (315:12): [Folded - Ignored]
  |  |  ------------------
  ------------------
 3470|    536|    r = CUR_CHAR(rl);
  ------------------
  |  |  323|    536|#define CUR_CHAR(l) htmlCurrentChar(ctxt, &l)
  ------------------
 3471|    536|    if (r == 0)
  ------------------
  |  Branch (3471:9): [True: 0, False: 536]
  ------------------
 3472|      0|        goto unfinished;
 3473|    536|    if (q == '-' && r == '>') {
  ------------------
  |  Branch (3473:9): [True: 11, False: 525]
  |  Branch (3473:21): [True: 4, False: 7]
  ------------------
 3474|      4|        htmlParseErr(ctxt, XML_ERR_COMMENT_ABRUPTLY_ENDED, "Comment abruptly ended", NULL, NULL);
 3475|      4|        cur = '>';
 3476|      4|        goto finished;
 3477|      4|    }
 3478|    532|    NEXTL(rl);
  ------------------
  |  |  310|    532|#define NEXTL(l) do {							\
  |  |  311|    532|    if (*(ctxt->input->cur) == '\n') {					\
  |  |  ------------------
  |  |  |  Branch (311:9): [True: 8, False: 524]
  |  |  ------------------
  |  |  312|      8|	ctxt->input->line++; ctxt->input->col = 1;			\
  |  |  313|    524|    } else ctxt->input->col++;						\
  |  |  314|    532|    ctxt->token = 0; ctxt->input->cur += l;				\
  |  |  315|    532|  } while (0)
  |  |  ------------------
  |  |  |  Branch (315:12): [Folded - Ignored]
  |  |  ------------------
  ------------------
 3479|    532|    cur = CUR_CHAR(l);
  ------------------
  |  |  323|    532|#define CUR_CHAR(l) htmlCurrentChar(ctxt, &l)
  ------------------
 3480|  28.1k|    while ((cur != 0) &&
  ------------------
  |  Branch (3480:12): [True: 28.1k, False: 6]
  ------------------
 3481|  28.1k|           ((cur != '>') ||
  ------------------
  |  Branch (3481:13): [True: 27.0k, False: 1.04k]
  ------------------
 3482|  28.1k|	    (r != '-') || (q != '-'))) {
  ------------------
  |  Branch (3482:6): [True: 524, False: 520]
  |  Branch (3482:20): [True: 0, False: 520]
  ------------------
 3483|  27.5k|	NEXTL(l);
  ------------------
  |  |  310|  27.5k|#define NEXTL(l) do {							\
  |  |  311|  27.5k|    if (*(ctxt->input->cur) == '\n') {					\
  |  |  ------------------
  |  |  |  Branch (311:9): [True: 206, False: 27.3k]
  |  |  ------------------
  |  |  312|    206|	ctxt->input->line++; ctxt->input->col = 1;			\
  |  |  313|  27.3k|    } else ctxt->input->col++;						\
  |  |  314|  27.5k|    ctxt->token = 0; ctxt->input->cur += l;				\
  |  |  315|  27.5k|  } while (0)
  |  |  ------------------
  |  |  |  Branch (315:12): [Folded - Ignored]
  |  |  ------------------
  ------------------
 3484|  27.5k|	next = CUR_CHAR(nl);
  ------------------
  |  |  323|  27.5k|#define CUR_CHAR(l) htmlCurrentChar(ctxt, &l)
  ------------------
 3485|       |
 3486|  27.5k|	if ((q == '-') && (r == '-') && (cur == '!') && (next == '>')) {
  ------------------
  |  Branch (3486:6): [True: 241, False: 27.3k]
  |  Branch (3486:20): [True: 76, False: 165]
  |  Branch (3486:34): [True: 6, False: 70]
  |  Branch (3486:50): [True: 6, False: 0]
  ------------------
 3487|      6|	  htmlParseErr(ctxt, XML_ERR_COMMENT_NOT_FINISHED,
 3488|      6|		       "Comment incorrectly closed by '--!>'", NULL, NULL);
 3489|      6|	  cur = '>';
 3490|      6|	  break;
 3491|      6|	}
 3492|       |
 3493|  27.5k|	if (len + 5 >= size) {
  ------------------
  |  Branch (3493:6): [True: 100, False: 27.4k]
  ------------------
 3494|    100|	    xmlChar *tmp;
 3495|       |
 3496|    100|	    size *= 2;
 3497|    100|	    tmp = (xmlChar *) xmlRealloc(buf, size);
 3498|    100|	    if (tmp == NULL) {
  ------------------
  |  Branch (3498:10): [True: 0, False: 100]
  ------------------
 3499|      0|	        xmlFree(buf);
 3500|      0|	        htmlErrMemory(ctxt, "growing buffer failed\n");
 3501|      0|		ctxt->instate = state;
 3502|      0|		return;
 3503|      0|	    }
 3504|    100|	    buf = tmp;
 3505|    100|	}
 3506|  27.5k|        if (IS_CHAR(q)) {
  ------------------
  |  |  125|  27.5k|#define IS_CHAR(c)   xmlIsCharQ(c)
  |  |  ------------------
  |  |  |  |  118|  27.5k|#define xmlIsCharQ(c)		(((c) < 0x100) ? \
  |  |  |  |  ------------------
  |  |  |  |  |  Branch (118:24): [True: 27.5k, False: 6]
  |  |  |  |  |  Branch (118:25): [True: 27.5k, False: 0]
  |  |  |  |  ------------------
  |  |  |  |  119|  27.5k|				 xmlIsChar_ch((c)) :\
  |  |  |  |  ------------------
  |  |  |  |  |  |  108|  27.5k|#define xmlIsChar_ch(c)		(((0x9 <= (c)) && ((c) <= 0xa)) || \
  |  |  |  |  |  |  ------------------
  |  |  |  |  |  |  |  Branch (108:28): [True: 27.5k, False: 0]
  |  |  |  |  |  |  |  Branch (108:44): [True: 804, False: 26.7k]
  |  |  |  |  |  |  ------------------
  |  |  |  |  |  |  109|  27.5k|				 ((c) == 0xd) || \
  |  |  |  |  |  |  ------------------
  |  |  |  |  |  |  |  Branch (109:6): [True: 84, False: 26.7k]
  |  |  |  |  |  |  ------------------
  |  |  |  |  |  |  110|  27.5k|				  (0x20 <= (c)))
  |  |  |  |  |  |  ------------------
  |  |  |  |  |  |  |  Branch (110:7): [True: 26.6k, False: 6]
  |  |  |  |  |  |  ------------------
  |  |  |  |  ------------------
  |  |  |  |  120|  27.5k|				(((0x100 <= (c)) && ((c) <= 0xd7ff)) || \
  |  |  |  |  ------------------
  |  |  |  |  |  Branch (120:7): [True: 0, False: 0]
  |  |  |  |  |  Branch (120:25): [True: 0, False: 0]
  |  |  |  |  ------------------
  |  |  |  |  121|      0|				 ((0xe000 <= (c)) && ((c) <= 0xfffd)) || \
  |  |  |  |  ------------------
  |  |  |  |  |  Branch (121:7): [True: 0, False: 0]
  |  |  |  |  |  Branch (121:26): [True: 0, False: 0]
  |  |  |  |  ------------------
  |  |  |  |  122|      0|				 ((0x10000 <= (c)) && ((c) <= 0x10ffff))))
  |  |  |  |  ------------------
  |  |  |  |  |  Branch (122:7): [True: 0, False: 0]
  |  |  |  |  |  Branch (122:27): [True: 0, False: 0]
  |  |  |  |  ------------------
  |  |  ------------------
  ------------------
 3507|  27.5k|	    COPY_BUF(ql,buf,len,q);
  ------------------
  |  |  326|  27.5k|    if (l == 1) b[i++] = v;						\
  |  |  ------------------
  |  |  |  Branch (326:9): [True: 27.5k, False: 10]
  |  |  ------------------
  |  |  327|  27.5k|    else i += xmlCopyChar(l,&b[i],v)
  ------------------
 3508|  27.5k|        } else {
 3509|      6|            htmlParseErrInt(ctxt, XML_ERR_INVALID_CHAR,
 3510|      6|                            "Invalid char in comment 0x%X\n", q);
 3511|      6|        }
 3512|  27.5k|        if (len > maxLength) {
  ------------------
  |  Branch (3512:13): [True: 0, False: 27.5k]
  ------------------
 3513|      0|            htmlParseErr(ctxt, XML_ERR_COMMENT_NOT_FINISHED,
 3514|      0|                         "comment too long", NULL, NULL);
 3515|      0|            xmlFree(buf);
 3516|      0|            ctxt->instate = state;
 3517|      0|            return;
 3518|      0|        }
 3519|       |
 3520|  27.5k|	q = r;
 3521|  27.5k|	ql = rl;
 3522|  27.5k|	r = cur;
 3523|  27.5k|	rl = l;
 3524|  27.5k|	cur = next;
 3525|  27.5k|	l = nl;
 3526|  27.5k|    }
 3527|    540|finished:
 3528|    540|    buf[len] = 0;
 3529|    540|    if (ctxt->instate == XML_PARSER_EOF) {
  ------------------
  |  Branch (3529:9): [True: 0, False: 540]
  ------------------
 3530|      0|        xmlFree(buf);
 3531|      0|        return;
 3532|      0|    }
 3533|    540|    if (cur == '>') {
  ------------------
  |  Branch (3533:9): [True: 534, False: 6]
  ------------------
 3534|    534|        NEXT;
  ------------------
  |  |  305|    534|#define NEXT xmlNextChar(ctxt)
  ------------------
 3535|    534|	if ((ctxt->sax != NULL) && (ctxt->sax->comment != NULL) &&
  ------------------
  |  Branch (3535:6): [True: 534, False: 0]
  |  Branch (3535:29): [True: 534, False: 0]
  ------------------
 3536|    534|	    (!ctxt->disableSAX))
  ------------------
  |  Branch (3536:6): [True: 526, False: 8]
  ------------------
 3537|    526|	    ctxt->sax->comment(ctxt->userData, buf);
 3538|    534|	xmlFree(buf);
 3539|    534|	ctxt->instate = state;
 3540|    534|	return;
 3541|    534|    }
 3542|       |
 3543|      6|unfinished:
 3544|      6|    htmlParseErr(ctxt, XML_ERR_COMMENT_NOT_FINISHED,
 3545|      6|		 "Comment not terminated \n<!--%.50s\n", buf, NULL);
 3546|      6|    xmlFree(buf);
 3547|      6|}
HTMLparser.c:htmlParsePI:
 3312|     21|htmlParsePI(htmlParserCtxtPtr ctxt) {
 3313|     21|    xmlChar *buf = NULL;
 3314|     21|    int len = 0;
 3315|     21|    int size = HTML_PARSER_BUFFER_SIZE;
  ------------------
  |  |   39|     21|#define HTML_PARSER_BUFFER_SIZE 100
  ------------------
 3316|     21|    int cur, l;
 3317|     21|    int maxLength = (ctxt->options & XML_PARSE_HUGE) ?
  ------------------
  |  Branch (3317:21): [True: 0, False: 21]
  ------------------
 3318|      0|                    XML_MAX_HUGE_LENGTH :
  ------------------
  |  |   49|      0|#define XML_MAX_HUGE_LENGTH 1000000000
  ------------------
 3319|     21|                    XML_MAX_TEXT_LENGTH;
  ------------------
  |  |   42|     21|#define XML_MAX_TEXT_LENGTH 10000000
  ------------------
 3320|     21|    const xmlChar *target;
 3321|     21|    xmlParserInputState state;
 3322|       |
 3323|     21|    if ((RAW == '<') && (NXT(1) == '?')) {
  ------------------
  |  |  307|     21|#define RAW (ctxt->token ? -1 : (*ctxt->input->cur))
  |  |  ------------------
  |  |  |  Branch (307:14): [True: 0, False: 21]
  |  |  ------------------
  ------------------
                  if ((RAW == '<') && (NXT(1) == '?')) {
  ------------------
  |  |  285|      9|#define NXT(val) ctxt->input->cur[(val)]
  ------------------
  |  Branch (3323:9): [True: 9, False: 12]
  |  Branch (3323:25): [True: 4, False: 5]
  ------------------
 3324|      4|	state = ctxt->instate;
 3325|      4|        ctxt->instate = XML_PARSER_PI;
 3326|       |	/*
 3327|       |	 * this is a Processing Instruction.
 3328|       |	 */
 3329|      4|	SKIP(2);
  ------------------
  |  |  283|      4|#define SKIP(val) ctxt->input->cur += (val),ctxt->input->col+=(val)
  ------------------
 3330|       |
 3331|       |	/*
 3332|       |	 * Parse the target name and check for special support like
 3333|       |	 * namespace.
 3334|       |	 */
 3335|      4|        target = htmlParseName(ctxt);
 3336|      4|	if (target != NULL) {
  ------------------
  |  Branch (3336:6): [True: 2, False: 2]
  ------------------
 3337|      2|	    if (RAW == '>') {
  ------------------
  |  |  307|      2|#define RAW (ctxt->token ? -1 : (*ctxt->input->cur))
  |  |  ------------------
  |  |  |  Branch (307:14): [True: 0, False: 2]
  |  |  ------------------
  ------------------
  |  Branch (3337:10): [True: 0, False: 2]
  ------------------
 3338|      0|		SKIP(1);
  ------------------
  |  |  283|      0|#define SKIP(val) ctxt->input->cur += (val),ctxt->input->col+=(val)
  ------------------
 3339|       |
 3340|       |		/*
 3341|       |		 * SAX: PI detected.
 3342|       |		 */
 3343|      0|		if ((ctxt->sax) && (!ctxt->disableSAX) &&
  ------------------
  |  Branch (3343:7): [True: 0, False: 0]
  |  Branch (3343:22): [True: 0, False: 0]
  ------------------
 3344|      0|		    (ctxt->sax->processingInstruction != NULL))
  ------------------
  |  Branch (3344:7): [True: 0, False: 0]
  ------------------
 3345|      0|		    ctxt->sax->processingInstruction(ctxt->userData,
 3346|      0|		                                     target, NULL);
 3347|      0|		ctxt->instate = state;
 3348|      0|		return;
 3349|      0|	    }
 3350|      2|	    buf = (xmlChar *) xmlMallocAtomic(size);
 3351|      2|	    if (buf == NULL) {
  ------------------
  |  Branch (3351:10): [True: 0, False: 2]
  ------------------
 3352|      0|		htmlErrMemory(ctxt, NULL);
 3353|      0|		ctxt->instate = state;
 3354|      0|		return;
 3355|      0|	    }
 3356|      2|	    cur = CUR;
  ------------------
  |  |  304|      2|#define CUR (*ctxt->input->cur)
  ------------------
 3357|      2|	    if (!IS_BLANK(cur)) {
  ------------------
  |  |  143|      2|#define IS_BLANK(c)  xmlIsBlankQ(c)
  |  |  ------------------
  |  |  |  |   98|      2|#define xmlIsBlankQ(c)		(((c) < 0x100) ? \
  |  |  |  |  ------------------
  |  |  |  |  |  Branch (98:26): [True: 2, False: 0]
  |  |  |  |  ------------------
  |  |  |  |   99|      2|				 xmlIsBlank_ch((c)) : 0)
  |  |  |  |  ------------------
  |  |  |  |  |  |   88|      2|#define xmlIsBlank_ch(c)	(((c) == 0x20) || \
  |  |  |  |  |  |  ------------------
  |  |  |  |  |  |  |  Branch (88:27): [True: 2, False: 0]
  |  |  |  |  |  |  ------------------
  |  |  |  |  |  |   89|      2|				 ((0x9 <= (c)) && ((c) <= 0xa)) || \
  |  |  |  |  |  |  ------------------
  |  |  |  |  |  |  |  Branch (89:7): [True: 0, False: 0]
  |  |  |  |  |  |  |  Branch (89:23): [True: 0, False: 0]
  |  |  |  |  |  |  ------------------
  |  |  |  |  |  |   90|      2|				 ((c) == 0xd))
  |  |  |  |  |  |  ------------------
  |  |  |  |  |  |  |  Branch (90:6): [True: 0, False: 0]
  |  |  |  |  |  |  ------------------
  |  |  |  |  ------------------
  |  |  ------------------
  ------------------
  |  Branch (3357:10): [True: 0, False: 2]
  ------------------
 3358|      0|		htmlParseErr(ctxt, XML_ERR_SPACE_REQUIRED,
 3359|      0|			  "ParsePI: PI %s space expected\n", target, NULL);
 3360|      0|	    }
 3361|      2|            SKIP_BLANKS;
  ------------------
  |  |  300|      2|#define SKIP_BLANKS htmlSkipBlankChars(ctxt)
  ------------------
 3362|      2|	    cur = CUR_CHAR(l);
  ------------------
  |  |  323|      2|#define CUR_CHAR(l) htmlCurrentChar(ctxt, &l)
  ------------------
 3363|     84|	    while ((cur != 0) && (cur != '>')) {
  ------------------
  |  Branch (3363:13): [True: 84, False: 0]
  |  Branch (3363:27): [True: 82, False: 2]
  ------------------
 3364|     82|		if (len + 5 >= size) {
  ------------------
  |  Branch (3364:7): [True: 0, False: 82]
  ------------------
 3365|      0|		    xmlChar *tmp;
 3366|       |
 3367|      0|		    size *= 2;
 3368|      0|		    tmp = (xmlChar *) xmlRealloc(buf, size);
 3369|      0|		    if (tmp == NULL) {
  ------------------
  |  Branch (3369:11): [True: 0, False: 0]
  ------------------
 3370|      0|			htmlErrMemory(ctxt, NULL);
 3371|      0|			xmlFree(buf);
 3372|      0|			ctxt->instate = state;
 3373|      0|			return;
 3374|      0|		    }
 3375|      0|		    buf = tmp;
 3376|      0|		}
 3377|     82|                if (IS_CHAR(cur)) {
  ------------------
  |  |  125|     82|#define IS_CHAR(c)   xmlIsCharQ(c)
  |  |  ------------------
  |  |  |  |  118|     82|#define xmlIsCharQ(c)		(((c) < 0x100) ? \
  |  |  |  |  ------------------
  |  |  |  |  |  Branch (118:24): [True: 82, False: 0]
  |  |  |  |  |  Branch (118:25): [True: 82, False: 0]
  |  |  |  |  ------------------
  |  |  |  |  119|     82|				 xmlIsChar_ch((c)) :\
  |  |  |  |  ------------------
  |  |  |  |  |  |  108|     82|#define xmlIsChar_ch(c)		(((0x9 <= (c)) && ((c) <= 0xa)) || \
  |  |  |  |  |  |  ------------------
  |  |  |  |  |  |  |  Branch (108:28): [True: 82, False: 0]
  |  |  |  |  |  |  |  Branch (108:44): [True: 0, False: 82]
  |  |  |  |  |  |  ------------------
  |  |  |  |  |  |  109|     82|				 ((c) == 0xd) || \
  |  |  |  |  |  |  ------------------
  |  |  |  |  |  |  |  Branch (109:6): [True: 0, False: 82]
  |  |  |  |  |  |  ------------------
  |  |  |  |  |  |  110|     82|				  (0x20 <= (c)))
  |  |  |  |  |  |  ------------------
  |  |  |  |  |  |  |  Branch (110:7): [True: 82, False: 0]
  |  |  |  |  |  |  ------------------
  |  |  |  |  ------------------
  |  |  |  |  120|     82|				(((0x100 <= (c)) && ((c) <= 0xd7ff)) || \
  |  |  |  |  ------------------
  |  |  |  |  |  Branch (120:7): [True: 0, False: 0]
  |  |  |  |  |  Branch (120:25): [True: 0, False: 0]
  |  |  |  |  ------------------
  |  |  |  |  121|      0|				 ((0xe000 <= (c)) && ((c) <= 0xfffd)) || \
  |  |  |  |  ------------------
  |  |  |  |  |  Branch (121:7): [True: 0, False: 0]
  |  |  |  |  |  Branch (121:26): [True: 0, False: 0]
  |  |  |  |  ------------------
  |  |  |  |  122|      0|				 ((0x10000 <= (c)) && ((c) <= 0x10ffff))))
  |  |  |  |  ------------------
  |  |  |  |  |  Branch (122:7): [True: 0, False: 0]
  |  |  |  |  |  Branch (122:27): [True: 0, False: 0]
  |  |  |  |  ------------------
  |  |  ------------------
  ------------------
 3378|     82|		    COPY_BUF(l,buf,len,cur);
  ------------------
  |  |  326|     82|    if (l == 1) b[i++] = v;						\
  |  |  ------------------
  |  |  |  Branch (326:9): [True: 82, False: 0]
  |  |  ------------------
  |  |  327|     82|    else i += xmlCopyChar(l,&b[i],v)
  ------------------
 3379|     82|                } else {
 3380|      0|                    htmlParseErrInt(ctxt, XML_ERR_INVALID_CHAR,
 3381|      0|                                    "Invalid char in processing instruction "
 3382|      0|                                    "0x%X\n", cur);
 3383|      0|                }
 3384|     82|                if (len > maxLength) {
  ------------------
  |  Branch (3384:21): [True: 0, False: 82]
  ------------------
 3385|      0|                    htmlParseErr(ctxt, XML_ERR_PI_NOT_FINISHED,
 3386|      0|                                 "PI %s too long", target, NULL);
 3387|      0|                    xmlFree(buf);
 3388|      0|                    ctxt->instate = state;
 3389|      0|                    return;
 3390|      0|                }
 3391|     82|		NEXTL(l);
  ------------------
  |  |  310|     82|#define NEXTL(l) do {							\
  |  |  311|     82|    if (*(ctxt->input->cur) == '\n') {					\
  |  |  ------------------
  |  |  |  Branch (311:9): [True: 0, False: 82]
  |  |  ------------------
  |  |  312|      0|	ctxt->input->line++; ctxt->input->col = 1;			\
  |  |  313|     82|    } else ctxt->input->col++;						\
  |  |  314|     82|    ctxt->token = 0; ctxt->input->cur += l;				\
  |  |  315|     82|  } while (0)
  |  |  ------------------
  |  |  |  Branch (315:12): [Folded - Ignored]
  |  |  ------------------
  ------------------
 3392|     82|		cur = CUR_CHAR(l);
  ------------------
  |  |  323|     82|#define CUR_CHAR(l) htmlCurrentChar(ctxt, &l)
  ------------------
 3393|     82|	    }
 3394|      2|	    buf[len] = 0;
 3395|      2|            if (ctxt->instate == XML_PARSER_EOF) {
  ------------------
  |  Branch (3395:17): [True: 0, False: 2]
  ------------------
 3396|      0|                xmlFree(buf);
 3397|      0|                return;
 3398|      0|            }
 3399|      2|	    if (cur != '>') {
  ------------------
  |  Branch (3399:10): [True: 0, False: 2]
  ------------------
 3400|      0|		htmlParseErr(ctxt, XML_ERR_PI_NOT_FINISHED,
 3401|      0|		      "ParsePI: PI %s never end ...\n", target, NULL);
 3402|      2|	    } else {
 3403|      2|		SKIP(1);
  ------------------
  |  |  283|      2|#define SKIP(val) ctxt->input->cur += (val),ctxt->input->col+=(val)
  ------------------
 3404|       |
 3405|       |		/*
 3406|       |		 * SAX: PI detected.
 3407|       |		 */
 3408|      2|		if ((ctxt->sax) && (!ctxt->disableSAX) &&
  ------------------
  |  Branch (3408:7): [True: 2, False: 0]
  |  Branch (3408:22): [True: 2, False: 0]
  ------------------
 3409|      2|		    (ctxt->sax->processingInstruction != NULL))
  ------------------
  |  Branch (3409:7): [True: 2, False: 0]
  ------------------
 3410|      2|		    ctxt->sax->processingInstruction(ctxt->userData,
 3411|      2|		                                     target, buf);
 3412|      2|	    }
 3413|      2|	    xmlFree(buf);
 3414|      2|	} else {
 3415|      2|	    htmlParseErr(ctxt, XML_ERR_PI_NOT_STARTED,
 3416|      2|                         "PI is not started correctly", NULL, NULL);
 3417|      2|	}
 3418|      4|	ctxt->instate = state;
 3419|      4|    }
 3420|     21|}
HTMLparser.c:htmlParseDocTypeDecl:
 3643|     46|htmlParseDocTypeDecl(htmlParserCtxtPtr ctxt) {
 3644|     46|    const xmlChar *name;
 3645|     46|    xmlChar *ExternalID = NULL;
 3646|     46|    xmlChar *URI = NULL;
 3647|       |
 3648|       |    /*
 3649|       |     * We know that '<!DOCTYPE' has been detected.
 3650|       |     */
 3651|     46|    SKIP(9);
  ------------------
  |  |  283|     46|#define SKIP(val) ctxt->input->cur += (val),ctxt->input->col+=(val)
  ------------------
 3652|       |
 3653|     46|    SKIP_BLANKS;
  ------------------
  |  |  300|     46|#define SKIP_BLANKS htmlSkipBlankChars(ctxt)
  ------------------
 3654|       |
 3655|       |    /*
 3656|       |     * Parse the DOCTYPE name.
 3657|       |     */
 3658|     46|    name = htmlParseName(ctxt);
 3659|     46|    if (name == NULL) {
  ------------------
  |  Branch (3659:9): [True: 0, False: 46]
  ------------------
 3660|      0|	htmlParseErr(ctxt, XML_ERR_NAME_REQUIRED,
 3661|      0|	             "htmlParseDocTypeDecl : no DOCTYPE name !\n",
 3662|      0|		     NULL, NULL);
 3663|      0|    }
 3664|       |    /*
 3665|       |     * Check that upper(name) == "HTML" !!!!!!!!!!!!!
 3666|       |     */
 3667|       |
 3668|     46|    SKIP_BLANKS;
  ------------------
  |  |  300|     46|#define SKIP_BLANKS htmlSkipBlankChars(ctxt)
  ------------------
 3669|       |
 3670|       |    /*
 3671|       |     * Check for SystemID and ExternalID
 3672|       |     */
 3673|     46|    URI = htmlParseExternalID(ctxt, &ExternalID);
 3674|     46|    SKIP_BLANKS;
  ------------------
  |  |  300|     46|#define SKIP_BLANKS htmlSkipBlankChars(ctxt)
  ------------------
 3675|       |
 3676|       |    /*
 3677|       |     * We should be at the end of the DOCTYPE declaration.
 3678|       |     */
 3679|     46|    if (CUR != '>') {
  ------------------
  |  |  304|     46|#define CUR (*ctxt->input->cur)
  ------------------
  |  Branch (3679:9): [True: 4, False: 42]
  ------------------
 3680|      4|	htmlParseErr(ctxt, XML_ERR_DOCTYPE_NOT_FINISHED,
 3681|      4|	             "DOCTYPE improperly terminated\n", NULL, NULL);
 3682|       |        /* Ignore bogus content */
 3683|    114|        while ((CUR != 0) && (CUR != '>') &&
  ------------------
  |  |  304|    114|#define CUR (*ctxt->input->cur)
  ------------------
                      while ((CUR != 0) && (CUR != '>') &&
  ------------------
  |  |  304|    114|#define CUR (*ctxt->input->cur)
  ------------------
  |  Branch (3683:16): [True: 114, False: 0]
  |  Branch (3683:30): [True: 110, False: 4]
  ------------------
 3684|    114|               (ctxt->instate != XML_PARSER_EOF))
  ------------------
  |  Branch (3684:16): [True: 110, False: 0]
  ------------------
 3685|    110|            NEXT;
  ------------------
  |  |  305|    110|#define NEXT xmlNextChar(ctxt)
  ------------------
 3686|      4|    }
 3687|     46|    if (CUR == '>')
  ------------------
  |  |  304|     46|#define CUR (*ctxt->input->cur)
  ------------------
  |  Branch (3687:9): [True: 46, False: 0]
  ------------------
 3688|     46|        NEXT;
  ------------------
  |  |  305|     46|#define NEXT xmlNextChar(ctxt)
  ------------------
 3689|       |
 3690|       |    /*
 3691|       |     * Create or update the document accordingly to the DOCTYPE
 3692|       |     */
 3693|     46|    if ((ctxt->sax != NULL) && (ctxt->sax->internalSubset != NULL) &&
  ------------------
  |  Branch (3693:9): [True: 46, False: 0]
  |  Branch (3693:32): [True: 46, False: 0]
  ------------------
 3694|     46|	(!ctxt->disableSAX))
  ------------------
  |  Branch (3694:2): [True: 42, False: 4]
  ------------------
 3695|     42|	ctxt->sax->internalSubset(ctxt->userData, name, ExternalID, URI);
 3696|       |
 3697|       |    /*
 3698|       |     * Cleanup, since we don't use all those identifiers
 3699|       |     */
 3700|     46|    if (URI != NULL) xmlFree(URI);
  ------------------
  |  Branch (3700:9): [True: 12, False: 34]
  ------------------
 3701|     46|    if (ExternalID != NULL) xmlFree(ExternalID);
  ------------------
  |  Branch (3701:9): [True: 36, False: 10]
  ------------------
 3702|     46|}
HTMLparser.c:htmlParseExternalID:
 3263|     46|htmlParseExternalID(htmlParserCtxtPtr ctxt, xmlChar **publicID) {
 3264|     46|    xmlChar *URI = NULL;
 3265|       |
 3266|     46|    if ((UPPER == 'S') && (UPP(1) == 'Y') &&
  ------------------
  |  |  281|     46|#define UPPER (toupper(*ctxt->input->cur))
  ------------------
                  if ((UPPER == 'S') && (UPP(1) == 'Y') &&
  ------------------
  |  |  287|      0|#define UPP(val) (toupper(ctxt->input->cur[(val)]))
  ------------------
  |  Branch (3266:9): [True: 0, False: 46]
  |  Branch (3266:27): [True: 0, False: 0]
  ------------------
 3267|     46|         (UPP(2) == 'S') && (UPP(3) == 'T') &&
  ------------------
  |  |  287|      0|#define UPP(val) (toupper(ctxt->input->cur[(val)]))
  ------------------
                       (UPP(2) == 'S') && (UPP(3) == 'T') &&
  ------------------
  |  |  287|      0|#define UPP(val) (toupper(ctxt->input->cur[(val)]))
  ------------------
  |  Branch (3267:10): [True: 0, False: 0]
  |  Branch (3267:29): [True: 0, False: 0]
  ------------------
 3268|     46|	 (UPP(4) == 'E') && (UPP(5) == 'M')) {
  ------------------
  |  |  287|      0|#define UPP(val) (toupper(ctxt->input->cur[(val)]))
  ------------------
              	 (UPP(4) == 'E') && (UPP(5) == 'M')) {
  ------------------
  |  |  287|      0|#define UPP(val) (toupper(ctxt->input->cur[(val)]))
  ------------------
  |  Branch (3268:3): [True: 0, False: 0]
  |  Branch (3268:22): [True: 0, False: 0]
  ------------------
 3269|      0|        SKIP(6);
  ------------------
  |  |  283|      0|#define SKIP(val) ctxt->input->cur += (val),ctxt->input->col+=(val)
  ------------------
 3270|      0|	if (!IS_BLANK_CH(CUR)) {
  ------------------
  |  |  151|      0|#define IS_BLANK_CH(c)  xmlIsBlank_ch(c)
  |  |  ------------------
  |  |  |  |   88|      0|#define xmlIsBlank_ch(c)	(((c) == 0x20) || \
  |  |  |  |  ------------------
  |  |  |  |  |  Branch (88:27): [True: 0, False: 0]
  |  |  |  |  ------------------
  |  |  |  |   89|      0|				 ((0x9 <= (c)) && ((c) <= 0xa)) || \
  |  |  |  |  ------------------
  |  |  |  |  |  Branch (89:7): [True: 0, False: 0]
  |  |  |  |  |  Branch (89:23): [True: 0, False: 0]
  |  |  |  |  ------------------
  |  |  |  |   90|      0|				 ((c) == 0xd))
  |  |  |  |  ------------------
  |  |  |  |  |  Branch (90:6): [True: 0, False: 0]
  |  |  |  |  ------------------
  |  |  ------------------
  ------------------
 3271|      0|	    htmlParseErr(ctxt, XML_ERR_SPACE_REQUIRED,
 3272|      0|	                 "Space required after 'SYSTEM'\n", NULL, NULL);
 3273|      0|	}
 3274|      0|        SKIP_BLANKS;
  ------------------
  |  |  300|      0|#define SKIP_BLANKS htmlSkipBlankChars(ctxt)
  ------------------
 3275|      0|	URI = htmlParseSystemLiteral(ctxt);
 3276|      0|	if (URI == NULL) {
  ------------------
  |  Branch (3276:6): [True: 0, False: 0]
  ------------------
 3277|      0|	    htmlParseErr(ctxt, XML_ERR_URI_REQUIRED,
 3278|      0|	                 "htmlParseExternalID: SYSTEM, no URI\n", NULL, NULL);
 3279|      0|        }
 3280|     46|    } else if ((UPPER == 'P') && (UPP(1) == 'U') &&
  ------------------
  |  |  281|     46|#define UPPER (toupper(*ctxt->input->cur))
  ------------------
                  } else if ((UPPER == 'P') && (UPP(1) == 'U') &&
  ------------------
  |  |  287|     40|#define UPP(val) (toupper(ctxt->input->cur[(val)]))
  ------------------
  |  Branch (3280:16): [True: 40, False: 6]
  |  Branch (3280:34): [True: 40, False: 0]
  ------------------
 3281|     46|	       (UPP(2) == 'B') && (UPP(3) == 'L') &&
  ------------------
  |  |  287|     40|#define UPP(val) (toupper(ctxt->input->cur[(val)]))
  ------------------
              	       (UPP(2) == 'B') && (UPP(3) == 'L') &&
  ------------------
  |  |  287|     38|#define UPP(val) (toupper(ctxt->input->cur[(val)]))
  ------------------
  |  Branch (3281:9): [True: 38, False: 2]
  |  Branch (3281:28): [True: 38, False: 0]
  ------------------
 3282|     46|	       (UPP(4) == 'I') && (UPP(5) == 'C')) {
  ------------------
  |  |  287|     38|#define UPP(val) (toupper(ctxt->input->cur[(val)]))
  ------------------
              	       (UPP(4) == 'I') && (UPP(5) == 'C')) {
  ------------------
  |  |  287|     38|#define UPP(val) (toupper(ctxt->input->cur[(val)]))
  ------------------
  |  Branch (3282:9): [True: 38, False: 0]
  |  Branch (3282:28): [True: 36, False: 2]
  ------------------
 3283|     36|        SKIP(6);
  ------------------
  |  |  283|     36|#define SKIP(val) ctxt->input->cur += (val),ctxt->input->col+=(val)
  ------------------
 3284|     36|	if (!IS_BLANK_CH(CUR)) {
  ------------------
  |  |  151|     36|#define IS_BLANK_CH(c)  xmlIsBlank_ch(c)
  |  |  ------------------
  |  |  |  |   88|     36|#define xmlIsBlank_ch(c)	(((c) == 0x20) || \
  |  |  |  |  ------------------
  |  |  |  |  |  Branch (88:27): [True: 36, False: 0]
  |  |  |  |  ------------------
  |  |  |  |   89|     36|				 ((0x9 <= (c)) && ((c) <= 0xa)) || \
  |  |  |  |  ------------------
  |  |  |  |  |  Branch (89:7): [True: 0, False: 0]
  |  |  |  |  |  Branch (89:23): [True: 0, False: 0]
  |  |  |  |  ------------------
  |  |  |  |   90|     36|				 ((c) == 0xd))
  |  |  |  |  ------------------
  |  |  |  |  |  Branch (90:6): [True: 0, False: 0]
  |  |  |  |  ------------------
  |  |  ------------------
  ------------------
 3285|      0|	    htmlParseErr(ctxt, XML_ERR_SPACE_REQUIRED,
 3286|      0|	                 "Space required after 'PUBLIC'\n", NULL, NULL);
 3287|      0|	}
 3288|     36|        SKIP_BLANKS;
  ------------------
  |  |  300|     36|#define SKIP_BLANKS htmlSkipBlankChars(ctxt)
  ------------------
 3289|     36|	*publicID = htmlParsePubidLiteral(ctxt);
 3290|     36|	if (*publicID == NULL) {
  ------------------
  |  Branch (3290:6): [True: 0, False: 36]
  ------------------
 3291|      0|	    htmlParseErr(ctxt, XML_ERR_PUBID_REQUIRED,
 3292|      0|	                 "htmlParseExternalID: PUBLIC, no Public Identifier\n",
 3293|      0|			 NULL, NULL);
 3294|      0|	}
 3295|     36|        SKIP_BLANKS;
  ------------------
  |  |  300|     36|#define SKIP_BLANKS htmlSkipBlankChars(ctxt)
  ------------------
 3296|     36|        if ((CUR == '"') || (CUR == '\'')) {
  ------------------
  |  |  304|     36|#define CUR (*ctxt->input->cur)
  ------------------
                      if ((CUR == '"') || (CUR == '\'')) {
  ------------------
  |  |  304|     24|#define CUR (*ctxt->input->cur)
  ------------------
  |  Branch (3296:13): [True: 12, False: 24]
  |  Branch (3296:29): [True: 0, False: 24]
  ------------------
 3297|     12|	    URI = htmlParseSystemLiteral(ctxt);
 3298|     12|	}
 3299|     36|    }
 3300|     46|    return(URI);
 3301|     46|}
HTMLparser.c:htmlParseSystemLiteral:
 2951|     12|htmlParseSystemLiteral(htmlParserCtxtPtr ctxt) {
 2952|     12|    size_t len = 0, startPosition = 0;
 2953|     12|    int err = 0;
 2954|     12|    int quote;
 2955|     12|    xmlChar *ret = NULL;
 2956|       |
 2957|     12|    if ((CUR != '"') && (CUR != '\'')) {
  ------------------
  |  |  304|     12|#define CUR (*ctxt->input->cur)
  ------------------
                  if ((CUR != '"') && (CUR != '\'')) {
  ------------------
  |  |  304|      0|#define CUR (*ctxt->input->cur)
  ------------------
  |  Branch (2957:9): [True: 0, False: 12]
  |  Branch (2957:25): [True: 0, False: 0]
  ------------------
 2958|      0|	htmlParseErr(ctxt, XML_ERR_LITERAL_NOT_STARTED,
 2959|      0|	             "SystemLiteral \" or ' expected\n", NULL, NULL);
 2960|      0|        return(NULL);
 2961|      0|    }
 2962|     12|    quote = CUR;
  ------------------
  |  |  304|     12|#define CUR (*ctxt->input->cur)
  ------------------
 2963|     12|    NEXT;
  ------------------
  |  |  305|     12|#define NEXT xmlNextChar(ctxt)
  ------------------
 2964|       |
 2965|     12|    if (CUR_PTR < BASE_PTR)
  ------------------
  |  |  289|     12|#define CUR_PTR ctxt->input->cur
  ------------------
                  if (CUR_PTR < BASE_PTR)
  ------------------
  |  |  290|     12|#define BASE_PTR ctxt->input->base
  ------------------
  |  Branch (2965:9): [True: 0, False: 12]
  ------------------
 2966|      0|        return(ret);
 2967|     12|    startPosition = CUR_PTR - BASE_PTR;
  ------------------
  |  |  289|     12|#define CUR_PTR ctxt->input->cur
  ------------------
                  startPosition = CUR_PTR - BASE_PTR;
  ------------------
  |  |  290|     12|#define BASE_PTR ctxt->input->base
  ------------------
 2968|       |
 2969|    512|    while ((CUR != 0) && (CUR != quote)) {
  ------------------
  |  |  304|    512|#define CUR (*ctxt->input->cur)
  ------------------
                  while ((CUR != 0) && (CUR != quote)) {
  ------------------
  |  |  304|    512|#define CUR (*ctxt->input->cur)
  ------------------
  |  Branch (2969:12): [True: 512, False: 0]
  |  Branch (2969:26): [True: 500, False: 12]
  ------------------
 2970|       |        /* TODO: Handle UTF-8 */
 2971|    500|        if (!IS_CHAR_CH(CUR)) {
  ------------------
  |  |  133|    500|#define IS_CHAR_CH(c)  xmlIsChar_ch(c)
  |  |  ------------------
  |  |  |  |  108|    500|#define xmlIsChar_ch(c)		(((0x9 <= (c)) && ((c) <= 0xa)) || \
  |  |  |  |  ------------------
  |  |  |  |  |  Branch (108:28): [True: 500, False: 0]
  |  |  |  |  |  Branch (108:44): [True: 0, False: 500]
  |  |  |  |  ------------------
  |  |  |  |  109|    500|				 ((c) == 0xd) || \
  |  |  |  |  ------------------
  |  |  |  |  |  Branch (109:6): [True: 0, False: 500]
  |  |  |  |  ------------------
  |  |  |  |  110|    500|				  (0x20 <= (c)))
  |  |  |  |  ------------------
  |  |  |  |  |  Branch (110:7): [True: 500, False: 0]
  |  |  |  |  ------------------
  |  |  ------------------
  ------------------
 2972|      0|            htmlParseErrInt(ctxt, XML_ERR_INVALID_CHAR,
 2973|      0|                            "Invalid char in SystemLiteral 0x%X\n", CUR);
  ------------------
  |  |  304|      0|#define CUR (*ctxt->input->cur)
  ------------------
 2974|      0|            err = 1;
 2975|      0|        }
 2976|    500|        NEXT;
  ------------------
  |  |  305|    500|#define NEXT xmlNextChar(ctxt)
  ------------------
 2977|    500|        len++;
 2978|    500|    }
 2979|     12|    if (CUR != quote) {
  ------------------
  |  |  304|     12|#define CUR (*ctxt->input->cur)
  ------------------
  |  Branch (2979:9): [True: 0, False: 12]
  ------------------
 2980|      0|        htmlParseErr(ctxt, XML_ERR_LITERAL_NOT_FINISHED,
 2981|      0|                     "Unfinished SystemLiteral\n", NULL, NULL);
 2982|     12|    } else {
 2983|     12|        if (err == 0)
  ------------------
  |  Branch (2983:13): [True: 12, False: 0]
  ------------------
 2984|     12|            ret = xmlStrndup((BASE_PTR+startPosition), len);
  ------------------
  |  |  290|     12|#define BASE_PTR ctxt->input->base
  ------------------
 2985|     12|        NEXT;
  ------------------
  |  |  305|     12|#define NEXT xmlNextChar(ctxt)
  ------------------
 2986|     12|    }
 2987|       |
 2988|     12|    return(ret);
 2989|     12|}
HTMLparser.c:htmlParsePubidLiteral:
 3003|     36|htmlParsePubidLiteral(htmlParserCtxtPtr ctxt) {
 3004|     36|    size_t len = 0, startPosition = 0;
 3005|     36|    int err = 0;
 3006|     36|    int quote;
 3007|     36|    xmlChar *ret = NULL;
 3008|       |
 3009|     36|    if ((CUR != '"') && (CUR != '\'')) {
  ------------------
  |  |  304|     36|#define CUR (*ctxt->input->cur)
  ------------------
                  if ((CUR != '"') && (CUR != '\'')) {
  ------------------
  |  |  304|      2|#define CUR (*ctxt->input->cur)
  ------------------
  |  Branch (3009:9): [True: 2, False: 34]
  |  Branch (3009:25): [True: 0, False: 2]
  ------------------
 3010|      0|	htmlParseErr(ctxt, XML_ERR_LITERAL_NOT_STARTED,
 3011|      0|	             "PubidLiteral \" or ' expected\n", NULL, NULL);
 3012|      0|        return(NULL);
 3013|      0|    }
 3014|     36|    quote = CUR;
  ------------------
  |  |  304|     36|#define CUR (*ctxt->input->cur)
  ------------------
 3015|     36|    NEXT;
  ------------------
  |  |  305|     36|#define NEXT xmlNextChar(ctxt)
  ------------------
 3016|       |
 3017|       |    /*
 3018|       |     * Name ::= (Letter | '_') (NameChar)*
 3019|       |     */
 3020|     36|    if (CUR_PTR < BASE_PTR)
  ------------------
  |  |  289|     36|#define CUR_PTR ctxt->input->cur
  ------------------
                  if (CUR_PTR < BASE_PTR)
  ------------------
  |  |  290|     36|#define BASE_PTR ctxt->input->base
  ------------------
  |  Branch (3020:9): [True: 0, False: 36]
  ------------------
 3021|      0|        return(ret);
 3022|     36|    startPosition = CUR_PTR - BASE_PTR;
  ------------------
  |  |  289|     36|#define CUR_PTR ctxt->input->cur
  ------------------
                  startPosition = CUR_PTR - BASE_PTR;
  ------------------
  |  |  290|     36|#define BASE_PTR ctxt->input->base
  ------------------
 3023|       |
 3024|  1.19k|    while ((CUR != 0) && (CUR != quote)) {
  ------------------
  |  |  304|  1.19k|#define CUR (*ctxt->input->cur)
  ------------------
                  while ((CUR != 0) && (CUR != quote)) {
  ------------------
  |  |  304|  1.19k|#define CUR (*ctxt->input->cur)
  ------------------
  |  Branch (3024:12): [True: 1.19k, False: 0]
  |  Branch (3024:26): [True: 1.15k, False: 36]
  ------------------
 3025|  1.15k|        if (!IS_PUBIDCHAR_CH(CUR)) {
  ------------------
  |  |  287|  1.15k|#define IS_PUBIDCHAR_CH(c) xmlIsPubidChar_ch(c)
  |  |  ------------------
  |  |  |  |  199|  1.15k|#define xmlIsPubidChar_ch(c)	(xmlIsPubidChar_tab[(c)])
  |  |  ------------------
  ------------------
  |  Branch (3025:13): [True: 0, False: 1.15k]
  ------------------
 3026|      0|            htmlParseErrInt(ctxt, XML_ERR_INVALID_CHAR,
 3027|      0|                            "Invalid char in PubidLiteral 0x%X\n", CUR);
  ------------------
  |  |  304|      0|#define CUR (*ctxt->input->cur)
  ------------------
 3028|      0|            err = 1;
 3029|      0|        }
 3030|  1.15k|        len++;
 3031|  1.15k|        NEXT;
  ------------------
  |  |  305|  1.15k|#define NEXT xmlNextChar(ctxt)
  ------------------
 3032|  1.15k|    }
 3033|       |
 3034|     36|    if (CUR != quote) {
  ------------------
  |  |  304|     36|#define CUR (*ctxt->input->cur)
  ------------------
  |  Branch (3034:9): [True: 0, False: 36]
  ------------------
 3035|      0|        htmlParseErr(ctxt, XML_ERR_LITERAL_NOT_FINISHED,
 3036|      0|                     "Unfinished PubidLiteral\n", NULL, NULL);
 3037|     36|    } else {
 3038|     36|        if (err == 0)
  ------------------
  |  Branch (3038:13): [True: 36, False: 0]
  ------------------
 3039|     36|            ret = xmlStrndup((BASE_PTR + startPosition), len);
  ------------------
  |  |  290|     36|#define BASE_PTR ctxt->input->base
  ------------------
 3040|     36|        NEXT;
  ------------------
  |  |  305|     36|#define NEXT xmlNextChar(ctxt)
  ------------------
 3041|     36|    }
 3042|       |
 3043|     36|    return(ret);
 3044|     36|}
HTMLparser.c:htmlInitParserCtxt:
 4954|    191|{
 4955|    191|    if (ctxt == NULL) return(-1);
  ------------------
  |  Branch (4955:9): [True: 0, False: 191]
  ------------------
 4956|    191|    memset(ctxt, 0, sizeof(htmlParserCtxt));
 4957|       |
 4958|    191|    ctxt->dict = xmlDictCreate();
 4959|    191|    if (ctxt->dict == NULL) {
  ------------------
  |  Branch (4959:9): [True: 2, False: 189]
  ------------------
 4960|      2|        htmlErrMemory(NULL, "htmlInitParserCtxt: out of memory\n");
 4961|      2|	return(-1);
 4962|      2|    }
 4963|       |
 4964|    189|    if (ctxt->sax == NULL)
  ------------------
  |  Branch (4964:9): [True: 189, False: 0]
  ------------------
 4965|    189|        ctxt->sax = (htmlSAXHandler *) xmlMalloc(sizeof(htmlSAXHandler));
 4966|    189|    if (ctxt->sax == NULL) {
  ------------------
  |  Branch (4966:9): [True: 0, False: 189]
  ------------------
 4967|      0|        htmlErrMemory(NULL, "htmlInitParserCtxt: out of memory\n");
 4968|      0|	return(-1);
 4969|      0|    }
 4970|    189|    if (sax == NULL) {
  ------------------
  |  Branch (4970:9): [True: 189, False: 0]
  ------------------
 4971|    189|        memset(ctxt->sax, 0, sizeof(htmlSAXHandler));
 4972|    189|        xmlSAX2InitHtmlDefaultSAXHandler(ctxt->sax);
 4973|    189|        ctxt->userData = ctxt;
 4974|    189|    } else {
 4975|      0|        memcpy(ctxt->sax, sax, sizeof(htmlSAXHandler));
 4976|      0|        ctxt->userData = userData ? userData : ctxt;
  ------------------
  |  Branch (4976:26): [True: 0, False: 0]
  ------------------
 4977|      0|    }
 4978|       |
 4979|       |    /* Allocate the Input stack */
 4980|    189|    ctxt->inputTab = (htmlParserInputPtr *)
 4981|    189|                      xmlMalloc(5 * sizeof(htmlParserInputPtr));
 4982|    189|    if (ctxt->inputTab == NULL) {
  ------------------
  |  Branch (4982:9): [True: 2, False: 187]
  ------------------
 4983|      2|        htmlErrMemory(NULL, "htmlInitParserCtxt: out of memory\n");
 4984|      2|	ctxt->inputNr = 0;
 4985|      2|	ctxt->inputMax = 0;
 4986|      2|	ctxt->input = NULL;
 4987|      2|	return(-1);
 4988|      2|    }
 4989|    187|    ctxt->inputNr = 0;
 4990|    187|    ctxt->inputMax = 5;
 4991|    187|    ctxt->input = NULL;
 4992|    187|    ctxt->version = NULL;
 4993|    187|    ctxt->encoding = NULL;
 4994|    187|    ctxt->standalone = -1;
 4995|    187|    ctxt->instate = XML_PARSER_START;
 4996|       |
 4997|       |    /* Allocate the Node stack */
 4998|    187|    ctxt->nodeTab = (htmlNodePtr *) xmlMalloc(10 * sizeof(htmlNodePtr));
 4999|    187|    if (ctxt->nodeTab == NULL) {
  ------------------
  |  Branch (4999:9): [True: 2, False: 185]
  ------------------
 5000|      2|        htmlErrMemory(NULL, "htmlInitParserCtxt: out of memory\n");
 5001|      2|	ctxt->nodeNr = 0;
 5002|      2|	ctxt->nodeMax = 0;
 5003|      2|	ctxt->node = NULL;
 5004|      2|	ctxt->inputNr = 0;
 5005|      2|	ctxt->inputMax = 0;
 5006|      2|	ctxt->input = NULL;
 5007|      2|	return(-1);
 5008|      2|    }
 5009|    185|    ctxt->nodeNr = 0;
 5010|    185|    ctxt->nodeMax = 10;
 5011|    185|    ctxt->node = NULL;
 5012|       |
 5013|       |    /* Allocate the Name stack */
 5014|    185|    ctxt->nameTab = (const xmlChar **) xmlMalloc(10 * sizeof(xmlChar *));
 5015|    185|    if (ctxt->nameTab == NULL) {
  ------------------
  |  Branch (5015:9): [True: 0, False: 185]
  ------------------
 5016|      0|        htmlErrMemory(NULL, "htmlInitParserCtxt: out of memory\n");
 5017|      0|	ctxt->nameNr = 0;
 5018|      0|	ctxt->nameMax = 0;
 5019|      0|	ctxt->name = NULL;
 5020|      0|	ctxt->nodeNr = 0;
 5021|      0|	ctxt->nodeMax = 0;
 5022|      0|	ctxt->node = NULL;
 5023|      0|	ctxt->inputNr = 0;
 5024|      0|	ctxt->inputMax = 0;
 5025|      0|	ctxt->input = NULL;
 5026|      0|	return(-1);
 5027|      0|    }
 5028|    185|    ctxt->nameNr = 0;
 5029|    185|    ctxt->nameMax = 10;
 5030|    185|    ctxt->name = NULL;
 5031|       |
 5032|    185|    ctxt->nodeInfoTab = NULL;
 5033|    185|    ctxt->nodeInfoNr  = 0;
 5034|    185|    ctxt->nodeInfoMax = 0;
 5035|       |
 5036|    185|    ctxt->myDoc = NULL;
 5037|    185|    ctxt->wellFormed = 1;
 5038|    185|    ctxt->replaceEntities = 0;
 5039|    185|    ctxt->linenumbers = xmlLineNumbersDefaultValue;
  ------------------
  |  |  868|    185|    XML_GLOBAL_MACRO(xmlLineNumbersDefaultValue)
  |  |  ------------------
  |  |  |  |  500|    185|  #define XML_GLOBAL_MACRO(name) (*__##name())
  |  |  ------------------
  ------------------
 5040|    185|    ctxt->keepBlanks = xmlKeepBlanksDefaultValue;
  ------------------
  |  |  866|    185|  #define xmlKeepBlanksDefaultValue XML_GLOBAL_MACRO(xmlKeepBlanksDefaultValue)
  |  |  ------------------
  |  |  |  |  500|    185|  #define XML_GLOBAL_MACRO(name) (*__##name())
  |  |  ------------------
  ------------------
 5041|    185|    ctxt->html = 1;
 5042|    185|    ctxt->vctxt.flags = XML_VCTXT_USE_PCTXT;
  ------------------
  |  |   18|    185|#define XML_VCTXT_USE_PCTXT (1u << 1)
  ------------------
 5043|    185|    ctxt->vctxt.userData = ctxt;
 5044|    185|    ctxt->vctxt.error = xmlParserValidityError;
 5045|    185|    ctxt->vctxt.warning = xmlParserValidityWarning;
 5046|    185|    ctxt->record_info = 0;
 5047|    185|    ctxt->validate = 0;
 5048|    185|    ctxt->checkIndex = 0;
 5049|    185|    ctxt->catalogs = NULL;
 5050|    185|    xmlInitNodeInfoSeq(&ctxt->node_seq);
 5051|    185|    return(0);
 5052|    185|}
HTMLparser.c:htmlParseTryOrFinish:
 5366|  3.34k|htmlParseTryOrFinish(htmlParserCtxtPtr ctxt, int terminate) {
 5367|  3.34k|    int ret = 0;
 5368|  3.34k|    htmlParserInputPtr in;
 5369|  3.34k|    ptrdiff_t avail = 0;
 5370|  3.34k|    xmlChar cur, next;
 5371|       |
 5372|  3.34k|    htmlParserNodeInfo node_info;
 5373|       |
 5374|  31.5k|    while (1) {
  ------------------
  |  Branch (5374:12): [Folded - Ignored]
  ------------------
 5375|       |
 5376|  31.5k|	in = ctxt->input;
 5377|  31.5k|	if (in == NULL) break;
  ------------------
  |  Branch (5377:6): [True: 0, False: 31.5k]
  ------------------
 5378|  31.5k|	avail = in->end - in->cur;
 5379|  31.5k|	if ((avail == 0) && (terminate)) {
  ------------------
  |  Branch (5379:6): [True: 176, False: 31.3k]
  |  Branch (5379:22): [True: 87, False: 89]
  ------------------
 5380|     87|	    htmlAutoCloseOnEnd(ctxt);
 5381|     87|	    if ((ctxt->nameNr == 0) && (ctxt->instate != XML_PARSER_EOF)) {
  ------------------
  |  Branch (5381:10): [True: 87, False: 0]
  |  Branch (5381:33): [True: 86, False: 1]
  ------------------
 5382|       |		/*
 5383|       |		 * SAX: end of the document processing.
 5384|       |		 */
 5385|     86|		ctxt->instate = XML_PARSER_EOF;
 5386|     86|		if ((ctxt->sax) && (ctxt->sax->endDocument != NULL))
  ------------------
  |  Branch (5386:7): [True: 86, False: 0]
  |  Branch (5386:22): [True: 86, False: 0]
  ------------------
 5387|     86|		    ctxt->sax->endDocument(ctxt->userData);
 5388|     86|	    }
 5389|     87|	}
 5390|  31.5k|        if (avail < 1)
  ------------------
  |  Branch (5390:13): [True: 176, False: 31.3k]
  ------------------
 5391|    176|	    goto done;
 5392|       |        /*
 5393|       |         * This is done to make progress and avoid an infinite loop
 5394|       |         * if a parsing attempt was aborted by hitting a NUL byte. After
 5395|       |         * changing htmlCurrentChar, this probably isn't necessary anymore.
 5396|       |         * We should consider removing this check.
 5397|       |         */
 5398|  31.3k|	cur = in->cur[0];
 5399|  31.3k|	if (cur == 0) {
  ------------------
  |  Branch (5399:6): [True: 20, False: 31.3k]
  ------------------
 5400|     20|	    SKIP(1);
  ------------------
  |  |  283|     20|#define SKIP(val) ctxt->input->cur += (val),ctxt->input->col+=(val)
  ------------------
 5401|     20|	    continue;
 5402|     20|	}
 5403|       |
 5404|  31.3k|        switch (ctxt->instate) {
 5405|      6|            case XML_PARSER_EOF:
  ------------------
  |  Branch (5405:13): [True: 6, False: 31.3k]
  ------------------
 5406|       |	        /*
 5407|       |		 * Document parsing is done !
 5408|       |		 */
 5409|      6|	        goto done;
 5410|     91|            case XML_PARSER_START:
  ------------------
  |  Branch (5410:13): [True: 91, False: 31.2k]
  ------------------
 5411|       |	        /*
 5412|       |		 * Very first chars read from the document flow.
 5413|       |		 */
 5414|     91|		cur = in->cur[0];
 5415|     91|		if (IS_BLANK_CH(cur)) {
  ------------------
  |  |  151|     91|#define IS_BLANK_CH(c)  xmlIsBlank_ch(c)
  |  |  ------------------
  |  |  |  |   88|     91|#define xmlIsBlank_ch(c)	(((c) == 0x20) || \
  |  |  |  |  ------------------
  |  |  |  |  |  Branch (88:27): [True: 0, False: 91]
  |  |  |  |  ------------------
  |  |  |  |   89|     91|				 ((0x9 <= (c)) && ((c) <= 0xa)) || \
  |  |  |  |  ------------------
  |  |  |  |  |  Branch (89:7): [True: 91, False: 0]
  |  |  |  |  |  Branch (89:23): [True: 1, False: 90]
  |  |  |  |  ------------------
  |  |  |  |   90|     91|				 ((c) == 0xd))
  |  |  |  |  ------------------
  |  |  |  |  |  Branch (90:6): [True: 0, False: 90]
  |  |  |  |  ------------------
  |  |  ------------------
  ------------------
 5416|      1|		    SKIP_BLANKS;
  ------------------
  |  |  300|      1|#define SKIP_BLANKS htmlSkipBlankChars(ctxt)
  ------------------
 5417|      1|                    avail = in->end - in->cur;
 5418|      1|		}
 5419|     91|		if ((ctxt->sax) && (ctxt->sax->setDocumentLocator))
  ------------------
  |  Branch (5419:7): [True: 91, False: 0]
  |  Branch (5419:22): [True: 91, False: 0]
  ------------------
 5420|     91|		    ctxt->sax->setDocumentLocator(ctxt->userData,
 5421|     91|						  &xmlDefaultSAXLocator);
  ------------------
  |  |  861|     91|  #define xmlDefaultSAXLocator XML_GLOBAL_MACRO(xmlDefaultSAXLocator)
  |  |  ------------------
  |  |  |  |  500|     91|  #define XML_GLOBAL_MACRO(name) (*__##name())
  |  |  ------------------
  ------------------
 5422|     91|		if ((ctxt->sax) && (ctxt->sax->startDocument) &&
  ------------------
  |  Branch (5422:7): [True: 91, False: 0]
  |  Branch (5422:22): [True: 91, False: 0]
  ------------------
 5423|     91|	            (!ctxt->disableSAX))
  ------------------
  |  Branch (5423:14): [True: 91, False: 0]
  ------------------
 5424|     91|		    ctxt->sax->startDocument(ctxt->userData);
 5425|     91|                if (ctxt->instate == XML_PARSER_EOF)
  ------------------
  |  Branch (5425:21): [True: 0, False: 91]
  ------------------
 5426|      0|                    goto done;
 5427|       |
 5428|     91|		cur = in->cur[0];
 5429|     91|		next = in->cur[1];
 5430|     91|		if ((cur == '<') && (next == '!') &&
  ------------------
  |  Branch (5430:7): [True: 82, False: 9]
  |  Branch (5430:23): [True: 25, False: 57]
  ------------------
 5431|     91|		    (UPP(2) == 'D') && (UPP(3) == 'O') &&
  ------------------
  |  |  287|     25|#define UPP(val) (toupper(ctxt->input->cur[(val)]))
  ------------------
              		    (UPP(2) == 'D') && (UPP(3) == 'O') &&
  ------------------
  |  |  287|     18|#define UPP(val) (toupper(ctxt->input->cur[(val)]))
  ------------------
  |  Branch (5431:7): [True: 18, False: 7]
  |  Branch (5431:26): [True: 18, False: 0]
  ------------------
 5432|     91|		    (UPP(4) == 'C') && (UPP(5) == 'T') &&
  ------------------
  |  |  287|     18|#define UPP(val) (toupper(ctxt->input->cur[(val)]))
  ------------------
              		    (UPP(4) == 'C') && (UPP(5) == 'T') &&
  ------------------
  |  |  287|     18|#define UPP(val) (toupper(ctxt->input->cur[(val)]))
  ------------------
  |  Branch (5432:7): [True: 18, False: 0]
  |  Branch (5432:26): [True: 18, False: 0]
  ------------------
 5433|     91|		    (UPP(6) == 'Y') && (UPP(7) == 'P') &&
  ------------------
  |  |  287|     18|#define UPP(val) (toupper(ctxt->input->cur[(val)]))
  ------------------
              		    (UPP(6) == 'Y') && (UPP(7) == 'P') &&
  ------------------
  |  |  287|     18|#define UPP(val) (toupper(ctxt->input->cur[(val)]))
  ------------------
  |  Branch (5433:7): [True: 18, False: 0]
  |  Branch (5433:26): [True: 18, False: 0]
  ------------------
 5434|     91|		    (UPP(8) == 'E')) {
  ------------------
  |  |  287|     18|#define UPP(val) (toupper(ctxt->input->cur[(val)]))
  ------------------
  |  Branch (5434:7): [True: 18, False: 0]
  ------------------
 5435|     18|		    if ((!terminate) &&
  ------------------
  |  Branch (5435:11): [True: 18, False: 0]
  ------------------
 5436|     18|		        (htmlParseLookupSequence(ctxt, '>', 0, 0, 1) < 0))
  ------------------
  |  Branch (5436:11): [True: 0, False: 18]
  ------------------
 5437|      0|			goto done;
 5438|     18|		    htmlParseDocTypeDecl(ctxt);
 5439|     18|                    if (ctxt->instate == XML_PARSER_EOF)
  ------------------
  |  Branch (5439:25): [True: 0, False: 18]
  ------------------
 5440|      0|                        goto done;
 5441|     18|		    ctxt->instate = XML_PARSER_PROLOG;
 5442|     73|                } else {
 5443|     73|		    ctxt->instate = XML_PARSER_MISC;
 5444|     73|		}
 5445|     91|		break;
 5446|     91|            case XML_PARSER_MISC:
  ------------------
  |  Branch (5446:13): [True: 86, False: 31.2k]
  ------------------
 5447|     86|		SKIP_BLANKS;
  ------------------
  |  |  300|     86|#define SKIP_BLANKS htmlSkipBlankChars(ctxt)
  ------------------
 5448|     86|                avail = in->end - in->cur;
 5449|       |		/*
 5450|       |		 * no chars in buffer
 5451|       |		 */
 5452|     86|		if (avail < 1)
  ------------------
  |  Branch (5452:7): [True: 0, False: 86]
  ------------------
 5453|      0|		    goto done;
 5454|       |		/*
 5455|       |		 * not enough chars in buffer
 5456|       |		 */
 5457|     86|		if (avail < 2) {
  ------------------
  |  Branch (5457:7): [True: 2, False: 84]
  ------------------
 5458|      2|		    if (!terminate)
  ------------------
  |  Branch (5458:11): [True: 1, False: 1]
  ------------------
 5459|      1|			goto done;
 5460|      1|		    else
 5461|      1|			next = ' ';
 5462|     84|		} else {
 5463|     84|		    next = in->cur[1];
 5464|     84|		}
 5465|     85|		cur = in->cur[0];
 5466|     85|	        if ((cur == '<') && (next == '!') &&
  ------------------
  |  Branch (5466:14): [True: 75, False: 10]
  |  Branch (5466:30): [True: 13, False: 62]
  ------------------
 5467|     85|		    (in->cur[2] == '-') && (in->cur[3] == '-')) {
  ------------------
  |  Branch (5467:7): [True: 13, False: 0]
  |  Branch (5467:30): [True: 13, False: 0]
  ------------------
 5468|     13|		    if ((!terminate) && (htmlParseLookupCommentEnd(ctxt) < 0))
  ------------------
  |  Branch (5468:11): [True: 10, False: 3]
  |  Branch (5468:27): [True: 6, False: 4]
  ------------------
 5469|      6|			goto done;
 5470|      7|		    htmlParseComment(ctxt);
 5471|      7|                    if (ctxt->instate == XML_PARSER_EOF)
  ------------------
  |  Branch (5471:25): [True: 0, False: 7]
  ------------------
 5472|      0|                        goto done;
 5473|      7|		    ctxt->instate = XML_PARSER_MISC;
 5474|     72|	        } else if ((cur == '<') && (next == '?')) {
  ------------------
  |  Branch (5474:21): [True: 62, False: 10]
  |  Branch (5474:37): [True: 2, False: 60]
  ------------------
 5475|      2|		    if ((!terminate) &&
  ------------------
  |  Branch (5475:11): [True: 1, False: 1]
  ------------------
 5476|      2|		        (htmlParseLookupSequence(ctxt, '>', 0, 0, 0) < 0))
  ------------------
  |  Branch (5476:11): [True: 1, False: 0]
  ------------------
 5477|      1|			goto done;
 5478|      1|		    htmlParsePI(ctxt);
 5479|      1|                    if (ctxt->instate == XML_PARSER_EOF)
  ------------------
  |  Branch (5479:25): [True: 0, False: 1]
  ------------------
 5480|      0|                        goto done;
 5481|      1|		    ctxt->instate = XML_PARSER_MISC;
 5482|     70|		} else if ((cur == '<') && (next == '!') &&
  ------------------
  |  Branch (5482:14): [True: 60, False: 10]
  |  Branch (5482:30): [True: 0, False: 60]
  ------------------
 5483|     70|		    (UPP(2) == 'D') && (UPP(3) == 'O') &&
  ------------------
  |  |  287|      0|#define UPP(val) (toupper(ctxt->input->cur[(val)]))
  ------------------
              		    (UPP(2) == 'D') && (UPP(3) == 'O') &&
  ------------------
  |  |  287|      0|#define UPP(val) (toupper(ctxt->input->cur[(val)]))
  ------------------
  |  Branch (5483:7): [True: 0, False: 0]
  |  Branch (5483:26): [True: 0, False: 0]
  ------------------
 5484|     70|		    (UPP(4) == 'C') && (UPP(5) == 'T') &&
  ------------------
  |  |  287|      0|#define UPP(val) (toupper(ctxt->input->cur[(val)]))
  ------------------
              		    (UPP(4) == 'C') && (UPP(5) == 'T') &&
  ------------------
  |  |  287|      0|#define UPP(val) (toupper(ctxt->input->cur[(val)]))
  ------------------
  |  Branch (5484:7): [True: 0, False: 0]
  |  Branch (5484:26): [True: 0, False: 0]
  ------------------
 5485|     70|		    (UPP(6) == 'Y') && (UPP(7) == 'P') &&
  ------------------
  |  |  287|      0|#define UPP(val) (toupper(ctxt->input->cur[(val)]))
  ------------------
              		    (UPP(6) == 'Y') && (UPP(7) == 'P') &&
  ------------------
  |  |  287|      0|#define UPP(val) (toupper(ctxt->input->cur[(val)]))
  ------------------
  |  Branch (5485:7): [True: 0, False: 0]
  |  Branch (5485:26): [True: 0, False: 0]
  ------------------
 5486|     70|		    (UPP(8) == 'E')) {
  ------------------
  |  |  287|      0|#define UPP(val) (toupper(ctxt->input->cur[(val)]))
  ------------------
  |  Branch (5486:7): [True: 0, False: 0]
  ------------------
 5487|      0|		    if ((!terminate) &&
  ------------------
  |  Branch (5487:11): [True: 0, False: 0]
  ------------------
 5488|      0|		        (htmlParseLookupSequence(ctxt, '>', 0, 0, 1) < 0))
  ------------------
  |  Branch (5488:11): [True: 0, False: 0]
  ------------------
 5489|      0|			goto done;
 5490|      0|		    htmlParseDocTypeDecl(ctxt);
 5491|      0|                    if (ctxt->instate == XML_PARSER_EOF)
  ------------------
  |  Branch (5491:25): [True: 0, False: 0]
  ------------------
 5492|      0|                        goto done;
 5493|      0|		    ctxt->instate = XML_PARSER_PROLOG;
 5494|     70|		} else if ((cur == '<') && (next == '!') &&
  ------------------
  |  Branch (5494:14): [True: 60, False: 10]
  |  Branch (5494:30): [True: 0, False: 60]
  ------------------
 5495|     70|		           (avail < 9)) {
  ------------------
  |  Branch (5495:14): [True: 0, False: 0]
  ------------------
 5496|      0|		    goto done;
 5497|     70|		} else {
 5498|     70|		    ctxt->instate = XML_PARSER_CONTENT;
 5499|     70|		}
 5500|     78|		break;
 5501|     78|            case XML_PARSER_PROLOG:
  ------------------
  |  Branch (5501:13): [True: 35, False: 31.3k]
  ------------------
 5502|     35|		SKIP_BLANKS;
  ------------------
  |  |  300|     35|#define SKIP_BLANKS htmlSkipBlankChars(ctxt)
  ------------------
 5503|     35|                avail = in->end - in->cur;
 5504|     35|		if (avail < 2)
  ------------------
  |  Branch (5504:7): [True: 0, False: 35]
  ------------------
 5505|      0|		    goto done;
 5506|     35|		cur = in->cur[0];
 5507|     35|		next = in->cur[1];
 5508|     35|		if ((cur == '<') && (next == '!') &&
  ------------------
  |  Branch (5508:7): [True: 35, False: 0]
  |  Branch (5508:23): [True: 15, False: 20]
  ------------------
 5509|     35|		    (in->cur[2] == '-') && (in->cur[3] == '-')) {
  ------------------
  |  Branch (5509:7): [True: 15, False: 0]
  |  Branch (5509:30): [True: 15, False: 0]
  ------------------
 5510|     15|		    if ((!terminate) && (htmlParseLookupCommentEnd(ctxt) < 0))
  ------------------
  |  Branch (5510:11): [True: 15, False: 0]
  |  Branch (5510:27): [True: 5, False: 10]
  ------------------
 5511|      5|			goto done;
 5512|     10|		    htmlParseComment(ctxt);
 5513|     10|                    if (ctxt->instate == XML_PARSER_EOF)
  ------------------
  |  Branch (5513:25): [True: 0, False: 10]
  ------------------
 5514|      0|                        goto done;
 5515|     10|		    ctxt->instate = XML_PARSER_PROLOG;
 5516|     20|	        } else if ((cur == '<') && (next == '?')) {
  ------------------
  |  Branch (5516:21): [True: 20, False: 0]
  |  Branch (5516:37): [True: 2, False: 18]
  ------------------
 5517|      2|		    if ((!terminate) &&
  ------------------
  |  Branch (5517:11): [True: 2, False: 0]
  ------------------
 5518|      2|		        (htmlParseLookupSequence(ctxt, '>', 0, 0, 0) < 0))
  ------------------
  |  Branch (5518:11): [True: 1, False: 1]
  ------------------
 5519|      1|			goto done;
 5520|      1|		    htmlParsePI(ctxt);
 5521|      1|                    if (ctxt->instate == XML_PARSER_EOF)
  ------------------
  |  Branch (5521:25): [True: 0, False: 1]
  ------------------
 5522|      0|                        goto done;
 5523|      1|		    ctxt->instate = XML_PARSER_PROLOG;
 5524|     18|		} else if ((cur == '<') && (next == '!') &&
  ------------------
  |  Branch (5524:14): [True: 18, False: 0]
  |  Branch (5524:30): [True: 0, False: 18]
  ------------------
 5525|     18|		           (avail < 4)) {
  ------------------
  |  Branch (5525:14): [True: 0, False: 0]
  ------------------
 5526|      0|		    goto done;
 5527|     18|		} else {
 5528|     18|		    ctxt->instate = XML_PARSER_CONTENT;
 5529|     18|		}
 5530|     29|		break;
 5531|     61|            case XML_PARSER_EPILOG:
  ------------------
  |  Branch (5531:13): [True: 61, False: 31.3k]
  ------------------
 5532|     61|                avail = in->end - in->cur;
 5533|     61|		if (avail < 1)
  ------------------
  |  Branch (5533:7): [True: 0, False: 61]
  ------------------
 5534|      0|		    goto done;
 5535|     61|		cur = in->cur[0];
 5536|     61|		if (IS_BLANK_CH(cur)) {
  ------------------
  |  |  151|     61|#define IS_BLANK_CH(c)  xmlIsBlank_ch(c)
  |  |  ------------------
  |  |  |  |   88|     61|#define xmlIsBlank_ch(c)	(((c) == 0x20) || \
  |  |  |  |  ------------------
  |  |  |  |  |  Branch (88:27): [True: 1, False: 60]
  |  |  |  |  ------------------
  |  |  |  |   89|     61|				 ((0x9 <= (c)) && ((c) <= 0xa)) || \
  |  |  |  |  ------------------
  |  |  |  |  |  Branch (89:7): [True: 60, False: 0]
  |  |  |  |  |  Branch (89:23): [True: 48, False: 12]
  |  |  |  |  ------------------
  |  |  |  |   90|     61|				 ((c) == 0xd))
  |  |  |  |  ------------------
  |  |  |  |  |  Branch (90:6): [True: 10, False: 2]
  |  |  |  |  ------------------
  |  |  ------------------
  ------------------
 5537|     59|		    htmlParseCharData(ctxt);
 5538|     59|		    goto done;
 5539|     59|		}
 5540|      2|		if (avail < 2)
  ------------------
  |  Branch (5540:7): [True: 0, False: 2]
  ------------------
 5541|      0|		    goto done;
 5542|      2|		next = in->cur[1];
 5543|      2|	        if ((cur == '<') && (next == '!') &&
  ------------------
  |  Branch (5543:14): [True: 0, False: 2]
  |  Branch (5543:30): [True: 0, False: 0]
  ------------------
 5544|      2|		    (in->cur[2] == '-') && (in->cur[3] == '-')) {
  ------------------
  |  Branch (5544:7): [True: 0, False: 0]
  |  Branch (5544:30): [True: 0, False: 0]
  ------------------
 5545|      0|		    if ((!terminate) && (htmlParseLookupCommentEnd(ctxt) < 0))
  ------------------
  |  Branch (5545:11): [True: 0, False: 0]
  |  Branch (5545:27): [True: 0, False: 0]
  ------------------
 5546|      0|			goto done;
 5547|      0|		    htmlParseComment(ctxt);
 5548|      0|                    if (ctxt->instate == XML_PARSER_EOF)
  ------------------
  |  Branch (5548:25): [True: 0, False: 0]
  ------------------
 5549|      0|                        goto done;
 5550|      0|		    ctxt->instate = XML_PARSER_EPILOG;
 5551|      2|	        } else if ((cur == '<') && (next == '?')) {
  ------------------
  |  Branch (5551:21): [True: 0, False: 2]
  |  Branch (5551:37): [True: 0, False: 0]
  ------------------
 5552|      0|		    if ((!terminate) &&
  ------------------
  |  Branch (5552:11): [True: 0, False: 0]
  ------------------
 5553|      0|		        (htmlParseLookupSequence(ctxt, '>', 0, 0, 0) < 0))
  ------------------
  |  Branch (5553:11): [True: 0, False: 0]
  ------------------
 5554|      0|			goto done;
 5555|      0|		    htmlParsePI(ctxt);
 5556|      0|                    if (ctxt->instate == XML_PARSER_EOF)
  ------------------
  |  Branch (5556:25): [True: 0, False: 0]
  ------------------
 5557|      0|                        goto done;
 5558|      0|		    ctxt->instate = XML_PARSER_EPILOG;
 5559|      2|		} else if ((cur == '<') && (next == '!') &&
  ------------------
  |  Branch (5559:14): [True: 0, False: 2]
  |  Branch (5559:30): [True: 0, False: 0]
  ------------------
 5560|      2|		           (avail < 4)) {
  ------------------
  |  Branch (5560:14): [True: 0, False: 0]
  ------------------
 5561|      0|		    goto done;
 5562|      2|		} else {
 5563|      2|		    ctxt->errNo = XML_ERR_DOCUMENT_END;
 5564|      2|		    ctxt->wellFormed = 0;
 5565|      2|		    ctxt->instate = XML_PARSER_EOF;
 5566|      2|		    if ((ctxt->sax) && (ctxt->sax->endDocument != NULL))
  ------------------
  |  Branch (5566:11): [True: 2, False: 0]
  |  Branch (5566:26): [True: 2, False: 0]
  ------------------
 5567|      2|			ctxt->sax->endDocument(ctxt->userData);
 5568|      2|		    goto done;
 5569|      2|		}
 5570|      0|		break;
 5571|  8.50k|            case XML_PARSER_START_TAG: {
  ------------------
  |  Branch (5571:13): [True: 8.50k, False: 22.8k]
  ------------------
 5572|  8.50k|	        const xmlChar *name;
 5573|  8.50k|		int failed;
 5574|  8.50k|		const htmlElemDesc * info;
 5575|       |
 5576|       |		/*
 5577|       |		 * no chars in buffer
 5578|       |		 */
 5579|  8.50k|		if (avail < 1)
  ------------------
  |  Branch (5579:7): [True: 0, False: 8.50k]
  ------------------
 5580|      0|		    goto done;
 5581|       |		/*
 5582|       |		 * not enough chars in buffer
 5583|       |		 */
 5584|  8.50k|		if (avail < 2) {
  ------------------
  |  Branch (5584:7): [True: 0, False: 8.50k]
  ------------------
 5585|      0|		    if (!terminate)
  ------------------
  |  Branch (5585:11): [True: 0, False: 0]
  ------------------
 5586|      0|			goto done;
 5587|      0|		    else
 5588|      0|			next = ' ';
 5589|  8.50k|		} else {
 5590|  8.50k|		    next = in->cur[1];
 5591|  8.50k|		}
 5592|  8.50k|		cur = in->cur[0];
 5593|  8.50k|	        if (cur != '<') {
  ------------------
  |  Branch (5593:14): [True: 0, False: 8.50k]
  ------------------
 5594|      0|		    ctxt->instate = XML_PARSER_CONTENT;
 5595|      0|		    break;
 5596|      0|		}
 5597|  8.50k|		if (next == '/') {
  ------------------
  |  Branch (5597:7): [True: 0, False: 8.50k]
  ------------------
 5598|      0|		    ctxt->instate = XML_PARSER_END_TAG;
 5599|      0|		    ctxt->checkIndex = 0;
 5600|      0|		    break;
 5601|      0|		}
 5602|  8.50k|		if ((!terminate) &&
  ------------------
  |  Branch (5602:7): [True: 8.19k, False: 311]
  ------------------
 5603|  8.50k|		    (htmlParseLookupSequence(ctxt, '>', 0, 0, 1) < 0))
  ------------------
  |  Branch (5603:7): [True: 1.77k, False: 6.42k]
  ------------------
 5604|  1.77k|		    goto done;
 5605|       |
 5606|       |                /* Capture start position */
 5607|  6.73k|	        if (ctxt->record_info) {
  ------------------
  |  Branch (5607:14): [True: 0, False: 6.73k]
  ------------------
 5608|      0|	             node_info.begin_pos = ctxt->input->consumed +
 5609|      0|	                                (CUR_PTR - ctxt->input->base);
  ------------------
  |  |  289|      0|#define CUR_PTR ctxt->input->cur
  ------------------
 5610|      0|	             node_info.begin_line = ctxt->input->line;
 5611|      0|	        }
 5612|       |
 5613|       |
 5614|  6.73k|		failed = htmlParseStartTag(ctxt);
 5615|  6.73k|		name = ctxt->name;
 5616|  6.73k|		if ((failed == -1) ||
  ------------------
  |  Branch (5616:7): [True: 0, False: 6.73k]
  ------------------
 5617|  6.73k|		    (name == NULL)) {
  ------------------
  |  Branch (5617:7): [True: 0, False: 6.73k]
  ------------------
 5618|      0|		    if (CUR == '>')
  ------------------
  |  |  304|      0|#define CUR (*ctxt->input->cur)
  ------------------
  |  Branch (5618:11): [True: 0, False: 0]
  ------------------
 5619|      0|			NEXT;
  ------------------
  |  |  305|      0|#define NEXT xmlNextChar(ctxt)
  ------------------
 5620|      0|		    break;
 5621|      0|		}
 5622|       |
 5623|       |		/*
 5624|       |		 * Lookup the info for that element.
 5625|       |		 */
 5626|  6.73k|		info = htmlTagLookup(name);
 5627|  6.73k|		if (info == NULL) {
  ------------------
  |  Branch (5627:7): [True: 16, False: 6.71k]
  ------------------
 5628|     16|		    htmlParseErr(ctxt, XML_HTML_UNKNOWN_TAG,
 5629|     16|		                 "Tag %s invalid\n", name, NULL);
 5630|     16|		}
 5631|       |
 5632|       |		/*
 5633|       |		 * Check for an Empty Element labeled the XML/SGML way
 5634|       |		 */
 5635|  6.73k|		if ((CUR == '/') && (NXT(1) == '>')) {
  ------------------
  |  |  304|  6.73k|#define CUR (*ctxt->input->cur)
  ------------------
              		if ((CUR == '/') && (NXT(1) == '>')) {
  ------------------
  |  |  285|      9|#define NXT(val) ctxt->input->cur[(val)]
  ------------------
  |  Branch (5635:7): [True: 9, False: 6.72k]
  |  Branch (5635:23): [True: 9, False: 0]
  ------------------
 5636|      9|		    SKIP(2);
  ------------------
  |  |  283|      9|#define SKIP(val) ctxt->input->cur += (val),ctxt->input->col+=(val)
  ------------------
 5637|      9|		    if ((ctxt->sax != NULL) && (ctxt->sax->endElement != NULL))
  ------------------
  |  Branch (5637:11): [True: 9, False: 0]
  |  Branch (5637:34): [True: 9, False: 0]
  ------------------
 5638|      9|			ctxt->sax->endElement(ctxt->userData, name);
 5639|      9|		    htmlnamePop(ctxt);
 5640|      9|                    if (ctxt->instate == XML_PARSER_EOF)
  ------------------
  |  Branch (5640:25): [True: 0, False: 9]
  ------------------
 5641|      0|                        goto done;
 5642|      9|		    ctxt->instate = XML_PARSER_CONTENT;
 5643|      9|		    break;
 5644|      9|		}
 5645|       |
 5646|  6.72k|		if (CUR == '>') {
  ------------------
  |  |  304|  6.72k|#define CUR (*ctxt->input->cur)
  ------------------
  |  Branch (5646:7): [True: 6.72k, False: 4]
  ------------------
 5647|  6.72k|		    NEXT;
  ------------------
  |  |  305|  6.72k|#define NEXT xmlNextChar(ctxt)
  ------------------
 5648|  6.72k|		} else {
 5649|      4|		    htmlParseErr(ctxt, XML_ERR_GT_REQUIRED,
 5650|      4|		                 "Couldn't find end of Start Tag %s\n",
 5651|      4|				 name, NULL);
 5652|       |
 5653|       |		    /*
 5654|       |		     * end of parsing of this node.
 5655|       |		     */
 5656|      4|		    if (xmlStrEqual(name, ctxt->name)) {
  ------------------
  |  Branch (5656:11): [True: 4, False: 0]
  ------------------
 5657|      4|			nodePop(ctxt);
 5658|      4|			htmlnamePop(ctxt);
 5659|      4|		    }
 5660|       |
 5661|      4|		    if (ctxt->record_info)
  ------------------
  |  Branch (5661:11): [True: 0, False: 4]
  ------------------
 5662|      0|		        htmlNodeInfoPush(ctxt, &node_info);
 5663|       |
 5664|      4|                    if (ctxt->instate == XML_PARSER_EOF)
  ------------------
  |  Branch (5664:25): [True: 0, False: 4]
  ------------------
 5665|      0|                        goto done;
 5666|      4|		    ctxt->instate = XML_PARSER_CONTENT;
 5667|      4|		    break;
 5668|      4|		}
 5669|       |
 5670|       |		/*
 5671|       |		 * Check for an Empty Element from DTD definition
 5672|       |		 */
 5673|  6.72k|		if ((info != NULL) && (info->empty)) {
  ------------------
  |  Branch (5673:7): [True: 6.70k, False: 13]
  |  Branch (5673:25): [True: 2.10k, False: 4.60k]
  ------------------
 5674|  2.10k|		    if ((ctxt->sax != NULL) && (ctxt->sax->endElement != NULL))
  ------------------
  |  Branch (5674:11): [True: 2.10k, False: 0]
  |  Branch (5674:34): [True: 2.10k, False: 0]
  ------------------
 5675|  2.10k|			ctxt->sax->endElement(ctxt->userData, name);
 5676|  2.10k|		    htmlnamePop(ctxt);
 5677|  2.10k|		}
 5678|       |
 5679|  6.72k|                if (ctxt->record_info)
  ------------------
  |  Branch (5679:21): [True: 0, False: 6.72k]
  ------------------
 5680|      0|	            htmlNodeInfoPush(ctxt, &node_info);
 5681|       |
 5682|  6.72k|                if (ctxt->instate == XML_PARSER_EOF)
  ------------------
  |  Branch (5682:21): [True: 0, False: 6.72k]
  ------------------
 5683|      0|                    goto done;
 5684|  6.72k|		ctxt->instate = XML_PARSER_CONTENT;
 5685|  6.72k|                break;
 5686|  6.72k|	    }
 5687|  18.0k|            case XML_PARSER_CONTENT: {
  ------------------
  |  Branch (5687:13): [True: 18.0k, False: 13.3k]
  ------------------
 5688|  18.0k|		xmlChar chr[2] = { 0, 0 };
 5689|       |
 5690|       |                /*
 5691|       |		 * Handle preparsed entities and charRef
 5692|       |		 */
 5693|  18.0k|		if (ctxt->token != 0) {
  ------------------
  |  Branch (5693:7): [True: 0, False: 18.0k]
  ------------------
 5694|      0|		    chr[0] = ctxt->token;
 5695|      0|		    htmlCheckParagraph(ctxt);
 5696|      0|		    if ((ctxt->sax != NULL) && (ctxt->sax->characters != NULL))
  ------------------
  |  Branch (5696:11): [True: 0, False: 0]
  |  Branch (5696:34): [True: 0, False: 0]
  ------------------
 5697|      0|			ctxt->sax->characters(ctxt->userData, chr, 1);
 5698|      0|		    ctxt->token = 0;
 5699|      0|		    ctxt->checkIndex = 0;
 5700|      0|		}
 5701|  18.0k|		if ((avail == 1) && (terminate)) {
  ------------------
  |  Branch (5701:7): [True: 158, False: 17.8k]
  |  Branch (5701:23): [True: 8, False: 150]
  ------------------
 5702|      8|		    cur = in->cur[0];
 5703|      8|		    if ((cur != '<') && (cur != '&')) {
  ------------------
  |  Branch (5703:11): [True: 8, False: 0]
  |  Branch (5703:27): [True: 8, False: 0]
  ------------------
 5704|      8|			if (ctxt->sax != NULL) {
  ------------------
  |  Branch (5704:8): [True: 8, False: 0]
  ------------------
 5705|      8|                            chr[0] = cur;
 5706|      8|			    if (IS_BLANK_CH(cur)) {
  ------------------
  |  |  151|      8|#define IS_BLANK_CH(c)  xmlIsBlank_ch(c)
  |  |  ------------------
  |  |  |  |   88|      8|#define xmlIsBlank_ch(c)	(((c) == 0x20) || \
  |  |  |  |  ------------------
  |  |  |  |  |  Branch (88:27): [True: 0, False: 8]
  |  |  |  |  ------------------
  |  |  |  |   89|      8|				 ((0x9 <= (c)) && ((c) <= 0xa)) || \
  |  |  |  |  ------------------
  |  |  |  |  |  Branch (89:7): [True: 8, False: 0]
  |  |  |  |  |  Branch (89:23): [True: 6, False: 2]
  |  |  |  |  ------------------
  |  |  |  |   90|      8|				 ((c) == 0xd))
  |  |  |  |  ------------------
  |  |  |  |  |  Branch (90:6): [True: 0, False: 2]
  |  |  |  |  ------------------
  |  |  ------------------
  ------------------
 5707|      6|				if (ctxt->keepBlanks) {
  ------------------
  |  Branch (5707:9): [True: 6, False: 0]
  ------------------
 5708|      6|				    if (ctxt->sax->characters != NULL)
  ------------------
  |  Branch (5708:13): [True: 6, False: 0]
  ------------------
 5709|      6|					ctxt->sax->characters(
 5710|      6|						ctxt->userData, chr, 1);
 5711|      6|				} else {
 5712|      0|				    if (ctxt->sax->ignorableWhitespace != NULL)
  ------------------
  |  Branch (5712:13): [True: 0, False: 0]
  ------------------
 5713|      0|					ctxt->sax->ignorableWhitespace(
 5714|      0|						ctxt->userData, chr, 1);
 5715|      0|				}
 5716|      6|			    } else {
 5717|      2|				htmlCheckParagraph(ctxt);
 5718|      2|				if (ctxt->sax->characters != NULL)
  ------------------
  |  Branch (5718:9): [True: 2, False: 0]
  ------------------
 5719|      2|				    ctxt->sax->characters(
 5720|      2|					    ctxt->userData, chr, 1);
 5721|      2|			    }
 5722|      8|			}
 5723|      8|			ctxt->token = 0;
 5724|      8|			ctxt->checkIndex = 0;
 5725|      8|			in->cur++;
 5726|      8|			break;
 5727|      8|		    }
 5728|      8|		}
 5729|  17.9k|		if (avail < 2)
  ------------------
  |  Branch (5729:7): [True: 150, False: 17.8k]
  ------------------
 5730|    150|		    goto done;
 5731|  17.8k|		cur = in->cur[0];
 5732|  17.8k|		next = in->cur[1];
 5733|  17.8k|		if ((xmlStrEqual(ctxt->name, BAD_CAST"script")) ||
  ------------------
  |  |   35|  17.8k|#define BAD_CAST (xmlChar *)
  ------------------
  |  Branch (5733:7): [True: 116, False: 17.7k]
  ------------------
 5734|  17.8k|		    (xmlStrEqual(ctxt->name, BAD_CAST"style"))) {
  ------------------
  |  |   35|  17.7k|#define BAD_CAST (xmlChar *)
  ------------------
  |  Branch (5734:7): [True: 42, False: 17.6k]
  ------------------
 5735|       |		    /*
 5736|       |		     * Handle SCRIPT/STYLE separately
 5737|       |		     */
 5738|    158|		    if (!terminate) {
  ------------------
  |  Branch (5738:11): [True: 158, False: 0]
  ------------------
 5739|    158|		        int idx;
 5740|    158|			xmlChar val;
 5741|       |
 5742|    158|			idx = htmlParseLookupSequence(ctxt, '<', '/', 0, 0);
 5743|    158|			if (idx < 0)
  ------------------
  |  Branch (5743:8): [True: 92, False: 66]
  ------------------
 5744|     92|			    goto done;
 5745|     66|		        val = in->cur[idx + 2];
 5746|     66|			if (val == 0) { /* bad cut of input */
  ------------------
  |  Branch (5746:8): [True: 0, False: 66]
  ------------------
 5747|       |                            /*
 5748|       |                             * FIXME: htmlParseScript checks for additional
 5749|       |                             * characters after '</'.
 5750|       |                             */
 5751|      0|                            ctxt->checkIndex = idx;
 5752|      0|			    goto done;
 5753|      0|                        }
 5754|     66|		    }
 5755|     66|		    htmlParseScript(ctxt);
 5756|     66|                    if (ctxt->instate == XML_PARSER_EOF)
  ------------------
  |  Branch (5756:25): [True: 0, False: 66]
  ------------------
 5757|      0|                        goto done;
 5758|     66|		    if ((cur == '<') && (next == '/')) {
  ------------------
  |  Branch (5758:11): [True: 33, False: 33]
  |  Branch (5758:27): [True: 33, False: 0]
  ------------------
 5759|     33|			ctxt->instate = XML_PARSER_END_TAG;
 5760|     33|			ctxt->checkIndex = 0;
 5761|     33|			break;
 5762|     33|		    }
 5763|  17.6k|		} else if ((cur == '<') && (next == '!')) {
  ------------------
  |  Branch (5763:14): [True: 11.5k, False: 6.16k]
  |  Branch (5763:30): [True: 378, False: 11.1k]
  ------------------
 5764|    378|                    if (avail < 4)
  ------------------
  |  Branch (5764:25): [True: 4, False: 374]
  ------------------
 5765|      4|                        goto done;
 5766|       |                    /*
 5767|       |                     * Sometimes DOCTYPE arrives in the middle of the document
 5768|       |                     */
 5769|    374|                    if ((UPP(2) == 'D') && (UPP(3) == 'O') &&
  ------------------
  |  |  287|    374|#define UPP(val) (toupper(ctxt->input->cur[(val)]))
  ------------------
                                  if ((UPP(2) == 'D') && (UPP(3) == 'O') &&
  ------------------
  |  |  287|     10|#define UPP(val) (toupper(ctxt->input->cur[(val)]))
  ------------------
  |  Branch (5769:25): [True: 10, False: 364]
  |  Branch (5769:44): [True: 10, False: 0]
  ------------------
 5770|    374|                        (UPP(4) == 'C') && (UPP(5) == 'T') &&
  ------------------
  |  |  287|     10|#define UPP(val) (toupper(ctxt->input->cur[(val)]))
  ------------------
                                      (UPP(4) == 'C') && (UPP(5) == 'T') &&
  ------------------
  |  |  287|     10|#define UPP(val) (toupper(ctxt->input->cur[(val)]))
  ------------------
  |  Branch (5770:25): [True: 10, False: 0]
  |  Branch (5770:44): [True: 10, False: 0]
  ------------------
 5771|    374|                        (UPP(6) == 'Y') && (UPP(7) == 'P') &&
  ------------------
  |  |  287|     10|#define UPP(val) (toupper(ctxt->input->cur[(val)]))
  ------------------
                                      (UPP(6) == 'Y') && (UPP(7) == 'P') &&
  ------------------
  |  |  287|     10|#define UPP(val) (toupper(ctxt->input->cur[(val)]))
  ------------------
  |  Branch (5771:25): [True: 10, False: 0]
  |  Branch (5771:44): [True: 10, False: 0]
  ------------------
 5772|    374|                        (UPP(8) == 'E')) {
  ------------------
  |  |  287|     10|#define UPP(val) (toupper(ctxt->input->cur[(val)]))
  ------------------
  |  Branch (5772:25): [True: 10, False: 0]
  ------------------
 5773|     10|                        if ((!terminate) &&
  ------------------
  |  Branch (5773:29): [True: 10, False: 0]
  ------------------
 5774|     10|                            (htmlParseLookupSequence(ctxt, '>', 0, 0, 1) < 0))
  ------------------
  |  Branch (5774:29): [True: 5, False: 5]
  ------------------
 5775|      5|                            goto done;
 5776|      5|                        htmlParseErr(ctxt, XML_HTML_STRUCURE_ERROR,
 5777|      5|                                     "Misplaced DOCTYPE declaration\n",
 5778|      5|                                     BAD_CAST "DOCTYPE" , NULL);
  ------------------
  |  |   35|      5|#define BAD_CAST (xmlChar *)
  ------------------
 5779|      5|                        htmlParseDocTypeDecl(ctxt);
 5780|    364|                    } else if ((in->cur[2] == '-') && (in->cur[3] == '-')) {
  ------------------
  |  Branch (5780:32): [True: 358, False: 6]
  |  Branch (5780:55): [True: 358, False: 0]
  ------------------
 5781|    358|                        if ((!terminate) &&
  ------------------
  |  Branch (5781:29): [True: 338, False: 20]
  ------------------
 5782|    358|                            (htmlParseLookupCommentEnd(ctxt) < 0))
  ------------------
  |  Branch (5782:29): [True: 95, False: 243]
  ------------------
 5783|     95|                            goto done;
 5784|    263|                        htmlParseComment(ctxt);
 5785|    263|                        if (ctxt->instate == XML_PARSER_EOF)
  ------------------
  |  Branch (5785:29): [True: 0, False: 263]
  ------------------
 5786|      0|                            goto done;
 5787|    263|                        ctxt->instate = XML_PARSER_CONTENT;
 5788|    263|                    } else {
 5789|      6|                        if ((!terminate) &&
  ------------------
  |  Branch (5789:29): [True: 6, False: 0]
  ------------------
 5790|      6|                            (htmlParseLookupSequence(ctxt, '>', 0, 0, 0) < 0))
  ------------------
  |  Branch (5790:29): [True: 0, False: 6]
  ------------------
 5791|      0|                            goto done;
 5792|      6|                        htmlSkipBogusComment(ctxt);
 5793|      6|                    }
 5794|  17.3k|                } else if ((cur == '<') && (next == '?')) {
  ------------------
  |  Branch (5794:28): [True: 11.1k, False: 6.16k]
  |  Branch (5794:44): [True: 0, False: 11.1k]
  ------------------
 5795|      0|                    if ((!terminate) &&
  ------------------
  |  Branch (5795:25): [True: 0, False: 0]
  ------------------
 5796|      0|                        (htmlParseLookupSequence(ctxt, '>', 0, 0, 0) < 0))
  ------------------
  |  Branch (5796:25): [True: 0, False: 0]
  ------------------
 5797|      0|                        goto done;
 5798|      0|                    htmlParsePI(ctxt);
 5799|      0|                    if (ctxt->instate == XML_PARSER_EOF)
  ------------------
  |  Branch (5799:25): [True: 0, False: 0]
  ------------------
 5800|      0|                        goto done;
 5801|      0|                    ctxt->instate = XML_PARSER_CONTENT;
 5802|  17.3k|                } else if ((cur == '<') && (next == '/')) {
  ------------------
  |  Branch (5802:28): [True: 11.1k, False: 6.16k]
  |  Branch (5802:44): [True: 4.41k, False: 6.73k]
  ------------------
 5803|  4.41k|                    ctxt->instate = XML_PARSER_END_TAG;
 5804|  4.41k|                    ctxt->checkIndex = 0;
 5805|  4.41k|                    break;
 5806|  12.9k|                } else if ((cur == '<') && IS_ASCII_LETTER(next)) {
  ------------------
  |  |  258|  6.73k|#define IS_ASCII_LETTER(c)	(((0x41 <= (c)) && ((c) <= 0x5a)) || \
  |  |  ------------------
  |  |  |  Branch (258:30): [True: 6.73k, False: 0]
  |  |  |  Branch (258:47): [True: 3.19k, False: 3.53k]
  |  |  ------------------
  |  |  259|  6.73k|				 ((0x61 <= (c)) && ((c) <= 0x7a)))
  |  |  ------------------
  |  |  |  Branch (259:7): [True: 3.53k, False: 1]
  |  |  |  Branch (259:24): [True: 3.53k, False: 2]
  |  |  ------------------
  ------------------
  |  Branch (5806:28): [True: 6.73k, False: 6.16k]
  ------------------
 5807|  6.73k|                    if ((!terminate) && (next == 0))
  ------------------
  |  Branch (5807:25): [True: 6.42k, False: 310]
  |  Branch (5807:41): [True: 0, False: 6.42k]
  ------------------
 5808|      0|                        goto done;
 5809|  6.73k|                    ctxt->instate = XML_PARSER_START_TAG;
 5810|  6.73k|                    ctxt->checkIndex = 0;
 5811|  6.73k|                    break;
 5812|  6.73k|                } else if (cur == '<') {
  ------------------
  |  Branch (5812:28): [True: 3, False: 6.16k]
  ------------------
 5813|      3|                    if ((ctxt->sax != NULL) && (!ctxt->disableSAX) &&
  ------------------
  |  Branch (5813:25): [True: 3, False: 0]
  |  Branch (5813:48): [True: 3, False: 0]
  ------------------
 5814|      3|                        (ctxt->sax->characters != NULL))
  ------------------
  |  Branch (5814:25): [True: 3, False: 0]
  ------------------
 5815|      3|                        ctxt->sax->characters(ctxt->userData,
 5816|      3|                                              BAD_CAST "<", 1);
  ------------------
  |  |   35|      3|#define BAD_CAST (xmlChar *)
  ------------------
 5817|      3|                    NEXT;
  ------------------
  |  |  305|      3|#define NEXT xmlNextChar(ctxt)
  ------------------
 5818|  6.16k|                } else {
 5819|       |                    /*
 5820|       |                     * check that the text sequence is complete
 5821|       |                     * before handing out the data to the parser
 5822|       |                     * to avoid problems with erroneous end of
 5823|       |                     * data detection.
 5824|       |                     */
 5825|  6.16k|                    if ((!terminate) &&
  ------------------
  |  Branch (5825:25): [True: 5.97k, False: 195]
  ------------------
 5826|  6.16k|                        (htmlParseLookupSequence(ctxt, '<', 0, 0, 0) < 0))
  ------------------
  |  Branch (5826:25): [True: 835, False: 5.13k]
  ------------------
 5827|    835|                        goto done;
 5828|  5.33k|                    ctxt->checkIndex = 0;
 5829|  11.3k|                    while ((ctxt->instate != XML_PARSER_EOF) &&
  ------------------
  |  Branch (5829:28): [True: 11.3k, False: 3]
  ------------------
 5830|  11.3k|                           (cur != '<') && (in->cur < in->end)) {
  ------------------
  |  Branch (5830:28): [True: 6.02k, False: 5.31k]
  |  Branch (5830:44): [True: 6.00k, False: 14]
  ------------------
 5831|  6.00k|                        if (cur == '&') {
  ------------------
  |  Branch (5831:29): [True: 546, False: 5.46k]
  ------------------
 5832|    546|                            htmlParseReference(ctxt);
 5833|  5.46k|                        } else {
 5834|  5.46k|                            htmlParseCharData(ctxt);
 5835|  5.46k|                        }
 5836|  6.00k|                        cur = in->cur[0];
 5837|  6.00k|                    }
 5838|  5.33k|		}
 5839|       |
 5840|  5.64k|		break;
 5841|  17.8k|	    }
 5842|  5.64k|            case XML_PARSER_END_TAG:
  ------------------
  |  Branch (5842:13): [True: 4.57k, False: 26.7k]
  ------------------
 5843|  4.57k|		if (avail < 2)
  ------------------
  |  Branch (5843:7): [True: 0, False: 4.57k]
  ------------------
 5844|      0|		    goto done;
 5845|  4.57k|		if ((!terminate) &&
  ------------------
  |  Branch (5845:7): [True: 4.38k, False: 189]
  ------------------
 5846|  4.57k|		    (htmlParseLookupSequence(ctxt, '>', 0, 0, 0) < 0))
  ------------------
  |  Branch (5846:7): [True: 127, False: 4.25k]
  ------------------
 5847|    127|		    goto done;
 5848|  4.44k|		htmlParseEndTag(ctxt);
 5849|  4.44k|                if (ctxt->instate == XML_PARSER_EOF)
  ------------------
  |  Branch (5849:21): [True: 0, False: 4.44k]
  ------------------
 5850|      0|                    goto done;
 5851|  4.44k|		if (ctxt->nameNr == 0) {
  ------------------
  |  Branch (5851:7): [True: 63, False: 4.38k]
  ------------------
 5852|     63|		    ctxt->instate = XML_PARSER_EPILOG;
 5853|  4.38k|		} else {
 5854|  4.38k|		    ctxt->instate = XML_PARSER_CONTENT;
 5855|  4.38k|		}
 5856|  4.44k|		ctxt->checkIndex = 0;
 5857|  4.44k|	        break;
 5858|      0|	    default:
  ------------------
  |  Branch (5858:6): [True: 0, False: 31.3k]
  ------------------
 5859|      0|		htmlParseErr(ctxt, XML_ERR_INTERNAL_ERROR,
 5860|      0|			     "HPP: internal error\n", NULL, NULL);
 5861|      0|		ctxt->instate = XML_PARSER_EOF;
 5862|      0|		break;
 5863|  31.3k|	}
 5864|  31.3k|    }
 5865|  3.34k|done:
 5866|  3.34k|    if ((avail == 0) && (terminate)) {
  ------------------
  |  Branch (5866:9): [True: 176, False: 3.16k]
  |  Branch (5866:25): [True: 87, False: 89]
  ------------------
 5867|     87|	htmlAutoCloseOnEnd(ctxt);
 5868|     87|	if ((ctxt->nameNr == 0) && (ctxt->instate != XML_PARSER_EOF)) {
  ------------------
  |  Branch (5868:6): [True: 87, False: 0]
  |  Branch (5868:29): [True: 0, False: 87]
  ------------------
 5869|       |	    /*
 5870|       |	     * SAX: end of the document processing.
 5871|       |	     */
 5872|      0|	    ctxt->instate = XML_PARSER_EOF;
 5873|      0|	    if ((ctxt->sax) && (ctxt->sax->endDocument != NULL))
  ------------------
  |  Branch (5873:10): [True: 0, False: 0]
  |  Branch (5873:25): [True: 0, False: 0]
  ------------------
 5874|      0|		ctxt->sax->endDocument(ctxt->userData);
 5875|      0|	}
 5876|     87|    }
 5877|  3.34k|    if ((!(ctxt->options & HTML_PARSE_NODEFDTD)) && (ctxt->myDoc != NULL) &&
  ------------------
  |  Branch (5877:9): [True: 3.33k, False: 7]
  |  Branch (5877:53): [True: 3.33k, False: 0]
  ------------------
 5878|  3.34k|	((terminate) || (ctxt->instate == XML_PARSER_EOF) ||
  ------------------
  |  Branch (5878:3): [True: 88, False: 3.24k]
  |  Branch (5878:18): [True: 3, False: 3.24k]
  ------------------
 5879|  3.33k|	 (ctxt->instate == XML_PARSER_EPILOG))) {
  ------------------
  |  Branch (5879:3): [True: 60, False: 3.18k]
  ------------------
 5880|    151|	xmlDtdPtr dtd;
 5881|    151|	dtd = xmlGetIntSubset(ctxt->myDoc);
 5882|    151|	if (dtd == NULL)
  ------------------
  |  Branch (5882:6): [True: 71, False: 80]
  ------------------
 5883|     71|	    ctxt->myDoc->intSubset =
 5884|     71|		xmlCreateIntSubset(ctxt->myDoc, BAD_CAST "html",
  ------------------
  |  |   35|     71|#define BAD_CAST (xmlChar *)
  ------------------
 5885|     71|		    BAD_CAST "-//W3C//DTD HTML 4.0 Transitional//EN",
  ------------------
  |  |   35|     71|#define BAD_CAST (xmlChar *)
  ------------------
 5886|     71|		    BAD_CAST "http://www.w3.org/TR/REC-html40/loose.dtd");
  ------------------
  |  |   35|     71|#define BAD_CAST (xmlChar *)
  ------------------
 5887|    151|    }
 5888|  3.34k|    return(ret);
 5889|  3.34k|}
HTMLparser.c:htmlParseLookupSequence:
 5260|  19.3k|{
 5261|  19.3k|    size_t base, len;
 5262|  19.3k|    htmlParserInputPtr in;
 5263|  19.3k|    const xmlChar *buf;
 5264|  19.3k|    int quote;
 5265|       |
 5266|  19.3k|    in = ctxt->input;
 5267|  19.3k|    if (in == NULL)
  ------------------
  |  Branch (5267:9): [True: 0, False: 19.3k]
  ------------------
 5268|      0|        return (-1);
 5269|       |
 5270|  19.3k|    base = ctxt->checkIndex;
 5271|  19.3k|    quote = ctxt->endCheckState;
 5272|       |
 5273|  19.3k|    buf = in->cur;
 5274|  19.3k|    len = in->end - in->cur;
 5275|       |
 5276|       |    /* take into account the sequence length */
 5277|  19.3k|    if (third)
  ------------------
  |  Branch (5277:9): [True: 0, False: 19.3k]
  ------------------
 5278|      0|        len -= 2;
 5279|  19.3k|    else if (next)
  ------------------
  |  Branch (5279:14): [True: 812, False: 18.5k]
  ------------------
 5280|    812|        len--;
 5281|   432k|    for (; base < len; base++) {
  ------------------
  |  Branch (5281:12): [True: 429k, False: 2.94k]
  ------------------
 5282|   429k|        if (base >= INT_MAX / 2) {
  ------------------
  |  Branch (5282:13): [True: 0, False: 429k]
  ------------------
 5283|      0|            ctxt->checkIndex = 0;
 5284|      0|            ctxt->endCheckState = 0;
 5285|      0|            return (base - 2);
 5286|      0|        }
 5287|   429k|        if (ignoreattrval) {
  ------------------
  |  Branch (5287:13): [True: 255k, False: 174k]
  ------------------
 5288|   255k|            if (quote) {
  ------------------
  |  Branch (5288:17): [True: 133k, False: 121k]
  ------------------
 5289|   133k|                if (buf[base] == quote)
  ------------------
  |  Branch (5289:21): [True: 4.09k, False: 129k]
  ------------------
 5290|  4.09k|                    quote = 0;
 5291|   133k|                continue;
 5292|   133k|            }
 5293|   121k|            if (buf[base] == '"' || buf[base] == '\'') {
  ------------------
  |  Branch (5293:17): [True: 4.07k, False: 117k]
  |  Branch (5293:37): [True: 17, False: 117k]
  ------------------
 5294|  4.09k|                quote = buf[base];
 5295|  4.09k|                continue;
 5296|  4.09k|            }
 5297|   121k|        }
 5298|   292k|        if (buf[base] == first) {
  ------------------
  |  Branch (5298:13): [True: 16.8k, False: 275k]
  ------------------
 5299|  16.8k|            if (third != 0) {
  ------------------
  |  Branch (5299:17): [True: 0, False: 16.8k]
  ------------------
 5300|      0|                if ((buf[base + 1] != next) || (buf[base + 2] != third))
  ------------------
  |  Branch (5300:21): [True: 0, False: 0]
  |  Branch (5300:48): [True: 0, False: 0]
  ------------------
 5301|      0|                    continue;
 5302|  16.8k|            } else if (next != 0) {
  ------------------
  |  Branch (5302:24): [True: 981, False: 15.8k]
  ------------------
 5303|    981|                if (buf[base + 1] != next)
  ------------------
  |  Branch (5303:21): [True: 366, False: 615]
  ------------------
 5304|    366|                    continue;
 5305|    981|            }
 5306|  16.4k|            ctxt->checkIndex = 0;
 5307|  16.4k|            ctxt->endCheckState = 0;
 5308|  16.4k|            return (base);
 5309|  16.8k|        }
 5310|   292k|    }
 5311|  2.94k|    ctxt->checkIndex = base;
 5312|  2.94k|    ctxt->endCheckState = quote;
 5313|  2.94k|    return (-1);
 5314|  19.3k|}
HTMLparser.c:htmlParseLookupCommentEnd:
 5332|    363|{
 5333|    363|    int mark = 0;
 5334|    363|    int offset;
 5335|       |
 5336|    654|    while (1) {
  ------------------
  |  Branch (5336:12): [Folded - Ignored]
  ------------------
 5337|    654|	mark = htmlParseLookupSequence(ctxt, '-', '-', 0, 0);
 5338|    654|	if (mark < 0)
  ------------------
  |  Branch (5338:6): [True: 105, False: 549]
  ------------------
 5339|    105|            break;
 5340|    549|        if ((NXT(mark+2) == '>') ||
  ------------------
  |  |  285|    549|#define NXT(val) ctxt->input->cur[(val)]
  ------------------
  |  Branch (5340:13): [True: 254, False: 295]
  ------------------
 5341|    549|	    ((NXT(mark+2) == '!') && (NXT(mark+3) == '>'))) {
  ------------------
  |  |  285|    295|#define NXT(val) ctxt->input->cur[(val)]
  ------------------
              	    ((NXT(mark+2) == '!') && (NXT(mark+3) == '>'))) {
  ------------------
  |  |  285|      3|#define NXT(val) ctxt->input->cur[(val)]
  ------------------
  |  Branch (5341:7): [True: 3, False: 292]
  |  Branch (5341:31): [True: 3, False: 0]
  ------------------
 5342|    257|            ctxt->checkIndex = 0;
 5343|    257|	    break;
 5344|    257|	}
 5345|    292|        offset = (NXT(mark+2) == '!') ? 3 : 2;
  ------------------
  |  |  285|    292|#define NXT(val) ctxt->input->cur[(val)]
  ------------------
  |  Branch (5345:18): [True: 0, False: 292]
  ------------------
 5346|    292|        if (mark + offset >= ctxt->input->end - ctxt->input->cur) {
  ------------------
  |  Branch (5346:13): [True: 1, False: 291]
  ------------------
 5347|      1|	    ctxt->checkIndex = mark;
 5348|      1|            return(-1);
 5349|      1|        }
 5350|    291|	ctxt->checkIndex = mark + 1;
 5351|    291|    }
 5352|    362|    return mark;
 5353|    363|}
HTMLparser.c:htmlNewInputStream:
 2310|     92|htmlNewInputStream(htmlParserCtxtPtr ctxt) {
 2311|     92|    htmlParserInputPtr input;
 2312|       |
 2313|     92|    input = (xmlParserInputPtr) xmlMalloc(sizeof(htmlParserInput));
 2314|     92|    if (input == NULL) {
  ------------------
  |  Branch (2314:9): [True: 0, False: 92]
  ------------------
 2315|      0|        htmlErrMemory(ctxt, "couldn't allocate a new input stream\n");
 2316|      0|	return(NULL);
 2317|      0|    }
 2318|     92|    memset(input, 0, sizeof(htmlParserInput));
 2319|     92|    input->filename = NULL;
 2320|     92|    input->directory = NULL;
 2321|     92|    input->base = NULL;
 2322|     92|    input->cur = NULL;
 2323|     92|    input->buf = NULL;
 2324|     92|    input->line = 1;
 2325|     92|    input->col = 1;
 2326|     92|    input->buf = NULL;
 2327|     92|    input->free = NULL;
 2328|     92|    input->version = NULL;
 2329|     92|    input->consumed = 0;
 2330|     92|    input->length = 0;
 2331|     92|    return(input);
 2332|     92|}
HTMLparser.c:htmlDoRead:
 6529|     91|{
 6530|     91|    htmlDocPtr ret;
 6531|       |
 6532|     91|    htmlCtxtUseOptions(ctxt, options);
 6533|     91|    ctxt->html = 1;
 6534|     91|    if (encoding != NULL) {
  ------------------
  |  Branch (6534:9): [True: 0, False: 91]
  ------------------
 6535|      0|        xmlCharEncodingHandlerPtr hdlr;
 6536|       |
 6537|      0|	hdlr = xmlFindCharEncodingHandler(encoding);
 6538|      0|	if (hdlr != NULL) {
  ------------------
  |  Branch (6538:6): [True: 0, False: 0]
  ------------------
 6539|      0|	    xmlSwitchToEncoding(ctxt, hdlr);
 6540|      0|        }
 6541|      0|    }
 6542|     91|    if ((URL != NULL) && (ctxt->input != NULL) &&
  ------------------
  |  Branch (6542:9): [True: 0, False: 91]
  |  Branch (6542:26): [True: 0, False: 0]
  ------------------
 6543|     91|        (ctxt->input->filename == NULL))
  ------------------
  |  Branch (6543:9): [True: 0, False: 0]
  ------------------
 6544|      0|        ctxt->input->filename = (char *) xmlStrdup((const xmlChar *) URL);
 6545|     91|    htmlParseDocument(ctxt);
 6546|     91|    ret = ctxt->myDoc;
 6547|     91|    ctxt->myDoc = NULL;
 6548|     91|    if (!reuse) {
  ------------------
  |  Branch (6548:9): [True: 91, False: 0]
  ------------------
 6549|     91|        if ((ctxt->dictNames) &&
  ------------------
  |  Branch (6549:13): [True: 0, False: 91]
  ------------------
 6550|     91|	    (ret != NULL) &&
  ------------------
  |  Branch (6550:6): [True: 0, False: 0]
  ------------------
 6551|     91|	    (ret->dict == ctxt->dict))
  ------------------
  |  Branch (6551:6): [True: 0, False: 0]
  ------------------
 6552|      0|	    ctxt->dict = NULL;
 6553|     91|	xmlFreeParserCtxt(ctxt);
 6554|     91|    }
 6555|     91|    return (ret);
 6556|     91|}

htmlIsBooleanAttr:
  320|  6.75k|{
  321|  6.75k|    int i = 0;
  322|       |
  323|  94.3k|    while (htmlBooleanAttrs[i] != NULL) {
  ------------------
  |  Branch (323:12): [True: 87.6k, False: 6.69k]
  ------------------
  324|  87.6k|        if (xmlStrcasecmp((const xmlChar *)htmlBooleanAttrs[i], name) == 0)
  ------------------
  |  Branch (324:13): [True: 60, False: 87.6k]
  ------------------
  325|     60|            return 1;
  326|  87.6k|        i++;
  327|  87.6k|    }
  328|  6.69k|    return 0;
  329|  6.75k|}
htmlNodeDumpFormatOutput:
  740|     99|                         int format) {
  741|     99|    xmlNodePtr root, parent;
  742|     99|    xmlAttrPtr attr;
  743|     99|    const htmlElemDesc * info;
  744|       |
  745|     99|    xmlInitParser();
  746|       |
  747|     99|    if ((cur == NULL) || (buf == NULL)) {
  ------------------
  |  Branch (747:9): [True: 10, False: 89]
  |  Branch (747:26): [True: 1, False: 88]
  ------------------
  748|     11|	return;
  749|     11|    }
  750|       |
  751|     88|    root = cur;
  752|     88|    parent = cur->parent;
  753|  12.0k|    while (1) {
  ------------------
  |  Branch (753:12): [Folded - Ignored]
  ------------------
  754|  12.0k|        switch (cur->type) {
  755|     88|        case XML_HTML_DOCUMENT_NODE:
  ------------------
  |  Branch (755:9): [True: 88, False: 11.9k]
  ------------------
  756|     88|        case XML_DOCUMENT_NODE:
  ------------------
  |  Branch (756:9): [True: 0, False: 12.0k]
  ------------------
  757|     88|            if (((xmlDocPtr) cur)->intSubset != NULL) {
  ------------------
  |  Branch (757:17): [True: 87, False: 1]
  ------------------
  758|     87|                htmlDtdDumpOutput(buf, (xmlDocPtr) cur, NULL);
  759|     87|            }
  760|     88|            if (cur->children != NULL) {
  ------------------
  |  Branch (760:17): [True: 87, False: 1]
  ------------------
  761|       |                /* Always validate cur->parent when descending. */
  762|     87|                if (cur->parent == parent) {
  ------------------
  |  Branch (762:21): [True: 87, False: 0]
  ------------------
  763|     87|                    parent = cur;
  764|     87|                    cur = cur->children;
  765|     87|                    continue;
  766|     87|                }
  767|     87|            } else {
  768|      1|                xmlOutputBufferWriteString(buf, "\n");
  769|      1|            }
  770|      1|            break;
  771|       |
  772|  6.48k|        case XML_ELEMENT_NODE:
  ------------------
  |  Branch (772:9): [True: 6.48k, False: 5.55k]
  ------------------
  773|       |            /*
  774|       |             * Some users like lxml are known to pass nodes with a corrupted
  775|       |             * tree structure. Fall back to a recursive call to handle this
  776|       |             * case.
  777|       |             */
  778|  6.48k|            if ((cur->parent != parent) && (cur->children != NULL)) {
  ------------------
  |  Branch (778:17): [True: 0, False: 6.48k]
  |  Branch (778:44): [True: 0, False: 0]
  ------------------
  779|      0|                htmlNodeDumpFormatOutput(buf, doc, cur, encoding, format);
  780|      0|                break;
  781|      0|            }
  782|       |
  783|       |            /*
  784|       |             * Get specific HTML info for that node.
  785|       |             */
  786|  6.48k|            if (cur->ns == NULL)
  ------------------
  |  Branch (786:17): [True: 6.48k, False: 0]
  ------------------
  787|  6.48k|                info = htmlTagLookup(cur->name);
  788|      0|            else
  789|      0|                info = NULL;
  790|       |
  791|  6.48k|            xmlOutputBufferWriteString(buf, "<");
  792|  6.48k|            if ((cur->ns != NULL) && (cur->ns->prefix != NULL)) {
  ------------------
  |  Branch (792:17): [True: 0, False: 6.48k]
  |  Branch (792:38): [True: 0, False: 0]
  ------------------
  793|      0|                xmlOutputBufferWriteString(buf, (const char *)cur->ns->prefix);
  794|      0|                xmlOutputBufferWriteString(buf, ":");
  795|      0|            }
  796|  6.48k|            xmlOutputBufferWriteString(buf, (const char *)cur->name);
  797|  6.48k|            if (cur->nsDef)
  ------------------
  |  Branch (797:17): [True: 0, False: 6.48k]
  ------------------
  798|      0|                xmlNsListDumpOutput(buf, cur->nsDef);
  799|  6.48k|            attr = cur->properties;
  800|  13.1k|            while (attr != NULL) {
  ------------------
  |  Branch (800:20): [True: 6.71k, False: 6.48k]
  ------------------
  801|  6.71k|                htmlAttrDumpOutput(buf, doc, attr);
  802|  6.71k|                attr = attr->next;
  803|  6.71k|            }
  804|       |
  805|  6.48k|            if ((info != NULL) && (info->empty)) {
  ------------------
  |  Branch (805:17): [True: 6.46k, False: 14]
  |  Branch (805:35): [True: 1.98k, False: 4.48k]
  ------------------
  806|  1.98k|                xmlOutputBufferWriteString(buf, ">");
  807|  4.49k|            } else if (cur->children == NULL) {
  ------------------
  |  Branch (807:24): [True: 133, False: 4.36k]
  ------------------
  808|    133|                if ((info != NULL) && (info->saveEndTag != 0) &&
  ------------------
  |  Branch (808:21): [True: 127, False: 6]
  |  Branch (808:39): [True: 0, False: 127]
  ------------------
  809|    133|                    (xmlStrcmp(BAD_CAST info->name, BAD_CAST "html")) &&
  ------------------
  |  |   35|      0|#define BAD_CAST (xmlChar *)
  ------------------
                                  (xmlStrcmp(BAD_CAST info->name, BAD_CAST "html")) &&
  ------------------
  |  |   35|      0|#define BAD_CAST (xmlChar *)
  ------------------
  |  Branch (809:21): [True: 0, False: 0]
  ------------------
  810|    133|                    (xmlStrcmp(BAD_CAST info->name, BAD_CAST "body"))) {
  ------------------
  |  |   35|      0|#define BAD_CAST (xmlChar *)
  ------------------
                                  (xmlStrcmp(BAD_CAST info->name, BAD_CAST "body"))) {
  ------------------
  |  |   35|      0|#define BAD_CAST (xmlChar *)
  ------------------
  |  Branch (810:21): [True: 0, False: 0]
  ------------------
  811|      0|                    xmlOutputBufferWriteString(buf, ">");
  812|    133|                } else {
  813|    133|                    xmlOutputBufferWriteString(buf, "></");
  814|    133|                    if ((cur->ns != NULL) && (cur->ns->prefix != NULL)) {
  ------------------
  |  Branch (814:25): [True: 0, False: 133]
  |  Branch (814:46): [True: 0, False: 0]
  ------------------
  815|      0|                        xmlOutputBufferWriteString(buf,
  816|      0|                                (const char *)cur->ns->prefix);
  817|      0|                        xmlOutputBufferWriteString(buf, ":");
  818|      0|                    }
  819|    133|                    xmlOutputBufferWriteString(buf, (const char *)cur->name);
  820|    133|                    xmlOutputBufferWriteString(buf, ">");
  821|    133|                }
  822|  4.36k|            } else {
  823|  4.36k|                xmlOutputBufferWriteString(buf, ">");
  824|  4.36k|                if ((format) && (info != NULL) && (!info->isinline) &&
  ------------------
  |  Branch (824:21): [True: 4.36k, False: 0]
  |  Branch (824:33): [True: 4.35k, False: 8]
  |  Branch (824:51): [True: 1.80k, False: 2.55k]
  ------------------
  825|  4.36k|                    (cur->children->type != HTML_TEXT_NODE) &&
  ------------------
  |  |   32|  1.80k|#define HTML_TEXT_NODE		XML_TEXT_NODE
  ------------------
  |  Branch (825:21): [True: 512, False: 1.29k]
  ------------------
  826|  4.36k|                    (cur->children->type != HTML_ENTITY_REF_NODE) &&
  ------------------
  |  |   39|    512|#define HTML_ENTITY_REF_NODE	XML_ENTITY_REF_NODE
  ------------------
  |  Branch (826:21): [True: 512, False: 0]
  ------------------
  827|  4.36k|                    (cur->children != cur->last) &&
  ------------------
  |  Branch (827:21): [True: 174, False: 338]
  ------------------
  828|  4.36k|                    (cur->name != NULL) &&
  ------------------
  |  Branch (828:21): [True: 174, False: 0]
  ------------------
  829|  4.36k|                    (cur->name[0] != 'p')) /* p, pre, param */
  ------------------
  |  Branch (829:21): [True: 125, False: 49]
  ------------------
  830|    125|                    xmlOutputBufferWriteString(buf, "\n");
  831|  4.36k|                parent = cur;
  832|  4.36k|                cur = cur->children;
  833|  4.36k|                continue;
  834|  4.36k|            }
  835|       |
  836|  2.12k|            if ((format) && (cur->next != NULL) &&
  ------------------
  |  Branch (836:17): [True: 2.12k, False: 0]
  |  Branch (836:29): [True: 1.85k, False: 264]
  ------------------
  837|  2.12k|                (info != NULL) && (!info->isinline)) {
  ------------------
  |  Branch (837:17): [True: 1.85k, False: 3]
  |  Branch (837:35): [True: 129, False: 1.72k]
  ------------------
  838|    129|                if ((cur->next->type != HTML_TEXT_NODE) &&
  ------------------
  |  |   32|    129|#define HTML_TEXT_NODE		XML_TEXT_NODE
  ------------------
  |  Branch (838:21): [True: 29, False: 100]
  ------------------
  839|    129|                    (cur->next->type != HTML_ENTITY_REF_NODE) &&
  ------------------
  |  |   39|     29|#define HTML_ENTITY_REF_NODE	XML_ENTITY_REF_NODE
  ------------------
  |  Branch (839:21): [True: 29, False: 0]
  ------------------
  840|    129|                    (parent != NULL) &&
  ------------------
  |  Branch (840:21): [True: 29, False: 0]
  ------------------
  841|    129|                    (parent->name != NULL) &&
  ------------------
  |  Branch (841:21): [True: 29, False: 0]
  ------------------
  842|    129|                    (parent->name[0] != 'p')) /* p, pre, param */
  ------------------
  |  Branch (842:21): [True: 29, False: 0]
  ------------------
  843|     29|                    xmlOutputBufferWriteString(buf, "\n");
  844|    129|            }
  845|       |
  846|  2.12k|            break;
  847|       |
  848|      0|        case XML_ATTRIBUTE_NODE:
  ------------------
  |  Branch (848:9): [True: 0, False: 12.0k]
  ------------------
  849|      0|            htmlAttrDumpOutput(buf, doc, (xmlAttrPtr) cur);
  850|      0|            break;
  851|       |
  852|  5.10k|        case HTML_TEXT_NODE:
  ------------------
  |  |   32|  5.10k|#define HTML_TEXT_NODE		XML_TEXT_NODE
  ------------------
  |  Branch (852:9): [True: 5.10k, False: 6.93k]
  ------------------
  853|  5.10k|            if (cur->content == NULL)
  ------------------
  |  Branch (853:17): [True: 0, False: 5.10k]
  ------------------
  854|      0|                break;
  855|  5.10k|            if (((cur->name == (const xmlChar *)xmlStringText) ||
  ------------------
  |  Branch (855:18): [True: 5.10k, False: 0]
  ------------------
  856|  5.10k|                 (cur->name != (const xmlChar *)xmlStringTextNoenc)) &&
  ------------------
  |  Branch (856:18): [True: 0, False: 0]
  ------------------
  857|  5.10k|                ((parent == NULL) ||
  ------------------
  |  Branch (857:18): [True: 0, False: 5.10k]
  ------------------
  858|  5.10k|                 ((xmlStrcasecmp(parent->name, BAD_CAST "script")) &&
  ------------------
  |  |   35|  5.10k|#define BAD_CAST (xmlChar *)
  ------------------
  |  Branch (858:19): [True: 5.10k, False: 0]
  ------------------
  859|  5.10k|                  (xmlStrcasecmp(parent->name, BAD_CAST "style"))))) {
  ------------------
  |  |   35|  5.10k|#define BAD_CAST (xmlChar *)
  ------------------
  |  Branch (859:19): [True: 5.10k, False: 0]
  ------------------
  860|  5.10k|                xmlChar *buffer;
  861|       |
  862|  5.10k|                buffer = xmlEncodeEntitiesReentrant(doc, cur->content);
  863|  5.10k|                if (buffer != NULL) {
  ------------------
  |  Branch (863:21): [True: 5.10k, False: 0]
  ------------------
  864|  5.10k|                    xmlOutputBufferWriteString(buf, (const char *)buffer);
  865|  5.10k|                    xmlFree(buffer);
  866|  5.10k|                }
  867|  5.10k|            } else {
  868|      0|                xmlOutputBufferWriteString(buf, (const char *)cur->content);
  869|      0|            }
  870|  5.10k|            break;
  871|       |
  872|    253|        case HTML_COMMENT_NODE:
  ------------------
  |  |   46|    253|#define HTML_COMMENT_NODE	XML_COMMENT_NODE
  ------------------
  |  Branch (872:9): [True: 253, False: 11.7k]
  ------------------
  873|    253|            if (cur->content != NULL) {
  ------------------
  |  Branch (873:17): [True: 253, False: 0]
  ------------------
  874|    253|                xmlOutputBufferWriteString(buf, "<!--");
  875|    253|                xmlOutputBufferWriteString(buf, (const char *)cur->content);
  876|    253|                xmlOutputBufferWriteString(buf, "-->");
  877|    253|            }
  878|    253|            break;
  879|       |
  880|      1|        case HTML_PI_NODE:
  ------------------
  |  |   60|      1|#define HTML_PI_NODE		XML_PI_NODE
  ------------------
  |  Branch (880:9): [True: 1, False: 12.0k]
  ------------------
  881|      1|            if (cur->name != NULL) {
  ------------------
  |  Branch (881:17): [True: 1, False: 0]
  ------------------
  882|      1|                xmlOutputBufferWriteString(buf, "<?");
  883|      1|                xmlOutputBufferWriteString(buf, (const char *)cur->name);
  884|      1|                if (cur->content != NULL) {
  ------------------
  |  Branch (884:21): [True: 1, False: 0]
  ------------------
  885|      1|                    xmlOutputBufferWriteString(buf, " ");
  886|      1|                    xmlOutputBufferWriteString(buf,
  887|      1|                            (const char *)cur->content);
  888|      1|                }
  889|      1|                xmlOutputBufferWriteString(buf, ">");
  890|      1|            }
  891|      1|            break;
  892|       |
  893|      0|        case HTML_ENTITY_REF_NODE:
  ------------------
  |  |   39|      0|#define HTML_ENTITY_REF_NODE	XML_ENTITY_REF_NODE
  ------------------
  |  Branch (893:9): [True: 0, False: 12.0k]
  ------------------
  894|      0|            xmlOutputBufferWriteString(buf, "&");
  895|      0|            xmlOutputBufferWriteString(buf, (const char *)cur->name);
  896|      0|            xmlOutputBufferWriteString(buf, ";");
  897|      0|            break;
  898|       |
  899|     22|        case HTML_PRESERVE_NODE:
  ------------------
  |  |   53|     22|#define HTML_PRESERVE_NODE	XML_CDATA_SECTION_NODE
  ------------------
  |  Branch (899:9): [True: 22, False: 12.0k]
  ------------------
  900|     22|            if (cur->content != NULL) {
  ------------------
  |  Branch (900:17): [True: 22, False: 0]
  ------------------
  901|     22|                xmlOutputBufferWriteString(buf, (const char *)cur->content);
  902|     22|            }
  903|     22|            break;
  904|       |
  905|     87|        default:
  ------------------
  |  Branch (905:9): [True: 87, False: 11.9k]
  ------------------
  906|     87|            break;
  907|  12.0k|        }
  908|       |
  909|  12.0k|        while (1) {
  ------------------
  |  Branch (909:16): [Folded - Ignored]
  ------------------
  910|  12.0k|            if (cur == root)
  ------------------
  |  Branch (910:17): [True: 88, False: 11.9k]
  ------------------
  911|     88|                return;
  912|  11.9k|            if (cur->next != NULL) {
  ------------------
  |  Branch (912:17): [True: 7.49k, False: 4.44k]
  ------------------
  913|  7.49k|                cur = cur->next;
  914|  7.49k|                break;
  915|  7.49k|            }
  916|       |
  917|  4.44k|            cur = parent;
  918|       |            /* cur->parent was validated when descending. */
  919|  4.44k|            parent = cur->parent;
  920|       |
  921|  4.44k|            if ((cur->type == XML_HTML_DOCUMENT_NODE) ||
  ------------------
  |  Branch (921:17): [True: 87, False: 4.36k]
  ------------------
  922|  4.44k|                (cur->type == XML_DOCUMENT_NODE)) {
  ------------------
  |  Branch (922:17): [True: 0, False: 4.36k]
  ------------------
  923|     87|                xmlOutputBufferWriteString(buf, "\n");
  924|  4.36k|            } else {
  925|  4.36k|                if ((format) && (cur->ns == NULL))
  ------------------
  |  Branch (925:21): [True: 4.36k, False: 0]
  |  Branch (925:33): [True: 4.36k, False: 0]
  ------------------
  926|  4.36k|                    info = htmlTagLookup(cur->name);
  927|      0|                else
  928|      0|                    info = NULL;
  929|       |
  930|  4.36k|                if ((format) && (info != NULL) && (!info->isinline) &&
  ------------------
  |  Branch (930:21): [True: 4.36k, False: 0]
  |  Branch (930:33): [True: 4.35k, False: 8]
  |  Branch (930:51): [True: 1.80k, False: 2.55k]
  ------------------
  931|  4.36k|                    (cur->last->type != HTML_TEXT_NODE) &&
  ------------------
  |  |   32|  1.80k|#define HTML_TEXT_NODE		XML_TEXT_NODE
  ------------------
  |  Branch (931:21): [True: 829, False: 973]
  ------------------
  932|  4.36k|                    (cur->last->type != HTML_ENTITY_REF_NODE) &&
  ------------------
  |  |   39|    829|#define HTML_ENTITY_REF_NODE	XML_ENTITY_REF_NODE
  ------------------
  |  Branch (932:21): [True: 829, False: 0]
  ------------------
  933|  4.36k|                    (cur->children != cur->last) &&
  ------------------
  |  Branch (933:21): [True: 491, False: 338]
  ------------------
  934|  4.36k|                    (cur->name != NULL) &&
  ------------------
  |  Branch (934:21): [True: 491, False: 0]
  ------------------
  935|  4.36k|                    (cur->name[0] != 'p')) /* p, pre, param */
  ------------------
  |  Branch (935:21): [True: 475, False: 16]
  ------------------
  936|    475|                    xmlOutputBufferWriteString(buf, "\n");
  937|       |
  938|  4.36k|                xmlOutputBufferWriteString(buf, "</");
  939|  4.36k|                if ((cur->ns != NULL) && (cur->ns->prefix != NULL)) {
  ------------------
  |  Branch (939:21): [True: 0, False: 4.36k]
  |  Branch (939:42): [True: 0, False: 0]
  ------------------
  940|      0|                    xmlOutputBufferWriteString(buf, (const char *)cur->ns->prefix);
  941|      0|                    xmlOutputBufferWriteString(buf, ":");
  942|      0|                }
  943|  4.36k|                xmlOutputBufferWriteString(buf, (const char *)cur->name);
  944|  4.36k|                xmlOutputBufferWriteString(buf, ">");
  945|       |
  946|  4.36k|                if ((format) && (info != NULL) && (!info->isinline) &&
  ------------------
  |  Branch (946:21): [True: 4.36k, False: 0]
  |  Branch (946:33): [True: 4.35k, False: 8]
  |  Branch (946:51): [True: 1.80k, False: 2.55k]
  ------------------
  947|  4.36k|                    (cur->next != NULL)) {
  ------------------
  |  Branch (947:21): [True: 1.21k, False: 590]
  ------------------
  948|  1.21k|                    if ((cur->next->type != HTML_TEXT_NODE) &&
  ------------------
  |  |   32|  1.21k|#define HTML_TEXT_NODE		XML_TEXT_NODE
  ------------------
  |  Branch (948:25): [True: 231, False: 981]
  ------------------
  949|  1.21k|                        (cur->next->type != HTML_ENTITY_REF_NODE) &&
  ------------------
  |  |   39|    231|#define HTML_ENTITY_REF_NODE	XML_ENTITY_REF_NODE
  ------------------
  |  Branch (949:25): [True: 231, False: 0]
  ------------------
  950|  1.21k|                        (parent != NULL) &&
  ------------------
  |  Branch (950:25): [True: 231, False: 0]
  ------------------
  951|  1.21k|                        (parent->name != NULL) &&
  ------------------
  |  Branch (951:25): [True: 230, False: 1]
  ------------------
  952|  1.21k|                        (parent->name[0] != 'p')) /* p, pre, param */
  ------------------
  |  Branch (952:25): [True: 230, False: 0]
  ------------------
  953|    230|                        xmlOutputBufferWriteString(buf, "\n");
  954|  1.21k|                }
  955|  4.36k|            }
  956|  4.44k|        }
  957|  7.58k|    }
  958|     88|}
htmlDocContentDumpOutput:
 1009|     99|	                 const char *encoding ATTRIBUTE_UNUSED) {
 1010|     99|    htmlNodeDumpFormatOutput(buf, cur, (xmlNodePtr) cur, NULL, 1);
 1011|     99|}
HTMLtree.c:htmlDtdDumpOutput:
  633|     87|	          const char *encoding ATTRIBUTE_UNUSED) {
  634|     87|    xmlDtdPtr cur = doc->intSubset;
  635|       |
  636|     87|    if (cur == NULL) {
  ------------------
  |  Branch (636:9): [True: 0, False: 87]
  ------------------
  637|      0|	htmlSaveErr(XML_SAVE_NO_DOCTYPE, (xmlNodePtr) doc, NULL);
  638|      0|	return;
  639|      0|    }
  640|     87|    xmlOutputBufferWriteString(buf, "<!DOCTYPE ");
  641|     87|    xmlOutputBufferWriteString(buf, (const char *)cur->name);
  642|     87|    if (cur->ExternalID != NULL) {
  ------------------
  |  Branch (642:9): [True: 83, False: 4]
  ------------------
  643|     83|	xmlOutputBufferWriteString(buf, " PUBLIC ");
  644|     83|	xmlBufWriteQuotedString(buf->buffer, cur->ExternalID);
  645|     83|	if (cur->SystemID != NULL) {
  ------------------
  |  Branch (645:6): [True: 76, False: 7]
  ------------------
  646|     76|	    xmlOutputBufferWriteString(buf, " ");
  647|     76|	    xmlBufWriteQuotedString(buf->buffer, cur->SystemID);
  648|     76|	}
  649|     83|    } else if (cur->SystemID != NULL &&
  ------------------
  |  Branch (649:16): [True: 0, False: 4]
  ------------------
  650|      4|	       xmlStrcmp(cur->SystemID, BAD_CAST "about:legacy-compat")) {
  ------------------
  |  |   35|      0|#define BAD_CAST (xmlChar *)
  ------------------
  |  Branch (650:9): [True: 0, False: 0]
  ------------------
  651|      0|	xmlOutputBufferWriteString(buf, " SYSTEM ");
  652|      0|	xmlBufWriteQuotedString(buf->buffer, cur->SystemID);
  653|      0|    }
  654|     87|    xmlOutputBufferWriteString(buf, ">\n");
  655|     87|}
HTMLtree.c:htmlAttrDumpOutput:
  666|  6.71k|htmlAttrDumpOutput(xmlOutputBufferPtr buf, xmlDocPtr doc, xmlAttrPtr cur) {
  667|  6.71k|    xmlChar *value;
  668|       |
  669|       |    /*
  670|       |     * The html output method should not escape a & character
  671|       |     * occurring in an attribute value immediately followed by
  672|       |     * a { character (see Section B.7.1 of the HTML 4.0 Recommendation).
  673|       |     * This is implemented in xmlEncodeEntitiesReentrant
  674|       |     */
  675|       |
  676|  6.71k|    if (cur == NULL) {
  ------------------
  |  Branch (676:9): [True: 0, False: 6.71k]
  ------------------
  677|      0|	return;
  678|      0|    }
  679|  6.71k|    xmlOutputBufferWriteString(buf, " ");
  680|  6.71k|    if ((cur->ns != NULL) && (cur->ns->prefix != NULL)) {
  ------------------
  |  Branch (680:9): [True: 0, False: 6.71k]
  |  Branch (680:30): [True: 0, False: 0]
  ------------------
  681|      0|        xmlOutputBufferWriteString(buf, (const char *)cur->ns->prefix);
  682|      0|	xmlOutputBufferWriteString(buf, ":");
  683|      0|    }
  684|  6.71k|    xmlOutputBufferWriteString(buf, (const char *)cur->name);
  685|  6.71k|    if ((cur->children != NULL) && (!htmlIsBooleanAttr(cur->name))) {
  ------------------
  |  Branch (685:9): [True: 6.70k, False: 5]
  |  Branch (685:36): [True: 6.68k, False: 20]
  ------------------
  686|  6.68k|	value = xmlNodeListGetString(doc, cur->children, 0);
  687|  6.68k|	if (value) {
  ------------------
  |  Branch (687:6): [True: 6.68k, False: 0]
  ------------------
  688|  6.68k|	    xmlOutputBufferWriteString(buf, "=");
  689|  6.68k|	    if ((cur->ns == NULL) && (cur->parent != NULL) &&
  ------------------
  |  Branch (689:10): [True: 6.68k, False: 0]
  |  Branch (689:31): [True: 6.68k, False: 0]
  ------------------
  690|  6.68k|		(cur->parent->ns == NULL) &&
  ------------------
  |  Branch (690:3): [True: 6.68k, False: 0]
  ------------------
  691|  6.68k|		((!xmlStrcasecmp(cur->name, BAD_CAST "href")) ||
  ------------------
  |  |   35|  6.68k|#define BAD_CAST (xmlChar *)
  ------------------
  |  Branch (691:4): [True: 934, False: 5.75k]
  ------------------
  692|  6.68k|	         (!xmlStrcasecmp(cur->name, BAD_CAST "action")) ||
  ------------------
  |  |   35|  5.75k|#define BAD_CAST (xmlChar *)
  ------------------
  |  Branch (692:11): [True: 29, False: 5.72k]
  ------------------
  693|  6.68k|		 (!xmlStrcasecmp(cur->name, BAD_CAST "src")) ||
  ------------------
  |  |   35|  5.72k|#define BAD_CAST (xmlChar *)
  ------------------
  |  Branch (693:4): [True: 284, False: 5.44k]
  ------------------
  694|  6.68k|		 ((!xmlStrcasecmp(cur->name, BAD_CAST "name")) &&
  ------------------
  |  |   35|  5.44k|#define BAD_CAST (xmlChar *)
  ------------------
  |  Branch (694:5): [True: 219, False: 5.22k]
  ------------------
  695|  5.44k|		  (!xmlStrcasecmp(cur->parent->name, BAD_CAST "a"))))) {
  ------------------
  |  |   35|    219|#define BAD_CAST (xmlChar *)
  ------------------
  |  Branch (695:5): [True: 89, False: 130]
  ------------------
  696|  1.33k|		xmlChar *escaped;
  697|  1.33k|		xmlChar *tmp = value;
  698|       |
  699|  1.33k|		while (IS_BLANK_CH(*tmp)) tmp++;
  700|       |
  701|       |		/*
  702|       |                 * Angle brackets are technically illegal in URIs, but they're
  703|       |                 * used in server side includes, for example. Curly brackets
  704|       |                 * are illegal as well and often used in templates.
  705|       |                 * Don't escape non-whitespace, printable ASCII chars for
  706|       |                 * improved interoperability. Only escape space, control
  707|       |                 * and non-ASCII chars.
  708|       |		 */
  709|  1.33k|		escaped = xmlURIEscapeStr(tmp,
  710|  1.33k|                        BAD_CAST "\"#$%&+,/:;<=>?@[\\]^`{|}");
  ------------------
  |  |   35|  1.33k|#define BAD_CAST (xmlChar *)
  ------------------
  711|  1.33k|		if (escaped != NULL) {
  ------------------
  |  Branch (711:7): [True: 1.33k, False: 0]
  ------------------
  712|  1.33k|		    xmlBufWriteQuotedString(buf->buffer, escaped);
  713|  1.33k|		    xmlFree(escaped);
  714|  1.33k|		} else {
  715|      0|		    xmlBufWriteQuotedString(buf->buffer, value);
  716|      0|		}
  717|  5.35k|	    } else {
  718|  5.35k|		xmlBufWriteQuotedString(buf->buffer, value);
  719|  5.35k|	    }
  720|  6.68k|	    xmlFree(value);
  721|  6.68k|	} else  {
  722|      0|	    xmlOutputBufferWriteString(buf, "=\"\"");
  723|      0|	}
  724|  6.68k|    }
  725|  6.71k|}

xmlSAX2InternalSubset:
  326|     42|{
  327|     42|    xmlParserCtxtPtr ctxt = (xmlParserCtxtPtr) ctx;
  328|     42|    xmlDtdPtr dtd;
  329|     42|    if (ctx == NULL) return;
  ------------------
  |  Branch (329:9): [True: 0, False: 42]
  ------------------
  330|       |
  331|     42|    if (ctxt->myDoc == NULL)
  ------------------
  |  Branch (331:9): [True: 0, False: 42]
  ------------------
  332|      0|	return;
  333|     42|    dtd = xmlGetIntSubset(ctxt->myDoc);
  334|     42|    if (dtd != NULL) {
  ------------------
  |  Branch (334:9): [True: 8, False: 34]
  ------------------
  335|      8|	if (ctxt->html)
  ------------------
  |  Branch (335:6): [True: 8, False: 0]
  ------------------
  336|      8|	    return;
  337|      0|	xmlUnlinkNode((xmlNodePtr) dtd);
  338|      0|	xmlFreeDtd(dtd);
  339|      0|	ctxt->myDoc->intSubset = NULL;
  340|      0|    }
  341|     34|    ctxt->myDoc->intSubset =
  342|     34|	xmlCreateIntSubset(ctxt->myDoc, name, ExternalID, SystemID);
  343|     34|    if (ctxt->myDoc->intSubset == NULL)
  ------------------
  |  Branch (343:9): [True: 0, False: 34]
  ------------------
  344|      0|        xmlSAX2ErrMemory(ctxt, "xmlSAX2InternalSubset");
  345|     34|}
xmlSAX2SetDocumentLocator:
  877|    182|{
  878|    182|}
xmlSAX2StartDocument:
  888|    182|{
  889|    182|    xmlParserCtxtPtr ctxt = (xmlParserCtxtPtr) ctx;
  890|    182|    xmlDocPtr doc;
  891|       |
  892|    182|    if (ctx == NULL) return;
  ------------------
  |  Branch (892:9): [True: 0, False: 182]
  ------------------
  893|       |
  894|    182|    if (ctxt->html) {
  ------------------
  |  Branch (894:9): [True: 182, False: 0]
  ------------------
  895|    182|#ifdef LIBXML_HTML_ENABLED
  896|    182|	if (ctxt->myDoc == NULL)
  ------------------
  |  Branch (896:6): [True: 182, False: 0]
  ------------------
  897|    182|	    ctxt->myDoc = htmlNewDocNoDtD(NULL, NULL);
  898|    182|	if (ctxt->myDoc == NULL) {
  ------------------
  |  Branch (898:6): [True: 2, False: 180]
  ------------------
  899|      2|	    xmlSAX2ErrMemory(ctxt, "xmlSAX2StartDocument");
  900|      2|	    return;
  901|      2|	}
  902|    180|	ctxt->myDoc->properties = XML_DOC_HTML;
  903|    180|	ctxt->myDoc->parseFlags = ctxt->options;
  904|       |#else
  905|       |        xmlGenericError(xmlGenericErrorContext,
  906|       |		"libxml2 built without HTML support\n");
  907|       |	ctxt->errNo = XML_ERR_INTERNAL_ERROR;
  908|       |	ctxt->instate = XML_PARSER_EOF;
  909|       |	ctxt->disableSAX = 1;
  910|       |	return;
  911|       |#endif
  912|    180|    } else {
  913|      0|	doc = ctxt->myDoc = xmlNewDoc(ctxt->version);
  914|      0|	if (doc != NULL) {
  ------------------
  |  Branch (914:6): [True: 0, False: 0]
  ------------------
  915|      0|	    doc->properties = 0;
  916|      0|	    if (ctxt->options & XML_PARSE_OLD10)
  ------------------
  |  Branch (916:10): [True: 0, False: 0]
  ------------------
  917|      0|	        doc->properties |= XML_DOC_OLD10;
  918|      0|	    doc->parseFlags = ctxt->options;
  919|      0|	    doc->standalone = ctxt->standalone;
  920|      0|	} else {
  921|      0|	    xmlSAX2ErrMemory(ctxt, "xmlSAX2StartDocument");
  922|      0|	    return;
  923|      0|	}
  924|      0|	if ((ctxt->dictNames) && (doc != NULL)) {
  ------------------
  |  Branch (924:6): [True: 0, False: 0]
  |  Branch (924:27): [True: 0, False: 0]
  ------------------
  925|      0|	    doc->dict = ctxt->dict;
  926|      0|	    xmlDictReference(doc->dict);
  927|      0|	}
  928|      0|    }
  929|    180|    if ((ctxt->myDoc != NULL) && (ctxt->myDoc->URL == NULL) &&
  ------------------
  |  Branch (929:9): [True: 180, False: 0]
  |  Branch (929:34): [True: 180, False: 0]
  ------------------
  930|    180|	(ctxt->input != NULL) && (ctxt->input->filename != NULL)) {
  ------------------
  |  Branch (930:2): [True: 180, False: 0]
  |  Branch (930:27): [True: 0, False: 180]
  ------------------
  931|      0|	ctxt->myDoc->URL = xmlPathToURI((const xmlChar *)ctxt->input->filename);
  932|      0|	if (ctxt->myDoc->URL == NULL)
  ------------------
  |  Branch (932:6): [True: 0, False: 0]
  ------------------
  933|      0|	    xmlSAX2ErrMemory(ctxt, "xmlSAX2StartDocument");
  934|      0|    }
  935|    180|}
xmlSAX2EndDocument:
  945|    180|{
  946|    180|    xmlParserCtxtPtr ctxt = (xmlParserCtxtPtr) ctx;
  947|    180|    xmlDocPtr doc;
  948|       |
  949|    180|    if (ctx == NULL) return;
  ------------------
  |  Branch (949:9): [True: 0, False: 180]
  ------------------
  950|    180|#ifdef LIBXML_VALID_ENABLED
  951|    180|    if (ctxt->validate && ctxt->wellFormed &&
  ------------------
  |  Branch (951:9): [True: 0, False: 180]
  |  Branch (951:27): [True: 0, False: 0]
  ------------------
  952|    180|        ctxt->myDoc && ctxt->myDoc->intSubset)
  ------------------
  |  Branch (952:9): [True: 0, False: 0]
  |  Branch (952:24): [True: 0, False: 0]
  ------------------
  953|      0|	ctxt->valid &= xmlValidateDocumentFinal(&ctxt->vctxt, ctxt->myDoc);
  954|    180|#endif /* LIBXML_VALID_ENABLED */
  955|       |
  956|    180|    doc = ctxt->myDoc;
  957|    180|    if ((doc != NULL) && (doc->encoding == NULL)) {
  ------------------
  |  Branch (957:9): [True: 177, False: 3]
  |  Branch (957:26): [True: 177, False: 0]
  ------------------
  958|    177|        const xmlChar *encoding = NULL;
  959|       |
  960|    177|        if ((ctxt->input->flags & XML_INPUT_USES_ENC_DECL) ||
  ------------------
  |  |   26|    177|#define XML_INPUT_USES_ENC_DECL     (1u << 4)
  ------------------
  |  Branch (960:13): [True: 16, False: 161]
  ------------------
  961|    177|            (ctxt->input->flags & XML_INPUT_AUTO_ENCODING)) {
  ------------------
  |  |   21|    161|#define XML_INPUT_AUTO_ENCODING     (7u << 1)
  ------------------
  |  Branch (961:13): [True: 0, False: 161]
  ------------------
  962|       |            /* Preserve encoding exactly */
  963|     16|            encoding = ctxt->encoding;
  964|    161|        } else if ((ctxt->input->buf) && (ctxt->input->buf->encoder)) {
  ------------------
  |  Branch (964:20): [True: 161, False: 0]
  |  Branch (964:42): [True: 43, False: 118]
  ------------------
  965|     43|            encoding = BAD_CAST ctxt->input->buf->encoder->name;
  ------------------
  |  |   35|     43|#define BAD_CAST (xmlChar *)
  ------------------
  966|    118|        } else if (ctxt->input->flags & XML_INPUT_HAS_ENCODING) {
  ------------------
  |  |   20|    118|#define XML_INPUT_HAS_ENCODING      (1u << 0)
  ------------------
  |  Branch (966:20): [True: 0, False: 118]
  ------------------
  967|      0|            encoding = BAD_CAST "UTF-8";
  ------------------
  |  |   35|      0|#define BAD_CAST (xmlChar *)
  ------------------
  968|      0|        }
  969|       |
  970|    177|        if (encoding != NULL) {
  ------------------
  |  Branch (970:13): [True: 59, False: 118]
  ------------------
  971|     59|            doc->encoding = xmlStrdup(encoding);
  972|     59|            if (doc->encoding == NULL)
  ------------------
  |  Branch (972:17): [True: 1, False: 58]
  ------------------
  973|      1|                xmlSAX2ErrMemory(ctxt, "xmlSAX2EndDocument");
  974|     59|        }
  975|    177|    }
  976|    180|}
xmlSAX2StartElement:
 1525|  13.2k|{
 1526|  13.2k|    xmlParserCtxtPtr ctxt = (xmlParserCtxtPtr) ctx;
 1527|  13.2k|    xmlNodePtr ret;
 1528|  13.2k|    xmlNodePtr parent;
 1529|  13.2k|    xmlNsPtr ns;
 1530|  13.2k|    xmlChar *name;
 1531|  13.2k|    xmlChar *prefix;
 1532|  13.2k|    const xmlChar *att;
 1533|  13.2k|    const xmlChar *value;
 1534|  13.2k|    int i;
 1535|       |
 1536|  13.2k|    if ((ctx == NULL) || (fullname == NULL) || (ctxt->myDoc == NULL)) return;
  ------------------
  |  Branch (1536:9): [True: 0, False: 13.2k]
  |  Branch (1536:26): [True: 0, False: 13.2k]
  |  Branch (1536:48): [True: 0, False: 13.2k]
  ------------------
 1537|       |
 1538|       |    /*
 1539|       |     * First check on validity:
 1540|       |     */
 1541|  13.2k|    if (ctxt->validate && (ctxt->myDoc->extSubset == NULL) &&
  ------------------
  |  Branch (1541:9): [True: 0, False: 13.2k]
  |  Branch (1541:27): [True: 0, False: 0]
  ------------------
 1542|  13.2k|        ((ctxt->myDoc->intSubset == NULL) ||
  ------------------
  |  Branch (1542:10): [True: 0, False: 0]
  ------------------
 1543|      0|	 ((ctxt->myDoc->intSubset->notations == NULL) &&
  ------------------
  |  Branch (1543:4): [True: 0, False: 0]
  ------------------
 1544|      0|	  (ctxt->myDoc->intSubset->elements == NULL) &&
  ------------------
  |  Branch (1544:4): [True: 0, False: 0]
  ------------------
 1545|      0|	  (ctxt->myDoc->intSubset->attributes == NULL) &&
  ------------------
  |  Branch (1545:4): [True: 0, False: 0]
  ------------------
 1546|      0|	  (ctxt->myDoc->intSubset->entities == NULL)))) {
  ------------------
  |  Branch (1546:4): [True: 0, False: 0]
  ------------------
 1547|      0|	xmlErrValid(ctxt, XML_ERR_NO_DTD,
 1548|      0|	  "Validation failed: no DTD found !", NULL, NULL);
 1549|      0|	ctxt->validate = 0;
 1550|      0|    }
 1551|       |
 1552|  13.2k|    if (ctxt->html) {
  ------------------
  |  Branch (1552:9): [True: 13.2k, False: 0]
  ------------------
 1553|  13.2k|        prefix = NULL;
 1554|  13.2k|        name = xmlStrdup(fullname);
 1555|  13.2k|    } else {
 1556|       |        /*
 1557|       |         * Split the full name into a namespace prefix and the tag name
 1558|       |         */
 1559|      0|        name = xmlSplitQName(ctxt, fullname, &prefix);
 1560|      0|    }
 1561|       |
 1562|       |    /*
 1563|       |     * Note : the namespace resolution is deferred until the end of the
 1564|       |     *        attributes parsing, since local namespace can be defined as
 1565|       |     *        an attribute at this level.
 1566|       |     */
 1567|  13.2k|    ret = xmlNewDocNodeEatName(ctxt->myDoc, NULL, name, NULL);
 1568|  13.2k|    if (ret == NULL) {
  ------------------
  |  Branch (1568:9): [True: 6, False: 13.2k]
  ------------------
 1569|      6|        if (prefix != NULL)
  ------------------
  |  Branch (1569:13): [True: 0, False: 6]
  ------------------
 1570|      0|	    xmlFree(prefix);
 1571|      6|	xmlSAX2ErrMemory(ctxt, "xmlSAX2StartElement");
 1572|      6|        return;
 1573|      6|    }
 1574|  13.2k|    ctxt->nodemem = -1;
 1575|  13.2k|    if (ctxt->linenumbers) {
  ------------------
  |  Branch (1575:9): [True: 13.2k, False: 0]
  ------------------
 1576|  13.2k|	if (ctxt->input != NULL) {
  ------------------
  |  Branch (1576:6): [True: 13.2k, False: 0]
  ------------------
 1577|  13.2k|	    if ((unsigned) ctxt->input->line < (unsigned) USHRT_MAX)
  ------------------
  |  Branch (1577:10): [True: 13.2k, False: 0]
  ------------------
 1578|  13.2k|		ret->line = ctxt->input->line;
 1579|      0|	    else
 1580|      0|	        ret->line = USHRT_MAX;
 1581|  13.2k|	}
 1582|  13.2k|    }
 1583|       |
 1584|       |    /* Initialize parent before pushing node */
 1585|  13.2k|    parent = ctxt->node;
 1586|  13.2k|    if (parent == NULL)
  ------------------
  |  Branch (1586:9): [True: 169, False: 13.0k]
  ------------------
 1587|    169|        parent = (xmlNodePtr) ctxt->myDoc;
 1588|       |
 1589|       |    /*
 1590|       |     * We are parsing a new node.
 1591|       |     */
 1592|  13.2k|    if (nodePush(ctxt, ret) < 0) {
  ------------------
  |  Branch (1592:9): [True: 0, False: 13.2k]
  ------------------
 1593|      0|        xmlUnlinkNode(ret);
 1594|      0|        xmlFreeNode(ret);
 1595|      0|        if (prefix != NULL)
  ------------------
  |  Branch (1595:13): [True: 0, False: 0]
  ------------------
 1596|      0|            xmlFree(prefix);
 1597|      0|        return;
 1598|      0|    }
 1599|       |
 1600|       |    /*
 1601|       |     * Link the child element
 1602|       |     */
 1603|  13.2k|    xmlAddChild(parent, ret);
 1604|       |
 1605|  13.2k|    if (!ctxt->html) {
  ------------------
  |  Branch (1605:9): [True: 0, False: 13.2k]
  ------------------
 1606|       |        /*
 1607|       |         * Insert all the defaulted attributes from the DTD especially
 1608|       |         * namespaces
 1609|       |         */
 1610|      0|        if ((ctxt->myDoc->intSubset != NULL) ||
  ------------------
  |  Branch (1610:13): [True: 0, False: 0]
  ------------------
 1611|      0|            (ctxt->myDoc->extSubset != NULL)) {
  ------------------
  |  Branch (1611:13): [True: 0, False: 0]
  ------------------
 1612|      0|            xmlCheckDefaultedAttributes(ctxt, name, prefix, atts);
 1613|      0|        }
 1614|       |
 1615|       |        /*
 1616|       |         * process all the attributes whose name start with "xmlns"
 1617|       |         */
 1618|      0|        if (atts != NULL) {
  ------------------
  |  Branch (1618:13): [True: 0, False: 0]
  ------------------
 1619|      0|            i = 0;
 1620|      0|            att = atts[i++];
 1621|      0|            value = atts[i++];
 1622|      0|	    while ((att != NULL) && (value != NULL)) {
  ------------------
  |  Branch (1622:13): [True: 0, False: 0]
  |  Branch (1622:30): [True: 0, False: 0]
  ------------------
 1623|      0|		if ((att[0] == 'x') && (att[1] == 'm') && (att[2] == 'l') &&
  ------------------
  |  Branch (1623:7): [True: 0, False: 0]
  |  Branch (1623:26): [True: 0, False: 0]
  |  Branch (1623:45): [True: 0, False: 0]
  ------------------
 1624|      0|		    (att[3] == 'n') && (att[4] == 's'))
  ------------------
  |  Branch (1624:7): [True: 0, False: 0]
  |  Branch (1624:26): [True: 0, False: 0]
  ------------------
 1625|      0|		    xmlSAX2AttributeInternal(ctxt, att, value, prefix);
 1626|       |
 1627|      0|		att = atts[i++];
 1628|      0|		value = atts[i++];
 1629|      0|	    }
 1630|      0|        }
 1631|       |
 1632|       |        /*
 1633|       |         * Search the namespace, note that since the attributes have been
 1634|       |         * processed, the local namespaces are available.
 1635|       |         */
 1636|      0|        ns = xmlSearchNs(ctxt->myDoc, ret, prefix);
 1637|      0|        if ((ns == NULL) && (parent != NULL))
  ------------------
  |  Branch (1637:13): [True: 0, False: 0]
  |  Branch (1637:29): [True: 0, False: 0]
  ------------------
 1638|      0|            ns = xmlSearchNs(ctxt->myDoc, parent, prefix);
 1639|      0|        if ((prefix != NULL) && (ns == NULL)) {
  ------------------
  |  Branch (1639:13): [True: 0, False: 0]
  |  Branch (1639:33): [True: 0, False: 0]
  ------------------
 1640|      0|            ns = xmlNewNs(ret, NULL, prefix);
 1641|      0|            xmlNsWarnMsg(ctxt, XML_NS_ERR_UNDEFINED_NAMESPACE,
 1642|      0|                         "Namespace prefix %s is not defined\n",
 1643|      0|                         prefix, NULL);
 1644|      0|        }
 1645|       |
 1646|       |        /*
 1647|       |         * set the namespace node, making sure that if the default namespace
 1648|       |         * is unbound on a parent we simply keep it NULL
 1649|       |         */
 1650|      0|        if ((ns != NULL) && (ns->href != NULL) &&
  ------------------
  |  Branch (1650:13): [True: 0, False: 0]
  |  Branch (1650:29): [True: 0, False: 0]
  ------------------
 1651|      0|            ((ns->href[0] != 0) || (ns->prefix != NULL)))
  ------------------
  |  Branch (1651:14): [True: 0, False: 0]
  |  Branch (1651:36): [True: 0, False: 0]
  ------------------
 1652|      0|            xmlSetNs(ret, ns);
 1653|      0|    }
 1654|       |
 1655|       |    /*
 1656|       |     * process all the other attributes
 1657|       |     */
 1658|  13.2k|    if (atts != NULL) {
  ------------------
  |  Branch (1658:9): [True: 6.84k, False: 6.41k]
  ------------------
 1659|  6.84k|        i = 0;
 1660|  6.84k|	att = atts[i++];
 1661|  6.84k|	value = atts[i++];
 1662|  6.84k|	if (ctxt->html) {
  ------------------
  |  Branch (1662:6): [True: 6.84k, False: 0]
  ------------------
 1663|  20.5k|	    while (att != NULL) {
  ------------------
  |  Branch (1663:13): [True: 13.7k, False: 6.84k]
  ------------------
 1664|  13.7k|		xmlSAX2AttributeInternal(ctxt, att, value, NULL);
 1665|  13.7k|		att = atts[i++];
 1666|  13.7k|		value = atts[i++];
 1667|  13.7k|	    }
 1668|  6.84k|	} else {
 1669|      0|	    while ((att != NULL) && (value != NULL)) {
  ------------------
  |  Branch (1669:13): [True: 0, False: 0]
  |  Branch (1669:30): [True: 0, False: 0]
  ------------------
 1670|      0|		if ((att[0] != 'x') || (att[1] != 'm') || (att[2] != 'l') ||
  ------------------
  |  Branch (1670:7): [True: 0, False: 0]
  |  Branch (1670:26): [True: 0, False: 0]
  |  Branch (1670:45): [True: 0, False: 0]
  ------------------
 1671|      0|		    (att[3] != 'n') || (att[4] != 's'))
  ------------------
  |  Branch (1671:7): [True: 0, False: 0]
  |  Branch (1671:26): [True: 0, False: 0]
  ------------------
 1672|      0|		    xmlSAX2AttributeInternal(ctxt, att, value, NULL);
 1673|       |
 1674|       |		/*
 1675|       |		 * Next ones
 1676|       |		 */
 1677|      0|		att = atts[i++];
 1678|      0|		value = atts[i++];
 1679|      0|	    }
 1680|      0|	}
 1681|  6.84k|    }
 1682|       |
 1683|  13.2k|#ifdef LIBXML_VALID_ENABLED
 1684|       |    /*
 1685|       |     * If it's the Document root, finish the DTD validation and
 1686|       |     * check the document root element for validity
 1687|       |     */
 1688|  13.2k|    if ((ctxt->validate) &&
  ------------------
  |  Branch (1688:9): [True: 0, False: 13.2k]
  ------------------
 1689|  13.2k|        ((ctxt->vctxt.flags & XML_VCTXT_DTD_VALIDATED) == 0)) {
  ------------------
  |  |   12|      0|#define XML_VCTXT_DTD_VALIDATED (1u << 0)
  ------------------
  |  Branch (1689:9): [True: 0, False: 0]
  ------------------
 1690|      0|	int chk;
 1691|       |
 1692|      0|	chk = xmlValidateDtdFinal(&ctxt->vctxt, ctxt->myDoc);
 1693|      0|	if (chk <= 0)
  ------------------
  |  Branch (1693:6): [True: 0, False: 0]
  ------------------
 1694|      0|	    ctxt->valid = 0;
 1695|      0|	if (chk < 0)
  ------------------
  |  Branch (1695:6): [True: 0, False: 0]
  ------------------
 1696|      0|	    ctxt->wellFormed = 0;
 1697|      0|	ctxt->valid &= xmlValidateRoot(&ctxt->vctxt, ctxt->myDoc);
 1698|      0|	ctxt->vctxt.flags |= XML_VCTXT_DTD_VALIDATED;
  ------------------
  |  |   12|      0|#define XML_VCTXT_DTD_VALIDATED (1u << 0)
  ------------------
 1699|      0|    }
 1700|  13.2k|#endif /* LIBXML_VALID_ENABLED */
 1701|       |
 1702|  13.2k|    if (prefix != NULL)
  ------------------
  |  Branch (1702:9): [True: 0, False: 13.2k]
  ------------------
 1703|      0|	xmlFree(prefix);
 1704|       |
 1705|  13.2k|}
xmlSAX2EndElement:
 1716|  13.2k|{
 1717|  13.2k|    xmlParserCtxtPtr ctxt = (xmlParserCtxtPtr) ctx;
 1718|       |
 1719|  13.2k|    if (ctx == NULL) return;
  ------------------
  |  Branch (1719:9): [True: 0, False: 13.2k]
  ------------------
 1720|       |
 1721|  13.2k|    ctxt->nodemem = -1;
 1722|       |
 1723|  13.2k|#ifdef LIBXML_VALID_ENABLED
 1724|  13.2k|    if (ctxt->validate && ctxt->wellFormed &&
  ------------------
  |  Branch (1724:9): [True: 0, False: 13.2k]
  |  Branch (1724:27): [True: 0, False: 0]
  ------------------
 1725|  13.2k|        ctxt->myDoc && ctxt->myDoc->intSubset)
  ------------------
  |  Branch (1725:9): [True: 0, False: 0]
  |  Branch (1725:24): [True: 0, False: 0]
  ------------------
 1726|      0|        ctxt->valid &= xmlValidateOneElement(&ctxt->vctxt, ctxt->myDoc,
 1727|      0|					     ctxt->node);
 1728|  13.2k|#endif /* LIBXML_VALID_ENABLED */
 1729|       |
 1730|       |
 1731|       |    /*
 1732|       |     * end of parsing of this node.
 1733|       |     */
 1734|  13.2k|    nodePop(ctxt);
 1735|  13.2k|}
xmlSAX2Characters:
 2541|  11.9k|{
 2542|  11.9k|    xmlSAX2Text((xmlParserCtxtPtr) ctx, ch, len, XML_TEXT_NODE);
 2543|  11.9k|}
xmlSAX2ProcessingInstruction:
 2570|      2|{
 2571|      2|    xmlParserCtxtPtr ctxt = (xmlParserCtxtPtr) ctx;
 2572|      2|    xmlNodePtr ret;
 2573|      2|    xmlNodePtr parent;
 2574|       |
 2575|      2|    if (ctx == NULL) return;
  ------------------
  |  Branch (2575:9): [True: 0, False: 2]
  ------------------
 2576|      2|    parent = ctxt->node;
 2577|       |
 2578|      2|    ret = xmlNewDocPI(ctxt->myDoc, target, data);
 2579|      2|    if (ret == NULL) return;
  ------------------
  |  Branch (2579:9): [True: 0, False: 2]
  ------------------
 2580|       |
 2581|      2|    if (ctxt->linenumbers) {
  ------------------
  |  Branch (2581:9): [True: 2, False: 0]
  ------------------
 2582|      2|	if (ctxt->input != NULL) {
  ------------------
  |  Branch (2582:6): [True: 2, False: 0]
  ------------------
 2583|      2|	    if ((unsigned) ctxt->input->line < (unsigned) USHRT_MAX)
  ------------------
  |  Branch (2583:10): [True: 2, False: 0]
  ------------------
 2584|      2|		ret->line = ctxt->input->line;
 2585|      0|	    else
 2586|      0|	        ret->line = USHRT_MAX;
 2587|      2|	}
 2588|      2|    }
 2589|      2|    if (ctxt->inSubset == 1) {
  ------------------
  |  Branch (2589:9): [True: 0, False: 2]
  ------------------
 2590|      0|	xmlAddChild((xmlNodePtr) ctxt->myDoc->intSubset, ret);
 2591|      0|	return;
 2592|      2|    } else if (ctxt->inSubset == 2) {
  ------------------
  |  Branch (2592:16): [True: 0, False: 2]
  ------------------
 2593|      0|	xmlAddChild((xmlNodePtr) ctxt->myDoc->extSubset, ret);
 2594|      0|	return;
 2595|      0|    }
 2596|      2|    if (parent == NULL) {
  ------------------
  |  Branch (2596:9): [True: 2, False: 0]
  ------------------
 2597|      2|        xmlAddChild((xmlNodePtr) ctxt->myDoc, (xmlNodePtr) ret);
 2598|      2|	return;
 2599|      2|    }
 2600|      0|    if (parent->type == XML_ELEMENT_NODE) {
  ------------------
  |  Branch (2600:9): [True: 0, False: 0]
  ------------------
 2601|      0|	xmlAddChild(parent, ret);
 2602|      0|    } else {
 2603|      0|	xmlAddSibling(parent, ret);
 2604|      0|    }
 2605|      0|}
xmlSAX2Comment:
 2616|    526|{
 2617|    526|    xmlParserCtxtPtr ctxt = (xmlParserCtxtPtr) ctx;
 2618|    526|    xmlNodePtr ret;
 2619|    526|    xmlNodePtr parent;
 2620|       |
 2621|    526|    if (ctx == NULL) return;
  ------------------
  |  Branch (2621:9): [True: 0, False: 526]
  ------------------
 2622|    526|    parent = ctxt->node;
 2623|    526|    ret = xmlNewDocComment(ctxt->myDoc, value);
 2624|    526|    if (ret == NULL) return;
  ------------------
  |  Branch (2624:9): [True: 0, False: 526]
  ------------------
 2625|    526|    if (ctxt->linenumbers) {
  ------------------
  |  Branch (2625:9): [True: 526, False: 0]
  ------------------
 2626|    526|	if (ctxt->input != NULL) {
  ------------------
  |  Branch (2626:6): [True: 526, False: 0]
  ------------------
 2627|    526|	    if ((unsigned) ctxt->input->line < (unsigned) USHRT_MAX)
  ------------------
  |  Branch (2627:10): [True: 526, False: 0]
  ------------------
 2628|    526|		ret->line = ctxt->input->line;
 2629|      0|	    else
 2630|      0|	        ret->line = USHRT_MAX;
 2631|    526|	}
 2632|    526|    }
 2633|       |
 2634|    526|    if (ctxt->inSubset == 1) {
  ------------------
  |  Branch (2634:9): [True: 0, False: 526]
  ------------------
 2635|      0|	xmlAddChild((xmlNodePtr) ctxt->myDoc->intSubset, ret);
 2636|      0|	return;
 2637|    526|    } else if (ctxt->inSubset == 2) {
  ------------------
  |  Branch (2637:16): [True: 0, False: 526]
  ------------------
 2638|      0|	xmlAddChild((xmlNodePtr) ctxt->myDoc->extSubset, ret);
 2639|      0|	return;
 2640|      0|    }
 2641|    526|    if (parent == NULL) {
  ------------------
  |  Branch (2641:9): [True: 24, False: 502]
  ------------------
 2642|     24|        xmlAddChild((xmlNodePtr) ctxt->myDoc, (xmlNodePtr) ret);
 2643|     24|	return;
 2644|     24|    }
 2645|    502|    if (parent->type == XML_ELEMENT_NODE) {
  ------------------
  |  Branch (2645:9): [True: 502, False: 0]
  ------------------
 2646|    502|	xmlAddChild(parent, ret);
 2647|    502|    } else {
 2648|      0|	xmlAddSibling(parent, ret);
 2649|      0|    }
 2650|    502|}
xmlSAX2CDataBlock:
 2662|     70|{
 2663|     70|    xmlSAX2Text((xmlParserCtxtPtr) ctx, value, len, XML_CDATA_SECTION_NODE);
 2664|     70|}
xmlSAX2InitHtmlDefaultSAXHandler:
 2798|    189|{
 2799|    189|    if ((hdlr == NULL) || (hdlr->initialized != 0))
  ------------------
  |  Branch (2799:9): [True: 0, False: 189]
  |  Branch (2799:27): [True: 0, False: 189]
  ------------------
 2800|      0|	return;
 2801|       |
 2802|    189|    hdlr->internalSubset = xmlSAX2InternalSubset;
 2803|    189|    hdlr->externalSubset = NULL;
 2804|    189|    hdlr->isStandalone = NULL;
 2805|    189|    hdlr->hasInternalSubset = NULL;
 2806|    189|    hdlr->hasExternalSubset = NULL;
 2807|    189|    hdlr->resolveEntity = NULL;
 2808|    189|    hdlr->getEntity = xmlSAX2GetEntity;
 2809|    189|    hdlr->getParameterEntity = NULL;
 2810|    189|    hdlr->entityDecl = NULL;
 2811|    189|    hdlr->attributeDecl = NULL;
 2812|    189|    hdlr->elementDecl = NULL;
 2813|    189|    hdlr->notationDecl = NULL;
 2814|    189|    hdlr->unparsedEntityDecl = NULL;
 2815|    189|    hdlr->setDocumentLocator = xmlSAX2SetDocumentLocator;
 2816|    189|    hdlr->startDocument = xmlSAX2StartDocument;
 2817|    189|    hdlr->endDocument = xmlSAX2EndDocument;
 2818|    189|    hdlr->startElement = xmlSAX2StartElement;
 2819|    189|    hdlr->endElement = xmlSAX2EndElement;
 2820|    189|    hdlr->reference = NULL;
 2821|    189|    hdlr->characters = xmlSAX2Characters;
 2822|    189|    hdlr->cdataBlock = xmlSAX2CDataBlock;
 2823|    189|    hdlr->ignorableWhitespace = xmlSAX2IgnorableWhitespace;
 2824|    189|    hdlr->processingInstruction = xmlSAX2ProcessingInstruction;
 2825|    189|    hdlr->comment = xmlSAX2Comment;
 2826|    189|    hdlr->warning = xmlParserWarning;
 2827|    189|    hdlr->error = xmlParserError;
 2828|    189|    hdlr->fatalError = xmlParserError;
 2829|       |
 2830|    189|    hdlr->initialized = 1;
 2831|    189|}
SAX2.c:xmlSAX2ErrMemory:
   55|      9|xmlSAX2ErrMemory(xmlParserCtxtPtr ctxt, const char *msg) {
   56|      9|    xmlStructuredErrorFunc schannel = NULL;
   57|      9|    const char *str1 = "out of memory\n";
   58|       |
   59|      9|    if (ctxt != NULL) {
  ------------------
  |  Branch (59:9): [True: 9, False: 0]
  ------------------
   60|      9|	ctxt->errNo = XML_ERR_NO_MEMORY;
   61|      9|	if ((ctxt->sax != NULL) && (ctxt->sax->initialized == XML_SAX2_MAGIC))
  ------------------
  |  |  685|      9|#define XML_SAX2_MAGIC 0xDEEDBEAF
  ------------------
  |  Branch (61:6): [True: 9, False: 0]
  |  Branch (61:29): [True: 0, False: 9]
  ------------------
   62|      0|	    schannel = ctxt->sax->serror;
   63|      9|	__xmlRaiseError(schannel,
   64|      9|			ctxt->vctxt.error, ctxt->vctxt.userData,
   65|      9|			ctxt, NULL, XML_FROM_PARSER, XML_ERR_NO_MEMORY,
   66|      9|			XML_ERR_ERROR, NULL, 0, (const char *) str1,
   67|      9|			NULL, NULL, 0, 0,
   68|      9|			msg, (const char *) str1, NULL);
   69|      9|	ctxt->errNo = XML_ERR_NO_MEMORY;
   70|      9|	ctxt->instate = XML_PARSER_EOF;
   71|      9|	ctxt->disableSAX = 1;
   72|      9|    } else {
   73|      0|	__xmlRaiseError(schannel,
   74|      0|			NULL, NULL,
   75|      0|			ctxt, NULL, XML_FROM_PARSER, XML_ERR_NO_MEMORY,
   76|      0|			XML_ERR_ERROR, NULL, 0, (const char *) str1,
   77|      0|			NULL, NULL, 0, 0,
   78|      0|			msg, (const char *) str1, NULL);
   79|      0|    }
   80|      9|}
SAX2.c:xmlSAX2AttributeInternal:
 1019|  13.7k|{
 1020|  13.7k|    xmlParserCtxtPtr ctxt = (xmlParserCtxtPtr) ctx;
 1021|  13.7k|    xmlAttrPtr ret;
 1022|  13.7k|    xmlChar *name;
 1023|  13.7k|    xmlChar *ns;
 1024|  13.7k|    xmlChar *nval;
 1025|  13.7k|    xmlNsPtr namespace;
 1026|       |
 1027|  13.7k|    if (ctxt->html) {
  ------------------
  |  Branch (1027:9): [True: 13.7k, False: 0]
  ------------------
 1028|  13.7k|	name = xmlStrdup(fullname);
 1029|  13.7k|	ns = NULL;
 1030|  13.7k|	namespace = NULL;
 1031|  13.7k|    } else {
 1032|       |	/*
 1033|       |	 * Split the full name into a namespace prefix and the tag name
 1034|       |	 */
 1035|      0|	name = xmlSplitQName(ctxt, fullname, &ns);
 1036|      0|	if ((name != NULL) && (name[0] == 0)) {
  ------------------
  |  Branch (1036:6): [True: 0, False: 0]
  |  Branch (1036:24): [True: 0, False: 0]
  ------------------
 1037|      0|	    if (xmlStrEqual(ns, BAD_CAST "xmlns")) {
  ------------------
  |  |   35|      0|#define BAD_CAST (xmlChar *)
  ------------------
  |  Branch (1037:10): [True: 0, False: 0]
  ------------------
 1038|      0|		xmlNsErrMsg(ctxt, XML_ERR_NS_DECL_ERROR,
 1039|      0|			    "invalid namespace declaration '%s'\n",
 1040|      0|			    fullname, NULL);
 1041|      0|	    } else {
 1042|      0|		xmlNsWarnMsg(ctxt, XML_WAR_NS_COLUMN,
 1043|      0|			     "Avoid attribute ending with ':' like '%s'\n",
 1044|      0|			     fullname, NULL);
 1045|      0|	    }
 1046|      0|	    if (ns != NULL)
  ------------------
  |  Branch (1046:10): [True: 0, False: 0]
  ------------------
 1047|      0|		xmlFree(ns);
 1048|      0|	    ns = NULL;
 1049|      0|	    xmlFree(name);
 1050|      0|	    name = xmlStrdup(fullname);
 1051|      0|	}
 1052|      0|    }
 1053|  13.7k|    if (name == NULL) {
  ------------------
  |  Branch (1053:9): [True: 0, False: 13.7k]
  ------------------
 1054|      0|        xmlSAX2ErrMemory(ctxt, "xmlSAX2StartElement");
 1055|      0|	if (ns != NULL)
  ------------------
  |  Branch (1055:6): [True: 0, False: 0]
  ------------------
 1056|      0|	    xmlFree(ns);
 1057|      0|	return;
 1058|      0|    }
 1059|       |
 1060|  13.7k|#ifdef LIBXML_HTML_ENABLED
 1061|  13.7k|    if ((ctxt->html) &&
  ------------------
  |  Branch (1061:9): [True: 13.7k, False: 0]
  ------------------
 1062|  13.7k|        (value == NULL) && (htmlIsBooleanAttr(fullname))) {
  ------------------
  |  Branch (1062:9): [True: 50, False: 13.6k]
  |  Branch (1062:28): [True: 40, False: 10]
  ------------------
 1063|     40|            nval = xmlStrdup(fullname);
 1064|     40|            value = (const xmlChar *) nval;
 1065|     40|    } else
 1066|  13.6k|#endif
 1067|  13.6k|    {
 1068|  13.6k|#ifdef LIBXML_VALID_ENABLED
 1069|       |        /*
 1070|       |         * Do the last stage of the attribute normalization
 1071|       |         * Needed for HTML too:
 1072|       |         *   http://www.w3.org/TR/html4/types.html#h-6.2
 1073|       |         */
 1074|  13.6k|        ctxt->vctxt.valid = 1;
 1075|  13.6k|        nval = xmlValidCtxtNormalizeAttributeValue(&ctxt->vctxt,
 1076|  13.6k|                                               ctxt->myDoc, ctxt->node,
 1077|  13.6k|                                               fullname, value);
 1078|  13.6k|        if (ctxt->vctxt.valid != 1) {
  ------------------
  |  Branch (1078:13): [True: 0, False: 13.6k]
  ------------------
 1079|      0|            ctxt->valid = 0;
 1080|      0|        }
 1081|  13.6k|        if (nval != NULL)
  ------------------
  |  Branch (1081:13): [True: 0, False: 13.6k]
  ------------------
 1082|      0|            value = nval;
 1083|       |#else
 1084|       |        nval = NULL;
 1085|       |#endif /* LIBXML_VALID_ENABLED */
 1086|  13.6k|    }
 1087|       |
 1088|       |    /*
 1089|       |     * Check whether it's a namespace definition
 1090|       |     */
 1091|  13.7k|    if ((!ctxt->html) && (ns == NULL) &&
  ------------------
  |  Branch (1091:9): [True: 0, False: 13.7k]
  |  Branch (1091:26): [True: 0, False: 0]
  ------------------
 1092|  13.7k|        (name[0] == 'x') && (name[1] == 'm') && (name[2] == 'l') &&
  ------------------
  |  Branch (1092:9): [True: 0, False: 0]
  |  Branch (1092:29): [True: 0, False: 0]
  |  Branch (1092:49): [True: 0, False: 0]
  ------------------
 1093|  13.7k|        (name[3] == 'n') && (name[4] == 's') && (name[5] == 0)) {
  ------------------
  |  Branch (1093:9): [True: 0, False: 0]
  |  Branch (1093:29): [True: 0, False: 0]
  |  Branch (1093:49): [True: 0, False: 0]
  ------------------
 1094|      0|	xmlNsPtr nsret;
 1095|      0|	xmlChar *val;
 1096|       |
 1097|       |        /* Avoid unused variable warning if features are disabled. */
 1098|      0|        (void) nsret;
 1099|       |
 1100|      0|        if (!ctxt->replaceEntities) {
  ------------------
  |  Branch (1100:13): [True: 0, False: 0]
  ------------------
 1101|      0|	    ctxt->depth++;
 1102|      0|	    val = xmlStringDecodeEntities(ctxt, value, XML_SUBSTITUTE_REF,
  ------------------
  |  |  521|      0|#define XML_SUBSTITUTE_REF	1
  ------------------
 1103|      0|		                          0,0,0);
 1104|      0|	    ctxt->depth--;
 1105|      0|	    if (val == NULL) {
  ------------------
  |  Branch (1105:10): [True: 0, False: 0]
  ------------------
 1106|      0|	        xmlSAX2ErrMemory(ctxt, "xmlSAX2StartElement");
 1107|      0|		if (name != NULL)
  ------------------
  |  Branch (1107:7): [True: 0, False: 0]
  ------------------
 1108|      0|		    xmlFree(name);
 1109|      0|                if (nval != NULL)
  ------------------
  |  Branch (1109:21): [True: 0, False: 0]
  ------------------
 1110|      0|                    xmlFree(nval);
 1111|      0|		return;
 1112|      0|	    }
 1113|      0|	} else {
 1114|      0|	    val = (xmlChar *) value;
 1115|      0|	}
 1116|       |
 1117|      0|	if (val[0] != 0) {
  ------------------
  |  Branch (1117:6): [True: 0, False: 0]
  ------------------
 1118|      0|	    xmlURIPtr uri;
 1119|       |
 1120|      0|	    uri = xmlParseURI((const char *)val);
 1121|      0|	    if (uri == NULL) {
  ------------------
  |  Branch (1121:10): [True: 0, False: 0]
  ------------------
 1122|      0|		if ((ctxt->sax != NULL) && (ctxt->sax->warning != NULL))
  ------------------
  |  Branch (1122:7): [True: 0, False: 0]
  |  Branch (1122:30): [True: 0, False: 0]
  ------------------
 1123|      0|		    ctxt->sax->warning(ctxt->userData,
 1124|      0|			 "xmlns: %s not a valid URI\n", val);
 1125|      0|	    } else {
 1126|      0|		if (uri->scheme == NULL) {
  ------------------
  |  Branch (1126:7): [True: 0, False: 0]
  ------------------
 1127|      0|		    if ((ctxt->sax != NULL) && (ctxt->sax->warning != NULL))
  ------------------
  |  Branch (1127:11): [True: 0, False: 0]
  |  Branch (1127:34): [True: 0, False: 0]
  ------------------
 1128|      0|			ctxt->sax->warning(ctxt->userData,
 1129|      0|			     "xmlns: URI %s is not absolute\n", val);
 1130|      0|		}
 1131|      0|		xmlFreeURI(uri);
 1132|      0|	    }
 1133|      0|	}
 1134|       |
 1135|       |	/* a default namespace definition */
 1136|      0|	nsret = xmlNewNs(ctxt->node, val, NULL);
 1137|       |
 1138|      0|#ifdef LIBXML_VALID_ENABLED
 1139|       |	/*
 1140|       |	 * Validate also for namespace decls, they are attributes from
 1141|       |	 * an XML-1.0 perspective
 1142|       |	 */
 1143|      0|        if (nsret != NULL && ctxt->validate && ctxt->wellFormed &&
  ------------------
  |  Branch (1143:13): [True: 0, False: 0]
  |  Branch (1143:30): [True: 0, False: 0]
  |  Branch (1143:48): [True: 0, False: 0]
  ------------------
 1144|      0|	    ctxt->myDoc && ctxt->myDoc->intSubset)
  ------------------
  |  Branch (1144:6): [True: 0, False: 0]
  |  Branch (1144:21): [True: 0, False: 0]
  ------------------
 1145|      0|	    ctxt->valid &= xmlValidateOneNamespace(&ctxt->vctxt, ctxt->myDoc,
 1146|      0|					   ctxt->node, prefix, nsret, val);
 1147|      0|#endif /* LIBXML_VALID_ENABLED */
 1148|      0|	if (name != NULL)
  ------------------
  |  Branch (1148:6): [True: 0, False: 0]
  ------------------
 1149|      0|	    xmlFree(name);
 1150|      0|	if (nval != NULL)
  ------------------
  |  Branch (1150:6): [True: 0, False: 0]
  ------------------
 1151|      0|	    xmlFree(nval);
 1152|      0|	if (val != value)
  ------------------
  |  Branch (1152:6): [True: 0, False: 0]
  ------------------
 1153|      0|	    xmlFree(val);
 1154|      0|	return;
 1155|      0|    }
 1156|  13.7k|    if ((!ctxt->html) &&
  ------------------
  |  Branch (1156:9): [True: 0, False: 13.7k]
  ------------------
 1157|  13.7k|	(ns != NULL) && (ns[0] == 'x') && (ns[1] == 'm') && (ns[2] == 'l') &&
  ------------------
  |  Branch (1157:2): [True: 0, False: 0]
  |  Branch (1157:18): [True: 0, False: 0]
  |  Branch (1157:36): [True: 0, False: 0]
  |  Branch (1157:54): [True: 0, False: 0]
  ------------------
 1158|  13.7k|        (ns[3] == 'n') && (ns[4] == 's') && (ns[5] == 0)) {
  ------------------
  |  Branch (1158:9): [True: 0, False: 0]
  |  Branch (1158:27): [True: 0, False: 0]
  |  Branch (1158:45): [True: 0, False: 0]
  ------------------
 1159|      0|	xmlNsPtr nsret;
 1160|      0|	xmlChar *val;
 1161|       |
 1162|       |        /* Avoid unused variable warning if features are disabled. */
 1163|      0|        (void) nsret;
 1164|       |
 1165|      0|        if (!ctxt->replaceEntities) {
  ------------------
  |  Branch (1165:13): [True: 0, False: 0]
  ------------------
 1166|      0|	    ctxt->depth++;
 1167|      0|	    val = xmlStringDecodeEntities(ctxt, value, XML_SUBSTITUTE_REF,
  ------------------
  |  |  521|      0|#define XML_SUBSTITUTE_REF	1
  ------------------
 1168|      0|		                          0,0,0);
 1169|      0|	    ctxt->depth--;
 1170|      0|	    if (val == NULL) {
  ------------------
  |  Branch (1170:10): [True: 0, False: 0]
  ------------------
 1171|      0|	        xmlSAX2ErrMemory(ctxt, "xmlSAX2StartElement");
 1172|      0|	        xmlFree(ns);
 1173|      0|		if (name != NULL)
  ------------------
  |  Branch (1173:7): [True: 0, False: 0]
  ------------------
 1174|      0|		    xmlFree(name);
 1175|      0|                if (nval != NULL)
  ------------------
  |  Branch (1175:21): [True: 0, False: 0]
  ------------------
 1176|      0|                    xmlFree(nval);
 1177|      0|		return;
 1178|      0|	    }
 1179|      0|	} else {
 1180|      0|	    val = (xmlChar *) value;
 1181|      0|	}
 1182|       |
 1183|      0|	if (val[0] == 0) {
  ------------------
  |  Branch (1183:6): [True: 0, False: 0]
  ------------------
 1184|      0|	    xmlNsErrMsg(ctxt, XML_NS_ERR_EMPTY,
 1185|      0|		        "Empty namespace name for prefix %s\n", name, NULL);
 1186|      0|	}
 1187|      0|	if ((ctxt->pedantic != 0) && (val[0] != 0)) {
  ------------------
  |  Branch (1187:6): [True: 0, False: 0]
  |  Branch (1187:31): [True: 0, False: 0]
  ------------------
 1188|      0|	    xmlURIPtr uri;
 1189|       |
 1190|      0|	    uri = xmlParseURI((const char *)val);
 1191|      0|	    if (uri == NULL) {
  ------------------
  |  Branch (1191:10): [True: 0, False: 0]
  ------------------
 1192|      0|	        xmlNsWarnMsg(ctxt, XML_WAR_NS_URI,
 1193|      0|			 "xmlns:%s: %s not a valid URI\n", name, value);
 1194|      0|	    } else {
 1195|      0|		if (uri->scheme == NULL) {
  ------------------
  |  Branch (1195:7): [True: 0, False: 0]
  ------------------
 1196|      0|		    xmlNsWarnMsg(ctxt, XML_WAR_NS_URI_RELATIVE,
 1197|      0|			   "xmlns:%s: URI %s is not absolute\n", name, value);
 1198|      0|		}
 1199|      0|		xmlFreeURI(uri);
 1200|      0|	    }
 1201|      0|	}
 1202|       |
 1203|       |	/* a standard namespace definition */
 1204|      0|	nsret = xmlNewNs(ctxt->node, val, name);
 1205|      0|	xmlFree(ns);
 1206|      0|#ifdef LIBXML_VALID_ENABLED
 1207|       |	/*
 1208|       |	 * Validate also for namespace decls, they are attributes from
 1209|       |	 * an XML-1.0 perspective
 1210|       |	 */
 1211|      0|        if (nsret != NULL && ctxt->validate && ctxt->wellFormed &&
  ------------------
  |  Branch (1211:13): [True: 0, False: 0]
  |  Branch (1211:30): [True: 0, False: 0]
  |  Branch (1211:48): [True: 0, False: 0]
  ------------------
 1212|      0|	    ctxt->myDoc && ctxt->myDoc->intSubset)
  ------------------
  |  Branch (1212:6): [True: 0, False: 0]
  |  Branch (1212:21): [True: 0, False: 0]
  ------------------
 1213|      0|	    ctxt->valid &= xmlValidateOneNamespace(&ctxt->vctxt, ctxt->myDoc,
 1214|      0|					   ctxt->node, prefix, nsret, value);
 1215|      0|#endif /* LIBXML_VALID_ENABLED */
 1216|      0|	if (name != NULL)
  ------------------
  |  Branch (1216:6): [True: 0, False: 0]
  ------------------
 1217|      0|	    xmlFree(name);
 1218|      0|	if (nval != NULL)
  ------------------
  |  Branch (1218:6): [True: 0, False: 0]
  ------------------
 1219|      0|	    xmlFree(nval);
 1220|      0|	if (val != value)
  ------------------
  |  Branch (1220:6): [True: 0, False: 0]
  ------------------
 1221|      0|	    xmlFree(val);
 1222|      0|	return;
 1223|      0|    }
 1224|       |
 1225|  13.7k|    if (ns != NULL) {
  ------------------
  |  Branch (1225:9): [True: 0, False: 13.7k]
  ------------------
 1226|      0|	namespace = xmlSearchNs(ctxt->myDoc, ctxt->node, ns);
 1227|       |
 1228|      0|	if (namespace == NULL) {
  ------------------
  |  Branch (1228:6): [True: 0, False: 0]
  ------------------
 1229|      0|	    xmlNsErrMsg(ctxt, XML_NS_ERR_UNDEFINED_NAMESPACE,
 1230|      0|		    "Namespace prefix %s of attribute %s is not defined\n",
 1231|      0|		             ns, name);
 1232|      0|	} else {
 1233|      0|            xmlAttrPtr prop;
 1234|       |
 1235|      0|            prop = ctxt->node->properties;
 1236|      0|            while (prop != NULL) {
  ------------------
  |  Branch (1236:20): [True: 0, False: 0]
  ------------------
 1237|      0|                if (prop->ns != NULL) {
  ------------------
  |  Branch (1237:21): [True: 0, False: 0]
  ------------------
 1238|      0|                    if ((xmlStrEqual(name, prop->name)) &&
  ------------------
  |  Branch (1238:25): [True: 0, False: 0]
  ------------------
 1239|      0|                        ((namespace == prop->ns) ||
  ------------------
  |  Branch (1239:26): [True: 0, False: 0]
  ------------------
 1240|      0|                         (xmlStrEqual(namespace->href, prop->ns->href)))) {
  ------------------
  |  Branch (1240:26): [True: 0, False: 0]
  ------------------
 1241|      0|                            xmlNsErrMsg(ctxt, XML_ERR_ATTRIBUTE_REDEFINED,
 1242|      0|                                    "Attribute %s in %s redefined\n",
 1243|      0|                                             name, namespace->href);
 1244|      0|                        ctxt->wellFormed = 0;
 1245|      0|                        if (ctxt->recovery == 0) ctxt->disableSAX = 1;
  ------------------
  |  Branch (1245:29): [True: 0, False: 0]
  ------------------
 1246|      0|                        if (name != NULL)
  ------------------
  |  Branch (1246:29): [True: 0, False: 0]
  ------------------
 1247|      0|                            xmlFree(name);
 1248|      0|                        goto error;
 1249|      0|                    }
 1250|      0|                }
 1251|      0|                prop = prop->next;
 1252|      0|            }
 1253|      0|        }
 1254|  13.7k|    } else {
 1255|  13.7k|	namespace = NULL;
 1256|  13.7k|    }
 1257|       |
 1258|       |    /* !!!!!! <a toto:arg="" xmlns:toto="http://toto.com"> */
 1259|  13.7k|    ret = xmlNewNsPropEatName(ctxt->node, namespace, name, NULL);
 1260|  13.7k|    if (ret == NULL)
  ------------------
  |  Branch (1260:9): [True: 0, False: 13.7k]
  ------------------
 1261|      0|        goto error;
 1262|       |
 1263|  13.7k|    if ((ctxt->replaceEntities == 0) && (!ctxt->html)) {
  ------------------
  |  Branch (1263:9): [True: 13.7k, False: 0]
  |  Branch (1263:41): [True: 0, False: 13.7k]
  ------------------
 1264|      0|        xmlNodePtr tmp;
 1265|       |
 1266|      0|        ret->children = xmlStringGetNodeList(ctxt->myDoc, value);
 1267|      0|        tmp = ret->children;
 1268|      0|        while (tmp != NULL) {
  ------------------
  |  Branch (1268:16): [True: 0, False: 0]
  ------------------
 1269|      0|            tmp->parent = (xmlNodePtr) ret;
 1270|      0|            if (tmp->next == NULL)
  ------------------
  |  Branch (1270:17): [True: 0, False: 0]
  ------------------
 1271|      0|                ret->last = tmp;
 1272|      0|            tmp = tmp->next;
 1273|      0|        }
 1274|  13.7k|    } else if (value != NULL) {
  ------------------
  |  Branch (1274:16): [True: 13.6k, False: 10]
  ------------------
 1275|  13.6k|        ret->children = xmlNewDocText(ctxt->myDoc, value);
 1276|  13.6k|        ret->last = ret->children;
 1277|  13.6k|        if (ret->children != NULL)
  ------------------
  |  Branch (1277:13): [True: 13.6k, False: 0]
  ------------------
 1278|  13.6k|            ret->children->parent = (xmlNodePtr) ret;
 1279|  13.6k|    }
 1280|       |
 1281|  13.7k|#ifdef LIBXML_VALID_ENABLED
 1282|  13.7k|    if ((!ctxt->html) && ctxt->validate && ctxt->wellFormed &&
  ------------------
  |  Branch (1282:9): [True: 0, False: 13.7k]
  |  Branch (1282:26): [True: 0, False: 0]
  |  Branch (1282:44): [True: 0, False: 0]
  ------------------
 1283|  13.7k|        ctxt->myDoc && ctxt->myDoc->intSubset) {
  ------------------
  |  Branch (1283:9): [True: 0, False: 0]
  |  Branch (1283:24): [True: 0, False: 0]
  ------------------
 1284|       |
 1285|       |	/*
 1286|       |	 * If we don't substitute entities, the validation should be
 1287|       |	 * done on a value with replaced entities anyway.
 1288|       |	 */
 1289|      0|        if (!ctxt->replaceEntities) {
  ------------------
  |  Branch (1289:13): [True: 0, False: 0]
  ------------------
 1290|      0|	    xmlChar *val;
 1291|       |
 1292|      0|	    ctxt->depth++;
 1293|      0|	    val = xmlStringDecodeEntities(ctxt, value, XML_SUBSTITUTE_REF,
  ------------------
  |  |  521|      0|#define XML_SUBSTITUTE_REF	1
  ------------------
 1294|      0|		                          0,0,0);
 1295|      0|	    ctxt->depth--;
 1296|       |
 1297|      0|	    if (val == NULL)
  ------------------
  |  Branch (1297:10): [True: 0, False: 0]
  ------------------
 1298|      0|		ctxt->valid &= xmlValidateOneAttribute(&ctxt->vctxt,
 1299|      0|				ctxt->myDoc, ctxt->node, ret, value);
 1300|      0|	    else {
 1301|      0|		xmlChar *nvalnorm;
 1302|       |
 1303|       |		/*
 1304|       |		 * Do the last stage of the attribute normalization
 1305|       |		 * It need to be done twice ... it's an extra burden related
 1306|       |		 * to the ability to keep xmlSAX2References in attributes
 1307|       |		 */
 1308|      0|		nvalnorm = xmlValidNormalizeAttributeValue(ctxt->myDoc,
 1309|      0|					    ctxt->node, fullname, val);
 1310|      0|		if (nvalnorm != NULL) {
  ------------------
  |  Branch (1310:7): [True: 0, False: 0]
  ------------------
 1311|      0|		    xmlFree(val);
 1312|      0|		    val = nvalnorm;
 1313|      0|		}
 1314|       |
 1315|      0|		ctxt->valid &= xmlValidateOneAttribute(&ctxt->vctxt,
 1316|      0|			        ctxt->myDoc, ctxt->node, ret, val);
 1317|      0|                xmlFree(val);
 1318|      0|	    }
 1319|      0|	} else {
 1320|      0|	    ctxt->valid &= xmlValidateOneAttribute(&ctxt->vctxt, ctxt->myDoc,
 1321|      0|					       ctxt->node, ret, value);
 1322|      0|	}
 1323|      0|    } else
 1324|  13.7k|#endif /* LIBXML_VALID_ENABLED */
 1325|  13.7k|           if (((ctxt->loadsubset & XML_SKIP_IDS) == 0) &&
  ------------------
  |  |  158|  13.7k|#define XML_SKIP_IDS		8
  ------------------
  |  Branch (1325:16): [True: 13.7k, False: 0]
  ------------------
 1326|  13.7k|	       (((ctxt->replaceEntities == 0) && (ctxt->external != 2)) ||
  ------------------
  |  Branch (1326:11): [True: 13.7k, False: 0]
  |  Branch (1326:43): [True: 13.7k, False: 0]
  ------------------
 1327|  13.7k|	        ((ctxt->replaceEntities != 0) && (ctxt->inSubset == 0))) &&
  ------------------
  |  Branch (1327:11): [True: 0, False: 0]
  |  Branch (1327:43): [True: 0, False: 0]
  ------------------
 1328|       |               /* Don't create IDs containing entity references */
 1329|  13.7k|               (ret->children != NULL) &&
  ------------------
  |  Branch (1329:16): [True: 13.6k, False: 10]
  ------------------
 1330|  13.7k|               (ret->children->type == XML_TEXT_NODE) &&
  ------------------
  |  Branch (1330:16): [True: 13.6k, False: 0]
  ------------------
 1331|  13.7k|               (ret->children->next == NULL)) {
  ------------------
  |  Branch (1331:16): [True: 13.6k, False: 0]
  ------------------
 1332|  13.6k|        xmlChar *content = ret->children->content;
 1333|       |        /*
 1334|       |	 * when validating, the ID registration is done at the attribute
 1335|       |	 * validation level. Otherwise we have to do specific handling here.
 1336|       |	 */
 1337|  13.6k|	if (xmlStrEqual(fullname, BAD_CAST "xml:id")) {
  ------------------
  |  |   35|  13.6k|#define BAD_CAST (xmlChar *)
  ------------------
  |  Branch (1337:6): [True: 0, False: 13.6k]
  ------------------
 1338|       |	    /*
 1339|       |	     * Add the xml:id value
 1340|       |	     *
 1341|       |	     * Open issue: normalization of the value.
 1342|       |	     */
 1343|      0|	    if (xmlValidateNCName(content, 1) != 0) {
  ------------------
  |  Branch (1343:10): [True: 0, False: 0]
  ------------------
 1344|      0|	        xmlErrValid(ctxt, XML_DTD_XMLID_VALUE,
 1345|      0|		      "xml:id : attribute value %s is not an NCName\n",
 1346|      0|			    (const char *) content, NULL);
 1347|      0|	    }
 1348|      0|	    xmlAddID(&ctxt->vctxt, ctxt->myDoc, content, ret);
 1349|  13.6k|	} else if (xmlIsID(ctxt->myDoc, ctxt->node, ret))
  ------------------
  |  Branch (1349:13): [True: 210, False: 13.4k]
  ------------------
 1350|    210|	    xmlAddID(&ctxt->vctxt, ctxt->myDoc, content, ret);
 1351|  13.4k|	else if (xmlIsRef(ctxt->myDoc, ctxt->node, ret))
  ------------------
  |  Branch (1351:11): [True: 0, False: 13.4k]
  ------------------
 1352|      0|	    xmlAddRef(&ctxt->vctxt, ctxt->myDoc, content, ret);
 1353|  13.6k|    }
 1354|       |
 1355|  13.7k|error:
 1356|  13.7k|    if (nval != NULL)
  ------------------
  |  Branch (1356:9): [True: 40, False: 13.6k]
  ------------------
 1357|     40|	xmlFree(nval);
 1358|  13.7k|    if (ns != NULL)
  ------------------
  |  Branch (1358:9): [True: 0, False: 13.7k]
  ------------------
 1359|      0|	xmlFree(ns);
 1360|  13.7k|}
SAX2.c:xmlSAX2TextNode:
 1749|  10.3k|xmlSAX2TextNode(xmlParserCtxtPtr ctxt, const xmlChar *str, int len) {
 1750|  10.3k|    xmlNodePtr ret;
 1751|  10.3k|    const xmlChar *intern = NULL;
 1752|       |
 1753|       |    /*
 1754|       |     * Allocate
 1755|       |     */
 1756|  10.3k|    if (ctxt->freeElems != NULL) {
  ------------------
  |  Branch (1756:9): [True: 0, False: 10.3k]
  ------------------
 1757|      0|	ret = ctxt->freeElems;
 1758|      0|	ctxt->freeElems = ret->next;
 1759|      0|	ctxt->freeElemsNr--;
 1760|  10.3k|    } else {
 1761|  10.3k|	ret = (xmlNodePtr) xmlMalloc(sizeof(xmlNode));
 1762|  10.3k|    }
 1763|  10.3k|    if (ret == NULL) {
  ------------------
  |  Branch (1763:9): [True: 0, False: 10.3k]
  ------------------
 1764|      0|        xmlErrMemory(ctxt, "xmlSAX2Characters");
 1765|      0|	return(NULL);
 1766|      0|    }
 1767|  10.3k|    memset(ret, 0, sizeof(xmlNode));
 1768|       |    /*
 1769|       |     * intern the formatting blanks found between tags, or the
 1770|       |     * very short strings
 1771|       |     */
 1772|  10.3k|    if (ctxt->dictNames) {
  ------------------
  |  Branch (1772:9): [True: 0, False: 10.3k]
  ------------------
 1773|      0|        xmlChar cur = str[len];
 1774|       |
 1775|      0|	if ((len < (int) (2 * sizeof(void *))) &&
  ------------------
  |  Branch (1775:6): [True: 0, False: 0]
  ------------------
 1776|      0|	    (ctxt->options & XML_PARSE_COMPACT)) {
  ------------------
  |  Branch (1776:6): [True: 0, False: 0]
  ------------------
 1777|       |	    /* store the string in the node overriding properties and nsDef */
 1778|      0|	    xmlChar *tmp = (xmlChar *) &(ret->properties);
 1779|      0|	    memcpy(tmp, str, len);
 1780|      0|	    tmp[len] = 0;
 1781|      0|	    intern = tmp;
 1782|      0|	} else if ((len <= 3) && ((cur == '"') || (cur == '\'') ||
  ------------------
  |  Branch (1782:13): [True: 0, False: 0]
  |  Branch (1782:28): [True: 0, False: 0]
  |  Branch (1782:44): [True: 0, False: 0]
  ------------------
 1783|      0|	    ((cur == '<') && (str[len + 1] != '!')))) {
  ------------------
  |  Branch (1783:7): [True: 0, False: 0]
  |  Branch (1783:23): [True: 0, False: 0]
  ------------------
 1784|      0|	    intern = xmlDictLookup(ctxt->dict, str, len);
 1785|      0|	} else if (IS_BLANK_CH(*str) && (len < 60) && (cur == '<') &&
  ------------------
  |  |  151|      0|#define IS_BLANK_CH(c)  xmlIsBlank_ch(c)
  |  |  ------------------
  |  |  |  |   88|      0|#define xmlIsBlank_ch(c)	(((c) == 0x20) || \
  |  |  |  |  ------------------
  |  |  |  |  |  Branch (88:27): [True: 0, False: 0]
  |  |  |  |  ------------------
  |  |  |  |   89|      0|				 ((0x9 <= (c)) && ((c) <= 0xa)) || \
  |  |  |  |  ------------------
  |  |  |  |  |  Branch (89:7): [True: 0, False: 0]
  |  |  |  |  |  Branch (89:23): [True: 0, False: 0]
  |  |  |  |  ------------------
  |  |  |  |   90|      0|				 ((c) == 0xd))
  |  |  |  |  ------------------
  |  |  |  |  |  Branch (90:6): [True: 0, False: 0]
  |  |  |  |  ------------------
  |  |  ------------------
  ------------------
  |  Branch (1785:34): [True: 0, False: 0]
  |  Branch (1785:48): [True: 0, False: 0]
  ------------------
 1786|      0|	           (str[len + 1] != '!')) {
  ------------------
  |  Branch (1786:13): [True: 0, False: 0]
  ------------------
 1787|      0|	    int i;
 1788|       |
 1789|      0|	    for (i = 1;i < len;i++) {
  ------------------
  |  Branch (1789:17): [True: 0, False: 0]
  ------------------
 1790|      0|		if (!IS_BLANK_CH(str[i])) goto skip;
  ------------------
  |  |  151|      0|#define IS_BLANK_CH(c)  xmlIsBlank_ch(c)
  |  |  ------------------
  |  |  |  |   88|      0|#define xmlIsBlank_ch(c)	(((c) == 0x20) || \
  |  |  |  |  ------------------
  |  |  |  |  |  Branch (88:27): [True: 0, False: 0]
  |  |  |  |  ------------------
  |  |  |  |   89|      0|				 ((0x9 <= (c)) && ((c) <= 0xa)) || \
  |  |  |  |  ------------------
  |  |  |  |  |  Branch (89:7): [True: 0, False: 0]
  |  |  |  |  |  Branch (89:23): [True: 0, False: 0]
  |  |  |  |  ------------------
  |  |  |  |   90|      0|				 ((c) == 0xd))
  |  |  |  |  ------------------
  |  |  |  |  |  Branch (90:6): [True: 0, False: 0]
  |  |  |  |  ------------------
  |  |  ------------------
  ------------------
 1791|      0|	    }
 1792|      0|	    intern = xmlDictLookup(ctxt->dict, str, len);
 1793|      0|	}
 1794|      0|    }
 1795|  10.3k|skip:
 1796|  10.3k|    ret->type = XML_TEXT_NODE;
 1797|       |
 1798|  10.3k|    ret->name = xmlStringText;
 1799|  10.3k|    if (intern == NULL) {
  ------------------
  |  Branch (1799:9): [True: 10.3k, False: 0]
  ------------------
 1800|  10.3k|	ret->content = xmlStrndup(str, len);
 1801|  10.3k|	if (ret->content == NULL) {
  ------------------
  |  Branch (1801:6): [True: 0, False: 10.3k]
  ------------------
 1802|      0|	    xmlSAX2ErrMemory(ctxt, "xmlSAX2TextNode");
 1803|      0|	    xmlFree(ret);
 1804|      0|	    return(NULL);
 1805|      0|	}
 1806|  10.3k|    } else
 1807|      0|	ret->content = (xmlChar *) intern;
 1808|       |
 1809|  10.3k|    if ((__xmlRegisterCallbacks) && (xmlRegisterNodeDefaultValue))
  ------------------
  |  |  682|      0|    XML_GLOBAL_MACRO(xmlRegisterNodeDefaultValue)
  |  |  ------------------
  |  |  |  |  500|      0|  #define XML_GLOBAL_MACRO(name) (*__##name())
  |  |  ------------------
  ------------------
  |  Branch (1809:9): [True: 0, False: 10.3k]
  |  Branch (1809:37): [True: 0, False: 0]
  ------------------
 1810|      0|	xmlRegisterNodeDefaultValue(ret);
  ------------------
  |  |  682|      0|    XML_GLOBAL_MACRO(xmlRegisterNodeDefaultValue)
  |  |  ------------------
  |  |  |  |  500|      0|  #define XML_GLOBAL_MACRO(name) (*__##name())
  |  |  ------------------
  ------------------
 1811|  10.3k|    return(ret);
 1812|  10.3k|}
SAX2.c:xmlSAX2Text:
 2404|  11.9k|{
 2405|  11.9k|    xmlNodePtr lastChild;
 2406|       |
 2407|  11.9k|    if (ctxt == NULL) return;
  ------------------
  |  Branch (2407:9): [True: 0, False: 11.9k]
  ------------------
 2408|       |    /*
 2409|       |     * Handle the data if any. If there is no child
 2410|       |     * add it as content, otherwise if the last child is text,
 2411|       |     * concatenate it, else create a new node of type text.
 2412|       |     */
 2413|       |
 2414|  11.9k|    if (ctxt->node == NULL) {
  ------------------
  |  Branch (2414:9): [True: 114, False: 11.8k]
  ------------------
 2415|    114|        return;
 2416|    114|    }
 2417|  11.8k|    lastChild = ctxt->node->last;
 2418|       |
 2419|       |    /*
 2420|       |     * Here we needed an accelerator mechanism in case of very large
 2421|       |     * elements. Use an attribute in the structure !!!
 2422|       |     */
 2423|  11.8k|    if (lastChild == NULL) {
  ------------------
  |  Branch (2423:9): [True: 5.59k, False: 6.28k]
  ------------------
 2424|  5.59k|        if (type == XML_TEXT_NODE)
  ------------------
  |  Branch (2424:13): [True: 5.55k, False: 44]
  ------------------
 2425|  5.55k|            lastChild = xmlSAX2TextNode(ctxt, ch, len);
 2426|     44|        else
 2427|     44|            lastChild = xmlNewCDataBlock(ctxt->myDoc, ch, len);
 2428|  5.59k|	if (lastChild != NULL) {
  ------------------
  |  Branch (2428:6): [True: 5.59k, False: 0]
  ------------------
 2429|  5.59k|	    ctxt->node->children = lastChild;
 2430|  5.59k|	    ctxt->node->last = lastChild;
 2431|  5.59k|	    lastChild->parent = ctxt->node;
 2432|  5.59k|	    lastChild->doc = ctxt->node->doc;
 2433|  5.59k|	    ctxt->nodelen = len;
 2434|  5.59k|	    ctxt->nodemem = len + 1;
 2435|  5.59k|	} else {
 2436|      0|	    xmlSAX2ErrMemory(ctxt, "xmlSAX2Characters");
 2437|      0|	    return;
 2438|      0|	}
 2439|  6.28k|    } else {
 2440|  6.28k|	int coalesceText = (lastChild != NULL) &&
  ------------------
  |  Branch (2440:21): [True: 6.28k, False: 0]
  ------------------
 2441|  6.28k|	    (lastChild->type == type) &&
  ------------------
  |  Branch (2441:6): [True: 1.45k, False: 4.83k]
  ------------------
 2442|  6.28k|	    ((type != XML_TEXT_NODE) ||
  ------------------
  |  Branch (2442:7): [True: 26, False: 1.42k]
  ------------------
 2443|  1.45k|             (lastChild->name == xmlStringText));
  ------------------
  |  Branch (2443:14): [True: 1.42k, False: 0]
  ------------------
 2444|  6.28k|	if ((coalesceText) && (ctxt->nodemem != 0)) {
  ------------------
  |  Branch (2444:6): [True: 1.45k, False: 4.83k]
  |  Branch (2444:24): [True: 1.45k, False: 0]
  ------------------
 2445|       |	    /*
 2446|       |	     * The whole point of maintaining nodelen and nodemem,
 2447|       |	     * xmlTextConcat is too costly, i.e. compute length,
 2448|       |	     * reallocate a new buffer, move data, append ch. Here
 2449|       |	     * We try to minimize realloc() uses and avoid copying
 2450|       |	     * and recomputing length over and over.
 2451|       |	     */
 2452|  1.45k|	    if (lastChild->content == (xmlChar *)&(lastChild->properties)) {
  ------------------
  |  Branch (2452:10): [True: 0, False: 1.45k]
  ------------------
 2453|      0|		lastChild->content = xmlStrdup(lastChild->content);
 2454|      0|		lastChild->properties = NULL;
 2455|  1.45k|	    } else if ((ctxt->nodemem == ctxt->nodelen + 1) &&
  ------------------
  |  Branch (2455:17): [True: 560, False: 893]
  ------------------
 2456|  1.45k|	               (xmlDictOwns(ctxt->dict, lastChild->content))) {
  ------------------
  |  Branch (2456:17): [True: 0, False: 560]
  ------------------
 2457|      0|		lastChild->content = xmlStrdup(lastChild->content);
 2458|      0|	    }
 2459|  1.45k|	    if (lastChild->content == NULL) {
  ------------------
  |  Branch (2459:10): [True: 0, False: 1.45k]
  ------------------
 2460|      0|		xmlSAX2ErrMemory(ctxt, "xmlSAX2Characters: xmlStrdup returned NULL");
 2461|      0|		return;
 2462|      0| 	    }
 2463|  1.45k|	    if (ctxt->nodelen > INT_MAX - len) {
  ------------------
  |  Branch (2463:10): [True: 0, False: 1.45k]
  ------------------
 2464|      0|                xmlSAX2ErrMemory(ctxt, "xmlSAX2Characters overflow prevented");
 2465|      0|                return;
 2466|      0|	    }
 2467|  1.45k|            if ((ctxt->nodelen + len > XML_MAX_TEXT_LENGTH) &&
  ------------------
  |  |   42|  1.45k|#define XML_MAX_TEXT_LENGTH 10000000
  ------------------
  |  Branch (2467:17): [True: 0, False: 1.45k]
  ------------------
 2468|  1.45k|                ((ctxt->options & XML_PARSE_HUGE) == 0)) {
  ------------------
  |  Branch (2468:17): [True: 0, False: 0]
  ------------------
 2469|      0|                xmlSAX2ErrMemory(ctxt, "xmlSAX2Characters: huge text node");
 2470|      0|                return;
 2471|      0|            }
 2472|  1.45k|	    if (ctxt->nodelen + len >= ctxt->nodemem) {
  ------------------
  |  Branch (2472:10): [True: 713, False: 740]
  ------------------
 2473|    713|		xmlChar *newbuf;
 2474|    713|		int size;
 2475|       |
 2476|    713|		size = ctxt->nodemem > INT_MAX - len ?
  ------------------
  |  Branch (2476:10): [True: 0, False: 713]
  ------------------
 2477|      0|                       INT_MAX :
 2478|    713|                       ctxt->nodemem + len;
 2479|    713|		size = size > INT_MAX / 2 ? INT_MAX : size * 2;
  ------------------
  |  Branch (2479:10): [True: 0, False: 713]
  ------------------
 2480|    713|                newbuf = (xmlChar *) xmlRealloc(lastChild->content,size);
 2481|    713|		if (newbuf == NULL) {
  ------------------
  |  Branch (2481:7): [True: 0, False: 713]
  ------------------
 2482|      0|		    xmlSAX2ErrMemory(ctxt, "xmlSAX2Characters");
 2483|      0|		    return;
 2484|      0|		}
 2485|    713|		ctxt->nodemem = size;
 2486|    713|		lastChild->content = newbuf;
 2487|    713|	    }
 2488|  1.45k|	    memcpy(&lastChild->content[ctxt->nodelen], ch, len);
 2489|  1.45k|	    ctxt->nodelen += len;
 2490|  1.45k|	    lastChild->content[ctxt->nodelen] = 0;
 2491|  4.83k|	} else if (coalesceText) {
  ------------------
  |  Branch (2491:13): [True: 0, False: 4.83k]
  ------------------
 2492|      0|	    if (xmlTextConcat(lastChild, ch, len)) {
  ------------------
  |  Branch (2492:10): [True: 0, False: 0]
  ------------------
 2493|      0|		xmlSAX2ErrMemory(ctxt, "xmlSAX2Characters");
 2494|      0|	    }
 2495|      0|	    if (ctxt->node->children != NULL) {
  ------------------
  |  Branch (2495:10): [True: 0, False: 0]
  ------------------
 2496|      0|		ctxt->nodelen = xmlStrlen(lastChild->content);
 2497|      0|		ctxt->nodemem = ctxt->nodelen + 1;
 2498|      0|	    }
 2499|  4.83k|	} else {
 2500|       |	    /* Mixed content, first time */
 2501|  4.83k|            if (type == XML_TEXT_NODE) {
  ------------------
  |  Branch (2501:17): [True: 4.83k, False: 0]
  ------------------
 2502|  4.83k|                lastChild = xmlSAX2TextNode(ctxt, ch, len);
 2503|  4.83k|                if (lastChild != NULL)
  ------------------
  |  Branch (2503:21): [True: 4.83k, False: 0]
  ------------------
 2504|  4.83k|                    lastChild->doc = ctxt->myDoc;
 2505|  4.83k|            } else
 2506|      0|                lastChild = xmlNewCDataBlock(ctxt->myDoc, ch, len);
 2507|  4.83k|	    if (lastChild != NULL) {
  ------------------
  |  Branch (2507:10): [True: 4.83k, False: 0]
  ------------------
 2508|  4.83k|		xmlAddChild(ctxt->node, lastChild);
 2509|  4.83k|		if (ctxt->node->children != NULL) {
  ------------------
  |  Branch (2509:7): [True: 4.83k, False: 0]
  ------------------
 2510|  4.83k|		    ctxt->nodelen = len;
 2511|  4.83k|		    ctxt->nodemem = len + 1;
 2512|  4.83k|		}
 2513|  4.83k|	    }
 2514|  4.83k|	}
 2515|  6.28k|    }
 2516|       |
 2517|  11.8k|    if ((lastChild != NULL) &&
  ------------------
  |  Branch (2517:9): [True: 11.8k, False: 0]
  ------------------
 2518|  11.8k|        (type == XML_TEXT_NODE) &&
  ------------------
  |  Branch (2518:9): [True: 11.8k, False: 70]
  ------------------
 2519|  11.8k|        (ctxt->linenumbers) &&
  ------------------
  |  Branch (2519:9): [True: 11.8k, False: 0]
  ------------------
 2520|  11.8k|        (ctxt->input != NULL)) {
  ------------------
  |  Branch (2520:9): [True: 11.8k, False: 0]
  ------------------
 2521|  11.8k|        if ((unsigned) ctxt->input->line < (unsigned) USHRT_MAX)
  ------------------
  |  Branch (2521:13): [True: 11.8k, False: 0]
  ------------------
 2522|  11.8k|            lastChild->line = ctxt->input->line;
 2523|      0|        else {
 2524|      0|            lastChild->line = USHRT_MAX;
 2525|      0|            if (ctxt->options & XML_PARSE_BIG_LINES)
  ------------------
  |  Branch (2525:17): [True: 0, False: 0]
  ------------------
 2526|      0|                lastChild->psvi = (void *) (ptrdiff_t) ctxt->input->line;
 2527|      0|        }
 2528|  11.8k|    }
 2529|  11.8k|}

xmlBufCreate:
  122|    147|xmlBufCreate(void) {
  123|    147|    xmlBufPtr ret;
  124|       |
  125|    147|    ret = (xmlBufPtr) xmlMalloc(sizeof(xmlBuf));
  126|    147|    if (ret == NULL) {
  ------------------
  |  Branch (126:9): [True: 2, False: 145]
  ------------------
  127|      2|	xmlBufMemoryError(NULL, "creating buffer");
  128|      2|        return(NULL);
  129|      2|    }
  130|    145|    ret->use = 0;
  131|    145|    ret->error = 0;
  132|    145|    ret->buffer = NULL;
  133|    145|    ret->size = xmlDefaultBufferSize;
  ------------------
  |  |  680|    145|  #define xmlDefaultBufferSize XML_GLOBAL_MACRO(xmlDefaultBufferSize)
  |  |  ------------------
  |  |  |  |  500|    145|  #define XML_GLOBAL_MACRO(name) (*__##name())
  |  |  ------------------
  ------------------
  134|    145|    UPDATE_COMPAT(ret);
  ------------------
  |  |   61|    145|     if (buf->size < INT_MAX) buf->compat_size = buf->size; \
  |  |  ------------------
  |  |  |  Branch (61:10): [True: 145, False: 0]
  |  |  ------------------
  |  |   62|    145|     else buf->compat_size = INT_MAX;			    \
  |  |   63|    145|     if (buf->use < INT_MAX) buf->compat_use = buf->use; \
  |  |  ------------------
  |  |  |  Branch (63:10): [True: 145, False: 0]
  |  |  ------------------
  |  |   64|    145|     else buf->compat_use = INT_MAX;
  ------------------
  135|    145|    ret->alloc = xmlBufferAllocScheme;
  ------------------
  |  |  679|    145|  #define xmlBufferAllocScheme XML_GLOBAL_MACRO(xmlBufferAllocScheme)
  |  |  ------------------
  |  |  |  |  500|    145|  #define XML_GLOBAL_MACRO(name) (*__##name())
  |  |  ------------------
  ------------------
  136|    145|    ret->content = (xmlChar *) xmlMallocAtomic(ret->size);
  137|    145|    if (ret->content == NULL) {
  ------------------
  |  Branch (137:9): [True: 0, False: 145]
  ------------------
  138|      0|	xmlBufMemoryError(ret, "creating buffer");
  139|      0|	xmlFree(ret);
  140|      0|        return(NULL);
  141|      0|    }
  142|    145|    ret->content[0] = 0;
  143|    145|    ret->contentIO = NULL;
  144|    145|    return(ret);
  145|    145|}
xmlBufCreateSize:
  155|    190|xmlBufCreateSize(size_t size) {
  156|    190|    xmlBufPtr ret;
  157|       |
  158|    190|    if (size == SIZE_MAX)
  ------------------
  |  |   30|    190|#define SIZE_MAX ((size_t) -1)
  ------------------
  |  Branch (158:9): [True: 0, False: 190]
  ------------------
  159|      0|        return(NULL);
  160|    190|    ret = (xmlBufPtr) xmlMalloc(sizeof(xmlBuf));
  161|    190|    if (ret == NULL) {
  ------------------
  |  Branch (161:9): [True: 3, False: 187]
  ------------------
  162|      3|	xmlBufMemoryError(NULL, "creating buffer");
  163|      3|        return(NULL);
  164|      3|    }
  165|    187|    ret->use = 0;
  166|    187|    ret->error = 0;
  167|    187|    ret->buffer = NULL;
  168|    187|    ret->alloc = xmlBufferAllocScheme;
  ------------------
  |  |  679|    187|  #define xmlBufferAllocScheme XML_GLOBAL_MACRO(xmlBufferAllocScheme)
  |  |  ------------------
  |  |  |  |  500|    187|  #define XML_GLOBAL_MACRO(name) (*__##name())
  |  |  ------------------
  ------------------
  169|    187|    ret->size = (size ? size + 1 : 0);         /* +1 for ending null */
  ------------------
  |  Branch (169:18): [True: 187, False: 0]
  ------------------
  170|    187|    UPDATE_COMPAT(ret);
  ------------------
  |  |   61|    187|     if (buf->size < INT_MAX) buf->compat_size = buf->size; \
  |  |  ------------------
  |  |  |  Branch (61:10): [True: 187, False: 0]
  |  |  ------------------
  |  |   62|    187|     else buf->compat_size = INT_MAX;			    \
  |  |   63|    187|     if (buf->use < INT_MAX) buf->compat_use = buf->use; \
  |  |  ------------------
  |  |  |  Branch (63:10): [True: 187, False: 0]
  |  |  ------------------
  |  |   64|    187|     else buf->compat_use = INT_MAX;
  ------------------
  171|    187|    if (ret->size){
  ------------------
  |  Branch (171:9): [True: 187, False: 0]
  ------------------
  172|    187|        ret->content = (xmlChar *) xmlMallocAtomic(ret->size);
  173|    187|        if (ret->content == NULL) {
  ------------------
  |  Branch (173:13): [True: 0, False: 187]
  ------------------
  174|      0|	    xmlBufMemoryError(ret, "creating buffer");
  175|      0|            xmlFree(ret);
  176|      0|            return(NULL);
  177|      0|        }
  178|    187|        ret->content[0] = 0;
  179|    187|    } else
  180|      0|	ret->content = NULL;
  181|    187|    ret->contentIO = NULL;
  182|    187|    return(ret);
  183|    187|}
xmlBufSetAllocationScheme:
  242|    276|                          xmlBufferAllocationScheme scheme) {
  243|    276|    if ((buf == NULL) || (buf->error != 0)) {
  ------------------
  |  Branch (243:9): [True: 0, False: 276]
  |  Branch (243:26): [True: 0, False: 276]
  ------------------
  244|      0|        return(-1);
  245|      0|    }
  246|    276|    if (buf->alloc == XML_BUFFER_ALLOC_IO)
  ------------------
  |  Branch (246:9): [True: 0, False: 276]
  ------------------
  247|      0|        return(-1);
  248|    276|    if ((scheme == XML_BUFFER_ALLOC_DOUBLEIT) ||
  ------------------
  |  Branch (248:9): [True: 276, False: 0]
  ------------------
  249|    276|        (scheme == XML_BUFFER_ALLOC_EXACT) ||
  ------------------
  |  Branch (249:9): [True: 0, False: 0]
  ------------------
  250|    276|        (scheme == XML_BUFFER_ALLOC_HYBRID) ||
  ------------------
  |  Branch (250:9): [True: 0, False: 0]
  ------------------
  251|    276|	(scheme == XML_BUFFER_ALLOC_BOUNDED)) {
  ------------------
  |  Branch (251:2): [True: 0, False: 0]
  ------------------
  252|    276|	buf->alloc = scheme;
  253|    276|        if (buf->buffer)
  ------------------
  |  Branch (253:13): [True: 0, False: 276]
  ------------------
  254|      0|            buf->buffer->alloc = scheme;
  255|    276|        return(0);
  256|    276|    }
  257|       |    /*
  258|       |     * Switching a buffer ALLOC_IO has the side effect of initializing
  259|       |     * the contentIO field with the current content
  260|       |     */
  261|      0|    if (scheme == XML_BUFFER_ALLOC_IO) {
  ------------------
  |  Branch (261:9): [True: 0, False: 0]
  ------------------
  262|      0|        buf->alloc = XML_BUFFER_ALLOC_IO;
  263|      0|        buf->contentIO = buf->content;
  264|      0|    }
  265|      0|    return(-1);
  266|    276|}
xmlBufFree:
  276|    332|xmlBufFree(xmlBufPtr buf) {
  277|    332|    if (buf == NULL) {
  ------------------
  |  Branch (277:9): [True: 0, False: 332]
  ------------------
  278|      0|	return;
  279|      0|    }
  280|       |
  281|    332|    if ((buf->alloc == XML_BUFFER_ALLOC_IO) &&
  ------------------
  |  Branch (281:9): [True: 0, False: 332]
  ------------------
  282|    332|        (buf->contentIO != NULL)) {
  ------------------
  |  Branch (282:9): [True: 0, False: 0]
  ------------------
  283|      0|        xmlFree(buf->contentIO);
  284|    332|    } else if (buf->content != NULL) {
  ------------------
  |  Branch (284:16): [True: 332, False: 0]
  ------------------
  285|    332|        xmlFree(buf->content);
  286|    332|    }
  287|    332|    xmlFree(buf);
  288|    332|}
xmlBufShrink:
  328|  2.10k|xmlBufShrink(xmlBufPtr buf, size_t len) {
  329|  2.10k|    if ((buf == NULL) || (buf->error != 0)) return(0);
  ------------------
  |  Branch (329:9): [True: 0, False: 2.10k]
  |  Branch (329:26): [True: 0, False: 2.10k]
  ------------------
  330|  2.10k|    CHECK_COMPAT(buf)
  ------------------
  |  |   72|  2.10k|     if (buf->size != (size_t) buf->compat_size)	    \
  |  |  ------------------
  |  |  |  Branch (72:10): [True: 0, False: 2.10k]
  |  |  ------------------
  |  |   73|  2.10k|         if (buf->compat_size < INT_MAX)		    \
  |  |  ------------------
  |  |  |  Branch (73:14): [True: 0, False: 0]
  |  |  ------------------
  |  |   74|      0|	     buf->size = buf->compat_size;		    \
  |  |   75|  2.10k|     if (buf->use != (size_t) buf->compat_use)		    \
  |  |  ------------------
  |  |  |  Branch (75:10): [True: 0, False: 2.10k]
  |  |  ------------------
  |  |   76|  2.10k|         if (buf->compat_use < INT_MAX)			    \
  |  |  ------------------
  |  |  |  Branch (76:14): [True: 0, False: 0]
  |  |  ------------------
  |  |   77|      0|	     buf->use = buf->compat_use;
  ------------------
  331|  2.10k|    if (len == 0) return(0);
  ------------------
  |  Branch (331:9): [True: 1, False: 2.10k]
  ------------------
  332|  2.10k|    if (len > buf->use) return(0);
  ------------------
  |  Branch (332:9): [True: 0, False: 2.10k]
  ------------------
  333|       |
  334|  2.10k|    buf->use -= len;
  335|  2.10k|    if ((buf->alloc == XML_BUFFER_ALLOC_IO) && (buf->contentIO != NULL)) {
  ------------------
  |  Branch (335:9): [True: 0, False: 2.10k]
  |  Branch (335:48): [True: 0, False: 0]
  ------------------
  336|       |	/*
  337|       |	 * we just move the content pointer, but also make sure
  338|       |	 * the perceived buffer size has shrunk accordingly
  339|       |	 */
  340|      0|        buf->content += len;
  341|      0|	buf->size -= len;
  342|       |
  343|       |        /*
  344|       |	 * sometimes though it maybe be better to really shrink
  345|       |	 * on IO buffers
  346|       |	 */
  347|      0|	if ((buf->alloc == XML_BUFFER_ALLOC_IO) && (buf->contentIO != NULL)) {
  ------------------
  |  Branch (347:6): [True: 0, False: 0]
  |  Branch (347:45): [True: 0, False: 0]
  ------------------
  348|      0|	    size_t start_buf = buf->content - buf->contentIO;
  349|      0|	    if (start_buf >= buf->size) {
  ------------------
  |  Branch (349:10): [True: 0, False: 0]
  ------------------
  350|      0|		memmove(buf->contentIO, &buf->content[0], buf->use);
  351|      0|		buf->content = buf->contentIO;
  352|      0|		buf->content[buf->use] = 0;
  353|      0|		buf->size += start_buf;
  354|      0|	    }
  355|      0|	}
  356|  2.10k|    } else {
  357|  2.10k|	memmove(buf->content, &buf->content[len], buf->use);
  358|  2.10k|	buf->content[buf->use] = 0;
  359|  2.10k|    }
  360|  2.10k|    UPDATE_COMPAT(buf)
  ------------------
  |  |   61|  2.10k|     if (buf->size < INT_MAX) buf->compat_size = buf->size; \
  |  |  ------------------
  |  |  |  Branch (61:10): [True: 2.10k, False: 0]
  |  |  ------------------
  |  |   62|  2.10k|     else buf->compat_size = INT_MAX;			    \
  |  |   63|  2.10k|     if (buf->use < INT_MAX) buf->compat_use = buf->use; \
  |  |  ------------------
  |  |  |  Branch (63:10): [True: 2.10k, False: 0]
  |  |  ------------------
  |  |   64|  2.10k|     else buf->compat_use = INT_MAX;
  ------------------
  361|  2.10k|    return(len);
  362|  2.10k|}
xmlBufGrow:
  443|  15.0k|xmlBufGrow(xmlBufPtr buf, int len) {
  444|  15.0k|    size_t ret;
  445|       |
  446|  15.0k|    if ((buf == NULL) || (len < 0)) return(-1);
  ------------------
  |  Branch (446:9): [True: 0, False: 15.0k]
  |  Branch (446:26): [True: 0, False: 15.0k]
  ------------------
  447|  15.0k|    if (len == 0)
  ------------------
  |  Branch (447:9): [True: 0, False: 15.0k]
  ------------------
  448|      0|        return(0);
  449|  15.0k|    ret = xmlBufGrowInternal(buf, len);
  450|  15.0k|    if (buf->error != 0)
  ------------------
  |  Branch (450:9): [True: 0, False: 15.0k]
  ------------------
  451|      0|        return(-1);
  452|  15.0k|    return(ret > INT_MAX ? INT_MAX : ret);
  ------------------
  |  Branch (452:12): [True: 0, False: 15.0k]
  ------------------
  453|  15.0k|}
xmlBufContent:
  491|  1.93k|{
  492|  1.93k|    if ((!buf) || (buf->error))
  ------------------
  |  Branch (492:9): [True: 0, False: 1.93k]
  |  Branch (492:19): [True: 0, False: 1.93k]
  ------------------
  493|      0|        return NULL;
  494|       |
  495|  1.93k|    return(buf->content);
  496|  1.93k|}
xmlBufEnd:
  509|  16.8k|{
  510|  16.8k|    if ((!buf) || (buf->error))
  ------------------
  |  Branch (510:9): [True: 0, False: 16.8k]
  |  Branch (510:19): [True: 0, False: 16.8k]
  ------------------
  511|      0|        return NULL;
  512|  16.8k|    CHECK_COMPAT(buf)
  ------------------
  |  |   72|  16.8k|     if (buf->size != (size_t) buf->compat_size)	    \
  |  |  ------------------
  |  |  |  Branch (72:10): [True: 0, False: 16.8k]
  |  |  ------------------
  |  |   73|  16.8k|         if (buf->compat_size < INT_MAX)		    \
  |  |  ------------------
  |  |  |  Branch (73:14): [True: 0, False: 0]
  |  |  ------------------
  |  |   74|      0|	     buf->size = buf->compat_size;		    \
  |  |   75|  16.8k|     if (buf->use != (size_t) buf->compat_use)		    \
  |  |  ------------------
  |  |  |  Branch (75:10): [True: 0, False: 16.8k]
  |  |  ------------------
  |  |   76|  16.8k|         if (buf->compat_use < INT_MAX)			    \
  |  |  ------------------
  |  |  |  Branch (76:14): [True: 0, False: 0]
  |  |  ------------------
  |  |   77|      0|	     buf->use = buf->compat_use;
  ------------------
  513|       |
  514|  16.8k|    return(&buf->content[buf->use]);
  515|  16.8k|}
xmlBufAddLen:
  529|  16.8k|xmlBufAddLen(xmlBufPtr buf, size_t len) {
  530|  16.8k|    if ((buf == NULL) || (buf->error))
  ------------------
  |  Branch (530:9): [True: 0, False: 16.8k]
  |  Branch (530:26): [True: 0, False: 16.8k]
  ------------------
  531|      0|        return(-1);
  532|  16.8k|    CHECK_COMPAT(buf)
  ------------------
  |  |   72|  16.8k|     if (buf->size != (size_t) buf->compat_size)	    \
  |  |  ------------------
  |  |  |  Branch (72:10): [True: 0, False: 16.8k]
  |  |  ------------------
  |  |   73|  16.8k|         if (buf->compat_size < INT_MAX)		    \
  |  |  ------------------
  |  |  |  Branch (73:14): [True: 0, False: 0]
  |  |  ------------------
  |  |   74|      0|	     buf->size = buf->compat_size;		    \
  |  |   75|  16.8k|     if (buf->use != (size_t) buf->compat_use)		    \
  |  |  ------------------
  |  |  |  Branch (75:10): [True: 0, False: 16.8k]
  |  |  ------------------
  |  |   76|  16.8k|         if (buf->compat_use < INT_MAX)			    \
  |  |  ------------------
  |  |  |  Branch (76:14): [True: 0, False: 0]
  |  |  ------------------
  |  |   77|      0|	     buf->use = buf->compat_use;
  ------------------
  533|  16.8k|    if (len >= (buf->size - buf->use))
  ------------------
  |  Branch (533:9): [True: 0, False: 16.8k]
  ------------------
  534|      0|        return(-1);
  535|  16.8k|    buf->use += len;
  536|  16.8k|    buf->content[buf->use] = 0;
  537|  16.8k|    UPDATE_COMPAT(buf)
  ------------------
  |  |   61|  16.8k|     if (buf->size < INT_MAX) buf->compat_size = buf->size; \
  |  |  ------------------
  |  |  |  Branch (61:10): [True: 16.8k, False: 0]
  |  |  ------------------
  |  |   62|  16.8k|     else buf->compat_size = INT_MAX;			    \
  |  |   63|  16.8k|     if (buf->use < INT_MAX) buf->compat_use = buf->use; \
  |  |  ------------------
  |  |  |  Branch (63:10): [True: 16.8k, False: 0]
  |  |  ------------------
  |  |   64|  16.8k|     else buf->compat_use = INT_MAX;
  ------------------
  538|  16.8k|    return(0);
  539|  16.8k|}
xmlBufUse:
  571|  6.91k|{
  572|  6.91k|    if ((!buf) || (buf->error))
  ------------------
  |  Branch (572:9): [True: 0, False: 6.91k]
  |  Branch (572:19): [True: 0, False: 6.91k]
  ------------------
  573|      0|        return 0;
  574|  6.91k|    CHECK_COMPAT(buf)
  ------------------
  |  |   72|  6.91k|     if (buf->size != (size_t) buf->compat_size)	    \
  |  |  ------------------
  |  |  |  Branch (72:10): [True: 0, False: 6.91k]
  |  |  ------------------
  |  |   73|  6.91k|         if (buf->compat_size < INT_MAX)		    \
  |  |  ------------------
  |  |  |  Branch (73:14): [True: 0, False: 0]
  |  |  ------------------
  |  |   74|      0|	     buf->size = buf->compat_size;		    \
  |  |   75|  6.91k|     if (buf->use != (size_t) buf->compat_use)		    \
  |  |  ------------------
  |  |  |  Branch (75:10): [True: 0, False: 6.91k]
  |  |  ------------------
  |  |   76|  6.91k|         if (buf->compat_use < INT_MAX)			    \
  |  |  ------------------
  |  |  |  Branch (76:14): [True: 0, False: 0]
  |  |  ------------------
  |  |   77|      0|	     buf->use = buf->compat_use;
  ------------------
  575|       |
  576|  6.91k|    return(buf->use);
  577|  6.91k|}
xmlBufAvail:
  593|  2.04k|{
  594|  2.04k|    if ((!buf) || (buf->error))
  ------------------
  |  Branch (594:9): [True: 0, False: 2.04k]
  |  Branch (594:19): [True: 0, False: 2.04k]
  ------------------
  595|      0|        return 0;
  596|  2.04k|    CHECK_COMPAT(buf)
  ------------------
  |  |   72|  2.04k|     if (buf->size != (size_t) buf->compat_size)	    \
  |  |  ------------------
  |  |  |  Branch (72:10): [True: 0, False: 2.04k]
  |  |  ------------------
  |  |   73|  2.04k|         if (buf->compat_size < INT_MAX)		    \
  |  |  ------------------
  |  |  |  Branch (73:14): [True: 0, False: 0]
  |  |  ------------------
  |  |   74|      0|	     buf->size = buf->compat_size;		    \
  |  |   75|  2.04k|     if (buf->use != (size_t) buf->compat_use)		    \
  |  |  ------------------
  |  |  |  Branch (75:10): [True: 0, False: 2.04k]
  |  |  ------------------
  |  |   76|  2.04k|         if (buf->compat_use < INT_MAX)			    \
  |  |  ------------------
  |  |  |  Branch (76:14): [True: 0, False: 0]
  |  |  ------------------
  |  |   77|      0|	     buf->use = buf->compat_use;
  ------------------
  597|       |
  598|  2.04k|    return((buf->size > buf->use) ? (buf->size - buf->use - 1) : 0);
  ------------------
  |  Branch (598:12): [True: 2.04k, False: 0]
  ------------------
  599|  2.04k|}
xmlBufIsEmpty:
  611|     57|{
  612|     57|    if ((!buf) || (buf->error))
  ------------------
  |  Branch (612:9): [True: 0, False: 57]
  |  Branch (612:19): [True: 0, False: 57]
  ------------------
  613|      0|        return(-1);
  614|     57|    CHECK_COMPAT(buf)
  ------------------
  |  |   72|     57|     if (buf->size != (size_t) buf->compat_size)	    \
  |  |  ------------------
  |  |  |  Branch (72:10): [True: 0, False: 57]
  |  |  ------------------
  |  |   73|     57|         if (buf->compat_size < INT_MAX)		    \
  |  |  ------------------
  |  |  |  Branch (73:14): [True: 0, False: 0]
  |  |  ------------------
  |  |   74|      0|	     buf->size = buf->compat_size;		    \
  |  |   75|     57|     if (buf->use != (size_t) buf->compat_use)		    \
  |  |  ------------------
  |  |  |  Branch (75:10): [True: 0, False: 57]
  |  |  ------------------
  |  |   76|     57|         if (buf->compat_use < INT_MAX)			    \
  |  |  ------------------
  |  |  |  Branch (76:14): [True: 0, False: 0]
  |  |  ------------------
  |  |   77|      0|	     buf->use = buf->compat_use;
  ------------------
  615|       |
  616|     57|    return(buf->use == 0);
  617|     57|}
xmlBufResize:
  630|     54|{
  631|     54|    size_t newSize;
  632|     54|    xmlChar* rebuf = NULL;
  633|     54|    size_t start_buf;
  634|       |
  635|     54|    if ((buf == NULL) || (buf->error))
  ------------------
  |  Branch (635:9): [True: 0, False: 54]
  |  Branch (635:26): [True: 0, False: 54]
  ------------------
  636|      0|        return(0);
  637|     54|    CHECK_COMPAT(buf)
  ------------------
  |  |   72|     54|     if (buf->size != (size_t) buf->compat_size)	    \
  |  |  ------------------
  |  |  |  Branch (72:10): [True: 0, False: 54]
  |  |  ------------------
  |  |   73|     54|         if (buf->compat_size < INT_MAX)		    \
  |  |  ------------------
  |  |  |  Branch (73:14): [True: 0, False: 0]
  |  |  ------------------
  |  |   74|      0|	     buf->size = buf->compat_size;		    \
  |  |   75|     54|     if (buf->use != (size_t) buf->compat_use)		    \
  |  |  ------------------
  |  |  |  Branch (75:10): [True: 0, False: 54]
  |  |  ------------------
  |  |   76|     54|         if (buf->compat_use < INT_MAX)			    \
  |  |  ------------------
  |  |  |  Branch (76:14): [True: 0, False: 0]
  |  |  ------------------
  |  |   77|      0|	     buf->use = buf->compat_use;
  ------------------
  638|       |
  639|     54|    if (buf->alloc == XML_BUFFER_ALLOC_BOUNDED) {
  ------------------
  |  Branch (639:9): [True: 0, False: 54]
  ------------------
  640|       |        /*
  641|       |	 * Used to provide parsing limits
  642|       |	 */
  643|      0|        if (size >= XML_MAX_TEXT_LENGTH) {
  ------------------
  |  |   42|      0|#define XML_MAX_TEXT_LENGTH 10000000
  ------------------
  |  Branch (643:13): [True: 0, False: 0]
  ------------------
  644|      0|	    xmlBufMemoryError(buf, "buffer error: text too long\n");
  645|      0|	    return(0);
  646|      0|	}
  647|      0|    }
  648|       |
  649|       |    /* Don't resize if we don't have to */
  650|     54|    if (size < buf->size)
  ------------------
  |  Branch (650:9): [True: 0, False: 54]
  ------------------
  651|      0|        return 1;
  652|       |
  653|       |    /* figure out new size */
  654|     54|    switch (buf->alloc){
  655|      0|	case XML_BUFFER_ALLOC_IO:
  ------------------
  |  Branch (655:2): [True: 0, False: 54]
  ------------------
  656|     54|	case XML_BUFFER_ALLOC_DOUBLEIT:
  ------------------
  |  Branch (656:2): [True: 54, False: 0]
  ------------------
  657|       |	    /*take care of empty case*/
  658|     54|            if (buf->size == 0) {
  ------------------
  |  Branch (658:17): [True: 0, False: 54]
  ------------------
  659|      0|                newSize = (size > SIZE_MAX - 10 ? SIZE_MAX : size + 10);
  ------------------
  |  |   30|      0|#define SIZE_MAX ((size_t) -1)
  ------------------
                              newSize = (size > SIZE_MAX - 10 ? SIZE_MAX : size + 10);
  ------------------
  |  |   30|      0|#define SIZE_MAX ((size_t) -1)
  ------------------
  |  Branch (659:28): [True: 0, False: 0]
  ------------------
  660|     54|            } else {
  661|     54|                newSize = buf->size;
  662|     54|            }
  663|    108|	    while (size > newSize) {
  ------------------
  |  Branch (663:13): [True: 54, False: 54]
  ------------------
  664|     54|	        if (newSize > SIZE_MAX / 2) {
  ------------------
  |  |   30|     54|#define SIZE_MAX ((size_t) -1)
  ------------------
  |  Branch (664:14): [True: 0, False: 54]
  ------------------
  665|      0|	            xmlBufMemoryError(buf, "growing buffer");
  666|      0|	            return 0;
  667|      0|	        }
  668|     54|	        newSize *= 2;
  669|     54|	    }
  670|     54|	    break;
  671|     54|	case XML_BUFFER_ALLOC_EXACT:
  ------------------
  |  Branch (671:2): [True: 0, False: 54]
  ------------------
  672|      0|            newSize = (size > SIZE_MAX - 10 ? SIZE_MAX : size + 10);
  ------------------
  |  |   30|      0|#define SIZE_MAX ((size_t) -1)
  ------------------
                          newSize = (size > SIZE_MAX - 10 ? SIZE_MAX : size + 10);
  ------------------
  |  |   30|      0|#define SIZE_MAX ((size_t) -1)
  ------------------
  |  Branch (672:24): [True: 0, False: 0]
  ------------------
  673|      0|	    break;
  674|      0|        case XML_BUFFER_ALLOC_HYBRID:
  ------------------
  |  Branch (674:9): [True: 0, False: 54]
  ------------------
  675|      0|            if (buf->use < BASE_BUFFER_SIZE)
  ------------------
  |  |   58|      0|#define BASE_BUFFER_SIZE 4096
  ------------------
  |  Branch (675:17): [True: 0, False: 0]
  ------------------
  676|      0|                newSize = size;
  677|      0|            else {
  678|      0|                newSize = buf->size;
  679|      0|                while (size > newSize) {
  ------------------
  |  Branch (679:24): [True: 0, False: 0]
  ------------------
  680|      0|                    if (newSize > SIZE_MAX / 2) {
  ------------------
  |  |   30|      0|#define SIZE_MAX ((size_t) -1)
  ------------------
  |  Branch (680:25): [True: 0, False: 0]
  ------------------
  681|      0|                        xmlBufMemoryError(buf, "growing buffer");
  682|      0|                        return 0;
  683|      0|                    }
  684|      0|                    newSize *= 2;
  685|      0|                }
  686|      0|            }
  687|      0|            break;
  688|       |
  689|      0|	default:
  ------------------
  |  Branch (689:2): [True: 0, False: 54]
  ------------------
  690|      0|            newSize = (size > SIZE_MAX - 10 ? SIZE_MAX : size + 10);
  ------------------
  |  |   30|      0|#define SIZE_MAX ((size_t) -1)
  ------------------
                          newSize = (size > SIZE_MAX - 10 ? SIZE_MAX : size + 10);
  ------------------
  |  |   30|      0|#define SIZE_MAX ((size_t) -1)
  ------------------
  |  Branch (690:24): [True: 0, False: 0]
  ------------------
  691|      0|	    break;
  692|     54|    }
  693|       |
  694|     54|    if ((buf->alloc == XML_BUFFER_ALLOC_IO) && (buf->contentIO != NULL)) {
  ------------------
  |  Branch (694:9): [True: 0, False: 54]
  |  Branch (694:48): [True: 0, False: 0]
  ------------------
  695|      0|        start_buf = buf->content - buf->contentIO;
  696|       |
  697|      0|        if (start_buf > newSize) {
  ------------------
  |  Branch (697:13): [True: 0, False: 0]
  ------------------
  698|       |	    /* move data back to start */
  699|      0|	    memmove(buf->contentIO, buf->content, buf->use);
  700|      0|	    buf->content = buf->contentIO;
  701|      0|	    buf->content[buf->use] = 0;
  702|      0|	    buf->size += start_buf;
  703|      0|	} else {
  704|      0|	    rebuf = (xmlChar *) xmlRealloc(buf->contentIO, start_buf + newSize);
  705|      0|	    if (rebuf == NULL) {
  ------------------
  |  Branch (705:10): [True: 0, False: 0]
  ------------------
  706|      0|		xmlBufMemoryError(buf, "growing buffer");
  707|      0|		return 0;
  708|      0|	    }
  709|      0|	    buf->contentIO = rebuf;
  710|      0|	    buf->content = rebuf + start_buf;
  711|      0|	}
  712|     54|    } else {
  713|     54|	if (buf->content == NULL) {
  ------------------
  |  Branch (713:6): [True: 0, False: 54]
  ------------------
  714|      0|	    rebuf = (xmlChar *) xmlMallocAtomic(newSize);
  715|      0|	    buf->use = 0;
  716|      0|            if (rebuf != NULL)
  ------------------
  |  Branch (716:17): [True: 0, False: 0]
  ------------------
  717|      0|	        rebuf[buf->use] = 0;
  718|     54|	} else if (buf->size - buf->use < 100) {
  ------------------
  |  Branch (718:13): [True: 43, False: 11]
  ------------------
  719|     43|	    rebuf = (xmlChar *) xmlRealloc(buf->content, newSize);
  720|     43|        } else {
  721|       |	    /*
  722|       |	     * if we are reallocating a buffer far from being full, it's
  723|       |	     * better to make a new allocation and copy only the used range
  724|       |	     * and free the old one.
  725|       |	     */
  726|     11|	    rebuf = (xmlChar *) xmlMallocAtomic(newSize);
  727|     11|	    if (rebuf != NULL) {
  ------------------
  |  Branch (727:10): [True: 11, False: 0]
  ------------------
  728|     11|		memcpy(rebuf, buf->content, buf->use);
  729|     11|		xmlFree(buf->content);
  730|     11|		rebuf[buf->use] = 0;
  731|     11|	    }
  732|     11|	}
  733|     54|	if (rebuf == NULL) {
  ------------------
  |  Branch (733:6): [True: 0, False: 54]
  ------------------
  734|      0|	    xmlBufMemoryError(buf, "growing buffer");
  735|      0|	    return 0;
  736|      0|	}
  737|     54|	buf->content = rebuf;
  738|     54|    }
  739|     54|    buf->size = newSize;
  740|     54|    UPDATE_COMPAT(buf)
  ------------------
  |  |   61|     54|     if (buf->size < INT_MAX) buf->compat_size = buf->size; \
  |  |  ------------------
  |  |  |  Branch (61:10): [True: 54, False: 0]
  |  |  ------------------
  |  |   62|     54|     else buf->compat_size = INT_MAX;			    \
  |  |   63|     54|     if (buf->use < INT_MAX) buf->compat_use = buf->use; \
  |  |  ------------------
  |  |  |  Branch (63:10): [True: 54, False: 0]
  |  |  ------------------
  |  |   64|     54|     else buf->compat_use = INT_MAX;
  ------------------
  741|       |
  742|     54|    return 1;
  743|     54|}
xmlBufAdd:
  758|  83.9k|xmlBufAdd(xmlBufPtr buf, const xmlChar *str, int len) {
  759|  83.9k|    size_t needSize;
  760|       |
  761|  83.9k|    if ((str == NULL) || (buf == NULL) || (buf->error))
  ------------------
  |  Branch (761:9): [True: 0, False: 83.9k]
  |  Branch (761:26): [True: 0, False: 83.9k]
  |  Branch (761:43): [True: 0, False: 83.9k]
  ------------------
  762|      0|	return -1;
  763|  83.9k|    CHECK_COMPAT(buf)
  ------------------
  |  |   72|  83.9k|     if (buf->size != (size_t) buf->compat_size)	    \
  |  |  ------------------
  |  |  |  Branch (72:10): [True: 0, False: 83.9k]
  |  |  ------------------
  |  |   73|  83.9k|         if (buf->compat_size < INT_MAX)		    \
  |  |  ------------------
  |  |  |  Branch (73:14): [True: 0, False: 0]
  |  |  ------------------
  |  |   74|      0|	     buf->size = buf->compat_size;		    \
  |  |   75|  83.9k|     if (buf->use != (size_t) buf->compat_use)		    \
  |  |  ------------------
  |  |  |  Branch (75:10): [True: 0, False: 83.9k]
  |  |  ------------------
  |  |   76|  83.9k|         if (buf->compat_use < INT_MAX)			    \
  |  |  ------------------
  |  |  |  Branch (76:14): [True: 0, False: 0]
  |  |  ------------------
  |  |   77|      0|	     buf->use = buf->compat_use;
  ------------------
  764|       |
  765|  83.9k|    if (len < -1) {
  ------------------
  |  Branch (765:9): [True: 0, False: 83.9k]
  ------------------
  766|      0|	return -1;
  767|      0|    }
  768|  83.9k|    if (len == 0) return 0;
  ------------------
  |  Branch (768:9): [True: 0, False: 83.9k]
  ------------------
  769|       |
  770|  83.9k|    if (len < 0)
  ------------------
  |  Branch (770:9): [True: 20.5k, False: 63.4k]
  ------------------
  771|  20.5k|        len = xmlStrlen(str);
  772|       |
  773|  83.9k|    if (len < 0) return -1;
  ------------------
  |  Branch (773:9): [True: 0, False: 83.9k]
  ------------------
  774|  83.9k|    if (len == 0) return 0;
  ------------------
  |  Branch (774:9): [True: 68, False: 83.8k]
  ------------------
  775|       |
  776|       |    /* Note that both buf->size and buf->use can be zero here. */
  777|  83.8k|    if ((size_t) len >= buf->size - buf->use) {
  ------------------
  |  Branch (777:9): [True: 54, False: 83.8k]
  ------------------
  778|     54|        if ((size_t) len >= SIZE_MAX - buf->use) {
  ------------------
  |  |   30|     54|#define SIZE_MAX ((size_t) -1)
  ------------------
  |  Branch (778:13): [True: 0, False: 54]
  ------------------
  779|      0|            xmlBufMemoryError(buf, "growing buffer past SIZE_MAX");
  780|      0|            return(-1);
  781|      0|        }
  782|     54|        needSize = buf->use + len + 1;
  783|     54|	if (buf->alloc == XML_BUFFER_ALLOC_BOUNDED) {
  ------------------
  |  Branch (783:6): [True: 0, False: 54]
  ------------------
  784|       |	    /*
  785|       |	     * Used to provide parsing limits
  786|       |	     */
  787|      0|	    if (needSize >= XML_MAX_TEXT_LENGTH) {
  ------------------
  |  |   42|      0|#define XML_MAX_TEXT_LENGTH 10000000
  ------------------
  |  Branch (787:10): [True: 0, False: 0]
  ------------------
  788|      0|		xmlBufMemoryError(buf, "buffer error: text too long\n");
  789|      0|		return(-1);
  790|      0|	    }
  791|      0|	}
  792|     54|        if (!xmlBufResize(buf, needSize)){
  ------------------
  |  Branch (792:13): [True: 0, False: 54]
  ------------------
  793|      0|	    xmlBufMemoryError(buf, "growing buffer");
  794|      0|            return XML_ERR_NO_MEMORY;
  795|      0|        }
  796|     54|    }
  797|       |
  798|  83.8k|    memmove(&buf->content[buf->use], str, len);
  799|  83.8k|    buf->use += len;
  800|  83.8k|    buf->content[buf->use] = 0;
  801|  83.8k|    UPDATE_COMPAT(buf)
  ------------------
  |  |   61|  83.8k|     if (buf->size < INT_MAX) buf->compat_size = buf->size; \
  |  |  ------------------
  |  |  |  Branch (61:10): [True: 83.8k, False: 0]
  |  |  ------------------
  |  |   62|  83.8k|     else buf->compat_size = INT_MAX;			    \
  |  |   63|  83.8k|     if (buf->use < INT_MAX) buf->compat_use = buf->use; \
  |  |  ------------------
  |  |  |  Branch (63:10): [True: 83.8k, False: 0]
  |  |  ------------------
  |  |   64|  83.8k|     else buf->compat_use = INT_MAX;
  ------------------
  802|  83.8k|    return 0;
  803|  83.8k|}
xmlBufCat:
  816|  20.5k|xmlBufCat(xmlBufPtr buf, const xmlChar *str) {
  817|  20.5k|    if ((buf == NULL) || (buf->error))
  ------------------
  |  Branch (817:9): [True: 0, False: 20.5k]
  |  Branch (817:26): [True: 0, False: 20.5k]
  ------------------
  818|      0|        return(-1);
  819|  20.5k|    CHECK_COMPAT(buf)
  ------------------
  |  |   72|  20.5k|     if (buf->size != (size_t) buf->compat_size)	    \
  |  |  ------------------
  |  |  |  Branch (72:10): [True: 0, False: 20.5k]
  |  |  ------------------
  |  |   73|  20.5k|         if (buf->compat_size < INT_MAX)		    \
  |  |  ------------------
  |  |  |  Branch (73:14): [True: 0, False: 0]
  |  |  ------------------
  |  |   74|      0|	     buf->size = buf->compat_size;		    \
  |  |   75|  20.5k|     if (buf->use != (size_t) buf->compat_use)		    \
  |  |  ------------------
  |  |  |  Branch (75:10): [True: 0, False: 20.5k]
  |  |  ------------------
  |  |   76|  20.5k|         if (buf->compat_use < INT_MAX)			    \
  |  |  ------------------
  |  |  |  Branch (76:14): [True: 0, False: 0]
  |  |  ------------------
  |  |   77|      0|	     buf->use = buf->compat_use;
  ------------------
  820|  20.5k|    if (str == NULL) return -1;
  ------------------
  |  Branch (820:9): [True: 0, False: 20.5k]
  ------------------
  821|  20.5k|    return xmlBufAdd(buf, str, -1);
  822|  20.5k|}
xmlBufCCat:
  835|  13.6k|xmlBufCCat(xmlBufPtr buf, const char *str) {
  836|  13.6k|    return xmlBufCat(buf, (const xmlChar *) str);
  837|  13.6k|}
xmlBufWriteQuotedString:
  852|  6.84k|xmlBufWriteQuotedString(xmlBufPtr buf, const xmlChar *string) {
  853|  6.84k|    const xmlChar *cur, *base;
  854|  6.84k|    if ((buf == NULL) || (buf->error))
  ------------------
  |  Branch (854:9): [True: 0, False: 6.84k]
  |  Branch (854:26): [True: 0, False: 6.84k]
  ------------------
  855|      0|        return(-1);
  856|  6.84k|    CHECK_COMPAT(buf)
  ------------------
  |  |   72|  6.84k|     if (buf->size != (size_t) buf->compat_size)	    \
  |  |  ------------------
  |  |  |  Branch (72:10): [True: 0, False: 6.84k]
  |  |  ------------------
  |  |   73|  6.84k|         if (buf->compat_size < INT_MAX)		    \
  |  |  ------------------
  |  |  |  Branch (73:14): [True: 0, False: 0]
  |  |  ------------------
  |  |   74|      0|	     buf->size = buf->compat_size;		    \
  |  |   75|  6.84k|     if (buf->use != (size_t) buf->compat_use)		    \
  |  |  ------------------
  |  |  |  Branch (75:10): [True: 0, False: 6.84k]
  |  |  ------------------
  |  |   76|  6.84k|         if (buf->compat_use < INT_MAX)			    \
  |  |  ------------------
  |  |  |  Branch (76:14): [True: 0, False: 0]
  |  |  ------------------
  |  |   77|      0|	     buf->use = buf->compat_use;
  ------------------
  857|  6.84k|    if (xmlStrchr(string, '\"')) {
  ------------------
  |  Branch (857:9): [True: 7, False: 6.83k]
  ------------------
  858|      7|        if (xmlStrchr(string, '\'')) {
  ------------------
  |  Branch (858:13): [True: 0, False: 7]
  ------------------
  859|      0|	    xmlBufCCat(buf, "\"");
  860|      0|            base = cur = string;
  861|      0|            while(*cur != 0){
  ------------------
  |  Branch (861:19): [True: 0, False: 0]
  ------------------
  862|      0|                if(*cur == '"'){
  ------------------
  |  Branch (862:20): [True: 0, False: 0]
  ------------------
  863|      0|                    if (base != cur)
  ------------------
  |  Branch (863:25): [True: 0, False: 0]
  ------------------
  864|      0|                        xmlBufAdd(buf, base, cur - base);
  865|      0|                    xmlBufAdd(buf, BAD_CAST "&quot;", 6);
  ------------------
  |  |   35|      0|#define BAD_CAST (xmlChar *)
  ------------------
  866|      0|                    cur++;
  867|      0|                    base = cur;
  868|      0|                }
  869|      0|                else {
  870|      0|                    cur++;
  871|      0|                }
  872|      0|            }
  873|      0|            if (base != cur)
  ------------------
  |  Branch (873:17): [True: 0, False: 0]
  ------------------
  874|      0|                xmlBufAdd(buf, base, cur - base);
  875|      0|	    xmlBufCCat(buf, "\"");
  876|      0|	}
  877|      7|        else{
  878|      7|	    xmlBufCCat(buf, "\'");
  879|      7|            xmlBufCat(buf, string);
  880|      7|	    xmlBufCCat(buf, "\'");
  881|      7|        }
  882|  6.83k|    } else {
  883|  6.83k|        xmlBufCCat(buf, "\"");
  884|  6.83k|        xmlBufCat(buf, string);
  885|  6.83k|        xmlBufCCat(buf, "\"");
  886|  6.83k|    }
  887|  6.84k|    return(0);
  888|  6.84k|}
xmlBufResetInput:
 1019|    240|xmlBufResetInput(xmlBufPtr buf, xmlParserInputPtr input) {
 1020|    240|    if (input == NULL)
  ------------------
  |  Branch (1020:9): [True: 0, False: 240]
  ------------------
 1021|      0|        return(-1);
 1022|    240|    if ((buf == NULL) || (buf->error)) {
  ------------------
  |  Branch (1022:9): [True: 1, False: 239]
  |  Branch (1022:26): [True: 0, False: 239]
  ------------------
 1023|      1|        input->base = input->cur = input->end = BAD_CAST "";
  ------------------
  |  |   35|      1|#define BAD_CAST (xmlChar *)
  ------------------
 1024|      1|        return(-1);
 1025|      1|    }
 1026|    239|    CHECK_COMPAT(buf)
  ------------------
  |  |   72|    239|     if (buf->size != (size_t) buf->compat_size)	    \
  |  |  ------------------
  |  |  |  Branch (72:10): [True: 0, False: 239]
  |  |  ------------------
  |  |   73|    239|         if (buf->compat_size < INT_MAX)		    \
  |  |  ------------------
  |  |  |  Branch (73:14): [True: 0, False: 0]
  |  |  ------------------
  |  |   74|      0|	     buf->size = buf->compat_size;		    \
  |  |   75|    239|     if (buf->use != (size_t) buf->compat_use)		    \
  |  |  ------------------
  |  |  |  Branch (75:10): [True: 0, False: 239]
  |  |  ------------------
  |  |   76|    239|         if (buf->compat_use < INT_MAX)			    \
  |  |  ------------------
  |  |  |  Branch (76:14): [True: 0, False: 0]
  |  |  ------------------
  |  |   77|      0|	     buf->use = buf->compat_use;
  ------------------
 1027|    239|    input->base = input->cur = buf->content;
 1028|    239|    input->end = &buf->content[buf->use];
 1029|    239|    return(0);
 1030|    240|}
xmlBufUpdateInput:
 1044|  18.3k|xmlBufUpdateInput(xmlBufPtr buf, xmlParserInputPtr input, size_t pos) {
 1045|  18.3k|    if (input == NULL)
  ------------------
  |  Branch (1045:9): [True: 0, False: 18.3k]
  ------------------
 1046|      0|        return(-1);
 1047|       |    /*
 1048|       |     * TODO: It might be safer to keep using the buffer content if there
 1049|       |     * was an error.
 1050|       |     */
 1051|  18.3k|    if ((buf == NULL) || (buf->error)) {
  ------------------
  |  Branch (1051:9): [True: 0, False: 18.3k]
  |  Branch (1051:26): [True: 0, False: 18.3k]
  ------------------
 1052|      0|        input->base = input->cur = input->end = BAD_CAST "";
  ------------------
  |  |   35|      0|#define BAD_CAST (xmlChar *)
  ------------------
 1053|      0|        return(-1);
 1054|      0|    }
 1055|  18.3k|    CHECK_COMPAT(buf)
  ------------------
  |  |   72|  18.3k|     if (buf->size != (size_t) buf->compat_size)	    \
  |  |  ------------------
  |  |  |  Branch (72:10): [True: 0, False: 18.3k]
  |  |  ------------------
  |  |   73|  18.3k|         if (buf->compat_size < INT_MAX)		    \
  |  |  ------------------
  |  |  |  Branch (73:14): [True: 0, False: 0]
  |  |  ------------------
  |  |   74|      0|	     buf->size = buf->compat_size;		    \
  |  |   75|  18.3k|     if (buf->use != (size_t) buf->compat_use)		    \
  |  |  ------------------
  |  |  |  Branch (75:10): [True: 0, False: 18.3k]
  |  |  ------------------
  |  |   76|  18.3k|         if (buf->compat_use < INT_MAX)			    \
  |  |  ------------------
  |  |  |  Branch (76:14): [True: 0, False: 0]
  |  |  ------------------
  |  |   77|      0|	     buf->use = buf->compat_use;
  ------------------
 1056|  18.3k|    input->base = buf->content;
 1057|  18.3k|    input->cur = input->base + pos;
 1058|  18.3k|    input->end = &buf->content[buf->use];
 1059|  18.3k|    return(0);
 1060|  18.3k|}
buf.c:xmlBufMemoryError:
   93|      5|{
   94|      5|    __xmlSimpleError(XML_FROM_BUFFER, XML_ERR_NO_MEMORY, NULL, NULL, extra);
   95|      5|    if ((buf) && (buf->error == 0))
  ------------------
  |  Branch (95:9): [True: 0, False: 5]
  |  Branch (95:18): [True: 0, False: 0]
  ------------------
   96|      0|        buf->error = XML_ERR_NO_MEMORY;
   97|      5|}
buf.c:xmlBufGrowInternal:
  376|  15.0k|xmlBufGrowInternal(xmlBufPtr buf, size_t len) {
  377|  15.0k|    size_t size;
  378|  15.0k|    xmlChar *newbuf;
  379|       |
  380|  15.0k|    if ((buf == NULL) || (buf->error != 0)) return(0);
  ------------------
  |  Branch (380:9): [True: 0, False: 15.0k]
  |  Branch (380:26): [True: 0, False: 15.0k]
  ------------------
  381|  15.0k|    CHECK_COMPAT(buf)
  ------------------
  |  |   72|  15.0k|     if (buf->size != (size_t) buf->compat_size)	    \
  |  |  ------------------
  |  |  |  Branch (72:10): [True: 0, False: 15.0k]
  |  |  ------------------
  |  |   73|  15.0k|         if (buf->compat_size < INT_MAX)		    \
  |  |  ------------------
  |  |  |  Branch (73:14): [True: 0, False: 0]
  |  |  ------------------
  |  |   74|      0|	     buf->size = buf->compat_size;		    \
  |  |   75|  15.0k|     if (buf->use != (size_t) buf->compat_use)		    \
  |  |  ------------------
  |  |  |  Branch (75:10): [True: 0, False: 15.0k]
  |  |  ------------------
  |  |   76|  15.0k|         if (buf->compat_use < INT_MAX)			    \
  |  |  ------------------
  |  |  |  Branch (76:14): [True: 0, False: 0]
  |  |  ------------------
  |  |   77|      0|	     buf->use = buf->compat_use;
  ------------------
  382|       |
  383|  15.0k|    if (len < buf->size - buf->use)
  ------------------
  |  Branch (383:9): [True: 14.9k, False: 110]
  ------------------
  384|  14.9k|        return(buf->size - buf->use - 1);
  385|    110|    if (len >= SIZE_MAX - buf->use) {
  ------------------
  |  |   30|    110|#define SIZE_MAX ((size_t) -1)
  ------------------
  |  Branch (385:9): [True: 0, False: 110]
  ------------------
  386|      0|        xmlBufMemoryError(buf, "growing buffer past SIZE_MAX");
  387|      0|        return(0);
  388|      0|    }
  389|       |
  390|    110|    if (buf->size > (size_t) len) {
  ------------------
  |  Branch (390:9): [True: 54, False: 56]
  ------------------
  391|     54|        size = buf->size > SIZE_MAX / 2 ? SIZE_MAX : buf->size * 2;
  ------------------
  |  |   30|     54|#define SIZE_MAX ((size_t) -1)
  ------------------
                      size = buf->size > SIZE_MAX / 2 ? SIZE_MAX : buf->size * 2;
  ------------------
  |  |   30|      0|#define SIZE_MAX ((size_t) -1)
  ------------------
  |  Branch (391:16): [True: 0, False: 54]
  ------------------
  392|     56|    } else {
  393|     56|        size = buf->use + len;
  394|     56|        size = size > SIZE_MAX - 100 ? SIZE_MAX : size + 100;
  ------------------
  |  |   30|     56|#define SIZE_MAX ((size_t) -1)
  ------------------
                      size = size > SIZE_MAX - 100 ? SIZE_MAX : size + 100;
  ------------------
  |  |   30|      0|#define SIZE_MAX ((size_t) -1)
  ------------------
  |  Branch (394:16): [True: 0, False: 56]
  ------------------
  395|     56|    }
  396|       |
  397|    110|    if (buf->alloc == XML_BUFFER_ALLOC_BOUNDED) {
  ------------------
  |  Branch (397:9): [True: 0, False: 110]
  ------------------
  398|       |        /*
  399|       |	 * Used to provide parsing limits
  400|       |	 */
  401|      0|        if ((buf->use + len + 1 >= XML_MAX_TEXT_LENGTH) ||
  ------------------
  |  |   42|      0|#define XML_MAX_TEXT_LENGTH 10000000
  ------------------
  |  Branch (401:13): [True: 0, False: 0]
  ------------------
  402|      0|	    (buf->size >= XML_MAX_TEXT_LENGTH)) {
  ------------------
  |  |   42|      0|#define XML_MAX_TEXT_LENGTH 10000000
  ------------------
  |  Branch (402:6): [True: 0, False: 0]
  ------------------
  403|      0|	    xmlBufMemoryError(buf, "buffer error: text too long\n");
  404|      0|	    return(0);
  405|      0|	}
  406|      0|	if (size >= XML_MAX_TEXT_LENGTH)
  ------------------
  |  |   42|      0|#define XML_MAX_TEXT_LENGTH 10000000
  ------------------
  |  Branch (406:6): [True: 0, False: 0]
  ------------------
  407|      0|	    size = XML_MAX_TEXT_LENGTH;
  ------------------
  |  |   42|      0|#define XML_MAX_TEXT_LENGTH 10000000
  ------------------
  408|      0|    }
  409|    110|    if ((buf->alloc == XML_BUFFER_ALLOC_IO) && (buf->contentIO != NULL)) {
  ------------------
  |  Branch (409:9): [True: 0, False: 110]
  |  Branch (409:48): [True: 0, False: 0]
  ------------------
  410|      0|        size_t start_buf = buf->content - buf->contentIO;
  411|       |
  412|      0|	newbuf = (xmlChar *) xmlRealloc(buf->contentIO, start_buf + size);
  413|      0|	if (newbuf == NULL) {
  ------------------
  |  Branch (413:6): [True: 0, False: 0]
  ------------------
  414|      0|	    xmlBufMemoryError(buf, "growing buffer");
  415|      0|	    return(0);
  416|      0|	}
  417|      0|	buf->contentIO = newbuf;
  418|      0|	buf->content = newbuf + start_buf;
  419|    110|    } else {
  420|    110|	newbuf = (xmlChar *) xmlRealloc(buf->content, size);
  421|    110|	if (newbuf == NULL) {
  ------------------
  |  Branch (421:6): [True: 0, False: 110]
  ------------------
  422|      0|	    xmlBufMemoryError(buf, "growing buffer");
  423|      0|	    return(0);
  424|      0|	}
  425|    110|	buf->content = newbuf;
  426|    110|    }
  427|    110|    buf->size = size;
  428|    110|    UPDATE_COMPAT(buf)
  ------------------
  |  |   61|    110|     if (buf->size < INT_MAX) buf->compat_size = buf->size; \
  |  |  ------------------
  |  |  |  Branch (61:10): [True: 110, False: 0]
  |  |  ------------------
  |  |   62|    110|     else buf->compat_size = INT_MAX;			    \
  |  |   63|    110|     if (buf->use < INT_MAX) buf->compat_use = buf->use; \
  |  |  ------------------
  |  |  |  Branch (63:10): [True: 110, False: 0]
  |  |  ------------------
  |  |   64|    110|     else buf->compat_use = INT_MAX;
  ------------------
  429|    110|    return(buf->size - buf->use - 1);
  430|    110|}

xmlInitializeCatalog:
 3096|      2|xmlInitializeCatalog(void) {
 3097|      2|    if (xmlCatalogInitialized != 0)
  ------------------
  |  Branch (3097:9): [True: 0, False: 2]
  ------------------
 3098|      0|	return;
 3099|       |
 3100|      2|    xmlInitializeCatalogData();
 3101|      2|    xmlRMutexLock(xmlCatalogMutex);
 3102|       |
 3103|      2|    if (getenv("XML_DEBUG_CATALOG"))
  ------------------
  |  Branch (3103:9): [True: 0, False: 2]
  ------------------
 3104|      0|	xmlDebugCatalogs = 1;
 3105|       |
 3106|      2|    if (xmlDefaultCatalog == NULL) {
  ------------------
  |  Branch (3106:9): [True: 2, False: 0]
  ------------------
 3107|      2|	const char *catalogs;
 3108|      2|	char *path;
 3109|      2|	const char *cur, *paths;
 3110|      2|	xmlCatalogPtr catal;
 3111|      2|	xmlCatalogEntryPtr *nextent;
 3112|       |
 3113|      2|	catalogs = (const char *) getenv("XML_CATALOG_FILES");
 3114|      2|	if (catalogs == NULL)
  ------------------
  |  Branch (3114:6): [True: 2, False: 0]
  ------------------
 3115|       |#if defined(_WIN32) && defined(_MSC_VER)
 3116|       |    {
 3117|       |		void* hmodule;
 3118|       |		hmodule = GetModuleHandleA("libxml2.dll");
 3119|       |		if (hmodule == NULL)
 3120|       |			hmodule = GetModuleHandleA(NULL);
 3121|       |		if (hmodule != NULL) {
 3122|       |			char buf[256];
 3123|       |			unsigned long len = GetModuleFileNameA(hmodule, buf, 255);
 3124|       |			if (len != 0) {
 3125|       |				char* p = &(buf[len]);
 3126|       |				while (*p != '\\' && p > buf)
 3127|       |					p--;
 3128|       |				if (p != buf) {
 3129|       |					xmlChar* uri;
 3130|       |					strncpy(p, "\\..\\etc\\catalog", 255 - (p - buf));
 3131|       |					uri = xmlCanonicPath((const xmlChar*)buf);
 3132|       |					if (uri != NULL) {
 3133|       |						strncpy(XML_XML_DEFAULT_CATALOG, (char* )uri, 255);
 3134|       |						xmlFree(uri);
 3135|       |					}
 3136|       |				}
 3137|       |			}
 3138|       |		}
 3139|       |		catalogs = XML_XML_DEFAULT_CATALOG;
 3140|       |    }
 3141|       |#else
 3142|      2|	    catalogs = XML_XML_DEFAULT_CATALOG;
  ------------------
  |  |   70|      2|#define XML_XML_DEFAULT_CATALOG "file://" SYSCONFDIR "/xml/catalog"
  ------------------
 3143|      2|#endif
 3144|       |
 3145|      2|	catal = xmlCreateNewCatalog(XML_XML_CATALOG_TYPE,
 3146|      2|		xmlCatalogDefaultPrefer);
 3147|      2|	if (catal != NULL) {
  ------------------
  |  Branch (3147:6): [True: 2, False: 0]
  ------------------
 3148|       |	    /* the XML_CATALOG_FILES envvar is allowed to contain a
 3149|       |	       space-separated list of entries. */
 3150|      2|	    cur = catalogs;
 3151|      2|	    nextent = &catal->xml;
 3152|      4|	    while (*cur != '\0') {
  ------------------
  |  Branch (3152:13): [True: 2, False: 2]
  ------------------
 3153|      2|		while (xmlIsBlank_ch(*cur))
  ------------------
  |  |   88|      2|#define xmlIsBlank_ch(c)	(((c) == 0x20) || \
  |  |  ------------------
  |  |  |  Branch (88:27): [True: 0, False: 2]
  |  |  ------------------
  |  |   89|      2|				 ((0x9 <= (c)) && ((c) <= 0xa)) || \
  |  |  ------------------
  |  |  |  Branch (89:7): [True: 2, False: 0]
  |  |  |  Branch (89:23): [True: 0, False: 2]
  |  |  ------------------
  |  |   90|      2|				 ((c) == 0xd))
  |  |  ------------------
  |  |  |  Branch (90:6): [True: 0, False: 2]
  |  |  ------------------
  ------------------
 3154|      0|		    cur++;
 3155|      2|		if (*cur != 0) {
  ------------------
  |  Branch (3155:7): [True: 2, False: 0]
  ------------------
 3156|      2|		    paths = cur;
 3157|     68|		    while ((*cur != 0) && (!xmlIsBlank_ch(*cur)))
  ------------------
  |  |   88|     66|#define xmlIsBlank_ch(c)	(((c) == 0x20) || \
  |  |  ------------------
  |  |  |  Branch (88:27): [True: 0, False: 66]
  |  |  ------------------
  |  |   89|     66|				 ((0x9 <= (c)) && ((c) <= 0xa)) || \
  |  |  ------------------
  |  |  |  Branch (89:7): [True: 66, False: 0]
  |  |  |  Branch (89:23): [True: 0, False: 66]
  |  |  ------------------
  |  |   90|     66|				 ((c) == 0xd))
  |  |  ------------------
  |  |  |  Branch (90:6): [True: 0, False: 66]
  |  |  ------------------
  ------------------
  |  Branch (3157:14): [True: 66, False: 2]
  ------------------
 3158|     66|			cur++;
 3159|      2|		    path = (char *) xmlStrndup((const xmlChar *)paths, cur - paths);
 3160|      2|		    if (path != NULL) {
  ------------------
  |  Branch (3160:11): [True: 2, False: 0]
  ------------------
 3161|      2|			*nextent = xmlNewCatalogEntry(XML_CATA_CATALOG, NULL,
 3162|      2|				NULL, BAD_CAST path, xmlCatalogDefaultPrefer, NULL);
  ------------------
  |  |   35|      2|#define BAD_CAST (xmlChar *)
  ------------------
 3163|      2|			if (*nextent != NULL)
  ------------------
  |  Branch (3163:8): [True: 2, False: 0]
  ------------------
 3164|      2|			    nextent = &((*nextent)->next);
 3165|      2|			xmlFree(path);
 3166|      2|		    }
 3167|      2|		}
 3168|      2|	    }
 3169|      2|	    xmlDefaultCatalog = catal;
 3170|      2|	}
 3171|      2|    }
 3172|       |
 3173|      2|    xmlRMutexUnlock(xmlCatalogMutex);
 3174|      2|}
catalog.c:xmlCreateNewCatalog:
  406|      2|xmlCreateNewCatalog(xmlCatalogType type, xmlCatalogPrefer prefer) {
  407|      2|    xmlCatalogPtr ret;
  408|       |
  409|      2|    ret = (xmlCatalogPtr) xmlMalloc(sizeof(xmlCatalog));
  410|      2|    if (ret == NULL) {
  ------------------
  |  Branch (410:9): [True: 0, False: 2]
  ------------------
  411|      0|        xmlCatalogErrMemory("allocating catalog");
  412|      0|	return(NULL);
  413|      0|    }
  414|      2|    memset(ret, 0, sizeof(xmlCatalog));
  415|      2|    ret->type = type;
  416|      2|    ret->catalNr = 0;
  417|      2|    ret->catalMax = XML_MAX_SGML_CATA_DEPTH;
  ------------------
  |  |  144|      2|#define XML_MAX_SGML_CATA_DEPTH 10
  ------------------
  418|      2|    ret->prefer = prefer;
  419|      2|    if (ret->type == XML_SGML_CATALOG_TYPE)
  ------------------
  |  Branch (419:9): [True: 0, False: 2]
  ------------------
  420|      0|	ret->sgml = xmlHashCreate(10);
  421|      2|    return(ret);
  422|      2|}
catalog.c:xmlNewCatalogEntry:
  267|      2|	   xmlCatalogEntryPtr group) {
  268|      2|    xmlCatalogEntryPtr ret;
  269|      2|    xmlChar *normid = NULL;
  270|       |
  271|      2|    ret = (xmlCatalogEntryPtr) xmlMalloc(sizeof(xmlCatalogEntry));
  272|      2|    if (ret == NULL) {
  ------------------
  |  Branch (272:9): [True: 0, False: 2]
  ------------------
  273|      0|        xmlCatalogErrMemory("allocating catalog entry");
  274|      0|	return(NULL);
  275|      0|    }
  276|      2|    ret->next = NULL;
  277|      2|    ret->parent = NULL;
  278|      2|    ret->children = NULL;
  279|      2|    ret->type = type;
  280|      2|    if (type == XML_CATA_PUBLIC || type == XML_CATA_DELEGATE_PUBLIC) {
  ------------------
  |  Branch (280:9): [True: 0, False: 2]
  |  Branch (280:36): [True: 0, False: 2]
  ------------------
  281|      0|        normid = xmlCatalogNormalizePublic(name);
  282|      0|        if (normid != NULL)
  ------------------
  |  Branch (282:13): [True: 0, False: 0]
  ------------------
  283|      0|            name = (*normid != 0 ? normid : NULL);
  ------------------
  |  Branch (283:21): [True: 0, False: 0]
  ------------------
  284|      0|    }
  285|      2|    if (name != NULL)
  ------------------
  |  Branch (285:9): [True: 0, False: 2]
  ------------------
  286|      0|	ret->name = xmlStrdup(name);
  287|      2|    else
  288|      2|	ret->name = NULL;
  289|      2|    if (normid != NULL)
  ------------------
  |  Branch (289:9): [True: 0, False: 2]
  ------------------
  290|      0|        xmlFree(normid);
  291|      2|    if (value != NULL)
  ------------------
  |  Branch (291:9): [True: 0, False: 2]
  ------------------
  292|      0|	ret->value = xmlStrdup(value);
  293|      2|    else
  294|      2|	ret->value = NULL;
  295|      2|    if (URL == NULL)
  ------------------
  |  Branch (295:9): [True: 0, False: 2]
  ------------------
  296|      0|	URL = value;
  297|      2|    if (URL != NULL)
  ------------------
  |  Branch (297:9): [True: 2, False: 0]
  ------------------
  298|      2|	ret->URL = xmlStrdup(URL);
  299|      0|    else
  300|      0|	ret->URL = NULL;
  301|      2|    ret->prefer = prefer;
  302|      2|    ret->dealloc = 0;
  303|      2|    ret->depth = 0;
  304|      2|    ret->group = group;
  305|      2|    return(ret);
  306|      2|}
catalog.c:xmlInitializeCatalogData:
 3078|      2|xmlInitializeCatalogData(void) {
 3079|      2|    if (xmlCatalogInitialized != 0)
  ------------------
  |  Branch (3079:9): [True: 0, False: 2]
  ------------------
 3080|      0|	return;
 3081|       |
 3082|      2|    if (getenv("XML_DEBUG_CATALOG"))
  ------------------
  |  Branch (3082:9): [True: 0, False: 2]
  ------------------
 3083|      0|	xmlDebugCatalogs = 1;
 3084|      2|    xmlCatalogMutex = xmlNewRMutex();
 3085|       |
 3086|      2|    xmlCatalogInitialized = 1;
 3087|      2|}

xmlInitDictInternal:
   99|      2|xmlInitDictInternal(void) {
  100|      2|    xmlInitMutex(&xmlDictMutex);
  101|      2|}
xmlDictCreate:
  262|    191|xmlDictCreate(void) {
  263|    191|    xmlDictPtr dict;
  264|       |
  265|    191|    xmlInitParser();
  266|       |
  267|    191|    dict = xmlMalloc(sizeof(xmlDict));
  268|    191|    if (dict == NULL)
  ------------------
  |  Branch (268:9): [True: 2, False: 189]
  ------------------
  269|      2|        return(NULL);
  270|    189|    dict->ref_counter = 1;
  271|    189|    dict->limit = 0;
  272|       |
  273|    189|    dict->size = 0;
  274|    189|    dict->nbElems = 0;
  275|    189|    dict->table = NULL;
  276|    189|    dict->strings = NULL;
  277|    189|    dict->subdict = NULL;
  278|    189|    dict->seed = xmlRandom();
  279|    189|#ifdef FUZZING_BUILD_MODE_UNSAFE_FOR_PRODUCTION
  280|    189|    dict->seed = 0;
  281|    189|#endif
  282|    189|    return(dict);
  283|    191|}
xmlDictReference:
  317|     38|xmlDictReference(xmlDictPtr dict) {
  318|     38|    if (dict == NULL) return -1;
  ------------------
  |  Branch (318:9): [True: 38, False: 0]
  ------------------
  319|      0|    xmlMutexLock(&xmlDictMutex);
  320|      0|    dict->ref_counter++;
  321|      0|    xmlMutexUnlock(&xmlDictMutex);
  322|      0|    return(0);
  323|     38|}
xmlDictFree:
  333|    189|xmlDictFree(xmlDictPtr dict) {
  334|    189|    xmlDictStringsPtr pool, nextp;
  335|       |
  336|    189|    if (dict == NULL)
  ------------------
  |  Branch (336:9): [True: 0, False: 189]
  ------------------
  337|      0|	return;
  338|       |
  339|       |    /* decrement the counter, it may be shared by a parser and docs */
  340|    189|    xmlMutexLock(&xmlDictMutex);
  341|    189|    dict->ref_counter--;
  342|    189|    if (dict->ref_counter > 0) {
  ------------------
  |  Branch (342:9): [True: 0, False: 189]
  ------------------
  343|      0|        xmlMutexUnlock(&xmlDictMutex);
  344|      0|        return;
  345|      0|    }
  346|       |
  347|    189|    xmlMutexUnlock(&xmlDictMutex);
  348|       |
  349|    189|    if (dict->subdict != NULL) {
  ------------------
  |  Branch (349:9): [True: 0, False: 189]
  ------------------
  350|      0|        xmlDictFree(dict->subdict);
  351|      0|    }
  352|       |
  353|    189|    if (dict->table) {
  ------------------
  |  Branch (353:9): [True: 161, False: 28]
  ------------------
  354|    161|	xmlFree(dict->table);
  355|    161|    }
  356|    189|    pool = dict->strings;
  357|    350|    while (pool != NULL) {
  ------------------
  |  Branch (357:12): [True: 161, False: 189]
  ------------------
  358|    161|        nextp = pool->next;
  359|    161|	xmlFree(pool);
  360|    161|	pool = nextp;
  361|    161|    }
  362|    189|    xmlFree(dict);
  363|    189|}
xmlDictOwns:
  376|    560|xmlDictOwns(xmlDictPtr dict, const xmlChar *str) {
  377|    560|    xmlDictStringsPtr pool;
  378|       |
  379|    560|    if ((dict == NULL) || (str == NULL))
  ------------------
  |  Branch (379:9): [True: 0, False: 560]
  |  Branch (379:27): [True: 0, False: 560]
  ------------------
  380|      0|	return(-1);
  381|    560|    pool = dict->strings;
  382|  1.12k|    while (pool != NULL) {
  ------------------
  |  Branch (382:12): [True: 560, False: 560]
  ------------------
  383|    560|        if ((str >= &pool->array[0]) && (str <= pool->free))
  ------------------
  |  Branch (383:13): [True: 364, False: 196]
  |  Branch (383:41): [True: 0, False: 364]
  ------------------
  384|      0|	    return(1);
  385|    560|	pool = pool->next;
  386|    560|    }
  387|    560|    if (dict->subdict)
  ------------------
  |  Branch (387:9): [True: 0, False: 560]
  ------------------
  388|      0|        return(xmlDictOwns(dict->subdict, str));
  389|    560|    return(0);
  390|    560|}
xmlDictLookup:
  824|  43.7k|xmlDictLookup(xmlDictPtr dict, const xmlChar *name, int len) {
  825|  43.7k|    const xmlDictEntry *entry;
  826|       |
  827|  43.7k|    entry = xmlDictLookupInternal(dict, NULL, name, len, 1);
  828|  43.7k|    if (entry == NULL)
  ------------------
  |  Branch (828:9): [True: 0, False: 43.7k]
  ------------------
  829|      0|        return(NULL);
  830|  43.7k|    return(entry->name);
  831|  43.7k|}
xmlInitRandom:
  918|      2|xmlInitRandom(void) {
  919|      2|    int var;
  920|       |
  921|      2|    xmlInitMutex(&xmlRngMutex);
  922|       |
  923|       |    /* TODO: Get seed values from system PRNG */
  924|       |
  925|      2|    globalRngState[0] = (unsigned) time(NULL) ^
  926|      2|                        HASH_ROL((unsigned) (size_t) &xmlInitRandom, 8);
  ------------------
  |  |   12|      2|#define HASH_ROL(x,n) ((x) << (n) | ((x) & 0xFFFFFFFF) >> (32 - (n)))
  ------------------
  927|      2|    globalRngState[1] = HASH_ROL((unsigned) (size_t) &xmlRngMutex, 16) ^
  ------------------
  |  |   12|      2|#define HASH_ROL(x,n) ((x) << (n) | ((x) & 0xFFFFFFFF) >> (32 - (n)))
  ------------------
  928|      2|                        HASH_ROL((unsigned) (size_t) &var, 24);
  ------------------
  |  |   12|      2|#define HASH_ROL(x,n) ((x) << (n) | ((x) & 0xFFFFFFFF) >> (32 - (n)))
  ------------------
  929|      2|}
xmlRandom:
  951|    326|xmlRandom(void) {
  952|    326|#ifdef XML_THREAD_LOCAL
  953|    326|    if (!localRngInitialized) {
  ------------------
  |  Branch (953:9): [True: 1, False: 325]
  ------------------
  954|      1|        xmlMutexLock(&xmlRngMutex);
  955|      1|        localRngState[0] = xoroshiro64ss(globalRngState);
  956|      1|        localRngState[1] = xoroshiro64ss(globalRngState);
  957|      1|        localRngInitialized = 1;
  958|      1|        xmlMutexUnlock(&xmlRngMutex);
  959|      1|    }
  960|       |
  961|    326|    return(xoroshiro64ss(localRngState));
  962|       |#else
  963|       |    unsigned ret;
  964|       |
  965|       |    xmlMutexLock(&xmlRngMutex);
  966|       |    ret = xoroshiro64ss(globalRngState);
  967|       |    xmlMutexUnlock(&xmlRngMutex);
  968|       |
  969|       |    return(ret);
  970|       |#endif
  971|    326|}
dict.c:xmlDictHashName:
  465|  43.7k|                size_t *plen) {
  466|  43.7k|    unsigned h1, h2;
  467|  43.7k|    size_t i;
  468|       |
  469|  43.7k|    HASH_INIT(h1, h2, seed);
  ------------------
  |  |   23|  43.7k|    do { \
  |  |   24|  43.7k|        h1 = seed ^ 0x3b00; \
  |  |   25|  43.7k|        h2 = HASH_ROL(seed, 15); \
  |  |  ------------------
  |  |  |  |   12|  43.7k|#define HASH_ROL(x,n) ((x) << (n) | ((x) & 0xFFFFFFFF) >> (32 - (n)))
  |  |  ------------------
  |  |   26|  43.7k|    } while (0)
  |  |  ------------------
  |  |  |  Branch (26:14): [Folded - Ignored]
  |  |  ------------------
  ------------------
  470|       |
  471|   192k|    for (i = 0; i < maxLen && data[i]; i++) {
  ------------------
  |  Branch (471:17): [True: 149k, False: 43.7k]
  |  Branch (471:31): [True: 149k, False: 0]
  ------------------
  472|   149k|        HASH_UPDATE(h1, h2, data[i]);
  ------------------
  |  |   29|   149k|    do { \
  |  |   30|   149k|        h1 += ch; \
  |  |   31|   149k|        h1 += h1 << 3; \
  |  |   32|   149k|        h2 += h1; \
  |  |   33|   149k|        h2 = HASH_ROL(h2, 7); \
  |  |  ------------------
  |  |  |  |   12|   149k|#define HASH_ROL(x,n) ((x) << (n) | ((x) & 0xFFFFFFFF) >> (32 - (n)))
  |  |  ------------------
  |  |   34|   149k|        h2 += h2 << 2; \
  |  |   35|   149k|    } while (0)
  |  |  ------------------
  |  |  |  Branch (35:14): [Folded - Ignored]
  |  |  ------------------
  ------------------
  473|   149k|    }
  474|       |
  475|  43.7k|    HASH_FINISH(h1, h2);
  ------------------
  |  |   39|  43.7k|    do { \
  |  |   40|  43.7k|        h1 ^= h2; \
  |  |   41|  43.7k|        h1 += HASH_ROL(h2, 14); \
  |  |  ------------------
  |  |  |  |   12|  43.7k|#define HASH_ROL(x,n) ((x) << (n) | ((x) & 0xFFFFFFFF) >> (32 - (n)))
  |  |  ------------------
  |  |   42|  43.7k|        h2 ^= h1; h2 += HASH_ROR(h1, 6); \
  |  |  ------------------
  |  |  |  |   13|  43.7k|#define HASH_ROR(x,n) (((x) & 0xFFFFFFFF) >> (n) | (x) << (32 - (n)))
  |  |  ------------------
  |  |   43|  43.7k|        h1 ^= h2; h1 += HASH_ROL(h2, 5); \
  |  |  ------------------
  |  |  |  |   12|  43.7k|#define HASH_ROL(x,n) ((x) << (n) | ((x) & 0xFFFFFFFF) >> (32 - (n)))
  |  |  ------------------
  |  |   44|  43.7k|        h2 ^= h1; h2 += HASH_ROR(h1, 8); \
  |  |  ------------------
  |  |  |  |   13|  43.7k|#define HASH_ROR(x,n) (((x) & 0xFFFFFFFF) >> (n) | (x) << (32 - (n)))
  |  |  ------------------
  |  |   45|  43.7k|        h2 &= 0xFFFFFFFF; \
  |  |   46|  43.7k|    } while (0)
  |  |  ------------------
  |  |  |  Branch (46:14): [Folded - Ignored]
  |  |  ------------------
  ------------------
  476|       |
  477|  43.7k|    *plen = i;
  478|  43.7k|    return(h2 | MAX_HASH_SIZE);
  ------------------
  |  |   41|  43.7k|#define MAX_HASH_SIZE (1u << 31)
  ------------------
  479|  43.7k|}
dict.c:xmlDictLookupInternal:
  679|  43.7k|                      const xmlChar *name, int maybeLen, int update) {
  680|  43.7k|    xmlDictEntry *entry = NULL;
  681|  43.7k|    const xmlChar *ret;
  682|  43.7k|    unsigned hashValue;
  683|  43.7k|    size_t maxLen, len, plen, klen;
  684|  43.7k|    int found = 0;
  685|       |
  686|  43.7k|    if ((dict == NULL) || (name == NULL))
  ------------------
  |  Branch (686:9): [True: 0, False: 43.7k]
  |  Branch (686:27): [True: 0, False: 43.7k]
  ------------------
  687|      0|	return(NULL);
  688|       |
  689|  43.7k|    maxLen = (maybeLen < 0) ? SIZE_MAX : (size_t) maybeLen;
  ------------------
  |  |   35|      0|  #define SIZE_MAX ((size_t) -1)
  ------------------
  |  Branch (689:14): [True: 0, False: 43.7k]
  ------------------
  690|       |
  691|  43.7k|    if (prefix == NULL) {
  ------------------
  |  Branch (691:9): [True: 43.7k, False: 0]
  ------------------
  692|  43.7k|        hashValue = xmlDictHashName(dict->seed, name, maxLen, &len);
  693|  43.7k|        if (len > INT_MAX / 2)
  ------------------
  |  Branch (693:13): [True: 0, False: 43.7k]
  ------------------
  694|      0|            return(NULL);
  695|  43.7k|        klen = len;
  696|  43.7k|    } else {
  697|      0|        hashValue = xmlDictHashQName(dict->seed, prefix, name, &plen, &len);
  698|      0|        if ((len > INT_MAX / 2) || (plen >= INT_MAX / 2 - len))
  ------------------
  |  Branch (698:13): [True: 0, False: 0]
  |  Branch (698:36): [True: 0, False: 0]
  ------------------
  699|      0|            return(NULL);
  700|      0|        klen = plen + 1 + len;
  701|      0|    }
  702|       |
  703|  43.7k|    if ((dict->limit > 0) && (klen >= dict->limit))
  ------------------
  |  Branch (703:9): [True: 0, False: 43.7k]
  |  Branch (703:30): [True: 0, False: 0]
  ------------------
  704|      0|        return(NULL);
  705|       |
  706|       |    /*
  707|       |     * Check for an existing entry
  708|       |     */
  709|  43.7k|    if (dict->size > 0)
  ------------------
  |  Branch (709:9): [True: 43.5k, False: 161]
  ------------------
  710|  43.5k|        entry = xmlDictFindEntry(dict, prefix, name, klen, hashValue, &found);
  711|  43.7k|    if (found)
  ------------------
  |  Branch (711:9): [True: 41.2k, False: 2.49k]
  ------------------
  712|  41.2k|        return(entry);
  713|       |
  714|  2.49k|    if ((dict->subdict != NULL) && (dict->subdict->size > 0)) {
  ------------------
  |  Branch (714:9): [True: 0, False: 2.49k]
  |  Branch (714:36): [True: 0, False: 0]
  ------------------
  715|      0|        xmlDictEntry *subEntry;
  716|      0|        unsigned subHashValue;
  717|       |
  718|      0|        if (prefix == NULL)
  ------------------
  |  Branch (718:13): [True: 0, False: 0]
  ------------------
  719|      0|            subHashValue = xmlDictHashName(dict->subdict->seed, name, len,
  720|      0|                                           &len);
  721|      0|        else
  722|      0|            subHashValue = xmlDictHashQName(dict->subdict->seed, prefix, name,
  723|      0|                                            &plen, &len);
  724|      0|        subEntry = xmlDictFindEntry(dict->subdict, prefix, name, klen,
  725|      0|                                    subHashValue, &found);
  726|      0|        if (found)
  ------------------
  |  Branch (726:13): [True: 0, False: 0]
  ------------------
  727|      0|            return(subEntry);
  728|      0|    }
  729|       |
  730|  2.49k|    if (!update)
  ------------------
  |  Branch (730:9): [True: 0, False: 2.49k]
  ------------------
  731|      0|        return(NULL);
  732|       |
  733|       |    /*
  734|       |     * Grow the hash table if needed
  735|       |     */
  736|  2.49k|    if (dict->nbElems + 1 > dict->size / MAX_FILL_DENOM * MAX_FILL_NUM) {
  ------------------
  |  |   39|  2.49k|#define MAX_FILL_DENOM 8
  ------------------
                  if (dict->nbElems + 1 > dict->size / MAX_FILL_DENOM * MAX_FILL_NUM) {
  ------------------
  |  |   38|  2.49k|#define MAX_FILL_NUM 7
  ------------------
  |  Branch (736:9): [True: 311, False: 2.18k]
  ------------------
  737|    311|        unsigned newSize, mask, displ, pos;
  738|       |
  739|    311|        if (dict->size == 0) {
  ------------------
  |  Branch (739:13): [True: 161, False: 150]
  ------------------
  740|    161|            newSize = MIN_HASH_SIZE;
  ------------------
  |  |   40|    161|#define MIN_HASH_SIZE 8
  ------------------
  741|    161|        } else {
  742|    150|            if (dict->size >= MAX_HASH_SIZE)
  ------------------
  |  |   41|    150|#define MAX_HASH_SIZE (1u << 31)
  ------------------
  |  Branch (742:17): [True: 0, False: 150]
  ------------------
  743|      0|                return(NULL);
  744|    150|            newSize = dict->size * 2;
  745|    150|        }
  746|    311|        if (xmlDictGrow(dict, newSize) != 0)
  ------------------
  |  Branch (746:13): [True: 0, False: 311]
  ------------------
  747|      0|            return(NULL);
  748|       |
  749|       |        /*
  750|       |         * Find new entry
  751|       |         */
  752|    311|        mask = dict->size - 1;
  753|    311|        displ = 0;
  754|    311|        pos = hashValue & mask;
  755|    311|        entry = &dict->table[pos];
  756|       |
  757|    429|        while ((entry->hashValue != 0) &&
  ------------------
  |  Branch (757:16): [True: 158, False: 271]
  ------------------
  758|    429|               ((pos - entry->hashValue) & mask) >= displ) {
  ------------------
  |  Branch (758:16): [True: 118, False: 40]
  ------------------
  759|    118|            displ++;
  760|    118|            pos++;
  761|    118|            entry++;
  762|    118|            if ((pos & mask) == 0)
  ------------------
  |  Branch (762:17): [True: 0, False: 118]
  ------------------
  763|      0|                entry = dict->table;
  764|    118|        }
  765|    311|    }
  766|       |
  767|  2.49k|    if (prefix == NULL)
  ------------------
  |  Branch (767:9): [True: 2.49k, False: 0]
  ------------------
  768|  2.49k|        ret = xmlDictAddString(dict, name, len);
  769|      0|    else
  770|      0|        ret = xmlDictAddQString(dict, prefix, plen, name, len);
  771|  2.49k|    if (ret == NULL)
  ------------------
  |  Branch (771:9): [True: 0, False: 2.49k]
  ------------------
  772|      0|        return(NULL);
  773|       |
  774|       |    /*
  775|       |     * Shift the remainder of the probe sequence to the right
  776|       |     */
  777|  2.49k|    if (entry->hashValue != 0) {
  ------------------
  |  Branch (777:9): [True: 666, False: 1.82k]
  ------------------
  778|    666|        const xmlDictEntry *end = &dict->table[dict->size];
  779|    666|        const xmlDictEntry *cur = entry;
  780|       |
  781|  1.84k|        do {
  782|  1.84k|            cur++;
  783|  1.84k|            if (cur >= end)
  ------------------
  |  Branch (783:17): [True: 18, False: 1.82k]
  ------------------
  784|     18|                cur = dict->table;
  785|  1.84k|        } while (cur->hashValue != 0);
  ------------------
  |  Branch (785:18): [True: 1.18k, False: 666]
  ------------------
  786|       |
  787|    666|        if (cur < entry) {
  ------------------
  |  Branch (787:13): [True: 18, False: 648]
  ------------------
  788|       |            /*
  789|       |             * If we traversed the end of the buffer, handle the part
  790|       |             * at the start of the buffer.
  791|       |             */
  792|     18|            memmove(&dict->table[1], dict->table,
  793|     18|                    (char *) cur - (char *) dict->table);
  794|     18|            cur = end - 1;
  795|     18|            dict->table[0] = *cur;
  796|     18|        }
  797|       |
  798|    666|        memmove(&entry[1], entry, (char *) cur - (char *) entry);
  799|    666|    }
  800|       |
  801|       |    /*
  802|       |     * Populate entry
  803|       |     */
  804|  2.49k|    entry->hashValue = hashValue;
  805|  2.49k|    entry->name = ret;
  806|       |
  807|  2.49k|    dict->nbElems++;
  808|       |
  809|  2.49k|    return(entry);
  810|  2.49k|}
dict.c:xmlDictFindEntry:
  549|  43.5k|                 int *pfound) {
  550|  43.5k|    xmlDictEntry *entry;
  551|  43.5k|    unsigned mask, pos, displ;
  552|  43.5k|    int found = 0;
  553|       |
  554|  43.5k|    mask = dict->size - 1;
  555|  43.5k|    pos = hashValue & mask;
  556|  43.5k|    entry = &dict->table[pos];
  557|       |
  558|  43.5k|    if (entry->hashValue != 0) {
  ------------------
  |  Branch (558:9): [True: 42.4k, False: 1.09k]
  ------------------
  559|       |        /*
  560|       |         * Robin hood hashing: abort if the displacement of the entry
  561|       |         * is smaller than the displacement of the key we look for.
  562|       |         * This also stops at the correct position when inserting.
  563|       |         */
  564|  42.4k|        displ = 0;
  565|       |
  566|  71.4k|        do {
  567|  71.4k|            if (entry->hashValue == hashValue) {
  ------------------
  |  Branch (567:17): [True: 41.2k, False: 30.1k]
  ------------------
  568|  41.2k|                if (prefix == NULL) {
  ------------------
  |  Branch (568:21): [True: 41.2k, False: 0]
  ------------------
  569|       |                    /*
  570|       |                     * name is not necessarily null-terminated.
  571|       |                     */
  572|  41.2k|                    if ((strncmp((const char *) entry->name,
  ------------------
  |  Branch (572:25): [True: 41.2k, False: 0]
  ------------------
  573|  41.2k|                                 (const char *) name, len) == 0) &&
  574|  41.2k|                        (entry->name[len] == 0)) {
  ------------------
  |  Branch (574:25): [True: 41.2k, False: 0]
  ------------------
  575|  41.2k|                        found = 1;
  576|  41.2k|                        break;
  577|  41.2k|                    }
  578|  41.2k|                } else {
  579|      0|                    if (xmlStrQEqual(prefix, name, entry->name)) {
  ------------------
  |  Branch (579:25): [True: 0, False: 0]
  ------------------
  580|      0|                        found = 1;
  581|      0|                        break;
  582|      0|                    }
  583|      0|                }
  584|  41.2k|            }
  585|       |
  586|  30.1k|            displ++;
  587|  30.1k|            pos++;
  588|  30.1k|            entry++;
  589|  30.1k|            if ((pos & mask) == 0)
  ------------------
  |  Branch (589:17): [True: 64, False: 30.1k]
  ------------------
  590|     64|                entry = dict->table;
  591|  30.1k|        } while ((entry->hashValue != 0) &&
  ------------------
  |  Branch (591:18): [True: 29.6k, False: 519]
  ------------------
  592|  30.1k|                 (((pos - entry->hashValue) & mask) >= displ));
  ------------------
  |  Branch (592:18): [True: 28.9k, False: 720]
  ------------------
  593|  42.4k|    }
  594|       |
  595|      0|    *pfound = found;
  596|  43.5k|    return(entry);
  597|  43.5k|}
dict.c:xmlDictGrow:
  609|    311|xmlDictGrow(xmlDictPtr dict, unsigned size) {
  610|    311|    const xmlDictEntry *oldentry, *oldend, *end;
  611|    311|    xmlDictEntry *table;
  612|    311|    unsigned oldsize, i;
  613|       |
  614|       |    /* Add 0 to avoid spurious -Wtype-limits warning on 64-bit GCC */
  615|    311|    if ((size_t) size + 0 > SIZE_MAX / sizeof(table[0]))
  ------------------
  |  |   35|    311|  #define SIZE_MAX ((size_t) -1)
  ------------------
  |  Branch (615:9): [True: 0, False: 311]
  ------------------
  616|      0|        return(-1);
  617|    311|    table = xmlMalloc(size * sizeof(table[0]));
  618|    311|    if (table == NULL)
  ------------------
  |  Branch (618:9): [True: 0, False: 311]
  ------------------
  619|      0|        return(-1);
  620|    311|    memset(table, 0, size * sizeof(table[0]));
  621|       |
  622|    311|    oldsize = dict->size;
  623|    311|    if (oldsize == 0)
  ------------------
  |  Branch (623:9): [True: 161, False: 150]
  ------------------
  624|    161|        goto done;
  625|       |
  626|    150|    oldend = &dict->table[oldsize];
  627|    150|    end = &table[size];
  628|       |
  629|       |    /*
  630|       |     * Robin Hood sorting order is maintained if we
  631|       |     *
  632|       |     * - compute dict indices with modulo
  633|       |     * - resize by an integer factor
  634|       |     * - start to copy from the beginning of a probe sequence
  635|       |     */
  636|    150|    oldentry = dict->table;
  637|    576|    while (oldentry->hashValue != 0) {
  ------------------
  |  Branch (637:12): [True: 426, False: 150]
  ------------------
  638|    426|        if (++oldentry >= oldend)
  ------------------
  |  Branch (638:13): [True: 0, False: 426]
  ------------------
  639|      0|            oldentry = dict->table;
  640|    426|    }
  641|       |
  642|  2.93k|    for (i = 0; i < oldsize; i++) {
  ------------------
  |  Branch (642:17): [True: 2.78k, False: 150]
  ------------------
  643|  2.78k|        if (oldentry->hashValue != 0) {
  ------------------
  |  Branch (643:13): [True: 2.43k, False: 348]
  ------------------
  644|  2.43k|            xmlDictEntry *entry = &table[oldentry->hashValue & (size - 1)];
  645|       |
  646|  3.18k|            while (entry->hashValue != 0) {
  ------------------
  |  Branch (646:20): [True: 750, False: 2.43k]
  ------------------
  647|    750|                if (++entry >= end)
  ------------------
  |  Branch (647:21): [True: 2, False: 748]
  ------------------
  648|      2|                    entry = table;
  649|    750|            }
  650|  2.43k|            *entry = *oldentry;
  651|  2.43k|        }
  652|       |
  653|  2.78k|        if (++oldentry >= oldend)
  ------------------
  |  Branch (653:13): [True: 150, False: 2.63k]
  ------------------
  654|    150|            oldentry = dict->table;
  655|  2.78k|    }
  656|       |
  657|    150|    xmlFree(dict->table);
  658|       |
  659|    311|done:
  660|    311|    dict->table = table;
  661|    311|    dict->size = size;
  662|       |
  663|    311|    return(0);
  664|    150|}
dict.c:xmlDictAddString:
  136|  2.49k|xmlDictAddString(xmlDictPtr dict, const xmlChar *name, unsigned int namelen) {
  137|  2.49k|    xmlDictStringsPtr pool;
  138|  2.49k|    const xmlChar *ret;
  139|  2.49k|    size_t size = 0; /* + sizeof(_xmlDictStrings) == 1024 */
  140|  2.49k|    size_t limit = 0;
  141|       |
  142|  2.49k|    pool = dict->strings;
  143|  2.49k|    while (pool != NULL) {
  ------------------
  |  Branch (143:12): [True: 2.33k, False: 161]
  ------------------
  144|  2.33k|	if ((size_t)(pool->end - pool->free) > namelen)
  ------------------
  |  Branch (144:6): [True: 2.33k, False: 0]
  ------------------
  145|  2.33k|	    goto found_pool;
  146|      0|	if (pool->size > size) size = pool->size;
  ------------------
  |  Branch (146:6): [True: 0, False: 0]
  ------------------
  147|      0|        limit += pool->size;
  148|      0|	pool = pool->next;
  149|      0|    }
  150|       |    /*
  151|       |     * Not found, need to allocate
  152|       |     */
  153|    161|    if (pool == NULL) {
  ------------------
  |  Branch (153:9): [True: 161, False: 0]
  ------------------
  154|    161|        if ((dict->limit > 0) && (limit > dict->limit)) {
  ------------------
  |  Branch (154:13): [True: 0, False: 161]
  |  Branch (154:34): [True: 0, False: 0]
  ------------------
  155|      0|            return(NULL);
  156|      0|        }
  157|       |
  158|    161|        if (size == 0) {
  ------------------
  |  Branch (158:13): [True: 161, False: 0]
  ------------------
  159|    161|            size = 1000;
  160|    161|        } else {
  161|      0|            if (size < (SIZE_MAX - sizeof(xmlDictStrings)) / 4)
  ------------------
  |  |   35|      0|  #define SIZE_MAX ((size_t) -1)
  ------------------
  |  Branch (161:17): [True: 0, False: 0]
  ------------------
  162|      0|                size *= 4; /* exponential growth */
  163|      0|            else
  164|      0|                size = SIZE_MAX - sizeof(xmlDictStrings);
  ------------------
  |  |   35|      0|  #define SIZE_MAX ((size_t) -1)
  ------------------
  165|      0|        }
  166|    161|        if (size / 4 < namelen) {
  ------------------
  |  Branch (166:13): [True: 0, False: 161]
  ------------------
  167|      0|            if ((size_t) namelen + 0 < (SIZE_MAX - sizeof(xmlDictStrings)) / 4)
  ------------------
  |  |   35|      0|  #define SIZE_MAX ((size_t) -1)
  ------------------
  |  Branch (167:17): [True: 0, False: 0]
  ------------------
  168|      0|                size = 4 * (size_t) namelen; /* just in case ! */
  169|      0|            else
  170|      0|                return(NULL);
  171|      0|        }
  172|    161|	pool = (xmlDictStringsPtr) xmlMalloc(sizeof(xmlDictStrings) + size);
  173|    161|	if (pool == NULL)
  ------------------
  |  Branch (173:6): [True: 0, False: 161]
  ------------------
  174|      0|	    return(NULL);
  175|    161|	pool->size = size;
  176|    161|	pool->nbStrings = 0;
  177|    161|	pool->free = &pool->array[0];
  178|    161|	pool->end = &pool->array[size];
  179|    161|	pool->next = dict->strings;
  180|    161|	dict->strings = pool;
  181|    161|    }
  182|  2.49k|found_pool:
  183|  2.49k|    ret = pool->free;
  184|  2.49k|    memcpy(pool->free, name, namelen);
  185|  2.49k|    pool->free += namelen;
  186|  2.49k|    *(pool->free++) = 0;
  187|  2.49k|    pool->nbStrings++;
  188|  2.49k|    return(ret);
  189|    161|}
dict.c:xoroshiro64ss:
  938|    328|xoroshiro64ss(unsigned *s) {
  939|    328|    unsigned s0 = s[0];
  940|    328|    unsigned s1 = s[1];
  941|    328|    unsigned result = HASH_ROL(s0 * 0x9E3779BB, 5) * 5;
  ------------------
  |  |   12|    328|#define HASH_ROL(x,n) ((x) << (n) | ((x) & 0xFFFFFFFF) >> (32 - (n)))
  ------------------
  942|       |
  943|    328|    s1 ^= s0;
  944|    328|    s[0] = HASH_ROL(s0, 26) ^ s1 ^ (s1 << 9);
  ------------------
  |  |   12|    328|#define HASH_ROL(x,n) ((x) << (n) | ((x) & 0xFFFFFFFF) >> (32 - (n)))
  ------------------
  945|    328|    s[1] = HASH_ROL(s1, 13);
  ------------------
  |  |   12|    328|#define HASH_ROL(x,n) ((x) << (n) | ((x) & 0xFFFFFFFF) >> (32 - (n)))
  ------------------
  946|       |
  947|    328|    return(result & 0xFFFFFFFF);
  948|    328|}

isolat1ToUTF8:
  284|  1.93k|              const unsigned char* in, int *inlen) {
  285|  1.93k|    unsigned char* outstart = out;
  286|  1.93k|    const unsigned char* base = in;
  287|  1.93k|    unsigned char* outend;
  288|  1.93k|    const unsigned char* inend;
  289|  1.93k|    const unsigned char* instop;
  290|       |
  291|  1.93k|    if ((out == NULL) || (in == NULL) || (outlen == NULL) || (inlen == NULL))
  ------------------
  |  Branch (291:9): [True: 0, False: 1.93k]
  |  Branch (291:26): [True: 0, False: 1.93k]
  |  Branch (291:42): [True: 0, False: 1.93k]
  |  Branch (291:62): [True: 0, False: 1.93k]
  ------------------
  292|      0|	return(XML_ENC_ERR_INTERNAL);
  293|       |
  294|  1.93k|    outend = out + *outlen;
  295|  1.93k|    inend = in + (*inlen);
  296|  1.93k|    instop = inend;
  297|       |
  298|  4.42k|    while ((in < inend) && (out < outend - 1)) {
  ------------------
  |  Branch (298:12): [True: 2.48k, False: 1.93k]
  |  Branch (298:28): [True: 2.48k, False: 4]
  ------------------
  299|  2.48k|	if (*in >= 0x80) {
  ------------------
  |  Branch (299:6): [True: 589, False: 1.89k]
  ------------------
  300|    589|	    *out++ = (((*in) >>  6) & 0x1F) | 0xC0;
  301|    589|            *out++ = ((*in) & 0x3F) | 0x80;
  302|    589|	    ++in;
  303|    589|	}
  304|  2.48k|	if ((instop - in) > (outend - out)) instop = in + (outend - out);
  ------------------
  |  Branch (304:6): [True: 53, False: 2.43k]
  ------------------
  305|   504k|	while ((in < instop) && (*in < 0x80)) {
  ------------------
  |  Branch (305:9): [True: 502k, False: 1.93k]
  |  Branch (305:26): [True: 502k, False: 545]
  ------------------
  306|   502k|	    *out++ = *in++;
  307|   502k|	}
  308|  2.48k|    }
  309|  1.93k|    if ((in < inend) && (out < outend) && (*in < 0x80)) {
  ------------------
  |  Branch (309:9): [True: 4, False: 1.93k]
  |  Branch (309:25): [True: 0, False: 4]
  |  Branch (309:43): [True: 0, False: 0]
  ------------------
  310|      0|        *out++ = *in++;
  311|      0|    }
  312|  1.93k|    *outlen = out - outstart;
  313|  1.93k|    *inlen = in - base;
  314|  1.93k|    return(*outlen);
  315|  1.93k|}
xmlGetEncodingAlias:
 1003|     61|xmlGetEncodingAlias(const char *alias) {
 1004|     61|    int i;
 1005|     61|    char upper[100];
 1006|       |
 1007|     61|    if (alias == NULL)
  ------------------
  |  Branch (1007:9): [True: 0, False: 61]
  ------------------
 1008|      0|	return(NULL);
 1009|       |
 1010|     61|    if (xmlCharEncodingAliases == NULL)
  ------------------
  |  Branch (1010:9): [True: 61, False: 0]
  ------------------
 1011|     61|	return(NULL);
 1012|       |
 1013|      0|    for (i = 0;i < 99;i++) {
  ------------------
  |  Branch (1013:16): [True: 0, False: 0]
  ------------------
 1014|      0|        upper[i] = (char) toupper((unsigned char) alias[i]);
 1015|      0|	if (upper[i] == 0) break;
  ------------------
  |  Branch (1015:6): [True: 0, False: 0]
  ------------------
 1016|      0|    }
 1017|      0|    upper[i] = 0;
 1018|       |
 1019|       |    /*
 1020|       |     * Walk down the list looking for a definition of the alias
 1021|       |     */
 1022|      0|    for (i = 0;i < xmlCharEncodingAliasesNb;i++) {
  ------------------
  |  Branch (1022:16): [True: 0, False: 0]
  ------------------
 1023|      0|	if (!strcmp(xmlCharEncodingAliases[i].alias, upper)) {
  ------------------
  |  Branch (1023:6): [True: 0, False: 0]
  ------------------
 1024|      0|	    return(xmlCharEncodingAliases[i].name);
 1025|      0|	}
 1026|      0|    }
 1027|      0|    return(NULL);
 1028|      0|}
xmlInitEncodingInternal:
 1470|      2|xmlInitEncodingInternal(void) {
 1471|      2|    unsigned short int tst = 0x1234;
 1472|      2|    unsigned char *ptr = (unsigned char *) &tst;
 1473|       |
 1474|      2|    if (*ptr == 0x12) xmlLittleEndian = 0;
  ------------------
  |  Branch (1474:9): [True: 0, False: 2]
  ------------------
 1475|      2|    else xmlLittleEndian = 1;
 1476|      2|}
xmlGetCharEncodingHandler:
 1547|    232|xmlGetCharEncodingHandler(xmlCharEncoding enc) {
 1548|    232|    xmlCharEncodingHandlerPtr handler;
 1549|       |
 1550|    232|    switch (enc) {
 1551|      0|        case XML_CHAR_ENCODING_ERROR:
  ------------------
  |  Branch (1551:9): [True: 0, False: 232]
  ------------------
 1552|      0|	    return(NULL);
 1553|    187|        case XML_CHAR_ENCODING_NONE:
  ------------------
  |  Branch (1553:9): [True: 187, False: 45]
  ------------------
 1554|    187|	    return(NULL);
 1555|      0|        case XML_CHAR_ENCODING_UTF8:
  ------------------
  |  Branch (1555:9): [True: 0, False: 232]
  ------------------
 1556|      0|	    return(NULL);
 1557|      0|        case XML_CHAR_ENCODING_UTF16LE:
  ------------------
  |  Branch (1557:9): [True: 0, False: 232]
  ------------------
 1558|      0|	    return((xmlCharEncodingHandlerPtr) xmlUTF16LEHandler);
 1559|      0|        case XML_CHAR_ENCODING_UTF16BE:
  ------------------
  |  Branch (1559:9): [True: 0, False: 232]
  ------------------
 1560|      0|	    return((xmlCharEncodingHandlerPtr) xmlUTF16BEHandler);
 1561|      0|        case XML_CHAR_ENCODING_EBCDIC:
  ------------------
  |  Branch (1561:9): [True: 0, False: 232]
  ------------------
 1562|      0|            handler = xmlFindCharEncodingHandler("EBCDIC");
 1563|      0|            if (handler != NULL) return(handler);
  ------------------
  |  Branch (1563:17): [True: 0, False: 0]
  ------------------
 1564|      0|            handler = xmlFindCharEncodingHandler("ebcdic");
 1565|      0|            if (handler != NULL) return(handler);
  ------------------
  |  Branch (1565:17): [True: 0, False: 0]
  ------------------
 1566|      0|            handler = xmlFindCharEncodingHandler("EBCDIC-US");
 1567|      0|            if (handler != NULL) return(handler);
  ------------------
  |  Branch (1567:17): [True: 0, False: 0]
  ------------------
 1568|      0|            handler = xmlFindCharEncodingHandler("IBM-037");
 1569|      0|            if (handler != NULL) return(handler);
  ------------------
  |  Branch (1569:17): [True: 0, False: 0]
  ------------------
 1570|      0|	    break;
 1571|      0|        case XML_CHAR_ENCODING_UCS4BE:
  ------------------
  |  Branch (1571:9): [True: 0, False: 232]
  ------------------
 1572|      0|            handler = xmlFindCharEncodingHandler("ISO-10646-UCS-4");
 1573|      0|            if (handler != NULL) return(handler);
  ------------------
  |  Branch (1573:17): [True: 0, False: 0]
  ------------------
 1574|      0|            handler = xmlFindCharEncodingHandler("UCS-4");
 1575|      0|            if (handler != NULL) return(handler);
  ------------------
  |  Branch (1575:17): [True: 0, False: 0]
  ------------------
 1576|      0|            handler = xmlFindCharEncodingHandler("UCS4");
 1577|      0|            if (handler != NULL) return(handler);
  ------------------
  |  Branch (1577:17): [True: 0, False: 0]
  ------------------
 1578|      0|	    break;
 1579|      0|        case XML_CHAR_ENCODING_UCS4LE:
  ------------------
  |  Branch (1579:9): [True: 0, False: 232]
  ------------------
 1580|      0|            handler = xmlFindCharEncodingHandler("ISO-10646-UCS-4");
 1581|      0|            if (handler != NULL) return(handler);
  ------------------
  |  Branch (1581:17): [True: 0, False: 0]
  ------------------
 1582|      0|            handler = xmlFindCharEncodingHandler("UCS-4");
 1583|      0|            if (handler != NULL) return(handler);
  ------------------
  |  Branch (1583:17): [True: 0, False: 0]
  ------------------
 1584|      0|            handler = xmlFindCharEncodingHandler("UCS4");
 1585|      0|            if (handler != NULL) return(handler);
  ------------------
  |  Branch (1585:17): [True: 0, False: 0]
  ------------------
 1586|      0|	    break;
 1587|      0|        case XML_CHAR_ENCODING_UCS4_2143:
  ------------------
  |  Branch (1587:9): [True: 0, False: 232]
  ------------------
 1588|      0|	    break;
 1589|      0|        case XML_CHAR_ENCODING_UCS4_3412:
  ------------------
  |  Branch (1589:9): [True: 0, False: 232]
  ------------------
 1590|      0|	    break;
 1591|      0|        case XML_CHAR_ENCODING_UCS2:
  ------------------
  |  Branch (1591:9): [True: 0, False: 232]
  ------------------
 1592|      0|            handler = xmlFindCharEncodingHandler("ISO-10646-UCS-2");
 1593|      0|            if (handler != NULL) return(handler);
  ------------------
  |  Branch (1593:17): [True: 0, False: 0]
  ------------------
 1594|      0|            handler = xmlFindCharEncodingHandler("UCS-2");
 1595|      0|            if (handler != NULL) return(handler);
  ------------------
  |  Branch (1595:17): [True: 0, False: 0]
  ------------------
 1596|      0|            handler = xmlFindCharEncodingHandler("UCS2");
 1597|      0|            if (handler != NULL) return(handler);
  ------------------
  |  Branch (1597:17): [True: 0, False: 0]
  ------------------
 1598|      0|	    break;
 1599|       |
 1600|       |	    /*
 1601|       |	     * We used to keep ISO Latin encodings native in the
 1602|       |	     * generated data. This led to so many problems that
 1603|       |	     * this has been removed. One can still change this
 1604|       |	     * back by registering no-ops encoders for those
 1605|       |	     */
 1606|     45|        case XML_CHAR_ENCODING_8859_1:
  ------------------
  |  Branch (1606:9): [True: 45, False: 187]
  ------------------
 1607|     45|	    handler = xmlFindCharEncodingHandler("ISO-8859-1");
 1608|     45|	    if (handler != NULL) return(handler);
  ------------------
  |  Branch (1608:10): [True: 45, False: 0]
  ------------------
 1609|      0|	    break;
 1610|      0|        case XML_CHAR_ENCODING_8859_2:
  ------------------
  |  Branch (1610:9): [True: 0, False: 232]
  ------------------
 1611|      0|	    handler = xmlFindCharEncodingHandler("ISO-8859-2");
 1612|      0|	    if (handler != NULL) return(handler);
  ------------------
  |  Branch (1612:10): [True: 0, False: 0]
  ------------------
 1613|      0|	    break;
 1614|      0|        case XML_CHAR_ENCODING_8859_3:
  ------------------
  |  Branch (1614:9): [True: 0, False: 232]
  ------------------
 1615|      0|	    handler = xmlFindCharEncodingHandler("ISO-8859-3");
 1616|      0|	    if (handler != NULL) return(handler);
  ------------------
  |  Branch (1616:10): [True: 0, False: 0]
  ------------------
 1617|      0|	    break;
 1618|      0|        case XML_CHAR_ENCODING_8859_4:
  ------------------
  |  Branch (1618:9): [True: 0, False: 232]
  ------------------
 1619|      0|	    handler = xmlFindCharEncodingHandler("ISO-8859-4");
 1620|      0|	    if (handler != NULL) return(handler);
  ------------------
  |  Branch (1620:10): [True: 0, False: 0]
  ------------------
 1621|      0|	    break;
 1622|      0|        case XML_CHAR_ENCODING_8859_5:
  ------------------
  |  Branch (1622:9): [True: 0, False: 232]
  ------------------
 1623|      0|	    handler = xmlFindCharEncodingHandler("ISO-8859-5");
 1624|      0|	    if (handler != NULL) return(handler);
  ------------------
  |  Branch (1624:10): [True: 0, False: 0]
  ------------------
 1625|      0|	    break;
 1626|      0|        case XML_CHAR_ENCODING_8859_6:
  ------------------
  |  Branch (1626:9): [True: 0, False: 232]
  ------------------
 1627|      0|	    handler = xmlFindCharEncodingHandler("ISO-8859-6");
 1628|      0|	    if (handler != NULL) return(handler);
  ------------------
  |  Branch (1628:10): [True: 0, False: 0]
  ------------------
 1629|      0|	    break;
 1630|      0|        case XML_CHAR_ENCODING_8859_7:
  ------------------
  |  Branch (1630:9): [True: 0, False: 232]
  ------------------
 1631|      0|	    handler = xmlFindCharEncodingHandler("ISO-8859-7");
 1632|      0|	    if (handler != NULL) return(handler);
  ------------------
  |  Branch (1632:10): [True: 0, False: 0]
  ------------------
 1633|      0|	    break;
 1634|      0|        case XML_CHAR_ENCODING_8859_8:
  ------------------
  |  Branch (1634:9): [True: 0, False: 232]
  ------------------
 1635|      0|	    handler = xmlFindCharEncodingHandler("ISO-8859-8");
 1636|      0|	    if (handler != NULL) return(handler);
  ------------------
  |  Branch (1636:10): [True: 0, False: 0]
  ------------------
 1637|      0|	    break;
 1638|      0|        case XML_CHAR_ENCODING_8859_9:
  ------------------
  |  Branch (1638:9): [True: 0, False: 232]
  ------------------
 1639|      0|	    handler = xmlFindCharEncodingHandler("ISO-8859-9");
 1640|      0|	    if (handler != NULL) return(handler);
  ------------------
  |  Branch (1640:10): [True: 0, False: 0]
  ------------------
 1641|      0|	    break;
 1642|       |
 1643|       |
 1644|      0|        case XML_CHAR_ENCODING_2022_JP:
  ------------------
  |  Branch (1644:9): [True: 0, False: 232]
  ------------------
 1645|      0|            handler = xmlFindCharEncodingHandler("ISO-2022-JP");
 1646|      0|            if (handler != NULL) return(handler);
  ------------------
  |  Branch (1646:17): [True: 0, False: 0]
  ------------------
 1647|      0|	    break;
 1648|      0|        case XML_CHAR_ENCODING_SHIFT_JIS:
  ------------------
  |  Branch (1648:9): [True: 0, False: 232]
  ------------------
 1649|      0|            handler = xmlFindCharEncodingHandler("SHIFT-JIS");
 1650|      0|            if (handler != NULL) return(handler);
  ------------------
  |  Branch (1650:17): [True: 0, False: 0]
  ------------------
 1651|      0|            handler = xmlFindCharEncodingHandler("SHIFT_JIS");
 1652|      0|            if (handler != NULL) return(handler);
  ------------------
  |  Branch (1652:17): [True: 0, False: 0]
  ------------------
 1653|      0|            handler = xmlFindCharEncodingHandler("Shift_JIS");
 1654|      0|            if (handler != NULL) return(handler);
  ------------------
  |  Branch (1654:17): [True: 0, False: 0]
  ------------------
 1655|      0|	    break;
 1656|      0|        case XML_CHAR_ENCODING_EUC_JP:
  ------------------
  |  Branch (1656:9): [True: 0, False: 232]
  ------------------
 1657|      0|            handler = xmlFindCharEncodingHandler("EUC-JP");
 1658|      0|            if (handler != NULL) return(handler);
  ------------------
  |  Branch (1658:17): [True: 0, False: 0]
  ------------------
 1659|      0|	    break;
 1660|      0|	default:
  ------------------
  |  Branch (1660:2): [True: 0, False: 232]
  ------------------
 1661|      0|	    break;
 1662|    232|    }
 1663|       |
 1664|      0|    return(NULL);
 1665|    232|}
xmlFindCharEncodingHandler:
 1677|     61|xmlFindCharEncodingHandler(const char *name) {
 1678|     61|    const char *nalias;
 1679|     61|    const char *norig;
 1680|     61|    xmlCharEncoding alias;
 1681|     61|#ifdef LIBXML_ICONV_ENABLED
 1682|     61|    xmlCharEncodingHandlerPtr enc;
 1683|     61|    iconv_t icv_in, icv_out;
 1684|     61|#endif /* LIBXML_ICONV_ENABLED */
 1685|       |#ifdef LIBXML_ICU_ENABLED
 1686|       |    xmlCharEncodingHandlerPtr encu;
 1687|       |    uconv_t *ucv_in, *ucv_out;
 1688|       |#endif /* LIBXML_ICU_ENABLED */
 1689|     61|    char upper[100];
 1690|     61|    int i;
 1691|       |
 1692|     61|    if (name == NULL) return(NULL);
  ------------------
  |  Branch (1692:9): [True: 0, False: 61]
  ------------------
 1693|     61|    if (name[0] == 0) return(NULL);
  ------------------
  |  Branch (1693:9): [True: 0, False: 61]
  ------------------
 1694|       |
 1695|       |    /*
 1696|       |     * Do the alias resolution
 1697|       |     */
 1698|     61|    norig = name;
 1699|     61|    nalias = xmlGetEncodingAlias(name);
 1700|     61|    if (nalias != NULL)
  ------------------
  |  Branch (1700:9): [True: 0, False: 61]
  ------------------
 1701|      0|	name = nalias;
 1702|       |
 1703|       |    /*
 1704|       |     * Check first for directly registered encoding names
 1705|       |     */
 1706|    651|    for (i = 0;i < 99;i++) {
  ------------------
  |  Branch (1706:16): [True: 651, False: 0]
  ------------------
 1707|    651|        upper[i] = (char) toupper((unsigned char) name[i]);
 1708|    651|	if (upper[i] == 0) break;
  ------------------
  |  Branch (1708:6): [True: 61, False: 590]
  ------------------
 1709|    651|    }
 1710|     61|    upper[i] = 0;
 1711|       |
 1712|    289|    for (i = 0; i < (int) NUM_DEFAULT_HANDLERS; i++) {
  ------------------
  |  | 1373|    289|    (sizeof(defaultHandlers) / sizeof(defaultHandlers[0]))
  ------------------
  |  Branch (1712:17): [True: 289, False: 0]
  ------------------
 1713|    289|        if (strcmp(upper, defaultHandlers[i].name) == 0)
  ------------------
  |  Branch (1713:13): [True: 61, False: 228]
  ------------------
 1714|     61|            return((xmlCharEncodingHandlerPtr) &defaultHandlers[i]);
 1715|    289|    }
 1716|       |
 1717|      0|    if (handlers != NULL) {
  ------------------
  |  Branch (1717:9): [True: 0, False: 0]
  ------------------
 1718|      0|        for (i = 0;i < nbCharEncodingHandler; i++) {
  ------------------
  |  Branch (1718:20): [True: 0, False: 0]
  ------------------
 1719|      0|            if (!strcmp(upper, handlers[i]->name)) {
  ------------------
  |  Branch (1719:17): [True: 0, False: 0]
  ------------------
 1720|      0|                return(handlers[i]);
 1721|      0|            }
 1722|      0|        }
 1723|      0|    }
 1724|       |
 1725|      0|#ifdef LIBXML_ICONV_ENABLED
 1726|       |    /* check whether iconv can handle this */
 1727|      0|    icv_in = iconv_open("UTF-8", name);
 1728|      0|    icv_out = iconv_open(name, "UTF-8");
 1729|      0|    if (icv_in == (iconv_t) -1) {
  ------------------
  |  Branch (1729:9): [True: 0, False: 0]
  ------------------
 1730|      0|        icv_in = iconv_open("UTF-8", upper);
 1731|      0|    }
 1732|      0|    if (icv_out == (iconv_t) -1) {
  ------------------
  |  Branch (1732:9): [True: 0, False: 0]
  ------------------
 1733|      0|	icv_out = iconv_open(upper, "UTF-8");
 1734|      0|    }
 1735|      0|    if ((icv_in != (iconv_t) -1) && (icv_out != (iconv_t) -1)) {
  ------------------
  |  Branch (1735:9): [True: 0, False: 0]
  |  Branch (1735:37): [True: 0, False: 0]
  ------------------
 1736|      0|	    enc = (xmlCharEncodingHandlerPtr)
 1737|      0|	          xmlMalloc(sizeof(xmlCharEncodingHandler));
 1738|      0|	    if (enc == NULL) {
  ------------------
  |  Branch (1738:10): [True: 0, False: 0]
  ------------------
 1739|      0|	        iconv_close(icv_in);
 1740|      0|	        iconv_close(icv_out);
 1741|      0|		return(NULL);
 1742|      0|	    }
 1743|      0|            memset(enc, 0, sizeof(xmlCharEncodingHandler));
 1744|      0|	    enc->name = xmlMemStrdup(name);
 1745|      0|            if (enc->name == NULL) {
  ------------------
  |  Branch (1745:17): [True: 0, False: 0]
  ------------------
 1746|      0|                xmlFree(enc);
 1747|      0|                iconv_close(icv_in);
 1748|      0|                iconv_close(icv_out);
 1749|      0|                return(NULL);
 1750|      0|            }
 1751|      0|	    enc->input = NULL;
 1752|      0|	    enc->output = NULL;
 1753|      0|	    enc->iconv_in = icv_in;
 1754|      0|	    enc->iconv_out = icv_out;
 1755|      0|	    return enc;
 1756|      0|    } else if ((icv_in != (iconv_t) -1) || icv_out != (iconv_t) -1) {
  ------------------
  |  Branch (1756:16): [True: 0, False: 0]
  |  Branch (1756:44): [True: 0, False: 0]
  ------------------
 1757|      0|	    if (icv_in != (iconv_t) -1)
  ------------------
  |  Branch (1757:10): [True: 0, False: 0]
  ------------------
 1758|      0|		iconv_close(icv_in);
 1759|      0|	    else
 1760|      0|		iconv_close(icv_out);
 1761|      0|    }
 1762|      0|#endif /* LIBXML_ICONV_ENABLED */
 1763|       |#ifdef LIBXML_ICU_ENABLED
 1764|       |    /* check whether icu can handle this */
 1765|       |    ucv_in = openIcuConverter(name, 1);
 1766|       |    ucv_out = openIcuConverter(name, 0);
 1767|       |    if (ucv_in != NULL && ucv_out != NULL) {
 1768|       |	    encu = (xmlCharEncodingHandlerPtr)
 1769|       |	           xmlMalloc(sizeof(xmlCharEncodingHandler));
 1770|       |	    if (encu == NULL) {
 1771|       |                closeIcuConverter(ucv_in);
 1772|       |                closeIcuConverter(ucv_out);
 1773|       |		return(NULL);
 1774|       |	    }
 1775|       |            memset(encu, 0, sizeof(xmlCharEncodingHandler));
 1776|       |	    encu->name = xmlMemStrdup(name);
 1777|       |            if (encu->name == NULL) {
 1778|       |                xmlFree(encu);
 1779|       |                closeIcuConverter(ucv_in);
 1780|       |                closeIcuConverter(ucv_out);
 1781|       |                return(NULL);
 1782|       |            }
 1783|       |	    encu->input = NULL;
 1784|       |	    encu->output = NULL;
 1785|       |	    encu->uconv_in = ucv_in;
 1786|       |	    encu->uconv_out = ucv_out;
 1787|       |	    return encu;
 1788|       |    } else if (ucv_in != NULL || ucv_out != NULL) {
 1789|       |            closeIcuConverter(ucv_in);
 1790|       |            closeIcuConverter(ucv_out);
 1791|       |    }
 1792|       |#endif /* LIBXML_ICU_ENABLED */
 1793|       |
 1794|       |    /*
 1795|       |     * Fallback using the canonical names
 1796|       |     */
 1797|      0|    alias = xmlParseCharEncoding(norig);
 1798|      0|    if (alias != XML_CHAR_ENCODING_ERROR) {
  ------------------
  |  Branch (1798:9): [True: 0, False: 0]
  ------------------
 1799|      0|        const char* canon;
 1800|      0|        canon = xmlGetCharEncodingName(alias);
 1801|      0|        if ((canon != NULL) && (strcmp(name, canon))) {
  ------------------
  |  Branch (1801:13): [True: 0, False: 0]
  |  Branch (1801:32): [True: 0, False: 0]
  ------------------
 1802|      0|	    return(xmlFindCharEncodingHandler(canon));
 1803|      0|        }
 1804|      0|    }
 1805|       |
 1806|       |    /* If "none of the above", give up */
 1807|      0|    return(NULL);
 1808|      0|}
xmlEncInputChunk:
 1988|  1.93k|                 int *outlen, const unsigned char *in, int *inlen) {
 1989|  1.93k|    int ret;
 1990|       |
 1991|  1.93k|    if (handler->input != NULL) {
  ------------------
  |  Branch (1991:9): [True: 1.93k, False: 0]
  ------------------
 1992|  1.93k|        int oldinlen = *inlen;
 1993|       |
 1994|  1.93k|        ret = handler->input(out, outlen, in, inlen);
 1995|  1.93k|        if (ret >= 0) {
  ------------------
  |  Branch (1995:13): [True: 1.93k, False: 0]
  ------------------
 1996|       |            /*
 1997|       |             * The built-in converters don't signal XML_ENC_ERR_SPACE.
 1998|       |             */
 1999|  1.93k|            if (*inlen < oldinlen) {
  ------------------
  |  Branch (1999:17): [True: 4, False: 1.93k]
  ------------------
 2000|      4|                if (*outlen > 0)
  ------------------
  |  Branch (2000:21): [True: 4, False: 0]
  ------------------
 2001|      4|                    ret = XML_ENC_ERR_SPACE;
 2002|      0|                else
 2003|      0|                    ret = XML_ENC_ERR_PARTIAL;
 2004|  1.93k|            } else {
 2005|  1.93k|                ret = XML_ENC_ERR_SUCCESS;
 2006|  1.93k|            }
 2007|  1.93k|        }
 2008|  1.93k|    }
 2009|      0|#ifdef LIBXML_ICONV_ENABLED
 2010|      0|    else if (handler->iconv_in != NULL) {
  ------------------
  |  Branch (2010:14): [True: 0, False: 0]
  ------------------
 2011|      0|        ret = xmlIconvWrapper(handler->iconv_in, out, outlen, in, inlen);
 2012|      0|    }
 2013|      0|#endif /* LIBXML_ICONV_ENABLED */
 2014|       |#ifdef LIBXML_ICU_ENABLED
 2015|       |    else if (handler->uconv_in != NULL) {
 2016|       |        ret = xmlUconvWrapper(handler->uconv_in, 1, out, outlen, in, inlen);
 2017|       |    }
 2018|       |#endif /* LIBXML_ICU_ENABLED */
 2019|      0|    else {
 2020|      0|        *outlen = 0;
 2021|      0|        *inlen = 0;
 2022|      0|        ret = XML_ENC_ERR_INTERNAL;
 2023|      0|    }
 2024|       |
 2025|       |    /* Ignore partial errors when reading. */
 2026|  1.93k|    if (ret == XML_ENC_ERR_PARTIAL)
  ------------------
  |  Branch (2026:9): [True: 0, False: 1.93k]
  ------------------
 2027|      0|        ret = XML_ENC_ERR_SUCCESS;
 2028|       |
 2029|  1.93k|    return(ret);
 2030|  1.93k|}
xmlCharEncInput:
 2118|  6.91k|{
 2119|  6.91k|    int ret;
 2120|  6.91k|    size_t avail;
 2121|  6.91k|    size_t toconv;
 2122|  6.91k|    int c_in;
 2123|  6.91k|    int c_out;
 2124|  6.91k|    xmlBufPtr in;
 2125|  6.91k|    xmlBufPtr out;
 2126|  6.91k|    const xmlChar *inData;
 2127|  6.91k|    size_t inTotal = 0;
 2128|       |
 2129|  6.91k|    if ((input == NULL) || (input->encoder == NULL) ||
  ------------------
  |  Branch (2129:9): [True: 0, False: 6.91k]
  |  Branch (2129:28): [True: 0, False: 6.91k]
  ------------------
 2130|  6.91k|        (input->buffer == NULL) || (input->raw == NULL))
  ------------------
  |  Branch (2130:9): [True: 1, False: 6.91k]
  |  Branch (2130:36): [True: 0, False: 6.91k]
  ------------------
 2131|      1|        return(XML_ENC_ERR_INTERNAL);
 2132|  6.91k|    out = input->buffer;
 2133|  6.91k|    in = input->raw;
 2134|       |
 2135|  6.91k|    toconv = xmlBufUse(in);
 2136|  6.91k|    if (toconv == 0)
  ------------------
  |  Branch (2136:9): [True: 4.97k, False: 1.93k]
  ------------------
 2137|  4.97k|        return (0);
 2138|  1.93k|    inData = xmlBufContent(in);
 2139|  1.93k|    inTotal = 0;
 2140|       |
 2141|  1.93k|    do {
 2142|  1.93k|        c_in = toconv > INT_MAX / 2 ? INT_MAX / 2 : toconv;
  ------------------
  |  Branch (2142:16): [True: 0, False: 1.93k]
  ------------------
 2143|       |
 2144|  1.93k|        avail = xmlBufAvail(out);
 2145|  1.93k|        if (avail > INT_MAX)
  ------------------
  |  Branch (2145:13): [True: 0, False: 1.93k]
  ------------------
 2146|      0|            avail = INT_MAX;
 2147|  1.93k|        if (avail < 4096) {
  ------------------
  |  Branch (2147:13): [True: 108, False: 1.83k]
  ------------------
 2148|    108|            if (xmlBufGrow(out, 4096) < 0) {
  ------------------
  |  Branch (2148:17): [True: 0, False: 108]
  ------------------
 2149|      0|                input->error = XML_ERR_NO_MEMORY;
 2150|      0|                return(XML_ENC_ERR_MEMORY);
 2151|      0|            }
 2152|    108|            avail = xmlBufAvail(out);
 2153|    108|        }
 2154|       |
 2155|  1.93k|        c_in = toconv;
 2156|  1.93k|        c_out = avail;
 2157|  1.93k|        ret = xmlEncInputChunk(input->encoder, xmlBufEnd(out), &c_out,
 2158|  1.93k|                               inData, &c_in);
 2159|  1.93k|        inTotal += c_in;
 2160|  1.93k|        inData += c_in;
 2161|  1.93k|        toconv -= c_in;
 2162|  1.93k|        xmlBufAddLen(out, c_out);
 2163|  1.93k|    } while (ret == XML_ENC_ERR_SPACE);
  ------------------
  |  Branch (2163:14): [True: 4, False: 1.93k]
  ------------------
 2164|       |
 2165|  1.93k|    xmlBufShrink(in, inTotal);
 2166|       |
 2167|  1.93k|    if (input->rawconsumed > ULONG_MAX - (unsigned long)c_in)
  ------------------
  |  Branch (2167:9): [True: 0, False: 1.93k]
  ------------------
 2168|      0|        input->rawconsumed = ULONG_MAX;
 2169|  1.93k|    else
 2170|  1.93k|        input->rawconsumed += c_in;
 2171|       |
 2172|  1.93k|    if ((c_out == 0) && (ret != 0)) {
  ------------------
  |  Branch (2172:9): [True: 0, False: 1.93k]
  |  Branch (2172:25): [True: 0, False: 0]
  ------------------
 2173|      0|        if (input->error == 0)
  ------------------
  |  Branch (2173:13): [True: 0, False: 0]
  ------------------
 2174|      0|            input->error = xmlEncConvertError(ret);
 2175|      0|        return(ret);
 2176|      0|    }
 2177|       |
 2178|  1.93k|    return (c_out);
 2179|  1.93k|}
xmlCharEncCloseFunc:
 2454|     61|xmlCharEncCloseFunc(xmlCharEncodingHandler *handler) {
 2455|     61|    int ret = 0;
 2456|     61|    int tofree = 0;
 2457|     61|    int i = 0;
 2458|       |
 2459|     61|    if (handler == NULL) return(-1);
  ------------------
  |  Branch (2459:9): [True: 0, False: 61]
  ------------------
 2460|       |
 2461|    289|    for (i = 0; i < (int) NUM_DEFAULT_HANDLERS; i++) {
  ------------------
  |  | 1373|    289|    (sizeof(defaultHandlers) / sizeof(defaultHandlers[0]))
  ------------------
  |  Branch (2461:17): [True: 289, False: 0]
  ------------------
 2462|    289|        if (handler == &defaultHandlers[i])
  ------------------
  |  Branch (2462:13): [True: 61, False: 228]
  ------------------
 2463|     61|            return(0);
 2464|    289|    }
 2465|       |
 2466|      0|    if (handlers != NULL) {
  ------------------
  |  Branch (2466:9): [True: 0, False: 0]
  ------------------
 2467|      0|        for (i = 0;i < nbCharEncodingHandler; i++) {
  ------------------
  |  Branch (2467:20): [True: 0, False: 0]
  ------------------
 2468|      0|            if (handler == handlers[i])
  ------------------
  |  Branch (2468:17): [True: 0, False: 0]
  ------------------
 2469|      0|                return(0);
 2470|      0|	}
 2471|      0|    }
 2472|      0|#ifdef LIBXML_ICONV_ENABLED
 2473|       |    /*
 2474|       |     * Iconv handlers can be used only once, free the whole block.
 2475|       |     * and the associated icon resources.
 2476|       |     */
 2477|      0|    if ((handler->iconv_out != NULL) || (handler->iconv_in != NULL)) {
  ------------------
  |  Branch (2477:9): [True: 0, False: 0]
  |  Branch (2477:41): [True: 0, False: 0]
  ------------------
 2478|      0|        tofree = 1;
 2479|      0|	if (handler->iconv_out != NULL) {
  ------------------
  |  Branch (2479:6): [True: 0, False: 0]
  ------------------
 2480|      0|	    if (iconv_close(handler->iconv_out))
  ------------------
  |  Branch (2480:10): [True: 0, False: 0]
  ------------------
 2481|      0|		ret = -1;
 2482|      0|	    handler->iconv_out = NULL;
 2483|      0|	}
 2484|      0|	if (handler->iconv_in != NULL) {
  ------------------
  |  Branch (2484:6): [True: 0, False: 0]
  ------------------
 2485|      0|	    if (iconv_close(handler->iconv_in))
  ------------------
  |  Branch (2485:10): [True: 0, False: 0]
  ------------------
 2486|      0|		ret = -1;
 2487|      0|	    handler->iconv_in = NULL;
 2488|      0|	}
 2489|      0|    }
 2490|      0|#endif /* LIBXML_ICONV_ENABLED */
 2491|       |#ifdef LIBXML_ICU_ENABLED
 2492|       |    if ((handler->uconv_out != NULL) || (handler->uconv_in != NULL)) {
 2493|       |        tofree = 1;
 2494|       |	if (handler->uconv_out != NULL) {
 2495|       |	    closeIcuConverter(handler->uconv_out);
 2496|       |	    handler->uconv_out = NULL;
 2497|       |	}
 2498|       |	if (handler->uconv_in != NULL) {
 2499|       |	    closeIcuConverter(handler->uconv_in);
 2500|       |	    handler->uconv_in = NULL;
 2501|       |	}
 2502|       |    }
 2503|       |#endif
 2504|      0|    if (tofree) {
  ------------------
  |  Branch (2504:9): [True: 0, False: 0]
  ------------------
 2505|       |        /* free up only dynamic handlers iconv/uconv */
 2506|      0|        if (handler->name != NULL)
  ------------------
  |  Branch (2506:13): [True: 0, False: 0]
  ------------------
 2507|      0|            xmlFree(handler->name);
 2508|      0|        handler->name = NULL;
 2509|      0|        xmlFree(handler);
 2510|      0|    }
 2511|       |
 2512|      0|    return(ret);
 2513|      0|}

xmlEncodeAttributeEntities:
  799|  6.68k|xmlEncodeAttributeEntities(xmlDocPtr doc, const xmlChar *input) {
  800|  6.68k|    return xmlEncodeEntitiesInternal(doc, input, 1);
  801|  6.68k|}
xmlEncodeEntitiesReentrant:
  816|  5.10k|xmlEncodeEntitiesReentrant(xmlDocPtr doc, const xmlChar *input) {
  817|  5.10k|    return xmlEncodeEntitiesInternal(doc, input, 0);
  818|  5.10k|}
entities.c:xmlEncodeEntitiesInternal:
  591|  11.7k|xmlEncodeEntitiesInternal(xmlDocPtr doc, const xmlChar *input, int attr) {
  592|  11.7k|    const xmlChar *cur = input;
  593|  11.7k|    xmlChar *buffer = NULL;
  594|  11.7k|    xmlChar *out = NULL;
  595|  11.7k|    size_t buffer_size = 0;
  596|  11.7k|    int html = 0;
  597|       |
  598|  11.7k|    if (input == NULL) return(NULL);
  ------------------
  |  Branch (598:9): [True: 0, False: 11.7k]
  ------------------
  599|  11.7k|    if (doc != NULL)
  ------------------
  |  Branch (599:9): [True: 11.7k, False: 0]
  ------------------
  600|  11.7k|        html = (doc->type == XML_HTML_DOCUMENT_NODE);
  601|       |
  602|       |    /*
  603|       |     * allocate an translation buffer.
  604|       |     */
  605|  11.7k|    buffer_size = 1000;
  606|  11.7k|    buffer = (xmlChar *) xmlMalloc(buffer_size);
  607|  11.7k|    if (buffer == NULL) {
  ------------------
  |  Branch (607:9): [True: 0, False: 11.7k]
  ------------------
  608|      0|        xmlEntitiesErrMemory("xmlEncodeEntities: malloc failed");
  609|      0|	return(NULL);
  610|      0|    }
  611|  11.7k|    out = buffer;
  612|       |
  613|   247k|    while (*cur != '\0') {
  ------------------
  |  Branch (613:12): [True: 235k, False: 11.7k]
  ------------------
  614|   235k|        size_t indx = out - buffer;
  615|   235k|        if (indx + 100 > buffer_size) {
  ------------------
  |  Branch (615:13): [True: 40, False: 235k]
  ------------------
  616|       |
  617|     80|	    growBufferReentrant();
  ------------------
  |  |  567|     40|#define growBufferReentrant() {						\
  |  |  568|     40|    xmlChar *tmp;                                                       \
  |  |  569|     40|    size_t new_size = buffer_size * 2;                                  \
  |  |  570|     40|    if (new_size < buffer_size) goto mem_error;                         \
  |  |  ------------------
  |  |  |  Branch (570:9): [True: 0, False: 40]
  |  |  ------------------
  |  |  571|     40|    tmp = (xmlChar *) xmlRealloc(buffer, new_size);	                \
  |  |  572|     40|    if (tmp == NULL) goto mem_error;                                    \
  |  |  ------------------
  |  |  |  Branch (572:9): [True: 0, False: 40]
  |  |  ------------------
  |  |  573|     40|    buffer = tmp;							\
  |  |  574|     40|    buffer_size = new_size;						\
  |  |  575|     40|}
  ------------------
  618|     80|	    out = &buffer[indx];
  619|     80|	}
  620|       |
  621|       |	/*
  622|       |	 * By default one have to encode at least '<', '>', '"' and '&' !
  623|       |	 */
  624|   235k|	if (*cur == '<') {
  ------------------
  |  Branch (624:6): [True: 22, False: 235k]
  ------------------
  625|     22|	    const xmlChar *end;
  626|       |
  627|       |	    /*
  628|       |	     * Special handling of server side include in HTML attributes
  629|       |	     */
  630|     22|	    if (html && attr &&
  ------------------
  |  Branch (630:10): [True: 22, False: 0]
  |  Branch (630:18): [True: 20, False: 2]
  ------------------
  631|     22|	        (cur[1] == '!') && (cur[2] == '-') && (cur[3] == '-') &&
  ------------------
  |  Branch (631:10): [True: 0, False: 20]
  |  Branch (631:29): [True: 0, False: 0]
  |  Branch (631:48): [True: 0, False: 0]
  ------------------
  632|     22|	        ((end = xmlStrstr(cur, BAD_CAST "-->")) != NULL)) {
  ------------------
  |  |   35|      0|#define BAD_CAST (xmlChar *)
  ------------------
  |  Branch (632:10): [True: 0, False: 0]
  ------------------
  633|      0|	        while (cur != end) {
  ------------------
  |  Branch (633:17): [True: 0, False: 0]
  ------------------
  634|      0|		    *out++ = *cur++;
  635|      0|		    indx = out - buffer;
  636|      0|		    if (indx + 100 > buffer_size) {
  ------------------
  |  Branch (636:11): [True: 0, False: 0]
  ------------------
  637|      0|			growBufferReentrant();
  ------------------
  |  |  567|      0|#define growBufferReentrant() {						\
  |  |  568|      0|    xmlChar *tmp;                                                       \
  |  |  569|      0|    size_t new_size = buffer_size * 2;                                  \
  |  |  570|      0|    if (new_size < buffer_size) goto mem_error;                         \
  |  |  ------------------
  |  |  |  Branch (570:9): [True: 0, False: 0]
  |  |  ------------------
  |  |  571|      0|    tmp = (xmlChar *) xmlRealloc(buffer, new_size);	                \
  |  |  572|      0|    if (tmp == NULL) goto mem_error;                                    \
  |  |  ------------------
  |  |  |  Branch (572:9): [True: 0, False: 0]
  |  |  ------------------
  |  |  573|      0|    buffer = tmp;							\
  |  |  574|      0|    buffer_size = new_size;						\
  |  |  575|      0|}
  ------------------
  638|      0|			out = &buffer[indx];
  639|      0|		    }
  640|      0|		}
  641|      0|		*out++ = *cur++;
  642|      0|		*out++ = *cur++;
  643|      0|		*out++ = *cur++;
  644|      0|		continue;
  645|      0|	    }
  646|     22|	    *out++ = '&';
  647|     22|	    *out++ = 'l';
  648|     22|	    *out++ = 't';
  649|     22|	    *out++ = ';';
  650|   235k|	} else if (*cur == '>') {
  ------------------
  |  Branch (650:13): [True: 41, False: 235k]
  ------------------
  651|     41|	    *out++ = '&';
  652|     41|	    *out++ = 'g';
  653|     41|	    *out++ = 't';
  654|     41|	    *out++ = ';';
  655|   235k|	} else if (*cur == '&') {
  ------------------
  |  Branch (655:13): [True: 325, False: 235k]
  ------------------
  656|       |	    /*
  657|       |	     * Special handling of &{...} construct from HTML 4, see
  658|       |	     * http://www.w3.org/TR/html401/appendix/notes.html#h-B.7.1
  659|       |	     */
  660|    325|	    if (html && attr && (cur[1] == '{') &&
  ------------------
  |  Branch (660:10): [True: 325, False: 0]
  |  Branch (660:18): [True: 303, False: 22]
  |  Branch (660:26): [True: 0, False: 303]
  ------------------
  661|    325|	        (strchr((const char *) cur, '}'))) {
  ------------------
  |  Branch (661:10): [True: 0, False: 0]
  ------------------
  662|      0|	        while (*cur != '}') {
  ------------------
  |  Branch (662:17): [True: 0, False: 0]
  ------------------
  663|      0|		    *out++ = *cur++;
  664|      0|		    indx = out - buffer;
  665|      0|		    if (indx + 100 > buffer_size) {
  ------------------
  |  Branch (665:11): [True: 0, False: 0]
  ------------------
  666|      0|			growBufferReentrant();
  ------------------
  |  |  567|      0|#define growBufferReentrant() {						\
  |  |  568|      0|    xmlChar *tmp;                                                       \
  |  |  569|      0|    size_t new_size = buffer_size * 2;                                  \
  |  |  570|      0|    if (new_size < buffer_size) goto mem_error;                         \
  |  |  ------------------
  |  |  |  Branch (570:9): [True: 0, False: 0]
  |  |  ------------------
  |  |  571|      0|    tmp = (xmlChar *) xmlRealloc(buffer, new_size);	                \
  |  |  572|      0|    if (tmp == NULL) goto mem_error;                                    \
  |  |  ------------------
  |  |  |  Branch (572:9): [True: 0, False: 0]
  |  |  ------------------
  |  |  573|      0|    buffer = tmp;							\
  |  |  574|      0|    buffer_size = new_size;						\
  |  |  575|      0|}
  ------------------
  667|      0|			out = &buffer[indx];
  668|      0|		    }
  669|      0|		}
  670|      0|		*out++ = *cur++;
  671|      0|		continue;
  672|      0|	    }
  673|    325|	    *out++ = '&';
  674|    325|	    *out++ = 'a';
  675|    325|	    *out++ = 'm';
  676|    325|	    *out++ = 'p';
  677|    325|	    *out++ = ';';
  678|   235k|	} else if (((*cur >= 0x20) && (*cur < 0x80)) ||
  ------------------
  |  Branch (678:14): [True: 229k, False: 6.13k]
  |  Branch (678:32): [True: 215k, False: 14.2k]
  ------------------
  679|   235k|	    (*cur == '\n') || (*cur == '\t') || ((html) && (*cur == '\r'))) {
  ------------------
  |  Branch (679:6): [True: 4.22k, False: 16.1k]
  |  Branch (679:24): [True: 356, False: 15.7k]
  |  Branch (679:43): [True: 15.7k, False: 0]
  |  Branch (679:53): [True: 1.47k, False: 14.2k]
  ------------------
  680|       |	    /*
  681|       |	     * default case, just copy !
  682|       |	     */
  683|   221k|	    *out++ = *cur;
  684|   221k|	} else if (*cur >= 0x80) {
  ------------------
  |  Branch (684:13): [True: 14.2k, False: 77]
  ------------------
  685|  14.2k|	    if (((doc != NULL) && (doc->encoding != NULL)) || (html)) {
  ------------------
  |  Branch (685:11): [True: 14.2k, False: 0]
  |  Branch (685:28): [True: 14.1k, False: 30]
  |  Branch (685:56): [True: 30, False: 0]
  ------------------
  686|       |		/*
  687|       |		 * Bjørn Reese <br@sseusa.com> provided the patch
  688|       |	        xmlChar xc;
  689|       |	        xc = (*cur & 0x3F) << 6;
  690|       |	        if (cur[1] != 0) {
  691|       |		    xc += *(++cur) & 0x3F;
  692|       |		    *out++ = xc;
  693|       |	        } else
  694|       |		 */
  695|  14.2k|		*out++ = *cur;
  696|  14.2k|	    } else {
  697|       |		/*
  698|       |		 * We assume we have UTF-8 input.
  699|       |		 * It must match either:
  700|       |		 *   110xxxxx 10xxxxxx
  701|       |		 *   1110xxxx 10xxxxxx 10xxxxxx
  702|       |		 *   11110xxx 10xxxxxx 10xxxxxx 10xxxxxx
  703|       |		 * That is:
  704|       |		 *   cur[0] is 11xxxxxx
  705|       |		 *   cur[1] is 10xxxxxx
  706|       |		 *   cur[2] is 10xxxxxx if cur[0] is 111xxxxx
  707|       |		 *   cur[3] is 10xxxxxx if cur[0] is 1111xxxx
  708|       |		 *   cur[0] is not 11111xxx
  709|       |		 */
  710|      0|		char buf[11], *ptr;
  711|      0|		int val = 0, l = 1;
  712|       |
  713|      0|		if (((cur[0] & 0xC0) != 0xC0) ||
  ------------------
  |  Branch (713:7): [True: 0, False: 0]
  ------------------
  714|      0|		    ((cur[1] & 0xC0) != 0x80) ||
  ------------------
  |  Branch (714:7): [True: 0, False: 0]
  ------------------
  715|      0|		    (((cur[0] & 0xE0) == 0xE0) && ((cur[2] & 0xC0) != 0x80)) ||
  ------------------
  |  Branch (715:8): [True: 0, False: 0]
  |  Branch (715:37): [True: 0, False: 0]
  ------------------
  716|      0|		    (((cur[0] & 0xF0) == 0xF0) && ((cur[3] & 0xC0) != 0x80)) ||
  ------------------
  |  Branch (716:8): [True: 0, False: 0]
  |  Branch (716:37): [True: 0, False: 0]
  ------------------
  717|      0|		    (((cur[0] & 0xF8) == 0xF8))) {
  ------------------
  |  Branch (717:7): [True: 0, False: 0]
  ------------------
  718|      0|		    xmlEntitiesErr(XML_CHECK_NOT_UTF8,
  719|      0|			    "xmlEncodeEntities: input not UTF-8");
  720|      0|		    snprintf(buf, sizeof(buf), "&#%d;", *cur);
  721|      0|		    buf[sizeof(buf) - 1] = 0;
  722|      0|		    ptr = buf;
  723|      0|		    while (*ptr != 0) *out++ = *ptr++;
  ------------------
  |  Branch (723:14): [True: 0, False: 0]
  ------------------
  724|      0|		    cur++;
  725|      0|		    continue;
  726|      0|		} else if (*cur < 0xE0) {
  ------------------
  |  Branch (726:14): [True: 0, False: 0]
  ------------------
  727|      0|                    val = (cur[0]) & 0x1F;
  728|      0|		    val <<= 6;
  729|      0|		    val |= (cur[1]) & 0x3F;
  730|      0|		    l = 2;
  731|      0|		} else if (*cur < 0xF0) {
  ------------------
  |  Branch (731:14): [True: 0, False: 0]
  ------------------
  732|      0|                    val = (cur[0]) & 0x0F;
  733|      0|		    val <<= 6;
  734|      0|		    val |= (cur[1]) & 0x3F;
  735|      0|		    val <<= 6;
  736|      0|		    val |= (cur[2]) & 0x3F;
  737|      0|		    l = 3;
  738|      0|		} else if (*cur < 0xF8) {
  ------------------
  |  Branch (738:14): [True: 0, False: 0]
  ------------------
  739|      0|                    val = (cur[0]) & 0x07;
  740|      0|		    val <<= 6;
  741|      0|		    val |= (cur[1]) & 0x3F;
  742|      0|		    val <<= 6;
  743|      0|		    val |= (cur[2]) & 0x3F;
  744|      0|		    val <<= 6;
  745|      0|		    val |= (cur[3]) & 0x3F;
  746|      0|		    l = 4;
  747|      0|		}
  748|      0|		if ((l == 1) || (!IS_CHAR(val))) {
  ------------------
  |  |  125|      0|#define IS_CHAR(c)   xmlIsCharQ(c)
  |  |  ------------------
  |  |  |  |  118|      0|#define xmlIsCharQ(c)		(((c) < 0x100) ? \
  |  |  |  |  ------------------
  |  |  |  |  |  Branch (118:25): [True: 0, False: 0]
  |  |  |  |  ------------------
  |  |  |  |  119|      0|				 xmlIsChar_ch((c)) :\
  |  |  |  |  ------------------
  |  |  |  |  |  |  108|      0|#define xmlIsChar_ch(c)		(((0x9 <= (c)) && ((c) <= 0xa)) || \
  |  |  |  |  |  |  ------------------
  |  |  |  |  |  |  |  Branch (108:28): [True: 0, False: 0]
  |  |  |  |  |  |  |  Branch (108:44): [True: 0, False: 0]
  |  |  |  |  |  |  ------------------
  |  |  |  |  |  |  109|      0|				 ((c) == 0xd) || \
  |  |  |  |  |  |  ------------------
  |  |  |  |  |  |  |  Branch (109:6): [True: 0, False: 0]
  |  |  |  |  |  |  ------------------
  |  |  |  |  |  |  110|      0|				  (0x20 <= (c)))
  |  |  |  |  |  |  ------------------
  |  |  |  |  |  |  |  Branch (110:7): [True: 0, False: 0]
  |  |  |  |  |  |  ------------------
  |  |  |  |  ------------------
  |  |  |  |  120|      0|				(((0x100 <= (c)) && ((c) <= 0xd7ff)) || \
  |  |  |  |  ------------------
  |  |  |  |  |  Branch (120:7): [True: 0, False: 0]
  |  |  |  |  |  Branch (120:25): [True: 0, False: 0]
  |  |  |  |  ------------------
  |  |  |  |  121|      0|				 ((0xe000 <= (c)) && ((c) <= 0xfffd)) || \
  |  |  |  |  ------------------
  |  |  |  |  |  Branch (121:7): [True: 0, False: 0]
  |  |  |  |  |  Branch (121:26): [True: 0, False: 0]
  |  |  |  |  ------------------
  |  |  |  |  122|      0|				 ((0x10000 <= (c)) && ((c) <= 0x10ffff))))
  |  |  |  |  ------------------
  |  |  |  |  |  Branch (122:7): [True: 0, False: 0]
  |  |  |  |  |  Branch (122:27): [True: 0, False: 0]
  |  |  |  |  ------------------
  |  |  ------------------
  ------------------
  |  Branch (748:7): [True: 0, False: 0]
  |  Branch (748:19): [True: 0, False: 0]
  ------------------
  749|      0|		    xmlEntitiesErr(XML_ERR_INVALID_CHAR,
  750|      0|			"xmlEncodeEntities: char out of range\n");
  751|      0|		    snprintf(buf, sizeof(buf), "&#%d;", *cur);
  752|      0|		    buf[sizeof(buf) - 1] = 0;
  753|      0|		    ptr = buf;
  754|      0|		    while (*ptr != 0) *out++ = *ptr++;
  ------------------
  |  Branch (754:14): [True: 0, False: 0]
  ------------------
  755|      0|		    cur++;
  756|      0|		    continue;
  757|      0|		}
  758|       |		/*
  759|       |		 * We could do multiple things here. Just save as a char ref
  760|       |		 */
  761|      0|		snprintf(buf, sizeof(buf), "&#x%X;", val);
  762|      0|		buf[sizeof(buf) - 1] = 0;
  763|      0|		ptr = buf;
  764|      0|		while (*ptr != 0) *out++ = *ptr++;
  ------------------
  |  Branch (764:10): [True: 0, False: 0]
  ------------------
  765|      0|		cur += l;
  766|      0|		continue;
  767|      0|	    }
  768|  14.2k|	} else if (IS_BYTE_CHAR(*cur)) {
  ------------------
  |  |  113|     77|#define IS_BYTE_CHAR(c)	 xmlIsChar_ch(c)
  |  |  ------------------
  |  |  |  |  108|     77|#define xmlIsChar_ch(c)		(((0x9 <= (c)) && ((c) <= 0xa)) || \
  |  |  |  |  ------------------
  |  |  |  |  |  Branch (108:28): [True: 77, False: 0]
  |  |  |  |  |  Branch (108:44): [True: 0, False: 77]
  |  |  |  |  ------------------
  |  |  |  |  109|     77|				 ((c) == 0xd) || \
  |  |  |  |  ------------------
  |  |  |  |  |  Branch (109:6): [True: 0, False: 77]
  |  |  |  |  ------------------
  |  |  |  |  110|     77|				  (0x20 <= (c)))
  |  |  |  |  ------------------
  |  |  |  |  |  Branch (110:7): [True: 0, False: 77]
  |  |  |  |  ------------------
  |  |  ------------------
  ------------------
  769|      0|	    char buf[11], *ptr;
  770|       |
  771|      0|	    snprintf(buf, sizeof(buf), "&#%d;", *cur);
  772|      0|	    buf[sizeof(buf) - 1] = 0;
  773|      0|            ptr = buf;
  774|      0|	    while (*ptr != 0) *out++ = *ptr++;
  ------------------
  |  Branch (774:13): [True: 0, False: 0]
  ------------------
  775|      0|	}
  776|   235k|	cur++;
  777|   235k|    }
  778|  11.7k|    *out = 0;
  779|  11.7k|    return(buffer);
  780|       |
  781|      0|mem_error:
  782|      0|    xmlEntitiesErrMemory("xmlEncodeEntities: realloc failed");
  783|      0|    xmlFree(buffer);
  784|      0|    return(NULL);
  785|  11.7k|}

xmlSetGenericErrorFunc:
  114|      2|xmlSetGenericErrorFunc(void *ctx, xmlGenericErrorFunc handler) {
  115|      2|    xmlGenericErrorContext = ctx;
  ------------------
  |  |  876|      2|  #define xmlGenericErrorContext XML_GLOBAL_MACRO(xmlGenericErrorContext)
  |  |  ------------------
  |  |  |  |  500|      2|  #define XML_GLOBAL_MACRO(name) (*__##name())
  |  |  ------------------
  ------------------
  116|      2|    if (handler != NULL)
  ------------------
  |  Branch (116:9): [True: 2, False: 0]
  ------------------
  117|      2|	xmlGenericError = handler;
  ------------------
  |  |  875|      2|  #define xmlGenericError XML_GLOBAL_MACRO(xmlGenericError)
  |  |  ------------------
  |  |  |  |  500|      2|  #define XML_GLOBAL_MACRO(name) (*__##name())
  |  |  ------------------
  ------------------
  118|      0|    else
  119|      0|	xmlGenericError = xmlGenericErrorDefaultFunc;
  ------------------
  |  |  875|      0|  #define xmlGenericError XML_GLOBAL_MACRO(xmlGenericError)
  |  |  ------------------
  |  |  |  |  500|      0|  #define XML_GLOBAL_MACRO(name) (*__##name())
  |  |  ------------------
  ------------------
  120|      2|}
__xmlRaiseError:
  475|  1.28k|{
  476|  1.28k|    xmlParserCtxtPtr ctxt = NULL;
  477|  1.28k|    xmlNodePtr node = (xmlNodePtr) nod;
  478|  1.28k|    char *str = NULL;
  479|  1.28k|    xmlParserInputPtr input = NULL;
  480|  1.28k|    xmlErrorPtr to = &xmlLastError;
  ------------------
  |  |  874|  1.28k|  #define xmlLastError XML_GLOBAL_MACRO(xmlLastError)
  |  |  ------------------
  |  |  |  |  500|  1.28k|  #define XML_GLOBAL_MACRO(name) (*__##name())
  |  |  ------------------
  ------------------
  481|  1.28k|    xmlNodePtr baseptr = NULL;
  482|       |
  483|  1.28k|    if (code == XML_ERR_OK)
  ------------------
  |  Branch (483:9): [True: 0, False: 1.28k]
  ------------------
  484|      0|        return;
  485|  1.28k|    if ((xmlGetWarningsDefaultValue == 0) && (level == XML_ERR_WARNING))
  ------------------
  |  |  865|  1.28k|    XML_GLOBAL_MACRO(xmlGetWarningsDefaultValue)
  |  |  ------------------
  |  |  |  |  500|  1.28k|  #define XML_GLOBAL_MACRO(name) (*__##name())
  |  |  ------------------
  ------------------
  |  Branch (485:9): [True: 0, False: 1.28k]
  |  Branch (485:46): [True: 0, False: 0]
  ------------------
  486|      0|        return;
  487|  1.28k|    if ((domain == XML_FROM_PARSER) || (domain == XML_FROM_HTML) ||
  ------------------
  |  Branch (487:9): [True: 36, False: 1.24k]
  |  Branch (487:40): [True: 1.23k, False: 8]
  ------------------
  488|  1.28k|        (domain == XML_FROM_DTD) || (domain == XML_FROM_NAMESPACE) ||
  ------------------
  |  Branch (488:9): [True: 0, False: 8]
  |  Branch (488:37): [True: 0, False: 8]
  ------------------
  489|  1.28k|	(domain == XML_FROM_IO) || (domain == XML_FROM_VALID)) {
  ------------------
  |  Branch (489:2): [True: 0, False: 8]
  |  Branch (489:29): [True: 2, False: 6]
  ------------------
  490|  1.27k|	ctxt = (xmlParserCtxtPtr) ctx;
  491|       |
  492|  1.27k|        if (ctxt != NULL) {
  ------------------
  |  Branch (492:13): [True: 1.26k, False: 10]
  ------------------
  493|  1.26k|            if (level == XML_ERR_WARNING) {
  ------------------
  |  Branch (493:17): [True: 0, False: 1.26k]
  ------------------
  494|      0|                if (ctxt->nbWarnings >= XML_MAX_ERRORS)
  ------------------
  |  |   20|      0|#define XML_MAX_ERRORS 100
  ------------------
  |  Branch (494:21): [True: 0, False: 0]
  ------------------
  495|      0|                    return;
  496|      0|                ctxt->nbWarnings += 1;
  497|  1.26k|            } else {
  498|  1.26k|                if (ctxt->nbErrors >= XML_MAX_ERRORS)
  ------------------
  |  |   20|  1.26k|#define XML_MAX_ERRORS 100
  ------------------
  |  Branch (498:21): [True: 0, False: 1.26k]
  ------------------
  499|      0|                    return;
  500|  1.26k|                ctxt->nbErrors += 1;
  501|  1.26k|            }
  502|       |
  503|  1.26k|            if ((schannel == NULL) && (ctxt->sax != NULL) &&
  ------------------
  |  Branch (503:17): [True: 1.26k, False: 0]
  |  Branch (503:39): [True: 1.26k, False: 0]
  ------------------
  504|  1.26k|                (ctxt->sax->initialized == XML_SAX2_MAGIC) &&
  ------------------
  |  |  685|  1.26k|#define XML_SAX2_MAGIC 0xDEEDBEAF
  ------------------
  |  Branch (504:17): [True: 0, False: 1.26k]
  ------------------
  505|  1.26k|                (ctxt->sax->serror != NULL)) {
  ------------------
  |  Branch (505:17): [True: 0, False: 0]
  ------------------
  506|      0|                schannel = ctxt->sax->serror;
  507|      0|                data = ctxt->userData;
  508|      0|            }
  509|  1.26k|        }
  510|  1.27k|    }
  511|       |    /*
  512|       |     * Check if structured error handler set
  513|       |     */
  514|  1.28k|    if (schannel == NULL) {
  ------------------
  |  Branch (514:9): [True: 1.28k, False: 0]
  ------------------
  515|  1.28k|	schannel = xmlStructuredError;
  ------------------
  |  |  877|  1.28k|  #define xmlStructuredError XML_GLOBAL_MACRO(xmlStructuredError)
  |  |  ------------------
  |  |  |  |  500|  1.28k|  #define XML_GLOBAL_MACRO(name) (*__##name())
  |  |  ------------------
  ------------------
  516|       |	/*
  517|       |	 * if user has defined handler, change data ptr to user's choice
  518|       |	 */
  519|  1.28k|	if (schannel != NULL)
  ------------------
  |  Branch (519:6): [True: 0, False: 1.28k]
  ------------------
  520|      0|	    data = xmlStructuredErrorContext;
  ------------------
  |  |  878|      0|  #define xmlStructuredErrorContext XML_GLOBAL_MACRO(xmlStructuredErrorContext)
  |  |  ------------------
  |  |  |  |  500|      0|  #define XML_GLOBAL_MACRO(name) (*__##name())
  |  |  ------------------
  ------------------
  521|  1.28k|    }
  522|       |    /*
  523|       |     * Formatting the message
  524|       |     */
  525|  1.28k|    if (msg == NULL) {
  ------------------
  |  Branch (525:9): [True: 0, False: 1.28k]
  ------------------
  526|      0|        str = (char *) xmlStrdup(BAD_CAST "No error message provided");
  ------------------
  |  |   35|      0|#define BAD_CAST (xmlChar *)
  ------------------
  527|  1.28k|    } else {
  528|  1.28k|        XML_GET_VAR_STR(msg, str);
  ------------------
  |  |   22|  1.28k|#define XML_GET_VAR_STR(msg, str) {				\
  |  |   23|  1.28k|    int       size, prev_size = -1;				\
  |  |   24|  1.28k|    int       chars;						\
  |  |   25|  1.28k|    char      *larger;						\
  |  |   26|  1.28k|    va_list   ap;						\
  |  |   27|  1.28k|								\
  |  |   28|  1.28k|    str = (char *) xmlMalloc(150);				\
  |  |   29|  1.28k|    if (str != NULL) {						\
  |  |  ------------------
  |  |  |  Branch (29:9): [True: 1.25k, False: 28]
  |  |  ------------------
  |  |   30|  1.25k|								\
  |  |   31|  1.25k|    size = 150;							\
  |  |   32|  1.25k|								\
  |  |   33|  2.50k|    while (size < 64000) {					\
  |  |  ------------------
  |  |  |  Branch (33:12): [True: 2.50k, False: 0]
  |  |  ------------------
  |  |   34|  2.50k|	va_start(ap, msg);					\
  |  |   35|  2.50k|	chars = vsnprintf(str, size, msg, ap);			\
  |  |   36|  2.50k|	va_end(ap);						\
  |  |   37|  2.50k|	if ((chars > -1) && (chars < size)) {			\
  |  |  ------------------
  |  |  |  Branch (37:6): [True: 2.50k, False: 0]
  |  |  |  Branch (37:22): [True: 2.50k, False: 0]
  |  |  ------------------
  |  |   38|  2.50k|	    if (prev_size == chars) {				\
  |  |  ------------------
  |  |  |  Branch (38:10): [True: 1.25k, False: 1.25k]
  |  |  ------------------
  |  |   39|  1.25k|		break;						\
  |  |   40|  1.25k|	    } else {						\
  |  |   41|  1.25k|		prev_size = chars;				\
  |  |   42|  1.25k|	    }							\
  |  |   43|  2.50k|	}							\
  |  |   44|  2.50k|	if (chars > -1)						\
  |  |  ------------------
  |  |  |  Branch (44:6): [True: 1.25k, False: 0]
  |  |  ------------------
  |  |   45|  1.25k|	    size += chars + 1;					\
  |  |   46|  1.25k|	else							\
  |  |   47|  1.25k|	    size += 100;					\
  |  |   48|  1.25k|	if ((larger = (char *) xmlRealloc(str, size)) == NULL) {\
  |  |  ------------------
  |  |  |  Branch (48:6): [True: 1, False: 1.25k]
  |  |  ------------------
  |  |   49|      1|	    break;						\
  |  |   50|      1|	}							\
  |  |   51|  1.25k|	str = larger;						\
  |  |   52|  1.25k|    }}								\
  |  |   53|  1.28k|}
  ------------------
  529|  1.28k|    }
  530|       |
  531|       |    /*
  532|       |     * specific processing if a parser context is provided
  533|       |     */
  534|  1.28k|    if (ctxt != NULL) {
  ------------------
  |  Branch (534:9): [True: 1.26k, False: 16]
  ------------------
  535|  1.26k|        if (file == NULL) {
  ------------------
  |  Branch (535:13): [True: 1.26k, False: 0]
  ------------------
  536|  1.26k|            input = ctxt->input;
  537|  1.26k|            if ((input != NULL) && (input->filename == NULL) &&
  ------------------
  |  Branch (537:17): [True: 1.26k, False: 0]
  |  Branch (537:36): [True: 1.26k, False: 0]
  ------------------
  538|  1.26k|                (ctxt->inputNr > 1)) {
  ------------------
  |  Branch (538:17): [True: 0, False: 1.26k]
  ------------------
  539|      0|                input = ctxt->inputTab[ctxt->inputNr - 2];
  540|      0|            }
  541|  1.26k|            if (input != NULL) {
  ------------------
  |  Branch (541:17): [True: 1.26k, False: 0]
  ------------------
  542|  1.26k|                file = input->filename;
  543|  1.26k|                line = input->line;
  544|  1.26k|                col = input->col;
  545|  1.26k|            }
  546|  1.26k|        }
  547|  1.26k|        to = &ctxt->lastError;
  548|  1.26k|    } else if ((node != NULL) && (file == NULL)) {
  ------------------
  |  Branch (548:16): [True: 0, False: 16]
  |  Branch (548:34): [True: 0, False: 0]
  ------------------
  549|      0|	int i;
  550|       |
  551|      0|	if ((node->doc != NULL) && (node->doc->URL != NULL)) {
  ------------------
  |  Branch (551:6): [True: 0, False: 0]
  |  Branch (551:29): [True: 0, False: 0]
  ------------------
  552|      0|	    baseptr = node;
  553|       |/*	    file = (const char *) node->doc->URL; */
  554|      0|	}
  555|      0|	for (i = 0;
  556|      0|	     ((i < 10) && (node != NULL) && (node->type != XML_ELEMENT_NODE));
  ------------------
  |  Branch (556:8): [True: 0, False: 0]
  |  Branch (556:20): [True: 0, False: 0]
  |  Branch (556:38): [True: 0, False: 0]
  ------------------
  557|      0|	     i++)
  558|      0|	     node = node->parent;
  559|      0|        if ((baseptr == NULL) && (node != NULL) &&
  ------------------
  |  Branch (559:13): [True: 0, False: 0]
  |  Branch (559:34): [True: 0, False: 0]
  ------------------
  560|      0|	    (node->doc != NULL) && (node->doc->URL != NULL))
  ------------------
  |  Branch (560:6): [True: 0, False: 0]
  |  Branch (560:29): [True: 0, False: 0]
  ------------------
  561|      0|	    baseptr = node;
  562|       |
  563|      0|	if ((node != NULL) && (node->type == XML_ELEMENT_NODE))
  ------------------
  |  Branch (563:6): [True: 0, False: 0]
  |  Branch (563:24): [True: 0, False: 0]
  ------------------
  564|      0|	    line = node->line;
  565|      0|	if ((line == 0) || (line == 65535))
  ------------------
  |  Branch (565:6): [True: 0, False: 0]
  |  Branch (565:21): [True: 0, False: 0]
  ------------------
  566|      0|	    line = xmlGetLineNo(node);
  567|      0|    }
  568|       |
  569|       |    /*
  570|       |     * Save the information about the error
  571|       |     */
  572|  1.28k|    xmlResetError(to);
  573|  1.28k|    to->domain = domain;
  574|  1.28k|    to->code = code;
  575|  1.28k|    to->message = str;
  576|  1.28k|    to->level = level;
  577|  1.28k|    if (file != NULL)
  ------------------
  |  Branch (577:9): [True: 0, False: 1.28k]
  ------------------
  578|      0|        to->file = (char *) xmlStrdup((const xmlChar *) file);
  579|  1.28k|    else if (baseptr != NULL) {
  ------------------
  |  Branch (579:14): [True: 0, False: 1.28k]
  ------------------
  580|      0|#ifdef LIBXML_XINCLUDE_ENABLED
  581|       |	/*
  582|       |	 * We check if the error is within an XInclude section and,
  583|       |	 * if so, attempt to print out the href of the XInclude instead
  584|       |	 * of the usual "base" (doc->URL) for the node (bug 152623).
  585|       |	 */
  586|      0|        xmlNodePtr prev = baseptr;
  587|      0|        char *href = NULL;
  588|      0|	int inclcount = 0;
  589|      0|	while (prev != NULL) {
  ------------------
  |  Branch (589:9): [True: 0, False: 0]
  ------------------
  590|      0|	    if (prev->prev == NULL)
  ------------------
  |  Branch (590:10): [True: 0, False: 0]
  ------------------
  591|      0|	        prev = prev->parent;
  592|      0|	    else {
  593|      0|	        prev = prev->prev;
  594|      0|		if (prev->type == XML_XINCLUDE_START) {
  ------------------
  |  Branch (594:7): [True: 0, False: 0]
  ------------------
  595|      0|		    if (inclcount > 0) {
  ------------------
  |  Branch (595:11): [True: 0, False: 0]
  ------------------
  596|      0|                        --inclcount;
  597|      0|                    } else {
  598|      0|                        href = (char *) xmlGetProp(prev, BAD_CAST "href");
  ------------------
  |  |   35|      0|#define BAD_CAST (xmlChar *)
  ------------------
  599|      0|                        if (href != NULL)
  ------------------
  |  Branch (599:29): [True: 0, False: 0]
  ------------------
  600|      0|		            break;
  601|      0|                    }
  602|      0|		} else if (prev->type == XML_XINCLUDE_END)
  ------------------
  |  Branch (602:14): [True: 0, False: 0]
  ------------------
  603|      0|		    inclcount++;
  604|      0|	    }
  605|      0|	}
  606|      0|        if (href != NULL)
  ------------------
  |  Branch (606:13): [True: 0, False: 0]
  ------------------
  607|      0|            to->file = href;
  608|      0|	else
  609|      0|#endif
  610|      0|	    to->file = (char *) xmlStrdup(baseptr->doc->URL);
  611|      0|	if ((to->file == NULL) && (node != NULL) && (node->doc != NULL)) {
  ------------------
  |  Branch (611:6): [True: 0, False: 0]
  |  Branch (611:28): [True: 0, False: 0]
  |  Branch (611:46): [True: 0, False: 0]
  ------------------
  612|      0|	    to->file = (char *) xmlStrdup(node->doc->URL);
  613|      0|	}
  614|      0|    }
  615|  1.28k|    to->line = line;
  616|  1.28k|    if (str1 != NULL)
  ------------------
  |  Branch (616:9): [True: 412, False: 868]
  ------------------
  617|    412|        to->str1 = (char *) xmlStrdup((const xmlChar *) str1);
  618|  1.28k|    if (str2 != NULL)
  ------------------
  |  Branch (618:9): [True: 119, False: 1.16k]
  ------------------
  619|    119|        to->str2 = (char *) xmlStrdup((const xmlChar *) str2);
  620|  1.28k|    if (str3 != NULL)
  ------------------
  |  Branch (620:9): [True: 0, False: 1.28k]
  ------------------
  621|      0|        to->str3 = (char *) xmlStrdup((const xmlChar *) str3);
  622|  1.28k|    to->int1 = int1;
  623|  1.28k|    to->int2 = col;
  624|  1.28k|    to->node = node;
  625|  1.28k|    to->ctxt = ctx;
  626|       |
  627|  1.28k|    if (to != &xmlLastError)
  ------------------
  |  |  874|  1.28k|  #define xmlLastError XML_GLOBAL_MACRO(xmlLastError)
  |  |  ------------------
  |  |  |  |  500|  1.28k|  #define XML_GLOBAL_MACRO(name) (*__##name())
  |  |  ------------------
  ------------------
  |  Branch (627:9): [True: 1.26k, False: 16]
  ------------------
  628|  1.26k|        xmlCopyError(to,&xmlLastError);
  ------------------
  |  |  874|  1.26k|  #define xmlLastError XML_GLOBAL_MACRO(xmlLastError)
  |  |  ------------------
  |  |  |  |  500|  1.26k|  #define XML_GLOBAL_MACRO(name) (*__##name())
  |  |  ------------------
  ------------------
  629|       |
  630|  1.28k|    if (schannel != NULL) {
  ------------------
  |  Branch (630:9): [True: 0, False: 1.28k]
  ------------------
  631|      0|	schannel(data, to);
  632|      0|	return;
  633|      0|    }
  634|       |
  635|       |    /*
  636|       |     * Find the callback channel if channel param is NULL
  637|       |     */
  638|  1.28k|    if ((ctxt != NULL) && (channel == NULL) &&
  ------------------
  |  Branch (638:9): [True: 1.26k, False: 16]
  |  Branch (638:27): [True: 1.25k, False: 6]
  ------------------
  639|  1.28k|        (xmlStructuredError == NULL) && (ctxt->sax != NULL)) {
  ------------------
  |  |  877|  1.25k|  #define xmlStructuredError XML_GLOBAL_MACRO(xmlStructuredError)
  |  |  ------------------
  |  |  |  |  500|  1.25k|  #define XML_GLOBAL_MACRO(name) (*__##name())
  |  |  ------------------
  ------------------
  |  Branch (639:9): [True: 1.25k, False: 0]
  |  Branch (639:41): [True: 1.25k, False: 0]
  ------------------
  640|  1.25k|        if (level == XML_ERR_WARNING)
  ------------------
  |  Branch (640:13): [True: 0, False: 1.25k]
  ------------------
  641|      0|	    channel = ctxt->sax->warning;
  642|  1.25k|        else
  643|  1.25k|	    channel = ctxt->sax->error;
  644|  1.25k|	data = ctxt->userData;
  645|  1.25k|    } else if (channel == NULL) {
  ------------------
  |  Branch (645:16): [True: 16, False: 6]
  ------------------
  646|     16|	channel = xmlGenericError;
  ------------------
  |  |  875|     16|  #define xmlGenericError XML_GLOBAL_MACRO(xmlGenericError)
  |  |  ------------------
  |  |  |  |  500|     16|  #define XML_GLOBAL_MACRO(name) (*__##name())
  |  |  ------------------
  ------------------
  647|     16|	if (ctxt != NULL) {
  ------------------
  |  Branch (647:6): [True: 0, False: 16]
  ------------------
  648|      0|	    data = ctxt;
  649|     16|	} else {
  650|     16|	    data = xmlGenericErrorContext;
  ------------------
  |  |  876|     16|  #define xmlGenericErrorContext XML_GLOBAL_MACRO(xmlGenericErrorContext)
  |  |  ------------------
  |  |  |  |  500|     16|  #define XML_GLOBAL_MACRO(name) (*__##name())
  |  |  ------------------
  ------------------
  651|     16|	}
  652|     16|    }
  653|  1.28k|    if (channel == NULL)
  ------------------
  |  Branch (653:9): [True: 23, False: 1.25k]
  ------------------
  654|     23|        return;
  655|       |
  656|  1.25k|    if ((channel == xmlParserError) ||
  ------------------
  |  Branch (656:9): [True: 1.23k, False: 22]
  ------------------
  657|  1.25k|        (channel == xmlParserWarning) ||
  ------------------
  |  Branch (657:9): [True: 0, False: 22]
  ------------------
  658|  1.25k|	(channel == xmlParserValidityError) ||
  ------------------
  |  Branch (658:2): [True: 6, False: 16]
  ------------------
  659|  1.25k|	(channel == xmlParserValidityWarning))
  ------------------
  |  Branch (659:2): [True: 0, False: 16]
  ------------------
  660|  1.24k|	xmlReportError(to, ctxt, str, NULL, NULL);
  661|     16|    else if (((void(*)(void)) channel == (void(*)(void)) fprintf) ||
  ------------------
  |  Branch (661:14): [True: 0, False: 16]
  ------------------
  662|     16|             (channel == xmlGenericErrorDefaultFunc))
  ------------------
  |  Branch (662:14): [True: 0, False: 16]
  ------------------
  663|      0|	xmlReportError(to, ctxt, str, channel, data);
  664|     16|    else
  665|     16|	channel(data, "%s", str);
  666|  1.25k|}
__xmlSimpleError:
  680|      6|{
  681|       |
  682|      6|    if (code == XML_ERR_NO_MEMORY) {
  ------------------
  |  Branch (682:9): [True: 6, False: 0]
  ------------------
  683|      6|	if (extra)
  ------------------
  |  Branch (683:6): [True: 6, False: 0]
  ------------------
  684|      6|	    __xmlRaiseError(NULL, NULL, NULL, NULL, node, domain,
  685|      6|			    XML_ERR_NO_MEMORY, XML_ERR_FATAL, NULL, 0, extra,
  686|      6|			    NULL, NULL, 0, 0,
  687|      6|			    "Memory allocation failed : %s\n", extra);
  688|      0|	else
  689|      0|	    __xmlRaiseError(NULL, NULL, NULL, NULL, node, domain,
  690|      0|			    XML_ERR_NO_MEMORY, XML_ERR_FATAL, NULL, 0, NULL,
  691|      0|			    NULL, NULL, 0, 0, "Memory allocation failed\n");
  692|      6|    } else {
  693|      0|	__xmlRaiseError(NULL, NULL, NULL, NULL, node, domain,
  694|      0|			code, XML_ERR_ERROR, NULL, 0, extra,
  695|      0|			NULL, NULL, 0, 0, msg, extra);
  696|      0|    }
  697|      6|}
xmlResetError:
  901|  1.34k|{
  902|  1.34k|    if (err == NULL)
  ------------------
  |  Branch (902:9): [True: 0, False: 1.34k]
  ------------------
  903|      0|        return;
  904|  1.34k|    if (err->code == XML_ERR_OK)
  ------------------
  |  Branch (904:9): [True: 119, False: 1.22k]
  ------------------
  905|    119|        return;
  906|  1.22k|    if (err->message != NULL)
  ------------------
  |  Branch (906:9): [True: 1.20k, False: 24]
  ------------------
  907|  1.20k|        xmlFree(err->message);
  908|  1.22k|    if (err->file != NULL)
  ------------------
  |  Branch (908:9): [True: 0, False: 1.22k]
  ------------------
  909|      0|        xmlFree(err->file);
  910|  1.22k|    if (err->str1 != NULL)
  ------------------
  |  Branch (910:9): [True: 358, False: 866]
  ------------------
  911|    358|        xmlFree(err->str1);
  912|  1.22k|    if (err->str2 != NULL)
  ------------------
  |  Branch (912:9): [True: 118, False: 1.10k]
  ------------------
  913|    118|        xmlFree(err->str2);
  914|  1.22k|    if (err->str3 != NULL)
  ------------------
  |  Branch (914:9): [True: 0, False: 1.22k]
  ------------------
  915|      0|        xmlFree(err->str3);
  916|  1.22k|    memset(err, 0, sizeof(xmlError));
  917|  1.22k|    err->code = XML_ERR_OK;
  918|  1.22k|}
xmlResetLastError:
  928|     99|{
  929|     99|    if (xmlLastError.code == XML_ERR_OK)
  ------------------
  |  |  874|     99|  #define xmlLastError XML_GLOBAL_MACRO(xmlLastError)
  |  |  ------------------
  |  |  |  |  500|     99|  #define XML_GLOBAL_MACRO(name) (*__##name())
  |  |  ------------------
  ------------------
  |  Branch (929:9): [True: 36, False: 63]
  ------------------
  930|     36|        return;
  931|     63|    xmlResetError(&xmlLastError);
  ------------------
  |  |  874|     63|  #define xmlLastError XML_GLOBAL_MACRO(xmlLastError)
  |  |  ------------------
  |  |  |  |  500|     63|  #define XML_GLOBAL_MACRO(name) (*__##name())
  |  |  ------------------
  ------------------
  932|     63|}
xmlCopyError:
  984|  1.26k|xmlCopyError(const xmlError *from, xmlErrorPtr to) {
  985|  1.26k|    char *message, *file, *str1, *str2, *str3;
  986|       |
  987|  1.26k|    if ((from == NULL) || (to == NULL))
  ------------------
  |  Branch (987:9): [True: 0, False: 1.26k]
  |  Branch (987:27): [True: 0, False: 1.26k]
  ------------------
  988|      0|        return(-1);
  989|       |
  990|  1.26k|    message = (char *) xmlStrdup((xmlChar *) from->message);
  991|  1.26k|    file = (char *) xmlStrdup ((xmlChar *) from->file);
  992|  1.26k|    str1 = (char *) xmlStrdup ((xmlChar *) from->str1);
  993|  1.26k|    str2 = (char *) xmlStrdup ((xmlChar *) from->str2);
  994|  1.26k|    str3 = (char *) xmlStrdup ((xmlChar *) from->str3);
  995|       |
  996|  1.26k|    if (to->message != NULL)
  ------------------
  |  Branch (996:9): [True: 1.19k, False: 67]
  ------------------
  997|  1.19k|        xmlFree(to->message);
  998|  1.26k|    if (to->file != NULL)
  ------------------
  |  Branch (998:9): [True: 0, False: 1.26k]
  ------------------
  999|      0|        xmlFree(to->file);
 1000|  1.26k|    if (to->str1 != NULL)
  ------------------
  |  Branch (1000:9): [True: 356, False: 908]
  ------------------
 1001|    356|        xmlFree(to->str1);
 1002|  1.26k|    if (to->str2 != NULL)
  ------------------
  |  Branch (1002:9): [True: 118, False: 1.14k]
  ------------------
 1003|    118|        xmlFree(to->str2);
 1004|  1.26k|    if (to->str3 != NULL)
  ------------------
  |  Branch (1004:9): [True: 0, False: 1.26k]
  ------------------
 1005|      0|        xmlFree(to->str3);
 1006|  1.26k|    to->domain = from->domain;
 1007|  1.26k|    to->code = from->code;
 1008|  1.26k|    to->level = from->level;
 1009|  1.26k|    to->line = from->line;
 1010|  1.26k|    to->node = from->node;
 1011|  1.26k|    to->int1 = from->int1;
 1012|  1.26k|    to->int2 = from->int2;
 1013|  1.26k|    to->node = from->node;
 1014|  1.26k|    to->ctxt = from->ctxt;
 1015|  1.26k|    to->message = message;
 1016|  1.26k|    to->file = file;
 1017|  1.26k|    to->str1 = str1;
 1018|  1.26k|    to->str2 = str2;
 1019|  1.26k|    to->str3 = str3;
 1020|       |
 1021|  1.26k|    return 0;
 1022|  1.26k|}
error.c:xmlParserPrintFileContextInternal:
  175|  1.24k|		xmlGenericErrorFunc channel, void *data ) {
  176|  1.24k|    const xmlChar *cur, *base, *start;
  177|  1.24k|    unsigned int n, col;	/* GCC warns if signed, because compared with sizeof() */
  178|  1.24k|    xmlChar  content[81]; /* space for 80 chars + line terminator */
  179|  1.24k|    xmlChar *ctnt;
  180|       |
  181|  1.24k|    if ((input == NULL) || (input->cur == NULL))
  ------------------
  |  Branch (181:9): [True: 0, False: 1.24k]
  |  Branch (181:28): [True: 0, False: 1.24k]
  ------------------
  182|      0|        return;
  183|       |
  184|  1.24k|    cur = input->cur;
  185|  1.24k|    base = input->base;
  186|       |    /* skip backwards over any end-of-lines */
  187|  1.40k|    while ((cur > base) && ((*(cur) == '\n') || (*(cur) == '\r'))) {
  ------------------
  |  Branch (187:12): [True: 1.39k, False: 8]
  |  Branch (187:29): [True: 134, False: 1.26k]
  |  Branch (187:49): [True: 30, False: 1.23k]
  ------------------
  188|    164|	cur--;
  189|    164|    }
  190|  1.24k|    n = 0;
  191|       |    /* search backwards for beginning-of-line (to max buff size) */
  192|  69.3k|    while ((n < sizeof(content) - 1) && (cur > base) &&
  ------------------
  |  Branch (192:12): [True: 68.7k, False: 599]
  |  Branch (192:41): [True: 68.7k, False: 47]
  ------------------
  193|  69.3k|	   (*cur != '\n') && (*cur != '\r')) {
  ------------------
  |  Branch (193:5): [True: 68.1k, False: 595]
  |  Branch (193:23): [True: 68.1k, False: 0]
  ------------------
  194|  68.1k|        cur--;
  195|  68.1k|        n++;
  196|  68.1k|    }
  197|  1.24k|    if ((n > 0) && ((*cur == '\n') || (*cur == '\r'))) {
  ------------------
  |  Branch (197:9): [True: 1.23k, False: 8]
  |  Branch (197:21): [True: 597, False: 636]
  |  Branch (197:39): [True: 0, False: 636]
  ------------------
  198|    597|        cur++;
  199|    644|    } else {
  200|       |        /* skip over continuation bytes */
  201|    646|        while ((cur < input->cur) && ((*cur & 0xC0) == 0x80))
  ------------------
  |  Branch (201:16): [True: 638, False: 8]
  |  Branch (201:38): [True: 2, False: 636]
  ------------------
  202|      2|            cur++;
  203|    644|    }
  204|       |    /* calculate the error position in terms of the current position */
  205|  1.24k|    col = input->cur - cur;
  206|       |    /* search forward for end-of-line (to max buff size) */
  207|  1.24k|    n = 0;
  208|  1.24k|    start = cur;
  209|       |    /* copy selected text to our buffer */
  210|  69.5k|    while ((*cur != 0) && (*(cur) != '\n') && (*(cur) != '\r')) {
  ------------------
  |  Branch (210:12): [True: 69.2k, False: 232]
  |  Branch (210:27): [True: 69.1k, False: 191]
  |  Branch (210:47): [True: 69.0k, False: 98]
  ------------------
  211|  69.0k|        int len = input->end - cur;
  212|  69.0k|        int c = xmlGetUTF8Char(cur, &len);
  213|       |
  214|  69.0k|        if ((c < 0) || (n + len > sizeof(content)-1))
  ------------------
  |  Branch (214:13): [True: 46, False: 68.9k]
  |  Branch (214:24): [True: 674, False: 68.2k]
  ------------------
  215|    720|            break;
  216|  68.2k|        cur += len;
  217|  68.2k|	n += len;
  218|  68.2k|    }
  219|  1.24k|    memcpy(content, start, n);
  220|  1.24k|    content[n] = 0;
  221|       |    /* print out the selected text */
  222|  1.24k|    channel(data ,"%s\n", content);
  223|       |    /* create blank line with problem pointer */
  224|  1.24k|    n = 0;
  225|  1.24k|    ctnt = content;
  226|       |    /* (leave buffer space for pointer + line terminator) */
  227|  62.1k|    while ((n<col) && (n++ < sizeof(content)-2) && (*ctnt != 0)) {
  ------------------
  |  Branch (227:12): [True: 61.6k, False: 516]
  |  Branch (227:23): [True: 61.1k, False: 552]
  |  Branch (227:52): [True: 60.9k, False: 173]
  ------------------
  228|  60.9k|	if (*(ctnt) != '\t')
  ------------------
  |  Branch (228:6): [True: 60.7k, False: 192]
  ------------------
  229|  60.7k|	    *(ctnt) = ' ';
  230|  60.9k|	ctnt++;
  231|  60.9k|    }
  232|  1.24k|    *ctnt++ = '^';
  233|  1.24k|    *ctnt = 0;
  234|  1.24k|    channel(data ,"%s\n", content);
  235|  1.24k|}
error.c:xmlReportError:
  261|  1.24k|{
  262|  1.24k|    char *file = NULL;
  263|  1.24k|    int line = 0;
  264|  1.24k|    int code = -1;
  265|  1.24k|    int domain;
  266|  1.24k|    const xmlChar *name = NULL;
  267|  1.24k|    xmlNodePtr node;
  268|  1.24k|    xmlErrorLevel level;
  269|  1.24k|    xmlParserInputPtr input = NULL;
  270|  1.24k|    xmlParserInputPtr cur = NULL;
  271|       |
  272|  1.24k|    if (err == NULL)
  ------------------
  |  Branch (272:9): [True: 0, False: 1.24k]
  ------------------
  273|      0|        return;
  274|       |
  275|  1.24k|    if (channel == NULL) {
  ------------------
  |  Branch (275:9): [True: 1.24k, False: 0]
  ------------------
  276|  1.24k|	channel = xmlGenericError;
  ------------------
  |  |  875|  1.24k|  #define xmlGenericError XML_GLOBAL_MACRO(xmlGenericError)
  |  |  ------------------
  |  |  |  |  500|  1.24k|  #define XML_GLOBAL_MACRO(name) (*__##name())
  |  |  ------------------
  ------------------
  277|  1.24k|	data = xmlGenericErrorContext;
  ------------------
  |  |  876|  1.24k|  #define xmlGenericErrorContext XML_GLOBAL_MACRO(xmlGenericErrorContext)
  |  |  ------------------
  |  |  |  |  500|  1.24k|  #define XML_GLOBAL_MACRO(name) (*__##name())
  |  |  ------------------
  ------------------
  278|  1.24k|    }
  279|  1.24k|    file = err->file;
  280|  1.24k|    line = err->line;
  281|  1.24k|    code = err->code;
  282|  1.24k|    domain = err->domain;
  283|  1.24k|    level = err->level;
  284|  1.24k|    node = err->node;
  285|       |
  286|  1.24k|    if (code == XML_ERR_OK)
  ------------------
  |  Branch (286:9): [True: 0, False: 1.24k]
  ------------------
  287|      0|        return;
  288|       |
  289|  1.24k|    if ((node != NULL) && (node->type == XML_ELEMENT_NODE))
  ------------------
  |  Branch (289:9): [True: 2, False: 1.23k]
  |  Branch (289:27): [True: 2, False: 0]
  ------------------
  290|      2|        name = node->name;
  291|       |
  292|       |    /*
  293|       |     * Maintain the compatibility with the legacy error handling
  294|       |     */
  295|  1.24k|    if (ctxt != NULL) {
  ------------------
  |  Branch (295:9): [True: 1.24k, False: 0]
  ------------------
  296|  1.24k|        input = ctxt->input;
  297|  1.24k|        if ((input != NULL) && (input->filename == NULL) &&
  ------------------
  |  Branch (297:13): [True: 1.24k, False: 0]
  |  Branch (297:32): [True: 1.24k, False: 0]
  ------------------
  298|  1.24k|            (ctxt->inputNr > 1)) {
  ------------------
  |  Branch (298:13): [True: 0, False: 1.24k]
  ------------------
  299|      0|            cur = input;
  300|      0|            input = ctxt->inputTab[ctxt->inputNr - 2];
  301|      0|        }
  302|  1.24k|        if (input != NULL) {
  ------------------
  |  Branch (302:13): [True: 1.24k, False: 0]
  ------------------
  303|  1.24k|            if (input->filename)
  ------------------
  |  Branch (303:17): [True: 0, False: 1.24k]
  ------------------
  304|      0|                channel(data, "%s:%d: ", input->filename, input->line);
  305|  1.24k|            else if ((line != 0) && (domain == XML_FROM_PARSER))
  ------------------
  |  Branch (305:22): [True: 1.24k, False: 0]
  |  Branch (305:37): [True: 21, False: 1.22k]
  ------------------
  306|     21|                channel(data, "Entity: line %d: ", input->line);
  307|  1.24k|        }
  308|  1.24k|    } else {
  309|      0|        if (file != NULL)
  ------------------
  |  Branch (309:13): [True: 0, False: 0]
  ------------------
  310|      0|            channel(data, "%s:%d: ", file, line);
  311|      0|        else if ((line != 0) &&
  ------------------
  |  Branch (311:18): [True: 0, False: 0]
  ------------------
  312|      0|	         ((domain == XML_FROM_PARSER) || (domain == XML_FROM_SCHEMASV)||
  ------------------
  |  Branch (312:12): [True: 0, False: 0]
  |  Branch (312:43): [True: 0, False: 0]
  ------------------
  313|      0|		  (domain == XML_FROM_SCHEMASP)||(domain == XML_FROM_DTD) ||
  ------------------
  |  Branch (313:5): [True: 0, False: 0]
  |  Branch (313:36): [True: 0, False: 0]
  ------------------
  314|      0|		  (domain == XML_FROM_RELAXNGP)||(domain == XML_FROM_RELAXNGV)))
  ------------------
  |  Branch (314:5): [True: 0, False: 0]
  |  Branch (314:36): [True: 0, False: 0]
  ------------------
  315|      0|            channel(data, "Entity: line %d: ", line);
  316|      0|    }
  317|  1.24k|    if (name != NULL) {
  ------------------
  |  Branch (317:9): [True: 2, False: 1.23k]
  ------------------
  318|      2|        channel(data, "element %s: ", name);
  319|      2|    }
  320|  1.24k|    switch (domain) {
  321|     21|        case XML_FROM_PARSER:
  ------------------
  |  Branch (321:9): [True: 21, False: 1.22k]
  ------------------
  322|     21|            channel(data, "parser ");
  323|     21|            break;
  324|      0|        case XML_FROM_NAMESPACE:
  ------------------
  |  Branch (324:9): [True: 0, False: 1.24k]
  ------------------
  325|      0|            channel(data, "namespace ");
  326|      0|            break;
  327|      0|        case XML_FROM_DTD:
  ------------------
  |  Branch (327:9): [True: 0, False: 1.24k]
  ------------------
  328|      2|        case XML_FROM_VALID:
  ------------------
  |  Branch (328:9): [True: 2, False: 1.23k]
  ------------------
  329|      2|            channel(data, "validity ");
  330|      2|            break;
  331|  1.21k|        case XML_FROM_HTML:
  ------------------
  |  Branch (331:9): [True: 1.21k, False: 23]
  ------------------
  332|  1.21k|            channel(data, "HTML parser ");
  333|  1.21k|            break;
  334|      0|        case XML_FROM_MEMORY:
  ------------------
  |  Branch (334:9): [True: 0, False: 1.24k]
  ------------------
  335|      0|            channel(data, "memory ");
  336|      0|            break;
  337|      0|        case XML_FROM_OUTPUT:
  ------------------
  |  Branch (337:9): [True: 0, False: 1.24k]
  ------------------
  338|      0|            channel(data, "output ");
  339|      0|            break;
  340|      0|        case XML_FROM_IO:
  ------------------
  |  Branch (340:9): [True: 0, False: 1.24k]
  ------------------
  341|      0|            channel(data, "I/O ");
  342|      0|            break;
  343|      0|        case XML_FROM_XINCLUDE:
  ------------------
  |  Branch (343:9): [True: 0, False: 1.24k]
  ------------------
  344|      0|            channel(data, "XInclude ");
  345|      0|            break;
  346|      0|        case XML_FROM_XPATH:
  ------------------
  |  Branch (346:9): [True: 0, False: 1.24k]
  ------------------
  347|      0|            channel(data, "XPath ");
  348|      0|            break;
  349|      0|        case XML_FROM_XPOINTER:
  ------------------
  |  Branch (349:9): [True: 0, False: 1.24k]
  ------------------
  350|      0|            channel(data, "parser ");
  351|      0|            break;
  352|      0|        case XML_FROM_REGEXP:
  ------------------
  |  Branch (352:9): [True: 0, False: 1.24k]
  ------------------
  353|      0|            channel(data, "regexp ");
  354|      0|            break;
  355|      0|        case XML_FROM_MODULE:
  ------------------
  |  Branch (355:9): [True: 0, False: 1.24k]
  ------------------
  356|      0|            channel(data, "module ");
  357|      0|            break;
  358|      0|        case XML_FROM_SCHEMASV:
  ------------------
  |  Branch (358:9): [True: 0, False: 1.24k]
  ------------------
  359|      0|            channel(data, "Schemas validity ");
  360|      0|            break;
  361|      0|        case XML_FROM_SCHEMASP:
  ------------------
  |  Branch (361:9): [True: 0, False: 1.24k]
  ------------------
  362|      0|            channel(data, "Schemas parser ");
  363|      0|            break;
  364|      0|        case XML_FROM_RELAXNGP:
  ------------------
  |  Branch (364:9): [True: 0, False: 1.24k]
  ------------------
  365|      0|            channel(data, "Relax-NG parser ");
  366|      0|            break;
  367|      0|        case XML_FROM_RELAXNGV:
  ------------------
  |  Branch (367:9): [True: 0, False: 1.24k]
  ------------------
  368|      0|            channel(data, "Relax-NG validity ");
  369|      0|            break;
  370|      0|        case XML_FROM_CATALOG:
  ------------------
  |  Branch (370:9): [True: 0, False: 1.24k]
  ------------------
  371|      0|            channel(data, "Catalog ");
  372|      0|            break;
  373|      0|        case XML_FROM_C14N:
  ------------------
  |  Branch (373:9): [True: 0, False: 1.24k]
  ------------------
  374|      0|            channel(data, "C14N ");
  375|      0|            break;
  376|      0|        case XML_FROM_XSLT:
  ------------------
  |  Branch (376:9): [True: 0, False: 1.24k]
  ------------------
  377|      0|            channel(data, "XSLT ");
  378|      0|            break;
  379|      0|        case XML_FROM_I18N:
  ------------------
  |  Branch (379:9): [True: 0, False: 1.24k]
  ------------------
  380|      0|            channel(data, "encoding ");
  381|      0|            break;
  382|      0|        case XML_FROM_SCHEMATRONV:
  ------------------
  |  Branch (382:9): [True: 0, False: 1.24k]
  ------------------
  383|      0|            channel(data, "schematron ");
  384|      0|            break;
  385|      0|        case XML_FROM_BUFFER:
  ------------------
  |  Branch (385:9): [True: 0, False: 1.24k]
  ------------------
  386|      0|            channel(data, "internal buffer ");
  387|      0|            break;
  388|      0|        case XML_FROM_URI:
  ------------------
  |  Branch (388:9): [True: 0, False: 1.24k]
  ------------------
  389|      0|            channel(data, "URI ");
  390|      0|            break;
  391|      0|        default:
  ------------------
  |  Branch (391:9): [True: 0, False: 1.24k]
  ------------------
  392|      0|            break;
  393|  1.24k|    }
  394|  1.24k|    switch (level) {
  ------------------
  |  Branch (394:13): [True: 0, False: 1.24k]
  ------------------
  395|      0|        case XML_ERR_NONE:
  ------------------
  |  Branch (395:9): [True: 0, False: 1.24k]
  ------------------
  396|      0|            channel(data, ": ");
  397|      0|            break;
  398|      0|        case XML_ERR_WARNING:
  ------------------
  |  Branch (398:9): [True: 0, False: 1.24k]
  ------------------
  399|      0|            channel(data, "warning : ");
  400|      0|            break;
  401|  1.22k|        case XML_ERR_ERROR:
  ------------------
  |  Branch (401:9): [True: 1.22k, False: 17]
  ------------------
  402|  1.22k|            channel(data, "error : ");
  403|  1.22k|            break;
  404|     17|        case XML_ERR_FATAL:
  ------------------
  |  Branch (404:9): [True: 17, False: 1.22k]
  ------------------
  405|     17|            channel(data, "error : ");
  406|     17|            break;
  407|  1.24k|    }
  408|  1.24k|    if (str != NULL) {
  ------------------
  |  Branch (408:9): [True: 1.23k, False: 6]
  ------------------
  409|  1.23k|        int len;
  410|  1.23k|	len = xmlStrlen((const xmlChar *)str);
  411|  1.23k|	if ((len > 0) && (str[len - 1] != '\n'))
  ------------------
  |  Branch (411:6): [True: 1.23k, False: 0]
  |  Branch (411:19): [True: 16, False: 1.21k]
  ------------------
  412|     16|	    channel(data, "%s\n", str);
  413|  1.21k|	else
  414|  1.21k|	    channel(data, "%s", str);
  415|  1.23k|    } else {
  416|      6|        channel(data, "%s\n", "out of memory error");
  417|      6|    }
  418|       |
  419|  1.24k|    if (ctxt != NULL) {
  ------------------
  |  Branch (419:9): [True: 1.24k, False: 0]
  ------------------
  420|  1.24k|        xmlParserPrintFileContextInternal(input, channel, data);
  421|  1.24k|        if (cur != NULL) {
  ------------------
  |  Branch (421:13): [True: 0, False: 1.24k]
  ------------------
  422|      0|            if (cur->filename)
  ------------------
  |  Branch (422:17): [True: 0, False: 0]
  ------------------
  423|      0|                channel(data, "%s:%d: \n", cur->filename, cur->line);
  424|      0|            else if ((line != 0) && (domain == XML_FROM_PARSER))
  ------------------
  |  Branch (424:22): [True: 0, False: 0]
  |  Branch (424:37): [True: 0, False: 0]
  ------------------
  425|      0|                channel(data, "Entity: line %d: \n", cur->line);
  426|      0|            xmlParserPrintFileContextInternal(cur, channel, data);
  427|      0|        }
  428|  1.24k|    }
  429|  1.24k|    if ((domain == XML_FROM_XPATH) && (err->str1 != NULL) &&
  ------------------
  |  Branch (429:9): [True: 0, False: 1.24k]
  |  Branch (429:39): [True: 0, False: 0]
  ------------------
  430|  1.24k|        (err->int1 < 100) &&
  ------------------
  |  Branch (430:9): [True: 0, False: 0]
  ------------------
  431|  1.24k|	(err->int1 < xmlStrlen((const xmlChar *)err->str1))) {
  ------------------
  |  Branch (431:2): [True: 0, False: 0]
  ------------------
  432|      0|	xmlChar buf[150];
  433|      0|	int i;
  434|       |
  435|      0|	channel(data, "%s\n", err->str1);
  436|      0|	for (i=0;i < err->int1;i++)
  ------------------
  |  Branch (436:11): [True: 0, False: 0]
  ------------------
  437|      0|	     buf[i] = ' ';
  438|      0|	buf[i++] = '^';
  439|      0|	buf[i] = 0;
  440|      0|	channel(data, "%s\n", buf);
  441|      0|    }
  442|  1.24k|}

xmlFuzzErrorFunc:
   56|  6.24k|                 ...) {
   57|  6.24k|}
xmlFuzzMemSetup:
  103|      2|xmlFuzzMemSetup(void) {
  104|      2|    xmlMemSetup(free, xmlFuzzMalloc, xmlFuzzRealloc, xmlMemStrdup);
  105|      2|}
xmlFuzzMemSetLimit:
  108|    297|xmlFuzzMemSetLimit(size_t limit) {
  109|    297|    fuzzNumAllocs = 0;
  110|    297|    fuzzMaxAllocs = limit ? limit + XML_FUZZ_MALLOC_OFFSET : 0;
  ------------------
  |  |   69|     20|#define XML_FUZZ_MALLOC_OFFSET  0
  ------------------
  |  Branch (110:21): [True: 20, False: 277]
  ------------------
  111|    297|    fuzzAllocFailed = 0;
  112|    297|}
xmlFuzzDataInit:
  125|     99|xmlFuzzDataInit(const char *data, size_t size) {
  126|     99|    fuzzData.data = data;
  127|     99|    fuzzData.size = size;
  128|     99|    fuzzData.ptr = data;
  129|     99|    fuzzData.remaining = size;
  130|       |
  131|     99|    fuzzData.outBuf = xmlMalloc(size + 1);
  132|     99|    fuzzData.outPtr = fuzzData.outBuf;
  133|       |
  134|     99|    fuzzData.entities = xmlHashCreate(8);
  135|     99|    fuzzData.mainUrl = NULL;
  136|     99|    fuzzData.mainEntity = NULL;
  137|     99|}
xmlFuzzDataCleanup:
  145|     99|xmlFuzzDataCleanup(void) {
  146|     99|    xmlFree(fuzzData.outBuf);
  147|     99|    xmlHashFree(fuzzData.entities, xmlHashDefaultDeallocator);
  148|     99|}
xmlFuzzReadInt:
  181|    198|xmlFuzzReadInt(int size) {
  182|    198|    size_t ret = 0;
  183|       |
  184|    990|    while ((size > 0) && (fuzzData.remaining > 0)) {
  ------------------
  |  Branch (184:12): [True: 792, False: 198]
  |  Branch (184:26): [True: 792, False: 0]
  ------------------
  185|    792|        unsigned char c = (unsigned char) *fuzzData.ptr++;
  186|    792|        fuzzData.remaining--;
  187|    792|        ret = (ret << 8) | c;
  188|    792|        size--;
  189|    792|    }
  190|       |
  191|    198|    return ret;
  192|    198|}
xmlFuzzReadRemaining:
  201|     99|xmlFuzzReadRemaining(size_t *size) {
  202|     99|    const char *ret = fuzzData.ptr;
  203|       |
  204|     99|    *size = fuzzData.remaining;
  205|     99|    fuzzData.ptr += fuzzData.remaining;
  206|     99|    fuzzData.remaining = 0;
  207|       |
  208|     99|    return(ret);
  209|     99|}
fuzz.c:xmlFuzzMalloc:
   73|   156k|xmlFuzzMalloc(size_t size) {
   74|   156k|    if (fuzzMaxAllocs > 0) {
  ------------------
  |  Branch (74:9): [True: 232, False: 156k]
  ------------------
   75|    232|        if (fuzzNumAllocs >= fuzzMaxAllocs - 1) {
  ------------------
  |  Branch (75:13): [True: 88, False: 144]
  ------------------
   76|       |#if XML_FUZZ_MALLOC_ABORT
   77|       |            abort();
   78|       |#endif
   79|     88|            fuzzAllocFailed = 1;
   80|     88|            return(NULL);
   81|     88|        }
   82|    144|        fuzzNumAllocs += 1;
   83|    144|    }
   84|   156k|    return malloc(size);
   85|   156k|}
fuzz.c:xmlFuzzRealloc:
   88|  12.9k|xmlFuzzRealloc(void *ptr, size_t size) {
   89|  12.9k|    if (fuzzMaxAllocs > 0) {
  ------------------
  |  Branch (89:9): [True: 17, False: 12.9k]
  ------------------
   90|     17|        if (fuzzNumAllocs >= fuzzMaxAllocs - 1) {
  ------------------
  |  Branch (90:13): [True: 1, False: 16]
  ------------------
   91|       |#if XML_FUZZ_MALLOC_ABORT
   92|       |            abort();
   93|       |#endif
   94|      1|            fuzzAllocFailed = 1;
   95|      1|            return(NULL);
   96|      1|        }
   97|     16|        fuzzNumAllocs += 1;
   98|     16|    }
   99|  12.9k|    return realloc(ptr, size);
  100|  12.9k|}

LLVMFuzzerInitialize:
   14|      2|                     char ***argv ATTRIBUTE_UNUSED) {
   15|      2|    xmlFuzzMemSetup();
   16|      2|    xmlInitParser();
   17|      2|#ifdef LIBXML_CATALOG_ENABLED
   18|      2|    xmlInitializeCatalog();
   19|      2|#endif
   20|      2|    xmlSetGenericErrorFunc(NULL, xmlFuzzErrorFunc);
   21|       |
   22|      2|    return 0;
   23|      2|}
LLVMFuzzerTestOneInput:
   26|     99|LLVMFuzzerTestOneInput(const char *data, size_t size) {
   27|     99|    htmlDocPtr doc;
   28|     99|    const char *docBuffer;
   29|     99|    size_t maxAlloc, docSize;
   30|     99|    int opts;
   31|       |
   32|     99|    xmlFuzzDataInit(data, size);
   33|     99|    opts = (int) xmlFuzzReadInt(4);
   34|     99|    maxAlloc = xmlFuzzReadInt(4) % (size + 1);
   35|       |
   36|     99|    docBuffer = xmlFuzzReadRemaining(&docSize);
   37|     99|    if (docBuffer == NULL) {
  ------------------
  |  Branch (37:9): [True: 0, False: 99]
  ------------------
   38|      0|        xmlFuzzDataCleanup();
   39|      0|        return(0);
   40|      0|    }
   41|       |
   42|       |    /* Pull parser */
   43|       |
   44|     99|    xmlFuzzMemSetLimit(maxAlloc);
   45|     99|    doc = htmlReadMemory(docBuffer, docSize, NULL, NULL, opts);
   46|       |
   47|     99|#ifdef LIBXML_OUTPUT_ENABLED
   48|     99|    {
   49|     99|        xmlOutputBufferPtr out;
   50|       |
   51|       |        /*
   52|       |         * Also test the serializer. Call htmlDocContentDumpOutput with our
   53|       |         * own buffer to avoid encoding the output. The HTML encoding is
   54|       |         * excruciatingly slow (see htmlEntityValueLookup).
   55|       |         */
   56|     99|        out = xmlAllocOutputBuffer(NULL);
   57|     99|        htmlDocContentDumpOutput(out, doc, NULL);
   58|     99|        xmlOutputBufferClose(out);
   59|     99|    }
   60|     99|#endif
   61|       |
   62|     99|    xmlFreeDoc(doc);
   63|       |
   64|       |    /* Push parser */
   65|       |
   66|     99|#ifdef LIBXML_PUSH_ENABLED
   67|     99|    {
   68|     99|        static const size_t maxChunkSize = 128;
   69|     99|        xmlParserCtxtPtr ctxt;
   70|     99|        size_t consumed, chunkSize;
   71|       |
   72|     99|        xmlFuzzMemSetLimit(maxAlloc);
   73|     99|        ctxt = htmlCreatePushParserCtxt(NULL, NULL, NULL, 0, NULL,
   74|     99|                                        XML_CHAR_ENCODING_NONE);
   75|       |
   76|     99|        if (ctxt != NULL) {
  ------------------
  |  Branch (76:13): [True: 92, False: 7]
  ------------------
   77|     92|            htmlCtxtUseOptions(ctxt, opts);
   78|       |
   79|  3.34k|            for (consumed = 0; consumed < docSize; consumed += chunkSize) {
  ------------------
  |  Branch (79:32): [True: 3.24k, False: 92]
  ------------------
   80|  3.24k|                chunkSize = docSize - consumed;
   81|  3.24k|                if (chunkSize > maxChunkSize)
  ------------------
  |  Branch (81:21): [True: 3.15k, False: 91]
  ------------------
   82|  3.15k|                    chunkSize = maxChunkSize;
   83|  3.24k|                htmlParseChunk(ctxt, docBuffer + consumed, chunkSize, 0);
   84|  3.24k|            }
   85|       |
   86|     92|            htmlParseChunk(ctxt, NULL, 0, 1);
   87|     92|            xmlFreeDoc(ctxt->myDoc);
   88|     92|            htmlFreeParserCtxt(ctxt);
   89|     92|        }
   90|     99|    }
   91|     99|#endif
   92|       |
   93|       |    /* Cleanup */
   94|       |
   95|     99|    xmlFuzzMemSetLimit(0);
   96|     99|    xmlFuzzDataCleanup();
   97|     99|    xmlResetLastError();
   98|       |
   99|     99|    return(0);
  100|     99|}

xmlInitGlobalsInternal:
  566|      2|void xmlInitGlobalsInternal(void) {
  567|      2|    xmlInitMutex(&xmlThrDefMutex);
  568|       |
  569|      2|#ifdef HAVE_POSIX_THREADS
  570|      2|#ifdef XML_PTHREAD_WEAK
  571|      2|    if (libxml_is_threaded == -1)
  ------------------
  |  Branch (571:9): [True: 2, False: 0]
  ------------------
  572|      2|        libxml_is_threaded =
  573|      2|            (pthread_getspecific != NULL) &&
  ------------------
  |  Branch (573:13): [True: 2, False: 0]
  ------------------
  574|      2|            (pthread_setspecific != NULL) &&
  ------------------
  |  Branch (574:13): [True: 2, False: 0]
  ------------------
  575|      2|            (pthread_key_create != NULL) &&
  ------------------
  |  Branch (575:13): [True: 2, False: 0]
  ------------------
  576|      2|            (pthread_key_delete != NULL) &&
  ------------------
  |  Branch (576:13): [True: 2, False: 0]
  ------------------
  577|       |            /*
  578|       |             * pthread_equal can be inline, resuting in -Waddress warnings.
  579|       |             * Let's assume it's available if all the other functions are.
  580|       |             */
  581|       |            /* (pthread_equal != NULL) && */
  582|      2|            (pthread_self != NULL);
  ------------------
  |  Branch (582:13): [True: 2, False: 0]
  ------------------
  583|      2|    if (libxml_is_threaded == 0)
  ------------------
  |  Branch (583:9): [True: 0, False: 2]
  ------------------
  584|      0|        return;
  585|      2|#endif /* XML_PTHREAD_WEAK */
  586|      2|    pthread_key_create(&globalkey, xmlFreeGlobalState);
  587|      2|    mainthread = pthread_self();
  588|       |#elif defined(HAVE_WIN32_THREADS)
  589|       |#ifndef USE_TLS
  590|       |    globalkey = TlsAlloc();
  591|       |#endif
  592|       |    mainthread = GetCurrentThreadId();
  593|       |#endif
  594|      2|}
__xmlLastError:
  892|  3.98k|    type *__##name(void) { \
  893|  3.98k|        if (IS_MAIN_THREAD) \
  ------------------
  |  |   62|  3.98k|#define IS_MAIN_THREAD (xmlIsMainThreadInternal())
  |  |  ------------------
  |  |  |  Branch (62:24): [True: 3.98k, False: 0]
  |  |  ------------------
  ------------------
  894|  3.98k|            return (&name); \
  895|  3.98k|        else \
  896|  3.98k|            return (&xmlGetThreadLocalStorage(0)->gs_##name); \
  897|  3.98k|    }
__xmlGenericError:
  892|  1.25k|    type *__##name(void) { \
  893|  1.25k|        if (IS_MAIN_THREAD) \
  ------------------
  |  |   62|  1.25k|#define IS_MAIN_THREAD (xmlIsMainThreadInternal())
  |  |  ------------------
  |  |  |  Branch (62:24): [True: 1.25k, False: 0]
  |  |  ------------------
  ------------------
  894|  1.25k|            return (&name); \
  895|  1.25k|        else \
  896|  1.25k|            return (&xmlGetThreadLocalStorage(0)->gs_##name); \
  897|  1.25k|    }
__xmlGenericErrorContext:
  892|  1.25k|    type *__##name(void) { \
  893|  1.25k|        if (IS_MAIN_THREAD) \
  ------------------
  |  |   62|  1.25k|#define IS_MAIN_THREAD (xmlIsMainThreadInternal())
  |  |  ------------------
  |  |  |  Branch (62:24): [True: 1.25k, False: 0]
  |  |  ------------------
  ------------------
  894|  1.25k|            return (&name); \
  895|  1.25k|        else \
  896|  1.25k|            return (&xmlGetThreadLocalStorage(0)->gs_##name); \
  897|  1.25k|    }
__xmlStructuredError:
  892|  2.53k|    type *__##name(void) { \
  893|  2.53k|        if (IS_MAIN_THREAD) \
  ------------------
  |  |   62|  2.53k|#define IS_MAIN_THREAD (xmlIsMainThreadInternal())
  |  |  ------------------
  |  |  |  Branch (62:24): [True: 2.53k, False: 0]
  |  |  ------------------
  ------------------
  894|  2.53k|            return (&name); \
  895|  2.53k|        else \
  896|  2.53k|            return (&xmlGetThreadLocalStorage(0)->gs_##name); \
  897|  2.53k|    }
__xmlDefaultSAXLocator:
  892|    182|    type *__##name(void) { \
  893|    182|        if (IS_MAIN_THREAD) \
  ------------------
  |  |   62|    182|#define IS_MAIN_THREAD (xmlIsMainThreadInternal())
  |  |  ------------------
  |  |  |  Branch (62:24): [True: 182, False: 0]
  |  |  ------------------
  ------------------
  894|    182|            return (&name); \
  895|    182|        else \
  896|    182|            return (&xmlGetThreadLocalStorage(0)->gs_##name); \
  897|    182|    }
__xmlGetWarningsDefaultValue:
  892|  1.28k|    type *__##name(void) { \
  893|  1.28k|        if (IS_MAIN_THREAD) \
  ------------------
  |  |   62|  1.28k|#define IS_MAIN_THREAD (xmlIsMainThreadInternal())
  |  |  ------------------
  |  |  |  Branch (62:24): [True: 1.28k, False: 0]
  |  |  ------------------
  ------------------
  894|  1.28k|            return (&name); \
  895|  1.28k|        else \
  896|  1.28k|            return (&xmlGetThreadLocalStorage(0)->gs_##name); \
  897|  1.28k|    }
__xmlKeepBlanksDefaultValue:
  892|    185|    type *__##name(void) { \
  893|    185|        if (IS_MAIN_THREAD) \
  ------------------
  |  |   62|    185|#define IS_MAIN_THREAD (xmlIsMainThreadInternal())
  |  |  ------------------
  |  |  |  Branch (62:24): [True: 185, False: 0]
  |  |  ------------------
  ------------------
  894|    185|            return (&name); \
  895|    185|        else \
  896|    185|            return (&xmlGetThreadLocalStorage(0)->gs_##name); \
  897|    185|    }
__xmlLineNumbersDefaultValue:
  892|    185|    type *__##name(void) { \
  893|    185|        if (IS_MAIN_THREAD) \
  ------------------
  |  |   62|    185|#define IS_MAIN_THREAD (xmlIsMainThreadInternal())
  |  |  ------------------
  |  |  |  Branch (62:24): [True: 185, False: 0]
  |  |  ------------------
  ------------------
  894|    185|            return (&name); \
  895|    185|        else \
  896|    185|            return (&xmlGetThreadLocalStorage(0)->gs_##name); \
  897|    185|    }
__xmlDefaultSAXHandler:
  892|    189|    type *__##name(void) { \
  893|    189|        if (IS_MAIN_THREAD) \
  ------------------
  |  |   62|    189|#define IS_MAIN_THREAD (xmlIsMainThreadInternal())
  |  |  ------------------
  |  |  |  Branch (62:24): [True: 189, False: 0]
  |  |  ------------------
  ------------------
  894|    189|            return (&name); \
  895|    189|        else \
  896|    189|            return (&xmlGetThreadLocalStorage(0)->gs_##name); \
  897|    189|    }
__xmlBufferAllocScheme:
  892|    332|    type *__##name(void) { \
  893|    332|        if (IS_MAIN_THREAD) \
  ------------------
  |  |   62|    332|#define IS_MAIN_THREAD (xmlIsMainThreadInternal())
  |  |  ------------------
  |  |  |  Branch (62:24): [True: 332, False: 0]
  |  |  ------------------
  ------------------
  894|    332|            return (&name); \
  895|    332|        else \
  896|    332|            return (&xmlGetThreadLocalStorage(0)->gs_##name); \
  897|    332|    }
__xmlDefaultBufferSize:
  892|    335|    type *__##name(void) { \
  893|    335|        if (IS_MAIN_THREAD) \
  ------------------
  |  |   62|    335|#define IS_MAIN_THREAD (xmlIsMainThreadInternal())
  |  |  ------------------
  |  |  |  Branch (62:24): [True: 335, False: 0]
  |  |  ------------------
  ------------------
  894|    335|            return (&name); \
  895|    335|        else \
  896|    335|            return (&xmlGetThreadLocalStorage(0)->gs_##name); \
  897|    335|    }
globals.c:xmlIsMainThreadInternal:
  660|  11.7k|xmlIsMainThreadInternal(void) {
  661|  11.7k|    if (parserInitialized == 0) {
  ------------------
  |  Branch (661:9): [True: 2, False: 11.7k]
  ------------------
  662|      2|        xmlInitParser();
  663|      2|        parserInitialized = 1;
  664|      2|    }
  665|       |
  666|  11.7k|#ifdef HAVE_POSIX_THREADS
  667|  11.7k|#ifdef XML_PTHREAD_WEAK
  668|  11.7k|    if (libxml_is_threaded == 0)
  ------------------
  |  Branch (668:9): [True: 0, False: 11.7k]
  ------------------
  669|      0|        return (1);
  670|  11.7k|#endif
  671|  11.7k|    return (pthread_equal(mainthread, pthread_self()));
  672|       |#elif defined HAVE_WIN32_THREADS
  673|       |    return (mainthread == GetCurrentThreadId());
  674|       |#else
  675|       |    return (1);
  676|       |#endif
  677|  11.7k|}

xmlHashCreate:
  160|    137|xmlHashCreate(int size) {
  161|    137|    xmlHashTablePtr hash;
  162|       |
  163|    137|    xmlInitParser();
  164|       |
  165|    137|    hash = xmlMalloc(sizeof(*hash));
  166|    137|    if (hash == NULL)
  ------------------
  |  Branch (166:9): [True: 0, False: 137]
  ------------------
  167|      0|        return(NULL);
  168|    137|    hash->dict = NULL;
  169|    137|    hash->size = 0;
  170|    137|    hash->table = NULL;
  171|    137|    hash->nbElems = 0;
  172|    137|    hash->randomSeed = xmlRandom();
  173|    137|#ifdef FUZZING_BUILD_MODE_UNSAFE_FOR_PRODUCTION
  174|    137|    hash->randomSeed = 0;
  175|    137|#endif
  176|       |
  177|       |    /*
  178|       |     * Unless a larger size is passed, the backing table is created
  179|       |     * lazily with MIN_HASH_SIZE capacity. In practice, there are many
  180|       |     * hash tables which are never filled.
  181|       |     */
  182|    137|    if (size > MIN_HASH_SIZE) {
  ------------------
  |  |   30|    137|#define MIN_HASH_SIZE 8
  ------------------
  |  Branch (182:9): [True: 0, False: 137]
  ------------------
  183|      0|        unsigned newSize = MIN_HASH_SIZE * 2;
  ------------------
  |  |   30|      0|#define MIN_HASH_SIZE 8
  ------------------
  184|       |
  185|      0|        while ((newSize < (unsigned) size) && (newSize < MAX_HASH_SIZE))
  ------------------
  |  |   31|      0|#define MAX_HASH_SIZE (1u << 31)
  ------------------
  |  Branch (185:16): [True: 0, False: 0]
  |  Branch (185:47): [True: 0, False: 0]
  ------------------
  186|      0|            newSize *= 2;
  187|       |
  188|      0|        if (xmlHashGrow(hash, newSize) != 0) {
  ------------------
  |  Branch (188:13): [True: 0, False: 0]
  ------------------
  189|      0|            xmlFree(hash);
  190|      0|            return(NULL);
  191|      0|        }
  192|      0|    }
  193|       |
  194|    137|    return(hash);
  195|    137|}
xmlHashCreateDict:
  209|     38|xmlHashCreateDict(int size, xmlDictPtr dict) {
  210|     38|    xmlHashTablePtr hash;
  211|       |
  212|     38|    hash = xmlHashCreate(size);
  213|     38|    if (hash != NULL) {
  ------------------
  |  Branch (213:9): [True: 38, False: 0]
  ------------------
  214|     38|        hash->dict = dict;
  215|     38|        xmlDictReference(dict);
  216|     38|    }
  217|     38|    return(hash);
  218|     38|}
xmlHashFree:
  229|    137|xmlHashFree(xmlHashTablePtr hash, xmlHashDeallocator dealloc) {
  230|    137|    if (hash == NULL)
  ------------------
  |  Branch (230:9): [True: 0, False: 137]
  ------------------
  231|      0|        return;
  232|       |
  233|    137|    if (hash->table) {
  ------------------
  |  Branch (233:9): [True: 38, False: 99]
  ------------------
  234|     38|        const xmlHashEntry *end = &hash->table[hash->size];
  235|     38|        const xmlHashEntry *entry;
  236|       |
  237|    518|        for (entry = hash->table; entry < end; entry++) {
  ------------------
  |  Branch (237:35): [True: 480, False: 38]
  ------------------
  238|    480|            if (entry->hashValue == 0)
  ------------------
  |  Branch (238:17): [True: 272, False: 208]
  ------------------
  239|    272|                continue;
  240|    208|            if ((dealloc != NULL) && (entry->payload != NULL))
  ------------------
  |  Branch (240:17): [True: 208, False: 0]
  |  Branch (240:38): [True: 208, False: 0]
  ------------------
  241|    208|                dealloc(entry->payload, entry->key);
  242|    208|            if (hash->dict == NULL) {
  ------------------
  |  Branch (242:17): [True: 208, False: 0]
  ------------------
  243|    208|                if (entry->key)
  ------------------
  |  Branch (243:21): [True: 208, False: 0]
  ------------------
  244|    208|                    xmlFree(entry->key);
  245|    208|                if (entry->key2)
  ------------------
  |  Branch (245:21): [True: 0, False: 208]
  ------------------
  246|      0|                    xmlFree(entry->key2);
  247|    208|                if (entry->key3)
  ------------------
  |  Branch (247:21): [True: 0, False: 208]
  ------------------
  248|      0|                    xmlFree(entry->key3);
  249|    208|            }
  250|    208|        }
  251|       |
  252|     38|        xmlFree(hash->table);
  253|     38|    }
  254|       |
  255|    137|    if (hash->dict)
  ------------------
  |  Branch (255:9): [True: 0, False: 137]
  ------------------
  256|      0|        xmlDictFree(hash->dict);
  257|       |
  258|    137|    xmlFree(hash);
  259|    137|}
xmlHashAddEntry:
  621|    210|xmlHashAddEntry(xmlHashTablePtr hash, const xmlChar *key, void *payload) {
  622|    210|    return(xmlHashUpdateInternal(hash, key, NULL, NULL, payload, NULL, 0));
  623|    210|}
hash.c:xmlHashGrow:
  354|     54|xmlHashGrow(xmlHashTablePtr hash, unsigned size) {
  355|     54|    const xmlHashEntry *oldentry, *oldend, *end;
  356|     54|    xmlHashEntry *table;
  357|     54|    unsigned oldsize, i;
  358|       |
  359|       |    /* Add 0 to avoid spurious -Wtype-limits warning on 64-bit GCC */
  360|     54|    if ((size_t) size + 0 > SIZE_MAX / sizeof(table[0]))
  ------------------
  |  |   25|     54|  #define SIZE_MAX ((size_t) -1)
  ------------------
  |  Branch (360:9): [True: 0, False: 54]
  ------------------
  361|      0|        return(-1);
  362|     54|    table = xmlMalloc(size * sizeof(table[0]));
  363|     54|    if (table == NULL)
  ------------------
  |  Branch (363:9): [True: 0, False: 54]
  ------------------
  364|      0|        return(-1);
  365|     54|    memset(table, 0, size * sizeof(table[0]));
  366|       |
  367|     54|    oldsize = hash->size;
  368|     54|    if (oldsize == 0)
  ------------------
  |  Branch (368:9): [True: 38, False: 16]
  ------------------
  369|     38|        goto done;
  370|       |
  371|     16|    oldend = &hash->table[oldsize];
  372|     16|    end = &table[size];
  373|       |
  374|       |    /*
  375|       |     * Robin Hood sorting order is maintained if we
  376|       |     *
  377|       |     * - compute hash indices with modulo
  378|       |     * - resize by an integer factor
  379|       |     * - start to copy from the beginning of a probe sequence
  380|       |     */
  381|     16|    oldentry = hash->table;
  382|     96|    while (oldentry->hashValue != 0) {
  ------------------
  |  Branch (382:12): [True: 80, False: 16]
  ------------------
  383|     80|        if (++oldentry >= oldend)
  ------------------
  |  Branch (383:13): [True: 0, False: 80]
  ------------------
  384|      0|            oldentry = hash->table;
  385|     80|    }
  386|       |
  387|    192|    for (i = 0; i < oldsize; i++) {
  ------------------
  |  Branch (387:17): [True: 176, False: 16]
  ------------------
  388|    176|        if (oldentry->hashValue != 0) {
  ------------------
  |  Branch (388:13): [True: 154, False: 22]
  ------------------
  389|    154|            xmlHashEntry *entry = &table[oldentry->hashValue & (size - 1)];
  390|       |
  391|    196|            while (entry->hashValue != 0) {
  ------------------
  |  Branch (391:20): [True: 42, False: 154]
  ------------------
  392|     42|                if (++entry >= end)
  ------------------
  |  Branch (392:21): [True: 0, False: 42]
  ------------------
  393|      0|                    entry = table;
  394|     42|            }
  395|    154|            *entry = *oldentry;
  396|    154|        }
  397|       |
  398|    176|        if (++oldentry >= oldend)
  ------------------
  |  Branch (398:13): [True: 16, False: 160]
  ------------------
  399|     16|            oldentry = hash->table;
  400|    176|    }
  401|       |
  402|     16|    xmlFree(hash->table);
  403|       |
  404|     54|done:
  405|     54|    hash->table = table;
  406|     54|    hash->size = size;
  407|       |
  408|     54|    return(0);
  409|     16|}
hash.c:xmlHashUpdateInternal:
  427|    210|                      void *payload, xmlHashDeallocator dealloc, int update) {
  428|    210|    xmlChar *copy, *copy2, *copy3;
  429|    210|    xmlHashEntry *entry = NULL;
  430|    210|    size_t lengths[3];
  431|    210|    unsigned hashValue;
  432|    210|    int found = 0;
  433|       |
  434|    210|    if ((hash == NULL) || (key == NULL))
  ------------------
  |  Branch (434:9): [True: 0, False: 210]
  |  Branch (434:27): [True: 0, False: 210]
  ------------------
  435|      0|        return(-1);
  436|       |
  437|       |    /*
  438|       |     * Check for an existing entry
  439|       |     */
  440|    210|    hashValue = xmlHashValue(hash->randomSeed, key, key2, key3, lengths);
  441|    210|    if (hash->size > 0)
  ------------------
  |  Branch (441:9): [True: 172, False: 38]
  ------------------
  442|    172|        entry = xmlHashFindEntry(hash, key, key2, key3, hashValue, &found);
  443|    210|    if (found) {
  ------------------
  |  Branch (443:9): [True: 2, False: 208]
  ------------------
  444|      2|        if (update) {
  ------------------
  |  Branch (444:13): [True: 0, False: 2]
  ------------------
  445|      0|            if (dealloc)
  ------------------
  |  Branch (445:17): [True: 0, False: 0]
  ------------------
  446|      0|                dealloc(entry->payload, entry->key);
  447|      0|            entry->payload = payload;
  448|      0|            return(0);
  449|      2|        } else {
  450|       |            /*
  451|       |             * xmlHashAddEntry found an existing entry.
  452|       |             *
  453|       |             * TODO: We should return a different error code here to
  454|       |             * distinguish from malloc failures.
  455|       |             */
  456|      2|            return(-1);
  457|      2|        }
  458|      2|    }
  459|       |
  460|       |    /*
  461|       |     * Grow the hash table if needed
  462|       |     */
  463|    208|    if (hash->nbElems + 1 > hash->size / MAX_FILL_DENOM * MAX_FILL_NUM) {
  ------------------
  |  |   29|    208|#define MAX_FILL_DENOM 8
  ------------------
                  if (hash->nbElems + 1 > hash->size / MAX_FILL_DENOM * MAX_FILL_NUM) {
  ------------------
  |  |   28|    208|#define MAX_FILL_NUM 7
  ------------------
  |  Branch (463:9): [True: 54, False: 154]
  ------------------
  464|     54|        unsigned newSize, mask, displ, pos;
  465|       |
  466|     54|        if (hash->size == 0) {
  ------------------
  |  Branch (466:13): [True: 38, False: 16]
  ------------------
  467|     38|            newSize = MIN_HASH_SIZE;
  ------------------
  |  |   30|     38|#define MIN_HASH_SIZE 8
  ------------------
  468|     38|        } else {
  469|       |            /* This guarantees that nbElems < INT_MAX */
  470|     16|            if (hash->size >= MAX_HASH_SIZE)
  ------------------
  |  |   31|     16|#define MAX_HASH_SIZE (1u << 31)
  ------------------
  |  Branch (470:17): [True: 0, False: 16]
  ------------------
  471|      0|                return(-1);
  472|     16|            newSize = hash->size * 2;
  473|     16|        }
  474|     54|        if (xmlHashGrow(hash, newSize) != 0)
  ------------------
  |  Branch (474:13): [True: 0, False: 54]
  ------------------
  475|      0|            return(-1);
  476|       |
  477|       |        /*
  478|       |         * Find new entry
  479|       |         */
  480|     54|        mask = hash->size - 1;
  481|     54|        displ = 0;
  482|     54|        pos = hashValue & mask;
  483|     54|        entry = &hash->table[pos];
  484|       |
  485|     54|        if (entry->hashValue != 0) {
  ------------------
  |  Branch (485:13): [True: 12, False: 42]
  ------------------
  486|     18|            do {
  487|     18|                displ++;
  488|     18|                pos++;
  489|     18|                entry++;
  490|     18|                if ((pos & mask) == 0)
  ------------------
  |  Branch (490:21): [True: 0, False: 18]
  ------------------
  491|      0|                    entry = hash->table;
  492|     18|            } while ((entry->hashValue != 0) &&
  ------------------
  |  Branch (492:22): [True: 12, False: 6]
  ------------------
  493|     18|                     ((pos - entry->hashValue) & mask) >= displ);
  ------------------
  |  Branch (493:22): [True: 6, False: 6]
  ------------------
  494|     12|        }
  495|     54|    }
  496|       |
  497|       |    /*
  498|       |     * Copy keys
  499|       |     */
  500|    208|    if (hash->dict != NULL) {
  ------------------
  |  Branch (500:9): [True: 0, False: 208]
  ------------------
  501|      0|        if (xmlDictOwns(hash->dict, key)) {
  ------------------
  |  Branch (501:13): [True: 0, False: 0]
  ------------------
  502|      0|            copy = (xmlChar *) key;
  503|      0|        } else {
  504|      0|            copy = (xmlChar *) xmlDictLookup(hash->dict, key, -1);
  505|      0|            if (copy == NULL)
  ------------------
  |  Branch (505:17): [True: 0, False: 0]
  ------------------
  506|      0|                return(-1);
  507|      0|        }
  508|       |
  509|      0|        if ((key2 == NULL) || (xmlDictOwns(hash->dict, key2))) {
  ------------------
  |  Branch (509:13): [True: 0, False: 0]
  |  Branch (509:31): [True: 0, False: 0]
  ------------------
  510|      0|            copy2 = (xmlChar *) key2;
  511|      0|        } else {
  512|      0|            copy2 = (xmlChar *) xmlDictLookup(hash->dict, key2, -1);
  513|      0|            if (copy2 == NULL)
  ------------------
  |  Branch (513:17): [True: 0, False: 0]
  ------------------
  514|      0|                return(-1);
  515|      0|        }
  516|      0|        if ((key3 == NULL) || (xmlDictOwns(hash->dict, key3))) {
  ------------------
  |  Branch (516:13): [True: 0, False: 0]
  |  Branch (516:31): [True: 0, False: 0]
  ------------------
  517|      0|            copy3 = (xmlChar *) key3;
  518|      0|        } else {
  519|      0|            copy3 = (xmlChar *) xmlDictLookup(hash->dict, key3, -1);
  520|      0|            if (copy3 == NULL)
  ------------------
  |  Branch (520:17): [True: 0, False: 0]
  ------------------
  521|      0|                return(-1);
  522|      0|        }
  523|    208|    } else {
  524|    208|        copy = xmlMalloc(lengths[0] + 1);
  525|    208|        if (copy == NULL)
  ------------------
  |  Branch (525:13): [True: 0, False: 208]
  ------------------
  526|      0|            return(-1);
  527|    208|        memcpy(copy, key, lengths[0] + 1);
  528|       |
  529|    208|        if (key2 != NULL) {
  ------------------
  |  Branch (529:13): [True: 0, False: 208]
  ------------------
  530|      0|            copy2 = xmlMalloc(lengths[1] + 1);
  531|      0|            if (copy2 == NULL) {
  ------------------
  |  Branch (531:17): [True: 0, False: 0]
  ------------------
  532|      0|                xmlFree(copy);
  533|      0|                return(-1);
  534|      0|            }
  535|      0|            memcpy(copy2, key2, lengths[1] + 1);
  536|    208|        } else {
  537|    208|            copy2 = NULL;
  538|    208|        }
  539|       |
  540|    208|        if (key3 != NULL) {
  ------------------
  |  Branch (540:13): [True: 0, False: 208]
  ------------------
  541|      0|            copy3 = xmlMalloc(lengths[2] + 1);
  542|      0|            if (copy3 == NULL) {
  ------------------
  |  Branch (542:17): [True: 0, False: 0]
  ------------------
  543|      0|                xmlFree(copy);
  544|      0|                xmlFree(copy2);
  545|      0|                return(-1);
  546|      0|            }
  547|      0|            memcpy(copy3, key3, lengths[2] + 1);
  548|    208|        } else {
  549|    208|            copy3 = NULL;
  550|    208|        }
  551|    208|    }
  552|       |
  553|       |    /*
  554|       |     * Shift the remainder of the probe sequence to the right
  555|       |     */
  556|    208|    if (entry->hashValue != 0) {
  ------------------
  |  Branch (556:9): [True: 36, False: 172]
  ------------------
  557|     36|        const xmlHashEntry *end = &hash->table[hash->size];
  558|     36|        const xmlHashEntry *cur = entry;
  559|       |
  560|     86|        do {
  561|     86|            cur++;
  562|     86|            if (cur >= end)
  ------------------
  |  Branch (562:17): [True: 16, False: 70]
  ------------------
  563|     16|                cur = hash->table;
  564|     86|        } while (cur->hashValue != 0);
  ------------------
  |  Branch (564:18): [True: 50, False: 36]
  ------------------
  565|       |
  566|     36|        if (cur < entry) {
  ------------------
  |  Branch (566:13): [True: 16, False: 20]
  ------------------
  567|       |            /*
  568|       |             * If we traversed the end of the buffer, handle the part
  569|       |             * at the start of the buffer.
  570|       |             */
  571|     16|            memmove(&hash->table[1], hash->table,
  572|     16|                    (char *) cur - (char *) hash->table);
  573|     16|            cur = end - 1;
  574|     16|            hash->table[0] = *cur;
  575|     16|        }
  576|       |
  577|     36|        memmove(&entry[1], entry, (char *) cur - (char *) entry);
  578|     36|    }
  579|       |
  580|       |    /*
  581|       |     * Populate entry
  582|       |     */
  583|    208|    entry->key = copy;
  584|    208|    entry->key2 = copy2;
  585|    208|    entry->key3 = copy3;
  586|    208|    entry->payload = payload;
  587|       |    /* OR with MAX_HASH_SIZE to make sure that the value is non-zero */
  588|    208|    entry->hashValue = hashValue | MAX_HASH_SIZE;
  ------------------
  |  |   31|    208|#define MAX_HASH_SIZE (1u << 31)
  ------------------
  589|       |
  590|    208|    hash->nbElems++;
  591|       |
  592|    208|    return(0);
  593|    208|}
hash.c:xmlHashValue:
   62|    210|             const xmlChar *key3, size_t *lengths) {
   63|    210|    unsigned h1, h2;
   64|    210|    size_t i;
   65|       |
   66|    210|    HASH_INIT(h1, h2, seed);
  ------------------
  |  |   23|    210|    do { \
  |  |   24|    210|        h1 = seed ^ 0x3b00; \
  |  |   25|    210|        h2 = HASH_ROL(seed, 15); \
  |  |  ------------------
  |  |  |  |   12|    210|#define HASH_ROL(x,n) ((x) << (n) | ((x) & 0xFFFFFFFF) >> (32 - (n)))
  |  |  ------------------
  |  |   26|    210|    } while (0)
  |  |  ------------------
  |  |  |  Branch (26:14): [Folded - Ignored]
  |  |  ------------------
  ------------------
   67|       |
   68|  3.76k|    for (i = 0; key[i] != 0; i++) {
  ------------------
  |  Branch (68:17): [True: 3.55k, False: 210]
  ------------------
   69|  3.55k|        HASH_UPDATE(h1, h2, key[i]);
  ------------------
  |  |   29|  3.55k|    do { \
  |  |   30|  3.55k|        h1 += ch; \
  |  |   31|  3.55k|        h1 += h1 << 3; \
  |  |   32|  3.55k|        h2 += h1; \
  |  |   33|  3.55k|        h2 = HASH_ROL(h2, 7); \
  |  |  ------------------
  |  |  |  |   12|  3.55k|#define HASH_ROL(x,n) ((x) << (n) | ((x) & 0xFFFFFFFF) >> (32 - (n)))
  |  |  ------------------
  |  |   34|  3.55k|        h2 += h2 << 2; \
  |  |   35|  3.55k|    } while (0)
  |  |  ------------------
  |  |  |  Branch (35:14): [Folded - Ignored]
  |  |  ------------------
  ------------------
   70|  3.55k|    }
   71|    210|    if (lengths)
  ------------------
  |  Branch (71:9): [True: 210, False: 0]
  ------------------
   72|    210|        lengths[0] = i;
   73|       |
   74|    210|    HASH_UPDATE(h1, h2, 0);
  ------------------
  |  |   29|    210|    do { \
  |  |   30|    210|        h1 += ch; \
  |  |   31|    210|        h1 += h1 << 3; \
  |  |   32|    210|        h2 += h1; \
  |  |   33|    210|        h2 = HASH_ROL(h2, 7); \
  |  |  ------------------
  |  |  |  |   12|    210|#define HASH_ROL(x,n) ((x) << (n) | ((x) & 0xFFFFFFFF) >> (32 - (n)))
  |  |  ------------------
  |  |   34|    210|        h2 += h2 << 2; \
  |  |   35|    210|    } while (0)
  |  |  ------------------
  |  |  |  Branch (35:14): [Folded - Ignored]
  |  |  ------------------
  ------------------
   75|       |
   76|    210|    if (key2 != NULL) {
  ------------------
  |  Branch (76:9): [True: 0, False: 210]
  ------------------
   77|      0|        for (i = 0; key2[i] != 0; i++) {
  ------------------
  |  Branch (77:21): [True: 0, False: 0]
  ------------------
   78|      0|            HASH_UPDATE(h1, h2, key2[i]);
  ------------------
  |  |   29|      0|    do { \
  |  |   30|      0|        h1 += ch; \
  |  |   31|      0|        h1 += h1 << 3; \
  |  |   32|      0|        h2 += h1; \
  |  |   33|      0|        h2 = HASH_ROL(h2, 7); \
  |  |  ------------------
  |  |  |  |   12|      0|#define HASH_ROL(x,n) ((x) << (n) | ((x) & 0xFFFFFFFF) >> (32 - (n)))
  |  |  ------------------
  |  |   34|      0|        h2 += h2 << 2; \
  |  |   35|      0|    } while (0)
  |  |  ------------------
  |  |  |  Branch (35:14): [Folded - Ignored]
  |  |  ------------------
  ------------------
   79|      0|        }
   80|      0|        if (lengths)
  ------------------
  |  Branch (80:13): [True: 0, False: 0]
  ------------------
   81|      0|            lengths[1] = i;
   82|      0|    }
   83|       |
   84|    210|    HASH_UPDATE(h1, h2, 0);
  ------------------
  |  |   29|    210|    do { \
  |  |   30|    210|        h1 += ch; \
  |  |   31|    210|        h1 += h1 << 3; \
  |  |   32|    210|        h2 += h1; \
  |  |   33|    210|        h2 = HASH_ROL(h2, 7); \
  |  |  ------------------
  |  |  |  |   12|    210|#define HASH_ROL(x,n) ((x) << (n) | ((x) & 0xFFFFFFFF) >> (32 - (n)))
  |  |  ------------------
  |  |   34|    210|        h2 += h2 << 2; \
  |  |   35|    210|    } while (0)
  |  |  ------------------
  |  |  |  Branch (35:14): [Folded - Ignored]
  |  |  ------------------
  ------------------
   85|       |
   86|    210|    if (key3 != NULL) {
  ------------------
  |  Branch (86:9): [True: 0, False: 210]
  ------------------
   87|      0|        for (i = 0; key3[i] != 0; i++) {
  ------------------
  |  Branch (87:21): [True: 0, False: 0]
  ------------------
   88|      0|            HASH_UPDATE(h1, h2, key3[i]);
  ------------------
  |  |   29|      0|    do { \
  |  |   30|      0|        h1 += ch; \
  |  |   31|      0|        h1 += h1 << 3; \
  |  |   32|      0|        h2 += h1; \
  |  |   33|      0|        h2 = HASH_ROL(h2, 7); \
  |  |  ------------------
  |  |  |  |   12|      0|#define HASH_ROL(x,n) ((x) << (n) | ((x) & 0xFFFFFFFF) >> (32 - (n)))
  |  |  ------------------
  |  |   34|      0|        h2 += h2 << 2; \
  |  |   35|      0|    } while (0)
  |  |  ------------------
  |  |  |  Branch (35:14): [Folded - Ignored]
  |  |  ------------------
  ------------------
   89|      0|        }
   90|      0|        if (lengths)
  ------------------
  |  Branch (90:13): [True: 0, False: 0]
  ------------------
   91|      0|            lengths[2] = i;
   92|      0|    }
   93|       |
   94|    210|    HASH_FINISH(h1, h2);
  ------------------
  |  |   39|    210|    do { \
  |  |   40|    210|        h1 ^= h2; \
  |  |   41|    210|        h1 += HASH_ROL(h2, 14); \
  |  |  ------------------
  |  |  |  |   12|    210|#define HASH_ROL(x,n) ((x) << (n) | ((x) & 0xFFFFFFFF) >> (32 - (n)))
  |  |  ------------------
  |  |   42|    210|        h2 ^= h1; h2 += HASH_ROR(h1, 6); \
  |  |  ------------------
  |  |  |  |   13|    210|#define HASH_ROR(x,n) (((x) & 0xFFFFFFFF) >> (n) | (x) << (32 - (n)))
  |  |  ------------------
  |  |   43|    210|        h1 ^= h2; h1 += HASH_ROL(h2, 5); \
  |  |  ------------------
  |  |  |  |   12|    210|#define HASH_ROL(x,n) ((x) << (n) | ((x) & 0xFFFFFFFF) >> (32 - (n)))
  |  |  ------------------
  |  |   44|    210|        h2 ^= h1; h2 += HASH_ROR(h1, 8); \
  |  |  ------------------
  |  |  |  |   13|    210|#define HASH_ROR(x,n) (((x) & 0xFFFFFFFF) >> (n) | (x) << (32 - (n)))
  |  |  ------------------
  |  |   45|    210|        h2 &= 0xFFFFFFFF; \
  |  |   46|    210|    } while (0)
  |  |  ------------------
  |  |  |  Branch (46:14): [Folded - Ignored]
  |  |  ------------------
  ------------------
   95|       |
   96|    210|    return(h2);
   97|    210|}
hash.c:xmlHashFindEntry:
  294|    172|                 unsigned hashValue, int *pfound) {
  295|    172|    xmlHashEntry *entry;
  296|    172|    unsigned mask, pos, displ;
  297|    172|    int found = 0;
  298|       |
  299|    172|    mask = hash->size - 1;
  300|    172|    pos = hashValue & mask;
  301|    172|    entry = &hash->table[pos];
  302|       |
  303|    172|    if (entry->hashValue != 0) {
  ------------------
  |  Branch (303:9): [True: 70, False: 102]
  ------------------
  304|       |        /*
  305|       |         * Robin hood hashing: abort if the displacement of the entry
  306|       |         * is smaller than the displacement of the key we look for.
  307|       |         * This also stops at the correct position when inserting.
  308|       |         */
  309|     70|        displ = 0;
  310|     70|        hashValue |= MAX_HASH_SIZE;
  ------------------
  |  |   31|     70|#define MAX_HASH_SIZE (1u << 31)
  ------------------
  311|       |
  312|     80|        do {
  313|     80|            if (entry->hashValue == hashValue) {
  ------------------
  |  Branch (313:17): [True: 2, False: 78]
  ------------------
  314|      2|                if (hash->dict) {
  ------------------
  |  Branch (314:21): [True: 0, False: 2]
  ------------------
  315|      0|                    if ((entry->key == key) &&
  ------------------
  |  Branch (315:25): [True: 0, False: 0]
  ------------------
  316|      0|                        (entry->key2 == key2) &&
  ------------------
  |  Branch (316:25): [True: 0, False: 0]
  ------------------
  317|      0|                        (entry->key3 == key3)) {
  ------------------
  |  Branch (317:25): [True: 0, False: 0]
  ------------------
  318|      0|                        found = 1;
  319|      0|                        break;
  320|      0|                    }
  321|      0|                }
  322|      2|                if ((strcmp((const char *) entry->key,
  ------------------
  |  Branch (322:21): [True: 2, False: 0]
  ------------------
  323|      2|                            (const char *) key) == 0) &&
  324|      2|                    (xmlFastStrEqual(entry->key2, key2)) &&
  ------------------
  |  Branch (324:21): [True: 2, False: 0]
  ------------------
  325|      2|                    (xmlFastStrEqual(entry->key3, key3))) {
  ------------------
  |  Branch (325:21): [True: 2, False: 0]
  ------------------
  326|      2|                    found = 1;
  327|      2|                    break;
  328|      2|                }
  329|      2|            }
  330|       |
  331|     78|            displ++;
  332|     78|            pos++;
  333|     78|            entry++;
  334|     78|            if ((pos & mask) == 0)
  ------------------
  |  Branch (334:17): [True: 0, False: 78]
  ------------------
  335|      0|                entry = hash->table;
  336|     78|        } while ((entry->hashValue != 0) &&
  ------------------
  |  Branch (336:18): [True: 54, False: 24]
  ------------------
  337|     78|                 (((pos - entry->hashValue) & mask) >= displ));
  ------------------
  |  Branch (337:18): [True: 10, False: 44]
  ------------------
  338|     70|    }
  339|       |
  340|      0|    *pfound = found;
  341|    172|    return(entry);
  342|    172|}
hash.c:xmlFastStrEqual:
  269|      4|xmlFastStrEqual(const xmlChar *s1, const xmlChar *s2) {
  270|      4|    if (s1 == NULL)
  ------------------
  |  Branch (270:9): [True: 4, False: 0]
  ------------------
  271|      4|        return(s2 == NULL);
  272|      0|    else
  273|      0|        return((s2 != NULL) &&
  ------------------
  |  Branch (273:16): [True: 0, False: 0]
  ------------------
  274|      0|               (strcmp((const char *) s1, (const char *) s2) == 0));
  ------------------
  |  Branch (274:16): [True: 0, False: 0]
  ------------------
  275|      4|}

inputPush:
 1893|    183|{
 1894|    183|    if ((ctxt == NULL) || (value == NULL))
  ------------------
  |  Branch (1894:9): [True: 0, False: 183]
  |  Branch (1894:27): [True: 0, False: 183]
  ------------------
 1895|      0|        return(-1);
 1896|    183|    if (ctxt->inputNr >= ctxt->inputMax) {
  ------------------
  |  Branch (1896:9): [True: 0, False: 183]
  ------------------
 1897|      0|        size_t newSize = ctxt->inputMax * 2;
 1898|      0|        xmlParserInputPtr *tmp;
 1899|       |
 1900|      0|        tmp = (xmlParserInputPtr *) xmlRealloc(ctxt->inputTab,
 1901|      0|                                               newSize * sizeof(*tmp));
 1902|      0|        if (tmp == NULL) {
  ------------------
  |  Branch (1902:13): [True: 0, False: 0]
  ------------------
 1903|      0|            xmlErrMemory(ctxt, NULL);
 1904|      0|            return (-1);
 1905|      0|        }
 1906|      0|        ctxt->inputTab = tmp;
 1907|      0|        ctxt->inputMax = newSize;
 1908|      0|    }
 1909|    183|    ctxt->inputTab[ctxt->inputNr] = value;
 1910|    183|    ctxt->input = value;
 1911|    183|    return (ctxt->inputNr++);
 1912|    183|}
inputPop:
 1923|    374|{
 1924|    374|    xmlParserInputPtr ret;
 1925|       |
 1926|    374|    if (ctxt == NULL)
  ------------------
  |  Branch (1926:9): [True: 0, False: 374]
  ------------------
 1927|      0|        return(NULL);
 1928|    374|    if (ctxt->inputNr <= 0)
  ------------------
  |  Branch (1928:9): [True: 191, False: 183]
  ------------------
 1929|    191|        return (NULL);
 1930|    183|    ctxt->inputNr--;
 1931|    183|    if (ctxt->inputNr > 0)
  ------------------
  |  Branch (1931:9): [True: 0, False: 183]
  ------------------
 1932|      0|        ctxt->input = ctxt->inputTab[ctxt->inputNr - 1];
 1933|    183|    else
 1934|    183|        ctxt->input = NULL;
 1935|    183|    ret = ctxt->inputTab[ctxt->inputNr];
 1936|    183|    ctxt->inputTab[ctxt->inputNr] = NULL;
 1937|    183|    return (ret);
 1938|    374|}
nodePush:
 1952|  13.2k|{
 1953|  13.2k|    if (ctxt == NULL) return(0);
  ------------------
  |  Branch (1953:9): [True: 0, False: 13.2k]
  ------------------
 1954|  13.2k|    if (ctxt->nodeNr >= ctxt->nodeMax) {
  ------------------
  |  Branch (1954:9): [True: 28, False: 13.2k]
  ------------------
 1955|     28|        xmlNodePtr *tmp;
 1956|       |
 1957|     28|	tmp = (xmlNodePtr *) xmlRealloc(ctxt->nodeTab,
 1958|     28|                                      ctxt->nodeMax * 2 *
 1959|     28|                                      sizeof(ctxt->nodeTab[0]));
 1960|     28|        if (tmp == NULL) {
  ------------------
  |  Branch (1960:13): [True: 0, False: 28]
  ------------------
 1961|      0|            xmlErrMemory(ctxt, NULL);
 1962|      0|            return (-1);
 1963|      0|        }
 1964|     28|        ctxt->nodeTab = tmp;
 1965|     28|	ctxt->nodeMax *= 2;
 1966|     28|    }
 1967|  13.2k|    if ((((unsigned int) ctxt->nodeNr) > xmlParserMaxDepth) &&
  ------------------
  |  Branch (1967:9): [True: 0, False: 13.2k]
  ------------------
 1968|  13.2k|        ((ctxt->options & XML_PARSE_HUGE) == 0)) {
  ------------------
  |  Branch (1968:9): [True: 0, False: 0]
  ------------------
 1969|      0|	xmlFatalErrMsgInt(ctxt, XML_ERR_INTERNAL_ERROR,
 1970|      0|		 "Excessive depth in document: %d use XML_PARSE_HUGE option\n",
 1971|      0|			  xmlParserMaxDepth);
 1972|      0|	xmlHaltParser(ctxt);
 1973|      0|	return(-1);
 1974|      0|    }
 1975|  13.2k|    ctxt->nodeTab[ctxt->nodeNr] = value;
 1976|  13.2k|    ctxt->node = value;
 1977|  13.2k|    return (ctxt->nodeNr++);
 1978|  13.2k|}
nodePop:
 1992|  13.2k|{
 1993|  13.2k|    xmlNodePtr ret;
 1994|       |
 1995|  13.2k|    if (ctxt == NULL) return(NULL);
  ------------------
  |  Branch (1995:9): [True: 0, False: 13.2k]
  ------------------
 1996|  13.2k|    if (ctxt->nodeNr <= 0)
  ------------------
  |  Branch (1996:9): [True: 3, False: 13.2k]
  ------------------
 1997|      3|        return (NULL);
 1998|  13.2k|    ctxt->nodeNr--;
 1999|  13.2k|    if (ctxt->nodeNr > 0)
  ------------------
  |  Branch (1999:9): [True: 13.0k, False: 169]
  ------------------
 2000|  13.0k|        ctxt->node = ctxt->nodeTab[ctxt->nodeNr - 1];
 2001|    169|    else
 2002|    169|        ctxt->node = NULL;
 2003|  13.2k|    ret = ctxt->nodeTab[ctxt->nodeNr];
 2004|  13.2k|    ctxt->nodeTab[ctxt->nodeNr] = NULL;
 2005|  13.2k|    return (ret);
 2006|  13.2k|}

__xmlErrEncoding:
  136|     12|{
  137|     12|    if ((ctxt != NULL) && (ctxt->disableSAX != 0) &&
  ------------------
  |  Branch (137:9): [True: 12, False: 0]
  |  Branch (137:27): [True: 0, False: 12]
  ------------------
  138|     12|        (ctxt->instate == XML_PARSER_EOF))
  ------------------
  |  Branch (138:9): [True: 0, False: 0]
  ------------------
  139|      0|	return;
  140|     12|    if (ctxt != NULL)
  ------------------
  |  Branch (140:9): [True: 12, False: 0]
  ------------------
  141|     12|        ctxt->errNo = xmlerr;
  142|     12|    __xmlRaiseError(NULL, NULL, NULL,
  143|     12|                    ctxt, NULL, XML_FROM_PARSER, xmlerr, XML_ERR_FATAL,
  144|     12|                    NULL, 0, (const char *) str1, (const char *) str2,
  145|     12|                    NULL, 0, 0, msg, str1, str2);
  146|     12|    if (ctxt != NULL) {
  ------------------
  |  Branch (146:9): [True: 12, False: 0]
  ------------------
  147|     12|        ctxt->wellFormed = 0;
  148|     12|        if (ctxt->recovery == 0)
  ------------------
  |  Branch (148:13): [True: 12, False: 0]
  ------------------
  149|     12|            ctxt->disableSAX = 1;
  150|     12|    }
  151|     12|}
xmlHaltParser:
  461|      1|xmlHaltParser(xmlParserCtxtPtr ctxt) {
  462|      1|    if (ctxt == NULL)
  ------------------
  |  Branch (462:9): [True: 0, False: 1]
  ------------------
  463|      0|        return;
  464|      1|    ctxt->instate = XML_PARSER_EOF;
  465|      1|    ctxt->disableSAX = 1;
  466|      1|    while (ctxt->inputNr > 1)
  ------------------
  |  Branch (466:12): [True: 0, False: 1]
  ------------------
  467|      0|        xmlFreeInputStream(inputPop(ctxt));
  468|      1|    if (ctxt->input != NULL) {
  ------------------
  |  Branch (468:9): [True: 1, False: 0]
  ------------------
  469|       |        /*
  470|       |	 * in case there was a specific allocation deallocate before
  471|       |	 * overriding base
  472|       |	 */
  473|      1|        if (ctxt->input->free != NULL) {
  ------------------
  |  Branch (473:13): [True: 0, False: 1]
  ------------------
  474|      0|	    ctxt->input->free((xmlChar *) ctxt->input->base);
  475|      0|	    ctxt->input->free = NULL;
  476|      0|	}
  477|      1|        if (ctxt->input->buf != NULL) {
  ------------------
  |  Branch (477:13): [True: 1, False: 0]
  ------------------
  478|      1|            xmlFreeParserInputBuffer(ctxt->input->buf);
  479|      1|            ctxt->input->buf = NULL;
  480|      1|        }
  481|      1|	ctxt->input->cur = BAD_CAST"";
  ------------------
  |  |   35|      1|#define BAD_CAST (xmlChar *)
  ------------------
  482|      1|        ctxt->input->length = 0;
  483|      1|	ctxt->input->base = ctxt->input->cur;
  484|      1|        ctxt->input->end = ctxt->input->cur;
  485|      1|    }
  486|      1|}
xmlParserGrow:
  511|   289k|xmlParserGrow(xmlParserCtxtPtr ctxt) {
  512|   289k|    xmlParserInputPtr in = ctxt->input;
  513|   289k|    xmlParserInputBufferPtr buf = in->buf;
  514|   289k|    ptrdiff_t curEnd = in->end - in->cur;
  515|   289k|    ptrdiff_t curBase = in->cur - in->base;
  516|   289k|    int ret;
  517|       |
  518|   289k|    if (buf == NULL)
  ------------------
  |  Branch (518:9): [True: 0, False: 289k]
  ------------------
  519|      0|        return(0);
  520|       |    /* Don't grow push parser buffer. */
  521|   289k|    if ((ctxt->progressive) && (ctxt->inputNr <= 1))
  ------------------
  |  Branch (521:9): [True: 274k, False: 14.9k]
  |  Branch (521:32): [True: 274k, False: 0]
  ------------------
  522|   274k|        return(0);
  523|  14.9k|    if (buf->error != 0)
  ------------------
  |  Branch (523:9): [True: 0, False: 14.9k]
  ------------------
  524|      0|        return(-1);
  525|       |
  526|  14.9k|    if (((curEnd > XML_MAX_LOOKUP_LIMIT) ||
  ------------------
  |  |   81|  14.9k|#define XML_MAX_LOOKUP_LIMIT 10000000
  ------------------
  |  Branch (526:10): [True: 0, False: 14.9k]
  ------------------
  527|  14.9k|         (curBase > XML_MAX_LOOKUP_LIMIT)) &&
  ------------------
  |  |   81|  14.9k|#define XML_MAX_LOOKUP_LIMIT 10000000
  ------------------
  |  Branch (527:10): [True: 0, False: 14.9k]
  ------------------
  528|  14.9k|        ((ctxt->options & XML_PARSE_HUGE) == 0)) {
  ------------------
  |  Branch (528:9): [True: 0, False: 0]
  ------------------
  529|      0|        xmlErrMemory(ctxt, "Huge input lookup");
  530|      0|        xmlHaltParser(ctxt);
  531|      0|	return(-1);
  532|      0|    }
  533|       |
  534|  14.9k|    if (curEnd >= INPUT_CHUNK)
  ------------------
  |  |   97|  14.9k|#define INPUT_CHUNK	250
  ------------------
  |  Branch (534:9): [True: 0, False: 14.9k]
  ------------------
  535|      0|        return(0);
  536|       |
  537|  14.9k|    ret = xmlParserInputBufferGrow(buf, INPUT_CHUNK);
  ------------------
  |  |   97|  14.9k|#define INPUT_CHUNK	250
  ------------------
  538|  14.9k|    xmlBufUpdateInput(buf->buffer, in, curBase);
  539|       |
  540|  14.9k|    if (ret < 0) {
  ------------------
  |  Branch (540:9): [True: 0, False: 14.9k]
  ------------------
  541|      0|        xmlFatalErr(ctxt, buf->error, NULL);
  542|       |        /* Buffer contents may be lost in case of memory errors. */
  543|      0|        if (buf->error == XML_ERR_NO_MEMORY)
  ------------------
  |  Branch (543:13): [True: 0, False: 0]
  ------------------
  544|      0|            xmlHaltParser(ctxt);
  545|      0|    }
  546|       |
  547|  14.9k|    return(ret);
  548|  14.9k|}
xmlParserShrink:
  600|    111|xmlParserShrink(xmlParserCtxtPtr ctxt) {
  601|    111|    xmlParserInputPtr in = ctxt->input;
  602|    111|    xmlParserInputBufferPtr buf = in->buf;
  603|    111|    size_t used;
  604|       |
  605|    111|    if (buf == NULL)
  ------------------
  |  Branch (605:9): [True: 0, False: 111]
  ------------------
  606|      0|        return;
  607|       |
  608|    111|    used = in->cur - in->base;
  609|       |    /*
  610|       |     * Do not shrink on large buffers whose only a tiny fraction
  611|       |     * was consumed
  612|       |     */
  613|    111|    if (used > INPUT_CHUNK) {
  ------------------
  |  |   97|    111|#define INPUT_CHUNK	250
  ------------------
  |  Branch (613:9): [True: 111, False: 0]
  ------------------
  614|    111|	size_t res = xmlBufShrink(buf->buffer, used - LINE_LEN);
  ------------------
  |  |  451|    111|#define LINE_LEN        80
  ------------------
  615|       |
  616|    111|	if (res > 0) {
  ------------------
  |  Branch (616:6): [True: 111, False: 0]
  ------------------
  617|    111|            used -= res;
  618|    111|            if ((res > ULONG_MAX) ||
  ------------------
  |  Branch (618:17): [True: 0, False: 111]
  ------------------
  619|    111|                (in->consumed > ULONG_MAX - (unsigned long)res))
  ------------------
  |  Branch (619:17): [True: 0, False: 111]
  ------------------
  620|      0|                in->consumed = ULONG_MAX;
  621|    111|            else
  622|    111|                in->consumed += res;
  623|    111|	}
  624|    111|    }
  625|       |
  626|    111|    xmlBufUpdateInput(buf->buffer, in, used);
  627|    111|}
xmlNextChar:
  698|   196k|{
  699|   196k|    const unsigned char *cur;
  700|   196k|    size_t avail;
  701|   196k|    int c;
  702|       |
  703|   196k|    if ((ctxt == NULL) || (ctxt->instate == XML_PARSER_EOF) ||
  ------------------
  |  Branch (703:9): [True: 0, False: 196k]
  |  Branch (703:27): [True: 0, False: 196k]
  ------------------
  704|   196k|        (ctxt->input == NULL))
  ------------------
  |  Branch (704:9): [True: 0, False: 196k]
  ------------------
  705|      0|        return;
  706|       |
  707|   196k|    avail = ctxt->input->end - ctxt->input->cur;
  708|       |
  709|   196k|    if (avail < INPUT_CHUNK) {
  ------------------
  |  |   97|   196k|#define INPUT_CHUNK	250
  ------------------
  |  Branch (709:9): [True: 94.8k, False: 102k]
  ------------------
  710|  94.8k|        xmlParserGrow(ctxt);
  711|  94.8k|        if ((ctxt->instate == XML_PARSER_EOF) ||
  ------------------
  |  Branch (711:13): [True: 0, False: 94.8k]
  ------------------
  712|  94.8k|            (ctxt->input->cur >= ctxt->input->end))
  ------------------
  |  Branch (712:13): [True: 0, False: 94.8k]
  ------------------
  713|      0|            return;
  714|  94.8k|        avail = ctxt->input->end - ctxt->input->cur;
  715|  94.8k|    }
  716|       |
  717|   196k|    cur = ctxt->input->cur;
  718|   196k|    c = *cur;
  719|       |
  720|   196k|    if (c < 0x80) {
  ------------------
  |  Branch (720:9): [True: 196k, False: 60]
  ------------------
  721|   196k|        if (c == '\n') {
  ------------------
  |  Branch (721:13): [True: 0, False: 196k]
  ------------------
  722|      0|            ctxt->input->cur++;
  723|      0|            ctxt->input->line++;
  724|      0|            ctxt->input->col = 1;
  725|   196k|        } else if (c == '\r') {
  ------------------
  |  Branch (725:20): [True: 6, False: 196k]
  ------------------
  726|       |            /*
  727|       |             *   2.11 End-of-Line Handling
  728|       |             *   the literal two-character sequence "#xD#xA" or a standalone
  729|       |             *   literal #xD, an XML processor must pass to the application
  730|       |             *   the single character #xA.
  731|       |             */
  732|      6|            ctxt->input->cur += ((cur[1] == '\n') ? 2 : 1);
  ------------------
  |  Branch (732:34): [True: 6, False: 0]
  ------------------
  733|      6|            ctxt->input->line++;
  734|      6|            ctxt->input->col = 1;
  735|      6|            return;
  736|   196k|        } else {
  737|   196k|            ctxt->input->cur++;
  738|   196k|            ctxt->input->col++;
  739|   196k|        }
  740|   196k|    } else {
  741|     60|        ctxt->input->col++;
  742|       |
  743|     60|        if ((avail < 2) || (cur[1] & 0xc0) != 0x80)
  ------------------
  |  Branch (743:13): [True: 0, False: 60]
  |  Branch (743:28): [True: 36, False: 24]
  ------------------
  744|     36|            goto encoding_error;
  745|       |
  746|     24|        if (c < 0xe0) {
  ------------------
  |  Branch (746:13): [True: 24, False: 0]
  ------------------
  747|       |            /* 2-byte code */
  748|     24|            if (c < 0xc2)
  ------------------
  |  Branch (748:17): [True: 16, False: 8]
  ------------------
  749|     16|                goto encoding_error;
  750|      8|            ctxt->input->cur += 2;
  751|      8|        } else {
  752|      0|            unsigned int val = (c << 8) | cur[1];
  753|       |
  754|      0|            if ((avail < 3) || (cur[2] & 0xc0) != 0x80)
  ------------------
  |  Branch (754:17): [True: 0, False: 0]
  |  Branch (754:32): [True: 0, False: 0]
  ------------------
  755|      0|                goto encoding_error;
  756|       |
  757|      0|            if (c < 0xf0) {
  ------------------
  |  Branch (757:17): [True: 0, False: 0]
  ------------------
  758|       |                /* 3-byte code */
  759|      0|                if ((val < 0xe0a0) || ((val >= 0xeda0) && (val < 0xee00)))
  ------------------
  |  Branch (759:21): [True: 0, False: 0]
  |  Branch (759:40): [True: 0, False: 0]
  |  Branch (759:59): [True: 0, False: 0]
  ------------------
  760|      0|                    goto encoding_error;
  761|      0|                ctxt->input->cur += 3;
  762|      0|            } else {
  763|      0|                if ((avail < 4) || ((cur[3] & 0xc0) != 0x80))
  ------------------
  |  Branch (763:21): [True: 0, False: 0]
  |  Branch (763:36): [True: 0, False: 0]
  ------------------
  764|      0|                    goto encoding_error;
  765|       |
  766|       |                /* 4-byte code */
  767|      0|                if ((val < 0xf090) || (val >= 0xf490))
  ------------------
  |  Branch (767:21): [True: 0, False: 0]
  |  Branch (767:39): [True: 0, False: 0]
  ------------------
  768|      0|                    goto encoding_error;
  769|      0|                ctxt->input->cur += 4;
  770|      0|            }
  771|      0|        }
  772|     24|    }
  773|       |
  774|   196k|    return;
  775|       |
  776|   196k|encoding_error:
  777|       |    /* Only report the first error */
  778|     52|    if ((ctxt->input->flags & XML_INPUT_ENCODING_ERROR) == 0) {
  ------------------
  |  |   27|     52|#define XML_INPUT_ENCODING_ERROR    (1u << 5)
  ------------------
  |  Branch (778:9): [True: 12, False: 40]
  ------------------
  779|     12|        if ((ctxt == NULL) || (ctxt->input == NULL) ||
  ------------------
  |  Branch (779:13): [True: 0, False: 12]
  |  Branch (779:31): [True: 0, False: 12]
  ------------------
  780|     12|            (ctxt->input->end - ctxt->input->cur < 4)) {
  ------------------
  |  Branch (780:13): [True: 0, False: 12]
  ------------------
  781|      0|            __xmlErrEncoding(ctxt, XML_ERR_INVALID_CHAR,
  782|      0|                         "Input is not proper UTF-8, indicate encoding !\n",
  783|      0|                         NULL, NULL);
  784|     12|        } else {
  785|     12|            char buffer[150];
  786|       |
  787|     12|            snprintf(buffer, 149, "Bytes: 0x%02X 0x%02X 0x%02X 0x%02X\n",
  788|     12|                            ctxt->input->cur[0], ctxt->input->cur[1],
  789|     12|                            ctxt->input->cur[2], ctxt->input->cur[3]);
  790|     12|            __xmlErrEncoding(ctxt, XML_ERR_INVALID_CHAR,
  791|     12|                         "Input is not proper UTF-8, indicate encoding !\n%s",
  792|     12|                         BAD_CAST buffer, NULL);
  ------------------
  |  |   35|     12|#define BAD_CAST (xmlChar *)
  ------------------
  793|     12|        }
  794|     12|        ctxt->input->flags |= XML_INPUT_ENCODING_ERROR;
  ------------------
  |  |   27|     12|#define XML_INPUT_ENCODING_ERROR    (1u << 5)
  ------------------
  795|     12|    }
  796|     52|    ctxt->input->cur++;
  797|     52|    return;
  798|   196k|}
xmlCopyCharMultiByte:
  995|  13.0k|xmlCopyCharMultiByte(xmlChar *out, int val) {
  996|  13.0k|    if ((out == NULL) || (val < 0)) return(0);
  ------------------
  |  Branch (996:9): [True: 0, False: 13.0k]
  |  Branch (996:26): [True: 0, False: 13.0k]
  ------------------
  997|       |    /*
  998|       |     * We are supposed to handle UTF8, check it's valid
  999|       |     * From rfc2044: encoding of the Unicode values on UTF-8:
 1000|       |     *
 1001|       |     * UCS-4 range (hex.)           UTF-8 octet sequence (binary)
 1002|       |     * 0000 0000-0000 007F   0xxxxxxx
 1003|       |     * 0000 0080-0000 07FF   110xxxxx 10xxxxxx
 1004|       |     * 0000 0800-0000 FFFF   1110xxxx 10xxxxxx 10xxxxxx
 1005|       |     */
 1006|  13.0k|    if  (val >= 0x80) {
  ------------------
  |  Branch (1006:10): [True: 13.0k, False: 0]
  ------------------
 1007|  13.0k|	xmlChar *savedout = out;
 1008|  13.0k|	int bits;
 1009|  13.0k|	if (val <   0x800) { *out++= (val >>  6) | 0xC0;  bits=  0; }
  ------------------
  |  Branch (1009:6): [True: 13.0k, False: 0]
  ------------------
 1010|      0|	else if (val < 0x10000) { *out++= (val >> 12) | 0xE0;  bits=  6;}
  ------------------
  |  Branch (1010:11): [True: 0, False: 0]
  ------------------
 1011|      0|	else if (val < 0x110000)  { *out++= (val >> 18) | 0xF0;  bits=  12; }
  ------------------
  |  Branch (1011:11): [True: 0, False: 0]
  ------------------
 1012|      0|	else {
 1013|      0|	    xmlErrEncodingInt(NULL, XML_ERR_INVALID_CHAR,
 1014|      0|		    "Internal error, xmlCopyCharMultiByte 0x%X out of bound\n",
 1015|      0|			      val);
 1016|      0|	    return(0);
 1017|      0|	}
 1018|  26.1k|	for ( ; bits >= 0; bits-= 6)
  ------------------
  |  Branch (1018:10): [True: 13.0k, False: 13.0k]
  ------------------
 1019|  13.0k|	    *out++= ((val >> bits) & 0x3F) | 0x80 ;
 1020|  13.0k|	return (out - savedout);
 1021|  13.0k|    }
 1022|      0|    *out = val;
 1023|      0|    return 1;
 1024|  13.0k|}
xmlCopyChar:
 1038|  13.0k|xmlCopyChar(int len ATTRIBUTE_UNUSED, xmlChar *out, int val) {
 1039|  13.0k|    if ((out == NULL) || (val < 0)) return(0);
  ------------------
  |  Branch (1039:9): [True: 0, False: 13.0k]
  |  Branch (1039:26): [True: 0, False: 13.0k]
  ------------------
 1040|       |    /* the len parameter is ignored */
 1041|  13.0k|    if  (val >= 0x80) {
  ------------------
  |  Branch (1041:10): [True: 13.0k, False: 0]
  ------------------
 1042|  13.0k|	return(xmlCopyCharMultiByte (out, val));
 1043|  13.0k|    }
 1044|      0|    *out = val;
 1045|      0|    return 1;
 1046|  13.0k|}
xmlSwitchEncoding:
 1128|     45|{
 1129|     45|    xmlCharEncodingHandlerPtr handler = NULL;
 1130|     45|    int check = 1;
 1131|     45|    int ret;
 1132|       |
 1133|     45|    if ((ctxt == NULL) || (ctxt->input == NULL))
  ------------------
  |  Branch (1133:9): [True: 0, False: 45]
  |  Branch (1133:27): [True: 0, False: 45]
  ------------------
 1134|      0|        return(-1);
 1135|       |
 1136|     45|    switch (enc) {
 1137|      0|	case XML_CHAR_ENCODING_NONE:
  ------------------
  |  Branch (1137:2): [True: 0, False: 45]
  ------------------
 1138|      0|	case XML_CHAR_ENCODING_UTF8:
  ------------------
  |  Branch (1138:2): [True: 0, False: 45]
  ------------------
 1139|      0|        case XML_CHAR_ENCODING_ASCII:
  ------------------
  |  Branch (1139:9): [True: 0, False: 45]
  ------------------
 1140|      0|            check = 0;
 1141|      0|            break;
 1142|      0|        case XML_CHAR_ENCODING_EBCDIC:
  ------------------
  |  Branch (1142:9): [True: 0, False: 45]
  ------------------
 1143|      0|            handler = xmlDetectEBCDIC(ctxt->input);
 1144|      0|            break;
 1145|     45|        default:
  ------------------
  |  Branch (1145:9): [True: 45, False: 0]
  ------------------
 1146|     45|            handler = xmlGetCharEncodingHandler(enc);
 1147|     45|            break;
 1148|     45|    }
 1149|       |
 1150|     45|    if ((check) && (handler == NULL)) {
  ------------------
  |  Branch (1150:9): [True: 45, False: 0]
  |  Branch (1150:20): [True: 0, False: 45]
  ------------------
 1151|      0|        const char *name = xmlGetCharEncodingName(enc);
 1152|       |
 1153|      0|        __xmlErrEncoding(ctxt, XML_ERR_UNSUPPORTED_ENCODING,
 1154|      0|                "encoding not supported: %s\n",
 1155|      0|                BAD_CAST (name ? name : "<null>"), NULL);
  ------------------
  |  |   35|      0|#define BAD_CAST (xmlChar *)
  ------------------
  |  Branch (1155:27): [True: 0, False: 0]
  ------------------
 1156|       |        /*
 1157|       |         * TODO: We could recover from errors in external entities
 1158|       |         * if we didn't stop the parser. But most callers of this
 1159|       |         * function don't check the return value.
 1160|       |         */
 1161|      0|        xmlStopParser(ctxt);
 1162|      0|        return(-1);
 1163|      0|    }
 1164|       |
 1165|     45|    ret = xmlSwitchInputEncoding(ctxt, ctxt->input, handler);
 1166|       |
 1167|     45|    if ((ret >= 0) && (enc == XML_CHAR_ENCODING_NONE)) {
  ------------------
  |  Branch (1167:9): [True: 44, False: 1]
  |  Branch (1167:23): [True: 0, False: 44]
  ------------------
 1168|      0|        ctxt->input->flags &= ~XML_INPUT_HAS_ENCODING;
  ------------------
  |  |   20|      0|#define XML_INPUT_HAS_ENCODING      (1u << 0)
  ------------------
 1169|      0|    }
 1170|       |
 1171|     45|    return(ret);
 1172|     45|}
xmlSwitchInputEncoding:
 1189|     61|{
 1190|     61|    int nbchars;
 1191|     61|    xmlParserInputBufferPtr in;
 1192|       |
 1193|     61|    if ((input == NULL) || (input->buf == NULL)) {
  ------------------
  |  Branch (1193:9): [True: 0, False: 61]
  |  Branch (1193:28): [True: 0, False: 61]
  ------------------
 1194|      0|        xmlCharEncCloseFunc(handler);
 1195|      0|	return (-1);
 1196|      0|    }
 1197|     61|    in = input->buf;
 1198|       |
 1199|     61|    input->flags |= XML_INPUT_HAS_ENCODING;
  ------------------
  |  |   20|     61|#define XML_INPUT_HAS_ENCODING      (1u << 0)
  ------------------
 1200|       |
 1201|       |    /*
 1202|       |     * UTF-8 requires no encoding handler.
 1203|       |     */
 1204|     61|    if ((handler != NULL) &&
  ------------------
  |  Branch (1204:9): [True: 61, False: 0]
  ------------------
 1205|     61|        (xmlStrcasecmp(BAD_CAST handler->name, BAD_CAST "UTF-8") == 0)) {
  ------------------
  |  |   35|     61|#define BAD_CAST (xmlChar *)
  ------------------
                      (xmlStrcasecmp(BAD_CAST handler->name, BAD_CAST "UTF-8") == 0)) {
  ------------------
  |  |   35|     61|#define BAD_CAST (xmlChar *)
  ------------------
  |  Branch (1205:9): [True: 4, False: 57]
  ------------------
 1206|      4|        xmlCharEncCloseFunc(handler);
 1207|      4|        handler = NULL;
 1208|      4|    }
 1209|       |
 1210|     61|    if (in->encoder == handler)
  ------------------
  |  Branch (1210:9): [True: 4, False: 57]
  ------------------
 1211|      4|        return (0);
 1212|       |
 1213|     57|    if (in->encoder != NULL) {
  ------------------
  |  Branch (1213:9): [True: 0, False: 57]
  ------------------
 1214|       |        /*
 1215|       |         * Switching encodings during parsing is a really bad idea,
 1216|       |         * but Chromium can switch between ISO-8859-1 and UTF-16 before
 1217|       |         * separate calls to xmlParseChunk.
 1218|       |         *
 1219|       |         * TODO: We should check whether the "raw" input buffer is empty and
 1220|       |         * convert the old content using the old encoder.
 1221|       |         */
 1222|       |
 1223|      0|        xmlCharEncCloseFunc(in->encoder);
 1224|      0|        in->encoder = handler;
 1225|      0|        return (0);
 1226|      0|    }
 1227|       |
 1228|     57|    in->encoder = handler;
 1229|       |
 1230|       |    /*
 1231|       |     * Is there already some content down the pipe to convert ?
 1232|       |     */
 1233|     57|    if (xmlBufIsEmpty(in->buffer) == 0) {
  ------------------
  |  Branch (1233:9): [True: 57, False: 0]
  ------------------
 1234|     57|        size_t processed;
 1235|       |
 1236|       |        /*
 1237|       |         * Shrink the current input buffer.
 1238|       |         * Move it as the raw buffer and create a new input buffer
 1239|       |         */
 1240|     57|        processed = input->cur - input->base;
 1241|     57|        xmlBufShrink(in->buffer, processed);
 1242|     57|        input->consumed += processed;
 1243|     57|        in->raw = in->buffer;
 1244|     57|        in->buffer = xmlBufCreate();
 1245|     57|        in->rawconsumed = processed;
 1246|       |
 1247|     57|        nbchars = xmlCharEncInput(in);
 1248|     57|        xmlBufResetInput(in->buffer, input);
 1249|     57|        if (nbchars < 0) {
  ------------------
  |  Branch (1249:13): [True: 1, False: 56]
  ------------------
 1250|       |            /* TODO: This could be an out of memory or an encoding error. */
 1251|      1|            xmlErrInternal(ctxt,
 1252|      1|                           "switching encoding: encoder error\n",
 1253|      1|                           NULL);
 1254|      1|            xmlHaltParser(ctxt);
 1255|      1|            return (-1);
 1256|      1|        }
 1257|     57|    }
 1258|     56|    return (0);
 1259|     57|}
xmlSwitchToEncoding:
 1275|     16|{
 1276|     16|    if (ctxt == NULL)
  ------------------
  |  Branch (1276:9): [True: 0, False: 16]
  ------------------
 1277|      0|        return(-1);
 1278|     16|    return(xmlSwitchInputEncoding(ctxt, ctxt->input, handler));
 1279|     16|}
xmlDetectEncoding:
 1290|     91|xmlDetectEncoding(xmlParserCtxtPtr ctxt) {
 1291|     91|    const xmlChar *in;
 1292|     91|    xmlCharEncoding enc;
 1293|     91|    int bomSize;
 1294|     91|    int autoFlag = 0;
 1295|       |
 1296|     91|    if (xmlParserGrow(ctxt) < 0)
  ------------------
  |  Branch (1296:9): [True: 0, False: 91]
  ------------------
 1297|      0|        return;
 1298|     91|    in = ctxt->input->cur;
 1299|     91|    if (ctxt->input->end - in < 4)
  ------------------
  |  Branch (1299:9): [True: 3, False: 88]
  ------------------
 1300|      3|        return;
 1301|       |
 1302|     88|    if (ctxt->input->flags & XML_INPUT_HAS_ENCODING) {
  ------------------
  |  |   20|     88|#define XML_INPUT_HAS_ENCODING      (1u << 0)
  ------------------
  |  Branch (1302:9): [True: 0, False: 88]
  ------------------
 1303|       |        /*
 1304|       |         * If the encoding was already set, only skip the BOM which was
 1305|       |         * possibly decoded to UTF-8.
 1306|       |         */
 1307|      0|        if ((in[0] == 0xEF) && (in[1] == 0xBB) && (in[2] == 0xBF)) {
  ------------------
  |  Branch (1307:13): [True: 0, False: 0]
  |  Branch (1307:32): [True: 0, False: 0]
  |  Branch (1307:51): [True: 0, False: 0]
  ------------------
 1308|      0|            ctxt->input->cur += 3;
 1309|      0|        }
 1310|       |
 1311|      0|        return;
 1312|      0|    }
 1313|       |
 1314|     88|    enc = XML_CHAR_ENCODING_NONE;
 1315|     88|    bomSize = 0;
 1316|       |
 1317|     88|    switch (in[0]) {
  ------------------
  |  Branch (1317:13): [True: 4, False: 84]
  ------------------
 1318|      3|        case 0x00:
  ------------------
  |  Branch (1318:9): [True: 3, False: 85]
  ------------------
 1319|      3|            if ((in[1] == 0x00) && (in[2] == 0x00) && (in[3] == 0x3C)) {
  ------------------
  |  Branch (1319:17): [True: 2, False: 1]
  |  Branch (1319:36): [True: 1, False: 1]
  |  Branch (1319:55): [True: 0, False: 1]
  ------------------
 1320|      0|                enc = XML_CHAR_ENCODING_UCS4BE;
 1321|      0|                autoFlag = XML_INPUT_AUTO_OTHER;
  ------------------
  |  |   25|      0|#define XML_INPUT_AUTO_OTHER        (4u << 1)
  ------------------
 1322|      3|            } else if ((in[1] == 0x3C) && (in[2] == 0x00) && (in[3] == 0x3F)) {
  ------------------
  |  Branch (1322:24): [True: 0, False: 3]
  |  Branch (1322:43): [True: 0, False: 0]
  |  Branch (1322:62): [True: 0, False: 0]
  ------------------
 1323|      0|                enc = XML_CHAR_ENCODING_UTF16BE;
 1324|      0|                autoFlag = XML_INPUT_AUTO_UTF16BE;
  ------------------
  |  |   24|      0|#define XML_INPUT_AUTO_UTF16BE      (3u << 1)
  ------------------
 1325|      0|            }
 1326|      3|            break;
 1327|       |
 1328|     81|        case 0x3C:
  ------------------
  |  Branch (1328:9): [True: 81, False: 7]
  ------------------
 1329|     81|            if (in[1] == 0x00) {
  ------------------
  |  Branch (1329:17): [True: 0, False: 81]
  ------------------
 1330|      0|                if ((in[2] == 0x00) && (in[3] == 0x00)) {
  ------------------
  |  Branch (1330:21): [True: 0, False: 0]
  |  Branch (1330:40): [True: 0, False: 0]
  ------------------
 1331|      0|                    enc = XML_CHAR_ENCODING_UCS4LE;
 1332|      0|                    autoFlag = XML_INPUT_AUTO_OTHER;
  ------------------
  |  |   25|      0|#define XML_INPUT_AUTO_OTHER        (4u << 1)
  ------------------
 1333|      0|                } else if ((in[2] == 0x3F) && (in[3] == 0x00)) {
  ------------------
  |  Branch (1333:28): [True: 0, False: 0]
  |  Branch (1333:47): [True: 0, False: 0]
  ------------------
 1334|      0|                    enc = XML_CHAR_ENCODING_UTF16LE;
 1335|      0|                    autoFlag = XML_INPUT_AUTO_UTF16LE;
  ------------------
  |  |   23|      0|#define XML_INPUT_AUTO_UTF16LE      (2u << 1)
  ------------------
 1336|      0|                }
 1337|      0|            }
 1338|     81|            break;
 1339|       |
 1340|      0|        case 0x4C:
  ------------------
  |  Branch (1340:9): [True: 0, False: 88]
  ------------------
 1341|      0|	    if ((in[1] == 0x6F) && (in[2] == 0xA7) && (in[3] == 0x94)) {
  ------------------
  |  Branch (1341:10): [True: 0, False: 0]
  |  Branch (1341:29): [True: 0, False: 0]
  |  Branch (1341:48): [True: 0, False: 0]
  ------------------
 1342|      0|	        enc = XML_CHAR_ENCODING_EBCDIC;
 1343|      0|                autoFlag = XML_INPUT_AUTO_OTHER;
  ------------------
  |  |   25|      0|#define XML_INPUT_AUTO_OTHER        (4u << 1)
  ------------------
 1344|      0|            }
 1345|      0|            break;
 1346|       |
 1347|      0|        case 0xEF:
  ------------------
  |  Branch (1347:9): [True: 0, False: 88]
  ------------------
 1348|      0|            if ((in[1] == 0xBB) && (in[2] == 0xBF)) {
  ------------------
  |  Branch (1348:17): [True: 0, False: 0]
  |  Branch (1348:36): [True: 0, False: 0]
  ------------------
 1349|      0|                enc = XML_CHAR_ENCODING_UTF8;
 1350|      0|                autoFlag = XML_INPUT_AUTO_UTF8;
  ------------------
  |  |   22|      0|#define XML_INPUT_AUTO_UTF8         (1u << 1)
  ------------------
 1351|      0|                bomSize = 3;
 1352|      0|            }
 1353|      0|            break;
 1354|       |
 1355|      0|        case 0xFE:
  ------------------
  |  Branch (1355:9): [True: 0, False: 88]
  ------------------
 1356|      0|            if (in[1] == 0xFF) {
  ------------------
  |  Branch (1356:17): [True: 0, False: 0]
  ------------------
 1357|      0|                enc = XML_CHAR_ENCODING_UTF16BE;
 1358|      0|                autoFlag = XML_INPUT_AUTO_UTF16BE;
  ------------------
  |  |   24|      0|#define XML_INPUT_AUTO_UTF16BE      (3u << 1)
  ------------------
 1359|      0|                bomSize = 2;
 1360|      0|            }
 1361|      0|            break;
 1362|       |
 1363|      0|        case 0xFF:
  ------------------
  |  Branch (1363:9): [True: 0, False: 88]
  ------------------
 1364|      0|            if (in[1] == 0xFE) {
  ------------------
  |  Branch (1364:17): [True: 0, False: 0]
  ------------------
 1365|      0|                enc = XML_CHAR_ENCODING_UTF16LE;
 1366|      0|                autoFlag = XML_INPUT_AUTO_UTF16LE;
  ------------------
  |  |   23|      0|#define XML_INPUT_AUTO_UTF16LE      (2u << 1)
  ------------------
 1367|      0|                bomSize = 2;
 1368|      0|            }
 1369|      0|            break;
 1370|     88|    }
 1371|       |
 1372|     88|    if (bomSize > 0) {
  ------------------
  |  Branch (1372:9): [True: 0, False: 88]
  ------------------
 1373|      0|        ctxt->input->cur += bomSize;
 1374|      0|    }
 1375|       |
 1376|     88|    if (enc != XML_CHAR_ENCODING_NONE) {
  ------------------
  |  Branch (1376:9): [True: 0, False: 88]
  ------------------
 1377|      0|        ctxt->input->flags |= autoFlag;
 1378|      0|        xmlSwitchEncoding(ctxt, enc);
 1379|      0|    }
 1380|     88|}
xmlSetDeclaredEncoding:
 1395|     16|xmlSetDeclaredEncoding(xmlParserCtxtPtr ctxt, xmlChar *encoding) {
 1396|     16|    if (ctxt->encoding != NULL)
  ------------------
  |  Branch (1396:9): [True: 0, False: 16]
  ------------------
 1397|      0|        xmlFree((xmlChar *) ctxt->encoding);
 1398|     16|    ctxt->encoding = encoding;
 1399|       |
 1400|     16|    if (((ctxt->input->flags & XML_INPUT_HAS_ENCODING) == 0) &&
  ------------------
  |  |   20|     16|#define XML_INPUT_HAS_ENCODING      (1u << 0)
  ------------------
  |  Branch (1400:9): [True: 16, False: 0]
  ------------------
 1401|     16|        ((ctxt->options & XML_PARSE_IGNORE_ENC) == 0)) {
  ------------------
  |  Branch (1401:9): [True: 16, False: 0]
  ------------------
 1402|     16|        xmlCharEncodingHandlerPtr handler;
 1403|       |
 1404|     16|        handler = xmlFindCharEncodingHandler((const char *) encoding);
 1405|     16|        if (handler == NULL) {
  ------------------
  |  Branch (1405:13): [True: 0, False: 16]
  ------------------
 1406|      0|            __xmlErrEncoding(ctxt, XML_ERR_UNSUPPORTED_ENCODING,
 1407|      0|                             "Unsupported encoding: %s\n",
 1408|      0|                             encoding, NULL);
 1409|      0|            return;
 1410|      0|        }
 1411|       |
 1412|     16|        xmlSwitchToEncoding(ctxt, handler);
 1413|     16|        ctxt->input->flags |= XML_INPUT_USES_ENC_DECL;
  ------------------
  |  |   26|     16|#define XML_INPUT_USES_ENC_DECL     (1u << 4)
  ------------------
 1414|     16|    } else if (ctxt->input->flags & XML_INPUT_AUTO_ENCODING) {
  ------------------
  |  |   21|      0|#define XML_INPUT_AUTO_ENCODING     (7u << 1)
  ------------------
  |  Branch (1414:16): [True: 0, False: 0]
  ------------------
 1415|      0|        static const char *allowedUTF8[] = {
 1416|      0|            "UTF-8", "UTF8", NULL
 1417|      0|        };
 1418|      0|        static const char *allowedUTF16LE[] = {
 1419|      0|            "UTF-16", "UTF-16LE", "UTF16", NULL
 1420|      0|        };
 1421|      0|        static const char *allowedUTF16BE[] = {
 1422|      0|            "UTF-16", "UTF-16BE", "UTF16", NULL
 1423|      0|        };
 1424|      0|        const char **allowed = NULL;
 1425|      0|        const char *autoEnc = NULL;
 1426|       |
 1427|      0|        switch (ctxt->input->flags & XML_INPUT_AUTO_ENCODING) {
  ------------------
  |  |   21|      0|#define XML_INPUT_AUTO_ENCODING     (7u << 1)
  ------------------
  |  Branch (1427:17): [True: 0, False: 0]
  ------------------
 1428|      0|            case XML_INPUT_AUTO_UTF8:
  ------------------
  |  |   22|      0|#define XML_INPUT_AUTO_UTF8         (1u << 1)
  ------------------
  |  Branch (1428:13): [True: 0, False: 0]
  ------------------
 1429|      0|                allowed = allowedUTF8;
 1430|      0|                autoEnc = "UTF-8";
 1431|      0|                break;
 1432|      0|            case XML_INPUT_AUTO_UTF16LE:
  ------------------
  |  |   23|      0|#define XML_INPUT_AUTO_UTF16LE      (2u << 1)
  ------------------
  |  Branch (1432:13): [True: 0, False: 0]
  ------------------
 1433|      0|                allowed = allowedUTF16LE;
 1434|      0|                autoEnc = "UTF-16LE";
 1435|      0|                break;
 1436|      0|            case XML_INPUT_AUTO_UTF16BE:
  ------------------
  |  |   24|      0|#define XML_INPUT_AUTO_UTF16BE      (3u << 1)
  ------------------
  |  Branch (1436:13): [True: 0, False: 0]
  ------------------
 1437|      0|                allowed = allowedUTF16BE;
 1438|      0|                autoEnc = "UTF-16BE";
 1439|      0|                break;
 1440|      0|        }
 1441|       |
 1442|      0|        if (allowed != NULL) {
  ------------------
  |  Branch (1442:13): [True: 0, False: 0]
  ------------------
 1443|      0|            const char **p;
 1444|      0|            int match = 0;
 1445|       |
 1446|      0|            for (p = allowed; *p != NULL; p++) {
  ------------------
  |  Branch (1446:31): [True: 0, False: 0]
  ------------------
 1447|      0|                if (xmlStrcasecmp(encoding, BAD_CAST *p) == 0) {
  ------------------
  |  |   35|      0|#define BAD_CAST (xmlChar *)
  ------------------
  |  Branch (1447:21): [True: 0, False: 0]
  ------------------
 1448|      0|                    match = 1;
 1449|      0|                    break;
 1450|      0|                }
 1451|      0|            }
 1452|       |
 1453|      0|            if (match == 0) {
  ------------------
  |  Branch (1453:17): [True: 0, False: 0]
  ------------------
 1454|      0|                xmlWarningMsg(ctxt, XML_WAR_ENCODING_MISMATCH,
 1455|      0|                              "Encoding '%s' doesn't match "
 1456|      0|                              "auto-detected '%s'\n",
 1457|      0|                              encoding, BAD_CAST autoEnc);
  ------------------
  |  |   35|      0|#define BAD_CAST (xmlChar *)
  ------------------
 1458|      0|            }
 1459|      0|        }
 1460|      0|    }
 1461|     16|}
xmlFreeInputStream:
 1476|    183|xmlFreeInputStream(xmlParserInputPtr input) {
 1477|    183|    if (input == NULL) return;
  ------------------
  |  Branch (1477:9): [True: 0, False: 183]
  ------------------
 1478|       |
 1479|    183|    if (input->filename != NULL) xmlFree((char *) input->filename);
  ------------------
  |  Branch (1479:9): [True: 0, False: 183]
  ------------------
 1480|    183|    if (input->directory != NULL) xmlFree((char *) input->directory);
  ------------------
  |  Branch (1480:9): [True: 0, False: 183]
  ------------------
 1481|    183|    if (input->version != NULL) xmlFree((char *) input->version);
  ------------------
  |  Branch (1481:9): [True: 0, False: 183]
  ------------------
 1482|    183|    if ((input->free != NULL) && (input->base != NULL))
  ------------------
  |  Branch (1482:9): [True: 0, False: 183]
  |  Branch (1482:34): [True: 0, False: 0]
  ------------------
 1483|      0|        input->free((xmlChar *) input->base);
 1484|    183|    if (input->buf != NULL)
  ------------------
  |  Branch (1484:9): [True: 182, False: 1]
  ------------------
 1485|    182|        xmlFreeParserInputBuffer(input->buf);
 1486|    183|    xmlFree(input);
 1487|    183|}
xmlNewInputStream:
 1498|     91|xmlNewInputStream(xmlParserCtxtPtr ctxt) {
 1499|     91|    xmlParserInputPtr input;
 1500|       |
 1501|     91|    input = (xmlParserInputPtr) xmlMalloc(sizeof(xmlParserInput));
 1502|     91|    if (input == NULL) {
  ------------------
  |  Branch (1502:9): [True: 0, False: 91]
  ------------------
 1503|      0|        xmlErrMemory(ctxt,  "couldn't allocate a new input stream\n");
 1504|      0|	return(NULL);
 1505|      0|    }
 1506|     91|    memset(input, 0, sizeof(xmlParserInput));
 1507|     91|    input->line = 1;
 1508|     91|    input->col = 1;
 1509|       |
 1510|       |    /*
 1511|       |     * If the context is NULL the id cannot be initialized, but that
 1512|       |     * should not happen while parsing which is the situation where
 1513|       |     * the id is actually needed.
 1514|       |     */
 1515|     91|    if (ctxt != NULL) {
  ------------------
  |  Branch (1515:9): [True: 91, False: 0]
  ------------------
 1516|     91|        if (input->id >= INT_MAX) {
  ------------------
  |  Branch (1516:13): [True: 0, False: 91]
  ------------------
 1517|      0|            xmlErrMemory(ctxt, "Input ID overflow\n");
 1518|      0|            return(NULL);
 1519|      0|        }
 1520|     91|        input->id = ctxt->input_id++;
 1521|     91|    }
 1522|       |
 1523|     91|    return(input);
 1524|     91|}
xmlFreeParserCtxt:
 1967|    191|{
 1968|    191|    xmlParserInputPtr input;
 1969|       |
 1970|    191|    if (ctxt == NULL) return;
  ------------------
  |  Branch (1970:9): [True: 0, False: 191]
  ------------------
 1971|       |
 1972|    374|    while ((input = inputPop(ctxt)) != NULL) { /* Non consuming */
  ------------------
  |  Branch (1972:12): [True: 183, False: 191]
  ------------------
 1973|    183|        xmlFreeInputStream(input);
 1974|    183|    }
 1975|    191|    if (ctxt->spaceTab != NULL) xmlFree(ctxt->spaceTab);
  ------------------
  |  Branch (1975:9): [True: 0, False: 191]
  ------------------
 1976|    191|    if (ctxt->nameTab != NULL) xmlFree((xmlChar * *)ctxt->nameTab);
  ------------------
  |  Branch (1976:9): [True: 185, False: 6]
  ------------------
 1977|    191|    if (ctxt->nodeTab != NULL) xmlFree(ctxt->nodeTab);
  ------------------
  |  Branch (1977:9): [True: 185, False: 6]
  ------------------
 1978|    191|    if (ctxt->nodeInfoTab != NULL) xmlFree(ctxt->nodeInfoTab);
  ------------------
  |  Branch (1978:9): [True: 0, False: 191]
  ------------------
 1979|    191|    if (ctxt->inputTab != NULL) xmlFree(ctxt->inputTab);
  ------------------
  |  Branch (1979:9): [True: 187, False: 4]
  ------------------
 1980|    191|    if (ctxt->version != NULL) xmlFree((char *) ctxt->version);
  ------------------
  |  Branch (1980:9): [True: 0, False: 191]
  ------------------
 1981|    191|    if (ctxt->encoding != NULL) xmlFree((char *) ctxt->encoding);
  ------------------
  |  Branch (1981:9): [True: 16, False: 175]
  ------------------
 1982|    191|    if (ctxt->extSubURI != NULL) xmlFree((char *) ctxt->extSubURI);
  ------------------
  |  Branch (1982:9): [True: 0, False: 191]
  ------------------
 1983|    191|    if (ctxt->extSubSystem != NULL) xmlFree((char *) ctxt->extSubSystem);
  ------------------
  |  Branch (1983:9): [True: 0, False: 191]
  ------------------
 1984|    191|#ifdef LIBXML_SAX1_ENABLED
 1985|    191|    if ((ctxt->sax != NULL) &&
  ------------------
  |  Branch (1985:9): [True: 189, False: 2]
  ------------------
 1986|    191|        (ctxt->sax != (xmlSAXHandlerPtr) &xmlDefaultSAXHandler))
  ------------------
  |  |  860|    189|  #define xmlDefaultSAXHandler XML_GLOBAL_MACRO(xmlDefaultSAXHandler)
  |  |  ------------------
  |  |  |  |  500|    189|  #define XML_GLOBAL_MACRO(name) (*__##name())
  |  |  ------------------
  ------------------
  |  Branch (1986:9): [True: 189, False: 0]
  ------------------
 1987|       |#else
 1988|       |    if (ctxt->sax != NULL)
 1989|       |#endif /* LIBXML_SAX1_ENABLED */
 1990|    189|        xmlFree(ctxt->sax);
 1991|    191|    if (ctxt->directory != NULL) xmlFree((char *) ctxt->directory);
  ------------------
  |  Branch (1991:9): [True: 0, False: 191]
  ------------------
 1992|    191|    if (ctxt->vctxt.nodeTab != NULL) xmlFree(ctxt->vctxt.nodeTab);
  ------------------
  |  Branch (1992:9): [True: 0, False: 191]
  ------------------
 1993|    191|    if (ctxt->atts != NULL) xmlFree((xmlChar * *)ctxt->atts);
  ------------------
  |  Branch (1993:9): [True: 103, False: 88]
  ------------------
 1994|    191|    if (ctxt->dict != NULL) xmlDictFree(ctxt->dict);
  ------------------
  |  Branch (1994:9): [True: 189, False: 2]
  ------------------
 1995|    191|    if (ctxt->nsTab != NULL) xmlFree(ctxt->nsTab);
  ------------------
  |  Branch (1995:9): [True: 0, False: 191]
  ------------------
 1996|    191|    if (ctxt->nsdb != NULL) xmlParserNsFree(ctxt->nsdb);
  ------------------
  |  Branch (1996:9): [True: 0, False: 191]
  ------------------
 1997|    191|    if (ctxt->attrHash != NULL) xmlFree(ctxt->attrHash);
  ------------------
  |  Branch (1997:9): [True: 0, False: 191]
  ------------------
 1998|    191|    if (ctxt->pushTab != NULL) xmlFree(ctxt->pushTab);
  ------------------
  |  Branch (1998:9): [True: 0, False: 191]
  ------------------
 1999|    191|    if (ctxt->attallocs != NULL) xmlFree(ctxt->attallocs);
  ------------------
  |  Branch (1999:9): [True: 0, False: 191]
  ------------------
 2000|    191|    if (ctxt->attsDefault != NULL)
  ------------------
  |  Branch (2000:9): [True: 0, False: 191]
  ------------------
 2001|      0|        xmlHashFree(ctxt->attsDefault, xmlHashDefaultDeallocator);
 2002|    191|    if (ctxt->attsSpecial != NULL)
  ------------------
  |  Branch (2002:9): [True: 0, False: 191]
  ------------------
 2003|      0|        xmlHashFree(ctxt->attsSpecial, NULL);
 2004|    191|    if (ctxt->freeElems != NULL) {
  ------------------
  |  Branch (2004:9): [True: 0, False: 191]
  ------------------
 2005|      0|        xmlNodePtr cur, next;
 2006|       |
 2007|      0|	cur = ctxt->freeElems;
 2008|      0|	while (cur != NULL) {
  ------------------
  |  Branch (2008:9): [True: 0, False: 0]
  ------------------
 2009|      0|	    next = cur->next;
 2010|      0|	    xmlFree(cur);
 2011|      0|	    cur = next;
 2012|      0|	}
 2013|      0|    }
 2014|    191|    if (ctxt->freeAttrs != NULL) {
  ------------------
  |  Branch (2014:9): [True: 0, False: 191]
  ------------------
 2015|      0|        xmlAttrPtr cur, next;
 2016|       |
 2017|      0|	cur = ctxt->freeAttrs;
 2018|      0|	while (cur != NULL) {
  ------------------
  |  Branch (2018:9): [True: 0, False: 0]
  ------------------
 2019|      0|	    next = cur->next;
 2020|      0|	    xmlFree(cur);
 2021|      0|	    cur = next;
 2022|      0|	}
 2023|      0|    }
 2024|       |    /*
 2025|       |     * cleanup the error strings
 2026|       |     */
 2027|    191|    if (ctxt->lastError.message != NULL)
  ------------------
  |  Branch (2027:9): [True: 106, False: 85]
  ------------------
 2028|    106|        xmlFree(ctxt->lastError.message);
 2029|    191|    if (ctxt->lastError.file != NULL)
  ------------------
  |  Branch (2029:9): [True: 0, False: 191]
  ------------------
 2030|      0|        xmlFree(ctxt->lastError.file);
 2031|    191|    if (ctxt->lastError.str1 != NULL)
  ------------------
  |  Branch (2031:9): [True: 60, False: 131]
  ------------------
 2032|     60|        xmlFree(ctxt->lastError.str1);
 2033|    191|    if (ctxt->lastError.str2 != NULL)
  ------------------
  |  Branch (2033:9): [True: 2, False: 189]
  ------------------
 2034|      2|        xmlFree(ctxt->lastError.str2);
 2035|    191|    if (ctxt->lastError.str3 != NULL)
  ------------------
  |  Branch (2035:9): [True: 0, False: 191]
  ------------------
 2036|      0|        xmlFree(ctxt->lastError.str3);
 2037|       |
 2038|    191|#ifdef LIBXML_CATALOG_ENABLED
 2039|    191|    if (ctxt->catalogs != NULL)
  ------------------
  |  Branch (2039:9): [True: 0, False: 191]
  ------------------
 2040|      0|	xmlCatalogFreeLocal(ctxt->catalogs);
 2041|    191|#endif
 2042|    191|    xmlFree(ctxt);
 2043|    191|}
xmlInitNodeInfoSeq:
 2149|    185|{
 2150|    185|    if (seq == NULL)
  ------------------
  |  Branch (2150:9): [True: 0, False: 185]
  ------------------
 2151|      0|        return;
 2152|    185|    seq->length = 0;
 2153|    185|    seq->maximum = 0;
 2154|    185|    seq->buffer = NULL;
 2155|    185|}
parserInternals.c:xmlErrInternal:
  163|      1|{
  164|      1|    if ((ctxt != NULL) && (ctxt->disableSAX != 0) &&
  ------------------
  |  Branch (164:9): [True: 1, False: 0]
  |  Branch (164:27): [True: 0, False: 1]
  ------------------
  165|      1|        (ctxt->instate == XML_PARSER_EOF))
  ------------------
  |  Branch (165:9): [True: 0, False: 0]
  ------------------
  166|      0|	return;
  167|      1|    if (ctxt != NULL)
  ------------------
  |  Branch (167:9): [True: 1, False: 0]
  ------------------
  168|      1|        ctxt->errNo = XML_ERR_INTERNAL_ERROR;
  169|      1|    __xmlRaiseError(NULL, NULL, NULL,
  170|      1|                    ctxt, NULL, XML_FROM_PARSER, XML_ERR_INTERNAL_ERROR,
  171|      1|                    XML_ERR_FATAL, NULL, 0, (const char *) str, NULL, NULL,
  172|      1|                    0, 0, msg, str);
  173|      1|    if (ctxt != NULL) {
  ------------------
  |  Branch (173:9): [True: 1, False: 0]
  ------------------
  174|      1|        ctxt->wellFormed = 0;
  175|      1|        if (ctxt->recovery == 0)
  ------------------
  |  Branch (175:13): [True: 1, False: 0]
  ------------------
  176|      1|            ctxt->disableSAX = 1;
  177|      1|    }
  178|      1|}

xmlInitMutex:
  129|      8|{
  130|      8|#ifdef HAVE_POSIX_THREADS
  131|      8|    if (XML_IS_NEVER_THREADED() == 0)
  ------------------
  |  |   85|      8|#define XML_IS_NEVER_THREADED() (!libxml_is_threaded)
  ------------------
  |  Branch (131:9): [True: 8, False: 0]
  ------------------
  132|      8|        pthread_mutex_init(&mutex->lock, NULL);
  133|       |#elif defined HAVE_WIN32_THREADS
  134|       |    InitializeCriticalSection(&mutex->cs);
  135|       |#else
  136|       |    (void) mutex;
  137|       |#endif
  138|      8|}
xmlMutexLock:
  202|    190|{
  203|    190|    if (tok == NULL)
  ------------------
  |  Branch (203:9): [True: 0, False: 190]
  ------------------
  204|      0|        return;
  205|    190|#ifdef HAVE_POSIX_THREADS
  206|       |    /*
  207|       |     * This assumes that __libc_single_threaded won't change while the
  208|       |     * lock is held.
  209|       |     */
  210|    190|    if (XML_IS_THREADED() != 0)
  ------------------
  |  |   84|    190|#define XML_IS_THREADED() libxml_is_threaded
  ------------------
  |  Branch (210:9): [True: 190, False: 0]
  ------------------
  211|    190|        pthread_mutex_lock(&tok->lock);
  212|       |#elif defined HAVE_WIN32_THREADS
  213|       |    EnterCriticalSection(&tok->cs);
  214|       |#endif
  215|       |
  216|    190|}
xmlMutexUnlock:
  226|    190|{
  227|    190|    if (tok == NULL)
  ------------------
  |  Branch (227:9): [True: 0, False: 190]
  ------------------
  228|      0|        return;
  229|    190|#ifdef HAVE_POSIX_THREADS
  230|    190|    if (XML_IS_THREADED() != 0)
  ------------------
  |  |   84|    190|#define XML_IS_THREADED() libxml_is_threaded
  ------------------
  |  Branch (230:9): [True: 190, False: 0]
  ------------------
  231|    190|        pthread_mutex_unlock(&tok->lock);
  232|       |#elif defined HAVE_WIN32_THREADS
  233|       |    LeaveCriticalSection(&tok->cs);
  234|       |#endif
  235|    190|}
xmlNewRMutex:
  249|      2|{
  250|      2|    xmlRMutexPtr tok;
  251|       |
  252|      2|    if ((tok = malloc(sizeof(xmlRMutex))) == NULL)
  ------------------
  |  Branch (252:9): [True: 0, False: 2]
  ------------------
  253|      0|        return (NULL);
  254|      2|#ifdef HAVE_POSIX_THREADS
  255|      2|    if (XML_IS_NEVER_THREADED() == 0) {
  ------------------
  |  |   85|      2|#define XML_IS_NEVER_THREADED() (!libxml_is_threaded)
  ------------------
  |  Branch (255:9): [True: 2, False: 0]
  ------------------
  256|      2|        pthread_mutex_init(&tok->lock, NULL);
  257|      2|        tok->held = 0;
  258|      2|        tok->waiters = 0;
  259|      2|        pthread_cond_init(&tok->cv, NULL);
  260|      2|    }
  261|       |#elif defined HAVE_WIN32_THREADS
  262|       |    InitializeCriticalSection(&tok->cs);
  263|       |#endif
  264|      2|    return (tok);
  265|      2|}
xmlRMutexLock:
  298|      2|{
  299|      2|    if (tok == NULL)
  ------------------
  |  Branch (299:9): [True: 0, False: 2]
  ------------------
  300|      0|        return;
  301|      2|#ifdef HAVE_POSIX_THREADS
  302|      2|    if (XML_IS_THREADED() == 0)
  ------------------
  |  |   84|      2|#define XML_IS_THREADED() libxml_is_threaded
  ------------------
  |  Branch (302:9): [True: 0, False: 2]
  ------------------
  303|      0|        return;
  304|       |
  305|      2|    pthread_mutex_lock(&tok->lock);
  306|      2|    if (tok->held) {
  ------------------
  |  Branch (306:9): [True: 0, False: 2]
  ------------------
  307|      0|        if (pthread_equal(tok->tid, pthread_self())) {
  ------------------
  |  Branch (307:13): [True: 0, False: 0]
  ------------------
  308|      0|            tok->held++;
  309|      0|            pthread_mutex_unlock(&tok->lock);
  310|      0|            return;
  311|      0|        } else {
  312|      0|            tok->waiters++;
  313|      0|            while (tok->held)
  ------------------
  |  Branch (313:20): [True: 0, False: 0]
  ------------------
  314|      0|                pthread_cond_wait(&tok->cv, &tok->lock);
  315|      0|            tok->waiters--;
  316|      0|        }
  317|      0|    }
  318|      2|    tok->tid = pthread_self();
  319|      2|    tok->held = 1;
  320|      2|    pthread_mutex_unlock(&tok->lock);
  321|       |#elif defined HAVE_WIN32_THREADS
  322|       |    EnterCriticalSection(&tok->cs);
  323|       |#endif
  324|      2|}
xmlRMutexUnlock:
  334|      2|{
  335|      2|    if (tok == NULL)
  ------------------
  |  Branch (335:9): [True: 0, False: 2]
  ------------------
  336|      0|        return;
  337|      2|#ifdef HAVE_POSIX_THREADS
  338|      2|    if (XML_IS_THREADED() == 0)
  ------------------
  |  |   84|      2|#define XML_IS_THREADED() libxml_is_threaded
  ------------------
  |  Branch (338:9): [True: 0, False: 2]
  ------------------
  339|      0|        return;
  340|       |
  341|      2|    pthread_mutex_lock(&tok->lock);
  342|      2|    tok->held--;
  343|      2|    if (tok->held == 0) {
  ------------------
  |  Branch (343:9): [True: 2, False: 0]
  ------------------
  344|      2|        if (tok->waiters)
  ------------------
  |  Branch (344:13): [True: 0, False: 2]
  ------------------
  345|      0|            pthread_cond_signal(&tok->cv);
  346|      2|        memset(&tok->tid, 0, sizeof(tok->tid));
  347|      2|    }
  348|      2|    pthread_mutex_unlock(&tok->lock);
  349|       |#elif defined HAVE_WIN32_THREADS
  350|       |    LeaveCriticalSection(&tok->cs);
  351|       |#endif
  352|      2|}
xmlInitParser:
  569|    720|xmlInitParser(void) {
  570|       |    /*
  571|       |     * Note that the initialization code must not make memory allocations.
  572|       |     */
  573|    720|    if (xmlParserInitialized != 0)
  ------------------
  |  Branch (573:9): [True: 718, False: 2]
  ------------------
  574|    718|        return;
  575|       |
  576|      2|    xmlGlobalInitMutexLock();
  577|       |
  578|      2|    if (xmlParserInnerInitialized == 0) {
  ------------------
  |  Branch (578:9): [True: 2, False: 0]
  ------------------
  579|       |#if defined(_WIN32) && \
  580|       |    !defined(LIBXML_THREAD_ALLOC_ENABLED) && \
  581|       |    (!defined(LIBXML_STATIC) || defined(LIBXML_STATIC_FOR_DLL))
  582|       |        if (xmlFree == free)
  583|       |            atexit(xmlCleanupParser);
  584|       |#endif
  585|       |
  586|      2|        xmlInitMemoryInternal(); /* Should come second */
  587|      2|        xmlInitGlobalsInternal();
  588|      2|        xmlInitRandom();
  589|      2|        xmlInitDictInternal();
  590|      2|        xmlInitEncodingInternal();
  591|      2|#if defined(LIBXML_XPATH_ENABLED) || defined(LIBXML_SCHEMAS_ENABLED)
  592|      2|        xmlInitXPathInternal();
  593|      2|#endif
  594|       |
  595|      2|        xmlRegisterDefaultInputCallbacks();
  596|      2|#ifdef LIBXML_OUTPUT_ENABLED
  597|      2|        xmlRegisterDefaultOutputCallbacks();
  598|      2|#endif /* LIBXML_OUTPUT_ENABLED */
  599|       |
  600|      2|        xmlParserInnerInitialized = 1;
  601|      2|    }
  602|       |
  603|      2|    xmlGlobalInitMutexUnlock();
  604|       |
  605|      2|    xmlParserInitialized = 1;
  606|      2|}
threads.c:xmlGlobalInitMutexLock:
  462|      2|xmlGlobalInitMutexLock(void) {
  463|      2|#ifdef HAVE_POSIX_THREADS
  464|       |
  465|      2|#ifdef XML_PTHREAD_WEAK
  466|       |    /*
  467|       |     * This is somewhat unreliable since libpthread could be loaded
  468|       |     * later with dlopen() and threads could be created. But it's
  469|       |     * long-standing behavior and hard to work around.
  470|       |     */
  471|      2|    if (libxml_is_threaded == -1)
  ------------------
  |  Branch (471:9): [True: 2, False: 0]
  ------------------
  472|      2|        libxml_is_threaded =
  473|      2|            (pthread_mutex_init != NULL) &&
  ------------------
  |  Branch (473:13): [True: 2, False: 0]
  ------------------
  474|      2|            (pthread_mutex_destroy != NULL) &&
  ------------------
  |  Branch (474:13): [True: 2, False: 0]
  ------------------
  475|      2|            (pthread_mutex_lock != NULL) &&
  ------------------
  |  Branch (475:13): [True: 2, False: 0]
  ------------------
  476|      2|            (pthread_mutex_unlock != NULL) &&
  ------------------
  |  Branch (476:13): [True: 2, False: 0]
  ------------------
  477|      2|            (pthread_cond_init != NULL) &&
  ------------------
  |  Branch (477:13): [True: 2, False: 0]
  ------------------
  478|      2|            (pthread_cond_destroy != NULL) &&
  ------------------
  |  Branch (478:13): [True: 2, False: 0]
  ------------------
  479|      2|            (pthread_cond_wait != NULL) &&
  ------------------
  |  Branch (479:13): [True: 2, False: 0]
  ------------------
  480|       |            /*
  481|       |             * pthread_equal can be inline, resuting in -Waddress warnings.
  482|       |             * Let's assume it's available if all the other functions are.
  483|       |             */
  484|       |            /* (pthread_equal != NULL) && */
  485|      2|            (pthread_self != NULL) &&
  ------------------
  |  Branch (485:13): [True: 2, False: 0]
  ------------------
  486|      2|            (pthread_cond_signal != NULL);
  ------------------
  |  Branch (486:13): [True: 2, False: 0]
  ------------------
  487|      2|#endif
  488|       |
  489|       |    /* The mutex is statically initialized, so we just lock it. */
  490|      2|    if (XML_IS_THREADED() != 0)
  ------------------
  |  |   84|      2|#define XML_IS_THREADED() libxml_is_threaded
  ------------------
  |  Branch (490:9): [True: 2, False: 0]
  ------------------
  491|      2|        pthread_mutex_lock(&global_init_lock);
  492|       |
  493|       |#elif defined HAVE_WIN32_THREADS
  494|       |
  495|       |    LPCRITICAL_SECTION cs;
  496|       |
  497|       |    /* Create a new critical section */
  498|       |    if (global_init_lock == NULL) {
  499|       |        cs = malloc(sizeof(CRITICAL_SECTION));
  500|       |        if (cs == NULL) {
  501|       |            xmlGenericError(xmlGenericErrorContext,
  502|       |                            "xmlGlobalInitMutexLock: out of memory\n");
  503|       |            return;
  504|       |        }
  505|       |        InitializeCriticalSection(cs);
  506|       |
  507|       |        /* Swap it into the global_init_lock */
  508|       |#ifdef InterlockedCompareExchangePointer
  509|       |        InterlockedCompareExchangePointer((void **) &global_init_lock,
  510|       |                                          cs, NULL);
  511|       |#else /* Use older void* version */
  512|       |        InterlockedCompareExchange((void **) &global_init_lock,
  513|       |                                   (void *) cs, NULL);
  514|       |#endif /* InterlockedCompareExchangePointer */
  515|       |
  516|       |        /* If another thread successfully recorded its critical
  517|       |         * section in the global_init_lock then discard the one
  518|       |         * allocated by this thread. */
  519|       |        if (global_init_lock != cs) {
  520|       |            DeleteCriticalSection(cs);
  521|       |            free(cs);
  522|       |        }
  523|       |    }
  524|       |
  525|       |    /* Lock the chosen critical section */
  526|       |    EnterCriticalSection(global_init_lock);
  527|       |
  528|       |#endif
  529|      2|}
threads.c:xmlGlobalInitMutexUnlock:
  532|      2|xmlGlobalInitMutexUnlock(void) {
  533|      2|#ifdef HAVE_POSIX_THREADS
  534|      2|    if (XML_IS_THREADED() != 0)
  ------------------
  |  |   84|      2|#define XML_IS_THREADED() libxml_is_threaded
  ------------------
  |  Branch (534:9): [True: 2, False: 0]
  ------------------
  535|      2|        pthread_mutex_unlock(&global_init_lock);
  536|       |#elif defined HAVE_WIN32_THREADS
  537|       |    if (global_init_lock != NULL)
  538|       |	LeaveCriticalSection(global_init_lock);
  539|       |#endif
  540|      2|}

xmlGetIntSubset:
  899|    868|xmlGetIntSubset(const xmlDoc *doc) {
  900|    868|    xmlNodePtr cur;
  901|       |
  902|    868|    if (doc == NULL)
  ------------------
  |  Branch (902:9): [True: 0, False: 868]
  ------------------
  903|      0|	return(NULL);
  904|    868|    cur = doc->children;
  905|  1.59k|    while (cur != NULL) {
  ------------------
  |  Branch (905:12): [True: 906, False: 686]
  ------------------
  906|    906|	if (cur->type == XML_DTD_NODE)
  ------------------
  |  Branch (906:6): [True: 182, False: 724]
  ------------------
  907|    182|	    return((xmlDtdPtr) cur);
  908|    724|	cur = cur->next;
  909|    724|    }
  910|    686|    return((xmlDtdPtr) doc->intSubset);
  911|    868|}
xmlCreateIntSubset:
  925|    175|                   const xmlChar *ExternalID, const xmlChar *SystemID) {
  926|    175|    xmlDtdPtr cur;
  927|       |
  928|    175|    if ((doc != NULL) && (xmlGetIntSubset(doc) != NULL)) {
  ------------------
  |  Branch (928:9): [True: 175, False: 0]
  |  Branch (928:26): [True: 0, False: 175]
  ------------------
  929|      0|	return(NULL);
  930|      0|    }
  931|       |
  932|       |    /*
  933|       |     * Allocate a new DTD and fill the fields.
  934|       |     */
  935|    175|    cur = (xmlDtdPtr) xmlMalloc(sizeof(xmlDtd));
  936|    175|    if (cur == NULL) {
  ------------------
  |  Branch (936:9): [True: 1, False: 174]
  ------------------
  937|      1|	xmlTreeErrMemory("building internal subset");
  938|      1|	return(NULL);
  939|      1|    }
  940|    174|    memset(cur, 0, sizeof(xmlDtd));
  941|    174|    cur->type = XML_DTD_NODE;
  942|       |
  943|    174|    if (name != NULL) {
  ------------------
  |  Branch (943:9): [True: 174, False: 0]
  ------------------
  944|    174|	cur->name = xmlStrdup(name);
  945|    174|	if (cur->name == NULL) {
  ------------------
  |  Branch (945:6): [True: 0, False: 174]
  ------------------
  946|      0|	    xmlTreeErrMemory("building internal subset");
  947|      0|	    xmlFree(cur);
  948|      0|	    return(NULL);
  949|      0|	}
  950|    174|    }
  951|    174|    if (ExternalID != NULL) {
  ------------------
  |  Branch (951:9): [True: 166, False: 8]
  ------------------
  952|    166|	cur->ExternalID = xmlStrdup(ExternalID);
  953|    166|	if (cur->ExternalID  == NULL) {
  ------------------
  |  Branch (953:6): [True: 0, False: 166]
  ------------------
  954|      0|	    xmlTreeErrMemory("building internal subset");
  955|      0|	    if (cur->name != NULL)
  ------------------
  |  Branch (955:10): [True: 0, False: 0]
  ------------------
  956|      0|	        xmlFree((char *)cur->name);
  957|      0|	    xmlFree(cur);
  958|      0|	    return(NULL);
  959|      0|	}
  960|    166|    }
  961|    174|    if (SystemID != NULL) {
  ------------------
  |  Branch (961:9): [True: 152, False: 22]
  ------------------
  962|    152|	cur->SystemID = xmlStrdup(SystemID);
  963|    152|	if (cur->SystemID == NULL) {
  ------------------
  |  Branch (963:6): [True: 0, False: 152]
  ------------------
  964|      0|	    xmlTreeErrMemory("building internal subset");
  965|      0|	    if (cur->name != NULL)
  ------------------
  |  Branch (965:10): [True: 0, False: 0]
  ------------------
  966|      0|	        xmlFree((char *)cur->name);
  967|      0|	    if (cur->ExternalID != NULL)
  ------------------
  |  Branch (967:10): [True: 0, False: 0]
  ------------------
  968|      0|	        xmlFree((char *)cur->ExternalID);
  969|      0|	    xmlFree(cur);
  970|      0|	    return(NULL);
  971|      0|	}
  972|    152|    }
  973|    174|    if (doc != NULL) {
  ------------------
  |  Branch (973:9): [True: 174, False: 0]
  ------------------
  974|    174|	doc->intSubset = cur;
  975|    174|	cur->parent = doc;
  976|    174|	cur->doc = doc;
  977|    174|	if (doc->children == NULL) {
  ------------------
  |  Branch (977:6): [True: 40, False: 134]
  ------------------
  978|     40|	    doc->children = (xmlNodePtr) cur;
  979|     40|	    doc->last = (xmlNodePtr) cur;
  980|    134|	} else {
  981|    134|	    if (doc->type == XML_HTML_DOCUMENT_NODE) {
  ------------------
  |  Branch (981:10): [True: 134, False: 0]
  ------------------
  982|    134|		xmlNodePtr prev;
  983|       |
  984|    134|		prev = doc->children;
  985|    134|		prev->prev = (xmlNodePtr) cur;
  986|    134|		cur->next = prev;
  987|    134|		doc->children = (xmlNodePtr) cur;
  988|    134|	    } else {
  989|      0|		xmlNodePtr next;
  990|       |
  991|      0|		next = doc->children;
  992|      0|		while ((next != NULL) && (next->type != XML_ELEMENT_NODE))
  ------------------
  |  Branch (992:10): [True: 0, False: 0]
  |  Branch (992:28): [True: 0, False: 0]
  ------------------
  993|      0|		    next = next->next;
  994|      0|		if (next == NULL) {
  ------------------
  |  Branch (994:7): [True: 0, False: 0]
  ------------------
  995|      0|		    cur->prev = doc->last;
  996|      0|		    cur->prev->next = (xmlNodePtr) cur;
  997|      0|		    cur->next = NULL;
  998|      0|		    doc->last = (xmlNodePtr) cur;
  999|      0|		} else {
 1000|      0|		    cur->next = next;
 1001|      0|		    cur->prev = next->prev;
 1002|      0|		    if (cur->prev == NULL)
  ------------------
  |  Branch (1002:11): [True: 0, False: 0]
  ------------------
 1003|      0|			doc->children = (xmlNodePtr) cur;
 1004|      0|		    else
 1005|      0|			cur->prev->next = (xmlNodePtr) cur;
 1006|      0|		    next->prev = (xmlNodePtr) cur;
 1007|      0|		}
 1008|      0|	    }
 1009|    134|	}
 1010|    174|    }
 1011|       |
 1012|    174|    if ((__xmlRegisterCallbacks) && (xmlRegisterNodeDefaultValue))
  ------------------
  |  |  682|      0|    XML_GLOBAL_MACRO(xmlRegisterNodeDefaultValue)
  |  |  ------------------
  |  |  |  |  500|      0|  #define XML_GLOBAL_MACRO(name) (*__##name())
  |  |  ------------------
  ------------------
  |  Branch (1012:9): [True: 0, False: 174]
  |  Branch (1012:37): [True: 0, False: 0]
  ------------------
 1013|      0|	xmlRegisterNodeDefaultValue((xmlNodePtr)cur);
  ------------------
  |  |  682|      0|    XML_GLOBAL_MACRO(xmlRegisterNodeDefaultValue)
  |  |  ------------------
  |  |  |  |  500|      0|  #define XML_GLOBAL_MACRO(name) (*__##name())
  |  |  ------------------
  ------------------
 1014|    174|    return(cur);
 1015|    174|}
xmlFreeDtd:
 1072|    174|xmlFreeDtd(xmlDtdPtr cur) {
 1073|    174|    xmlDictPtr dict = NULL;
 1074|       |
 1075|    174|    if (cur == NULL) {
  ------------------
  |  Branch (1075:9): [True: 0, False: 174]
  ------------------
 1076|      0|	return;
 1077|      0|    }
 1078|    174|    if (cur->doc != NULL) dict = cur->doc->dict;
  ------------------
  |  Branch (1078:9): [True: 174, False: 0]
  ------------------
 1079|       |
 1080|    174|    if ((__xmlRegisterCallbacks) && (xmlDeregisterNodeDefaultValue))
  ------------------
  |  |  684|      0|    XML_GLOBAL_MACRO(xmlDeregisterNodeDefaultValue)
  |  |  ------------------
  |  |  |  |  500|      0|  #define XML_GLOBAL_MACRO(name) (*__##name())
  |  |  ------------------
  ------------------
  |  Branch (1080:9): [True: 0, False: 174]
  |  Branch (1080:37): [True: 0, False: 0]
  ------------------
 1081|      0|	xmlDeregisterNodeDefaultValue((xmlNodePtr)cur);
  ------------------
  |  |  684|      0|    XML_GLOBAL_MACRO(xmlDeregisterNodeDefaultValue)
  |  |  ------------------
  |  |  |  |  500|      0|  #define XML_GLOBAL_MACRO(name) (*__##name())
  |  |  ------------------
  ------------------
 1082|       |
 1083|    174|    if (cur->children != NULL) {
  ------------------
  |  Branch (1083:9): [True: 0, False: 174]
  ------------------
 1084|      0|	xmlNodePtr next, c = cur->children;
 1085|       |
 1086|       |	/*
 1087|       |	 * Cleanup all nodes which are not part of the specific lists
 1088|       |	 * of notations, elements, attributes and entities.
 1089|       |	 */
 1090|      0|        while (c != NULL) {
  ------------------
  |  Branch (1090:16): [True: 0, False: 0]
  ------------------
 1091|      0|	    next = c->next;
 1092|      0|	    if ((c->type != XML_NOTATION_NODE) &&
  ------------------
  |  Branch (1092:10): [True: 0, False: 0]
  ------------------
 1093|      0|	        (c->type != XML_ELEMENT_DECL) &&
  ------------------
  |  Branch (1093:10): [True: 0, False: 0]
  ------------------
 1094|      0|		(c->type != XML_ATTRIBUTE_DECL) &&
  ------------------
  |  Branch (1094:3): [True: 0, False: 0]
  ------------------
 1095|      0|		(c->type != XML_ENTITY_DECL)) {
  ------------------
  |  Branch (1095:3): [True: 0, False: 0]
  ------------------
 1096|      0|		xmlUnlinkNode(c);
 1097|      0|		xmlFreeNode(c);
 1098|      0|	    }
 1099|      0|	    c = next;
 1100|      0|	}
 1101|      0|    }
 1102|    174|    DICT_FREE(cur->name)
  ------------------
  |  | 1025|    174|	if ((str) && ((!dict) ||				\
  |  |  ------------------
  |  |  |  Branch (1025:6): [True: 174, False: 0]
  |  |  |  Branch (1025:16): [True: 174, False: 0]
  |  |  ------------------
  |  | 1026|    174|	    (xmlDictOwns(dict, (const xmlChar *)(str)) == 0)))	\
  |  |  ------------------
  |  |  |  Branch (1026:6): [True: 0, False: 0]
  |  |  ------------------
  |  | 1027|    174|	    xmlFree((char *)(str));
  ------------------
 1103|    174|    DICT_FREE(cur->SystemID)
  ------------------
  |  | 1025|    174|	if ((str) && ((!dict) ||				\
  |  |  ------------------
  |  |  |  Branch (1025:6): [True: 152, False: 22]
  |  |  |  Branch (1025:16): [True: 152, False: 0]
  |  |  ------------------
  |  | 1026|    152|	    (xmlDictOwns(dict, (const xmlChar *)(str)) == 0)))	\
  |  |  ------------------
  |  |  |  Branch (1026:6): [True: 0, False: 0]
  |  |  ------------------
  |  | 1027|    174|	    xmlFree((char *)(str));
  ------------------
 1104|    174|    DICT_FREE(cur->ExternalID)
  ------------------
  |  | 1025|    174|	if ((str) && ((!dict) ||				\
  |  |  ------------------
  |  |  |  Branch (1025:6): [True: 166, False: 8]
  |  |  |  Branch (1025:16): [True: 166, False: 0]
  |  |  ------------------
  |  | 1026|    166|	    (xmlDictOwns(dict, (const xmlChar *)(str)) == 0)))	\
  |  |  ------------------
  |  |  |  Branch (1026:6): [True: 0, False: 0]
  |  |  ------------------
  |  | 1027|    174|	    xmlFree((char *)(str));
  ------------------
 1105|       |    /* TODO !!! */
 1106|    174|    if (cur->notations != NULL)
  ------------------
  |  Branch (1106:9): [True: 0, False: 174]
  ------------------
 1107|      0|        xmlFreeNotationTable((xmlNotationTablePtr) cur->notations);
 1108|       |
 1109|    174|    if (cur->elements != NULL)
  ------------------
  |  Branch (1109:9): [True: 0, False: 174]
  ------------------
 1110|      0|        xmlFreeElementTable((xmlElementTablePtr) cur->elements);
 1111|    174|    if (cur->attributes != NULL)
  ------------------
  |  Branch (1111:9): [True: 0, False: 174]
  ------------------
 1112|      0|        xmlFreeAttributeTable((xmlAttributeTablePtr) cur->attributes);
 1113|    174|    if (cur->entities != NULL)
  ------------------
  |  Branch (1113:9): [True: 0, False: 174]
  ------------------
 1114|      0|        xmlFreeEntitiesTable((xmlEntitiesTablePtr) cur->entities);
 1115|    174|    if (cur->pentities != NULL)
  ------------------
  |  Branch (1115:9): [True: 0, False: 174]
  ------------------
 1116|      0|        xmlFreeEntitiesTable((xmlEntitiesTablePtr) cur->pentities);
 1117|       |
 1118|    174|    xmlFree(cur);
 1119|    174|}
xmlFreeDoc:
 1177|    191|xmlFreeDoc(xmlDocPtr cur) {
 1178|    191|    xmlDtdPtr extSubset, intSubset;
 1179|    191|    xmlDictPtr dict = NULL;
 1180|       |
 1181|    191|    if (cur == NULL) {
  ------------------
  |  Branch (1181:9): [True: 11, False: 180]
  ------------------
 1182|     11|	return;
 1183|     11|    }
 1184|       |
 1185|    180|    if (cur != NULL) dict = cur->dict;
  ------------------
  |  Branch (1185:9): [True: 180, False: 0]
  ------------------
 1186|       |
 1187|    180|    if ((__xmlRegisterCallbacks) && (xmlDeregisterNodeDefaultValue))
  ------------------
  |  |  684|      0|    XML_GLOBAL_MACRO(xmlDeregisterNodeDefaultValue)
  |  |  ------------------
  |  |  |  |  500|      0|  #define XML_GLOBAL_MACRO(name) (*__##name())
  |  |  ------------------
  ------------------
  |  Branch (1187:9): [True: 0, False: 180]
  |  Branch (1187:37): [True: 0, False: 0]
  ------------------
 1188|      0|	xmlDeregisterNodeDefaultValue((xmlNodePtr)cur);
  ------------------
  |  |  684|      0|    XML_GLOBAL_MACRO(xmlDeregisterNodeDefaultValue)
  |  |  ------------------
  |  |  |  |  500|      0|  #define XML_GLOBAL_MACRO(name) (*__##name())
  |  |  ------------------
  ------------------
 1189|       |
 1190|       |    /*
 1191|       |     * Do this before freeing the children list to avoid ID lookups
 1192|       |     */
 1193|    180|    if (cur->ids != NULL) xmlFreeIDTable((xmlIDTablePtr) cur->ids);
  ------------------
  |  Branch (1193:9): [True: 38, False: 142]
  ------------------
 1194|    180|    cur->ids = NULL;
 1195|    180|    if (cur->refs != NULL) xmlFreeRefTable((xmlRefTablePtr) cur->refs);
  ------------------
  |  Branch (1195:9): [True: 0, False: 180]
  ------------------
 1196|    180|    cur->refs = NULL;
 1197|    180|    extSubset = cur->extSubset;
 1198|    180|    intSubset = cur->intSubset;
 1199|    180|    if (intSubset == extSubset)
  ------------------
  |  Branch (1199:9): [True: 6, False: 174]
  ------------------
 1200|      6|	extSubset = NULL;
 1201|    180|    if (extSubset != NULL) {
  ------------------
  |  Branch (1201:9): [True: 0, False: 180]
  ------------------
 1202|      0|	xmlUnlinkNode((xmlNodePtr) cur->extSubset);
 1203|      0|	cur->extSubset = NULL;
 1204|      0|	xmlFreeDtd(extSubset);
 1205|      0|    }
 1206|    180|    if (intSubset != NULL) {
  ------------------
  |  Branch (1206:9): [True: 174, False: 6]
  ------------------
 1207|    174|	xmlUnlinkNode((xmlNodePtr) cur->intSubset);
 1208|    174|	cur->intSubset = NULL;
 1209|    174|	xmlFreeDtd(intSubset);
 1210|    174|    }
 1211|       |
 1212|    180|    if (cur->children != NULL) xmlFreeNodeList(cur->children);
  ------------------
  |  Branch (1212:9): [True: 168, False: 12]
  ------------------
 1213|    180|    if (cur->oldNs != NULL) xmlFreeNsList(cur->oldNs);
  ------------------
  |  Branch (1213:9): [True: 0, False: 180]
  ------------------
 1214|       |
 1215|    180|    DICT_FREE(cur->version)
  ------------------
  |  | 1025|    180|	if ((str) && ((!dict) ||				\
  |  |  ------------------
  |  |  |  Branch (1025:6): [True: 0, False: 180]
  |  |  |  Branch (1025:16): [True: 0, False: 0]
  |  |  ------------------
  |  | 1026|      0|	    (xmlDictOwns(dict, (const xmlChar *)(str)) == 0)))	\
  |  |  ------------------
  |  |  |  Branch (1026:6): [True: 0, False: 0]
  |  |  ------------------
  |  | 1027|    180|	    xmlFree((char *)(str));
  ------------------
 1216|    180|    DICT_FREE(cur->name)
  ------------------
  |  | 1025|    180|	if ((str) && ((!dict) ||				\
  |  |  ------------------
  |  |  |  Branch (1025:6): [True: 0, False: 180]
  |  |  |  Branch (1025:16): [True: 0, False: 0]
  |  |  ------------------
  |  | 1026|      0|	    (xmlDictOwns(dict, (const xmlChar *)(str)) == 0)))	\
  |  |  ------------------
  |  |  |  Branch (1026:6): [True: 0, False: 0]
  |  |  ------------------
  |  | 1027|    180|	    xmlFree((char *)(str));
  ------------------
 1217|    180|    DICT_FREE(cur->encoding)
  ------------------
  |  | 1025|    180|	if ((str) && ((!dict) ||				\
  |  |  ------------------
  |  |  |  Branch (1025:6): [True: 58, False: 122]
  |  |  |  Branch (1025:16): [True: 58, False: 0]
  |  |  ------------------
  |  | 1026|     58|	    (xmlDictOwns(dict, (const xmlChar *)(str)) == 0)))	\
  |  |  ------------------
  |  |  |  Branch (1026:6): [True: 0, False: 0]
  |  |  ------------------
  |  | 1027|    180|	    xmlFree((char *)(str));
  ------------------
 1218|    180|    DICT_FREE(cur->URL)
  ------------------
  |  | 1025|    180|	if ((str) && ((!dict) ||				\
  |  |  ------------------
  |  |  |  Branch (1025:6): [True: 0, False: 180]
  |  |  |  Branch (1025:16): [True: 0, False: 0]
  |  |  ------------------
  |  | 1026|      0|	    (xmlDictOwns(dict, (const xmlChar *)(str)) == 0)))	\
  |  |  ------------------
  |  |  |  Branch (1026:6): [True: 0, False: 0]
  |  |  ------------------
  |  | 1027|    180|	    xmlFree((char *)(str));
  ------------------
 1219|    180|    xmlFree(cur);
 1220|    180|    if (dict) xmlDictFree(dict);
  ------------------
  |  Branch (1220:9): [True: 0, False: 180]
  ------------------
 1221|    180|}
xmlNodeListGetString:
 1673|  6.68k|{
 1674|  6.68k|    const xmlNode *node = list;
 1675|  6.68k|    xmlChar *ret = NULL;
 1676|  6.68k|    xmlEntityPtr ent;
 1677|  6.68k|    int attr;
 1678|       |
 1679|  6.68k|    if (list == NULL)
  ------------------
  |  Branch (1679:9): [True: 0, False: 6.68k]
  ------------------
 1680|      0|        return (NULL);
 1681|  6.68k|    if ((list->parent != NULL) && (list->parent->type == XML_ATTRIBUTE_NODE))
  ------------------
  |  Branch (1681:9): [True: 6.68k, False: 0]
  |  Branch (1681:35): [True: 6.68k, False: 0]
  ------------------
 1682|  6.68k|        attr = 1;
 1683|      0|    else
 1684|      0|        attr = 0;
 1685|       |
 1686|  13.3k|    while (node != NULL) {
  ------------------
  |  Branch (1686:12): [True: 6.68k, False: 6.68k]
  ------------------
 1687|  6.68k|        if ((node->type == XML_TEXT_NODE) ||
  ------------------
  |  Branch (1687:13): [True: 6.68k, False: 0]
  ------------------
 1688|  6.68k|            (node->type == XML_CDATA_SECTION_NODE)) {
  ------------------
  |  Branch (1688:13): [True: 0, False: 0]
  ------------------
 1689|  6.68k|            if (inLine) {
  ------------------
  |  Branch (1689:17): [True: 0, False: 6.68k]
  ------------------
 1690|      0|                ret = xmlStrcat(ret, node->content);
 1691|  6.68k|            } else {
 1692|  6.68k|                xmlChar *buffer;
 1693|       |
 1694|  6.68k|		if (attr)
  ------------------
  |  Branch (1694:7): [True: 6.68k, False: 0]
  ------------------
 1695|  6.68k|		    buffer = xmlEncodeAttributeEntities(doc, node->content);
 1696|      0|		else
 1697|      0|		    buffer = xmlEncodeEntitiesReentrant(doc, node->content);
 1698|  6.68k|                if (buffer != NULL) {
  ------------------
  |  Branch (1698:21): [True: 6.68k, False: 0]
  ------------------
 1699|  6.68k|                    ret = xmlStrcat(ret, buffer);
 1700|  6.68k|                    xmlFree(buffer);
 1701|  6.68k|                }
 1702|  6.68k|            }
 1703|  6.68k|        } else if (node->type == XML_ENTITY_REF_NODE) {
  ------------------
  |  Branch (1703:20): [True: 0, False: 0]
  ------------------
 1704|      0|            if (inLine) {
  ------------------
  |  Branch (1704:17): [True: 0, False: 0]
  ------------------
 1705|      0|                ent = xmlGetDocEntity(doc, node->name);
 1706|      0|                if (ent != NULL) {
  ------------------
  |  Branch (1706:21): [True: 0, False: 0]
  ------------------
 1707|      0|                    xmlChar *buffer;
 1708|       |
 1709|       |                    /* an entity content can be any "well balanced chunk",
 1710|       |                     * i.e. the result of the content [43] production:
 1711|       |                     * http://www.w3.org/TR/REC-xml#NT-content.
 1712|       |                     * So it can contain text, CDATA section or nested
 1713|       |                     * entity reference nodes (among others).
 1714|       |                     * -> we recursive  call xmlNodeListGetString()
 1715|       |                     * which handles these types */
 1716|      0|                    buffer = xmlNodeListGetString(doc, ent->children, 1);
 1717|      0|                    if (buffer != NULL) {
  ------------------
  |  Branch (1717:25): [True: 0, False: 0]
  ------------------
 1718|      0|                        ret = xmlStrcat(ret, buffer);
 1719|      0|                        xmlFree(buffer);
 1720|      0|                    }
 1721|      0|                } else {
 1722|      0|                    ret = xmlStrcat(ret, node->content);
 1723|      0|                }
 1724|      0|            } else {
 1725|      0|                xmlChar buf[2];
 1726|       |
 1727|      0|                buf[0] = '&';
 1728|      0|                buf[1] = 0;
 1729|      0|                ret = xmlStrncat(ret, buf, 1);
 1730|      0|                ret = xmlStrcat(ret, node->name);
 1731|      0|                buf[0] = ';';
 1732|      0|                buf[1] = 0;
 1733|      0|                ret = xmlStrncat(ret, buf, 1);
 1734|      0|            }
 1735|      0|        }
 1736|       |#if 0
 1737|       |        else {
 1738|       |            xmlGenericError(xmlGenericErrorContext,
 1739|       |                            "xmlGetNodeListString : invalid node type %d\n",
 1740|       |                            node->type);
 1741|       |        }
 1742|       |#endif
 1743|  6.68k|        node = node->next;
 1744|  6.68k|    }
 1745|  6.68k|    return (ret);
 1746|  6.68k|}
xmlNewNsPropEatName:
 1973|  13.7k|           const xmlChar *value) {
 1974|       |
 1975|  13.7k|    if (name == NULL) {
  ------------------
  |  Branch (1975:9): [True: 0, False: 13.7k]
  ------------------
 1976|      0|	return(NULL);
 1977|      0|    }
 1978|       |
 1979|  13.7k|    return xmlNewPropInternal(node, ns, name, value, 1);
 1980|  13.7k|}
xmlFreePropList:
 2047|  6.84k|xmlFreePropList(xmlAttrPtr cur) {
 2048|  6.84k|    xmlAttrPtr next;
 2049|  6.84k|    if (cur == NULL) return;
  ------------------
  |  Branch (2049:9): [True: 0, False: 6.84k]
  ------------------
 2050|  20.5k|    while (cur != NULL) {
  ------------------
  |  Branch (2050:12): [True: 13.7k, False: 6.84k]
  ------------------
 2051|  13.7k|        next = cur->next;
 2052|  13.7k|        xmlFreeProp(cur);
 2053|  13.7k|	cur = next;
 2054|  13.7k|    }
 2055|  6.84k|}
xmlFreeProp:
 2064|  13.7k|xmlFreeProp(xmlAttrPtr cur) {
 2065|  13.7k|    xmlDictPtr dict = NULL;
 2066|  13.7k|    if (cur == NULL) return;
  ------------------
  |  Branch (2066:9): [True: 0, False: 13.7k]
  ------------------
 2067|       |
 2068|  13.7k|    if (cur->doc != NULL) dict = cur->doc->dict;
  ------------------
  |  Branch (2068:9): [True: 13.7k, False: 0]
  ------------------
 2069|       |
 2070|  13.7k|    if ((__xmlRegisterCallbacks) && (xmlDeregisterNodeDefaultValue))
  ------------------
  |  |  684|      0|    XML_GLOBAL_MACRO(xmlDeregisterNodeDefaultValue)
  |  |  ------------------
  |  |  |  |  500|      0|  #define XML_GLOBAL_MACRO(name) (*__##name())
  |  |  ------------------
  ------------------
  |  Branch (2070:9): [True: 0, False: 13.7k]
  |  Branch (2070:37): [True: 0, False: 0]
  ------------------
 2071|      0|	xmlDeregisterNodeDefaultValue((xmlNodePtr)cur);
  ------------------
  |  |  684|      0|    XML_GLOBAL_MACRO(xmlDeregisterNodeDefaultValue)
  |  |  ------------------
  |  |  |  |  500|      0|  #define XML_GLOBAL_MACRO(name) (*__##name())
  |  |  ------------------
  ------------------
 2072|       |
 2073|       |    /* Check for ID removal -> leading to invalid references ! */
 2074|  13.7k|    if ((cur->doc != NULL) && (cur->atype == XML_ATTRIBUTE_ID)) {
  ------------------
  |  Branch (2074:9): [True: 13.7k, False: 0]
  |  Branch (2074:31): [True: 208, False: 13.4k]
  ------------------
 2075|    208|	    xmlRemoveID(cur->doc, cur);
 2076|    208|    }
 2077|  13.7k|    if (cur->children != NULL) xmlFreeNodeList(cur->children);
  ------------------
  |  Branch (2077:9): [True: 13.6k, False: 10]
  ------------------
 2078|  13.7k|    DICT_FREE(cur->name)
  ------------------
  |  | 1025|  13.7k|	if ((str) && ((!dict) ||				\
  |  |  ------------------
  |  |  |  Branch (1025:6): [True: 13.7k, False: 0]
  |  |  |  Branch (1025:16): [True: 13.7k, False: 0]
  |  |  ------------------
  |  | 1026|  13.7k|	    (xmlDictOwns(dict, (const xmlChar *)(str)) == 0)))	\
  |  |  ------------------
  |  |  |  Branch (1026:6): [True: 0, False: 0]
  |  |  ------------------
  |  | 1027|  13.7k|	    xmlFree((char *)(str));
  ------------------
 2079|  13.7k|    xmlFree(cur);
 2080|  13.7k|}
xmlNewDocPI:
 2131|      2|xmlNewDocPI(xmlDocPtr doc, const xmlChar *name, const xmlChar *content) {
 2132|      2|    xmlNodePtr cur;
 2133|       |
 2134|      2|    if (name == NULL) {
  ------------------
  |  Branch (2134:9): [True: 0, False: 2]
  ------------------
 2135|      0|	return(NULL);
 2136|      0|    }
 2137|       |
 2138|       |    /*
 2139|       |     * Allocate a new node and fill the fields.
 2140|       |     */
 2141|      2|    cur = (xmlNodePtr) xmlMalloc(sizeof(xmlNode));
 2142|      2|    if (cur == NULL) {
  ------------------
  |  Branch (2142:9): [True: 0, False: 2]
  ------------------
 2143|      0|	xmlTreeErrMemory("building PI");
 2144|      0|	return(NULL);
 2145|      0|    }
 2146|      2|    memset(cur, 0, sizeof(xmlNode));
 2147|      2|    cur->type = XML_PI_NODE;
 2148|       |
 2149|      2|    if ((doc != NULL) && (doc->dict != NULL))
  ------------------
  |  Branch (2149:9): [True: 2, False: 0]
  |  Branch (2149:26): [True: 0, False: 2]
  ------------------
 2150|      0|        cur->name = xmlDictLookup(doc->dict, name, -1);
 2151|      2|    else
 2152|      2|	cur->name = xmlStrdup(name);
 2153|      2|    if (content != NULL) {
  ------------------
  |  Branch (2153:9): [True: 2, False: 0]
  ------------------
 2154|      2|	cur->content = xmlStrdup(content);
 2155|      2|    }
 2156|      2|    cur->doc = doc;
 2157|       |
 2158|      2|    if ((__xmlRegisterCallbacks) && (xmlRegisterNodeDefaultValue))
  ------------------
  |  |  682|      0|    XML_GLOBAL_MACRO(xmlRegisterNodeDefaultValue)
  |  |  ------------------
  |  |  |  |  500|      0|  #define XML_GLOBAL_MACRO(name) (*__##name())
  |  |  ------------------
  ------------------
  |  Branch (2158:9): [True: 0, False: 2]
  |  Branch (2158:37): [True: 0, False: 0]
  ------------------
 2159|      0|	xmlRegisterNodeDefaultValue((xmlNodePtr)cur);
  ------------------
  |  |  682|      0|    XML_GLOBAL_MACRO(xmlRegisterNodeDefaultValue)
  |  |  ------------------
  |  |  |  |  500|      0|  #define XML_GLOBAL_MACRO(name) (*__##name())
  |  |  ------------------
  ------------------
 2160|      2|    return(cur);
 2161|      2|}
xmlNewNodeEatName:
 2232|  13.2k|xmlNewNodeEatName(xmlNsPtr ns, xmlChar *name) {
 2233|  13.2k|    xmlNodePtr cur;
 2234|       |
 2235|  13.2k|    if (name == NULL) {
  ------------------
  |  Branch (2235:9): [True: 6, False: 13.2k]
  ------------------
 2236|      6|	return(NULL);
 2237|      6|    }
 2238|       |
 2239|       |    /*
 2240|       |     * Allocate a new node and fill the fields.
 2241|       |     */
 2242|  13.2k|    cur = (xmlNodePtr) xmlMalloc(sizeof(xmlNode));
 2243|  13.2k|    if (cur == NULL) {
  ------------------
  |  Branch (2243:9): [True: 0, False: 13.2k]
  ------------------
 2244|      0|	xmlTreeErrMemory("building node");
 2245|       |	/* we can't check here that name comes from the doc dictionary */
 2246|      0|	return(NULL);
 2247|      0|    }
 2248|  13.2k|    memset(cur, 0, sizeof(xmlNode));
 2249|  13.2k|    cur->type = XML_ELEMENT_NODE;
 2250|       |
 2251|  13.2k|    cur->name = name;
 2252|  13.2k|    cur->ns = ns;
 2253|       |
 2254|  13.2k|    if ((__xmlRegisterCallbacks) && (xmlRegisterNodeDefaultValue))
  ------------------
  |  |  682|      0|    XML_GLOBAL_MACRO(xmlRegisterNodeDefaultValue)
  |  |  ------------------
  |  |  |  |  500|      0|  #define XML_GLOBAL_MACRO(name) (*__##name())
  |  |  ------------------
  ------------------
  |  Branch (2254:9): [True: 0, False: 13.2k]
  |  Branch (2254:37): [True: 0, False: 0]
  ------------------
 2255|      0|	xmlRegisterNodeDefaultValue((xmlNodePtr)cur);
  ------------------
  |  |  682|      0|    XML_GLOBAL_MACRO(xmlRegisterNodeDefaultValue)
  |  |  ------------------
  |  |  |  |  500|      0|  #define XML_GLOBAL_MACRO(name) (*__##name())
  |  |  ------------------
  ------------------
 2256|  13.2k|    return(cur);
 2257|  13.2k|}
xmlNewDocNodeEatName:
 2314|  13.2k|              xmlChar *name, const xmlChar *content) {
 2315|  13.2k|    xmlNodePtr cur;
 2316|       |
 2317|  13.2k|    cur = xmlNewNodeEatName(ns, name);
 2318|  13.2k|    if (cur != NULL) {
  ------------------
  |  Branch (2318:9): [True: 13.2k, False: 6]
  ------------------
 2319|  13.2k|        cur->doc = doc;
 2320|  13.2k|	if (content != NULL) {
  ------------------
  |  Branch (2320:6): [True: 0, False: 13.2k]
  ------------------
 2321|      0|	    cur->children = xmlStringGetNodeList(doc, content);
 2322|      0|	    UPDATE_LAST_CHILD_AND_PARENT(cur)
  ------------------
  |  |  127|      0|#define UPDATE_LAST_CHILD_AND_PARENT(n) if ((n) != NULL) {		\
  |  |  ------------------
  |  |  |  Branch (127:45): [True: 0, False: 0]
  |  |  ------------------
  |  |  128|      0|    xmlNodePtr ulccur = (n)->children;					\
  |  |  129|      0|    if (ulccur == NULL) {						\
  |  |  ------------------
  |  |  |  Branch (129:9): [True: 0, False: 0]
  |  |  ------------------
  |  |  130|      0|        (n)->last = NULL;						\
  |  |  131|      0|    } else {								\
  |  |  132|      0|        while (ulccur->next != NULL) {					\
  |  |  ------------------
  |  |  |  Branch (132:16): [True: 0, False: 0]
  |  |  ------------------
  |  |  133|      0|		ulccur->parent = (n);					\
  |  |  134|      0|		ulccur = ulccur->next;					\
  |  |  135|      0|	}								\
  |  |  136|      0|	ulccur->parent = (n);						\
  |  |  137|      0|	(n)->last = ulccur;						\
  |  |  138|      0|}}
  ------------------
 2323|      0|	}
 2324|  13.2k|    } else {
 2325|       |        /* if name don't come from the doc dictionary free it here */
 2326|      6|        if ((name != NULL) &&
  ------------------
  |  Branch (2326:13): [True: 0, False: 6]
  ------------------
 2327|      6|            ((doc == NULL) || (doc->dict == NULL) ||
  ------------------
  |  Branch (2327:14): [True: 0, False: 0]
  |  Branch (2327:31): [True: 0, False: 0]
  ------------------
 2328|      0|	     (!(xmlDictOwns(doc->dict, name)))))
  ------------------
  |  Branch (2328:7): [True: 0, False: 0]
  ------------------
 2329|      0|	    xmlFree(name);
 2330|      6|    }
 2331|  13.2k|    return(cur);
 2332|  13.2k|}
xmlNewText:
 2404|  13.6k|xmlNewText(const xmlChar *content) {
 2405|  13.6k|    xmlNodePtr cur;
 2406|       |
 2407|       |    /*
 2408|       |     * Allocate a new node and fill the fields.
 2409|       |     */
 2410|  13.6k|    cur = (xmlNodePtr) xmlMalloc(sizeof(xmlNode));
 2411|  13.6k|    if (cur == NULL) {
  ------------------
  |  Branch (2411:9): [True: 0, False: 13.6k]
  ------------------
 2412|      0|	xmlTreeErrMemory("building text");
 2413|      0|	return(NULL);
 2414|      0|    }
 2415|  13.6k|    memset(cur, 0, sizeof(xmlNode));
 2416|  13.6k|    cur->type = XML_TEXT_NODE;
 2417|       |
 2418|  13.6k|    cur->name = xmlStringText;
 2419|  13.6k|    if (content != NULL) {
  ------------------
  |  Branch (2419:9): [True: 13.6k, False: 0]
  ------------------
 2420|  13.6k|	cur->content = xmlStrdup(content);
 2421|  13.6k|    }
 2422|       |
 2423|  13.6k|    if ((__xmlRegisterCallbacks) && (xmlRegisterNodeDefaultValue))
  ------------------
  |  |  682|      0|    XML_GLOBAL_MACRO(xmlRegisterNodeDefaultValue)
  |  |  ------------------
  |  |  |  |  500|      0|  #define XML_GLOBAL_MACRO(name) (*__##name())
  |  |  ------------------
  ------------------
  |  Branch (2423:9): [True: 0, False: 13.6k]
  |  Branch (2423:37): [True: 0, False: 0]
  ------------------
 2424|      0|	xmlRegisterNodeDefaultValue(cur);
  ------------------
  |  |  682|      0|    XML_GLOBAL_MACRO(xmlRegisterNodeDefaultValue)
  |  |  ------------------
  |  |  |  |  500|      0|  #define XML_GLOBAL_MACRO(name) (*__##name())
  |  |  ------------------
  ------------------
 2425|  13.6k|    return(cur);
 2426|  13.6k|}
xmlNewDocText:
 2610|  13.6k|xmlNewDocText(const xmlDoc *doc, const xmlChar *content) {
 2611|  13.6k|    xmlNodePtr cur;
 2612|       |
 2613|  13.6k|    cur = xmlNewText(content);
 2614|  13.6k|    if (cur != NULL) cur->doc = (xmlDoc *)doc;
  ------------------
  |  Branch (2614:9): [True: 13.6k, False: 0]
  ------------------
 2615|  13.6k|    return(cur);
 2616|  13.6k|}
xmlNewComment:
 2682|    526|xmlNewComment(const xmlChar *content) {
 2683|    526|    xmlNodePtr cur;
 2684|       |
 2685|       |    /*
 2686|       |     * Allocate a new node and fill the fields.
 2687|       |     */
 2688|    526|    cur = (xmlNodePtr) xmlMalloc(sizeof(xmlNode));
 2689|    526|    if (cur == NULL) {
  ------------------
  |  Branch (2689:9): [True: 0, False: 526]
  ------------------
 2690|      0|	xmlTreeErrMemory("building comment");
 2691|      0|	return(NULL);
 2692|      0|    }
 2693|    526|    memset(cur, 0, sizeof(xmlNode));
 2694|    526|    cur->type = XML_COMMENT_NODE;
 2695|       |
 2696|    526|    cur->name = xmlStringComment;
 2697|    526|    if (content != NULL) {
  ------------------
  |  Branch (2697:9): [True: 526, False: 0]
  ------------------
 2698|    526|	cur->content = xmlStrdup(content);
 2699|    526|    }
 2700|       |
 2701|    526|    if ((__xmlRegisterCallbacks) && (xmlRegisterNodeDefaultValue))
  ------------------
  |  |  682|      0|    XML_GLOBAL_MACRO(xmlRegisterNodeDefaultValue)
  |  |  ------------------
  |  |  |  |  500|      0|  #define XML_GLOBAL_MACRO(name) (*__##name())
  |  |  ------------------
  ------------------
  |  Branch (2701:9): [True: 0, False: 526]
  |  Branch (2701:37): [True: 0, False: 0]
  ------------------
 2702|      0|	xmlRegisterNodeDefaultValue(cur);
  ------------------
  |  |  682|      0|    XML_GLOBAL_MACRO(xmlRegisterNodeDefaultValue)
  |  |  ------------------
  |  |  |  |  500|      0|  #define XML_GLOBAL_MACRO(name) (*__##name())
  |  |  ------------------
  ------------------
 2703|    526|    return(cur);
 2704|    526|}
xmlNewCDataBlock:
 2716|     44|xmlNewCDataBlock(xmlDocPtr doc, const xmlChar *content, int len) {
 2717|     44|    xmlNodePtr cur;
 2718|       |
 2719|       |    /*
 2720|       |     * Allocate a new node and fill the fields.
 2721|       |     */
 2722|     44|    cur = (xmlNodePtr) xmlMalloc(sizeof(xmlNode));
 2723|     44|    if (cur == NULL) {
  ------------------
  |  Branch (2723:9): [True: 0, False: 44]
  ------------------
 2724|      0|	xmlTreeErrMemory("building CDATA");
 2725|      0|	return(NULL);
 2726|      0|    }
 2727|     44|    memset(cur, 0, sizeof(xmlNode));
 2728|     44|    cur->type = XML_CDATA_SECTION_NODE;
 2729|     44|    cur->doc = doc;
 2730|       |
 2731|     44|    if (content != NULL) {
  ------------------
  |  Branch (2731:9): [True: 44, False: 0]
  ------------------
 2732|     44|	cur->content = xmlStrndup(content, len);
 2733|     44|    }
 2734|       |
 2735|     44|    if ((__xmlRegisterCallbacks) && (xmlRegisterNodeDefaultValue))
  ------------------
  |  |  682|      0|    XML_GLOBAL_MACRO(xmlRegisterNodeDefaultValue)
  |  |  ------------------
  |  |  |  |  500|      0|  #define XML_GLOBAL_MACRO(name) (*__##name())
  |  |  ------------------
  ------------------
  |  Branch (2735:9): [True: 0, False: 44]
  |  Branch (2735:37): [True: 0, False: 0]
  ------------------
 2736|      0|	xmlRegisterNodeDefaultValue(cur);
  ------------------
  |  |  682|      0|    XML_GLOBAL_MACRO(xmlRegisterNodeDefaultValue)
  |  |  ------------------
  |  |  |  |  500|      0|  #define XML_GLOBAL_MACRO(name) (*__##name())
  |  |  ------------------
  ------------------
 2737|     44|    return(cur);
 2738|     44|}
xmlNewDocComment:
 2749|    526|xmlNewDocComment(xmlDocPtr doc, const xmlChar *content) {
 2750|    526|    xmlNodePtr cur;
 2751|       |
 2752|    526|    cur = xmlNewComment(content);
 2753|    526|    if (cur != NULL) cur->doc = doc;
  ------------------
  |  Branch (2753:9): [True: 526, False: 0]
  ------------------
 2754|    526|    return(cur);
 2755|    526|}
xmlAddChild:
 3279|  18.6k|xmlAddChild(xmlNodePtr parent, xmlNodePtr cur) {
 3280|  18.6k|    xmlNodePtr prev;
 3281|       |
 3282|  18.6k|    if ((parent == NULL) || (parent->type == XML_NAMESPACE_DECL)) {
  ------------------
  |  Branch (3282:9): [True: 0, False: 18.6k]
  |  Branch (3282:29): [True: 0, False: 18.6k]
  ------------------
 3283|      0|	return(NULL);
 3284|      0|    }
 3285|       |
 3286|  18.6k|    if ((cur == NULL) || (cur->type == XML_NAMESPACE_DECL)) {
  ------------------
  |  Branch (3286:9): [True: 0, False: 18.6k]
  |  Branch (3286:26): [True: 0, False: 18.6k]
  ------------------
 3287|      0|	return(NULL);
 3288|      0|    }
 3289|       |
 3290|  18.6k|    if (parent == cur) {
  ------------------
  |  Branch (3290:9): [True: 0, False: 18.6k]
  ------------------
 3291|      0|	return(NULL);
 3292|      0|    }
 3293|       |    /*
 3294|       |     * If cur is a TEXT node, merge its content with adjacent TEXT nodes
 3295|       |     * cur is then freed.
 3296|       |     */
 3297|  18.6k|    if (cur->type == XML_TEXT_NODE) {
  ------------------
  |  Branch (3297:9): [True: 4.83k, False: 13.7k]
  ------------------
 3298|  4.83k|	if ((parent->type == XML_TEXT_NODE) &&
  ------------------
  |  Branch (3298:6): [True: 0, False: 4.83k]
  ------------------
 3299|  4.83k|	    (parent->content != NULL) &&
  ------------------
  |  Branch (3299:6): [True: 0, False: 0]
  ------------------
 3300|  4.83k|	    (parent->name == cur->name)) {
  ------------------
  |  Branch (3300:6): [True: 0, False: 0]
  ------------------
 3301|      0|	    xmlNodeAddContent(parent, cur->content);
 3302|      0|	    xmlFreeNode(cur);
 3303|      0|	    return(parent);
 3304|      0|	}
 3305|  4.83k|	if ((parent->last != NULL) && (parent->last->type == XML_TEXT_NODE) &&
  ------------------
  |  Branch (3305:6): [True: 4.83k, False: 0]
  |  Branch (3305:32): [True: 0, False: 4.83k]
  ------------------
 3306|  4.83k|	    (parent->last->name == cur->name) &&
  ------------------
  |  Branch (3306:6): [True: 0, False: 0]
  ------------------
 3307|  4.83k|	    (parent->last != cur)) {
  ------------------
  |  Branch (3307:6): [True: 0, False: 0]
  ------------------
 3308|      0|	    xmlNodeAddContent(parent->last, cur->content);
 3309|      0|	    xmlFreeNode(cur);
 3310|      0|	    return(parent->last);
 3311|      0|	}
 3312|  4.83k|    }
 3313|       |
 3314|       |    /*
 3315|       |     * add the new element at the end of the children list.
 3316|       |     */
 3317|  18.6k|    prev = cur->parent;
 3318|  18.6k|    cur->parent = parent;
 3319|  18.6k|    if (cur->doc != parent->doc) {
  ------------------
  |  Branch (3319:9): [True: 0, False: 18.6k]
  ------------------
 3320|      0|	xmlSetTreeDoc(cur, parent->doc);
 3321|      0|    }
 3322|       |    /* this check prevents a loop on tree-traversions if a developer
 3323|       |     * tries to add a node to its parent multiple times
 3324|       |     */
 3325|  18.6k|    if (prev == parent)
  ------------------
  |  Branch (3325:9): [True: 0, False: 18.6k]
  ------------------
 3326|      0|	return(cur);
 3327|       |
 3328|       |    /*
 3329|       |     * Coalescing
 3330|       |     */
 3331|  18.6k|    if ((parent->type == XML_TEXT_NODE) &&
  ------------------
  |  Branch (3331:9): [True: 0, False: 18.6k]
  ------------------
 3332|  18.6k|	(parent->content != NULL) &&
  ------------------
  |  Branch (3332:2): [True: 0, False: 0]
  ------------------
 3333|  18.6k|	(parent != cur)) {
  ------------------
  |  Branch (3333:2): [True: 0, False: 0]
  ------------------
 3334|      0|	xmlNodeAddContent(parent, cur->content);
 3335|      0|	xmlFreeNode(cur);
 3336|      0|	return(parent);
 3337|      0|    }
 3338|  18.6k|    if (cur->type == XML_ATTRIBUTE_NODE) {
  ------------------
  |  Branch (3338:9): [True: 0, False: 18.6k]
  ------------------
 3339|      0|		if (parent->type != XML_ELEMENT_NODE)
  ------------------
  |  Branch (3339:7): [True: 0, False: 0]
  ------------------
 3340|      0|			return(NULL);
 3341|      0|	if (parent->properties != NULL) {
  ------------------
  |  Branch (3341:6): [True: 0, False: 0]
  ------------------
 3342|       |	    /* check if an attribute with the same name exists */
 3343|      0|	    xmlAttrPtr lastattr;
 3344|       |
 3345|      0|	    if (cur->ns == NULL)
  ------------------
  |  Branch (3345:10): [True: 0, False: 0]
  ------------------
 3346|      0|		lastattr = xmlHasNsProp(parent, cur->name, NULL);
 3347|      0|	    else
 3348|      0|		lastattr = xmlHasNsProp(parent, cur->name, cur->ns->href);
 3349|      0|	    if ((lastattr != NULL) && (lastattr != (xmlAttrPtr) cur) && (lastattr->type != XML_ATTRIBUTE_DECL)) {
  ------------------
  |  Branch (3349:10): [True: 0, False: 0]
  |  Branch (3349:32): [True: 0, False: 0]
  |  Branch (3349:66): [True: 0, False: 0]
  ------------------
 3350|       |		/* different instance, destroy it (attributes must be unique) */
 3351|      0|			xmlUnlinkNode((xmlNodePtr) lastattr);
 3352|      0|		xmlFreeProp(lastattr);
 3353|      0|	    }
 3354|      0|		if (lastattr == (xmlAttrPtr) cur)
  ------------------
  |  Branch (3354:7): [True: 0, False: 0]
  ------------------
 3355|      0|			return(cur);
 3356|       |
 3357|      0|	}
 3358|      0|	if (parent->properties == NULL) {
  ------------------
  |  Branch (3358:6): [True: 0, False: 0]
  ------------------
 3359|      0|	    parent->properties = (xmlAttrPtr) cur;
 3360|      0|	} else {
 3361|       |	    /* find the end */
 3362|      0|	    xmlAttrPtr lastattr = parent->properties;
 3363|      0|	    while (lastattr->next != NULL) {
  ------------------
  |  Branch (3363:13): [True: 0, False: 0]
  ------------------
 3364|      0|		lastattr = lastattr->next;
 3365|      0|	    }
 3366|      0|	    lastattr->next = (xmlAttrPtr) cur;
 3367|      0|	    ((xmlAttrPtr) cur)->prev = lastattr;
 3368|      0|	}
 3369|  18.6k|    } else {
 3370|  18.6k|	if (parent->children == NULL) {
  ------------------
  |  Branch (3370:6): [True: 3.44k, False: 15.1k]
  ------------------
 3371|  3.44k|	    parent->children = cur;
 3372|  3.44k|	    parent->last = cur;
 3373|  15.1k|	} else {
 3374|  15.1k|	    prev = parent->last;
 3375|  15.1k|	    prev->next = cur;
 3376|  15.1k|	    cur->prev = prev;
 3377|  15.1k|	    parent->last = cur;
 3378|  15.1k|	}
 3379|  18.6k|    }
 3380|  18.6k|    return(cur);
 3381|  18.6k|}
xmlGetLastChild:
 3391|  5.08k|xmlGetLastChild(const xmlNode *parent) {
 3392|  5.08k|    if ((parent == NULL) || (parent->type == XML_NAMESPACE_DECL)) {
  ------------------
  |  Branch (3392:9): [True: 0, False: 5.08k]
  |  Branch (3392:29): [True: 0, False: 5.08k]
  ------------------
 3393|      0|	return(NULL);
 3394|      0|    }
 3395|  5.08k|    return(parent->last);
 3396|  5.08k|}
xmlFreeNodeList:
 3602|  13.8k|xmlFreeNodeList(xmlNodePtr cur) {
 3603|  13.8k|    xmlNodePtr next;
 3604|  13.8k|    xmlNodePtr parent;
 3605|  13.8k|    xmlDictPtr dict = NULL;
 3606|  13.8k|    size_t depth = 0;
 3607|       |
 3608|  13.8k|    if (cur == NULL) return;
  ------------------
  |  Branch (3608:9): [True: 0, False: 13.8k]
  ------------------
 3609|  13.8k|    if (cur->type == XML_NAMESPACE_DECL) {
  ------------------
  |  Branch (3609:9): [True: 0, False: 13.8k]
  ------------------
 3610|      0|	xmlFreeNsList((xmlNsPtr) cur);
 3611|      0|	return;
 3612|      0|    }
 3613|  13.8k|    if (cur->doc != NULL) dict = cur->doc->dict;
  ------------------
  |  Branch (3613:9): [True: 13.8k, False: 0]
  ------------------
 3614|  37.9k|    while (1) {
  ------------------
  |  Branch (3614:12): [Folded - Ignored]
  ------------------
 3615|  46.8k|        while ((cur->children != NULL) &&
  ------------------
  |  Branch (3615:16): [True: 8.90k, False: 37.9k]
  ------------------
 3616|  46.8k|               (cur->type != XML_DOCUMENT_NODE) &&
  ------------------
  |  Branch (3616:16): [True: 8.90k, False: 0]
  ------------------
 3617|  46.8k|               (cur->type != XML_HTML_DOCUMENT_NODE) &&
  ------------------
  |  Branch (3617:16): [True: 8.90k, False: 0]
  ------------------
 3618|  46.8k|               (cur->type != XML_DTD_NODE) &&
  ------------------
  |  Branch (3618:16): [True: 8.90k, False: 0]
  ------------------
 3619|  46.8k|               (cur->type != XML_ENTITY_REF_NODE)) {
  ------------------
  |  Branch (3619:16): [True: 8.90k, False: 0]
  ------------------
 3620|  8.90k|            cur = cur->children;
 3621|  8.90k|            depth += 1;
 3622|  8.90k|        }
 3623|       |
 3624|  37.9k|        next = cur->next;
 3625|  37.9k|        parent = cur->parent;
 3626|  37.9k|	if ((cur->type == XML_DOCUMENT_NODE) ||
  ------------------
  |  Branch (3626:6): [True: 0, False: 37.9k]
  ------------------
 3627|  37.9k|            (cur->type == XML_HTML_DOCUMENT_NODE)) {
  ------------------
  |  Branch (3627:13): [True: 0, False: 37.9k]
  ------------------
 3628|      0|            xmlFreeDoc((xmlDocPtr) cur);
 3629|  37.9k|        } else if (cur->type != XML_DTD_NODE) {
  ------------------
  |  Branch (3629:20): [True: 37.9k, False: 0]
  ------------------
 3630|       |
 3631|  37.9k|	    if ((__xmlRegisterCallbacks) && (xmlDeregisterNodeDefaultValue))
  ------------------
  |  |  684|      0|    XML_GLOBAL_MACRO(xmlDeregisterNodeDefaultValue)
  |  |  ------------------
  |  |  |  |  500|      0|  #define XML_GLOBAL_MACRO(name) (*__##name())
  |  |  ------------------
  ------------------
  |  Branch (3631:10): [True: 0, False: 37.9k]
  |  Branch (3631:38): [True: 0, False: 0]
  ------------------
 3632|      0|		xmlDeregisterNodeDefaultValue(cur);
  ------------------
  |  |  684|      0|    XML_GLOBAL_MACRO(xmlDeregisterNodeDefaultValue)
  |  |  ------------------
  |  |  |  |  500|      0|  #define XML_GLOBAL_MACRO(name) (*__##name())
  |  |  ------------------
  ------------------
 3633|       |
 3634|  37.9k|	    if (((cur->type == XML_ELEMENT_NODE) ||
  ------------------
  |  Branch (3634:11): [True: 13.2k, False: 24.6k]
  ------------------
 3635|  37.9k|		 (cur->type == XML_XINCLUDE_START) ||
  ------------------
  |  Branch (3635:4): [True: 0, False: 24.6k]
  ------------------
 3636|  37.9k|		 (cur->type == XML_XINCLUDE_END)) &&
  ------------------
  |  Branch (3636:4): [True: 0, False: 24.6k]
  ------------------
 3637|  37.9k|		(cur->properties != NULL))
  ------------------
  |  Branch (3637:3): [True: 6.84k, False: 6.41k]
  ------------------
 3638|  6.84k|		xmlFreePropList(cur->properties);
 3639|  37.9k|	    if ((cur->type != XML_ELEMENT_NODE) &&
  ------------------
  |  Branch (3639:10): [True: 24.6k, False: 13.2k]
  ------------------
 3640|  37.9k|		(cur->type != XML_XINCLUDE_START) &&
  ------------------
  |  Branch (3640:3): [True: 24.6k, False: 0]
  ------------------
 3641|  37.9k|		(cur->type != XML_XINCLUDE_END) &&
  ------------------
  |  Branch (3641:3): [True: 24.6k, False: 0]
  ------------------
 3642|  37.9k|		(cur->type != XML_ENTITY_REF_NODE) &&
  ------------------
  |  Branch (3642:3): [True: 24.6k, False: 0]
  ------------------
 3643|  37.9k|		(cur->content != (xmlChar *) &(cur->properties))) {
  ------------------
  |  Branch (3643:3): [True: 24.6k, False: 0]
  ------------------
 3644|  24.6k|		DICT_FREE(cur->content)
  ------------------
  |  | 1025|  24.6k|	if ((str) && ((!dict) ||				\
  |  |  ------------------
  |  |  |  Branch (1025:6): [True: 24.6k, False: 0]
  |  |  |  Branch (1025:16): [True: 24.6k, False: 0]
  |  |  ------------------
  |  | 1026|  24.6k|	    (xmlDictOwns(dict, (const xmlChar *)(str)) == 0)))	\
  |  |  ------------------
  |  |  |  Branch (1026:6): [True: 0, False: 0]
  |  |  ------------------
  |  | 1027|  24.6k|	    xmlFree((char *)(str));
  ------------------
 3645|  24.6k|	    }
 3646|  37.9k|	    if (((cur->type == XML_ELEMENT_NODE) ||
  ------------------
  |  Branch (3646:11): [True: 13.2k, False: 24.6k]
  ------------------
 3647|  37.9k|	         (cur->type == XML_XINCLUDE_START) ||
  ------------------
  |  Branch (3647:11): [True: 0, False: 24.6k]
  ------------------
 3648|  37.9k|		 (cur->type == XML_XINCLUDE_END)) &&
  ------------------
  |  Branch (3648:4): [True: 0, False: 24.6k]
  ------------------
 3649|  37.9k|		(cur->nsDef != NULL))
  ------------------
  |  Branch (3649:3): [True: 0, False: 13.2k]
  ------------------
 3650|      0|		xmlFreeNsList(cur->nsDef);
 3651|       |
 3652|       |	    /*
 3653|       |	     * When a node is a text node or a comment, it uses a global static
 3654|       |	     * variable for the name of the node.
 3655|       |	     * Otherwise the node name might come from the document's
 3656|       |	     * dictionary
 3657|       |	     */
 3658|  37.9k|	    if ((cur->name != NULL) &&
  ------------------
  |  Branch (3658:10): [True: 37.8k, False: 44]
  ------------------
 3659|  37.9k|		(cur->type != XML_TEXT_NODE) &&
  ------------------
  |  Branch (3659:3): [True: 13.7k, False: 24.0k]
  ------------------
 3660|  37.9k|		(cur->type != XML_COMMENT_NODE))
  ------------------
  |  Branch (3660:3): [True: 13.2k, False: 526]
  ------------------
 3661|  13.2k|		DICT_FREE(cur->name)
  ------------------
  |  | 1025|  13.2k|	if ((str) && ((!dict) ||				\
  |  |  ------------------
  |  |  |  Branch (1025:6): [True: 13.2k, False: 0]
  |  |  |  Branch (1025:16): [True: 13.2k, False: 0]
  |  |  ------------------
  |  | 1026|  13.2k|	    (xmlDictOwns(dict, (const xmlChar *)(str)) == 0)))	\
  |  |  ------------------
  |  |  |  Branch (1026:6): [True: 0, False: 0]
  |  |  ------------------
  |  | 1027|  13.2k|	    xmlFree((char *)(str));
  ------------------
 3662|  37.9k|	    xmlFree(cur);
 3663|  37.9k|	}
 3664|       |
 3665|  37.9k|        if (next != NULL) {
  ------------------
  |  Branch (3665:13): [True: 15.1k, False: 22.7k]
  ------------------
 3666|  15.1k|	    cur = next;
 3667|  22.7k|        } else {
 3668|  22.7k|            if ((depth == 0) || (parent == NULL))
  ------------------
  |  Branch (3668:17): [True: 13.8k, False: 8.90k]
  |  Branch (3668:33): [True: 0, False: 8.90k]
  ------------------
 3669|  13.8k|                break;
 3670|  8.90k|            depth -= 1;
 3671|  8.90k|            cur = parent;
 3672|  8.90k|            cur->children = NULL;
 3673|  8.90k|        }
 3674|  37.9k|    }
 3675|  13.8k|}
xmlUnlinkNode:
 3755|    174|xmlUnlinkNode(xmlNodePtr cur) {
 3756|    174|    if (cur == NULL) {
  ------------------
  |  Branch (3756:9): [True: 0, False: 174]
  ------------------
 3757|      0|	return;
 3758|      0|    }
 3759|    174|    if (cur->type == XML_NAMESPACE_DECL)
  ------------------
  |  Branch (3759:9): [True: 0, False: 174]
  ------------------
 3760|      0|        return;
 3761|    174|    if (cur->type == XML_DTD_NODE) {
  ------------------
  |  Branch (3761:9): [True: 174, False: 0]
  ------------------
 3762|    174|	xmlDocPtr doc;
 3763|    174|	doc = cur->doc;
 3764|    174|	if (doc != NULL) {
  ------------------
  |  Branch (3764:6): [True: 174, False: 0]
  ------------------
 3765|    174|	    if (doc->intSubset == (xmlDtdPtr) cur)
  ------------------
  |  Branch (3765:10): [True: 174, False: 0]
  ------------------
 3766|    174|		doc->intSubset = NULL;
 3767|    174|	    if (doc->extSubset == (xmlDtdPtr) cur)
  ------------------
  |  Branch (3767:10): [True: 0, False: 174]
  ------------------
 3768|      0|		doc->extSubset = NULL;
 3769|    174|	}
 3770|    174|    }
 3771|    174|    if (cur->type == XML_ENTITY_DECL) {
  ------------------
  |  Branch (3771:9): [True: 0, False: 174]
  ------------------
 3772|      0|        xmlDocPtr doc;
 3773|      0|	doc = cur->doc;
 3774|      0|	if (doc != NULL) {
  ------------------
  |  Branch (3774:6): [True: 0, False: 0]
  ------------------
 3775|      0|	    if (doc->intSubset != NULL) {
  ------------------
  |  Branch (3775:10): [True: 0, False: 0]
  ------------------
 3776|      0|	        if (xmlHashLookup(doc->intSubset->entities, cur->name) == cur)
  ------------------
  |  Branch (3776:14): [True: 0, False: 0]
  ------------------
 3777|      0|		    xmlHashRemoveEntry(doc->intSubset->entities, cur->name,
 3778|      0|		                       NULL);
 3779|      0|	        if (xmlHashLookup(doc->intSubset->pentities, cur->name) == cur)
  ------------------
  |  Branch (3779:14): [True: 0, False: 0]
  ------------------
 3780|      0|		    xmlHashRemoveEntry(doc->intSubset->pentities, cur->name,
 3781|      0|		                       NULL);
 3782|      0|	    }
 3783|      0|	    if (doc->extSubset != NULL) {
  ------------------
  |  Branch (3783:10): [True: 0, False: 0]
  ------------------
 3784|      0|	        if (xmlHashLookup(doc->extSubset->entities, cur->name) == cur)
  ------------------
  |  Branch (3784:14): [True: 0, False: 0]
  ------------------
 3785|      0|		    xmlHashRemoveEntry(doc->extSubset->entities, cur->name,
 3786|      0|		                       NULL);
 3787|      0|	        if (xmlHashLookup(doc->extSubset->pentities, cur->name) == cur)
  ------------------
  |  Branch (3787:14): [True: 0, False: 0]
  ------------------
 3788|      0|		    xmlHashRemoveEntry(doc->extSubset->pentities, cur->name,
 3789|      0|		                       NULL);
 3790|      0|	    }
 3791|      0|	}
 3792|      0|    }
 3793|    174|    if (cur->parent != NULL) {
  ------------------
  |  Branch (3793:9): [True: 174, False: 0]
  ------------------
 3794|    174|	xmlNodePtr parent;
 3795|    174|	parent = cur->parent;
 3796|    174|	if (cur->type == XML_ATTRIBUTE_NODE) {
  ------------------
  |  Branch (3796:6): [True: 0, False: 174]
  ------------------
 3797|      0|	    if (parent->properties == (xmlAttrPtr) cur)
  ------------------
  |  Branch (3797:10): [True: 0, False: 0]
  ------------------
 3798|      0|		parent->properties = ((xmlAttrPtr) cur)->next;
 3799|    174|	} else {
 3800|    174|	    if (parent->children == cur)
  ------------------
  |  Branch (3800:10): [True: 174, False: 0]
  ------------------
 3801|    174|		parent->children = cur->next;
 3802|    174|	    if (parent->last == cur)
  ------------------
  |  Branch (3802:10): [True: 7, False: 167]
  ------------------
 3803|      7|		parent->last = cur->prev;
 3804|    174|	}
 3805|    174|	cur->parent = NULL;
 3806|    174|    }
 3807|    174|    if (cur->next != NULL)
  ------------------
  |  Branch (3807:9): [True: 167, False: 7]
  ------------------
 3808|    167|        cur->next->prev = cur->prev;
 3809|    174|    if (cur->prev != NULL)
  ------------------
  |  Branch (3809:9): [True: 0, False: 174]
  ------------------
 3810|      0|        cur->prev->next = cur->next;
 3811|    174|    cur->next = cur->prev = NULL;
 3812|    174|}
xmlGetLineNo:
 4629|    210|{
 4630|    210|    return(xmlGetLineNoInternal(node, 0));
 4631|    210|}
xmlNodeIsText:
 6869|  3.49k|xmlNodeIsText(const xmlNode *node) {
 6870|  3.49k|    if (node == NULL) return(0);
  ------------------
  |  Branch (6870:9): [True: 0, False: 3.49k]
  ------------------
 6871|       |
 6872|  3.49k|    if (node->type == XML_TEXT_NODE) return(1);
  ------------------
  |  Branch (6872:9): [True: 432, False: 3.06k]
  ------------------
 6873|  3.06k|    return(0);
 6874|  3.49k|}
tree.c:xmlTreeErrMemory:
   76|      1|{
   77|      1|    __xmlSimpleError(XML_FROM_TREE, XML_ERR_NO_MEMORY, NULL, NULL, extra);
   78|      1|}
tree.c:xmlNewPropInternal:
 1836|  13.7k|{
 1837|  13.7k|    xmlAttrPtr cur;
 1838|  13.7k|    xmlDocPtr doc = NULL;
 1839|       |
 1840|  13.7k|    if ((node != NULL) && (node->type != XML_ELEMENT_NODE)) {
  ------------------
  |  Branch (1840:9): [True: 13.7k, False: 0]
  |  Branch (1840:27): [True: 0, False: 13.7k]
  ------------------
 1841|      0|        if ((eatname == 1) &&
  ------------------
  |  Branch (1841:13): [True: 0, False: 0]
  ------------------
 1842|      0|	    ((node->doc == NULL) || (node->doc->dict == NULL) ||
  ------------------
  |  Branch (1842:7): [True: 0, False: 0]
  |  Branch (1842:30): [True: 0, False: 0]
  ------------------
 1843|      0|	     (!(xmlDictOwns(node->doc->dict, name)))))
  ------------------
  |  Branch (1843:7): [True: 0, False: 0]
  ------------------
 1844|      0|            xmlFree((xmlChar *) name);
 1845|      0|        return (NULL);
 1846|      0|    }
 1847|       |
 1848|       |    /*
 1849|       |     * Allocate a new property and fill the fields.
 1850|       |     */
 1851|  13.7k|    cur = (xmlAttrPtr) xmlMalloc(sizeof(xmlAttr));
 1852|  13.7k|    if (cur == NULL) {
  ------------------
  |  Branch (1852:9): [True: 0, False: 13.7k]
  ------------------
 1853|      0|        if ((eatname == 1) &&
  ------------------
  |  Branch (1853:13): [True: 0, False: 0]
  ------------------
 1854|      0|	    ((node == NULL) || (node->doc == NULL) ||
  ------------------
  |  Branch (1854:7): [True: 0, False: 0]
  |  Branch (1854:25): [True: 0, False: 0]
  ------------------
 1855|      0|             (node->doc->dict == NULL) ||
  ------------------
  |  Branch (1855:14): [True: 0, False: 0]
  ------------------
 1856|      0|	     (!(xmlDictOwns(node->doc->dict, name)))))
  ------------------
  |  Branch (1856:7): [True: 0, False: 0]
  ------------------
 1857|      0|            xmlFree((xmlChar *) name);
 1858|      0|        xmlTreeErrMemory("building attribute");
 1859|      0|        return (NULL);
 1860|      0|    }
 1861|  13.7k|    memset(cur, 0, sizeof(xmlAttr));
 1862|  13.7k|    cur->type = XML_ATTRIBUTE_NODE;
 1863|       |
 1864|  13.7k|    cur->parent = node;
 1865|  13.7k|    if (node != NULL) {
  ------------------
  |  Branch (1865:9): [True: 13.7k, False: 0]
  ------------------
 1866|  13.7k|        doc = node->doc;
 1867|  13.7k|        cur->doc = doc;
 1868|  13.7k|    }
 1869|  13.7k|    cur->ns = ns;
 1870|       |
 1871|  13.7k|    if (eatname == 0) {
  ------------------
  |  Branch (1871:9): [True: 0, False: 13.7k]
  ------------------
 1872|      0|        if ((doc != NULL) && (doc->dict != NULL))
  ------------------
  |  Branch (1872:13): [True: 0, False: 0]
  |  Branch (1872:30): [True: 0, False: 0]
  ------------------
 1873|      0|            cur->name = (xmlChar *) xmlDictLookup(doc->dict, name, -1);
 1874|      0|        else
 1875|      0|            cur->name = xmlStrdup(name);
 1876|      0|    } else
 1877|  13.7k|        cur->name = name;
 1878|       |
 1879|  13.7k|    if (value != NULL) {
  ------------------
  |  Branch (1879:9): [True: 0, False: 13.7k]
  ------------------
 1880|      0|        xmlNodePtr tmp;
 1881|       |
 1882|      0|        cur->children = xmlNewDocText(doc, value);
 1883|      0|        cur->last = NULL;
 1884|      0|        tmp = cur->children;
 1885|      0|        while (tmp != NULL) {
  ------------------
  |  Branch (1885:16): [True: 0, False: 0]
  ------------------
 1886|      0|            tmp->parent = (xmlNodePtr) cur;
 1887|      0|            if (tmp->next == NULL)
  ------------------
  |  Branch (1887:17): [True: 0, False: 0]
  ------------------
 1888|      0|                cur->last = tmp;
 1889|      0|            tmp = tmp->next;
 1890|      0|        }
 1891|      0|    }
 1892|       |
 1893|       |    /*
 1894|       |     * Add it at the end to preserve parsing order ...
 1895|       |     */
 1896|  13.7k|    if (node != NULL) {
  ------------------
  |  Branch (1896:9): [True: 13.7k, False: 0]
  ------------------
 1897|  13.7k|        if (node->properties == NULL) {
  ------------------
  |  Branch (1897:13): [True: 6.84k, False: 6.85k]
  ------------------
 1898|  6.84k|            node->properties = cur;
 1899|  6.85k|        } else {
 1900|  6.85k|            xmlAttrPtr prev = node->properties;
 1901|       |
 1902|  11.8k|            while (prev->next != NULL)
  ------------------
  |  Branch (1902:20): [True: 4.97k, False: 6.85k]
  ------------------
 1903|  4.97k|                prev = prev->next;
 1904|  6.85k|            prev->next = cur;
 1905|  6.85k|            cur->prev = prev;
 1906|  6.85k|        }
 1907|  13.7k|    }
 1908|       |
 1909|  13.7k|    if ((value != NULL) && (node != NULL) &&
  ------------------
  |  Branch (1909:9): [True: 0, False: 13.7k]
  |  Branch (1909:28): [True: 0, False: 0]
  ------------------
 1910|  13.7k|        (xmlIsID(node->doc, node, cur) == 1))
  ------------------
  |  Branch (1910:9): [True: 0, False: 0]
  ------------------
 1911|      0|        xmlAddID(NULL, node->doc, value, cur);
 1912|       |
 1913|  13.7k|    if ((__xmlRegisterCallbacks) && (xmlRegisterNodeDefaultValue))
  ------------------
  |  |  682|      0|    XML_GLOBAL_MACRO(xmlRegisterNodeDefaultValue)
  |  |  ------------------
  |  |  |  |  500|      0|  #define XML_GLOBAL_MACRO(name) (*__##name())
  |  |  ------------------
  ------------------
  |  Branch (1913:9): [True: 0, False: 13.7k]
  |  Branch (1913:37): [True: 0, False: 0]
  ------------------
 1914|      0|        xmlRegisterNodeDefaultValue((xmlNodePtr) cur);
  ------------------
  |  |  682|      0|    XML_GLOBAL_MACRO(xmlRegisterNodeDefaultValue)
  |  |  ------------------
  |  |  |  |  500|      0|  #define XML_GLOBAL_MACRO(name) (*__##name())
  |  |  ------------------
  ------------------
 1915|  13.7k|    return (cur);
 1916|  13.7k|}
tree.c:xmlGetLineNoInternal:
 4579|    210|{
 4580|    210|    long result = -1;
 4581|       |
 4582|    210|    if (depth >= 5)
  ------------------
  |  Branch (4582:9): [True: 0, False: 210]
  ------------------
 4583|      0|        return(-1);
 4584|       |
 4585|    210|    if (!node)
  ------------------
  |  Branch (4585:9): [True: 0, False: 210]
  ------------------
 4586|      0|        return result;
 4587|    210|    if ((node->type == XML_ELEMENT_NODE) ||
  ------------------
  |  Branch (4587:9): [True: 210, False: 0]
  ------------------
 4588|    210|        (node->type == XML_TEXT_NODE) ||
  ------------------
  |  Branch (4588:9): [True: 0, False: 0]
  ------------------
 4589|    210|	(node->type == XML_COMMENT_NODE) ||
  ------------------
  |  Branch (4589:2): [True: 0, False: 0]
  ------------------
 4590|    210|	(node->type == XML_PI_NODE)) {
  ------------------
  |  Branch (4590:2): [True: 0, False: 0]
  ------------------
 4591|    210|	if (node->line == 65535) {
  ------------------
  |  Branch (4591:6): [True: 0, False: 210]
  ------------------
 4592|      0|	    if ((node->type == XML_TEXT_NODE) && (node->psvi != NULL))
  ------------------
  |  Branch (4592:10): [True: 0, False: 0]
  |  Branch (4592:43): [True: 0, False: 0]
  ------------------
 4593|      0|	        result = (long) (ptrdiff_t) node->psvi;
 4594|      0|	    else if ((node->type == XML_ELEMENT_NODE) &&
  ------------------
  |  Branch (4594:15): [True: 0, False: 0]
  ------------------
 4595|      0|	             (node->children != NULL))
  ------------------
  |  Branch (4595:15): [True: 0, False: 0]
  ------------------
 4596|      0|	        result = xmlGetLineNoInternal(node->children, depth + 1);
 4597|      0|	    else if (node->next != NULL)
  ------------------
  |  Branch (4597:15): [True: 0, False: 0]
  ------------------
 4598|      0|	        result = xmlGetLineNoInternal(node->next, depth + 1);
 4599|      0|	    else if (node->prev != NULL)
  ------------------
  |  Branch (4599:15): [True: 0, False: 0]
  ------------------
 4600|      0|	        result = xmlGetLineNoInternal(node->prev, depth + 1);
 4601|      0|	}
 4602|    210|	if ((result == -1) || (result == 65535))
  ------------------
  |  Branch (4602:6): [True: 210, False: 0]
  |  Branch (4602:24): [True: 0, False: 0]
  ------------------
 4603|    210|	    result = (long) node->line;
 4604|    210|    } else if ((node->prev != NULL) &&
  ------------------
  |  Branch (4604:16): [True: 0, False: 0]
  ------------------
 4605|      0|             ((node->prev->type == XML_ELEMENT_NODE) ||
  ------------------
  |  Branch (4605:15): [True: 0, False: 0]
  ------------------
 4606|      0|	      (node->prev->type == XML_TEXT_NODE) ||
  ------------------
  |  Branch (4606:8): [True: 0, False: 0]
  ------------------
 4607|      0|	      (node->prev->type == XML_COMMENT_NODE) ||
  ------------------
  |  Branch (4607:8): [True: 0, False: 0]
  ------------------
 4608|      0|	      (node->prev->type == XML_PI_NODE)))
  ------------------
  |  Branch (4608:8): [True: 0, False: 0]
  ------------------
 4609|      0|        result = xmlGetLineNoInternal(node->prev, depth + 1);
 4610|      0|    else if ((node->parent != NULL) &&
  ------------------
  |  Branch (4610:14): [True: 0, False: 0]
  ------------------
 4611|      0|             (node->parent->type == XML_ELEMENT_NODE))
  ------------------
  |  Branch (4611:14): [True: 0, False: 0]
  ------------------
 4612|      0|        result = xmlGetLineNoInternal(node->parent, depth + 1);
 4613|       |
 4614|    210|    return result;
 4615|    210|}

xmlURIEscapeStr:
 1689|  1.33k|xmlURIEscapeStr(const xmlChar *str, const xmlChar *list) {
 1690|  1.33k|    xmlChar *ret, ch;
 1691|  1.33k|    xmlChar *temp;
 1692|  1.33k|    const xmlChar *in;
 1693|  1.33k|    int len, out;
 1694|       |
 1695|  1.33k|    if (str == NULL)
  ------------------
  |  Branch (1695:9): [True: 0, False: 1.33k]
  ------------------
 1696|      0|	return(NULL);
 1697|  1.33k|    if (str[0] == 0)
  ------------------
  |  Branch (1697:9): [True: 1, False: 1.33k]
  ------------------
 1698|      1|	return(xmlStrdup(str));
 1699|  1.33k|    len = xmlStrlen(str);
 1700|  1.33k|    if (!(len > 0)) return(NULL);
  ------------------
  |  Branch (1700:9): [True: 0, False: 1.33k]
  ------------------
 1701|       |
 1702|  1.33k|    len += 20;
 1703|  1.33k|    ret = (xmlChar *) xmlMallocAtomic(len);
 1704|  1.33k|    if (ret == NULL) {
  ------------------
  |  Branch (1704:9): [True: 0, False: 1.33k]
  ------------------
 1705|      0|        xmlURIErrMemory("escaping URI value\n");
 1706|      0|	return(NULL);
 1707|      0|    }
 1708|  1.33k|    in = (const xmlChar *) str;
 1709|  1.33k|    out = 0;
 1710|  54.0k|    while(*in != 0) {
  ------------------
  |  Branch (1710:11): [True: 52.6k, False: 1.33k]
  ------------------
 1711|  52.6k|	if (len - out <= 3) {
  ------------------
  |  Branch (1711:6): [True: 1, False: 52.6k]
  ------------------
 1712|      1|            temp = xmlSaveUriRealloc(ret, &len);
 1713|      1|	    if (temp == NULL) {
  ------------------
  |  Branch (1713:10): [True: 0, False: 1]
  ------------------
 1714|      0|                xmlURIErrMemory("escaping URI value\n");
 1715|      0|		xmlFree(ret);
 1716|      0|		return(NULL);
 1717|      0|	    }
 1718|      1|	    ret = temp;
 1719|      1|	}
 1720|       |
 1721|  52.6k|	ch = *in;
 1722|       |
 1723|  52.6k|	if ((ch != '@') && (!IS_UNRESERVED(ch)) && (!xmlStrchr(list, ch))) {
  ------------------
  |  |  125|  52.6k|#define IS_UNRESERVED(x) (IS_ALPHANUM(x) || IS_MARK(x))
  |  |  ------------------
  |  |  |  |   93|   105k|#define IS_ALPHANUM(x) (IS_ALPHA(x) || IS_DIGIT(x))
  |  |  |  |  ------------------
  |  |  |  |  |  |   63|   105k|#define IS_ALPHA(x) (IS_LOWALPHA(x) || IS_UPALPHA(x))
  |  |  |  |  |  |  ------------------
  |  |  |  |  |  |  |  |   72|   105k|#define IS_LOWALPHA(x) (((x) >= 'a') && ((x) <= 'z'))
  |  |  |  |  |  |  |  |  ------------------
  |  |  |  |  |  |  |  |  |  Branch (72:25): [True: 35.6k, False: 16.9k]
  |  |  |  |  |  |  |  |  |  Branch (72:41): [True: 35.6k, False: 6]
  |  |  |  |  |  |  |  |  ------------------
  |  |  |  |  |  |  ------------------
  |  |  |  |  |  |               #define IS_ALPHA(x) (IS_LOWALPHA(x) || IS_UPALPHA(x))
  |  |  |  |  |  |  ------------------
  |  |  |  |  |  |  |  |   79|  16.9k|#define IS_UPALPHA(x) (((x) >= 'A') && ((x) <= 'Z'))
  |  |  |  |  |  |  |  |  ------------------
  |  |  |  |  |  |  |  |  |  Branch (79:24): [True: 1.58k, False: 15.3k]
  |  |  |  |  |  |  |  |  |  Branch (79:40): [True: 1.06k, False: 515]
  |  |  |  |  |  |  |  |  ------------------
  |  |  |  |  |  |  ------------------
  |  |  |  |  ------------------
  |  |  |  |               #define IS_ALPHANUM(x) (IS_ALPHA(x) || IS_DIGIT(x))
  |  |  |  |  ------------------
  |  |  |  |  |  |   87|  15.9k|#define IS_DIGIT(x) (((x) >= '0') && ((x) <= '9'))
  |  |  |  |  |  |  ------------------
  |  |  |  |  |  |  |  Branch (87:22): [True: 7.82k, False: 8.08k]
  |  |  |  |  |  |  |  Branch (87:38): [True: 6.05k, False: 1.77k]
  |  |  |  |  |  |  ------------------
  |  |  |  |  ------------------
  |  |  ------------------
  |  |               #define IS_UNRESERVED(x) (IS_ALPHANUM(x) || IS_MARK(x))
  |  |  ------------------
  |  |  |  |   99|  9.85k|#define IS_MARK(x) (((x) == '-') || ((x) == '_') || ((x) == '.') ||     \
  |  |  |  |  ------------------
  |  |  |  |  |  Branch (99:21): [True: 90, False: 9.76k]
  |  |  |  |  |  Branch (99:37): [True: 506, False: 9.25k]
  |  |  |  |  |  Branch (99:53): [True: 2.85k, False: 6.40k]
  |  |  |  |  ------------------
  |  |  |  |  100|  9.85k|    ((x) == '!') || ((x) == '~') || ((x) == '*') || ((x) == '\'') ||    \
  |  |  |  |  ------------------
  |  |  |  |  |  Branch (100:5): [True: 0, False: 6.40k]
  |  |  |  |  |  Branch (100:21): [True: 0, False: 6.40k]
  |  |  |  |  |  Branch (100:37): [True: 0, False: 6.40k]
  |  |  |  |  |  Branch (100:53): [True: 6, False: 6.40k]
  |  |  |  |  ------------------
  |  |  |  |  101|  9.85k|    ((x) == '(') || ((x) == ')'))
  |  |  |  |  ------------------
  |  |  |  |  |  Branch (101:5): [True: 3, False: 6.39k]
  |  |  |  |  |  Branch (101:21): [True: 3, False: 6.39k]
  |  |  |  |  ------------------
  |  |  ------------------
  ------------------
  |  Branch (1723:6): [True: 52.6k, False: 93]
  |  Branch (1723:45): [True: 65, False: 6.32k]
  ------------------
 1724|     65|	    unsigned char val;
 1725|     65|	    ret[out++] = '%';
 1726|     65|	    val = ch >> 4;
 1727|     65|	    if (val <= 9)
  ------------------
  |  Branch (1727:10): [True: 65, False: 0]
  ------------------
 1728|     65|		ret[out++] = '0' + val;
 1729|      0|	    else
 1730|      0|		ret[out++] = 'A' + val - 0xA;
 1731|     65|	    val = ch & 0xF;
 1732|     65|	    if (val <= 9)
  ------------------
  |  Branch (1732:10): [True: 55, False: 10]
  ------------------
 1733|     55|		ret[out++] = '0' + val;
 1734|     10|	    else
 1735|     10|		ret[out++] = 'A' + val - 0xA;
 1736|     65|	    in++;
 1737|  52.6k|	} else {
 1738|  52.6k|	    ret[out++] = *in++;
 1739|  52.6k|	}
 1740|       |
 1741|  52.6k|    }
 1742|  1.33k|    ret[out] = 0;
 1743|  1.33k|    return(ret);
 1744|  1.33k|}
uri.c:xmlSaveUriRealloc:
 1047|      1|xmlSaveUriRealloc(xmlChar *ret, int *max) {
 1048|      1|    xmlChar *temp;
 1049|      1|    int tmp;
 1050|       |
 1051|      1|    if (*max > MAX_URI_LENGTH) {
  ------------------
  |  |   35|      1|#define MAX_URI_LENGTH 1024 * 1024
  ------------------
  |  Branch (1051:9): [True: 0, False: 1]
  ------------------
 1052|      0|        xmlURIErrMemory("reaching arbitrary MAX_URI_LENGTH limit\n");
 1053|      0|        return(NULL);
 1054|      0|    }
 1055|      1|    tmp = *max * 2;
 1056|      1|    temp = (xmlChar *) xmlRealloc(ret, (tmp + 1));
 1057|      1|    if (temp == NULL) {
  ------------------
  |  Branch (1057:9): [True: 0, False: 1]
  ------------------
 1058|      0|        xmlURIErrMemory("saving URI\n");
 1059|      0|        return(NULL);
 1060|      0|    }
 1061|      1|    *max = tmp;
 1062|      1|    return(temp);
 1063|      1|}

xmlAddID:
 2518|    210|         xmlAttrPtr attr) {
 2519|    210|    xmlIDPtr ret;
 2520|    210|    xmlIDTablePtr table;
 2521|       |
 2522|    210|    if (doc == NULL) {
  ------------------
  |  Branch (2522:9): [True: 0, False: 210]
  ------------------
 2523|      0|	return(NULL);
 2524|      0|    }
 2525|    210|    if ((value == NULL) || (value[0] == 0)) {
  ------------------
  |  Branch (2525:9): [True: 0, False: 210]
  |  Branch (2525:28): [True: 0, False: 210]
  ------------------
 2526|      0|	return(NULL);
 2527|      0|    }
 2528|    210|    if (attr == NULL) {
  ------------------
  |  Branch (2528:9): [True: 0, False: 210]
  ------------------
 2529|      0|	return(NULL);
 2530|      0|    }
 2531|       |
 2532|       |    /*
 2533|       |     * Create the ID table if needed.
 2534|       |     */
 2535|    210|    table = (xmlIDTablePtr) doc->ids;
 2536|    210|    if (table == NULL)  {
  ------------------
  |  Branch (2536:9): [True: 38, False: 172]
  ------------------
 2537|     38|        doc->ids = table = xmlHashCreateDict(0, doc->dict);
 2538|     38|    }
 2539|    210|    if (table == NULL) {
  ------------------
  |  Branch (2539:9): [True: 0, False: 210]
  ------------------
 2540|      0|	xmlVErrMemory(ctxt,
 2541|      0|		"xmlAddID: Table creation failed!\n");
 2542|      0|        return(NULL);
 2543|      0|    }
 2544|       |
 2545|    210|    ret = (xmlIDPtr) xmlMalloc(sizeof(xmlID));
 2546|    210|    if (ret == NULL) {
  ------------------
  |  Branch (2546:9): [True: 0, False: 210]
  ------------------
 2547|      0|	xmlVErrMemory(ctxt, "malloc failed");
 2548|      0|	return(NULL);
 2549|      0|    }
 2550|       |
 2551|       |    /*
 2552|       |     * fill the structure.
 2553|       |     */
 2554|    210|    ret->value = xmlStrdup(value);
 2555|    210|    ret->doc = doc;
 2556|    210|    if (xmlIsStreaming(ctxt)) {
  ------------------
  |  Branch (2556:9): [True: 0, False: 210]
  ------------------
 2557|       |	/*
 2558|       |	 * Operating in streaming mode, attr is gonna disappear
 2559|       |	 */
 2560|      0|	if (doc->dict != NULL)
  ------------------
  |  Branch (2560:6): [True: 0, False: 0]
  ------------------
 2561|      0|	    ret->name = xmlDictLookup(doc->dict, attr->name, -1);
 2562|      0|	else
 2563|      0|	    ret->name = xmlStrdup(attr->name);
 2564|      0|	ret->attr = NULL;
 2565|    210|    } else {
 2566|    210|	ret->attr = attr;
 2567|    210|	ret->name = NULL;
 2568|    210|    }
 2569|    210|    ret->lineno = xmlGetLineNo(attr->parent);
 2570|       |
 2571|    210|    if (xmlHashAddEntry(table, value, ret) < 0) {
  ------------------
  |  Branch (2571:9): [True: 2, False: 208]
  ------------------
 2572|      2|#ifdef LIBXML_VALID_ENABLED
 2573|       |	/*
 2574|       |	 * The id is already defined in this DTD.
 2575|       |	 */
 2576|      2|	if (ctxt != NULL) {
  ------------------
  |  Branch (2576:6): [True: 2, False: 0]
  ------------------
 2577|      2|	    xmlErrValidNode(ctxt, attr->parent, XML_DTD_ID_REDEFINED,
 2578|      2|			    "ID %s already defined\n", value, NULL, NULL);
 2579|      2|	}
 2580|      2|#endif /* LIBXML_VALID_ENABLED */
 2581|      2|	xmlFreeID(ret);
 2582|      2|	return(NULL);
 2583|      2|    }
 2584|    208|    if (attr != NULL)
  ------------------
  |  Branch (2584:9): [True: 208, False: 0]
  ------------------
 2585|    208|	attr->atype = XML_ATTRIBUTE_ID;
 2586|    208|    return(ret);
 2587|    210|}
xmlFreeIDTable:
 2601|     38|xmlFreeIDTable(xmlIDTablePtr table) {
 2602|     38|    xmlHashFree(table, xmlFreeIDTableEntry);
 2603|     38|}
xmlIsID:
 2619|  13.6k|xmlIsID(xmlDocPtr doc, xmlNodePtr elem, xmlAttrPtr attr) {
 2620|  13.6k|    if ((attr == NULL) || (attr->name == NULL)) return(0);
  ------------------
  |  Branch (2620:9): [True: 0, False: 13.6k]
  |  Branch (2620:27): [True: 0, False: 13.6k]
  ------------------
 2621|  13.6k|    if ((attr->ns != NULL) && (attr->ns->prefix != NULL) &&
  ------------------
  |  Branch (2621:9): [True: 0, False: 13.6k]
  |  Branch (2621:31): [True: 0, False: 0]
  ------------------
 2622|  13.6k|        (!strcmp((char *) attr->name, "id")) &&
  ------------------
  |  Branch (2622:9): [True: 0, False: 0]
  ------------------
 2623|  13.6k|        (!strcmp((char *) attr->ns->prefix, "xml")))
  ------------------
  |  Branch (2623:9): [True: 0, False: 0]
  ------------------
 2624|      0|	return(1);
 2625|  13.6k|    if (doc == NULL) return(0);
  ------------------
  |  Branch (2625:9): [True: 0, False: 13.6k]
  ------------------
 2626|  13.6k|    if ((doc->intSubset == NULL) && (doc->extSubset == NULL) &&
  ------------------
  |  Branch (2626:9): [True: 7.20k, False: 6.49k]
  |  Branch (2626:37): [True: 7.20k, False: 0]
  ------------------
 2627|  13.6k|        (doc->type != XML_HTML_DOCUMENT_NODE)) {
  ------------------
  |  Branch (2627:9): [True: 0, False: 7.20k]
  ------------------
 2628|      0|	return(0);
 2629|  13.6k|    } else if (doc->type == XML_HTML_DOCUMENT_NODE) {
  ------------------
  |  Branch (2629:16): [True: 13.6k, False: 0]
  ------------------
 2630|  13.6k|        if ((xmlStrEqual(BAD_CAST "id", attr->name)) ||
  ------------------
  |  |   35|  13.6k|#define BAD_CAST (xmlChar *)
  ------------------
  |  Branch (2630:13): [True: 32, False: 13.6k]
  ------------------
 2631|  13.6k|	    ((xmlStrEqual(BAD_CAST "name", attr->name)) &&
  ------------------
  |  |   35|  13.6k|#define BAD_CAST (xmlChar *)
  ------------------
  |  Branch (2631:7): [True: 439, False: 13.2k]
  ------------------
 2632|  13.6k|	    ((elem == NULL) || (xmlStrEqual(elem->name, BAD_CAST "a")))))
  ------------------
  |  |   35|    439|#define BAD_CAST (xmlChar *)
  ------------------
  |  Branch (2632:7): [True: 0, False: 439]
  |  Branch (2632:25): [True: 178, False: 261]
  ------------------
 2633|    210|	    return(1);
 2634|  13.4k|	return(0);
 2635|  13.6k|    } else if (elem == NULL) {
  ------------------
  |  Branch (2635:16): [True: 0, False: 0]
  ------------------
 2636|      0|	return(0);
 2637|      0|    } else {
 2638|      0|	xmlAttributePtr attrDecl = NULL;
 2639|       |
 2640|      0|	xmlChar felem[50], fattr[50];
 2641|      0|	xmlChar *fullelemname, *fullattrname;
 2642|       |
 2643|      0|	fullelemname = (elem->ns != NULL && elem->ns->prefix != NULL) ?
  ------------------
  |  Branch (2643:18): [True: 0, False: 0]
  |  Branch (2643:38): [True: 0, False: 0]
  ------------------
 2644|      0|	    xmlBuildQName(elem->name, elem->ns->prefix, felem, 50) :
 2645|      0|	    (xmlChar *)elem->name;
 2646|       |
 2647|      0|	fullattrname = (attr->ns != NULL && attr->ns->prefix != NULL) ?
  ------------------
  |  Branch (2647:18): [True: 0, False: 0]
  |  Branch (2647:38): [True: 0, False: 0]
  ------------------
 2648|      0|	    xmlBuildQName(attr->name, attr->ns->prefix, fattr, 50) :
 2649|      0|	    (xmlChar *)attr->name;
 2650|       |
 2651|      0|	if (fullelemname != NULL && fullattrname != NULL) {
  ------------------
  |  Branch (2651:6): [True: 0, False: 0]
  |  Branch (2651:30): [True: 0, False: 0]
  ------------------
 2652|      0|	    attrDecl = xmlGetDtdAttrDesc(doc->intSubset, fullelemname,
 2653|      0|		                         fullattrname);
 2654|      0|	    if ((attrDecl == NULL) && (doc->extSubset != NULL))
  ------------------
  |  Branch (2654:10): [True: 0, False: 0]
  |  Branch (2654:32): [True: 0, False: 0]
  ------------------
 2655|      0|		attrDecl = xmlGetDtdAttrDesc(doc->extSubset, fullelemname,
 2656|      0|					     fullattrname);
 2657|      0|	}
 2658|       |
 2659|      0|	if ((fullattrname != fattr) && (fullattrname != attr->name))
  ------------------
  |  Branch (2659:6): [True: 0, False: 0]
  |  Branch (2659:33): [True: 0, False: 0]
  ------------------
 2660|      0|	    xmlFree(fullattrname);
 2661|      0|	if ((fullelemname != felem) && (fullelemname != elem->name))
  ------------------
  |  Branch (2661:6): [True: 0, False: 0]
  |  Branch (2661:33): [True: 0, False: 0]
  ------------------
 2662|      0|	    xmlFree(fullelemname);
 2663|       |
 2664|      0|        if ((attrDecl != NULL) && (attrDecl->atype == XML_ATTRIBUTE_ID))
  ------------------
  |  Branch (2664:13): [True: 0, False: 0]
  |  Branch (2664:35): [True: 0, False: 0]
  ------------------
 2665|      0|	    return(1);
 2666|      0|    }
 2667|      0|    return(0);
 2668|  13.6k|}
xmlRemoveID:
 2680|    208|xmlRemoveID(xmlDocPtr doc, xmlAttrPtr attr) {
 2681|    208|    xmlIDTablePtr table;
 2682|    208|    xmlIDPtr id;
 2683|    208|    xmlChar *ID;
 2684|       |
 2685|    208|    if (doc == NULL) return(-1);
  ------------------
  |  Branch (2685:9): [True: 0, False: 208]
  ------------------
 2686|    208|    if (attr == NULL) return(-1);
  ------------------
  |  Branch (2686:9): [True: 0, False: 208]
  ------------------
 2687|       |
 2688|    208|    table = (xmlIDTablePtr) doc->ids;
 2689|    208|    if (table == NULL)
  ------------------
  |  Branch (2689:9): [True: 208, False: 0]
  ------------------
 2690|    208|        return(-1);
 2691|       |
 2692|      0|    ID = xmlNodeListGetString(doc, attr->children, 1);
 2693|      0|    if (ID == NULL)
  ------------------
  |  Branch (2693:9): [True: 0, False: 0]
  ------------------
 2694|      0|        return(-1);
 2695|      0|    xmlValidNormalizeString(ID);
 2696|       |
 2697|      0|    id = xmlHashLookup(table, ID);
 2698|      0|    if (id == NULL || id->attr != attr) {
  ------------------
  |  Branch (2698:9): [True: 0, False: 0]
  |  Branch (2698:23): [True: 0, False: 0]
  ------------------
 2699|      0|        xmlFree(ID);
 2700|      0|        return(-1);
 2701|      0|    }
 2702|       |
 2703|      0|    xmlHashRemoveEntry(table, ID, xmlFreeIDTableEntry);
 2704|      0|    xmlFree(ID);
 2705|      0|    attr->atype = 0;
 2706|      0|    return(0);
 2707|      0|}
xmlIsRef:
 2967|  13.4k|xmlIsRef(xmlDocPtr doc, xmlNodePtr elem, xmlAttrPtr attr) {
 2968|  13.4k|    if (attr == NULL)
  ------------------
  |  Branch (2968:9): [True: 0, False: 13.4k]
  ------------------
 2969|      0|        return(0);
 2970|  13.4k|    if (doc == NULL) {
  ------------------
  |  Branch (2970:9): [True: 0, False: 13.4k]
  ------------------
 2971|      0|        doc = attr->doc;
 2972|      0|	if (doc == NULL) return(0);
  ------------------
  |  Branch (2972:6): [True: 0, False: 0]
  ------------------
 2973|      0|    }
 2974|       |
 2975|  13.4k|    if ((doc->intSubset == NULL) && (doc->extSubset == NULL)) {
  ------------------
  |  Branch (2975:9): [True: 7.16k, False: 6.32k]
  |  Branch (2975:37): [True: 7.16k, False: 0]
  ------------------
 2976|  7.16k|        return(0);
 2977|  7.16k|    } else if (doc->type == XML_HTML_DOCUMENT_NODE) {
  ------------------
  |  Branch (2977:16): [True: 6.32k, False: 0]
  ------------------
 2978|       |        /* TODO @@@ */
 2979|  6.32k|        return(0);
 2980|  6.32k|    } else {
 2981|      0|        xmlAttributePtr attrDecl;
 2982|       |
 2983|      0|        if (elem == NULL) return(0);
  ------------------
  |  Branch (2983:13): [True: 0, False: 0]
  ------------------
 2984|      0|        attrDecl = xmlGetDtdAttrDesc(doc->intSubset, elem->name, attr->name);
 2985|      0|        if ((attrDecl == NULL) && (doc->extSubset != NULL))
  ------------------
  |  Branch (2985:13): [True: 0, False: 0]
  |  Branch (2985:35): [True: 0, False: 0]
  ------------------
 2986|      0|            attrDecl = xmlGetDtdAttrDesc(doc->extSubset,
 2987|      0|		                         elem->name, attr->name);
 2988|       |
 2989|      0|	if ((attrDecl != NULL) &&
  ------------------
  |  Branch (2989:6): [True: 0, False: 0]
  ------------------
 2990|      0|	    (attrDecl->atype == XML_ATTRIBUTE_IDREF ||
  ------------------
  |  Branch (2990:7): [True: 0, False: 0]
  ------------------
 2991|      0|	     attrDecl->atype == XML_ATTRIBUTE_IDREFS))
  ------------------
  |  Branch (2991:7): [True: 0, False: 0]
  ------------------
 2992|      0|	return(1);
 2993|      0|    }
 2994|      0|    return(0);
 2995|  13.4k|}
xmlGetDtdAttrDesc:
 3230|  6.47k|xmlGetDtdAttrDesc(xmlDtdPtr dtd, const xmlChar *elem, const xmlChar *name) {
 3231|  6.47k|    xmlAttributeTablePtr table;
 3232|  6.47k|    xmlAttributePtr cur;
 3233|  6.47k|    xmlChar *uqname = NULL, *prefix = NULL;
 3234|       |
 3235|  6.47k|    if (dtd == NULL) return(NULL);
  ------------------
  |  Branch (3235:9): [True: 0, False: 6.47k]
  ------------------
 3236|  6.47k|    if (dtd->attributes == NULL) return(NULL);
  ------------------
  |  Branch (3236:9): [True: 6.47k, False: 0]
  ------------------
 3237|       |
 3238|      0|    table = (xmlAttributeTablePtr) dtd->attributes;
 3239|      0|    if (table == NULL)
  ------------------
  |  Branch (3239:9): [True: 0, False: 0]
  ------------------
 3240|      0|	return(NULL);
 3241|       |
 3242|      0|    uqname = xmlSplitQName2(name, &prefix);
 3243|       |
 3244|      0|    if (uqname != NULL) {
  ------------------
  |  Branch (3244:9): [True: 0, False: 0]
  ------------------
 3245|      0|	cur = xmlHashLookup3(table, uqname, prefix, elem);
 3246|      0|	if (prefix != NULL) xmlFree(prefix);
  ------------------
  |  Branch (3246:6): [True: 0, False: 0]
  ------------------
 3247|      0|	if (uqname != NULL) xmlFree(uqname);
  ------------------
  |  Branch (3247:6): [True: 0, False: 0]
  ------------------
 3248|      0|    } else
 3249|      0|	cur = xmlHashLookup3(table, name, NULL, elem);
 3250|      0|    return(cur);
 3251|      0|}
xmlValidCtxtNormalizeAttributeValue:
 3919|  13.6k|	     xmlNodePtr elem, const xmlChar *name, const xmlChar *value) {
 3920|  13.6k|    xmlChar *ret;
 3921|  13.6k|    xmlAttributePtr attrDecl = NULL;
 3922|  13.6k|    int extsubset = 0;
 3923|       |
 3924|  13.6k|    if (doc == NULL) return(NULL);
  ------------------
  |  Branch (3924:9): [True: 0, False: 13.6k]
  ------------------
 3925|  13.6k|    if (elem == NULL) return(NULL);
  ------------------
  |  Branch (3925:9): [True: 0, False: 13.6k]
  ------------------
 3926|  13.6k|    if (name == NULL) return(NULL);
  ------------------
  |  Branch (3926:9): [True: 0, False: 13.6k]
  ------------------
 3927|  13.6k|    if (value == NULL) return(NULL);
  ------------------
  |  Branch (3927:9): [True: 10, False: 13.6k]
  ------------------
 3928|       |
 3929|  13.6k|    if ((elem->ns != NULL) && (elem->ns->prefix != NULL)) {
  ------------------
  |  Branch (3929:9): [True: 0, False: 13.6k]
  |  Branch (3929:31): [True: 0, False: 0]
  ------------------
 3930|      0|	xmlChar fn[50];
 3931|      0|	xmlChar *fullname;
 3932|       |
 3933|      0|	fullname = xmlBuildQName(elem->name, elem->ns->prefix, fn, 50);
 3934|      0|	if (fullname == NULL)
  ------------------
  |  Branch (3934:6): [True: 0, False: 0]
  ------------------
 3935|      0|	    return(NULL);
 3936|      0|	attrDecl = xmlGetDtdAttrDesc(doc->intSubset, fullname, name);
 3937|      0|	if ((attrDecl == NULL) && (doc->extSubset != NULL)) {
  ------------------
  |  Branch (3937:6): [True: 0, False: 0]
  |  Branch (3937:28): [True: 0, False: 0]
  ------------------
 3938|      0|	    attrDecl = xmlGetDtdAttrDesc(doc->extSubset, fullname, name);
 3939|      0|	    if (attrDecl != NULL)
  ------------------
  |  Branch (3939:10): [True: 0, False: 0]
  ------------------
 3940|      0|		extsubset = 1;
 3941|      0|	}
 3942|      0|	if ((fullname != fn) && (fullname != elem->name))
  ------------------
  |  Branch (3942:6): [True: 0, False: 0]
  |  Branch (3942:26): [True: 0, False: 0]
  ------------------
 3943|      0|	    xmlFree(fullname);
 3944|      0|    }
 3945|  13.6k|    if ((attrDecl == NULL) && (doc->intSubset != NULL))
  ------------------
  |  Branch (3945:9): [True: 13.6k, False: 0]
  |  Branch (3945:31): [True: 6.47k, False: 7.18k]
  ------------------
 3946|  6.47k|	attrDecl = xmlGetDtdAttrDesc(doc->intSubset, elem->name, name);
 3947|  13.6k|    if ((attrDecl == NULL) && (doc->extSubset != NULL)) {
  ------------------
  |  Branch (3947:9): [True: 13.6k, False: 0]
  |  Branch (3947:31): [True: 0, False: 13.6k]
  ------------------
 3948|      0|	attrDecl = xmlGetDtdAttrDesc(doc->extSubset, elem->name, name);
 3949|      0|	if (attrDecl != NULL)
  ------------------
  |  Branch (3949:6): [True: 0, False: 0]
  ------------------
 3950|      0|	    extsubset = 1;
 3951|      0|    }
 3952|       |
 3953|  13.6k|    if (attrDecl == NULL)
  ------------------
  |  Branch (3953:9): [True: 13.6k, False: 0]
  ------------------
 3954|  13.6k|	return(NULL);
 3955|      0|    if (attrDecl->atype == XML_ATTRIBUTE_CDATA)
  ------------------
  |  Branch (3955:9): [True: 0, False: 0]
  ------------------
 3956|      0|	return(NULL);
 3957|       |
 3958|      0|    ret = xmlStrdup(value);
 3959|      0|    if (ret == NULL)
  ------------------
  |  Branch (3959:9): [True: 0, False: 0]
  ------------------
 3960|      0|	return(NULL);
 3961|      0|    xmlValidNormalizeString(ret);
 3962|      0|    if ((doc->standalone) && (extsubset == 1) && (!xmlStrEqual(value, ret))) {
  ------------------
  |  Branch (3962:9): [True: 0, False: 0]
  |  Branch (3962:30): [True: 0, False: 0]
  |  Branch (3962:50): [True: 0, False: 0]
  ------------------
 3963|      0|	xmlErrValidNode(ctxt, elem, XML_DTD_NOT_STANDALONE,
 3964|      0|"standalone: %s on %s value had to be normalized based on external subset declaration\n",
 3965|      0|	       name, elem->name, NULL);
 3966|      0|	ctxt->valid = 0;
 3967|      0|    }
 3968|      0|    return(ret);
 3969|      0|}
valid.c:xmlErrValidNode:
  137|      2|{
  138|      2|    xmlStructuredErrorFunc schannel = NULL;
  139|      2|    xmlGenericErrorFunc channel = NULL;
  140|      2|    xmlParserCtxtPtr pctxt = NULL;
  141|      2|    void *data = NULL;
  142|       |
  143|      2|    if (ctxt != NULL) {
  ------------------
  |  Branch (143:9): [True: 2, False: 0]
  ------------------
  144|      2|        channel = ctxt->error;
  145|      2|        data = ctxt->userData;
  146|       |	/* Look up flag to detect if it is part of a parsing
  147|       |	   context */
  148|      2|	if (ctxt->flags & XML_VCTXT_USE_PCTXT) {
  ------------------
  |  |   18|      2|#define XML_VCTXT_USE_PCTXT (1u << 1)
  ------------------
  |  Branch (148:6): [True: 2, False: 0]
  ------------------
  149|      2|	    pctxt = ctxt->userData;
  150|      2|	}
  151|      2|    }
  152|      2|    __xmlRaiseError(schannel, channel, data, pctxt, node, XML_FROM_VALID, error,
  153|      2|                    XML_ERR_ERROR, NULL, 0,
  154|      2|                    (const char *) str1,
  155|      2|                    (const char *) str2,
  156|      2|                    (const char *) str3, 0, 0, msg, str1, str2, str3);
  157|      2|}
valid.c:xmlIsStreaming:
 2471|    210|xmlIsStreaming(xmlValidCtxtPtr ctxt) {
 2472|    210|    xmlParserCtxtPtr pctxt;
 2473|       |
 2474|    210|    if (ctxt == NULL)
  ------------------
  |  Branch (2474:9): [True: 0, False: 210]
  ------------------
 2475|      0|        return(0);
 2476|    210|    if ((ctxt->flags & XML_VCTXT_USE_PCTXT) == 0)
  ------------------
  |  |   18|    210|#define XML_VCTXT_USE_PCTXT (1u << 1)
  ------------------
  |  Branch (2476:9): [True: 0, False: 210]
  ------------------
 2477|      0|        return(0);
 2478|    210|    pctxt = ctxt->userData;
 2479|    210|    return(pctxt->parseMode == XML_PARSE_READER);
 2480|    210|}
valid.c:xmlFreeID:
 2489|    210|xmlFreeID(xmlIDPtr id) {
 2490|    210|    xmlDictPtr dict = NULL;
 2491|       |
 2492|    210|    if (id == NULL) return;
  ------------------
  |  Branch (2492:9): [True: 0, False: 210]
  ------------------
 2493|       |
 2494|    210|    if (id->doc != NULL)
  ------------------
  |  Branch (2494:9): [True: 210, False: 0]
  ------------------
 2495|    210|        dict = id->doc->dict;
 2496|       |
 2497|    210|    if (id->value != NULL)
  ------------------
  |  Branch (2497:9): [True: 210, False: 0]
  ------------------
 2498|    210|	DICT_FREE(id->value)
  ------------------
  |  | 2437|    210|	if ((str) && ((!dict) ||				\
  |  |  ------------------
  |  |  |  Branch (2437:6): [True: 210, False: 0]
  |  |  |  Branch (2437:16): [True: 210, False: 0]
  |  |  ------------------
  |  | 2438|    210|	    (xmlDictOwns(dict, (const xmlChar *)(str)) == 0)))	\
  |  |  ------------------
  |  |  |  Branch (2438:6): [True: 0, False: 0]
  |  |  ------------------
  |  | 2439|    210|	    xmlFree((char *)(str));
  ------------------
 2499|    210|    if (id->name != NULL)
  ------------------
  |  Branch (2499:9): [True: 0, False: 210]
  ------------------
 2500|      0|	DICT_FREE(id->name)
  ------------------
  |  | 2437|      0|	if ((str) && ((!dict) ||				\
  |  |  ------------------
  |  |  |  Branch (2437:6): [True: 0, False: 0]
  |  |  |  Branch (2437:16): [True: 0, False: 0]
  |  |  ------------------
  |  | 2438|      0|	    (xmlDictOwns(dict, (const xmlChar *)(str)) == 0)))	\
  |  |  ------------------
  |  |  |  Branch (2438:6): [True: 0, False: 0]
  |  |  ------------------
  |  | 2439|      0|	    xmlFree((char *)(str));
  ------------------
 2501|    210|    xmlFree(id);
 2502|    210|}
valid.c:xmlFreeIDTableEntry:
 2590|    208|xmlFreeIDTableEntry(void *id, const xmlChar *name ATTRIBUTE_UNUSED) {
 2591|    208|    xmlFreeID((xmlIDPtr) id);
 2592|    208|}

xmlRegisterInputCallbacks:
 2102|      6|	xmlInputCloseCallback closeFunc) {
 2103|      6|    if (xmlInputCallbackNr >= MAX_INPUT_CALLBACK) {
  ------------------
  |  |   85|      6|#define MAX_INPUT_CALLBACK 15
  ------------------
  |  Branch (2103:9): [True: 0, False: 6]
  ------------------
 2104|      0|	return(-1);
 2105|      0|    }
 2106|      6|    xmlInputCallbackTable[xmlInputCallbackNr].matchcallback = matchFunc;
 2107|      6|    xmlInputCallbackTable[xmlInputCallbackNr].opencallback = openFunc;
 2108|      6|    xmlInputCallbackTable[xmlInputCallbackNr].readcallback = readFunc;
 2109|      6|    xmlInputCallbackTable[xmlInputCallbackNr].closecallback = closeFunc;
 2110|      6|    xmlInputCallbackInitialized = 1;
 2111|      6|    return(xmlInputCallbackNr++);
 2112|      6|}
xmlRegisterOutputCallbacks:
 2129|      2|	xmlOutputCloseCallback closeFunc) {
 2130|      2|    if (xmlOutputCallbackNr >= MAX_OUTPUT_CALLBACK) {
  ------------------
  |  |  102|      2|#define MAX_OUTPUT_CALLBACK 15
  ------------------
  |  Branch (2130:9): [True: 0, False: 2]
  ------------------
 2131|      0|	return(-1);
 2132|      0|    }
 2133|      2|    xmlOutputCallbackTable[xmlOutputCallbackNr].matchcallback = matchFunc;
 2134|      2|    xmlOutputCallbackTable[xmlOutputCallbackNr].opencallback = openFunc;
 2135|      2|    xmlOutputCallbackTable[xmlOutputCallbackNr].writecallback = writeFunc;
 2136|      2|    xmlOutputCallbackTable[xmlOutputCallbackNr].closecallback = closeFunc;
 2137|      2|    xmlOutputCallbackInitialized = 1;
 2138|      2|    return(xmlOutputCallbackNr++);
 2139|      2|}
xmlRegisterDefaultInputCallbacks:
 2148|      2|xmlRegisterDefaultInputCallbacks(void) {
 2149|      2|    if (xmlInputCallbackInitialized)
  ------------------
  |  Branch (2149:9): [True: 0, False: 2]
  ------------------
 2150|      0|	return;
 2151|       |
 2152|      2|    xmlRegisterInputCallbacks(xmlFileMatch, xmlFileOpen,
 2153|      2|	                      xmlFileRead, xmlFileClose);
 2154|      2|#ifdef LIBXML_ZLIB_ENABLED
 2155|      2|    xmlRegisterInputCallbacks(xmlGzfileMatch, xmlGzfileOpen,
 2156|      2|	                      xmlGzfileRead, xmlGzfileClose);
 2157|      2|#endif /* LIBXML_ZLIB_ENABLED */
 2158|      2|#ifdef LIBXML_LZMA_ENABLED
 2159|      2|    xmlRegisterInputCallbacks(xmlXzfileMatch, xmlXzfileOpen,
 2160|      2|	                      xmlXzfileRead, xmlXzfileClose);
 2161|      2|#endif /* LIBXML_LZMA_ENABLED */
 2162|       |
 2163|       |#ifdef LIBXML_HTTP_ENABLED
 2164|       |    xmlRegisterInputCallbacks(xmlIOHTTPMatch, xmlIOHTTPOpen,
 2165|       |	                      xmlIOHTTPRead, xmlIOHTTPClose);
 2166|       |#endif /* LIBXML_HTTP_ENABLED */
 2167|       |
 2168|       |#ifdef LIBXML_FTP_ENABLED
 2169|       |    xmlRegisterInputCallbacks(xmlIOFTPMatch, xmlIOFTPOpen,
 2170|       |	                      xmlIOFTPRead, xmlIOFTPClose);
 2171|       |#endif /* LIBXML_FTP_ENABLED */
 2172|      2|    xmlInputCallbackInitialized = 1;
 2173|      2|}
xmlRegisterDefaultOutputCallbacks:
 2182|      2|xmlRegisterDefaultOutputCallbacks (void) {
 2183|      2|    if (xmlOutputCallbackInitialized)
  ------------------
  |  Branch (2183:9): [True: 0, False: 2]
  ------------------
 2184|      0|	return;
 2185|       |
 2186|      2|    xmlRegisterOutputCallbacks(xmlFileMatch, xmlFileOpenW,
 2187|      2|	                      xmlFileWrite, xmlFileClose);
 2188|       |
 2189|       |#ifdef LIBXML_HTTP_ENABLED
 2190|       |    xmlRegisterOutputCallbacks(xmlIOHTTPMatch, xmlIOHTTPDfltOpenW,
 2191|       |	                       xmlIOHTTPWrite, xmlIOHTTPClosePut);
 2192|       |#endif
 2193|       |
 2194|       |/*********************************
 2195|       | No way a-priori to distinguish between gzipped files from
 2196|       | uncompressed ones except opening if existing then closing
 2197|       | and saving with same compression ratio ... a pain.
 2198|       |
 2199|       |#ifdef LIBXML_ZLIB_ENABLED
 2200|       |    xmlRegisterOutputCallbacks(xmlGzfileMatch, xmlGzfileOpen,
 2201|       |	                       xmlGzfileWrite, xmlGzfileClose);
 2202|       |#endif
 2203|       |
 2204|       | Nor FTP PUT ....
 2205|       |#ifdef LIBXML_FTP_ENABLED
 2206|       |    xmlRegisterOutputCallbacks(xmlIOFTPMatch, xmlIOFTPOpen,
 2207|       |	                       xmlIOFTPWrite, xmlIOFTPClose);
 2208|       |#endif
 2209|       | **********************************/
 2210|      2|    xmlOutputCallbackInitialized = 1;
 2211|      2|}
xmlAllocParserInputBuffer:
 2246|    192|xmlAllocParserInputBuffer(xmlCharEncoding enc) {
 2247|    192|    xmlParserInputBufferPtr ret;
 2248|       |
 2249|    192|    ret = (xmlParserInputBufferPtr) xmlMalloc(sizeof(xmlParserInputBuffer));
 2250|    192|    if (ret == NULL) {
  ------------------
  |  Branch (2250:9): [True: 2, False: 190]
  ------------------
 2251|      2|	return(NULL);
 2252|      2|    }
 2253|    190|    memset(ret, 0, sizeof(xmlParserInputBuffer));
 2254|    190|    ret->buffer = xmlBufCreateSize(2 * xmlDefaultBufferSize);
  ------------------
  |  |  680|    190|  #define xmlDefaultBufferSize XML_GLOBAL_MACRO(xmlDefaultBufferSize)
  |  |  ------------------
  |  |  |  |  500|    190|  #define XML_GLOBAL_MACRO(name) (*__##name())
  |  |  ------------------
  ------------------
 2255|    190|    if (ret->buffer == NULL) {
  ------------------
  |  Branch (2255:9): [True: 3, False: 187]
  ------------------
 2256|      3|        xmlFree(ret);
 2257|      3|	return(NULL);
 2258|      3|    }
 2259|    187|    xmlBufSetAllocationScheme(ret->buffer, XML_BUFFER_ALLOC_DOUBLEIT);
 2260|    187|    ret->encoder = xmlGetCharEncodingHandler(enc);
 2261|    187|    if (ret->encoder != NULL)
  ------------------
  |  Branch (2261:9): [True: 0, False: 187]
  ------------------
 2262|      0|        ret->raw = xmlBufCreateSize(2 * xmlDefaultBufferSize);
  ------------------
  |  |  680|      0|  #define xmlDefaultBufferSize XML_GLOBAL_MACRO(xmlDefaultBufferSize)
  |  |  ------------------
  |  |  |  |  500|      0|  #define XML_GLOBAL_MACRO(name) (*__##name())
  |  |  ------------------
  ------------------
 2263|    187|    else
 2264|    187|        ret->raw = NULL;
 2265|    187|    ret->readcallback = NULL;
 2266|    187|    ret->closecallback = NULL;
 2267|    187|    ret->context = NULL;
 2268|    187|    ret->compressed = -1;
 2269|    187|    ret->rawconsumed = 0;
 2270|       |
 2271|    187|    return(ret);
 2272|    190|}
xmlAllocOutputBuffer:
 2284|     99|xmlAllocOutputBuffer(xmlCharEncodingHandlerPtr encoder) {
 2285|     99|    xmlOutputBufferPtr ret;
 2286|       |
 2287|     99|    ret = (xmlOutputBufferPtr) xmlMalloc(sizeof(xmlOutputBuffer));
 2288|     99|    if (ret == NULL) {
  ------------------
  |  Branch (2288:9): [True: 9, False: 90]
  ------------------
 2289|      9|	return(NULL);
 2290|      9|    }
 2291|     90|    memset(ret, 0, sizeof(xmlOutputBuffer));
 2292|     90|    ret->buffer = xmlBufCreate();
 2293|     90|    if (ret->buffer == NULL) {
  ------------------
  |  Branch (2293:9): [True: 1, False: 89]
  ------------------
 2294|      1|        xmlFree(ret);
 2295|      1|	return(NULL);
 2296|      1|    }
 2297|     89|    xmlBufSetAllocationScheme(ret->buffer, XML_BUFFER_ALLOC_DOUBLEIT);
 2298|       |
 2299|     89|    ret->encoder = encoder;
 2300|     89|    if (encoder != NULL) {
  ------------------
  |  Branch (2300:9): [True: 0, False: 89]
  ------------------
 2301|      0|        ret->conv = xmlBufCreateSize(4000);
 2302|      0|	if (ret->conv == NULL) {
  ------------------
  |  Branch (2302:6): [True: 0, False: 0]
  ------------------
 2303|      0|            xmlBufFree(ret->buffer);
 2304|      0|	    xmlFree(ret);
 2305|      0|	    return(NULL);
 2306|      0|	}
 2307|       |
 2308|       |	/*
 2309|       |	 * This call is designed to initiate the encoder state
 2310|       |	 */
 2311|      0|	xmlCharEncOutput(ret, 1);
 2312|      0|    } else
 2313|     89|        ret->conv = NULL;
 2314|     89|    ret->writecallback = NULL;
 2315|     89|    ret->closecallback = NULL;
 2316|     89|    ret->context = NULL;
 2317|     89|    ret->written = 0;
 2318|       |
 2319|     89|    return(ret);
 2320|     89|}
xmlFreeParserInputBuffer:
 2383|    187|xmlFreeParserInputBuffer(xmlParserInputBufferPtr in) {
 2384|    187|    if (in == NULL) return;
  ------------------
  |  Branch (2384:9): [True: 0, False: 187]
  ------------------
 2385|       |
 2386|    187|    if (in->raw) {
  ------------------
  |  Branch (2386:9): [True: 57, False: 130]
  ------------------
 2387|     57|        xmlBufFree(in->raw);
 2388|     57|	in->raw = NULL;
 2389|     57|    }
 2390|    187|    if (in->encoder != NULL) {
  ------------------
  |  Branch (2390:9): [True: 57, False: 130]
  ------------------
 2391|     57|        xmlCharEncCloseFunc(in->encoder);
 2392|     57|    }
 2393|    187|    if (in->closecallback != NULL) {
  ------------------
  |  Branch (2393:9): [True: 91, False: 96]
  ------------------
 2394|     91|	in->closecallback(in->context);
 2395|     91|    }
 2396|    187|    if (in->buffer != NULL) {
  ------------------
  |  Branch (2396:9): [True: 186, False: 1]
  ------------------
 2397|    186|        xmlBufFree(in->buffer);
 2398|    186|	in->buffer = NULL;
 2399|    186|    }
 2400|       |
 2401|    187|    xmlFree(in);
 2402|    187|}
xmlOutputBufferClose:
 2416|     99|{
 2417|     99|    int written;
 2418|     99|    int err_rc = 0;
 2419|       |
 2420|     99|    if (out == NULL)
  ------------------
  |  Branch (2420:9): [True: 10, False: 89]
  ------------------
 2421|     10|        return (-1);
 2422|     89|    if (out->writecallback != NULL)
  ------------------
  |  Branch (2422:9): [True: 0, False: 89]
  ------------------
 2423|      0|        xmlOutputBufferFlush(out);
 2424|     89|    if (out->closecallback != NULL) {
  ------------------
  |  Branch (2424:9): [True: 0, False: 89]
  ------------------
 2425|      0|        err_rc = out->closecallback(out->context);
 2426|      0|    }
 2427|     89|    written = out->written;
 2428|     89|    if (out->conv) {
  ------------------
  |  Branch (2428:9): [True: 0, False: 89]
  ------------------
 2429|      0|        xmlBufFree(out->conv);
 2430|      0|        out->conv = NULL;
 2431|      0|    }
 2432|     89|    if (out->encoder != NULL) {
  ------------------
  |  Branch (2432:9): [True: 0, False: 89]
  ------------------
 2433|      0|        xmlCharEncCloseFunc(out->encoder);
 2434|      0|    }
 2435|     89|    if (out->buffer != NULL) {
  ------------------
  |  Branch (2435:9): [True: 89, False: 0]
  ------------------
 2436|     89|        xmlBufFree(out->buffer);
 2437|     89|        out->buffer = NULL;
 2438|     89|    }
 2439|       |
 2440|     89|    if (out->error)
  ------------------
  |  Branch (2440:9): [True: 0, False: 89]
  ------------------
 2441|      0|        err_rc = -1;
 2442|     89|    xmlFree(out);
 2443|     89|    return ((err_rc == 0) ? written : err_rc);
  ------------------
  |  Branch (2443:13): [True: 89, False: 0]
  ------------------
 2444|     99|}
xmlParserInputBufferCreateMem:
 2870|     93|xmlParserInputBufferCreateMem(const char *mem, int size, xmlCharEncoding enc) {
 2871|     93|    xmlParserInputBufferPtr ret;
 2872|     93|    xmlMemIOCtxt *ctxt;
 2873|       |
 2874|     93|    if (size < 0) return(NULL);
  ------------------
  |  Branch (2874:9): [True: 0, False: 93]
  ------------------
 2875|     93|    if (mem == NULL) return(NULL);
  ------------------
  |  Branch (2875:9): [True: 0, False: 93]
  ------------------
 2876|       |
 2877|     93|    ret = xmlAllocParserInputBuffer(enc);
 2878|     93|    if (ret == NULL)
  ------------------
  |  Branch (2878:9): [True: 2, False: 91]
  ------------------
 2879|      2|        return(NULL);
 2880|       |
 2881|     91|    ctxt = xmlMalloc(sizeof(*ctxt));
 2882|     91|    if (ctxt == NULL) {
  ------------------
  |  Branch (2882:9): [True: 0, False: 91]
  ------------------
 2883|      0|        xmlFreeParserInputBuffer(ret);
 2884|      0|        return(NULL);
 2885|      0|    }
 2886|     91|    ctxt->mem = mem;
 2887|     91|    ctxt->size = size;
 2888|       |
 2889|     91|    ret->context = ctxt;
 2890|     91|    ret->readcallback = xmlMemRead;
 2891|     91|    ret->closecallback = xmlMemClose;
 2892|       |
 2893|     91|    return(ret);
 2894|     91|}
xmlParserInputBufferPush:
 3116|  3.24k|	                 int len, const char *buf) {
 3117|  3.24k|    int nbchars = 0;
 3118|  3.24k|    int ret;
 3119|       |
 3120|  3.24k|    if (len < 0) return(0);
  ------------------
  |  Branch (3120:9): [True: 0, False: 3.24k]
  ------------------
 3121|  3.24k|    if ((in == NULL) || (in->error)) return(-1);
  ------------------
  |  Branch (3121:9): [True: 0, False: 3.24k]
  |  Branch (3121:25): [True: 0, False: 3.24k]
  ------------------
 3122|  3.24k|    if (in->encoder != NULL) {
  ------------------
  |  Branch (3122:9): [True: 1.81k, False: 1.42k]
  ------------------
 3123|       |        /*
 3124|       |	 * Store the data in the incoming raw buffer
 3125|       |	 */
 3126|  1.81k|        if (in->raw == NULL) {
  ------------------
  |  Branch (3126:13): [True: 0, False: 1.81k]
  ------------------
 3127|      0|	    in->raw = xmlBufCreate();
 3128|      0|            if (in->raw == NULL) {
  ------------------
  |  Branch (3128:17): [True: 0, False: 0]
  ------------------
 3129|      0|                in->error = XML_ERR_NO_MEMORY;
 3130|      0|                return(-1);
 3131|      0|            }
 3132|      0|	}
 3133|  1.81k|	ret = xmlBufAdd(in->raw, (const xmlChar *) buf, len);
 3134|  1.81k|	if (ret != 0) {
  ------------------
  |  Branch (3134:6): [True: 0, False: 1.81k]
  ------------------
 3135|      0|            in->error = XML_ERR_NO_MEMORY;
 3136|      0|	    return(-1);
 3137|      0|        }
 3138|       |
 3139|       |	/*
 3140|       |	 * convert as much as possible to the parser reading buffer.
 3141|       |	 */
 3142|  1.81k|	nbchars = xmlCharEncInput(in);
 3143|  1.81k|	if (nbchars < 0)
  ------------------
  |  Branch (3143:6): [True: 0, False: 1.81k]
  ------------------
 3144|      0|	    return(-1);
 3145|  1.81k|    } else {
 3146|  1.42k|	nbchars = len;
 3147|  1.42k|        ret = xmlBufAdd(in->buffer, (xmlChar *) buf, nbchars);
 3148|  1.42k|	if (ret != 0) {
  ------------------
  |  Branch (3148:6): [True: 0, False: 1.42k]
  ------------------
 3149|      0|            in->error = XML_ERR_NO_MEMORY;
 3150|      0|	    return(-1);
 3151|      0|        }
 3152|  1.42k|    }
 3153|  3.24k|    return(nbchars);
 3154|  3.24k|}
xmlParserInputBufferGrow:
 3185|  14.9k|xmlParserInputBufferGrow(xmlParserInputBufferPtr in, int len) {
 3186|  14.9k|    xmlBufPtr buf;
 3187|  14.9k|    int res = 0;
 3188|       |
 3189|  14.9k|    if ((in == NULL) || (in->error)) return(-1);
  ------------------
  |  Branch (3189:9): [True: 0, False: 14.9k]
  |  Branch (3189:25): [True: 0, False: 14.9k]
  ------------------
 3190|  14.9k|    if ((len <= MINLEN) && (len != 4))
  ------------------
  |  |   73|  14.9k|#define MINLEN 4000
  ------------------
  |  Branch (3190:9): [True: 14.9k, False: 0]
  |  Branch (3190:28): [True: 14.9k, False: 0]
  ------------------
 3191|  14.9k|        len = MINLEN;
  ------------------
  |  |   73|  14.9k|#define MINLEN 4000
  ------------------
 3192|       |
 3193|  14.9k|    if (in->encoder == NULL) {
  ------------------
  |  Branch (3193:9): [True: 9.91k, False: 5.03k]
  ------------------
 3194|  9.91k|        if (in->readcallback == NULL)
  ------------------
  |  Branch (3194:13): [True: 0, False: 9.91k]
  ------------------
 3195|      0|            return(0);
 3196|  9.91k|        buf = in->buffer;
 3197|  9.91k|    } else {
 3198|  5.03k|        if (in->raw == NULL) {
  ------------------
  |  Branch (3198:13): [True: 0, False: 5.03k]
  ------------------
 3199|      0|	    in->raw = xmlBufCreate();
 3200|      0|	}
 3201|  5.03k|        buf = in->raw;
 3202|  5.03k|    }
 3203|       |
 3204|       |    /*
 3205|       |     * Call the read method for this I/O type.
 3206|       |     */
 3207|  14.9k|    if (in->readcallback != NULL) {
  ------------------
  |  Branch (3207:9): [True: 14.9k, False: 0]
  ------------------
 3208|  14.9k|        if (xmlBufGrow(buf, len + 1) < 0) {
  ------------------
  |  Branch (3208:13): [True: 0, False: 14.9k]
  ------------------
 3209|      0|            in->error = XML_ERR_NO_MEMORY;
 3210|      0|            return(-1);
 3211|      0|        }
 3212|       |
 3213|  14.9k|	res = in->readcallback(in->context, (char *)xmlBufEnd(buf), len);
 3214|  14.9k|	if (res <= 0)
  ------------------
  |  Branch (3214:6): [True: 14.7k, False: 177]
  ------------------
 3215|  14.7k|	    in->readcallback = endOfInput;
 3216|  14.9k|        if (res < 0) {
  ------------------
  |  Branch (3216:13): [True: 0, False: 14.9k]
  ------------------
 3217|      0|            in->error = XML_IO_UNKNOWN;
 3218|      0|            return(-1);
 3219|      0|        }
 3220|       |
 3221|  14.9k|        if (xmlBufAddLen(buf, res) < 0) {
  ------------------
  |  Branch (3221:13): [True: 0, False: 14.9k]
  ------------------
 3222|      0|            in->error = XML_ERR_NO_MEMORY;
 3223|      0|            return(-1);
 3224|      0|        }
 3225|  14.9k|    }
 3226|       |
 3227|       |    /*
 3228|       |     * try to establish compressed status of input if not done already
 3229|       |     */
 3230|  14.9k|    if (in->compressed == -1) {
  ------------------
  |  Branch (3230:9): [True: 14.9k, False: 0]
  ------------------
 3231|  14.9k|#ifdef LIBXML_LZMA_ENABLED
 3232|  14.9k|	if (in->readcallback == xmlXzfileRead)
  ------------------
  |  Branch (3232:6): [True: 0, False: 14.9k]
  ------------------
 3233|      0|            in->compressed = __libxml2_xzcompressed(in->context);
 3234|  14.9k|#endif
 3235|  14.9k|    }
 3236|       |
 3237|  14.9k|    if (in->encoder != NULL) {
  ------------------
  |  Branch (3237:9): [True: 5.03k, False: 9.91k]
  ------------------
 3238|  5.03k|	res = xmlCharEncInput(in);
 3239|  5.03k|	if (res < 0)
  ------------------
  |  Branch (3239:6): [True: 0, False: 5.03k]
  ------------------
 3240|      0|	    return(-1);
 3241|  5.03k|    }
 3242|  14.9k|    return(res);
 3243|  14.9k|}
xmlOutputBufferWrite:
 3278|  60.1k|xmlOutputBufferWrite(xmlOutputBufferPtr out, int len, const char *buf) {
 3279|  60.1k|    int nbchars = 0; /* number of chars to output to I/O */
 3280|  60.1k|    int ret;         /* return from function call */
 3281|  60.1k|    int written = 0; /* number of char written to I/O so far */
 3282|  60.1k|    int chunk;       /* number of byte current processed from buf */
 3283|       |
 3284|  60.1k|    if ((out == NULL) || (out->error)) return(-1);
  ------------------
  |  Branch (3284:9): [True: 0, False: 60.1k]
  |  Branch (3284:26): [True: 0, False: 60.1k]
  ------------------
 3285|  60.1k|    if (len < 0) return(0);
  ------------------
  |  Branch (3285:9): [True: 0, False: 60.1k]
  ------------------
 3286|  60.1k|    if (out->error) return(-1);
  ------------------
  |  Branch (3286:9): [True: 0, False: 60.1k]
  ------------------
 3287|       |
 3288|  60.1k|    do {
 3289|  60.1k|	chunk = len;
 3290|  60.1k|	if (chunk > 4 * MINLEN)
  ------------------
  |  |   73|  60.1k|#define MINLEN 4000
  ------------------
  |  Branch (3290:6): [True: 0, False: 60.1k]
  ------------------
 3291|      0|	    chunk = 4 * MINLEN;
  ------------------
  |  |   73|      0|#define MINLEN 4000
  ------------------
 3292|       |
 3293|       |	/*
 3294|       |	 * first handle encoding stuff.
 3295|       |	 */
 3296|  60.1k|	if (out->encoder != NULL) {
  ------------------
  |  Branch (3296:6): [True: 0, False: 60.1k]
  ------------------
 3297|       |	    /*
 3298|       |	     * Store the data in the incoming raw buffer
 3299|       |	     */
 3300|      0|	    if (out->conv == NULL) {
  ------------------
  |  Branch (3300:10): [True: 0, False: 0]
  ------------------
 3301|      0|		out->conv = xmlBufCreate();
 3302|      0|	    }
 3303|      0|	    ret = xmlBufAdd(out->buffer, (const xmlChar *) buf, chunk);
 3304|      0|	    if (ret != 0)
  ------------------
  |  Branch (3304:10): [True: 0, False: 0]
  ------------------
 3305|      0|	        return(-1);
 3306|       |
 3307|      0|	    if ((xmlBufUse(out->buffer) < MINLEN) && (chunk == len))
  ------------------
  |  |   73|      0|#define MINLEN 4000
  ------------------
  |  Branch (3307:10): [True: 0, False: 0]
  |  Branch (3307:47): [True: 0, False: 0]
  ------------------
 3308|      0|		goto done;
 3309|       |
 3310|       |	    /*
 3311|       |	     * convert as much as possible to the parser reading buffer.
 3312|       |	     */
 3313|      0|	    ret = xmlCharEncOutput(out, 0);
 3314|      0|	    if ((ret < 0) && (ret != -3)) {
  ------------------
  |  Branch (3314:10): [True: 0, False: 0]
  |  Branch (3314:23): [True: 0, False: 0]
  ------------------
 3315|      0|		xmlIOErr(XML_IO_ENCODER, NULL);
 3316|      0|		out->error = XML_IO_ENCODER;
 3317|      0|		return(-1);
 3318|      0|	    }
 3319|      0|            if (out->writecallback)
  ------------------
  |  Branch (3319:17): [True: 0, False: 0]
  ------------------
 3320|      0|	        nbchars = xmlBufUse(out->conv);
 3321|      0|            else
 3322|      0|                nbchars = ret >= 0 ? ret : 0;
  ------------------
  |  Branch (3322:27): [True: 0, False: 0]
  ------------------
 3323|  60.1k|	} else {
 3324|  60.1k|	    ret = xmlBufAdd(out->buffer, (const xmlChar *) buf, chunk);
 3325|  60.1k|	    if (ret != 0)
  ------------------
  |  Branch (3325:10): [True: 0, False: 60.1k]
  ------------------
 3326|      0|	        return(-1);
 3327|  60.1k|            if (out->writecallback)
  ------------------
  |  Branch (3327:17): [True: 0, False: 60.1k]
  ------------------
 3328|      0|	        nbchars = xmlBufUse(out->buffer);
 3329|  60.1k|            else
 3330|  60.1k|                nbchars = chunk;
 3331|  60.1k|	}
 3332|  60.1k|	buf += chunk;
 3333|  60.1k|	len -= chunk;
 3334|       |
 3335|  60.1k|	if (out->writecallback) {
  ------------------
  |  Branch (3335:6): [True: 0, False: 60.1k]
  ------------------
 3336|      0|            if ((nbchars < MINLEN) && (len <= 0))
  ------------------
  |  |   73|      0|#define MINLEN 4000
  ------------------
  |  Branch (3336:17): [True: 0, False: 0]
  |  Branch (3336:39): [True: 0, False: 0]
  ------------------
 3337|      0|                goto done;
 3338|       |
 3339|       |	    /*
 3340|       |	     * second write the stuff to the I/O channel
 3341|       |	     */
 3342|      0|	    if (out->encoder != NULL) {
  ------------------
  |  Branch (3342:10): [True: 0, False: 0]
  ------------------
 3343|      0|		ret = out->writecallback(out->context,
 3344|      0|                           (const char *)xmlBufContent(out->conv), nbchars);
 3345|      0|		if (ret >= 0)
  ------------------
  |  Branch (3345:7): [True: 0, False: 0]
  ------------------
 3346|      0|		    xmlBufShrink(out->conv, ret);
 3347|      0|	    } else {
 3348|      0|		ret = out->writecallback(out->context,
 3349|      0|                           (const char *)xmlBufContent(out->buffer), nbchars);
 3350|      0|		if (ret >= 0)
  ------------------
  |  Branch (3350:7): [True: 0, False: 0]
  ------------------
 3351|      0|		    xmlBufShrink(out->buffer, ret);
 3352|      0|	    }
 3353|      0|	    if (ret < 0) {
  ------------------
  |  Branch (3353:10): [True: 0, False: 0]
  ------------------
 3354|      0|		xmlIOErr(XML_IO_WRITE, NULL);
 3355|      0|		out->error = XML_IO_WRITE;
 3356|      0|		return(ret);
 3357|      0|	    }
 3358|      0|            if (out->written > INT_MAX - ret)
  ------------------
  |  Branch (3358:17): [True: 0, False: 0]
  ------------------
 3359|      0|                out->written = INT_MAX;
 3360|      0|            else
 3361|      0|                out->written += ret;
 3362|      0|	}
 3363|  60.1k|	written += nbchars;
 3364|  60.1k|    } while (len > 0);
  ------------------
  |  Branch (3364:14): [True: 0, False: 60.1k]
  ------------------
 3365|       |
 3366|  60.1k|done:
 3367|  60.1k|    return(written);
 3368|  60.1k|}
xmlOutputBufferWriteString:
 3580|  60.1k|xmlOutputBufferWriteString(xmlOutputBufferPtr out, const char *str) {
 3581|  60.1k|    int len;
 3582|       |
 3583|  60.1k|    if ((out == NULL) || (out->error)) return(-1);
  ------------------
  |  Branch (3583:9): [True: 0, False: 60.1k]
  |  Branch (3583:26): [True: 0, False: 60.1k]
  ------------------
 3584|  60.1k|    if (str == NULL)
  ------------------
  |  Branch (3584:9): [True: 0, False: 60.1k]
  ------------------
 3585|      0|        return(-1);
 3586|  60.1k|    len = strlen(str);
 3587|       |
 3588|  60.1k|    if (len > 0)
  ------------------
  |  Branch (3588:9): [True: 60.1k, False: 4]
  ------------------
 3589|  60.1k|	return(xmlOutputBufferWrite(out, len, str));
 3590|      4|    return(len);
 3591|  60.1k|}
xmlIO.c:xmlMemRead:
 2839|    267|xmlMemRead(void *vctxt, char *buf, int size) {
 2840|    267|    xmlMemIOCtxt *ctxt = vctxt;
 2841|       |
 2842|    267|    if ((size_t) size > ctxt->size)
  ------------------
  |  Branch (2842:9): [True: 180, False: 87]
  ------------------
 2843|    180|        size = ctxt->size;
 2844|       |
 2845|    267|    memcpy(buf, ctxt->mem, size);
 2846|    267|    ctxt->mem += size;
 2847|    267|    ctxt->size -= size;
 2848|       |
 2849|    267|    return size;
 2850|    267|}
xmlIO.c:xmlMemClose:
 2853|     91|xmlMemClose(void *vctxt) {
 2854|     91|    xmlFree(vctxt);
 2855|     91|    return(0);
 2856|     91|}
xmlIO.c:endOfInput:
 3165|  14.6k|	    int len ATTRIBUTE_UNUSED) {
 3166|  14.6k|    return(0);
 3167|  14.6k|}

xmlInitMemoryInternal:
  846|      2|xmlInitMemoryInternal(void) {
  847|      2|     char *breakpoint;
  848|      2|     xmlInitMutex(&xmlMemMutex);
  849|       |
  850|      2|     breakpoint = getenv("XML_MEM_BREAKPOINT");
  851|      2|     if (breakpoint != NULL) {
  ------------------
  |  Branch (851:10): [True: 0, False: 2]
  ------------------
  852|      0|         sscanf(breakpoint, "%ud", &xmlMemStopAtBlock);
  853|      0|     }
  854|      2|     breakpoint = getenv("XML_MEM_TRACE");
  855|      2|     if (breakpoint != NULL) {
  ------------------
  |  Branch (855:10): [True: 0, False: 2]
  ------------------
  856|      0|         sscanf(breakpoint, "%p", &xmlMemTraceBlockAt);
  857|      0|     }
  858|       |
  859|      2|}
xmlMemSetup:
  910|      2|            xmlReallocFunc reallocFunc, xmlStrdupFunc strdupFunc) {
  911|      2|    if (freeFunc == NULL)
  ------------------
  |  Branch (911:9): [True: 0, False: 2]
  ------------------
  912|      0|	return(-1);
  913|      2|    if (mallocFunc == NULL)
  ------------------
  |  Branch (913:9): [True: 0, False: 2]
  ------------------
  914|      0|	return(-1);
  915|      2|    if (reallocFunc == NULL)
  ------------------
  |  Branch (915:9): [True: 0, False: 2]
  ------------------
  916|      0|	return(-1);
  917|      2|    if (strdupFunc == NULL)
  ------------------
  |  Branch (917:9): [True: 0, False: 2]
  ------------------
  918|      0|	return(-1);
  919|      2|    xmlFree = freeFunc;
  920|      2|    xmlMalloc = mallocFunc;
  921|      2|    xmlMallocAtomic = mallocFunc;
  922|      2|    xmlRealloc = reallocFunc;
  923|      2|    xmlMemStrdup = strdupFunc;
  924|      2|    return(0);
  925|      2|}

xmlStrndup:
   45|  72.0k|xmlStrndup(const xmlChar *cur, int len) {
   46|  72.0k|    xmlChar *ret;
   47|       |
   48|  72.0k|    if ((cur == NULL) || (len < 0)) return(NULL);
  ------------------
  |  Branch (48:9): [True: 0, False: 72.0k]
  |  Branch (48:26): [True: 0, False: 72.0k]
  ------------------
   49|  72.0k|    ret = (xmlChar *) xmlMallocAtomic((size_t) len + 1);
   50|  72.0k|    if (ret == NULL) {
  ------------------
  |  Branch (50:9): [True: 33, False: 72.0k]
  ------------------
   51|     33|        return(NULL);
   52|     33|    }
   53|  72.0k|    memcpy(ret, cur, len);
   54|  72.0k|    ret[len] = 0;
   55|  72.0k|    return(ret);
   56|  72.0k|}
xmlStrdup:
   69|  66.1k|xmlStrdup(const xmlChar *cur) {
   70|  66.1k|    const xmlChar *p = cur;
   71|       |
   72|  66.1k|    if (cur == NULL) return(NULL);
  ------------------
  |  Branch (72:9): [True: 4.56k, False: 61.6k]
  ------------------
   73|   650k|    while (*p != 0) p++; /* non input consuming */
  ------------------
  |  Branch (73:12): [True: 589k, False: 61.6k]
  ------------------
   74|  61.6k|    return(xmlStrndup(cur, p - cur));
   75|  66.1k|}
xmlStrEqual:
  162|   634k|xmlStrEqual(const xmlChar *str1, const xmlChar *str2) {
  163|   634k|    if (str1 == str2) return(1);
  ------------------
  |  Branch (163:9): [True: 42.6k, False: 591k]
  ------------------
  164|   591k|    if (str1 == NULL) return(0);
  ------------------
  |  Branch (164:9): [True: 484, False: 591k]
  ------------------
  165|   591k|    if (str2 == NULL) return(0);
  ------------------
  |  Branch (165:9): [True: 0, False: 591k]
  ------------------
  166|   591k|#ifdef FUZZING_BUILD_MODE_UNSAFE_FOR_PRODUCTION
  167|   591k|    return(strcmp((const char *)str1, (const char *)str2) == 0);
  168|       |#else
  169|       |    do {
  170|       |        if (*str1++ != *str2) return(0);
  171|       |    } while (*str2++);
  172|       |    return(1);
  173|       |#endif
  174|   591k|}
xmlStrcasecmp:
  277|   261k|xmlStrcasecmp(const xmlChar *str1, const xmlChar *str2) {
  278|   261k|    register int tmp;
  279|       |
  280|   261k|    if (str1 == str2) return(0);
  ------------------
  |  Branch (280:9): [True: 30, False: 261k]
  ------------------
  281|   261k|    if (str1 == NULL) return(-1);
  ------------------
  |  Branch (281:9): [True: 0, False: 261k]
  ------------------
  282|   261k|    if (str2 == NULL) return(1);
  ------------------
  |  Branch (282:9): [True: 0, False: 261k]
  ------------------
  283|   386k|    do {
  284|   386k|        tmp = casemap[*str1++] - casemap[*str2];
  285|   386k|        if (tmp != 0) return(tmp);
  ------------------
  |  Branch (285:13): [True: 235k, False: 151k]
  ------------------
  286|   386k|    } while (*str2++ != 0);
  ------------------
  |  Branch (286:14): [True: 125k, False: 25.9k]
  ------------------
  287|  25.9k|    return 0;
  288|   261k|}
xmlStrncasecmp:
  302|    832|xmlStrncasecmp(const xmlChar *str1, const xmlChar *str2, int len) {
  303|    832|    register int tmp;
  304|       |
  305|    832|    if (len <= 0) return(0);
  ------------------
  |  Branch (305:9): [True: 0, False: 832]
  ------------------
  306|    832|    if (str1 == str2) return(0);
  ------------------
  |  Branch (306:9): [True: 0, False: 832]
  ------------------
  307|    832|    if (str1 == NULL) return(-1);
  ------------------
  |  Branch (307:9): [True: 0, False: 832]
  ------------------
  308|    832|    if (str2 == NULL) return(1);
  ------------------
  |  Branch (308:9): [True: 0, False: 832]
  ------------------
  309|  1.99k|    do {
  310|  1.99k|        tmp = casemap[*str1++] - casemap[*str2];
  311|  1.99k|        if (tmp != 0 || --len == 0) return(tmp);
  ------------------
  |  Branch (311:13): [True: 818, False: 1.17k]
  |  Branch (311:25): [True: 14, False: 1.16k]
  ------------------
  312|  1.99k|    } while (*str2++ != 0);
  ------------------
  |  Branch (312:14): [True: 1.16k, False: 0]
  ------------------
  313|      0|    return 0;
  314|    832|}
xmlStrchr:
  327|  13.2k|xmlStrchr(const xmlChar *str, xmlChar val) {
  328|  13.2k|    if (str == NULL) return(NULL);
  ------------------
  |  Branch (328:9): [True: 0, False: 13.2k]
  ------------------
  329|   186k|    while (*str != 0) { /* non input consuming */
  ------------------
  |  Branch (329:12): [True: 179k, False: 6.91k]
  ------------------
  330|   179k|        if (*str == val) return((xmlChar *) str);
  ------------------
  |  Branch (330:13): [True: 6.33k, False: 173k]
  ------------------
  331|   173k|        str++;
  332|   173k|    }
  333|  6.91k|    return(NULL);
  334|  13.2k|}
xmlStrcasestr:
  375|     59|xmlStrcasestr(const xmlChar *str, const xmlChar *val) {
  376|     59|    int n;
  377|       |
  378|     59|    if (str == NULL) return(NULL);
  ------------------
  |  Branch (378:9): [True: 0, False: 59]
  ------------------
  379|     59|    if (val == NULL) return(NULL);
  ------------------
  |  Branch (379:9): [True: 0, False: 59]
  ------------------
  380|     59|    n = xmlStrlen(val);
  381|       |
  382|     59|    if (n == 0) return(str);
  ------------------
  |  Branch (382:9): [True: 0, False: 59]
  ------------------
  383|  46.9k|    while (*str != 0) { /* non input consuming */
  ------------------
  |  Branch (383:12): [True: 46.9k, False: 45]
  ------------------
  384|  46.9k|        if (casemap[*str] == casemap[*val])
  ------------------
  |  Branch (384:13): [True: 832, False: 46.0k]
  ------------------
  385|    832|            if (!xmlStrncasecmp(str, val, n)) return(str);
  ------------------
  |  Branch (385:17): [True: 14, False: 818]
  ------------------
  386|  46.8k|        str++;
  387|  46.8k|    }
  388|     45|    return(NULL);
  389|     59|}
xmlStrlen:
  428|  23.1k|xmlStrlen(const xmlChar *str) {
  429|  23.1k|    size_t len = str ? strlen((const char *)str) : 0;
  ------------------
  |  Branch (429:18): [True: 23.1k, False: 0]
  ------------------
  430|  23.1k|    return(len > INT_MAX ? 0 : len);
  ------------------
  |  Branch (430:12): [True: 0, False: 23.1k]
  ------------------
  431|  23.1k|}
xmlStrcat:
  524|  6.68k|xmlStrcat(xmlChar *cur, const xmlChar *add) {
  525|  6.68k|    const xmlChar *p = add;
  526|       |
  527|  6.68k|    if (add == NULL) return(cur);
  ------------------
  |  Branch (527:9): [True: 0, False: 6.68k]
  ------------------
  528|  6.68k|    if (cur == NULL)
  ------------------
  |  Branch (528:9): [True: 6.68k, False: 0]
  ------------------
  529|  6.68k|        return(xmlStrdup(add));
  530|       |
  531|      0|    while (*p != 0) p++; /* non input consuming */
  ------------------
  |  Branch (531:12): [True: 0, False: 0]
  ------------------
  532|      0|    return(xmlStrncat(cur, add, p - add));
  533|  6.68k|}
xmlGetUTF8Char:
  708|  69.0k|xmlGetUTF8Char(const unsigned char *utf, int *len) {
  709|  69.0k|    unsigned int c;
  710|       |
  711|  69.0k|    if (utf == NULL)
  ------------------
  |  Branch (711:9): [True: 0, False: 69.0k]
  ------------------
  712|      0|        goto error;
  713|  69.0k|    if (len == NULL)
  ------------------
  |  Branch (713:9): [True: 0, False: 69.0k]
  ------------------
  714|      0|        goto error;
  715|       |
  716|  69.0k|    c = utf[0];
  717|  69.0k|    if (c < 0x80) {
  ------------------
  |  Branch (717:9): [True: 68.8k, False: 180]
  ------------------
  718|  68.8k|        if (*len < 1)
  ------------------
  |  Branch (718:13): [True: 0, False: 68.8k]
  ------------------
  719|      0|            goto error;
  720|       |        /* 1-byte code */
  721|  68.8k|        *len = 1;
  722|  68.8k|    } else {
  723|    180|        if ((*len < 2) || ((utf[1] & 0xc0) != 0x80))
  ------------------
  |  Branch (723:13): [True: 2, False: 178]
  |  Branch (723:27): [True: 44, False: 134]
  ------------------
  724|     46|            goto error;
  725|    134|        if (c < 0xe0) {
  ------------------
  |  Branch (725:13): [True: 134, False: 0]
  ------------------
  726|    134|            if (c < 0xc2)
  ------------------
  |  Branch (726:17): [True: 0, False: 134]
  ------------------
  727|      0|                goto error;
  728|       |            /* 2-byte code */
  729|    134|            *len = 2;
  730|    134|            c = (c & 0x1f) << 6;
  731|    134|            c |= utf[1] & 0x3f;
  732|    134|        } else {
  733|      0|            if ((*len < 3) || ((utf[2] & 0xc0) != 0x80))
  ------------------
  |  Branch (733:17): [True: 0, False: 0]
  |  Branch (733:31): [True: 0, False: 0]
  ------------------
  734|      0|                goto error;
  735|      0|            if (c < 0xf0) {
  ------------------
  |  Branch (735:17): [True: 0, False: 0]
  ------------------
  736|       |                /* 3-byte code */
  737|      0|                *len = 3;
  738|      0|                c = (c & 0xf) << 12;
  739|      0|                c |= (utf[1] & 0x3f) << 6;
  740|      0|                c |= utf[2] & 0x3f;
  741|      0|                if ((c < 0x800) || ((c >= 0xd800) && (c < 0xe000)))
  ------------------
  |  Branch (741:21): [True: 0, False: 0]
  |  Branch (741:37): [True: 0, False: 0]
  |  Branch (741:54): [True: 0, False: 0]
  ------------------
  742|      0|                    goto error;
  743|      0|            } else {
  744|      0|                if ((*len < 4) || ((utf[3] & 0xc0) != 0x80))
  ------------------
  |  Branch (744:21): [True: 0, False: 0]
  |  Branch (744:35): [True: 0, False: 0]
  ------------------
  745|      0|                    goto error;
  746|      0|                *len = 4;
  747|       |                /* 4-byte code */
  748|      0|                c = (c & 0x7) << 18;
  749|      0|                c |= (utf[1] & 0x3f) << 12;
  750|      0|                c |= (utf[2] & 0x3f) << 6;
  751|      0|                c |= utf[3] & 0x3f;
  752|      0|                if ((c < 0x10000) || (c >= 0x110000))
  ------------------
  |  Branch (752:21): [True: 0, False: 0]
  |  Branch (752:38): [True: 0, False: 0]
  ------------------
  753|      0|                    goto error;
  754|      0|            }
  755|      0|        }
  756|    134|    }
  757|  68.9k|    return(c);
  758|       |
  759|     46|error:
  760|     46|    if (len != NULL)
  ------------------
  |  Branch (760:9): [True: 46, False: 0]
  ------------------
  761|     46|	*len = 0;
  762|     46|    return(-1);
  763|  69.0k|}

xmlInitXPathInternal:
  168|      2|xmlInitXPathInternal(void) {
  169|      2|#if defined(NAN) && defined(INFINITY)
  170|      2|    xmlXPathNAN = NAN;
  171|      2|    xmlXPathPINF = INFINITY;
  172|      2|    xmlXPathNINF = -INFINITY;
  173|       |#else
  174|       |    /* MSVC doesn't allow division by zero in constant expressions. */
  175|       |    double zero = 0.0;
  176|       |    xmlXPathNAN = 0.0 / zero;
  177|       |    xmlXPathPINF = 1.0 / zero;
  178|       |    xmlXPathNINF = -xmlXPathPINF;
  179|       |#endif
  180|      2|}

