xmlCharInRange:
  170|     73|xmlCharInRange (unsigned int val, const xmlChRangeGroup *rptr) {
  171|     73|    int low, high, mid;
  172|     73|    const xmlChSRange *sptr;
  173|     73|    const xmlChLRange *lptr;
  174|       |
  175|     73|    if (rptr == NULL) return(0);
  ------------------
  |  Branch (175:9): [True: 0, False: 73]
  ------------------
  176|     73|    if (val < 0x10000) {	/* is val in 'short' or 'long'  array? */
  ------------------
  |  Branch (176:9): [True: 73, False: 0]
  ------------------
  177|     73|	if (rptr->nbShortRange == 0)
  ------------------
  |  Branch (177:6): [True: 0, False: 73]
  ------------------
  178|      0|	    return 0;
  179|     73|	low = 0;
  180|     73|	high = rptr->nbShortRange - 1;
  181|     73|	sptr = rptr->shortRange;
  182|    365|	while (low <= high) {
  ------------------
  |  Branch (182:9): [True: 292, False: 73]
  ------------------
  183|    292|	    mid = (low + high) / 2;
  184|    292|	    if ((unsigned short) val < sptr[mid].low) {
  ------------------
  |  Branch (184:10): [True: 219, False: 73]
  ------------------
  185|    219|		high = mid - 1;
  186|    219|	    } else {
  187|     73|	        if ((unsigned short) val > sptr[mid].high) {
  ------------------
  |  Branch (187:14): [True: 73, False: 0]
  ------------------
  188|     73|		    low = mid + 1;
  189|     73|		} else {
  190|      0|		    return 1;
  191|      0|		}
  192|     73|	    }
  193|    292|	}
  194|     73|    } else {
  195|      0|	if (rptr->nbLongRange == 0) {
  ------------------
  |  Branch (195:6): [True: 0, False: 0]
  ------------------
  196|      0|	    return 0;
  197|      0|	}
  198|      0|	low = 0;
  199|      0|	high = rptr->nbLongRange - 1;
  200|      0|	lptr = rptr->longRange;
  201|      0|	while (low <= high) {
  ------------------
  |  Branch (201:9): [True: 0, False: 0]
  ------------------
  202|      0|	    mid = (low + high) / 2;
  203|      0|	    if (val < lptr[mid].low) {
  ------------------
  |  Branch (203:10): [True: 0, False: 0]
  ------------------
  204|      0|		high = mid - 1;
  205|      0|	    } else {
  206|      0|	        if (val > lptr[mid].high) {
  ------------------
  |  Branch (206:14): [True: 0, False: 0]
  ------------------
  207|      0|		    low = mid + 1;
  208|      0|		} else {
  209|      0|		    return 1;
  210|      0|		}
  211|      0|	    }
  212|      0|	}
  213|      0|    }
  214|     73|    return 0;
  215|     73|}

xmlInitDictInternal:
   99|      2|xmlInitDictInternal(void) {
  100|      2|    xmlInitMutex(&xmlDictMutex);
  101|      2|}
xmlInitRandom:
  918|      2|xmlInitRandom(void) {
  919|      2|    int var;
  920|       |
  921|      2|    xmlInitMutex(&xmlRngMutex);
  922|       |
  923|       |    /* TODO: Get seed values from system PRNG */
  924|       |
  925|      2|    globalRngState[0] = (unsigned) time(NULL) ^
  926|      2|                        HASH_ROL((unsigned) (size_t) &xmlInitRandom, 8);
  ------------------
  |  |   12|      2|#define HASH_ROL(x,n) ((x) << (n) | ((x) & 0xFFFFFFFF) >> (32 - (n)))
  ------------------
  927|      2|    globalRngState[1] = HASH_ROL((unsigned) (size_t) &xmlRngMutex, 16) ^
  ------------------
  |  |   12|      2|#define HASH_ROL(x,n) ((x) << (n) | ((x) & 0xFFFFFFFF) >> (32 - (n)))
  ------------------
  928|      2|                        HASH_ROL((unsigned) (size_t) &var, 24);
  ------------------
  |  |   12|      2|#define HASH_ROL(x,n) ((x) << (n) | ((x) & 0xFFFFFFFF) >> (32 - (n)))
  ------------------
  929|      2|}
xmlRandom:
  951|    330|xmlRandom(void) {
  952|    330|#ifdef XML_THREAD_LOCAL
  953|    330|    if (!localRngInitialized) {
  ------------------
  |  Branch (953:9): [True: 1, False: 329]
  ------------------
  954|      1|        xmlMutexLock(&xmlRngMutex);
  955|      1|        localRngState[0] = xoroshiro64ss(globalRngState);
  956|      1|        localRngState[1] = xoroshiro64ss(globalRngState);
  957|      1|        localRngInitialized = 1;
  958|      1|        xmlMutexUnlock(&xmlRngMutex);
  959|      1|    }
  960|       |
  961|    330|    return(xoroshiro64ss(localRngState));
  962|       |#else
  963|       |    unsigned ret;
  964|       |
  965|       |    xmlMutexLock(&xmlRngMutex);
  966|       |    ret = xoroshiro64ss(globalRngState);
  967|       |    xmlMutexUnlock(&xmlRngMutex);
  968|       |
  969|       |    return(ret);
  970|       |#endif
  971|    330|}
dict.c:xoroshiro64ss:
  938|    332|xoroshiro64ss(unsigned *s) {
  939|    332|    unsigned s0 = s[0];
  940|    332|    unsigned s1 = s[1];
  941|    332|    unsigned result = HASH_ROL(s0 * 0x9E3779BB, 5) * 5;
  ------------------
  |  |   12|    332|#define HASH_ROL(x,n) ((x) << (n) | ((x) & 0xFFFFFFFF) >> (32 - (n)))
  ------------------
  942|       |
  943|    332|    s1 ^= s0;
  944|    332|    s[0] = HASH_ROL(s0, 26) ^ s1 ^ (s1 << 9);
  ------------------
  |  |   12|    332|#define HASH_ROL(x,n) ((x) << (n) | ((x) & 0xFFFFFFFF) >> (32 - (n)))
  ------------------
  945|    332|    s[1] = HASH_ROL(s1, 13);
  ------------------
  |  |   12|    332|#define HASH_ROL(x,n) ((x) << (n) | ((x) & 0xFFFFFFFF) >> (32 - (n)))
  ------------------
  946|       |
  947|    332|    return(result & 0xFFFFFFFF);
  948|    332|}

xmlInitEncodingInternal:
 1470|      2|xmlInitEncodingInternal(void) {
 1471|      2|    unsigned short int tst = 0x1234;
 1472|      2|    unsigned char *ptr = (unsigned char *) &tst;
 1473|       |
 1474|      2|    if (*ptr == 0x12) xmlLittleEndian = 0;
  ------------------
  |  Branch (1474:9): [True: 0, False: 2]
  ------------------
 1475|      2|    else xmlLittleEndian = 1;
 1476|      2|}

xmlSetGenericErrorFunc:
  114|      2|xmlSetGenericErrorFunc(void *ctx, xmlGenericErrorFunc handler) {
  115|      2|    xmlGenericErrorContext = ctx;
  ------------------
  |  |  876|      2|  #define xmlGenericErrorContext XML_GLOBAL_MACRO(xmlGenericErrorContext)
  |  |  ------------------
  |  |  |  |  500|      2|  #define XML_GLOBAL_MACRO(name) (*__##name())
  |  |  ------------------
  ------------------
  116|      2|    if (handler != NULL)
  ------------------
  |  Branch (116:9): [True: 2, False: 0]
  ------------------
  117|      2|	xmlGenericError = handler;
  ------------------
  |  |  875|      2|  #define xmlGenericError XML_GLOBAL_MACRO(xmlGenericError)
  |  |  ------------------
  |  |  |  |  500|      2|  #define XML_GLOBAL_MACRO(name) (*__##name())
  |  |  ------------------
  ------------------
  118|      0|    else
  119|      0|	xmlGenericError = xmlGenericErrorDefaultFunc;
  ------------------
  |  |  875|      0|  #define xmlGenericError XML_GLOBAL_MACRO(xmlGenericError)
  |  |  ------------------
  |  |  |  |  500|      0|  #define XML_GLOBAL_MACRO(name) (*__##name())
  |  |  ------------------
  ------------------
  120|      2|}
__xmlRaiseError:
  475|    869|{
  476|    869|    xmlParserCtxtPtr ctxt = NULL;
  477|    869|    xmlNodePtr node = (xmlNodePtr) nod;
  478|    869|    char *str = NULL;
  479|    869|    xmlParserInputPtr input = NULL;
  480|    869|    xmlErrorPtr to = &xmlLastError;
  ------------------
  |  |  874|    869|  #define xmlLastError XML_GLOBAL_MACRO(xmlLastError)
  |  |  ------------------
  |  |  |  |  500|    869|  #define XML_GLOBAL_MACRO(name) (*__##name())
  |  |  ------------------
  ------------------
  481|    869|    xmlNodePtr baseptr = NULL;
  482|       |
  483|    869|    if (code == XML_ERR_OK)
  ------------------
  |  Branch (483:9): [True: 0, False: 869]
  ------------------
  484|      0|        return;
  485|    869|    if ((xmlGetWarningsDefaultValue == 0) && (level == XML_ERR_WARNING))
  ------------------
  |  |  865|    869|    XML_GLOBAL_MACRO(xmlGetWarningsDefaultValue)
  |  |  ------------------
  |  |  |  |  500|    869|  #define XML_GLOBAL_MACRO(name) (*__##name())
  |  |  ------------------
  ------------------
  |  Branch (485:9): [True: 0, False: 869]
  |  Branch (485:46): [True: 0, False: 0]
  ------------------
  486|      0|        return;
  487|    869|    if ((domain == XML_FROM_PARSER) || (domain == XML_FROM_HTML) ||
  ------------------
  |  Branch (487:9): [True: 0, False: 869]
  |  Branch (487:40): [True: 0, False: 869]
  ------------------
  488|    869|        (domain == XML_FROM_DTD) || (domain == XML_FROM_NAMESPACE) ||
  ------------------
  |  Branch (488:9): [True: 0, False: 869]
  |  Branch (488:37): [True: 0, False: 869]
  ------------------
  489|    869|	(domain == XML_FROM_IO) || (domain == XML_FROM_VALID)) {
  ------------------
  |  Branch (489:2): [True: 0, False: 869]
  |  Branch (489:29): [True: 0, False: 869]
  ------------------
  490|      0|	ctxt = (xmlParserCtxtPtr) ctx;
  491|       |
  492|      0|        if (ctxt != NULL) {
  ------------------
  |  Branch (492:13): [True: 0, False: 0]
  ------------------
  493|      0|            if (level == XML_ERR_WARNING) {
  ------------------
  |  Branch (493:17): [True: 0, False: 0]
  ------------------
  494|      0|                if (ctxt->nbWarnings >= XML_MAX_ERRORS)
  ------------------
  |  |   20|      0|#define XML_MAX_ERRORS 100
  ------------------
  |  Branch (494:21): [True: 0, False: 0]
  ------------------
  495|      0|                    return;
  496|      0|                ctxt->nbWarnings += 1;
  497|      0|            } else {
  498|      0|                if (ctxt->nbErrors >= XML_MAX_ERRORS)
  ------------------
  |  |   20|      0|#define XML_MAX_ERRORS 100
  ------------------
  |  Branch (498:21): [True: 0, False: 0]
  ------------------
  499|      0|                    return;
  500|      0|                ctxt->nbErrors += 1;
  501|      0|            }
  502|       |
  503|      0|            if ((schannel == NULL) && (ctxt->sax != NULL) &&
  ------------------
  |  Branch (503:17): [True: 0, False: 0]
  |  Branch (503:39): [True: 0, False: 0]
  ------------------
  504|      0|                (ctxt->sax->initialized == XML_SAX2_MAGIC) &&
  ------------------
  |  |  685|      0|#define XML_SAX2_MAGIC 0xDEEDBEAF
  ------------------
  |  Branch (504:17): [True: 0, False: 0]
  ------------------
  505|      0|                (ctxt->sax->serror != NULL)) {
  ------------------
  |  Branch (505:17): [True: 0, False: 0]
  ------------------
  506|      0|                schannel = ctxt->sax->serror;
  507|      0|                data = ctxt->userData;
  508|      0|            }
  509|      0|        }
  510|      0|    }
  511|       |    /*
  512|       |     * Check if structured error handler set
  513|       |     */
  514|    869|    if (schannel == NULL) {
  ------------------
  |  Branch (514:9): [True: 869, False: 0]
  ------------------
  515|    869|	schannel = xmlStructuredError;
  ------------------
  |  |  877|    869|  #define xmlStructuredError XML_GLOBAL_MACRO(xmlStructuredError)
  |  |  ------------------
  |  |  |  |  500|    869|  #define XML_GLOBAL_MACRO(name) (*__##name())
  |  |  ------------------
  ------------------
  516|       |	/*
  517|       |	 * if user has defined handler, change data ptr to user's choice
  518|       |	 */
  519|    869|	if (schannel != NULL)
  ------------------
  |  Branch (519:6): [True: 0, False: 869]
  ------------------
  520|      0|	    data = xmlStructuredErrorContext;
  ------------------
  |  |  878|      0|  #define xmlStructuredErrorContext XML_GLOBAL_MACRO(xmlStructuredErrorContext)
  |  |  ------------------
  |  |  |  |  500|      0|  #define XML_GLOBAL_MACRO(name) (*__##name())
  |  |  ------------------
  ------------------
  521|    869|    }
  522|       |    /*
  523|       |     * Formatting the message
  524|       |     */
  525|    869|    if (msg == NULL) {
  ------------------
  |  Branch (525:9): [True: 0, False: 869]
  ------------------
  526|      0|        str = (char *) xmlStrdup(BAD_CAST "No error message provided");
  ------------------
  |  |   35|      0|#define BAD_CAST (xmlChar *)
  ------------------
  527|    869|    } else {
  528|    869|        XML_GET_VAR_STR(msg, str);
  ------------------
  |  |   22|    869|#define XML_GET_VAR_STR(msg, str) {				\
  |  |   23|    869|    int       size, prev_size = -1;				\
  |  |   24|    869|    int       chars;						\
  |  |   25|    869|    char      *larger;						\
  |  |   26|    869|    va_list   ap;						\
  |  |   27|    869|								\
  |  |   28|    869|    str = (char *) xmlMalloc(150);				\
  |  |   29|    869|    if (str != NULL) {						\
  |  |  ------------------
  |  |  |  Branch (29:9): [True: 497, False: 372]
  |  |  ------------------
  |  |   30|    497|								\
  |  |   31|    497|    size = 150;							\
  |  |   32|    497|								\
  |  |   33|    992|    while (size < 64000) {					\
  |  |  ------------------
  |  |  |  Branch (33:12): [True: 992, False: 0]
  |  |  ------------------
  |  |   34|    992|	va_start(ap, msg);					\
  |  |   35|    992|	chars = vsnprintf(str, size, msg, ap);			\
  |  |   36|    992|	va_end(ap);						\
  |  |   37|    992|	if ((chars > -1) && (chars < size)) {			\
  |  |  ------------------
  |  |  |  Branch (37:6): [True: 992, False: 0]
  |  |  |  Branch (37:22): [True: 992, False: 0]
  |  |  ------------------
  |  |   38|    992|	    if (prev_size == chars) {				\
  |  |  ------------------
  |  |  |  Branch (38:10): [True: 495, False: 497]
  |  |  ------------------
  |  |   39|    495|		break;						\
  |  |   40|    497|	    } else {						\
  |  |   41|    497|		prev_size = chars;				\
  |  |   42|    497|	    }							\
  |  |   43|    992|	}							\
  |  |   44|    992|	if (chars > -1)						\
  |  |  ------------------
  |  |  |  Branch (44:6): [True: 497, False: 0]
  |  |  ------------------
  |  |   45|    497|	    size += chars + 1;					\
  |  |   46|    497|	else							\
  |  |   47|    497|	    size += 100;					\
  |  |   48|    497|	if ((larger = (char *) xmlRealloc(str, size)) == NULL) {\
  |  |  ------------------
  |  |  |  Branch (48:6): [True: 2, False: 495]
  |  |  ------------------
  |  |   49|      2|	    break;						\
  |  |   50|      2|	}							\
  |  |   51|    497|	str = larger;						\
  |  |   52|    495|    }}								\
  |  |   53|    869|}
  ------------------
  529|    869|    }
  530|       |
  531|       |    /*
  532|       |     * specific processing if a parser context is provided
  533|       |     */
  534|    869|    if (ctxt != NULL) {
  ------------------
  |  Branch (534:9): [True: 0, False: 869]
  ------------------
  535|      0|        if (file == NULL) {
  ------------------
  |  Branch (535:13): [True: 0, False: 0]
  ------------------
  536|      0|            input = ctxt->input;
  537|      0|            if ((input != NULL) && (input->filename == NULL) &&
  ------------------
  |  Branch (537:17): [True: 0, False: 0]
  |  Branch (537:36): [True: 0, False: 0]
  ------------------
  538|      0|                (ctxt->inputNr > 1)) {
  ------------------
  |  Branch (538:17): [True: 0, False: 0]
  ------------------
  539|      0|                input = ctxt->inputTab[ctxt->inputNr - 2];
  540|      0|            }
  541|      0|            if (input != NULL) {
  ------------------
  |  Branch (541:17): [True: 0, False: 0]
  ------------------
  542|      0|                file = input->filename;
  543|      0|                line = input->line;
  544|      0|                col = input->col;
  545|      0|            }
  546|      0|        }
  547|      0|        to = &ctxt->lastError;
  548|    869|    } else if ((node != NULL) && (file == NULL)) {
  ------------------
  |  Branch (548:16): [True: 0, False: 869]
  |  Branch (548:34): [True: 0, False: 0]
  ------------------
  549|      0|	int i;
  550|       |
  551|      0|	if ((node->doc != NULL) && (node->doc->URL != NULL)) {
  ------------------
  |  Branch (551:6): [True: 0, False: 0]
  |  Branch (551:29): [True: 0, False: 0]
  ------------------
  552|      0|	    baseptr = node;
  553|       |/*	    file = (const char *) node->doc->URL; */
  554|      0|	}
  555|      0|	for (i = 0;
  556|      0|	     ((i < 10) && (node != NULL) && (node->type != XML_ELEMENT_NODE));
  ------------------
  |  Branch (556:8): [True: 0, False: 0]
  |  Branch (556:20): [True: 0, False: 0]
  |  Branch (556:38): [True: 0, False: 0]
  ------------------
  557|      0|	     i++)
  558|      0|	     node = node->parent;
  559|      0|        if ((baseptr == NULL) && (node != NULL) &&
  ------------------
  |  Branch (559:13): [True: 0, False: 0]
  |  Branch (559:34): [True: 0, False: 0]
  ------------------
  560|      0|	    (node->doc != NULL) && (node->doc->URL != NULL))
  ------------------
  |  Branch (560:6): [True: 0, False: 0]
  |  Branch (560:29): [True: 0, False: 0]
  ------------------
  561|      0|	    baseptr = node;
  562|       |
  563|      0|	if ((node != NULL) && (node->type == XML_ELEMENT_NODE))
  ------------------
  |  Branch (563:6): [True: 0, False: 0]
  |  Branch (563:24): [True: 0, False: 0]
  ------------------
  564|      0|	    line = node->line;
  565|      0|	if ((line == 0) || (line == 65535))
  ------------------
  |  Branch (565:6): [True: 0, False: 0]
  |  Branch (565:21): [True: 0, False: 0]
  ------------------
  566|      0|	    line = xmlGetLineNo(node);
  567|      0|    }
  568|       |
  569|       |    /*
  570|       |     * Save the information about the error
  571|       |     */
  572|    869|    xmlResetError(to);
  573|    869|    to->domain = domain;
  574|    869|    to->code = code;
  575|    869|    to->message = str;
  576|    869|    to->level = level;
  577|    869|    if (file != NULL)
  ------------------
  |  Branch (577:9): [True: 0, False: 869]
  ------------------
  578|      0|        to->file = (char *) xmlStrdup((const xmlChar *) file);
  579|    869|    else if (baseptr != NULL) {
  ------------------
  |  Branch (579:14): [True: 0, False: 869]
  ------------------
  580|      0|#ifdef LIBXML_XINCLUDE_ENABLED
  581|       |	/*
  582|       |	 * We check if the error is within an XInclude section and,
  583|       |	 * if so, attempt to print out the href of the XInclude instead
  584|       |	 * of the usual "base" (doc->URL) for the node (bug 152623).
  585|       |	 */
  586|      0|        xmlNodePtr prev = baseptr;
  587|      0|        char *href = NULL;
  588|      0|	int inclcount = 0;
  589|      0|	while (prev != NULL) {
  ------------------
  |  Branch (589:9): [True: 0, False: 0]
  ------------------
  590|      0|	    if (prev->prev == NULL)
  ------------------
  |  Branch (590:10): [True: 0, False: 0]
  ------------------
  591|      0|	        prev = prev->parent;
  592|      0|	    else {
  593|      0|	        prev = prev->prev;
  594|      0|		if (prev->type == XML_XINCLUDE_START) {
  ------------------
  |  Branch (594:7): [True: 0, False: 0]
  ------------------
  595|      0|		    if (inclcount > 0) {
  ------------------
  |  Branch (595:11): [True: 0, False: 0]
  ------------------
  596|      0|                        --inclcount;
  597|      0|                    } else {
  598|      0|                        href = (char *) xmlGetProp(prev, BAD_CAST "href");
  ------------------
  |  |   35|      0|#define BAD_CAST (xmlChar *)
  ------------------
  599|      0|                        if (href != NULL)
  ------------------
  |  Branch (599:29): [True: 0, False: 0]
  ------------------
  600|      0|		            break;
  601|      0|                    }
  602|      0|		} else if (prev->type == XML_XINCLUDE_END)
  ------------------
  |  Branch (602:14): [True: 0, False: 0]
  ------------------
  603|      0|		    inclcount++;
  604|      0|	    }
  605|      0|	}
  606|      0|        if (href != NULL)
  ------------------
  |  Branch (606:13): [True: 0, False: 0]
  ------------------
  607|      0|            to->file = href;
  608|      0|	else
  609|      0|#endif
  610|      0|	    to->file = (char *) xmlStrdup(baseptr->doc->URL);
  611|      0|	if ((to->file == NULL) && (node != NULL) && (node->doc != NULL)) {
  ------------------
  |  Branch (611:6): [True: 0, False: 0]
  |  Branch (611:28): [True: 0, False: 0]
  |  Branch (611:46): [True: 0, False: 0]
  ------------------
  612|      0|	    to->file = (char *) xmlStrdup(node->doc->URL);
  613|      0|	}
  614|      0|    }
  615|    869|    to->line = line;
  616|    869|    if (str1 != NULL)
  ------------------
  |  Branch (616:9): [True: 869, False: 0]
  ------------------
  617|    869|        to->str1 = (char *) xmlStrdup((const xmlChar *) str1);
  618|    869|    if (str2 != NULL)
  ------------------
  |  Branch (618:9): [True: 867, False: 2]
  ------------------
  619|    867|        to->str2 = (char *) xmlStrdup((const xmlChar *) str2);
  620|    869|    if (str3 != NULL)
  ------------------
  |  Branch (620:9): [True: 0, False: 869]
  ------------------
  621|      0|        to->str3 = (char *) xmlStrdup((const xmlChar *) str3);
  622|    869|    to->int1 = int1;
  623|    869|    to->int2 = col;
  624|    869|    to->node = node;
  625|    869|    to->ctxt = ctx;
  626|       |
  627|    869|    if (to != &xmlLastError)
  ------------------
  |  |  874|    869|  #define xmlLastError XML_GLOBAL_MACRO(xmlLastError)
  |  |  ------------------
  |  |  |  |  500|    869|  #define XML_GLOBAL_MACRO(name) (*__##name())
  |  |  ------------------
  ------------------
  |  Branch (627:9): [True: 0, False: 869]
  ------------------
  628|      0|        xmlCopyError(to,&xmlLastError);
  ------------------
  |  |  874|      0|  #define xmlLastError XML_GLOBAL_MACRO(xmlLastError)
  |  |  ------------------
  |  |  |  |  500|      0|  #define XML_GLOBAL_MACRO(name) (*__##name())
  |  |  ------------------
  ------------------
  629|       |
  630|    869|    if (schannel != NULL) {
  ------------------
  |  Branch (630:9): [True: 0, False: 869]
  ------------------
  631|      0|	schannel(data, to);
  632|      0|	return;
  633|      0|    }
  634|       |
  635|       |    /*
  636|       |     * Find the callback channel if channel param is NULL
  637|       |     */
  638|    869|    if ((ctxt != NULL) && (channel == NULL) &&
  ------------------
  |  Branch (638:9): [True: 0, False: 869]
  |  Branch (638:27): [True: 0, False: 0]
  ------------------
  639|    869|        (xmlStructuredError == NULL) && (ctxt->sax != NULL)) {
  ------------------
  |  |  877|      0|  #define xmlStructuredError XML_GLOBAL_MACRO(xmlStructuredError)
  |  |  ------------------
  |  |  |  |  500|      0|  #define XML_GLOBAL_MACRO(name) (*__##name())
  |  |  ------------------
  ------------------
  |  Branch (639:9): [True: 0, False: 0]
  |  Branch (639:41): [True: 0, False: 0]
  ------------------
  640|      0|        if (level == XML_ERR_WARNING)
  ------------------
  |  Branch (640:13): [True: 0, False: 0]
  ------------------
  641|      0|	    channel = ctxt->sax->warning;
  642|      0|        else
  643|      0|	    channel = ctxt->sax->error;
  644|      0|	data = ctxt->userData;
  645|    869|    } else if (channel == NULL) {
  ------------------
  |  Branch (645:16): [True: 869, False: 0]
  ------------------
  646|    869|	channel = xmlGenericError;
  ------------------
  |  |  875|    869|  #define xmlGenericError XML_GLOBAL_MACRO(xmlGenericError)
  |  |  ------------------
  |  |  |  |  500|    869|  #define XML_GLOBAL_MACRO(name) (*__##name())
  |  |  ------------------
  ------------------
  647|    869|	if (ctxt != NULL) {
  ------------------
  |  Branch (647:6): [True: 0, False: 869]
  ------------------
  648|      0|	    data = ctxt;
  649|    869|	} else {
  650|    869|	    data = xmlGenericErrorContext;
  ------------------
  |  |  876|    869|  #define xmlGenericErrorContext XML_GLOBAL_MACRO(xmlGenericErrorContext)
  |  |  ------------------
  |  |  |  |  500|    869|  #define XML_GLOBAL_MACRO(name) (*__##name())
  |  |  ------------------
  ------------------
  651|    869|	}
  652|    869|    }
  653|    869|    if (channel == NULL)
  ------------------
  |  Branch (653:9): [True: 0, False: 869]
  ------------------
  654|      0|        return;
  655|       |
  656|    869|    if ((channel == xmlParserError) ||
  ------------------
  |  Branch (656:9): [True: 0, False: 869]
  ------------------
  657|    869|        (channel == xmlParserWarning) ||
  ------------------
  |  Branch (657:9): [True: 0, False: 869]
  ------------------
  658|    869|	(channel == xmlParserValidityError) ||
  ------------------
  |  Branch (658:2): [True: 0, False: 869]
  ------------------
  659|    869|	(channel == xmlParserValidityWarning))
  ------------------
  |  Branch (659:2): [True: 0, False: 869]
  ------------------
  660|      0|	xmlReportError(to, ctxt, str, NULL, NULL);
  661|    869|    else if (((void(*)(void)) channel == (void(*)(void)) fprintf) ||
  ------------------
  |  Branch (661:14): [True: 0, False: 869]
  ------------------
  662|    869|             (channel == xmlGenericErrorDefaultFunc))
  ------------------
  |  Branch (662:14): [True: 0, False: 869]
  ------------------
  663|      0|	xmlReportError(to, ctxt, str, channel, data);
  664|    869|    else
  665|    869|	channel(data, "%s", str);
  666|    869|}
xmlResetError:
  901|  1.04k|{
  902|  1.04k|    if (err == NULL)
  ------------------
  |  Branch (902:9): [True: 0, False: 1.04k]
  ------------------
  903|      0|        return;
  904|  1.04k|    if (err->code == XML_ERR_OK)
  ------------------
  |  Branch (904:9): [True: 173, False: 869]
  ------------------
  905|    173|        return;
  906|    869|    if (err->message != NULL)
  ------------------
  |  Branch (906:9): [True: 497, False: 372]
  ------------------
  907|    497|        xmlFree(err->message);
  908|    869|    if (err->file != NULL)
  ------------------
  |  Branch (908:9): [True: 0, False: 869]
  ------------------
  909|      0|        xmlFree(err->file);
  910|    869|    if (err->str1 != NULL)
  ------------------
  |  Branch (910:9): [True: 495, False: 374]
  ------------------
  911|    495|        xmlFree(err->str1);
  912|    869|    if (err->str2 != NULL)
  ------------------
  |  Branch (912:9): [True: 492, False: 377]
  ------------------
  913|    492|        xmlFree(err->str2);
  914|    869|    if (err->str3 != NULL)
  ------------------
  |  Branch (914:9): [True: 0, False: 869]
  ------------------
  915|      0|        xmlFree(err->str3);
  916|    869|    memset(err, 0, sizeof(xmlError));
  917|    869|    err->code = XML_ERR_OK;
  918|    869|}
xmlResetLastError:
  928|    330|{
  929|    330|    if (xmlLastError.code == XML_ERR_OK)
  ------------------
  |  |  874|    330|  #define xmlLastError XML_GLOBAL_MACRO(xmlLastError)
  |  |  ------------------
  |  |  |  |  500|    330|  #define XML_GLOBAL_MACRO(name) (*__##name())
  |  |  ------------------
  ------------------
  |  Branch (929:9): [True: 157, False: 173]
  ------------------
  930|    157|        return;
  931|    173|    xmlResetError(&xmlLastError);
  ------------------
  |  |  874|    173|  #define xmlLastError XML_GLOBAL_MACRO(xmlLastError)
  |  |  ------------------
  |  |  |  |  500|    173|  #define XML_GLOBAL_MACRO(name) (*__##name())
  |  |  ------------------
  ------------------
  932|    173|}

xmlFuzzErrorFunc:
   56|    869|                 ...) {
   57|    869|}
xmlFuzzMemSetup:
  103|      2|xmlFuzzMemSetup(void) {
  104|      2|    xmlMemSetup(free, xmlFuzzMalloc, xmlFuzzRealloc, xmlMemStrdup);
  105|      2|}
xmlFuzzMemSetLimit:
  108|    660|xmlFuzzMemSetLimit(size_t limit) {
  109|    660|    fuzzNumAllocs = 0;
  110|    660|    fuzzMaxAllocs = limit ? limit + XML_FUZZ_MALLOC_OFFSET : 0;
  ------------------
  |  |   69|     84|#define XML_FUZZ_MALLOC_OFFSET  0
  ------------------
  |  Branch (110:21): [True: 84, False: 576]
  ------------------
  111|    660|    fuzzAllocFailed = 0;
  112|    660|}
xmlFuzzMallocFailed:
  115|    330|xmlFuzzMallocFailed(void) {
  116|    330|    return fuzzAllocFailed;
  117|    330|}
xmlFuzzDataInit:
  125|    330|xmlFuzzDataInit(const char *data, size_t size) {
  126|    330|    fuzzData.data = data;
  127|    330|    fuzzData.size = size;
  128|    330|    fuzzData.ptr = data;
  129|    330|    fuzzData.remaining = size;
  130|       |
  131|    330|    fuzzData.outBuf = xmlMalloc(size + 1);
  132|    330|    fuzzData.outPtr = fuzzData.outBuf;
  133|       |
  134|    330|    fuzzData.entities = xmlHashCreate(8);
  135|    330|    fuzzData.mainUrl = NULL;
  136|    330|    fuzzData.mainEntity = NULL;
  137|    330|}
xmlFuzzDataCleanup:
  145|    330|xmlFuzzDataCleanup(void) {
  146|    330|    xmlFree(fuzzData.outBuf);
  147|    330|    xmlHashFree(fuzzData.entities, xmlHashDefaultDeallocator);
  148|    330|}
xmlFuzzReadInt:
  181|    330|xmlFuzzReadInt(int size) {
  182|    330|    size_t ret = 0;
  183|       |
  184|  1.64k|    while ((size > 0) && (fuzzData.remaining > 0)) {
  ------------------
  |  Branch (184:12): [True: 1.31k, False: 328]
  |  Branch (184:26): [True: 1.31k, False: 2]
  ------------------
  185|  1.31k|        unsigned char c = (unsigned char) *fuzzData.ptr++;
  186|  1.31k|        fuzzData.remaining--;
  187|  1.31k|        ret = (ret << 8) | c;
  188|  1.31k|        size--;
  189|  1.31k|    }
  190|       |
  191|    330|    return ret;
  192|    330|}
xmlFuzzReadString:
  245|    330|xmlFuzzReadString(size_t *size) {
  246|    330|    const char *out = fuzzData.outPtr;
  247|       |
  248|  21.3k|    while (fuzzData.remaining > 0) {
  ------------------
  |  Branch (248:12): [True: 20.9k, False: 330]
  ------------------
  249|  20.9k|        int c = *fuzzData.ptr++;
  250|  20.9k|        fuzzData.remaining--;
  251|       |
  252|  20.9k|        if ((c == '\\') && (fuzzData.remaining > 0)) {
  ------------------
  |  Branch (252:13): [True: 1.70k, False: 19.2k]
  |  Branch (252:28): [True: 1.69k, False: 13]
  ------------------
  253|  1.69k|            int c2 = *fuzzData.ptr;
  254|       |
  255|  1.69k|            if (c2 == '\n') {
  ------------------
  |  Branch (255:17): [True: 0, False: 1.69k]
  ------------------
  256|      0|                fuzzData.ptr++;
  257|      0|                fuzzData.remaining--;
  258|      0|                if (size != NULL)
  ------------------
  |  Branch (258:21): [True: 0, False: 0]
  ------------------
  259|      0|                    *size = fuzzData.outPtr - out;
  260|      0|                *fuzzData.outPtr++ = '\0';
  261|      0|                return(out);
  262|      0|            }
  263|  1.69k|            if (c2 == '\\') {
  ------------------
  |  Branch (263:17): [True: 23, False: 1.67k]
  ------------------
  264|     23|                fuzzData.ptr++;
  265|     23|                fuzzData.remaining--;
  266|     23|            }
  267|  1.69k|        }
  268|       |
  269|  20.9k|        *fuzzData.outPtr++ = c;
  270|  20.9k|    }
  271|       |
  272|    330|    if (fuzzData.outPtr > out) {
  ------------------
  |  Branch (272:9): [True: 327, False: 3]
  ------------------
  273|    327|        if (size != NULL)
  ------------------
  |  Branch (273:13): [True: 0, False: 327]
  ------------------
  274|      0|            *size = fuzzData.outPtr - out;
  275|    327|        *fuzzData.outPtr++ = '\0';
  276|    327|        return(out);
  277|    327|    }
  278|       |
  279|      3|    if (size != NULL)
  ------------------
  |  Branch (279:9): [True: 0, False: 3]
  ------------------
  280|      0|        *size = 0;
  281|      3|    return(NULL);
  282|    330|}
fuzz.c:xmlFuzzMalloc:
   73|  38.7k|xmlFuzzMalloc(size_t size) {
   74|  38.7k|    if (fuzzMaxAllocs > 0) {
  ------------------
  |  Branch (74:9): [True: 5.31k, False: 33.4k]
  ------------------
   75|  5.31k|        if (fuzzNumAllocs >= fuzzMaxAllocs - 1) {
  ------------------
  |  Branch (75:13): [True: 1.24k, False: 4.07k]
  ------------------
   76|       |#if XML_FUZZ_MALLOC_ABORT
   77|       |            abort();
   78|       |#endif
   79|  1.24k|            fuzzAllocFailed = 1;
   80|  1.24k|            return(NULL);
   81|  1.24k|        }
   82|  4.07k|        fuzzNumAllocs += 1;
   83|  4.07k|    }
   84|  37.5k|    return malloc(size);
   85|  38.7k|}
fuzz.c:xmlFuzzRealloc:
   88|  3.07k|xmlFuzzRealloc(void *ptr, size_t size) {
   89|  3.07k|    if (fuzzMaxAllocs > 0) {
  ------------------
  |  Branch (89:9): [True: 381, False: 2.69k]
  ------------------
   90|    381|        if (fuzzNumAllocs >= fuzzMaxAllocs - 1) {
  ------------------
  |  Branch (90:13): [True: 12, False: 369]
  ------------------
   91|       |#if XML_FUZZ_MALLOC_ABORT
   92|       |            abort();
   93|       |#endif
   94|     12|            fuzzAllocFailed = 1;
   95|     12|            return(NULL);
   96|     12|        }
   97|    369|        fuzzNumAllocs += 1;
   98|    369|    }
   99|  3.06k|    return realloc(ptr, size);
  100|  3.07k|}

LLVMFuzzerInitialize:
   14|      2|                     char ***argv ATTRIBUTE_UNUSED) {
   15|      2|    xmlFuzzMemSetup();
   16|      2|    xmlSetGenericErrorFunc(NULL, xmlFuzzErrorFunc);
   17|       |
   18|      2|    return 0;
   19|      2|}
LLVMFuzzerTestOneInput:
   22|    355|LLVMFuzzerTestOneInput(const char *data, size_t size) {
   23|    355|    xmlRegexpPtr regexp;
   24|    355|    size_t maxAlloc;
   25|    355|    const char *str1;
   26|       |
   27|    355|    if (size > 200)
  ------------------
  |  Branch (27:9): [True: 25, False: 330]
  ------------------
   28|     25|        return(0);
   29|       |
   30|    330|    xmlFuzzDataInit(data, size);
   31|    330|    maxAlloc = xmlFuzzReadInt(4) % (size * 8 + 1);
   32|    330|    str1 = xmlFuzzReadString(NULL);
   33|       |
   34|    330|    xmlFuzzMemSetLimit(maxAlloc);
   35|    330|    regexp = xmlRegexpCompile(BAD_CAST str1);
  ------------------
  |  |   35|    330|#define BAD_CAST (xmlChar *)
  ------------------
   36|    330|    if (xmlFuzzMallocFailed() && regexp != NULL) {
  ------------------
  |  Branch (36:9): [True: 45, False: 285]
  |  Branch (36:34): [True: 0, False: 45]
  ------------------
   37|      0|        fprintf(stderr, "malloc failure not reported\n");
   38|      0|        abort();
   39|      0|    }
   40|       |    /* xmlRegexpExec has pathological performance in too many cases. */
   41|       |#if 0
   42|       |    xmlRegexpExec(regexp, BAD_CAST str2);
   43|       |#endif
   44|    330|    xmlRegFreeRegexp(regexp);
   45|       |
   46|    330|    xmlFuzzMemSetLimit(0);
   47|    330|    xmlFuzzDataCleanup();
   48|    330|    xmlResetLastError();
   49|       |
   50|    330|    return 0;
   51|    330|}

xmlInitGlobalsInternal:
  566|      2|void xmlInitGlobalsInternal(void) {
  567|      2|    xmlInitMutex(&xmlThrDefMutex);
  568|       |
  569|      2|#ifdef HAVE_POSIX_THREADS
  570|      2|#ifdef XML_PTHREAD_WEAK
  571|      2|    if (libxml_is_threaded == -1)
  ------------------
  |  Branch (571:9): [True: 2, False: 0]
  ------------------
  572|      2|        libxml_is_threaded =
  573|      2|            (pthread_getspecific != NULL) &&
  ------------------
  |  Branch (573:13): [True: 2, False: 0]
  ------------------
  574|      2|            (pthread_setspecific != NULL) &&
  ------------------
  |  Branch (574:13): [True: 2, False: 0]
  ------------------
  575|      2|            (pthread_key_create != NULL) &&
  ------------------
  |  Branch (575:13): [True: 2, False: 0]
  ------------------
  576|      2|            (pthread_key_delete != NULL) &&
  ------------------
  |  Branch (576:13): [True: 2, False: 0]
  ------------------
  577|       |            /*
  578|       |             * pthread_equal can be inline, resuting in -Waddress warnings.
  579|       |             * Let's assume it's available if all the other functions are.
  580|       |             */
  581|       |            /* (pthread_equal != NULL) && */
  582|      2|            (pthread_self != NULL);
  ------------------
  |  Branch (582:13): [True: 2, False: 0]
  ------------------
  583|      2|    if (libxml_is_threaded == 0)
  ------------------
  |  Branch (583:9): [True: 0, False: 2]
  ------------------
  584|      0|        return;
  585|      2|#endif /* XML_PTHREAD_WEAK */
  586|      2|    pthread_key_create(&globalkey, xmlFreeGlobalState);
  587|      2|    mainthread = pthread_self();
  588|       |#elif defined(HAVE_WIN32_THREADS)
  589|       |#ifndef USE_TLS
  590|       |    globalkey = TlsAlloc();
  591|       |#endif
  592|       |    mainthread = GetCurrentThreadId();
  593|       |#endif
  594|      2|}
__xmlLastError:
  892|  2.24k|    type *__##name(void) { \
  893|  2.24k|        if (IS_MAIN_THREAD) \
  ------------------
  |  |   62|  2.24k|#define IS_MAIN_THREAD (xmlIsMainThreadInternal())
  |  |  ------------------
  |  |  |  Branch (62:24): [True: 2.24k, False: 0]
  |  |  ------------------
  ------------------
  894|  2.24k|            return (&name); \
  895|  2.24k|        else \
  896|  2.24k|            return (&xmlGetThreadLocalStorage(0)->gs_##name); \
  897|  2.24k|    }
__xmlGenericError:
  892|    871|    type *__##name(void) { \
  893|    871|        if (IS_MAIN_THREAD) \
  ------------------
  |  |   62|    871|#define IS_MAIN_THREAD (xmlIsMainThreadInternal())
  |  |  ------------------
  |  |  |  Branch (62:24): [True: 871, False: 0]
  |  |  ------------------
  ------------------
  894|    871|            return (&name); \
  895|    871|        else \
  896|    871|            return (&xmlGetThreadLocalStorage(0)->gs_##name); \
  897|    871|    }
__xmlGenericErrorContext:
  892|    871|    type *__##name(void) { \
  893|    871|        if (IS_MAIN_THREAD) \
  ------------------
  |  |   62|    871|#define IS_MAIN_THREAD (xmlIsMainThreadInternal())
  |  |  ------------------
  |  |  |  Branch (62:24): [True: 871, False: 0]
  |  |  ------------------
  ------------------
  894|    871|            return (&name); \
  895|    871|        else \
  896|    871|            return (&xmlGetThreadLocalStorage(0)->gs_##name); \
  897|    871|    }
__xmlStructuredError:
  892|    869|    type *__##name(void) { \
  893|    869|        if (IS_MAIN_THREAD) \
  ------------------
  |  |   62|    869|#define IS_MAIN_THREAD (xmlIsMainThreadInternal())
  |  |  ------------------
  |  |  |  Branch (62:24): [True: 869, False: 0]
  |  |  ------------------
  ------------------
  894|    869|            return (&name); \
  895|    869|        else \
  896|    869|            return (&xmlGetThreadLocalStorage(0)->gs_##name); \
  897|    869|    }
__xmlGetWarningsDefaultValue:
  892|    869|    type *__##name(void) { \
  893|    869|        if (IS_MAIN_THREAD) \
  ------------------
  |  |   62|    869|#define IS_MAIN_THREAD (xmlIsMainThreadInternal())
  |  |  ------------------
  |  |  |  Branch (62:24): [True: 869, False: 0]
  |  |  ------------------
  ------------------
  894|    869|            return (&name); \
  895|    869|        else \
  896|    869|            return (&xmlGetThreadLocalStorage(0)->gs_##name); \
  897|    869|    }
globals.c:xmlIsMainThreadInternal:
  660|  5.72k|xmlIsMainThreadInternal(void) {
  661|  5.72k|    if (parserInitialized == 0) {
  ------------------
  |  Branch (661:9): [True: 2, False: 5.71k]
  ------------------
  662|      2|        xmlInitParser();
  663|      2|        parserInitialized = 1;
  664|      2|    }
  665|       |
  666|  5.72k|#ifdef HAVE_POSIX_THREADS
  667|  5.72k|#ifdef XML_PTHREAD_WEAK
  668|  5.72k|    if (libxml_is_threaded == 0)
  ------------------
  |  Branch (668:9): [True: 0, False: 5.72k]
  ------------------
  669|      0|        return (1);
  670|  5.72k|#endif
  671|  5.72k|    return (pthread_equal(mainthread, pthread_self()));
  672|       |#elif defined HAVE_WIN32_THREADS
  673|       |    return (mainthread == GetCurrentThreadId());
  674|       |#else
  675|       |    return (1);
  676|       |#endif
  677|  5.72k|}

xmlHashCreate:
  160|    330|xmlHashCreate(int size) {
  161|    330|    xmlHashTablePtr hash;
  162|       |
  163|    330|    xmlInitParser();
  164|       |
  165|    330|    hash = xmlMalloc(sizeof(*hash));
  166|    330|    if (hash == NULL)
  ------------------
  |  Branch (166:9): [True: 0, False: 330]
  ------------------
  167|      0|        return(NULL);
  168|    330|    hash->dict = NULL;
  169|    330|    hash->size = 0;
  170|    330|    hash->table = NULL;
  171|    330|    hash->nbElems = 0;
  172|    330|    hash->randomSeed = xmlRandom();
  173|    330|#ifdef FUZZING_BUILD_MODE_UNSAFE_FOR_PRODUCTION
  174|    330|    hash->randomSeed = 0;
  175|    330|#endif
  176|       |
  177|       |    /*
  178|       |     * Unless a larger size is passed, the backing table is created
  179|       |     * lazily with MIN_HASH_SIZE capacity. In practice, there are many
  180|       |     * hash tables which are never filled.
  181|       |     */
  182|    330|    if (size > MIN_HASH_SIZE) {
  ------------------
  |  |   30|    330|#define MIN_HASH_SIZE 8
  ------------------
  |  Branch (182:9): [True: 0, False: 330]
  ------------------
  183|      0|        unsigned newSize = MIN_HASH_SIZE * 2;
  ------------------
  |  |   30|      0|#define MIN_HASH_SIZE 8
  ------------------
  184|       |
  185|      0|        while ((newSize < (unsigned) size) && (newSize < MAX_HASH_SIZE))
  ------------------
  |  |   31|      0|#define MAX_HASH_SIZE (1u << 31)
  ------------------
  |  Branch (185:16): [True: 0, False: 0]
  |  Branch (185:47): [True: 0, False: 0]
  ------------------
  186|      0|            newSize *= 2;
  187|       |
  188|      0|        if (xmlHashGrow(hash, newSize) != 0) {
  ------------------
  |  Branch (188:13): [True: 0, False: 0]
  ------------------
  189|      0|            xmlFree(hash);
  190|      0|            return(NULL);
  191|      0|        }
  192|      0|    }
  193|       |
  194|    330|    return(hash);
  195|    330|}
xmlHashFree:
  229|    330|xmlHashFree(xmlHashTablePtr hash, xmlHashDeallocator dealloc) {
  230|    330|    if (hash == NULL)
  ------------------
  |  Branch (230:9): [True: 0, False: 330]
  ------------------
  231|      0|        return;
  232|       |
  233|    330|    if (hash->table) {
  ------------------
  |  Branch (233:9): [True: 0, False: 330]
  ------------------
  234|      0|        const xmlHashEntry *end = &hash->table[hash->size];
  235|      0|        const xmlHashEntry *entry;
  236|       |
  237|      0|        for (entry = hash->table; entry < end; entry++) {
  ------------------
  |  Branch (237:35): [True: 0, False: 0]
  ------------------
  238|      0|            if (entry->hashValue == 0)
  ------------------
  |  Branch (238:17): [True: 0, False: 0]
  ------------------
  239|      0|                continue;
  240|      0|            if ((dealloc != NULL) && (entry->payload != NULL))
  ------------------
  |  Branch (240:17): [True: 0, False: 0]
  |  Branch (240:38): [True: 0, False: 0]
  ------------------
  241|      0|                dealloc(entry->payload, entry->key);
  242|      0|            if (hash->dict == NULL) {
  ------------------
  |  Branch (242:17): [True: 0, False: 0]
  ------------------
  243|      0|                if (entry->key)
  ------------------
  |  Branch (243:21): [True: 0, False: 0]
  ------------------
  244|      0|                    xmlFree(entry->key);
  245|      0|                if (entry->key2)
  ------------------
  |  Branch (245:21): [True: 0, False: 0]
  ------------------
  246|      0|                    xmlFree(entry->key2);
  247|      0|                if (entry->key3)
  ------------------
  |  Branch (247:21): [True: 0, False: 0]
  ------------------
  248|      0|                    xmlFree(entry->key3);
  249|      0|            }
  250|      0|        }
  251|       |
  252|      0|        xmlFree(hash->table);
  253|      0|    }
  254|       |
  255|    330|    if (hash->dict)
  ------------------
  |  Branch (255:9): [True: 0, False: 330]
  ------------------
  256|      0|        xmlDictFree(hash->dict);
  257|       |
  258|    330|    xmlFree(hash);
  259|    330|}

xmlInitMutex:
  129|      8|{
  130|      8|#ifdef HAVE_POSIX_THREADS
  131|      8|    if (XML_IS_NEVER_THREADED() == 0)
  ------------------
  |  |   85|      8|#define XML_IS_NEVER_THREADED() (!libxml_is_threaded)
  ------------------
  |  Branch (131:9): [True: 8, False: 0]
  ------------------
  132|      8|        pthread_mutex_init(&mutex->lock, NULL);
  133|       |#elif defined HAVE_WIN32_THREADS
  134|       |    InitializeCriticalSection(&mutex->cs);
  135|       |#else
  136|       |    (void) mutex;
  137|       |#endif
  138|      8|}
xmlMutexLock:
  202|      1|{
  203|      1|    if (tok == NULL)
  ------------------
  |  Branch (203:9): [True: 0, False: 1]
  ------------------
  204|      0|        return;
  205|      1|#ifdef HAVE_POSIX_THREADS
  206|       |    /*
  207|       |     * This assumes that __libc_single_threaded won't change while the
  208|       |     * lock is held.
  209|       |     */
  210|      1|    if (XML_IS_THREADED() != 0)
  ------------------
  |  |   84|      1|#define XML_IS_THREADED() libxml_is_threaded
  ------------------
  |  Branch (210:9): [True: 1, False: 0]
  ------------------
  211|      1|        pthread_mutex_lock(&tok->lock);
  212|       |#elif defined HAVE_WIN32_THREADS
  213|       |    EnterCriticalSection(&tok->cs);
  214|       |#endif
  215|       |
  216|      1|}
xmlMutexUnlock:
  226|      1|{
  227|      1|    if (tok == NULL)
  ------------------
  |  Branch (227:9): [True: 0, False: 1]
  ------------------
  228|      0|        return;
  229|      1|#ifdef HAVE_POSIX_THREADS
  230|      1|    if (XML_IS_THREADED() != 0)
  ------------------
  |  |   84|      1|#define XML_IS_THREADED() libxml_is_threaded
  ------------------
  |  Branch (230:9): [True: 1, False: 0]
  ------------------
  231|      1|        pthread_mutex_unlock(&tok->lock);
  232|       |#elif defined HAVE_WIN32_THREADS
  233|       |    LeaveCriticalSection(&tok->cs);
  234|       |#endif
  235|      1|}
xmlInitParser:
  569|    332|xmlInitParser(void) {
  570|       |    /*
  571|       |     * Note that the initialization code must not make memory allocations.
  572|       |     */
  573|    332|    if (xmlParserInitialized != 0)
  ------------------
  |  Branch (573:9): [True: 330, False: 2]
  ------------------
  574|    330|        return;
  575|       |
  576|      2|    xmlGlobalInitMutexLock();
  577|       |
  578|      2|    if (xmlParserInnerInitialized == 0) {
  ------------------
  |  Branch (578:9): [True: 2, False: 0]
  ------------------
  579|       |#if defined(_WIN32) && \
  580|       |    !defined(LIBXML_THREAD_ALLOC_ENABLED) && \
  581|       |    (!defined(LIBXML_STATIC) || defined(LIBXML_STATIC_FOR_DLL))
  582|       |        if (xmlFree == free)
  583|       |            atexit(xmlCleanupParser);
  584|       |#endif
  585|       |
  586|      2|        xmlInitMemoryInternal(); /* Should come second */
  587|      2|        xmlInitGlobalsInternal();
  588|      2|        xmlInitRandom();
  589|      2|        xmlInitDictInternal();
  590|      2|        xmlInitEncodingInternal();
  591|      2|#if defined(LIBXML_XPATH_ENABLED) || defined(LIBXML_SCHEMAS_ENABLED)
  592|      2|        xmlInitXPathInternal();
  593|      2|#endif
  594|       |
  595|      2|        xmlRegisterDefaultInputCallbacks();
  596|      2|#ifdef LIBXML_OUTPUT_ENABLED
  597|      2|        xmlRegisterDefaultOutputCallbacks();
  598|      2|#endif /* LIBXML_OUTPUT_ENABLED */
  599|       |
  600|      2|        xmlParserInnerInitialized = 1;
  601|      2|    }
  602|       |
  603|      2|    xmlGlobalInitMutexUnlock();
  604|       |
  605|      2|    xmlParserInitialized = 1;
  606|      2|}
threads.c:xmlGlobalInitMutexLock:
  462|      2|xmlGlobalInitMutexLock(void) {
  463|      2|#ifdef HAVE_POSIX_THREADS
  464|       |
  465|      2|#ifdef XML_PTHREAD_WEAK
  466|       |    /*
  467|       |     * This is somewhat unreliable since libpthread could be loaded
  468|       |     * later with dlopen() and threads could be created. But it's
  469|       |     * long-standing behavior and hard to work around.
  470|       |     */
  471|      2|    if (libxml_is_threaded == -1)
  ------------------
  |  Branch (471:9): [True: 2, False: 0]
  ------------------
  472|      2|        libxml_is_threaded =
  473|      2|            (pthread_mutex_init != NULL) &&
  ------------------
  |  Branch (473:13): [True: 2, False: 0]
  ------------------
  474|      2|            (pthread_mutex_destroy != NULL) &&
  ------------------
  |  Branch (474:13): [True: 2, False: 0]
  ------------------
  475|      2|            (pthread_mutex_lock != NULL) &&
  ------------------
  |  Branch (475:13): [True: 2, False: 0]
  ------------------
  476|      2|            (pthread_mutex_unlock != NULL) &&
  ------------------
  |  Branch (476:13): [True: 2, False: 0]
  ------------------
  477|      2|            (pthread_cond_init != NULL) &&
  ------------------
  |  Branch (477:13): [True: 2, False: 0]
  ------------------
  478|      2|            (pthread_cond_destroy != NULL) &&
  ------------------
  |  Branch (478:13): [True: 2, False: 0]
  ------------------
  479|      2|            (pthread_cond_wait != NULL) &&
  ------------------
  |  Branch (479:13): [True: 2, False: 0]
  ------------------
  480|       |            /*
  481|       |             * pthread_equal can be inline, resuting in -Waddress warnings.
  482|       |             * Let's assume it's available if all the other functions are.
  483|       |             */
  484|       |            /* (pthread_equal != NULL) && */
  485|      2|            (pthread_self != NULL) &&
  ------------------
  |  Branch (485:13): [True: 2, False: 0]
  ------------------
  486|      2|            (pthread_cond_signal != NULL);
  ------------------
  |  Branch (486:13): [True: 2, False: 0]
  ------------------
  487|      2|#endif
  488|       |
  489|       |    /* The mutex is statically initialized, so we just lock it. */
  490|      2|    if (XML_IS_THREADED() != 0)
  ------------------
  |  |   84|      2|#define XML_IS_THREADED() libxml_is_threaded
  ------------------
  |  Branch (490:9): [True: 2, False: 0]
  ------------------
  491|      2|        pthread_mutex_lock(&global_init_lock);
  492|       |
  493|       |#elif defined HAVE_WIN32_THREADS
  494|       |
  495|       |    LPCRITICAL_SECTION cs;
  496|       |
  497|       |    /* Create a new critical section */
  498|       |    if (global_init_lock == NULL) {
  499|       |        cs = malloc(sizeof(CRITICAL_SECTION));
  500|       |        if (cs == NULL) {
  501|       |            xmlGenericError(xmlGenericErrorContext,
  502|       |                            "xmlGlobalInitMutexLock: out of memory\n");
  503|       |            return;
  504|       |        }
  505|       |        InitializeCriticalSection(cs);
  506|       |
  507|       |        /* Swap it into the global_init_lock */
  508|       |#ifdef InterlockedCompareExchangePointer
  509|       |        InterlockedCompareExchangePointer((void **) &global_init_lock,
  510|       |                                          cs, NULL);
  511|       |#else /* Use older void* version */
  512|       |        InterlockedCompareExchange((void **) &global_init_lock,
  513|       |                                   (void *) cs, NULL);
  514|       |#endif /* InterlockedCompareExchangePointer */
  515|       |
  516|       |        /* If another thread successfully recorded its critical
  517|       |         * section in the global_init_lock then discard the one
  518|       |         * allocated by this thread. */
  519|       |        if (global_init_lock != cs) {
  520|       |            DeleteCriticalSection(cs);
  521|       |            free(cs);
  522|       |        }
  523|       |    }
  524|       |
  525|       |    /* Lock the chosen critical section */
  526|       |    EnterCriticalSection(global_init_lock);
  527|       |
  528|       |#endif
  529|      2|}
threads.c:xmlGlobalInitMutexUnlock:
  532|      2|xmlGlobalInitMutexUnlock(void) {
  533|      2|#ifdef HAVE_POSIX_THREADS
  534|      2|    if (XML_IS_THREADED() != 0)
  ------------------
  |  |   84|      2|#define XML_IS_THREADED() libxml_is_threaded
  ------------------
  |  Branch (534:9): [True: 2, False: 0]
  ------------------
  535|      2|        pthread_mutex_unlock(&global_init_lock);
  536|       |#elif defined HAVE_WIN32_THREADS
  537|       |    if (global_init_lock != NULL)
  538|       |	LeaveCriticalSection(global_init_lock);
  539|       |#endif
  540|      2|}

xmlRegisterInputCallbacks:
 2102|      6|	xmlInputCloseCallback closeFunc) {
 2103|      6|    if (xmlInputCallbackNr >= MAX_INPUT_CALLBACK) {
  ------------------
  |  |   85|      6|#define MAX_INPUT_CALLBACK 15
  ------------------
  |  Branch (2103:9): [True: 0, False: 6]
  ------------------
 2104|      0|	return(-1);
 2105|      0|    }
 2106|      6|    xmlInputCallbackTable[xmlInputCallbackNr].matchcallback = matchFunc;
 2107|      6|    xmlInputCallbackTable[xmlInputCallbackNr].opencallback = openFunc;
 2108|      6|    xmlInputCallbackTable[xmlInputCallbackNr].readcallback = readFunc;
 2109|      6|    xmlInputCallbackTable[xmlInputCallbackNr].closecallback = closeFunc;
 2110|      6|    xmlInputCallbackInitialized = 1;
 2111|      6|    return(xmlInputCallbackNr++);
 2112|      6|}
xmlRegisterOutputCallbacks:
 2129|      2|	xmlOutputCloseCallback closeFunc) {
 2130|      2|    if (xmlOutputCallbackNr >= MAX_OUTPUT_CALLBACK) {
  ------------------
  |  |  102|      2|#define MAX_OUTPUT_CALLBACK 15
  ------------------
  |  Branch (2130:9): [True: 0, False: 2]
  ------------------
 2131|      0|	return(-1);
 2132|      0|    }
 2133|      2|    xmlOutputCallbackTable[xmlOutputCallbackNr].matchcallback = matchFunc;
 2134|      2|    xmlOutputCallbackTable[xmlOutputCallbackNr].opencallback = openFunc;
 2135|      2|    xmlOutputCallbackTable[xmlOutputCallbackNr].writecallback = writeFunc;
 2136|      2|    xmlOutputCallbackTable[xmlOutputCallbackNr].closecallback = closeFunc;
 2137|      2|    xmlOutputCallbackInitialized = 1;
 2138|      2|    return(xmlOutputCallbackNr++);
 2139|      2|}
xmlRegisterDefaultInputCallbacks:
 2148|      2|xmlRegisterDefaultInputCallbacks(void) {
 2149|      2|    if (xmlInputCallbackInitialized)
  ------------------
  |  Branch (2149:9): [True: 0, False: 2]
  ------------------
 2150|      0|	return;
 2151|       |
 2152|      2|    xmlRegisterInputCallbacks(xmlFileMatch, xmlFileOpen,
 2153|      2|	                      xmlFileRead, xmlFileClose);
 2154|      2|#ifdef LIBXML_ZLIB_ENABLED
 2155|      2|    xmlRegisterInputCallbacks(xmlGzfileMatch, xmlGzfileOpen,
 2156|      2|	                      xmlGzfileRead, xmlGzfileClose);
 2157|      2|#endif /* LIBXML_ZLIB_ENABLED */
 2158|      2|#ifdef LIBXML_LZMA_ENABLED
 2159|      2|    xmlRegisterInputCallbacks(xmlXzfileMatch, xmlXzfileOpen,
 2160|      2|	                      xmlXzfileRead, xmlXzfileClose);
 2161|      2|#endif /* LIBXML_LZMA_ENABLED */
 2162|       |
 2163|       |#ifdef LIBXML_HTTP_ENABLED
 2164|       |    xmlRegisterInputCallbacks(xmlIOHTTPMatch, xmlIOHTTPOpen,
 2165|       |	                      xmlIOHTTPRead, xmlIOHTTPClose);
 2166|       |#endif /* LIBXML_HTTP_ENABLED */
 2167|       |
 2168|       |#ifdef LIBXML_FTP_ENABLED
 2169|       |    xmlRegisterInputCallbacks(xmlIOFTPMatch, xmlIOFTPOpen,
 2170|       |	                      xmlIOFTPRead, xmlIOFTPClose);
 2171|       |#endif /* LIBXML_FTP_ENABLED */
 2172|      2|    xmlInputCallbackInitialized = 1;
 2173|      2|}
xmlRegisterDefaultOutputCallbacks:
 2182|      2|xmlRegisterDefaultOutputCallbacks (void) {
 2183|      2|    if (xmlOutputCallbackInitialized)
  ------------------
  |  Branch (2183:9): [True: 0, False: 2]
  ------------------
 2184|      0|	return;
 2185|       |
 2186|      2|    xmlRegisterOutputCallbacks(xmlFileMatch, xmlFileOpenW,
 2187|      2|	                      xmlFileWrite, xmlFileClose);
 2188|       |
 2189|       |#ifdef LIBXML_HTTP_ENABLED
 2190|       |    xmlRegisterOutputCallbacks(xmlIOHTTPMatch, xmlIOHTTPDfltOpenW,
 2191|       |	                       xmlIOHTTPWrite, xmlIOHTTPClosePut);
 2192|       |#endif
 2193|       |
 2194|       |/*********************************
 2195|       | No way a-priori to distinguish between gzipped files from
 2196|       | uncompressed ones except opening if existing then closing
 2197|       | and saving with same compression ratio ... a pain.
 2198|       |
 2199|       |#ifdef LIBXML_ZLIB_ENABLED
 2200|       |    xmlRegisterOutputCallbacks(xmlGzfileMatch, xmlGzfileOpen,
 2201|       |	                       xmlGzfileWrite, xmlGzfileClose);
 2202|       |#endif
 2203|       |
 2204|       | Nor FTP PUT ....
 2205|       |#ifdef LIBXML_FTP_ENABLED
 2206|       |    xmlRegisterOutputCallbacks(xmlIOFTPMatch, xmlIOFTPOpen,
 2207|       |	                       xmlIOFTPWrite, xmlIOFTPClose);
 2208|       |#endif
 2209|       | **********************************/
 2210|      2|    xmlOutputCallbackInitialized = 1;
 2211|      2|}

xmlInitMemoryInternal:
  846|      2|xmlInitMemoryInternal(void) {
  847|      2|     char *breakpoint;
  848|      2|     xmlInitMutex(&xmlMemMutex);
  849|       |
  850|      2|     breakpoint = getenv("XML_MEM_BREAKPOINT");
  851|      2|     if (breakpoint != NULL) {
  ------------------
  |  Branch (851:10): [True: 0, False: 2]
  ------------------
  852|      0|         sscanf(breakpoint, "%ud", &xmlMemStopAtBlock);
  853|      0|     }
  854|      2|     breakpoint = getenv("XML_MEM_TRACE");
  855|      2|     if (breakpoint != NULL) {
  ------------------
  |  Branch (855:10): [True: 0, False: 2]
  ------------------
  856|      0|         sscanf(breakpoint, "%p", &xmlMemTraceBlockAt);
  857|      0|     }
  858|       |
  859|      2|}
xmlMemSetup:
  910|      2|            xmlReallocFunc reallocFunc, xmlStrdupFunc strdupFunc) {
  911|      2|    if (freeFunc == NULL)
  ------------------
  |  Branch (911:9): [True: 0, False: 2]
  ------------------
  912|      0|	return(-1);
  913|      2|    if (mallocFunc == NULL)
  ------------------
  |  Branch (913:9): [True: 0, False: 2]
  ------------------
  914|      0|	return(-1);
  915|      2|    if (reallocFunc == NULL)
  ------------------
  |  Branch (915:9): [True: 0, False: 2]
  ------------------
  916|      0|	return(-1);
  917|      2|    if (strdupFunc == NULL)
  ------------------
  |  Branch (917:9): [True: 0, False: 2]
  ------------------
  918|      0|	return(-1);
  919|      2|    xmlFree = freeFunc;
  920|      2|    xmlMalloc = mallocFunc;
  921|      2|    xmlMallocAtomic = mallocFunc;
  922|      2|    xmlRealloc = reallocFunc;
  923|      2|    xmlMemStrdup = strdupFunc;
  924|      2|    return(0);
  925|      2|}

xmlRegexpCompile:
 5417|    330|xmlRegexpCompile(const xmlChar *regexp) {
 5418|    330|    xmlRegexpPtr ret = NULL;
 5419|    330|    xmlRegParserCtxtPtr ctxt;
 5420|       |
 5421|    330|    if (regexp == NULL)
  ------------------
  |  Branch (5421:9): [True: 3, False: 327]
  ------------------
 5422|      3|        return(NULL);
 5423|       |
 5424|    327|    ctxt = xmlRegNewParserCtxt(regexp);
 5425|    327|    if (ctxt == NULL)
  ------------------
  |  Branch (5425:9): [True: 1, False: 326]
  ------------------
 5426|      1|	return(NULL);
 5427|       |
 5428|       |    /* initialize the parser */
 5429|    326|    ctxt->state = xmlRegStatePush(ctxt);
 5430|    326|    if (ctxt->state == NULL)
  ------------------
  |  Branch (5430:9): [True: 2, False: 324]
  ------------------
 5431|      2|        goto error;
 5432|    324|    ctxt->start = ctxt->state;
 5433|    324|    ctxt->end = NULL;
 5434|       |
 5435|       |    /* parse the expression building an automata */
 5436|    324|    xmlFAParseRegExp(ctxt, 1);
 5437|    324|    if (CUR != 0) {
  ------------------
  |  |   58|    324|#define CUR (*(ctxt->cur))
  ------------------
  |  Branch (5437:9): [True: 114, False: 210]
  ------------------
 5438|    114|	ERROR("xmlFAParseRegExp: extra characters");
  ------------------
  |  |   55|    114|    ctxt->error = XML_REGEXP_COMPILE_ERROR;				\
  |  |   56|    114|    xmlRegexpErrCompile(ctxt, str);
  ------------------
 5439|    114|    }
 5440|    324|    if (ctxt->error != 0)
  ------------------
  |  Branch (5440:9): [True: 167, False: 157]
  ------------------
 5441|    167|        goto error;
 5442|    157|    ctxt->end = ctxt->state;
 5443|    157|    ctxt->start->type = XML_REGEXP_START_STATE;
 5444|    157|    ctxt->end->type = XML_REGEXP_FINAL_STATE;
 5445|       |
 5446|       |    /* remove the Epsilon except for counted transitions */
 5447|    157|    xmlFAEliminateEpsilonTransitions(ctxt);
 5448|       |
 5449|       |
 5450|    157|    if (ctxt->error != 0)
  ------------------
  |  Branch (5450:9): [True: 0, False: 157]
  ------------------
 5451|      0|        goto error;
 5452|    157|    ret = xmlRegEpxFromParse(ctxt);
 5453|       |
 5454|    326|error:
 5455|    326|    xmlRegFreeParserCtxt(ctxt);
 5456|    326|    return(ret);
 5457|    157|}
xmlRegexpIsDeterminist:
 5484|    156|xmlRegexpIsDeterminist(xmlRegexpPtr comp) {
 5485|    156|    xmlAutomataPtr am;
 5486|    156|    int ret;
 5487|       |
 5488|    156|    if (comp == NULL)
  ------------------
  |  Branch (5488:9): [True: 0, False: 156]
  ------------------
 5489|      0|	return(-1);
 5490|    156|    if (comp->determinist != -1)
  ------------------
  |  Branch (5490:9): [True: 0, False: 156]
  ------------------
 5491|      0|	return(comp->determinist);
 5492|       |
 5493|    156|    am = xmlNewAutomata();
 5494|    156|    if (am == NULL)
  ------------------
  |  Branch (5494:9): [True: 3, False: 153]
  ------------------
 5495|      3|        return(-1);
 5496|    153|    if (am->states != NULL) {
  ------------------
  |  Branch (5496:9): [True: 153, False: 0]
  ------------------
 5497|    153|	int i;
 5498|       |
 5499|    306|	for (i = 0;i < am->nbStates;i++)
  ------------------
  |  Branch (5499:13): [True: 153, False: 153]
  ------------------
 5500|    153|	    xmlRegFreeState(am->states[i]);
 5501|    153|	xmlFree(am->states);
 5502|    153|    }
 5503|    153|    am->nbAtoms = comp->nbAtoms;
 5504|    153|    am->atoms = comp->atoms;
 5505|    153|    am->nbStates = comp->nbStates;
 5506|    153|    am->states = comp->states;
 5507|    153|    am->determinist = -1;
 5508|    153|    am->flags = comp->flags;
 5509|    153|    ret = xmlFAComputesDeterminism(am);
 5510|    153|    am->atoms = NULL;
 5511|    153|    am->states = NULL;
 5512|    153|    xmlFreeAutomata(am);
 5513|    153|    comp->determinist = ret;
 5514|    153|    return(ret);
 5515|    156|}
xmlRegFreeRegexp:
 5524|    330|xmlRegFreeRegexp(xmlRegexpPtr regexp) {
 5525|    330|    int i;
 5526|    330|    if (regexp == NULL)
  ------------------
  |  Branch (5526:9): [True: 177, False: 153]
  ------------------
 5527|    177|	return;
 5528|       |
 5529|    153|    if (regexp->string != NULL)
  ------------------
  |  Branch (5529:9): [True: 153, False: 0]
  ------------------
 5530|    153|	xmlFree(regexp->string);
 5531|    153|    if (regexp->states != NULL) {
  ------------------
  |  Branch (5531:9): [True: 153, False: 0]
  ------------------
 5532|  4.46k|	for (i = 0;i < regexp->nbStates;i++)
  ------------------
  |  Branch (5532:13): [True: 4.31k, False: 153]
  ------------------
 5533|  4.31k|	    xmlRegFreeState(regexp->states[i]);
 5534|    153|	xmlFree(regexp->states);
 5535|    153|    }
 5536|    153|    if (regexp->atoms != NULL) {
  ------------------
  |  Branch (5536:9): [True: 149, False: 4]
  ------------------
 5537|  3.27k|	for (i = 0;i < regexp->nbAtoms;i++)
  ------------------
  |  Branch (5537:13): [True: 3.12k, False: 149]
  ------------------
 5538|  3.12k|	    xmlRegFreeAtom(regexp->atoms[i]);
 5539|    149|	xmlFree(regexp->atoms);
 5540|    149|    }
 5541|    153|    if (regexp->counters != NULL)
  ------------------
  |  Branch (5541:9): [True: 52, False: 101]
  ------------------
 5542|     52|	xmlFree(regexp->counters);
 5543|    153|    if (regexp->compact != NULL)
  ------------------
  |  Branch (5543:9): [True: 0, False: 153]
  ------------------
 5544|      0|	xmlFree(regexp->compact);
 5545|    153|    if (regexp->transdata != NULL)
  ------------------
  |  Branch (5545:9): [True: 0, False: 153]
  ------------------
 5546|      0|	xmlFree(regexp->transdata);
 5547|    153|    if (regexp->stringMap != NULL) {
  ------------------
  |  Branch (5547:9): [True: 0, False: 153]
  ------------------
 5548|      0|	for (i = 0; i < regexp->nbstrings;i++)
  ------------------
  |  Branch (5548:14): [True: 0, False: 0]
  ------------------
 5549|      0|	    xmlFree(regexp->stringMap[i]);
 5550|      0|	xmlFree(regexp->stringMap);
 5551|      0|    }
 5552|       |
 5553|    153|    xmlFree(regexp);
 5554|    153|}
xmlNewAutomata:
 5571|    156|xmlNewAutomata(void) {
 5572|    156|    xmlAutomataPtr ctxt;
 5573|       |
 5574|    156|    ctxt = xmlRegNewParserCtxt(NULL);
 5575|    156|    if (ctxt == NULL)
  ------------------
  |  Branch (5575:9): [True: 2, False: 154]
  ------------------
 5576|      2|	return(NULL);
 5577|       |
 5578|       |    /* initialize the parser */
 5579|    154|    ctxt->state = xmlRegStatePush(ctxt);
 5580|    154|    if (ctxt->state == NULL) {
  ------------------
  |  Branch (5580:9): [True: 1, False: 153]
  ------------------
 5581|      1|	xmlFreeAutomata(ctxt);
 5582|      1|	return(NULL);
 5583|      1|    }
 5584|    153|    ctxt->start = ctxt->state;
 5585|    153|    ctxt->end = NULL;
 5586|       |
 5587|    153|    ctxt->start->type = XML_REGEXP_START_STATE;
 5588|    153|    ctxt->flags = 0;
 5589|       |
 5590|    153|    return(ctxt);
 5591|    154|}
xmlFreeAutomata:
 5600|    154|xmlFreeAutomata(xmlAutomataPtr am) {
 5601|    154|    if (am == NULL)
  ------------------
  |  Branch (5601:9): [True: 0, False: 154]
  ------------------
 5602|      0|	return;
 5603|    154|    xmlRegFreeParserCtxt(am);
 5604|    154|}
xmlregexp.c:xmlRegexpErrMemory:
  382|    132|{
  383|    132|    const char *regexp = NULL;
  384|    132|    if (ctxt != NULL) {
  ------------------
  |  Branch (384:9): [True: 132, False: 0]
  ------------------
  385|    132|        regexp = (const char *) ctxt->string;
  386|    132|	ctxt->error = XML_ERR_NO_MEMORY;
  387|    132|    }
  388|    132|    __xmlRaiseError(NULL, NULL, NULL, NULL, NULL, XML_FROM_REGEXP,
  389|    132|		    XML_ERR_NO_MEMORY, XML_ERR_FATAL, NULL, 0, extra,
  390|    132|		    regexp, NULL, 0, 0,
  391|    132|		    "Memory allocation failed : %s\n", extra);
  392|    132|}
xmlregexp.c:xmlRegNewParserCtxt:
  694|    483|xmlRegNewParserCtxt(const xmlChar *string) {
  695|    483|    xmlRegParserCtxtPtr ret;
  696|       |
  697|    483|    ret = (xmlRegParserCtxtPtr) xmlMalloc(sizeof(xmlRegParserCtxt));
  698|    483|    if (ret == NULL)
  ------------------
  |  Branch (698:9): [True: 3, False: 480]
  ------------------
  699|      3|	return(NULL);
  700|    480|    memset(ret, 0, sizeof(xmlRegParserCtxt));
  701|    480|    if (string != NULL)
  ------------------
  |  Branch (701:9): [True: 326, False: 154]
  ------------------
  702|    326|	ret->string = xmlStrdup(string);
  703|    480|    ret->cur = ret->string;
  704|    480|    ret->neg = 0;
  705|    480|    ret->negs = 0;
  706|    480|    ret->error = 0;
  707|    480|    ret->determinist = -1;
  708|    480|    return(ret);
  709|    483|}
xmlregexp.c:xmlRegStatePush:
 1369|  9.32k|xmlRegStatePush(xmlRegParserCtxtPtr ctxt) {
 1370|  9.32k|    xmlRegStatePtr state;
 1371|       |
 1372|  9.32k|    if (ctxt->nbStates >= ctxt->maxStates) {
  ------------------
  |  Branch (1372:9): [True: 1.20k, False: 8.12k]
  ------------------
 1373|  1.20k|        size_t newSize = ctxt->maxStates ? ctxt->maxStates * 2 : 4;
  ------------------
  |  Branch (1373:26): [True: 722, False: 480]
  ------------------
 1374|  1.20k|	xmlRegStatePtr *tmp;
 1375|       |
 1376|  1.20k|	tmp = xmlRealloc(ctxt->states, newSize * sizeof(tmp[0]));
 1377|  1.20k|	if (tmp == NULL) {
  ------------------
  |  Branch (1377:6): [True: 5, False: 1.19k]
  ------------------
 1378|      5|	    xmlRegexpErrMemory(ctxt, "adding state");
 1379|      5|	    return(NULL);
 1380|      5|	}
 1381|  1.19k|	ctxt->states = tmp;
 1382|  1.19k|	ctxt->maxStates = newSize;
 1383|  1.19k|    }
 1384|       |
 1385|  9.32k|    state = xmlRegNewState(ctxt);
 1386|  9.32k|    if (state == NULL)
  ------------------
  |  Branch (1386:9): [True: 33, False: 9.28k]
  ------------------
 1387|     33|        return(NULL);
 1388|       |
 1389|  9.28k|    state->no = ctxt->nbStates;
 1390|  9.28k|    ctxt->states[ctxt->nbStates++] = state;
 1391|       |
 1392|  9.28k|    return(state);
 1393|  9.32k|}
xmlregexp.c:xmlRegNewState:
  885|  9.32k|xmlRegNewState(xmlRegParserCtxtPtr ctxt) {
  886|  9.32k|    xmlRegStatePtr ret;
  887|       |
  888|  9.32k|    ret = (xmlRegStatePtr) xmlMalloc(sizeof(xmlRegState));
  889|  9.32k|    if (ret == NULL) {
  ------------------
  |  Branch (889:9): [True: 33, False: 9.28k]
  ------------------
  890|     33|	xmlRegexpErrMemory(ctxt, "allocating state");
  891|     33|	return(NULL);
  892|     33|    }
  893|  9.28k|    memset(ret, 0, sizeof(xmlRegState));
  894|  9.28k|    ret->type = XML_REGEXP_TRANS_STATE;
  895|  9.28k|    ret->mark = XML_REGEXP_MARK_NORMAL;
  896|  9.28k|    return(ret);
  897|  9.32k|}
xmlregexp.c:xmlFAParseRegExp:
 5336|  2.15k|xmlFAParseRegExp(xmlRegParserCtxtPtr ctxt, int top) {
 5337|  2.15k|    xmlRegStatePtr start, end;
 5338|       |
 5339|       |    /* if not top start should have been generated by an epsilon trans */
 5340|  2.15k|    start = ctxt->state;
 5341|  2.15k|    ctxt->end = NULL;
 5342|  2.15k|    xmlFAParseBranch(ctxt, NULL);
 5343|  2.15k|    if (top) {
  ------------------
  |  Branch (5343:9): [True: 324, False: 1.83k]
  ------------------
 5344|    324|	ctxt->state->type = XML_REGEXP_FINAL_STATE;
 5345|    324|    }
 5346|  2.15k|    if (CUR != '|') {
  ------------------
  |  |   58|  2.15k|#define CUR (*(ctxt->cur))
  ------------------
  |  Branch (5346:9): [True: 1.56k, False: 597]
  ------------------
 5347|  1.56k|	ctxt->end = ctxt->state;
 5348|  1.56k|	return;
 5349|  1.56k|    }
 5350|    597|    end = ctxt->state;
 5351|  1.59k|    while ((CUR == '|') && (ctxt->error == 0)) {
  ------------------
  |  |   58|  1.59k|#define CUR (*(ctxt->cur))
  ------------------
  |  Branch (5351:12): [True: 1.00k, False: 588]
  |  Branch (5351:28): [True: 993, False: 9]
  ------------------
 5352|    993|	NEXT;
  ------------------
  |  |   57|    993|#define NEXT ctxt->cur++
  ------------------
 5353|    993|	ctxt->state = start;
 5354|    993|	ctxt->end = NULL;
 5355|    993|	xmlFAParseBranch(ctxt, end);
 5356|    993|    }
 5357|    597|    if (!top) {
  ------------------
  |  Branch (5357:9): [True: 558, False: 39]
  ------------------
 5358|    558|	ctxt->state = end;
 5359|    558|	ctxt->end = end;
 5360|    558|    }
 5361|    597|}
xmlregexp.c:xmlFAParseBranch:
 5291|  3.15k|xmlFAParseBranch(xmlRegParserCtxtPtr ctxt, xmlRegStatePtr to) {
 5292|  3.15k|    xmlRegStatePtr previous;
 5293|  3.15k|    int ret;
 5294|       |
 5295|  3.15k|    previous = ctxt->state;
 5296|  3.15k|    ret = xmlFAParsePiece(ctxt);
 5297|  3.15k|    if (ret == 0) {
  ------------------
  |  Branch (5297:9): [True: 284, False: 2.86k]
  ------------------
 5298|       |        /* Empty branch */
 5299|    284|	xmlFAGenerateEpsilonTransition(ctxt, previous, to);
 5300|  2.86k|    } else {
 5301|  2.86k|	if (xmlFAGenerateTransitions(ctxt, previous,
  ------------------
  |  Branch (5301:6): [True: 52, False: 2.81k]
  ------------------
 5302|  2.86k|	        (CUR=='|' || CUR==')' || CUR==0) ? to : NULL,
  ------------------
  |  |   58|  2.86k|#define CUR (*(ctxt->cur))
  ------------------
              	        (CUR=='|' || CUR==')' || CUR==0) ? to : NULL,
  ------------------
  |  |   58|  2.37k|#define CUR (*(ctxt->cur))
  ------------------
              	        (CUR=='|' || CUR==')' || CUR==0) ? to : NULL,
  ------------------
  |  |   58|  1.79k|#define CUR (*(ctxt->cur))
  ------------------
  |  Branch (5302:11): [True: 495, False: 2.37k]
  |  Branch (5302:23): [True: 574, False: 1.79k]
  |  Branch (5302:35): [True: 156, False: 1.64k]
  ------------------
 5303|  2.86k|                ctxt->atom) < 0) {
 5304|     52|            xmlRegFreeAtom(ctxt->atom);
 5305|     52|            ctxt->atom = NULL;
 5306|     52|	    return(-1);
 5307|     52|        }
 5308|  2.81k|	previous = ctxt->state;
 5309|  2.81k|	ctxt->atom = NULL;
 5310|  2.81k|    }
 5311|  9.21k|    while ((ret != 0) && (ctxt->error == 0)) {
  ------------------
  |  Branch (5311:12): [True: 6.48k, False: 2.72k]
  |  Branch (5311:26): [True: 6.16k, False: 327]
  ------------------
 5312|  6.16k|	ret = xmlFAParsePiece(ctxt);
 5313|  6.16k|	if (ret != 0) {
  ------------------
  |  Branch (5313:6): [True: 3.71k, False: 2.44k]
  ------------------
 5314|  3.71k|	    if (xmlFAGenerateTransitions(ctxt, previous,
  ------------------
  |  Branch (5314:10): [True: 45, False: 3.67k]
  ------------------
 5315|  3.71k|	            (CUR=='|' || CUR==')' || CUR==0) ? to : NULL,
  ------------------
  |  |   58|  3.71k|#define CUR (*(ctxt->cur))
  ------------------
              	            (CUR=='|' || CUR==')' || CUR==0) ? to : NULL,
  ------------------
  |  |   58|  3.46k|#define CUR (*(ctxt->cur))
  ------------------
              	            (CUR=='|' || CUR==')' || CUR==0) ? to : NULL,
  ------------------
  |  |   58|  2.52k|#define CUR (*(ctxt->cur))
  ------------------
  |  Branch (5315:15): [True: 250, False: 3.46k]
  |  Branch (5315:27): [True: 948, False: 2.52k]
  |  Branch (5315:39): [True: 167, False: 2.35k]
  ------------------
 5316|  3.71k|                    ctxt->atom) < 0) {
 5317|     45|                xmlRegFreeAtom(ctxt->atom);
 5318|     45|                ctxt->atom = NULL;
 5319|     45|                return(-1);
 5320|     45|            }
 5321|  3.67k|	    previous = ctxt->state;
 5322|  3.67k|	    ctxt->atom = NULL;
 5323|  3.67k|	}
 5324|  6.16k|    }
 5325|  3.05k|    return(0);
 5326|  3.09k|}
xmlregexp.c:xmlFAParsePiece:
 5266|  9.31k|xmlFAParsePiece(xmlRegParserCtxtPtr ctxt) {
 5267|  9.31k|    int ret;
 5268|       |
 5269|  9.31k|    ctxt->atom = NULL;
 5270|  9.31k|    ret = xmlFAParseAtom(ctxt);
 5271|  9.31k|    if (ret == 0)
  ------------------
  |  Branch (5271:9): [True: 2.72k, False: 6.58k]
  ------------------
 5272|  2.72k|	return(0);
 5273|  6.58k|    if (ctxt->atom == NULL) {
  ------------------
  |  Branch (5273:9): [True: 83, False: 6.50k]
  ------------------
 5274|     83|	ERROR("internal: no atom generated");
  ------------------
  |  |   55|     83|    ctxt->error = XML_REGEXP_COMPILE_ERROR;				\
  |  |   56|     83|    xmlRegexpErrCompile(ctxt, str);
  ------------------
 5275|     83|    }
 5276|  6.58k|    xmlFAParseQuantifier(ctxt);
 5277|  6.58k|    return(1);
 5278|  9.31k|}
xmlregexp.c:xmlFAParseAtom:
 5194|  9.31k|xmlFAParseAtom(xmlRegParserCtxtPtr ctxt) {
 5195|  9.31k|    int codepoint, len;
 5196|       |
 5197|  9.31k|    codepoint = xmlFAIsChar(ctxt);
 5198|  9.31k|    if (codepoint > 0) {
  ------------------
  |  Branch (5198:9): [True: 3.12k, False: 6.18k]
  ------------------
 5199|  3.12k|	ctxt->atom = xmlRegNewAtom(ctxt, XML_REGEXP_CHARVAL);
 5200|  3.12k|	if (ctxt->atom == NULL)
  ------------------
  |  Branch (5200:6): [True: 8, False: 3.11k]
  ------------------
 5201|      8|	    return(-1);
 5202|  3.11k|        len = 4;
 5203|  3.11k|        codepoint = xmlGetUTF8Char(ctxt->cur, &len);
 5204|  3.11k|        if (codepoint < 0) {
  ------------------
  |  Branch (5204:13): [True: 0, False: 3.11k]
  ------------------
 5205|      0|            ERROR("Invalid UTF-8");
  ------------------
  |  |   55|      0|    ctxt->error = XML_REGEXP_COMPILE_ERROR;				\
  |  |   56|      0|    xmlRegexpErrCompile(ctxt, str);
  ------------------
 5206|      0|            return(-1);
 5207|      0|        }
 5208|  3.11k|	ctxt->atom->codepoint = codepoint;
 5209|  3.11k|	NEXTL(len);
  ------------------
  |  |   61|  3.11k|#define NEXTL(l) ctxt->cur += l;
  ------------------
 5210|  3.11k|	return(1);
 5211|  6.18k|    } else if (CUR == '|') {
  ------------------
  |  |   58|  6.18k|#define CUR (*(ctxt->cur))
  ------------------
  |  Branch (5211:16): [True: 993, False: 5.19k]
  ------------------
 5212|    993|	return(0);
 5213|  5.19k|    } else if (CUR == 0) {
  ------------------
  |  |   58|  5.19k|#define CUR (*(ctxt->cur))
  ------------------
  |  Branch (5213:16): [True: 187, False: 5.00k]
  ------------------
 5214|    187|	return(0);
 5215|  5.00k|    } else if (CUR == ')') {
  ------------------
  |  |   58|  5.00k|#define CUR (*(ctxt->cur))
  ------------------
  |  Branch (5215:16): [True: 1.52k, False: 3.48k]
  ------------------
 5216|  1.52k|	return(0);
 5217|  3.48k|    } else if (CUR == '(') {
  ------------------
  |  |   58|  3.48k|#define CUR (*(ctxt->cur))
  ------------------
  |  Branch (5217:16): [True: 1.83k, False: 1.65k]
  ------------------
 5218|  1.83k|	xmlRegStatePtr start, oldend, start0;
 5219|       |
 5220|  1.83k|	NEXT;
  ------------------
  |  |   57|  1.83k|#define NEXT ctxt->cur++
  ------------------
 5221|  1.83k|        if (ctxt->depth >= 50) {
  ------------------
  |  Branch (5221:13): [True: 0, False: 1.83k]
  ------------------
 5222|      0|	    ERROR("xmlFAParseAtom: maximum nesting depth exceeded");
  ------------------
  |  |   55|      0|    ctxt->error = XML_REGEXP_COMPILE_ERROR;				\
  |  |   56|      0|    xmlRegexpErrCompile(ctxt, str);
  ------------------
 5223|      0|            return(-1);
 5224|      0|        }
 5225|       |	/*
 5226|       |	 * this extra Epsilon transition is needed if we count with 0 allowed
 5227|       |	 * unfortunately this can't be known at that point
 5228|       |	 */
 5229|  1.83k|	xmlFAGenerateEpsilonTransition(ctxt, ctxt->state, NULL);
 5230|  1.83k|	start0 = ctxt->state;
 5231|  1.83k|	xmlFAGenerateEpsilonTransition(ctxt, ctxt->state, NULL);
 5232|  1.83k|	start = ctxt->state;
 5233|  1.83k|	oldend = ctxt->end;
 5234|  1.83k|	ctxt->end = NULL;
 5235|  1.83k|	ctxt->atom = NULL;
 5236|  1.83k|        ctxt->depth++;
 5237|  1.83k|	xmlFAParseRegExp(ctxt, 0);
 5238|  1.83k|        ctxt->depth--;
 5239|  1.83k|	if (CUR == ')') {
  ------------------
  |  |   58|  1.83k|#define CUR (*(ctxt->cur))
  ------------------
  |  Branch (5239:6): [True: 1.51k, False: 319]
  ------------------
 5240|  1.51k|	    NEXT;
  ------------------
  |  |   57|  1.51k|#define NEXT ctxt->cur++
  ------------------
 5241|  1.51k|	} else {
 5242|    319|	    ERROR("xmlFAParseAtom: expecting ')'");
  ------------------
  |  |   55|    319|    ctxt->error = XML_REGEXP_COMPILE_ERROR;				\
  |  |   56|    319|    xmlRegexpErrCompile(ctxt, str);
  ------------------
 5243|    319|	}
 5244|  1.83k|	ctxt->atom = xmlRegNewAtom(ctxt, XML_REGEXP_SUBREG);
 5245|  1.83k|	if (ctxt->atom == NULL)
  ------------------
  |  Branch (5245:6): [True: 56, False: 1.77k]
  ------------------
 5246|     56|	    return(-1);
 5247|  1.77k|	ctxt->atom->start = start;
 5248|  1.77k|	ctxt->atom->start0 = start0;
 5249|  1.77k|	ctxt->atom->stop = ctxt->state;
 5250|  1.77k|	ctxt->end = oldend;
 5251|  1.77k|	return(1);
 5252|  1.83k|    } else if ((CUR == '[') || (CUR == '\\') || (CUR == '.')) {
  ------------------
  |  |   58|  1.65k|#define CUR (*(ctxt->cur))
  ------------------
                  } else if ((CUR == '[') || (CUR == '\\') || (CUR == '.')) {
  ------------------
  |  |   58|  1.32k|#define CUR (*(ctxt->cur))
  ------------------
                  } else if ((CUR == '[') || (CUR == '\\') || (CUR == '.')) {
  ------------------
  |  |   58|     33|#define CUR (*(ctxt->cur))
  ------------------
  |  Branch (5252:16): [True: 324, False: 1.32k]
  |  Branch (5252:32): [True: 1.29k, False: 33]
  |  Branch (5252:49): [True: 8, False: 25]
  ------------------
 5253|  1.62k|	xmlFAParseCharClass(ctxt);
 5254|  1.62k|	return(1);
 5255|  1.62k|    }
 5256|     25|    return(0);
 5257|  9.31k|}
xmlregexp.c:xmlFAIsChar:
 4441|  9.31k|xmlFAIsChar(xmlRegParserCtxtPtr ctxt) {
 4442|  9.31k|    int cur;
 4443|  9.31k|    int len;
 4444|       |
 4445|  9.31k|    len = 4;
 4446|  9.31k|    cur = xmlGetUTF8Char(ctxt->cur, &len);
 4447|  9.31k|    if (cur < 0) {
  ------------------
  |  Branch (4447:9): [True: 11, False: 9.29k]
  ------------------
 4448|     11|        ERROR("Invalid UTF-8");
  ------------------
  |  |   55|     11|    ctxt->error = XML_REGEXP_COMPILE_ERROR;				\
  |  |   56|     11|    xmlRegexpErrCompile(ctxt, str);
  ------------------
 4449|     11|        return(0);
 4450|     11|    }
 4451|  9.29k|    if ((cur == '.') || (cur == '\\') || (cur == '?') ||
  ------------------
  |  Branch (4451:9): [True: 8, False: 9.29k]
  |  Branch (4451:25): [True: 1.29k, False: 7.99k]
  |  Branch (4451:42): [True: 1, False: 7.99k]
  ------------------
 4452|  9.29k|	(cur == '*') || (cur == '+') || (cur == '(') ||
  ------------------
  |  Branch (4452:2): [True: 2, False: 7.99k]
  |  Branch (4452:18): [True: 5, False: 7.98k]
  |  Branch (4452:34): [True: 1.83k, False: 6.15k]
  ------------------
 4453|  9.29k|	(cur == ')') || (cur == '|') || (cur == 0x5B) ||
  ------------------
  |  Branch (4453:2): [True: 1.52k, False: 4.63k]
  |  Branch (4453:18): [True: 993, False: 3.64k]
  |  Branch (4453:34): [True: 324, False: 3.31k]
  ------------------
 4454|  9.29k|	(cur == 0x5D) || (cur == 0))
  ------------------
  |  Branch (4454:2): [True: 6, False: 3.31k]
  |  Branch (4454:19): [True: 187, False: 3.12k]
  ------------------
 4455|  6.17k|	return(-1);
 4456|  3.12k|    return(cur);
 4457|  9.29k|}
xmlregexp.c:xmlFAParseCharClass:
 5068|  1.62k|xmlFAParseCharClass(xmlRegParserCtxtPtr ctxt) {
 5069|  1.62k|    if (CUR == '[') {
  ------------------
  |  |   58|  1.62k|#define CUR (*(ctxt->cur))
  ------------------
  |  Branch (5069:9): [True: 324, False: 1.30k]
  ------------------
 5070|    324|	NEXT;
  ------------------
  |  |   57|    324|#define NEXT ctxt->cur++
  ------------------
 5071|    324|	ctxt->atom = xmlRegNewAtom(ctxt, XML_REGEXP_RANGES);
 5072|    324|	if (ctxt->atom == NULL)
  ------------------
  |  Branch (5072:6): [True: 1, False: 323]
  ------------------
 5073|      1|	    return;
 5074|    323|	xmlFAParseCharGroup(ctxt);
 5075|    323|	if (CUR == ']') {
  ------------------
  |  |   58|    323|#define CUR (*(ctxt->cur))
  ------------------
  |  Branch (5075:6): [True: 293, False: 30]
  ------------------
 5076|    293|	    NEXT;
  ------------------
  |  |   57|    293|#define NEXT ctxt->cur++
  ------------------
 5077|    293|	} else {
 5078|     30|	    ERROR("xmlFAParseCharClass: ']' expected");
  ------------------
  |  |   55|     30|    ctxt->error = XML_REGEXP_COMPILE_ERROR;				\
  |  |   56|     30|    xmlRegexpErrCompile(ctxt, str);
  ------------------
 5079|     30|	}
 5080|  1.30k|    } else {
 5081|  1.30k|	xmlFAParseCharClassEsc(ctxt);
 5082|  1.30k|    }
 5083|  1.62k|}
xmlregexp.c:xmlFAParseCharGroup:
 5032|    339|xmlFAParseCharGroup(xmlRegParserCtxtPtr ctxt) {
 5033|    339|    int neg = ctxt->neg;
 5034|       |
 5035|    339|    if (CUR == '^') {
  ------------------
  |  |   58|    339|#define CUR (*(ctxt->cur))
  ------------------
  |  Branch (5035:9): [True: 2, False: 337]
  ------------------
 5036|      2|	NEXT;
  ------------------
  |  |   57|      2|#define NEXT ctxt->cur++
  ------------------
 5037|      2|	ctxt->neg = !ctxt->neg;
 5038|      2|	xmlFAParsePosCharGroup(ctxt);
 5039|      2|	ctxt->neg = neg;
 5040|      2|    }
 5041|    693|    while ((CUR != ']') && (ctxt->error == 0)) {
  ------------------
  |  |   58|    693|#define CUR (*(ctxt->cur))
  ------------------
  |  Branch (5041:12): [True: 399, False: 294]
  |  Branch (5041:28): [True: 370, False: 29]
  ------------------
 5042|    370|	if ((CUR == '-') && (NXT(1) == '[')) {
  ------------------
  |  |   58|    370|#define CUR (*(ctxt->cur))
  ------------------
              	if ((CUR == '-') && (NXT(1) == '[')) {
  ------------------
  |  |   59|     27|#define NXT(index) (ctxt->cur[index])
  ------------------
  |  Branch (5042:6): [True: 27, False: 343]
  |  Branch (5042:22): [True: 16, False: 11]
  ------------------
 5043|     16|	    NEXT;	/* eat the '-' */
  ------------------
  |  |   57|     16|#define NEXT ctxt->cur++
  ------------------
 5044|     16|	    NEXT;	/* eat the '[' */
  ------------------
  |  |   57|     16|#define NEXT ctxt->cur++
  ------------------
 5045|     16|	    ctxt->neg = 2;
 5046|     16|	    xmlFAParseCharGroup(ctxt);
 5047|     16|	    ctxt->neg = neg;
 5048|     16|	    if (CUR == ']') {
  ------------------
  |  |   58|     16|#define CUR (*(ctxt->cur))
  ------------------
  |  Branch (5048:10): [True: 15, False: 1]
  ------------------
 5049|     15|		NEXT;
  ------------------
  |  |   57|     15|#define NEXT ctxt->cur++
  ------------------
 5050|     15|	    } else {
 5051|      1|		ERROR("charClassExpr: ']' expected");
  ------------------
  |  |   55|      1|    ctxt->error = XML_REGEXP_COMPILE_ERROR;				\
  |  |   56|      1|    xmlRegexpErrCompile(ctxt, str);
  ------------------
 5052|      1|	    }
 5053|     16|	    break;
 5054|    354|	} else {
 5055|    354|	    xmlFAParsePosCharGroup(ctxt);
 5056|    354|	}
 5057|    370|    }
 5058|    339|}
xmlregexp.c:xmlFAParsePosCharGroup:
 5011|    356|xmlFAParsePosCharGroup(xmlRegParserCtxtPtr ctxt) {
 5012|    573|    do {
 5013|    573|	if (CUR == '\\') {
  ------------------
  |  |   58|    573|#define CUR (*(ctxt->cur))
  ------------------
  |  Branch (5013:6): [True: 134, False: 439]
  ------------------
 5014|    134|	    xmlFAParseCharClassEsc(ctxt);
 5015|    439|	} else {
 5016|    439|	    xmlFAParseCharRange(ctxt);
 5017|    439|	}
 5018|    573|    } while ((CUR != ']') && (CUR != '-') &&
  ------------------
  |  |   58|    573|#define CUR (*(ctxt->cur))
  ------------------
                  } while ((CUR != ']') && (CUR != '-') &&
  ------------------
  |  |   58|    279|#define CUR (*(ctxt->cur))
  ------------------
  |  Branch (5018:14): [True: 279, False: 294]
  |  Branch (5018:30): [True: 255, False: 24]
  ------------------
 5019|    573|             (CUR != 0) && (ctxt->error == 0));
  ------------------
  |  |   58|    255|#define CUR (*(ctxt->cur))
  ------------------
  |  Branch (5019:14): [True: 234, False: 21]
  |  Branch (5019:28): [True: 217, False: 17]
  ------------------
 5020|    356|}
xmlregexp.c:xmlFAParseCharRange:
 4909|    439|xmlFAParseCharRange(xmlRegParserCtxtPtr ctxt) {
 4910|    439|    int cur, len;
 4911|    439|    int start = -1;
 4912|    439|    int end = -1;
 4913|       |
 4914|    439|    if (CUR == '\0') {
  ------------------
  |  |   58|    439|#define CUR (*(ctxt->cur))
  ------------------
  |  Branch (4914:9): [True: 9, False: 430]
  ------------------
 4915|      9|        ERROR("Expecting ']'");
  ------------------
  |  |   55|      9|    ctxt->error = XML_REGEXP_COMPILE_ERROR;				\
  |  |   56|      9|    xmlRegexpErrCompile(ctxt, str);
  ------------------
 4916|      9|	return;
 4917|      9|    }
 4918|       |
 4919|    430|    cur = CUR;
  ------------------
  |  |   58|    430|#define CUR (*(ctxt->cur))
  ------------------
 4920|    430|    if (cur == '\\') {
  ------------------
  |  Branch (4920:9): [True: 0, False: 430]
  ------------------
 4921|      0|	NEXT;
  ------------------
  |  |   57|      0|#define NEXT ctxt->cur++
  ------------------
 4922|      0|	cur = CUR;
  ------------------
  |  |   58|      0|#define CUR (*(ctxt->cur))
  ------------------
 4923|      0|	switch (cur) {
 4924|      0|	    case 'n': start = 0xA; break;
  ------------------
  |  Branch (4924:6): [True: 0, False: 0]
  ------------------
 4925|      0|	    case 'r': start = 0xD; break;
  ------------------
  |  Branch (4925:6): [True: 0, False: 0]
  ------------------
 4926|      0|	    case 't': start = 0x9; break;
  ------------------
  |  Branch (4926:6): [True: 0, False: 0]
  ------------------
 4927|      0|	    case '\\': case '|': case '.': case '-': case '^': case '?':
  ------------------
  |  Branch (4927:6): [True: 0, False: 0]
  |  Branch (4927:17): [True: 0, False: 0]
  |  Branch (4927:27): [True: 0, False: 0]
  |  Branch (4927:37): [True: 0, False: 0]
  |  Branch (4927:47): [True: 0, False: 0]
  |  Branch (4927:57): [True: 0, False: 0]
  ------------------
 4928|      0|	    case '*': case '+': case '{': case '}': case '(': case ')':
  ------------------
  |  Branch (4928:6): [True: 0, False: 0]
  |  Branch (4928:16): [True: 0, False: 0]
  |  Branch (4928:26): [True: 0, False: 0]
  |  Branch (4928:36): [True: 0, False: 0]
  |  Branch (4928:46): [True: 0, False: 0]
  |  Branch (4928:56): [True: 0, False: 0]
  ------------------
 4929|      0|	    case '[': case ']':
  ------------------
  |  Branch (4929:6): [True: 0, False: 0]
  |  Branch (4929:16): [True: 0, False: 0]
  ------------------
 4930|      0|		start = cur; break;
 4931|      0|	    default:
  ------------------
  |  Branch (4931:6): [True: 0, False: 0]
  ------------------
 4932|      0|		ERROR("Invalid escape value");
  ------------------
  |  |   55|      0|    ctxt->error = XML_REGEXP_COMPILE_ERROR;				\
  |  |   56|      0|    xmlRegexpErrCompile(ctxt, str);
  ------------------
 4933|      0|		return;
 4934|      0|	}
 4935|      0|	end = start;
 4936|      0|        len = 1;
 4937|    430|    } else if ((cur != 0x5B) && (cur != 0x5D)) {
  ------------------
  |  Branch (4937:16): [True: 424, False: 6]
  |  Branch (4937:33): [True: 424, False: 0]
  ------------------
 4938|    424|        len = 4;
 4939|    424|        end = start = xmlGetUTF8Char(ctxt->cur, &len);
 4940|    424|        if (start < 0) {
  ------------------
  |  Branch (4940:13): [True: 7, False: 417]
  ------------------
 4941|      7|            ERROR("Invalid UTF-8");
  ------------------
  |  |   55|      7|    ctxt->error = XML_REGEXP_COMPILE_ERROR;				\
  |  |   56|      7|    xmlRegexpErrCompile(ctxt, str);
  ------------------
 4942|      7|            return;
 4943|      7|        }
 4944|    424|    } else {
 4945|      6|	ERROR("Expecting a char range");
  ------------------
  |  |   55|      6|    ctxt->error = XML_REGEXP_COMPILE_ERROR;				\
  |  |   56|      6|    xmlRegexpErrCompile(ctxt, str);
  ------------------
 4946|      6|	return;
 4947|      6|    }
 4948|       |    /*
 4949|       |     * Since we are "inside" a range, we can assume ctxt->cur is past
 4950|       |     * the start of ctxt->string, and PREV should be safe
 4951|       |     */
 4952|    417|    if ((start == '-') && (NXT(1) != ']') && (PREV != '[') && (PREV != '^')) {
  ------------------
  |  |   59|     11|#define NXT(index) (ctxt->cur[index])
  ------------------
                  if ((start == '-') && (NXT(1) != ']') && (PREV != '[') && (PREV != '^')) {
  ------------------
  |  |   67|      2|#define PREV (ctxt->cur[-1])
  ------------------
                  if ((start == '-') && (NXT(1) != ']') && (PREV != '[') && (PREV != '^')) {
  ------------------
  |  |   67|      1|#define PREV (ctxt->cur[-1])
  ------------------
  |  Branch (4952:9): [True: 11, False: 406]
  |  Branch (4952:27): [True: 2, False: 9]
  |  Branch (4952:46): [True: 1, False: 1]
  |  Branch (4952:63): [True: 1, False: 0]
  ------------------
 4953|      1|	NEXTL(len);
  ------------------
  |  |   61|      1|#define NEXTL(l) ctxt->cur += l;
  ------------------
 4954|      1|	return;
 4955|      1|    }
 4956|    416|    NEXTL(len);
  ------------------
  |  |   61|    416|#define NEXTL(l) ctxt->cur += l;
  ------------------
 4957|    416|    cur = CUR;
  ------------------
  |  |   58|    416|#define CUR (*(ctxt->cur))
  ------------------
 4958|    416|    if ((cur != '-') || (NXT(1) == '[') || (NXT(1) == ']')) {
  ------------------
  |  |   59|    185|#define NXT(index) (ctxt->cur[index])
  ------------------
                  if ((cur != '-') || (NXT(1) == '[') || (NXT(1) == ']')) {
  ------------------
  |  |   59|    183|#define NXT(index) (ctxt->cur[index])
  ------------------
  |  Branch (4958:9): [True: 231, False: 185]
  |  Branch (4958:25): [True: 2, False: 183]
  |  Branch (4958:44): [True: 7, False: 176]
  ------------------
 4959|    240|        xmlRegAtomAddRange(ctxt, ctxt->atom, ctxt->neg,
 4960|    240|		              XML_REGEXP_CHARVAL, start, end, NULL);
 4961|    240|	return;
 4962|    240|    }
 4963|    176|    NEXT;
  ------------------
  |  |   57|    176|#define NEXT ctxt->cur++
  ------------------
 4964|    176|    cur = CUR;
  ------------------
  |  |   58|    176|#define CUR (*(ctxt->cur))
  ------------------
 4965|    176|    if (cur == '\\') {
  ------------------
  |  Branch (4965:9): [True: 1, False: 175]
  ------------------
 4966|      1|	NEXT;
  ------------------
  |  |   57|      1|#define NEXT ctxt->cur++
  ------------------
 4967|      1|	cur = CUR;
  ------------------
  |  |   58|      1|#define CUR (*(ctxt->cur))
  ------------------
 4968|      1|	switch (cur) {
 4969|      0|	    case 'n': end = 0xA; break;
  ------------------
  |  Branch (4969:6): [True: 0, False: 1]
  ------------------
 4970|      0|	    case 'r': end = 0xD; break;
  ------------------
  |  Branch (4970:6): [True: 0, False: 1]
  ------------------
 4971|      0|	    case 't': end = 0x9; break;
  ------------------
  |  Branch (4971:6): [True: 0, False: 1]
  ------------------
 4972|      0|	    case '\\': case '|': case '.': case '-': case '^': case '?':
  ------------------
  |  Branch (4972:6): [True: 0, False: 1]
  |  Branch (4972:17): [True: 0, False: 1]
  |  Branch (4972:27): [True: 0, False: 1]
  |  Branch (4972:37): [True: 0, False: 1]
  |  Branch (4972:47): [True: 0, False: 1]
  |  Branch (4972:57): [True: 0, False: 1]
  ------------------
 4973|      0|	    case '*': case '+': case '{': case '}': case '(': case ')':
  ------------------
  |  Branch (4973:6): [True: 0, False: 1]
  |  Branch (4973:16): [True: 0, False: 1]
  |  Branch (4973:26): [True: 0, False: 1]
  |  Branch (4973:36): [True: 0, False: 1]
  |  Branch (4973:46): [True: 0, False: 1]
  |  Branch (4973:56): [True: 0, False: 1]
  ------------------
 4974|      0|	    case '[': case ']':
  ------------------
  |  Branch (4974:6): [True: 0, False: 1]
  |  Branch (4974:16): [True: 0, False: 1]
  ------------------
 4975|      0|		end = cur; break;
 4976|      1|	    default:
  ------------------
  |  Branch (4976:6): [True: 1, False: 0]
  ------------------
 4977|      1|		ERROR("Invalid escape value");
  ------------------
  |  |   55|      1|    ctxt->error = XML_REGEXP_COMPILE_ERROR;				\
  |  |   56|      1|    xmlRegexpErrCompile(ctxt, str);
  ------------------
 4978|      1|		return;
 4979|      1|	}
 4980|      0|        len = 1;
 4981|    175|    } else if ((cur != '\0') && (cur != 0x5B) && (cur != 0x5D)) {
  ------------------
  |  Branch (4981:16): [True: 174, False: 1]
  |  Branch (4981:33): [True: 174, False: 0]
  |  Branch (4981:50): [True: 174, False: 0]
  ------------------
 4982|    174|        len = 4;
 4983|    174|        end = xmlGetUTF8Char(ctxt->cur, &len);
 4984|    174|        if (end < 0) {
  ------------------
  |  Branch (4984:13): [True: 1, False: 173]
  ------------------
 4985|      1|            ERROR("Invalid UTF-8");
  ------------------
  |  |   55|      1|    ctxt->error = XML_REGEXP_COMPILE_ERROR;				\
  |  |   56|      1|    xmlRegexpErrCompile(ctxt, str);
  ------------------
 4986|      1|            return;
 4987|      1|        }
 4988|    174|    } else {
 4989|      1|	ERROR("Expecting the end of a char range");
  ------------------
  |  |   55|      1|    ctxt->error = XML_REGEXP_COMPILE_ERROR;				\
  |  |   56|      1|    xmlRegexpErrCompile(ctxt, str);
  ------------------
 4990|      1|	return;
 4991|      1|    }
 4992|       |
 4993|       |    /* TODO check that the values are acceptable character ranges for XML */
 4994|    173|    if (end < start) {
  ------------------
  |  Branch (4994:9): [True: 1, False: 172]
  ------------------
 4995|      1|	ERROR("End of range is before start of range");
  ------------------
  |  |   55|      1|    ctxt->error = XML_REGEXP_COMPILE_ERROR;				\
  |  |   56|      1|    xmlRegexpErrCompile(ctxt, str);
  ------------------
 4996|    172|    } else {
 4997|    172|        NEXTL(len);
  ------------------
  |  |   61|    172|#define NEXTL(l) ctxt->cur += l;
  ------------------
 4998|    172|        xmlRegAtomAddRange(ctxt, ctxt->atom, ctxt->neg,
 4999|    172|		           XML_REGEXP_CHARVAL, start, end, NULL);
 5000|    172|    }
 5001|    173|    return;
 5002|    176|}
xmlregexp.c:xmlRegAtomAddRange:
 1186|    545|		   xmlChar *blockName) {
 1187|    545|    xmlRegRangePtr range;
 1188|       |
 1189|    545|    if (atom == NULL) {
  ------------------
  |  Branch (1189:9): [True: 0, False: 545]
  ------------------
 1190|      0|	ERROR("add range: atom is NULL");
  ------------------
  |  |   55|      0|    ctxt->error = XML_REGEXP_COMPILE_ERROR;				\
  |  |   56|      0|    xmlRegexpErrCompile(ctxt, str);
  ------------------
 1191|      0|	return(NULL);
 1192|      0|    }
 1193|    545|    if (atom->type != XML_REGEXP_RANGES) {
  ------------------
  |  Branch (1193:9): [True: 0, False: 545]
  ------------------
 1194|      0|	ERROR("add range: atom is not ranges");
  ------------------
  |  |   55|      0|    ctxt->error = XML_REGEXP_COMPILE_ERROR;				\
  |  |   56|      0|    xmlRegexpErrCompile(ctxt, str);
  ------------------
 1195|      0|	return(NULL);
 1196|      0|    }
 1197|    545|    if (atom->maxRanges == 0) {
  ------------------
  |  Branch (1197:9): [True: 314, False: 231]
  ------------------
 1198|    314|	atom->maxRanges = 4;
 1199|    314|	atom->ranges = (xmlRegRangePtr *) xmlMalloc(atom->maxRanges *
 1200|    314|		                             sizeof(xmlRegRangePtr));
 1201|    314|	if (atom->ranges == NULL) {
  ------------------
  |  Branch (1201:6): [True: 0, False: 314]
  ------------------
 1202|      0|	    xmlRegexpErrMemory(ctxt, "adding ranges");
 1203|      0|	    atom->maxRanges = 0;
 1204|      0|	    return(NULL);
 1205|      0|	}
 1206|    314|    } else if (atom->nbRanges >= atom->maxRanges) {
  ------------------
  |  Branch (1206:16): [True: 22, False: 209]
  ------------------
 1207|     22|	xmlRegRangePtr *tmp;
 1208|     22|	atom->maxRanges *= 2;
 1209|     22|	tmp = (xmlRegRangePtr *) xmlRealloc(atom->ranges, atom->maxRanges *
 1210|     22|		                             sizeof(xmlRegRangePtr));
 1211|     22|	if (tmp == NULL) {
  ------------------
  |  Branch (1211:6): [True: 1, False: 21]
  ------------------
 1212|      1|	    xmlRegexpErrMemory(ctxt, "adding ranges");
 1213|      1|	    atom->maxRanges /= 2;
 1214|      1|	    return(NULL);
 1215|      1|	}
 1216|     21|	atom->ranges = tmp;
 1217|     21|    }
 1218|    544|    range = xmlRegNewRange(ctxt, neg, type, start, end);
 1219|    544|    if (range == NULL)
  ------------------
  |  Branch (1219:9): [True: 1, False: 543]
  ------------------
 1220|      1|	return(NULL);
 1221|    543|    range->blockName = blockName;
 1222|    543|    atom->ranges[atom->nbRanges++] = range;
 1223|       |
 1224|    543|    return(range);
 1225|    544|}
xmlregexp.c:xmlRegNewRange:
  725|    544|	       int neg, xmlRegAtomType type, int start, int end) {
  726|    544|    xmlRegRangePtr ret;
  727|       |
  728|    544|    ret = (xmlRegRangePtr) xmlMalloc(sizeof(xmlRegRange));
  729|    544|    if (ret == NULL) {
  ------------------
  |  Branch (729:9): [True: 1, False: 543]
  ------------------
  730|      1|	xmlRegexpErrMemory(ctxt, "allocating range");
  731|      1|	return(NULL);
  732|      1|    }
  733|    543|    ret->neg = neg;
  734|    543|    ret->type = type;
  735|    543|    ret->start = start;
  736|    543|    ret->end = end;
  737|    543|    return(ret);
  738|    544|}
xmlregexp.c:xmlFAParseCharClassEsc:
 4739|  1.43k|xmlFAParseCharClassEsc(xmlRegParserCtxtPtr ctxt) {
 4740|  1.43k|    int cur;
 4741|       |
 4742|  1.43k|    if (CUR == '.') {
  ------------------
  |  |   58|  1.43k|#define CUR (*(ctxt->cur))
  ------------------
  |  Branch (4742:9): [True: 8, False: 1.42k]
  ------------------
 4743|      8|	if (ctxt->atom == NULL) {
  ------------------
  |  Branch (4743:6): [True: 8, False: 0]
  ------------------
 4744|      8|	    ctxt->atom = xmlRegNewAtom(ctxt, XML_REGEXP_ANYCHAR);
 4745|      8|	} else if (ctxt->atom->type == XML_REGEXP_RANGES) {
  ------------------
  |  Branch (4745:13): [True: 0, False: 0]
  ------------------
 4746|      0|	    xmlRegAtomAddRange(ctxt, ctxt->atom, ctxt->neg,
 4747|      0|			       XML_REGEXP_ANYCHAR, 0, 0, NULL);
 4748|      0|	}
 4749|      8|	NEXT;
  ------------------
  |  |   57|      8|#define NEXT ctxt->cur++
  ------------------
 4750|      8|	return;
 4751|      8|    }
 4752|  1.42k|    if (CUR != '\\') {
  ------------------
  |  |   58|  1.42k|#define CUR (*(ctxt->cur))
  ------------------
  |  Branch (4752:9): [True: 0, False: 1.42k]
  ------------------
 4753|      0|	ERROR("Escaped sequence: expecting \\");
  ------------------
  |  |   55|      0|    ctxt->error = XML_REGEXP_COMPILE_ERROR;				\
  |  |   56|      0|    xmlRegexpErrCompile(ctxt, str);
  ------------------
 4754|      0|	return;
 4755|      0|    }
 4756|  1.42k|    NEXT;
  ------------------
  |  |   57|  1.42k|#define NEXT ctxt->cur++
  ------------------
 4757|  1.42k|    cur = CUR;
  ------------------
  |  |   58|  1.42k|#define CUR (*(ctxt->cur))
  ------------------
 4758|  1.42k|    if (cur == 'p') {
  ------------------
  |  Branch (4758:9): [True: 97, False: 1.33k]
  ------------------
 4759|     97|	NEXT;
  ------------------
  |  |   57|     97|#define NEXT ctxt->cur++
  ------------------
 4760|     97|	if (CUR != '{') {
  ------------------
  |  |   58|     97|#define CUR (*(ctxt->cur))
  ------------------
  |  Branch (4760:6): [True: 2, False: 95]
  ------------------
 4761|      2|	    ERROR("Expecting '{'");
  ------------------
  |  |   55|      2|    ctxt->error = XML_REGEXP_COMPILE_ERROR;				\
  |  |   56|      2|    xmlRegexpErrCompile(ctxt, str);
  ------------------
 4762|      2|	    return;
 4763|      2|	}
 4764|     95|	NEXT;
  ------------------
  |  |   57|     95|#define NEXT ctxt->cur++
  ------------------
 4765|     95|	xmlFAParseCharProp(ctxt);
 4766|     95|	if (CUR != '}') {
  ------------------
  |  |   58|     95|#define CUR (*(ctxt->cur))
  ------------------
  |  Branch (4766:6): [True: 19, False: 76]
  ------------------
 4767|     19|	    ERROR("Expecting '}'");
  ------------------
  |  |   55|     19|    ctxt->error = XML_REGEXP_COMPILE_ERROR;				\
  |  |   56|     19|    xmlRegexpErrCompile(ctxt, str);
  ------------------
 4768|     19|	    return;
 4769|     19|	}
 4770|     76|	NEXT;
  ------------------
  |  |   57|     76|#define NEXT ctxt->cur++
  ------------------
 4771|  1.33k|    } else if (cur == 'P') {
  ------------------
  |  Branch (4771:16): [True: 0, False: 1.33k]
  ------------------
 4772|      0|	NEXT;
  ------------------
  |  |   57|      0|#define NEXT ctxt->cur++
  ------------------
 4773|      0|	if (CUR != '{') {
  ------------------
  |  |   58|      0|#define CUR (*(ctxt->cur))
  ------------------
  |  Branch (4773:6): [True: 0, False: 0]
  ------------------
 4774|      0|	    ERROR("Expecting '{'");
  ------------------
  |  |   55|      0|    ctxt->error = XML_REGEXP_COMPILE_ERROR;				\
  |  |   56|      0|    xmlRegexpErrCompile(ctxt, str);
  ------------------
 4775|      0|	    return;
 4776|      0|	}
 4777|      0|	NEXT;
  ------------------
  |  |   57|      0|#define NEXT ctxt->cur++
  ------------------
 4778|      0|	xmlFAParseCharProp(ctxt);
 4779|      0|        if (ctxt->atom != NULL)
  ------------------
  |  Branch (4779:13): [True: 0, False: 0]
  ------------------
 4780|      0|	    ctxt->atom->neg = 1;
 4781|      0|	if (CUR != '}') {
  ------------------
  |  |   58|      0|#define CUR (*(ctxt->cur))
  ------------------
  |  Branch (4781:6): [True: 0, False: 0]
  ------------------
 4782|      0|	    ERROR("Expecting '}'");
  ------------------
  |  |   55|      0|    ctxt->error = XML_REGEXP_COMPILE_ERROR;				\
  |  |   56|      0|    xmlRegexpErrCompile(ctxt, str);
  ------------------
 4783|      0|	    return;
 4784|      0|	}
 4785|      0|	NEXT;
  ------------------
  |  |   57|      0|#define NEXT ctxt->cur++
  ------------------
 4786|  1.33k|    } else if ((cur == 'n') || (cur == 'r') || (cur == 't') || (cur == '\\') ||
  ------------------
  |  Branch (4786:16): [True: 0, False: 1.33k]
  |  Branch (4786:32): [True: 0, False: 1.33k]
  |  Branch (4786:48): [True: 1, False: 1.33k]
  |  Branch (4786:64): [True: 0, False: 1.33k]
  ------------------
 4787|  1.33k|	(cur == '|') || (cur == '.') || (cur == '?') || (cur == '*') ||
  ------------------
  |  Branch (4787:2): [True: 39, False: 1.29k]
  |  Branch (4787:18): [True: 284, False: 1.00k]
  |  Branch (4787:34): [True: 2, False: 1.00k]
  |  Branch (4787:50): [True: 143, False: 862]
  ------------------
 4788|  1.33k|	(cur == '+') || (cur == '(') || (cur == ')') || (cur == '{') ||
  ------------------
  |  Branch (4788:2): [True: 13, False: 849]
  |  Branch (4788:18): [True: 1, False: 848]
  |  Branch (4788:34): [True: 4, False: 844]
  |  Branch (4788:50): [True: 1, False: 843]
  ------------------
 4789|  1.33k|	(cur == '}') || (cur == 0x2D) || (cur == 0x5B) || (cur == 0x5D) ||
  ------------------
  |  Branch (4789:2): [True: 0, False: 843]
  |  Branch (4789:18): [True: 93, False: 750]
  |  Branch (4789:35): [True: 1, False: 749]
  |  Branch (4789:52): [True: 1, False: 748]
  ------------------
 4790|  1.33k|	(cur == 0x5E) ||
  ------------------
  |  Branch (4790:2): [True: 0, False: 748]
  ------------------
 4791|       |
 4792|       |	/* Non-standard escape sequences:
 4793|       |	 *                  Java 1.8|.NET Core 3.1|MSXML 6 */
 4794|  1.33k|	(cur == '!') ||     /*   +  |     +       |    +   */
  ------------------
  |  Branch (4794:2): [True: 0, False: 748]
  ------------------
 4795|  1.33k|	(cur == '"') ||     /*   +  |     +       |    +   */
  ------------------
  |  Branch (4795:2): [True: 1, False: 747]
  ------------------
 4796|  1.33k|	(cur == '#') ||     /*   +  |     +       |    +   */
  ------------------
  |  Branch (4796:2): [True: 0, False: 747]
  ------------------
 4797|  1.33k|	(cur == '$') ||     /*   +  |     +       |    +   */
  ------------------
  |  Branch (4797:2): [True: 2, False: 745]
  ------------------
 4798|  1.33k|	(cur == '%') ||     /*   +  |     +       |    +   */
  ------------------
  |  Branch (4798:2): [True: 0, False: 745]
  ------------------
 4799|  1.33k|	(cur == ',') ||     /*   +  |     +       |    +   */
  ------------------
  |  Branch (4799:2): [True: 0, False: 745]
  ------------------
 4800|  1.33k|	(cur == '/') ||     /*   +  |     +       |    +   */
  ------------------
  |  Branch (4800:2): [True: 3, False: 742]
  ------------------
 4801|  1.33k|	(cur == ':') ||     /*   +  |     +       |    +   */
  ------------------
  |  Branch (4801:2): [True: 3, False: 739]
  ------------------
 4802|  1.33k|	(cur == ';') ||     /*   +  |     +       |    +   */
  ------------------
  |  Branch (4802:2): [True: 0, False: 739]
  ------------------
 4803|  1.33k|	(cur == '=') ||     /*   +  |     +       |    +   */
  ------------------
  |  Branch (4803:2): [True: 0, False: 739]
  ------------------
 4804|  1.33k|	(cur == '>') ||     /*      |     +       |    +   */
  ------------------
  |  Branch (4804:2): [True: 0, False: 739]
  ------------------
 4805|  1.33k|	(cur == '@') ||     /*   +  |     +       |    +   */
  ------------------
  |  Branch (4805:2): [True: 0, False: 739]
  ------------------
 4806|  1.33k|	(cur == '`') ||     /*   +  |     +       |    +   */
  ------------------
  |  Branch (4806:2): [True: 1, False: 738]
  ------------------
 4807|  1.33k|	(cur == '~') ||     /*   +  |     +       |    +   */
  ------------------
  |  Branch (4807:2): [True: 0, False: 738]
  ------------------
 4808|  1.33k|	(cur == 'u')) {     /*      |     +       |    +   */
  ------------------
  |  Branch (4808:2): [True: 0, False: 738]
  ------------------
 4809|    593|	if (ctxt->atom == NULL) {
  ------------------
  |  Branch (4809:6): [True: 583, False: 10]
  ------------------
 4810|    583|	    ctxt->atom = xmlRegNewAtom(ctxt, XML_REGEXP_CHARVAL);
 4811|    583|	    if (ctxt->atom != NULL) {
  ------------------
  |  Branch (4811:10): [True: 582, False: 1]
  ------------------
 4812|    582|	        switch (cur) {
 4813|      0|		    case 'n':
  ------------------
  |  Branch (4813:7): [True: 0, False: 582]
  ------------------
 4814|      0|		        ctxt->atom->codepoint = '\n';
 4815|      0|			break;
 4816|      0|		    case 'r':
  ------------------
  |  Branch (4816:7): [True: 0, False: 582]
  ------------------
 4817|      0|		        ctxt->atom->codepoint = '\r';
 4818|      0|			break;
 4819|      1|		    case 't':
  ------------------
  |  Branch (4819:7): [True: 1, False: 581]
  ------------------
 4820|      1|		        ctxt->atom->codepoint = '\t';
 4821|      1|			break;
 4822|      0|		    case 'u':
  ------------------
  |  Branch (4822:7): [True: 0, False: 582]
  ------------------
 4823|      0|			cur = parse_escaped_codepoint(ctxt);
 4824|      0|			if (cur < 0) {
  ------------------
  |  Branch (4824:8): [True: 0, False: 0]
  ------------------
 4825|      0|			    return;
 4826|      0|			}
 4827|      0|			ctxt->atom->codepoint = cur;
 4828|      0|			break;
 4829|    581|		    default:
  ------------------
  |  Branch (4829:7): [True: 581, False: 1]
  ------------------
 4830|    581|			ctxt->atom->codepoint = cur;
 4831|    582|		}
 4832|    582|	    }
 4833|    583|	} else if (ctxt->atom->type == XML_REGEXP_RANGES) {
  ------------------
  |  Branch (4833:13): [True: 10, False: 0]
  ------------------
 4834|     10|            switch (cur) {
  ------------------
  |  Branch (4834:21): [True: 10, False: 0]
  ------------------
 4835|      0|                case 'n':
  ------------------
  |  Branch (4835:17): [True: 0, False: 10]
  ------------------
 4836|      0|                    cur = '\n';
 4837|      0|                    break;
 4838|      0|                case 'r':
  ------------------
  |  Branch (4838:17): [True: 0, False: 10]
  ------------------
 4839|      0|                    cur = '\r';
 4840|      0|                    break;
 4841|      0|                case 't':
  ------------------
  |  Branch (4841:17): [True: 0, False: 10]
  ------------------
 4842|      0|                    cur = '\t';
 4843|      0|                    break;
 4844|     10|            }
 4845|     10|	    xmlRegAtomAddRange(ctxt, ctxt->atom, ctxt->neg,
 4846|     10|			       XML_REGEXP_CHARVAL, cur, cur, NULL);
 4847|     10|	}
 4848|    593|	NEXT;
  ------------------
  |  |   57|    593|#define NEXT ctxt->cur++
  ------------------
 4849|    738|    } else if ((cur == 's') || (cur == 'S') || (cur == 'i') || (cur == 'I') ||
  ------------------
  |  Branch (4849:16): [True: 87, False: 651]
  |  Branch (4849:32): [True: 0, False: 651]
  |  Branch (4849:48): [True: 320, False: 331]
  |  Branch (4849:64): [True: 1, False: 330]
  ------------------
 4850|    738|	(cur == 'c') || (cur == 'C') || (cur == 'd') || (cur == 'D') ||
  ------------------
  |  Branch (4850:2): [True: 307, False: 23]
  |  Branch (4850:18): [True: 0, False: 23]
  |  Branch (4850:34): [True: 16, False: 7]
  |  Branch (4850:50): [True: 0, False: 7]
  ------------------
 4851|    738|	(cur == 'w') || (cur == 'W')) {
  ------------------
  |  Branch (4851:2): [True: 0, False: 7]
  |  Branch (4851:18): [True: 0, False: 7]
  ------------------
 4852|    731|	xmlRegAtomType type = XML_REGEXP_ANYSPACE;
 4853|       |
 4854|    731|	switch (cur) {
  ------------------
  |  Branch (4854:10): [True: 0, False: 731]
  ------------------
 4855|     87|	    case 's':
  ------------------
  |  Branch (4855:6): [True: 87, False: 644]
  ------------------
 4856|     87|		type = XML_REGEXP_ANYSPACE;
 4857|     87|		break;
 4858|      0|	    case 'S':
  ------------------
  |  Branch (4858:6): [True: 0, False: 731]
  ------------------
 4859|      0|		type = XML_REGEXP_NOTSPACE;
 4860|      0|		break;
 4861|    320|	    case 'i':
  ------------------
  |  Branch (4861:6): [True: 320, False: 411]
  ------------------
 4862|    320|		type = XML_REGEXP_INITNAME;
 4863|    320|		break;
 4864|      1|	    case 'I':
  ------------------
  |  Branch (4864:6): [True: 1, False: 730]
  ------------------
 4865|      1|		type = XML_REGEXP_NOTINITNAME;
 4866|      1|		break;
 4867|    307|	    case 'c':
  ------------------
  |  Branch (4867:6): [True: 307, False: 424]
  ------------------
 4868|    307|		type = XML_REGEXP_NAMECHAR;
 4869|    307|		break;
 4870|      0|	    case 'C':
  ------------------
  |  Branch (4870:6): [True: 0, False: 731]
  ------------------
 4871|      0|		type = XML_REGEXP_NOTNAMECHAR;
 4872|      0|		break;
 4873|     16|	    case 'd':
  ------------------
  |  Branch (4873:6): [True: 16, False: 715]
  ------------------
 4874|     16|		type = XML_REGEXP_DECIMAL;
 4875|     16|		break;
 4876|      0|	    case 'D':
  ------------------
  |  Branch (4876:6): [True: 0, False: 731]
  ------------------
 4877|      0|		type = XML_REGEXP_NOTDECIMAL;
 4878|      0|		break;
 4879|      0|	    case 'w':
  ------------------
  |  Branch (4879:6): [True: 0, False: 731]
  ------------------
 4880|      0|		type = XML_REGEXP_REALCHAR;
 4881|      0|		break;
 4882|      0|	    case 'W':
  ------------------
  |  Branch (4882:6): [True: 0, False: 731]
  ------------------
 4883|      0|		type = XML_REGEXP_NOTREALCHAR;
 4884|      0|		break;
 4885|    731|	}
 4886|    731|	NEXT;
  ------------------
  |  |   57|    731|#define NEXT ctxt->cur++
  ------------------
 4887|    731|	if (ctxt->atom == NULL) {
  ------------------
  |  Branch (4887:6): [True: 627, False: 104]
  ------------------
 4888|    627|	    ctxt->atom = xmlRegNewAtom(ctxt, type);
 4889|    627|	} else if (ctxt->atom->type == XML_REGEXP_RANGES) {
  ------------------
  |  Branch (4889:13): [True: 104, False: 0]
  ------------------
 4890|    104|	    xmlRegAtomAddRange(ctxt, ctxt->atom, ctxt->neg,
 4891|    104|			       type, 0, 0, NULL);
 4892|    104|	}
 4893|    731|    } else {
 4894|      7|	ERROR("Wrong escape sequence, misuse of character '\\'");
  ------------------
  |  |   55|      7|    ctxt->error = XML_REGEXP_COMPILE_ERROR;				\
  |  |   56|      7|    xmlRegexpErrCompile(ctxt, str);
  ------------------
 4895|      7|    }
 4896|  1.42k|}
xmlregexp.c:xmlFAParseCharProp:
 4476|     95|xmlFAParseCharProp(xmlRegParserCtxtPtr ctxt) {
 4477|     95|    int cur;
 4478|     95|    xmlRegAtomType type = (xmlRegAtomType) 0;
 4479|     95|    xmlChar *blockName = NULL;
 4480|       |
 4481|     95|    cur = CUR;
  ------------------
  |  |   58|     95|#define CUR (*(ctxt->cur))
  ------------------
 4482|     95|    if (cur == 'L') {
  ------------------
  |  Branch (4482:9): [True: 0, False: 95]
  ------------------
 4483|      0|	NEXT;
  ------------------
  |  |   57|      0|#define NEXT ctxt->cur++
  ------------------
 4484|      0|	cur = CUR;
  ------------------
  |  |   58|      0|#define CUR (*(ctxt->cur))
  ------------------
 4485|      0|	if (cur == 'u') {
  ------------------
  |  Branch (4485:6): [True: 0, False: 0]
  ------------------
 4486|      0|	    NEXT;
  ------------------
  |  |   57|      0|#define NEXT ctxt->cur++
  ------------------
 4487|      0|	    type = XML_REGEXP_LETTER_UPPERCASE;
 4488|      0|	} else if (cur == 'l') {
  ------------------
  |  Branch (4488:13): [True: 0, False: 0]
  ------------------
 4489|      0|	    NEXT;
  ------------------
  |  |   57|      0|#define NEXT ctxt->cur++
  ------------------
 4490|      0|	    type = XML_REGEXP_LETTER_LOWERCASE;
 4491|      0|	} else if (cur == 't') {
  ------------------
  |  Branch (4491:13): [True: 0, False: 0]
  ------------------
 4492|      0|	    NEXT;
  ------------------
  |  |   57|      0|#define NEXT ctxt->cur++
  ------------------
 4493|      0|	    type = XML_REGEXP_LETTER_TITLECASE;
 4494|      0|	} else if (cur == 'm') {
  ------------------
  |  Branch (4494:13): [True: 0, False: 0]
  ------------------
 4495|      0|	    NEXT;
  ------------------
  |  |   57|      0|#define NEXT ctxt->cur++
  ------------------
 4496|      0|	    type = XML_REGEXP_LETTER_MODIFIER;
 4497|      0|	} else if (cur == 'o') {
  ------------------
  |  Branch (4497:13): [True: 0, False: 0]
  ------------------
 4498|      0|	    NEXT;
  ------------------
  |  |   57|      0|#define NEXT ctxt->cur++
  ------------------
 4499|      0|	    type = XML_REGEXP_LETTER_OTHERS;
 4500|      0|	} else {
 4501|      0|	    type = XML_REGEXP_LETTER;
 4502|      0|	}
 4503|     95|    } else if (cur == 'M') {
  ------------------
  |  Branch (4503:16): [True: 1, False: 94]
  ------------------
 4504|      1|	NEXT;
  ------------------
  |  |   57|      1|#define NEXT ctxt->cur++
  ------------------
 4505|      1|	cur = CUR;
  ------------------
  |  |   58|      1|#define CUR (*(ctxt->cur))
  ------------------
 4506|      1|	if (cur == 'n') {
  ------------------
  |  Branch (4506:6): [True: 0, False: 1]
  ------------------
 4507|      0|	    NEXT;
  ------------------
  |  |   57|      0|#define NEXT ctxt->cur++
  ------------------
 4508|       |	    /* nonspacing */
 4509|      0|	    type = XML_REGEXP_MARK_NONSPACING;
 4510|      1|	} else if (cur == 'c') {
  ------------------
  |  Branch (4510:13): [True: 0, False: 1]
  ------------------
 4511|      0|	    NEXT;
  ------------------
  |  |   57|      0|#define NEXT ctxt->cur++
  ------------------
 4512|       |	    /* spacing combining */
 4513|      0|	    type = XML_REGEXP_MARK_SPACECOMBINING;
 4514|      1|	} else if (cur == 'e') {
  ------------------
  |  Branch (4514:13): [True: 0, False: 1]
  ------------------
 4515|      0|	    NEXT;
  ------------------
  |  |   57|      0|#define NEXT ctxt->cur++
  ------------------
 4516|       |	    /* enclosing */
 4517|      0|	    type = XML_REGEXP_MARK_ENCLOSING;
 4518|      1|	} else {
 4519|       |	    /* all marks */
 4520|      1|	    type = XML_REGEXP_MARK;
 4521|      1|	}
 4522|     94|    } else if (cur == 'N') {
  ------------------
  |  Branch (4522:16): [True: 9, False: 85]
  ------------------
 4523|      9|	NEXT;
  ------------------
  |  |   57|      9|#define NEXT ctxt->cur++
  ------------------
 4524|      9|	cur = CUR;
  ------------------
  |  |   58|      9|#define CUR (*(ctxt->cur))
  ------------------
 4525|      9|	if (cur == 'd') {
  ------------------
  |  Branch (4525:6): [True: 8, False: 1]
  ------------------
 4526|      8|	    NEXT;
  ------------------
  |  |   57|      8|#define NEXT ctxt->cur++
  ------------------
 4527|       |	    /* digital */
 4528|      8|	    type = XML_REGEXP_NUMBER_DECIMAL;
 4529|      8|	} else if (cur == 'l') {
  ------------------
  |  Branch (4529:13): [True: 0, False: 1]
  ------------------
 4530|      0|	    NEXT;
  ------------------
  |  |   57|      0|#define NEXT ctxt->cur++
  ------------------
 4531|       |	    /* letter */
 4532|      0|	    type = XML_REGEXP_NUMBER_LETTER;
 4533|      1|	} else if (cur == 'o') {
  ------------------
  |  Branch (4533:13): [True: 0, False: 1]
  ------------------
 4534|      0|	    NEXT;
  ------------------
  |  |   57|      0|#define NEXT ctxt->cur++
  ------------------
 4535|       |	    /* other */
 4536|      0|	    type = XML_REGEXP_NUMBER_OTHERS;
 4537|      1|	} else {
 4538|       |	    /* all numbers */
 4539|      1|	    type = XML_REGEXP_NUMBER;
 4540|      1|	}
 4541|     85|    } else if (cur == 'P') {
  ------------------
  |  Branch (4541:16): [True: 0, False: 85]
  ------------------
 4542|      0|	NEXT;
  ------------------
  |  |   57|      0|#define NEXT ctxt->cur++
  ------------------
 4543|      0|	cur = CUR;
  ------------------
  |  |   58|      0|#define CUR (*(ctxt->cur))
  ------------------
 4544|      0|	if (cur == 'c') {
  ------------------
  |  Branch (4544:6): [True: 0, False: 0]
  ------------------
 4545|      0|	    NEXT;
  ------------------
  |  |   57|      0|#define NEXT ctxt->cur++
  ------------------
 4546|       |	    /* connector */
 4547|      0|	    type = XML_REGEXP_PUNCT_CONNECTOR;
 4548|      0|	} else if (cur == 'd') {
  ------------------
  |  Branch (4548:13): [True: 0, False: 0]
  ------------------
 4549|      0|	    NEXT;
  ------------------
  |  |   57|      0|#define NEXT ctxt->cur++
  ------------------
 4550|       |	    /* dash */
 4551|      0|	    type = XML_REGEXP_PUNCT_DASH;
 4552|      0|	} else if (cur == 's') {
  ------------------
  |  Branch (4552:13): [True: 0, False: 0]
  ------------------
 4553|      0|	    NEXT;
  ------------------
  |  |   57|      0|#define NEXT ctxt->cur++
  ------------------
 4554|       |	    /* open */
 4555|      0|	    type = XML_REGEXP_PUNCT_OPEN;
 4556|      0|	} else if (cur == 'e') {
  ------------------
  |  Branch (4556:13): [True: 0, False: 0]
  ------------------
 4557|      0|	    NEXT;
  ------------------
  |  |   57|      0|#define NEXT ctxt->cur++
  ------------------
 4558|       |	    /* close */
 4559|      0|	    type = XML_REGEXP_PUNCT_CLOSE;
 4560|      0|	} else if (cur == 'i') {
  ------------------
  |  Branch (4560:13): [True: 0, False: 0]
  ------------------
 4561|      0|	    NEXT;
  ------------------
  |  |   57|      0|#define NEXT ctxt->cur++
  ------------------
 4562|       |	    /* initial quote */
 4563|      0|	    type = XML_REGEXP_PUNCT_INITQUOTE;
 4564|      0|	} else if (cur == 'f') {
  ------------------
  |  Branch (4564:13): [True: 0, False: 0]
  ------------------
 4565|      0|	    NEXT;
  ------------------
  |  |   57|      0|#define NEXT ctxt->cur++
  ------------------
 4566|       |	    /* final quote */
 4567|      0|	    type = XML_REGEXP_PUNCT_FINQUOTE;
 4568|      0|	} else if (cur == 'o') {
  ------------------
  |  Branch (4568:13): [True: 0, False: 0]
  ------------------
 4569|      0|	    NEXT;
  ------------------
  |  |   57|      0|#define NEXT ctxt->cur++
  ------------------
 4570|       |	    /* other */
 4571|      0|	    type = XML_REGEXP_PUNCT_OTHERS;
 4572|      0|	} else {
 4573|       |	    /* all punctuation */
 4574|      0|	    type = XML_REGEXP_PUNCT;
 4575|      0|	}
 4576|     85|    } else if (cur == 'Z') {
  ------------------
  |  Branch (4576:16): [True: 0, False: 85]
  ------------------
 4577|      0|	NEXT;
  ------------------
  |  |   57|      0|#define NEXT ctxt->cur++
  ------------------
 4578|      0|	cur = CUR;
  ------------------
  |  |   58|      0|#define CUR (*(ctxt->cur))
  ------------------
 4579|      0|	if (cur == 's') {
  ------------------
  |  Branch (4579:6): [True: 0, False: 0]
  ------------------
 4580|      0|	    NEXT;
  ------------------
  |  |   57|      0|#define NEXT ctxt->cur++
  ------------------
 4581|       |	    /* space */
 4582|      0|	    type = XML_REGEXP_SEPAR_SPACE;
 4583|      0|	} else if (cur == 'l') {
  ------------------
  |  Branch (4583:13): [True: 0, False: 0]
  ------------------
 4584|      0|	    NEXT;
  ------------------
  |  |   57|      0|#define NEXT ctxt->cur++
  ------------------
 4585|       |	    /* line */
 4586|      0|	    type = XML_REGEXP_SEPAR_LINE;
 4587|      0|	} else if (cur == 'p') {
  ------------------
  |  Branch (4587:13): [True: 0, False: 0]
  ------------------
 4588|      0|	    NEXT;
  ------------------
  |  |   57|      0|#define NEXT ctxt->cur++
  ------------------
 4589|       |	    /* paragraph */
 4590|      0|	    type = XML_REGEXP_SEPAR_PARA;
 4591|      0|	} else {
 4592|       |	    /* all separators */
 4593|      0|	    type = XML_REGEXP_SEPAR;
 4594|      0|	}
 4595|     85|    } else if (cur == 'S') {
  ------------------
  |  Branch (4595:16): [True: 2, False: 83]
  ------------------
 4596|      2|	NEXT;
  ------------------
  |  |   57|      2|#define NEXT ctxt->cur++
  ------------------
 4597|      2|	cur = CUR;
  ------------------
  |  |   58|      2|#define CUR (*(ctxt->cur))
  ------------------
 4598|      2|	if (cur == 'm') {
  ------------------
  |  Branch (4598:6): [True: 0, False: 2]
  ------------------
 4599|      0|	    NEXT;
  ------------------
  |  |   57|      0|#define NEXT ctxt->cur++
  ------------------
 4600|      0|	    type = XML_REGEXP_SYMBOL_MATH;
 4601|       |	    /* math */
 4602|      2|	} else if (cur == 'c') {
  ------------------
  |  Branch (4602:13): [True: 0, False: 2]
  ------------------
 4603|      0|	    NEXT;
  ------------------
  |  |   57|      0|#define NEXT ctxt->cur++
  ------------------
 4604|      0|	    type = XML_REGEXP_SYMBOL_CURRENCY;
 4605|       |	    /* currency */
 4606|      2|	} else if (cur == 'k') {
  ------------------
  |  Branch (4606:13): [True: 0, False: 2]
  ------------------
 4607|      0|	    NEXT;
  ------------------
  |  |   57|      0|#define NEXT ctxt->cur++
  ------------------
 4608|      0|	    type = XML_REGEXP_SYMBOL_MODIFIER;
 4609|       |	    /* modifiers */
 4610|      2|	} else if (cur == 'o') {
  ------------------
  |  Branch (4610:13): [True: 0, False: 2]
  ------------------
 4611|      0|	    NEXT;
  ------------------
  |  |   57|      0|#define NEXT ctxt->cur++
  ------------------
 4612|      0|	    type = XML_REGEXP_SYMBOL_OTHERS;
 4613|       |	    /* other */
 4614|      2|	} else {
 4615|       |	    /* all symbols */
 4616|      2|	    type = XML_REGEXP_SYMBOL;
 4617|      2|	}
 4618|     83|    } else if (cur == 'C') {
  ------------------
  |  Branch (4618:16): [True: 5, False: 78]
  ------------------
 4619|      5|	NEXT;
  ------------------
  |  |   57|      5|#define NEXT ctxt->cur++
  ------------------
 4620|      5|	cur = CUR;
  ------------------
  |  |   58|      5|#define CUR (*(ctxt->cur))
  ------------------
 4621|      5|	if (cur == 'c') {
  ------------------
  |  Branch (4621:6): [True: 0, False: 5]
  ------------------
 4622|      0|	    NEXT;
  ------------------
  |  |   57|      0|#define NEXT ctxt->cur++
  ------------------
 4623|       |	    /* control */
 4624|      0|	    type = XML_REGEXP_OTHER_CONTROL;
 4625|      5|	} else if (cur == 'f') {
  ------------------
  |  Branch (4625:13): [True: 0, False: 5]
  ------------------
 4626|      0|	    NEXT;
  ------------------
  |  |   57|      0|#define NEXT ctxt->cur++
  ------------------
 4627|       |	    /* format */
 4628|      0|	    type = XML_REGEXP_OTHER_FORMAT;
 4629|      5|	} else if (cur == 'o') {
  ------------------
  |  Branch (4629:13): [True: 0, False: 5]
  ------------------
 4630|      0|	    NEXT;
  ------------------
  |  |   57|      0|#define NEXT ctxt->cur++
  ------------------
 4631|       |	    /* private use */
 4632|      0|	    type = XML_REGEXP_OTHER_PRIVATE;
 4633|      5|	} else if (cur == 'n') {
  ------------------
  |  Branch (4633:13): [True: 0, False: 5]
  ------------------
 4634|      0|	    NEXT;
  ------------------
  |  |   57|      0|#define NEXT ctxt->cur++
  ------------------
 4635|       |	    /* not assigned */
 4636|      0|	    type = XML_REGEXP_OTHER_NA;
 4637|      5|	} else {
 4638|       |	    /* all others */
 4639|      5|	    type = XML_REGEXP_OTHER;
 4640|      5|	}
 4641|     78|    } else if (cur == 'I') {
  ------------------
  |  Branch (4641:16): [True: 76, False: 2]
  ------------------
 4642|     76|	const xmlChar *start;
 4643|     76|	NEXT;
  ------------------
  |  |   57|     76|#define NEXT ctxt->cur++
  ------------------
 4644|     76|	cur = CUR;
  ------------------
  |  |   58|     76|#define CUR (*(ctxt->cur))
  ------------------
 4645|     76|	if (cur != 's') {
  ------------------
  |  Branch (4645:6): [True: 5, False: 71]
  ------------------
 4646|      5|	    ERROR("IsXXXX expected");
  ------------------
  |  |   55|      5|    ctxt->error = XML_REGEXP_COMPILE_ERROR;				\
  |  |   56|      5|    xmlRegexpErrCompile(ctxt, str);
  ------------------
 4647|      5|	    return;
 4648|      5|	}
 4649|     71|	NEXT;
  ------------------
  |  |   57|     71|#define NEXT ctxt->cur++
  ------------------
 4650|     71|	start = ctxt->cur;
 4651|     71|	cur = CUR;
  ------------------
  |  |   58|     71|#define CUR (*(ctxt->cur))
  ------------------
 4652|     71|	if (((cur >= 'a') && (cur <= 'z')) ||
  ------------------
  |  Branch (4652:7): [True: 2, False: 69]
  |  Branch (4652:23): [True: 1, False: 1]
  ------------------
 4653|     71|	    ((cur >= 'A') && (cur <= 'Z')) ||
  ------------------
  |  Branch (4653:7): [True: 69, False: 1]
  |  Branch (4653:23): [True: 68, False: 1]
  ------------------
 4654|     71|	    ((cur >= '0') && (cur <= '9')) ||
  ------------------
  |  Branch (4654:7): [True: 1, False: 1]
  |  Branch (4654:23): [True: 0, False: 1]
  ------------------
 4655|     71|	    (cur == 0x2D)) {
  ------------------
  |  Branch (4655:6): [True: 0, False: 2]
  ------------------
 4656|     69|	    NEXT;
  ------------------
  |  |   57|     69|#define NEXT ctxt->cur++
  ------------------
 4657|     69|	    cur = CUR;
  ------------------
  |  |   58|     69|#define CUR (*(ctxt->cur))
  ------------------
 4658|    945|	    while (((cur >= 'a') && (cur <= 'z')) ||
  ------------------
  |  Branch (4658:14): [True: 844, False: 101]
  |  Branch (4658:30): [True: 782, False: 62]
  ------------------
 4659|    945|		((cur >= 'A') && (cur <= 'Z')) ||
  ------------------
  |  Branch (4659:4): [True: 146, False: 17]
  |  Branch (4659:20): [True: 83, False: 63]
  ------------------
 4660|    945|		((cur >= '0') && (cur <= '9')) ||
  ------------------
  |  Branch (4660:4): [True: 74, False: 6]
  |  Branch (4660:20): [True: 11, False: 63]
  ------------------
 4661|    945|		(cur == 0x2D)) {
  ------------------
  |  Branch (4661:3): [True: 0, False: 69]
  ------------------
 4662|    876|		NEXT;
  ------------------
  |  |   57|    876|#define NEXT ctxt->cur++
  ------------------
 4663|    876|		cur = CUR;
  ------------------
  |  |   58|    876|#define CUR (*(ctxt->cur))
  ------------------
 4664|    876|	    }
 4665|     69|	}
 4666|     71|	type = XML_REGEXP_BLOCK_NAME;
 4667|     71|	blockName = xmlStrndup(start, ctxt->cur - start);
 4668|     71|    } else {
 4669|      2|	ERROR("Unknown char property");
  ------------------
  |  |   55|      2|    ctxt->error = XML_REGEXP_COMPILE_ERROR;				\
  |  |   56|      2|    xmlRegexpErrCompile(ctxt, str);
  ------------------
 4670|      2|	return;
 4671|      2|    }
 4672|     88|    if (ctxt->atom == NULL) {
  ------------------
  |  Branch (4672:9): [True: 69, False: 19]
  ------------------
 4673|     69|	ctxt->atom = xmlRegNewAtom(ctxt, type);
 4674|     69|        if (ctxt->atom == NULL) {
  ------------------
  |  Branch (4674:13): [True: 2, False: 67]
  ------------------
 4675|      2|            xmlFree(blockName);
 4676|      2|            return;
 4677|      2|        }
 4678|     67|	ctxt->atom->valuep = blockName;
 4679|     67|    } else if (ctxt->atom->type == XML_REGEXP_RANGES) {
  ------------------
  |  Branch (4679:16): [True: 19, False: 0]
  ------------------
 4680|     19|        if (xmlRegAtomAddRange(ctxt, ctxt->atom, ctxt->neg,
  ------------------
  |  Branch (4680:13): [True: 0, False: 19]
  ------------------
 4681|     19|                               type, 0, 0, blockName) == NULL) {
 4682|      0|            xmlFree(blockName);
 4683|      0|        }
 4684|     19|    }
 4685|     88|}
xmlregexp.c:xmlFAParseQuantifier:
 5131|  6.58k|xmlFAParseQuantifier(xmlRegParserCtxtPtr ctxt) {
 5132|  6.58k|    int cur;
 5133|       |
 5134|  6.58k|    cur = CUR;
  ------------------
  |  |   58|  6.58k|#define CUR (*(ctxt->cur))
  ------------------
 5135|  6.58k|    if ((cur == '?') || (cur == '*') || (cur == '+')) {
  ------------------
  |  Branch (5135:9): [True: 589, False: 5.99k]
  |  Branch (5135:25): [True: 496, False: 5.49k]
  |  Branch (5135:41): [True: 240, False: 5.25k]
  ------------------
 5136|  1.32k|	if (ctxt->atom != NULL) {
  ------------------
  |  Branch (5136:6): [True: 1.32k, False: 1]
  ------------------
 5137|  1.32k|	    if (cur == '?')
  ------------------
  |  Branch (5137:10): [True: 588, False: 736]
  ------------------
 5138|    588|		ctxt->atom->quant = XML_REGEXP_QUANT_OPT;
 5139|    736|	    else if (cur == '*')
  ------------------
  |  Branch (5139:15): [True: 496, False: 240]
  ------------------
 5140|    496|		ctxt->atom->quant = XML_REGEXP_QUANT_MULT;
 5141|    240|	    else if (cur == '+')
  ------------------
  |  Branch (5141:15): [True: 240, False: 0]
  ------------------
 5142|    240|		ctxt->atom->quant = XML_REGEXP_QUANT_PLUS;
 5143|  1.32k|	}
 5144|  1.32k|	NEXT;
  ------------------
  |  |   57|  1.32k|#define NEXT ctxt->cur++
  ------------------
 5145|  1.32k|	return(1);
 5146|  1.32k|    }
 5147|  5.25k|    if (cur == '{') {
  ------------------
  |  Branch (5147:9): [True: 146, False: 5.11k]
  ------------------
 5148|    146|	int min = 0, max = 0;
 5149|       |
 5150|    146|	NEXT;
  ------------------
  |  |   57|    146|#define NEXT ctxt->cur++
  ------------------
 5151|    146|	cur = xmlFAParseQuantExact(ctxt);
 5152|    146|	if (cur >= 0)
  ------------------
  |  Branch (5152:6): [True: 134, False: 12]
  ------------------
 5153|    134|	    min = cur;
 5154|     12|        else {
 5155|     12|            ERROR("Improper quantifier");
  ------------------
  |  |   55|     12|    ctxt->error = XML_REGEXP_COMPILE_ERROR;				\
  |  |   56|     12|    xmlRegexpErrCompile(ctxt, str);
  ------------------
 5156|     12|        }
 5157|    146|	if (CUR == ',') {
  ------------------
  |  |   58|    146|#define CUR (*(ctxt->cur))
  ------------------
  |  Branch (5157:6): [True: 88, False: 58]
  ------------------
 5158|     88|	    NEXT;
  ------------------
  |  |   57|     88|#define NEXT ctxt->cur++
  ------------------
 5159|     88|	    if (CUR == '}')
  ------------------
  |  |   58|     88|#define CUR (*(ctxt->cur))
  ------------------
  |  Branch (5159:10): [True: 3, False: 85]
  ------------------
 5160|      3|	        max = INT_MAX;
 5161|     85|	    else {
 5162|     85|	        cur = xmlFAParseQuantExact(ctxt);
 5163|     85|	        if (cur >= 0)
  ------------------
  |  Branch (5163:14): [True: 82, False: 3]
  ------------------
 5164|     82|		    max = cur;
 5165|      3|		else {
 5166|      3|		    ERROR("Improper quantifier");
  ------------------
  |  |   55|      3|    ctxt->error = XML_REGEXP_COMPILE_ERROR;				\
  |  |   56|      3|    xmlRegexpErrCompile(ctxt, str);
  ------------------
 5167|      3|		}
 5168|     85|	    }
 5169|     88|	}
 5170|    146|	if (CUR == '}') {
  ------------------
  |  |   58|    146|#define CUR (*(ctxt->cur))
  ------------------
  |  Branch (5170:6): [True: 126, False: 20]
  ------------------
 5171|    126|	    NEXT;
  ------------------
  |  |   57|    126|#define NEXT ctxt->cur++
  ------------------
 5172|    126|	} else {
 5173|     20|	    ERROR("Unterminated quantifier");
  ------------------
  |  |   55|     20|    ctxt->error = XML_REGEXP_COMPILE_ERROR;				\
  |  |   56|     20|    xmlRegexpErrCompile(ctxt, str);
  ------------------
 5174|     20|	}
 5175|    146|	if (max == 0)
  ------------------
  |  Branch (5175:6): [True: 61, False: 85]
  ------------------
 5176|     61|	    max = min;
 5177|    146|	if (ctxt->atom != NULL) {
  ------------------
  |  Branch (5177:6): [True: 145, False: 1]
  ------------------
 5178|    145|	    ctxt->atom->quant = XML_REGEXP_QUANT_RANGE;
 5179|    145|	    ctxt->atom->min = min;
 5180|    145|	    ctxt->atom->max = max;
 5181|    145|	}
 5182|    146|	return(1);
 5183|    146|    }
 5184|  5.11k|    return(0);
 5185|  5.25k|}
xmlregexp.c:xmlFAParseQuantExact:
 5094|    231|xmlFAParseQuantExact(xmlRegParserCtxtPtr ctxt) {
 5095|    231|    int ret = 0;
 5096|    231|    int ok = 0;
 5097|    231|    int overflow = 0;
 5098|       |
 5099|    451|    while ((CUR >= '0') && (CUR <= '9')) {
  ------------------
  |  |   58|    451|#define CUR (*(ctxt->cur))
  ------------------
                  while ((CUR >= '0') && (CUR <= '9')) {
  ------------------
  |  |   58|    355|#define CUR (*(ctxt->cur))
  ------------------
  |  Branch (5099:12): [True: 355, False: 96]
  |  Branch (5099:28): [True: 220, False: 135]
  ------------------
 5100|    220|        if (ret > INT_MAX / 10) {
  ------------------
  |  Branch (5100:13): [True: 0, False: 220]
  ------------------
 5101|      0|            overflow = 1;
 5102|    220|        } else {
 5103|    220|            int digit = CUR - '0';
  ------------------
  |  |   58|    220|#define CUR (*(ctxt->cur))
  ------------------
 5104|       |
 5105|    220|            ret *= 10;
 5106|    220|            if (ret > INT_MAX - digit)
  ------------------
  |  Branch (5106:17): [True: 0, False: 220]
  ------------------
 5107|      0|                overflow = 1;
 5108|    220|            else
 5109|    220|                ret += digit;
 5110|    220|        }
 5111|    220|	ok = 1;
 5112|    220|	NEXT;
  ------------------
  |  |   57|    220|#define NEXT ctxt->cur++
  ------------------
 5113|    220|    }
 5114|    231|    if ((ok != 1) || (overflow == 1)) {
  ------------------
  |  Branch (5114:9): [True: 15, False: 216]
  |  Branch (5114:22): [True: 0, False: 216]
  ------------------
 5115|     15|	return(-1);
 5116|     15|    }
 5117|    216|    return(ret);
 5118|    231|}
xmlregexp.c:xmlRegexpErrCompile:
  402|    737|{
  403|    737|    const char *regexp = NULL;
  404|    737|    int idx = 0;
  405|       |
  406|    737|    if (ctxt != NULL) {
  ------------------
  |  Branch (406:9): [True: 737, False: 0]
  ------------------
  407|    737|        regexp = (const char *) ctxt->string;
  408|    737|	idx = ctxt->cur - ctxt->string;
  409|    737|	ctxt->error = XML_REGEXP_COMPILE_ERROR;
  410|    737|    }
  411|    737|    __xmlRaiseError(NULL, NULL, NULL, NULL, NULL, XML_FROM_REGEXP,
  412|    737|		    XML_REGEXP_COMPILE_ERROR, XML_ERR_FATAL, NULL, 0, extra,
  413|    737|		    regexp, NULL, idx, 0,
  414|    737|		    "failed to compile: %s\n", extra);
  415|    737|}
xmlregexp.c:xmlFAEliminateEpsilonTransitions:
 1877|    157|xmlFAEliminateEpsilonTransitions(xmlRegParserCtxtPtr ctxt) {
 1878|    157|    int statenr, transnr;
 1879|    157|    xmlRegStatePtr state;
 1880|    157|    int has_epsilon;
 1881|       |
 1882|    157|    if (ctxt->states == NULL) return;
  ------------------
  |  Branch (1882:9): [True: 0, False: 157]
  ------------------
 1883|       |
 1884|       |    /*
 1885|       |     * Eliminate simple epsilon transition and the associated unreachable
 1886|       |     * states.
 1887|       |     */
 1888|    157|    xmlFAEliminateSimpleEpsilonTransitions(ctxt);
 1889|  4.48k|    for (statenr = 0;statenr < ctxt->nbStates;statenr++) {
  ------------------
  |  Branch (1889:22): [True: 4.33k, False: 157]
  ------------------
 1890|  4.33k|	state = ctxt->states[statenr];
 1891|  4.33k|	if ((state != NULL) && (state->type == XML_REGEXP_UNREACH_STATE)) {
  ------------------
  |  Branch (1891:6): [True: 4.33k, False: 0]
  |  Branch (1891:25): [True: 1.74k, False: 2.58k]
  ------------------
 1892|  1.74k|	    xmlRegFreeState(state);
 1893|  1.74k|	    ctxt->states[statenr] = NULL;
 1894|  1.74k|	}
 1895|  4.33k|    }
 1896|       |
 1897|    157|    has_epsilon = 0;
 1898|       |
 1899|       |    /*
 1900|       |     * Build the completed transitions bypassing the epsilons
 1901|       |     * Use a marking algorithm to avoid loops
 1902|       |     * Mark sink states too.
 1903|       |     * Process from the latest states backward to the start when
 1904|       |     * there is long cascading epsilon chains this minimize the
 1905|       |     * recursions and transition compares when adding the new ones
 1906|       |     */
 1907|  4.48k|    for (statenr = ctxt->nbStates - 1;statenr >= 0;statenr--) {
  ------------------
  |  Branch (1907:39): [True: 4.33k, False: 157]
  ------------------
 1908|  4.33k|	state = ctxt->states[statenr];
 1909|  4.33k|	if (state == NULL)
  ------------------
  |  Branch (1909:6): [True: 1.74k, False: 2.58k]
  ------------------
 1910|  1.74k|	    continue;
 1911|  2.58k|	if ((state->nbTrans == 0) &&
  ------------------
  |  Branch (1911:6): [True: 104, False: 2.48k]
  ------------------
 1912|  2.58k|	    (state->type != XML_REGEXP_FINAL_STATE)) {
  ------------------
  |  Branch (1912:6): [True: 0, False: 104]
  ------------------
 1913|      0|	    state->type = XML_REGEXP_SINK_STATE;
 1914|      0|	}
 1915|  12.5k|	for (transnr = 0;transnr < state->nbTrans;transnr++) {
  ------------------
  |  Branch (1915:19): [True: 9.94k, False: 2.58k]
  ------------------
 1916|  9.94k|	    if ((state->trans[transnr].atom == NULL) &&
  ------------------
  |  Branch (1916:10): [True: 2.89k, False: 7.04k]
  ------------------
 1917|  9.94k|		(state->trans[transnr].to >= 0)) {
  ------------------
  |  Branch (1917:3): [True: 1.49k, False: 1.40k]
  ------------------
 1918|  1.49k|		if (state->trans[transnr].to == statenr) {
  ------------------
  |  Branch (1918:7): [True: 1, False: 1.49k]
  ------------------
 1919|      1|		    state->trans[transnr].to = -1;
 1920|  1.49k|		} else if (state->trans[transnr].count < 0) {
  ------------------
  |  Branch (1920:14): [True: 1.31k, False: 180]
  ------------------
 1921|  1.31k|		    int newto = state->trans[transnr].to;
 1922|       |
 1923|  1.31k|		    has_epsilon = 1;
 1924|  1.31k|		    state->trans[transnr].to = -2;
 1925|  1.31k|		    state->mark = XML_REGEXP_MARK_START;
 1926|  1.31k|		    xmlFAReduceEpsilonTransitions(ctxt, statenr,
 1927|  1.31k|				      newto, state->trans[transnr].counter);
 1928|  1.31k|		    xmlFAFinishReduceEpsilonTransitions(ctxt, newto);
 1929|  1.31k|		    state->mark = XML_REGEXP_MARK_NORMAL;
 1930|  1.31k|	        }
 1931|  1.49k|	    }
 1932|  9.94k|	}
 1933|  2.58k|    }
 1934|       |    /*
 1935|       |     * Eliminate the epsilon transitions
 1936|       |     */
 1937|    157|    if (has_epsilon) {
  ------------------
  |  Branch (1937:9): [True: 130, False: 27]
  ------------------
 1938|  4.23k|	for (statenr = 0;statenr < ctxt->nbStates;statenr++) {
  ------------------
  |  Branch (1938:19): [True: 4.10k, False: 130]
  ------------------
 1939|  4.10k|	    state = ctxt->states[statenr];
 1940|  4.10k|	    if (state == NULL)
  ------------------
  |  Branch (1940:10): [True: 1.73k, False: 2.36k]
  ------------------
 1941|  1.73k|		continue;
 1942|  12.1k|	    for (transnr = 0;transnr < state->nbTrans;transnr++) {
  ------------------
  |  Branch (1942:23): [True: 9.73k, False: 2.36k]
  ------------------
 1943|  9.73k|		xmlRegTransPtr trans = &(state->trans[transnr]);
 1944|  9.73k|		if ((trans->atom == NULL) &&
  ------------------
  |  Branch (1944:7): [True: 2.89k, False: 6.83k]
  ------------------
 1945|  9.73k|		    (trans->count < 0) &&
  ------------------
  |  Branch (1945:7): [True: 2.71k, False: 180]
  ------------------
 1946|  9.73k|		    (trans->to >= 0)) {
  ------------------
  |  Branch (1946:7): [True: 0, False: 2.71k]
  ------------------
 1947|      0|		    trans->to = -1;
 1948|      0|		}
 1949|  9.73k|	    }
 1950|  2.36k|	}
 1951|    130|    }
 1952|       |
 1953|       |    /*
 1954|       |     * Use this pass to detect unreachable states too
 1955|       |     */
 1956|  4.48k|    for (statenr = 0;statenr < ctxt->nbStates;statenr++) {
  ------------------
  |  Branch (1956:22): [True: 4.33k, False: 157]
  ------------------
 1957|  4.33k|	state = ctxt->states[statenr];
 1958|  4.33k|	if (state != NULL)
  ------------------
  |  Branch (1958:6): [True: 2.58k, False: 1.74k]
  ------------------
 1959|  2.58k|	    state->reached = XML_REGEXP_MARK_NORMAL;
 1960|  4.33k|    }
 1961|    157|    state = ctxt->states[0];
 1962|    157|    if (state != NULL)
  ------------------
  |  Branch (1962:9): [True: 157, False: 0]
  ------------------
 1963|    157|	state->reached = XML_REGEXP_MARK_START;
 1964|  2.29k|    while (state != NULL) {
  ------------------
  |  Branch (1964:12): [True: 2.13k, False: 157]
  ------------------
 1965|  2.13k|	xmlRegStatePtr target = NULL;
 1966|  2.13k|	state->reached = XML_REGEXP_MARK_VISITED;
 1967|       |	/*
 1968|       |	 * Mark all states reachable from the current reachable state
 1969|       |	 */
 1970|  9.27k|	for (transnr = 0;transnr < state->nbTrans;transnr++) {
  ------------------
  |  Branch (1970:19): [True: 7.13k, False: 2.13k]
  ------------------
 1971|  7.13k|	    if ((state->trans[transnr].to >= 0) &&
  ------------------
  |  Branch (1971:10): [True: 4.37k, False: 2.75k]
  ------------------
 1972|  7.13k|		((state->trans[transnr].atom != NULL) ||
  ------------------
  |  Branch (1972:4): [True: 4.27k, False: 102]
  ------------------
 1973|  4.37k|		 (state->trans[transnr].count >= 0))) {
  ------------------
  |  Branch (1973:4): [True: 102, False: 0]
  ------------------
 1974|  4.37k|		int newto = state->trans[transnr].to;
 1975|       |
 1976|  4.37k|		if (ctxt->states[newto] == NULL)
  ------------------
  |  Branch (1976:7): [True: 0, False: 4.37k]
  ------------------
 1977|      0|		    continue;
 1978|  4.37k|		if (ctxt->states[newto]->reached == XML_REGEXP_MARK_NORMAL) {
  ------------------
  |  Branch (1978:7): [True: 1.97k, False: 2.40k]
  ------------------
 1979|  1.97k|		    ctxt->states[newto]->reached = XML_REGEXP_MARK_START;
 1980|  1.97k|		    target = ctxt->states[newto];
 1981|  1.97k|		}
 1982|  4.37k|	    }
 1983|  7.13k|	}
 1984|       |
 1985|       |	/*
 1986|       |	 * find the next accessible state not explored
 1987|       |	 */
 1988|  2.13k|	if (target == NULL) {
  ------------------
  |  Branch (1988:6): [True: 741, False: 1.39k]
  ------------------
 1989|  33.0k|	    for (statenr = 1;statenr < ctxt->nbStates;statenr++) {
  ------------------
  |  Branch (1989:23): [True: 32.8k, False: 157]
  ------------------
 1990|  32.8k|		state = ctxt->states[statenr];
 1991|  32.8k|		if ((state != NULL) && (state->reached ==
  ------------------
  |  Branch (1991:7): [True: 17.5k, False: 15.3k]
  |  Branch (1991:26): [True: 584, False: 16.9k]
  ------------------
 1992|  17.5k|			XML_REGEXP_MARK_START)) {
 1993|    584|		    target = state;
 1994|    584|		    break;
 1995|    584|		}
 1996|  32.8k|	    }
 1997|    741|	}
 1998|  2.13k|	state = target;
 1999|  2.13k|    }
 2000|  4.48k|    for (statenr = 0;statenr < ctxt->nbStates;statenr++) {
  ------------------
  |  Branch (2000:22): [True: 4.33k, False: 157]
  ------------------
 2001|  4.33k|	state = ctxt->states[statenr];
 2002|  4.33k|	if ((state != NULL) && (state->reached == XML_REGEXP_MARK_NORMAL)) {
  ------------------
  |  Branch (2002:6): [True: 2.58k, False: 1.74k]
  |  Branch (2002:25): [True: 452, False: 2.13k]
  ------------------
 2003|    452|	    xmlRegFreeState(state);
 2004|    452|	    ctxt->states[statenr] = NULL;
 2005|    452|	}
 2006|  4.33k|    }
 2007|       |
 2008|    157|}
xmlregexp.c:xmlFAEliminateSimpleEpsilonTransitions:
 1824|    157|xmlFAEliminateSimpleEpsilonTransitions(xmlRegParserCtxtPtr ctxt) {
 1825|    157|    int statenr, i, j, newto;
 1826|    157|    xmlRegStatePtr state, tmp;
 1827|       |
 1828|  4.48k|    for (statenr = 0;statenr < ctxt->nbStates;statenr++) {
  ------------------
  |  Branch (1828:22): [True: 4.33k, False: 157]
  ------------------
 1829|  4.33k|	state = ctxt->states[statenr];
 1830|  4.33k|	if (state == NULL)
  ------------------
  |  Branch (1830:6): [True: 0, False: 4.33k]
  ------------------
 1831|      0|	    continue;
 1832|  4.33k|	if (state->nbTrans != 1)
  ------------------
  |  Branch (1832:6): [True: 1.41k, False: 2.92k]
  ------------------
 1833|  1.41k|	    continue;
 1834|  2.92k|       if (state->type == XML_REGEXP_UNREACH_STATE ||
  ------------------
  |  Branch (1834:12): [True: 0, False: 2.92k]
  ------------------
 1835|  2.92k|           state->type == XML_REGEXP_FINAL_STATE)
  ------------------
  |  Branch (1835:12): [True: 15, False: 2.90k]
  ------------------
 1836|     15|	    continue;
 1837|       |	/* is the only transition out a basic transition */
 1838|  2.90k|	if ((state->trans[0].atom == NULL) &&
  ------------------
  |  Branch (1838:6): [True: 1.84k, False: 1.06k]
  ------------------
 1839|  2.90k|	    (state->trans[0].to >= 0) &&
  ------------------
  |  Branch (1839:6): [True: 1.84k, False: 0]
  ------------------
 1840|  2.90k|	    (state->trans[0].to != statenr) &&
  ------------------
  |  Branch (1840:6): [True: 1.84k, False: 0]
  ------------------
 1841|  2.90k|	    (state->trans[0].counter < 0) &&
  ------------------
  |  Branch (1841:6): [True: 1.84k, False: 0]
  ------------------
 1842|  2.90k|	    (state->trans[0].count < 0)) {
  ------------------
  |  Branch (1842:6): [True: 1.84k, False: 0]
  ------------------
 1843|  1.84k|	    newto = state->trans[0].to;
 1844|       |
 1845|  1.84k|            if (state->type == XML_REGEXP_START_STATE) {
  ------------------
  |  Branch (1845:17): [True: 96, False: 1.74k]
  ------------------
 1846|  1.74k|            } else {
 1847|  5.73k|	        for (i = 0;i < state->nbTransTo;i++) {
  ------------------
  |  Branch (1847:21): [True: 3.99k, False: 1.74k]
  ------------------
 1848|  3.99k|		    tmp = ctxt->states[state->transTo[i]];
 1849|  19.0k|		    for (j = 0;j < tmp->nbTrans;j++) {
  ------------------
  |  Branch (1849:18): [True: 15.0k, False: 3.99k]
  ------------------
 1850|  15.0k|			if (tmp->trans[j].to == statenr) {
  ------------------
  |  Branch (1850:8): [True: 2.91k, False: 12.1k]
  ------------------
 1851|  2.91k|			    tmp->trans[j].to = -1;
 1852|  2.91k|			    xmlRegStateAddTrans(ctxt, tmp, tmp->trans[j].atom,
 1853|  2.91k|						ctxt->states[newto],
 1854|  2.91k|					        tmp->trans[j].counter,
 1855|  2.91k|						tmp->trans[j].count);
 1856|  2.91k|			}
 1857|  15.0k|		    }
 1858|  3.99k|		}
 1859|  1.74k|		if (state->type == XML_REGEXP_FINAL_STATE)
  ------------------
  |  Branch (1859:7): [True: 0, False: 1.74k]
  ------------------
 1860|      0|		    ctxt->states[newto]->type = XML_REGEXP_FINAL_STATE;
 1861|       |		/* eliminate the transition completely */
 1862|  1.74k|		state->nbTrans = 0;
 1863|       |
 1864|  1.74k|                state->type = XML_REGEXP_UNREACH_STATE;
 1865|       |
 1866|  1.74k|	    }
 1867|       |
 1868|  1.84k|	}
 1869|  2.90k|    }
 1870|    157|}
xmlregexp.c:xmlFAReduceEpsilonTransitions:
 1722|  1.58k|	                      int tonr, int counter) {
 1723|  1.58k|    int transnr;
 1724|  1.58k|    xmlRegStatePtr from;
 1725|  1.58k|    xmlRegStatePtr to;
 1726|       |
 1727|  1.58k|    from = ctxt->states[fromnr];
 1728|  1.58k|    if (from == NULL)
  ------------------
  |  Branch (1728:9): [True: 0, False: 1.58k]
  ------------------
 1729|      0|	return;
 1730|  1.58k|    to = ctxt->states[tonr];
 1731|  1.58k|    if (to == NULL)
  ------------------
  |  Branch (1731:9): [True: 0, False: 1.58k]
  ------------------
 1732|      0|	return;
 1733|  1.58k|    if ((to->mark == XML_REGEXP_MARK_START) ||
  ------------------
  |  Branch (1733:9): [True: 0, False: 1.58k]
  ------------------
 1734|  1.58k|	(to->mark == XML_REGEXP_MARK_VISITED))
  ------------------
  |  Branch (1734:2): [True: 57, False: 1.52k]
  ------------------
 1735|     57|	return;
 1736|       |
 1737|  1.52k|    to->mark = XML_REGEXP_MARK_VISITED;
 1738|  1.52k|    if (to->type == XML_REGEXP_FINAL_STATE) {
  ------------------
  |  Branch (1738:9): [True: 328, False: 1.19k]
  ------------------
 1739|    328|	from->type = XML_REGEXP_FINAL_STATE;
 1740|    328|    }
 1741|  8.52k|    for (transnr = 0;transnr < to->nbTrans;transnr++) {
  ------------------
  |  Branch (1741:22): [True: 6.99k, False: 1.52k]
  ------------------
 1742|  6.99k|        xmlRegTransPtr t1 = &to->trans[transnr];
 1743|  6.99k|        int tcounter;
 1744|       |
 1745|  6.99k|        if (t1->to < 0)
  ------------------
  |  Branch (1745:13): [True: 3.18k, False: 3.81k]
  ------------------
 1746|  3.18k|	    continue;
 1747|  3.81k|        if (t1->counter >= 0) {
  ------------------
  |  Branch (1747:13): [True: 239, False: 3.57k]
  ------------------
 1748|       |            /* assert(counter < 0); */
 1749|    239|            tcounter = t1->counter;
 1750|  3.57k|        } else {
 1751|  3.57k|            tcounter = counter;
 1752|  3.57k|        }
 1753|  3.81k|	if (t1->atom == NULL) {
  ------------------
  |  Branch (1753:6): [True: 485, False: 3.32k]
  ------------------
 1754|       |	    /*
 1755|       |	     * Don't remove counted transitions
 1756|       |	     * Don't loop either
 1757|       |	     */
 1758|    485|	    if (t1->to != fromnr) {
  ------------------
  |  Branch (1758:10): [True: 395, False: 90]
  ------------------
 1759|    395|		if (t1->count >= 0) {
  ------------------
  |  Branch (1759:7): [True: 129, False: 266]
  ------------------
 1760|    129|		    xmlRegStateAddTrans(ctxt, from, NULL, ctxt->states[t1->to],
 1761|    129|					-1, t1->count);
 1762|    266|		} else {
 1763|    266|                    xmlFAReduceEpsilonTransitions(ctxt, fromnr, t1->to,
 1764|    266|                                                  tcounter);
 1765|    266|		}
 1766|    395|	    }
 1767|  3.32k|	} else {
 1768|  3.32k|            xmlRegStateAddTrans(ctxt, from, t1->atom,
 1769|  3.32k|                                ctxt->states[t1->to], tcounter, -1);
 1770|  3.32k|	}
 1771|  3.81k|    }
 1772|  1.52k|}
xmlregexp.c:xmlFAFinishReduceEpsilonTransitions:
 1783|  1.79k|xmlFAFinishReduceEpsilonTransitions(xmlRegParserCtxtPtr ctxt, int tonr) {
 1784|  1.79k|    int transnr;
 1785|  1.79k|    xmlRegStatePtr to;
 1786|       |
 1787|  1.79k|    to = ctxt->states[tonr];
 1788|  1.79k|    if (to == NULL)
  ------------------
  |  Branch (1788:9): [True: 0, False: 1.79k]
  ------------------
 1789|      0|	return;
 1790|  1.79k|    if ((to->mark == XML_REGEXP_MARK_START) ||
  ------------------
  |  Branch (1790:9): [True: 90, False: 1.70k]
  ------------------
 1791|  1.79k|	(to->mark == XML_REGEXP_MARK_NORMAL))
  ------------------
  |  Branch (1791:2): [True: 186, False: 1.52k]
  ------------------
 1792|    276|	return;
 1793|       |
 1794|  1.52k|    to->mark = XML_REGEXP_MARK_NORMAL;
 1795|  8.52k|    for (transnr = 0;transnr < to->nbTrans;transnr++) {
  ------------------
  |  Branch (1795:22): [True: 6.99k, False: 1.52k]
  ------------------
 1796|  6.99k|	xmlRegTransPtr t1 = &to->trans[transnr];
 1797|  6.99k|	if ((t1->to >= 0) && (t1->atom == NULL))
  ------------------
  |  Branch (1797:6): [True: 3.81k, False: 3.18k]
  |  Branch (1797:23): [True: 485, False: 3.32k]
  ------------------
 1798|    485|            xmlFAFinishReduceEpsilonTransitions(ctxt, t1->to);
 1799|  6.99k|    }
 1800|  1.52k|}
xmlregexp.c:xmlRegEpxFromParse:
  460|    157|xmlRegEpxFromParse(xmlRegParserCtxtPtr ctxt) {
  461|    157|    xmlRegexpPtr ret;
  462|       |
  463|    157|    ret = (xmlRegexpPtr) xmlMalloc(sizeof(xmlRegexp));
  464|    157|    if (ret == NULL) {
  ------------------
  |  Branch (464:9): [True: 1, False: 156]
  ------------------
  465|      1|	xmlRegexpErrMemory(ctxt, "compiling regexp");
  466|      1|	return(NULL);
  467|      1|    }
  468|    156|    memset(ret, 0, sizeof(xmlRegexp));
  469|    156|    ret->string = ctxt->string;
  470|    156|    ret->nbStates = ctxt->nbStates;
  471|    156|    ret->states = ctxt->states;
  472|    156|    ret->nbAtoms = ctxt->nbAtoms;
  473|    156|    ret->atoms = ctxt->atoms;
  474|    156|    ret->nbCounters = ctxt->nbCounters;
  475|    156|    ret->counters = ctxt->counters;
  476|    156|    ret->determinist = ctxt->determinist;
  477|    156|    ret->flags = ctxt->flags;
  478|    156|    if (ret->determinist == -1) {
  ------------------
  |  Branch (478:9): [True: 156, False: 0]
  ------------------
  479|    156|        if (xmlRegexpIsDeterminist(ret) < 0) {
  ------------------
  |  Branch (479:13): [True: 3, False: 153]
  ------------------
  480|      3|            xmlRegexpErrMemory(ctxt, "checking determinism");
  481|      3|            xmlFree(ret);
  482|      3|            return(NULL);
  483|      3|        }
  484|    156|    }
  485|       |
  486|    153|    if ((ret->determinist != 0) &&
  ------------------
  |  Branch (486:9): [True: 92, False: 61]
  ------------------
  487|    153|	(ret->nbCounters == 0) &&
  ------------------
  |  Branch (487:2): [True: 76, False: 16]
  ------------------
  488|    153|	(ctxt->negs == 0) &&
  ------------------
  |  Branch (488:2): [True: 76, False: 0]
  ------------------
  489|    153|	(ret->atoms != NULL) &&
  ------------------
  |  Branch (489:2): [True: 72, False: 4]
  ------------------
  490|    153|	(ret->atoms[0] != NULL) &&
  ------------------
  |  Branch (490:2): [True: 72, False: 0]
  ------------------
  491|    153|	(ret->atoms[0]->type == XML_REGEXP_STRING)) {
  ------------------
  |  Branch (491:2): [True: 0, False: 72]
  ------------------
  492|      0|	int i, j, nbstates = 0, nbatoms = 0;
  493|      0|	int *stateRemap;
  494|      0|	int *stringRemap;
  495|      0|	int *transitions;
  496|      0|	void **transdata;
  497|      0|	xmlChar **stringMap;
  498|      0|        xmlChar *value;
  499|       |
  500|       |	/*
  501|       |	 * Switch to a compact representation
  502|       |	 * 1/ counting the effective number of states left
  503|       |	 * 2/ counting the unique number of atoms, and check that
  504|       |	 *    they are all of the string type
  505|       |	 * 3/ build a table state x atom for the transitions
  506|       |	 */
  507|       |
  508|      0|	stateRemap = xmlMalloc(ret->nbStates * sizeof(int));
  509|      0|	if (stateRemap == NULL) {
  ------------------
  |  Branch (509:6): [True: 0, False: 0]
  ------------------
  510|      0|	    xmlRegexpErrMemory(ctxt, "compiling regexp");
  511|      0|	    xmlFree(ret);
  512|      0|	    return(NULL);
  513|      0|	}
  514|      0|	for (i = 0;i < ret->nbStates;i++) {
  ------------------
  |  Branch (514:13): [True: 0, False: 0]
  ------------------
  515|      0|	    if (ret->states[i] != NULL) {
  ------------------
  |  Branch (515:10): [True: 0, False: 0]
  ------------------
  516|      0|		stateRemap[i] = nbstates;
  517|      0|		nbstates++;
  518|      0|	    } else {
  519|      0|		stateRemap[i] = -1;
  520|      0|	    }
  521|      0|	}
  522|      0|	stringMap = xmlMalloc(ret->nbAtoms * sizeof(char *));
  523|      0|	if (stringMap == NULL) {
  ------------------
  |  Branch (523:6): [True: 0, False: 0]
  ------------------
  524|      0|	    xmlRegexpErrMemory(ctxt, "compiling regexp");
  525|      0|	    xmlFree(stateRemap);
  526|      0|	    xmlFree(ret);
  527|      0|	    return(NULL);
  528|      0|	}
  529|      0|	stringRemap = xmlMalloc(ret->nbAtoms * sizeof(int));
  530|      0|	if (stringRemap == NULL) {
  ------------------
  |  Branch (530:6): [True: 0, False: 0]
  ------------------
  531|      0|	    xmlRegexpErrMemory(ctxt, "compiling regexp");
  532|      0|	    xmlFree(stringMap);
  533|      0|	    xmlFree(stateRemap);
  534|      0|	    xmlFree(ret);
  535|      0|	    return(NULL);
  536|      0|	}
  537|      0|	for (i = 0;i < ret->nbAtoms;i++) {
  ------------------
  |  Branch (537:13): [True: 0, False: 0]
  ------------------
  538|      0|	    if ((ret->atoms[i]->type == XML_REGEXP_STRING) &&
  ------------------
  |  Branch (538:10): [True: 0, False: 0]
  ------------------
  539|      0|		(ret->atoms[i]->quant == XML_REGEXP_QUANT_ONCE)) {
  ------------------
  |  Branch (539:3): [True: 0, False: 0]
  ------------------
  540|      0|		value = ret->atoms[i]->valuep;
  541|      0|                for (j = 0;j < nbatoms;j++) {
  ------------------
  |  Branch (541:28): [True: 0, False: 0]
  ------------------
  542|      0|		    if (xmlStrEqual(stringMap[j], value)) {
  ------------------
  |  Branch (542:11): [True: 0, False: 0]
  ------------------
  543|      0|			stringRemap[i] = j;
  544|      0|			break;
  545|      0|		    }
  546|      0|		}
  547|      0|		if (j >= nbatoms) {
  ------------------
  |  Branch (547:7): [True: 0, False: 0]
  ------------------
  548|      0|		    stringRemap[i] = nbatoms;
  549|      0|		    stringMap[nbatoms] = xmlStrdup(value);
  550|      0|		    if (stringMap[nbatoms] == NULL) {
  ------------------
  |  Branch (550:11): [True: 0, False: 0]
  ------------------
  551|      0|			for (i = 0;i < nbatoms;i++)
  ------------------
  |  Branch (551:15): [True: 0, False: 0]
  ------------------
  552|      0|			    xmlFree(stringMap[i]);
  553|      0|			xmlFree(stringRemap);
  554|      0|			xmlFree(stringMap);
  555|      0|			xmlFree(stateRemap);
  556|      0|			xmlFree(ret);
  557|      0|			return(NULL);
  558|      0|		    }
  559|      0|		    nbatoms++;
  560|      0|		}
  561|      0|	    } else {
  562|      0|		xmlFree(stateRemap);
  563|      0|		xmlFree(stringRemap);
  564|      0|		for (i = 0;i < nbatoms;i++)
  ------------------
  |  Branch (564:14): [True: 0, False: 0]
  ------------------
  565|      0|		    xmlFree(stringMap[i]);
  566|      0|		xmlFree(stringMap);
  567|      0|		xmlFree(ret);
  568|      0|		return(NULL);
  569|      0|	    }
  570|      0|	}
  571|      0|	transitions = (int *) xmlRegCalloc2(nbstates + 1, nbatoms + 1,
  572|      0|                                            sizeof(int));
  573|      0|	if (transitions == NULL) {
  ------------------
  |  Branch (573:6): [True: 0, False: 0]
  ------------------
  574|      0|	    xmlFree(stateRemap);
  575|      0|	    xmlFree(stringRemap);
  576|      0|            for (i = 0;i < nbatoms;i++)
  ------------------
  |  Branch (576:24): [True: 0, False: 0]
  ------------------
  577|      0|		xmlFree(stringMap[i]);
  578|      0|	    xmlFree(stringMap);
  579|      0|	    xmlFree(ret);
  580|      0|	    return(NULL);
  581|      0|	}
  582|       |
  583|       |	/*
  584|       |	 * Allocate the transition table. The first entry for each
  585|       |	 * state corresponds to the state type.
  586|       |	 */
  587|      0|	transdata = NULL;
  588|       |
  589|      0|	for (i = 0;i < ret->nbStates;i++) {
  ------------------
  |  Branch (589:13): [True: 0, False: 0]
  ------------------
  590|      0|	    int stateno, atomno, targetno, prev;
  591|      0|	    xmlRegStatePtr state;
  592|      0|	    xmlRegTransPtr trans;
  593|       |
  594|      0|	    stateno = stateRemap[i];
  595|      0|	    if (stateno == -1)
  ------------------
  |  Branch (595:10): [True: 0, False: 0]
  ------------------
  596|      0|		continue;
  597|      0|	    state = ret->states[i];
  598|       |
  599|      0|	    transitions[stateno * (nbatoms + 1)] = state->type;
  600|       |
  601|      0|	    for (j = 0;j < state->nbTrans;j++) {
  ------------------
  |  Branch (601:17): [True: 0, False: 0]
  ------------------
  602|      0|		trans = &(state->trans[j]);
  603|      0|		if ((trans->to < 0) || (trans->atom == NULL))
  ------------------
  |  Branch (603:7): [True: 0, False: 0]
  |  Branch (603:26): [True: 0, False: 0]
  ------------------
  604|      0|		    continue;
  605|      0|                atomno = stringRemap[trans->atom->no];
  606|      0|		if ((trans->atom->data != NULL) && (transdata == NULL)) {
  ------------------
  |  Branch (606:7): [True: 0, False: 0]
  |  Branch (606:38): [True: 0, False: 0]
  ------------------
  607|      0|		    transdata = (void **) xmlRegCalloc2(nbstates, nbatoms,
  608|      0|			                                sizeof(void *));
  609|      0|		    if (transdata == NULL) {
  ------------------
  |  Branch (609:11): [True: 0, False: 0]
  ------------------
  610|      0|			xmlRegexpErrMemory(ctxt, "compiling regexp");
  611|      0|			break;
  612|      0|		    }
  613|      0|		}
  614|      0|		targetno = stateRemap[trans->to];
  615|       |		/*
  616|       |		 * if the same atom can generate transitions to 2 different
  617|       |		 * states then it means the automata is not deterministic and
  618|       |		 * the compact form can't be used !
  619|       |		 */
  620|      0|		prev = transitions[stateno * (nbatoms + 1) + atomno + 1];
  621|      0|		if (prev != 0) {
  ------------------
  |  Branch (621:7): [True: 0, False: 0]
  ------------------
  622|      0|		    if (prev != targetno + 1) {
  ------------------
  |  Branch (622:11): [True: 0, False: 0]
  ------------------
  623|      0|			ret->determinist = 0;
  624|      0|			if (transdata != NULL)
  ------------------
  |  Branch (624:8): [True: 0, False: 0]
  ------------------
  625|      0|			    xmlFree(transdata);
  626|      0|			xmlFree(transitions);
  627|      0|			xmlFree(stateRemap);
  628|      0|			xmlFree(stringRemap);
  629|      0|			for (i = 0;i < nbatoms;i++)
  ------------------
  |  Branch (629:15): [True: 0, False: 0]
  ------------------
  630|      0|			    xmlFree(stringMap[i]);
  631|      0|			xmlFree(stringMap);
  632|      0|			goto not_determ;
  633|      0|		    }
  634|      0|		} else {
  635|       |#if 0
  636|       |		    printf("State %d trans %d: atom %d to %d : %d to %d\n",
  637|       |			   i, j, trans->atom->no, trans->to, atomno, targetno);
  638|       |#endif
  639|      0|		    transitions[stateno * (nbatoms + 1) + atomno + 1] =
  640|      0|			targetno + 1; /* to avoid 0 */
  641|      0|		    if (transdata != NULL)
  ------------------
  |  Branch (641:11): [True: 0, False: 0]
  ------------------
  642|      0|			transdata[stateno * nbatoms + atomno] =
  643|      0|			    trans->atom->data;
  644|      0|		}
  645|      0|	    }
  646|      0|	}
  647|      0|	ret->determinist = 1;
  648|       |	/*
  649|       |	 * Cleanup of the old data
  650|       |	 */
  651|      0|	if (ret->states != NULL) {
  ------------------
  |  Branch (651:6): [True: 0, False: 0]
  ------------------
  652|      0|	    for (i = 0;i < ret->nbStates;i++)
  ------------------
  |  Branch (652:17): [True: 0, False: 0]
  ------------------
  653|      0|		xmlRegFreeState(ret->states[i]);
  654|      0|	    xmlFree(ret->states);
  655|      0|	}
  656|      0|	ret->states = NULL;
  657|      0|	ret->nbStates = 0;
  658|      0|	if (ret->atoms != NULL) {
  ------------------
  |  Branch (658:6): [True: 0, False: 0]
  ------------------
  659|      0|	    for (i = 0;i < ret->nbAtoms;i++)
  ------------------
  |  Branch (659:17): [True: 0, False: 0]
  ------------------
  660|      0|		xmlRegFreeAtom(ret->atoms[i]);
  661|      0|	    xmlFree(ret->atoms);
  662|      0|	}
  663|      0|	ret->atoms = NULL;
  664|      0|	ret->nbAtoms = 0;
  665|       |
  666|      0|	ret->compact = transitions;
  667|      0|	ret->transdata = transdata;
  668|      0|	ret->stringMap = stringMap;
  669|      0|	ret->nbstrings = nbatoms;
  670|      0|	ret->nbstates = nbstates;
  671|      0|	xmlFree(stateRemap);
  672|      0|	xmlFree(stringRemap);
  673|      0|    }
  674|    153|not_determ:
  675|    153|    ctxt->string = NULL;
  676|    153|    ctxt->nbStates = 0;
  677|    153|    ctxt->states = NULL;
  678|    153|    ctxt->nbAtoms = 0;
  679|    153|    ctxt->atoms = NULL;
  680|    153|    ctxt->nbCounters = 0;
  681|    153|    ctxt->counters = NULL;
  682|    153|    return(ret);
  683|    153|}
xmlregexp.c:xmlRegFreeParserCtxt:
  924|    480|xmlRegFreeParserCtxt(xmlRegParserCtxtPtr ctxt) {
  925|    480|    int i;
  926|    480|    if (ctxt == NULL)
  ------------------
  |  Branch (926:9): [True: 0, False: 480]
  ------------------
  927|      0|	return;
  928|       |
  929|    480|    if (ctxt->string != NULL)
  ------------------
  |  Branch (929:9): [True: 172, False: 308]
  ------------------
  930|    172|	xmlFree(ctxt->string);
  931|    480|    if (ctxt->states != NULL) {
  ------------------
  |  Branch (931:9): [True: 172, False: 308]
  ------------------
  932|  4.99k|	for (i = 0;i < ctxt->nbStates;i++)
  ------------------
  |  Branch (932:13): [True: 4.82k, False: 172]
  ------------------
  933|  4.82k|	    xmlRegFreeState(ctxt->states[i]);
  934|    172|	xmlFree(ctxt->states);
  935|    172|    }
  936|    480|    if (ctxt->atoms != NULL) {
  ------------------
  |  Branch (936:9): [True: 152, False: 328]
  ------------------
  937|  3.49k|	for (i = 0;i < ctxt->nbAtoms;i++)
  ------------------
  |  Branch (937:13): [True: 3.34k, False: 152]
  ------------------
  938|  3.34k|	    xmlRegFreeAtom(ctxt->atoms[i]);
  939|    152|	xmlFree(ctxt->atoms);
  940|    152|    }
  941|    480|    if (ctxt->counters != NULL)
  ------------------
  |  Branch (941:9): [True: 16, False: 464]
  ------------------
  942|     16|	xmlFree(ctxt->counters);
  943|    480|    xmlFree(ctxt);
  944|    480|}
xmlregexp.c:xmlRegCheckCharacter:
 2940|  2.54k|xmlRegCheckCharacter(xmlRegAtomPtr atom, int codepoint) {
 2941|  2.54k|    int i, ret = 0;
 2942|  2.54k|    xmlRegRangePtr range;
 2943|       |
 2944|  2.54k|    if ((atom == NULL) || (!IS_CHAR(codepoint)))
  ------------------
  |  |  125|  2.54k|#define IS_CHAR(c)   xmlIsCharQ(c)
  |  |  ------------------
  |  |  |  |  118|  2.54k|#define xmlIsCharQ(c)		(((c) < 0x100) ? \
  |  |  |  |  ------------------
  |  |  |  |  |  Branch (118:25): [True: 2.54k, False: 0]
  |  |  |  |  ------------------
  |  |  |  |  119|  2.54k|				 xmlIsChar_ch((c)) :\
  |  |  |  |  ------------------
  |  |  |  |  |  |  108|  2.54k|#define xmlIsChar_ch(c)		(((0x9 <= (c)) && ((c) <= 0xa)) || \
  |  |  |  |  |  |  ------------------
  |  |  |  |  |  |  |  Branch (108:28): [True: 2.54k, False: 0]
  |  |  |  |  |  |  |  Branch (108:44): [True: 0, False: 2.54k]
  |  |  |  |  |  |  ------------------
  |  |  |  |  |  |  109|  2.54k|				 ((c) == 0xd) || \
  |  |  |  |  |  |  ------------------
  |  |  |  |  |  |  |  Branch (109:6): [True: 0, False: 2.54k]
  |  |  |  |  |  |  ------------------
  |  |  |  |  |  |  110|  2.54k|				  (0x20 <= (c)))
  |  |  |  |  |  |  ------------------
  |  |  |  |  |  |  |  Branch (110:7): [True: 2.54k, False: 1]
  |  |  |  |  |  |  ------------------
  |  |  |  |  ------------------
  |  |  |  |  120|  2.54k|				(((0x100 <= (c)) && ((c) <= 0xd7ff)) || \
  |  |  |  |  ------------------
  |  |  |  |  |  Branch (120:7): [True: 0, False: 0]
  |  |  |  |  |  Branch (120:25): [True: 0, False: 0]
  |  |  |  |  ------------------
  |  |  |  |  121|      0|				 ((0xe000 <= (c)) && ((c) <= 0xfffd)) || \
  |  |  |  |  ------------------
  |  |  |  |  |  Branch (121:7): [True: 0, False: 0]
  |  |  |  |  |  Branch (121:26): [True: 0, False: 0]
  |  |  |  |  ------------------
  |  |  |  |  122|      0|				 ((0x10000 <= (c)) && ((c) <= 0x10ffff))))
  |  |  |  |  ------------------
  |  |  |  |  |  Branch (122:7): [True: 0, False: 0]
  |  |  |  |  |  Branch (122:27): [True: 0, False: 0]
  |  |  |  |  ------------------
  |  |  ------------------
  ------------------
  |  Branch (2944:9): [True: 0, False: 2.54k]
  |  Branch (2944:27): [True: 1, False: 2.54k]
  ------------------
 2945|      1|	return(-1);
 2946|       |
 2947|  2.54k|    switch (atom->type) {
  ------------------
  |  Branch (2947:13): [True: 0, False: 2.54k]
  ------------------
 2948|      0|        case XML_REGEXP_SUBREG:
  ------------------
  |  Branch (2948:9): [True: 0, False: 2.54k]
  ------------------
 2949|      0|        case XML_REGEXP_EPSILON:
  ------------------
  |  Branch (2949:9): [True: 0, False: 2.54k]
  ------------------
 2950|      0|	    return(-1);
 2951|      0|        case XML_REGEXP_CHARVAL:
  ------------------
  |  Branch (2951:9): [True: 0, False: 2.54k]
  ------------------
 2952|      0|            return(codepoint == atom->codepoint);
 2953|    914|        case XML_REGEXP_RANGES: {
  ------------------
  |  Branch (2953:9): [True: 914, False: 1.63k]
  ------------------
 2954|    914|	    int accept = 0;
 2955|       |
 2956|  1.87k|	    for (i = 0;i < atom->nbRanges;i++) {
  ------------------
  |  Branch (2956:17): [True: 961, False: 913]
  ------------------
 2957|    961|		range = atom->ranges[i];
 2958|    961|		if (range->neg == 2) {
  ------------------
  |  Branch (2958:7): [True: 0, False: 961]
  ------------------
 2959|      0|		    ret = xmlRegCheckCharacterRange(range->type, codepoint,
 2960|      0|						0, range->start, range->end,
 2961|      0|						range->blockName);
 2962|      0|		    if (ret != 0)
  ------------------
  |  Branch (2962:11): [True: 0, False: 0]
  ------------------
 2963|      0|			return(0); /* excluded char */
 2964|    961|		} else if (range->neg) {
  ------------------
  |  Branch (2964:14): [True: 6, False: 955]
  ------------------
 2965|      6|		    ret = xmlRegCheckCharacterRange(range->type, codepoint,
 2966|      6|						0, range->start, range->end,
 2967|      6|						range->blockName);
 2968|      6|		    if (ret == 0)
  ------------------
  |  Branch (2968:11): [True: 5, False: 1]
  ------------------
 2969|      5|		        accept = 1;
 2970|      1|		    else
 2971|      1|		        return(0);
 2972|    955|		} else {
 2973|    955|		    ret = xmlRegCheckCharacterRange(range->type, codepoint,
 2974|    955|						0, range->start, range->end,
 2975|    955|						range->blockName);
 2976|    955|		    if (ret != 0)
  ------------------
  |  Branch (2976:11): [True: 6, False: 949]
  ------------------
 2977|      6|			accept = 1; /* might still be excluded */
 2978|    955|		}
 2979|    961|	    }
 2980|    913|	    return(accept);
 2981|    914|	}
 2982|      0|        case XML_REGEXP_STRING:
  ------------------
  |  Branch (2982:9): [True: 0, False: 2.54k]
  ------------------
 2983|      0|	    printf("TODO: XML_REGEXP_STRING\n");
 2984|      0|	    return(-1);
 2985|      0|        case XML_REGEXP_ANYCHAR:
  ------------------
  |  Branch (2985:9): [True: 0, False: 2.54k]
  ------------------
 2986|      0|        case XML_REGEXP_ANYSPACE:
  ------------------
  |  Branch (2986:9): [True: 0, False: 2.54k]
  ------------------
 2987|      0|        case XML_REGEXP_NOTSPACE:
  ------------------
  |  Branch (2987:9): [True: 0, False: 2.54k]
  ------------------
 2988|  1.03k|        case XML_REGEXP_INITNAME:
  ------------------
  |  Branch (2988:9): [True: 1.03k, False: 1.51k]
  ------------------
 2989|  1.03k|        case XML_REGEXP_NOTINITNAME:
  ------------------
  |  Branch (2989:9): [True: 0, False: 2.54k]
  ------------------
 2990|  1.54k|        case XML_REGEXP_NAMECHAR:
  ------------------
  |  Branch (2990:9): [True: 507, False: 2.04k]
  ------------------
 2991|  1.54k|        case XML_REGEXP_NOTNAMECHAR:
  ------------------
  |  Branch (2991:9): [True: 0, False: 2.54k]
  ------------------
 2992|  1.54k|        case XML_REGEXP_DECIMAL:
  ------------------
  |  Branch (2992:9): [True: 1, False: 2.54k]
  ------------------
 2993|  1.54k|        case XML_REGEXP_NOTDECIMAL:
  ------------------
  |  Branch (2993:9): [True: 0, False: 2.54k]
  ------------------
 2994|  1.54k|        case XML_REGEXP_REALCHAR:
  ------------------
  |  Branch (2994:9): [True: 0, False: 2.54k]
  ------------------
 2995|  1.54k|        case XML_REGEXP_NOTREALCHAR:
  ------------------
  |  Branch (2995:9): [True: 0, False: 2.54k]
  ------------------
 2996|  1.54k|        case XML_REGEXP_LETTER:
  ------------------
  |  Branch (2996:9): [True: 0, False: 2.54k]
  ------------------
 2997|  1.54k|        case XML_REGEXP_LETTER_UPPERCASE:
  ------------------
  |  Branch (2997:9): [True: 0, False: 2.54k]
  ------------------
 2998|  1.54k|        case XML_REGEXP_LETTER_LOWERCASE:
  ------------------
  |  Branch (2998:9): [True: 0, False: 2.54k]
  ------------------
 2999|  1.54k|        case XML_REGEXP_LETTER_TITLECASE:
  ------------------
  |  Branch (2999:9): [True: 0, False: 2.54k]
  ------------------
 3000|  1.54k|        case XML_REGEXP_LETTER_MODIFIER:
  ------------------
  |  Branch (3000:9): [True: 0, False: 2.54k]
  ------------------
 3001|  1.54k|        case XML_REGEXP_LETTER_OTHERS:
  ------------------
  |  Branch (3001:9): [True: 0, False: 2.54k]
  ------------------
 3002|  1.54k|        case XML_REGEXP_MARK:
  ------------------
  |  Branch (3002:9): [True: 0, False: 2.54k]
  ------------------
 3003|  1.54k|        case XML_REGEXP_MARK_NONSPACING:
  ------------------
  |  Branch (3003:9): [True: 0, False: 2.54k]
  ------------------
 3004|  1.54k|        case XML_REGEXP_MARK_SPACECOMBINING:
  ------------------
  |  Branch (3004:9): [True: 0, False: 2.54k]
  ------------------
 3005|  1.54k|        case XML_REGEXP_MARK_ENCLOSING:
  ------------------
  |  Branch (3005:9): [True: 0, False: 2.54k]
  ------------------
 3006|  1.54k|        case XML_REGEXP_NUMBER:
  ------------------
  |  Branch (3006:9): [True: 0, False: 2.54k]
  ------------------
 3007|  1.61k|        case XML_REGEXP_NUMBER_DECIMAL:
  ------------------
  |  Branch (3007:9): [True: 72, False: 2.47k]
  ------------------
 3008|  1.61k|        case XML_REGEXP_NUMBER_LETTER:
  ------------------
  |  Branch (3008:9): [True: 0, False: 2.54k]
  ------------------
 3009|  1.61k|        case XML_REGEXP_NUMBER_OTHERS:
  ------------------
  |  Branch (3009:9): [True: 0, False: 2.54k]
  ------------------
 3010|  1.61k|        case XML_REGEXP_PUNCT:
  ------------------
  |  Branch (3010:9): [True: 0, False: 2.54k]
  ------------------
 3011|  1.61k|        case XML_REGEXP_PUNCT_CONNECTOR:
  ------------------
  |  Branch (3011:9): [True: 0, False: 2.54k]
  ------------------
 3012|  1.61k|        case XML_REGEXP_PUNCT_DASH:
  ------------------
  |  Branch (3012:9): [True: 0, False: 2.54k]
  ------------------
 3013|  1.61k|        case XML_REGEXP_PUNCT_OPEN:
  ------------------
  |  Branch (3013:9): [True: 0, False: 2.54k]
  ------------------
 3014|  1.61k|        case XML_REGEXP_PUNCT_CLOSE:
  ------------------
  |  Branch (3014:9): [True: 0, False: 2.54k]
  ------------------
 3015|  1.61k|        case XML_REGEXP_PUNCT_INITQUOTE:
  ------------------
  |  Branch (3015:9): [True: 0, False: 2.54k]
  ------------------
 3016|  1.61k|        case XML_REGEXP_PUNCT_FINQUOTE:
  ------------------
  |  Branch (3016:9): [True: 0, False: 2.54k]
  ------------------
 3017|  1.61k|        case XML_REGEXP_PUNCT_OTHERS:
  ------------------
  |  Branch (3017:9): [True: 0, False: 2.54k]
  ------------------
 3018|  1.61k|        case XML_REGEXP_SEPAR:
  ------------------
  |  Branch (3018:9): [True: 0, False: 2.54k]
  ------------------
 3019|  1.61k|        case XML_REGEXP_SEPAR_SPACE:
  ------------------
  |  Branch (3019:9): [True: 0, False: 2.54k]
  ------------------
 3020|  1.61k|        case XML_REGEXP_SEPAR_LINE:
  ------------------
  |  Branch (3020:9): [True: 0, False: 2.54k]
  ------------------
 3021|  1.61k|        case XML_REGEXP_SEPAR_PARA:
  ------------------
  |  Branch (3021:9): [True: 0, False: 2.54k]
  ------------------
 3022|  1.61k|        case XML_REGEXP_SYMBOL:
  ------------------
  |  Branch (3022:9): [True: 0, False: 2.54k]
  ------------------
 3023|  1.61k|        case XML_REGEXP_SYMBOL_MATH:
  ------------------
  |  Branch (3023:9): [True: 0, False: 2.54k]
  ------------------
 3024|  1.61k|        case XML_REGEXP_SYMBOL_CURRENCY:
  ------------------
  |  Branch (3024:9): [True: 0, False: 2.54k]
  ------------------
 3025|  1.61k|        case XML_REGEXP_SYMBOL_MODIFIER:
  ------------------
  |  Branch (3025:9): [True: 0, False: 2.54k]
  ------------------
 3026|  1.61k|        case XML_REGEXP_SYMBOL_OTHERS:
  ------------------
  |  Branch (3026:9): [True: 0, False: 2.54k]
  ------------------
 3027|  1.61k|        case XML_REGEXP_OTHER:
  ------------------
  |  Branch (3027:9): [True: 0, False: 2.54k]
  ------------------
 3028|  1.61k|        case XML_REGEXP_OTHER_CONTROL:
  ------------------
  |  Branch (3028:9): [True: 0, False: 2.54k]
  ------------------
 3029|  1.61k|        case XML_REGEXP_OTHER_FORMAT:
  ------------------
  |  Branch (3029:9): [True: 0, False: 2.54k]
  ------------------
 3030|  1.61k|        case XML_REGEXP_OTHER_PRIVATE:
  ------------------
  |  Branch (3030:9): [True: 0, False: 2.54k]
  ------------------
 3031|  1.61k|        case XML_REGEXP_OTHER_NA:
  ------------------
  |  Branch (3031:9): [True: 0, False: 2.54k]
  ------------------
 3032|  1.63k|	case XML_REGEXP_BLOCK_NAME:
  ------------------
  |  Branch (3032:2): [True: 18, False: 2.52k]
  ------------------
 3033|  1.63k|	    ret = xmlRegCheckCharacterRange(atom->type, codepoint, 0, 0, 0,
 3034|  1.63k|		                            (const xmlChar *)atom->valuep);
 3035|  1.63k|	    if (atom->neg)
  ------------------
  |  Branch (3035:10): [True: 0, False: 1.63k]
  ------------------
 3036|      0|		ret = !ret;
 3037|  1.63k|	    break;
 3038|  2.54k|    }
 3039|  1.63k|    return(ret);
 3040|  2.54k|}
xmlregexp.c:xmlRegCheckCharacterRange:
 2766|  4.62k|	                  int start, int end, const xmlChar *blockName) {
 2767|  4.62k|    int ret = 0;
 2768|       |
 2769|  4.62k|    switch (type) {
  ------------------
  |  Branch (2769:13): [True: 0, False: 4.62k]
  ------------------
 2770|      0|        case XML_REGEXP_STRING:
  ------------------
  |  Branch (2770:9): [True: 0, False: 4.62k]
  ------------------
 2771|      0|        case XML_REGEXP_SUBREG:
  ------------------
  |  Branch (2771:9): [True: 0, False: 4.62k]
  ------------------
 2772|      0|        case XML_REGEXP_RANGES:
  ------------------
  |  Branch (2772:9): [True: 0, False: 4.62k]
  ------------------
 2773|      0|        case XML_REGEXP_EPSILON:
  ------------------
  |  Branch (2773:9): [True: 0, False: 4.62k]
  ------------------
 2774|      0|	    return(-1);
 2775|      0|        case XML_REGEXP_ANYCHAR:
  ------------------
  |  Branch (2775:9): [True: 0, False: 4.62k]
  ------------------
 2776|      0|	    ret = ((codepoint != '\n') && (codepoint != '\r'));
  ------------------
  |  Branch (2776:13): [True: 0, False: 0]
  |  Branch (2776:36): [True: 0, False: 0]
  ------------------
 2777|      0|	    break;
 2778|    416|        case XML_REGEXP_CHARVAL:
  ------------------
  |  Branch (2778:9): [True: 416, False: 4.20k]
  ------------------
 2779|    416|	    ret = ((codepoint >= start) && (codepoint <= end));
  ------------------
  |  Branch (2779:13): [True: 170, False: 246]
  |  Branch (2779:37): [True: 5, False: 165]
  ------------------
 2780|    416|	    break;
 2781|      0|        case XML_REGEXP_NOTSPACE:
  ------------------
  |  Branch (2781:9): [True: 0, False: 4.62k]
  ------------------
 2782|      0|	    neg = !neg;
 2783|       |            /* Falls through. */
 2784|  2.42k|        case XML_REGEXP_ANYSPACE:
  ------------------
  |  Branch (2784:9): [True: 2.42k, False: 2.20k]
  ------------------
 2785|  2.42k|	    ret = ((codepoint == '\n') || (codepoint == '\r') ||
  ------------------
  |  Branch (2785:13): [True: 0, False: 2.42k]
  |  Branch (2785:36): [True: 0, False: 2.42k]
  ------------------
 2786|  2.42k|		   (codepoint == '\t') || (codepoint == ' '));
  ------------------
  |  Branch (2786:6): [True: 0, False: 2.42k]
  |  Branch (2786:29): [True: 0, False: 2.42k]
  ------------------
 2787|  2.42k|	    break;
 2788|      0|        case XML_REGEXP_NOTINITNAME:
  ------------------
  |  Branch (2788:9): [True: 0, False: 4.62k]
  ------------------
 2789|      0|	    neg = !neg;
 2790|       |            /* Falls through. */
 2791|  1.03k|        case XML_REGEXP_INITNAME:
  ------------------
  |  Branch (2791:9): [True: 1.03k, False: 3.58k]
  ------------------
 2792|  1.03k|	    ret = (IS_LETTER(codepoint) ||
  ------------------
  |  |  240|  2.07k|#define IS_LETTER(c) (IS_BASECHAR(c) || IS_IDEOGRAPHIC(c))
  |  |  ------------------
  |  |  |  |  161|  1.03k|#define IS_BASECHAR(c) xmlIsBaseCharQ(c)
  |  |  |  |  ------------------
  |  |  |  |  |  |   76|  2.07k|#define xmlIsBaseCharQ(c)	(((c) < 0x100) ? \
  |  |  |  |  |  |  ------------------
  |  |  |  |  |  |  |  Branch (76:27): [True: 256, False: 779]
  |  |  |  |  |  |  |  Branch (76:28): [True: 1.03k, False: 0]
  |  |  |  |  |  |  ------------------
  |  |  |  |  |  |   77|  2.07k|				 xmlIsBaseChar_ch((c)) : \
  |  |  |  |  |  |  ------------------
  |  |  |  |  |  |  |  |   64|  1.03k|#define xmlIsBaseChar_ch(c)	(((0x41 <= (c)) && ((c) <= 0x5a)) || \
  |  |  |  |  |  |  |  |  ------------------
  |  |  |  |  |  |  |  |  |  Branch (64:31): [True: 264, False: 771]
  |  |  |  |  |  |  |  |  |  Branch (64:48): [True: 8, False: 256]
  |  |  |  |  |  |  |  |  ------------------
  |  |  |  |  |  |  |  |   65|  1.03k|				 ((0x61 <= (c)) && ((c) <= 0x7a)) || \
  |  |  |  |  |  |  |  |  ------------------
  |  |  |  |  |  |  |  |  |  Branch (65:7): [True: 256, False: 771]
  |  |  |  |  |  |  |  |  |  Branch (65:24): [True: 248, False: 8]
  |  |  |  |  |  |  |  |  ------------------
  |  |  |  |  |  |  |  |   66|  1.03k|				 ((0xc0 <= (c)) && ((c) <= 0xd6)) || \
  |  |  |  |  |  |  |  |  ------------------
  |  |  |  |  |  |  |  |  |  Branch (66:7): [True: 0, False: 779]
  |  |  |  |  |  |  |  |  |  Branch (66:24): [True: 0, False: 0]
  |  |  |  |  |  |  |  |  ------------------
  |  |  |  |  |  |  |  |   67|  1.03k|				 ((0xd8 <= (c)) && ((c) <= 0xf6)) || \
  |  |  |  |  |  |  |  |  ------------------
  |  |  |  |  |  |  |  |  |  Branch (67:7): [True: 0, False: 779]
  |  |  |  |  |  |  |  |  |  Branch (67:24): [True: 0, False: 0]
  |  |  |  |  |  |  |  |  ------------------
  |  |  |  |  |  |  |  |   68|  1.03k|				  (0xf8 <= (c)))
  |  |  |  |  |  |  |  |  ------------------
  |  |  |  |  |  |  |  |  |  Branch (68:7): [True: 0, False: 779]
  |  |  |  |  |  |  |  |  ------------------
  |  |  |  |  |  |  ------------------
  |  |  |  |  |  |   78|  2.07k|				 xmlCharInRange((c), &xmlIsBaseCharGroup))
  |  |  |  |  ------------------
  |  |  ------------------
  |  |               #define IS_LETTER(c) (IS_BASECHAR(c) || IS_IDEOGRAPHIC(c))
  |  |  ------------------
  |  |  |  |  229|    779|#define IS_IDEOGRAPHIC(c) xmlIsIdeographicQ(c)
  |  |  |  |  ------------------
  |  |  |  |  |  |  184|    779|#define xmlIsIdeographicQ(c)	(((c) < 0x100) ? \
  |  |  |  |  |  |  ------------------
  |  |  |  |  |  |  |  Branch (184:30): [True: 0, False: 779]
  |  |  |  |  |  |  |  Branch (184:31): [True: 779, False: 0]
  |  |  |  |  |  |  ------------------
  |  |  |  |  |  |  185|    779|				 0 :\
  |  |  |  |  |  |  186|    779|				(((0x4e00 <= (c)) && ((c) <= 0x9fa5)) || \
  |  |  |  |  |  |  ------------------
  |  |  |  |  |  |  |  Branch (186:7): [True: 0, False: 0]
  |  |  |  |  |  |  |  Branch (186:26): [True: 0, False: 0]
  |  |  |  |  |  |  ------------------
  |  |  |  |  |  |  187|      0|				 ((c) == 0x3007) || \
  |  |  |  |  |  |  ------------------
  |  |  |  |  |  |  |  Branch (187:6): [True: 0, False: 0]
  |  |  |  |  |  |  ------------------
  |  |  |  |  |  |  188|      0|				 ((0x3021 <= (c)) && ((c) <= 0x3029))))
  |  |  |  |  |  |  ------------------
  |  |  |  |  |  |  |  Branch (188:7): [True: 0, False: 0]
  |  |  |  |  |  |  |  Branch (188:26): [True: 0, False: 0]
  |  |  |  |  |  |  ------------------
  |  |  |  |  ------------------
  |  |  ------------------
  ------------------
 2793|  1.03k|		   (codepoint == '_') || (codepoint == ':'));
  ------------------
  |  Branch (2793:6): [True: 0, False: 779]
  |  Branch (2793:28): [True: 0, False: 779]
  ------------------
 2794|  1.03k|	    break;
 2795|      0|        case XML_REGEXP_NOTNAMECHAR:
  ------------------
  |  Branch (2795:9): [True: 0, False: 4.62k]
  ------------------
 2796|      0|	    neg = !neg;
 2797|       |            /* Falls through. */
 2798|    507|        case XML_REGEXP_NAMECHAR:
  ------------------
  |  Branch (2798:9): [True: 507, False: 4.11k]
  ------------------
 2799|    507|	    ret = (IS_LETTER(codepoint) || IS_DIGIT(codepoint) ||
  ------------------
  |  |  240|  1.01k|#define IS_LETTER(c) (IS_BASECHAR(c) || IS_IDEOGRAPHIC(c))
  |  |  ------------------
  |  |  |  |  161|    507|#define IS_BASECHAR(c) xmlIsBaseCharQ(c)
  |  |  |  |  ------------------
  |  |  |  |  |  |   76|  1.01k|#define xmlIsBaseCharQ(c)	(((c) < 0x100) ? \
  |  |  |  |  |  |  ------------------
  |  |  |  |  |  |  |  Branch (76:27): [True: 10, False: 497]
  |  |  |  |  |  |  |  Branch (76:28): [True: 507, False: 0]
  |  |  |  |  |  |  ------------------
  |  |  |  |  |  |   77|  1.01k|				 xmlIsBaseChar_ch((c)) : \
  |  |  |  |  |  |  ------------------
  |  |  |  |  |  |  |  |   64|    507|#define xmlIsBaseChar_ch(c)	(((0x41 <= (c)) && ((c) <= 0x5a)) || \
  |  |  |  |  |  |  |  |  ------------------
  |  |  |  |  |  |  |  |  |  Branch (64:31): [True: 136, False: 371]
  |  |  |  |  |  |  |  |  |  Branch (64:48): [True: 0, False: 136]
  |  |  |  |  |  |  |  |  ------------------
  |  |  |  |  |  |  |  |   65|    507|				 ((0x61 <= (c)) && ((c) <= 0x7a)) || \
  |  |  |  |  |  |  |  |  ------------------
  |  |  |  |  |  |  |  |  |  Branch (65:7): [True: 136, False: 371]
  |  |  |  |  |  |  |  |  |  Branch (65:24): [True: 10, False: 126]
  |  |  |  |  |  |  |  |  ------------------
  |  |  |  |  |  |  |  |   66|    507|				 ((0xc0 <= (c)) && ((c) <= 0xd6)) || \
  |  |  |  |  |  |  |  |  ------------------
  |  |  |  |  |  |  |  |  |  Branch (66:7): [True: 0, False: 497]
  |  |  |  |  |  |  |  |  |  Branch (66:24): [True: 0, False: 0]
  |  |  |  |  |  |  |  |  ------------------
  |  |  |  |  |  |  |  |   67|    507|				 ((0xd8 <= (c)) && ((c) <= 0xf6)) || \
  |  |  |  |  |  |  |  |  ------------------
  |  |  |  |  |  |  |  |  |  Branch (67:7): [True: 0, False: 497]
  |  |  |  |  |  |  |  |  |  Branch (67:24): [True: 0, False: 0]
  |  |  |  |  |  |  |  |  ------------------
  |  |  |  |  |  |  |  |   68|    507|				  (0xf8 <= (c)))
  |  |  |  |  |  |  |  |  ------------------
  |  |  |  |  |  |  |  |  |  Branch (68:7): [True: 0, False: 497]
  |  |  |  |  |  |  |  |  ------------------
  |  |  |  |  |  |  ------------------
  |  |  |  |  |  |   78|  1.01k|				 xmlCharInRange((c), &xmlIsBaseCharGroup))
  |  |  |  |  ------------------
  |  |  ------------------
  |  |               #define IS_LETTER(c) (IS_BASECHAR(c) || IS_IDEOGRAPHIC(c))
  |  |  ------------------
  |  |  |  |  229|    497|#define IS_IDEOGRAPHIC(c) xmlIsIdeographicQ(c)
  |  |  |  |  ------------------
  |  |  |  |  |  |  184|    497|#define xmlIsIdeographicQ(c)	(((c) < 0x100) ? \
  |  |  |  |  |  |  ------------------
  |  |  |  |  |  |  |  Branch (184:30): [True: 0, False: 497]
  |  |  |  |  |  |  |  Branch (184:31): [True: 497, False: 0]
  |  |  |  |  |  |  ------------------
  |  |  |  |  |  |  185|    497|				 0 :\
  |  |  |  |  |  |  186|    497|				(((0x4e00 <= (c)) && ((c) <= 0x9fa5)) || \
  |  |  |  |  |  |  ------------------
  |  |  |  |  |  |  |  Branch (186:7): [True: 0, False: 0]
  |  |  |  |  |  |  |  Branch (186:26): [True: 0, False: 0]
  |  |  |  |  |  |  ------------------
  |  |  |  |  |  |  187|      0|				 ((c) == 0x3007) || \
  |  |  |  |  |  |  ------------------
  |  |  |  |  |  |  |  Branch (187:6): [True: 0, False: 0]
  |  |  |  |  |  |  ------------------
  |  |  |  |  |  |  188|      0|				 ((0x3021 <= (c)) && ((c) <= 0x3029))))
  |  |  |  |  |  |  ------------------
  |  |  |  |  |  |  |  Branch (188:7): [True: 0, False: 0]
  |  |  |  |  |  |  |  Branch (188:26): [True: 0, False: 0]
  |  |  |  |  |  |  ------------------
  |  |  |  |  ------------------
  |  |  ------------------
  ------------------
              	    ret = (IS_LETTER(codepoint) || IS_DIGIT(codepoint) ||
  ------------------
  |  |  171|    497|#define IS_DIGIT(c) xmlIsDigitQ(c)
  |  |  ------------------
  |  |  |  |  152|  1.00k|#define xmlIsDigitQ(c)		(((c) < 0x100) ? \
  |  |  |  |  ------------------
  |  |  |  |  |  Branch (152:25): [True: 0, False: 497]
  |  |  |  |  |  Branch (152:26): [True: 497, False: 0]
  |  |  |  |  ------------------
  |  |  |  |  153|  1.00k|				 xmlIsDigit_ch((c)) : \
  |  |  |  |  ------------------
  |  |  |  |  |  |  144|    497|#define xmlIsDigit_ch(c)	(((0x30 <= (c)) && ((c) <= 0x39)))
  |  |  |  |  |  |  ------------------
  |  |  |  |  |  |  |  Branch (144:28): [True: 274, False: 223]
  |  |  |  |  |  |  |  Branch (144:45): [True: 0, False: 274]
  |  |  |  |  |  |  ------------------
  |  |  |  |  ------------------
  |  |  |  |  154|  1.00k|				 xmlCharInRange((c), &xmlIsDigitGroup))
  |  |  ------------------
  ------------------
 2800|    507|		   (codepoint == '.') || (codepoint == '-') ||
  ------------------
  |  Branch (2800:6): [True: 3, False: 494]
  |  Branch (2800:28): [True: 0, False: 494]
  ------------------
 2801|    507|		   (codepoint == '_') || (codepoint == ':') ||
  ------------------
  |  Branch (2801:6): [True: 0, False: 494]
  |  Branch (2801:28): [True: 148, False: 346]
  ------------------
 2802|    507|		   IS_COMBINING(codepoint) || IS_EXTENDER(codepoint));
  ------------------
  |  |  189|    346|#define IS_COMBINING(c) xmlIsCombiningQ(c)
  |  |  ------------------
  |  |  |  |  132|    853|#define xmlIsCombiningQ(c)	(((c) < 0x100) ? \
  |  |  |  |  ------------------
  |  |  |  |  |  Branch (132:28): [True: 0, False: 346]
  |  |  |  |  |  Branch (132:29): [True: 346, False: 0]
  |  |  |  |  ------------------
  |  |  |  |  133|    853|				 0 : \
  |  |  |  |  134|    853|				 xmlCharInRange((c), &xmlIsCombiningGroup))
  |  |  ------------------
  ------------------
              		   IS_COMBINING(codepoint) || IS_EXTENDER(codepoint));
  ------------------
  |  |  210|    346|#define IS_EXTENDER(c) xmlIsExtenderQ(c)
  |  |  ------------------
  |  |  |  |  172|    346|#define xmlIsExtenderQ(c)	(((c) < 0x100) ? \
  |  |  |  |  ------------------
  |  |  |  |  |  Branch (172:27): [True: 0, False: 346]
  |  |  |  |  |  Branch (172:28): [True: 346, False: 0]
  |  |  |  |  ------------------
  |  |  |  |  173|    346|				 xmlIsExtender_ch((c)) : \
  |  |  |  |  ------------------
  |  |  |  |  |  |  164|    346|#define xmlIsExtender_ch(c)	(((c) == 0xb7))
  |  |  |  |  ------------------
  |  |  |  |  174|    346|				 xmlCharInRange((c), &xmlIsExtenderGroup))
  |  |  ------------------
  ------------------
 2803|    507|	    break;
 2804|      0|        case XML_REGEXP_NOTDECIMAL:
  ------------------
  |  Branch (2804:9): [True: 0, False: 4.62k]
  ------------------
 2805|      0|	    neg = !neg;
 2806|       |            /* Falls through. */
 2807|      1|        case XML_REGEXP_DECIMAL:
  ------------------
  |  Branch (2807:9): [True: 1, False: 4.62k]
  ------------------
 2808|      1|	    ret = xmlUCSIsCatNd(codepoint);
 2809|      1|	    break;
 2810|      0|        case XML_REGEXP_REALCHAR:
  ------------------
  |  Branch (2810:9): [True: 0, False: 4.62k]
  ------------------
 2811|      0|	    neg = !neg;
 2812|       |            /* Falls through. */
 2813|      0|        case XML_REGEXP_NOTREALCHAR:
  ------------------
  |  Branch (2813:9): [True: 0, False: 4.62k]
  ------------------
 2814|      0|	    ret = xmlUCSIsCatP(codepoint);
 2815|      0|	    if (ret == 0)
  ------------------
  |  Branch (2815:10): [True: 0, False: 0]
  ------------------
 2816|      0|		ret = xmlUCSIsCatZ(codepoint);
 2817|      0|	    if (ret == 0)
  ------------------
  |  Branch (2817:10): [True: 0, False: 0]
  ------------------
 2818|      0|		ret = xmlUCSIsCatC(codepoint);
 2819|      0|	    break;
 2820|      0|        case XML_REGEXP_LETTER:
  ------------------
  |  Branch (2820:9): [True: 0, False: 4.62k]
  ------------------
 2821|      0|	    ret = xmlUCSIsCatL(codepoint);
 2822|      0|	    break;
 2823|      0|        case XML_REGEXP_LETTER_UPPERCASE:
  ------------------
  |  Branch (2823:9): [True: 0, False: 4.62k]
  ------------------
 2824|      0|	    ret = xmlUCSIsCatLu(codepoint);
 2825|      0|	    break;
 2826|      0|        case XML_REGEXP_LETTER_LOWERCASE:
  ------------------
  |  Branch (2826:9): [True: 0, False: 4.62k]
  ------------------
 2827|      0|	    ret = xmlUCSIsCatLl(codepoint);
 2828|      0|	    break;
 2829|      0|        case XML_REGEXP_LETTER_TITLECASE:
  ------------------
  |  Branch (2829:9): [True: 0, False: 4.62k]
  ------------------
 2830|      0|	    ret = xmlUCSIsCatLt(codepoint);
 2831|      0|	    break;
 2832|      0|        case XML_REGEXP_LETTER_MODIFIER:
  ------------------
  |  Branch (2832:9): [True: 0, False: 4.62k]
  ------------------
 2833|      0|	    ret = xmlUCSIsCatLm(codepoint);
 2834|      0|	    break;
 2835|      0|        case XML_REGEXP_LETTER_OTHERS:
  ------------------
  |  Branch (2835:9): [True: 0, False: 4.62k]
  ------------------
 2836|      0|	    ret = xmlUCSIsCatLo(codepoint);
 2837|      0|	    break;
 2838|      0|        case XML_REGEXP_MARK:
  ------------------
  |  Branch (2838:9): [True: 0, False: 4.62k]
  ------------------
 2839|      0|	    ret = xmlUCSIsCatM(codepoint);
 2840|      0|	    break;
 2841|      0|        case XML_REGEXP_MARK_NONSPACING:
  ------------------
  |  Branch (2841:9): [True: 0, False: 4.62k]
  ------------------
 2842|      0|	    ret = xmlUCSIsCatMn(codepoint);
 2843|      0|	    break;
 2844|      0|        case XML_REGEXP_MARK_SPACECOMBINING:
  ------------------
  |  Branch (2844:9): [True: 0, False: 4.62k]
  ------------------
 2845|      0|	    ret = xmlUCSIsCatMc(codepoint);
 2846|      0|	    break;
 2847|      0|        case XML_REGEXP_MARK_ENCLOSING:
  ------------------
  |  Branch (2847:9): [True: 0, False: 4.62k]
  ------------------
 2848|      0|	    ret = xmlUCSIsCatMe(codepoint);
 2849|      0|	    break;
 2850|      0|        case XML_REGEXP_NUMBER:
  ------------------
  |  Branch (2850:9): [True: 0, False: 4.62k]
  ------------------
 2851|      0|	    ret = xmlUCSIsCatN(codepoint);
 2852|      0|	    break;
 2853|     72|        case XML_REGEXP_NUMBER_DECIMAL:
  ------------------
  |  Branch (2853:9): [True: 72, False: 4.55k]
  ------------------
 2854|     72|	    ret = xmlUCSIsCatNd(codepoint);
 2855|     72|	    break;
 2856|      0|        case XML_REGEXP_NUMBER_LETTER:
  ------------------
  |  Branch (2856:9): [True: 0, False: 4.62k]
  ------------------
 2857|      0|	    ret = xmlUCSIsCatNl(codepoint);
 2858|      0|	    break;
 2859|      0|        case XML_REGEXP_NUMBER_OTHERS:
  ------------------
  |  Branch (2859:9): [True: 0, False: 4.62k]
  ------------------
 2860|      0|	    ret = xmlUCSIsCatNo(codepoint);
 2861|      0|	    break;
 2862|      0|        case XML_REGEXP_PUNCT:
  ------------------
  |  Branch (2862:9): [True: 0, False: 4.62k]
  ------------------
 2863|      0|	    ret = xmlUCSIsCatP(codepoint);
 2864|      0|	    break;
 2865|      0|        case XML_REGEXP_PUNCT_CONNECTOR:
  ------------------
  |  Branch (2865:9): [True: 0, False: 4.62k]
  ------------------
 2866|      0|	    ret = xmlUCSIsCatPc(codepoint);
 2867|      0|	    break;
 2868|      0|        case XML_REGEXP_PUNCT_DASH:
  ------------------
  |  Branch (2868:9): [True: 0, False: 4.62k]
  ------------------
 2869|      0|	    ret = xmlUCSIsCatPd(codepoint);
 2870|      0|	    break;
 2871|      0|        case XML_REGEXP_PUNCT_OPEN:
  ------------------
  |  Branch (2871:9): [True: 0, False: 4.62k]
  ------------------
 2872|      0|	    ret = xmlUCSIsCatPs(codepoint);
 2873|      0|	    break;
 2874|      0|        case XML_REGEXP_PUNCT_CLOSE:
  ------------------
  |  Branch (2874:9): [True: 0, False: 4.62k]
  ------------------
 2875|      0|	    ret = xmlUCSIsCatPe(codepoint);
 2876|      0|	    break;
 2877|      0|        case XML_REGEXP_PUNCT_INITQUOTE:
  ------------------
  |  Branch (2877:9): [True: 0, False: 4.62k]
  ------------------
 2878|      0|	    ret = xmlUCSIsCatPi(codepoint);
 2879|      0|	    break;
 2880|      0|        case XML_REGEXP_PUNCT_FINQUOTE:
  ------------------
  |  Branch (2880:9): [True: 0, False: 4.62k]
  ------------------
 2881|      0|	    ret = xmlUCSIsCatPf(codepoint);
 2882|      0|	    break;
 2883|      0|        case XML_REGEXP_PUNCT_OTHERS:
  ------------------
  |  Branch (2883:9): [True: 0, False: 4.62k]
  ------------------
 2884|      0|	    ret = xmlUCSIsCatPo(codepoint);
 2885|      0|	    break;
 2886|      0|        case XML_REGEXP_SEPAR:
  ------------------
  |  Branch (2886:9): [True: 0, False: 4.62k]
  ------------------
 2887|      0|	    ret = xmlUCSIsCatZ(codepoint);
 2888|      0|	    break;
 2889|      0|        case XML_REGEXP_SEPAR_SPACE:
  ------------------
  |  Branch (2889:9): [True: 0, False: 4.62k]
  ------------------
 2890|      0|	    ret = xmlUCSIsCatZs(codepoint);
 2891|      0|	    break;
 2892|      0|        case XML_REGEXP_SEPAR_LINE:
  ------------------
  |  Branch (2892:9): [True: 0, False: 4.62k]
  ------------------
 2893|      0|	    ret = xmlUCSIsCatZl(codepoint);
 2894|      0|	    break;
 2895|      0|        case XML_REGEXP_SEPAR_PARA:
  ------------------
  |  Branch (2895:9): [True: 0, False: 4.62k]
  ------------------
 2896|      0|	    ret = xmlUCSIsCatZp(codepoint);
 2897|      0|	    break;
 2898|      0|        case XML_REGEXP_SYMBOL:
  ------------------
  |  Branch (2898:9): [True: 0, False: 4.62k]
  ------------------
 2899|      0|	    ret = xmlUCSIsCatS(codepoint);
 2900|      0|	    break;
 2901|      0|        case XML_REGEXP_SYMBOL_MATH:
  ------------------
  |  Branch (2901:9): [True: 0, False: 4.62k]
  ------------------
 2902|      0|	    ret = xmlUCSIsCatSm(codepoint);
 2903|      0|	    break;
 2904|      0|        case XML_REGEXP_SYMBOL_CURRENCY:
  ------------------
  |  Branch (2904:9): [True: 0, False: 4.62k]
  ------------------
 2905|      0|	    ret = xmlUCSIsCatSc(codepoint);
 2906|      0|	    break;
 2907|      0|        case XML_REGEXP_SYMBOL_MODIFIER:
  ------------------
  |  Branch (2907:9): [True: 0, False: 4.62k]
  ------------------
 2908|      0|	    ret = xmlUCSIsCatSk(codepoint);
 2909|      0|	    break;
 2910|      0|        case XML_REGEXP_SYMBOL_OTHERS:
  ------------------
  |  Branch (2910:9): [True: 0, False: 4.62k]
  ------------------
 2911|      0|	    ret = xmlUCSIsCatSo(codepoint);
 2912|      0|	    break;
 2913|      0|        case XML_REGEXP_OTHER:
  ------------------
  |  Branch (2913:9): [True: 0, False: 4.62k]
  ------------------
 2914|      0|	    ret = xmlUCSIsCatC(codepoint);
 2915|      0|	    break;
 2916|      0|        case XML_REGEXP_OTHER_CONTROL:
  ------------------
  |  Branch (2916:9): [True: 0, False: 4.62k]
  ------------------
 2917|      0|	    ret = xmlUCSIsCatCc(codepoint);
 2918|      0|	    break;
 2919|      0|        case XML_REGEXP_OTHER_FORMAT:
  ------------------
  |  Branch (2919:9): [True: 0, False: 4.62k]
  ------------------
 2920|      0|	    ret = xmlUCSIsCatCf(codepoint);
 2921|      0|	    break;
 2922|      0|        case XML_REGEXP_OTHER_PRIVATE:
  ------------------
  |  Branch (2922:9): [True: 0, False: 4.62k]
  ------------------
 2923|      0|	    ret = xmlUCSIsCatCo(codepoint);
 2924|      0|	    break;
 2925|      0|        case XML_REGEXP_OTHER_NA:
  ------------------
  |  Branch (2925:9): [True: 0, False: 4.62k]
  ------------------
 2926|       |	    /* ret = xmlUCSIsCatCn(codepoint); */
 2927|       |	    /* Seems it doesn't exist anymore in recent Unicode releases */
 2928|      0|	    ret = 0;
 2929|      0|	    break;
 2930|    169|        case XML_REGEXP_BLOCK_NAME:
  ------------------
  |  Branch (2930:9): [True: 169, False: 4.45k]
  ------------------
 2931|    169|	    ret = xmlUCSIsBlock(codepoint, (const char *) blockName);
 2932|    169|	    break;
 2933|  4.62k|    }
 2934|  4.62k|    if (neg)
  ------------------
  |  Branch (2934:9): [True: 0, False: 4.62k]
  ------------------
 2935|      0|	return(!ret);
 2936|  4.62k|    return(ret);
 2937|  4.62k|}
xmlregexp.c:xmlRegFreeState:
  906|  11.4k|xmlRegFreeState(xmlRegStatePtr state) {
  907|  11.4k|    if (state == NULL)
  ------------------
  |  Branch (907:9): [True: 2.19k, False: 9.28k]
  ------------------
  908|  2.19k|	return;
  909|       |
  910|  9.28k|    if (state->trans != NULL)
  ------------------
  |  Branch (910:9): [True: 8.85k, False: 433]
  ------------------
  911|  8.85k|	xmlFree(state->trans);
  912|  9.28k|    if (state->transTo != NULL)
  ------------------
  |  Branch (912:9): [True: 8.79k, False: 490]
  ------------------
  913|  8.79k|	xmlFree(state->transTo);
  914|  9.28k|    xmlFree(state);
  915|  9.28k|}
xmlregexp.c:xmlFAComputesDeterminism:
 2610|    153|xmlFAComputesDeterminism(xmlRegParserCtxtPtr ctxt) {
 2611|    153|    int statenr, transnr;
 2612|    153|    xmlRegStatePtr state;
 2613|    153|    xmlRegTransPtr t1, t2, last;
 2614|    153|    int i;
 2615|    153|    int ret = 1;
 2616|    153|    int deep = 1;
 2617|       |
 2618|    153|    if (ctxt->determinist != -1)
  ------------------
  |  Branch (2618:9): [True: 0, False: 153]
  ------------------
 2619|      0|	return(ctxt->determinist);
 2620|       |
 2621|    153|    if (ctxt->flags & AM_AUTOMATA_RNG)
  ------------------
  |  |  243|    153|#define AM_AUTOMATA_RNG 1
  ------------------
  |  Branch (2621:9): [True: 0, False: 153]
  ------------------
 2622|      0|        deep = 0;
 2623|       |
 2624|       |    /*
 2625|       |     * First cleanup the automata removing cancelled transitions
 2626|       |     */
 2627|  4.46k|    for (statenr = 0;statenr < ctxt->nbStates;statenr++) {
  ------------------
  |  Branch (2627:22): [True: 4.31k, False: 153]
  ------------------
 2628|  4.31k|	state = ctxt->states[statenr];
 2629|  4.31k|	if (state == NULL)
  ------------------
  |  Branch (2629:6): [True: 2.19k, False: 2.12k]
  ------------------
 2630|  2.19k|	    continue;
 2631|  2.12k|	if (state->nbTrans < 2)
  ------------------
  |  Branch (2631:6): [True: 924, False: 1.20k]
  ------------------
 2632|    924|	    continue;
 2633|  7.49k|	for (transnr = 0;transnr < state->nbTrans;transnr++) {
  ------------------
  |  Branch (2633:19): [True: 6.29k, False: 1.20k]
  ------------------
 2634|  6.29k|	    t1 = &(state->trans[transnr]);
 2635|       |	    /*
 2636|       |	     * Determinism checks in case of counted or all transitions
 2637|       |	     * will have to be handled separately
 2638|       |	     */
 2639|  6.29k|	    if (t1->atom == NULL) {
  ------------------
  |  Branch (2639:10): [True: 1.99k, False: 4.29k]
  ------------------
 2640|       |		/* t1->nd = 1; */
 2641|  1.99k|		continue;
 2642|  1.99k|	    }
 2643|  4.29k|	    if (t1->to < 0) /* eliminated */
  ------------------
  |  Branch (2643:10): [True: 857, False: 3.44k]
  ------------------
 2644|    857|		continue;
 2645|  15.8k|	    for (i = 0;i < transnr;i++) {
  ------------------
  |  Branch (2645:17): [True: 12.4k, False: 3.44k]
  ------------------
 2646|  12.4k|		t2 = &(state->trans[i]);
 2647|  12.4k|		if (t2->to < 0) /* eliminated */
  ------------------
  |  Branch (2647:7): [True: 7.48k, False: 4.92k]
  ------------------
 2648|  7.48k|		    continue;
 2649|  4.92k|		if (t2->atom != NULL) {
  ------------------
  |  Branch (2649:7): [True: 4.64k, False: 274]
  ------------------
 2650|  4.64k|		    if (t1->to == t2->to) {
  ------------------
  |  Branch (2650:11): [True: 728, False: 3.91k]
  ------------------
 2651|       |                        /*
 2652|       |                         * Here we use deep because we want to keep the
 2653|       |                         * transitions which indicate a conflict
 2654|       |                         */
 2655|    728|			if (xmlFAEqualAtoms(t1->atom, t2->atom, deep) &&
  ------------------
  |  Branch (2655:8): [True: 31, False: 697]
  ------------------
 2656|    728|                            (t1->counter == t2->counter) &&
  ------------------
  |  Branch (2656:29): [True: 0, False: 31]
  ------------------
 2657|    728|                            (t1->count == t2->count))
  ------------------
  |  Branch (2657:29): [True: 0, False: 0]
  ------------------
 2658|      0|			    t2->to = -1; /* eliminated */
 2659|    728|		    }
 2660|  4.64k|		}
 2661|  4.92k|	    }
 2662|  3.44k|	}
 2663|  1.20k|    }
 2664|       |
 2665|       |    /*
 2666|       |     * Check for all states that there aren't 2 transitions
 2667|       |     * with the same atom and a different target.
 2668|       |     */
 2669|  4.46k|    for (statenr = 0;statenr < ctxt->nbStates;statenr++) {
  ------------------
  |  Branch (2669:22): [True: 4.31k, False: 153]
  ------------------
 2670|  4.31k|	state = ctxt->states[statenr];
 2671|  4.31k|	if (state == NULL)
  ------------------
  |  Branch (2671:6): [True: 2.19k, False: 2.12k]
  ------------------
 2672|  2.19k|	    continue;
 2673|  2.12k|	if (state->nbTrans < 2)
  ------------------
  |  Branch (2673:6): [True: 924, False: 1.20k]
  ------------------
 2674|    924|	    continue;
 2675|  1.20k|	last = NULL;
 2676|  7.49k|	for (transnr = 0;transnr < state->nbTrans;transnr++) {
  ------------------
  |  Branch (2676:19): [True: 6.29k, False: 1.20k]
  ------------------
 2677|  6.29k|	    t1 = &(state->trans[transnr]);
 2678|       |	    /*
 2679|       |	     * Determinism checks in case of counted or all transitions
 2680|       |	     * will have to be handled separately
 2681|       |	     */
 2682|  6.29k|	    if (t1->atom == NULL) {
  ------------------
  |  Branch (2682:10): [True: 1.99k, False: 4.29k]
  ------------------
 2683|  1.99k|		continue;
 2684|  1.99k|	    }
 2685|  4.29k|	    if (t1->to < 0) /* eliminated */
  ------------------
  |  Branch (2685:10): [True: 857, False: 3.44k]
  ------------------
 2686|    857|		continue;
 2687|  15.8k|	    for (i = 0;i < transnr;i++) {
  ------------------
  |  Branch (2687:17): [True: 12.4k, False: 3.44k]
  ------------------
 2688|  12.4k|		t2 = &(state->trans[i]);
 2689|  12.4k|		if (t2->to < 0) /* eliminated */
  ------------------
  |  Branch (2689:7): [True: 7.48k, False: 4.92k]
  ------------------
 2690|  7.48k|		    continue;
 2691|  4.92k|		if (t2->atom != NULL) {
  ------------------
  |  Branch (2691:7): [True: 4.64k, False: 274]
  ------------------
 2692|       |                    /*
 2693|       |                     * But here we don't use deep because we want to
 2694|       |                     * find transitions which indicate a conflict
 2695|       |                     */
 2696|  4.64k|		    if (xmlFACompareAtoms(t1->atom, t2->atom, 1)) {
  ------------------
  |  Branch (2696:11): [True: 921, False: 3.72k]
  ------------------
 2697|       |                        /*
 2698|       |                         * Treat equal counter transitions that couldn't be
 2699|       |                         * eliminated as deterministic.
 2700|       |                         */
 2701|    921|                        if ((t1->to != t2->to) ||
  ------------------
  |  Branch (2701:29): [True: 869, False: 52]
  ------------------
 2702|    921|                            (t1->counter == t2->counter) ||
  ------------------
  |  Branch (2702:29): [True: 13, False: 39]
  ------------------
 2703|    921|                            (!xmlFAEqualAtoms(t1->atom, t2->atom, deep)))
  ------------------
  |  Branch (2703:29): [True: 8, False: 31]
  ------------------
 2704|    890|                            ret = 0;
 2705|       |			/* mark the transitions as non-deterministic ones */
 2706|    921|			t1->nd = 1;
 2707|    921|			t2->nd = 1;
 2708|    921|			last = t1;
 2709|    921|		    }
 2710|  4.64k|		} else {
 2711|    274|                    int res;
 2712|       |
 2713|       |		    /*
 2714|       |		     * do the closure in case of remaining specific
 2715|       |		     * epsilon transitions like choices or all
 2716|       |		     */
 2717|    274|		    res = xmlFARecurseDeterminism(ctxt, ctxt->states[t2->to],
 2718|    274|						  statenr, t1->to, t1->atom);
 2719|    274|                    xmlFAFinishRecurseDeterminism(ctxt, ctxt->states[t2->to]);
 2720|       |		    /* don't shortcut the computation so all non deterministic
 2721|       |		       transition get marked down
 2722|       |		    if (ret == 0)
 2723|       |			return(0);
 2724|       |		     */
 2725|    274|		    if (res == 0) {
  ------------------
  |  Branch (2725:11): [True: 84, False: 190]
  ------------------
 2726|     84|			t1->nd = 1;
 2727|       |			/* t2->nd = 1; */
 2728|     84|			last = t1;
 2729|     84|                        ret = 0;
 2730|     84|		    }
 2731|    274|		}
 2732|  4.92k|	    }
 2733|       |	    /* don't shortcut the computation so all non deterministic
 2734|       |	       transition get marked down
 2735|       |	    if (ret == 0)
 2736|       |		break; */
 2737|  3.44k|	}
 2738|       |
 2739|       |	/*
 2740|       |	 * mark specifically the last non-deterministic transition
 2741|       |	 * from a state since there is no need to set-up rollback
 2742|       |	 * from it
 2743|       |	 */
 2744|  1.20k|	if (last != NULL) {
  ------------------
  |  Branch (2744:6): [True: 586, False: 614]
  ------------------
 2745|    586|	    last->nd = 2;
 2746|    586|	}
 2747|       |
 2748|       |	/* don't shortcut the computation so all non deterministic
 2749|       |	   transition get marked down
 2750|       |	if (ret == 0)
 2751|       |	    break; */
 2752|  1.20k|    }
 2753|       |
 2754|    153|    ctxt->determinist = ret;
 2755|    153|    return(ret);
 2756|    153|}
xmlregexp.c:xmlFAEqualAtoms:
 2386|    863|xmlFAEqualAtoms(xmlRegAtomPtr atom1, xmlRegAtomPtr atom2, int deep) {
 2387|    863|    int ret = 0;
 2388|       |
 2389|    863|    if (atom1 == atom2)
  ------------------
  |  Branch (2389:9): [True: 158, False: 705]
  ------------------
 2390|    158|	return(1);
 2391|    705|    if ((atom1 == NULL) || (atom2 == NULL))
  ------------------
  |  Branch (2391:9): [True: 0, False: 705]
  |  Branch (2391:28): [True: 0, False: 705]
  ------------------
 2392|      0|	return(0);
 2393|       |
 2394|    705|    if (atom1->type != atom2->type)
  ------------------
  |  Branch (2394:9): [True: 39, False: 666]
  ------------------
 2395|     39|        return(0);
 2396|    666|    switch (atom1->type) {
 2397|      0|        case XML_REGEXP_EPSILON:
  ------------------
  |  Branch (2397:9): [True: 0, False: 666]
  ------------------
 2398|      0|	    ret = 0;
 2399|      0|	    break;
 2400|      0|        case XML_REGEXP_STRING:
  ------------------
  |  Branch (2400:9): [True: 0, False: 666]
  ------------------
 2401|      0|            if (!deep)
  ------------------
  |  Branch (2401:17): [True: 0, False: 0]
  ------------------
 2402|      0|                ret = (atom1->valuep == atom2->valuep);
 2403|      0|            else
 2404|      0|                ret = xmlStrEqual((xmlChar *)atom1->valuep,
 2405|      0|                                  (xmlChar *)atom2->valuep);
 2406|      0|	    break;
 2407|    638|        case XML_REGEXP_CHARVAL:
  ------------------
  |  Branch (2407:9): [True: 638, False: 28]
  ------------------
 2408|    638|	    ret = (atom1->codepoint == atom2->codepoint);
 2409|    638|	    break;
 2410|     28|	case XML_REGEXP_RANGES:
  ------------------
  |  Branch (2410:2): [True: 28, False: 638]
  ------------------
 2411|       |	    /* too hard to do in the general case */
 2412|     28|	    ret = 0;
 2413|     28|	default:
  ------------------
  |  Branch (2413:2): [True: 0, False: 666]
  ------------------
 2414|     28|	    break;
 2415|    666|    }
 2416|    666|    return(ret);
 2417|    666|}
xmlregexp.c:xmlFACompareAtoms:
 2431|  5.47k|xmlFACompareAtoms(xmlRegAtomPtr atom1, xmlRegAtomPtr atom2, int deep) {
 2432|  5.47k|    int ret = 1;
 2433|       |
 2434|  5.47k|    if (atom1 == atom2)
  ------------------
  |  Branch (2434:9): [True: 127, False: 5.34k]
  ------------------
 2435|    127|	return(1);
 2436|  5.34k|    if ((atom1 == NULL) || (atom2 == NULL))
  ------------------
  |  Branch (2436:9): [True: 0, False: 5.34k]
  |  Branch (2436:28): [True: 0, False: 5.34k]
  ------------------
 2437|      0|	return(0);
 2438|       |
 2439|  5.34k|    if ((atom1->type == XML_REGEXP_ANYCHAR) ||
  ------------------
  |  Branch (2439:9): [True: 2, False: 5.34k]
  ------------------
 2440|  5.34k|        (atom2->type == XML_REGEXP_ANYCHAR))
  ------------------
  |  Branch (2440:9): [True: 0, False: 5.34k]
  ------------------
 2441|      2|	return(1);
 2442|       |
 2443|  5.34k|    if (atom1->type > atom2->type) {
  ------------------
  |  Branch (2443:9): [True: 1.01k, False: 4.33k]
  ------------------
 2444|  1.01k|	xmlRegAtomPtr tmp;
 2445|  1.01k|	tmp = atom1;
 2446|  1.01k|	atom1 = atom2;
 2447|  1.01k|	atom2 = tmp;
 2448|  1.01k|    }
 2449|  5.34k|    if (atom1->type != atom2->type) {
  ------------------
  |  Branch (2449:9): [True: 2.60k, False: 2.74k]
  ------------------
 2450|  2.60k|        ret = xmlFACompareAtomTypes(atom1->type, atom2->type);
 2451|       |	/* if they can't intersect at the type level break now */
 2452|  2.60k|	if (ret == 0)
  ------------------
  |  Branch (2452:6): [True: 0, False: 2.60k]
  ------------------
 2453|      0|	    return(0);
 2454|  2.60k|    }
 2455|  5.34k|    switch (atom1->type) {
 2456|      0|        case XML_REGEXP_STRING:
  ------------------
  |  Branch (2456:9): [True: 0, False: 5.34k]
  ------------------
 2457|      0|            if (!deep)
  ------------------
  |  Branch (2457:17): [True: 0, False: 0]
  ------------------
 2458|      0|                ret = (atom1->valuep != atom2->valuep);
 2459|      0|            else {
 2460|      0|                xmlChar *val1 = (xmlChar *)atom1->valuep;
 2461|      0|                xmlChar *val2 = (xmlChar *)atom2->valuep;
 2462|      0|                int compound1 = (xmlStrchr(val1, '|') != NULL);
 2463|      0|                int compound2 = (xmlStrchr(val2, '|') != NULL);
 2464|       |
 2465|       |                /* Ignore negative match flag for ##other namespaces */
 2466|      0|                if (compound1 != compound2)
  ------------------
  |  Branch (2466:21): [True: 0, False: 0]
  ------------------
 2467|      0|                    return(0);
 2468|       |
 2469|      0|                ret = xmlRegStrEqualWildcard(val1, val2);
 2470|      0|            }
 2471|      0|	    break;
 2472|      0|        case XML_REGEXP_EPSILON:
  ------------------
  |  Branch (2472:9): [True: 0, False: 5.34k]
  ------------------
 2473|      0|	    goto not_determinist;
 2474|  4.78k|        case XML_REGEXP_CHARVAL:
  ------------------
  |  Branch (2474:9): [True: 4.78k, False: 559]
  ------------------
 2475|  4.78k|	    if (atom2->type == XML_REGEXP_CHARVAL) {
  ------------------
  |  Branch (2475:10): [True: 2.23k, False: 2.54k]
  ------------------
 2476|  2.23k|		ret = (atom1->codepoint == atom2->codepoint);
 2477|  2.54k|	    } else {
 2478|  2.54k|	        ret = xmlRegCheckCharacter(atom2, atom1->codepoint);
 2479|  2.54k|		if (ret < 0)
  ------------------
  |  Branch (2479:7): [True: 15, False: 2.53k]
  ------------------
 2480|     15|		    ret = 1;
 2481|  2.54k|	    }
 2482|  4.78k|	    break;
 2483|    351|        case XML_REGEXP_RANGES:
  ------------------
  |  Branch (2483:9): [True: 351, False: 4.99k]
  ------------------
 2484|    351|	    if (atom2->type == XML_REGEXP_RANGES) {
  ------------------
  |  Branch (2484:10): [True: 315, False: 36]
  ------------------
 2485|    315|	        int i, j, res;
 2486|    315|		xmlRegRangePtr r1, r2;
 2487|       |
 2488|       |		/*
 2489|       |		 * need to check that none of the ranges eventually matches
 2490|       |		 */
 2491|    539|		for (i = 0;i < atom1->nbRanges;i++) {
  ------------------
  |  Branch (2491:14): [True: 330, False: 209]
  ------------------
 2492|    564|		    for (j = 0;j < atom2->nbRanges;j++) {
  ------------------
  |  Branch (2492:18): [True: 340, False: 224]
  ------------------
 2493|    340|			r1 = atom1->ranges[i];
 2494|    340|			r2 = atom2->ranges[j];
 2495|    340|			res = xmlFACompareRanges(r1, r2);
 2496|    340|			if (res == 1) {
  ------------------
  |  Branch (2496:8): [True: 106, False: 234]
  ------------------
 2497|    106|			    ret = 1;
 2498|    106|			    goto done;
 2499|    106|			}
 2500|    340|		    }
 2501|    330|		}
 2502|    209|		ret = 0;
 2503|    209|	    }
 2504|    245|	    break;
 2505|    245|	default:
  ------------------
  |  Branch (2505:2): [True: 208, False: 5.13k]
  ------------------
 2506|    208|	    goto not_determinist;
 2507|  5.34k|    }
 2508|  5.13k|done:
 2509|  5.13k|    if (atom1->neg != atom2->neg) {
  ------------------
  |  Branch (2509:9): [True: 0, False: 5.13k]
  ------------------
 2510|      0|        ret = !ret;
 2511|      0|    }
 2512|  5.13k|    if (ret == 0)
  ------------------
  |  Branch (2512:9): [True: 4.36k, False: 771]
  ------------------
 2513|  4.36k|        return(0);
 2514|    979|not_determinist:
 2515|    979|    return(1);
 2516|  5.13k|}
xmlregexp.c:xmlFACompareAtomTypes:
 2184|  2.60k|xmlFACompareAtomTypes(xmlRegAtomType type1, xmlRegAtomType type2) {
 2185|  2.60k|    if ((type1 == XML_REGEXP_EPSILON) ||
  ------------------
  |  Branch (2185:9): [True: 0, False: 2.60k]
  ------------------
 2186|  2.60k|        (type1 == XML_REGEXP_CHARVAL) ||
  ------------------
  |  Branch (2186:9): [True: 2.54k, False: 52]
  ------------------
 2187|  2.60k|	(type1 == XML_REGEXP_RANGES) ||
  ------------------
  |  Branch (2187:2): [True: 36, False: 16]
  ------------------
 2188|  2.60k|	(type1 == XML_REGEXP_SUBREG) ||
  ------------------
  |  Branch (2188:2): [True: 0, False: 16]
  ------------------
 2189|  2.60k|	(type1 == XML_REGEXP_STRING) ||
  ------------------
  |  Branch (2189:2): [True: 0, False: 16]
  ------------------
 2190|  2.60k|	(type1 == XML_REGEXP_ANYCHAR))
  ------------------
  |  Branch (2190:2): [True: 0, False: 16]
  ------------------
 2191|  2.58k|	return(1);
 2192|     16|    if ((type2 == XML_REGEXP_EPSILON) ||
  ------------------
  |  Branch (2192:9): [True: 0, False: 16]
  ------------------
 2193|     16|        (type2 == XML_REGEXP_CHARVAL) ||
  ------------------
  |  Branch (2193:9): [True: 0, False: 16]
  ------------------
 2194|     16|	(type2 == XML_REGEXP_RANGES) ||
  ------------------
  |  Branch (2194:2): [True: 0, False: 16]
  ------------------
 2195|     16|	(type2 == XML_REGEXP_SUBREG) ||
  ------------------
  |  Branch (2195:2): [True: 0, False: 16]
  ------------------
 2196|     16|	(type2 == XML_REGEXP_STRING) ||
  ------------------
  |  Branch (2196:2): [True: 0, False: 16]
  ------------------
 2197|     16|	(type2 == XML_REGEXP_ANYCHAR))
  ------------------
  |  Branch (2197:2): [True: 0, False: 16]
  ------------------
 2198|      0|	return(1);
 2199|       |
 2200|     16|    if (type1 == type2) return(1);
  ------------------
  |  Branch (2200:9): [True: 0, False: 16]
  ------------------
 2201|       |
 2202|       |    /* simplify subsequent compares by making sure type1 < type2 */
 2203|     16|    if (type1 > type2) {
  ------------------
  |  Branch (2203:9): [True: 0, False: 16]
  ------------------
 2204|      0|        xmlRegAtomType tmp = type1;
 2205|      0|	type1 = type2;
 2206|      0|	type2 = tmp;
 2207|      0|    }
 2208|     16|    switch (type1) {
 2209|      0|        case XML_REGEXP_ANYSPACE: /* \s */
  ------------------
  |  Branch (2209:9): [True: 0, False: 16]
  ------------------
 2210|       |	    /* can't be a letter, number, mark, punctuation, symbol */
 2211|      0|	    if ((type2 == XML_REGEXP_NOTSPACE) ||
  ------------------
  |  Branch (2211:10): [True: 0, False: 0]
  ------------------
 2212|      0|		((type2 >= XML_REGEXP_LETTER) &&
  ------------------
  |  Branch (2212:4): [True: 0, False: 0]
  ------------------
 2213|      0|		 (type2 <= XML_REGEXP_LETTER_OTHERS)) ||
  ------------------
  |  Branch (2213:4): [True: 0, False: 0]
  ------------------
 2214|      0|	        ((type2 >= XML_REGEXP_NUMBER) &&
  ------------------
  |  Branch (2214:11): [True: 0, False: 0]
  ------------------
 2215|      0|		 (type2 <= XML_REGEXP_NUMBER_OTHERS)) ||
  ------------------
  |  Branch (2215:4): [True: 0, False: 0]
  ------------------
 2216|      0|	        ((type2 >= XML_REGEXP_MARK) &&
  ------------------
  |  Branch (2216:11): [True: 0, False: 0]
  ------------------
 2217|      0|		 (type2 <= XML_REGEXP_MARK_ENCLOSING)) ||
  ------------------
  |  Branch (2217:4): [True: 0, False: 0]
  ------------------
 2218|      0|	        ((type2 >= XML_REGEXP_PUNCT) &&
  ------------------
  |  Branch (2218:11): [True: 0, False: 0]
  ------------------
 2219|      0|		 (type2 <= XML_REGEXP_PUNCT_OTHERS)) ||
  ------------------
  |  Branch (2219:4): [True: 0, False: 0]
  ------------------
 2220|      0|	        ((type2 >= XML_REGEXP_SYMBOL) &&
  ------------------
  |  Branch (2220:11): [True: 0, False: 0]
  ------------------
 2221|      0|		 (type2 <= XML_REGEXP_SYMBOL_OTHERS))
  ------------------
  |  Branch (2221:4): [True: 0, False: 0]
  ------------------
 2222|      0|	        ) return(0);
 2223|      0|	    break;
 2224|      0|        case XML_REGEXP_NOTSPACE: /* \S */
  ------------------
  |  Branch (2224:9): [True: 0, False: 16]
  ------------------
 2225|      0|	    break;
 2226|     14|        case XML_REGEXP_INITNAME: /* \l */
  ------------------
  |  Branch (2226:9): [True: 14, False: 2]
  ------------------
 2227|       |	    /* can't be a number, mark, separator, punctuation, symbol or other */
 2228|     14|	    if ((type2 == XML_REGEXP_NOTINITNAME) ||
  ------------------
  |  Branch (2228:10): [True: 0, False: 14]
  ------------------
 2229|     14|	        ((type2 >= XML_REGEXP_NUMBER) &&
  ------------------
  |  Branch (2229:11): [True: 0, False: 14]
  ------------------
 2230|     14|		 (type2 <= XML_REGEXP_NUMBER_OTHERS)) ||
  ------------------
  |  Branch (2230:4): [True: 0, False: 0]
  ------------------
 2231|     14|	        ((type2 >= XML_REGEXP_MARK) &&
  ------------------
  |  Branch (2231:11): [True: 0, False: 14]
  ------------------
 2232|     14|		 (type2 <= XML_REGEXP_MARK_ENCLOSING)) ||
  ------------------
  |  Branch (2232:4): [True: 0, False: 0]
  ------------------
 2233|     14|	        ((type2 >= XML_REGEXP_SEPAR) &&
  ------------------
  |  Branch (2233:11): [True: 0, False: 14]
  ------------------
 2234|     14|		 (type2 <= XML_REGEXP_SEPAR_PARA)) ||
  ------------------
  |  Branch (2234:4): [True: 0, False: 0]
  ------------------
 2235|     14|	        ((type2 >= XML_REGEXP_PUNCT) &&
  ------------------
  |  Branch (2235:11): [True: 0, False: 14]
  ------------------
 2236|     14|		 (type2 <= XML_REGEXP_PUNCT_OTHERS)) ||
  ------------------
  |  Branch (2236:4): [True: 0, False: 0]
  ------------------
 2237|     14|	        ((type2 >= XML_REGEXP_SYMBOL) &&
  ------------------
  |  Branch (2237:11): [True: 0, False: 14]
  ------------------
 2238|     14|		 (type2 <= XML_REGEXP_SYMBOL_OTHERS)) ||
  ------------------
  |  Branch (2238:4): [True: 0, False: 0]
  ------------------
 2239|     14|	        ((type2 >= XML_REGEXP_OTHER) &&
  ------------------
  |  Branch (2239:11): [True: 0, False: 14]
  ------------------
 2240|     14|		 (type2 <= XML_REGEXP_OTHER_NA))
  ------------------
  |  Branch (2240:4): [True: 0, False: 0]
  ------------------
 2241|     14|		) return(0);
 2242|     14|	    break;
 2243|     14|        case XML_REGEXP_NOTINITNAME: /* \L */
  ------------------
  |  Branch (2243:9): [True: 0, False: 16]
  ------------------
 2244|      0|	    break;
 2245|      2|        case XML_REGEXP_NAMECHAR: /* \c */
  ------------------
  |  Branch (2245:9): [True: 2, False: 14]
  ------------------
 2246|       |	    /* can't be a mark, separator, punctuation, symbol or other */
 2247|      2|	    if ((type2 == XML_REGEXP_NOTNAMECHAR) ||
  ------------------
  |  Branch (2247:10): [True: 0, False: 2]
  ------------------
 2248|      2|	        ((type2 >= XML_REGEXP_MARK) &&
  ------------------
  |  Branch (2248:11): [True: 2, False: 0]
  ------------------
 2249|      2|		 (type2 <= XML_REGEXP_MARK_ENCLOSING)) ||
  ------------------
  |  Branch (2249:4): [True: 0, False: 2]
  ------------------
 2250|      2|	        ((type2 >= XML_REGEXP_PUNCT) &&
  ------------------
  |  Branch (2250:11): [True: 2, False: 0]
  ------------------
 2251|      2|		 (type2 <= XML_REGEXP_PUNCT_OTHERS)) ||
  ------------------
  |  Branch (2251:4): [True: 0, False: 2]
  ------------------
 2252|      2|	        ((type2 >= XML_REGEXP_SEPAR) &&
  ------------------
  |  Branch (2252:11): [True: 2, False: 0]
  ------------------
 2253|      2|		 (type2 <= XML_REGEXP_SEPAR_PARA)) ||
  ------------------
  |  Branch (2253:4): [True: 0, False: 2]
  ------------------
 2254|      2|	        ((type2 >= XML_REGEXP_SYMBOL) &&
  ------------------
  |  Branch (2254:11): [True: 2, False: 0]
  ------------------
 2255|      2|		 (type2 <= XML_REGEXP_SYMBOL_OTHERS)) ||
  ------------------
  |  Branch (2255:4): [True: 0, False: 2]
  ------------------
 2256|      2|	        ((type2 >= XML_REGEXP_OTHER) &&
  ------------------
  |  Branch (2256:11): [True: 2, False: 0]
  ------------------
 2257|      2|		 (type2 <= XML_REGEXP_OTHER_NA))
  ------------------
  |  Branch (2257:4): [True: 0, False: 2]
  ------------------
 2258|      2|		) return(0);
 2259|      2|	    break;
 2260|      2|        case XML_REGEXP_NOTNAMECHAR: /* \C */
  ------------------
  |  Branch (2260:9): [True: 0, False: 16]
  ------------------
 2261|      0|	    break;
 2262|      0|        case XML_REGEXP_DECIMAL: /* \d */
  ------------------
  |  Branch (2262:9): [True: 0, False: 16]
  ------------------
 2263|       |	    /* can't be a letter, mark, separator, punctuation, symbol or other */
 2264|      0|	    if ((type2 == XML_REGEXP_NOTDECIMAL) ||
  ------------------
  |  Branch (2264:10): [True: 0, False: 0]
  ------------------
 2265|      0|	        (type2 == XML_REGEXP_REALCHAR) ||
  ------------------
  |  Branch (2265:10): [True: 0, False: 0]
  ------------------
 2266|      0|		((type2 >= XML_REGEXP_LETTER) &&
  ------------------
  |  Branch (2266:4): [True: 0, False: 0]
  ------------------
 2267|      0|		 (type2 <= XML_REGEXP_LETTER_OTHERS)) ||
  ------------------
  |  Branch (2267:4): [True: 0, False: 0]
  ------------------
 2268|      0|	        ((type2 >= XML_REGEXP_MARK) &&
  ------------------
  |  Branch (2268:11): [True: 0, False: 0]
  ------------------
 2269|      0|		 (type2 <= XML_REGEXP_MARK_ENCLOSING)) ||
  ------------------
  |  Branch (2269:4): [True: 0, False: 0]
  ------------------
 2270|      0|	        ((type2 >= XML_REGEXP_PUNCT) &&
  ------------------
  |  Branch (2270:11): [True: 0, False: 0]
  ------------------
 2271|      0|		 (type2 <= XML_REGEXP_PUNCT_OTHERS)) ||
  ------------------
  |  Branch (2271:4): [True: 0, False: 0]
  ------------------
 2272|      0|	        ((type2 >= XML_REGEXP_SEPAR) &&
  ------------------
  |  Branch (2272:11): [True: 0, False: 0]
  ------------------
 2273|      0|		 (type2 <= XML_REGEXP_SEPAR_PARA)) ||
  ------------------
  |  Branch (2273:4): [True: 0, False: 0]
  ------------------
 2274|      0|	        ((type2 >= XML_REGEXP_SYMBOL) &&
  ------------------
  |  Branch (2274:11): [True: 0, False: 0]
  ------------------
 2275|      0|		 (type2 <= XML_REGEXP_SYMBOL_OTHERS)) ||
  ------------------
  |  Branch (2275:4): [True: 0, False: 0]
  ------------------
 2276|      0|	        ((type2 >= XML_REGEXP_OTHER) &&
  ------------------
  |  Branch (2276:11): [True: 0, False: 0]
  ------------------
 2277|      0|		 (type2 <= XML_REGEXP_OTHER_NA))
  ------------------
  |  Branch (2277:4): [True: 0, False: 0]
  ------------------
 2278|      0|		)return(0);
 2279|      0|	    break;
 2280|      0|        case XML_REGEXP_NOTDECIMAL: /* \D */
  ------------------
  |  Branch (2280:9): [True: 0, False: 16]
  ------------------
 2281|      0|	    break;
 2282|      0|        case XML_REGEXP_REALCHAR: /* \w */
  ------------------
  |  Branch (2282:9): [True: 0, False: 16]
  ------------------
 2283|       |	    /* can't be a mark, separator, punctuation, symbol or other */
 2284|      0|	    if ((type2 == XML_REGEXP_NOTDECIMAL) ||
  ------------------
  |  Branch (2284:10): [True: 0, False: 0]
  ------------------
 2285|      0|	        ((type2 >= XML_REGEXP_MARK) &&
  ------------------
  |  Branch (2285:11): [True: 0, False: 0]
  ------------------
 2286|      0|		 (type2 <= XML_REGEXP_MARK_ENCLOSING)) ||
  ------------------
  |  Branch (2286:4): [True: 0, False: 0]
  ------------------
 2287|      0|	        ((type2 >= XML_REGEXP_PUNCT) &&
  ------------------
  |  Branch (2287:11): [True: 0, False: 0]
  ------------------
 2288|      0|		 (type2 <= XML_REGEXP_PUNCT_OTHERS)) ||
  ------------------
  |  Branch (2288:4): [True: 0, False: 0]
  ------------------
 2289|      0|	        ((type2 >= XML_REGEXP_SEPAR) &&
  ------------------
  |  Branch (2289:11): [True: 0, False: 0]
  ------------------
 2290|      0|		 (type2 <= XML_REGEXP_SEPAR_PARA)) ||
  ------------------
  |  Branch (2290:4): [True: 0, False: 0]
  ------------------
 2291|      0|	        ((type2 >= XML_REGEXP_SYMBOL) &&
  ------------------
  |  Branch (2291:11): [True: 0, False: 0]
  ------------------
 2292|      0|		 (type2 <= XML_REGEXP_SYMBOL_OTHERS)) ||
  ------------------
  |  Branch (2292:4): [True: 0, False: 0]
  ------------------
 2293|      0|	        ((type2 >= XML_REGEXP_OTHER) &&
  ------------------
  |  Branch (2293:11): [True: 0, False: 0]
  ------------------
 2294|      0|		 (type2 <= XML_REGEXP_OTHER_NA))
  ------------------
  |  Branch (2294:4): [True: 0, False: 0]
  ------------------
 2295|      0|		)return(0);
 2296|      0|	    break;
 2297|      0|        case XML_REGEXP_NOTREALCHAR: /* \W */
  ------------------
  |  Branch (2297:9): [True: 0, False: 16]
  ------------------
 2298|      0|	    break;
 2299|       |	/*
 2300|       |	 * at that point we know both type 1 and type2 are from
 2301|       |	 * character categories are ordered and are different,
 2302|       |	 * it becomes simple because this is a partition
 2303|       |	 */
 2304|      0|        case XML_REGEXP_LETTER:
  ------------------
  |  Branch (2304:9): [True: 0, False: 16]
  ------------------
 2305|      0|	    if (type2 <= XML_REGEXP_LETTER_OTHERS)
  ------------------
  |  Branch (2305:10): [True: 0, False: 0]
  ------------------
 2306|      0|	        return(1);
 2307|      0|	    return(0);
 2308|      0|        case XML_REGEXP_LETTER_UPPERCASE:
  ------------------
  |  Branch (2308:9): [True: 0, False: 16]
  ------------------
 2309|      0|        case XML_REGEXP_LETTER_LOWERCASE:
  ------------------
  |  Branch (2309:9): [True: 0, False: 16]
  ------------------
 2310|      0|        case XML_REGEXP_LETTER_TITLECASE:
  ------------------
  |  Branch (2310:9): [True: 0, False: 16]
  ------------------
 2311|      0|        case XML_REGEXP_LETTER_MODIFIER:
  ------------------
  |  Branch (2311:9): [True: 0, False: 16]
  ------------------
 2312|      0|        case XML_REGEXP_LETTER_OTHERS:
  ------------------
  |  Branch (2312:9): [True: 0, False: 16]
  ------------------
 2313|      0|	    return(0);
 2314|      0|        case XML_REGEXP_MARK:
  ------------------
  |  Branch (2314:9): [True: 0, False: 16]
  ------------------
 2315|      0|	    if (type2 <= XML_REGEXP_MARK_ENCLOSING)
  ------------------
  |  Branch (2315:10): [True: 0, False: 0]
  ------------------
 2316|      0|	        return(1);
 2317|      0|	    return(0);
 2318|      0|        case XML_REGEXP_MARK_NONSPACING:
  ------------------
  |  Branch (2318:9): [True: 0, False: 16]
  ------------------
 2319|      0|        case XML_REGEXP_MARK_SPACECOMBINING:
  ------------------
  |  Branch (2319:9): [True: 0, False: 16]
  ------------------
 2320|      0|        case XML_REGEXP_MARK_ENCLOSING:
  ------------------
  |  Branch (2320:9): [True: 0, False: 16]
  ------------------
 2321|      0|	    return(0);
 2322|      0|        case XML_REGEXP_NUMBER:
  ------------------
  |  Branch (2322:9): [True: 0, False: 16]
  ------------------
 2323|      0|	    if (type2 <= XML_REGEXP_NUMBER_OTHERS)
  ------------------
  |  Branch (2323:10): [True: 0, False: 0]
  ------------------
 2324|      0|	        return(1);
 2325|      0|	    return(0);
 2326|      0|        case XML_REGEXP_NUMBER_DECIMAL:
  ------------------
  |  Branch (2326:9): [True: 0, False: 16]
  ------------------
 2327|      0|        case XML_REGEXP_NUMBER_LETTER:
  ------------------
  |  Branch (2327:9): [True: 0, False: 16]
  ------------------
 2328|      0|        case XML_REGEXP_NUMBER_OTHERS:
  ------------------
  |  Branch (2328:9): [True: 0, False: 16]
  ------------------
 2329|      0|	    return(0);
 2330|      0|        case XML_REGEXP_PUNCT:
  ------------------
  |  Branch (2330:9): [True: 0, False: 16]
  ------------------
 2331|      0|	    if (type2 <= XML_REGEXP_PUNCT_OTHERS)
  ------------------
  |  Branch (2331:10): [True: 0, False: 0]
  ------------------
 2332|      0|	        return(1);
 2333|      0|	    return(0);
 2334|      0|        case XML_REGEXP_PUNCT_CONNECTOR:
  ------------------
  |  Branch (2334:9): [True: 0, False: 16]
  ------------------
 2335|      0|        case XML_REGEXP_PUNCT_DASH:
  ------------------
  |  Branch (2335:9): [True: 0, False: 16]
  ------------------
 2336|      0|        case XML_REGEXP_PUNCT_OPEN:
  ------------------
  |  Branch (2336:9): [True: 0, False: 16]
  ------------------
 2337|      0|        case XML_REGEXP_PUNCT_CLOSE:
  ------------------
  |  Branch (2337:9): [True: 0, False: 16]
  ------------------
 2338|      0|        case XML_REGEXP_PUNCT_INITQUOTE:
  ------------------
  |  Branch (2338:9): [True: 0, False: 16]
  ------------------
 2339|      0|        case XML_REGEXP_PUNCT_FINQUOTE:
  ------------------
  |  Branch (2339:9): [True: 0, False: 16]
  ------------------
 2340|      0|        case XML_REGEXP_PUNCT_OTHERS:
  ------------------
  |  Branch (2340:9): [True: 0, False: 16]
  ------------------
 2341|      0|	    return(0);
 2342|      0|        case XML_REGEXP_SEPAR:
  ------------------
  |  Branch (2342:9): [True: 0, False: 16]
  ------------------
 2343|      0|	    if (type2 <= XML_REGEXP_SEPAR_PARA)
  ------------------
  |  Branch (2343:10): [True: 0, False: 0]
  ------------------
 2344|      0|	        return(1);
 2345|      0|	    return(0);
 2346|      0|        case XML_REGEXP_SEPAR_SPACE:
  ------------------
  |  Branch (2346:9): [True: 0, False: 16]
  ------------------
 2347|      0|        case XML_REGEXP_SEPAR_LINE:
  ------------------
  |  Branch (2347:9): [True: 0, False: 16]
  ------------------
 2348|      0|        case XML_REGEXP_SEPAR_PARA:
  ------------------
  |  Branch (2348:9): [True: 0, False: 16]
  ------------------
 2349|      0|	    return(0);
 2350|      0|        case XML_REGEXP_SYMBOL:
  ------------------
  |  Branch (2350:9): [True: 0, False: 16]
  ------------------
 2351|      0|	    if (type2 <= XML_REGEXP_SYMBOL_OTHERS)
  ------------------
  |  Branch (2351:10): [True: 0, False: 0]
  ------------------
 2352|      0|	        return(1);
 2353|      0|	    return(0);
 2354|      0|        case XML_REGEXP_SYMBOL_MATH:
  ------------------
  |  Branch (2354:9): [True: 0, False: 16]
  ------------------
 2355|      0|        case XML_REGEXP_SYMBOL_CURRENCY:
  ------------------
  |  Branch (2355:9): [True: 0, False: 16]
  ------------------
 2356|      0|        case XML_REGEXP_SYMBOL_MODIFIER:
  ------------------
  |  Branch (2356:9): [True: 0, False: 16]
  ------------------
 2357|      0|        case XML_REGEXP_SYMBOL_OTHERS:
  ------------------
  |  Branch (2357:9): [True: 0, False: 16]
  ------------------
 2358|      0|	    return(0);
 2359|      0|        case XML_REGEXP_OTHER:
  ------------------
  |  Branch (2359:9): [True: 0, False: 16]
  ------------------
 2360|      0|	    if (type2 <= XML_REGEXP_OTHER_NA)
  ------------------
  |  Branch (2360:10): [True: 0, False: 0]
  ------------------
 2361|      0|	        return(1);
 2362|      0|	    return(0);
 2363|      0|        case XML_REGEXP_OTHER_CONTROL:
  ------------------
  |  Branch (2363:9): [True: 0, False: 16]
  ------------------
 2364|      0|        case XML_REGEXP_OTHER_FORMAT:
  ------------------
  |  Branch (2364:9): [True: 0, False: 16]
  ------------------
 2365|      0|        case XML_REGEXP_OTHER_PRIVATE:
  ------------------
  |  Branch (2365:9): [True: 0, False: 16]
  ------------------
 2366|      0|        case XML_REGEXP_OTHER_NA:
  ------------------
  |  Branch (2366:9): [True: 0, False: 16]
  ------------------
 2367|      0|	    return(0);
 2368|      0|	default:
  ------------------
  |  Branch (2368:2): [True: 0, False: 16]
  ------------------
 2369|      0|	    break;
 2370|     16|    }
 2371|     16|    return(1);
 2372|     16|}
xmlregexp.c:xmlFACompareRanges:
 2011|    340|xmlFACompareRanges(xmlRegRangePtr range1, xmlRegRangePtr range2) {
 2012|    340|    int ret = 0;
 2013|       |
 2014|    340|    if ((range1->type == XML_REGEXP_RANGES) ||
  ------------------
  |  Branch (2014:9): [True: 0, False: 340]
  ------------------
 2015|    340|        (range2->type == XML_REGEXP_RANGES) ||
  ------------------
  |  Branch (2015:9): [True: 0, False: 340]
  ------------------
 2016|    340|        (range2->type == XML_REGEXP_SUBREG) ||
  ------------------
  |  Branch (2016:9): [True: 0, False: 340]
  ------------------
 2017|    340|        (range1->type == XML_REGEXP_SUBREG) ||
  ------------------
  |  Branch (2017:9): [True: 0, False: 340]
  ------------------
 2018|    340|        (range1->type == XML_REGEXP_STRING) ||
  ------------------
  |  Branch (2018:9): [True: 0, False: 340]
  ------------------
 2019|    340|        (range2->type == XML_REGEXP_STRING))
  ------------------
  |  Branch (2019:9): [True: 0, False: 340]
  ------------------
 2020|      0|	return(-1);
 2021|       |
 2022|       |    /* put them in order */
 2023|    340|    if (range1->type > range2->type) {
  ------------------
  |  Branch (2023:9): [True: 121, False: 219]
  ------------------
 2024|    121|        xmlRegRangePtr tmp;
 2025|       |
 2026|    121|	tmp = range1;
 2027|    121|	range1 = range2;
 2028|    121|	range2 = tmp;
 2029|    121|    }
 2030|    340|    if ((range1->type == XML_REGEXP_ANYCHAR) ||
  ------------------
  |  Branch (2030:9): [True: 0, False: 340]
  ------------------
 2031|    340|        (range2->type == XML_REGEXP_ANYCHAR)) {
  ------------------
  |  Branch (2031:9): [True: 0, False: 340]
  ------------------
 2032|      0|	ret = 1;
 2033|    340|    } else if ((range1->type == XML_REGEXP_EPSILON) ||
  ------------------
  |  Branch (2033:16): [True: 0, False: 340]
  ------------------
 2034|    340|               (range2->type == XML_REGEXP_EPSILON)) {
  ------------------
  |  Branch (2034:16): [True: 0, False: 340]
  ------------------
 2035|      0|	return(0);
 2036|    340|    } else if (range1->type == range2->type) {
  ------------------
  |  Branch (2036:16): [True: 111, False: 229]
  ------------------
 2037|    111|        if (range1->type != XML_REGEXP_CHARVAL)
  ------------------
  |  Branch (2037:13): [True: 55, False: 56]
  ------------------
 2038|     55|            ret = 1;
 2039|     56|        else if ((range1->end < range2->start) ||
  ------------------
  |  Branch (2039:18): [True: 7, False: 49]
  ------------------
 2040|     56|	         (range2->end < range1->start))
  ------------------
  |  Branch (2040:11): [True: 15, False: 34]
  ------------------
 2041|     22|	    ret = 0;
 2042|     34|	else
 2043|     34|	    ret = 1;
 2044|    229|    } else if (range1->type == XML_REGEXP_CHARVAL) {
  ------------------
  |  Branch (2044:16): [True: 212, False: 17]
  ------------------
 2045|    212|        int codepoint;
 2046|    212|	int neg = 0;
 2047|       |
 2048|       |	/*
 2049|       |	 * just check all codepoints in the range for acceptance,
 2050|       |	 * this is usually way cheaper since done only once at
 2051|       |	 * compilation than testing over and over at runtime or
 2052|       |	 * pushing too many states when evaluating.
 2053|       |	 */
 2054|    212|	if (((range1->neg == 0) && (range2->neg != 0)) ||
  ------------------
  |  Branch (2054:7): [True: 212, False: 0]
  |  Branch (2054:29): [True: 0, False: 212]
  ------------------
 2055|    212|	    ((range1->neg != 0) && (range2->neg == 0)))
  ------------------
  |  Branch (2055:7): [True: 0, False: 212]
  |  Branch (2055:29): [True: 0, False: 0]
  ------------------
 2056|      0|	    neg = 1;
 2057|       |
 2058|  2.24k|	for (codepoint = range1->start;codepoint <= range1->end ;codepoint++) {
  ------------------
  |  Branch (2058:33): [True: 2.03k, False: 210]
  ------------------
 2059|  2.03k|	    ret = xmlRegCheckCharacterRange(range2->type, codepoint,
 2060|  2.03k|					    0, range2->start, range2->end,
 2061|  2.03k|					    range2->blockName);
 2062|  2.03k|	    if (ret < 0)
  ------------------
  |  Branch (2062:10): [True: 2, False: 2.02k]
  ------------------
 2063|      2|	        return(-1);
 2064|  2.02k|	    if (((neg == 1) && (ret == 0)) ||
  ------------------
  |  Branch (2064:11): [True: 0, False: 2.02k]
  |  Branch (2064:25): [True: 0, False: 0]
  ------------------
 2065|  2.02k|	        ((neg == 0) && (ret == 1)))
  ------------------
  |  Branch (2065:11): [True: 2.02k, False: 0]
  |  Branch (2065:25): [True: 0, False: 2.02k]
  ------------------
 2066|      0|		return(1);
 2067|  2.02k|	}
 2068|    210|	return(0);
 2069|    212|    } else if ((range1->type == XML_REGEXP_BLOCK_NAME) ||
  ------------------
  |  Branch (2069:16): [True: 0, False: 17]
  ------------------
 2070|     17|               (range2->type == XML_REGEXP_BLOCK_NAME)) {
  ------------------
  |  Branch (2070:16): [True: 17, False: 0]
  ------------------
 2071|     17|	if (range1->type == range2->type) {
  ------------------
  |  Branch (2071:6): [True: 0, False: 17]
  ------------------
 2072|      0|	    ret = xmlStrEqual(range1->blockName, range2->blockName);
 2073|     17|	} else {
 2074|       |	    /*
 2075|       |	     * comparing a block range with anything else is way
 2076|       |	     * too costly, and maintaining the table is like too much
 2077|       |	     * memory too, so let's force the automata to save state
 2078|       |	     * here.
 2079|       |	     */
 2080|     17|	    return(1);
 2081|     17|	}
 2082|     17|    } else if ((range1->type < XML_REGEXP_LETTER) ||
  ------------------
  |  Branch (2082:16): [True: 0, False: 0]
  ------------------
 2083|      0|               (range2->type < XML_REGEXP_LETTER)) {
  ------------------
  |  Branch (2083:16): [True: 0, False: 0]
  ------------------
 2084|      0|	if ((range1->type == XML_REGEXP_ANYSPACE) &&
  ------------------
  |  Branch (2084:6): [True: 0, False: 0]
  ------------------
 2085|      0|	    (range2->type == XML_REGEXP_NOTSPACE))
  ------------------
  |  Branch (2085:6): [True: 0, False: 0]
  ------------------
 2086|      0|	    ret = 0;
 2087|      0|	else if ((range1->type == XML_REGEXP_INITNAME) &&
  ------------------
  |  Branch (2087:11): [True: 0, False: 0]
  ------------------
 2088|      0|	         (range2->type == XML_REGEXP_NOTINITNAME))
  ------------------
  |  Branch (2088:11): [True: 0, False: 0]
  ------------------
 2089|      0|	    ret = 0;
 2090|      0|	else if ((range1->type == XML_REGEXP_NAMECHAR) &&
  ------------------
  |  Branch (2090:11): [True: 0, False: 0]
  ------------------
 2091|      0|	         (range2->type == XML_REGEXP_NOTNAMECHAR))
  ------------------
  |  Branch (2091:11): [True: 0, False: 0]
  ------------------
 2092|      0|	    ret = 0;
 2093|      0|	else if ((range1->type == XML_REGEXP_DECIMAL) &&
  ------------------
  |  Branch (2093:11): [True: 0, False: 0]
  ------------------
 2094|      0|	         (range2->type == XML_REGEXP_NOTDECIMAL))
  ------------------
  |  Branch (2094:11): [True: 0, False: 0]
  ------------------
 2095|      0|	    ret = 0;
 2096|      0|	else if ((range1->type == XML_REGEXP_REALCHAR) &&
  ------------------
  |  Branch (2096:11): [True: 0, False: 0]
  ------------------
 2097|      0|	         (range2->type == XML_REGEXP_NOTREALCHAR))
  ------------------
  |  Branch (2097:11): [True: 0, False: 0]
  ------------------
 2098|      0|	    ret = 0;
 2099|      0|	else {
 2100|       |	    /* same thing to limit complexity */
 2101|      0|	    return(1);
 2102|      0|	}
 2103|      0|    } else {
 2104|      0|        ret = 0;
 2105|       |        /* range1->type < range2->type here */
 2106|      0|        switch (range1->type) {
 2107|      0|	    case XML_REGEXP_LETTER:
  ------------------
  |  Branch (2107:6): [True: 0, False: 0]
  ------------------
 2108|       |	         /* all disjoint except in the subgroups */
 2109|      0|	         if ((range2->type == XML_REGEXP_LETTER_UPPERCASE) ||
  ------------------
  |  Branch (2109:15): [True: 0, False: 0]
  ------------------
 2110|      0|		     (range2->type == XML_REGEXP_LETTER_LOWERCASE) ||
  ------------------
  |  Branch (2110:8): [True: 0, False: 0]
  ------------------
 2111|      0|		     (range2->type == XML_REGEXP_LETTER_TITLECASE) ||
  ------------------
  |  Branch (2111:8): [True: 0, False: 0]
  ------------------
 2112|      0|		     (range2->type == XML_REGEXP_LETTER_MODIFIER) ||
  ------------------
  |  Branch (2112:8): [True: 0, False: 0]
  ------------------
 2113|      0|		     (range2->type == XML_REGEXP_LETTER_OTHERS))
  ------------------
  |  Branch (2113:8): [True: 0, False: 0]
  ------------------
 2114|      0|		     ret = 1;
 2115|      0|		 break;
 2116|      0|	    case XML_REGEXP_MARK:
  ------------------
  |  Branch (2116:6): [True: 0, False: 0]
  ------------------
 2117|      0|	         if ((range2->type == XML_REGEXP_MARK_NONSPACING) ||
  ------------------
  |  Branch (2117:15): [True: 0, False: 0]
  ------------------
 2118|      0|		     (range2->type == XML_REGEXP_MARK_SPACECOMBINING) ||
  ------------------
  |  Branch (2118:8): [True: 0, False: 0]
  ------------------
 2119|      0|		     (range2->type == XML_REGEXP_MARK_ENCLOSING))
  ------------------
  |  Branch (2119:8): [True: 0, False: 0]
  ------------------
 2120|      0|		     ret = 1;
 2121|      0|		 break;
 2122|      0|	    case XML_REGEXP_NUMBER:
  ------------------
  |  Branch (2122:6): [True: 0, False: 0]
  ------------------
 2123|      0|	         if ((range2->type == XML_REGEXP_NUMBER_DECIMAL) ||
  ------------------
  |  Branch (2123:15): [True: 0, False: 0]
  ------------------
 2124|      0|		     (range2->type == XML_REGEXP_NUMBER_LETTER) ||
  ------------------
  |  Branch (2124:8): [True: 0, False: 0]
  ------------------
 2125|      0|		     (range2->type == XML_REGEXP_NUMBER_OTHERS))
  ------------------
  |  Branch (2125:8): [True: 0, False: 0]
  ------------------
 2126|      0|		     ret = 1;
 2127|      0|		 break;
 2128|      0|	    case XML_REGEXP_PUNCT:
  ------------------
  |  Branch (2128:6): [True: 0, False: 0]
  ------------------
 2129|      0|	         if ((range2->type == XML_REGEXP_PUNCT_CONNECTOR) ||
  ------------------
  |  Branch (2129:15): [True: 0, False: 0]
  ------------------
 2130|      0|		     (range2->type == XML_REGEXP_PUNCT_DASH) ||
  ------------------
  |  Branch (2130:8): [True: 0, False: 0]
  ------------------
 2131|      0|		     (range2->type == XML_REGEXP_PUNCT_OPEN) ||
  ------------------
  |  Branch (2131:8): [True: 0, False: 0]
  ------------------
 2132|      0|		     (range2->type == XML_REGEXP_PUNCT_CLOSE) ||
  ------------------
  |  Branch (2132:8): [True: 0, False: 0]
  ------------------
 2133|      0|		     (range2->type == XML_REGEXP_PUNCT_INITQUOTE) ||
  ------------------
  |  Branch (2133:8): [True: 0, False: 0]
  ------------------
 2134|      0|		     (range2->type == XML_REGEXP_PUNCT_FINQUOTE) ||
  ------------------
  |  Branch (2134:8): [True: 0, False: 0]
  ------------------
 2135|      0|		     (range2->type == XML_REGEXP_PUNCT_OTHERS))
  ------------------
  |  Branch (2135:8): [True: 0, False: 0]
  ------------------
 2136|      0|		     ret = 1;
 2137|      0|		 break;
 2138|      0|	    case XML_REGEXP_SEPAR:
  ------------------
  |  Branch (2138:6): [True: 0, False: 0]
  ------------------
 2139|      0|	         if ((range2->type == XML_REGEXP_SEPAR_SPACE) ||
  ------------------
  |  Branch (2139:15): [True: 0, False: 0]
  ------------------
 2140|      0|		     (range2->type == XML_REGEXP_SEPAR_LINE) ||
  ------------------
  |  Branch (2140:8): [True: 0, False: 0]
  ------------------
 2141|      0|		     (range2->type == XML_REGEXP_SEPAR_PARA))
  ------------------
  |  Branch (2141:8): [True: 0, False: 0]
  ------------------
 2142|      0|		     ret = 1;
 2143|      0|		 break;
 2144|      0|	    case XML_REGEXP_SYMBOL:
  ------------------
  |  Branch (2144:6): [True: 0, False: 0]
  ------------------
 2145|      0|	         if ((range2->type == XML_REGEXP_SYMBOL_MATH) ||
  ------------------
  |  Branch (2145:15): [True: 0, False: 0]
  ------------------
 2146|      0|		     (range2->type == XML_REGEXP_SYMBOL_CURRENCY) ||
  ------------------
  |  Branch (2146:8): [True: 0, False: 0]
  ------------------
 2147|      0|		     (range2->type == XML_REGEXP_SYMBOL_MODIFIER) ||
  ------------------
  |  Branch (2147:8): [True: 0, False: 0]
  ------------------
 2148|      0|		     (range2->type == XML_REGEXP_SYMBOL_OTHERS))
  ------------------
  |  Branch (2148:8): [True: 0, False: 0]
  ------------------
 2149|      0|		     ret = 1;
 2150|      0|		 break;
 2151|      0|	    case XML_REGEXP_OTHER:
  ------------------
  |  Branch (2151:6): [True: 0, False: 0]
  ------------------
 2152|      0|	         if ((range2->type == XML_REGEXP_OTHER_CONTROL) ||
  ------------------
  |  Branch (2152:15): [True: 0, False: 0]
  ------------------
 2153|      0|		     (range2->type == XML_REGEXP_OTHER_FORMAT) ||
  ------------------
  |  Branch (2153:8): [True: 0, False: 0]
  ------------------
 2154|      0|		     (range2->type == XML_REGEXP_OTHER_PRIVATE))
  ------------------
  |  Branch (2154:8): [True: 0, False: 0]
  ------------------
 2155|      0|		     ret = 1;
 2156|      0|		 break;
 2157|      0|            default:
  ------------------
  |  Branch (2157:13): [True: 0, False: 0]
  ------------------
 2158|      0|	         if ((range2->type >= XML_REGEXP_LETTER) &&
  ------------------
  |  Branch (2158:15): [True: 0, False: 0]
  ------------------
 2159|      0|		     (range2->type < XML_REGEXP_BLOCK_NAME))
  ------------------
  |  Branch (2159:8): [True: 0, False: 0]
  ------------------
 2160|      0|		     ret = 0;
 2161|      0|		 else {
 2162|       |		     /* safety net ! */
 2163|      0|		     return(1);
 2164|      0|		 }
 2165|      0|	}
 2166|      0|    }
 2167|    111|    if (((range1->neg == 0) && (range2->neg != 0)) ||
  ------------------
  |  Branch (2167:10): [True: 111, False: 0]
  |  Branch (2167:32): [True: 0, False: 111]
  ------------------
 2168|    111|        ((range1->neg != 0) && (range2->neg == 0)))
  ------------------
  |  Branch (2168:10): [True: 0, False: 111]
  |  Branch (2168:32): [True: 0, False: 0]
  ------------------
 2169|      0|	ret = !ret;
 2170|    111|    return(ret);
 2171|    340|}
xmlregexp.c:xmlFARecurseDeterminism:
 2528|    292|	                int fromnr, int tonr, xmlRegAtomPtr atom) {
 2529|    292|    int ret = 1;
 2530|    292|    int res;
 2531|    292|    int transnr, nbTrans;
 2532|    292|    xmlRegTransPtr t1;
 2533|    292|    int deep = 1;
 2534|       |
 2535|    292|    if (state == NULL)
  ------------------
  |  Branch (2535:9): [True: 0, False: 292]
  ------------------
 2536|      0|	return(ret);
 2537|    292|    if (state->markd == XML_REGEXP_MARK_VISITED)
  ------------------
  |  Branch (2537:9): [True: 0, False: 292]
  ------------------
 2538|      0|	return(ret);
 2539|       |
 2540|    292|    if (ctxt->flags & AM_AUTOMATA_RNG)
  ------------------
  |  |  243|    292|#define AM_AUTOMATA_RNG 1
  ------------------
  |  Branch (2540:9): [True: 0, False: 292]
  ------------------
 2541|      0|        deep = 0;
 2542|       |
 2543|       |    /*
 2544|       |     * don't recurse on transitions potentially added in the course of
 2545|       |     * the elimination.
 2546|       |     */
 2547|    292|    nbTrans = state->nbTrans;
 2548|  1.86k|    for (transnr = 0;transnr < nbTrans;transnr++) {
  ------------------
  |  Branch (2548:22): [True: 1.57k, False: 292]
  ------------------
 2549|  1.57k|	t1 = &(state->trans[transnr]);
 2550|       |	/*
 2551|       |	 * check transitions conflicting with the one looked at
 2552|       |	 */
 2553|  1.57k|        if ((t1->to < 0) || (t1->to == fromnr))
  ------------------
  |  Branch (2553:13): [True: 638, False: 933]
  |  Branch (2553:29): [True: 89, False: 844]
  ------------------
 2554|    727|            continue;
 2555|    844|	if (t1->atom == NULL) {
  ------------------
  |  Branch (2555:6): [True: 18, False: 826]
  ------------------
 2556|     18|	    state->markd = XML_REGEXP_MARK_VISITED;
 2557|     18|	    res = xmlFARecurseDeterminism(ctxt, ctxt->states[t1->to],
 2558|     18|		                          fromnr, tonr, atom);
 2559|     18|	    if (res == 0) {
  ------------------
  |  Branch (2559:10): [True: 0, False: 18]
  ------------------
 2560|      0|	        ret = 0;
 2561|       |		/* t1->nd = 1; */
 2562|      0|	    }
 2563|     18|	    continue;
 2564|     18|	}
 2565|    826|	if (xmlFACompareAtoms(t1->atom, atom, deep)) {
  ------------------
  |  Branch (2565:6): [True: 187, False: 639]
  ------------------
 2566|       |            /* Treat equal transitions as deterministic. */
 2567|    187|            if ((t1->to != tonr) ||
  ------------------
  |  Branch (2567:17): [True: 91, False: 96]
  ------------------
 2568|    187|                (!xmlFAEqualAtoms(t1->atom, atom, deep)))
  ------------------
  |  Branch (2568:17): [True: 0, False: 96]
  ------------------
 2569|     91|                ret = 0;
 2570|       |	    /* mark the transition as non-deterministic */
 2571|    187|	    t1->nd = 1;
 2572|    187|	}
 2573|    826|    }
 2574|    292|    return(ret);
 2575|    292|}
xmlregexp.c:xmlFAFinishRecurseDeterminism:
 2584|    292|xmlFAFinishRecurseDeterminism(xmlRegParserCtxtPtr ctxt, xmlRegStatePtr state) {
 2585|    292|    int transnr, nbTrans;
 2586|       |
 2587|    292|    if (state == NULL)
  ------------------
  |  Branch (2587:9): [True: 0, False: 292]
  ------------------
 2588|      0|	return;
 2589|    292|    if (state->markd != XML_REGEXP_MARK_VISITED)
  ------------------
  |  Branch (2589:9): [True: 274, False: 18]
  ------------------
 2590|    274|	return;
 2591|     18|    state->markd = 0;
 2592|       |
 2593|     18|    nbTrans = state->nbTrans;
 2594|    144|    for (transnr = 0; transnr < nbTrans; transnr++) {
  ------------------
  |  Branch (2594:23): [True: 126, False: 18]
  ------------------
 2595|    126|	xmlRegTransPtr t1 = &state->trans[transnr];
 2596|    126|	if ((t1->atom == NULL) && (t1->to >= 0))
  ------------------
  |  Branch (2596:6): [True: 36, False: 90]
  |  Branch (2596:28): [True: 18, False: 18]
  ------------------
 2597|     18|	    xmlFAFinishRecurseDeterminism(ctxt, ctxt->states[t1->to]);
 2598|    126|    }
 2599|     18|}
xmlregexp.c:xmlRegFreeAtom:
  819|  6.58k|xmlRegFreeAtom(xmlRegAtomPtr atom) {
  820|  6.58k|    int i;
  821|       |
  822|  6.58k|    if (atom == NULL)
  ------------------
  |  Branch (822:9): [True: 83, False: 6.50k]
  ------------------
  823|     83|	return;
  824|       |
  825|  7.04k|    for (i = 0;i < atom->nbRanges;i++)
  ------------------
  |  Branch (825:16): [True: 543, False: 6.50k]
  ------------------
  826|    543|	xmlRegFreeRange(atom->ranges[i]);
  827|  6.50k|    if (atom->ranges != NULL)
  ------------------
  |  Branch (827:9): [True: 314, False: 6.18k]
  ------------------
  828|    314|	xmlFree(atom->ranges);
  829|  6.50k|    if ((atom->type == XML_REGEXP_STRING) && (atom->valuep != NULL))
  ------------------
  |  Branch (829:9): [True: 0, False: 6.50k]
  |  Branch (829:46): [True: 0, False: 0]
  ------------------
  830|      0|	xmlFree(atom->valuep);
  831|  6.50k|    if ((atom->type == XML_REGEXP_STRING) && (atom->valuep2 != NULL))
  ------------------
  |  Branch (831:9): [True: 0, False: 6.50k]
  |  Branch (831:46): [True: 0, False: 0]
  ------------------
  832|      0|	xmlFree(atom->valuep2);
  833|  6.50k|    if ((atom->type == XML_REGEXP_BLOCK_NAME) && (atom->valuep != NULL))
  ------------------
  |  Branch (833:9): [True: 50, False: 6.45k]
  |  Branch (833:50): [True: 50, False: 0]
  ------------------
  834|     50|	xmlFree(atom->valuep);
  835|  6.50k|    xmlFree(atom);
  836|  6.50k|}
xmlregexp.c:xmlRegFreeRange:
  747|    543|xmlRegFreeRange(xmlRegRangePtr range) {
  748|    543|    if (range == NULL)
  ------------------
  |  Branch (748:9): [True: 0, False: 543]
  ------------------
  749|      0|	return;
  750|       |
  751|    543|    if (range->blockName != NULL)
  ------------------
  |  Branch (751:9): [True: 19, False: 524]
  ------------------
  752|     19|	xmlFree(range->blockName);
  753|    543|    xmlFree(range);
  754|    543|}
xmlregexp.c:xmlRegNewAtom:
  796|  6.56k|xmlRegNewAtom(xmlRegParserCtxtPtr ctxt, xmlRegAtomType type) {
  797|  6.56k|    xmlRegAtomPtr ret;
  798|       |
  799|  6.56k|    ret = (xmlRegAtomPtr) xmlMalloc(sizeof(xmlRegAtom));
  800|  6.56k|    if (ret == NULL) {
  ------------------
  |  Branch (800:9): [True: 68, False: 6.50k]
  ------------------
  801|     68|	xmlRegexpErrMemory(ctxt, "allocating atom");
  802|     68|	return(NULL);
  803|     68|    }
  804|  6.50k|    memset(ret, 0, sizeof(xmlRegAtom));
  805|  6.50k|    ret->type = type;
  806|  6.50k|    ret->quant = XML_REGEXP_QUANT_ONCE;
  807|  6.50k|    ret->min = 0;
  808|  6.50k|    ret->max = 0;
  809|  6.50k|    return(ret);
  810|  6.56k|}
xmlregexp.c:xmlFAGenerateTransitions:
 1493|  6.58k|	                 xmlRegStatePtr to, xmlRegAtomPtr atom) {
 1494|  6.58k|    xmlRegStatePtr end;
 1495|  6.58k|    int nullable = 0;
 1496|       |
 1497|  6.58k|    if (atom == NULL) {
  ------------------
  |  Branch (1497:9): [True: 83, False: 6.50k]
  ------------------
 1498|     83|	ERROR("generate transition: atom == NULL");
  ------------------
  |  |   55|     83|    ctxt->error = XML_REGEXP_COMPILE_ERROR;				\
  |  |   56|     83|    xmlRegexpErrCompile(ctxt, str);
  ------------------
 1499|     83|	return(-1);
 1500|     83|    }
 1501|  6.50k|    if (atom->type == XML_REGEXP_SUBREG) {
  ------------------
  |  Branch (1501:9): [True: 1.77k, False: 4.72k]
  ------------------
 1502|       |	/*
 1503|       |	 * this is a subexpression handling one should not need to
 1504|       |	 * create a new node except for XML_REGEXP_QUANT_RANGE.
 1505|       |	 */
 1506|  1.77k|	if ((to != NULL) && (atom->stop != to) &&
  ------------------
  |  Branch (1506:6): [True: 50, False: 1.72k]
  |  Branch (1506:22): [True: 50, False: 0]
  ------------------
 1507|  1.77k|	    (atom->quant != XML_REGEXP_QUANT_RANGE)) {
  ------------------
  |  Branch (1507:6): [True: 49, False: 1]
  ------------------
 1508|       |	    /*
 1509|       |	     * Generate an epsilon transition to link to the target
 1510|       |	     */
 1511|     49|	    xmlFAGenerateEpsilonTransition(ctxt, atom->stop, to);
 1512|       |#ifdef DV
 1513|       |	} else if ((to == NULL) && (atom->quant != XML_REGEXP_QUANT_RANGE) &&
 1514|       |		   (atom->quant != XML_REGEXP_QUANT_ONCE)) {
 1515|       |	    to = xmlRegStatePush(ctxt, to);
 1516|       |            if (to == NULL)
 1517|       |                return(-1);
 1518|       |	    ctxt->state = to;
 1519|       |	    xmlFAGenerateEpsilonTransition(ctxt, atom->stop, to);
 1520|       |#endif
 1521|     49|	}
 1522|  1.77k|	switch (atom->quant) {
 1523|    483|	    case XML_REGEXP_QUANT_OPT:
  ------------------
  |  Branch (1523:6): [True: 483, False: 1.29k]
  ------------------
 1524|    483|		atom->quant = XML_REGEXP_QUANT_ONCE;
 1525|       |		/*
 1526|       |		 * transition done to the state after end of atom.
 1527|       |		 *      1. set transition from atom start to new state
 1528|       |		 *      2. set transition from atom end to this state.
 1529|       |		 */
 1530|    483|                if (to == NULL) {
  ------------------
  |  Branch (1530:21): [True: 480, False: 3]
  ------------------
 1531|    480|                    xmlFAGenerateEpsilonTransition(ctxt, atom->start, 0);
 1532|    480|                    xmlFAGenerateEpsilonTransition(ctxt, atom->stop,
 1533|    480|                                                   ctxt->state);
 1534|    480|                } else {
 1535|      3|                    xmlFAGenerateEpsilonTransition(ctxt, atom->start, to);
 1536|      3|                }
 1537|    483|		break;
 1538|    119|	    case XML_REGEXP_QUANT_MULT:
  ------------------
  |  Branch (1538:6): [True: 119, False: 1.65k]
  ------------------
 1539|    119|		atom->quant = XML_REGEXP_QUANT_ONCE;
 1540|    119|		xmlFAGenerateEpsilonTransition(ctxt, atom->start, atom->stop);
 1541|    119|		xmlFAGenerateEpsilonTransition(ctxt, atom->stop, atom->start);
 1542|    119|		break;
 1543|     73|	    case XML_REGEXP_QUANT_PLUS:
  ------------------
  |  Branch (1543:6): [True: 73, False: 1.70k]
  ------------------
 1544|     73|		atom->quant = XML_REGEXP_QUANT_ONCE;
 1545|     73|		xmlFAGenerateEpsilonTransition(ctxt, atom->stop, atom->start);
 1546|     73|		break;
 1547|     78|	    case XML_REGEXP_QUANT_RANGE: {
  ------------------
  |  Branch (1547:6): [True: 78, False: 1.69k]
  ------------------
 1548|     78|		int counter;
 1549|     78|		xmlRegStatePtr inter, newstate;
 1550|       |
 1551|       |		/*
 1552|       |		 * create the final state now if needed
 1553|       |		 */
 1554|     78|		if (to != NULL) {
  ------------------
  |  Branch (1554:7): [True: 1, False: 77]
  ------------------
 1555|      1|		    newstate = to;
 1556|     77|		} else {
 1557|     77|		    newstate = xmlRegStatePush(ctxt);
 1558|     77|                    if (newstate == NULL)
  ------------------
  |  Branch (1558:25): [True: 0, False: 77]
  ------------------
 1559|      0|                        return(-1);
 1560|     77|		}
 1561|       |
 1562|       |		/*
 1563|       |		 * The principle here is to use counted transition
 1564|       |		 * to avoid explosion in the number of states in the
 1565|       |		 * graph. This is clearly more complex but should not
 1566|       |		 * be exploitable at runtime.
 1567|       |		 */
 1568|     78|		if ((atom->min == 0) && (atom->start0 == NULL)) {
  ------------------
  |  Branch (1568:7): [True: 14, False: 64]
  |  Branch (1568:27): [True: 0, False: 14]
  ------------------
 1569|      0|		    xmlRegAtomPtr copy;
 1570|       |		    /*
 1571|       |		     * duplicate a transition based on atom to count next
 1572|       |		     * occurrences after 1. We cannot loop to atom->start
 1573|       |		     * directly because we need an epsilon transition to
 1574|       |		     * newstate.
 1575|       |		     */
 1576|       |		     /* ???? For some reason it seems we never reach that
 1577|       |		        case, I suppose this got optimized out before when
 1578|       |			building the automata */
 1579|      0|		    copy = xmlRegCopyAtom(ctxt, atom);
 1580|      0|		    if (copy == NULL)
  ------------------
  |  Branch (1580:11): [True: 0, False: 0]
  ------------------
 1581|      0|		        return(-1);
 1582|      0|		    copy->quant = XML_REGEXP_QUANT_ONCE;
 1583|      0|		    copy->min = 0;
 1584|      0|		    copy->max = 0;
 1585|       |
 1586|      0|		    if (xmlFAGenerateTransitions(ctxt, atom->start, NULL, copy)
  ------------------
  |  Branch (1586:11): [True: 0, False: 0]
  ------------------
 1587|      0|		        < 0) {
 1588|      0|                        xmlRegFreeAtom(copy);
 1589|      0|			return(-1);
 1590|      0|                    }
 1591|      0|		    inter = ctxt->state;
 1592|      0|		    counter = xmlRegGetCounter(ctxt);
 1593|      0|                    if (counter < 0)
  ------------------
  |  Branch (1593:25): [True: 0, False: 0]
  ------------------
 1594|      0|                        return(-1);
 1595|      0|		    ctxt->counters[counter].min = atom->min - 1;
 1596|      0|		    ctxt->counters[counter].max = atom->max - 1;
 1597|       |		    /* count the number of times we see it again */
 1598|      0|		    xmlFAGenerateCountedEpsilonTransition(ctxt, inter,
 1599|      0|						   atom->stop, counter);
 1600|       |		    /* allow a way out based on the count */
 1601|      0|		    xmlFAGenerateCountedTransition(ctxt, inter,
 1602|      0|			                           newstate, counter);
 1603|       |		    /* and also allow a direct exit for 0 */
 1604|      0|		    xmlFAGenerateEpsilonTransition(ctxt, atom->start,
 1605|      0|		                                   newstate);
 1606|     78|		} else {
 1607|       |		    /*
 1608|       |		     * either we need the atom at least once or there
 1609|       |		     * is an atom->start0 allowing to easily plug the
 1610|       |		     * epsilon transition.
 1611|       |		     */
 1612|     78|		    counter = xmlRegGetCounter(ctxt);
 1613|     78|                    if (counter < 0)
  ------------------
  |  Branch (1613:25): [True: 0, False: 78]
  ------------------
 1614|      0|                        return(-1);
 1615|     78|		    ctxt->counters[counter].min = atom->min - 1;
 1616|     78|		    ctxt->counters[counter].max = atom->max - 1;
 1617|       |		    /* allow a way out based on the count */
 1618|     78|		    xmlFAGenerateCountedTransition(ctxt, atom->stop,
 1619|     78|			                           newstate, counter);
 1620|       |		    /* count the number of times we see it again */
 1621|     78|		    xmlFAGenerateCountedEpsilonTransition(ctxt, atom->stop,
 1622|     78|						   atom->start, counter);
 1623|       |		    /* and if needed allow a direct exit for 0 */
 1624|     78|		    if (atom->min == 0)
  ------------------
  |  Branch (1624:11): [True: 14, False: 64]
  ------------------
 1625|     14|			xmlFAGenerateEpsilonTransition(ctxt, atom->start0,
 1626|     14|						       newstate);
 1627|       |
 1628|     78|		}
 1629|     78|		atom->min = 0;
 1630|     78|		atom->max = 0;
 1631|     78|		atom->quant = XML_REGEXP_QUANT_ONCE;
 1632|     78|		ctxt->state = newstate;
 1633|     78|	    }
 1634|  1.10k|	    default:
  ------------------
  |  Branch (1634:6): [True: 1.02k, False: 753]
  ------------------
 1635|  1.10k|		break;
 1636|  1.77k|	}
 1637|  1.77k|	if (xmlRegAtomPush(ctxt, atom) < 0)
  ------------------
  |  Branch (1637:6): [True: 0, False: 1.77k]
  ------------------
 1638|      0|	    return(-1);
 1639|  1.77k|	return(0);
 1640|  1.77k|    }
 1641|  4.72k|    if ((atom->min == 0) && (atom->max == 0) &&
  ------------------
  |  Branch (1641:9): [True: 4.69k, False: 33]
  |  Branch (1641:29): [True: 4.67k, False: 19]
  ------------------
 1642|  4.72k|               (atom->quant == XML_REGEXP_QUANT_RANGE)) {
  ------------------
  |  Branch (1642:16): [True: 15, False: 4.65k]
  ------------------
 1643|       |        /*
 1644|       |	 * we can discard the atom and generate an epsilon transition instead
 1645|       |	 */
 1646|     15|	if (to == NULL) {
  ------------------
  |  Branch (1646:6): [True: 14, False: 1]
  ------------------
 1647|     14|	    to = xmlRegStatePush(ctxt);
 1648|     14|	    if (to == NULL)
  ------------------
  |  Branch (1648:10): [True: 2, False: 12]
  ------------------
 1649|      2|		return(-1);
 1650|     14|	}
 1651|     13|	xmlFAGenerateEpsilonTransition(ctxt, from, to);
 1652|     13|	ctxt->state = to;
 1653|     13|	xmlRegFreeAtom(atom);
 1654|     13|	return(0);
 1655|     15|    }
 1656|  4.70k|    if (to == NULL) {
  ------------------
  |  Branch (1656:9): [True: 4.03k, False: 670]
  ------------------
 1657|  4.03k|	to = xmlRegStatePush(ctxt);
 1658|  4.03k|	if (to == NULL)
  ------------------
  |  Branch (1658:6): [True: 7, False: 4.03k]
  ------------------
 1659|      7|	    return(-1);
 1660|  4.03k|    }
 1661|  4.70k|    end = to;
 1662|  4.70k|    if ((atom->quant == XML_REGEXP_QUANT_MULT) ||
  ------------------
  |  Branch (1662:9): [True: 376, False: 4.32k]
  ------------------
 1663|  4.70k|        (atom->quant == XML_REGEXP_QUANT_PLUS)) {
  ------------------
  |  Branch (1663:9): [True: 166, False: 4.16k]
  ------------------
 1664|       |	/*
 1665|       |	 * Do not pollute the target state by adding transitions from
 1666|       |	 * it as it is likely to be the shared target of multiple branches.
 1667|       |	 * So isolate with an epsilon transition.
 1668|       |	 */
 1669|    542|        xmlRegStatePtr tmp;
 1670|       |
 1671|    542|	tmp = xmlRegStatePush(ctxt);
 1672|    542|        if (tmp == NULL)
  ------------------
  |  Branch (1672:13): [True: 1, False: 541]
  ------------------
 1673|      1|	    return(-1);
 1674|    541|	xmlFAGenerateEpsilonTransition(ctxt, tmp, to);
 1675|    541|	to = tmp;
 1676|    541|    }
 1677|  4.70k|    if ((atom->quant == XML_REGEXP_QUANT_RANGE) &&
  ------------------
  |  Branch (1677:9): [True: 51, False: 4.65k]
  ------------------
 1678|  4.70k|        (atom->min == 0) && (atom->max > 0)) {
  ------------------
  |  Branch (1678:9): [True: 19, False: 32]
  |  Branch (1678:29): [True: 19, False: 0]
  ------------------
 1679|     19|	nullable = 1;
 1680|     19|	atom->min = 1;
 1681|     19|        if (atom->max == 1)
  ------------------
  |  Branch (1681:13): [True: 1, False: 18]
  ------------------
 1682|      1|	    atom->quant = XML_REGEXP_QUANT_OPT;
 1683|     19|    }
 1684|  4.70k|    xmlRegStateAddTrans(ctxt, from, atom, to, -1, -1);
 1685|  4.70k|    ctxt->state = end;
 1686|  4.70k|    switch (atom->quant) {
 1687|    106|	case XML_REGEXP_QUANT_OPT:
  ------------------
  |  Branch (1687:2): [True: 106, False: 4.59k]
  ------------------
 1688|    106|	    atom->quant = XML_REGEXP_QUANT_ONCE;
 1689|    106|	    xmlFAGenerateEpsilonTransition(ctxt, from, to);
 1690|    106|	    break;
 1691|    376|	case XML_REGEXP_QUANT_MULT:
  ------------------
  |  Branch (1691:2): [True: 376, False: 4.32k]
  ------------------
 1692|    376|	    atom->quant = XML_REGEXP_QUANT_ONCE;
 1693|    376|	    xmlFAGenerateEpsilonTransition(ctxt, from, to);
 1694|    376|	    xmlRegStateAddTrans(ctxt, to, atom, to, -1, -1);
 1695|    376|	    break;
 1696|    165|	case XML_REGEXP_QUANT_PLUS:
  ------------------
  |  Branch (1696:2): [True: 165, False: 4.53k]
  ------------------
 1697|    165|	    atom->quant = XML_REGEXP_QUANT_ONCE;
 1698|    165|	    xmlRegStateAddTrans(ctxt, to, atom, to, -1, -1);
 1699|    165|	    break;
 1700|     50|	case XML_REGEXP_QUANT_RANGE:
  ------------------
  |  Branch (1700:2): [True: 50, False: 4.65k]
  ------------------
 1701|     50|	    if (nullable)
  ------------------
  |  Branch (1701:10): [True: 18, False: 32]
  ------------------
 1702|     18|		xmlFAGenerateEpsilonTransition(ctxt, from, to);
 1703|     50|	    break;
 1704|  4.00k|	default:
  ------------------
  |  Branch (1704:2): [True: 4.00k, False: 697]
  ------------------
 1705|  4.00k|	    break;
 1706|  4.70k|    }
 1707|  4.70k|    if (xmlRegAtomPush(ctxt, atom) < 0)
  ------------------
  |  Branch (1707:9): [True: 4, False: 4.69k]
  ------------------
 1708|      4|	return(-1);
 1709|  4.69k|    return(0);
 1710|  4.70k|}
xmlregexp.c:xmlRegGetCounter:
 1228|     78|xmlRegGetCounter(xmlRegParserCtxtPtr ctxt) {
 1229|     78|    if (ctxt->maxCounters == 0) {
  ------------------
  |  Branch (1229:9): [True: 68, False: 10]
  ------------------
 1230|     68|	ctxt->maxCounters = 4;
 1231|     68|	ctxt->counters = (xmlRegCounter *) xmlMalloc(ctxt->maxCounters *
 1232|     68|		                             sizeof(xmlRegCounter));
 1233|     68|	if (ctxt->counters == NULL) {
  ------------------
  |  Branch (1233:6): [True: 0, False: 68]
  ------------------
 1234|      0|	    xmlRegexpErrMemory(ctxt, "allocating counter");
 1235|      0|	    ctxt->maxCounters = 0;
 1236|      0|	    return(-1);
 1237|      0|	}
 1238|     68|    } else if (ctxt->nbCounters >= ctxt->maxCounters) {
  ------------------
  |  Branch (1238:16): [True: 0, False: 10]
  ------------------
 1239|      0|	xmlRegCounter *tmp;
 1240|      0|	ctxt->maxCounters *= 2;
 1241|      0|	tmp = (xmlRegCounter *) xmlRealloc(ctxt->counters, ctxt->maxCounters *
 1242|      0|		                           sizeof(xmlRegCounter));
 1243|      0|	if (tmp == NULL) {
  ------------------
  |  Branch (1243:6): [True: 0, False: 0]
  ------------------
 1244|      0|	    xmlRegexpErrMemory(ctxt, "allocating counter");
 1245|      0|	    ctxt->maxCounters /= 2;
 1246|      0|	    return(-1);
 1247|      0|	}
 1248|      0|	ctxt->counters = tmp;
 1249|      0|    }
 1250|     78|    ctxt->counters[ctxt->nbCounters].min = -1;
 1251|     78|    ctxt->counters[ctxt->nbCounters].max = -1;
 1252|     78|    return(ctxt->nbCounters++);
 1253|     78|}
xmlregexp.c:xmlRegStateAddTrans:
 1309|  18.0k|		    int counter, int count) {
 1310|       |
 1311|  18.0k|    int nrtrans;
 1312|       |
 1313|  18.0k|    if (state == NULL) {
  ------------------
  |  Branch (1313:9): [True: 0, False: 18.0k]
  ------------------
 1314|      0|	ERROR("add state: state is NULL");
  ------------------
  |  |   55|      0|    ctxt->error = XML_REGEXP_COMPILE_ERROR;				\
  |  |   56|      0|    xmlRegexpErrCompile(ctxt, str);
  ------------------
 1315|      0|	return;
 1316|      0|    }
 1317|  18.0k|    if (target == NULL) {
  ------------------
  |  Branch (1317:9): [True: 0, False: 18.0k]
  ------------------
 1318|      0|	ERROR("add state: target is NULL");
  ------------------
  |  |   55|      0|    ctxt->error = XML_REGEXP_COMPILE_ERROR;				\
  |  |   56|      0|    xmlRegexpErrCompile(ctxt, str);
  ------------------
 1319|      0|	return;
 1320|      0|    }
 1321|       |    /*
 1322|       |     * Other routines follow the philosophy 'When in doubt, add a transition'
 1323|       |     * so we check here whether such a transition is already present and, if
 1324|       |     * so, silently ignore this request.
 1325|       |     */
 1326|       |
 1327|  49.0k|    for (nrtrans = state->nbTrans - 1; nrtrans >= 0; nrtrans--) {
  ------------------
  |  Branch (1327:40): [True: 31.5k, False: 17.4k]
  ------------------
 1328|  31.5k|	xmlRegTransPtr trans = &(state->trans[nrtrans]);
 1329|  31.5k|	if ((trans->atom == atom) &&
  ------------------
  |  Branch (1329:6): [True: 7.35k, False: 24.1k]
  ------------------
 1330|  31.5k|	    (trans->to == target->no) &&
  ------------------
  |  Branch (1330:6): [True: 697, False: 6.66k]
  ------------------
 1331|  31.5k|	    (trans->counter == counter) &&
  ------------------
  |  Branch (1331:6): [True: 618, False: 79]
  ------------------
 1332|  31.5k|	    (trans->count == count)) {
  ------------------
  |  Branch (1332:6): [True: 606, False: 12]
  ------------------
 1333|    606|	    return;
 1334|    606|	}
 1335|  31.5k|    }
 1336|       |
 1337|  17.4k|    if (state->maxTrans == 0) {
  ------------------
  |  Branch (1337:9): [True: 8.86k, False: 8.60k]
  ------------------
 1338|  8.86k|	state->maxTrans = 8;
 1339|  8.86k|	state->trans = (xmlRegTrans *) xmlMalloc(state->maxTrans *
 1340|  8.86k|		                             sizeof(xmlRegTrans));
 1341|  8.86k|	if (state->trans == NULL) {
  ------------------
  |  Branch (1341:6): [True: 11, False: 8.85k]
  ------------------
 1342|     11|	    xmlRegexpErrMemory(ctxt, "adding transition");
 1343|     11|	    state->maxTrans = 0;
 1344|     11|	    return;
 1345|     11|	}
 1346|  8.86k|    } else if (state->nbTrans >= state->maxTrans) {
  ------------------
  |  Branch (1346:16): [True: 302, False: 8.30k]
  ------------------
 1347|    302|	xmlRegTrans *tmp;
 1348|    302|	state->maxTrans *= 2;
 1349|    302|	tmp = (xmlRegTrans *) xmlRealloc(state->trans, state->maxTrans *
 1350|    302|		                             sizeof(xmlRegTrans));
 1351|    302|	if (tmp == NULL) {
  ------------------
  |  Branch (1351:6): [True: 0, False: 302]
  ------------------
 1352|      0|	    xmlRegexpErrMemory(ctxt, "adding transition");
 1353|      0|	    state->maxTrans /= 2;
 1354|      0|	    return;
 1355|      0|	}
 1356|    302|	state->trans = tmp;
 1357|    302|    }
 1358|       |
 1359|  17.4k|    state->trans[state->nbTrans].atom = atom;
 1360|  17.4k|    state->trans[state->nbTrans].to = target->no;
 1361|  17.4k|    state->trans[state->nbTrans].counter = counter;
 1362|  17.4k|    state->trans[state->nbTrans].count = count;
 1363|  17.4k|    state->trans[state->nbTrans].nd = 0;
 1364|  17.4k|    state->nbTrans++;
 1365|  17.4k|    xmlRegStateAddTransTo(ctxt, target, state->no);
 1366|  17.4k|}
xmlregexp.c:xmlRegStateAddTransTo:
 1280|  17.4k|                      int from) {
 1281|  17.4k|    if (target->maxTransTo == 0) {
  ------------------
  |  Branch (1281:9): [True: 8.80k, False: 8.66k]
  ------------------
 1282|  8.80k|	target->maxTransTo = 8;
 1283|  8.80k|	target->transTo = (int *) xmlMalloc(target->maxTransTo *
 1284|  8.80k|		                             sizeof(int));
 1285|  8.80k|	if (target->transTo == NULL) {
  ------------------
  |  Branch (1285:6): [True: 5, False: 8.79k]
  ------------------
 1286|      5|	    xmlRegexpErrMemory(ctxt, "adding transition");
 1287|      5|	    target->maxTransTo = 0;
 1288|      5|	    return;
 1289|      5|	}
 1290|  8.80k|    } else if (target->nbTransTo >= target->maxTransTo) {
  ------------------
  |  Branch (1290:16): [True: 187, False: 8.47k]
  ------------------
 1291|    187|	int *tmp;
 1292|    187|	target->maxTransTo *= 2;
 1293|    187|	tmp = (int *) xmlRealloc(target->transTo, target->maxTransTo *
 1294|    187|		                             sizeof(int));
 1295|    187|	if (tmp == NULL) {
  ------------------
  |  Branch (1295:6): [True: 0, False: 187]
  ------------------
 1296|      0|	    xmlRegexpErrMemory(ctxt, "adding transition");
 1297|      0|	    target->maxTransTo /= 2;
 1298|      0|	    return;
 1299|      0|	}
 1300|    187|	target->transTo = tmp;
 1301|    187|    }
 1302|  17.4k|    target->transTo[target->nbTransTo] = from;
 1303|  17.4k|    target->nbTransTo++;
 1304|  17.4k|}
xmlregexp.c:xmlRegAtomPush:
 1256|  6.47k|xmlRegAtomPush(xmlRegParserCtxtPtr ctxt, xmlRegAtomPtr atom) {
 1257|  6.47k|    if (atom == NULL) {
  ------------------
  |  Branch (1257:9): [True: 0, False: 6.47k]
  ------------------
 1258|      0|	ERROR("atom push: atom is NULL");
  ------------------
  |  |   55|      0|    ctxt->error = XML_REGEXP_COMPILE_ERROR;				\
  |  |   56|      0|    xmlRegexpErrCompile(ctxt, str);
  ------------------
 1259|      0|	return(-1);
 1260|      0|    }
 1261|  6.47k|    if (ctxt->nbAtoms >= ctxt->maxAtoms) {
  ------------------
  |  Branch (1261:9): [True: 867, False: 5.61k]
  ------------------
 1262|    867|        size_t newSize = ctxt->maxAtoms ? ctxt->maxAtoms * 2 : 4;
  ------------------
  |  Branch (1262:26): [True: 563, False: 304]
  ------------------
 1263|    867|	xmlRegAtomPtr *tmp;
 1264|       |
 1265|    867|	tmp = xmlRealloc(ctxt->atoms, newSize * sizeof(xmlRegAtomPtr));
 1266|    867|	if (tmp == NULL) {
  ------------------
  |  Branch (1266:6): [True: 4, False: 863]
  ------------------
 1267|      4|	    xmlRegexpErrMemory(ctxt, "allocating counter");
 1268|      4|	    return(-1);
 1269|      4|	}
 1270|    863|	ctxt->atoms = tmp;
 1271|    863|        ctxt->maxAtoms = newSize;
 1272|    863|    }
 1273|  6.47k|    atom->no = ctxt->nbAtoms;
 1274|  6.47k|    ctxt->atoms[ctxt->nbAtoms++] = atom;
 1275|  6.47k|    return(0);
 1276|  6.47k|}
xmlregexp.c:xmlFAGenerateEpsilonTransition:
 1429|  6.34k|			       xmlRegStatePtr from, xmlRegStatePtr to) {
 1430|  6.34k|    if (to == NULL) {
  ------------------
  |  Branch (1430:9): [True: 4.17k, False: 2.16k]
  ------------------
 1431|  4.17k|	to = xmlRegStatePush(ctxt);
 1432|  4.17k|        if (to == NULL)
  ------------------
  |  Branch (1432:13): [True: 25, False: 4.15k]
  ------------------
 1433|     25|            return(-1);
 1434|  4.15k|	ctxt->state = to;
 1435|  4.15k|    }
 1436|  6.31k|    xmlRegStateAddTrans(ctxt, from, NULL, to, -1, -1);
 1437|  6.31k|    return(0);
 1438|  6.34k|}
xmlregexp.c:xmlFAGenerateCountedEpsilonTransition:
 1450|     78|	    xmlRegStatePtr from, xmlRegStatePtr to, int counter) {
 1451|     78|    if (to == NULL) {
  ------------------
  |  Branch (1451:9): [True: 0, False: 78]
  ------------------
 1452|      0|	to = xmlRegStatePush(ctxt);
 1453|      0|        if (to == NULL)
  ------------------
  |  Branch (1453:13): [True: 0, False: 0]
  ------------------
 1454|      0|            return(-1);
 1455|      0|	ctxt->state = to;
 1456|      0|    }
 1457|     78|    xmlRegStateAddTrans(ctxt, from, NULL, to, counter, -1);
 1458|     78|    return(0);
 1459|     78|}
xmlregexp.c:xmlFAGenerateCountedTransition:
 1471|     78|	    xmlRegStatePtr from, xmlRegStatePtr to, int counter) {
 1472|     78|    if (to == NULL) {
  ------------------
  |  Branch (1472:9): [True: 0, False: 78]
  ------------------
 1473|      0|	to = xmlRegStatePush(ctxt);
 1474|      0|        if (to == NULL)
  ------------------
  |  Branch (1474:13): [True: 0, False: 0]
  ------------------
 1475|      0|            return(-1);
 1476|      0|	ctxt->state = to;
 1477|      0|    }
 1478|     78|    xmlRegStateAddTrans(ctxt, from, NULL, to, -1, counter);
 1479|     78|    return(0);
 1480|     78|}

xmlStrndup:
   45|  2.13k|xmlStrndup(const xmlChar *cur, int len) {
   46|  2.13k|    xmlChar *ret;
   47|       |
   48|  2.13k|    if ((cur == NULL) || (len < 0)) return(NULL);
  ------------------
  |  Branch (48:9): [True: 0, False: 2.13k]
  |  Branch (48:26): [True: 0, False: 2.13k]
  ------------------
   49|  2.13k|    ret = (xmlChar *) xmlMallocAtomic((size_t) len + 1);
   50|  2.13k|    if (ret == NULL) {
  ------------------
  |  Branch (50:9): [True: 752, False: 1.38k]
  ------------------
   51|    752|        return(NULL);
   52|    752|    }
   53|  1.38k|    memcpy(ret, cur, len);
   54|  1.38k|    ret[len] = 0;
   55|  1.38k|    return(ret);
   56|  2.13k|}
xmlStrdup:
   69|  2.06k|xmlStrdup(const xmlChar *cur) {
   70|  2.06k|    const xmlChar *p = cur;
   71|       |
   72|  2.06k|    if (cur == NULL) return(NULL);
  ------------------
  |  Branch (72:9): [True: 0, False: 2.06k]
  ------------------
   73|   106k|    while (*p != 0) p++; /* non input consuming */
  ------------------
  |  Branch (73:12): [True: 104k, False: 2.06k]
  ------------------
   74|  2.06k|    return(xmlStrndup(cur, p - cur));
   75|  2.06k|}
xmlGetUTF8Char:
  708|  13.0k|xmlGetUTF8Char(const unsigned char *utf, int *len) {
  709|  13.0k|    unsigned int c;
  710|       |
  711|  13.0k|    if (utf == NULL)
  ------------------
  |  Branch (711:9): [True: 0, False: 13.0k]
  ------------------
  712|      0|        goto error;
  713|  13.0k|    if (len == NULL)
  ------------------
  |  Branch (713:9): [True: 0, False: 13.0k]
  ------------------
  714|      0|        goto error;
  715|       |
  716|  13.0k|    c = utf[0];
  717|  13.0k|    if (c < 0x80) {
  ------------------
  |  Branch (717:9): [True: 12.9k, False: 43]
  ------------------
  718|  12.9k|        if (*len < 1)
  ------------------
  |  Branch (718:13): [True: 0, False: 12.9k]
  ------------------
  719|      0|            goto error;
  720|       |        /* 1-byte code */
  721|  12.9k|        *len = 1;
  722|  12.9k|    } else {
  723|     43|        if ((*len < 2) || ((utf[1] & 0xc0) != 0x80))
  ------------------
  |  Branch (723:13): [True: 0, False: 43]
  |  Branch (723:27): [True: 16, False: 27]
  ------------------
  724|     16|            goto error;
  725|     27|        if (c < 0xe0) {
  ------------------
  |  Branch (725:13): [True: 26, False: 1]
  ------------------
  726|     26|            if (c < 0xc2)
  ------------------
  |  Branch (726:17): [True: 2, False: 24]
  ------------------
  727|      2|                goto error;
  728|       |            /* 2-byte code */
  729|     24|            *len = 2;
  730|     24|            c = (c & 0x1f) << 6;
  731|     24|            c |= utf[1] & 0x3f;
  732|     24|        } else {
  733|      1|            if ((*len < 3) || ((utf[2] & 0xc0) != 0x80))
  ------------------
  |  Branch (733:17): [True: 0, False: 1]
  |  Branch (733:31): [True: 1, False: 0]
  ------------------
  734|      1|                goto error;
  735|      0|            if (c < 0xf0) {
  ------------------
  |  Branch (735:17): [True: 0, False: 0]
  ------------------
  736|       |                /* 3-byte code */
  737|      0|                *len = 3;
  738|      0|                c = (c & 0xf) << 12;
  739|      0|                c |= (utf[1] & 0x3f) << 6;
  740|      0|                c |= utf[2] & 0x3f;
  741|      0|                if ((c < 0x800) || ((c >= 0xd800) && (c < 0xe000)))
  ------------------
  |  Branch (741:21): [True: 0, False: 0]
  |  Branch (741:37): [True: 0, False: 0]
  |  Branch (741:54): [True: 0, False: 0]
  ------------------
  742|      0|                    goto error;
  743|      0|            } else {
  744|      0|                if ((*len < 4) || ((utf[3] & 0xc0) != 0x80))
  ------------------
  |  Branch (744:21): [True: 0, False: 0]
  |  Branch (744:35): [True: 0, False: 0]
  ------------------
  745|      0|                    goto error;
  746|      0|                *len = 4;
  747|       |                /* 4-byte code */
  748|      0|                c = (c & 0x7) << 18;
  749|      0|                c |= (utf[1] & 0x3f) << 12;
  750|      0|                c |= (utf[2] & 0x3f) << 6;
  751|      0|                c |= utf[3] & 0x3f;
  752|      0|                if ((c < 0x10000) || (c >= 0x110000))
  ------------------
  |  Branch (752:21): [True: 0, False: 0]
  |  Branch (752:38): [True: 0, False: 0]
  ------------------
  753|      0|                    goto error;
  754|      0|            }
  755|      0|        }
  756|     27|    }
  757|  13.0k|    return(c);
  758|       |
  759|     19|error:
  760|     19|    if (len != NULL)
  ------------------
  |  Branch (760:9): [True: 19, False: 0]
  ------------------
  761|     19|	*len = 0;
  762|     19|    return(-1);
  763|  13.0k|}

xmlUCSIsHalfwidthandFullwidthForms:
 1626|    144|xmlUCSIsHalfwidthandFullwidthForms(int code) {
 1627|    144|    return(((code >= 0xFF00) && (code <= 0xFFEF)));
  ------------------
  |  Branch (1627:13): [True: 0, False: 144]
  |  Branch (1627:33): [True: 0, False: 0]
  ------------------
 1628|    144|}
xmlUCSIsHangulJamo:
 1652|      3|xmlUCSIsHangulJamo(int code) {
 1653|      3|    return(((code >= 0x1100) && (code <= 0x11FF)));
  ------------------
  |  Branch (1653:13): [True: 0, False: 3]
  |  Branch (1653:33): [True: 0, False: 0]
  ------------------
 1654|      3|}
xmlUCSIsTamil:
 2486|      4|xmlUCSIsTamil(int code) {
 2487|      4|    return(((code >= 0x0B80) && (code <= 0x0BFF)));
  ------------------
  |  Branch (2487:13): [True: 0, False: 4]
  |  Branch (2487:33): [True: 0, False: 0]
  ------------------
 2488|      4|}
xmlUCSIsBlock:
 2643|    169|xmlUCSIsBlock(int code, const char *block) {
 2644|    169|    xmlIntFunc *func;
 2645|       |
 2646|    169|    func = xmlUnicodeLookup(&xmlUnicodeBlockTbl, block);
 2647|    169|    if (func == NULL)
  ------------------
  |  Branch (2647:9): [True: 18, False: 151]
  ------------------
 2648|     18|	return (-1);
 2649|    151|    return (func(code));
 2650|    169|}
xmlUCSIsCatNd:
 2881|     73|xmlUCSIsCatNd(int code) {
 2882|     73|    return(xmlCharInRange((unsigned int)code, &xmlNdG));
 2883|     73|}
xmlunicode.c:xmlUnicodeLookup:
  946|    169|*xmlUnicodeLookup(const xmlUnicodeNameTable *tptr, const char *tname) {
  947|    169|    int low, high, mid, cmp;
  948|    169|    const xmlUnicodeRange *sptr;
  949|       |
  950|    169|    if ((tptr == NULL) || (tname == NULL)) return(NULL);
  ------------------
  |  Branch (950:9): [True: 0, False: 169]
  |  Branch (950:27): [True: 0, False: 169]
  ------------------
  951|       |
  952|    169|    low = 0;
  953|    169|    high = tptr->numentries - 1;
  954|    169|    sptr = tptr->table;
  955|  1.20k|    while (low <= high) {
  ------------------
  |  Branch (955:12): [True: 1.18k, False: 18]
  ------------------
  956|  1.18k|	mid = (low + high) / 2;
  957|  1.18k|	if ((cmp=strcmp(tname, sptr[mid].rangename)) == 0)
  ------------------
  |  Branch (957:6): [True: 151, False: 1.03k]
  ------------------
  958|    151|	    return (sptr[mid].func);
  959|  1.03k|	if (cmp < 0)
  ------------------
  |  Branch (959:6): [True: 521, False: 511]
  ------------------
  960|    521|	    high = mid - 1;
  961|    511|	else
  962|    511|	    low = mid + 1;
  963|  1.03k|    }
  964|     18|    return (NULL);
  965|    169|}

xmlInitXPathInternal:
  168|      2|xmlInitXPathInternal(void) {
  169|      2|#if defined(NAN) && defined(INFINITY)
  170|      2|    xmlXPathNAN = NAN;
  171|      2|    xmlXPathPINF = INFINITY;
  172|      2|    xmlXPathNINF = -INFINITY;
  173|       |#else
  174|       |    /* MSVC doesn't allow division by zero in constant expressions. */
  175|       |    double zero = 0.0;
  176|       |    xmlXPathNAN = 0.0 / zero;
  177|       |    xmlXPathPINF = 1.0 / zero;
  178|       |    xmlXPathNINF = -xmlXPathPINF;
  179|       |#endif
  180|      2|}

