xmlSAX2SetDocumentLocator:
  877|    238|{
  878|    238|}
xmlSAX2StartDocument:
  888|    236|{
  889|    236|    xmlParserCtxtPtr ctxt = (xmlParserCtxtPtr) ctx;
  890|    236|    xmlDocPtr doc;
  891|       |
  892|    236|    if (ctx == NULL) return;
  ------------------
  |  Branch (892:9): [True: 0, False: 236]
  ------------------
  893|       |
  894|    236|    if (ctxt->html) {
  ------------------
  |  Branch (894:9): [True: 0, False: 236]
  ------------------
  895|      0|#ifdef LIBXML_HTML_ENABLED
  896|      0|	if (ctxt->myDoc == NULL)
  ------------------
  |  Branch (896:6): [True: 0, False: 0]
  ------------------
  897|      0|	    ctxt->myDoc = htmlNewDocNoDtD(NULL, NULL);
  898|      0|	if (ctxt->myDoc == NULL) {
  ------------------
  |  Branch (898:6): [True: 0, False: 0]
  ------------------
  899|      0|	    xmlSAX2ErrMemory(ctxt, "xmlSAX2StartDocument");
  900|      0|	    return;
  901|      0|	}
  902|      0|	ctxt->myDoc->properties = XML_DOC_HTML;
  903|      0|	ctxt->myDoc->parseFlags = ctxt->options;
  904|       |#else
  905|       |        xmlGenericError(xmlGenericErrorContext,
  906|       |		"libxml2 built without HTML support\n");
  907|       |	ctxt->errNo = XML_ERR_INTERNAL_ERROR;
  908|       |	ctxt->instate = XML_PARSER_EOF;
  909|       |	ctxt->disableSAX = 1;
  910|       |	return;
  911|       |#endif
  912|    236|    } else {
  913|    236|	doc = ctxt->myDoc = xmlNewDoc(ctxt->version);
  914|    236|	if (doc != NULL) {
  ------------------
  |  Branch (914:6): [True: 236, False: 0]
  ------------------
  915|    236|	    doc->properties = 0;
  916|    236|	    if (ctxt->options & XML_PARSE_OLD10)
  ------------------
  |  Branch (916:10): [True: 0, False: 236]
  ------------------
  917|      0|	        doc->properties |= XML_DOC_OLD10;
  918|    236|	    doc->parseFlags = ctxt->options;
  919|    236|	    doc->standalone = ctxt->standalone;
  920|    236|	} else {
  921|      0|	    xmlSAX2ErrMemory(ctxt, "xmlSAX2StartDocument");
  922|      0|	    return;
  923|      0|	}
  924|    236|	if ((ctxt->dictNames) && (doc != NULL)) {
  ------------------
  |  Branch (924:6): [True: 236, False: 0]
  |  Branch (924:27): [True: 236, False: 0]
  ------------------
  925|    236|	    doc->dict = ctxt->dict;
  926|    236|	    xmlDictReference(doc->dict);
  927|    236|	}
  928|    236|    }
  929|    236|    if ((ctxt->myDoc != NULL) && (ctxt->myDoc->URL == NULL) &&
  ------------------
  |  Branch (929:9): [True: 236, False: 0]
  |  Branch (929:34): [True: 236, False: 0]
  ------------------
  930|    236|	(ctxt->input != NULL) && (ctxt->input->filename != NULL)) {
  ------------------
  |  Branch (930:2): [True: 236, False: 0]
  |  Branch (930:27): [True: 236, False: 0]
  ------------------
  931|    236|	ctxt->myDoc->URL = xmlPathToURI((const xmlChar *)ctxt->input->filename);
  932|    236|	if (ctxt->myDoc->URL == NULL)
  ------------------
  |  Branch (932:6): [True: 0, False: 236]
  ------------------
  933|      0|	    xmlSAX2ErrMemory(ctxt, "xmlSAX2StartDocument");
  934|    236|    }
  935|    236|}
xmlSAX2EndDocument:
  945|    238|{
  946|    238|    xmlParserCtxtPtr ctxt = (xmlParserCtxtPtr) ctx;
  947|    238|    xmlDocPtr doc;
  948|       |
  949|    238|    if (ctx == NULL) return;
  ------------------
  |  Branch (949:9): [True: 0, False: 238]
  ------------------
  950|    238|#ifdef LIBXML_VALID_ENABLED
  951|    238|    if (ctxt->validate && ctxt->wellFormed &&
  ------------------
  |  Branch (951:9): [True: 0, False: 238]
  |  Branch (951:27): [True: 0, False: 0]
  ------------------
  952|    238|        ctxt->myDoc && ctxt->myDoc->intSubset)
  ------------------
  |  Branch (952:9): [True: 0, False: 0]
  |  Branch (952:24): [True: 0, False: 0]
  ------------------
  953|      0|	ctxt->valid &= xmlValidateDocumentFinal(&ctxt->vctxt, ctxt->myDoc);
  954|    238|#endif /* LIBXML_VALID_ENABLED */
  955|       |
  956|    238|    doc = ctxt->myDoc;
  957|    238|    if ((doc != NULL) && (doc->encoding == NULL)) {
  ------------------
  |  Branch (957:9): [True: 236, False: 2]
  |  Branch (957:26): [True: 236, False: 0]
  ------------------
  958|    236|        const xmlChar *encoding = NULL;
  959|       |
  960|    236|        if ((ctxt->input->flags & XML_INPUT_USES_ENC_DECL) ||
  ------------------
  |  |   26|    236|#define XML_INPUT_USES_ENC_DECL     (1u << 4)
  ------------------
  |  Branch (960:13): [True: 123, False: 113]
  ------------------
  961|    236|            (ctxt->input->flags & XML_INPUT_AUTO_ENCODING)) {
  ------------------
  |  |   21|    113|#define XML_INPUT_AUTO_ENCODING     (7u << 1)
  ------------------
  |  Branch (961:13): [True: 0, False: 113]
  ------------------
  962|       |            /* Preserve encoding exactly */
  963|    123|            encoding = ctxt->encoding;
  964|    123|        } else if ((ctxt->input->buf) && (ctxt->input->buf->encoder)) {
  ------------------
  |  Branch (964:20): [True: 113, False: 0]
  |  Branch (964:42): [True: 0, False: 113]
  ------------------
  965|      0|            encoding = BAD_CAST ctxt->input->buf->encoder->name;
  ------------------
  |  |   35|      0|#define BAD_CAST (xmlChar *)
  ------------------
  966|    113|        } else if (ctxt->input->flags & XML_INPUT_HAS_ENCODING) {
  ------------------
  |  |   20|    113|#define XML_INPUT_HAS_ENCODING      (1u << 0)
  ------------------
  |  Branch (966:20): [True: 0, False: 113]
  ------------------
  967|      0|            encoding = BAD_CAST "UTF-8";
  ------------------
  |  |   35|      0|#define BAD_CAST (xmlChar *)
  ------------------
  968|      0|        }
  969|       |
  970|    236|        if (encoding != NULL) {
  ------------------
  |  Branch (970:13): [True: 123, False: 113]
  ------------------
  971|    123|            doc->encoding = xmlStrdup(encoding);
  972|    123|            if (doc->encoding == NULL)
  ------------------
  |  Branch (972:17): [True: 0, False: 123]
  ------------------
  973|      0|                xmlSAX2ErrMemory(ctxt, "xmlSAX2EndDocument");
  974|    123|        }
  975|    236|    }
  976|    238|}
xmlSAX2StartElementNs:
 2087|  3.54k|{
 2088|  3.54k|    xmlParserCtxtPtr ctxt = (xmlParserCtxtPtr) ctx;
 2089|  3.54k|    xmlNodePtr ret;
 2090|  3.54k|    xmlNodePtr parent;
 2091|  3.54k|    xmlNsPtr last = NULL, ns;
 2092|  3.54k|    const xmlChar *uri, *pref;
 2093|  3.54k|    xmlChar *lname = NULL;
 2094|  3.54k|    int i, j;
 2095|       |
 2096|  3.54k|    if (ctx == NULL) return;
  ------------------
  |  Branch (2096:9): [True: 0, False: 3.54k]
  ------------------
 2097|       |    /*
 2098|       |     * First check on validity:
 2099|       |     */
 2100|  3.54k|    if (ctxt->validate && (ctxt->myDoc->extSubset == NULL) &&
  ------------------
  |  Branch (2100:9): [True: 0, False: 3.54k]
  |  Branch (2100:27): [True: 0, False: 0]
  ------------------
 2101|  3.54k|        ((ctxt->myDoc->intSubset == NULL) ||
  ------------------
  |  Branch (2101:10): [True: 0, False: 0]
  ------------------
 2102|      0|	 ((ctxt->myDoc->intSubset->notations == NULL) &&
  ------------------
  |  Branch (2102:4): [True: 0, False: 0]
  ------------------
 2103|      0|	  (ctxt->myDoc->intSubset->elements == NULL) &&
  ------------------
  |  Branch (2103:4): [True: 0, False: 0]
  ------------------
 2104|      0|	  (ctxt->myDoc->intSubset->attributes == NULL) &&
  ------------------
  |  Branch (2104:4): [True: 0, False: 0]
  ------------------
 2105|      0|	  (ctxt->myDoc->intSubset->entities == NULL)))) {
  ------------------
  |  Branch (2105:4): [True: 0, False: 0]
  ------------------
 2106|      0|	xmlErrValid(ctxt, XML_DTD_NO_DTD,
 2107|      0|	  "Validation failed: no DTD found !", NULL, NULL);
 2108|      0|	ctxt->validate = 0;
 2109|      0|    }
 2110|       |
 2111|       |    /*
 2112|       |     * Take care of the rare case of an undefined namespace prefix
 2113|       |     */
 2114|  3.54k|    if ((prefix != NULL) && (URI == NULL)) {
  ------------------
  |  Branch (2114:9): [True: 3.29k, False: 250]
  |  Branch (2114:29): [True: 2, False: 3.29k]
  ------------------
 2115|      2|        if (ctxt->dictNames) {
  ------------------
  |  Branch (2115:13): [True: 2, False: 0]
  ------------------
 2116|      2|	    const xmlChar *fullname;
 2117|       |
 2118|      2|	    fullname = xmlDictQLookup(ctxt->dict, prefix, localname);
 2119|      2|	    if (fullname != NULL)
  ------------------
  |  Branch (2119:10): [True: 2, False: 0]
  ------------------
 2120|      2|	        localname = fullname;
 2121|      2|	} else {
 2122|      0|	    lname = xmlBuildQName(localname, prefix, NULL, 0);
 2123|      0|	}
 2124|      2|    }
 2125|       |    /*
 2126|       |     * allocate the node
 2127|       |     */
 2128|  3.54k|    if (ctxt->freeElems != NULL) {
  ------------------
  |  Branch (2128:9): [True: 0, False: 3.54k]
  ------------------
 2129|      0|        ret = ctxt->freeElems;
 2130|      0|	ctxt->freeElems = ret->next;
 2131|      0|	ctxt->freeElemsNr--;
 2132|      0|	memset(ret, 0, sizeof(xmlNode));
 2133|      0|        ret->doc = ctxt->myDoc;
 2134|      0|	ret->type = XML_ELEMENT_NODE;
 2135|       |
 2136|      0|	if (ctxt->dictNames)
  ------------------
  |  Branch (2136:6): [True: 0, False: 0]
  ------------------
 2137|      0|	    ret->name = localname;
 2138|      0|	else {
 2139|      0|	    if (lname == NULL)
  ------------------
  |  Branch (2139:10): [True: 0, False: 0]
  ------------------
 2140|      0|		ret->name = xmlStrdup(localname);
 2141|      0|	    else
 2142|      0|	        ret->name = lname;
 2143|      0|	    if (ret->name == NULL) {
  ------------------
  |  Branch (2143:10): [True: 0, False: 0]
  ------------------
 2144|      0|	        xmlSAX2ErrMemory(ctxt, "xmlSAX2StartElementNs");
 2145|      0|                xmlFree(ret);
 2146|      0|		return;
 2147|      0|	    }
 2148|      0|	}
 2149|      0|	if ((__xmlRegisterCallbacks) && (xmlRegisterNodeDefaultValue))
  ------------------
  |  |  682|      0|    XML_GLOBAL_MACRO(xmlRegisterNodeDefaultValue)
  |  |  ------------------
  |  |  |  |  500|      0|  #define XML_GLOBAL_MACRO(name) (*__##name())
  |  |  ------------------
  ------------------
  |  Branch (2149:6): [True: 0, False: 0]
  |  Branch (2149:34): [True: 0, False: 0]
  ------------------
 2150|      0|	    xmlRegisterNodeDefaultValue(ret);
  ------------------
  |  |  682|      0|    XML_GLOBAL_MACRO(xmlRegisterNodeDefaultValue)
  |  |  ------------------
  |  |  |  |  500|      0|  #define XML_GLOBAL_MACRO(name) (*__##name())
  |  |  ------------------
  ------------------
 2151|  3.54k|    } else {
 2152|  3.54k|	if (ctxt->dictNames)
  ------------------
  |  Branch (2152:6): [True: 3.54k, False: 0]
  ------------------
 2153|  3.54k|	    ret = xmlNewDocNodeEatName(ctxt->myDoc, NULL,
 2154|  3.54k|	                               (xmlChar *) localname, NULL);
 2155|      0|	else if (lname == NULL)
  ------------------
  |  Branch (2155:11): [True: 0, False: 0]
  ------------------
 2156|      0|	    ret = xmlNewDocNode(ctxt->myDoc, NULL, localname, NULL);
 2157|      0|	else
 2158|      0|	    ret = xmlNewDocNodeEatName(ctxt->myDoc, NULL,
 2159|      0|	                               (xmlChar *) lname, NULL);
 2160|  3.54k|	if (ret == NULL) {
  ------------------
  |  Branch (2160:6): [True: 0, False: 3.54k]
  ------------------
 2161|      0|	    xmlSAX2ErrMemory(ctxt, "xmlSAX2StartElementNs");
 2162|      0|	    return;
 2163|      0|	}
 2164|  3.54k|    }
 2165|  3.54k|    if (ctxt->linenumbers) {
  ------------------
  |  Branch (2165:9): [True: 3.54k, False: 0]
  ------------------
 2166|  3.54k|	if (ctxt->input != NULL) {
  ------------------
  |  Branch (2166:6): [True: 3.54k, False: 0]
  ------------------
 2167|  3.54k|	    if ((unsigned) ctxt->input->line < (unsigned) USHRT_MAX)
  ------------------
  |  Branch (2167:10): [True: 3.54k, False: 0]
  ------------------
 2168|  3.54k|		ret->line = ctxt->input->line;
 2169|      0|	    else
 2170|      0|	        ret->line = USHRT_MAX;
 2171|  3.54k|	}
 2172|  3.54k|    }
 2173|       |
 2174|       |    /*
 2175|       |     * Build the namespace list
 2176|       |     */
 2177|  3.91k|    for (i = 0,j = 0;j < nb_namespaces;j++) {
  ------------------
  |  Branch (2177:22): [True: 377, False: 3.54k]
  ------------------
 2178|    377|        pref = namespaces[i++];
 2179|    377|	uri = namespaces[i++];
 2180|    377|	ns = xmlNewNs(NULL, uri, pref);
 2181|    377|	if (ns != NULL) {
  ------------------
  |  Branch (2181:6): [True: 377, False: 0]
  ------------------
 2182|    377|	    if (last == NULL) {
  ------------------
  |  Branch (2182:10): [True: 233, False: 144]
  ------------------
 2183|    233|	        ret->nsDef = last = ns;
 2184|    233|	    } else {
 2185|    144|	        last->next = ns;
 2186|    144|		last = ns;
 2187|    144|	    }
 2188|    377|	    if ((URI != NULL) && (prefix == pref))
  ------------------
  |  Branch (2188:10): [True: 377, False: 0]
  |  Branch (2188:27): [True: 231, False: 146]
  ------------------
 2189|    231|		ret->ns = ns;
 2190|    377|	} else {
 2191|       |            /*
 2192|       |             * any out of memory error would already have been raised
 2193|       |             * but we can't be guaranteed it's the actual error due to the
 2194|       |             * API, best is to skip in this case
 2195|       |             */
 2196|      0|	    continue;
 2197|      0|	}
 2198|       |
 2199|    377|        xmlParserNsUpdateSax(ctxt, pref, ns);
 2200|       |
 2201|    377|#ifdef LIBXML_VALID_ENABLED
 2202|    377|	if ((!ctxt->html) && ctxt->validate && ctxt->wellFormed &&
  ------------------
  |  Branch (2202:6): [True: 377, False: 0]
  |  Branch (2202:23): [True: 0, False: 377]
  |  Branch (2202:41): [True: 0, False: 0]
  ------------------
 2203|    377|	    ctxt->myDoc && ctxt->myDoc->intSubset) {
  ------------------
  |  Branch (2203:6): [True: 0, False: 0]
  |  Branch (2203:21): [True: 0, False: 0]
  ------------------
 2204|      0|	    ctxt->valid &= xmlValidateOneNamespace(&ctxt->vctxt, ctxt->myDoc,
 2205|      0|	                                           ret, prefix, ns, uri);
 2206|      0|	}
 2207|    377|#endif /* LIBXML_VALID_ENABLED */
 2208|    377|    }
 2209|  3.54k|    ctxt->nodemem = -1;
 2210|       |
 2211|       |    /* Initialize parent before pushing node */
 2212|  3.54k|    parent = ctxt->node;
 2213|  3.54k|    if (parent == NULL)
  ------------------
  |  Branch (2213:9): [True: 229, False: 3.31k]
  ------------------
 2214|    229|        parent = (xmlNodePtr) ctxt->myDoc;
 2215|       |
 2216|       |    /*
 2217|       |     * We are parsing a new node.
 2218|       |     */
 2219|  3.54k|    if (nodePush(ctxt, ret) < 0) {
  ------------------
  |  Branch (2219:9): [True: 0, False: 3.54k]
  ------------------
 2220|      0|        xmlUnlinkNode(ret);
 2221|      0|        xmlFreeNode(ret);
 2222|      0|        return;
 2223|      0|    }
 2224|       |
 2225|       |    /*
 2226|       |     * Link the child element
 2227|       |     */
 2228|  3.54k|    xmlAddChild(parent, ret);
 2229|       |
 2230|       |    /*
 2231|       |     * Insert the defaulted attributes from the DTD only if requested:
 2232|       |     */
 2233|  3.54k|    if ((nb_defaulted != 0) &&
  ------------------
  |  Branch (2233:9): [True: 0, False: 3.54k]
  ------------------
 2234|  3.54k|        ((ctxt->loadsubset & XML_COMPLETE_ATTRS) == 0))
  ------------------
  |  |  150|      0|#define XML_COMPLETE_ATTRS	4
  ------------------
  |  Branch (2234:9): [True: 0, False: 0]
  ------------------
 2235|      0|	nb_attributes -= nb_defaulted;
 2236|       |
 2237|       |    /*
 2238|       |     * Search the namespace if it wasn't already found
 2239|       |     * Note that, if prefix is NULL, this searches for the default Ns
 2240|       |     */
 2241|  3.54k|    if ((URI != NULL) && (ret->ns == NULL)) {
  ------------------
  |  Branch (2241:9): [True: 3.54k, False: 2]
  |  Branch (2241:26): [True: 3.30k, False: 231]
  ------------------
 2242|  3.30k|        ret->ns = xmlParserNsLookupSax(ctxt, prefix);
 2243|  3.30k|	if ((ret->ns == NULL) && (xmlStrEqual(prefix, BAD_CAST "xml"))) {
  ------------------
  |  |   35|      0|#define BAD_CAST (xmlChar *)
  ------------------
  |  Branch (2243:6): [True: 0, False: 3.30k]
  |  Branch (2243:27): [True: 0, False: 0]
  ------------------
 2244|      0|	    ret->ns = xmlSearchNs(ctxt->myDoc, ret, prefix);
 2245|      0|	}
 2246|  3.30k|	if (ret->ns == NULL) {
  ------------------
  |  Branch (2246:6): [True: 0, False: 3.30k]
  ------------------
 2247|      0|	    ns = xmlNewNs(ret, NULL, prefix);
 2248|      0|	    if (ns == NULL) {
  ------------------
  |  Branch (2248:10): [True: 0, False: 0]
  ------------------
 2249|       |
 2250|      0|	        xmlSAX2ErrMemory(ctxt, "xmlSAX2StartElementNs");
 2251|      0|		return;
 2252|      0|	    }
 2253|      0|            if (prefix != NULL)
  ------------------
  |  Branch (2253:17): [True: 0, False: 0]
  ------------------
 2254|      0|                xmlNsWarnMsg(ctxt, XML_NS_ERR_UNDEFINED_NAMESPACE,
 2255|      0|                             "Namespace prefix %s was not found\n",
 2256|      0|                             prefix, NULL);
 2257|      0|            else
 2258|      0|                xmlNsWarnMsg(ctxt, XML_NS_ERR_UNDEFINED_NAMESPACE,
 2259|      0|                             "Namespace default prefix was not found\n",
 2260|      0|                             NULL, NULL);
 2261|      0|	}
 2262|  3.30k|    }
 2263|       |
 2264|       |    /*
 2265|       |     * process all the other attributes
 2266|       |     */
 2267|  3.54k|    if (nb_attributes > 0) {
  ------------------
  |  Branch (2267:9): [True: 2.60k, False: 934]
  ------------------
 2268|  2.60k|        xmlAttrPtr prev = NULL;
 2269|       |
 2270|  6.57k|        for (j = 0,i = 0;i < nb_attributes;i++,j+=5) {
  ------------------
  |  Branch (2270:26): [True: 3.96k, False: 2.60k]
  ------------------
 2271|  3.96k|            xmlAttrPtr attr = NULL;
 2272|       |
 2273|       |	    /*
 2274|       |	     * Handle the rare case of an undefined attribute prefix
 2275|       |	     */
 2276|  3.96k|	    if ((attributes[j+1] != NULL) && (attributes[j+2] == NULL)) {
  ------------------
  |  Branch (2276:10): [True: 48, False: 3.91k]
  |  Branch (2276:39): [True: 0, False: 48]
  ------------------
 2277|      0|		if (ctxt->dictNames) {
  ------------------
  |  Branch (2277:7): [True: 0, False: 0]
  ------------------
 2278|      0|		    const xmlChar *fullname;
 2279|       |
 2280|      0|		    fullname = xmlDictQLookup(ctxt->dict, attributes[j+1],
 2281|      0|		                              attributes[j]);
 2282|      0|		    if (fullname != NULL) {
  ------------------
  |  Branch (2282:11): [True: 0, False: 0]
  ------------------
 2283|      0|                        attr = xmlSAX2AttributeNs(ctxt, fullname, NULL,
 2284|      0|                                                  attributes[j+3],
 2285|      0|                                                  attributes[j+4]);
 2286|      0|                        goto have_attr;
 2287|      0|		    }
 2288|      0|		} else {
 2289|      0|		    lname = xmlBuildQName(attributes[j], attributes[j+1],
 2290|      0|		                          NULL, 0);
 2291|      0|		    if (lname != NULL) {
  ------------------
  |  Branch (2291:11): [True: 0, False: 0]
  ------------------
 2292|      0|                        attr = xmlSAX2AttributeNs(ctxt, lname, NULL,
 2293|      0|                                                  attributes[j+3],
 2294|      0|                                                  attributes[j+4]);
 2295|      0|			xmlFree(lname);
 2296|      0|                        goto have_attr;
 2297|      0|		    }
 2298|      0|		}
 2299|      0|	    }
 2300|  3.96k|            attr = xmlSAX2AttributeNs(ctxt, attributes[j], attributes[j+1],
 2301|  3.96k|                                      attributes[j+3], attributes[j+4]);
 2302|  3.96k|have_attr:
 2303|  3.96k|            if (attr == NULL)
  ------------------
  |  Branch (2303:17): [True: 0, False: 3.96k]
  ------------------
 2304|      0|                continue;
 2305|       |
 2306|       |            /* link at the end to preserve order */
 2307|  3.96k|            if (prev == NULL) {
  ------------------
  |  Branch (2307:17): [True: 2.60k, False: 1.35k]
  ------------------
 2308|  2.60k|                ctxt->node->properties = attr;
 2309|  2.60k|            } else {
 2310|  1.35k|                prev->next = attr;
 2311|  1.35k|                attr->prev = prev;
 2312|  1.35k|            }
 2313|       |
 2314|  3.96k|            prev = attr;
 2315|  3.96k|	}
 2316|  2.60k|    }
 2317|       |
 2318|  3.54k|#ifdef LIBXML_VALID_ENABLED
 2319|       |    /*
 2320|       |     * If it's the Document root, finish the DTD validation and
 2321|       |     * check the document root element for validity
 2322|       |     */
 2323|  3.54k|    if ((ctxt->validate) &&
  ------------------
  |  Branch (2323:9): [True: 0, False: 3.54k]
  ------------------
 2324|  3.54k|        ((ctxt->vctxt.flags & XML_VCTXT_DTD_VALIDATED) == 0)) {
  ------------------
  |  |   12|      0|#define XML_VCTXT_DTD_VALIDATED (1u << 0)
  ------------------
  |  Branch (2324:9): [True: 0, False: 0]
  ------------------
 2325|      0|	int chk;
 2326|       |
 2327|      0|	chk = xmlValidateDtdFinal(&ctxt->vctxt, ctxt->myDoc);
 2328|      0|	if (chk <= 0)
  ------------------
  |  Branch (2328:6): [True: 0, False: 0]
  ------------------
 2329|      0|	    ctxt->valid = 0;
 2330|      0|	if (chk < 0)
  ------------------
  |  Branch (2330:6): [True: 0, False: 0]
  ------------------
 2331|      0|	    ctxt->wellFormed = 0;
 2332|      0|	ctxt->valid &= xmlValidateRoot(&ctxt->vctxt, ctxt->myDoc);
 2333|      0|	ctxt->vctxt.flags |= XML_VCTXT_DTD_VALIDATED;
  ------------------
  |  |   12|      0|#define XML_VCTXT_DTD_VALIDATED (1u << 0)
  ------------------
 2334|      0|    }
 2335|  3.54k|#endif /* LIBXML_VALID_ENABLED */
 2336|  3.54k|}
xmlSAX2EndElementNs:
 2353|  3.48k|{
 2354|  3.48k|    xmlParserCtxtPtr ctxt = (xmlParserCtxtPtr) ctx;
 2355|       |
 2356|  3.48k|    if (ctx == NULL) return;
  ------------------
  |  Branch (2356:9): [True: 0, False: 3.48k]
  ------------------
 2357|  3.48k|    ctxt->nodemem = -1;
 2358|       |
 2359|  3.48k|#ifdef LIBXML_VALID_ENABLED
 2360|  3.48k|    if (ctxt->validate && ctxt->wellFormed &&
  ------------------
  |  Branch (2360:9): [True: 0, False: 3.48k]
  |  Branch (2360:27): [True: 0, False: 0]
  ------------------
 2361|  3.48k|        ctxt->myDoc && ctxt->myDoc->intSubset)
  ------------------
  |  Branch (2361:9): [True: 0, False: 0]
  |  Branch (2361:24): [True: 0, False: 0]
  ------------------
 2362|      0|        ctxt->valid &= xmlValidateOneElement(&ctxt->vctxt, ctxt->myDoc,
 2363|      0|                                             ctxt->node);
 2364|  3.48k|#endif /* LIBXML_VALID_ENABLED */
 2365|       |
 2366|       |    /*
 2367|       |     * end of parsing of this node.
 2368|       |     */
 2369|  3.48k|    nodePop(ctxt);
 2370|  3.48k|}
xmlSAX2Characters:
 2541|  5.61k|{
 2542|  5.61k|    xmlSAX2Text((xmlParserCtxtPtr) ctx, ch, len, XML_TEXT_NODE);
 2543|  5.61k|}
xmlSAX2Comment:
 2616|    184|{
 2617|    184|    xmlParserCtxtPtr ctxt = (xmlParserCtxtPtr) ctx;
 2618|    184|    xmlNodePtr ret;
 2619|    184|    xmlNodePtr parent;
 2620|       |
 2621|    184|    if (ctx == NULL) return;
  ------------------
  |  Branch (2621:9): [True: 0, False: 184]
  ------------------
 2622|    184|    parent = ctxt->node;
 2623|    184|    ret = xmlNewDocComment(ctxt->myDoc, value);
 2624|    184|    if (ret == NULL) return;
  ------------------
  |  Branch (2624:9): [True: 0, False: 184]
  ------------------
 2625|    184|    if (ctxt->linenumbers) {
  ------------------
  |  Branch (2625:9): [True: 184, False: 0]
  ------------------
 2626|    184|	if (ctxt->input != NULL) {
  ------------------
  |  Branch (2626:6): [True: 184, False: 0]
  ------------------
 2627|    184|	    if ((unsigned) ctxt->input->line < (unsigned) USHRT_MAX)
  ------------------
  |  Branch (2627:10): [True: 184, False: 0]
  ------------------
 2628|    184|		ret->line = ctxt->input->line;
 2629|      0|	    else
 2630|      0|	        ret->line = USHRT_MAX;
 2631|    184|	}
 2632|    184|    }
 2633|       |
 2634|    184|    if (ctxt->inSubset == 1) {
  ------------------
  |  Branch (2634:9): [True: 0, False: 184]
  ------------------
 2635|      0|	xmlAddChild((xmlNodePtr) ctxt->myDoc->intSubset, ret);
 2636|      0|	return;
 2637|    184|    } else if (ctxt->inSubset == 2) {
  ------------------
  |  Branch (2637:16): [True: 0, False: 184]
  ------------------
 2638|      0|	xmlAddChild((xmlNodePtr) ctxt->myDoc->extSubset, ret);
 2639|      0|	return;
 2640|      0|    }
 2641|    184|    if (parent == NULL) {
  ------------------
  |  Branch (2641:9): [True: 73, False: 111]
  ------------------
 2642|     73|        xmlAddChild((xmlNodePtr) ctxt->myDoc, (xmlNodePtr) ret);
 2643|     73|	return;
 2644|     73|    }
 2645|    111|    if (parent->type == XML_ELEMENT_NODE) {
  ------------------
  |  Branch (2645:9): [True: 111, False: 0]
  ------------------
 2646|    111|	xmlAddChild(parent, ret);
 2647|    111|    } else {
 2648|      0|	xmlAddSibling(parent, ret);
 2649|      0|    }
 2650|    111|}
xmlSAXVersion:
 2706|    242|{
 2707|    242|    if (hdlr == NULL) return(-1);
  ------------------
  |  Branch (2707:9): [True: 0, False: 242]
  ------------------
 2708|    242|    if (version == 2) {
  ------------------
  |  Branch (2708:9): [True: 242, False: 0]
  ------------------
 2709|    242|	hdlr->startElementNs = xmlSAX2StartElementNs;
 2710|    242|	hdlr->endElementNs = xmlSAX2EndElementNs;
 2711|    242|	hdlr->serror = NULL;
 2712|    242|	hdlr->initialized = XML_SAX2_MAGIC;
  ------------------
  |  |  685|    242|#define XML_SAX2_MAGIC 0xDEEDBEAF
  ------------------
 2713|    242|#ifdef LIBXML_SAX1_ENABLED
 2714|    242|    } else if (version == 1) {
  ------------------
  |  Branch (2714:16): [True: 0, False: 0]
  ------------------
 2715|      0|	hdlr->initialized = 1;
 2716|      0|#endif /* LIBXML_SAX1_ENABLED */
 2717|      0|    } else
 2718|      0|        return(-1);
 2719|    242|#ifdef LIBXML_SAX1_ENABLED
 2720|    242|    hdlr->startElement = xmlSAX2StartElement;
 2721|    242|    hdlr->endElement = xmlSAX2EndElement;
 2722|       |#else
 2723|       |    hdlr->startElement = NULL;
 2724|       |    hdlr->endElement = NULL;
 2725|       |#endif /* LIBXML_SAX1_ENABLED */
 2726|    242|    hdlr->internalSubset = xmlSAX2InternalSubset;
 2727|    242|    hdlr->externalSubset = xmlSAX2ExternalSubset;
 2728|    242|    hdlr->isStandalone = xmlSAX2IsStandalone;
 2729|    242|    hdlr->hasInternalSubset = xmlSAX2HasInternalSubset;
 2730|    242|    hdlr->hasExternalSubset = xmlSAX2HasExternalSubset;
 2731|    242|    hdlr->resolveEntity = xmlSAX2ResolveEntity;
 2732|    242|    hdlr->getEntity = xmlSAX2GetEntity;
 2733|    242|    hdlr->getParameterEntity = xmlSAX2GetParameterEntity;
 2734|    242|    hdlr->entityDecl = xmlSAX2EntityDecl;
 2735|    242|    hdlr->attributeDecl = xmlSAX2AttributeDecl;
 2736|    242|    hdlr->elementDecl = xmlSAX2ElementDecl;
 2737|    242|    hdlr->notationDecl = xmlSAX2NotationDecl;
 2738|    242|    hdlr->unparsedEntityDecl = xmlSAX2UnparsedEntityDecl;
 2739|    242|    hdlr->setDocumentLocator = xmlSAX2SetDocumentLocator;
 2740|    242|    hdlr->startDocument = xmlSAX2StartDocument;
 2741|    242|    hdlr->endDocument = xmlSAX2EndDocument;
 2742|    242|    hdlr->reference = xmlSAX2Reference;
 2743|    242|    hdlr->characters = xmlSAX2Characters;
 2744|    242|    hdlr->cdataBlock = xmlSAX2CDataBlock;
 2745|    242|    hdlr->ignorableWhitespace = xmlSAX2Characters;
 2746|    242|    hdlr->processingInstruction = xmlSAX2ProcessingInstruction;
 2747|    242|    hdlr->comment = xmlSAX2Comment;
 2748|    242|    hdlr->warning = xmlParserWarning;
 2749|    242|    hdlr->error = xmlParserError;
 2750|    242|    hdlr->fatalError = xmlParserError;
 2751|       |
 2752|    242|    return(0);
 2753|    242|}
SAX2.c:xmlSAX2AttributeNs:
 1867|  3.96k|{
 1868|  3.96k|    xmlAttrPtr ret;
 1869|  3.96k|    xmlNsPtr namespace = NULL;
 1870|  3.96k|    xmlChar *dup = NULL;
 1871|       |
 1872|       |    /*
 1873|       |     * Note: if prefix == NULL, the attribute is not in the default namespace
 1874|       |     */
 1875|  3.96k|    if (prefix != NULL) {
  ------------------
  |  Branch (1875:9): [True: 48, False: 3.91k]
  ------------------
 1876|     48|	namespace = xmlParserNsLookupSax(ctxt, prefix);
 1877|     48|	if ((namespace == NULL) && (xmlStrEqual(prefix, BAD_CAST "xml"))) {
  ------------------
  |  |   35|     24|#define BAD_CAST (xmlChar *)
  ------------------
  |  Branch (1877:6): [True: 24, False: 24]
  |  Branch (1877:29): [True: 24, False: 0]
  ------------------
 1878|     24|	    namespace = xmlSearchNs(ctxt->myDoc, ctxt->node, prefix);
 1879|     24|	}
 1880|     48|    }
 1881|       |
 1882|       |    /*
 1883|       |     * allocate the node
 1884|       |     */
 1885|  3.96k|    if (ctxt->freeAttrs != NULL) {
  ------------------
  |  Branch (1885:9): [True: 0, False: 3.96k]
  ------------------
 1886|      0|        ret = ctxt->freeAttrs;
 1887|      0|	ctxt->freeAttrs = ret->next;
 1888|      0|	ctxt->freeAttrsNr--;
 1889|  3.96k|    } else {
 1890|  3.96k|        ret = xmlMalloc(sizeof(*ret));
 1891|  3.96k|        if (ret == NULL) {
  ------------------
  |  Branch (1891:13): [True: 0, False: 3.96k]
  ------------------
 1892|      0|            xmlSAX2ErrMemory(ctxt, NULL);
 1893|      0|            return(NULL);
 1894|      0|        }
 1895|  3.96k|    }
 1896|       |
 1897|  3.96k|    memset(ret, 0, sizeof(xmlAttr));
 1898|  3.96k|    ret->type = XML_ATTRIBUTE_NODE;
 1899|       |
 1900|  3.96k|    ret->parent = ctxt->node;
 1901|  3.96k|    ret->doc = ctxt->myDoc;
 1902|  3.96k|    ret->ns = namespace;
 1903|       |
 1904|  3.96k|    if (ctxt->dictNames)
  ------------------
  |  Branch (1904:9): [True: 3.96k, False: 0]
  ------------------
 1905|  3.96k|        ret->name = localname;
 1906|      0|    else
 1907|      0|        ret->name = xmlStrdup(localname);
 1908|       |
 1909|  3.96k|    if ((__xmlRegisterCallbacks) && (xmlRegisterNodeDefaultValue))
  ------------------
  |  |  682|      0|    XML_GLOBAL_MACRO(xmlRegisterNodeDefaultValue)
  |  |  ------------------
  |  |  |  |  500|      0|  #define XML_GLOBAL_MACRO(name) (*__##name())
  |  |  ------------------
  ------------------
  |  Branch (1909:9): [True: 0, False: 3.96k]
  |  Branch (1909:37): [True: 0, False: 0]
  ------------------
 1910|      0|        xmlRegisterNodeDefaultValue((xmlNodePtr)ret);
  ------------------
  |  |  682|      0|    XML_GLOBAL_MACRO(xmlRegisterNodeDefaultValue)
  |  |  ------------------
  |  |  |  |  500|      0|  #define XML_GLOBAL_MACRO(name) (*__##name())
  |  |  ------------------
  ------------------
 1911|       |
 1912|  3.96k|    if ((ctxt->replaceEntities == 0) && (!ctxt->html)) {
  ------------------
  |  Branch (1912:9): [True: 0, False: 3.96k]
  |  Branch (1912:41): [True: 0, False: 0]
  ------------------
 1913|      0|	xmlNodePtr tmp;
 1914|       |
 1915|       |	/*
 1916|       |	 * We know that if there is an entity reference, then
 1917|       |	 * the string has been dup'ed and terminates with 0
 1918|       |	 * otherwise with ' or "
 1919|       |	 */
 1920|      0|	if (*valueend != 0) {
  ------------------
  |  Branch (1920:6): [True: 0, False: 0]
  ------------------
 1921|      0|	    tmp = xmlSAX2TextNode(ctxt, value, valueend - value);
 1922|      0|	    ret->children = tmp;
 1923|      0|	    ret->last = tmp;
 1924|      0|	    if (tmp != NULL) {
  ------------------
  |  Branch (1924:10): [True: 0, False: 0]
  ------------------
 1925|      0|		tmp->doc = ret->doc;
 1926|      0|		tmp->parent = (xmlNodePtr) ret;
 1927|      0|	    }
 1928|      0|	} else {
 1929|      0|	    ret->children = xmlStringLenGetNodeList(ctxt->myDoc, value,
 1930|      0|						    valueend - value);
 1931|      0|	    tmp = ret->children;
 1932|      0|	    while (tmp != NULL) {
  ------------------
  |  Branch (1932:13): [True: 0, False: 0]
  ------------------
 1933|      0|	        tmp->doc = ret->doc;
 1934|      0|		tmp->parent = (xmlNodePtr) ret;
 1935|      0|		if (tmp->next == NULL)
  ------------------
  |  Branch (1935:7): [True: 0, False: 0]
  ------------------
 1936|      0|		    ret->last = tmp;
 1937|      0|		tmp = tmp->next;
 1938|      0|	    }
 1939|      0|	}
 1940|  3.96k|    } else if (value != NULL) {
  ------------------
  |  Branch (1940:16): [True: 3.96k, False: 0]
  ------------------
 1941|  3.96k|	xmlNodePtr tmp;
 1942|       |
 1943|  3.96k|	tmp = xmlSAX2TextNode(ctxt, value, valueend - value);
 1944|  3.96k|	ret->children = tmp;
 1945|  3.96k|	ret->last = tmp;
 1946|  3.96k|	if (tmp != NULL) {
  ------------------
  |  Branch (1946:6): [True: 3.96k, False: 0]
  ------------------
 1947|  3.96k|	    tmp->doc = ret->doc;
 1948|  3.96k|	    tmp->parent = (xmlNodePtr) ret;
 1949|  3.96k|	}
 1950|  3.96k|    }
 1951|       |
 1952|  3.96k|#ifdef LIBXML_VALID_ENABLED
 1953|  3.96k|    if ((!ctxt->html) && ctxt->validate && ctxt->wellFormed &&
  ------------------
  |  Branch (1953:9): [True: 3.96k, False: 0]
  |  Branch (1953:26): [True: 0, False: 3.96k]
  |  Branch (1953:44): [True: 0, False: 0]
  ------------------
 1954|  3.96k|        ctxt->myDoc && ctxt->myDoc->intSubset) {
  ------------------
  |  Branch (1954:9): [True: 0, False: 0]
  |  Branch (1954:24): [True: 0, False: 0]
  ------------------
 1955|       |	/*
 1956|       |	 * If we don't substitute entities, the validation should be
 1957|       |	 * done on a value with replaced entities anyway.
 1958|       |	 */
 1959|      0|        if (!ctxt->replaceEntities) {
  ------------------
  |  Branch (1959:13): [True: 0, False: 0]
  ------------------
 1960|      0|	    dup = xmlSAX2DecodeAttrEntities(ctxt, value, valueend);
 1961|      0|	    if (dup == NULL) {
  ------------------
  |  Branch (1961:10): [True: 0, False: 0]
  ------------------
 1962|      0|	        if (*valueend == 0) {
  ------------------
  |  Branch (1962:14): [True: 0, False: 0]
  ------------------
 1963|      0|		    ctxt->valid &= xmlValidateOneAttribute(&ctxt->vctxt,
 1964|      0|				    ctxt->myDoc, ctxt->node, ret, value);
 1965|      0|		} else {
 1966|       |		    /*
 1967|       |		     * That should already be normalized.
 1968|       |		     * cheaper to finally allocate here than duplicate
 1969|       |		     * entry points in the full validation code
 1970|       |		     */
 1971|      0|		    dup = xmlStrndup(value, valueend - value);
 1972|       |
 1973|      0|		    ctxt->valid &= xmlValidateOneAttribute(&ctxt->vctxt,
 1974|      0|				    ctxt->myDoc, ctxt->node, ret, dup);
 1975|      0|		}
 1976|      0|	    } else {
 1977|       |	        /*
 1978|       |		 * dup now contains a string of the flattened attribute
 1979|       |		 * content with entities substituted. Check if we need to
 1980|       |		 * apply an extra layer of normalization.
 1981|       |		 * It need to be done twice ... it's an extra burden related
 1982|       |		 * to the ability to keep references in attributes
 1983|       |		 */
 1984|      0|		if (ctxt->attsSpecial != NULL) {
  ------------------
  |  Branch (1984:7): [True: 0, False: 0]
  ------------------
 1985|      0|		    xmlChar *nvalnorm;
 1986|      0|		    xmlChar fn[50];
 1987|      0|		    xmlChar *fullname;
 1988|       |
 1989|      0|		    fullname = xmlBuildQName(localname, prefix, fn, 50);
 1990|      0|		    if (fullname != NULL) {
  ------------------
  |  Branch (1990:11): [True: 0, False: 0]
  ------------------
 1991|      0|			ctxt->vctxt.valid = 1;
 1992|      0|		        nvalnorm = xmlValidCtxtNormalizeAttributeValue(
 1993|      0|			                 &ctxt->vctxt, ctxt->myDoc,
 1994|      0|					 ctxt->node, fullname, dup);
 1995|      0|			if (ctxt->vctxt.valid != 1)
  ------------------
  |  Branch (1995:8): [True: 0, False: 0]
  ------------------
 1996|      0|			    ctxt->valid = 0;
 1997|       |
 1998|      0|			if ((fullname != fn) && (fullname != localname))
  ------------------
  |  Branch (1998:8): [True: 0, False: 0]
  |  Branch (1998:28): [True: 0, False: 0]
  ------------------
 1999|      0|			    xmlFree(fullname);
 2000|      0|			if (nvalnorm != NULL) {
  ------------------
  |  Branch (2000:8): [True: 0, False: 0]
  ------------------
 2001|      0|			    xmlFree(dup);
 2002|      0|			    dup = nvalnorm;
 2003|      0|			}
 2004|      0|		    }
 2005|      0|		}
 2006|       |
 2007|      0|		ctxt->valid &= xmlValidateOneAttribute(&ctxt->vctxt,
 2008|      0|			        ctxt->myDoc, ctxt->node, ret, dup);
 2009|      0|	    }
 2010|      0|	} else {
 2011|       |	    /*
 2012|       |	     * if entities already have been substituted, then
 2013|       |	     * the attribute as passed is already normalized
 2014|       |	     */
 2015|      0|	    dup = xmlStrndup(value, valueend - value);
 2016|       |
 2017|      0|	    ctxt->valid &= xmlValidateOneAttribute(&ctxt->vctxt,
 2018|      0|	                             ctxt->myDoc, ctxt->node, ret, dup);
 2019|      0|	}
 2020|      0|    } else
 2021|  3.96k|#endif /* LIBXML_VALID_ENABLED */
 2022|  3.96k|           if (((ctxt->loadsubset & XML_SKIP_IDS) == 0) &&
  ------------------
  |  |  158|  3.96k|#define XML_SKIP_IDS		8
  ------------------
  |  Branch (2022:16): [True: 3.96k, False: 0]
  ------------------
 2023|  3.96k|	       (((ctxt->replaceEntities == 0) && (ctxt->external != 2)) ||
  ------------------
  |  Branch (2023:11): [True: 0, False: 3.96k]
  |  Branch (2023:43): [True: 0, False: 0]
  ------------------
 2024|  3.96k|	        ((ctxt->replaceEntities != 0) && (ctxt->inSubset == 0))) &&
  ------------------
  |  Branch (2024:11): [True: 3.96k, False: 0]
  |  Branch (2024:43): [True: 3.96k, False: 0]
  ------------------
 2025|       |               /* Don't create IDs containing entity references */
 2026|  3.96k|               (ret->children != NULL) &&
  ------------------
  |  Branch (2026:16): [True: 3.96k, False: 0]
  ------------------
 2027|  3.96k|               (ret->children->type == XML_TEXT_NODE) &&
  ------------------
  |  Branch (2027:16): [True: 3.96k, False: 0]
  ------------------
 2028|  3.96k|               (ret->children->next == NULL)) {
  ------------------
  |  Branch (2028:16): [True: 3.96k, False: 0]
  ------------------
 2029|  3.96k|        xmlChar *content = ret->children->content;
 2030|       |        /*
 2031|       |	 * when validating, the ID registration is done at the attribute
 2032|       |	 * validation level. Otherwise we have to do specific handling here.
 2033|       |	 */
 2034|  3.96k|        if ((prefix == ctxt->str_xml) &&
  ------------------
  |  Branch (2034:13): [True: 24, False: 3.93k]
  ------------------
 2035|  3.96k|	           (localname[0] == 'i') && (localname[1] == 'd') &&
  ------------------
  |  Branch (2035:13): [True: 0, False: 24]
  |  Branch (2035:38): [True: 0, False: 0]
  ------------------
 2036|  3.96k|		   (localname[2] == 0)) {
  ------------------
  |  Branch (2036:6): [True: 0, False: 0]
  ------------------
 2037|       |	    /*
 2038|       |	     * Add the xml:id value
 2039|       |	     *
 2040|       |	     * Open issue: normalization of the value.
 2041|       |	     */
 2042|      0|	    if (xmlValidateNCName(content, 1) != 0) {
  ------------------
  |  Branch (2042:10): [True: 0, False: 0]
  ------------------
 2043|      0|	        xmlErrValid(ctxt, XML_DTD_XMLID_VALUE,
 2044|      0|		      "xml:id : attribute value %s is not an NCName\n",
 2045|      0|			    (const char *) content, NULL);
 2046|      0|	    }
 2047|      0|	    xmlAddID(&ctxt->vctxt, ctxt->myDoc, content, ret);
 2048|  3.96k|	} else if (xmlIsID(ctxt->myDoc, ctxt->node, ret)) {
  ------------------
  |  Branch (2048:13): [True: 0, False: 3.96k]
  ------------------
 2049|      0|	    xmlAddID(&ctxt->vctxt, ctxt->myDoc, content, ret);
 2050|  3.96k|	} else if (xmlIsRef(ctxt->myDoc, ctxt->node, ret)) {
  ------------------
  |  Branch (2050:13): [True: 0, False: 3.96k]
  ------------------
 2051|      0|	    xmlAddRef(&ctxt->vctxt, ctxt->myDoc, content, ret);
 2052|      0|	}
 2053|  3.96k|    }
 2054|  3.96k|    if (dup != NULL)
  ------------------
  |  Branch (2054:9): [True: 0, False: 3.96k]
  ------------------
 2055|      0|	xmlFree(dup);
 2056|       |
 2057|  3.96k|    return(ret);
 2058|  3.96k|}
SAX2.c:xmlSAX2TextNode:
 1749|  9.41k|xmlSAX2TextNode(xmlParserCtxtPtr ctxt, const xmlChar *str, int len) {
 1750|  9.41k|    xmlNodePtr ret;
 1751|  9.41k|    const xmlChar *intern = NULL;
 1752|       |
 1753|       |    /*
 1754|       |     * Allocate
 1755|       |     */
 1756|  9.41k|    if (ctxt->freeElems != NULL) {
  ------------------
  |  Branch (1756:9): [True: 0, False: 9.41k]
  ------------------
 1757|      0|	ret = ctxt->freeElems;
 1758|      0|	ctxt->freeElems = ret->next;
 1759|      0|	ctxt->freeElemsNr--;
 1760|  9.41k|    } else {
 1761|  9.41k|	ret = (xmlNodePtr) xmlMalloc(sizeof(xmlNode));
 1762|  9.41k|    }
 1763|  9.41k|    if (ret == NULL) {
  ------------------
  |  Branch (1763:9): [True: 0, False: 9.41k]
  ------------------
 1764|      0|        xmlErrMemory(ctxt, "xmlSAX2Characters");
 1765|      0|	return(NULL);
 1766|      0|    }
 1767|  9.41k|    memset(ret, 0, sizeof(xmlNode));
 1768|       |    /*
 1769|       |     * intern the formatting blanks found between tags, or the
 1770|       |     * very short strings
 1771|       |     */
 1772|  9.41k|    if (ctxt->dictNames) {
  ------------------
  |  Branch (1772:9): [True: 9.41k, False: 0]
  ------------------
 1773|  9.41k|        xmlChar cur = str[len];
 1774|       |
 1775|  9.41k|	if ((len < (int) (2 * sizeof(void *))) &&
  ------------------
  |  Branch (1775:6): [True: 8.70k, False: 706]
  ------------------
 1776|  9.41k|	    (ctxt->options & XML_PARSE_COMPACT)) {
  ------------------
  |  Branch (1776:6): [True: 0, False: 8.70k]
  ------------------
 1777|       |	    /* store the string in the node overriding properties and nsDef */
 1778|      0|	    xmlChar *tmp = (xmlChar *) &(ret->properties);
 1779|      0|	    memcpy(tmp, str, len);
 1780|      0|	    tmp[len] = 0;
 1781|      0|	    intern = tmp;
 1782|  9.41k|	} else if ((len <= 3) && ((cur == '"') || (cur == '\'') ||
  ------------------
  |  Branch (1782:13): [True: 2.67k, False: 6.73k]
  |  Branch (1782:28): [True: 825, False: 1.85k]
  |  Branch (1782:44): [True: 24, False: 1.83k]
  ------------------
 1783|  2.67k|	    ((cur == '<') && (str[len + 1] != '!')))) {
  ------------------
  |  Branch (1783:7): [True: 1.75k, False: 78]
  |  Branch (1783:23): [True: 1.68k, False: 63]
  ------------------
 1784|  2.53k|	    intern = xmlDictLookup(ctxt->dict, str, len);
 1785|  6.87k|	} else if (IS_BLANK_CH(*str) && (len < 60) && (cur == '<') &&
  ------------------
  |  |  151|  6.87k|#define IS_BLANK_CH(c)  xmlIsBlank_ch(c)
  |  |  ------------------
  |  |  |  |   88|  13.7k|#define xmlIsBlank_ch(c)	(((c) == 0x20) || \
  |  |  |  |  ------------------
  |  |  |  |  |  Branch (88:27): [True: 128, False: 6.74k]
  |  |  |  |  ------------------
  |  |  |  |   89|  6.87k|				 ((0x9 <= (c)) && ((c) <= 0xa)) || \
  |  |  |  |  ------------------
  |  |  |  |  |  Branch (89:7): [True: 6.74k, False: 0]
  |  |  |  |  |  Branch (89:23): [True: 3.58k, False: 3.16k]
  |  |  |  |  ------------------
  |  |  |  |   90|  13.7k|				 ((c) == 0xd))
  |  |  |  |  ------------------
  |  |  |  |  |  Branch (90:6): [True: 0, False: 3.16k]
  |  |  |  |  ------------------
  |  |  ------------------
  ------------------
  |  Branch (1785:34): [True: 3.68k, False: 32]
  |  Branch (1785:48): [True: 3.55k, False: 123]
  ------------------
 1786|  6.87k|	           (str[len + 1] != '!')) {
  ------------------
  |  Branch (1786:13): [True: 3.44k, False: 110]
  ------------------
 1787|  3.44k|	    int i;
 1788|       |
 1789|  26.5k|	    for (i = 1;i < len;i++) {
  ------------------
  |  Branch (1789:17): [True: 23.1k, False: 3.43k]
  ------------------
 1790|  23.1k|		if (!IS_BLANK_CH(str[i])) goto skip;
  ------------------
  |  |  151|  23.1k|#define IS_BLANK_CH(c)  xmlIsBlank_ch(c)
  |  |  ------------------
  |  |  |  |   88|  23.1k|#define xmlIsBlank_ch(c)	(((c) == 0x20) || \
  |  |  |  |  ------------------
  |  |  |  |  |  Branch (88:27): [True: 17.3k, False: 5.73k]
  |  |  |  |  ------------------
  |  |  |  |   89|  23.1k|				 ((0x9 <= (c)) && ((c) <= 0xa)) || \
  |  |  |  |  ------------------
  |  |  |  |  |  Branch (89:7): [True: 5.73k, False: 0]
  |  |  |  |  |  Branch (89:23): [True: 5.72k, False: 11]
  |  |  |  |  ------------------
  |  |  |  |   90|  23.1k|				 ((c) == 0xd))
  |  |  |  |  ------------------
  |  |  |  |  |  Branch (90:6): [True: 0, False: 11]
  |  |  |  |  ------------------
  |  |  ------------------
  ------------------
 1791|  23.1k|	    }
 1792|  3.43k|	    intern = xmlDictLookup(ctxt->dict, str, len);
 1793|  3.43k|	}
 1794|  9.41k|    }
 1795|  9.41k|skip:
 1796|  9.41k|    ret->type = XML_TEXT_NODE;
 1797|       |
 1798|  9.41k|    ret->name = xmlStringText;
 1799|  9.41k|    if (intern == NULL) {
  ------------------
  |  Branch (1799:9): [True: 3.44k, False: 5.97k]
  ------------------
 1800|  3.44k|	ret->content = xmlStrndup(str, len);
 1801|  3.44k|	if (ret->content == NULL) {
  ------------------
  |  Branch (1801:6): [True: 0, False: 3.44k]
  ------------------
 1802|      0|	    xmlSAX2ErrMemory(ctxt, "xmlSAX2TextNode");
 1803|      0|	    xmlFree(ret);
 1804|      0|	    return(NULL);
 1805|      0|	}
 1806|  3.44k|    } else
 1807|  5.97k|	ret->content = (xmlChar *) intern;
 1808|       |
 1809|  9.41k|    if ((__xmlRegisterCallbacks) && (xmlRegisterNodeDefaultValue))
  ------------------
  |  |  682|      0|    XML_GLOBAL_MACRO(xmlRegisterNodeDefaultValue)
  |  |  ------------------
  |  |  |  |  500|      0|  #define XML_GLOBAL_MACRO(name) (*__##name())
  |  |  ------------------
  ------------------
  |  Branch (1809:9): [True: 0, False: 9.41k]
  |  Branch (1809:37): [True: 0, False: 0]
  ------------------
 1810|      0|	xmlRegisterNodeDefaultValue(ret);
  ------------------
  |  |  682|      0|    XML_GLOBAL_MACRO(xmlRegisterNodeDefaultValue)
  |  |  ------------------
  |  |  |  |  500|      0|  #define XML_GLOBAL_MACRO(name) (*__##name())
  |  |  ------------------
  ------------------
 1811|  9.41k|    return(ret);
 1812|  9.41k|}
SAX2.c:xmlSAX2Text:
 2404|  5.61k|{
 2405|  5.61k|    xmlNodePtr lastChild;
 2406|       |
 2407|  5.61k|    if (ctxt == NULL) return;
  ------------------
  |  Branch (2407:9): [True: 0, False: 5.61k]
  ------------------
 2408|       |    /*
 2409|       |     * Handle the data if any. If there is no child
 2410|       |     * add it as content, otherwise if the last child is text,
 2411|       |     * concatenate it, else create a new node of type text.
 2412|       |     */
 2413|       |
 2414|  5.61k|    if (ctxt->node == NULL) {
  ------------------
  |  Branch (2414:9): [True: 0, False: 5.61k]
  ------------------
 2415|      0|        return;
 2416|      0|    }
 2417|  5.61k|    lastChild = ctxt->node->last;
 2418|       |
 2419|       |    /*
 2420|       |     * Here we needed an accelerator mechanism in case of very large
 2421|       |     * elements. Use an attribute in the structure !!!
 2422|       |     */
 2423|  5.61k|    if (lastChild == NULL) {
  ------------------
  |  Branch (2423:9): [True: 2.06k, False: 3.54k]
  ------------------
 2424|  2.06k|        if (type == XML_TEXT_NODE)
  ------------------
  |  Branch (2424:13): [True: 2.06k, False: 0]
  ------------------
 2425|  2.06k|            lastChild = xmlSAX2TextNode(ctxt, ch, len);
 2426|      0|        else
 2427|      0|            lastChild = xmlNewCDataBlock(ctxt->myDoc, ch, len);
 2428|  2.06k|	if (lastChild != NULL) {
  ------------------
  |  Branch (2428:6): [True: 2.06k, False: 0]
  ------------------
 2429|  2.06k|	    ctxt->node->children = lastChild;
 2430|  2.06k|	    ctxt->node->last = lastChild;
 2431|  2.06k|	    lastChild->parent = ctxt->node;
 2432|  2.06k|	    lastChild->doc = ctxt->node->doc;
 2433|  2.06k|	    ctxt->nodelen = len;
 2434|  2.06k|	    ctxt->nodemem = len + 1;
 2435|  2.06k|	} else {
 2436|      0|	    xmlSAX2ErrMemory(ctxt, "xmlSAX2Characters");
 2437|      0|	    return;
 2438|      0|	}
 2439|  3.54k|    } else {
 2440|  3.54k|	int coalesceText = (lastChild != NULL) &&
  ------------------
  |  Branch (2440:21): [True: 3.54k, False: 0]
  ------------------
 2441|  3.54k|	    (lastChild->type == type) &&
  ------------------
  |  Branch (2441:6): [True: 164, False: 3.38k]
  ------------------
 2442|  3.54k|	    ((type != XML_TEXT_NODE) ||
  ------------------
  |  Branch (2442:7): [True: 0, False: 164]
  ------------------
 2443|    164|             (lastChild->name == xmlStringText));
  ------------------
  |  Branch (2443:14): [True: 164, False: 0]
  ------------------
 2444|  3.54k|	if ((coalesceText) && (ctxt->nodemem != 0)) {
  ------------------
  |  Branch (2444:6): [True: 164, False: 3.38k]
  |  Branch (2444:24): [True: 164, False: 0]
  ------------------
 2445|       |	    /*
 2446|       |	     * The whole point of maintaining nodelen and nodemem,
 2447|       |	     * xmlTextConcat is too costly, i.e. compute length,
 2448|       |	     * reallocate a new buffer, move data, append ch. Here
 2449|       |	     * We try to minimize realloc() uses and avoid copying
 2450|       |	     * and recomputing length over and over.
 2451|       |	     */
 2452|    164|	    if (lastChild->content == (xmlChar *)&(lastChild->properties)) {
  ------------------
  |  Branch (2452:10): [True: 0, False: 164]
  ------------------
 2453|      0|		lastChild->content = xmlStrdup(lastChild->content);
 2454|      0|		lastChild->properties = NULL;
 2455|    164|	    } else if ((ctxt->nodemem == ctxt->nodelen + 1) &&
  ------------------
  |  Branch (2455:17): [True: 81, False: 83]
  ------------------
 2456|    164|	               (xmlDictOwns(ctxt->dict, lastChild->content))) {
  ------------------
  |  Branch (2456:17): [True: 0, False: 81]
  ------------------
 2457|      0|		lastChild->content = xmlStrdup(lastChild->content);
 2458|      0|	    }
 2459|    164|	    if (lastChild->content == NULL) {
  ------------------
  |  Branch (2459:10): [True: 0, False: 164]
  ------------------
 2460|      0|		xmlSAX2ErrMemory(ctxt, "xmlSAX2Characters: xmlStrdup returned NULL");
 2461|      0|		return;
 2462|      0| 	    }
 2463|    164|	    if (ctxt->nodelen > INT_MAX - len) {
  ------------------
  |  Branch (2463:10): [True: 0, False: 164]
  ------------------
 2464|      0|                xmlSAX2ErrMemory(ctxt, "xmlSAX2Characters overflow prevented");
 2465|      0|                return;
 2466|      0|	    }
 2467|    164|            if ((ctxt->nodelen + len > XML_MAX_TEXT_LENGTH) &&
  ------------------
  |  |   42|    164|#define XML_MAX_TEXT_LENGTH 10000000
  ------------------
  |  Branch (2467:17): [True: 0, False: 164]
  ------------------
 2468|    164|                ((ctxt->options & XML_PARSE_HUGE) == 0)) {
  ------------------
  |  Branch (2468:17): [True: 0, False: 0]
  ------------------
 2469|      0|                xmlSAX2ErrMemory(ctxt, "xmlSAX2Characters: huge text node");
 2470|      0|                return;
 2471|      0|            }
 2472|    164|	    if (ctxt->nodelen + len >= ctxt->nodemem) {
  ------------------
  |  Branch (2472:10): [True: 95, False: 69]
  ------------------
 2473|     95|		xmlChar *newbuf;
 2474|     95|		int size;
 2475|       |
 2476|     95|		size = ctxt->nodemem > INT_MAX - len ?
  ------------------
  |  Branch (2476:10): [True: 0, False: 95]
  ------------------
 2477|      0|                       INT_MAX :
 2478|     95|                       ctxt->nodemem + len;
 2479|     95|		size = size > INT_MAX / 2 ? INT_MAX : size * 2;
  ------------------
  |  Branch (2479:10): [True: 0, False: 95]
  ------------------
 2480|     95|                newbuf = (xmlChar *) xmlRealloc(lastChild->content,size);
 2481|     95|		if (newbuf == NULL) {
  ------------------
  |  Branch (2481:7): [True: 0, False: 95]
  ------------------
 2482|      0|		    xmlSAX2ErrMemory(ctxt, "xmlSAX2Characters");
 2483|      0|		    return;
 2484|      0|		}
 2485|     95|		ctxt->nodemem = size;
 2486|     95|		lastChild->content = newbuf;
 2487|     95|	    }
 2488|    164|	    memcpy(&lastChild->content[ctxt->nodelen], ch, len);
 2489|    164|	    ctxt->nodelen += len;
 2490|    164|	    lastChild->content[ctxt->nodelen] = 0;
 2491|  3.38k|	} else if (coalesceText) {
  ------------------
  |  Branch (2491:13): [True: 0, False: 3.38k]
  ------------------
 2492|      0|	    if (xmlTextConcat(lastChild, ch, len)) {
  ------------------
  |  Branch (2492:10): [True: 0, False: 0]
  ------------------
 2493|      0|		xmlSAX2ErrMemory(ctxt, "xmlSAX2Characters");
 2494|      0|	    }
 2495|      0|	    if (ctxt->node->children != NULL) {
  ------------------
  |  Branch (2495:10): [True: 0, False: 0]
  ------------------
 2496|      0|		ctxt->nodelen = xmlStrlen(lastChild->content);
 2497|      0|		ctxt->nodemem = ctxt->nodelen + 1;
 2498|      0|	    }
 2499|  3.38k|	} else {
 2500|       |	    /* Mixed content, first time */
 2501|  3.38k|            if (type == XML_TEXT_NODE) {
  ------------------
  |  Branch (2501:17): [True: 3.38k, False: 0]
  ------------------
 2502|  3.38k|                lastChild = xmlSAX2TextNode(ctxt, ch, len);
 2503|  3.38k|                if (lastChild != NULL)
  ------------------
  |  Branch (2503:21): [True: 3.38k, False: 0]
  ------------------
 2504|  3.38k|                    lastChild->doc = ctxt->myDoc;
 2505|  3.38k|            } else
 2506|      0|                lastChild = xmlNewCDataBlock(ctxt->myDoc, ch, len);
 2507|  3.38k|	    if (lastChild != NULL) {
  ------------------
  |  Branch (2507:10): [True: 3.38k, False: 0]
  ------------------
 2508|  3.38k|		xmlAddChild(ctxt->node, lastChild);
 2509|  3.38k|		if (ctxt->node->children != NULL) {
  ------------------
  |  Branch (2509:7): [True: 3.38k, False: 0]
  ------------------
 2510|  3.38k|		    ctxt->nodelen = len;
 2511|  3.38k|		    ctxt->nodemem = len + 1;
 2512|  3.38k|		}
 2513|  3.38k|	    }
 2514|  3.38k|	}
 2515|  3.54k|    }
 2516|       |
 2517|  5.61k|    if ((lastChild != NULL) &&
  ------------------
  |  Branch (2517:9): [True: 5.61k, False: 0]
  ------------------
 2518|  5.61k|        (type == XML_TEXT_NODE) &&
  ------------------
  |  Branch (2518:9): [True: 5.61k, False: 0]
  ------------------
 2519|  5.61k|        (ctxt->linenumbers) &&
  ------------------
  |  Branch (2519:9): [True: 5.61k, False: 0]
  ------------------
 2520|  5.61k|        (ctxt->input != NULL)) {
  ------------------
  |  Branch (2520:9): [True: 5.61k, False: 0]
  ------------------
 2521|  5.61k|        if ((unsigned) ctxt->input->line < (unsigned) USHRT_MAX)
  ------------------
  |  Branch (2521:13): [True: 5.61k, False: 0]
  ------------------
 2522|  5.61k|            lastChild->line = ctxt->input->line;
 2523|      0|        else {
 2524|      0|            lastChild->line = USHRT_MAX;
 2525|      0|            if (ctxt->options & XML_PARSE_BIG_LINES)
  ------------------
  |  Branch (2525:17): [True: 0, False: 0]
  ------------------
 2526|      0|                lastChild->psvi = (void *) (ptrdiff_t) ctxt->input->line;
 2527|      0|        }
 2528|  5.61k|    }
 2529|  5.61k|}

xmlBufCreate:
  122|     52|xmlBufCreate(void) {
  123|     52|    xmlBufPtr ret;
  124|       |
  125|     52|    ret = (xmlBufPtr) xmlMalloc(sizeof(xmlBuf));
  126|     52|    if (ret == NULL) {
  ------------------
  |  Branch (126:9): [True: 0, False: 52]
  ------------------
  127|      0|	xmlBufMemoryError(NULL, "creating buffer");
  128|      0|        return(NULL);
  129|      0|    }
  130|     52|    ret->use = 0;
  131|     52|    ret->error = 0;
  132|     52|    ret->buffer = NULL;
  133|     52|    ret->size = xmlDefaultBufferSize;
  ------------------
  |  |  680|     52|  #define xmlDefaultBufferSize XML_GLOBAL_MACRO(xmlDefaultBufferSize)
  |  |  ------------------
  |  |  |  |  500|     52|  #define XML_GLOBAL_MACRO(name) (*__##name())
  |  |  ------------------
  ------------------
  134|     52|    UPDATE_COMPAT(ret);
  ------------------
  |  |   61|     52|     if (buf->size < INT_MAX) buf->compat_size = buf->size; \
  |  |  ------------------
  |  |  |  Branch (61:10): [True: 52, False: 0]
  |  |  ------------------
  |  |   62|     52|     else buf->compat_size = INT_MAX;			    \
  |  |   63|     52|     if (buf->use < INT_MAX) buf->compat_use = buf->use; \
  |  |  ------------------
  |  |  |  Branch (63:10): [True: 52, False: 0]
  |  |  ------------------
  |  |   64|     52|     else buf->compat_use = INT_MAX;
  ------------------
  135|     52|    ret->alloc = xmlBufferAllocScheme;
  ------------------
  |  |  679|     52|  #define xmlBufferAllocScheme XML_GLOBAL_MACRO(xmlBufferAllocScheme)
  |  |  ------------------
  |  |  |  |  500|     52|  #define XML_GLOBAL_MACRO(name) (*__##name())
  |  |  ------------------
  ------------------
  136|     52|    ret->content = (xmlChar *) xmlMallocAtomic(ret->size);
  137|     52|    if (ret->content == NULL) {
  ------------------
  |  Branch (137:9): [True: 0, False: 52]
  ------------------
  138|      0|	xmlBufMemoryError(ret, "creating buffer");
  139|      0|	xmlFree(ret);
  140|      0|        return(NULL);
  141|      0|    }
  142|     52|    ret->content[0] = 0;
  143|     52|    ret->contentIO = NULL;
  144|     52|    return(ret);
  145|     52|}
xmlBufCreateSize:
  155|    238|xmlBufCreateSize(size_t size) {
  156|    238|    xmlBufPtr ret;
  157|       |
  158|    238|    if (size == SIZE_MAX)
  ------------------
  |  |   30|    238|#define SIZE_MAX ((size_t) -1)
  ------------------
  |  Branch (158:9): [True: 0, False: 238]
  ------------------
  159|      0|        return(NULL);
  160|    238|    ret = (xmlBufPtr) xmlMalloc(sizeof(xmlBuf));
  161|    238|    if (ret == NULL) {
  ------------------
  |  Branch (161:9): [True: 0, False: 238]
  ------------------
  162|      0|	xmlBufMemoryError(NULL, "creating buffer");
  163|      0|        return(NULL);
  164|      0|    }
  165|    238|    ret->use = 0;
  166|    238|    ret->error = 0;
  167|    238|    ret->buffer = NULL;
  168|    238|    ret->alloc = xmlBufferAllocScheme;
  ------------------
  |  |  679|    238|  #define xmlBufferAllocScheme XML_GLOBAL_MACRO(xmlBufferAllocScheme)
  |  |  ------------------
  |  |  |  |  500|    238|  #define XML_GLOBAL_MACRO(name) (*__##name())
  |  |  ------------------
  ------------------
  169|    238|    ret->size = (size ? size + 1 : 0);         /* +1 for ending null */
  ------------------
  |  Branch (169:18): [True: 238, False: 0]
  ------------------
  170|    238|    UPDATE_COMPAT(ret);
  ------------------
  |  |   61|    238|     if (buf->size < INT_MAX) buf->compat_size = buf->size; \
  |  |  ------------------
  |  |  |  Branch (61:10): [True: 238, False: 0]
  |  |  ------------------
  |  |   62|    238|     else buf->compat_size = INT_MAX;			    \
  |  |   63|    238|     if (buf->use < INT_MAX) buf->compat_use = buf->use; \
  |  |  ------------------
  |  |  |  Branch (63:10): [True: 238, False: 0]
  |  |  ------------------
  |  |   64|    238|     else buf->compat_use = INT_MAX;
  ------------------
  171|    238|    if (ret->size){
  ------------------
  |  Branch (171:9): [True: 238, False: 0]
  ------------------
  172|    238|        ret->content = (xmlChar *) xmlMallocAtomic(ret->size);
  173|    238|        if (ret->content == NULL) {
  ------------------
  |  Branch (173:13): [True: 0, False: 238]
  ------------------
  174|      0|	    xmlBufMemoryError(ret, "creating buffer");
  175|      0|            xmlFree(ret);
  176|      0|            return(NULL);
  177|      0|        }
  178|    238|        ret->content[0] = 0;
  179|    238|    } else
  180|      0|	ret->content = NULL;
  181|    238|    ret->contentIO = NULL;
  182|    238|    return(ret);
  183|    238|}
xmlBufSetAllocationScheme:
  242|    238|                          xmlBufferAllocationScheme scheme) {
  243|    238|    if ((buf == NULL) || (buf->error != 0)) {
  ------------------
  |  Branch (243:9): [True: 0, False: 238]
  |  Branch (243:26): [True: 0, False: 238]
  ------------------
  244|      0|        return(-1);
  245|      0|    }
  246|    238|    if (buf->alloc == XML_BUFFER_ALLOC_IO)
  ------------------
  |  Branch (246:9): [True: 0, False: 238]
  ------------------
  247|      0|        return(-1);
  248|    238|    if ((scheme == XML_BUFFER_ALLOC_DOUBLEIT) ||
  ------------------
  |  Branch (248:9): [True: 238, False: 0]
  ------------------
  249|    238|        (scheme == XML_BUFFER_ALLOC_EXACT) ||
  ------------------
  |  Branch (249:9): [True: 0, False: 0]
  ------------------
  250|    238|        (scheme == XML_BUFFER_ALLOC_HYBRID) ||
  ------------------
  |  Branch (250:9): [True: 0, False: 0]
  ------------------
  251|    238|	(scheme == XML_BUFFER_ALLOC_BOUNDED)) {
  ------------------
  |  Branch (251:2): [True: 0, False: 0]
  ------------------
  252|    238|	buf->alloc = scheme;
  253|    238|        if (buf->buffer)
  ------------------
  |  Branch (253:13): [True: 0, False: 238]
  ------------------
  254|      0|            buf->buffer->alloc = scheme;
  255|    238|        return(0);
  256|    238|    }
  257|       |    /*
  258|       |     * Switching a buffer ALLOC_IO has the side effect of initializing
  259|       |     * the contentIO field with the current content
  260|       |     */
  261|      0|    if (scheme == XML_BUFFER_ALLOC_IO) {
  ------------------
  |  Branch (261:9): [True: 0, False: 0]
  ------------------
  262|      0|        buf->alloc = XML_BUFFER_ALLOC_IO;
  263|      0|        buf->contentIO = buf->content;
  264|      0|    }
  265|      0|    return(-1);
  266|    238|}
xmlBufFree:
  276|    290|xmlBufFree(xmlBufPtr buf) {
  277|    290|    if (buf == NULL) {
  ------------------
  |  Branch (277:9): [True: 0, False: 290]
  ------------------
  278|      0|	return;
  279|      0|    }
  280|       |
  281|    290|    if ((buf->alloc == XML_BUFFER_ALLOC_IO) &&
  ------------------
  |  Branch (281:9): [True: 0, False: 290]
  ------------------
  282|    290|        (buf->contentIO != NULL)) {
  ------------------
  |  Branch (282:9): [True: 0, False: 0]
  ------------------
  283|      0|        xmlFree(buf->contentIO);
  284|    290|    } else if (buf->content != NULL) {
  ------------------
  |  Branch (284:16): [True: 290, False: 0]
  ------------------
  285|    290|        xmlFree(buf->content);
  286|    290|    }
  287|    290|    xmlFree(buf);
  288|    290|}
xmlBufShrink:
  328|    311|xmlBufShrink(xmlBufPtr buf, size_t len) {
  329|    311|    if ((buf == NULL) || (buf->error != 0)) return(0);
  ------------------
  |  Branch (329:9): [True: 0, False: 311]
  |  Branch (329:26): [True: 0, False: 311]
  ------------------
  330|    311|    CHECK_COMPAT(buf)
  ------------------
  |  |   72|    311|     if (buf->size != (size_t) buf->compat_size)	    \
  |  |  ------------------
  |  |  |  Branch (72:10): [True: 0, False: 311]
  |  |  ------------------
  |  |   73|    311|         if (buf->compat_size < INT_MAX)		    \
  |  |  ------------------
  |  |  |  Branch (73:14): [True: 0, False: 0]
  |  |  ------------------
  |  |   74|      0|	     buf->size = buf->compat_size;		    \
  |  |   75|    311|     if (buf->use != (size_t) buf->compat_use)		    \
  |  |  ------------------
  |  |  |  Branch (75:10): [True: 0, False: 311]
  |  |  ------------------
  |  |   76|    311|         if (buf->compat_use < INT_MAX)			    \
  |  |  ------------------
  |  |  |  Branch (76:14): [True: 0, False: 0]
  |  |  ------------------
  |  |   77|      0|	     buf->use = buf->compat_use;
  ------------------
  331|    311|    if (len == 0) return(0);
  ------------------
  |  Branch (331:9): [True: 0, False: 311]
  ------------------
  332|    311|    if (len > buf->use) return(0);
  ------------------
  |  Branch (332:9): [True: 0, False: 311]
  ------------------
  333|       |
  334|    311|    buf->use -= len;
  335|    311|    if ((buf->alloc == XML_BUFFER_ALLOC_IO) && (buf->contentIO != NULL)) {
  ------------------
  |  Branch (335:9): [True: 0, False: 311]
  |  Branch (335:48): [True: 0, False: 0]
  ------------------
  336|       |	/*
  337|       |	 * we just move the content pointer, but also make sure
  338|       |	 * the perceived buffer size has shrunk accordingly
  339|       |	 */
  340|      0|        buf->content += len;
  341|      0|	buf->size -= len;
  342|       |
  343|       |        /*
  344|       |	 * sometimes though it maybe be better to really shrink
  345|       |	 * on IO buffers
  346|       |	 */
  347|      0|	if ((buf->alloc == XML_BUFFER_ALLOC_IO) && (buf->contentIO != NULL)) {
  ------------------
  |  Branch (347:6): [True: 0, False: 0]
  |  Branch (347:45): [True: 0, False: 0]
  ------------------
  348|      0|	    size_t start_buf = buf->content - buf->contentIO;
  349|      0|	    if (start_buf >= buf->size) {
  ------------------
  |  Branch (349:10): [True: 0, False: 0]
  ------------------
  350|      0|		memmove(buf->contentIO, &buf->content[0], buf->use);
  351|      0|		buf->content = buf->contentIO;
  352|      0|		buf->content[buf->use] = 0;
  353|      0|		buf->size += start_buf;
  354|      0|	    }
  355|      0|	}
  356|    311|    } else {
  357|    311|	memmove(buf->content, &buf->content[len], buf->use);
  358|    311|	buf->content[buf->use] = 0;
  359|    311|    }
  360|    311|    UPDATE_COMPAT(buf)
  ------------------
  |  |   61|    311|     if (buf->size < INT_MAX) buf->compat_size = buf->size; \
  |  |  ------------------
  |  |  |  Branch (61:10): [True: 311, False: 0]
  |  |  ------------------
  |  |   62|    311|     else buf->compat_size = INT_MAX;			    \
  |  |   63|    311|     if (buf->use < INT_MAX) buf->compat_use = buf->use; \
  |  |  ------------------
  |  |  |  Branch (63:10): [True: 311, False: 0]
  |  |  ------------------
  |  |   64|    311|     else buf->compat_use = INT_MAX;
  ------------------
  361|    311|    return(len);
  362|    311|}
xmlBufGrow:
  443|  16.9k|xmlBufGrow(xmlBufPtr buf, int len) {
  444|  16.9k|    size_t ret;
  445|       |
  446|  16.9k|    if ((buf == NULL) || (len < 0)) return(-1);
  ------------------
  |  Branch (446:9): [True: 0, False: 16.9k]
  |  Branch (446:26): [True: 0, False: 16.9k]
  ------------------
  447|  16.9k|    if (len == 0)
  ------------------
  |  Branch (447:9): [True: 0, False: 16.9k]
  ------------------
  448|      0|        return(0);
  449|  16.9k|    ret = xmlBufGrowInternal(buf, len);
  450|  16.9k|    if (buf->error != 0)
  ------------------
  |  Branch (450:9): [True: 0, False: 16.9k]
  ------------------
  451|      0|        return(-1);
  452|  16.9k|    return(ret > INT_MAX ? INT_MAX : ret);
  ------------------
  |  Branch (452:12): [True: 0, False: 16.9k]
  ------------------
  453|  16.9k|}
xmlBufContent:
  491|    297|{
  492|    297|    if ((!buf) || (buf->error))
  ------------------
  |  Branch (492:9): [True: 0, False: 297]
  |  Branch (492:19): [True: 0, False: 297]
  ------------------
  493|      0|        return NULL;
  494|       |
  495|    297|    return(buf->content);
  496|    297|}
xmlBufEnd:
  509|  16.9k|{
  510|  16.9k|    if ((!buf) || (buf->error))
  ------------------
  |  Branch (510:9): [True: 0, False: 16.9k]
  |  Branch (510:19): [True: 0, False: 16.9k]
  ------------------
  511|      0|        return NULL;
  512|  16.9k|    CHECK_COMPAT(buf)
  ------------------
  |  |   72|  16.9k|     if (buf->size != (size_t) buf->compat_size)	    \
  |  |  ------------------
  |  |  |  Branch (72:10): [True: 0, False: 16.9k]
  |  |  ------------------
  |  |   73|  16.9k|         if (buf->compat_size < INT_MAX)		    \
  |  |  ------------------
  |  |  |  Branch (73:14): [True: 0, False: 0]
  |  |  ------------------
  |  |   74|      0|	     buf->size = buf->compat_size;		    \
  |  |   75|  16.9k|     if (buf->use != (size_t) buf->compat_use)		    \
  |  |  ------------------
  |  |  |  Branch (75:10): [True: 0, False: 16.9k]
  |  |  ------------------
  |  |   76|  16.9k|         if (buf->compat_use < INT_MAX)			    \
  |  |  ------------------
  |  |  |  Branch (76:14): [True: 0, False: 0]
  |  |  ------------------
  |  |   77|      0|	     buf->use = buf->compat_use;
  ------------------
  513|       |
  514|  16.9k|    return(&buf->content[buf->use]);
  515|  16.9k|}
xmlBufAddLen:
  529|  16.9k|xmlBufAddLen(xmlBufPtr buf, size_t len) {
  530|  16.9k|    if ((buf == NULL) || (buf->error))
  ------------------
  |  Branch (530:9): [True: 0, False: 16.9k]
  |  Branch (530:26): [True: 0, False: 16.9k]
  ------------------
  531|      0|        return(-1);
  532|  16.9k|    CHECK_COMPAT(buf)
  ------------------
  |  |   72|  16.9k|     if (buf->size != (size_t) buf->compat_size)	    \
  |  |  ------------------
  |  |  |  Branch (72:10): [True: 0, False: 16.9k]
  |  |  ------------------
  |  |   73|  16.9k|         if (buf->compat_size < INT_MAX)		    \
  |  |  ------------------
  |  |  |  Branch (73:14): [True: 0, False: 0]
  |  |  ------------------
  |  |   74|      0|	     buf->size = buf->compat_size;		    \
  |  |   75|  16.9k|     if (buf->use != (size_t) buf->compat_use)		    \
  |  |  ------------------
  |  |  |  Branch (75:10): [True: 0, False: 16.9k]
  |  |  ------------------
  |  |   76|  16.9k|         if (buf->compat_use < INT_MAX)			    \
  |  |  ------------------
  |  |  |  Branch (76:14): [True: 0, False: 0]
  |  |  ------------------
  |  |   77|      0|	     buf->use = buf->compat_use;
  ------------------
  533|  16.9k|    if (len >= (buf->size - buf->use))
  ------------------
  |  Branch (533:9): [True: 0, False: 16.9k]
  ------------------
  534|      0|        return(-1);
  535|  16.9k|    buf->use += len;
  536|  16.9k|    buf->content[buf->use] = 0;
  537|  16.9k|    UPDATE_COMPAT(buf)
  ------------------
  |  |   61|  16.9k|     if (buf->size < INT_MAX) buf->compat_size = buf->size; \
  |  |  ------------------
  |  |  |  Branch (61:10): [True: 16.9k, False: 0]
  |  |  ------------------
  |  |   62|  16.9k|     else buf->compat_size = INT_MAX;			    \
  |  |   63|  16.9k|     if (buf->use < INT_MAX) buf->compat_use = buf->use; \
  |  |  ------------------
  |  |  |  Branch (63:10): [True: 16.9k, False: 0]
  |  |  ------------------
  |  |   64|  16.9k|     else buf->compat_use = INT_MAX;
  ------------------
  538|  16.9k|    return(0);
  539|  16.9k|}
xmlBufUse:
  571|  3.91k|{
  572|  3.91k|    if ((!buf) || (buf->error))
  ------------------
  |  Branch (572:9): [True: 0, False: 3.91k]
  |  Branch (572:19): [True: 0, False: 3.91k]
  ------------------
  573|      0|        return 0;
  574|  3.91k|    CHECK_COMPAT(buf)
  ------------------
  |  |   72|  3.91k|     if (buf->size != (size_t) buf->compat_size)	    \
  |  |  ------------------
  |  |  |  Branch (72:10): [True: 0, False: 3.91k]
  |  |  ------------------
  |  |   73|  3.91k|         if (buf->compat_size < INT_MAX)		    \
  |  |  ------------------
  |  |  |  Branch (73:14): [True: 0, False: 0]
  |  |  ------------------
  |  |   74|      0|	     buf->size = buf->compat_size;		    \
  |  |   75|  3.91k|     if (buf->use != (size_t) buf->compat_use)		    \
  |  |  ------------------
  |  |  |  Branch (75:10): [True: 0, False: 3.91k]
  |  |  ------------------
  |  |   76|  3.91k|         if (buf->compat_use < INT_MAX)			    \
  |  |  ------------------
  |  |  |  Branch (76:14): [True: 0, False: 0]
  |  |  ------------------
  |  |   77|      0|	     buf->use = buf->compat_use;
  ------------------
  575|       |
  576|  3.91k|    return(buf->use);
  577|  3.91k|}
xmlBufAvail:
  593|    116|{
  594|    116|    if ((!buf) || (buf->error))
  ------------------
  |  Branch (594:9): [True: 0, False: 116]
  |  Branch (594:19): [True: 0, False: 116]
  ------------------
  595|      0|        return 0;
  596|    116|    CHECK_COMPAT(buf)
  ------------------
  |  |   72|    116|     if (buf->size != (size_t) buf->compat_size)	    \
  |  |  ------------------
  |  |  |  Branch (72:10): [True: 0, False: 116]
  |  |  ------------------
  |  |   73|    116|         if (buf->compat_size < INT_MAX)		    \
  |  |  ------------------
  |  |  |  Branch (73:14): [True: 0, False: 0]
  |  |  ------------------
  |  |   74|      0|	     buf->size = buf->compat_size;		    \
  |  |   75|    116|     if (buf->use != (size_t) buf->compat_use)		    \
  |  |  ------------------
  |  |  |  Branch (75:10): [True: 0, False: 116]
  |  |  ------------------
  |  |   76|    116|         if (buf->compat_use < INT_MAX)			    \
  |  |  ------------------
  |  |  |  Branch (76:14): [True: 0, False: 0]
  |  |  ------------------
  |  |   77|      0|	     buf->use = buf->compat_use;
  ------------------
  597|       |
  598|    116|    return((buf->size > buf->use) ? (buf->size - buf->use - 1) : 0);
  ------------------
  |  Branch (598:12): [True: 116, False: 0]
  ------------------
  599|    116|}
xmlBufIsEmpty:
  611|     98|{
  612|     98|    if ((!buf) || (buf->error))
  ------------------
  |  Branch (612:9): [True: 0, False: 98]
  |  Branch (612:19): [True: 0, False: 98]
  ------------------
  613|      0|        return(-1);
  614|     98|    CHECK_COMPAT(buf)
  ------------------
  |  |   72|     98|     if (buf->size != (size_t) buf->compat_size)	    \
  |  |  ------------------
  |  |  |  Branch (72:10): [True: 0, False: 98]
  |  |  ------------------
  |  |   73|     98|         if (buf->compat_size < INT_MAX)		    \
  |  |  ------------------
  |  |  |  Branch (73:14): [True: 0, False: 0]
  |  |  ------------------
  |  |   74|      0|	     buf->size = buf->compat_size;		    \
  |  |   75|     98|     if (buf->use != (size_t) buf->compat_use)		    \
  |  |  ------------------
  |  |  |  Branch (75:10): [True: 0, False: 98]
  |  |  ------------------
  |  |   76|     98|         if (buf->compat_use < INT_MAX)			    \
  |  |  ------------------
  |  |  |  Branch (76:14): [True: 0, False: 0]
  |  |  ------------------
  |  |   77|      0|	     buf->use = buf->compat_use;
  ------------------
  615|       |
  616|     98|    return(buf->use == 0);
  617|     98|}
xmlBufResetInput:
 1019|     52|xmlBufResetInput(xmlBufPtr buf, xmlParserInputPtr input) {
 1020|     52|    if (input == NULL)
  ------------------
  |  Branch (1020:9): [True: 0, False: 52]
  ------------------
 1021|      0|        return(-1);
 1022|     52|    if ((buf == NULL) || (buf->error)) {
  ------------------
  |  Branch (1022:9): [True: 0, False: 52]
  |  Branch (1022:26): [True: 0, False: 52]
  ------------------
 1023|      0|        input->base = input->cur = input->end = BAD_CAST "";
  ------------------
  |  |   35|      0|#define BAD_CAST (xmlChar *)
  ------------------
 1024|      0|        return(-1);
 1025|      0|    }
 1026|     52|    CHECK_COMPAT(buf)
  ------------------
  |  |   72|     52|     if (buf->size != (size_t) buf->compat_size)	    \
  |  |  ------------------
  |  |  |  Branch (72:10): [True: 0, False: 52]
  |  |  ------------------
  |  |   73|     52|         if (buf->compat_size < INT_MAX)		    \
  |  |  ------------------
  |  |  |  Branch (73:14): [True: 0, False: 0]
  |  |  ------------------
  |  |   74|      0|	     buf->size = buf->compat_size;		    \
  |  |   75|     52|     if (buf->use != (size_t) buf->compat_use)		    \
  |  |  ------------------
  |  |  |  Branch (75:10): [True: 0, False: 52]
  |  |  ------------------
  |  |   76|     52|         if (buf->compat_use < INT_MAX)			    \
  |  |  ------------------
  |  |  |  Branch (76:14): [True: 0, False: 0]
  |  |  ------------------
  |  |   77|      0|	     buf->use = buf->compat_use;
  ------------------
 1027|     52|    input->base = input->cur = buf->content;
 1028|     52|    input->end = &buf->content[buf->use];
 1029|     52|    return(0);
 1030|     52|}
xmlBufUpdateInput:
 1044|  17.0k|xmlBufUpdateInput(xmlBufPtr buf, xmlParserInputPtr input, size_t pos) {
 1045|  17.0k|    if (input == NULL)
  ------------------
  |  Branch (1045:9): [True: 0, False: 17.0k]
  ------------------
 1046|      0|        return(-1);
 1047|       |    /*
 1048|       |     * TODO: It might be safer to keep using the buffer content if there
 1049|       |     * was an error.
 1050|       |     */
 1051|  17.0k|    if ((buf == NULL) || (buf->error)) {
  ------------------
  |  Branch (1051:9): [True: 0, False: 17.0k]
  |  Branch (1051:26): [True: 0, False: 17.0k]
  ------------------
 1052|      0|        input->base = input->cur = input->end = BAD_CAST "";
  ------------------
  |  |   35|      0|#define BAD_CAST (xmlChar *)
  ------------------
 1053|      0|        return(-1);
 1054|      0|    }
 1055|  17.0k|    CHECK_COMPAT(buf)
  ------------------
  |  |   72|  17.0k|     if (buf->size != (size_t) buf->compat_size)	    \
  |  |  ------------------
  |  |  |  Branch (72:10): [True: 0, False: 17.0k]
  |  |  ------------------
  |  |   73|  17.0k|         if (buf->compat_size < INT_MAX)		    \
  |  |  ------------------
  |  |  |  Branch (73:14): [True: 0, False: 0]
  |  |  ------------------
  |  |   74|      0|	     buf->size = buf->compat_size;		    \
  |  |   75|  17.0k|     if (buf->use != (size_t) buf->compat_use)		    \
  |  |  ------------------
  |  |  |  Branch (75:10): [True: 0, False: 17.0k]
  |  |  ------------------
  |  |   76|  17.0k|         if (buf->compat_use < INT_MAX)			    \
  |  |  ------------------
  |  |  |  Branch (76:14): [True: 0, False: 0]
  |  |  ------------------
  |  |   77|      0|	     buf->use = buf->compat_use;
  ------------------
 1056|  17.0k|    input->base = buf->content;
 1057|  17.0k|    input->cur = input->base + pos;
 1058|  17.0k|    input->end = &buf->content[buf->use];
 1059|  17.0k|    return(0);
 1060|  17.0k|}
buf.c:xmlBufGrowInternal:
  376|  16.9k|xmlBufGrowInternal(xmlBufPtr buf, size_t len) {
  377|  16.9k|    size_t size;
  378|  16.9k|    xmlChar *newbuf;
  379|       |
  380|  16.9k|    if ((buf == NULL) || (buf->error != 0)) return(0);
  ------------------
  |  Branch (380:9): [True: 0, False: 16.9k]
  |  Branch (380:26): [True: 0, False: 16.9k]
  ------------------
  381|  16.9k|    CHECK_COMPAT(buf)
  ------------------
  |  |   72|  16.9k|     if (buf->size != (size_t) buf->compat_size)	    \
  |  |  ------------------
  |  |  |  Branch (72:10): [True: 0, False: 16.9k]
  |  |  ------------------
  |  |   73|  16.9k|         if (buf->compat_size < INT_MAX)		    \
  |  |  ------------------
  |  |  |  Branch (73:14): [True: 0, False: 0]
  |  |  ------------------
  |  |   74|      0|	     buf->size = buf->compat_size;		    \
  |  |   75|  16.9k|     if (buf->use != (size_t) buf->compat_use)		    \
  |  |  ------------------
  |  |  |  Branch (75:10): [True: 0, False: 16.9k]
  |  |  ------------------
  |  |   76|  16.9k|         if (buf->compat_use < INT_MAX)			    \
  |  |  ------------------
  |  |  |  Branch (76:14): [True: 0, False: 0]
  |  |  ------------------
  |  |   77|      0|	     buf->use = buf->compat_use;
  ------------------
  382|       |
  383|  16.9k|    if (len < buf->size - buf->use)
  ------------------
  |  Branch (383:9): [True: 16.8k, False: 57]
  ------------------
  384|  16.8k|        return(buf->size - buf->use - 1);
  385|     57|    if (len >= SIZE_MAX - buf->use) {
  ------------------
  |  |   30|     57|#define SIZE_MAX ((size_t) -1)
  ------------------
  |  Branch (385:9): [True: 0, False: 57]
  ------------------
  386|      0|        xmlBufMemoryError(buf, "growing buffer past SIZE_MAX");
  387|      0|        return(0);
  388|      0|    }
  389|       |
  390|     57|    if (buf->size > (size_t) len) {
  ------------------
  |  Branch (390:9): [True: 5, False: 52]
  ------------------
  391|      5|        size = buf->size > SIZE_MAX / 2 ? SIZE_MAX : buf->size * 2;
  ------------------
  |  |   30|      5|#define SIZE_MAX ((size_t) -1)
  ------------------
                      size = buf->size > SIZE_MAX / 2 ? SIZE_MAX : buf->size * 2;
  ------------------
  |  |   30|      0|#define SIZE_MAX ((size_t) -1)
  ------------------
  |  Branch (391:16): [True: 0, False: 5]
  ------------------
  392|     52|    } else {
  393|     52|        size = buf->use + len;
  394|     52|        size = size > SIZE_MAX - 100 ? SIZE_MAX : size + 100;
  ------------------
  |  |   30|     52|#define SIZE_MAX ((size_t) -1)
  ------------------
                      size = size > SIZE_MAX - 100 ? SIZE_MAX : size + 100;
  ------------------
  |  |   30|      0|#define SIZE_MAX ((size_t) -1)
  ------------------
  |  Branch (394:16): [True: 0, False: 52]
  ------------------
  395|     52|    }
  396|       |
  397|     57|    if (buf->alloc == XML_BUFFER_ALLOC_BOUNDED) {
  ------------------
  |  Branch (397:9): [True: 0, False: 57]
  ------------------
  398|       |        /*
  399|       |	 * Used to provide parsing limits
  400|       |	 */
  401|      0|        if ((buf->use + len + 1 >= XML_MAX_TEXT_LENGTH) ||
  ------------------
  |  |   42|      0|#define XML_MAX_TEXT_LENGTH 10000000
  ------------------
  |  Branch (401:13): [True: 0, False: 0]
  ------------------
  402|      0|	    (buf->size >= XML_MAX_TEXT_LENGTH)) {
  ------------------
  |  |   42|      0|#define XML_MAX_TEXT_LENGTH 10000000
  ------------------
  |  Branch (402:6): [True: 0, False: 0]
  ------------------
  403|      0|	    xmlBufMemoryError(buf, "buffer error: text too long\n");
  404|      0|	    return(0);
  405|      0|	}
  406|      0|	if (size >= XML_MAX_TEXT_LENGTH)
  ------------------
  |  |   42|      0|#define XML_MAX_TEXT_LENGTH 10000000
  ------------------
  |  Branch (406:6): [True: 0, False: 0]
  ------------------
  407|      0|	    size = XML_MAX_TEXT_LENGTH;
  ------------------
  |  |   42|      0|#define XML_MAX_TEXT_LENGTH 10000000
  ------------------
  408|      0|    }
  409|     57|    if ((buf->alloc == XML_BUFFER_ALLOC_IO) && (buf->contentIO != NULL)) {
  ------------------
  |  Branch (409:9): [True: 0, False: 57]
  |  Branch (409:48): [True: 0, False: 0]
  ------------------
  410|      0|        size_t start_buf = buf->content - buf->contentIO;
  411|       |
  412|      0|	newbuf = (xmlChar *) xmlRealloc(buf->contentIO, start_buf + size);
  413|      0|	if (newbuf == NULL) {
  ------------------
  |  Branch (413:6): [True: 0, False: 0]
  ------------------
  414|      0|	    xmlBufMemoryError(buf, "growing buffer");
  415|      0|	    return(0);
  416|      0|	}
  417|      0|	buf->contentIO = newbuf;
  418|      0|	buf->content = newbuf + start_buf;
  419|     57|    } else {
  420|     57|	newbuf = (xmlChar *) xmlRealloc(buf->content, size);
  421|     57|	if (newbuf == NULL) {
  ------------------
  |  Branch (421:6): [True: 0, False: 57]
  ------------------
  422|      0|	    xmlBufMemoryError(buf, "growing buffer");
  423|      0|	    return(0);
  424|      0|	}
  425|     57|	buf->content = newbuf;
  426|     57|    }
  427|     57|    buf->size = size;
  428|     57|    UPDATE_COMPAT(buf)
  ------------------
  |  |   61|     57|     if (buf->size < INT_MAX) buf->compat_size = buf->size; \
  |  |  ------------------
  |  |  |  Branch (61:10): [True: 57, False: 0]
  |  |  ------------------
  |  |   62|     57|     else buf->compat_size = INT_MAX;			    \
  |  |   63|     57|     if (buf->use < INT_MAX) buf->compat_use = buf->use; \
  |  |  ------------------
  |  |  |  Branch (63:10): [True: 57, False: 0]
  |  |  ------------------
  |  |   64|     57|     else buf->compat_use = INT_MAX;
  ------------------
  429|     57|    return(buf->size - buf->use - 1);
  430|     57|}

xmlInitializeCatalog:
 3096|      2|xmlInitializeCatalog(void) {
 3097|      2|    if (xmlCatalogInitialized != 0)
  ------------------
  |  Branch (3097:9): [True: 0, False: 2]
  ------------------
 3098|      0|	return;
 3099|       |
 3100|      2|    xmlInitializeCatalogData();
 3101|      2|    xmlRMutexLock(xmlCatalogMutex);
 3102|       |
 3103|      2|    if (getenv("XML_DEBUG_CATALOG"))
  ------------------
  |  Branch (3103:9): [True: 0, False: 2]
  ------------------
 3104|      0|	xmlDebugCatalogs = 1;
 3105|       |
 3106|      2|    if (xmlDefaultCatalog == NULL) {
  ------------------
  |  Branch (3106:9): [True: 2, False: 0]
  ------------------
 3107|      2|	const char *catalogs;
 3108|      2|	char *path;
 3109|      2|	const char *cur, *paths;
 3110|      2|	xmlCatalogPtr catal;
 3111|      2|	xmlCatalogEntryPtr *nextent;
 3112|       |
 3113|      2|	catalogs = (const char *) getenv("XML_CATALOG_FILES");
 3114|      2|	if (catalogs == NULL)
  ------------------
  |  Branch (3114:6): [True: 2, False: 0]
  ------------------
 3115|       |#if defined(_WIN32) && defined(_MSC_VER)
 3116|       |    {
 3117|       |		void* hmodule;
 3118|       |		hmodule = GetModuleHandleA("libxml2.dll");
 3119|       |		if (hmodule == NULL)
 3120|       |			hmodule = GetModuleHandleA(NULL);
 3121|       |		if (hmodule != NULL) {
 3122|       |			char buf[256];
 3123|       |			unsigned long len = GetModuleFileNameA(hmodule, buf, 255);
 3124|       |			if (len != 0) {
 3125|       |				char* p = &(buf[len]);
 3126|       |				while (*p != '\\' && p > buf)
 3127|       |					p--;
 3128|       |				if (p != buf) {
 3129|       |					xmlChar* uri;
 3130|       |					strncpy(p, "\\..\\etc\\catalog", 255 - (p - buf));
 3131|       |					uri = xmlCanonicPath((const xmlChar*)buf);
 3132|       |					if (uri != NULL) {
 3133|       |						strncpy(XML_XML_DEFAULT_CATALOG, (char* )uri, 255);
 3134|       |						xmlFree(uri);
 3135|       |					}
 3136|       |				}
 3137|       |			}
 3138|       |		}
 3139|       |		catalogs = XML_XML_DEFAULT_CATALOG;
 3140|       |    }
 3141|       |#else
 3142|      2|	    catalogs = XML_XML_DEFAULT_CATALOG;
  ------------------
  |  |   70|      2|#define XML_XML_DEFAULT_CATALOG "file://" SYSCONFDIR "/xml/catalog"
  ------------------
 3143|      2|#endif
 3144|       |
 3145|      2|	catal = xmlCreateNewCatalog(XML_XML_CATALOG_TYPE,
 3146|      2|		xmlCatalogDefaultPrefer);
 3147|      2|	if (catal != NULL) {
  ------------------
  |  Branch (3147:6): [True: 2, False: 0]
  ------------------
 3148|       |	    /* the XML_CATALOG_FILES envvar is allowed to contain a
 3149|       |	       space-separated list of entries. */
 3150|      2|	    cur = catalogs;
 3151|      2|	    nextent = &catal->xml;
 3152|      4|	    while (*cur != '\0') {
  ------------------
  |  Branch (3152:13): [True: 2, False: 2]
  ------------------
 3153|      2|		while (xmlIsBlank_ch(*cur))
  ------------------
  |  |   88|      2|#define xmlIsBlank_ch(c)	(((c) == 0x20) || \
  |  |  ------------------
  |  |  |  Branch (88:27): [True: 0, False: 2]
  |  |  ------------------
  |  |   89|      2|				 ((0x9 <= (c)) && ((c) <= 0xa)) || \
  |  |  ------------------
  |  |  |  Branch (89:7): [True: 2, False: 0]
  |  |  |  Branch (89:23): [True: 0, False: 2]
  |  |  ------------------
  |  |   90|      2|				 ((c) == 0xd))
  |  |  ------------------
  |  |  |  Branch (90:6): [True: 0, False: 2]
  |  |  ------------------
  ------------------
 3154|      0|		    cur++;
 3155|      2|		if (*cur != 0) {
  ------------------
  |  Branch (3155:7): [True: 2, False: 0]
  ------------------
 3156|      2|		    paths = cur;
 3157|     68|		    while ((*cur != 0) && (!xmlIsBlank_ch(*cur)))
  ------------------
  |  |   88|     66|#define xmlIsBlank_ch(c)	(((c) == 0x20) || \
  |  |  ------------------
  |  |  |  Branch (88:27): [True: 0, False: 66]
  |  |  ------------------
  |  |   89|     66|				 ((0x9 <= (c)) && ((c) <= 0xa)) || \
  |  |  ------------------
  |  |  |  Branch (89:7): [True: 66, False: 0]
  |  |  |  Branch (89:23): [True: 0, False: 66]
  |  |  ------------------
  |  |   90|     66|				 ((c) == 0xd))
  |  |  ------------------
  |  |  |  Branch (90:6): [True: 0, False: 66]
  |  |  ------------------
  ------------------
  |  Branch (3157:14): [True: 66, False: 2]
  ------------------
 3158|     66|			cur++;
 3159|      2|		    path = (char *) xmlStrndup((const xmlChar *)paths, cur - paths);
 3160|      2|		    if (path != NULL) {
  ------------------
  |  Branch (3160:11): [True: 2, False: 0]
  ------------------
 3161|      2|			*nextent = xmlNewCatalogEntry(XML_CATA_CATALOG, NULL,
 3162|      2|				NULL, BAD_CAST path, xmlCatalogDefaultPrefer, NULL);
  ------------------
  |  |   35|      2|#define BAD_CAST (xmlChar *)
  ------------------
 3163|      2|			if (*nextent != NULL)
  ------------------
  |  Branch (3163:8): [True: 2, False: 0]
  ------------------
 3164|      2|			    nextent = &((*nextent)->next);
 3165|      2|			xmlFree(path);
 3166|      2|		    }
 3167|      2|		}
 3168|      2|	    }
 3169|      2|	    xmlDefaultCatalog = catal;
 3170|      2|	}
 3171|      2|    }
 3172|       |
 3173|      2|    xmlRMutexUnlock(xmlCatalogMutex);
 3174|      2|}
catalog.c:xmlCreateNewCatalog:
  406|      2|xmlCreateNewCatalog(xmlCatalogType type, xmlCatalogPrefer prefer) {
  407|      2|    xmlCatalogPtr ret;
  408|       |
  409|      2|    ret = (xmlCatalogPtr) xmlMalloc(sizeof(xmlCatalog));
  410|      2|    if (ret == NULL) {
  ------------------
  |  Branch (410:9): [True: 0, False: 2]
  ------------------
  411|      0|        xmlCatalogErrMemory("allocating catalog");
  412|      0|	return(NULL);
  413|      0|    }
  414|      2|    memset(ret, 0, sizeof(xmlCatalog));
  415|      2|    ret->type = type;
  416|      2|    ret->catalNr = 0;
  417|      2|    ret->catalMax = XML_MAX_SGML_CATA_DEPTH;
  ------------------
  |  |  144|      2|#define XML_MAX_SGML_CATA_DEPTH 10
  ------------------
  418|      2|    ret->prefer = prefer;
  419|      2|    if (ret->type == XML_SGML_CATALOG_TYPE)
  ------------------
  |  Branch (419:9): [True: 0, False: 2]
  ------------------
  420|      0|	ret->sgml = xmlHashCreate(10);
  421|      2|    return(ret);
  422|      2|}
catalog.c:xmlNewCatalogEntry:
  267|      2|	   xmlCatalogEntryPtr group) {
  268|      2|    xmlCatalogEntryPtr ret;
  269|      2|    xmlChar *normid = NULL;
  270|       |
  271|      2|    ret = (xmlCatalogEntryPtr) xmlMalloc(sizeof(xmlCatalogEntry));
  272|      2|    if (ret == NULL) {
  ------------------
  |  Branch (272:9): [True: 0, False: 2]
  ------------------
  273|      0|        xmlCatalogErrMemory("allocating catalog entry");
  274|      0|	return(NULL);
  275|      0|    }
  276|      2|    ret->next = NULL;
  277|      2|    ret->parent = NULL;
  278|      2|    ret->children = NULL;
  279|      2|    ret->type = type;
  280|      2|    if (type == XML_CATA_PUBLIC || type == XML_CATA_DELEGATE_PUBLIC) {
  ------------------
  |  Branch (280:9): [True: 0, False: 2]
  |  Branch (280:36): [True: 0, False: 2]
  ------------------
  281|      0|        normid = xmlCatalogNormalizePublic(name);
  282|      0|        if (normid != NULL)
  ------------------
  |  Branch (282:13): [True: 0, False: 0]
  ------------------
  283|      0|            name = (*normid != 0 ? normid : NULL);
  ------------------
  |  Branch (283:21): [True: 0, False: 0]
  ------------------
  284|      0|    }
  285|      2|    if (name != NULL)
  ------------------
  |  Branch (285:9): [True: 0, False: 2]
  ------------------
  286|      0|	ret->name = xmlStrdup(name);
  287|      2|    else
  288|      2|	ret->name = NULL;
  289|      2|    if (normid != NULL)
  ------------------
  |  Branch (289:9): [True: 0, False: 2]
  ------------------
  290|      0|        xmlFree(normid);
  291|      2|    if (value != NULL)
  ------------------
  |  Branch (291:9): [True: 0, False: 2]
  ------------------
  292|      0|	ret->value = xmlStrdup(value);
  293|      2|    else
  294|      2|	ret->value = NULL;
  295|      2|    if (URL == NULL)
  ------------------
  |  Branch (295:9): [True: 0, False: 2]
  ------------------
  296|      0|	URL = value;
  297|      2|    if (URL != NULL)
  ------------------
  |  Branch (297:9): [True: 2, False: 0]
  ------------------
  298|      2|	ret->URL = xmlStrdup(URL);
  299|      0|    else
  300|      0|	ret->URL = NULL;
  301|      2|    ret->prefer = prefer;
  302|      2|    ret->dealloc = 0;
  303|      2|    ret->depth = 0;
  304|      2|    ret->group = group;
  305|      2|    return(ret);
  306|      2|}
catalog.c:xmlInitializeCatalogData:
 3078|      2|xmlInitializeCatalogData(void) {
 3079|      2|    if (xmlCatalogInitialized != 0)
  ------------------
  |  Branch (3079:9): [True: 0, False: 2]
  ------------------
 3080|      0|	return;
 3081|       |
 3082|      2|    if (getenv("XML_DEBUG_CATALOG"))
  ------------------
  |  Branch (3082:9): [True: 0, False: 2]
  ------------------
 3083|      0|	xmlDebugCatalogs = 1;
 3084|      2|    xmlCatalogMutex = xmlNewRMutex();
 3085|       |
 3086|      2|    xmlCatalogInitialized = 1;
 3087|      2|}

xmlCharInRange:
  170|      2|xmlCharInRange (unsigned int val, const xmlChRangeGroup *rptr) {
  171|      2|    int low, high, mid;
  172|      2|    const xmlChSRange *sptr;
  173|      2|    const xmlChLRange *lptr;
  174|       |
  175|      2|    if (rptr == NULL) return(0);
  ------------------
  |  Branch (175:9): [True: 0, False: 2]
  ------------------
  176|      2|    if (val < 0x10000) {	/* is val in 'short' or 'long'  array? */
  ------------------
  |  Branch (176:9): [True: 2, False: 0]
  ------------------
  177|      2|	if (rptr->nbShortRange == 0)
  ------------------
  |  Branch (177:6): [True: 0, False: 2]
  ------------------
  178|      0|	    return 0;
  179|      2|	low = 0;
  180|      2|	high = rptr->nbShortRange - 1;
  181|      2|	sptr = rptr->shortRange;
  182|     10|	while (low <= high) {
  ------------------
  |  Branch (182:9): [True: 8, False: 2]
  ------------------
  183|      8|	    mid = (low + high) / 2;
  184|      8|	    if ((unsigned short) val < sptr[mid].low) {
  ------------------
  |  Branch (184:10): [True: 8, False: 0]
  ------------------
  185|      8|		high = mid - 1;
  186|      8|	    } else {
  187|      0|	        if ((unsigned short) val > sptr[mid].high) {
  ------------------
  |  Branch (187:14): [True: 0, False: 0]
  ------------------
  188|      0|		    low = mid + 1;
  189|      0|		} else {
  190|      0|		    return 1;
  191|      0|		}
  192|      0|	    }
  193|      8|	}
  194|      2|    } else {
  195|      0|	if (rptr->nbLongRange == 0) {
  ------------------
  |  Branch (195:6): [True: 0, False: 0]
  ------------------
  196|      0|	    return 0;
  197|      0|	}
  198|      0|	low = 0;
  199|      0|	high = rptr->nbLongRange - 1;
  200|      0|	lptr = rptr->longRange;
  201|      0|	while (low <= high) {
  ------------------
  |  Branch (201:9): [True: 0, False: 0]
  ------------------
  202|      0|	    mid = (low + high) / 2;
  203|      0|	    if (val < lptr[mid].low) {
  ------------------
  |  Branch (203:10): [True: 0, False: 0]
  ------------------
  204|      0|		high = mid - 1;
  205|      0|	    } else {
  206|      0|	        if (val > lptr[mid].high) {
  ------------------
  |  Branch (206:14): [True: 0, False: 0]
  ------------------
  207|      0|		    low = mid + 1;
  208|      0|		} else {
  209|      0|		    return 1;
  210|      0|		}
  211|      0|	    }
  212|      0|	}
  213|      0|    }
  214|      2|    return 0;
  215|      2|}

xmlInitDictInternal:
   99|      2|xmlInitDictInternal(void) {
  100|      2|    xmlInitMutex(&xmlDictMutex);
  101|      2|}
xmlDictCreate:
  262|    482|xmlDictCreate(void) {
  263|    482|    xmlDictPtr dict;
  264|       |
  265|    482|    xmlInitParser();
  266|       |
  267|    482|    dict = xmlMalloc(sizeof(xmlDict));
  268|    482|    if (dict == NULL)
  ------------------
  |  Branch (268:9): [True: 0, False: 482]
  ------------------
  269|      0|        return(NULL);
  270|    482|    dict->ref_counter = 1;
  271|    482|    dict->limit = 0;
  272|       |
  273|    482|    dict->size = 0;
  274|    482|    dict->nbElems = 0;
  275|    482|    dict->table = NULL;
  276|    482|    dict->strings = NULL;
  277|    482|    dict->subdict = NULL;
  278|    482|    dict->seed = xmlRandom();
  279|    482|#ifdef FUZZING_BUILD_MODE_UNSAFE_FOR_PRODUCTION
  280|    482|    dict->seed = 0;
  281|    482|#endif
  282|    482|    return(dict);
  283|    482|}
xmlDictReference:
  317|  1.36k|xmlDictReference(xmlDictPtr dict) {
  318|  1.36k|    if (dict == NULL) return -1;
  ------------------
  |  Branch (318:9): [True: 0, False: 1.36k]
  ------------------
  319|  1.36k|    xmlMutexLock(&xmlDictMutex);
  320|  1.36k|    dict->ref_counter++;
  321|  1.36k|    xmlMutexUnlock(&xmlDictMutex);
  322|  1.36k|    return(0);
  323|  1.36k|}
xmlDictFree:
  333|  1.84k|xmlDictFree(xmlDictPtr dict) {
  334|  1.84k|    xmlDictStringsPtr pool, nextp;
  335|       |
  336|  1.84k|    if (dict == NULL)
  ------------------
  |  Branch (336:9): [True: 0, False: 1.84k]
  ------------------
  337|      0|	return;
  338|       |
  339|       |    /* decrement the counter, it may be shared by a parser and docs */
  340|  1.84k|    xmlMutexLock(&xmlDictMutex);
  341|  1.84k|    dict->ref_counter--;
  342|  1.84k|    if (dict->ref_counter > 0) {
  ------------------
  |  Branch (342:9): [True: 1.36k, False: 482]
  ------------------
  343|  1.36k|        xmlMutexUnlock(&xmlDictMutex);
  344|  1.36k|        return;
  345|  1.36k|    }
  346|       |
  347|    482|    xmlMutexUnlock(&xmlDictMutex);
  348|       |
  349|    482|    if (dict->subdict != NULL) {
  ------------------
  |  Branch (349:9): [True: 0, False: 482]
  ------------------
  350|      0|        xmlDictFree(dict->subdict);
  351|      0|    }
  352|       |
  353|    482|    if (dict->table) {
  ------------------
  |  Branch (353:9): [True: 198, False: 284]
  ------------------
  354|    198|	xmlFree(dict->table);
  355|    198|    }
  356|    482|    pool = dict->strings;
  357|    687|    while (pool != NULL) {
  ------------------
  |  Branch (357:12): [True: 205, False: 482]
  ------------------
  358|    205|        nextp = pool->next;
  359|    205|	xmlFree(pool);
  360|    205|	pool = nextp;
  361|    205|    }
  362|    482|    xmlFree(dict);
  363|    482|}
xmlDictOwns:
  376|  18.6k|xmlDictOwns(xmlDictPtr dict, const xmlChar *str) {
  377|  18.6k|    xmlDictStringsPtr pool;
  378|       |
  379|  18.6k|    if ((dict == NULL) || (str == NULL))
  ------------------
  |  Branch (379:9): [True: 0, False: 18.6k]
  |  Branch (379:27): [True: 0, False: 18.6k]
  ------------------
  380|      0|	return(-1);
  381|  18.6k|    pool = dict->strings;
  382|  27.0k|    while (pool != NULL) {
  ------------------
  |  Branch (382:12): [True: 22.6k, False: 4.40k]
  ------------------
  383|  22.6k|        if ((str >= &pool->array[0]) && (str <= pool->free))
  ------------------
  |  Branch (383:13): [True: 16.0k, False: 6.59k]
  |  Branch (383:41): [True: 14.2k, False: 1.82k]
  ------------------
  384|  14.2k|	    return(1);
  385|  8.41k|	pool = pool->next;
  386|  8.41k|    }
  387|  4.40k|    if (dict->subdict)
  ------------------
  |  Branch (387:9): [True: 0, False: 4.40k]
  ------------------
  388|      0|        return(xmlDictOwns(dict->subdict, str));
  389|  4.40k|    return(0);
  390|  4.40k|}
xmlDictSetLimit:
  421|    242|xmlDictSetLimit(xmlDictPtr dict, size_t limit) {
  422|    242|    size_t ret;
  423|       |
  424|    242|    if (dict == NULL)
  ------------------
  |  Branch (424:9): [True: 0, False: 242]
  ------------------
  425|      0|	return(0);
  426|    242|    ret = dict->limit;
  427|    242|    dict->limit = limit;
  428|    242|    return(ret);
  429|    242|}
xmlDictComputeHash:
  512|  3.42k|xmlDictComputeHash(const xmlDict *dict, const xmlChar *string) {
  513|  3.42k|    size_t len;
  514|  3.42k|    return(xmlDictHashName(dict->seed, string, SIZE_MAX, &len));
  ------------------
  |  |   35|  3.42k|  #define SIZE_MAX ((size_t) -1)
  ------------------
  515|  3.42k|}
xmlDictCombineHash:
  521|  2.56k|xmlDictCombineHash(unsigned v1, unsigned v2) {
  522|       |    /*
  523|       |     * The upper bit of hash values is always set, so we have to operate on
  524|       |     * 31-bit hashes here.
  525|       |     */
  526|  2.56k|    v1 ^= v2;
  527|  2.56k|    v1 += HASH_ROL31(v2, 5);
  ------------------
  |  |  517|  2.56k|#define HASH_ROL31(x,n) ((x) << (n) | ((x) & 0x7FFFFFFF) >> (31 - (n)))
  ------------------
  528|       |
  529|  2.56k|    return((v1 & 0xFFFFFFFF) | 0x80000000);
  530|  2.56k|}
xmlDictLookup:
  824|  13.1k|xmlDictLookup(xmlDictPtr dict, const xmlChar *name, int len) {
  825|  13.1k|    const xmlDictEntry *entry;
  826|       |
  827|  13.1k|    entry = xmlDictLookupInternal(dict, NULL, name, len, 1);
  828|  13.1k|    if (entry == NULL)
  ------------------
  |  Branch (828:9): [True: 0, False: 13.1k]
  ------------------
  829|      0|        return(NULL);
  830|  13.1k|    return(entry->name);
  831|  13.1k|}
xmlDictLookupHashed:
  845|  12.6k|xmlDictLookupHashed(xmlDictPtr dict, const xmlChar *name, int len) {
  846|  12.6k|    const xmlDictEntry *entry;
  847|  12.6k|    xmlHashedString ret;
  848|       |
  849|  12.6k|    entry = xmlDictLookupInternal(dict, NULL, name, len, 1);
  850|       |
  851|  12.6k|    if (entry == NULL) {
  ------------------
  |  Branch (851:9): [True: 0, False: 12.6k]
  ------------------
  852|      0|        ret.name = NULL;
  853|      0|        ret.hashValue = 0;
  854|  12.6k|    } else {
  855|  12.6k|        ret = *entry;
  856|  12.6k|    }
  857|       |
  858|  12.6k|    return(ret);
  859|  12.6k|}
xmlDictQLookup:
  894|      2|xmlDictQLookup(xmlDictPtr dict, const xmlChar *prefix, const xmlChar *name) {
  895|      2|    const xmlDictEntry *entry;
  896|       |
  897|      2|    entry = xmlDictLookupInternal(dict, prefix, name, -1, 1);
  898|      2|    if (entry == NULL)
  ------------------
  |  Branch (898:9): [True: 0, False: 2]
  ------------------
  899|      0|        return(NULL);
  900|      2|    return(entry->name);
  901|      2|}
xmlInitRandom:
  918|      2|xmlInitRandom(void) {
  919|      2|    int var;
  920|       |
  921|      2|    xmlInitMutex(&xmlRngMutex);
  922|       |
  923|       |    /* TODO: Get seed values from system PRNG */
  924|       |
  925|      2|    globalRngState[0] = (unsigned) time(NULL) ^
  926|      2|                        HASH_ROL((unsigned) (size_t) &xmlInitRandom, 8);
  ------------------
  |  |   12|      2|#define HASH_ROL(x,n) ((x) << (n) | ((x) & 0xFFFFFFFF) >> (32 - (n)))
  ------------------
  927|      2|    globalRngState[1] = HASH_ROL((unsigned) (size_t) &xmlRngMutex, 16) ^
  ------------------
  |  |   12|      2|#define HASH_ROL(x,n) ((x) << (n) | ((x) & 0xFFFFFFFF) >> (32 - (n)))
  ------------------
  928|      2|                        HASH_ROL((unsigned) (size_t) &var, 24);
  ------------------
  |  |   12|      2|#define HASH_ROL(x,n) ((x) << (n) | ((x) & 0xFFFFFFFF) >> (32 - (n)))
  ------------------
  929|      2|}
xmlRandom:
  951|  1.12k|xmlRandom(void) {
  952|  1.12k|#ifdef XML_THREAD_LOCAL
  953|  1.12k|    if (!localRngInitialized) {
  ------------------
  |  Branch (953:9): [True: 1, False: 1.12k]
  ------------------
  954|      1|        xmlMutexLock(&xmlRngMutex);
  955|      1|        localRngState[0] = xoroshiro64ss(globalRngState);
  956|      1|        localRngState[1] = xoroshiro64ss(globalRngState);
  957|      1|        localRngInitialized = 1;
  958|      1|        xmlMutexUnlock(&xmlRngMutex);
  959|      1|    }
  960|       |
  961|  1.12k|    return(xoroshiro64ss(localRngState));
  962|       |#else
  963|       |    unsigned ret;
  964|       |
  965|       |    xmlMutexLock(&xmlRngMutex);
  966|       |    ret = xoroshiro64ss(globalRngState);
  967|       |    xmlMutexUnlock(&xmlRngMutex);
  968|       |
  969|       |    return(ret);
  970|       |#endif
  971|  1.12k|}
dict.c:xmlDictHashName:
  465|  29.2k|                size_t *plen) {
  466|  29.2k|    unsigned h1, h2;
  467|  29.2k|    size_t i;
  468|       |
  469|  29.2k|    HASH_INIT(h1, h2, seed);
  ------------------
  |  |   23|  29.2k|    do { \
  |  |   24|  29.2k|        h1 = seed ^ 0x3b00; \
  |  |   25|  29.2k|        h2 = HASH_ROL(seed, 15); \
  |  |  ------------------
  |  |  |  |   12|  29.2k|#define HASH_ROL(x,n) ((x) << (n) | ((x) & 0xFFFFFFFF) >> (32 - (n)))
  |  |  ------------------
  |  |   26|  29.2k|    } while (0)
  |  |  ------------------
  |  |  |  Branch (26:14): [Folded - Ignored]
  |  |  ------------------
  ------------------
  470|       |
  471|   226k|    for (i = 0; i < maxLen && data[i]; i++) {
  ------------------
  |  Branch (471:17): [True: 206k, False: 20.0k]
  |  Branch (471:31): [True: 197k, False: 9.20k]
  ------------------
  472|   197k|        HASH_UPDATE(h1, h2, data[i]);
  ------------------
  |  |   29|   197k|    do { \
  |  |   30|   197k|        h1 += ch; \
  |  |   31|   197k|        h1 += h1 << 3; \
  |  |   32|   197k|        h2 += h1; \
  |  |   33|   197k|        h2 = HASH_ROL(h2, 7); \
  |  |  ------------------
  |  |  |  |   12|   197k|#define HASH_ROL(x,n) ((x) << (n) | ((x) & 0xFFFFFFFF) >> (32 - (n)))
  |  |  ------------------
  |  |   34|   197k|        h2 += h2 << 2; \
  |  |   35|   197k|    } while (0)
  |  |  ------------------
  |  |  |  Branch (35:14): [Folded - Ignored]
  |  |  ------------------
  ------------------
  473|   197k|    }
  474|       |
  475|  29.2k|    HASH_FINISH(h1, h2);
  ------------------
  |  |   39|  29.2k|    do { \
  |  |   40|  29.2k|        h1 ^= h2; \
  |  |   41|  29.2k|        h1 += HASH_ROL(h2, 14); \
  |  |  ------------------
  |  |  |  |   12|  29.2k|#define HASH_ROL(x,n) ((x) << (n) | ((x) & 0xFFFFFFFF) >> (32 - (n)))
  |  |  ------------------
  |  |   42|  29.2k|        h2 ^= h1; h2 += HASH_ROR(h1, 6); \
  |  |  ------------------
  |  |  |  |   13|  29.2k|#define HASH_ROR(x,n) (((x) & 0xFFFFFFFF) >> (n) | (x) << (32 - (n)))
  |  |  ------------------
  |  |   43|  29.2k|        h1 ^= h2; h1 += HASH_ROL(h2, 5); \
  |  |  ------------------
  |  |  |  |   12|  29.2k|#define HASH_ROL(x,n) ((x) << (n) | ((x) & 0xFFFFFFFF) >> (32 - (n)))
  |  |  ------------------
  |  |   44|  29.2k|        h2 ^= h1; h2 += HASH_ROR(h1, 8); \
  |  |  ------------------
  |  |  |  |   13|  29.2k|#define HASH_ROR(x,n) (((x) & 0xFFFFFFFF) >> (n) | (x) << (32 - (n)))
  |  |  ------------------
  |  |   45|  29.2k|        h2 &= 0xFFFFFFFF; \
  |  |   46|  29.2k|    } while (0)
  |  |  ------------------
  |  |  |  Branch (46:14): [Folded - Ignored]
  |  |  ------------------
  ------------------
  476|       |
  477|  29.2k|    *plen = i;
  478|  29.2k|    return(h2 | MAX_HASH_SIZE);
  ------------------
  |  |   41|  29.2k|#define MAX_HASH_SIZE (1u << 31)
  ------------------
  479|  29.2k|}
dict.c:xmlDictLookupInternal:
  679|  25.7k|                      const xmlChar *name, int maybeLen, int update) {
  680|  25.7k|    xmlDictEntry *entry = NULL;
  681|  25.7k|    const xmlChar *ret;
  682|  25.7k|    unsigned hashValue;
  683|  25.7k|    size_t maxLen, len, plen, klen;
  684|  25.7k|    int found = 0;
  685|       |
  686|  25.7k|    if ((dict == NULL) || (name == NULL))
  ------------------
  |  Branch (686:9): [True: 0, False: 25.7k]
  |  Branch (686:27): [True: 0, False: 25.7k]
  ------------------
  687|      0|	return(NULL);
  688|       |
  689|  25.7k|    maxLen = (maybeLen < 0) ? SIZE_MAX : (size_t) maybeLen;
  ------------------
  |  |   35|  5.78k|  #define SIZE_MAX ((size_t) -1)
  ------------------
  |  Branch (689:14): [True: 5.78k, False: 20.0k]
  ------------------
  690|       |
  691|  25.7k|    if (prefix == NULL) {
  ------------------
  |  Branch (691:9): [True: 25.7k, False: 2]
  ------------------
  692|  25.7k|        hashValue = xmlDictHashName(dict->seed, name, maxLen, &len);
  693|  25.7k|        if (len > INT_MAX / 2)
  ------------------
  |  Branch (693:13): [True: 0, False: 25.7k]
  ------------------
  694|      0|            return(NULL);
  695|  25.7k|        klen = len;
  696|  25.7k|    } else {
  697|      2|        hashValue = xmlDictHashQName(dict->seed, prefix, name, &plen, &len);
  698|      2|        if ((len > INT_MAX / 2) || (plen >= INT_MAX / 2 - len))
  ------------------
  |  Branch (698:13): [True: 0, False: 2]
  |  Branch (698:36): [True: 0, False: 2]
  ------------------
  699|      0|            return(NULL);
  700|      2|        klen = plen + 1 + len;
  701|      2|    }
  702|       |
  703|  25.7k|    if ((dict->limit > 0) && (klen >= dict->limit))
  ------------------
  |  Branch (703:9): [True: 0, False: 25.7k]
  |  Branch (703:30): [True: 0, False: 0]
  ------------------
  704|      0|        return(NULL);
  705|       |
  706|       |    /*
  707|       |     * Check for an existing entry
  708|       |     */
  709|  25.7k|    if (dict->size > 0)
  ------------------
  |  Branch (709:9): [True: 25.6k, False: 198]
  ------------------
  710|  25.6k|        entry = xmlDictFindEntry(dict, prefix, name, klen, hashValue, &found);
  711|  25.7k|    if (found)
  ------------------
  |  Branch (711:9): [True: 18.3k, False: 7.48k]
  ------------------
  712|  18.3k|        return(entry);
  713|       |
  714|  7.48k|    if ((dict->subdict != NULL) && (dict->subdict->size > 0)) {
  ------------------
  |  Branch (714:9): [True: 0, False: 7.48k]
  |  Branch (714:36): [True: 0, False: 0]
  ------------------
  715|      0|        xmlDictEntry *subEntry;
  716|      0|        unsigned subHashValue;
  717|       |
  718|      0|        if (prefix == NULL)
  ------------------
  |  Branch (718:13): [True: 0, False: 0]
  ------------------
  719|      0|            subHashValue = xmlDictHashName(dict->subdict->seed, name, len,
  720|      0|                                           &len);
  721|      0|        else
  722|      0|            subHashValue = xmlDictHashQName(dict->subdict->seed, prefix, name,
  723|      0|                                            &plen, &len);
  724|      0|        subEntry = xmlDictFindEntry(dict->subdict, prefix, name, klen,
  725|      0|                                    subHashValue, &found);
  726|      0|        if (found)
  ------------------
  |  Branch (726:13): [True: 0, False: 0]
  ------------------
  727|      0|            return(subEntry);
  728|      0|    }
  729|       |
  730|  7.48k|    if (!update)
  ------------------
  |  Branch (730:9): [True: 0, False: 7.48k]
  ------------------
  731|      0|        return(NULL);
  732|       |
  733|       |    /*
  734|       |     * Grow the hash table if needed
  735|       |     */
  736|  7.48k|    if (dict->nbElems + 1 > dict->size / MAX_FILL_DENOM * MAX_FILL_NUM) {
  ------------------
  |  |   39|  7.48k|#define MAX_FILL_DENOM 8
  ------------------
                  if (dict->nbElems + 1 > dict->size / MAX_FILL_DENOM * MAX_FILL_NUM) {
  ------------------
  |  |   38|  7.48k|#define MAX_FILL_NUM 7
  ------------------
  |  Branch (736:9): [True: 727, False: 6.75k]
  ------------------
  737|    727|        unsigned newSize, mask, displ, pos;
  738|       |
  739|    727|        if (dict->size == 0) {
  ------------------
  |  Branch (739:13): [True: 198, False: 529]
  ------------------
  740|    198|            newSize = MIN_HASH_SIZE;
  ------------------
  |  |   40|    198|#define MIN_HASH_SIZE 8
  ------------------
  741|    529|        } else {
  742|    529|            if (dict->size >= MAX_HASH_SIZE)
  ------------------
  |  |   41|    529|#define MAX_HASH_SIZE (1u << 31)
  ------------------
  |  Branch (742:17): [True: 0, False: 529]
  ------------------
  743|      0|                return(NULL);
  744|    529|            newSize = dict->size * 2;
  745|    529|        }
  746|    727|        if (xmlDictGrow(dict, newSize) != 0)
  ------------------
  |  Branch (746:13): [True: 0, False: 727]
  ------------------
  747|      0|            return(NULL);
  748|       |
  749|       |        /*
  750|       |         * Find new entry
  751|       |         */
  752|    727|        mask = dict->size - 1;
  753|    727|        displ = 0;
  754|    727|        pos = hashValue & mask;
  755|    727|        entry = &dict->table[pos];
  756|       |
  757|    963|        while ((entry->hashValue != 0) &&
  ------------------
  |  Branch (757:16): [True: 296, False: 667]
  ------------------
  758|    963|               ((pos - entry->hashValue) & mask) >= displ) {
  ------------------
  |  Branch (758:16): [True: 236, False: 60]
  ------------------
  759|    236|            displ++;
  760|    236|            pos++;
  761|    236|            entry++;
  762|    236|            if ((pos & mask) == 0)
  ------------------
  |  Branch (762:17): [True: 22, False: 214]
  ------------------
  763|     22|                entry = dict->table;
  764|    236|        }
  765|    727|    }
  766|       |
  767|  7.48k|    if (prefix == NULL)
  ------------------
  |  Branch (767:9): [True: 7.48k, False: 2]
  ------------------
  768|  7.48k|        ret = xmlDictAddString(dict, name, len);
  769|      2|    else
  770|      2|        ret = xmlDictAddQString(dict, prefix, plen, name, len);
  771|  7.48k|    if (ret == NULL)
  ------------------
  |  Branch (771:9): [True: 0, False: 7.48k]
  ------------------
  772|      0|        return(NULL);
  773|       |
  774|       |    /*
  775|       |     * Shift the remainder of the probe sequence to the right
  776|       |     */
  777|  7.48k|    if (entry->hashValue != 0) {
  ------------------
  |  Branch (777:9): [True: 2.22k, False: 5.25k]
  ------------------
  778|  2.22k|        const xmlDictEntry *end = &dict->table[dict->size];
  779|  2.22k|        const xmlDictEntry *cur = entry;
  780|       |
  781|  9.86k|        do {
  782|  9.86k|            cur++;
  783|  9.86k|            if (cur >= end)
  ------------------
  |  Branch (783:17): [True: 559, False: 9.30k]
  ------------------
  784|    559|                cur = dict->table;
  785|  9.86k|        } while (cur->hashValue != 0);
  ------------------
  |  Branch (785:18): [True: 7.64k, False: 2.22k]
  ------------------
  786|       |
  787|  2.22k|        if (cur < entry) {
  ------------------
  |  Branch (787:13): [True: 559, False: 1.66k]
  ------------------
  788|       |            /*
  789|       |             * If we traversed the end of the buffer, handle the part
  790|       |             * at the start of the buffer.
  791|       |             */
  792|    559|            memmove(&dict->table[1], dict->table,
  793|    559|                    (char *) cur - (char *) dict->table);
  794|    559|            cur = end - 1;
  795|    559|            dict->table[0] = *cur;
  796|    559|        }
  797|       |
  798|  2.22k|        memmove(&entry[1], entry, (char *) cur - (char *) entry);
  799|  2.22k|    }
  800|       |
  801|       |    /*
  802|       |     * Populate entry
  803|       |     */
  804|  7.48k|    entry->hashValue = hashValue;
  805|  7.48k|    entry->name = ret;
  806|       |
  807|  7.48k|    dict->nbElems++;
  808|       |
  809|  7.48k|    return(entry);
  810|  7.48k|}
dict.c:xmlDictHashQName:
  484|      2|                 size_t *pplen, size_t *plen) {
  485|      2|    unsigned h1, h2;
  486|      2|    size_t i;
  487|       |
  488|      2|    HASH_INIT(h1, h2, seed);
  ------------------
  |  |   23|      2|    do { \
  |  |   24|      2|        h1 = seed ^ 0x3b00; \
  |  |   25|      2|        h2 = HASH_ROL(seed, 15); \
  |  |  ------------------
  |  |  |  |   12|      2|#define HASH_ROL(x,n) ((x) << (n) | ((x) & 0xFFFFFFFF) >> (32 - (n)))
  |  |  ------------------
  |  |   26|      2|    } while (0)
  |  |  ------------------
  |  |  |  Branch (26:14): [Folded - Ignored]
  |  |  ------------------
  ------------------
  489|       |
  490|     14|    for (i = 0; prefix[i] != 0; i++) {
  ------------------
  |  Branch (490:17): [True: 12, False: 2]
  ------------------
  491|     12|        HASH_UPDATE(h1, h2, prefix[i]);
  ------------------
  |  |   29|     12|    do { \
  |  |   30|     12|        h1 += ch; \
  |  |   31|     12|        h1 += h1 << 3; \
  |  |   32|     12|        h2 += h1; \
  |  |   33|     12|        h2 = HASH_ROL(h2, 7); \
  |  |  ------------------
  |  |  |  |   12|     12|#define HASH_ROL(x,n) ((x) << (n) | ((x) & 0xFFFFFFFF) >> (32 - (n)))
  |  |  ------------------
  |  |   34|     12|        h2 += h2 << 2; \
  |  |   35|     12|    } while (0)
  |  |  ------------------
  |  |  |  Branch (35:14): [Folded - Ignored]
  |  |  ------------------
  ------------------
  492|     12|    }
  493|      2|    *pplen = i;
  494|       |
  495|      2|    HASH_UPDATE(h1, h2, ':');
  ------------------
  |  |   29|      2|    do { \
  |  |   30|      2|        h1 += ch; \
  |  |   31|      2|        h1 += h1 << 3; \
  |  |   32|      2|        h2 += h1; \
  |  |   33|      2|        h2 = HASH_ROL(h2, 7); \
  |  |  ------------------
  |  |  |  |   12|      2|#define HASH_ROL(x,n) ((x) << (n) | ((x) & 0xFFFFFFFF) >> (32 - (n)))
  |  |  ------------------
  |  |   34|      2|        h2 += h2 << 2; \
  |  |   35|      2|    } while (0)
  |  |  ------------------
  |  |  |  Branch (35:14): [Folded - Ignored]
  |  |  ------------------
  ------------------
  496|       |
  497|      8|    for (i = 0; name[i] != 0; i++) {
  ------------------
  |  Branch (497:17): [True: 6, False: 2]
  ------------------
  498|      6|        HASH_UPDATE(h1, h2, name[i]);
  ------------------
  |  |   29|      6|    do { \
  |  |   30|      6|        h1 += ch; \
  |  |   31|      6|        h1 += h1 << 3; \
  |  |   32|      6|        h2 += h1; \
  |  |   33|      6|        h2 = HASH_ROL(h2, 7); \
  |  |  ------------------
  |  |  |  |   12|      6|#define HASH_ROL(x,n) ((x) << (n) | ((x) & 0xFFFFFFFF) >> (32 - (n)))
  |  |  ------------------
  |  |   34|      6|        h2 += h2 << 2; \
  |  |   35|      6|    } while (0)
  |  |  ------------------
  |  |  |  Branch (35:14): [Folded - Ignored]
  |  |  ------------------
  ------------------
  499|      6|    }
  500|      2|    *plen = i;
  501|       |
  502|      2|    HASH_FINISH(h1, h2);
  ------------------
  |  |   39|      2|    do { \
  |  |   40|      2|        h1 ^= h2; \
  |  |   41|      2|        h1 += HASH_ROL(h2, 14); \
  |  |  ------------------
  |  |  |  |   12|      2|#define HASH_ROL(x,n) ((x) << (n) | ((x) & 0xFFFFFFFF) >> (32 - (n)))
  |  |  ------------------
  |  |   42|      2|        h2 ^= h1; h2 += HASH_ROR(h1, 6); \
  |  |  ------------------
  |  |  |  |   13|      2|#define HASH_ROR(x,n) (((x) & 0xFFFFFFFF) >> (n) | (x) << (32 - (n)))
  |  |  ------------------
  |  |   43|      2|        h1 ^= h2; h1 += HASH_ROL(h2, 5); \
  |  |  ------------------
  |  |  |  |   12|      2|#define HASH_ROL(x,n) ((x) << (n) | ((x) & 0xFFFFFFFF) >> (32 - (n)))
  |  |  ------------------
  |  |   44|      2|        h2 ^= h1; h2 += HASH_ROR(h1, 8); \
  |  |  ------------------
  |  |  |  |   13|      2|#define HASH_ROR(x,n) (((x) & 0xFFFFFFFF) >> (n) | (x) << (32 - (n)))
  |  |  ------------------
  |  |   45|      2|        h2 &= 0xFFFFFFFF; \
  |  |   46|      2|    } while (0)
  |  |  ------------------
  |  |  |  Branch (46:14): [Folded - Ignored]
  |  |  ------------------
  ------------------
  503|       |
  504|       |    /*
  505|       |     * Always set the upper bit of hash values since 0 means an unoccupied
  506|       |     * bucket.
  507|       |     */
  508|      2|    return(h2 | MAX_HASH_SIZE);
  ------------------
  |  |   41|      2|#define MAX_HASH_SIZE (1u << 31)
  ------------------
  509|      2|}
dict.c:xmlDictFindEntry:
  549|  25.6k|                 int *pfound) {
  550|  25.6k|    xmlDictEntry *entry;
  551|  25.6k|    unsigned mask, pos, displ;
  552|  25.6k|    int found = 0;
  553|       |
  554|  25.6k|    mask = dict->size - 1;
  555|  25.6k|    pos = hashValue & mask;
  556|  25.6k|    entry = &dict->table[pos];
  557|       |
  558|  25.6k|    if (entry->hashValue != 0) {
  ------------------
  |  Branch (558:9): [True: 22.6k, False: 2.95k]
  ------------------
  559|       |        /*
  560|       |         * Robin hood hashing: abort if the displacement of the entry
  561|       |         * is smaller than the displacement of the key we look for.
  562|       |         * This also stops at the correct position when inserting.
  563|       |         */
  564|  22.6k|        displ = 0;
  565|       |
  566|  39.9k|        do {
  567|  39.9k|            if (entry->hashValue == hashValue) {
  ------------------
  |  Branch (567:17): [True: 18.3k, False: 21.6k]
  ------------------
  568|  18.3k|                if (prefix == NULL) {
  ------------------
  |  Branch (568:21): [True: 18.3k, False: 0]
  ------------------
  569|       |                    /*
  570|       |                     * name is not necessarily null-terminated.
  571|       |                     */
  572|  18.3k|                    if ((strncmp((const char *) entry->name,
  ------------------
  |  Branch (572:25): [True: 18.3k, False: 0]
  ------------------
  573|  18.3k|                                 (const char *) name, len) == 0) &&
  574|  18.3k|                        (entry->name[len] == 0)) {
  ------------------
  |  Branch (574:25): [True: 18.3k, False: 0]
  ------------------
  575|  18.3k|                        found = 1;
  576|  18.3k|                        break;
  577|  18.3k|                    }
  578|  18.3k|                } else {
  579|      0|                    if (xmlStrQEqual(prefix, name, entry->name)) {
  ------------------
  |  Branch (579:25): [True: 0, False: 0]
  ------------------
  580|      0|                        found = 1;
  581|      0|                        break;
  582|      0|                    }
  583|      0|                }
  584|  18.3k|            }
  585|       |
  586|  21.6k|            displ++;
  587|  21.6k|            pos++;
  588|  21.6k|            entry++;
  589|  21.6k|            if ((pos & mask) == 0)
  ------------------
  |  Branch (589:17): [True: 621, False: 21.0k]
  ------------------
  590|    621|                entry = dict->table;
  591|  21.6k|        } while ((entry->hashValue != 0) &&
  ------------------
  |  Branch (591:18): [True: 19.8k, False: 1.78k]
  ------------------
  592|  21.6k|                 (((pos - entry->hashValue) & mask) >= displ));
  ------------------
  |  Branch (592:18): [True: 17.3k, False: 2.54k]
  ------------------
  593|  22.6k|    }
  594|       |
  595|      0|    *pfound = found;
  596|  25.6k|    return(entry);
  597|  25.6k|}
dict.c:xmlDictGrow:
  609|    727|xmlDictGrow(xmlDictPtr dict, unsigned size) {
  610|    727|    const xmlDictEntry *oldentry, *oldend, *end;
  611|    727|    xmlDictEntry *table;
  612|    727|    unsigned oldsize, i;
  613|       |
  614|       |    /* Add 0 to avoid spurious -Wtype-limits warning on 64-bit GCC */
  615|    727|    if ((size_t) size + 0 > SIZE_MAX / sizeof(table[0]))
  ------------------
  |  |   35|    727|  #define SIZE_MAX ((size_t) -1)
  ------------------
  |  Branch (615:9): [True: 0, False: 727]
  ------------------
  616|      0|        return(-1);
  617|    727|    table = xmlMalloc(size * sizeof(table[0]));
  618|    727|    if (table == NULL)
  ------------------
  |  Branch (618:9): [True: 0, False: 727]
  ------------------
  619|      0|        return(-1);
  620|    727|    memset(table, 0, size * sizeof(table[0]));
  621|       |
  622|    727|    oldsize = dict->size;
  623|    727|    if (oldsize == 0)
  ------------------
  |  Branch (623:9): [True: 198, False: 529]
  ------------------
  624|    198|        goto done;
  625|       |
  626|    529|    oldend = &dict->table[oldsize];
  627|    529|    end = &table[size];
  628|       |
  629|       |    /*
  630|       |     * Robin Hood sorting order is maintained if we
  631|       |     *
  632|       |     * - compute dict indices with modulo
  633|       |     * - resize by an integer factor
  634|       |     * - start to copy from the beginning of a probe sequence
  635|       |     */
  636|    529|    oldentry = dict->table;
  637|  3.64k|    while (oldentry->hashValue != 0) {
  ------------------
  |  Branch (637:12): [True: 3.11k, False: 529]
  ------------------
  638|  3.11k|        if (++oldentry >= oldend)
  ------------------
  |  Branch (638:13): [True: 0, False: 3.11k]
  ------------------
  639|      0|            oldentry = dict->table;
  640|  3.11k|    }
  641|       |
  642|  11.2k|    for (i = 0; i < oldsize; i++) {
  ------------------
  |  Branch (642:17): [True: 10.7k, False: 529]
  ------------------
  643|  10.7k|        if (oldentry->hashValue != 0) {
  ------------------
  |  Branch (643:13): [True: 9.38k, False: 1.34k]
  ------------------
  644|  9.38k|            xmlDictEntry *entry = &table[oldentry->hashValue & (size - 1)];
  645|       |
  646|  11.9k|            while (entry->hashValue != 0) {
  ------------------
  |  Branch (646:20): [True: 2.58k, False: 9.38k]
  ------------------
  647|  2.58k|                if (++entry >= end)
  ------------------
  |  Branch (647:21): [True: 58, False: 2.53k]
  ------------------
  648|     58|                    entry = table;
  649|  2.58k|            }
  650|  9.38k|            *entry = *oldentry;
  651|  9.38k|        }
  652|       |
  653|  10.7k|        if (++oldentry >= oldend)
  ------------------
  |  Branch (653:13): [True: 529, False: 10.1k]
  ------------------
  654|    529|            oldentry = dict->table;
  655|  10.7k|    }
  656|       |
  657|    529|    xmlFree(dict->table);
  658|       |
  659|    727|done:
  660|    727|    dict->table = table;
  661|    727|    dict->size = size;
  662|       |
  663|    727|    return(0);
  664|    529|}
dict.c:xmlDictAddString:
  136|  7.48k|xmlDictAddString(xmlDictPtr dict, const xmlChar *name, unsigned int namelen) {
  137|  7.48k|    xmlDictStringsPtr pool;
  138|  7.48k|    const xmlChar *ret;
  139|  7.48k|    size_t size = 0; /* + sizeof(_xmlDictStrings) == 1024 */
  140|  7.48k|    size_t limit = 0;
  141|       |
  142|  7.48k|    pool = dict->strings;
  143|  7.49k|    while (pool != NULL) {
  ------------------
  |  Branch (143:12): [True: 7.28k, False: 205]
  ------------------
  144|  7.28k|	if ((size_t)(pool->end - pool->free) > namelen)
  ------------------
  |  Branch (144:6): [True: 7.27k, False: 7]
  ------------------
  145|  7.27k|	    goto found_pool;
  146|      7|	if (pool->size > size) size = pool->size;
  ------------------
  |  Branch (146:6): [True: 7, False: 0]
  ------------------
  147|      7|        limit += pool->size;
  148|      7|	pool = pool->next;
  149|      7|    }
  150|       |    /*
  151|       |     * Not found, need to allocate
  152|       |     */
  153|    205|    if (pool == NULL) {
  ------------------
  |  Branch (153:9): [True: 205, False: 0]
  ------------------
  154|    205|        if ((dict->limit > 0) && (limit > dict->limit)) {
  ------------------
  |  Branch (154:13): [True: 0, False: 205]
  |  Branch (154:34): [True: 0, False: 0]
  ------------------
  155|      0|            return(NULL);
  156|      0|        }
  157|       |
  158|    205|        if (size == 0) {
  ------------------
  |  Branch (158:13): [True: 198, False: 7]
  ------------------
  159|    198|            size = 1000;
  160|    198|        } else {
  161|      7|            if (size < (SIZE_MAX - sizeof(xmlDictStrings)) / 4)
  ------------------
  |  |   35|      7|  #define SIZE_MAX ((size_t) -1)
  ------------------
  |  Branch (161:17): [True: 7, False: 0]
  ------------------
  162|      7|                size *= 4; /* exponential growth */
  163|      0|            else
  164|      0|                size = SIZE_MAX - sizeof(xmlDictStrings);
  ------------------
  |  |   35|      0|  #define SIZE_MAX ((size_t) -1)
  ------------------
  165|      7|        }
  166|    205|        if (size / 4 < namelen) {
  ------------------
  |  Branch (166:13): [True: 0, False: 205]
  ------------------
  167|      0|            if ((size_t) namelen + 0 < (SIZE_MAX - sizeof(xmlDictStrings)) / 4)
  ------------------
  |  |   35|      0|  #define SIZE_MAX ((size_t) -1)
  ------------------
  |  Branch (167:17): [True: 0, False: 0]
  ------------------
  168|      0|                size = 4 * (size_t) namelen; /* just in case ! */
  169|      0|            else
  170|      0|                return(NULL);
  171|      0|        }
  172|    205|	pool = (xmlDictStringsPtr) xmlMalloc(sizeof(xmlDictStrings) + size);
  173|    205|	if (pool == NULL)
  ------------------
  |  Branch (173:6): [True: 0, False: 205]
  ------------------
  174|      0|	    return(NULL);
  175|    205|	pool->size = size;
  176|    205|	pool->nbStrings = 0;
  177|    205|	pool->free = &pool->array[0];
  178|    205|	pool->end = &pool->array[size];
  179|    205|	pool->next = dict->strings;
  180|    205|	dict->strings = pool;
  181|    205|    }
  182|  7.48k|found_pool:
  183|  7.48k|    ret = pool->free;
  184|  7.48k|    memcpy(pool->free, name, namelen);
  185|  7.48k|    pool->free += namelen;
  186|  7.48k|    *(pool->free++) = 0;
  187|  7.48k|    pool->nbStrings++;
  188|  7.48k|    return(ret);
  189|    205|}
dict.c:xmlDictAddQString:
  206|      2|{
  207|      2|    xmlDictStringsPtr pool;
  208|      2|    const xmlChar *ret;
  209|      2|    size_t size = 0; /* + sizeof(_xmlDictStrings) == 1024 */
  210|      2|    size_t limit = 0;
  211|       |
  212|      2|    pool = dict->strings;
  213|      2|    while (pool != NULL) {
  ------------------
  |  Branch (213:12): [True: 2, False: 0]
  ------------------
  214|      2|	if ((size_t)(pool->end - pool->free) > namelen + plen + 1)
  ------------------
  |  Branch (214:6): [True: 2, False: 0]
  ------------------
  215|      2|	    goto found_pool;
  216|      0|	if (pool->size > size) size = pool->size;
  ------------------
  |  Branch (216:6): [True: 0, False: 0]
  ------------------
  217|      0|        limit += pool->size;
  218|      0|	pool = pool->next;
  219|      0|    }
  220|       |    /*
  221|       |     * Not found, need to allocate
  222|       |     */
  223|      0|    if (pool == NULL) {
  ------------------
  |  Branch (223:9): [True: 0, False: 0]
  ------------------
  224|      0|        if ((dict->limit > 0) && (limit > dict->limit)) {
  ------------------
  |  Branch (224:13): [True: 0, False: 0]
  |  Branch (224:34): [True: 0, False: 0]
  ------------------
  225|      0|            return(NULL);
  226|      0|        }
  227|       |
  228|      0|        if (size == 0) size = 1000;
  ------------------
  |  Branch (228:13): [True: 0, False: 0]
  ------------------
  229|      0|	else size *= 4; /* exponential growth */
  230|      0|        if (size < 4 * (namelen + plen + 1))
  ------------------
  |  Branch (230:13): [True: 0, False: 0]
  ------------------
  231|      0|	    size = 4 * (namelen + plen + 1); /* just in case ! */
  232|      0|	pool = (xmlDictStringsPtr) xmlMalloc(sizeof(xmlDictStrings) + size);
  233|      0|	if (pool == NULL)
  ------------------
  |  Branch (233:6): [True: 0, False: 0]
  ------------------
  234|      0|	    return(NULL);
  235|      0|	pool->size = size;
  236|      0|	pool->nbStrings = 0;
  237|      0|	pool->free = &pool->array[0];
  238|      0|	pool->end = &pool->array[size];
  239|      0|	pool->next = dict->strings;
  240|      0|	dict->strings = pool;
  241|      0|    }
  242|      2|found_pool:
  243|      2|    ret = pool->free;
  244|      2|    memcpy(pool->free, prefix, plen);
  245|      2|    pool->free += plen;
  246|      2|    *(pool->free++) = ':';
  247|      2|    memcpy(pool->free, name, namelen);
  248|      2|    pool->free += namelen;
  249|      2|    *(pool->free++) = 0;
  250|      2|    pool->nbStrings++;
  251|      2|    return(ret);
  252|      0|}
dict.c:xoroshiro64ss:
  938|  1.12k|xoroshiro64ss(unsigned *s) {
  939|  1.12k|    unsigned s0 = s[0];
  940|  1.12k|    unsigned s1 = s[1];
  941|  1.12k|    unsigned result = HASH_ROL(s0 * 0x9E3779BB, 5) * 5;
  ------------------
  |  |   12|  1.12k|#define HASH_ROL(x,n) ((x) << (n) | ((x) & 0xFFFFFFFF) >> (32 - (n)))
  ------------------
  942|       |
  943|  1.12k|    s1 ^= s0;
  944|  1.12k|    s[0] = HASH_ROL(s0, 26) ^ s1 ^ (s1 << 9);
  ------------------
  |  |   12|  1.12k|#define HASH_ROL(x,n) ((x) << (n) | ((x) & 0xFFFFFFFF) >> (32 - (n)))
  ------------------
  945|  1.12k|    s[1] = HASH_ROL(s1, 13);
  ------------------
  |  |   12|  1.12k|#define HASH_ROL(x,n) ((x) << (n) | ((x) & 0xFFFFFFFF) >> (32 - (n)))
  ------------------
  946|       |
  947|  1.12k|    return(result & 0xFFFFFFFF);
  948|  1.12k|}

isolat1ToUTF8:
  284|     59|              const unsigned char* in, int *inlen) {
  285|     59|    unsigned char* outstart = out;
  286|     59|    const unsigned char* base = in;
  287|     59|    unsigned char* outend;
  288|     59|    const unsigned char* inend;
  289|     59|    const unsigned char* instop;
  290|       |
  291|     59|    if ((out == NULL) || (in == NULL) || (outlen == NULL) || (inlen == NULL))
  ------------------
  |  Branch (291:9): [True: 0, False: 59]
  |  Branch (291:26): [True: 0, False: 59]
  |  Branch (291:42): [True: 0, False: 59]
  |  Branch (291:62): [True: 0, False: 59]
  ------------------
  292|      0|	return(XML_ENC_ERR_INTERNAL);
  293|       |
  294|     59|    outend = out + *outlen;
  295|     59|    inend = in + (*inlen);
  296|     59|    instop = inend;
  297|       |
  298|    198|    while ((in < inend) && (out < outend - 1)) {
  ------------------
  |  Branch (298:12): [True: 139, False: 59]
  |  Branch (298:28): [True: 139, False: 0]
  ------------------
  299|    139|	if (*in >= 0x80) {
  ------------------
  |  Branch (299:6): [True: 80, False: 59]
  ------------------
  300|     80|	    *out++ = (((*in) >>  6) & 0x1F) | 0xC0;
  301|     80|            *out++ = ((*in) & 0x3F) | 0x80;
  302|     80|	    ++in;
  303|     80|	}
  304|    139|	if ((instop - in) > (outend - out)) instop = in + (outend - out);
  ------------------
  |  Branch (304:6): [True: 0, False: 139]
  ------------------
  305|  68.7k|	while ((in < instop) && (*in < 0x80)) {
  ------------------
  |  Branch (305:9): [True: 68.6k, False: 59]
  |  Branch (305:26): [True: 68.6k, False: 80]
  ------------------
  306|  68.6k|	    *out++ = *in++;
  307|  68.6k|	}
  308|    139|    }
  309|     59|    if ((in < inend) && (out < outend) && (*in < 0x80)) {
  ------------------
  |  Branch (309:9): [True: 0, False: 59]
  |  Branch (309:25): [True: 0, False: 0]
  |  Branch (309:43): [True: 0, False: 0]
  ------------------
  310|      0|        *out++ = *in++;
  311|      0|    }
  312|     59|    *outlen = out - outstart;
  313|     59|    *inlen = in - base;
  314|     59|    return(*outlen);
  315|     59|}
xmlGetEncodingAlias:
 1003|    123|xmlGetEncodingAlias(const char *alias) {
 1004|    123|    int i;
 1005|    123|    char upper[100];
 1006|       |
 1007|    123|    if (alias == NULL)
  ------------------
  |  Branch (1007:9): [True: 0, False: 123]
  ------------------
 1008|      0|	return(NULL);
 1009|       |
 1010|    123|    if (xmlCharEncodingAliases == NULL)
  ------------------
  |  Branch (1010:9): [True: 123, False: 0]
  ------------------
 1011|    123|	return(NULL);
 1012|       |
 1013|      0|    for (i = 0;i < 99;i++) {
  ------------------
  |  Branch (1013:16): [True: 0, False: 0]
  ------------------
 1014|      0|        upper[i] = (char) toupper((unsigned char) alias[i]);
 1015|      0|	if (upper[i] == 0) break;
  ------------------
  |  Branch (1015:6): [True: 0, False: 0]
  ------------------
 1016|      0|    }
 1017|      0|    upper[i] = 0;
 1018|       |
 1019|       |    /*
 1020|       |     * Walk down the list looking for a definition of the alias
 1021|       |     */
 1022|      0|    for (i = 0;i < xmlCharEncodingAliasesNb;i++) {
  ------------------
  |  Branch (1022:16): [True: 0, False: 0]
  ------------------
 1023|      0|	if (!strcmp(xmlCharEncodingAliases[i].alias, upper)) {
  ------------------
  |  Branch (1023:6): [True: 0, False: 0]
  ------------------
 1024|      0|	    return(xmlCharEncodingAliases[i].name);
 1025|      0|	}
 1026|      0|    }
 1027|      0|    return(NULL);
 1028|      0|}
xmlInitEncodingInternal:
 1470|      2|xmlInitEncodingInternal(void) {
 1471|      2|    unsigned short int tst = 0x1234;
 1472|      2|    unsigned char *ptr = (unsigned char *) &tst;
 1473|       |
 1474|      2|    if (*ptr == 0x12) xmlLittleEndian = 0;
  ------------------
  |  Branch (1474:9): [True: 0, False: 2]
  ------------------
 1475|      2|    else xmlLittleEndian = 1;
 1476|      2|}
xmlGetCharEncodingHandler:
 1547|    238|xmlGetCharEncodingHandler(xmlCharEncoding enc) {
 1548|    238|    xmlCharEncodingHandlerPtr handler;
 1549|       |
 1550|    238|    switch (enc) {
 1551|      0|        case XML_CHAR_ENCODING_ERROR:
  ------------------
  |  Branch (1551:9): [True: 0, False: 238]
  ------------------
 1552|      0|	    return(NULL);
 1553|    238|        case XML_CHAR_ENCODING_NONE:
  ------------------
  |  Branch (1553:9): [True: 238, False: 0]
  ------------------
 1554|    238|	    return(NULL);
 1555|      0|        case XML_CHAR_ENCODING_UTF8:
  ------------------
  |  Branch (1555:9): [True: 0, False: 238]
  ------------------
 1556|      0|	    return(NULL);
 1557|      0|        case XML_CHAR_ENCODING_UTF16LE:
  ------------------
  |  Branch (1557:9): [True: 0, False: 238]
  ------------------
 1558|      0|	    return((xmlCharEncodingHandlerPtr) xmlUTF16LEHandler);
 1559|      0|        case XML_CHAR_ENCODING_UTF16BE:
  ------------------
  |  Branch (1559:9): [True: 0, False: 238]
  ------------------
 1560|      0|	    return((xmlCharEncodingHandlerPtr) xmlUTF16BEHandler);
 1561|      0|        case XML_CHAR_ENCODING_EBCDIC:
  ------------------
  |  Branch (1561:9): [True: 0, False: 238]
  ------------------
 1562|      0|            handler = xmlFindCharEncodingHandler("EBCDIC");
 1563|      0|            if (handler != NULL) return(handler);
  ------------------
  |  Branch (1563:17): [True: 0, False: 0]
  ------------------
 1564|      0|            handler = xmlFindCharEncodingHandler("ebcdic");
 1565|      0|            if (handler != NULL) return(handler);
  ------------------
  |  Branch (1565:17): [True: 0, False: 0]
  ------------------
 1566|      0|            handler = xmlFindCharEncodingHandler("EBCDIC-US");
 1567|      0|            if (handler != NULL) return(handler);
  ------------------
  |  Branch (1567:17): [True: 0, False: 0]
  ------------------
 1568|      0|            handler = xmlFindCharEncodingHandler("IBM-037");
 1569|      0|            if (handler != NULL) return(handler);
  ------------------
  |  Branch (1569:17): [True: 0, False: 0]
  ------------------
 1570|      0|	    break;
 1571|      0|        case XML_CHAR_ENCODING_UCS4BE:
  ------------------
  |  Branch (1571:9): [True: 0, False: 238]
  ------------------
 1572|      0|            handler = xmlFindCharEncodingHandler("ISO-10646-UCS-4");
 1573|      0|            if (handler != NULL) return(handler);
  ------------------
  |  Branch (1573:17): [True: 0, False: 0]
  ------------------
 1574|      0|            handler = xmlFindCharEncodingHandler("UCS-4");
 1575|      0|            if (handler != NULL) return(handler);
  ------------------
  |  Branch (1575:17): [True: 0, False: 0]
  ------------------
 1576|      0|            handler = xmlFindCharEncodingHandler("UCS4");
 1577|      0|            if (handler != NULL) return(handler);
  ------------------
  |  Branch (1577:17): [True: 0, False: 0]
  ------------------
 1578|      0|	    break;
 1579|      0|        case XML_CHAR_ENCODING_UCS4LE:
  ------------------
  |  Branch (1579:9): [True: 0, False: 238]
  ------------------
 1580|      0|            handler = xmlFindCharEncodingHandler("ISO-10646-UCS-4");
 1581|      0|            if (handler != NULL) return(handler);
  ------------------
  |  Branch (1581:17): [True: 0, False: 0]
  ------------------
 1582|      0|            handler = xmlFindCharEncodingHandler("UCS-4");
 1583|      0|            if (handler != NULL) return(handler);
  ------------------
  |  Branch (1583:17): [True: 0, False: 0]
  ------------------
 1584|      0|            handler = xmlFindCharEncodingHandler("UCS4");
 1585|      0|            if (handler != NULL) return(handler);
  ------------------
  |  Branch (1585:17): [True: 0, False: 0]
  ------------------
 1586|      0|	    break;
 1587|      0|        case XML_CHAR_ENCODING_UCS4_2143:
  ------------------
  |  Branch (1587:9): [True: 0, False: 238]
  ------------------
 1588|      0|	    break;
 1589|      0|        case XML_CHAR_ENCODING_UCS4_3412:
  ------------------
  |  Branch (1589:9): [True: 0, False: 238]
  ------------------
 1590|      0|	    break;
 1591|      0|        case XML_CHAR_ENCODING_UCS2:
  ------------------
  |  Branch (1591:9): [True: 0, False: 238]
  ------------------
 1592|      0|            handler = xmlFindCharEncodingHandler("ISO-10646-UCS-2");
 1593|      0|            if (handler != NULL) return(handler);
  ------------------
  |  Branch (1593:17): [True: 0, False: 0]
  ------------------
 1594|      0|            handler = xmlFindCharEncodingHandler("UCS-2");
 1595|      0|            if (handler != NULL) return(handler);
  ------------------
  |  Branch (1595:17): [True: 0, False: 0]
  ------------------
 1596|      0|            handler = xmlFindCharEncodingHandler("UCS2");
 1597|      0|            if (handler != NULL) return(handler);
  ------------------
  |  Branch (1597:17): [True: 0, False: 0]
  ------------------
 1598|      0|	    break;
 1599|       |
 1600|       |	    /*
 1601|       |	     * We used to keep ISO Latin encodings native in the
 1602|       |	     * generated data. This led to so many problems that
 1603|       |	     * this has been removed. One can still change this
 1604|       |	     * back by registering no-ops encoders for those
 1605|       |	     */
 1606|      0|        case XML_CHAR_ENCODING_8859_1:
  ------------------
  |  Branch (1606:9): [True: 0, False: 238]
  ------------------
 1607|      0|	    handler = xmlFindCharEncodingHandler("ISO-8859-1");
 1608|      0|	    if (handler != NULL) return(handler);
  ------------------
  |  Branch (1608:10): [True: 0, False: 0]
  ------------------
 1609|      0|	    break;
 1610|      0|        case XML_CHAR_ENCODING_8859_2:
  ------------------
  |  Branch (1610:9): [True: 0, False: 238]
  ------------------
 1611|      0|	    handler = xmlFindCharEncodingHandler("ISO-8859-2");
 1612|      0|	    if (handler != NULL) return(handler);
  ------------------
  |  Branch (1612:10): [True: 0, False: 0]
  ------------------
 1613|      0|	    break;
 1614|      0|        case XML_CHAR_ENCODING_8859_3:
  ------------------
  |  Branch (1614:9): [True: 0, False: 238]
  ------------------
 1615|      0|	    handler = xmlFindCharEncodingHandler("ISO-8859-3");
 1616|      0|	    if (handler != NULL) return(handler);
  ------------------
  |  Branch (1616:10): [True: 0, False: 0]
  ------------------
 1617|      0|	    break;
 1618|      0|        case XML_CHAR_ENCODING_8859_4:
  ------------------
  |  Branch (1618:9): [True: 0, False: 238]
  ------------------
 1619|      0|	    handler = xmlFindCharEncodingHandler("ISO-8859-4");
 1620|      0|	    if (handler != NULL) return(handler);
  ------------------
  |  Branch (1620:10): [True: 0, False: 0]
  ------------------
 1621|      0|	    break;
 1622|      0|        case XML_CHAR_ENCODING_8859_5:
  ------------------
  |  Branch (1622:9): [True: 0, False: 238]
  ------------------
 1623|      0|	    handler = xmlFindCharEncodingHandler("ISO-8859-5");
 1624|      0|	    if (handler != NULL) return(handler);
  ------------------
  |  Branch (1624:10): [True: 0, False: 0]
  ------------------
 1625|      0|	    break;
 1626|      0|        case XML_CHAR_ENCODING_8859_6:
  ------------------
  |  Branch (1626:9): [True: 0, False: 238]
  ------------------
 1627|      0|	    handler = xmlFindCharEncodingHandler("ISO-8859-6");
 1628|      0|	    if (handler != NULL) return(handler);
  ------------------
  |  Branch (1628:10): [True: 0, False: 0]
  ------------------
 1629|      0|	    break;
 1630|      0|        case XML_CHAR_ENCODING_8859_7:
  ------------------
  |  Branch (1630:9): [True: 0, False: 238]
  ------------------
 1631|      0|	    handler = xmlFindCharEncodingHandler("ISO-8859-7");
 1632|      0|	    if (handler != NULL) return(handler);
  ------------------
  |  Branch (1632:10): [True: 0, False: 0]
  ------------------
 1633|      0|	    break;
 1634|      0|        case XML_CHAR_ENCODING_8859_8:
  ------------------
  |  Branch (1634:9): [True: 0, False: 238]
  ------------------
 1635|      0|	    handler = xmlFindCharEncodingHandler("ISO-8859-8");
 1636|      0|	    if (handler != NULL) return(handler);
  ------------------
  |  Branch (1636:10): [True: 0, False: 0]
  ------------------
 1637|      0|	    break;
 1638|      0|        case XML_CHAR_ENCODING_8859_9:
  ------------------
  |  Branch (1638:9): [True: 0, False: 238]
  ------------------
 1639|      0|	    handler = xmlFindCharEncodingHandler("ISO-8859-9");
 1640|      0|	    if (handler != NULL) return(handler);
  ------------------
  |  Branch (1640:10): [True: 0, False: 0]
  ------------------
 1641|      0|	    break;
 1642|       |
 1643|       |
 1644|      0|        case XML_CHAR_ENCODING_2022_JP:
  ------------------
  |  Branch (1644:9): [True: 0, False: 238]
  ------------------
 1645|      0|            handler = xmlFindCharEncodingHandler("ISO-2022-JP");
 1646|      0|            if (handler != NULL) return(handler);
  ------------------
  |  Branch (1646:17): [True: 0, False: 0]
  ------------------
 1647|      0|	    break;
 1648|      0|        case XML_CHAR_ENCODING_SHIFT_JIS:
  ------------------
  |  Branch (1648:9): [True: 0, False: 238]
  ------------------
 1649|      0|            handler = xmlFindCharEncodingHandler("SHIFT-JIS");
 1650|      0|            if (handler != NULL) return(handler);
  ------------------
  |  Branch (1650:17): [True: 0, False: 0]
  ------------------
 1651|      0|            handler = xmlFindCharEncodingHandler("SHIFT_JIS");
 1652|      0|            if (handler != NULL) return(handler);
  ------------------
  |  Branch (1652:17): [True: 0, False: 0]
  ------------------
 1653|      0|            handler = xmlFindCharEncodingHandler("Shift_JIS");
 1654|      0|            if (handler != NULL) return(handler);
  ------------------
  |  Branch (1654:17): [True: 0, False: 0]
  ------------------
 1655|      0|	    break;
 1656|      0|        case XML_CHAR_ENCODING_EUC_JP:
  ------------------
  |  Branch (1656:9): [True: 0, False: 238]
  ------------------
 1657|      0|            handler = xmlFindCharEncodingHandler("EUC-JP");
 1658|      0|            if (handler != NULL) return(handler);
  ------------------
  |  Branch (1658:17): [True: 0, False: 0]
  ------------------
 1659|      0|	    break;
 1660|      0|	default:
  ------------------
  |  Branch (1660:2): [True: 0, False: 238]
  ------------------
 1661|      0|	    break;
 1662|    238|    }
 1663|       |
 1664|      0|    return(NULL);
 1665|    238|}
xmlFindCharEncodingHandler:
 1677|    123|xmlFindCharEncodingHandler(const char *name) {
 1678|    123|    const char *nalias;
 1679|    123|    const char *norig;
 1680|    123|    xmlCharEncoding alias;
 1681|    123|#ifdef LIBXML_ICONV_ENABLED
 1682|    123|    xmlCharEncodingHandlerPtr enc;
 1683|    123|    iconv_t icv_in, icv_out;
 1684|    123|#endif /* LIBXML_ICONV_ENABLED */
 1685|       |#ifdef LIBXML_ICU_ENABLED
 1686|       |    xmlCharEncodingHandlerPtr encu;
 1687|       |    uconv_t *ucv_in, *ucv_out;
 1688|       |#endif /* LIBXML_ICU_ENABLED */
 1689|    123|    char upper[100];
 1690|    123|    int i;
 1691|       |
 1692|    123|    if (name == NULL) return(NULL);
  ------------------
  |  Branch (1692:9): [True: 0, False: 123]
  ------------------
 1693|    123|    if (name[0] == 0) return(NULL);
  ------------------
  |  Branch (1693:9): [True: 0, False: 123]
  ------------------
 1694|       |
 1695|       |    /*
 1696|       |     * Do the alias resolution
 1697|       |     */
 1698|    123|    norig = name;
 1699|    123|    nalias = xmlGetEncodingAlias(name);
 1700|    123|    if (nalias != NULL)
  ------------------
  |  Branch (1700:9): [True: 0, False: 123]
  ------------------
 1701|      0|	name = nalias;
 1702|       |
 1703|       |    /*
 1704|       |     * Check first for directly registered encoding names
 1705|       |     */
 1706|    998|    for (i = 0;i < 99;i++) {
  ------------------
  |  Branch (1706:16): [True: 998, False: 0]
  ------------------
 1707|    998|        upper[i] = (char) toupper((unsigned char) name[i]);
 1708|    998|	if (upper[i] == 0) break;
  ------------------
  |  Branch (1708:6): [True: 123, False: 875]
  ------------------
 1709|    998|    }
 1710|    123|    upper[i] = 0;
 1711|       |
 1712|    331|    for (i = 0; i < (int) NUM_DEFAULT_HANDLERS; i++) {
  ------------------
  |  | 1373|    331|    (sizeof(defaultHandlers) / sizeof(defaultHandlers[0]))
  ------------------
  |  Branch (1712:17): [True: 331, False: 0]
  ------------------
 1713|    331|        if (strcmp(upper, defaultHandlers[i].name) == 0)
  ------------------
  |  Branch (1713:13): [True: 123, False: 208]
  ------------------
 1714|    123|            return((xmlCharEncodingHandlerPtr) &defaultHandlers[i]);
 1715|    331|    }
 1716|       |
 1717|      0|    if (handlers != NULL) {
  ------------------
  |  Branch (1717:9): [True: 0, False: 0]
  ------------------
 1718|      0|        for (i = 0;i < nbCharEncodingHandler; i++) {
  ------------------
  |  Branch (1718:20): [True: 0, False: 0]
  ------------------
 1719|      0|            if (!strcmp(upper, handlers[i]->name)) {
  ------------------
  |  Branch (1719:17): [True: 0, False: 0]
  ------------------
 1720|      0|                return(handlers[i]);
 1721|      0|            }
 1722|      0|        }
 1723|      0|    }
 1724|       |
 1725|      0|#ifdef LIBXML_ICONV_ENABLED
 1726|       |    /* check whether iconv can handle this */
 1727|      0|    icv_in = iconv_open("UTF-8", name);
 1728|      0|    icv_out = iconv_open(name, "UTF-8");
 1729|      0|    if (icv_in == (iconv_t) -1) {
  ------------------
  |  Branch (1729:9): [True: 0, False: 0]
  ------------------
 1730|      0|        icv_in = iconv_open("UTF-8", upper);
 1731|      0|    }
 1732|      0|    if (icv_out == (iconv_t) -1) {
  ------------------
  |  Branch (1732:9): [True: 0, False: 0]
  ------------------
 1733|      0|	icv_out = iconv_open(upper, "UTF-8");
 1734|      0|    }
 1735|      0|    if ((icv_in != (iconv_t) -1) && (icv_out != (iconv_t) -1)) {
  ------------------
  |  Branch (1735:9): [True: 0, False: 0]
  |  Branch (1735:37): [True: 0, False: 0]
  ------------------
 1736|      0|	    enc = (xmlCharEncodingHandlerPtr)
 1737|      0|	          xmlMalloc(sizeof(xmlCharEncodingHandler));
 1738|      0|	    if (enc == NULL) {
  ------------------
  |  Branch (1738:10): [True: 0, False: 0]
  ------------------
 1739|      0|	        iconv_close(icv_in);
 1740|      0|	        iconv_close(icv_out);
 1741|      0|		return(NULL);
 1742|      0|	    }
 1743|      0|            memset(enc, 0, sizeof(xmlCharEncodingHandler));
 1744|      0|	    enc->name = xmlMemStrdup(name);
 1745|      0|            if (enc->name == NULL) {
  ------------------
  |  Branch (1745:17): [True: 0, False: 0]
  ------------------
 1746|      0|                xmlFree(enc);
 1747|      0|                iconv_close(icv_in);
 1748|      0|                iconv_close(icv_out);
 1749|      0|                return(NULL);
 1750|      0|            }
 1751|      0|	    enc->input = NULL;
 1752|      0|	    enc->output = NULL;
 1753|      0|	    enc->iconv_in = icv_in;
 1754|      0|	    enc->iconv_out = icv_out;
 1755|      0|	    return enc;
 1756|      0|    } else if ((icv_in != (iconv_t) -1) || icv_out != (iconv_t) -1) {
  ------------------
  |  Branch (1756:16): [True: 0, False: 0]
  |  Branch (1756:44): [True: 0, False: 0]
  ------------------
 1757|      0|	    if (icv_in != (iconv_t) -1)
  ------------------
  |  Branch (1757:10): [True: 0, False: 0]
  ------------------
 1758|      0|		iconv_close(icv_in);
 1759|      0|	    else
 1760|      0|		iconv_close(icv_out);
 1761|      0|    }
 1762|      0|#endif /* LIBXML_ICONV_ENABLED */
 1763|       |#ifdef LIBXML_ICU_ENABLED
 1764|       |    /* check whether icu can handle this */
 1765|       |    ucv_in = openIcuConverter(name, 1);
 1766|       |    ucv_out = openIcuConverter(name, 0);
 1767|       |    if (ucv_in != NULL && ucv_out != NULL) {
 1768|       |	    encu = (xmlCharEncodingHandlerPtr)
 1769|       |	           xmlMalloc(sizeof(xmlCharEncodingHandler));
 1770|       |	    if (encu == NULL) {
 1771|       |                closeIcuConverter(ucv_in);
 1772|       |                closeIcuConverter(ucv_out);
 1773|       |		return(NULL);
 1774|       |	    }
 1775|       |            memset(encu, 0, sizeof(xmlCharEncodingHandler));
 1776|       |	    encu->name = xmlMemStrdup(name);
 1777|       |            if (encu->name == NULL) {
 1778|       |                xmlFree(encu);
 1779|       |                closeIcuConverter(ucv_in);
 1780|       |                closeIcuConverter(ucv_out);
 1781|       |                return(NULL);
 1782|       |            }
 1783|       |	    encu->input = NULL;
 1784|       |	    encu->output = NULL;
 1785|       |	    encu->uconv_in = ucv_in;
 1786|       |	    encu->uconv_out = ucv_out;
 1787|       |	    return encu;
 1788|       |    } else if (ucv_in != NULL || ucv_out != NULL) {
 1789|       |            closeIcuConverter(ucv_in);
 1790|       |            closeIcuConverter(ucv_out);
 1791|       |    }
 1792|       |#endif /* LIBXML_ICU_ENABLED */
 1793|       |
 1794|       |    /*
 1795|       |     * Fallback using the canonical names
 1796|       |     */
 1797|      0|    alias = xmlParseCharEncoding(norig);
 1798|      0|    if (alias != XML_CHAR_ENCODING_ERROR) {
  ------------------
  |  Branch (1798:9): [True: 0, False: 0]
  ------------------
 1799|      0|        const char* canon;
 1800|      0|        canon = xmlGetCharEncodingName(alias);
 1801|      0|        if ((canon != NULL) && (strcmp(name, canon))) {
  ------------------
  |  Branch (1801:13): [True: 0, False: 0]
  |  Branch (1801:32): [True: 0, False: 0]
  ------------------
 1802|      0|	    return(xmlFindCharEncodingHandler(canon));
 1803|      0|        }
 1804|      0|    }
 1805|       |
 1806|       |    /* If "none of the above", give up */
 1807|      0|    return(NULL);
 1808|      0|}
xmlEncInputChunk:
 1988|     59|                 int *outlen, const unsigned char *in, int *inlen) {
 1989|     59|    int ret;
 1990|       |
 1991|     59|    if (handler->input != NULL) {
  ------------------
  |  Branch (1991:9): [True: 59, False: 0]
  ------------------
 1992|     59|        int oldinlen = *inlen;
 1993|       |
 1994|     59|        ret = handler->input(out, outlen, in, inlen);
 1995|     59|        if (ret >= 0) {
  ------------------
  |  Branch (1995:13): [True: 59, False: 0]
  ------------------
 1996|       |            /*
 1997|       |             * The built-in converters don't signal XML_ENC_ERR_SPACE.
 1998|       |             */
 1999|     59|            if (*inlen < oldinlen) {
  ------------------
  |  Branch (1999:17): [True: 0, False: 59]
  ------------------
 2000|      0|                if (*outlen > 0)
  ------------------
  |  Branch (2000:21): [True: 0, False: 0]
  ------------------
 2001|      0|                    ret = XML_ENC_ERR_SPACE;
 2002|      0|                else
 2003|      0|                    ret = XML_ENC_ERR_PARTIAL;
 2004|     59|            } else {
 2005|     59|                ret = XML_ENC_ERR_SUCCESS;
 2006|     59|            }
 2007|     59|        }
 2008|     59|    }
 2009|      0|#ifdef LIBXML_ICONV_ENABLED
 2010|      0|    else if (handler->iconv_in != NULL) {
  ------------------
  |  Branch (2010:14): [True: 0, False: 0]
  ------------------
 2011|      0|        ret = xmlIconvWrapper(handler->iconv_in, out, outlen, in, inlen);
 2012|      0|    }
 2013|      0|#endif /* LIBXML_ICONV_ENABLED */
 2014|       |#ifdef LIBXML_ICU_ENABLED
 2015|       |    else if (handler->uconv_in != NULL) {
 2016|       |        ret = xmlUconvWrapper(handler->uconv_in, 1, out, outlen, in, inlen);
 2017|       |    }
 2018|       |#endif /* LIBXML_ICU_ENABLED */
 2019|      0|    else {
 2020|      0|        *outlen = 0;
 2021|      0|        *inlen = 0;
 2022|      0|        ret = XML_ENC_ERR_INTERNAL;
 2023|      0|    }
 2024|       |
 2025|       |    /* Ignore partial errors when reading. */
 2026|     59|    if (ret == XML_ENC_ERR_PARTIAL)
  ------------------
  |  Branch (2026:9): [True: 0, False: 59]
  ------------------
 2027|      0|        ret = XML_ENC_ERR_SUCCESS;
 2028|       |
 2029|     59|    return(ret);
 2030|     59|}
xmlCharEncInput:
 2118|  3.67k|{
 2119|  3.67k|    int ret;
 2120|  3.67k|    size_t avail;
 2121|  3.67k|    size_t toconv;
 2122|  3.67k|    int c_in;
 2123|  3.67k|    int c_out;
 2124|  3.67k|    xmlBufPtr in;
 2125|  3.67k|    xmlBufPtr out;
 2126|  3.67k|    const xmlChar *inData;
 2127|  3.67k|    size_t inTotal = 0;
 2128|       |
 2129|  3.67k|    if ((input == NULL) || (input->encoder == NULL) ||
  ------------------
  |  Branch (2129:9): [True: 0, False: 3.67k]
  |  Branch (2129:28): [True: 0, False: 3.67k]
  ------------------
 2130|  3.67k|        (input->buffer == NULL) || (input->raw == NULL))
  ------------------
  |  Branch (2130:9): [True: 0, False: 3.67k]
  |  Branch (2130:36): [True: 0, False: 3.67k]
  ------------------
 2131|      0|        return(XML_ENC_ERR_INTERNAL);
 2132|  3.67k|    out = input->buffer;
 2133|  3.67k|    in = input->raw;
 2134|       |
 2135|  3.67k|    toconv = xmlBufUse(in);
 2136|  3.67k|    if (toconv == 0)
  ------------------
  |  Branch (2136:9): [True: 3.61k, False: 59]
  ------------------
 2137|  3.61k|        return (0);
 2138|     59|    inData = xmlBufContent(in);
 2139|     59|    inTotal = 0;
 2140|       |
 2141|     59|    do {
 2142|     59|        c_in = toconv > INT_MAX / 2 ? INT_MAX / 2 : toconv;
  ------------------
  |  Branch (2142:16): [True: 0, False: 59]
  ------------------
 2143|       |
 2144|     59|        avail = xmlBufAvail(out);
 2145|     59|        if (avail > INT_MAX)
  ------------------
  |  Branch (2145:13): [True: 0, False: 59]
  ------------------
 2146|      0|            avail = INT_MAX;
 2147|     59|        if (avail < 4096) {
  ------------------
  |  Branch (2147:13): [True: 57, False: 2]
  ------------------
 2148|     57|            if (xmlBufGrow(out, 4096) < 0) {
  ------------------
  |  Branch (2148:17): [True: 0, False: 57]
  ------------------
 2149|      0|                input->error = XML_ERR_NO_MEMORY;
 2150|      0|                return(XML_ENC_ERR_MEMORY);
 2151|      0|            }
 2152|     57|            avail = xmlBufAvail(out);
 2153|     57|        }
 2154|       |
 2155|     59|        c_in = toconv;
 2156|     59|        c_out = avail;
 2157|     59|        ret = xmlEncInputChunk(input->encoder, xmlBufEnd(out), &c_out,
 2158|     59|                               inData, &c_in);
 2159|     59|        inTotal += c_in;
 2160|     59|        inData += c_in;
 2161|     59|        toconv -= c_in;
 2162|     59|        xmlBufAddLen(out, c_out);
 2163|     59|    } while (ret == XML_ENC_ERR_SPACE);
  ------------------
  |  Branch (2163:14): [True: 0, False: 59]
  ------------------
 2164|       |
 2165|     59|    xmlBufShrink(in, inTotal);
 2166|       |
 2167|     59|    if (input->rawconsumed > ULONG_MAX - (unsigned long)c_in)
  ------------------
  |  Branch (2167:9): [True: 0, False: 59]
  ------------------
 2168|      0|        input->rawconsumed = ULONG_MAX;
 2169|     59|    else
 2170|     59|        input->rawconsumed += c_in;
 2171|       |
 2172|     59|    if ((c_out == 0) && (ret != 0)) {
  ------------------
  |  Branch (2172:9): [True: 0, False: 59]
  |  Branch (2172:25): [True: 0, False: 0]
  ------------------
 2173|      0|        if (input->error == 0)
  ------------------
  |  Branch (2173:13): [True: 0, False: 0]
  ------------------
 2174|      0|            input->error = xmlEncConvertError(ret);
 2175|      0|        return(ret);
 2176|      0|    }
 2177|       |
 2178|     59|    return (c_out);
 2179|     59|}
xmlCharEncCloseFunc:
 2454|    123|xmlCharEncCloseFunc(xmlCharEncodingHandler *handler) {
 2455|    123|    int ret = 0;
 2456|    123|    int tofree = 0;
 2457|    123|    int i = 0;
 2458|       |
 2459|    123|    if (handler == NULL) return(-1);
  ------------------
  |  Branch (2459:9): [True: 0, False: 123]
  ------------------
 2460|       |
 2461|    331|    for (i = 0; i < (int) NUM_DEFAULT_HANDLERS; i++) {
  ------------------
  |  | 1373|    331|    (sizeof(defaultHandlers) / sizeof(defaultHandlers[0]))
  ------------------
  |  Branch (2461:17): [True: 331, False: 0]
  ------------------
 2462|    331|        if (handler == &defaultHandlers[i])
  ------------------
  |  Branch (2462:13): [True: 123, False: 208]
  ------------------
 2463|    123|            return(0);
 2464|    331|    }
 2465|       |
 2466|      0|    if (handlers != NULL) {
  ------------------
  |  Branch (2466:9): [True: 0, False: 0]
  ------------------
 2467|      0|        for (i = 0;i < nbCharEncodingHandler; i++) {
  ------------------
  |  Branch (2467:20): [True: 0, False: 0]
  ------------------
 2468|      0|            if (handler == handlers[i])
  ------------------
  |  Branch (2468:17): [True: 0, False: 0]
  ------------------
 2469|      0|                return(0);
 2470|      0|	}
 2471|      0|    }
 2472|      0|#ifdef LIBXML_ICONV_ENABLED
 2473|       |    /*
 2474|       |     * Iconv handlers can be used only once, free the whole block.
 2475|       |     * and the associated icon resources.
 2476|       |     */
 2477|      0|    if ((handler->iconv_out != NULL) || (handler->iconv_in != NULL)) {
  ------------------
  |  Branch (2477:9): [True: 0, False: 0]
  |  Branch (2477:41): [True: 0, False: 0]
  ------------------
 2478|      0|        tofree = 1;
 2479|      0|	if (handler->iconv_out != NULL) {
  ------------------
  |  Branch (2479:6): [True: 0, False: 0]
  ------------------
 2480|      0|	    if (iconv_close(handler->iconv_out))
  ------------------
  |  Branch (2480:10): [True: 0, False: 0]
  ------------------
 2481|      0|		ret = -1;
 2482|      0|	    handler->iconv_out = NULL;
 2483|      0|	}
 2484|      0|	if (handler->iconv_in != NULL) {
  ------------------
  |  Branch (2484:6): [True: 0, False: 0]
  ------------------
 2485|      0|	    if (iconv_close(handler->iconv_in))
  ------------------
  |  Branch (2485:10): [True: 0, False: 0]
  ------------------
 2486|      0|		ret = -1;
 2487|      0|	    handler->iconv_in = NULL;
 2488|      0|	}
 2489|      0|    }
 2490|      0|#endif /* LIBXML_ICONV_ENABLED */
 2491|       |#ifdef LIBXML_ICU_ENABLED
 2492|       |    if ((handler->uconv_out != NULL) || (handler->uconv_in != NULL)) {
 2493|       |        tofree = 1;
 2494|       |	if (handler->uconv_out != NULL) {
 2495|       |	    closeIcuConverter(handler->uconv_out);
 2496|       |	    handler->uconv_out = NULL;
 2497|       |	}
 2498|       |	if (handler->uconv_in != NULL) {
 2499|       |	    closeIcuConverter(handler->uconv_in);
 2500|       |	    handler->uconv_in = NULL;
 2501|       |	}
 2502|       |    }
 2503|       |#endif
 2504|      0|    if (tofree) {
  ------------------
  |  Branch (2504:9): [True: 0, False: 0]
  ------------------
 2505|       |        /* free up only dynamic handlers iconv/uconv */
 2506|      0|        if (handler->name != NULL)
  ------------------
  |  Branch (2506:13): [True: 0, False: 0]
  ------------------
 2507|      0|            xmlFree(handler->name);
 2508|      0|        handler->name = NULL;
 2509|      0|        xmlFree(handler);
 2510|      0|    }
 2511|       |
 2512|      0|    return(ret);
 2513|      0|}

xmlGetPredefinedEntity:
  295|     10|xmlGetPredefinedEntity(const xmlChar *name) {
  296|     10|    if (name == NULL) return(NULL);
  ------------------
  |  Branch (296:9): [True: 0, False: 10]
  ------------------
  297|     10|    switch (name[0]) {
  298|      8|        case 'l':
  ------------------
  |  Branch (298:9): [True: 8, False: 2]
  ------------------
  299|      8|	    if (xmlStrEqual(name, BAD_CAST "lt"))
  ------------------
  |  |   35|      8|#define BAD_CAST (xmlChar *)
  ------------------
  |  Branch (299:10): [True: 8, False: 0]
  ------------------
  300|      8|	        return(&xmlEntityLt);
  301|      0|	    break;
  302|      0|        case 'g':
  ------------------
  |  Branch (302:9): [True: 0, False: 10]
  ------------------
  303|      0|	    if (xmlStrEqual(name, BAD_CAST "gt"))
  ------------------
  |  |   35|      0|#define BAD_CAST (xmlChar *)
  ------------------
  |  Branch (303:10): [True: 0, False: 0]
  ------------------
  304|      0|	        return(&xmlEntityGt);
  305|      0|	    break;
  306|      2|        case 'a':
  ------------------
  |  Branch (306:9): [True: 2, False: 8]
  ------------------
  307|      2|	    if (xmlStrEqual(name, BAD_CAST "amp"))
  ------------------
  |  |   35|      2|#define BAD_CAST (xmlChar *)
  ------------------
  |  Branch (307:10): [True: 2, False: 0]
  ------------------
  308|      2|	        return(&xmlEntityAmp);
  309|      0|	    if (xmlStrEqual(name, BAD_CAST "apos"))
  ------------------
  |  |   35|      0|#define BAD_CAST (xmlChar *)
  ------------------
  |  Branch (309:10): [True: 0, False: 0]
  ------------------
  310|      0|	        return(&xmlEntityApos);
  311|      0|	    break;
  312|      0|        case 'q':
  ------------------
  |  Branch (312:9): [True: 0, False: 10]
  ------------------
  313|      0|	    if (xmlStrEqual(name, BAD_CAST "quot"))
  ------------------
  |  |   35|      0|#define BAD_CAST (xmlChar *)
  ------------------
  |  Branch (313:10): [True: 0, False: 0]
  ------------------
  314|      0|	        return(&xmlEntityQuot);
  315|      0|	    break;
  316|      0|	default:
  ------------------
  |  Branch (316:2): [True: 0, False: 10]
  ------------------
  317|      0|	    break;
  318|     10|    }
  319|      0|    return(NULL);
  320|     10|}

xmlSetGenericErrorFunc:
  114|      2|xmlSetGenericErrorFunc(void *ctx, xmlGenericErrorFunc handler) {
  115|      2|    xmlGenericErrorContext = ctx;
  ------------------
  |  |  876|      2|  #define xmlGenericErrorContext XML_GLOBAL_MACRO(xmlGenericErrorContext)
  |  |  ------------------
  |  |  |  |  500|      2|  #define XML_GLOBAL_MACRO(name) (*__##name())
  |  |  ------------------
  ------------------
  116|      2|    if (handler != NULL)
  ------------------
  |  Branch (116:9): [True: 2, False: 0]
  ------------------
  117|      2|	xmlGenericError = handler;
  ------------------
  |  |  875|      2|  #define xmlGenericError XML_GLOBAL_MACRO(xmlGenericError)
  |  |  ------------------
  |  |  |  |  500|      2|  #define XML_GLOBAL_MACRO(name) (*__##name())
  |  |  ------------------
  ------------------
  118|      0|    else
  119|      0|	xmlGenericError = xmlGenericErrorDefaultFunc;
  ------------------
  |  |  875|      0|  #define xmlGenericError XML_GLOBAL_MACRO(xmlGenericError)
  |  |  ------------------
  |  |  |  |  500|      0|  #define XML_GLOBAL_MACRO(name) (*__##name())
  |  |  ------------------
  ------------------
  120|      2|}
__xmlRaiseError:
  475|    244|{
  476|    244|    xmlParserCtxtPtr ctxt = NULL;
  477|    244|    xmlNodePtr node = (xmlNodePtr) nod;
  478|    244|    char *str = NULL;
  479|    244|    xmlParserInputPtr input = NULL;
  480|    244|    xmlErrorPtr to = &xmlLastError;
  ------------------
  |  |  874|    244|  #define xmlLastError XML_GLOBAL_MACRO(xmlLastError)
  |  |  ------------------
  |  |  |  |  500|    244|  #define XML_GLOBAL_MACRO(name) (*__##name())
  |  |  ------------------
  ------------------
  481|    244|    xmlNodePtr baseptr = NULL;
  482|       |
  483|    244|    if (code == XML_ERR_OK)
  ------------------
  |  Branch (483:9): [True: 0, False: 244]
  ------------------
  484|      0|        return;
  485|    244|    if ((xmlGetWarningsDefaultValue == 0) && (level == XML_ERR_WARNING))
  ------------------
  |  |  865|    244|    XML_GLOBAL_MACRO(xmlGetWarningsDefaultValue)
  |  |  ------------------
  |  |  |  |  500|    244|  #define XML_GLOBAL_MACRO(name) (*__##name())
  |  |  ------------------
  ------------------
  |  Branch (485:9): [True: 0, False: 244]
  |  Branch (485:46): [True: 0, False: 0]
  ------------------
  486|      0|        return;
  487|    244|    if ((domain == XML_FROM_PARSER) || (domain == XML_FROM_HTML) ||
  ------------------
  |  Branch (487:9): [True: 115, False: 129]
  |  Branch (487:40): [True: 0, False: 129]
  ------------------
  488|    244|        (domain == XML_FROM_DTD) || (domain == XML_FROM_NAMESPACE) ||
  ------------------
  |  Branch (488:9): [True: 0, False: 129]
  |  Branch (488:37): [True: 5, False: 124]
  ------------------
  489|    244|	(domain == XML_FROM_IO) || (domain == XML_FROM_VALID)) {
  ------------------
  |  Branch (489:2): [True: 0, False: 124]
  |  Branch (489:29): [True: 0, False: 124]
  ------------------
  490|    120|	ctxt = (xmlParserCtxtPtr) ctx;
  491|       |
  492|    120|        if (ctxt != NULL) {
  ------------------
  |  Branch (492:13): [True: 120, False: 0]
  ------------------
  493|    120|            if (level == XML_ERR_WARNING) {
  ------------------
  |  Branch (493:17): [True: 0, False: 120]
  ------------------
  494|      0|                if (ctxt->nbWarnings >= XML_MAX_ERRORS)
  ------------------
  |  |   20|      0|#define XML_MAX_ERRORS 100
  ------------------
  |  Branch (494:21): [True: 0, False: 0]
  ------------------
  495|      0|                    return;
  496|      0|                ctxt->nbWarnings += 1;
  497|    120|            } else {
  498|    120|                if (ctxt->nbErrors >= XML_MAX_ERRORS)
  ------------------
  |  |   20|    120|#define XML_MAX_ERRORS 100
  ------------------
  |  Branch (498:21): [True: 0, False: 120]
  ------------------
  499|      0|                    return;
  500|    120|                ctxt->nbErrors += 1;
  501|    120|            }
  502|       |
  503|    120|            if ((schannel == NULL) && (ctxt->sax != NULL) &&
  ------------------
  |  Branch (503:17): [True: 120, False: 0]
  |  Branch (503:39): [True: 120, False: 0]
  ------------------
  504|    120|                (ctxt->sax->initialized == XML_SAX2_MAGIC) &&
  ------------------
  |  |  685|    120|#define XML_SAX2_MAGIC 0xDEEDBEAF
  ------------------
  |  Branch (504:17): [True: 120, False: 0]
  ------------------
  505|    120|                (ctxt->sax->serror != NULL)) {
  ------------------
  |  Branch (505:17): [True: 0, False: 120]
  ------------------
  506|      0|                schannel = ctxt->sax->serror;
  507|      0|                data = ctxt->userData;
  508|      0|            }
  509|    120|        }
  510|    120|    }
  511|       |    /*
  512|       |     * Check if structured error handler set
  513|       |     */
  514|    244|    if (schannel == NULL) {
  ------------------
  |  Branch (514:9): [True: 244, False: 0]
  ------------------
  515|    244|	schannel = xmlStructuredError;
  ------------------
  |  |  877|    244|  #define xmlStructuredError XML_GLOBAL_MACRO(xmlStructuredError)
  |  |  ------------------
  |  |  |  |  500|    244|  #define XML_GLOBAL_MACRO(name) (*__##name())
  |  |  ------------------
  ------------------
  516|       |	/*
  517|       |	 * if user has defined handler, change data ptr to user's choice
  518|       |	 */
  519|    244|	if (schannel != NULL)
  ------------------
  |  Branch (519:6): [True: 0, False: 244]
  ------------------
  520|      0|	    data = xmlStructuredErrorContext;
  ------------------
  |  |  878|      0|  #define xmlStructuredErrorContext XML_GLOBAL_MACRO(xmlStructuredErrorContext)
  |  |  ------------------
  |  |  |  |  500|      0|  #define XML_GLOBAL_MACRO(name) (*__##name())
  |  |  ------------------
  ------------------
  521|    244|    }
  522|       |    /*
  523|       |     * Formatting the message
  524|       |     */
  525|    244|    if (msg == NULL) {
  ------------------
  |  Branch (525:9): [True: 0, False: 244]
  ------------------
  526|      0|        str = (char *) xmlStrdup(BAD_CAST "No error message provided");
  ------------------
  |  |   35|      0|#define BAD_CAST (xmlChar *)
  ------------------
  527|    244|    } else {
  528|    244|        XML_GET_VAR_STR(msg, str);
  ------------------
  |  |   22|    244|#define XML_GET_VAR_STR(msg, str) {				\
  |  |   23|    244|    int       size, prev_size = -1;				\
  |  |   24|    244|    int       chars;						\
  |  |   25|    244|    char      *larger;						\
  |  |   26|    244|    va_list   ap;						\
  |  |   27|    244|								\
  |  |   28|    244|    str = (char *) xmlMalloc(150);				\
  |  |   29|    244|    if (str != NULL) {						\
  |  |  ------------------
  |  |  |  Branch (29:9): [True: 244, False: 0]
  |  |  ------------------
  |  |   30|    244|								\
  |  |   31|    244|    size = 150;							\
  |  |   32|    244|								\
  |  |   33|    515|    while (size < 64000) {					\
  |  |  ------------------
  |  |  |  Branch (33:12): [True: 515, False: 0]
  |  |  ------------------
  |  |   34|    515|	va_start(ap, msg);					\
  |  |   35|    515|	chars = vsnprintf(str, size, msg, ap);			\
  |  |   36|    515|	va_end(ap);						\
  |  |   37|    515|	if ((chars > -1) && (chars < size)) {			\
  |  |  ------------------
  |  |  |  Branch (37:6): [True: 515, False: 0]
  |  |  |  Branch (37:22): [True: 488, False: 27]
  |  |  ------------------
  |  |   38|    488|	    if (prev_size == chars) {				\
  |  |  ------------------
  |  |  |  Branch (38:10): [True: 244, False: 244]
  |  |  ------------------
  |  |   39|    244|		break;						\
  |  |   40|    244|	    } else {						\
  |  |   41|    244|		prev_size = chars;				\
  |  |   42|    244|	    }							\
  |  |   43|    488|	}							\
  |  |   44|    515|	if (chars > -1)						\
  |  |  ------------------
  |  |  |  Branch (44:6): [True: 271, False: 0]
  |  |  ------------------
  |  |   45|    271|	    size += chars + 1;					\
  |  |   46|    271|	else							\
  |  |   47|    271|	    size += 100;					\
  |  |   48|    271|	if ((larger = (char *) xmlRealloc(str, size)) == NULL) {\
  |  |  ------------------
  |  |  |  Branch (48:6): [True: 0, False: 271]
  |  |  ------------------
  |  |   49|      0|	    break;						\
  |  |   50|      0|	}							\
  |  |   51|    271|	str = larger;						\
  |  |   52|    271|    }}								\
  |  |   53|    244|}
  ------------------
  529|    244|    }
  530|       |
  531|       |    /*
  532|       |     * specific processing if a parser context is provided
  533|       |     */
  534|    244|    if (ctxt != NULL) {
  ------------------
  |  Branch (534:9): [True: 120, False: 124]
  ------------------
  535|    120|        if (file == NULL) {
  ------------------
  |  Branch (535:13): [True: 120, False: 0]
  ------------------
  536|    120|            input = ctxt->input;
  537|    120|            if ((input != NULL) && (input->filename == NULL) &&
  ------------------
  |  Branch (537:17): [True: 120, False: 0]
  |  Branch (537:36): [True: 0, False: 120]
  ------------------
  538|    120|                (ctxt->inputNr > 1)) {
  ------------------
  |  Branch (538:17): [True: 0, False: 0]
  ------------------
  539|      0|                input = ctxt->inputTab[ctxt->inputNr - 2];
  540|      0|            }
  541|    120|            if (input != NULL) {
  ------------------
  |  Branch (541:17): [True: 120, False: 0]
  ------------------
  542|    120|                file = input->filename;
  543|    120|                line = input->line;
  544|    120|                col = input->col;
  545|    120|            }
  546|    120|        }
  547|    120|        to = &ctxt->lastError;
  548|    124|    } else if ((node != NULL) && (file == NULL)) {
  ------------------
  |  Branch (548:16): [True: 93, False: 31]
  |  Branch (548:34): [True: 93, False: 0]
  ------------------
  549|     93|	int i;
  550|       |
  551|     93|	if ((node->doc != NULL) && (node->doc->URL != NULL)) {
  ------------------
  |  Branch (551:6): [True: 93, False: 0]
  |  Branch (551:29): [True: 93, False: 0]
  ------------------
  552|     93|	    baseptr = node;
  553|       |/*	    file = (const char *) node->doc->URL; */
  554|     93|	}
  555|     93|	for (i = 0;
  556|    131|	     ((i < 10) && (node != NULL) && (node->type != XML_ELEMENT_NODE));
  ------------------
  |  Branch (556:8): [True: 131, False: 0]
  |  Branch (556:20): [True: 131, False: 0]
  |  Branch (556:38): [True: 38, False: 93]
  ------------------
  557|     93|	     i++)
  558|     38|	     node = node->parent;
  559|     93|        if ((baseptr == NULL) && (node != NULL) &&
  ------------------
  |  Branch (559:13): [True: 0, False: 93]
  |  Branch (559:34): [True: 0, False: 0]
  ------------------
  560|     93|	    (node->doc != NULL) && (node->doc->URL != NULL))
  ------------------
  |  Branch (560:6): [True: 0, False: 0]
  |  Branch (560:29): [True: 0, False: 0]
  ------------------
  561|      0|	    baseptr = node;
  562|       |
  563|     93|	if ((node != NULL) && (node->type == XML_ELEMENT_NODE))
  ------------------
  |  Branch (563:6): [True: 93, False: 0]
  |  Branch (563:24): [True: 93, False: 0]
  ------------------
  564|     93|	    line = node->line;
  565|     93|	if ((line == 0) || (line == 65535))
  ------------------
  |  Branch (565:6): [True: 0, False: 93]
  |  Branch (565:21): [True: 0, False: 93]
  ------------------
  566|      0|	    line = xmlGetLineNo(node);
  567|     93|    }
  568|       |
  569|       |    /*
  570|       |     * Save the information about the error
  571|       |     */
  572|    244|    xmlResetError(to);
  573|    244|    to->domain = domain;
  574|    244|    to->code = code;
  575|    244|    to->message = str;
  576|    244|    to->level = level;
  577|    244|    if (file != NULL)
  ------------------
  |  Branch (577:9): [True: 120, False: 124]
  ------------------
  578|    120|        to->file = (char *) xmlStrdup((const xmlChar *) file);
  579|    124|    else if (baseptr != NULL) {
  ------------------
  |  Branch (579:14): [True: 93, False: 31]
  ------------------
  580|     93|#ifdef LIBXML_XINCLUDE_ENABLED
  581|       |	/*
  582|       |	 * We check if the error is within an XInclude section and,
  583|       |	 * if so, attempt to print out the href of the XInclude instead
  584|       |	 * of the usual "base" (doc->URL) for the node (bug 152623).
  585|       |	 */
  586|     93|        xmlNodePtr prev = baseptr;
  587|     93|        char *href = NULL;
  588|     93|	int inclcount = 0;
  589|    893|	while (prev != NULL) {
  ------------------
  |  Branch (589:9): [True: 800, False: 93]
  ------------------
  590|    800|	    if (prev->prev == NULL)
  ------------------
  |  Branch (590:10): [True: 484, False: 316]
  ------------------
  591|    484|	        prev = prev->parent;
  592|    316|	    else {
  593|    316|	        prev = prev->prev;
  594|    316|		if (prev->type == XML_XINCLUDE_START) {
  ------------------
  |  Branch (594:7): [True: 0, False: 316]
  ------------------
  595|      0|		    if (inclcount > 0) {
  ------------------
  |  Branch (595:11): [True: 0, False: 0]
  ------------------
  596|      0|                        --inclcount;
  597|      0|                    } else {
  598|      0|                        href = (char *) xmlGetProp(prev, BAD_CAST "href");
  ------------------
  |  |   35|      0|#define BAD_CAST (xmlChar *)
  ------------------
  599|      0|                        if (href != NULL)
  ------------------
  |  Branch (599:29): [True: 0, False: 0]
  ------------------
  600|      0|		            break;
  601|      0|                    }
  602|    316|		} else if (prev->type == XML_XINCLUDE_END)
  ------------------
  |  Branch (602:14): [True: 0, False: 316]
  ------------------
  603|      0|		    inclcount++;
  604|    316|	    }
  605|    800|	}
  606|     93|        if (href != NULL)
  ------------------
  |  Branch (606:13): [True: 0, False: 93]
  ------------------
  607|      0|            to->file = href;
  608|     93|	else
  609|     93|#endif
  610|     93|	    to->file = (char *) xmlStrdup(baseptr->doc->URL);
  611|     93|	if ((to->file == NULL) && (node != NULL) && (node->doc != NULL)) {
  ------------------
  |  Branch (611:6): [True: 0, False: 93]
  |  Branch (611:28): [True: 0, False: 0]
  |  Branch (611:46): [True: 0, False: 0]
  ------------------
  612|      0|	    to->file = (char *) xmlStrdup(node->doc->URL);
  613|      0|	}
  614|     93|    }
  615|    244|    to->line = line;
  616|    244|    if (str1 != NULL)
  ------------------
  |  Branch (616:9): [True: 153, False: 91]
  ------------------
  617|    153|        to->str1 = (char *) xmlStrdup((const xmlChar *) str1);
  618|    244|    if (str2 != NULL)
  ------------------
  |  Branch (618:9): [True: 76, False: 168]
  ------------------
  619|     76|        to->str2 = (char *) xmlStrdup((const xmlChar *) str2);
  620|    244|    if (str3 != NULL)
  ------------------
  |  Branch (620:9): [True: 4, False: 240]
  ------------------
  621|      4|        to->str3 = (char *) xmlStrdup((const xmlChar *) str3);
  622|    244|    to->int1 = int1;
  623|    244|    to->int2 = col;
  624|    244|    to->node = node;
  625|    244|    to->ctxt = ctx;
  626|       |
  627|    244|    if (to != &xmlLastError)
  ------------------
  |  |  874|    244|  #define xmlLastError XML_GLOBAL_MACRO(xmlLastError)
  |  |  ------------------
  |  |  |  |  500|    244|  #define XML_GLOBAL_MACRO(name) (*__##name())
  |  |  ------------------
  ------------------
  |  Branch (627:9): [True: 120, False: 124]
  ------------------
  628|    120|        xmlCopyError(to,&xmlLastError);
  ------------------
  |  |  874|    120|  #define xmlLastError XML_GLOBAL_MACRO(xmlLastError)
  |  |  ------------------
  |  |  |  |  500|    120|  #define XML_GLOBAL_MACRO(name) (*__##name())
  |  |  ------------------
  ------------------
  629|       |
  630|    244|    if (schannel != NULL) {
  ------------------
  |  Branch (630:9): [True: 0, False: 244]
  ------------------
  631|      0|	schannel(data, to);
  632|      0|	return;
  633|      0|    }
  634|       |
  635|       |    /*
  636|       |     * Find the callback channel if channel param is NULL
  637|       |     */
  638|    244|    if ((ctxt != NULL) && (channel == NULL) &&
  ------------------
  |  Branch (638:9): [True: 120, False: 124]
  |  Branch (638:27): [True: 120, False: 0]
  ------------------
  639|    244|        (xmlStructuredError == NULL) && (ctxt->sax != NULL)) {
  ------------------
  |  |  877|    120|  #define xmlStructuredError XML_GLOBAL_MACRO(xmlStructuredError)
  |  |  ------------------
  |  |  |  |  500|    120|  #define XML_GLOBAL_MACRO(name) (*__##name())
  |  |  ------------------
  ------------------
  |  Branch (639:9): [True: 120, False: 0]
  |  Branch (639:41): [True: 120, False: 0]
  ------------------
  640|    120|        if (level == XML_ERR_WARNING)
  ------------------
  |  Branch (640:13): [True: 0, False: 120]
  ------------------
  641|      0|	    channel = ctxt->sax->warning;
  642|    120|        else
  643|    120|	    channel = ctxt->sax->error;
  644|    120|	data = ctxt->userData;
  645|    124|    } else if (channel == NULL) {
  ------------------
  |  Branch (645:16): [True: 0, False: 124]
  ------------------
  646|      0|	channel = xmlGenericError;
  ------------------
  |  |  875|      0|  #define xmlGenericError XML_GLOBAL_MACRO(xmlGenericError)
  |  |  ------------------
  |  |  |  |  500|      0|  #define XML_GLOBAL_MACRO(name) (*__##name())
  |  |  ------------------
  ------------------
  647|      0|	if (ctxt != NULL) {
  ------------------
  |  Branch (647:6): [True: 0, False: 0]
  ------------------
  648|      0|	    data = ctxt;
  649|      0|	} else {
  650|      0|	    data = xmlGenericErrorContext;
  ------------------
  |  |  876|      0|  #define xmlGenericErrorContext XML_GLOBAL_MACRO(xmlGenericErrorContext)
  |  |  ------------------
  |  |  |  |  500|      0|  #define XML_GLOBAL_MACRO(name) (*__##name())
  |  |  ------------------
  ------------------
  651|      0|	}
  652|      0|    }
  653|    244|    if (channel == NULL)
  ------------------
  |  Branch (653:9): [True: 0, False: 244]
  ------------------
  654|      0|        return;
  655|       |
  656|    244|    if ((channel == xmlParserError) ||
  ------------------
  |  Branch (656:9): [True: 120, False: 124]
  ------------------
  657|    244|        (channel == xmlParserWarning) ||
  ------------------
  |  Branch (657:9): [True: 0, False: 124]
  ------------------
  658|    244|	(channel == xmlParserValidityError) ||
  ------------------
  |  Branch (658:2): [True: 0, False: 124]
  ------------------
  659|    244|	(channel == xmlParserValidityWarning))
  ------------------
  |  Branch (659:2): [True: 0, False: 124]
  ------------------
  660|    120|	xmlReportError(to, ctxt, str, NULL, NULL);
  661|    124|    else if (((void(*)(void)) channel == (void(*)(void)) fprintf) ||
  ------------------
  |  Branch (661:14): [True: 0, False: 124]
  ------------------
  662|    124|             (channel == xmlGenericErrorDefaultFunc))
  ------------------
  |  Branch (662:14): [True: 0, False: 124]
  ------------------
  663|      0|	xmlReportError(to, ctxt, str, channel, data);
  664|    124|    else
  665|    124|	channel(data, "%s", str);
  666|    244|}
xmlGetLastError:
  887|     36|{
  888|     36|    if (xmlLastError.code == XML_ERR_OK)
  ------------------
  |  |  874|     36|  #define xmlLastError XML_GLOBAL_MACRO(xmlLastError)
  |  |  ------------------
  |  |  |  |  500|     36|  #define XML_GLOBAL_MACRO(name) (*__##name())
  |  |  ------------------
  ------------------
  |  Branch (888:9): [True: 4, False: 32]
  ------------------
  889|      4|        return (NULL);
  890|     32|    return (&xmlLastError);
  ------------------
  |  |  874|     32|  #define xmlLastError XML_GLOBAL_MACRO(xmlLastError)
  |  |  ------------------
  |  |  |  |  500|     32|  #define XML_GLOBAL_MACRO(name) (*__##name())
  |  |  ------------------
  ------------------
  891|     36|}
xmlResetError:
  901|    317|{
  902|    317|    if (err == NULL)
  ------------------
  |  Branch (902:9): [True: 0, False: 317]
  ------------------
  903|      0|        return;
  904|    317|    if (err->code == XML_ERR_OK)
  ------------------
  |  Branch (904:9): [True: 73, False: 244]
  ------------------
  905|     73|        return;
  906|    244|    if (err->message != NULL)
  ------------------
  |  Branch (906:9): [True: 244, False: 0]
  ------------------
  907|    244|        xmlFree(err->message);
  908|    244|    if (err->file != NULL)
  ------------------
  |  Branch (908:9): [True: 213, False: 31]
  ------------------
  909|    213|        xmlFree(err->file);
  910|    244|    if (err->str1 != NULL)
  ------------------
  |  Branch (910:9): [True: 153, False: 91]
  ------------------
  911|    153|        xmlFree(err->str1);
  912|    244|    if (err->str2 != NULL)
  ------------------
  |  Branch (912:9): [True: 76, False: 168]
  ------------------
  913|     76|        xmlFree(err->str2);
  914|    244|    if (err->str3 != NULL)
  ------------------
  |  Branch (914:9): [True: 4, False: 240]
  ------------------
  915|      4|        xmlFree(err->str3);
  916|    244|    memset(err, 0, sizeof(xmlError));
  917|    244|    err->code = XML_ERR_OK;
  918|    244|}
xmlResetLastError:
  928|    198|{
  929|    198|    if (xmlLastError.code == XML_ERR_OK)
  ------------------
  |  |  874|    198|  #define xmlLastError XML_GLOBAL_MACRO(xmlLastError)
  |  |  ------------------
  |  |  |  |  500|    198|  #define XML_GLOBAL_MACRO(name) (*__##name())
  |  |  ------------------
  ------------------
  |  Branch (929:9): [True: 125, False: 73]
  ------------------
  930|    125|        return;
  931|     73|    xmlResetError(&xmlLastError);
  ------------------
  |  |  874|     73|  #define xmlLastError XML_GLOBAL_MACRO(xmlLastError)
  |  |  ------------------
  |  |  |  |  500|     73|  #define XML_GLOBAL_MACRO(name) (*__##name())
  |  |  ------------------
  ------------------
  932|     73|}
xmlCopyError:
  984|    120|xmlCopyError(const xmlError *from, xmlErrorPtr to) {
  985|    120|    char *message, *file, *str1, *str2, *str3;
  986|       |
  987|    120|    if ((from == NULL) || (to == NULL))
  ------------------
  |  Branch (987:9): [True: 0, False: 120]
  |  Branch (987:27): [True: 0, False: 120]
  ------------------
  988|      0|        return(-1);
  989|       |
  990|    120|    message = (char *) xmlStrdup((xmlChar *) from->message);
  991|    120|    file = (char *) xmlStrdup ((xmlChar *) from->file);
  992|    120|    str1 = (char *) xmlStrdup ((xmlChar *) from->str1);
  993|    120|    str2 = (char *) xmlStrdup ((xmlChar *) from->str2);
  994|    120|    str3 = (char *) xmlStrdup ((xmlChar *) from->str3);
  995|       |
  996|    120|    if (to->message != NULL)
  ------------------
  |  Branch (996:9): [True: 88, False: 32]
  ------------------
  997|     88|        xmlFree(to->message);
  998|    120|    if (to->file != NULL)
  ------------------
  |  Branch (998:9): [True: 88, False: 32]
  ------------------
  999|     88|        xmlFree(to->file);
 1000|    120|    if (to->str1 != NULL)
  ------------------
  |  Branch (1000:9): [True: 43, False: 77]
  ------------------
 1001|     43|        xmlFree(to->str1);
 1002|    120|    if (to->str2 != NULL)
  ------------------
  |  Branch (1002:9): [True: 21, False: 99]
  ------------------
 1003|     21|        xmlFree(to->str2);
 1004|    120|    if (to->str3 != NULL)
  ------------------
  |  Branch (1004:9): [True: 0, False: 120]
  ------------------
 1005|      0|        xmlFree(to->str3);
 1006|    120|    to->domain = from->domain;
 1007|    120|    to->code = from->code;
 1008|    120|    to->level = from->level;
 1009|    120|    to->line = from->line;
 1010|    120|    to->node = from->node;
 1011|    120|    to->int1 = from->int1;
 1012|    120|    to->int2 = from->int2;
 1013|    120|    to->node = from->node;
 1014|    120|    to->ctxt = from->ctxt;
 1015|    120|    to->message = message;
 1016|    120|    to->file = file;
 1017|    120|    to->str1 = str1;
 1018|    120|    to->str2 = str2;
 1019|    120|    to->str3 = str3;
 1020|       |
 1021|    120|    return 0;
 1022|    120|}
error.c:xmlParserPrintFileContextInternal:
  175|    120|		xmlGenericErrorFunc channel, void *data ) {
  176|    120|    const xmlChar *cur, *base, *start;
  177|    120|    unsigned int n, col;	/* GCC warns if signed, because compared with sizeof() */
  178|    120|    xmlChar  content[81]; /* space for 80 chars + line terminator */
  179|    120|    xmlChar *ctnt;
  180|       |
  181|    120|    if ((input == NULL) || (input->cur == NULL))
  ------------------
  |  Branch (181:9): [True: 0, False: 120]
  |  Branch (181:28): [True: 0, False: 120]
  ------------------
  182|      0|        return;
  183|       |
  184|    120|    cur = input->cur;
  185|    120|    base = input->base;
  186|       |    /* skip backwards over any end-of-lines */
  187|    146|    while ((cur > base) && ((*(cur) == '\n') || (*(cur) == '\r'))) {
  ------------------
  |  Branch (187:12): [True: 145, False: 1]
  |  Branch (187:29): [True: 24, False: 121]
  |  Branch (187:49): [True: 2, False: 119]
  ------------------
  188|     26|	cur--;
  189|     26|    }
  190|    120|    n = 0;
  191|       |    /* search backwards for beginning-of-line (to max buff size) */
  192|  2.62k|    while ((n < sizeof(content) - 1) && (cur > base) &&
  ------------------
  |  Branch (192:12): [True: 2.62k, False: 0]
  |  Branch (192:41): [True: 2.61k, False: 8]
  ------------------
  193|  2.62k|	   (*cur != '\n') && (*cur != '\r')) {
  ------------------
  |  Branch (193:5): [True: 2.50k, False: 112]
  |  Branch (193:23): [True: 2.50k, False: 0]
  ------------------
  194|  2.50k|        cur--;
  195|  2.50k|        n++;
  196|  2.50k|    }
  197|    120|    if ((n > 0) && ((*cur == '\n') || (*cur == '\r'))) {
  ------------------
  |  Branch (197:9): [True: 119, False: 1]
  |  Branch (197:21): [True: 112, False: 7]
  |  Branch (197:39): [True: 0, False: 7]
  ------------------
  198|    112|        cur++;
  199|    112|    } else {
  200|       |        /* skip over continuation bytes */
  201|      8|        while ((cur < input->cur) && ((*cur & 0xC0) == 0x80))
  ------------------
  |  Branch (201:16): [True: 7, False: 1]
  |  Branch (201:38): [True: 0, False: 7]
  ------------------
  202|      0|            cur++;
  203|      8|    }
  204|       |    /* calculate the error position in terms of the current position */
  205|    120|    col = input->cur - cur;
  206|       |    /* search forward for end-of-line (to max buff size) */
  207|    120|    n = 0;
  208|    120|    start = cur;
  209|       |    /* copy selected text to our buffer */
  210|  3.94k|    while ((*cur != 0) && (*(cur) != '\n') && (*(cur) != '\r')) {
  ------------------
  |  Branch (210:12): [True: 3.92k, False: 23]
  |  Branch (210:27): [True: 3.85k, False: 65]
  |  Branch (210:47): [True: 3.85k, False: 5]
  ------------------
  211|  3.85k|        int len = input->end - cur;
  212|  3.85k|        int c = xmlGetUTF8Char(cur, &len);
  213|       |
  214|  3.85k|        if ((c < 0) || (n + len > sizeof(content)-1))
  ------------------
  |  Branch (214:13): [True: 20, False: 3.83k]
  |  Branch (214:24): [True: 7, False: 3.82k]
  ------------------
  215|     27|            break;
  216|  3.82k|        cur += len;
  217|  3.82k|	n += len;
  218|  3.82k|    }
  219|    120|    memcpy(content, start, n);
  220|    120|    content[n] = 0;
  221|       |    /* print out the selected text */
  222|    120|    channel(data ,"%s\n", content);
  223|       |    /* create blank line with problem pointer */
  224|    120|    n = 0;
  225|    120|    ctnt = content;
  226|       |    /* (leave buffer space for pointer + line terminator) */
  227|  2.46k|    while ((n<col) && (n++ < sizeof(content)-2) && (*ctnt != 0)) {
  ------------------
  |  Branch (227:12): [True: 2.36k, False: 101]
  |  Branch (227:23): [True: 2.36k, False: 0]
  |  Branch (227:52): [True: 2.34k, False: 19]
  ------------------
  228|  2.34k|	if (*(ctnt) != '\t')
  ------------------
  |  Branch (228:6): [True: 2.22k, False: 122]
  ------------------
  229|  2.22k|	    *(ctnt) = ' ';
  230|  2.34k|	ctnt++;
  231|  2.34k|    }
  232|    120|    *ctnt++ = '^';
  233|    120|    *ctnt = 0;
  234|    120|    channel(data ,"%s\n", content);
  235|    120|}
error.c:xmlReportError:
  261|    120|{
  262|    120|    char *file = NULL;
  263|    120|    int line = 0;
  264|    120|    int code = -1;
  265|    120|    int domain;
  266|    120|    const xmlChar *name = NULL;
  267|    120|    xmlNodePtr node;
  268|    120|    xmlErrorLevel level;
  269|    120|    xmlParserInputPtr input = NULL;
  270|    120|    xmlParserInputPtr cur = NULL;
  271|       |
  272|    120|    if (err == NULL)
  ------------------
  |  Branch (272:9): [True: 0, False: 120]
  ------------------
  273|      0|        return;
  274|       |
  275|    120|    if (channel == NULL) {
  ------------------
  |  Branch (275:9): [True: 120, False: 0]
  ------------------
  276|    120|	channel = xmlGenericError;
  ------------------
  |  |  875|    120|  #define xmlGenericError XML_GLOBAL_MACRO(xmlGenericError)
  |  |  ------------------
  |  |  |  |  500|    120|  #define XML_GLOBAL_MACRO(name) (*__##name())
  |  |  ------------------
  ------------------
  277|    120|	data = xmlGenericErrorContext;
  ------------------
  |  |  876|    120|  #define xmlGenericErrorContext XML_GLOBAL_MACRO(xmlGenericErrorContext)
  |  |  ------------------
  |  |  |  |  500|    120|  #define XML_GLOBAL_MACRO(name) (*__##name())
  |  |  ------------------
  ------------------
  278|    120|    }
  279|    120|    file = err->file;
  280|    120|    line = err->line;
  281|    120|    code = err->code;
  282|    120|    domain = err->domain;
  283|    120|    level = err->level;
  284|    120|    node = err->node;
  285|       |
  286|    120|    if (code == XML_ERR_OK)
  ------------------
  |  Branch (286:9): [True: 0, False: 120]
  ------------------
  287|      0|        return;
  288|       |
  289|    120|    if ((node != NULL) && (node->type == XML_ELEMENT_NODE))
  ------------------
  |  Branch (289:9): [True: 0, False: 120]
  |  Branch (289:27): [True: 0, False: 0]
  ------------------
  290|      0|        name = node->name;
  291|       |
  292|       |    /*
  293|       |     * Maintain the compatibility with the legacy error handling
  294|       |     */
  295|    120|    if (ctxt != NULL) {
  ------------------
  |  Branch (295:9): [True: 120, False: 0]
  ------------------
  296|    120|        input = ctxt->input;
  297|    120|        if ((input != NULL) && (input->filename == NULL) &&
  ------------------
  |  Branch (297:13): [True: 120, False: 0]
  |  Branch (297:32): [True: 0, False: 120]
  ------------------
  298|    120|            (ctxt->inputNr > 1)) {
  ------------------
  |  Branch (298:13): [True: 0, False: 0]
  ------------------
  299|      0|            cur = input;
  300|      0|            input = ctxt->inputTab[ctxt->inputNr - 2];
  301|      0|        }
  302|    120|        if (input != NULL) {
  ------------------
  |  Branch (302:13): [True: 120, False: 0]
  ------------------
  303|    120|            if (input->filename)
  ------------------
  |  Branch (303:17): [True: 120, False: 0]
  ------------------
  304|    120|                channel(data, "%s:%d: ", input->filename, input->line);
  305|      0|            else if ((line != 0) && (domain == XML_FROM_PARSER))
  ------------------
  |  Branch (305:22): [True: 0, False: 0]
  |  Branch (305:37): [True: 0, False: 0]
  ------------------
  306|      0|                channel(data, "Entity: line %d: ", input->line);
  307|    120|        }
  308|    120|    } else {
  309|      0|        if (file != NULL)
  ------------------
  |  Branch (309:13): [True: 0, False: 0]
  ------------------
  310|      0|            channel(data, "%s:%d: ", file, line);
  311|      0|        else if ((line != 0) &&
  ------------------
  |  Branch (311:18): [True: 0, False: 0]
  ------------------
  312|      0|	         ((domain == XML_FROM_PARSER) || (domain == XML_FROM_SCHEMASV)||
  ------------------
  |  Branch (312:12): [True: 0, False: 0]
  |  Branch (312:43): [True: 0, False: 0]
  ------------------
  313|      0|		  (domain == XML_FROM_SCHEMASP)||(domain == XML_FROM_DTD) ||
  ------------------
  |  Branch (313:5): [True: 0, False: 0]
  |  Branch (313:36): [True: 0, False: 0]
  ------------------
  314|      0|		  (domain == XML_FROM_RELAXNGP)||(domain == XML_FROM_RELAXNGV)))
  ------------------
  |  Branch (314:5): [True: 0, False: 0]
  |  Branch (314:36): [True: 0, False: 0]
  ------------------
  315|      0|            channel(data, "Entity: line %d: ", line);
  316|      0|    }
  317|    120|    if (name != NULL) {
  ------------------
  |  Branch (317:9): [True: 0, False: 120]
  ------------------
  318|      0|        channel(data, "element %s: ", name);
  319|      0|    }
  320|    120|    switch (domain) {
  321|    115|        case XML_FROM_PARSER:
  ------------------
  |  Branch (321:9): [True: 115, False: 5]
  ------------------
  322|    115|            channel(data, "parser ");
  323|    115|            break;
  324|      5|        case XML_FROM_NAMESPACE:
  ------------------
  |  Branch (324:9): [True: 5, False: 115]
  ------------------
  325|      5|            channel(data, "namespace ");
  326|      5|            break;
  327|      0|        case XML_FROM_DTD:
  ------------------
  |  Branch (327:9): [True: 0, False: 120]
  ------------------
  328|      0|        case XML_FROM_VALID:
  ------------------
  |  Branch (328:9): [True: 0, False: 120]
  ------------------
  329|      0|            channel(data, "validity ");
  330|      0|            break;
  331|      0|        case XML_FROM_HTML:
  ------------------
  |  Branch (331:9): [True: 0, False: 120]
  ------------------
  332|      0|            channel(data, "HTML parser ");
  333|      0|            break;
  334|      0|        case XML_FROM_MEMORY:
  ------------------
  |  Branch (334:9): [True: 0, False: 120]
  ------------------
  335|      0|            channel(data, "memory ");
  336|      0|            break;
  337|      0|        case XML_FROM_OUTPUT:
  ------------------
  |  Branch (337:9): [True: 0, False: 120]
  ------------------
  338|      0|            channel(data, "output ");
  339|      0|            break;
  340|      0|        case XML_FROM_IO:
  ------------------
  |  Branch (340:9): [True: 0, False: 120]
  ------------------
  341|      0|            channel(data, "I/O ");
  342|      0|            break;
  343|      0|        case XML_FROM_XINCLUDE:
  ------------------
  |  Branch (343:9): [True: 0, False: 120]
  ------------------
  344|      0|            channel(data, "XInclude ");
  345|      0|            break;
  346|      0|        case XML_FROM_XPATH:
  ------------------
  |  Branch (346:9): [True: 0, False: 120]
  ------------------
  347|      0|            channel(data, "XPath ");
  348|      0|            break;
  349|      0|        case XML_FROM_XPOINTER:
  ------------------
  |  Branch (349:9): [True: 0, False: 120]
  ------------------
  350|      0|            channel(data, "parser ");
  351|      0|            break;
  352|      0|        case XML_FROM_REGEXP:
  ------------------
  |  Branch (352:9): [True: 0, False: 120]
  ------------------
  353|      0|            channel(data, "regexp ");
  354|      0|            break;
  355|      0|        case XML_FROM_MODULE:
  ------------------
  |  Branch (355:9): [True: 0, False: 120]
  ------------------
  356|      0|            channel(data, "module ");
  357|      0|            break;
  358|      0|        case XML_FROM_SCHEMASV:
  ------------------
  |  Branch (358:9): [True: 0, False: 120]
  ------------------
  359|      0|            channel(data, "Schemas validity ");
  360|      0|            break;
  361|      0|        case XML_FROM_SCHEMASP:
  ------------------
  |  Branch (361:9): [True: 0, False: 120]
  ------------------
  362|      0|            channel(data, "Schemas parser ");
  363|      0|            break;
  364|      0|        case XML_FROM_RELAXNGP:
  ------------------
  |  Branch (364:9): [True: 0, False: 120]
  ------------------
  365|      0|            channel(data, "Relax-NG parser ");
  366|      0|            break;
  367|      0|        case XML_FROM_RELAXNGV:
  ------------------
  |  Branch (367:9): [True: 0, False: 120]
  ------------------
  368|      0|            channel(data, "Relax-NG validity ");
  369|      0|            break;
  370|      0|        case XML_FROM_CATALOG:
  ------------------
  |  Branch (370:9): [True: 0, False: 120]
  ------------------
  371|      0|            channel(data, "Catalog ");
  372|      0|            break;
  373|      0|        case XML_FROM_C14N:
  ------------------
  |  Branch (373:9): [True: 0, False: 120]
  ------------------
  374|      0|            channel(data, "C14N ");
  375|      0|            break;
  376|      0|        case XML_FROM_XSLT:
  ------------------
  |  Branch (376:9): [True: 0, False: 120]
  ------------------
  377|      0|            channel(data, "XSLT ");
  378|      0|            break;
  379|      0|        case XML_FROM_I18N:
  ------------------
  |  Branch (379:9): [True: 0, False: 120]
  ------------------
  380|      0|            channel(data, "encoding ");
  381|      0|            break;
  382|      0|        case XML_FROM_SCHEMATRONV:
  ------------------
  |  Branch (382:9): [True: 0, False: 120]
  ------------------
  383|      0|            channel(data, "schematron ");
  384|      0|            break;
  385|      0|        case XML_FROM_BUFFER:
  ------------------
  |  Branch (385:9): [True: 0, False: 120]
  ------------------
  386|      0|            channel(data, "internal buffer ");
  387|      0|            break;
  388|      0|        case XML_FROM_URI:
  ------------------
  |  Branch (388:9): [True: 0, False: 120]
  ------------------
  389|      0|            channel(data, "URI ");
  390|      0|            break;
  391|      0|        default:
  ------------------
  |  Branch (391:9): [True: 0, False: 120]
  ------------------
  392|      0|            break;
  393|    120|    }
  394|    120|    switch (level) {
  ------------------
  |  Branch (394:13): [True: 0, False: 120]
  ------------------
  395|      0|        case XML_ERR_NONE:
  ------------------
  |  Branch (395:9): [True: 0, False: 120]
  ------------------
  396|      0|            channel(data, ": ");
  397|      0|            break;
  398|      0|        case XML_ERR_WARNING:
  ------------------
  |  Branch (398:9): [True: 0, False: 120]
  ------------------
  399|      0|            channel(data, "warning : ");
  400|      0|            break;
  401|      5|        case XML_ERR_ERROR:
  ------------------
  |  Branch (401:9): [True: 5, False: 115]
  ------------------
  402|      5|            channel(data, "error : ");
  403|      5|            break;
  404|    115|        case XML_ERR_FATAL:
  ------------------
  |  Branch (404:9): [True: 115, False: 5]
  ------------------
  405|    115|            channel(data, "error : ");
  406|    115|            break;
  407|    120|    }
  408|    120|    if (str != NULL) {
  ------------------
  |  Branch (408:9): [True: 120, False: 0]
  ------------------
  409|    120|        int len;
  410|    120|	len = xmlStrlen((const xmlChar *)str);
  411|    120|	if ((len > 0) && (str[len - 1] != '\n'))
  ------------------
  |  Branch (411:6): [True: 120, False: 0]
  |  Branch (411:19): [True: 0, False: 120]
  ------------------
  412|      0|	    channel(data, "%s\n", str);
  413|    120|	else
  414|    120|	    channel(data, "%s", str);
  415|    120|    } else {
  416|      0|        channel(data, "%s\n", "out of memory error");
  417|      0|    }
  418|       |
  419|    120|    if (ctxt != NULL) {
  ------------------
  |  Branch (419:9): [True: 120, False: 0]
  ------------------
  420|    120|        xmlParserPrintFileContextInternal(input, channel, data);
  421|    120|        if (cur != NULL) {
  ------------------
  |  Branch (421:13): [True: 0, False: 120]
  ------------------
  422|      0|            if (cur->filename)
  ------------------
  |  Branch (422:17): [True: 0, False: 0]
  ------------------
  423|      0|                channel(data, "%s:%d: \n", cur->filename, cur->line);
  424|      0|            else if ((line != 0) && (domain == XML_FROM_PARSER))
  ------------------
  |  Branch (424:22): [True: 0, False: 0]
  |  Branch (424:37): [True: 0, False: 0]
  ------------------
  425|      0|                channel(data, "Entity: line %d: \n", cur->line);
  426|      0|            xmlParserPrintFileContextInternal(cur, channel, data);
  427|      0|        }
  428|    120|    }
  429|    120|    if ((domain == XML_FROM_XPATH) && (err->str1 != NULL) &&
  ------------------
  |  Branch (429:9): [True: 0, False: 120]
  |  Branch (429:39): [True: 0, False: 0]
  ------------------
  430|    120|        (err->int1 < 100) &&
  ------------------
  |  Branch (430:9): [True: 0, False: 0]
  ------------------
  431|    120|	(err->int1 < xmlStrlen((const xmlChar *)err->str1))) {
  ------------------
  |  Branch (431:2): [True: 0, False: 0]
  ------------------
  432|      0|	xmlChar buf[150];
  433|      0|	int i;
  434|       |
  435|      0|	channel(data, "%s\n", err->str1);
  436|      0|	for (i=0;i < err->int1;i++)
  ------------------
  |  Branch (436:11): [True: 0, False: 0]
  ------------------
  437|      0|	     buf[i] = ' ';
  438|      0|	buf[i++] = '^';
  439|      0|	buf[i] = 0;
  440|      0|	channel(data, "%s\n", buf);
  441|      0|    }
  442|    120|}

xmlFuzzErrorFunc:
   56|    844|                 ...) {
   57|    844|}
xmlFuzzMemSetup:
  103|      2|xmlFuzzMemSetup(void) {
  104|      2|    xmlMemSetup(free, xmlFuzzMalloc, xmlFuzzRealloc, xmlMemStrdup);
  105|      2|}
xmlFuzzMemSetLimit:
  108|    396|xmlFuzzMemSetLimit(size_t limit) {
  109|    396|    fuzzNumAllocs = 0;
  110|    396|    fuzzMaxAllocs = limit ? limit + XML_FUZZ_MALLOC_OFFSET : 0;
  ------------------
  |  |   69|      0|#define XML_FUZZ_MALLOC_OFFSET  0
  ------------------
  |  Branch (110:21): [True: 0, False: 396]
  ------------------
  111|    396|    fuzzAllocFailed = 0;
  112|    396|}
xmlFuzzDataInit:
  125|    198|xmlFuzzDataInit(const char *data, size_t size) {
  126|    198|    fuzzData.data = data;
  127|    198|    fuzzData.size = size;
  128|    198|    fuzzData.ptr = data;
  129|    198|    fuzzData.remaining = size;
  130|       |
  131|    198|    fuzzData.outBuf = xmlMalloc(size + 1);
  132|    198|    fuzzData.outPtr = fuzzData.outBuf;
  133|       |
  134|    198|    fuzzData.entities = xmlHashCreate(8);
  135|    198|    fuzzData.mainUrl = NULL;
  136|    198|    fuzzData.mainEntity = NULL;
  137|    198|}
xmlFuzzDataCleanup:
  145|    198|xmlFuzzDataCleanup(void) {
  146|    198|    xmlFree(fuzzData.outBuf);
  147|    198|    xmlHashFree(fuzzData.entities, xmlHashDefaultDeallocator);
  148|    198|}
xmlFuzzReadInt:
  181|    198|xmlFuzzReadInt(int size) {
  182|    198|    size_t ret = 0;
  183|       |
  184|    198|    while ((size > 0) && (fuzzData.remaining > 0)) {
  ------------------
  |  Branch (184:12): [True: 198, False: 0]
  |  Branch (184:26): [True: 0, False: 198]
  ------------------
  185|      0|        unsigned char c = (unsigned char) *fuzzData.ptr++;
  186|      0|        fuzzData.remaining--;
  187|      0|        ret = (ret << 8) | c;
  188|      0|        size--;
  189|      0|    }
  190|       |
  191|    198|    return ret;
  192|    198|}
xmlFuzzReadString:
  245|    693|xmlFuzzReadString(size_t *size) {
  246|    693|    const char *out = fuzzData.outPtr;
  247|       |
  248|   286k|    while (fuzzData.remaining > 0) {
  ------------------
  |  Branch (248:12): [True: 286k, False: 200]
  ------------------
  249|   286k|        int c = *fuzzData.ptr++;
  250|   286k|        fuzzData.remaining--;
  251|       |
  252|   286k|        if ((c == '\\') && (fuzzData.remaining > 0)) {
  ------------------
  |  Branch (252:13): [True: 543, False: 285k]
  |  Branch (252:28): [True: 543, False: 0]
  ------------------
  253|    543|            int c2 = *fuzzData.ptr;
  254|       |
  255|    543|            if (c2 == '\n') {
  ------------------
  |  Branch (255:17): [True: 493, False: 50]
  ------------------
  256|    493|                fuzzData.ptr++;
  257|    493|                fuzzData.remaining--;
  258|    493|                if (size != NULL)
  ------------------
  |  Branch (258:21): [True: 246, False: 247]
  ------------------
  259|    246|                    *size = fuzzData.outPtr - out;
  260|    493|                *fuzzData.outPtr++ = '\0';
  261|    493|                return(out);
  262|    493|            }
  263|     50|            if (c2 == '\\') {
  ------------------
  |  Branch (263:17): [True: 49, False: 1]
  ------------------
  264|     49|                fuzzData.ptr++;
  265|     49|                fuzzData.remaining--;
  266|     49|            }
  267|     50|        }
  268|       |
  269|   285k|        *fuzzData.outPtr++ = c;
  270|   285k|    }
  271|       |
  272|    200|    if (fuzzData.outPtr > out) {
  ------------------
  |  Branch (272:9): [True: 2, False: 198]
  ------------------
  273|      2|        if (size != NULL)
  ------------------
  |  Branch (273:13): [True: 0, False: 2]
  ------------------
  274|      0|            *size = fuzzData.outPtr - out;
  275|      2|        *fuzzData.outPtr++ = '\0';
  276|      2|        return(out);
  277|      2|    }
  278|       |
  279|    198|    if (size != NULL)
  ------------------
  |  Branch (279:9): [True: 3, False: 195]
  ------------------
  280|      3|        *size = 0;
  281|    198|    return(NULL);
  282|    200|}
xmlFuzzReadEntities:
  291|    198|xmlFuzzReadEntities(void) {
  292|    198|    size_t num = 0;
  293|       |
  294|    444|    while (1) {
  ------------------
  |  Branch (294:12): [Folded - Ignored]
  ------------------
  295|    444|        const char *url, *entity;
  296|    444|        size_t entitySize;
  297|    444|        xmlFuzzEntityInfo *entityInfo;
  298|       |
  299|    444|        url = xmlFuzzReadString(NULL);
  300|    444|        if (url == NULL) break;
  ------------------
  |  Branch (300:13): [True: 195, False: 249]
  ------------------
  301|       |
  302|    249|        entity = xmlFuzzReadString(&entitySize);
  303|    249|        if (entity == NULL) break;
  ------------------
  |  Branch (303:13): [True: 3, False: 246]
  ------------------
  304|       |
  305|    246|        if (xmlHashLookup(fuzzData.entities, (xmlChar *)url) == NULL) {
  ------------------
  |  Branch (305:13): [True: 246, False: 0]
  ------------------
  306|    246|            entityInfo = xmlMalloc(sizeof(xmlFuzzEntityInfo));
  307|    246|            if (entityInfo == NULL)
  ------------------
  |  Branch (307:17): [True: 0, False: 246]
  ------------------
  308|      0|                break;
  309|    246|            entityInfo->data = entity;
  310|    246|            entityInfo->size = entitySize;
  311|       |
  312|    246|            xmlHashAddEntry(fuzzData.entities, (xmlChar *)url, entityInfo);
  313|       |
  314|    246|            if (num == 0) {
  ------------------
  |  Branch (314:17): [True: 198, False: 48]
  ------------------
  315|    198|                fuzzData.mainUrl = url;
  316|    198|                fuzzData.mainEntity = entityInfo;
  317|    198|            }
  318|       |
  319|    246|            num++;
  320|    246|        }
  321|    246|    }
  322|    198|}
xmlFuzzMainUrl:
  330|    198|xmlFuzzMainUrl(void) {
  331|    198|    return(fuzzData.mainUrl);
  332|    198|}
xmlFuzzEntityLoader:
  355|    242|                    xmlParserCtxtPtr ctxt) {
  356|    242|    xmlParserInputPtr input;
  357|    242|    xmlFuzzEntityInfo *entity;
  358|       |
  359|    242|    if (URL == NULL)
  ------------------
  |  Branch (359:9): [True: 0, False: 242]
  ------------------
  360|      0|        return(NULL);
  361|    242|    entity = xmlHashLookup(fuzzData.entities, (xmlChar *) URL);
  362|    242|    if (entity == NULL)
  ------------------
  |  Branch (362:9): [True: 4, False: 238]
  ------------------
  363|      4|        return(NULL);
  364|       |
  365|    238|    input = xmlNewInputStream(ctxt);
  366|    238|    if (input == NULL)
  ------------------
  |  Branch (366:9): [True: 0, False: 238]
  ------------------
  367|      0|        return(NULL);
  368|    238|    input->filename = (char *) xmlCharStrdup(URL);
  369|    238|    input->buf = xmlParserInputBufferCreateMem(entity->data, entity->size,
  370|    238|                                               XML_CHAR_ENCODING_NONE);
  371|    238|    if (input->buf == NULL) {
  ------------------
  |  Branch (371:9): [True: 0, False: 238]
  ------------------
  372|      0|        xmlFreeInputStream(input);
  373|      0|        return(NULL);
  374|      0|    }
  375|    238|    input->base = input->cur = xmlBufContent(input->buf->buffer);
  376|    238|    input->end = input->base + xmlBufUse(input->buf->buffer);
  377|       |
  378|    238|    return input;
  379|    238|}
fuzz.c:xmlFuzzMalloc:
   73|  52.9k|xmlFuzzMalloc(size_t size) {
   74|  52.9k|    if (fuzzMaxAllocs > 0) {
  ------------------
  |  Branch (74:9): [True: 0, False: 52.9k]
  ------------------
   75|      0|        if (fuzzNumAllocs >= fuzzMaxAllocs - 1) {
  ------------------
  |  Branch (75:13): [True: 0, False: 0]
  ------------------
   76|       |#if XML_FUZZ_MALLOC_ABORT
   77|       |            abort();
   78|       |#endif
   79|      0|            fuzzAllocFailed = 1;
   80|      0|            return(NULL);
   81|      0|        }
   82|      0|        fuzzNumAllocs += 1;
   83|      0|    }
   84|  52.9k|    return malloc(size);
   85|  52.9k|}
fuzz.c:xmlFuzzRealloc:
   88|  3.57k|xmlFuzzRealloc(void *ptr, size_t size) {
   89|  3.57k|    if (fuzzMaxAllocs > 0) {
  ------------------
  |  Branch (89:9): [True: 0, False: 3.57k]
  ------------------
   90|      0|        if (fuzzNumAllocs >= fuzzMaxAllocs - 1) {
  ------------------
  |  Branch (90:13): [True: 0, False: 0]
  ------------------
   91|       |#if XML_FUZZ_MALLOC_ABORT
   92|       |            abort();
   93|       |#endif
   94|      0|            fuzzAllocFailed = 1;
   95|      0|            return(NULL);
   96|      0|        }
   97|      0|        fuzzNumAllocs += 1;
   98|      0|    }
   99|  3.57k|    return realloc(ptr, size);
  100|  3.57k|}

LLVMFuzzerInitialize:
   13|      2|                     char ***argv ATTRIBUTE_UNUSED) {
   14|      2|    xmlFuzzMemSetup();
   15|      2|    xmlInitParser();
   16|      2|#ifdef LIBXML_CATALOG_ENABLED
   17|      2|    xmlInitializeCatalog();
   18|      2|#endif
   19|      2|    xmlSetGenericErrorFunc(NULL, xmlFuzzErrorFunc);
   20|      2|    xmlSetExternalEntityLoader(xmlFuzzEntityLoader);
   21|       |
   22|      2|    return 0;
   23|      2|}
LLVMFuzzerTestOneInput:
   26|    198|LLVMFuzzerTestOneInput(const char *data, size_t size) {
   27|    198|    xmlSchemaParserCtxtPtr pctxt;
   28|    198|    size_t maxAlloc;
   29|       |
   30|    198|    if (size > 50000)
  ------------------
  |  Branch (30:9): [True: 0, False: 198]
  ------------------
   31|      0|        return(0);
   32|       |
   33|    198|    maxAlloc = xmlFuzzReadInt(4) % (size + 1);
   34|       |
   35|    198|    xmlFuzzDataInit(data, size);
   36|    198|    xmlFuzzReadEntities();
   37|       |
   38|    198|    xmlFuzzMemSetLimit(maxAlloc);
   39|    198|    pctxt = xmlSchemaNewParserCtxt(xmlFuzzMainUrl());
   40|    198|    xmlSchemaSetParserErrors(pctxt, xmlFuzzErrorFunc, xmlFuzzErrorFunc, NULL);
   41|    198|    xmlSchemaFree(xmlSchemaParse(pctxt));
   42|    198|    xmlSchemaFreeParserCtxt(pctxt);
   43|       |
   44|    198|    xmlFuzzMemSetLimit(0);
   45|    198|    xmlFuzzDataCleanup();
   46|    198|    xmlResetLastError();
   47|       |
   48|    198|    return(0);
   49|    198|}

xmlInitGlobalsInternal:
  566|      2|void xmlInitGlobalsInternal(void) {
  567|      2|    xmlInitMutex(&xmlThrDefMutex);
  568|       |
  569|      2|#ifdef HAVE_POSIX_THREADS
  570|      2|#ifdef XML_PTHREAD_WEAK
  571|      2|    if (libxml_is_threaded == -1)
  ------------------
  |  Branch (571:9): [True: 2, False: 0]
  ------------------
  572|      2|        libxml_is_threaded =
  573|      2|            (pthread_getspecific != NULL) &&
  ------------------
  |  Branch (573:13): [True: 2, False: 0]
  ------------------
  574|      2|            (pthread_setspecific != NULL) &&
  ------------------
  |  Branch (574:13): [True: 2, False: 0]
  ------------------
  575|      2|            (pthread_key_create != NULL) &&
  ------------------
  |  Branch (575:13): [True: 2, False: 0]
  ------------------
  576|      2|            (pthread_key_delete != NULL) &&
  ------------------
  |  Branch (576:13): [True: 2, False: 0]
  ------------------
  577|       |            /*
  578|       |             * pthread_equal can be inline, resuting in -Waddress warnings.
  579|       |             * Let's assume it's available if all the other functions are.
  580|       |             */
  581|       |            /* (pthread_equal != NULL) && */
  582|      2|            (pthread_self != NULL);
  ------------------
  |  Branch (582:13): [True: 2, False: 0]
  ------------------
  583|      2|    if (libxml_is_threaded == 0)
  ------------------
  |  Branch (583:9): [True: 0, False: 2]
  ------------------
  584|      0|        return;
  585|      2|#endif /* XML_PTHREAD_WEAK */
  586|      2|    pthread_key_create(&globalkey, xmlFreeGlobalState);
  587|      2|    mainthread = pthread_self();
  588|       |#elif defined(HAVE_WIN32_THREADS)
  589|       |#ifndef USE_TLS
  590|       |    globalkey = TlsAlloc();
  591|       |#endif
  592|       |    mainthread = GetCurrentThreadId();
  593|       |#endif
  594|      2|}
__xmlLastError:
  892|    947|    type *__##name(void) { \
  893|    947|        if (IS_MAIN_THREAD) \
  ------------------
  |  |   62|    947|#define IS_MAIN_THREAD (xmlIsMainThreadInternal())
  |  |  ------------------
  |  |  |  Branch (62:24): [True: 947, False: 0]
  |  |  ------------------
  ------------------
  894|    947|            return (&name); \
  895|    947|        else \
  896|    947|            return (&xmlGetThreadLocalStorage(0)->gs_##name); \
  897|    947|    }
__xmlGenericError:
  892|    122|    type *__##name(void) { \
  893|    122|        if (IS_MAIN_THREAD) \
  ------------------
  |  |   62|    122|#define IS_MAIN_THREAD (xmlIsMainThreadInternal())
  |  |  ------------------
  |  |  |  Branch (62:24): [True: 122, False: 0]
  |  |  ------------------
  ------------------
  894|    122|            return (&name); \
  895|    122|        else \
  896|    122|            return (&xmlGetThreadLocalStorage(0)->gs_##name); \
  897|    122|    }
__xmlGenericErrorContext:
  892|    122|    type *__##name(void) { \
  893|    122|        if (IS_MAIN_THREAD) \
  ------------------
  |  |   62|    122|#define IS_MAIN_THREAD (xmlIsMainThreadInternal())
  |  |  ------------------
  |  |  |  Branch (62:24): [True: 122, False: 0]
  |  |  ------------------
  ------------------
  894|    122|            return (&name); \
  895|    122|        else \
  896|    122|            return (&xmlGetThreadLocalStorage(0)->gs_##name); \
  897|    122|    }
__xmlStructuredError:
  892|    364|    type *__##name(void) { \
  893|    364|        if (IS_MAIN_THREAD) \
  ------------------
  |  |   62|    364|#define IS_MAIN_THREAD (xmlIsMainThreadInternal())
  |  |  ------------------
  |  |  |  Branch (62:24): [True: 364, False: 0]
  |  |  ------------------
  ------------------
  894|    364|            return (&name); \
  895|    364|        else \
  896|    364|            return (&xmlGetThreadLocalStorage(0)->gs_##name); \
  897|    364|    }
__xmlDefaultSAXLocator:
  892|    238|    type *__##name(void) { \
  893|    238|        if (IS_MAIN_THREAD) \
  ------------------
  |  |   62|    238|#define IS_MAIN_THREAD (xmlIsMainThreadInternal())
  |  |  ------------------
  |  |  |  Branch (62:24): [True: 238, False: 0]
  |  |  ------------------
  ------------------
  894|    238|            return (&name); \
  895|    238|        else \
  896|    238|            return (&xmlGetThreadLocalStorage(0)->gs_##name); \
  897|    238|    }
__xmlDoValidityCheckingDefaultValue:
  892|    242|    type *__##name(void) { \
  893|    242|        if (IS_MAIN_THREAD) \
  ------------------
  |  |   62|    242|#define IS_MAIN_THREAD (xmlIsMainThreadInternal())
  |  |  ------------------
  |  |  |  Branch (62:24): [True: 242, False: 0]
  |  |  ------------------
  ------------------
  894|    242|            return (&name); \
  895|    242|        else \
  896|    242|            return (&xmlGetThreadLocalStorage(0)->gs_##name); \
  897|    242|    }
__xmlGetWarningsDefaultValue:
  892|    244|    type *__##name(void) { \
  893|    244|        if (IS_MAIN_THREAD) \
  ------------------
  |  |   62|    244|#define IS_MAIN_THREAD (xmlIsMainThreadInternal())
  |  |  ------------------
  |  |  |  Branch (62:24): [True: 244, False: 0]
  |  |  ------------------
  ------------------
  894|    244|            return (&name); \
  895|    244|        else \
  896|    244|            return (&xmlGetThreadLocalStorage(0)->gs_##name); \
  897|    244|    }
__xmlKeepBlanksDefaultValue:
  892|    242|    type *__##name(void) { \
  893|    242|        if (IS_MAIN_THREAD) \
  ------------------
  |  |   62|    242|#define IS_MAIN_THREAD (xmlIsMainThreadInternal())
  |  |  ------------------
  |  |  |  Branch (62:24): [True: 242, False: 0]
  |  |  ------------------
  ------------------
  894|    242|            return (&name); \
  895|    242|        else \
  896|    242|            return (&xmlGetThreadLocalStorage(0)->gs_##name); \
  897|    242|    }
__xmlLineNumbersDefaultValue:
  892|    242|    type *__##name(void) { \
  893|    242|        if (IS_MAIN_THREAD) \
  ------------------
  |  |   62|    242|#define IS_MAIN_THREAD (xmlIsMainThreadInternal())
  |  |  ------------------
  |  |  |  Branch (62:24): [True: 242, False: 0]
  |  |  ------------------
  ------------------
  894|    242|            return (&name); \
  895|    242|        else \
  896|    242|            return (&xmlGetThreadLocalStorage(0)->gs_##name); \
  897|    242|    }
__xmlLoadExtDtdDefaultValue:
  892|    242|    type *__##name(void) { \
  893|    242|        if (IS_MAIN_THREAD) \
  ------------------
  |  |   62|    242|#define IS_MAIN_THREAD (xmlIsMainThreadInternal())
  |  |  ------------------
  |  |  |  Branch (62:24): [True: 242, False: 0]
  |  |  ------------------
  ------------------
  894|    242|            return (&name); \
  895|    242|        else \
  896|    242|            return (&xmlGetThreadLocalStorage(0)->gs_##name); \
  897|    242|    }
__xmlPedanticParserDefaultValue:
  892|    242|    type *__##name(void) { \
  893|    242|        if (IS_MAIN_THREAD) \
  ------------------
  |  |   62|    242|#define IS_MAIN_THREAD (xmlIsMainThreadInternal())
  |  |  ------------------
  |  |  |  Branch (62:24): [True: 242, False: 0]
  |  |  ------------------
  ------------------
  894|    242|            return (&name); \
  895|    242|        else \
  896|    242|            return (&xmlGetThreadLocalStorage(0)->gs_##name); \
  897|    242|    }
__xmlSubstituteEntitiesDefaultValue:
  892|    242|    type *__##name(void) { \
  893|    242|        if (IS_MAIN_THREAD) \
  ------------------
  |  |   62|    242|#define IS_MAIN_THREAD (xmlIsMainThreadInternal())
  |  |  ------------------
  |  |  |  Branch (62:24): [True: 242, False: 0]
  |  |  ------------------
  ------------------
  894|    242|            return (&name); \
  895|    242|        else \
  896|    242|            return (&xmlGetThreadLocalStorage(0)->gs_##name); \
  897|    242|    }
__xmlDefaultSAXHandler:
  892|    242|    type *__##name(void) { \
  893|    242|        if (IS_MAIN_THREAD) \
  ------------------
  |  |   62|    242|#define IS_MAIN_THREAD (xmlIsMainThreadInternal())
  |  |  ------------------
  |  |  |  Branch (62:24): [True: 242, False: 0]
  |  |  ------------------
  ------------------
  894|    242|            return (&name); \
  895|    242|        else \
  896|    242|            return (&xmlGetThreadLocalStorage(0)->gs_##name); \
  897|    242|    }
__xmlBufferAllocScheme:
  892|    290|    type *__##name(void) { \
  893|    290|        if (IS_MAIN_THREAD) \
  ------------------
  |  |   62|    290|#define IS_MAIN_THREAD (xmlIsMainThreadInternal())
  |  |  ------------------
  |  |  |  Branch (62:24): [True: 290, False: 0]
  |  |  ------------------
  ------------------
  894|    290|            return (&name); \
  895|    290|        else \
  896|    290|            return (&xmlGetThreadLocalStorage(0)->gs_##name); \
  897|    290|    }
__xmlDefaultBufferSize:
  892|    290|    type *__##name(void) { \
  893|    290|        if (IS_MAIN_THREAD) \
  ------------------
  |  |   62|    290|#define IS_MAIN_THREAD (xmlIsMainThreadInternal())
  |  |  ------------------
  |  |  |  Branch (62:24): [True: 290, False: 0]
  |  |  ------------------
  ------------------
  894|    290|            return (&name); \
  895|    290|        else \
  896|    290|            return (&xmlGetThreadLocalStorage(0)->gs_##name); \
  897|    290|    }
globals.c:xmlIsMainThreadInternal:
  660|  4.31k|xmlIsMainThreadInternal(void) {
  661|  4.31k|    if (parserInitialized == 0) {
  ------------------
  |  Branch (661:9): [True: 2, False: 4.30k]
  ------------------
  662|      2|        xmlInitParser();
  663|      2|        parserInitialized = 1;
  664|      2|    }
  665|       |
  666|  4.31k|#ifdef HAVE_POSIX_THREADS
  667|  4.31k|#ifdef XML_PTHREAD_WEAK
  668|  4.31k|    if (libxml_is_threaded == 0)
  ------------------
  |  Branch (668:9): [True: 0, False: 4.31k]
  ------------------
  669|      0|        return (1);
  670|  4.31k|#endif
  671|  4.31k|    return (pthread_equal(mainthread, pthread_self()));
  672|       |#elif defined HAVE_WIN32_THREADS
  673|       |    return (mainthread == GetCurrentThreadId());
  674|       |#else
  675|       |    return (1);
  676|       |#endif
  677|  4.31k|}

xmlHashCreate:
  160|    641|xmlHashCreate(int size) {
  161|    641|    xmlHashTablePtr hash;
  162|       |
  163|    641|    xmlInitParser();
  164|       |
  165|    641|    hash = xmlMalloc(sizeof(*hash));
  166|    641|    if (hash == NULL)
  ------------------
  |  Branch (166:9): [True: 0, False: 641]
  ------------------
  167|      0|        return(NULL);
  168|    641|    hash->dict = NULL;
  169|    641|    hash->size = 0;
  170|    641|    hash->table = NULL;
  171|    641|    hash->nbElems = 0;
  172|    641|    hash->randomSeed = xmlRandom();
  173|    641|#ifdef FUZZING_BUILD_MODE_UNSAFE_FOR_PRODUCTION
  174|    641|    hash->randomSeed = 0;
  175|    641|#endif
  176|       |
  177|       |    /*
  178|       |     * Unless a larger size is passed, the backing table is created
  179|       |     * lazily with MIN_HASH_SIZE capacity. In practice, there are many
  180|       |     * hash tables which are never filled.
  181|       |     */
  182|    641|    if (size > MIN_HASH_SIZE) {
  ------------------
  |  |   30|    641|#define MIN_HASH_SIZE 8
  ------------------
  |  Branch (182:9): [True: 271, False: 370]
  ------------------
  183|    271|        unsigned newSize = MIN_HASH_SIZE * 2;
  ------------------
  |  |   30|    271|#define MIN_HASH_SIZE 8
  ------------------
  184|       |
  185|    273|        while ((newSize < (unsigned) size) && (newSize < MAX_HASH_SIZE))
  ------------------
  |  |   31|      2|#define MAX_HASH_SIZE (1u << 31)
  ------------------
  |  Branch (185:16): [True: 2, False: 271]
  |  Branch (185:47): [True: 2, False: 0]
  ------------------
  186|      2|            newSize *= 2;
  187|       |
  188|    271|        if (xmlHashGrow(hash, newSize) != 0) {
  ------------------
  |  Branch (188:13): [True: 0, False: 271]
  ------------------
  189|      0|            xmlFree(hash);
  190|      0|            return(NULL);
  191|      0|        }
  192|    271|    }
  193|       |
  194|    641|    return(hash);
  195|    641|}
xmlHashCreateDict:
  209|    442|xmlHashCreateDict(int size, xmlDictPtr dict) {
  210|    442|    xmlHashTablePtr hash;
  211|       |
  212|    442|    hash = xmlHashCreate(size);
  213|    442|    if (hash != NULL) {
  ------------------
  |  Branch (213:9): [True: 442, False: 0]
  ------------------
  214|    442|        hash->dict = dict;
  215|    442|        xmlDictReference(dict);
  216|    442|    }
  217|    442|    return(hash);
  218|    442|}
xmlHashFree:
  229|    640|xmlHashFree(xmlHashTablePtr hash, xmlHashDeallocator dealloc) {
  230|    640|    if (hash == NULL)
  ------------------
  |  Branch (230:9): [True: 0, False: 640]
  ------------------
  231|      0|        return;
  232|       |
  233|    640|    if (hash->table) {
  ------------------
  |  Branch (233:9): [True: 640, False: 0]
  ------------------
  234|    640|        const xmlHashEntry *end = &hash->table[hash->size];
  235|    640|        const xmlHashEntry *entry;
  236|       |
  237|  8.05k|        for (entry = hash->table; entry < end; entry++) {
  ------------------
  |  Branch (237:35): [True: 7.41k, False: 640]
  ------------------
  238|  7.41k|            if (entry->hashValue == 0)
  ------------------
  |  Branch (238:17): [True: 6.32k, False: 1.08k]
  ------------------
  239|  6.32k|                continue;
  240|  1.08k|            if ((dealloc != NULL) && (entry->payload != NULL))
  ------------------
  |  Branch (240:17): [True: 452, False: 636]
  |  Branch (240:38): [True: 452, False: 0]
  ------------------
  241|    452|                dealloc(entry->payload, entry->key);
  242|  1.08k|            if (hash->dict == NULL) {
  ------------------
  |  Branch (242:17): [True: 246, False: 842]
  ------------------
  243|    246|                if (entry->key)
  ------------------
  |  Branch (243:21): [True: 246, False: 0]
  ------------------
  244|    246|                    xmlFree(entry->key);
  245|    246|                if (entry->key2)
  ------------------
  |  Branch (245:21): [True: 0, False: 246]
  ------------------
  246|      0|                    xmlFree(entry->key2);
  247|    246|                if (entry->key3)
  ------------------
  |  Branch (247:21): [True: 0, False: 246]
  ------------------
  248|      0|                    xmlFree(entry->key3);
  249|    246|            }
  250|  1.08k|        }
  251|       |
  252|    640|        xmlFree(hash->table);
  253|    640|    }
  254|       |
  255|    640|    if (hash->dict)
  ------------------
  |  Branch (255:9): [True: 442, False: 198]
  ------------------
  256|    442|        xmlDictFree(hash->dict);
  257|       |
  258|    640|    xmlFree(hash);
  259|    640|}
xmlHashDefaultDeallocator:
  603|    246|xmlHashDefaultDeallocator(void *entry, const xmlChar *key ATTRIBUTE_UNUSED) {
  604|    246|    xmlFree(entry);
  605|    246|}
xmlHashAddEntry:
  621|  1.08k|xmlHashAddEntry(xmlHashTablePtr hash, const xmlChar *key, void *payload) {
  622|  1.08k|    return(xmlHashUpdateInternal(hash, key, NULL, NULL, payload, NULL, 0));
  623|  1.08k|}
xmlHashAddEntry2:
  640|     52|                 const xmlChar *key2, void *payload) {
  641|     52|    return(xmlHashUpdateInternal(hash, key, key2, NULL, payload, NULL, 0));
  642|     52|}
xmlHashLookup:
  739|  1.15k|xmlHashLookup(xmlHashTablePtr hash, const xmlChar *key) {
  740|  1.15k|    return(xmlHashLookup3(hash, key, NULL, NULL));
  741|  1.15k|}
xmlHashLookup2:
  755|    431|              const xmlChar *key2) {
  756|    431|    return(xmlHashLookup3(hash, key, key2, NULL));
  757|    431|}
xmlHashLookup3:
  807|  1.58k|               const xmlChar *key2, const xmlChar *key3) {
  808|  1.58k|    const xmlHashEntry *entry;
  809|  1.58k|    unsigned hashValue;
  810|  1.58k|    int found;
  811|       |
  812|  1.58k|    if ((hash == NULL) || (hash->size == 0) || (key == NULL))
  ------------------
  |  Branch (812:9): [True: 10, False: 1.57k]
  |  Branch (812:27): [True: 198, False: 1.37k]
  |  Branch (812:48): [True: 0, False: 1.37k]
  ------------------
  813|    208|        return(NULL);
  814|  1.37k|    hashValue = xmlHashValue(hash->randomSeed, key, key2, key3, NULL);
  815|  1.37k|    entry = xmlHashFindEntry(hash, key, key2, key3, hashValue, &found);
  816|  1.37k|    if (found)
  ------------------
  |  Branch (816:9): [True: 1.32k, False: 55]
  ------------------
  817|  1.32k|        return(entry->payload);
  818|     55|    return(NULL);
  819|  1.37k|}
xmlHashSize:
 1033|     58|xmlHashSize(xmlHashTablePtr hash) {
 1034|     58|    if (hash == NULL)
  ------------------
  |  Branch (1034:9): [True: 0, False: 58]
  ------------------
 1035|      0|        return(-1);
 1036|     58|    return(hash->nbElems);
 1037|     58|}
hash.c:xmlHashGrow:
  354|    649|xmlHashGrow(xmlHashTablePtr hash, unsigned size) {
  355|    649|    const xmlHashEntry *oldentry, *oldend, *end;
  356|    649|    xmlHashEntry *table;
  357|    649|    unsigned oldsize, i;
  358|       |
  359|       |    /* Add 0 to avoid spurious -Wtype-limits warning on 64-bit GCC */
  360|    649|    if ((size_t) size + 0 > SIZE_MAX / sizeof(table[0]))
  ------------------
  |  |   25|    649|  #define SIZE_MAX ((size_t) -1)
  ------------------
  |  Branch (360:9): [True: 0, False: 649]
  ------------------
  361|      0|        return(-1);
  362|    649|    table = xmlMalloc(size * sizeof(table[0]));
  363|    649|    if (table == NULL)
  ------------------
  |  Branch (363:9): [True: 0, False: 649]
  ------------------
  364|      0|        return(-1);
  365|    649|    memset(table, 0, size * sizeof(table[0]));
  366|       |
  367|    649|    oldsize = hash->size;
  368|    649|    if (oldsize == 0)
  ------------------
  |  Branch (368:9): [True: 641, False: 8]
  ------------------
  369|    641|        goto done;
  370|       |
  371|      8|    oldend = &hash->table[oldsize];
  372|      8|    end = &table[size];
  373|       |
  374|       |    /*
  375|       |     * Robin Hood sorting order is maintained if we
  376|       |     *
  377|       |     * - compute hash indices with modulo
  378|       |     * - resize by an integer factor
  379|       |     * - start to copy from the beginning of a probe sequence
  380|       |     */
  381|      8|    oldentry = hash->table;
  382|     61|    while (oldentry->hashValue != 0) {
  ------------------
  |  Branch (382:12): [True: 53, False: 8]
  ------------------
  383|     53|        if (++oldentry >= oldend)
  ------------------
  |  Branch (383:13): [True: 0, False: 53]
  ------------------
  384|      0|            oldentry = hash->table;
  385|     53|    }
  386|       |
  387|    144|    for (i = 0; i < oldsize; i++) {
  ------------------
  |  Branch (387:17): [True: 136, False: 8]
  ------------------
  388|    136|        if (oldentry->hashValue != 0) {
  ------------------
  |  Branch (388:13): [True: 119, False: 17]
  ------------------
  389|    119|            xmlHashEntry *entry = &table[oldentry->hashValue & (size - 1)];
  390|       |
  391|    166|            while (entry->hashValue != 0) {
  ------------------
  |  Branch (391:20): [True: 47, False: 119]
  ------------------
  392|     47|                if (++entry >= end)
  ------------------
  |  Branch (392:21): [True: 1, False: 46]
  ------------------
  393|      1|                    entry = table;
  394|     47|            }
  395|    119|            *entry = *oldentry;
  396|    119|        }
  397|       |
  398|    136|        if (++oldentry >= oldend)
  ------------------
  |  Branch (398:13): [True: 8, False: 128]
  ------------------
  399|      8|            oldentry = hash->table;
  400|    136|    }
  401|       |
  402|      8|    xmlFree(hash->table);
  403|       |
  404|    649|done:
  405|    649|    hash->table = table;
  406|    649|    hash->size = size;
  407|       |
  408|    649|    return(0);
  409|      8|}
hash.c:xmlHashUpdateInternal:
  427|  1.13k|                      void *payload, xmlHashDeallocator dealloc, int update) {
  428|  1.13k|    xmlChar *copy, *copy2, *copy3;
  429|  1.13k|    xmlHashEntry *entry = NULL;
  430|  1.13k|    size_t lengths[3];
  431|  1.13k|    unsigned hashValue;
  432|  1.13k|    int found = 0;
  433|       |
  434|  1.13k|    if ((hash == NULL) || (key == NULL))
  ------------------
  |  Branch (434:9): [True: 0, False: 1.13k]
  |  Branch (434:27): [True: 0, False: 1.13k]
  ------------------
  435|      0|        return(-1);
  436|       |
  437|       |    /*
  438|       |     * Check for an existing entry
  439|       |     */
  440|  1.13k|    hashValue = xmlHashValue(hash->randomSeed, key, key2, key3, lengths);
  441|  1.13k|    if (hash->size > 0)
  ------------------
  |  Branch (441:9): [True: 765, False: 370]
  ------------------
  442|    765|        entry = xmlHashFindEntry(hash, key, key2, key3, hashValue, &found);
  443|  1.13k|    if (found) {
  ------------------
  |  Branch (443:9): [True: 1, False: 1.13k]
  ------------------
  444|      1|        if (update) {
  ------------------
  |  Branch (444:13): [True: 0, False: 1]
  ------------------
  445|      0|            if (dealloc)
  ------------------
  |  Branch (445:17): [True: 0, False: 0]
  ------------------
  446|      0|                dealloc(entry->payload, entry->key);
  447|      0|            entry->payload = payload;
  448|      0|            return(0);
  449|      1|        } else {
  450|       |            /*
  451|       |             * xmlHashAddEntry found an existing entry.
  452|       |             *
  453|       |             * TODO: We should return a different error code here to
  454|       |             * distinguish from malloc failures.
  455|       |             */
  456|      1|            return(-1);
  457|      1|        }
  458|      1|    }
  459|       |
  460|       |    /*
  461|       |     * Grow the hash table if needed
  462|       |     */
  463|  1.13k|    if (hash->nbElems + 1 > hash->size / MAX_FILL_DENOM * MAX_FILL_NUM) {
  ------------------
  |  |   29|  1.13k|#define MAX_FILL_DENOM 8
  ------------------
                  if (hash->nbElems + 1 > hash->size / MAX_FILL_DENOM * MAX_FILL_NUM) {
  ------------------
  |  |   28|  1.13k|#define MAX_FILL_NUM 7
  ------------------
  |  Branch (463:9): [True: 378, False: 756]
  ------------------
  464|    378|        unsigned newSize, mask, displ, pos;
  465|       |
  466|    378|        if (hash->size == 0) {
  ------------------
  |  Branch (466:13): [True: 370, False: 8]
  ------------------
  467|    370|            newSize = MIN_HASH_SIZE;
  ------------------
  |  |   30|    370|#define MIN_HASH_SIZE 8
  ------------------
  468|    370|        } else {
  469|       |            /* This guarantees that nbElems < INT_MAX */
  470|      8|            if (hash->size >= MAX_HASH_SIZE)
  ------------------
  |  |   31|      8|#define MAX_HASH_SIZE (1u << 31)
  ------------------
  |  Branch (470:17): [True: 0, False: 8]
  ------------------
  471|      0|                return(-1);
  472|      8|            newSize = hash->size * 2;
  473|      8|        }
  474|    378|        if (xmlHashGrow(hash, newSize) != 0)
  ------------------
  |  Branch (474:13): [True: 0, False: 378]
  ------------------
  475|      0|            return(-1);
  476|       |
  477|       |        /*
  478|       |         * Find new entry
  479|       |         */
  480|    378|        mask = hash->size - 1;
  481|    378|        displ = 0;
  482|    378|        pos = hashValue & mask;
  483|    378|        entry = &hash->table[pos];
  484|       |
  485|    378|        if (entry->hashValue != 0) {
  ------------------
  |  Branch (485:13): [True: 6, False: 372]
  ------------------
  486|      9|            do {
  487|      9|                displ++;
  488|      9|                pos++;
  489|      9|                entry++;
  490|      9|                if ((pos & mask) == 0)
  ------------------
  |  Branch (490:21): [True: 1, False: 8]
  ------------------
  491|      1|                    entry = hash->table;
  492|      9|            } while ((entry->hashValue != 0) &&
  ------------------
  |  Branch (492:22): [True: 4, False: 5]
  ------------------
  493|      9|                     ((pos - entry->hashValue) & mask) >= displ);
  ------------------
  |  Branch (493:22): [True: 3, False: 1]
  ------------------
  494|      6|        }
  495|    378|    }
  496|       |
  497|       |    /*
  498|       |     * Copy keys
  499|       |     */
  500|  1.13k|    if (hash->dict != NULL) {
  ------------------
  |  Branch (500:9): [True: 842, False: 292]
  ------------------
  501|    842|        if (xmlDictOwns(hash->dict, key)) {
  ------------------
  |  Branch (501:13): [True: 752, False: 90]
  ------------------
  502|    752|            copy = (xmlChar *) key;
  503|    752|        } else {
  504|     90|            copy = (xmlChar *) xmlDictLookup(hash->dict, key, -1);
  505|     90|            if (copy == NULL)
  ------------------
  |  Branch (505:17): [True: 0, False: 90]
  ------------------
  506|      0|                return(-1);
  507|     90|        }
  508|       |
  509|    842|        if ((key2 == NULL) || (xmlDictOwns(hash->dict, key2))) {
  ------------------
  |  Branch (509:13): [True: 837, False: 5]
  |  Branch (509:31): [True: 5, False: 0]
  ------------------
  510|    842|            copy2 = (xmlChar *) key2;
  511|    842|        } else {
  512|      0|            copy2 = (xmlChar *) xmlDictLookup(hash->dict, key2, -1);
  513|      0|            if (copy2 == NULL)
  ------------------
  |  Branch (513:17): [True: 0, False: 0]
  ------------------
  514|      0|                return(-1);
  515|      0|        }
  516|    842|        if ((key3 == NULL) || (xmlDictOwns(hash->dict, key3))) {
  ------------------
  |  Branch (516:13): [True: 842, False: 0]
  |  Branch (516:31): [True: 0, False: 0]
  ------------------
  517|    842|            copy3 = (xmlChar *) key3;
  518|    842|        } else {
  519|      0|            copy3 = (xmlChar *) xmlDictLookup(hash->dict, key3, -1);
  520|      0|            if (copy3 == NULL)
  ------------------
  |  Branch (520:17): [True: 0, False: 0]
  ------------------
  521|      0|                return(-1);
  522|      0|        }
  523|    842|    } else {
  524|    292|        copy = xmlMalloc(lengths[0] + 1);
  525|    292|        if (copy == NULL)
  ------------------
  |  Branch (525:13): [True: 0, False: 292]
  ------------------
  526|      0|            return(-1);
  527|    292|        memcpy(copy, key, lengths[0] + 1);
  528|       |
  529|    292|        if (key2 != NULL) {
  ------------------
  |  Branch (529:13): [True: 46, False: 246]
  ------------------
  530|     46|            copy2 = xmlMalloc(lengths[1] + 1);
  531|     46|            if (copy2 == NULL) {
  ------------------
  |  Branch (531:17): [True: 0, False: 46]
  ------------------
  532|      0|                xmlFree(copy);
  533|      0|                return(-1);
  534|      0|            }
  535|     46|            memcpy(copy2, key2, lengths[1] + 1);
  536|    246|        } else {
  537|    246|            copy2 = NULL;
  538|    246|        }
  539|       |
  540|    292|        if (key3 != NULL) {
  ------------------
  |  Branch (540:13): [True: 0, False: 292]
  ------------------
  541|      0|            copy3 = xmlMalloc(lengths[2] + 1);
  542|      0|            if (copy3 == NULL) {
  ------------------
  |  Branch (542:17): [True: 0, False: 0]
  ------------------
  543|      0|                xmlFree(copy);
  544|      0|                xmlFree(copy2);
  545|      0|                return(-1);
  546|      0|            }
  547|      0|            memcpy(copy3, key3, lengths[2] + 1);
  548|    292|        } else {
  549|    292|            copy3 = NULL;
  550|    292|        }
  551|    292|    }
  552|       |
  553|       |    /*
  554|       |     * Shift the remainder of the probe sequence to the right
  555|       |     */
  556|  1.13k|    if (entry->hashValue != 0) {
  ------------------
  |  Branch (556:9): [True: 55, False: 1.07k]
  ------------------
  557|     55|        const xmlHashEntry *end = &hash->table[hash->size];
  558|     55|        const xmlHashEntry *cur = entry;
  559|       |
  560|    185|        do {
  561|    185|            cur++;
  562|    185|            if (cur >= end)
  ------------------
  |  Branch (562:17): [True: 7, False: 178]
  ------------------
  563|      7|                cur = hash->table;
  564|    185|        } while (cur->hashValue != 0);
  ------------------
  |  Branch (564:18): [True: 130, False: 55]
  ------------------
  565|       |
  566|     55|        if (cur < entry) {
  ------------------
  |  Branch (566:13): [True: 7, False: 48]
  ------------------
  567|       |            /*
  568|       |             * If we traversed the end of the buffer, handle the part
  569|       |             * at the start of the buffer.
  570|       |             */
  571|      7|            memmove(&hash->table[1], hash->table,
  572|      7|                    (char *) cur - (char *) hash->table);
  573|      7|            cur = end - 1;
  574|      7|            hash->table[0] = *cur;
  575|      7|        }
  576|       |
  577|     55|        memmove(&entry[1], entry, (char *) cur - (char *) entry);
  578|     55|    }
  579|       |
  580|       |    /*
  581|       |     * Populate entry
  582|       |     */
  583|  1.13k|    entry->key = copy;
  584|  1.13k|    entry->key2 = copy2;
  585|  1.13k|    entry->key3 = copy3;
  586|  1.13k|    entry->payload = payload;
  587|       |    /* OR with MAX_HASH_SIZE to make sure that the value is non-zero */
  588|  1.13k|    entry->hashValue = hashValue | MAX_HASH_SIZE;
  ------------------
  |  |   31|  1.13k|#define MAX_HASH_SIZE (1u << 31)
  ------------------
  589|       |
  590|  1.13k|    hash->nbElems++;
  591|       |
  592|  1.13k|    return(0);
  593|  1.13k|}
hash.c:xmlHashValue:
   62|  2.51k|             const xmlChar *key3, size_t *lengths) {
   63|  2.51k|    unsigned h1, h2;
   64|  2.51k|    size_t i;
   65|       |
   66|  2.51k|    HASH_INIT(h1, h2, seed);
  ------------------
  |  |   23|  2.51k|    do { \
  |  |   24|  2.51k|        h1 = seed ^ 0x3b00; \
  |  |   25|  2.51k|        h2 = HASH_ROL(seed, 15); \
  |  |  ------------------
  |  |  |  |   12|  2.51k|#define HASH_ROL(x,n) ((x) << (n) | ((x) & 0xFFFFFFFF) >> (32 - (n)))
  |  |  ------------------
  |  |   26|  2.51k|    } while (0)
  |  |  ------------------
  |  |  |  Branch (26:14): [Folded - Ignored]
  |  |  ------------------
  ------------------
   67|       |
   68|  22.6k|    for (i = 0; key[i] != 0; i++) {
  ------------------
  |  Branch (68:17): [True: 20.1k, False: 2.51k]
  ------------------
   69|  20.1k|        HASH_UPDATE(h1, h2, key[i]);
  ------------------
  |  |   29|  20.1k|    do { \
  |  |   30|  20.1k|        h1 += ch; \
  |  |   31|  20.1k|        h1 += h1 << 3; \
  |  |   32|  20.1k|        h2 += h1; \
  |  |   33|  20.1k|        h2 = HASH_ROL(h2, 7); \
  |  |  ------------------
  |  |  |  |   12|  20.1k|#define HASH_ROL(x,n) ((x) << (n) | ((x) & 0xFFFFFFFF) >> (32 - (n)))
  |  |  ------------------
  |  |   34|  20.1k|        h2 += h2 << 2; \
  |  |   35|  20.1k|    } while (0)
  |  |  ------------------
  |  |  |  Branch (35:14): [Folded - Ignored]
  |  |  ------------------
  ------------------
   70|  20.1k|    }
   71|  2.51k|    if (lengths)
  ------------------
  |  Branch (71:9): [True: 1.13k, False: 1.37k]
  ------------------
   72|  1.13k|        lengths[0] = i;
   73|       |
   74|  2.51k|    HASH_UPDATE(h1, h2, 0);
  ------------------
  |  |   29|  2.51k|    do { \
  |  |   30|  2.51k|        h1 += ch; \
  |  |   31|  2.51k|        h1 += h1 << 3; \
  |  |   32|  2.51k|        h2 += h1; \
  |  |   33|  2.51k|        h2 = HASH_ROL(h2, 7); \
  |  |  ------------------
  |  |  |  |   12|  2.51k|#define HASH_ROL(x,n) ((x) << (n) | ((x) & 0xFFFFFFFF) >> (32 - (n)))
  |  |  ------------------
  |  |   34|  2.51k|        h2 += h2 << 2; \
  |  |   35|  2.51k|    } while (0)
  |  |  ------------------
  |  |  |  Branch (35:14): [Folded - Ignored]
  |  |  ------------------
  ------------------
   75|       |
   76|  2.51k|    if (key2 != NULL) {
  ------------------
  |  Branch (76:9): [True: 481, False: 2.03k]
  ------------------
   77|  15.5k|        for (i = 0; key2[i] != 0; i++) {
  ------------------
  |  Branch (77:21): [True: 15.1k, False: 481]
  ------------------
   78|  15.1k|            HASH_UPDATE(h1, h2, key2[i]);
  ------------------
  |  |   29|  15.1k|    do { \
  |  |   30|  15.1k|        h1 += ch; \
  |  |   31|  15.1k|        h1 += h1 << 3; \
  |  |   32|  15.1k|        h2 += h1; \
  |  |   33|  15.1k|        h2 = HASH_ROL(h2, 7); \
  |  |  ------------------
  |  |  |  |   12|  15.1k|#define HASH_ROL(x,n) ((x) << (n) | ((x) & 0xFFFFFFFF) >> (32 - (n)))
  |  |  ------------------
  |  |   34|  15.1k|        h2 += h2 << 2; \
  |  |   35|  15.1k|    } while (0)
  |  |  ------------------
  |  |  |  Branch (35:14): [Folded - Ignored]
  |  |  ------------------
  ------------------
   79|  15.1k|        }
   80|    481|        if (lengths)
  ------------------
  |  Branch (80:13): [True: 51, False: 430]
  ------------------
   81|     51|            lengths[1] = i;
   82|    481|    }
   83|       |
   84|  2.51k|    HASH_UPDATE(h1, h2, 0);
  ------------------
  |  |   29|  2.51k|    do { \
  |  |   30|  2.51k|        h1 += ch; \
  |  |   31|  2.51k|        h1 += h1 << 3; \
  |  |   32|  2.51k|        h2 += h1; \
  |  |   33|  2.51k|        h2 = HASH_ROL(h2, 7); \
  |  |  ------------------
  |  |  |  |   12|  2.51k|#define HASH_ROL(x,n) ((x) << (n) | ((x) & 0xFFFFFFFF) >> (32 - (n)))
  |  |  ------------------
  |  |   34|  2.51k|        h2 += h2 << 2; \
  |  |   35|  2.51k|    } while (0)
  |  |  ------------------
  |  |  |  Branch (35:14): [Folded - Ignored]
  |  |  ------------------
  ------------------
   85|       |
   86|  2.51k|    if (key3 != NULL) {
  ------------------
  |  Branch (86:9): [True: 0, False: 2.51k]
  ------------------
   87|      0|        for (i = 0; key3[i] != 0; i++) {
  ------------------
  |  Branch (87:21): [True: 0, False: 0]
  ------------------
   88|      0|            HASH_UPDATE(h1, h2, key3[i]);
  ------------------
  |  |   29|      0|    do { \
  |  |   30|      0|        h1 += ch; \
  |  |   31|      0|        h1 += h1 << 3; \
  |  |   32|      0|        h2 += h1; \
  |  |   33|      0|        h2 = HASH_ROL(h2, 7); \
  |  |  ------------------
  |  |  |  |   12|      0|#define HASH_ROL(x,n) ((x) << (n) | ((x) & 0xFFFFFFFF) >> (32 - (n)))
  |  |  ------------------
  |  |   34|      0|        h2 += h2 << 2; \
  |  |   35|      0|    } while (0)
  |  |  ------------------
  |  |  |  Branch (35:14): [Folded - Ignored]
  |  |  ------------------
  ------------------
   89|      0|        }
   90|      0|        if (lengths)
  ------------------
  |  Branch (90:13): [True: 0, False: 0]
  ------------------
   91|      0|            lengths[2] = i;
   92|      0|    }
   93|       |
   94|  2.51k|    HASH_FINISH(h1, h2);
  ------------------
  |  |   39|  2.51k|    do { \
  |  |   40|  2.51k|        h1 ^= h2; \
  |  |   41|  2.51k|        h1 += HASH_ROL(h2, 14); \
  |  |  ------------------
  |  |  |  |   12|  2.51k|#define HASH_ROL(x,n) ((x) << (n) | ((x) & 0xFFFFFFFF) >> (32 - (n)))
  |  |  ------------------
  |  |   42|  2.51k|        h2 ^= h1; h2 += HASH_ROR(h1, 6); \
  |  |  ------------------
  |  |  |  |   13|  2.51k|#define HASH_ROR(x,n) (((x) & 0xFFFFFFFF) >> (n) | (x) << (32 - (n)))
  |  |  ------------------
  |  |   43|  2.51k|        h1 ^= h2; h1 += HASH_ROL(h2, 5); \
  |  |  ------------------
  |  |  |  |   12|  2.51k|#define HASH_ROL(x,n) ((x) << (n) | ((x) & 0xFFFFFFFF) >> (32 - (n)))
  |  |  ------------------
  |  |   44|  2.51k|        h2 ^= h1; h2 += HASH_ROR(h1, 8); \
  |  |  ------------------
  |  |  |  |   13|  2.51k|#define HASH_ROR(x,n) (((x) & 0xFFFFFFFF) >> (n) | (x) << (32 - (n)))
  |  |  ------------------
  |  |   45|  2.51k|        h2 &= 0xFFFFFFFF; \
  |  |   46|  2.51k|    } while (0)
  |  |  ------------------
  |  |  |  Branch (46:14): [Folded - Ignored]
  |  |  ------------------
  ------------------
   95|       |
   96|  2.51k|    return(h2);
   97|  2.51k|}
hash.c:xmlHashFindEntry:
  294|  2.14k|                 unsigned hashValue, int *pfound) {
  295|  2.14k|    xmlHashEntry *entry;
  296|  2.14k|    unsigned mask, pos, displ;
  297|  2.14k|    int found = 0;
  298|       |
  299|  2.14k|    mask = hash->size - 1;
  300|  2.14k|    pos = hashValue & mask;
  301|  2.14k|    entry = &hash->table[pos];
  302|       |
  303|  2.14k|    if (entry->hashValue != 0) {
  ------------------
  |  Branch (303:9): [True: 1.48k, False: 662]
  ------------------
  304|       |        /*
  305|       |         * Robin hood hashing: abort if the displacement of the entry
  306|       |         * is smaller than the displacement of the key we look for.
  307|       |         * This also stops at the correct position when inserting.
  308|       |         */
  309|  1.48k|        displ = 0;
  310|  1.48k|        hashValue |= MAX_HASH_SIZE;
  ------------------
  |  |   31|  1.48k|#define MAX_HASH_SIZE (1u << 31)
  ------------------
  311|       |
  312|  2.09k|        do {
  313|  2.09k|            if (entry->hashValue == hashValue) {
  ------------------
  |  Branch (313:17): [True: 1.32k, False: 772]
  ------------------
  314|  1.32k|                if (hash->dict) {
  ------------------
  |  Branch (314:21): [True: 683, False: 642]
  ------------------
  315|    683|                    if ((entry->key == key) &&
  ------------------
  |  Branch (315:25): [True: 676, False: 7]
  ------------------
  316|    683|                        (entry->key2 == key2) &&
  ------------------
  |  Branch (316:25): [True: 676, False: 0]
  ------------------
  317|    683|                        (entry->key3 == key3)) {
  ------------------
  |  Branch (317:25): [True: 676, False: 0]
  ------------------
  318|    676|                        found = 1;
  319|    676|                        break;
  320|    676|                    }
  321|    683|                }
  322|    649|                if ((strcmp((const char *) entry->key,
  ------------------
  |  Branch (322:21): [True: 649, False: 0]
  ------------------
  323|    649|                            (const char *) key) == 0) &&
  324|    649|                    (xmlFastStrEqual(entry->key2, key2)) &&
  ------------------
  |  Branch (324:21): [True: 649, False: 0]
  ------------------
  325|    649|                    (xmlFastStrEqual(entry->key3, key3))) {
  ------------------
  |  Branch (325:21): [True: 649, False: 0]
  ------------------
  326|    649|                    found = 1;
  327|    649|                    break;
  328|    649|                }
  329|    649|            }
  330|       |
  331|    772|            displ++;
  332|    772|            pos++;
  333|    772|            entry++;
  334|    772|            if ((pos & mask) == 0)
  ------------------
  |  Branch (334:17): [True: 20, False: 752]
  ------------------
  335|     20|                entry = hash->table;
  336|    772|        } while ((entry->hashValue != 0) &&
  ------------------
  |  Branch (336:18): [True: 677, False: 95]
  ------------------
  337|    772|                 (((pos - entry->hashValue) & mask) >= displ));
  ------------------
  |  Branch (337:18): [True: 615, False: 62]
  ------------------
  338|  1.48k|    }
  339|       |
  340|      0|    *pfound = found;
  341|  2.14k|    return(entry);
  342|  2.14k|}
hash.c:xmlFastStrEqual:
  269|  1.29k|xmlFastStrEqual(const xmlChar *s1, const xmlChar *s2) {
  270|  1.29k|    if (s1 == NULL)
  ------------------
  |  Branch (270:9): [True: 894, False: 404]
  ------------------
  271|    894|        return(s2 == NULL);
  272|    404|    else
  273|    404|        return((s2 != NULL) &&
  ------------------
  |  Branch (273:16): [True: 404, False: 0]
  ------------------
  274|    404|               (strcmp((const char *) s1, (const char *) s2) == 0));
  ------------------
  |  Branch (274:16): [True: 404, False: 0]
  ------------------
  275|  1.29k|}

xmlParserNsCreate:
 1407|    242|xmlParserNsCreate(void) {
 1408|    242|    xmlParserNsData *nsdb = xmlMalloc(sizeof(*nsdb));
 1409|       |
 1410|    242|    if (nsdb == NULL)
  ------------------
  |  Branch (1410:9): [True: 0, False: 242]
  ------------------
 1411|      0|        return(NULL);
 1412|    242|    memset(nsdb, 0, sizeof(*nsdb));
 1413|    242|    nsdb->defaultNsIndex = INT_MAX;
 1414|       |
 1415|    242|    return(nsdb);
 1416|    242|}
xmlParserNsFree:
 1425|    242|xmlParserNsFree(xmlParserNsData *nsdb) {
 1426|    242|    if (nsdb == NULL)
  ------------------
  |  Branch (1426:9): [True: 0, False: 242]
  ------------------
 1427|      0|        return;
 1428|       |
 1429|    242|    xmlFree(nsdb->extra);
 1430|    242|    xmlFree(nsdb->hash);
 1431|    242|    xmlFree(nsdb);
 1432|    242|}
xmlParserNsLookupSax:
 1560|  3.35k|xmlParserNsLookupSax(xmlParserCtxtPtr ctxt, const xmlChar *prefix) {
 1561|  3.35k|    xmlHashedString hprefix;
 1562|  3.35k|    int nsIndex;
 1563|       |
 1564|  3.35k|    if (prefix == ctxt->str_xml)
  ------------------
  |  Branch (1564:9): [True: 24, False: 3.33k]
  ------------------
 1565|     24|        return(NULL);
 1566|       |
 1567|  3.33k|    hprefix.name = prefix;
 1568|  3.33k|    if (prefix != NULL)
  ------------------
  |  Branch (1568:9): [True: 3.11k, False: 222]
  ------------------
 1569|  3.11k|        hprefix.hashValue = xmlDictComputeHash(ctxt->dict, prefix);
 1570|    222|    else
 1571|    222|        hprefix.hashValue = 0;
 1572|  3.33k|    nsIndex = xmlParserNsLookup(ctxt, &hprefix, NULL);
 1573|  3.33k|    if (nsIndex == INT_MAX)
  ------------------
  |  Branch (1573:9): [True: 0, False: 3.33k]
  ------------------
 1574|      0|        return(NULL);
 1575|       |
 1576|  3.33k|    return(ctxt->nsdb->extra[nsIndex].saxData);
 1577|  3.33k|}
xmlParserNsUpdateSax:
 1593|    377|                     void *saxData) {
 1594|    377|    xmlHashedString hprefix;
 1595|    377|    int nsIndex;
 1596|       |
 1597|    377|    if (prefix == ctxt->str_xml)
  ------------------
  |  Branch (1597:9): [True: 0, False: 377]
  ------------------
 1598|      0|        return(-1);
 1599|       |
 1600|    377|    hprefix.name = prefix;
 1601|    377|    if (prefix != NULL)
  ------------------
  |  Branch (1601:9): [True: 309, False: 68]
  ------------------
 1602|    309|        hprefix.hashValue = xmlDictComputeHash(ctxt->dict, prefix);
 1603|     68|    else
 1604|     68|        hprefix.hashValue = 0;
 1605|    377|    nsIndex = xmlParserNsLookup(ctxt, &hprefix, NULL);
 1606|    377|    if (nsIndex == INT_MAX)
  ------------------
  |  Branch (1606:9): [True: 0, False: 377]
  ------------------
 1607|      0|        return(-1);
 1608|       |
 1609|    377|    ctxt->nsdb->extra[nsIndex].saxData = saxData;
 1610|    377|    return(0);
 1611|    377|}
inputPush:
 1893|    238|{
 1894|    238|    if ((ctxt == NULL) || (value == NULL))
  ------------------
  |  Branch (1894:9): [True: 0, False: 238]
  |  Branch (1894:27): [True: 0, False: 238]
  ------------------
 1895|      0|        return(-1);
 1896|    238|    if (ctxt->inputNr >= ctxt->inputMax) {
  ------------------
  |  Branch (1896:9): [True: 0, False: 238]
  ------------------
 1897|      0|        size_t newSize = ctxt->inputMax * 2;
 1898|      0|        xmlParserInputPtr *tmp;
 1899|       |
 1900|      0|        tmp = (xmlParserInputPtr *) xmlRealloc(ctxt->inputTab,
 1901|      0|                                               newSize * sizeof(*tmp));
 1902|      0|        if (tmp == NULL) {
  ------------------
  |  Branch (1902:13): [True: 0, False: 0]
  ------------------
 1903|      0|            xmlErrMemory(ctxt, NULL);
 1904|      0|            return (-1);
 1905|      0|        }
 1906|      0|        ctxt->inputTab = tmp;
 1907|      0|        ctxt->inputMax = newSize;
 1908|      0|    }
 1909|    238|    ctxt->inputTab[ctxt->inputNr] = value;
 1910|    238|    ctxt->input = value;
 1911|    238|    return (ctxt->inputNr++);
 1912|    238|}
inputPop:
 1923|    964|{
 1924|    964|    xmlParserInputPtr ret;
 1925|       |
 1926|    964|    if (ctxt == NULL)
  ------------------
  |  Branch (1926:9): [True: 0, False: 964]
  ------------------
 1927|      0|        return(NULL);
 1928|    964|    if (ctxt->inputNr <= 0)
  ------------------
  |  Branch (1928:9): [True: 726, False: 238]
  ------------------
 1929|    726|        return (NULL);
 1930|    238|    ctxt->inputNr--;
 1931|    238|    if (ctxt->inputNr > 0)
  ------------------
  |  Branch (1931:9): [True: 0, False: 238]
  ------------------
 1932|      0|        ctxt->input = ctxt->inputTab[ctxt->inputNr - 1];
 1933|    238|    else
 1934|    238|        ctxt->input = NULL;
 1935|    238|    ret = ctxt->inputTab[ctxt->inputNr];
 1936|    238|    ctxt->inputTab[ctxt->inputNr] = NULL;
 1937|    238|    return (ret);
 1938|    964|}
nodePush:
 1952|  3.54k|{
 1953|  3.54k|    if (ctxt == NULL) return(0);
  ------------------
  |  Branch (1953:9): [True: 0, False: 3.54k]
  ------------------
 1954|  3.54k|    if (ctxt->nodeNr >= ctxt->nodeMax) {
  ------------------
  |  Branch (1954:9): [True: 2, False: 3.54k]
  ------------------
 1955|      2|        xmlNodePtr *tmp;
 1956|       |
 1957|      2|	tmp = (xmlNodePtr *) xmlRealloc(ctxt->nodeTab,
 1958|      2|                                      ctxt->nodeMax * 2 *
 1959|      2|                                      sizeof(ctxt->nodeTab[0]));
 1960|      2|        if (tmp == NULL) {
  ------------------
  |  Branch (1960:13): [True: 0, False: 2]
  ------------------
 1961|      0|            xmlErrMemory(ctxt, NULL);
 1962|      0|            return (-1);
 1963|      0|        }
 1964|      2|        ctxt->nodeTab = tmp;
 1965|      2|	ctxt->nodeMax *= 2;
 1966|      2|    }
 1967|  3.54k|    if ((((unsigned int) ctxt->nodeNr) > xmlParserMaxDepth) &&
  ------------------
  |  Branch (1967:9): [True: 0, False: 3.54k]
  ------------------
 1968|  3.54k|        ((ctxt->options & XML_PARSE_HUGE) == 0)) {
  ------------------
  |  Branch (1968:9): [True: 0, False: 0]
  ------------------
 1969|      0|	xmlFatalErrMsgInt(ctxt, XML_ERR_INTERNAL_ERROR,
 1970|      0|		 "Excessive depth in document: %d use XML_PARSE_HUGE option\n",
 1971|      0|			  xmlParserMaxDepth);
 1972|      0|	xmlHaltParser(ctxt);
 1973|      0|	return(-1);
 1974|      0|    }
 1975|  3.54k|    ctxt->nodeTab[ctxt->nodeNr] = value;
 1976|  3.54k|    ctxt->node = value;
 1977|  3.54k|    return (ctxt->nodeNr++);
 1978|  3.54k|}
nodePop:
 1992|  3.49k|{
 1993|  3.49k|    xmlNodePtr ret;
 1994|       |
 1995|  3.49k|    if (ctxt == NULL) return(NULL);
  ------------------
  |  Branch (1995:9): [True: 0, False: 3.49k]
  ------------------
 1996|  3.49k|    if (ctxt->nodeNr <= 0)
  ------------------
  |  Branch (1996:9): [True: 3, False: 3.49k]
  ------------------
 1997|      3|        return (NULL);
 1998|  3.49k|    ctxt->nodeNr--;
 1999|  3.49k|    if (ctxt->nodeNr > 0)
  ------------------
  |  Branch (1999:9): [True: 3.27k, False: 212]
  ------------------
 2000|  3.27k|        ctxt->node = ctxt->nodeTab[ctxt->nodeNr - 1];
 2001|    212|    else
 2002|    212|        ctxt->node = NULL;
 2003|  3.49k|    ret = ctxt->nodeTab[ctxt->nodeNr];
 2004|  3.49k|    ctxt->nodeTab[ctxt->nodeNr] = NULL;
 2005|  3.49k|    return (ret);
 2006|  3.49k|}
namePop:
 2139|  3.72k|{
 2140|  3.72k|    const xmlChar *ret;
 2141|       |
 2142|  3.72k|    if ((ctxt == NULL) || (ctxt->nameNr <= 0))
  ------------------
  |  Branch (2142:9): [True: 0, False: 3.72k]
  |  Branch (2142:27): [True: 0, False: 3.72k]
  ------------------
 2143|      0|        return (NULL);
 2144|  3.72k|    ctxt->nameNr--;
 2145|  3.72k|    if (ctxt->nameNr > 0)
  ------------------
  |  Branch (2145:9): [True: 3.49k, False: 230]
  ------------------
 2146|  3.49k|        ctxt->name = ctxt->nameTab[ctxt->nameNr - 1];
 2147|    230|    else
 2148|    230|        ctxt->name = NULL;
 2149|  3.72k|    ret = ctxt->nameTab[ctxt->nameNr];
 2150|  3.72k|    ctxt->nameTab[ctxt->nameNr] = NULL;
 2151|  3.72k|    return (ret);
 2152|  3.72k|}
xmlSkipBlankChars:
 2311|  19.1k|xmlSkipBlankChars(xmlParserCtxtPtr ctxt) {
 2312|  19.1k|    int res = 0;
 2313|       |
 2314|       |    /*
 2315|       |     * It's Okay to use CUR/NEXT here since all the blanks are on
 2316|       |     * the ASCII range.
 2317|       |     */
 2318|  19.1k|    if (((ctxt->inputNr == 1) && (ctxt->instate != XML_PARSER_DTD)) ||
  ------------------
  |  Branch (2318:10): [True: 19.1k, False: 0]
  |  Branch (2318:34): [True: 19.1k, False: 0]
  ------------------
 2319|  19.1k|        (ctxt->instate == XML_PARSER_START)) {
  ------------------
  |  Branch (2319:9): [True: 0, False: 0]
  ------------------
 2320|  19.1k|	const xmlChar *cur;
 2321|       |	/*
 2322|       |	 * if we are in the document content, go really fast
 2323|       |	 */
 2324|  19.1k|	cur = ctxt->input->cur;
 2325|  19.1k|	while (IS_BLANK_CH(*cur)) {
 2326|  8.96k|	    if (*cur == '\n') {
  ------------------
  |  Branch (2326:10): [True: 1.00k, False: 7.96k]
  ------------------
 2327|  1.00k|		ctxt->input->line++; ctxt->input->col = 1;
 2328|  7.96k|	    } else {
 2329|  7.96k|		ctxt->input->col++;
 2330|  7.96k|	    }
 2331|  8.96k|	    cur++;
 2332|  8.96k|	    if (res < INT_MAX)
  ------------------
  |  Branch (2332:10): [True: 8.96k, False: 0]
  ------------------
 2333|  8.96k|		res++;
 2334|  8.96k|	    if (*cur == 0) {
  ------------------
  |  Branch (2334:10): [True: 186, False: 8.77k]
  ------------------
 2335|    186|		ctxt->input->cur = cur;
 2336|    186|		xmlParserGrow(ctxt);
 2337|    186|		cur = ctxt->input->cur;
 2338|    186|	    }
 2339|  8.96k|	}
 2340|  19.1k|	ctxt->input->cur = cur;
 2341|  19.1k|    } else {
 2342|      0|        int expandPE = ((ctxt->external != 0) || (ctxt->inputNr != 1));
  ------------------
  |  Branch (2342:25): [True: 0, False: 0]
  |  Branch (2342:50): [True: 0, False: 0]
  ------------------
 2343|       |
 2344|      0|	while (ctxt->instate != XML_PARSER_EOF) {
  ------------------
  |  Branch (2344:9): [True: 0, False: 0]
  ------------------
 2345|      0|            if (IS_BLANK_CH(CUR)) { /* CHECKED tstblanks.xml */
  ------------------
  |  |  151|      0|#define IS_BLANK_CH(c)  xmlIsBlank_ch(c)
  |  |  ------------------
  |  |  |  |   88|      0|#define xmlIsBlank_ch(c)	(((c) == 0x20) || \
  |  |  |  |  ------------------
  |  |  |  |  |  Branch (88:27): [True: 0, False: 0]
  |  |  |  |  ------------------
  |  |  |  |   89|      0|				 ((0x9 <= (c)) && ((c) <= 0xa)) || \
  |  |  |  |  ------------------
  |  |  |  |  |  Branch (89:7): [True: 0, False: 0]
  |  |  |  |  |  Branch (89:23): [True: 0, False: 0]
  |  |  |  |  ------------------
  |  |  |  |   90|      0|				 ((c) == 0xd))
  |  |  |  |  ------------------
  |  |  |  |  |  Branch (90:6): [True: 0, False: 0]
  |  |  |  |  ------------------
  |  |  ------------------
  ------------------
 2346|      0|		NEXT;
  ------------------
  |  | 2275|      0|#define NEXT xmlNextChar(ctxt)
  ------------------
 2347|      0|	    } else if (CUR == '%') {
  ------------------
  |  | 2222|      0|#define CUR (*ctxt->input->cur)
  ------------------
  |  Branch (2347:17): [True: 0, False: 0]
  ------------------
 2348|       |                /*
 2349|       |                 * Need to handle support of entities branching here
 2350|       |                 */
 2351|      0|	        if ((expandPE == 0) || (IS_BLANK_CH(NXT(1))) || (NXT(1) == 0))
  ------------------
  |  |  151|      0|#define IS_BLANK_CH(c)  xmlIsBlank_ch(c)
  |  |  ------------------
  |  |  |  |   88|      0|#define xmlIsBlank_ch(c)	(((c) == 0x20) || \
  |  |  |  |  ------------------
  |  |  |  |  |  Branch (88:27): [True: 0, False: 0]
  |  |  |  |  ------------------
  |  |  |  |   89|      0|				 ((0x9 <= (c)) && ((c) <= 0xa)) || \
  |  |  |  |  ------------------
  |  |  |  |  |  Branch (89:7): [True: 0, False: 0]
  |  |  |  |  |  Branch (89:23): [True: 0, False: 0]
  |  |  |  |  ------------------
  |  |  |  |   90|      0|				 ((c) == 0xd))
  |  |  |  |  ------------------
  |  |  |  |  |  Branch (90:6): [True: 0, False: 0]
  |  |  |  |  ------------------
  |  |  ------------------
  ------------------
              	        if ((expandPE == 0) || (IS_BLANK_CH(NXT(1))) || (NXT(1) == 0))
  ------------------
  |  | 2223|      0|#define NXT(val) ctxt->input->cur[(val)]
  ------------------
  |  Branch (2351:14): [True: 0, False: 0]
  |  Branch (2351:58): [True: 0, False: 0]
  ------------------
 2352|      0|                    break;
 2353|      0|	        xmlParsePEReference(ctxt);
 2354|      0|            } else if (CUR == 0) {
  ------------------
  |  | 2222|      0|#define CUR (*ctxt->input->cur)
  ------------------
  |  Branch (2354:24): [True: 0, False: 0]
  ------------------
 2355|      0|                unsigned long consumed;
 2356|      0|                xmlEntityPtr ent;
 2357|       |
 2358|      0|                if (ctxt->inputNr <= 1)
  ------------------
  |  Branch (2358:21): [True: 0, False: 0]
  ------------------
 2359|      0|                    break;
 2360|       |
 2361|      0|                consumed = ctxt->input->consumed;
 2362|      0|                xmlSaturatedAddSizeT(&consumed,
 2363|      0|                                     ctxt->input->cur - ctxt->input->base);
 2364|       |
 2365|       |                /*
 2366|       |                 * Add to sizeentities when parsing an external entity
 2367|       |                 * for the first time.
 2368|       |                 */
 2369|      0|                ent = ctxt->input->entity;
 2370|      0|                if ((ent->etype == XML_EXTERNAL_PARAMETER_ENTITY) &&
  ------------------
  |  Branch (2370:21): [True: 0, False: 0]
  ------------------
 2371|      0|                    ((ent->flags & XML_ENT_PARSED) == 0)) {
  ------------------
  |  |   14|      0|#define XML_ENT_PARSED      (1<<0)
  ------------------
  |  Branch (2371:21): [True: 0, False: 0]
  ------------------
 2372|      0|                    ent->flags |= XML_ENT_PARSED;
  ------------------
  |  |   14|      0|#define XML_ENT_PARSED      (1<<0)
  ------------------
 2373|       |
 2374|      0|                    xmlSaturatedAdd(&ctxt->sizeentities, consumed);
 2375|      0|                }
 2376|       |
 2377|      0|                xmlParserEntityCheck(ctxt, consumed);
 2378|       |
 2379|      0|                xmlPopInput(ctxt);
 2380|      0|            } else {
 2381|      0|                break;
 2382|      0|            }
 2383|       |
 2384|       |            /*
 2385|       |             * Also increase the counter when entering or exiting a PERef.
 2386|       |             * The spec says: "When a parameter-entity reference is recognized
 2387|       |             * in the DTD and included, its replacement text MUST be enlarged
 2388|       |             * by the attachment of one leading and one following space (#x20)
 2389|       |             * character."
 2390|       |             */
 2391|      0|	    if (res < INT_MAX)
  ------------------
  |  Branch (2391:10): [True: 0, False: 0]
  ------------------
 2392|      0|		res++;
 2393|      0|        }
 2394|      0|    }
 2395|  19.1k|    return(res);
 2396|  19.1k|}
xmlParseName:
 3524|     13|xmlParseName(xmlParserCtxtPtr ctxt) {
 3525|     13|    const xmlChar *in;
 3526|     13|    const xmlChar *ret;
 3527|     13|    size_t count = 0;
 3528|     13|    size_t maxLength = (ctxt->options & XML_PARSE_HUGE) ?
  ------------------
  |  Branch (3528:24): [True: 0, False: 13]
  ------------------
 3529|      0|                       XML_MAX_TEXT_LENGTH :
  ------------------
  |  |   42|      0|#define XML_MAX_TEXT_LENGTH 10000000
  ------------------
 3530|     13|                       XML_MAX_NAME_LENGTH;
  ------------------
  |  |   61|     26|#define XML_MAX_NAME_LENGTH 50000
  ------------------
 3531|       |
 3532|     13|    GROW;
  ------------------
  |  | 2270|     13|#define GROW if (ctxt->input->end - ctxt->input->cur < INPUT_CHUNK)	\
  |  |  ------------------
  |  |  |  |   97|     13|#define INPUT_CHUNK	250
  |  |  ------------------
  |  |  |  Branch (2270:18): [True: 5, False: 8]
  |  |  ------------------
  |  | 2271|     13|	xmlParserGrow(ctxt);
  ------------------
 3533|     13|    if (ctxt->instate == XML_PARSER_EOF)
  ------------------
  |  Branch (3533:9): [True: 0, False: 13]
  ------------------
 3534|      0|        return(NULL);
 3535|       |
 3536|       |    /*
 3537|       |     * Accelerator for simple ASCII names
 3538|       |     */
 3539|     13|    in = ctxt->input->cur;
 3540|     13|    if (((*in >= 0x61) && (*in <= 0x7A)) ||
  ------------------
  |  Branch (3540:10): [True: 13, False: 0]
  |  Branch (3540:27): [True: 13, False: 0]
  ------------------
 3541|     13|	((*in >= 0x41) && (*in <= 0x5A)) ||
  ------------------
  |  Branch (3541:3): [True: 0, False: 0]
  |  Branch (3541:20): [True: 0, False: 0]
  ------------------
 3542|     13|	(*in == '_') || (*in == ':')) {
  ------------------
  |  Branch (3542:2): [True: 0, False: 0]
  |  Branch (3542:18): [True: 0, False: 0]
  ------------------
 3543|     13|	in++;
 3544|     51|	while (((*in >= 0x61) && (*in <= 0x7A)) ||
  ------------------
  |  Branch (3544:10): [True: 36, False: 15]
  |  Branch (3544:27): [True: 36, False: 0]
  ------------------
 3545|     51|	       ((*in >= 0x41) && (*in <= 0x5A)) ||
  ------------------
  |  Branch (3545:10): [True: 2, False: 13]
  |  Branch (3545:27): [True: 2, False: 0]
  ------------------
 3546|     51|	       ((*in >= 0x30) && (*in <= 0x39)) ||
  ------------------
  |  Branch (3546:10): [True: 12, False: 1]
  |  Branch (3546:27): [True: 0, False: 12]
  ------------------
 3547|     51|	       (*in == '_') || (*in == '-') ||
  ------------------
  |  Branch (3547:9): [True: 0, False: 13]
  |  Branch (3547:25): [True: 0, False: 13]
  ------------------
 3548|     51|	       (*in == ':') || (*in == '.'))
  ------------------
  |  Branch (3548:9): [True: 0, False: 13]
  |  Branch (3548:25): [True: 0, False: 13]
  ------------------
 3549|     38|	    in++;
 3550|     13|	if ((*in > 0) && (*in < 0x80)) {
  ------------------
  |  Branch (3550:6): [True: 13, False: 0]
  |  Branch (3550:19): [True: 13, False: 0]
  ------------------
 3551|     13|	    count = in - ctxt->input->cur;
 3552|     13|            if (count > maxLength) {
  ------------------
  |  Branch (3552:17): [True: 0, False: 13]
  ------------------
 3553|      0|                xmlFatalErr(ctxt, XML_ERR_NAME_TOO_LONG, "Name");
 3554|      0|                return(NULL);
 3555|      0|            }
 3556|     13|	    ret = xmlDictLookup(ctxt->dict, ctxt->input->cur, count);
 3557|     13|	    ctxt->input->cur = in;
 3558|     13|	    ctxt->input->col += count;
 3559|     13|	    if (ret == NULL)
  ------------------
  |  Branch (3559:10): [True: 0, False: 13]
  ------------------
 3560|      0|	        xmlErrMemory(ctxt, NULL);
 3561|     13|	    return(ret);
 3562|     13|	}
 3563|     13|    }
 3564|       |    /* accelerator for special cases */
 3565|      0|    return(xmlParseNameComplex(ctxt));
 3566|     13|}
xmlParseComment:
 5029|    190|xmlParseComment(xmlParserCtxtPtr ctxt) {
 5030|    190|    xmlChar *buf = NULL;
 5031|    190|    size_t size = XML_PARSER_BUFFER_SIZE;
  ------------------
  |  |  167|    190|#define XML_PARSER_BUFFER_SIZE 100
  ------------------
 5032|    190|    size_t len = 0;
 5033|    190|    size_t maxLength = (ctxt->options & XML_PARSE_HUGE) ?
  ------------------
  |  Branch (5033:24): [True: 0, False: 190]
  ------------------
 5034|      0|                       XML_MAX_HUGE_LENGTH :
  ------------------
  |  |   49|      0|#define XML_MAX_HUGE_LENGTH 1000000000
  ------------------
 5035|    190|                       XML_MAX_TEXT_LENGTH;
  ------------------
  |  |   42|    380|#define XML_MAX_TEXT_LENGTH 10000000
  ------------------
 5036|    190|    xmlParserInputState state;
 5037|    190|    const xmlChar *in;
 5038|    190|    size_t nbchar = 0;
 5039|    190|    int ccol;
 5040|    190|    int inputid;
 5041|       |
 5042|       |    /*
 5043|       |     * Check that there is a comment right here.
 5044|       |     */
 5045|    190|    if ((RAW != '<') || (NXT(1) != '!'))
  ------------------
  |  | 2221|    190|#define RAW (*ctxt->input->cur)
  ------------------
                  if ((RAW != '<') || (NXT(1) != '!'))
  ------------------
  |  | 2223|    190|#define NXT(val) ctxt->input->cur[(val)]
  ------------------
  |  Branch (5045:9): [True: 0, False: 190]
  |  Branch (5045:25): [True: 0, False: 190]
  ------------------
 5046|      0|        return;
 5047|    190|    SKIP(2);
  ------------------
  |  | 2245|    190|#define SKIP(val) do {							\
  |  | 2246|    190|    ctxt->input->cur += (val),ctxt->input->col+=(val);			\
  |  | 2247|    190|    if (*ctxt->input->cur == 0)						\
  |  |  ------------------
  |  |  |  Branch (2247:9): [True: 0, False: 190]
  |  |  ------------------
  |  | 2248|    190|        xmlParserGrow(ctxt);						\
  |  | 2249|    190|  } while (0)
  |  |  ------------------
  |  |  |  Branch (2249:12): [Folded - Ignored]
  |  |  ------------------
  ------------------
 5048|    190|    if ((RAW != '-') || (NXT(1) != '-'))
  ------------------
  |  | 2221|    190|#define RAW (*ctxt->input->cur)
  ------------------
                  if ((RAW != '-') || (NXT(1) != '-'))
  ------------------
  |  | 2223|    190|#define NXT(val) ctxt->input->cur[(val)]
  ------------------
  |  Branch (5048:9): [True: 0, False: 190]
  |  Branch (5048:25): [True: 0, False: 190]
  ------------------
 5049|      0|        return;
 5050|    190|    state = ctxt->instate;
 5051|    190|    ctxt->instate = XML_PARSER_COMMENT;
 5052|    190|    inputid = ctxt->input->id;
 5053|    190|    SKIP(2);
  ------------------
  |  | 2245|    190|#define SKIP(val) do {							\
  |  | 2246|    190|    ctxt->input->cur += (val),ctxt->input->col+=(val);			\
  |  | 2247|    190|    if (*ctxt->input->cur == 0)						\
  |  |  ------------------
  |  |  |  Branch (2247:9): [True: 0, False: 190]
  |  |  ------------------
  |  | 2248|    190|        xmlParserGrow(ctxt);						\
  |  | 2249|    190|  } while (0)
  |  |  ------------------
  |  |  |  Branch (2249:12): [Folded - Ignored]
  |  |  ------------------
  ------------------
 5054|    190|    GROW;
  ------------------
  |  | 2270|    190|#define GROW if (ctxt->input->end - ctxt->input->cur < INPUT_CHUNK)	\
  |  |  ------------------
  |  |  |  |   97|    190|#define INPUT_CHUNK	250
  |  |  ------------------
  |  |  |  Branch (2270:18): [True: 29, False: 161]
  |  |  ------------------
  |  | 2271|    190|	xmlParserGrow(ctxt);
  ------------------
 5055|       |
 5056|       |    /*
 5057|       |     * Accelerated common case where input don't need to be
 5058|       |     * modified before passing it to the handler.
 5059|       |     */
 5060|    190|    in = ctxt->input->cur;
 5061|    190|    do {
 5062|    190|	if (*in == 0xA) {
  ------------------
  |  Branch (5062:6): [True: 11, False: 179]
  ------------------
 5063|     11|	    do {
 5064|     11|		ctxt->input->line++; ctxt->input->col = 1;
 5065|     11|		in++;
 5066|     11|	    } while (*in == 0xA);
  ------------------
  |  Branch (5066:15): [True: 0, False: 11]
  ------------------
 5067|     11|	}
 5068|    431|get_more:
 5069|    431|        ccol = ctxt->input->col;
 5070|  13.9k|	while (((*in > '-') && (*in <= 0x7F)) ||
  ------------------
  |  Branch (5070:10): [True: 10.4k, False: 3.50k]
  |  Branch (5070:25): [True: 10.4k, False: 29]
  ------------------
 5071|  13.9k|	       ((*in >= 0x20) && (*in < '-')) ||
  ------------------
  |  Branch (5071:10): [True: 3.08k, False: 452]
  |  Branch (5071:27): [True: 2.85k, False: 230]
  ------------------
 5072|  13.9k|	       (*in == 0x09)) {
  ------------------
  |  Branch (5072:9): [True: 251, False: 431]
  ------------------
 5073|  13.5k|		    in++;
 5074|  13.5k|		    ccol++;
 5075|  13.5k|	}
 5076|    431|	ctxt->input->col = ccol;
 5077|    431|	if (*in == 0xA) {
  ------------------
  |  Branch (5077:6): [True: 200, False: 231]
  ------------------
 5078|    217|	    do {
 5079|    217|		ctxt->input->line++; ctxt->input->col = 1;
 5080|    217|		in++;
 5081|    217|	    } while (*in == 0xA);
  ------------------
  |  Branch (5081:15): [True: 17, False: 200]
  ------------------
 5082|    200|	    goto get_more;
 5083|    200|	}
 5084|    231|	nbchar = in - ctxt->input->cur;
 5085|       |	/*
 5086|       |	 * save current set of data
 5087|       |	 */
 5088|    231|	if (nbchar > 0) {
  ------------------
  |  Branch (5088:6): [True: 231, False: 0]
  ------------------
 5089|    231|            if (buf == NULL) {
  ------------------
  |  Branch (5089:17): [True: 190, False: 41]
  ------------------
 5090|    190|                if ((*in == '-') && (in[1] == '-'))
  ------------------
  |  Branch (5090:21): [True: 161, False: 29]
  |  Branch (5090:37): [True: 145, False: 16]
  ------------------
 5091|    145|                    size = nbchar + 1;
 5092|     45|                else
 5093|     45|                    size = XML_PARSER_BUFFER_SIZE + nbchar;
  ------------------
  |  |  167|     45|#define XML_PARSER_BUFFER_SIZE 100
  ------------------
 5094|    190|                buf = (xmlChar *) xmlMallocAtomic(size);
 5095|    190|                if (buf == NULL) {
  ------------------
  |  Branch (5095:21): [True: 0, False: 190]
  ------------------
 5096|      0|                    xmlErrMemory(ctxt, NULL);
 5097|      0|                    ctxt->instate = state;
 5098|      0|                    return;
 5099|      0|                }
 5100|    190|                len = 0;
 5101|    190|            } else if (len + nbchar + 1 >= size) {
  ------------------
  |  Branch (5101:24): [True: 1, False: 40]
  ------------------
 5102|      1|                xmlChar *new_buf;
 5103|      1|                size  += len + nbchar + XML_PARSER_BUFFER_SIZE;
  ------------------
  |  |  167|      1|#define XML_PARSER_BUFFER_SIZE 100
  ------------------
 5104|      1|                new_buf = (xmlChar *) xmlRealloc(buf, size);
 5105|      1|                if (new_buf == NULL) {
  ------------------
  |  Branch (5105:21): [True: 0, False: 1]
  ------------------
 5106|      0|                    xmlFree (buf);
 5107|      0|                    xmlErrMemory(ctxt, NULL);
 5108|      0|                    ctxt->instate = state;
 5109|      0|                    return;
 5110|      0|                }
 5111|      1|                buf = new_buf;
 5112|      1|            }
 5113|    231|            memcpy(&buf[len], ctxt->input->cur, nbchar);
 5114|    231|            len += nbchar;
 5115|    231|            buf[len] = 0;
 5116|    231|	}
 5117|    231|        if (len > maxLength) {
  ------------------
  |  Branch (5117:13): [True: 0, False: 231]
  ------------------
 5118|      0|            xmlFatalErrMsgStr(ctxt, XML_ERR_COMMENT_NOT_FINISHED,
 5119|      0|                         "Comment too big found", NULL);
 5120|      0|            xmlFree (buf);
 5121|      0|            return;
 5122|      0|        }
 5123|    231|	ctxt->input->cur = in;
 5124|    231|	if (*in == 0xA) {
  ------------------
  |  Branch (5124:6): [True: 0, False: 231]
  ------------------
 5125|      0|	    in++;
 5126|      0|	    ctxt->input->line++; ctxt->input->col = 1;
 5127|      0|	}
 5128|    231|	if (*in == 0xD) {
  ------------------
  |  Branch (5128:6): [True: 0, False: 231]
  ------------------
 5129|      0|	    in++;
 5130|      0|	    if (*in == 0xA) {
  ------------------
  |  Branch (5130:10): [True: 0, False: 0]
  ------------------
 5131|      0|		ctxt->input->cur = in;
 5132|      0|		in++;
 5133|      0|		ctxt->input->line++; ctxt->input->col = 1;
 5134|      0|		goto get_more;
 5135|      0|	    }
 5136|      0|	    in--;
 5137|      0|	}
 5138|    231|	SHRINK;
  ------------------
  |  | 2265|    231|    if (((ctxt->progressive == 0) || (ctxt->inputNr > 1)) && \
  |  |  ------------------
  |  |  |  Branch (2265:10): [True: 231, False: 0]
  |  |  |  Branch (2265:38): [True: 0, False: 0]
  |  |  ------------------
  |  | 2266|    231|        (ctxt->input->cur - ctxt->input->base > 2 * INPUT_CHUNK) && \
  |  |  ------------------
  |  |  |  |   97|    231|#define INPUT_CHUNK	250
  |  |  ------------------
  |  |  |  Branch (2266:9): [True: 74, False: 157]
  |  |  ------------------
  |  | 2267|    231|	(ctxt->input->end - ctxt->input->cur < 2 * INPUT_CHUNK)) \
  |  |  ------------------
  |  |  |  |   97|     74|#define INPUT_CHUNK	250
  |  |  ------------------
  |  |  |  Branch (2267:2): [True: 7, False: 67]
  |  |  ------------------
  |  | 2268|    231|	xmlParserShrink(ctxt);
  ------------------
 5139|    231|	GROW;
  ------------------
  |  | 2270|    231|#define GROW if (ctxt->input->end - ctxt->input->cur < INPUT_CHUNK)	\
  |  |  ------------------
  |  |  |  |   97|    231|#define INPUT_CHUNK	250
  |  |  ------------------
  |  |  |  Branch (2270:18): [True: 35, False: 196]
  |  |  ------------------
  |  | 2271|    231|	xmlParserGrow(ctxt);
  ------------------
 5140|    231|        if (ctxt->instate == XML_PARSER_EOF) {
  ------------------
  |  Branch (5140:13): [True: 0, False: 231]
  ------------------
 5141|      0|            xmlFree(buf);
 5142|      0|            return;
 5143|      0|        }
 5144|    231|	in = ctxt->input->cur;
 5145|    231|	if (*in == '-') {
  ------------------
  |  Branch (5145:6): [True: 201, False: 30]
  ------------------
 5146|    201|	    if (in[1] == '-') {
  ------------------
  |  Branch (5146:10): [True: 160, False: 41]
  ------------------
 5147|    160|	        if (in[2] == '>') {
  ------------------
  |  Branch (5147:14): [True: 160, False: 0]
  ------------------
 5148|    160|		    if (ctxt->input->id != inputid) {
  ------------------
  |  Branch (5148:11): [True: 0, False: 160]
  ------------------
 5149|      0|			xmlFatalErrMsg(ctxt, XML_ERR_ENTITY_BOUNDARY,
 5150|      0|			               "comment doesn't start and stop in the"
 5151|      0|                                       " same entity\n");
 5152|      0|		    }
 5153|    160|		    SKIP(3);
  ------------------
  |  | 2245|    160|#define SKIP(val) do {							\
  |  | 2246|    160|    ctxt->input->cur += (val),ctxt->input->col+=(val);			\
  |  | 2247|    160|    if (*ctxt->input->cur == 0)						\
  |  |  ------------------
  |  |  |  Branch (2247:9): [True: 0, False: 160]
  |  |  ------------------
  |  | 2248|    160|        xmlParserGrow(ctxt);						\
  |  | 2249|    160|  } while (0)
  |  |  ------------------
  |  |  |  Branch (2249:12): [Folded - Ignored]
  |  |  ------------------
  ------------------
 5154|    160|		    if ((ctxt->sax != NULL) && (ctxt->sax->comment != NULL) &&
  ------------------
  |  Branch (5154:11): [True: 160, False: 0]
  |  Branch (5154:34): [True: 160, False: 0]
  ------------------
 5155|    160|		        (!ctxt->disableSAX)) {
  ------------------
  |  Branch (5155:11): [True: 157, False: 3]
  ------------------
 5156|    157|			if (buf != NULL)
  ------------------
  |  Branch (5156:8): [True: 157, False: 0]
  ------------------
 5157|    157|			    ctxt->sax->comment(ctxt->userData, buf);
 5158|      0|			else
 5159|      0|			    ctxt->sax->comment(ctxt->userData, BAD_CAST "");
  ------------------
  |  |   35|      0|#define BAD_CAST (xmlChar *)
  ------------------
 5160|    157|		    }
 5161|    160|		    if (buf != NULL)
  ------------------
  |  Branch (5161:11): [True: 160, False: 0]
  ------------------
 5162|    160|		        xmlFree(buf);
 5163|    160|		    if (ctxt->instate != XML_PARSER_EOF)
  ------------------
  |  Branch (5163:11): [True: 160, False: 0]
  ------------------
 5164|    160|			ctxt->instate = state;
 5165|    160|		    return;
 5166|    160|		}
 5167|      0|		if (buf != NULL) {
  ------------------
  |  Branch (5167:7): [True: 0, False: 0]
  ------------------
 5168|      0|		    xmlFatalErrMsgStr(ctxt, XML_ERR_HYPHEN_IN_COMMENT,
 5169|      0|		                      "Double hyphen within comment: "
 5170|      0|                                      "<!--%.50s\n",
 5171|      0|				      buf);
 5172|      0|		} else
 5173|      0|		    xmlFatalErrMsgStr(ctxt, XML_ERR_HYPHEN_IN_COMMENT,
 5174|      0|		                      "Double hyphen within comment\n", NULL);
 5175|      0|                if (ctxt->instate == XML_PARSER_EOF) {
  ------------------
  |  Branch (5175:21): [True: 0, False: 0]
  ------------------
 5176|      0|                    xmlFree(buf);
 5177|      0|                    return;
 5178|      0|                }
 5179|      0|		in++;
 5180|      0|		ctxt->input->col++;
 5181|      0|	    }
 5182|     41|	    in++;
 5183|     41|	    ctxt->input->col++;
 5184|     41|	    goto get_more;
 5185|    201|	}
 5186|    231|    } while (((*in >= 0x20) && (*in <= 0x7F)) || (*in == 0x09) || (*in == 0x0a));
  ------------------
  |  Branch (5186:15): [True: 29, False: 1]
  |  Branch (5186:32): [True: 0, False: 29]
  |  Branch (5186:50): [True: 0, False: 30]
  |  Branch (5186:67): [True: 0, False: 30]
  ------------------
 5187|     30|    xmlParseCommentComplex(ctxt, buf, len, size);
 5188|     30|    ctxt->instate = state;
 5189|     30|    return;
 5190|    190|}
xmlParseReference:
 7222|      8|xmlParseReference(xmlParserCtxtPtr ctxt) {
 7223|      8|    xmlEntityPtr ent;
 7224|      8|    xmlChar *val;
 7225|      8|    int was_checked;
 7226|      8|    xmlNodePtr list = NULL;
 7227|      8|    xmlParserErrors ret = XML_ERR_OK;
 7228|       |
 7229|       |
 7230|      8|    if (RAW != '&')
  ------------------
  |  | 2221|      8|#define RAW (*ctxt->input->cur)
  ------------------
  |  Branch (7230:9): [True: 0, False: 8]
  ------------------
 7231|      0|        return;
 7232|       |
 7233|       |    /*
 7234|       |     * Simple case of a CharRef
 7235|       |     */
 7236|      8|    if (NXT(1) == '#') {
  ------------------
  |  | 2223|      8|#define NXT(val) ctxt->input->cur[(val)]
  ------------------
  |  Branch (7236:9): [True: 0, False: 8]
  ------------------
 7237|      0|	int i = 0;
 7238|      0|	xmlChar out[16];
 7239|      0|	int value = xmlParseCharRef(ctxt);
 7240|       |
 7241|      0|	if (value == 0)
  ------------------
  |  Branch (7241:6): [True: 0, False: 0]
  ------------------
 7242|      0|	    return;
 7243|       |
 7244|       |        /*
 7245|       |         * Just encode the value in UTF-8
 7246|       |         */
 7247|      0|        COPY_BUF(out, i, value);
  ------------------
  |  | 2295|      0|    if (v < 0x80) b[i++] = v;						\
  |  |  ------------------
  |  |  |  Branch (2295:9): [True: 0, False: 0]
  |  |  ------------------
  |  | 2296|      0|    else i += xmlCopyCharMultiByte(&b[i],v)
  ------------------
 7248|      0|        out[i] = 0;
 7249|      0|        if ((ctxt->sax != NULL) && (ctxt->sax->characters != NULL) &&
  ------------------
  |  Branch (7249:13): [True: 0, False: 0]
  |  Branch (7249:36): [True: 0, False: 0]
  ------------------
 7250|      0|            (!ctxt->disableSAX))
  ------------------
  |  Branch (7250:13): [True: 0, False: 0]
  ------------------
 7251|      0|            ctxt->sax->characters(ctxt->userData, out, i);
 7252|      0|	return;
 7253|      0|    }
 7254|       |
 7255|       |    /*
 7256|       |     * We are seeing an entity reference
 7257|       |     */
 7258|      8|    ent = xmlParseEntityRef(ctxt);
 7259|      8|    if (ent == NULL) return;
  ------------------
  |  Branch (7259:9): [True: 0, False: 8]
  ------------------
 7260|      8|    if (!ctxt->wellFormed)
  ------------------
  |  Branch (7260:9): [True: 0, False: 8]
  ------------------
 7261|      0|	return;
 7262|      8|    was_checked = ent->flags & XML_ENT_PARSED;
  ------------------
  |  |   14|      8|#define XML_ENT_PARSED      (1<<0)
  ------------------
 7263|       |
 7264|       |    /* special case of predefined entities */
 7265|      8|    if ((ent->name == NULL) ||
  ------------------
  |  Branch (7265:9): [True: 0, False: 8]
  ------------------
 7266|      8|        (ent->etype == XML_INTERNAL_PREDEFINED_ENTITY)) {
  ------------------
  |  Branch (7266:9): [True: 8, False: 0]
  ------------------
 7267|      8|	val = ent->content;
 7268|      8|	if (val == NULL) return;
  ------------------
  |  Branch (7268:6): [True: 0, False: 8]
  ------------------
 7269|       |	/*
 7270|       |	 * inline the entity.
 7271|       |	 */
 7272|      8|	if ((ctxt->sax != NULL) && (ctxt->sax->characters != NULL) &&
  ------------------
  |  Branch (7272:6): [True: 8, False: 0]
  |  Branch (7272:29): [True: 8, False: 0]
  ------------------
 7273|      8|	    (!ctxt->disableSAX))
  ------------------
  |  Branch (7273:6): [True: 8, False: 0]
  ------------------
 7274|      8|	    ctxt->sax->characters(ctxt->userData, val, xmlStrlen(val));
 7275|      8|	return;
 7276|      8|    }
 7277|       |
 7278|       |    /*
 7279|       |     * The first reference to the entity trigger a parsing phase
 7280|       |     * where the ent->children is filled with the result from
 7281|       |     * the parsing.
 7282|       |     * Note: external parsed entities will not be loaded, it is not
 7283|       |     * required for a non-validating parser, unless the parsing option
 7284|       |     * of validating, or substituting entities were given. Doing so is
 7285|       |     * far more secure as the parser will only process data coming from
 7286|       |     * the document entity by default.
 7287|       |     *
 7288|       |     * FIXME: This doesn't work correctly since entities can be
 7289|       |     * expanded with different namespace declarations in scope.
 7290|       |     * For example:
 7291|       |     *
 7292|       |     * <!DOCTYPE doc [
 7293|       |     *   <!ENTITY ent "<ns:elem/>">
 7294|       |     * ]>
 7295|       |     * <doc>
 7296|       |     *   <decl1 xmlns:ns="urn:ns1">
 7297|       |     *     &ent;
 7298|       |     *   </decl1>
 7299|       |     *   <decl2 xmlns:ns="urn:ns2">
 7300|       |     *     &ent;
 7301|       |     *   </decl2>
 7302|       |     * </doc>
 7303|       |     *
 7304|       |     * Proposed fix:
 7305|       |     *
 7306|       |     * - Remove the ent->owner optimization which tries to avoid the
 7307|       |     *   initial copy of the entity. Always make entities own the
 7308|       |     *   subtree.
 7309|       |     * - Ignore current namespace declarations when parsing the
 7310|       |     *   entity. If a prefix can't be resolved, don't report an error
 7311|       |     *   but mark it as unresolved.
 7312|       |     * - Try to resolve these prefixes when expanding the entity.
 7313|       |     *   This will require a specialized version of xmlStaticCopyNode
 7314|       |     *   which can also make use of the namespace hash table to avoid
 7315|       |     *   quadratic behavior.
 7316|       |     *
 7317|       |     * Alternatively, we could simply reparse the entity on each
 7318|       |     * expansion like we already do with custom SAX callbacks.
 7319|       |     * External entity content should be cached in this case.
 7320|       |     */
 7321|      0|    if (((ent->flags & XML_ENT_PARSED) == 0) &&
  ------------------
  |  |   14|      0|#define XML_ENT_PARSED      (1<<0)
  ------------------
  |  Branch (7321:9): [True: 0, False: 0]
  ------------------
 7322|      0|        ((ent->etype != XML_EXTERNAL_GENERAL_PARSED_ENTITY) ||
  ------------------
  |  Branch (7322:10): [True: 0, False: 0]
  ------------------
 7323|      0|         (ctxt->options & (XML_PARSE_NOENT | XML_PARSE_DTDVALID)))) {
  ------------------
  |  Branch (7323:10): [True: 0, False: 0]
  ------------------
 7324|      0|	unsigned long oldsizeentcopy = ctxt->sizeentcopy;
 7325|       |
 7326|       |	/*
 7327|       |	 * This is a bit hackish but this seems the best
 7328|       |	 * way to make sure both SAX and DOM entity support
 7329|       |	 * behaves okay.
 7330|       |	 */
 7331|      0|	void *user_data;
 7332|      0|	if (ctxt->userData == ctxt)
  ------------------
  |  Branch (7332:6): [True: 0, False: 0]
  ------------------
 7333|      0|	    user_data = NULL;
 7334|      0|	else
 7335|      0|	    user_data = ctxt->userData;
 7336|       |
 7337|       |        /* Avoid overflow as much as possible */
 7338|      0|        ctxt->sizeentcopy = 0;
 7339|       |
 7340|      0|        if (ent->flags & XML_ENT_EXPANDING) {
  ------------------
  |  |   16|      0|#define XML_ENT_EXPANDING   (1<<2)
  ------------------
  |  Branch (7340:13): [True: 0, False: 0]
  ------------------
 7341|      0|            xmlFatalErr(ctxt, XML_ERR_ENTITY_LOOP, NULL);
 7342|      0|            xmlHaltParser(ctxt);
 7343|      0|            return;
 7344|      0|        }
 7345|       |
 7346|      0|        ent->flags |= XML_ENT_EXPANDING;
  ------------------
  |  |   16|      0|#define XML_ENT_EXPANDING   (1<<2)
  ------------------
 7347|       |
 7348|       |	/*
 7349|       |	 * Check that this entity is well formed
 7350|       |	 * 4.3.2: An internal general parsed entity is well-formed
 7351|       |	 * if its replacement text matches the production labeled
 7352|       |	 * content.
 7353|       |	 */
 7354|      0|	if (ent->etype == XML_INTERNAL_GENERAL_ENTITY) {
  ------------------
  |  Branch (7354:6): [True: 0, False: 0]
  ------------------
 7355|      0|	    ctxt->depth++;
 7356|      0|	    ret = xmlParseBalancedChunkMemoryInternal(ctxt, ent->content,
 7357|      0|	                                              user_data, &list);
 7358|      0|	    ctxt->depth--;
 7359|       |
 7360|      0|	} else if (ent->etype == XML_EXTERNAL_GENERAL_PARSED_ENTITY) {
  ------------------
  |  Branch (7360:13): [True: 0, False: 0]
  ------------------
 7361|      0|	    ctxt->depth++;
 7362|      0|	    ret = xmlParseExternalEntityPrivate(ctxt->myDoc, ctxt, ctxt->sax,
 7363|      0|	                                   user_data, ctxt->depth, ent->URI,
 7364|      0|					   ent->ExternalID, &list);
 7365|      0|	    ctxt->depth--;
 7366|      0|	} else {
 7367|      0|	    ret = XML_ERR_ENTITY_PE_INTERNAL;
 7368|      0|	    xmlErrMsgStr(ctxt, XML_ERR_INTERNAL_ERROR,
 7369|      0|			 "invalid entity type found\n", NULL);
 7370|      0|	}
 7371|       |
 7372|      0|        ent->flags &= ~XML_ENT_EXPANDING;
  ------------------
  |  |   16|      0|#define XML_ENT_EXPANDING   (1<<2)
  ------------------
 7373|      0|        ent->flags |= XML_ENT_PARSED | XML_ENT_CHECKED;
  ------------------
  |  |   14|      0|#define XML_ENT_PARSED      (1<<0)
  ------------------
                      ent->flags |= XML_ENT_PARSED | XML_ENT_CHECKED;
  ------------------
  |  |   15|      0|#define XML_ENT_CHECKED     (1<<1)
  ------------------
 7374|      0|        ent->expandedSize = ctxt->sizeentcopy;
 7375|      0|	if (ret == XML_ERR_ENTITY_LOOP) {
  ------------------
  |  Branch (7375:6): [True: 0, False: 0]
  ------------------
 7376|      0|            xmlHaltParser(ctxt);
 7377|      0|	    xmlFreeNodeList(list);
 7378|      0|	    return;
 7379|      0|	}
 7380|      0|	if (xmlParserEntityCheck(ctxt, oldsizeentcopy)) {
  ------------------
  |  Branch (7380:6): [True: 0, False: 0]
  ------------------
 7381|      0|	    xmlFreeNodeList(list);
 7382|      0|	    return;
 7383|      0|	}
 7384|       |
 7385|      0|	if ((ret == XML_ERR_OK) && (list != NULL)) {
  ------------------
  |  Branch (7385:6): [True: 0, False: 0]
  |  Branch (7385:29): [True: 0, False: 0]
  ------------------
 7386|      0|            ent->children = list;
 7387|       |            /*
 7388|       |             * Prune it directly in the generated document
 7389|       |             * except for single text nodes.
 7390|       |             */
 7391|      0|            if ((ctxt->replaceEntities == 0) ||
  ------------------
  |  Branch (7391:17): [True: 0, False: 0]
  ------------------
 7392|      0|                (ctxt->parseMode == XML_PARSE_READER) ||
  ------------------
  |  Branch (7392:17): [True: 0, False: 0]
  ------------------
 7393|      0|                ((list->type == XML_TEXT_NODE) &&
  ------------------
  |  Branch (7393:18): [True: 0, False: 0]
  ------------------
 7394|      0|                 (list->next == NULL))) {
  ------------------
  |  Branch (7394:18): [True: 0, False: 0]
  ------------------
 7395|      0|                ent->owner = 1;
 7396|      0|                while (list != NULL) {
  ------------------
  |  Branch (7396:24): [True: 0, False: 0]
  ------------------
 7397|      0|                    list->parent = (xmlNodePtr) ent;
 7398|      0|                    if (list->doc != ent->doc)
  ------------------
  |  Branch (7398:25): [True: 0, False: 0]
  ------------------
 7399|      0|                        xmlSetTreeDoc(list, ent->doc);
 7400|      0|                    if (list->next == NULL)
  ------------------
  |  Branch (7400:25): [True: 0, False: 0]
  ------------------
 7401|      0|                        ent->last = list;
 7402|      0|                    list = list->next;
 7403|      0|                }
 7404|      0|                list = NULL;
 7405|      0|            } else {
 7406|      0|                ent->owner = 0;
 7407|      0|                while (list != NULL) {
  ------------------
  |  Branch (7407:24): [True: 0, False: 0]
  ------------------
 7408|      0|                    list->parent = (xmlNodePtr) ctxt->node;
 7409|      0|                    list->doc = ctxt->myDoc;
 7410|      0|                    if (list->next == NULL)
  ------------------
  |  Branch (7410:25): [True: 0, False: 0]
  ------------------
 7411|      0|                        ent->last = list;
 7412|      0|                    list = list->next;
 7413|      0|                }
 7414|      0|                list = ent->children;
 7415|       |#ifdef LIBXML_LEGACY_ENABLED
 7416|       |                if (ent->etype == XML_EXTERNAL_GENERAL_PARSED_ENTITY)
 7417|       |                    xmlAddEntityReference(ent, list, NULL);
 7418|       |#endif /* LIBXML_LEGACY_ENABLED */
 7419|      0|            }
 7420|      0|	} else if ((ret != XML_ERR_OK) &&
  ------------------
  |  Branch (7420:13): [True: 0, False: 0]
  ------------------
 7421|      0|		   (ret != XML_WAR_UNDECLARED_ENTITY)) {
  ------------------
  |  Branch (7421:6): [True: 0, False: 0]
  ------------------
 7422|      0|	    xmlFatalErrMsgStr(ctxt, XML_ERR_UNDECLARED_ENTITY,
 7423|      0|		     "Entity '%s' failed to parse\n", ent->name);
 7424|      0|            if (ent->content != NULL)
  ------------------
  |  Branch (7424:17): [True: 0, False: 0]
  ------------------
 7425|      0|                ent->content[0] = 0;
 7426|      0|	} else if (list != NULL) {
  ------------------
  |  Branch (7426:13): [True: 0, False: 0]
  ------------------
 7427|      0|	    xmlFreeNodeList(list);
 7428|      0|	    list = NULL;
 7429|      0|	}
 7430|       |
 7431|       |        /* Prevent entity from being parsed and expanded twice (Bug 760367). */
 7432|      0|        was_checked = 0;
 7433|      0|    }
 7434|       |
 7435|       |    /*
 7436|       |     * Now that the entity content has been gathered
 7437|       |     * provide it to the application, this can take different forms based
 7438|       |     * on the parsing modes.
 7439|       |     */
 7440|      0|    if (ent->children == NULL) {
  ------------------
  |  Branch (7440:9): [True: 0, False: 0]
  ------------------
 7441|       |	/*
 7442|       |	 * Probably running in SAX mode and the callbacks don't
 7443|       |	 * build the entity content. So unless we already went
 7444|       |	 * though parsing for first checking go though the entity
 7445|       |	 * content to generate callbacks associated to the entity
 7446|       |	 */
 7447|      0|	if (was_checked != 0) {
  ------------------
  |  Branch (7447:6): [True: 0, False: 0]
  ------------------
 7448|      0|	    void *user_data;
 7449|       |	    /*
 7450|       |	     * This is a bit hackish but this seems the best
 7451|       |	     * way to make sure both SAX and DOM entity support
 7452|       |	     * behaves okay.
 7453|       |	     */
 7454|      0|	    if (ctxt->userData == ctxt)
  ------------------
  |  Branch (7454:10): [True: 0, False: 0]
  ------------------
 7455|      0|		user_data = NULL;
 7456|      0|	    else
 7457|      0|		user_data = ctxt->userData;
 7458|       |
 7459|      0|	    if (ent->etype == XML_INTERNAL_GENERAL_ENTITY) {
  ------------------
  |  Branch (7459:10): [True: 0, False: 0]
  ------------------
 7460|      0|		ctxt->depth++;
 7461|      0|		ret = xmlParseBalancedChunkMemoryInternal(ctxt,
 7462|      0|				   ent->content, user_data, NULL);
 7463|      0|		ctxt->depth--;
 7464|      0|	    } else if (ent->etype ==
  ------------------
  |  Branch (7464:17): [True: 0, False: 0]
  ------------------
 7465|      0|		       XML_EXTERNAL_GENERAL_PARSED_ENTITY) {
 7466|      0|	        unsigned long oldsizeentities = ctxt->sizeentities;
 7467|       |
 7468|      0|		ctxt->depth++;
 7469|      0|		ret = xmlParseExternalEntityPrivate(ctxt->myDoc, ctxt,
 7470|      0|			   ctxt->sax, user_data, ctxt->depth,
 7471|      0|			   ent->URI, ent->ExternalID, NULL);
 7472|      0|		ctxt->depth--;
 7473|       |
 7474|       |                /* Undo the change to sizeentities */
 7475|      0|                ctxt->sizeentities = oldsizeentities;
 7476|      0|	    } else {
 7477|      0|		ret = XML_ERR_ENTITY_PE_INTERNAL;
 7478|      0|		xmlErrMsgStr(ctxt, XML_ERR_INTERNAL_ERROR,
 7479|      0|			     "invalid entity type found\n", NULL);
 7480|      0|	    }
 7481|      0|	    if (ret == XML_ERR_ENTITY_LOOP) {
  ------------------
  |  Branch (7481:10): [True: 0, False: 0]
  ------------------
 7482|      0|		xmlFatalErr(ctxt, XML_ERR_ENTITY_LOOP, NULL);
 7483|      0|		return;
 7484|      0|	    }
 7485|      0|            if (xmlParserEntityCheck(ctxt, 0))
  ------------------
  |  Branch (7485:17): [True: 0, False: 0]
  ------------------
 7486|      0|                return;
 7487|      0|	}
 7488|      0|	if ((ctxt->sax != NULL) && (ctxt->sax->reference != NULL) &&
  ------------------
  |  Branch (7488:6): [True: 0, False: 0]
  |  Branch (7488:29): [True: 0, False: 0]
  ------------------
 7489|      0|	    (ctxt->replaceEntities == 0) && (!ctxt->disableSAX)) {
  ------------------
  |  Branch (7489:6): [True: 0, False: 0]
  |  Branch (7489:38): [True: 0, False: 0]
  ------------------
 7490|       |	    /*
 7491|       |	     * Entity reference callback comes second, it's somewhat
 7492|       |	     * superfluous but a compatibility to historical behaviour
 7493|       |	     */
 7494|      0|	    ctxt->sax->reference(ctxt->userData, ent->name);
 7495|      0|	}
 7496|      0|	return;
 7497|      0|    }
 7498|       |
 7499|       |    /*
 7500|       |     * We also check for amplification if entities aren't substituted.
 7501|       |     * They might be expanded later.
 7502|       |     */
 7503|      0|    if ((was_checked != 0) &&
  ------------------
  |  Branch (7503:9): [True: 0, False: 0]
  ------------------
 7504|      0|        (xmlParserEntityCheck(ctxt, ent->expandedSize)))
  ------------------
  |  Branch (7504:9): [True: 0, False: 0]
  ------------------
 7505|      0|        return;
 7506|       |
 7507|       |    /*
 7508|       |     * If we didn't get any children for the entity being built
 7509|       |     */
 7510|      0|    if ((ctxt->sax != NULL) && (ctxt->sax->reference != NULL) &&
  ------------------
  |  Branch (7510:9): [True: 0, False: 0]
  |  Branch (7510:32): [True: 0, False: 0]
  ------------------
 7511|      0|	(ctxt->replaceEntities == 0) && (!ctxt->disableSAX)) {
  ------------------
  |  Branch (7511:2): [True: 0, False: 0]
  |  Branch (7511:34): [True: 0, False: 0]
  ------------------
 7512|       |	/*
 7513|       |	 * Create a node.
 7514|       |	 */
 7515|      0|	ctxt->sax->reference(ctxt->userData, ent->name);
 7516|      0|	return;
 7517|      0|    }
 7518|       |
 7519|      0|    if (ctxt->replaceEntities)  {
  ------------------
  |  Branch (7519:9): [True: 0, False: 0]
  ------------------
 7520|       |	/*
 7521|       |	 * There is a problem on the handling of _private for entities
 7522|       |	 * (bug 155816): Should we copy the content of the field from
 7523|       |	 * the entity (possibly overwriting some value set by the user
 7524|       |	 * when a copy is created), should we leave it alone, or should
 7525|       |	 * we try to take care of different situations?  The problem
 7526|       |	 * is exacerbated by the usage of this field by the xmlReader.
 7527|       |	 * To fix this bug, we look at _private on the created node
 7528|       |	 * and, if it's NULL, we copy in whatever was in the entity.
 7529|       |	 * If it's not NULL we leave it alone.  This is somewhat of a
 7530|       |	 * hack - maybe we should have further tests to determine
 7531|       |	 * what to do.
 7532|       |	 */
 7533|      0|	if (ctxt->node != NULL) {
  ------------------
  |  Branch (7533:6): [True: 0, False: 0]
  ------------------
 7534|       |	    /*
 7535|       |	     * Seems we are generating the DOM content, do
 7536|       |	     * a simple tree copy for all references except the first
 7537|       |	     * In the first occurrence list contains the replacement.
 7538|       |	     */
 7539|      0|	    if (((list == NULL) && (ent->owner == 0)) ||
  ------------------
  |  Branch (7539:11): [True: 0, False: 0]
  |  Branch (7539:29): [True: 0, False: 0]
  ------------------
 7540|      0|		(ctxt->parseMode == XML_PARSE_READER)) {
  ------------------
  |  Branch (7540:3): [True: 0, False: 0]
  ------------------
 7541|      0|		xmlNodePtr nw = NULL, cur, firstChild = NULL;
 7542|       |
 7543|       |		/*
 7544|       |		 * when operating on a reader, the entities definitions
 7545|       |		 * are always owning the entities subtree.
 7546|       |		if (ctxt->parseMode == XML_PARSE_READER)
 7547|       |		    ent->owner = 1;
 7548|       |		 */
 7549|       |
 7550|      0|		cur = ent->children;
 7551|      0|		while (cur != NULL) {
  ------------------
  |  Branch (7551:10): [True: 0, False: 0]
  ------------------
 7552|      0|		    nw = xmlDocCopyNode(cur, ctxt->myDoc, 1);
 7553|      0|		    if (nw != NULL) {
  ------------------
  |  Branch (7553:11): [True: 0, False: 0]
  ------------------
 7554|      0|			if (nw->_private == NULL)
  ------------------
  |  Branch (7554:8): [True: 0, False: 0]
  ------------------
 7555|      0|			    nw->_private = cur->_private;
 7556|      0|			if (firstChild == NULL){
  ------------------
  |  Branch (7556:8): [True: 0, False: 0]
  ------------------
 7557|      0|			    firstChild = nw;
 7558|      0|			}
 7559|      0|			nw = xmlAddChild(ctxt->node, nw);
 7560|      0|		    }
 7561|      0|		    if (cur == ent->last) {
  ------------------
  |  Branch (7561:11): [True: 0, False: 0]
  ------------------
 7562|       |			/*
 7563|       |			 * needed to detect some strange empty
 7564|       |			 * node cases in the reader tests
 7565|       |			 */
 7566|      0|			if ((ctxt->parseMode == XML_PARSE_READER) &&
  ------------------
  |  Branch (7566:8): [True: 0, False: 0]
  ------------------
 7567|      0|			    (nw != NULL) &&
  ------------------
  |  Branch (7567:8): [True: 0, False: 0]
  ------------------
 7568|      0|			    (nw->type == XML_ELEMENT_NODE) &&
  ------------------
  |  Branch (7568:8): [True: 0, False: 0]
  ------------------
 7569|      0|			    (nw->children == NULL))
  ------------------
  |  Branch (7569:8): [True: 0, False: 0]
  ------------------
 7570|      0|			    nw->extra = 1;
 7571|       |
 7572|      0|			break;
 7573|      0|		    }
 7574|      0|		    cur = cur->next;
 7575|      0|		}
 7576|       |#ifdef LIBXML_LEGACY_ENABLED
 7577|       |		if (ent->etype == XML_EXTERNAL_GENERAL_PARSED_ENTITY)
 7578|       |		  xmlAddEntityReference(ent, firstChild, nw);
 7579|       |#endif /* LIBXML_LEGACY_ENABLED */
 7580|      0|	    } else if ((list == NULL) || (ctxt->inputNr > 0)) {
  ------------------
  |  Branch (7580:17): [True: 0, False: 0]
  |  Branch (7580:35): [True: 0, False: 0]
  ------------------
 7581|      0|		xmlNodePtr nw = NULL, cur, next, last,
 7582|      0|			   firstChild = NULL;
 7583|       |
 7584|       |		/*
 7585|       |		 * Copy the entity child list and make it the new
 7586|       |		 * entity child list. The goal is to make sure any
 7587|       |		 * ID or REF referenced will be the one from the
 7588|       |		 * document content and not the entity copy.
 7589|       |		 */
 7590|      0|		cur = ent->children;
 7591|      0|		ent->children = NULL;
 7592|      0|		last = ent->last;
 7593|      0|		ent->last = NULL;
 7594|      0|		while (cur != NULL) {
  ------------------
  |  Branch (7594:10): [True: 0, False: 0]
  ------------------
 7595|      0|		    next = cur->next;
 7596|      0|		    cur->next = NULL;
 7597|      0|		    cur->parent = NULL;
 7598|      0|		    nw = xmlDocCopyNode(cur, ctxt->myDoc, 1);
 7599|      0|		    if (nw != NULL) {
  ------------------
  |  Branch (7599:11): [True: 0, False: 0]
  ------------------
 7600|      0|			if (nw->_private == NULL)
  ------------------
  |  Branch (7600:8): [True: 0, False: 0]
  ------------------
 7601|      0|			    nw->_private = cur->_private;
 7602|      0|			if (firstChild == NULL){
  ------------------
  |  Branch (7602:8): [True: 0, False: 0]
  ------------------
 7603|      0|			    firstChild = cur;
 7604|      0|			}
 7605|      0|			xmlAddChild((xmlNodePtr) ent, nw);
 7606|      0|		    }
 7607|      0|		    xmlAddChild(ctxt->node, cur);
 7608|      0|		    if (cur == last)
  ------------------
  |  Branch (7608:11): [True: 0, False: 0]
  ------------------
 7609|      0|			break;
 7610|      0|		    cur = next;
 7611|      0|		}
 7612|      0|		if (ent->owner == 0)
  ------------------
  |  Branch (7612:7): [True: 0, False: 0]
  ------------------
 7613|      0|		    ent->owner = 1;
 7614|       |#ifdef LIBXML_LEGACY_ENABLED
 7615|       |		if (ent->etype == XML_EXTERNAL_GENERAL_PARSED_ENTITY)
 7616|       |		  xmlAddEntityReference(ent, firstChild, nw);
 7617|       |#endif /* LIBXML_LEGACY_ENABLED */
 7618|      0|	    } else {
 7619|      0|		const xmlChar *nbktext;
 7620|       |
 7621|       |		/*
 7622|       |		 * the name change is to avoid coalescing of the
 7623|       |		 * node with a possible previous text one which
 7624|       |		 * would make ent->children a dangling pointer
 7625|       |		 */
 7626|      0|		nbktext = xmlDictLookup(ctxt->dict, BAD_CAST "nbktext",
  ------------------
  |  |   35|      0|#define BAD_CAST (xmlChar *)
  ------------------
 7627|      0|					-1);
 7628|      0|		if (ent->children->type == XML_TEXT_NODE)
  ------------------
  |  Branch (7628:7): [True: 0, False: 0]
  ------------------
 7629|      0|		    ent->children->name = nbktext;
 7630|      0|		if ((ent->last != ent->children) &&
  ------------------
  |  Branch (7630:7): [True: 0, False: 0]
  ------------------
 7631|      0|		    (ent->last->type == XML_TEXT_NODE))
  ------------------
  |  Branch (7631:7): [True: 0, False: 0]
  ------------------
 7632|      0|		    ent->last->name = nbktext;
 7633|      0|		xmlAddChildList(ctxt->node, ent->children);
 7634|      0|	    }
 7635|       |
 7636|       |	    /*
 7637|       |	     * This is to avoid a nasty side effect, see
 7638|       |	     * characters() in SAX.c
 7639|       |	     */
 7640|      0|	    ctxt->nodemem = 0;
 7641|      0|	    ctxt->nodelen = 0;
 7642|      0|	    return;
 7643|      0|	}
 7644|      0|    }
 7645|      0|}
xmlParseEntityRef:
 7678|     10|xmlParseEntityRef(xmlParserCtxtPtr ctxt) {
 7679|     10|    const xmlChar *name;
 7680|     10|    xmlEntityPtr ent = NULL;
 7681|       |
 7682|     10|    GROW;
  ------------------
  |  | 2270|     10|#define GROW if (ctxt->input->end - ctxt->input->cur < INPUT_CHUNK)	\
  |  |  ------------------
  |  |  |  |   97|     10|#define INPUT_CHUNK	250
  |  |  ------------------
  |  |  |  Branch (2270:18): [True: 2, False: 8]
  |  |  ------------------
  |  | 2271|     10|	xmlParserGrow(ctxt);
  ------------------
 7683|     10|    if (ctxt->instate == XML_PARSER_EOF)
  ------------------
  |  Branch (7683:9): [True: 0, False: 10]
  ------------------
 7684|      0|        return(NULL);
 7685|       |
 7686|     10|    if (RAW != '&')
  ------------------
  |  | 2221|     10|#define RAW (*ctxt->input->cur)
  ------------------
  |  Branch (7686:9): [True: 0, False: 10]
  ------------------
 7687|      0|        return(NULL);
 7688|     10|    NEXT;
  ------------------
  |  | 2275|     10|#define NEXT xmlNextChar(ctxt)
  ------------------
 7689|     10|    name = xmlParseName(ctxt);
 7690|     10|    if (name == NULL) {
  ------------------
  |  Branch (7690:9): [True: 0, False: 10]
  ------------------
 7691|      0|	xmlFatalErrMsg(ctxt, XML_ERR_NAME_REQUIRED,
 7692|      0|		       "xmlParseEntityRef: no name\n");
 7693|      0|        return(NULL);
 7694|      0|    }
 7695|     10|    if (RAW != ';') {
  ------------------
  |  | 2221|     10|#define RAW (*ctxt->input->cur)
  ------------------
  |  Branch (7695:9): [True: 0, False: 10]
  ------------------
 7696|      0|	xmlFatalErr(ctxt, XML_ERR_ENTITYREF_SEMICOL_MISSING, NULL);
 7697|      0|	return(NULL);
 7698|      0|    }
 7699|     10|    NEXT;
  ------------------
  |  | 2275|     10|#define NEXT xmlNextChar(ctxt)
  ------------------
 7700|       |
 7701|       |    /*
 7702|       |     * Predefined entities override any extra definition
 7703|       |     */
 7704|     10|    if ((ctxt->options & XML_PARSE_OLDSAX) == 0) {
  ------------------
  |  Branch (7704:9): [True: 10, False: 0]
  ------------------
 7705|     10|        ent = xmlGetPredefinedEntity(name);
 7706|     10|        if (ent != NULL)
  ------------------
  |  Branch (7706:13): [True: 10, False: 0]
  ------------------
 7707|     10|            return(ent);
 7708|     10|    }
 7709|       |
 7710|       |    /*
 7711|       |     * Ask first SAX for entity resolution, otherwise try the
 7712|       |     * entities which may have stored in the parser context.
 7713|       |     */
 7714|      0|    if (ctxt->sax != NULL) {
  ------------------
  |  Branch (7714:9): [True: 0, False: 0]
  ------------------
 7715|      0|	if (ctxt->sax->getEntity != NULL)
  ------------------
  |  Branch (7715:6): [True: 0, False: 0]
  ------------------
 7716|      0|	    ent = ctxt->sax->getEntity(ctxt->userData, name);
 7717|      0|	if ((ctxt->wellFormed == 1 ) && (ent == NULL) &&
  ------------------
  |  Branch (7717:6): [True: 0, False: 0]
  |  Branch (7717:34): [True: 0, False: 0]
  ------------------
 7718|      0|	    (ctxt->options & XML_PARSE_OLDSAX))
  ------------------
  |  Branch (7718:6): [True: 0, False: 0]
  ------------------
 7719|      0|	    ent = xmlGetPredefinedEntity(name);
 7720|      0|	if ((ctxt->wellFormed == 1 ) && (ent == NULL) &&
  ------------------
  |  Branch (7720:6): [True: 0, False: 0]
  |  Branch (7720:34): [True: 0, False: 0]
  ------------------
 7721|      0|	    (ctxt->userData==ctxt)) {
  ------------------
  |  Branch (7721:6): [True: 0, False: 0]
  ------------------
 7722|      0|	    ent = xmlSAX2GetEntity(ctxt, name);
 7723|      0|	}
 7724|      0|    }
 7725|      0|    if (ctxt->instate == XML_PARSER_EOF)
  ------------------
  |  Branch (7725:9): [True: 0, False: 0]
  ------------------
 7726|      0|	return(NULL);
 7727|       |    /*
 7728|       |     * [ WFC: Entity Declared ]
 7729|       |     * In a document without any DTD, a document with only an
 7730|       |     * internal DTD subset which contains no parameter entity
 7731|       |     * references, or a document with "standalone='yes'", the
 7732|       |     * Name given in the entity reference must match that in an
 7733|       |     * entity declaration, except that well-formed documents
 7734|       |     * need not declare any of the following entities: amp, lt,
 7735|       |     * gt, apos, quot.
 7736|       |     * The declaration of a parameter entity must precede any
 7737|       |     * reference to it.
 7738|       |     * Similarly, the declaration of a general entity must
 7739|       |     * precede any reference to it which appears in a default
 7740|       |     * value in an attribute-list declaration. Note that if
 7741|       |     * entities are declared in the external subset or in
 7742|       |     * external parameter entities, a non-validating processor
 7743|       |     * is not obligated to read and process their declarations;
 7744|       |     * for such documents, the rule that an entity must be
 7745|       |     * declared is a well-formedness constraint only if
 7746|       |     * standalone='yes'.
 7747|       |     */
 7748|      0|    if (ent == NULL) {
  ------------------
  |  Branch (7748:9): [True: 0, False: 0]
  ------------------
 7749|      0|	if ((ctxt->standalone == 1) ||
  ------------------
  |  Branch (7749:6): [True: 0, False: 0]
  ------------------
 7750|      0|	    ((ctxt->hasExternalSubset == 0) &&
  ------------------
  |  Branch (7750:7): [True: 0, False: 0]
  ------------------
 7751|      0|	     (ctxt->hasPErefs == 0))) {
  ------------------
  |  Branch (7751:7): [True: 0, False: 0]
  ------------------
 7752|      0|	    xmlFatalErrMsgStr(ctxt, XML_ERR_UNDECLARED_ENTITY,
 7753|      0|		     "Entity '%s' not defined\n", name);
 7754|      0|	} else {
 7755|      0|	    xmlErrMsgStr(ctxt, XML_WAR_UNDECLARED_ENTITY,
 7756|      0|		     "Entity '%s' not defined\n", name);
 7757|      0|	    if ((ctxt->inSubset == 0) &&
  ------------------
  |  Branch (7757:10): [True: 0, False: 0]
  ------------------
 7758|      0|		(ctxt->sax != NULL) &&
  ------------------
  |  Branch (7758:3): [True: 0, False: 0]
  ------------------
 7759|      0|                (ctxt->disableSAX == 0) &&
  ------------------
  |  Branch (7759:17): [True: 0, False: 0]
  ------------------
 7760|      0|		(ctxt->sax->reference != NULL)) {
  ------------------
  |  Branch (7760:3): [True: 0, False: 0]
  ------------------
 7761|      0|		ctxt->sax->reference(ctxt->userData, name);
 7762|      0|	    }
 7763|      0|	}
 7764|      0|	ctxt->valid = 0;
 7765|      0|    }
 7766|       |
 7767|       |    /*
 7768|       |     * [ WFC: Parsed Entity ]
 7769|       |     * An entity reference must not contain the name of an
 7770|       |     * unparsed entity
 7771|       |     */
 7772|      0|    else if (ent->etype == XML_EXTERNAL_GENERAL_UNPARSED_ENTITY) {
  ------------------
  |  Branch (7772:14): [True: 0, False: 0]
  ------------------
 7773|      0|	xmlFatalErrMsgStr(ctxt, XML_ERR_UNPARSED_ENTITY,
 7774|      0|		 "Entity reference to unparsed entity %s\n", name);
 7775|      0|    }
 7776|       |
 7777|       |    /*
 7778|       |     * [ WFC: No External Entity References ]
 7779|       |     * Attribute values cannot contain direct or indirect
 7780|       |     * entity references to external entities.
 7781|       |     */
 7782|      0|    else if ((ctxt->instate == XML_PARSER_ATTRIBUTE_VALUE) &&
  ------------------
  |  Branch (7782:14): [True: 0, False: 0]
  ------------------
 7783|      0|	     (ent->etype == XML_EXTERNAL_GENERAL_PARSED_ENTITY)) {
  ------------------
  |  Branch (7783:7): [True: 0, False: 0]
  ------------------
 7784|      0|	xmlFatalErrMsgStr(ctxt, XML_ERR_ENTITY_IS_EXTERNAL,
 7785|      0|	     "Attribute references external entity '%s'\n", name);
 7786|      0|    }
 7787|       |    /*
 7788|       |     * [ WFC: No < in Attribute Values ]
 7789|       |     * The replacement text of any entity referred to directly or
 7790|       |     * indirectly in an attribute value (other than "&lt;") must
 7791|       |     * not contain a <.
 7792|       |     */
 7793|      0|    else if ((ctxt->instate == XML_PARSER_ATTRIBUTE_VALUE) &&
  ------------------
  |  Branch (7793:14): [True: 0, False: 0]
  ------------------
 7794|      0|	     (ent->etype != XML_INTERNAL_PREDEFINED_ENTITY)) {
  ------------------
  |  Branch (7794:7): [True: 0, False: 0]
  ------------------
 7795|      0|	if ((ent->flags & XML_ENT_CHECKED_LT) == 0) {
  ------------------
  |  |   17|      0|#define XML_ENT_CHECKED_LT  (1<<3)
  ------------------
  |  Branch (7795:6): [True: 0, False: 0]
  ------------------
 7796|      0|            if ((ent->content != NULL) && (xmlStrchr(ent->content, '<')))
  ------------------
  |  Branch (7796:17): [True: 0, False: 0]
  |  Branch (7796:43): [True: 0, False: 0]
  ------------------
 7797|      0|                ent->flags |= XML_ENT_CONTAINS_LT;
  ------------------
  |  |   18|      0|#define XML_ENT_CONTAINS_LT (1<<4)
  ------------------
 7798|      0|            ent->flags |= XML_ENT_CHECKED_LT;
  ------------------
  |  |   17|      0|#define XML_ENT_CHECKED_LT  (1<<3)
  ------------------
 7799|      0|        }
 7800|      0|        if (ent->flags & XML_ENT_CONTAINS_LT)
  ------------------
  |  |   18|      0|#define XML_ENT_CONTAINS_LT (1<<4)
  ------------------
  |  Branch (7800:13): [True: 0, False: 0]
  ------------------
 7801|      0|            xmlFatalErrMsgStr(ctxt, XML_ERR_LT_IN_ATTRIBUTE,
 7802|      0|                    "'<' in entity '%s' is not allowed in attributes "
 7803|      0|                    "values\n", name);
 7804|      0|    }
 7805|       |
 7806|       |    /*
 7807|       |     * Internal check, no parameter entities here ...
 7808|       |     */
 7809|      0|    else {
 7810|      0|	switch (ent->etype) {
 7811|      0|	    case XML_INTERNAL_PARAMETER_ENTITY:
  ------------------
  |  Branch (7811:6): [True: 0, False: 0]
  ------------------
 7812|      0|	    case XML_EXTERNAL_PARAMETER_ENTITY:
  ------------------
  |  Branch (7812:6): [True: 0, False: 0]
  ------------------
 7813|      0|	    xmlFatalErrMsgStr(ctxt, XML_ERR_ENTITY_IS_PARAMETER,
 7814|      0|	     "Attempt to reference the parameter entity '%s'\n",
 7815|      0|			      name);
 7816|      0|	    break;
 7817|      0|	    default:
  ------------------
  |  Branch (7817:6): [True: 0, False: 0]
  ------------------
 7818|      0|	    break;
 7819|      0|	}
 7820|      0|    }
 7821|       |
 7822|       |    /*
 7823|       |     * [ WFC: No Recursion ]
 7824|       |     * A parsed entity must not contain a recursive reference
 7825|       |     * to itself, either directly or indirectly.
 7826|       |     * Done somewhere else
 7827|       |     */
 7828|      0|    return(ent);
 7829|      0|}
xmlParseElement:
10319|    235|xmlParseElement(xmlParserCtxtPtr ctxt) {
10320|    235|    if (xmlParseElementStart(ctxt) != 0)
  ------------------
  |  Branch (10320:9): [True: 3, False: 232]
  ------------------
10321|      3|        return;
10322|       |
10323|    232|    xmlParseContentInternal(ctxt);
10324|    232|    if (ctxt->instate == XML_PARSER_EOF)
  ------------------
  |  Branch (10324:9): [True: 0, False: 232]
  ------------------
10325|      0|	return;
10326|       |
10327|    232|    if (ctxt->input->cur >= ctxt->input->end) {
  ------------------
  |  Branch (10327:9): [True: 5, False: 227]
  ------------------
10328|      5|        if (ctxt->errNo == XML_ERR_OK) {
  ------------------
  |  Branch (10328:13): [True: 0, False: 5]
  ------------------
10329|      0|            const xmlChar *name = ctxt->nameTab[ctxt->nameNr - 1];
10330|      0|            int line = ctxt->pushTab[ctxt->nameNr - 1].line;
10331|      0|            xmlFatalErrMsgStrIntStr(ctxt, XML_ERR_TAG_NOT_FINISHED,
10332|      0|                    "Premature end of data in tag %s line %d\n",
10333|      0|                    name, line, NULL);
10334|      0|        }
10335|      5|        return;
10336|      5|    }
10337|       |
10338|    227|    xmlParseElementEnd(ctxt);
10339|    227|}
xmlParseVersionNum:
10526|    227|xmlParseVersionNum(xmlParserCtxtPtr ctxt) {
10527|    227|    xmlChar *buf = NULL;
10528|    227|    int len = 0;
10529|    227|    int size = 10;
10530|    227|    xmlChar cur;
10531|       |
10532|    227|    buf = (xmlChar *) xmlMallocAtomic(size);
10533|    227|    if (buf == NULL) {
  ------------------
  |  Branch (10533:9): [True: 0, False: 227]
  ------------------
10534|      0|	xmlErrMemory(ctxt, NULL);
10535|      0|	return(NULL);
10536|      0|    }
10537|    227|    cur = CUR;
  ------------------
  |  | 2222|    227|#define CUR (*ctxt->input->cur)
  ------------------
10538|    227|    if (!((cur >= '0') && (cur <= '9'))) {
  ------------------
  |  Branch (10538:11): [True: 227, False: 0]
  |  Branch (10538:27): [True: 227, False: 0]
  ------------------
10539|      0|	xmlFree(buf);
10540|      0|	return(NULL);
10541|      0|    }
10542|    227|    buf[len++] = cur;
10543|    227|    NEXT;
  ------------------
  |  | 2275|    227|#define NEXT xmlNextChar(ctxt)
  ------------------
10544|    227|    cur=CUR;
  ------------------
  |  | 2222|    227|#define CUR (*ctxt->input->cur)
  ------------------
10545|    227|    if (cur != '.') {
  ------------------
  |  Branch (10545:9): [True: 0, False: 227]
  ------------------
10546|      0|	xmlFree(buf);
10547|      0|	return(NULL);
10548|      0|    }
10549|    227|    buf[len++] = cur;
10550|    227|    NEXT;
  ------------------
  |  | 2275|    227|#define NEXT xmlNextChar(ctxt)
  ------------------
10551|    227|    cur=CUR;
  ------------------
  |  | 2222|    227|#define CUR (*ctxt->input->cur)
  ------------------
10552|    454|    while ((cur >= '0') && (cur <= '9')) {
  ------------------
  |  Branch (10552:12): [True: 227, False: 227]
  |  Branch (10552:28): [True: 227, False: 0]
  ------------------
10553|    227|	if (len + 1 >= size) {
  ------------------
  |  Branch (10553:6): [True: 0, False: 227]
  ------------------
10554|      0|	    xmlChar *tmp;
10555|       |
10556|      0|	    size *= 2;
10557|      0|	    tmp = (xmlChar *) xmlRealloc(buf, size);
10558|      0|	    if (tmp == NULL) {
  ------------------
  |  Branch (10558:10): [True: 0, False: 0]
  ------------------
10559|      0|	        xmlFree(buf);
10560|      0|		xmlErrMemory(ctxt, NULL);
10561|      0|		return(NULL);
10562|      0|	    }
10563|      0|	    buf = tmp;
10564|      0|	}
10565|    227|	buf[len++] = cur;
10566|    227|	NEXT;
  ------------------
  |  | 2275|    227|#define NEXT xmlNextChar(ctxt)
  ------------------
10567|    227|	cur=CUR;
  ------------------
  |  | 2222|    227|#define CUR (*ctxt->input->cur)
  ------------------
10568|    227|    }
10569|    227|    buf[len] = 0;
10570|    227|    return(buf);
10571|    227|}
xmlParseVersionInfo:
10589|    227|xmlParseVersionInfo(xmlParserCtxtPtr ctxt) {
10590|    227|    xmlChar *version = NULL;
10591|       |
10592|    227|    if (CMP7(CUR_PTR, 'v', 'e', 'r', 's', 'i', 'o', 'n')) {
  ------------------
  |  | 2235|    227|  ( CMP6( s, c1, c2, c3, c4, c5, c6 ) && ((unsigned char *) s)[ 6 ] == c7 )
  |  |  ------------------
  |  |  |  | 2233|    454|  ( CMP5( s, c1, c2, c3, c4, c5 ) && ((unsigned char *) s)[ 5 ] == c6 )
  |  |  |  |  ------------------
  |  |  |  |  |  | 2231|    454|  ( CMP4( s, c1, c2, c3, c4 ) && ((unsigned char *) s)[ 4 ] == c5 )
  |  |  |  |  |  |  ------------------
  |  |  |  |  |  |  |  | 2228|    454|  ( ((unsigned char *) s)[ 0 ] == c1 && ((unsigned char *) s)[ 1 ] == c2 && \
  |  |  |  |  |  |  |  |  ------------------
  |  |  |  |  |  |  |  |  |  Branch (2228:5): [True: 227, False: 0]
  |  |  |  |  |  |  |  |  |  Branch (2228:41): [True: 227, False: 0]
  |  |  |  |  |  |  |  |  ------------------
  |  |  |  |  |  |  |  | 2229|    227|    ((unsigned char *) s)[ 2 ] == c3 && ((unsigned char *) s)[ 3 ] == c4 )
  |  |  |  |  |  |  |  |  ------------------
  |  |  |  |  |  |  |  |  |  Branch (2229:5): [True: 227, False: 0]
  |  |  |  |  |  |  |  |  |  Branch (2229:41): [True: 227, False: 0]
  |  |  |  |  |  |  |  |  ------------------
  |  |  |  |  |  |  ------------------
  |  |  |  |  |  |  |  Branch (2231:34): [True: 227, False: 0]
  |  |  |  |  |  |  ------------------
  |  |  |  |  ------------------
  |  |  |  |  |  Branch (2233:38): [True: 227, False: 0]
  |  |  |  |  ------------------
  |  |  ------------------
  |  |  |  Branch (2235:42): [True: 227, False: 0]
  |  |  ------------------
  ------------------
10593|    227|	SKIP(7);
  ------------------
  |  | 2245|    227|#define SKIP(val) do {							\
  |  | 2246|    227|    ctxt->input->cur += (val),ctxt->input->col+=(val);			\
  |  | 2247|    227|    if (*ctxt->input->cur == 0)						\
  |  |  ------------------
  |  |  |  Branch (2247:9): [True: 0, False: 227]
  |  |  ------------------
  |  | 2248|    227|        xmlParserGrow(ctxt);						\
  |  | 2249|    227|  } while (0)
  |  |  ------------------
  |  |  |  Branch (2249:12): [Folded - Ignored]
  |  |  ------------------
  ------------------
10594|    227|	SKIP_BLANKS;
  ------------------
  |  | 2273|    227|#define SKIP_BLANKS xmlSkipBlankChars(ctxt)
  ------------------
10595|    227|	if (RAW != '=') {
  ------------------
  |  | 2221|    227|#define RAW (*ctxt->input->cur)
  ------------------
  |  Branch (10595:6): [True: 0, False: 227]
  ------------------
10596|      0|	    xmlFatalErr(ctxt, XML_ERR_EQUAL_REQUIRED, NULL);
10597|      0|	    return(NULL);
10598|      0|        }
10599|    227|	NEXT;
  ------------------
  |  | 2275|    227|#define NEXT xmlNextChar(ctxt)
  ------------------
10600|    227|	SKIP_BLANKS;
  ------------------
  |  | 2273|    227|#define SKIP_BLANKS xmlSkipBlankChars(ctxt)
  ------------------
10601|    227|	if (RAW == '"') {
  ------------------
  |  | 2221|    227|#define RAW (*ctxt->input->cur)
  ------------------
  |  Branch (10601:6): [True: 222, False: 5]
  ------------------
10602|    222|	    NEXT;
  ------------------
  |  | 2275|    222|#define NEXT xmlNextChar(ctxt)
  ------------------
10603|    222|	    version = xmlParseVersionNum(ctxt);
10604|    222|	    if (RAW != '"') {
  ------------------
  |  | 2221|    222|#define RAW (*ctxt->input->cur)
  ------------------
  |  Branch (10604:10): [True: 0, False: 222]
  ------------------
10605|      0|		xmlFatalErr(ctxt, XML_ERR_STRING_NOT_CLOSED, NULL);
10606|      0|	    } else
10607|    222|	        NEXT;
  ------------------
  |  | 2275|    222|#define NEXT xmlNextChar(ctxt)
  ------------------
10608|    222|	} else if (RAW == '\''){
  ------------------
  |  | 2221|      5|#define RAW (*ctxt->input->cur)
  ------------------
  |  Branch (10608:13): [True: 5, False: 0]
  ------------------
10609|      5|	    NEXT;
  ------------------
  |  | 2275|      5|#define NEXT xmlNextChar(ctxt)
  ------------------
10610|      5|	    version = xmlParseVersionNum(ctxt);
10611|      5|	    if (RAW != '\'') {
  ------------------
  |  | 2221|      5|#define RAW (*ctxt->input->cur)
  ------------------
  |  Branch (10611:10): [True: 0, False: 5]
  ------------------
10612|      0|		xmlFatalErr(ctxt, XML_ERR_STRING_NOT_CLOSED, NULL);
10613|      0|	    } else
10614|      5|	        NEXT;
  ------------------
  |  | 2275|      5|#define NEXT xmlNextChar(ctxt)
  ------------------
10615|      5|	} else {
10616|      0|	    xmlFatalErr(ctxt, XML_ERR_STRING_NOT_STARTED, NULL);
10617|      0|	}
10618|    227|    }
10619|    227|    return(version);
10620|    227|}
xmlParseEncName:
10635|    125|xmlParseEncName(xmlParserCtxtPtr ctxt) {
10636|    125|    xmlChar *buf = NULL;
10637|    125|    int len = 0;
10638|    125|    int size = 10;
10639|    125|    int maxLength = (ctxt->options & XML_PARSE_HUGE) ?
  ------------------
  |  Branch (10639:21): [True: 0, False: 125]
  ------------------
10640|      0|                    XML_MAX_TEXT_LENGTH :
  ------------------
  |  |   42|      0|#define XML_MAX_TEXT_LENGTH 10000000
  ------------------
10641|    125|                    XML_MAX_NAME_LENGTH;
  ------------------
  |  |   61|    125|#define XML_MAX_NAME_LENGTH 50000
  ------------------
10642|    125|    xmlChar cur;
10643|       |
10644|    125|    cur = CUR;
  ------------------
  |  | 2222|    125|#define CUR (*ctxt->input->cur)
  ------------------
10645|    125|    if (((cur >= 'a') && (cur <= 'z')) ||
  ------------------
  |  Branch (10645:10): [True: 5, False: 120]
  |  Branch (10645:26): [True: 5, False: 0]
  ------------------
10646|    125|        ((cur >= 'A') && (cur <= 'Z'))) {
  ------------------
  |  Branch (10646:10): [True: 120, False: 0]
  |  Branch (10646:26): [True: 120, False: 0]
  ------------------
10647|    125|	buf = (xmlChar *) xmlMallocAtomic(size);
10648|    125|	if (buf == NULL) {
  ------------------
  |  Branch (10648:6): [True: 0, False: 125]
  ------------------
10649|      0|	    xmlErrMemory(ctxt, NULL);
10650|      0|	    return(NULL);
10651|      0|	}
10652|       |
10653|    125|	buf[len++] = cur;
10654|    125|	NEXT;
  ------------------
  |  | 2275|    125|#define NEXT xmlNextChar(ctxt)
  ------------------
10655|    125|	cur = CUR;
  ------------------
  |  | 2222|    125|#define CUR (*ctxt->input->cur)
  ------------------
10656|    877|	while (((cur >= 'a') && (cur <= 'z')) ||
  ------------------
  |  Branch (10656:10): [True: 12, False: 865]
  |  Branch (10656:26): [True: 10, False: 2]
  ------------------
10657|    877|	       ((cur >= 'A') && (cur <= 'Z')) ||
  ------------------
  |  Branch (10657:10): [True: 238, False: 629]
  |  Branch (10657:26): [True: 236, False: 2]
  ------------------
10658|    877|	       ((cur >= '0') && (cur <= '9')) ||
  ------------------
  |  Branch (10658:10): [True: 333, False: 298]
  |  Branch (10658:26): [True: 331, False: 2]
  ------------------
10659|    877|	       (cur == '.') || (cur == '_') ||
  ------------------
  |  Branch (10659:9): [True: 0, False: 300]
  |  Branch (10659:25): [True: 0, False: 300]
  ------------------
10660|    877|	       (cur == '-')) {
  ------------------
  |  Branch (10660:9): [True: 175, False: 125]
  ------------------
10661|    752|	    if (len + 1 >= size) {
  ------------------
  |  Branch (10661:10): [True: 52, False: 700]
  ------------------
10662|     52|	        xmlChar *tmp;
10663|       |
10664|     52|		size *= 2;
10665|     52|		tmp = (xmlChar *) xmlRealloc(buf, size);
10666|     52|		if (tmp == NULL) {
  ------------------
  |  Branch (10666:7): [True: 0, False: 52]
  ------------------
10667|      0|		    xmlErrMemory(ctxt, NULL);
10668|      0|		    xmlFree(buf);
10669|      0|		    return(NULL);
10670|      0|		}
10671|     52|		buf = tmp;
10672|     52|	    }
10673|    752|	    buf[len++] = cur;
10674|    752|            if (len > maxLength) {
  ------------------
  |  Branch (10674:17): [True: 0, False: 752]
  ------------------
10675|      0|                xmlFatalErr(ctxt, XML_ERR_NAME_TOO_LONG, "EncName");
10676|      0|                xmlFree(buf);
10677|      0|                return(NULL);
10678|      0|            }
10679|    752|	    NEXT;
  ------------------
  |  | 2275|    752|#define NEXT xmlNextChar(ctxt)
  ------------------
10680|    752|	    cur = CUR;
  ------------------
  |  | 2222|    752|#define CUR (*ctxt->input->cur)
  ------------------
10681|    752|        }
10682|    125|	buf[len] = 0;
10683|    125|    } else {
10684|      0|	xmlFatalErr(ctxt, XML_ERR_ENCODING_NAME, NULL);
10685|      0|    }
10686|    125|    return(buf);
10687|    125|}
xmlParseEncodingDecl:
10705|    127|xmlParseEncodingDecl(xmlParserCtxtPtr ctxt) {
10706|    127|    xmlChar *encoding = NULL;
10707|       |
10708|    127|    SKIP_BLANKS;
  ------------------
  |  | 2273|    127|#define SKIP_BLANKS xmlSkipBlankChars(ctxt)
  ------------------
10709|    127|    if (CMP8(CUR_PTR, 'e', 'n', 'c', 'o', 'd', 'i', 'n', 'g') == 0)
  ------------------
  |  | 2237|    127|  ( CMP7( s, c1, c2, c3, c4, c5, c6, c7 ) && ((unsigned char *) s)[ 7 ] == c8 )
  |  |  ------------------
  |  |  |  | 2235|    254|  ( CMP6( s, c1, c2, c3, c4, c5, c6 ) && ((unsigned char *) s)[ 6 ] == c7 )
  |  |  |  |  ------------------
  |  |  |  |  |  | 2233|    254|  ( CMP5( s, c1, c2, c3, c4, c5 ) && ((unsigned char *) s)[ 5 ] == c6 )
  |  |  |  |  |  |  ------------------
  |  |  |  |  |  |  |  | 2231|    254|  ( CMP4( s, c1, c2, c3, c4 ) && ((unsigned char *) s)[ 4 ] == c5 )
  |  |  |  |  |  |  |  |  ------------------
  |  |  |  |  |  |  |  |  |  | 2228|    254|  ( ((unsigned char *) s)[ 0 ] == c1 && ((unsigned char *) s)[ 1 ] == c2 && \
  |  |  |  |  |  |  |  |  |  |  ------------------
  |  |  |  |  |  |  |  |  |  |  |  Branch (2228:5): [True: 125, False: 2]
  |  |  |  |  |  |  |  |  |  |  |  Branch (2228:41): [True: 125, False: 0]
  |  |  |  |  |  |  |  |  |  |  ------------------
  |  |  |  |  |  |  |  |  |  | 2229|    127|    ((unsigned char *) s)[ 2 ] == c3 && ((unsigned char *) s)[ 3 ] == c4 )
  |  |  |  |  |  |  |  |  |  |  ------------------
  |  |  |  |  |  |  |  |  |  |  |  Branch (2229:5): [True: 125, False: 0]
  |  |  |  |  |  |  |  |  |  |  |  Branch (2229:41): [True: 125, False: 0]
  |  |  |  |  |  |  |  |  |  |  ------------------
  |  |  |  |  |  |  |  |  ------------------
  |  |  |  |  |  |  |  |  |  Branch (2231:34): [True: 125, False: 0]
  |  |  |  |  |  |  |  |  ------------------
  |  |  |  |  |  |  ------------------
  |  |  |  |  |  |  |  Branch (2233:38): [True: 125, False: 0]
  |  |  |  |  |  |  ------------------
  |  |  |  |  ------------------
  |  |  |  |  |  Branch (2235:42): [True: 125, False: 0]
  |  |  |  |  ------------------
  |  |  ------------------
  |  |  |  Branch (2237:46): [True: 125, False: 0]
  |  |  ------------------
  ------------------
  |  Branch (10709:9): [True: 2, False: 125]
  ------------------
10710|      2|        return(NULL);
10711|       |
10712|    125|    SKIP(8);
  ------------------
  |  | 2245|    125|#define SKIP(val) do {							\
  |  | 2246|    125|    ctxt->input->cur += (val),ctxt->input->col+=(val);			\
  |  | 2247|    125|    if (*ctxt->input->cur == 0)						\
  |  |  ------------------
  |  |  |  Branch (2247:9): [True: 0, False: 125]
  |  |  ------------------
  |  | 2248|    125|        xmlParserGrow(ctxt);						\
  |  | 2249|    125|  } while (0)
  |  |  ------------------
  |  |  |  Branch (2249:12): [Folded - Ignored]
  |  |  ------------------
  ------------------
10713|    125|    SKIP_BLANKS;
  ------------------
  |  | 2273|    125|#define SKIP_BLANKS xmlSkipBlankChars(ctxt)
  ------------------
10714|    125|    if (RAW != '=') {
  ------------------
  |  | 2221|    125|#define RAW (*ctxt->input->cur)
  ------------------
  |  Branch (10714:9): [True: 0, False: 125]
  ------------------
10715|      0|        xmlFatalErr(ctxt, XML_ERR_EQUAL_REQUIRED, NULL);
10716|      0|        return(NULL);
10717|      0|    }
10718|    125|    NEXT;
  ------------------
  |  | 2275|    125|#define NEXT xmlNextChar(ctxt)
  ------------------
10719|    125|    SKIP_BLANKS;
  ------------------
  |  | 2273|    125|#define SKIP_BLANKS xmlSkipBlankChars(ctxt)
  ------------------
10720|    125|    if (RAW == '"') {
  ------------------
  |  | 2221|    125|#define RAW (*ctxt->input->cur)
  ------------------
  |  Branch (10720:9): [True: 122, False: 3]
  ------------------
10721|    122|        NEXT;
  ------------------
  |  | 2275|    122|#define NEXT xmlNextChar(ctxt)
  ------------------
10722|    122|        encoding = xmlParseEncName(ctxt);
10723|    122|        if (RAW != '"') {
  ------------------
  |  | 2221|    122|#define RAW (*ctxt->input->cur)
  ------------------
  |  Branch (10723:13): [True: 2, False: 120]
  ------------------
10724|      2|            xmlFatalErr(ctxt, XML_ERR_STRING_NOT_CLOSED, NULL);
10725|      2|            xmlFree((xmlChar *) encoding);
10726|      2|            return(NULL);
10727|      2|        } else
10728|    120|            NEXT;
  ------------------
  |  | 2275|    120|#define NEXT xmlNextChar(ctxt)
  ------------------
10729|    122|    } else if (RAW == '\''){
  ------------------
  |  | 2221|      3|#define RAW (*ctxt->input->cur)
  ------------------
  |  Branch (10729:16): [True: 3, False: 0]
  ------------------
10730|      3|        NEXT;
  ------------------
  |  | 2275|      3|#define NEXT xmlNextChar(ctxt)
  ------------------
10731|      3|        encoding = xmlParseEncName(ctxt);
10732|      3|        if (RAW != '\'') {
  ------------------
  |  | 2221|      3|#define RAW (*ctxt->input->cur)
  ------------------
  |  Branch (10732:13): [True: 0, False: 3]
  ------------------
10733|      0|            xmlFatalErr(ctxt, XML_ERR_STRING_NOT_CLOSED, NULL);
10734|      0|            xmlFree((xmlChar *) encoding);
10735|      0|            return(NULL);
10736|      0|        } else
10737|      3|            NEXT;
  ------------------
  |  | 2275|      3|#define NEXT xmlNextChar(ctxt)
  ------------------
10738|      3|    } else {
10739|      0|        xmlFatalErr(ctxt, XML_ERR_STRING_NOT_STARTED, NULL);
10740|      0|    }
10741|       |
10742|    123|    if (encoding == NULL)
  ------------------
  |  Branch (10742:9): [True: 0, False: 123]
  ------------------
10743|      0|        return(NULL);
10744|       |
10745|    123|    xmlSetDeclaredEncoding(ctxt, encoding);
10746|       |
10747|    123|    return(ctxt->encoding);
10748|    123|}
xmlParseSDDecl:
10784|     34|xmlParseSDDecl(xmlParserCtxtPtr ctxt) {
10785|     34|    int standalone = -2;
10786|       |
10787|     34|    SKIP_BLANKS;
  ------------------
  |  | 2273|     34|#define SKIP_BLANKS xmlSkipBlankChars(ctxt)
  ------------------
10788|     34|    if (CMP10(CUR_PTR, 's', 't', 'a', 'n', 'd', 'a', 'l', 'o', 'n', 'e')) {
  ------------------
  |  | 2242|     34|  ( CMP9( s, c1, c2, c3, c4, c5, c6, c7, c8, c9 ) && \
  |  |  ------------------
  |  |  |  | 2239|     68|  ( CMP8( s, c1, c2, c3, c4, c5, c6, c7, c8 ) && \
  |  |  |  |  ------------------
  |  |  |  |  |  | 2237|     68|  ( CMP7( s, c1, c2, c3, c4, c5, c6, c7 ) && ((unsigned char *) s)[ 7 ] == c8 )
  |  |  |  |  |  |  ------------------
  |  |  |  |  |  |  |  | 2235|     68|  ( CMP6( s, c1, c2, c3, c4, c5, c6 ) && ((unsigned char *) s)[ 6 ] == c7 )
  |  |  |  |  |  |  |  |  ------------------
  |  |  |  |  |  |  |  |  |  | 2233|     68|  ( CMP5( s, c1, c2, c3, c4, c5 ) && ((unsigned char *) s)[ 5 ] == c6 )
  |  |  |  |  |  |  |  |  |  |  ------------------
  |  |  |  |  |  |  |  |  |  |  |  | 2231|     68|  ( CMP4( s, c1, c2, c3, c4 ) && ((unsigned char *) s)[ 4 ] == c5 )
  |  |  |  |  |  |  |  |  |  |  |  |  ------------------
  |  |  |  |  |  |  |  |  |  |  |  |  |  | 2228|     68|  ( ((unsigned char *) s)[ 0 ] == c1 && ((unsigned char *) s)[ 1 ] == c2 && \
  |  |  |  |  |  |  |  |  |  |  |  |  |  |  ------------------
  |  |  |  |  |  |  |  |  |  |  |  |  |  |  |  Branch (2228:5): [True: 0, False: 34]
  |  |  |  |  |  |  |  |  |  |  |  |  |  |  |  Branch (2228:41): [True: 0, False: 0]
  |  |  |  |  |  |  |  |  |  |  |  |  |  |  ------------------
  |  |  |  |  |  |  |  |  |  |  |  |  |  | 2229|     34|    ((unsigned char *) s)[ 2 ] == c3 && ((unsigned char *) s)[ 3 ] == c4 )
  |  |  |  |  |  |  |  |  |  |  |  |  |  |  ------------------
  |  |  |  |  |  |  |  |  |  |  |  |  |  |  |  Branch (2229:5): [True: 0, False: 0]
  |  |  |  |  |  |  |  |  |  |  |  |  |  |  |  Branch (2229:41): [True: 0, False: 0]
  |  |  |  |  |  |  |  |  |  |  |  |  |  |  ------------------
  |  |  |  |  |  |  |  |  |  |  |  |  ------------------
  |  |  |  |  |  |  |  |  |  |  |  |  |  Branch (2231:34): [True: 0, False: 0]
  |  |  |  |  |  |  |  |  |  |  |  |  ------------------
  |  |  |  |  |  |  |  |  |  |  ------------------
  |  |  |  |  |  |  |  |  |  |  |  Branch (2233:38): [True: 0, False: 0]
  |  |  |  |  |  |  |  |  |  |  ------------------
  |  |  |  |  |  |  |  |  ------------------
  |  |  |  |  |  |  |  |  |  Branch (2235:42): [True: 0, False: 0]
  |  |  |  |  |  |  |  |  ------------------
  |  |  |  |  |  |  ------------------
  |  |  |  |  |  |  |  Branch (2237:46): [True: 0, False: 0]
  |  |  |  |  |  |  ------------------
  |  |  |  |  ------------------
  |  |  |  | 2240|     68|    ((unsigned char *) s)[ 8 ] == c9 )
  |  |  |  |  ------------------
  |  |  |  |  |  Branch (2240:5): [True: 0, False: 0]
  |  |  |  |  ------------------
  |  |  ------------------
  |  | 2243|     34|    ((unsigned char *) s)[ 9 ] == c10 )
  |  |  ------------------
  |  |  |  Branch (2243:5): [True: 0, False: 0]
  |  |  ------------------
  ------------------
10789|      0|	SKIP(10);
  ------------------
  |  | 2245|      0|#define SKIP(val) do {							\
  |  | 2246|      0|    ctxt->input->cur += (val),ctxt->input->col+=(val);			\
  |  | 2247|      0|    if (*ctxt->input->cur == 0)						\
  |  |  ------------------
  |  |  |  Branch (2247:9): [True: 0, False: 0]
  |  |  ------------------
  |  | 2248|      0|        xmlParserGrow(ctxt);						\
  |  | 2249|      0|  } while (0)
  |  |  ------------------
  |  |  |  Branch (2249:12): [Folded - Ignored]
  |  |  ------------------
  ------------------
10790|      0|        SKIP_BLANKS;
  ------------------
  |  | 2273|      0|#define SKIP_BLANKS xmlSkipBlankChars(ctxt)
  ------------------
10791|      0|	if (RAW != '=') {
  ------------------
  |  | 2221|      0|#define RAW (*ctxt->input->cur)
  ------------------
  |  Branch (10791:6): [True: 0, False: 0]
  ------------------
10792|      0|	    xmlFatalErr(ctxt, XML_ERR_EQUAL_REQUIRED, NULL);
10793|      0|	    return(standalone);
10794|      0|        }
10795|      0|	NEXT;
  ------------------
  |  | 2275|      0|#define NEXT xmlNextChar(ctxt)
  ------------------
10796|      0|	SKIP_BLANKS;
  ------------------
  |  | 2273|      0|#define SKIP_BLANKS xmlSkipBlankChars(ctxt)
  ------------------
10797|      0|        if (RAW == '\''){
  ------------------
  |  | 2221|      0|#define RAW (*ctxt->input->cur)
  ------------------
  |  Branch (10797:13): [True: 0, False: 0]
  ------------------
10798|      0|	    NEXT;
  ------------------
  |  | 2275|      0|#define NEXT xmlNextChar(ctxt)
  ------------------
10799|      0|	    if ((RAW == 'n') && (NXT(1) == 'o')) {
  ------------------
  |  | 2221|      0|#define RAW (*ctxt->input->cur)
  ------------------
              	    if ((RAW == 'n') && (NXT(1) == 'o')) {
  ------------------
  |  | 2223|      0|#define NXT(val) ctxt->input->cur[(val)]
  ------------------
  |  Branch (10799:10): [True: 0, False: 0]
  |  Branch (10799:26): [True: 0, False: 0]
  ------------------
10800|      0|	        standalone = 0;
10801|      0|                SKIP(2);
  ------------------
  |  | 2245|      0|#define SKIP(val) do {							\
  |  | 2246|      0|    ctxt->input->cur += (val),ctxt->input->col+=(val);			\
  |  | 2247|      0|    if (*ctxt->input->cur == 0)						\
  |  |  ------------------
  |  |  |  Branch (2247:9): [True: 0, False: 0]
  |  |  ------------------
  |  | 2248|      0|        xmlParserGrow(ctxt);						\
  |  | 2249|      0|  } while (0)
  |  |  ------------------
  |  |  |  Branch (2249:12): [Folded - Ignored]
  |  |  ------------------
  ------------------
10802|      0|	    } else if ((RAW == 'y') && (NXT(1) == 'e') &&
  ------------------
  |  | 2221|      0|#define RAW (*ctxt->input->cur)
  ------------------
              	    } else if ((RAW == 'y') && (NXT(1) == 'e') &&
  ------------------
  |  | 2223|      0|#define NXT(val) ctxt->input->cur[(val)]
  ------------------
  |  Branch (10802:17): [True: 0, False: 0]
  |  Branch (10802:33): [True: 0, False: 0]
  ------------------
10803|      0|	               (NXT(2) == 's')) {
  ------------------
  |  | 2223|      0|#define NXT(val) ctxt->input->cur[(val)]
  ------------------
  |  Branch (10803:17): [True: 0, False: 0]
  ------------------
10804|      0|	        standalone = 1;
10805|      0|		SKIP(3);
  ------------------
  |  | 2245|      0|#define SKIP(val) do {							\
  |  | 2246|      0|    ctxt->input->cur += (val),ctxt->input->col+=(val);			\
  |  | 2247|      0|    if (*ctxt->input->cur == 0)						\
  |  |  ------------------
  |  |  |  Branch (2247:9): [True: 0, False: 0]
  |  |  ------------------
  |  | 2248|      0|        xmlParserGrow(ctxt);						\
  |  | 2249|      0|  } while (0)
  |  |  ------------------
  |  |  |  Branch (2249:12): [Folded - Ignored]
  |  |  ------------------
  ------------------
10806|      0|            } else {
10807|      0|		xmlFatalErr(ctxt, XML_ERR_STANDALONE_VALUE, NULL);
10808|      0|	    }
10809|      0|	    if (RAW != '\'') {
  ------------------
  |  | 2221|      0|#define RAW (*ctxt->input->cur)
  ------------------
  |  Branch (10809:10): [True: 0, False: 0]
  ------------------
10810|      0|		xmlFatalErr(ctxt, XML_ERR_STRING_NOT_CLOSED, NULL);
10811|      0|	    } else
10812|      0|	        NEXT;
  ------------------
  |  | 2275|      0|#define NEXT xmlNextChar(ctxt)
  ------------------
10813|      0|	} else if (RAW == '"'){
  ------------------
  |  | 2221|      0|#define RAW (*ctxt->input->cur)
  ------------------
  |  Branch (10813:13): [True: 0, False: 0]
  ------------------
10814|      0|	    NEXT;
  ------------------
  |  | 2275|      0|#define NEXT xmlNextChar(ctxt)
  ------------------
10815|      0|	    if ((RAW == 'n') && (NXT(1) == 'o')) {
  ------------------
  |  | 2221|      0|#define RAW (*ctxt->input->cur)
  ------------------
              	    if ((RAW == 'n') && (NXT(1) == 'o')) {
  ------------------
  |  | 2223|      0|#define NXT(val) ctxt->input->cur[(val)]
  ------------------
  |  Branch (10815:10): [True: 0, False: 0]
  |  Branch (10815:26): [True: 0, False: 0]
  ------------------
10816|      0|	        standalone = 0;
10817|      0|		SKIP(2);
  ------------------
  |  | 2245|      0|#define SKIP(val) do {							\
  |  | 2246|      0|    ctxt->input->cur += (val),ctxt->input->col+=(val);			\
  |  | 2247|      0|    if (*ctxt->input->cur == 0)						\
  |  |  ------------------
  |  |  |  Branch (2247:9): [True: 0, False: 0]
  |  |  ------------------
  |  | 2248|      0|        xmlParserGrow(ctxt);						\
  |  | 2249|      0|  } while (0)
  |  |  ------------------
  |  |  |  Branch (2249:12): [Folded - Ignored]
  |  |  ------------------
  ------------------
10818|      0|	    } else if ((RAW == 'y') && (NXT(1) == 'e') &&
  ------------------
  |  | 2221|      0|#define RAW (*ctxt->input->cur)
  ------------------
              	    } else if ((RAW == 'y') && (NXT(1) == 'e') &&
  ------------------
  |  | 2223|      0|#define NXT(val) ctxt->input->cur[(val)]
  ------------------
  |  Branch (10818:17): [True: 0, False: 0]
  |  Branch (10818:33): [True: 0, False: 0]
  ------------------
10819|      0|	               (NXT(2) == 's')) {
  ------------------
  |  | 2223|      0|#define NXT(val) ctxt->input->cur[(val)]
  ------------------
  |  Branch (10819:17): [True: 0, False: 0]
  ------------------
10820|      0|	        standalone = 1;
10821|      0|                SKIP(3);
  ------------------
  |  | 2245|      0|#define SKIP(val) do {							\
  |  | 2246|      0|    ctxt->input->cur += (val),ctxt->input->col+=(val);			\
  |  | 2247|      0|    if (*ctxt->input->cur == 0)						\
  |  |  ------------------
  |  |  |  Branch (2247:9): [True: 0, False: 0]
  |  |  ------------------
  |  | 2248|      0|        xmlParserGrow(ctxt);						\
  |  | 2249|      0|  } while (0)
  |  |  ------------------
  |  |  |  Branch (2249:12): [Folded - Ignored]
  |  |  ------------------
  ------------------
10822|      0|            } else {
10823|      0|		xmlFatalErr(ctxt, XML_ERR_STANDALONE_VALUE, NULL);
10824|      0|	    }
10825|      0|	    if (RAW != '"') {
  ------------------
  |  | 2221|      0|#define RAW (*ctxt->input->cur)
  ------------------
  |  Branch (10825:10): [True: 0, False: 0]
  ------------------
10826|      0|		xmlFatalErr(ctxt, XML_ERR_STRING_NOT_CLOSED, NULL);
10827|      0|	    } else
10828|      0|	        NEXT;
  ------------------
  |  | 2275|      0|#define NEXT xmlNextChar(ctxt)
  ------------------
10829|      0|	} else {
10830|      0|	    xmlFatalErr(ctxt, XML_ERR_STRING_NOT_STARTED, NULL);
10831|      0|        }
10832|      0|    }
10833|     34|    return(standalone);
10834|     34|}
xmlParseXMLDecl:
10848|    227|xmlParseXMLDecl(xmlParserCtxtPtr ctxt) {
10849|    227|    xmlChar *version;
10850|       |
10851|       |    /*
10852|       |     * This value for standalone indicates that the document has an
10853|       |     * XML declaration but it does not have a standalone attribute.
10854|       |     * It will be overwritten later if a standalone attribute is found.
10855|       |     */
10856|       |
10857|    227|    ctxt->standalone = -2;
10858|       |
10859|       |    /*
10860|       |     * We know that '<?xml' is here.
10861|       |     */
10862|    227|    SKIP(5);
  ------------------
  |  | 2245|    227|#define SKIP(val) do {							\
  |  | 2246|    227|    ctxt->input->cur += (val),ctxt->input->col+=(val);			\
  |  | 2247|    227|    if (*ctxt->input->cur == 0)						\
  |  |  ------------------
  |  |  |  Branch (2247:9): [True: 0, False: 227]
  |  |  ------------------
  |  | 2248|    227|        xmlParserGrow(ctxt);						\
  |  | 2249|    227|  } while (0)
  |  |  ------------------
  |  |  |  Branch (2249:12): [Folded - Ignored]
  |  |  ------------------
  ------------------
10863|       |
10864|    227|    if (!IS_BLANK_CH(RAW)) {
  ------------------
  |  |  151|    227|#define IS_BLANK_CH(c)  xmlIsBlank_ch(c)
  |  |  ------------------
  |  |  |  |   88|    227|#define xmlIsBlank_ch(c)	(((c) == 0x20) || \
  |  |  |  |  ------------------
  |  |  |  |  |  Branch (88:27): [True: 227, False: 0]
  |  |  |  |  ------------------
  |  |  |  |   89|    227|				 ((0x9 <= (c)) && ((c) <= 0xa)) || \
  |  |  |  |  ------------------
  |  |  |  |  |  Branch (89:7): [True: 0, False: 0]
  |  |  |  |  |  Branch (89:23): [True: 0, False: 0]
  |  |  |  |  ------------------
  |  |  |  |   90|    227|				 ((c) == 0xd))
  |  |  |  |  ------------------
  |  |  |  |  |  Branch (90:6): [True: 0, False: 0]
  |  |  |  |  ------------------
  |  |  ------------------
  ------------------
10865|      0|	xmlFatalErrMsg(ctxt, XML_ERR_SPACE_REQUIRED,
10866|      0|	               "Blank needed after '<?xml'\n");
10867|      0|    }
10868|    227|    SKIP_BLANKS;
  ------------------
  |  | 2273|    227|#define SKIP_BLANKS xmlSkipBlankChars(ctxt)
  ------------------
10869|       |
10870|       |    /*
10871|       |     * We must have the VersionInfo here.
10872|       |     */
10873|    227|    version = xmlParseVersionInfo(ctxt);
10874|    227|    if (version == NULL) {
  ------------------
  |  Branch (10874:9): [True: 0, False: 227]
  ------------------
10875|      0|	xmlFatalErr(ctxt, XML_ERR_VERSION_MISSING, NULL);
10876|    227|    } else {
10877|    227|	if (!xmlStrEqual(version, (const xmlChar *) XML_DEFAULT_VERSION)) {
  ------------------
  |  |   37|    227|#define XML_DEFAULT_VERSION	"1.0"
  ------------------
  |  Branch (10877:6): [True: 0, False: 227]
  ------------------
10878|       |	    /*
10879|       |	     * Changed here for XML-1.0 5th edition
10880|       |	     */
10881|      0|	    if (ctxt->options & XML_PARSE_OLD10) {
  ------------------
  |  Branch (10881:10): [True: 0, False: 0]
  ------------------
10882|      0|		xmlFatalErrMsgStr(ctxt, XML_ERR_UNKNOWN_VERSION,
10883|      0|			          "Unsupported version '%s'\n",
10884|      0|			          version);
10885|      0|	    } else {
10886|      0|	        if ((version[0] == '1') && ((version[1] == '.'))) {
  ------------------
  |  Branch (10886:14): [True: 0, False: 0]
  |  Branch (10886:37): [True: 0, False: 0]
  ------------------
10887|      0|		    xmlWarningMsg(ctxt, XML_WAR_UNKNOWN_VERSION,
10888|      0|		                  "Unsupported version '%s'\n",
10889|      0|				  version, NULL);
10890|      0|		} else {
10891|      0|		    xmlFatalErrMsgStr(ctxt, XML_ERR_UNKNOWN_VERSION,
10892|      0|				      "Unsupported version '%s'\n",
10893|      0|				      version);
10894|      0|		}
10895|      0|	    }
10896|      0|	}
10897|    227|	if (ctxt->version != NULL)
  ------------------
  |  Branch (10897:6): [True: 0, False: 227]
  ------------------
10898|      0|	    xmlFree((void *) ctxt->version);
10899|    227|	ctxt->version = version;
10900|    227|    }
10901|       |
10902|       |    /*
10903|       |     * We may have the encoding declaration
10904|       |     */
10905|    227|    if (!IS_BLANK_CH(RAW)) {
  ------------------
  |  |  151|    227|#define IS_BLANK_CH(c)  xmlIsBlank_ch(c)
  |  |  ------------------
  |  |  |  |   88|    227|#define xmlIsBlank_ch(c)	(((c) == 0x20) || \
  |  |  |  |  ------------------
  |  |  |  |  |  Branch (88:27): [True: 127, False: 100]
  |  |  |  |  ------------------
  |  |  |  |   89|    227|				 ((0x9 <= (c)) && ((c) <= 0xa)) || \
  |  |  |  |  ------------------
  |  |  |  |  |  Branch (89:7): [True: 100, False: 0]
  |  |  |  |  |  Branch (89:23): [True: 0, False: 100]
  |  |  |  |  ------------------
  |  |  |  |   90|    227|				 ((c) == 0xd))
  |  |  |  |  ------------------
  |  |  |  |  |  Branch (90:6): [True: 0, False: 100]
  |  |  |  |  ------------------
  |  |  ------------------
  ------------------
10906|    100|        if ((RAW == '?') && (NXT(1) == '>')) {
  ------------------
  |  | 2221|    100|#define RAW (*ctxt->input->cur)
  ------------------
                      if ((RAW == '?') && (NXT(1) == '>')) {
  ------------------
  |  | 2223|    100|#define NXT(val) ctxt->input->cur[(val)]
  ------------------
  |  Branch (10906:13): [True: 100, False: 0]
  |  Branch (10906:29): [True: 100, False: 0]
  ------------------
10907|    100|	    SKIP(2);
  ------------------
  |  | 2245|    100|#define SKIP(val) do {							\
  |  | 2246|    100|    ctxt->input->cur += (val),ctxt->input->col+=(val);			\
  |  | 2247|    100|    if (*ctxt->input->cur == 0)						\
  |  |  ------------------
  |  |  |  Branch (2247:9): [True: 0, False: 100]
  |  |  ------------------
  |  | 2248|    100|        xmlParserGrow(ctxt);						\
  |  | 2249|    100|  } while (0)
  |  |  ------------------
  |  |  |  Branch (2249:12): [Folded - Ignored]
  |  |  ------------------
  ------------------
10908|    100|	    return;
10909|    100|	}
10910|      0|	xmlFatalErrMsg(ctxt, XML_ERR_SPACE_REQUIRED, "Blank needed here\n");
10911|      0|    }
10912|    127|    xmlParseEncodingDecl(ctxt);
10913|    127|    if ((ctxt->errNo == XML_ERR_UNSUPPORTED_ENCODING) ||
  ------------------
  |  Branch (10913:9): [True: 0, False: 127]
  ------------------
10914|    127|         (ctxt->instate == XML_PARSER_EOF)) {
  ------------------
  |  Branch (10914:10): [True: 0, False: 127]
  ------------------
10915|       |	/*
10916|       |	 * The XML REC instructs us to stop parsing right here
10917|       |	 */
10918|      0|        return;
10919|      0|    }
10920|       |
10921|       |    /*
10922|       |     * We may have the standalone status.
10923|       |     */
10924|    127|    if ((ctxt->encoding != NULL) && (!IS_BLANK_CH(RAW))) {
  ------------------
  |  |  151|    123|#define IS_BLANK_CH(c)  xmlIsBlank_ch(c)
  |  |  ------------------
  |  |  |  |   88|    123|#define xmlIsBlank_ch(c)	(((c) == 0x20) || \
  |  |  |  |  ------------------
  |  |  |  |  |  Branch (88:27): [True: 30, False: 93]
  |  |  |  |  ------------------
  |  |  |  |   89|    123|				 ((0x9 <= (c)) && ((c) <= 0xa)) || \
  |  |  |  |  ------------------
  |  |  |  |  |  Branch (89:7): [True: 93, False: 0]
  |  |  |  |  |  Branch (89:23): [True: 0, False: 93]
  |  |  |  |  ------------------
  |  |  |  |   90|    123|				 ((c) == 0xd))
  |  |  |  |  ------------------
  |  |  |  |  |  Branch (90:6): [True: 0, False: 93]
  |  |  |  |  ------------------
  |  |  ------------------
  ------------------
  |  Branch (10924:9): [True: 123, False: 4]
  ------------------
10925|     93|        if ((RAW == '?') && (NXT(1) == '>')) {
  ------------------
  |  | 2221|     93|#define RAW (*ctxt->input->cur)
  ------------------
                      if ((RAW == '?') && (NXT(1) == '>')) {
  ------------------
  |  | 2223|     93|#define NXT(val) ctxt->input->cur[(val)]
  ------------------
  |  Branch (10925:13): [True: 93, False: 0]
  |  Branch (10925:29): [True: 93, False: 0]
  ------------------
10926|     93|	    SKIP(2);
  ------------------
  |  | 2245|     93|#define SKIP(val) do {							\
  |  | 2246|     93|    ctxt->input->cur += (val),ctxt->input->col+=(val);			\
  |  | 2247|     93|    if (*ctxt->input->cur == 0)						\
  |  |  ------------------
  |  |  |  Branch (2247:9): [True: 0, False: 93]
  |  |  ------------------
  |  | 2248|     93|        xmlParserGrow(ctxt);						\
  |  | 2249|     93|  } while (0)
  |  |  ------------------
  |  |  |  Branch (2249:12): [Folded - Ignored]
  |  |  ------------------
  ------------------
10927|     93|	    return;
10928|     93|	}
10929|      0|	xmlFatalErrMsg(ctxt, XML_ERR_SPACE_REQUIRED, "Blank needed here\n");
10930|      0|    }
10931|       |
10932|       |    /*
10933|       |     * We can grow the input buffer freely at that point
10934|       |     */
10935|     34|    GROW;
  ------------------
  |  | 2270|     34|#define GROW if (ctxt->input->end - ctxt->input->cur < INPUT_CHUNK)	\
  |  |  ------------------
  |  |  |  |   97|     34|#define INPUT_CHUNK	250
  |  |  ------------------
  |  |  |  Branch (2270:18): [True: 0, False: 34]
  |  |  ------------------
  |  | 2271|     34|	xmlParserGrow(ctxt);
  ------------------
10936|       |
10937|     34|    SKIP_BLANKS;
  ------------------
  |  | 2273|     34|#define SKIP_BLANKS xmlSkipBlankChars(ctxt)
  ------------------
10938|     34|    ctxt->standalone = xmlParseSDDecl(ctxt);
10939|       |
10940|     34|    SKIP_BLANKS;
  ------------------
  |  | 2273|     34|#define SKIP_BLANKS xmlSkipBlankChars(ctxt)
  ------------------
10941|     34|    if ((RAW == '?') && (NXT(1) == '>')) {
  ------------------
  |  | 2221|     34|#define RAW (*ctxt->input->cur)
  ------------------
                  if ((RAW == '?') && (NXT(1) == '>')) {
  ------------------
  |  | 2223|     32|#define NXT(val) ctxt->input->cur[(val)]
  ------------------
  |  Branch (10941:9): [True: 32, False: 2]
  |  Branch (10941:25): [True: 32, False: 0]
  ------------------
10942|     32|        SKIP(2);
  ------------------
  |  | 2245|     32|#define SKIP(val) do {							\
  |  | 2246|     32|    ctxt->input->cur += (val),ctxt->input->col+=(val);			\
  |  | 2247|     32|    if (*ctxt->input->cur == 0)						\
  |  |  ------------------
  |  |  |  Branch (2247:9): [True: 0, False: 32]
  |  |  ------------------
  |  | 2248|     32|        xmlParserGrow(ctxt);						\
  |  | 2249|     32|  } while (0)
  |  |  ------------------
  |  |  |  Branch (2249:12): [Folded - Ignored]
  |  |  ------------------
  ------------------
10943|     32|    } else if (RAW == '>') {
  ------------------
  |  | 2221|      2|#define RAW (*ctxt->input->cur)
  ------------------
  |  Branch (10943:16): [True: 0, False: 2]
  ------------------
10944|       |        /* Deprecated old WD ... */
10945|      0|	xmlFatalErr(ctxt, XML_ERR_XMLDECL_NOT_FINISHED, NULL);
10946|      0|	NEXT;
  ------------------
  |  | 2275|      0|#define NEXT xmlNextChar(ctxt)
  ------------------
10947|      2|    } else {
10948|      2|        int c;
10949|       |
10950|      2|	xmlFatalErr(ctxt, XML_ERR_XMLDECL_NOT_FINISHED, NULL);
10951|     42|        while ((c = CUR) != 0) {
  ------------------
  |  | 2222|     42|#define CUR (*ctxt->input->cur)
  ------------------
  |  Branch (10951:16): [True: 42, False: 0]
  ------------------
10952|     42|            NEXT;
  ------------------
  |  | 2275|     42|#define NEXT xmlNextChar(ctxt)
  ------------------
10953|     42|            if (c == '>')
  ------------------
  |  Branch (10953:17): [True: 2, False: 40]
  ------------------
10954|      2|                break;
10955|     42|        }
10956|      2|    }
10957|     34|}
xmlParseMisc:
10971|    473|xmlParseMisc(xmlParserCtxtPtr ctxt) {
10972|    550|    while (ctxt->instate != XML_PARSER_EOF) {
  ------------------
  |  Branch (10972:12): [True: 550, False: 0]
  ------------------
10973|    550|        SKIP_BLANKS;
  ------------------
  |  | 2273|    550|#define SKIP_BLANKS xmlSkipBlankChars(ctxt)
  ------------------
10974|    550|        GROW;
  ------------------
  |  | 2270|    550|#define GROW if (ctxt->input->end - ctxt->input->cur < INPUT_CHUNK)	\
  |  |  ------------------
  |  |  |  |   97|    550|#define INPUT_CHUNK	250
  |  |  ------------------
  |  |  |  Branch (2270:18): [True: 288, False: 262]
  |  |  ------------------
  |  | 2271|    550|	xmlParserGrow(ctxt);
  ------------------
10975|    550|        if ((RAW == '<') && (NXT(1) == '?')) {
  ------------------
  |  | 2221|    550|#define RAW (*ctxt->input->cur)
  ------------------
                      if ((RAW == '<') && (NXT(1) == '?')) {
  ------------------
  |  | 2223|    320|#define NXT(val) ctxt->input->cur[(val)]
  ------------------
  |  Branch (10975:13): [True: 320, False: 230]
  |  Branch (10975:29): [True: 0, False: 320]
  ------------------
10976|      0|	    xmlParsePI(ctxt);
10977|    550|        } else if (CMP4(CUR_PTR, '<', '!', '-', '-')) {
  ------------------
  |  | 2228|    550|  ( ((unsigned char *) s)[ 0 ] == c1 && ((unsigned char *) s)[ 1 ] == c2 && \
  |  |  ------------------
  |  |  |  Branch (2228:5): [True: 320, False: 230]
  |  |  |  Branch (2228:41): [True: 77, False: 243]
  |  |  ------------------
  |  | 2229|    550|    ((unsigned char *) s)[ 2 ] == c3 && ((unsigned char *) s)[ 3 ] == c4 )
  |  |  ------------------
  |  |  |  Branch (2229:5): [True: 77, False: 0]
  |  |  |  Branch (2229:41): [True: 77, False: 0]
  |  |  ------------------
  ------------------
10978|     77|	    xmlParseComment(ctxt);
10979|    473|        } else {
10980|    473|            break;
10981|    473|        }
10982|    550|    }
10983|    473|}
xmlParseDocument:
11001|    238|xmlParseDocument(xmlParserCtxtPtr ctxt) {
11002|    238|    xmlInitParser();
11003|       |
11004|    238|    if ((ctxt == NULL) || (ctxt->input == NULL))
  ------------------
  |  Branch (11004:9): [True: 0, False: 238]
  |  Branch (11004:27): [True: 0, False: 238]
  ------------------
11005|      0|        return(-1);
11006|       |
11007|    238|    GROW;
  ------------------
  |  | 2270|    238|#define GROW if (ctxt->input->end - ctxt->input->cur < INPUT_CHUNK)	\
  |  |  ------------------
  |  |  |  |   97|    238|#define INPUT_CHUNK	250
  |  |  ------------------
  |  |  |  Branch (2270:18): [True: 238, False: 0]
  |  |  ------------------
  |  | 2271|    238|	xmlParserGrow(ctxt);
  ------------------
11008|       |
11009|       |    /*
11010|       |     * SAX: detecting the level.
11011|       |     */
11012|    238|    xmlDetectSAX2(ctxt);
11013|       |
11014|       |    /*
11015|       |     * SAX: beginning of the document processing.
11016|       |     */
11017|    238|    if ((ctxt->sax) && (ctxt->sax->setDocumentLocator))
  ------------------
  |  Branch (11017:9): [True: 238, False: 0]
  |  Branch (11017:24): [True: 238, False: 0]
  ------------------
11018|    238|        ctxt->sax->setDocumentLocator(ctxt->userData, &xmlDefaultSAXLocator);
  ------------------
  |  |  861|    238|  #define xmlDefaultSAXLocator XML_GLOBAL_MACRO(xmlDefaultSAXLocator)
  |  |  ------------------
  |  |  |  |  500|    238|  #define XML_GLOBAL_MACRO(name) (*__##name())
  |  |  ------------------
  ------------------
11019|    238|    if (ctxt->instate == XML_PARSER_EOF)
  ------------------
  |  Branch (11019:9): [True: 0, False: 238]
  ------------------
11020|      0|	return(-1);
11021|       |
11022|    238|    xmlDetectEncoding(ctxt);
11023|       |
11024|    238|    if (CUR == 0) {
  ------------------
  |  | 2222|    238|#define CUR (*ctxt->input->cur)
  ------------------
  |  Branch (11024:9): [True: 0, False: 238]
  ------------------
11025|      0|	xmlFatalErr(ctxt, XML_ERR_DOCUMENT_EMPTY, NULL);
11026|      0|	return(-1);
11027|      0|    }
11028|       |
11029|    238|    GROW;
  ------------------
  |  | 2270|    238|#define GROW if (ctxt->input->end - ctxt->input->cur < INPUT_CHUNK)	\
  |  |  ------------------
  |  |  |  |   97|    238|#define INPUT_CHUNK	250
  |  |  ------------------
  |  |  |  Branch (2270:18): [True: 16, False: 222]
  |  |  ------------------
  |  | 2271|    238|	xmlParserGrow(ctxt);
  ------------------
11030|    238|    if ((CMP5(CUR_PTR, '<', '?', 'x', 'm', 'l')) && (IS_BLANK_CH(NXT(5)))) {
  ------------------
  |  | 2231|    238|  ( CMP4( s, c1, c2, c3, c4 ) && ((unsigned char *) s)[ 4 ] == c5 )
  |  |  ------------------
  |  |  |  | 2228|    476|  ( ((unsigned char *) s)[ 0 ] == c1 && ((unsigned char *) s)[ 1 ] == c2 && \
  |  |  |  |  ------------------
  |  |  |  |  |  Branch (2228:5): [True: 237, False: 1]
  |  |  |  |  |  Branch (2228:41): [True: 227, False: 10]
  |  |  |  |  ------------------
  |  |  |  | 2229|    238|    ((unsigned char *) s)[ 2 ] == c3 && ((unsigned char *) s)[ 3 ] == c4 )
  |  |  |  |  ------------------
  |  |  |  |  |  Branch (2229:5): [True: 227, False: 0]
  |  |  |  |  |  Branch (2229:41): [True: 227, False: 0]
  |  |  |  |  ------------------
  |  |  ------------------
  |  |  |  Branch (2231:34): [True: 227, False: 0]
  |  |  ------------------
  ------------------
                  if ((CMP5(CUR_PTR, '<', '?', 'x', 'm', 'l')) && (IS_BLANK_CH(NXT(5)))) {
  ------------------
  |  |  151|    227|#define IS_BLANK_CH(c)  xmlIsBlank_ch(c)
  |  |  ------------------
  |  |  |  |   88|    227|#define xmlIsBlank_ch(c)	(((c) == 0x20) || \
  |  |  |  |  ------------------
  |  |  |  |  |  Branch (88:27): [True: 227, False: 0]
  |  |  |  |  ------------------
  |  |  |  |   89|    227|				 ((0x9 <= (c)) && ((c) <= 0xa)) || \
  |  |  |  |  ------------------
  |  |  |  |  |  Branch (89:7): [True: 0, False: 0]
  |  |  |  |  |  Branch (89:23): [True: 0, False: 0]
  |  |  |  |  ------------------
  |  |  |  |   90|    227|				 ((c) == 0xd))
  |  |  |  |  ------------------
  |  |  |  |  |  Branch (90:6): [True: 0, False: 0]
  |  |  |  |  ------------------
  |  |  ------------------
  ------------------
11031|       |
11032|       |	/*
11033|       |	 * Note that we will switch encoding on the fly.
11034|       |	 */
11035|    227|	xmlParseXMLDecl(ctxt);
11036|    227|	if ((ctxt->errNo == XML_ERR_UNSUPPORTED_ENCODING) ||
  ------------------
  |  Branch (11036:6): [True: 0, False: 227]
  ------------------
11037|    227|	    (ctxt->instate == XML_PARSER_EOF)) {
  ------------------
  |  Branch (11037:6): [True: 0, False: 227]
  ------------------
11038|       |	    /*
11039|       |	     * The XML REC instructs us to stop parsing right here
11040|       |	     */
11041|      0|	    return(-1);
11042|      0|	}
11043|    227|	SKIP_BLANKS;
  ------------------
  |  | 2273|    227|#define SKIP_BLANKS xmlSkipBlankChars(ctxt)
  ------------------
11044|    227|    } else {
11045|     11|	ctxt->version = xmlCharStrdup(XML_DEFAULT_VERSION);
  ------------------
  |  |   37|     11|#define XML_DEFAULT_VERSION	"1.0"
  ------------------
11046|     11|    }
11047|    238|    if ((ctxt->sax) && (ctxt->sax->startDocument) && (!ctxt->disableSAX))
  ------------------
  |  Branch (11047:9): [True: 238, False: 0]
  |  Branch (11047:24): [True: 238, False: 0]
  |  Branch (11047:54): [True: 236, False: 2]
  ------------------
11048|    236|        ctxt->sax->startDocument(ctxt->userData);
11049|    238|    if (ctxt->instate == XML_PARSER_EOF)
  ------------------
  |  Branch (11049:9): [True: 0, False: 238]
  ------------------
11050|      0|	return(-1);
11051|    238|    if ((ctxt->myDoc != NULL) && (ctxt->input != NULL) &&
  ------------------
  |  Branch (11051:9): [True: 236, False: 2]
  |  Branch (11051:34): [True: 236, False: 0]
  ------------------
11052|    238|        (ctxt->input->buf != NULL) && (ctxt->input->buf->compressed >= 0)) {
  ------------------
  |  Branch (11052:9): [True: 236, False: 0]
  |  Branch (11052:39): [True: 0, False: 236]
  ------------------
11053|      0|	ctxt->myDoc->compression = ctxt->input->buf->compressed;
11054|      0|    }
11055|       |
11056|       |    /*
11057|       |     * The Misc part of the Prolog
11058|       |     */
11059|    238|    xmlParseMisc(ctxt);
11060|       |
11061|       |    /*
11062|       |     * Then possibly doc type declaration(s) and more Misc
11063|       |     * (doctypedecl Misc*)?
11064|       |     */
11065|    238|    GROW;
  ------------------
  |  | 2270|    238|#define GROW if (ctxt->input->end - ctxt->input->cur < INPUT_CHUNK)	\
  |  |  ------------------
  |  |  |  |   97|    238|#define INPUT_CHUNK	250
  |  |  ------------------
  |  |  |  Branch (2270:18): [True: 34, False: 204]
  |  |  ------------------
  |  | 2271|    238|	xmlParserGrow(ctxt);
  ------------------
11066|    238|    if (CMP9(CUR_PTR, '<', '!', 'D', 'O', 'C', 'T', 'Y', 'P', 'E')) {
  ------------------
  |  | 2239|    238|  ( CMP8( s, c1, c2, c3, c4, c5, c6, c7, c8 ) && \
  |  |  ------------------
  |  |  |  | 2237|    476|  ( CMP7( s, c1, c2, c3, c4, c5, c6, c7 ) && ((unsigned char *) s)[ 7 ] == c8 )
  |  |  |  |  ------------------
  |  |  |  |  |  | 2235|    476|  ( CMP6( s, c1, c2, c3, c4, c5, c6 ) && ((unsigned char *) s)[ 6 ] == c7 )
  |  |  |  |  |  |  ------------------
  |  |  |  |  |  |  |  | 2233|    476|  ( CMP5( s, c1, c2, c3, c4, c5 ) && ((unsigned char *) s)[ 5 ] == c6 )
  |  |  |  |  |  |  |  |  ------------------
  |  |  |  |  |  |  |  |  |  | 2231|    476|  ( CMP4( s, c1, c2, c3, c4 ) && ((unsigned char *) s)[ 4 ] == c5 )
  |  |  |  |  |  |  |  |  |  |  ------------------
  |  |  |  |  |  |  |  |  |  |  |  | 2228|    476|  ( ((unsigned char *) s)[ 0 ] == c1 && ((unsigned char *) s)[ 1 ] == c2 && \
  |  |  |  |  |  |  |  |  |  |  |  |  ------------------
  |  |  |  |  |  |  |  |  |  |  |  |  |  Branch (2228:5): [True: 235, False: 3]
  |  |  |  |  |  |  |  |  |  |  |  |  |  Branch (2228:41): [True: 0, False: 235]
  |  |  |  |  |  |  |  |  |  |  |  |  ------------------
  |  |  |  |  |  |  |  |  |  |  |  | 2229|    238|    ((unsigned char *) s)[ 2 ] == c3 && ((unsigned char *) s)[ 3 ] == c4 )
  |  |  |  |  |  |  |  |  |  |  |  |  ------------------
  |  |  |  |  |  |  |  |  |  |  |  |  |  Branch (2229:5): [True: 0, False: 0]
  |  |  |  |  |  |  |  |  |  |  |  |  |  Branch (2229:41): [True: 0, False: 0]
  |  |  |  |  |  |  |  |  |  |  |  |  ------------------
  |  |  |  |  |  |  |  |  |  |  ------------------
  |  |  |  |  |  |  |  |  |  |  |  Branch (2231:34): [True: 0, False: 0]
  |  |  |  |  |  |  |  |  |  |  ------------------
  |  |  |  |  |  |  |  |  ------------------
  |  |  |  |  |  |  |  |  |  Branch (2233:38): [True: 0, False: 0]
  |  |  |  |  |  |  |  |  ------------------
  |  |  |  |  |  |  ------------------
  |  |  |  |  |  |  |  Branch (2235:42): [True: 0, False: 0]
  |  |  |  |  |  |  ------------------
  |  |  |  |  ------------------
  |  |  |  |  |  Branch (2237:46): [True: 0, False: 0]
  |  |  |  |  ------------------
  |  |  ------------------
  |  | 2240|    238|    ((unsigned char *) s)[ 8 ] == c9 )
  |  |  ------------------
  |  |  |  Branch (2240:5): [True: 0, False: 0]
  |  |  ------------------
  ------------------
11067|       |
11068|      0|	ctxt->inSubset = 1;
11069|      0|	xmlParseDocTypeDecl(ctxt);
11070|      0|	if (RAW == '[') {
  ------------------
  |  | 2221|      0|#define RAW (*ctxt->input->cur)
  ------------------
  |  Branch (11070:6): [True: 0, False: 0]
  ------------------
11071|      0|	    ctxt->instate = XML_PARSER_DTD;
11072|      0|	    xmlParseInternalSubset(ctxt);
11073|      0|	    if (ctxt->instate == XML_PARSER_EOF)
  ------------------
  |  Branch (11073:10): [True: 0, False: 0]
  ------------------
11074|      0|		return(-1);
11075|      0|	}
11076|       |
11077|       |	/*
11078|       |	 * Create and update the external subset.
11079|       |	 */
11080|      0|	ctxt->inSubset = 2;
11081|      0|	if ((ctxt->sax != NULL) && (ctxt->sax->externalSubset != NULL) &&
  ------------------
  |  Branch (11081:6): [True: 0, False: 0]
  |  Branch (11081:29): [True: 0, False: 0]
  ------------------
11082|      0|	    (!ctxt->disableSAX))
  ------------------
  |  Branch (11082:6): [True: 0, False: 0]
  ------------------
11083|      0|	    ctxt->sax->externalSubset(ctxt->userData, ctxt->intSubName,
11084|      0|	                              ctxt->extSubSystem, ctxt->extSubURI);
11085|      0|	if (ctxt->instate == XML_PARSER_EOF)
  ------------------
  |  Branch (11085:6): [True: 0, False: 0]
  ------------------
11086|      0|	    return(-1);
11087|      0|	ctxt->inSubset = 0;
11088|       |
11089|      0|        xmlCleanSpecialAttr(ctxt);
11090|       |
11091|      0|	ctxt->instate = XML_PARSER_PROLOG;
11092|      0|	xmlParseMisc(ctxt);
11093|      0|    }
11094|       |
11095|       |    /*
11096|       |     * Time to start parsing the tree itself
11097|       |     */
11098|    238|    GROW;
  ------------------
  |  | 2270|    238|#define GROW if (ctxt->input->end - ctxt->input->cur < INPUT_CHUNK)	\
  |  |  ------------------
  |  |  |  |   97|    238|#define INPUT_CHUNK	250
  |  |  ------------------
  |  |  |  Branch (2270:18): [True: 34, False: 204]
  |  |  ------------------
  |  | 2271|    238|	xmlParserGrow(ctxt);
  ------------------
11099|    238|    if (RAW != '<') {
  ------------------
  |  | 2221|    238|#define RAW (*ctxt->input->cur)
  ------------------
  |  Branch (11099:9): [True: 3, False: 235]
  ------------------
11100|      3|	xmlFatalErrMsg(ctxt, XML_ERR_DOCUMENT_EMPTY,
11101|      3|		       "Start tag expected, '<' not found\n");
11102|    235|    } else {
11103|    235|	ctxt->instate = XML_PARSER_CONTENT;
11104|    235|	xmlParseElement(ctxt);
11105|    235|	ctxt->instate = XML_PARSER_EPILOG;
11106|       |
11107|       |
11108|       |	/*
11109|       |	 * The Misc part at the end
11110|       |	 */
11111|    235|	xmlParseMisc(ctxt);
11112|       |
11113|    235|        if (ctxt->input->cur < ctxt->input->end) {
  ------------------
  |  Branch (11113:13): [True: 11, False: 224]
  ------------------
11114|     11|            if (ctxt->errNo == XML_ERR_OK)
  ------------------
  |  Branch (11114:17): [True: 0, False: 11]
  ------------------
11115|      0|	        xmlFatalErr(ctxt, XML_ERR_DOCUMENT_END, NULL);
11116|    224|        } else if ((ctxt->input->buf != NULL) &&
  ------------------
  |  Branch (11116:20): [True: 224, False: 0]
  ------------------
11117|    224|                   (ctxt->input->buf->encoder != NULL) &&
  ------------------
  |  Branch (11117:20): [True: 46, False: 178]
  ------------------
11118|    224|                   (!xmlBufIsEmpty(ctxt->input->buf->raw))) {
  ------------------
  |  Branch (11118:20): [True: 0, False: 46]
  ------------------
11119|      0|            xmlFatalErrMsg(ctxt, XML_ERR_INVALID_CHAR,
11120|      0|                           "Truncated multi-byte sequence at EOF\n");
11121|      0|        }
11122|    235|	ctxt->instate = XML_PARSER_EOF;
11123|    235|    }
11124|       |
11125|       |    /*
11126|       |     * SAX: end of the document processing.
11127|       |     */
11128|    238|    if ((ctxt->sax) && (ctxt->sax->endDocument != NULL))
  ------------------
  |  Branch (11128:9): [True: 238, False: 0]
  |  Branch (11128:24): [True: 238, False: 0]
  ------------------
11129|    238|        ctxt->sax->endDocument(ctxt->userData);
11130|       |
11131|       |    /*
11132|       |     * Remove locally kept entity definitions if the tree was not built
11133|       |     */
11134|    238|    if ((ctxt->myDoc != NULL) &&
  ------------------
  |  Branch (11134:9): [True: 236, False: 2]
  ------------------
11135|    238|	(xmlStrEqual(ctxt->myDoc->version, SAX_COMPAT_MODE))) {
  ------------------
  |  |  168|    236|#define SAX_COMPAT_MODE BAD_CAST "SAX compatibility mode document"
  |  |  ------------------
  |  |  |  |   35|    236|#define BAD_CAST (xmlChar *)
  |  |  ------------------
  ------------------
  |  Branch (11135:2): [True: 0, False: 236]
  ------------------
11136|      0|	xmlFreeDoc(ctxt->myDoc);
11137|      0|	ctxt->myDoc = NULL;
11138|      0|    }
11139|       |
11140|    238|    if ((ctxt->wellFormed) && (ctxt->myDoc != NULL)) {
  ------------------
  |  Branch (11140:9): [True: 206, False: 32]
  |  Branch (11140:31): [True: 206, False: 0]
  ------------------
11141|    206|        ctxt->myDoc->properties |= XML_DOC_WELLFORMED;
11142|    206|	if (ctxt->valid)
  ------------------
  |  Branch (11142:6): [True: 206, False: 0]
  ------------------
11143|    206|	    ctxt->myDoc->properties |= XML_DOC_DTDVALID;
11144|    206|	if (ctxt->nsWellFormed)
  ------------------
  |  Branch (11144:6): [True: 206, False: 0]
  ------------------
11145|    206|	    ctxt->myDoc->properties |= XML_DOC_NSVALID;
11146|    206|	if (ctxt->options & XML_PARSE_OLD10)
  ------------------
  |  Branch (11146:6): [True: 0, False: 206]
  ------------------
11147|      0|	    ctxt->myDoc->properties |= XML_DOC_OLD10;
11148|    206|    }
11149|    238|    if (! ctxt->wellFormed) {
  ------------------
  |  Branch (11149:9): [True: 32, False: 206]
  ------------------
11150|     32|	ctxt->valid = 0;
11151|     32|	return(-1);
11152|     32|    }
11153|    206|    return(0);
11154|    238|}
xmlCtxtReset:
14362|    242|{
14363|    242|    xmlParserInputPtr input;
14364|    242|    xmlDictPtr dict;
14365|       |
14366|    242|    if (ctxt == NULL)
  ------------------
  |  Branch (14366:9): [True: 0, False: 242]
  ------------------
14367|      0|        return;
14368|       |
14369|    242|    dict = ctxt->dict;
14370|       |
14371|    242|    while ((input = inputPop(ctxt)) != NULL) { /* Non consuming */
  ------------------
  |  Branch (14371:12): [True: 0, False: 242]
  ------------------
14372|      0|        xmlFreeInputStream(input);
14373|      0|    }
14374|    242|    ctxt->inputNr = 0;
14375|    242|    ctxt->input = NULL;
14376|       |
14377|    242|    ctxt->spaceNr = 0;
14378|    242|    if (ctxt->spaceTab != NULL) {
  ------------------
  |  Branch (14378:9): [True: 242, False: 0]
  ------------------
14379|    242|	ctxt->spaceTab[0] = -1;
14380|    242|	ctxt->space = &ctxt->spaceTab[0];
14381|    242|    } else {
14382|      0|        ctxt->space = NULL;
14383|      0|    }
14384|       |
14385|       |
14386|    242|    ctxt->nodeNr = 0;
14387|    242|    ctxt->node = NULL;
14388|       |
14389|    242|    ctxt->nameNr = 0;
14390|    242|    ctxt->name = NULL;
14391|       |
14392|    242|    ctxt->nsNr = 0;
14393|    242|    xmlParserNsReset(ctxt->nsdb);
14394|       |
14395|    242|    DICT_FREE(ctxt->version);
  ------------------
  |  |14350|    242|	if ((str) && ((!dict) ||				\
  |  |  ------------------
  |  |  |  Branch (14350:6): [True: 0, False: 242]
  |  |  |  Branch (14350:16): [True: 0, False: 0]
  |  |  ------------------
  |  |14351|      0|	    (xmlDictOwns(dict, (const xmlChar *)(str)) == 0)))	\
  |  |  ------------------
  |  |  |  Branch (14351:6): [True: 0, False: 0]
  |  |  ------------------
  |  |14352|    242|	    xmlFree((char *)(str));
  ------------------
14396|    242|    ctxt->version = NULL;
14397|    242|    DICT_FREE(ctxt->encoding);
  ------------------
  |  |14350|    242|	if ((str) && ((!dict) ||				\
  |  |  ------------------
  |  |  |  Branch (14350:6): [True: 0, False: 242]
  |  |  |  Branch (14350:16): [True: 0, False: 0]
  |  |  ------------------
  |  |14351|      0|	    (xmlDictOwns(dict, (const xmlChar *)(str)) == 0)))	\
  |  |  ------------------
  |  |  |  Branch (14351:6): [True: 0, False: 0]
  |  |  ------------------
  |  |14352|    242|	    xmlFree((char *)(str));
  ------------------
14398|    242|    ctxt->encoding = NULL;
14399|    242|    DICT_FREE(ctxt->directory);
  ------------------
  |  |14350|    242|	if ((str) && ((!dict) ||				\
  |  |  ------------------
  |  |  |  Branch (14350:6): [True: 0, False: 242]
  |  |  |  Branch (14350:16): [True: 0, False: 0]
  |  |  ------------------
  |  |14351|      0|	    (xmlDictOwns(dict, (const xmlChar *)(str)) == 0)))	\
  |  |  ------------------
  |  |  |  Branch (14351:6): [True: 0, False: 0]
  |  |  ------------------
  |  |14352|    242|	    xmlFree((char *)(str));
  ------------------
14400|    242|    ctxt->directory = NULL;
14401|    242|    DICT_FREE(ctxt->extSubURI);
  ------------------
  |  |14350|    242|	if ((str) && ((!dict) ||				\
  |  |  ------------------
  |  |  |  Branch (14350:6): [True: 0, False: 242]
  |  |  |  Branch (14350:16): [True: 0, False: 0]
  |  |  ------------------
  |  |14351|      0|	    (xmlDictOwns(dict, (const xmlChar *)(str)) == 0)))	\
  |  |  ------------------
  |  |  |  Branch (14351:6): [True: 0, False: 0]
  |  |  ------------------
  |  |14352|    242|	    xmlFree((char *)(str));
  ------------------
14402|    242|    ctxt->extSubURI = NULL;
14403|    242|    DICT_FREE(ctxt->extSubSystem);
  ------------------
  |  |14350|    242|	if ((str) && ((!dict) ||				\
  |  |  ------------------
  |  |  |  Branch (14350:6): [True: 0, False: 242]
  |  |  |  Branch (14350:16): [True: 0, False: 0]
  |  |  ------------------
  |  |14351|      0|	    (xmlDictOwns(dict, (const xmlChar *)(str)) == 0)))	\
  |  |  ------------------
  |  |  |  Branch (14351:6): [True: 0, False: 0]
  |  |  ------------------
  |  |14352|    242|	    xmlFree((char *)(str));
  ------------------
14404|    242|    ctxt->extSubSystem = NULL;
14405|    242|    if (ctxt->myDoc != NULL)
  ------------------
  |  Branch (14405:9): [True: 0, False: 242]
  ------------------
14406|      0|        xmlFreeDoc(ctxt->myDoc);
14407|    242|    ctxt->myDoc = NULL;
14408|       |
14409|    242|    ctxt->standalone = -1;
14410|    242|    ctxt->hasExternalSubset = 0;
14411|    242|    ctxt->hasPErefs = 0;
14412|    242|    ctxt->html = 0;
14413|    242|    ctxt->external = 0;
14414|    242|    ctxt->instate = XML_PARSER_START;
14415|    242|    ctxt->token = 0;
14416|       |
14417|    242|    ctxt->wellFormed = 1;
14418|    242|    ctxt->nsWellFormed = 1;
14419|    242|    ctxt->disableSAX = 0;
14420|    242|    ctxt->valid = 1;
14421|       |#if 0
14422|       |    ctxt->vctxt.userData = ctxt;
14423|       |    ctxt->vctxt.error = xmlParserValidityError;
14424|       |    ctxt->vctxt.warning = xmlParserValidityWarning;
14425|       |#endif
14426|    242|    ctxt->record_info = 0;
14427|    242|    ctxt->checkIndex = 0;
14428|    242|    ctxt->endCheckState = 0;
14429|    242|    ctxt->inSubset = 0;
14430|    242|    ctxt->errNo = XML_ERR_OK;
14431|    242|    ctxt->depth = 0;
14432|    242|    ctxt->catalogs = NULL;
14433|    242|    ctxt->sizeentities = 0;
14434|    242|    ctxt->sizeentcopy = 0;
14435|    242|    xmlInitNodeInfoSeq(&ctxt->node_seq);
14436|       |
14437|    242|    if (ctxt->attsDefault != NULL) {
  ------------------
  |  Branch (14437:9): [True: 0, False: 242]
  ------------------
14438|      0|        xmlHashFree(ctxt->attsDefault, xmlHashDefaultDeallocator);
14439|      0|        ctxt->attsDefault = NULL;
14440|      0|    }
14441|    242|    if (ctxt->attsSpecial != NULL) {
  ------------------
  |  Branch (14441:9): [True: 0, False: 242]
  ------------------
14442|      0|        xmlHashFree(ctxt->attsSpecial, NULL);
14443|      0|        ctxt->attsSpecial = NULL;
14444|      0|    }
14445|       |
14446|    242|#ifdef LIBXML_CATALOG_ENABLED
14447|    242|    if (ctxt->catalogs != NULL)
  ------------------
  |  Branch (14447:9): [True: 0, False: 242]
  ------------------
14448|      0|	xmlCatalogFreeLocal(ctxt->catalogs);
14449|    242|#endif
14450|    242|    ctxt->nbErrors = 0;
14451|    242|    ctxt->nbWarnings = 0;
14452|    242|    if (ctxt->lastError.code != XML_ERR_OK)
  ------------------
  |  Branch (14452:9): [True: 0, False: 242]
  ------------------
14453|      0|        xmlResetError(&ctxt->lastError);
14454|    242|}
xmlCtxtReadFile:
14988|    242|{
14989|    242|    xmlParserInputPtr stream;
14990|       |
14991|    242|    if (filename == NULL)
  ------------------
  |  Branch (14991:9): [True: 0, False: 242]
  ------------------
14992|      0|        return (NULL);
14993|    242|    if (ctxt == NULL)
  ------------------
  |  Branch (14993:9): [True: 0, False: 242]
  ------------------
14994|      0|        return (NULL);
14995|    242|    xmlInitParser();
14996|       |
14997|    242|    xmlCtxtReset(ctxt);
14998|       |
14999|    242|    stream = xmlLoadExternalEntity(filename, NULL, ctxt);
15000|    242|    if (stream == NULL) {
  ------------------
  |  Branch (15000:9): [True: 4, False: 238]
  ------------------
15001|      4|        return (NULL);
15002|      4|    }
15003|    238|    inputPush(ctxt, stream);
15004|    238|    return (xmlDoRead(ctxt, NULL, encoding, options, 1));
15005|    242|}
parser.c:xmlParserNsLookup:
 1485|  8.10k|                  xmlParserNsBucket **bucketPtr) {
 1486|  8.10k|    xmlParserNsBucket *bucket;
 1487|  8.10k|    unsigned index, hashValue;
 1488|       |
 1489|  8.10k|    if (prefix->name == NULL)
  ------------------
  |  Branch (1489:9): [True: 555, False: 7.55k]
  ------------------
 1490|    555|        return(ctxt->nsdb->defaultNsIndex);
 1491|       |
 1492|  7.55k|    if (ctxt->nsdb->hashSize == 0)
  ------------------
  |  Branch (1492:9): [True: 232, False: 7.32k]
  ------------------
 1493|    232|        return(INT_MAX);
 1494|       |
 1495|  7.32k|    hashValue = prefix->hashValue;
 1496|  7.32k|    index = hashValue & (ctxt->nsdb->hashSize - 1);
 1497|  7.32k|    bucket = &ctxt->nsdb->hash[index];
 1498|       |
 1499|  7.41k|    while (bucket->hashValue) {
  ------------------
  |  Branch (1499:12): [True: 7.32k, False: 86]
  ------------------
 1500|  7.32k|        if ((bucket->hashValue == hashValue) &&
  ------------------
  |  Branch (1500:13): [True: 7.26k, False: 60]
  ------------------
 1501|  7.32k|            (bucket->index != INT_MAX)) {
  ------------------
  |  Branch (1501:13): [True: 7.23k, False: 34]
  ------------------
 1502|  7.23k|            if (ctxt->nsTab[bucket->index * 2] == prefix->name) {
  ------------------
  |  Branch (1502:17): [True: 7.23k, False: 0]
  ------------------
 1503|  7.23k|                if (bucketPtr != NULL)
  ------------------
  |  Branch (1503:21): [True: 314, False: 6.92k]
  ------------------
 1504|    314|                    *bucketPtr = bucket;
 1505|  7.23k|                return(bucket->index);
 1506|  7.23k|            }
 1507|  7.23k|        }
 1508|       |
 1509|     94|        index++;
 1510|     94|        bucket++;
 1511|     94|        if (index == ctxt->nsdb->hashSize) {
  ------------------
  |  Branch (1511:13): [True: 0, False: 94]
  ------------------
 1512|      0|            index = 0;
 1513|      0|            bucket = ctxt->nsdb->hash;
 1514|      0|        }
 1515|     94|    }
 1516|       |
 1517|     86|    if (bucketPtr != NULL)
  ------------------
  |  Branch (1517:9): [True: 83, False: 3]
  ------------------
 1518|     83|        *bucketPtr = bucket;
 1519|     86|    return(INT_MAX);
 1520|  7.32k|}
parser.c:xmlFatalErrMsgInt:
  385|     11|{
  386|     11|    if ((ctxt != NULL) && (ctxt->disableSAX != 0) &&
  ------------------
  |  Branch (386:9): [True: 11, False: 0]
  |  Branch (386:27): [True: 11, False: 0]
  ------------------
  387|     11|        (ctxt->instate == XML_PARSER_EOF))
  ------------------
  |  Branch (387:9): [True: 0, False: 11]
  ------------------
  388|      0|	return;
  389|     11|    if (ctxt != NULL)
  ------------------
  |  Branch (389:9): [True: 11, False: 0]
  ------------------
  390|     11|	ctxt->errNo = error;
  391|     11|    __xmlRaiseError(NULL, NULL, NULL,
  392|     11|                    ctxt, NULL, XML_FROM_PARSER, error, XML_ERR_FATAL,
  393|     11|                    NULL, 0, NULL, NULL, NULL, val, 0, msg, val);
  394|     11|    if (ctxt != NULL) {
  ------------------
  |  Branch (394:9): [True: 11, False: 0]
  ------------------
  395|     11|	ctxt->wellFormed = 0;
  396|     11|	if (ctxt->recovery == 0)
  ------------------
  |  Branch (396:6): [True: 11, False: 0]
  ------------------
  397|     11|	    ctxt->disableSAX = 1;
  398|     11|    }
  399|     11|}
parser.c:xmlFatalErrMsgStr:
  445|      3|{
  446|      3|    if ((ctxt != NULL) && (ctxt->disableSAX != 0) &&
  ------------------
  |  Branch (446:9): [True: 3, False: 0]
  |  Branch (446:27): [True: 0, False: 3]
  ------------------
  447|      3|        (ctxt->instate == XML_PARSER_EOF))
  ------------------
  |  Branch (447:9): [True: 0, False: 0]
  ------------------
  448|      0|	return;
  449|      3|    if (ctxt != NULL)
  ------------------
  |  Branch (449:9): [True: 3, False: 0]
  ------------------
  450|      3|	ctxt->errNo = error;
  451|      3|    __xmlRaiseError(NULL, NULL, NULL, ctxt, NULL,
  452|      3|                    XML_FROM_PARSER, error, XML_ERR_FATAL,
  453|      3|                    NULL, 0, (const char *) val, NULL, NULL, 0, 0, msg,
  454|      3|                    val);
  455|      3|    if (ctxt != NULL) {
  ------------------
  |  Branch (455:9): [True: 3, False: 0]
  ------------------
  456|      3|	ctxt->wellFormed = 0;
  457|      3|	if (ctxt->recovery == 0)
  ------------------
  |  Branch (457:6): [True: 3, False: 0]
  ------------------
  458|      3|	    ctxt->disableSAX = 1;
  459|      3|    }
  460|      3|}
parser.c:xmlIsNameChar:
 3357|     23|xmlIsNameChar(xmlParserCtxtPtr ctxt, int c) {
 3358|     23|    if ((ctxt->options & XML_PARSE_OLD10) == 0) {
  ------------------
  |  Branch (3358:9): [True: 23, False: 0]
  ------------------
 3359|       |        /*
 3360|       |	 * Use the new checks of production [4] [4a] amd [5] of the
 3361|       |	 * Update 5 of XML-1.0
 3362|       |	 */
 3363|     23|	if ((c != ' ') && (c != '>') && (c != '/') && /* accelerators */
  ------------------
  |  Branch (3363:6): [True: 23, False: 0]
  |  Branch (3363:20): [True: 23, False: 0]
  |  Branch (3363:34): [True: 23, False: 0]
  ------------------
 3364|     23|	    (((c >= 'a') && (c <= 'z')) ||
  ------------------
  |  Branch (3364:8): [True: 21, False: 2]
  |  Branch (3364:22): [True: 19, False: 2]
  ------------------
 3365|     23|	     ((c >= 'A') && (c <= 'Z')) ||
  ------------------
  |  Branch (3365:8): [True: 3, False: 1]
  |  Branch (3365:22): [True: 1, False: 2]
  ------------------
 3366|     23|	     ((c >= '0') && (c <= '9')) || /* !start */
  ------------------
  |  Branch (3366:8): [True: 2, False: 1]
  |  Branch (3366:22): [True: 0, False: 2]
  ------------------
 3367|     23|	     (c == '_') || (c == ':') ||
  ------------------
  |  Branch (3367:7): [True: 0, False: 3]
  |  Branch (3367:21): [True: 0, False: 3]
  ------------------
 3368|     23|	     (c == '-') || (c == '.') || (c == 0xB7) || /* !start */
  ------------------
  |  Branch (3368:7): [True: 0, False: 3]
  |  Branch (3368:21): [True: 0, False: 3]
  |  Branch (3368:35): [True: 0, False: 3]
  ------------------
 3369|     23|	     ((c >= 0xC0) && (c <= 0xD6)) ||
  ------------------
  |  Branch (3369:8): [True: 2, False: 1]
  |  Branch (3369:23): [True: 0, False: 2]
  ------------------
 3370|     23|	     ((c >= 0xD8) && (c <= 0xF6)) ||
  ------------------
  |  Branch (3370:8): [True: 2, False: 1]
  |  Branch (3370:23): [True: 0, False: 2]
  ------------------
 3371|     23|	     ((c >= 0xF8) && (c <= 0x2FF)) ||
  ------------------
  |  Branch (3371:8): [True: 2, False: 1]
  |  Branch (3371:23): [True: 0, False: 2]
  ------------------
 3372|     23|	     ((c >= 0x300) && (c <= 0x36F)) || /* !start */
  ------------------
  |  Branch (3372:8): [True: 2, False: 1]
  |  Branch (3372:24): [True: 0, False: 2]
  ------------------
 3373|     23|	     ((c >= 0x370) && (c <= 0x37D)) ||
  ------------------
  |  Branch (3373:8): [True: 2, False: 1]
  |  Branch (3373:24): [True: 0, False: 2]
  ------------------
 3374|     23|	     ((c >= 0x37F) && (c <= 0x1FFF)) ||
  ------------------
  |  Branch (3374:8): [True: 2, False: 1]
  |  Branch (3374:24): [True: 0, False: 2]
  ------------------
 3375|     23|	     ((c >= 0x200C) && (c <= 0x200D)) ||
  ------------------
  |  Branch (3375:8): [True: 2, False: 1]
  |  Branch (3375:25): [True: 0, False: 2]
  ------------------
 3376|     23|	     ((c >= 0x203F) && (c <= 0x2040)) || /* !start */
  ------------------
  |  Branch (3376:8): [True: 2, False: 1]
  |  Branch (3376:25): [True: 0, False: 2]
  ------------------
 3377|     23|	     ((c >= 0x2070) && (c <= 0x218F)) ||
  ------------------
  |  Branch (3377:8): [True: 2, False: 1]
  |  Branch (3377:25): [True: 0, False: 2]
  ------------------
 3378|     23|	     ((c >= 0x2C00) && (c <= 0x2FEF)) ||
  ------------------
  |  Branch (3378:8): [True: 2, False: 1]
  |  Branch (3378:25): [True: 0, False: 2]
  ------------------
 3379|     23|	     ((c >= 0x3001) && (c <= 0xD7FF)) ||
  ------------------
  |  Branch (3379:8): [True: 2, False: 1]
  |  Branch (3379:25): [True: 0, False: 2]
  ------------------
 3380|     23|	     ((c >= 0xF900) && (c <= 0xFDCF)) ||
  ------------------
  |  Branch (3380:8): [True: 2, False: 1]
  |  Branch (3380:25): [True: 0, False: 2]
  ------------------
 3381|     23|	     ((c >= 0xFDF0) && (c <= 0xFFFD)) ||
  ------------------
  |  Branch (3381:8): [True: 2, False: 1]
  |  Branch (3381:25): [True: 2, False: 0]
  ------------------
 3382|     23|	     ((c >= 0x10000) && (c <= 0xEFFFF))))
  ------------------
  |  Branch (3382:8): [True: 0, False: 1]
  |  Branch (3382:26): [True: 0, False: 0]
  ------------------
 3383|     22|	     return(1);
 3384|     23|    } else {
 3385|      0|        if ((IS_LETTER(c)) || (IS_DIGIT(c)) ||
  ------------------
  |  |  240|      0|#define IS_LETTER(c) (IS_BASECHAR(c) || IS_IDEOGRAPHIC(c))
  |  |  ------------------
  |  |  |  |  161|      0|#define IS_BASECHAR(c) xmlIsBaseCharQ(c)
  |  |  |  |  ------------------
  |  |  |  |  |  |   76|      0|#define xmlIsBaseCharQ(c)	(((c) < 0x100) ? \
  |  |  |  |  |  |  ------------------
  |  |  |  |  |  |  |  Branch (76:27): [True: 0, False: 0]
  |  |  |  |  |  |  |  Branch (76:28): [True: 0, False: 0]
  |  |  |  |  |  |  ------------------
  |  |  |  |  |  |   77|      0|				 xmlIsBaseChar_ch((c)) : \
  |  |  |  |  |  |  ------------------
  |  |  |  |  |  |  |  |   64|      0|#define xmlIsBaseChar_ch(c)	(((0x41 <= (c)) && ((c) <= 0x5a)) || \
  |  |  |  |  |  |  |  |  ------------------
  |  |  |  |  |  |  |  |  |  Branch (64:31): [True: 0, False: 0]
  |  |  |  |  |  |  |  |  |  Branch (64:48): [True: 0, False: 0]
  |  |  |  |  |  |  |  |  ------------------
  |  |  |  |  |  |  |  |   65|      0|				 ((0x61 <= (c)) && ((c) <= 0x7a)) || \
  |  |  |  |  |  |  |  |  ------------------
  |  |  |  |  |  |  |  |  |  Branch (65:7): [True: 0, False: 0]
  |  |  |  |  |  |  |  |  |  Branch (65:24): [True: 0, False: 0]
  |  |  |  |  |  |  |  |  ------------------
  |  |  |  |  |  |  |  |   66|      0|				 ((0xc0 <= (c)) && ((c) <= 0xd6)) || \
  |  |  |  |  |  |  |  |  ------------------
  |  |  |  |  |  |  |  |  |  Branch (66:7): [True: 0, False: 0]
  |  |  |  |  |  |  |  |  |  Branch (66:24): [True: 0, False: 0]
  |  |  |  |  |  |  |  |  ------------------
  |  |  |  |  |  |  |  |   67|      0|				 ((0xd8 <= (c)) && ((c) <= 0xf6)) || \
  |  |  |  |  |  |  |  |  ------------------
  |  |  |  |  |  |  |  |  |  Branch (67:7): [True: 0, False: 0]
  |  |  |  |  |  |  |  |  |  Branch (67:24): [True: 0, False: 0]
  |  |  |  |  |  |  |  |  ------------------
  |  |  |  |  |  |  |  |   68|      0|				  (0xf8 <= (c)))
  |  |  |  |  |  |  |  |  ------------------
  |  |  |  |  |  |  |  |  |  Branch (68:7): [True: 0, False: 0]
  |  |  |  |  |  |  |  |  ------------------
  |  |  |  |  |  |  ------------------
  |  |  |  |  |  |   78|      0|				 xmlCharInRange((c), &xmlIsBaseCharGroup))
  |  |  |  |  ------------------
  |  |  ------------------
  |  |               #define IS_LETTER(c) (IS_BASECHAR(c) || IS_IDEOGRAPHIC(c))
  |  |  ------------------
  |  |  |  |  229|      0|#define IS_IDEOGRAPHIC(c) xmlIsIdeographicQ(c)
  |  |  |  |  ------------------
  |  |  |  |  |  |  184|      0|#define xmlIsIdeographicQ(c)	(((c) < 0x100) ? \
  |  |  |  |  |  |  ------------------
  |  |  |  |  |  |  |  Branch (184:30): [True: 0, False: 0]
  |  |  |  |  |  |  |  Branch (184:31): [True: 0, False: 0]
  |  |  |  |  |  |  ------------------
  |  |  |  |  |  |  185|      0|				 0 :\
  |  |  |  |  |  |  186|      0|				(((0x4e00 <= (c)) && ((c) <= 0x9fa5)) || \
  |  |  |  |  |  |  ------------------
  |  |  |  |  |  |  |  Branch (186:7): [True: 0, False: 0]
  |  |  |  |  |  |  |  Branch (186:26): [True: 0, False: 0]
  |  |  |  |  |  |  ------------------
  |  |  |  |  |  |  187|      0|				 ((c) == 0x3007) || \
  |  |  |  |  |  |  ------------------
  |  |  |  |  |  |  |  Branch (187:6): [True: 0, False: 0]
  |  |  |  |  |  |  ------------------
  |  |  |  |  |  |  188|      0|				 ((0x3021 <= (c)) && ((c) <= 0x3029))))
  |  |  |  |  |  |  ------------------
  |  |  |  |  |  |  |  Branch (188:7): [True: 0, False: 0]
  |  |  |  |  |  |  |  Branch (188:26): [True: 0, False: 0]
  |  |  |  |  |  |  ------------------
  |  |  |  |  ------------------
  |  |  ------------------
  ------------------
                      if ((IS_LETTER(c)) || (IS_DIGIT(c)) ||
  ------------------
  |  |  171|      0|#define IS_DIGIT(c) xmlIsDigitQ(c)
  |  |  ------------------
  |  |  |  |  152|      0|#define xmlIsDigitQ(c)		(((c) < 0x100) ? \
  |  |  |  |  ------------------
  |  |  |  |  |  Branch (152:26): [True: 0, False: 0]
  |  |  |  |  ------------------
  |  |  |  |  153|      0|				 xmlIsDigit_ch((c)) : \
  |  |  |  |  ------------------
  |  |  |  |  |  |  144|      0|#define xmlIsDigit_ch(c)	(((0x30 <= (c)) && ((c) <= 0x39)))
  |  |  |  |  |  |  ------------------
  |  |  |  |  |  |  |  Branch (144:28): [True: 0, False: 0]
  |  |  |  |  |  |  |  Branch (144:45): [True: 0, False: 0]
  |  |  |  |  |  |  ------------------
  |  |  |  |  ------------------
  |  |  |  |  154|      0|				 xmlCharInRange((c), &xmlIsDigitGroup))
  |  |  ------------------
  ------------------
  |  Branch (3385:31): [True: 0, False: 0]
  ------------------
 3386|      0|            (c == '.') || (c == '-') ||
  ------------------
  |  Branch (3386:13): [True: 0, False: 0]
  |  Branch (3386:27): [True: 0, False: 0]
  ------------------
 3387|      0|	    (c == '_') || (c == ':') ||
  ------------------
  |  Branch (3387:6): [True: 0, False: 0]
  |  Branch (3387:20): [True: 0, False: 0]
  ------------------
 3388|      0|	    (IS_COMBINING(c)) ||
  ------------------
  |  |  189|      0|#define IS_COMBINING(c) xmlIsCombiningQ(c)
  |  |  ------------------
  |  |  |  |  132|      0|#define xmlIsCombiningQ(c)	(((c) < 0x100) ? \
  |  |  |  |  ------------------
  |  |  |  |  |  Branch (132:29): [True: 0, False: 0]
  |  |  |  |  ------------------
  |  |  |  |  133|      0|				 0 : \
  |  |  |  |  134|      0|				 xmlCharInRange((c), &xmlIsCombiningGroup))
  |  |  ------------------
  ------------------
  |  Branch (3388:6): [True: 0, False: 0]
  ------------------
 3389|      0|	    (IS_EXTENDER(c)))
  ------------------
  |  |  210|      0|#define IS_EXTENDER(c) xmlIsExtenderQ(c)
  |  |  ------------------
  |  |  |  |  172|      0|#define xmlIsExtenderQ(c)	(((c) < 0x100) ? \
  |  |  |  |  ------------------
  |  |  |  |  |  Branch (172:28): [True: 0, False: 0]
  |  |  |  |  ------------------
  |  |  |  |  173|      0|				 xmlIsExtender_ch((c)) : \
  |  |  |  |  ------------------
  |  |  |  |  |  |  164|      0|#define xmlIsExtender_ch(c)	(((c) == 0xb7))
  |  |  |  |  ------------------
  |  |  |  |  174|      0|				 xmlCharInRange((c), &xmlIsExtenderGroup))
  |  |  ------------------
  ------------------
  |  Branch (3389:6): [True: 0, False: 0]
  ------------------
 3390|      0|	    return(1);
 3391|      0|    }
 3392|      1|    return(0);
 3393|     23|}
parser.c:xmlFatalErrMsg:
  279|     20|{
  280|     20|    if ((ctxt != NULL) && (ctxt->disableSAX != 0) &&
  ------------------
  |  Branch (280:9): [True: 20, False: 0]
  |  Branch (280:27): [True: 8, False: 12]
  ------------------
  281|     20|        (ctxt->instate == XML_PARSER_EOF))
  ------------------
  |  Branch (281:9): [True: 0, False: 8]
  ------------------
  282|      0|	return;
  283|     20|    if (ctxt != NULL)
  ------------------
  |  Branch (283:9): [True: 20, False: 0]
  ------------------
  284|     20|	ctxt->errNo = error;
  285|     20|    __xmlRaiseError(NULL, NULL, NULL, ctxt, NULL, XML_FROM_PARSER, error,
  286|     20|                    XML_ERR_FATAL, NULL, 0, NULL, NULL, NULL, 0, 0, "%s", msg);
  287|     20|    if (ctxt != NULL) {
  ------------------
  |  Branch (287:9): [True: 20, False: 0]
  ------------------
  288|     20|	ctxt->wellFormed = 0;
  289|     20|	if (ctxt->recovery == 0)
  ------------------
  |  Branch (289:6): [True: 20, False: 0]
  ------------------
  290|     20|	    ctxt->disableSAX = 1;
  291|     20|    }
  292|     20|}
parser.c:xmlIsNameStartChar:
 3326|      8|xmlIsNameStartChar(xmlParserCtxtPtr ctxt, int c) {
 3327|      8|    if ((ctxt->options & XML_PARSE_OLD10) == 0) {
  ------------------
  |  Branch (3327:9): [True: 8, False: 0]
  ------------------
 3328|       |        /*
 3329|       |	 * Use the new checks of production [4] [4a] amd [5] of the
 3330|       |	 * Update 5 of XML-1.0
 3331|       |	 */
 3332|      8|	if ((c != ' ') && (c != '>') && (c != '/') && /* accelerators */
  ------------------
  |  Branch (3332:6): [True: 8, False: 0]
  |  Branch (3332:20): [True: 8, False: 0]
  |  Branch (3332:34): [True: 8, False: 0]
  ------------------
 3333|      8|	    (((c >= 'a') && (c <= 'z')) ||
  ------------------
  |  Branch (3333:8): [True: 2, False: 6]
  |  Branch (3333:22): [True: 2, False: 0]
  ------------------
 3334|      8|	     ((c >= 'A') && (c <= 'Z')) ||
  ------------------
  |  Branch (3334:8): [True: 0, False: 6]
  |  Branch (3334:22): [True: 0, False: 0]
  ------------------
 3335|      8|	     (c == '_') || (c == ':') ||
  ------------------
  |  Branch (3335:7): [True: 0, False: 6]
  |  Branch (3335:21): [True: 0, False: 6]
  ------------------
 3336|      8|	     ((c >= 0xC0) && (c <= 0xD6)) ||
  ------------------
  |  Branch (3336:8): [True: 0, False: 6]
  |  Branch (3336:23): [True: 0, False: 0]
  ------------------
 3337|      8|	     ((c >= 0xD8) && (c <= 0xF6)) ||
  ------------------
  |  Branch (3337:8): [True: 0, False: 6]
  |  Branch (3337:23): [True: 0, False: 0]
  ------------------
 3338|      8|	     ((c >= 0xF8) && (c <= 0x2FF)) ||
  ------------------
  |  Branch (3338:8): [True: 0, False: 6]
  |  Branch (3338:23): [True: 0, False: 0]
  ------------------
 3339|      8|	     ((c >= 0x370) && (c <= 0x37D)) ||
  ------------------
  |  Branch (3339:8): [True: 0, False: 6]
  |  Branch (3339:24): [True: 0, False: 0]
  ------------------
 3340|      8|	     ((c >= 0x37F) && (c <= 0x1FFF)) ||
  ------------------
  |  Branch (3340:8): [True: 0, False: 6]
  |  Branch (3340:24): [True: 0, False: 0]
  ------------------
 3341|      8|	     ((c >= 0x200C) && (c <= 0x200D)) ||
  ------------------
  |  Branch (3341:8): [True: 0, False: 6]
  |  Branch (3341:25): [True: 0, False: 0]
  ------------------
 3342|      8|	     ((c >= 0x2070) && (c <= 0x218F)) ||
  ------------------
  |  Branch (3342:8): [True: 0, False: 6]
  |  Branch (3342:25): [True: 0, False: 0]
  ------------------
 3343|      8|	     ((c >= 0x2C00) && (c <= 0x2FEF)) ||
  ------------------
  |  Branch (3343:8): [True: 0, False: 6]
  |  Branch (3343:25): [True: 0, False: 0]
  ------------------
 3344|      8|	     ((c >= 0x3001) && (c <= 0xD7FF)) ||
  ------------------
  |  Branch (3344:8): [True: 0, False: 6]
  |  Branch (3344:25): [True: 0, False: 0]
  ------------------
 3345|      8|	     ((c >= 0xF900) && (c <= 0xFDCF)) ||
  ------------------
  |  Branch (3345:8): [True: 0, False: 6]
  |  Branch (3345:25): [True: 0, False: 0]
  ------------------
 3346|      8|	     ((c >= 0xFDF0) && (c <= 0xFFFD)) ||
  ------------------
  |  Branch (3346:8): [True: 0, False: 6]
  |  Branch (3346:25): [True: 0, False: 0]
  ------------------
 3347|      8|	     ((c >= 0x10000) && (c <= 0xEFFFF))))
  ------------------
  |  Branch (3347:8): [True: 0, False: 6]
  |  Branch (3347:26): [True: 0, False: 0]
  ------------------
 3348|      2|	    return(1);
 3349|      8|    } else {
 3350|      0|        if (IS_LETTER(c) || (c == '_') || (c == ':'))
  ------------------
  |  |  240|      0|#define IS_LETTER(c) (IS_BASECHAR(c) || IS_IDEOGRAPHIC(c))
  |  |  ------------------
  |  |  |  |  161|      0|#define IS_BASECHAR(c) xmlIsBaseCharQ(c)
  |  |  |  |  ------------------
  |  |  |  |  |  |   76|      0|#define xmlIsBaseCharQ(c)	(((c) < 0x100) ? \
  |  |  |  |  |  |  ------------------
  |  |  |  |  |  |  |  Branch (76:27): [True: 0, False: 0]
  |  |  |  |  |  |  |  Branch (76:28): [True: 0, False: 0]
  |  |  |  |  |  |  ------------------
  |  |  |  |  |  |   77|      0|				 xmlIsBaseChar_ch((c)) : \
  |  |  |  |  |  |  ------------------
  |  |  |  |  |  |  |  |   64|      0|#define xmlIsBaseChar_ch(c)	(((0x41 <= (c)) && ((c) <= 0x5a)) || \
  |  |  |  |  |  |  |  |  ------------------
  |  |  |  |  |  |  |  |  |  Branch (64:31): [True: 0, False: 0]
  |  |  |  |  |  |  |  |  |  Branch (64:48): [True: 0, False: 0]
  |  |  |  |  |  |  |  |  ------------------
  |  |  |  |  |  |  |  |   65|      0|				 ((0x61 <= (c)) && ((c) <= 0x7a)) || \
  |  |  |  |  |  |  |  |  ------------------
  |  |  |  |  |  |  |  |  |  Branch (65:7): [True: 0, False: 0]
  |  |  |  |  |  |  |  |  |  Branch (65:24): [True: 0, False: 0]
  |  |  |  |  |  |  |  |  ------------------
  |  |  |  |  |  |  |  |   66|      0|				 ((0xc0 <= (c)) && ((c) <= 0xd6)) || \
  |  |  |  |  |  |  |  |  ------------------
  |  |  |  |  |  |  |  |  |  Branch (66:7): [True: 0, False: 0]
  |  |  |  |  |  |  |  |  |  Branch (66:24): [True: 0, False: 0]
  |  |  |  |  |  |  |  |  ------------------
  |  |  |  |  |  |  |  |   67|      0|				 ((0xd8 <= (c)) && ((c) <= 0xf6)) || \
  |  |  |  |  |  |  |  |  ------------------
  |  |  |  |  |  |  |  |  |  Branch (67:7): [True: 0, False: 0]
  |  |  |  |  |  |  |  |  |  Branch (67:24): [True: 0, False: 0]
  |  |  |  |  |  |  |  |  ------------------
  |  |  |  |  |  |  |  |   68|      0|				  (0xf8 <= (c)))
  |  |  |  |  |  |  |  |  ------------------
  |  |  |  |  |  |  |  |  |  Branch (68:7): [True: 0, False: 0]
  |  |  |  |  |  |  |  |  ------------------
  |  |  |  |  |  |  ------------------
  |  |  |  |  |  |   78|      0|				 xmlCharInRange((c), &xmlIsBaseCharGroup))
  |  |  |  |  ------------------
  |  |  ------------------
  |  |               #define IS_LETTER(c) (IS_BASECHAR(c) || IS_IDEOGRAPHIC(c))
  |  |  ------------------
  |  |  |  |  229|      0|#define IS_IDEOGRAPHIC(c) xmlIsIdeographicQ(c)
  |  |  |  |  ------------------
  |  |  |  |  |  |  184|      0|#define xmlIsIdeographicQ(c)	(((c) < 0x100) ? \
  |  |  |  |  |  |  ------------------
  |  |  |  |  |  |  |  Branch (184:30): [True: 0, False: 0]
  |  |  |  |  |  |  |  Branch (184:31): [True: 0, False: 0]
  |  |  |  |  |  |  ------------------
  |  |  |  |  |  |  185|      0|				 0 :\
  |  |  |  |  |  |  186|      0|				(((0x4e00 <= (c)) && ((c) <= 0x9fa5)) || \
  |  |  |  |  |  |  ------------------
  |  |  |  |  |  |  |  Branch (186:7): [True: 0, False: 0]
  |  |  |  |  |  |  |  Branch (186:26): [True: 0, False: 0]
  |  |  |  |  |  |  ------------------
  |  |  |  |  |  |  187|      0|				 ((c) == 0x3007) || \
  |  |  |  |  |  |  ------------------
  |  |  |  |  |  |  |  Branch (187:6): [True: 0, False: 0]
  |  |  |  |  |  |  ------------------
  |  |  |  |  |  |  188|      0|				 ((0x3021 <= (c)) && ((c) <= 0x3029))))
  |  |  |  |  |  |  ------------------
  |  |  |  |  |  |  |  Branch (188:7): [True: 0, False: 0]
  |  |  |  |  |  |  |  Branch (188:26): [True: 0, False: 0]
  |  |  |  |  |  |  ------------------
  |  |  |  |  ------------------
  |  |  ------------------
  ------------------
  |  Branch (3350:29): [True: 0, False: 0]
  |  Branch (3350:43): [True: 0, False: 0]
  ------------------
 3351|      0|	    return(1);
 3352|      0|    }
 3353|      6|    return(0);
 3354|      8|}
parser.c:xmlParseCharDataInternal:
 4557|  5.78k|xmlParseCharDataInternal(xmlParserCtxtPtr ctxt, int partial) {
 4558|  5.78k|    const xmlChar *in;
 4559|  5.78k|    int nbchar = 0;
 4560|  5.78k|    int line = ctxt->input->line;
 4561|  5.78k|    int col = ctxt->input->col;
 4562|  5.78k|    int ccol;
 4563|       |
 4564|  5.78k|    GROW;
  ------------------
  |  | 2270|  5.78k|#define GROW if (ctxt->input->end - ctxt->input->cur < INPUT_CHUNK)	\
  |  |  ------------------
  |  |  |  |   97|  5.78k|#define INPUT_CHUNK	250
  |  |  ------------------
  |  |  |  Branch (2270:18): [True: 1.56k, False: 4.22k]
  |  |  ------------------
  |  | 2271|  5.78k|	xmlParserGrow(ctxt);
  ------------------
 4565|       |    /*
 4566|       |     * Accelerated common case where input don't need to be
 4567|       |     * modified before passing it to the handler.
 4568|       |     */
 4569|  5.78k|    in = ctxt->input->cur;
 4570|  7.17k|    do {
 4571|  11.3k|get_more_space:
 4572|  30.9k|        while (*in == 0x20) { in++; ctxt->input->col++; }
  ------------------
  |  Branch (4572:16): [True: 19.6k, False: 11.3k]
  ------------------
 4573|  11.3k|        if (*in == 0xA) {
  ------------------
  |  Branch (4573:13): [True: 4.12k, False: 7.17k]
  ------------------
 4574|  4.51k|            do {
 4575|  4.51k|                ctxt->input->line++; ctxt->input->col = 1;
 4576|  4.51k|                in++;
 4577|  4.51k|            } while (*in == 0xA);
  ------------------
  |  Branch (4577:22): [True: 386, False: 4.12k]
  ------------------
 4578|  4.12k|            goto get_more_space;
 4579|  4.12k|        }
 4580|  7.17k|        if (*in == '<') {
  ------------------
  |  Branch (4580:13): [True: 2.96k, False: 4.21k]
  ------------------
 4581|  2.96k|            nbchar = in - ctxt->input->cur;
 4582|  2.96k|            if (nbchar > 0) {
  ------------------
  |  Branch (4582:17): [True: 2.96k, False: 0]
  ------------------
 4583|  2.96k|                const xmlChar *tmp = ctxt->input->cur;
 4584|  2.96k|                ctxt->input->cur = in;
 4585|       |
 4586|  2.96k|                if ((ctxt->sax != NULL) &&
  ------------------
  |  Branch (4586:21): [True: 2.96k, False: 0]
  ------------------
 4587|  2.96k|                    (ctxt->disableSAX == 0) &&
  ------------------
  |  Branch (4587:21): [True: 2.73k, False: 224]
  ------------------
 4588|  2.96k|                    (ctxt->sax->ignorableWhitespace !=
  ------------------
  |  Branch (4588:21): [True: 0, False: 2.73k]
  ------------------
 4589|  2.73k|                     ctxt->sax->characters)) {
 4590|      0|                    if (areBlanks(ctxt, tmp, nbchar, 1)) {
  ------------------
  |  Branch (4590:25): [True: 0, False: 0]
  ------------------
 4591|      0|                        if (ctxt->sax->ignorableWhitespace != NULL)
  ------------------
  |  Branch (4591:29): [True: 0, False: 0]
  ------------------
 4592|      0|                            ctxt->sax->ignorableWhitespace(ctxt->userData,
 4593|      0|                                                   tmp, nbchar);
 4594|      0|                    } else {
 4595|      0|                        if (ctxt->sax->characters != NULL)
  ------------------
  |  Branch (4595:29): [True: 0, False: 0]
  ------------------
 4596|      0|                            ctxt->sax->characters(ctxt->userData,
 4597|      0|                                                  tmp, nbchar);
 4598|      0|                        if (*ctxt->space == -1)
  ------------------
  |  Branch (4598:29): [True: 0, False: 0]
  ------------------
 4599|      0|                            *ctxt->space = -2;
 4600|      0|                    }
 4601|  2.96k|                } else if ((ctxt->sax != NULL) &&
  ------------------
  |  Branch (4601:28): [True: 2.96k, False: 0]
  ------------------
 4602|  2.96k|                           (ctxt->disableSAX == 0) &&
  ------------------
  |  Branch (4602:28): [True: 2.73k, False: 224]
  ------------------
 4603|  2.96k|                           (ctxt->sax->characters != NULL)) {
  ------------------
  |  Branch (4603:28): [True: 2.73k, False: 0]
  ------------------
 4604|  2.73k|                    ctxt->sax->characters(ctxt->userData,
 4605|  2.73k|                                          tmp, nbchar);
 4606|  2.73k|                }
 4607|  2.96k|            }
 4608|  2.96k|            return;
 4609|  2.96k|        }
 4610|       |
 4611|  4.89k|get_more:
 4612|  4.89k|        ccol = ctxt->input->col;
 4613|  34.6k|        while (test_char_data[*in]) {
  ------------------
  |  Branch (4613:16): [True: 29.7k, False: 4.89k]
  ------------------
 4614|  29.7k|            in++;
 4615|  29.7k|            ccol++;
 4616|  29.7k|        }
 4617|  4.89k|        ctxt->input->col = ccol;
 4618|  4.89k|        if (*in == 0xA) {
  ------------------
  |  Branch (4618:13): [True: 672, False: 4.21k]
  ------------------
 4619|    732|            do {
 4620|    732|                ctxt->input->line++; ctxt->input->col = 1;
 4621|    732|                in++;
 4622|    732|            } while (*in == 0xA);
  ------------------
  |  Branch (4622:22): [True: 60, False: 672]
  ------------------
 4623|    672|            goto get_more;
 4624|    672|        }
 4625|  4.21k|        if (*in == ']') {
  ------------------
  |  Branch (4625:13): [True: 0, False: 4.21k]
  ------------------
 4626|      0|            if ((in[1] == ']') && (in[2] == '>')) {
  ------------------
  |  Branch (4626:17): [True: 0, False: 0]
  |  Branch (4626:35): [True: 0, False: 0]
  ------------------
 4627|      0|                xmlFatalErr(ctxt, XML_ERR_MISPLACED_CDATA_END, NULL);
 4628|      0|                if (ctxt->instate != XML_PARSER_EOF)
  ------------------
  |  Branch (4628:21): [True: 0, False: 0]
  ------------------
 4629|      0|                    ctxt->input->cur = in + 1;
 4630|      0|                return;
 4631|      0|            }
 4632|      0|            in++;
 4633|      0|            ctxt->input->col++;
 4634|      0|            goto get_more;
 4635|      0|        }
 4636|  4.21k|        nbchar = in - ctxt->input->cur;
 4637|  4.21k|        if (nbchar > 0) {
  ------------------
  |  Branch (4637:13): [True: 2.92k, False: 1.29k]
  ------------------
 4638|  2.92k|            if ((ctxt->sax != NULL) &&
  ------------------
  |  Branch (4638:17): [True: 2.92k, False: 0]
  ------------------
 4639|  2.92k|                (ctxt->disableSAX == 0) &&
  ------------------
  |  Branch (4639:17): [True: 2.82k, False: 98]
  ------------------
 4640|  2.92k|                (ctxt->sax->ignorableWhitespace !=
  ------------------
  |  Branch (4640:17): [True: 0, False: 2.82k]
  ------------------
 4641|  2.82k|                 ctxt->sax->characters) &&
 4642|  2.92k|                (IS_BLANK_CH(*ctxt->input->cur))) {
  ------------------
  |  |  151|      0|#define IS_BLANK_CH(c)  xmlIsBlank_ch(c)
  |  |  ------------------
  |  |  |  |   88|      0|#define xmlIsBlank_ch(c)	(((c) == 0x20) || \
  |  |  |  |  ------------------
  |  |  |  |  |  Branch (88:27): [True: 0, False: 0]
  |  |  |  |  ------------------
  |  |  |  |   89|      0|				 ((0x9 <= (c)) && ((c) <= 0xa)) || \
  |  |  |  |  ------------------
  |  |  |  |  |  Branch (89:7): [True: 0, False: 0]
  |  |  |  |  |  Branch (89:23): [True: 0, False: 0]
  |  |  |  |  ------------------
  |  |  |  |   90|      0|				 ((c) == 0xd))
  |  |  |  |  ------------------
  |  |  |  |  |  Branch (90:6): [True: 0, False: 0]
  |  |  |  |  ------------------
  |  |  ------------------
  ------------------
 4643|      0|                const xmlChar *tmp = ctxt->input->cur;
 4644|      0|                ctxt->input->cur = in;
 4645|       |
 4646|      0|                if (areBlanks(ctxt, tmp, nbchar, 0)) {
  ------------------
  |  Branch (4646:21): [True: 0, False: 0]
  ------------------
 4647|      0|                    if (ctxt->sax->ignorableWhitespace != NULL)
  ------------------
  |  Branch (4647:25): [True: 0, False: 0]
  ------------------
 4648|      0|                        ctxt->sax->ignorableWhitespace(ctxt->userData,
 4649|      0|                                                       tmp, nbchar);
 4650|      0|                } else {
 4651|      0|                    if (ctxt->sax->characters != NULL)
  ------------------
  |  Branch (4651:25): [True: 0, False: 0]
  ------------------
 4652|      0|                        ctxt->sax->characters(ctxt->userData,
 4653|      0|                                              tmp, nbchar);
 4654|      0|                    if (*ctxt->space == -1)
  ------------------
  |  Branch (4654:25): [True: 0, False: 0]
  ------------------
 4655|      0|                        *ctxt->space = -2;
 4656|      0|                }
 4657|      0|                line = ctxt->input->line;
 4658|      0|                col = ctxt->input->col;
 4659|  2.92k|            } else if ((ctxt->sax != NULL) &&
  ------------------
  |  Branch (4659:24): [True: 2.92k, False: 0]
  ------------------
 4660|  2.92k|                       (ctxt->disableSAX == 0)) {
  ------------------
  |  Branch (4660:24): [True: 2.82k, False: 98]
  ------------------
 4661|  2.82k|                if (ctxt->sax->characters != NULL)
  ------------------
  |  Branch (4661:21): [True: 2.82k, False: 0]
  ------------------
 4662|  2.82k|                    ctxt->sax->characters(ctxt->userData,
 4663|  2.82k|                                          ctxt->input->cur, nbchar);
 4664|  2.82k|                line = ctxt->input->line;
 4665|  2.82k|                col = ctxt->input->col;
 4666|  2.82k|            }
 4667|  2.92k|            if (ctxt->instate == XML_PARSER_EOF)
  ------------------
  |  Branch (4667:17): [True: 0, False: 2.92k]
  ------------------
 4668|      0|                return;
 4669|  2.92k|        }
 4670|  4.21k|        ctxt->input->cur = in;
 4671|  4.21k|        if (*in == 0xD) {
  ------------------
  |  Branch (4671:13): [True: 1.43k, False: 2.78k]
  ------------------
 4672|  1.43k|            in++;
 4673|  1.43k|            if (*in == 0xA) {
  ------------------
  |  Branch (4673:17): [True: 1.43k, False: 0]
  ------------------
 4674|  1.43k|                ctxt->input->cur = in;
 4675|  1.43k|                in++;
 4676|  1.43k|                ctxt->input->line++; ctxt->input->col = 1;
 4677|  1.43k|                continue; /* while */
 4678|  1.43k|            }
 4679|      0|            in--;
 4680|      0|        }
 4681|  2.78k|        if (*in == '<') {
  ------------------
  |  Branch (4681:13): [True: 2.75k, False: 24]
  ------------------
 4682|  2.75k|            return;
 4683|  2.75k|        }
 4684|     24|        if (*in == '&') {
  ------------------
  |  Branch (4684:13): [True: 8, False: 16]
  ------------------
 4685|      8|            return;
 4686|      8|        }
 4687|     16|        SHRINK;
  ------------------
  |  | 2265|     16|    if (((ctxt->progressive == 0) || (ctxt->inputNr > 1)) && \
  |  |  ------------------
  |  |  |  Branch (2265:10): [True: 16, False: 0]
  |  |  |  Branch (2265:38): [True: 0, False: 0]
  |  |  ------------------
  |  | 2266|     16|        (ctxt->input->cur - ctxt->input->base > 2 * INPUT_CHUNK) && \
  |  |  ------------------
  |  |  |  |   97|     16|#define INPUT_CHUNK	250
  |  |  ------------------
  |  |  |  Branch (2266:9): [True: 1, False: 15]
  |  |  ------------------
  |  | 2267|     16|	(ctxt->input->end - ctxt->input->cur < 2 * INPUT_CHUNK)) \
  |  |  ------------------
  |  |  |  |   97|      1|#define INPUT_CHUNK	250
  |  |  ------------------
  |  |  |  Branch (2267:2): [True: 0, False: 1]
  |  |  ------------------
  |  | 2268|     16|	xmlParserShrink(ctxt);
  ------------------
 4688|     16|        GROW;
  ------------------
  |  | 2270|     16|#define GROW if (ctxt->input->end - ctxt->input->cur < INPUT_CHUNK)	\
  |  |  ------------------
  |  |  |  |   97|     16|#define INPUT_CHUNK	250
  |  |  ------------------
  |  |  |  Branch (2270:18): [True: 15, False: 1]
  |  |  ------------------
  |  | 2271|     16|	xmlParserGrow(ctxt);
  ------------------
 4689|     16|        if (ctxt->instate == XML_PARSER_EOF)
  ------------------
  |  Branch (4689:13): [True: 0, False: 16]
  ------------------
 4690|      0|            return;
 4691|     16|        in = ctxt->input->cur;
 4692|  1.45k|    } while (((*in >= 0x20) && (*in <= 0x7F)) ||
  ------------------
  |  Branch (4692:15): [True: 374, False: 1.07k]
  |  Branch (4692:32): [True: 372, False: 2]
  ------------------
 4693|  1.45k|             (*in == 0x09) || (*in == 0x0a));
  ------------------
  |  Branch (4693:14): [True: 1.01k, False: 62]
  |  Branch (4693:31): [True: 1, False: 61]
  ------------------
 4694|     61|    ctxt->input->line = line;
 4695|     61|    ctxt->input->col = col;
 4696|     61|    xmlParseCharDataComplex(ctxt, partial);
 4697|     61|}
parser.c:areBlanks:
 3071|     45|                     int blank_chars) {
 3072|     45|    int i, ret;
 3073|     45|    xmlNodePtr lastChild;
 3074|       |
 3075|       |    /*
 3076|       |     * Don't spend time trying to differentiate them, the same callback is
 3077|       |     * used !
 3078|       |     */
 3079|     45|    if (ctxt->sax->ignorableWhitespace == ctxt->sax->characters)
  ------------------
  |  Branch (3079:9): [True: 45, False: 0]
  ------------------
 3080|     45|	return(0);
 3081|       |
 3082|       |    /*
 3083|       |     * Check for xml:space value.
 3084|       |     */
 3085|      0|    if ((ctxt->space == NULL) || (*(ctxt->space) == 1) ||
  ------------------
  |  Branch (3085:9): [True: 0, False: 0]
  |  Branch (3085:34): [True: 0, False: 0]
  ------------------
 3086|      0|        (*(ctxt->space) == -2))
  ------------------
  |  Branch (3086:9): [True: 0, False: 0]
  ------------------
 3087|      0|	return(0);
 3088|       |
 3089|       |    /*
 3090|       |     * Check that the string is made of blanks
 3091|       |     */
 3092|      0|    if (blank_chars == 0) {
  ------------------
  |  Branch (3092:9): [True: 0, False: 0]
  ------------------
 3093|      0|	for (i = 0;i < len;i++)
  ------------------
  |  Branch (3093:13): [True: 0, False: 0]
  ------------------
 3094|      0|	    if (!(IS_BLANK_CH(str[i]))) return(0);
  ------------------
  |  |  151|      0|#define IS_BLANK_CH(c)  xmlIsBlank_ch(c)
  |  |  ------------------
  |  |  |  |   88|      0|#define xmlIsBlank_ch(c)	(((c) == 0x20) || \
  |  |  |  |  ------------------
  |  |  |  |  |  Branch (88:27): [True: 0, False: 0]
  |  |  |  |  ------------------
  |  |  |  |   89|      0|				 ((0x9 <= (c)) && ((c) <= 0xa)) || \
  |  |  |  |  ------------------
  |  |  |  |  |  Branch (89:7): [True: 0, False: 0]
  |  |  |  |  |  Branch (89:23): [True: 0, False: 0]
  |  |  |  |  ------------------
  |  |  |  |   90|      0|				 ((c) == 0xd))
  |  |  |  |  ------------------
  |  |  |  |  |  Branch (90:6): [True: 0, False: 0]
  |  |  |  |  ------------------
  |  |  ------------------
  ------------------
 3095|      0|    }
 3096|       |
 3097|       |    /*
 3098|       |     * Look if the element is mixed content in the DTD if available
 3099|       |     */
 3100|      0|    if (ctxt->node == NULL) return(0);
  ------------------
  |  Branch (3100:9): [True: 0, False: 0]
  ------------------
 3101|      0|    if (ctxt->myDoc != NULL) {
  ------------------
  |  Branch (3101:9): [True: 0, False: 0]
  ------------------
 3102|      0|	ret = xmlIsMixedElement(ctxt->myDoc, ctxt->node->name);
 3103|      0|        if (ret == 0) return(1);
  ------------------
  |  Branch (3103:13): [True: 0, False: 0]
  ------------------
 3104|      0|        if (ret == 1) return(0);
  ------------------
  |  Branch (3104:13): [True: 0, False: 0]
  ------------------
 3105|      0|    }
 3106|       |
 3107|       |    /*
 3108|       |     * Otherwise, heuristic :-\
 3109|       |     */
 3110|      0|    if ((RAW != '<') && (RAW != 0xD)) return(0);
  ------------------
  |  | 2221|      0|#define RAW (*ctxt->input->cur)
  ------------------
                  if ((RAW != '<') && (RAW != 0xD)) return(0);
  ------------------
  |  | 2221|      0|#define RAW (*ctxt->input->cur)
  ------------------
  |  Branch (3110:9): [True: 0, False: 0]
  |  Branch (3110:25): [True: 0, False: 0]
  ------------------
 3111|      0|    if ((ctxt->node->children == NULL) &&
  ------------------
  |  Branch (3111:9): [True: 0, False: 0]
  ------------------
 3112|      0|	(RAW == '<') && (NXT(1) == '/')) return(0);
  ------------------
  |  | 2221|      0|#define RAW (*ctxt->input->cur)
  ------------------
              	(RAW == '<') && (NXT(1) == '/')) return(0);
  ------------------
  |  | 2223|      0|#define NXT(val) ctxt->input->cur[(val)]
  ------------------
  |  Branch (3112:2): [True: 0, False: 0]
  |  Branch (3112:18): [True: 0, False: 0]
  ------------------
 3113|       |
 3114|      0|    lastChild = xmlGetLastChild(ctxt->node);
 3115|      0|    if (lastChild == NULL) {
  ------------------
  |  Branch (3115:9): [True: 0, False: 0]
  ------------------
 3116|      0|        if ((ctxt->node->type != XML_ELEMENT_NODE) &&
  ------------------
  |  Branch (3116:13): [True: 0, False: 0]
  ------------------
 3117|      0|            (ctxt->node->content != NULL)) return(0);
  ------------------
  |  Branch (3117:13): [True: 0, False: 0]
  ------------------
 3118|      0|    } else if (xmlNodeIsText(lastChild))
  ------------------
  |  Branch (3118:16): [True: 0, False: 0]
  ------------------
 3119|      0|        return(0);
 3120|      0|    else if ((ctxt->node->children != NULL) &&
  ------------------
  |  Branch (3120:14): [True: 0, False: 0]
  ------------------
 3121|      0|             (xmlNodeIsText(ctxt->node->children)))
  ------------------
  |  Branch (3121:14): [True: 0, False: 0]
  ------------------
 3122|      0|        return(0);
 3123|      0|    return(1);
 3124|      0|}
parser.c:xmlParseCharDataComplex:
 4711|     61|xmlParseCharDataComplex(xmlParserCtxtPtr ctxt, int partial) {
 4712|     61|    xmlChar buf[XML_PARSER_BIG_BUFFER_SIZE + 5];
 4713|     61|    int nbchar = 0;
 4714|     61|    int cur, l;
 4715|       |
 4716|     61|    cur = CUR_CHAR(l);
  ------------------
  |  | 2291|     61|#define CUR_CHAR(l) xmlCurrentChar(ctxt, &l)
  ------------------
 4717|    394|    while ((cur != '<') && /* checked */
  ------------------
  |  Branch (4717:12): [True: 347, False: 47]
  ------------------
 4718|    394|           (cur != '&') &&
  ------------------
  |  Branch (4718:12): [True: 347, False: 0]
  ------------------
 4719|    394|	   (IS_CHAR(cur))) {
  ------------------
  |  |  125|    347|#define IS_CHAR(c)   xmlIsCharQ(c)
  |  |  ------------------
  |  |  |  |  118|    347|#define xmlIsCharQ(c)		(((c) < 0x100) ? \
  |  |  |  |  ------------------
  |  |  |  |  |  Branch (118:25): [True: 344, False: 3]
  |  |  |  |  ------------------
  |  |  |  |  119|    347|				 xmlIsChar_ch((c)) :\
  |  |  |  |  ------------------
  |  |  |  |  |  |  108|    344|#define xmlIsChar_ch(c)		(((0x9 <= (c)) && ((c) <= 0xa)) || \
  |  |  |  |  |  |  ------------------
  |  |  |  |  |  |  |  Branch (108:28): [True: 332, False: 12]
  |  |  |  |  |  |  |  Branch (108:44): [True: 128, False: 204]
  |  |  |  |  |  |  ------------------
  |  |  |  |  |  |  109|    344|				 ((c) == 0xd) || \
  |  |  |  |  |  |  ------------------
  |  |  |  |  |  |  |  Branch (109:6): [True: 0, False: 216]
  |  |  |  |  |  |  ------------------
  |  |  |  |  |  |  110|    344|				  (0x20 <= (c)))
  |  |  |  |  |  |  ------------------
  |  |  |  |  |  |  |  Branch (110:7): [True: 202, False: 14]
  |  |  |  |  |  |  ------------------
  |  |  |  |  ------------------
  |  |  |  |  120|    347|				(((0x100 <= (c)) && ((c) <= 0xd7ff)) || \
  |  |  |  |  ------------------
  |  |  |  |  |  Branch (120:7): [True: 3, False: 0]
  |  |  |  |  |  Branch (120:25): [True: 0, False: 3]
  |  |  |  |  ------------------
  |  |  |  |  121|      3|				 ((0xe000 <= (c)) && ((c) <= 0xfffd)) || \
  |  |  |  |  ------------------
  |  |  |  |  |  Branch (121:7): [True: 3, False: 0]
  |  |  |  |  |  Branch (121:26): [True: 3, False: 0]
  |  |  |  |  ------------------
  |  |  |  |  122|      3|				 ((0x10000 <= (c)) && ((c) <= 0x10ffff))))
  |  |  |  |  ------------------
  |  |  |  |  |  Branch (122:7): [True: 0, False: 0]
  |  |  |  |  |  Branch (122:27): [True: 0, False: 0]
  |  |  |  |  ------------------
  |  |  ------------------
  ------------------
  |  Branch (4719:5): [True: 333, False: 14]
  ------------------
 4720|    333|	if ((cur == ']') && (NXT(1) == ']') && (NXT(2) == '>')) {
  ------------------
  |  | 2223|      0|#define NXT(val) ctxt->input->cur[(val)]
  ------------------
              	if ((cur == ']') && (NXT(1) == ']') && (NXT(2) == '>')) {
  ------------------
  |  | 2223|      0|#define NXT(val) ctxt->input->cur[(val)]
  ------------------
  |  Branch (4720:6): [True: 0, False: 333]
  |  Branch (4720:22): [True: 0, False: 0]
  |  Branch (4720:41): [True: 0, False: 0]
  ------------------
 4721|      0|	    xmlFatalErr(ctxt, XML_ERR_MISPLACED_CDATA_END, NULL);
 4722|      0|	}
 4723|    333|	COPY_BUF(buf, nbchar, cur);
  ------------------
  |  | 2295|    333|    if (v < 0x80) b[i++] = v;						\
  |  |  ------------------
  |  |  |  Branch (2295:9): [True: 329, False: 4]
  |  |  ------------------
  |  | 2296|    333|    else i += xmlCopyCharMultiByte(&b[i],v)
  ------------------
 4724|       |	/* move current position before possible calling of ctxt->sax->characters */
 4725|    333|	NEXTL(l);
  ------------------
  |  | 2284|    333|#define NEXTL(l) do {							\
  |  | 2285|    333|    if (*(ctxt->input->cur) == '\n') {					\
  |  |  ------------------
  |  |  |  Branch (2285:9): [True: 50, False: 283]
  |  |  ------------------
  |  | 2286|     50|	ctxt->input->line++; ctxt->input->col = 1;			\
  |  | 2287|    283|    } else ctxt->input->col++;						\
  |  | 2288|    333|    ctxt->input->cur += l;				\
  |  | 2289|    333|  } while (0)
  |  |  ------------------
  |  |  |  Branch (2289:12): [Folded - Ignored]
  |  |  ------------------
  ------------------
 4726|    333|	if (nbchar >= XML_PARSER_BIG_BUFFER_SIZE) {
  ------------------
  |  |  166|    333|#define XML_PARSER_BIG_BUFFER_SIZE 300
  ------------------
  |  Branch (4726:6): [True: 0, False: 333]
  ------------------
 4727|      0|	    buf[nbchar] = 0;
 4728|       |
 4729|       |	    /*
 4730|       |	     * OK the segment is to be consumed as chars.
 4731|       |	     */
 4732|      0|	    if ((ctxt->sax != NULL) && (!ctxt->disableSAX)) {
  ------------------
  |  Branch (4732:10): [True: 0, False: 0]
  |  Branch (4732:33): [True: 0, False: 0]
  ------------------
 4733|      0|		if (areBlanks(ctxt, buf, nbchar, 0)) {
  ------------------
  |  Branch (4733:7): [True: 0, False: 0]
  ------------------
 4734|      0|		    if (ctxt->sax->ignorableWhitespace != NULL)
  ------------------
  |  Branch (4734:11): [True: 0, False: 0]
  ------------------
 4735|      0|			ctxt->sax->ignorableWhitespace(ctxt->userData,
 4736|      0|			                               buf, nbchar);
 4737|      0|		} else {
 4738|      0|		    if (ctxt->sax->characters != NULL)
  ------------------
  |  Branch (4738:11): [True: 0, False: 0]
  ------------------
 4739|      0|			ctxt->sax->characters(ctxt->userData, buf, nbchar);
 4740|      0|		    if ((ctxt->sax->characters !=
  ------------------
  |  Branch (4740:11): [True: 0, False: 0]
  ------------------
 4741|      0|		         ctxt->sax->ignorableWhitespace) &&
 4742|      0|			(*ctxt->space == -1))
  ------------------
  |  Branch (4742:4): [True: 0, False: 0]
  ------------------
 4743|      0|			*ctxt->space = -2;
 4744|      0|		}
 4745|      0|	    }
 4746|      0|	    nbchar = 0;
 4747|       |            /* something really bad happened in the SAX callback */
 4748|      0|            if (ctxt->instate != XML_PARSER_CONTENT)
  ------------------
  |  Branch (4748:17): [True: 0, False: 0]
  ------------------
 4749|      0|                return;
 4750|      0|            SHRINK;
  ------------------
  |  | 2265|      0|    if (((ctxt->progressive == 0) || (ctxt->inputNr > 1)) && \
  |  |  ------------------
  |  |  |  Branch (2265:10): [True: 0, False: 0]
  |  |  |  Branch (2265:38): [True: 0, False: 0]
  |  |  ------------------
  |  | 2266|      0|        (ctxt->input->cur - ctxt->input->base > 2 * INPUT_CHUNK) && \
  |  |  ------------------
  |  |  |  |   97|      0|#define INPUT_CHUNK	250
  |  |  ------------------
  |  |  |  Branch (2266:9): [True: 0, False: 0]
  |  |  ------------------
  |  | 2267|      0|	(ctxt->input->end - ctxt->input->cur < 2 * INPUT_CHUNK)) \
  |  |  ------------------
  |  |  |  |   97|      0|#define INPUT_CHUNK	250
  |  |  ------------------
  |  |  |  Branch (2267:2): [True: 0, False: 0]
  |  |  ------------------
  |  | 2268|      0|	xmlParserShrink(ctxt);
  ------------------
 4751|      0|	}
 4752|    333|	cur = CUR_CHAR(l);
  ------------------
  |  | 2291|    333|#define CUR_CHAR(l) xmlCurrentChar(ctxt, &l)
  ------------------
 4753|    333|    }
 4754|     61|    if (ctxt->instate == XML_PARSER_EOF)
  ------------------
  |  Branch (4754:9): [True: 0, False: 61]
  ------------------
 4755|      0|        return;
 4756|     61|    if (nbchar != 0) {
  ------------------
  |  Branch (4756:9): [True: 47, False: 14]
  ------------------
 4757|     47|        buf[nbchar] = 0;
 4758|       |	/*
 4759|       |	 * OK the segment is to be consumed as chars.
 4760|       |	 */
 4761|     47|	if ((ctxt->sax != NULL) && (!ctxt->disableSAX)) {
  ------------------
  |  Branch (4761:6): [True: 47, False: 0]
  |  Branch (4761:29): [True: 45, False: 2]
  ------------------
 4762|     45|	    if (areBlanks(ctxt, buf, nbchar, 0)) {
  ------------------
  |  Branch (4762:10): [True: 0, False: 45]
  ------------------
 4763|      0|		if (ctxt->sax->ignorableWhitespace != NULL)
  ------------------
  |  Branch (4763:7): [True: 0, False: 0]
  ------------------
 4764|      0|		    ctxt->sax->ignorableWhitespace(ctxt->userData, buf, nbchar);
 4765|     45|	    } else {
 4766|     45|		if (ctxt->sax->characters != NULL)
  ------------------
  |  Branch (4766:7): [True: 45, False: 0]
  ------------------
 4767|     45|		    ctxt->sax->characters(ctxt->userData, buf, nbchar);
 4768|     45|		if ((ctxt->sax->characters != ctxt->sax->ignorableWhitespace) &&
  ------------------
  |  Branch (4768:7): [True: 0, False: 45]
  ------------------
 4769|     45|		    (*ctxt->space == -1))
  ------------------
  |  Branch (4769:7): [True: 0, False: 0]
  ------------------
 4770|      0|		    *ctxt->space = -2;
 4771|     45|	    }
 4772|     45|	}
 4773|     47|    }
 4774|       |    /*
 4775|       |     * cur == 0 can mean
 4776|       |     *
 4777|       |     * - XML_PARSER_EOF or memory error. This is checked above.
 4778|       |     * - An actual 0 character.
 4779|       |     * - End of buffer.
 4780|       |     * - An incomplete UTF-8 sequence. This is allowed if partial is set.
 4781|       |     */
 4782|     61|    if (ctxt->input->cur < ctxt->input->end) {
  ------------------
  |  Branch (4782:9): [True: 57, False: 4]
  ------------------
 4783|     57|        if ((cur == 0) && (CUR != 0)) {
  ------------------
  |  | 2222|      8|#define CUR (*ctxt->input->cur)
  ------------------
  |  Branch (4783:13): [True: 8, False: 49]
  |  Branch (4783:27): [True: 0, False: 8]
  ------------------
 4784|      0|            if (partial == 0) {
  ------------------
  |  Branch (4784:17): [True: 0, False: 0]
  ------------------
 4785|      0|                xmlFatalErrMsgInt(ctxt, XML_ERR_INVALID_CHAR,
 4786|      0|                        "Incomplete UTF-8 sequence starting with %02X\n", CUR);
  ------------------
  |  | 2222|      0|#define CUR (*ctxt->input->cur)
  ------------------
 4787|      0|                NEXTL(1);
  ------------------
  |  | 2284|      0|#define NEXTL(l) do {							\
  |  | 2285|      0|    if (*(ctxt->input->cur) == '\n') {					\
  |  |  ------------------
  |  |  |  Branch (2285:9): [True: 0, False: 0]
  |  |  ------------------
  |  | 2286|      0|	ctxt->input->line++; ctxt->input->col = 1;			\
  |  | 2287|      0|    } else ctxt->input->col++;						\
  |  | 2288|      0|    ctxt->input->cur += l;				\
  |  | 2289|      0|  } while (0)
  |  |  ------------------
  |  |  |  Branch (2289:12): [Folded - Ignored]
  |  |  ------------------
  ------------------
 4788|      0|            }
 4789|     57|        } else if ((cur != '<') && (cur != '&')) {
  ------------------
  |  Branch (4789:20): [True: 10, False: 47]
  |  Branch (4789:36): [True: 10, False: 0]
  ------------------
 4790|       |            /* Generate the error and skip the offending character */
 4791|     10|            xmlFatalErrMsgInt(ctxt, XML_ERR_INVALID_CHAR,
 4792|     10|                              "PCDATA invalid Char value %d\n", cur);
 4793|     10|            NEXTL(l);
  ------------------
  |  | 2284|     10|#define NEXTL(l) do {							\
  |  | 2285|     10|    if (*(ctxt->input->cur) == '\n') {					\
  |  |  ------------------
  |  |  |  Branch (2285:9): [True: 0, False: 10]
  |  |  ------------------
  |  | 2286|      0|	ctxt->input->line++; ctxt->input->col = 1;			\
  |  | 2287|     10|    } else ctxt->input->col++;						\
  |  | 2288|     10|    ctxt->input->cur += l;				\
  |  | 2289|     10|  } while (0)
  |  |  ------------------
  |  |  |  Branch (2289:12): [Folded - Ignored]
  |  |  ------------------
  ------------------
 4794|     10|        }
 4795|     57|    }
 4796|     61|}
parser.c:xmlParseCommentComplex:
 4901|     30|                       size_t len, size_t size) {
 4902|     30|    int q, ql;
 4903|     30|    int r, rl;
 4904|     30|    int cur, l;
 4905|     30|    size_t maxLength = (ctxt->options & XML_PARSE_HUGE) ?
  ------------------
  |  Branch (4905:24): [True: 0, False: 30]
  ------------------
 4906|      0|                       XML_MAX_HUGE_LENGTH :
  ------------------
  |  |   49|      0|#define XML_MAX_HUGE_LENGTH 1000000000
  ------------------
 4907|     30|                       XML_MAX_TEXT_LENGTH;
  ------------------
  |  |   42|     60|#define XML_MAX_TEXT_LENGTH 10000000
  ------------------
 4908|     30|    int inputid;
 4909|       |
 4910|     30|    inputid = ctxt->input->id;
 4911|       |
 4912|     30|    if (buf == NULL) {
  ------------------
  |  Branch (4912:9): [True: 0, False: 30]
  ------------------
 4913|      0|        len = 0;
 4914|      0|	size = XML_PARSER_BUFFER_SIZE;
  ------------------
  |  |  167|      0|#define XML_PARSER_BUFFER_SIZE 100
  ------------------
 4915|      0|	buf = (xmlChar *) xmlMallocAtomic(size);
 4916|      0|	if (buf == NULL) {
  ------------------
  |  Branch (4916:6): [True: 0, False: 0]
  ------------------
 4917|      0|	    xmlErrMemory(ctxt, NULL);
 4918|      0|	    return;
 4919|      0|	}
 4920|      0|    }
 4921|     30|    q = CUR_CHAR(ql);
  ------------------
  |  | 2291|     30|#define CUR_CHAR(l) xmlCurrentChar(ctxt, &l)
  ------------------
 4922|     30|    if (q == 0)
  ------------------
  |  Branch (4922:9): [True: 1, False: 29]
  ------------------
 4923|      1|        goto not_terminated;
 4924|     29|    if (!IS_CHAR(q)) {
  ------------------
  |  |  125|     29|#define IS_CHAR(c)   xmlIsCharQ(c)
  |  |  ------------------
  |  |  |  |  118|     29|#define xmlIsCharQ(c)		(((c) < 0x100) ? \
  |  |  |  |  ------------------
  |  |  |  |  |  Branch (118:25): [True: 27, False: 2]
  |  |  |  |  ------------------
  |  |  |  |  119|     29|				 xmlIsChar_ch((c)) :\
  |  |  |  |  ------------------
  |  |  |  |  |  |  108|     27|#define xmlIsChar_ch(c)		(((0x9 <= (c)) && ((c) <= 0xa)) || \
  |  |  |  |  |  |  ------------------
  |  |  |  |  |  |  |  Branch (108:28): [True: 27, False: 0]
  |  |  |  |  |  |  |  Branch (108:44): [True: 0, False: 27]
  |  |  |  |  |  |  ------------------
  |  |  |  |  |  |  109|     27|				 ((c) == 0xd) || \
  |  |  |  |  |  |  ------------------
  |  |  |  |  |  |  |  Branch (109:6): [True: 0, False: 27]
  |  |  |  |  |  |  ------------------
  |  |  |  |  |  |  110|     27|				  (0x20 <= (c)))
  |  |  |  |  |  |  ------------------
  |  |  |  |  |  |  |  Branch (110:7): [True: 27, False: 0]
  |  |  |  |  |  |  ------------------
  |  |  |  |  ------------------
  |  |  |  |  120|     29|				(((0x100 <= (c)) && ((c) <= 0xd7ff)) || \
  |  |  |  |  ------------------
  |  |  |  |  |  Branch (120:7): [True: 2, False: 0]
  |  |  |  |  |  Branch (120:25): [True: 0, False: 2]
  |  |  |  |  ------------------
  |  |  |  |  121|      2|				 ((0xe000 <= (c)) && ((c) <= 0xfffd)) || \
  |  |  |  |  ------------------
  |  |  |  |  |  Branch (121:7): [True: 2, False: 0]
  |  |  |  |  |  Branch (121:26): [True: 2, False: 0]
  |  |  |  |  ------------------
  |  |  |  |  122|      2|				 ((0x10000 <= (c)) && ((c) <= 0x10ffff))))
  |  |  |  |  ------------------
  |  |  |  |  |  Branch (122:7): [True: 0, False: 0]
  |  |  |  |  |  Branch (122:27): [True: 0, False: 0]
  |  |  |  |  ------------------
  |  |  ------------------
  ------------------
  |  Branch (4924:9): [True: 0, False: 29]
  ------------------
 4925|      0|        xmlFatalErrMsgInt(ctxt, XML_ERR_INVALID_CHAR,
 4926|      0|                          "xmlParseComment: invalid xmlChar value %d\n",
 4927|      0|	                  q);
 4928|      0|	xmlFree (buf);
 4929|      0|	return;
 4930|      0|    }
 4931|     29|    NEXTL(ql);
  ------------------
  |  | 2284|     29|#define NEXTL(l) do {							\
  |  | 2285|     29|    if (*(ctxt->input->cur) == '\n') {					\
  |  |  ------------------
  |  |  |  Branch (2285:9): [True: 0, False: 29]
  |  |  ------------------
  |  | 2286|      0|	ctxt->input->line++; ctxt->input->col = 1;			\
  |  | 2287|     29|    } else ctxt->input->col++;						\
  |  | 2288|     29|    ctxt->input->cur += l;				\
  |  | 2289|     29|  } while (0)
  |  |  ------------------
  |  |  |  Branch (2289:12): [Folded - Ignored]
  |  |  ------------------
  ------------------
 4932|     29|    r = CUR_CHAR(rl);
  ------------------
  |  | 2291|     29|#define CUR_CHAR(l) xmlCurrentChar(ctxt, &l)
  ------------------
 4933|     29|    if (r == 0)
  ------------------
  |  Branch (4933:9): [True: 0, False: 29]
  ------------------
 4934|      0|        goto not_terminated;
 4935|     29|    if (!IS_CHAR(r)) {
  ------------------
  |  |  125|     29|#define IS_CHAR(c)   xmlIsCharQ(c)
  |  |  ------------------
  |  |  |  |  118|     29|#define xmlIsCharQ(c)		(((c) < 0x100) ? \
  |  |  |  |  ------------------
  |  |  |  |  |  Branch (118:25): [True: 27, False: 2]
  |  |  |  |  ------------------
  |  |  |  |  119|     29|				 xmlIsChar_ch((c)) :\
  |  |  |  |  ------------------
  |  |  |  |  |  |  108|     27|#define xmlIsChar_ch(c)		(((0x9 <= (c)) && ((c) <= 0xa)) || \
  |  |  |  |  |  |  ------------------
  |  |  |  |  |  |  |  Branch (108:28): [True: 27, False: 0]
  |  |  |  |  |  |  |  Branch (108:44): [True: 0, False: 27]
  |  |  |  |  |  |  ------------------
  |  |  |  |  |  |  109|     27|				 ((c) == 0xd) || \
  |  |  |  |  |  |  ------------------
  |  |  |  |  |  |  |  Branch (109:6): [True: 0, False: 27]
  |  |  |  |  |  |  ------------------
  |  |  |  |  |  |  110|     27|				  (0x20 <= (c)))
  |  |  |  |  |  |  ------------------
  |  |  |  |  |  |  |  Branch (110:7): [True: 27, False: 0]
  |  |  |  |  |  |  ------------------
  |  |  |  |  ------------------
  |  |  |  |  120|     29|				(((0x100 <= (c)) && ((c) <= 0xd7ff)) || \
  |  |  |  |  ------------------
  |  |  |  |  |  Branch (120:7): [True: 2, False: 0]
  |  |  |  |  |  Branch (120:25): [True: 0, False: 2]
  |  |  |  |  ------------------
  |  |  |  |  121|      2|				 ((0xe000 <= (c)) && ((c) <= 0xfffd)) || \
  |  |  |  |  ------------------
  |  |  |  |  |  Branch (121:7): [True: 2, False: 0]
  |  |  |  |  |  Branch (121:26): [True: 2, False: 0]
  |  |  |  |  ------------------
  |  |  |  |  122|      2|				 ((0x10000 <= (c)) && ((c) <= 0x10ffff))))
  |  |  |  |  ------------------
  |  |  |  |  |  Branch (122:7): [True: 0, False: 0]
  |  |  |  |  |  Branch (122:27): [True: 0, False: 0]
  |  |  |  |  ------------------
  |  |  ------------------
  ------------------
  |  Branch (4935:9): [True: 0, False: 29]
  ------------------
 4936|      0|        xmlFatalErrMsgInt(ctxt, XML_ERR_INVALID_CHAR,
 4937|      0|                          "xmlParseComment: invalid xmlChar value %d\n",
 4938|      0|	                  r);
 4939|      0|	xmlFree (buf);
 4940|      0|	return;
 4941|      0|    }
 4942|     29|    NEXTL(rl);
  ------------------
  |  | 2284|     29|#define NEXTL(l) do {							\
  |  | 2285|     29|    if (*(ctxt->input->cur) == '\n') {					\
  |  |  ------------------
  |  |  |  Branch (2285:9): [True: 0, False: 29]
  |  |  ------------------
  |  | 2286|      0|	ctxt->input->line++; ctxt->input->col = 1;			\
  |  | 2287|     29|    } else ctxt->input->col++;						\
  |  | 2288|     29|    ctxt->input->cur += l;				\
  |  | 2289|     29|  } while (0)
  |  |  ------------------
  |  |  |  Branch (2289:12): [Folded - Ignored]
  |  |  ------------------
  ------------------
 4943|     29|    cur = CUR_CHAR(l);
  ------------------
  |  | 2291|     29|#define CUR_CHAR(l) xmlCurrentChar(ctxt, &l)
  ------------------
 4944|     29|    if (cur == 0)
  ------------------
  |  Branch (4944:9): [True: 0, False: 29]
  ------------------
 4945|      0|        goto not_terminated;
 4946|  2.91k|    while (IS_CHAR(cur) && /* checked */
  ------------------
  |  |  125|  2.91k|#define IS_CHAR(c)   xmlIsCharQ(c)
  |  |  ------------------
  |  |  |  |  118|  5.83k|#define xmlIsCharQ(c)		(((c) < 0x100) ? \
  |  |  |  |  ------------------
  |  |  |  |  |  Branch (118:24): [True: 2.91k, False: 1]
  |  |  |  |  |  Branch (118:25): [True: 2.91k, False: 7]
  |  |  |  |  ------------------
  |  |  |  |  119|  5.83k|				 xmlIsChar_ch((c)) :\
  |  |  |  |  ------------------
  |  |  |  |  |  |  108|  2.91k|#define xmlIsChar_ch(c)		(((0x9 <= (c)) && ((c) <= 0xa)) || \
  |  |  |  |  |  |  ------------------
  |  |  |  |  |  |  |  Branch (108:28): [True: 2.91k, False: 0]
  |  |  |  |  |  |  |  Branch (108:44): [True: 80, False: 2.83k]
  |  |  |  |  |  |  ------------------
  |  |  |  |  |  |  109|  2.91k|				 ((c) == 0xd) || \
  |  |  |  |  |  |  ------------------
  |  |  |  |  |  |  |  Branch (109:6): [True: 0, False: 2.83k]
  |  |  |  |  |  |  ------------------
  |  |  |  |  |  |  110|  2.91k|				  (0x20 <= (c)))
  |  |  |  |  |  |  ------------------
  |  |  |  |  |  |  |  Branch (110:7): [True: 2.82k, False: 1]
  |  |  |  |  |  |  ------------------
  |  |  |  |  ------------------
  |  |  |  |  120|  5.83k|				(((0x100 <= (c)) && ((c) <= 0xd7ff)) || \
  |  |  |  |  ------------------
  |  |  |  |  |  Branch (120:7): [True: 7, False: 0]
  |  |  |  |  |  Branch (120:25): [True: 0, False: 7]
  |  |  |  |  ------------------
  |  |  |  |  121|      7|				 ((0xe000 <= (c)) && ((c) <= 0xfffd)) || \
  |  |  |  |  ------------------
  |  |  |  |  |  Branch (121:7): [True: 7, False: 0]
  |  |  |  |  |  Branch (121:26): [True: 7, False: 0]
  |  |  |  |  ------------------
  |  |  |  |  122|      7|				 ((0x10000 <= (c)) && ((c) <= 0x10ffff))))
  |  |  |  |  ------------------
  |  |  |  |  |  Branch (122:7): [True: 0, False: 0]
  |  |  |  |  |  Branch (122:27): [True: 0, False: 0]
  |  |  |  |  ------------------
  |  |  ------------------
  ------------------
 4947|  2.91k|           ((cur != '>') ||
  ------------------
  |  Branch (4947:13): [True: 2.88k, False: 32]
  ------------------
 4948|  2.91k|	    (r != '-') || (q != '-'))) {
  ------------------
  |  Branch (4948:6): [True: 4, False: 28]
  |  Branch (4948:20): [True: 0, False: 28]
  ------------------
 4949|  2.88k|	if ((r == '-') && (q == '-')) {
  ------------------
  |  Branch (4949:6): [True: 29, False: 2.85k]
  |  Branch (4949:20): [True: 0, False: 29]
  ------------------
 4950|      0|	    xmlFatalErr(ctxt, XML_ERR_HYPHEN_IN_COMMENT, NULL);
 4951|      0|	}
 4952|  2.88k|	if (len + 5 >= size) {
  ------------------
  |  Branch (4952:6): [True: 10, False: 2.87k]
  ------------------
 4953|     10|	    xmlChar *new_buf;
 4954|     10|            size_t new_size;
 4955|       |
 4956|     10|	    new_size = size * 2;
 4957|     10|	    new_buf = (xmlChar *) xmlRealloc(buf, new_size);
 4958|     10|	    if (new_buf == NULL) {
  ------------------
  |  Branch (4958:10): [True: 0, False: 10]
  ------------------
 4959|      0|		xmlFree (buf);
 4960|      0|		xmlErrMemory(ctxt, NULL);
 4961|      0|		return;
 4962|      0|	    }
 4963|     10|	    buf = new_buf;
 4964|     10|            size = new_size;
 4965|     10|	}
 4966|  2.88k|	COPY_BUF(buf, len, q);
  ------------------
  |  | 2295|  2.88k|    if (v < 0x80) b[i++] = v;						\
  |  |  ------------------
  |  |  |  Branch (2295:9): [True: 2.80k, False: 82]
  |  |  ------------------
  |  | 2296|  2.88k|    else i += xmlCopyCharMultiByte(&b[i],v)
  ------------------
 4967|  2.88k|        if (len > maxLength) {
  ------------------
  |  Branch (4967:13): [True: 0, False: 2.88k]
  ------------------
 4968|      0|            xmlFatalErrMsgStr(ctxt, XML_ERR_COMMENT_NOT_FINISHED,
 4969|      0|                         "Comment too big found", NULL);
 4970|      0|            xmlFree (buf);
 4971|      0|            return;
 4972|      0|        }
 4973|       |
 4974|  2.88k|	q = r;
 4975|  2.88k|	ql = rl;
 4976|  2.88k|	r = cur;
 4977|  2.88k|	rl = l;
 4978|       |
 4979|  2.88k|	NEXTL(l);
  ------------------
  |  | 2284|  2.88k|#define NEXTL(l) do {							\
  |  | 2285|  2.88k|    if (*(ctxt->input->cur) == '\n') {					\
  |  |  ------------------
  |  |  |  Branch (2285:9): [True: 50, False: 2.83k]
  |  |  ------------------
  |  | 2286|     50|	ctxt->input->line++; ctxt->input->col = 1;			\
  |  | 2287|  2.83k|    } else ctxt->input->col++;						\
  |  | 2288|  2.88k|    ctxt->input->cur += l;				\
  |  | 2289|  2.88k|  } while (0)
  |  |  ------------------
  |  |  |  Branch (2289:12): [Folded - Ignored]
  |  |  ------------------
  ------------------
 4980|  2.88k|	cur = CUR_CHAR(l);
  ------------------
  |  | 2291|  2.88k|#define CUR_CHAR(l) xmlCurrentChar(ctxt, &l)
  ------------------
 4981|       |
 4982|  2.88k|    }
 4983|     29|    buf[len] = 0;
 4984|     29|    if (ctxt->instate == XML_PARSER_EOF) {
  ------------------
  |  Branch (4984:9): [True: 0, False: 29]
  ------------------
 4985|      0|        xmlFree(buf);
 4986|      0|        return;
 4987|      0|    }
 4988|     29|    if (cur == 0) {
  ------------------
  |  Branch (4988:9): [True: 0, False: 29]
  ------------------
 4989|      0|	xmlFatalErrMsgStr(ctxt, XML_ERR_COMMENT_NOT_FINISHED,
 4990|      0|	                     "Comment not terminated \n<!--%.50s\n", buf);
 4991|     29|    } else if (!IS_CHAR(cur)) {
  ------------------
  |  |  125|     29|#define IS_CHAR(c)   xmlIsCharQ(c)
  |  |  ------------------
  |  |  |  |  118|     29|#define xmlIsCharQ(c)		(((c) < 0x100) ? \
  |  |  |  |  ------------------
  |  |  |  |  |  Branch (118:25): [True: 29, False: 0]
  |  |  |  |  ------------------
  |  |  |  |  119|     29|				 xmlIsChar_ch((c)) :\
  |  |  |  |  ------------------
  |  |  |  |  |  |  108|     29|#define xmlIsChar_ch(c)		(((0x9 <= (c)) && ((c) <= 0xa)) || \
  |  |  |  |  |  |  ------------------
  |  |  |  |  |  |  |  Branch (108:28): [True: 29, False: 0]
  |  |  |  |  |  |  |  Branch (108:44): [True: 0, False: 29]
  |  |  |  |  |  |  ------------------
  |  |  |  |  |  |  109|     29|				 ((c) == 0xd) || \
  |  |  |  |  |  |  ------------------
  |  |  |  |  |  |  |  Branch (109:6): [True: 0, False: 29]
  |  |  |  |  |  |  ------------------
  |  |  |  |  |  |  110|     29|				  (0x20 <= (c)))
  |  |  |  |  |  |  ------------------
  |  |  |  |  |  |  |  Branch (110:7): [True: 28, False: 1]
  |  |  |  |  |  |  ------------------
  |  |  |  |  ------------------
  |  |  |  |  120|     29|				(((0x100 <= (c)) && ((c) <= 0xd7ff)) || \
  |  |  |  |  ------------------
  |  |  |  |  |  Branch (120:7): [True: 0, False: 0]
  |  |  |  |  |  Branch (120:25): [True: 0, False: 0]
  |  |  |  |  ------------------
  |  |  |  |  121|      0|				 ((0xe000 <= (c)) && ((c) <= 0xfffd)) || \
  |  |  |  |  ------------------
  |  |  |  |  |  Branch (121:7): [True: 0, False: 0]
  |  |  |  |  |  Branch (121:26): [True: 0, False: 0]
  |  |  |  |  ------------------
  |  |  |  |  122|      0|				 ((0x10000 <= (c)) && ((c) <= 0x10ffff))))
  |  |  |  |  ------------------
  |  |  |  |  |  Branch (122:7): [True: 0, False: 0]
  |  |  |  |  |  Branch (122:27): [True: 0, False: 0]
  |  |  |  |  ------------------
  |  |  ------------------
  ------------------
  |  Branch (4991:16): [True: 1, False: 28]
  ------------------
 4992|      1|        xmlFatalErrMsgInt(ctxt, XML_ERR_INVALID_CHAR,
 4993|      1|                          "xmlParseComment: invalid xmlChar value %d\n",
 4994|      1|	                  cur);
 4995|     28|    } else {
 4996|     28|	if (inputid != ctxt->input->id) {
  ------------------
  |  Branch (4996:6): [True: 0, False: 28]
  ------------------
 4997|      0|	    xmlFatalErrMsg(ctxt, XML_ERR_ENTITY_BOUNDARY,
 4998|      0|		           "Comment doesn't start and stop in the same"
 4999|      0|                           " entity\n");
 5000|      0|	}
 5001|     28|        NEXT;
  ------------------
  |  | 2275|     28|#define NEXT xmlNextChar(ctxt)
  ------------------
 5002|     28|	if ((ctxt->sax != NULL) && (ctxt->sax->comment != NULL) &&
  ------------------
  |  Branch (5002:6): [True: 28, False: 0]
  |  Branch (5002:29): [True: 28, False: 0]
  ------------------
 5003|     28|	    (!ctxt->disableSAX))
  ------------------
  |  Branch (5003:6): [True: 27, False: 1]
  ------------------
 5004|     27|	    ctxt->sax->comment(ctxt->userData, buf);
 5005|     28|    }
 5006|     29|    xmlFree(buf);
 5007|     29|    return;
 5008|      1|not_terminated:
 5009|      1|    xmlFatalErrMsgStr(ctxt, XML_ERR_COMMENT_NOT_FINISHED,
 5010|      1|			 "Comment not terminated\n", NULL);
 5011|      1|    xmlFree(buf);
 5012|      1|    return;
 5013|     29|}
parser.c:xmlNsErr:
  501|      5|{
  502|      5|    if ((ctxt != NULL) && (ctxt->disableSAX != 0) &&
  ------------------
  |  Branch (502:9): [True: 5, False: 0]
  |  Branch (502:27): [True: 2, False: 3]
  ------------------
  503|      5|        (ctxt->instate == XML_PARSER_EOF))
  ------------------
  |  Branch (503:9): [True: 0, False: 2]
  ------------------
  504|      0|	return;
  505|      5|    if (ctxt != NULL)
  ------------------
  |  Branch (505:9): [True: 5, False: 0]
  ------------------
  506|      5|	ctxt->errNo = error;
  507|      5|    __xmlRaiseError(NULL, NULL, NULL, ctxt, NULL, XML_FROM_NAMESPACE, error,
  508|      5|                    XML_ERR_ERROR, NULL, 0, (const char *) info1,
  509|      5|                    (const char *) info2, (const char *) info3, 0, 0, msg,
  510|      5|                    info1, info2, info3);
  511|      5|    if (ctxt != NULL)
  ------------------
  |  Branch (511:9): [True: 5, False: 0]
  ------------------
  512|      5|	ctxt->nsWellFormed = 0;
  513|      5|}
parser.c:xmlDetectSAX2:
  857|    238|xmlDetectSAX2(xmlParserCtxtPtr ctxt) {
  858|    238|    xmlSAXHandlerPtr sax;
  859|       |
  860|       |    /* Avoid unused variable warning if features are disabled. */
  861|    238|    (void) sax;
  862|       |
  863|    238|    if (ctxt == NULL) return;
  ------------------
  |  Branch (863:9): [True: 0, False: 238]
  ------------------
  864|    238|    sax = ctxt->sax;
  865|    238|#ifdef LIBXML_SAX1_ENABLED
  866|    238|    if ((sax) && (sax->initialized == XML_SAX2_MAGIC))
  ------------------
  |  |  685|    238|#define XML_SAX2_MAGIC 0xDEEDBEAF
  ------------------
  |  Branch (866:9): [True: 238, False: 0]
  |  Branch (866:18): [True: 238, False: 0]
  ------------------
  867|    238|        ctxt->sax2 = 1;
  868|       |#else
  869|       |    ctxt->sax2 = 1;
  870|       |#endif /* LIBXML_SAX1_ENABLED */
  871|       |
  872|    238|    ctxt->str_xml = xmlDictLookup(ctxt->dict, BAD_CAST "xml", 3);
  ------------------
  |  |   35|    238|#define BAD_CAST (xmlChar *)
  ------------------
  873|    238|    ctxt->str_xmlns = xmlDictLookup(ctxt->dict, BAD_CAST "xmlns", 5);
  ------------------
  |  |   35|    238|#define BAD_CAST (xmlChar *)
  ------------------
  874|    238|    ctxt->str_xml_ns = xmlDictLookup(ctxt->dict, XML_XML_NAMESPACE, 36);
  ------------------
  |  |  143|    238|    (const xmlChar *) "http://www.w3.org/XML/1998/namespace"
  ------------------
  875|    238|    if ((ctxt->str_xml==NULL) || (ctxt->str_xmlns==NULL) ||
  ------------------
  |  Branch (875:9): [True: 0, False: 238]
  |  Branch (875:34): [True: 0, False: 238]
  ------------------
  876|    238|		(ctxt->str_xml_ns == NULL)) {
  ------------------
  |  Branch (876:3): [True: 0, False: 238]
  ------------------
  877|      0|        xmlErrMemory(ctxt, NULL);
  878|      0|    }
  879|    238|}
parser.c:xmlParseNameAndCompare:
 3682|    165|xmlParseNameAndCompare(xmlParserCtxtPtr ctxt, xmlChar const *other) {
 3683|    165|    register const xmlChar *cmp = other;
 3684|    165|    register const xmlChar *in;
 3685|    165|    const xmlChar *ret;
 3686|       |
 3687|    165|    GROW;
  ------------------
  |  | 2270|    165|#define GROW if (ctxt->input->end - ctxt->input->cur < INPUT_CHUNK)	\
  |  |  ------------------
  |  |  |  |   97|    165|#define INPUT_CHUNK	250
  |  |  ------------------
  |  |  |  Branch (2270:18): [True: 106, False: 59]
  |  |  ------------------
  |  | 2271|    165|	xmlParserGrow(ctxt);
  ------------------
 3688|    165|    if (ctxt->instate == XML_PARSER_EOF)
  ------------------
  |  Branch (3688:9): [True: 0, False: 165]
  ------------------
 3689|      0|        return(NULL);
 3690|       |
 3691|    165|    in = ctxt->input->cur;
 3692|  1.67k|    while (*in != 0 && *in == *cmp) {
  ------------------
  |  Branch (3692:12): [True: 1.67k, False: 0]
  |  Branch (3692:24): [True: 1.50k, False: 165]
  ------------------
 3693|  1.50k|	++in;
 3694|  1.50k|	++cmp;
 3695|  1.50k|    }
 3696|    165|    if (*cmp == 0 && (*in == '>' || IS_BLANK_CH (*in))) {
  ------------------
  |  |  151|      0|#define IS_BLANK_CH(c)  xmlIsBlank_ch(c)
  |  |  ------------------
  |  |  |  |   88|      0|#define xmlIsBlank_ch(c)	(((c) == 0x20) || \
  |  |  |  |  ------------------
  |  |  |  |  |  Branch (88:27): [True: 0, False: 0]
  |  |  |  |  ------------------
  |  |  |  |   89|      0|				 ((0x9 <= (c)) && ((c) <= 0xa)) || \
  |  |  |  |  ------------------
  |  |  |  |  |  Branch (89:7): [True: 0, False: 0]
  |  |  |  |  |  Branch (89:23): [True: 0, False: 0]
  |  |  |  |  ------------------
  |  |  |  |   90|      0|				 ((c) == 0xd))
  |  |  |  |  ------------------
  |  |  |  |  |  Branch (90:6): [True: 0, False: 0]
  |  |  |  |  ------------------
  |  |  ------------------
  ------------------
  |  Branch (3696:9): [True: 162, False: 3]
  |  Branch (3696:23): [True: 162, False: 0]
  ------------------
 3697|       |	/* success */
 3698|    162|	ctxt->input->col += in - ctxt->input->cur;
 3699|    162|	ctxt->input->cur = in;
 3700|    162|	return (const xmlChar*) 1;
 3701|    162|    }
 3702|       |    /* failure (or end of input buffer), check with full function */
 3703|      3|    ret = xmlParseName (ctxt);
 3704|       |    /* strings coming from the dictionary direct compare possible */
 3705|      3|    if (ret == other) {
  ------------------
  |  Branch (3705:9): [True: 0, False: 3]
  ------------------
 3706|      0|	return (const xmlChar*) 1;
 3707|      0|    }
 3708|      3|    return ret;
 3709|      3|}
parser.c:spacePop:
 2173|  3.73k|static int spacePop(xmlParserCtxtPtr ctxt) {
 2174|  3.73k|    int ret;
 2175|  3.73k|    if (ctxt->spaceNr <= 0) return(0);
  ------------------
  |  Branch (2175:9): [True: 0, False: 3.73k]
  ------------------
 2176|  3.73k|    ctxt->spaceNr--;
 2177|  3.73k|    if (ctxt->spaceNr > 0)
  ------------------
  |  Branch (2177:9): [True: 3.50k, False: 230]
  ------------------
 2178|  3.50k|	ctxt->space = &ctxt->spaceTab[ctxt->spaceNr - 1];
 2179|    230|    else
 2180|    230|        ctxt->space = &ctxt->spaceTab[0];
 2181|  3.73k|    ret = ctxt->spaceTab[ctxt->spaceNr];
 2182|  3.73k|    ctxt->spaceTab[ctxt->spaceNr] = -1;
 2183|  3.73k|    return(ret);
 2184|  3.73k|}
parser.c:xmlParseAttValueInternal:
 9115|  4.62k|{
 9116|  4.62k|    xmlChar limit = 0;
 9117|  4.62k|    const xmlChar *in = NULL, *start, *end, *last;
 9118|  4.62k|    xmlChar *ret = NULL;
 9119|  4.62k|    int line, col;
 9120|  4.62k|    int maxLength = (ctxt->options & XML_PARSE_HUGE) ?
  ------------------
  |  Branch (9120:21): [True: 0, False: 4.62k]
  ------------------
 9121|      0|                    XML_MAX_HUGE_LENGTH :
  ------------------
  |  |   49|      0|#define XML_MAX_HUGE_LENGTH 1000000000
  ------------------
 9122|  4.62k|                    XML_MAX_TEXT_LENGTH;
  ------------------
  |  |   42|  4.62k|#define XML_MAX_TEXT_LENGTH 10000000
  ------------------
 9123|       |
 9124|  4.62k|    GROW;
  ------------------
  |  | 2270|  4.62k|#define GROW if (ctxt->input->end - ctxt->input->cur < INPUT_CHUNK)	\
  |  |  ------------------
  |  |  |  |   97|  4.62k|#define INPUT_CHUNK	250
  |  |  ------------------
  |  |  |  Branch (2270:18): [True: 1.06k, False: 3.55k]
  |  |  ------------------
  |  | 2271|  4.62k|	xmlParserGrow(ctxt);
  ------------------
 9125|  4.62k|    in = (xmlChar *) CUR_PTR;
  ------------------
  |  | 2224|  4.62k|#define CUR_PTR ctxt->input->cur
  ------------------
 9126|  4.62k|    line = ctxt->input->line;
 9127|  4.62k|    col = ctxt->input->col;
 9128|  4.62k|    if (*in != '"' && *in != '\'') {
  ------------------
  |  Branch (9128:9): [True: 50, False: 4.57k]
  |  Branch (9128:23): [True: 0, False: 50]
  ------------------
 9129|      0|        xmlFatalErr(ctxt, XML_ERR_ATTRIBUTE_NOT_STARTED, NULL);
 9130|      0|        return (NULL);
 9131|      0|    }
 9132|  4.62k|    ctxt->instate = XML_PARSER_ATTRIBUTE_VALUE;
 9133|       |
 9134|       |    /*
 9135|       |     * try to handle in this routine the most common case where no
 9136|       |     * allocation of a new string is required and where content is
 9137|       |     * pure ASCII.
 9138|       |     */
 9139|  4.62k|    limit = *in++;
 9140|  4.62k|    col++;
 9141|  4.62k|    end = ctxt->input->end;
 9142|  4.62k|    start = in;
 9143|  4.62k|    if (in >= end) {
  ------------------
  |  Branch (9143:9): [True: 0, False: 4.62k]
  ------------------
 9144|      0|        GROW_PARSE_ATT_VALUE_INTERNAL(ctxt, in, start, end)
  ------------------
  |  | 9101|      0|    const xmlChar *oldbase = ctxt->input->base;\
  |  | 9102|      0|    GROW;\
  |  |  ------------------
  |  |  |  | 2270|      0|#define GROW if (ctxt->input->end - ctxt->input->cur < INPUT_CHUNK)	\
  |  |  |  |  ------------------
  |  |  |  |  |  |   97|      0|#define INPUT_CHUNK	250
  |  |  |  |  ------------------
  |  |  |  |  |  Branch (2270:18): [True: 0, False: 0]
  |  |  |  |  ------------------
  |  |  |  | 2271|      0|	xmlParserGrow(ctxt);
  |  |  ------------------
  |  | 9103|      0|    if (ctxt->instate == XML_PARSER_EOF)\
  |  |  ------------------
  |  |  |  Branch (9103:9): [True: 0, False: 0]
  |  |  ------------------
  |  | 9104|      0|        return(NULL);\
  |  | 9105|      0|    if (oldbase != ctxt->input->base) {\
  |  |  ------------------
  |  |  |  Branch (9105:9): [True: 0, False: 0]
  |  |  ------------------
  |  | 9106|      0|        ptrdiff_t delta = ctxt->input->base - oldbase;\
  |  | 9107|      0|        start = start + delta;\
  |  | 9108|      0|        in = in + delta;\
  |  | 9109|      0|    }\
  |  | 9110|      0|    end = ctxt->input->end;
  ------------------
 9145|      0|    }
 9146|  4.62k|    if (normalize) {
  ------------------
  |  Branch (9146:9): [True: 0, False: 4.62k]
  ------------------
 9147|       |        /*
 9148|       |	 * Skip any leading spaces
 9149|       |	 */
 9150|      0|	while ((in < end) && (*in != limit) &&
  ------------------
  |  Branch (9150:9): [True: 0, False: 0]
  |  Branch (9150:23): [True: 0, False: 0]
  ------------------
 9151|      0|	       ((*in == 0x20) || (*in == 0x9) ||
  ------------------
  |  Branch (9151:10): [True: 0, False: 0]
  |  Branch (9151:27): [True: 0, False: 0]
  ------------------
 9152|      0|	        (*in == 0xA) || (*in == 0xD))) {
  ------------------
  |  Branch (9152:10): [True: 0, False: 0]
  |  Branch (9152:26): [True: 0, False: 0]
  ------------------
 9153|      0|	    if (*in == 0xA) {
  ------------------
  |  Branch (9153:10): [True: 0, False: 0]
  ------------------
 9154|      0|	        line++; col = 1;
 9155|      0|	    } else {
 9156|      0|	        col++;
 9157|      0|	    }
 9158|      0|	    in++;
 9159|      0|	    start = in;
 9160|      0|	    if (in >= end) {
  ------------------
  |  Branch (9160:10): [True: 0, False: 0]
  ------------------
 9161|      0|                GROW_PARSE_ATT_VALUE_INTERNAL(ctxt, in, start, end)
  ------------------
  |  | 9101|      0|    const xmlChar *oldbase = ctxt->input->base;\
  |  | 9102|      0|    GROW;\
  |  |  ------------------
  |  |  |  | 2270|      0|#define GROW if (ctxt->input->end - ctxt->input->cur < INPUT_CHUNK)	\
  |  |  |  |  ------------------
  |  |  |  |  |  |   97|      0|#define INPUT_CHUNK	250
  |  |  |  |  ------------------
  |  |  |  |  |  Branch (2270:18): [True: 0, False: 0]
  |  |  |  |  ------------------
  |  |  |  | 2271|      0|	xmlParserGrow(ctxt);
  |  |  ------------------
  |  | 9103|      0|    if (ctxt->instate == XML_PARSER_EOF)\
  |  |  ------------------
  |  |  |  Branch (9103:9): [True: 0, False: 0]
  |  |  ------------------
  |  | 9104|      0|        return(NULL);\
  |  | 9105|      0|    if (oldbase != ctxt->input->base) {\
  |  |  ------------------
  |  |  |  Branch (9105:9): [True: 0, False: 0]
  |  |  ------------------
  |  | 9106|      0|        ptrdiff_t delta = ctxt->input->base - oldbase;\
  |  | 9107|      0|        start = start + delta;\
  |  | 9108|      0|        in = in + delta;\
  |  | 9109|      0|    }\
  |  | 9110|      0|    end = ctxt->input->end;
  ------------------
 9162|      0|                if ((in - start) > maxLength) {
  ------------------
  |  Branch (9162:21): [True: 0, False: 0]
  ------------------
 9163|      0|                    xmlFatalErrMsg(ctxt, XML_ERR_ATTRIBUTE_NOT_FINISHED,
 9164|      0|                                   "AttValue length too long\n");
 9165|      0|                    return(NULL);
 9166|      0|                }
 9167|      0|	    }
 9168|      0|	}
 9169|      0|	while ((in < end) && (*in != limit) && (*in >= 0x20) &&
  ------------------
  |  Branch (9169:9): [True: 0, False: 0]
  |  Branch (9169:23): [True: 0, False: 0]
  |  Branch (9169:41): [True: 0, False: 0]
  ------------------
 9170|      0|	       (*in <= 0x7f) && (*in != '&') && (*in != '<')) {
  ------------------
  |  Branch (9170:9): [True: 0, False: 0]
  |  Branch (9170:26): [True: 0, False: 0]
  |  Branch (9170:42): [True: 0, False: 0]
  ------------------
 9171|      0|	    col++;
 9172|      0|	    if ((*in++ == 0x20) && (*in == 0x20)) break;
  ------------------
  |  Branch (9172:10): [True: 0, False: 0]
  |  Branch (9172:29): [True: 0, False: 0]
  ------------------
 9173|      0|	    if (in >= end) {
  ------------------
  |  Branch (9173:10): [True: 0, False: 0]
  ------------------
 9174|      0|                GROW_PARSE_ATT_VALUE_INTERNAL(ctxt, in, start, end)
  ------------------
  |  | 9101|      0|    const xmlChar *oldbase = ctxt->input->base;\
  |  | 9102|      0|    GROW;\
  |  |  ------------------
  |  |  |  | 2270|      0|#define GROW if (ctxt->input->end - ctxt->input->cur < INPUT_CHUNK)	\
  |  |  |  |  ------------------
  |  |  |  |  |  |   97|      0|#define INPUT_CHUNK	250
  |  |  |  |  ------------------
  |  |  |  |  |  Branch (2270:18): [True: 0, False: 0]
  |  |  |  |  ------------------
  |  |  |  | 2271|      0|	xmlParserGrow(ctxt);
  |  |  ------------------
  |  | 9103|      0|    if (ctxt->instate == XML_PARSER_EOF)\
  |  |  ------------------
  |  |  |  Branch (9103:9): [True: 0, False: 0]
  |  |  ------------------
  |  | 9104|      0|        return(NULL);\
  |  | 9105|      0|    if (oldbase != ctxt->input->base) {\
  |  |  ------------------
  |  |  |  Branch (9105:9): [True: 0, False: 0]
  |  |  ------------------
  |  | 9106|      0|        ptrdiff_t delta = ctxt->input->base - oldbase;\
  |  | 9107|      0|        start = start + delta;\
  |  | 9108|      0|        in = in + delta;\
  |  | 9109|      0|    }\
  |  | 9110|      0|    end = ctxt->input->end;
  ------------------
 9175|      0|                if ((in - start) > maxLength) {
  ------------------
  |  Branch (9175:21): [True: 0, False: 0]
  ------------------
 9176|      0|                    xmlFatalErrMsg(ctxt, XML_ERR_ATTRIBUTE_NOT_FINISHED,
 9177|      0|                                   "AttValue length too long\n");
 9178|      0|                    return(NULL);
 9179|      0|                }
 9180|      0|	    }
 9181|      0|	}
 9182|      0|	last = in;
 9183|       |	/*
 9184|       |	 * skip the trailing blanks
 9185|       |	 */
 9186|      0|	while ((last[-1] == 0x20) && (last > start)) last--;
  ------------------
  |  Branch (9186:9): [True: 0, False: 0]
  |  Branch (9186:31): [True: 0, False: 0]
  ------------------
 9187|      0|	while ((in < end) && (*in != limit) &&
  ------------------
  |  Branch (9187:9): [True: 0, False: 0]
  |  Branch (9187:23): [True: 0, False: 0]
  ------------------
 9188|      0|	       ((*in == 0x20) || (*in == 0x9) ||
  ------------------
  |  Branch (9188:10): [True: 0, False: 0]
  |  Branch (9188:27): [True: 0, False: 0]
  ------------------
 9189|      0|	        (*in == 0xA) || (*in == 0xD))) {
  ------------------
  |  Branch (9189:10): [True: 0, False: 0]
  |  Branch (9189:26): [True: 0, False: 0]
  ------------------
 9190|      0|	    if (*in == 0xA) {
  ------------------
  |  Branch (9190:10): [True: 0, False: 0]
  ------------------
 9191|      0|	        line++, col = 1;
 9192|      0|	    } else {
 9193|      0|	        col++;
 9194|      0|	    }
 9195|      0|	    in++;
 9196|      0|	    if (in >= end) {
  ------------------
  |  Branch (9196:10): [True: 0, False: 0]
  ------------------
 9197|      0|		const xmlChar *oldbase = ctxt->input->base;
 9198|      0|		GROW;
  ------------------
  |  | 2270|      0|#define GROW if (ctxt->input->end - ctxt->input->cur < INPUT_CHUNK)	\
  |  |  ------------------
  |  |  |  |   97|      0|#define INPUT_CHUNK	250
  |  |  ------------------
  |  |  |  Branch (2270:18): [True: 0, False: 0]
  |  |  ------------------
  |  | 2271|      0|	xmlParserGrow(ctxt);
  ------------------
 9199|      0|                if (ctxt->instate == XML_PARSER_EOF)
  ------------------
  |  Branch (9199:21): [True: 0, False: 0]
  ------------------
 9200|      0|                    return(NULL);
 9201|      0|		if (oldbase != ctxt->input->base) {
  ------------------
  |  Branch (9201:7): [True: 0, False: 0]
  ------------------
 9202|      0|		    ptrdiff_t delta = ctxt->input->base - oldbase;
 9203|      0|		    start = start + delta;
 9204|      0|		    in = in + delta;
 9205|      0|		    last = last + delta;
 9206|      0|		}
 9207|      0|		end = ctxt->input->end;
 9208|      0|                if ((in - start) > maxLength) {
  ------------------
  |  Branch (9208:21): [True: 0, False: 0]
  ------------------
 9209|      0|                    xmlFatalErrMsg(ctxt, XML_ERR_ATTRIBUTE_NOT_FINISHED,
 9210|      0|                                   "AttValue length too long\n");
 9211|      0|                    return(NULL);
 9212|      0|                }
 9213|      0|	    }
 9214|      0|	}
 9215|      0|        if ((in - start) > maxLength) {
  ------------------
  |  Branch (9215:13): [True: 0, False: 0]
  ------------------
 9216|      0|            xmlFatalErrMsg(ctxt, XML_ERR_ATTRIBUTE_NOT_FINISHED,
 9217|      0|                           "AttValue length too long\n");
 9218|      0|            return(NULL);
 9219|      0|        }
 9220|      0|	if (*in != limit) goto need_complex;
  ------------------
  |  Branch (9220:6): [True: 0, False: 0]
  ------------------
 9221|  4.62k|    } else {
 9222|  51.2k|	while ((in < end) && (*in != limit) && (*in >= 0x20) &&
  ------------------
  |  Branch (9222:9): [True: 51.2k, False: 0]
  |  Branch (9222:23): [True: 46.6k, False: 4.61k]
  |  Branch (9222:41): [True: 46.6k, False: 2]
  ------------------
 9223|  51.2k|	       (*in <= 0x7f) && (*in != '&') && (*in != '<')) {
  ------------------
  |  Branch (9223:9): [True: 46.6k, False: 2]
  |  Branch (9223:26): [True: 46.6k, False: 2]
  |  Branch (9223:42): [True: 46.6k, False: 0]
  ------------------
 9224|  46.6k|	    in++;
 9225|  46.6k|	    col++;
 9226|  46.6k|	    if (in >= end) {
  ------------------
  |  Branch (9226:10): [True: 0, False: 46.6k]
  ------------------
 9227|      0|                GROW_PARSE_ATT_VALUE_INTERNAL(ctxt, in, start, end)
  ------------------
  |  | 9101|      0|    const xmlChar *oldbase = ctxt->input->base;\
  |  | 9102|      0|    GROW;\
  |  |  ------------------
  |  |  |  | 2270|      0|#define GROW if (ctxt->input->end - ctxt->input->cur < INPUT_CHUNK)	\
  |  |  |  |  ------------------
  |  |  |  |  |  |   97|      0|#define INPUT_CHUNK	250
  |  |  |  |  ------------------
  |  |  |  |  |  Branch (2270:18): [True: 0, False: 0]
  |  |  |  |  ------------------
  |  |  |  | 2271|      0|	xmlParserGrow(ctxt);
  |  |  ------------------
  |  | 9103|      0|    if (ctxt->instate == XML_PARSER_EOF)\
  |  |  ------------------
  |  |  |  Branch (9103:9): [True: 0, False: 0]
  |  |  ------------------
  |  | 9104|      0|        return(NULL);\
  |  | 9105|      0|    if (oldbase != ctxt->input->base) {\
  |  |  ------------------
  |  |  |  Branch (9105:9): [True: 0, False: 0]
  |  |  ------------------
  |  | 9106|      0|        ptrdiff_t delta = ctxt->input->base - oldbase;\
  |  | 9107|      0|        start = start + delta;\
  |  | 9108|      0|        in = in + delta;\
  |  | 9109|      0|    }\
  |  | 9110|      0|    end = ctxt->input->end;
  ------------------
 9228|      0|                if ((in - start) > maxLength) {
  ------------------
  |  Branch (9228:21): [True: 0, False: 0]
  ------------------
 9229|      0|                    xmlFatalErrMsg(ctxt, XML_ERR_ATTRIBUTE_NOT_FINISHED,
 9230|      0|                                   "AttValue length too long\n");
 9231|      0|                    return(NULL);
 9232|      0|                }
 9233|      0|	    }
 9234|  46.6k|	}
 9235|  4.62k|	last = in;
 9236|  4.62k|        if ((in - start) > maxLength) {
  ------------------
  |  Branch (9236:13): [True: 0, False: 4.62k]
  ------------------
 9237|      0|            xmlFatalErrMsg(ctxt, XML_ERR_ATTRIBUTE_NOT_FINISHED,
 9238|      0|                           "AttValue length too long\n");
 9239|      0|            return(NULL);
 9240|      0|        }
 9241|  4.62k|	if (*in != limit) goto need_complex;
  ------------------
  |  Branch (9241:6): [True: 6, False: 4.61k]
  ------------------
 9242|  4.62k|    }
 9243|  4.61k|    in++;
 9244|  4.61k|    col++;
 9245|  4.61k|    if (len != NULL) {
  ------------------
  |  Branch (9245:9): [True: 4.61k, False: 0]
  ------------------
 9246|  4.61k|        if (alloc) *alloc = 0;
  ------------------
  |  Branch (9246:13): [True: 4.61k, False: 0]
  ------------------
 9247|  4.61k|        *len = last - start;
 9248|  4.61k|        ret = (xmlChar *) start;
 9249|  4.61k|    } else {
 9250|      0|        if (alloc) *alloc = 1;
  ------------------
  |  Branch (9250:13): [True: 0, False: 0]
  ------------------
 9251|      0|        ret = xmlStrndup(start, last - start);
 9252|      0|    }
 9253|  4.61k|    CUR_PTR = in;
  ------------------
  |  | 2224|  4.61k|#define CUR_PTR ctxt->input->cur
  ------------------
 9254|  4.61k|    ctxt->input->line = line;
 9255|  4.61k|    ctxt->input->col = col;
 9256|  4.61k|    return ret;
 9257|      6|need_complex:
 9258|      6|    if (alloc) *alloc = 1;
  ------------------
  |  Branch (9258:9): [True: 6, False: 0]
  ------------------
 9259|      6|    return xmlParseAttValueComplex(ctxt, len, normalize);
 9260|  4.62k|}
parser.c:xmlParseAttValueComplex:
 4056|      6|xmlParseAttValueComplex(xmlParserCtxtPtr ctxt, int *attlen, int normalize) {
 4057|      6|    xmlChar limit = 0;
 4058|      6|    xmlChar *buf = NULL;
 4059|      6|    xmlChar *rep = NULL;
 4060|      6|    size_t len = 0;
 4061|      6|    size_t buf_size = 0;
 4062|      6|    size_t maxLength = (ctxt->options & XML_PARSE_HUGE) ?
  ------------------
  |  Branch (4062:24): [True: 0, False: 6]
  ------------------
 4063|      0|                       XML_MAX_HUGE_LENGTH :
  ------------------
  |  |   49|      0|#define XML_MAX_HUGE_LENGTH 1000000000
  ------------------
 4064|      6|                       XML_MAX_TEXT_LENGTH;
  ------------------
  |  |   42|     12|#define XML_MAX_TEXT_LENGTH 10000000
  ------------------
 4065|      6|    int c, l, in_space = 0;
 4066|      6|    xmlChar *current = NULL;
 4067|      6|    xmlEntityPtr ent;
 4068|       |
 4069|      6|    if (NXT(0) == '"') {
  ------------------
  |  | 2223|      6|#define NXT(val) ctxt->input->cur[(val)]
  ------------------
  |  Branch (4069:9): [True: 6, False: 0]
  ------------------
 4070|      6|	ctxt->instate = XML_PARSER_ATTRIBUTE_VALUE;
 4071|      6|	limit = '"';
 4072|      6|        NEXT;
  ------------------
  |  | 2275|      6|#define NEXT xmlNextChar(ctxt)
  ------------------
 4073|      6|    } else if (NXT(0) == '\'') {
  ------------------
  |  | 2223|      0|#define NXT(val) ctxt->input->cur[(val)]
  ------------------
  |  Branch (4073:16): [True: 0, False: 0]
  ------------------
 4074|      0|	limit = '\'';
 4075|      0|	ctxt->instate = XML_PARSER_ATTRIBUTE_VALUE;
 4076|      0|        NEXT;
  ------------------
  |  | 2275|      0|#define NEXT xmlNextChar(ctxt)
  ------------------
 4077|      0|    } else {
 4078|      0|	xmlFatalErr(ctxt, XML_ERR_ATTRIBUTE_NOT_STARTED, NULL);
 4079|      0|	return(NULL);
 4080|      0|    }
 4081|       |
 4082|       |    /*
 4083|       |     * allocate a translation buffer.
 4084|       |     */
 4085|      6|    buf_size = XML_PARSER_BUFFER_SIZE;
  ------------------
  |  |  167|      6|#define XML_PARSER_BUFFER_SIZE 100
  ------------------
 4086|      6|    buf = (xmlChar *) xmlMallocAtomic(buf_size);
 4087|      6|    if (buf == NULL) goto mem_error;
  ------------------
  |  Branch (4087:9): [True: 0, False: 6]
  ------------------
 4088|       |
 4089|       |    /*
 4090|       |     * OK loop until we reach one of the ending char or a size limit.
 4091|       |     */
 4092|      6|    c = CUR_CHAR(l);
  ------------------
  |  | 2291|      6|#define CUR_CHAR(l) xmlCurrentChar(ctxt, &l)
  ------------------
 4093|     58|    while (((NXT(0) != limit) && /* checked */
  ------------------
  |  | 2223|     58|#define NXT(val) ctxt->input->cur[(val)]
  ------------------
  |  Branch (4093:13): [True: 55, False: 3]
  ------------------
 4094|     58|            (IS_CHAR(c)) && (c != '<')) &&
  ------------------
  |  |  125|     55|#define IS_CHAR(c)   xmlIsCharQ(c)
  |  |  ------------------
  |  |  |  |  118|     55|#define xmlIsCharQ(c)		(((c) < 0x100) ? \
  |  |  |  |  ------------------
  |  |  |  |  |  Branch (118:25): [True: 41, False: 14]
  |  |  |  |  ------------------
  |  |  |  |  119|     55|				 xmlIsChar_ch((c)) :\
  |  |  |  |  ------------------
  |  |  |  |  |  |  108|     41|#define xmlIsChar_ch(c)		(((0x9 <= (c)) && ((c) <= 0xa)) || \
  |  |  |  |  |  |  ------------------
  |  |  |  |  |  |  |  Branch (108:28): [True: 40, False: 1]
  |  |  |  |  |  |  |  Branch (108:44): [True: 1, False: 39]
  |  |  |  |  |  |  ------------------
  |  |  |  |  |  |  109|     41|				 ((c) == 0xd) || \
  |  |  |  |  |  |  ------------------
  |  |  |  |  |  |  |  Branch (109:6): [True: 0, False: 40]
  |  |  |  |  |  |  ------------------
  |  |  |  |  |  |  110|     41|				  (0x20 <= (c)))
  |  |  |  |  |  |  ------------------
  |  |  |  |  |  |  |  Branch (110:7): [True: 38, False: 2]
  |  |  |  |  |  |  ------------------
  |  |  |  |  ------------------
  |  |  |  |  120|     55|				(((0x100 <= (c)) && ((c) <= 0xd7ff)) || \
  |  |  |  |  ------------------
  |  |  |  |  |  Branch (120:7): [True: 14, False: 0]
  |  |  |  |  |  Branch (120:25): [True: 1, False: 13]
  |  |  |  |  ------------------
  |  |  |  |  121|     14|				 ((0xe000 <= (c)) && ((c) <= 0xfffd)) || \
  |  |  |  |  ------------------
  |  |  |  |  |  Branch (121:7): [True: 13, False: 0]
  |  |  |  |  |  Branch (121:26): [True: 13, False: 0]
  |  |  |  |  ------------------
  |  |  |  |  122|     14|				 ((0x10000 <= (c)) && ((c) <= 0x10ffff))))
  |  |  |  |  ------------------
  |  |  |  |  |  Branch (122:7): [True: 0, False: 0]
  |  |  |  |  |  Branch (122:27): [True: 0, False: 0]
  |  |  |  |  ------------------
  |  |  ------------------
  ------------------
  |  Branch (4094:13): [True: 53, False: 2]
  |  Branch (4094:29): [True: 52, False: 1]
  ------------------
 4095|     58|            (ctxt->instate != XML_PARSER_EOF)) {
  ------------------
  |  Branch (4095:13): [True: 52, False: 0]
  ------------------
 4096|     52|	if (c == '&') {
  ------------------
  |  Branch (4096:6): [True: 2, False: 50]
  ------------------
 4097|      2|	    in_space = 0;
 4098|      2|	    if (NXT(1) == '#') {
  ------------------
  |  | 2223|      2|#define NXT(val) ctxt->input->cur[(val)]
  ------------------
  |  Branch (4098:10): [True: 0, False: 2]
  ------------------
 4099|      0|		int val = xmlParseCharRef(ctxt);
 4100|       |
 4101|      0|		if (val == '&') {
  ------------------
  |  Branch (4101:7): [True: 0, False: 0]
  ------------------
 4102|      0|		    if (ctxt->replaceEntities) {
  ------------------
  |  Branch (4102:11): [True: 0, False: 0]
  ------------------
 4103|      0|			if (len + 10 > buf_size) {
  ------------------
  |  Branch (4103:8): [True: 0, False: 0]
  ------------------
 4104|      0|			    growBuffer(buf, 10);
  ------------------
  |  | 2774|      0|#define growBuffer(buffer, n) {						\
  |  | 2775|      0|    xmlChar *tmp;							\
  |  | 2776|      0|    size_t new_size = buffer##_size * 2 + n;                            \
  |  | 2777|      0|    if (new_size < buffer##_size) goto mem_error;                       \
  |  |  ------------------
  |  |  |  Branch (2777:9): [True: 0, False: 0]
  |  |  ------------------
  |  | 2778|      0|    tmp = (xmlChar *) xmlRealloc(buffer, new_size);                     \
  |  | 2779|      0|    if (tmp == NULL) goto mem_error;					\
  |  |  ------------------
  |  |  |  Branch (2779:9): [True: 0, False: 0]
  |  |  ------------------
  |  | 2780|      0|    buffer = tmp;							\
  |  | 2781|      0|    buffer##_size = new_size;                                           \
  |  | 2782|      0|}
  ------------------
 4105|      0|			}
 4106|      0|			buf[len++] = '&';
 4107|      0|		    } else {
 4108|       |			/*
 4109|       |			 * The reparsing will be done in xmlStringGetNodeList()
 4110|       |			 * called by the attribute() function in SAX.c
 4111|       |			 */
 4112|      0|			if (len + 10 > buf_size) {
  ------------------
  |  Branch (4112:8): [True: 0, False: 0]
  ------------------
 4113|      0|			    growBuffer(buf, 10);
  ------------------
  |  | 2774|      0|#define growBuffer(buffer, n) {						\
  |  | 2775|      0|    xmlChar *tmp;							\
  |  | 2776|      0|    size_t new_size = buffer##_size * 2 + n;                            \
  |  | 2777|      0|    if (new_size < buffer##_size) goto mem_error;                       \
  |  |  ------------------
  |  |  |  Branch (2777:9): [True: 0, False: 0]
  |  |  ------------------
  |  | 2778|      0|    tmp = (xmlChar *) xmlRealloc(buffer, new_size);                     \
  |  | 2779|      0|    if (tmp == NULL) goto mem_error;					\
  |  |  ------------------
  |  |  |  Branch (2779:9): [True: 0, False: 0]
  |  |  ------------------
  |  | 2780|      0|    buffer = tmp;							\
  |  | 2781|      0|    buffer##_size = new_size;                                           \
  |  | 2782|      0|}
  ------------------
 4114|      0|			}
 4115|      0|			buf[len++] = '&';
 4116|      0|			buf[len++] = '#';
 4117|      0|			buf[len++] = '3';
 4118|      0|			buf[len++] = '8';
 4119|      0|			buf[len++] = ';';
 4120|      0|		    }
 4121|      0|		} else if (val != 0) {
  ------------------
  |  Branch (4121:14): [True: 0, False: 0]
  ------------------
 4122|      0|		    if (len + 10 > buf_size) {
  ------------------
  |  Branch (4122:11): [True: 0, False: 0]
  ------------------
 4123|      0|			growBuffer(buf, 10);
  ------------------
  |  | 2774|      0|#define growBuffer(buffer, n) {						\
  |  | 2775|      0|    xmlChar *tmp;							\
  |  | 2776|      0|    size_t new_size = buffer##_size * 2 + n;                            \
  |  | 2777|      0|    if (new_size < buffer##_size) goto mem_error;                       \
  |  |  ------------------
  |  |  |  Branch (2777:9): [True: 0, False: 0]
  |  |  ------------------
  |  | 2778|      0|    tmp = (xmlChar *) xmlRealloc(buffer, new_size);                     \
  |  | 2779|      0|    if (tmp == NULL) goto mem_error;					\
  |  |  ------------------
  |  |  |  Branch (2779:9): [True: 0, False: 0]
  |  |  ------------------
  |  | 2780|      0|    buffer = tmp;							\
  |  | 2781|      0|    buffer##_size = new_size;                                           \
  |  | 2782|      0|}
  ------------------
 4124|      0|		    }
 4125|      0|		    len += xmlCopyChar(0, &buf[len], val);
 4126|      0|		}
 4127|      2|	    } else {
 4128|      2|		ent = xmlParseEntityRef(ctxt);
 4129|      2|		if ((ent != NULL) &&
  ------------------
  |  Branch (4129:7): [True: 2, False: 0]
  ------------------
 4130|      2|		    (ent->etype == XML_INTERNAL_PREDEFINED_ENTITY)) {
  ------------------
  |  Branch (4130:7): [True: 2, False: 0]
  ------------------
 4131|      2|		    if (len + 10 > buf_size) {
  ------------------
  |  Branch (4131:11): [True: 0, False: 2]
  ------------------
 4132|      0|			growBuffer(buf, 10);
  ------------------
  |  | 2774|      0|#define growBuffer(buffer, n) {						\
  |  | 2775|      0|    xmlChar *tmp;							\
  |  | 2776|      0|    size_t new_size = buffer##_size * 2 + n;                            \
  |  | 2777|      0|    if (new_size < buffer##_size) goto mem_error;                       \
  |  |  ------------------
  |  |  |  Branch (2777:9): [True: 0, False: 0]
  |  |  ------------------
  |  | 2778|      0|    tmp = (xmlChar *) xmlRealloc(buffer, new_size);                     \
  |  | 2779|      0|    if (tmp == NULL) goto mem_error;					\
  |  |  ------------------
  |  |  |  Branch (2779:9): [True: 0, False: 0]
  |  |  ------------------
  |  | 2780|      0|    buffer = tmp;							\
  |  | 2781|      0|    buffer##_size = new_size;                                           \
  |  | 2782|      0|}
  ------------------
 4133|      0|		    }
 4134|      2|		    if ((ctxt->replaceEntities == 0) &&
  ------------------
  |  Branch (4134:11): [True: 0, False: 2]
  ------------------
 4135|      2|		        (ent->content[0] == '&')) {
  ------------------
  |  Branch (4135:11): [True: 0, False: 0]
  ------------------
 4136|      0|			buf[len++] = '&';
 4137|      0|			buf[len++] = '#';
 4138|      0|			buf[len++] = '3';
 4139|      0|			buf[len++] = '8';
 4140|      0|			buf[len++] = ';';
 4141|      2|		    } else {
 4142|      2|			buf[len++] = ent->content[0];
 4143|      2|		    }
 4144|      2|		} else if ((ent != NULL) &&
  ------------------
  |  Branch (4144:14): [True: 0, False: 0]
  ------------------
 4145|      0|		           (ctxt->replaceEntities != 0)) {
  ------------------
  |  Branch (4145:14): [True: 0, False: 0]
  ------------------
 4146|      0|		    if (ent->etype != XML_INTERNAL_PREDEFINED_ENTITY) {
  ------------------
  |  Branch (4146:11): [True: 0, False: 0]
  ------------------
 4147|      0|                        if (xmlParserEntityCheck(ctxt, ent->length))
  ------------------
  |  Branch (4147:29): [True: 0, False: 0]
  ------------------
 4148|      0|                            goto error;
 4149|       |
 4150|      0|			++ctxt->depth;
 4151|      0|			rep = xmlStringDecodeEntitiesInt(ctxt, ent->content,
 4152|      0|                                ent->length, XML_SUBSTITUTE_REF, 0, 0, 0,
  ------------------
  |  |  521|      0|#define XML_SUBSTITUTE_REF	1
  ------------------
 4153|      0|                                /* check */ 1);
 4154|      0|			--ctxt->depth;
 4155|      0|			if (rep != NULL) {
  ------------------
  |  Branch (4155:8): [True: 0, False: 0]
  ------------------
 4156|      0|			    current = rep;
 4157|      0|			    while (*current != 0) { /* non input consuming */
  ------------------
  |  Branch (4157:15): [True: 0, False: 0]
  ------------------
 4158|      0|                                if ((*current == 0xD) || (*current == 0xA) ||
  ------------------
  |  Branch (4158:37): [True: 0, False: 0]
  |  Branch (4158:58): [True: 0, False: 0]
  ------------------
 4159|      0|                                    (*current == 0x9)) {
  ------------------
  |  Branch (4159:37): [True: 0, False: 0]
  ------------------
 4160|      0|                                    buf[len++] = 0x20;
 4161|      0|                                    current++;
 4162|      0|                                } else
 4163|      0|                                    buf[len++] = *current++;
 4164|      0|				if (len + 10 > buf_size) {
  ------------------
  |  Branch (4164:9): [True: 0, False: 0]
  ------------------
 4165|      0|				    growBuffer(buf, 10);
  ------------------
  |  | 2774|      0|#define growBuffer(buffer, n) {						\
  |  | 2775|      0|    xmlChar *tmp;							\
  |  | 2776|      0|    size_t new_size = buffer##_size * 2 + n;                            \
  |  | 2777|      0|    if (new_size < buffer##_size) goto mem_error;                       \
  |  |  ------------------
  |  |  |  Branch (2777:9): [True: 0, False: 0]
  |  |  ------------------
  |  | 2778|      0|    tmp = (xmlChar *) xmlRealloc(buffer, new_size);                     \
  |  | 2779|      0|    if (tmp == NULL) goto mem_error;					\
  |  |  ------------------
  |  |  |  Branch (2779:9): [True: 0, False: 0]
  |  |  ------------------
  |  | 2780|      0|    buffer = tmp;							\
  |  | 2781|      0|    buffer##_size = new_size;                                           \
  |  | 2782|      0|}
  ------------------
 4166|      0|				}
 4167|      0|			    }
 4168|      0|			    xmlFree(rep);
 4169|      0|			    rep = NULL;
 4170|      0|			}
 4171|      0|		    } else {
 4172|      0|			if (len + 10 > buf_size) {
  ------------------
  |  Branch (4172:8): [True: 0, False: 0]
  ------------------
 4173|      0|			    growBuffer(buf, 10);
  ------------------
  |  | 2774|      0|#define growBuffer(buffer, n) {						\
  |  | 2775|      0|    xmlChar *tmp;							\
  |  | 2776|      0|    size_t new_size = buffer##_size * 2 + n;                            \
  |  | 2777|      0|    if (new_size < buffer##_size) goto mem_error;                       \
  |  |  ------------------
  |  |  |  Branch (2777:9): [True: 0, False: 0]
  |  |  ------------------
  |  | 2778|      0|    tmp = (xmlChar *) xmlRealloc(buffer, new_size);                     \
  |  | 2779|      0|    if (tmp == NULL) goto mem_error;					\
  |  |  ------------------
  |  |  |  Branch (2779:9): [True: 0, False: 0]
  |  |  ------------------
  |  | 2780|      0|    buffer = tmp;							\
  |  | 2781|      0|    buffer##_size = new_size;                                           \
  |  | 2782|      0|}
  ------------------
 4174|      0|			}
 4175|      0|			if (ent->content != NULL)
  ------------------
  |  Branch (4175:8): [True: 0, False: 0]
  ------------------
 4176|      0|			    buf[len++] = ent->content[0];
 4177|      0|		    }
 4178|      0|		} else if (ent != NULL) {
  ------------------
  |  Branch (4178:14): [True: 0, False: 0]
  ------------------
 4179|      0|		    int i = xmlStrlen(ent->name);
 4180|      0|		    const xmlChar *cur = ent->name;
 4181|       |
 4182|       |		    /*
 4183|       |                     * We also check for recursion and amplification
 4184|       |                     * when entities are not substituted. They're
 4185|       |                     * often expanded later.
 4186|       |		     */
 4187|      0|		    if ((ent->etype != XML_INTERNAL_PREDEFINED_ENTITY) &&
  ------------------
  |  Branch (4187:11): [True: 0, False: 0]
  ------------------
 4188|      0|			(ent->content != NULL)) {
  ------------------
  |  Branch (4188:4): [True: 0, False: 0]
  ------------------
 4189|      0|                        if ((ent->flags & XML_ENT_CHECKED) == 0) {
  ------------------
  |  |   15|      0|#define XML_ENT_CHECKED     (1<<1)
  ------------------
  |  Branch (4189:29): [True: 0, False: 0]
  ------------------
 4190|      0|                            unsigned long oldCopy = ctxt->sizeentcopy;
 4191|       |
 4192|      0|                            ctxt->sizeentcopy = ent->length;
 4193|       |
 4194|      0|                            ++ctxt->depth;
 4195|      0|                            rep = xmlStringDecodeEntitiesInt(ctxt,
 4196|      0|                                    ent->content, ent->length,
 4197|      0|                                    XML_SUBSTITUTE_REF, 0, 0, 0,
  ------------------
  |  |  521|      0|#define XML_SUBSTITUTE_REF	1
  ------------------
 4198|      0|                                    /* check */ 1);
 4199|      0|                            --ctxt->depth;
 4200|       |
 4201|       |                            /*
 4202|       |                             * If we're parsing DTD content, the entity
 4203|       |                             * might reference other entities which
 4204|       |                             * weren't defined yet, so the check isn't
 4205|       |                             * reliable.
 4206|       |                             */
 4207|      0|                            if (ctxt->inSubset == 0) {
  ------------------
  |  Branch (4207:33): [True: 0, False: 0]
  ------------------
 4208|      0|                                ent->flags |= XML_ENT_CHECKED;
  ------------------
  |  |   15|      0|#define XML_ENT_CHECKED     (1<<1)
  ------------------
 4209|      0|                                ent->expandedSize = ctxt->sizeentcopy;
 4210|      0|                            }
 4211|       |
 4212|      0|                            if (rep != NULL) {
  ------------------
  |  Branch (4212:33): [True: 0, False: 0]
  ------------------
 4213|      0|                                xmlFree(rep);
 4214|      0|                                rep = NULL;
 4215|      0|                            } else {
 4216|      0|                                ent->content[0] = 0;
 4217|      0|                            }
 4218|       |
 4219|      0|                            if (xmlParserEntityCheck(ctxt, oldCopy))
  ------------------
  |  Branch (4219:33): [True: 0, False: 0]
  ------------------
 4220|      0|                                goto error;
 4221|      0|                        } else {
 4222|      0|                            if (xmlParserEntityCheck(ctxt, ent->expandedSize))
  ------------------
  |  Branch (4222:33): [True: 0, False: 0]
  ------------------
 4223|      0|                                goto error;
 4224|      0|                        }
 4225|      0|		    }
 4226|       |
 4227|       |		    /*
 4228|       |		     * Just output the reference
 4229|       |		     */
 4230|      0|		    buf[len++] = '&';
 4231|      0|		    while (len + i + 10 > buf_size) {
  ------------------
  |  Branch (4231:14): [True: 0, False: 0]
  ------------------
 4232|      0|			growBuffer(buf, i + 10);
  ------------------
  |  | 2774|      0|#define growBuffer(buffer, n) {						\
  |  | 2775|      0|    xmlChar *tmp;							\
  |  | 2776|      0|    size_t new_size = buffer##_size * 2 + n;                            \
  |  | 2777|      0|    if (new_size < buffer##_size) goto mem_error;                       \
  |  |  ------------------
  |  |  |  Branch (2777:9): [True: 0, False: 0]
  |  |  ------------------
  |  | 2778|      0|    tmp = (xmlChar *) xmlRealloc(buffer, new_size);                     \
  |  | 2779|      0|    if (tmp == NULL) goto mem_error;					\
  |  |  ------------------
  |  |  |  Branch (2779:9): [True: 0, False: 0]
  |  |  ------------------
  |  | 2780|      0|    buffer = tmp;							\
  |  | 2781|      0|    buffer##_size = new_size;                                           \
  |  | 2782|      0|}
  ------------------
 4233|      0|		    }
 4234|      0|		    for (;i > 0;i--)
  ------------------
  |  Branch (4234:13): [True: 0, False: 0]
  ------------------
 4235|      0|			buf[len++] = *cur++;
 4236|      0|		    buf[len++] = ';';
 4237|      0|		}
 4238|      2|	    }
 4239|     50|	} else {
 4240|     50|	    if ((c == 0x20) || (c == 0xD) || (c == 0xA) || (c == 0x9)) {
  ------------------
  |  Branch (4240:10): [True: 0, False: 50]
  |  Branch (4240:25): [True: 0, False: 50]
  |  Branch (4240:39): [True: 1, False: 49]
  |  Branch (4240:53): [True: 0, False: 49]
  ------------------
 4241|      1|	        if ((len != 0) || (!normalize)) {
  ------------------
  |  Branch (4241:14): [True: 1, False: 0]
  |  Branch (4241:28): [True: 0, False: 0]
  ------------------
 4242|      1|		    if ((!normalize) || (!in_space)) {
  ------------------
  |  Branch (4242:11): [True: 1, False: 0]
  |  Branch (4242:27): [True: 0, False: 0]
  ------------------
 4243|      1|			COPY_BUF(buf, len, 0x20);
  ------------------
  |  | 2295|      1|    if (v < 0x80) b[i++] = v;						\
  |  |  ------------------
  |  |  |  Branch (2295:9): [Folded - Ignored]
  |  |  ------------------
  |  | 2296|      1|    else i += xmlCopyCharMultiByte(&b[i],v)
  ------------------
 4244|      1|			while (len + 10 > buf_size) {
  ------------------
  |  Branch (4244:11): [True: 0, False: 1]
  ------------------
 4245|      0|			    growBuffer(buf, 10);
  ------------------
  |  | 2774|      0|#define growBuffer(buffer, n) {						\
  |  | 2775|      0|    xmlChar *tmp;							\
  |  | 2776|      0|    size_t new_size = buffer##_size * 2 + n;                            \
  |  | 2777|      0|    if (new_size < buffer##_size) goto mem_error;                       \
  |  |  ------------------
  |  |  |  Branch (2777:9): [True: 0, False: 0]
  |  |  ------------------
  |  | 2778|      0|    tmp = (xmlChar *) xmlRealloc(buffer, new_size);                     \
  |  | 2779|      0|    if (tmp == NULL) goto mem_error;					\
  |  |  ------------------
  |  |  |  Branch (2779:9): [True: 0, False: 0]
  |  |  ------------------
  |  | 2780|      0|    buffer = tmp;							\
  |  | 2781|      0|    buffer##_size = new_size;                                           \
  |  | 2782|      0|}
  ------------------
 4246|      0|			}
 4247|      1|		    }
 4248|      1|		    in_space = 1;
 4249|      1|		}
 4250|     49|	    } else {
 4251|     49|	        in_space = 0;
 4252|     49|		COPY_BUF(buf, len, c);
  ------------------
  |  | 2295|     49|    if (v < 0x80) b[i++] = v;						\
  |  |  ------------------
  |  |  |  Branch (2295:9): [True: 35, False: 14]
  |  |  ------------------
  |  | 2296|     49|    else i += xmlCopyCharMultiByte(&b[i],v)
  ------------------
 4253|     49|		if (len + 10 > buf_size) {
  ------------------
  |  Branch (4253:7): [True: 0, False: 49]
  ------------------
 4254|      0|		    growBuffer(buf, 10);
  ------------------
  |  | 2774|      0|#define growBuffer(buffer, n) {						\
  |  | 2775|      0|    xmlChar *tmp;							\
  |  | 2776|      0|    size_t new_size = buffer##_size * 2 + n;                            \
  |  | 2777|      0|    if (new_size < buffer##_size) goto mem_error;                       \
  |  |  ------------------
  |  |  |  Branch (2777:9): [True: 0, False: 0]
  |  |  ------------------
  |  | 2778|      0|    tmp = (xmlChar *) xmlRealloc(buffer, new_size);                     \
  |  | 2779|      0|    if (tmp == NULL) goto mem_error;					\
  |  |  ------------------
  |  |  |  Branch (2779:9): [True: 0, False: 0]
  |  |  ------------------
  |  | 2780|      0|    buffer = tmp;							\
  |  | 2781|      0|    buffer##_size = new_size;                                           \
  |  | 2782|      0|}
  ------------------
 4255|      0|		}
 4256|     49|	    }
 4257|     50|	    NEXTL(l);
  ------------------
  |  | 2284|     50|#define NEXTL(l) do {							\
  |  | 2285|     50|    if (*(ctxt->input->cur) == '\n') {					\
  |  |  ------------------
  |  |  |  Branch (2285:9): [True: 1, False: 49]
  |  |  ------------------
  |  | 2286|      1|	ctxt->input->line++; ctxt->input->col = 1;			\
  |  | 2287|     49|    } else ctxt->input->col++;						\
  |  | 2288|     50|    ctxt->input->cur += l;				\
  |  | 2289|     50|  } while (0)
  |  |  ------------------
  |  |  |  Branch (2289:12): [Folded - Ignored]
  |  |  ------------------
  ------------------
 4258|     50|	}
 4259|     52|	GROW;
  ------------------
  |  | 2270|     52|#define GROW if (ctxt->input->end - ctxt->input->cur < INPUT_CHUNK)	\
  |  |  ------------------
  |  |  |  |   97|     52|#define INPUT_CHUNK	250
  |  |  ------------------
  |  |  |  Branch (2270:18): [True: 52, False: 0]
  |  |  ------------------
  |  | 2271|     52|	xmlParserGrow(ctxt);
  ------------------
 4260|     52|	c = CUR_CHAR(l);
  ------------------
  |  | 2291|     52|#define CUR_CHAR(l) xmlCurrentChar(ctxt, &l)
  ------------------
 4261|     52|        if (len > maxLength) {
  ------------------
  |  Branch (4261:13): [True: 0, False: 52]
  ------------------
 4262|      0|            xmlFatalErrMsg(ctxt, XML_ERR_ATTRIBUTE_NOT_FINISHED,
 4263|      0|                           "AttValue length too long\n");
 4264|      0|            goto mem_error;
 4265|      0|        }
 4266|     52|    }
 4267|      6|    if (ctxt->instate == XML_PARSER_EOF)
  ------------------
  |  Branch (4267:9): [True: 0, False: 6]
  ------------------
 4268|      0|        goto error;
 4269|       |
 4270|      6|    if ((in_space) && (normalize)) {
  ------------------
  |  Branch (4270:9): [True: 1, False: 5]
  |  Branch (4270:23): [True: 0, False: 1]
  ------------------
 4271|      0|        while ((len > 0) && (buf[len - 1] == 0x20)) len--;
  ------------------
  |  Branch (4271:16): [True: 0, False: 0]
  |  Branch (4271:29): [True: 0, False: 0]
  ------------------
 4272|      0|    }
 4273|      6|    buf[len] = 0;
 4274|      6|    if (RAW == '<') {
  ------------------
  |  | 2221|      6|#define RAW (*ctxt->input->cur)
  ------------------
  |  Branch (4274:9): [True: 1, False: 5]
  ------------------
 4275|      1|	xmlFatalErr(ctxt, XML_ERR_LT_IN_ATTRIBUTE, NULL);
 4276|      5|    } else if (RAW != limit) {
  ------------------
  |  | 2221|      5|#define RAW (*ctxt->input->cur)
  ------------------
  |  Branch (4276:16): [True: 2, False: 3]
  ------------------
 4277|      2|	if ((c != 0) && (!IS_CHAR(c))) {
  ------------------
  |  |  125|      1|#define IS_CHAR(c)   xmlIsCharQ(c)
  |  |  ------------------
  |  |  |  |  118|      1|#define xmlIsCharQ(c)		(((c) < 0x100) ? \
  |  |  |  |  ------------------
  |  |  |  |  |  Branch (118:25): [True: 1, False: 0]
  |  |  |  |  ------------------
  |  |  |  |  119|      1|				 xmlIsChar_ch((c)) :\
  |  |  |  |  ------------------
  |  |  |  |  |  |  108|      1|#define xmlIsChar_ch(c)		(((0x9 <= (c)) && ((c) <= 0xa)) || \
  |  |  |  |  |  |  ------------------
  |  |  |  |  |  |  |  Branch (108:28): [True: 1, False: 0]
  |  |  |  |  |  |  |  Branch (108:44): [True: 0, False: 1]
  |  |  |  |  |  |  ------------------
  |  |  |  |  |  |  109|      1|				 ((c) == 0xd) || \
  |  |  |  |  |  |  ------------------
  |  |  |  |  |  |  |  Branch (109:6): [True: 0, False: 1]
  |  |  |  |  |  |  ------------------
  |  |  |  |  |  |  110|      1|				  (0x20 <= (c)))
  |  |  |  |  |  |  ------------------
  |  |  |  |  |  |  |  Branch (110:7): [True: 0, False: 1]
  |  |  |  |  |  |  ------------------
  |  |  |  |  ------------------
  |  |  |  |  120|      1|				(((0x100 <= (c)) && ((c) <= 0xd7ff)) || \
  |  |  |  |  ------------------
  |  |  |  |  |  Branch (120:7): [True: 0, False: 0]
  |  |  |  |  |  Branch (120:25): [True: 0, False: 0]
  |  |  |  |  ------------------
  |  |  |  |  121|      0|				 ((0xe000 <= (c)) && ((c) <= 0xfffd)) || \
  |  |  |  |  ------------------
  |  |  |  |  |  Branch (121:7): [True: 0, False: 0]
  |  |  |  |  |  Branch (121:26): [True: 0, False: 0]
  |  |  |  |  ------------------
  |  |  |  |  122|      0|				 ((0x10000 <= (c)) && ((c) <= 0x10ffff))))
  |  |  |  |  ------------------
  |  |  |  |  |  Branch (122:7): [True: 0, False: 0]
  |  |  |  |  |  Branch (122:27): [True: 0, False: 0]
  |  |  |  |  ------------------
  |  |  ------------------
  ------------------
  |  Branch (4277:6): [True: 1, False: 1]
  |  Branch (4277:18): [True: 1, False: 0]
  ------------------
 4278|      1|	    xmlFatalErrMsg(ctxt, XML_ERR_INVALID_CHAR,
 4279|      1|			   "invalid character in attribute value\n");
 4280|      1|	} else {
 4281|      1|	    xmlFatalErrMsg(ctxt, XML_ERR_ATTRIBUTE_NOT_FINISHED,
 4282|      1|			   "AttValue: ' expected\n");
 4283|      1|        }
 4284|      2|    } else
 4285|      3|	NEXT;
  ------------------
  |  | 2275|      3|#define NEXT xmlNextChar(ctxt)
  ------------------
 4286|       |
 4287|      6|    if (attlen != NULL) *attlen = len;
  ------------------
  |  Branch (4287:9): [True: 6, False: 0]
  ------------------
 4288|      6|    return(buf);
 4289|       |
 4290|      0|mem_error:
 4291|      0|    xmlErrMemory(ctxt, NULL);
 4292|      0|error:
 4293|      0|    if (buf != NULL)
  ------------------
  |  Branch (4293:9): [True: 0, False: 0]
  ------------------
 4294|      0|        xmlFree(buf);
 4295|      0|    if (rep != NULL)
  ------------------
  |  Branch (4295:9): [True: 0, False: 0]
  ------------------
 4296|      0|        xmlFree(rep);
 4297|      0|    return(NULL);
 4298|      0|}
parser.c:xmlParseContentInternal:
10210|    232|xmlParseContentInternal(xmlParserCtxtPtr ctxt) {
10211|    232|    int nameNr = ctxt->nameNr;
10212|       |
10213|    232|    GROW;
  ------------------
  |  | 2270|    232|#define GROW if (ctxt->input->end - ctxt->input->cur < INPUT_CHUNK)	\
  |  |  ------------------
  |  |  |  |   97|    232|#define INPUT_CHUNK	250
  |  |  ------------------
  |  |  |  Branch (2270:18): [True: 77, False: 155]
  |  |  ------------------
  |  | 2271|    232|	xmlParserGrow(ctxt);
  ------------------
10214|  11.5k|    while ((ctxt->input->cur < ctxt->input->end) &&
  ------------------
  |  Branch (10214:12): [True: 11.5k, False: 5]
  ------------------
10215|  11.5k|	   (ctxt->instate != XML_PARSER_EOF)) {
  ------------------
  |  Branch (10215:5): [True: 11.5k, False: 0]
  ------------------
10216|  11.5k|	const xmlChar *cur = ctxt->input->cur;
10217|       |
10218|       |	/*
10219|       |	 * First case : a Processing Instruction.
10220|       |	 */
10221|  11.5k|	if ((*cur == '<') && (cur[1] == '?')) {
  ------------------
  |  Branch (10221:6): [True: 5.77k, False: 5.79k]
  |  Branch (10221:23): [True: 0, False: 5.77k]
  ------------------
10222|      0|	    xmlParsePI(ctxt);
10223|      0|	}
10224|       |
10225|       |	/*
10226|       |	 * Second case : a CDSection
10227|       |	 */
10228|       |	/* 2.6.0 test was *cur not RAW */
10229|  11.5k|	else if (CMP9(CUR_PTR, '<', '!', '[', 'C', 'D', 'A', 'T', 'A', '[')) {
  ------------------
  |  | 2239|  11.5k|  ( CMP8( s, c1, c2, c3, c4, c5, c6, c7, c8 ) && \
  |  |  ------------------
  |  |  |  | 2237|  23.1k|  ( CMP7( s, c1, c2, c3, c4, c5, c6, c7 ) && ((unsigned char *) s)[ 7 ] == c8 )
  |  |  |  |  ------------------
  |  |  |  |  |  | 2235|  23.1k|  ( CMP6( s, c1, c2, c3, c4, c5, c6 ) && ((unsigned char *) s)[ 6 ] == c7 )
  |  |  |  |  |  |  ------------------
  |  |  |  |  |  |  |  | 2233|  23.1k|  ( CMP5( s, c1, c2, c3, c4, c5 ) && ((unsigned char *) s)[ 5 ] == c6 )
  |  |  |  |  |  |  |  |  ------------------
  |  |  |  |  |  |  |  |  |  | 2231|  23.1k|  ( CMP4( s, c1, c2, c3, c4 ) && ((unsigned char *) s)[ 4 ] == c5 )
  |  |  |  |  |  |  |  |  |  |  ------------------
  |  |  |  |  |  |  |  |  |  |  |  | 2228|  23.1k|  ( ((unsigned char *) s)[ 0 ] == c1 && ((unsigned char *) s)[ 1 ] == c2 && \
  |  |  |  |  |  |  |  |  |  |  |  |  ------------------
  |  |  |  |  |  |  |  |  |  |  |  |  |  Branch (2228:5): [True: 5.77k, False: 5.79k]
  |  |  |  |  |  |  |  |  |  |  |  |  |  Branch (2228:41): [True: 113, False: 5.66k]
  |  |  |  |  |  |  |  |  |  |  |  |  ------------------
  |  |  |  |  |  |  |  |  |  |  |  | 2229|  11.5k|    ((unsigned char *) s)[ 2 ] == c3 && ((unsigned char *) s)[ 3 ] == c4 )
  |  |  |  |  |  |  |  |  |  |  |  |  ------------------
  |  |  |  |  |  |  |  |  |  |  |  |  |  Branch (2229:5): [True: 0, False: 113]
  |  |  |  |  |  |  |  |  |  |  |  |  |  Branch (2229:41): [True: 0, False: 0]
  |  |  |  |  |  |  |  |  |  |  |  |  ------------------
  |  |  |  |  |  |  |  |  |  |  ------------------
  |  |  |  |  |  |  |  |  |  |  |  Branch (2231:34): [True: 0, False: 0]
  |  |  |  |  |  |  |  |  |  |  ------------------
  |  |  |  |  |  |  |  |  ------------------
  |  |  |  |  |  |  |  |  |  Branch (2233:38): [True: 0, False: 0]
  |  |  |  |  |  |  |  |  ------------------
  |  |  |  |  |  |  ------------------
  |  |  |  |  |  |  |  Branch (2235:42): [True: 0, False: 0]
  |  |  |  |  |  |  ------------------
  |  |  |  |  ------------------
  |  |  |  |  |  Branch (2237:46): [True: 0, False: 0]
  |  |  |  |  ------------------
  |  |  ------------------
  |  | 2240|  11.5k|    ((unsigned char *) s)[ 8 ] == c9 )
  |  |  ------------------
  |  |  |  Branch (2240:5): [True: 0, False: 0]
  |  |  ------------------
  ------------------
10230|      0|	    xmlParseCDSect(ctxt);
10231|      0|	}
10232|       |
10233|       |	/*
10234|       |	 * Third case :  a comment
10235|       |	 */
10236|  11.5k|	else if ((*cur == '<') && (NXT(1) == '!') &&
  ------------------
  |  | 2223|  5.77k|#define NXT(val) ctxt->input->cur[(val)]
  ------------------
  |  Branch (10236:11): [True: 5.77k, False: 5.79k]
  |  Branch (10236:28): [True: 113, False: 5.66k]
  ------------------
10237|  11.5k|		 (NXT(2) == '-') && (NXT(3) == '-')) {
  ------------------
  |  | 2223|    113|#define NXT(val) ctxt->input->cur[(val)]
  ------------------
              		 (NXT(2) == '-') && (NXT(3) == '-')) {
  ------------------
  |  | 2223|    113|#define NXT(val) ctxt->input->cur[(val)]
  ------------------
  |  Branch (10237:4): [True: 113, False: 0]
  |  Branch (10237:23): [True: 113, False: 0]
  ------------------
10238|    113|	    xmlParseComment(ctxt);
10239|    113|	    ctxt->instate = XML_PARSER_CONTENT;
10240|    113|	}
10241|       |
10242|       |	/*
10243|       |	 * Fourth case :  a sub-element.
10244|       |	 */
10245|  11.4k|	else if (*cur == '<') {
  ------------------
  |  Branch (10245:11): [True: 5.66k, False: 5.79k]
  ------------------
10246|  5.66k|            if (NXT(1) == '/') {
  ------------------
  |  | 2223|  5.66k|#define NXT(val) ctxt->input->cur[(val)]
  ------------------
  |  Branch (10246:17): [True: 2.15k, False: 3.51k]
  ------------------
10247|  2.15k|                if (ctxt->nameNr <= nameNr)
  ------------------
  |  Branch (10247:21): [True: 227, False: 1.92k]
  ------------------
10248|    227|                    break;
10249|  1.92k|	        xmlParseElementEnd(ctxt);
10250|  3.51k|            } else {
10251|  3.51k|	        xmlParseElementStart(ctxt);
10252|  3.51k|            }
10253|  5.66k|	}
10254|       |
10255|       |	/*
10256|       |	 * Fifth case : a reference. If if has not been resolved,
10257|       |	 *    parsing returns it's Name, create the node
10258|       |	 */
10259|       |
10260|  5.79k|	else if (*cur == '&') {
  ------------------
  |  Branch (10260:11): [True: 8, False: 5.78k]
  ------------------
10261|      8|	    xmlParseReference(ctxt);
10262|      8|	}
10263|       |
10264|       |	/*
10265|       |	 * Last case, text. Note that References are handled directly.
10266|       |	 */
10267|  5.78k|	else {
10268|  5.78k|	    xmlParseCharDataInternal(ctxt, 0);
10269|  5.78k|	}
10270|       |
10271|  11.3k|	SHRINK;
  ------------------
  |  | 2265|  11.3k|    if (((ctxt->progressive == 0) || (ctxt->inputNr > 1)) && \
  |  |  ------------------
  |  |  |  Branch (2265:10): [True: 11.3k, False: 0]
  |  |  |  Branch (2265:38): [True: 0, False: 0]
  |  |  ------------------
  |  | 2266|  11.3k|        (ctxt->input->cur - ctxt->input->base > 2 * INPUT_CHUNK) && \
  |  |  ------------------
  |  |  |  |   97|  11.3k|#define INPUT_CHUNK	250
  |  |  ------------------
  |  |  |  Branch (2266:9): [True: 5.36k, False: 5.97k]
  |  |  ------------------
  |  | 2267|  11.3k|	(ctxt->input->end - ctxt->input->cur < 2 * INPUT_CHUNK)) \
  |  |  ------------------
  |  |  |  |   97|  5.36k|#define INPUT_CHUNK	250
  |  |  ------------------
  |  |  |  Branch (2267:2): [True: 193, False: 5.17k]
  |  |  ------------------
  |  | 2268|  11.3k|	xmlParserShrink(ctxt);
  ------------------
10272|  11.3k|	GROW;
  ------------------
  |  | 2270|  11.3k|#define GROW if (ctxt->input->end - ctxt->input->cur < INPUT_CHUNK)	\
  |  |  ------------------
  |  |  |  |   97|  11.3k|#define INPUT_CHUNK	250
  |  |  ------------------
  |  |  |  Branch (2270:18): [True: 3.08k, False: 8.25k]
  |  |  ------------------
  |  | 2271|  11.3k|	xmlParserGrow(ctxt);
  ------------------
10273|  11.3k|    }
10274|    232|}
parser.c:xmlFatalErrMsgStrIntStr:
  416|     47|{
  417|     47|    if ((ctxt != NULL) && (ctxt->disableSAX != 0) &&
  ------------------
  |  Branch (417:9): [True: 47, False: 0]
  |  Branch (417:27): [True: 42, False: 5]
  ------------------
  418|     47|        (ctxt->instate == XML_PARSER_EOF))
  ------------------
  |  Branch (418:9): [True: 0, False: 42]
  ------------------
  419|      0|	return;
  420|     47|    if (ctxt != NULL)
  ------------------
  |  Branch (420:9): [True: 47, False: 0]
  ------------------
  421|     47|	ctxt->errNo = error;
  422|     47|    __xmlRaiseError(NULL, NULL, NULL,
  423|     47|                    ctxt, NULL, XML_FROM_PARSER, error, XML_ERR_FATAL,
  424|     47|                    NULL, 0, (const char *) str1, (const char *) str2,
  425|     47|		    NULL, val, 0, msg, str1, val, str2);
  426|     47|    if (ctxt != NULL) {
  ------------------
  |  Branch (426:9): [True: 47, False: 0]
  ------------------
  427|     47|	ctxt->wellFormed = 0;
  428|     47|	if (ctxt->recovery == 0)
  ------------------
  |  Branch (428:6): [True: 47, False: 0]
  ------------------
  429|     47|	    ctxt->disableSAX = 1;
  430|     47|    }
  431|     47|}
parser.c:xmlParseElementStart:
10351|  3.74k|xmlParseElementStart(xmlParserCtxtPtr ctxt) {
10352|  3.74k|    const xmlChar *name;
10353|  3.74k|    const xmlChar *prefix = NULL;
10354|  3.74k|    const xmlChar *URI = NULL;
10355|  3.74k|    xmlParserNodeInfo node_info;
10356|  3.74k|    int line;
10357|  3.74k|    xmlNodePtr cur;
10358|  3.74k|    int nbNs = 0;
10359|       |
10360|  3.74k|    if (((unsigned int) ctxt->nameNr > xmlParserMaxDepth) &&
  ------------------
  |  Branch (10360:9): [True: 0, False: 3.74k]
  ------------------
10361|  3.74k|        ((ctxt->options & XML_PARSE_HUGE) == 0)) {
  ------------------
  |  Branch (10361:9): [True: 0, False: 0]
  ------------------
10362|      0|	xmlFatalErrMsgInt(ctxt, XML_ERR_INTERNAL_ERROR,
10363|      0|		 "Excessive depth in document: %d use XML_PARSE_HUGE option\n",
10364|      0|			  xmlParserMaxDepth);
10365|      0|	xmlHaltParser(ctxt);
10366|      0|	return(-1);
10367|      0|    }
10368|       |
10369|       |    /* Capture start position */
10370|  3.74k|    if (ctxt->record_info) {
  ------------------
  |  Branch (10370:9): [True: 0, False: 3.74k]
  ------------------
10371|      0|        node_info.begin_pos = ctxt->input->consumed +
10372|      0|                          (CUR_PTR - ctxt->input->base);
  ------------------
  |  | 2224|      0|#define CUR_PTR ctxt->input->cur
  ------------------
10373|      0|	node_info.begin_line = ctxt->input->line;
10374|      0|    }
10375|       |
10376|  3.74k|    if (ctxt->spaceNr == 0)
  ------------------
  |  Branch (10376:9): [True: 235, False: 3.51k]
  ------------------
10377|    235|	spacePush(ctxt, -1);
10378|  3.51k|    else if (*ctxt->space == -2)
  ------------------
  |  Branch (10378:14): [True: 0, False: 3.51k]
  ------------------
10379|      0|	spacePush(ctxt, -1);
10380|  3.51k|    else
10381|  3.51k|	spacePush(ctxt, *ctxt->space);
10382|       |
10383|  3.74k|    line = ctxt->input->line;
10384|  3.74k|#ifdef LIBXML_SAX1_ENABLED
10385|  3.74k|    if (ctxt->sax2)
  ------------------
  |  Branch (10385:9): [True: 3.74k, False: 0]
  ------------------
10386|  3.74k|#endif /* LIBXML_SAX1_ENABLED */
10387|  3.74k|        name = xmlParseStartTag2(ctxt, &prefix, &URI, &nbNs);
10388|      0|#ifdef LIBXML_SAX1_ENABLED
10389|      0|    else
10390|      0|	name = xmlParseStartTag(ctxt);
10391|  3.74k|#endif /* LIBXML_SAX1_ENABLED */
10392|  3.74k|    if (ctxt->instate == XML_PARSER_EOF)
  ------------------
  |  Branch (10392:9): [True: 0, False: 3.74k]
  ------------------
10393|      0|	return(-1);
10394|  3.74k|    if (name == NULL) {
  ------------------
  |  Branch (10394:9): [True: 1, False: 3.74k]
  ------------------
10395|      1|	spacePop(ctxt);
10396|      1|        return(-1);
10397|      1|    }
10398|  3.74k|    nameNsPush(ctxt, name, prefix, URI, line, nbNs);
10399|  3.74k|    cur = ctxt->node;
10400|       |
10401|  3.74k|#ifdef LIBXML_VALID_ENABLED
10402|       |    /*
10403|       |     * [ VC: Root Element Type ]
10404|       |     * The Name in the document type declaration must match the element
10405|       |     * type of the root element.
10406|       |     */
10407|  3.74k|    if (ctxt->validate && ctxt->wellFormed && ctxt->myDoc &&
  ------------------
  |  Branch (10407:9): [True: 0, False: 3.74k]
  |  Branch (10407:27): [True: 0, False: 0]
  |  Branch (10407:47): [True: 0, False: 0]
  ------------------
10408|  3.74k|        ctxt->node && (ctxt->node == ctxt->myDoc->children))
  ------------------
  |  Branch (10408:9): [True: 0, False: 0]
  |  Branch (10408:23): [True: 0, False: 0]
  ------------------
10409|      0|        ctxt->valid &= xmlValidateRoot(&ctxt->vctxt, ctxt->myDoc);
10410|  3.74k|#endif /* LIBXML_VALID_ENABLED */
10411|       |
10412|       |    /*
10413|       |     * Check for an Empty Element.
10414|       |     */
10415|  3.74k|    if ((RAW == '/') && (NXT(1) == '>')) {
  ------------------
  |  | 2221|  3.74k|#define RAW (*ctxt->input->cur)
  ------------------
                  if ((RAW == '/') && (NXT(1) == '>')) {
  ------------------
  |  | 2223|  1.56k|#define NXT(val) ctxt->input->cur[(val)]
  ------------------
  |  Branch (10415:9): [True: 1.56k, False: 2.18k]
  |  Branch (10415:25): [True: 1.56k, False: 0]
  ------------------
10416|  1.56k|        SKIP(2);
  ------------------
  |  | 2245|  1.56k|#define SKIP(val) do {							\
  |  | 2246|  1.56k|    ctxt->input->cur += (val),ctxt->input->col+=(val);			\
  |  | 2247|  1.56k|    if (*ctxt->input->cur == 0)						\
  |  |  ------------------
  |  |  |  Branch (2247:9): [True: 0, False: 1.56k]
  |  |  ------------------
  |  | 2248|  1.56k|        xmlParserGrow(ctxt);						\
  |  | 2249|  1.56k|  } while (0)
  |  |  ------------------
  |  |  |  Branch (2249:12): [Folded - Ignored]
  |  |  ------------------
  ------------------
10417|  1.56k|	if (ctxt->sax2) {
  ------------------
  |  Branch (10417:6): [True: 1.56k, False: 0]
  ------------------
10418|  1.56k|	    if ((ctxt->sax != NULL) && (ctxt->sax->endElementNs != NULL) &&
  ------------------
  |  Branch (10418:10): [True: 1.56k, False: 0]
  |  Branch (10418:33): [True: 1.56k, False: 0]
  ------------------
10419|  1.56k|		(!ctxt->disableSAX))
  ------------------
  |  Branch (10419:3): [True: 1.46k, False: 97]
  ------------------
10420|  1.46k|		ctxt->sax->endElementNs(ctxt->userData, name, prefix, URI);
10421|  1.56k|#ifdef LIBXML_SAX1_ENABLED
10422|  1.56k|	} else {
10423|      0|	    if ((ctxt->sax != NULL) && (ctxt->sax->endElement != NULL) &&
  ------------------
  |  Branch (10423:10): [True: 0, False: 0]
  |  Branch (10423:33): [True: 0, False: 0]
  ------------------
10424|      0|		(!ctxt->disableSAX))
  ------------------
  |  Branch (10424:3): [True: 0, False: 0]
  ------------------
10425|      0|		ctxt->sax->endElement(ctxt->userData, name);
10426|      0|#endif /* LIBXML_SAX1_ENABLED */
10427|      0|	}
10428|  1.56k|	namePop(ctxt);
10429|  1.56k|	spacePop(ctxt);
10430|  1.56k|	if (nbNs > 0)
  ------------------
  |  Branch (10430:6): [True: 0, False: 1.56k]
  ------------------
10431|      0|	    xmlParserNsPop(ctxt, nbNs);
10432|  1.56k|	if (cur != NULL && ctxt->record_info) {
  ------------------
  |  Branch (10432:6): [True: 1.54k, False: 15]
  |  Branch (10432:21): [True: 0, False: 1.54k]
  ------------------
10433|      0|            node_info.node = cur;
10434|      0|            node_info.end_pos = ctxt->input->consumed +
10435|      0|                                (CUR_PTR - ctxt->input->base);
  ------------------
  |  | 2224|      0|#define CUR_PTR ctxt->input->cur
  ------------------
10436|      0|            node_info.end_line = ctxt->input->line;
10437|      0|            xmlParserAddNodeInfo(ctxt, &node_info);
10438|      0|	}
10439|  1.56k|	return(1);
10440|  1.56k|    }
10441|  2.18k|    if (RAW == '>') {
  ------------------
  |  | 2221|  2.18k|#define RAW (*ctxt->input->cur)
  ------------------
  |  Branch (10441:9): [True: 2.16k, False: 14]
  ------------------
10442|  2.16k|        NEXT1;
  ------------------
  |  | 2277|  2.16k|#define NEXT1 {								\
  |  | 2278|  2.16k|	ctxt->input->col++;						\
  |  | 2279|  2.16k|	ctxt->input->cur++;						\
  |  | 2280|  2.16k|	if (*ctxt->input->cur == 0)					\
  |  |  ------------------
  |  |  |  Branch (2280:6): [True: 0, False: 2.16k]
  |  |  ------------------
  |  | 2281|  2.16k|	    xmlParserGrow(ctxt);						\
  |  | 2282|  2.16k|    }
  ------------------
10443|  2.16k|        if (cur != NULL && ctxt->record_info) {
  ------------------
  |  Branch (10443:13): [True: 2.15k, False: 17]
  |  Branch (10443:28): [True: 0, False: 2.15k]
  ------------------
10444|      0|            node_info.node = cur;
10445|      0|            node_info.end_pos = 0;
10446|      0|            node_info.end_line = 0;
10447|      0|            xmlParserAddNodeInfo(ctxt, &node_info);
10448|      0|        }
10449|  2.16k|    } else {
10450|     14|        xmlFatalErrMsgStrIntStr(ctxt, XML_ERR_GT_REQUIRED,
10451|     14|		     "Couldn't find end of Start Tag %s line %d\n",
10452|     14|		                name, line, NULL);
10453|       |
10454|       |	/*
10455|       |	 * end of parsing of this node.
10456|       |	 */
10457|     14|	nodePop(ctxt);
10458|     14|	namePop(ctxt);
10459|     14|	spacePop(ctxt);
10460|     14|	if (nbNs > 0)
  ------------------
  |  Branch (10460:6): [True: 3, False: 11]
  ------------------
10461|      3|	    xmlParserNsPop(ctxt, nbNs);
10462|     14|	return(-1);
10463|     14|    }
10464|       |
10465|  2.16k|    return(0);
10466|  2.18k|}
parser.c:spacePush:
 2154|  3.74k|static int spacePush(xmlParserCtxtPtr ctxt, int val) {
 2155|  3.74k|    if (ctxt->spaceNr >= ctxt->spaceMax) {
  ------------------
  |  Branch (2155:9): [True: 4, False: 3.74k]
  ------------------
 2156|      4|        int *tmp;
 2157|       |
 2158|      4|	ctxt->spaceMax *= 2;
 2159|      4|        tmp = (int *) xmlRealloc(ctxt->spaceTab,
 2160|      4|	                         ctxt->spaceMax * sizeof(ctxt->spaceTab[0]));
 2161|      4|        if (tmp == NULL) {
  ------------------
  |  Branch (2161:13): [True: 0, False: 4]
  ------------------
 2162|      0|	    xmlErrMemory(ctxt, NULL);
 2163|      0|	    ctxt->spaceMax /=2;
 2164|      0|	    return(-1);
 2165|      0|	}
 2166|      4|	ctxt->spaceTab = tmp;
 2167|      4|    }
 2168|  3.74k|    ctxt->spaceTab[ctxt->spaceNr] = val;
 2169|  3.74k|    ctxt->space = &ctxt->spaceTab[ctxt->spaceNr];
 2170|  3.74k|    return(ctxt->spaceNr++);
 2171|  3.74k|}
parser.c:xmlParseStartTag2:
 9471|  3.74k|                  const xmlChar **URI, int *nbNsPtr) {
 9472|  3.74k|    xmlHashedString hlocalname;
 9473|  3.74k|    xmlHashedString hprefix;
 9474|  3.74k|    xmlHashedString hattname;
 9475|  3.74k|    xmlHashedString haprefix;
 9476|  3.74k|    const xmlChar *localname;
 9477|  3.74k|    const xmlChar *prefix;
 9478|  3.74k|    const xmlChar *attname;
 9479|  3.74k|    const xmlChar *aprefix;
 9480|  3.74k|    const xmlChar *uri;
 9481|  3.74k|    xmlChar *attvalue = NULL;
 9482|  3.74k|    const xmlChar **atts = ctxt->atts;
 9483|  3.74k|    unsigned attrHashSize = 0;
 9484|  3.74k|    int maxatts = ctxt->maxatts;
 9485|  3.74k|    int nratts, nbatts, nbdef, inputid;
 9486|  3.74k|    int i, j, nbNs, nbTotalDef, attval, nsIndex, maxAtts;
 9487|  3.74k|    int alloc = 0;
 9488|       |
 9489|  3.74k|    if (RAW != '<') return(NULL);
  ------------------
  |  | 2221|  3.74k|#define RAW (*ctxt->input->cur)
  ------------------
  |  Branch (9489:9): [True: 0, False: 3.74k]
  ------------------
 9490|  3.74k|    NEXT1;
  ------------------
  |  | 2277|  3.74k|#define NEXT1 {								\
  |  | 2278|  3.74k|	ctxt->input->col++;						\
  |  | 2279|  3.74k|	ctxt->input->cur++;						\
  |  | 2280|  3.74k|	if (*ctxt->input->cur == 0)					\
  |  |  ------------------
  |  |  |  Branch (2280:6): [True: 0, False: 3.74k]
  |  |  ------------------
  |  | 2281|  3.74k|	    xmlParserGrow(ctxt);						\
  |  | 2282|  3.74k|    }
  ------------------
 9491|       |
 9492|  3.74k|    inputid = ctxt->input->id;
 9493|  3.74k|    nbatts = 0;
 9494|  3.74k|    nratts = 0;
 9495|  3.74k|    nbdef = 0;
 9496|  3.74k|    nbNs = 0;
 9497|  3.74k|    nbTotalDef = 0;
 9498|  3.74k|    attval = 0;
 9499|       |
 9500|  3.74k|    if (xmlParserNsStartElement(ctxt->nsdb) < 0) {
  ------------------
  |  Branch (9500:9): [True: 0, False: 3.74k]
  ------------------
 9501|      0|        xmlErrMemory(ctxt, NULL);
 9502|      0|        return(NULL);
 9503|      0|    }
 9504|       |
 9505|  3.74k|    hlocalname = xmlParseQNameHashed(ctxt, &hprefix);
 9506|  3.74k|    if (hlocalname.name == NULL) {
  ------------------
  |  Branch (9506:9): [True: 1, False: 3.74k]
  ------------------
 9507|      1|	xmlFatalErrMsg(ctxt, XML_ERR_NAME_REQUIRED,
 9508|      1|		       "StartTag: invalid element name\n");
 9509|      1|        return(NULL);
 9510|      1|    }
 9511|  3.74k|    localname = hlocalname.name;
 9512|  3.74k|    prefix = hprefix.name;
 9513|       |
 9514|       |    /*
 9515|       |     * Now parse the attributes, it ends up with the ending
 9516|       |     *
 9517|       |     * (S Attribute)* S?
 9518|       |     */
 9519|  3.74k|    SKIP_BLANKS;
  ------------------
  |  | 2273|  3.74k|#define SKIP_BLANKS xmlSkipBlankChars(ctxt)
  ------------------
 9520|  3.74k|    GROW;
  ------------------
  |  | 2270|  3.74k|#define GROW if (ctxt->input->end - ctxt->input->cur < INPUT_CHUNK)	\
  |  |  ------------------
  |  |  |  |   97|  3.74k|#define INPUT_CHUNK	250
  |  |  ------------------
  |  |  |  Branch (2270:18): [True: 804, False: 2.94k]
  |  |  ------------------
  |  | 2271|  3.74k|	xmlParserGrow(ctxt);
  ------------------
 9521|       |
 9522|       |    /*
 9523|       |     * The ctxt->atts array will be ultimately passed to the SAX callback
 9524|       |     * containing five xmlChar pointers for each attribute:
 9525|       |     *
 9526|       |     * [0] attribute name
 9527|       |     * [1] attribute prefix
 9528|       |     * [2] namespace URI
 9529|       |     * [3] attribute value
 9530|       |     * [4] end of attribute value
 9531|       |     *
 9532|       |     * To save memory, we reuse this array temporarily and store integers
 9533|       |     * in these pointer variables.
 9534|       |     *
 9535|       |     * [0] attribute name
 9536|       |     * [1] attribute prefix
 9537|       |     * [2] hash value of attribute prefix, and later namespace index
 9538|       |     * [3] for non-allocated values: ptrdiff_t offset into input buffer
 9539|       |     * [4] for non-allocated values: ptrdiff_t offset into input buffer
 9540|       |     *
 9541|       |     * The ctxt->attallocs array contains an additional unsigned int for
 9542|       |     * each attribute, containing the hash value of the attribute name
 9543|       |     * and the alloc flag in bit 31.
 9544|       |     */
 9545|       |
 9546|  5.76k|    while (((RAW != '>') &&
  ------------------
  |  | 2221|  5.76k|#define RAW (*ctxt->input->cur)
  ------------------
  |  Branch (9546:13): [True: 4.85k, False: 910]
  ------------------
 9547|  5.76k|	   ((RAW != '/') || (NXT(1) != '>')) &&
  ------------------
  |  | 2221|  4.85k|#define RAW (*ctxt->input->cur)
  ------------------
              	   ((RAW != '/') || (NXT(1) != '>')) &&
  ------------------
  |  | 2223|    228|#define NXT(val) ctxt->input->cur[(val)]
  ------------------
  |  Branch (9547:6): [True: 4.63k, False: 228]
  |  Branch (9547:22): [True: 0, False: 228]
  ------------------
 9548|  5.76k|	   (IS_BYTE_CHAR(RAW))) && (ctxt->instate != XML_PARSER_EOF)) {
  ------------------
  |  |  113|  4.63k|#define IS_BYTE_CHAR(c)	 xmlIsChar_ch(c)
  |  |  ------------------
  |  |  |  |  108|  4.63k|#define xmlIsChar_ch(c)		(((0x9 <= (c)) && ((c) <= 0xa)) || \
  |  |  |  |  ------------------
  |  |  |  |  |  Branch (108:28): [True: 4.63k, False: 0]
  |  |  |  |  |  Branch (108:44): [True: 0, False: 4.63k]
  |  |  |  |  ------------------
  |  |  |  |  109|  4.63k|				 ((c) == 0xd) || \
  |  |  |  |  ------------------
  |  |  |  |  |  Branch (109:6): [True: 0, False: 4.63k]
  |  |  |  |  ------------------
  |  |  |  |  110|  4.63k|				  (0x20 <= (c)))
  |  |  |  |  ------------------
  |  |  |  |  |  Branch (110:7): [True: 4.63k, False: 0]
  |  |  |  |  ------------------
  |  |  ------------------
  ------------------
  |  Branch (9548:29): [True: 4.63k, False: 0]
  ------------------
 9549|  4.63k|	int len = -1;
 9550|       |
 9551|  4.63k|	hattname = xmlParseAttribute2(ctxt, prefix, localname,
 9552|  4.63k|                                          &haprefix, &attvalue, &len,
 9553|  4.63k|                                          &alloc);
 9554|  4.63k|        if (hattname.name == NULL) {
  ------------------
  |  Branch (9554:13): [True: 6, False: 4.62k]
  ------------------
 9555|      6|	    xmlFatalErr(ctxt, XML_ERR_INTERNAL_ERROR,
 9556|      6|	         "xmlParseStartTag: problem parsing attributes\n");
 9557|      6|	    break;
 9558|      6|	}
 9559|  4.62k|        if (attvalue == NULL)
  ------------------
  |  Branch (9559:13): [True: 2, False: 4.62k]
  ------------------
 9560|      2|            goto next_attr;
 9561|  4.62k|        attname = hattname.name;
 9562|  4.62k|        aprefix = haprefix.name;
 9563|  4.62k|	if (len < 0) len = xmlStrlen(attvalue);
  ------------------
  |  Branch (9563:6): [True: 0, False: 4.62k]
  ------------------
 9564|       |
 9565|  4.62k|        if ((attname == ctxt->str_xmlns) && (aprefix == NULL)) {
  ------------------
  |  Branch (9565:13): [True: 71, False: 4.55k]
  |  Branch (9565:45): [True: 71, False: 0]
  ------------------
 9566|     71|            xmlHashedString huri;
 9567|     71|            xmlURIPtr parsedUri;
 9568|       |
 9569|     71|            huri = xmlDictLookupHashed(ctxt->dict, attvalue, len);
 9570|     71|            uri = huri.name;
 9571|     71|            if (uri == NULL) {
  ------------------
  |  Branch (9571:17): [True: 0, False: 71]
  ------------------
 9572|      0|                xmlErrMemory(ctxt, NULL);
 9573|      0|                goto next_attr;
 9574|      0|            }
 9575|     71|            if (*uri != 0) {
  ------------------
  |  Branch (9575:17): [True: 70, False: 1]
  ------------------
 9576|     70|                parsedUri = xmlParseURI((const char *) uri);
 9577|     70|                if (parsedUri == NULL) {
  ------------------
  |  Branch (9577:21): [True: 1, False: 69]
  ------------------
 9578|      1|                    xmlNsErr(ctxt, XML_WAR_NS_URI,
 9579|      1|                             "xmlns: '%s' is not a valid URI\n",
 9580|      1|                                       uri, NULL, NULL);
 9581|     69|                } else {
 9582|     69|                    if (parsedUri->scheme == NULL) {
  ------------------
  |  Branch (9582:25): [True: 0, False: 69]
  ------------------
 9583|      0|                        xmlNsWarn(ctxt, XML_WAR_NS_URI_RELATIVE,
 9584|      0|                                  "xmlns: URI %s is not absolute\n",
 9585|      0|                                  uri, NULL, NULL);
 9586|      0|                    }
 9587|     69|                    xmlFreeURI(parsedUri);
 9588|     69|                }
 9589|     70|                if (uri == ctxt->str_xml_ns) {
  ------------------
  |  Branch (9589:21): [True: 0, False: 70]
  ------------------
 9590|      0|                    if (attname != ctxt->str_xml) {
  ------------------
  |  Branch (9590:25): [True: 0, False: 0]
  ------------------
 9591|      0|                        xmlNsErr(ctxt, XML_NS_ERR_XML_NAMESPACE,
 9592|      0|                     "xml namespace URI cannot be the default namespace\n",
 9593|      0|                                 NULL, NULL, NULL);
 9594|      0|                    }
 9595|      0|                    goto next_attr;
 9596|      0|                }
 9597|     70|                if ((len == 29) &&
  ------------------
  |  Branch (9597:21): [True: 1, False: 69]
  ------------------
 9598|     70|                    (xmlStrEqual(uri,
  ------------------
  |  Branch (9598:21): [True: 0, False: 1]
  ------------------
 9599|      1|                             BAD_CAST "http://www.w3.org/2000/xmlns/"))) {
  ------------------
  |  |   35|      1|#define BAD_CAST (xmlChar *)
  ------------------
 9600|      0|                    xmlNsErr(ctxt, XML_NS_ERR_XML_NAMESPACE,
 9601|      0|                         "reuse of the xmlns namespace name is forbidden\n",
 9602|      0|                             NULL, NULL, NULL);
 9603|      0|                    goto next_attr;
 9604|      0|                }
 9605|     70|            }
 9606|       |
 9607|     71|            if (xmlParserNsPush(ctxt, NULL, &huri, NULL, 0) > 0)
  ------------------
  |  Branch (9607:17): [True: 71, False: 0]
  ------------------
 9608|     71|                nbNs++;
 9609|  4.55k|        } else if (aprefix == ctxt->str_xmlns) {
  ------------------
  |  Branch (9609:20): [True: 317, False: 4.23k]
  ------------------
 9610|    317|            xmlHashedString huri;
 9611|    317|            xmlURIPtr parsedUri;
 9612|       |
 9613|    317|            huri = xmlDictLookupHashed(ctxt->dict, attvalue, len);
 9614|    317|            uri = huri.name;
 9615|    317|            if (uri == NULL) {
  ------------------
  |  Branch (9615:17): [True: 0, False: 317]
  ------------------
 9616|      0|                xmlErrMemory(ctxt, NULL);
 9617|      0|                goto next_attr;
 9618|      0|            }
 9619|       |
 9620|    317|            if (attname == ctxt->str_xml) {
  ------------------
  |  Branch (9620:17): [True: 0, False: 317]
  ------------------
 9621|      0|                if (uri != ctxt->str_xml_ns) {
  ------------------
  |  Branch (9621:21): [True: 0, False: 0]
  ------------------
 9622|      0|                    xmlNsErr(ctxt, XML_NS_ERR_XML_NAMESPACE,
 9623|      0|                             "xml namespace prefix mapped to wrong URI\n",
 9624|      0|                             NULL, NULL, NULL);
 9625|      0|                }
 9626|       |                /*
 9627|       |                 * Do not keep a namespace definition node
 9628|       |                 */
 9629|      0|                goto next_attr;
 9630|      0|            }
 9631|    317|            if (uri == ctxt->str_xml_ns) {
  ------------------
  |  Branch (9631:17): [True: 0, False: 317]
  ------------------
 9632|      0|                if (attname != ctxt->str_xml) {
  ------------------
  |  Branch (9632:21): [True: 0, False: 0]
  ------------------
 9633|      0|                    xmlNsErr(ctxt, XML_NS_ERR_XML_NAMESPACE,
 9634|      0|                             "xml namespace URI mapped to wrong prefix\n",
 9635|      0|                             NULL, NULL, NULL);
 9636|      0|                }
 9637|      0|                goto next_attr;
 9638|      0|            }
 9639|    317|            if (attname == ctxt->str_xmlns) {
  ------------------
  |  Branch (9639:17): [True: 0, False: 317]
  ------------------
 9640|      0|                xmlNsErr(ctxt, XML_NS_ERR_XML_NAMESPACE,
 9641|      0|                         "redefinition of the xmlns prefix is forbidden\n",
 9642|      0|                         NULL, NULL, NULL);
 9643|      0|                goto next_attr;
 9644|      0|            }
 9645|    317|            if ((len == 29) &&
  ------------------
  |  Branch (9645:17): [True: 1, False: 316]
  ------------------
 9646|    317|                (xmlStrEqual(uri,
  ------------------
  |  Branch (9646:17): [True: 0, False: 1]
  ------------------
 9647|      1|                             BAD_CAST "http://www.w3.org/2000/xmlns/"))) {
  ------------------
  |  |   35|      1|#define BAD_CAST (xmlChar *)
  ------------------
 9648|      0|                xmlNsErr(ctxt, XML_NS_ERR_XML_NAMESPACE,
 9649|      0|                         "reuse of the xmlns namespace name is forbidden\n",
 9650|      0|                         NULL, NULL, NULL);
 9651|      0|                goto next_attr;
 9652|      0|            }
 9653|    317|            if ((uri == NULL) || (uri[0] == 0)) {
  ------------------
  |  Branch (9653:17): [True: 0, False: 317]
  |  Branch (9653:34): [True: 0, False: 317]
  ------------------
 9654|      0|                xmlNsErr(ctxt, XML_NS_ERR_XML_NAMESPACE,
 9655|      0|                         "xmlns:%s: Empty XML namespace is not allowed\n",
 9656|      0|                              attname, NULL, NULL);
 9657|      0|                goto next_attr;
 9658|    317|            } else {
 9659|    317|                parsedUri = xmlParseURI((const char *) uri);
 9660|    317|                if (parsedUri == NULL) {
  ------------------
  |  Branch (9660:21): [True: 1, False: 316]
  ------------------
 9661|      1|                    xmlNsErr(ctxt, XML_WAR_NS_URI,
 9662|      1|                         "xmlns:%s: '%s' is not a valid URI\n",
 9663|      1|                                       attname, uri, NULL);
 9664|    316|                } else {
 9665|    316|                    if ((ctxt->pedantic) && (parsedUri->scheme == NULL)) {
  ------------------
  |  Branch (9665:25): [True: 0, False: 316]
  |  Branch (9665:45): [True: 0, False: 0]
  ------------------
 9666|      0|                        xmlNsWarn(ctxt, XML_WAR_NS_URI_RELATIVE,
 9667|      0|                                  "xmlns:%s: URI %s is not absolute\n",
 9668|      0|                                  attname, uri, NULL);
 9669|      0|                    }
 9670|    316|                    xmlFreeURI(parsedUri);
 9671|    316|                }
 9672|    317|            }
 9673|       |
 9674|    317|            if (xmlParserNsPush(ctxt, &hattname, &huri, NULL, 0) > 0)
  ------------------
  |  Branch (9674:17): [True: 317, False: 0]
  ------------------
 9675|    317|                nbNs++;
 9676|  4.23k|        } else {
 9677|       |            /*
 9678|       |             * Populate attributes array, see above for repurposing
 9679|       |             * of xmlChar pointers.
 9680|       |             */
 9681|  4.23k|            if ((atts == NULL) || (nbatts + 5 > maxatts)) {
  ------------------
  |  Branch (9681:17): [True: 233, False: 4.00k]
  |  Branch (9681:35): [True: 1, False: 4.00k]
  ------------------
 9682|    234|                if (xmlCtxtGrowAttrs(ctxt, nbatts + 5) < 0) {
  ------------------
  |  Branch (9682:21): [True: 0, False: 234]
  ------------------
 9683|      0|                    goto next_attr;
 9684|      0|                }
 9685|    234|                maxatts = ctxt->maxatts;
 9686|    234|                atts = ctxt->atts;
 9687|    234|            }
 9688|  4.23k|            ctxt->attallocs[nratts++] = (hattname.hashValue & 0x7FFFFFFF) |
 9689|  4.23k|                                        ((unsigned) alloc << 31);
 9690|  4.23k|            atts[nbatts++] = attname;
 9691|  4.23k|            atts[nbatts++] = aprefix;
 9692|  4.23k|            atts[nbatts++] = (const xmlChar *) (size_t) haprefix.hashValue;
 9693|  4.23k|            if (alloc) {
  ------------------
  |  Branch (9693:17): [True: 5, False: 4.22k]
  ------------------
 9694|      5|                atts[nbatts++] = attvalue;
 9695|      5|                attvalue += len;
 9696|      5|                atts[nbatts++] = attvalue;
 9697|  4.22k|            } else {
 9698|       |                /*
 9699|       |                 * attvalue points into the input buffer which can be
 9700|       |                 * reallocated. Store differences to input->base instead.
 9701|       |                 * The pointers will be reconstructed later.
 9702|       |                 */
 9703|  4.22k|                atts[nbatts++] = (void *) (attvalue - BASE_PTR);
  ------------------
  |  | 2225|  4.22k|#define BASE_PTR ctxt->input->base
  ------------------
 9704|  4.22k|                attvalue += len;
 9705|  4.22k|                atts[nbatts++] = (void *) (attvalue - BASE_PTR);
  ------------------
  |  | 2225|  4.22k|#define BASE_PTR ctxt->input->base
  ------------------
 9706|  4.22k|            }
 9707|       |            /*
 9708|       |             * tag if some deallocation is needed
 9709|       |             */
 9710|  4.23k|            if (alloc != 0) attval = 1;
  ------------------
  |  Branch (9710:17): [True: 5, False: 4.22k]
  ------------------
 9711|  4.23k|            attvalue = NULL; /* moved into atts */
 9712|  4.23k|        }
 9713|       |
 9714|  4.62k|next_attr:
 9715|  4.62k|        if ((attvalue != NULL) && (alloc != 0)) {
  ------------------
  |  Branch (9715:13): [True: 388, False: 4.23k]
  |  Branch (9715:35): [True: 1, False: 387]
  ------------------
 9716|      1|            xmlFree(attvalue);
 9717|      1|            attvalue = NULL;
 9718|      1|        }
 9719|       |
 9720|  4.62k|	GROW
  ------------------
  |  | 2270|  4.62k|#define GROW if (ctxt->input->end - ctxt->input->cur < INPUT_CHUNK)	\
  |  |  ------------------
  |  |  |  |   97|  4.62k|#define INPUT_CHUNK	250
  |  |  ------------------
  |  |  |  Branch (2270:18): [True: 1.14k, False: 3.47k]
  |  |  ------------------
  |  | 2271|  4.62k|	xmlParserGrow(ctxt);
  ------------------
 9721|  4.62k|        if (ctxt->instate == XML_PARSER_EOF)
  ------------------
  |  Branch (9721:13): [True: 0, False: 4.62k]
  ------------------
 9722|      0|            break;
 9723|  4.62k|	if ((RAW == '>') || (((RAW == '/') && (NXT(1) == '>'))))
  ------------------
  |  | 2221|  4.62k|#define RAW (*ctxt->input->cur)
  ------------------
              	if ((RAW == '>') || (((RAW == '/') && (NXT(1) == '>'))))
  ------------------
  |  | 2221|  3.36k|#define RAW (*ctxt->input->cur)
  ------------------
              	if ((RAW == '>') || (((RAW == '/') && (NXT(1) == '>'))))
  ------------------
  |  | 2223|  1.33k|#define NXT(val) ctxt->input->cur[(val)]
  ------------------
  |  Branch (9723:6): [True: 1.25k, False: 3.36k]
  |  Branch (9723:24): [True: 1.33k, False: 2.03k]
  |  Branch (9723:40): [True: 1.33k, False: 0]
  ------------------
 9724|  2.59k|	    break;
 9725|  2.03k|	if (SKIP_BLANKS == 0) {
  ------------------
  |  | 2273|  2.03k|#define SKIP_BLANKS xmlSkipBlankChars(ctxt)
  ------------------
  |  Branch (9725:6): [True: 8, False: 2.02k]
  ------------------
 9726|      8|	    xmlFatalErrMsg(ctxt, XML_ERR_SPACE_REQUIRED,
 9727|      8|			   "attributes construct error\n");
 9728|      8|	    break;
 9729|      8|	}
 9730|  2.02k|        GROW;
  ------------------
  |  | 2270|  2.02k|#define GROW if (ctxt->input->end - ctxt->input->cur < INPUT_CHUNK)	\
  |  |  ------------------
  |  |  |  |   97|  2.02k|#define INPUT_CHUNK	250
  |  |  ------------------
  |  |  |  Branch (2270:18): [True: 492, False: 1.53k]
  |  |  ------------------
  |  | 2271|  2.02k|	xmlParserGrow(ctxt);
  ------------------
 9731|  2.02k|    }
 9732|       |
 9733|  3.74k|    if (ctxt->input->id != inputid) {
  ------------------
  |  Branch (9733:9): [True: 0, False: 3.74k]
  ------------------
 9734|      0|        xmlFatalErr(ctxt, XML_ERR_INTERNAL_ERROR,
 9735|      0|                    "Unexpected change of input\n");
 9736|      0|        localname = NULL;
 9737|      0|        goto done;
 9738|      0|    }
 9739|       |
 9740|       |    /*
 9741|       |     * Namespaces from default attributes
 9742|       |     */
 9743|  3.74k|    if (ctxt->attsDefault != NULL) {
  ------------------
  |  Branch (9743:9): [True: 0, False: 3.74k]
  ------------------
 9744|      0|        xmlDefAttrsPtr defaults;
 9745|       |
 9746|      0|	defaults = xmlHashLookup2(ctxt->attsDefault, localname, prefix);
 9747|      0|	if (defaults != NULL) {
  ------------------
  |  Branch (9747:6): [True: 0, False: 0]
  ------------------
 9748|      0|	    for (i = 0; i < defaults->nbAttrs; i++) {
  ------------------
  |  Branch (9748:18): [True: 0, False: 0]
  ------------------
 9749|      0|                xmlDefAttr *attr = &defaults->attrs[i];
 9750|       |
 9751|      0|	        attname = attr->name.name;
 9752|      0|		aprefix = attr->prefix.name;
 9753|       |
 9754|      0|		if ((attname == ctxt->str_xmlns) && (aprefix == NULL)) {
  ------------------
  |  Branch (9754:7): [True: 0, False: 0]
  |  Branch (9754:39): [True: 0, False: 0]
  ------------------
 9755|      0|                    xmlParserEntityCheck(ctxt, attr->expandedSize);
 9756|       |
 9757|      0|                    if (xmlParserNsPush(ctxt, NULL, &attr->value, NULL, 1) > 0)
  ------------------
  |  Branch (9757:25): [True: 0, False: 0]
  ------------------
 9758|      0|                        nbNs++;
 9759|      0|		} else if (aprefix == ctxt->str_xmlns) {
  ------------------
  |  Branch (9759:14): [True: 0, False: 0]
  ------------------
 9760|      0|                    xmlParserEntityCheck(ctxt, attr->expandedSize);
 9761|       |
 9762|      0|                    if (xmlParserNsPush(ctxt, &attr->name, &attr->value,
  ------------------
  |  Branch (9762:25): [True: 0, False: 0]
  ------------------
 9763|      0|                                      NULL, 1) > 0)
 9764|      0|                        nbNs++;
 9765|      0|		} else {
 9766|      0|                    nbTotalDef += 1;
 9767|      0|                }
 9768|      0|	    }
 9769|      0|	}
 9770|      0|    }
 9771|       |
 9772|       |    /*
 9773|       |     * Resolve attribute namespaces
 9774|       |     */
 9775|  7.97k|    for (i = 0; i < nbatts; i += 5) {
  ------------------
  |  Branch (9775:17): [True: 4.23k, False: 3.74k]
  ------------------
 9776|  4.23k|        attname = atts[i];
 9777|  4.23k|        aprefix = atts[i+1];
 9778|       |
 9779|       |        /*
 9780|       |	* The default namespace does not apply to attribute names.
 9781|       |	*/
 9782|  4.23k|	if (aprefix == NULL) {
  ------------------
  |  Branch (9782:6): [True: 4.18k, False: 53]
  ------------------
 9783|  4.18k|            nsIndex = NS_INDEX_EMPTY;
  ------------------
  |  |   77|  4.18k|#define NS_INDEX_EMPTY  INT_MAX
  ------------------
 9784|  4.18k|        } else if (aprefix == ctxt->str_xml) {
  ------------------
  |  Branch (9784:20): [True: 28, False: 25]
  ------------------
 9785|     28|            nsIndex = NS_INDEX_XML;
  ------------------
  |  |   78|     28|#define NS_INDEX_XML    (INT_MAX - 1)
  ------------------
 9786|     28|        } else {
 9787|     25|            haprefix.name = aprefix;
 9788|     25|            haprefix.hashValue = (size_t) atts[i+2];
 9789|     25|            nsIndex = xmlParserNsLookup(ctxt, &haprefix, NULL);
 9790|     25|	    if (nsIndex == INT_MAX) {
  ------------------
  |  Branch (9790:10): [True: 0, False: 25]
  ------------------
 9791|      0|                xmlNsErr(ctxt, XML_NS_ERR_UNDEFINED_NAMESPACE,
 9792|      0|		    "Namespace prefix %s for %s on %s is not defined\n",
 9793|      0|		    aprefix, attname, localname);
 9794|      0|                nsIndex = NS_INDEX_EMPTY;
  ------------------
  |  |   77|      0|#define NS_INDEX_EMPTY  INT_MAX
  ------------------
 9795|      0|            }
 9796|     25|        }
 9797|       |
 9798|  4.23k|        atts[i+2] = (const xmlChar *) (ptrdiff_t) nsIndex;
 9799|  4.23k|    }
 9800|       |
 9801|       |    /*
 9802|       |     * Maximum number of attributes including default attributes.
 9803|       |     */
 9804|  3.74k|    maxAtts = nratts + nbTotalDef;
 9805|       |
 9806|       |    /*
 9807|       |     * Verify that attribute names are unique.
 9808|       |     */
 9809|  3.74k|    if (maxAtts > 1) {
  ------------------
  |  Branch (9809:9): [True: 1.08k, False: 2.66k]
  ------------------
 9810|  1.08k|        attrHashSize = 4;
 9811|  1.39k|        while (attrHashSize / 2 < (unsigned) maxAtts)
  ------------------
  |  Branch (9811:16): [True: 316, False: 1.08k]
  ------------------
 9812|    316|            attrHashSize *= 2;
 9813|       |
 9814|  1.08k|        if (attrHashSize > ctxt->attrHashMax) {
  ------------------
  |  Branch (9814:13): [True: 256, False: 825]
  ------------------
 9815|    256|            xmlAttrHashBucket *tmp;
 9816|       |
 9817|    256|            tmp = xmlRealloc(ctxt->attrHash, attrHashSize * sizeof(tmp[0]));
 9818|    256|            if (tmp == NULL) {
  ------------------
  |  Branch (9818:17): [True: 0, False: 256]
  ------------------
 9819|      0|                xmlErrMemory(ctxt, NULL);
 9820|      0|                goto done;
 9821|      0|            }
 9822|       |
 9823|    256|            ctxt->attrHash = tmp;
 9824|    256|            ctxt->attrHashMax = attrHashSize;
 9825|    256|        }
 9826|       |
 9827|  1.08k|        memset(ctxt->attrHash, -1, attrHashSize * sizeof(ctxt->attrHash[0]));
 9828|       |
 9829|  3.64k|        for (i = 0, j = 0; j < nratts; i += 5, j++) {
  ------------------
  |  Branch (9829:28): [True: 2.56k, False: 1.08k]
  ------------------
 9830|  2.56k|            const xmlChar *nsuri;
 9831|  2.56k|            unsigned hashValue, nameHashValue, uriHashValue;
 9832|  2.56k|            int res;
 9833|       |
 9834|  2.56k|            attname = atts[i];
 9835|  2.56k|            aprefix = atts[i+1];
 9836|  2.56k|            nsIndex = (ptrdiff_t) atts[i+2];
 9837|       |            /* Hash values always have bit 31 set, see dict.c */
 9838|  2.56k|            nameHashValue = ctxt->attallocs[j] | 0x80000000;
 9839|       |
 9840|  2.56k|            if (nsIndex == NS_INDEX_EMPTY) {
  ------------------
  |  |   77|  2.56k|#define NS_INDEX_EMPTY  INT_MAX
  ------------------
  |  Branch (9840:17): [True: 2.54k, False: 20]
  ------------------
 9841|  2.54k|                nsuri = NULL;
 9842|  2.54k|                uriHashValue = URI_HASH_EMPTY;
  ------------------
  |  |   79|  2.54k|#define URI_HASH_EMPTY  0xD943A04E
  ------------------
 9843|  2.54k|            } else if (nsIndex == NS_INDEX_XML) {
  ------------------
  |  |   78|     20|#define NS_INDEX_XML    (INT_MAX - 1)
  ------------------
  |  Branch (9843:24): [True: 15, False: 5]
  ------------------
 9844|     15|                nsuri = ctxt->str_xml_ns;
 9845|     15|                uriHashValue = URI_HASH_XML;
  ------------------
  |  |   80|     15|#define URI_HASH_XML    0xF0451F02
  ------------------
 9846|     15|            } else {
 9847|      5|                nsuri = ctxt->nsTab[nsIndex * 2 + 1];
 9848|      5|                uriHashValue = ctxt->nsdb->extra[nsIndex].uriHashValue;
 9849|      5|            }
 9850|       |
 9851|  2.56k|            hashValue = xmlDictCombineHash(nameHashValue, uriHashValue);
 9852|  2.56k|            res = xmlAttrHashInsert(ctxt, attrHashSize, attname, nsuri,
 9853|  2.56k|                                    hashValue, i);
 9854|  2.56k|            if (res < 0)
  ------------------
  |  Branch (9854:17): [True: 0, False: 2.56k]
  ------------------
 9855|      0|                continue;
 9856|       |
 9857|       |            /*
 9858|       |             * [ WFC: Unique Att Spec ]
 9859|       |             * No attribute name may appear more than once in the same
 9860|       |             * start-tag or empty-element tag.
 9861|       |             * As extended by the Namespace in XML REC.
 9862|       |             */
 9863|  2.56k|            if (res < INT_MAX) {
  ------------------
  |  Branch (9863:17): [True: 0, False: 2.56k]
  ------------------
 9864|      0|                if (aprefix == atts[res+1]) {
  ------------------
  |  Branch (9864:21): [True: 0, False: 0]
  ------------------
 9865|      0|                    xmlErrAttributeDup(ctxt, aprefix, attname);
 9866|      0|                } else {
 9867|      0|                    xmlNsErr(ctxt, XML_NS_ERR_ATTRIBUTE_REDEFINED,
 9868|      0|                             "Namespaced Attribute %s in '%s' redefined\n",
 9869|      0|                             attname, nsuri, NULL);
 9870|      0|                }
 9871|      0|            }
 9872|  2.56k|        }
 9873|  1.08k|    }
 9874|       |
 9875|       |    /*
 9876|       |     * Default attributes
 9877|       |     */
 9878|  3.74k|    if (ctxt->attsDefault != NULL) {
  ------------------
  |  Branch (9878:9): [True: 0, False: 3.74k]
  ------------------
 9879|      0|        xmlDefAttrsPtr defaults;
 9880|       |
 9881|      0|	defaults = xmlHashLookup2(ctxt->attsDefault, localname, prefix);
 9882|      0|	if (defaults != NULL) {
  ------------------
  |  Branch (9882:6): [True: 0, False: 0]
  ------------------
 9883|      0|	    for (i = 0; i < defaults->nbAttrs; i++) {
  ------------------
  |  Branch (9883:18): [True: 0, False: 0]
  ------------------
 9884|      0|                xmlDefAttr *attr = &defaults->attrs[i];
 9885|      0|                const xmlChar *nsuri;
 9886|      0|                unsigned hashValue, uriHashValue;
 9887|      0|                int res;
 9888|       |
 9889|      0|	        attname = attr->name.name;
 9890|      0|		aprefix = attr->prefix.name;
 9891|       |
 9892|      0|		if ((attname == ctxt->str_xmlns) && (aprefix == NULL))
  ------------------
  |  Branch (9892:7): [True: 0, False: 0]
  |  Branch (9892:39): [True: 0, False: 0]
  ------------------
 9893|      0|                    continue;
 9894|      0|		if (aprefix == ctxt->str_xmlns)
  ------------------
  |  Branch (9894:7): [True: 0, False: 0]
  ------------------
 9895|      0|                    continue;
 9896|       |
 9897|      0|                if (aprefix == NULL) {
  ------------------
  |  Branch (9897:21): [True: 0, False: 0]
  ------------------
 9898|      0|                    nsIndex = NS_INDEX_EMPTY;
  ------------------
  |  |   77|      0|#define NS_INDEX_EMPTY  INT_MAX
  ------------------
 9899|      0|                    nsuri = NULL;
 9900|      0|                    uriHashValue = URI_HASH_EMPTY;
  ------------------
  |  |   79|      0|#define URI_HASH_EMPTY  0xD943A04E
  ------------------
 9901|      0|                } if (aprefix == ctxt->str_xml) {
  ------------------
  |  Branch (9901:23): [True: 0, False: 0]
  ------------------
 9902|      0|                    nsIndex = NS_INDEX_XML;
  ------------------
  |  |   78|      0|#define NS_INDEX_XML    (INT_MAX - 1)
  ------------------
 9903|      0|                    nsuri = ctxt->str_xml_ns;
 9904|      0|                    uriHashValue = URI_HASH_XML;
  ------------------
  |  |   80|      0|#define URI_HASH_XML    0xF0451F02
  ------------------
 9905|      0|                } else if (aprefix != NULL) {
  ------------------
  |  Branch (9905:28): [True: 0, False: 0]
  ------------------
 9906|      0|                    nsIndex = xmlParserNsLookup(ctxt, &attr->prefix, NULL);
 9907|      0|                    if (nsIndex == INT_MAX) {
  ------------------
  |  Branch (9907:25): [True: 0, False: 0]
  ------------------
 9908|      0|                        xmlNsErr(ctxt, XML_NS_ERR_UNDEFINED_NAMESPACE,
 9909|      0|                                 "Namespace prefix %s for %s on %s is not "
 9910|      0|                                 "defined\n",
 9911|      0|                                 aprefix, attname, localname);
 9912|      0|                        nsIndex = NS_INDEX_EMPTY;
  ------------------
  |  |   77|      0|#define NS_INDEX_EMPTY  INT_MAX
  ------------------
 9913|      0|                        nsuri = NULL;
 9914|      0|                        uriHashValue = URI_HASH_EMPTY;
  ------------------
  |  |   79|      0|#define URI_HASH_EMPTY  0xD943A04E
  ------------------
 9915|      0|                    } else {
 9916|      0|                        nsuri = ctxt->nsTab[nsIndex * 2 + 1];
 9917|      0|                        uriHashValue = ctxt->nsdb->extra[nsIndex].uriHashValue;
 9918|      0|                    }
 9919|      0|                }
 9920|       |
 9921|       |                /*
 9922|       |                 * Check whether the attribute exists
 9923|       |                 */
 9924|      0|                if (maxAtts > 1) {
  ------------------
  |  Branch (9924:21): [True: 0, False: 0]
  ------------------
 9925|      0|                    hashValue = xmlDictCombineHash(attr->name.hashValue,
 9926|      0|                                                   uriHashValue);
 9927|      0|                    res = xmlAttrHashInsert(ctxt, attrHashSize, attname, nsuri,
 9928|      0|                                            hashValue, nbatts);
 9929|      0|                    if (res < 0)
  ------------------
  |  Branch (9929:25): [True: 0, False: 0]
  ------------------
 9930|      0|                        continue;
 9931|      0|                    if (res < INT_MAX) {
  ------------------
  |  Branch (9931:25): [True: 0, False: 0]
  ------------------
 9932|      0|                        if (aprefix == atts[res+1])
  ------------------
  |  Branch (9932:29): [True: 0, False: 0]
  ------------------
 9933|      0|                            continue;
 9934|      0|                        xmlNsErr(ctxt, XML_NS_ERR_ATTRIBUTE_REDEFINED,
 9935|      0|                                 "Namespaced Attribute %s in '%s' redefined\n",
 9936|      0|                                 attname, nsuri, NULL);
 9937|      0|                    }
 9938|      0|                }
 9939|       |
 9940|      0|                xmlParserEntityCheck(ctxt, attr->expandedSize);
 9941|       |
 9942|      0|                if ((atts == NULL) || (nbatts + 5 > maxatts)) {
  ------------------
  |  Branch (9942:21): [True: 0, False: 0]
  |  Branch (9942:39): [True: 0, False: 0]
  ------------------
 9943|      0|                    if (xmlCtxtGrowAttrs(ctxt, nbatts + 5) < 0) {
  ------------------
  |  Branch (9943:25): [True: 0, False: 0]
  ------------------
 9944|      0|                        localname = NULL;
 9945|      0|                        goto done;
 9946|      0|                    }
 9947|      0|                    maxatts = ctxt->maxatts;
 9948|      0|                    atts = ctxt->atts;
 9949|      0|                }
 9950|       |
 9951|      0|                atts[nbatts++] = attname;
 9952|      0|                atts[nbatts++] = aprefix;
 9953|      0|                atts[nbatts++] = (const xmlChar *) (ptrdiff_t) nsIndex;
 9954|      0|                atts[nbatts++] = attr->value.name;
 9955|      0|                atts[nbatts++] = attr->valueEnd;
 9956|      0|                if ((ctxt->standalone == 1) && (attr->external != 0)) {
  ------------------
  |  Branch (9956:21): [True: 0, False: 0]
  |  Branch (9956:48): [True: 0, False: 0]
  ------------------
 9957|      0|                    xmlValidityError(ctxt, XML_DTD_STANDALONE_DEFAULTED,
 9958|      0|                            "standalone: attribute %s on %s defaulted "
 9959|      0|                            "from external subset\n",
 9960|      0|                            attname, localname);
 9961|      0|                }
 9962|      0|                nbdef++;
 9963|      0|	    }
 9964|      0|	}
 9965|      0|    }
 9966|       |
 9967|       |    /*
 9968|       |     * Reconstruct attribute pointers
 9969|       |     */
 9970|  7.97k|    for (i = 0, j = 0; i < nbatts; i += 5, j++) {
  ------------------
  |  Branch (9970:24): [True: 4.23k, False: 3.74k]
  ------------------
 9971|       |        /* namespace URI */
 9972|  4.23k|        nsIndex = (ptrdiff_t) atts[i+2];
 9973|  4.23k|        if (nsIndex == INT_MAX)
  ------------------
  |  Branch (9973:13): [True: 4.18k, False: 53]
  ------------------
 9974|  4.18k|            atts[i+2] = NULL;
 9975|     53|        else if (nsIndex == INT_MAX - 1)
  ------------------
  |  Branch (9975:18): [True: 28, False: 25]
  ------------------
 9976|     28|            atts[i+2] = ctxt->str_xml_ns;
 9977|     25|        else
 9978|     25|            atts[i+2] = ctxt->nsTab[nsIndex * 2 + 1];
 9979|       |
 9980|  4.23k|        if ((j < nratts) && (ctxt->attallocs[j] & 0x80000000) == 0) {
  ------------------
  |  Branch (9980:13): [True: 4.23k, False: 0]
  |  Branch (9980:29): [True: 4.22k, False: 5]
  ------------------
 9981|  4.22k|            atts[i+3] = BASE_PTR + (ptrdiff_t) atts[i+3];  /* value */
  ------------------
  |  | 2225|  4.22k|#define BASE_PTR ctxt->input->base
  ------------------
 9982|  4.22k|            atts[i+4] = BASE_PTR + (ptrdiff_t) atts[i+4];  /* valuend */
  ------------------
  |  | 2225|  4.22k|#define BASE_PTR ctxt->input->base
  ------------------
 9983|  4.22k|        }
 9984|  4.23k|    }
 9985|       |
 9986|  3.74k|    uri = xmlParserNsLookupUri(ctxt, &hprefix);
 9987|  3.74k|    if ((prefix != NULL) && (uri == NULL)) {
  ------------------
  |  Branch (9987:9): [True: 3.47k, False: 265]
  |  Branch (9987:29): [True: 3, False: 3.47k]
  ------------------
 9988|      3|	xmlNsErr(ctxt, XML_NS_ERR_UNDEFINED_NAMESPACE,
 9989|      3|	         "Namespace prefix %s on %s is not defined\n",
 9990|      3|		 prefix, localname, NULL);
 9991|      3|    }
 9992|  3.74k|    *pref = prefix;
 9993|  3.74k|    *URI = uri;
 9994|       |
 9995|       |    /*
 9996|       |     * SAX callback
 9997|       |     */
 9998|  3.74k|    if ((ctxt->sax != NULL) && (ctxt->sax->startElementNs != NULL) &&
  ------------------
  |  Branch (9998:9): [True: 3.74k, False: 0]
  |  Branch (9998:32): [True: 3.74k, False: 0]
  ------------------
 9999|  3.74k|	(!ctxt->disableSAX)) {
  ------------------
  |  Branch (9999:2): [True: 3.54k, False: 202]
  ------------------
10000|  3.54k|	if (nbNs > 0)
  ------------------
  |  Branch (10000:6): [True: 233, False: 3.30k]
  ------------------
10001|    233|	    ctxt->sax->startElementNs(ctxt->userData, localname, prefix, uri,
10002|    233|                          nbNs, ctxt->nsTab + 2 * (ctxt->nsNr - nbNs),
10003|    233|			  nbatts / 5, nbdef, atts);
10004|  3.30k|	else
10005|  3.30k|	    ctxt->sax->startElementNs(ctxt->userData, localname, prefix, uri,
10006|  3.30k|                          0, NULL, nbatts / 5, nbdef, atts);
10007|  3.54k|    }
10008|       |
10009|  3.74k|done:
10010|       |    /*
10011|       |     * Free allocated attribute values
10012|       |     */
10013|  3.74k|    if (attval != 0) {
  ------------------
  |  Branch (10013:9): [True: 5, False: 3.73k]
  ------------------
10014|     10|	for (i = 0, j = 0; j < nratts; i += 5, j++)
  ------------------
  |  Branch (10014:21): [True: 5, False: 5]
  ------------------
10015|      5|	    if (ctxt->attallocs[j] & 0x80000000)
  ------------------
  |  Branch (10015:10): [True: 5, False: 0]
  ------------------
10016|      5|	        xmlFree((xmlChar *) atts[i+3]);
10017|      5|    }
10018|       |
10019|  3.74k|    *nbNsPtr = nbNs;
10020|  3.74k|    return(localname);
10021|  3.74k|}
parser.c:xmlParserNsStartElement:
 1462|  3.74k|xmlParserNsStartElement(xmlParserNsData *nsdb) {
 1463|  3.74k|    if (nsdb->elementId == UINT_MAX)
  ------------------
  |  Branch (1463:9): [True: 0, False: 3.74k]
  ------------------
 1464|      0|        return(-1);
 1465|  3.74k|    nsdb->elementId++;
 1466|       |
 1467|  3.74k|    return(0);
 1468|  3.74k|}
parser.c:xmlParseQNameHashed:
 8943|  8.40k|xmlParseQNameHashed(xmlParserCtxtPtr ctxt, xmlHashedString *prefix) {
 8944|  8.40k|    xmlHashedString l, p;
 8945|  8.40k|    int start;
 8946|       |
 8947|  8.40k|    l.name = NULL;
 8948|  8.40k|    p.name = NULL;
 8949|       |
 8950|  8.40k|    GROW;
  ------------------
  |  | 2270|  8.40k|#define GROW if (ctxt->input->end - ctxt->input->cur < INPUT_CHUNK)	\
  |  |  ------------------
  |  |  |  |   97|  8.40k|#define INPUT_CHUNK	250
  |  |  ------------------
  |  |  |  Branch (2270:18): [True: 1.82k, False: 6.57k]
  |  |  ------------------
  |  | 2271|  8.40k|	xmlParserGrow(ctxt);
  ------------------
 8951|  8.40k|    if (ctxt->instate == XML_PARSER_EOF)
  ------------------
  |  Branch (8951:9): [True: 0, False: 8.40k]
  ------------------
 8952|      0|        return(l);
 8953|  8.40k|    start = CUR_PTR - BASE_PTR;
  ------------------
  |  | 2224|  8.40k|#define CUR_PTR ctxt->input->cur
  ------------------
                  start = CUR_PTR - BASE_PTR;
  ------------------
  |  | 2225|  8.40k|#define BASE_PTR ctxt->input->base
  ------------------
 8954|       |
 8955|  8.40k|    l = xmlParseNCName(ctxt);
 8956|  8.40k|    if ((l.name != NULL) && (CUR == ':')) {
  ------------------
  |  | 2222|  8.39k|#define CUR (*ctxt->input->cur)
  ------------------
  |  Branch (8956:9): [True: 8.39k, False: 7]
  |  Branch (8956:29): [True: 3.87k, False: 4.51k]
  ------------------
 8957|  3.87k|        NEXT;
  ------------------
  |  | 2275|  3.87k|#define NEXT xmlNextChar(ctxt)
  ------------------
 8958|  3.87k|	p = l;
 8959|  3.87k|	l = xmlParseNCName(ctxt);
 8960|  3.87k|    }
 8961|  8.40k|    if ((l.name == NULL) || (CUR == ':')) {
  ------------------
  |  | 2222|  8.39k|#define CUR (*ctxt->input->cur)
  ------------------
  |  Branch (8961:9): [True: 7, False: 8.39k]
  |  Branch (8961:29): [True: 0, False: 8.39k]
  ------------------
 8962|      7|        xmlChar *tmp;
 8963|       |
 8964|      7|        l.name = NULL;
 8965|      7|        p.name = NULL;
 8966|      7|        if (ctxt->instate == XML_PARSER_EOF)
  ------------------
  |  Branch (8966:13): [True: 0, False: 7]
  ------------------
 8967|      0|            return(l);
 8968|      7|        if ((CUR != ':') && (CUR_PTR <= BASE_PTR + start))
  ------------------
  |  | 2222|      7|#define CUR (*ctxt->input->cur)
  ------------------
                      if ((CUR != ':') && (CUR_PTR <= BASE_PTR + start))
  ------------------
  |  | 2224|      7|#define CUR_PTR ctxt->input->cur
  ------------------
                      if ((CUR != ':') && (CUR_PTR <= BASE_PTR + start))
  ------------------
  |  | 2225|      7|#define BASE_PTR ctxt->input->base
  ------------------
  |  Branch (8968:13): [True: 7, False: 0]
  |  Branch (8968:29): [True: 7, False: 0]
  ------------------
 8969|      7|            return(l);
 8970|      0|        tmp = xmlParseNmtoken(ctxt);
 8971|      0|        if (tmp != NULL)
  ------------------
  |  Branch (8971:13): [True: 0, False: 0]
  ------------------
 8972|      0|            xmlFree(tmp);
 8973|      0|        if (ctxt->instate == XML_PARSER_EOF)
  ------------------
  |  Branch (8973:13): [True: 0, False: 0]
  ------------------
 8974|      0|            return(l);
 8975|      0|        l = xmlDictLookupHashed(ctxt->dict, BASE_PTR + start,
  ------------------
  |  | 2225|      0|#define BASE_PTR ctxt->input->base
  ------------------
 8976|      0|                                CUR_PTR - (BASE_PTR + start));
  ------------------
  |  | 2224|      0|#define CUR_PTR ctxt->input->cur
  ------------------
                                              CUR_PTR - (BASE_PTR + start));
  ------------------
  |  | 2225|      0|#define BASE_PTR ctxt->input->base
  ------------------
 8977|      0|        xmlNsErr(ctxt, XML_NS_ERR_QNAME,
 8978|      0|                 "Failed to parse QName '%s'\n", l.name, NULL, NULL);
 8979|      0|    }
 8980|       |
 8981|  8.39k|    *prefix = p;
 8982|  8.39k|    return(l);
 8983|  8.40k|}
parser.c:xmlParseNCName:
 3624|  12.2k|xmlParseNCName(xmlParserCtxtPtr ctxt) {
 3625|  12.2k|    const xmlChar *in, *e;
 3626|  12.2k|    xmlHashedString ret;
 3627|  12.2k|    size_t count = 0;
 3628|  12.2k|    size_t maxLength = (ctxt->options & XML_PARSE_HUGE) ?
  ------------------
  |  Branch (3628:24): [True: 0, False: 12.2k]
  ------------------
 3629|      0|                       XML_MAX_TEXT_LENGTH :
  ------------------
  |  |   42|      0|#define XML_MAX_TEXT_LENGTH 10000000
  ------------------
 3630|  12.2k|                       XML_MAX_NAME_LENGTH;
  ------------------
  |  |   61|  24.5k|#define XML_MAX_NAME_LENGTH 50000
  ------------------
 3631|       |
 3632|  12.2k|    ret.name = NULL;
 3633|       |
 3634|       |    /*
 3635|       |     * Accelerator for simple ASCII names
 3636|       |     */
 3637|  12.2k|    in = ctxt->input->cur;
 3638|  12.2k|    e = ctxt->input->end;
 3639|  12.2k|    if ((((*in >= 0x61) && (*in <= 0x7A)) ||
  ------------------
  |  Branch (3639:11): [True: 12.2k, False: 18]
  |  Branch (3639:28): [True: 12.2k, False: 0]
  ------------------
 3640|  12.2k|	 ((*in >= 0x41) && (*in <= 0x5A)) ||
  ------------------
  |  Branch (3640:4): [True: 11, False: 7]
  |  Branch (3640:21): [True: 11, False: 0]
  ------------------
 3641|  12.2k|	 (*in == '_')) && (in < e)) {
  ------------------
  |  Branch (3641:3): [True: 0, False: 7]
  |  Branch (3641:20): [True: 12.2k, False: 0]
  ------------------
 3642|  12.2k|	in++;
 3643|  71.4k|	while ((((*in >= 0x61) && (*in <= 0x7A)) ||
  ------------------
  |  Branch (3643:11): [True: 57.0k, False: 14.4k]
  |  Branch (3643:28): [True: 57.0k, False: 2]
  ------------------
 3644|  71.4k|	        ((*in >= 0x41) && (*in <= 0x5A)) ||
  ------------------
  |  Branch (3644:11): [True: 2.17k, False: 12.2k]
  |  Branch (3644:28): [True: 2.17k, False: 2]
  ------------------
 3645|  71.4k|	        ((*in >= 0x30) && (*in <= 0x39)) ||
  ------------------
  |  Branch (3645:11): [True: 9.43k, False: 2.85k]
  |  Branch (3645:28): [True: 10, False: 9.42k]
  ------------------
 3646|  71.4k|	        (*in == '_') || (*in == '-') ||
  ------------------
  |  Branch (3646:10): [True: 0, False: 12.2k]
  |  Branch (3646:26): [True: 0, False: 12.2k]
  ------------------
 3647|  71.4k|	        (*in == '.')) && (in < e))
  ------------------
  |  Branch (3647:10): [True: 0, False: 12.2k]
  |  Branch (3647:27): [True: 59.1k, False: 0]
  ------------------
 3648|  59.1k|	    in++;
 3649|  12.2k|	if (in >= e)
  ------------------
  |  Branch (3649:6): [True: 0, False: 12.2k]
  ------------------
 3650|      0|	    goto complex;
 3651|  12.2k|	if ((*in > 0) && (*in < 0x80)) {
  ------------------
  |  Branch (3651:6): [True: 12.2k, False: 0]
  |  Branch (3651:19): [True: 12.2k, False: 2]
  ------------------
 3652|  12.2k|	    count = in - ctxt->input->cur;
 3653|  12.2k|            if (count > maxLength) {
  ------------------
  |  Branch (3653:17): [True: 0, False: 12.2k]
  ------------------
 3654|      0|                xmlFatalErr(ctxt, XML_ERR_NAME_TOO_LONG, "NCName");
 3655|      0|                return(ret);
 3656|      0|            }
 3657|  12.2k|	    ret = xmlDictLookupHashed(ctxt->dict, ctxt->input->cur, count);
 3658|  12.2k|	    ctxt->input->cur = in;
 3659|  12.2k|	    ctxt->input->col += count;
 3660|  12.2k|	    if (ret.name == NULL) {
  ------------------
  |  Branch (3660:10): [True: 0, False: 12.2k]
  ------------------
 3661|      0|	        xmlErrMemory(ctxt, NULL);
 3662|      0|	    }
 3663|  12.2k|	    return(ret);
 3664|  12.2k|	}
 3665|  12.2k|    }
 3666|      9|complex:
 3667|      9|    return(xmlParseNCNameComplex(ctxt));
 3668|  12.2k|}
parser.c:xmlParseNCNameComplex:
 3569|      9|xmlParseNCNameComplex(xmlParserCtxtPtr ctxt) {
 3570|      9|    xmlHashedString ret;
 3571|      9|    int len = 0, l;
 3572|      9|    int c;
 3573|      9|    int maxLength = (ctxt->options & XML_PARSE_HUGE) ?
  ------------------
  |  Branch (3573:21): [True: 0, False: 9]
  ------------------
 3574|      0|                    XML_MAX_TEXT_LENGTH :
  ------------------
  |  |   42|      0|#define XML_MAX_TEXT_LENGTH 10000000
  ------------------
 3575|      9|                    XML_MAX_NAME_LENGTH;
  ------------------
  |  |   61|      9|#define XML_MAX_NAME_LENGTH 50000
  ------------------
 3576|      9|    size_t startPosition = 0;
 3577|       |
 3578|      9|    ret.name = NULL;
 3579|      9|    ret.hashValue = 0;
 3580|       |
 3581|       |    /*
 3582|       |     * Handler for more complex cases
 3583|       |     */
 3584|      9|    startPosition = CUR_PTR - BASE_PTR;
  ------------------
  |  | 2224|      9|#define CUR_PTR ctxt->input->cur
  ------------------
                  startPosition = CUR_PTR - BASE_PTR;
  ------------------
  |  | 2225|      9|#define BASE_PTR ctxt->input->base
  ------------------
 3585|      9|    c = CUR_CHAR(l);
  ------------------
  |  | 2291|      9|#define CUR_CHAR(l) xmlCurrentChar(ctxt, &l)
  ------------------
 3586|      9|    if ((c == ' ') || (c == '>') || (c == '/') || /* accelerators */
  ------------------
  |  Branch (3586:9): [True: 1, False: 8]
  |  Branch (3586:23): [True: 0, False: 8]
  |  Branch (3586:37): [True: 0, False: 8]
  ------------------
 3587|      9|	(!xmlIsNameStartChar(ctxt, c) || (c == ':'))) {
  ------------------
  |  Branch (3587:3): [True: 6, False: 2]
  |  Branch (3587:35): [True: 0, False: 2]
  ------------------
 3588|      7|	return(ret);
 3589|      7|    }
 3590|       |
 3591|     24|    while ((c != ' ') && (c != '>') && (c != '/') && /* test bigname.xml */
  ------------------
  |  Branch (3591:12): [True: 24, False: 0]
  |  Branch (3591:26): [True: 23, False: 1]
  |  Branch (3591:40): [True: 23, False: 0]
  ------------------
 3592|     24|	   (xmlIsNameChar(ctxt, c) && (c != ':'))) {
  ------------------
  |  Branch (3592:6): [True: 22, False: 1]
  |  Branch (3592:32): [True: 22, False: 0]
  ------------------
 3593|     22|        if (len <= INT_MAX - l)
  ------------------
  |  Branch (3593:13): [True: 22, False: 0]
  ------------------
 3594|     22|	    len += l;
 3595|     22|	NEXTL(l);
  ------------------
  |  | 2284|     22|#define NEXTL(l) do {							\
  |  | 2285|     22|    if (*(ctxt->input->cur) == '\n') {					\
  |  |  ------------------
  |  |  |  Branch (2285:9): [True: 0, False: 22]
  |  |  ------------------
  |  | 2286|      0|	ctxt->input->line++; ctxt->input->col = 1;			\
  |  | 2287|     22|    } else ctxt->input->col++;						\
  |  | 2288|     22|    ctxt->input->cur += l;				\
  |  | 2289|     22|  } while (0)
  |  |  ------------------
  |  |  |  Branch (2289:12): [Folded - Ignored]
  |  |  ------------------
  ------------------
 3596|     22|	c = CUR_CHAR(l);
  ------------------
  |  | 2291|     22|#define CUR_CHAR(l) xmlCurrentChar(ctxt, &l)
  ------------------
 3597|     22|    }
 3598|      2|    if (ctxt->instate == XML_PARSER_EOF)
  ------------------
  |  Branch (3598:9): [True: 0, False: 2]
  ------------------
 3599|      0|        return(ret);
 3600|      2|    if (len > maxLength) {
  ------------------
  |  Branch (3600:9): [True: 0, False: 2]
  ------------------
 3601|      0|        xmlFatalErr(ctxt, XML_ERR_NAME_TOO_LONG, "NCName");
 3602|      0|        return(ret);
 3603|      0|    }
 3604|      2|    ret = xmlDictLookupHashed(ctxt->dict, (BASE_PTR + startPosition), len);
  ------------------
  |  | 2225|      2|#define BASE_PTR ctxt->input->base
  ------------------
 3605|      2|    return(ret);
 3606|      2|}
parser.c:xmlParseAttribute2:
 9282|  4.63k|{
 9283|  4.63k|    xmlHashedString hname;
 9284|  4.63k|    const xmlChar *prefix, *name;
 9285|  4.63k|    xmlChar *val, *internal_val = NULL;
 9286|  4.63k|    int normalize = 0;
 9287|       |
 9288|  4.63k|    *value = NULL;
 9289|  4.63k|    GROW;
  ------------------
  |  | 2270|  4.63k|#define GROW if (ctxt->input->end - ctxt->input->cur < INPUT_CHUNK)	\
  |  |  ------------------
  |  |  |  |   97|  4.63k|#define INPUT_CHUNK	250
  |  |  ------------------
  |  |  |  Branch (2270:18): [True: 1.04k, False: 3.58k]
  |  |  ------------------
  |  | 2271|  4.63k|	xmlParserGrow(ctxt);
  ------------------
 9290|  4.63k|    hname = xmlParseQNameHashed(ctxt, hprefix);
 9291|  4.63k|    if (hname.name == NULL) {
  ------------------
  |  Branch (9291:9): [True: 6, False: 4.62k]
  ------------------
 9292|      6|        xmlFatalErrMsg(ctxt, XML_ERR_NAME_REQUIRED,
 9293|      6|                       "error parsing attribute name\n");
 9294|      6|        return(hname);
 9295|      6|    }
 9296|  4.62k|    name = hname.name;
 9297|  4.62k|    if (hprefix->name != NULL)
  ------------------
  |  Branch (9297:9): [True: 370, False: 4.25k]
  ------------------
 9298|    370|        prefix = hprefix->name;
 9299|  4.25k|    else
 9300|  4.25k|        prefix = NULL;
 9301|       |
 9302|       |    /*
 9303|       |     * get the type if needed
 9304|       |     */
 9305|  4.62k|    if (ctxt->attsSpecial != NULL) {
  ------------------
  |  Branch (9305:9): [True: 0, False: 4.62k]
  ------------------
 9306|      0|        int type;
 9307|       |
 9308|      0|        type = (int) (ptrdiff_t) xmlHashQLookup2(ctxt->attsSpecial,
 9309|      0|                                                 pref, elem,
 9310|      0|                                                 prefix, name);
 9311|      0|        if (type != 0)
  ------------------
  |  Branch (9311:13): [True: 0, False: 0]
  ------------------
 9312|      0|            normalize = 1;
 9313|      0|    }
 9314|       |
 9315|       |    /*
 9316|       |     * read the value
 9317|       |     */
 9318|  4.62k|    SKIP_BLANKS;
  ------------------
  |  | 2273|  4.62k|#define SKIP_BLANKS xmlSkipBlankChars(ctxt)
  ------------------
 9319|  4.62k|    if (RAW == '=') {
  ------------------
  |  | 2221|  4.62k|#define RAW (*ctxt->input->cur)
  ------------------
  |  Branch (9319:9): [True: 4.62k, False: 2]
  ------------------
 9320|  4.62k|        NEXT;
  ------------------
  |  | 2275|  4.62k|#define NEXT xmlNextChar(ctxt)
  ------------------
 9321|  4.62k|        SKIP_BLANKS;
  ------------------
  |  | 2273|  4.62k|#define SKIP_BLANKS xmlSkipBlankChars(ctxt)
  ------------------
 9322|  4.62k|        val = xmlParseAttValueInternal(ctxt, len, alloc, normalize);
 9323|  4.62k|        if (val == NULL) {
  ------------------
  |  Branch (9323:13): [True: 0, False: 4.62k]
  ------------------
 9324|      0|            hname.name = NULL;
 9325|      0|            return(hname);
 9326|      0|        }
 9327|  4.62k|	if (normalize) {
  ------------------
  |  Branch (9327:6): [True: 0, False: 4.62k]
  ------------------
 9328|       |	    /*
 9329|       |	     * Sometimes a second normalisation pass for spaces is needed
 9330|       |	     * but that only happens if charrefs or entities references
 9331|       |	     * have been used in the attribute value, i.e. the attribute
 9332|       |	     * value have been extracted in an allocated string already.
 9333|       |	     */
 9334|      0|	    if (*alloc) {
  ------------------
  |  Branch (9334:10): [True: 0, False: 0]
  ------------------
 9335|      0|	        const xmlChar *val2;
 9336|       |
 9337|      0|	        val2 = xmlAttrNormalizeSpace2(ctxt, val, len);
 9338|      0|		if ((val2 != NULL) && (val2 != val)) {
  ------------------
  |  Branch (9338:7): [True: 0, False: 0]
  |  Branch (9338:25): [True: 0, False: 0]
  ------------------
 9339|      0|		    xmlFree(val);
 9340|      0|		    val = (xmlChar *) val2;
 9341|      0|		}
 9342|      0|	    }
 9343|      0|	}
 9344|  4.62k|        ctxt->instate = XML_PARSER_CONTENT;
 9345|  4.62k|    } else {
 9346|      2|        xmlFatalErrMsgStr(ctxt, XML_ERR_ATTRIBUTE_WITHOUT_VALUE,
 9347|      2|                          "Specification mandates value for attribute %s\n",
 9348|      2|                          name);
 9349|      2|        return(hname);
 9350|      2|    }
 9351|       |
 9352|  4.62k|    if (prefix == ctxt->str_xml) {
  ------------------
  |  Branch (9352:9): [True: 28, False: 4.59k]
  ------------------
 9353|       |        /*
 9354|       |         * Check that xml:lang conforms to the specification
 9355|       |         * No more registered as an error, just generate a warning now
 9356|       |         * since this was deprecated in XML second edition
 9357|       |         */
 9358|     28|        if ((ctxt->pedantic) && (xmlStrEqual(name, BAD_CAST "lang"))) {
  ------------------
  |  |   35|      0|#define BAD_CAST (xmlChar *)
  ------------------
  |  Branch (9358:13): [True: 0, False: 28]
  |  Branch (9358:33): [True: 0, False: 0]
  ------------------
 9359|      0|            internal_val = xmlStrndup(val, *len);
 9360|      0|            if (!xmlCheckLanguageID(internal_val)) {
  ------------------
  |  Branch (9360:17): [True: 0, False: 0]
  ------------------
 9361|      0|                xmlWarningMsg(ctxt, XML_WAR_LANG_VALUE,
 9362|      0|                              "Malformed value for xml:lang : %s\n",
 9363|      0|                              internal_val, NULL);
 9364|      0|            }
 9365|      0|        }
 9366|       |
 9367|       |        /*
 9368|       |         * Check that xml:space conforms to the specification
 9369|       |         */
 9370|     28|        if (xmlStrEqual(name, BAD_CAST "space")) {
  ------------------
  |  |   35|     28|#define BAD_CAST (xmlChar *)
  ------------------
  |  Branch (9370:13): [True: 0, False: 28]
  ------------------
 9371|      0|            internal_val = xmlStrndup(val, *len);
 9372|      0|            if (xmlStrEqual(internal_val, BAD_CAST "default"))
  ------------------
  |  |   35|      0|#define BAD_CAST (xmlChar *)
  ------------------
  |  Branch (9372:17): [True: 0, False: 0]
  ------------------
 9373|      0|                *(ctxt->space) = 0;
 9374|      0|            else if (xmlStrEqual(internal_val, BAD_CAST "preserve"))
  ------------------
  |  |   35|      0|#define BAD_CAST (xmlChar *)
  ------------------
  |  Branch (9374:22): [True: 0, False: 0]
  ------------------
 9375|      0|                *(ctxt->space) = 1;
 9376|      0|            else {
 9377|      0|                xmlWarningMsg(ctxt, XML_WAR_SPACE_VALUE,
 9378|      0|                              "Invalid value \"%s\" for xml:space : \"default\" or \"preserve\" expected\n",
 9379|      0|                              internal_val, NULL);
 9380|      0|            }
 9381|      0|        }
 9382|     28|        if (internal_val) {
  ------------------
  |  Branch (9382:13): [True: 0, False: 28]
  ------------------
 9383|      0|            xmlFree(internal_val);
 9384|      0|        }
 9385|     28|    }
 9386|       |
 9387|  4.62k|    *value = val;
 9388|  4.62k|    return (hname);
 9389|  4.62k|}
parser.c:xmlCtxtGrowAttrs:
 1853|    234|xmlCtxtGrowAttrs(xmlParserCtxtPtr ctxt, int nr) {
 1854|    234|    const xmlChar **atts;
 1855|    234|    unsigned *attallocs;
 1856|    234|    int maxatts;
 1857|       |
 1858|    234|    if (nr + 5 > ctxt->maxatts) {
  ------------------
  |  Branch (1858:9): [True: 234, False: 0]
  ------------------
 1859|    234|	maxatts = ctxt->maxatts == 0 ? 55 : (nr + 5) * 2;
  ------------------
  |  Branch (1859:12): [True: 233, False: 1]
  ------------------
 1860|    234|	atts = (const xmlChar **) xmlMalloc(
 1861|    234|				     maxatts * sizeof(const xmlChar *));
 1862|    234|	if (atts == NULL) goto mem_error;
  ------------------
  |  Branch (1862:6): [True: 0, False: 234]
  ------------------
 1863|    234|	attallocs = xmlRealloc(ctxt->attallocs,
 1864|    234|                               (maxatts / 5) * sizeof(attallocs[0]));
 1865|    234|	if (attallocs == NULL) {
  ------------------
  |  Branch (1865:6): [True: 0, False: 234]
  ------------------
 1866|      0|            xmlFree(atts);
 1867|      0|            goto mem_error;
 1868|      0|        }
 1869|    234|        if (ctxt->maxatts > 0)
  ------------------
  |  Branch (1869:13): [True: 1, False: 233]
  ------------------
 1870|      1|            memcpy(atts, ctxt->atts, ctxt->maxatts * sizeof(const xmlChar *));
 1871|    234|        xmlFree(ctxt->atts);
 1872|    234|	ctxt->atts = atts;
 1873|    234|	ctxt->attallocs = attallocs;
 1874|    234|	ctxt->maxatts = maxatts;
 1875|    234|    }
 1876|    234|    return(ctxt->maxatts);
 1877|      0|mem_error:
 1878|      0|    xmlErrMemory(ctxt, NULL);
 1879|      0|    return(-1);
 1880|    234|}
parser.c:xmlAttrHashInsert:
 9407|  2.56k|                  const xmlChar *uri, unsigned hashValue, int aindex) {
 9408|  2.56k|    xmlAttrHashBucket *table = ctxt->attrHash;
 9409|  2.56k|    xmlAttrHashBucket *bucket;
 9410|  2.56k|    unsigned hindex;
 9411|       |
 9412|  2.56k|    hindex = hashValue & (size - 1);
 9413|  2.56k|    bucket = &table[hindex];
 9414|       |
 9415|  3.06k|    while (bucket->index >= 0) {
  ------------------
  |  Branch (9415:12): [True: 508, False: 2.56k]
  ------------------
 9416|    508|        const xmlChar **atts = &ctxt->atts[bucket->index];
 9417|       |
 9418|    508|        if (name == atts[0]) {
  ------------------
  |  Branch (9418:13): [True: 0, False: 508]
  ------------------
 9419|      0|            int nsIndex = (int) (ptrdiff_t) atts[2];
 9420|       |
 9421|      0|            if ((nsIndex == NS_INDEX_EMPTY) ? (uri == NULL) :
  ------------------
  |  |   77|      0|#define NS_INDEX_EMPTY  INT_MAX
  ------------------
  |  Branch (9421:17): [True: 0, False: 0]
  |  Branch (9421:17): [True: 0, False: 0]
  ------------------
 9422|      0|                (nsIndex == NS_INDEX_XML) ? (uri == ctxt->str_xml) :
  ------------------
  |  |   78|      0|#define NS_INDEX_XML    (INT_MAX - 1)
  ------------------
  |  Branch (9422:17): [True: 0, False: 0]
  ------------------
 9423|      0|                (uri == ctxt->nsTab[nsIndex * 2 + 1]))
 9424|      0|                return(bucket->index);
 9425|      0|        }
 9426|       |
 9427|    508|        hindex++;
 9428|    508|        bucket++;
 9429|    508|        if (hindex >= size) {
  ------------------
  |  Branch (9429:13): [True: 128, False: 380]
  ------------------
 9430|    128|            hindex = 0;
 9431|    128|            bucket = table;
 9432|    128|        }
 9433|    508|    }
 9434|       |
 9435|  2.56k|    bucket->index = aindex;
 9436|       |
 9437|  2.56k|    return(INT_MAX);
 9438|  2.56k|}
parser.c:xmlParserNsLookupUri:
 1532|  3.74k|xmlParserNsLookupUri(xmlParserCtxtPtr ctxt, const xmlHashedString *prefix) {
 1533|  3.74k|    const xmlChar *ret;
 1534|  3.74k|    int nsIndex;
 1535|       |
 1536|  3.74k|    if (prefix->name == ctxt->str_xml)
  ------------------
  |  Branch (1536:9): [True: 0, False: 3.74k]
  ------------------
 1537|      0|        return(ctxt->str_xml_ns);
 1538|       |
 1539|  3.74k|    nsIndex = xmlParserNsLookup(ctxt, prefix, NULL);
 1540|  3.74k|    if (nsIndex == INT_MAX)
  ------------------
  |  Branch (1540:9): [True: 4, False: 3.74k]
  ------------------
 1541|      4|        return(NULL);
 1542|       |
 1543|  3.74k|    ret = ctxt->nsTab[nsIndex * 2 + 1];
 1544|  3.74k|    if (ret[0] == 0)
  ------------------
  |  Branch (1544:9): [True: 0, False: 3.74k]
  ------------------
 1545|      0|        ret = NULL;
 1546|  3.74k|    return(ret);
 1547|  3.74k|}
parser.c:nameNsPush:
 2024|  3.74k|{
 2025|  3.74k|    xmlStartTag *tag;
 2026|       |
 2027|  3.74k|    if (ctxt->nameNr >= ctxt->nameMax) {
  ------------------
  |  Branch (2027:9): [True: 4, False: 3.74k]
  ------------------
 2028|      4|        const xmlChar * *tmp;
 2029|      4|        xmlStartTag *tmp2;
 2030|      4|        ctxt->nameMax *= 2;
 2031|      4|        tmp = (const xmlChar * *) xmlRealloc((xmlChar * *)ctxt->nameTab,
 2032|      4|                                    ctxt->nameMax *
 2033|      4|                                    sizeof(ctxt->nameTab[0]));
 2034|      4|        if (tmp == NULL) {
  ------------------
  |  Branch (2034:13): [True: 0, False: 4]
  ------------------
 2035|      0|	    ctxt->nameMax /= 2;
 2036|      0|	    goto mem_error;
 2037|      0|        }
 2038|      4|	ctxt->nameTab = tmp;
 2039|      4|        tmp2 = (xmlStartTag *) xmlRealloc((void * *)ctxt->pushTab,
 2040|      4|                                    ctxt->nameMax *
 2041|      4|                                    sizeof(ctxt->pushTab[0]));
 2042|      4|        if (tmp2 == NULL) {
  ------------------
  |  Branch (2042:13): [True: 0, False: 4]
  ------------------
 2043|      0|	    ctxt->nameMax /= 2;
 2044|      0|	    goto mem_error;
 2045|      0|        }
 2046|      4|	ctxt->pushTab = tmp2;
 2047|  3.74k|    } else if (ctxt->pushTab == NULL) {
  ------------------
  |  Branch (2047:16): [True: 235, False: 3.50k]
  ------------------
 2048|    235|        ctxt->pushTab = (xmlStartTag *) xmlMalloc(ctxt->nameMax *
 2049|    235|                                            sizeof(ctxt->pushTab[0]));
 2050|    235|        if (ctxt->pushTab == NULL)
  ------------------
  |  Branch (2050:13): [True: 0, False: 235]
  ------------------
 2051|      0|            goto mem_error;
 2052|    235|    }
 2053|  3.74k|    ctxt->nameTab[ctxt->nameNr] = value;
 2054|  3.74k|    ctxt->name = value;
 2055|  3.74k|    tag = &ctxt->pushTab[ctxt->nameNr];
 2056|  3.74k|    tag->prefix = prefix;
 2057|  3.74k|    tag->URI = URI;
 2058|  3.74k|    tag->line = line;
 2059|  3.74k|    tag->nsNr = nsNr;
 2060|  3.74k|    return (ctxt->nameNr++);
 2061|      0|mem_error:
 2062|      0|    xmlErrMemory(ctxt, NULL);
 2063|      0|    return (-1);
 2064|  3.74k|}
parser.c:xmlParseElementEnd:
10475|  2.15k|xmlParseElementEnd(xmlParserCtxtPtr ctxt) {
10476|  2.15k|    xmlNodePtr cur = ctxt->node;
10477|       |
10478|  2.15k|    if (ctxt->nameNr <= 0) {
  ------------------
  |  Branch (10478:9): [True: 0, False: 2.15k]
  ------------------
10479|      0|        if ((RAW == '<') && (NXT(1) == '/'))
  ------------------
  |  | 2221|      0|#define RAW (*ctxt->input->cur)
  ------------------
                      if ((RAW == '<') && (NXT(1) == '/'))
  ------------------
  |  | 2223|      0|#define NXT(val) ctxt->input->cur[(val)]
  ------------------
  |  Branch (10479:13): [True: 0, False: 0]
  |  Branch (10479:29): [True: 0, False: 0]
  ------------------
10480|      0|            SKIP(2);
  ------------------
  |  | 2245|      0|#define SKIP(val) do {							\
  |  | 2246|      0|    ctxt->input->cur += (val),ctxt->input->col+=(val);			\
  |  | 2247|      0|    if (*ctxt->input->cur == 0)						\
  |  |  ------------------
  |  |  |  Branch (2247:9): [True: 0, False: 0]
  |  |  ------------------
  |  | 2248|      0|        xmlParserGrow(ctxt);						\
  |  | 2249|      0|  } while (0)
  |  |  ------------------
  |  |  |  Branch (2249:12): [Folded - Ignored]
  |  |  ------------------
  ------------------
10481|      0|        return;
10482|      0|    }
10483|       |
10484|       |    /*
10485|       |     * parse the end of tag: '</' should be here.
10486|       |     */
10487|  2.15k|    if (ctxt->sax2) {
  ------------------
  |  Branch (10487:9): [True: 2.15k, False: 0]
  ------------------
10488|  2.15k|	xmlParseEndTag2(ctxt, &ctxt->pushTab[ctxt->nameNr - 1]);
10489|  2.15k|	namePop(ctxt);
10490|  2.15k|    }
10491|      0|#ifdef LIBXML_SAX1_ENABLED
10492|      0|    else
10493|      0|	xmlParseEndTag1(ctxt, 0);
10494|  2.15k|#endif /* LIBXML_SAX1_ENABLED */
10495|       |
10496|       |    /*
10497|       |     * Capture end position
10498|       |     */
10499|  2.15k|    if (cur != NULL && ctxt->record_info) {
  ------------------
  |  Branch (10499:9): [True: 2.13k, False: 23]
  |  Branch (10499:24): [True: 0, False: 2.13k]
  ------------------
10500|      0|        xmlParserNodeInfoPtr node_info;
10501|       |
10502|      0|        node_info = (xmlParserNodeInfoPtr) xmlParserFindNodeInfo(ctxt, cur);
10503|      0|        if (node_info != NULL) {
  ------------------
  |  Branch (10503:13): [True: 0, False: 0]
  ------------------
10504|      0|            node_info->end_pos = ctxt->input->consumed +
10505|      0|                                 (CUR_PTR - ctxt->input->base);
  ------------------
  |  | 2224|      0|#define CUR_PTR ctxt->input->cur
  ------------------
10506|      0|            node_info->end_line = ctxt->input->line;
10507|      0|        }
10508|      0|    }
10509|  2.15k|}
parser.c:xmlParseEndTag2:
10039|  2.15k|xmlParseEndTag2(xmlParserCtxtPtr ctxt, const xmlStartTag *tag) {
10040|  2.15k|    const xmlChar *name;
10041|       |
10042|  2.15k|    GROW;
  ------------------
  |  | 2270|  2.15k|#define GROW if (ctxt->input->end - ctxt->input->cur < INPUT_CHUNK)	\
  |  |  ------------------
  |  |  |  |   97|  2.15k|#define INPUT_CHUNK	250
  |  |  ------------------
  |  |  |  Branch (2270:18): [True: 852, False: 1.30k]
  |  |  ------------------
  |  | 2271|  2.15k|	xmlParserGrow(ctxt);
  ------------------
10043|  2.15k|    if ((RAW != '<') || (NXT(1) != '/')) {
  ------------------
  |  | 2221|  2.15k|#define RAW (*ctxt->input->cur)
  ------------------
                  if ((RAW != '<') || (NXT(1) != '/')) {
  ------------------
  |  | 2223|  2.15k|#define NXT(val) ctxt->input->cur[(val)]
  ------------------
  |  Branch (10043:9): [True: 0, False: 2.15k]
  |  Branch (10043:25): [True: 0, False: 2.15k]
  ------------------
10044|      0|	xmlFatalErr(ctxt, XML_ERR_LTSLASH_REQUIRED, NULL);
10045|      0|	return;
10046|      0|    }
10047|  2.15k|    SKIP(2);
  ------------------
  |  | 2245|  2.15k|#define SKIP(val) do {							\
  |  | 2246|  2.15k|    ctxt->input->cur += (val),ctxt->input->col+=(val);			\
  |  | 2247|  2.15k|    if (*ctxt->input->cur == 0)						\
  |  |  ------------------
  |  |  |  Branch (2247:9): [True: 0, False: 2.15k]
  |  |  ------------------
  |  | 2248|  2.15k|        xmlParserGrow(ctxt);						\
  |  | 2249|  2.15k|  } while (0)
  |  |  ------------------
  |  |  |  Branch (2249:12): [Folded - Ignored]
  |  |  ------------------
  ------------------
10048|       |
10049|  2.15k|    if (tag->prefix == NULL)
  ------------------
  |  Branch (10049:9): [True: 165, False: 1.98k]
  ------------------
10050|    165|        name = xmlParseNameAndCompare(ctxt, ctxt->name);
10051|  1.98k|    else
10052|  1.98k|        name = xmlParseQNameAndCompare(ctxt, ctxt->name, tag->prefix);
10053|       |
10054|       |    /*
10055|       |     * We should definitely be at the ending "S? '>'" part
10056|       |     */
10057|  2.15k|    GROW;
  ------------------
  |  | 2270|  2.15k|#define GROW if (ctxt->input->end - ctxt->input->cur < INPUT_CHUNK)	\
  |  |  ------------------
  |  |  |  |   97|  2.15k|#define INPUT_CHUNK	250
  |  |  ------------------
  |  |  |  Branch (2270:18): [True: 867, False: 1.28k]
  |  |  ------------------
  |  | 2271|  2.15k|	xmlParserGrow(ctxt);
  ------------------
10058|  2.15k|    if (ctxt->instate == XML_PARSER_EOF)
  ------------------
  |  Branch (10058:9): [True: 0, False: 2.15k]
  ------------------
10059|      0|        return;
10060|  2.15k|    SKIP_BLANKS;
  ------------------
  |  | 2273|  2.15k|#define SKIP_BLANKS xmlSkipBlankChars(ctxt)
  ------------------
10061|  2.15k|    if ((!IS_BYTE_CHAR(RAW)) || (RAW != '>')) {
  ------------------
  |  |  113|  2.15k|#define IS_BYTE_CHAR(c)	 xmlIsChar_ch(c)
  |  |  ------------------
  |  |  |  |  108|  2.15k|#define xmlIsChar_ch(c)		(((0x9 <= (c)) && ((c) <= 0xa)) || \
  |  |  |  |  ------------------
  |  |  |  |  |  Branch (108:28): [True: 2.15k, False: 1]
  |  |  |  |  |  Branch (108:44): [True: 0, False: 2.15k]
  |  |  |  |  ------------------
  |  |  |  |  109|  2.15k|				 ((c) == 0xd) || \
  |  |  |  |  ------------------
  |  |  |  |  |  Branch (109:6): [True: 0, False: 2.15k]
  |  |  |  |  ------------------
  |  |  |  |  110|  2.15k|				  (0x20 <= (c)))
  |  |  |  |  ------------------
  |  |  |  |  |  Branch (110:7): [True: 2.15k, False: 1]
  |  |  |  |  ------------------
  |  |  ------------------
  ------------------
                  if ((!IS_BYTE_CHAR(RAW)) || (RAW != '>')) {
  ------------------
  |  | 2221|  2.15k|#define RAW (*ctxt->input->cur)
  ------------------
  |  Branch (10061:33): [True: 4, False: 2.14k]
  ------------------
10062|      5|	xmlFatalErr(ctxt, XML_ERR_GT_REQUIRED, NULL);
10063|      5|    } else
10064|  2.14k|	NEXT1;
  ------------------
  |  | 2277|  2.14k|#define NEXT1 {								\
  |  | 2278|  2.14k|	ctxt->input->col++;						\
  |  | 2279|  2.14k|	ctxt->input->cur++;						\
  |  | 2280|  2.14k|	if (*ctxt->input->cur == 0)					\
  |  |  ------------------
  |  |  |  Branch (2280:6): [True: 34, False: 2.11k]
  |  |  ------------------
  |  | 2281|  2.14k|	    xmlParserGrow(ctxt);						\
  |  | 2282|  2.14k|    }
  ------------------
10065|       |
10066|       |    /*
10067|       |     * [ WFC: Element Type Match ]
10068|       |     * The Name in an element's end-tag must match the element type in the
10069|       |     * start-tag.
10070|       |     *
10071|       |     */
10072|  2.15k|    if (name != (xmlChar*)1) {
  ------------------
  |  Branch (10072:9): [True: 33, False: 2.12k]
  ------------------
10073|     33|        if (name == NULL) name = BAD_CAST "unparsable";
  ------------------
  |  |   35|      0|#define BAD_CAST (xmlChar *)
  ------------------
  |  Branch (10073:13): [True: 0, False: 33]
  ------------------
10074|     33|        xmlFatalErrMsgStrIntStr(ctxt, XML_ERR_TAG_NAME_MISMATCH,
10075|     33|		     "Opening and ending tag mismatch: %s line %d and %s\n",
10076|     33|		                ctxt->name, tag->line, name);
10077|     33|    }
10078|       |
10079|       |    /*
10080|       |     * SAX: End of Tag
10081|       |     */
10082|  2.15k|    if ((ctxt->sax != NULL) && (ctxt->sax->endElementNs != NULL) &&
  ------------------
  |  Branch (10082:9): [True: 2.15k, False: 0]
  |  Branch (10082:32): [True: 2.15k, False: 0]
  ------------------
10083|  2.15k|	(!ctxt->disableSAX))
  ------------------
  |  Branch (10083:2): [True: 2.01k, False: 138]
  ------------------
10084|  2.01k|	ctxt->sax->endElementNs(ctxt->userData, ctxt->name, tag->prefix,
10085|  2.01k|                                tag->URI);
10086|       |
10087|  2.15k|    spacePop(ctxt);
10088|  2.15k|    if (tag->nsNr != 0)
  ------------------
  |  Branch (10088:9): [True: 233, False: 1.92k]
  ------------------
10089|    233|	xmlParserNsPop(ctxt, tag->nsNr);
10090|  2.15k|}
parser.c:xmlParseQNameAndCompare:
 9025|  1.98k|                        xmlChar const *prefix) {
 9026|  1.98k|    const xmlChar *cmp;
 9027|  1.98k|    const xmlChar *in;
 9028|  1.98k|    const xmlChar *ret;
 9029|  1.98k|    const xmlChar *prefix2;
 9030|       |
 9031|  1.98k|    if (prefix == NULL) return(xmlParseNameAndCompare(ctxt, name));
  ------------------
  |  Branch (9031:9): [True: 0, False: 1.98k]
  ------------------
 9032|       |
 9033|  1.98k|    GROW;
  ------------------
  |  | 2270|  1.98k|#define GROW if (ctxt->input->end - ctxt->input->cur < INPUT_CHUNK)	\
  |  |  ------------------
  |  |  |  |   97|  1.98k|#define INPUT_CHUNK	250
  |  |  ------------------
  |  |  |  Branch (2270:18): [True: 746, False: 1.24k]
  |  |  ------------------
  |  | 2271|  1.98k|	xmlParserGrow(ctxt);
  ------------------
 9034|  1.98k|    in = ctxt->input->cur;
 9035|       |
 9036|  1.98k|    cmp = prefix;
 9037|  6.76k|    while (*in != 0 && *in == *cmp) {
  ------------------
  |  Branch (9037:12): [True: 6.76k, False: 0]
  |  Branch (9037:24): [True: 4.78k, False: 1.98k]
  ------------------
 9038|  4.78k|	++in;
 9039|  4.78k|	++cmp;
 9040|  4.78k|    }
 9041|  1.98k|    if ((*cmp == 0) && (*in == ':')) {
  ------------------
  |  Branch (9041:9): [True: 1.98k, False: 3]
  |  Branch (9041:24): [True: 1.98k, False: 0]
  ------------------
 9042|  1.98k|        in++;
 9043|  1.98k|	cmp = name;
 9044|  20.2k|	while (*in != 0 && *in == *cmp) {
  ------------------
  |  Branch (9044:9): [True: 20.2k, False: 0]
  |  Branch (9044:21): [True: 18.2k, False: 1.98k]
  ------------------
 9045|  18.2k|	    ++in;
 9046|  18.2k|	    ++cmp;
 9047|  18.2k|	}
 9048|  1.98k|	if (*cmp == 0 && (*in == '>' || IS_BLANK_CH (*in))) {
  ------------------
  |  |  151|      0|#define IS_BLANK_CH(c)  xmlIsBlank_ch(c)
  |  |  ------------------
  |  |  |  |   88|      0|#define xmlIsBlank_ch(c)	(((c) == 0x20) || \
  |  |  |  |  ------------------
  |  |  |  |  |  Branch (88:27): [True: 0, False: 0]
  |  |  |  |  ------------------
  |  |  |  |   89|      0|				 ((0x9 <= (c)) && ((c) <= 0xa)) || \
  |  |  |  |  ------------------
  |  |  |  |  |  Branch (89:7): [True: 0, False: 0]
  |  |  |  |  |  Branch (89:23): [True: 0, False: 0]
  |  |  |  |  ------------------
  |  |  |  |   90|      0|				 ((c) == 0xd))
  |  |  |  |  ------------------
  |  |  |  |  |  Branch (90:6): [True: 0, False: 0]
  |  |  |  |  ------------------
  |  |  ------------------
  ------------------
  |  Branch (9048:6): [True: 1.95k, False: 27]
  |  Branch (9048:20): [True: 1.95k, False: 0]
  ------------------
 9049|       |	    /* success */
 9050|  1.95k|            ctxt->input->col += in - ctxt->input->cur;
 9051|  1.95k|	    ctxt->input->cur = in;
 9052|  1.95k|	    return((const xmlChar*) 1);
 9053|  1.95k|	}
 9054|  1.98k|    }
 9055|       |    /*
 9056|       |     * all strings coms from the dictionary, equality can be done directly
 9057|       |     */
 9058|     30|    ret = xmlParseQName (ctxt, &prefix2);
 9059|     30|    if (ret == NULL)
  ------------------
  |  Branch (9059:9): [True: 0, False: 30]
  ------------------
 9060|      0|        return(NULL);
 9061|     30|    if ((ret == name) && (prefix == prefix2))
  ------------------
  |  Branch (9061:9): [True: 0, False: 30]
  |  Branch (9061:26): [True: 0, False: 0]
  ------------------
 9062|      0|	return((const xmlChar*) 1);
 9063|     30|    return ret;
 9064|     30|}
parser.c:xmlParseQName:
 9000|     30|xmlParseQName(xmlParserCtxtPtr ctxt, const xmlChar **prefix) {
 9001|     30|    xmlHashedString n, p;
 9002|       |
 9003|     30|    n = xmlParseQNameHashed(ctxt, &p);
 9004|     30|    if (n.name == NULL)
  ------------------
  |  Branch (9004:9): [True: 0, False: 30]
  ------------------
 9005|      0|        return(NULL);
 9006|     30|    *prefix = p.name;
 9007|     30|    return(n.name);
 9008|     30|}
parser.c:xmlParserNsPush:
 1664|    388|                const xmlHashedString *uri, void *saxData, int defAttr) {
 1665|    388|    xmlParserNsBucket *bucket = NULL;
 1666|    388|    xmlParserNsExtra *extra;
 1667|    388|    const xmlChar **ns;
 1668|    388|    unsigned hashValue, nsIndex, oldIndex;
 1669|       |
 1670|    388|    if ((prefix != NULL) && (prefix->name == ctxt->str_xml))
  ------------------
  |  Branch (1670:9): [True: 317, False: 71]
  |  Branch (1670:29): [True: 0, False: 317]
  ------------------
 1671|      0|        return(0);
 1672|       |
 1673|    388|    if ((ctxt->nsNr >= ctxt->nsMax) && (xmlParserNsGrow(ctxt) < 0)) {
  ------------------
  |  Branch (1673:9): [True: 235, False: 153]
  |  Branch (1673:40): [True: 0, False: 235]
  ------------------
 1674|      0|        xmlErrMemory(ctxt, NULL);
 1675|      0|        return(-1);
 1676|      0|    }
 1677|       |
 1678|       |    /*
 1679|       |     * Default namespace and 'xml' namespace
 1680|       |     */
 1681|    388|    if ((prefix == NULL) || (prefix->name == NULL)) {
  ------------------
  |  Branch (1681:9): [True: 71, False: 317]
  |  Branch (1681:29): [True: 0, False: 317]
  ------------------
 1682|     71|        oldIndex = ctxt->nsdb->defaultNsIndex;
 1683|       |
 1684|     71|        if (oldIndex != INT_MAX) {
  ------------------
  |  Branch (1684:13): [True: 0, False: 71]
  ------------------
 1685|      0|            if (defAttr != 0)
  ------------------
  |  Branch (1685:17): [True: 0, False: 0]
  ------------------
 1686|      0|                return(0);
 1687|       |
 1688|      0|            extra = &ctxt->nsdb->extra[oldIndex];
 1689|       |
 1690|      0|            if (extra->elementId == ctxt->nsdb->elementId) {
  ------------------
  |  Branch (1690:17): [True: 0, False: 0]
  ------------------
 1691|      0|                xmlErrAttributeDup(ctxt, NULL, BAD_CAST "xmlns");
  ------------------
  |  |   35|      0|#define BAD_CAST (xmlChar *)
  ------------------
 1692|      0|                return(0);
 1693|      0|            }
 1694|       |
 1695|      0|            if ((ctxt->options & XML_PARSE_NSCLEAN) &&
  ------------------
  |  Branch (1695:17): [True: 0, False: 0]
  ------------------
 1696|      0|                (uri->name == ctxt->nsTab[oldIndex * 2 + 1]))
  ------------------
  |  Branch (1696:17): [True: 0, False: 0]
  ------------------
 1697|      0|                return(0);
 1698|      0|        }
 1699|       |
 1700|     71|        ctxt->nsdb->defaultNsIndex = ctxt->nsNr;
 1701|     71|        goto populate_entry;
 1702|     71|    }
 1703|       |
 1704|       |    /*
 1705|       |     * Hash table lookup
 1706|       |     */
 1707|    317|    oldIndex = xmlParserNsLookup(ctxt, prefix, &bucket);
 1708|    317|    if (oldIndex != INT_MAX) {
  ------------------
  |  Branch (1708:9): [True: 2, False: 315]
  ------------------
 1709|      2|        extra = &ctxt->nsdb->extra[oldIndex];
 1710|       |
 1711|      2|        if (defAttr != 0)
  ------------------
  |  Branch (1711:13): [True: 0, False: 2]
  ------------------
 1712|      0|            return(0);
 1713|       |
 1714|       |        /*
 1715|       |         * Check for duplicate definitions on the same element.
 1716|       |         */
 1717|      2|        if (extra->elementId == ctxt->nsdb->elementId) {
  ------------------
  |  Branch (1717:13): [True: 0, False: 2]
  ------------------
 1718|      0|            xmlErrAttributeDup(ctxt, BAD_CAST "xmlns", prefix->name);
  ------------------
  |  |   35|      0|#define BAD_CAST (xmlChar *)
  ------------------
 1719|      0|            return(0);
 1720|      0|        }
 1721|       |
 1722|      2|        if ((ctxt->options & XML_PARSE_NSCLEAN) &&
  ------------------
  |  Branch (1722:13): [True: 0, False: 2]
  ------------------
 1723|      2|            (uri->name == ctxt->nsTab[bucket->index * 2 + 1]))
  ------------------
  |  Branch (1723:13): [True: 0, False: 0]
  ------------------
 1724|      0|            return(0);
 1725|       |
 1726|      2|        bucket->index = ctxt->nsNr;
 1727|      2|        goto populate_entry;
 1728|      2|    }
 1729|       |
 1730|       |    /*
 1731|       |     * Insert new bucket
 1732|       |     */
 1733|       |
 1734|    315|    hashValue = prefix->hashValue;
 1735|       |
 1736|       |    /*
 1737|       |     * Grow hash table, 50% fill factor
 1738|       |     */
 1739|    315|    if (ctxt->nsdb->hashElems + 1 > ctxt->nsdb->hashSize / 2) {
  ------------------
  |  Branch (1739:9): [True: 232, False: 83]
  ------------------
 1740|    232|        xmlParserNsBucket *newHash;
 1741|    232|        unsigned newSize, i, index;
 1742|       |
 1743|    232|        if (ctxt->nsdb->hashSize > UINT_MAX / 2) {
  ------------------
  |  Branch (1743:13): [True: 0, False: 232]
  ------------------
 1744|      0|            xmlErrMemory(ctxt, NULL);
 1745|      0|            return(-1);
 1746|      0|        }
 1747|    232|        newSize = ctxt->nsdb->hashSize ? ctxt->nsdb->hashSize * 2 : 16;
  ------------------
  |  Branch (1747:19): [True: 0, False: 232]
  ------------------
 1748|    232|        newHash = xmlMalloc(newSize * sizeof(newHash[0]));
 1749|    232|        if (newHash == NULL) {
  ------------------
  |  Branch (1749:13): [True: 0, False: 232]
  ------------------
 1750|      0|            xmlErrMemory(ctxt, NULL);
 1751|      0|            return(-1);
 1752|      0|        }
 1753|    232|        memset(newHash, 0, newSize * sizeof(newHash[0]));
 1754|       |
 1755|    232|        for (i = 0; i < ctxt->nsdb->hashSize; i++) {
  ------------------
  |  Branch (1755:21): [True: 0, False: 232]
  ------------------
 1756|      0|            unsigned hv = ctxt->nsdb->hash[i].hashValue;
 1757|      0|            unsigned newIndex;
 1758|       |
 1759|      0|            if (hv == 0)
  ------------------
  |  Branch (1759:17): [True: 0, False: 0]
  ------------------
 1760|      0|                continue;
 1761|      0|            newIndex = hv & (newSize - 1);
 1762|       |
 1763|      0|            while (newHash[newIndex].hashValue != 0) {
  ------------------
  |  Branch (1763:20): [True: 0, False: 0]
  ------------------
 1764|      0|                newIndex++;
 1765|      0|                if (newIndex == newSize)
  ------------------
  |  Branch (1765:21): [True: 0, False: 0]
  ------------------
 1766|      0|                    newIndex = 0;
 1767|      0|            }
 1768|       |
 1769|      0|            newHash[newIndex] = ctxt->nsdb->hash[i];
 1770|      0|        }
 1771|       |
 1772|    232|        xmlFree(ctxt->nsdb->hash);
 1773|    232|        ctxt->nsdb->hash = newHash;
 1774|    232|        ctxt->nsdb->hashSize = newSize;
 1775|       |
 1776|       |        /*
 1777|       |         * Relookup
 1778|       |         */
 1779|    232|        index = hashValue & (newSize - 1);
 1780|       |
 1781|    232|        while (newHash[index].hashValue != 0) {
  ------------------
  |  Branch (1781:16): [True: 0, False: 232]
  ------------------
 1782|      0|            index++;
 1783|      0|            if (index == newSize)
  ------------------
  |  Branch (1783:17): [True: 0, False: 0]
  ------------------
 1784|      0|                index = 0;
 1785|      0|        }
 1786|       |
 1787|    232|        bucket = &newHash[index];
 1788|    232|    }
 1789|       |
 1790|    315|    bucket->hashValue = hashValue;
 1791|    315|    bucket->index = ctxt->nsNr;
 1792|    315|    ctxt->nsdb->hashElems++;
 1793|    315|    oldIndex = INT_MAX;
 1794|       |
 1795|    388|populate_entry:
 1796|    388|    nsIndex = ctxt->nsNr;
 1797|       |
 1798|    388|    ns = &ctxt->nsTab[nsIndex * 2];
 1799|    388|    ns[0] = prefix ? prefix->name : NULL;
  ------------------
  |  Branch (1799:13): [True: 317, False: 71]
  ------------------
 1800|    388|    ns[1] = uri->name;
 1801|       |
 1802|    388|    extra = &ctxt->nsdb->extra[nsIndex];
 1803|    388|    extra->saxData = saxData;
 1804|    388|    extra->prefixHashValue = prefix ? prefix->hashValue : 0;
  ------------------
  |  Branch (1804:30): [True: 317, False: 71]
  ------------------
 1805|    388|    extra->uriHashValue = uri->hashValue;
 1806|    388|    extra->elementId = ctxt->nsdb->elementId;
 1807|    388|    extra->oldIndex = oldIndex;
 1808|       |
 1809|    388|    ctxt->nsNr++;
 1810|       |
 1811|    388|    return(1);
 1812|    315|}
parser.c:xmlParserNsGrow:
 1622|    235|xmlParserNsGrow(xmlParserCtxtPtr ctxt) {
 1623|    235|    const xmlChar **table;
 1624|    235|    xmlParserNsExtra *extra;
 1625|    235|    int newSize;
 1626|       |
 1627|    235|    if (ctxt->nsMax > INT_MAX / 2)
  ------------------
  |  Branch (1627:9): [True: 0, False: 235]
  ------------------
 1628|      0|        goto error;
 1629|    235|    newSize = ctxt->nsMax ? ctxt->nsMax * 2 : 16;
  ------------------
  |  Branch (1629:15): [True: 0, False: 235]
  ------------------
 1630|       |
 1631|    235|    table = xmlRealloc(ctxt->nsTab, 2 * newSize * sizeof(table[0]));
 1632|    235|    if (table == NULL)
  ------------------
  |  Branch (1632:9): [True: 0, False: 235]
  ------------------
 1633|      0|        goto error;
 1634|    235|    ctxt->nsTab = table;
 1635|       |
 1636|    235|    extra = xmlRealloc(ctxt->nsdb->extra, newSize * sizeof(extra[0]));
 1637|    235|    if (extra == NULL)
  ------------------
  |  Branch (1637:9): [True: 0, False: 235]
  ------------------
 1638|      0|        goto error;
 1639|    235|    ctxt->nsdb->extra = extra;
 1640|       |
 1641|    235|    ctxt->nsMax = newSize;
 1642|    235|    return(0);
 1643|       |
 1644|      0|error:
 1645|      0|    xmlErrMemory(ctxt, NULL);
 1646|      0|    return(-1);
 1647|    235|}
parser.c:xmlParserNsPop:
 1825|    236|{
 1826|    236|    int i;
 1827|       |
 1828|       |    /* assert(nr <= ctxt->nsNr); */
 1829|       |
 1830|    618|    for (i = ctxt->nsNr - 1; i >= ctxt->nsNr - nr; i--) {
  ------------------
  |  Branch (1830:30): [True: 382, False: 236]
  ------------------
 1831|    382|        const xmlChar *prefix = ctxt->nsTab[i * 2];
 1832|    382|        xmlParserNsExtra *extra = &ctxt->nsdb->extra[i];
 1833|       |
 1834|    382|        if (prefix == NULL) {
  ------------------
  |  Branch (1834:13): [True: 70, False: 312]
  ------------------
 1835|     70|            ctxt->nsdb->defaultNsIndex = extra->oldIndex;
 1836|    312|        } else {
 1837|    312|            xmlHashedString hprefix;
 1838|    312|            xmlParserNsBucket *bucket = NULL;
 1839|       |
 1840|    312|            hprefix.name = prefix;
 1841|    312|            hprefix.hashValue = extra->prefixHashValue;
 1842|    312|            xmlParserNsLookup(ctxt, &hprefix, &bucket);
 1843|       |            /* assert(bucket && bucket->hashValue); */
 1844|    312|            bucket->index = extra->oldIndex;
 1845|    312|        }
 1846|    382|    }
 1847|       |
 1848|    236|    ctxt->nsNr -= nr;
 1849|    236|    return(nr);
 1850|    236|}
parser.c:xmlParserNsReset:
 1441|    242|xmlParserNsReset(xmlParserNsData *nsdb) {
 1442|    242|    if (nsdb == NULL)
  ------------------
  |  Branch (1442:9): [True: 0, False: 242]
  ------------------
 1443|      0|        return;
 1444|       |
 1445|    242|    nsdb->hashElems = 0;
 1446|    242|    nsdb->elementId = 0;
 1447|    242|    nsdb->defaultNsIndex = INT_MAX;
 1448|       |
 1449|    242|    if (nsdb->hash)
  ------------------
  |  Branch (1449:9): [True: 0, False: 242]
  ------------------
 1450|      0|        memset(nsdb->hash, 0, nsdb->hashSize * sizeof(nsdb->hash[0]));
 1451|    242|}
parser.c:xmlCtxtUseOptionsInternal:
14554|    238|{
14555|    238|    if (ctxt == NULL)
  ------------------
  |  Branch (14555:9): [True: 0, False: 238]
  ------------------
14556|      0|        return(-1);
14557|    238|    if (encoding != NULL) {
  ------------------
  |  Branch (14557:9): [True: 0, False: 238]
  ------------------
14558|      0|        if (ctxt->encoding != NULL)
  ------------------
  |  Branch (14558:13): [True: 0, False: 0]
  ------------------
14559|      0|	    xmlFree((xmlChar *) ctxt->encoding);
14560|      0|        ctxt->encoding = xmlStrdup((const xmlChar *) encoding);
14561|      0|    }
14562|    238|    if (options & XML_PARSE_RECOVER) {
  ------------------
  |  Branch (14562:9): [True: 0, False: 238]
  ------------------
14563|      0|        ctxt->recovery = 1;
14564|      0|        options -= XML_PARSE_RECOVER;
14565|      0|	ctxt->options |= XML_PARSE_RECOVER;
14566|      0|    } else
14567|    238|        ctxt->recovery = 0;
14568|    238|    if (options & XML_PARSE_DTDLOAD) {
  ------------------
  |  Branch (14568:9): [True: 0, False: 238]
  ------------------
14569|      0|        ctxt->loadsubset = XML_DETECT_IDS;
  ------------------
  |  |  141|      0|#define XML_DETECT_IDS		2
  ------------------
14570|      0|        options -= XML_PARSE_DTDLOAD;
14571|      0|	ctxt->options |= XML_PARSE_DTDLOAD;
14572|      0|    } else
14573|    238|        ctxt->loadsubset = 0;
14574|    238|    if (options & XML_PARSE_DTDATTR) {
  ------------------
  |  Branch (14574:9): [True: 0, False: 238]
  ------------------
14575|      0|        ctxt->loadsubset |= XML_COMPLETE_ATTRS;
  ------------------
  |  |  150|      0|#define XML_COMPLETE_ATTRS	4
  ------------------
14576|      0|        options -= XML_PARSE_DTDATTR;
14577|      0|	ctxt->options |= XML_PARSE_DTDATTR;
14578|      0|    }
14579|    238|    if (options & XML_PARSE_NOENT) {
  ------------------
  |  Branch (14579:9): [True: 238, False: 0]
  ------------------
14580|    238|        ctxt->replaceEntities = 1;
14581|       |        /* ctxt->loadsubset |= XML_DETECT_IDS; */
14582|    238|        options -= XML_PARSE_NOENT;
14583|    238|	ctxt->options |= XML_PARSE_NOENT;
14584|    238|    } else
14585|      0|        ctxt->replaceEntities = 0;
14586|    238|    if (options & XML_PARSE_PEDANTIC) {
  ------------------
  |  Branch (14586:9): [True: 0, False: 238]
  ------------------
14587|      0|        ctxt->pedantic = 1;
14588|      0|        options -= XML_PARSE_PEDANTIC;
14589|      0|	ctxt->options |= XML_PARSE_PEDANTIC;
14590|      0|    } else
14591|    238|        ctxt->pedantic = 0;
14592|    238|    if (options & XML_PARSE_NOBLANKS) {
  ------------------
  |  Branch (14592:9): [True: 0, False: 238]
  ------------------
14593|      0|        ctxt->keepBlanks = 0;
14594|      0|        ctxt->sax->ignorableWhitespace = xmlSAX2IgnorableWhitespace;
14595|      0|        options -= XML_PARSE_NOBLANKS;
14596|      0|	ctxt->options |= XML_PARSE_NOBLANKS;
14597|      0|    } else
14598|    238|        ctxt->keepBlanks = 1;
14599|    238|    if (options & XML_PARSE_DTDVALID) {
  ------------------
  |  Branch (14599:9): [True: 0, False: 238]
  ------------------
14600|      0|        ctxt->validate = 1;
14601|      0|        if (options & XML_PARSE_NOWARNING)
  ------------------
  |  Branch (14601:13): [True: 0, False: 0]
  ------------------
14602|      0|            ctxt->vctxt.warning = NULL;
14603|      0|        if (options & XML_PARSE_NOERROR)
  ------------------
  |  Branch (14603:13): [True: 0, False: 0]
  ------------------
14604|      0|            ctxt->vctxt.error = NULL;
14605|      0|        options -= XML_PARSE_DTDVALID;
14606|      0|	ctxt->options |= XML_PARSE_DTDVALID;
14607|      0|    } else
14608|    238|        ctxt->validate = 0;
14609|    238|    if (options & XML_PARSE_NOWARNING) {
  ------------------
  |  Branch (14609:9): [True: 0, False: 238]
  ------------------
14610|      0|        ctxt->sax->warning = NULL;
14611|      0|        options -= XML_PARSE_NOWARNING;
14612|      0|    }
14613|    238|    if (options & XML_PARSE_NOERROR) {
  ------------------
  |  Branch (14613:9): [True: 0, False: 238]
  ------------------
14614|      0|        ctxt->sax->error = NULL;
14615|      0|        ctxt->sax->fatalError = NULL;
14616|      0|        options -= XML_PARSE_NOERROR;
14617|      0|    }
14618|    238|#ifdef LIBXML_SAX1_ENABLED
14619|    238|    if (options & XML_PARSE_SAX1) {
  ------------------
  |  Branch (14619:9): [True: 0, False: 238]
  ------------------
14620|      0|        ctxt->sax->startElementNs = NULL;
14621|      0|        ctxt->sax->endElementNs = NULL;
14622|      0|        ctxt->sax->initialized = 1;
14623|      0|        options -= XML_PARSE_SAX1;
14624|      0|	ctxt->options |= XML_PARSE_SAX1;
14625|      0|    }
14626|    238|#endif /* LIBXML_SAX1_ENABLED */
14627|    238|    if (options & XML_PARSE_NODICT) {
  ------------------
  |  Branch (14627:9): [True: 0, False: 238]
  ------------------
14628|      0|        ctxt->dictNames = 0;
14629|      0|        options -= XML_PARSE_NODICT;
14630|      0|	ctxt->options |= XML_PARSE_NODICT;
14631|    238|    } else {
14632|    238|        ctxt->dictNames = 1;
14633|    238|    }
14634|    238|    if (options & XML_PARSE_NOCDATA) {
  ------------------
  |  Branch (14634:9): [True: 0, False: 238]
  ------------------
14635|      0|        ctxt->sax->cdataBlock = NULL;
14636|      0|        options -= XML_PARSE_NOCDATA;
14637|      0|	ctxt->options |= XML_PARSE_NOCDATA;
14638|      0|    }
14639|    238|    if (options & XML_PARSE_NSCLEAN) {
  ------------------
  |  Branch (14639:9): [True: 0, False: 238]
  ------------------
14640|      0|	ctxt->options |= XML_PARSE_NSCLEAN;
14641|      0|        options -= XML_PARSE_NSCLEAN;
14642|      0|    }
14643|    238|    if (options & XML_PARSE_NONET) {
  ------------------
  |  Branch (14643:9): [True: 0, False: 238]
  ------------------
14644|      0|	ctxt->options |= XML_PARSE_NONET;
14645|      0|        options -= XML_PARSE_NONET;
14646|      0|    }
14647|    238|    if (options & XML_PARSE_COMPACT) {
  ------------------
  |  Branch (14647:9): [True: 0, False: 238]
  ------------------
14648|      0|	ctxt->options |= XML_PARSE_COMPACT;
14649|      0|        options -= XML_PARSE_COMPACT;
14650|      0|    }
14651|    238|    if (options & XML_PARSE_OLD10) {
  ------------------
  |  Branch (14651:9): [True: 0, False: 238]
  ------------------
14652|      0|	ctxt->options |= XML_PARSE_OLD10;
14653|      0|        options -= XML_PARSE_OLD10;
14654|      0|    }
14655|    238|    if (options & XML_PARSE_NOBASEFIX) {
  ------------------
  |  Branch (14655:9): [True: 0, False: 238]
  ------------------
14656|      0|	ctxt->options |= XML_PARSE_NOBASEFIX;
14657|      0|        options -= XML_PARSE_NOBASEFIX;
14658|      0|    }
14659|    238|    if (options & XML_PARSE_HUGE) {
  ------------------
  |  Branch (14659:9): [True: 0, False: 238]
  ------------------
14660|      0|	ctxt->options |= XML_PARSE_HUGE;
14661|      0|        options -= XML_PARSE_HUGE;
14662|      0|        if (ctxt->dict != NULL)
  ------------------
  |  Branch (14662:13): [True: 0, False: 0]
  ------------------
14663|      0|            xmlDictSetLimit(ctxt->dict, 0);
14664|      0|    }
14665|    238|    if (options & XML_PARSE_OLDSAX) {
  ------------------
  |  Branch (14665:9): [True: 0, False: 238]
  ------------------
14666|      0|	ctxt->options |= XML_PARSE_OLDSAX;
14667|      0|        options -= XML_PARSE_OLDSAX;
14668|      0|    }
14669|    238|    if (options & XML_PARSE_IGNORE_ENC) {
  ------------------
  |  Branch (14669:9): [True: 0, False: 238]
  ------------------
14670|      0|	ctxt->options |= XML_PARSE_IGNORE_ENC;
14671|      0|        options -= XML_PARSE_IGNORE_ENC;
14672|      0|    }
14673|    238|    if (options & XML_PARSE_BIG_LINES) {
  ------------------
  |  Branch (14673:9): [True: 0, False: 238]
  ------------------
14674|      0|	ctxt->options |= XML_PARSE_BIG_LINES;
14675|      0|        options -= XML_PARSE_BIG_LINES;
14676|      0|    }
14677|    238|    ctxt->linenumbers = 1;
14678|    238|    return (options);
14679|    238|}
parser.c:xmlDoRead:
14731|    238|{
14732|    238|    xmlDocPtr ret;
14733|       |
14734|    238|    xmlCtxtUseOptionsInternal(ctxt, options, encoding);
14735|    238|    if (encoding != NULL) {
  ------------------
  |  Branch (14735:9): [True: 0, False: 238]
  ------------------
14736|      0|        xmlCharEncodingHandlerPtr hdlr;
14737|       |
14738|       |        /*
14739|       |         * TODO: We should consider to set XML_PARSE_IGNORE_ENC if the
14740|       |         * caller provided an encoding. Otherwise, we might switch to
14741|       |         * the encoding from the XML declaration which is likely to
14742|       |         * break things. Also see xmlSwitchInputEncoding.
14743|       |         */
14744|      0|	hdlr = xmlFindCharEncodingHandler(encoding);
14745|      0|	if (hdlr != NULL)
  ------------------
  |  Branch (14745:6): [True: 0, False: 0]
  ------------------
14746|      0|	    xmlSwitchToEncoding(ctxt, hdlr);
14747|      0|    }
14748|    238|    if ((URL != NULL) && (ctxt->input != NULL) &&
  ------------------
  |  Branch (14748:9): [True: 0, False: 238]
  |  Branch (14748:26): [True: 0, False: 0]
  ------------------
14749|    238|        (ctxt->input->filename == NULL))
  ------------------
  |  Branch (14749:9): [True: 0, False: 0]
  ------------------
14750|      0|        ctxt->input->filename = (char *) xmlStrdup((const xmlChar *) URL);
14751|    238|    xmlParseDocument(ctxt);
14752|    238|    if ((ctxt->wellFormed) || ctxt->recovery)
  ------------------
  |  Branch (14752:9): [True: 206, False: 32]
  |  Branch (14752:31): [True: 0, False: 32]
  ------------------
14753|    206|        ret = ctxt->myDoc;
14754|     32|    else {
14755|     32|        ret = NULL;
14756|     32|	if (ctxt->myDoc != NULL) {
  ------------------
  |  Branch (14756:6): [True: 30, False: 2]
  ------------------
14757|     30|	    xmlFreeDoc(ctxt->myDoc);
14758|     30|	}
14759|     32|    }
14760|    238|    ctxt->myDoc = NULL;
14761|    238|    if (!reuse) {
  ------------------
  |  Branch (14761:9): [True: 0, False: 238]
  ------------------
14762|      0|	xmlFreeParserCtxt(ctxt);
14763|      0|    }
14764|       |
14765|    238|    return (ret);
14766|    238|}

__xmlErrEncoding:
  136|      9|{
  137|      9|    if ((ctxt != NULL) && (ctxt->disableSAX != 0) &&
  ------------------
  |  Branch (137:9): [True: 9, False: 0]
  |  Branch (137:27): [True: 3, False: 6]
  ------------------
  138|      9|        (ctxt->instate == XML_PARSER_EOF))
  ------------------
  |  Branch (138:9): [True: 0, False: 3]
  ------------------
  139|      0|	return;
  140|      9|    if (ctxt != NULL)
  ------------------
  |  Branch (140:9): [True: 9, False: 0]
  ------------------
  141|      9|        ctxt->errNo = xmlerr;
  142|      9|    __xmlRaiseError(NULL, NULL, NULL,
  143|      9|                    ctxt, NULL, XML_FROM_PARSER, xmlerr, XML_ERR_FATAL,
  144|      9|                    NULL, 0, (const char *) str1, (const char *) str2,
  145|      9|                    NULL, 0, 0, msg, str1, str2);
  146|      9|    if (ctxt != NULL) {
  ------------------
  |  Branch (146:9): [True: 9, False: 0]
  ------------------
  147|      9|        ctxt->wellFormed = 0;
  148|      9|        if (ctxt->recovery == 0)
  ------------------
  |  Branch (148:13): [True: 9, False: 0]
  ------------------
  149|      9|            ctxt->disableSAX = 1;
  150|      9|    }
  151|      9|}
xmlFatalErr:
  190|     16|{
  191|     16|    const char *errmsg;
  192|       |
  193|     16|    if ((ctxt != NULL) && (ctxt->disableSAX != 0) &&
  ------------------
  |  Branch (193:9): [True: 16, False: 0]
  |  Branch (193:27): [True: 12, False: 4]
  ------------------
  194|     16|        (ctxt->instate == XML_PARSER_EOF))
  ------------------
  |  Branch (194:9): [True: 0, False: 12]
  ------------------
  195|      0|	return;
  196|     16|    switch (error) {
  197|      0|        case XML_ERR_INVALID_HEX_CHARREF:
  ------------------
  |  Branch (197:9): [True: 0, False: 16]
  ------------------
  198|      0|            errmsg = "CharRef: invalid hexadecimal value";
  199|      0|            break;
  200|      0|        case XML_ERR_INVALID_DEC_CHARREF:
  ------------------
  |  Branch (200:9): [True: 0, False: 16]
  ------------------
  201|      0|            errmsg = "CharRef: invalid decimal value";
  202|      0|            break;
  203|      0|        case XML_ERR_INVALID_CHARREF:
  ------------------
  |  Branch (203:9): [True: 0, False: 16]
  ------------------
  204|      0|            errmsg = "CharRef: invalid value";
  205|      0|            break;
  206|      6|        case XML_ERR_INTERNAL_ERROR:
  ------------------
  |  Branch (206:9): [True: 6, False: 10]
  ------------------
  207|      6|            errmsg = "internal error";
  208|      6|            break;
  209|      0|        case XML_ERR_PEREF_AT_EOF:
  ------------------
  |  Branch (209:9): [True: 0, False: 16]
  ------------------
  210|      0|            errmsg = "PEReference at end of document";
  211|      0|            break;
  212|      0|        case XML_ERR_PEREF_IN_PROLOG:
  ------------------
  |  Branch (212:9): [True: 0, False: 16]
  ------------------
  213|      0|            errmsg = "PEReference in prolog";
  214|      0|            break;
  215|      0|        case XML_ERR_PEREF_IN_EPILOG:
  ------------------
  |  Branch (215:9): [True: 0, False: 16]
  ------------------
  216|      0|            errmsg = "PEReference in epilog";
  217|      0|            break;
  218|      0|        case XML_ERR_PEREF_NO_NAME:
  ------------------
  |  Branch (218:9): [True: 0, False: 16]
  ------------------
  219|      0|            errmsg = "PEReference: no name";
  220|      0|            break;
  221|      0|        case XML_ERR_PEREF_SEMICOL_MISSING:
  ------------------
  |  Branch (221:9): [True: 0, False: 16]
  ------------------
  222|      0|            errmsg = "PEReference: expecting ';'";
  223|      0|            break;
  224|      0|        case XML_ERR_ENTITY_LOOP:
  ------------------
  |  Branch (224:9): [True: 0, False: 16]
  ------------------
  225|      0|            errmsg = "Detected an entity reference loop";
  226|      0|            break;
  227|      0|        case XML_ERR_ENTITY_NOT_STARTED:
  ------------------
  |  Branch (227:9): [True: 0, False: 16]
  ------------------
  228|      0|            errmsg = "EntityValue: \" or ' expected";
  229|      0|            break;
  230|      0|        case XML_ERR_ENTITY_PE_INTERNAL:
  ------------------
  |  Branch (230:9): [True: 0, False: 16]
  ------------------
  231|      0|            errmsg = "PEReferences forbidden in internal subset";
  232|      0|            break;
  233|      0|        case XML_ERR_ENTITY_NOT_FINISHED:
  ------------------
  |  Branch (233:9): [True: 0, False: 16]
  ------------------
  234|      0|            errmsg = "EntityValue: \" or ' expected";
  235|      0|            break;
  236|      0|        case XML_ERR_ATTRIBUTE_NOT_STARTED:
  ------------------
  |  Branch (236:9): [True: 0, False: 16]
  ------------------
  237|      0|            errmsg = "AttValue: \" or ' expected";
  238|      0|            break;
  239|      1|        case XML_ERR_LT_IN_ATTRIBUTE:
  ------------------
  |  Branch (239:9): [True: 1, False: 15]
  ------------------
  240|      1|            errmsg = "Unescaped '<' not allowed in attributes values";
  241|      1|            break;
  242|      0|        case XML_ERR_LITERAL_NOT_STARTED:
  ------------------
  |  Branch (242:9): [True: 0, False: 16]
  ------------------
  243|      0|            errmsg = "SystemLiteral \" or ' expected";
  244|      0|            break;
  245|      0|        case XML_ERR_LITERAL_NOT_FINISHED:
  ------------------
  |  Branch (245:9): [True: 0, False: 16]
  ------------------
  246|      0|            errmsg = "Unfinished System or Public ID \" or ' expected";
  247|      0|            break;
  248|      0|        case XML_ERR_MISPLACED_CDATA_END:
  ------------------
  |  Branch (248:9): [True: 0, False: 16]
  ------------------
  249|      0|            errmsg = "Sequence ']]>' not allowed in content";
  250|      0|            break;
  251|      0|        case XML_ERR_URI_REQUIRED:
  ------------------
  |  Branch (251:9): [True: 0, False: 16]
  ------------------
  252|      0|            errmsg = "SYSTEM or PUBLIC, the URI is missing";
  253|      0|            break;
  254|      0|        case XML_ERR_PUBID_REQUIRED:
  ------------------
  |  Branch (254:9): [True: 0, False: 16]
  ------------------
  255|      0|            errmsg = "PUBLIC, the Public Identifier is missing";
  256|      0|            break;
  257|      0|        case XML_ERR_HYPHEN_IN_COMMENT:
  ------------------
  |  Branch (257:9): [True: 0, False: 16]
  ------------------
  258|      0|            errmsg = "Comment must not contain '--' (double-hyphen)";
  259|      0|            break;
  260|      0|        case XML_ERR_PI_NOT_STARTED:
  ------------------
  |  Branch (260:9): [True: 0, False: 16]
  ------------------
  261|      0|            errmsg = "xmlParsePI : no target name";
  262|      0|            break;
  263|      0|        case XML_ERR_RESERVED_XML_NAME:
  ------------------
  |  Branch (263:9): [True: 0, False: 16]
  ------------------
  264|      0|            errmsg = "Invalid PI name";
  265|      0|            break;
  266|      0|        case XML_ERR_NOTATION_NOT_STARTED:
  ------------------
  |  Branch (266:9): [True: 0, False: 16]
  ------------------
  267|      0|            errmsg = "NOTATION: Name expected here";
  268|      0|            break;
  269|      0|        case XML_ERR_NOTATION_NOT_FINISHED:
  ------------------
  |  Branch (269:9): [True: 0, False: 16]
  ------------------
  270|      0|            errmsg = "'>' required to close NOTATION declaration";
  271|      0|            break;
  272|      0|        case XML_ERR_VALUE_REQUIRED:
  ------------------
  |  Branch (272:9): [True: 0, False: 16]
  ------------------
  273|      0|            errmsg = "Entity value required";
  274|      0|            break;
  275|      0|        case XML_ERR_URI_FRAGMENT:
  ------------------
  |  Branch (275:9): [True: 0, False: 16]
  ------------------
  276|      0|            errmsg = "Fragment not allowed";
  277|      0|            break;
  278|      0|        case XML_ERR_ATTLIST_NOT_STARTED:
  ------------------
  |  Branch (278:9): [True: 0, False: 16]
  ------------------
  279|      0|            errmsg = "'(' required to start ATTLIST enumeration";
  280|      0|            break;
  281|      0|        case XML_ERR_NMTOKEN_REQUIRED:
  ------------------
  |  Branch (281:9): [True: 0, False: 16]
  ------------------
  282|      0|            errmsg = "NmToken expected in ATTLIST enumeration";
  283|      0|            break;
  284|      0|        case XML_ERR_ATTLIST_NOT_FINISHED:
  ------------------
  |  Branch (284:9): [True: 0, False: 16]
  ------------------
  285|      0|            errmsg = "')' required to finish ATTLIST enumeration";
  286|      0|            break;
  287|      0|        case XML_ERR_MIXED_NOT_STARTED:
  ------------------
  |  Branch (287:9): [True: 0, False: 16]
  ------------------
  288|      0|            errmsg = "MixedContentDecl : '|' or ')*' expected";
  289|      0|            break;
  290|      0|        case XML_ERR_PCDATA_REQUIRED:
  ------------------
  |  Branch (290:9): [True: 0, False: 16]
  ------------------
  291|      0|            errmsg = "MixedContentDecl : '#PCDATA' expected";
  292|      0|            break;
  293|      0|        case XML_ERR_ELEMCONTENT_NOT_STARTED:
  ------------------
  |  Branch (293:9): [True: 0, False: 16]
  ------------------
  294|      0|            errmsg = "ContentDecl : Name or '(' expected";
  295|      0|            break;
  296|      0|        case XML_ERR_ELEMCONTENT_NOT_FINISHED:
  ------------------
  |  Branch (296:9): [True: 0, False: 16]
  ------------------
  297|      0|            errmsg = "ContentDecl : ',' '|' or ')' expected";
  298|      0|            break;
  299|      0|        case XML_ERR_PEREF_IN_INT_SUBSET:
  ------------------
  |  Branch (299:9): [True: 0, False: 16]
  ------------------
  300|      0|            errmsg =
  301|      0|                "PEReference: forbidden within markup decl in internal subset";
  302|      0|            break;
  303|      5|        case XML_ERR_GT_REQUIRED:
  ------------------
  |  Branch (303:9): [True: 5, False: 11]
  ------------------
  304|      5|            errmsg = "expected '>'";
  305|      5|            break;
  306|      0|        case XML_ERR_CONDSEC_INVALID:
  ------------------
  |  Branch (306:9): [True: 0, False: 16]
  ------------------
  307|      0|            errmsg = "XML conditional section '[' expected";
  308|      0|            break;
  309|      0|        case XML_ERR_EXT_SUBSET_NOT_FINISHED:
  ------------------
  |  Branch (309:9): [True: 0, False: 16]
  ------------------
  310|      0|            errmsg = "Content error in the external subset";
  311|      0|            break;
  312|      0|        case XML_ERR_CONDSEC_INVALID_KEYWORD:
  ------------------
  |  Branch (312:9): [True: 0, False: 16]
  ------------------
  313|      0|            errmsg =
  314|      0|                "conditional section INCLUDE or IGNORE keyword expected";
  315|      0|            break;
  316|      0|        case XML_ERR_CONDSEC_NOT_FINISHED:
  ------------------
  |  Branch (316:9): [True: 0, False: 16]
  ------------------
  317|      0|            errmsg = "XML conditional section not closed";
  318|      0|            break;
  319|      0|        case XML_ERR_XMLDECL_NOT_STARTED:
  ------------------
  |  Branch (319:9): [True: 0, False: 16]
  ------------------
  320|      0|            errmsg = "Text declaration '<?xml' required";
  321|      0|            break;
  322|      2|        case XML_ERR_XMLDECL_NOT_FINISHED:
  ------------------
  |  Branch (322:9): [True: 2, False: 14]
  ------------------
  323|      2|            errmsg = "parsing XML declaration: '?>' expected";
  324|      2|            break;
  325|      0|        case XML_ERR_EXT_ENTITY_STANDALONE:
  ------------------
  |  Branch (325:9): [True: 0, False: 16]
  ------------------
  326|      0|            errmsg = "external parsed entities cannot be standalone";
  327|      0|            break;
  328|      0|        case XML_ERR_ENTITYREF_SEMICOL_MISSING:
  ------------------
  |  Branch (328:9): [True: 0, False: 16]
  ------------------
  329|      0|            errmsg = "EntityRef: expecting ';'";
  330|      0|            break;
  331|      0|        case XML_ERR_DOCTYPE_NOT_FINISHED:
  ------------------
  |  Branch (331:9): [True: 0, False: 16]
  ------------------
  332|      0|            errmsg = "DOCTYPE improperly terminated";
  333|      0|            break;
  334|      0|        case XML_ERR_LTSLASH_REQUIRED:
  ------------------
  |  Branch (334:9): [True: 0, False: 16]
  ------------------
  335|      0|            errmsg = "EndTag: '</' not found";
  336|      0|            break;
  337|      0|        case XML_ERR_EQUAL_REQUIRED:
  ------------------
  |  Branch (337:9): [True: 0, False: 16]
  ------------------
  338|      0|            errmsg = "expected '='";
  339|      0|            break;
  340|      2|        case XML_ERR_STRING_NOT_CLOSED:
  ------------------
  |  Branch (340:9): [True: 2, False: 14]
  ------------------
  341|      2|            errmsg = "String not closed expecting \" or '";
  342|      2|            break;
  343|      0|        case XML_ERR_STRING_NOT_STARTED:
  ------------------
  |  Branch (343:9): [True: 0, False: 16]
  ------------------
  344|      0|            errmsg = "String not started expecting ' or \"";
  345|      0|            break;
  346|      0|        case XML_ERR_ENCODING_NAME:
  ------------------
  |  Branch (346:9): [True: 0, False: 16]
  ------------------
  347|      0|            errmsg = "Invalid XML encoding name";
  348|      0|            break;
  349|      0|        case XML_ERR_STANDALONE_VALUE:
  ------------------
  |  Branch (349:9): [True: 0, False: 16]
  ------------------
  350|      0|            errmsg = "standalone accepts only 'yes' or 'no'";
  351|      0|            break;
  352|      0|        case XML_ERR_DOCUMENT_EMPTY:
  ------------------
  |  Branch (352:9): [True: 0, False: 16]
  ------------------
  353|      0|            errmsg = "Document is empty";
  354|      0|            break;
  355|      0|        case XML_ERR_DOCUMENT_END:
  ------------------
  |  Branch (355:9): [True: 0, False: 16]
  ------------------
  356|      0|            errmsg = "Extra content at the end of the document";
  357|      0|            break;
  358|      0|        case XML_ERR_NOT_WELL_BALANCED:
  ------------------
  |  Branch (358:9): [True: 0, False: 16]
  ------------------
  359|      0|            errmsg = "chunk is not well balanced";
  360|      0|            break;
  361|      0|        case XML_ERR_EXTRA_CONTENT:
  ------------------
  |  Branch (361:9): [True: 0, False: 16]
  ------------------
  362|      0|            errmsg = "extra content at the end of well balanced chunk";
  363|      0|            break;
  364|      0|        case XML_ERR_VERSION_MISSING:
  ------------------
  |  Branch (364:9): [True: 0, False: 16]
  ------------------
  365|      0|            errmsg = "Malformed declaration expecting version";
  366|      0|            break;
  367|      0|        case XML_ERR_NAME_TOO_LONG:
  ------------------
  |  Branch (367:9): [True: 0, False: 16]
  ------------------
  368|      0|            errmsg = "Name too long";
  369|      0|            break;
  370|      0|        case XML_ERR_INVALID_ENCODING:
  ------------------
  |  Branch (370:9): [True: 0, False: 16]
  ------------------
  371|      0|            errmsg = "Invalid bytes in character encoding";
  372|      0|            break;
  373|      0|        case XML_IO_UNKNOWN:
  ------------------
  |  Branch (373:9): [True: 0, False: 16]
  ------------------
  374|      0|            errmsg = "I/O error";
  375|      0|            break;
  376|       |#if 0
  377|       |        case:
  378|       |            errmsg = "";
  379|       |            break;
  380|       |#endif
  381|      0|        default:
  ------------------
  |  Branch (381:9): [True: 0, False: 16]
  ------------------
  382|      0|            errmsg = "Unregistered error message";
  383|     16|    }
  384|     16|    if (ctxt != NULL)
  ------------------
  |  Branch (384:9): [True: 16, False: 0]
  ------------------
  385|     16|	ctxt->errNo = error;
  386|     16|    if (info == NULL) {
  ------------------
  |  Branch (386:9): [True: 10, False: 6]
  ------------------
  387|     10|        __xmlRaiseError(NULL, NULL, NULL, ctxt, NULL, XML_FROM_PARSER, error,
  388|     10|                        XML_ERR_FATAL, NULL, 0, info, NULL, NULL, 0, 0, "%s\n",
  389|     10|                        errmsg);
  390|     10|    } else {
  391|      6|        __xmlRaiseError(NULL, NULL, NULL, ctxt, NULL, XML_FROM_PARSER, error,
  392|      6|                        XML_ERR_FATAL, NULL, 0, info, NULL, NULL, 0, 0, "%s: %s\n",
  393|      6|                        errmsg, info);
  394|      6|    }
  395|     16|    if (ctxt != NULL) {
  ------------------
  |  Branch (395:9): [True: 16, False: 0]
  ------------------
  396|     16|	ctxt->wellFormed = 0;
  397|     16|	if (ctxt->recovery == 0)
  ------------------
  |  Branch (397:6): [True: 16, False: 0]
  ------------------
  398|     16|	    ctxt->disableSAX = 1;
  399|     16|    }
  400|     16|}
xmlParserGrow:
  511|  17.1k|xmlParserGrow(xmlParserCtxtPtr ctxt) {
  512|  17.1k|    xmlParserInputPtr in = ctxt->input;
  513|  17.1k|    xmlParserInputBufferPtr buf = in->buf;
  514|  17.1k|    ptrdiff_t curEnd = in->end - in->cur;
  515|  17.1k|    ptrdiff_t curBase = in->cur - in->base;
  516|  17.1k|    int ret;
  517|       |
  518|  17.1k|    if (buf == NULL)
  ------------------
  |  Branch (518:9): [True: 0, False: 17.1k]
  ------------------
  519|      0|        return(0);
  520|       |    /* Don't grow push parser buffer. */
  521|  17.1k|    if ((ctxt->progressive) && (ctxt->inputNr <= 1))
  ------------------
  |  Branch (521:9): [True: 0, False: 17.1k]
  |  Branch (521:32): [True: 0, False: 0]
  ------------------
  522|      0|        return(0);
  523|  17.1k|    if (buf->error != 0)
  ------------------
  |  Branch (523:9): [True: 0, False: 17.1k]
  ------------------
  524|      0|        return(-1);
  525|       |
  526|  17.1k|    if (((curEnd > XML_MAX_LOOKUP_LIMIT) ||
  ------------------
  |  |   81|  17.1k|#define XML_MAX_LOOKUP_LIMIT 10000000
  ------------------
  |  Branch (526:10): [True: 0, False: 17.1k]
  ------------------
  527|  17.1k|         (curBase > XML_MAX_LOOKUP_LIMIT)) &&
  ------------------
  |  |   81|  17.1k|#define XML_MAX_LOOKUP_LIMIT 10000000
  ------------------
  |  Branch (527:10): [True: 0, False: 17.1k]
  ------------------
  528|  17.1k|        ((ctxt->options & XML_PARSE_HUGE) == 0)) {
  ------------------
  |  Branch (528:9): [True: 0, False: 0]
  ------------------
  529|      0|        xmlErrMemory(ctxt, "Huge input lookup");
  530|      0|        xmlHaltParser(ctxt);
  531|      0|	return(-1);
  532|      0|    }
  533|       |
  534|  17.1k|    if (curEnd >= INPUT_CHUNK)
  ------------------
  |  |   97|  17.1k|#define INPUT_CHUNK	250
  ------------------
  |  Branch (534:9): [True: 222, False: 16.8k]
  ------------------
  535|    222|        return(0);
  536|       |
  537|  16.8k|    ret = xmlParserInputBufferGrow(buf, INPUT_CHUNK);
  ------------------
  |  |   97|  16.8k|#define INPUT_CHUNK	250
  ------------------
  538|  16.8k|    xmlBufUpdateInput(buf->buffer, in, curBase);
  539|       |
  540|  16.8k|    if (ret < 0) {
  ------------------
  |  Branch (540:9): [True: 0, False: 16.8k]
  ------------------
  541|      0|        xmlFatalErr(ctxt, buf->error, NULL);
  542|       |        /* Buffer contents may be lost in case of memory errors. */
  543|      0|        if (buf->error == XML_ERR_NO_MEMORY)
  ------------------
  |  Branch (543:13): [True: 0, False: 0]
  ------------------
  544|      0|            xmlHaltParser(ctxt);
  545|      0|    }
  546|       |
  547|  16.8k|    return(ret);
  548|  17.1k|}
xmlParserShrink:
  600|    200|xmlParserShrink(xmlParserCtxtPtr ctxt) {
  601|    200|    xmlParserInputPtr in = ctxt->input;
  602|    200|    xmlParserInputBufferPtr buf = in->buf;
  603|    200|    size_t used;
  604|       |
  605|    200|    if (buf == NULL)
  ------------------
  |  Branch (605:9): [True: 0, False: 200]
  ------------------
  606|      0|        return;
  607|       |
  608|    200|    used = in->cur - in->base;
  609|       |    /*
  610|       |     * Do not shrink on large buffers whose only a tiny fraction
  611|       |     * was consumed
  612|       |     */
  613|    200|    if (used > INPUT_CHUNK) {
  ------------------
  |  |   97|    200|#define INPUT_CHUNK	250
  ------------------
  |  Branch (613:9): [True: 200, False: 0]
  ------------------
  614|    200|	size_t res = xmlBufShrink(buf->buffer, used - LINE_LEN);
  ------------------
  |  |  451|    200|#define LINE_LEN        80
  ------------------
  615|       |
  616|    200|	if (res > 0) {
  ------------------
  |  Branch (616:6): [True: 200, False: 0]
  ------------------
  617|    200|            used -= res;
  618|    200|            if ((res > ULONG_MAX) ||
  ------------------
  |  Branch (618:17): [True: 0, False: 200]
  ------------------
  619|    200|                (in->consumed > ULONG_MAX - (unsigned long)res))
  ------------------
  |  Branch (619:17): [True: 0, False: 200]
  ------------------
  620|      0|                in->consumed = ULONG_MAX;
  621|    200|            else
  622|    200|                in->consumed += res;
  623|    200|	}
  624|    200|    }
  625|       |
  626|    200|    xmlBufUpdateInput(buf->buffer, in, used);
  627|    200|}
xmlNextChar:
  698|  11.2k|{
  699|  11.2k|    const unsigned char *cur;
  700|  11.2k|    size_t avail;
  701|  11.2k|    int c;
  702|       |
  703|  11.2k|    if ((ctxt == NULL) || (ctxt->instate == XML_PARSER_EOF) ||
  ------------------
  |  Branch (703:9): [True: 0, False: 11.2k]
  |  Branch (703:27): [True: 0, False: 11.2k]
  ------------------
  704|  11.2k|        (ctxt->input == NULL))
  ------------------
  |  Branch (704:9): [True: 0, False: 11.2k]
  ------------------
  705|      0|        return;
  706|       |
  707|  11.2k|    avail = ctxt->input->end - ctxt->input->cur;
  708|       |
  709|  11.2k|    if (avail < INPUT_CHUNK) {
  ------------------
  |  |   97|  11.2k|#define INPUT_CHUNK	250
  ------------------
  |  Branch (709:9): [True: 2.03k, False: 9.17k]
  ------------------
  710|  2.03k|        xmlParserGrow(ctxt);
  711|  2.03k|        if ((ctxt->instate == XML_PARSER_EOF) ||
  ------------------
  |  Branch (711:13): [True: 0, False: 2.03k]
  ------------------
  712|  2.03k|            (ctxt->input->cur >= ctxt->input->end))
  ------------------
  |  Branch (712:13): [True: 0, False: 2.03k]
  ------------------
  713|      0|            return;
  714|  2.03k|        avail = ctxt->input->end - ctxt->input->cur;
  715|  2.03k|    }
  716|       |
  717|  11.2k|    cur = ctxt->input->cur;
  718|  11.2k|    c = *cur;
  719|       |
  720|  11.2k|    if (c < 0x80) {
  ------------------
  |  Branch (720:9): [True: 11.1k, False: 16]
  ------------------
  721|  11.1k|        if (c == '\n') {
  ------------------
  |  Branch (721:13): [True: 0, False: 11.1k]
  ------------------
  722|      0|            ctxt->input->cur++;
  723|      0|            ctxt->input->line++;
  724|      0|            ctxt->input->col = 1;
  725|  11.1k|        } else if (c == '\r') {
  ------------------
  |  Branch (725:20): [True: 0, False: 11.1k]
  ------------------
  726|       |            /*
  727|       |             *   2.11 End-of-Line Handling
  728|       |             *   the literal two-character sequence "#xD#xA" or a standalone
  729|       |             *   literal #xD, an XML processor must pass to the application
  730|       |             *   the single character #xA.
  731|       |             */
  732|      0|            ctxt->input->cur += ((cur[1] == '\n') ? 2 : 1);
  ------------------
  |  Branch (732:34): [True: 0, False: 0]
  ------------------
  733|      0|            ctxt->input->line++;
  734|      0|            ctxt->input->col = 1;
  735|      0|            return;
  736|  11.1k|        } else {
  737|  11.1k|            ctxt->input->cur++;
  738|  11.1k|            ctxt->input->col++;
  739|  11.1k|        }
  740|  11.1k|    } else {
  741|     16|        ctxt->input->col++;
  742|       |
  743|     16|        if ((avail < 2) || (cur[1] & 0xc0) != 0x80)
  ------------------
  |  Branch (743:13): [True: 0, False: 16]
  |  Branch (743:28): [True: 2, False: 14]
  ------------------
  744|      2|            goto encoding_error;
  745|       |
  746|     14|        if (c < 0xe0) {
  ------------------
  |  Branch (746:13): [True: 14, False: 0]
  ------------------
  747|       |            /* 2-byte code */
  748|     14|            if (c < 0xc2)
  ------------------
  |  Branch (748:17): [True: 14, False: 0]
  ------------------
  749|     14|                goto encoding_error;
  750|      0|            ctxt->input->cur += 2;
  751|      0|        } else {
  752|      0|            unsigned int val = (c << 8) | cur[1];
  753|       |
  754|      0|            if ((avail < 3) || (cur[2] & 0xc0) != 0x80)
  ------------------
  |  Branch (754:17): [True: 0, False: 0]
  |  Branch (754:32): [True: 0, False: 0]
  ------------------
  755|      0|                goto encoding_error;
  756|       |
  757|      0|            if (c < 0xf0) {
  ------------------
  |  Branch (757:17): [True: 0, False: 0]
  ------------------
  758|       |                /* 3-byte code */
  759|      0|                if ((val < 0xe0a0) || ((val >= 0xeda0) && (val < 0xee00)))
  ------------------
  |  Branch (759:21): [True: 0, False: 0]
  |  Branch (759:40): [True: 0, False: 0]
  |  Branch (759:59): [True: 0, False: 0]
  ------------------
  760|      0|                    goto encoding_error;
  761|      0|                ctxt->input->cur += 3;
  762|      0|            } else {
  763|      0|                if ((avail < 4) || ((cur[3] & 0xc0) != 0x80))
  ------------------
  |  Branch (763:21): [True: 0, False: 0]
  |  Branch (763:36): [True: 0, False: 0]
  ------------------
  764|      0|                    goto encoding_error;
  765|       |
  766|       |                /* 4-byte code */
  767|      0|                if ((val < 0xf090) || (val >= 0xf490))
  ------------------
  |  Branch (767:21): [True: 0, False: 0]
  |  Branch (767:39): [True: 0, False: 0]
  ------------------
  768|      0|                    goto encoding_error;
  769|      0|                ctxt->input->cur += 4;
  770|      0|            }
  771|      0|        }
  772|     14|    }
  773|       |
  774|  11.1k|    return;
  775|       |
  776|  11.1k|encoding_error:
  777|       |    /* Only report the first error */
  778|     16|    if ((ctxt->input->flags & XML_INPUT_ENCODING_ERROR) == 0) {
  ------------------
  |  |   27|     16|#define XML_INPUT_ENCODING_ERROR    (1u << 5)
  ------------------
  |  Branch (778:9): [True: 2, False: 14]
  ------------------
  779|      2|        if ((ctxt == NULL) || (ctxt->input == NULL) ||
  ------------------
  |  Branch (779:13): [True: 0, False: 2]
  |  Branch (779:31): [True: 0, False: 2]
  ------------------
  780|      2|            (ctxt->input->end - ctxt->input->cur < 4)) {
  ------------------
  |  Branch (780:13): [True: 0, False: 2]
  ------------------
  781|      0|            __xmlErrEncoding(ctxt, XML_ERR_INVALID_CHAR,
  782|      0|                         "Input is not proper UTF-8, indicate encoding !\n",
  783|      0|                         NULL, NULL);
  784|      2|        } else {
  785|      2|            char buffer[150];
  786|       |
  787|      2|            snprintf(buffer, 149, "Bytes: 0x%02X 0x%02X 0x%02X 0x%02X\n",
  788|      2|                            ctxt->input->cur[0], ctxt->input->cur[1],
  789|      2|                            ctxt->input->cur[2], ctxt->input->cur[3]);
  790|      2|            __xmlErrEncoding(ctxt, XML_ERR_INVALID_CHAR,
  791|      2|                         "Input is not proper UTF-8, indicate encoding !\n%s",
  792|      2|                         BAD_CAST buffer, NULL);
  ------------------
  |  |   35|      2|#define BAD_CAST (xmlChar *)
  ------------------
  793|      2|        }
  794|      2|        ctxt->input->flags |= XML_INPUT_ENCODING_ERROR;
  ------------------
  |  |   27|      2|#define XML_INPUT_ENCODING_ERROR    (1u << 5)
  ------------------
  795|      2|    }
  796|     16|    ctxt->input->cur++;
  797|     16|    return;
  798|  11.2k|}
xmlCurrentChar:
  821|  3.45k|xmlCurrentChar(xmlParserCtxtPtr ctxt, int *len) {
  822|  3.45k|    const unsigned char *cur;
  823|  3.45k|    size_t avail;
  824|  3.45k|    int c;
  825|       |
  826|  3.45k|    if ((ctxt == NULL) || (len == NULL) || (ctxt->input == NULL)) return(0);
  ------------------
  |  Branch (826:9): [True: 0, False: 3.45k]
  |  Branch (826:27): [True: 0, False: 3.45k]
  |  Branch (826:44): [True: 0, False: 3.45k]
  ------------------
  827|  3.45k|    if (ctxt->instate == XML_PARSER_EOF)
  ------------------
  |  Branch (827:9): [True: 0, False: 3.45k]
  ------------------
  828|      0|	return(0);
  829|       |
  830|  3.45k|    avail = ctxt->input->end - ctxt->input->cur;
  831|       |
  832|  3.45k|    if (avail < INPUT_CHUNK) {
  ------------------
  |  |   97|  3.45k|#define INPUT_CHUNK	250
  ------------------
  |  Branch (832:9): [True: 184, False: 3.27k]
  ------------------
  833|    184|        xmlParserGrow(ctxt);
  834|    184|        if (ctxt->instate == XML_PARSER_EOF)
  ------------------
  |  Branch (834:13): [True: 0, False: 184]
  ------------------
  835|      0|            return(0);
  836|    184|        avail = ctxt->input->end - ctxt->input->cur;
  837|    184|    }
  838|       |
  839|  3.45k|    cur = ctxt->input->cur;
  840|  3.45k|    c = *cur;
  841|       |
  842|  3.45k|    if (c < 0x80) {
  ------------------
  |  Branch (842:9): [True: 3.35k, False: 104]
  ------------------
  843|       |	/* 1-byte code */
  844|  3.35k|        if (c < 0x20) {
  ------------------
  |  Branch (844:13): [True: 228, False: 3.12k]
  ------------------
  845|       |            /*
  846|       |             *   2.11 End-of-Line Handling
  847|       |             *   the literal two-character sequence "#xD#xA" or a standalone
  848|       |             *   literal #xD, an XML processor must pass to the application
  849|       |             *   the single character #xA.
  850|       |             */
  851|    228|            if (c == '\r') {
  ------------------
  |  Branch (851:17): [True: 49, False: 179]
  ------------------
  852|     49|                *len = ((cur[1] == '\n') ? 2 : 1);
  ------------------
  |  Branch (852:25): [True: 49, False: 0]
  ------------------
  853|     49|                c = '\n';
  854|    179|            } else if (c == 0) {
  ------------------
  |  Branch (854:24): [True: 14, False: 165]
  ------------------
  855|     14|                if (ctxt->input->cur >= ctxt->input->end) {
  ------------------
  |  Branch (855:21): [True: 5, False: 9]
  ------------------
  856|      5|                    *len = 0;
  857|      9|                } else {
  858|      9|                    *len = 1;
  859|       |                    /*
  860|       |                     * TODO: Null bytes should be handled by callers,
  861|       |                     * but this can be tricky.
  862|       |                     */
  863|      9|                    xmlErrEncodingInt(ctxt, XML_ERR_INVALID_CHAR,
  864|      9|                            "Char 0x0 out of allowed range\n", c);
  865|      9|                }
  866|    165|            } else {
  867|    165|                *len = 1;
  868|    165|            }
  869|  3.12k|        } else {
  870|  3.12k|            *len = 1;
  871|  3.12k|        }
  872|       |
  873|  3.35k|        return(c);
  874|  3.35k|    } else {
  875|    104|        int val;
  876|       |
  877|    104|        if (avail < 2)
  ------------------
  |  Branch (877:13): [True: 0, False: 104]
  ------------------
  878|      0|            goto incomplete_sequence;
  879|    104|        if ((cur[1] & 0xc0) != 0x80)
  ------------------
  |  Branch (879:13): [True: 24, False: 80]
  ------------------
  880|     24|            goto encoding_error;
  881|       |
  882|     80|        if (c < 0xe0) {
  ------------------
  |  Branch (882:13): [True: 80, False: 0]
  ------------------
  883|       |            /* 2-byte code */
  884|     80|            if (c < 0xc2)
  ------------------
  |  Branch (884:17): [True: 5, False: 75]
  ------------------
  885|      5|                goto encoding_error;
  886|     75|            val = (c & 0x1f) << 6;
  887|     75|            val |= cur[1] & 0x3f;
  888|     75|            *len = 2;
  889|     75|        } else {
  890|      0|            if (avail < 3)
  ------------------
  |  Branch (890:17): [True: 0, False: 0]
  ------------------
  891|      0|                goto incomplete_sequence;
  892|      0|            if ((cur[2] & 0xc0) != 0x80)
  ------------------
  |  Branch (892:17): [True: 0, False: 0]
  ------------------
  893|      0|                goto encoding_error;
  894|       |
  895|      0|            if (c < 0xf0) {
  ------------------
  |  Branch (895:17): [True: 0, False: 0]
  ------------------
  896|       |                /* 3-byte code */
  897|      0|                val = (c & 0xf) << 12;
  898|      0|                val |= (cur[1] & 0x3f) << 6;
  899|      0|                val |= cur[2] & 0x3f;
  900|      0|                if ((val < 0x800) || ((val >= 0xd800) && (val < 0xe000)))
  ------------------
  |  Branch (900:21): [True: 0, False: 0]
  |  Branch (900:39): [True: 0, False: 0]
  |  Branch (900:58): [True: 0, False: 0]
  ------------------
  901|      0|                    goto encoding_error;
  902|      0|                *len = 3;
  903|      0|            } else {
  904|      0|                if (avail < 4)
  ------------------
  |  Branch (904:21): [True: 0, False: 0]
  ------------------
  905|      0|                    goto incomplete_sequence;
  906|      0|                if ((cur[3] & 0xc0) != 0x80)
  ------------------
  |  Branch (906:21): [True: 0, False: 0]
  ------------------
  907|      0|                    goto encoding_error;
  908|       |
  909|       |                /* 4-byte code */
  910|      0|                val = (c & 0x0f) << 18;
  911|      0|                val |= (cur[1] & 0x3f) << 12;
  912|      0|                val |= (cur[2] & 0x3f) << 6;
  913|      0|                val |= cur[3] & 0x3f;
  914|      0|                if ((val < 0x10000) || (val >= 0x110000))
  ------------------
  |  Branch (914:21): [True: 0, False: 0]
  |  Branch (914:40): [True: 0, False: 0]
  ------------------
  915|      0|                    goto encoding_error;
  916|      0|                *len = 4;
  917|      0|            }
  918|      0|        }
  919|       |
  920|     75|        return(val);
  921|     80|    }
  922|       |
  923|     29|encoding_error:
  924|       |    /* Only report the first error */
  925|     29|    if ((ctxt->input->flags & XML_INPUT_ENCODING_ERROR) == 0) {
  ------------------
  |  |   27|     29|#define XML_INPUT_ENCODING_ERROR    (1u << 5)
  ------------------
  |  Branch (925:9): [True: 7, False: 22]
  ------------------
  926|      7|        if (ctxt->input->end - ctxt->input->cur < 4) {
  ------------------
  |  Branch (926:13): [True: 0, False: 7]
  ------------------
  927|      0|            __xmlErrEncoding(ctxt, XML_ERR_INVALID_CHAR,
  928|      0|                         "Input is not proper UTF-8, indicate encoding !\n",
  929|      0|                         NULL, NULL);
  930|      7|        } else {
  931|      7|            char buffer[150];
  932|       |
  933|      7|            snprintf(&buffer[0], 149, "Bytes: 0x%02X 0x%02X 0x%02X 0x%02X\n",
  934|      7|                            ctxt->input->cur[0], ctxt->input->cur[1],
  935|      7|                            ctxt->input->cur[2], ctxt->input->cur[3]);
  936|      7|            __xmlErrEncoding(ctxt, XML_ERR_INVALID_CHAR,
  937|      7|                         "Input is not proper UTF-8, indicate encoding !\n%s",
  938|      7|                         BAD_CAST buffer, NULL);
  ------------------
  |  |   35|      7|#define BAD_CAST (xmlChar *)
  ------------------
  939|      7|        }
  940|      7|        ctxt->input->flags |= XML_INPUT_ENCODING_ERROR;
  ------------------
  |  |   27|      7|#define XML_INPUT_ENCODING_ERROR    (1u << 5)
  ------------------
  941|      7|    }
  942|     29|    *len = 1;
  943|     29|    return(0xFFFD); /* U+FFFD Replacement Character */
  944|       |
  945|      0|incomplete_sequence:
  946|       |    /*
  947|       |     * An encoding problem may arise from a truncated input buffer
  948|       |     * splitting a character in the middle. In that case do not raise
  949|       |     * an error but return 0. This should only happen when push parsing
  950|       |     * char data.
  951|       |     */
  952|      0|    *len = 0;
  953|      0|    return(0);
  954|  3.45k|}
xmlStringCurrentChar:
  972|    240|                     const xmlChar *cur, int *len) {
  973|    240|    int c;
  974|       |
  975|    240|    if ((cur == NULL) || (len == NULL))
  ------------------
  |  Branch (975:9): [True: 0, False: 240]
  |  Branch (975:26): [True: 0, False: 240]
  ------------------
  976|      0|        return(0);
  977|       |
  978|       |    /* cur is zero-terminated, so we can lie about its length. */
  979|    240|    *len = 4;
  980|    240|    c = xmlGetUTF8Char(cur, len);
  981|       |
  982|    240|    return((c < 0) ? 0 : c);
  ------------------
  |  Branch (982:12): [True: 0, False: 240]
  ------------------
  983|    240|}
xmlCopyCharMultiByte:
  995|    100|xmlCopyCharMultiByte(xmlChar *out, int val) {
  996|    100|    if ((out == NULL) || (val < 0)) return(0);
  ------------------
  |  Branch (996:9): [True: 0, False: 100]
  |  Branch (996:26): [True: 0, False: 100]
  ------------------
  997|       |    /*
  998|       |     * We are supposed to handle UTF8, check it's valid
  999|       |     * From rfc2044: encoding of the Unicode values on UTF-8:
 1000|       |     *
 1001|       |     * UCS-4 range (hex.)           UTF-8 octet sequence (binary)
 1002|       |     * 0000 0000-0000 007F   0xxxxxxx
 1003|       |     * 0000 0080-0000 07FF   110xxxxx 10xxxxxx
 1004|       |     * 0000 0800-0000 FFFF   1110xxxx 10xxxxxx 10xxxxxx
 1005|       |     */
 1006|    100|    if  (val >= 0x80) {
  ------------------
  |  Branch (1006:10): [True: 100, False: 0]
  ------------------
 1007|    100|	xmlChar *savedout = out;
 1008|    100|	int bits;
 1009|    100|	if (val <   0x800) { *out++= (val >>  6) | 0xC0;  bits=  0; }
  ------------------
  |  Branch (1009:6): [True: 75, False: 25]
  ------------------
 1010|     25|	else if (val < 0x10000) { *out++= (val >> 12) | 0xE0;  bits=  6;}
  ------------------
  |  Branch (1010:11): [True: 25, False: 0]
  ------------------
 1011|      0|	else if (val < 0x110000)  { *out++= (val >> 18) | 0xF0;  bits=  12; }
  ------------------
  |  Branch (1011:11): [True: 0, False: 0]
  ------------------
 1012|      0|	else {
 1013|      0|	    xmlErrEncodingInt(NULL, XML_ERR_INVALID_CHAR,
 1014|      0|		    "Internal error, xmlCopyCharMultiByte 0x%X out of bound\n",
 1015|      0|			      val);
 1016|      0|	    return(0);
 1017|      0|	}
 1018|    225|	for ( ; bits >= 0; bits-= 6)
  ------------------
  |  Branch (1018:10): [True: 125, False: 100]
  ------------------
 1019|    125|	    *out++= ((val >> bits) & 0x3F) | 0x80 ;
 1020|    100|	return (out - savedout);
 1021|    100|    }
 1022|      0|    *out = val;
 1023|      0|    return 1;
 1024|    100|}
xmlSwitchInputEncoding:
 1189|    123|{
 1190|    123|    int nbchars;
 1191|    123|    xmlParserInputBufferPtr in;
 1192|       |
 1193|    123|    if ((input == NULL) || (input->buf == NULL)) {
  ------------------
  |  Branch (1193:9): [True: 0, False: 123]
  |  Branch (1193:28): [True: 0, False: 123]
  ------------------
 1194|      0|        xmlCharEncCloseFunc(handler);
 1195|      0|	return (-1);
 1196|      0|    }
 1197|    123|    in = input->buf;
 1198|       |
 1199|    123|    input->flags |= XML_INPUT_HAS_ENCODING;
  ------------------
  |  |   20|    123|#define XML_INPUT_HAS_ENCODING      (1u << 0)
  ------------------
 1200|       |
 1201|       |    /*
 1202|       |     * UTF-8 requires no encoding handler.
 1203|       |     */
 1204|    123|    if ((handler != NULL) &&
  ------------------
  |  Branch (1204:9): [True: 123, False: 0]
  ------------------
 1205|    123|        (xmlStrcasecmp(BAD_CAST handler->name, BAD_CAST "UTF-8") == 0)) {
  ------------------
  |  |   35|    123|#define BAD_CAST (xmlChar *)
  ------------------
                      (xmlStrcasecmp(BAD_CAST handler->name, BAD_CAST "UTF-8") == 0)) {
  ------------------
  |  |   35|    123|#define BAD_CAST (xmlChar *)
  ------------------
  |  Branch (1205:9): [True: 71, False: 52]
  ------------------
 1206|     71|        xmlCharEncCloseFunc(handler);
 1207|     71|        handler = NULL;
 1208|     71|    }
 1209|       |
 1210|    123|    if (in->encoder == handler)
  ------------------
  |  Branch (1210:9): [True: 71, False: 52]
  ------------------
 1211|     71|        return (0);
 1212|       |
 1213|     52|    if (in->encoder != NULL) {
  ------------------
  |  Branch (1213:9): [True: 0, False: 52]
  ------------------
 1214|       |        /*
 1215|       |         * Switching encodings during parsing is a really bad idea,
 1216|       |         * but Chromium can switch between ISO-8859-1 and UTF-16 before
 1217|       |         * separate calls to xmlParseChunk.
 1218|       |         *
 1219|       |         * TODO: We should check whether the "raw" input buffer is empty and
 1220|       |         * convert the old content using the old encoder.
 1221|       |         */
 1222|       |
 1223|      0|        xmlCharEncCloseFunc(in->encoder);
 1224|      0|        in->encoder = handler;
 1225|      0|        return (0);
 1226|      0|    }
 1227|       |
 1228|     52|    in->encoder = handler;
 1229|       |
 1230|       |    /*
 1231|       |     * Is there already some content down the pipe to convert ?
 1232|       |     */
 1233|     52|    if (xmlBufIsEmpty(in->buffer) == 0) {
  ------------------
  |  Branch (1233:9): [True: 52, False: 0]
  ------------------
 1234|     52|        size_t processed;
 1235|       |
 1236|       |        /*
 1237|       |         * Shrink the current input buffer.
 1238|       |         * Move it as the raw buffer and create a new input buffer
 1239|       |         */
 1240|     52|        processed = input->cur - input->base;
 1241|     52|        xmlBufShrink(in->buffer, processed);
 1242|     52|        input->consumed += processed;
 1243|     52|        in->raw = in->buffer;
 1244|     52|        in->buffer = xmlBufCreate();
 1245|     52|        in->rawconsumed = processed;
 1246|       |
 1247|     52|        nbchars = xmlCharEncInput(in);
 1248|     52|        xmlBufResetInput(in->buffer, input);
 1249|     52|        if (nbchars < 0) {
  ------------------
  |  Branch (1249:13): [True: 0, False: 52]
  ------------------
 1250|       |            /* TODO: This could be an out of memory or an encoding error. */
 1251|      0|            xmlErrInternal(ctxt,
 1252|      0|                           "switching encoding: encoder error\n",
 1253|      0|                           NULL);
 1254|      0|            xmlHaltParser(ctxt);
 1255|      0|            return (-1);
 1256|      0|        }
 1257|     52|    }
 1258|     52|    return (0);
 1259|     52|}
xmlSwitchToEncoding:
 1275|    123|{
 1276|    123|    if (ctxt == NULL)
  ------------------
  |  Branch (1276:9): [True: 0, False: 123]
  ------------------
 1277|      0|        return(-1);
 1278|    123|    return(xmlSwitchInputEncoding(ctxt, ctxt->input, handler));
 1279|    123|}
xmlDetectEncoding:
 1290|    238|xmlDetectEncoding(xmlParserCtxtPtr ctxt) {
 1291|    238|    const xmlChar *in;
 1292|    238|    xmlCharEncoding enc;
 1293|    238|    int bomSize;
 1294|    238|    int autoFlag = 0;
 1295|       |
 1296|    238|    if (xmlParserGrow(ctxt) < 0)
  ------------------
  |  Branch (1296:9): [True: 0, False: 238]
  ------------------
 1297|      0|        return;
 1298|    238|    in = ctxt->input->cur;
 1299|    238|    if (ctxt->input->end - in < 4)
  ------------------
  |  Branch (1299:9): [True: 0, False: 238]
  ------------------
 1300|      0|        return;
 1301|       |
 1302|    238|    if (ctxt->input->flags & XML_INPUT_HAS_ENCODING) {
  ------------------
  |  |   20|    238|#define XML_INPUT_HAS_ENCODING      (1u << 0)
  ------------------
  |  Branch (1302:9): [True: 0, False: 238]
  ------------------
 1303|       |        /*
 1304|       |         * If the encoding was already set, only skip the BOM which was
 1305|       |         * possibly decoded to UTF-8.
 1306|       |         */
 1307|      0|        if ((in[0] == 0xEF) && (in[1] == 0xBB) && (in[2] == 0xBF)) {
  ------------------
  |  Branch (1307:13): [True: 0, False: 0]
  |  Branch (1307:32): [True: 0, False: 0]
  |  Branch (1307:51): [True: 0, False: 0]
  ------------------
 1308|      0|            ctxt->input->cur += 3;
 1309|      0|        }
 1310|       |
 1311|      0|        return;
 1312|      0|    }
 1313|       |
 1314|    238|    enc = XML_CHAR_ENCODING_NONE;
 1315|    238|    bomSize = 0;
 1316|       |
 1317|    238|    switch (in[0]) {
  ------------------
  |  Branch (1317:13): [True: 1, False: 237]
  ------------------
 1318|      0|        case 0x00:
  ------------------
  |  Branch (1318:9): [True: 0, False: 238]
  ------------------
 1319|      0|            if ((in[1] == 0x00) && (in[2] == 0x00) && (in[3] == 0x3C)) {
  ------------------
  |  Branch (1319:17): [True: 0, False: 0]
  |  Branch (1319:36): [True: 0, False: 0]
  |  Branch (1319:55): [True: 0, False: 0]
  ------------------
 1320|      0|                enc = XML_CHAR_ENCODING_UCS4BE;
 1321|      0|                autoFlag = XML_INPUT_AUTO_OTHER;
  ------------------
  |  |   25|      0|#define XML_INPUT_AUTO_OTHER        (4u << 1)
  ------------------
 1322|      0|            } else if ((in[1] == 0x3C) && (in[2] == 0x00) && (in[3] == 0x3F)) {
  ------------------
  |  Branch (1322:24): [True: 0, False: 0]
  |  Branch (1322:43): [True: 0, False: 0]
  |  Branch (1322:62): [True: 0, False: 0]
  ------------------
 1323|      0|                enc = XML_CHAR_ENCODING_UTF16BE;
 1324|      0|                autoFlag = XML_INPUT_AUTO_UTF16BE;
  ------------------
  |  |   24|      0|#define XML_INPUT_AUTO_UTF16BE      (3u << 1)
  ------------------
 1325|      0|            }
 1326|      0|            break;
 1327|       |
 1328|    237|        case 0x3C:
  ------------------
  |  Branch (1328:9): [True: 237, False: 1]
  ------------------
 1329|    237|            if (in[1] == 0x00) {
  ------------------
  |  Branch (1329:17): [True: 0, False: 237]
  ------------------
 1330|      0|                if ((in[2] == 0x00) && (in[3] == 0x00)) {
  ------------------
  |  Branch (1330:21): [True: 0, False: 0]
  |  Branch (1330:40): [True: 0, False: 0]
  ------------------
 1331|      0|                    enc = XML_CHAR_ENCODING_UCS4LE;
 1332|      0|                    autoFlag = XML_INPUT_AUTO_OTHER;
  ------------------
  |  |   25|      0|#define XML_INPUT_AUTO_OTHER        (4u << 1)
  ------------------
 1333|      0|                } else if ((in[2] == 0x3F) && (in[3] == 0x00)) {
  ------------------
  |  Branch (1333:28): [True: 0, False: 0]
  |  Branch (1333:47): [True: 0, False: 0]
  ------------------
 1334|      0|                    enc = XML_CHAR_ENCODING_UTF16LE;
 1335|      0|                    autoFlag = XML_INPUT_AUTO_UTF16LE;
  ------------------
  |  |   23|      0|#define XML_INPUT_AUTO_UTF16LE      (2u << 1)
  ------------------
 1336|      0|                }
 1337|      0|            }
 1338|    237|            break;
 1339|       |
 1340|      0|        case 0x4C:
  ------------------
  |  Branch (1340:9): [True: 0, False: 238]
  ------------------
 1341|      0|	    if ((in[1] == 0x6F) && (in[2] == 0xA7) && (in[3] == 0x94)) {
  ------------------
  |  Branch (1341:10): [True: 0, False: 0]
  |  Branch (1341:29): [True: 0, False: 0]
  |  Branch (1341:48): [True: 0, False: 0]
  ------------------
 1342|      0|	        enc = XML_CHAR_ENCODING_EBCDIC;
 1343|      0|                autoFlag = XML_INPUT_AUTO_OTHER;
  ------------------
  |  |   25|      0|#define XML_INPUT_AUTO_OTHER        (4u << 1)
  ------------------
 1344|      0|            }
 1345|      0|            break;
 1346|       |
 1347|      0|        case 0xEF:
  ------------------
  |  Branch (1347:9): [True: 0, False: 238]
  ------------------
 1348|      0|            if ((in[1] == 0xBB) && (in[2] == 0xBF)) {
  ------------------
  |  Branch (1348:17): [True: 0, False: 0]
  |  Branch (1348:36): [True: 0, False: 0]
  ------------------
 1349|      0|                enc = XML_CHAR_ENCODING_UTF8;
 1350|      0|                autoFlag = XML_INPUT_AUTO_UTF8;
  ------------------
  |  |   22|      0|#define XML_INPUT_AUTO_UTF8         (1u << 1)
  ------------------
 1351|      0|                bomSize = 3;
 1352|      0|            }
 1353|      0|            break;
 1354|       |
 1355|      0|        case 0xFE:
  ------------------
  |  Branch (1355:9): [True: 0, False: 238]
  ------------------
 1356|      0|            if (in[1] == 0xFF) {
  ------------------
  |  Branch (1356:17): [True: 0, False: 0]
  ------------------
 1357|      0|                enc = XML_CHAR_ENCODING_UTF16BE;
 1358|      0|                autoFlag = XML_INPUT_AUTO_UTF16BE;
  ------------------
  |  |   24|      0|#define XML_INPUT_AUTO_UTF16BE      (3u << 1)
  ------------------
 1359|      0|                bomSize = 2;
 1360|      0|            }
 1361|      0|            break;
 1362|       |
 1363|      0|        case 0xFF:
  ------------------
  |  Branch (1363:9): [True: 0, False: 238]
  ------------------
 1364|      0|            if (in[1] == 0xFE) {
  ------------------
  |  Branch (1364:17): [True: 0, False: 0]
  ------------------
 1365|      0|                enc = XML_CHAR_ENCODING_UTF16LE;
 1366|      0|                autoFlag = XML_INPUT_AUTO_UTF16LE;
  ------------------
  |  |   23|      0|#define XML_INPUT_AUTO_UTF16LE      (2u << 1)
  ------------------
 1367|      0|                bomSize = 2;
 1368|      0|            }
 1369|      0|            break;
 1370|    238|    }
 1371|       |
 1372|    238|    if (bomSize > 0) {
  ------------------
  |  Branch (1372:9): [True: 0, False: 238]
  ------------------
 1373|      0|        ctxt->input->cur += bomSize;
 1374|      0|    }
 1375|       |
 1376|    238|    if (enc != XML_CHAR_ENCODING_NONE) {
  ------------------
  |  Branch (1376:9): [True: 0, False: 238]
  ------------------
 1377|      0|        ctxt->input->flags |= autoFlag;
 1378|      0|        xmlSwitchEncoding(ctxt, enc);
 1379|      0|    }
 1380|    238|}
xmlSetDeclaredEncoding:
 1395|    123|xmlSetDeclaredEncoding(xmlParserCtxtPtr ctxt, xmlChar *encoding) {
 1396|    123|    if (ctxt->encoding != NULL)
  ------------------
  |  Branch (1396:9): [True: 0, False: 123]
  ------------------
 1397|      0|        xmlFree((xmlChar *) ctxt->encoding);
 1398|    123|    ctxt->encoding = encoding;
 1399|       |
 1400|    123|    if (((ctxt->input->flags & XML_INPUT_HAS_ENCODING) == 0) &&
  ------------------
  |  |   20|    123|#define XML_INPUT_HAS_ENCODING      (1u << 0)
  ------------------
  |  Branch (1400:9): [True: 123, False: 0]
  ------------------
 1401|    123|        ((ctxt->options & XML_PARSE_IGNORE_ENC) == 0)) {
  ------------------
  |  Branch (1401:9): [True: 123, False: 0]
  ------------------
 1402|    123|        xmlCharEncodingHandlerPtr handler;
 1403|       |
 1404|    123|        handler = xmlFindCharEncodingHandler((const char *) encoding);
 1405|    123|        if (handler == NULL) {
  ------------------
  |  Branch (1405:13): [True: 0, False: 123]
  ------------------
 1406|      0|            __xmlErrEncoding(ctxt, XML_ERR_UNSUPPORTED_ENCODING,
 1407|      0|                             "Unsupported encoding: %s\n",
 1408|      0|                             encoding, NULL);
 1409|      0|            return;
 1410|      0|        }
 1411|       |
 1412|    123|        xmlSwitchToEncoding(ctxt, handler);
 1413|    123|        ctxt->input->flags |= XML_INPUT_USES_ENC_DECL;
  ------------------
  |  |   26|    123|#define XML_INPUT_USES_ENC_DECL     (1u << 4)
  ------------------
 1414|    123|    } else if (ctxt->input->flags & XML_INPUT_AUTO_ENCODING) {
  ------------------
  |  |   21|      0|#define XML_INPUT_AUTO_ENCODING     (7u << 1)
  ------------------
  |  Branch (1414:16): [True: 0, False: 0]
  ------------------
 1415|      0|        static const char *allowedUTF8[] = {
 1416|      0|            "UTF-8", "UTF8", NULL
 1417|      0|        };
 1418|      0|        static const char *allowedUTF16LE[] = {
 1419|      0|            "UTF-16", "UTF-16LE", "UTF16", NULL
 1420|      0|        };
 1421|      0|        static const char *allowedUTF16BE[] = {
 1422|      0|            "UTF-16", "UTF-16BE", "UTF16", NULL
 1423|      0|        };
 1424|      0|        const char **allowed = NULL;
 1425|      0|        const char *autoEnc = NULL;
 1426|       |
 1427|      0|        switch (ctxt->input->flags & XML_INPUT_AUTO_ENCODING) {
  ------------------
  |  |   21|      0|#define XML_INPUT_AUTO_ENCODING     (7u << 1)
  ------------------
  |  Branch (1427:17): [True: 0, False: 0]
  ------------------
 1428|      0|            case XML_INPUT_AUTO_UTF8:
  ------------------
  |  |   22|      0|#define XML_INPUT_AUTO_UTF8         (1u << 1)
  ------------------
  |  Branch (1428:13): [True: 0, False: 0]
  ------------------
 1429|      0|                allowed = allowedUTF8;
 1430|      0|                autoEnc = "UTF-8";
 1431|      0|                break;
 1432|      0|            case XML_INPUT_AUTO_UTF16LE:
  ------------------
  |  |   23|      0|#define XML_INPUT_AUTO_UTF16LE      (2u << 1)
  ------------------
  |  Branch (1432:13): [True: 0, False: 0]
  ------------------
 1433|      0|                allowed = allowedUTF16LE;
 1434|      0|                autoEnc = "UTF-16LE";
 1435|      0|                break;
 1436|      0|            case XML_INPUT_AUTO_UTF16BE:
  ------------------
  |  |   24|      0|#define XML_INPUT_AUTO_UTF16BE      (3u << 1)
  ------------------
  |  Branch (1436:13): [True: 0, False: 0]
  ------------------
 1437|      0|                allowed = allowedUTF16BE;
 1438|      0|                autoEnc = "UTF-16BE";
 1439|      0|                break;
 1440|      0|        }
 1441|       |
 1442|      0|        if (allowed != NULL) {
  ------------------
  |  Branch (1442:13): [True: 0, False: 0]
  ------------------
 1443|      0|            const char **p;
 1444|      0|            int match = 0;
 1445|       |
 1446|      0|            for (p = allowed; *p != NULL; p++) {
  ------------------
  |  Branch (1446:31): [True: 0, False: 0]
  ------------------
 1447|      0|                if (xmlStrcasecmp(encoding, BAD_CAST *p) == 0) {
  ------------------
  |  |   35|      0|#define BAD_CAST (xmlChar *)
  ------------------
  |  Branch (1447:21): [True: 0, False: 0]
  ------------------
 1448|      0|                    match = 1;
 1449|      0|                    break;
 1450|      0|                }
 1451|      0|            }
 1452|       |
 1453|      0|            if (match == 0) {
  ------------------
  |  Branch (1453:17): [True: 0, False: 0]
  ------------------
 1454|      0|                xmlWarningMsg(ctxt, XML_WAR_ENCODING_MISMATCH,
 1455|      0|                              "Encoding '%s' doesn't match "
 1456|      0|                              "auto-detected '%s'\n",
 1457|      0|                              encoding, BAD_CAST autoEnc);
  ------------------
  |  |   35|      0|#define BAD_CAST (xmlChar *)
  ------------------
 1458|      0|            }
 1459|      0|        }
 1460|      0|    }
 1461|    123|}
xmlFreeInputStream:
 1476|    238|xmlFreeInputStream(xmlParserInputPtr input) {
 1477|    238|    if (input == NULL) return;
  ------------------
  |  Branch (1477:9): [True: 0, False: 238]
  ------------------
 1478|       |
 1479|    238|    if (input->filename != NULL) xmlFree((char *) input->filename);
  ------------------
  |  Branch (1479:9): [True: 238, False: 0]
  ------------------
 1480|    238|    if (input->directory != NULL) xmlFree((char *) input->directory);
  ------------------
  |  Branch (1480:9): [True: 0, False: 238]
  ------------------
 1481|    238|    if (input->version != NULL) xmlFree((char *) input->version);
  ------------------
  |  Branch (1481:9): [True: 0, False: 238]
  ------------------
 1482|    238|    if ((input->free != NULL) && (input->base != NULL))
  ------------------
  |  Branch (1482:9): [True: 0, False: 238]
  |  Branch (1482:34): [True: 0, False: 0]
  ------------------
 1483|      0|        input->free((xmlChar *) input->base);
 1484|    238|    if (input->buf != NULL)
  ------------------
  |  Branch (1484:9): [True: 238, False: 0]
  ------------------
 1485|    238|        xmlFreeParserInputBuffer(input->buf);
 1486|    238|    xmlFree(input);
 1487|    238|}
xmlNewInputStream:
 1498|    238|xmlNewInputStream(xmlParserCtxtPtr ctxt) {
 1499|    238|    xmlParserInputPtr input;
 1500|       |
 1501|    238|    input = (xmlParserInputPtr) xmlMalloc(sizeof(xmlParserInput));
 1502|    238|    if (input == NULL) {
  ------------------
  |  Branch (1502:9): [True: 0, False: 238]
  ------------------
 1503|      0|        xmlErrMemory(ctxt,  "couldn't allocate a new input stream\n");
 1504|      0|	return(NULL);
 1505|      0|    }
 1506|    238|    memset(input, 0, sizeof(xmlParserInput));
 1507|    238|    input->line = 1;
 1508|    238|    input->col = 1;
 1509|       |
 1510|       |    /*
 1511|       |     * If the context is NULL the id cannot be initialized, but that
 1512|       |     * should not happen while parsing which is the situation where
 1513|       |     * the id is actually needed.
 1514|       |     */
 1515|    238|    if (ctxt != NULL) {
  ------------------
  |  Branch (1515:9): [True: 238, False: 0]
  ------------------
 1516|    238|        if (input->id >= INT_MAX) {
  ------------------
  |  Branch (1516:13): [True: 0, False: 238]
  ------------------
 1517|      0|            xmlErrMemory(ctxt, "Input ID overflow\n");
 1518|      0|            return(NULL);
 1519|      0|        }
 1520|    238|        input->id = ctxt->input_id++;
 1521|    238|    }
 1522|       |
 1523|    238|    return(input);
 1524|    238|}
xmlFreeParserCtxt:
 1967|    242|{
 1968|    242|    xmlParserInputPtr input;
 1969|       |
 1970|    242|    if (ctxt == NULL) return;
  ------------------
  |  Branch (1970:9): [True: 0, False: 242]
  ------------------
 1971|       |
 1972|    480|    while ((input = inputPop(ctxt)) != NULL) { /* Non consuming */
  ------------------
  |  Branch (1972:12): [True: 238, False: 242]
  ------------------
 1973|    238|        xmlFreeInputStream(input);
 1974|    238|    }
 1975|    242|    if (ctxt->spaceTab != NULL) xmlFree(ctxt->spaceTab);
  ------------------
  |  Branch (1975:9): [True: 242, False: 0]
  ------------------
 1976|    242|    if (ctxt->nameTab != NULL) xmlFree((xmlChar * *)ctxt->nameTab);
  ------------------
  |  Branch (1976:9): [True: 242, False: 0]
  ------------------
 1977|    242|    if (ctxt->nodeTab != NULL) xmlFree(ctxt->nodeTab);
  ------------------
  |  Branch (1977:9): [True: 242, False: 0]
  ------------------
 1978|    242|    if (ctxt->nodeInfoTab != NULL) xmlFree(ctxt->nodeInfoTab);
  ------------------
  |  Branch (1978:9): [True: 0, False: 242]
  ------------------
 1979|    242|    if (ctxt->inputTab != NULL) xmlFree(ctxt->inputTab);
  ------------------
  |  Branch (1979:9): [True: 242, False: 0]
  ------------------
 1980|    242|    if (ctxt->version != NULL) xmlFree((char *) ctxt->version);
  ------------------
  |  Branch (1980:9): [True: 238, False: 4]
  ------------------
 1981|    242|    if (ctxt->encoding != NULL) xmlFree((char *) ctxt->encoding);
  ------------------
  |  Branch (1981:9): [True: 123, False: 119]
  ------------------
 1982|    242|    if (ctxt->extSubURI != NULL) xmlFree((char *) ctxt->extSubURI);
  ------------------
  |  Branch (1982:9): [True: 0, False: 242]
  ------------------
 1983|    242|    if (ctxt->extSubSystem != NULL) xmlFree((char *) ctxt->extSubSystem);
  ------------------
  |  Branch (1983:9): [True: 0, False: 242]
  ------------------
 1984|    242|#ifdef LIBXML_SAX1_ENABLED
 1985|    242|    if ((ctxt->sax != NULL) &&
  ------------------
  |  Branch (1985:9): [True: 242, False: 0]
  ------------------
 1986|    242|        (ctxt->sax != (xmlSAXHandlerPtr) &xmlDefaultSAXHandler))
  ------------------
  |  |  860|    242|  #define xmlDefaultSAXHandler XML_GLOBAL_MACRO(xmlDefaultSAXHandler)
  |  |  ------------------
  |  |  |  |  500|    242|  #define XML_GLOBAL_MACRO(name) (*__##name())
  |  |  ------------------
  ------------------
  |  Branch (1986:9): [True: 242, False: 0]
  ------------------
 1987|       |#else
 1988|       |    if (ctxt->sax != NULL)
 1989|       |#endif /* LIBXML_SAX1_ENABLED */
 1990|    242|        xmlFree(ctxt->sax);
 1991|    242|    if (ctxt->directory != NULL) xmlFree((char *) ctxt->directory);
  ------------------
  |  Branch (1991:9): [True: 0, False: 242]
  ------------------
 1992|    242|    if (ctxt->vctxt.nodeTab != NULL) xmlFree(ctxt->vctxt.nodeTab);
  ------------------
  |  Branch (1992:9): [True: 0, False: 242]
  ------------------
 1993|    242|    if (ctxt->atts != NULL) xmlFree((xmlChar * *)ctxt->atts);
  ------------------
  |  Branch (1993:9): [True: 233, False: 9]
  ------------------
 1994|    242|    if (ctxt->dict != NULL) xmlDictFree(ctxt->dict);
  ------------------
  |  Branch (1994:9): [True: 242, False: 0]
  ------------------
 1995|    242|    if (ctxt->nsTab != NULL) xmlFree(ctxt->nsTab);
  ------------------
  |  Branch (1995:9): [True: 235, False: 7]
  ------------------
 1996|    242|    if (ctxt->nsdb != NULL) xmlParserNsFree(ctxt->nsdb);
  ------------------
  |  Branch (1996:9): [True: 242, False: 0]
  ------------------
 1997|    242|    if (ctxt->attrHash != NULL) xmlFree(ctxt->attrHash);
  ------------------
  |  Branch (1997:9): [True: 209, False: 33]
  ------------------
 1998|    242|    if (ctxt->pushTab != NULL) xmlFree(ctxt->pushTab);
  ------------------
  |  Branch (1998:9): [True: 235, False: 7]
  ------------------
 1999|    242|    if (ctxt->attallocs != NULL) xmlFree(ctxt->attallocs);
  ------------------
  |  Branch (1999:9): [True: 233, False: 9]
  ------------------
 2000|    242|    if (ctxt->attsDefault != NULL)
  ------------------
  |  Branch (2000:9): [True: 0, False: 242]
  ------------------
 2001|      0|        xmlHashFree(ctxt->attsDefault, xmlHashDefaultDeallocator);
 2002|    242|    if (ctxt->attsSpecial != NULL)
  ------------------
  |  Branch (2002:9): [True: 0, False: 242]
  ------------------
 2003|      0|        xmlHashFree(ctxt->attsSpecial, NULL);
 2004|    242|    if (ctxt->freeElems != NULL) {
  ------------------
  |  Branch (2004:9): [True: 0, False: 242]
  ------------------
 2005|      0|        xmlNodePtr cur, next;
 2006|       |
 2007|      0|	cur = ctxt->freeElems;
 2008|      0|	while (cur != NULL) {
  ------------------
  |  Branch (2008:9): [True: 0, False: 0]
  ------------------
 2009|      0|	    next = cur->next;
 2010|      0|	    xmlFree(cur);
 2011|      0|	    cur = next;
 2012|      0|	}
 2013|      0|    }
 2014|    242|    if (ctxt->freeAttrs != NULL) {
  ------------------
  |  Branch (2014:9): [True: 0, False: 242]
  ------------------
 2015|      0|        xmlAttrPtr cur, next;
 2016|       |
 2017|      0|	cur = ctxt->freeAttrs;
 2018|      0|	while (cur != NULL) {
  ------------------
  |  Branch (2018:9): [True: 0, False: 0]
  ------------------
 2019|      0|	    next = cur->next;
 2020|      0|	    xmlFree(cur);
 2021|      0|	    cur = next;
 2022|      0|	}
 2023|      0|    }
 2024|       |    /*
 2025|       |     * cleanup the error strings
 2026|       |     */
 2027|    242|    if (ctxt->lastError.message != NULL)
  ------------------
  |  Branch (2027:9): [True: 32, False: 210]
  ------------------
 2028|     32|        xmlFree(ctxt->lastError.message);
 2029|    242|    if (ctxt->lastError.file != NULL)
  ------------------
  |  Branch (2029:9): [True: 32, False: 210]
  ------------------
 2030|     32|        xmlFree(ctxt->lastError.file);
 2031|    242|    if (ctxt->lastError.str1 != NULL)
  ------------------
  |  Branch (2031:9): [True: 26, False: 216]
  ------------------
 2032|     26|        xmlFree(ctxt->lastError.str1);
 2033|    242|    if (ctxt->lastError.str2 != NULL)
  ------------------
  |  Branch (2033:9): [True: 16, False: 226]
  ------------------
 2034|     16|        xmlFree(ctxt->lastError.str2);
 2035|    242|    if (ctxt->lastError.str3 != NULL)
  ------------------
  |  Branch (2035:9): [True: 0, False: 242]
  ------------------
 2036|      0|        xmlFree(ctxt->lastError.str3);
 2037|       |
 2038|    242|#ifdef LIBXML_CATALOG_ENABLED
 2039|    242|    if (ctxt->catalogs != NULL)
  ------------------
  |  Branch (2039:9): [True: 0, False: 242]
  ------------------
 2040|      0|	xmlCatalogFreeLocal(ctxt->catalogs);
 2041|    242|#endif
 2042|    242|    xmlFree(ctxt);
 2043|    242|}
xmlNewParserCtxt:
 2055|    242|{
 2056|    242|    return(xmlNewSAXParserCtxt(NULL, NULL));
 2057|    242|}
xmlNewSAXParserCtxt:
 2072|    242|{
 2073|    242|    xmlParserCtxtPtr ctxt;
 2074|       |
 2075|    242|    ctxt = (xmlParserCtxtPtr) xmlMalloc(sizeof(xmlParserCtxt));
 2076|    242|    if (ctxt == NULL) {
  ------------------
  |  Branch (2076:9): [True: 0, False: 242]
  ------------------
 2077|      0|	xmlErrMemory(NULL, "cannot allocate parser context\n");
 2078|      0|	return(NULL);
 2079|      0|    }
 2080|    242|    memset(ctxt, 0, sizeof(xmlParserCtxt));
 2081|    242|    if (xmlInitSAXParserCtxt(ctxt, sax, userData) < 0) {
  ------------------
  |  Branch (2081:9): [True: 0, False: 242]
  ------------------
 2082|      0|        xmlFreeParserCtxt(ctxt);
 2083|      0|	return(NULL);
 2084|      0|    }
 2085|    242|    return(ctxt);
 2086|    242|}
xmlInitNodeInfoSeq:
 2149|    484|{
 2150|    484|    if (seq == NULL)
  ------------------
  |  Branch (2150:9): [True: 0, False: 484]
  ------------------
 2151|      0|        return;
 2152|    484|    seq->length = 0;
 2153|    484|    seq->maximum = 0;
 2154|    484|    seq->buffer = NULL;
 2155|    484|}
parserInternals.c:xmlErrEncodingInt:
  414|      9|{
  415|      9|    if ((ctxt != NULL) && (ctxt->disableSAX != 0) &&
  ------------------
  |  Branch (415:9): [True: 9, False: 0]
  |  Branch (415:27): [True: 7, False: 2]
  ------------------
  416|      9|        (ctxt->instate == XML_PARSER_EOF))
  ------------------
  |  Branch (416:9): [True: 0, False: 7]
  ------------------
  417|      0|	return;
  418|      9|    if (ctxt != NULL)
  ------------------
  |  Branch (418:9): [True: 9, False: 0]
  ------------------
  419|      9|        ctxt->errNo = error;
  420|      9|    __xmlRaiseError(NULL, NULL, NULL,
  421|      9|                    ctxt, NULL, XML_FROM_PARSER, error, XML_ERR_FATAL,
  422|      9|                    NULL, 0, NULL, NULL, NULL, val, 0, msg, val);
  423|      9|    if (ctxt != NULL) {
  ------------------
  |  Branch (423:9): [True: 9, False: 0]
  ------------------
  424|      9|        ctxt->wellFormed = 0;
  425|      9|        if (ctxt->recovery == 0)
  ------------------
  |  Branch (425:13): [True: 9, False: 0]
  ------------------
  426|      9|            ctxt->disableSAX = 1;
  427|      9|    }
  428|      9|}
parserInternals.c:xmlInitSAXParserCtxt:
 1746|    242|{
 1747|    242|    xmlParserInputPtr input;
 1748|       |
 1749|    242|    if(ctxt==NULL) {
  ------------------
  |  Branch (1749:8): [True: 0, False: 242]
  ------------------
 1750|      0|        xmlErrInternal(NULL, "Got NULL parser context\n", NULL);
 1751|      0|        return(-1);
 1752|      0|    }
 1753|       |
 1754|    242|    xmlInitParser();
 1755|       |
 1756|    242|    if (ctxt->dict == NULL)
  ------------------
  |  Branch (1756:9): [True: 242, False: 0]
  ------------------
 1757|    242|	ctxt->dict = xmlDictCreate();
 1758|    242|    if (ctxt->dict == NULL) {
  ------------------
  |  Branch (1758:9): [True: 0, False: 242]
  ------------------
 1759|      0|        xmlErrMemory(NULL, "cannot initialize parser context\n");
 1760|      0|	return(-1);
 1761|      0|    }
 1762|    242|    xmlDictSetLimit(ctxt->dict, XML_MAX_DICTIONARY_LIMIT);
  ------------------
  |  |   71|    242|#define XML_MAX_DICTIONARY_LIMIT 10000000
  ------------------
 1763|       |
 1764|    242|    if (ctxt->sax == NULL)
  ------------------
  |  Branch (1764:9): [True: 242, False: 0]
  ------------------
 1765|    242|	ctxt->sax = (xmlSAXHandler *) xmlMalloc(sizeof(xmlSAXHandler));
 1766|    242|    if (ctxt->sax == NULL) {
  ------------------
  |  Branch (1766:9): [True: 0, False: 242]
  ------------------
 1767|      0|        xmlErrMemory(NULL, "cannot initialize parser context\n");
 1768|      0|	return(-1);
 1769|      0|    }
 1770|    242|    if (sax == NULL) {
  ------------------
  |  Branch (1770:9): [True: 242, False: 0]
  ------------------
 1771|    242|	memset(ctxt->sax, 0, sizeof(xmlSAXHandler));
 1772|    242|        xmlSAXVersion(ctxt->sax, 2);
 1773|    242|        ctxt->userData = ctxt;
 1774|    242|    } else {
 1775|      0|	if (sax->initialized == XML_SAX2_MAGIC) {
  ------------------
  |  |  685|      0|#define XML_SAX2_MAGIC 0xDEEDBEAF
  ------------------
  |  Branch (1775:6): [True: 0, False: 0]
  ------------------
 1776|      0|	    memcpy(ctxt->sax, sax, sizeof(xmlSAXHandler));
 1777|      0|        } else {
 1778|      0|	    memset(ctxt->sax, 0, sizeof(xmlSAXHandler));
 1779|      0|	    memcpy(ctxt->sax, sax, sizeof(xmlSAXHandlerV1));
 1780|      0|        }
 1781|      0|        ctxt->userData = userData ? userData : ctxt;
  ------------------
  |  Branch (1781:26): [True: 0, False: 0]
  ------------------
 1782|      0|    }
 1783|       |
 1784|    242|    ctxt->maxatts = 0;
 1785|    242|    ctxt->atts = NULL;
 1786|       |    /* Allocate the Input stack */
 1787|    242|    if (ctxt->inputTab == NULL) {
  ------------------
  |  Branch (1787:9): [True: 242, False: 0]
  ------------------
 1788|    242|	ctxt->inputTab = (xmlParserInputPtr *)
 1789|    242|		    xmlMalloc(5 * sizeof(xmlParserInputPtr));
 1790|    242|	ctxt->inputMax = 5;
 1791|    242|    }
 1792|    242|    if (ctxt->inputTab == NULL) {
  ------------------
  |  Branch (1792:9): [True: 0, False: 242]
  ------------------
 1793|      0|        xmlErrMemory(NULL, "cannot initialize parser context\n");
 1794|      0|	ctxt->inputNr = 0;
 1795|      0|	ctxt->inputMax = 0;
 1796|      0|	ctxt->input = NULL;
 1797|      0|	return(-1);
 1798|      0|    }
 1799|    242|    while ((input = inputPop(ctxt)) != NULL) { /* Non consuming */
  ------------------
  |  Branch (1799:12): [True: 0, False: 242]
  ------------------
 1800|      0|        xmlFreeInputStream(input);
 1801|      0|    }
 1802|    242|    ctxt->inputNr = 0;
 1803|    242|    ctxt->input = NULL;
 1804|       |
 1805|    242|    ctxt->version = NULL;
 1806|    242|    ctxt->encoding = NULL;
 1807|    242|    ctxt->standalone = -1;
 1808|    242|    ctxt->hasExternalSubset = 0;
 1809|    242|    ctxt->hasPErefs = 0;
 1810|    242|    ctxt->html = 0;
 1811|    242|    ctxt->external = 0;
 1812|    242|    ctxt->instate = XML_PARSER_START;
 1813|    242|    ctxt->token = 0;
 1814|    242|    ctxt->directory = NULL;
 1815|       |
 1816|       |    /* Allocate the Node stack */
 1817|    242|    if (ctxt->nodeTab == NULL) {
  ------------------
  |  Branch (1817:9): [True: 242, False: 0]
  ------------------
 1818|    242|	ctxt->nodeTab = (xmlNodePtr *) xmlMalloc(10 * sizeof(xmlNodePtr));
 1819|    242|	ctxt->nodeMax = 10;
 1820|    242|    }
 1821|    242|    if (ctxt->nodeTab == NULL) {
  ------------------
  |  Branch (1821:9): [True: 0, False: 242]
  ------------------
 1822|      0|        xmlErrMemory(NULL, "cannot initialize parser context\n");
 1823|      0|	ctxt->nodeNr = 0;
 1824|      0|	ctxt->nodeMax = 0;
 1825|      0|	ctxt->node = NULL;
 1826|      0|	ctxt->inputNr = 0;
 1827|      0|	ctxt->inputMax = 0;
 1828|      0|	ctxt->input = NULL;
 1829|      0|	return(-1);
 1830|      0|    }
 1831|    242|    ctxt->nodeNr = 0;
 1832|    242|    ctxt->node = NULL;
 1833|       |
 1834|       |    /* Allocate the Name stack */
 1835|    242|    if (ctxt->nameTab == NULL) {
  ------------------
  |  Branch (1835:9): [True: 242, False: 0]
  ------------------
 1836|    242|	ctxt->nameTab = (const xmlChar **) xmlMalloc(10 * sizeof(xmlChar *));
 1837|    242|	ctxt->nameMax = 10;
 1838|    242|    }
 1839|    242|    if (ctxt->nameTab == NULL) {
  ------------------
  |  Branch (1839:9): [True: 0, False: 242]
  ------------------
 1840|      0|        xmlErrMemory(NULL, "cannot initialize parser context\n");
 1841|      0|	ctxt->nodeNr = 0;
 1842|      0|	ctxt->nodeMax = 0;
 1843|      0|	ctxt->node = NULL;
 1844|      0|	ctxt->inputNr = 0;
 1845|      0|	ctxt->inputMax = 0;
 1846|      0|	ctxt->input = NULL;
 1847|      0|	ctxt->nameNr = 0;
 1848|      0|	ctxt->nameMax = 0;
 1849|      0|	ctxt->name = NULL;
 1850|      0|	return(-1);
 1851|      0|    }
 1852|    242|    ctxt->nameNr = 0;
 1853|    242|    ctxt->name = NULL;
 1854|       |
 1855|       |    /* Allocate the space stack */
 1856|    242|    if (ctxt->spaceTab == NULL) {
  ------------------
  |  Branch (1856:9): [True: 242, False: 0]
  ------------------
 1857|    242|	ctxt->spaceTab = (int *) xmlMalloc(10 * sizeof(int));
 1858|    242|	ctxt->spaceMax = 10;
 1859|    242|    }
 1860|    242|    if (ctxt->spaceTab == NULL) {
  ------------------
  |  Branch (1860:9): [True: 0, False: 242]
  ------------------
 1861|      0|        xmlErrMemory(NULL, "cannot initialize parser context\n");
 1862|      0|	ctxt->nodeNr = 0;
 1863|      0|	ctxt->nodeMax = 0;
 1864|      0|	ctxt->node = NULL;
 1865|      0|	ctxt->inputNr = 0;
 1866|      0|	ctxt->inputMax = 0;
 1867|      0|	ctxt->input = NULL;
 1868|      0|	ctxt->nameNr = 0;
 1869|      0|	ctxt->nameMax = 0;
 1870|      0|	ctxt->name = NULL;
 1871|      0|	ctxt->spaceNr = 0;
 1872|      0|	ctxt->spaceMax = 0;
 1873|      0|	ctxt->space = NULL;
 1874|      0|	return(-1);
 1875|      0|    }
 1876|    242|    ctxt->spaceNr = 1;
 1877|    242|    ctxt->spaceMax = 10;
 1878|    242|    ctxt->spaceTab[0] = -1;
 1879|    242|    ctxt->space = &ctxt->spaceTab[0];
 1880|    242|    ctxt->myDoc = NULL;
 1881|    242|    ctxt->wellFormed = 1;
 1882|    242|    ctxt->nsWellFormed = 1;
 1883|    242|    ctxt->valid = 1;
 1884|    242|    ctxt->loadsubset = xmlLoadExtDtdDefaultValue;
  ------------------
  |  |  869|    242|  #define xmlLoadExtDtdDefaultValue XML_GLOBAL_MACRO(xmlLoadExtDtdDefaultValue)
  |  |  ------------------
  |  |  |  |  500|    242|  #define XML_GLOBAL_MACRO(name) (*__##name())
  |  |  ------------------
  ------------------
 1885|    242|    if (ctxt->loadsubset) {
  ------------------
  |  Branch (1885:9): [True: 0, False: 242]
  ------------------
 1886|      0|        ctxt->options |= XML_PARSE_DTDLOAD;
 1887|      0|    }
 1888|    242|    ctxt->validate = xmlDoValidityCheckingDefaultValue;
  ------------------
  |  |  863|    242|    XML_GLOBAL_MACRO(xmlDoValidityCheckingDefaultValue)
  |  |  ------------------
  |  |  |  |  500|    242|  #define XML_GLOBAL_MACRO(name) (*__##name())
  |  |  ------------------
  ------------------
 1889|    242|    ctxt->pedantic = xmlPedanticParserDefaultValue;
  ------------------
  |  |  872|    242|    XML_GLOBAL_MACRO(xmlPedanticParserDefaultValue)
  |  |  ------------------
  |  |  |  |  500|    242|  #define XML_GLOBAL_MACRO(name) (*__##name())
  |  |  ------------------
  ------------------
 1890|    242|    if (ctxt->pedantic) {
  ------------------
  |  Branch (1890:9): [True: 0, False: 242]
  ------------------
 1891|      0|        ctxt->options |= XML_PARSE_PEDANTIC;
 1892|      0|    }
 1893|    242|    ctxt->linenumbers = xmlLineNumbersDefaultValue;
  ------------------
  |  |  868|    242|    XML_GLOBAL_MACRO(xmlLineNumbersDefaultValue)
  |  |  ------------------
  |  |  |  |  500|    242|  #define XML_GLOBAL_MACRO(name) (*__##name())
  |  |  ------------------
  ------------------
 1894|    242|    ctxt->keepBlanks = xmlKeepBlanksDefaultValue;
  ------------------
  |  |  866|    242|  #define xmlKeepBlanksDefaultValue XML_GLOBAL_MACRO(xmlKeepBlanksDefaultValue)
  |  |  ------------------
  |  |  |  |  500|    242|  #define XML_GLOBAL_MACRO(name) (*__##name())
  |  |  ------------------
  ------------------
 1895|    242|    if (ctxt->keepBlanks == 0) {
  ------------------
  |  Branch (1895:9): [True: 0, False: 242]
  ------------------
 1896|      0|	ctxt->sax->ignorableWhitespace = xmlSAX2IgnorableWhitespace;
 1897|      0|	ctxt->options |= XML_PARSE_NOBLANKS;
 1898|      0|    }
 1899|       |
 1900|    242|    ctxt->vctxt.flags = XML_VCTXT_USE_PCTXT;
  ------------------
  |  |   18|    242|#define XML_VCTXT_USE_PCTXT (1u << 1)
  ------------------
 1901|    242|    ctxt->vctxt.userData = ctxt;
 1902|    242|    ctxt->vctxt.error = xmlParserValidityError;
 1903|    242|    ctxt->vctxt.warning = xmlParserValidityWarning;
 1904|    242|    if (ctxt->validate) {
  ------------------
  |  Branch (1904:9): [True: 0, False: 242]
  ------------------
 1905|      0|	if (xmlGetWarningsDefaultValue == 0)
  ------------------
  |  |  865|      0|    XML_GLOBAL_MACRO(xmlGetWarningsDefaultValue)
  |  |  ------------------
  |  |  |  |  500|      0|  #define XML_GLOBAL_MACRO(name) (*__##name())
  |  |  ------------------
  ------------------
  |  Branch (1905:6): [True: 0, False: 0]
  ------------------
 1906|      0|	    ctxt->vctxt.warning = NULL;
 1907|      0|	else
 1908|      0|	    ctxt->vctxt.warning = xmlParserValidityWarning;
 1909|      0|	ctxt->vctxt.nodeMax = 0;
 1910|      0|        ctxt->options |= XML_PARSE_DTDVALID;
 1911|      0|    }
 1912|    242|    ctxt->replaceEntities = xmlSubstituteEntitiesDefaultValue;
  ------------------
  |  |  874|    242|    XML_GLOBAL_MACRO(xmlSubstituteEntitiesDefaultValue)
  |  |  ------------------
  |  |  |  |  500|    242|  #define XML_GLOBAL_MACRO(name) (*__##name())
  |  |  ------------------
  ------------------
 1913|    242|    if (ctxt->replaceEntities) {
  ------------------
  |  Branch (1913:9): [True: 0, False: 242]
  ------------------
 1914|      0|        ctxt->options |= XML_PARSE_NOENT;
 1915|      0|    }
 1916|    242|    ctxt->record_info = 0;
 1917|    242|    ctxt->checkIndex = 0;
 1918|    242|    ctxt->inSubset = 0;
 1919|    242|    ctxt->errNo = XML_ERR_OK;
 1920|    242|    ctxt->depth = 0;
 1921|    242|    ctxt->catalogs = NULL;
 1922|    242|    ctxt->sizeentities = 0;
 1923|    242|    ctxt->sizeentcopy = 0;
 1924|    242|    ctxt->input_id = 1;
 1925|    242|    ctxt->maxAmpl = XML_MAX_AMPLIFICATION_DEFAULT;
  ------------------
  |  |   52|    242|#define XML_MAX_AMPLIFICATION_DEFAULT 5
  ------------------
 1926|    242|    xmlInitNodeInfoSeq(&ctxt->node_seq);
 1927|       |
 1928|    242|    if (ctxt->nsdb == NULL) {
  ------------------
  |  Branch (1928:9): [True: 242, False: 0]
  ------------------
 1929|    242|        ctxt->nsdb = xmlParserNsCreate();
 1930|    242|        if (ctxt->nsdb == NULL) {
  ------------------
  |  Branch (1930:13): [True: 0, False: 242]
  ------------------
 1931|      0|            xmlErrMemory(ctxt, NULL);
 1932|      0|            return(-1);
 1933|      0|        }
 1934|    242|    }
 1935|       |
 1936|    242|    return(0);
 1937|    242|}

xmlFreePattern:
  228|     30|xmlFreePattern(xmlPatternPtr comp) {
  229|     30|    xmlFreePatternList(comp);
  230|     30|}
xmlFreePatternList:
  269|     30|xmlFreePatternList(xmlPatternPtr comp) {
  270|     30|    xmlPatternPtr cur;
  271|       |
  272|     61|    while (comp != NULL) {
  ------------------
  |  Branch (272:12): [True: 31, False: 30]
  ------------------
  273|     31|	cur = comp;
  274|     31|	comp = comp->next;
  275|     31|	cur->next = NULL;
  276|     31|	xmlFreePatternInternal(cur);
  277|     31|    }
  278|     30|}
xmlPatterncompile:
 2274|     30|                  const xmlChar **namespaces) {
 2275|     30|    xmlPatternPtr ret = NULL, cur;
 2276|     30|    xmlPatParserContextPtr ctxt = NULL;
 2277|     30|    const xmlChar *or, *start;
 2278|     30|    xmlChar *tmp = NULL;
 2279|     30|    int type = 0;
 2280|     30|    int streamable = 1;
 2281|       |
 2282|     30|    if (pattern == NULL)
  ------------------
  |  Branch (2282:9): [True: 0, False: 30]
  ------------------
 2283|      0|        return(NULL);
 2284|       |
 2285|     30|    start = pattern;
 2286|     30|    or = start;
 2287|     61|    while (*or != 0) {
  ------------------
  |  Branch (2287:12): [True: 31, False: 30]
  ------------------
 2288|     31|	tmp = NULL;
 2289|    273|	while ((*or != 0) && (*or != '|')) or++;
  ------------------
  |  Branch (2289:9): [True: 243, False: 30]
  |  Branch (2289:23): [True: 242, False: 1]
  ------------------
 2290|     31|        if (*or == 0)
  ------------------
  |  Branch (2290:13): [True: 30, False: 1]
  ------------------
 2291|     30|	    ctxt = xmlNewPatParserContext(start, dict, namespaces);
 2292|      1|	else {
 2293|      1|	    tmp = xmlStrndup(start, or - start);
 2294|      1|	    if (tmp != NULL) {
  ------------------
  |  Branch (2294:10): [True: 1, False: 0]
  ------------------
 2295|      1|		ctxt = xmlNewPatParserContext(tmp, dict, namespaces);
 2296|      1|	    }
 2297|      1|	    or++;
 2298|      1|	}
 2299|     31|	if (ctxt == NULL) goto error;
  ------------------
  |  Branch (2299:6): [True: 0, False: 31]
  ------------------
 2300|     31|	cur = xmlNewPattern();
 2301|     31|	if (cur == NULL) goto error;
  ------------------
  |  Branch (2301:6): [True: 0, False: 31]
  ------------------
 2302|       |	/*
 2303|       |	* Assign string dict.
 2304|       |	*/
 2305|     31|	if (dict) {
  ------------------
  |  Branch (2305:6): [True: 0, False: 31]
  ------------------
 2306|      0|	    cur->dict = dict;
 2307|      0|	    xmlDictReference(dict);
 2308|      0|	}
 2309|     31|	if (ret == NULL)
  ------------------
  |  Branch (2309:6): [True: 30, False: 1]
  ------------------
 2310|     30|	    ret = cur;
 2311|      1|	else {
 2312|      1|	    cur->next = ret->next;
 2313|      1|	    ret->next = cur;
 2314|      1|	}
 2315|     31|	cur->flags = flags;
 2316|     31|	ctxt->comp = cur;
 2317|       |
 2318|     31|	if (XML_STREAM_XS_IDC(cur))
  ------------------
  |  |   72|     31|#define XML_STREAM_XS_IDC(c) ((c)->flags & \
  |  |  ------------------
  |  |  |  Branch (72:30): [True: 31, False: 0]
  |  |  ------------------
  |  |   73|     31|    (XML_PATTERN_XSSEL | XML_PATTERN_XSFIELD))
  ------------------
 2319|     31|	    xmlCompileIDCXPathPath(ctxt);
 2320|      0|	else
 2321|      0|	    xmlCompilePathPattern(ctxt);
 2322|     31|	if (ctxt->error != 0)
  ------------------
  |  Branch (2322:6): [True: 0, False: 31]
  ------------------
 2323|      0|	    goto error;
 2324|     31|	xmlFreePatParserContext(ctxt);
 2325|     31|	ctxt = NULL;
 2326|       |
 2327|       |
 2328|     31|        if (streamable) {
  ------------------
  |  Branch (2328:13): [True: 31, False: 0]
  ------------------
 2329|     31|	    if (type == 0) {
  ------------------
  |  Branch (2329:10): [True: 30, False: 1]
  ------------------
 2330|     30|	        type = cur->flags & (PAT_FROM_ROOT | PAT_FROM_CUR);
  ------------------
  |  |  158|     30|#define PAT_FROM_ROOT	(1<<8)
  ------------------
              	        type = cur->flags & (PAT_FROM_ROOT | PAT_FROM_CUR);
  ------------------
  |  |  159|     30|#define PAT_FROM_CUR	(1<<9)
  ------------------
 2331|     30|	    } else if (type == PAT_FROM_ROOT) {
  ------------------
  |  |  158|      1|#define PAT_FROM_ROOT	(1<<8)
  ------------------
  |  Branch (2331:17): [True: 0, False: 1]
  ------------------
 2332|      0|	        if (cur->flags & PAT_FROM_CUR)
  ------------------
  |  |  159|      0|#define PAT_FROM_CUR	(1<<9)
  ------------------
  |  Branch (2332:14): [True: 0, False: 0]
  ------------------
 2333|      0|		    streamable = 0;
 2334|      1|	    } else if (type == PAT_FROM_CUR) {
  ------------------
  |  |  159|      1|#define PAT_FROM_CUR	(1<<9)
  ------------------
  |  Branch (2334:17): [True: 1, False: 0]
  ------------------
 2335|      1|	        if (cur->flags & PAT_FROM_ROOT)
  ------------------
  |  |  158|      1|#define PAT_FROM_ROOT	(1<<8)
  ------------------
  |  Branch (2335:14): [True: 0, False: 1]
  ------------------
 2336|      0|		    streamable = 0;
 2337|      1|	    }
 2338|     31|	}
 2339|     31|	if (streamable)
  ------------------
  |  Branch (2339:6): [True: 31, False: 0]
  ------------------
 2340|     31|	    xmlStreamCompile(cur);
 2341|     31|	if (xmlReversePattern(cur) < 0)
  ------------------
  |  Branch (2341:6): [True: 0, False: 31]
  ------------------
 2342|      0|	    goto error;
 2343|     31|	if (tmp != NULL) {
  ------------------
  |  Branch (2343:6): [True: 1, False: 30]
  ------------------
 2344|      1|	    xmlFree(tmp);
 2345|      1|	    tmp = NULL;
 2346|      1|	}
 2347|     31|	start = or;
 2348|     31|    }
 2349|     30|    if (streamable == 0) {
  ------------------
  |  Branch (2349:9): [True: 0, False: 30]
  ------------------
 2350|      0|        cur = ret;
 2351|      0|	while (cur != NULL) {
  ------------------
  |  Branch (2351:9): [True: 0, False: 0]
  ------------------
 2352|      0|	    if (cur->stream != NULL) {
  ------------------
  |  Branch (2352:10): [True: 0, False: 0]
  ------------------
 2353|      0|		xmlFreeStreamComp(cur->stream);
 2354|      0|		cur->stream = NULL;
 2355|      0|	    }
 2356|      0|	    cur = cur->next;
 2357|      0|	}
 2358|      0|    }
 2359|       |
 2360|     30|    return(ret);
 2361|      0|error:
 2362|      0|    if (ctxt != NULL) xmlFreePatParserContext(ctxt);
  ------------------
  |  Branch (2362:9): [True: 0, False: 0]
  ------------------
 2363|      0|    if (ret != NULL) xmlFreePattern(ret);
  ------------------
  |  Branch (2363:9): [True: 0, False: 0]
  ------------------
 2364|      0|    if (tmp != NULL) xmlFree(tmp);
  ------------------
  |  Branch (2364:9): [True: 0, False: 0]
  ------------------
 2365|      0|    return(NULL);
 2366|     30|}
pattern.c:xmlFreePatternInternal:
  233|     31|xmlFreePatternInternal(xmlPatternPtr comp) {
  234|     31|    xmlStepOpPtr op;
  235|     31|    int i;
  236|       |
  237|     31|    if (comp == NULL)
  ------------------
  |  Branch (237:9): [True: 0, False: 31]
  ------------------
  238|      0|	return;
  239|     31|    if (comp->stream != NULL)
  ------------------
  |  Branch (239:9): [True: 31, False: 0]
  ------------------
  240|     31|        xmlFreeStreamComp(comp->stream);
  241|     31|    if (comp->pattern != NULL)
  ------------------
  |  Branch (241:9): [True: 0, False: 31]
  ------------------
  242|      0|	xmlFree((xmlChar *)comp->pattern);
  243|     31|    if (comp->steps != NULL) {
  ------------------
  |  Branch (243:9): [True: 31, False: 0]
  ------------------
  244|     31|        if (comp->dict == NULL) {
  ------------------
  |  Branch (244:13): [True: 31, False: 0]
  ------------------
  245|     97|	    for (i = 0;i < comp->nbStep;i++) {
  ------------------
  |  Branch (245:17): [True: 66, False: 31]
  ------------------
  246|     66|		op = &comp->steps[i];
  247|     66|		if (op->value != NULL)
  ------------------
  |  Branch (247:7): [True: 30, False: 36]
  ------------------
  248|     30|		    xmlFree((xmlChar *) op->value);
  249|     66|		if (op->value2 != NULL)
  ------------------
  |  Branch (249:7): [True: 12, False: 54]
  ------------------
  250|     12|		    xmlFree((xmlChar *) op->value2);
  251|     66|	    }
  252|     31|	}
  253|     31|	xmlFree(comp->steps);
  254|     31|    }
  255|     31|    if (comp->dict != NULL)
  ------------------
  |  Branch (255:9): [True: 0, False: 31]
  ------------------
  256|      0|        xmlDictFree(comp->dict);
  257|       |
  258|     31|    memset(comp, -1, sizeof(xmlPattern));
  259|     31|    xmlFree(comp);
  260|     31|}
pattern.c:xmlNewPatParserContext:
  293|     31|                       const xmlChar **namespaces) {
  294|     31|    xmlPatParserContextPtr cur;
  295|       |
  296|     31|    if (pattern == NULL)
  ------------------
  |  Branch (296:9): [True: 0, False: 31]
  ------------------
  297|      0|        return(NULL);
  298|       |
  299|     31|    cur = (xmlPatParserContextPtr) xmlMalloc(sizeof(xmlPatParserContext));
  300|     31|    if (cur == NULL) {
  ------------------
  |  Branch (300:9): [True: 0, False: 31]
  ------------------
  301|      0|	ERROR(NULL, NULL, NULL,
  302|      0|		"xmlNewPatParserContext : malloc failed\n");
  303|      0|	return(NULL);
  304|      0|    }
  305|     31|    memset(cur, 0, sizeof(xmlPatParserContext));
  306|     31|    cur->dict = dict;
  307|     31|    cur->cur = pattern;
  308|     31|    cur->base = pattern;
  309|     31|    if (namespaces != NULL) {
  ------------------
  |  Branch (309:9): [True: 31, False: 0]
  ------------------
  310|     31|        int i;
  311|     83|        for (i = 0;namespaces[2 * i] != NULL;i++)
  ------------------
  |  Branch (311:20): [True: 52, False: 31]
  ------------------
  312|     52|            ;
  313|     31|        cur->nb_namespaces = i;
  314|     31|    } else {
  315|      0|        cur->nb_namespaces = 0;
  316|      0|    }
  317|     31|    cur->namespaces = namespaces;
  318|     31|    return(cur);
  319|     31|}
pattern.c:xmlNewPattern:
  200|     31|xmlNewPattern(void) {
  201|     31|    xmlPatternPtr cur;
  202|       |
  203|     31|    cur = (xmlPatternPtr) xmlMalloc(sizeof(xmlPattern));
  204|     31|    if (cur == NULL) {
  ------------------
  |  Branch (204:9): [True: 0, False: 31]
  ------------------
  205|      0|	ERROR(NULL, NULL, NULL,
  206|      0|		"xmlNewPattern : malloc failed\n");
  207|      0|	return(NULL);
  208|      0|    }
  209|     31|    memset(cur, 0, sizeof(xmlPattern));
  210|     31|    cur->maxStep = 10;
  211|     31|    cur->steps = (xmlStepOpPtr) xmlMalloc(cur->maxStep * sizeof(xmlStepOp));
  212|     31|    if (cur->steps == NULL) {
  ------------------
  |  Branch (212:9): [True: 0, False: 31]
  ------------------
  213|      0|        xmlFree(cur);
  214|      0|	ERROR(NULL, NULL, NULL,
  215|      0|		"xmlNewPattern : malloc failed\n");
  216|      0|	return(NULL);
  217|      0|    }
  218|     31|    return(cur);
  219|     31|}
pattern.c:xmlCompileIDCXPathPath:
 1319|     31|xmlCompileIDCXPathPath(xmlPatParserContextPtr ctxt) {
 1320|     31|    SKIP_BLANKS;
  ------------------
  |  |  711|     31|    while (IS_BLANK_CH(CUR)) NEXT
  |  |  ------------------
  |  |  |  |  714|      1|#define NEXT ((*ctxt->cur) ?  ctxt->cur++: ctxt->cur)
  |  |  |  |  ------------------
  |  |  |  |  |  Branch (714:15): [True: 1, False: 0]
  |  |  |  |  ------------------
  |  |  ------------------
  ------------------
 1321|     31|    if (CUR == '/') {
  ------------------
  |  |  704|     31|#define CUR (*ctxt->cur)
  ------------------
  |  Branch (1321:9): [True: 0, False: 31]
  ------------------
 1322|      0|	ERROR5(NULL, NULL, NULL,
 1323|      0|	    "Unexpected selection of the document root in '%s'.\n",
 1324|      0|	    ctxt->base);
 1325|      0|	goto error;
 1326|      0|    }
 1327|     31|    ctxt->comp->flags |= PAT_FROM_CUR;
  ------------------
  |  |  159|     31|#define PAT_FROM_CUR	(1<<9)
  ------------------
 1328|       |
 1329|     31|    if (CUR == '.') {
  ------------------
  |  |  704|     31|#define CUR (*ctxt->cur)
  ------------------
  |  Branch (1329:9): [True: 7, False: 24]
  ------------------
 1330|       |	/* "." - "self::node()" */
 1331|      7|	NEXT;
  ------------------
  |  |  714|      7|#define NEXT ((*ctxt->cur) ?  ctxt->cur++: ctxt->cur)
  |  |  ------------------
  |  |  |  Branch (714:15): [True: 7, False: 0]
  |  |  ------------------
  ------------------
 1332|      7|	SKIP_BLANKS;
  ------------------
  |  |  711|      7|    while (IS_BLANK_CH(CUR)) NEXT
  |  |  ------------------
  |  |  |  |  714|      0|#define NEXT ((*ctxt->cur) ?  ctxt->cur++: ctxt->cur)
  |  |  |  |  ------------------
  |  |  |  |  |  Branch (714:15): [True: 0, False: 0]
  |  |  |  |  ------------------
  |  |  ------------------
  ------------------
 1333|      7|	if (CUR == 0) {
  ------------------
  |  |  704|      7|#define CUR (*ctxt->cur)
  ------------------
  |  Branch (1333:6): [True: 3, False: 4]
  ------------------
 1334|       |	    /*
 1335|       |	    * Selection of the context node.
 1336|       |	    */
 1337|      3|	    PUSH(XML_OP_ELEM, NULL, NULL);
  ------------------
  |  |  718|      3|    if (xmlPatternAdd(ctxt, ctxt->comp, (op), (val), (val2))) goto error;
  |  |  ------------------
  |  |  |  Branch (718:9): [True: 0, False: 3]
  |  |  ------------------
  ------------------
 1338|      3|	    return;
 1339|      3|	}
 1340|      4|	if (CUR != '/') {
  ------------------
  |  |  704|      4|#define CUR (*ctxt->cur)
  ------------------
  |  Branch (1340:6): [True: 0, False: 4]
  ------------------
 1341|       |	    /* TODO: A more meaningful error message. */
 1342|      0|	    ERROR5(NULL, NULL, NULL,
 1343|      0|	    "Unexpected token after '.' in '%s'.\n", ctxt->base);
 1344|      0|	    goto error;
 1345|      0|	}
 1346|       |	/* "./" - "self::node()/" */
 1347|      4|	NEXT;
  ------------------
  |  |  714|      4|#define NEXT ((*ctxt->cur) ?  ctxt->cur++: ctxt->cur)
  |  |  ------------------
  |  |  |  Branch (714:15): [True: 4, False: 0]
  |  |  ------------------
  ------------------
 1348|      4|	SKIP_BLANKS;
  ------------------
  |  |  711|      4|    while (IS_BLANK_CH(CUR)) NEXT
  |  |  ------------------
  |  |  |  |  714|      4|#define NEXT ((*ctxt->cur) ?  ctxt->cur++: ctxt->cur)
  |  |  |  |  ------------------
  |  |  |  |  |  Branch (714:15): [True: 0, False: 0]
  |  |  |  |  ------------------
  |  |  ------------------
  ------------------
 1349|      4|	if (CUR == '/') {
  ------------------
  |  |  704|      4|#define CUR (*ctxt->cur)
  ------------------
  |  Branch (1349:6): [True: 4, False: 0]
  ------------------
 1350|      4|	    if (IS_BLANK_CH(PEEKPREV(1))) {
  ------------------
  |  |  151|      4|#define IS_BLANK_CH(c)  xmlIsBlank_ch(c)
  |  |  ------------------
  |  |  |  |   88|      4|#define xmlIsBlank_ch(c)	(((c) == 0x20) || \
  |  |  |  |  ------------------
  |  |  |  |  |  Branch (88:27): [True: 0, False: 4]
  |  |  |  |  ------------------
  |  |  |  |   89|      4|				 ((0x9 <= (c)) && ((c) <= 0xa)) || \
  |  |  |  |  ------------------
  |  |  |  |  |  Branch (89:7): [True: 4, False: 0]
  |  |  |  |  |  Branch (89:23): [True: 0, False: 4]
  |  |  |  |  ------------------
  |  |  |  |   90|      4|				 ((c) == 0xd))
  |  |  |  |  ------------------
  |  |  |  |  |  Branch (90:6): [True: 0, False: 4]
  |  |  |  |  ------------------
  |  |  ------------------
  ------------------
 1351|       |		/*
 1352|       |		* Disallow "./ /"
 1353|       |		*/
 1354|      0|		ERROR5(NULL, NULL, NULL,
 1355|      0|		    "Unexpected '/' token in '%s'.\n", ctxt->base);
 1356|      0|		goto error;
 1357|      0|	    }
 1358|       |	    /* ".//" - "self:node()/descendant-or-self::node()/" */
 1359|      4|	    PUSH(XML_OP_ANCESTOR, NULL, NULL);
  ------------------
  |  |  718|      4|    if (xmlPatternAdd(ctxt, ctxt->comp, (op), (val), (val2))) goto error;
  |  |  ------------------
  |  |  |  Branch (718:9): [True: 0, False: 4]
  |  |  ------------------
  ------------------
 1360|      4|	    NEXT;
  ------------------
  |  |  714|      4|#define NEXT ((*ctxt->cur) ?  ctxt->cur++: ctxt->cur)
  |  |  ------------------
  |  |  |  Branch (714:15): [True: 4, False: 0]
  |  |  ------------------
  ------------------
 1361|      4|	    SKIP_BLANKS;
  ------------------
  |  |  711|      4|    while (IS_BLANK_CH(CUR)) NEXT
  |  |  ------------------
  |  |  |  |  714|      4|#define NEXT ((*ctxt->cur) ?  ctxt->cur++: ctxt->cur)
  |  |  |  |  ------------------
  |  |  |  |  |  Branch (714:15): [True: 0, False: 0]
  |  |  |  |  ------------------
  |  |  ------------------
  ------------------
 1362|      4|	}
 1363|      4|	if (CUR == 0)
  ------------------
  |  |  704|      4|#define CUR (*ctxt->cur)
  ------------------
  |  Branch (1363:6): [True: 0, False: 4]
  ------------------
 1364|      0|	    goto error_unfinished;
 1365|      4|    }
 1366|       |    /*
 1367|       |    * Process steps.
 1368|       |    */
 1369|     30|    do {
 1370|     30|	xmlCompileStepPattern(ctxt);
 1371|     30|	if (ctxt->error != 0)
  ------------------
  |  Branch (1371:6): [True: 0, False: 30]
  ------------------
 1372|      0|	    goto error;
 1373|     30|	SKIP_BLANKS;
  ------------------
  |  |  711|     30|    while (IS_BLANK_CH(CUR)) NEXT
  |  |  ------------------
  |  |  |  |  714|     31|#define NEXT ((*ctxt->cur) ?  ctxt->cur++: ctxt->cur)
  |  |  |  |  ------------------
  |  |  |  |  |  Branch (714:15): [True: 1, False: 0]
  |  |  |  |  ------------------
  |  |  ------------------
  ------------------
 1374|     30|	if (CUR != '/')
  ------------------
  |  |  704|     30|#define CUR (*ctxt->cur)
  ------------------
  |  Branch (1374:6): [True: 28, False: 2]
  ------------------
 1375|     28|	    break;
 1376|      2|	PUSH(XML_OP_PARENT, NULL, NULL);
  ------------------
  |  |  718|      2|    if (xmlPatternAdd(ctxt, ctxt->comp, (op), (val), (val2))) goto error;
  |  |  ------------------
  |  |  |  Branch (718:9): [True: 0, False: 2]
  |  |  ------------------
  ------------------
 1377|      2|	NEXT;
  ------------------
  |  |  714|      2|#define NEXT ((*ctxt->cur) ?  ctxt->cur++: ctxt->cur)
  |  |  ------------------
  |  |  |  Branch (714:15): [True: 2, False: 0]
  |  |  ------------------
  ------------------
 1378|      2|	SKIP_BLANKS;
  ------------------
  |  |  711|      2|    while (IS_BLANK_CH(CUR)) NEXT
  |  |  ------------------
  |  |  |  |  714|      2|#define NEXT ((*ctxt->cur) ?  ctxt->cur++: ctxt->cur)
  |  |  |  |  ------------------
  |  |  |  |  |  Branch (714:15): [True: 0, False: 0]
  |  |  |  |  ------------------
  |  |  ------------------
  ------------------
 1379|      2|	if (CUR == '/') {
  ------------------
  |  |  704|      2|#define CUR (*ctxt->cur)
  ------------------
  |  Branch (1379:6): [True: 0, False: 2]
  ------------------
 1380|       |	    /*
 1381|       |	    * Disallow subsequent '//'.
 1382|       |	    */
 1383|      0|	    ERROR5(NULL, NULL, NULL,
 1384|      0|		"Unexpected subsequent '//' in '%s'.\n",
 1385|      0|		ctxt->base);
 1386|      0|	    goto error;
 1387|      0|	}
 1388|      2|	if (CUR == 0)
  ------------------
  |  |  704|      2|#define CUR (*ctxt->cur)
  ------------------
  |  Branch (1388:6): [True: 0, False: 2]
  ------------------
 1389|      0|	    goto error_unfinished;
 1390|       |
 1391|      2|    } while (CUR != 0);
  ------------------
  |  |  704|      2|#define CUR (*ctxt->cur)
  ------------------
  |  Branch (1391:14): [True: 2, False: 0]
  ------------------
 1392|       |
 1393|     28|    if (CUR != 0) {
  ------------------
  |  |  704|     28|#define CUR (*ctxt->cur)
  ------------------
  |  Branch (1393:9): [True: 0, False: 28]
  ------------------
 1394|      0|	ERROR5(NULL, NULL, NULL,
 1395|      0|	    "Failed to compile expression '%s'.\n", ctxt->base);
 1396|      0|	ctxt->error = 1;
 1397|      0|    }
 1398|     28|    return;
 1399|      0|error:
 1400|      0|    ctxt->error = 1;
 1401|      0|    return;
 1402|       |
 1403|      0|error_unfinished:
 1404|      0|    ctxt->error = 1;
 1405|      0|    ERROR5(NULL, NULL, NULL,
 1406|      0|	"Unfinished expression '%s'.\n", ctxt->base);
 1407|      0|    return;
 1408|     28|}
pattern.c:xmlPatternAdd:
  350|     39|{
  351|     39|    if (comp->nbStep >= comp->maxStep) {
  ------------------
  |  Branch (351:9): [True: 0, False: 39]
  ------------------
  352|      0|        xmlStepOpPtr temp;
  353|      0|	temp = (xmlStepOpPtr) xmlRealloc(comp->steps, comp->maxStep * 2 *
  354|      0|	                                 sizeof(xmlStepOp));
  355|      0|        if (temp == NULL) {
  ------------------
  |  Branch (355:13): [True: 0, False: 0]
  ------------------
  356|      0|	    ERROR(ctxt, NULL, NULL,
  357|      0|			     "xmlPatternAdd: realloc failed\n");
  358|      0|	    return (-1);
  359|      0|	}
  360|      0|	comp->steps = temp;
  361|      0|	comp->maxStep *= 2;
  362|      0|    }
  363|     39|    comp->steps[comp->nbStep].op = op;
  364|     39|    comp->steps[comp->nbStep].value = value;
  365|     39|    comp->steps[comp->nbStep].value2 = value2;
  366|     39|    comp->nbStep++;
  367|     39|    return (0);
  368|     39|}
pattern.c:xmlCompileStepPattern:
 1003|     30|xmlCompileStepPattern(xmlPatParserContextPtr ctxt) {
 1004|     30|    xmlChar *token = NULL;
 1005|     30|    xmlChar *name = NULL;
 1006|     30|    xmlChar *URL = NULL;
 1007|     30|    int hasBlanks = 0;
 1008|       |
 1009|     30|    SKIP_BLANKS;
  ------------------
  |  |  711|     30|    while (IS_BLANK_CH(CUR)) NEXT
  |  |  ------------------
  |  |  |  |  714|      0|#define NEXT ((*ctxt->cur) ?  ctxt->cur++: ctxt->cur)
  |  |  |  |  ------------------
  |  |  |  |  |  Branch (714:15): [True: 0, False: 0]
  |  |  |  |  ------------------
  |  |  ------------------
  ------------------
 1010|     30|    if (CUR == '.') {
  ------------------
  |  |  704|     30|#define CUR (*ctxt->cur)
  ------------------
  |  Branch (1010:9): [True: 0, False: 30]
  ------------------
 1011|       |	/*
 1012|       |	* Context node.
 1013|       |	*/
 1014|      0|	NEXT;
  ------------------
  |  |  714|      0|#define NEXT ((*ctxt->cur) ?  ctxt->cur++: ctxt->cur)
  |  |  ------------------
  |  |  |  Branch (714:15): [True: 0, False: 0]
  |  |  ------------------
  ------------------
 1015|      0|	PUSH(XML_OP_ELEM, NULL, NULL);
  ------------------
  |  |  718|      0|    if (xmlPatternAdd(ctxt, ctxt->comp, (op), (val), (val2))) goto error;
  |  |  ------------------
  |  |  |  Branch (718:9): [True: 0, False: 0]
  |  |  ------------------
  ------------------
 1016|      0|	return;
 1017|      0|    }
 1018|     30|    if (CUR == '@') {
  ------------------
  |  |  704|     30|#define CUR (*ctxt->cur)
  ------------------
  |  Branch (1018:9): [True: 13, False: 17]
  ------------------
 1019|       |	/*
 1020|       |	* Attribute test.
 1021|       |	*/
 1022|     13|	if (XML_STREAM_XS_IDC_SEL(ctxt->comp)) {
  ------------------
  |  |   75|     13|#define XML_STREAM_XS_IDC_SEL(c) ((c)->flags & XML_PATTERN_XSSEL)
  |  |  ------------------
  |  |  |  Branch (75:34): [True: 0, False: 13]
  |  |  ------------------
  ------------------
 1023|      0|	    ERROR5(NULL, NULL, NULL,
 1024|      0|		"Unexpected attribute axis in '%s'.\n", ctxt->base);
 1025|      0|	    ctxt->error = 1;
 1026|      0|	    return;
 1027|      0|	}
 1028|     13|	NEXT;
  ------------------
  |  |  714|     13|#define NEXT ((*ctxt->cur) ?  ctxt->cur++: ctxt->cur)
  |  |  ------------------
  |  |  |  Branch (714:15): [True: 13, False: 0]
  |  |  ------------------
  ------------------
 1029|     13|	xmlCompileAttributeTest(ctxt);
 1030|     13|	if (ctxt->error != 0)
  ------------------
  |  Branch (1030:6): [True: 0, False: 13]
  ------------------
 1031|      0|	    goto error;
 1032|     13|	return;
 1033|     13|    }
 1034|     17|    name = xmlPatScanNCName(ctxt);
 1035|     17|    if (name == NULL) {
  ------------------
  |  Branch (1035:9): [True: 0, False: 17]
  ------------------
 1036|      0|	if (CUR == '*') {
  ------------------
  |  |  704|      0|#define CUR (*ctxt->cur)
  ------------------
  |  Branch (1036:6): [True: 0, False: 0]
  ------------------
 1037|      0|	    NEXT;
  ------------------
  |  |  714|      0|#define NEXT ((*ctxt->cur) ?  ctxt->cur++: ctxt->cur)
  |  |  ------------------
  |  |  |  Branch (714:15): [True: 0, False: 0]
  |  |  ------------------
  ------------------
 1038|      0|	    PUSH(XML_OP_ALL, NULL, NULL);
  ------------------
  |  |  718|      0|    if (xmlPatternAdd(ctxt, ctxt->comp, (op), (val), (val2))) goto error;
  |  |  ------------------
  |  |  |  Branch (718:9): [True: 0, False: 0]
  |  |  ------------------
  ------------------
 1039|      0|	    return;
 1040|      0|	} else {
 1041|      0|	    ERROR(NULL, NULL, NULL,
 1042|      0|		    "xmlCompileStepPattern : Name expected\n");
 1043|      0|	    ctxt->error = 1;
 1044|      0|	    return;
 1045|      0|	}
 1046|      0|    }
 1047|     17|    if (IS_BLANK_CH(CUR)) {
  ------------------
  |  |  151|     17|#define IS_BLANK_CH(c)  xmlIsBlank_ch(c)
  |  |  ------------------
  |  |  |  |   88|     17|#define xmlIsBlank_ch(c)	(((c) == 0x20) || \
  |  |  |  |  ------------------
  |  |  |  |  |  Branch (88:27): [True: 0, False: 17]
  |  |  |  |  ------------------
  |  |  |  |   89|     17|				 ((0x9 <= (c)) && ((c) <= 0xa)) || \
  |  |  |  |  ------------------
  |  |  |  |  |  Branch (89:7): [True: 12, False: 5]
  |  |  |  |  |  Branch (89:23): [True: 0, False: 12]
  |  |  |  |  ------------------
  |  |  |  |   90|     17|				 ((c) == 0xd))
  |  |  |  |  ------------------
  |  |  |  |  |  Branch (90:6): [True: 0, False: 17]
  |  |  |  |  ------------------
  |  |  ------------------
  ------------------
 1048|      0|	hasBlanks = 1;
 1049|      0|	SKIP_BLANKS;
  ------------------
  |  |  711|      0|    while (IS_BLANK_CH(CUR)) NEXT
  |  |  ------------------
  |  |  |  |  714|      0|#define NEXT ((*ctxt->cur) ?  ctxt->cur++: ctxt->cur)
  |  |  |  |  ------------------
  |  |  |  |  |  Branch (714:15): [True: 0, False: 0]
  |  |  |  |  ------------------
  |  |  ------------------
  ------------------
 1050|      0|    }
 1051|     17|    if (CUR == ':') {
  ------------------
  |  |  704|     17|#define CUR (*ctxt->cur)
  ------------------
  |  Branch (1051:9): [True: 10, False: 7]
  ------------------
 1052|     10|	NEXT;
  ------------------
  |  |  714|     10|#define NEXT ((*ctxt->cur) ?  ctxt->cur++: ctxt->cur)
  |  |  ------------------
  |  |  |  Branch (714:15): [True: 10, False: 0]
  |  |  ------------------
  ------------------
 1053|     10|	if (CUR != ':') {
  ------------------
  |  |  704|     10|#define CUR (*ctxt->cur)
  ------------------
  |  Branch (1053:6): [True: 10, False: 0]
  ------------------
 1054|     10|	    xmlChar *prefix = name;
 1055|     10|	    int i;
 1056|       |
 1057|     10|	    if (hasBlanks || IS_BLANK_CH(CUR)) {
  ------------------
  |  |  151|     10|#define IS_BLANK_CH(c)  xmlIsBlank_ch(c)
  |  |  ------------------
  |  |  |  |   88|     10|#define xmlIsBlank_ch(c)	(((c) == 0x20) || \
  |  |  |  |  ------------------
  |  |  |  |  |  Branch (88:27): [True: 0, False: 10]
  |  |  |  |  ------------------
  |  |  |  |   89|     10|				 ((0x9 <= (c)) && ((c) <= 0xa)) || \
  |  |  |  |  ------------------
  |  |  |  |  |  Branch (89:7): [True: 10, False: 0]
  |  |  |  |  |  Branch (89:23): [True: 0, False: 10]
  |  |  |  |  ------------------
  |  |  |  |   90|     10|				 ((c) == 0xd))
  |  |  |  |  ------------------
  |  |  |  |  |  Branch (90:6): [True: 0, False: 10]
  |  |  |  |  ------------------
  |  |  ------------------
  ------------------
  |  Branch (1057:10): [True: 0, False: 10]
  ------------------
 1058|      0|		ERROR5(NULL, NULL, NULL, "Invalid QName.\n", NULL);
 1059|      0|		ctxt->error = 1;
 1060|      0|		goto error;
 1061|      0|	    }
 1062|       |	    /*
 1063|       |	     * This is a namespace match
 1064|       |	     */
 1065|     10|	    token = xmlPatScanName(ctxt);
 1066|     10|	    if ((prefix[0] == 'x') &&
  ------------------
  |  Branch (1066:10): [True: 0, False: 10]
  ------------------
 1067|     10|		(prefix[1] == 'm') &&
  ------------------
  |  Branch (1067:3): [True: 0, False: 0]
  ------------------
 1068|     10|		(prefix[2] == 'l') &&
  ------------------
  |  Branch (1068:3): [True: 0, False: 0]
  ------------------
 1069|     10|		(prefix[3] == 0))
  ------------------
  |  Branch (1069:3): [True: 0, False: 0]
  ------------------
 1070|      0|	    {
 1071|      0|		XML_PAT_COPY_NSNAME(ctxt, URL, XML_XML_NAMESPACE)
  ------------------
  |  |   80|      0|    if ((c)->comp->dict) \
  |  |  ------------------
  |  |  |  Branch (80:9): [True: 0, False: 0]
  |  |  ------------------
  |  |   81|      0|	r = (xmlChar *) xmlDictLookup((c)->comp->dict, BAD_CAST nsname, -1); \
  |  |  ------------------
  |  |  |  |   35|      0|#define BAD_CAST (xmlChar *)
  |  |  ------------------
  |  |   82|      0|    else r = xmlStrdup(BAD_CAST nsname);
  |  |  ------------------
  |  |  |  |   35|      0|#define BAD_CAST (xmlChar *)
  |  |  ------------------
  ------------------
 1072|     10|	    } else {
 1073|     18|		for (i = 0;i < ctxt->nb_namespaces;i++) {
  ------------------
  |  Branch (1073:14): [True: 18, False: 0]
  ------------------
 1074|     18|		    if (xmlStrEqual(ctxt->namespaces[2 * i + 1], prefix)) {
  ------------------
  |  Branch (1074:11): [True: 10, False: 8]
  ------------------
 1075|     10|			XML_PAT_COPY_NSNAME(ctxt, URL, ctxt->namespaces[2 * i])
  ------------------
  |  |   80|     10|    if ((c)->comp->dict) \
  |  |  ------------------
  |  |  |  Branch (80:9): [True: 0, False: 10]
  |  |  ------------------
  |  |   81|     10|	r = (xmlChar *) xmlDictLookup((c)->comp->dict, BAD_CAST nsname, -1); \
  |  |  ------------------
  |  |  |  |   35|      0|#define BAD_CAST (xmlChar *)
  |  |  ------------------
  |  |   82|     10|    else r = xmlStrdup(BAD_CAST nsname);
  |  |  ------------------
  |  |  |  |   35|     10|#define BAD_CAST (xmlChar *)
  |  |  ------------------
  ------------------
 1076|     10|			break;
 1077|     10|		    }
 1078|     18|		}
 1079|     10|		if (i >= ctxt->nb_namespaces) {
  ------------------
  |  Branch (1079:7): [True: 0, False: 10]
  ------------------
 1080|      0|		    ERROR5(NULL, NULL, NULL,
 1081|      0|			"xmlCompileStepPattern : no namespace bound to prefix %s\n",
 1082|      0|			prefix);
 1083|      0|		    ctxt->error = 1;
 1084|      0|		    goto error;
 1085|      0|		}
 1086|     10|	    }
 1087|     10|	    XML_PAT_FREE_STRING(ctxt, prefix);
  ------------------
  |  |   84|     10|#define XML_PAT_FREE_STRING(c, r) if ((c)->comp->dict == NULL) xmlFree(r);
  |  |  ------------------
  |  |  |  Branch (84:39): [True: 10, False: 0]
  |  |  ------------------
  ------------------
 1088|     10|	    name = NULL;
 1089|     10|	    if (token == NULL) {
  ------------------
  |  Branch (1089:10): [True: 0, False: 10]
  ------------------
 1090|      0|		if (CUR == '*') {
  ------------------
  |  |  704|      0|#define CUR (*ctxt->cur)
  ------------------
  |  Branch (1090:7): [True: 0, False: 0]
  ------------------
 1091|      0|		    NEXT;
  ------------------
  |  |  714|      0|#define NEXT ((*ctxt->cur) ?  ctxt->cur++: ctxt->cur)
  |  |  ------------------
  |  |  |  Branch (714:15): [True: 0, False: 0]
  |  |  ------------------
  ------------------
 1092|      0|		    PUSH(XML_OP_NS, URL, NULL);
  ------------------
  |  |  718|      0|    if (xmlPatternAdd(ctxt, ctxt->comp, (op), (val), (val2))) goto error;
  |  |  ------------------
  |  |  |  Branch (718:9): [True: 0, False: 0]
  |  |  ------------------
  ------------------
 1093|      0|		} else {
 1094|      0|		    ERROR(NULL, NULL, NULL,
 1095|      0|			    "xmlCompileStepPattern : Name expected\n");
 1096|      0|		    ctxt->error = 1;
 1097|      0|		    goto error;
 1098|      0|		}
 1099|     10|	    } else {
 1100|     10|		PUSH(XML_OP_ELEM, token, URL);
  ------------------
  |  |  718|     10|    if (xmlPatternAdd(ctxt, ctxt->comp, (op), (val), (val2))) goto error;
  |  |  ------------------
  |  |  |  Branch (718:9): [True: 0, False: 10]
  |  |  ------------------
  ------------------
 1101|     10|	    }
 1102|     10|	} else {
 1103|      0|	    NEXT;
  ------------------
  |  |  714|      0|#define NEXT ((*ctxt->cur) ?  ctxt->cur++: ctxt->cur)
  |  |  ------------------
  |  |  |  Branch (714:15): [True: 0, False: 0]
  |  |  ------------------
  ------------------
 1104|      0|	    if (xmlStrEqual(name, (const xmlChar *) "child")) {
  ------------------
  |  Branch (1104:10): [True: 0, False: 0]
  ------------------
 1105|      0|		XML_PAT_FREE_STRING(ctxt, name);
  ------------------
  |  |   84|      0|#define XML_PAT_FREE_STRING(c, r) if ((c)->comp->dict == NULL) xmlFree(r);
  |  |  ------------------
  |  |  |  Branch (84:39): [True: 0, False: 0]
  |  |  ------------------
  ------------------
 1106|      0|		name = xmlPatScanName(ctxt);
 1107|      0|		if (name == NULL) {
  ------------------
  |  Branch (1107:7): [True: 0, False: 0]
  ------------------
 1108|      0|		    if (CUR == '*') {
  ------------------
  |  |  704|      0|#define CUR (*ctxt->cur)
  ------------------
  |  Branch (1108:11): [True: 0, False: 0]
  ------------------
 1109|      0|			NEXT;
  ------------------
  |  |  714|      0|#define NEXT ((*ctxt->cur) ?  ctxt->cur++: ctxt->cur)
  |  |  ------------------
  |  |  |  Branch (714:15): [True: 0, False: 0]
  |  |  ------------------
  ------------------
 1110|      0|			PUSH(XML_OP_ALL, NULL, NULL);
  ------------------
  |  |  718|      0|    if (xmlPatternAdd(ctxt, ctxt->comp, (op), (val), (val2))) goto error;
  |  |  ------------------
  |  |  |  Branch (718:9): [True: 0, False: 0]
  |  |  ------------------
  ------------------
 1111|      0|			return;
 1112|      0|		    } else {
 1113|      0|			ERROR(NULL, NULL, NULL,
 1114|      0|			    "xmlCompileStepPattern : QName expected\n");
 1115|      0|			ctxt->error = 1;
 1116|      0|			goto error;
 1117|      0|		    }
 1118|      0|		}
 1119|      0|		if (CUR == ':') {
  ------------------
  |  |  704|      0|#define CUR (*ctxt->cur)
  ------------------
  |  Branch (1119:7): [True: 0, False: 0]
  ------------------
 1120|      0|		    xmlChar *prefix = name;
 1121|      0|		    int i;
 1122|       |
 1123|      0|		    NEXT;
  ------------------
  |  |  714|      0|#define NEXT ((*ctxt->cur) ?  ctxt->cur++: ctxt->cur)
  |  |  ------------------
  |  |  |  Branch (714:15): [True: 0, False: 0]
  |  |  ------------------
  ------------------
 1124|      0|		    if (IS_BLANK_CH(CUR)) {
  ------------------
  |  |  151|      0|#define IS_BLANK_CH(c)  xmlIsBlank_ch(c)
  |  |  ------------------
  |  |  |  |   88|      0|#define xmlIsBlank_ch(c)	(((c) == 0x20) || \
  |  |  |  |  ------------------
  |  |  |  |  |  Branch (88:27): [True: 0, False: 0]
  |  |  |  |  ------------------
  |  |  |  |   89|      0|				 ((0x9 <= (c)) && ((c) <= 0xa)) || \
  |  |  |  |  ------------------
  |  |  |  |  |  Branch (89:7): [True: 0, False: 0]
  |  |  |  |  |  Branch (89:23): [True: 0, False: 0]
  |  |  |  |  ------------------
  |  |  |  |   90|      0|				 ((c) == 0xd))
  |  |  |  |  ------------------
  |  |  |  |  |  Branch (90:6): [True: 0, False: 0]
  |  |  |  |  ------------------
  |  |  ------------------
  ------------------
 1125|      0|			ERROR5(NULL, NULL, NULL, "Invalid QName.\n", NULL);
 1126|      0|			ctxt->error = 1;
 1127|      0|			goto error;
 1128|      0|		    }
 1129|       |		    /*
 1130|       |		    * This is a namespace match
 1131|       |		    */
 1132|      0|		    token = xmlPatScanName(ctxt);
 1133|      0|		    if ((prefix[0] == 'x') &&
  ------------------
  |  Branch (1133:11): [True: 0, False: 0]
  ------------------
 1134|      0|			(prefix[1] == 'm') &&
  ------------------
  |  Branch (1134:4): [True: 0, False: 0]
  ------------------
 1135|      0|			(prefix[2] == 'l') &&
  ------------------
  |  Branch (1135:4): [True: 0, False: 0]
  ------------------
 1136|      0|			(prefix[3] == 0))
  ------------------
  |  Branch (1136:4): [True: 0, False: 0]
  ------------------
 1137|      0|		    {
 1138|      0|			XML_PAT_COPY_NSNAME(ctxt, URL, XML_XML_NAMESPACE)
  ------------------
  |  |   80|      0|    if ((c)->comp->dict) \
  |  |  ------------------
  |  |  |  Branch (80:9): [True: 0, False: 0]
  |  |  ------------------
  |  |   81|      0|	r = (xmlChar *) xmlDictLookup((c)->comp->dict, BAD_CAST nsname, -1); \
  |  |  ------------------
  |  |  |  |   35|      0|#define BAD_CAST (xmlChar *)
  |  |  ------------------
  |  |   82|      0|    else r = xmlStrdup(BAD_CAST nsname);
  |  |  ------------------
  |  |  |  |   35|      0|#define BAD_CAST (xmlChar *)
  |  |  ------------------
  ------------------
 1139|      0|		    } else {
 1140|      0|			for (i = 0;i < ctxt->nb_namespaces;i++) {
  ------------------
  |  Branch (1140:15): [True: 0, False: 0]
  ------------------
 1141|      0|			    if (xmlStrEqual(ctxt->namespaces[2 * i + 1], prefix)) {
  ------------------
  |  Branch (1141:12): [True: 0, False: 0]
  ------------------
 1142|      0|				XML_PAT_COPY_NSNAME(ctxt, URL, ctxt->namespaces[2 * i])
  ------------------
  |  |   80|      0|    if ((c)->comp->dict) \
  |  |  ------------------
  |  |  |  Branch (80:9): [True: 0, False: 0]
  |  |  ------------------
  |  |   81|      0|	r = (xmlChar *) xmlDictLookup((c)->comp->dict, BAD_CAST nsname, -1); \
  |  |  ------------------
  |  |  |  |   35|      0|#define BAD_CAST (xmlChar *)
  |  |  ------------------
  |  |   82|      0|    else r = xmlStrdup(BAD_CAST nsname);
  |  |  ------------------
  |  |  |  |   35|      0|#define BAD_CAST (xmlChar *)
  |  |  ------------------
  ------------------
 1143|      0|				break;
 1144|      0|			    }
 1145|      0|			}
 1146|      0|			if (i >= ctxt->nb_namespaces) {
  ------------------
  |  Branch (1146:8): [True: 0, False: 0]
  ------------------
 1147|      0|			    ERROR5(NULL, NULL, NULL,
 1148|      0|				"xmlCompileStepPattern : no namespace bound "
 1149|      0|				"to prefix %s\n", prefix);
 1150|      0|			    ctxt->error = 1;
 1151|      0|			    goto error;
 1152|      0|			}
 1153|      0|		    }
 1154|      0|		    XML_PAT_FREE_STRING(ctxt, prefix);
  ------------------
  |  |   84|      0|#define XML_PAT_FREE_STRING(c, r) if ((c)->comp->dict == NULL) xmlFree(r);
  |  |  ------------------
  |  |  |  Branch (84:39): [True: 0, False: 0]
  |  |  ------------------
  ------------------
 1155|      0|		    name = NULL;
 1156|      0|		    if (token == NULL) {
  ------------------
  |  Branch (1156:11): [True: 0, False: 0]
  ------------------
 1157|      0|			if (CUR == '*') {
  ------------------
  |  |  704|      0|#define CUR (*ctxt->cur)
  ------------------
  |  Branch (1157:8): [True: 0, False: 0]
  ------------------
 1158|      0|			    NEXT;
  ------------------
  |  |  714|      0|#define NEXT ((*ctxt->cur) ?  ctxt->cur++: ctxt->cur)
  |  |  ------------------
  |  |  |  Branch (714:15): [True: 0, False: 0]
  |  |  ------------------
  ------------------
 1159|      0|			    PUSH(XML_OP_NS, URL, NULL);
  ------------------
  |  |  718|      0|    if (xmlPatternAdd(ctxt, ctxt->comp, (op), (val), (val2))) goto error;
  |  |  ------------------
  |  |  |  Branch (718:9): [True: 0, False: 0]
  |  |  ------------------
  ------------------
 1160|      0|			} else {
 1161|      0|			    ERROR(NULL, NULL, NULL,
 1162|      0|				"xmlCompileStepPattern : Name expected\n");
 1163|      0|			    ctxt->error = 1;
 1164|      0|			    goto error;
 1165|      0|			}
 1166|      0|		    } else {
 1167|      0|			PUSH(XML_OP_CHILD, token, URL);
  ------------------
  |  |  718|      0|    if (xmlPatternAdd(ctxt, ctxt->comp, (op), (val), (val2))) goto error;
  |  |  ------------------
  |  |  |  Branch (718:9): [True: 0, False: 0]
  |  |  ------------------
  ------------------
 1168|      0|		    }
 1169|      0|		} else
 1170|      0|		    PUSH(XML_OP_CHILD, name, NULL);
  ------------------
  |  |  718|      0|    if (xmlPatternAdd(ctxt, ctxt->comp, (op), (val), (val2))) goto error;
  |  |  ------------------
  |  |  |  Branch (718:9): [True: 0, False: 0]
  |  |  ------------------
  ------------------
 1171|      0|		return;
 1172|      0|	    } else if (xmlStrEqual(name, (const xmlChar *) "attribute")) {
  ------------------
  |  Branch (1172:17): [True: 0, False: 0]
  ------------------
 1173|      0|		XML_PAT_FREE_STRING(ctxt, name)
  ------------------
  |  |   84|      0|#define XML_PAT_FREE_STRING(c, r) if ((c)->comp->dict == NULL) xmlFree(r);
  |  |  ------------------
  |  |  |  Branch (84:39): [True: 0, False: 0]
  |  |  ------------------
  ------------------
 1174|      0|		name = NULL;
 1175|      0|		if (XML_STREAM_XS_IDC_SEL(ctxt->comp)) {
  ------------------
  |  |   75|      0|#define XML_STREAM_XS_IDC_SEL(c) ((c)->flags & XML_PATTERN_XSSEL)
  |  |  ------------------
  |  |  |  Branch (75:34): [True: 0, False: 0]
  |  |  ------------------
  ------------------
 1176|      0|		    ERROR5(NULL, NULL, NULL,
 1177|      0|			"Unexpected attribute axis in '%s'.\n", ctxt->base);
 1178|      0|		    ctxt->error = 1;
 1179|      0|		    goto error;
 1180|      0|		}
 1181|      0|		xmlCompileAttributeTest(ctxt);
 1182|      0|		if (ctxt->error != 0)
  ------------------
  |  Branch (1182:7): [True: 0, False: 0]
  ------------------
 1183|      0|		    goto error;
 1184|      0|		return;
 1185|      0|	    } else {
 1186|      0|		ERROR5(NULL, NULL, NULL,
 1187|      0|		    "The 'element' or 'attribute' axis is expected.\n", NULL);
 1188|      0|		ctxt->error = 1;
 1189|      0|		goto error;
 1190|      0|	    }
 1191|      0|	}
 1192|     10|    } else if (CUR == '*') {
  ------------------
  |  |  704|      7|#define CUR (*ctxt->cur)
  ------------------
  |  Branch (1192:16): [True: 0, False: 7]
  ------------------
 1193|      0|        if (name != NULL) {
  ------------------
  |  Branch (1193:13): [True: 0, False: 0]
  ------------------
 1194|      0|	    ctxt->error = 1;
 1195|      0|	    goto error;
 1196|      0|	}
 1197|      0|	NEXT;
  ------------------
  |  |  714|      0|#define NEXT ((*ctxt->cur) ?  ctxt->cur++: ctxt->cur)
  |  |  ------------------
  |  |  |  Branch (714:15): [True: 0, False: 0]
  |  |  ------------------
  ------------------
 1198|      0|	PUSH(XML_OP_ALL, token, NULL);
  ------------------
  |  |  718|      0|    if (xmlPatternAdd(ctxt, ctxt->comp, (op), (val), (val2))) goto error;
  |  |  ------------------
  |  |  |  Branch (718:9): [True: 0, False: 0]
  |  |  ------------------
  ------------------
 1199|      7|    } else {
 1200|      7|	PUSH(XML_OP_ELEM, name, NULL);
  ------------------
  |  |  718|      7|    if (xmlPatternAdd(ctxt, ctxt->comp, (op), (val), (val2))) goto error;
  |  |  ------------------
  |  |  |  Branch (718:9): [True: 0, False: 7]
  |  |  ------------------
  ------------------
 1201|      7|    }
 1202|     17|    return;
 1203|     17|error:
 1204|      0|    if (URL != NULL)
  ------------------
  |  Branch (1204:9): [True: 0, False: 0]
  ------------------
 1205|      0|	XML_PAT_FREE_STRING(ctxt, URL)
  ------------------
  |  |   84|      0|#define XML_PAT_FREE_STRING(c, r) if ((c)->comp->dict == NULL) xmlFree(r);
  |  |  ------------------
  |  |  |  Branch (84:39): [True: 0, False: 0]
  |  |  ------------------
  ------------------
 1206|      0|    if (token != NULL)
  ------------------
  |  Branch (1206:9): [True: 0, False: 0]
  ------------------
 1207|      0|	XML_PAT_FREE_STRING(ctxt, token)
  ------------------
  |  |   84|      0|#define XML_PAT_FREE_STRING(c, r) if ((c)->comp->dict == NULL) xmlFree(r);
  |  |  ------------------
  |  |  |  Branch (84:39): [True: 0, False: 0]
  |  |  ------------------
  ------------------
 1208|      0|    if (name != NULL)
  ------------------
  |  Branch (1208:9): [True: 0, False: 0]
  ------------------
 1209|      0|	XML_PAT_FREE_STRING(ctxt, name)
  ------------------
  |  |   84|      0|#define XML_PAT_FREE_STRING(c, r) if ((c)->comp->dict == NULL) xmlFree(r);
  |  |  ------------------
  |  |  |  Branch (84:39): [True: 0, False: 0]
  |  |  ------------------
  ------------------
 1210|      0|}
pattern.c:xmlCompileAttributeTest:
  909|     13|xmlCompileAttributeTest(xmlPatParserContextPtr ctxt) {
  910|     13|    xmlChar *token = NULL;
  911|     13|    xmlChar *name = NULL;
  912|     13|    xmlChar *URL = NULL;
  913|       |
  914|     13|    SKIP_BLANKS;
  ------------------
  |  |  711|     13|    while (IS_BLANK_CH(CUR)) NEXT
  |  |  ------------------
  |  |  |  |  714|      0|#define NEXT ((*ctxt->cur) ?  ctxt->cur++: ctxt->cur)
  |  |  |  |  ------------------
  |  |  |  |  |  Branch (714:15): [True: 0, False: 0]
  |  |  |  |  ------------------
  |  |  ------------------
  ------------------
  915|     13|    name = xmlPatScanNCName(ctxt);
  916|     13|    if (name == NULL) {
  ------------------
  |  Branch (916:9): [True: 0, False: 13]
  ------------------
  917|      0|	if (CUR == '*') {
  ------------------
  |  |  704|      0|#define CUR (*ctxt->cur)
  ------------------
  |  Branch (917:6): [True: 0, False: 0]
  ------------------
  918|      0|	    PUSH(XML_OP_ATTR, NULL, NULL);
  ------------------
  |  |  718|      0|    if (xmlPatternAdd(ctxt, ctxt->comp, (op), (val), (val2))) goto error;
  |  |  ------------------
  |  |  |  Branch (718:9): [True: 0, False: 0]
  |  |  ------------------
  ------------------
  919|      0|	    NEXT;
  ------------------
  |  |  714|      0|#define NEXT ((*ctxt->cur) ?  ctxt->cur++: ctxt->cur)
  |  |  ------------------
  |  |  |  Branch (714:15): [True: 0, False: 0]
  |  |  ------------------
  ------------------
  920|      0|	} else {
  921|      0|	    ERROR(NULL, NULL, NULL,
  922|      0|		"xmlCompileAttributeTest : Name expected\n");
  923|      0|	    ctxt->error = 1;
  924|      0|	}
  925|      0|	return;
  926|      0|    }
  927|     13|    if (CUR == ':') {
  ------------------
  |  |  704|     13|#define CUR (*ctxt->cur)
  ------------------
  |  Branch (927:9): [True: 2, False: 11]
  ------------------
  928|      2|	int i;
  929|      2|	xmlChar *prefix = name;
  930|       |
  931|      2|	NEXT;
  ------------------
  |  |  714|      2|#define NEXT ((*ctxt->cur) ?  ctxt->cur++: ctxt->cur)
  |  |  ------------------
  |  |  |  Branch (714:15): [True: 2, False: 0]
  |  |  ------------------
  ------------------
  932|       |
  933|      2|	if (IS_BLANK_CH(CUR)) {
  ------------------
  |  |  151|      2|#define IS_BLANK_CH(c)  xmlIsBlank_ch(c)
  |  |  ------------------
  |  |  |  |   88|      2|#define xmlIsBlank_ch(c)	(((c) == 0x20) || \
  |  |  |  |  ------------------
  |  |  |  |  |  Branch (88:27): [True: 0, False: 2]
  |  |  |  |  ------------------
  |  |  |  |   89|      2|				 ((0x9 <= (c)) && ((c) <= 0xa)) || \
  |  |  |  |  ------------------
  |  |  |  |  |  Branch (89:7): [True: 2, False: 0]
  |  |  |  |  |  Branch (89:23): [True: 0, False: 2]
  |  |  |  |  ------------------
  |  |  |  |   90|      2|				 ((c) == 0xd))
  |  |  |  |  ------------------
  |  |  |  |  |  Branch (90:6): [True: 0, False: 2]
  |  |  |  |  ------------------
  |  |  ------------------
  ------------------
  934|      0|	    ERROR5(NULL, NULL, NULL, "Invalid QName.\n", NULL);
  935|      0|	    ctxt->error = 1;
  936|      0|	    goto error;
  937|      0|	}
  938|       |	/*
  939|       |	* This is a namespace match
  940|       |	*/
  941|      2|	token = xmlPatScanName(ctxt);
  942|      2|	if ((prefix[0] == 'x') &&
  ------------------
  |  Branch (942:6): [True: 0, False: 2]
  ------------------
  943|      2|	    (prefix[1] == 'm') &&
  ------------------
  |  Branch (943:6): [True: 0, False: 0]
  ------------------
  944|      2|	    (prefix[2] == 'l') &&
  ------------------
  |  Branch (944:6): [True: 0, False: 0]
  ------------------
  945|      2|	    (prefix[3] == 0))
  ------------------
  |  Branch (945:6): [True: 0, False: 0]
  ------------------
  946|      0|	{
  947|      0|	    XML_PAT_COPY_NSNAME(ctxt, URL, XML_XML_NAMESPACE);
  ------------------
  |  |   80|      0|    if ((c)->comp->dict) \
  |  |  ------------------
  |  |  |  Branch (80:9): [True: 0, False: 0]
  |  |  ------------------
  |  |   81|      0|	r = (xmlChar *) xmlDictLookup((c)->comp->dict, BAD_CAST nsname, -1); \
  |  |  ------------------
  |  |  |  |   35|      0|#define BAD_CAST (xmlChar *)
  |  |  ------------------
  |  |   82|      0|    else r = xmlStrdup(BAD_CAST nsname);
  |  |  ------------------
  |  |  |  |   35|      0|#define BAD_CAST (xmlChar *)
  |  |  ------------------
  ------------------
  948|      2|	} else {
  949|      4|	    for (i = 0;i < ctxt->nb_namespaces;i++) {
  ------------------
  |  Branch (949:17): [True: 4, False: 0]
  ------------------
  950|      4|		if (xmlStrEqual(ctxt->namespaces[2 * i + 1], prefix)) {
  ------------------
  |  Branch (950:7): [True: 2, False: 2]
  ------------------
  951|      2|		    XML_PAT_COPY_NSNAME(ctxt, URL, ctxt->namespaces[2 * i])
  ------------------
  |  |   80|      2|    if ((c)->comp->dict) \
  |  |  ------------------
  |  |  |  Branch (80:9): [True: 0, False: 2]
  |  |  ------------------
  |  |   81|      2|	r = (xmlChar *) xmlDictLookup((c)->comp->dict, BAD_CAST nsname, -1); \
  |  |  ------------------
  |  |  |  |   35|      0|#define BAD_CAST (xmlChar *)
  |  |  ------------------
  |  |   82|      2|    else r = xmlStrdup(BAD_CAST nsname);
  |  |  ------------------
  |  |  |  |   35|      2|#define BAD_CAST (xmlChar *)
  |  |  ------------------
  ------------------
  952|      2|		    break;
  953|      2|		}
  954|      4|	    }
  955|      2|	    if (i >= ctxt->nb_namespaces) {
  ------------------
  |  Branch (955:10): [True: 0, False: 2]
  ------------------
  956|      0|		ERROR5(NULL, NULL, NULL,
  957|      0|		    "xmlCompileAttributeTest : no namespace bound to prefix %s\n",
  958|      0|		    prefix);
  959|      0|		ctxt->error = 1;
  960|      0|		goto error;
  961|      0|	    }
  962|      2|	}
  963|      2|        XML_PAT_FREE_STRING(ctxt, name);
  ------------------
  |  |   84|      2|#define XML_PAT_FREE_STRING(c, r) if ((c)->comp->dict == NULL) xmlFree(r);
  |  |  ------------------
  |  |  |  Branch (84:39): [True: 2, False: 0]
  |  |  ------------------
  ------------------
  964|      2|        name = NULL;
  965|      2|	if (token == NULL) {
  ------------------
  |  Branch (965:6): [True: 0, False: 2]
  ------------------
  966|      0|	    if (CUR == '*') {
  ------------------
  |  |  704|      0|#define CUR (*ctxt->cur)
  ------------------
  |  Branch (966:10): [True: 0, False: 0]
  ------------------
  967|      0|		NEXT;
  ------------------
  |  |  714|      0|#define NEXT ((*ctxt->cur) ?  ctxt->cur++: ctxt->cur)
  |  |  ------------------
  |  |  |  Branch (714:15): [True: 0, False: 0]
  |  |  ------------------
  ------------------
  968|      0|		PUSH(XML_OP_ATTR, NULL, URL);
  ------------------
  |  |  718|      0|    if (xmlPatternAdd(ctxt, ctxt->comp, (op), (val), (val2))) goto error;
  |  |  ------------------
  |  |  |  Branch (718:9): [True: 0, False: 0]
  |  |  ------------------
  ------------------
  969|      0|	    } else {
  970|      0|		ERROR(NULL, NULL, NULL,
  971|      0|		    "xmlCompileAttributeTest : Name expected\n");
  972|      0|		ctxt->error = 1;
  973|      0|		goto error;
  974|      0|	    }
  975|      2|	} else {
  976|      2|	    PUSH(XML_OP_ATTR, token, URL);
  ------------------
  |  |  718|      2|    if (xmlPatternAdd(ctxt, ctxt->comp, (op), (val), (val2))) goto error;
  |  |  ------------------
  |  |  |  Branch (718:9): [True: 0, False: 2]
  |  |  ------------------
  ------------------
  977|      2|	}
  978|     11|    } else {
  979|     11|	PUSH(XML_OP_ATTR, name, NULL);
  ------------------
  |  |  718|     11|    if (xmlPatternAdd(ctxt, ctxt->comp, (op), (val), (val2))) goto error;
  |  |  ------------------
  |  |  |  Branch (718:9): [True: 0, False: 11]
  |  |  ------------------
  ------------------
  980|     11|    }
  981|     13|    return;
  982|     13|error:
  983|      0|    if (name != NULL)
  ------------------
  |  Branch (983:9): [True: 0, False: 0]
  ------------------
  984|      0|	XML_PAT_FREE_STRING(ctxt, name);
  ------------------
  |  |   84|      0|#define XML_PAT_FREE_STRING(c, r) if ((c)->comp->dict == NULL) xmlFree(r);
  |  |  ------------------
  |  |  |  Branch (84:39): [True: 0, False: 0]
  |  |  ------------------
  ------------------
  985|      0|    if (URL != NULL)
  ------------------
  |  Branch (985:9): [True: 0, False: 0]
  ------------------
  986|      0|	XML_PAT_FREE_STRING(ctxt, URL)
  ------------------
  |  |   84|      0|#define XML_PAT_FREE_STRING(c, r) if ((c)->comp->dict == NULL) xmlFree(r);
  |  |  ------------------
  |  |  |  Branch (84:39): [True: 0, False: 0]
  |  |  ------------------
  ------------------
  987|      0|    if (token != NULL)
  ------------------
  |  Branch (987:9): [True: 0, False: 0]
  ------------------
  988|      0|	XML_PAT_FREE_STRING(ctxt, token);
  ------------------
  |  |   84|      0|#define XML_PAT_FREE_STRING(c, r) if ((c)->comp->dict == NULL) xmlFree(r);
  |  |  ------------------
  |  |  |  Branch (84:39): [True: 0, False: 0]
  |  |  ------------------
  ------------------
  989|      0|}
pattern.c:xmlPatScanNCName:
  848|     30|xmlPatScanNCName(xmlPatParserContextPtr ctxt) {
  849|     30|    const xmlChar *q, *cur;
  850|     30|    xmlChar *ret = NULL;
  851|     30|    int val, len;
  852|       |
  853|     30|    SKIP_BLANKS;
  ------------------
  |  |  711|     30|    while (IS_BLANK_CH(CUR)) NEXT
  |  |  ------------------
  |  |  |  |  714|      0|#define NEXT ((*ctxt->cur) ?  ctxt->cur++: ctxt->cur)
  |  |  |  |  ------------------
  |  |  |  |  |  Branch (714:15): [True: 0, False: 0]
  |  |  |  |  ------------------
  |  |  ------------------
  ------------------
  854|       |
  855|     30|    cur = q = CUR_PTR;
  ------------------
  |  |  708|     30|#define CUR_PTR ctxt->cur
  ------------------
  856|     30|    val = xmlStringCurrentChar(NULL, cur, &len);
  857|     30|    if (!IS_LETTER(val) && (val != '_'))
  ------------------
  |  |  240|     60|#define IS_LETTER(c) (IS_BASECHAR(c) || IS_IDEOGRAPHIC(c))
  |  |  ------------------
  |  |  |  |  161|     30|#define IS_BASECHAR(c) xmlIsBaseCharQ(c)
  |  |  |  |  ------------------
  |  |  |  |  |  |   76|     60|#define xmlIsBaseCharQ(c)	(((c) < 0x100) ? \
  |  |  |  |  |  |  ------------------
  |  |  |  |  |  |  |  Branch (76:27): [True: 30, False: 0]
  |  |  |  |  |  |  |  Branch (76:28): [True: 30, False: 0]
  |  |  |  |  |  |  ------------------
  |  |  |  |  |  |   77|     60|				 xmlIsBaseChar_ch((c)) : \
  |  |  |  |  |  |  ------------------
  |  |  |  |  |  |  |  |   64|     30|#define xmlIsBaseChar_ch(c)	(((0x41 <= (c)) && ((c) <= 0x5a)) || \
  |  |  |  |  |  |  |  |  ------------------
  |  |  |  |  |  |  |  |  |  Branch (64:31): [True: 30, False: 0]
  |  |  |  |  |  |  |  |  |  Branch (64:48): [True: 4, False: 26]
  |  |  |  |  |  |  |  |  ------------------
  |  |  |  |  |  |  |  |   65|     30|				 ((0x61 <= (c)) && ((c) <= 0x7a)) || \
  |  |  |  |  |  |  |  |  ------------------
  |  |  |  |  |  |  |  |  |  Branch (65:7): [True: 26, False: 0]
  |  |  |  |  |  |  |  |  |  Branch (65:24): [True: 26, False: 0]
  |  |  |  |  |  |  |  |  ------------------
  |  |  |  |  |  |  |  |   66|     30|				 ((0xc0 <= (c)) && ((c) <= 0xd6)) || \
  |  |  |  |  |  |  |  |  ------------------
  |  |  |  |  |  |  |  |  |  Branch (66:7): [True: 0, False: 0]
  |  |  |  |  |  |  |  |  |  Branch (66:24): [True: 0, False: 0]
  |  |  |  |  |  |  |  |  ------------------
  |  |  |  |  |  |  |  |   67|     30|				 ((0xd8 <= (c)) && ((c) <= 0xf6)) || \
  |  |  |  |  |  |  |  |  ------------------
  |  |  |  |  |  |  |  |  |  Branch (67:7): [True: 0, False: 0]
  |  |  |  |  |  |  |  |  |  Branch (67:24): [True: 0, False: 0]
  |  |  |  |  |  |  |  |  ------------------
  |  |  |  |  |  |  |  |   68|     30|				  (0xf8 <= (c)))
  |  |  |  |  |  |  |  |  ------------------
  |  |  |  |  |  |  |  |  |  Branch (68:7): [True: 0, False: 0]
  |  |  |  |  |  |  |  |  ------------------
  |  |  |  |  |  |  ------------------
  |  |  |  |  |  |   78|     60|				 xmlCharInRange((c), &xmlIsBaseCharGroup))
  |  |  |  |  ------------------
  |  |  ------------------
  |  |               #define IS_LETTER(c) (IS_BASECHAR(c) || IS_IDEOGRAPHIC(c))
  |  |  ------------------
  |  |  |  |  229|      0|#define IS_IDEOGRAPHIC(c) xmlIsIdeographicQ(c)
  |  |  |  |  ------------------
  |  |  |  |  |  |  184|      0|#define xmlIsIdeographicQ(c)	(((c) < 0x100) ? \
  |  |  |  |  |  |  ------------------
  |  |  |  |  |  |  |  Branch (184:30): [True: 0, False: 0]
  |  |  |  |  |  |  |  Branch (184:31): [True: 0, False: 0]
  |  |  |  |  |  |  ------------------
  |  |  |  |  |  |  185|      0|				 0 :\
  |  |  |  |  |  |  186|      0|				(((0x4e00 <= (c)) && ((c) <= 0x9fa5)) || \
  |  |  |  |  |  |  ------------------
  |  |  |  |  |  |  |  Branch (186:7): [True: 0, False: 0]
  |  |  |  |  |  |  |  Branch (186:26): [True: 0, False: 0]
  |  |  |  |  |  |  ------------------
  |  |  |  |  |  |  187|      0|				 ((c) == 0x3007) || \
  |  |  |  |  |  |  ------------------
  |  |  |  |  |  |  |  Branch (187:6): [True: 0, False: 0]
  |  |  |  |  |  |  ------------------
  |  |  |  |  |  |  188|      0|				 ((0x3021 <= (c)) && ((c) <= 0x3029))))
  |  |  |  |  |  |  ------------------
  |  |  |  |  |  |  |  Branch (188:7): [True: 0, False: 0]
  |  |  |  |  |  |  |  Branch (188:26): [True: 0, False: 0]
  |  |  |  |  |  |  ------------------
  |  |  |  |  ------------------
  |  |  ------------------
  ------------------
  |  Branch (857:28): [True: 0, False: 0]
  ------------------
  858|      0|	return(NULL);
  859|       |
  860|    152|    while ((IS_LETTER(val)) || (IS_DIGIT(val)) ||
  ------------------
  |  |  240|    152|#define IS_LETTER(c) (IS_BASECHAR(c) || IS_IDEOGRAPHIC(c))
  |  |  ------------------
  |  |  |  |  161|    152|#define IS_BASECHAR(c) xmlIsBaseCharQ(c)
  |  |  |  |  ------------------
  |  |  |  |  |  |   76|    304|#define xmlIsBaseCharQ(c)	(((c) < 0x100) ? \
  |  |  |  |  |  |  ------------------
  |  |  |  |  |  |  |  Branch (76:27): [True: 122, False: 30]
  |  |  |  |  |  |  |  Branch (76:28): [True: 152, False: 0]
  |  |  |  |  |  |  ------------------
  |  |  |  |  |  |   77|    304|				 xmlIsBaseChar_ch((c)) : \
  |  |  |  |  |  |  ------------------
  |  |  |  |  |  |  |  |   64|    152|#define xmlIsBaseChar_ch(c)	(((0x41 <= (c)) && ((c) <= 0x5a)) || \
  |  |  |  |  |  |  |  |  ------------------
  |  |  |  |  |  |  |  |  |  Branch (64:31): [True: 122, False: 30]
  |  |  |  |  |  |  |  |  |  Branch (64:48): [True: 10, False: 112]
  |  |  |  |  |  |  |  |  ------------------
  |  |  |  |  |  |  |  |   65|    152|				 ((0x61 <= (c)) && ((c) <= 0x7a)) || \
  |  |  |  |  |  |  |  |  ------------------
  |  |  |  |  |  |  |  |  |  Branch (65:7): [True: 112, False: 30]
  |  |  |  |  |  |  |  |  |  Branch (65:24): [True: 112, False: 0]
  |  |  |  |  |  |  |  |  ------------------
  |  |  |  |  |  |  |  |   66|    152|				 ((0xc0 <= (c)) && ((c) <= 0xd6)) || \
  |  |  |  |  |  |  |  |  ------------------
  |  |  |  |  |  |  |  |  |  Branch (66:7): [True: 0, False: 30]
  |  |  |  |  |  |  |  |  |  Branch (66:24): [True: 0, False: 0]
  |  |  |  |  |  |  |  |  ------------------
  |  |  |  |  |  |  |  |   67|    152|				 ((0xd8 <= (c)) && ((c) <= 0xf6)) || \
  |  |  |  |  |  |  |  |  ------------------
  |  |  |  |  |  |  |  |  |  Branch (67:7): [True: 0, False: 30]
  |  |  |  |  |  |  |  |  |  Branch (67:24): [True: 0, False: 0]
  |  |  |  |  |  |  |  |  ------------------
  |  |  |  |  |  |  |  |   68|    152|				  (0xf8 <= (c)))
  |  |  |  |  |  |  |  |  ------------------
  |  |  |  |  |  |  |  |  |  Branch (68:7): [True: 0, False: 30]
  |  |  |  |  |  |  |  |  ------------------
  |  |  |  |  |  |  ------------------
  |  |  |  |  |  |   78|    304|				 xmlCharInRange((c), &xmlIsBaseCharGroup))
  |  |  |  |  ------------------
  |  |  ------------------
  |  |               #define IS_LETTER(c) (IS_BASECHAR(c) || IS_IDEOGRAPHIC(c))
  |  |  ------------------
  |  |  |  |  229|     30|#define IS_IDEOGRAPHIC(c) xmlIsIdeographicQ(c)
  |  |  |  |  ------------------
  |  |  |  |  |  |  184|     30|#define xmlIsIdeographicQ(c)	(((c) < 0x100) ? \
  |  |  |  |  |  |  ------------------
  |  |  |  |  |  |  |  Branch (184:30): [True: 0, False: 30]
  |  |  |  |  |  |  |  Branch (184:31): [True: 30, False: 0]
  |  |  |  |  |  |  ------------------
  |  |  |  |  |  |  185|     30|				 0 :\
  |  |  |  |  |  |  186|     30|				(((0x4e00 <= (c)) && ((c) <= 0x9fa5)) || \
  |  |  |  |  |  |  ------------------
  |  |  |  |  |  |  |  Branch (186:7): [True: 0, False: 0]
  |  |  |  |  |  |  |  Branch (186:26): [True: 0, False: 0]
  |  |  |  |  |  |  ------------------
  |  |  |  |  |  |  187|      0|				 ((c) == 0x3007) || \
  |  |  |  |  |  |  ------------------
  |  |  |  |  |  |  |  Branch (187:6): [True: 0, False: 0]
  |  |  |  |  |  |  ------------------
  |  |  |  |  |  |  188|      0|				 ((0x3021 <= (c)) && ((c) <= 0x3029))))
  |  |  |  |  |  |  ------------------
  |  |  |  |  |  |  |  Branch (188:7): [True: 0, False: 0]
  |  |  |  |  |  |  |  Branch (188:26): [True: 0, False: 0]
  |  |  |  |  |  |  ------------------
  |  |  |  |  ------------------
  |  |  ------------------
  ------------------
                  while ((IS_LETTER(val)) || (IS_DIGIT(val)) ||
  ------------------
  |  |  171|     30|#define IS_DIGIT(c) xmlIsDigitQ(c)
  |  |  ------------------
  |  |  |  |  152|     30|#define xmlIsDigitQ(c)		(((c) < 0x100) ? \
  |  |  |  |  ------------------
  |  |  |  |  |  Branch (152:26): [True: 30, False: 0]
  |  |  |  |  ------------------
  |  |  |  |  153|     30|				 xmlIsDigit_ch((c)) : \
  |  |  |  |  ------------------
  |  |  |  |  |  |  144|     30|#define xmlIsDigit_ch(c)	(((0x30 <= (c)) && ((c) <= 0x39)))
  |  |  |  |  |  |  ------------------
  |  |  |  |  |  |  |  Branch (144:28): [True: 12, False: 18]
  |  |  |  |  |  |  |  Branch (144:45): [True: 0, False: 12]
  |  |  |  |  |  |  ------------------
  |  |  |  |  ------------------
  |  |  |  |  154|     30|				 xmlCharInRange((c), &xmlIsDigitGroup))
  |  |  ------------------
  ------------------
  |  Branch (860:32): [True: 0, False: 30]
  ------------------
  861|    152|           (val == '.') || (val == '-') ||
  ------------------
  |  Branch (861:12): [True: 0, False: 30]
  |  Branch (861:28): [True: 0, False: 30]
  ------------------
  862|    152|	   (val == '_') ||
  ------------------
  |  Branch (862:5): [True: 0, False: 30]
  ------------------
  863|    152|	   (IS_COMBINING(val)) ||
  ------------------
  |  |  189|     30|#define IS_COMBINING(c) xmlIsCombiningQ(c)
  |  |  ------------------
  |  |  |  |  132|     30|#define xmlIsCombiningQ(c)	(((c) < 0x100) ? \
  |  |  |  |  ------------------
  |  |  |  |  |  Branch (132:29): [True: 30, False: 0]
  |  |  |  |  ------------------
  |  |  |  |  133|     30|				 0 : \
  |  |  |  |  134|     30|				 xmlCharInRange((c), &xmlIsCombiningGroup))
  |  |  ------------------
  ------------------
  |  Branch (863:5): [True: 0, False: 30]
  ------------------
  864|    152|	   (IS_EXTENDER(val))) {
  ------------------
  |  |  210|     30|#define IS_EXTENDER(c) xmlIsExtenderQ(c)
  |  |  ------------------
  |  |  |  |  172|     30|#define xmlIsExtenderQ(c)	(((c) < 0x100) ? \
  |  |  |  |  ------------------
  |  |  |  |  |  Branch (172:28): [True: 30, False: 0]
  |  |  |  |  ------------------
  |  |  |  |  173|     30|				 xmlIsExtender_ch((c)) : \
  |  |  |  |  ------------------
  |  |  |  |  |  |  164|     30|#define xmlIsExtender_ch(c)	(((c) == 0xb7))
  |  |  |  |  ------------------
  |  |  |  |  174|     30|				 xmlCharInRange((c), &xmlIsExtenderGroup))
  |  |  ------------------
  ------------------
  |  Branch (864:5): [True: 0, False: 30]
  ------------------
  865|    122|	cur += len;
  866|    122|	val = xmlStringCurrentChar(NULL, cur, &len);
  867|    122|    }
  868|     30|    if (ctxt->dict)
  ------------------
  |  Branch (868:9): [True: 0, False: 30]
  ------------------
  869|      0|	ret = (xmlChar *) xmlDictLookup(ctxt->dict, q, cur - q);
  870|     30|    else
  871|     30|	ret = xmlStrndup(q, cur - q);
  872|     30|    CUR_PTR = cur;
  ------------------
  |  |  708|     30|#define CUR_PTR ctxt->cur
  ------------------
  873|     30|    return(ret);
  874|     30|}
pattern.c:xmlPatScanName:
  810|     12|xmlPatScanName(xmlPatParserContextPtr ctxt) {
  811|     12|    const xmlChar *q, *cur;
  812|     12|    xmlChar *ret = NULL;
  813|     12|    int val, len;
  814|       |
  815|     12|    SKIP_BLANKS;
  ------------------
  |  |  711|     12|    while (IS_BLANK_CH(CUR)) NEXT
  |  |  ------------------
  |  |  |  |  714|      0|#define NEXT ((*ctxt->cur) ?  ctxt->cur++: ctxt->cur)
  |  |  |  |  ------------------
  |  |  |  |  |  Branch (714:15): [True: 0, False: 0]
  |  |  |  |  ------------------
  |  |  ------------------
  ------------------
  816|       |
  817|     12|    cur = q = CUR_PTR;
  ------------------
  |  |  708|     12|#define CUR_PTR ctxt->cur
  ------------------
  818|     12|    val = xmlStringCurrentChar(NULL, cur, &len);
  819|     12|    if (!IS_LETTER(val) && (val != '_') && (val != ':'))
  ------------------
  |  |  240|     24|#define IS_LETTER(c) (IS_BASECHAR(c) || IS_IDEOGRAPHIC(c))
  |  |  ------------------
  |  |  |  |  161|     12|#define IS_BASECHAR(c) xmlIsBaseCharQ(c)
  |  |  |  |  ------------------
  |  |  |  |  |  |   76|     24|#define xmlIsBaseCharQ(c)	(((c) < 0x100) ? \
  |  |  |  |  |  |  ------------------
  |  |  |  |  |  |  |  Branch (76:27): [True: 12, False: 0]
  |  |  |  |  |  |  |  Branch (76:28): [True: 12, False: 0]
  |  |  |  |  |  |  ------------------
  |  |  |  |  |  |   77|     24|				 xmlIsBaseChar_ch((c)) : \
  |  |  |  |  |  |  ------------------
  |  |  |  |  |  |  |  |   64|     12|#define xmlIsBaseChar_ch(c)	(((0x41 <= (c)) && ((c) <= 0x5a)) || \
  |  |  |  |  |  |  |  |  ------------------
  |  |  |  |  |  |  |  |  |  Branch (64:31): [True: 12, False: 0]
  |  |  |  |  |  |  |  |  |  Branch (64:48): [True: 6, False: 6]
  |  |  |  |  |  |  |  |  ------------------
  |  |  |  |  |  |  |  |   65|     12|				 ((0x61 <= (c)) && ((c) <= 0x7a)) || \
  |  |  |  |  |  |  |  |  ------------------
  |  |  |  |  |  |  |  |  |  Branch (65:7): [True: 6, False: 0]
  |  |  |  |  |  |  |  |  |  Branch (65:24): [True: 6, False: 0]
  |  |  |  |  |  |  |  |  ------------------
  |  |  |  |  |  |  |  |   66|     12|				 ((0xc0 <= (c)) && ((c) <= 0xd6)) || \
  |  |  |  |  |  |  |  |  ------------------
  |  |  |  |  |  |  |  |  |  Branch (66:7): [True: 0, False: 0]
  |  |  |  |  |  |  |  |  |  Branch (66:24): [True: 0, False: 0]
  |  |  |  |  |  |  |  |  ------------------
  |  |  |  |  |  |  |  |   67|     12|				 ((0xd8 <= (c)) && ((c) <= 0xf6)) || \
  |  |  |  |  |  |  |  |  ------------------
  |  |  |  |  |  |  |  |  |  Branch (67:7): [True: 0, False: 0]
  |  |  |  |  |  |  |  |  |  Branch (67:24): [True: 0, False: 0]
  |  |  |  |  |  |  |  |  ------------------
  |  |  |  |  |  |  |  |   68|     12|				  (0xf8 <= (c)))
  |  |  |  |  |  |  |  |  ------------------
  |  |  |  |  |  |  |  |  |  Branch (68:7): [True: 0, False: 0]
  |  |  |  |  |  |  |  |  ------------------
  |  |  |  |  |  |  ------------------
  |  |  |  |  |  |   78|     24|				 xmlCharInRange((c), &xmlIsBaseCharGroup))
  |  |  |  |  ------------------
  |  |  ------------------
  |  |               #define IS_LETTER(c) (IS_BASECHAR(c) || IS_IDEOGRAPHIC(c))
  |  |  ------------------
  |  |  |  |  229|      0|#define IS_IDEOGRAPHIC(c) xmlIsIdeographicQ(c)
  |  |  |  |  ------------------
  |  |  |  |  |  |  184|      0|#define xmlIsIdeographicQ(c)	(((c) < 0x100) ? \
  |  |  |  |  |  |  ------------------
  |  |  |  |  |  |  |  Branch (184:30): [True: 0, False: 0]
  |  |  |  |  |  |  |  Branch (184:31): [True: 0, False: 0]
  |  |  |  |  |  |  ------------------
  |  |  |  |  |  |  185|      0|				 0 :\
  |  |  |  |  |  |  186|      0|				(((0x4e00 <= (c)) && ((c) <= 0x9fa5)) || \
  |  |  |  |  |  |  ------------------
  |  |  |  |  |  |  |  Branch (186:7): [True: 0, False: 0]
  |  |  |  |  |  |  |  Branch (186:26): [True: 0, False: 0]
  |  |  |  |  |  |  ------------------
  |  |  |  |  |  |  187|      0|				 ((c) == 0x3007) || \
  |  |  |  |  |  |  ------------------
  |  |  |  |  |  |  |  Branch (187:6): [True: 0, False: 0]
  |  |  |  |  |  |  ------------------
  |  |  |  |  |  |  188|      0|				 ((0x3021 <= (c)) && ((c) <= 0x3029))))
  |  |  |  |  |  |  ------------------
  |  |  |  |  |  |  |  Branch (188:7): [True: 0, False: 0]
  |  |  |  |  |  |  |  Branch (188:26): [True: 0, False: 0]
  |  |  |  |  |  |  ------------------
  |  |  |  |  ------------------
  |  |  ------------------
  ------------------
  |  Branch (819:28): [True: 0, False: 0]
  |  Branch (819:44): [True: 0, False: 0]
  ------------------
  820|      0|	return(NULL);
  821|       |
  822|     88|    while ((IS_LETTER(val)) || (IS_DIGIT(val)) ||
  ------------------
  |  |  240|     88|#define IS_LETTER(c) (IS_BASECHAR(c) || IS_IDEOGRAPHIC(c))
  |  |  ------------------
  |  |  |  |  161|     88|#define IS_BASECHAR(c) xmlIsBaseCharQ(c)
  |  |  |  |  ------------------
  |  |  |  |  |  |   76|    176|#define xmlIsBaseCharQ(c)	(((c) < 0x100) ? \
  |  |  |  |  |  |  ------------------
  |  |  |  |  |  |  |  Branch (76:27): [True: 76, False: 12]
  |  |  |  |  |  |  |  Branch (76:28): [True: 88, False: 0]
  |  |  |  |  |  |  ------------------
  |  |  |  |  |  |   77|    176|				 xmlIsBaseChar_ch((c)) : \
  |  |  |  |  |  |  ------------------
  |  |  |  |  |  |  |  |   64|     88|#define xmlIsBaseChar_ch(c)	(((0x41 <= (c)) && ((c) <= 0x5a)) || \
  |  |  |  |  |  |  |  |  ------------------
  |  |  |  |  |  |  |  |  |  Branch (64:31): [True: 76, False: 12]
  |  |  |  |  |  |  |  |  |  Branch (64:48): [True: 9, False: 67]
  |  |  |  |  |  |  |  |  ------------------
  |  |  |  |  |  |  |  |   65|     88|				 ((0x61 <= (c)) && ((c) <= 0x7a)) || \
  |  |  |  |  |  |  |  |  ------------------
  |  |  |  |  |  |  |  |  |  Branch (65:7): [True: 67, False: 12]
  |  |  |  |  |  |  |  |  |  Branch (65:24): [True: 67, False: 0]
  |  |  |  |  |  |  |  |  ------------------
  |  |  |  |  |  |  |  |   66|     88|				 ((0xc0 <= (c)) && ((c) <= 0xd6)) || \
  |  |  |  |  |  |  |  |  ------------------
  |  |  |  |  |  |  |  |  |  Branch (66:7): [True: 0, False: 12]
  |  |  |  |  |  |  |  |  |  Branch (66:24): [True: 0, False: 0]
  |  |  |  |  |  |  |  |  ------------------
  |  |  |  |  |  |  |  |   67|     88|				 ((0xd8 <= (c)) && ((c) <= 0xf6)) || \
  |  |  |  |  |  |  |  |  ------------------
  |  |  |  |  |  |  |  |  |  Branch (67:7): [True: 0, False: 12]
  |  |  |  |  |  |  |  |  |  Branch (67:24): [True: 0, False: 0]
  |  |  |  |  |  |  |  |  ------------------
  |  |  |  |  |  |  |  |   68|     88|				  (0xf8 <= (c)))
  |  |  |  |  |  |  |  |  ------------------
  |  |  |  |  |  |  |  |  |  Branch (68:7): [True: 0, False: 12]
  |  |  |  |  |  |  |  |  ------------------
  |  |  |  |  |  |  ------------------
  |  |  |  |  |  |   78|    176|				 xmlCharInRange((c), &xmlIsBaseCharGroup))
  |  |  |  |  ------------------
  |  |  ------------------
  |  |               #define IS_LETTER(c) (IS_BASECHAR(c) || IS_IDEOGRAPHIC(c))
  |  |  ------------------
  |  |  |  |  229|     12|#define IS_IDEOGRAPHIC(c) xmlIsIdeographicQ(c)
  |  |  |  |  ------------------
  |  |  |  |  |  |  184|     12|#define xmlIsIdeographicQ(c)	(((c) < 0x100) ? \
  |  |  |  |  |  |  ------------------
  |  |  |  |  |  |  |  Branch (184:30): [True: 0, False: 12]
  |  |  |  |  |  |  |  Branch (184:31): [True: 12, False: 0]
  |  |  |  |  |  |  ------------------
  |  |  |  |  |  |  185|     12|				 0 :\
  |  |  |  |  |  |  186|     12|				(((0x4e00 <= (c)) && ((c) <= 0x9fa5)) || \
  |  |  |  |  |  |  ------------------
  |  |  |  |  |  |  |  Branch (186:7): [True: 0, False: 0]
  |  |  |  |  |  |  |  Branch (186:26): [True: 0, False: 0]
  |  |  |  |  |  |  ------------------
  |  |  |  |  |  |  187|      0|				 ((c) == 0x3007) || \
  |  |  |  |  |  |  ------------------
  |  |  |  |  |  |  |  Branch (187:6): [True: 0, False: 0]
  |  |  |  |  |  |  ------------------
  |  |  |  |  |  |  188|      0|				 ((0x3021 <= (c)) && ((c) <= 0x3029))))
  |  |  |  |  |  |  ------------------
  |  |  |  |  |  |  |  Branch (188:7): [True: 0, False: 0]
  |  |  |  |  |  |  |  Branch (188:26): [True: 0, False: 0]
  |  |  |  |  |  |  ------------------
  |  |  |  |  ------------------
  |  |  ------------------
  ------------------
                  while ((IS_LETTER(val)) || (IS_DIGIT(val)) ||
  ------------------
  |  |  171|     12|#define IS_DIGIT(c) xmlIsDigitQ(c)
  |  |  ------------------
  |  |  |  |  152|     12|#define xmlIsDigitQ(c)		(((c) < 0x100) ? \
  |  |  |  |  ------------------
  |  |  |  |  |  Branch (152:26): [True: 12, False: 0]
  |  |  |  |  ------------------
  |  |  |  |  153|     12|				 xmlIsDigit_ch((c)) : \
  |  |  |  |  ------------------
  |  |  |  |  |  |  144|     12|#define xmlIsDigit_ch(c)	(((0x30 <= (c)) && ((c) <= 0x39)))
  |  |  |  |  |  |  ------------------
  |  |  |  |  |  |  |  Branch (144:28): [True: 0, False: 12]
  |  |  |  |  |  |  |  Branch (144:45): [True: 0, False: 0]
  |  |  |  |  |  |  ------------------
  |  |  |  |  ------------------
  |  |  |  |  154|     12|				 xmlCharInRange((c), &xmlIsDigitGroup))
  |  |  ------------------
  ------------------
  |  Branch (822:32): [True: 0, False: 12]
  ------------------
  823|     88|           (val == '.') || (val == '-') ||
  ------------------
  |  Branch (823:12): [True: 0, False: 12]
  |  Branch (823:28): [True: 0, False: 12]
  ------------------
  824|     88|	   (val == '_') ||
  ------------------
  |  Branch (824:5): [True: 0, False: 12]
  ------------------
  825|     88|	   (IS_COMBINING(val)) ||
  ------------------
  |  |  189|     12|#define IS_COMBINING(c) xmlIsCombiningQ(c)
  |  |  ------------------
  |  |  |  |  132|     12|#define xmlIsCombiningQ(c)	(((c) < 0x100) ? \
  |  |  |  |  ------------------
  |  |  |  |  |  Branch (132:29): [True: 12, False: 0]
  |  |  |  |  ------------------
  |  |  |  |  133|     12|				 0 : \
  |  |  |  |  134|     12|				 xmlCharInRange((c), &xmlIsCombiningGroup))
  |  |  ------------------
  ------------------
  |  Branch (825:5): [True: 0, False: 12]
  ------------------
  826|     88|	   (IS_EXTENDER(val))) {
  ------------------
  |  |  210|     12|#define IS_EXTENDER(c) xmlIsExtenderQ(c)
  |  |  ------------------
  |  |  |  |  172|     12|#define xmlIsExtenderQ(c)	(((c) < 0x100) ? \
  |  |  |  |  ------------------
  |  |  |  |  |  Branch (172:28): [True: 12, False: 0]
  |  |  |  |  ------------------
  |  |  |  |  173|     12|				 xmlIsExtender_ch((c)) : \
  |  |  |  |  ------------------
  |  |  |  |  |  |  164|     12|#define xmlIsExtender_ch(c)	(((c) == 0xb7))
  |  |  |  |  ------------------
  |  |  |  |  174|     12|				 xmlCharInRange((c), &xmlIsExtenderGroup))
  |  |  ------------------
  ------------------
  |  Branch (826:5): [True: 0, False: 12]
  ------------------
  827|     76|	cur += len;
  828|     76|	val = xmlStringCurrentChar(NULL, cur, &len);
  829|     76|    }
  830|     12|    if (ctxt->dict)
  ------------------
  |  Branch (830:9): [True: 0, False: 12]
  ------------------
  831|      0|	ret = (xmlChar *) xmlDictLookup(ctxt->dict, q, cur - q);
  832|     12|    else
  833|     12|	ret = xmlStrndup(q, cur - q);
  834|     12|    CUR_PTR = cur;
  ------------------
  |  |  708|     12|#define CUR_PTR ctxt->cur
  ------------------
  835|     12|    return(ret);
  836|     12|}
pattern.c:xmlFreePatParserContext:
  328|     31|xmlFreePatParserContext(xmlPatParserContextPtr ctxt) {
  329|     31|    if (ctxt == NULL)
  ------------------
  |  Branch (329:9): [True: 0, False: 31]
  ------------------
  330|      0|	return;
  331|     31|    memset(ctxt, -1, sizeof(xmlPatParserContext));
  332|     31|    xmlFree(ctxt);
  333|     31|}
pattern.c:xmlStreamCompile:
 1511|     31|xmlStreamCompile(xmlPatternPtr comp) {
 1512|     31|    xmlStreamCompPtr stream;
 1513|     31|    int i, s = 0, root = 0, flags = 0, prevs = -1;
 1514|     31|    xmlStepOp step;
 1515|       |
 1516|     31|    if ((comp == NULL) || (comp->steps == NULL))
  ------------------
  |  Branch (1516:9): [True: 0, False: 31]
  |  Branch (1516:27): [True: 0, False: 31]
  ------------------
 1517|      0|        return(-1);
 1518|       |    /*
 1519|       |     * special case for .
 1520|       |     */
 1521|     31|    if ((comp->nbStep == 1) &&
  ------------------
  |  Branch (1521:9): [True: 25, False: 6]
  ------------------
 1522|     31|        (comp->steps[0].op == XML_OP_ELEM) &&
  ------------------
  |  Branch (1522:9): [True: 12, False: 13]
  ------------------
 1523|     31|	(comp->steps[0].value == NULL) &&
  ------------------
  |  Branch (1523:2): [True: 3, False: 9]
  ------------------
 1524|     31|	(comp->steps[0].value2 == NULL)) {
  ------------------
  |  Branch (1524:2): [True: 3, False: 0]
  ------------------
 1525|      3|	stream = xmlNewStreamComp(0);
 1526|      3|	if (stream == NULL)
  ------------------
  |  Branch (1526:6): [True: 0, False: 3]
  ------------------
 1527|      0|	    return(-1);
 1528|       |	/* Note that the stream will have no steps in this case. */
 1529|      3|	stream->flags |= XML_STREAM_FINAL_IS_ANY_NODE;
  ------------------
  |  |   58|      3|#define XML_STREAM_FINAL_IS_ANY_NODE 1<<14
  ------------------
 1530|      3|	comp->stream = stream;
 1531|      3|	return(0);
 1532|      3|    }
 1533|       |
 1534|     28|    stream = xmlNewStreamComp((comp->nbStep / 2) + 1);
 1535|     28|    if (stream == NULL)
  ------------------
  |  Branch (1535:9): [True: 0, False: 28]
  ------------------
 1536|      0|        return(-1);
 1537|     28|    if (comp->dict != NULL) {
  ------------------
  |  Branch (1537:9): [True: 0, False: 28]
  ------------------
 1538|      0|        stream->dict = comp->dict;
 1539|      0|	xmlDictReference(stream->dict);
 1540|      0|    }
 1541|       |
 1542|     28|    i = 0;
 1543|     28|    if (comp->flags & PAT_FROM_ROOT)
  ------------------
  |  |  158|     28|#define PAT_FROM_ROOT	(1<<8)
  ------------------
  |  Branch (1543:9): [True: 0, False: 28]
  ------------------
 1544|      0|	stream->flags |= XML_STREAM_FROM_ROOT;
  ------------------
  |  |   59|      0|#define XML_STREAM_FROM_ROOT 1<<15
  ------------------
 1545|       |
 1546|     64|    for (;i < comp->nbStep;i++) {
  ------------------
  |  Branch (1546:11): [True: 36, False: 28]
  ------------------
 1547|     36|	step = comp->steps[i];
 1548|     36|        switch (step.op) {
  ------------------
  |  Branch (1548:17): [True: 0, False: 36]
  ------------------
 1549|      0|	    case XML_OP_END:
  ------------------
  |  Branch (1549:6): [True: 0, False: 36]
  ------------------
 1550|      0|	        break;
 1551|      0|	    case XML_OP_ROOT:
  ------------------
  |  Branch (1551:6): [True: 0, False: 36]
  ------------------
 1552|      0|	        if (i != 0)
  ------------------
  |  Branch (1552:14): [True: 0, False: 0]
  ------------------
 1553|      0|		    goto error;
 1554|      0|		root = 1;
 1555|      0|		break;
 1556|      0|	    case XML_OP_NS:
  ------------------
  |  Branch (1556:6): [True: 0, False: 36]
  ------------------
 1557|      0|		s = xmlStreamCompAddStep(stream, NULL, step.value,
 1558|      0|		    XML_ELEMENT_NODE, flags);
 1559|      0|		if (s < 0)
  ------------------
  |  Branch (1559:7): [True: 0, False: 0]
  ------------------
 1560|      0|		    goto error;
 1561|      0|		prevs = s;
 1562|      0|		flags = 0;
 1563|      0|		break;
 1564|     13|	    case XML_OP_ATTR:
  ------------------
  |  Branch (1564:6): [True: 13, False: 23]
  ------------------
 1565|     13|		flags |= XML_STREAM_STEP_ATTR;
  ------------------
  |  |   48|     13|#define XML_STREAM_STEP_ATTR	8
  ------------------
 1566|     13|		prevs = -1;
 1567|     13|		s = xmlStreamCompAddStep(stream,
 1568|     13|		    step.value, step.value2, XML_ATTRIBUTE_NODE, flags);
 1569|     13|		flags = 0;
 1570|     13|		if (s < 0)
  ------------------
  |  Branch (1570:7): [True: 0, False: 13]
  ------------------
 1571|      0|		    goto error;
 1572|     13|		break;
 1573|     17|	    case XML_OP_ELEM:
  ------------------
  |  Branch (1573:6): [True: 17, False: 19]
  ------------------
 1574|     17|	        if ((step.value == NULL) && (step.value2 == NULL)) {
  ------------------
  |  Branch (1574:14): [True: 0, False: 17]
  |  Branch (1574:38): [True: 0, False: 0]
  ------------------
 1575|       |		    /*
 1576|       |		    * We have a "." or "self::node()" here.
 1577|       |		    * Eliminate redundant self::node() tests like in "/./."
 1578|       |		    * or "//./"
 1579|       |		    * The only case we won't eliminate is "//.", i.e. if
 1580|       |		    * self::node() is the last node test and we had
 1581|       |		    * continuation somewhere beforehand.
 1582|       |		    */
 1583|      0|		    if ((comp->nbStep == i + 1) &&
  ------------------
  |  Branch (1583:11): [True: 0, False: 0]
  ------------------
 1584|      0|			(flags & XML_STREAM_STEP_DESC)) {
  ------------------
  |  |   45|      0|#define XML_STREAM_STEP_DESC	1
  ------------------
  |  Branch (1584:4): [True: 0, False: 0]
  ------------------
 1585|       |			/*
 1586|       |			* Mark the special case where the expression resolves
 1587|       |			* to any type of node.
 1588|       |			*/
 1589|      0|			if (comp->nbStep == i + 1) {
  ------------------
  |  Branch (1589:8): [True: 0, False: 0]
  ------------------
 1590|      0|			    stream->flags |= XML_STREAM_FINAL_IS_ANY_NODE;
  ------------------
  |  |   58|      0|#define XML_STREAM_FINAL_IS_ANY_NODE 1<<14
  ------------------
 1591|      0|			}
 1592|      0|			flags |= XML_STREAM_STEP_NODE;
  ------------------
  |  |   49|      0|#define XML_STREAM_STEP_NODE	16
  ------------------
 1593|      0|			s = xmlStreamCompAddStep(stream, NULL, NULL,
 1594|      0|			    XML_STREAM_ANY_NODE, flags);
  ------------------
  |  |   66|      0|#define XML_STREAM_ANY_NODE 100
  ------------------
 1595|      0|			if (s < 0)
  ------------------
  |  Branch (1595:8): [True: 0, False: 0]
  ------------------
 1596|      0|			    goto error;
 1597|      0|			flags = 0;
 1598|       |			/*
 1599|       |			* If there was a previous step, mark it to be added to
 1600|       |			* the result node-set; this is needed since only
 1601|       |			* the last step will be marked as "final" and only
 1602|       |			* "final" nodes are added to the resulting set.
 1603|       |			*/
 1604|      0|			if (prevs != -1) {
  ------------------
  |  Branch (1604:8): [True: 0, False: 0]
  ------------------
 1605|      0|			    stream->steps[prevs].flags |= XML_STREAM_STEP_IN_SET;
  ------------------
  |  |   50|      0|#define XML_STREAM_STEP_IN_SET	32
  ------------------
 1606|      0|			    prevs = -1;
 1607|      0|			}
 1608|      0|			break;
 1609|       |
 1610|      0|		    } else {
 1611|       |			/* Just skip this one. */
 1612|      0|			continue;
 1613|      0|		    }
 1614|      0|		}
 1615|       |		/* An element node. */
 1616|     17|	        s = xmlStreamCompAddStep(stream, step.value, step.value2,
 1617|     17|		    XML_ELEMENT_NODE, flags);
 1618|     17|		if (s < 0)
  ------------------
  |  Branch (1618:7): [True: 0, False: 17]
  ------------------
 1619|      0|		    goto error;
 1620|     17|		prevs = s;
 1621|     17|		flags = 0;
 1622|     17|		break;
 1623|      0|	    case XML_OP_CHILD:
  ------------------
  |  Branch (1623:6): [True: 0, False: 36]
  ------------------
 1624|       |		/* An element node child. */
 1625|      0|	        s = xmlStreamCompAddStep(stream, step.value, step.value2,
 1626|      0|		    XML_ELEMENT_NODE, flags);
 1627|      0|		if (s < 0)
  ------------------
  |  Branch (1627:7): [True: 0, False: 0]
  ------------------
 1628|      0|		    goto error;
 1629|      0|		prevs = s;
 1630|      0|		flags = 0;
 1631|      0|		break;
 1632|      0|	    case XML_OP_ALL:
  ------------------
  |  Branch (1632:6): [True: 0, False: 36]
  ------------------
 1633|      0|	        s = xmlStreamCompAddStep(stream, NULL, NULL,
 1634|      0|		    XML_ELEMENT_NODE, flags);
 1635|      0|		if (s < 0)
  ------------------
  |  Branch (1635:7): [True: 0, False: 0]
  ------------------
 1636|      0|		    goto error;
 1637|      0|		prevs = s;
 1638|      0|		flags = 0;
 1639|      0|		break;
 1640|      2|	    case XML_OP_PARENT:
  ------------------
  |  Branch (1640:6): [True: 2, False: 34]
  ------------------
 1641|      2|	        break;
 1642|      4|	    case XML_OP_ANCESTOR:
  ------------------
  |  Branch (1642:6): [True: 4, False: 32]
  ------------------
 1643|       |		/* Skip redundant continuations. */
 1644|      4|		if (flags & XML_STREAM_STEP_DESC)
  ------------------
  |  |   45|      4|#define XML_STREAM_STEP_DESC	1
  ------------------
  |  Branch (1644:7): [True: 0, False: 4]
  ------------------
 1645|      0|		    break;
 1646|      4|	        flags |= XML_STREAM_STEP_DESC;
  ------------------
  |  |   45|      4|#define XML_STREAM_STEP_DESC	1
  ------------------
 1647|       |		/*
 1648|       |		* Mark the expression as having "//".
 1649|       |		*/
 1650|      4|		if ((stream->flags & XML_STREAM_DESC) == 0)
  ------------------
  |  |   60|      4|#define XML_STREAM_DESC 1<<16
  ------------------
  |  Branch (1650:7): [True: 4, False: 0]
  ------------------
 1651|      4|		    stream->flags |= XML_STREAM_DESC;
  ------------------
  |  |   60|      4|#define XML_STREAM_DESC 1<<16
  ------------------
 1652|      4|		break;
 1653|     36|	}
 1654|     36|    }
 1655|     28|    if ((! root) && (comp->flags & XML_PATTERN_NOTPATTERN) == 0) {
  ------------------
  |  |   68|     28|#define XML_PATTERN_NOTPATTERN  (XML_PATTERN_XPATH | \
  |  |   69|     28|				 XML_PATTERN_XSSEL | \
  |  |   70|     28|				 XML_PATTERN_XSFIELD)
  ------------------
  |  Branch (1655:9): [True: 28, False: 0]
  |  Branch (1655:21): [True: 0, False: 28]
  ------------------
 1656|       |	/*
 1657|       |	* If this should behave like a real pattern, we will mark
 1658|       |	* the first step as having "//", to be reentrant on every
 1659|       |	* tree level.
 1660|       |	*/
 1661|      0|	if ((stream->flags & XML_STREAM_DESC) == 0)
  ------------------
  |  |   60|      0|#define XML_STREAM_DESC 1<<16
  ------------------
  |  Branch (1661:6): [True: 0, False: 0]
  ------------------
 1662|      0|	    stream->flags |= XML_STREAM_DESC;
  ------------------
  |  |   60|      0|#define XML_STREAM_DESC 1<<16
  ------------------
 1663|       |
 1664|      0|	if (stream->nbStep > 0) {
  ------------------
  |  Branch (1664:6): [True: 0, False: 0]
  ------------------
 1665|      0|	    if ((stream->steps[0].flags & XML_STREAM_STEP_DESC) == 0)
  ------------------
  |  |   45|      0|#define XML_STREAM_STEP_DESC	1
  ------------------
  |  Branch (1665:10): [True: 0, False: 0]
  ------------------
 1666|      0|		stream->steps[0].flags |= XML_STREAM_STEP_DESC;
  ------------------
  |  |   45|      0|#define XML_STREAM_STEP_DESC	1
  ------------------
 1667|      0|	}
 1668|      0|    }
 1669|     28|    if (stream->nbStep <= s)
  ------------------
  |  Branch (1669:9): [True: 0, False: 28]
  ------------------
 1670|      0|	goto error;
 1671|     28|    stream->steps[s].flags |= XML_STREAM_STEP_FINAL;
  ------------------
  |  |   46|     28|#define XML_STREAM_STEP_FINAL	2
  ------------------
 1672|     28|    if (root)
  ------------------
  |  Branch (1672:9): [True: 0, False: 28]
  ------------------
 1673|      0|	stream->steps[0].flags |= XML_STREAM_STEP_ROOT;
  ------------------
  |  |   47|      0|#define XML_STREAM_STEP_ROOT	4
  ------------------
 1674|     28|    comp->stream = stream;
 1675|     28|    return(0);
 1676|      0|error:
 1677|      0|    xmlFreeStreamComp(stream);
 1678|      0|    return(0);
 1679|     28|}
pattern.c:xmlNewStreamComp:
 1425|     31|xmlNewStreamComp(int size) {
 1426|     31|    xmlStreamCompPtr cur;
 1427|       |
 1428|     31|    if (size < 4)
  ------------------
  |  Branch (1428:9): [True: 31, False: 0]
  ------------------
 1429|     31|        size  = 4;
 1430|       |
 1431|     31|    cur = (xmlStreamCompPtr) xmlMalloc(sizeof(xmlStreamComp));
 1432|     31|    if (cur == NULL) {
  ------------------
  |  Branch (1432:9): [True: 0, False: 31]
  ------------------
 1433|      0|	ERROR(NULL, NULL, NULL,
 1434|      0|		"xmlNewStreamComp: malloc failed\n");
 1435|      0|	return(NULL);
 1436|      0|    }
 1437|     31|    memset(cur, 0, sizeof(xmlStreamComp));
 1438|     31|    cur->steps = (xmlStreamStepPtr) xmlMalloc(size * sizeof(xmlStreamStep));
 1439|     31|    if (cur->steps == NULL) {
  ------------------
  |  Branch (1439:9): [True: 0, False: 31]
  ------------------
 1440|      0|	xmlFree(cur);
 1441|      0|	ERROR(NULL, NULL, NULL,
 1442|      0|	      "xmlNewStreamComp: malloc failed\n");
 1443|      0|	return(NULL);
 1444|      0|    }
 1445|     31|    cur->nbStep = 0;
 1446|     31|    cur->maxStep = size;
 1447|     31|    return(cur);
 1448|     31|}
pattern.c:xmlStreamCompAddStep:
 1480|     30|                     const xmlChar *ns, int nodeType, int flags) {
 1481|     30|    xmlStreamStepPtr cur;
 1482|       |
 1483|     30|    if (comp->nbStep >= comp->maxStep) {
  ------------------
  |  Branch (1483:9): [True: 0, False: 30]
  ------------------
 1484|      0|	cur = (xmlStreamStepPtr) xmlRealloc(comp->steps,
 1485|      0|				 comp->maxStep * 2 * sizeof(xmlStreamStep));
 1486|      0|	if (cur == NULL) {
  ------------------
  |  Branch (1486:6): [True: 0, False: 0]
  ------------------
 1487|      0|	    ERROR(NULL, NULL, NULL,
 1488|      0|		  "xmlNewStreamComp: malloc failed\n");
 1489|      0|	    return(-1);
 1490|      0|	}
 1491|      0|	comp->steps = cur;
 1492|      0|        comp->maxStep *= 2;
 1493|      0|    }
 1494|     30|    cur = &comp->steps[comp->nbStep++];
 1495|     30|    cur->flags = flags;
 1496|     30|    cur->name = name;
 1497|     30|    cur->ns = ns;
 1498|     30|    cur->nodeType = nodeType;
 1499|     30|    return(comp->nbStep - 1);
 1500|     30|}
pattern.c:xmlReversePattern:
  408|     31|xmlReversePattern(xmlPatternPtr comp) {
  409|     31|    int i, j;
  410|       |
  411|       |    /*
  412|       |     * remove the leading // for //a or .//a
  413|       |     */
  414|     31|    if ((comp->nbStep > 0) && (comp->steps[0].op == XML_OP_ANCESTOR)) {
  ------------------
  |  Branch (414:9): [True: 31, False: 0]
  |  Branch (414:31): [True: 4, False: 27]
  ------------------
  415|      8|        for (i = 0, j = 1;j < comp->nbStep;i++,j++) {
  ------------------
  |  Branch (415:27): [True: 4, False: 4]
  ------------------
  416|      4|	    comp->steps[i].value = comp->steps[j].value;
  417|      4|	    comp->steps[i].value2 = comp->steps[j].value2;
  418|      4|	    comp->steps[i].op = comp->steps[j].op;
  419|      4|	}
  420|      4|	comp->nbStep--;
  421|      4|    }
  422|     31|    if (comp->nbStep >= comp->maxStep) {
  ------------------
  |  Branch (422:9): [True: 0, False: 31]
  ------------------
  423|      0|        xmlStepOpPtr temp;
  424|      0|	temp = (xmlStepOpPtr) xmlRealloc(comp->steps, comp->maxStep * 2 *
  425|      0|	                                 sizeof(xmlStepOp));
  426|      0|        if (temp == NULL) {
  ------------------
  |  Branch (426:13): [True: 0, False: 0]
  ------------------
  427|      0|	    ERROR(ctxt, NULL, NULL,
  428|      0|			     "xmlReversePattern: realloc failed\n");
  429|      0|	    return (-1);
  430|      0|	}
  431|      0|	comp->steps = temp;
  432|      0|	comp->maxStep *= 2;
  433|      0|    }
  434|     31|    i = 0;
  435|     31|    j = comp->nbStep - 1;
  436|     33|    while (j > i) {
  ------------------
  |  Branch (436:12): [True: 2, False: 31]
  ------------------
  437|      2|	register const xmlChar *tmp;
  438|      2|	register xmlPatOp op;
  439|      2|	tmp = comp->steps[i].value;
  440|      2|	comp->steps[i].value = comp->steps[j].value;
  441|      2|	comp->steps[j].value = tmp;
  442|      2|	tmp = comp->steps[i].value2;
  443|      2|	comp->steps[i].value2 = comp->steps[j].value2;
  444|      2|	comp->steps[j].value2 = tmp;
  445|      2|	op = comp->steps[i].op;
  446|      2|	comp->steps[i].op = comp->steps[j].op;
  447|      2|	comp->steps[j].op = op;
  448|      2|	j--;
  449|      2|	i++;
  450|      2|    }
  451|     31|    comp->steps[comp->nbStep].value = NULL;
  452|     31|    comp->steps[comp->nbStep].value2 = NULL;
  453|     31|    comp->steps[comp->nbStep++].op = XML_OP_END;
  454|     31|    return(0);
  455|     31|}
pattern.c:xmlFreeStreamComp:
 1457|     31|xmlFreeStreamComp(xmlStreamCompPtr comp) {
 1458|     31|    if (comp != NULL) {
  ------------------
  |  Branch (1458:9): [True: 31, False: 0]
  ------------------
 1459|     31|        if (comp->steps != NULL)
  ------------------
  |  Branch (1459:13): [True: 31, False: 0]
  ------------------
 1460|     31|	    xmlFree(comp->steps);
 1461|     31|	if (comp->dict != NULL)
  ------------------
  |  Branch (1461:6): [True: 0, False: 31]
  ------------------
 1462|      0|	    xmlDictFree(comp->dict);
 1463|     31|        xmlFree(comp);
 1464|     31|    }
 1465|     31|}

xmlInitMutex:
  129|      8|{
  130|      8|#ifdef HAVE_POSIX_THREADS
  131|      8|    if (XML_IS_NEVER_THREADED() == 0)
  ------------------
  |  |   85|      8|#define XML_IS_NEVER_THREADED() (!libxml_is_threaded)
  ------------------
  |  Branch (131:9): [True: 8, False: 0]
  ------------------
  132|      8|        pthread_mutex_init(&mutex->lock, NULL);
  133|       |#elif defined HAVE_WIN32_THREADS
  134|       |    InitializeCriticalSection(&mutex->cs);
  135|       |#else
  136|       |    (void) mutex;
  137|       |#endif
  138|      8|}
xmlMutexLock:
  202|  3.21k|{
  203|  3.21k|    if (tok == NULL)
  ------------------
  |  Branch (203:9): [True: 0, False: 3.21k]
  ------------------
  204|      0|        return;
  205|  3.21k|#ifdef HAVE_POSIX_THREADS
  206|       |    /*
  207|       |     * This assumes that __libc_single_threaded won't change while the
  208|       |     * lock is held.
  209|       |     */
  210|  3.21k|    if (XML_IS_THREADED() != 0)
  ------------------
  |  |   84|  3.21k|#define XML_IS_THREADED() libxml_is_threaded
  ------------------
  |  Branch (210:9): [True: 3.21k, False: 0]
  ------------------
  211|  3.21k|        pthread_mutex_lock(&tok->lock);
  212|       |#elif defined HAVE_WIN32_THREADS
  213|       |    EnterCriticalSection(&tok->cs);
  214|       |#endif
  215|       |
  216|  3.21k|}
xmlMutexUnlock:
  226|  3.21k|{
  227|  3.21k|    if (tok == NULL)
  ------------------
  |  Branch (227:9): [True: 0, False: 3.21k]
  ------------------
  228|      0|        return;
  229|  3.21k|#ifdef HAVE_POSIX_THREADS
  230|  3.21k|    if (XML_IS_THREADED() != 0)
  ------------------
  |  |   84|  3.21k|#define XML_IS_THREADED() libxml_is_threaded
  ------------------
  |  Branch (230:9): [True: 3.21k, False: 0]
  ------------------
  231|  3.21k|        pthread_mutex_unlock(&tok->lock);
  232|       |#elif defined HAVE_WIN32_THREADS
  233|       |    LeaveCriticalSection(&tok->cs);
  234|       |#endif
  235|  3.21k|}
xmlNewRMutex:
  249|      2|{
  250|      2|    xmlRMutexPtr tok;
  251|       |
  252|      2|    if ((tok = malloc(sizeof(xmlRMutex))) == NULL)
  ------------------
  |  Branch (252:9): [True: 0, False: 2]
  ------------------
  253|      0|        return (NULL);
  254|      2|#ifdef HAVE_POSIX_THREADS
  255|      2|    if (XML_IS_NEVER_THREADED() == 0) {
  ------------------
  |  |   85|      2|#define XML_IS_NEVER_THREADED() (!libxml_is_threaded)
  ------------------
  |  Branch (255:9): [True: 2, False: 0]
  ------------------
  256|      2|        pthread_mutex_init(&tok->lock, NULL);
  257|      2|        tok->held = 0;
  258|      2|        tok->waiters = 0;
  259|      2|        pthread_cond_init(&tok->cv, NULL);
  260|      2|    }
  261|       |#elif defined HAVE_WIN32_THREADS
  262|       |    InitializeCriticalSection(&tok->cs);
  263|       |#endif
  264|      2|    return (tok);
  265|      2|}
xmlRMutexLock:
  298|      2|{
  299|      2|    if (tok == NULL)
  ------------------
  |  Branch (299:9): [True: 0, False: 2]
  ------------------
  300|      0|        return;
  301|      2|#ifdef HAVE_POSIX_THREADS
  302|      2|    if (XML_IS_THREADED() == 0)
  ------------------
  |  |   84|      2|#define XML_IS_THREADED() libxml_is_threaded
  ------------------
  |  Branch (302:9): [True: 0, False: 2]
  ------------------
  303|      0|        return;
  304|       |
  305|      2|    pthread_mutex_lock(&tok->lock);
  306|      2|    if (tok->held) {
  ------------------
  |  Branch (306:9): [True: 0, False: 2]
  ------------------
  307|      0|        if (pthread_equal(tok->tid, pthread_self())) {
  ------------------
  |  Branch (307:13): [True: 0, False: 0]
  ------------------
  308|      0|            tok->held++;
  309|      0|            pthread_mutex_unlock(&tok->lock);
  310|      0|            return;
  311|      0|        } else {
  312|      0|            tok->waiters++;
  313|      0|            while (tok->held)
  ------------------
  |  Branch (313:20): [True: 0, False: 0]
  ------------------
  314|      0|                pthread_cond_wait(&tok->cv, &tok->lock);
  315|      0|            tok->waiters--;
  316|      0|        }
  317|      0|    }
  318|      2|    tok->tid = pthread_self();
  319|      2|    tok->held = 1;
  320|      2|    pthread_mutex_unlock(&tok->lock);
  321|       |#elif defined HAVE_WIN32_THREADS
  322|       |    EnterCriticalSection(&tok->cs);
  323|       |#endif
  324|      2|}
xmlRMutexUnlock:
  334|      2|{
  335|      2|    if (tok == NULL)
  ------------------
  |  Branch (335:9): [True: 0, False: 2]
  ------------------
  336|      0|        return;
  337|      2|#ifdef HAVE_POSIX_THREADS
  338|      2|    if (XML_IS_THREADED() == 0)
  ------------------
  |  |   84|      2|#define XML_IS_THREADED() libxml_is_threaded
  ------------------
  |  Branch (338:9): [True: 0, False: 2]
  ------------------
  339|      0|        return;
  340|       |
  341|      2|    pthread_mutex_lock(&tok->lock);
  342|      2|    tok->held--;
  343|      2|    if (tok->held == 0) {
  ------------------
  |  Branch (343:9): [True: 2, False: 0]
  ------------------
  344|      2|        if (tok->waiters)
  ------------------
  |  Branch (344:13): [True: 0, False: 2]
  ------------------
  345|      0|            pthread_cond_signal(&tok->cv);
  346|      2|        memset(&tok->tid, 0, sizeof(tok->tid));
  347|      2|    }
  348|      2|    pthread_mutex_unlock(&tok->lock);
  349|       |#elif defined HAVE_WIN32_THREADS
  350|       |    LeaveCriticalSection(&tok->cs);
  351|       |#endif
  352|      2|}
xmlInitParser:
  569|  1.84k|xmlInitParser(void) {
  570|       |    /*
  571|       |     * Note that the initialization code must not make memory allocations.
  572|       |     */
  573|  1.84k|    if (xmlParserInitialized != 0)
  ------------------
  |  Branch (573:9): [True: 1.84k, False: 2]
  ------------------
  574|  1.84k|        return;
  575|       |
  576|      2|    xmlGlobalInitMutexLock();
  577|       |
  578|      2|    if (xmlParserInnerInitialized == 0) {
  ------------------
  |  Branch (578:9): [True: 2, False: 0]
  ------------------
  579|       |#if defined(_WIN32) && \
  580|       |    !defined(LIBXML_THREAD_ALLOC_ENABLED) && \
  581|       |    (!defined(LIBXML_STATIC) || defined(LIBXML_STATIC_FOR_DLL))
  582|       |        if (xmlFree == free)
  583|       |            atexit(xmlCleanupParser);
  584|       |#endif
  585|       |
  586|      2|        xmlInitMemoryInternal(); /* Should come second */
  587|      2|        xmlInitGlobalsInternal();
  588|      2|        xmlInitRandom();
  589|      2|        xmlInitDictInternal();
  590|      2|        xmlInitEncodingInternal();
  591|      2|#if defined(LIBXML_XPATH_ENABLED) || defined(LIBXML_SCHEMAS_ENABLED)
  592|      2|        xmlInitXPathInternal();
  593|      2|#endif
  594|       |
  595|      2|        xmlRegisterDefaultInputCallbacks();
  596|      2|#ifdef LIBXML_OUTPUT_ENABLED
  597|      2|        xmlRegisterDefaultOutputCallbacks();
  598|      2|#endif /* LIBXML_OUTPUT_ENABLED */
  599|       |
  600|      2|        xmlParserInnerInitialized = 1;
  601|      2|    }
  602|       |
  603|      2|    xmlGlobalInitMutexUnlock();
  604|       |
  605|      2|    xmlParserInitialized = 1;
  606|      2|}
threads.c:xmlGlobalInitMutexLock:
  462|      2|xmlGlobalInitMutexLock(void) {
  463|      2|#ifdef HAVE_POSIX_THREADS
  464|       |
  465|      2|#ifdef XML_PTHREAD_WEAK
  466|       |    /*
  467|       |     * This is somewhat unreliable since libpthread could be loaded
  468|       |     * later with dlopen() and threads could be created. But it's
  469|       |     * long-standing behavior and hard to work around.
  470|       |     */
  471|      2|    if (libxml_is_threaded == -1)
  ------------------
  |  Branch (471:9): [True: 2, False: 0]
  ------------------
  472|      2|        libxml_is_threaded =
  473|      2|            (pthread_mutex_init != NULL) &&
  ------------------
  |  Branch (473:13): [True: 2, False: 0]
  ------------------
  474|      2|            (pthread_mutex_destroy != NULL) &&
  ------------------
  |  Branch (474:13): [True: 2, False: 0]
  ------------------
  475|      2|            (pthread_mutex_lock != NULL) &&
  ------------------
  |  Branch (475:13): [True: 2, False: 0]
  ------------------
  476|      2|            (pthread_mutex_unlock != NULL) &&
  ------------------
  |  Branch (476:13): [True: 2, False: 0]
  ------------------
  477|      2|            (pthread_cond_init != NULL) &&
  ------------------
  |  Branch (477:13): [True: 2, False: 0]
  ------------------
  478|      2|            (pthread_cond_destroy != NULL) &&
  ------------------
  |  Branch (478:13): [True: 2, False: 0]
  ------------------
  479|      2|            (pthread_cond_wait != NULL) &&
  ------------------
  |  Branch (479:13): [True: 2, False: 0]
  ------------------
  480|       |            /*
  481|       |             * pthread_equal can be inline, resuting in -Waddress warnings.
  482|       |             * Let's assume it's available if all the other functions are.
  483|       |             */
  484|       |            /* (pthread_equal != NULL) && */
  485|      2|            (pthread_self != NULL) &&
  ------------------
  |  Branch (485:13): [True: 2, False: 0]
  ------------------
  486|      2|            (pthread_cond_signal != NULL);
  ------------------
  |  Branch (486:13): [True: 2, False: 0]
  ------------------
  487|      2|#endif
  488|       |
  489|       |    /* The mutex is statically initialized, so we just lock it. */
  490|      2|    if (XML_IS_THREADED() != 0)
  ------------------
  |  |   84|      2|#define XML_IS_THREADED() libxml_is_threaded
  ------------------
  |  Branch (490:9): [True: 2, False: 0]
  ------------------
  491|      2|        pthread_mutex_lock(&global_init_lock);
  492|       |
  493|       |#elif defined HAVE_WIN32_THREADS
  494|       |
  495|       |    LPCRITICAL_SECTION cs;
  496|       |
  497|       |    /* Create a new critical section */
  498|       |    if (global_init_lock == NULL) {
  499|       |        cs = malloc(sizeof(CRITICAL_SECTION));
  500|       |        if (cs == NULL) {
  501|       |            xmlGenericError(xmlGenericErrorContext,
  502|       |                            "xmlGlobalInitMutexLock: out of memory\n");
  503|       |            return;
  504|       |        }
  505|       |        InitializeCriticalSection(cs);
  506|       |
  507|       |        /* Swap it into the global_init_lock */
  508|       |#ifdef InterlockedCompareExchangePointer
  509|       |        InterlockedCompareExchangePointer((void **) &global_init_lock,
  510|       |                                          cs, NULL);
  511|       |#else /* Use older void* version */
  512|       |        InterlockedCompareExchange((void **) &global_init_lock,
  513|       |                                   (void *) cs, NULL);
  514|       |#endif /* InterlockedCompareExchangePointer */
  515|       |
  516|       |        /* If another thread successfully recorded its critical
  517|       |         * section in the global_init_lock then discard the one
  518|       |         * allocated by this thread. */
  519|       |        if (global_init_lock != cs) {
  520|       |            DeleteCriticalSection(cs);
  521|       |            free(cs);
  522|       |        }
  523|       |    }
  524|       |
  525|       |    /* Lock the chosen critical section */
  526|       |    EnterCriticalSection(global_init_lock);
  527|       |
  528|       |#endif
  529|      2|}
threads.c:xmlGlobalInitMutexUnlock:
  532|      2|xmlGlobalInitMutexUnlock(void) {
  533|      2|#ifdef HAVE_POSIX_THREADS
  534|      2|    if (XML_IS_THREADED() != 0)
  ------------------
  |  |   84|      2|#define XML_IS_THREADED() libxml_is_threaded
  ------------------
  |  Branch (534:9): [True: 2, False: 0]
  ------------------
  535|      2|        pthread_mutex_unlock(&global_init_lock);
  536|       |#elif defined HAVE_WIN32_THREADS
  537|       |    if (global_init_lock != NULL)
  538|       |	LeaveCriticalSection(global_init_lock);
  539|       |#endif
  540|      2|}

xmlSplitQName3:
  322|    646|xmlSplitQName3(const xmlChar *name, int *len) {
  323|    646|    int l = 0;
  324|       |
  325|    646|    if (name == NULL) return(NULL);
  ------------------
  |  Branch (325:9): [True: 0, False: 646]
  ------------------
  326|    646|    if (len == NULL) return(NULL);
  ------------------
  |  Branch (326:9): [True: 0, False: 646]
  ------------------
  327|       |
  328|       |    /* nasty but valid */
  329|    646|    if (name[0] == ':')
  ------------------
  |  Branch (329:9): [True: 0, False: 646]
  ------------------
  330|      0|	return(NULL);
  331|       |
  332|       |    /*
  333|       |     * we are not trying to validate but just to cut, and yes it will
  334|       |     * work even if this is as set of UTF-8 encoded chars
  335|       |     */
  336|  2.32k|    while ((name[l] != 0) && (name[l] != ':'))
  ------------------
  |  Branch (336:12): [True: 2.32k, False: 0]
  |  Branch (336:30): [True: 1.68k, False: 646]
  ------------------
  337|  1.68k|	l++;
  338|       |
  339|    646|    if (name[l] == 0)
  ------------------
  |  Branch (339:9): [True: 0, False: 646]
  ------------------
  340|      0|	return(NULL);
  341|       |
  342|    646|    *len = l;
  343|       |
  344|    646|    return(&name[l+1]);
  345|    646|}
xmlValidateNCName:
  366|  1.14k|xmlValidateNCName(const xmlChar *value, int space) {
  367|  1.14k|    const xmlChar *cur = value;
  368|  1.14k|    int c,l;
  369|       |
  370|  1.14k|    if (value == NULL)
  ------------------
  |  Branch (370:9): [True: 0, False: 1.14k]
  ------------------
  371|      0|        return(-1);
  372|       |
  373|       |    /*
  374|       |     * First quick algorithm for ASCII range
  375|       |     */
  376|  1.14k|    if (space)
  ------------------
  |  Branch (376:9): [True: 1.14k, False: 0]
  ------------------
  377|  1.14k|	while (IS_BLANK_CH(*cur)) cur++;
  378|  1.14k|    if (((*cur >= 'a') && (*cur <= 'z')) || ((*cur >= 'A') && (*cur <= 'Z')) ||
  ------------------
  |  Branch (378:10): [True: 1.03k, False: 109]
  |  Branch (378:27): [True: 1.03k, False: 0]
  |  Branch (378:46): [True: 109, False: 0]
  |  Branch (378:63): [True: 109, False: 0]
  ------------------
  379|  1.14k|	(*cur == '_'))
  ------------------
  |  Branch (379:2): [True: 0, False: 0]
  ------------------
  380|  1.14k|	cur++;
  381|      0|    else
  382|      0|	goto try_complex;
  383|  8.57k|    while (((*cur >= 'a') && (*cur <= 'z')) ||
  ------------------
  |  Branch (383:13): [True: 5.99k, False: 2.58k]
  |  Branch (383:30): [True: 5.99k, False: 0]
  ------------------
  384|  8.57k|	   ((*cur >= 'A') && (*cur <= 'Z')) ||
  ------------------
  |  Branch (384:6): [True: 680, False: 1.90k]
  |  Branch (384:23): [True: 458, False: 222]
  ------------------
  385|  8.57k|	   ((*cur >= '0') && (*cur <= '9')) ||
  ------------------
  |  Branch (385:6): [True: 623, False: 1.50k]
  |  Branch (385:23): [True: 401, False: 222]
  ------------------
  386|  8.57k|	   (*cur == '_') || (*cur == '-') || (*cur == '.'))
  ------------------
  |  Branch (386:5): [True: 222, False: 1.50k]
  |  Branch (386:22): [True: 72, False: 1.42k]
  |  Branch (386:39): [True: 282, False: 1.14k]
  ------------------
  387|  7.43k|	cur++;
  388|  1.14k|    if (space)
  ------------------
  |  Branch (388:9): [True: 1.14k, False: 0]
  ------------------
  389|  1.14k|	while (IS_BLANK_CH(*cur)) cur++;
  390|  1.14k|    if (*cur == 0)
  ------------------
  |  Branch (390:9): [True: 1.14k, False: 0]
  ------------------
  391|  1.14k|	return(0);
  392|       |
  393|      0|try_complex:
  394|       |    /*
  395|       |     * Second check for chars outside the ASCII range
  396|       |     */
  397|      0|    cur = value;
  398|      0|    c = CUR_SCHAR(cur, l);
  ------------------
  |  |  353|      0|#define CUR_SCHAR(s, l) xmlStringCurrentChar(NULL, s, &l)
  ------------------
  399|      0|    if (space) {
  ------------------
  |  Branch (399:9): [True: 0, False: 0]
  ------------------
  400|      0|	while (IS_BLANK(c)) {
  401|      0|	    cur += l;
  402|      0|	    c = CUR_SCHAR(cur, l);
  ------------------
  |  |  353|      0|#define CUR_SCHAR(s, l) xmlStringCurrentChar(NULL, s, &l)
  ------------------
  403|      0|	}
  404|      0|    }
  405|      0|    if ((!IS_LETTER(c)) && (c != '_'))
  ------------------
  |  |  240|      0|#define IS_LETTER(c) (IS_BASECHAR(c) || IS_IDEOGRAPHIC(c))
  |  |  ------------------
  |  |  |  |  161|      0|#define IS_BASECHAR(c) xmlIsBaseCharQ(c)
  |  |  |  |  ------------------
  |  |  |  |  |  |   76|      0|#define xmlIsBaseCharQ(c)	(((c) < 0x100) ? \
  |  |  |  |  |  |  ------------------
  |  |  |  |  |  |  |  Branch (76:27): [True: 0, False: 0]
  |  |  |  |  |  |  |  Branch (76:28): [True: 0, False: 0]
  |  |  |  |  |  |  ------------------
  |  |  |  |  |  |   77|      0|				 xmlIsBaseChar_ch((c)) : \
  |  |  |  |  |  |  ------------------
  |  |  |  |  |  |  |  |   64|      0|#define xmlIsBaseChar_ch(c)	(((0x41 <= (c)) && ((c) <= 0x5a)) || \
  |  |  |  |  |  |  |  |  ------------------
  |  |  |  |  |  |  |  |  |  Branch (64:31): [True: 0, False: 0]
  |  |  |  |  |  |  |  |  |  Branch (64:48): [True: 0, False: 0]
  |  |  |  |  |  |  |  |  ------------------
  |  |  |  |  |  |  |  |   65|      0|				 ((0x61 <= (c)) && ((c) <= 0x7a)) || \
  |  |  |  |  |  |  |  |  ------------------
  |  |  |  |  |  |  |  |  |  Branch (65:7): [True: 0, False: 0]
  |  |  |  |  |  |  |  |  |  Branch (65:24): [True: 0, False: 0]
  |  |  |  |  |  |  |  |  ------------------
  |  |  |  |  |  |  |  |   66|      0|				 ((0xc0 <= (c)) && ((c) <= 0xd6)) || \
  |  |  |  |  |  |  |  |  ------------------
  |  |  |  |  |  |  |  |  |  Branch (66:7): [True: 0, False: 0]
  |  |  |  |  |  |  |  |  |  Branch (66:24): [True: 0, False: 0]
  |  |  |  |  |  |  |  |  ------------------
  |  |  |  |  |  |  |  |   67|      0|				 ((0xd8 <= (c)) && ((c) <= 0xf6)) || \
  |  |  |  |  |  |  |  |  ------------------
  |  |  |  |  |  |  |  |  |  Branch (67:7): [True: 0, False: 0]
  |  |  |  |  |  |  |  |  |  Branch (67:24): [True: 0, False: 0]
  |  |  |  |  |  |  |  |  ------------------
  |  |  |  |  |  |  |  |   68|      0|				  (0xf8 <= (c)))
  |  |  |  |  |  |  |  |  ------------------
  |  |  |  |  |  |  |  |  |  Branch (68:7): [True: 0, False: 0]
  |  |  |  |  |  |  |  |  ------------------
  |  |  |  |  |  |  ------------------
  |  |  |  |  |  |   78|      0|				 xmlCharInRange((c), &xmlIsBaseCharGroup))
  |  |  |  |  ------------------
  |  |  ------------------
  |  |               #define IS_LETTER(c) (IS_BASECHAR(c) || IS_IDEOGRAPHIC(c))
  |  |  ------------------
  |  |  |  |  229|      0|#define IS_IDEOGRAPHIC(c) xmlIsIdeographicQ(c)
  |  |  |  |  ------------------
  |  |  |  |  |  |  184|      0|#define xmlIsIdeographicQ(c)	(((c) < 0x100) ? \
  |  |  |  |  |  |  ------------------
  |  |  |  |  |  |  |  Branch (184:30): [True: 0, False: 0]
  |  |  |  |  |  |  |  Branch (184:31): [True: 0, False: 0]
  |  |  |  |  |  |  ------------------
  |  |  |  |  |  |  185|      0|				 0 :\
  |  |  |  |  |  |  186|      0|				(((0x4e00 <= (c)) && ((c) <= 0x9fa5)) || \
  |  |  |  |  |  |  ------------------
  |  |  |  |  |  |  |  Branch (186:7): [True: 0, False: 0]
  |  |  |  |  |  |  |  Branch (186:26): [True: 0, False: 0]
  |  |  |  |  |  |  ------------------
  |  |  |  |  |  |  187|      0|				 ((c) == 0x3007) || \
  |  |  |  |  |  |  ------------------
  |  |  |  |  |  |  |  Branch (187:6): [True: 0, False: 0]
  |  |  |  |  |  |  ------------------
  |  |  |  |  |  |  188|      0|				 ((0x3021 <= (c)) && ((c) <= 0x3029))))
  |  |  |  |  |  |  ------------------
  |  |  |  |  |  |  |  Branch (188:7): [True: 0, False: 0]
  |  |  |  |  |  |  |  Branch (188:26): [True: 0, False: 0]
  |  |  |  |  |  |  ------------------
  |  |  |  |  ------------------
  |  |  ------------------
  ------------------
  |  Branch (405:28): [True: 0, False: 0]
  ------------------
  406|      0|	return(1);
  407|      0|    cur += l;
  408|      0|    c = CUR_SCHAR(cur, l);
  ------------------
  |  |  353|      0|#define CUR_SCHAR(s, l) xmlStringCurrentChar(NULL, s, &l)
  ------------------
  409|      0|    while (IS_LETTER(c) || IS_DIGIT(c) || (c == '.') ||
  ------------------
  |  |  240|      0|#define IS_LETTER(c) (IS_BASECHAR(c) || IS_IDEOGRAPHIC(c))
  |  |  ------------------
  |  |  |  |  161|      0|#define IS_BASECHAR(c) xmlIsBaseCharQ(c)
  |  |  |  |  ------------------
  |  |  |  |  |  |   76|      0|#define xmlIsBaseCharQ(c)	(((c) < 0x100) ? \
  |  |  |  |  |  |  ------------------
  |  |  |  |  |  |  |  Branch (76:27): [True: 0, False: 0]
  |  |  |  |  |  |  |  Branch (76:28): [True: 0, False: 0]
  |  |  |  |  |  |  ------------------
  |  |  |  |  |  |   77|      0|				 xmlIsBaseChar_ch((c)) : \
  |  |  |  |  |  |  ------------------
  |  |  |  |  |  |  |  |   64|      0|#define xmlIsBaseChar_ch(c)	(((0x41 <= (c)) && ((c) <= 0x5a)) || \
  |  |  |  |  |  |  |  |  ------------------
  |  |  |  |  |  |  |  |  |  Branch (64:31): [True: 0, False: 0]
  |  |  |  |  |  |  |  |  |  Branch (64:48): [True: 0, False: 0]
  |  |  |  |  |  |  |  |  ------------------
  |  |  |  |  |  |  |  |   65|      0|				 ((0x61 <= (c)) && ((c) <= 0x7a)) || \
  |  |  |  |  |  |  |  |  ------------------
  |  |  |  |  |  |  |  |  |  Branch (65:7): [True: 0, False: 0]
  |  |  |  |  |  |  |  |  |  Branch (65:24): [True: 0, False: 0]
  |  |  |  |  |  |  |  |  ------------------
  |  |  |  |  |  |  |  |   66|      0|				 ((0xc0 <= (c)) && ((c) <= 0xd6)) || \
  |  |  |  |  |  |  |  |  ------------------
  |  |  |  |  |  |  |  |  |  Branch (66:7): [True: 0, False: 0]
  |  |  |  |  |  |  |  |  |  Branch (66:24): [True: 0, False: 0]
  |  |  |  |  |  |  |  |  ------------------
  |  |  |  |  |  |  |  |   67|      0|				 ((0xd8 <= (c)) && ((c) <= 0xf6)) || \
  |  |  |  |  |  |  |  |  ------------------
  |  |  |  |  |  |  |  |  |  Branch (67:7): [True: 0, False: 0]
  |  |  |  |  |  |  |  |  |  Branch (67:24): [True: 0, False: 0]
  |  |  |  |  |  |  |  |  ------------------
  |  |  |  |  |  |  |  |   68|      0|				  (0xf8 <= (c)))
  |  |  |  |  |  |  |  |  ------------------
  |  |  |  |  |  |  |  |  |  Branch (68:7): [True: 0, False: 0]
  |  |  |  |  |  |  |  |  ------------------
  |  |  |  |  |  |  ------------------
  |  |  |  |  |  |   78|      0|				 xmlCharInRange((c), &xmlIsBaseCharGroup))
  |  |  |  |  ------------------
  |  |  ------------------
  |  |               #define IS_LETTER(c) (IS_BASECHAR(c) || IS_IDEOGRAPHIC(c))
  |  |  ------------------
  |  |  |  |  229|      0|#define IS_IDEOGRAPHIC(c) xmlIsIdeographicQ(c)
  |  |  |  |  ------------------
  |  |  |  |  |  |  184|      0|#define xmlIsIdeographicQ(c)	(((c) < 0x100) ? \
  |  |  |  |  |  |  ------------------
  |  |  |  |  |  |  |  Branch (184:30): [True: 0, False: 0]
  |  |  |  |  |  |  |  Branch (184:31): [True: 0, False: 0]
  |  |  |  |  |  |  ------------------
  |  |  |  |  |  |  185|      0|				 0 :\
  |  |  |  |  |  |  186|      0|				(((0x4e00 <= (c)) && ((c) <= 0x9fa5)) || \
  |  |  |  |  |  |  ------------------
  |  |  |  |  |  |  |  Branch (186:7): [True: 0, False: 0]
  |  |  |  |  |  |  |  Branch (186:26): [True: 0, False: 0]
  |  |  |  |  |  |  ------------------
  |  |  |  |  |  |  187|      0|				 ((c) == 0x3007) || \
  |  |  |  |  |  |  ------------------
  |  |  |  |  |  |  |  Branch (187:6): [True: 0, False: 0]
  |  |  |  |  |  |  ------------------
  |  |  |  |  |  |  188|      0|				 ((0x3021 <= (c)) && ((c) <= 0x3029))))
  |  |  |  |  |  |  ------------------
  |  |  |  |  |  |  |  Branch (188:7): [True: 0, False: 0]
  |  |  |  |  |  |  |  Branch (188:26): [True: 0, False: 0]
  |  |  |  |  |  |  ------------------
  |  |  |  |  ------------------
  |  |  ------------------
  ------------------
                  while (IS_LETTER(c) || IS_DIGIT(c) || (c == '.') ||
  ------------------
  |  |  171|      0|#define IS_DIGIT(c) xmlIsDigitQ(c)
  |  |  ------------------
  |  |  |  |  152|      0|#define xmlIsDigitQ(c)		(((c) < 0x100) ? \
  |  |  |  |  ------------------
  |  |  |  |  |  Branch (152:25): [True: 0, False: 0]
  |  |  |  |  |  Branch (152:26): [True: 0, False: 0]
  |  |  |  |  ------------------
  |  |  |  |  153|      0|				 xmlIsDigit_ch((c)) : \
  |  |  |  |  ------------------
  |  |  |  |  |  |  144|      0|#define xmlIsDigit_ch(c)	(((0x30 <= (c)) && ((c) <= 0x39)))
  |  |  |  |  |  |  ------------------
  |  |  |  |  |  |  |  Branch (144:28): [True: 0, False: 0]
  |  |  |  |  |  |  |  Branch (144:45): [True: 0, False: 0]
  |  |  |  |  |  |  ------------------
  |  |  |  |  ------------------
  |  |  |  |  154|      0|				 xmlCharInRange((c), &xmlIsDigitGroup))
  |  |  ------------------
  ------------------
  |  Branch (409:43): [True: 0, False: 0]
  ------------------
  410|      0|	   (c == '-') || (c == '_') || IS_COMBINING(c) ||
  ------------------
  |  |  189|      0|#define IS_COMBINING(c) xmlIsCombiningQ(c)
  |  |  ------------------
  |  |  |  |  132|      0|#define xmlIsCombiningQ(c)	(((c) < 0x100) ? \
  |  |  |  |  ------------------
  |  |  |  |  |  Branch (132:28): [True: 0, False: 0]
  |  |  |  |  |  Branch (132:29): [True: 0, False: 0]
  |  |  |  |  ------------------
  |  |  |  |  133|      0|				 0 : \
  |  |  |  |  134|      0|				 xmlCharInRange((c), &xmlIsCombiningGroup))
  |  |  ------------------
  ------------------
  |  Branch (410:5): [True: 0, False: 0]
  |  Branch (410:19): [True: 0, False: 0]
  ------------------
  411|      0|	   IS_EXTENDER(c)) {
  ------------------
  |  |  210|      0|#define IS_EXTENDER(c) xmlIsExtenderQ(c)
  |  |  ------------------
  |  |  |  |  172|      0|#define xmlIsExtenderQ(c)	(((c) < 0x100) ? \
  |  |  |  |  ------------------
  |  |  |  |  |  Branch (172:27): [True: 0, False: 0]
  |  |  |  |  |  Branch (172:28): [True: 0, False: 0]
  |  |  |  |  ------------------
  |  |  |  |  173|      0|				 xmlIsExtender_ch((c)) : \
  |  |  |  |  ------------------
  |  |  |  |  |  |  164|      0|#define xmlIsExtender_ch(c)	(((c) == 0xb7))
  |  |  |  |  ------------------
  |  |  |  |  174|      0|				 xmlCharInRange((c), &xmlIsExtenderGroup))
  |  |  ------------------
  ------------------
  412|      0|	cur += l;
  413|      0|	c = CUR_SCHAR(cur, l);
  ------------------
  |  |  353|      0|#define CUR_SCHAR(s, l) xmlStringCurrentChar(NULL, s, &l)
  ------------------
  414|      0|    }
  415|      0|    if (space) {
  ------------------
  |  Branch (415:9): [True: 0, False: 0]
  ------------------
  416|      0|	while (IS_BLANK(c)) {
  417|      0|	    cur += l;
  418|      0|	    c = CUR_SCHAR(cur, l);
  ------------------
  |  |  353|      0|#define CUR_SCHAR(s, l) xmlStringCurrentChar(NULL, s, &l)
  ------------------
  419|      0|	}
  420|      0|    }
  421|      0|    if (c != 0)
  ------------------
  |  Branch (421:9): [True: 0, False: 0]
  ------------------
  422|      0|	return(1);
  423|       |
  424|      0|    return(0);
  425|      0|}
xmlValidateQName:
  439|  1.07k|xmlValidateQName(const xmlChar *value, int space) {
  440|  1.07k|    const xmlChar *cur = value;
  441|  1.07k|    int c,l;
  442|       |
  443|  1.07k|    if (value == NULL)
  ------------------
  |  Branch (443:9): [True: 0, False: 1.07k]
  ------------------
  444|      0|        return(-1);
  445|       |    /*
  446|       |     * First quick algorithm for ASCII range
  447|       |     */
  448|  1.07k|    if (space)
  ------------------
  |  Branch (448:9): [True: 1.07k, False: 0]
  ------------------
  449|  1.07k|	while (IS_BLANK_CH(*cur)) cur++;
  450|  1.07k|    if (((*cur >= 'a') && (*cur <= 'z')) || ((*cur >= 'A') && (*cur <= 'Z')) ||
  ------------------
  |  Branch (450:10): [True: 1.03k, False: 37]
  |  Branch (450:27): [True: 1.03k, False: 0]
  |  Branch (450:46): [True: 37, False: 0]
  |  Branch (450:63): [True: 37, False: 0]
  ------------------
  451|  1.07k|	(*cur == '_'))
  ------------------
  |  Branch (451:2): [True: 0, False: 0]
  ------------------
  452|  1.07k|	cur++;
  453|      0|    else
  454|      0|	goto try_complex;
  455|  5.30k|    while (((*cur >= 'a') && (*cur <= 'z')) ||
  ------------------
  |  Branch (455:13): [True: 3.93k, False: 1.37k]
  |  Branch (455:30): [True: 3.93k, False: 0]
  ------------------
  456|  5.30k|	   ((*cur >= 'A') && (*cur <= 'Z')) ||
  ------------------
  |  Branch (456:6): [True: 145, False: 1.22k]
  |  Branch (456:23): [True: 133, False: 12]
  ------------------
  457|  5.30k|	   ((*cur >= '0') && (*cur <= '9')) ||
  ------------------
  |  Branch (457:6): [True: 714, False: 526]
  |  Branch (457:23): [True: 56, False: 658]
  ------------------
  458|  5.30k|	   (*cur == '_') || (*cur == '-') || (*cur == '.'))
  ------------------
  |  Branch (458:5): [True: 12, False: 1.17k]
  |  Branch (458:22): [True: 73, False: 1.09k]
  |  Branch (458:39): [True: 27, False: 1.07k]
  ------------------
  459|  4.23k|	cur++;
  460|  1.07k|    if (*cur == ':') {
  ------------------
  |  Branch (460:9): [True: 646, False: 426]
  ------------------
  461|    646|	cur++;
  462|    646|	if (((*cur >= 'a') && (*cur <= 'z')) ||
  ------------------
  |  Branch (462:7): [True: 582, False: 64]
  |  Branch (462:24): [True: 582, False: 0]
  ------------------
  463|    646|	    ((*cur >= 'A') && (*cur <= 'Z')) ||
  ------------------
  |  Branch (463:7): [True: 64, False: 0]
  |  Branch (463:24): [True: 64, False: 0]
  ------------------
  464|    646|	    (*cur == '_'))
  ------------------
  |  Branch (464:6): [True: 0, False: 0]
  ------------------
  465|    646|	    cur++;
  466|      0|	else
  467|      0|	    goto try_complex;
  468|  4.75k|	while (((*cur >= 'a') && (*cur <= 'z')) ||
  ------------------
  |  Branch (468:10): [True: 3.34k, False: 1.41k]
  |  Branch (468:27): [True: 3.34k, False: 0]
  ------------------
  469|  4.75k|	       ((*cur >= 'A') && (*cur <= 'Z')) ||
  ------------------
  |  Branch (469:10): [True: 451, False: 962]
  |  Branch (469:27): [True: 355, False: 96]
  ------------------
  470|  4.75k|	       ((*cur >= '0') && (*cur <= '9')) ||
  ------------------
  |  Branch (470:10): [True: 245, False: 813]
  |  Branch (470:27): [True: 149, False: 96]
  ------------------
  471|  4.75k|	       (*cur == '_') || (*cur == '-') || (*cur == '.'))
  ------------------
  |  Branch (471:9): [True: 96, False: 813]
  |  Branch (471:26): [True: 15, False: 798]
  |  Branch (471:43): [True: 152, False: 646]
  ------------------
  472|  4.10k|	    cur++;
  473|    646|    }
  474|  1.07k|    if (space)
  ------------------
  |  Branch (474:9): [True: 1.07k, False: 0]
  ------------------
  475|  1.07k|	while (IS_BLANK_CH(*cur)) cur++;
  476|  1.07k|    if (*cur == 0)
  ------------------
  |  Branch (476:9): [True: 1.07k, False: 0]
  ------------------
  477|  1.07k|	return(0);
  478|       |
  479|      0|try_complex:
  480|       |    /*
  481|       |     * Second check for chars outside the ASCII range
  482|       |     */
  483|      0|    cur = value;
  484|      0|    c = CUR_SCHAR(cur, l);
  ------------------
  |  |  353|      0|#define CUR_SCHAR(s, l) xmlStringCurrentChar(NULL, s, &l)
  ------------------
  485|      0|    if (space) {
  ------------------
  |  Branch (485:9): [True: 0, False: 0]
  ------------------
  486|      0|	while (IS_BLANK(c)) {
  487|      0|	    cur += l;
  488|      0|	    c = CUR_SCHAR(cur, l);
  ------------------
  |  |  353|      0|#define CUR_SCHAR(s, l) xmlStringCurrentChar(NULL, s, &l)
  ------------------
  489|      0|	}
  490|      0|    }
  491|      0|    if ((!IS_LETTER(c)) && (c != '_'))
  ------------------
  |  |  240|      0|#define IS_LETTER(c) (IS_BASECHAR(c) || IS_IDEOGRAPHIC(c))
  |  |  ------------------
  |  |  |  |  161|      0|#define IS_BASECHAR(c) xmlIsBaseCharQ(c)
  |  |  |  |  ------------------
  |  |  |  |  |  |   76|      0|#define xmlIsBaseCharQ(c)	(((c) < 0x100) ? \
  |  |  |  |  |  |  ------------------
  |  |  |  |  |  |  |  Branch (76:27): [True: 0, False: 0]
  |  |  |  |  |  |  |  Branch (76:28): [True: 0, False: 0]
  |  |  |  |  |  |  ------------------
  |  |  |  |  |  |   77|      0|				 xmlIsBaseChar_ch((c)) : \
  |  |  |  |  |  |  ------------------
  |  |  |  |  |  |  |  |   64|      0|#define xmlIsBaseChar_ch(c)	(((0x41 <= (c)) && ((c) <= 0x5a)) || \
  |  |  |  |  |  |  |  |  ------------------
  |  |  |  |  |  |  |  |  |  Branch (64:31): [True: 0, False: 0]
  |  |  |  |  |  |  |  |  |  Branch (64:48): [True: 0, False: 0]
  |  |  |  |  |  |  |  |  ------------------
  |  |  |  |  |  |  |  |   65|      0|				 ((0x61 <= (c)) && ((c) <= 0x7a)) || \
  |  |  |  |  |  |  |  |  ------------------
  |  |  |  |  |  |  |  |  |  Branch (65:7): [True: 0, False: 0]
  |  |  |  |  |  |  |  |  |  Branch (65:24): [True: 0, False: 0]
  |  |  |  |  |  |  |  |  ------------------
  |  |  |  |  |  |  |  |   66|      0|				 ((0xc0 <= (c)) && ((c) <= 0xd6)) || \
  |  |  |  |  |  |  |  |  ------------------
  |  |  |  |  |  |  |  |  |  Branch (66:7): [True: 0, False: 0]
  |  |  |  |  |  |  |  |  |  Branch (66:24): [True: 0, False: 0]
  |  |  |  |  |  |  |  |  ------------------
  |  |  |  |  |  |  |  |   67|      0|				 ((0xd8 <= (c)) && ((c) <= 0xf6)) || \
  |  |  |  |  |  |  |  |  ------------------
  |  |  |  |  |  |  |  |  |  Branch (67:7): [True: 0, False: 0]
  |  |  |  |  |  |  |  |  |  Branch (67:24): [True: 0, False: 0]
  |  |  |  |  |  |  |  |  ------------------
  |  |  |  |  |  |  |  |   68|      0|				  (0xf8 <= (c)))
  |  |  |  |  |  |  |  |  ------------------
  |  |  |  |  |  |  |  |  |  Branch (68:7): [True: 0, False: 0]
  |  |  |  |  |  |  |  |  ------------------
  |  |  |  |  |  |  ------------------
  |  |  |  |  |  |   78|      0|				 xmlCharInRange((c), &xmlIsBaseCharGroup))
  |  |  |  |  ------------------
  |  |  ------------------
  |  |               #define IS_LETTER(c) (IS_BASECHAR(c) || IS_IDEOGRAPHIC(c))
  |  |  ------------------
  |  |  |  |  229|      0|#define IS_IDEOGRAPHIC(c) xmlIsIdeographicQ(c)
  |  |  |  |  ------------------
  |  |  |  |  |  |  184|      0|#define xmlIsIdeographicQ(c)	(((c) < 0x100) ? \
  |  |  |  |  |  |  ------------------
  |  |  |  |  |  |  |  Branch (184:30): [True: 0, False: 0]
  |  |  |  |  |  |  |  Branch (184:31): [True: 0, False: 0]
  |  |  |  |  |  |  ------------------
  |  |  |  |  |  |  185|      0|				 0 :\
  |  |  |  |  |  |  186|      0|				(((0x4e00 <= (c)) && ((c) <= 0x9fa5)) || \
  |  |  |  |  |  |  ------------------
  |  |  |  |  |  |  |  Branch (186:7): [True: 0, False: 0]
  |  |  |  |  |  |  |  Branch (186:26): [True: 0, False: 0]
  |  |  |  |  |  |  ------------------
  |  |  |  |  |  |  187|      0|				 ((c) == 0x3007) || \
  |  |  |  |  |  |  ------------------
  |  |  |  |  |  |  |  Branch (187:6): [True: 0, False: 0]
  |  |  |  |  |  |  ------------------
  |  |  |  |  |  |  188|      0|				 ((0x3021 <= (c)) && ((c) <= 0x3029))))
  |  |  |  |  |  |  ------------------
  |  |  |  |  |  |  |  Branch (188:7): [True: 0, False: 0]
  |  |  |  |  |  |  |  Branch (188:26): [True: 0, False: 0]
  |  |  |  |  |  |  ------------------
  |  |  |  |  ------------------
  |  |  ------------------
  ------------------
  |  Branch (491:28): [True: 0, False: 0]
  ------------------
  492|      0|	return(1);
  493|      0|    cur += l;
  494|      0|    c = CUR_SCHAR(cur, l);
  ------------------
  |  |  353|      0|#define CUR_SCHAR(s, l) xmlStringCurrentChar(NULL, s, &l)
  ------------------
  495|      0|    while (IS_LETTER(c) || IS_DIGIT(c) || (c == '.') ||
  ------------------
  |  |  240|      0|#define IS_LETTER(c) (IS_BASECHAR(c) || IS_IDEOGRAPHIC(c))
  |  |  ------------------
  |  |  |  |  161|      0|#define IS_BASECHAR(c) xmlIsBaseCharQ(c)
  |  |  |  |  ------------------
  |  |  |  |  |  |   76|      0|#define xmlIsBaseCharQ(c)	(((c) < 0x100) ? \
  |  |  |  |  |  |  ------------------
  |  |  |  |  |  |  |  Branch (76:27): [True: 0, False: 0]
  |  |  |  |  |  |  |  Branch (76:28): [True: 0, False: 0]
  |  |  |  |  |  |  ------------------
  |  |  |  |  |  |   77|      0|				 xmlIsBaseChar_ch((c)) : \
  |  |  |  |  |  |  ------------------
  |  |  |  |  |  |  |  |   64|      0|#define xmlIsBaseChar_ch(c)	(((0x41 <= (c)) && ((c) <= 0x5a)) || \
  |  |  |  |  |  |  |  |  ------------------
  |  |  |  |  |  |  |  |  |  Branch (64:31): [True: 0, False: 0]
  |  |  |  |  |  |  |  |  |  Branch (64:48): [True: 0, False: 0]
  |  |  |  |  |  |  |  |  ------------------
  |  |  |  |  |  |  |  |   65|      0|				 ((0x61 <= (c)) && ((c) <= 0x7a)) || \
  |  |  |  |  |  |  |  |  ------------------
  |  |  |  |  |  |  |  |  |  Branch (65:7): [True: 0, False: 0]
  |  |  |  |  |  |  |  |  |  Branch (65:24): [True: 0, False: 0]
  |  |  |  |  |  |  |  |  ------------------
  |  |  |  |  |  |  |  |   66|      0|				 ((0xc0 <= (c)) && ((c) <= 0xd6)) || \
  |  |  |  |  |  |  |  |  ------------------
  |  |  |  |  |  |  |  |  |  Branch (66:7): [True: 0, False: 0]
  |  |  |  |  |  |  |  |  |  Branch (66:24): [True: 0, False: 0]
  |  |  |  |  |  |  |  |  ------------------
  |  |  |  |  |  |  |  |   67|      0|				 ((0xd8 <= (c)) && ((c) <= 0xf6)) || \
  |  |  |  |  |  |  |  |  ------------------
  |  |  |  |  |  |  |  |  |  Branch (67:7): [True: 0, False: 0]
  |  |  |  |  |  |  |  |  |  Branch (67:24): [True: 0, False: 0]
  |  |  |  |  |  |  |  |  ------------------
  |  |  |  |  |  |  |  |   68|      0|				  (0xf8 <= (c)))
  |  |  |  |  |  |  |  |  ------------------
  |  |  |  |  |  |  |  |  |  Branch (68:7): [True: 0, False: 0]
  |  |  |  |  |  |  |  |  ------------------
  |  |  |  |  |  |  ------------------
  |  |  |  |  |  |   78|      0|				 xmlCharInRange((c), &xmlIsBaseCharGroup))
  |  |  |  |  ------------------
  |  |  ------------------
  |  |               #define IS_LETTER(c) (IS_BASECHAR(c) || IS_IDEOGRAPHIC(c))
  |  |  ------------------
  |  |  |  |  229|      0|#define IS_IDEOGRAPHIC(c) xmlIsIdeographicQ(c)
  |  |  |  |  ------------------
  |  |  |  |  |  |  184|      0|#define xmlIsIdeographicQ(c)	(((c) < 0x100) ? \
  |  |  |  |  |  |  ------------------
  |  |  |  |  |  |  |  Branch (184:30): [True: 0, False: 0]
  |  |  |  |  |  |  |  Branch (184:31): [True: 0, False: 0]
  |  |  |  |  |  |  ------------------
  |  |  |  |  |  |  185|      0|				 0 :\
  |  |  |  |  |  |  186|      0|				(((0x4e00 <= (c)) && ((c) <= 0x9fa5)) || \
  |  |  |  |  |  |  ------------------
  |  |  |  |  |  |  |  Branch (186:7): [True: 0, False: 0]
  |  |  |  |  |  |  |  Branch (186:26): [True: 0, False: 0]
  |  |  |  |  |  |  ------------------
  |  |  |  |  |  |  187|      0|				 ((c) == 0x3007) || \
  |  |  |  |  |  |  ------------------
  |  |  |  |  |  |  |  Branch (187:6): [True: 0, False: 0]
  |  |  |  |  |  |  ------------------
  |  |  |  |  |  |  188|      0|				 ((0x3021 <= (c)) && ((c) <= 0x3029))))
  |  |  |  |  |  |  ------------------
  |  |  |  |  |  |  |  Branch (188:7): [True: 0, False: 0]
  |  |  |  |  |  |  |  Branch (188:26): [True: 0, False: 0]
  |  |  |  |  |  |  ------------------
  |  |  |  |  ------------------
  |  |  ------------------
  ------------------
                  while (IS_LETTER(c) || IS_DIGIT(c) || (c == '.') ||
  ------------------
  |  |  171|      0|#define IS_DIGIT(c) xmlIsDigitQ(c)
  |  |  ------------------
  |  |  |  |  152|      0|#define xmlIsDigitQ(c)		(((c) < 0x100) ? \
  |  |  |  |  ------------------
  |  |  |  |  |  Branch (152:25): [True: 0, False: 0]
  |  |  |  |  |  Branch (152:26): [True: 0, False: 0]
  |  |  |  |  ------------------
  |  |  |  |  153|      0|				 xmlIsDigit_ch((c)) : \
  |  |  |  |  ------------------
  |  |  |  |  |  |  144|      0|#define xmlIsDigit_ch(c)	(((0x30 <= (c)) && ((c) <= 0x39)))
  |  |  |  |  |  |  ------------------
  |  |  |  |  |  |  |  Branch (144:28): [True: 0, False: 0]
  |  |  |  |  |  |  |  Branch (144:45): [True: 0, False: 0]
  |  |  |  |  |  |  ------------------
  |  |  |  |  ------------------
  |  |  |  |  154|      0|				 xmlCharInRange((c), &xmlIsDigitGroup))
  |  |  ------------------
  ------------------
  |  Branch (495:43): [True: 0, False: 0]
  ------------------
  496|      0|	   (c == '-') || (c == '_') || IS_COMBINING(c) ||
  ------------------
  |  |  189|      0|#define IS_COMBINING(c) xmlIsCombiningQ(c)
  |  |  ------------------
  |  |  |  |  132|      0|#define xmlIsCombiningQ(c)	(((c) < 0x100) ? \
  |  |  |  |  ------------------
  |  |  |  |  |  Branch (132:28): [True: 0, False: 0]
  |  |  |  |  |  Branch (132:29): [True: 0, False: 0]
  |  |  |  |  ------------------
  |  |  |  |  133|      0|				 0 : \
  |  |  |  |  134|      0|				 xmlCharInRange((c), &xmlIsCombiningGroup))
  |  |  ------------------
  ------------------
  |  Branch (496:5): [True: 0, False: 0]
  |  Branch (496:19): [True: 0, False: 0]
  ------------------
  497|      0|	   IS_EXTENDER(c)) {
  ------------------
  |  |  210|      0|#define IS_EXTENDER(c) xmlIsExtenderQ(c)
  |  |  ------------------
  |  |  |  |  172|      0|#define xmlIsExtenderQ(c)	(((c) < 0x100) ? \
  |  |  |  |  ------------------
  |  |  |  |  |  Branch (172:27): [True: 0, False: 0]
  |  |  |  |  |  Branch (172:28): [True: 0, False: 0]
  |  |  |  |  ------------------
  |  |  |  |  173|      0|				 xmlIsExtender_ch((c)) : \
  |  |  |  |  ------------------
  |  |  |  |  |  |  164|      0|#define xmlIsExtender_ch(c)	(((c) == 0xb7))
  |  |  |  |  ------------------
  |  |  |  |  174|      0|				 xmlCharInRange((c), &xmlIsExtenderGroup))
  |  |  ------------------
  ------------------
  498|      0|	cur += l;
  499|      0|	c = CUR_SCHAR(cur, l);
  ------------------
  |  |  353|      0|#define CUR_SCHAR(s, l) xmlStringCurrentChar(NULL, s, &l)
  ------------------
  500|      0|    }
  501|      0|    if (c == ':') {
  ------------------
  |  Branch (501:9): [True: 0, False: 0]
  ------------------
  502|      0|	cur += l;
  503|      0|	c = CUR_SCHAR(cur, l);
  ------------------
  |  |  353|      0|#define CUR_SCHAR(s, l) xmlStringCurrentChar(NULL, s, &l)
  ------------------
  504|      0|	if ((!IS_LETTER(c)) && (c != '_'))
  ------------------
  |  |  240|      0|#define IS_LETTER(c) (IS_BASECHAR(c) || IS_IDEOGRAPHIC(c))
  |  |  ------------------
  |  |  |  |  161|      0|#define IS_BASECHAR(c) xmlIsBaseCharQ(c)
  |  |  |  |  ------------------
  |  |  |  |  |  |   76|      0|#define xmlIsBaseCharQ(c)	(((c) < 0x100) ? \
  |  |  |  |  |  |  ------------------
  |  |  |  |  |  |  |  Branch (76:27): [True: 0, False: 0]
  |  |  |  |  |  |  |  Branch (76:28): [True: 0, False: 0]
  |  |  |  |  |  |  ------------------
  |  |  |  |  |  |   77|      0|				 xmlIsBaseChar_ch((c)) : \
  |  |  |  |  |  |  ------------------
  |  |  |  |  |  |  |  |   64|      0|#define xmlIsBaseChar_ch(c)	(((0x41 <= (c)) && ((c) <= 0x5a)) || \
  |  |  |  |  |  |  |  |  ------------------
  |  |  |  |  |  |  |  |  |  Branch (64:31): [True: 0, False: 0]
  |  |  |  |  |  |  |  |  |  Branch (64:48): [True: 0, False: 0]
  |  |  |  |  |  |  |  |  ------------------
  |  |  |  |  |  |  |  |   65|      0|				 ((0x61 <= (c)) && ((c) <= 0x7a)) || \
  |  |  |  |  |  |  |  |  ------------------
  |  |  |  |  |  |  |  |  |  Branch (65:7): [True: 0, False: 0]
  |  |  |  |  |  |  |  |  |  Branch (65:24): [True: 0, False: 0]
  |  |  |  |  |  |  |  |  ------------------
  |  |  |  |  |  |  |  |   66|      0|				 ((0xc0 <= (c)) && ((c) <= 0xd6)) || \
  |  |  |  |  |  |  |  |  ------------------
  |  |  |  |  |  |  |  |  |  Branch (66:7): [True: 0, False: 0]
  |  |  |  |  |  |  |  |  |  Branch (66:24): [True: 0, False: 0]
  |  |  |  |  |  |  |  |  ------------------
  |  |  |  |  |  |  |  |   67|      0|				 ((0xd8 <= (c)) && ((c) <= 0xf6)) || \
  |  |  |  |  |  |  |  |  ------------------
  |  |  |  |  |  |  |  |  |  Branch (67:7): [True: 0, False: 0]
  |  |  |  |  |  |  |  |  |  Branch (67:24): [True: 0, False: 0]
  |  |  |  |  |  |  |  |  ------------------
  |  |  |  |  |  |  |  |   68|      0|				  (0xf8 <= (c)))
  |  |  |  |  |  |  |  |  ------------------
  |  |  |  |  |  |  |  |  |  Branch (68:7): [True: 0, False: 0]
  |  |  |  |  |  |  |  |  ------------------
  |  |  |  |  |  |  ------------------
  |  |  |  |  |  |   78|      0|				 xmlCharInRange((c), &xmlIsBaseCharGroup))
  |  |  |  |  ------------------
  |  |  ------------------
  |  |               #define IS_LETTER(c) (IS_BASECHAR(c) || IS_IDEOGRAPHIC(c))
  |  |  ------------------
  |  |  |  |  229|      0|#define IS_IDEOGRAPHIC(c) xmlIsIdeographicQ(c)
  |  |  |  |  ------------------
  |  |  |  |  |  |  184|      0|#define xmlIsIdeographicQ(c)	(((c) < 0x100) ? \
  |  |  |  |  |  |  ------------------
  |  |  |  |  |  |  |  Branch (184:30): [True: 0, False: 0]
  |  |  |  |  |  |  |  Branch (184:31): [True: 0, False: 0]
  |  |  |  |  |  |  ------------------
  |  |  |  |  |  |  185|      0|				 0 :\
  |  |  |  |  |  |  186|      0|				(((0x4e00 <= (c)) && ((c) <= 0x9fa5)) || \
  |  |  |  |  |  |  ------------------
  |  |  |  |  |  |  |  Branch (186:7): [True: 0, False: 0]
  |  |  |  |  |  |  |  Branch (186:26): [True: 0, False: 0]
  |  |  |  |  |  |  ------------------
  |  |  |  |  |  |  187|      0|				 ((c) == 0x3007) || \
  |  |  |  |  |  |  ------------------
  |  |  |  |  |  |  |  Branch (187:6): [True: 0, False: 0]
  |  |  |  |  |  |  ------------------
  |  |  |  |  |  |  188|      0|				 ((0x3021 <= (c)) && ((c) <= 0x3029))))
  |  |  |  |  |  |  ------------------
  |  |  |  |  |  |  |  Branch (188:7): [True: 0, False: 0]
  |  |  |  |  |  |  |  Branch (188:26): [True: 0, False: 0]
  |  |  |  |  |  |  ------------------
  |  |  |  |  ------------------
  |  |  ------------------
  ------------------
  |  Branch (504:25): [True: 0, False: 0]
  ------------------
  505|      0|	    return(1);
  506|      0|	cur += l;
  507|      0|	c = CUR_SCHAR(cur, l);
  ------------------
  |  |  353|      0|#define CUR_SCHAR(s, l) xmlStringCurrentChar(NULL, s, &l)
  ------------------
  508|      0|	while (IS_LETTER(c) || IS_DIGIT(c) || (c == '.') ||
  ------------------
  |  |  240|      0|#define IS_LETTER(c) (IS_BASECHAR(c) || IS_IDEOGRAPHIC(c))
  |  |  ------------------
  |  |  |  |  161|      0|#define IS_BASECHAR(c) xmlIsBaseCharQ(c)
  |  |  |  |  ------------------
  |  |  |  |  |  |   76|      0|#define xmlIsBaseCharQ(c)	(((c) < 0x100) ? \
  |  |  |  |  |  |  ------------------
  |  |  |  |  |  |  |  Branch (76:27): [True: 0, False: 0]
  |  |  |  |  |  |  |  Branch (76:28): [True: 0, False: 0]
  |  |  |  |  |  |  ------------------
  |  |  |  |  |  |   77|      0|				 xmlIsBaseChar_ch((c)) : \
  |  |  |  |  |  |  ------------------
  |  |  |  |  |  |  |  |   64|      0|#define xmlIsBaseChar_ch(c)	(((0x41 <= (c)) && ((c) <= 0x5a)) || \
  |  |  |  |  |  |  |  |  ------------------
  |  |  |  |  |  |  |  |  |  Branch (64:31): [True: 0, False: 0]
  |  |  |  |  |  |  |  |  |  Branch (64:48): [True: 0, False: 0]
  |  |  |  |  |  |  |  |  ------------------
  |  |  |  |  |  |  |  |   65|      0|				 ((0x61 <= (c)) && ((c) <= 0x7a)) || \
  |  |  |  |  |  |  |  |  ------------------
  |  |  |  |  |  |  |  |  |  Branch (65:7): [True: 0, False: 0]
  |  |  |  |  |  |  |  |  |  Branch (65:24): [True: 0, False: 0]
  |  |  |  |  |  |  |  |  ------------------
  |  |  |  |  |  |  |  |   66|      0|				 ((0xc0 <= (c)) && ((c) <= 0xd6)) || \
  |  |  |  |  |  |  |  |  ------------------
  |  |  |  |  |  |  |  |  |  Branch (66:7): [True: 0, False: 0]
  |  |  |  |  |  |  |  |  |  Branch (66:24): [True: 0, False: 0]
  |  |  |  |  |  |  |  |  ------------------
  |  |  |  |  |  |  |  |   67|      0|				 ((0xd8 <= (c)) && ((c) <= 0xf6)) || \
  |  |  |  |  |  |  |  |  ------------------
  |  |  |  |  |  |  |  |  |  Branch (67:7): [True: 0, False: 0]
  |  |  |  |  |  |  |  |  |  Branch (67:24): [True: 0, False: 0]
  |  |  |  |  |  |  |  |  ------------------
  |  |  |  |  |  |  |  |   68|      0|				  (0xf8 <= (c)))
  |  |  |  |  |  |  |  |  ------------------
  |  |  |  |  |  |  |  |  |  Branch (68:7): [True: 0, False: 0]
  |  |  |  |  |  |  |  |  ------------------
  |  |  |  |  |  |  ------------------
  |  |  |  |  |  |   78|      0|				 xmlCharInRange((c), &xmlIsBaseCharGroup))
  |  |  |  |  ------------------
  |  |  ------------------
  |  |               #define IS_LETTER(c) (IS_BASECHAR(c) || IS_IDEOGRAPHIC(c))
  |  |  ------------------
  |  |  |  |  229|      0|#define IS_IDEOGRAPHIC(c) xmlIsIdeographicQ(c)
  |  |  |  |  ------------------
  |  |  |  |  |  |  184|      0|#define xmlIsIdeographicQ(c)	(((c) < 0x100) ? \
  |  |  |  |  |  |  ------------------
  |  |  |  |  |  |  |  Branch (184:30): [True: 0, False: 0]
  |  |  |  |  |  |  |  Branch (184:31): [True: 0, False: 0]
  |  |  |  |  |  |  ------------------
  |  |  |  |  |  |  185|      0|				 0 :\
  |  |  |  |  |  |  186|      0|				(((0x4e00 <= (c)) && ((c) <= 0x9fa5)) || \
  |  |  |  |  |  |  ------------------
  |  |  |  |  |  |  |  Branch (186:7): [True: 0, False: 0]
  |  |  |  |  |  |  |  Branch (186:26): [True: 0, False: 0]
  |  |  |  |  |  |  ------------------
  |  |  |  |  |  |  187|      0|				 ((c) == 0x3007) || \
  |  |  |  |  |  |  ------------------
  |  |  |  |  |  |  |  Branch (187:6): [True: 0, False: 0]
  |  |  |  |  |  |  ------------------
  |  |  |  |  |  |  188|      0|				 ((0x3021 <= (c)) && ((c) <= 0x3029))))
  |  |  |  |  |  |  ------------------
  |  |  |  |  |  |  |  Branch (188:7): [True: 0, False: 0]
  |  |  |  |  |  |  |  Branch (188:26): [True: 0, False: 0]
  |  |  |  |  |  |  ------------------
  |  |  |  |  ------------------
  |  |  ------------------
  ------------------
              	while (IS_LETTER(c) || IS_DIGIT(c) || (c == '.') ||
  ------------------
  |  |  171|      0|#define IS_DIGIT(c) xmlIsDigitQ(c)
  |  |  ------------------
  |  |  |  |  152|      0|#define xmlIsDigitQ(c)		(((c) < 0x100) ? \
  |  |  |  |  ------------------
  |  |  |  |  |  Branch (152:25): [True: 0, False: 0]
  |  |  |  |  |  Branch (152:26): [True: 0, False: 0]
  |  |  |  |  ------------------
  |  |  |  |  153|      0|				 xmlIsDigit_ch((c)) : \
  |  |  |  |  ------------------
  |  |  |  |  |  |  144|      0|#define xmlIsDigit_ch(c)	(((0x30 <= (c)) && ((c) <= 0x39)))
  |  |  |  |  |  |  ------------------
  |  |  |  |  |  |  |  Branch (144:28): [True: 0, False: 0]
  |  |  |  |  |  |  |  Branch (144:45): [True: 0, False: 0]
  |  |  |  |  |  |  ------------------
  |  |  |  |  ------------------
  |  |  |  |  154|      0|				 xmlCharInRange((c), &xmlIsDigitGroup))
  |  |  ------------------
  ------------------
  |  Branch (508:40): [True: 0, False: 0]
  ------------------
  509|      0|	       (c == '-') || (c == '_') || IS_COMBINING(c) ||
  ------------------
  |  |  189|      0|#define IS_COMBINING(c) xmlIsCombiningQ(c)
  |  |  ------------------
  |  |  |  |  132|      0|#define xmlIsCombiningQ(c)	(((c) < 0x100) ? \
  |  |  |  |  ------------------
  |  |  |  |  |  Branch (132:28): [True: 0, False: 0]
  |  |  |  |  |  Branch (132:29): [True: 0, False: 0]
  |  |  |  |  ------------------
  |  |  |  |  133|      0|				 0 : \
  |  |  |  |  134|      0|				 xmlCharInRange((c), &xmlIsCombiningGroup))
  |  |  ------------------
  ------------------
  |  Branch (509:9): [True: 0, False: 0]
  |  Branch (509:23): [True: 0, False: 0]
  ------------------
  510|      0|	       IS_EXTENDER(c)) {
  ------------------
  |  |  210|      0|#define IS_EXTENDER(c) xmlIsExtenderQ(c)
  |  |  ------------------
  |  |  |  |  172|      0|#define xmlIsExtenderQ(c)	(((c) < 0x100) ? \
  |  |  |  |  ------------------
  |  |  |  |  |  Branch (172:27): [True: 0, False: 0]
  |  |  |  |  |  Branch (172:28): [True: 0, False: 0]
  |  |  |  |  ------------------
  |  |  |  |  173|      0|				 xmlIsExtender_ch((c)) : \
  |  |  |  |  ------------------
  |  |  |  |  |  |  164|      0|#define xmlIsExtender_ch(c)	(((c) == 0xb7))
  |  |  |  |  ------------------
  |  |  |  |  174|      0|				 xmlCharInRange((c), &xmlIsExtenderGroup))
  |  |  ------------------
  ------------------
  511|      0|	    cur += l;
  512|      0|	    c = CUR_SCHAR(cur, l);
  ------------------
  |  |  353|      0|#define CUR_SCHAR(s, l) xmlStringCurrentChar(NULL, s, &l)
  ------------------
  513|      0|	}
  514|      0|    }
  515|      0|    if (space) {
  ------------------
  |  Branch (515:9): [True: 0, False: 0]
  ------------------
  516|      0|	while (IS_BLANK(c)) {
  517|      0|	    cur += l;
  518|      0|	    c = CUR_SCHAR(cur, l);
  ------------------
  |  |  353|      0|#define CUR_SCHAR(s, l) xmlStringCurrentChar(NULL, s, &l)
  ------------------
  519|      0|	}
  520|      0|    }
  521|      0|    if (c != 0)
  ------------------
  |  Branch (521:9): [True: 0, False: 0]
  ------------------
  522|      0|	return(1);
  523|      0|    return(0);
  524|      0|}
xmlValidateNMToken:
  606|     20|xmlValidateNMToken(const xmlChar *value, int space) {
  607|     20|    const xmlChar *cur = value;
  608|     20|    int c,l;
  609|       |
  610|     20|    if (value == NULL)
  ------------------
  |  Branch (610:9): [True: 0, False: 20]
  ------------------
  611|      0|        return(-1);
  612|       |    /*
  613|       |     * First quick algorithm for ASCII range
  614|       |     */
  615|     20|    if (space)
  ------------------
  |  Branch (615:9): [True: 20, False: 0]
  ------------------
  616|     20|	while (IS_BLANK_CH(*cur)) cur++;
  617|     20|    if (((*cur >= 'a') && (*cur <= 'z')) ||
  ------------------
  |  Branch (617:10): [True: 8, False: 12]
  |  Branch (617:27): [True: 8, False: 0]
  ------------------
  618|     20|        ((*cur >= 'A') && (*cur <= 'Z')) ||
  ------------------
  |  Branch (618:10): [True: 11, False: 1]
  |  Branch (618:27): [True: 11, False: 0]
  ------------------
  619|     20|        ((*cur >= '0') && (*cur <= '9')) ||
  ------------------
  |  Branch (619:10): [True: 1, False: 0]
  |  Branch (619:27): [True: 1, False: 0]
  ------------------
  620|     20|        (*cur == '_') || (*cur == '-') || (*cur == '.') || (*cur == ':'))
  ------------------
  |  Branch (620:9): [True: 0, False: 0]
  |  Branch (620:26): [True: 0, False: 0]
  |  Branch (620:43): [True: 0, False: 0]
  |  Branch (620:60): [True: 0, False: 0]
  ------------------
  621|     20|	cur++;
  622|      0|    else
  623|      0|	goto try_complex;
  624|     78|    while (((*cur >= 'a') && (*cur <= 'z')) ||
  ------------------
  |  Branch (624:13): [True: 36, False: 42]
  |  Branch (624:30): [True: 36, False: 0]
  ------------------
  625|     78|	   ((*cur >= 'A') && (*cur <= 'Z')) ||
  ------------------
  |  Branch (625:6): [True: 22, False: 20]
  |  Branch (625:23): [True: 22, False: 0]
  ------------------
  626|     78|	   ((*cur >= '0') && (*cur <= '9')) ||
  ------------------
  |  Branch (626:6): [True: 0, False: 20]
  |  Branch (626:23): [True: 0, False: 0]
  ------------------
  627|     78|	   (*cur == '_') || (*cur == '-') || (*cur == '.') || (*cur == ':'))
  ------------------
  |  Branch (627:5): [True: 0, False: 20]
  |  Branch (627:22): [True: 0, False: 20]
  |  Branch (627:39): [True: 0, False: 20]
  |  Branch (627:56): [True: 0, False: 20]
  ------------------
  628|     58|	cur++;
  629|     20|    if (space)
  ------------------
  |  Branch (629:9): [True: 20, False: 0]
  ------------------
  630|     20|	while (IS_BLANK_CH(*cur)) cur++;
  631|     20|    if (*cur == 0)
  ------------------
  |  Branch (631:9): [True: 20, False: 0]
  ------------------
  632|     20|	return(0);
  633|       |
  634|      0|try_complex:
  635|       |    /*
  636|       |     * Second check for chars outside the ASCII range
  637|       |     */
  638|      0|    cur = value;
  639|      0|    c = CUR_SCHAR(cur, l);
  ------------------
  |  |  353|      0|#define CUR_SCHAR(s, l) xmlStringCurrentChar(NULL, s, &l)
  ------------------
  640|      0|    if (space) {
  ------------------
  |  Branch (640:9): [True: 0, False: 0]
  ------------------
  641|      0|	while (IS_BLANK(c)) {
  642|      0|	    cur += l;
  643|      0|	    c = CUR_SCHAR(cur, l);
  ------------------
  |  |  353|      0|#define CUR_SCHAR(s, l) xmlStringCurrentChar(NULL, s, &l)
  ------------------
  644|      0|	}
  645|      0|    }
  646|      0|    if (!(IS_LETTER(c) || IS_DIGIT(c) || (c == '.') || (c == ':') ||
  ------------------
  |  |  240|      0|#define IS_LETTER(c) (IS_BASECHAR(c) || IS_IDEOGRAPHIC(c))
  |  |  ------------------
  |  |  |  |  161|      0|#define IS_BASECHAR(c) xmlIsBaseCharQ(c)
  |  |  |  |  ------------------
  |  |  |  |  |  |   76|      0|#define xmlIsBaseCharQ(c)	(((c) < 0x100) ? \
  |  |  |  |  |  |  ------------------
  |  |  |  |  |  |  |  Branch (76:27): [True: 0, False: 0]
  |  |  |  |  |  |  |  Branch (76:28): [True: 0, False: 0]
  |  |  |  |  |  |  ------------------
  |  |  |  |  |  |   77|      0|				 xmlIsBaseChar_ch((c)) : \
  |  |  |  |  |  |  ------------------
  |  |  |  |  |  |  |  |   64|      0|#define xmlIsBaseChar_ch(c)	(((0x41 <= (c)) && ((c) <= 0x5a)) || \
  |  |  |  |  |  |  |  |  ------------------
  |  |  |  |  |  |  |  |  |  Branch (64:31): [True: 0, False: 0]
  |  |  |  |  |  |  |  |  |  Branch (64:48): [True: 0, False: 0]
  |  |  |  |  |  |  |  |  ------------------
  |  |  |  |  |  |  |  |   65|      0|				 ((0x61 <= (c)) && ((c) <= 0x7a)) || \
  |  |  |  |  |  |  |  |  ------------------
  |  |  |  |  |  |  |  |  |  Branch (65:7): [True: 0, False: 0]
  |  |  |  |  |  |  |  |  |  Branch (65:24): [True: 0, False: 0]
  |  |  |  |  |  |  |  |  ------------------
  |  |  |  |  |  |  |  |   66|      0|				 ((0xc0 <= (c)) && ((c) <= 0xd6)) || \
  |  |  |  |  |  |  |  |  ------------------
  |  |  |  |  |  |  |  |  |  Branch (66:7): [True: 0, False: 0]
  |  |  |  |  |  |  |  |  |  Branch (66:24): [True: 0, False: 0]
  |  |  |  |  |  |  |  |  ------------------
  |  |  |  |  |  |  |  |   67|      0|				 ((0xd8 <= (c)) && ((c) <= 0xf6)) || \
  |  |  |  |  |  |  |  |  ------------------
  |  |  |  |  |  |  |  |  |  Branch (67:7): [True: 0, False: 0]
  |  |  |  |  |  |  |  |  |  Branch (67:24): [True: 0, False: 0]
  |  |  |  |  |  |  |  |  ------------------
  |  |  |  |  |  |  |  |   68|      0|				  (0xf8 <= (c)))
  |  |  |  |  |  |  |  |  ------------------
  |  |  |  |  |  |  |  |  |  Branch (68:7): [True: 0, False: 0]
  |  |  |  |  |  |  |  |  ------------------
  |  |  |  |  |  |  ------------------
  |  |  |  |  |  |   78|      0|				 xmlCharInRange((c), &xmlIsBaseCharGroup))
  |  |  |  |  ------------------
  |  |  ------------------
  |  |               #define IS_LETTER(c) (IS_BASECHAR(c) || IS_IDEOGRAPHIC(c))
  |  |  ------------------
  |  |  |  |  229|      0|#define IS_IDEOGRAPHIC(c) xmlIsIdeographicQ(c)
  |  |  |  |  ------------------
  |  |  |  |  |  |  184|      0|#define xmlIsIdeographicQ(c)	(((c) < 0x100) ? \
  |  |  |  |  |  |  ------------------
  |  |  |  |  |  |  |  Branch (184:30): [True: 0, False: 0]
  |  |  |  |  |  |  |  Branch (184:31): [True: 0, False: 0]
  |  |  |  |  |  |  ------------------
  |  |  |  |  |  |  185|      0|				 0 :\
  |  |  |  |  |  |  186|      0|				(((0x4e00 <= (c)) && ((c) <= 0x9fa5)) || \
  |  |  |  |  |  |  ------------------
  |  |  |  |  |  |  |  Branch (186:7): [True: 0, False: 0]
  |  |  |  |  |  |  |  Branch (186:26): [True: 0, False: 0]
  |  |  |  |  |  |  ------------------
  |  |  |  |  |  |  187|      0|				 ((c) == 0x3007) || \
  |  |  |  |  |  |  ------------------
  |  |  |  |  |  |  |  Branch (187:6): [True: 0, False: 0]
  |  |  |  |  |  |  ------------------
  |  |  |  |  |  |  188|      0|				 ((0x3021 <= (c)) && ((c) <= 0x3029))))
  |  |  |  |  |  |  ------------------
  |  |  |  |  |  |  |  Branch (188:7): [True: 0, False: 0]
  |  |  |  |  |  |  |  Branch (188:26): [True: 0, False: 0]
  |  |  |  |  |  |  ------------------
  |  |  |  |  ------------------
  |  |  ------------------
  ------------------
                  if (!(IS_LETTER(c) || IS_DIGIT(c) || (c == '.') || (c == ':') ||
  ------------------
  |  |  171|      0|#define IS_DIGIT(c) xmlIsDigitQ(c)
  |  |  ------------------
  |  |  |  |  152|      0|#define xmlIsDigitQ(c)		(((c) < 0x100) ? \
  |  |  |  |  ------------------
  |  |  |  |  |  Branch (152:25): [True: 0, False: 0]
  |  |  |  |  |  Branch (152:26): [True: 0, False: 0]
  |  |  |  |  ------------------
  |  |  |  |  153|      0|				 xmlIsDigit_ch((c)) : \
  |  |  |  |  ------------------
  |  |  |  |  |  |  144|      0|#define xmlIsDigit_ch(c)	(((0x30 <= (c)) && ((c) <= 0x39)))
  |  |  |  |  |  |  ------------------
  |  |  |  |  |  |  |  Branch (144:28): [True: 0, False: 0]
  |  |  |  |  |  |  |  Branch (144:45): [True: 0, False: 0]
  |  |  |  |  |  |  ------------------
  |  |  |  |  ------------------
  |  |  |  |  154|      0|				 xmlCharInRange((c), &xmlIsDigitGroup))
  |  |  ------------------
  ------------------
  |  Branch (646:42): [True: 0, False: 0]
  |  Branch (646:56): [True: 0, False: 0]
  ------------------
  647|      0|        (c == '-') || (c == '_') || IS_COMBINING(c) || IS_EXTENDER(c)))
  ------------------
  |  |  189|      0|#define IS_COMBINING(c) xmlIsCombiningQ(c)
  |  |  ------------------
  |  |  |  |  132|      0|#define xmlIsCombiningQ(c)	(((c) < 0x100) ? \
  |  |  |  |  ------------------
  |  |  |  |  |  Branch (132:28): [True: 0, False: 0]
  |  |  |  |  |  Branch (132:29): [True: 0, False: 0]
  |  |  |  |  ------------------
  |  |  |  |  133|      0|				 0 : \
  |  |  |  |  134|      0|				 xmlCharInRange((c), &xmlIsCombiningGroup))
  |  |  ------------------
  ------------------
                      (c == '-') || (c == '_') || IS_COMBINING(c) || IS_EXTENDER(c)))
  ------------------
  |  |  210|      0|#define IS_EXTENDER(c) xmlIsExtenderQ(c)
  |  |  ------------------
  |  |  |  |  172|      0|#define xmlIsExtenderQ(c)	(((c) < 0x100) ? \
  |  |  |  |  ------------------
  |  |  |  |  |  Branch (172:27): [True: 0, False: 0]
  |  |  |  |  |  Branch (172:28): [True: 0, False: 0]
  |  |  |  |  ------------------
  |  |  |  |  173|      0|				 xmlIsExtender_ch((c)) : \
  |  |  |  |  ------------------
  |  |  |  |  |  |  164|      0|#define xmlIsExtender_ch(c)	(((c) == 0xb7))
  |  |  |  |  ------------------
  |  |  |  |  174|      0|				 xmlCharInRange((c), &xmlIsExtenderGroup))
  |  |  ------------------
  ------------------
  |  Branch (647:9): [True: 0, False: 0]
  |  Branch (647:23): [True: 0, False: 0]
  ------------------
  648|      0|	return(1);
  649|      0|    cur += l;
  650|      0|    c = CUR_SCHAR(cur, l);
  ------------------
  |  |  353|      0|#define CUR_SCHAR(s, l) xmlStringCurrentChar(NULL, s, &l)
  ------------------
  651|      0|    while (IS_LETTER(c) || IS_DIGIT(c) || (c == '.') || (c == ':') ||
  ------------------
  |  |  240|      0|#define IS_LETTER(c) (IS_BASECHAR(c) || IS_IDEOGRAPHIC(c))
  |  |  ------------------
  |  |  |  |  161|      0|#define IS_BASECHAR(c) xmlIsBaseCharQ(c)
  |  |  |  |  ------------------
  |  |  |  |  |  |   76|      0|#define xmlIsBaseCharQ(c)	(((c) < 0x100) ? \
  |  |  |  |  |  |  ------------------
  |  |  |  |  |  |  |  Branch (76:27): [True: 0, False: 0]
  |  |  |  |  |  |  |  Branch (76:28): [True: 0, False: 0]
  |  |  |  |  |  |  ------------------
  |  |  |  |  |  |   77|      0|				 xmlIsBaseChar_ch((c)) : \
  |  |  |  |  |  |  ------------------
  |  |  |  |  |  |  |  |   64|      0|#define xmlIsBaseChar_ch(c)	(((0x41 <= (c)) && ((c) <= 0x5a)) || \
  |  |  |  |  |  |  |  |  ------------------
  |  |  |  |  |  |  |  |  |  Branch (64:31): [True: 0, False: 0]
  |  |  |  |  |  |  |  |  |  Branch (64:48): [True: 0, False: 0]
  |  |  |  |  |  |  |  |  ------------------
  |  |  |  |  |  |  |  |   65|      0|				 ((0x61 <= (c)) && ((c) <= 0x7a)) || \
  |  |  |  |  |  |  |  |  ------------------
  |  |  |  |  |  |  |  |  |  Branch (65:7): [True: 0, False: 0]
  |  |  |  |  |  |  |  |  |  Branch (65:24): [True: 0, False: 0]
  |  |  |  |  |  |  |  |  ------------------
  |  |  |  |  |  |  |  |   66|      0|				 ((0xc0 <= (c)) && ((c) <= 0xd6)) || \
  |  |  |  |  |  |  |  |  ------------------
  |  |  |  |  |  |  |  |  |  Branch (66:7): [True: 0, False: 0]
  |  |  |  |  |  |  |  |  |  Branch (66:24): [True: 0, False: 0]
  |  |  |  |  |  |  |  |  ------------------
  |  |  |  |  |  |  |  |   67|      0|				 ((0xd8 <= (c)) && ((c) <= 0xf6)) || \
  |  |  |  |  |  |  |  |  ------------------
  |  |  |  |  |  |  |  |  |  Branch (67:7): [True: 0, False: 0]
  |  |  |  |  |  |  |  |  |  Branch (67:24): [True: 0, False: 0]
  |  |  |  |  |  |  |  |  ------------------
  |  |  |  |  |  |  |  |   68|      0|				  (0xf8 <= (c)))
  |  |  |  |  |  |  |  |  ------------------
  |  |  |  |  |  |  |  |  |  Branch (68:7): [True: 0, False: 0]
  |  |  |  |  |  |  |  |  ------------------
  |  |  |  |  |  |  ------------------
  |  |  |  |  |  |   78|      0|				 xmlCharInRange((c), &xmlIsBaseCharGroup))
  |  |  |  |  ------------------
  |  |  ------------------
  |  |               #define IS_LETTER(c) (IS_BASECHAR(c) || IS_IDEOGRAPHIC(c))
  |  |  ------------------
  |  |  |  |  229|      0|#define IS_IDEOGRAPHIC(c) xmlIsIdeographicQ(c)
  |  |  |  |  ------------------
  |  |  |  |  |  |  184|      0|#define xmlIsIdeographicQ(c)	(((c) < 0x100) ? \
  |  |  |  |  |  |  ------------------
  |  |  |  |  |  |  |  Branch (184:30): [True: 0, False: 0]
  |  |  |  |  |  |  |  Branch (184:31): [True: 0, False: 0]
  |  |  |  |  |  |  ------------------
  |  |  |  |  |  |  185|      0|				 0 :\
  |  |  |  |  |  |  186|      0|				(((0x4e00 <= (c)) && ((c) <= 0x9fa5)) || \
  |  |  |  |  |  |  ------------------
  |  |  |  |  |  |  |  Branch (186:7): [True: 0, False: 0]
  |  |  |  |  |  |  |  Branch (186:26): [True: 0, False: 0]
  |  |  |  |  |  |  ------------------
  |  |  |  |  |  |  187|      0|				 ((c) == 0x3007) || \
  |  |  |  |  |  |  ------------------
  |  |  |  |  |  |  |  Branch (187:6): [True: 0, False: 0]
  |  |  |  |  |  |  ------------------
  |  |  |  |  |  |  188|      0|				 ((0x3021 <= (c)) && ((c) <= 0x3029))))
  |  |  |  |  |  |  ------------------
  |  |  |  |  |  |  |  Branch (188:7): [True: 0, False: 0]
  |  |  |  |  |  |  |  Branch (188:26): [True: 0, False: 0]
  |  |  |  |  |  |  ------------------
  |  |  |  |  ------------------
  |  |  ------------------
  ------------------
                  while (IS_LETTER(c) || IS_DIGIT(c) || (c == '.') || (c == ':') ||
  ------------------
  |  |  171|      0|#define IS_DIGIT(c) xmlIsDigitQ(c)
  |  |  ------------------
  |  |  |  |  152|      0|#define xmlIsDigitQ(c)		(((c) < 0x100) ? \
  |  |  |  |  ------------------
  |  |  |  |  |  Branch (152:25): [True: 0, False: 0]
  |  |  |  |  |  Branch (152:26): [True: 0, False: 0]
  |  |  |  |  ------------------
  |  |  |  |  153|      0|				 xmlIsDigit_ch((c)) : \
  |  |  |  |  ------------------
  |  |  |  |  |  |  144|      0|#define xmlIsDigit_ch(c)	(((0x30 <= (c)) && ((c) <= 0x39)))
  |  |  |  |  |  |  ------------------
  |  |  |  |  |  |  |  Branch (144:28): [True: 0, False: 0]
  |  |  |  |  |  |  |  Branch (144:45): [True: 0, False: 0]
  |  |  |  |  |  |  ------------------
  |  |  |  |  ------------------
  |  |  |  |  154|      0|				 xmlCharInRange((c), &xmlIsDigitGroup))
  |  |  ------------------
  ------------------
  |  Branch (651:43): [True: 0, False: 0]
  |  Branch (651:57): [True: 0, False: 0]
  ------------------
  652|      0|	   (c == '-') || (c == '_') || IS_COMBINING(c) || IS_EXTENDER(c)) {
  ------------------
  |  |  189|      0|#define IS_COMBINING(c) xmlIsCombiningQ(c)
  |  |  ------------------
  |  |  |  |  132|      0|#define xmlIsCombiningQ(c)	(((c) < 0x100) ? \
  |  |  |  |  ------------------
  |  |  |  |  |  Branch (132:28): [True: 0, False: 0]
  |  |  |  |  |  Branch (132:29): [True: 0, False: 0]
  |  |  |  |  ------------------
  |  |  |  |  133|      0|				 0 : \
  |  |  |  |  134|      0|				 xmlCharInRange((c), &xmlIsCombiningGroup))
  |  |  ------------------
  ------------------
              	   (c == '-') || (c == '_') || IS_COMBINING(c) || IS_EXTENDER(c)) {
  ------------------
  |  |  210|      0|#define IS_EXTENDER(c) xmlIsExtenderQ(c)
  |  |  ------------------
  |  |  |  |  172|      0|#define xmlIsExtenderQ(c)	(((c) < 0x100) ? \
  |  |  |  |  ------------------
  |  |  |  |  |  Branch (172:27): [True: 0, False: 0]
  |  |  |  |  |  Branch (172:28): [True: 0, False: 0]
  |  |  |  |  ------------------
  |  |  |  |  173|      0|				 xmlIsExtender_ch((c)) : \
  |  |  |  |  ------------------
  |  |  |  |  |  |  164|      0|#define xmlIsExtender_ch(c)	(((c) == 0xb7))
  |  |  |  |  ------------------
  |  |  |  |  174|      0|				 xmlCharInRange((c), &xmlIsExtenderGroup))
  |  |  ------------------
  ------------------
  |  Branch (652:5): [True: 0, False: 0]
  |  Branch (652:19): [True: 0, False: 0]
  ------------------
  653|      0|	cur += l;
  654|      0|	c = CUR_SCHAR(cur, l);
  ------------------
  |  |  353|      0|#define CUR_SCHAR(s, l) xmlStringCurrentChar(NULL, s, &l)
  ------------------
  655|      0|    }
  656|      0|    if (space) {
  ------------------
  |  Branch (656:9): [True: 0, False: 0]
  ------------------
  657|      0|	while (IS_BLANK(c)) {
  658|      0|	    cur += l;
  659|      0|	    c = CUR_SCHAR(cur, l);
  ------------------
  |  |  353|      0|#define CUR_SCHAR(s, l) xmlStringCurrentChar(NULL, s, &l)
  ------------------
  660|      0|	}
  661|      0|    }
  662|      0|    if (c != 0)
  ------------------
  |  Branch (662:9): [True: 0, False: 0]
  ------------------
  663|      0|	return(1);
  664|      0|    return(0);
  665|      0|}
xmlNewNs:
  726|    377|xmlNewNs(xmlNodePtr node, const xmlChar *href, const xmlChar *prefix) {
  727|    377|    xmlNsPtr cur;
  728|       |
  729|    377|    if ((node != NULL) && (node->type != XML_ELEMENT_NODE))
  ------------------
  |  Branch (729:9): [True: 0, False: 377]
  |  Branch (729:27): [True: 0, False: 0]
  ------------------
  730|      0|	return(NULL);
  731|       |
  732|    377|    if ((prefix != NULL) && (xmlStrEqual(prefix, BAD_CAST "xml"))) {
  ------------------
  |  |   35|    309|#define BAD_CAST (xmlChar *)
  ------------------
  |  Branch (732:9): [True: 309, False: 68]
  |  Branch (732:29): [True: 0, False: 309]
  ------------------
  733|       |        /* xml namespace is predefined, no need to add it */
  734|      0|        if (xmlStrEqual(href, XML_XML_NAMESPACE))
  ------------------
  |  |  143|      0|    (const xmlChar *) "http://www.w3.org/XML/1998/namespace"
  ------------------
  |  Branch (734:13): [True: 0, False: 0]
  ------------------
  735|      0|            return(NULL);
  736|       |
  737|       |        /*
  738|       |         * Problem, this is an attempt to bind xml prefix to a wrong
  739|       |         * namespace, which breaks
  740|       |         * Namespace constraint: Reserved Prefixes and Namespace Names
  741|       |         * from XML namespace. But documents authors may not care in
  742|       |         * their context so let's proceed.
  743|       |         */
  744|      0|    }
  745|       |
  746|       |    /*
  747|       |     * Allocate a new Namespace and fill the fields.
  748|       |     */
  749|    377|    cur = (xmlNsPtr) xmlMalloc(sizeof(xmlNs));
  750|    377|    if (cur == NULL) {
  ------------------
  |  Branch (750:9): [True: 0, False: 377]
  ------------------
  751|      0|	xmlTreeErrMemory("building namespace");
  752|      0|	return(NULL);
  753|      0|    }
  754|    377|    memset(cur, 0, sizeof(xmlNs));
  755|    377|    cur->type = XML_LOCAL_NAMESPACE;
  ------------------
  |  |  370|    377|#define XML_LOCAL_NAMESPACE XML_NAMESPACE_DECL
  ------------------
  756|       |
  757|    377|    if (href != NULL)
  ------------------
  |  Branch (757:9): [True: 377, False: 0]
  ------------------
  758|    377|	cur->href = xmlStrdup(href);
  759|    377|    if (prefix != NULL)
  ------------------
  |  Branch (759:9): [True: 309, False: 68]
  ------------------
  760|    309|	cur->prefix = xmlStrdup(prefix);
  761|       |
  762|       |    /*
  763|       |     * Add it at the end to preserve parsing order ...
  764|       |     * and checks for existing use of the prefix
  765|       |     */
  766|    377|    if (node != NULL) {
  ------------------
  |  Branch (766:9): [True: 0, False: 377]
  ------------------
  767|      0|	if (node->nsDef == NULL) {
  ------------------
  |  Branch (767:6): [True: 0, False: 0]
  ------------------
  768|      0|	    node->nsDef = cur;
  769|      0|	} else {
  770|      0|	    xmlNsPtr prev = node->nsDef;
  771|       |
  772|      0|	    if (((prev->prefix == NULL) && (cur->prefix == NULL)) ||
  ------------------
  |  Branch (772:11): [True: 0, False: 0]
  |  Branch (772:37): [True: 0, False: 0]
  ------------------
  773|      0|		(xmlStrEqual(prev->prefix, cur->prefix))) {
  ------------------
  |  Branch (773:3): [True: 0, False: 0]
  ------------------
  774|      0|		xmlFreeNs(cur);
  775|      0|		return(NULL);
  776|      0|	    }
  777|      0|	    while (prev->next != NULL) {
  ------------------
  |  Branch (777:13): [True: 0, False: 0]
  ------------------
  778|      0|	        prev = prev->next;
  779|      0|		if (((prev->prefix == NULL) && (cur->prefix == NULL)) ||
  ------------------
  |  Branch (779:8): [True: 0, False: 0]
  |  Branch (779:34): [True: 0, False: 0]
  ------------------
  780|      0|		    (xmlStrEqual(prev->prefix, cur->prefix))) {
  ------------------
  |  Branch (780:7): [True: 0, False: 0]
  ------------------
  781|      0|		    xmlFreeNs(cur);
  782|      0|		    return(NULL);
  783|      0|		}
  784|      0|	    }
  785|      0|	    prev->next = cur;
  786|      0|	}
  787|      0|    }
  788|    377|    return(cur);
  789|    377|}
xmlFreeNs:
  815|    396|xmlFreeNs(xmlNsPtr cur) {
  816|    396|    if (cur == NULL) {
  ------------------
  |  Branch (816:9): [True: 0, False: 396]
  ------------------
  817|      0|	return;
  818|      0|    }
  819|    396|    if (cur->href != NULL) xmlFree((char *) cur->href);
  ------------------
  |  Branch (819:9): [True: 396, False: 0]
  ------------------
  820|    396|    if (cur->prefix != NULL) xmlFree((char *) cur->prefix);
  ------------------
  |  Branch (820:9): [True: 328, False: 68]
  ------------------
  821|    396|    xmlFree(cur);
  822|    396|}
xmlFreeNsList:
  831|    252|xmlFreeNsList(xmlNsPtr cur) {
  832|    252|    xmlNsPtr next;
  833|    252|    if (cur == NULL) {
  ------------------
  |  Branch (833:9): [True: 0, False: 252]
  ------------------
  834|      0|	return;
  835|      0|    }
  836|    648|    while (cur != NULL) {
  ------------------
  |  Branch (836:12): [True: 396, False: 252]
  ------------------
  837|    396|        next = cur->next;
  838|    396|        xmlFreeNs(cur);
  839|    396|	cur = next;
  840|    396|    }
  841|    252|}
xmlNewDoc:
 1130|    236|xmlNewDoc(const xmlChar *version) {
 1131|    236|    xmlDocPtr cur;
 1132|       |
 1133|    236|    if (version == NULL)
  ------------------
  |  Branch (1133:9): [True: 0, False: 236]
  ------------------
 1134|      0|	version = (const xmlChar *) "1.0";
 1135|       |
 1136|       |    /*
 1137|       |     * Allocate a new document and fill the fields.
 1138|       |     */
 1139|    236|    cur = (xmlDocPtr) xmlMalloc(sizeof(xmlDoc));
 1140|    236|    if (cur == NULL) {
  ------------------
  |  Branch (1140:9): [True: 0, False: 236]
  ------------------
 1141|      0|	xmlTreeErrMemory("building doc");
 1142|      0|	return(NULL);
 1143|      0|    }
 1144|    236|    memset(cur, 0, sizeof(xmlDoc));
 1145|    236|    cur->type = XML_DOCUMENT_NODE;
 1146|       |
 1147|    236|    cur->version = xmlStrdup(version);
 1148|    236|    if (cur->version == NULL) {
  ------------------
  |  Branch (1148:9): [True: 0, False: 236]
  ------------------
 1149|      0|	xmlTreeErrMemory("building doc");
 1150|      0|	xmlFree(cur);
 1151|      0|	return(NULL);
 1152|      0|    }
 1153|    236|    cur->standalone = -1;
 1154|    236|    cur->compression = -1; /* not initialized */
 1155|    236|    cur->doc = cur;
 1156|    236|    cur->parseFlags = 0;
 1157|    236|    cur->properties = XML_DOC_USERBUILT;
 1158|       |    /*
 1159|       |     * The in memory encoding is always UTF8
 1160|       |     * This field will never change and would
 1161|       |     * be obsolete if not for binary compatibility.
 1162|       |     */
 1163|    236|    cur->charset = XML_CHAR_ENCODING_UTF8;
 1164|       |
 1165|    236|    if ((__xmlRegisterCallbacks) && (xmlRegisterNodeDefaultValue))
  ------------------
  |  |  682|      0|    XML_GLOBAL_MACRO(xmlRegisterNodeDefaultValue)
  |  |  ------------------
  |  |  |  |  500|      0|  #define XML_GLOBAL_MACRO(name) (*__##name())
  |  |  ------------------
  ------------------
  |  Branch (1165:9): [True: 0, False: 236]
  |  Branch (1165:37): [True: 0, False: 0]
  ------------------
 1166|      0|	xmlRegisterNodeDefaultValue((xmlNodePtr)cur);
  ------------------
  |  |  682|      0|    XML_GLOBAL_MACRO(xmlRegisterNodeDefaultValue)
  |  |  ------------------
  |  |  |  |  500|      0|  #define XML_GLOBAL_MACRO(name) (*__##name())
  |  |  ------------------
  ------------------
 1167|    236|    return(cur);
 1168|    236|}
xmlFreeDoc:
 1177|    236|xmlFreeDoc(xmlDocPtr cur) {
 1178|    236|    xmlDtdPtr extSubset, intSubset;
 1179|    236|    xmlDictPtr dict = NULL;
 1180|       |
 1181|    236|    if (cur == NULL) {
  ------------------
  |  Branch (1181:9): [True: 0, False: 236]
  ------------------
 1182|      0|	return;
 1183|      0|    }
 1184|       |
 1185|    236|    if (cur != NULL) dict = cur->dict;
  ------------------
  |  Branch (1185:9): [True: 236, False: 0]
  ------------------
 1186|       |
 1187|    236|    if ((__xmlRegisterCallbacks) && (xmlDeregisterNodeDefaultValue))
  ------------------
  |  |  684|      0|    XML_GLOBAL_MACRO(xmlDeregisterNodeDefaultValue)
  |  |  ------------------
  |  |  |  |  500|      0|  #define XML_GLOBAL_MACRO(name) (*__##name())
  |  |  ------------------
  ------------------
  |  Branch (1187:9): [True: 0, False: 236]
  |  Branch (1187:37): [True: 0, False: 0]
  ------------------
 1188|      0|	xmlDeregisterNodeDefaultValue((xmlNodePtr)cur);
  ------------------
  |  |  684|      0|    XML_GLOBAL_MACRO(xmlDeregisterNodeDefaultValue)
  |  |  ------------------
  |  |  |  |  500|      0|  #define XML_GLOBAL_MACRO(name) (*__##name())
  |  |  ------------------
  ------------------
 1189|       |
 1190|       |    /*
 1191|       |     * Do this before freeing the children list to avoid ID lookups
 1192|       |     */
 1193|    236|    if (cur->ids != NULL) xmlFreeIDTable((xmlIDTablePtr) cur->ids);
  ------------------
  |  Branch (1193:9): [True: 5, False: 231]
  ------------------
 1194|    236|    cur->ids = NULL;
 1195|    236|    if (cur->refs != NULL) xmlFreeRefTable((xmlRefTablePtr) cur->refs);
  ------------------
  |  Branch (1195:9): [True: 0, False: 236]
  ------------------
 1196|    236|    cur->refs = NULL;
 1197|    236|    extSubset = cur->extSubset;
 1198|    236|    intSubset = cur->intSubset;
 1199|    236|    if (intSubset == extSubset)
  ------------------
  |  Branch (1199:9): [True: 236, False: 0]
  ------------------
 1200|    236|	extSubset = NULL;
 1201|    236|    if (extSubset != NULL) {
  ------------------
  |  Branch (1201:9): [True: 0, False: 236]
  ------------------
 1202|      0|	xmlUnlinkNode((xmlNodePtr) cur->extSubset);
 1203|      0|	cur->extSubset = NULL;
 1204|      0|	xmlFreeDtd(extSubset);
 1205|      0|    }
 1206|    236|    if (intSubset != NULL) {
  ------------------
  |  Branch (1206:9): [True: 0, False: 236]
  ------------------
 1207|      0|	xmlUnlinkNode((xmlNodePtr) cur->intSubset);
 1208|      0|	cur->intSubset = NULL;
 1209|      0|	xmlFreeDtd(intSubset);
 1210|      0|    }
 1211|       |
 1212|    236|    if (cur->children != NULL) xmlFreeNodeList(cur->children);
  ------------------
  |  Branch (1212:9): [True: 231, False: 5]
  ------------------
 1213|    236|    if (cur->oldNs != NULL) xmlFreeNsList(cur->oldNs);
  ------------------
  |  Branch (1213:9): [True: 19, False: 217]
  ------------------
 1214|       |
 1215|    236|    DICT_FREE(cur->version)
  ------------------
  |  | 1025|    236|	if ((str) && ((!dict) ||				\
  |  |  ------------------
  |  |  |  Branch (1025:6): [True: 236, False: 0]
  |  |  |  Branch (1025:16): [True: 0, False: 236]
  |  |  ------------------
  |  | 1026|    236|	    (xmlDictOwns(dict, (const xmlChar *)(str)) == 0)))	\
  |  |  ------------------
  |  |  |  Branch (1026:6): [True: 236, False: 0]
  |  |  ------------------
  |  | 1027|    236|	    xmlFree((char *)(str));
  ------------------
 1216|    236|    DICT_FREE(cur->name)
  ------------------
  |  | 1025|    236|	if ((str) && ((!dict) ||				\
  |  |  ------------------
  |  |  |  Branch (1025:6): [True: 0, False: 236]
  |  |  |  Branch (1025:16): [True: 0, False: 0]
  |  |  ------------------
  |  | 1026|      0|	    (xmlDictOwns(dict, (const xmlChar *)(str)) == 0)))	\
  |  |  ------------------
  |  |  |  Branch (1026:6): [True: 0, False: 0]
  |  |  ------------------
  |  | 1027|    236|	    xmlFree((char *)(str));
  ------------------
 1217|    236|    DICT_FREE(cur->encoding)
  ------------------
  |  | 1025|    236|	if ((str) && ((!dict) ||				\
  |  |  ------------------
  |  |  |  Branch (1025:6): [True: 123, False: 113]
  |  |  |  Branch (1025:16): [True: 0, False: 123]
  |  |  ------------------
  |  | 1026|    123|	    (xmlDictOwns(dict, (const xmlChar *)(str)) == 0)))	\
  |  |  ------------------
  |  |  |  Branch (1026:6): [True: 123, False: 0]
  |  |  ------------------
  |  | 1027|    236|	    xmlFree((char *)(str));
  ------------------
 1218|    236|    DICT_FREE(cur->URL)
  ------------------
  |  | 1025|    236|	if ((str) && ((!dict) ||				\
  |  |  ------------------
  |  |  |  Branch (1025:6): [True: 236, False: 0]
  |  |  |  Branch (1025:16): [True: 0, False: 236]
  |  |  ------------------
  |  | 1026|    236|	    (xmlDictOwns(dict, (const xmlChar *)(str)) == 0)))	\
  |  |  ------------------
  |  |  |  Branch (1026:6): [True: 236, False: 0]
  |  |  ------------------
  |  | 1027|    236|	    xmlFree((char *)(str));
  ------------------
 1219|    236|    xmlFree(cur);
 1220|    236|    if (dict) xmlDictFree(dict);
  ------------------
  |  Branch (1220:9): [True: 236, False: 0]
  ------------------
 1221|    236|}
xmlFreePropList:
 2047|  2.60k|xmlFreePropList(xmlAttrPtr cur) {
 2048|  2.60k|    xmlAttrPtr next;
 2049|  2.60k|    if (cur == NULL) return;
  ------------------
  |  Branch (2049:9): [True: 0, False: 2.60k]
  ------------------
 2050|  6.57k|    while (cur != NULL) {
  ------------------
  |  Branch (2050:12): [True: 3.96k, False: 2.60k]
  ------------------
 2051|  3.96k|        next = cur->next;
 2052|  3.96k|        xmlFreeProp(cur);
 2053|  3.96k|	cur = next;
 2054|  3.96k|    }
 2055|  2.60k|}
xmlFreeProp:
 2064|  3.96k|xmlFreeProp(xmlAttrPtr cur) {
 2065|  3.96k|    xmlDictPtr dict = NULL;
 2066|  3.96k|    if (cur == NULL) return;
  ------------------
  |  Branch (2066:9): [True: 0, False: 3.96k]
  ------------------
 2067|       |
 2068|  3.96k|    if (cur->doc != NULL) dict = cur->doc->dict;
  ------------------
  |  Branch (2068:9): [True: 3.96k, False: 0]
  ------------------
 2069|       |
 2070|  3.96k|    if ((__xmlRegisterCallbacks) && (xmlDeregisterNodeDefaultValue))
  ------------------
  |  |  684|      0|    XML_GLOBAL_MACRO(xmlDeregisterNodeDefaultValue)
  |  |  ------------------
  |  |  |  |  500|      0|  #define XML_GLOBAL_MACRO(name) (*__##name())
  |  |  ------------------
  ------------------
  |  Branch (2070:9): [True: 0, False: 3.96k]
  |  Branch (2070:37): [True: 0, False: 0]
  ------------------
 2071|      0|	xmlDeregisterNodeDefaultValue((xmlNodePtr)cur);
  ------------------
  |  |  684|      0|    XML_GLOBAL_MACRO(xmlDeregisterNodeDefaultValue)
  |  |  ------------------
  |  |  |  |  500|      0|  #define XML_GLOBAL_MACRO(name) (*__##name())
  |  |  ------------------
  ------------------
 2072|       |
 2073|       |    /* Check for ID removal -> leading to invalid references ! */
 2074|  3.96k|    if ((cur->doc != NULL) && (cur->atype == XML_ATTRIBUTE_ID)) {
  ------------------
  |  Branch (2074:9): [True: 3.96k, False: 0]
  |  Branch (2074:31): [True: 17, False: 3.94k]
  ------------------
 2075|     17|	    xmlRemoveID(cur->doc, cur);
 2076|     17|    }
 2077|  3.96k|    if (cur->children != NULL) xmlFreeNodeList(cur->children);
  ------------------
  |  Branch (2077:9): [True: 3.96k, False: 0]
  ------------------
 2078|  3.96k|    DICT_FREE(cur->name)
  ------------------
  |  | 1025|  3.96k|	if ((str) && ((!dict) ||				\
  |  |  ------------------
  |  |  |  Branch (1025:6): [True: 3.96k, False: 0]
  |  |  |  Branch (1025:16): [True: 0, False: 3.96k]
  |  |  ------------------
  |  | 1026|  3.96k|	    (xmlDictOwns(dict, (const xmlChar *)(str)) == 0)))	\
  |  |  ------------------
  |  |  |  Branch (1026:6): [True: 0, False: 3.96k]
  |  |  ------------------
  |  | 1027|  3.96k|	    xmlFree((char *)(str));
  ------------------
 2079|  3.96k|    xmlFree(cur);
 2080|  3.96k|}
xmlNewNodeEatName:
 2232|  3.54k|xmlNewNodeEatName(xmlNsPtr ns, xmlChar *name) {
 2233|  3.54k|    xmlNodePtr cur;
 2234|       |
 2235|  3.54k|    if (name == NULL) {
  ------------------
  |  Branch (2235:9): [True: 0, False: 3.54k]
  ------------------
 2236|      0|	return(NULL);
 2237|      0|    }
 2238|       |
 2239|       |    /*
 2240|       |     * Allocate a new node and fill the fields.
 2241|       |     */
 2242|  3.54k|    cur = (xmlNodePtr) xmlMalloc(sizeof(xmlNode));
 2243|  3.54k|    if (cur == NULL) {
  ------------------
  |  Branch (2243:9): [True: 0, False: 3.54k]
  ------------------
 2244|      0|	xmlTreeErrMemory("building node");
 2245|       |	/* we can't check here that name comes from the doc dictionary */
 2246|      0|	return(NULL);
 2247|      0|    }
 2248|  3.54k|    memset(cur, 0, sizeof(xmlNode));
 2249|  3.54k|    cur->type = XML_ELEMENT_NODE;
 2250|       |
 2251|  3.54k|    cur->name = name;
 2252|  3.54k|    cur->ns = ns;
 2253|       |
 2254|  3.54k|    if ((__xmlRegisterCallbacks) && (xmlRegisterNodeDefaultValue))
  ------------------
  |  |  682|      0|    XML_GLOBAL_MACRO(xmlRegisterNodeDefaultValue)
  |  |  ------------------
  |  |  |  |  500|      0|  #define XML_GLOBAL_MACRO(name) (*__##name())
  |  |  ------------------
  ------------------
  |  Branch (2254:9): [True: 0, False: 3.54k]
  |  Branch (2254:37): [True: 0, False: 0]
  ------------------
 2255|      0|	xmlRegisterNodeDefaultValue((xmlNodePtr)cur);
  ------------------
  |  |  682|      0|    XML_GLOBAL_MACRO(xmlRegisterNodeDefaultValue)
  |  |  ------------------
  |  |  |  |  500|      0|  #define XML_GLOBAL_MACRO(name) (*__##name())
  |  |  ------------------
  ------------------
 2256|  3.54k|    return(cur);
 2257|  3.54k|}
xmlNewDocNodeEatName:
 2314|  3.54k|              xmlChar *name, const xmlChar *content) {
 2315|  3.54k|    xmlNodePtr cur;
 2316|       |
 2317|  3.54k|    cur = xmlNewNodeEatName(ns, name);
 2318|  3.54k|    if (cur != NULL) {
  ------------------
  |  Branch (2318:9): [True: 3.54k, False: 0]
  ------------------
 2319|  3.54k|        cur->doc = doc;
 2320|  3.54k|	if (content != NULL) {
  ------------------
  |  Branch (2320:6): [True: 0, False: 3.54k]
  ------------------
 2321|      0|	    cur->children = xmlStringGetNodeList(doc, content);
 2322|      0|	    UPDATE_LAST_CHILD_AND_PARENT(cur)
  ------------------
  |  |  127|      0|#define UPDATE_LAST_CHILD_AND_PARENT(n) if ((n) != NULL) {		\
  |  |  ------------------
  |  |  |  Branch (127:45): [True: 0, False: 0]
  |  |  ------------------
  |  |  128|      0|    xmlNodePtr ulccur = (n)->children;					\
  |  |  129|      0|    if (ulccur == NULL) {						\
  |  |  ------------------
  |  |  |  Branch (129:9): [True: 0, False: 0]
  |  |  ------------------
  |  |  130|      0|        (n)->last = NULL;						\
  |  |  131|      0|    } else {								\
  |  |  132|      0|        while (ulccur->next != NULL) {					\
  |  |  ------------------
  |  |  |  Branch (132:16): [True: 0, False: 0]
  |  |  ------------------
  |  |  133|      0|		ulccur->parent = (n);					\
  |  |  134|      0|		ulccur = ulccur->next;					\
  |  |  135|      0|	}								\
  |  |  136|      0|	ulccur->parent = (n);						\
  |  |  137|      0|	(n)->last = ulccur;						\
  |  |  138|      0|}}
  ------------------
 2323|      0|	}
 2324|  3.54k|    } else {
 2325|       |        /* if name don't come from the doc dictionary free it here */
 2326|      0|        if ((name != NULL) &&
  ------------------
  |  Branch (2326:13): [True: 0, False: 0]
  ------------------
 2327|      0|            ((doc == NULL) || (doc->dict == NULL) ||
  ------------------
  |  Branch (2327:14): [True: 0, False: 0]
  |  Branch (2327:31): [True: 0, False: 0]
  ------------------
 2328|      0|	     (!(xmlDictOwns(doc->dict, name)))))
  ------------------
  |  Branch (2328:7): [True: 0, False: 0]
  ------------------
 2329|      0|	    xmlFree(name);
 2330|      0|    }
 2331|  3.54k|    return(cur);
 2332|  3.54k|}
xmlNewComment:
 2682|    184|xmlNewComment(const xmlChar *content) {
 2683|    184|    xmlNodePtr cur;
 2684|       |
 2685|       |    /*
 2686|       |     * Allocate a new node and fill the fields.
 2687|       |     */
 2688|    184|    cur = (xmlNodePtr) xmlMalloc(sizeof(xmlNode));
 2689|    184|    if (cur == NULL) {
  ------------------
  |  Branch (2689:9): [True: 0, False: 184]
  ------------------
 2690|      0|	xmlTreeErrMemory("building comment");
 2691|      0|	return(NULL);
 2692|      0|    }
 2693|    184|    memset(cur, 0, sizeof(xmlNode));
 2694|    184|    cur->type = XML_COMMENT_NODE;
 2695|       |
 2696|    184|    cur->name = xmlStringComment;
 2697|    184|    if (content != NULL) {
  ------------------
  |  Branch (2697:9): [True: 184, False: 0]
  ------------------
 2698|    184|	cur->content = xmlStrdup(content);
 2699|    184|    }
 2700|       |
 2701|    184|    if ((__xmlRegisterCallbacks) && (xmlRegisterNodeDefaultValue))
  ------------------
  |  |  682|      0|    XML_GLOBAL_MACRO(xmlRegisterNodeDefaultValue)
  |  |  ------------------
  |  |  |  |  500|      0|  #define XML_GLOBAL_MACRO(name) (*__##name())
  |  |  ------------------
  ------------------
  |  Branch (2701:9): [True: 0, False: 184]
  |  Branch (2701:37): [True: 0, False: 0]
  ------------------
 2702|      0|	xmlRegisterNodeDefaultValue(cur);
  ------------------
  |  |  682|      0|    XML_GLOBAL_MACRO(xmlRegisterNodeDefaultValue)
  |  |  ------------------
  |  |  |  |  500|      0|  #define XML_GLOBAL_MACRO(name) (*__##name())
  |  |  ------------------
  ------------------
 2703|    184|    return(cur);
 2704|    184|}
xmlNewDocComment:
 2749|    184|xmlNewDocComment(xmlDocPtr doc, const xmlChar *content) {
 2750|    184|    xmlNodePtr cur;
 2751|       |
 2752|    184|    cur = xmlNewComment(content);
 2753|    184|    if (cur != NULL) cur->doc = doc;
  ------------------
  |  Branch (2753:9): [True: 184, False: 0]
  ------------------
 2754|    184|    return(cur);
 2755|    184|}
xmlAddChild:
 3279|  7.11k|xmlAddChild(xmlNodePtr parent, xmlNodePtr cur) {
 3280|  7.11k|    xmlNodePtr prev;
 3281|       |
 3282|  7.11k|    if ((parent == NULL) || (parent->type == XML_NAMESPACE_DECL)) {
  ------------------
  |  Branch (3282:9): [True: 0, False: 7.11k]
  |  Branch (3282:29): [True: 0, False: 7.11k]
  ------------------
 3283|      0|	return(NULL);
 3284|      0|    }
 3285|       |
 3286|  7.11k|    if ((cur == NULL) || (cur->type == XML_NAMESPACE_DECL)) {
  ------------------
  |  Branch (3286:9): [True: 0, False: 7.11k]
  |  Branch (3286:26): [True: 0, False: 7.11k]
  ------------------
 3287|      0|	return(NULL);
 3288|      0|    }
 3289|       |
 3290|  7.11k|    if (parent == cur) {
  ------------------
  |  Branch (3290:9): [True: 0, False: 7.11k]
  ------------------
 3291|      0|	return(NULL);
 3292|      0|    }
 3293|       |    /*
 3294|       |     * If cur is a TEXT node, merge its content with adjacent TEXT nodes
 3295|       |     * cur is then freed.
 3296|       |     */
 3297|  7.11k|    if (cur->type == XML_TEXT_NODE) {
  ------------------
  |  Branch (3297:9): [True: 3.38k, False: 3.72k]
  ------------------
 3298|  3.38k|	if ((parent->type == XML_TEXT_NODE) &&
  ------------------
  |  Branch (3298:6): [True: 0, False: 3.38k]
  ------------------
 3299|  3.38k|	    (parent->content != NULL) &&
  ------------------
  |  Branch (3299:6): [True: 0, False: 0]
  ------------------
 3300|  3.38k|	    (parent->name == cur->name)) {
  ------------------
  |  Branch (3300:6): [True: 0, False: 0]
  ------------------
 3301|      0|	    xmlNodeAddContent(parent, cur->content);
 3302|      0|	    xmlFreeNode(cur);
 3303|      0|	    return(parent);
 3304|      0|	}
 3305|  3.38k|	if ((parent->last != NULL) && (parent->last->type == XML_TEXT_NODE) &&
  ------------------
  |  Branch (3305:6): [True: 3.38k, False: 0]
  |  Branch (3305:32): [True: 0, False: 3.38k]
  ------------------
 3306|  3.38k|	    (parent->last->name == cur->name) &&
  ------------------
  |  Branch (3306:6): [True: 0, False: 0]
  ------------------
 3307|  3.38k|	    (parent->last != cur)) {
  ------------------
  |  Branch (3307:6): [True: 0, False: 0]
  ------------------
 3308|      0|	    xmlNodeAddContent(parent->last, cur->content);
 3309|      0|	    xmlFreeNode(cur);
 3310|      0|	    return(parent->last);
 3311|      0|	}
 3312|  3.38k|    }
 3313|       |
 3314|       |    /*
 3315|       |     * add the new element at the end of the children list.
 3316|       |     */
 3317|  7.11k|    prev = cur->parent;
 3318|  7.11k|    cur->parent = parent;
 3319|  7.11k|    if (cur->doc != parent->doc) {
  ------------------
  |  Branch (3319:9): [True: 0, False: 7.11k]
  ------------------
 3320|      0|	xmlSetTreeDoc(cur, parent->doc);
 3321|      0|    }
 3322|       |    /* this check prevents a loop on tree-traversions if a developer
 3323|       |     * tries to add a node to its parent multiple times
 3324|       |     */
 3325|  7.11k|    if (prev == parent)
  ------------------
  |  Branch (3325:9): [True: 0, False: 7.11k]
  ------------------
 3326|      0|	return(cur);
 3327|       |
 3328|       |    /*
 3329|       |     * Coalescing
 3330|       |     */
 3331|  7.11k|    if ((parent->type == XML_TEXT_NODE) &&
  ------------------
  |  Branch (3331:9): [True: 0, False: 7.11k]
  ------------------
 3332|  7.11k|	(parent->content != NULL) &&
  ------------------
  |  Branch (3332:2): [True: 0, False: 0]
  ------------------
 3333|  7.11k|	(parent != cur)) {
  ------------------
  |  Branch (3333:2): [True: 0, False: 0]
  ------------------
 3334|      0|	xmlNodeAddContent(parent, cur->content);
 3335|      0|	xmlFreeNode(cur);
 3336|      0|	return(parent);
 3337|      0|    }
 3338|  7.11k|    if (cur->type == XML_ATTRIBUTE_NODE) {
  ------------------
  |  Branch (3338:9): [True: 0, False: 7.11k]
  ------------------
 3339|      0|		if (parent->type != XML_ELEMENT_NODE)
  ------------------
  |  Branch (3339:7): [True: 0, False: 0]
  ------------------
 3340|      0|			return(NULL);
 3341|      0|	if (parent->properties != NULL) {
  ------------------
  |  Branch (3341:6): [True: 0, False: 0]
  ------------------
 3342|       |	    /* check if an attribute with the same name exists */
 3343|      0|	    xmlAttrPtr lastattr;
 3344|       |
 3345|      0|	    if (cur->ns == NULL)
  ------------------
  |  Branch (3345:10): [True: 0, False: 0]
  ------------------
 3346|      0|		lastattr = xmlHasNsProp(parent, cur->name, NULL);
 3347|      0|	    else
 3348|      0|		lastattr = xmlHasNsProp(parent, cur->name, cur->ns->href);
 3349|      0|	    if ((lastattr != NULL) && (lastattr != (xmlAttrPtr) cur) && (lastattr->type != XML_ATTRIBUTE_DECL)) {
  ------------------
  |  Branch (3349:10): [True: 0, False: 0]
  |  Branch (3349:32): [True: 0, False: 0]
  |  Branch (3349:66): [True: 0, False: 0]
  ------------------
 3350|       |		/* different instance, destroy it (attributes must be unique) */
 3351|      0|			xmlUnlinkNode((xmlNodePtr) lastattr);
 3352|      0|		xmlFreeProp(lastattr);
 3353|      0|	    }
 3354|      0|		if (lastattr == (xmlAttrPtr) cur)
  ------------------
  |  Branch (3354:7): [True: 0, False: 0]
  ------------------
 3355|      0|			return(cur);
 3356|       |
 3357|      0|	}
 3358|      0|	if (parent->properties == NULL) {
  ------------------
  |  Branch (3358:6): [True: 0, False: 0]
  ------------------
 3359|      0|	    parent->properties = (xmlAttrPtr) cur;
 3360|      0|	} else {
 3361|       |	    /* find the end */
 3362|      0|	    xmlAttrPtr lastattr = parent->properties;
 3363|      0|	    while (lastattr->next != NULL) {
  ------------------
  |  Branch (3363:13): [True: 0, False: 0]
  ------------------
 3364|      0|		lastattr = lastattr->next;
 3365|      0|	    }
 3366|      0|	    lastattr->next = (xmlAttrPtr) cur;
 3367|      0|	    ((xmlAttrPtr) cur)->prev = lastattr;
 3368|      0|	}
 3369|  7.11k|    } else {
 3370|  7.11k|	if (parent->children == NULL) {
  ------------------
  |  Branch (3370:6): [True: 231, False: 6.88k]
  ------------------
 3371|    231|	    parent->children = cur;
 3372|    231|	    parent->last = cur;
 3373|  6.88k|	} else {
 3374|  6.88k|	    prev = parent->last;
 3375|  6.88k|	    prev->next = cur;
 3376|  6.88k|	    cur->prev = prev;
 3377|  6.88k|	    parent->last = cur;
 3378|  6.88k|	}
 3379|  7.11k|    }
 3380|  7.11k|    return(cur);
 3381|  7.11k|}
xmlFreeNodeList:
 3602|  4.19k|xmlFreeNodeList(xmlNodePtr cur) {
 3603|  4.19k|    xmlNodePtr next;
 3604|  4.19k|    xmlNodePtr parent;
 3605|  4.19k|    xmlDictPtr dict = NULL;
 3606|  4.19k|    size_t depth = 0;
 3607|       |
 3608|  4.19k|    if (cur == NULL) return;
  ------------------
  |  Branch (3608:9): [True: 0, False: 4.19k]
  ------------------
 3609|  4.19k|    if (cur->type == XML_NAMESPACE_DECL) {
  ------------------
  |  Branch (3609:9): [True: 0, False: 4.19k]
  ------------------
 3610|      0|	xmlFreeNsList((xmlNsPtr) cur);
 3611|      0|	return;
 3612|      0|    }
 3613|  4.19k|    if (cur->doc != NULL) dict = cur->doc->dict;
  ------------------
  |  Branch (3613:9): [True: 4.19k, False: 0]
  ------------------
 3614|  8.00k|    while (1) {
  ------------------
  |  Branch (3614:12): [Folded - Ignored]
  ------------------
 3615|  10.0k|        while ((cur->children != NULL) &&
  ------------------
  |  Branch (3615:16): [True: 2.04k, False: 8.00k]
  ------------------
 3616|  10.0k|               (cur->type != XML_DOCUMENT_NODE) &&
  ------------------
  |  Branch (3616:16): [True: 2.04k, False: 0]
  ------------------
 3617|  10.0k|               (cur->type != XML_HTML_DOCUMENT_NODE) &&
  ------------------
  |  Branch (3617:16): [True: 2.04k, False: 0]
  ------------------
 3618|  10.0k|               (cur->type != XML_DTD_NODE) &&
  ------------------
  |  Branch (3618:16): [True: 2.04k, False: 0]
  ------------------
 3619|  10.0k|               (cur->type != XML_ENTITY_REF_NODE)) {
  ------------------
  |  Branch (3619:16): [True: 2.04k, False: 0]
  ------------------
 3620|  2.04k|            cur = cur->children;
 3621|  2.04k|            depth += 1;
 3622|  2.04k|        }
 3623|       |
 3624|  8.00k|        next = cur->next;
 3625|  8.00k|        parent = cur->parent;
 3626|  8.00k|	if ((cur->type == XML_DOCUMENT_NODE) ||
  ------------------
  |  Branch (3626:6): [True: 0, False: 8.00k]
  ------------------
 3627|  8.00k|            (cur->type == XML_HTML_DOCUMENT_NODE)) {
  ------------------
  |  Branch (3627:13): [True: 0, False: 8.00k]
  ------------------
 3628|      0|            xmlFreeDoc((xmlDocPtr) cur);
 3629|  8.00k|        } else if (cur->type != XML_DTD_NODE) {
  ------------------
  |  Branch (3629:20): [True: 8.00k, False: 0]
  ------------------
 3630|       |
 3631|  8.00k|	    if ((__xmlRegisterCallbacks) && (xmlDeregisterNodeDefaultValue))
  ------------------
  |  |  684|      0|    XML_GLOBAL_MACRO(xmlDeregisterNodeDefaultValue)
  |  |  ------------------
  |  |  |  |  500|      0|  #define XML_GLOBAL_MACRO(name) (*__##name())
  |  |  ------------------
  ------------------
  |  Branch (3631:10): [True: 0, False: 8.00k]
  |  Branch (3631:38): [True: 0, False: 0]
  ------------------
 3632|      0|		xmlDeregisterNodeDefaultValue(cur);
  ------------------
  |  |  684|      0|    XML_GLOBAL_MACRO(xmlDeregisterNodeDefaultValue)
  |  |  ------------------
  |  |  |  |  500|      0|  #define XML_GLOBAL_MACRO(name) (*__##name())
  |  |  ------------------
  ------------------
 3633|       |
 3634|  8.00k|	    if (((cur->type == XML_ELEMENT_NODE) ||
  ------------------
  |  Branch (3634:11): [True: 3.54k, False: 4.46k]
  ------------------
 3635|  8.00k|		 (cur->type == XML_XINCLUDE_START) ||
  ------------------
  |  Branch (3635:4): [True: 0, False: 4.46k]
  ------------------
 3636|  8.00k|		 (cur->type == XML_XINCLUDE_END)) &&
  ------------------
  |  Branch (3636:4): [True: 0, False: 4.46k]
  ------------------
 3637|  8.00k|		(cur->properties != NULL))
  ------------------
  |  Branch (3637:3): [True: 2.60k, False: 934]
  ------------------
 3638|  2.60k|		xmlFreePropList(cur->properties);
 3639|  8.00k|	    if ((cur->type != XML_ELEMENT_NODE) &&
  ------------------
  |  Branch (3639:10): [True: 4.46k, False: 3.54k]
  ------------------
 3640|  8.00k|		(cur->type != XML_XINCLUDE_START) &&
  ------------------
  |  Branch (3640:3): [True: 4.46k, False: 0]
  ------------------
 3641|  8.00k|		(cur->type != XML_XINCLUDE_END) &&
  ------------------
  |  Branch (3641:3): [True: 4.46k, False: 0]
  ------------------
 3642|  8.00k|		(cur->type != XML_ENTITY_REF_NODE) &&
  ------------------
  |  Branch (3642:3): [True: 4.46k, False: 0]
  ------------------
 3643|  8.00k|		(cur->content != (xmlChar *) &(cur->properties))) {
  ------------------
  |  Branch (3643:3): [True: 4.46k, False: 0]
  ------------------
 3644|  4.46k|		DICT_FREE(cur->content)
  ------------------
  |  | 1025|  4.46k|	if ((str) && ((!dict) ||				\
  |  |  ------------------
  |  |  |  Branch (1025:6): [True: 4.46k, False: 0]
  |  |  |  Branch (1025:16): [True: 0, False: 4.46k]
  |  |  ------------------
  |  | 1026|  4.46k|	    (xmlDictOwns(dict, (const xmlChar *)(str)) == 0)))	\
  |  |  ------------------
  |  |  |  Branch (1026:6): [True: 3.32k, False: 1.13k]
  |  |  ------------------
  |  | 1027|  4.46k|	    xmlFree((char *)(str));
  ------------------
 3645|  4.46k|	    }
 3646|  8.00k|	    if (((cur->type == XML_ELEMENT_NODE) ||
  ------------------
  |  Branch (3646:11): [True: 3.54k, False: 4.46k]
  ------------------
 3647|  8.00k|	         (cur->type == XML_XINCLUDE_START) ||
  ------------------
  |  Branch (3647:11): [True: 0, False: 4.46k]
  ------------------
 3648|  8.00k|		 (cur->type == XML_XINCLUDE_END)) &&
  ------------------
  |  Branch (3648:4): [True: 0, False: 4.46k]
  ------------------
 3649|  8.00k|		(cur->nsDef != NULL))
  ------------------
  |  Branch (3649:3): [True: 233, False: 3.30k]
  ------------------
 3650|    233|		xmlFreeNsList(cur->nsDef);
 3651|       |
 3652|       |	    /*
 3653|       |	     * When a node is a text node or a comment, it uses a global static
 3654|       |	     * variable for the name of the node.
 3655|       |	     * Otherwise the node name might come from the document's
 3656|       |	     * dictionary
 3657|       |	     */
 3658|  8.00k|	    if ((cur->name != NULL) &&
  ------------------
  |  Branch (3658:10): [True: 8.00k, False: 0]
  ------------------
 3659|  8.00k|		(cur->type != XML_TEXT_NODE) &&
  ------------------
  |  Branch (3659:3): [True: 3.62k, False: 4.38k]
  ------------------
 3660|  8.00k|		(cur->type != XML_COMMENT_NODE))
  ------------------
  |  Branch (3660:3): [True: 3.54k, False: 78]
  ------------------
 3661|  3.54k|		DICT_FREE(cur->name)
  ------------------
  |  | 1025|  3.54k|	if ((str) && ((!dict) ||				\
  |  |  ------------------
  |  |  |  Branch (1025:6): [True: 3.54k, False: 0]
  |  |  |  Branch (1025:16): [True: 0, False: 3.54k]
  |  |  ------------------
  |  | 1026|  3.54k|	    (xmlDictOwns(dict, (const xmlChar *)(str)) == 0)))	\
  |  |  ------------------
  |  |  |  Branch (1026:6): [True: 0, False: 3.54k]
  |  |  ------------------
  |  | 1027|  3.54k|	    xmlFree((char *)(str));
  ------------------
 3662|  8.00k|	    xmlFree(cur);
 3663|  8.00k|	}
 3664|       |
 3665|  8.00k|        if (next != NULL) {
  ------------------
  |  Branch (3665:13): [True: 1.76k, False: 6.24k]
  ------------------
 3666|  1.76k|	    cur = next;
 3667|  6.24k|        } else {
 3668|  6.24k|            if ((depth == 0) || (parent == NULL))
  ------------------
  |  Branch (3668:17): [True: 4.19k, False: 2.04k]
  |  Branch (3668:33): [True: 0, False: 2.04k]
  ------------------
 3669|  4.19k|                break;
 3670|  2.04k|            depth -= 1;
 3671|  2.04k|            cur = parent;
 3672|  2.04k|            cur->children = NULL;
 3673|  2.04k|        }
 3674|  8.00k|    }
 3675|  4.19k|}
xmlFreeNode:
 3685|  5.13k|xmlFreeNode(xmlNodePtr cur) {
 3686|  5.13k|    xmlDictPtr dict = NULL;
 3687|       |
 3688|  5.13k|    if (cur == NULL) return;
  ------------------
  |  Branch (3688:9): [True: 0, False: 5.13k]
  ------------------
 3689|       |
 3690|       |    /* use xmlFreeDtd for DTD nodes */
 3691|  5.13k|    if (cur->type == XML_DTD_NODE) {
  ------------------
  |  Branch (3691:9): [True: 0, False: 5.13k]
  ------------------
 3692|      0|	xmlFreeDtd((xmlDtdPtr) cur);
 3693|      0|	return;
 3694|      0|    }
 3695|  5.13k|    if (cur->type == XML_NAMESPACE_DECL) {
  ------------------
  |  Branch (3695:9): [True: 0, False: 5.13k]
  ------------------
 3696|      0|	xmlFreeNs((xmlNsPtr) cur);
 3697|      0|        return;
 3698|      0|    }
 3699|  5.13k|    if (cur->type == XML_ATTRIBUTE_NODE) {
  ------------------
  |  Branch (3699:9): [True: 0, False: 5.13k]
  ------------------
 3700|      0|	xmlFreeProp((xmlAttrPtr) cur);
 3701|      0|	return;
 3702|      0|    }
 3703|       |
 3704|  5.13k|    if ((__xmlRegisterCallbacks) && (xmlDeregisterNodeDefaultValue))
  ------------------
  |  |  684|      0|    XML_GLOBAL_MACRO(xmlDeregisterNodeDefaultValue)
  |  |  ------------------
  |  |  |  |  500|      0|  #define XML_GLOBAL_MACRO(name) (*__##name())
  |  |  ------------------
  ------------------
  |  Branch (3704:9): [True: 0, False: 5.13k]
  |  Branch (3704:37): [True: 0, False: 0]
  ------------------
 3705|      0|	xmlDeregisterNodeDefaultValue(cur);
  ------------------
  |  |  684|      0|    XML_GLOBAL_MACRO(xmlDeregisterNodeDefaultValue)
  |  |  ------------------
  |  |  |  |  500|      0|  #define XML_GLOBAL_MACRO(name) (*__##name())
  |  |  ------------------
  ------------------
 3706|       |
 3707|  5.13k|    if (cur->doc != NULL) dict = cur->doc->dict;
  ------------------
  |  Branch (3707:9): [True: 5.13k, False: 0]
  ------------------
 3708|       |
 3709|  5.13k|    if (cur->type == XML_ENTITY_DECL) {
  ------------------
  |  Branch (3709:9): [True: 0, False: 5.13k]
  ------------------
 3710|      0|        xmlEntityPtr ent = (xmlEntityPtr) cur;
 3711|      0|	DICT_FREE(ent->SystemID);
  ------------------
  |  | 1025|      0|	if ((str) && ((!dict) ||				\
  |  |  ------------------
  |  |  |  Branch (1025:6): [True: 0, False: 0]
  |  |  |  Branch (1025:16): [True: 0, False: 0]
  |  |  ------------------
  |  | 1026|      0|	    (xmlDictOwns(dict, (const xmlChar *)(str)) == 0)))	\
  |  |  ------------------
  |  |  |  Branch (1026:6): [True: 0, False: 0]
  |  |  ------------------
  |  | 1027|      0|	    xmlFree((char *)(str));
  ------------------
 3712|      0|	DICT_FREE(ent->ExternalID);
  ------------------
  |  | 1025|      0|	if ((str) && ((!dict) ||				\
  |  |  ------------------
  |  |  |  Branch (1025:6): [True: 0, False: 0]
  |  |  |  Branch (1025:16): [True: 0, False: 0]
  |  |  ------------------
  |  | 1026|      0|	    (xmlDictOwns(dict, (const xmlChar *)(str)) == 0)))	\
  |  |  ------------------
  |  |  |  Branch (1026:6): [True: 0, False: 0]
  |  |  ------------------
  |  | 1027|      0|	    xmlFree((char *)(str));
  ------------------
 3713|      0|    }
 3714|  5.13k|    if ((cur->children != NULL) &&
  ------------------
  |  Branch (3714:9): [True: 0, False: 5.13k]
  ------------------
 3715|  5.13k|	(cur->type != XML_ENTITY_REF_NODE))
  ------------------
  |  Branch (3715:2): [True: 0, False: 0]
  ------------------
 3716|      0|	xmlFreeNodeList(cur->children);
 3717|       |
 3718|  5.13k|    if ((cur->type == XML_ELEMENT_NODE) ||
  ------------------
  |  Branch (3718:9): [True: 0, False: 5.13k]
  ------------------
 3719|  5.13k|        (cur->type == XML_XINCLUDE_START) ||
  ------------------
  |  Branch (3719:9): [True: 0, False: 5.13k]
  ------------------
 3720|  5.13k|        (cur->type == XML_XINCLUDE_END)) {
  ------------------
  |  Branch (3720:9): [True: 0, False: 5.13k]
  ------------------
 3721|      0|        if (cur->properties != NULL)
  ------------------
  |  Branch (3721:13): [True: 0, False: 0]
  ------------------
 3722|      0|            xmlFreePropList(cur->properties);
 3723|      0|        if (cur->nsDef != NULL)
  ------------------
  |  Branch (3723:13): [True: 0, False: 0]
  ------------------
 3724|      0|            xmlFreeNsList(cur->nsDef);
 3725|  5.13k|    } else if ((cur->content != NULL) &&
  ------------------
  |  Branch (3725:16): [True: 5.13k, False: 0]
  ------------------
 3726|  5.13k|               (cur->type != XML_ENTITY_REF_NODE) &&
  ------------------
  |  Branch (3726:16): [True: 5.13k, False: 0]
  ------------------
 3727|  5.13k|               (cur->content != (xmlChar *) &(cur->properties))) {
  ------------------
  |  Branch (3727:16): [True: 5.13k, False: 0]
  ------------------
 3728|  5.13k|        DICT_FREE(cur->content)
  ------------------
  |  | 1025|  5.13k|	if ((str) && ((!dict) ||				\
  |  |  ------------------
  |  |  |  Branch (1025:6): [True: 5.13k, False: 0]
  |  |  |  Branch (1025:16): [True: 0, False: 5.13k]
  |  |  ------------------
  |  | 1026|  5.13k|	    (xmlDictOwns(dict, (const xmlChar *)(str)) == 0)))	\
  |  |  ------------------
  |  |  |  Branch (1026:6): [True: 299, False: 4.83k]
  |  |  ------------------
  |  | 1027|  5.13k|	    xmlFree((char *)(str));
  ------------------
 3729|  5.13k|    }
 3730|       |
 3731|       |    /*
 3732|       |     * When a node is a text node or a comment, it uses a global static
 3733|       |     * variable for the name of the node.
 3734|       |     * Otherwise the node name might come from the document's dictionary
 3735|       |     */
 3736|  5.13k|    if ((cur->name != NULL) &&
  ------------------
  |  Branch (3736:9): [True: 5.13k, False: 0]
  ------------------
 3737|  5.13k|        (cur->type != XML_TEXT_NODE) &&
  ------------------
  |  Branch (3737:9): [True: 106, False: 5.03k]
  ------------------
 3738|  5.13k|        (cur->type != XML_COMMENT_NODE))
  ------------------
  |  Branch (3738:9): [True: 0, False: 106]
  ------------------
 3739|      0|	DICT_FREE(cur->name)
  ------------------
  |  | 1025|      0|	if ((str) && ((!dict) ||				\
  |  |  ------------------
  |  |  |  Branch (1025:6): [True: 0, False: 0]
  |  |  |  Branch (1025:16): [True: 0, False: 0]
  |  |  ------------------
  |  | 1026|      0|	    (xmlDictOwns(dict, (const xmlChar *)(str)) == 0)))	\
  |  |  ------------------
  |  |  |  Branch (1026:6): [True: 0, False: 0]
  |  |  ------------------
  |  | 1027|      0|	    xmlFree((char *)(str));
  ------------------
 3740|       |
 3741|  5.13k|    xmlFree(cur);
 3742|  5.13k|}
xmlUnlinkNode:
 3755|  5.13k|xmlUnlinkNode(xmlNodePtr cur) {
 3756|  5.13k|    if (cur == NULL) {
  ------------------
  |  Branch (3756:9): [True: 0, False: 5.13k]
  ------------------
 3757|      0|	return;
 3758|      0|    }
 3759|  5.13k|    if (cur->type == XML_NAMESPACE_DECL)
  ------------------
  |  Branch (3759:9): [True: 0, False: 5.13k]
  ------------------
 3760|      0|        return;
 3761|  5.13k|    if (cur->type == XML_DTD_NODE) {
  ------------------
  |  Branch (3761:9): [True: 0, False: 5.13k]
  ------------------
 3762|      0|	xmlDocPtr doc;
 3763|      0|	doc = cur->doc;
 3764|      0|	if (doc != NULL) {
  ------------------
  |  Branch (3764:6): [True: 0, False: 0]
  ------------------
 3765|      0|	    if (doc->intSubset == (xmlDtdPtr) cur)
  ------------------
  |  Branch (3765:10): [True: 0, False: 0]
  ------------------
 3766|      0|		doc->intSubset = NULL;
 3767|      0|	    if (doc->extSubset == (xmlDtdPtr) cur)
  ------------------
  |  Branch (3767:10): [True: 0, False: 0]
  ------------------
 3768|      0|		doc->extSubset = NULL;
 3769|      0|	}
 3770|      0|    }
 3771|  5.13k|    if (cur->type == XML_ENTITY_DECL) {
  ------------------
  |  Branch (3771:9): [True: 0, False: 5.13k]
  ------------------
 3772|      0|        xmlDocPtr doc;
 3773|      0|	doc = cur->doc;
 3774|      0|	if (doc != NULL) {
  ------------------
  |  Branch (3774:6): [True: 0, False: 0]
  ------------------
 3775|      0|	    if (doc->intSubset != NULL) {
  ------------------
  |  Branch (3775:10): [True: 0, False: 0]
  ------------------
 3776|      0|	        if (xmlHashLookup(doc->intSubset->entities, cur->name) == cur)
  ------------------
  |  Branch (3776:14): [True: 0, False: 0]
  ------------------
 3777|      0|		    xmlHashRemoveEntry(doc->intSubset->entities, cur->name,
 3778|      0|		                       NULL);
 3779|      0|	        if (xmlHashLookup(doc->intSubset->pentities, cur->name) == cur)
  ------------------
  |  Branch (3779:14): [True: 0, False: 0]
  ------------------
 3780|      0|		    xmlHashRemoveEntry(doc->intSubset->pentities, cur->name,
 3781|      0|		                       NULL);
 3782|      0|	    }
 3783|      0|	    if (doc->extSubset != NULL) {
  ------------------
  |  Branch (3783:10): [True: 0, False: 0]
  ------------------
 3784|      0|	        if (xmlHashLookup(doc->extSubset->entities, cur->name) == cur)
  ------------------
  |  Branch (3784:14): [True: 0, False: 0]
  ------------------
 3785|      0|		    xmlHashRemoveEntry(doc->extSubset->entities, cur->name,
 3786|      0|		                       NULL);
 3787|      0|	        if (xmlHashLookup(doc->extSubset->pentities, cur->name) == cur)
  ------------------
  |  Branch (3787:14): [True: 0, False: 0]
  ------------------
 3788|      0|		    xmlHashRemoveEntry(doc->extSubset->pentities, cur->name,
 3789|      0|		                       NULL);
 3790|      0|	    }
 3791|      0|	}
 3792|      0|    }
 3793|  5.13k|    if (cur->parent != NULL) {
  ------------------
  |  Branch (3793:9): [True: 5.13k, False: 0]
  ------------------
 3794|  5.13k|	xmlNodePtr parent;
 3795|  5.13k|	parent = cur->parent;
 3796|  5.13k|	if (cur->type == XML_ATTRIBUTE_NODE) {
  ------------------
  |  Branch (3796:6): [True: 0, False: 5.13k]
  ------------------
 3797|      0|	    if (parent->properties == (xmlAttrPtr) cur)
  ------------------
  |  Branch (3797:10): [True: 0, False: 0]
  ------------------
 3798|      0|		parent->properties = ((xmlAttrPtr) cur)->next;
 3799|  5.13k|	} else {
 3800|  5.13k|	    if (parent->children == cur)
  ------------------
  |  Branch (3800:10): [True: 1.85k, False: 3.28k]
  ------------------
 3801|  1.85k|		parent->children = cur->next;
 3802|  5.13k|	    if (parent->last == cur)
  ------------------
  |  Branch (3802:10): [True: 1.82k, False: 3.31k]
  ------------------
 3803|  1.82k|		parent->last = cur->prev;
 3804|  5.13k|	}
 3805|  5.13k|	cur->parent = NULL;
 3806|  5.13k|    }
 3807|  5.13k|    if (cur->next != NULL)
  ------------------
  |  Branch (3807:9): [True: 3.31k, False: 1.82k]
  ------------------
 3808|  3.31k|        cur->next->prev = cur->prev;
 3809|  5.13k|    if (cur->prev != NULL)
  ------------------
  |  Branch (3809:9): [True: 3.28k, False: 1.85k]
  ------------------
 3810|  3.28k|        cur->prev->next = cur->next;
 3811|  5.13k|    cur->next = cur->prev = NULL;
 3812|  5.13k|}
xmlGetLineNo:
 4629|     17|{
 4630|     17|    return(xmlGetLineNoInternal(node, 0));
 4631|     17|}
xmlDocGetRootElement:
 4892|    406|xmlDocGetRootElement(const xmlDoc *doc) {
 4893|    406|    xmlNodePtr ret;
 4894|       |
 4895|    406|    if (doc == NULL) return(NULL);
  ------------------
  |  Branch (4895:9): [True: 0, False: 406]
  ------------------
 4896|    406|    ret = doc->children;
 4897|    532|    while (ret != NULL) {
  ------------------
  |  Branch (4897:12): [True: 532, False: 0]
  ------------------
 4898|    532|	if (ret->type == XML_ELEMENT_NODE)
  ------------------
  |  Branch (4898:6): [True: 406, False: 126]
  ------------------
 4899|    406|	    return(ret);
 4900|    126|        ret = ret->next;
 4901|    126|    }
 4902|      0|    return(ret);
 4903|    406|}
xmlNodeGetSpacePreserve:
 5081|  5.03k|xmlNodeGetSpacePreserve(const xmlNode *cur) {
 5082|  5.03k|    xmlChar *space;
 5083|       |
 5084|  5.03k|    if ((cur == NULL) || (cur->type != XML_ELEMENT_NODE))
  ------------------
  |  Branch (5084:9): [True: 0, False: 5.03k]
  |  Branch (5084:26): [True: 5.03k, False: 0]
  ------------------
 5085|  5.03k|        return(-1);
 5086|      0|    while (cur != NULL) {
  ------------------
  |  Branch (5086:12): [True: 0, False: 0]
  ------------------
 5087|      0|	space = xmlGetNsProp(cur, BAD_CAST "space", XML_XML_NAMESPACE);
  ------------------
  |  |   35|      0|#define BAD_CAST (xmlChar *)
  ------------------
              	space = xmlGetNsProp(cur, BAD_CAST "space", XML_XML_NAMESPACE);
  ------------------
  |  |  143|      0|    (const xmlChar *) "http://www.w3.org/XML/1998/namespace"
  ------------------
 5088|      0|	if (space != NULL) {
  ------------------
  |  Branch (5088:6): [True: 0, False: 0]
  ------------------
 5089|      0|	    if (xmlStrEqual(space, BAD_CAST "preserve")) {
  ------------------
  |  |   35|      0|#define BAD_CAST (xmlChar *)
  ------------------
  |  Branch (5089:10): [True: 0, False: 0]
  ------------------
 5090|      0|		xmlFree(space);
 5091|      0|		return(1);
 5092|      0|	    }
 5093|      0|	    if (xmlStrEqual(space, BAD_CAST "default")) {
  ------------------
  |  |   35|      0|#define BAD_CAST (xmlChar *)
  ------------------
  |  Branch (5093:10): [True: 0, False: 0]
  ------------------
 5094|      0|		xmlFree(space);
 5095|      0|		return(0);
 5096|      0|	    }
 5097|      0|	    xmlFree(space);
 5098|      0|	}
 5099|      0|	cur = cur->parent;
 5100|      0|    }
 5101|      0|    return(-1);
 5102|      0|}
xmlNodeGetBase:
 5245|     47|xmlNodeGetBase(const xmlDoc *doc, const xmlNode *cur) {
 5246|     47|    xmlChar *oldbase = NULL;
 5247|     47|    xmlChar *base, *newbase;
 5248|       |
 5249|     47|    if ((cur == NULL) && (doc == NULL))
  ------------------
  |  Branch (5249:9): [True: 0, False: 47]
  |  Branch (5249:26): [True: 0, False: 0]
  ------------------
 5250|      0|        return(NULL);
 5251|     47|    if ((cur != NULL) && (cur->type == XML_NAMESPACE_DECL))
  ------------------
  |  Branch (5251:9): [True: 47, False: 0]
  |  Branch (5251:26): [True: 0, False: 47]
  ------------------
 5252|      0|        return(NULL);
 5253|     47|    if (doc == NULL) doc = cur->doc;
  ------------------
  |  Branch (5253:9): [True: 0, False: 47]
  ------------------
 5254|     47|    if ((doc != NULL) && (doc->type == XML_HTML_DOCUMENT_NODE)) {
  ------------------
  |  Branch (5254:9): [True: 47, False: 0]
  |  Branch (5254:26): [True: 0, False: 47]
  ------------------
 5255|      0|        cur = doc->children;
 5256|      0|	while ((cur != NULL) && (cur->name != NULL)) {
  ------------------
  |  Branch (5256:9): [True: 0, False: 0]
  |  Branch (5256:26): [True: 0, False: 0]
  ------------------
 5257|      0|	    if (cur->type != XML_ELEMENT_NODE) {
  ------------------
  |  Branch (5257:10): [True: 0, False: 0]
  ------------------
 5258|      0|	        cur = cur->next;
 5259|      0|		continue;
 5260|      0|	    }
 5261|      0|	    if (!xmlStrcasecmp(cur->name, BAD_CAST "html")) {
  ------------------
  |  |   35|      0|#define BAD_CAST (xmlChar *)
  ------------------
  |  Branch (5261:10): [True: 0, False: 0]
  ------------------
 5262|      0|	        cur = cur->children;
 5263|      0|		continue;
 5264|      0|	    }
 5265|      0|	    if (!xmlStrcasecmp(cur->name, BAD_CAST "head")) {
  ------------------
  |  |   35|      0|#define BAD_CAST (xmlChar *)
  ------------------
  |  Branch (5265:10): [True: 0, False: 0]
  ------------------
 5266|      0|	        cur = cur->children;
 5267|      0|		continue;
 5268|      0|	    }
 5269|      0|	    if (!xmlStrcasecmp(cur->name, BAD_CAST "base")) {
  ------------------
  |  |   35|      0|#define BAD_CAST (xmlChar *)
  ------------------
  |  Branch (5269:10): [True: 0, False: 0]
  ------------------
 5270|      0|                return(xmlGetProp(cur, BAD_CAST "href"));
  ------------------
  |  |   35|      0|#define BAD_CAST (xmlChar *)
  ------------------
 5271|      0|	    }
 5272|      0|	    cur = cur->next;
 5273|      0|	}
 5274|      0|	return(NULL);
 5275|      0|    }
 5276|    188|    while (cur != NULL) {
  ------------------
  |  Branch (5276:12): [True: 141, False: 47]
  ------------------
 5277|    141|	if (cur->type == XML_ENTITY_DECL) {
  ------------------
  |  Branch (5277:6): [True: 0, False: 141]
  ------------------
 5278|      0|	    xmlEntityPtr ent = (xmlEntityPtr) cur;
 5279|      0|	    return(xmlStrdup(ent->URI));
 5280|      0|	}
 5281|    141|	if (cur->type == XML_ELEMENT_NODE) {
  ------------------
  |  Branch (5281:6): [True: 94, False: 47]
  ------------------
 5282|     94|	    base = xmlGetNsProp(cur, BAD_CAST "base", XML_XML_NAMESPACE);
  ------------------
  |  |   35|     94|#define BAD_CAST (xmlChar *)
  ------------------
              	    base = xmlGetNsProp(cur, BAD_CAST "base", XML_XML_NAMESPACE);
  ------------------
  |  |  143|     94|    (const xmlChar *) "http://www.w3.org/XML/1998/namespace"
  ------------------
 5283|     94|	    if (base != NULL) {
  ------------------
  |  Branch (5283:10): [True: 0, False: 94]
  ------------------
 5284|      0|		if (oldbase != NULL) {
  ------------------
  |  Branch (5284:7): [True: 0, False: 0]
  ------------------
 5285|      0|		    newbase = xmlBuildURI(oldbase, base);
 5286|      0|		    if (newbase != NULL) {
  ------------------
  |  Branch (5286:11): [True: 0, False: 0]
  ------------------
 5287|      0|			xmlFree(oldbase);
 5288|      0|			xmlFree(base);
 5289|      0|			oldbase = newbase;
 5290|      0|		    } else {
 5291|      0|			xmlFree(oldbase);
 5292|      0|			xmlFree(base);
 5293|      0|			return(NULL);
 5294|      0|		    }
 5295|      0|		} else {
 5296|      0|		    oldbase = base;
 5297|      0|		}
 5298|      0|		if ((!xmlStrncmp(oldbase, BAD_CAST "http://", 7)) ||
  ------------------
  |  |   35|      0|#define BAD_CAST (xmlChar *)
  ------------------
  |  Branch (5298:7): [True: 0, False: 0]
  ------------------
 5299|      0|		    (!xmlStrncmp(oldbase, BAD_CAST "ftp://", 6)) ||
  ------------------
  |  |   35|      0|#define BAD_CAST (xmlChar *)
  ------------------
  |  Branch (5299:7): [True: 0, False: 0]
  ------------------
 5300|      0|		    (!xmlStrncmp(oldbase, BAD_CAST "urn:", 4)))
  ------------------
  |  |   35|      0|#define BAD_CAST (xmlChar *)
  ------------------
  |  Branch (5300:7): [True: 0, False: 0]
  ------------------
 5301|      0|		    return(oldbase);
 5302|      0|	    }
 5303|     94|	}
 5304|    141|	cur = cur->parent;
 5305|    141|    }
 5306|     47|    if ((doc != NULL) && (doc->URL != NULL)) {
  ------------------
  |  Branch (5306:9): [True: 47, False: 0]
  |  Branch (5306:26): [True: 47, False: 0]
  ------------------
 5307|     47|	if (oldbase == NULL)
  ------------------
  |  Branch (5307:6): [True: 47, False: 0]
  ------------------
 5308|     47|	    return(xmlStrdup(doc->URL));
 5309|      0|	newbase = xmlBuildURI(oldbase, doc->URL);
 5310|      0|	xmlFree(oldbase);
 5311|      0|	return(newbase);
 5312|     47|    }
 5313|      0|    return(oldbase);
 5314|     47|}
xmlNodeGetContent:
 5497|  3.11k|{
 5498|  3.11k|    if (cur == NULL)
  ------------------
  |  Branch (5498:9): [True: 2, False: 3.11k]
  ------------------
 5499|      2|        return (NULL);
 5500|  3.11k|    switch (cur->type) {
  ------------------
  |  Branch (5500:13): [True: 0, False: 3.11k]
  ------------------
 5501|      0|        case XML_DOCUMENT_FRAG_NODE:
  ------------------
  |  Branch (5501:9): [True: 0, False: 3.11k]
  ------------------
 5502|      0|        case XML_ELEMENT_NODE:{
  ------------------
  |  Branch (5502:9): [True: 0, False: 3.11k]
  ------------------
 5503|      0|                xmlBufPtr buf;
 5504|      0|                xmlChar *ret;
 5505|       |
 5506|      0|                buf = xmlBufCreateSize(64);
 5507|      0|                if (buf == NULL)
  ------------------
  |  Branch (5507:21): [True: 0, False: 0]
  ------------------
 5508|      0|                    return (NULL);
 5509|      0|                xmlBufSetAllocationScheme(buf, XML_BUFFER_ALLOC_DOUBLEIT);
 5510|      0|		xmlBufGetNodeContent(buf, cur);
 5511|      0|                ret = xmlBufDetach(buf);
 5512|      0|                xmlBufFree(buf);
 5513|      0|                return (ret);
 5514|      0|            }
 5515|  3.11k|        case XML_ATTRIBUTE_NODE:
  ------------------
  |  Branch (5515:9): [True: 3.11k, False: 0]
  ------------------
 5516|  3.11k|	    return(xmlGetPropNodeValueInternal((xmlAttrPtr) cur));
 5517|      0|        case XML_COMMENT_NODE:
  ------------------
  |  Branch (5517:9): [True: 0, False: 3.11k]
  ------------------
 5518|      0|        case XML_PI_NODE:
  ------------------
  |  Branch (5518:9): [True: 0, False: 3.11k]
  ------------------
 5519|      0|            if (cur->content != NULL)
  ------------------
  |  Branch (5519:17): [True: 0, False: 0]
  ------------------
 5520|      0|                return (xmlStrdup(cur->content));
 5521|      0|            return (NULL);
 5522|      0|        case XML_ENTITY_REF_NODE:{
  ------------------
  |  Branch (5522:9): [True: 0, False: 3.11k]
  ------------------
 5523|      0|                xmlEntityPtr ent;
 5524|      0|                xmlBufPtr buf;
 5525|      0|                xmlChar *ret;
 5526|       |
 5527|       |                /* lookup entity declaration */
 5528|      0|                ent = xmlGetDocEntity(cur->doc, cur->name);
 5529|      0|                if (ent == NULL)
  ------------------
  |  Branch (5529:21): [True: 0, False: 0]
  ------------------
 5530|      0|                    return (NULL);
 5531|       |
 5532|      0|                buf = xmlBufCreate();
 5533|      0|                if (buf == NULL)
  ------------------
  |  Branch (5533:21): [True: 0, False: 0]
  ------------------
 5534|      0|                    return (NULL);
 5535|      0|                xmlBufSetAllocationScheme(buf, XML_BUFFER_ALLOC_DOUBLEIT);
 5536|       |
 5537|      0|                xmlBufGetNodeContent(buf, cur);
 5538|       |
 5539|      0|                ret = xmlBufDetach(buf);
 5540|      0|                xmlBufFree(buf);
 5541|      0|                return (ret);
 5542|      0|            }
 5543|      0|        case XML_ENTITY_NODE:
  ------------------
  |  Branch (5543:9): [True: 0, False: 3.11k]
  ------------------
 5544|      0|        case XML_DOCUMENT_TYPE_NODE:
  ------------------
  |  Branch (5544:9): [True: 0, False: 3.11k]
  ------------------
 5545|      0|        case XML_NOTATION_NODE:
  ------------------
  |  Branch (5545:9): [True: 0, False: 3.11k]
  ------------------
 5546|      0|        case XML_DTD_NODE:
  ------------------
  |  Branch (5546:9): [True: 0, False: 3.11k]
  ------------------
 5547|      0|        case XML_XINCLUDE_START:
  ------------------
  |  Branch (5547:9): [True: 0, False: 3.11k]
  ------------------
 5548|      0|        case XML_XINCLUDE_END:
  ------------------
  |  Branch (5548:9): [True: 0, False: 3.11k]
  ------------------
 5549|      0|            return (NULL);
 5550|      0|        case XML_DOCUMENT_NODE:
  ------------------
  |  Branch (5550:9): [True: 0, False: 3.11k]
  ------------------
 5551|      0|        case XML_HTML_DOCUMENT_NODE: {
  ------------------
  |  Branch (5551:9): [True: 0, False: 3.11k]
  ------------------
 5552|      0|	    xmlBufPtr buf;
 5553|      0|	    xmlChar *ret;
 5554|       |
 5555|      0|	    buf = xmlBufCreate();
 5556|      0|	    if (buf == NULL)
  ------------------
  |  Branch (5556:10): [True: 0, False: 0]
  ------------------
 5557|      0|		return (NULL);
 5558|      0|            xmlBufSetAllocationScheme(buf, XML_BUFFER_ALLOC_DOUBLEIT);
 5559|       |
 5560|      0|	    xmlBufGetNodeContent(buf, (xmlNodePtr) cur);
 5561|       |
 5562|      0|	    ret = xmlBufDetach(buf);
 5563|      0|	    xmlBufFree(buf);
 5564|      0|	    return (ret);
 5565|      0|	}
 5566|      0|        case XML_NAMESPACE_DECL: {
  ------------------
  |  Branch (5566:9): [True: 0, False: 3.11k]
  ------------------
 5567|      0|	    xmlChar *tmp;
 5568|       |
 5569|      0|	    tmp = xmlStrdup(((xmlNsPtr) cur)->href);
 5570|      0|            return (tmp);
 5571|      0|	}
 5572|      0|        case XML_ELEMENT_DECL:
  ------------------
  |  Branch (5572:9): [True: 0, False: 3.11k]
  ------------------
 5573|       |            /* TODO !!! */
 5574|      0|            return (NULL);
 5575|      0|        case XML_ATTRIBUTE_DECL:
  ------------------
  |  Branch (5575:9): [True: 0, False: 3.11k]
  ------------------
 5576|       |            /* TODO !!! */
 5577|      0|            return (NULL);
 5578|      0|        case XML_ENTITY_DECL:
  ------------------
  |  Branch (5578:9): [True: 0, False: 3.11k]
  ------------------
 5579|       |            /* TODO !!! */
 5580|      0|            return (NULL);
 5581|      0|        case XML_CDATA_SECTION_NODE:
  ------------------
  |  Branch (5581:9): [True: 0, False: 3.11k]
  ------------------
 5582|      0|        case XML_TEXT_NODE:
  ------------------
  |  Branch (5582:9): [True: 0, False: 3.11k]
  ------------------
 5583|      0|            if (cur->content != NULL)
  ------------------
  |  Branch (5583:17): [True: 0, False: 0]
  ------------------
 5584|      0|                return (xmlStrdup(cur->content));
 5585|      0|            return (NULL);
 5586|  3.11k|    }
 5587|      0|    return (NULL);
 5588|  3.11k|}
xmlGetNsList:
 5850|     30|{
 5851|     30|    xmlNsPtr cur;
 5852|     30|    xmlNsPtr *ret = NULL;
 5853|     30|    int nbns = 0;
 5854|     30|    int maxns = 0;
 5855|     30|    int i;
 5856|       |
 5857|     30|    if ((node == NULL) || (node->type == XML_NAMESPACE_DECL))
  ------------------
  |  Branch (5857:9): [True: 0, False: 30]
  |  Branch (5857:27): [True: 0, False: 30]
  ------------------
 5858|      0|        return(NULL);
 5859|       |
 5860|    186|    while (node != NULL) {
  ------------------
  |  Branch (5860:12): [True: 156, False: 30]
  ------------------
 5861|    156|        if (node->type == XML_ELEMENT_NODE) {
  ------------------
  |  Branch (5861:13): [True: 126, False: 30]
  ------------------
 5862|    126|            cur = node->nsDef;
 5863|    176|            while (cur != NULL) {
  ------------------
  |  Branch (5863:20): [True: 50, False: 126]
  ------------------
 5864|     72|                for (i = 0; i < nbns; i++) {
  ------------------
  |  Branch (5864:29): [True: 22, False: 50]
  ------------------
 5865|     22|                    if ((cur->prefix == ret[i]->prefix) ||
  ------------------
  |  Branch (5865:25): [True: 0, False: 22]
  ------------------
 5866|     22|                        (xmlStrEqual(cur->prefix, ret[i]->prefix)))
  ------------------
  |  Branch (5866:25): [True: 0, False: 22]
  ------------------
 5867|      0|                        break;
 5868|     22|                }
 5869|     50|                if (i >= nbns) {
  ------------------
  |  Branch (5869:21): [True: 50, False: 0]
  ------------------
 5870|     50|                    if (nbns >= maxns) {
  ------------------
  |  Branch (5870:25): [True: 30, False: 20]
  ------------------
 5871|     30|                        xmlNsPtr *tmp;
 5872|       |
 5873|     30|                        maxns = maxns ? maxns * 2 : 10;
  ------------------
  |  Branch (5873:33): [True: 0, False: 30]
  ------------------
 5874|     30|                        tmp = (xmlNsPtr *) xmlRealloc(ret,
 5875|     30|                                                      (maxns + 1) *
 5876|     30|                                                      sizeof(xmlNsPtr));
 5877|     30|                        if (tmp == NULL) {
  ------------------
  |  Branch (5877:29): [True: 0, False: 30]
  ------------------
 5878|      0|			    xmlTreeErrMemory("getting namespace list");
 5879|      0|                            xmlFree(ret);
 5880|      0|                            return (NULL);
 5881|      0|                        }
 5882|     30|                        ret = tmp;
 5883|     30|                    }
 5884|     50|                    ret[nbns++] = cur;
 5885|     50|                    ret[nbns] = NULL;
 5886|     50|                }
 5887|       |
 5888|     50|                cur = cur->next;
 5889|     50|            }
 5890|    126|        }
 5891|    156|        node = node->parent;
 5892|    156|    }
 5893|     30|    return (ret);
 5894|     30|}
xmlSearchNs:
 5946|  1.09k|xmlSearchNs(xmlDocPtr doc, xmlNodePtr node, const xmlChar *nameSpace) {
 5947|       |
 5948|  1.09k|    xmlNsPtr cur;
 5949|  1.09k|    const xmlNode *orig = node;
 5950|       |
 5951|  1.09k|    if ((node == NULL) || (node->type == XML_NAMESPACE_DECL)) return(NULL);
  ------------------
  |  Branch (5951:9): [True: 0, False: 1.09k]
  |  Branch (5951:27): [True: 0, False: 1.09k]
  ------------------
 5952|  1.09k|    if ((nameSpace != NULL) &&
  ------------------
  |  Branch (5952:9): [True: 670, False: 426]
  ------------------
 5953|  1.09k|	(xmlStrEqual(nameSpace, (const xmlChar *)"xml"))) {
  ------------------
  |  Branch (5953:2): [True: 31, False: 639]
  ------------------
 5954|     31|	if ((doc == NULL) && (node->type == XML_ELEMENT_NODE)) {
  ------------------
  |  Branch (5954:6): [True: 0, False: 31]
  |  Branch (5954:23): [True: 0, False: 0]
  ------------------
 5955|       |	    /*
 5956|       |	     * The XML-1.0 namespace is normally held on the root
 5957|       |	     * element. In this case exceptionally create it on the
 5958|       |	     * node element.
 5959|       |	     */
 5960|      0|	    cur = (xmlNsPtr) xmlMalloc(sizeof(xmlNs));
 5961|      0|	    if (cur == NULL) {
  ------------------
  |  Branch (5961:10): [True: 0, False: 0]
  ------------------
 5962|      0|		xmlTreeErrMemory("searching namespace");
 5963|      0|		return(NULL);
 5964|      0|	    }
 5965|      0|	    memset(cur, 0, sizeof(xmlNs));
 5966|      0|	    cur->type = XML_LOCAL_NAMESPACE;
  ------------------
  |  |  370|      0|#define XML_LOCAL_NAMESPACE XML_NAMESPACE_DECL
  ------------------
 5967|      0|	    cur->href = xmlStrdup(XML_XML_NAMESPACE);
  ------------------
  |  |  143|      0|    (const xmlChar *) "http://www.w3.org/XML/1998/namespace"
  ------------------
 5968|      0|	    cur->prefix = xmlStrdup((const xmlChar *)"xml");
 5969|      0|	    cur->next = node->nsDef;
 5970|      0|	    node->nsDef = cur;
 5971|      0|	    return(cur);
 5972|      0|	}
 5973|     31|	if (doc == NULL) {
  ------------------
  |  Branch (5973:6): [True: 0, False: 31]
  ------------------
 5974|      0|	    doc = node->doc;
 5975|      0|	    if (doc == NULL)
  ------------------
  |  Branch (5975:10): [True: 0, False: 0]
  ------------------
 5976|      0|		return(NULL);
 5977|      0|	}
 5978|       |	/*
 5979|       |	* Return the XML namespace declaration held by the doc.
 5980|       |	*/
 5981|     31|	if (doc->oldNs == NULL)
  ------------------
  |  Branch (5981:6): [True: 19, False: 12]
  ------------------
 5982|     19|	    return(xmlTreeEnsureXMLDecl(doc));
 5983|     12|	else
 5984|     12|	    return(doc->oldNs);
 5985|     31|    }
 5986|  4.38k|    while (node != NULL) {
  ------------------
  |  Branch (5986:12): [True: 4.04k, False: 339]
  ------------------
 5987|  4.04k|	if ((node->type == XML_ENTITY_REF_NODE) ||
  ------------------
  |  Branch (5987:6): [True: 0, False: 4.04k]
  ------------------
 5988|  4.04k|	    (node->type == XML_ENTITY_NODE) ||
  ------------------
  |  Branch (5988:6): [True: 0, False: 4.04k]
  ------------------
 5989|  4.04k|	    (node->type == XML_ENTITY_DECL))
  ------------------
  |  Branch (5989:6): [True: 0, False: 4.04k]
  ------------------
 5990|      0|	    return(NULL);
 5991|  4.04k|	if (node->type == XML_ELEMENT_NODE) {
  ------------------
  |  Branch (5991:6): [True: 3.70k, False: 339]
  ------------------
 5992|  3.70k|	    cur = node->nsDef;
 5993|  4.25k|	    while (cur != NULL) {
  ------------------
  |  Branch (5993:13): [True: 912, False: 3.34k]
  ------------------
 5994|    912|		if ((cur->prefix == NULL) && (nameSpace == NULL) &&
  ------------------
  |  Branch (5994:7): [True: 113, False: 799]
  |  Branch (5994:32): [True: 68, False: 45]
  ------------------
 5995|    912|		    (cur->href != NULL))
  ------------------
  |  Branch (5995:7): [True: 68, False: 0]
  ------------------
 5996|     68|		    return(cur);
 5997|    844|		if ((cur->prefix != NULL) && (nameSpace != NULL) &&
  ------------------
  |  Branch (5997:7): [True: 799, False: 45]
  |  Branch (5997:32): [True: 413, False: 386]
  ------------------
 5998|    844|		    (cur->href != NULL) &&
  ------------------
  |  Branch (5998:7): [True: 413, False: 0]
  ------------------
 5999|    844|		    (xmlStrEqual(cur->prefix, nameSpace)))
  ------------------
  |  Branch (5999:7): [True: 292, False: 121]
  ------------------
 6000|    292|		    return(cur);
 6001|    552|		cur = cur->next;
 6002|    552|	    }
 6003|  3.34k|	    if (orig != node) {
  ------------------
  |  Branch (6003:10): [True: 2.27k, False: 1.06k]
  ------------------
 6004|  2.27k|	        cur = node->ns;
 6005|  2.27k|	        if (cur != NULL) {
  ------------------
  |  Branch (6005:14): [True: 2.27k, False: 0]
  ------------------
 6006|  2.27k|		    if ((cur->prefix == NULL) && (nameSpace == NULL) &&
  ------------------
  |  Branch (6006:11): [True: 122, False: 2.15k]
  |  Branch (6006:36): [True: 19, False: 103]
  ------------------
 6007|  2.27k|		        (cur->href != NULL))
  ------------------
  |  Branch (6007:11): [True: 19, False: 0]
  ------------------
 6008|     19|		        return(cur);
 6009|  2.25k|		    if ((cur->prefix != NULL) && (nameSpace != NULL) &&
  ------------------
  |  Branch (6009:11): [True: 2.15k, False: 103]
  |  Branch (6009:36): [True: 794, False: 1.36k]
  ------------------
 6010|  2.25k|		        (cur->href != NULL) &&
  ------------------
  |  Branch (6010:11): [True: 794, False: 0]
  ------------------
 6011|  2.25k|		        (xmlStrEqual(cur->prefix, nameSpace)))
  ------------------
  |  Branch (6011:11): [True: 347, False: 447]
  ------------------
 6012|    347|		        return(cur);
 6013|  2.25k|	        }
 6014|  2.27k|	    }
 6015|  3.34k|	}
 6016|  3.31k|	node = node->parent;
 6017|  3.31k|    }
 6018|    339|    return(NULL);
 6019|  1.06k|}
xmlHasProp:
 6583|      1|xmlHasProp(const xmlNode *node, const xmlChar *name) {
 6584|      1|    xmlAttrPtr prop;
 6585|      1|    xmlDocPtr doc;
 6586|       |
 6587|      1|    if ((node == NULL) || (node->type != XML_ELEMENT_NODE) || (name == NULL))
  ------------------
  |  Branch (6587:9): [True: 0, False: 1]
  |  Branch (6587:27): [True: 0, False: 1]
  |  Branch (6587:63): [True: 0, False: 1]
  ------------------
 6588|      0|        return(NULL);
 6589|       |    /*
 6590|       |     * Check on the properties attached to the node
 6591|       |     */
 6592|      1|    prop = node->properties;
 6593|      3|    while (prop != NULL) {
  ------------------
  |  Branch (6593:12): [True: 3, False: 0]
  ------------------
 6594|      3|        if (xmlStrEqual(prop->name, name))  {
  ------------------
  |  Branch (6594:13): [True: 1, False: 2]
  ------------------
 6595|      1|	    return(prop);
 6596|      1|        }
 6597|      2|	prop = prop->next;
 6598|      2|    }
 6599|      0|    if (!xmlCheckDTD) return(NULL);
  ------------------
  |  Branch (6599:9): [True: 0, False: 0]
  ------------------
 6600|       |
 6601|       |    /*
 6602|       |     * Check if there is a default declaration in the internal
 6603|       |     * or external subsets
 6604|       |     */
 6605|      0|    doc =  node->doc;
 6606|      0|    if (doc != NULL) {
  ------------------
  |  Branch (6606:9): [True: 0, False: 0]
  ------------------
 6607|      0|        xmlAttributePtr attrDecl;
 6608|      0|        if (doc->intSubset != NULL) {
  ------------------
  |  Branch (6608:13): [True: 0, False: 0]
  ------------------
 6609|      0|	    attrDecl = xmlGetDtdAttrDesc(doc->intSubset, node->name, name);
 6610|      0|	    if ((attrDecl == NULL) && (doc->extSubset != NULL))
  ------------------
  |  Branch (6610:10): [True: 0, False: 0]
  |  Branch (6610:32): [True: 0, False: 0]
  ------------------
 6611|      0|		attrDecl = xmlGetDtdAttrDesc(doc->extSubset, node->name, name);
 6612|      0|            if ((attrDecl != NULL) && (attrDecl->defaultValue != NULL))
  ------------------
  |  Branch (6612:17): [True: 0, False: 0]
  |  Branch (6612:39): [True: 0, False: 0]
  ------------------
 6613|       |              /* return attribute declaration only if a default value is given
 6614|       |                 (that includes #FIXED declarations) */
 6615|      0|		return((xmlAttrPtr) attrDecl);
 6616|      0|	}
 6617|      0|    }
 6618|      0|    return(NULL);
 6619|      0|}
xmlGetNoNsProp:
 6685|  2.24k|xmlGetNoNsProp(const xmlNode *node, const xmlChar *name) {
 6686|  2.24k|    xmlAttrPtr prop;
 6687|       |
 6688|  2.24k|    prop = xmlGetPropNodeInternal(node, name, NULL, xmlCheckDTD);
 6689|  2.24k|    if (prop == NULL)
  ------------------
  |  Branch (6689:9): [True: 1.76k, False: 484]
  ------------------
 6690|  1.76k|	return(NULL);
 6691|    484|    return(xmlGetPropNodeValueInternal(prop));
 6692|  2.24k|}
xmlGetNsProp:
 6710|     94|xmlGetNsProp(const xmlNode *node, const xmlChar *name, const xmlChar *nameSpace) {
 6711|     94|    xmlAttrPtr prop;
 6712|       |
 6713|     94|    prop = xmlGetPropNodeInternal(node, name, nameSpace, xmlCheckDTD);
 6714|     94|    if (prop == NULL)
  ------------------
  |  Branch (6714:9): [True: 94, False: 0]
  ------------------
 6715|     94|	return(NULL);
 6716|      0|    return(xmlGetPropNodeValueInternal(prop));
 6717|     94|}
tree.c:xmlGetLineNoInternal:
 4579|     17|{
 4580|     17|    long result = -1;
 4581|       |
 4582|     17|    if (depth >= 5)
  ------------------
  |  Branch (4582:9): [True: 0, False: 17]
  ------------------
 4583|      0|        return(-1);
 4584|       |
 4585|     17|    if (!node)
  ------------------
  |  Branch (4585:9): [True: 0, False: 17]
  ------------------
 4586|      0|        return result;
 4587|     17|    if ((node->type == XML_ELEMENT_NODE) ||
  ------------------
  |  Branch (4587:9): [True: 17, False: 0]
  ------------------
 4588|     17|        (node->type == XML_TEXT_NODE) ||
  ------------------
  |  Branch (4588:9): [True: 0, False: 0]
  ------------------
 4589|     17|	(node->type == XML_COMMENT_NODE) ||
  ------------------
  |  Branch (4589:2): [True: 0, False: 0]
  ------------------
 4590|     17|	(node->type == XML_PI_NODE)) {
  ------------------
  |  Branch (4590:2): [True: 0, False: 0]
  ------------------
 4591|     17|	if (node->line == 65535) {
  ------------------
  |  Branch (4591:6): [True: 0, False: 17]
  ------------------
 4592|      0|	    if ((node->type == XML_TEXT_NODE) && (node->psvi != NULL))
  ------------------
  |  Branch (4592:10): [True: 0, False: 0]
  |  Branch (4592:43): [True: 0, False: 0]
  ------------------
 4593|      0|	        result = (long) (ptrdiff_t) node->psvi;
 4594|      0|	    else if ((node->type == XML_ELEMENT_NODE) &&
  ------------------
  |  Branch (4594:15): [True: 0, False: 0]
  ------------------
 4595|      0|	             (node->children != NULL))
  ------------------
  |  Branch (4595:15): [True: 0, False: 0]
  ------------------
 4596|      0|	        result = xmlGetLineNoInternal(node->children, depth + 1);
 4597|      0|	    else if (node->next != NULL)
  ------------------
  |  Branch (4597:15): [True: 0, False: 0]
  ------------------
 4598|      0|	        result = xmlGetLineNoInternal(node->next, depth + 1);
 4599|      0|	    else if (node->prev != NULL)
  ------------------
  |  Branch (4599:15): [True: 0, False: 0]
  ------------------
 4600|      0|	        result = xmlGetLineNoInternal(node->prev, depth + 1);
 4601|      0|	}
 4602|     17|	if ((result == -1) || (result == 65535))
  ------------------
  |  Branch (4602:6): [True: 17, False: 0]
  |  Branch (4602:24): [True: 0, False: 0]
  ------------------
 4603|     17|	    result = (long) node->line;
 4604|     17|    } else if ((node->prev != NULL) &&
  ------------------
  |  Branch (4604:16): [True: 0, False: 0]
  ------------------
 4605|      0|             ((node->prev->type == XML_ELEMENT_NODE) ||
  ------------------
  |  Branch (4605:15): [True: 0, False: 0]
  ------------------
 4606|      0|	      (node->prev->type == XML_TEXT_NODE) ||
  ------------------
  |  Branch (4606:8): [True: 0, False: 0]
  ------------------
 4607|      0|	      (node->prev->type == XML_COMMENT_NODE) ||
  ------------------
  |  Branch (4607:8): [True: 0, False: 0]
  ------------------
 4608|      0|	      (node->prev->type == XML_PI_NODE)))
  ------------------
  |  Branch (4608:8): [True: 0, False: 0]
  ------------------
 4609|      0|        result = xmlGetLineNoInternal(node->prev, depth + 1);
 4610|      0|    else if ((node->parent != NULL) &&
  ------------------
  |  Branch (4610:14): [True: 0, False: 0]
  ------------------
 4611|      0|             (node->parent->type == XML_ELEMENT_NODE))
  ------------------
  |  Branch (4611:14): [True: 0, False: 0]
  ------------------
 4612|      0|        result = xmlGetLineNoInternal(node->parent, depth + 1);
 4613|       |
 4614|     17|    return result;
 4615|     17|}
tree.c:xmlTreeEnsureXMLDecl:
 5907|     19|{
 5908|     19|    if (doc == NULL)
  ------------------
  |  Branch (5908:9): [True: 0, False: 19]
  ------------------
 5909|      0|	return (NULL);
 5910|     19|    if (doc->oldNs != NULL)
  ------------------
  |  Branch (5910:9): [True: 0, False: 19]
  ------------------
 5911|      0|	return (doc->oldNs);
 5912|     19|    {
 5913|     19|	xmlNsPtr ns;
 5914|     19|	ns = (xmlNsPtr) xmlMalloc(sizeof(xmlNs));
 5915|     19|	if (ns == NULL) {
  ------------------
  |  Branch (5915:6): [True: 0, False: 19]
  ------------------
 5916|      0|	    xmlTreeErrMemory(
 5917|      0|		"allocating the XML namespace");
 5918|      0|	    return (NULL);
 5919|      0|	}
 5920|     19|	memset(ns, 0, sizeof(xmlNs));
 5921|     19|	ns->type = XML_LOCAL_NAMESPACE;
  ------------------
  |  |  370|     19|#define XML_LOCAL_NAMESPACE XML_NAMESPACE_DECL
  ------------------
 5922|     19|	ns->href = xmlStrdup(XML_XML_NAMESPACE);
  ------------------
  |  |  143|     19|    (const xmlChar *) "http://www.w3.org/XML/1998/namespace"
  ------------------
 5923|     19|	ns->prefix = xmlStrdup((const xmlChar *)"xml");
 5924|     19|	doc->oldNs = ns;
 5925|     19|	return (ns);
 5926|     19|    }
 5927|     19|}
tree.c:xmlGetPropNodeValueInternal:
 6538|  3.59k|{
 6539|  3.59k|    if (prop == NULL)
  ------------------
  |  Branch (6539:9): [True: 0, False: 3.59k]
  ------------------
 6540|      0|	return(NULL);
 6541|  3.59k|    if (prop->type == XML_ATTRIBUTE_NODE) {
  ------------------
  |  Branch (6541:9): [True: 3.59k, False: 0]
  ------------------
 6542|       |	/*
 6543|       |	* Note that we return at least the empty string.
 6544|       |	*   TODO: Do we really always want that?
 6545|       |	*/
 6546|  3.59k|	if (prop->children != NULL) {
  ------------------
  |  Branch (6546:6): [True: 3.59k, False: 0]
  ------------------
 6547|  3.59k|	    if ((prop->children->next == NULL) &&
  ------------------
  |  Branch (6547:10): [True: 3.59k, False: 0]
  ------------------
 6548|  3.59k|		((prop->children->type == XML_TEXT_NODE) ||
  ------------------
  |  Branch (6548:4): [True: 3.59k, False: 0]
  ------------------
 6549|  3.59k|		(prop->children->type == XML_CDATA_SECTION_NODE)))
  ------------------
  |  Branch (6549:3): [True: 0, False: 0]
  ------------------
 6550|  3.59k|	    {
 6551|       |		/*
 6552|       |		* Optimization for the common case: only 1 text node.
 6553|       |		*/
 6554|  3.59k|		return(xmlStrdup(prop->children->content));
 6555|  3.59k|	    } else {
 6556|      0|		xmlChar *ret;
 6557|       |
 6558|      0|		ret = xmlNodeListGetString(prop->doc, prop->children, 1);
 6559|      0|		if (ret != NULL)
  ------------------
  |  Branch (6559:7): [True: 0, False: 0]
  ------------------
 6560|      0|		    return(ret);
 6561|      0|	    }
 6562|  3.59k|	}
 6563|      0|	return(xmlStrdup((xmlChar *)""));
 6564|  3.59k|    } else if (prop->type == XML_ATTRIBUTE_DECL) {
  ------------------
  |  Branch (6564:16): [True: 0, False: 0]
  ------------------
 6565|      0|	return(xmlStrdup(((xmlAttributePtr)prop)->defaultValue));
 6566|      0|    }
 6567|      0|    return(NULL);
 6568|  3.59k|}
tree.c:xmlGetPropNodeInternal:
 6412|  2.33k|{
 6413|  2.33k|    xmlAttrPtr prop;
 6414|       |
 6415|       |    /* Avoid unused variable warning if features are disabled. */
 6416|  2.33k|    (void) useDTD;
 6417|       |
 6418|  2.33k|    if ((node == NULL) || (node->type != XML_ELEMENT_NODE) || (name == NULL))
  ------------------
  |  Branch (6418:9): [True: 0, False: 2.33k]
  |  Branch (6418:27): [True: 0, False: 2.33k]
  |  Branch (6418:63): [True: 0, False: 2.33k]
  ------------------
 6419|      0|	return(NULL);
 6420|       |
 6421|  2.33k|    if (node->properties != NULL) {
  ------------------
  |  Branch (6421:9): [True: 2.21k, False: 125]
  ------------------
 6422|  2.21k|	prop = node->properties;
 6423|  2.21k|	if (nsName == NULL) {
  ------------------
  |  Branch (6423:6): [True: 2.12k, False: 92]
  ------------------
 6424|       |	    /*
 6425|       |	    * We want the attr to be in no namespace.
 6426|       |	    */
 6427|  3.37k|	    do {
 6428|  3.37k|		if ((prop->ns == NULL) && xmlStrEqual(prop->name, name)) {
  ------------------
  |  Branch (6428:7): [True: 3.37k, False: 8]
  |  Branch (6428:29): [True: 484, False: 2.88k]
  ------------------
 6429|    484|		    return(prop);
 6430|    484|		}
 6431|  2.89k|		prop = prop->next;
 6432|  2.89k|	    } while (prop != NULL);
  ------------------
  |  Branch (6432:15): [True: 1.25k, False: 1.63k]
  ------------------
 6433|  2.12k|	} else {
 6434|       |	    /*
 6435|       |	    * We want the attr to be in the specified namespace.
 6436|       |	    */
 6437|    163|	    do {
 6438|    163|		if ((prop->ns != NULL) && xmlStrEqual(prop->name, name) &&
  ------------------
  |  Branch (6438:7): [True: 5, False: 158]
  |  Branch (6438:29): [True: 0, False: 5]
  ------------------
 6439|    163|		    ((prop->ns->href == nsName) ||
  ------------------
  |  Branch (6439:8): [True: 0, False: 0]
  ------------------
 6440|      0|		     xmlStrEqual(prop->ns->href, nsName)))
  ------------------
  |  Branch (6440:8): [True: 0, False: 0]
  ------------------
 6441|      0|		{
 6442|      0|		    return(prop);
 6443|      0|		}
 6444|    163|		prop = prop->next;
 6445|    163|	    } while (prop != NULL);
  ------------------
  |  Branch (6445:15): [True: 71, False: 92]
  ------------------
 6446|     92|	}
 6447|  2.21k|    }
 6448|       |
 6449|  1.85k|#ifdef LIBXML_TREE_ENABLED
 6450|  1.85k|    if (! useDTD)
  ------------------
  |  Branch (6450:9): [True: 0, False: 1.85k]
  ------------------
 6451|      0|	return(NULL);
 6452|       |    /*
 6453|       |     * Check if there is a default/fixed attribute declaration in
 6454|       |     * the internal or external subset.
 6455|       |     */
 6456|  1.85k|    if ((node->doc != NULL) && (node->doc->intSubset != NULL)) {
  ------------------
  |  Branch (6456:9): [True: 1.85k, False: 0]
  |  Branch (6456:32): [True: 0, False: 1.85k]
  ------------------
 6457|      0|	xmlDocPtr doc = node->doc;
 6458|      0|	xmlAttributePtr attrDecl = NULL;
 6459|      0|	xmlChar *elemQName, *tmpstr = NULL;
 6460|       |
 6461|       |	/*
 6462|       |	* We need the QName of the element for the DTD-lookup.
 6463|       |	*/
 6464|      0|	if ((node->ns != NULL) && (node->ns->prefix != NULL)) {
  ------------------
  |  Branch (6464:6): [True: 0, False: 0]
  |  Branch (6464:28): [True: 0, False: 0]
  ------------------
 6465|      0|	    tmpstr = xmlStrdup(node->ns->prefix);
 6466|      0|	    tmpstr = xmlStrcat(tmpstr, BAD_CAST ":");
  ------------------
  |  |   35|      0|#define BAD_CAST (xmlChar *)
  ------------------
 6467|      0|	    tmpstr = xmlStrcat(tmpstr, node->name);
 6468|      0|	    if (tmpstr == NULL)
  ------------------
  |  Branch (6468:10): [True: 0, False: 0]
  ------------------
 6469|      0|		return(NULL);
 6470|      0|	    elemQName = tmpstr;
 6471|      0|	} else
 6472|      0|	    elemQName = (xmlChar *) node->name;
 6473|      0|	if (nsName == NULL) {
  ------------------
  |  Branch (6473:6): [True: 0, False: 0]
  ------------------
 6474|       |	    /*
 6475|       |	    * The common and nice case: Attr in no namespace.
 6476|       |	    */
 6477|      0|	    attrDecl = xmlGetDtdQAttrDesc(doc->intSubset,
 6478|      0|		elemQName, name, NULL);
 6479|      0|	    if ((attrDecl == NULL) && (doc->extSubset != NULL)) {
  ------------------
  |  Branch (6479:10): [True: 0, False: 0]
  |  Branch (6479:32): [True: 0, False: 0]
  ------------------
 6480|      0|		attrDecl = xmlGetDtdQAttrDesc(doc->extSubset,
 6481|      0|		    elemQName, name, NULL);
 6482|      0|	    }
 6483|      0|        } else if (xmlStrEqual(nsName, XML_XML_NAMESPACE)) {
  ------------------
  |  |  143|      0|    (const xmlChar *) "http://www.w3.org/XML/1998/namespace"
  ------------------
  |  Branch (6483:20): [True: 0, False: 0]
  ------------------
 6484|       |	    /*
 6485|       |	    * The XML namespace must be bound to prefix 'xml'.
 6486|       |	    */
 6487|      0|	    attrDecl = xmlGetDtdQAttrDesc(doc->intSubset,
 6488|      0|		elemQName, name, BAD_CAST "xml");
  ------------------
  |  |   35|      0|#define BAD_CAST (xmlChar *)
  ------------------
 6489|      0|	    if ((attrDecl == NULL) && (doc->extSubset != NULL)) {
  ------------------
  |  Branch (6489:10): [True: 0, False: 0]
  |  Branch (6489:32): [True: 0, False: 0]
  ------------------
 6490|      0|		attrDecl = xmlGetDtdQAttrDesc(doc->extSubset,
 6491|      0|		    elemQName, name, BAD_CAST "xml");
  ------------------
  |  |   35|      0|#define BAD_CAST (xmlChar *)
  ------------------
 6492|      0|	    }
 6493|      0|	} else {
 6494|      0|	    xmlNsPtr *nsList, *cur;
 6495|       |
 6496|       |	    /*
 6497|       |	    * The ugly case: Search using the prefixes of in-scope
 6498|       |	    * ns-decls corresponding to @nsName.
 6499|       |	    */
 6500|      0|	    nsList = xmlGetNsList(node->doc, node);
 6501|      0|	    if (nsList == NULL) {
  ------------------
  |  Branch (6501:10): [True: 0, False: 0]
  ------------------
 6502|      0|		if (tmpstr != NULL)
  ------------------
  |  Branch (6502:7): [True: 0, False: 0]
  ------------------
 6503|      0|		    xmlFree(tmpstr);
 6504|      0|		return(NULL);
 6505|      0|	    }
 6506|      0|	    cur = nsList;
 6507|      0|	    while (*cur != NULL) {
  ------------------
  |  Branch (6507:13): [True: 0, False: 0]
  ------------------
 6508|      0|		if (xmlStrEqual((*cur)->href, nsName)) {
  ------------------
  |  Branch (6508:7): [True: 0, False: 0]
  ------------------
 6509|      0|		    attrDecl = xmlGetDtdQAttrDesc(doc->intSubset, elemQName,
 6510|      0|			name, (*cur)->prefix);
 6511|      0|		    if (attrDecl)
  ------------------
  |  Branch (6511:11): [True: 0, False: 0]
  ------------------
 6512|      0|			break;
 6513|      0|		    if (doc->extSubset != NULL) {
  ------------------
  |  Branch (6513:11): [True: 0, False: 0]
  ------------------
 6514|      0|			attrDecl = xmlGetDtdQAttrDesc(doc->extSubset, elemQName,
 6515|      0|			    name, (*cur)->prefix);
 6516|      0|			if (attrDecl)
  ------------------
  |  Branch (6516:8): [True: 0, False: 0]
  ------------------
 6517|      0|			    break;
 6518|      0|		    }
 6519|      0|		}
 6520|      0|		cur++;
 6521|      0|	    }
 6522|      0|	    xmlFree(nsList);
 6523|      0|	}
 6524|      0|	if (tmpstr != NULL)
  ------------------
  |  Branch (6524:6): [True: 0, False: 0]
  ------------------
 6525|      0|	    xmlFree(tmpstr);
 6526|       |	/*
 6527|       |	* Only default/fixed attrs are relevant.
 6528|       |	*/
 6529|      0|	if ((attrDecl != NULL) && (attrDecl->defaultValue != NULL))
  ------------------
  |  Branch (6529:6): [True: 0, False: 0]
  |  Branch (6529:28): [True: 0, False: 0]
  ------------------
 6530|      0|	    return((xmlAttrPtr) attrDecl);
 6531|      0|    }
 6532|  1.85k|#endif /* LIBXML_TREE_ENABLED */
 6533|  1.85k|    return(NULL);
 6534|  1.85k|}

xmlParseURI:
  947|  1.09k|xmlParseURI(const char *str) {
  948|  1.09k|    xmlURIPtr uri;
  949|  1.09k|    int ret;
  950|       |
  951|  1.09k|    if (str == NULL)
  ------------------
  |  Branch (951:9): [True: 0, False: 1.09k]
  ------------------
  952|      0|	return(NULL);
  953|  1.09k|    uri = xmlCreateURI();
  954|  1.09k|    if (uri != NULL) {
  ------------------
  |  Branch (954:9): [True: 1.09k, False: 0]
  ------------------
  955|  1.09k|	ret = xmlParse3986URIReference(uri, str);
  956|  1.09k|        if (ret) {
  ------------------
  |  Branch (956:13): [True: 5, False: 1.08k]
  ------------------
  957|      5|	    xmlFreeURI(uri);
  958|      5|	    return(NULL);
  959|      5|	}
  960|  1.09k|    }
  961|  1.08k|    return(uri);
  962|  1.09k|}
xmlParseURIReference:
  977|     94|xmlParseURIReference(xmlURIPtr uri, const char *str) {
  978|     94|    return(xmlParse3986URIReference(uri, str));
  979|     94|}
xmlCreateURI:
 1027|  1.23k|xmlCreateURI(void) {
 1028|  1.23k|    xmlURIPtr ret;
 1029|       |
 1030|  1.23k|    ret = (xmlURIPtr) xmlMalloc(sizeof(xmlURI));
 1031|  1.23k|    if (ret == NULL) {
  ------------------
  |  Branch (1031:9): [True: 0, False: 1.23k]
  ------------------
 1032|      0|        xmlURIErrMemory("creating URI structure\n");
 1033|      0|	return(NULL);
 1034|      0|    }
 1035|  1.23k|    memset(ret, 0, sizeof(xmlURI));
 1036|  1.23k|    ret->port = PORT_EMPTY;
  ------------------
  |  |   37|  1.23k|#define PORT_EMPTY           0
  ------------------
 1037|  1.23k|    return(ret);
 1038|  1.23k|}
xmlSaveUri:
 1074|     48|xmlSaveUri(xmlURIPtr uri) {
 1075|     48|    xmlChar *ret = NULL;
 1076|     48|    xmlChar *temp;
 1077|     48|    const char *p;
 1078|     48|    int len;
 1079|     48|    int max;
 1080|       |
 1081|     48|    if (uri == NULL) return(NULL);
  ------------------
  |  Branch (1081:9): [True: 0, False: 48]
  ------------------
 1082|       |
 1083|       |
 1084|     48|    max = 80;
 1085|     48|    ret = (xmlChar *) xmlMallocAtomic(max + 1);
 1086|     48|    if (ret == NULL) {
  ------------------
  |  Branch (1086:9): [True: 0, False: 48]
  ------------------
 1087|      0|        xmlURIErrMemory("saving URI\n");
 1088|      0|	return(NULL);
 1089|      0|    }
 1090|     48|    len = 0;
 1091|       |
 1092|     48|    if (uri->scheme != NULL) {
  ------------------
  |  Branch (1092:9): [True: 0, False: 48]
  ------------------
 1093|      0|	p = uri->scheme;
 1094|      0|	while (*p != 0) {
  ------------------
  |  Branch (1094:9): [True: 0, False: 0]
  ------------------
 1095|      0|	    if (len >= max) {
  ------------------
  |  Branch (1095:10): [True: 0, False: 0]
  ------------------
 1096|      0|                temp = xmlSaveUriRealloc(ret, &max);
 1097|      0|                if (temp == NULL) goto mem_error;
  ------------------
  |  Branch (1097:21): [True: 0, False: 0]
  ------------------
 1098|      0|		ret = temp;
 1099|      0|	    }
 1100|      0|	    ret[len++] = *p++;
 1101|      0|	}
 1102|      0|	if (len >= max) {
  ------------------
  |  Branch (1102:6): [True: 0, False: 0]
  ------------------
 1103|      0|            temp = xmlSaveUriRealloc(ret, &max);
 1104|      0|            if (temp == NULL) goto mem_error;
  ------------------
  |  Branch (1104:17): [True: 0, False: 0]
  ------------------
 1105|      0|            ret = temp;
 1106|      0|	}
 1107|      0|	ret[len++] = ':';
 1108|      0|    }
 1109|     48|    if (uri->opaque != NULL) {
  ------------------
  |  Branch (1109:9): [True: 0, False: 48]
  ------------------
 1110|      0|	p = uri->opaque;
 1111|      0|	while (*p != 0) {
  ------------------
  |  Branch (1111:9): [True: 0, False: 0]
  ------------------
 1112|      0|	    if (len + 3 >= max) {
  ------------------
  |  Branch (1112:10): [True: 0, False: 0]
  ------------------
 1113|      0|                temp = xmlSaveUriRealloc(ret, &max);
 1114|      0|                if (temp == NULL) goto mem_error;
  ------------------
  |  Branch (1114:21): [True: 0, False: 0]
  ------------------
 1115|      0|                ret = temp;
 1116|      0|	    }
 1117|      0|	    if (IS_RESERVED(*(p)) || IS_UNRESERVED(*(p)))
  ------------------
  |  |  116|      0|#define IS_RESERVED(x) (((x) == ';') || ((x) == '/') || ((x) == '?') || \
  |  |  ------------------
  |  |  |  Branch (116:25): [True: 0, False: 0]
  |  |  |  Branch (116:41): [True: 0, False: 0]
  |  |  |  Branch (116:57): [True: 0, False: 0]
  |  |  ------------------
  |  |  117|      0|        ((x) == ':') || ((x) == '@') || ((x) == '&') || ((x) == '=') || \
  |  |  ------------------
  |  |  |  Branch (117:9): [True: 0, False: 0]
  |  |  |  Branch (117:25): [True: 0, False: 0]
  |  |  |  Branch (117:41): [True: 0, False: 0]
  |  |  |  Branch (117:57): [True: 0, False: 0]
  |  |  ------------------
  |  |  118|      0|        ((x) == '+') || ((x) == '$') || ((x) == ',') || ((x) == '[') || \
  |  |  ------------------
  |  |  |  Branch (118:9): [True: 0, False: 0]
  |  |  |  Branch (118:25): [True: 0, False: 0]
  |  |  |  Branch (118:41): [True: 0, False: 0]
  |  |  |  Branch (118:57): [True: 0, False: 0]
  |  |  ------------------
  |  |  119|      0|        ((x) == ']'))
  |  |  ------------------
  |  |  |  Branch (119:9): [True: 0, False: 0]
  |  |  ------------------
  ------------------
              	    if (IS_RESERVED(*(p)) || IS_UNRESERVED(*(p)))
  ------------------
  |  |  125|      0|#define IS_UNRESERVED(x) (IS_ALPHANUM(x) || IS_MARK(x))
  |  |  ------------------
  |  |  |  |   93|      0|#define IS_ALPHANUM(x) (IS_ALPHA(x) || IS_DIGIT(x))
  |  |  |  |  ------------------
  |  |  |  |  |  |   63|      0|#define IS_ALPHA(x) (IS_LOWALPHA(x) || IS_UPALPHA(x))
  |  |  |  |  |  |  ------------------
  |  |  |  |  |  |  |  |   72|      0|#define IS_LOWALPHA(x) (((x) >= 'a') && ((x) <= 'z'))
  |  |  |  |  |  |  |  |  ------------------
  |  |  |  |  |  |  |  |  |  Branch (72:25): [True: 0, False: 0]
  |  |  |  |  |  |  |  |  |  Branch (72:41): [True: 0, False: 0]
  |  |  |  |  |  |  |  |  ------------------
  |  |  |  |  |  |  ------------------
  |  |  |  |  |  |               #define IS_ALPHA(x) (IS_LOWALPHA(x) || IS_UPALPHA(x))
  |  |  |  |  |  |  ------------------
  |  |  |  |  |  |  |  |   79|      0|#define IS_UPALPHA(x) (((x) >= 'A') && ((x) <= 'Z'))
  |  |  |  |  |  |  |  |  ------------------
  |  |  |  |  |  |  |  |  |  Branch (79:24): [True: 0, False: 0]
  |  |  |  |  |  |  |  |  |  Branch (79:40): [True: 0, False: 0]
  |  |  |  |  |  |  |  |  ------------------
  |  |  |  |  |  |  ------------------
  |  |  |  |  ------------------
  |  |  |  |               #define IS_ALPHANUM(x) (IS_ALPHA(x) || IS_DIGIT(x))
  |  |  |  |  ------------------
  |  |  |  |  |  |   87|      0|#define IS_DIGIT(x) (((x) >= '0') && ((x) <= '9'))
  |  |  |  |  |  |  ------------------
  |  |  |  |  |  |  |  Branch (87:22): [True: 0, False: 0]
  |  |  |  |  |  |  |  Branch (87:38): [True: 0, False: 0]
  |  |  |  |  |  |  ------------------
  |  |  |  |  ------------------
  |  |  ------------------
  |  |               #define IS_UNRESERVED(x) (IS_ALPHANUM(x) || IS_MARK(x))
  |  |  ------------------
  |  |  |  |   99|      0|#define IS_MARK(x) (((x) == '-') || ((x) == '_') || ((x) == '.') ||     \
  |  |  |  |  ------------------
  |  |  |  |  |  Branch (99:21): [True: 0, False: 0]
  |  |  |  |  |  Branch (99:37): [True: 0, False: 0]
  |  |  |  |  |  Branch (99:53): [True: 0, False: 0]
  |  |  |  |  ------------------
  |  |  |  |  100|      0|    ((x) == '!') || ((x) == '~') || ((x) == '*') || ((x) == '\'') ||    \
  |  |  |  |  ------------------
  |  |  |  |  |  Branch (100:5): [True: 0, False: 0]
  |  |  |  |  |  Branch (100:21): [True: 0, False: 0]
  |  |  |  |  |  Branch (100:37): [True: 0, False: 0]
  |  |  |  |  |  Branch (100:53): [True: 0, False: 0]
  |  |  |  |  ------------------
  |  |  |  |  101|      0|    ((x) == '(') || ((x) == ')'))
  |  |  |  |  ------------------
  |  |  |  |  |  Branch (101:5): [True: 0, False: 0]
  |  |  |  |  |  Branch (101:21): [True: 0, False: 0]
  |  |  |  |  ------------------
  |  |  ------------------
  ------------------
 1118|      0|		ret[len++] = *p++;
 1119|      0|	    else {
 1120|      0|		int val = *(unsigned char *)p++;
 1121|      0|		int hi = val / 0x10, lo = val % 0x10;
 1122|      0|		ret[len++] = '%';
 1123|      0|		ret[len++] = hi + (hi > 9? 'A'-10 : '0');
  ------------------
  |  Branch (1123:22): [True: 0, False: 0]
  ------------------
 1124|      0|		ret[len++] = lo + (lo > 9? 'A'-10 : '0');
  ------------------
  |  Branch (1124:22): [True: 0, False: 0]
  ------------------
 1125|      0|	    }
 1126|      0|	}
 1127|     48|    } else {
 1128|     48|	if ((uri->server != NULL) || (uri->port != PORT_EMPTY)) {
  ------------------
  |  |   37|     48|#define PORT_EMPTY           0
  ------------------
  |  Branch (1128:6): [True: 0, False: 48]
  |  Branch (1128:31): [True: 0, False: 48]
  ------------------
 1129|      0|	    if (len + 3 >= max) {
  ------------------
  |  Branch (1129:10): [True: 0, False: 0]
  ------------------
 1130|      0|                temp = xmlSaveUriRealloc(ret, &max);
 1131|      0|                if (temp == NULL) goto mem_error;
  ------------------
  |  Branch (1131:21): [True: 0, False: 0]
  ------------------
 1132|      0|                ret = temp;
 1133|      0|	    }
 1134|      0|	    ret[len++] = '/';
 1135|      0|	    ret[len++] = '/';
 1136|      0|	    if (uri->user != NULL) {
  ------------------
  |  Branch (1136:10): [True: 0, False: 0]
  ------------------
 1137|      0|		p = uri->user;
 1138|      0|		while (*p != 0) {
  ------------------
  |  Branch (1138:10): [True: 0, False: 0]
  ------------------
 1139|      0|		    if (len + 3 >= max) {
  ------------------
  |  Branch (1139:11): [True: 0, False: 0]
  ------------------
 1140|      0|                        temp = xmlSaveUriRealloc(ret, &max);
 1141|      0|                        if (temp == NULL) goto mem_error;
  ------------------
  |  Branch (1141:29): [True: 0, False: 0]
  ------------------
 1142|      0|                        ret = temp;
 1143|      0|		    }
 1144|      0|		    if ((IS_UNRESERVED(*(p))) ||
  ------------------
  |  |  125|      0|#define IS_UNRESERVED(x) (IS_ALPHANUM(x) || IS_MARK(x))
  |  |  ------------------
  |  |  |  |   93|      0|#define IS_ALPHANUM(x) (IS_ALPHA(x) || IS_DIGIT(x))
  |  |  |  |  ------------------
  |  |  |  |  |  |   63|      0|#define IS_ALPHA(x) (IS_LOWALPHA(x) || IS_UPALPHA(x))
  |  |  |  |  |  |  ------------------
  |  |  |  |  |  |  |  |   72|      0|#define IS_LOWALPHA(x) (((x) >= 'a') && ((x) <= 'z'))
  |  |  |  |  |  |  |  |  ------------------
  |  |  |  |  |  |  |  |  |  Branch (72:25): [True: 0, False: 0]
  |  |  |  |  |  |  |  |  |  Branch (72:41): [True: 0, False: 0]
  |  |  |  |  |  |  |  |  ------------------
  |  |  |  |  |  |  ------------------
  |  |  |  |  |  |               #define IS_ALPHA(x) (IS_LOWALPHA(x) || IS_UPALPHA(x))
  |  |  |  |  |  |  ------------------
  |  |  |  |  |  |  |  |   79|      0|#define IS_UPALPHA(x) (((x) >= 'A') && ((x) <= 'Z'))
  |  |  |  |  |  |  |  |  ------------------
  |  |  |  |  |  |  |  |  |  Branch (79:24): [True: 0, False: 0]
  |  |  |  |  |  |  |  |  |  Branch (79:40): [True: 0, False: 0]
  |  |  |  |  |  |  |  |  ------------------
  |  |  |  |  |  |  ------------------
  |  |  |  |  ------------------
  |  |  |  |               #define IS_ALPHANUM(x) (IS_ALPHA(x) || IS_DIGIT(x))
  |  |  |  |  ------------------
  |  |  |  |  |  |   87|      0|#define IS_DIGIT(x) (((x) >= '0') && ((x) <= '9'))
  |  |  |  |  |  |  ------------------
  |  |  |  |  |  |  |  Branch (87:22): [True: 0, False: 0]
  |  |  |  |  |  |  |  Branch (87:38): [True: 0, False: 0]
  |  |  |  |  |  |  ------------------
  |  |  |  |  ------------------
  |  |  ------------------
  |  |               #define IS_UNRESERVED(x) (IS_ALPHANUM(x) || IS_MARK(x))
  |  |  ------------------
  |  |  |  |   99|      0|#define IS_MARK(x) (((x) == '-') || ((x) == '_') || ((x) == '.') ||     \
  |  |  |  |  ------------------
  |  |  |  |  |  Branch (99:21): [True: 0, False: 0]
  |  |  |  |  |  Branch (99:37): [True: 0, False: 0]
  |  |  |  |  |  Branch (99:53): [True: 0, False: 0]
  |  |  |  |  ------------------
  |  |  |  |  100|      0|    ((x) == '!') || ((x) == '~') || ((x) == '*') || ((x) == '\'') ||    \
  |  |  |  |  ------------------
  |  |  |  |  |  Branch (100:5): [True: 0, False: 0]
  |  |  |  |  |  Branch (100:21): [True: 0, False: 0]
  |  |  |  |  |  Branch (100:37): [True: 0, False: 0]
  |  |  |  |  |  Branch (100:53): [True: 0, False: 0]
  |  |  |  |  ------------------
  |  |  |  |  101|      0|    ((x) == '(') || ((x) == ')'))
  |  |  |  |  ------------------
  |  |  |  |  |  Branch (101:5): [True: 0, False: 0]
  |  |  |  |  |  Branch (101:21): [True: 0, False: 0]
  |  |  |  |  ------------------
  |  |  ------------------
  ------------------
 1145|      0|			((*(p) == ';')) || ((*(p) == ':')) ||
  ------------------
  |  Branch (1145:4): [True: 0, False: 0]
  |  Branch (1145:23): [True: 0, False: 0]
  ------------------
 1146|      0|			((*(p) == '&')) || ((*(p) == '=')) ||
  ------------------
  |  Branch (1146:4): [True: 0, False: 0]
  |  Branch (1146:23): [True: 0, False: 0]
  ------------------
 1147|      0|			((*(p) == '+')) || ((*(p) == '$')) ||
  ------------------
  |  Branch (1147:4): [True: 0, False: 0]
  |  Branch (1147:23): [True: 0, False: 0]
  ------------------
 1148|      0|			((*(p) == ',')))
  ------------------
  |  Branch (1148:4): [True: 0, False: 0]
  ------------------
 1149|      0|			ret[len++] = *p++;
 1150|      0|		    else {
 1151|      0|			int val = *(unsigned char *)p++;
 1152|      0|			int hi = val / 0x10, lo = val % 0x10;
 1153|      0|			ret[len++] = '%';
 1154|      0|			ret[len++] = hi + (hi > 9? 'A'-10 : '0');
  ------------------
  |  Branch (1154:23): [True: 0, False: 0]
  ------------------
 1155|      0|			ret[len++] = lo + (lo > 9? 'A'-10 : '0');
  ------------------
  |  Branch (1155:23): [True: 0, False: 0]
  ------------------
 1156|      0|		    }
 1157|      0|		}
 1158|      0|		if (len + 3 >= max) {
  ------------------
  |  Branch (1158:7): [True: 0, False: 0]
  ------------------
 1159|      0|                    temp = xmlSaveUriRealloc(ret, &max);
 1160|      0|                    if (temp == NULL) goto mem_error;
  ------------------
  |  Branch (1160:25): [True: 0, False: 0]
  ------------------
 1161|      0|                    ret = temp;
 1162|      0|		}
 1163|      0|		ret[len++] = '@';
 1164|      0|	    }
 1165|      0|	    if (uri->server != NULL) {
  ------------------
  |  Branch (1165:10): [True: 0, False: 0]
  ------------------
 1166|      0|		p = uri->server;
 1167|      0|		while (*p != 0) {
  ------------------
  |  Branch (1167:10): [True: 0, False: 0]
  ------------------
 1168|      0|		    if (len >= max) {
  ------------------
  |  Branch (1168:11): [True: 0, False: 0]
  ------------------
 1169|      0|			temp = xmlSaveUriRealloc(ret, &max);
 1170|      0|			if (temp == NULL) goto mem_error;
  ------------------
  |  Branch (1170:8): [True: 0, False: 0]
  ------------------
 1171|      0|			ret = temp;
 1172|      0|		    }
 1173|       |                    /* TODO: escaping? */
 1174|      0|		    ret[len++] = (xmlChar) *p++;
 1175|      0|		}
 1176|      0|	    }
 1177|      0|            if (uri->port > 0) {
  ------------------
  |  Branch (1177:17): [True: 0, False: 0]
  ------------------
 1178|      0|                if (len + 10 >= max) {
  ------------------
  |  Branch (1178:21): [True: 0, False: 0]
  ------------------
 1179|      0|                    temp = xmlSaveUriRealloc(ret, &max);
 1180|      0|                    if (temp == NULL) goto mem_error;
  ------------------
  |  Branch (1180:25): [True: 0, False: 0]
  ------------------
 1181|      0|                    ret = temp;
 1182|      0|                }
 1183|      0|                len += snprintf((char *) &ret[len], max - len, ":%d", uri->port);
 1184|      0|            }
 1185|     48|	} else if (uri->authority != NULL) {
  ------------------
  |  Branch (1185:13): [True: 0, False: 48]
  ------------------
 1186|      0|	    if (len + 3 >= max) {
  ------------------
  |  Branch (1186:10): [True: 0, False: 0]
  ------------------
 1187|      0|                temp = xmlSaveUriRealloc(ret, &max);
 1188|      0|                if (temp == NULL) goto mem_error;
  ------------------
  |  Branch (1188:21): [True: 0, False: 0]
  ------------------
 1189|      0|                ret = temp;
 1190|      0|	    }
 1191|      0|	    ret[len++] = '/';
 1192|      0|	    ret[len++] = '/';
 1193|      0|	    p = uri->authority;
 1194|      0|	    while (*p != 0) {
  ------------------
  |  Branch (1194:13): [True: 0, False: 0]
  ------------------
 1195|      0|		if (len + 3 >= max) {
  ------------------
  |  Branch (1195:7): [True: 0, False: 0]
  ------------------
 1196|      0|                    temp = xmlSaveUriRealloc(ret, &max);
 1197|      0|                    if (temp == NULL) goto mem_error;
  ------------------
  |  Branch (1197:25): [True: 0, False: 0]
  ------------------
 1198|      0|                    ret = temp;
 1199|      0|		}
 1200|      0|		if ((IS_UNRESERVED(*(p))) ||
  ------------------
  |  |  125|      0|#define IS_UNRESERVED(x) (IS_ALPHANUM(x) || IS_MARK(x))
  |  |  ------------------
  |  |  |  |   93|      0|#define IS_ALPHANUM(x) (IS_ALPHA(x) || IS_DIGIT(x))
  |  |  |  |  ------------------
  |  |  |  |  |  |   63|      0|#define IS_ALPHA(x) (IS_LOWALPHA(x) || IS_UPALPHA(x))
  |  |  |  |  |  |  ------------------
  |  |  |  |  |  |  |  |   72|      0|#define IS_LOWALPHA(x) (((x) >= 'a') && ((x) <= 'z'))
  |  |  |  |  |  |  |  |  ------------------
  |  |  |  |  |  |  |  |  |  Branch (72:25): [True: 0, False: 0]
  |  |  |  |  |  |  |  |  |  Branch (72:41): [True: 0, False: 0]
  |  |  |  |  |  |  |  |  ------------------
  |  |  |  |  |  |  ------------------
  |  |  |  |  |  |               #define IS_ALPHA(x) (IS_LOWALPHA(x) || IS_UPALPHA(x))
  |  |  |  |  |  |  ------------------
  |  |  |  |  |  |  |  |   79|      0|#define IS_UPALPHA(x) (((x) >= 'A') && ((x) <= 'Z'))
  |  |  |  |  |  |  |  |  ------------------
  |  |  |  |  |  |  |  |  |  Branch (79:24): [True: 0, False: 0]
  |  |  |  |  |  |  |  |  |  Branch (79:40): [True: 0, False: 0]
  |  |  |  |  |  |  |  |  ------------------
  |  |  |  |  |  |  ------------------
  |  |  |  |  ------------------
  |  |  |  |               #define IS_ALPHANUM(x) (IS_ALPHA(x) || IS_DIGIT(x))
  |  |  |  |  ------------------
  |  |  |  |  |  |   87|      0|#define IS_DIGIT(x) (((x) >= '0') && ((x) <= '9'))
  |  |  |  |  |  |  ------------------
  |  |  |  |  |  |  |  Branch (87:22): [True: 0, False: 0]
  |  |  |  |  |  |  |  Branch (87:38): [True: 0, False: 0]
  |  |  |  |  |  |  ------------------
  |  |  |  |  ------------------
  |  |  ------------------
  |  |               #define IS_UNRESERVED(x) (IS_ALPHANUM(x) || IS_MARK(x))
  |  |  ------------------
  |  |  |  |   99|      0|#define IS_MARK(x) (((x) == '-') || ((x) == '_') || ((x) == '.') ||     \
  |  |  |  |  ------------------
  |  |  |  |  |  Branch (99:21): [True: 0, False: 0]
  |  |  |  |  |  Branch (99:37): [True: 0, False: 0]
  |  |  |  |  |  Branch (99:53): [True: 0, False: 0]
  |  |  |  |  ------------------
  |  |  |  |  100|      0|    ((x) == '!') || ((x) == '~') || ((x) == '*') || ((x) == '\'') ||    \
  |  |  |  |  ------------------
  |  |  |  |  |  Branch (100:5): [True: 0, False: 0]
  |  |  |  |  |  Branch (100:21): [True: 0, False: 0]
  |  |  |  |  |  Branch (100:37): [True: 0, False: 0]
  |  |  |  |  |  Branch (100:53): [True: 0, False: 0]
  |  |  |  |  ------------------
  |  |  |  |  101|      0|    ((x) == '(') || ((x) == ')'))
  |  |  |  |  ------------------
  |  |  |  |  |  Branch (101:5): [True: 0, False: 0]
  |  |  |  |  |  Branch (101:21): [True: 0, False: 0]
  |  |  |  |  ------------------
  |  |  ------------------
  ------------------
 1201|      0|                    ((*(p) == '$')) || ((*(p) == ',')) || ((*(p) == ';')) ||
  ------------------
  |  Branch (1201:21): [True: 0, False: 0]
  |  Branch (1201:40): [True: 0, False: 0]
  |  Branch (1201:59): [True: 0, False: 0]
  ------------------
 1202|      0|                    ((*(p) == ':')) || ((*(p) == '@')) || ((*(p) == '&')) ||
  ------------------
  |  Branch (1202:21): [True: 0, False: 0]
  |  Branch (1202:40): [True: 0, False: 0]
  |  Branch (1202:59): [True: 0, False: 0]
  ------------------
 1203|      0|                    ((*(p) == '=')) || ((*(p) == '+')))
  ------------------
  |  Branch (1203:21): [True: 0, False: 0]
  |  Branch (1203:40): [True: 0, False: 0]
  ------------------
 1204|      0|		    ret[len++] = *p++;
 1205|      0|		else {
 1206|      0|		    int val = *(unsigned char *)p++;
 1207|      0|		    int hi = val / 0x10, lo = val % 0x10;
 1208|      0|		    ret[len++] = '%';
 1209|      0|		    ret[len++] = hi + (hi > 9? 'A'-10 : '0');
  ------------------
  |  Branch (1209:26): [True: 0, False: 0]
  ------------------
 1210|      0|		    ret[len++] = lo + (lo > 9? 'A'-10 : '0');
  ------------------
  |  Branch (1210:26): [True: 0, False: 0]
  ------------------
 1211|      0|		}
 1212|      0|	    }
 1213|     48|	} else if (uri->scheme != NULL) {
  ------------------
  |  Branch (1213:13): [True: 0, False: 48]
  ------------------
 1214|      0|	    if (len + 3 >= max) {
  ------------------
  |  Branch (1214:10): [True: 0, False: 0]
  ------------------
 1215|      0|                temp = xmlSaveUriRealloc(ret, &max);
 1216|      0|                if (temp == NULL) goto mem_error;
  ------------------
  |  Branch (1216:21): [True: 0, False: 0]
  ------------------
 1217|      0|                ret = temp;
 1218|      0|	    }
 1219|      0|	}
 1220|     48|	if (uri->path != NULL) {
  ------------------
  |  Branch (1220:6): [True: 48, False: 0]
  ------------------
 1221|     48|	    p = uri->path;
 1222|       |	    /*
 1223|       |	     * the colon in file:///d: should not be escaped or
 1224|       |	     * Windows accesses fail later.
 1225|       |	     */
 1226|     48|	    if ((uri->scheme != NULL) &&
  ------------------
  |  Branch (1226:10): [True: 0, False: 48]
  ------------------
 1227|     48|		(p[0] == '/') &&
  ------------------
  |  Branch (1227:3): [True: 0, False: 0]
  ------------------
 1228|     48|		(((p[1] >= 'a') && (p[1] <= 'z')) ||
  ------------------
  |  Branch (1228:5): [True: 0, False: 0]
  |  Branch (1228:22): [True: 0, False: 0]
  ------------------
 1229|      0|		 ((p[1] >= 'A') && (p[1] <= 'Z'))) &&
  ------------------
  |  Branch (1229:5): [True: 0, False: 0]
  |  Branch (1229:22): [True: 0, False: 0]
  ------------------
 1230|     48|		(p[2] == ':') &&
  ------------------
  |  Branch (1230:3): [True: 0, False: 0]
  ------------------
 1231|     48|	        (xmlStrEqual(BAD_CAST uri->scheme, BAD_CAST "file"))) {
  ------------------
  |  |   35|      0|#define BAD_CAST (xmlChar *)
  ------------------
              	        (xmlStrEqual(BAD_CAST uri->scheme, BAD_CAST "file"))) {
  ------------------
  |  |   35|      0|#define BAD_CAST (xmlChar *)
  ------------------
  |  Branch (1231:10): [True: 0, False: 0]
  ------------------
 1232|      0|		if (len + 3 >= max) {
  ------------------
  |  Branch (1232:7): [True: 0, False: 0]
  ------------------
 1233|      0|                    temp = xmlSaveUriRealloc(ret, &max);
 1234|      0|                    if (temp == NULL) goto mem_error;
  ------------------
  |  Branch (1234:25): [True: 0, False: 0]
  ------------------
 1235|      0|                    ret = temp;
 1236|      0|		}
 1237|      0|		ret[len++] = *p++;
 1238|      0|		ret[len++] = *p++;
 1239|      0|		ret[len++] = *p++;
 1240|      0|	    }
 1241|    918|	    while (*p != 0) {
  ------------------
  |  Branch (1241:13): [True: 870, False: 48]
  ------------------
 1242|    870|		if (len + 3 >= max) {
  ------------------
  |  Branch (1242:7): [True: 0, False: 870]
  ------------------
 1243|      0|                    temp = xmlSaveUriRealloc(ret, &max);
 1244|      0|                    if (temp == NULL) goto mem_error;
  ------------------
  |  Branch (1244:25): [True: 0, False: 0]
  ------------------
 1245|      0|                    ret = temp;
 1246|      0|		}
 1247|    870|		if ((IS_UNRESERVED(*(p))) || ((*(p) == '/')) ||
  ------------------
  |  |  125|    870|#define IS_UNRESERVED(x) (IS_ALPHANUM(x) || IS_MARK(x))
  |  |  ------------------
  |  |  |  |   93|  1.74k|#define IS_ALPHANUM(x) (IS_ALPHA(x) || IS_DIGIT(x))
  |  |  |  |  ------------------
  |  |  |  |  |  |   63|  1.74k|#define IS_ALPHA(x) (IS_LOWALPHA(x) || IS_UPALPHA(x))
  |  |  |  |  |  |  ------------------
  |  |  |  |  |  |  |  |   72|  1.74k|#define IS_LOWALPHA(x) (((x) >= 'a') && ((x) <= 'z'))
  |  |  |  |  |  |  |  |  ------------------
  |  |  |  |  |  |  |  |  |  Branch (72:25): [True: 490, False: 380]
  |  |  |  |  |  |  |  |  |  Branch (72:41): [True: 490, False: 0]
  |  |  |  |  |  |  |  |  ------------------
  |  |  |  |  |  |  ------------------
  |  |  |  |  |  |               #define IS_ALPHA(x) (IS_LOWALPHA(x) || IS_UPALPHA(x))
  |  |  |  |  |  |  ------------------
  |  |  |  |  |  |  |  |   79|    380|#define IS_UPALPHA(x) (((x) >= 'A') && ((x) <= 'Z'))
  |  |  |  |  |  |  |  |  ------------------
  |  |  |  |  |  |  |  |  |  Branch (79:24): [True: 27, False: 353]
  |  |  |  |  |  |  |  |  |  Branch (79:40): [True: 14, False: 13]
  |  |  |  |  |  |  |  |  ------------------
  |  |  |  |  |  |  ------------------
  |  |  |  |  ------------------
  |  |  |  |               #define IS_ALPHANUM(x) (IS_ALPHA(x) || IS_DIGIT(x))
  |  |  |  |  ------------------
  |  |  |  |  |  |   87|    366|#define IS_DIGIT(x) (((x) >= '0') && ((x) <= '9'))
  |  |  |  |  |  |  ------------------
  |  |  |  |  |  |  |  Branch (87:22): [True: 250, False: 116]
  |  |  |  |  |  |  |  Branch (87:38): [True: 237, False: 13]
  |  |  |  |  |  |  ------------------
  |  |  |  |  ------------------
  |  |  ------------------
  |  |               #define IS_UNRESERVED(x) (IS_ALPHANUM(x) || IS_MARK(x))
  |  |  ------------------
  |  |  |  |   99|    129|#define IS_MARK(x) (((x) == '-') || ((x) == '_') || ((x) == '.') ||     \
  |  |  |  |  ------------------
  |  |  |  |  |  Branch (99:21): [True: 52, False: 77]
  |  |  |  |  |  Branch (99:37): [True: 13, False: 64]
  |  |  |  |  |  Branch (99:53): [True: 61, False: 3]
  |  |  |  |  ------------------
  |  |  |  |  100|    129|    ((x) == '!') || ((x) == '~') || ((x) == '*') || ((x) == '\'') ||    \
  |  |  |  |  ------------------
  |  |  |  |  |  Branch (100:5): [True: 0, False: 3]
  |  |  |  |  |  Branch (100:21): [True: 0, False: 3]
  |  |  |  |  |  Branch (100:37): [True: 0, False: 3]
  |  |  |  |  |  Branch (100:53): [True: 0, False: 3]
  |  |  |  |  ------------------
  |  |  |  |  101|    129|    ((x) == '(') || ((x) == ')'))
  |  |  |  |  ------------------
  |  |  |  |  |  Branch (101:5): [True: 0, False: 3]
  |  |  |  |  |  Branch (101:21): [True: 0, False: 3]
  |  |  |  |  ------------------
  |  |  ------------------
  ------------------
  |  Branch (1247:32): [True: 0, False: 3]
  ------------------
 1248|    870|                    ((*(p) == ';')) || ((*(p) == '@')) || ((*(p) == '&')) ||
  ------------------
  |  Branch (1248:21): [True: 0, False: 3]
  |  Branch (1248:40): [True: 0, False: 3]
  |  Branch (1248:59): [True: 0, False: 3]
  ------------------
 1249|    870|	            ((*(p) == '=')) || ((*(p) == '+')) || ((*(p) == '$')) ||
  ------------------
  |  Branch (1249:14): [True: 0, False: 3]
  |  Branch (1249:33): [True: 0, False: 3]
  |  Branch (1249:52): [True: 0, False: 3]
  ------------------
 1250|    870|	            ((*(p) == ',')))
  ------------------
  |  Branch (1250:14): [True: 0, False: 3]
  ------------------
 1251|    867|		    ret[len++] = *p++;
 1252|      3|		else {
 1253|      3|		    int val = *(unsigned char *)p++;
 1254|      3|		    int hi = val / 0x10, lo = val % 0x10;
 1255|      3|		    ret[len++] = '%';
 1256|      3|		    ret[len++] = hi + (hi > 9? 'A'-10 : '0');
  ------------------
  |  Branch (1256:26): [True: 3, False: 0]
  ------------------
 1257|      3|		    ret[len++] = lo + (lo > 9? 'A'-10 : '0');
  ------------------
  |  Branch (1257:26): [True: 2, False: 1]
  ------------------
 1258|      3|		}
 1259|    870|	    }
 1260|     48|	}
 1261|     48|	if (uri->query_raw != NULL) {
  ------------------
  |  Branch (1261:6): [True: 0, False: 48]
  ------------------
 1262|      0|	    if (len + 1 >= max) {
  ------------------
  |  Branch (1262:10): [True: 0, False: 0]
  ------------------
 1263|      0|                temp = xmlSaveUriRealloc(ret, &max);
 1264|      0|                if (temp == NULL) goto mem_error;
  ------------------
  |  Branch (1264:21): [True: 0, False: 0]
  ------------------
 1265|      0|                ret = temp;
 1266|      0|	    }
 1267|      0|	    ret[len++] = '?';
 1268|      0|	    p = uri->query_raw;
 1269|      0|	    while (*p != 0) {
  ------------------
  |  Branch (1269:13): [True: 0, False: 0]
  ------------------
 1270|      0|		if (len + 1 >= max) {
  ------------------
  |  Branch (1270:7): [True: 0, False: 0]
  ------------------
 1271|      0|                    temp = xmlSaveUriRealloc(ret, &max);
 1272|      0|                    if (temp == NULL) goto mem_error;
  ------------------
  |  Branch (1272:25): [True: 0, False: 0]
  ------------------
 1273|      0|                    ret = temp;
 1274|      0|		}
 1275|      0|		ret[len++] = *p++;
 1276|      0|	    }
 1277|     48|	} else if (uri->query != NULL) {
  ------------------
  |  Branch (1277:13): [True: 0, False: 48]
  ------------------
 1278|      0|	    if (len + 3 >= max) {
  ------------------
  |  Branch (1278:10): [True: 0, False: 0]
  ------------------
 1279|      0|                temp = xmlSaveUriRealloc(ret, &max);
 1280|      0|                if (temp == NULL) goto mem_error;
  ------------------
  |  Branch (1280:21): [True: 0, False: 0]
  ------------------
 1281|      0|                ret = temp;
 1282|      0|	    }
 1283|      0|	    ret[len++] = '?';
 1284|      0|	    p = uri->query;
 1285|      0|	    while (*p != 0) {
  ------------------
  |  Branch (1285:13): [True: 0, False: 0]
  ------------------
 1286|      0|		if (len + 3 >= max) {
  ------------------
  |  Branch (1286:7): [True: 0, False: 0]
  ------------------
 1287|      0|                    temp = xmlSaveUriRealloc(ret, &max);
 1288|      0|                    if (temp == NULL) goto mem_error;
  ------------------
  |  Branch (1288:25): [True: 0, False: 0]
  ------------------
 1289|      0|                    ret = temp;
 1290|      0|		}
 1291|      0|		if ((IS_UNRESERVED(*(p))) || (IS_RESERVED(*(p))))
  ------------------
  |  |  125|      0|#define IS_UNRESERVED(x) (IS_ALPHANUM(x) || IS_MARK(x))
  |  |  ------------------
  |  |  |  |   93|      0|#define IS_ALPHANUM(x) (IS_ALPHA(x) || IS_DIGIT(x))
  |  |  |  |  ------------------
  |  |  |  |  |  |   63|      0|#define IS_ALPHA(x) (IS_LOWALPHA(x) || IS_UPALPHA(x))
  |  |  |  |  |  |  ------------------
  |  |  |  |  |  |  |  |   72|      0|#define IS_LOWALPHA(x) (((x) >= 'a') && ((x) <= 'z'))
  |  |  |  |  |  |  |  |  ------------------
  |  |  |  |  |  |  |  |  |  Branch (72:25): [True: 0, False: 0]
  |  |  |  |  |  |  |  |  |  Branch (72:41): [True: 0, False: 0]
  |  |  |  |  |  |  |  |  ------------------
  |  |  |  |  |  |  ------------------
  |  |  |  |  |  |               #define IS_ALPHA(x) (IS_LOWALPHA(x) || IS_UPALPHA(x))
  |  |  |  |  |  |  ------------------
  |  |  |  |  |  |  |  |   79|      0|#define IS_UPALPHA(x) (((x) >= 'A') && ((x) <= 'Z'))
  |  |  |  |  |  |  |  |  ------------------
  |  |  |  |  |  |  |  |  |  Branch (79:24): [True: 0, False: 0]
  |  |  |  |  |  |  |  |  |  Branch (79:40): [True: 0, False: 0]
  |  |  |  |  |  |  |  |  ------------------
  |  |  |  |  |  |  ------------------
  |  |  |  |  ------------------
  |  |  |  |               #define IS_ALPHANUM(x) (IS_ALPHA(x) || IS_DIGIT(x))
  |  |  |  |  ------------------
  |  |  |  |  |  |   87|      0|#define IS_DIGIT(x) (((x) >= '0') && ((x) <= '9'))
  |  |  |  |  |  |  ------------------
  |  |  |  |  |  |  |  Branch (87:22): [True: 0, False: 0]
  |  |  |  |  |  |  |  Branch (87:38): [True: 0, False: 0]
  |  |  |  |  |  |  ------------------
  |  |  |  |  ------------------
  |  |  ------------------
  |  |               #define IS_UNRESERVED(x) (IS_ALPHANUM(x) || IS_MARK(x))
  |  |  ------------------
  |  |  |  |   99|      0|#define IS_MARK(x) (((x) == '-') || ((x) == '_') || ((x) == '.') ||     \
  |  |  |  |  ------------------
  |  |  |  |  |  Branch (99:21): [True: 0, False: 0]
  |  |  |  |  |  Branch (99:37): [True: 0, False: 0]
  |  |  |  |  |  Branch (99:53): [True: 0, False: 0]
  |  |  |  |  ------------------
  |  |  |  |  100|      0|    ((x) == '!') || ((x) == '~') || ((x) == '*') || ((x) == '\'') ||    \
  |  |  |  |  ------------------
  |  |  |  |  |  Branch (100:5): [True: 0, False: 0]
  |  |  |  |  |  Branch (100:21): [True: 0, False: 0]
  |  |  |  |  |  Branch (100:37): [True: 0, False: 0]
  |  |  |  |  |  Branch (100:53): [True: 0, False: 0]
  |  |  |  |  ------------------
  |  |  |  |  101|      0|    ((x) == '(') || ((x) == ')'))
  |  |  |  |  ------------------
  |  |  |  |  |  Branch (101:5): [True: 0, False: 0]
  |  |  |  |  |  Branch (101:21): [True: 0, False: 0]
  |  |  |  |  ------------------
  |  |  ------------------
  ------------------
              		if ((IS_UNRESERVED(*(p))) || (IS_RESERVED(*(p))))
  ------------------
  |  |  116|      0|#define IS_RESERVED(x) (((x) == ';') || ((x) == '/') || ((x) == '?') || \
  |  |  ------------------
  |  |  |  Branch (116:25): [True: 0, False: 0]
  |  |  |  Branch (116:41): [True: 0, False: 0]
  |  |  |  Branch (116:57): [True: 0, False: 0]
  |  |  ------------------
  |  |  117|      0|        ((x) == ':') || ((x) == '@') || ((x) == '&') || ((x) == '=') || \
  |  |  ------------------
  |  |  |  Branch (117:9): [True: 0, False: 0]
  |  |  |  Branch (117:25): [True: 0, False: 0]
  |  |  |  Branch (117:41): [True: 0, False: 0]
  |  |  |  Branch (117:57): [True: 0, False: 0]
  |  |  ------------------
  |  |  118|      0|        ((x) == '+') || ((x) == '$') || ((x) == ',') || ((x) == '[') || \
  |  |  ------------------
  |  |  |  Branch (118:9): [True: 0, False: 0]
  |  |  |  Branch (118:25): [True: 0, False: 0]
  |  |  |  Branch (118:41): [True: 0, False: 0]
  |  |  |  Branch (118:57): [True: 0, False: 0]
  |  |  ------------------
  |  |  119|      0|        ((x) == ']'))
  |  |  ------------------
  |  |  |  Branch (119:9): [True: 0, False: 0]
  |  |  ------------------
  ------------------
 1292|      0|		    ret[len++] = *p++;
 1293|      0|		else {
 1294|      0|		    int val = *(unsigned char *)p++;
 1295|      0|		    int hi = val / 0x10, lo = val % 0x10;
 1296|      0|		    ret[len++] = '%';
 1297|      0|		    ret[len++] = hi + (hi > 9? 'A'-10 : '0');
  ------------------
  |  Branch (1297:26): [True: 0, False: 0]
  ------------------
 1298|      0|		    ret[len++] = lo + (lo > 9? 'A'-10 : '0');
  ------------------
  |  Branch (1298:26): [True: 0, False: 0]
  ------------------
 1299|      0|		}
 1300|      0|	    }
 1301|      0|	}
 1302|     48|    }
 1303|     48|    if (uri->fragment != NULL) {
  ------------------
  |  Branch (1303:9): [True: 0, False: 48]
  ------------------
 1304|      0|	if (len + 3 >= max) {
  ------------------
  |  Branch (1304:6): [True: 0, False: 0]
  ------------------
 1305|      0|            temp = xmlSaveUriRealloc(ret, &max);
 1306|      0|            if (temp == NULL) goto mem_error;
  ------------------
  |  Branch (1306:17): [True: 0, False: 0]
  ------------------
 1307|      0|            ret = temp;
 1308|      0|	}
 1309|      0|	ret[len++] = '#';
 1310|      0|	p = uri->fragment;
 1311|      0|	while (*p != 0) {
  ------------------
  |  Branch (1311:9): [True: 0, False: 0]
  ------------------
 1312|      0|	    if (len + 3 >= max) {
  ------------------
  |  Branch (1312:10): [True: 0, False: 0]
  ------------------
 1313|      0|                temp = xmlSaveUriRealloc(ret, &max);
 1314|      0|                if (temp == NULL) goto mem_error;
  ------------------
  |  Branch (1314:21): [True: 0, False: 0]
  ------------------
 1315|      0|                ret = temp;
 1316|      0|	    }
 1317|      0|	    if ((IS_UNRESERVED(*(p))) || (IS_RESERVED(*(p))))
  ------------------
  |  |  125|      0|#define IS_UNRESERVED(x) (IS_ALPHANUM(x) || IS_MARK(x))
  |  |  ------------------
  |  |  |  |   93|      0|#define IS_ALPHANUM(x) (IS_ALPHA(x) || IS_DIGIT(x))
  |  |  |  |  ------------------
  |  |  |  |  |  |   63|      0|#define IS_ALPHA(x) (IS_LOWALPHA(x) || IS_UPALPHA(x))
  |  |  |  |  |  |  ------------------
  |  |  |  |  |  |  |  |   72|      0|#define IS_LOWALPHA(x) (((x) >= 'a') && ((x) <= 'z'))
  |  |  |  |  |  |  |  |  ------------------
  |  |  |  |  |  |  |  |  |  Branch (72:25): [True: 0, False: 0]
  |  |  |  |  |  |  |  |  |  Branch (72:41): [True: 0, False: 0]
  |  |  |  |  |  |  |  |  ------------------
  |  |  |  |  |  |  ------------------
  |  |  |  |  |  |               #define IS_ALPHA(x) (IS_LOWALPHA(x) || IS_UPALPHA(x))
  |  |  |  |  |  |  ------------------
  |  |  |  |  |  |  |  |   79|      0|#define IS_UPALPHA(x) (((x) >= 'A') && ((x) <= 'Z'))
  |  |  |  |  |  |  |  |  ------------------
  |  |  |  |  |  |  |  |  |  Branch (79:24): [True: 0, False: 0]
  |  |  |  |  |  |  |  |  |  Branch (79:40): [True: 0, False: 0]
  |  |  |  |  |  |  |  |  ------------------
  |  |  |  |  |  |  ------------------
  |  |  |  |  ------------------
  |  |  |  |               #define IS_ALPHANUM(x) (IS_ALPHA(x) || IS_DIGIT(x))
  |  |  |  |  ------------------
  |  |  |  |  |  |   87|      0|#define IS_DIGIT(x) (((x) >= '0') && ((x) <= '9'))
  |  |  |  |  |  |  ------------------
  |  |  |  |  |  |  |  Branch (87:22): [True: 0, False: 0]
  |  |  |  |  |  |  |  Branch (87:38): [True: 0, False: 0]
  |  |  |  |  |  |  ------------------
  |  |  |  |  ------------------
  |  |  ------------------
  |  |               #define IS_UNRESERVED(x) (IS_ALPHANUM(x) || IS_MARK(x))
  |  |  ------------------
  |  |  |  |   99|      0|#define IS_MARK(x) (((x) == '-') || ((x) == '_') || ((x) == '.') ||     \
  |  |  |  |  ------------------
  |  |  |  |  |  Branch (99:21): [True: 0, False: 0]
  |  |  |  |  |  Branch (99:37): [True: 0, False: 0]
  |  |  |  |  |  Branch (99:53): [True: 0, False: 0]
  |  |  |  |  ------------------
  |  |  |  |  100|      0|    ((x) == '!') || ((x) == '~') || ((x) == '*') || ((x) == '\'') ||    \
  |  |  |  |  ------------------
  |  |  |  |  |  Branch (100:5): [True: 0, False: 0]
  |  |  |  |  |  Branch (100:21): [True: 0, False: 0]
  |  |  |  |  |  Branch (100:37): [True: 0, False: 0]
  |  |  |  |  |  Branch (100:53): [True: 0, False: 0]
  |  |  |  |  ------------------
  |  |  |  |  101|      0|    ((x) == '(') || ((x) == ')'))
  |  |  |  |  ------------------
  |  |  |  |  |  Branch (101:5): [True: 0, False: 0]
  |  |  |  |  |  Branch (101:21): [True: 0, False: 0]
  |  |  |  |  ------------------
  |  |  ------------------
  ------------------
              	    if ((IS_UNRESERVED(*(p))) || (IS_RESERVED(*(p))))
  ------------------
  |  |  116|      0|#define IS_RESERVED(x) (((x) == ';') || ((x) == '/') || ((x) == '?') || \
  |  |  ------------------
  |  |  |  Branch (116:25): [True: 0, False: 0]
  |  |  |  Branch (116:41): [True: 0, False: 0]
  |  |  |  Branch (116:57): [True: 0, False: 0]
  |  |  ------------------
  |  |  117|      0|        ((x) == ':') || ((x) == '@') || ((x) == '&') || ((x) == '=') || \
  |  |  ------------------
  |  |  |  Branch (117:9): [True: 0, False: 0]
  |  |  |  Branch (117:25): [True: 0, False: 0]
  |  |  |  Branch (117:41): [True: 0, False: 0]
  |  |  |  Branch (117:57): [True: 0, False: 0]
  |  |  ------------------
  |  |  118|      0|        ((x) == '+') || ((x) == '$') || ((x) == ',') || ((x) == '[') || \
  |  |  ------------------
  |  |  |  Branch (118:9): [True: 0, False: 0]
  |  |  |  Branch (118:25): [True: 0, False: 0]
  |  |  |  Branch (118:41): [True: 0, False: 0]
  |  |  |  Branch (118:57): [True: 0, False: 0]
  |  |  ------------------
  |  |  119|      0|        ((x) == ']'))
  |  |  ------------------
  |  |  |  Branch (119:9): [True: 0, False: 0]
  |  |  ------------------
  ------------------
 1318|      0|		ret[len++] = *p++;
 1319|      0|	    else {
 1320|      0|		int val = *(unsigned char *)p++;
 1321|      0|		int hi = val / 0x10, lo = val % 0x10;
 1322|      0|		ret[len++] = '%';
 1323|      0|		ret[len++] = hi + (hi > 9? 'A'-10 : '0');
  ------------------
  |  Branch (1323:22): [True: 0, False: 0]
  ------------------
 1324|      0|		ret[len++] = lo + (lo > 9? 'A'-10 : '0');
  ------------------
  |  Branch (1324:22): [True: 0, False: 0]
  ------------------
 1325|      0|	    }
 1326|      0|	}
 1327|      0|    }
 1328|     48|    if (len >= max) {
  ------------------
  |  Branch (1328:9): [True: 0, False: 48]
  ------------------
 1329|      0|        temp = xmlSaveUriRealloc(ret, &max);
 1330|      0|        if (temp == NULL) goto mem_error;
  ------------------
  |  Branch (1330:13): [True: 0, False: 0]
  ------------------
 1331|      0|        ret = temp;
 1332|      0|    }
 1333|     48|    ret[len] = 0;
 1334|     48|    return(ret);
 1335|       |
 1336|      0|mem_error:
 1337|      0|    xmlFree(ret);
 1338|      0|    return(NULL);
 1339|     48|}
xmlFreeURI:
 1396|  1.23k|xmlFreeURI(xmlURIPtr uri) {
 1397|  1.23k|    if (uri == NULL) return;
  ------------------
  |  Branch (1397:9): [True: 0, False: 1.23k]
  ------------------
 1398|       |
 1399|  1.23k|    if (uri->scheme != NULL) xmlFree(uri->scheme);
  ------------------
  |  Branch (1399:9): [True: 559, False: 672]
  ------------------
 1400|  1.23k|    if (uri->server != NULL) xmlFree(uri->server);
  ------------------
  |  Branch (1400:9): [True: 540, False: 691]
  ------------------
 1401|  1.23k|    if (uri->user != NULL) xmlFree(uri->user);
  ------------------
  |  Branch (1401:9): [True: 0, False: 1.23k]
  ------------------
 1402|  1.23k|    if (uri->path != NULL) xmlFree(uri->path);
  ------------------
  |  Branch (1402:9): [True: 615, False: 616]
  ------------------
 1403|  1.23k|    if (uri->fragment != NULL) xmlFree(uri->fragment);
  ------------------
  |  Branch (1403:9): [True: 5, False: 1.22k]
  ------------------
 1404|  1.23k|    if (uri->opaque != NULL) xmlFree(uri->opaque);
  ------------------
  |  Branch (1404:9): [True: 0, False: 1.23k]
  ------------------
 1405|  1.23k|    if (uri->authority != NULL) xmlFree(uri->authority);
  ------------------
  |  Branch (1405:9): [True: 0, False: 1.23k]
  ------------------
 1406|  1.23k|    if (uri->query != NULL) xmlFree(uri->query);
  ------------------
  |  Branch (1406:9): [True: 0, False: 1.23k]
  ------------------
 1407|  1.23k|    if (uri->query_raw != NULL) xmlFree(uri->query_raw);
  ------------------
  |  Branch (1407:9): [True: 0, False: 1.23k]
  ------------------
 1408|  1.23k|    xmlFree(uri);
 1409|  1.23k|}
xmlNormalizeURIPath:
 1429|     47|xmlNormalizeURIPath(char *path) {
 1430|     47|    char *cur, *out;
 1431|       |
 1432|     47|    if (path == NULL)
  ------------------
  |  Branch (1432:9): [True: 0, False: 47]
  ------------------
 1433|      0|	return(-1);
 1434|       |
 1435|       |    /* Skip all initial "/" chars.  We want to get to the beginning of the
 1436|       |     * first non-empty segment.
 1437|       |     */
 1438|     47|    cur = path;
 1439|     47|    while (cur[0] == '/')
  ------------------
  |  Branch (1439:12): [True: 0, False: 47]
  ------------------
 1440|      0|      ++cur;
 1441|     47|    if (cur[0] == '\0')
  ------------------
  |  Branch (1441:9): [True: 0, False: 47]
  ------------------
 1442|      0|      return(0);
 1443|       |
 1444|       |    /* Keep everything we've seen so far.  */
 1445|     47|    out = cur;
 1446|       |
 1447|       |    /*
 1448|       |     * Analyze each segment in sequence for cases (c) and (d).
 1449|       |     */
 1450|     56|    while (cur[0] != '\0') {
  ------------------
  |  Branch (1450:12): [True: 56, False: 0]
  ------------------
 1451|       |	/*
 1452|       |	 * c) All occurrences of "./", where "." is a complete path segment,
 1453|       |	 *    are removed from the buffer string.
 1454|       |	 */
 1455|     56|	if ((cur[0] == '.') && (cur[1] == '/')) {
  ------------------
  |  Branch (1455:6): [True: 9, False: 47]
  |  Branch (1455:25): [True: 9, False: 0]
  ------------------
 1456|      9|	    cur += 2;
 1457|       |	    /* '//' normalization should be done at this point too */
 1458|      9|	    while (cur[0] == '/')
  ------------------
  |  Branch (1458:13): [True: 0, False: 9]
  ------------------
 1459|      0|		cur++;
 1460|      9|	    continue;
 1461|      9|	}
 1462|       |
 1463|       |	/*
 1464|       |	 * d) If the buffer string ends with "." as a complete path segment,
 1465|       |	 *    that "." is removed.
 1466|       |	 */
 1467|     47|	if ((cur[0] == '.') && (cur[1] == '\0'))
  ------------------
  |  Branch (1467:6): [True: 0, False: 47]
  |  Branch (1467:25): [True: 0, False: 0]
  ------------------
 1468|      0|	    break;
 1469|       |
 1470|       |	/* Otherwise keep the segment.  */
 1471|    913|	while (cur[0] != '/') {
  ------------------
  |  Branch (1471:9): [True: 913, False: 0]
  ------------------
 1472|    913|            if (cur[0] == '\0')
  ------------------
  |  Branch (1472:17): [True: 47, False: 866]
  ------------------
 1473|     47|              goto done_cd;
 1474|    866|	    (out++)[0] = (cur++)[0];
 1475|    866|	}
 1476|       |	/* normalize // */
 1477|      0|	while ((cur[0] == '/') && (cur[1] == '/'))
  ------------------
  |  Branch (1477:9): [True: 0, False: 0]
  |  Branch (1477:28): [True: 0, False: 0]
  ------------------
 1478|      0|	    cur++;
 1479|       |
 1480|      0|        (out++)[0] = (cur++)[0];
 1481|      0|    }
 1482|     47| done_cd:
 1483|     47|    out[0] = '\0';
 1484|       |
 1485|       |    /* Reset to the beginning of the first segment for the next sequence.  */
 1486|     47|    cur = path;
 1487|     47|    while (cur[0] == '/')
  ------------------
  |  Branch (1487:12): [True: 0, False: 47]
  ------------------
 1488|      0|      ++cur;
 1489|     47|    if (cur[0] == '\0')
  ------------------
  |  Branch (1489:9): [True: 0, False: 47]
  ------------------
 1490|      0|	return(0);
 1491|       |
 1492|       |    /*
 1493|       |     * Analyze each segment in sequence for cases (e) and (f).
 1494|       |     *
 1495|       |     * e) All occurrences of "<segment>/../", where <segment> is a
 1496|       |     *    complete path segment not equal to "..", are removed from the
 1497|       |     *    buffer string.  Removal of these path segments is performed
 1498|       |     *    iteratively, removing the leftmost matching pattern on each
 1499|       |     *    iteration, until no matching pattern remains.
 1500|       |     *
 1501|       |     * f) If the buffer string ends with "<segment>/..", where <segment>
 1502|       |     *    is a complete path segment not equal to "..", that
 1503|       |     *    "<segment>/.." is removed.
 1504|       |     *
 1505|       |     * To satisfy the "iterative" clause in (e), we need to collapse the
 1506|       |     * string every time we find something that needs to be removed.  Thus,
 1507|       |     * we don't need to keep two pointers into the string: we only need a
 1508|       |     * "current position" pointer.
 1509|       |     */
 1510|     47|    while (1) {
  ------------------
  |  Branch (1510:12): [Folded - Ignored]
  ------------------
 1511|     47|        char *segp, *tmp;
 1512|       |
 1513|       |        /* At the beginning of each iteration of this loop, "cur" points to
 1514|       |         * the first character of the segment we want to examine.
 1515|       |         */
 1516|       |
 1517|       |        /* Find the end of the current segment.  */
 1518|     47|        segp = cur;
 1519|    913|        while ((segp[0] != '/') && (segp[0] != '\0'))
  ------------------
  |  Branch (1519:16): [True: 913, False: 0]
  |  Branch (1519:36): [True: 866, False: 47]
  ------------------
 1520|    866|          ++segp;
 1521|       |
 1522|       |        /* If this is the last segment, we're done (we need at least two
 1523|       |         * segments to meet the criteria for the (e) and (f) cases).
 1524|       |         */
 1525|     47|        if (segp[0] == '\0')
  ------------------
  |  Branch (1525:13): [True: 47, False: 0]
  ------------------
 1526|     47|          break;
 1527|       |
 1528|       |        /* If the first segment is "..", or if the next segment _isn't_ "..",
 1529|       |         * keep this segment and try the next one.
 1530|       |         */
 1531|      0|        ++segp;
 1532|      0|        if (((cur[0] == '.') && (cur[1] == '.') && (segp == cur+3))
  ------------------
  |  Branch (1532:14): [True: 0, False: 0]
  |  Branch (1532:33): [True: 0, False: 0]
  |  Branch (1532:52): [True: 0, False: 0]
  ------------------
 1533|      0|            || ((segp[0] != '.') || (segp[1] != '.')
  ------------------
  |  Branch (1533:17): [True: 0, False: 0]
  |  Branch (1533:37): [True: 0, False: 0]
  ------------------
 1534|      0|                || ((segp[2] != '/') && (segp[2] != '\0')))) {
  ------------------
  |  Branch (1534:21): [True: 0, False: 0]
  |  Branch (1534:41): [True: 0, False: 0]
  ------------------
 1535|      0|          cur = segp;
 1536|      0|          continue;
 1537|      0|        }
 1538|       |
 1539|       |        /* If we get here, remove this segment and the next one and back up
 1540|       |         * to the previous segment (if there is one), to implement the
 1541|       |         * "iteratively" clause.  It's pretty much impossible to back up
 1542|       |         * while maintaining two pointers into the buffer, so just compact
 1543|       |         * the whole buffer now.
 1544|       |         */
 1545|       |
 1546|       |        /* If this is the end of the buffer, we're done.  */
 1547|      0|        if (segp[2] == '\0') {
  ------------------
  |  Branch (1547:13): [True: 0, False: 0]
  ------------------
 1548|      0|          cur[0] = '\0';
 1549|      0|          break;
 1550|      0|        }
 1551|       |        /* Valgrind complained, strcpy(cur, segp + 3); */
 1552|       |        /* string will overlap, do not use strcpy */
 1553|      0|        tmp = cur;
 1554|      0|        segp += 3;
 1555|      0|        while ((*tmp++ = *segp++) != 0)
  ------------------
  |  Branch (1555:16): [True: 0, False: 0]
  ------------------
 1556|      0|          ;
 1557|       |
 1558|       |        /* If there are no previous segments, then keep going from here.  */
 1559|      0|        segp = cur;
 1560|      0|        while ((segp > path) && ((--segp)[0] == '/'))
  ------------------
  |  Branch (1560:16): [True: 0, False: 0]
  |  Branch (1560:33): [True: 0, False: 0]
  ------------------
 1561|      0|          ;
 1562|      0|        if (segp == path)
  ------------------
  |  Branch (1562:13): [True: 0, False: 0]
  ------------------
 1563|      0|          continue;
 1564|       |
 1565|       |        /* "segp" is pointing to the end of a previous segment; find it's
 1566|       |         * start.  We need to back up to the previous segment and start
 1567|       |         * over with that to handle things like "foo/bar/../..".  If we
 1568|       |         * don't do this, then on the first pass we'll remove the "bar/..",
 1569|       |         * but be pointing at the second ".." so we won't realize we can also
 1570|       |         * remove the "foo/..".
 1571|       |         */
 1572|      0|        cur = segp;
 1573|      0|        while ((cur > path) && (cur[-1] != '/'))
  ------------------
  |  Branch (1573:16): [True: 0, False: 0]
  |  Branch (1573:32): [True: 0, False: 0]
  ------------------
 1574|      0|          --cur;
 1575|      0|    }
 1576|     47|    out[0] = '\0';
 1577|       |
 1578|       |    /*
 1579|       |     * g) If the resulting buffer string still begins with one or more
 1580|       |     *    complete path segments of "..", then the reference is
 1581|       |     *    considered to be in error. Implementations may handle this
 1582|       |     *    error by retaining these components in the resolved path (i.e.,
 1583|       |     *    treating them as part of the final URI), by removing them from
 1584|       |     *    the resolved path (i.e., discarding relative levels above the
 1585|       |     *    root), or by avoiding traversal of the reference.
 1586|       |     *
 1587|       |     * We discard them from the final path.
 1588|       |     */
 1589|     47|    if (path[0] == '/') {
  ------------------
  |  Branch (1589:9): [True: 0, False: 47]
  ------------------
 1590|      0|      cur = path;
 1591|      0|      while ((cur[0] == '/') && (cur[1] == '.') && (cur[2] == '.')
  ------------------
  |  Branch (1591:14): [True: 0, False: 0]
  |  Branch (1591:33): [True: 0, False: 0]
  |  Branch (1591:52): [True: 0, False: 0]
  ------------------
 1592|      0|             && ((cur[3] == '/') || (cur[3] == '\0')))
  ------------------
  |  Branch (1592:18): [True: 0, False: 0]
  |  Branch (1592:37): [True: 0, False: 0]
  ------------------
 1593|      0|	cur += 3;
 1594|       |
 1595|      0|      if (cur != path) {
  ------------------
  |  Branch (1595:11): [True: 0, False: 0]
  ------------------
 1596|      0|	out = path;
 1597|      0|	while (cur[0] != '\0')
  ------------------
  |  Branch (1597:9): [True: 0, False: 0]
  ------------------
 1598|      0|          (out++)[0] = (cur++)[0];
 1599|      0|	out[0] = 0;
 1600|      0|      }
 1601|      0|    }
 1602|       |
 1603|     47|    return(0);
 1604|     47|}
xmlURIUnescapeString:
 1629|  1.11k|xmlURIUnescapeString(const char *str, int len, char *target) {
 1630|  1.11k|    char *ret, *out;
 1631|  1.11k|    const char *in;
 1632|       |
 1633|  1.11k|    if (str == NULL)
  ------------------
  |  Branch (1633:9): [True: 0, False: 1.11k]
  ------------------
 1634|      0|	return(NULL);
 1635|  1.11k|    if (len <= 0) len = strlen(str);
  ------------------
  |  Branch (1635:9): [True: 4, False: 1.11k]
  ------------------
 1636|  1.11k|    if (len < 0) return(NULL);
  ------------------
  |  Branch (1636:9): [True: 0, False: 1.11k]
  ------------------
 1637|       |
 1638|  1.11k|    if (target == NULL) {
  ------------------
  |  Branch (1638:9): [True: 1.11k, False: 0]
  ------------------
 1639|  1.11k|	ret = (char *) xmlMallocAtomic(len + 1);
 1640|  1.11k|	if (ret == NULL) {
  ------------------
  |  Branch (1640:6): [True: 0, False: 1.11k]
  ------------------
 1641|      0|            xmlURIErrMemory("unescaping URI value\n");
 1642|      0|	    return(NULL);
 1643|      0|	}
 1644|  1.11k|    } else
 1645|      0|	ret = target;
 1646|  1.11k|    in = str;
 1647|  1.11k|    out = ret;
 1648|  14.5k|    while(len > 0) {
  ------------------
  |  Branch (1648:11): [True: 13.3k, False: 1.11k]
  ------------------
 1649|  13.3k|	if ((len > 2) && (*in == '%') && (is_hex(in[1])) && (is_hex(in[2]))) {
  ------------------
  |  Branch (1649:6): [True: 11.1k, False: 2.21k]
  |  Branch (1649:19): [True: 0, False: 11.1k]
  |  Branch (1649:35): [True: 0, False: 0]
  |  Branch (1649:54): [True: 0, False: 0]
  ------------------
 1650|      0|            int c = 0;
 1651|      0|	    in++;
 1652|      0|	    if ((*in >= '0') && (*in <= '9'))
  ------------------
  |  Branch (1652:10): [True: 0, False: 0]
  |  Branch (1652:26): [True: 0, False: 0]
  ------------------
 1653|      0|	        c = (*in - '0');
 1654|      0|	    else if ((*in >= 'a') && (*in <= 'f'))
  ------------------
  |  Branch (1654:15): [True: 0, False: 0]
  |  Branch (1654:31): [True: 0, False: 0]
  ------------------
 1655|      0|	        c = (*in - 'a') + 10;
 1656|      0|	    else if ((*in >= 'A') && (*in <= 'F'))
  ------------------
  |  Branch (1656:15): [True: 0, False: 0]
  |  Branch (1656:31): [True: 0, False: 0]
  ------------------
 1657|      0|	        c = (*in - 'A') + 10;
 1658|      0|	    in++;
 1659|      0|	    if ((*in >= '0') && (*in <= '9'))
  ------------------
  |  Branch (1659:10): [True: 0, False: 0]
  |  Branch (1659:26): [True: 0, False: 0]
  ------------------
 1660|      0|	        c = c * 16 + (*in - '0');
 1661|      0|	    else if ((*in >= 'a') && (*in <= 'f'))
  ------------------
  |  Branch (1661:15): [True: 0, False: 0]
  |  Branch (1661:31): [True: 0, False: 0]
  ------------------
 1662|      0|	        c = c * 16 + (*in - 'a') + 10;
 1663|      0|	    else if ((*in >= 'A') && (*in <= 'F'))
  ------------------
  |  Branch (1663:15): [True: 0, False: 0]
  |  Branch (1663:31): [True: 0, False: 0]
  ------------------
 1664|      0|	        c = c * 16 + (*in - 'A') + 10;
 1665|      0|	    in++;
 1666|      0|	    len -= 3;
 1667|       |            /* Explicit sign change */
 1668|      0|	    *out++ = (char) c;
 1669|  13.3k|	} else {
 1670|  13.3k|	    *out++ = *in++;
 1671|  13.3k|	    len--;
 1672|  13.3k|	}
 1673|  13.3k|    }
 1674|  1.11k|    *out = 0;
 1675|  1.11k|    return(ret);
 1676|  1.11k|}
xmlBuildURI:
 1902|     47|xmlBuildURI(const xmlChar *URI, const xmlChar *base) {
 1903|     47|    xmlChar *val = NULL;
 1904|     47|    int ret, len, indx, cur, out;
 1905|     47|    xmlURIPtr ref = NULL;
 1906|     47|    xmlURIPtr bas = NULL;
 1907|     47|    xmlURIPtr res = NULL;
 1908|       |
 1909|       |    /*
 1910|       |     * 1) The URI reference is parsed into the potential four components and
 1911|       |     *    fragment identifier, as described in Section 4.3.
 1912|       |     *
 1913|       |     *    NOTE that a completely empty URI is treated by modern browsers
 1914|       |     *    as a reference to "." rather than as a synonym for the current
 1915|       |     *    URI.  Should we do that here?
 1916|       |     */
 1917|     47|    if (URI == NULL)
  ------------------
  |  Branch (1917:9): [True: 0, False: 47]
  ------------------
 1918|      0|	ret = -1;
 1919|     47|    else {
 1920|     47|	if (*URI) {
  ------------------
  |  Branch (1920:6): [True: 47, False: 0]
  ------------------
 1921|     47|	    ref = xmlCreateURI();
 1922|     47|	    if (ref == NULL)
  ------------------
  |  Branch (1922:10): [True: 0, False: 47]
  ------------------
 1923|      0|		goto done;
 1924|     47|	    ret = xmlParseURIReference(ref, (const char *) URI);
 1925|     47|	}
 1926|      0|	else
 1927|      0|	    ret = 0;
 1928|     47|    }
 1929|     47|    if (ret != 0)
  ------------------
  |  Branch (1929:9): [True: 0, False: 47]
  ------------------
 1930|      0|	goto done;
 1931|     47|    if ((ref != NULL) && (ref->scheme != NULL)) {
  ------------------
  |  Branch (1931:9): [True: 47, False: 0]
  |  Branch (1931:26): [True: 0, False: 47]
  ------------------
 1932|       |	/*
 1933|       |	 * The URI is absolute don't modify.
 1934|       |	 */
 1935|      0|	val = xmlStrdup(URI);
 1936|      0|	goto done;
 1937|      0|    }
 1938|     47|    if (base == NULL)
  ------------------
  |  Branch (1938:9): [True: 0, False: 47]
  ------------------
 1939|      0|	ret = -1;
 1940|     47|    else {
 1941|     47|	bas = xmlCreateURI();
 1942|     47|	if (bas == NULL)
  ------------------
  |  Branch (1942:6): [True: 0, False: 47]
  ------------------
 1943|      0|	    goto done;
 1944|     47|	ret = xmlParseURIReference(bas, (const char *) base);
 1945|     47|    }
 1946|     47|    if (ret != 0) {
  ------------------
  |  Branch (1946:9): [True: 0, False: 47]
  ------------------
 1947|      0|	if (ref)
  ------------------
  |  Branch (1947:6): [True: 0, False: 0]
  ------------------
 1948|      0|	    val = xmlSaveUri(ref);
 1949|      0|	goto done;
 1950|      0|    }
 1951|     47|    if (ref == NULL) {
  ------------------
  |  Branch (1951:9): [True: 0, False: 47]
  ------------------
 1952|       |	/*
 1953|       |	 * the base fragment must be ignored
 1954|       |	 */
 1955|      0|	if (bas->fragment != NULL) {
  ------------------
  |  Branch (1955:6): [True: 0, False: 0]
  ------------------
 1956|      0|	    xmlFree(bas->fragment);
 1957|      0|	    bas->fragment = NULL;
 1958|      0|	}
 1959|      0|	val = xmlSaveUri(bas);
 1960|      0|	goto done;
 1961|      0|    }
 1962|       |
 1963|       |    /*
 1964|       |     * 2) If the path component is empty and the scheme, authority, and
 1965|       |     *    query components are undefined, then it is a reference to the
 1966|       |     *    current document and we are done.  Otherwise, the reference URI's
 1967|       |     *    query and fragment components are defined as found (or not found)
 1968|       |     *    within the URI reference and not inherited from the base URI.
 1969|       |     *
 1970|       |     *    NOTE that in modern browsers, the parsing differs from the above
 1971|       |     *    in the following aspect:  the query component is allowed to be
 1972|       |     *    defined while still treating this as a reference to the current
 1973|       |     *    document.
 1974|       |     */
 1975|     47|    res = xmlCreateURI();
 1976|     47|    if (res == NULL)
  ------------------
  |  Branch (1976:9): [True: 0, False: 47]
  ------------------
 1977|      0|	goto done;
 1978|     47|    if ((ref->scheme == NULL) && (ref->path == NULL) &&
  ------------------
  |  Branch (1978:9): [True: 47, False: 0]
  |  Branch (1978:34): [True: 0, False: 47]
  ------------------
 1979|     47|	((ref->authority == NULL) && (ref->server == NULL) &&
  ------------------
  |  Branch (1979:3): [True: 0, False: 0]
  |  Branch (1979:31): [True: 0, False: 0]
  ------------------
 1980|      0|         (ref->port == PORT_EMPTY))) {
  ------------------
  |  |   37|      0|#define PORT_EMPTY           0
  ------------------
  |  Branch (1980:10): [True: 0, False: 0]
  ------------------
 1981|      0|	if (bas->scheme != NULL)
  ------------------
  |  Branch (1981:6): [True: 0, False: 0]
  ------------------
 1982|      0|	    res->scheme = xmlMemStrdup(bas->scheme);
 1983|      0|	if (bas->authority != NULL)
  ------------------
  |  Branch (1983:6): [True: 0, False: 0]
  ------------------
 1984|      0|	    res->authority = xmlMemStrdup(bas->authority);
 1985|      0|	else {
 1986|      0|	    if (bas->server != NULL)
  ------------------
  |  Branch (1986:10): [True: 0, False: 0]
  ------------------
 1987|      0|		res->server = xmlMemStrdup(bas->server);
 1988|      0|	    if (bas->user != NULL)
  ------------------
  |  Branch (1988:10): [True: 0, False: 0]
  ------------------
 1989|      0|		res->user = xmlMemStrdup(bas->user);
 1990|      0|	    res->port = bas->port;
 1991|      0|	}
 1992|      0|	if (bas->path != NULL)
  ------------------
  |  Branch (1992:6): [True: 0, False: 0]
  ------------------
 1993|      0|	    res->path = xmlMemStrdup(bas->path);
 1994|      0|	if (ref->query_raw != NULL)
  ------------------
  |  Branch (1994:6): [True: 0, False: 0]
  ------------------
 1995|      0|	    res->query_raw = xmlMemStrdup (ref->query_raw);
 1996|      0|	else if (ref->query != NULL)
  ------------------
  |  Branch (1996:11): [True: 0, False: 0]
  ------------------
 1997|      0|	    res->query = xmlMemStrdup(ref->query);
 1998|      0|	else if (bas->query_raw != NULL)
  ------------------
  |  Branch (1998:11): [True: 0, False: 0]
  ------------------
 1999|      0|	    res->query_raw = xmlMemStrdup(bas->query_raw);
 2000|      0|	else if (bas->query != NULL)
  ------------------
  |  Branch (2000:11): [True: 0, False: 0]
  ------------------
 2001|      0|	    res->query = xmlMemStrdup(bas->query);
 2002|      0|	if (ref->fragment != NULL)
  ------------------
  |  Branch (2002:6): [True: 0, False: 0]
  ------------------
 2003|      0|	    res->fragment = xmlMemStrdup(ref->fragment);
 2004|      0|	goto step_7;
 2005|      0|    }
 2006|       |
 2007|       |    /*
 2008|       |     * 3) If the scheme component is defined, indicating that the reference
 2009|       |     *    starts with a scheme name, then the reference is interpreted as an
 2010|       |     *    absolute URI and we are done.  Otherwise, the reference URI's
 2011|       |     *    scheme is inherited from the base URI's scheme component.
 2012|       |     */
 2013|     47|    if (ref->scheme != NULL) {
  ------------------
  |  Branch (2013:9): [True: 0, False: 47]
  ------------------
 2014|      0|	val = xmlSaveUri(ref);
 2015|      0|	goto done;
 2016|      0|    }
 2017|     47|    if (bas->scheme != NULL)
  ------------------
  |  Branch (2017:9): [True: 0, False: 47]
  ------------------
 2018|      0|	res->scheme = xmlMemStrdup(bas->scheme);
 2019|       |
 2020|     47|    if (ref->query_raw != NULL)
  ------------------
  |  Branch (2020:9): [True: 0, False: 47]
  ------------------
 2021|      0|	res->query_raw = xmlMemStrdup(ref->query_raw);
 2022|     47|    else if (ref->query != NULL)
  ------------------
  |  Branch (2022:14): [True: 0, False: 47]
  ------------------
 2023|      0|	res->query = xmlMemStrdup(ref->query);
 2024|     47|    if (ref->fragment != NULL)
  ------------------
  |  Branch (2024:9): [True: 0, False: 47]
  ------------------
 2025|      0|	res->fragment = xmlMemStrdup(ref->fragment);
 2026|       |
 2027|       |    /*
 2028|       |     * 4) If the authority component is defined, then the reference is a
 2029|       |     *    network-path and we skip to step 7.  Otherwise, the reference
 2030|       |     *    URI's authority is inherited from the base URI's authority
 2031|       |     *    component, which will also be undefined if the URI scheme does not
 2032|       |     *    use an authority component.
 2033|       |     */
 2034|     47|    if ((ref->authority != NULL) || (ref->server != NULL) ||
  ------------------
  |  Branch (2034:9): [True: 0, False: 47]
  |  Branch (2034:37): [True: 0, False: 47]
  ------------------
 2035|     47|         (ref->port != PORT_EMPTY)) {
  ------------------
  |  |   37|     47|#define PORT_EMPTY           0
  ------------------
  |  Branch (2035:10): [True: 0, False: 47]
  ------------------
 2036|      0|	if (ref->authority != NULL)
  ------------------
  |  Branch (2036:6): [True: 0, False: 0]
  ------------------
 2037|      0|	    res->authority = xmlMemStrdup(ref->authority);
 2038|      0|	else {
 2039|      0|            if (ref->server != NULL)
  ------------------
  |  Branch (2039:17): [True: 0, False: 0]
  ------------------
 2040|      0|                res->server = xmlMemStrdup(ref->server);
 2041|      0|	    if (ref->user != NULL)
  ------------------
  |  Branch (2041:10): [True: 0, False: 0]
  ------------------
 2042|      0|		res->user = xmlMemStrdup(ref->user);
 2043|      0|            res->port = ref->port;
 2044|      0|	}
 2045|      0|	if (ref->path != NULL)
  ------------------
  |  Branch (2045:6): [True: 0, False: 0]
  ------------------
 2046|      0|	    res->path = xmlMemStrdup(ref->path);
 2047|      0|	goto step_7;
 2048|      0|    }
 2049|     47|    if (bas->authority != NULL)
  ------------------
  |  Branch (2049:9): [True: 0, False: 47]
  ------------------
 2050|      0|	res->authority = xmlMemStrdup(bas->authority);
 2051|     47|    else if ((bas->server != NULL) || (bas->port != PORT_EMPTY)) {
  ------------------
  |  |   37|     47|#define PORT_EMPTY           0
  ------------------
  |  Branch (2051:14): [True: 0, False: 47]
  |  Branch (2051:39): [True: 0, False: 47]
  ------------------
 2052|      0|	if (bas->server != NULL)
  ------------------
  |  Branch (2052:6): [True: 0, False: 0]
  ------------------
 2053|      0|	    res->server = xmlMemStrdup(bas->server);
 2054|      0|	if (bas->user != NULL)
  ------------------
  |  Branch (2054:6): [True: 0, False: 0]
  ------------------
 2055|      0|	    res->user = xmlMemStrdup(bas->user);
 2056|      0|	res->port = bas->port;
 2057|      0|    }
 2058|       |
 2059|       |    /*
 2060|       |     * 5) If the path component begins with a slash character ("/"), then
 2061|       |     *    the reference is an absolute-path and we skip to step 7.
 2062|       |     */
 2063|     47|    if ((ref->path != NULL) && (ref->path[0] == '/')) {
  ------------------
  |  Branch (2063:9): [True: 47, False: 0]
  |  Branch (2063:32): [True: 0, False: 47]
  ------------------
 2064|      0|	res->path = xmlMemStrdup(ref->path);
 2065|      0|	goto step_7;
 2066|      0|    }
 2067|       |
 2068|       |
 2069|       |    /*
 2070|       |     * 6) If this step is reached, then we are resolving a relative-path
 2071|       |     *    reference.  The relative path needs to be merged with the base
 2072|       |     *    URI's path.  Although there are many ways to do this, we will
 2073|       |     *    describe a simple method using a separate string buffer.
 2074|       |     *
 2075|       |     * Allocate a buffer large enough for the result string.
 2076|       |     */
 2077|     47|    len = 2; /* extra / and 0 */
 2078|     47|    if (ref->path != NULL)
  ------------------
  |  Branch (2078:9): [True: 47, False: 0]
  ------------------
 2079|     47|	len += strlen(ref->path);
 2080|     47|    if (bas->path != NULL)
  ------------------
  |  Branch (2080:9): [True: 12, False: 35]
  ------------------
 2081|     12|	len += strlen(bas->path);
 2082|     47|    res->path = (char *) xmlMallocAtomic(len);
 2083|     47|    if (res->path == NULL) {
  ------------------
  |  Branch (2083:9): [True: 0, False: 47]
  ------------------
 2084|      0|        xmlURIErrMemory("resolving URI against base\n");
 2085|      0|	goto done;
 2086|      0|    }
 2087|     47|    res->path[0] = 0;
 2088|       |
 2089|       |    /*
 2090|       |     * a) All but the last segment of the base URI's path component is
 2091|       |     *    copied to the buffer.  In other words, any characters after the
 2092|       |     *    last (right-most) slash character, if any, are excluded.
 2093|       |     */
 2094|     47|    cur = 0;
 2095|     47|    out = 0;
 2096|     47|    if (bas->path != NULL) {
  ------------------
  |  Branch (2096:9): [True: 12, False: 35]
  ------------------
 2097|     12|	while (bas->path[cur] != 0) {
  ------------------
  |  Branch (2097:9): [True: 12, False: 0]
  ------------------
 2098|    240|	    while ((bas->path[cur] != 0) && (bas->path[cur] != '/'))
  ------------------
  |  Branch (2098:13): [True: 228, False: 12]
  |  Branch (2098:38): [True: 228, False: 0]
  ------------------
 2099|    228|		cur++;
 2100|     12|	    if (bas->path[cur] == 0)
  ------------------
  |  Branch (2100:10): [True: 12, False: 0]
  ------------------
 2101|     12|		break;
 2102|       |
 2103|      0|	    cur++;
 2104|      0|	    while (out < cur) {
  ------------------
  |  Branch (2104:13): [True: 0, False: 0]
  ------------------
 2105|      0|		res->path[out] = bas->path[out];
 2106|      0|		out++;
 2107|      0|	    }
 2108|      0|	}
 2109|     12|    }
 2110|     47|    res->path[out] = 0;
 2111|       |
 2112|       |    /*
 2113|       |     * b) The reference's path component is appended to the buffer
 2114|       |     *    string.
 2115|       |     */
 2116|     47|    if (ref->path != NULL && ref->path[0] != 0) {
  ------------------
  |  Branch (2116:9): [True: 47, False: 0]
  |  Branch (2116:30): [True: 47, False: 0]
  ------------------
 2117|     47|	indx = 0;
 2118|       |	/*
 2119|       |	 * Ensure the path includes a '/'
 2120|       |	 */
 2121|     47|	if ((out == 0) && ((bas->server != NULL) || bas->port != PORT_EMPTY))
  ------------------
  |  |   37|     47|#define PORT_EMPTY           0
  ------------------
  |  Branch (2121:6): [True: 47, False: 0]
  |  Branch (2121:21): [True: 0, False: 47]
  |  Branch (2121:46): [True: 0, False: 47]
  ------------------
 2122|      0|	    res->path[out++] = '/';
 2123|    931|	while (ref->path[indx] != 0) {
  ------------------
  |  Branch (2123:9): [True: 884, False: 47]
  ------------------
 2124|    884|	    res->path[out++] = ref->path[indx++];
 2125|    884|	}
 2126|     47|    }
 2127|     47|    res->path[out] = 0;
 2128|       |
 2129|       |    /*
 2130|       |     * Steps c) to h) are really path normalization steps
 2131|       |     */
 2132|     47|    xmlNormalizeURIPath(res->path);
 2133|       |
 2134|     47|step_7:
 2135|       |
 2136|       |    /*
 2137|       |     * 7) The resulting URI components, including any inherited from the
 2138|       |     *    base URI, are recombined to give the absolute form of the URI
 2139|       |     *    reference.
 2140|       |     */
 2141|     47|    val = xmlSaveUri(res);
 2142|       |
 2143|     47|done:
 2144|     47|    if (ref != NULL)
  ------------------
  |  Branch (2144:9): [True: 47, False: 0]
  ------------------
 2145|     47|	xmlFreeURI(ref);
 2146|     47|    if (bas != NULL)
  ------------------
  |  Branch (2146:9): [True: 47, False: 0]
  ------------------
 2147|     47|	xmlFreeURI(bas);
 2148|     47|    if (res != NULL)
  ------------------
  |  Branch (2148:9): [True: 47, False: 0]
  ------------------
 2149|     47|	xmlFreeURI(res);
 2150|     47|    return(val);
 2151|     47|}
xmlCanonicPath:
 2395|    243|{
 2396|       |/*
 2397|       | * For Windows implementations, additional work needs to be done to
 2398|       | * replace backslashes in pathnames with "forward slashes"
 2399|       | */
 2400|       |#if defined(_WIN32)
 2401|       |    int len = 0;
 2402|       |    char *p = NULL;
 2403|       |#endif
 2404|    243|    xmlURIPtr uri;
 2405|    243|    xmlChar *ret;
 2406|    243|    const xmlChar *absuri;
 2407|       |
 2408|    243|    if (path == NULL)
  ------------------
  |  Branch (2408:9): [True: 0, False: 243]
  ------------------
 2409|      0|	return(NULL);
 2410|       |
 2411|       |#if defined(_WIN32)
 2412|       |    /*
 2413|       |     * We must not change the backslashes to slashes if the the path
 2414|       |     * starts with \\?\
 2415|       |     * Those paths can be up to 32k characters long.
 2416|       |     * Was added specifically for OpenOffice, those paths can't be converted
 2417|       |     * to URIs anyway.
 2418|       |     */
 2419|       |    if ((path[0] == '\\') && (path[1] == '\\') && (path[2] == '?') &&
 2420|       |        (path[3] == '\\') )
 2421|       |	return xmlStrdup((const xmlChar *) path);
 2422|       |#endif
 2423|       |
 2424|       |	/* sanitize filename starting with // so it can be used as URI */
 2425|    243|    if ((path[0] == '/') && (path[1] == '/') && (path[2] != '/'))
  ------------------
  |  Branch (2425:9): [True: 0, False: 243]
  |  Branch (2425:29): [True: 0, False: 0]
  |  Branch (2425:49): [True: 0, False: 0]
  ------------------
 2426|      0|        path++;
 2427|       |
 2428|    243|    if ((uri = xmlParseURI((const char *) path)) != NULL) {
  ------------------
  |  Branch (2428:9): [True: 241, False: 2]
  ------------------
 2429|    241|	xmlFreeURI(uri);
 2430|    241|	return xmlStrdup(path);
 2431|    241|    }
 2432|       |
 2433|       |    /* Check if this is an "absolute uri" */
 2434|      2|    absuri = xmlStrstr(path, BAD_CAST "://");
  ------------------
  |  |   35|      2|#define BAD_CAST (xmlChar *)
  ------------------
 2435|      2|    if (absuri != NULL) {
  ------------------
  |  Branch (2435:9): [True: 0, False: 2]
  ------------------
 2436|      0|        int l, j;
 2437|      0|	unsigned char c;
 2438|      0|	xmlChar *escURI;
 2439|       |
 2440|       |        /*
 2441|       |	 * this looks like an URI where some parts have not been
 2442|       |	 * escaped leading to a parsing problem.  Check that the first
 2443|       |	 * part matches a protocol.
 2444|       |	 */
 2445|      0|	l = absuri - path;
 2446|       |	/* Bypass if first part (part before the '://') is > 20 chars */
 2447|      0|	if ((l <= 0) || (l > 20))
  ------------------
  |  Branch (2447:6): [True: 0, False: 0]
  |  Branch (2447:18): [True: 0, False: 0]
  ------------------
 2448|      0|	    goto path_processing;
 2449|       |	/* Bypass if any non-alpha characters are present in first part */
 2450|      0|	for (j = 0;j < l;j++) {
  ------------------
  |  Branch (2450:13): [True: 0, False: 0]
  ------------------
 2451|      0|	    c = path[j];
 2452|      0|	    if (!(((c >= 'a') && (c <= 'z')) || ((c >= 'A') && (c <= 'Z'))))
  ------------------
  |  Branch (2452:13): [True: 0, False: 0]
  |  Branch (2452:27): [True: 0, False: 0]
  |  Branch (2452:43): [True: 0, False: 0]
  |  Branch (2452:57): [True: 0, False: 0]
  ------------------
 2453|      0|	        goto path_processing;
 2454|      0|	}
 2455|       |
 2456|       |	/* Escape all except the characters specified in the supplied path */
 2457|      0|        escURI = xmlURIEscapeStr(path, BAD_CAST ":/?_.#&;=");
  ------------------
  |  |   35|      0|#define BAD_CAST (xmlChar *)
  ------------------
 2458|      0|	if (escURI != NULL) {
  ------------------
  |  Branch (2458:6): [True: 0, False: 0]
  ------------------
 2459|       |	    /* Try parsing the escaped path */
 2460|      0|	    uri = xmlParseURI((const char *) escURI);
 2461|       |	    /* If successful, return the escaped string */
 2462|      0|	    if (uri != NULL) {
  ------------------
  |  Branch (2462:10): [True: 0, False: 0]
  ------------------
 2463|      0|	        xmlFreeURI(uri);
 2464|      0|		return escURI;
 2465|      0|	    }
 2466|      0|            xmlFree(escURI);
 2467|      0|	}
 2468|      0|    }
 2469|       |
 2470|      2|path_processing:
 2471|       |/* For Windows implementations, replace backslashes with 'forward slashes' */
 2472|       |#if defined(_WIN32)
 2473|       |    /*
 2474|       |     * Create a URI structure
 2475|       |     */
 2476|       |    uri = xmlCreateURI();
 2477|       |    if (uri == NULL) {		/* Guard against 'out of memory' */
 2478|       |        return(NULL);
 2479|       |    }
 2480|       |
 2481|       |    len = xmlStrlen(path);
 2482|       |    if ((len > 2) && IS_WINDOWS_PATH(path)) {
 2483|       |        /* make the scheme 'file' */
 2484|       |	uri->scheme = (char *) xmlStrdup(BAD_CAST "file");
 2485|       |	/* allocate space for leading '/' + path + string terminator */
 2486|       |	uri->path = xmlMallocAtomic(len + 2);
 2487|       |	if (uri->path == NULL) {
 2488|       |	    xmlFreeURI(uri);	/* Guard against 'out of memory' */
 2489|       |	    return(NULL);
 2490|       |	}
 2491|       |	/* Put in leading '/' plus path */
 2492|       |	uri->path[0] = '/';
 2493|       |	p = uri->path + 1;
 2494|       |	strncpy(p, (char *) path, len + 1);
 2495|       |    } else {
 2496|       |	uri->path = (char *) xmlStrdup(path);
 2497|       |	if (uri->path == NULL) {
 2498|       |	    xmlFreeURI(uri);
 2499|       |	    return(NULL);
 2500|       |	}
 2501|       |	p = uri->path;
 2502|       |    }
 2503|       |    /* Now change all occurrences of '\' to '/' */
 2504|       |    while (*p != '\0') {
 2505|       |	if (*p == '\\')
 2506|       |	    *p = '/';
 2507|       |	p++;
 2508|       |    }
 2509|       |
 2510|       |    if (uri->scheme == NULL) {
 2511|       |	ret = xmlStrdup((const xmlChar *) uri->path);
 2512|       |    } else {
 2513|       |	ret = xmlSaveUri(uri);
 2514|       |    }
 2515|       |
 2516|       |    xmlFreeURI(uri);
 2517|       |#else
 2518|      2|    ret = xmlStrdup((const xmlChar *) path);
 2519|      2|#endif
 2520|      2|    return(ret);
 2521|      2|}
xmlPathToURI:
 2536|    236|{
 2537|    236|    xmlURIPtr uri;
 2538|    236|    xmlURI temp;
 2539|    236|    xmlChar *ret, *cal;
 2540|       |
 2541|    236|    if (path == NULL)
  ------------------
  |  Branch (2541:9): [True: 0, False: 236]
  ------------------
 2542|      0|        return(NULL);
 2543|       |
 2544|    236|    if ((uri = xmlParseURI((const char *) path)) != NULL) {
  ------------------
  |  Branch (2544:9): [True: 235, False: 1]
  ------------------
 2545|    235|	xmlFreeURI(uri);
 2546|    235|	return xmlStrdup(path);
 2547|    235|    }
 2548|      1|    cal = xmlCanonicPath(path);
 2549|      1|    if (cal == NULL)
  ------------------
  |  Branch (2549:9): [True: 0, False: 1]
  ------------------
 2550|      0|        return(NULL);
 2551|       |#if defined(_WIN32)
 2552|       |    /* xmlCanonicPath can return an URI on Windows (is that the intended behaviour?)
 2553|       |       If 'cal' is a valid URI already then we are done here, as continuing would make
 2554|       |       it invalid. */
 2555|       |    if ((uri = xmlParseURI((const char *) cal)) != NULL) {
 2556|       |	xmlFreeURI(uri);
 2557|       |	return cal;
 2558|       |    }
 2559|       |    /* 'cal' can contain a relative path with backslashes. If that is processed
 2560|       |       by xmlSaveURI, they will be escaped and the external entity loader machinery
 2561|       |       will fail. So convert them to slashes. Misuse 'ret' for walking. */
 2562|       |    ret = cal;
 2563|       |    while (*ret != '\0') {
 2564|       |	if (*ret == '\\')
 2565|       |	    *ret = '/';
 2566|       |	ret++;
 2567|       |    }
 2568|       |#endif
 2569|      1|    memset(&temp, 0, sizeof(temp));
 2570|      1|    temp.path = (char *) cal;
 2571|      1|    ret = xmlSaveUri(&temp);
 2572|      1|    xmlFree(cal);
 2573|      1|    return(ret);
 2574|      1|}
uri.c:xmlParse3986URIReference:
  913|  1.18k|xmlParse3986URIReference(xmlURIPtr uri, const char *str) {
  914|  1.18k|    int ret;
  915|       |
  916|  1.18k|    if (str == NULL)
  ------------------
  |  Branch (916:9): [True: 0, False: 1.18k]
  ------------------
  917|      0|	return(-1);
  918|  1.18k|    xmlCleanURI(uri);
  919|       |
  920|       |    /*
  921|       |     * Try first to parse absolute refs, then fallback to relative if
  922|       |     * it fails.
  923|       |     */
  924|  1.18k|    ret = xmlParse3986URI(uri, str);
  925|  1.18k|    if (ret != 0) {
  ------------------
  |  Branch (925:9): [True: 625, False: 559]
  ------------------
  926|    625|	xmlCleanURI(uri);
  927|    625|        ret = xmlParse3986RelativeRef(uri, str);
  928|    625|	if (ret != 0) {
  ------------------
  |  Branch (928:6): [True: 5, False: 620]
  ------------------
  929|      5|	    xmlCleanURI(uri);
  930|      5|	    return(ret);
  931|      5|	}
  932|    625|    }
  933|  1.17k|    return(0);
  934|  1.18k|}
uri.c:xmlCleanURI:
 1366|  1.82k|xmlCleanURI(xmlURIPtr uri) {
 1367|  1.82k|    if (uri == NULL) return;
  ------------------
  |  Branch (1367:9): [True: 0, False: 1.82k]
  ------------------
 1368|       |
 1369|  1.82k|    if (uri->scheme != NULL) xmlFree(uri->scheme);
  ------------------
  |  Branch (1369:9): [True: 83, False: 1.73k]
  ------------------
 1370|  1.82k|    uri->scheme = NULL;
 1371|  1.82k|    if (uri->server != NULL) xmlFree(uri->server);
  ------------------
  |  Branch (1371:9): [True: 0, False: 1.82k]
  ------------------
 1372|  1.82k|    uri->server = NULL;
 1373|  1.82k|    if (uri->user != NULL) xmlFree(uri->user);
  ------------------
  |  Branch (1373:9): [True: 0, False: 1.82k]
  ------------------
 1374|  1.82k|    uri->user = NULL;
 1375|  1.82k|    if (uri->path != NULL) xmlFree(uri->path);
  ------------------
  |  Branch (1375:9): [True: 2, False: 1.81k]
  ------------------
 1376|  1.82k|    uri->path = NULL;
 1377|  1.82k|    if (uri->fragment != NULL) xmlFree(uri->fragment);
  ------------------
  |  Branch (1377:9): [True: 0, False: 1.82k]
  ------------------
 1378|  1.82k|    uri->fragment = NULL;
 1379|  1.82k|    if (uri->opaque != NULL) xmlFree(uri->opaque);
  ------------------
  |  Branch (1379:9): [True: 0, False: 1.82k]
  ------------------
 1380|  1.82k|    uri->opaque = NULL;
 1381|  1.82k|    if (uri->authority != NULL) xmlFree(uri->authority);
  ------------------
  |  Branch (1381:9): [True: 0, False: 1.82k]
  ------------------
 1382|  1.82k|    uri->authority = NULL;
 1383|  1.82k|    if (uri->query != NULL) xmlFree(uri->query);
  ------------------
  |  Branch (1383:9): [True: 0, False: 1.82k]
  ------------------
 1384|  1.82k|    uri->query = NULL;
 1385|  1.82k|    if (uri->query_raw != NULL) xmlFree(uri->query_raw);
  ------------------
  |  Branch (1385:9): [True: 0, False: 1.82k]
  ------------------
 1386|  1.82k|    uri->query_raw = NULL;
 1387|  1.82k|}
uri.c:xmlParse3986URI:
  872|  1.18k|xmlParse3986URI(xmlURIPtr uri, const char *str) {
  873|  1.18k|    int ret;
  874|       |
  875|  1.18k|    ret = xmlParse3986Scheme(uri, &str);
  876|  1.18k|    if (ret != 0) return(ret);
  ------------------
  |  Branch (876:9): [True: 542, False: 642]
  ------------------
  877|    642|    if (*str != ':') {
  ------------------
  |  Branch (877:9): [True: 82, False: 560]
  ------------------
  878|     82|	return(1);
  879|     82|    }
  880|    560|    str++;
  881|    560|    ret = xmlParse3986HierPart(uri, &str);
  882|    560|    if (ret != 0) return(ret);
  ------------------
  |  Branch (882:9): [True: 0, False: 560]
  ------------------
  883|    560|    if (*str == '?') {
  ------------------
  |  Branch (883:9): [True: 0, False: 560]
  ------------------
  884|      0|	str++;
  885|      0|	ret = xmlParse3986Query(uri, &str);
  886|      0|	if (ret != 0) return(ret);
  ------------------
  |  Branch (886:6): [True: 0, False: 0]
  ------------------
  887|      0|    }
  888|    560|    if (*str == '#') {
  ------------------
  |  Branch (888:9): [True: 5, False: 555]
  ------------------
  889|      5|	str++;
  890|      5|	ret = xmlParse3986Fragment(uri, &str);
  891|      5|	if (ret != 0) return(ret);
  ------------------
  |  Branch (891:6): [True: 0, False: 5]
  ------------------
  892|      5|    }
  893|    560|    if (*str != 0) {
  ------------------
  |  Branch (893:9): [True: 1, False: 559]
  ------------------
  894|      1|	xmlCleanURI(uri);
  895|      1|	return(1);
  896|      1|    }
  897|    559|    return(0);
  898|    560|}
uri.c:xmlParse3986Scheme:
  213|  1.18k|xmlParse3986Scheme(xmlURIPtr uri, const char **str) {
  214|  1.18k|    const char *cur;
  215|       |
  216|  1.18k|    if (str == NULL)
  ------------------
  |  Branch (216:9): [True: 0, False: 1.18k]
  ------------------
  217|      0|	return(-1);
  218|       |
  219|  1.18k|    cur = *str;
  220|  1.18k|    if (!ISA_ALPHA(cur))
  ------------------
  |  |  152|  1.18k|#define ISA_ALPHA(p) (((*(p) >= 'a') && (*(p) <= 'z')) ||		\
  |  |  ------------------
  |  |  |  Branch (152:24): [True: 642, False: 542]
  |  |  |  Branch (152:41): [True: 642, False: 0]
  |  |  ------------------
  |  |  153|  1.18k|                      ((*(p) >= 'A') && (*(p) <= 'Z')))
  |  |  ------------------
  |  |  |  Branch (153:24): [True: 0, False: 542]
  |  |  |  Branch (153:41): [True: 0, False: 0]
  |  |  ------------------
  ------------------
  221|    542|	return(2);
  222|    642|    cur++;
  223|  3.28k|    while (ISA_ALPHA(cur) || ISA_DIGIT(cur) ||
  ------------------
  |  |  152|  6.57k|#define ISA_ALPHA(p) (((*(p) >= 'a') && (*(p) <= 'z')) ||		\
  |  |  ------------------
  |  |  |  Branch (152:24): [True: 2.35k, False: 934]
  |  |  |  Branch (152:41): [True: 2.35k, False: 0]
  |  |  ------------------
  |  |  153|  6.57k|                      ((*(p) >= 'A') && (*(p) <= 'Z')))
  |  |  ------------------
  |  |  |  Branch (153:24): [True: 109, False: 825]
  |  |  |  Branch (153:41): [True: 57, False: 52]
  |  |  ------------------
  ------------------
                  while (ISA_ALPHA(cur) || ISA_DIGIT(cur) ||
  ------------------
  |  |  151|  4.16k|#define ISA_DIGIT(p) ((*(p) >= '0') && (*(p) <= '9'))
  |  |  ------------------
  |  |  |  Branch (151:23): [True: 753, False: 124]
  |  |  |  Branch (151:40): [True: 141, False: 612]
  |  |  ------------------
  ------------------
  224|  3.28k|           (*cur == '+') || (*cur == '-') || (*cur == '.')) cur++;
  ------------------
  |  Branch (224:12): [True: 0, False: 736]
  |  Branch (224:29): [True: 10, False: 726]
  |  Branch (224:46): [True: 84, False: 642]
  ------------------
  225|    642|    if (uri != NULL) {
  ------------------
  |  Branch (225:9): [True: 642, False: 0]
  ------------------
  226|    642|	if (uri->scheme != NULL) xmlFree(uri->scheme);
  ------------------
  |  Branch (226:6): [True: 0, False: 642]
  ------------------
  227|    642|	uri->scheme = STRNDUP(*str, cur - *str);
  ------------------
  |  |  143|    642|#define STRNDUP(s, n) (char *) xmlStrndup((const xmlChar *)(s), (n))
  ------------------
  228|    642|    }
  229|    642|    *str = cur;
  230|    642|    return(0);
  231|  1.18k|}
uri.c:xmlParse3986HierPart:
  765|    560|{
  766|    560|    const char *cur;
  767|    560|    int ret;
  768|       |
  769|    560|    cur = *str;
  770|       |
  771|    560|    if ((*cur == '/') && (*(cur + 1) == '/')) {
  ------------------
  |  Branch (771:9): [True: 540, False: 20]
  |  Branch (771:26): [True: 540, False: 0]
  ------------------
  772|    540|        cur += 2;
  773|    540|	ret = xmlParse3986Authority(uri, &cur);
  774|    540|	if (ret != 0) return(ret);
  ------------------
  |  Branch (774:6): [True: 0, False: 540]
  ------------------
  775|       |        /*
  776|       |         * An empty server is marked with a special URI value.
  777|       |         */
  778|    540|	if ((uri->server == NULL) && (uri->port == PORT_EMPTY))
  ------------------
  |  |   37|      0|#define PORT_EMPTY           0
  ------------------
  |  Branch (778:6): [True: 0, False: 540]
  |  Branch (778:31): [True: 0, False: 0]
  ------------------
  779|      0|	    uri->port = PORT_EMPTY_SERVER;
  ------------------
  |  |   38|      0|#define PORT_EMPTY_SERVER   -1
  ------------------
  780|    540|	ret = xmlParse3986PathAbEmpty(uri, &cur);
  781|    540|	if (ret != 0) return(ret);
  ------------------
  |  Branch (781:6): [True: 0, False: 540]
  ------------------
  782|    540|	*str = cur;
  783|    540|	return(0);
  784|    540|    } else if (*cur == '/') {
  ------------------
  |  Branch (784:16): [True: 0, False: 20]
  ------------------
  785|      0|        ret = xmlParse3986PathAbsolute(uri, &cur);
  786|      0|	if (ret != 0) return(ret);
  ------------------
  |  Branch (786:6): [True: 0, False: 0]
  ------------------
  787|     20|    } else if (ISA_PCHAR(cur)) {
  ------------------
  |  |  198|     20|     (ISA_UNRESERVED(p) || ISA_PCT_ENCODED(p) || ISA_SUB_DELIM(p) ||	\
  |  |  ------------------
  |  |  |  |  185|     40|      ((ISA_ALPHA(p)) || (ISA_DIGIT(p)) || ((*(p) == '-')) ||		\
  |  |  |  |  ------------------
  |  |  |  |  |  |  152|     20|#define ISA_ALPHA(p) (((*(p) >= 'a') && (*(p) <= 'z')) ||		\
  |  |  |  |  |  |  ------------------
  |  |  |  |  |  |  |  Branch (152:24): [True: 19, False: 1]
  |  |  |  |  |  |  |  Branch (152:41): [True: 19, False: 0]
  |  |  |  |  |  |  ------------------
  |  |  |  |  |  |  153|     20|                      ((*(p) >= 'A') && (*(p) <= 'Z')))
  |  |  |  |  |  |  ------------------
  |  |  |  |  |  |  |  Branch (153:24): [True: 0, False: 1]
  |  |  |  |  |  |  |  Branch (153:41): [True: 0, False: 0]
  |  |  |  |  |  |  ------------------
  |  |  |  |  ------------------
  |  |  |  |                     ((ISA_ALPHA(p)) || (ISA_DIGIT(p)) || ((*(p) == '-')) ||		\
  |  |  |  |  ------------------
  |  |  |  |  |  |  151|      1|#define ISA_DIGIT(p) ((*(p) >= '0') && (*(p) <= '9'))
  |  |  |  |  |  |  ------------------
  |  |  |  |  |  |  |  Branch (151:23): [True: 1, False: 0]
  |  |  |  |  |  |  |  Branch (151:40): [True: 0, False: 1]
  |  |  |  |  |  |  ------------------
  |  |  |  |  ------------------
  |  |  |  |  |  Branch (185:44): [True: 0, False: 1]
  |  |  |  |  ------------------
  |  |  |  |  186|     20|       ((*(p) == '.')) || ((*(p) == '_')) || ((*(p) == '~')))
  |  |  |  |  ------------------
  |  |  |  |  |  Branch (186:8): [True: 0, False: 1]
  |  |  |  |  |  Branch (186:27): [True: 0, False: 1]
  |  |  |  |  |  Branch (186:46): [True: 0, False: 1]
  |  |  |  |  ------------------
  |  |  ------------------
  |  |                    (ISA_UNRESERVED(p) || ISA_PCT_ENCODED(p) || ISA_SUB_DELIM(p) ||	\
  |  |  ------------------
  |  |  |  |  192|     21|     ((*(p) == '%') && (ISA_HEXDIG(p + 1)) && (ISA_HEXDIG(p + 2)))
  |  |  |  |  ------------------
  |  |  |  |  |  |  155|      0|       (ISA_DIGIT(p) || ((*(p) >= 'a') && (*(p) <= 'f')) ||		\
  |  |  |  |  |  |  ------------------
  |  |  |  |  |  |  |  |  151|      0|#define ISA_DIGIT(p) ((*(p) >= '0') && (*(p) <= '9'))
  |  |  |  |  |  |  |  |  ------------------
  |  |  |  |  |  |  |  |  |  Branch (151:23): [True: 0, False: 0]
  |  |  |  |  |  |  |  |  |  Branch (151:40): [True: 0, False: 0]
  |  |  |  |  |  |  |  |  ------------------
  |  |  |  |  |  |  ------------------
  |  |  |  |  |  |  |  Branch (155:26): [True: 0, False: 0]
  |  |  |  |  |  |  |  Branch (155:43): [True: 0, False: 0]
  |  |  |  |  |  |  ------------------
  |  |  |  |  |  |  156|      0|        ((*(p) >= 'A') && (*(p) <= 'F')))
  |  |  |  |  |  |  ------------------
  |  |  |  |  |  |  |  Branch (156:10): [True: 0, False: 0]
  |  |  |  |  |  |  |  Branch (156:27): [True: 0, False: 0]
  |  |  |  |  |  |  ------------------
  |  |  |  |  ------------------
  |  |  |  |                    ((*(p) == '%') && (ISA_HEXDIG(p + 1)) && (ISA_HEXDIG(p + 2)))
  |  |  |  |  ------------------
  |  |  |  |  |  |  155|      0|       (ISA_DIGIT(p) || ((*(p) >= 'a') && (*(p) <= 'f')) ||		\
  |  |  |  |  |  |  ------------------
  |  |  |  |  |  |  |  |  151|      0|#define ISA_DIGIT(p) ((*(p) >= '0') && (*(p) <= '9'))
  |  |  |  |  |  |  |  |  ------------------
  |  |  |  |  |  |  |  |  |  Branch (151:23): [True: 0, False: 0]
  |  |  |  |  |  |  |  |  |  Branch (151:40): [True: 0, False: 0]
  |  |  |  |  |  |  |  |  ------------------
  |  |  |  |  |  |  ------------------
  |  |  |  |  |  |  |  Branch (155:26): [True: 0, False: 0]
  |  |  |  |  |  |  |  Branch (155:43): [True: 0, False: 0]
  |  |  |  |  |  |  ------------------
  |  |  |  |  |  |  156|      0|        ((*(p) >= 'A') && (*(p) <= 'F')))
  |  |  |  |  |  |  ------------------
  |  |  |  |  |  |  |  Branch (156:10): [True: 0, False: 0]
  |  |  |  |  |  |  |  Branch (156:27): [True: 0, False: 0]
  |  |  |  |  |  |  ------------------
  |  |  |  |  ------------------
  |  |  |  |  |  Branch (192:7): [True: 0, False: 1]
  |  |  |  |  ------------------
  |  |  ------------------
  |  |                    (ISA_UNRESERVED(p) || ISA_PCT_ENCODED(p) || ISA_SUB_DELIM(p) ||	\
  |  |  ------------------
  |  |  |  |  163|     21|      (((*(p) == '!')) || ((*(p) == '$')) || ((*(p) == '&')) ||		\
  |  |  |  |  ------------------
  |  |  |  |  |  Branch (163:8): [True: 0, False: 1]
  |  |  |  |  |  Branch (163:27): [True: 0, False: 1]
  |  |  |  |  |  Branch (163:46): [True: 0, False: 1]
  |  |  |  |  ------------------
  |  |  |  |  164|      1|       ((*(p) == '(')) || ((*(p) == ')')) || ((*(p) == '*')) ||		\
  |  |  |  |  ------------------
  |  |  |  |  |  Branch (164:8): [True: 0, False: 1]
  |  |  |  |  |  Branch (164:27): [True: 0, False: 1]
  |  |  |  |  |  Branch (164:46): [True: 0, False: 1]
  |  |  |  |  ------------------
  |  |  |  |  165|      1|       ((*(p) == '+')) || ((*(p) == ',')) || ((*(p) == ';')) ||		\
  |  |  |  |  ------------------
  |  |  |  |  |  Branch (165:8): [True: 0, False: 1]
  |  |  |  |  |  Branch (165:27): [True: 0, False: 1]
  |  |  |  |  |  Branch (165:46): [True: 0, False: 1]
  |  |  |  |  ------------------
  |  |  |  |  166|      1|       ((*(p) == '=')) || ((*(p) == '\'')))
  |  |  |  |  ------------------
  |  |  |  |  |  Branch (166:8): [True: 0, False: 1]
  |  |  |  |  |  Branch (166:27): [True: 0, False: 1]
  |  |  |  |  ------------------
  |  |  ------------------
  |  |  199|     20|      ((*(p) == ':')) || ((*(p) == '@')))
  |  |  ------------------
  |  |  |  Branch (199:7): [True: 0, False: 1]
  |  |  |  Branch (199:26): [True: 0, False: 1]
  |  |  ------------------
  ------------------
  788|     19|        ret = xmlParse3986PathRootless(uri, &cur);
  789|     19|	if (ret != 0) return(ret);
  ------------------
  |  Branch (789:6): [True: 0, False: 19]
  ------------------
  790|     19|    } else {
  791|       |	/* path-empty is effectively empty */
  792|      1|	if (uri != NULL) {
  ------------------
  |  Branch (792:6): [True: 1, False: 0]
  ------------------
  793|      1|	    if (uri->path != NULL) xmlFree(uri->path);
  ------------------
  |  Branch (793:10): [True: 0, False: 1]
  ------------------
  794|      1|	    uri->path = NULL;
  795|      1|	}
  796|      1|    }
  797|     20|    *str = cur;
  798|     20|    return (0);
  799|    560|}
uri.c:xmlParse3986Authority:
  521|    540|{
  522|    540|    const char *cur;
  523|    540|    int ret;
  524|       |
  525|    540|    cur = *str;
  526|       |    /*
  527|       |     * try to parse an userinfo and check for the trailing @
  528|       |     */
  529|    540|    ret = xmlParse3986Userinfo(uri, &cur);
  530|    540|    if ((ret != 0) || (*cur != '@'))
  ------------------
  |  Branch (530:9): [True: 540, False: 0]
  |  Branch (530:23): [True: 0, False: 0]
  ------------------
  531|    540|        cur = *str;
  532|      0|    else
  533|      0|        cur++;
  534|    540|    ret = xmlParse3986Host(uri, &cur);
  535|    540|    if (ret != 0) return(ret);
  ------------------
  |  Branch (535:9): [True: 0, False: 540]
  ------------------
  536|    540|    if (*cur == ':') {
  ------------------
  |  Branch (536:9): [True: 0, False: 540]
  ------------------
  537|      0|        cur++;
  538|      0|        ret = xmlParse3986Port(uri, &cur);
  539|      0|	if (ret != 0) return(ret);
  ------------------
  |  Branch (539:6): [True: 0, False: 0]
  ------------------
  540|      0|    }
  541|    540|    *str = cur;
  542|    540|    return(0);
  543|    540|}
uri.c:xmlParse3986Userinfo:
  370|    540|{
  371|    540|    const char *cur;
  372|       |
  373|    540|    cur = *str;
  374|  5.05k|    while (ISA_UNRESERVED(cur) || ISA_PCT_ENCODED(cur) ||
  ------------------
  |  |  185|  10.1k|      ((ISA_ALPHA(p)) || (ISA_DIGIT(p)) || ((*(p) == '-')) ||		\
  |  |  ------------------
  |  |  |  |  152|  5.05k|#define ISA_ALPHA(p) (((*(p) >= 'a') && (*(p) <= 'z')) ||		\
  |  |  |  |  ------------------
  |  |  |  |  |  Branch (152:24): [True: 3.11k, False: 1.94k]
  |  |  |  |  |  Branch (152:41): [True: 3.11k, False: 0]
  |  |  |  |  ------------------
  |  |  |  |  153|  5.05k|                      ((*(p) >= 'A') && (*(p) <= 'Z')))
  |  |  |  |  ------------------
  |  |  |  |  |  Branch (153:24): [True: 486, False: 1.45k]
  |  |  |  |  |  Branch (153:41): [True: 486, False: 0]
  |  |  |  |  ------------------
  |  |  ------------------
  |  |                     ((ISA_ALPHA(p)) || (ISA_DIGIT(p)) || ((*(p) == '-')) ||		\
  |  |  ------------------
  |  |  |  |  151|  1.45k|#define ISA_DIGIT(p) ((*(p) >= '0') && (*(p) <= '9'))
  |  |  |  |  ------------------
  |  |  |  |  |  Branch (151:23): [True: 247, False: 1.20k]
  |  |  |  |  |  Branch (151:40): [True: 247, False: 0]
  |  |  |  |  ------------------
  |  |  ------------------
  |  |  |  Branch (185:44): [True: 8, False: 1.20k]
  |  |  ------------------
  |  |  186|  5.05k|       ((*(p) == '.')) || ((*(p) == '_')) || ((*(p) == '~')))
  |  |  ------------------
  |  |  |  Branch (186:8): [True: 660, False: 540]
  |  |  |  Branch (186:27): [True: 0, False: 540]
  |  |  |  Branch (186:46): [True: 0, False: 540]
  |  |  ------------------
  ------------------
                  while (ISA_UNRESERVED(cur) || ISA_PCT_ENCODED(cur) ||
  ------------------
  |  |  192|  5.59k|     ((*(p) == '%') && (ISA_HEXDIG(p + 1)) && (ISA_HEXDIG(p + 2)))
  |  |  ------------------
  |  |  |  |  155|      0|       (ISA_DIGIT(p) || ((*(p) >= 'a') && (*(p) <= 'f')) ||		\
  |  |  |  |  ------------------
  |  |  |  |  |  |  151|      0|#define ISA_DIGIT(p) ((*(p) >= '0') && (*(p) <= '9'))
  |  |  |  |  |  |  ------------------
  |  |  |  |  |  |  |  Branch (151:23): [True: 0, False: 0]
  |  |  |  |  |  |  |  Branch (151:40): [True: 0, False: 0]
  |  |  |  |  |  |  ------------------
  |  |  |  |  ------------------
  |  |  |  |  |  Branch (155:26): [True: 0, False: 0]
  |  |  |  |  |  Branch (155:43): [True: 0, False: 0]
  |  |  |  |  ------------------
  |  |  |  |  156|      0|        ((*(p) >= 'A') && (*(p) <= 'F')))
  |  |  |  |  ------------------
  |  |  |  |  |  Branch (156:10): [True: 0, False: 0]
  |  |  |  |  |  Branch (156:27): [True: 0, False: 0]
  |  |  |  |  ------------------
  |  |  ------------------
  |  |                    ((*(p) == '%') && (ISA_HEXDIG(p + 1)) && (ISA_HEXDIG(p + 2)))
  |  |  ------------------
  |  |  |  |  155|      0|       (ISA_DIGIT(p) || ((*(p) >= 'a') && (*(p) <= 'f')) ||		\
  |  |  |  |  ------------------
  |  |  |  |  |  |  151|      0|#define ISA_DIGIT(p) ((*(p) >= '0') && (*(p) <= '9'))
  |  |  |  |  |  |  ------------------
  |  |  |  |  |  |  |  Branch (151:23): [True: 0, False: 0]
  |  |  |  |  |  |  |  Branch (151:40): [True: 0, False: 0]
  |  |  |  |  |  |  ------------------
  |  |  |  |  ------------------
  |  |  |  |  |  Branch (155:26): [True: 0, False: 0]
  |  |  |  |  |  Branch (155:43): [True: 0, False: 0]
  |  |  |  |  ------------------
  |  |  |  |  156|      0|        ((*(p) >= 'A') && (*(p) <= 'F')))
  |  |  |  |  ------------------
  |  |  |  |  |  Branch (156:10): [True: 0, False: 0]
  |  |  |  |  |  Branch (156:27): [True: 0, False: 0]
  |  |  |  |  ------------------
  |  |  ------------------
  |  |  |  Branch (192:7): [True: 0, False: 540]
  |  |  ------------------
  ------------------
  375|  5.05k|           ISA_SUB_DELIM(cur) || (*cur == ':'))
  ------------------
  |  |  163|  5.59k|      (((*(p) == '!')) || ((*(p) == '$')) || ((*(p) == '&')) ||		\
  |  |  ------------------
  |  |  |  Branch (163:8): [True: 0, False: 540]
  |  |  |  Branch (163:27): [True: 0, False: 540]
  |  |  |  Branch (163:46): [True: 0, False: 540]
  |  |  ------------------
  |  |  164|    540|       ((*(p) == '(')) || ((*(p) == ')')) || ((*(p) == '*')) ||		\
  |  |  ------------------
  |  |  |  Branch (164:8): [True: 0, False: 540]
  |  |  |  Branch (164:27): [True: 0, False: 540]
  |  |  |  Branch (164:46): [True: 0, False: 540]
  |  |  ------------------
  |  |  165|    540|       ((*(p) == '+')) || ((*(p) == ',')) || ((*(p) == ';')) ||		\
  |  |  ------------------
  |  |  |  Branch (165:8): [True: 0, False: 540]
  |  |  |  Branch (165:27): [True: 0, False: 540]
  |  |  |  Branch (165:46): [True: 0, False: 540]
  |  |  ------------------
  |  |  166|    540|       ((*(p) == '=')) || ((*(p) == '\'')))
  |  |  ------------------
  |  |  |  Branch (166:8): [True: 0, False: 540]
  |  |  |  Branch (166:27): [True: 0, False: 540]
  |  |  ------------------
  ------------------
  |  Branch (375:34): [True: 0, False: 540]
  ------------------
  376|  4.51k|	NEXT(cur);
  ------------------
  |  |  131|  4.51k|#define NEXT(p) ((*p == '%')? p += 3 : p++)
  |  |  ------------------
  |  |  |  Branch (131:18): [True: 0, False: 4.51k]
  |  |  ------------------
  ------------------
  377|    540|    if (*cur == '@') {
  ------------------
  |  Branch (377:9): [True: 0, False: 540]
  ------------------
  378|      0|	if (uri != NULL) {
  ------------------
  |  Branch (378:6): [True: 0, False: 0]
  ------------------
  379|      0|	    if (uri->user != NULL) xmlFree(uri->user);
  ------------------
  |  Branch (379:10): [True: 0, False: 0]
  ------------------
  380|      0|	    if (uri->cleanup & 2)
  ------------------
  |  Branch (380:10): [True: 0, False: 0]
  ------------------
  381|      0|		uri->user = STRNDUP(*str, cur - *str);
  ------------------
  |  |  143|      0|#define STRNDUP(s, n) (char *) xmlStrndup((const xmlChar *)(s), (n))
  ------------------
  382|      0|	    else
  383|      0|		uri->user = xmlURIUnescapeString(*str, cur - *str, NULL);
  384|      0|	}
  385|      0|	*str = cur;
  386|      0|	return(0);
  387|      0|    }
  388|    540|    return(1);
  389|    540|}
uri.c:xmlParse3986Host:
  445|    540|{
  446|    540|    const char *cur = *str;
  447|    540|    const char *host;
  448|       |
  449|    540|    host = cur;
  450|       |    /*
  451|       |     * IPv6 and future addressing scheme are enclosed between brackets
  452|       |     */
  453|    540|    if (*cur == '[') {
  ------------------
  |  Branch (453:9): [True: 0, False: 540]
  ------------------
  454|      0|        cur++;
  455|      0|	while ((*cur != ']') && (*cur != 0))
  ------------------
  |  Branch (455:9): [True: 0, False: 0]
  |  Branch (455:26): [True: 0, False: 0]
  ------------------
  456|      0|	    cur++;
  457|      0|	if (*cur != ']')
  ------------------
  |  Branch (457:6): [True: 0, False: 0]
  ------------------
  458|      0|	    return(1);
  459|      0|	cur++;
  460|      0|	goto found;
  461|      0|    }
  462|       |    /*
  463|       |     * try to parse an IPv4
  464|       |     */
  465|    540|    if (ISA_DIGIT(cur)) {
  ------------------
  |  |  151|    540|#define ISA_DIGIT(p) ((*(p) >= '0') && (*(p) <= '9'))
  |  |  ------------------
  |  |  |  Branch (151:23): [True: 540, False: 0]
  |  |  |  Branch (151:40): [True: 0, False: 540]
  |  |  ------------------
  ------------------
  466|      0|        if (xmlParse3986DecOctet(&cur) != 0)
  ------------------
  |  Branch (466:13): [True: 0, False: 0]
  ------------------
  467|      0|	    goto not_ipv4;
  468|      0|	if (*cur != '.')
  ------------------
  |  Branch (468:6): [True: 0, False: 0]
  ------------------
  469|      0|	    goto not_ipv4;
  470|      0|	cur++;
  471|      0|        if (xmlParse3986DecOctet(&cur) != 0)
  ------------------
  |  Branch (471:13): [True: 0, False: 0]
  ------------------
  472|      0|	    goto not_ipv4;
  473|      0|	if (*cur != '.')
  ------------------
  |  Branch (473:6): [True: 0, False: 0]
  ------------------
  474|      0|	    goto not_ipv4;
  475|      0|        if (xmlParse3986DecOctet(&cur) != 0)
  ------------------
  |  Branch (475:13): [True: 0, False: 0]
  ------------------
  476|      0|	    goto not_ipv4;
  477|      0|	if (*cur != '.')
  ------------------
  |  Branch (477:6): [True: 0, False: 0]
  ------------------
  478|      0|	    goto not_ipv4;
  479|      0|        if (xmlParse3986DecOctet(&cur) != 0)
  ------------------
  |  Branch (479:13): [True: 0, False: 0]
  ------------------
  480|      0|	    goto not_ipv4;
  481|      0|	goto found;
  482|      0|not_ipv4:
  483|      0|        cur = *str;
  484|      0|    }
  485|       |    /*
  486|       |     * then this should be a hostname which can be empty
  487|       |     */
  488|  5.05k|    while (ISA_UNRESERVED(cur) || ISA_PCT_ENCODED(cur) || ISA_SUB_DELIM(cur))
  ------------------
  |  |  185|  10.1k|      ((ISA_ALPHA(p)) || (ISA_DIGIT(p)) || ((*(p) == '-')) ||		\
  |  |  ------------------
  |  |  |  |  152|  5.05k|#define ISA_ALPHA(p) (((*(p) >= 'a') && (*(p) <= 'z')) ||		\
  |  |  |  |  ------------------
  |  |  |  |  |  Branch (152:24): [True: 3.11k, False: 1.94k]
  |  |  |  |  |  Branch (152:41): [True: 3.11k, False: 0]
  |  |  |  |  ------------------
  |  |  |  |  153|  5.05k|                      ((*(p) >= 'A') && (*(p) <= 'Z')))
  |  |  |  |  ------------------
  |  |  |  |  |  Branch (153:24): [True: 486, False: 1.45k]
  |  |  |  |  |  Branch (153:41): [True: 486, False: 0]
  |  |  |  |  ------------------
  |  |  ------------------
  |  |                     ((ISA_ALPHA(p)) || (ISA_DIGIT(p)) || ((*(p) == '-')) ||		\
  |  |  ------------------
  |  |  |  |  151|  1.45k|#define ISA_DIGIT(p) ((*(p) >= '0') && (*(p) <= '9'))
  |  |  |  |  ------------------
  |  |  |  |  |  Branch (151:23): [True: 247, False: 1.20k]
  |  |  |  |  |  Branch (151:40): [True: 247, False: 0]
  |  |  |  |  ------------------
  |  |  ------------------
  |  |  |  Branch (185:44): [True: 8, False: 1.20k]
  |  |  ------------------
  |  |  186|  5.05k|       ((*(p) == '.')) || ((*(p) == '_')) || ((*(p) == '~')))
  |  |  ------------------
  |  |  |  Branch (186:8): [True: 660, False: 540]
  |  |  |  Branch (186:27): [True: 0, False: 540]
  |  |  |  Branch (186:46): [True: 0, False: 540]
  |  |  ------------------
  ------------------
                  while (ISA_UNRESERVED(cur) || ISA_PCT_ENCODED(cur) || ISA_SUB_DELIM(cur))
  ------------------
  |  |  192|  5.59k|     ((*(p) == '%') && (ISA_HEXDIG(p + 1)) && (ISA_HEXDIG(p + 2)))
  |  |  ------------------
  |  |  |  |  155|      0|       (ISA_DIGIT(p) || ((*(p) >= 'a') && (*(p) <= 'f')) ||		\
  |  |  |  |  ------------------
  |  |  |  |  |  |  151|      0|#define ISA_DIGIT(p) ((*(p) >= '0') && (*(p) <= '9'))
  |  |  |  |  |  |  ------------------
  |  |  |  |  |  |  |  Branch (151:23): [True: 0, False: 0]
  |  |  |  |  |  |  |  Branch (151:40): [True: 0, False: 0]
  |  |  |  |  |  |  ------------------
  |  |  |  |  ------------------
  |  |  |  |  |  Branch (155:26): [True: 0, False: 0]
  |  |  |  |  |  Branch (155:43): [True: 0, False: 0]
  |  |  |  |  ------------------
  |  |  |  |  156|      0|        ((*(p) >= 'A') && (*(p) <= 'F')))
  |  |  |  |  ------------------
  |  |  |  |  |  Branch (156:10): [True: 0, False: 0]
  |  |  |  |  |  Branch (156:27): [True: 0, False: 0]
  |  |  |  |  ------------------
  |  |  ------------------
  |  |                    ((*(p) == '%') && (ISA_HEXDIG(p + 1)) && (ISA_HEXDIG(p + 2)))
  |  |  ------------------
  |  |  |  |  155|      0|       (ISA_DIGIT(p) || ((*(p) >= 'a') && (*(p) <= 'f')) ||		\
  |  |  |  |  ------------------
  |  |  |  |  |  |  151|      0|#define ISA_DIGIT(p) ((*(p) >= '0') && (*(p) <= '9'))
  |  |  |  |  |  |  ------------------
  |  |  |  |  |  |  |  Branch (151:23): [True: 0, False: 0]
  |  |  |  |  |  |  |  Branch (151:40): [True: 0, False: 0]
  |  |  |  |  |  |  ------------------
  |  |  |  |  ------------------
  |  |  |  |  |  Branch (155:26): [True: 0, False: 0]
  |  |  |  |  |  Branch (155:43): [True: 0, False: 0]
  |  |  |  |  ------------------
  |  |  |  |  156|      0|        ((*(p) >= 'A') && (*(p) <= 'F')))
  |  |  |  |  ------------------
  |  |  |  |  |  Branch (156:10): [True: 0, False: 0]
  |  |  |  |  |  Branch (156:27): [True: 0, False: 0]
  |  |  |  |  ------------------
  |  |  ------------------
  |  |  |  Branch (192:7): [True: 0, False: 540]
  |  |  ------------------
  ------------------
                  while (ISA_UNRESERVED(cur) || ISA_PCT_ENCODED(cur) || ISA_SUB_DELIM(cur))
  ------------------
  |  |  163|    540|      (((*(p) == '!')) || ((*(p) == '$')) || ((*(p) == '&')) ||		\
  |  |  ------------------
  |  |  |  Branch (163:8): [True: 0, False: 540]
  |  |  |  Branch (163:27): [True: 0, False: 540]
  |  |  |  Branch (163:46): [True: 0, False: 540]
  |  |  ------------------
  |  |  164|    540|       ((*(p) == '(')) || ((*(p) == ')')) || ((*(p) == '*')) ||		\
  |  |  ------------------
  |  |  |  Branch (164:8): [True: 0, False: 540]
  |  |  |  Branch (164:27): [True: 0, False: 540]
  |  |  |  Branch (164:46): [True: 0, False: 540]
  |  |  ------------------
  |  |  165|    540|       ((*(p) == '+')) || ((*(p) == ',')) || ((*(p) == ';')) ||		\
  |  |  ------------------
  |  |  |  Branch (165:8): [True: 0, False: 540]
  |  |  |  Branch (165:27): [True: 0, False: 540]
  |  |  |  Branch (165:46): [True: 0, False: 540]
  |  |  ------------------
  |  |  166|    540|       ((*(p) == '=')) || ((*(p) == '\'')))
  |  |  ------------------
  |  |  |  Branch (166:8): [True: 0, False: 540]
  |  |  |  Branch (166:27): [True: 0, False: 540]
  |  |  ------------------
  ------------------
  489|  4.51k|        NEXT(cur);
  ------------------
  |  |  131|  5.05k|#define NEXT(p) ((*p == '%')? p += 3 : p++)
  |  |  ------------------
  |  |  |  Branch (131:18): [True: 0, False: 4.51k]
  |  |  ------------------
  ------------------
  490|    540|found:
  491|    540|    if (uri != NULL) {
  ------------------
  |  Branch (491:9): [True: 540, False: 0]
  ------------------
  492|    540|	if (uri->authority != NULL) xmlFree(uri->authority);
  ------------------
  |  Branch (492:6): [True: 0, False: 540]
  ------------------
  493|    540|	uri->authority = NULL;
  494|    540|	if (uri->server != NULL) xmlFree(uri->server);
  ------------------
  |  Branch (494:6): [True: 0, False: 540]
  ------------------
  495|    540|	if (cur != host) {
  ------------------
  |  Branch (495:6): [True: 540, False: 0]
  ------------------
  496|    540|	    if (uri->cleanup & 2)
  ------------------
  |  Branch (496:10): [True: 0, False: 540]
  ------------------
  497|      0|		uri->server = STRNDUP(host, cur - host);
  ------------------
  |  |  143|      0|#define STRNDUP(s, n) (char *) xmlStrndup((const xmlChar *)(s), (n))
  ------------------
  498|    540|	    else
  499|    540|		uri->server = xmlURIUnescapeString(host, cur - host, NULL);
  500|    540|	} else
  501|      0|	    uri->server = NULL;
  502|    540|    }
  503|    540|    *str = cur;
  504|    540|    return(0);
  505|    540|}
uri.c:xmlParse3986PathAbEmpty:
  592|    540|{
  593|    540|    const char *cur;
  594|    540|    int ret;
  595|       |
  596|    540|    cur = *str;
  597|       |
  598|  1.23k|    while (*cur == '/') {
  ------------------
  |  Branch (598:12): [True: 694, False: 540]
  ------------------
  599|    694|        cur++;
  600|    694|	ret = xmlParse3986Segment(&cur, 0, 1);
  601|    694|	if (ret != 0) return(ret);
  ------------------
  |  Branch (601:6): [True: 0, False: 694]
  ------------------
  602|    694|    }
  603|    540|    if (uri != NULL) {
  ------------------
  |  Branch (603:9): [True: 540, False: 0]
  ------------------
  604|    540|	if (uri->path != NULL) xmlFree(uri->path);
  ------------------
  |  Branch (604:6): [True: 0, False: 540]
  ------------------
  605|    540|        if (*str != cur) {
  ------------------
  |  Branch (605:13): [True: 354, False: 186]
  ------------------
  606|    354|            if (uri->cleanup & 2)
  ------------------
  |  Branch (606:17): [True: 0, False: 354]
  ------------------
  607|      0|                uri->path = STRNDUP(*str, cur - *str);
  ------------------
  |  |  143|      0|#define STRNDUP(s, n) (char *) xmlStrndup((const xmlChar *)(s), (n))
  ------------------
  608|    354|            else
  609|    354|                uri->path = xmlURIUnescapeString(*str, cur - *str, NULL);
  610|    354|        } else {
  611|    186|            uri->path = NULL;
  612|    186|        }
  613|    540|    }
  614|    540|    *str = cur;
  615|    540|    return (0);
  616|    540|}
uri.c:xmlParse3986Segment:
  563|    928|{
  564|    928|    const char *cur;
  565|       |
  566|    928|    cur = *str;
  567|    928|    if (!ISA_PCHAR(cur)) {
  ------------------
  |  |  198|    928|     (ISA_UNRESERVED(p) || ISA_PCT_ENCODED(p) || ISA_SUB_DELIM(p) ||	\
  |  |  ------------------
  |  |  |  |  185|  1.85k|      ((ISA_ALPHA(p)) || (ISA_DIGIT(p)) || ((*(p) == '-')) ||		\
  |  |  |  |  ------------------
  |  |  |  |  |  |  152|    928|#define ISA_ALPHA(p) (((*(p) >= 'a') && (*(p) <= 'z')) ||		\
  |  |  |  |  |  |  ------------------
  |  |  |  |  |  |  |  Branch (152:24): [True: 207, False: 721]
  |  |  |  |  |  |  |  Branch (152:41): [True: 207, False: 0]
  |  |  |  |  |  |  ------------------
  |  |  |  |  |  |  153|    928|                      ((*(p) >= 'A') && (*(p) <= 'Z')))
  |  |  |  |  |  |  ------------------
  |  |  |  |  |  |  |  Branch (153:24): [True: 296, False: 425]
  |  |  |  |  |  |  |  Branch (153:41): [True: 296, False: 0]
  |  |  |  |  |  |  ------------------
  |  |  |  |  ------------------
  |  |  |  |                     ((ISA_ALPHA(p)) || (ISA_DIGIT(p)) || ((*(p) == '-')) ||		\
  |  |  |  |  ------------------
  |  |  |  |  |  |  151|    425|#define ISA_DIGIT(p) ((*(p) >= '0') && (*(p) <= '9'))
  |  |  |  |  |  |  ------------------
  |  |  |  |  |  |  |  Branch (151:23): [True: 385, False: 40]
  |  |  |  |  |  |  |  Branch (151:40): [True: 383, False: 2]
  |  |  |  |  |  |  ------------------
  |  |  |  |  ------------------
  |  |  |  |  |  Branch (185:44): [True: 0, False: 42]
  |  |  |  |  ------------------
  |  |  |  |  186|    928|       ((*(p) == '.')) || ((*(p) == '_')) || ((*(p) == '~')))
  |  |  |  |  ------------------
  |  |  |  |  |  Branch (186:8): [True: 18, False: 24]
  |  |  |  |  |  Branch (186:27): [True: 0, False: 24]
  |  |  |  |  |  Branch (186:46): [True: 0, False: 24]
  |  |  |  |  ------------------
  |  |  ------------------
  |  |                    (ISA_UNRESERVED(p) || ISA_PCT_ENCODED(p) || ISA_SUB_DELIM(p) ||	\
  |  |  ------------------
  |  |  |  |  192|    952|     ((*(p) == '%') && (ISA_HEXDIG(p + 1)) && (ISA_HEXDIG(p + 2)))
  |  |  |  |  ------------------
  |  |  |  |  |  |  155|      0|       (ISA_DIGIT(p) || ((*(p) >= 'a') && (*(p) <= 'f')) ||		\
  |  |  |  |  |  |  ------------------
  |  |  |  |  |  |  |  |  151|      0|#define ISA_DIGIT(p) ((*(p) >= '0') && (*(p) <= '9'))
  |  |  |  |  |  |  |  |  ------------------
  |  |  |  |  |  |  |  |  |  Branch (151:23): [True: 0, False: 0]
  |  |  |  |  |  |  |  |  |  Branch (151:40): [True: 0, False: 0]
  |  |  |  |  |  |  |  |  ------------------
  |  |  |  |  |  |  ------------------
  |  |  |  |  |  |  |  Branch (155:26): [True: 0, False: 0]
  |  |  |  |  |  |  |  Branch (155:43): [True: 0, False: 0]
  |  |  |  |  |  |  ------------------
  |  |  |  |  |  |  156|      0|        ((*(p) >= 'A') && (*(p) <= 'F')))
  |  |  |  |  |  |  ------------------
  |  |  |  |  |  |  |  Branch (156:10): [True: 0, False: 0]
  |  |  |  |  |  |  |  Branch (156:27): [True: 0, False: 0]
  |  |  |  |  |  |  ------------------
  |  |  |  |  ------------------
  |  |  |  |                    ((*(p) == '%') && (ISA_HEXDIG(p + 1)) && (ISA_HEXDIG(p + 2)))
  |  |  |  |  ------------------
  |  |  |  |  |  |  155|      0|       (ISA_DIGIT(p) || ((*(p) >= 'a') && (*(p) <= 'f')) ||		\
  |  |  |  |  |  |  ------------------
  |  |  |  |  |  |  |  |  151|      0|#define ISA_DIGIT(p) ((*(p) >= '0') && (*(p) <= '9'))
  |  |  |  |  |  |  |  |  ------------------
  |  |  |  |  |  |  |  |  |  Branch (151:23): [True: 0, False: 0]
  |  |  |  |  |  |  |  |  |  Branch (151:40): [True: 0, False: 0]
  |  |  |  |  |  |  |  |  ------------------
  |  |  |  |  |  |  ------------------
  |  |  |  |  |  |  |  Branch (155:26): [True: 0, False: 0]
  |  |  |  |  |  |  |  Branch (155:43): [True: 0, False: 0]
  |  |  |  |  |  |  ------------------
  |  |  |  |  |  |  156|      0|        ((*(p) >= 'A') && (*(p) <= 'F')))
  |  |  |  |  |  |  ------------------
  |  |  |  |  |  |  |  Branch (156:10): [True: 0, False: 0]
  |  |  |  |  |  |  |  Branch (156:27): [True: 0, False: 0]
  |  |  |  |  |  |  ------------------
  |  |  |  |  ------------------
  |  |  |  |  |  Branch (192:7): [True: 0, False: 24]
  |  |  |  |  ------------------
  |  |  ------------------
  |  |                    (ISA_UNRESERVED(p) || ISA_PCT_ENCODED(p) || ISA_SUB_DELIM(p) ||	\
  |  |  ------------------
  |  |  |  |  163|    952|      (((*(p) == '!')) || ((*(p) == '$')) || ((*(p) == '&')) ||		\
  |  |  |  |  ------------------
  |  |  |  |  |  Branch (163:8): [True: 0, False: 24]
  |  |  |  |  |  Branch (163:27): [True: 0, False: 24]
  |  |  |  |  |  Branch (163:46): [True: 0, False: 24]
  |  |  |  |  ------------------
  |  |  |  |  164|     24|       ((*(p) == '(')) || ((*(p) == ')')) || ((*(p) == '*')) ||		\
  |  |  |  |  ------------------
  |  |  |  |  |  Branch (164:8): [True: 0, False: 24]
  |  |  |  |  |  Branch (164:27): [True: 0, False: 24]
  |  |  |  |  |  Branch (164:46): [True: 0, False: 24]
  |  |  |  |  ------------------
  |  |  |  |  165|     24|       ((*(p) == '+')) || ((*(p) == ',')) || ((*(p) == ';')) ||		\
  |  |  |  |  ------------------
  |  |  |  |  |  Branch (165:8): [True: 0, False: 24]
  |  |  |  |  |  Branch (165:27): [True: 0, False: 24]
  |  |  |  |  |  Branch (165:46): [True: 0, False: 24]
  |  |  |  |  ------------------
  |  |  |  |  166|     24|       ((*(p) == '=')) || ((*(p) == '\'')))
  |  |  |  |  ------------------
  |  |  |  |  |  Branch (166:8): [True: 0, False: 24]
  |  |  |  |  |  Branch (166:27): [True: 0, False: 24]
  |  |  |  |  ------------------
  |  |  ------------------
  |  |  199|    928|      ((*(p) == ':')) || ((*(p) == '@')))
  |  |  ------------------
  |  |  |  Branch (199:7): [True: 0, False: 24]
  |  |  |  Branch (199:26): [True: 2, False: 22]
  |  |  ------------------
  ------------------
  568|     22|        if (empty)
  ------------------
  |  Branch (568:13): [True: 22, False: 0]
  ------------------
  569|     22|	    return(0);
  570|      0|	return(1);
  571|     22|    }
  572|  9.07k|    while (ISA_PCHAR(cur) && (*cur != forbid))
  ------------------
  |  |  198|  18.1k|     (ISA_UNRESERVED(p) || ISA_PCT_ENCODED(p) || ISA_SUB_DELIM(p) ||	\
  |  |  ------------------
  |  |  |  |  185|  18.1k|      ((ISA_ALPHA(p)) || (ISA_DIGIT(p)) || ((*(p) == '-')) ||		\
  |  |  |  |  ------------------
  |  |  |  |  |  |  152|  9.07k|#define ISA_ALPHA(p) (((*(p) >= 'a') && (*(p) <= 'z')) ||		\
  |  |  |  |  |  |  ------------------
  |  |  |  |  |  |  |  Branch (152:24): [True: 4.26k, False: 4.80k]
  |  |  |  |  |  |  |  Branch (152:41): [True: 4.26k, False: 0]
  |  |  |  |  |  |  ------------------
  |  |  |  |  |  |  153|  9.07k|                      ((*(p) >= 'A') && (*(p) <= 'Z')))
  |  |  |  |  |  |  ------------------
  |  |  |  |  |  |  |  Branch (153:24): [True: 1.28k, False: 3.52k]
  |  |  |  |  |  |  |  Branch (153:41): [True: 1.23k, False: 52]
  |  |  |  |  |  |  ------------------
  |  |  |  |  ------------------
  |  |  |  |                     ((ISA_ALPHA(p)) || (ISA_DIGIT(p)) || ((*(p) == '-')) ||		\
  |  |  |  |  ------------------
  |  |  |  |  |  |  151|  3.57k|#define ISA_DIGIT(p) ((*(p) >= '0') && (*(p) <= '9'))
  |  |  |  |  |  |  ------------------
  |  |  |  |  |  |  |  Branch (151:23): [True: 2.13k, False: 1.44k]
  |  |  |  |  |  |  |  Branch (151:40): [True: 2.05k, False: 78]
  |  |  |  |  |  |  ------------------
  |  |  |  |  ------------------
  |  |  |  |  |  Branch (185:44): [True: 260, False: 1.26k]
  |  |  |  |  ------------------
  |  |  |  |  186|  9.07k|       ((*(p) == '.')) || ((*(p) == '_')) || ((*(p) == '~')))
  |  |  |  |  ------------------
  |  |  |  |  |  Branch (186:8): [True: 282, False: 983]
  |  |  |  |  |  Branch (186:27): [True: 52, False: 931]
  |  |  |  |  |  Branch (186:46): [True: 0, False: 931]
  |  |  |  |  ------------------
  |  |  ------------------
  |  |                    (ISA_UNRESERVED(p) || ISA_PCT_ENCODED(p) || ISA_SUB_DELIM(p) ||	\
  |  |  ------------------
  |  |  |  |  192|  10.0k|     ((*(p) == '%') && (ISA_HEXDIG(p + 1)) && (ISA_HEXDIG(p + 2)))
  |  |  |  |  ------------------
  |  |  |  |  |  |  155|      0|       (ISA_DIGIT(p) || ((*(p) >= 'a') && (*(p) <= 'f')) ||		\
  |  |  |  |  |  |  ------------------
  |  |  |  |  |  |  |  |  151|      0|#define ISA_DIGIT(p) ((*(p) >= '0') && (*(p) <= '9'))
  |  |  |  |  |  |  |  |  ------------------
  |  |  |  |  |  |  |  |  |  Branch (151:23): [True: 0, False: 0]
  |  |  |  |  |  |  |  |  |  Branch (151:40): [True: 0, False: 0]
  |  |  |  |  |  |  |  |  ------------------
  |  |  |  |  |  |  ------------------
  |  |  |  |  |  |  |  Branch (155:26): [True: 0, False: 0]
  |  |  |  |  |  |  |  Branch (155:43): [True: 0, False: 0]
  |  |  |  |  |  |  ------------------
  |  |  |  |  |  |  156|      0|        ((*(p) >= 'A') && (*(p) <= 'F')))
  |  |  |  |  |  |  ------------------
  |  |  |  |  |  |  |  Branch (156:10): [True: 0, False: 0]
  |  |  |  |  |  |  |  Branch (156:27): [True: 0, False: 0]
  |  |  |  |  |  |  ------------------
  |  |  |  |  ------------------
  |  |  |  |                    ((*(p) == '%') && (ISA_HEXDIG(p + 1)) && (ISA_HEXDIG(p + 2)))
  |  |  |  |  ------------------
  |  |  |  |  |  |  155|      0|       (ISA_DIGIT(p) || ((*(p) >= 'a') && (*(p) <= 'f')) ||		\
  |  |  |  |  |  |  ------------------
  |  |  |  |  |  |  |  |  151|      0|#define ISA_DIGIT(p) ((*(p) >= '0') && (*(p) <= '9'))
  |  |  |  |  |  |  |  |  ------------------
  |  |  |  |  |  |  |  |  |  Branch (151:23): [True: 0, False: 0]
  |  |  |  |  |  |  |  |  |  Branch (151:40): [True: 0, False: 0]
  |  |  |  |  |  |  |  |  ------------------
  |  |  |  |  |  |  ------------------
  |  |  |  |  |  |  |  Branch (155:26): [True: 0, False: 0]
  |  |  |  |  |  |  |  Branch (155:43): [True: 0, False: 0]
  |  |  |  |  |  |  ------------------
  |  |  |  |  |  |  156|      0|        ((*(p) >= 'A') && (*(p) <= 'F')))
  |  |  |  |  |  |  ------------------
  |  |  |  |  |  |  |  Branch (156:10): [True: 0, False: 0]
  |  |  |  |  |  |  |  Branch (156:27): [True: 0, False: 0]
  |  |  |  |  |  |  ------------------
  |  |  |  |  ------------------
  |  |  |  |  |  Branch (192:7): [True: 0, False: 931]
  |  |  |  |  ------------------
  |  |  ------------------
  |  |                    (ISA_UNRESERVED(p) || ISA_PCT_ENCODED(p) || ISA_SUB_DELIM(p) ||	\
  |  |  ------------------
  |  |  |  |  163|  10.0k|      (((*(p) == '!')) || ((*(p) == '$')) || ((*(p) == '&')) ||		\
  |  |  |  |  ------------------
  |  |  |  |  |  Branch (163:8): [True: 0, False: 931]
  |  |  |  |  |  Branch (163:27): [True: 0, False: 931]
  |  |  |  |  |  Branch (163:46): [True: 0, False: 931]
  |  |  |  |  ------------------
  |  |  |  |  164|    931|       ((*(p) == '(')) || ((*(p) == ')')) || ((*(p) == '*')) ||		\
  |  |  |  |  ------------------
  |  |  |  |  |  Branch (164:8): [True: 0, False: 931]
  |  |  |  |  |  Branch (164:27): [True: 0, False: 931]
  |  |  |  |  |  Branch (164:46): [True: 0, False: 931]
  |  |  |  |  ------------------
  |  |  |  |  165|    931|       ((*(p) == '+')) || ((*(p) == ',')) || ((*(p) == ';')) ||		\
  |  |  |  |  ------------------
  |  |  |  |  |  Branch (165:8): [True: 0, False: 931]
  |  |  |  |  |  Branch (165:27): [True: 0, False: 931]
  |  |  |  |  |  Branch (165:46): [True: 0, False: 931]
  |  |  |  |  ------------------
  |  |  |  |  166|    931|       ((*(p) == '=')) || ((*(p) == '\'')))
  |  |  |  |  ------------------
  |  |  |  |  |  Branch (166:8): [True: 1, False: 930]
  |  |  |  |  |  Branch (166:27): [True: 0, False: 930]
  |  |  |  |  ------------------
  |  |  ------------------
  |  |  199|  9.07k|      ((*(p) == ':')) || ((*(p) == '@')))
  |  |  ------------------
  |  |  |  Branch (199:7): [True: 23, False: 907]
  |  |  |  Branch (199:26): [True: 2, False: 905]
  |  |  ------------------
  ------------------
  |  Branch (572:30): [True: 8.16k, False: 1]
  ------------------
  573|  8.16k|        NEXT(cur);
  ------------------
  |  |  131|  9.07k|#define NEXT(p) ((*p == '%')? p += 3 : p++)
  |  |  ------------------
  |  |  |  Branch (131:18): [True: 0, False: 8.16k]
  |  |  ------------------
  ------------------
  574|    906|    *str = cur;
  575|    906|    return (0);
  576|    928|}
uri.c:xmlParse3986PathRootless:
  678|     19|{
  679|     19|    const char *cur;
  680|     19|    int ret;
  681|       |
  682|     19|    cur = *str;
  683|       |
  684|     19|    ret = xmlParse3986Segment(&cur, 0, 0);
  685|     19|    if (ret != 0) return(ret);
  ------------------
  |  Branch (685:9): [True: 0, False: 19]
  ------------------
  686|     19|    while (*cur == '/') {
  ------------------
  |  Branch (686:12): [True: 0, False: 19]
  ------------------
  687|      0|        cur++;
  688|      0|	ret = xmlParse3986Segment(&cur, 0, 1);
  689|      0|	if (ret != 0) return(ret);
  ------------------
  |  Branch (689:6): [True: 0, False: 0]
  ------------------
  690|      0|    }
  691|     19|    if (uri != NULL) {
  ------------------
  |  Branch (691:9): [True: 19, False: 0]
  ------------------
  692|     19|	if (uri->path != NULL) xmlFree(uri->path);
  ------------------
  |  Branch (692:6): [True: 0, False: 19]
  ------------------
  693|     19|        if (cur != *str) {
  ------------------
  |  Branch (693:13): [True: 19, False: 0]
  ------------------
  694|     19|            if (uri->cleanup & 2)
  ------------------
  |  Branch (694:17): [True: 0, False: 19]
  ------------------
  695|      0|                uri->path = STRNDUP(*str, cur - *str);
  ------------------
  |  |  143|      0|#define STRNDUP(s, n) (char *) xmlStrndup((const xmlChar *)(s), (n))
  ------------------
  696|     19|            else
  697|     19|                uri->path = xmlURIUnescapeString(*str, cur - *str, NULL);
  698|     19|        } else {
  699|      0|            uri->path = NULL;
  700|      0|        }
  701|     19|    }
  702|     19|    *str = cur;
  703|     19|    return (0);
  704|     19|}
uri.c:xmlParse3986Fragment:
  250|      5|{
  251|      5|    const char *cur;
  252|       |
  253|      5|    if (str == NULL)
  ------------------
  |  Branch (253:9): [True: 0, False: 5]
  ------------------
  254|      0|        return (-1);
  255|       |
  256|      5|    cur = *str;
  257|       |
  258|      9|    while ((ISA_PCHAR(cur)) || (*cur == '/') || (*cur == '?') ||
  ------------------
  |  |  198|      9|     (ISA_UNRESERVED(p) || ISA_PCT_ENCODED(p) || ISA_SUB_DELIM(p) ||	\
  |  |  ------------------
  |  |  |  |  185|     18|      ((ISA_ALPHA(p)) || (ISA_DIGIT(p)) || ((*(p) == '-')) ||		\
  |  |  |  |  ------------------
  |  |  |  |  |  |  152|      9|#define ISA_ALPHA(p) (((*(p) >= 'a') && (*(p) <= 'z')) ||		\
  |  |  |  |  |  |  ------------------
  |  |  |  |  |  |  |  Branch (152:24): [True: 3, False: 6]
  |  |  |  |  |  |  |  Branch (152:41): [True: 3, False: 0]
  |  |  |  |  |  |  ------------------
  |  |  |  |  |  |  153|      9|                      ((*(p) >= 'A') && (*(p) <= 'Z')))
  |  |  |  |  |  |  ------------------
  |  |  |  |  |  |  |  Branch (153:24): [True: 0, False: 6]
  |  |  |  |  |  |  |  Branch (153:41): [True: 0, False: 0]
  |  |  |  |  |  |  ------------------
  |  |  |  |  ------------------
  |  |  |  |                     ((ISA_ALPHA(p)) || (ISA_DIGIT(p)) || ((*(p) == '-')) ||		\
  |  |  |  |  ------------------
  |  |  |  |  |  |  151|      6|#define ISA_DIGIT(p) ((*(p) >= '0') && (*(p) <= '9'))
  |  |  |  |  |  |  ------------------
  |  |  |  |  |  |  |  Branch (151:23): [True: 1, False: 5]
  |  |  |  |  |  |  |  Branch (151:40): [True: 1, False: 0]
  |  |  |  |  |  |  ------------------
  |  |  |  |  ------------------
  |  |  |  |  |  Branch (185:44): [True: 0, False: 5]
  |  |  |  |  ------------------
  |  |  |  |  186|      9|       ((*(p) == '.')) || ((*(p) == '_')) || ((*(p) == '~')))
  |  |  |  |  ------------------
  |  |  |  |  |  Branch (186:8): [True: 0, False: 5]
  |  |  |  |  |  Branch (186:27): [True: 0, False: 5]
  |  |  |  |  |  Branch (186:46): [True: 0, False: 5]
  |  |  |  |  ------------------
  |  |  ------------------
  |  |                    (ISA_UNRESERVED(p) || ISA_PCT_ENCODED(p) || ISA_SUB_DELIM(p) ||	\
  |  |  ------------------
  |  |  |  |  192|     14|     ((*(p) == '%') && (ISA_HEXDIG(p + 1)) && (ISA_HEXDIG(p + 2)))
  |  |  |  |  ------------------
  |  |  |  |  |  |  155|      0|       (ISA_DIGIT(p) || ((*(p) >= 'a') && (*(p) <= 'f')) ||		\
  |  |  |  |  |  |  ------------------
  |  |  |  |  |  |  |  |  151|      0|#define ISA_DIGIT(p) ((*(p) >= '0') && (*(p) <= '9'))
  |  |  |  |  |  |  |  |  ------------------
  |  |  |  |  |  |  |  |  |  Branch (151:23): [True: 0, False: 0]
  |  |  |  |  |  |  |  |  |  Branch (151:40): [True: 0, False: 0]
  |  |  |  |  |  |  |  |  ------------------
  |  |  |  |  |  |  ------------------
  |  |  |  |  |  |  |  Branch (155:26): [True: 0, False: 0]
  |  |  |  |  |  |  |  Branch (155:43): [True: 0, False: 0]
  |  |  |  |  |  |  ------------------
  |  |  |  |  |  |  156|      0|        ((*(p) >= 'A') && (*(p) <= 'F')))
  |  |  |  |  |  |  ------------------
  |  |  |  |  |  |  |  Branch (156:10): [True: 0, False: 0]
  |  |  |  |  |  |  |  Branch (156:27): [True: 0, False: 0]
  |  |  |  |  |  |  ------------------
  |  |  |  |  ------------------
  |  |  |  |                    ((*(p) == '%') && (ISA_HEXDIG(p + 1)) && (ISA_HEXDIG(p + 2)))
  |  |  |  |  ------------------
  |  |  |  |  |  |  155|      0|       (ISA_DIGIT(p) || ((*(p) >= 'a') && (*(p) <= 'f')) ||		\
  |  |  |  |  |  |  ------------------
  |  |  |  |  |  |  |  |  151|      0|#define ISA_DIGIT(p) ((*(p) >= '0') && (*(p) <= '9'))
  |  |  |  |  |  |  |  |  ------------------
  |  |  |  |  |  |  |  |  |  Branch (151:23): [True: 0, False: 0]
  |  |  |  |  |  |  |  |  |  Branch (151:40): [True: 0, False: 0]
  |  |  |  |  |  |  |  |  ------------------
  |  |  |  |  |  |  ------------------
  |  |  |  |  |  |  |  Branch (155:26): [True: 0, False: 0]
  |  |  |  |  |  |  |  Branch (155:43): [True: 0, False: 0]
  |  |  |  |  |  |  ------------------
  |  |  |  |  |  |  156|      0|        ((*(p) >= 'A') && (*(p) <= 'F')))
  |  |  |  |  |  |  ------------------
  |  |  |  |  |  |  |  Branch (156:10): [True: 0, False: 0]
  |  |  |  |  |  |  |  Branch (156:27): [True: 0, False: 0]
  |  |  |  |  |  |  ------------------
  |  |  |  |  ------------------
  |  |  |  |  |  Branch (192:7): [True: 0, False: 5]
  |  |  |  |  ------------------
  |  |  ------------------
  |  |                    (ISA_UNRESERVED(p) || ISA_PCT_ENCODED(p) || ISA_SUB_DELIM(p) ||	\
  |  |  ------------------
  |  |  |  |  163|     14|      (((*(p) == '!')) || ((*(p) == '$')) || ((*(p) == '&')) ||		\
  |  |  |  |  ------------------
  |  |  |  |  |  Branch (163:8): [True: 0, False: 5]
  |  |  |  |  |  Branch (163:27): [True: 0, False: 5]
  |  |  |  |  |  Branch (163:46): [True: 0, False: 5]
  |  |  |  |  ------------------
  |  |  |  |  164|      5|       ((*(p) == '(')) || ((*(p) == ')')) || ((*(p) == '*')) ||		\
  |  |  |  |  ------------------
  |  |  |  |  |  Branch (164:8): [True: 0, False: 5]
  |  |  |  |  |  Branch (164:27): [True: 0, False: 5]
  |  |  |  |  |  Branch (164:46): [True: 0, False: 5]
  |  |  |  |  ------------------
  |  |  |  |  165|      5|       ((*(p) == '+')) || ((*(p) == ',')) || ((*(p) == ';')) ||		\
  |  |  |  |  ------------------
  |  |  |  |  |  Branch (165:8): [True: 0, False: 5]
  |  |  |  |  |  Branch (165:27): [True: 0, False: 5]
  |  |  |  |  |  Branch (165:46): [True: 0, False: 5]
  |  |  |  |  ------------------
  |  |  |  |  166|      5|       ((*(p) == '=')) || ((*(p) == '\'')))
  |  |  |  |  ------------------
  |  |  |  |  |  Branch (166:8): [True: 0, False: 5]
  |  |  |  |  |  Branch (166:27): [True: 0, False: 5]
  |  |  |  |  ------------------
  |  |  ------------------
  |  |  199|      9|      ((*(p) == ':')) || ((*(p) == '@')))
  |  |  ------------------
  |  |  |  Branch (199:7): [True: 0, False: 5]
  |  |  |  Branch (199:26): [True: 0, False: 5]
  |  |  ------------------
  ------------------
  |  Branch (258:32): [True: 0, False: 5]
  |  Branch (258:49): [True: 0, False: 5]
  ------------------
  259|      9|           (*cur == '[') || (*cur == ']') ||
  ------------------
  |  Branch (259:12): [True: 0, False: 5]
  |  Branch (259:29): [True: 0, False: 5]
  ------------------
  260|      9|           ((uri != NULL) && (uri->cleanup & 1) && (IS_UNWISE(cur))))
  ------------------
  |  |  108|      0|      (((*(p) == '{')) || ((*(p) == '}')) || ((*(p) == '|')) ||         \
  |  |  ------------------
  |  |  |  Branch (108:8): [True: 0, False: 0]
  |  |  |  Branch (108:27): [True: 0, False: 0]
  |  |  |  Branch (108:46): [True: 0, False: 0]
  |  |  ------------------
  |  |  109|      0|       ((*(p) == '\\')) || ((*(p) == '^')) || ((*(p) == '[')) ||        \
  |  |  ------------------
  |  |  |  Branch (109:8): [True: 0, False: 0]
  |  |  |  Branch (109:28): [True: 0, False: 0]
  |  |  |  Branch (109:47): [True: 0, False: 0]
  |  |  ------------------
  |  |  110|      0|       ((*(p) == ']')) || ((*(p) == '`')))
  |  |  ------------------
  |  |  |  Branch (110:8): [True: 0, False: 0]
  |  |  |  Branch (110:27): [True: 0, False: 0]
  |  |  ------------------
  ------------------
  |  Branch (260:13): [True: 5, False: 0]
  |  Branch (260:30): [True: 0, False: 5]
  ------------------
  261|      4|        NEXT(cur);
  ------------------
  |  |  131|      9|#define NEXT(p) ((*p == '%')? p += 3 : p++)
  |  |  ------------------
  |  |  |  Branch (131:18): [True: 0, False: 4]
  |  |  ------------------
  ------------------
  262|      5|    if (uri != NULL) {
  ------------------
  |  Branch (262:9): [True: 5, False: 0]
  ------------------
  263|      5|        if (uri->fragment != NULL)
  ------------------
  |  Branch (263:13): [True: 0, False: 5]
  ------------------
  264|      0|            xmlFree(uri->fragment);
  265|      5|	if (uri->cleanup & 2)
  ------------------
  |  Branch (265:6): [True: 0, False: 5]
  ------------------
  266|      0|	    uri->fragment = STRNDUP(*str, cur - *str);
  ------------------
  |  |  143|      0|#define STRNDUP(s, n) (char *) xmlStrndup((const xmlChar *)(s), (n))
  ------------------
  267|      5|	else
  268|      5|	    uri->fragment = xmlURIUnescapeString(*str, cur - *str, NULL);
  269|      5|    }
  270|      5|    *str = cur;
  271|      5|    return (0);
  272|      5|}
uri.c:xmlParse3986RelativeRef:
  818|    625|xmlParse3986RelativeRef(xmlURIPtr uri, const char *str) {
  819|    625|    int ret;
  820|       |
  821|    625|    if ((*str == '/') && (*(str + 1) == '/')) {
  ------------------
  |  Branch (821:9): [True: 0, False: 625]
  |  Branch (821:26): [True: 0, False: 0]
  ------------------
  822|      0|        str += 2;
  823|      0|	ret = xmlParse3986Authority(uri, &str);
  824|      0|	if (ret != 0) return(ret);
  ------------------
  |  Branch (824:6): [True: 0, False: 0]
  ------------------
  825|      0|	ret = xmlParse3986PathAbEmpty(uri, &str);
  826|      0|	if (ret != 0) return(ret);
  ------------------
  |  Branch (826:6): [True: 0, False: 0]
  ------------------
  827|    625|    } else if (*str == '/') {
  ------------------
  |  Branch (827:16): [True: 0, False: 625]
  ------------------
  828|      0|	ret = xmlParse3986PathAbsolute(uri, &str);
  829|      0|	if (ret != 0) return(ret);
  ------------------
  |  Branch (829:6): [True: 0, False: 0]
  ------------------
  830|    625|    } else if (ISA_PCHAR(str)) {
  ------------------
  |  |  198|    625|     (ISA_UNRESERVED(p) || ISA_PCT_ENCODED(p) || ISA_SUB_DELIM(p) ||	\
  |  |  ------------------
  |  |  |  |  185|  1.25k|      ((ISA_ALPHA(p)) || (ISA_DIGIT(p)) || ((*(p) == '-')) ||		\
  |  |  |  |  ------------------
  |  |  |  |  |  |  152|    625|#define ISA_ALPHA(p) (((*(p) >= 'a') && (*(p) <= 'z')) ||		\
  |  |  |  |  |  |  ------------------
  |  |  |  |  |  |  |  Branch (152:24): [True: 83, False: 542]
  |  |  |  |  |  |  |  Branch (152:41): [True: 83, False: 0]
  |  |  |  |  |  |  ------------------
  |  |  |  |  |  |  153|    625|                      ((*(p) >= 'A') && (*(p) <= 'Z')))
  |  |  |  |  |  |  ------------------
  |  |  |  |  |  |  |  Branch (153:24): [True: 0, False: 542]
  |  |  |  |  |  |  |  Branch (153:41): [True: 0, False: 0]
  |  |  |  |  |  |  ------------------
  |  |  |  |  ------------------
  |  |  |  |                     ((ISA_ALPHA(p)) || (ISA_DIGIT(p)) || ((*(p) == '-')) ||		\
  |  |  |  |  ------------------
  |  |  |  |  |  |  151|    542|#define ISA_DIGIT(p) ((*(p) >= '0') && (*(p) <= '9'))
  |  |  |  |  |  |  ------------------
  |  |  |  |  |  |  |  Branch (151:23): [True: 96, False: 446]
  |  |  |  |  |  |  |  Branch (151:40): [True: 94, False: 2]
  |  |  |  |  |  |  ------------------
  |  |  |  |  ------------------
  |  |  |  |  |  Branch (185:44): [True: 0, False: 448]
  |  |  |  |  ------------------
  |  |  |  |  186|    625|       ((*(p) == '.')) || ((*(p) == '_')) || ((*(p) == '~')))
  |  |  |  |  ------------------
  |  |  |  |  |  Branch (186:8): [True: 18, False: 430]
  |  |  |  |  |  Branch (186:27): [True: 0, False: 430]
  |  |  |  |  |  Branch (186:46): [True: 0, False: 430]
  |  |  |  |  ------------------
  |  |  ------------------
  |  |                    (ISA_UNRESERVED(p) || ISA_PCT_ENCODED(p) || ISA_SUB_DELIM(p) ||	\
  |  |  ------------------
  |  |  |  |  192|  1.05k|     ((*(p) == '%') && (ISA_HEXDIG(p + 1)) && (ISA_HEXDIG(p + 2)))
  |  |  |  |  ------------------
  |  |  |  |  |  |  155|      0|       (ISA_DIGIT(p) || ((*(p) >= 'a') && (*(p) <= 'f')) ||		\
  |  |  |  |  |  |  ------------------
  |  |  |  |  |  |  |  |  151|      0|#define ISA_DIGIT(p) ((*(p) >= '0') && (*(p) <= '9'))
  |  |  |  |  |  |  |  |  ------------------
  |  |  |  |  |  |  |  |  |  Branch (151:23): [True: 0, False: 0]
  |  |  |  |  |  |  |  |  |  Branch (151:40): [True: 0, False: 0]
  |  |  |  |  |  |  |  |  ------------------
  |  |  |  |  |  |  ------------------
  |  |  |  |  |  |  |  Branch (155:26): [True: 0, False: 0]
  |  |  |  |  |  |  |  Branch (155:43): [True: 0, False: 0]
  |  |  |  |  |  |  ------------------
  |  |  |  |  |  |  156|      0|        ((*(p) >= 'A') && (*(p) <= 'F')))
  |  |  |  |  |  |  ------------------
  |  |  |  |  |  |  |  Branch (156:10): [True: 0, False: 0]
  |  |  |  |  |  |  |  Branch (156:27): [True: 0, False: 0]
  |  |  |  |  |  |  ------------------
  |  |  |  |  ------------------
  |  |  |  |                    ((*(p) == '%') && (ISA_HEXDIG(p + 1)) && (ISA_HEXDIG(p + 2)))
  |  |  |  |  ------------------
  |  |  |  |  |  |  155|      0|       (ISA_DIGIT(p) || ((*(p) >= 'a') && (*(p) <= 'f')) ||		\
  |  |  |  |  |  |  ------------------
  |  |  |  |  |  |  |  |  151|      0|#define ISA_DIGIT(p) ((*(p) >= '0') && (*(p) <= '9'))
  |  |  |  |  |  |  |  |  ------------------
  |  |  |  |  |  |  |  |  |  Branch (151:23): [True: 0, False: 0]
  |  |  |  |  |  |  |  |  |  Branch (151:40): [True: 0, False: 0]
  |  |  |  |  |  |  |  |  ------------------
  |  |  |  |  |  |  ------------------
  |  |  |  |  |  |  |  Branch (155:26): [True: 0, False: 0]
  |  |  |  |  |  |  |  Branch (155:43): [True: 0, False: 0]
  |  |  |  |  |  |  ------------------
  |  |  |  |  |  |  156|      0|        ((*(p) >= 'A') && (*(p) <= 'F')))
  |  |  |  |  |  |  ------------------
  |  |  |  |  |  |  |  Branch (156:10): [True: 0, False: 0]
  |  |  |  |  |  |  |  Branch (156:27): [True: 0, False: 0]
  |  |  |  |  |  |  ------------------
  |  |  |  |  ------------------
  |  |  |  |  |  Branch (192:7): [True: 0, False: 430]
  |  |  |  |  ------------------
  |  |  ------------------
  |  |                    (ISA_UNRESERVED(p) || ISA_PCT_ENCODED(p) || ISA_SUB_DELIM(p) ||	\
  |  |  ------------------
  |  |  |  |  163|  1.05k|      (((*(p) == '!')) || ((*(p) == '$')) || ((*(p) == '&')) ||		\
  |  |  |  |  ------------------
  |  |  |  |  |  Branch (163:8): [True: 0, False: 430]
  |  |  |  |  |  Branch (163:27): [True: 0, False: 430]
  |  |  |  |  |  Branch (163:46): [True: 0, False: 430]
  |  |  |  |  ------------------
  |  |  |  |  164|    430|       ((*(p) == '(')) || ((*(p) == ')')) || ((*(p) == '*')) ||		\
  |  |  |  |  ------------------
  |  |  |  |  |  Branch (164:8): [True: 0, False: 430]
  |  |  |  |  |  Branch (164:27): [True: 0, False: 430]
  |  |  |  |  |  Branch (164:46): [True: 0, False: 430]
  |  |  |  |  ------------------
  |  |  |  |  165|    430|       ((*(p) == '+')) || ((*(p) == ',')) || ((*(p) == ';')) ||		\
  |  |  |  |  ------------------
  |  |  |  |  |  Branch (165:8): [True: 0, False: 430]
  |  |  |  |  |  Branch (165:27): [True: 0, False: 430]
  |  |  |  |  |  Branch (165:46): [True: 0, False: 430]
  |  |  |  |  ------------------
  |  |  |  |  166|    430|       ((*(p) == '=')) || ((*(p) == '\'')))
  |  |  |  |  ------------------
  |  |  |  |  |  Branch (166:8): [True: 0, False: 430]
  |  |  |  |  |  Branch (166:27): [True: 0, False: 430]
  |  |  |  |  ------------------
  |  |  ------------------
  |  |  199|    625|      ((*(p) == ':')) || ((*(p) == '@')))
  |  |  ------------------
  |  |  |  Branch (199:7): [True: 0, False: 430]
  |  |  |  Branch (199:26): [True: 2, False: 428]
  |  |  ------------------
  ------------------
  831|    197|        ret = xmlParse3986PathNoScheme(uri, &str);
  832|    197|	if (ret != 0) return(ret);
  ------------------
  |  Branch (832:6): [True: 0, False: 197]
  ------------------
  833|    428|    } else {
  834|       |	/* path-empty is effectively empty */
  835|    428|	if (uri != NULL) {
  ------------------
  |  Branch (835:6): [True: 428, False: 0]
  ------------------
  836|    428|	    if (uri->path != NULL) xmlFree(uri->path);
  ------------------
  |  Branch (836:10): [True: 0, False: 428]
  ------------------
  837|    428|	    uri->path = NULL;
  838|    428|	}
  839|    428|    }
  840|       |
  841|    625|    if (*str == '?') {
  ------------------
  |  Branch (841:9): [True: 0, False: 625]
  ------------------
  842|      0|	str++;
  843|      0|	ret = xmlParse3986Query(uri, &str);
  844|      0|	if (ret != 0) return(ret);
  ------------------
  |  Branch (844:6): [True: 0, False: 0]
  ------------------
  845|      0|    }
  846|    625|    if (*str == '#') {
  ------------------
  |  Branch (846:9): [True: 0, False: 625]
  ------------------
  847|      0|	str++;
  848|      0|	ret = xmlParse3986Fragment(uri, &str);
  849|      0|	if (ret != 0) return(ret);
  ------------------
  |  Branch (849:6): [True: 0, False: 0]
  ------------------
  850|      0|    }
  851|    625|    if (*str != 0) {
  ------------------
  |  Branch (851:9): [True: 5, False: 620]
  ------------------
  852|      5|	xmlCleanURI(uri);
  853|      5|	return(1);
  854|      5|    }
  855|    620|    return(0);
  856|    625|}
uri.c:xmlParse3986PathNoScheme:
  720|    197|{
  721|    197|    const char *cur;
  722|    197|    int ret;
  723|       |
  724|    197|    cur = *str;
  725|       |
  726|    197|    ret = xmlParse3986Segment(&cur, ':', 0);
  727|    197|    if (ret != 0) return(ret);
  ------------------
  |  Branch (727:9): [True: 0, False: 197]
  ------------------
  728|    215|    while (*cur == '/') {
  ------------------
  |  Branch (728:12): [True: 18, False: 197]
  ------------------
  729|     18|        cur++;
  730|     18|	ret = xmlParse3986Segment(&cur, 0, 1);
  731|     18|	if (ret != 0) return(ret);
  ------------------
  |  Branch (731:6): [True: 0, False: 18]
  ------------------
  732|     18|    }
  733|    197|    if (uri != NULL) {
  ------------------
  |  Branch (733:9): [True: 197, False: 0]
  ------------------
  734|    197|	if (uri->path != NULL) xmlFree(uri->path);
  ------------------
  |  Branch (734:6): [True: 0, False: 197]
  ------------------
  735|    197|        if (cur != *str) {
  ------------------
  |  Branch (735:13): [True: 197, False: 0]
  ------------------
  736|    197|            if (uri->cleanup & 2)
  ------------------
  |  Branch (736:17): [True: 0, False: 197]
  ------------------
  737|      0|                uri->path = STRNDUP(*str, cur - *str);
  ------------------
  |  |  143|      0|#define STRNDUP(s, n) (char *) xmlStrndup((const xmlChar *)(s), (n))
  ------------------
  738|    197|            else
  739|    197|                uri->path = xmlURIUnescapeString(*str, cur - *str, NULL);
  740|    197|        } else {
  741|      0|            uri->path = NULL;
  742|      0|        }
  743|    197|    }
  744|    197|    *str = cur;
  745|    197|    return (0);
  746|    197|}

xmlAddID:
 2518|     17|         xmlAttrPtr attr) {
 2519|     17|    xmlIDPtr ret;
 2520|     17|    xmlIDTablePtr table;
 2521|       |
 2522|     17|    if (doc == NULL) {
  ------------------
  |  Branch (2522:9): [True: 0, False: 17]
  ------------------
 2523|      0|	return(NULL);
 2524|      0|    }
 2525|     17|    if ((value == NULL) || (value[0] == 0)) {
  ------------------
  |  Branch (2525:9): [True: 0, False: 17]
  |  Branch (2525:28): [True: 0, False: 17]
  ------------------
 2526|      0|	return(NULL);
 2527|      0|    }
 2528|     17|    if (attr == NULL) {
  ------------------
  |  Branch (2528:9): [True: 0, False: 17]
  ------------------
 2529|      0|	return(NULL);
 2530|      0|    }
 2531|       |
 2532|       |    /*
 2533|       |     * Create the ID table if needed.
 2534|       |     */
 2535|     17|    table = (xmlIDTablePtr) doc->ids;
 2536|     17|    if (table == NULL)  {
  ------------------
  |  Branch (2536:9): [True: 5, False: 12]
  ------------------
 2537|      5|        doc->ids = table = xmlHashCreateDict(0, doc->dict);
 2538|      5|    }
 2539|     17|    if (table == NULL) {
  ------------------
  |  Branch (2539:9): [True: 0, False: 17]
  ------------------
 2540|      0|	xmlVErrMemory(ctxt,
 2541|      0|		"xmlAddID: Table creation failed!\n");
 2542|      0|        return(NULL);
 2543|      0|    }
 2544|       |
 2545|     17|    ret = (xmlIDPtr) xmlMalloc(sizeof(xmlID));
 2546|     17|    if (ret == NULL) {
  ------------------
  |  Branch (2546:9): [True: 0, False: 17]
  ------------------
 2547|      0|	xmlVErrMemory(ctxt, "malloc failed");
 2548|      0|	return(NULL);
 2549|      0|    }
 2550|       |
 2551|       |    /*
 2552|       |     * fill the structure.
 2553|       |     */
 2554|     17|    ret->value = xmlStrdup(value);
 2555|     17|    ret->doc = doc;
 2556|     17|    if (xmlIsStreaming(ctxt)) {
  ------------------
  |  Branch (2556:9): [True: 0, False: 17]
  ------------------
 2557|       |	/*
 2558|       |	 * Operating in streaming mode, attr is gonna disappear
 2559|       |	 */
 2560|      0|	if (doc->dict != NULL)
  ------------------
  |  Branch (2560:6): [True: 0, False: 0]
  ------------------
 2561|      0|	    ret->name = xmlDictLookup(doc->dict, attr->name, -1);
 2562|      0|	else
 2563|      0|	    ret->name = xmlStrdup(attr->name);
 2564|      0|	ret->attr = NULL;
 2565|     17|    } else {
 2566|     17|	ret->attr = attr;
 2567|     17|	ret->name = NULL;
 2568|     17|    }
 2569|     17|    ret->lineno = xmlGetLineNo(attr->parent);
 2570|       |
 2571|     17|    if (xmlHashAddEntry(table, value, ret) < 0) {
  ------------------
  |  Branch (2571:9): [True: 0, False: 17]
  ------------------
 2572|      0|#ifdef LIBXML_VALID_ENABLED
 2573|       |	/*
 2574|       |	 * The id is already defined in this DTD.
 2575|       |	 */
 2576|      0|	if (ctxt != NULL) {
  ------------------
  |  Branch (2576:6): [True: 0, False: 0]
  ------------------
 2577|      0|	    xmlErrValidNode(ctxt, attr->parent, XML_DTD_ID_REDEFINED,
 2578|      0|			    "ID %s already defined\n", value, NULL, NULL);
 2579|      0|	}
 2580|      0|#endif /* LIBXML_VALID_ENABLED */
 2581|      0|	xmlFreeID(ret);
 2582|      0|	return(NULL);
 2583|      0|    }
 2584|     17|    if (attr != NULL)
  ------------------
  |  Branch (2584:9): [True: 17, False: 0]
  ------------------
 2585|     17|	attr->atype = XML_ATTRIBUTE_ID;
 2586|     17|    return(ret);
 2587|     17|}
xmlFreeIDTable:
 2601|      5|xmlFreeIDTable(xmlIDTablePtr table) {
 2602|      5|    xmlHashFree(table, xmlFreeIDTableEntry);
 2603|      5|}
xmlIsID:
 2619|  3.96k|xmlIsID(xmlDocPtr doc, xmlNodePtr elem, xmlAttrPtr attr) {
 2620|  3.96k|    if ((attr == NULL) || (attr->name == NULL)) return(0);
  ------------------
  |  Branch (2620:9): [True: 0, False: 3.96k]
  |  Branch (2620:27): [True: 0, False: 3.96k]
  ------------------
 2621|  3.96k|    if ((attr->ns != NULL) && (attr->ns->prefix != NULL) &&
  ------------------
  |  Branch (2621:9): [True: 48, False: 3.91k]
  |  Branch (2621:31): [True: 48, False: 0]
  ------------------
 2622|  3.96k|        (!strcmp((char *) attr->name, "id")) &&
  ------------------
  |  Branch (2622:9): [True: 0, False: 48]
  ------------------
 2623|  3.96k|        (!strcmp((char *) attr->ns->prefix, "xml")))
  ------------------
  |  Branch (2623:9): [True: 0, False: 0]
  ------------------
 2624|      0|	return(1);
 2625|  3.96k|    if (doc == NULL) return(0);
  ------------------
  |  Branch (2625:9): [True: 0, False: 3.96k]
  ------------------
 2626|  3.96k|    if ((doc->intSubset == NULL) && (doc->extSubset == NULL) &&
  ------------------
  |  Branch (2626:9): [True: 3.96k, False: 0]
  |  Branch (2626:37): [True: 3.96k, False: 0]
  ------------------
 2627|  3.96k|        (doc->type != XML_HTML_DOCUMENT_NODE)) {
  ------------------
  |  Branch (2627:9): [True: 3.96k, False: 0]
  ------------------
 2628|  3.96k|	return(0);
 2629|  3.96k|    } else if (doc->type == XML_HTML_DOCUMENT_NODE) {
  ------------------
  |  Branch (2629:16): [True: 0, False: 0]
  ------------------
 2630|      0|        if ((xmlStrEqual(BAD_CAST "id", attr->name)) ||
  ------------------
  |  |   35|      0|#define BAD_CAST (xmlChar *)
  ------------------
  |  Branch (2630:13): [True: 0, False: 0]
  ------------------
 2631|      0|	    ((xmlStrEqual(BAD_CAST "name", attr->name)) &&
  ------------------
  |  |   35|      0|#define BAD_CAST (xmlChar *)
  ------------------
  |  Branch (2631:7): [True: 0, False: 0]
  ------------------
 2632|      0|	    ((elem == NULL) || (xmlStrEqual(elem->name, BAD_CAST "a")))))
  ------------------
  |  |   35|      0|#define BAD_CAST (xmlChar *)
  ------------------
  |  Branch (2632:7): [True: 0, False: 0]
  |  Branch (2632:25): [True: 0, False: 0]
  ------------------
 2633|      0|	    return(1);
 2634|      0|	return(0);
 2635|      0|    } else if (elem == NULL) {
  ------------------
  |  Branch (2635:16): [True: 0, False: 0]
  ------------------
 2636|      0|	return(0);
 2637|      0|    } else {
 2638|      0|	xmlAttributePtr attrDecl = NULL;
 2639|       |
 2640|      0|	xmlChar felem[50], fattr[50];
 2641|      0|	xmlChar *fullelemname, *fullattrname;
 2642|       |
 2643|      0|	fullelemname = (elem->ns != NULL && elem->ns->prefix != NULL) ?
  ------------------
  |  Branch (2643:18): [True: 0, False: 0]
  |  Branch (2643:38): [True: 0, False: 0]
  ------------------
 2644|      0|	    xmlBuildQName(elem->name, elem->ns->prefix, felem, 50) :
 2645|      0|	    (xmlChar *)elem->name;
 2646|       |
 2647|      0|	fullattrname = (attr->ns != NULL && attr->ns->prefix != NULL) ?
  ------------------
  |  Branch (2647:18): [True: 0, False: 0]
  |  Branch (2647:38): [True: 0, False: 0]
  ------------------
 2648|      0|	    xmlBuildQName(attr->name, attr->ns->prefix, fattr, 50) :
 2649|      0|	    (xmlChar *)attr->name;
 2650|       |
 2651|      0|	if (fullelemname != NULL && fullattrname != NULL) {
  ------------------
  |  Branch (2651:6): [True: 0, False: 0]
  |  Branch (2651:30): [True: 0, False: 0]
  ------------------
 2652|      0|	    attrDecl = xmlGetDtdAttrDesc(doc->intSubset, fullelemname,
 2653|      0|		                         fullattrname);
 2654|      0|	    if ((attrDecl == NULL) && (doc->extSubset != NULL))
  ------------------
  |  Branch (2654:10): [True: 0, False: 0]
  |  Branch (2654:32): [True: 0, False: 0]
  ------------------
 2655|      0|		attrDecl = xmlGetDtdAttrDesc(doc->extSubset, fullelemname,
 2656|      0|					     fullattrname);
 2657|      0|	}
 2658|       |
 2659|      0|	if ((fullattrname != fattr) && (fullattrname != attr->name))
  ------------------
  |  Branch (2659:6): [True: 0, False: 0]
  |  Branch (2659:33): [True: 0, False: 0]
  ------------------
 2660|      0|	    xmlFree(fullattrname);
 2661|      0|	if ((fullelemname != felem) && (fullelemname != elem->name))
  ------------------
  |  Branch (2661:6): [True: 0, False: 0]
  |  Branch (2661:33): [True: 0, False: 0]
  ------------------
 2662|      0|	    xmlFree(fullelemname);
 2663|       |
 2664|      0|        if ((attrDecl != NULL) && (attrDecl->atype == XML_ATTRIBUTE_ID))
  ------------------
  |  Branch (2664:13): [True: 0, False: 0]
  |  Branch (2664:35): [True: 0, False: 0]
  ------------------
 2665|      0|	    return(1);
 2666|      0|    }
 2667|      0|    return(0);
 2668|  3.96k|}
xmlRemoveID:
 2680|     17|xmlRemoveID(xmlDocPtr doc, xmlAttrPtr attr) {
 2681|     17|    xmlIDTablePtr table;
 2682|     17|    xmlIDPtr id;
 2683|     17|    xmlChar *ID;
 2684|       |
 2685|     17|    if (doc == NULL) return(-1);
  ------------------
  |  Branch (2685:9): [True: 0, False: 17]
  ------------------
 2686|     17|    if (attr == NULL) return(-1);
  ------------------
  |  Branch (2686:9): [True: 0, False: 17]
  ------------------
 2687|       |
 2688|     17|    table = (xmlIDTablePtr) doc->ids;
 2689|     17|    if (table == NULL)
  ------------------
  |  Branch (2689:9): [True: 17, False: 0]
  ------------------
 2690|     17|        return(-1);
 2691|       |
 2692|      0|    ID = xmlNodeListGetString(doc, attr->children, 1);
 2693|      0|    if (ID == NULL)
  ------------------
  |  Branch (2693:9): [True: 0, False: 0]
  ------------------
 2694|      0|        return(-1);
 2695|      0|    xmlValidNormalizeString(ID);
 2696|       |
 2697|      0|    id = xmlHashLookup(table, ID);
 2698|      0|    if (id == NULL || id->attr != attr) {
  ------------------
  |  Branch (2698:9): [True: 0, False: 0]
  |  Branch (2698:23): [True: 0, False: 0]
  ------------------
 2699|      0|        xmlFree(ID);
 2700|      0|        return(-1);
 2701|      0|    }
 2702|       |
 2703|      0|    xmlHashRemoveEntry(table, ID, xmlFreeIDTableEntry);
 2704|      0|    xmlFree(ID);
 2705|      0|    attr->atype = 0;
 2706|      0|    return(0);
 2707|      0|}
xmlIsRef:
 2967|  3.96k|xmlIsRef(xmlDocPtr doc, xmlNodePtr elem, xmlAttrPtr attr) {
 2968|  3.96k|    if (attr == NULL)
  ------------------
  |  Branch (2968:9): [True: 0, False: 3.96k]
  ------------------
 2969|      0|        return(0);
 2970|  3.96k|    if (doc == NULL) {
  ------------------
  |  Branch (2970:9): [True: 0, False: 3.96k]
  ------------------
 2971|      0|        doc = attr->doc;
 2972|      0|	if (doc == NULL) return(0);
  ------------------
  |  Branch (2972:6): [True: 0, False: 0]
  ------------------
 2973|      0|    }
 2974|       |
 2975|  3.96k|    if ((doc->intSubset == NULL) && (doc->extSubset == NULL)) {
  ------------------
  |  Branch (2975:9): [True: 3.96k, False: 0]
  |  Branch (2975:37): [True: 3.96k, False: 0]
  ------------------
 2976|  3.96k|        return(0);
 2977|  3.96k|    } else if (doc->type == XML_HTML_DOCUMENT_NODE) {
  ------------------
  |  Branch (2977:16): [True: 0, False: 0]
  ------------------
 2978|       |        /* TODO @@@ */
 2979|      0|        return(0);
 2980|      0|    } else {
 2981|      0|        xmlAttributePtr attrDecl;
 2982|       |
 2983|      0|        if (elem == NULL) return(0);
  ------------------
  |  Branch (2983:13): [True: 0, False: 0]
  ------------------
 2984|      0|        attrDecl = xmlGetDtdAttrDesc(doc->intSubset, elem->name, attr->name);
 2985|      0|        if ((attrDecl == NULL) && (doc->extSubset != NULL))
  ------------------
  |  Branch (2985:13): [True: 0, False: 0]
  |  Branch (2985:35): [True: 0, False: 0]
  ------------------
 2986|      0|            attrDecl = xmlGetDtdAttrDesc(doc->extSubset,
 2987|      0|		                         elem->name, attr->name);
 2988|       |
 2989|      0|	if ((attrDecl != NULL) &&
  ------------------
  |  Branch (2989:6): [True: 0, False: 0]
  ------------------
 2990|      0|	    (attrDecl->atype == XML_ATTRIBUTE_IDREF ||
  ------------------
  |  Branch (2990:7): [True: 0, False: 0]
  ------------------
 2991|      0|	     attrDecl->atype == XML_ATTRIBUTE_IDREFS))
  ------------------
  |  Branch (2991:7): [True: 0, False: 0]
  ------------------
 2992|      0|	return(1);
 2993|      0|    }
 2994|      0|    return(0);
 2995|  3.96k|}
valid.c:xmlIsStreaming:
 2471|     17|xmlIsStreaming(xmlValidCtxtPtr ctxt) {
 2472|     17|    xmlParserCtxtPtr pctxt;
 2473|       |
 2474|     17|    if (ctxt == NULL)
  ------------------
  |  Branch (2474:9): [True: 17, False: 0]
  ------------------
 2475|     17|        return(0);
 2476|      0|    if ((ctxt->flags & XML_VCTXT_USE_PCTXT) == 0)
  ------------------
  |  |   18|      0|#define XML_VCTXT_USE_PCTXT (1u << 1)
  ------------------
  |  Branch (2476:9): [True: 0, False: 0]
  ------------------
 2477|      0|        return(0);
 2478|      0|    pctxt = ctxt->userData;
 2479|      0|    return(pctxt->parseMode == XML_PARSE_READER);
 2480|      0|}
valid.c:xmlFreeID:
 2489|     17|xmlFreeID(xmlIDPtr id) {
 2490|     17|    xmlDictPtr dict = NULL;
 2491|       |
 2492|     17|    if (id == NULL) return;
  ------------------
  |  Branch (2492:9): [True: 0, False: 17]
  ------------------
 2493|       |
 2494|     17|    if (id->doc != NULL)
  ------------------
  |  Branch (2494:9): [True: 17, False: 0]
  ------------------
 2495|     17|        dict = id->doc->dict;
 2496|       |
 2497|     17|    if (id->value != NULL)
  ------------------
  |  Branch (2497:9): [True: 17, False: 0]
  ------------------
 2498|     17|	DICT_FREE(id->value)
  ------------------
  |  | 2437|     17|	if ((str) && ((!dict) ||				\
  |  |  ------------------
  |  |  |  Branch (2437:6): [True: 17, False: 0]
  |  |  |  Branch (2437:16): [True: 0, False: 17]
  |  |  ------------------
  |  | 2438|     17|	    (xmlDictOwns(dict, (const xmlChar *)(str)) == 0)))	\
  |  |  ------------------
  |  |  |  Branch (2438:6): [True: 17, False: 0]
  |  |  ------------------
  |  | 2439|     17|	    xmlFree((char *)(str));
  ------------------
 2499|     17|    if (id->name != NULL)
  ------------------
  |  Branch (2499:9): [True: 0, False: 17]
  ------------------
 2500|      0|	DICT_FREE(id->name)
  ------------------
  |  | 2437|      0|	if ((str) && ((!dict) ||				\
  |  |  ------------------
  |  |  |  Branch (2437:6): [True: 0, False: 0]
  |  |  |  Branch (2437:16): [True: 0, False: 0]
  |  |  ------------------
  |  | 2438|      0|	    (xmlDictOwns(dict, (const xmlChar *)(str)) == 0)))	\
  |  |  ------------------
  |  |  |  Branch (2438:6): [True: 0, False: 0]
  |  |  ------------------
  |  | 2439|      0|	    xmlFree((char *)(str));
  ------------------
 2501|     17|    xmlFree(id);
 2502|     17|}
valid.c:xmlFreeIDTableEntry:
 2590|     17|xmlFreeIDTableEntry(void *id, const xmlChar *name ATTRIBUTE_UNUSED) {
 2591|     17|    xmlFreeID((xmlIDPtr) id);
 2592|     17|}

xmlCheckFilename:
  679|    242|{
  680|    242|#ifdef HAVE_STAT
  681|       |#if defined(_WIN32)
  682|       |    struct _stat stat_buffer;
  683|       |#else
  684|    242|    struct stat stat_buffer;
  685|    242|#endif
  686|    242|#endif
  687|    242|    if (path == NULL)
  ------------------
  |  Branch (687:9): [True: 0, False: 242]
  ------------------
  688|      0|	return(0);
  689|       |
  690|    242|#ifdef HAVE_STAT
  691|       |#if defined(_WIN32)
  692|       |    /*
  693|       |     * On Windows stat and wstat do not work with long pathname,
  694|       |     * which start with '\\?\'
  695|       |     */
  696|       |    if ((path[0] == '\\') && (path[1] == '\\') && (path[2] == '?') &&
  697|       |	(path[3] == '\\') )
  698|       |	    return 1;
  699|       |
  700|       |    if (xmlWrapStatUtf8(path, &stat_buffer) == -1)
  701|       |        return 0;
  702|       |#else
  703|    242|    if (stat(path, &stat_buffer) == -1)
  ------------------
  |  Branch (703:9): [True: 242, False: 0]
  ------------------
  704|    242|        return 0;
  705|      0|#endif
  706|      0|#ifdef S_ISDIR
  707|      0|    if (S_ISDIR(stat_buffer.st_mode))
  708|      0|        return 2;
  709|      0|#endif
  710|      0|#endif /* HAVE_STAT */
  711|      0|    return 1;
  712|      0|}
xmlRegisterInputCallbacks:
 2102|      6|	xmlInputCloseCallback closeFunc) {
 2103|      6|    if (xmlInputCallbackNr >= MAX_INPUT_CALLBACK) {
  ------------------
  |  |   85|      6|#define MAX_INPUT_CALLBACK 15
  ------------------
  |  Branch (2103:9): [True: 0, False: 6]
  ------------------
 2104|      0|	return(-1);
 2105|      0|    }
 2106|      6|    xmlInputCallbackTable[xmlInputCallbackNr].matchcallback = matchFunc;
 2107|      6|    xmlInputCallbackTable[xmlInputCallbackNr].opencallback = openFunc;
 2108|      6|    xmlInputCallbackTable[xmlInputCallbackNr].readcallback = readFunc;
 2109|      6|    xmlInputCallbackTable[xmlInputCallbackNr].closecallback = closeFunc;
 2110|      6|    xmlInputCallbackInitialized = 1;
 2111|      6|    return(xmlInputCallbackNr++);
 2112|      6|}
xmlRegisterOutputCallbacks:
 2129|      2|	xmlOutputCloseCallback closeFunc) {
 2130|      2|    if (xmlOutputCallbackNr >= MAX_OUTPUT_CALLBACK) {
  ------------------
  |  |  102|      2|#define MAX_OUTPUT_CALLBACK 15
  ------------------
  |  Branch (2130:9): [True: 0, False: 2]
  ------------------
 2131|      0|	return(-1);
 2132|      0|    }
 2133|      2|    xmlOutputCallbackTable[xmlOutputCallbackNr].matchcallback = matchFunc;
 2134|      2|    xmlOutputCallbackTable[xmlOutputCallbackNr].opencallback = openFunc;
 2135|      2|    xmlOutputCallbackTable[xmlOutputCallbackNr].writecallback = writeFunc;
 2136|      2|    xmlOutputCallbackTable[xmlOutputCallbackNr].closecallback = closeFunc;
 2137|      2|    xmlOutputCallbackInitialized = 1;
 2138|      2|    return(xmlOutputCallbackNr++);
 2139|      2|}
xmlRegisterDefaultInputCallbacks:
 2148|      2|xmlRegisterDefaultInputCallbacks(void) {
 2149|      2|    if (xmlInputCallbackInitialized)
  ------------------
  |  Branch (2149:9): [True: 0, False: 2]
  ------------------
 2150|      0|	return;
 2151|       |
 2152|      2|    xmlRegisterInputCallbacks(xmlFileMatch, xmlFileOpen,
 2153|      2|	                      xmlFileRead, xmlFileClose);
 2154|      2|#ifdef LIBXML_ZLIB_ENABLED
 2155|      2|    xmlRegisterInputCallbacks(xmlGzfileMatch, xmlGzfileOpen,
 2156|      2|	                      xmlGzfileRead, xmlGzfileClose);
 2157|      2|#endif /* LIBXML_ZLIB_ENABLED */
 2158|      2|#ifdef LIBXML_LZMA_ENABLED
 2159|      2|    xmlRegisterInputCallbacks(xmlXzfileMatch, xmlXzfileOpen,
 2160|      2|	                      xmlXzfileRead, xmlXzfileClose);
 2161|      2|#endif /* LIBXML_LZMA_ENABLED */
 2162|       |
 2163|       |#ifdef LIBXML_HTTP_ENABLED
 2164|       |    xmlRegisterInputCallbacks(xmlIOHTTPMatch, xmlIOHTTPOpen,
 2165|       |	                      xmlIOHTTPRead, xmlIOHTTPClose);
 2166|       |#endif /* LIBXML_HTTP_ENABLED */
 2167|       |
 2168|       |#ifdef LIBXML_FTP_ENABLED
 2169|       |    xmlRegisterInputCallbacks(xmlIOFTPMatch, xmlIOFTPOpen,
 2170|       |	                      xmlIOFTPRead, xmlIOFTPClose);
 2171|       |#endif /* LIBXML_FTP_ENABLED */
 2172|      2|    xmlInputCallbackInitialized = 1;
 2173|      2|}
xmlRegisterDefaultOutputCallbacks:
 2182|      2|xmlRegisterDefaultOutputCallbacks (void) {
 2183|      2|    if (xmlOutputCallbackInitialized)
  ------------------
  |  Branch (2183:9): [True: 0, False: 2]
  ------------------
 2184|      0|	return;
 2185|       |
 2186|      2|    xmlRegisterOutputCallbacks(xmlFileMatch, xmlFileOpenW,
 2187|      2|	                      xmlFileWrite, xmlFileClose);
 2188|       |
 2189|       |#ifdef LIBXML_HTTP_ENABLED
 2190|       |    xmlRegisterOutputCallbacks(xmlIOHTTPMatch, xmlIOHTTPDfltOpenW,
 2191|       |	                       xmlIOHTTPWrite, xmlIOHTTPClosePut);
 2192|       |#endif
 2193|       |
 2194|       |/*********************************
 2195|       | No way a-priori to distinguish between gzipped files from
 2196|       | uncompressed ones except opening if existing then closing
 2197|       | and saving with same compression ratio ... a pain.
 2198|       |
 2199|       |#ifdef LIBXML_ZLIB_ENABLED
 2200|       |    xmlRegisterOutputCallbacks(xmlGzfileMatch, xmlGzfileOpen,
 2201|       |	                       xmlGzfileWrite, xmlGzfileClose);
 2202|       |#endif
 2203|       |
 2204|       | Nor FTP PUT ....
 2205|       |#ifdef LIBXML_FTP_ENABLED
 2206|       |    xmlRegisterOutputCallbacks(xmlIOFTPMatch, xmlIOFTPOpen,
 2207|       |	                       xmlIOFTPWrite, xmlIOFTPClose);
 2208|       |#endif
 2209|       | **********************************/
 2210|      2|    xmlOutputCallbackInitialized = 1;
 2211|      2|}
xmlAllocParserInputBuffer:
 2246|    238|xmlAllocParserInputBuffer(xmlCharEncoding enc) {
 2247|    238|    xmlParserInputBufferPtr ret;
 2248|       |
 2249|    238|    ret = (xmlParserInputBufferPtr) xmlMalloc(sizeof(xmlParserInputBuffer));
 2250|    238|    if (ret == NULL) {
  ------------------
  |  Branch (2250:9): [True: 0, False: 238]
  ------------------
 2251|      0|	return(NULL);
 2252|      0|    }
 2253|    238|    memset(ret, 0, sizeof(xmlParserInputBuffer));
 2254|    238|    ret->buffer = xmlBufCreateSize(2 * xmlDefaultBufferSize);
  ------------------
  |  |  680|    238|  #define xmlDefaultBufferSize XML_GLOBAL_MACRO(xmlDefaultBufferSize)
  |  |  ------------------
  |  |  |  |  500|    238|  #define XML_GLOBAL_MACRO(name) (*__##name())
  |  |  ------------------
  ------------------
 2255|    238|    if (ret->buffer == NULL) {
  ------------------
  |  Branch (2255:9): [True: 0, False: 238]
  ------------------
 2256|      0|        xmlFree(ret);
 2257|      0|	return(NULL);
 2258|      0|    }
 2259|    238|    xmlBufSetAllocationScheme(ret->buffer, XML_BUFFER_ALLOC_DOUBLEIT);
 2260|    238|    ret->encoder = xmlGetCharEncodingHandler(enc);
 2261|    238|    if (ret->encoder != NULL)
  ------------------
  |  Branch (2261:9): [True: 0, False: 238]
  ------------------
 2262|      0|        ret->raw = xmlBufCreateSize(2 * xmlDefaultBufferSize);
  ------------------
  |  |  680|      0|  #define xmlDefaultBufferSize XML_GLOBAL_MACRO(xmlDefaultBufferSize)
  |  |  ------------------
  |  |  |  |  500|      0|  #define XML_GLOBAL_MACRO(name) (*__##name())
  |  |  ------------------
  ------------------
 2263|    238|    else
 2264|    238|        ret->raw = NULL;
 2265|    238|    ret->readcallback = NULL;
 2266|    238|    ret->closecallback = NULL;
 2267|    238|    ret->context = NULL;
 2268|    238|    ret->compressed = -1;
 2269|    238|    ret->rawconsumed = 0;
 2270|       |
 2271|    238|    return(ret);
 2272|    238|}
xmlFreeParserInputBuffer:
 2383|    238|xmlFreeParserInputBuffer(xmlParserInputBufferPtr in) {
 2384|    238|    if (in == NULL) return;
  ------------------
  |  Branch (2384:9): [True: 0, False: 238]
  ------------------
 2385|       |
 2386|    238|    if (in->raw) {
  ------------------
  |  Branch (2386:9): [True: 52, False: 186]
  ------------------
 2387|     52|        xmlBufFree(in->raw);
 2388|     52|	in->raw = NULL;
 2389|     52|    }
 2390|    238|    if (in->encoder != NULL) {
  ------------------
  |  Branch (2390:9): [True: 52, False: 186]
  ------------------
 2391|     52|        xmlCharEncCloseFunc(in->encoder);
 2392|     52|    }
 2393|    238|    if (in->closecallback != NULL) {
  ------------------
  |  Branch (2393:9): [True: 238, False: 0]
  ------------------
 2394|    238|	in->closecallback(in->context);
 2395|    238|    }
 2396|    238|    if (in->buffer != NULL) {
  ------------------
  |  Branch (2396:9): [True: 238, False: 0]
  ------------------
 2397|    238|        xmlBufFree(in->buffer);
 2398|    238|	in->buffer = NULL;
 2399|    238|    }
 2400|       |
 2401|    238|    xmlFree(in);
 2402|    238|}
xmlParserInputBufferCreateMem:
 2870|    238|xmlParserInputBufferCreateMem(const char *mem, int size, xmlCharEncoding enc) {
 2871|    238|    xmlParserInputBufferPtr ret;
 2872|    238|    xmlMemIOCtxt *ctxt;
 2873|       |
 2874|    238|    if (size < 0) return(NULL);
  ------------------
  |  Branch (2874:9): [True: 0, False: 238]
  ------------------
 2875|    238|    if (mem == NULL) return(NULL);
  ------------------
  |  Branch (2875:9): [True: 0, False: 238]
  ------------------
 2876|       |
 2877|    238|    ret = xmlAllocParserInputBuffer(enc);
 2878|    238|    if (ret == NULL)
  ------------------
  |  Branch (2878:9): [True: 0, False: 238]
  ------------------
 2879|      0|        return(NULL);
 2880|       |
 2881|    238|    ctxt = xmlMalloc(sizeof(*ctxt));
 2882|    238|    if (ctxt == NULL) {
  ------------------
  |  Branch (2882:9): [True: 0, False: 238]
  ------------------
 2883|      0|        xmlFreeParserInputBuffer(ret);
 2884|      0|        return(NULL);
 2885|      0|    }
 2886|    238|    ctxt->mem = mem;
 2887|    238|    ctxt->size = size;
 2888|       |
 2889|    238|    ret->context = ctxt;
 2890|    238|    ret->readcallback = xmlMemRead;
 2891|    238|    ret->closecallback = xmlMemClose;
 2892|       |
 2893|    238|    return(ret);
 2894|    238|}
xmlParserInputBufferGrow:
 3185|  16.8k|xmlParserInputBufferGrow(xmlParserInputBufferPtr in, int len) {
 3186|  16.8k|    xmlBufPtr buf;
 3187|  16.8k|    int res = 0;
 3188|       |
 3189|  16.8k|    if ((in == NULL) || (in->error)) return(-1);
  ------------------
  |  Branch (3189:9): [True: 0, False: 16.8k]
  |  Branch (3189:25): [True: 0, False: 16.8k]
  ------------------
 3190|  16.8k|    if ((len <= MINLEN) && (len != 4))
  ------------------
  |  |   73|  16.8k|#define MINLEN 4000
  ------------------
  |  Branch (3190:9): [True: 16.8k, False: 0]
  |  Branch (3190:28): [True: 16.8k, False: 0]
  ------------------
 3191|  16.8k|        len = MINLEN;
  ------------------
  |  |   73|  16.8k|#define MINLEN 4000
  ------------------
 3192|       |
 3193|  16.8k|    if (in->encoder == NULL) {
  ------------------
  |  Branch (3193:9): [True: 13.2k, False: 3.62k]
  ------------------
 3194|  13.2k|        if (in->readcallback == NULL)
  ------------------
  |  Branch (3194:13): [True: 0, False: 13.2k]
  ------------------
 3195|      0|            return(0);
 3196|  13.2k|        buf = in->buffer;
 3197|  13.2k|    } else {
 3198|  3.62k|        if (in->raw == NULL) {
  ------------------
  |  Branch (3198:13): [True: 0, False: 3.62k]
  ------------------
 3199|      0|	    in->raw = xmlBufCreate();
 3200|      0|	}
 3201|  3.62k|        buf = in->raw;
 3202|  3.62k|    }
 3203|       |
 3204|       |    /*
 3205|       |     * Call the read method for this I/O type.
 3206|       |     */
 3207|  16.8k|    if (in->readcallback != NULL) {
  ------------------
  |  Branch (3207:9): [True: 16.8k, False: 0]
  ------------------
 3208|  16.8k|        if (xmlBufGrow(buf, len + 1) < 0) {
  ------------------
  |  Branch (3208:13): [True: 0, False: 16.8k]
  ------------------
 3209|      0|            in->error = XML_ERR_NO_MEMORY;
 3210|      0|            return(-1);
 3211|      0|        }
 3212|       |
 3213|  16.8k|	res = in->readcallback(in->context, (char *)xmlBufEnd(buf), len);
 3214|  16.8k|	if (res <= 0)
  ------------------
  |  Branch (3214:6): [True: 16.6k, False: 263]
  ------------------
 3215|  16.6k|	    in->readcallback = endOfInput;
 3216|  16.8k|        if (res < 0) {
  ------------------
  |  Branch (3216:13): [True: 0, False: 16.8k]
  ------------------
 3217|      0|            in->error = XML_IO_UNKNOWN;
 3218|      0|            return(-1);
 3219|      0|        }
 3220|       |
 3221|  16.8k|        if (xmlBufAddLen(buf, res) < 0) {
  ------------------
  |  Branch (3221:13): [True: 0, False: 16.8k]
  ------------------
 3222|      0|            in->error = XML_ERR_NO_MEMORY;
 3223|      0|            return(-1);
 3224|      0|        }
 3225|  16.8k|    }
 3226|       |
 3227|       |    /*
 3228|       |     * try to establish compressed status of input if not done already
 3229|       |     */
 3230|  16.8k|    if (in->compressed == -1) {
  ------------------
  |  Branch (3230:9): [True: 16.8k, False: 0]
  ------------------
 3231|  16.8k|#ifdef LIBXML_LZMA_ENABLED
 3232|  16.8k|	if (in->readcallback == xmlXzfileRead)
  ------------------
  |  Branch (3232:6): [True: 0, False: 16.8k]
  ------------------
 3233|      0|            in->compressed = __libxml2_xzcompressed(in->context);
 3234|  16.8k|#endif
 3235|  16.8k|    }
 3236|       |
 3237|  16.8k|    if (in->encoder != NULL) {
  ------------------
  |  Branch (3237:9): [True: 3.62k, False: 13.2k]
  ------------------
 3238|  3.62k|	res = xmlCharEncInput(in);
 3239|  3.62k|	if (res < 0)
  ------------------
  |  Branch (3239:6): [True: 0, False: 3.62k]
  ------------------
 3240|      0|	    return(-1);
 3241|  3.62k|    }
 3242|  16.8k|    return(res);
 3243|  16.8k|}
xmlSetExternalEntityLoader:
 3937|      2|xmlSetExternalEntityLoader(xmlExternalEntityLoader f) {
 3938|      2|    xmlCurrentExternalEntityLoader = f;
 3939|      2|}
xmlLoadExternalEntity:
 3966|    242|                      xmlParserCtxtPtr ctxt) {
 3967|    242|    if ((URL != NULL) && (xmlNoNetExists(URL) == 0)) {
  ------------------
  |  Branch (3967:9): [True: 242, False: 0]
  |  Branch (3967:26): [True: 242, False: 0]
  ------------------
 3968|    242|	char *canonicFilename;
 3969|    242|	xmlParserInputPtr ret;
 3970|       |
 3971|    242|	canonicFilename = (char *) xmlCanonicPath((const xmlChar *) URL);
 3972|    242|	if (canonicFilename == NULL) {
  ------------------
  |  Branch (3972:6): [True: 0, False: 242]
  ------------------
 3973|      0|            xmlErrMemory(ctxt, "building canonical path\n");
 3974|      0|	    return(NULL);
 3975|      0|	}
 3976|       |
 3977|    242|	ret = xmlCurrentExternalEntityLoader(canonicFilename, ID, ctxt);
 3978|    242|	xmlFree(canonicFilename);
 3979|    242|	return(ret);
 3980|    242|    }
 3981|      0|    return(xmlCurrentExternalEntityLoader(URL, ID, ctxt));
 3982|    242|}
xmlIO.c:xmlMemRead:
 2839|    499|xmlMemRead(void *vctxt, char *buf, int size) {
 2840|    499|    xmlMemIOCtxt *ctxt = vctxt;
 2841|       |
 2842|    499|    if ((size_t) size > ctxt->size)
  ------------------
  |  Branch (2842:9): [True: 474, False: 25]
  ------------------
 2843|    474|        size = ctxt->size;
 2844|       |
 2845|    499|    memcpy(buf, ctxt->mem, size);
 2846|    499|    ctxt->mem += size;
 2847|    499|    ctxt->size -= size;
 2848|       |
 2849|    499|    return size;
 2850|    499|}
xmlIO.c:xmlMemClose:
 2853|    238|xmlMemClose(void *vctxt) {
 2854|    238|    xmlFree(vctxt);
 2855|    238|    return(0);
 2856|    238|}
xmlIO.c:endOfInput:
 3165|  16.3k|	    int len ATTRIBUTE_UNUSED) {
 3166|  16.3k|    return(0);
 3167|  16.3k|}
xmlIO.c:xmlNoNetExists:
 3781|    242|static int xmlNoNetExists(const char *URL) {
 3782|    242|    const char *path;
 3783|       |
 3784|    242|    if (URL == NULL)
  ------------------
  |  Branch (3784:9): [True: 0, False: 242]
  ------------------
 3785|      0|	return(0);
 3786|       |
 3787|    242|    if (!xmlStrncasecmp(BAD_CAST URL, BAD_CAST "file://localhost/", 17))
  ------------------
  |  |   35|    242|#define BAD_CAST (xmlChar *)
  ------------------
                  if (!xmlStrncasecmp(BAD_CAST URL, BAD_CAST "file://localhost/", 17))
  ------------------
  |  |   35|    242|#define BAD_CAST (xmlChar *)
  ------------------
  |  Branch (3787:9): [True: 0, False: 242]
  ------------------
 3788|       |#if defined (_WIN32)
 3789|       |	path = &URL[17];
 3790|       |#else
 3791|      0|	path = &URL[16];
 3792|    242|#endif
 3793|    242|    else if (!xmlStrncasecmp(BAD_CAST URL, BAD_CAST "file:///", 8)) {
  ------------------
  |  |   35|    242|#define BAD_CAST (xmlChar *)
  ------------------
                  else if (!xmlStrncasecmp(BAD_CAST URL, BAD_CAST "file:///", 8)) {
  ------------------
  |  |   35|    242|#define BAD_CAST (xmlChar *)
  ------------------
  |  Branch (3793:14): [True: 0, False: 242]
  ------------------
 3794|       |#if defined (_WIN32)
 3795|       |	path = &URL[8];
 3796|       |#else
 3797|      0|	path = &URL[7];
 3798|      0|#endif
 3799|      0|    } else
 3800|    242|	path = URL;
 3801|       |
 3802|    242|    return xmlCheckFilename(path);
 3803|    242|}

xmlInitMemoryInternal:
  846|      2|xmlInitMemoryInternal(void) {
  847|      2|     char *breakpoint;
  848|      2|     xmlInitMutex(&xmlMemMutex);
  849|       |
  850|      2|     breakpoint = getenv("XML_MEM_BREAKPOINT");
  851|      2|     if (breakpoint != NULL) {
  ------------------
  |  Branch (851:10): [True: 0, False: 2]
  ------------------
  852|      0|         sscanf(breakpoint, "%ud", &xmlMemStopAtBlock);
  853|      0|     }
  854|      2|     breakpoint = getenv("XML_MEM_TRACE");
  855|      2|     if (breakpoint != NULL) {
  ------------------
  |  Branch (855:10): [True: 0, False: 2]
  ------------------
  856|      0|         sscanf(breakpoint, "%p", &xmlMemTraceBlockAt);
  857|      0|     }
  858|       |
  859|      2|}
xmlMemSetup:
  910|      2|            xmlReallocFunc reallocFunc, xmlStrdupFunc strdupFunc) {
  911|      2|    if (freeFunc == NULL)
  ------------------
  |  Branch (911:9): [True: 0, False: 2]
  ------------------
  912|      0|	return(-1);
  913|      2|    if (mallocFunc == NULL)
  ------------------
  |  Branch (913:9): [True: 0, False: 2]
  ------------------
  914|      0|	return(-1);
  915|      2|    if (reallocFunc == NULL)
  ------------------
  |  Branch (915:9): [True: 0, False: 2]
  ------------------
  916|      0|	return(-1);
  917|      2|    if (strdupFunc == NULL)
  ------------------
  |  Branch (917:9): [True: 0, False: 2]
  ------------------
  918|      0|	return(-1);
  919|      2|    xmlFree = freeFunc;
  920|      2|    xmlMalloc = mallocFunc;
  921|      2|    xmlMallocAtomic = mallocFunc;
  922|      2|    xmlRealloc = reallocFunc;
  923|      2|    xmlMemStrdup = strdupFunc;
  924|      2|    return(0);
  925|      2|}

xmlRegexpCompile:
 5417|     26|xmlRegexpCompile(const xmlChar *regexp) {
 5418|     26|    xmlRegexpPtr ret = NULL;
 5419|     26|    xmlRegParserCtxtPtr ctxt;
 5420|       |
 5421|     26|    if (regexp == NULL)
  ------------------
  |  Branch (5421:9): [True: 0, False: 26]
  ------------------
 5422|      0|        return(NULL);
 5423|       |
 5424|     26|    ctxt = xmlRegNewParserCtxt(regexp);
 5425|     26|    if (ctxt == NULL)
  ------------------
  |  Branch (5425:9): [True: 0, False: 26]
  ------------------
 5426|      0|	return(NULL);
 5427|       |
 5428|       |    /* initialize the parser */
 5429|     26|    ctxt->state = xmlRegStatePush(ctxt);
 5430|     26|    if (ctxt->state == NULL)
  ------------------
  |  Branch (5430:9): [True: 0, False: 26]
  ------------------
 5431|      0|        goto error;
 5432|     26|    ctxt->start = ctxt->state;
 5433|     26|    ctxt->end = NULL;
 5434|       |
 5435|       |    /* parse the expression building an automata */
 5436|     26|    xmlFAParseRegExp(ctxt, 1);
 5437|     26|    if (CUR != 0) {
  ------------------
  |  |   58|     26|#define CUR (*(ctxt->cur))
  ------------------
  |  Branch (5437:9): [True: 0, False: 26]
  ------------------
 5438|      0|	ERROR("xmlFAParseRegExp: extra characters");
  ------------------
  |  |   55|      0|    ctxt->error = XML_REGEXP_COMPILE_ERROR;				\
  |  |   56|      0|    xmlRegexpErrCompile(ctxt, str);
  ------------------
 5439|      0|    }
 5440|     26|    if (ctxt->error != 0)
  ------------------
  |  Branch (5440:9): [True: 0, False: 26]
  ------------------
 5441|      0|        goto error;
 5442|     26|    ctxt->end = ctxt->state;
 5443|     26|    ctxt->start->type = XML_REGEXP_START_STATE;
 5444|     26|    ctxt->end->type = XML_REGEXP_FINAL_STATE;
 5445|       |
 5446|       |    /* remove the Epsilon except for counted transitions */
 5447|     26|    xmlFAEliminateEpsilonTransitions(ctxt);
 5448|       |
 5449|       |
 5450|     26|    if (ctxt->error != 0)
  ------------------
  |  Branch (5450:9): [True: 0, False: 26]
  ------------------
 5451|      0|        goto error;
 5452|     26|    ret = xmlRegEpxFromParse(ctxt);
 5453|       |
 5454|     26|error:
 5455|     26|    xmlRegFreeParserCtxt(ctxt);
 5456|     26|    return(ret);
 5457|     26|}
xmlRegexpIsDeterminist:
 5484|    410|xmlRegexpIsDeterminist(xmlRegexpPtr comp) {
 5485|    410|    xmlAutomataPtr am;
 5486|    410|    int ret;
 5487|       |
 5488|    410|    if (comp == NULL)
  ------------------
  |  Branch (5488:9): [True: 0, False: 410]
  ------------------
 5489|      0|	return(-1);
 5490|    410|    if (comp->determinist != -1)
  ------------------
  |  Branch (5490:9): [True: 192, False: 218]
  ------------------
 5491|    192|	return(comp->determinist);
 5492|       |
 5493|    218|    am = xmlNewAutomata();
 5494|    218|    if (am == NULL)
  ------------------
  |  Branch (5494:9): [True: 0, False: 218]
  ------------------
 5495|      0|        return(-1);
 5496|    218|    if (am->states != NULL) {
  ------------------
  |  Branch (5496:9): [True: 218, False: 0]
  ------------------
 5497|    218|	int i;
 5498|       |
 5499|    436|	for (i = 0;i < am->nbStates;i++)
  ------------------
  |  Branch (5499:13): [True: 218, False: 218]
  ------------------
 5500|    218|	    xmlRegFreeState(am->states[i]);
 5501|    218|	xmlFree(am->states);
 5502|    218|    }
 5503|    218|    am->nbAtoms = comp->nbAtoms;
 5504|    218|    am->atoms = comp->atoms;
 5505|    218|    am->nbStates = comp->nbStates;
 5506|    218|    am->states = comp->states;
 5507|    218|    am->determinist = -1;
 5508|    218|    am->flags = comp->flags;
 5509|    218|    ret = xmlFAComputesDeterminism(am);
 5510|    218|    am->atoms = NULL;
 5511|    218|    am->states = NULL;
 5512|    218|    xmlFreeAutomata(am);
 5513|    218|    comp->determinist = ret;
 5514|    218|    return(ret);
 5515|    218|}
xmlRegFreeRegexp:
 5524|    218|xmlRegFreeRegexp(xmlRegexpPtr regexp) {
 5525|    218|    int i;
 5526|    218|    if (regexp == NULL)
  ------------------
  |  Branch (5526:9): [True: 0, False: 218]
  ------------------
 5527|      0|	return;
 5528|       |
 5529|    218|    if (regexp->string != NULL)
  ------------------
  |  Branch (5529:9): [True: 26, False: 192]
  ------------------
 5530|     26|	xmlFree(regexp->string);
 5531|    218|    if (regexp->states != NULL) {
  ------------------
  |  Branch (5531:9): [True: 91, False: 127]
  ------------------
 5532|    659|	for (i = 0;i < regexp->nbStates;i++)
  ------------------
  |  Branch (5532:13): [True: 568, False: 91]
  ------------------
 5533|    568|	    xmlRegFreeState(regexp->states[i]);
 5534|     91|	xmlFree(regexp->states);
 5535|     91|    }
 5536|    218|    if (regexp->atoms != NULL) {
  ------------------
  |  Branch (5536:9): [True: 83, False: 135]
  ------------------
 5537|    435|	for (i = 0;i < regexp->nbAtoms;i++)
  ------------------
  |  Branch (5537:13): [True: 352, False: 83]
  ------------------
 5538|    352|	    xmlRegFreeAtom(regexp->atoms[i]);
 5539|     83|	xmlFree(regexp->atoms);
 5540|     83|    }
 5541|    218|    if (regexp->counters != NULL)
  ------------------
  |  Branch (5541:9): [True: 50, False: 168]
  ------------------
 5542|     50|	xmlFree(regexp->counters);
 5543|    218|    if (regexp->compact != NULL)
  ------------------
  |  Branch (5543:9): [True: 127, False: 91]
  ------------------
 5544|    127|	xmlFree(regexp->compact);
 5545|    218|    if (regexp->transdata != NULL)
  ------------------
  |  Branch (5545:9): [True: 127, False: 91]
  ------------------
 5546|    127|	xmlFree(regexp->transdata);
 5547|    218|    if (regexp->stringMap != NULL) {
  ------------------
  |  Branch (5547:9): [True: 127, False: 91]
  ------------------
 5548|    471|	for (i = 0; i < regexp->nbstrings;i++)
  ------------------
  |  Branch (5548:14): [True: 344, False: 127]
  ------------------
 5549|    344|	    xmlFree(regexp->stringMap[i]);
 5550|    127|	xmlFree(regexp->stringMap);
 5551|    127|    }
 5552|       |
 5553|    218|    xmlFree(regexp);
 5554|    218|}
xmlNewAutomata:
 5571|    410|xmlNewAutomata(void) {
 5572|    410|    xmlAutomataPtr ctxt;
 5573|       |
 5574|    410|    ctxt = xmlRegNewParserCtxt(NULL);
 5575|    410|    if (ctxt == NULL)
  ------------------
  |  Branch (5575:9): [True: 0, False: 410]
  ------------------
 5576|      0|	return(NULL);
 5577|       |
 5578|       |    /* initialize the parser */
 5579|    410|    ctxt->state = xmlRegStatePush(ctxt);
 5580|    410|    if (ctxt->state == NULL) {
  ------------------
  |  Branch (5580:9): [True: 0, False: 410]
  ------------------
 5581|      0|	xmlFreeAutomata(ctxt);
 5582|      0|	return(NULL);
 5583|      0|    }
 5584|    410|    ctxt->start = ctxt->state;
 5585|    410|    ctxt->end = NULL;
 5586|       |
 5587|    410|    ctxt->start->type = XML_REGEXP_START_STATE;
 5588|    410|    ctxt->flags = 0;
 5589|       |
 5590|    410|    return(ctxt);
 5591|    410|}
xmlFreeAutomata:
 5600|    410|xmlFreeAutomata(xmlAutomataPtr am) {
 5601|    410|    if (am == NULL)
  ------------------
  |  Branch (5601:9): [True: 0, False: 410]
  ------------------
 5602|      0|	return;
 5603|    410|    xmlRegFreeParserCtxt(am);
 5604|    410|}
xmlAutomataGetInitState:
 5629|    192|xmlAutomataGetInitState(xmlAutomataPtr am) {
 5630|    192|    if (am == NULL)
  ------------------
  |  Branch (5630:9): [True: 0, False: 192]
  ------------------
 5631|      0|	return(NULL);
 5632|    192|    return(am->start);
 5633|    192|}
xmlAutomataSetFinalState:
 5645|    192|xmlAutomataSetFinalState(xmlAutomataPtr am, xmlAutomataStatePtr state) {
 5646|    192|    if ((am == NULL) || (state == NULL))
  ------------------
  |  Branch (5646:9): [True: 0, False: 192]
  |  Branch (5646:25): [True: 0, False: 192]
  ------------------
 5647|      0|	return(-1);
 5648|    192|    state->type = XML_REGEXP_FINAL_STATE;
 5649|    192|    return(0);
 5650|    192|}
xmlAutomataNewTransition2:
 5707|    567|			  const xmlChar *token2, void *data) {
 5708|    567|    xmlRegAtomPtr atom;
 5709|       |
 5710|    567|    if ((am == NULL) || (from == NULL) || (token == NULL))
  ------------------
  |  Branch (5710:9): [True: 0, False: 567]
  |  Branch (5710:25): [True: 0, False: 567]
  |  Branch (5710:43): [True: 0, False: 567]
  ------------------
 5711|      0|	return(NULL);
 5712|    567|    atom = xmlRegNewAtom(am, XML_REGEXP_STRING);
 5713|    567|    if (atom == NULL)
  ------------------
  |  Branch (5713:9): [True: 0, False: 567]
  ------------------
 5714|      0|	return(NULL);
 5715|    567|    atom->data = data;
 5716|    567|    if ((token2 == NULL) || (*token2 == 0)) {
  ------------------
  |  Branch (5716:9): [True: 334, False: 233]
  |  Branch (5716:29): [True: 0, False: 233]
  ------------------
 5717|    334|	atom->valuep = xmlStrdup(token);
 5718|    334|    } else {
 5719|    233|	int lenn, lenp;
 5720|    233|	xmlChar *str;
 5721|       |
 5722|    233|	lenn = strlen((char *) token2);
 5723|    233|	lenp = strlen((char *) token);
 5724|       |
 5725|    233|	str = (xmlChar *) xmlMallocAtomic(lenn + lenp + 2);
 5726|    233|	if (str == NULL) {
  ------------------
  |  Branch (5726:6): [True: 0, False: 233]
  ------------------
 5727|      0|	    xmlRegFreeAtom(atom);
 5728|      0|	    return(NULL);
 5729|      0|	}
 5730|    233|	memcpy(&str[0], token, lenp);
 5731|    233|	str[lenp] = '|';
 5732|    233|	memcpy(&str[lenp + 1], token2, lenn);
 5733|    233|	str[lenn + lenp + 1] = 0;
 5734|       |
 5735|    233|	atom->valuep = str;
 5736|    233|    }
 5737|       |
 5738|    567|    if (xmlFAGenerateTransitions(am, from, to, atom) < 0) {
  ------------------
  |  Branch (5738:9): [True: 0, False: 567]
  ------------------
 5739|      0|        xmlRegFreeAtom(atom);
 5740|      0|	return(NULL);
 5741|      0|    }
 5742|    567|    if (to == NULL)
  ------------------
  |  Branch (5742:9): [True: 483, False: 84]
  ------------------
 5743|    483|	return(am->state);
 5744|     84|    return(to);
 5745|    567|}
xmlAutomataNewNegTrans:
 5767|     13|		       const xmlChar *token2, void *data) {
 5768|     13|    xmlRegAtomPtr atom;
 5769|     13|    xmlChar err_msg[200];
 5770|       |
 5771|     13|    if ((am == NULL) || (from == NULL) || (token == NULL))
  ------------------
  |  Branch (5771:9): [True: 0, False: 13]
  |  Branch (5771:25): [True: 0, False: 13]
  |  Branch (5771:43): [True: 0, False: 13]
  ------------------
 5772|      0|	return(NULL);
 5773|     13|    atom = xmlRegNewAtom(am, XML_REGEXP_STRING);
 5774|     13|    if (atom == NULL)
  ------------------
  |  Branch (5774:9): [True: 0, False: 13]
  ------------------
 5775|      0|	return(NULL);
 5776|     13|    atom->data = data;
 5777|     13|    atom->neg = 1;
 5778|     13|    if ((token2 == NULL) || (*token2 == 0)) {
  ------------------
  |  Branch (5778:9): [True: 0, False: 13]
  |  Branch (5778:29): [True: 0, False: 13]
  ------------------
 5779|      0|	atom->valuep = xmlStrdup(token);
 5780|     13|    } else {
 5781|     13|	int lenn, lenp;
 5782|     13|	xmlChar *str;
 5783|       |
 5784|     13|	lenn = strlen((char *) token2);
 5785|     13|	lenp = strlen((char *) token);
 5786|       |
 5787|     13|	str = (xmlChar *) xmlMallocAtomic(lenn + lenp + 2);
 5788|     13|	if (str == NULL) {
  ------------------
  |  Branch (5788:6): [True: 0, False: 13]
  ------------------
 5789|      0|	    xmlRegFreeAtom(atom);
 5790|      0|	    return(NULL);
 5791|      0|	}
 5792|     13|	memcpy(&str[0], token, lenp);
 5793|     13|	str[lenp] = '|';
 5794|     13|	memcpy(&str[lenp + 1], token2, lenn);
 5795|     13|	str[lenn + lenp + 1] = 0;
 5796|       |
 5797|     13|	atom->valuep = str;
 5798|     13|    }
 5799|     13|    snprintf((char *) err_msg, 199, "not %s", (const char *) atom->valuep);
 5800|     13|    err_msg[199] = 0;
 5801|     13|    atom->valuep2 = xmlStrdup(err_msg);
 5802|       |
 5803|     13|    if (xmlFAGenerateTransitions(am, from, to, atom) < 0) {
  ------------------
  |  Branch (5803:9): [True: 0, False: 13]
  ------------------
 5804|      0|        xmlRegFreeAtom(atom);
 5805|      0|	return(NULL);
 5806|      0|    }
 5807|     13|    am->negs++;
 5808|     13|    if (to == NULL)
  ------------------
  |  Branch (5808:9): [True: 0, False: 13]
  ------------------
 5809|      0|	return(am->state);
 5810|     13|    return(to);
 5811|     13|}
xmlAutomataNewCountTrans2:
 5835|      9|			 int min, int max, void *data) {
 5836|      9|    xmlRegAtomPtr atom;
 5837|      9|    int counter;
 5838|       |
 5839|      9|    if ((am == NULL) || (from == NULL) || (token == NULL))
  ------------------
  |  Branch (5839:9): [True: 0, False: 9]
  |  Branch (5839:25): [True: 0, False: 9]
  |  Branch (5839:43): [True: 0, False: 9]
  ------------------
 5840|      0|	return(NULL);
 5841|      9|    if (min < 0)
  ------------------
  |  Branch (5841:9): [True: 0, False: 9]
  ------------------
 5842|      0|	return(NULL);
 5843|      9|    if ((max < min) || (max < 1))
  ------------------
  |  Branch (5843:9): [True: 0, False: 9]
  |  Branch (5843:24): [True: 0, False: 9]
  ------------------
 5844|      0|	return(NULL);
 5845|      9|    atom = xmlRegNewAtom(am, XML_REGEXP_STRING);
 5846|      9|    if (atom == NULL)
  ------------------
  |  Branch (5846:9): [True: 0, False: 9]
  ------------------
 5847|      0|	return(NULL);
 5848|      9|    if ((token2 == NULL) || (*token2 == 0)) {
  ------------------
  |  Branch (5848:9): [True: 6, False: 3]
  |  Branch (5848:29): [True: 0, False: 3]
  ------------------
 5849|      6|	atom->valuep = xmlStrdup(token);
 5850|      6|        if (atom->valuep == NULL)
  ------------------
  |  Branch (5850:13): [True: 0, False: 6]
  ------------------
 5851|      0|            goto error;
 5852|      6|    } else {
 5853|      3|	int lenn, lenp;
 5854|      3|	xmlChar *str;
 5855|       |
 5856|      3|	lenn = strlen((char *) token2);
 5857|      3|	lenp = strlen((char *) token);
 5858|       |
 5859|      3|	str = (xmlChar *) xmlMallocAtomic(lenn + lenp + 2);
 5860|      3|	if (str == NULL)
  ------------------
  |  Branch (5860:6): [True: 0, False: 3]
  ------------------
 5861|      0|	    goto error;
 5862|      3|	memcpy(&str[0], token, lenp);
 5863|      3|	str[lenp] = '|';
 5864|      3|	memcpy(&str[lenp + 1], token2, lenn);
 5865|      3|	str[lenn + lenp + 1] = 0;
 5866|       |
 5867|      3|	atom->valuep = str;
 5868|      3|    }
 5869|      9|    atom->data = data;
 5870|      9|    if (min == 0)
  ------------------
  |  Branch (5870:9): [True: 9, False: 0]
  ------------------
 5871|      9|	atom->min = 1;
 5872|      0|    else
 5873|      0|	atom->min = min;
 5874|      9|    atom->max = max;
 5875|       |
 5876|       |    /*
 5877|       |     * associate a counter to the transition.
 5878|       |     */
 5879|      9|    counter = xmlRegGetCounter(am);
 5880|      9|    if (counter < 0)
  ------------------
  |  Branch (5880:9): [True: 0, False: 9]
  ------------------
 5881|      0|        goto error;
 5882|      9|    am->counters[counter].min = min;
 5883|      9|    am->counters[counter].max = max;
 5884|       |
 5885|       |    /* xmlFAGenerateTransitions(am, from, to, atom); */
 5886|      9|    if (to == NULL) {
  ------------------
  |  Branch (5886:9): [True: 0, False: 9]
  ------------------
 5887|      0|	to = xmlRegStatePush(am);
 5888|      0|        if (to == NULL)
  ------------------
  |  Branch (5888:13): [True: 0, False: 0]
  ------------------
 5889|      0|            goto error;
 5890|      0|    }
 5891|      9|    xmlRegStateAddTrans(am, from, atom, to, counter, -1);
 5892|      9|    if (xmlRegAtomPush(am, atom) < 0)
  ------------------
  |  Branch (5892:9): [True: 0, False: 9]
  ------------------
 5893|      0|        goto error;
 5894|      9|    am->state = to;
 5895|       |
 5896|      9|    if (to == NULL)
  ------------------
  |  Branch (5896:9): [True: 0, False: 9]
  ------------------
 5897|      0|	to = am->state;
 5898|      9|    if (to == NULL)
  ------------------
  |  Branch (5898:9): [True: 0, False: 9]
  ------------------
 5899|      0|	return(NULL);
 5900|      9|    if (min == 0)
  ------------------
  |  Branch (5900:9): [True: 9, False: 0]
  ------------------
 5901|      9|	xmlFAGenerateEpsilonTransition(am, from, to);
 5902|      9|    return(to);
 5903|       |
 5904|      0|error:
 5905|      0|    xmlRegFreeAtom(atom);
 5906|      0|    return(NULL);
 5907|      9|}
xmlAutomataNewOnceTrans2:
 6008|      7|			 int min, int max, void *data) {
 6009|      7|    xmlRegAtomPtr atom;
 6010|      7|    int counter;
 6011|       |
 6012|      7|    if ((am == NULL) || (from == NULL) || (token == NULL))
  ------------------
  |  Branch (6012:9): [True: 0, False: 7]
  |  Branch (6012:25): [True: 0, False: 7]
  |  Branch (6012:43): [True: 0, False: 7]
  ------------------
 6013|      0|	return(NULL);
 6014|      7|    if (min < 1)
  ------------------
  |  Branch (6014:9): [True: 0, False: 7]
  ------------------
 6015|      0|	return(NULL);
 6016|      7|    if (max < min)
  ------------------
  |  Branch (6016:9): [True: 0, False: 7]
  ------------------
 6017|      0|	return(NULL);
 6018|      7|    atom = xmlRegNewAtom(am, XML_REGEXP_STRING);
 6019|      7|    if (atom == NULL)
  ------------------
  |  Branch (6019:9): [True: 0, False: 7]
  ------------------
 6020|      0|	return(NULL);
 6021|      7|    if ((token2 == NULL) || (*token2 == 0)) {
  ------------------
  |  Branch (6021:9): [True: 7, False: 0]
  |  Branch (6021:29): [True: 0, False: 0]
  ------------------
 6022|      7|	atom->valuep = xmlStrdup(token);
 6023|      7|        if (atom->valuep == NULL)
  ------------------
  |  Branch (6023:13): [True: 0, False: 7]
  ------------------
 6024|      0|            goto error;
 6025|      7|    } else {
 6026|      0|	int lenn, lenp;
 6027|      0|	xmlChar *str;
 6028|       |
 6029|      0|	lenn = strlen((char *) token2);
 6030|      0|	lenp = strlen((char *) token);
 6031|       |
 6032|      0|	str = (xmlChar *) xmlMallocAtomic(lenn + lenp + 2);
 6033|      0|	if (str == NULL)
  ------------------
  |  Branch (6033:6): [True: 0, False: 0]
  ------------------
 6034|      0|	    goto error;
 6035|      0|	memcpy(&str[0], token, lenp);
 6036|      0|	str[lenp] = '|';
 6037|      0|	memcpy(&str[lenp + 1], token2, lenn);
 6038|      0|	str[lenn + lenp + 1] = 0;
 6039|       |
 6040|      0|	atom->valuep = str;
 6041|      0|    }
 6042|      7|    atom->data = data;
 6043|      7|    atom->quant = XML_REGEXP_QUANT_ONCEONLY;
 6044|      7|    atom->min = min;
 6045|      7|    atom->max = max;
 6046|       |    /*
 6047|       |     * associate a counter to the transition.
 6048|       |     */
 6049|      7|    counter = xmlRegGetCounter(am);
 6050|      7|    if (counter < 0)
  ------------------
  |  Branch (6050:9): [True: 0, False: 7]
  ------------------
 6051|      0|        goto error;
 6052|      7|    am->counters[counter].min = 1;
 6053|      7|    am->counters[counter].max = 1;
 6054|       |
 6055|       |    /* xmlFAGenerateTransitions(am, from, to, atom); */
 6056|      7|    if (to == NULL) {
  ------------------
  |  Branch (6056:9): [True: 0, False: 7]
  ------------------
 6057|      0|	to = xmlRegStatePush(am);
 6058|      0|        if (to == NULL)
  ------------------
  |  Branch (6058:13): [True: 0, False: 0]
  ------------------
 6059|      0|            goto error;
 6060|      0|    }
 6061|      7|    xmlRegStateAddTrans(am, from, atom, to, counter, -1);
 6062|      7|    if (xmlRegAtomPush(am, atom) < 0)
  ------------------
  |  Branch (6062:9): [True: 0, False: 7]
  ------------------
 6063|      0|        goto error;
 6064|      7|    am->state = to;
 6065|      7|    return(to);
 6066|       |
 6067|      0|error:
 6068|      0|    xmlRegFreeAtom(atom);
 6069|      0|    return(NULL);
 6070|      7|}
xmlAutomataNewState:
 6148|    125|xmlAutomataNewState(xmlAutomataPtr am) {
 6149|    125|    if (am == NULL)
  ------------------
  |  Branch (6149:9): [True: 0, False: 125]
  ------------------
 6150|      0|	return(NULL);
 6151|    125|    return(xmlRegStatePush(am));
 6152|    125|}
xmlAutomataNewEpsilon:
 6168|    379|		      xmlAutomataStatePtr to) {
 6169|    379|    if ((am == NULL) || (from == NULL))
  ------------------
  |  Branch (6169:9): [True: 0, False: 379]
  |  Branch (6169:25): [True: 0, False: 379]
  ------------------
 6170|      0|	return(NULL);
 6171|    379|    xmlFAGenerateEpsilonTransition(am, from, to);
 6172|    379|    if (to == NULL)
  ------------------
  |  Branch (6172:9): [True: 36, False: 343]
  ------------------
 6173|     36|	return(am->state);
 6174|    343|    return(to);
 6175|    379|}
xmlAutomataNewAllTrans:
 6193|     11|		       xmlAutomataStatePtr to, int lax) {
 6194|     11|    if ((am == NULL) || (from == NULL))
  ------------------
  |  Branch (6194:9): [True: 0, False: 11]
  |  Branch (6194:25): [True: 0, False: 11]
  ------------------
 6195|      0|	return(NULL);
 6196|     11|    xmlFAGenerateAllTransition(am, from, to, lax);
 6197|     11|    if (to == NULL)
  ------------------
  |  Branch (6197:9): [True: 11, False: 0]
  ------------------
 6198|     11|	return(am->state);
 6199|      0|    return(to);
 6200|     11|}
xmlAutomataNewCounter:
 6213|     48|xmlAutomataNewCounter(xmlAutomataPtr am, int min, int max) {
 6214|     48|    int ret;
 6215|       |
 6216|     48|    if (am == NULL)
  ------------------
  |  Branch (6216:9): [True: 0, False: 48]
  ------------------
 6217|      0|	return(-1);
 6218|       |
 6219|     48|    ret = xmlRegGetCounter(am);
 6220|     48|    if (ret < 0)
  ------------------
  |  Branch (6220:9): [True: 0, False: 48]
  ------------------
 6221|      0|	return(-1);
 6222|     48|    am->counters[ret].min = min;
 6223|     48|    am->counters[ret].max = max;
 6224|     48|    return(ret);
 6225|     48|}
xmlAutomataNewCountedTrans:
 6242|     48|		xmlAutomataStatePtr to, int counter) {
 6243|     48|    if ((am == NULL) || (from == NULL) || (counter < 0))
  ------------------
  |  Branch (6243:9): [True: 0, False: 48]
  |  Branch (6243:25): [True: 0, False: 48]
  |  Branch (6243:43): [True: 0, False: 48]
  ------------------
 6244|      0|	return(NULL);
 6245|     48|    xmlFAGenerateCountedEpsilonTransition(am, from, to, counter);
 6246|     48|    if (to == NULL)
  ------------------
  |  Branch (6246:9): [True: 4, False: 44]
  ------------------
 6247|      4|	return(am->state);
 6248|     44|    return(to);
 6249|     48|}
xmlAutomataNewCounterTrans:
 6266|     44|		xmlAutomataStatePtr to, int counter) {
 6267|     44|    if ((am == NULL) || (from == NULL) || (counter < 0))
  ------------------
  |  Branch (6267:9): [True: 0, False: 44]
  |  Branch (6267:25): [True: 0, False: 44]
  |  Branch (6267:43): [True: 0, False: 44]
  ------------------
 6268|      0|	return(NULL);
 6269|     44|    xmlFAGenerateCountedTransition(am, from, to, counter);
 6270|     44|    if (to == NULL)
  ------------------
  |  Branch (6270:9): [True: 12, False: 32]
  ------------------
 6271|     12|	return(am->state);
 6272|     32|    return(to);
 6273|     44|}
xmlAutomataCompile:
 6285|    192|xmlAutomataCompile(xmlAutomataPtr am) {
 6286|    192|    xmlRegexpPtr ret;
 6287|       |
 6288|    192|    if ((am == NULL) || (am->error != 0)) return(NULL);
  ------------------
  |  Branch (6288:9): [True: 0, False: 192]
  |  Branch (6288:25): [True: 0, False: 192]
  ------------------
 6289|    192|    xmlFAEliminateEpsilonTransitions(am);
 6290|       |    /* xmlFAComputesDeterminism(am); */
 6291|    192|    ret = xmlRegEpxFromParse(am);
 6292|       |
 6293|    192|    return(ret);
 6294|    192|}
xmlregexp.c:xmlRegStrEqualWildcard:
 3572|  3.13k|xmlRegStrEqualWildcard(const xmlChar *expStr, const xmlChar *valStr) {
 3573|  3.13k|    if (expStr == valStr) return(1);
  ------------------
  |  Branch (3573:9): [True: 0, False: 3.13k]
  ------------------
 3574|  3.13k|    if (expStr == NULL) return(0);
  ------------------
  |  Branch (3574:9): [True: 0, False: 3.13k]
  ------------------
 3575|  3.13k|    if (valStr == NULL) return(0);
  ------------------
  |  Branch (3575:9): [True: 0, False: 3.13k]
  ------------------
 3576|  3.79k|    do {
 3577|       |	/*
 3578|       |	* Eval if we have a wildcard for the current item.
 3579|       |	*/
 3580|  3.79k|        if (*expStr != *valStr) {
  ------------------
  |  Branch (3580:13): [True: 3.12k, False: 679]
  ------------------
 3581|       |	    /* if one of them starts with a wildcard make valStr be it */
 3582|  3.12k|	    if (*valStr == '*') {
  ------------------
  |  Branch (3582:10): [True: 3, False: 3.11k]
  ------------------
 3583|      3|	        const xmlChar *tmp;
 3584|       |
 3585|      3|		tmp = valStr;
 3586|      3|		valStr = expStr;
 3587|      3|		expStr = tmp;
 3588|      3|	    }
 3589|  3.12k|	    if ((*valStr != 0) && (*expStr != 0) && (*expStr++ == '*')) {
  ------------------
  |  Branch (3589:10): [True: 3.12k, False: 0]
  |  Branch (3589:28): [True: 3.12k, False: 0]
  |  Branch (3589:46): [True: 6, False: 3.11k]
  ------------------
 3590|     38|		do {
 3591|     38|		    if (*valStr == XML_REG_STRING_SEPARATOR)
  ------------------
  |  |   62|     38|#define XML_REG_STRING_SEPARATOR '|'
  ------------------
  |  Branch (3591:11): [True: 6, False: 32]
  ------------------
 3592|      6|			break;
 3593|     32|		    valStr++;
 3594|     32|		} while (*valStr != 0);
  ------------------
  |  Branch (3594:12): [True: 32, False: 0]
  ------------------
 3595|      0|		continue;
 3596|      6|	    } else
 3597|  3.11k|		return(0);
 3598|  3.12k|	}
 3599|    679|	expStr++;
 3600|    679|	valStr++;
 3601|    685|    } while (*valStr != 0);
  ------------------
  |  Branch (3601:14): [True: 666, False: 19]
  ------------------
 3602|     19|    if (*expStr != 0)
  ------------------
  |  Branch (3602:9): [True: 9, False: 10]
  ------------------
 3603|      9|	return (0);
 3604|     10|    else
 3605|     10|	return (1);
 3606|     19|}
xmlregexp.c:xmlRegNewParserCtxt:
  694|    436|xmlRegNewParserCtxt(const xmlChar *string) {
  695|    436|    xmlRegParserCtxtPtr ret;
  696|       |
  697|    436|    ret = (xmlRegParserCtxtPtr) xmlMalloc(sizeof(xmlRegParserCtxt));
  698|    436|    if (ret == NULL)
  ------------------
  |  Branch (698:9): [True: 0, False: 436]
  ------------------
  699|      0|	return(NULL);
  700|    436|    memset(ret, 0, sizeof(xmlRegParserCtxt));
  701|    436|    if (string != NULL)
  ------------------
  |  Branch (701:9): [True: 26, False: 410]
  ------------------
  702|     26|	ret->string = xmlStrdup(string);
  703|    436|    ret->cur = ret->string;
  704|    436|    ret->neg = 0;
  705|    436|    ret->negs = 0;
  706|    436|    ret->error = 0;
  707|    436|    ret->determinist = -1;
  708|    436|    return(ret);
  709|    436|}
xmlregexp.c:xmlRegStatePush:
 1369|  1.28k|xmlRegStatePush(xmlRegParserCtxtPtr ctxt) {
 1370|  1.28k|    xmlRegStatePtr state;
 1371|       |
 1372|  1.28k|    if (ctxt->nbStates >= ctxt->maxStates) {
  ------------------
  |  Branch (1372:9): [True: 549, False: 739]
  ------------------
 1373|    549|        size_t newSize = ctxt->maxStates ? ctxt->maxStates * 2 : 4;
  ------------------
  |  Branch (1373:26): [True: 113, False: 436]
  ------------------
 1374|    549|	xmlRegStatePtr *tmp;
 1375|       |
 1376|    549|	tmp = xmlRealloc(ctxt->states, newSize * sizeof(tmp[0]));
 1377|    549|	if (tmp == NULL) {
  ------------------
  |  Branch (1377:6): [True: 0, False: 549]
  ------------------
 1378|      0|	    xmlRegexpErrMemory(ctxt, "adding state");
 1379|      0|	    return(NULL);
 1380|      0|	}
 1381|    549|	ctxt->states = tmp;
 1382|    549|	ctxt->maxStates = newSize;
 1383|    549|    }
 1384|       |
 1385|  1.28k|    state = xmlRegNewState(ctxt);
 1386|  1.28k|    if (state == NULL)
  ------------------
  |  Branch (1386:9): [True: 0, False: 1.28k]
  ------------------
 1387|      0|        return(NULL);
 1388|       |
 1389|  1.28k|    state->no = ctxt->nbStates;
 1390|  1.28k|    ctxt->states[ctxt->nbStates++] = state;
 1391|       |
 1392|  1.28k|    return(state);
 1393|  1.28k|}
xmlregexp.c:xmlRegNewState:
  885|  1.28k|xmlRegNewState(xmlRegParserCtxtPtr ctxt) {
  886|  1.28k|    xmlRegStatePtr ret;
  887|       |
  888|  1.28k|    ret = (xmlRegStatePtr) xmlMalloc(sizeof(xmlRegState));
  889|  1.28k|    if (ret == NULL) {
  ------------------
  |  Branch (889:9): [True: 0, False: 1.28k]
  ------------------
  890|      0|	xmlRegexpErrMemory(ctxt, "allocating state");
  891|      0|	return(NULL);
  892|      0|    }
  893|  1.28k|    memset(ret, 0, sizeof(xmlRegState));
  894|  1.28k|    ret->type = XML_REGEXP_TRANS_STATE;
  895|  1.28k|    ret->mark = XML_REGEXP_MARK_NORMAL;
  896|  1.28k|    return(ret);
  897|  1.28k|}
xmlregexp.c:xmlFAParseRegExp:
 5336|     39|xmlFAParseRegExp(xmlRegParserCtxtPtr ctxt, int top) {
 5337|     39|    xmlRegStatePtr start, end;
 5338|       |
 5339|       |    /* if not top start should have been generated by an epsilon trans */
 5340|     39|    start = ctxt->state;
 5341|     39|    ctxt->end = NULL;
 5342|     39|    xmlFAParseBranch(ctxt, NULL);
 5343|     39|    if (top) {
  ------------------
  |  Branch (5343:9): [True: 26, False: 13]
  ------------------
 5344|     26|	ctxt->state->type = XML_REGEXP_FINAL_STATE;
 5345|     26|    }
 5346|     39|    if (CUR != '|') {
  ------------------
  |  |   58|     39|#define CUR (*(ctxt->cur))
  ------------------
  |  Branch (5346:9): [True: 29, False: 10]
  ------------------
 5347|     29|	ctxt->end = ctxt->state;
 5348|     29|	return;
 5349|     29|    }
 5350|     10|    end = ctxt->state;
 5351|     31|    while ((CUR == '|') && (ctxt->error == 0)) {
  ------------------
  |  |   58|     31|#define CUR (*(ctxt->cur))
  ------------------
  |  Branch (5351:12): [True: 21, False: 10]
  |  Branch (5351:28): [True: 21, False: 0]
  ------------------
 5352|     21|	NEXT;
  ------------------
  |  |   57|     21|#define NEXT ctxt->cur++
  ------------------
 5353|     21|	ctxt->state = start;
 5354|     21|	ctxt->end = NULL;
 5355|     21|	xmlFAParseBranch(ctxt, end);
 5356|     21|    }
 5357|     10|    if (!top) {
  ------------------
  |  Branch (5357:9): [True: 10, False: 0]
  ------------------
 5358|     10|	ctxt->state = end;
 5359|     10|	ctxt->end = end;
 5360|     10|    }
 5361|     10|}
xmlregexp.c:xmlFAParseBranch:
 5291|     60|xmlFAParseBranch(xmlRegParserCtxtPtr ctxt, xmlRegStatePtr to) {
 5292|     60|    xmlRegStatePtr previous;
 5293|     60|    int ret;
 5294|       |
 5295|     60|    previous = ctxt->state;
 5296|     60|    ret = xmlFAParsePiece(ctxt);
 5297|     60|    if (ret == 0) {
  ------------------
  |  Branch (5297:9): [True: 0, False: 60]
  ------------------
 5298|       |        /* Empty branch */
 5299|      0|	xmlFAGenerateEpsilonTransition(ctxt, previous, to);
 5300|     60|    } else {
 5301|     60|	if (xmlFAGenerateTransitions(ctxt, previous,
  ------------------
  |  Branch (5301:6): [True: 0, False: 60]
  ------------------
 5302|     60|	        (CUR=='|' || CUR==')' || CUR==0) ? to : NULL,
  ------------------
  |  |   58|     60|#define CUR (*(ctxt->cur))
  ------------------
              	        (CUR=='|' || CUR==')' || CUR==0) ? to : NULL,
  ------------------
  |  |   58|     60|#define CUR (*(ctxt->cur))
  ------------------
              	        (CUR=='|' || CUR==')' || CUR==0) ? to : NULL,
  ------------------
  |  |   58|     58|#define CUR (*(ctxt->cur))
  ------------------
  |  Branch (5302:11): [True: 0, False: 60]
  |  Branch (5302:23): [True: 2, False: 58]
  |  Branch (5302:35): [True: 10, False: 48]
  ------------------
 5303|     60|                ctxt->atom) < 0) {
 5304|      0|            xmlRegFreeAtom(ctxt->atom);
 5305|      0|            ctxt->atom = NULL;
 5306|      0|	    return(-1);
 5307|      0|        }
 5308|     60|	previous = ctxt->state;
 5309|     60|	ctxt->atom = NULL;
 5310|     60|    }
 5311|    234|    while ((ret != 0) && (ctxt->error == 0)) {
  ------------------
  |  Branch (5311:12): [True: 174, False: 60]
  |  Branch (5311:26): [True: 174, False: 0]
  ------------------
 5312|    174|	ret = xmlFAParsePiece(ctxt);
 5313|    174|	if (ret != 0) {
  ------------------
  |  Branch (5313:6): [True: 114, False: 60]
  ------------------
 5314|    114|	    if (xmlFAGenerateTransitions(ctxt, previous,
  ------------------
  |  Branch (5314:10): [True: 0, False: 114]
  ------------------
 5315|    114|	            (CUR=='|' || CUR==')' || CUR==0) ? to : NULL,
  ------------------
  |  |   58|    114|#define CUR (*(ctxt->cur))
  ------------------
              	            (CUR=='|' || CUR==')' || CUR==0) ? to : NULL,
  ------------------
  |  |   58|     93|#define CUR (*(ctxt->cur))
  ------------------
              	            (CUR=='|' || CUR==')' || CUR==0) ? to : NULL,
  ------------------
  |  |   58|     82|#define CUR (*(ctxt->cur))
  ------------------
  |  Branch (5315:15): [True: 21, False: 93]
  |  Branch (5315:27): [True: 11, False: 82]
  |  Branch (5315:39): [True: 16, False: 66]
  ------------------
 5316|    114|                    ctxt->atom) < 0) {
 5317|      0|                xmlRegFreeAtom(ctxt->atom);
 5318|      0|                ctxt->atom = NULL;
 5319|      0|                return(-1);
 5320|      0|            }
 5321|    114|	    previous = ctxt->state;
 5322|    114|	    ctxt->atom = NULL;
 5323|    114|	}
 5324|    174|    }
 5325|     60|    return(0);
 5326|     60|}
xmlregexp.c:xmlFAParsePiece:
 5266|    234|xmlFAParsePiece(xmlRegParserCtxtPtr ctxt) {
 5267|    234|    int ret;
 5268|       |
 5269|    234|    ctxt->atom = NULL;
 5270|    234|    ret = xmlFAParseAtom(ctxt);
 5271|    234|    if (ret == 0)
  ------------------
  |  Branch (5271:9): [True: 60, False: 174]
  ------------------
 5272|     60|	return(0);
 5273|    174|    if (ctxt->atom == NULL) {
  ------------------
  |  Branch (5273:9): [True: 0, False: 174]
  ------------------
 5274|      0|	ERROR("internal: no atom generated");
  ------------------
  |  |   55|      0|    ctxt->error = XML_REGEXP_COMPILE_ERROR;				\
  |  |   56|      0|    xmlRegexpErrCompile(ctxt, str);
  ------------------
 5275|      0|    }
 5276|    174|    xmlFAParseQuantifier(ctxt);
 5277|    174|    return(1);
 5278|    234|}
xmlregexp.c:xmlFAParseAtom:
 5194|    234|xmlFAParseAtom(xmlRegParserCtxtPtr ctxt) {
 5195|    234|    int codepoint, len;
 5196|       |
 5197|    234|    codepoint = xmlFAIsChar(ctxt);
 5198|    234|    if (codepoint > 0) {
  ------------------
  |  Branch (5198:9): [True: 93, False: 141]
  ------------------
 5199|     93|	ctxt->atom = xmlRegNewAtom(ctxt, XML_REGEXP_CHARVAL);
 5200|     93|	if (ctxt->atom == NULL)
  ------------------
  |  Branch (5200:6): [True: 0, False: 93]
  ------------------
 5201|      0|	    return(-1);
 5202|     93|        len = 4;
 5203|     93|        codepoint = xmlGetUTF8Char(ctxt->cur, &len);
 5204|     93|        if (codepoint < 0) {
  ------------------
  |  Branch (5204:13): [True: 0, False: 93]
  ------------------
 5205|      0|            ERROR("Invalid UTF-8");
  ------------------
  |  |   55|      0|    ctxt->error = XML_REGEXP_COMPILE_ERROR;				\
  |  |   56|      0|    xmlRegexpErrCompile(ctxt, str);
  ------------------
 5206|      0|            return(-1);
 5207|      0|        }
 5208|     93|	ctxt->atom->codepoint = codepoint;
 5209|     93|	NEXTL(len);
  ------------------
  |  |   61|     93|#define NEXTL(l) ctxt->cur += l;
  ------------------
 5210|     93|	return(1);
 5211|    141|    } else if (CUR == '|') {
  ------------------
  |  |   58|    141|#define CUR (*(ctxt->cur))
  ------------------
  |  Branch (5211:16): [True: 21, False: 120]
  ------------------
 5212|     21|	return(0);
 5213|    120|    } else if (CUR == 0) {
  ------------------
  |  |   58|    120|#define CUR (*(ctxt->cur))
  ------------------
  |  Branch (5213:16): [True: 26, False: 94]
  ------------------
 5214|     26|	return(0);
 5215|     94|    } else if (CUR == ')') {
  ------------------
  |  |   58|     94|#define CUR (*(ctxt->cur))
  ------------------
  |  Branch (5215:16): [True: 13, False: 81]
  ------------------
 5216|     13|	return(0);
 5217|     81|    } else if (CUR == '(') {
  ------------------
  |  |   58|     81|#define CUR (*(ctxt->cur))
  ------------------
  |  Branch (5217:16): [True: 13, False: 68]
  ------------------
 5218|     13|	xmlRegStatePtr start, oldend, start0;
 5219|       |
 5220|     13|	NEXT;
  ------------------
  |  |   57|     13|#define NEXT ctxt->cur++
  ------------------
 5221|     13|        if (ctxt->depth >= 50) {
  ------------------
  |  Branch (5221:13): [True: 0, False: 13]
  ------------------
 5222|      0|	    ERROR("xmlFAParseAtom: maximum nesting depth exceeded");
  ------------------
  |  |   55|      0|    ctxt->error = XML_REGEXP_COMPILE_ERROR;				\
  |  |   56|      0|    xmlRegexpErrCompile(ctxt, str);
  ------------------
 5223|      0|            return(-1);
 5224|      0|        }
 5225|       |	/*
 5226|       |	 * this extra Epsilon transition is needed if we count with 0 allowed
 5227|       |	 * unfortunately this can't be known at that point
 5228|       |	 */
 5229|     13|	xmlFAGenerateEpsilonTransition(ctxt, ctxt->state, NULL);
 5230|     13|	start0 = ctxt->state;
 5231|     13|	xmlFAGenerateEpsilonTransition(ctxt, ctxt->state, NULL);
 5232|     13|	start = ctxt->state;
 5233|     13|	oldend = ctxt->end;
 5234|     13|	ctxt->end = NULL;
 5235|     13|	ctxt->atom = NULL;
 5236|     13|        ctxt->depth++;
 5237|     13|	xmlFAParseRegExp(ctxt, 0);
 5238|     13|        ctxt->depth--;
 5239|     13|	if (CUR == ')') {
  ------------------
  |  |   58|     13|#define CUR (*(ctxt->cur))
  ------------------
  |  Branch (5239:6): [True: 13, False: 0]
  ------------------
 5240|     13|	    NEXT;
  ------------------
  |  |   57|     13|#define NEXT ctxt->cur++
  ------------------
 5241|     13|	} else {
 5242|      0|	    ERROR("xmlFAParseAtom: expecting ')'");
  ------------------
  |  |   55|      0|    ctxt->error = XML_REGEXP_COMPILE_ERROR;				\
  |  |   56|      0|    xmlRegexpErrCompile(ctxt, str);
  ------------------
 5243|      0|	}
 5244|     13|	ctxt->atom = xmlRegNewAtom(ctxt, XML_REGEXP_SUBREG);
 5245|     13|	if (ctxt->atom == NULL)
  ------------------
  |  Branch (5245:6): [True: 0, False: 13]
  ------------------
 5246|      0|	    return(-1);
 5247|     13|	ctxt->atom->start = start;
 5248|     13|	ctxt->atom->start0 = start0;
 5249|     13|	ctxt->atom->stop = ctxt->state;
 5250|     13|	ctxt->end = oldend;
 5251|     13|	return(1);
 5252|     68|    } else if ((CUR == '[') || (CUR == '\\') || (CUR == '.')) {
  ------------------
  |  |   58|     68|#define CUR (*(ctxt->cur))
  ------------------
                  } else if ((CUR == '[') || (CUR == '\\') || (CUR == '.')) {
  ------------------
  |  |   58|     44|#define CUR (*(ctxt->cur))
  ------------------
                  } else if ((CUR == '[') || (CUR == '\\') || (CUR == '.')) {
  ------------------
  |  |   58|      1|#define CUR (*(ctxt->cur))
  ------------------
  |  Branch (5252:16): [True: 24, False: 44]
  |  Branch (5252:32): [True: 43, False: 1]
  |  Branch (5252:49): [True: 1, False: 0]
  ------------------
 5253|     68|	xmlFAParseCharClass(ctxt);
 5254|     68|	return(1);
 5255|     68|    }
 5256|      0|    return(0);
 5257|    234|}
xmlregexp.c:xmlFAIsChar:
 4441|    234|xmlFAIsChar(xmlRegParserCtxtPtr ctxt) {
 4442|    234|    int cur;
 4443|    234|    int len;
 4444|       |
 4445|    234|    len = 4;
 4446|    234|    cur = xmlGetUTF8Char(ctxt->cur, &len);
 4447|    234|    if (cur < 0) {
  ------------------
  |  Branch (4447:9): [True: 0, False: 234]
  ------------------
 4448|      0|        ERROR("Invalid UTF-8");
  ------------------
  |  |   55|      0|    ctxt->error = XML_REGEXP_COMPILE_ERROR;				\
  |  |   56|      0|    xmlRegexpErrCompile(ctxt, str);
  ------------------
 4449|      0|        return(0);
 4450|      0|    }
 4451|    234|    if ((cur == '.') || (cur == '\\') || (cur == '?') ||
  ------------------
  |  Branch (4451:9): [True: 1, False: 233]
  |  Branch (4451:25): [True: 43, False: 190]
  |  Branch (4451:42): [True: 0, False: 190]
  ------------------
 4452|    234|	(cur == '*') || (cur == '+') || (cur == '(') ||
  ------------------
  |  Branch (4452:2): [True: 0, False: 190]
  |  Branch (4452:18): [True: 0, False: 190]
  |  Branch (4452:34): [True: 13, False: 177]
  ------------------
 4453|    234|	(cur == ')') || (cur == '|') || (cur == 0x5B) ||
  ------------------
  |  Branch (4453:2): [True: 13, False: 164]
  |  Branch (4453:18): [True: 21, False: 143]
  |  Branch (4453:34): [True: 24, False: 119]
  ------------------
 4454|    234|	(cur == 0x5D) || (cur == 0))
  ------------------
  |  Branch (4454:2): [True: 0, False: 119]
  |  Branch (4454:19): [True: 26, False: 93]
  ------------------
 4455|    141|	return(-1);
 4456|     93|    return(cur);
 4457|    234|}
xmlregexp.c:xmlFAParseCharClass:
 5068|     68|xmlFAParseCharClass(xmlRegParserCtxtPtr ctxt) {
 5069|     68|    if (CUR == '[') {
  ------------------
  |  |   58|     68|#define CUR (*(ctxt->cur))
  ------------------
  |  Branch (5069:9): [True: 24, False: 44]
  ------------------
 5070|     24|	NEXT;
  ------------------
  |  |   57|     24|#define NEXT ctxt->cur++
  ------------------
 5071|     24|	ctxt->atom = xmlRegNewAtom(ctxt, XML_REGEXP_RANGES);
 5072|     24|	if (ctxt->atom == NULL)
  ------------------
  |  Branch (5072:6): [True: 0, False: 24]
  ------------------
 5073|      0|	    return;
 5074|     24|	xmlFAParseCharGroup(ctxt);
 5075|     24|	if (CUR == ']') {
  ------------------
  |  |   58|     24|#define CUR (*(ctxt->cur))
  ------------------
  |  Branch (5075:6): [True: 24, False: 0]
  ------------------
 5076|     24|	    NEXT;
  ------------------
  |  |   57|     24|#define NEXT ctxt->cur++
  ------------------
 5077|     24|	} else {
 5078|      0|	    ERROR("xmlFAParseCharClass: ']' expected");
  ------------------
  |  |   55|      0|    ctxt->error = XML_REGEXP_COMPILE_ERROR;				\
  |  |   56|      0|    xmlRegexpErrCompile(ctxt, str);
  ------------------
 5079|      0|	}
 5080|     44|    } else {
 5081|     44|	xmlFAParseCharClassEsc(ctxt);
 5082|     44|    }
 5083|     68|}
xmlregexp.c:xmlFAParseCharGroup:
 5032|     24|xmlFAParseCharGroup(xmlRegParserCtxtPtr ctxt) {
 5033|     24|    int neg = ctxt->neg;
 5034|       |
 5035|     24|    if (CUR == '^') {
  ------------------
  |  |   58|     24|#define CUR (*(ctxt->cur))
  ------------------
  |  Branch (5035:9): [True: 4, False: 20]
  ------------------
 5036|      4|	NEXT;
  ------------------
  |  |   57|      4|#define NEXT ctxt->cur++
  ------------------
 5037|      4|	ctxt->neg = !ctxt->neg;
 5038|      4|	xmlFAParsePosCharGroup(ctxt);
 5039|      4|	ctxt->neg = neg;
 5040|      4|    }
 5041|     44|    while ((CUR != ']') && (ctxt->error == 0)) {
  ------------------
  |  |   58|     44|#define CUR (*(ctxt->cur))
  ------------------
  |  Branch (5041:12): [True: 20, False: 24]
  |  Branch (5041:28): [True: 20, False: 0]
  ------------------
 5042|     20|	if ((CUR == '-') && (NXT(1) == '[')) {
  ------------------
  |  |   58|     20|#define CUR (*(ctxt->cur))
  ------------------
              	if ((CUR == '-') && (NXT(1) == '[')) {
  ------------------
  |  |   59|      0|#define NXT(index) (ctxt->cur[index])
  ------------------
  |  Branch (5042:6): [True: 0, False: 20]
  |  Branch (5042:22): [True: 0, False: 0]
  ------------------
 5043|      0|	    NEXT;	/* eat the '-' */
  ------------------
  |  |   57|      0|#define NEXT ctxt->cur++
  ------------------
 5044|      0|	    NEXT;	/* eat the '[' */
  ------------------
  |  |   57|      0|#define NEXT ctxt->cur++
  ------------------
 5045|      0|	    ctxt->neg = 2;
 5046|      0|	    xmlFAParseCharGroup(ctxt);
 5047|      0|	    ctxt->neg = neg;
 5048|      0|	    if (CUR == ']') {
  ------------------
  |  |   58|      0|#define CUR (*(ctxt->cur))
  ------------------
  |  Branch (5048:10): [True: 0, False: 0]
  ------------------
 5049|      0|		NEXT;
  ------------------
  |  |   57|      0|#define NEXT ctxt->cur++
  ------------------
 5050|      0|	    } else {
 5051|      0|		ERROR("charClassExpr: ']' expected");
  ------------------
  |  |   55|      0|    ctxt->error = XML_REGEXP_COMPILE_ERROR;				\
  |  |   56|      0|    xmlRegexpErrCompile(ctxt, str);
  ------------------
 5052|      0|	    }
 5053|      0|	    break;
 5054|     20|	} else {
 5055|     20|	    xmlFAParsePosCharGroup(ctxt);
 5056|     20|	}
 5057|     20|    }
 5058|     24|}
xmlregexp.c:xmlFAParsePosCharGroup:
 5011|     24|xmlFAParsePosCharGroup(xmlRegParserCtxtPtr ctxt) {
 5012|     50|    do {
 5013|     50|	if (CUR == '\\') {
  ------------------
  |  |   58|     50|#define CUR (*(ctxt->cur))
  ------------------
  |  Branch (5013:6): [True: 0, False: 50]
  ------------------
 5014|      0|	    xmlFAParseCharClassEsc(ctxt);
 5015|     50|	} else {
 5016|     50|	    xmlFAParseCharRange(ctxt);
 5017|     50|	}
 5018|     50|    } while ((CUR != ']') && (CUR != '-') &&
  ------------------
  |  |   58|     50|#define CUR (*(ctxt->cur))
  ------------------
                  } while ((CUR != ']') && (CUR != '-') &&
  ------------------
  |  |   58|     26|#define CUR (*(ctxt->cur))
  ------------------
  |  Branch (5018:14): [True: 26, False: 24]
  |  Branch (5018:30): [True: 26, False: 0]
  ------------------
 5019|     50|             (CUR != 0) && (ctxt->error == 0));
  ------------------
  |  |   58|     26|#define CUR (*(ctxt->cur))
  ------------------
  |  Branch (5019:14): [True: 26, False: 0]
  |  Branch (5019:28): [True: 26, False: 0]
  ------------------
 5020|     24|}
xmlregexp.c:xmlFAParseCharRange:
 4909|     50|xmlFAParseCharRange(xmlRegParserCtxtPtr ctxt) {
 4910|     50|    int cur, len;
 4911|     50|    int start = -1;
 4912|     50|    int end = -1;
 4913|       |
 4914|     50|    if (CUR == '\0') {
  ------------------
  |  |   58|     50|#define CUR (*(ctxt->cur))
  ------------------
  |  Branch (4914:9): [True: 0, False: 50]
  ------------------
 4915|      0|        ERROR("Expecting ']'");
  ------------------
  |  |   55|      0|    ctxt->error = XML_REGEXP_COMPILE_ERROR;				\
  |  |   56|      0|    xmlRegexpErrCompile(ctxt, str);
  ------------------
 4916|      0|	return;
 4917|      0|    }
 4918|       |
 4919|     50|    cur = CUR;
  ------------------
  |  |   58|     50|#define CUR (*(ctxt->cur))
  ------------------
 4920|     50|    if (cur == '\\') {
  ------------------
  |  Branch (4920:9): [True: 0, False: 50]
  ------------------
 4921|      0|	NEXT;
  ------------------
  |  |   57|      0|#define NEXT ctxt->cur++
  ------------------
 4922|      0|	cur = CUR;
  ------------------
  |  |   58|      0|#define CUR (*(ctxt->cur))
  ------------------
 4923|      0|	switch (cur) {
 4924|      0|	    case 'n': start = 0xA; break;
  ------------------
  |  Branch (4924:6): [True: 0, False: 0]
  ------------------
 4925|      0|	    case 'r': start = 0xD; break;
  ------------------
  |  Branch (4925:6): [True: 0, False: 0]
  ------------------
 4926|      0|	    case 't': start = 0x9; break;
  ------------------
  |  Branch (4926:6): [True: 0, False: 0]
  ------------------
 4927|      0|	    case '\\': case '|': case '.': case '-': case '^': case '?':
  ------------------
  |  Branch (4927:6): [True: 0, False: 0]
  |  Branch (4927:17): [True: 0, False: 0]
  |  Branch (4927:27): [True: 0, False: 0]
  |  Branch (4927:37): [True: 0, False: 0]
  |  Branch (4927:47): [True: 0, False: 0]
  |  Branch (4927:57): [True: 0, False: 0]
  ------------------
 4928|      0|	    case '*': case '+': case '{': case '}': case '(': case ')':
  ------------------
  |  Branch (4928:6): [True: 0, False: 0]
  |  Branch (4928:16): [True: 0, False: 0]
  |  Branch (4928:26): [True: 0, False: 0]
  |  Branch (4928:36): [True: 0, False: 0]
  |  Branch (4928:46): [True: 0, False: 0]
  |  Branch (4928:56): [True: 0, False: 0]
  ------------------
 4929|      0|	    case '[': case ']':
  ------------------
  |  Branch (4929:6): [True: 0, False: 0]
  |  Branch (4929:16): [True: 0, False: 0]
  ------------------
 4930|      0|		start = cur; break;
 4931|      0|	    default:
  ------------------
  |  Branch (4931:6): [True: 0, False: 0]
  ------------------
 4932|      0|		ERROR("Invalid escape value");
  ------------------
  |  |   55|      0|    ctxt->error = XML_REGEXP_COMPILE_ERROR;				\
  |  |   56|      0|    xmlRegexpErrCompile(ctxt, str);
  ------------------
 4933|      0|		return;
 4934|      0|	}
 4935|      0|	end = start;
 4936|      0|        len = 1;
 4937|     50|    } else if ((cur != 0x5B) && (cur != 0x5D)) {
  ------------------
  |  Branch (4937:16): [True: 50, False: 0]
  |  Branch (4937:33): [True: 50, False: 0]
  ------------------
 4938|     50|        len = 4;
 4939|     50|        end = start = xmlGetUTF8Char(ctxt->cur, &len);
 4940|     50|        if (start < 0) {
  ------------------
  |  Branch (4940:13): [True: 0, False: 50]
  ------------------
 4941|      0|            ERROR("Invalid UTF-8");
  ------------------
  |  |   55|      0|    ctxt->error = XML_REGEXP_COMPILE_ERROR;				\
  |  |   56|      0|    xmlRegexpErrCompile(ctxt, str);
  ------------------
 4942|      0|            return;
 4943|      0|        }
 4944|     50|    } else {
 4945|      0|	ERROR("Expecting a char range");
  ------------------
  |  |   55|      0|    ctxt->error = XML_REGEXP_COMPILE_ERROR;				\
  |  |   56|      0|    xmlRegexpErrCompile(ctxt, str);
  ------------------
 4946|      0|	return;
 4947|      0|    }
 4948|       |    /*
 4949|       |     * Since we are "inside" a range, we can assume ctxt->cur is past
 4950|       |     * the start of ctxt->string, and PREV should be safe
 4951|       |     */
 4952|     50|    if ((start == '-') && (NXT(1) != ']') && (PREV != '[') && (PREV != '^')) {
  ------------------
  |  |   59|      0|#define NXT(index) (ctxt->cur[index])
  ------------------
                  if ((start == '-') && (NXT(1) != ']') && (PREV != '[') && (PREV != '^')) {
  ------------------
  |  |   67|      0|#define PREV (ctxt->cur[-1])
  ------------------
                  if ((start == '-') && (NXT(1) != ']') && (PREV != '[') && (PREV != '^')) {
  ------------------
  |  |   67|      0|#define PREV (ctxt->cur[-1])
  ------------------
  |  Branch (4952:9): [True: 0, False: 50]
  |  Branch (4952:27): [True: 0, False: 0]
  |  Branch (4952:46): [True: 0, False: 0]
  |  Branch (4952:63): [True: 0, False: 0]
  ------------------
 4953|      0|	NEXTL(len);
  ------------------
  |  |   61|      0|#define NEXTL(l) ctxt->cur += l;
  ------------------
 4954|      0|	return;
 4955|      0|    }
 4956|     50|    NEXTL(len);
  ------------------
  |  |   61|     50|#define NEXTL(l) ctxt->cur += l;
  ------------------
 4957|     50|    cur = CUR;
  ------------------
  |  |   58|     50|#define CUR (*(ctxt->cur))
  ------------------
 4958|     50|    if ((cur != '-') || (NXT(1) == '[') || (NXT(1) == ']')) {
  ------------------
  |  |   59|     11|#define NXT(index) (ctxt->cur[index])
  ------------------
                  if ((cur != '-') || (NXT(1) == '[') || (NXT(1) == ']')) {
  ------------------
  |  |   59|     11|#define NXT(index) (ctxt->cur[index])
  ------------------
  |  Branch (4958:9): [True: 39, False: 11]
  |  Branch (4958:25): [True: 0, False: 11]
  |  Branch (4958:44): [True: 0, False: 11]
  ------------------
 4959|     39|        xmlRegAtomAddRange(ctxt, ctxt->atom, ctxt->neg,
 4960|     39|		              XML_REGEXP_CHARVAL, start, end, NULL);
 4961|     39|	return;
 4962|     39|    }
 4963|     11|    NEXT;
  ------------------
  |  |   57|     11|#define NEXT ctxt->cur++
  ------------------
 4964|     11|    cur = CUR;
  ------------------
  |  |   58|     11|#define CUR (*(ctxt->cur))
  ------------------
 4965|     11|    if (cur == '\\') {
  ------------------
  |  Branch (4965:9): [True: 0, False: 11]
  ------------------
 4966|      0|	NEXT;
  ------------------
  |  |   57|      0|#define NEXT ctxt->cur++
  ------------------
 4967|      0|	cur = CUR;
  ------------------
  |  |   58|      0|#define CUR (*(ctxt->cur))
  ------------------
 4968|      0|	switch (cur) {
 4969|      0|	    case 'n': end = 0xA; break;
  ------------------
  |  Branch (4969:6): [True: 0, False: 0]
  ------------------
 4970|      0|	    case 'r': end = 0xD; break;
  ------------------
  |  Branch (4970:6): [True: 0, False: 0]
  ------------------
 4971|      0|	    case 't': end = 0x9; break;
  ------------------
  |  Branch (4971:6): [True: 0, False: 0]
  ------------------
 4972|      0|	    case '\\': case '|': case '.': case '-': case '^': case '?':
  ------------------
  |  Branch (4972:6): [True: 0, False: 0]
  |  Branch (4972:17): [True: 0, False: 0]
  |  Branch (4972:27): [True: 0, False: 0]
  |  Branch (4972:37): [True: 0, False: 0]
  |  Branch (4972:47): [True: 0, False: 0]
  |  Branch (4972:57): [True: 0, False: 0]
  ------------------
 4973|      0|	    case '*': case '+': case '{': case '}': case '(': case ')':
  ------------------
  |  Branch (4973:6): [True: 0, False: 0]
  |  Branch (4973:16): [True: 0, False: 0]
  |  Branch (4973:26): [True: 0, False: 0]
  |  Branch (4973:36): [True: 0, False: 0]
  |  Branch (4973:46): [True: 0, False: 0]
  |  Branch (4973:56): [True: 0, False: 0]
  ------------------
 4974|      0|	    case '[': case ']':
  ------------------
  |  Branch (4974:6): [True: 0, False: 0]
  |  Branch (4974:16): [True: 0, False: 0]
  ------------------
 4975|      0|		end = cur; break;
 4976|      0|	    default:
  ------------------
  |  Branch (4976:6): [True: 0, False: 0]
  ------------------
 4977|      0|		ERROR("Invalid escape value");
  ------------------
  |  |   55|      0|    ctxt->error = XML_REGEXP_COMPILE_ERROR;				\
  |  |   56|      0|    xmlRegexpErrCompile(ctxt, str);
  ------------------
 4978|      0|		return;
 4979|      0|	}
 4980|      0|        len = 1;
 4981|     11|    } else if ((cur != '\0') && (cur != 0x5B) && (cur != 0x5D)) {
  ------------------
  |  Branch (4981:16): [True: 11, False: 0]
  |  Branch (4981:33): [True: 11, False: 0]
  |  Branch (4981:50): [True: 11, False: 0]
  ------------------
 4982|     11|        len = 4;
 4983|     11|        end = xmlGetUTF8Char(ctxt->cur, &len);
 4984|     11|        if (end < 0) {
  ------------------
  |  Branch (4984:13): [True: 0, False: 11]
  ------------------
 4985|      0|            ERROR("Invalid UTF-8");
  ------------------
  |  |   55|      0|    ctxt->error = XML_REGEXP_COMPILE_ERROR;				\
  |  |   56|      0|    xmlRegexpErrCompile(ctxt, str);
  ------------------
 4986|      0|            return;
 4987|      0|        }
 4988|     11|    } else {
 4989|      0|	ERROR("Expecting the end of a char range");
  ------------------
  |  |   55|      0|    ctxt->error = XML_REGEXP_COMPILE_ERROR;				\
  |  |   56|      0|    xmlRegexpErrCompile(ctxt, str);
  ------------------
 4990|      0|	return;
 4991|      0|    }
 4992|       |
 4993|       |    /* TODO check that the values are acceptable character ranges for XML */
 4994|     11|    if (end < start) {
  ------------------
  |  Branch (4994:9): [True: 0, False: 11]
  ------------------
 4995|      0|	ERROR("End of range is before start of range");
  ------------------
  |  |   55|      0|    ctxt->error = XML_REGEXP_COMPILE_ERROR;				\
  |  |   56|      0|    xmlRegexpErrCompile(ctxt, str);
  ------------------
 4996|     11|    } else {
 4997|     11|        NEXTL(len);
  ------------------
  |  |   61|     11|#define NEXTL(l) ctxt->cur += l;
  ------------------
 4998|     11|        xmlRegAtomAddRange(ctxt, ctxt->atom, ctxt->neg,
 4999|     11|		           XML_REGEXP_CHARVAL, start, end, NULL);
 5000|     11|    }
 5001|     11|    return;
 5002|     11|}
xmlregexp.c:xmlRegAtomAddRange:
 1186|     50|		   xmlChar *blockName) {
 1187|     50|    xmlRegRangePtr range;
 1188|       |
 1189|     50|    if (atom == NULL) {
  ------------------
  |  Branch (1189:9): [True: 0, False: 50]
  ------------------
 1190|      0|	ERROR("add range: atom is NULL");
  ------------------
  |  |   55|      0|    ctxt->error = XML_REGEXP_COMPILE_ERROR;				\
  |  |   56|      0|    xmlRegexpErrCompile(ctxt, str);
  ------------------
 1191|      0|	return(NULL);
 1192|      0|    }
 1193|     50|    if (atom->type != XML_REGEXP_RANGES) {
  ------------------
  |  Branch (1193:9): [True: 0, False: 50]
  ------------------
 1194|      0|	ERROR("add range: atom is not ranges");
  ------------------
  |  |   55|      0|    ctxt->error = XML_REGEXP_COMPILE_ERROR;				\
  |  |   56|      0|    xmlRegexpErrCompile(ctxt, str);
  ------------------
 1195|      0|	return(NULL);
 1196|      0|    }
 1197|     50|    if (atom->maxRanges == 0) {
  ------------------
  |  Branch (1197:9): [True: 24, False: 26]
  ------------------
 1198|     24|	atom->maxRanges = 4;
 1199|     24|	atom->ranges = (xmlRegRangePtr *) xmlMalloc(atom->maxRanges *
 1200|     24|		                             sizeof(xmlRegRangePtr));
 1201|     24|	if (atom->ranges == NULL) {
  ------------------
  |  Branch (1201:6): [True: 0, False: 24]
  ------------------
 1202|      0|	    xmlRegexpErrMemory(ctxt, "adding ranges");
 1203|      0|	    atom->maxRanges = 0;
 1204|      0|	    return(NULL);
 1205|      0|	}
 1206|     26|    } else if (atom->nbRanges >= atom->maxRanges) {
  ------------------
  |  Branch (1206:16): [True: 2, False: 24]
  ------------------
 1207|      2|	xmlRegRangePtr *tmp;
 1208|      2|	atom->maxRanges *= 2;
 1209|      2|	tmp = (xmlRegRangePtr *) xmlRealloc(atom->ranges, atom->maxRanges *
 1210|      2|		                             sizeof(xmlRegRangePtr));
 1211|      2|	if (tmp == NULL) {
  ------------------
  |  Branch (1211:6): [True: 0, False: 2]
  ------------------
 1212|      0|	    xmlRegexpErrMemory(ctxt, "adding ranges");
 1213|      0|	    atom->maxRanges /= 2;
 1214|      0|	    return(NULL);
 1215|      0|	}
 1216|      2|	atom->ranges = tmp;
 1217|      2|    }
 1218|     50|    range = xmlRegNewRange(ctxt, neg, type, start, end);
 1219|     50|    if (range == NULL)
  ------------------
  |  Branch (1219:9): [True: 0, False: 50]
  ------------------
 1220|      0|	return(NULL);
 1221|     50|    range->blockName = blockName;
 1222|     50|    atom->ranges[atom->nbRanges++] = range;
 1223|       |
 1224|     50|    return(range);
 1225|     50|}
xmlregexp.c:xmlRegNewRange:
  725|     50|	       int neg, xmlRegAtomType type, int start, int end) {
  726|     50|    xmlRegRangePtr ret;
  727|       |
  728|     50|    ret = (xmlRegRangePtr) xmlMalloc(sizeof(xmlRegRange));
  729|     50|    if (ret == NULL) {
  ------------------
  |  Branch (729:9): [True: 0, False: 50]
  ------------------
  730|      0|	xmlRegexpErrMemory(ctxt, "allocating range");
  731|      0|	return(NULL);
  732|      0|    }
  733|     50|    ret->neg = neg;
  734|     50|    ret->type = type;
  735|     50|    ret->start = start;
  736|     50|    ret->end = end;
  737|     50|    return(ret);
  738|     50|}
xmlregexp.c:xmlFAParseCharClassEsc:
 4739|     44|xmlFAParseCharClassEsc(xmlRegParserCtxtPtr ctxt) {
 4740|     44|    int cur;
 4741|       |
 4742|     44|    if (CUR == '.') {
  ------------------
  |  |   58|     44|#define CUR (*(ctxt->cur))
  ------------------
  |  Branch (4742:9): [True: 1, False: 43]
  ------------------
 4743|      1|	if (ctxt->atom == NULL) {
  ------------------
  |  Branch (4743:6): [True: 1, False: 0]
  ------------------
 4744|      1|	    ctxt->atom = xmlRegNewAtom(ctxt, XML_REGEXP_ANYCHAR);
 4745|      1|	} else if (ctxt->atom->type == XML_REGEXP_RANGES) {
  ------------------
  |  Branch (4745:13): [True: 0, False: 0]
  ------------------
 4746|      0|	    xmlRegAtomAddRange(ctxt, ctxt->atom, ctxt->neg,
 4747|      0|			       XML_REGEXP_ANYCHAR, 0, 0, NULL);
 4748|      0|	}
 4749|      1|	NEXT;
  ------------------
  |  |   57|      1|#define NEXT ctxt->cur++
  ------------------
 4750|      1|	return;
 4751|      1|    }
 4752|     43|    if (CUR != '\\') {
  ------------------
  |  |   58|     43|#define CUR (*(ctxt->cur))
  ------------------
  |  Branch (4752:9): [True: 0, False: 43]
  ------------------
 4753|      0|	ERROR("Escaped sequence: expecting \\");
  ------------------
  |  |   55|      0|    ctxt->error = XML_REGEXP_COMPILE_ERROR;				\
  |  |   56|      0|    xmlRegexpErrCompile(ctxt, str);
  ------------------
 4754|      0|	return;
 4755|      0|    }
 4756|     43|    NEXT;
  ------------------
  |  |   57|     43|#define NEXT ctxt->cur++
  ------------------
 4757|     43|    cur = CUR;
  ------------------
  |  |   58|     43|#define CUR (*(ctxt->cur))
  ------------------
 4758|     43|    if (cur == 'p') {
  ------------------
  |  Branch (4758:9): [True: 0, False: 43]
  ------------------
 4759|      0|	NEXT;
  ------------------
  |  |   57|      0|#define NEXT ctxt->cur++
  ------------------
 4760|      0|	if (CUR != '{') {
  ------------------
  |  |   58|      0|#define CUR (*(ctxt->cur))
  ------------------
  |  Branch (4760:6): [True: 0, False: 0]
  ------------------
 4761|      0|	    ERROR("Expecting '{'");
  ------------------
  |  |   55|      0|    ctxt->error = XML_REGEXP_COMPILE_ERROR;				\
  |  |   56|      0|    xmlRegexpErrCompile(ctxt, str);
  ------------------
 4762|      0|	    return;
 4763|      0|	}
 4764|      0|	NEXT;
  ------------------
  |  |   57|      0|#define NEXT ctxt->cur++
  ------------------
 4765|      0|	xmlFAParseCharProp(ctxt);
 4766|      0|	if (CUR != '}') {
  ------------------
  |  |   58|      0|#define CUR (*(ctxt->cur))
  ------------------
  |  Branch (4766:6): [True: 0, False: 0]
  ------------------
 4767|      0|	    ERROR("Expecting '}'");
  ------------------
  |  |   55|      0|    ctxt->error = XML_REGEXP_COMPILE_ERROR;				\
  |  |   56|      0|    xmlRegexpErrCompile(ctxt, str);
  ------------------
 4768|      0|	    return;
 4769|      0|	}
 4770|      0|	NEXT;
  ------------------
  |  |   57|      0|#define NEXT ctxt->cur++
  ------------------
 4771|     43|    } else if (cur == 'P') {
  ------------------
  |  Branch (4771:16): [True: 0, False: 43]
  ------------------
 4772|      0|	NEXT;
  ------------------
  |  |   57|      0|#define NEXT ctxt->cur++
  ------------------
 4773|      0|	if (CUR != '{') {
  ------------------
  |  |   58|      0|#define CUR (*(ctxt->cur))
  ------------------
  |  Branch (4773:6): [True: 0, False: 0]
  ------------------
 4774|      0|	    ERROR("Expecting '{'");
  ------------------
  |  |   55|      0|    ctxt->error = XML_REGEXP_COMPILE_ERROR;				\
  |  |   56|      0|    xmlRegexpErrCompile(ctxt, str);
  ------------------
 4775|      0|	    return;
 4776|      0|	}
 4777|      0|	NEXT;
  ------------------
  |  |   57|      0|#define NEXT ctxt->cur++
  ------------------
 4778|      0|	xmlFAParseCharProp(ctxt);
 4779|      0|        if (ctxt->atom != NULL)
  ------------------
  |  Branch (4779:13): [True: 0, False: 0]
  ------------------
 4780|      0|	    ctxt->atom->neg = 1;
 4781|      0|	if (CUR != '}') {
  ------------------
  |  |   58|      0|#define CUR (*(ctxt->cur))
  ------------------
  |  Branch (4781:6): [True: 0, False: 0]
  ------------------
 4782|      0|	    ERROR("Expecting '}'");
  ------------------
  |  |   55|      0|    ctxt->error = XML_REGEXP_COMPILE_ERROR;				\
  |  |   56|      0|    xmlRegexpErrCompile(ctxt, str);
  ------------------
 4783|      0|	    return;
 4784|      0|	}
 4785|      0|	NEXT;
  ------------------
  |  |   57|      0|#define NEXT ctxt->cur++
  ------------------
 4786|     43|    } else if ((cur == 'n') || (cur == 'r') || (cur == 't') || (cur == '\\') ||
  ------------------
  |  Branch (4786:16): [True: 0, False: 43]
  |  Branch (4786:32): [True: 0, False: 43]
  |  Branch (4786:48): [True: 0, False: 43]
  |  Branch (4786:64): [True: 0, False: 43]
  ------------------
 4787|     43|	(cur == '|') || (cur == '.') || (cur == '?') || (cur == '*') ||
  ------------------
  |  Branch (4787:2): [True: 0, False: 43]
  |  Branch (4787:18): [True: 1, False: 42]
  |  Branch (4787:34): [True: 0, False: 42]
  |  Branch (4787:50): [True: 0, False: 42]
  ------------------
 4788|     43|	(cur == '+') || (cur == '(') || (cur == ')') || (cur == '{') ||
  ------------------
  |  Branch (4788:2): [True: 0, False: 42]
  |  Branch (4788:18): [True: 1, False: 41]
  |  Branch (4788:34): [True: 1, False: 40]
  |  Branch (4788:50): [True: 0, False: 40]
  ------------------
 4789|     43|	(cur == '}') || (cur == 0x2D) || (cur == 0x5B) || (cur == 0x5D) ||
  ------------------
  |  Branch (4789:2): [True: 0, False: 40]
  |  Branch (4789:18): [True: 3, False: 37]
  |  Branch (4789:35): [True: 0, False: 37]
  |  Branch (4789:52): [True: 0, False: 37]
  ------------------
 4790|     43|	(cur == 0x5E) ||
  ------------------
  |  Branch (4790:2): [True: 0, False: 37]
  ------------------
 4791|       |
 4792|       |	/* Non-standard escape sequences:
 4793|       |	 *                  Java 1.8|.NET Core 3.1|MSXML 6 */
 4794|     43|	(cur == '!') ||     /*   +  |     +       |    +   */
  ------------------
  |  Branch (4794:2): [True: 0, False: 37]
  ------------------
 4795|     43|	(cur == '"') ||     /*   +  |     +       |    +   */
  ------------------
  |  Branch (4795:2): [True: 0, False: 37]
  ------------------
 4796|     43|	(cur == '#') ||     /*   +  |     +       |    +   */
  ------------------
  |  Branch (4796:2): [True: 0, False: 37]
  ------------------
 4797|     43|	(cur == '$') ||     /*   +  |     +       |    +   */
  ------------------
  |  Branch (4797:2): [True: 0, False: 37]
  ------------------
 4798|     43|	(cur == '%') ||     /*   +  |     +       |    +   */
  ------------------
  |  Branch (4798:2): [True: 0, False: 37]
  ------------------
 4799|     43|	(cur == ',') ||     /*   +  |     +       |    +   */
  ------------------
  |  Branch (4799:2): [True: 0, False: 37]
  ------------------
 4800|     43|	(cur == '/') ||     /*   +  |     +       |    +   */
  ------------------
  |  Branch (4800:2): [True: 0, False: 37]
  ------------------
 4801|     43|	(cur == ':') ||     /*   +  |     +       |    +   */
  ------------------
  |  Branch (4801:2): [True: 0, False: 37]
  ------------------
 4802|     43|	(cur == ';') ||     /*   +  |     +       |    +   */
  ------------------
  |  Branch (4802:2): [True: 0, False: 37]
  ------------------
 4803|     43|	(cur == '=') ||     /*   +  |     +       |    +   */
  ------------------
  |  Branch (4803:2): [True: 0, False: 37]
  ------------------
 4804|     43|	(cur == '>') ||     /*      |     +       |    +   */
  ------------------
  |  Branch (4804:2): [True: 0, False: 37]
  ------------------
 4805|     43|	(cur == '@') ||     /*   +  |     +       |    +   */
  ------------------
  |  Branch (4805:2): [True: 0, False: 37]
  ------------------
 4806|     43|	(cur == '`') ||     /*   +  |     +       |    +   */
  ------------------
  |  Branch (4806:2): [True: 0, False: 37]
  ------------------
 4807|     43|	(cur == '~') ||     /*   +  |     +       |    +   */
  ------------------
  |  Branch (4807:2): [True: 0, False: 37]
  ------------------
 4808|     43|	(cur == 'u')) {     /*      |     +       |    +   */
  ------------------
  |  Branch (4808:2): [True: 0, False: 37]
  ------------------
 4809|      6|	if (ctxt->atom == NULL) {
  ------------------
  |  Branch (4809:6): [True: 6, False: 0]
  ------------------
 4810|      6|	    ctxt->atom = xmlRegNewAtom(ctxt, XML_REGEXP_CHARVAL);
 4811|      6|	    if (ctxt->atom != NULL) {
  ------------------
  |  Branch (4811:10): [True: 6, False: 0]
  ------------------
 4812|      6|	        switch (cur) {
 4813|      0|		    case 'n':
  ------------------
  |  Branch (4813:7): [True: 0, False: 6]
  ------------------
 4814|      0|		        ctxt->atom->codepoint = '\n';
 4815|      0|			break;
 4816|      0|		    case 'r':
  ------------------
  |  Branch (4816:7): [True: 0, False: 6]
  ------------------
 4817|      0|		        ctxt->atom->codepoint = '\r';
 4818|      0|			break;
 4819|      0|		    case 't':
  ------------------
  |  Branch (4819:7): [True: 0, False: 6]
  ------------------
 4820|      0|		        ctxt->atom->codepoint = '\t';
 4821|      0|			break;
 4822|      0|		    case 'u':
  ------------------
  |  Branch (4822:7): [True: 0, False: 6]
  ------------------
 4823|      0|			cur = parse_escaped_codepoint(ctxt);
 4824|      0|			if (cur < 0) {
  ------------------
  |  Branch (4824:8): [True: 0, False: 0]
  ------------------
 4825|      0|			    return;
 4826|      0|			}
 4827|      0|			ctxt->atom->codepoint = cur;
 4828|      0|			break;
 4829|      6|		    default:
  ------------------
  |  Branch (4829:7): [True: 6, False: 0]
  ------------------
 4830|      6|			ctxt->atom->codepoint = cur;
 4831|      6|		}
 4832|      6|	    }
 4833|      6|	} else if (ctxt->atom->type == XML_REGEXP_RANGES) {
  ------------------
  |  Branch (4833:13): [True: 0, False: 0]
  ------------------
 4834|      0|            switch (cur) {
  ------------------
  |  Branch (4834:21): [True: 0, False: 0]
  ------------------
 4835|      0|                case 'n':
  ------------------
  |  Branch (4835:17): [True: 0, False: 0]
  ------------------
 4836|      0|                    cur = '\n';
 4837|      0|                    break;
 4838|      0|                case 'r':
  ------------------
  |  Branch (4838:17): [True: 0, False: 0]
  ------------------
 4839|      0|                    cur = '\r';
 4840|      0|                    break;
 4841|      0|                case 't':
  ------------------
  |  Branch (4841:17): [True: 0, False: 0]
  ------------------
 4842|      0|                    cur = '\t';
 4843|      0|                    break;
 4844|      0|            }
 4845|      0|	    xmlRegAtomAddRange(ctxt, ctxt->atom, ctxt->neg,
 4846|      0|			       XML_REGEXP_CHARVAL, cur, cur, NULL);
 4847|      0|	}
 4848|      6|	NEXT;
  ------------------
  |  |   57|      6|#define NEXT ctxt->cur++
  ------------------
 4849|     37|    } else if ((cur == 's') || (cur == 'S') || (cur == 'i') || (cur == 'I') ||
  ------------------
  |  Branch (4849:16): [True: 2, False: 35]
  |  Branch (4849:32): [True: 0, False: 35]
  |  Branch (4849:48): [True: 0, False: 35]
  |  Branch (4849:64): [True: 0, False: 35]
  ------------------
 4850|     37|	(cur == 'c') || (cur == 'C') || (cur == 'd') || (cur == 'D') ||
  ------------------
  |  Branch (4850:2): [True: 0, False: 35]
  |  Branch (4850:18): [True: 0, False: 35]
  |  Branch (4850:34): [True: 35, False: 0]
  |  Branch (4850:50): [True: 0, False: 0]
  ------------------
 4851|     37|	(cur == 'w') || (cur == 'W')) {
  ------------------
  |  Branch (4851:2): [True: 0, False: 0]
  |  Branch (4851:18): [True: 0, False: 0]
  ------------------
 4852|     37|	xmlRegAtomType type = XML_REGEXP_ANYSPACE;
 4853|       |
 4854|     37|	switch (cur) {
  ------------------
  |  Branch (4854:10): [True: 0, False: 37]
  ------------------
 4855|      2|	    case 's':
  ------------------
  |  Branch (4855:6): [True: 2, False: 35]
  ------------------
 4856|      2|		type = XML_REGEXP_ANYSPACE;
 4857|      2|		break;
 4858|      0|	    case 'S':
  ------------------
  |  Branch (4858:6): [True: 0, False: 37]
  ------------------
 4859|      0|		type = XML_REGEXP_NOTSPACE;
 4860|      0|		break;
 4861|      0|	    case 'i':
  ------------------
  |  Branch (4861:6): [True: 0, False: 37]
  ------------------
 4862|      0|		type = XML_REGEXP_INITNAME;
 4863|      0|		break;
 4864|      0|	    case 'I':
  ------------------
  |  Branch (4864:6): [True: 0, False: 37]
  ------------------
 4865|      0|		type = XML_REGEXP_NOTINITNAME;
 4866|      0|		break;
 4867|      0|	    case 'c':
  ------------------
  |  Branch (4867:6): [True: 0, False: 37]
  ------------------
 4868|      0|		type = XML_REGEXP_NAMECHAR;
 4869|      0|		break;
 4870|      0|	    case 'C':
  ------------------
  |  Branch (4870:6): [True: 0, False: 37]
  ------------------
 4871|      0|		type = XML_REGEXP_NOTNAMECHAR;
 4872|      0|		break;
 4873|     35|	    case 'd':
  ------------------
  |  Branch (4873:6): [True: 35, False: 2]
  ------------------
 4874|     35|		type = XML_REGEXP_DECIMAL;
 4875|     35|		break;
 4876|      0|	    case 'D':
  ------------------
  |  Branch (4876:6): [True: 0, False: 37]
  ------------------
 4877|      0|		type = XML_REGEXP_NOTDECIMAL;
 4878|      0|		break;
 4879|      0|	    case 'w':
  ------------------
  |  Branch (4879:6): [True: 0, False: 37]
  ------------------
 4880|      0|		type = XML_REGEXP_REALCHAR;
 4881|      0|		break;
 4882|      0|	    case 'W':
  ------------------
  |  Branch (4882:6): [True: 0, False: 37]
  ------------------
 4883|      0|		type = XML_REGEXP_NOTREALCHAR;
 4884|      0|		break;
 4885|     37|	}
 4886|     37|	NEXT;
  ------------------
  |  |   57|     37|#define NEXT ctxt->cur++
  ------------------
 4887|     37|	if (ctxt->atom == NULL) {
  ------------------
  |  Branch (4887:6): [True: 37, False: 0]
  ------------------
 4888|     37|	    ctxt->atom = xmlRegNewAtom(ctxt, type);
 4889|     37|	} else if (ctxt->atom->type == XML_REGEXP_RANGES) {
  ------------------
  |  Branch (4889:13): [True: 0, False: 0]
  ------------------
 4890|      0|	    xmlRegAtomAddRange(ctxt, ctxt->atom, ctxt->neg,
 4891|      0|			       type, 0, 0, NULL);
 4892|      0|	}
 4893|     37|    } else {
 4894|      0|	ERROR("Wrong escape sequence, misuse of character '\\'");
  ------------------
  |  |   55|      0|    ctxt->error = XML_REGEXP_COMPILE_ERROR;				\
  |  |   56|      0|    xmlRegexpErrCompile(ctxt, str);
  ------------------
 4895|      0|    }
 4896|     43|}
xmlregexp.c:xmlFAParseQuantifier:
 5131|    174|xmlFAParseQuantifier(xmlRegParserCtxtPtr ctxt) {
 5132|    174|    int cur;
 5133|       |
 5134|    174|    cur = CUR;
  ------------------
  |  |   58|    174|#define CUR (*(ctxt->cur))
  ------------------
 5135|    174|    if ((cur == '?') || (cur == '*') || (cur == '+')) {
  ------------------
  |  Branch (5135:9): [True: 2, False: 172]
  |  Branch (5135:25): [True: 7, False: 165]
  |  Branch (5135:41): [True: 5, False: 160]
  ------------------
 5136|     14|	if (ctxt->atom != NULL) {
  ------------------
  |  Branch (5136:6): [True: 14, False: 0]
  ------------------
 5137|     14|	    if (cur == '?')
  ------------------
  |  Branch (5137:10): [True: 2, False: 12]
  ------------------
 5138|      2|		ctxt->atom->quant = XML_REGEXP_QUANT_OPT;
 5139|     12|	    else if (cur == '*')
  ------------------
  |  Branch (5139:15): [True: 7, False: 5]
  ------------------
 5140|      7|		ctxt->atom->quant = XML_REGEXP_QUANT_MULT;
 5141|      5|	    else if (cur == '+')
  ------------------
  |  Branch (5141:15): [True: 5, False: 0]
  ------------------
 5142|      5|		ctxt->atom->quant = XML_REGEXP_QUANT_PLUS;
 5143|     14|	}
 5144|     14|	NEXT;
  ------------------
  |  |   57|     14|#define NEXT ctxt->cur++
  ------------------
 5145|     14|	return(1);
 5146|     14|    }
 5147|    160|    if (cur == '{') {
  ------------------
  |  Branch (5147:9): [True: 15, False: 145]
  ------------------
 5148|     15|	int min = 0, max = 0;
 5149|       |
 5150|     15|	NEXT;
  ------------------
  |  |   57|     15|#define NEXT ctxt->cur++
  ------------------
 5151|     15|	cur = xmlFAParseQuantExact(ctxt);
 5152|     15|	if (cur >= 0)
  ------------------
  |  Branch (5152:6): [True: 15, False: 0]
  ------------------
 5153|     15|	    min = cur;
 5154|      0|        else {
 5155|      0|            ERROR("Improper quantifier");
  ------------------
  |  |   55|      0|    ctxt->error = XML_REGEXP_COMPILE_ERROR;				\
  |  |   56|      0|    xmlRegexpErrCompile(ctxt, str);
  ------------------
 5156|      0|        }
 5157|     15|	if (CUR == ',') {
  ------------------
  |  |   58|     15|#define CUR (*(ctxt->cur))
  ------------------
  |  Branch (5157:6): [True: 0, False: 15]
  ------------------
 5158|      0|	    NEXT;
  ------------------
  |  |   57|      0|#define NEXT ctxt->cur++
  ------------------
 5159|      0|	    if (CUR == '}')
  ------------------
  |  |   58|      0|#define CUR (*(ctxt->cur))
  ------------------
  |  Branch (5159:10): [True: 0, False: 0]
  ------------------
 5160|      0|	        max = INT_MAX;
 5161|      0|	    else {
 5162|      0|	        cur = xmlFAParseQuantExact(ctxt);
 5163|      0|	        if (cur >= 0)
  ------------------
  |  Branch (5163:14): [True: 0, False: 0]
  ------------------
 5164|      0|		    max = cur;
 5165|      0|		else {
 5166|      0|		    ERROR("Improper quantifier");
  ------------------
  |  |   55|      0|    ctxt->error = XML_REGEXP_COMPILE_ERROR;				\
  |  |   56|      0|    xmlRegexpErrCompile(ctxt, str);
  ------------------
 5167|      0|		}
 5168|      0|	    }
 5169|      0|	}
 5170|     15|	if (CUR == '}') {
  ------------------
  |  |   58|     15|#define CUR (*(ctxt->cur))
  ------------------
  |  Branch (5170:6): [True: 15, False: 0]
  ------------------
 5171|     15|	    NEXT;
  ------------------
  |  |   57|     15|#define NEXT ctxt->cur++
  ------------------
 5172|     15|	} else {
 5173|      0|	    ERROR("Unterminated quantifier");
  ------------------
  |  |   55|      0|    ctxt->error = XML_REGEXP_COMPILE_ERROR;				\
  |  |   56|      0|    xmlRegexpErrCompile(ctxt, str);
  ------------------
 5174|      0|	}
 5175|     15|	if (max == 0)
  ------------------
  |  Branch (5175:6): [True: 15, False: 0]
  ------------------
 5176|     15|	    max = min;
 5177|     15|	if (ctxt->atom != NULL) {
  ------------------
  |  Branch (5177:6): [True: 15, False: 0]
  ------------------
 5178|     15|	    ctxt->atom->quant = XML_REGEXP_QUANT_RANGE;
 5179|     15|	    ctxt->atom->min = min;
 5180|     15|	    ctxt->atom->max = max;
 5181|     15|	}
 5182|     15|	return(1);
 5183|     15|    }
 5184|    145|    return(0);
 5185|    160|}
xmlregexp.c:xmlFAParseQuantExact:
 5094|     15|xmlFAParseQuantExact(xmlRegParserCtxtPtr ctxt) {
 5095|     15|    int ret = 0;
 5096|     15|    int ok = 0;
 5097|     15|    int overflow = 0;
 5098|       |
 5099|     37|    while ((CUR >= '0') && (CUR <= '9')) {
  ------------------
  |  |   58|     37|#define CUR (*(ctxt->cur))
  ------------------
                  while ((CUR >= '0') && (CUR <= '9')) {
  ------------------
  |  |   58|     37|#define CUR (*(ctxt->cur))
  ------------------
  |  Branch (5099:12): [True: 37, False: 0]
  |  Branch (5099:28): [True: 22, False: 15]
  ------------------
 5100|     22|        if (ret > INT_MAX / 10) {
  ------------------
  |  Branch (5100:13): [True: 0, False: 22]
  ------------------
 5101|      0|            overflow = 1;
 5102|     22|        } else {
 5103|     22|            int digit = CUR - '0';
  ------------------
  |  |   58|     22|#define CUR (*(ctxt->cur))
  ------------------
 5104|       |
 5105|     22|            ret *= 10;
 5106|     22|            if (ret > INT_MAX - digit)
  ------------------
  |  Branch (5106:17): [True: 0, False: 22]
  ------------------
 5107|      0|                overflow = 1;
 5108|     22|            else
 5109|     22|                ret += digit;
 5110|     22|        }
 5111|     22|	ok = 1;
 5112|     22|	NEXT;
  ------------------
  |  |   57|     22|#define NEXT ctxt->cur++
  ------------------
 5113|     22|    }
 5114|     15|    if ((ok != 1) || (overflow == 1)) {
  ------------------
  |  Branch (5114:9): [True: 0, False: 15]
  |  Branch (5114:22): [True: 0, False: 15]
  ------------------
 5115|      0|	return(-1);
 5116|      0|    }
 5117|     15|    return(ret);
 5118|     15|}
xmlregexp.c:xmlFAEliminateEpsilonTransitions:
 1877|    218|xmlFAEliminateEpsilonTransitions(xmlRegParserCtxtPtr ctxt) {
 1878|    218|    int statenr, transnr;
 1879|    218|    xmlRegStatePtr state;
 1880|    218|    int has_epsilon;
 1881|       |
 1882|    218|    if (ctxt->states == NULL) return;
  ------------------
  |  Branch (1882:9): [True: 0, False: 218]
  ------------------
 1883|       |
 1884|       |    /*
 1885|       |     * Eliminate simple epsilon transition and the associated unreachable
 1886|       |     * states.
 1887|       |     */
 1888|    218|    xmlFAEliminateSimpleEpsilonTransitions(ctxt);
 1889|  1.28k|    for (statenr = 0;statenr < ctxt->nbStates;statenr++) {
  ------------------
  |  Branch (1889:22): [True: 1.07k, False: 218]
  ------------------
 1890|  1.07k|	state = ctxt->states[statenr];
 1891|  1.07k|	if ((state != NULL) && (state->type == XML_REGEXP_UNREACH_STATE)) {
  ------------------
  |  Branch (1891:6): [True: 1.07k, False: 0]
  |  Branch (1891:25): [True: 135, False: 935]
  ------------------
 1892|    135|	    xmlRegFreeState(state);
 1893|    135|	    ctxt->states[statenr] = NULL;
 1894|    135|	}
 1895|  1.07k|    }
 1896|       |
 1897|    218|    has_epsilon = 0;
 1898|       |
 1899|       |    /*
 1900|       |     * Build the completed transitions bypassing the epsilons
 1901|       |     * Use a marking algorithm to avoid loops
 1902|       |     * Mark sink states too.
 1903|       |     * Process from the latest states backward to the start when
 1904|       |     * there is long cascading epsilon chains this minimize the
 1905|       |     * recursions and transition compares when adding the new ones
 1906|       |     */
 1907|  1.28k|    for (statenr = ctxt->nbStates - 1;statenr >= 0;statenr--) {
  ------------------
  |  Branch (1907:39): [True: 1.07k, False: 218]
  ------------------
 1908|  1.07k|	state = ctxt->states[statenr];
 1909|  1.07k|	if (state == NULL)
  ------------------
  |  Branch (1909:6): [True: 135, False: 935]
  ------------------
 1910|    135|	    continue;
 1911|    935|	if ((state->nbTrans == 0) &&
  ------------------
  |  Branch (1911:6): [True: 176, False: 759]
  ------------------
 1912|    935|	    (state->type != XML_REGEXP_FINAL_STATE)) {
  ------------------
  |  Branch (1912:6): [True: 0, False: 176]
  ------------------
 1913|      0|	    state->type = XML_REGEXP_SINK_STATE;
 1914|      0|	}
 1915|  3.20k|	for (transnr = 0;transnr < state->nbTrans;transnr++) {
  ------------------
  |  Branch (1915:19): [True: 2.26k, False: 935]
  ------------------
 1916|  2.26k|	    if ((state->trans[transnr].atom == NULL) &&
  ------------------
  |  Branch (1916:10): [True: 507, False: 1.76k]
  ------------------
 1917|  2.26k|		(state->trans[transnr].to >= 0)) {
  ------------------
  |  Branch (1917:3): [True: 454, False: 53]
  ------------------
 1918|    454|		if (state->trans[transnr].to == statenr) {
  ------------------
  |  Branch (1918:7): [True: 7, False: 447]
  ------------------
 1919|      7|		    state->trans[transnr].to = -1;
 1920|    447|		} else if (state->trans[transnr].count < 0) {
  ------------------
  |  Branch (1920:14): [True: 343, False: 104]
  ------------------
 1921|    343|		    int newto = state->trans[transnr].to;
 1922|       |
 1923|    343|		    has_epsilon = 1;
 1924|    343|		    state->trans[transnr].to = -2;
 1925|    343|		    state->mark = XML_REGEXP_MARK_START;
 1926|    343|		    xmlFAReduceEpsilonTransitions(ctxt, statenr,
 1927|    343|				      newto, state->trans[transnr].counter);
 1928|    343|		    xmlFAFinishReduceEpsilonTransitions(ctxt, newto);
 1929|    343|		    state->mark = XML_REGEXP_MARK_NORMAL;
 1930|    343|	        }
 1931|    454|	    }
 1932|  2.26k|	}
 1933|    935|    }
 1934|       |    /*
 1935|       |     * Eliminate the epsilon transitions
 1936|       |     */
 1937|    218|    if (has_epsilon) {
  ------------------
  |  Branch (1937:9): [True: 125, False: 93]
  ------------------
 1938|    887|	for (statenr = 0;statenr < ctxt->nbStates;statenr++) {
  ------------------
  |  Branch (1938:19): [True: 762, False: 125]
  ------------------
 1939|    762|	    state = ctxt->states[statenr];
 1940|    762|	    if (state == NULL)
  ------------------
  |  Branch (1940:10): [True: 132, False: 630]
  ------------------
 1941|    132|		continue;
 1942|  2.66k|	    for (transnr = 0;transnr < state->nbTrans;transnr++) {
  ------------------
  |  Branch (1942:23): [True: 2.03k, False: 630]
  ------------------
 1943|  2.03k|		xmlRegTransPtr trans = &(state->trans[transnr]);
 1944|  2.03k|		if ((trans->atom == NULL) &&
  ------------------
  |  Branch (1944:7): [True: 507, False: 1.52k]
  ------------------
 1945|  2.03k|		    (trans->count < 0) &&
  ------------------
  |  Branch (1945:7): [True: 397, False: 110]
  ------------------
 1946|  2.03k|		    (trans->to >= 0)) {
  ------------------
  |  Branch (1946:7): [True: 0, False: 397]
  ------------------
 1947|      0|		    trans->to = -1;
 1948|      0|		}
 1949|  2.03k|	    }
 1950|    630|	}
 1951|    125|    }
 1952|       |
 1953|       |    /*
 1954|       |     * Use this pass to detect unreachable states too
 1955|       |     */
 1956|  1.28k|    for (statenr = 0;statenr < ctxt->nbStates;statenr++) {
  ------------------
  |  Branch (1956:22): [True: 1.07k, False: 218]
  ------------------
 1957|  1.07k|	state = ctxt->states[statenr];
 1958|  1.07k|	if (state != NULL)
  ------------------
  |  Branch (1958:6): [True: 935, False: 135]
  ------------------
 1959|    935|	    state->reached = XML_REGEXP_MARK_NORMAL;
 1960|  1.07k|    }
 1961|    218|    state = ctxt->states[0];
 1962|    218|    if (state != NULL)
  ------------------
  |  Branch (1962:9): [True: 218, False: 0]
  ------------------
 1963|    218|	state->reached = XML_REGEXP_MARK_START;
 1964|  1.07k|    while (state != NULL) {
  ------------------
  |  Branch (1964:12): [True: 856, False: 218]
  ------------------
 1965|    856|	xmlRegStatePtr target = NULL;
 1966|    856|	state->reached = XML_REGEXP_MARK_VISITED;
 1967|       |	/*
 1968|       |	 * Mark all states reachable from the current reachable state
 1969|       |	 */
 1970|  2.80k|	for (transnr = 0;transnr < state->nbTrans;transnr++) {
  ------------------
  |  Branch (1970:19): [True: 1.94k, False: 856]
  ------------------
 1971|  1.94k|	    if ((state->trans[transnr].to >= 0) &&
  ------------------
  |  Branch (1971:10): [True: 1.54k, False: 399]
  ------------------
 1972|  1.94k|		((state->trans[transnr].atom != NULL) ||
  ------------------
  |  Branch (1972:4): [True: 1.45k, False: 95]
  ------------------
 1973|  1.54k|		 (state->trans[transnr].count >= 0))) {
  ------------------
  |  Branch (1973:4): [True: 95, False: 0]
  ------------------
 1974|  1.54k|		int newto = state->trans[transnr].to;
 1975|       |
 1976|  1.54k|		if (ctxt->states[newto] == NULL)
  ------------------
  |  Branch (1976:7): [True: 0, False: 1.54k]
  ------------------
 1977|      0|		    continue;
 1978|  1.54k|		if (ctxt->states[newto]->reached == XML_REGEXP_MARK_NORMAL) {
  ------------------
  |  Branch (1978:7): [True: 638, False: 909]
  ------------------
 1979|    638|		    ctxt->states[newto]->reached = XML_REGEXP_MARK_START;
 1980|    638|		    target = ctxt->states[newto];
 1981|    638|		}
 1982|  1.54k|	    }
 1983|  1.94k|	}
 1984|       |
 1985|       |	/*
 1986|       |	 * find the next accessible state not explored
 1987|       |	 */
 1988|    856|	if (target == NULL) {
  ------------------
  |  Branch (1988:6): [True: 365, False: 491]
  ------------------
 1989|  2.10k|	    for (statenr = 1;statenr < ctxt->nbStates;statenr++) {
  ------------------
  |  Branch (1989:23): [True: 1.88k, False: 218]
  ------------------
 1990|  1.88k|		state = ctxt->states[statenr];
 1991|  1.88k|		if ((state != NULL) && (state->reached ==
  ------------------
  |  Branch (1991:7): [True: 1.56k, False: 324]
  |  Branch (1991:26): [True: 147, False: 1.41k]
  ------------------
 1992|  1.56k|			XML_REGEXP_MARK_START)) {
 1993|    147|		    target = state;
 1994|    147|		    break;
 1995|    147|		}
 1996|  1.88k|	    }
 1997|    365|	}
 1998|    856|	state = target;
 1999|    856|    }
 2000|  1.28k|    for (statenr = 0;statenr < ctxt->nbStates;statenr++) {
  ------------------
  |  Branch (2000:22): [True: 1.07k, False: 218]
  ------------------
 2001|  1.07k|	state = ctxt->states[statenr];
 2002|  1.07k|	if ((state != NULL) && (state->reached == XML_REGEXP_MARK_NORMAL)) {
  ------------------
  |  Branch (2002:6): [True: 935, False: 135]
  |  Branch (2002:25): [True: 79, False: 856]
  ------------------
 2003|     79|	    xmlRegFreeState(state);
 2004|     79|	    ctxt->states[statenr] = NULL;
 2005|     79|	}
 2006|  1.07k|    }
 2007|       |
 2008|    218|}
xmlregexp.c:xmlFAEliminateSimpleEpsilonTransitions:
 1824|    218|xmlFAEliminateSimpleEpsilonTransitions(xmlRegParserCtxtPtr ctxt) {
 1825|    218|    int statenr, i, j, newto;
 1826|    218|    xmlRegStatePtr state, tmp;
 1827|       |
 1828|  1.28k|    for (statenr = 0;statenr < ctxt->nbStates;statenr++) {
  ------------------
  |  Branch (1828:22): [True: 1.07k, False: 218]
  ------------------
 1829|  1.07k|	state = ctxt->states[statenr];
 1830|  1.07k|	if (state == NULL)
  ------------------
  |  Branch (1830:6): [True: 0, False: 1.07k]
  ------------------
 1831|      0|	    continue;
 1832|  1.07k|	if (state->nbTrans != 1)
  ------------------
  |  Branch (1832:6): [True: 496, False: 574]
  ------------------
 1833|    496|	    continue;
 1834|    574|       if (state->type == XML_REGEXP_UNREACH_STATE ||
  ------------------
  |  Branch (1834:12): [True: 0, False: 574]
  ------------------
 1835|    574|           state->type == XML_REGEXP_FINAL_STATE)
  ------------------
  |  Branch (1835:12): [True: 42, False: 532]
  ------------------
 1836|     42|	    continue;
 1837|       |	/* is the only transition out a basic transition */
 1838|    532|	if ((state->trans[0].atom == NULL) &&
  ------------------
  |  Branch (1838:6): [True: 175, False: 357]
  ------------------
 1839|    532|	    (state->trans[0].to >= 0) &&
  ------------------
  |  Branch (1839:6): [True: 175, False: 0]
  ------------------
 1840|    532|	    (state->trans[0].to != statenr) &&
  ------------------
  |  Branch (1840:6): [True: 175, False: 0]
  ------------------
 1841|    532|	    (state->trans[0].counter < 0) &&
  ------------------
  |  Branch (1841:6): [True: 175, False: 0]
  ------------------
 1842|    532|	    (state->trans[0].count < 0)) {
  ------------------
  |  Branch (1842:6): [True: 175, False: 0]
  ------------------
 1843|    175|	    newto = state->trans[0].to;
 1844|       |
 1845|    175|            if (state->type == XML_REGEXP_START_STATE) {
  ------------------
  |  Branch (1845:17): [True: 40, False: 135]
  ------------------
 1846|    135|            } else {
 1847|    310|	        for (i = 0;i < state->nbTransTo;i++) {
  ------------------
  |  Branch (1847:21): [True: 175, False: 135]
  ------------------
 1848|    175|		    tmp = ctxt->states[state->transTo[i]];
 1849|  1.19k|		    for (j = 0;j < tmp->nbTrans;j++) {
  ------------------
  |  Branch (1849:18): [True: 1.02k, False: 175]
  ------------------
 1850|  1.02k|			if (tmp->trans[j].to == statenr) {
  ------------------
  |  Branch (1850:8): [True: 168, False: 852]
  ------------------
 1851|    168|			    tmp->trans[j].to = -1;
 1852|    168|			    xmlRegStateAddTrans(ctxt, tmp, tmp->trans[j].atom,
 1853|    168|						ctxt->states[newto],
 1854|    168|					        tmp->trans[j].counter,
 1855|    168|						tmp->trans[j].count);
 1856|    168|			}
 1857|  1.02k|		    }
 1858|    175|		}
 1859|    135|		if (state->type == XML_REGEXP_FINAL_STATE)
  ------------------
  |  Branch (1859:7): [True: 0, False: 135]
  ------------------
 1860|      0|		    ctxt->states[newto]->type = XML_REGEXP_FINAL_STATE;
 1861|       |		/* eliminate the transition completely */
 1862|    135|		state->nbTrans = 0;
 1863|       |
 1864|    135|                state->type = XML_REGEXP_UNREACH_STATE;
 1865|       |
 1866|    135|	    }
 1867|       |
 1868|    175|	}
 1869|    532|    }
 1870|    218|}
xmlregexp.c:xmlFAReduceEpsilonTransitions:
 1722|    397|	                      int tonr, int counter) {
 1723|    397|    int transnr;
 1724|    397|    xmlRegStatePtr from;
 1725|    397|    xmlRegStatePtr to;
 1726|       |
 1727|    397|    from = ctxt->states[fromnr];
 1728|    397|    if (from == NULL)
  ------------------
  |  Branch (1728:9): [True: 0, False: 397]
  ------------------
 1729|      0|	return;
 1730|    397|    to = ctxt->states[tonr];
 1731|    397|    if (to == NULL)
  ------------------
  |  Branch (1731:9): [True: 0, False: 397]
  ------------------
 1732|      0|	return;
 1733|    397|    if ((to->mark == XML_REGEXP_MARK_START) ||
  ------------------
  |  Branch (1733:9): [True: 0, False: 397]
  ------------------
 1734|    397|	(to->mark == XML_REGEXP_MARK_VISITED))
  ------------------
  |  Branch (1734:2): [True: 1, False: 396]
  ------------------
 1735|      1|	return;
 1736|       |
 1737|    396|    to->mark = XML_REGEXP_MARK_VISITED;
 1738|    396|    if (to->type == XML_REGEXP_FINAL_STATE) {
  ------------------
  |  Branch (1738:9): [True: 211, False: 185]
  ------------------
 1739|    211|	from->type = XML_REGEXP_FINAL_STATE;
 1740|    211|    }
 1741|  1.79k|    for (transnr = 0;transnr < to->nbTrans;transnr++) {
  ------------------
  |  Branch (1741:22): [True: 1.39k, False: 396]
  ------------------
 1742|  1.39k|        xmlRegTransPtr t1 = &to->trans[transnr];
 1743|  1.39k|        int tcounter;
 1744|       |
 1745|  1.39k|        if (t1->to < 0)
  ------------------
  |  Branch (1745:13): [True: 364, False: 1.03k]
  ------------------
 1746|    364|	    continue;
 1747|  1.03k|        if (t1->counter >= 0) {
  ------------------
  |  Branch (1747:13): [True: 102, False: 933]
  ------------------
 1748|       |            /* assert(counter < 0); */
 1749|    102|            tcounter = t1->counter;
 1750|    933|        } else {
 1751|    933|            tcounter = counter;
 1752|    933|        }
 1753|  1.03k|	if (t1->atom == NULL) {
  ------------------
  |  Branch (1753:6): [True: 121, False: 914]
  ------------------
 1754|       |	    /*
 1755|       |	     * Don't remove counted transitions
 1756|       |	     * Don't loop either
 1757|       |	     */
 1758|    121|	    if (t1->to != fromnr) {
  ------------------
  |  Branch (1758:10): [True: 111, False: 10]
  ------------------
 1759|    111|		if (t1->count >= 0) {
  ------------------
  |  Branch (1759:7): [True: 57, False: 54]
  ------------------
 1760|     57|		    xmlRegStateAddTrans(ctxt, from, NULL, ctxt->states[t1->to],
 1761|     57|					-1, t1->count);
 1762|     57|		} else {
 1763|     54|                    xmlFAReduceEpsilonTransitions(ctxt, fromnr, t1->to,
 1764|     54|                                                  tcounter);
 1765|     54|		}
 1766|    111|	    }
 1767|    914|	} else {
 1768|    914|            xmlRegStateAddTrans(ctxt, from, t1->atom,
 1769|    914|                                ctxt->states[t1->to], tcounter, -1);
 1770|    914|	}
 1771|  1.03k|    }
 1772|    396|}
xmlregexp.c:xmlFAFinishReduceEpsilonTransitions:
 1783|    464|xmlFAFinishReduceEpsilonTransitions(xmlRegParserCtxtPtr ctxt, int tonr) {
 1784|    464|    int transnr;
 1785|    464|    xmlRegStatePtr to;
 1786|       |
 1787|    464|    to = ctxt->states[tonr];
 1788|    464|    if (to == NULL)
  ------------------
  |  Branch (1788:9): [True: 0, False: 464]
  ------------------
 1789|      0|	return;
 1790|    464|    if ((to->mark == XML_REGEXP_MARK_START) ||
  ------------------
  |  Branch (1790:9): [True: 10, False: 454]
  ------------------
 1791|    464|	(to->mark == XML_REGEXP_MARK_NORMAL))
  ------------------
  |  Branch (1791:2): [True: 58, False: 396]
  ------------------
 1792|     68|	return;
 1793|       |
 1794|    396|    to->mark = XML_REGEXP_MARK_NORMAL;
 1795|  1.79k|    for (transnr = 0;transnr < to->nbTrans;transnr++) {
  ------------------
  |  Branch (1795:22): [True: 1.39k, False: 396]
  ------------------
 1796|  1.39k|	xmlRegTransPtr t1 = &to->trans[transnr];
 1797|  1.39k|	if ((t1->to >= 0) && (t1->atom == NULL))
  ------------------
  |  Branch (1797:6): [True: 1.03k, False: 364]
  |  Branch (1797:23): [True: 121, False: 914]
  ------------------
 1798|    121|            xmlFAFinishReduceEpsilonTransitions(ctxt, t1->to);
 1799|  1.39k|    }
 1800|    396|}
xmlregexp.c:xmlRegEpxFromParse:
  460|    218|xmlRegEpxFromParse(xmlRegParserCtxtPtr ctxt) {
  461|    218|    xmlRegexpPtr ret;
  462|       |
  463|    218|    ret = (xmlRegexpPtr) xmlMalloc(sizeof(xmlRegexp));
  464|    218|    if (ret == NULL) {
  ------------------
  |  Branch (464:9): [True: 0, False: 218]
  ------------------
  465|      0|	xmlRegexpErrMemory(ctxt, "compiling regexp");
  466|      0|	return(NULL);
  467|      0|    }
  468|    218|    memset(ret, 0, sizeof(xmlRegexp));
  469|    218|    ret->string = ctxt->string;
  470|    218|    ret->nbStates = ctxt->nbStates;
  471|    218|    ret->states = ctxt->states;
  472|    218|    ret->nbAtoms = ctxt->nbAtoms;
  473|    218|    ret->atoms = ctxt->atoms;
  474|    218|    ret->nbCounters = ctxt->nbCounters;
  475|    218|    ret->counters = ctxt->counters;
  476|    218|    ret->determinist = ctxt->determinist;
  477|    218|    ret->flags = ctxt->flags;
  478|    218|    if (ret->determinist == -1) {
  ------------------
  |  Branch (478:9): [True: 218, False: 0]
  ------------------
  479|    218|        if (xmlRegexpIsDeterminist(ret) < 0) {
  ------------------
  |  Branch (479:13): [True: 0, False: 218]
  ------------------
  480|      0|            xmlRegexpErrMemory(ctxt, "checking determinism");
  481|      0|            xmlFree(ret);
  482|      0|            return(NULL);
  483|      0|        }
  484|    218|    }
  485|       |
  486|    218|    if ((ret->determinist != 0) &&
  ------------------
  |  Branch (486:9): [True: 213, False: 5]
  ------------------
  487|    218|	(ret->nbCounters == 0) &&
  ------------------
  |  Branch (487:2): [True: 163, False: 50]
  ------------------
  488|    218|	(ctxt->negs == 0) &&
  ------------------
  |  Branch (488:2): [True: 158, False: 5]
  ------------------
  489|    218|	(ret->atoms != NULL) &&
  ------------------
  |  Branch (489:2): [True: 150, False: 8]
  ------------------
  490|    218|	(ret->atoms[0] != NULL) &&
  ------------------
  |  Branch (490:2): [True: 150, False: 0]
  ------------------
  491|    218|	(ret->atoms[0]->type == XML_REGEXP_STRING)) {
  ------------------
  |  Branch (491:2): [True: 127, False: 23]
  ------------------
  492|    127|	int i, j, nbstates = 0, nbatoms = 0;
  493|    127|	int *stateRemap;
  494|    127|	int *stringRemap;
  495|    127|	int *transitions;
  496|    127|	void **transdata;
  497|    127|	xmlChar **stringMap;
  498|    127|        xmlChar *value;
  499|       |
  500|       |	/*
  501|       |	 * Switch to a compact representation
  502|       |	 * 1/ counting the effective number of states left
  503|       |	 * 2/ counting the unique number of atoms, and check that
  504|       |	 *    they are all of the string type
  505|       |	 * 3/ build a table state x atom for the transitions
  506|       |	 */
  507|       |
  508|    127|	stateRemap = xmlMalloc(ret->nbStates * sizeof(int));
  509|    127|	if (stateRemap == NULL) {
  ------------------
  |  Branch (509:6): [True: 0, False: 127]
  ------------------
  510|      0|	    xmlRegexpErrMemory(ctxt, "compiling regexp");
  511|      0|	    xmlFree(ret);
  512|      0|	    return(NULL);
  513|      0|	}
  514|    629|	for (i = 0;i < ret->nbStates;i++) {
  ------------------
  |  Branch (514:13): [True: 502, False: 127]
  ------------------
  515|    502|	    if (ret->states[i] != NULL) {
  ------------------
  |  Branch (515:10): [True: 471, False: 31]
  ------------------
  516|    471|		stateRemap[i] = nbstates;
  517|    471|		nbstates++;
  518|    471|	    } else {
  519|     31|		stateRemap[i] = -1;
  520|     31|	    }
  521|    502|	}
  522|    127|	stringMap = xmlMalloc(ret->nbAtoms * sizeof(char *));
  523|    127|	if (stringMap == NULL) {
  ------------------
  |  Branch (523:6): [True: 0, False: 127]
  ------------------
  524|      0|	    xmlRegexpErrMemory(ctxt, "compiling regexp");
  525|      0|	    xmlFree(stateRemap);
  526|      0|	    xmlFree(ret);
  527|      0|	    return(NULL);
  528|      0|	}
  529|    127|	stringRemap = xmlMalloc(ret->nbAtoms * sizeof(int));
  530|    127|	if (stringRemap == NULL) {
  ------------------
  |  Branch (530:6): [True: 0, False: 127]
  ------------------
  531|      0|	    xmlRegexpErrMemory(ctxt, "compiling regexp");
  532|      0|	    xmlFree(stringMap);
  533|      0|	    xmlFree(stateRemap);
  534|      0|	    xmlFree(ret);
  535|      0|	    return(NULL);
  536|      0|	}
  537|    545|	for (i = 0;i < ret->nbAtoms;i++) {
  ------------------
  |  Branch (537:13): [True: 418, False: 127]
  ------------------
  538|    418|	    if ((ret->atoms[i]->type == XML_REGEXP_STRING) &&
  ------------------
  |  Branch (538:10): [True: 418, False: 0]
  ------------------
  539|    418|		(ret->atoms[i]->quant == XML_REGEXP_QUANT_ONCE)) {
  ------------------
  |  Branch (539:3): [True: 418, False: 0]
  ------------------
  540|    418|		value = ret->atoms[i]->valuep;
  541|  1.19k|                for (j = 0;j < nbatoms;j++) {
  ------------------
  |  Branch (541:28): [True: 846, False: 344]
  ------------------
  542|    846|		    if (xmlStrEqual(stringMap[j], value)) {
  ------------------
  |  Branch (542:11): [True: 74, False: 772]
  ------------------
  543|     74|			stringRemap[i] = j;
  544|     74|			break;
  545|     74|		    }
  546|    846|		}
  547|    418|		if (j >= nbatoms) {
  ------------------
  |  Branch (547:7): [True: 344, False: 74]
  ------------------
  548|    344|		    stringRemap[i] = nbatoms;
  549|    344|		    stringMap[nbatoms] = xmlStrdup(value);
  550|    344|		    if (stringMap[nbatoms] == NULL) {
  ------------------
  |  Branch (550:11): [True: 0, False: 344]
  ------------------
  551|      0|			for (i = 0;i < nbatoms;i++)
  ------------------
  |  Branch (551:15): [True: 0, False: 0]
  ------------------
  552|      0|			    xmlFree(stringMap[i]);
  553|      0|			xmlFree(stringRemap);
  554|      0|			xmlFree(stringMap);
  555|      0|			xmlFree(stateRemap);
  556|      0|			xmlFree(ret);
  557|      0|			return(NULL);
  558|      0|		    }
  559|    344|		    nbatoms++;
  560|    344|		}
  561|    418|	    } else {
  562|      0|		xmlFree(stateRemap);
  563|      0|		xmlFree(stringRemap);
  564|      0|		for (i = 0;i < nbatoms;i++)
  ------------------
  |  Branch (564:14): [True: 0, False: 0]
  ------------------
  565|      0|		    xmlFree(stringMap[i]);
  566|      0|		xmlFree(stringMap);
  567|      0|		xmlFree(ret);
  568|      0|		return(NULL);
  569|      0|	    }
  570|    418|	}
  571|    127|	transitions = (int *) xmlRegCalloc2(nbstates + 1, nbatoms + 1,
  572|    127|                                            sizeof(int));
  573|    127|	if (transitions == NULL) {
  ------------------
  |  Branch (573:6): [True: 0, False: 127]
  ------------------
  574|      0|	    xmlFree(stateRemap);
  575|      0|	    xmlFree(stringRemap);
  576|      0|            for (i = 0;i < nbatoms;i++)
  ------------------
  |  Branch (576:24): [True: 0, False: 0]
  ------------------
  577|      0|		xmlFree(stringMap[i]);
  578|      0|	    xmlFree(stringMap);
  579|      0|	    xmlFree(ret);
  580|      0|	    return(NULL);
  581|      0|	}
  582|       |
  583|       |	/*
  584|       |	 * Allocate the transition table. The first entry for each
  585|       |	 * state corresponds to the state type.
  586|       |	 */
  587|    127|	transdata = NULL;
  588|       |
  589|    629|	for (i = 0;i < ret->nbStates;i++) {
  ------------------
  |  Branch (589:13): [True: 502, False: 127]
  ------------------
  590|    502|	    int stateno, atomno, targetno, prev;
  591|    502|	    xmlRegStatePtr state;
  592|    502|	    xmlRegTransPtr trans;
  593|       |
  594|    502|	    stateno = stateRemap[i];
  595|    502|	    if (stateno == -1)
  ------------------
  |  Branch (595:10): [True: 31, False: 471]
  ------------------
  596|     31|		continue;
  597|    471|	    state = ret->states[i];
  598|       |
  599|    471|	    transitions[stateno * (nbatoms + 1)] = state->type;
  600|       |
  601|  1.26k|	    for (j = 0;j < state->nbTrans;j++) {
  ------------------
  |  Branch (601:17): [True: 793, False: 471]
  ------------------
  602|    793|		trans = &(state->trans[j]);
  603|    793|		if ((trans->to < 0) || (trans->atom == NULL))
  ------------------
  |  Branch (603:7): [True: 212, False: 581]
  |  Branch (603:26): [True: 0, False: 581]
  ------------------
  604|    212|		    continue;
  605|    581|                atomno = stringRemap[trans->atom->no];
  606|    581|		if ((trans->atom->data != NULL) && (transdata == NULL)) {
  ------------------
  |  Branch (606:7): [True: 581, False: 0]
  |  Branch (606:38): [True: 127, False: 454]
  ------------------
  607|    127|		    transdata = (void **) xmlRegCalloc2(nbstates, nbatoms,
  608|    127|			                                sizeof(void *));
  609|    127|		    if (transdata == NULL) {
  ------------------
  |  Branch (609:11): [True: 0, False: 127]
  ------------------
  610|      0|			xmlRegexpErrMemory(ctxt, "compiling regexp");
  611|      0|			break;
  612|      0|		    }
  613|    127|		}
  614|    581|		targetno = stateRemap[trans->to];
  615|       |		/*
  616|       |		 * if the same atom can generate transitions to 2 different
  617|       |		 * states then it means the automata is not deterministic and
  618|       |		 * the compact form can't be used !
  619|       |		 */
  620|    581|		prev = transitions[stateno * (nbatoms + 1) + atomno + 1];
  621|    581|		if (prev != 0) {
  ------------------
  |  Branch (621:7): [True: 0, False: 581]
  ------------------
  622|      0|		    if (prev != targetno + 1) {
  ------------------
  |  Branch (622:11): [True: 0, False: 0]
  ------------------
  623|      0|			ret->determinist = 0;
  624|      0|			if (transdata != NULL)
  ------------------
  |  Branch (624:8): [True: 0, False: 0]
  ------------------
  625|      0|			    xmlFree(transdata);
  626|      0|			xmlFree(transitions);
  627|      0|			xmlFree(stateRemap);
  628|      0|			xmlFree(stringRemap);
  629|      0|			for (i = 0;i < nbatoms;i++)
  ------------------
  |  Branch (629:15): [True: 0, False: 0]
  ------------------
  630|      0|			    xmlFree(stringMap[i]);
  631|      0|			xmlFree(stringMap);
  632|      0|			goto not_determ;
  633|      0|		    }
  634|    581|		} else {
  635|       |#if 0
  636|       |		    printf("State %d trans %d: atom %d to %d : %d to %d\n",
  637|       |			   i, j, trans->atom->no, trans->to, atomno, targetno);
  638|       |#endif
  639|    581|		    transitions[stateno * (nbatoms + 1) + atomno + 1] =
  640|    581|			targetno + 1; /* to avoid 0 */
  641|    581|		    if (transdata != NULL)
  ------------------
  |  Branch (641:11): [True: 581, False: 0]
  ------------------
  642|    581|			transdata[stateno * nbatoms + atomno] =
  643|    581|			    trans->atom->data;
  644|    581|		}
  645|    581|	    }
  646|    471|	}
  647|    127|	ret->determinist = 1;
  648|       |	/*
  649|       |	 * Cleanup of the old data
  650|       |	 */
  651|    127|	if (ret->states != NULL) {
  ------------------
  |  Branch (651:6): [True: 127, False: 0]
  ------------------
  652|    629|	    for (i = 0;i < ret->nbStates;i++)
  ------------------
  |  Branch (652:17): [True: 502, False: 127]
  ------------------
  653|    502|		xmlRegFreeState(ret->states[i]);
  654|    127|	    xmlFree(ret->states);
  655|    127|	}
  656|    127|	ret->states = NULL;
  657|    127|	ret->nbStates = 0;
  658|    127|	if (ret->atoms != NULL) {
  ------------------
  |  Branch (658:6): [True: 127, False: 0]
  ------------------
  659|    545|	    for (i = 0;i < ret->nbAtoms;i++)
  ------------------
  |  Branch (659:17): [True: 418, False: 127]
  ------------------
  660|    418|		xmlRegFreeAtom(ret->atoms[i]);
  661|    127|	    xmlFree(ret->atoms);
  662|    127|	}
  663|    127|	ret->atoms = NULL;
  664|    127|	ret->nbAtoms = 0;
  665|       |
  666|    127|	ret->compact = transitions;
  667|    127|	ret->transdata = transdata;
  668|    127|	ret->stringMap = stringMap;
  669|    127|	ret->nbstrings = nbatoms;
  670|    127|	ret->nbstates = nbstates;
  671|    127|	xmlFree(stateRemap);
  672|    127|	xmlFree(stringRemap);
  673|    127|    }
  674|    218|not_determ:
  675|    218|    ctxt->string = NULL;
  676|    218|    ctxt->nbStates = 0;
  677|    218|    ctxt->states = NULL;
  678|    218|    ctxt->nbAtoms = 0;
  679|    218|    ctxt->atoms = NULL;
  680|    218|    ctxt->nbCounters = 0;
  681|    218|    ctxt->counters = NULL;
  682|    218|    return(ret);
  683|    218|}
xmlregexp.c:xmlRegCalloc2:
  436|    254|xmlRegCalloc2(size_t dim1, size_t dim2, size_t elemSize) {
  437|    254|    size_t totalSize;
  438|    254|    void *ret;
  439|       |
  440|       |    /* Check for overflow */
  441|    254|    if ((dim2 == 0) || (elemSize == 0) ||
  ------------------
  |  Branch (441:9): [True: 0, False: 254]
  |  Branch (441:24): [True: 0, False: 254]
  ------------------
  442|    254|        (dim1 > SIZE_MAX / dim2 / elemSize))
  ------------------
  |  |   36|    254|#define SIZE_MAX ((size_t) -1)
  ------------------
  |  Branch (442:9): [True: 0, False: 254]
  ------------------
  443|      0|        return (NULL);
  444|    254|    totalSize = dim1 * dim2 * elemSize;
  445|    254|    ret = xmlMalloc(totalSize);
  446|    254|    if (ret != NULL)
  ------------------
  |  Branch (446:9): [True: 254, False: 0]
  ------------------
  447|    254|        memset(ret, 0, totalSize);
  448|    254|    return (ret);
  449|    254|}
xmlregexp.c:xmlRegFreeParserCtxt:
  924|    436|xmlRegFreeParserCtxt(xmlRegParserCtxtPtr ctxt) {
  925|    436|    int i;
  926|    436|    if (ctxt == NULL)
  ------------------
  |  Branch (926:9): [True: 0, False: 436]
  ------------------
  927|      0|	return;
  928|       |
  929|    436|    if (ctxt->string != NULL)
  ------------------
  |  Branch (929:9): [True: 0, False: 436]
  ------------------
  930|      0|	xmlFree(ctxt->string);
  931|    436|    if (ctxt->states != NULL) {
  ------------------
  |  Branch (931:9): [True: 0, False: 436]
  ------------------
  932|      0|	for (i = 0;i < ctxt->nbStates;i++)
  ------------------
  |  Branch (932:13): [True: 0, False: 0]
  ------------------
  933|      0|	    xmlRegFreeState(ctxt->states[i]);
  934|      0|	xmlFree(ctxt->states);
  935|      0|    }
  936|    436|    if (ctxt->atoms != NULL) {
  ------------------
  |  Branch (936:9): [True: 0, False: 436]
  ------------------
  937|      0|	for (i = 0;i < ctxt->nbAtoms;i++)
  ------------------
  |  Branch (937:13): [True: 0, False: 0]
  ------------------
  938|      0|	    xmlRegFreeAtom(ctxt->atoms[i]);
  939|      0|	xmlFree(ctxt->atoms);
  940|      0|    }
  941|    436|    if (ctxt->counters != NULL)
  ------------------
  |  Branch (941:9): [True: 0, False: 436]
  ------------------
  942|      0|	xmlFree(ctxt->counters);
  943|    436|    xmlFree(ctxt);
  944|    436|}
xmlregexp.c:xmlRegCheckCharacter:
 2940|     10|xmlRegCheckCharacter(xmlRegAtomPtr atom, int codepoint) {
 2941|     10|    int i, ret = 0;
 2942|     10|    xmlRegRangePtr range;
 2943|       |
 2944|     10|    if ((atom == NULL) || (!IS_CHAR(codepoint)))
  ------------------
  |  |  125|     10|#define IS_CHAR(c)   xmlIsCharQ(c)
  |  |  ------------------
  |  |  |  |  118|     10|#define xmlIsCharQ(c)		(((c) < 0x100) ? \
  |  |  |  |  ------------------
  |  |  |  |  |  Branch (118:25): [True: 10, False: 0]
  |  |  |  |  ------------------
  |  |  |  |  119|     10|				 xmlIsChar_ch((c)) :\
  |  |  |  |  ------------------
  |  |  |  |  |  |  108|     10|#define xmlIsChar_ch(c)		(((0x9 <= (c)) && ((c) <= 0xa)) || \
  |  |  |  |  |  |  ------------------
  |  |  |  |  |  |  |  Branch (108:28): [True: 10, False: 0]
  |  |  |  |  |  |  |  Branch (108:44): [True: 0, False: 10]
  |  |  |  |  |  |  ------------------
  |  |  |  |  |  |  109|     10|				 ((c) == 0xd) || \
  |  |  |  |  |  |  ------------------
  |  |  |  |  |  |  |  Branch (109:6): [True: 0, False: 10]
  |  |  |  |  |  |  ------------------
  |  |  |  |  |  |  110|     10|				  (0x20 <= (c)))
  |  |  |  |  |  |  ------------------
  |  |  |  |  |  |  |  Branch (110:7): [True: 10, False: 0]
  |  |  |  |  |  |  ------------------
  |  |  |  |  ------------------
  |  |  |  |  120|     10|				(((0x100 <= (c)) && ((c) <= 0xd7ff)) || \
  |  |  |  |  ------------------
  |  |  |  |  |  Branch (120:7): [True: 0, False: 0]
  |  |  |  |  |  Branch (120:25): [True: 0, False: 0]
  |  |  |  |  ------------------
  |  |  |  |  121|      0|				 ((0xe000 <= (c)) && ((c) <= 0xfffd)) || \
  |  |  |  |  ------------------
  |  |  |  |  |  Branch (121:7): [True: 0, False: 0]
  |  |  |  |  |  Branch (121:26): [True: 0, False: 0]
  |  |  |  |  ------------------
  |  |  |  |  122|      0|				 ((0x10000 <= (c)) && ((c) <= 0x10ffff))))
  |  |  |  |  ------------------
  |  |  |  |  |  Branch (122:7): [True: 0, False: 0]
  |  |  |  |  |  Branch (122:27): [True: 0, False: 0]
  |  |  |  |  ------------------
  |  |  ------------------
  ------------------
  |  Branch (2944:9): [True: 0, False: 10]
  |  Branch (2944:27): [True: 0, False: 10]
  ------------------
 2945|      0|	return(-1);
 2946|       |
 2947|     10|    switch (atom->type) {
  ------------------
  |  Branch (2947:13): [True: 0, False: 10]
  ------------------
 2948|      0|        case XML_REGEXP_SUBREG:
  ------------------
  |  Branch (2948:9): [True: 0, False: 10]
  ------------------
 2949|      0|        case XML_REGEXP_EPSILON:
  ------------------
  |  Branch (2949:9): [True: 0, False: 10]
  ------------------
 2950|      0|	    return(-1);
 2951|      0|        case XML_REGEXP_CHARVAL:
  ------------------
  |  Branch (2951:9): [True: 0, False: 10]
  ------------------
 2952|      0|            return(codepoint == atom->codepoint);
 2953|      4|        case XML_REGEXP_RANGES: {
  ------------------
  |  Branch (2953:9): [True: 4, False: 6]
  ------------------
 2954|      4|	    int accept = 0;
 2955|       |
 2956|      8|	    for (i = 0;i < atom->nbRanges;i++) {
  ------------------
  |  Branch (2956:17): [True: 4, False: 4]
  ------------------
 2957|      4|		range = atom->ranges[i];
 2958|      4|		if (range->neg == 2) {
  ------------------
  |  Branch (2958:7): [True: 0, False: 4]
  ------------------
 2959|      0|		    ret = xmlRegCheckCharacterRange(range->type, codepoint,
 2960|      0|						0, range->start, range->end,
 2961|      0|						range->blockName);
 2962|      0|		    if (ret != 0)
  ------------------
  |  Branch (2962:11): [True: 0, False: 0]
  ------------------
 2963|      0|			return(0); /* excluded char */
 2964|      4|		} else if (range->neg) {
  ------------------
  |  Branch (2964:14): [True: 0, False: 4]
  ------------------
 2965|      0|		    ret = xmlRegCheckCharacterRange(range->type, codepoint,
 2966|      0|						0, range->start, range->end,
 2967|      0|						range->blockName);
 2968|      0|		    if (ret == 0)
  ------------------
  |  Branch (2968:11): [True: 0, False: 0]
  ------------------
 2969|      0|		        accept = 1;
 2970|      0|		    else
 2971|      0|		        return(0);
 2972|      4|		} else {
 2973|      4|		    ret = xmlRegCheckCharacterRange(range->type, codepoint,
 2974|      4|						0, range->start, range->end,
 2975|      4|						range->blockName);
 2976|      4|		    if (ret != 0)
  ------------------
  |  Branch (2976:11): [True: 0, False: 4]
  ------------------
 2977|      0|			accept = 1; /* might still be excluded */
 2978|      4|		}
 2979|      4|	    }
 2980|      4|	    return(accept);
 2981|      4|	}
 2982|      0|        case XML_REGEXP_STRING:
  ------------------
  |  Branch (2982:9): [True: 0, False: 10]
  ------------------
 2983|      0|	    printf("TODO: XML_REGEXP_STRING\n");
 2984|      0|	    return(-1);
 2985|      0|        case XML_REGEXP_ANYCHAR:
  ------------------
  |  Branch (2985:9): [True: 0, False: 10]
  ------------------
 2986|      4|        case XML_REGEXP_ANYSPACE:
  ------------------
  |  Branch (2986:9): [True: 4, False: 6]
  ------------------
 2987|      4|        case XML_REGEXP_NOTSPACE:
  ------------------
  |  Branch (2987:9): [True: 0, False: 10]
  ------------------
 2988|      4|        case XML_REGEXP_INITNAME:
  ------------------
  |  Branch (2988:9): [True: 0, False: 10]
  ------------------
 2989|      4|        case XML_REGEXP_NOTINITNAME:
  ------------------
  |  Branch (2989:9): [True: 0, False: 10]
  ------------------
 2990|      4|        case XML_REGEXP_NAMECHAR:
  ------------------
  |  Branch (2990:9): [True: 0, False: 10]
  ------------------
 2991|      4|        case XML_REGEXP_NOTNAMECHAR:
  ------------------
  |  Branch (2991:9): [True: 0, False: 10]
  ------------------
 2992|      6|        case XML_REGEXP_DECIMAL:
  ------------------
  |  Branch (2992:9): [True: 2, False: 8]
  ------------------
 2993|      6|        case XML_REGEXP_NOTDECIMAL:
  ------------------
  |  Branch (2993:9): [True: 0, False: 10]
  ------------------
 2994|      6|        case XML_REGEXP_REALCHAR:
  ------------------
  |  Branch (2994:9): [True: 0, False: 10]
  ------------------
 2995|      6|        case XML_REGEXP_NOTREALCHAR:
  ------------------
  |  Branch (2995:9): [True: 0, False: 10]
  ------------------
 2996|      6|        case XML_REGEXP_LETTER:
  ------------------
  |  Branch (2996:9): [True: 0, False: 10]
  ------------------
 2997|      6|        case XML_REGEXP_LETTER_UPPERCASE:
  ------------------
  |  Branch (2997:9): [True: 0, False: 10]
  ------------------
 2998|      6|        case XML_REGEXP_LETTER_LOWERCASE:
  ------------------
  |  Branch (2998:9): [True: 0, False: 10]
  ------------------
 2999|      6|        case XML_REGEXP_LETTER_TITLECASE:
  ------------------
  |  Branch (2999:9): [True: 0, False: 10]
  ------------------
 3000|      6|        case XML_REGEXP_LETTER_MODIFIER:
  ------------------
  |  Branch (3000:9): [True: 0, False: 10]
  ------------------
 3001|      6|        case XML_REGEXP_LETTER_OTHERS:
  ------------------
  |  Branch (3001:9): [True: 0, False: 10]
  ------------------
 3002|      6|        case XML_REGEXP_MARK:
  ------------------
  |  Branch (3002:9): [True: 0, False: 10]
  ------------------
 3003|      6|        case XML_REGEXP_MARK_NONSPACING:
  ------------------
  |  Branch (3003:9): [True: 0, False: 10]
  ------------------
 3004|      6|        case XML_REGEXP_MARK_SPACECOMBINING:
  ------------------
  |  Branch (3004:9): [True: 0, False: 10]
  ------------------
 3005|      6|        case XML_REGEXP_MARK_ENCLOSING:
  ------------------
  |  Branch (3005:9): [True: 0, False: 10]
  ------------------
 3006|      6|        case XML_REGEXP_NUMBER:
  ------------------
  |  Branch (3006:9): [True: 0, False: 10]
  ------------------
 3007|      6|        case XML_REGEXP_NUMBER_DECIMAL:
  ------------------
  |  Branch (3007:9): [True: 0, False: 10]
  ------------------
 3008|      6|        case XML_REGEXP_NUMBER_LETTER:
  ------------------
  |  Branch (3008:9): [True: 0, False: 10]
  ------------------
 3009|      6|        case XML_REGEXP_NUMBER_OTHERS:
  ------------------
  |  Branch (3009:9): [True: 0, False: 10]
  ------------------
 3010|      6|        case XML_REGEXP_PUNCT:
  ------------------
  |  Branch (3010:9): [True: 0, False: 10]
  ------------------
 3011|      6|        case XML_REGEXP_PUNCT_CONNECTOR:
  ------------------
  |  Branch (3011:9): [True: 0, False: 10]
  ------------------
 3012|      6|        case XML_REGEXP_PUNCT_DASH:
  ------------------
  |  Branch (3012:9): [True: 0, False: 10]
  ------------------
 3013|      6|        case XML_REGEXP_PUNCT_OPEN:
  ------------------
  |  Branch (3013:9): [True: 0, False: 10]
  ------------------
 3014|      6|        case XML_REGEXP_PUNCT_CLOSE:
  ------------------
  |  Branch (3014:9): [True: 0, False: 10]
  ------------------
 3015|      6|        case XML_REGEXP_PUNCT_INITQUOTE:
  ------------------
  |  Branch (3015:9): [True: 0, False: 10]
  ------------------
 3016|      6|        case XML_REGEXP_PUNCT_FINQUOTE:
  ------------------
  |  Branch (3016:9): [True: 0, False: 10]
  ------------------
 3017|      6|        case XML_REGEXP_PUNCT_OTHERS:
  ------------------
  |  Branch (3017:9): [True: 0, False: 10]
  ------------------
 3018|      6|        case XML_REGEXP_SEPAR:
  ------------------
  |  Branch (3018:9): [True: 0, False: 10]
  ------------------
 3019|      6|        case XML_REGEXP_SEPAR_SPACE:
  ------------------
  |  Branch (3019:9): [True: 0, False: 10]
  ------------------
 3020|      6|        case XML_REGEXP_SEPAR_LINE:
  ------------------
  |  Branch (3020:9): [True: 0, False: 10]
  ------------------
 3021|      6|        case XML_REGEXP_SEPAR_PARA:
  ------------------
  |  Branch (3021:9): [True: 0, False: 10]
  ------------------
 3022|      6|        case XML_REGEXP_SYMBOL:
  ------------------
  |  Branch (3022:9): [True: 0, False: 10]
  ------------------
 3023|      6|        case XML_REGEXP_SYMBOL_MATH:
  ------------------
  |  Branch (3023:9): [True: 0, False: 10]
  ------------------
 3024|      6|        case XML_REGEXP_SYMBOL_CURRENCY:
  ------------------
  |  Branch (3024:9): [True: 0, False: 10]
  ------------------
 3025|      6|        case XML_REGEXP_SYMBOL_MODIFIER:
  ------------------
  |  Branch (3025:9): [True: 0, False: 10]
  ------------------
 3026|      6|        case XML_REGEXP_SYMBOL_OTHERS:
  ------------------
  |  Branch (3026:9): [True: 0, False: 10]
  ------------------
 3027|      6|        case XML_REGEXP_OTHER:
  ------------------
  |  Branch (3027:9): [True: 0, False: 10]
  ------------------
 3028|      6|        case XML_REGEXP_OTHER_CONTROL:
  ------------------
  |  Branch (3028:9): [True: 0, False: 10]
  ------------------
 3029|      6|        case XML_REGEXP_OTHER_FORMAT:
  ------------------
  |  Branch (3029:9): [True: 0, False: 10]
  ------------------
 3030|      6|        case XML_REGEXP_OTHER_PRIVATE:
  ------------------
  |  Branch (3030:9): [True: 0, False: 10]
  ------------------
 3031|      6|        case XML_REGEXP_OTHER_NA:
  ------------------
  |  Branch (3031:9): [True: 0, False: 10]
  ------------------
 3032|      6|	case XML_REGEXP_BLOCK_NAME:
  ------------------
  |  Branch (3032:2): [True: 0, False: 10]
  ------------------
 3033|      6|	    ret = xmlRegCheckCharacterRange(atom->type, codepoint, 0, 0, 0,
 3034|      6|		                            (const xmlChar *)atom->valuep);
 3035|      6|	    if (atom->neg)
  ------------------
  |  Branch (3035:10): [True: 0, False: 6]
  ------------------
 3036|      0|		ret = !ret;
 3037|      6|	    break;
 3038|     10|    }
 3039|      6|    return(ret);
 3040|     10|}
xmlregexp.c:xmlRegCheckCharacterRange:
 2766|     10|	                  int start, int end, const xmlChar *blockName) {
 2767|     10|    int ret = 0;
 2768|       |
 2769|     10|    switch (type) {
  ------------------
  |  Branch (2769:13): [True: 0, False: 10]
  ------------------
 2770|      0|        case XML_REGEXP_STRING:
  ------------------
  |  Branch (2770:9): [True: 0, False: 10]
  ------------------
 2771|      0|        case XML_REGEXP_SUBREG:
  ------------------
  |  Branch (2771:9): [True: 0, False: 10]
  ------------------
 2772|      0|        case XML_REGEXP_RANGES:
  ------------------
  |  Branch (2772:9): [True: 0, False: 10]
  ------------------
 2773|      0|        case XML_REGEXP_EPSILON:
  ------------------
  |  Branch (2773:9): [True: 0, False: 10]
  ------------------
 2774|      0|	    return(-1);
 2775|      0|        case XML_REGEXP_ANYCHAR:
  ------------------
  |  Branch (2775:9): [True: 0, False: 10]
  ------------------
 2776|      0|	    ret = ((codepoint != '\n') && (codepoint != '\r'));
  ------------------
  |  Branch (2776:13): [True: 0, False: 0]
  |  Branch (2776:36): [True: 0, False: 0]
  ------------------
 2777|      0|	    break;
 2778|      4|        case XML_REGEXP_CHARVAL:
  ------------------
  |  Branch (2778:9): [True: 4, False: 6]
  ------------------
 2779|      4|	    ret = ((codepoint >= start) && (codepoint <= end));
  ------------------
  |  Branch (2779:13): [True: 2, False: 2]
  |  Branch (2779:37): [True: 0, False: 2]
  ------------------
 2780|      4|	    break;
 2781|      0|        case XML_REGEXP_NOTSPACE:
  ------------------
  |  Branch (2781:9): [True: 0, False: 10]
  ------------------
 2782|      0|	    neg = !neg;
 2783|       |            /* Falls through. */
 2784|      4|        case XML_REGEXP_ANYSPACE:
  ------------------
  |  Branch (2784:9): [True: 4, False: 6]
  ------------------
 2785|      4|	    ret = ((codepoint == '\n') || (codepoint == '\r') ||
  ------------------
  |  Branch (2785:13): [True: 0, False: 4]
  |  Branch (2785:36): [True: 0, False: 4]
  ------------------
 2786|      4|		   (codepoint == '\t') || (codepoint == ' '));
  ------------------
  |  Branch (2786:6): [True: 0, False: 4]
  |  Branch (2786:29): [True: 0, False: 4]
  ------------------
 2787|      4|	    break;
 2788|      0|        case XML_REGEXP_NOTINITNAME:
  ------------------
  |  Branch (2788:9): [True: 0, False: 10]
  ------------------
 2789|      0|	    neg = !neg;
 2790|       |            /* Falls through. */
 2791|      0|        case XML_REGEXP_INITNAME:
  ------------------
  |  Branch (2791:9): [True: 0, False: 10]
  ------------------
 2792|      0|	    ret = (IS_LETTER(codepoint) ||
  ------------------
  |  |  240|      0|#define IS_LETTER(c) (IS_BASECHAR(c) || IS_IDEOGRAPHIC(c))
  |  |  ------------------
  |  |  |  |  161|      0|#define IS_BASECHAR(c) xmlIsBaseCharQ(c)
  |  |  |  |  ------------------
  |  |  |  |  |  |   76|      0|#define xmlIsBaseCharQ(c)	(((c) < 0x100) ? \
  |  |  |  |  |  |  ------------------
  |  |  |  |  |  |  |  Branch (76:27): [True: 0, False: 0]
  |  |  |  |  |  |  |  Branch (76:28): [True: 0, False: 0]
  |  |  |  |  |  |  ------------------
  |  |  |  |  |  |   77|      0|				 xmlIsBaseChar_ch((c)) : \
  |  |  |  |  |  |  ------------------
  |  |  |  |  |  |  |  |   64|      0|#define xmlIsBaseChar_ch(c)	(((0x41 <= (c)) && ((c) <= 0x5a)) || \
  |  |  |  |  |  |  |  |  ------------------
  |  |  |  |  |  |  |  |  |  Branch (64:31): [True: 0, False: 0]
  |  |  |  |  |  |  |  |  |  Branch (64:48): [True: 0, False: 0]
  |  |  |  |  |  |  |  |  ------------------
  |  |  |  |  |  |  |  |   65|      0|				 ((0x61 <= (c)) && ((c) <= 0x7a)) || \
  |  |  |  |  |  |  |  |  ------------------
  |  |  |  |  |  |  |  |  |  Branch (65:7): [True: 0, False: 0]
  |  |  |  |  |  |  |  |  |  Branch (65:24): [True: 0, False: 0]
  |  |  |  |  |  |  |  |  ------------------
  |  |  |  |  |  |  |  |   66|      0|				 ((0xc0 <= (c)) && ((c) <= 0xd6)) || \
  |  |  |  |  |  |  |  |  ------------------
  |  |  |  |  |  |  |  |  |  Branch (66:7): [True: 0, False: 0]
  |  |  |  |  |  |  |  |  |  Branch (66:24): [True: 0, False: 0]
  |  |  |  |  |  |  |  |  ------------------
  |  |  |  |  |  |  |  |   67|      0|				 ((0xd8 <= (c)) && ((c) <= 0xf6)) || \
  |  |  |  |  |  |  |  |  ------------------
  |  |  |  |  |  |  |  |  |  Branch (67:7): [True: 0, False: 0]
  |  |  |  |  |  |  |  |  |  Branch (67:24): [True: 0, False: 0]
  |  |  |  |  |  |  |  |  ------------------
  |  |  |  |  |  |  |  |   68|      0|				  (0xf8 <= (c)))
  |  |  |  |  |  |  |  |  ------------------
  |  |  |  |  |  |  |  |  |  Branch (68:7): [True: 0, False: 0]
  |  |  |  |  |  |  |  |  ------------------
  |  |  |  |  |  |  ------------------
  |  |  |  |  |  |   78|      0|				 xmlCharInRange((c), &xmlIsBaseCharGroup))
  |  |  |  |  ------------------
  |  |  ------------------
  |  |               #define IS_LETTER(c) (IS_BASECHAR(c) || IS_IDEOGRAPHIC(c))
  |  |  ------------------
  |  |  |  |  229|      0|#define IS_IDEOGRAPHIC(c) xmlIsIdeographicQ(c)
  |  |  |  |  ------------------
  |  |  |  |  |  |  184|      0|#define xmlIsIdeographicQ(c)	(((c) < 0x100) ? \
  |  |  |  |  |  |  ------------------
  |  |  |  |  |  |  |  Branch (184:30): [True: 0, False: 0]
  |  |  |  |  |  |  |  Branch (184:31): [True: 0, False: 0]
  |  |  |  |  |  |  ------------------
  |  |  |  |  |  |  185|      0|				 0 :\
  |  |  |  |  |  |  186|      0|				(((0x4e00 <= (c)) && ((c) <= 0x9fa5)) || \
  |  |  |  |  |  |  ------------------
  |  |  |  |  |  |  |  Branch (186:7): [True: 0, False: 0]
  |  |  |  |  |  |  |  Branch (186:26): [True: 0, False: 0]
  |  |  |  |  |  |  ------------------
  |  |  |  |  |  |  187|      0|				 ((c) == 0x3007) || \
  |  |  |  |  |  |  ------------------
  |  |  |  |  |  |  |  Branch (187:6): [True: 0, False: 0]
  |  |  |  |  |  |  ------------------
  |  |  |  |  |  |  188|      0|				 ((0x3021 <= (c)) && ((c) <= 0x3029))))
  |  |  |  |  |  |  ------------------
  |  |  |  |  |  |  |  Branch (188:7): [True: 0, False: 0]
  |  |  |  |  |  |  |  Branch (188:26): [True: 0, False: 0]
  |  |  |  |  |  |  ------------------
  |  |  |  |  ------------------
  |  |  ------------------
  ------------------
 2793|      0|		   (codepoint == '_') || (codepoint == ':'));
  ------------------
  |  Branch (2793:6): [True: 0, False: 0]
  |  Branch (2793:28): [True: 0, False: 0]
  ------------------
 2794|      0|	    break;
 2795|      0|        case XML_REGEXP_NOTNAMECHAR:
  ------------------
  |  Branch (2795:9): [True: 0, False: 10]
  ------------------
 2796|      0|	    neg = !neg;
 2797|       |            /* Falls through. */
 2798|      0|        case XML_REGEXP_NAMECHAR:
  ------------------
  |  Branch (2798:9): [True: 0, False: 10]
  ------------------
 2799|      0|	    ret = (IS_LETTER(codepoint) || IS_DIGIT(codepoint) ||
  ------------------
  |  |  240|      0|#define IS_LETTER(c) (IS_BASECHAR(c) || IS_IDEOGRAPHIC(c))
  |  |  ------------------
  |  |  |  |  161|      0|#define IS_BASECHAR(c) xmlIsBaseCharQ(c)
  |  |  |  |  ------------------
  |  |  |  |  |  |   76|      0|#define xmlIsBaseCharQ(c)	(((c) < 0x100) ? \
  |  |  |  |  |  |  ------------------
  |  |  |  |  |  |  |  Branch (76:27): [True: 0, False: 0]
  |  |  |  |  |  |  |  Branch (76:28): [True: 0, False: 0]
  |  |  |  |  |  |  ------------------
  |  |  |  |  |  |   77|      0|				 xmlIsBaseChar_ch((c)) : \
  |  |  |  |  |  |  ------------------
  |  |  |  |  |  |  |  |   64|      0|#define xmlIsBaseChar_ch(c)	(((0x41 <= (c)) && ((c) <= 0x5a)) || \
  |  |  |  |  |  |  |  |  ------------------
  |  |  |  |  |  |  |  |  |  Branch (64:31): [True: 0, False: 0]
  |  |  |  |  |  |  |  |  |  Branch (64:48): [True: 0, False: 0]
  |  |  |  |  |  |  |  |  ------------------
  |  |  |  |  |  |  |  |   65|      0|				 ((0x61 <= (c)) && ((c) <= 0x7a)) || \
  |  |  |  |  |  |  |  |  ------------------
  |  |  |  |  |  |  |  |  |  Branch (65:7): [True: 0, False: 0]
  |  |  |  |  |  |  |  |  |  Branch (65:24): [True: 0, False: 0]
  |  |  |  |  |  |  |  |  ------------------
  |  |  |  |  |  |  |  |   66|      0|				 ((0xc0 <= (c)) && ((c) <= 0xd6)) || \
  |  |  |  |  |  |  |  |  ------------------
  |  |  |  |  |  |  |  |  |  Branch (66:7): [True: 0, False: 0]
  |  |  |  |  |  |  |  |  |  Branch (66:24): [True: 0, False: 0]
  |  |  |  |  |  |  |  |  ------------------
  |  |  |  |  |  |  |  |   67|      0|				 ((0xd8 <= (c)) && ((c) <= 0xf6)) || \
  |  |  |  |  |  |  |  |  ------------------
  |  |  |  |  |  |  |  |  |  Branch (67:7): [True: 0, False: 0]
  |  |  |  |  |  |  |  |  |  Branch (67:24): [True: 0, False: 0]
  |  |  |  |  |  |  |  |  ------------------
  |  |  |  |  |  |  |  |   68|      0|				  (0xf8 <= (c)))
  |  |  |  |  |  |  |  |  ------------------
  |  |  |  |  |  |  |  |  |  Branch (68:7): [True: 0, False: 0]
  |  |  |  |  |  |  |  |  ------------------
  |  |  |  |  |  |  ------------------
  |  |  |  |  |  |   78|      0|				 xmlCharInRange((c), &xmlIsBaseCharGroup))
  |  |  |  |  ------------------
  |  |  ------------------
  |  |               #define IS_LETTER(c) (IS_BASECHAR(c) || IS_IDEOGRAPHIC(c))
  |  |  ------------------
  |  |  |  |  229|      0|#define IS_IDEOGRAPHIC(c) xmlIsIdeographicQ(c)
  |  |  |  |  ------------------
  |  |  |  |  |  |  184|      0|#define xmlIsIdeographicQ(c)	(((c) < 0x100) ? \
  |  |  |  |  |  |  ------------------
  |  |  |  |  |  |  |  Branch (184:30): [True: 0, False: 0]
  |  |  |  |  |  |  |  Branch (184:31): [True: 0, False: 0]
  |  |  |  |  |  |  ------------------
  |  |  |  |  |  |  185|      0|				 0 :\
  |  |  |  |  |  |  186|      0|				(((0x4e00 <= (c)) && ((c) <= 0x9fa5)) || \
  |  |  |  |  |  |  ------------------
  |  |  |  |  |  |  |  Branch (186:7): [True: 0, False: 0]
  |  |  |  |  |  |  |  Branch (186:26): [True: 0, False: 0]
  |  |  |  |  |  |  ------------------
  |  |  |  |  |  |  187|      0|				 ((c) == 0x3007) || \
  |  |  |  |  |  |  ------------------
  |  |  |  |  |  |  |  Branch (187:6): [True: 0, False: 0]
  |  |  |  |  |  |  ------------------
  |  |  |  |  |  |  188|      0|				 ((0x3021 <= (c)) && ((c) <= 0x3029))))
  |  |  |  |  |  |  ------------------
  |  |  |  |  |  |  |  Branch (188:7): [True: 0, False: 0]
  |  |  |  |  |  |  |  Branch (188:26): [True: 0, False: 0]
  |  |  |  |  |  |  ------------------
  |  |  |  |  ------------------
  |  |  ------------------
  ------------------
              	    ret = (IS_LETTER(codepoint) || IS_DIGIT(codepoint) ||
  ------------------
  |  |  171|      0|#define IS_DIGIT(c) xmlIsDigitQ(c)
  |  |  ------------------
  |  |  |  |  152|      0|#define xmlIsDigitQ(c)		(((c) < 0x100) ? \
  |  |  |  |  ------------------
  |  |  |  |  |  Branch (152:25): [True: 0, False: 0]
  |  |  |  |  |  Branch (152:26): [True: 0, False: 0]
  |  |  |  |  ------------------
  |  |  |  |  153|      0|				 xmlIsDigit_ch((c)) : \
  |  |  |  |  ------------------
  |  |  |  |  |  |  144|      0|#define xmlIsDigit_ch(c)	(((0x30 <= (c)) && ((c) <= 0x39)))
  |  |  |  |  |  |  ------------------
  |  |  |  |  |  |  |  Branch (144:28): [True: 0, False: 0]
  |  |  |  |  |  |  |  Branch (144:45): [True: 0, False: 0]
  |  |  |  |  |  |  ------------------
  |  |  |  |  ------------------
  |  |  |  |  154|      0|				 xmlCharInRange((c), &xmlIsDigitGroup))
  |  |  ------------------
  ------------------
 2800|      0|		   (codepoint == '.') || (codepoint == '-') ||
  ------------------
  |  Branch (2800:6): [True: 0, False: 0]
  |  Branch (2800:28): [True: 0, False: 0]
  ------------------
 2801|      0|		   (codepoint == '_') || (codepoint == ':') ||
  ------------------
  |  Branch (2801:6): [True: 0, False: 0]
  |  Branch (2801:28): [True: 0, False: 0]
  ------------------
 2802|      0|		   IS_COMBINING(codepoint) || IS_EXTENDER(codepoint));
  ------------------
  |  |  189|      0|#define IS_COMBINING(c) xmlIsCombiningQ(c)
  |  |  ------------------
  |  |  |  |  132|      0|#define xmlIsCombiningQ(c)	(((c) < 0x100) ? \
  |  |  |  |  ------------------
  |  |  |  |  |  Branch (132:28): [True: 0, False: 0]
  |  |  |  |  |  Branch (132:29): [True: 0, False: 0]
  |  |  |  |  ------------------
  |  |  |  |  133|      0|				 0 : \
  |  |  |  |  134|      0|				 xmlCharInRange((c), &xmlIsCombiningGroup))
  |  |  ------------------
  ------------------
              		   IS_COMBINING(codepoint) || IS_EXTENDER(codepoint));
  ------------------
  |  |  210|      0|#define IS_EXTENDER(c) xmlIsExtenderQ(c)
  |  |  ------------------
  |  |  |  |  172|      0|#define xmlIsExtenderQ(c)	(((c) < 0x100) ? \
  |  |  |  |  ------------------
  |  |  |  |  |  Branch (172:27): [True: 0, False: 0]
  |  |  |  |  |  Branch (172:28): [True: 0, False: 0]
  |  |  |  |  ------------------
  |  |  |  |  173|      0|				 xmlIsExtender_ch((c)) : \
  |  |  |  |  ------------------
  |  |  |  |  |  |  164|      0|#define xmlIsExtender_ch(c)	(((c) == 0xb7))
  |  |  |  |  ------------------
  |  |  |  |  174|      0|				 xmlCharInRange((c), &xmlIsExtenderGroup))
  |  |  ------------------
  ------------------
 2803|      0|	    break;
 2804|      0|        case XML_REGEXP_NOTDECIMAL:
  ------------------
  |  Branch (2804:9): [True: 0, False: 10]
  ------------------
 2805|      0|	    neg = !neg;
 2806|       |            /* Falls through. */
 2807|      2|        case XML_REGEXP_DECIMAL:
  ------------------
  |  Branch (2807:9): [True: 2, False: 8]
  ------------------
 2808|      2|	    ret = xmlUCSIsCatNd(codepoint);
 2809|      2|	    break;
 2810|      0|        case XML_REGEXP_REALCHAR:
  ------------------
  |  Branch (2810:9): [True: 0, False: 10]
  ------------------
 2811|      0|	    neg = !neg;
 2812|       |            /* Falls through. */
 2813|      0|        case XML_REGEXP_NOTREALCHAR:
  ------------------
  |  Branch (2813:9): [True: 0, False: 10]
  ------------------
 2814|      0|	    ret = xmlUCSIsCatP(codepoint);
 2815|      0|	    if (ret == 0)
  ------------------
  |  Branch (2815:10): [True: 0, False: 0]
  ------------------
 2816|      0|		ret = xmlUCSIsCatZ(codepoint);
 2817|      0|	    if (ret == 0)
  ------------------
  |  Branch (2817:10): [True: 0, False: 0]
  ------------------
 2818|      0|		ret = xmlUCSIsCatC(codepoint);
 2819|      0|	    break;
 2820|      0|        case XML_REGEXP_LETTER:
  ------------------
  |  Branch (2820:9): [True: 0, False: 10]
  ------------------
 2821|      0|	    ret = xmlUCSIsCatL(codepoint);
 2822|      0|	    break;
 2823|      0|        case XML_REGEXP_LETTER_UPPERCASE:
  ------------------
  |  Branch (2823:9): [True: 0, False: 10]
  ------------------
 2824|      0|	    ret = xmlUCSIsCatLu(codepoint);
 2825|      0|	    break;
 2826|      0|        case XML_REGEXP_LETTER_LOWERCASE:
  ------------------
  |  Branch (2826:9): [True: 0, False: 10]
  ------------------
 2827|      0|	    ret = xmlUCSIsCatLl(codepoint);
 2828|      0|	    break;
 2829|      0|        case XML_REGEXP_LETTER_TITLECASE:
  ------------------
  |  Branch (2829:9): [True: 0, False: 10]
  ------------------
 2830|      0|	    ret = xmlUCSIsCatLt(codepoint);
 2831|      0|	    break;
 2832|      0|        case XML_REGEXP_LETTER_MODIFIER:
  ------------------
  |  Branch (2832:9): [True: 0, False: 10]
  ------------------
 2833|      0|	    ret = xmlUCSIsCatLm(codepoint);
 2834|      0|	    break;
 2835|      0|        case XML_REGEXP_LETTER_OTHERS:
  ------------------
  |  Branch (2835:9): [True: 0, False: 10]
  ------------------
 2836|      0|	    ret = xmlUCSIsCatLo(codepoint);
 2837|      0|	    break;
 2838|      0|        case XML_REGEXP_MARK:
  ------------------
  |  Branch (2838:9): [True: 0, False: 10]
  ------------------
 2839|      0|	    ret = xmlUCSIsCatM(codepoint);
 2840|      0|	    break;
 2841|      0|        case XML_REGEXP_MARK_NONSPACING:
  ------------------
  |  Branch (2841:9): [True: 0, False: 10]
  ------------------
 2842|      0|	    ret = xmlUCSIsCatMn(codepoint);
 2843|      0|	    break;
 2844|      0|        case XML_REGEXP_MARK_SPACECOMBINING:
  ------------------
  |  Branch (2844:9): [True: 0, False: 10]
  ------------------
 2845|      0|	    ret = xmlUCSIsCatMc(codepoint);
 2846|      0|	    break;
 2847|      0|        case XML_REGEXP_MARK_ENCLOSING:
  ------------------
  |  Branch (2847:9): [True: 0, False: 10]
  ------------------
 2848|      0|	    ret = xmlUCSIsCatMe(codepoint);
 2849|      0|	    break;
 2850|      0|        case XML_REGEXP_NUMBER:
  ------------------
  |  Branch (2850:9): [True: 0, False: 10]
  ------------------
 2851|      0|	    ret = xmlUCSIsCatN(codepoint);
 2852|      0|	    break;
 2853|      0|        case XML_REGEXP_NUMBER_DECIMAL:
  ------------------
  |  Branch (2853:9): [True: 0, False: 10]
  ------------------
 2854|      0|	    ret = xmlUCSIsCatNd(codepoint);
 2855|      0|	    break;
 2856|      0|        case XML_REGEXP_NUMBER_LETTER:
  ------------------
  |  Branch (2856:9): [True: 0, False: 10]
  ------------------
 2857|      0|	    ret = xmlUCSIsCatNl(codepoint);
 2858|      0|	    break;
 2859|      0|        case XML_REGEXP_NUMBER_OTHERS:
  ------------------
  |  Branch (2859:9): [True: 0, False: 10]
  ------------------
 2860|      0|	    ret = xmlUCSIsCatNo(codepoint);
 2861|      0|	    break;
 2862|      0|        case XML_REGEXP_PUNCT:
  ------------------
  |  Branch (2862:9): [True: 0, False: 10]
  ------------------
 2863|      0|	    ret = xmlUCSIsCatP(codepoint);
 2864|      0|	    break;
 2865|      0|        case XML_REGEXP_PUNCT_CONNECTOR:
  ------------------
  |  Branch (2865:9): [True: 0, False: 10]
  ------------------
 2866|      0|	    ret = xmlUCSIsCatPc(codepoint);
 2867|      0|	    break;
 2868|      0|        case XML_REGEXP_PUNCT_DASH:
  ------------------
  |  Branch (2868:9): [True: 0, False: 10]
  ------------------
 2869|      0|	    ret = xmlUCSIsCatPd(codepoint);
 2870|      0|	    break;
 2871|      0|        case XML_REGEXP_PUNCT_OPEN:
  ------------------
  |  Branch (2871:9): [True: 0, False: 10]
  ------------------
 2872|      0|	    ret = xmlUCSIsCatPs(codepoint);
 2873|      0|	    break;
 2874|      0|        case XML_REGEXP_PUNCT_CLOSE:
  ------------------
  |  Branch (2874:9): [True: 0, False: 10]
  ------------------
 2875|      0|	    ret = xmlUCSIsCatPe(codepoint);
 2876|      0|	    break;
 2877|      0|        case XML_REGEXP_PUNCT_INITQUOTE:
  ------------------
  |  Branch (2877:9): [True: 0, False: 10]
  ------------------
 2878|      0|	    ret = xmlUCSIsCatPi(codepoint);
 2879|      0|	    break;
 2880|      0|        case XML_REGEXP_PUNCT_FINQUOTE:
  ------------------
  |  Branch (2880:9): [True: 0, False: 10]
  ------------------
 2881|      0|	    ret = xmlUCSIsCatPf(codepoint);
 2882|      0|	    break;
 2883|      0|        case XML_REGEXP_PUNCT_OTHERS:
  ------------------
  |  Branch (2883:9): [True: 0, False: 10]
  ------------------
 2884|      0|	    ret = xmlUCSIsCatPo(codepoint);
 2885|      0|	    break;
 2886|      0|        case XML_REGEXP_SEPAR:
  ------------------
  |  Branch (2886:9): [True: 0, False: 10]
  ------------------
 2887|      0|	    ret = xmlUCSIsCatZ(codepoint);
 2888|      0|	    break;
 2889|      0|        case XML_REGEXP_SEPAR_SPACE:
  ------------------
  |  Branch (2889:9): [True: 0, False: 10]
  ------------------
 2890|      0|	    ret = xmlUCSIsCatZs(codepoint);
 2891|      0|	    break;
 2892|      0|        case XML_REGEXP_SEPAR_LINE:
  ------------------
  |  Branch (2892:9): [True: 0, False: 10]
  ------------------
 2893|      0|	    ret = xmlUCSIsCatZl(codepoint);
 2894|      0|	    break;
 2895|      0|        case XML_REGEXP_SEPAR_PARA:
  ------------------
  |  Branch (2895:9): [True: 0, False: 10]
  ------------------
 2896|      0|	    ret = xmlUCSIsCatZp(codepoint);
 2897|      0|	    break;
 2898|      0|        case XML_REGEXP_SYMBOL:
  ------------------
  |  Branch (2898:9): [True: 0, False: 10]
  ------------------
 2899|      0|	    ret = xmlUCSIsCatS(codepoint);
 2900|      0|	    break;
 2901|      0|        case XML_REGEXP_SYMBOL_MATH:
  ------------------
  |  Branch (2901:9): [True: 0, False: 10]
  ------------------
 2902|      0|	    ret = xmlUCSIsCatSm(codepoint);
 2903|      0|	    break;
 2904|      0|        case XML_REGEXP_SYMBOL_CURRENCY:
  ------------------
  |  Branch (2904:9): [True: 0, False: 10]
  ------------------
 2905|      0|	    ret = xmlUCSIsCatSc(codepoint);
 2906|      0|	    break;
 2907|      0|        case XML_REGEXP_SYMBOL_MODIFIER:
  ------------------
  |  Branch (2907:9): [True: 0, False: 10]
  ------------------
 2908|      0|	    ret = xmlUCSIsCatSk(codepoint);
 2909|      0|	    break;
 2910|      0|        case XML_REGEXP_SYMBOL_OTHERS:
  ------------------
  |  Branch (2910:9): [True: 0, False: 10]
  ------------------
 2911|      0|	    ret = xmlUCSIsCatSo(codepoint);
 2912|      0|	    break;
 2913|      0|        case XML_REGEXP_OTHER:
  ------------------
  |  Branch (2913:9): [True: 0, False: 10]
  ------------------
 2914|      0|	    ret = xmlUCSIsCatC(codepoint);
 2915|      0|	    break;
 2916|      0|        case XML_REGEXP_OTHER_CONTROL:
  ------------------
  |  Branch (2916:9): [True: 0, False: 10]
  ------------------
 2917|      0|	    ret = xmlUCSIsCatCc(codepoint);
 2918|      0|	    break;
 2919|      0|        case XML_REGEXP_OTHER_FORMAT:
  ------------------
  |  Branch (2919:9): [True: 0, False: 10]
  ------------------
 2920|      0|	    ret = xmlUCSIsCatCf(codepoint);
 2921|      0|	    break;
 2922|      0|        case XML_REGEXP_OTHER_PRIVATE:
  ------------------
  |  Branch (2922:9): [True: 0, False: 10]
  ------------------
 2923|      0|	    ret = xmlUCSIsCatCo(codepoint);
 2924|      0|	    break;
 2925|      0|        case XML_REGEXP_OTHER_NA:
  ------------------
  |  Branch (2925:9): [True: 0, False: 10]
  ------------------
 2926|       |	    /* ret = xmlUCSIsCatCn(codepoint); */
 2927|       |	    /* Seems it doesn't exist anymore in recent Unicode releases */
 2928|      0|	    ret = 0;
 2929|      0|	    break;
 2930|      0|        case XML_REGEXP_BLOCK_NAME:
  ------------------
  |  Branch (2930:9): [True: 0, False: 10]
  ------------------
 2931|      0|	    ret = xmlUCSIsBlock(codepoint, (const char *) blockName);
 2932|      0|	    break;
 2933|     10|    }
 2934|     10|    if (neg)
  ------------------
  |  Branch (2934:9): [True: 0, False: 10]
  ------------------
 2935|      0|	return(!ret);
 2936|     10|    return(ret);
 2937|     10|}
xmlregexp.c:xmlRegFreeState:
  906|  1.50k|xmlRegFreeState(xmlRegStatePtr state) {
  907|  1.50k|    if (state == NULL)
  ------------------
  |  Branch (907:9): [True: 214, False: 1.28k]
  ------------------
  908|    214|	return;
  909|       |
  910|  1.28k|    if (state->trans != NULL)
  ------------------
  |  Branch (910:9): [True: 894, False: 394]
  ------------------
  911|    894|	xmlFree(state->trans);
  912|  1.28k|    if (state->transTo != NULL)
  ------------------
  |  Branch (912:9): [True: 857, False: 431]
  ------------------
  913|    857|	xmlFree(state->transTo);
  914|  1.28k|    xmlFree(state);
  915|  1.28k|}
xmlregexp.c:xmlFAComputesDeterminism:
 2610|    218|xmlFAComputesDeterminism(xmlRegParserCtxtPtr ctxt) {
 2611|    218|    int statenr, transnr;
 2612|    218|    xmlRegStatePtr state;
 2613|    218|    xmlRegTransPtr t1, t2, last;
 2614|    218|    int i;
 2615|    218|    int ret = 1;
 2616|    218|    int deep = 1;
 2617|       |
 2618|    218|    if (ctxt->determinist != -1)
  ------------------
  |  Branch (2618:9): [True: 0, False: 218]
  ------------------
 2619|      0|	return(ctxt->determinist);
 2620|       |
 2621|    218|    if (ctxt->flags & AM_AUTOMATA_RNG)
  ------------------
  |  |  243|    218|#define AM_AUTOMATA_RNG 1
  ------------------
  |  Branch (2621:9): [True: 0, False: 218]
  ------------------
 2622|      0|        deep = 0;
 2623|       |
 2624|       |    /*
 2625|       |     * First cleanup the automata removing cancelled transitions
 2626|       |     */
 2627|  1.28k|    for (statenr = 0;statenr < ctxt->nbStates;statenr++) {
  ------------------
  |  Branch (2627:22): [True: 1.07k, False: 218]
  ------------------
 2628|  1.07k|	state = ctxt->states[statenr];
 2629|  1.07k|	if (state == NULL)
  ------------------
  |  Branch (2629:6): [True: 214, False: 856]
  ------------------
 2630|    214|	    continue;
 2631|    856|	if (state->nbTrans < 2)
  ------------------
  |  Branch (2631:6): [True: 536, False: 320]
  ------------------
 2632|    536|	    continue;
 2633|  1.88k|	for (transnr = 0;transnr < state->nbTrans;transnr++) {
  ------------------
  |  Branch (2633:19): [True: 1.56k, False: 320]
  ------------------
 2634|  1.56k|	    t1 = &(state->trans[transnr]);
 2635|       |	    /*
 2636|       |	     * Determinism checks in case of counted or all transitions
 2637|       |	     * will have to be handled separately
 2638|       |	     */
 2639|  1.56k|	    if (t1->atom == NULL) {
  ------------------
  |  Branch (2639:10): [True: 452, False: 1.11k]
  ------------------
 2640|       |		/* t1->nd = 1; */
 2641|    452|		continue;
 2642|    452|	    }
 2643|  1.11k|	    if (t1->to < 0) /* eliminated */
  ------------------
  |  Branch (2643:10): [True: 42, False: 1.07k]
  ------------------
 2644|     42|		continue;
 2645|  6.00k|	    for (i = 0;i < transnr;i++) {
  ------------------
  |  Branch (2645:17): [True: 4.93k, False: 1.07k]
  ------------------
 2646|  4.93k|		t2 = &(state->trans[i]);
 2647|  4.93k|		if (t2->to < 0) /* eliminated */
  ------------------
  |  Branch (2647:7): [True: 1.45k, False: 3.48k]
  ------------------
 2648|  1.45k|		    continue;
 2649|  3.48k|		if (t2->atom != NULL) {
  ------------------
  |  Branch (2649:7): [True: 3.34k, False: 138]
  ------------------
 2650|  3.34k|		    if (t1->to == t2->to) {
  ------------------
  |  Branch (2650:11): [True: 535, False: 2.81k]
  ------------------
 2651|       |                        /*
 2652|       |                         * Here we use deep because we want to keep the
 2653|       |                         * transitions which indicate a conflict
 2654|       |                         */
 2655|    535|			if (xmlFAEqualAtoms(t1->atom, t2->atom, deep) &&
  ------------------
  |  Branch (2655:8): [True: 73, False: 462]
  ------------------
 2656|    535|                            (t1->counter == t2->counter) &&
  ------------------
  |  Branch (2656:29): [True: 61, False: 12]
  ------------------
 2657|    535|                            (t1->count == t2->count))
  ------------------
  |  Branch (2657:29): [True: 61, False: 0]
  ------------------
 2658|     61|			    t2->to = -1; /* eliminated */
 2659|    535|		    }
 2660|  3.34k|		}
 2661|  3.48k|	    }
 2662|  1.07k|	}
 2663|    320|    }
 2664|       |
 2665|       |    /*
 2666|       |     * Check for all states that there aren't 2 transitions
 2667|       |     * with the same atom and a different target.
 2668|       |     */
 2669|  1.28k|    for (statenr = 0;statenr < ctxt->nbStates;statenr++) {
  ------------------
  |  Branch (2669:22): [True: 1.07k, False: 218]
  ------------------
 2670|  1.07k|	state = ctxt->states[statenr];
 2671|  1.07k|	if (state == NULL)
  ------------------
  |  Branch (2671:6): [True: 214, False: 856]
  ------------------
 2672|    214|	    continue;
 2673|    856|	if (state->nbTrans < 2)
  ------------------
  |  Branch (2673:6): [True: 536, False: 320]
  ------------------
 2674|    536|	    continue;
 2675|    320|	last = NULL;
 2676|  1.88k|	for (transnr = 0;transnr < state->nbTrans;transnr++) {
  ------------------
  |  Branch (2676:19): [True: 1.56k, False: 320]
  ------------------
 2677|  1.56k|	    t1 = &(state->trans[transnr]);
 2678|       |	    /*
 2679|       |	     * Determinism checks in case of counted or all transitions
 2680|       |	     * will have to be handled separately
 2681|       |	     */
 2682|  1.56k|	    if (t1->atom == NULL) {
  ------------------
  |  Branch (2682:10): [True: 452, False: 1.11k]
  ------------------
 2683|    452|		continue;
 2684|    452|	    }
 2685|  1.11k|	    if (t1->to < 0) /* eliminated */
  ------------------
  |  Branch (2685:10): [True: 103, False: 1.01k]
  ------------------
 2686|    103|		continue;
 2687|  5.85k|	    for (i = 0;i < transnr;i++) {
  ------------------
  |  Branch (2687:17): [True: 4.84k, False: 1.01k]
  ------------------
 2688|  4.84k|		t2 = &(state->trans[i]);
 2689|  4.84k|		if (t2->to < 0) /* eliminated */
  ------------------
  |  Branch (2689:7): [True: 1.47k, False: 3.36k]
  ------------------
 2690|  1.47k|		    continue;
 2691|  3.36k|		if (t2->atom != NULL) {
  ------------------
  |  Branch (2691:7): [True: 3.22k, False: 137]
  ------------------
 2692|       |                    /*
 2693|       |                     * But here we don't use deep because we want to
 2694|       |                     * find transitions which indicate a conflict
 2695|       |                     */
 2696|  3.22k|		    if (xmlFACompareAtoms(t1->atom, t2->atom, 1)) {
  ------------------
  |  Branch (2696:11): [True: 57, False: 3.17k]
  ------------------
 2697|       |                        /*
 2698|       |                         * Treat equal counter transitions that couldn't be
 2699|       |                         * eliminated as deterministic.
 2700|       |                         */
 2701|     57|                        if ((t1->to != t2->to) ||
  ------------------
  |  Branch (2701:29): [True: 45, False: 12]
  ------------------
 2702|     57|                            (t1->counter == t2->counter) ||
  ------------------
  |  Branch (2702:29): [True: 0, False: 12]
  ------------------
 2703|     57|                            (!xmlFAEqualAtoms(t1->atom, t2->atom, deep)))
  ------------------
  |  Branch (2703:29): [True: 0, False: 12]
  ------------------
 2704|     45|                            ret = 0;
 2705|       |			/* mark the transitions as non-deterministic ones */
 2706|     57|			t1->nd = 1;
 2707|     57|			t2->nd = 1;
 2708|     57|			last = t1;
 2709|     57|		    }
 2710|  3.22k|		} else {
 2711|    137|                    int res;
 2712|       |
 2713|       |		    /*
 2714|       |		     * do the closure in case of remaining specific
 2715|       |		     * epsilon transitions like choices or all
 2716|       |		     */
 2717|    137|		    res = xmlFARecurseDeterminism(ctxt, ctxt->states[t2->to],
 2718|    137|						  statenr, t1->to, t1->atom);
 2719|    137|                    xmlFAFinishRecurseDeterminism(ctxt, ctxt->states[t2->to]);
 2720|       |		    /* don't shortcut the computation so all non deterministic
 2721|       |		       transition get marked down
 2722|       |		    if (ret == 0)
 2723|       |			return(0);
 2724|       |		     */
 2725|    137|		    if (res == 0) {
  ------------------
  |  Branch (2725:11): [True: 0, False: 137]
  ------------------
 2726|      0|			t1->nd = 1;
 2727|       |			/* t2->nd = 1; */
 2728|      0|			last = t1;
 2729|      0|                        ret = 0;
 2730|      0|		    }
 2731|    137|		}
 2732|  3.36k|	    }
 2733|       |	    /* don't shortcut the computation so all non deterministic
 2734|       |	       transition get marked down
 2735|       |	    if (ret == 0)
 2736|       |		break; */
 2737|  1.01k|	}
 2738|       |
 2739|       |	/*
 2740|       |	 * mark specifically the last non-deterministic transition
 2741|       |	 * from a state since there is no need to set-up rollback
 2742|       |	 * from it
 2743|       |	 */
 2744|    320|	if (last != NULL) {
  ------------------
  |  Branch (2744:6): [True: 11, False: 309]
  ------------------
 2745|     11|	    last->nd = 2;
 2746|     11|	}
 2747|       |
 2748|       |	/* don't shortcut the computation so all non deterministic
 2749|       |	   transition get marked down
 2750|       |	if (ret == 0)
 2751|       |	    break; */
 2752|    320|    }
 2753|       |
 2754|    218|    ctxt->determinist = ret;
 2755|    218|    return(ret);
 2756|    218|}
xmlregexp.c:xmlFAEqualAtoms:
 2386|    547|xmlFAEqualAtoms(xmlRegAtomPtr atom1, xmlRegAtomPtr atom2, int deep) {
 2387|    547|    int ret = 0;
 2388|       |
 2389|    547|    if (atom1 == atom2)
  ------------------
  |  Branch (2389:9): [True: 20, False: 527]
  ------------------
 2390|     20|	return(1);
 2391|    527|    if ((atom1 == NULL) || (atom2 == NULL))
  ------------------
  |  Branch (2391:9): [True: 0, False: 527]
  |  Branch (2391:28): [True: 0, False: 527]
  ------------------
 2392|      0|	return(0);
 2393|       |
 2394|    527|    if (atom1->type != atom2->type)
  ------------------
  |  Branch (2394:9): [True: 0, False: 527]
  ------------------
 2395|      0|        return(0);
 2396|    527|    switch (atom1->type) {
 2397|      0|        case XML_REGEXP_EPSILON:
  ------------------
  |  Branch (2397:9): [True: 0, False: 527]
  ------------------
 2398|      0|	    ret = 0;
 2399|      0|	    break;
 2400|    527|        case XML_REGEXP_STRING:
  ------------------
  |  Branch (2400:9): [True: 527, False: 0]
  ------------------
 2401|    527|            if (!deep)
  ------------------
  |  Branch (2401:17): [True: 0, False: 527]
  ------------------
 2402|      0|                ret = (atom1->valuep == atom2->valuep);
 2403|    527|            else
 2404|    527|                ret = xmlStrEqual((xmlChar *)atom1->valuep,
 2405|    527|                                  (xmlChar *)atom2->valuep);
 2406|    527|	    break;
 2407|      0|        case XML_REGEXP_CHARVAL:
  ------------------
  |  Branch (2407:9): [True: 0, False: 527]
  ------------------
 2408|      0|	    ret = (atom1->codepoint == atom2->codepoint);
 2409|      0|	    break;
 2410|      0|	case XML_REGEXP_RANGES:
  ------------------
  |  Branch (2410:2): [True: 0, False: 527]
  ------------------
 2411|       |	    /* too hard to do in the general case */
 2412|      0|	    ret = 0;
 2413|      0|	default:
  ------------------
  |  Branch (2413:2): [True: 0, False: 527]
  ------------------
 2414|      0|	    break;
 2415|    527|    }
 2416|    527|    return(ret);
 2417|    527|}
xmlregexp.c:xmlFACompareAtoms:
 2431|  3.24k|xmlFACompareAtoms(xmlRegAtomPtr atom1, xmlRegAtomPtr atom2, int deep) {
 2432|  3.24k|    int ret = 1;
 2433|       |
 2434|  3.24k|    if (atom1 == atom2)
  ------------------
  |  Branch (2434:9): [True: 10, False: 3.23k]
  ------------------
 2435|     10|	return(1);
 2436|  3.23k|    if ((atom1 == NULL) || (atom2 == NULL))
  ------------------
  |  Branch (2436:9): [True: 0, False: 3.23k]
  |  Branch (2436:28): [True: 0, False: 3.23k]
  ------------------
 2437|      0|	return(0);
 2438|       |
 2439|  3.23k|    if ((atom1->type == XML_REGEXP_ANYCHAR) ||
  ------------------
  |  Branch (2439:9): [True: 0, False: 3.23k]
  ------------------
 2440|  3.23k|        (atom2->type == XML_REGEXP_ANYCHAR))
  ------------------
  |  Branch (2440:9): [True: 0, False: 3.23k]
  ------------------
 2441|      0|	return(1);
 2442|       |
 2443|  3.23k|    if (atom1->type > atom2->type) {
  ------------------
  |  Branch (2443:9): [True: 4, False: 3.23k]
  ------------------
 2444|      4|	xmlRegAtomPtr tmp;
 2445|      4|	tmp = atom1;
 2446|      4|	atom1 = atom2;
 2447|      4|	atom2 = tmp;
 2448|      4|    }
 2449|  3.23k|    if (atom1->type != atom2->type) {
  ------------------
  |  Branch (2449:9): [True: 10, False: 3.22k]
  ------------------
 2450|     10|        ret = xmlFACompareAtomTypes(atom1->type, atom2->type);
 2451|       |	/* if they can't intersect at the type level break now */
 2452|     10|	if (ret == 0)
  ------------------
  |  Branch (2452:6): [True: 0, False: 10]
  ------------------
 2453|      0|	    return(0);
 2454|     10|    }
 2455|  3.23k|    switch (atom1->type) {
 2456|  3.15k|        case XML_REGEXP_STRING:
  ------------------
  |  Branch (2456:9): [True: 3.15k, False: 89]
  ------------------
 2457|  3.15k|            if (!deep)
  ------------------
  |  Branch (2457:17): [True: 0, False: 3.15k]
  ------------------
 2458|      0|                ret = (atom1->valuep != atom2->valuep);
 2459|  3.15k|            else {
 2460|  3.15k|                xmlChar *val1 = (xmlChar *)atom1->valuep;
 2461|  3.15k|                xmlChar *val2 = (xmlChar *)atom2->valuep;
 2462|  3.15k|                int compound1 = (xmlStrchr(val1, '|') != NULL);
 2463|  3.15k|                int compound2 = (xmlStrchr(val2, '|') != NULL);
 2464|       |
 2465|       |                /* Ignore negative match flag for ##other namespaces */
 2466|  3.15k|                if (compound1 != compound2)
  ------------------
  |  Branch (2466:21): [True: 17, False: 3.13k]
  ------------------
 2467|     17|                    return(0);
 2468|       |
 2469|  3.13k|                ret = xmlRegStrEqualWildcard(val1, val2);
 2470|  3.13k|            }
 2471|  3.13k|	    break;
 2472|  3.13k|        case XML_REGEXP_EPSILON:
  ------------------
  |  Branch (2472:9): [True: 0, False: 3.23k]
  ------------------
 2473|      0|	    goto not_determinist;
 2474|     87|        case XML_REGEXP_CHARVAL:
  ------------------
  |  Branch (2474:9): [True: 87, False: 3.15k]
  ------------------
 2475|     87|	    if (atom2->type == XML_REGEXP_CHARVAL) {
  ------------------
  |  Branch (2475:10): [True: 77, False: 10]
  ------------------
 2476|     77|		ret = (atom1->codepoint == atom2->codepoint);
 2477|     77|	    } else {
 2478|     10|	        ret = xmlRegCheckCharacter(atom2, atom1->codepoint);
 2479|     10|		if (ret < 0)
  ------------------
  |  Branch (2479:7): [True: 0, False: 10]
  ------------------
 2480|      0|		    ret = 1;
 2481|     10|	    }
 2482|     87|	    break;
 2483|      0|        case XML_REGEXP_RANGES:
  ------------------
  |  Branch (2483:9): [True: 0, False: 3.23k]
  ------------------
 2484|      0|	    if (atom2->type == XML_REGEXP_RANGES) {
  ------------------
  |  Branch (2484:10): [True: 0, False: 0]
  ------------------
 2485|      0|	        int i, j, res;
 2486|      0|		xmlRegRangePtr r1, r2;
 2487|       |
 2488|       |		/*
 2489|       |		 * need to check that none of the ranges eventually matches
 2490|       |		 */
 2491|      0|		for (i = 0;i < atom1->nbRanges;i++) {
  ------------------
  |  Branch (2491:14): [True: 0, False: 0]
  ------------------
 2492|      0|		    for (j = 0;j < atom2->nbRanges;j++) {
  ------------------
  |  Branch (2492:18): [True: 0, False: 0]
  ------------------
 2493|      0|			r1 = atom1->ranges[i];
 2494|      0|			r2 = atom2->ranges[j];
 2495|      0|			res = xmlFACompareRanges(r1, r2);
 2496|      0|			if (res == 1) {
  ------------------
  |  Branch (2496:8): [True: 0, False: 0]
  ------------------
 2497|      0|			    ret = 1;
 2498|      0|			    goto done;
 2499|      0|			}
 2500|      0|		    }
 2501|      0|		}
 2502|      0|		ret = 0;
 2503|      0|	    }
 2504|      0|	    break;
 2505|      2|	default:
  ------------------
  |  Branch (2505:2): [True: 2, False: 3.23k]
  ------------------
 2506|      2|	    goto not_determinist;
 2507|  3.23k|    }
 2508|  3.22k|done:
 2509|  3.22k|    if (atom1->neg != atom2->neg) {
  ------------------
  |  Branch (2509:9): [True: 5, False: 3.21k]
  ------------------
 2510|      5|        ret = !ret;
 2511|      5|    }
 2512|  3.22k|    if (ret == 0)
  ------------------
  |  Branch (2512:9): [True: 3.17k, False: 45]
  ------------------
 2513|  3.17k|        return(0);
 2514|     47|not_determinist:
 2515|     47|    return(1);
 2516|  3.22k|}
xmlregexp.c:xmlFACompareAtomTypes:
 2184|     10|xmlFACompareAtomTypes(xmlRegAtomType type1, xmlRegAtomType type2) {
 2185|     10|    if ((type1 == XML_REGEXP_EPSILON) ||
  ------------------
  |  Branch (2185:9): [True: 0, False: 10]
  ------------------
 2186|     10|        (type1 == XML_REGEXP_CHARVAL) ||
  ------------------
  |  Branch (2186:9): [True: 10, False: 0]
  ------------------
 2187|     10|	(type1 == XML_REGEXP_RANGES) ||
  ------------------
  |  Branch (2187:2): [True: 0, False: 0]
  ------------------
 2188|     10|	(type1 == XML_REGEXP_SUBREG) ||
  ------------------
  |  Branch (2188:2): [True: 0, False: 0]
  ------------------
 2189|     10|	(type1 == XML_REGEXP_STRING) ||
  ------------------
  |  Branch (2189:2): [True: 0, False: 0]
  ------------------
 2190|     10|	(type1 == XML_REGEXP_ANYCHAR))
  ------------------
  |  Branch (2190:2): [True: 0, False: 0]
  ------------------
 2191|     10|	return(1);
 2192|      0|    if ((type2 == XML_REGEXP_EPSILON) ||
  ------------------
  |  Branch (2192:9): [True: 0, False: 0]
  ------------------
 2193|      0|        (type2 == XML_REGEXP_CHARVAL) ||
  ------------------
  |  Branch (2193:9): [True: 0, False: 0]
  ------------------
 2194|      0|	(type2 == XML_REGEXP_RANGES) ||
  ------------------
  |  Branch (2194:2): [True: 0, False: 0]
  ------------------
 2195|      0|	(type2 == XML_REGEXP_SUBREG) ||
  ------------------
  |  Branch (2195:2): [True: 0, False: 0]
  ------------------
 2196|      0|	(type2 == XML_REGEXP_STRING) ||
  ------------------
  |  Branch (2196:2): [True: 0, False: 0]
  ------------------
 2197|      0|	(type2 == XML_REGEXP_ANYCHAR))
  ------------------
  |  Branch (2197:2): [True: 0, False: 0]
  ------------------
 2198|      0|	return(1);
 2199|       |
 2200|      0|    if (type1 == type2) return(1);
  ------------------
  |  Branch (2200:9): [True: 0, False: 0]
  ------------------
 2201|       |
 2202|       |    /* simplify subsequent compares by making sure type1 < type2 */
 2203|      0|    if (type1 > type2) {
  ------------------
  |  Branch (2203:9): [True: 0, False: 0]
  ------------------
 2204|      0|        xmlRegAtomType tmp = type1;
 2205|      0|	type1 = type2;
 2206|      0|	type2 = tmp;
 2207|      0|    }
 2208|      0|    switch (type1) {
 2209|      0|        case XML_REGEXP_ANYSPACE: /* \s */
  ------------------
  |  Branch (2209:9): [True: 0, False: 0]
  ------------------
 2210|       |	    /* can't be a letter, number, mark, punctuation, symbol */
 2211|      0|	    if ((type2 == XML_REGEXP_NOTSPACE) ||
  ------------------
  |  Branch (2211:10): [True: 0, False: 0]
  ------------------
 2212|      0|		((type2 >= XML_REGEXP_LETTER) &&
  ------------------
  |  Branch (2212:4): [True: 0, False: 0]
  ------------------
 2213|      0|		 (type2 <= XML_REGEXP_LETTER_OTHERS)) ||
  ------------------
  |  Branch (2213:4): [True: 0, False: 0]
  ------------------
 2214|      0|	        ((type2 >= XML_REGEXP_NUMBER) &&
  ------------------
  |  Branch (2214:11): [True: 0, False: 0]
  ------------------
 2215|      0|		 (type2 <= XML_REGEXP_NUMBER_OTHERS)) ||
  ------------------
  |  Branch (2215:4): [True: 0, False: 0]
  ------------------
 2216|      0|	        ((type2 >= XML_REGEXP_MARK) &&
  ------------------
  |  Branch (2216:11): [True: 0, False: 0]
  ------------------
 2217|      0|		 (type2 <= XML_REGEXP_MARK_ENCLOSING)) ||
  ------------------
  |  Branch (2217:4): [True: 0, False: 0]
  ------------------
 2218|      0|	        ((type2 >= XML_REGEXP_PUNCT) &&
  ------------------
  |  Branch (2218:11): [True: 0, False: 0]
  ------------------
 2219|      0|		 (type2 <= XML_REGEXP_PUNCT_OTHERS)) ||
  ------------------
  |  Branch (2219:4): [True: 0, False: 0]
  ------------------
 2220|      0|	        ((type2 >= XML_REGEXP_SYMBOL) &&
  ------------------
  |  Branch (2220:11): [True: 0, False: 0]
  ------------------
 2221|      0|		 (type2 <= XML_REGEXP_SYMBOL_OTHERS))
  ------------------
  |  Branch (2221:4): [True: 0, False: 0]
  ------------------
 2222|      0|	        ) return(0);
 2223|      0|	    break;
 2224|      0|        case XML_REGEXP_NOTSPACE: /* \S */
  ------------------
  |  Branch (2224:9): [True: 0, False: 0]
  ------------------
 2225|      0|	    break;
 2226|      0|        case XML_REGEXP_INITNAME: /* \l */
  ------------------
  |  Branch (2226:9): [True: 0, False: 0]
  ------------------
 2227|       |	    /* can't be a number, mark, separator, punctuation, symbol or other */
 2228|      0|	    if ((type2 == XML_REGEXP_NOTINITNAME) ||
  ------------------
  |  Branch (2228:10): [True: 0, False: 0]
  ------------------
 2229|      0|	        ((type2 >= XML_REGEXP_NUMBER) &&
  ------------------
  |  Branch (2229:11): [True: 0, False: 0]
  ------------------
 2230|      0|		 (type2 <= XML_REGEXP_NUMBER_OTHERS)) ||
  ------------------
  |  Branch (2230:4): [True: 0, False: 0]
  ------------------
 2231|      0|	        ((type2 >= XML_REGEXP_MARK) &&
  ------------------
  |  Branch (2231:11): [True: 0, False: 0]
  ------------------
 2232|      0|		 (type2 <= XML_REGEXP_MARK_ENCLOSING)) ||
  ------------------
  |  Branch (2232:4): [True: 0, False: 0]
  ------------------
 2233|      0|	        ((type2 >= XML_REGEXP_SEPAR) &&
  ------------------
  |  Branch (2233:11): [True: 0, False: 0]
  ------------------
 2234|      0|		 (type2 <= XML_REGEXP_SEPAR_PARA)) ||
  ------------------
  |  Branch (2234:4): [True: 0, False: 0]
  ------------------
 2235|      0|	        ((type2 >= XML_REGEXP_PUNCT) &&
  ------------------
  |  Branch (2235:11): [True: 0, False: 0]
  ------------------
 2236|      0|		 (type2 <= XML_REGEXP_PUNCT_OTHERS)) ||
  ------------------
  |  Branch (2236:4): [True: 0, False: 0]
  ------------------
 2237|      0|	        ((type2 >= XML_REGEXP_SYMBOL) &&
  ------------------
  |  Branch (2237:11): [True: 0, False: 0]
  ------------------
 2238|      0|		 (type2 <= XML_REGEXP_SYMBOL_OTHERS)) ||
  ------------------
  |  Branch (2238:4): [True: 0, False: 0]
  ------------------
 2239|      0|	        ((type2 >= XML_REGEXP_OTHER) &&
  ------------------
  |  Branch (2239:11): [True: 0, False: 0]
  ------------------
 2240|      0|		 (type2 <= XML_REGEXP_OTHER_NA))
  ------------------
  |  Branch (2240:4): [True: 0, False: 0]
  ------------------
 2241|      0|		) return(0);
 2242|      0|	    break;
 2243|      0|        case XML_REGEXP_NOTINITNAME: /* \L */
  ------------------
  |  Branch (2243:9): [True: 0, False: 0]
  ------------------
 2244|      0|	    break;
 2245|      0|        case XML_REGEXP_NAMECHAR: /* \c */
  ------------------
  |  Branch (2245:9): [True: 0, False: 0]
  ------------------
 2246|       |	    /* can't be a mark, separator, punctuation, symbol or other */
 2247|      0|	    if ((type2 == XML_REGEXP_NOTNAMECHAR) ||
  ------------------
  |  Branch (2247:10): [True: 0, False: 0]
  ------------------
 2248|      0|	        ((type2 >= XML_REGEXP_MARK) &&
  ------------------
  |  Branch (2248:11): [True: 0, False: 0]
  ------------------
 2249|      0|		 (type2 <= XML_REGEXP_MARK_ENCLOSING)) ||
  ------------------
  |  Branch (2249:4): [True: 0, False: 0]
  ------------------
 2250|      0|	        ((type2 >= XML_REGEXP_PUNCT) &&
  ------------------
  |  Branch (2250:11): [True: 0, False: 0]
  ------------------
 2251|      0|		 (type2 <= XML_REGEXP_PUNCT_OTHERS)) ||
  ------------------
  |  Branch (2251:4): [True: 0, False: 0]
  ------------------
 2252|      0|	        ((type2 >= XML_REGEXP_SEPAR) &&
  ------------------
  |  Branch (2252:11): [True: 0, False: 0]
  ------------------
 2253|      0|		 (type2 <= XML_REGEXP_SEPAR_PARA)) ||
  ------------------
  |  Branch (2253:4): [True: 0, False: 0]
  ------------------
 2254|      0|	        ((type2 >= XML_REGEXP_SYMBOL) &&
  ------------------
  |  Branch (2254:11): [True: 0, False: 0]
  ------------------
 2255|      0|		 (type2 <= XML_REGEXP_SYMBOL_OTHERS)) ||
  ------------------
  |  Branch (2255:4): [True: 0, False: 0]
  ------------------
 2256|      0|	        ((type2 >= XML_REGEXP_OTHER) &&
  ------------------
  |  Branch (2256:11): [True: 0, False: 0]
  ------------------
 2257|      0|		 (type2 <= XML_REGEXP_OTHER_NA))
  ------------------
  |  Branch (2257:4): [True: 0, False: 0]
  ------------------
 2258|      0|		) return(0);
 2259|      0|	    break;
 2260|      0|        case XML_REGEXP_NOTNAMECHAR: /* \C */
  ------------------
  |  Branch (2260:9): [True: 0, False: 0]
  ------------------
 2261|      0|	    break;
 2262|      0|        case XML_REGEXP_DECIMAL: /* \d */
  ------------------
  |  Branch (2262:9): [True: 0, False: 0]
  ------------------
 2263|       |	    /* can't be a letter, mark, separator, punctuation, symbol or other */
 2264|      0|	    if ((type2 == XML_REGEXP_NOTDECIMAL) ||
  ------------------
  |  Branch (2264:10): [True: 0, False: 0]
  ------------------
 2265|      0|	        (type2 == XML_REGEXP_REALCHAR) ||
  ------------------
  |  Branch (2265:10): [True: 0, False: 0]
  ------------------
 2266|      0|		((type2 >= XML_REGEXP_LETTER) &&
  ------------------
  |  Branch (2266:4): [True: 0, False: 0]
  ------------------
 2267|      0|		 (type2 <= XML_REGEXP_LETTER_OTHERS)) ||
  ------------------
  |  Branch (2267:4): [True: 0, False: 0]
  ------------------
 2268|      0|	        ((type2 >= XML_REGEXP_MARK) &&
  ------------------
  |  Branch (2268:11): [True: 0, False: 0]
  ------------------
 2269|      0|		 (type2 <= XML_REGEXP_MARK_ENCLOSING)) ||
  ------------------
  |  Branch (2269:4): [True: 0, False: 0]
  ------------------
 2270|      0|	        ((type2 >= XML_REGEXP_PUNCT) &&
  ------------------
  |  Branch (2270:11): [True: 0, False: 0]
  ------------------
 2271|      0|		 (type2 <= XML_REGEXP_PUNCT_OTHERS)) ||
  ------------------
  |  Branch (2271:4): [True: 0, False: 0]
  ------------------
 2272|      0|	        ((type2 >= XML_REGEXP_SEPAR) &&
  ------------------
  |  Branch (2272:11): [True: 0, False: 0]
  ------------------
 2273|      0|		 (type2 <= XML_REGEXP_SEPAR_PARA)) ||
  ------------------
  |  Branch (2273:4): [True: 0, False: 0]
  ------------------
 2274|      0|	        ((type2 >= XML_REGEXP_SYMBOL) &&
  ------------------
  |  Branch (2274:11): [True: 0, False: 0]
  ------------------
 2275|      0|		 (type2 <= XML_REGEXP_SYMBOL_OTHERS)) ||
  ------------------
  |  Branch (2275:4): [True: 0, False: 0]
  ------------------
 2276|      0|	        ((type2 >= XML_REGEXP_OTHER) &&
  ------------------
  |  Branch (2276:11): [True: 0, False: 0]
  ------------------
 2277|      0|		 (type2 <= XML_REGEXP_OTHER_NA))
  ------------------
  |  Branch (2277:4): [True: 0, False: 0]
  ------------------
 2278|      0|		)return(0);
 2279|      0|	    break;
 2280|      0|        case XML_REGEXP_NOTDECIMAL: /* \D */
  ------------------
  |  Branch (2280:9): [True: 0, False: 0]
  ------------------
 2281|      0|	    break;
 2282|      0|        case XML_REGEXP_REALCHAR: /* \w */
  ------------------
  |  Branch (2282:9): [True: 0, False: 0]
  ------------------
 2283|       |	    /* can't be a mark, separator, punctuation, symbol or other */
 2284|      0|	    if ((type2 == XML_REGEXP_NOTDECIMAL) ||
  ------------------
  |  Branch (2284:10): [True: 0, False: 0]
  ------------------
 2285|      0|	        ((type2 >= XML_REGEXP_MARK) &&
  ------------------
  |  Branch (2285:11): [True: 0, False: 0]
  ------------------
 2286|      0|		 (type2 <= XML_REGEXP_MARK_ENCLOSING)) ||
  ------------------
  |  Branch (2286:4): [True: 0, False: 0]
  ------------------
 2287|      0|	        ((type2 >= XML_REGEXP_PUNCT) &&
  ------------------
  |  Branch (2287:11): [True: 0, False: 0]
  ------------------
 2288|      0|		 (type2 <= XML_REGEXP_PUNCT_OTHERS)) ||
  ------------------
  |  Branch (2288:4): [True: 0, False: 0]
  ------------------
 2289|      0|	        ((type2 >= XML_REGEXP_SEPAR) &&
  ------------------
  |  Branch (2289:11): [True: 0, False: 0]
  ------------------
 2290|      0|		 (type2 <= XML_REGEXP_SEPAR_PARA)) ||
  ------------------
  |  Branch (2290:4): [True: 0, False: 0]
  ------------------
 2291|      0|	        ((type2 >= XML_REGEXP_SYMBOL) &&
  ------------------
  |  Branch (2291:11): [True: 0, False: 0]
  ------------------
 2292|      0|		 (type2 <= XML_REGEXP_SYMBOL_OTHERS)) ||
  ------------------
  |  Branch (2292:4): [True: 0, False: 0]
  ------------------
 2293|      0|	        ((type2 >= XML_REGEXP_OTHER) &&
  ------------------
  |  Branch (2293:11): [True: 0, False: 0]
  ------------------
 2294|      0|		 (type2 <= XML_REGEXP_OTHER_NA))
  ------------------
  |  Branch (2294:4): [True: 0, False: 0]
  ------------------
 2295|      0|		)return(0);
 2296|      0|	    break;
 2297|      0|        case XML_REGEXP_NOTREALCHAR: /* \W */
  ------------------
  |  Branch (2297:9): [True: 0, False: 0]
  ------------------
 2298|      0|	    break;
 2299|       |	/*
 2300|       |	 * at that point we know both type 1 and type2 are from
 2301|       |	 * character categories are ordered and are different,
 2302|       |	 * it becomes simple because this is a partition
 2303|       |	 */
 2304|      0|        case XML_REGEXP_LETTER:
  ------------------
  |  Branch (2304:9): [True: 0, False: 0]
  ------------------
 2305|      0|	    if (type2 <= XML_REGEXP_LETTER_OTHERS)
  ------------------
  |  Branch (2305:10): [True: 0, False: 0]
  ------------------
 2306|      0|	        return(1);
 2307|      0|	    return(0);
 2308|      0|        case XML_REGEXP_LETTER_UPPERCASE:
  ------------------
  |  Branch (2308:9): [True: 0, False: 0]
  ------------------
 2309|      0|        case XML_REGEXP_LETTER_LOWERCASE:
  ------------------
  |  Branch (2309:9): [True: 0, False: 0]
  ------------------
 2310|      0|        case XML_REGEXP_LETTER_TITLECASE:
  ------------------
  |  Branch (2310:9): [True: 0, False: 0]
  ------------------
 2311|      0|        case XML_REGEXP_LETTER_MODIFIER:
  ------------------
  |  Branch (2311:9): [True: 0, False: 0]
  ------------------
 2312|      0|        case XML_REGEXP_LETTER_OTHERS:
  ------------------
  |  Branch (2312:9): [True: 0, False: 0]
  ------------------
 2313|      0|	    return(0);
 2314|      0|        case XML_REGEXP_MARK:
  ------------------
  |  Branch (2314:9): [True: 0, False: 0]
  ------------------
 2315|      0|	    if (type2 <= XML_REGEXP_MARK_ENCLOSING)
  ------------------
  |  Branch (2315:10): [True: 0, False: 0]
  ------------------
 2316|      0|	        return(1);
 2317|      0|	    return(0);
 2318|      0|        case XML_REGEXP_MARK_NONSPACING:
  ------------------
  |  Branch (2318:9): [True: 0, False: 0]
  ------------------
 2319|      0|        case XML_REGEXP_MARK_SPACECOMBINING:
  ------------------
  |  Branch (2319:9): [True: 0, False: 0]
  ------------------
 2320|      0|        case XML_REGEXP_MARK_ENCLOSING:
  ------------------
  |  Branch (2320:9): [True: 0, False: 0]
  ------------------
 2321|      0|	    return(0);
 2322|      0|        case XML_REGEXP_NUMBER:
  ------------------
  |  Branch (2322:9): [True: 0, False: 0]
  ------------------
 2323|      0|	    if (type2 <= XML_REGEXP_NUMBER_OTHERS)
  ------------------
  |  Branch (2323:10): [True: 0, False: 0]
  ------------------
 2324|      0|	        return(1);
 2325|      0|	    return(0);
 2326|      0|        case XML_REGEXP_NUMBER_DECIMAL:
  ------------------
  |  Branch (2326:9): [True: 0, False: 0]
  ------------------
 2327|      0|        case XML_REGEXP_NUMBER_LETTER:
  ------------------
  |  Branch (2327:9): [True: 0, False: 0]
  ------------------
 2328|      0|        case XML_REGEXP_NUMBER_OTHERS:
  ------------------
  |  Branch (2328:9): [True: 0, False: 0]
  ------------------
 2329|      0|	    return(0);
 2330|      0|        case XML_REGEXP_PUNCT:
  ------------------
  |  Branch (2330:9): [True: 0, False: 0]
  ------------------
 2331|      0|	    if (type2 <= XML_REGEXP_PUNCT_OTHERS)
  ------------------
  |  Branch (2331:10): [True: 0, False: 0]
  ------------------
 2332|      0|	        return(1);
 2333|      0|	    return(0);
 2334|      0|        case XML_REGEXP_PUNCT_CONNECTOR:
  ------------------
  |  Branch (2334:9): [True: 0, False: 0]
  ------------------
 2335|      0|        case XML_REGEXP_PUNCT_DASH:
  ------------------
  |  Branch (2335:9): [True: 0, False: 0]
  ------------------
 2336|      0|        case XML_REGEXP_PUNCT_OPEN:
  ------------------
  |  Branch (2336:9): [True: 0, False: 0]
  ------------------
 2337|      0|        case XML_REGEXP_PUNCT_CLOSE:
  ------------------
  |  Branch (2337:9): [True: 0, False: 0]
  ------------------
 2338|      0|        case XML_REGEXP_PUNCT_INITQUOTE:
  ------------------
  |  Branch (2338:9): [True: 0, False: 0]
  ------------------
 2339|      0|        case XML_REGEXP_PUNCT_FINQUOTE:
  ------------------
  |  Branch (2339:9): [True: 0, False: 0]
  ------------------
 2340|      0|        case XML_REGEXP_PUNCT_OTHERS:
  ------------------
  |  Branch (2340:9): [True: 0, False: 0]
  ------------------
 2341|      0|	    return(0);
 2342|      0|        case XML_REGEXP_SEPAR:
  ------------------
  |  Branch (2342:9): [True: 0, False: 0]
  ------------------
 2343|      0|	    if (type2 <= XML_REGEXP_SEPAR_PARA)
  ------------------
  |  Branch (2343:10): [True: 0, False: 0]
  ------------------
 2344|      0|	        return(1);
 2345|      0|	    return(0);
 2346|      0|        case XML_REGEXP_SEPAR_SPACE:
  ------------------
  |  Branch (2346:9): [True: 0, False: 0]
  ------------------
 2347|      0|        case XML_REGEXP_SEPAR_LINE:
  ------------------
  |  Branch (2347:9): [True: 0, False: 0]
  ------------------
 2348|      0|        case XML_REGEXP_SEPAR_PARA:
  ------------------
  |  Branch (2348:9): [True: 0, False: 0]
  ------------------
 2349|      0|	    return(0);
 2350|      0|        case XML_REGEXP_SYMBOL:
  ------------------
  |  Branch (2350:9): [True: 0, False: 0]
  ------------------
 2351|      0|	    if (type2 <= XML_REGEXP_SYMBOL_OTHERS)
  ------------------
  |  Branch (2351:10): [True: 0, False: 0]
  ------------------
 2352|      0|	        return(1);
 2353|      0|	    return(0);
 2354|      0|        case XML_REGEXP_SYMBOL_MATH:
  ------------------
  |  Branch (2354:9): [True: 0, False: 0]
  ------------------
 2355|      0|        case XML_REGEXP_SYMBOL_CURRENCY:
  ------------------
  |  Branch (2355:9): [True: 0, False: 0]
  ------------------
 2356|      0|        case XML_REGEXP_SYMBOL_MODIFIER:
  ------------------
  |  Branch (2356:9): [True: 0, False: 0]
  ------------------
 2357|      0|        case XML_REGEXP_SYMBOL_OTHERS:
  ------------------
  |  Branch (2357:9): [True: 0, False: 0]
  ------------------
 2358|      0|	    return(0);
 2359|      0|        case XML_REGEXP_OTHER:
  ------------------
  |  Branch (2359:9): [True: 0, False: 0]
  ------------------
 2360|      0|	    if (type2 <= XML_REGEXP_OTHER_NA)
  ------------------
  |  Branch (2360:10): [True: 0, False: 0]
  ------------------
 2361|      0|	        return(1);
 2362|      0|	    return(0);
 2363|      0|        case XML_REGEXP_OTHER_CONTROL:
  ------------------
  |  Branch (2363:9): [True: 0, False: 0]
  ------------------
 2364|      0|        case XML_REGEXP_OTHER_FORMAT:
  ------------------
  |  Branch (2364:9): [True: 0, False: 0]
  ------------------
 2365|      0|        case XML_REGEXP_OTHER_PRIVATE:
  ------------------
  |  Branch (2365:9): [True: 0, False: 0]
  ------------------
 2366|      0|        case XML_REGEXP_OTHER_NA:
  ------------------
  |  Branch (2366:9): [True: 0, False: 0]
  ------------------
 2367|      0|	    return(0);
 2368|      0|	default:
  ------------------
  |  Branch (2368:2): [True: 0, False: 0]
  ------------------
 2369|      0|	    break;
 2370|      0|    }
 2371|      0|    return(1);
 2372|      0|}
xmlregexp.c:xmlFARecurseDeterminism:
 2528|    144|	                int fromnr, int tonr, xmlRegAtomPtr atom) {
 2529|    144|    int ret = 1;
 2530|    144|    int res;
 2531|    144|    int transnr, nbTrans;
 2532|    144|    xmlRegTransPtr t1;
 2533|    144|    int deep = 1;
 2534|       |
 2535|    144|    if (state == NULL)
  ------------------
  |  Branch (2535:9): [True: 0, False: 144]
  ------------------
 2536|      0|	return(ret);
 2537|    144|    if (state->markd == XML_REGEXP_MARK_VISITED)
  ------------------
  |  Branch (2537:9): [True: 0, False: 144]
  ------------------
 2538|      0|	return(ret);
 2539|       |
 2540|    144|    if (ctxt->flags & AM_AUTOMATA_RNG)
  ------------------
  |  |  243|    144|#define AM_AUTOMATA_RNG 1
  ------------------
  |  Branch (2540:9): [True: 0, False: 144]
  ------------------
 2541|      0|        deep = 0;
 2542|       |
 2543|       |    /*
 2544|       |     * don't recurse on transitions potentially added in the course of
 2545|       |     * the elimination.
 2546|       |     */
 2547|    144|    nbTrans = state->nbTrans;
 2548|    208|    for (transnr = 0;transnr < nbTrans;transnr++) {
  ------------------
  |  Branch (2548:22): [True: 64, False: 144]
  ------------------
 2549|     64|	t1 = &(state->trans[transnr]);
 2550|       |	/*
 2551|       |	 * check transitions conflicting with the one looked at
 2552|       |	 */
 2553|     64|        if ((t1->to < 0) || (t1->to == fromnr))
  ------------------
  |  Branch (2553:13): [True: 16, False: 48]
  |  Branch (2553:29): [True: 21, False: 27]
  ------------------
 2554|     37|            continue;
 2555|     27|	if (t1->atom == NULL) {
  ------------------
  |  Branch (2555:6): [True: 7, False: 20]
  ------------------
 2556|      7|	    state->markd = XML_REGEXP_MARK_VISITED;
 2557|      7|	    res = xmlFARecurseDeterminism(ctxt, ctxt->states[t1->to],
 2558|      7|		                          fromnr, tonr, atom);
 2559|      7|	    if (res == 0) {
  ------------------
  |  Branch (2559:10): [True: 0, False: 7]
  ------------------
 2560|      0|	        ret = 0;
 2561|       |		/* t1->nd = 1; */
 2562|      0|	    }
 2563|      7|	    continue;
 2564|      7|	}
 2565|     20|	if (xmlFACompareAtoms(t1->atom, atom, deep)) {
  ------------------
  |  Branch (2565:6): [True: 0, False: 20]
  ------------------
 2566|       |            /* Treat equal transitions as deterministic. */
 2567|      0|            if ((t1->to != tonr) ||
  ------------------
  |  Branch (2567:17): [True: 0, False: 0]
  ------------------
 2568|      0|                (!xmlFAEqualAtoms(t1->atom, atom, deep)))
  ------------------
  |  Branch (2568:17): [True: 0, False: 0]
  ------------------
 2569|      0|                ret = 0;
 2570|       |	    /* mark the transition as non-deterministic */
 2571|      0|	    t1->nd = 1;
 2572|      0|	}
 2573|     20|    }
 2574|    144|    return(ret);
 2575|    144|}
xmlregexp.c:xmlFAFinishRecurseDeterminism:
 2584|    144|xmlFAFinishRecurseDeterminism(xmlRegParserCtxtPtr ctxt, xmlRegStatePtr state) {
 2585|    144|    int transnr, nbTrans;
 2586|       |
 2587|    144|    if (state == NULL)
  ------------------
  |  Branch (2587:9): [True: 0, False: 144]
  ------------------
 2588|      0|	return;
 2589|    144|    if (state->markd != XML_REGEXP_MARK_VISITED)
  ------------------
  |  Branch (2589:9): [True: 137, False: 7]
  ------------------
 2590|    137|	return;
 2591|      7|    state->markd = 0;
 2592|       |
 2593|      7|    nbTrans = state->nbTrans;
 2594|     53|    for (transnr = 0; transnr < nbTrans; transnr++) {
  ------------------
  |  Branch (2594:23): [True: 46, False: 7]
  ------------------
 2595|     46|	xmlRegTransPtr t1 = &state->trans[transnr];
 2596|     46|	if ((t1->atom == NULL) && (t1->to >= 0))
  ------------------
  |  Branch (2596:6): [True: 15, False: 31]
  |  Branch (2596:28): [True: 7, False: 8]
  ------------------
 2597|      7|	    xmlFAFinishRecurseDeterminism(ctxt, ctxt->states[t1->to]);
 2598|     46|    }
 2599|      7|}
xmlregexp.c:xmlRegFreeAtom:
  819|    770|xmlRegFreeAtom(xmlRegAtomPtr atom) {
  820|    770|    int i;
  821|       |
  822|    770|    if (atom == NULL)
  ------------------
  |  Branch (822:9): [True: 0, False: 770]
  ------------------
  823|      0|	return;
  824|       |
  825|    820|    for (i = 0;i < atom->nbRanges;i++)
  ------------------
  |  Branch (825:16): [True: 50, False: 770]
  ------------------
  826|     50|	xmlRegFreeRange(atom->ranges[i]);
  827|    770|    if (atom->ranges != NULL)
  ------------------
  |  Branch (827:9): [True: 24, False: 746]
  ------------------
  828|     24|	xmlFree(atom->ranges);
  829|    770|    if ((atom->type == XML_REGEXP_STRING) && (atom->valuep != NULL))
  ------------------
  |  Branch (829:9): [True: 596, False: 174]
  |  Branch (829:46): [True: 596, False: 0]
  ------------------
  830|    596|	xmlFree(atom->valuep);
  831|    770|    if ((atom->type == XML_REGEXP_STRING) && (atom->valuep2 != NULL))
  ------------------
  |  Branch (831:9): [True: 596, False: 174]
  |  Branch (831:46): [True: 13, False: 583]
  ------------------
  832|     13|	xmlFree(atom->valuep2);
  833|    770|    if ((atom->type == XML_REGEXP_BLOCK_NAME) && (atom->valuep != NULL))
  ------------------
  |  Branch (833:9): [True: 0, False: 770]
  |  Branch (833:50): [True: 0, False: 0]
  ------------------
  834|      0|	xmlFree(atom->valuep);
  835|    770|    xmlFree(atom);
  836|    770|}
xmlregexp.c:xmlRegFreeRange:
  747|     50|xmlRegFreeRange(xmlRegRangePtr range) {
  748|     50|    if (range == NULL)
  ------------------
  |  Branch (748:9): [True: 0, False: 50]
  ------------------
  749|      0|	return;
  750|       |
  751|     50|    if (range->blockName != NULL)
  ------------------
  |  Branch (751:9): [True: 0, False: 50]
  ------------------
  752|      0|	xmlFree(range->blockName);
  753|     50|    xmlFree(range);
  754|     50|}
xmlregexp.c:xmlRegNewAtom:
  796|    770|xmlRegNewAtom(xmlRegParserCtxtPtr ctxt, xmlRegAtomType type) {
  797|    770|    xmlRegAtomPtr ret;
  798|       |
  799|    770|    ret = (xmlRegAtomPtr) xmlMalloc(sizeof(xmlRegAtom));
  800|    770|    if (ret == NULL) {
  ------------------
  |  Branch (800:9): [True: 0, False: 770]
  ------------------
  801|      0|	xmlRegexpErrMemory(ctxt, "allocating atom");
  802|      0|	return(NULL);
  803|      0|    }
  804|    770|    memset(ret, 0, sizeof(xmlRegAtom));
  805|    770|    ret->type = type;
  806|    770|    ret->quant = XML_REGEXP_QUANT_ONCE;
  807|    770|    ret->min = 0;
  808|    770|    ret->max = 0;
  809|    770|    return(ret);
  810|    770|}
xmlregexp.c:xmlFAGenerateTransitions:
 1493|    754|	                 xmlRegStatePtr to, xmlRegAtomPtr atom) {
 1494|    754|    xmlRegStatePtr end;
 1495|    754|    int nullable = 0;
 1496|       |
 1497|    754|    if (atom == NULL) {
  ------------------
  |  Branch (1497:9): [True: 0, False: 754]
  ------------------
 1498|      0|	ERROR("generate transition: atom == NULL");
  ------------------
  |  |   55|      0|    ctxt->error = XML_REGEXP_COMPILE_ERROR;				\
  |  |   56|      0|    xmlRegexpErrCompile(ctxt, str);
  ------------------
 1499|      0|	return(-1);
 1500|      0|    }
 1501|    754|    if (atom->type == XML_REGEXP_SUBREG) {
  ------------------
  |  Branch (1501:9): [True: 13, False: 741]
  ------------------
 1502|       |	/*
 1503|       |	 * this is a subexpression handling one should not need to
 1504|       |	 * create a new node except for XML_REGEXP_QUANT_RANGE.
 1505|       |	 */
 1506|     13|	if ((to != NULL) && (atom->stop != to) &&
  ------------------
  |  Branch (1506:6): [True: 3, False: 10]
  |  Branch (1506:22): [True: 3, False: 0]
  ------------------
 1507|     13|	    (atom->quant != XML_REGEXP_QUANT_RANGE)) {
  ------------------
  |  Branch (1507:6): [True: 3, False: 0]
  ------------------
 1508|       |	    /*
 1509|       |	     * Generate an epsilon transition to link to the target
 1510|       |	     */
 1511|      3|	    xmlFAGenerateEpsilonTransition(ctxt, atom->stop, to);
 1512|       |#ifdef DV
 1513|       |	} else if ((to == NULL) && (atom->quant != XML_REGEXP_QUANT_RANGE) &&
 1514|       |		   (atom->quant != XML_REGEXP_QUANT_ONCE)) {
 1515|       |	    to = xmlRegStatePush(ctxt, to);
 1516|       |            if (to == NULL)
 1517|       |                return(-1);
 1518|       |	    ctxt->state = to;
 1519|       |	    xmlFAGenerateEpsilonTransition(ctxt, atom->stop, to);
 1520|       |#endif
 1521|      3|	}
 1522|     13|	switch (atom->quant) {
 1523|      2|	    case XML_REGEXP_QUANT_OPT:
  ------------------
  |  Branch (1523:6): [True: 2, False: 11]
  ------------------
 1524|      2|		atom->quant = XML_REGEXP_QUANT_ONCE;
 1525|       |		/*
 1526|       |		 * transition done to the state after end of atom.
 1527|       |		 *      1. set transition from atom start to new state
 1528|       |		 *      2. set transition from atom end to this state.
 1529|       |		 */
 1530|      2|                if (to == NULL) {
  ------------------
  |  Branch (1530:21): [True: 1, False: 1]
  ------------------
 1531|      1|                    xmlFAGenerateEpsilonTransition(ctxt, atom->start, 0);
 1532|      1|                    xmlFAGenerateEpsilonTransition(ctxt, atom->stop,
 1533|      1|                                                   ctxt->state);
 1534|      1|                } else {
 1535|      1|                    xmlFAGenerateEpsilonTransition(ctxt, atom->start, to);
 1536|      1|                }
 1537|      2|		break;
 1538|      1|	    case XML_REGEXP_QUANT_MULT:
  ------------------
  |  Branch (1538:6): [True: 1, False: 12]
  ------------------
 1539|      1|		atom->quant = XML_REGEXP_QUANT_ONCE;
 1540|      1|		xmlFAGenerateEpsilonTransition(ctxt, atom->start, atom->stop);
 1541|      1|		xmlFAGenerateEpsilonTransition(ctxt, atom->stop, atom->start);
 1542|      1|		break;
 1543|      0|	    case XML_REGEXP_QUANT_PLUS:
  ------------------
  |  Branch (1543:6): [True: 0, False: 13]
  ------------------
 1544|      0|		atom->quant = XML_REGEXP_QUANT_ONCE;
 1545|      0|		xmlFAGenerateEpsilonTransition(ctxt, atom->stop, atom->start);
 1546|      0|		break;
 1547|      0|	    case XML_REGEXP_QUANT_RANGE: {
  ------------------
  |  Branch (1547:6): [True: 0, False: 13]
  ------------------
 1548|      0|		int counter;
 1549|      0|		xmlRegStatePtr inter, newstate;
 1550|       |
 1551|       |		/*
 1552|       |		 * create the final state now if needed
 1553|       |		 */
 1554|      0|		if (to != NULL) {
  ------------------
  |  Branch (1554:7): [True: 0, False: 0]
  ------------------
 1555|      0|		    newstate = to;
 1556|      0|		} else {
 1557|      0|		    newstate = xmlRegStatePush(ctxt);
 1558|      0|                    if (newstate == NULL)
  ------------------
  |  Branch (1558:25): [True: 0, False: 0]
  ------------------
 1559|      0|                        return(-1);
 1560|      0|		}
 1561|       |
 1562|       |		/*
 1563|       |		 * The principle here is to use counted transition
 1564|       |		 * to avoid explosion in the number of states in the
 1565|       |		 * graph. This is clearly more complex but should not
 1566|       |		 * be exploitable at runtime.
 1567|       |		 */
 1568|      0|		if ((atom->min == 0) && (atom->start0 == NULL)) {
  ------------------
  |  Branch (1568:7): [True: 0, False: 0]
  |  Branch (1568:27): [True: 0, False: 0]
  ------------------
 1569|      0|		    xmlRegAtomPtr copy;
 1570|       |		    /*
 1571|       |		     * duplicate a transition based on atom to count next
 1572|       |		     * occurrences after 1. We cannot loop to atom->start
 1573|       |		     * directly because we need an epsilon transition to
 1574|       |		     * newstate.
 1575|       |		     */
 1576|       |		     /* ???? For some reason it seems we never reach that
 1577|       |		        case, I suppose this got optimized out before when
 1578|       |			building the automata */
 1579|      0|		    copy = xmlRegCopyAtom(ctxt, atom);
 1580|      0|		    if (copy == NULL)
  ------------------
  |  Branch (1580:11): [True: 0, False: 0]
  ------------------
 1581|      0|		        return(-1);
 1582|      0|		    copy->quant = XML_REGEXP_QUANT_ONCE;
 1583|      0|		    copy->min = 0;
 1584|      0|		    copy->max = 0;
 1585|       |
 1586|      0|		    if (xmlFAGenerateTransitions(ctxt, atom->start, NULL, copy)
  ------------------
  |  Branch (1586:11): [True: 0, False: 0]
  ------------------
 1587|      0|		        < 0) {
 1588|      0|                        xmlRegFreeAtom(copy);
 1589|      0|			return(-1);
 1590|      0|                    }
 1591|      0|		    inter = ctxt->state;
 1592|      0|		    counter = xmlRegGetCounter(ctxt);
 1593|      0|                    if (counter < 0)
  ------------------
  |  Branch (1593:25): [True: 0, False: 0]
  ------------------
 1594|      0|                        return(-1);
 1595|      0|		    ctxt->counters[counter].min = atom->min - 1;
 1596|      0|		    ctxt->counters[counter].max = atom->max - 1;
 1597|       |		    /* count the number of times we see it again */
 1598|      0|		    xmlFAGenerateCountedEpsilonTransition(ctxt, inter,
 1599|      0|						   atom->stop, counter);
 1600|       |		    /* allow a way out based on the count */
 1601|      0|		    xmlFAGenerateCountedTransition(ctxt, inter,
 1602|      0|			                           newstate, counter);
 1603|       |		    /* and also allow a direct exit for 0 */
 1604|      0|		    xmlFAGenerateEpsilonTransition(ctxt, atom->start,
 1605|      0|		                                   newstate);
 1606|      0|		} else {
 1607|       |		    /*
 1608|       |		     * either we need the atom at least once or there
 1609|       |		     * is an atom->start0 allowing to easily plug the
 1610|       |		     * epsilon transition.
 1611|       |		     */
 1612|      0|		    counter = xmlRegGetCounter(ctxt);
 1613|      0|                    if (counter < 0)
  ------------------
  |  Branch (1613:25): [True: 0, False: 0]
  ------------------
 1614|      0|                        return(-1);
 1615|      0|		    ctxt->counters[counter].min = atom->min - 1;
 1616|      0|		    ctxt->counters[counter].max = atom->max - 1;
 1617|       |		    /* allow a way out based on the count */
 1618|      0|		    xmlFAGenerateCountedTransition(ctxt, atom->stop,
 1619|      0|			                           newstate, counter);
 1620|       |		    /* count the number of times we see it again */
 1621|      0|		    xmlFAGenerateCountedEpsilonTransition(ctxt, atom->stop,
 1622|      0|						   atom->start, counter);
 1623|       |		    /* and if needed allow a direct exit for 0 */
 1624|      0|		    if (atom->min == 0)
  ------------------
  |  Branch (1624:11): [True: 0, False: 0]
  ------------------
 1625|      0|			xmlFAGenerateEpsilonTransition(ctxt, atom->start0,
 1626|      0|						       newstate);
 1627|       |
 1628|      0|		}
 1629|      0|		atom->min = 0;
 1630|      0|		atom->max = 0;
 1631|      0|		atom->quant = XML_REGEXP_QUANT_ONCE;
 1632|      0|		ctxt->state = newstate;
 1633|      0|	    }
 1634|     10|	    default:
  ------------------
  |  Branch (1634:6): [True: 10, False: 3]
  ------------------
 1635|     10|		break;
 1636|     13|	}
 1637|     13|	if (xmlRegAtomPush(ctxt, atom) < 0)
  ------------------
  |  Branch (1637:6): [True: 0, False: 13]
  ------------------
 1638|      0|	    return(-1);
 1639|     13|	return(0);
 1640|     13|    }
 1641|    741|    if ((atom->min == 0) && (atom->max == 0) &&
  ------------------
  |  Branch (1641:9): [True: 726, False: 15]
  |  Branch (1641:29): [True: 726, False: 0]
  ------------------
 1642|    741|               (atom->quant == XML_REGEXP_QUANT_RANGE)) {
  ------------------
  |  Branch (1642:16): [True: 0, False: 726]
  ------------------
 1643|       |        /*
 1644|       |	 * we can discard the atom and generate an epsilon transition instead
 1645|       |	 */
 1646|      0|	if (to == NULL) {
  ------------------
  |  Branch (1646:6): [True: 0, False: 0]
  ------------------
 1647|      0|	    to = xmlRegStatePush(ctxt);
 1648|      0|	    if (to == NULL)
  ------------------
  |  Branch (1648:10): [True: 0, False: 0]
  ------------------
 1649|      0|		return(-1);
 1650|      0|	}
 1651|      0|	xmlFAGenerateEpsilonTransition(ctxt, from, to);
 1652|      0|	ctxt->state = to;
 1653|      0|	xmlRegFreeAtom(atom);
 1654|      0|	return(0);
 1655|      0|    }
 1656|    741|    if (to == NULL) {
  ------------------
  |  Branch (1656:9): [True: 626, False: 115]
  ------------------
 1657|    626|	to = xmlRegStatePush(ctxt);
 1658|    626|	if (to == NULL)
  ------------------
  |  Branch (1658:6): [True: 0, False: 626]
  ------------------
 1659|      0|	    return(-1);
 1660|    626|    }
 1661|    741|    end = to;
 1662|    741|    if ((atom->quant == XML_REGEXP_QUANT_MULT) ||
  ------------------
  |  Branch (1662:9): [True: 6, False: 735]
  ------------------
 1663|    741|        (atom->quant == XML_REGEXP_QUANT_PLUS)) {
  ------------------
  |  Branch (1663:9): [True: 5, False: 730]
  ------------------
 1664|       |	/*
 1665|       |	 * Do not pollute the target state by adding transitions from
 1666|       |	 * it as it is likely to be the shared target of multiple branches.
 1667|       |	 * So isolate with an epsilon transition.
 1668|       |	 */
 1669|     11|        xmlRegStatePtr tmp;
 1670|       |
 1671|     11|	tmp = xmlRegStatePush(ctxt);
 1672|     11|        if (tmp == NULL)
  ------------------
  |  Branch (1672:13): [True: 0, False: 11]
  ------------------
 1673|      0|	    return(-1);
 1674|     11|	xmlFAGenerateEpsilonTransition(ctxt, tmp, to);
 1675|     11|	to = tmp;
 1676|     11|    }
 1677|    741|    if ((atom->quant == XML_REGEXP_QUANT_RANGE) &&
  ------------------
  |  Branch (1677:9): [True: 15, False: 726]
  ------------------
 1678|    741|        (atom->min == 0) && (atom->max > 0)) {
  ------------------
  |  Branch (1678:9): [True: 0, False: 15]
  |  Branch (1678:29): [True: 0, False: 0]
  ------------------
 1679|      0|	nullable = 1;
 1680|      0|	atom->min = 1;
 1681|      0|        if (atom->max == 1)
  ------------------
  |  Branch (1681:13): [True: 0, False: 0]
  ------------------
 1682|      0|	    atom->quant = XML_REGEXP_QUANT_OPT;
 1683|      0|    }
 1684|    741|    xmlRegStateAddTrans(ctxt, from, atom, to, -1, -1);
 1685|    741|    ctxt->state = end;
 1686|    741|    switch (atom->quant) {
 1687|      0|	case XML_REGEXP_QUANT_OPT:
  ------------------
  |  Branch (1687:2): [True: 0, False: 741]
  ------------------
 1688|      0|	    atom->quant = XML_REGEXP_QUANT_ONCE;
 1689|      0|	    xmlFAGenerateEpsilonTransition(ctxt, from, to);
 1690|      0|	    break;
 1691|      6|	case XML_REGEXP_QUANT_MULT:
  ------------------
  |  Branch (1691:2): [True: 6, False: 735]
  ------------------
 1692|      6|	    atom->quant = XML_REGEXP_QUANT_ONCE;
 1693|      6|	    xmlFAGenerateEpsilonTransition(ctxt, from, to);
 1694|      6|	    xmlRegStateAddTrans(ctxt, to, atom, to, -1, -1);
 1695|      6|	    break;
 1696|      5|	case XML_REGEXP_QUANT_PLUS:
  ------------------
  |  Branch (1696:2): [True: 5, False: 736]
  ------------------
 1697|      5|	    atom->quant = XML_REGEXP_QUANT_ONCE;
 1698|      5|	    xmlRegStateAddTrans(ctxt, to, atom, to, -1, -1);
 1699|      5|	    break;
 1700|     15|	case XML_REGEXP_QUANT_RANGE:
  ------------------
  |  Branch (1700:2): [True: 15, False: 726]
  ------------------
 1701|     15|	    if (nullable)
  ------------------
  |  Branch (1701:10): [True: 0, False: 15]
  ------------------
 1702|      0|		xmlFAGenerateEpsilonTransition(ctxt, from, to);
 1703|     15|	    break;
 1704|    715|	default:
  ------------------
  |  Branch (1704:2): [True: 715, False: 26]
  ------------------
 1705|    715|	    break;
 1706|    741|    }
 1707|    741|    if (xmlRegAtomPush(ctxt, atom) < 0)
  ------------------
  |  Branch (1707:9): [True: 0, False: 741]
  ------------------
 1708|      0|	return(-1);
 1709|    741|    return(0);
 1710|    741|}
xmlregexp.c:xmlRegGetCounter:
 1228|     64|xmlRegGetCounter(xmlRegParserCtxtPtr ctxt) {
 1229|     64|    if (ctxt->maxCounters == 0) {
  ------------------
  |  Branch (1229:9): [True: 50, False: 14]
  ------------------
 1230|     50|	ctxt->maxCounters = 4;
 1231|     50|	ctxt->counters = (xmlRegCounter *) xmlMalloc(ctxt->maxCounters *
 1232|     50|		                             sizeof(xmlRegCounter));
 1233|     50|	if (ctxt->counters == NULL) {
  ------------------
  |  Branch (1233:6): [True: 0, False: 50]
  ------------------
 1234|      0|	    xmlRegexpErrMemory(ctxt, "allocating counter");
 1235|      0|	    ctxt->maxCounters = 0;
 1236|      0|	    return(-1);
 1237|      0|	}
 1238|     50|    } else if (ctxt->nbCounters >= ctxt->maxCounters) {
  ------------------
  |  Branch (1238:16): [True: 0, False: 14]
  ------------------
 1239|      0|	xmlRegCounter *tmp;
 1240|      0|	ctxt->maxCounters *= 2;
 1241|      0|	tmp = (xmlRegCounter *) xmlRealloc(ctxt->counters, ctxt->maxCounters *
 1242|      0|		                           sizeof(xmlRegCounter));
 1243|      0|	if (tmp == NULL) {
  ------------------
  |  Branch (1243:6): [True: 0, False: 0]
  ------------------
 1244|      0|	    xmlRegexpErrMemory(ctxt, "allocating counter");
 1245|      0|	    ctxt->maxCounters /= 2;
 1246|      0|	    return(-1);
 1247|      0|	}
 1248|      0|	ctxt->counters = tmp;
 1249|      0|    }
 1250|     64|    ctxt->counters[ctxt->nbCounters].min = -1;
 1251|     64|    ctxt->counters[ctxt->nbCounters].max = -1;
 1252|     64|    return(ctxt->nbCounters++);
 1253|     64|}
xmlregexp.c:xmlRegStateAddTrans:
 1309|  2.44k|		    int counter, int count) {
 1310|       |
 1311|  2.44k|    int nrtrans;
 1312|       |
 1313|  2.44k|    if (state == NULL) {
  ------------------
  |  Branch (1313:9): [True: 0, False: 2.44k]
  ------------------
 1314|      0|	ERROR("add state: state is NULL");
  ------------------
  |  |   55|      0|    ctxt->error = XML_REGEXP_COMPILE_ERROR;				\
  |  |   56|      0|    xmlRegexpErrCompile(ctxt, str);
  ------------------
 1315|      0|	return;
 1316|      0|    }
 1317|  2.44k|    if (target == NULL) {
  ------------------
  |  Branch (1317:9): [True: 0, False: 2.44k]
  ------------------
 1318|      0|	ERROR("add state: target is NULL");
  ------------------
  |  |   55|      0|    ctxt->error = XML_REGEXP_COMPILE_ERROR;				\
  |  |   56|      0|    xmlRegexpErrCompile(ctxt, str);
  ------------------
 1319|      0|	return;
 1320|      0|    }
 1321|       |    /*
 1322|       |     * Other routines follow the philosophy 'When in doubt, add a transition'
 1323|       |     * so we check here whether such a transition is already present and, if
 1324|       |     * so, silently ignore this request.
 1325|       |     */
 1326|       |
 1327|  9.94k|    for (nrtrans = state->nbTrans - 1; nrtrans >= 0; nrtrans--) {
  ------------------
  |  Branch (1327:40): [True: 7.54k, False: 2.40k]
  ------------------
 1328|  7.54k|	xmlRegTransPtr trans = &(state->trans[nrtrans]);
 1329|  7.54k|	if ((trans->atom == atom) &&
  ------------------
  |  Branch (1329:6): [True: 458, False: 7.08k]
  ------------------
 1330|  7.54k|	    (trans->to == target->no) &&
  ------------------
  |  Branch (1330:6): [True: 74, False: 384]
  ------------------
 1331|  7.54k|	    (trans->counter == counter) &&
  ------------------
  |  Branch (1331:6): [True: 53, False: 21]
  ------------------
 1332|  7.54k|	    (trans->count == count)) {
  ------------------
  |  Branch (1332:6): [True: 46, False: 7]
  ------------------
 1333|     46|	    return;
 1334|     46|	}
 1335|  7.54k|    }
 1336|       |
 1337|  2.40k|    if (state->maxTrans == 0) {
  ------------------
  |  Branch (1337:9): [True: 894, False: 1.50k]
  ------------------
 1338|    894|	state->maxTrans = 8;
 1339|    894|	state->trans = (xmlRegTrans *) xmlMalloc(state->maxTrans *
 1340|    894|		                             sizeof(xmlRegTrans));
 1341|    894|	if (state->trans == NULL) {
  ------------------
  |  Branch (1341:6): [True: 0, False: 894]
  ------------------
 1342|      0|	    xmlRegexpErrMemory(ctxt, "adding transition");
 1343|      0|	    state->maxTrans = 0;
 1344|      0|	    return;
 1345|      0|	}
 1346|  1.50k|    } else if (state->nbTrans >= state->maxTrans) {
  ------------------
  |  Branch (1346:16): [True: 64, False: 1.44k]
  ------------------
 1347|     64|	xmlRegTrans *tmp;
 1348|     64|	state->maxTrans *= 2;
 1349|     64|	tmp = (xmlRegTrans *) xmlRealloc(state->trans, state->maxTrans *
 1350|     64|		                             sizeof(xmlRegTrans));
 1351|     64|	if (tmp == NULL) {
  ------------------
  |  Branch (1351:6): [True: 0, False: 64]
  ------------------
 1352|      0|	    xmlRegexpErrMemory(ctxt, "adding transition");
 1353|      0|	    state->maxTrans /= 2;
 1354|      0|	    return;
 1355|      0|	}
 1356|     64|	state->trans = tmp;
 1357|     64|    }
 1358|       |
 1359|  2.40k|    state->trans[state->nbTrans].atom = atom;
 1360|  2.40k|    state->trans[state->nbTrans].to = target->no;
 1361|  2.40k|    state->trans[state->nbTrans].counter = counter;
 1362|  2.40k|    state->trans[state->nbTrans].count = count;
 1363|  2.40k|    state->trans[state->nbTrans].nd = 0;
 1364|  2.40k|    state->nbTrans++;
 1365|  2.40k|    xmlRegStateAddTransTo(ctxt, target, state->no);
 1366|  2.40k|}
xmlregexp.c:xmlRegStateAddTransTo:
 1280|  2.40k|                      int from) {
 1281|  2.40k|    if (target->maxTransTo == 0) {
  ------------------
  |  Branch (1281:9): [True: 857, False: 1.54k]
  ------------------
 1282|    857|	target->maxTransTo = 8;
 1283|    857|	target->transTo = (int *) xmlMalloc(target->maxTransTo *
 1284|    857|		                             sizeof(int));
 1285|    857|	if (target->transTo == NULL) {
  ------------------
  |  Branch (1285:6): [True: 0, False: 857]
  ------------------
 1286|      0|	    xmlRegexpErrMemory(ctxt, "adding transition");
 1287|      0|	    target->maxTransTo = 0;
 1288|      0|	    return;
 1289|      0|	}
 1290|  1.54k|    } else if (target->nbTransTo >= target->maxTransTo) {
  ------------------
  |  Branch (1290:16): [True: 77, False: 1.46k]
  ------------------
 1291|     77|	int *tmp;
 1292|     77|	target->maxTransTo *= 2;
 1293|     77|	tmp = (int *) xmlRealloc(target->transTo, target->maxTransTo *
 1294|     77|		                             sizeof(int));
 1295|     77|	if (tmp == NULL) {
  ------------------
  |  Branch (1295:6): [True: 0, False: 77]
  ------------------
 1296|      0|	    xmlRegexpErrMemory(ctxt, "adding transition");
 1297|      0|	    target->maxTransTo /= 2;
 1298|      0|	    return;
 1299|      0|	}
 1300|     77|	target->transTo = tmp;
 1301|     77|    }
 1302|  2.40k|    target->transTo[target->nbTransTo] = from;
 1303|  2.40k|    target->nbTransTo++;
 1304|  2.40k|}
xmlregexp.c:xmlRegAtomPush:
 1256|    770|xmlRegAtomPush(xmlRegParserCtxtPtr ctxt, xmlRegAtomPtr atom) {
 1257|    770|    if (atom == NULL) {
  ------------------
  |  Branch (1257:9): [True: 0, False: 770]
  ------------------
 1258|      0|	ERROR("atom push: atom is NULL");
  ------------------
  |  |   55|      0|    ctxt->error = XML_REGEXP_COMPILE_ERROR;				\
  |  |   56|      0|    xmlRegexpErrCompile(ctxt, str);
  ------------------
 1259|      0|	return(-1);
 1260|      0|    }
 1261|    770|    if (ctxt->nbAtoms >= ctxt->maxAtoms) {
  ------------------
  |  Branch (1261:9): [True: 272, False: 498]
  ------------------
 1262|    272|        size_t newSize = ctxt->maxAtoms ? ctxt->maxAtoms * 2 : 4;
  ------------------
  |  Branch (1262:26): [True: 62, False: 210]
  ------------------
 1263|    272|	xmlRegAtomPtr *tmp;
 1264|       |
 1265|    272|	tmp = xmlRealloc(ctxt->atoms, newSize * sizeof(xmlRegAtomPtr));
 1266|    272|	if (tmp == NULL) {
  ------------------
  |  Branch (1266:6): [True: 0, False: 272]
  ------------------
 1267|      0|	    xmlRegexpErrMemory(ctxt, "allocating counter");
 1268|      0|	    return(-1);
 1269|      0|	}
 1270|    272|	ctxt->atoms = tmp;
 1271|    272|        ctxt->maxAtoms = newSize;
 1272|    272|    }
 1273|    770|    atom->no = ctxt->nbAtoms;
 1274|    770|    ctxt->atoms[ctxt->nbAtoms++] = atom;
 1275|    770|    return(0);
 1276|    770|}
xmlregexp.c:xmlFAGenerateEpsilonTransition:
 1429|    439|			       xmlRegStatePtr from, xmlRegStatePtr to) {
 1430|    439|    if (to == NULL) {
  ------------------
  |  Branch (1430:9): [True: 63, False: 376]
  ------------------
 1431|     63|	to = xmlRegStatePush(ctxt);
 1432|     63|        if (to == NULL)
  ------------------
  |  Branch (1432:13): [True: 0, False: 63]
  ------------------
 1433|      0|            return(-1);
 1434|     63|	ctxt->state = to;
 1435|     63|    }
 1436|    439|    xmlRegStateAddTrans(ctxt, from, NULL, to, -1, -1);
 1437|    439|    return(0);
 1438|    439|}
xmlregexp.c:xmlFAGenerateAllTransition:
 1406|     11|			   int lax) {
 1407|     11|    if (to == NULL) {
  ------------------
  |  Branch (1407:9): [True: 11, False: 0]
  ------------------
 1408|     11|	to = xmlRegStatePush(ctxt);
 1409|     11|        if (to == NULL)
  ------------------
  |  Branch (1409:13): [True: 0, False: 11]
  ------------------
 1410|      0|            return(-1);
 1411|     11|	ctxt->state = to;
 1412|     11|    }
 1413|     11|    if (lax)
  ------------------
  |  Branch (1413:9): [True: 0, False: 11]
  ------------------
 1414|      0|	xmlRegStateAddTrans(ctxt, from, NULL, to, -1, REGEXP_ALL_LAX_COUNTER);
  ------------------
  |  |  359|      0|#define REGEXP_ALL_LAX_COUNTER	0x123457
  ------------------
 1415|     11|    else
 1416|     11|	xmlRegStateAddTrans(ctxt, from, NULL, to, -1, REGEXP_ALL_COUNTER);
  ------------------
  |  |  358|     11|#define REGEXP_ALL_COUNTER	0x123456
  ------------------
 1417|     11|    return(0);
 1418|     11|}
xmlregexp.c:xmlFAGenerateCountedEpsilonTransition:
 1450|     48|	    xmlRegStatePtr from, xmlRegStatePtr to, int counter) {
 1451|     48|    if (to == NULL) {
  ------------------
  |  Branch (1451:9): [True: 4, False: 44]
  ------------------
 1452|      4|	to = xmlRegStatePush(ctxt);
 1453|      4|        if (to == NULL)
  ------------------
  |  Branch (1453:13): [True: 0, False: 4]
  ------------------
 1454|      0|            return(-1);
 1455|      4|	ctxt->state = to;
 1456|      4|    }
 1457|     48|    xmlRegStateAddTrans(ctxt, from, NULL, to, counter, -1);
 1458|     48|    return(0);
 1459|     48|}
xmlregexp.c:xmlFAGenerateCountedTransition:
 1471|     44|	    xmlRegStatePtr from, xmlRegStatePtr to, int counter) {
 1472|     44|    if (to == NULL) {
  ------------------
  |  Branch (1472:9): [True: 12, False: 32]
  ------------------
 1473|     12|	to = xmlRegStatePush(ctxt);
 1474|     12|        if (to == NULL)
  ------------------
  |  Branch (1474:13): [True: 0, False: 12]
  ------------------
 1475|      0|            return(-1);
 1476|     12|	ctxt->state = to;
 1477|     12|    }
 1478|     44|    xmlRegStateAddTrans(ctxt, from, NULL, to, -1, counter);
 1479|     44|    return(0);
 1480|     44|}

xmlSchemaNewFacet:
 3344|    227|{
 3345|    227|    xmlSchemaFacetPtr ret;
 3346|       |
 3347|    227|    ret = (xmlSchemaFacetPtr) xmlMalloc(sizeof(xmlSchemaFacet));
 3348|    227|    if (ret == NULL) {
  ------------------
  |  Branch (3348:9): [True: 0, False: 227]
  ------------------
 3349|      0|        return (NULL);
 3350|      0|    }
 3351|    227|    memset(ret, 0, sizeof(xmlSchemaFacet));
 3352|       |
 3353|    227|    return (ret);
 3354|    227|}
xmlSchemaFreeWildcard:
 3873|    134|{
 3874|    134|    if (wildcard == NULL)
  ------------------
  |  Branch (3874:9): [True: 0, False: 134]
  ------------------
 3875|      0|        return;
 3876|    134|    if (wildcard->annot != NULL)
  ------------------
  |  Branch (3876:9): [True: 0, False: 134]
  ------------------
 3877|      0|        xmlSchemaFreeAnnot(wildcard->annot);
 3878|    134|    if (wildcard->nsSet != NULL)
  ------------------
  |  Branch (3878:9): [True: 46, False: 88]
  ------------------
 3879|     46|	xmlSchemaFreeWildcardNsSet(wildcard->nsSet);
 3880|    134|    if (wildcard->negNsSet != NULL)
  ------------------
  |  Branch (3880:9): [True: 56, False: 78]
  ------------------
 3881|     56|	xmlFree(wildcard->negNsSet);
 3882|    134|    xmlFree(wildcard);
 3883|    134|}
xmlSchemaFreeFacet:
 4011|    224|{
 4012|    224|    if (facet == NULL)
  ------------------
  |  Branch (4012:9): [True: 0, False: 224]
  ------------------
 4013|      0|        return;
 4014|    224|    if (facet->val != NULL)
  ------------------
  |  Branch (4014:9): [True: 196, False: 28]
  ------------------
 4015|    196|        xmlSchemaFreeValue(facet->val);
 4016|    224|    if (facet->regexp != NULL)
  ------------------
  |  Branch (4016:9): [True: 26, False: 198]
  ------------------
 4017|     26|        xmlRegFreeRegexp(facet->regexp);
 4018|    224|    if (facet->annot != NULL)
  ------------------
  |  Branch (4018:9): [True: 3, False: 221]
  ------------------
 4019|      3|        xmlSchemaFreeAnnot(facet->annot);
 4020|    224|    xmlFree(facet);
 4021|    224|}
xmlSchemaFreeType:
 4031|    542|{
 4032|    542|    if (type == NULL)
  ------------------
  |  Branch (4032:9): [True: 0, False: 542]
  ------------------
 4033|      0|        return;
 4034|    542|    if (type->annot != NULL)
  ------------------
  |  Branch (4034:9): [True: 15, False: 527]
  ------------------
 4035|     15|        xmlSchemaFreeAnnot(type->annot);
 4036|    542|    if (type->facets != NULL) {
  ------------------
  |  Branch (4036:9): [True: 120, False: 422]
  ------------------
 4037|    120|        xmlSchemaFacetPtr facet, next;
 4038|       |
 4039|    120|        facet = type->facets;
 4040|    344|        while (facet != NULL) {
  ------------------
  |  Branch (4040:16): [True: 224, False: 120]
  ------------------
 4041|    224|            next = facet->next;
 4042|    224|            xmlSchemaFreeFacet(facet);
 4043|    224|            facet = next;
 4044|    224|        }
 4045|    120|    }
 4046|    542|    if (type->attrUses != NULL)
  ------------------
  |  Branch (4046:9): [True: 143, False: 399]
  ------------------
 4047|    143|	xmlSchemaItemListFree((xmlSchemaItemListPtr) type->attrUses);
 4048|    542|    if (type->memberTypes != NULL)
  ------------------
  |  Branch (4048:9): [True: 25, False: 517]
  ------------------
 4049|     25|	xmlSchemaFreeTypeLinkList(type->memberTypes);
 4050|    542|    if (type->facetSet != NULL) {
  ------------------
  |  Branch (4050:9): [True: 121, False: 421]
  ------------------
 4051|    121|	xmlSchemaFacetLinkPtr next, link;
 4052|       |
 4053|    121|	link = type->facetSet;
 4054|    225|	do {
 4055|    225|	    next = link->next;
 4056|    225|	    xmlFree(link);
 4057|    225|	    link = next;
 4058|    225|	} while (link != NULL);
  ------------------
  |  Branch (4058:11): [True: 104, False: 121]
  ------------------
 4059|    121|    }
 4060|    542|    if (type->contModel != NULL)
  ------------------
  |  Branch (4060:9): [True: 192, False: 350]
  ------------------
 4061|    192|        xmlRegFreeRegexp(type->contModel);
 4062|    542|    xmlFree(type);
 4063|    542|}
xmlSchemaFree:
 4180|    285|{
 4181|    285|    if (schema == NULL)
  ------------------
  |  Branch (4181:9): [True: 71, False: 214]
  ------------------
 4182|     71|        return;
 4183|       |    /* @volatiles is not used anymore :-/ */
 4184|    214|    if (schema->volatiles != NULL)
  ------------------
  |  Branch (4184:9): [True: 0, False: 214]
  ------------------
 4185|    214|	TODO
  ------------------
  |  |  100|      0|    xmlGenericError(xmlGenericErrorContext,				\
  |  |  ------------------
  |  |  |  |  875|      0|  #define xmlGenericError XML_GLOBAL_MACRO(xmlGenericError)
  |  |  |  |  ------------------
  |  |  |  |  |  |  500|      0|  #define XML_GLOBAL_MACRO(name) (*__##name())
  |  |  |  |  ------------------
  |  |  ------------------
  |  |                   xmlGenericError(xmlGenericErrorContext,				\
  |  |  ------------------
  |  |  |  |  876|      0|  #define xmlGenericErrorContext XML_GLOBAL_MACRO(xmlGenericErrorContext)
  |  |  |  |  ------------------
  |  |  |  |  |  |  500|      0|  #define XML_GLOBAL_MACRO(name) (*__##name())
  |  |  |  |  ------------------
  |  |  ------------------
  |  |  101|      0|	    "Unimplemented block at %s:%d\n",				\
  |  |  102|      0|            __FILE__, __LINE__);
  ------------------
 4186|       |    /*
 4187|       |    * Note that those slots are not responsible for freeing
 4188|       |    * schema components anymore; this will now be done by
 4189|       |    * the schema buckets.
 4190|       |    */
 4191|    214|    if (schema->notaDecl != NULL)
  ------------------
  |  Branch (4191:9): [True: 0, False: 214]
  ------------------
 4192|      0|        xmlHashFree(schema->notaDecl, NULL);
 4193|    214|    if (schema->attrDecl != NULL)
  ------------------
  |  Branch (4193:9): [True: 16, False: 198]
  ------------------
 4194|     16|        xmlHashFree(schema->attrDecl, NULL);
 4195|    214|    if (schema->attrgrpDecl != NULL)
  ------------------
  |  Branch (4195:9): [True: 17, False: 197]
  ------------------
 4196|     17|        xmlHashFree(schema->attrgrpDecl, NULL);
 4197|    214|    if (schema->elemDecl != NULL)
  ------------------
  |  Branch (4197:9): [True: 135, False: 79]
  ------------------
 4198|    135|        xmlHashFree(schema->elemDecl, NULL);
 4199|    214|    if (schema->typeDecl != NULL)
  ------------------
  |  Branch (4199:9): [True: 82, False: 132]
  ------------------
 4200|     82|        xmlHashFree(schema->typeDecl, NULL);
 4201|    214|    if (schema->groupDecl != NULL)
  ------------------
  |  Branch (4201:9): [True: 8, False: 206]
  ------------------
 4202|      8|        xmlHashFree(schema->groupDecl, NULL);
 4203|    214|    if (schema->idcDef != NULL)
  ------------------
  |  Branch (4203:9): [True: 8, False: 206]
  ------------------
 4204|      8|        xmlHashFree(schema->idcDef, NULL);
 4205|       |
 4206|    214|    if (schema->schemasImports != NULL)
  ------------------
  |  Branch (4206:9): [True: 167, False: 47]
  ------------------
 4207|    167|	xmlHashFree(schema->schemasImports, xmlSchemaBucketFreeEntry);
 4208|    214|    if (schema->includes != NULL) {
  ------------------
  |  Branch (4208:9): [True: 16, False: 198]
  ------------------
 4209|     16|	xmlSchemaItemListPtr list = (xmlSchemaItemListPtr) schema->includes;
 4210|     16|	int i;
 4211|     37|	for (i = 0; i < list->nbItems; i++) {
  ------------------
  |  Branch (4211:14): [True: 21, False: 16]
  ------------------
 4212|     21|	    xmlSchemaBucketFree((xmlSchemaBucketPtr) list->items[i]);
 4213|     21|	}
 4214|     16|	xmlSchemaItemListFree(list);
 4215|     16|    }
 4216|    214|    if (schema->annot != NULL)
  ------------------
  |  Branch (4216:9): [True: 12, False: 202]
  ------------------
 4217|     12|        xmlSchemaFreeAnnot(schema->annot);
 4218|       |    /* Never free the doc here, since this will be done by the buckets. */
 4219|       |
 4220|    214|    xmlDictFree(schema->dict);
 4221|    214|    xmlFree(schema);
 4222|    214|}
xmlSchemaNewParserCtxt:
12413|    198|{
12414|    198|    xmlSchemaParserCtxtPtr ret;
12415|       |
12416|    198|    if (URL == NULL)
  ------------------
  |  Branch (12416:9): [True: 0, False: 198]
  ------------------
12417|      0|        return (NULL);
12418|       |
12419|    198|    ret = xmlSchemaParserCtxtCreate();
12420|    198|    if (ret == NULL)
  ------------------
  |  Branch (12420:9): [True: 0, False: 198]
  ------------------
12421|      0|	return(NULL);
12422|    198|    ret->dict = xmlDictCreate();
12423|    198|    ret->URL = xmlDictLookup(ret->dict, (const xmlChar *) URL, -1);
12424|    198|    return (ret);
12425|    198|}
xmlSchemaFreeParserCtxt:
12488|    231|{
12489|    231|    if (ctxt == NULL)
  ------------------
  |  Branch (12489:9): [True: 0, False: 231]
  ------------------
12490|      0|        return;
12491|    231|    if (ctxt->doc != NULL && !ctxt->preserve)
  ------------------
  |  Branch (12491:9): [True: 0, False: 231]
  |  Branch (12491:30): [True: 0, False: 0]
  ------------------
12492|      0|        xmlFreeDoc(ctxt->doc);
12493|    231|    if (ctxt->vctxt != NULL) {
  ------------------
  |  Branch (12493:9): [True: 42, False: 189]
  ------------------
12494|     42|	xmlSchemaFreeValidCtxt(ctxt->vctxt);
12495|     42|    }
12496|    231|    if (ctxt->ownsConstructor && (ctxt->constructor != NULL)) {
  ------------------
  |  Branch (12496:9): [True: 127, False: 104]
  |  Branch (12496:34): [True: 127, False: 0]
  ------------------
12497|    127|	xmlSchemaConstructionCtxtFree(ctxt->constructor);
12498|    127|	ctxt->constructor = NULL;
12499|    127|	ctxt->ownsConstructor = 0;
12500|    127|    }
12501|    231|    if (ctxt->attrProhibs != NULL)
  ------------------
  |  Branch (12501:9): [True: 231, False: 0]
  ------------------
12502|    231|	xmlSchemaItemListFree(ctxt->attrProhibs);
12503|    231|    xmlDictFree(ctxt->dict);
12504|    231|    xmlFree(ctxt);
12505|    231|}
xmlSchemaCheckFacet:
18574|    224|{
18575|    224|    int ret = 0, ctxtGiven;
18576|       |
18577|    224|    if ((facet == NULL) || (typeDecl == NULL))
  ------------------
  |  Branch (18577:9): [True: 0, False: 224]
  |  Branch (18577:28): [True: 0, False: 224]
  ------------------
18578|      0|        return(-1);
18579|       |    /*
18580|       |    * TODO: will the parser context be given if used from
18581|       |    * the relaxNG module?
18582|       |    */
18583|    224|    if (pctxt == NULL)
  ------------------
  |  Branch (18583:9): [True: 0, False: 224]
  ------------------
18584|      0|	ctxtGiven = 0;
18585|    224|    else
18586|    224|	ctxtGiven = 1;
18587|       |
18588|    224|    switch (facet->type) {
18589|     17|        case XML_SCHEMA_FACET_MININCLUSIVE:
  ------------------
  |  Branch (18589:9): [True: 17, False: 207]
  ------------------
18590|     26|        case XML_SCHEMA_FACET_MINEXCLUSIVE:
  ------------------
  |  Branch (18590:9): [True: 9, False: 215]
  ------------------
18591|     41|        case XML_SCHEMA_FACET_MAXINCLUSIVE:
  ------------------
  |  Branch (18591:9): [True: 15, False: 209]
  ------------------
18592|     51|        case XML_SCHEMA_FACET_MAXEXCLUSIVE:
  ------------------
  |  Branch (18592:9): [True: 10, False: 214]
  ------------------
18593|    166|	case XML_SCHEMA_FACET_ENUMERATION: {
  ------------------
  |  Branch (18593:2): [True: 115, False: 109]
  ------------------
18594|       |                /*
18595|       |                 * Okay we need to validate the value
18596|       |                 * at that point.
18597|       |                 */
18598|    166|		xmlSchemaTypePtr base;
18599|       |
18600|       |		/* 4.3.5.5 Constraints on enumeration Schema Components
18601|       |		* Schema Component Constraint: enumeration valid restriction
18602|       |		* It is an `error` if any member of {value} is not in the
18603|       |		* `value space` of {base type definition}.
18604|       |		*
18605|       |		* minInclusive, maxInclusive, minExclusive, maxExclusive:
18606|       |		* The value `must` be in the
18607|       |		* `value space` of the `base type`.
18608|       |		*/
18609|       |		/*
18610|       |		* This function is intended to deliver a compiled value
18611|       |		* on the facet. In this implementation of XML Schemata the
18612|       |		* type holding a facet, won't be a built-in type.
18613|       |		* Thus to ensure that other API
18614|       |		* calls (relaxng) do work, if the given type is a built-in
18615|       |		* type, we will assume that the given built-in type *is
18616|       |		* already* the base type.
18617|       |		*/
18618|    166|		if (typeDecl->type != XML_SCHEMA_TYPE_BASIC) {
  ------------------
  |  Branch (18618:7): [True: 166, False: 0]
  ------------------
18619|    166|		    base = typeDecl->baseType;
18620|    166|		    if (base == NULL) {
  ------------------
  |  Branch (18620:11): [True: 0, False: 166]
  ------------------
18621|      0|			PERROR_INT("xmlSchemaCheckFacet",
  ------------------
  |  | 2824|      0|#define PERROR_INT(func, msg) xmlSchemaInternalErr(ACTXT_CAST pctxt, func, msg);
  |  |  ------------------
  |  |  |  |  121|      0|#define ACTXT_CAST (xmlSchemaAbstractCtxtPtr)
  |  |  ------------------
  ------------------
18622|      0|			    "a type user derived type has no base type");
18623|      0|			return (-1);
18624|      0|		    }
18625|    166|		} else
18626|      0|		    base = typeDecl;
18627|       |
18628|    166|		if (! ctxtGiven) {
  ------------------
  |  Branch (18628:7): [True: 0, False: 166]
  ------------------
18629|       |		    /*
18630|       |		    * A context is needed if called from RelaxNG.
18631|       |		    */
18632|      0|		    pctxt = xmlSchemaNewParserCtxt("*");
18633|      0|		    if (pctxt == NULL)
  ------------------
  |  Branch (18633:11): [True: 0, False: 0]
  ------------------
18634|      0|			return (-1);
18635|      0|		}
18636|       |		/*
18637|       |		* NOTE: This call does not check the content nodes,
18638|       |		* since they are not available:
18639|       |		* facet->node is just the node holding the facet
18640|       |		* definition, *not* the attribute holding the *value*
18641|       |		* of the facet.
18642|       |		*/
18643|    166|		ret = xmlSchemaVCheckCVCSimpleType(
18644|    166|		    ACTXT_CAST pctxt, facet->node, base,
  ------------------
  |  |  121|    166|#define ACTXT_CAST (xmlSchemaAbstractCtxtPtr)
  ------------------
18645|    166|		    facet->value, &(facet->val), 1, 1, 0);
18646|    166|                if (ret != 0) {
  ------------------
  |  Branch (18646:21): [True: 0, False: 166]
  ------------------
18647|      0|		    if (ret < 0) {
  ------------------
  |  Branch (18647:11): [True: 0, False: 0]
  ------------------
18648|       |			/* No error message for RelaxNG. */
18649|      0|			if (ctxtGiven) {
  ------------------
  |  Branch (18649:8): [True: 0, False: 0]
  ------------------
18650|      0|			    xmlSchemaCustomErr(ACTXT_CAST pctxt,
  ------------------
  |  |  121|      0|#define ACTXT_CAST (xmlSchemaAbstractCtxtPtr)
  ------------------
18651|      0|				XML_SCHEMAP_INTERNAL, facet->node, NULL,
18652|      0|				"Internal error: xmlSchemaCheckFacet, "
18653|      0|				"failed to validate the value '%s' of the "
18654|      0|				"facet '%s' against the base type",
18655|      0|				facet->value, xmlSchemaFacetTypeToString(facet->type));
18656|      0|			}
18657|      0|			goto internal_error;
18658|      0|		    }
18659|      0|		    ret = XML_SCHEMAP_INVALID_FACET_VALUE;
18660|       |		    /* No error message for RelaxNG. */
18661|      0|		    if (ctxtGiven) {
  ------------------
  |  Branch (18661:11): [True: 0, False: 0]
  ------------------
18662|      0|			xmlChar *str = NULL;
18663|       |
18664|      0|			xmlSchemaCustomErr(ACTXT_CAST pctxt,
  ------------------
  |  |  121|      0|#define ACTXT_CAST (xmlSchemaAbstractCtxtPtr)
  ------------------
18665|      0|			    ret, facet->node, WXS_BASIC_CAST facet,
  ------------------
  |  |  124|      0|#define WXS_BASIC_CAST (xmlSchemaBasicItemPtr)
  ------------------
18666|      0|			    "The value '%s' of the facet does not validate "
18667|      0|			    "against the base type '%s'",
18668|      0|			    facet->value,
18669|      0|			    xmlSchemaFormatQName(&str,
18670|      0|				base->targetNamespace, base->name));
18671|      0|			FREE_AND_NULL(str);
  ------------------
  |  |  320|      0|#define FREE_AND_NULL(str) if ((str) != NULL) { xmlFree((xmlChar *) (str)); str = NULL; }
  |  |  ------------------
  |  |  |  Branch (320:32): [True: 0, False: 0]
  |  |  ------------------
  ------------------
18672|      0|		    }
18673|      0|		    goto exit;
18674|    166|                } else if (facet->val == NULL) {
  ------------------
  |  Branch (18674:28): [True: 0, False: 166]
  ------------------
18675|      0|		    if (ctxtGiven) {
  ------------------
  |  Branch (18675:11): [True: 0, False: 0]
  ------------------
18676|      0|			PERROR_INT("xmlSchemaCheckFacet",
  ------------------
  |  | 2824|      0|#define PERROR_INT(func, msg) xmlSchemaInternalErr(ACTXT_CAST pctxt, func, msg);
  |  |  ------------------
  |  |  |  |  121|      0|#define ACTXT_CAST (xmlSchemaAbstractCtxtPtr)
  |  |  ------------------
  ------------------
18677|      0|			    "value was not computed");
18678|      0|		    }
18679|      0|		    TODO
  ------------------
  |  |  100|      0|    xmlGenericError(xmlGenericErrorContext,				\
  |  |  ------------------
  |  |  |  |  875|      0|  #define xmlGenericError XML_GLOBAL_MACRO(xmlGenericError)
  |  |  |  |  ------------------
  |  |  |  |  |  |  500|      0|  #define XML_GLOBAL_MACRO(name) (*__##name())
  |  |  |  |  ------------------
  |  |  ------------------
  |  |                   xmlGenericError(xmlGenericErrorContext,				\
  |  |  ------------------
  |  |  |  |  876|      0|  #define xmlGenericErrorContext XML_GLOBAL_MACRO(xmlGenericErrorContext)
  |  |  |  |  ------------------
  |  |  |  |  |  |  500|      0|  #define XML_GLOBAL_MACRO(name) (*__##name())
  |  |  |  |  ------------------
  |  |  ------------------
  |  |  101|      0|	    "Unimplemented block at %s:%d\n",				\
  |  |  102|      0|            __FILE__, __LINE__);
  ------------------
18680|      0|		}
18681|    166|                break;
18682|    166|            }
18683|    166|        case XML_SCHEMA_FACET_PATTERN:
  ------------------
  |  Branch (18683:9): [True: 26, False: 198]
  ------------------
18684|     26|            facet->regexp = xmlRegexpCompile(facet->value);
18685|     26|            if (facet->regexp == NULL) {
  ------------------
  |  Branch (18685:17): [True: 0, False: 26]
  ------------------
18686|      0|		ret = XML_SCHEMAP_REGEXP_INVALID;
18687|       |		/* No error message for RelaxNG. */
18688|      0|		if (ctxtGiven) {
  ------------------
  |  Branch (18688:7): [True: 0, False: 0]
  ------------------
18689|      0|		    xmlSchemaCustomErr(ACTXT_CAST pctxt,
  ------------------
  |  |  121|      0|#define ACTXT_CAST (xmlSchemaAbstractCtxtPtr)
  ------------------
18690|      0|			ret, facet->node, WXS_BASIC_CAST typeDecl,
  ------------------
  |  |  124|      0|#define WXS_BASIC_CAST (xmlSchemaBasicItemPtr)
  ------------------
18691|      0|			"The value '%s' of the facet 'pattern' is not a "
18692|      0|			"valid regular expression",
18693|      0|			facet->value, NULL);
18694|      0|		}
18695|      0|            }
18696|     26|            break;
18697|      7|        case XML_SCHEMA_FACET_TOTALDIGITS:
  ------------------
  |  Branch (18697:9): [True: 7, False: 217]
  ------------------
18698|      7|        case XML_SCHEMA_FACET_FRACTIONDIGITS:
  ------------------
  |  Branch (18698:9): [True: 0, False: 224]
  ------------------
18699|     10|        case XML_SCHEMA_FACET_LENGTH:
  ------------------
  |  Branch (18699:9): [True: 3, False: 221]
  ------------------
18700|     23|        case XML_SCHEMA_FACET_MAXLENGTH:
  ------------------
  |  Branch (18700:9): [True: 13, False: 211]
  ------------------
18701|     30|        case XML_SCHEMA_FACET_MINLENGTH:
  ------------------
  |  Branch (18701:9): [True: 7, False: 217]
  ------------------
18702|       |
18703|     30|	    if (facet->type == XML_SCHEMA_FACET_TOTALDIGITS) {
  ------------------
  |  Branch (18703:10): [True: 7, False: 23]
  ------------------
18704|      7|		ret = xmlSchemaValidatePredefinedType(
18705|      7|		    xmlSchemaGetBuiltInType(XML_SCHEMAS_PINTEGER),
18706|      7|		    facet->value, &(facet->val));
18707|     23|	    } else {
18708|     23|		ret = xmlSchemaValidatePredefinedType(
18709|     23|		    xmlSchemaGetBuiltInType(XML_SCHEMAS_NNINTEGER),
18710|     23|		    facet->value, &(facet->val));
18711|     23|	    }
18712|     30|	    if (ret != 0) {
  ------------------
  |  Branch (18712:10): [True: 0, False: 30]
  ------------------
18713|      0|		if (ret < 0) {
  ------------------
  |  Branch (18713:7): [True: 0, False: 0]
  ------------------
18714|       |		    /* No error message for RelaxNG. */
18715|      0|		    if (ctxtGiven) {
  ------------------
  |  Branch (18715:11): [True: 0, False: 0]
  ------------------
18716|      0|			PERROR_INT("xmlSchemaCheckFacet",
  ------------------
  |  | 2824|      0|#define PERROR_INT(func, msg) xmlSchemaInternalErr(ACTXT_CAST pctxt, func, msg);
  |  |  ------------------
  |  |  |  |  121|      0|#define ACTXT_CAST (xmlSchemaAbstractCtxtPtr)
  |  |  ------------------
  ------------------
18717|      0|			    "validating facet value");
18718|      0|		    }
18719|      0|		    goto internal_error;
18720|      0|		}
18721|      0|		ret = XML_SCHEMAP_INVALID_FACET_VALUE;
18722|       |		/* No error message for RelaxNG. */
18723|      0|		if (ctxtGiven) {
  ------------------
  |  Branch (18723:7): [True: 0, False: 0]
  ------------------
18724|       |		    /* error code */
18725|      0|		    xmlSchemaCustomErr4(ACTXT_CAST pctxt,
  ------------------
  |  |  121|      0|#define ACTXT_CAST (xmlSchemaAbstractCtxtPtr)
  ------------------
18726|      0|			ret, facet->node, WXS_BASIC_CAST typeDecl,
  ------------------
  |  |  124|      0|#define WXS_BASIC_CAST (xmlSchemaBasicItemPtr)
  ------------------
18727|      0|			"The value '%s' of the facet '%s' is not a valid '%s'",
18728|      0|			facet->value,
18729|      0|			xmlSchemaFacetTypeToString(facet->type),
18730|      0|			(facet->type != XML_SCHEMA_FACET_TOTALDIGITS) ?
  ------------------
  |  Branch (18730:4): [True: 0, False: 0]
  ------------------
18731|      0|			    BAD_CAST "nonNegativeInteger" :
  ------------------
  |  |   35|      0|#define BAD_CAST (xmlChar *)
  ------------------
18732|      0|			    BAD_CAST "positiveInteger",
  ------------------
  |  |   35|      0|#define BAD_CAST (xmlChar *)
  ------------------
18733|      0|			NULL);
18734|      0|		}
18735|      0|	    }
18736|     30|	    break;
18737|       |
18738|     30|        case XML_SCHEMA_FACET_WHITESPACE:{
  ------------------
  |  Branch (18738:9): [True: 2, False: 222]
  ------------------
18739|      2|                if (xmlStrEqual(facet->value, BAD_CAST "preserve")) {
  ------------------
  |  |   35|      2|#define BAD_CAST (xmlChar *)
  ------------------
  |  Branch (18739:21): [True: 0, False: 2]
  ------------------
18740|      0|                    facet->whitespace = XML_SCHEMAS_FACET_PRESERVE;
  ------------------
  |  |  807|      0|#define XML_SCHEMAS_FACET_PRESERVE        1
  ------------------
18741|      2|                } else if (xmlStrEqual(facet->value, BAD_CAST "replace")) {
  ------------------
  |  |   35|      2|#define BAD_CAST (xmlChar *)
  ------------------
  |  Branch (18741:28): [True: 1, False: 1]
  ------------------
18742|      1|                    facet->whitespace = XML_SCHEMAS_FACET_REPLACE;
  ------------------
  |  |  813|      1|#define XML_SCHEMAS_FACET_REPLACE        2
  ------------------
18743|      1|                } else if (xmlStrEqual(facet->value, BAD_CAST "collapse")) {
  ------------------
  |  |   35|      1|#define BAD_CAST (xmlChar *)
  ------------------
  |  Branch (18743:28): [True: 1, False: 0]
  ------------------
18744|      1|                    facet->whitespace = XML_SCHEMAS_FACET_COLLAPSE;
  ------------------
  |  |  819|      1|#define XML_SCHEMAS_FACET_COLLAPSE        3
  ------------------
18745|      1|                } else {
18746|      0|		    ret = XML_SCHEMAP_INVALID_FACET_VALUE;
18747|       |                    /* No error message for RelaxNG. */
18748|      0|		    if (ctxtGiven) {
  ------------------
  |  Branch (18748:11): [True: 0, False: 0]
  ------------------
18749|       |			/* error was previously: XML_SCHEMAP_INVALID_WHITE_SPACE */
18750|      0|			xmlSchemaCustomErr(ACTXT_CAST pctxt,
  ------------------
  |  |  121|      0|#define ACTXT_CAST (xmlSchemaAbstractCtxtPtr)
  ------------------
18751|      0|			    ret, facet->node, WXS_BASIC_CAST typeDecl,
  ------------------
  |  |  124|      0|#define WXS_BASIC_CAST (xmlSchemaBasicItemPtr)
  ------------------
18752|      0|			    "The value '%s' of the facet 'whitespace' is not "
18753|      0|			    "valid", facet->value, NULL);
18754|      0|                    }
18755|      0|                }
18756|      2|            }
18757|      2|        default:
  ------------------
  |  Branch (18757:9): [True: 0, False: 224]
  ------------------
18758|      2|            break;
18759|    224|    }
18760|    224|exit:
18761|    224|    if ((! ctxtGiven) && (pctxt != NULL))
  ------------------
  |  Branch (18761:9): [True: 0, False: 224]
  |  Branch (18761:26): [True: 0, False: 0]
  ------------------
18762|      0|	xmlSchemaFreeParserCtxt(pctxt);
18763|    224|    return (ret);
18764|      0|internal_error:
18765|      0|    if ((! ctxtGiven) && (pctxt != NULL))
  ------------------
  |  Branch (18765:9): [True: 0, False: 0]
  |  Branch (18765:26): [True: 0, False: 0]
  ------------------
18766|      0|	xmlSchemaFreeParserCtxt(pctxt);
18767|      0|    return (-1);
18768|    224|}
xmlSchemaParse:
21236|    198|{
21237|    198|    xmlSchemaPtr mainSchema = NULL;
21238|    198|    xmlSchemaBucketPtr bucket = NULL;
21239|    198|    int res;
21240|       |
21241|       |    /*
21242|       |    * This one is used if the schema to be parsed was specified via
21243|       |    * the API; i.e. not automatically by the validated instance document.
21244|       |    */
21245|       |
21246|    198|    if (xmlSchemaInitTypes() < 0)
  ------------------
  |  Branch (21246:9): [True: 0, False: 198]
  ------------------
21247|      0|        return (NULL);
21248|       |
21249|    198|    if (ctxt == NULL)
  ------------------
  |  Branch (21249:9): [True: 0, False: 198]
  ------------------
21250|      0|        return (NULL);
21251|       |
21252|       |    /* TODO: Init the context. Is this all we need?*/
21253|    198|    ctxt->nberrors = 0;
21254|    198|    ctxt->err = 0;
21255|    198|    ctxt->counter = 0;
21256|       |
21257|       |    /* Create the *main* schema. */
21258|    198|    mainSchema = xmlSchemaNewSchema(ctxt);
21259|    198|    if (mainSchema == NULL)
  ------------------
  |  Branch (21259:9): [True: 0, False: 198]
  ------------------
21260|      0|	goto exit_failure;
21261|       |    /*
21262|       |    * Create the schema constructor.
21263|       |    */
21264|    198|    if (ctxt->constructor == NULL) {
  ------------------
  |  Branch (21264:9): [True: 198, False: 0]
  ------------------
21265|    198|	ctxt->constructor = xmlSchemaConstructionCtxtCreate(ctxt->dict);
21266|    198|	if (ctxt->constructor == NULL)
  ------------------
  |  Branch (21266:6): [True: 0, False: 198]
  ------------------
21267|      0|	    goto exit_failure;
21268|       |	/* Take ownership of the constructor to be able to free it. */
21269|    198|	ctxt->ownsConstructor = 1;
21270|    198|    }
21271|    198|    ctxt->constructor->mainSchema = mainSchema;
21272|       |    /*
21273|       |    * Locate and add the schema document.
21274|       |    */
21275|    198|    res = xmlSchemaAddSchemaDoc(ctxt, XML_SCHEMA_SCHEMA_MAIN,
  ------------------
  |  |  371|    198|#define XML_SCHEMA_SCHEMA_MAIN 0
  ------------------
21276|    198|	ctxt->URL, ctxt->doc, ctxt->buffer, ctxt->size, NULL,
21277|    198|	NULL, NULL, &bucket);
21278|    198|    if (res == -1)
  ------------------
  |  Branch (21278:9): [True: 0, False: 198]
  ------------------
21279|      0|	goto exit_failure;
21280|    198|    if (res != 0)
  ------------------
  |  Branch (21280:9): [True: 31, False: 167]
  ------------------
21281|     31|	goto exit;
21282|       |
21283|    167|    if (bucket == NULL) {
  ------------------
  |  Branch (21283:9): [True: 0, False: 167]
  ------------------
21284|       |	/* TODO: Error code, actually we failed to *locate* the schema. */
21285|      0|	if (ctxt->URL)
  ------------------
  |  Branch (21285:6): [True: 0, False: 0]
  ------------------
21286|      0|	    xmlSchemaCustomErr(ACTXT_CAST ctxt, XML_SCHEMAP_FAILED_LOAD,
  ------------------
  |  |  121|      0|#define ACTXT_CAST (xmlSchemaAbstractCtxtPtr)
  ------------------
21287|      0|		NULL, NULL,
21288|      0|		"Failed to locate the main schema resource at '%s'",
21289|      0|		ctxt->URL, NULL);
21290|      0|	else
21291|      0|	    xmlSchemaCustomErr(ACTXT_CAST ctxt, XML_SCHEMAP_FAILED_LOAD,
  ------------------
  |  |  121|      0|#define ACTXT_CAST (xmlSchemaAbstractCtxtPtr)
  ------------------
21292|      0|		NULL, NULL,
21293|      0|		"Failed to locate the main schema resource",
21294|      0|		    NULL, NULL);
21295|      0|	goto exit;
21296|      0|    }
21297|       |    /* Then do the parsing for good. */
21298|    167|    if (xmlSchemaParseNewDocWithContext(ctxt, mainSchema, bucket) == -1)
  ------------------
  |  Branch (21298:9): [True: 0, False: 167]
  ------------------
21299|      0|	goto exit_failure;
21300|    167|    if (ctxt->nberrors != 0)
  ------------------
  |  Branch (21300:9): [True: 29, False: 138]
  ------------------
21301|     29|	goto exit;
21302|       |
21303|    138|    mainSchema->doc = bucket->doc;
21304|    138|    mainSchema->preserve = ctxt->preserve;
21305|       |
21306|    138|    ctxt->schema = mainSchema;
21307|       |
21308|    138|    if (xmlSchemaFixupComponents(ctxt, WXS_CONSTRUCTOR(ctxt)->mainBucket) == -1)
  ------------------
  |  |  278|    138|#define WXS_CONSTRUCTOR(ctx) (ctx)->constructor
  ------------------
  |  Branch (21308:9): [True: 0, False: 138]
  ------------------
21309|      0|	goto exit_failure;
21310|       |
21311|       |    /*
21312|       |    * TODO: This is not nice, since we cannot distinguish from the
21313|       |    * result if there was an internal error or not.
21314|       |    */
21315|    198|exit:
21316|    198|    if (ctxt->nberrors != 0) {
  ------------------
  |  Branch (21316:9): [True: 71, False: 127]
  ------------------
21317|     71|	if (mainSchema) {
  ------------------
  |  Branch (21317:6): [True: 71, False: 0]
  ------------------
21318|     71|	    xmlSchemaFree(mainSchema);
21319|     71|	    mainSchema = NULL;
21320|     71|	}
21321|     71|	if (ctxt->constructor) {
  ------------------
  |  Branch (21321:6): [True: 71, False: 0]
  ------------------
21322|     71|	    xmlSchemaConstructionCtxtFree(ctxt->constructor);
21323|     71|	    ctxt->constructor = NULL;
21324|     71|	    ctxt->ownsConstructor = 0;
21325|     71|	}
21326|     71|    }
21327|    198|    ctxt->schema = NULL;
21328|    198|    return(mainSchema);
21329|      0|exit_failure:
21330|       |    /*
21331|       |    * Quite verbose, but should catch internal errors, which were
21332|       |    * not communicated.
21333|       |    */
21334|      0|    if (mainSchema) {
  ------------------
  |  Branch (21334:9): [True: 0, False: 0]
  ------------------
21335|      0|        xmlSchemaFree(mainSchema);
21336|      0|	mainSchema = NULL;
21337|      0|    }
21338|      0|    if (ctxt->constructor) {
  ------------------
  |  Branch (21338:9): [True: 0, False: 0]
  ------------------
21339|      0|	xmlSchemaConstructionCtxtFree(ctxt->constructor);
21340|      0|	ctxt->constructor = NULL;
21341|      0|	ctxt->ownsConstructor = 0;
21342|      0|    }
21343|      0|    PERROR_INT2("xmlSchemaParse",
  ------------------
  |  | 2825|      0|#define PERROR_INT2(func, msg) xmlSchemaInternalErr(ACTXT_CAST ctxt, func, msg);
  |  |  ------------------
  |  |  |  |  121|      0|#define ACTXT_CAST (xmlSchemaAbstractCtxtPtr)
  |  |  ------------------
  ------------------
21344|      0|	"An internal error occurred");
21345|      0|    ctxt->schema = NULL;
21346|      0|    return(NULL);
21347|    138|}
xmlSchemaSetParserErrors:
21362|    231|{
21363|    231|    if (ctxt == NULL)
  ------------------
  |  Branch (21363:9): [True: 0, False: 231]
  ------------------
21364|      0|        return;
21365|    231|    ctxt->error = err;
21366|    231|    ctxt->warning = warn;
21367|    231|    ctxt->errCtxt = ctx;
21368|    231|    if (ctxt->vctxt != NULL)
  ------------------
  |  Branch (21368:9): [True: 0, False: 231]
  ------------------
21369|      0|	xmlSchemaSetValidErrors(ctxt->vctxt, err, warn, ctx);
21370|    231|}
xmlSchemaSetParserStructuredErrors:
21384|     33|{
21385|     33|    if (ctxt == NULL)
  ------------------
  |  Branch (21385:9): [True: 0, False: 33]
  ------------------
21386|      0|	return;
21387|     33|    ctxt->serror = serror;
21388|     33|    ctxt->errCtxt = ctx;
21389|     33|    if (ctxt->vctxt != NULL)
  ------------------
  |  Branch (21389:9): [True: 0, False: 33]
  ------------------
21390|      0|	xmlSchemaSetValidStructuredErrors(ctxt->vctxt, serror, ctx);
21391|     33|}
xmlSchemaNewValidCtxt:
27429|     42|{
27430|     42|    xmlSchemaValidCtxtPtr ret;
27431|       |
27432|     42|    ret = (xmlSchemaValidCtxtPtr) xmlMalloc(sizeof(xmlSchemaValidCtxt));
27433|     42|    if (ret == NULL) {
  ------------------
  |  Branch (27433:9): [True: 0, False: 42]
  ------------------
27434|      0|        xmlSchemaVErrMemory(NULL, "allocating validation context", NULL);
27435|      0|        return (NULL);
27436|      0|    }
27437|     42|    memset(ret, 0, sizeof(xmlSchemaValidCtxt));
27438|     42|    ret->type = XML_SCHEMA_CTXT_VALIDATOR;
  ------------------
  |  |  359|     42|#define XML_SCHEMA_CTXT_VALIDATOR 2
  ------------------
27439|     42|    ret->dict = xmlDictCreate();
27440|     42|    ret->nodeQNames = xmlSchemaItemListCreate();
27441|     42|    ret->schema = schema;
27442|     42|    return (ret);
27443|     42|}
xmlSchemaFreeValidCtxt:
27598|     42|{
27599|     42|    if (ctxt == NULL)
  ------------------
  |  Branch (27599:9): [True: 0, False: 42]
  ------------------
27600|      0|        return;
27601|     42|    if (ctxt->value != NULL)
  ------------------
  |  Branch (27601:9): [True: 0, False: 42]
  ------------------
27602|      0|        xmlSchemaFreeValue(ctxt->value);
27603|     42|    if (ctxt->pctxt != NULL)
  ------------------
  |  Branch (27603:9): [True: 0, False: 42]
  ------------------
27604|      0|	xmlSchemaFreeParserCtxt(ctxt->pctxt);
27605|     42|    if (ctxt->idcNodes != NULL) {
  ------------------
  |  Branch (27605:9): [True: 0, False: 42]
  ------------------
27606|      0|	int i;
27607|      0|	xmlSchemaPSVIIDCNodePtr item;
27608|       |
27609|      0|	for (i = 0; i < ctxt->nbIdcNodes; i++) {
  ------------------
  |  Branch (27609:14): [True: 0, False: 0]
  ------------------
27610|      0|	    item = ctxt->idcNodes[i];
27611|      0|	    xmlFree(item->keys);
27612|      0|	    xmlFree(item);
27613|      0|	}
27614|      0|	xmlFree(ctxt->idcNodes);
27615|      0|    }
27616|     42|    if (ctxt->idcKeys != NULL) {
  ------------------
  |  Branch (27616:9): [True: 0, False: 42]
  ------------------
27617|      0|	int i;
27618|      0|	for (i = 0; i < ctxt->nbIdcKeys; i++)
  ------------------
  |  Branch (27618:14): [True: 0, False: 0]
  ------------------
27619|      0|	    xmlSchemaIDCFreeKey(ctxt->idcKeys[i]);
27620|      0|	xmlFree(ctxt->idcKeys);
27621|      0|    }
27622|       |
27623|     42|    if (ctxt->xpathStates != NULL) {
  ------------------
  |  Branch (27623:9): [True: 0, False: 42]
  ------------------
27624|      0|	xmlSchemaFreeIDCStateObjList(ctxt->xpathStates);
27625|      0|	ctxt->xpathStates = NULL;
27626|      0|    }
27627|     42|    if (ctxt->xpathStatePool != NULL) {
  ------------------
  |  Branch (27627:9): [True: 0, False: 42]
  ------------------
27628|      0|	xmlSchemaFreeIDCStateObjList(ctxt->xpathStatePool);
27629|      0|	ctxt->xpathStatePool = NULL;
27630|      0|    }
27631|       |
27632|       |    /*
27633|       |    * Augmented IDC information.
27634|       |    */
27635|     42|    if (ctxt->aidcs != NULL) {
  ------------------
  |  Branch (27635:9): [True: 0, False: 42]
  ------------------
27636|      0|	xmlSchemaIDCAugPtr cur = ctxt->aidcs, next;
27637|      0|	do {
27638|      0|	    next = cur->next;
27639|      0|	    xmlFree(cur);
27640|      0|	    cur = next;
27641|      0|	} while (cur != NULL);
  ------------------
  |  Branch (27641:11): [True: 0, False: 0]
  ------------------
27642|      0|    }
27643|     42|    if (ctxt->attrInfos != NULL) {
  ------------------
  |  Branch (27643:9): [True: 0, False: 42]
  ------------------
27644|      0|	int i;
27645|      0|	xmlSchemaAttrInfoPtr attr;
27646|       |
27647|       |	/* Just a paranoid call to the cleanup. */
27648|      0|	if (ctxt->nbAttrInfos != 0)
  ------------------
  |  Branch (27648:6): [True: 0, False: 0]
  ------------------
27649|      0|	    xmlSchemaClearAttrInfos(ctxt);
27650|      0|	for (i = 0; i < ctxt->sizeAttrInfos; i++) {
  ------------------
  |  Branch (27650:14): [True: 0, False: 0]
  ------------------
27651|      0|	    attr = ctxt->attrInfos[i];
27652|      0|	    xmlFree(attr);
27653|      0|	}
27654|      0|	xmlFree(ctxt->attrInfos);
27655|      0|    }
27656|     42|    if (ctxt->elemInfos != NULL) {
  ------------------
  |  Branch (27656:9): [True: 0, False: 42]
  ------------------
27657|      0|	int i;
27658|      0|	xmlSchemaNodeInfoPtr ei;
27659|       |
27660|      0|	for (i = 0; i < ctxt->sizeElemInfos; i++) {
  ------------------
  |  Branch (27660:14): [True: 0, False: 0]
  ------------------
27661|      0|	    ei = ctxt->elemInfos[i];
27662|      0|	    if (ei == NULL)
  ------------------
  |  Branch (27662:10): [True: 0, False: 0]
  ------------------
27663|      0|		break;
27664|      0|	    xmlSchemaClearElemInfo(ctxt, ei);
27665|      0|	    xmlFree(ei);
27666|      0|	}
27667|      0|	xmlFree(ctxt->elemInfos);
27668|      0|    }
27669|     42|    if (ctxt->nodeQNames != NULL)
  ------------------
  |  Branch (27669:9): [True: 42, False: 0]
  ------------------
27670|     42|	xmlSchemaItemListFree(ctxt->nodeQNames);
27671|     42|    if (ctxt->dict != NULL)
  ------------------
  |  Branch (27671:9): [True: 42, False: 0]
  ------------------
27672|     42|	xmlDictFree(ctxt->dict);
27673|     42|    if (ctxt->filename != NULL)
  ------------------
  |  Branch (27673:9): [True: 0, False: 42]
  ------------------
27674|      0|	xmlFree(ctxt->filename);
27675|     42|    xmlFree(ctxt);
27676|     42|}
xmlSchemaSetValidErrors:
27708|     42|{
27709|     42|    if (ctxt == NULL)
  ------------------
  |  Branch (27709:9): [True: 0, False: 42]
  ------------------
27710|      0|        return;
27711|     42|    ctxt->error = err;
27712|     42|    ctxt->warning = warn;
27713|     42|    ctxt->errCtxt = ctx;
27714|     42|    if (ctxt->pctxt != NULL)
  ------------------
  |  Branch (27714:9): [True: 0, False: 42]
  ------------------
27715|      0|	xmlSchemaSetParserErrors(ctxt->pctxt, err, warn, ctx);
27716|     42|}
xmlSchemaSetValidStructuredErrors:
27729|     42|{
27730|     42|    if (ctxt == NULL)
  ------------------
  |  Branch (27730:9): [True: 0, False: 42]
  ------------------
27731|      0|        return;
27732|     42|    ctxt->serror = serror;
27733|     42|    ctxt->error = NULL;
27734|     42|    ctxt->warning = NULL;
27735|     42|    ctxt->errCtxt = ctx;
27736|     42|    if (ctxt->pctxt != NULL)
  ------------------
  |  Branch (27736:9): [True: 0, False: 42]
  ------------------
27737|      0|	xmlSchemaSetParserStructuredErrors(ctxt->pctxt, serror, ctx);
27738|     42|}
xmlschemas.c:xmlSchemaFreeAnnot:
 3765|     88|{
 3766|     88|    if (annot == NULL)
  ------------------
  |  Branch (3766:9): [True: 0, False: 88]
  ------------------
 3767|      0|        return;
 3768|     88|    if (annot->next == NULL) {
  ------------------
  |  Branch (3768:9): [True: 88, False: 0]
  ------------------
 3769|     88|	xmlFree(annot);
 3770|     88|    } else {
 3771|      0|	xmlSchemaAnnotPtr prev;
 3772|       |
 3773|      0|	do {
 3774|      0|	    prev = annot;
 3775|      0|	    annot = annot->next;
 3776|      0|	    xmlFree(prev);
 3777|      0|	} while (annot != NULL);
  ------------------
  |  Branch (3777:11): [True: 0, False: 0]
  ------------------
 3778|      0|    }
 3779|     88|}
xmlschemas.c:xmlSchemaFreeWildcardNsSet:
 3855|     58|{
 3856|     58|    xmlSchemaWildcardNsPtr next;
 3857|       |
 3858|    172|    while (set != NULL) {
  ------------------
  |  Branch (3858:12): [True: 114, False: 58]
  ------------------
 3859|    114|	next = set->next;
 3860|    114|	xmlFree(set);
 3861|    114|	set = next;
 3862|    114|    }
 3863|     58|}
xmlschemas.c:xmlSchemaItemListFree:
 3564|  1.27k|{
 3565|  1.27k|    if (list == NULL)
  ------------------
  |  Branch (3565:9): [True: 0, False: 1.27k]
  ------------------
 3566|      0|	return;
 3567|  1.27k|    if (list->items != NULL)
  ------------------
  |  Branch (3567:9): [True: 821, False: 453]
  ------------------
 3568|    821|	xmlFree(list->items);
 3569|  1.27k|    xmlFree(list);
 3570|  1.27k|}
xmlschemas.c:xmlSchemaFreeTypeLinkList:
 3923|     25|{
 3924|     25|    xmlSchemaTypeLinkPtr next;
 3925|       |
 3926|    120|    while (link != NULL) {
  ------------------
  |  Branch (3926:12): [True: 95, False: 25]
  ------------------
 3927|     95|	next = link->next;
 3928|     95|	xmlFree(link);
 3929|     95|	link = next;
 3930|     95|    }
 3931|     25|}
xmlschemas.c:xmlSchemaBucketFreeEntry:
 3605|    183|{
 3606|    183|    xmlSchemaBucketFree((xmlSchemaBucketPtr) bucket);
 3607|    183|}
xmlschemas.c:xmlSchemaBucketFree:
 3574|    204|{
 3575|    204|    if (bucket == NULL)
  ------------------
  |  Branch (3575:9): [True: 0, False: 204]
  ------------------
 3576|      0|	return;
 3577|    204|    if (bucket->globals != NULL) {
  ------------------
  |  Branch (3577:9): [True: 204, False: 0]
  ------------------
 3578|    204|	xmlSchemaComponentListFree(bucket->globals);
 3579|    204|	xmlSchemaItemListFree(bucket->globals);
 3580|    204|    }
 3581|    204|    if (bucket->locals != NULL) {
  ------------------
  |  Branch (3581:9): [True: 204, False: 0]
  ------------------
 3582|    204|	xmlSchemaComponentListFree(bucket->locals);
 3583|    204|	xmlSchemaItemListFree(bucket->locals);
 3584|    204|    }
 3585|    204|    if (bucket->relations != NULL) {
  ------------------
  |  Branch (3585:9): [True: 39, False: 165]
  ------------------
 3586|     39|	xmlSchemaSchemaRelationPtr prev, cur = bucket->relations;
 3587|     49|	do {
 3588|     49|	    prev = cur;
 3589|     49|	    cur = cur->next;
 3590|     49|	    xmlFree(prev);
 3591|     49|	} while (cur != NULL);
  ------------------
  |  Branch (3591:11): [True: 10, False: 39]
  ------------------
 3592|     39|    }
 3593|    204|    if ((! bucket->preserveDoc) && (bucket->doc != NULL)) {
  ------------------
  |  Branch (3593:9): [True: 204, False: 0]
  |  Branch (3593:36): [True: 204, False: 0]
  ------------------
 3594|    204|	xmlFreeDoc(bucket->doc);
 3595|    204|    }
 3596|    204|    if (bucket->type == XML_SCHEMA_SCHEMA_IMPORT) {
  ------------------
  |  |  372|    204|#define XML_SCHEMA_SCHEMA_IMPORT 1
  ------------------
  |  Branch (3596:9): [True: 16, False: 188]
  ------------------
 3597|     16|	if (WXS_IMPBUCKET(bucket)->schema != NULL)
  ------------------
  |  |  202|     16|#define WXS_IMPBUCKET(b) ((xmlSchemaImportPtr) (b))
  ------------------
  |  Branch (3597:6): [True: 16, False: 0]
  ------------------
 3598|     16|	    xmlSchemaFree(WXS_IMPBUCKET(bucket)->schema);
  ------------------
  |  |  202|     16|#define WXS_IMPBUCKET(b) ((xmlSchemaImportPtr) (b))
  ------------------
 3599|     16|    }
 3600|    204|    xmlFree(bucket);
 3601|    204|}
xmlschemas.c:xmlSchemaComponentListFree:
 4095|    408|{
 4096|    408|    if ((list == NULL) || (list->nbItems == 0))
  ------------------
  |  Branch (4096:9): [True: 0, False: 408]
  |  Branch (4096:27): [True: 85, False: 323]
  ------------------
 4097|     85|	return;
 4098|    323|    {
 4099|    323|	xmlSchemaTreeItemPtr item;
 4100|    323|	xmlSchemaTreeItemPtr *items = (xmlSchemaTreeItemPtr *) list->items;
 4101|    323|	int i;
 4102|       |
 4103|  3.42k|	for (i = 0; i < list->nbItems; i++) {
  ------------------
  |  Branch (4103:14): [True: 3.09k, False: 323]
  ------------------
 4104|  3.09k|	    item = items[i];
 4105|  3.09k|	    if (item == NULL)
  ------------------
  |  Branch (4105:10): [True: 0, False: 3.09k]
  ------------------
 4106|      0|		continue;
 4107|  3.09k|	    switch (item->type) {
 4108|    162|		case XML_SCHEMA_TYPE_SIMPLE:
  ------------------
  |  Branch (4108:3): [True: 162, False: 2.93k]
  ------------------
 4109|    542|		case XML_SCHEMA_TYPE_COMPLEX:
  ------------------
  |  Branch (4109:3): [True: 380, False: 2.71k]
  ------------------
 4110|    542|		    xmlSchemaFreeType((xmlSchemaTypePtr) item);
 4111|    542|		    break;
 4112|    196|		case XML_SCHEMA_TYPE_ATTRIBUTE:
  ------------------
  |  Branch (4112:3): [True: 196, False: 2.90k]
  ------------------
 4113|    196|		    xmlSchemaFreeAttribute((xmlSchemaAttributePtr) item);
 4114|    196|		    break;
 4115|    205|		case XML_SCHEMA_TYPE_ATTRIBUTE_USE:
  ------------------
  |  Branch (4115:3): [True: 205, False: 2.89k]
  ------------------
 4116|    205|		    xmlSchemaFreeAttributeUse((xmlSchemaAttributeUsePtr) item);
 4117|    205|		    break;
 4118|      8|		case XML_SCHEMA_EXTRA_ATTR_USE_PROHIB:
  ------------------
  |  Branch (4118:3): [True: 8, False: 3.09k]
  ------------------
 4119|      8|		    xmlSchemaFreeAttributeUseProhib(
 4120|      8|			(xmlSchemaAttributeUseProhibPtr) item);
 4121|      8|		    break;
 4122|    594|		case XML_SCHEMA_TYPE_ELEMENT:
  ------------------
  |  Branch (4122:3): [True: 594, False: 2.50k]
  ------------------
 4123|    594|		    xmlSchemaFreeElement((xmlSchemaElementPtr) item);
 4124|    594|		    break;
 4125|    748|		case XML_SCHEMA_TYPE_PARTICLE:
  ------------------
  |  Branch (4125:3): [True: 748, False: 2.35k]
  ------------------
 4126|    748|		    if (item->annot != NULL)
  ------------------
  |  Branch (4126:11): [True: 0, False: 748]
  ------------------
 4127|      0|			xmlSchemaFreeAnnot(item->annot);
 4128|    748|		    xmlFree(item);
 4129|    748|		    break;
 4130|    187|		case XML_SCHEMA_TYPE_SEQUENCE:
  ------------------
  |  Branch (4130:3): [True: 187, False: 2.91k]
  ------------------
 4131|    224|		case XML_SCHEMA_TYPE_CHOICE:
  ------------------
  |  Branch (4131:3): [True: 37, False: 3.06k]
  ------------------
 4132|    234|		case XML_SCHEMA_TYPE_ALL:
  ------------------
  |  Branch (4132:3): [True: 10, False: 3.08k]
  ------------------
 4133|    234|		    xmlSchemaFreeModelGroup((xmlSchemaModelGroupPtr) item);
 4134|    234|		    break;
 4135|     40|		case XML_SCHEMA_TYPE_ATTRIBUTEGROUP:
  ------------------
  |  Branch (4135:3): [True: 40, False: 3.05k]
  ------------------
 4136|     40|		    xmlSchemaFreeAttributeGroup(
 4137|     40|			(xmlSchemaAttributeGroupPtr) item);
 4138|     40|		    break;
 4139|      9|		case XML_SCHEMA_TYPE_GROUP:
  ------------------
  |  Branch (4139:3): [True: 9, False: 3.08k]
  ------------------
 4140|      9|		    xmlSchemaFreeModelGroupDef(
 4141|      9|			(xmlSchemaModelGroupDefPtr) item);
 4142|      9|		    break;
 4143|     19|		case XML_SCHEMA_TYPE_ANY:
  ------------------
  |  Branch (4143:3): [True: 19, False: 3.07k]
  ------------------
 4144|    134|		case XML_SCHEMA_TYPE_ANY_ATTRIBUTE:
  ------------------
  |  Branch (4144:3): [True: 115, False: 2.98k]
  ------------------
 4145|    134|		    xmlSchemaFreeWildcard((xmlSchemaWildcardPtr) item);
 4146|    134|		    break;
 4147|      6|		case XML_SCHEMA_TYPE_IDC_KEY:
  ------------------
  |  Branch (4147:3): [True: 6, False: 3.09k]
  ------------------
 4148|     11|		case XML_SCHEMA_TYPE_IDC_UNIQUE:
  ------------------
  |  Branch (4148:3): [True: 5, False: 3.09k]
  ------------------
 4149|     15|		case XML_SCHEMA_TYPE_IDC_KEYREF:
  ------------------
  |  Branch (4149:3): [True: 4, False: 3.09k]
  ------------------
 4150|     15|		    xmlSchemaFreeIDC((xmlSchemaIDCPtr) item);
 4151|     15|		    break;
 4152|      0|		case XML_SCHEMA_TYPE_NOTATION:
  ------------------
  |  Branch (4152:3): [True: 0, False: 3.09k]
  ------------------
 4153|      0|		    xmlSchemaFreeNotation((xmlSchemaNotationPtr) item);
 4154|      0|		    break;
 4155|    373|		case XML_SCHEMA_EXTRA_QNAMEREF:
  ------------------
  |  Branch (4155:3): [True: 373, False: 2.72k]
  ------------------
 4156|    373|		    xmlSchemaFreeQNameRef((xmlSchemaQNameRefPtr) item);
 4157|    373|		    break;
 4158|      0|		default: {
  ------------------
  |  Branch (4158:3): [True: 0, False: 3.09k]
  ------------------
 4159|       |		    /* TODO: This should never be hit. */
 4160|      0|		    xmlSchemaPSimpleInternalErr(NULL,
 4161|      0|			"Internal error: xmlSchemaComponentListFree, "
 4162|      0|			"unexpected component type '%s'\n",
 4163|      0|			(const xmlChar *) WXS_ITEM_TYPE_NAME(item));
  ------------------
  |  |  144|      0|#define WXS_ITEM_TYPE_NAME(i) xmlSchemaGetComponentTypeStr(WXS_BASIC_CAST (i))
  |  |  ------------------
  |  |  |  |  124|      0|#define WXS_BASIC_CAST (xmlSchemaBasicItemPtr)
  |  |  ------------------
  ------------------
 4164|      0|			 }
 4165|      0|		    break;
 4166|  3.09k|	    }
 4167|  3.09k|	}
 4168|    323|	list->nbItems = 0;
 4169|    323|    }
 4170|    323|}
xmlschemas.c:xmlSchemaFreeAttribute:
 3805|    196|{
 3806|    196|    if (attr == NULL)
  ------------------
  |  Branch (3806:9): [True: 0, False: 196]
  ------------------
 3807|      0|        return;
 3808|    196|    if (attr->annot != NULL)
  ------------------
  |  Branch (3808:9): [True: 4, False: 192]
  ------------------
 3809|      4|	xmlSchemaFreeAnnot(attr->annot);
 3810|    196|    if (attr->defVal != NULL)
  ------------------
  |  Branch (3810:9): [True: 10, False: 186]
  ------------------
 3811|     10|	xmlSchemaFreeValue(attr->defVal);
 3812|    196|    xmlFree(attr);
 3813|    196|}
xmlschemas.c:xmlSchemaFreeAttributeUse:
 3823|    205|{
 3824|    205|    if (use == NULL)
  ------------------
  |  Branch (3824:9): [True: 0, False: 205]
  ------------------
 3825|      0|        return;
 3826|    205|    if (use->annot != NULL)
  ------------------
  |  Branch (3826:9): [True: 19, False: 186]
  ------------------
 3827|     19|	xmlSchemaFreeAnnot(use->annot);
 3828|    205|    if (use->defVal != NULL)
  ------------------
  |  Branch (3828:9): [True: 0, False: 205]
  ------------------
 3829|      0|	xmlSchemaFreeValue(use->defVal);
 3830|    205|    xmlFree(use);
 3831|    205|}
xmlschemas.c:xmlSchemaFreeAttributeUseProhib:
 3841|      8|{
 3842|      8|    if (prohib == NULL)
  ------------------
  |  Branch (3842:9): [True: 0, False: 8]
  ------------------
 3843|      0|        return;
 3844|      8|    xmlFree(prohib);
 3845|      8|}
xmlschemas.c:xmlSchemaFreeElement:
 3991|    594|{
 3992|    594|    if (elem == NULL)
  ------------------
  |  Branch (3992:9): [True: 0, False: 594]
  ------------------
 3993|      0|        return;
 3994|    594|    if (elem->annot != NULL)
  ------------------
  |  Branch (3994:9): [True: 27, False: 567]
  ------------------
 3995|     27|        xmlSchemaFreeAnnot(elem->annot);
 3996|    594|    if (elem->contModel != NULL)
  ------------------
  |  Branch (3996:9): [True: 0, False: 594]
  ------------------
 3997|      0|        xmlRegFreeRegexp(elem->contModel);
 3998|    594|    if (elem->defVal != NULL)
  ------------------
  |  Branch (3998:9): [True: 1, False: 593]
  ------------------
 3999|      1|	xmlSchemaFreeValue(elem->defVal);
 4000|    594|    xmlFree(elem);
 4001|    594|}
xmlschemas.c:xmlSchemaFreeModelGroup:
 4087|    234|{
 4088|    234|    if (item->annot != NULL)
  ------------------
  |  Branch (4088:9): [True: 0, False: 234]
  ------------------
 4089|      0|	xmlSchemaFreeAnnot(item->annot);
 4090|    234|    xmlFree(item);
 4091|    234|}
xmlschemas.c:xmlSchemaFreeAttributeGroup:
 3893|     40|{
 3894|     40|    if (attrGr == NULL)
  ------------------
  |  Branch (3894:9): [True: 0, False: 40]
  ------------------
 3895|      0|        return;
 3896|     40|    if (attrGr->annot != NULL)
  ------------------
  |  Branch (3896:9): [True: 0, False: 40]
  ------------------
 3897|      0|        xmlSchemaFreeAnnot(attrGr->annot);
 3898|     40|    if (attrGr->attrUses != NULL)
  ------------------
  |  Branch (3898:9): [True: 13, False: 27]
  ------------------
 3899|     13|	xmlSchemaItemListFree(WXS_LIST_CAST attrGr->attrUses);
  ------------------
  |  |  137|     13|#define WXS_LIST_CAST (xmlSchemaItemListPtr)
  ------------------
 3900|     40|    xmlFree(attrGr);
 3901|     40|}
xmlschemas.c:xmlSchemaFreeModelGroupDef:
 4073|      9|{
 4074|      9|    if (item->annot != NULL)
  ------------------
  |  Branch (4074:9): [True: 2, False: 7]
  ------------------
 4075|      2|	xmlSchemaFreeAnnot(item->annot);
 4076|      9|    xmlFree(item);
 4077|      9|}
xmlschemas.c:xmlSchemaFreeIDC:
 3956|     15|{
 3957|     15|    xmlSchemaIDCSelectPtr cur, prev;
 3958|       |
 3959|     15|    if (idcDef == NULL)
  ------------------
  |  Branch (3959:9): [True: 0, False: 15]
  ------------------
 3960|      0|	return;
 3961|     15|    if (idcDef->annot != NULL)
  ------------------
  |  Branch (3961:9): [True: 0, False: 15]
  ------------------
 3962|      0|        xmlSchemaFreeAnnot(idcDef->annot);
 3963|       |    /* Selector */
 3964|     15|    if (idcDef->selector != NULL) {
  ------------------
  |  Branch (3964:9): [True: 15, False: 0]
  ------------------
 3965|     15|	if (idcDef->selector->xpathComp != NULL)
  ------------------
  |  Branch (3965:6): [True: 15, False: 0]
  ------------------
 3966|     15|	    xmlFreePattern((xmlPatternPtr) idcDef->selector->xpathComp);
 3967|     15|	xmlFree(idcDef->selector);
 3968|     15|    }
 3969|       |    /* Fields */
 3970|     15|    if (idcDef->fields != NULL) {
  ------------------
  |  Branch (3970:9): [True: 15, False: 0]
  ------------------
 3971|     15|	cur = idcDef->fields;
 3972|     15|	do {
 3973|     15|	    prev = cur;
 3974|     15|	    cur = cur->next;
 3975|     15|	    if (prev->xpathComp != NULL)
  ------------------
  |  Branch (3975:10): [True: 15, False: 0]
  ------------------
 3976|     15|		xmlFreePattern((xmlPatternPtr) prev->xpathComp);
 3977|     15|	    xmlFree(prev);
 3978|     15|	} while (cur != NULL);
  ------------------
  |  Branch (3978:11): [True: 0, False: 15]
  ------------------
 3979|     15|    }
 3980|     15|    xmlFree(idcDef);
 3981|     15|}
xmlschemas.c:xmlSchemaFreeQNameRef:
 3911|    373|{
 3912|    373|    xmlFree(item);
 3913|    373|}
xmlschemas.c:xmlSchemaGetComponentTypeStr:
 1188|     14|{
 1189|     14|    switch (item->type) {
 1190|      0|	case XML_SCHEMA_TYPE_BASIC:
  ------------------
  |  Branch (1190:2): [True: 0, False: 14]
  ------------------
 1191|      0|	    if (WXS_IS_COMPLEX(WXS_TYPE_CAST item))
  ------------------
  |  |  213|      0|    (((i)->type == XML_SCHEMA_TYPE_COMPLEX) || \
  |  |  ------------------
  |  |  |  Branch (213:6): [True: 0, False: 0]
  |  |  ------------------
  |  |  214|      0|     ((i)->builtInType == XML_SCHEMAS_ANYTYPE))
  |  |  ------------------
  |  |  |  Branch (214:6): [True: 0, False: 0]
  |  |  ------------------
  ------------------
 1192|      0|		return(BAD_CAST "complex type definition");
  ------------------
  |  |   35|      0|#define BAD_CAST (xmlChar *)
  ------------------
 1193|      0|	    else
 1194|      0|		return(BAD_CAST "simple type definition");
  ------------------
  |  |   35|      0|#define BAD_CAST (xmlChar *)
  ------------------
 1195|     14|	default:
  ------------------
  |  Branch (1195:2): [True: 14, False: 0]
  ------------------
 1196|     14|	    return(xmlSchemaItemTypeToStr(item->type));
 1197|     14|    }
 1198|     14|}
xmlschemas.c:xmlSchemaItemTypeToStr:
 1132|     24|{
 1133|     24|    switch (type) {
 1134|      0|	case XML_SCHEMA_TYPE_BASIC:
  ------------------
  |  Branch (1134:2): [True: 0, False: 24]
  ------------------
 1135|      0|	    return(BAD_CAST "simple type definition");
  ------------------
  |  |   35|      0|#define BAD_CAST (xmlChar *)
  ------------------
 1136|      0|	case XML_SCHEMA_TYPE_SIMPLE:
  ------------------
  |  Branch (1136:2): [True: 0, False: 24]
  ------------------
 1137|      0|	    return(BAD_CAST "simple type definition");
  ------------------
  |  |   35|      0|#define BAD_CAST (xmlChar *)
  ------------------
 1138|     11|	case XML_SCHEMA_TYPE_COMPLEX:
  ------------------
  |  Branch (1138:2): [True: 11, False: 13]
  ------------------
 1139|     11|	    return(BAD_CAST "complex type definition");
  ------------------
  |  |   35|     11|#define BAD_CAST (xmlChar *)
  ------------------
 1140|      9|	case XML_SCHEMA_TYPE_ELEMENT:
  ------------------
  |  Branch (1140:2): [True: 9, False: 15]
  ------------------
 1141|      9|	    return(BAD_CAST "element declaration");
  ------------------
  |  |   35|      9|#define BAD_CAST (xmlChar *)
  ------------------
 1142|      2|	case XML_SCHEMA_TYPE_ATTRIBUTE_USE:
  ------------------
  |  Branch (1142:2): [True: 2, False: 22]
  ------------------
 1143|      2|	    return(BAD_CAST "attribute use");
  ------------------
  |  |   35|      2|#define BAD_CAST (xmlChar *)
  ------------------
 1144|      2|	case XML_SCHEMA_TYPE_ATTRIBUTE:
  ------------------
  |  Branch (1144:2): [True: 2, False: 22]
  ------------------
 1145|      2|	    return(BAD_CAST "attribute declaration");
  ------------------
  |  |   35|      2|#define BAD_CAST (xmlChar *)
  ------------------
 1146|      0|	case XML_SCHEMA_TYPE_GROUP:
  ------------------
  |  Branch (1146:2): [True: 0, False: 24]
  ------------------
 1147|      0|	    return(BAD_CAST "model group definition");
  ------------------
  |  |   35|      0|#define BAD_CAST (xmlChar *)
  ------------------
 1148|      0|	case XML_SCHEMA_TYPE_ATTRIBUTEGROUP:
  ------------------
  |  Branch (1148:2): [True: 0, False: 24]
  ------------------
 1149|      0|	    return(BAD_CAST "attribute group definition");
  ------------------
  |  |   35|      0|#define BAD_CAST (xmlChar *)
  ------------------
 1150|      0|	case XML_SCHEMA_TYPE_NOTATION:
  ------------------
  |  Branch (1150:2): [True: 0, False: 24]
  ------------------
 1151|      0|	    return(BAD_CAST "notation declaration");
  ------------------
  |  |   35|      0|#define BAD_CAST (xmlChar *)
  ------------------
 1152|      0|	case XML_SCHEMA_TYPE_SEQUENCE:
  ------------------
  |  Branch (1152:2): [True: 0, False: 24]
  ------------------
 1153|      0|	    return(BAD_CAST "model group (sequence)");
  ------------------
  |  |   35|      0|#define BAD_CAST (xmlChar *)
  ------------------
 1154|      0|	case XML_SCHEMA_TYPE_CHOICE:
  ------------------
  |  Branch (1154:2): [True: 0, False: 24]
  ------------------
 1155|      0|	    return(BAD_CAST "model group (choice)");
  ------------------
  |  |   35|      0|#define BAD_CAST (xmlChar *)
  ------------------
 1156|      0|	case XML_SCHEMA_TYPE_ALL:
  ------------------
  |  Branch (1156:2): [True: 0, False: 24]
  ------------------
 1157|      0|	    return(BAD_CAST "model group (all)");
  ------------------
  |  |   35|      0|#define BAD_CAST (xmlChar *)
  ------------------
 1158|      0|	case XML_SCHEMA_TYPE_PARTICLE:
  ------------------
  |  Branch (1158:2): [True: 0, False: 24]
  ------------------
 1159|      0|	    return(BAD_CAST "particle");
  ------------------
  |  |   35|      0|#define BAD_CAST (xmlChar *)
  ------------------
 1160|      0|	case XML_SCHEMA_TYPE_IDC_UNIQUE:
  ------------------
  |  Branch (1160:2): [True: 0, False: 24]
  ------------------
 1161|      0|	    return(BAD_CAST "unique identity-constraint");
  ------------------
  |  |   35|      0|#define BAD_CAST (xmlChar *)
  ------------------
 1162|       |	    /* return(BAD_CAST "IDC (unique)"); */
 1163|      0|	case XML_SCHEMA_TYPE_IDC_KEY:
  ------------------
  |  Branch (1163:2): [True: 0, False: 24]
  ------------------
 1164|      0|	    return(BAD_CAST "key identity-constraint");
  ------------------
  |  |   35|      0|#define BAD_CAST (xmlChar *)
  ------------------
 1165|       |	    /* return(BAD_CAST "IDC (key)"); */
 1166|      0|	case XML_SCHEMA_TYPE_IDC_KEYREF:
  ------------------
  |  Branch (1166:2): [True: 0, False: 24]
  ------------------
 1167|      0|	    return(BAD_CAST "keyref identity-constraint");
  ------------------
  |  |   35|      0|#define BAD_CAST (xmlChar *)
  ------------------
 1168|       |	    /* return(BAD_CAST "IDC (keyref)"); */
 1169|      0|	case XML_SCHEMA_TYPE_ANY:
  ------------------
  |  Branch (1169:2): [True: 0, False: 24]
  ------------------
 1170|      0|	    return(BAD_CAST "wildcard (any)");
  ------------------
  |  |   35|      0|#define BAD_CAST (xmlChar *)
  ------------------
 1171|      0|	case XML_SCHEMA_EXTRA_QNAMEREF:
  ------------------
  |  Branch (1171:2): [True: 0, False: 24]
  ------------------
 1172|      0|	    return(BAD_CAST "[helper component] QName reference");
  ------------------
  |  |   35|      0|#define BAD_CAST (xmlChar *)
  ------------------
 1173|      0|	case XML_SCHEMA_EXTRA_ATTR_USE_PROHIB:
  ------------------
  |  Branch (1173:2): [True: 0, False: 24]
  ------------------
 1174|      0|	    return(BAD_CAST "[helper component] attribute use prohibition");
  ------------------
  |  |   35|      0|#define BAD_CAST (xmlChar *)
  ------------------
 1175|      0|	default:
  ------------------
  |  Branch (1175:2): [True: 0, False: 24]
  ------------------
 1176|      0|	    return(BAD_CAST "Not a schema component");
  ------------------
  |  |   35|      0|#define BAD_CAST (xmlChar *)
  ------------------
 1177|     24|    }
 1178|     24|}
xmlschemas.c:xmlSchemaParserCtxtCreate:
 9918|    231|{
 9919|    231|    xmlSchemaParserCtxtPtr ret;
 9920|       |
 9921|    231|    ret = (xmlSchemaParserCtxtPtr) xmlMalloc(sizeof(xmlSchemaParserCtxt));
 9922|    231|    if (ret == NULL) {
  ------------------
  |  Branch (9922:9): [True: 0, False: 231]
  ------------------
 9923|      0|        xmlSchemaPErrMemory(NULL, "allocating schema parser context",
 9924|      0|                            NULL);
 9925|      0|        return (NULL);
 9926|      0|    }
 9927|    231|    memset(ret, 0, sizeof(xmlSchemaParserCtxt));
 9928|    231|    ret->type = XML_SCHEMA_CTXT_PARSER;
  ------------------
  |  |  358|    231|#define XML_SCHEMA_CTXT_PARSER 1
  ------------------
 9929|    231|    ret->attrProhibs = xmlSchemaItemListCreate();
 9930|    231|    if (ret->attrProhibs == NULL) {
  ------------------
  |  Branch (9930:9): [True: 0, False: 231]
  ------------------
 9931|      0|	xmlFree(ret);
 9932|      0|	return(NULL);
 9933|      0|    }
 9934|    231|    return(ret);
 9935|    231|}
xmlschemas.c:xmlSchemaConstructionCtxtFree:
 9863|    198|{
 9864|       |    /*
 9865|       |    * After the construction context has been freed, there will be
 9866|       |    * no schema graph available any more. Only the schema buckets
 9867|       |    * will stay alive, which are put into the "schemasImports" and
 9868|       |    * "includes" slots of the xmlSchema.
 9869|       |    */
 9870|    198|    if (con->buckets != NULL)
  ------------------
  |  Branch (9870:9): [True: 198, False: 0]
  ------------------
 9871|    198|	xmlSchemaItemListFree(con->buckets);
 9872|    198|    if (con->pending != NULL)
  ------------------
  |  Branch (9872:9): [True: 198, False: 0]
  ------------------
 9873|    198|	xmlSchemaItemListFree(con->pending);
 9874|    198|    if (con->substGroups != NULL)
  ------------------
  |  Branch (9874:9): [True: 0, False: 198]
  ------------------
 9875|      0|	xmlHashFree(con->substGroups, xmlSchemaSubstGroupFreeEntry);
 9876|    198|    if (con->redefs != NULL)
  ------------------
  |  Branch (9876:9): [True: 0, False: 198]
  ------------------
 9877|      0|	xmlSchemaRedefListFree(con->redefs);
 9878|    198|    if (con->dict != NULL)
  ------------------
  |  Branch (9878:9): [True: 198, False: 0]
  ------------------
 9879|    198|	xmlDictFree(con->dict);
 9880|    198|    xmlFree(con);
 9881|    198|}
xmlschemas.c:xmlSchemaSubstGroupFreeEntry:
 5639|      6|{
 5640|      6|    xmlSchemaSubstGroupFree((xmlSchemaSubstGroupPtr) group);
 5641|      6|}
xmlschemas.c:xmlSchemaSubstGroupFree:
 5629|      6|{
 5630|      6|    if (group == NULL)
  ------------------
  |  Branch (5630:9): [True: 0, False: 6]
  ------------------
 5631|      0|	return;
 5632|      6|    if (group->members != NULL)
  ------------------
  |  Branch (5632:9): [True: 6, False: 0]
  ------------------
 5633|      6|	xmlSchemaItemListFree(group->members);
 5634|      6|    xmlFree(group);
 5635|      6|}
xmlschemas.c:xmlSchemaErr4Line:
 2089|     69|{
 2090|     69|    xmlStructuredErrorFunc schannel = NULL;
 2091|     69|    xmlGenericErrorFunc channel = NULL;
 2092|     69|    void *data = NULL;
 2093|       |
 2094|     69|    if (ctxt != NULL) {
  ------------------
  |  Branch (2094:9): [True: 69, False: 0]
  ------------------
 2095|     69|	if (ctxt->type == XML_SCHEMA_CTXT_VALIDATOR) {
  ------------------
  |  |  359|     69|#define XML_SCHEMA_CTXT_VALIDATOR 2
  ------------------
  |  Branch (2095:6): [True: 0, False: 69]
  ------------------
 2096|      0|	    xmlSchemaValidCtxtPtr vctxt = (xmlSchemaValidCtxtPtr) ctxt;
 2097|      0|	    const char *file = NULL;
 2098|      0|	    int col = 0;
 2099|      0|	    if (errorLevel != XML_ERR_WARNING) {
  ------------------
  |  Branch (2099:10): [True: 0, False: 0]
  ------------------
 2100|      0|		vctxt->nberrors++;
 2101|      0|		vctxt->err = error;
 2102|      0|		channel = vctxt->error;
 2103|      0|	    } else {
 2104|      0|		channel = vctxt->warning;
 2105|      0|	    }
 2106|      0|	    schannel = vctxt->serror;
 2107|      0|	    data = vctxt->errCtxt;
 2108|       |
 2109|       |	    /*
 2110|       |	    * Error node. If we specify a line number, then
 2111|       |	    * do not channel any node to the error function.
 2112|       |	    */
 2113|      0|	    if (line == 0) {
  ------------------
  |  Branch (2113:10): [True: 0, False: 0]
  ------------------
 2114|      0|		if ((node == NULL) &&
  ------------------
  |  Branch (2114:7): [True: 0, False: 0]
  ------------------
 2115|      0|		    (vctxt->depth >= 0) &&
  ------------------
  |  Branch (2115:7): [True: 0, False: 0]
  ------------------
 2116|      0|		    (vctxt->inode != NULL)) {
  ------------------
  |  Branch (2116:7): [True: 0, False: 0]
  ------------------
 2117|      0|		    node = vctxt->inode->node;
 2118|      0|		}
 2119|       |		/*
 2120|       |		* Get filename and line if no node-tree.
 2121|       |		*/
 2122|      0|		if ((node == NULL) &&
  ------------------
  |  Branch (2122:7): [True: 0, False: 0]
  ------------------
 2123|      0|		    (vctxt->parserCtxt != NULL) &&
  ------------------
  |  Branch (2123:7): [True: 0, False: 0]
  ------------------
 2124|      0|		    (vctxt->parserCtxt->input != NULL)) {
  ------------------
  |  Branch (2124:7): [True: 0, False: 0]
  ------------------
 2125|      0|		    file = vctxt->parserCtxt->input->filename;
 2126|      0|                    if (vctxt->inode != NULL) {
  ------------------
  |  Branch (2126:25): [True: 0, False: 0]
  ------------------
 2127|      0|		        line = vctxt->inode->nodeLine;
 2128|      0|                        col = 0;
 2129|      0|                    } else {
 2130|       |                        /* This is inaccurate. */
 2131|      0|		        line = vctxt->parserCtxt->input->line;
 2132|      0|		        col = vctxt->parserCtxt->input->col;
 2133|      0|                    }
 2134|      0|		}
 2135|      0|	    } else {
 2136|       |		/*
 2137|       |		* Override the given node's (if any) position
 2138|       |		* and channel only the given line number.
 2139|       |		*/
 2140|      0|		node = NULL;
 2141|       |		/*
 2142|       |		* Get filename.
 2143|       |		*/
 2144|      0|		if (vctxt->doc != NULL)
  ------------------
  |  Branch (2144:7): [True: 0, False: 0]
  ------------------
 2145|      0|		    file = (const char *) vctxt->doc->URL;
 2146|      0|		else if ((vctxt->parserCtxt != NULL) &&
  ------------------
  |  Branch (2146:12): [True: 0, False: 0]
  ------------------
 2147|      0|		    (vctxt->parserCtxt->input != NULL))
  ------------------
  |  Branch (2147:7): [True: 0, False: 0]
  ------------------
 2148|      0|		    file = vctxt->parserCtxt->input->filename;
 2149|      0|	    }
 2150|      0|	    if (vctxt->locFunc != NULL) {
  ------------------
  |  Branch (2150:10): [True: 0, False: 0]
  ------------------
 2151|      0|	        if ((file == NULL) || (line == 0)) {
  ------------------
  |  Branch (2151:14): [True: 0, False: 0]
  |  Branch (2151:32): [True: 0, False: 0]
  ------------------
 2152|      0|		    unsigned long l;
 2153|      0|		    const char *f;
 2154|      0|		    vctxt->locFunc(vctxt->locCtxt, &f, &l);
 2155|      0|		    if (file == NULL)
  ------------------
  |  Branch (2155:11): [True: 0, False: 0]
  ------------------
 2156|      0|		        file = f;
 2157|      0|		    if (line == 0)
  ------------------
  |  Branch (2157:11): [True: 0, False: 0]
  ------------------
 2158|      0|		        line = (int) l;
 2159|      0|		}
 2160|      0|	    }
 2161|      0|	    if ((file == NULL) && (vctxt->filename != NULL))
  ------------------
  |  Branch (2161:10): [True: 0, False: 0]
  |  Branch (2161:28): [True: 0, False: 0]
  ------------------
 2162|      0|	        file = vctxt->filename;
 2163|       |
 2164|      0|	    __xmlRaiseError(schannel, channel, data, ctxt,
 2165|      0|		node, XML_FROM_SCHEMASV,
 2166|      0|		error, errorLevel, file, line,
 2167|      0|		(const char *) str1, (const char *) str2,
 2168|      0|		(const char *) str3, 0, col, msg, str1, str2, str3, str4);
 2169|       |
 2170|     69|	} else if (ctxt->type == XML_SCHEMA_CTXT_PARSER) {
  ------------------
  |  |  358|     69|#define XML_SCHEMA_CTXT_PARSER 1
  ------------------
  |  Branch (2170:13): [True: 69, False: 0]
  ------------------
 2171|     69|	    xmlSchemaParserCtxtPtr pctxt = (xmlSchemaParserCtxtPtr) ctxt;
 2172|     69|	    if (errorLevel != XML_ERR_WARNING) {
  ------------------
  |  Branch (2172:10): [True: 67, False: 2]
  ------------------
 2173|     67|		pctxt->nberrors++;
 2174|     67|		pctxt->err = error;
 2175|     67|		channel = pctxt->error;
 2176|     67|	    } else {
 2177|      2|		channel = pctxt->warning;
 2178|      2|	    }
 2179|     69|	    schannel = pctxt->serror;
 2180|     69|	    data = pctxt->errCtxt;
 2181|     69|	    __xmlRaiseError(schannel, channel, data, ctxt,
 2182|     69|		node, XML_FROM_SCHEMASP, error,
 2183|     69|		errorLevel, NULL, 0,
 2184|     69|		(const char *) str1, (const char *) str2,
 2185|     69|		(const char *) str3, 0, 0, msg, str1, str2, str3, str4);
 2186|     69|	} else {
 2187|      0|	    TODO
  ------------------
  |  |  100|      0|    xmlGenericError(xmlGenericErrorContext,				\
  |  |  ------------------
  |  |  |  |  875|      0|  #define xmlGenericError XML_GLOBAL_MACRO(xmlGenericError)
  |  |  |  |  ------------------
  |  |  |  |  |  |  500|      0|  #define XML_GLOBAL_MACRO(name) (*__##name())
  |  |  |  |  ------------------
  |  |  ------------------
  |  |                   xmlGenericError(xmlGenericErrorContext,				\
  |  |  ------------------
  |  |  |  |  876|      0|  #define xmlGenericErrorContext XML_GLOBAL_MACRO(xmlGenericErrorContext)
  |  |  |  |  ------------------
  |  |  |  |  |  |  500|      0|  #define XML_GLOBAL_MACRO(name) (*__##name())
  |  |  |  |  ------------------
  |  |  ------------------
  |  |  101|      0|	    "Unimplemented block at %s:%d\n",				\
  |  |  102|      0|            __FILE__, __LINE__);
  ------------------
 2188|      0|	}
 2189|     69|    }
 2190|     69|}
xmlschemas.c:xmlSchemaCustomErr:
 2413|     42|{
 2414|     42|    xmlSchemaCustomErr4(actxt, error, node, item,
 2415|     42|	message, str1, str2, NULL, NULL);
 2416|     42|}
xmlschemas.c:xmlSchemaFormatQName:
 1309|    131|{
 1310|    131|    FREE_AND_NULL(*buf)
  ------------------
  |  |  320|    131|#define FREE_AND_NULL(str) if ((str) != NULL) { xmlFree((xmlChar *) (str)); str = NULL; }
  |  |  ------------------
  |  |  |  Branch (320:32): [True: 0, False: 131]
  |  |  ------------------
  ------------------
 1311|    131|    if (namespaceName != NULL) {
  ------------------
  |  Branch (1311:9): [True: 87, False: 44]
  ------------------
 1312|     87|	*buf = xmlStrdup(BAD_CAST "{");
  ------------------
  |  |   35|     87|#define BAD_CAST (xmlChar *)
  ------------------
 1313|     87|	*buf = xmlStrcat(*buf, namespaceName);
 1314|     87|	*buf = xmlStrcat(*buf, BAD_CAST "}");
  ------------------
  |  |   35|     87|#define BAD_CAST (xmlChar *)
  ------------------
 1315|     87|    }
 1316|    131|    if (localName != NULL) {
  ------------------
  |  Branch (1316:9): [True: 131, False: 0]
  ------------------
 1317|    131|	if (namespaceName == NULL)
  ------------------
  |  Branch (1317:6): [True: 44, False: 87]
  ------------------
 1318|     44|	    return(localName);
 1319|     87|	*buf = xmlStrcat(*buf, localName);
 1320|     87|    } else {
 1321|      0|	*buf = xmlStrcat(*buf, BAD_CAST "(NULL)");
  ------------------
  |  |   35|      0|#define BAD_CAST (xmlChar *)
  ------------------
 1322|      0|    }
 1323|     87|    return ((const xmlChar *) *buf);
 1324|    131|}
xmlschemas.c:xmlSchemaCustomErr4:
 2388|     46|{
 2389|     46|    xmlChar *msg = NULL;
 2390|       |
 2391|     46|    if ((node == NULL) && (item != NULL) &&
  ------------------
  |  Branch (2391:9): [True: 36, False: 10]
  |  Branch (2391:27): [True: 5, False: 31]
  ------------------
 2392|     46|	(actxt->type == XML_SCHEMA_CTXT_PARSER)) {
  ------------------
  |  |  358|      5|#define XML_SCHEMA_CTXT_PARSER 1
  ------------------
  |  Branch (2392:2): [True: 5, False: 0]
  ------------------
 2393|      5|	node = WXS_ITEM_NODE(item);
  ------------------
  |  |  142|      5|#define WXS_ITEM_NODE(i) xmlSchemaGetComponentNode(WXS_BASIC_CAST (i))
  |  |  ------------------
  |  |  |  |  124|      5|#define WXS_BASIC_CAST (xmlSchemaBasicItemPtr)
  |  |  ------------------
  ------------------
 2394|      5|	xmlSchemaFormatItemForReport(&msg, NULL, item, NULL);
 2395|      5|	msg = xmlStrcat(msg, BAD_CAST ": ");
  ------------------
  |  |   35|      5|#define BAD_CAST (xmlChar *)
  ------------------
 2396|      5|    } else
 2397|     41|	xmlSchemaFormatNodeForError(&msg, actxt, node);
 2398|     46|    msg = xmlStrcat(msg, (const xmlChar *) message);
 2399|     46|    msg = xmlStrcat(msg, BAD_CAST ".\n");
  ------------------
  |  |   35|     46|#define BAD_CAST (xmlChar *)
  ------------------
 2400|     46|    xmlSchemaErr4(actxt, error, node,
 2401|     46|	(const char *) msg, str1, str2, str3, str4);
 2402|     46|    FREE_AND_NULL(msg)
  ------------------
  |  |  320|     46|#define FREE_AND_NULL(str) if ((str) != NULL) { xmlFree((xmlChar *) (str)); str = NULL; }
  |  |  ------------------
  |  |  |  Branch (320:32): [True: 46, False: 0]
  |  |  ------------------
  ------------------
 2403|     46|}
xmlschemas.c:xmlSchemaGetComponentNode:
 1212|     23|{
 1213|     23|    switch (item->type) {
 1214|      3|	case XML_SCHEMA_TYPE_ELEMENT:
  ------------------
  |  Branch (1214:2): [True: 3, False: 20]
  ------------------
 1215|      3|	    return (((xmlSchemaElementPtr) item)->node);
 1216|      0|	case XML_SCHEMA_TYPE_ATTRIBUTE:
  ------------------
  |  Branch (1216:2): [True: 0, False: 23]
  ------------------
 1217|      0|	    return (((xmlSchemaAttributePtr) item)->node);
 1218|     12|	case XML_SCHEMA_TYPE_COMPLEX:
  ------------------
  |  Branch (1218:2): [True: 12, False: 11]
  ------------------
 1219|     12|	case XML_SCHEMA_TYPE_SIMPLE:
  ------------------
  |  Branch (1219:2): [True: 0, False: 23]
  ------------------
 1220|     12|	    return (((xmlSchemaTypePtr) item)->node);
 1221|      0|	case XML_SCHEMA_TYPE_ANY:
  ------------------
  |  Branch (1221:2): [True: 0, False: 23]
  ------------------
 1222|      0|	case XML_SCHEMA_TYPE_ANY_ATTRIBUTE:
  ------------------
  |  Branch (1222:2): [True: 0, False: 23]
  ------------------
 1223|      0|	    return (((xmlSchemaWildcardPtr) item)->node);
 1224|      8|	case XML_SCHEMA_TYPE_PARTICLE:
  ------------------
  |  Branch (1224:2): [True: 8, False: 15]
  ------------------
 1225|      8|	    return (((xmlSchemaParticlePtr) item)->node);
 1226|      0|	case XML_SCHEMA_TYPE_SEQUENCE:
  ------------------
  |  Branch (1226:2): [True: 0, False: 23]
  ------------------
 1227|      0|	case XML_SCHEMA_TYPE_CHOICE:
  ------------------
  |  Branch (1227:2): [True: 0, False: 23]
  ------------------
 1228|      0|	case XML_SCHEMA_TYPE_ALL:
  ------------------
  |  Branch (1228:2): [True: 0, False: 23]
  ------------------
 1229|      0|	    return (((xmlSchemaModelGroupPtr) item)->node);
 1230|      0|	case XML_SCHEMA_TYPE_GROUP:
  ------------------
  |  Branch (1230:2): [True: 0, False: 23]
  ------------------
 1231|      0|	    return (((xmlSchemaModelGroupDefPtr) item)->node);
 1232|      0|	case XML_SCHEMA_TYPE_ATTRIBUTEGROUP:
  ------------------
  |  Branch (1232:2): [True: 0, False: 23]
  ------------------
 1233|      0|	    return (((xmlSchemaAttributeGroupPtr) item)->node);
 1234|      0|	case XML_SCHEMA_TYPE_IDC_UNIQUE:
  ------------------
  |  Branch (1234:2): [True: 0, False: 23]
  ------------------
 1235|      0|	case XML_SCHEMA_TYPE_IDC_KEY:
  ------------------
  |  Branch (1235:2): [True: 0, False: 23]
  ------------------
 1236|      0|	case XML_SCHEMA_TYPE_IDC_KEYREF:
  ------------------
  |  Branch (1236:2): [True: 0, False: 23]
  ------------------
 1237|      0|	    return (((xmlSchemaIDCPtr) item)->node);
 1238|      0|	case XML_SCHEMA_EXTRA_QNAMEREF:
  ------------------
  |  Branch (1238:2): [True: 0, False: 23]
  ------------------
 1239|      0|	    return(((xmlSchemaQNameRefPtr) item)->node);
 1240|       |	/* TODO: What to do with NOTATIONs?
 1241|       |	case XML_SCHEMA_TYPE_NOTATION:
 1242|       |	    return (((xmlSchemaNotationPtr) item)->node);
 1243|       |	*/
 1244|      0|	case XML_SCHEMA_TYPE_ATTRIBUTE_USE:
  ------------------
  |  Branch (1244:2): [True: 0, False: 23]
  ------------------
 1245|      0|	    return (((xmlSchemaAttributeUsePtr) item)->node);
 1246|      0|	default:
  ------------------
  |  Branch (1246:2): [True: 0, False: 23]
  ------------------
 1247|      0|	    return (NULL);
 1248|     23|    }
 1249|     23|}
xmlschemas.c:xmlSchemaFormatItemForReport:
 1626|     66|{
 1627|     66|    xmlChar *str = NULL;
 1628|     66|    int named = 1;
 1629|       |
 1630|     66|    if (*buf != NULL) {
  ------------------
  |  Branch (1630:9): [True: 0, False: 66]
  ------------------
 1631|      0|	xmlFree(*buf);
 1632|      0|	*buf = NULL;
 1633|      0|    }
 1634|       |
 1635|     66|    if (itemDes != NULL) {
  ------------------
  |  Branch (1635:9): [True: 0, False: 66]
  ------------------
 1636|      0|	*buf = xmlStrdup(itemDes);
 1637|     66|    } else if (item != NULL) {
  ------------------
  |  Branch (1637:16): [True: 25, False: 41]
  ------------------
 1638|     25|	switch (item->type) {
 1639|      0|	case XML_SCHEMA_TYPE_BASIC: {
  ------------------
  |  Branch (1639:2): [True: 0, False: 25]
  ------------------
 1640|      0|	    xmlSchemaTypePtr type = WXS_TYPE_CAST item;
  ------------------
  |  |  127|      0|#define WXS_TYPE_CAST (xmlSchemaTypePtr)
  ------------------
 1641|       |
 1642|      0|	    if (WXS_IS_ATOMIC(type))
  ------------------
  |  |  270|      0|#define WXS_IS_ATOMIC(t) (t->flags & XML_SCHEMAS_TYPE_VARIETY_ATOMIC)
  |  |  ------------------
  |  |  |  |  460|      0|#define XML_SCHEMAS_TYPE_VARIETY_ATOMIC    1 << 8
  |  |  ------------------
  |  |  |  Branch (270:26): [True: 0, False: 0]
  |  |  ------------------
  ------------------
 1643|      0|		*buf = xmlStrdup(BAD_CAST "atomic type 'xs:");
  ------------------
  |  |   35|      0|#define BAD_CAST (xmlChar *)
  ------------------
 1644|      0|	    else if (WXS_IS_LIST(type))
  ------------------
  |  |  272|      0|#define WXS_IS_LIST(t) (t->flags & XML_SCHEMAS_TYPE_VARIETY_LIST)
  |  |  ------------------
  |  |  |  |  448|      0|#define XML_SCHEMAS_TYPE_VARIETY_LIST    1 << 6
  |  |  ------------------
  |  |  |  Branch (272:24): [True: 0, False: 0]
  |  |  ------------------
  ------------------
 1645|      0|		*buf = xmlStrdup(BAD_CAST "list type 'xs:");
  ------------------
  |  |   35|      0|#define BAD_CAST (xmlChar *)
  ------------------
 1646|      0|	    else if (WXS_IS_UNION(type))
  ------------------
  |  |  274|      0|#define WXS_IS_UNION(t) (t->flags & XML_SCHEMAS_TYPE_VARIETY_UNION)
  |  |  ------------------
  |  |  |  |  454|      0|#define XML_SCHEMAS_TYPE_VARIETY_UNION    1 << 7
  |  |  ------------------
  |  |  |  Branch (274:25): [True: 0, False: 0]
  |  |  ------------------
  ------------------
 1647|      0|		*buf = xmlStrdup(BAD_CAST "union type 'xs:");
  ------------------
  |  |   35|      0|#define BAD_CAST (xmlChar *)
  ------------------
 1648|      0|	    else
 1649|      0|		*buf = xmlStrdup(BAD_CAST "simple type 'xs:");
  ------------------
  |  |   35|      0|#define BAD_CAST (xmlChar *)
  ------------------
 1650|      0|	    *buf = xmlStrcat(*buf, type->name);
 1651|      0|	    *buf = xmlStrcat(*buf, BAD_CAST "'");
  ------------------
  |  |   35|      0|#define BAD_CAST (xmlChar *)
  ------------------
 1652|      0|	    }
 1653|      0|	    break;
 1654|      0|	case XML_SCHEMA_TYPE_SIMPLE: {
  ------------------
  |  Branch (1654:2): [True: 0, False: 25]
  ------------------
 1655|      0|	    xmlSchemaTypePtr type = WXS_TYPE_CAST item;
  ------------------
  |  |  127|      0|#define WXS_TYPE_CAST (xmlSchemaTypePtr)
  ------------------
 1656|       |
 1657|      0|	    if (type->flags & XML_SCHEMAS_TYPE_GLOBAL) {
  ------------------
  |  |  426|      0|#define XML_SCHEMAS_TYPE_GLOBAL                1 << 3
  ------------------
  |  Branch (1657:10): [True: 0, False: 0]
  ------------------
 1658|      0|		*buf = xmlStrdup(BAD_CAST"");
  ------------------
  |  |   35|      0|#define BAD_CAST (xmlChar *)
  ------------------
 1659|      0|	    } else {
 1660|      0|		*buf = xmlStrdup(BAD_CAST "local ");
  ------------------
  |  |   35|      0|#define BAD_CAST (xmlChar *)
  ------------------
 1661|      0|	    }
 1662|      0|	    if (WXS_IS_ATOMIC(type))
  ------------------
  |  |  270|      0|#define WXS_IS_ATOMIC(t) (t->flags & XML_SCHEMAS_TYPE_VARIETY_ATOMIC)
  |  |  ------------------
  |  |  |  |  460|      0|#define XML_SCHEMAS_TYPE_VARIETY_ATOMIC    1 << 8
  |  |  ------------------
  |  |  |  Branch (270:26): [True: 0, False: 0]
  |  |  ------------------
  ------------------
 1663|      0|		*buf = xmlStrcat(*buf, BAD_CAST "atomic type");
  ------------------
  |  |   35|      0|#define BAD_CAST (xmlChar *)
  ------------------
 1664|      0|	    else if (WXS_IS_LIST(type))
  ------------------
  |  |  272|      0|#define WXS_IS_LIST(t) (t->flags & XML_SCHEMAS_TYPE_VARIETY_LIST)
  |  |  ------------------
  |  |  |  |  448|      0|#define XML_SCHEMAS_TYPE_VARIETY_LIST    1 << 6
  |  |  ------------------
  |  |  |  Branch (272:24): [True: 0, False: 0]
  |  |  ------------------
  ------------------
 1665|      0|		*buf = xmlStrcat(*buf, BAD_CAST "list type");
  ------------------
  |  |   35|      0|#define BAD_CAST (xmlChar *)
  ------------------
 1666|      0|	    else if (WXS_IS_UNION(type))
  ------------------
  |  |  274|      0|#define WXS_IS_UNION(t) (t->flags & XML_SCHEMAS_TYPE_VARIETY_UNION)
  |  |  ------------------
  |  |  |  |  454|      0|#define XML_SCHEMAS_TYPE_VARIETY_UNION    1 << 7
  |  |  ------------------
  |  |  |  Branch (274:25): [True: 0, False: 0]
  |  |  ------------------
  ------------------
 1667|      0|		*buf = xmlStrcat(*buf, BAD_CAST "union type");
  ------------------
  |  |   35|      0|#define BAD_CAST (xmlChar *)
  ------------------
 1668|      0|	    else
 1669|      0|		*buf = xmlStrcat(*buf, BAD_CAST "simple type");
  ------------------
  |  |   35|      0|#define BAD_CAST (xmlChar *)
  ------------------
 1670|      0|	    if (type->flags & XML_SCHEMAS_TYPE_GLOBAL) {
  ------------------
  |  |  426|      0|#define XML_SCHEMAS_TYPE_GLOBAL                1 << 3
  ------------------
  |  Branch (1670:10): [True: 0, False: 0]
  ------------------
 1671|      0|		*buf = xmlStrcat(*buf, BAD_CAST " '");
  ------------------
  |  |   35|      0|#define BAD_CAST (xmlChar *)
  ------------------
 1672|      0|		*buf = xmlStrcat(*buf, type->name);
 1673|      0|		*buf = xmlStrcat(*buf, BAD_CAST "'");
  ------------------
  |  |   35|      0|#define BAD_CAST (xmlChar *)
  ------------------
 1674|      0|	    }
 1675|      0|	    }
 1676|      0|	    break;
 1677|     14|	case XML_SCHEMA_TYPE_COMPLEX: {
  ------------------
  |  Branch (1677:2): [True: 14, False: 11]
  ------------------
 1678|     14|	    xmlSchemaTypePtr type = WXS_TYPE_CAST item;
  ------------------
  |  |  127|     14|#define WXS_TYPE_CAST (xmlSchemaTypePtr)
  ------------------
 1679|       |
 1680|     14|	    if (type->flags & XML_SCHEMAS_TYPE_GLOBAL)
  ------------------
  |  |  426|     14|#define XML_SCHEMAS_TYPE_GLOBAL                1 << 3
  ------------------
  |  Branch (1680:10): [True: 4, False: 10]
  ------------------
 1681|      4|		*buf = xmlStrdup(BAD_CAST "");
  ------------------
  |  |   35|      4|#define BAD_CAST (xmlChar *)
  ------------------
 1682|     10|	    else
 1683|     10|		*buf = xmlStrdup(BAD_CAST "local ");
  ------------------
  |  |   35|     10|#define BAD_CAST (xmlChar *)
  ------------------
 1684|     14|	    *buf = xmlStrcat(*buf, BAD_CAST "complex type");
  ------------------
  |  |   35|     14|#define BAD_CAST (xmlChar *)
  ------------------
 1685|     14|	    if (type->flags & XML_SCHEMAS_TYPE_GLOBAL) {
  ------------------
  |  |  426|     14|#define XML_SCHEMAS_TYPE_GLOBAL                1 << 3
  ------------------
  |  Branch (1685:10): [True: 4, False: 10]
  ------------------
 1686|      4|		*buf = xmlStrcat(*buf, BAD_CAST " '");
  ------------------
  |  |   35|      4|#define BAD_CAST (xmlChar *)
  ------------------
 1687|      4|		*buf = xmlStrcat(*buf, type->name);
 1688|      4|		*buf = xmlStrcat(*buf, BAD_CAST "'");
  ------------------
  |  |   35|      4|#define BAD_CAST (xmlChar *)
  ------------------
 1689|      4|	    }
 1690|     14|	    }
 1691|     14|	    break;
 1692|      8|	case XML_SCHEMA_TYPE_ATTRIBUTE_USE: {
  ------------------
  |  Branch (1692:2): [True: 8, False: 17]
  ------------------
 1693|      8|		xmlSchemaAttributeUsePtr ause;
 1694|       |
 1695|      8|		ause = WXS_ATTR_USE_CAST item;
  ------------------
  |  |  131|      8|#define WXS_ATTR_USE_CAST (xmlSchemaAttributeUsePtr)
  ------------------
 1696|      8|		*buf = xmlStrdup(BAD_CAST "attribute use ");
  ------------------
  |  |   35|      8|#define BAD_CAST (xmlChar *)
  ------------------
 1697|      8|		if (WXS_ATTRUSE_DECL(ause) != NULL) {
  ------------------
  |  |  158|      8|#define WXS_ATTRUSE_DECL(au) (WXS_ATTR_USE_CAST (au))->attrDecl
  |  |  ------------------
  |  |  |  |  131|      8|#define WXS_ATTR_USE_CAST (xmlSchemaAttributeUsePtr)
  |  |  ------------------
  ------------------
  |  Branch (1697:7): [True: 6, False: 2]
  ------------------
 1698|      6|		    *buf = xmlStrcat(*buf, BAD_CAST "'");
  ------------------
  |  |   35|      6|#define BAD_CAST (xmlChar *)
  ------------------
 1699|      6|		    *buf = xmlStrcat(*buf,
 1700|      6|			xmlSchemaGetComponentQName(&str, WXS_ATTRUSE_DECL(ause)));
  ------------------
  |  |  158|      6|#define WXS_ATTRUSE_DECL(au) (WXS_ATTR_USE_CAST (au))->attrDecl
  |  |  ------------------
  |  |  |  |  131|      6|#define WXS_ATTR_USE_CAST (xmlSchemaAttributeUsePtr)
  |  |  ------------------
  ------------------
 1701|      6|		    FREE_AND_NULL(str)
  ------------------
  |  |  320|      6|#define FREE_AND_NULL(str) if ((str) != NULL) { xmlFree((xmlChar *) (str)); str = NULL; }
  |  |  ------------------
  |  |  |  Branch (320:32): [True: 0, False: 6]
  |  |  ------------------
  ------------------
 1702|      6|			*buf = xmlStrcat(*buf, BAD_CAST "'");
  ------------------
  |  |   35|      6|#define BAD_CAST (xmlChar *)
  ------------------
 1703|      6|		} else {
 1704|      2|		    *buf = xmlStrcat(*buf, BAD_CAST "(unknown)");
  ------------------
  |  |   35|      2|#define BAD_CAST (xmlChar *)
  ------------------
 1705|      2|		}
 1706|      8|	    }
 1707|      8|	    break;
 1708|      0|	case XML_SCHEMA_TYPE_ATTRIBUTE: {
  ------------------
  |  Branch (1708:2): [True: 0, False: 25]
  ------------------
 1709|      0|		xmlSchemaAttributePtr attr;
 1710|       |
 1711|      0|		attr = (xmlSchemaAttributePtr) item;
 1712|      0|		*buf = xmlStrdup(BAD_CAST "attribute decl.");
  ------------------
  |  |   35|      0|#define BAD_CAST (xmlChar *)
  ------------------
 1713|      0|		*buf = xmlStrcat(*buf, BAD_CAST " '");
  ------------------
  |  |   35|      0|#define BAD_CAST (xmlChar *)
  ------------------
 1714|      0|		*buf = xmlStrcat(*buf, xmlSchemaFormatQName(&str,
 1715|      0|		    attr->targetNamespace, attr->name));
 1716|      0|		FREE_AND_NULL(str)
  ------------------
  |  |  320|      0|#define FREE_AND_NULL(str) if ((str) != NULL) { xmlFree((xmlChar *) (str)); str = NULL; }
  |  |  ------------------
  |  |  |  Branch (320:32): [True: 0, False: 0]
  |  |  ------------------
  ------------------
 1717|      0|		    *buf = xmlStrcat(*buf, BAD_CAST "'");
  ------------------
  |  |   35|      0|#define BAD_CAST (xmlChar *)
  ------------------
 1718|      0|	    }
 1719|      0|	    break;
 1720|      0|	case XML_SCHEMA_TYPE_ATTRIBUTEGROUP:
  ------------------
  |  Branch (1720:2): [True: 0, False: 25]
  ------------------
 1721|      0|	    xmlSchemaGetComponentDesignation(buf, item);
 1722|      0|	    break;
 1723|      3|	case XML_SCHEMA_TYPE_ELEMENT: {
  ------------------
  |  Branch (1723:2): [True: 3, False: 22]
  ------------------
 1724|      3|		xmlSchemaElementPtr elem;
 1725|       |
 1726|      3|		elem = (xmlSchemaElementPtr) item;
 1727|      3|		*buf = xmlStrdup(BAD_CAST "element decl.");
  ------------------
  |  |   35|      3|#define BAD_CAST (xmlChar *)
  ------------------
 1728|      3|		*buf = xmlStrcat(*buf, BAD_CAST " '");
  ------------------
  |  |   35|      3|#define BAD_CAST (xmlChar *)
  ------------------
 1729|      3|		*buf = xmlStrcat(*buf, xmlSchemaFormatQName(&str,
 1730|      3|		    elem->targetNamespace, elem->name));
 1731|      3|		*buf = xmlStrcat(*buf, BAD_CAST "'");
  ------------------
  |  |   35|      3|#define BAD_CAST (xmlChar *)
  ------------------
 1732|      3|	    }
 1733|      3|	    break;
 1734|      0|	case XML_SCHEMA_TYPE_IDC_UNIQUE:
  ------------------
  |  Branch (1734:2): [True: 0, False: 25]
  ------------------
 1735|      0|	case XML_SCHEMA_TYPE_IDC_KEY:
  ------------------
  |  Branch (1735:2): [True: 0, False: 25]
  ------------------
 1736|      0|	case XML_SCHEMA_TYPE_IDC_KEYREF:
  ------------------
  |  Branch (1736:2): [True: 0, False: 25]
  ------------------
 1737|      0|	    if (item->type == XML_SCHEMA_TYPE_IDC_UNIQUE)
  ------------------
  |  Branch (1737:10): [True: 0, False: 0]
  ------------------
 1738|      0|		*buf = xmlStrdup(BAD_CAST "unique '");
  ------------------
  |  |   35|      0|#define BAD_CAST (xmlChar *)
  ------------------
 1739|      0|	    else if (item->type == XML_SCHEMA_TYPE_IDC_KEY)
  ------------------
  |  Branch (1739:15): [True: 0, False: 0]
  ------------------
 1740|      0|		*buf = xmlStrdup(BAD_CAST "key '");
  ------------------
  |  |   35|      0|#define BAD_CAST (xmlChar *)
  ------------------
 1741|      0|	    else
 1742|      0|		*buf = xmlStrdup(BAD_CAST "keyRef '");
  ------------------
  |  |   35|      0|#define BAD_CAST (xmlChar *)
  ------------------
 1743|      0|	    *buf = xmlStrcat(*buf, ((xmlSchemaIDCPtr) item)->name);
 1744|      0|	    *buf = xmlStrcat(*buf, BAD_CAST "'");
  ------------------
  |  |   35|      0|#define BAD_CAST (xmlChar *)
  ------------------
 1745|      0|	    break;
 1746|      0|	case XML_SCHEMA_TYPE_ANY:
  ------------------
  |  Branch (1746:2): [True: 0, False: 25]
  ------------------
 1747|      0|	case XML_SCHEMA_TYPE_ANY_ATTRIBUTE:
  ------------------
  |  Branch (1747:2): [True: 0, False: 25]
  ------------------
 1748|      0|	    *buf = xmlStrdup(xmlSchemaWildcardPCToString(
 1749|      0|		    ((xmlSchemaWildcardPtr) item)->processContents));
 1750|      0|	    *buf = xmlStrcat(*buf, BAD_CAST " wildcard");
  ------------------
  |  |   35|      0|#define BAD_CAST (xmlChar *)
  ------------------
 1751|      0|	    break;
 1752|      0|	case XML_SCHEMA_FACET_MININCLUSIVE:
  ------------------
  |  Branch (1752:2): [True: 0, False: 25]
  ------------------
 1753|      0|	case XML_SCHEMA_FACET_MINEXCLUSIVE:
  ------------------
  |  Branch (1753:2): [True: 0, False: 25]
  ------------------
 1754|      0|	case XML_SCHEMA_FACET_MAXINCLUSIVE:
  ------------------
  |  Branch (1754:2): [True: 0, False: 25]
  ------------------
 1755|      0|	case XML_SCHEMA_FACET_MAXEXCLUSIVE:
  ------------------
  |  Branch (1755:2): [True: 0, False: 25]
  ------------------
 1756|      0|	case XML_SCHEMA_FACET_TOTALDIGITS:
  ------------------
  |  Branch (1756:2): [True: 0, False: 25]
  ------------------
 1757|      0|	case XML_SCHEMA_FACET_FRACTIONDIGITS:
  ------------------
  |  Branch (1757:2): [True: 0, False: 25]
  ------------------
 1758|      0|	case XML_SCHEMA_FACET_PATTERN:
  ------------------
  |  Branch (1758:2): [True: 0, False: 25]
  ------------------
 1759|      0|	case XML_SCHEMA_FACET_ENUMERATION:
  ------------------
  |  Branch (1759:2): [True: 0, False: 25]
  ------------------
 1760|      0|	case XML_SCHEMA_FACET_WHITESPACE:
  ------------------
  |  Branch (1760:2): [True: 0, False: 25]
  ------------------
 1761|      0|	case XML_SCHEMA_FACET_LENGTH:
  ------------------
  |  Branch (1761:2): [True: 0, False: 25]
  ------------------
 1762|      0|	case XML_SCHEMA_FACET_MAXLENGTH:
  ------------------
  |  Branch (1762:2): [True: 0, False: 25]
  ------------------
 1763|      0|	case XML_SCHEMA_FACET_MINLENGTH:
  ------------------
  |  Branch (1763:2): [True: 0, False: 25]
  ------------------
 1764|      0|	    *buf = xmlStrdup(BAD_CAST "facet '");
  ------------------
  |  |   35|      0|#define BAD_CAST (xmlChar *)
  ------------------
 1765|      0|	    *buf = xmlStrcat(*buf, xmlSchemaFacetTypeToString(item->type));
 1766|      0|	    *buf = xmlStrcat(*buf, BAD_CAST "'");
  ------------------
  |  |   35|      0|#define BAD_CAST (xmlChar *)
  ------------------
 1767|      0|	    break;
 1768|      0|	case XML_SCHEMA_TYPE_GROUP: {
  ------------------
  |  Branch (1768:2): [True: 0, False: 25]
  ------------------
 1769|      0|		*buf = xmlStrdup(BAD_CAST "model group def.");
  ------------------
  |  |   35|      0|#define BAD_CAST (xmlChar *)
  ------------------
 1770|      0|		*buf = xmlStrcat(*buf, BAD_CAST " '");
  ------------------
  |  |   35|      0|#define BAD_CAST (xmlChar *)
  ------------------
 1771|      0|		*buf = xmlStrcat(*buf, xmlSchemaGetComponentQName(&str, item));
 1772|      0|		*buf = xmlStrcat(*buf, BAD_CAST "'");
  ------------------
  |  |   35|      0|#define BAD_CAST (xmlChar *)
  ------------------
 1773|      0|		FREE_AND_NULL(str)
  ------------------
  |  |  320|      0|#define FREE_AND_NULL(str) if ((str) != NULL) { xmlFree((xmlChar *) (str)); str = NULL; }
  |  |  ------------------
  |  |  |  Branch (320:32): [True: 0, False: 0]
  |  |  ------------------
  ------------------
 1774|      0|	    }
 1775|      0|	    break;
 1776|      0|	case XML_SCHEMA_TYPE_SEQUENCE:
  ------------------
  |  Branch (1776:2): [True: 0, False: 25]
  ------------------
 1777|      0|	case XML_SCHEMA_TYPE_CHOICE:
  ------------------
  |  Branch (1777:2): [True: 0, False: 25]
  ------------------
 1778|      0|	case XML_SCHEMA_TYPE_ALL:
  ------------------
  |  Branch (1778:2): [True: 0, False: 25]
  ------------------
 1779|      0|	case XML_SCHEMA_TYPE_PARTICLE:
  ------------------
  |  Branch (1779:2): [True: 0, False: 25]
  ------------------
 1780|      0|	    *buf = xmlStrdup(WXS_ITEM_TYPE_NAME(item));
  ------------------
  |  |  144|      0|#define WXS_ITEM_TYPE_NAME(i) xmlSchemaGetComponentTypeStr(WXS_BASIC_CAST (i))
  |  |  ------------------
  |  |  |  |  124|      0|#define WXS_BASIC_CAST (xmlSchemaBasicItemPtr)
  |  |  ------------------
  ------------------
 1781|      0|	    break;
 1782|      0|	case XML_SCHEMA_TYPE_NOTATION: {
  ------------------
  |  Branch (1782:2): [True: 0, False: 25]
  ------------------
 1783|      0|		*buf = xmlStrdup(WXS_ITEM_TYPE_NAME(item));
  ------------------
  |  |  144|      0|#define WXS_ITEM_TYPE_NAME(i) xmlSchemaGetComponentTypeStr(WXS_BASIC_CAST (i))
  |  |  ------------------
  |  |  |  |  124|      0|#define WXS_BASIC_CAST (xmlSchemaBasicItemPtr)
  |  |  ------------------
  ------------------
 1784|      0|		*buf = xmlStrcat(*buf, BAD_CAST " '");
  ------------------
  |  |   35|      0|#define BAD_CAST (xmlChar *)
  ------------------
 1785|      0|		*buf = xmlStrcat(*buf, xmlSchemaGetComponentQName(&str, item));
 1786|      0|		*buf = xmlStrcat(*buf, BAD_CAST "'");
  ------------------
  |  |   35|      0|#define BAD_CAST (xmlChar *)
  ------------------
 1787|      0|		FREE_AND_NULL(str);
  ------------------
  |  |  320|      0|#define FREE_AND_NULL(str) if ((str) != NULL) { xmlFree((xmlChar *) (str)); str = NULL; }
  |  |  ------------------
  |  |  |  Branch (320:32): [True: 0, False: 0]
  |  |  ------------------
  ------------------
 1788|      0|	    }
 1789|       |            /* Falls through. */
 1790|      0|	default:
  ------------------
  |  Branch (1790:2): [True: 0, False: 25]
  ------------------
 1791|      0|	    named = 0;
 1792|     25|	}
 1793|     25|    } else
 1794|     41|	named = 0;
 1795|       |
 1796|     66|    if ((named == 0) && (itemNode != NULL)) {
  ------------------
  |  Branch (1796:9): [True: 41, False: 25]
  |  Branch (1796:25): [True: 41, False: 0]
  ------------------
 1797|     41|	xmlNodePtr elem;
 1798|       |
 1799|     41|	if (itemNode->type == XML_ATTRIBUTE_NODE)
  ------------------
  |  Branch (1799:6): [True: 0, False: 41]
  ------------------
 1800|      0|	    elem = itemNode->parent;
 1801|     41|	else
 1802|     41|	    elem = itemNode;
 1803|     41|	*buf = xmlStrdup(BAD_CAST "Element '");
  ------------------
  |  |   35|     41|#define BAD_CAST (xmlChar *)
  ------------------
 1804|     41|	if (elem->ns != NULL) {
  ------------------
  |  Branch (1804:6): [True: 41, False: 0]
  ------------------
 1805|     41|	    *buf = xmlStrcat(*buf,
 1806|     41|		xmlSchemaFormatQName(&str, elem->ns->href, elem->name));
 1807|     41|	    FREE_AND_NULL(str)
  ------------------
  |  |  320|     41|#define FREE_AND_NULL(str) if ((str) != NULL) { xmlFree((xmlChar *) (str)); str = NULL; }
  |  |  ------------------
  |  |  |  Branch (320:32): [True: 41, False: 0]
  |  |  ------------------
  ------------------
 1808|     41|	} else
 1809|      0|	    *buf = xmlStrcat(*buf, elem->name);
 1810|     41|	*buf = xmlStrcat(*buf, BAD_CAST "'");
  ------------------
  |  |   35|     41|#define BAD_CAST (xmlChar *)
  ------------------
 1811|       |
 1812|     41|    }
 1813|     66|    if ((itemNode != NULL) && (itemNode->type == XML_ATTRIBUTE_NODE)) {
  ------------------
  |  Branch (1813:9): [True: 46, False: 20]
  |  Branch (1813:31): [True: 0, False: 46]
  ------------------
 1814|      0|	*buf = xmlStrcat(*buf, BAD_CAST ", attribute '");
  ------------------
  |  |   35|      0|#define BAD_CAST (xmlChar *)
  ------------------
 1815|      0|	if (itemNode->ns != NULL) {
  ------------------
  |  Branch (1815:6): [True: 0, False: 0]
  ------------------
 1816|      0|	    *buf = xmlStrcat(*buf, xmlSchemaFormatQName(&str,
 1817|      0|		itemNode->ns->href, itemNode->name));
 1818|      0|	    FREE_AND_NULL(str)
  ------------------
  |  |  320|      0|#define FREE_AND_NULL(str) if ((str) != NULL) { xmlFree((xmlChar *) (str)); str = NULL; }
  |  |  ------------------
  |  |  |  Branch (320:32): [True: 0, False: 0]
  |  |  ------------------
  ------------------
 1819|      0|	} else
 1820|      0|	    *buf = xmlStrcat(*buf, itemNode->name);
 1821|      0|	*buf = xmlStrcat(*buf, BAD_CAST "'");
  ------------------
  |  |   35|      0|#define BAD_CAST (xmlChar *)
  ------------------
 1822|      0|    }
 1823|     66|    FREE_AND_NULL(str)
  ------------------
  |  |  320|     66|#define FREE_AND_NULL(str) if ((str) != NULL) { xmlFree((xmlChar *) (str)); str = NULL; }
  |  |  ------------------
  |  |  |  Branch (320:32): [True: 0, False: 66]
  |  |  ------------------
  ------------------
 1824|       |
 1825|     66|    return (xmlEscapeFormatString(buf));
 1826|     66|}
xmlschemas.c:xmlSchemaGetComponentQName:
 1440|     23|{
 1441|     23|    return (xmlSchemaFormatQName(buf,
 1442|     23|	xmlSchemaGetComponentTargetNs((xmlSchemaBasicItemPtr) item),
 1443|     23|	xmlSchemaGetComponentName((xmlSchemaBasicItemPtr) item)));
 1444|     23|}
xmlschemas.c:xmlSchemaGetComponentTargetNs:
 1395|     25|{
 1396|     25|    if (item == NULL) {
  ------------------
  |  Branch (1396:9): [True: 0, False: 25]
  ------------------
 1397|      0|        return (NULL);
 1398|      0|    }
 1399|     25|    switch (item->type) {
 1400|      5|	case XML_SCHEMA_TYPE_ELEMENT:
  ------------------
  |  Branch (1400:2): [True: 5, False: 20]
  ------------------
 1401|      5|	    return (((xmlSchemaElementPtr) item)->targetNamespace);
 1402|      8|	case XML_SCHEMA_TYPE_ATTRIBUTE:
  ------------------
  |  Branch (1402:2): [True: 8, False: 17]
  ------------------
 1403|      8|	    return (((xmlSchemaAttributePtr) item)->targetNamespace);
 1404|      0|	case XML_SCHEMA_TYPE_ATTRIBUTEGROUP:
  ------------------
  |  Branch (1404:2): [True: 0, False: 25]
  ------------------
 1405|      0|	    return (((xmlSchemaAttributeGroupPtr) item)->targetNamespace);
 1406|      0|	case XML_SCHEMA_TYPE_BASIC:
  ------------------
  |  Branch (1406:2): [True: 0, False: 25]
  ------------------
 1407|      0|	    return (BAD_CAST "http://www.w3.org/2001/XMLSchema");
  ------------------
  |  |   35|      0|#define BAD_CAST (xmlChar *)
  ------------------
 1408|      0|	case XML_SCHEMA_TYPE_SIMPLE:
  ------------------
  |  Branch (1408:2): [True: 0, False: 25]
  ------------------
 1409|     10|	case XML_SCHEMA_TYPE_COMPLEX:
  ------------------
  |  Branch (1409:2): [True: 10, False: 15]
  ------------------
 1410|     10|	    return (((xmlSchemaTypePtr) item)->targetNamespace);
 1411|      0|	case XML_SCHEMA_TYPE_GROUP:
  ------------------
  |  Branch (1411:2): [True: 0, False: 25]
  ------------------
 1412|      0|	    return (((xmlSchemaModelGroupDefPtr) item)->targetNamespace);
 1413|      0|	case XML_SCHEMA_TYPE_IDC_KEY:
  ------------------
  |  Branch (1413:2): [True: 0, False: 25]
  ------------------
 1414|      0|	case XML_SCHEMA_TYPE_IDC_UNIQUE:
  ------------------
  |  Branch (1414:2): [True: 0, False: 25]
  ------------------
 1415|      0|	case XML_SCHEMA_TYPE_IDC_KEYREF:
  ------------------
  |  Branch (1415:2): [True: 0, False: 25]
  ------------------
 1416|      0|	    return (((xmlSchemaIDCPtr) item)->targetNamespace);
 1417|      2|	case XML_SCHEMA_TYPE_ATTRIBUTE_USE:
  ------------------
  |  Branch (1417:2): [True: 2, False: 23]
  ------------------
 1418|      2|	    if (WXS_ATTRUSE_DECL(item) != NULL) {
  ------------------
  |  |  158|      2|#define WXS_ATTRUSE_DECL(au) (WXS_ATTR_USE_CAST (au))->attrDecl
  |  |  ------------------
  |  |  |  |  131|      2|#define WXS_ATTR_USE_CAST (xmlSchemaAttributeUsePtr)
  |  |  ------------------
  ------------------
  |  Branch (1418:10): [True: 2, False: 0]
  ------------------
 1419|      2|		return(xmlSchemaGetComponentTargetNs(
 1420|      2|		    WXS_BASIC_CAST WXS_ATTRUSE_DECL(item)));
  ------------------
  |  |  124|      2|#define WXS_BASIC_CAST (xmlSchemaBasicItemPtr)
  ------------------
              		    WXS_BASIC_CAST WXS_ATTRUSE_DECL(item)));
  ------------------
  |  |  158|      2|#define WXS_ATTRUSE_DECL(au) (WXS_ATTR_USE_CAST (au))->attrDecl
  |  |  ------------------
  |  |  |  |  131|      2|#define WXS_ATTR_USE_CAST (xmlSchemaAttributeUsePtr)
  |  |  ------------------
  ------------------
 1421|      2|	    }
 1422|       |	    /* TODO: Will returning NULL break something? */
 1423|      0|	    break;
 1424|      0|	case XML_SCHEMA_EXTRA_QNAMEREF:
  ------------------
  |  Branch (1424:2): [True: 0, False: 25]
  ------------------
 1425|      0|	    return (((xmlSchemaQNameRefPtr) item)->targetNamespace);
 1426|      0|	case XML_SCHEMA_TYPE_NOTATION:
  ------------------
  |  Branch (1426:2): [True: 0, False: 25]
  ------------------
 1427|      0|	    return (((xmlSchemaNotationPtr) item)->targetNamespace);
 1428|      0|	default:
  ------------------
  |  Branch (1428:2): [True: 0, False: 25]
  ------------------
 1429|       |	    /*
 1430|       |	    * Other components cannot have names.
 1431|       |	    */
 1432|      0|	    break;
 1433|     25|    }
 1434|      0|    return (NULL);
 1435|     25|}
xmlschemas.c:xmlSchemaGetComponentName:
 1337|     25|{
 1338|     25|    if (item == NULL) {
  ------------------
  |  Branch (1338:9): [True: 0, False: 25]
  ------------------
 1339|      0|        return (NULL);
 1340|      0|    }
 1341|     25|    switch (item->type) {
 1342|      5|	case XML_SCHEMA_TYPE_ELEMENT:
  ------------------
  |  Branch (1342:2): [True: 5, False: 20]
  ------------------
 1343|      5|	    return (((xmlSchemaElementPtr) item)->name);
 1344|      8|	case XML_SCHEMA_TYPE_ATTRIBUTE:
  ------------------
  |  Branch (1344:2): [True: 8, False: 17]
  ------------------
 1345|      8|	    return (((xmlSchemaAttributePtr) item)->name);
 1346|      0|	case XML_SCHEMA_TYPE_ATTRIBUTEGROUP:
  ------------------
  |  Branch (1346:2): [True: 0, False: 25]
  ------------------
 1347|      0|	    return (((xmlSchemaAttributeGroupPtr) item)->name);
 1348|      0|	case XML_SCHEMA_TYPE_BASIC:
  ------------------
  |  Branch (1348:2): [True: 0, False: 25]
  ------------------
 1349|      0|	case XML_SCHEMA_TYPE_SIMPLE:
  ------------------
  |  Branch (1349:2): [True: 0, False: 25]
  ------------------
 1350|     10|	case XML_SCHEMA_TYPE_COMPLEX:
  ------------------
  |  Branch (1350:2): [True: 10, False: 15]
  ------------------
 1351|     10|	    return (((xmlSchemaTypePtr) item)->name);
 1352|      0|	case XML_SCHEMA_TYPE_GROUP:
  ------------------
  |  Branch (1352:2): [True: 0, False: 25]
  ------------------
 1353|      0|	    return (((xmlSchemaModelGroupDefPtr) item)->name);
 1354|      0|	case XML_SCHEMA_TYPE_IDC_KEY:
  ------------------
  |  Branch (1354:2): [True: 0, False: 25]
  ------------------
 1355|      0|	case XML_SCHEMA_TYPE_IDC_UNIQUE:
  ------------------
  |  Branch (1355:2): [True: 0, False: 25]
  ------------------
 1356|      0|	case XML_SCHEMA_TYPE_IDC_KEYREF:
  ------------------
  |  Branch (1356:2): [True: 0, False: 25]
  ------------------
 1357|      0|	    return (((xmlSchemaIDCPtr) item)->name);
 1358|      2|	case XML_SCHEMA_TYPE_ATTRIBUTE_USE:
  ------------------
  |  Branch (1358:2): [True: 2, False: 23]
  ------------------
 1359|      2|	    if (WXS_ATTRUSE_DECL(item) != NULL) {
  ------------------
  |  |  158|      2|#define WXS_ATTRUSE_DECL(au) (WXS_ATTR_USE_CAST (au))->attrDecl
  |  |  ------------------
  |  |  |  |  131|      2|#define WXS_ATTR_USE_CAST (xmlSchemaAttributeUsePtr)
  |  |  ------------------
  ------------------
  |  Branch (1359:10): [True: 2, False: 0]
  ------------------
 1360|      2|		return(xmlSchemaGetComponentName(
 1361|      2|		    WXS_BASIC_CAST WXS_ATTRUSE_DECL(item)));
  ------------------
  |  |  124|      2|#define WXS_BASIC_CAST (xmlSchemaBasicItemPtr)
  ------------------
              		    WXS_BASIC_CAST WXS_ATTRUSE_DECL(item)));
  ------------------
  |  |  158|      2|#define WXS_ATTRUSE_DECL(au) (WXS_ATTR_USE_CAST (au))->attrDecl
  |  |  ------------------
  |  |  |  |  131|      2|#define WXS_ATTR_USE_CAST (xmlSchemaAttributeUsePtr)
  |  |  ------------------
  ------------------
 1362|      2|	    } else
 1363|      0|		return(NULL);
 1364|      0|	case XML_SCHEMA_EXTRA_QNAMEREF:
  ------------------
  |  Branch (1364:2): [True: 0, False: 25]
  ------------------
 1365|      0|	    return (((xmlSchemaQNameRefPtr) item)->name);
 1366|      0|	case XML_SCHEMA_TYPE_NOTATION:
  ------------------
  |  Branch (1366:2): [True: 0, False: 25]
  ------------------
 1367|      0|	    return (((xmlSchemaNotationPtr) item)->name);
 1368|      0|	default:
  ------------------
  |  Branch (1368:2): [True: 0, False: 25]
  ------------------
 1369|       |	    /*
 1370|       |	    * Other components cannot have names.
 1371|       |	    */
 1372|      0|	    break;
 1373|     25|    }
 1374|      0|    return (NULL);
 1375|     25|}
xmlschemas.c:xmlSchemaGetComponentDesignation:
 1448|      9|{
 1449|      9|    xmlChar *str = NULL;
 1450|       |
 1451|      9|    *buf = xmlStrcat(*buf, WXS_ITEM_TYPE_NAME(item));
  ------------------
  |  |  144|      9|#define WXS_ITEM_TYPE_NAME(i) xmlSchemaGetComponentTypeStr(WXS_BASIC_CAST (i))
  |  |  ------------------
  |  |  |  |  124|      9|#define WXS_BASIC_CAST (xmlSchemaBasicItemPtr)
  |  |  ------------------
  ------------------
 1452|      9|    *buf = xmlStrcat(*buf, BAD_CAST " '");
  ------------------
  |  |   35|      9|#define BAD_CAST (xmlChar *)
  ------------------
 1453|      9|    *buf = xmlStrcat(*buf, xmlSchemaGetComponentQName(&str,
 1454|      9|	(xmlSchemaBasicItemPtr) item));
 1455|      9|    *buf = xmlStrcat(*buf, BAD_CAST "'");
  ------------------
  |  |   35|      9|#define BAD_CAST (xmlChar *)
  ------------------
 1456|      9|    FREE_AND_NULL(str);
  ------------------
  |  |  320|      9|#define FREE_AND_NULL(str) if ((str) != NULL) { xmlFree((xmlChar *) (str)); str = NULL; }
  |  |  ------------------
  |  |  |  Branch (320:32): [True: 7, False: 2]
  |  |  ------------------
  ------------------
 1457|      9|    return(*buf);
 1458|      9|}
xmlschemas.c:xmlSchemaFormatNodeForError:
 2235|     64|{
 2236|     64|    xmlChar *str = NULL;
 2237|       |
 2238|     64|    *msg = NULL;
 2239|     64|    if ((node != NULL) &&
  ------------------
  |  Branch (2239:9): [True: 33, False: 31]
  ------------------
 2240|     64|	(node->type != XML_ELEMENT_NODE) &&
  ------------------
  |  Branch (2240:2): [True: 5, False: 28]
  ------------------
 2241|     64|	(node->type != XML_ATTRIBUTE_NODE))
  ------------------
  |  Branch (2241:2): [True: 0, False: 5]
  ------------------
 2242|      0|    {
 2243|       |	/*
 2244|       |	* Don't try to format other nodes than element and
 2245|       |	* attribute nodes.
 2246|       |	* Play safe and return an empty string.
 2247|       |	*/
 2248|      0|	*msg = xmlStrdup(BAD_CAST "");
  ------------------
  |  |   35|      0|#define BAD_CAST (xmlChar *)
  ------------------
 2249|      0|	return(*msg);
 2250|      0|    }
 2251|     64|    if (node != NULL) {
  ------------------
  |  Branch (2251:9): [True: 33, False: 31]
  ------------------
 2252|       |	/*
 2253|       |	* Work on tree nodes.
 2254|       |	*/
 2255|     33|	if (node->type == XML_ATTRIBUTE_NODE) {
  ------------------
  |  Branch (2255:6): [True: 5, False: 28]
  ------------------
 2256|      5|	    xmlNodePtr elem = node->parent;
 2257|       |
 2258|      5|	    *msg = xmlStrdup(BAD_CAST "Element '");
  ------------------
  |  |   35|      5|#define BAD_CAST (xmlChar *)
  ------------------
 2259|      5|	    if (elem->ns != NULL)
  ------------------
  |  Branch (2259:10): [True: 5, False: 0]
  ------------------
 2260|      5|		*msg = xmlStrcat(*msg, xmlSchemaFormatQName(&str,
 2261|      5|		    elem->ns->href, elem->name));
 2262|      0|	    else
 2263|      0|		*msg = xmlStrcat(*msg, xmlSchemaFormatQName(&str,
 2264|      0|		    NULL, elem->name));
 2265|      5|	    FREE_AND_NULL(str);
  ------------------
  |  |  320|      5|#define FREE_AND_NULL(str) if ((str) != NULL) { xmlFree((xmlChar *) (str)); str = NULL; }
  |  |  ------------------
  |  |  |  Branch (320:32): [True: 5, False: 0]
  |  |  ------------------
  ------------------
 2266|      5|	    *msg = xmlStrcat(*msg, BAD_CAST "', ");
  ------------------
  |  |   35|      5|#define BAD_CAST (xmlChar *)
  ------------------
 2267|      5|	    *msg = xmlStrcat(*msg, BAD_CAST "attribute '");
  ------------------
  |  |   35|      5|#define BAD_CAST (xmlChar *)
  ------------------
 2268|     28|	} else {
 2269|     28|	    *msg = xmlStrdup(BAD_CAST "Element '");
  ------------------
  |  |   35|     28|#define BAD_CAST (xmlChar *)
  ------------------
 2270|     28|	}
 2271|     33|	if (node->ns != NULL)
  ------------------
  |  Branch (2271:6): [True: 29, False: 4]
  ------------------
 2272|     29|	    *msg = xmlStrcat(*msg, xmlSchemaFormatQName(&str,
 2273|     29|	    node->ns->href, node->name));
 2274|      4|	else
 2275|      4|	    *msg = xmlStrcat(*msg, xmlSchemaFormatQName(&str,
 2276|      4|	    NULL, node->name));
 2277|     33|	FREE_AND_NULL(str);
  ------------------
  |  |  320|     33|#define FREE_AND_NULL(str) if ((str) != NULL) { xmlFree((xmlChar *) (str)); str = NULL; }
  |  |  ------------------
  |  |  |  Branch (320:32): [True: 29, False: 4]
  |  |  ------------------
  ------------------
 2278|     33|	*msg = xmlStrcat(*msg, BAD_CAST "': ");
  ------------------
  |  |   35|     33|#define BAD_CAST (xmlChar *)
  ------------------
 2279|     33|    } else if (actxt->type == XML_SCHEMA_CTXT_VALIDATOR) {
  ------------------
  |  |  359|     31|#define XML_SCHEMA_CTXT_VALIDATOR 2
  ------------------
  |  Branch (2279:16): [True: 0, False: 31]
  ------------------
 2280|      0|	xmlSchemaValidCtxtPtr vctxt = (xmlSchemaValidCtxtPtr) actxt;
 2281|       |	/*
 2282|       |	* Work on node infos.
 2283|       |	*/
 2284|      0|	if (vctxt->inode->nodeType == XML_ATTRIBUTE_NODE) {
  ------------------
  |  Branch (2284:6): [True: 0, False: 0]
  ------------------
 2285|      0|	    xmlSchemaNodeInfoPtr ielem =
 2286|      0|		vctxt->elemInfos[vctxt->depth];
 2287|       |
 2288|      0|	    *msg = xmlStrdup(BAD_CAST "Element '");
  ------------------
  |  |   35|      0|#define BAD_CAST (xmlChar *)
  ------------------
 2289|      0|	    *msg = xmlStrcat(*msg, xmlSchemaFormatQName(&str,
 2290|      0|		ielem->nsName, ielem->localName));
 2291|      0|	    FREE_AND_NULL(str);
  ------------------
  |  |  320|      0|#define FREE_AND_NULL(str) if ((str) != NULL) { xmlFree((xmlChar *) (str)); str = NULL; }
  |  |  ------------------
  |  |  |  Branch (320:32): [True: 0, False: 0]
  |  |  ------------------
  ------------------
 2292|      0|	    *msg = xmlStrcat(*msg, BAD_CAST "', ");
  ------------------
  |  |   35|      0|#define BAD_CAST (xmlChar *)
  ------------------
 2293|      0|	    *msg = xmlStrcat(*msg, BAD_CAST "attribute '");
  ------------------
  |  |   35|      0|#define BAD_CAST (xmlChar *)
  ------------------
 2294|      0|	} else {
 2295|      0|	    *msg = xmlStrdup(BAD_CAST "Element '");
  ------------------
  |  |   35|      0|#define BAD_CAST (xmlChar *)
  ------------------
 2296|      0|	}
 2297|      0|	*msg = xmlStrcat(*msg, xmlSchemaFormatQName(&str,
 2298|      0|	    vctxt->inode->nsName, vctxt->inode->localName));
 2299|      0|	FREE_AND_NULL(str);
  ------------------
  |  |  320|      0|#define FREE_AND_NULL(str) if ((str) != NULL) { xmlFree((xmlChar *) (str)); str = NULL; }
  |  |  ------------------
  |  |  |  Branch (320:32): [True: 0, False: 0]
  |  |  ------------------
  ------------------
 2300|      0|	*msg = xmlStrcat(*msg, BAD_CAST "': ");
  ------------------
  |  |   35|      0|#define BAD_CAST (xmlChar *)
  ------------------
 2301|     31|    } else if (actxt->type == XML_SCHEMA_CTXT_PARSER) {
  ------------------
  |  |  358|     31|#define XML_SCHEMA_CTXT_PARSER 1
  ------------------
  |  Branch (2301:16): [True: 31, False: 0]
  ------------------
 2302|       |	/*
 2303|       |	* Hmm, no node while parsing?
 2304|       |	* Return an empty string, in case NULL will break something.
 2305|       |	*/
 2306|     31|	*msg = xmlStrdup(BAD_CAST "");
  ------------------
  |  |   35|     31|#define BAD_CAST (xmlChar *)
  ------------------
 2307|     31|    } else {
 2308|      0|	TODO
  ------------------
  |  |  100|      0|    xmlGenericError(xmlGenericErrorContext,				\
  |  |  ------------------
  |  |  |  |  875|      0|  #define xmlGenericError XML_GLOBAL_MACRO(xmlGenericError)
  |  |  |  |  ------------------
  |  |  |  |  |  |  500|      0|  #define XML_GLOBAL_MACRO(name) (*__##name())
  |  |  |  |  ------------------
  |  |  ------------------
  |  |                   xmlGenericError(xmlGenericErrorContext,				\
  |  |  ------------------
  |  |  |  |  876|      0|  #define xmlGenericErrorContext XML_GLOBAL_MACRO(xmlGenericErrorContext)
  |  |  |  |  ------------------
  |  |  |  |  |  |  500|      0|  #define XML_GLOBAL_MACRO(name) (*__##name())
  |  |  |  |  ------------------
  |  |  ------------------
  |  |  101|      0|	    "Unimplemented block at %s:%d\n",				\
  |  |  102|      0|            __FILE__, __LINE__);
  ------------------
 2309|      0|	return (NULL);
 2310|      0|    }
 2311|       |
 2312|       |    /*
 2313|       |     * xmlSchemaFormatItemForReport() also returns an escaped format
 2314|       |     * string, so do this before calling it below (in the future).
 2315|       |     */
 2316|     64|    xmlEscapeFormatString(msg);
 2317|       |
 2318|       |    /*
 2319|       |    * VAL TODO: The output of the given schema component is currently
 2320|       |    * disabled.
 2321|       |    */
 2322|       |#if 0
 2323|       |    if ((type != NULL) && (xmlSchemaIsGlobalItem(type))) {
 2324|       |	*msg = xmlStrcat(*msg, BAD_CAST " [");
 2325|       |	*msg = xmlStrcat(*msg, xmlSchemaFormatItemForReport(&str,
 2326|       |	    NULL, type, NULL, 0));
 2327|       |	FREE_AND_NULL(str)
 2328|       |	*msg = xmlStrcat(*msg, BAD_CAST "]");
 2329|       |    }
 2330|       |#endif
 2331|     64|    return (*msg);
 2332|     64|}
xmlschemas.c:xmlSchemaErr4:
 2218|     67|{
 2219|     67|    xmlSchemaErr4Line(actxt, XML_ERR_ERROR, error, node, 0,
 2220|     67|	msg, str1, str2, str3, str4);
 2221|     67|}
xmlschemas.c:xmlSchemaNewSchema:
 3320|    214|{
 3321|    214|    xmlSchemaPtr ret;
 3322|       |
 3323|    214|    ret = (xmlSchemaPtr) xmlMalloc(sizeof(xmlSchema));
 3324|    214|    if (ret == NULL) {
  ------------------
  |  Branch (3324:9): [True: 0, False: 214]
  ------------------
 3325|      0|        xmlSchemaPErrMemory(ctxt, "allocating schema", NULL);
 3326|      0|        return (NULL);
 3327|      0|    }
 3328|    214|    memset(ret, 0, sizeof(xmlSchema));
 3329|    214|    ret->dict = ctxt->dict;
 3330|    214|    xmlDictReference(ret->dict);
 3331|       |
 3332|    214|    return (ret);
 3333|    214|}
xmlschemas.c:xmlSchemaConstructionCtxtCreate:
 9885|    198|{
 9886|    198|    xmlSchemaConstructionCtxtPtr ret;
 9887|       |
 9888|    198|    ret = (xmlSchemaConstructionCtxtPtr)
 9889|    198|	xmlMalloc(sizeof(xmlSchemaConstructionCtxt));
 9890|    198|    if (ret == NULL) {
  ------------------
  |  Branch (9890:9): [True: 0, False: 198]
  ------------------
 9891|      0|        xmlSchemaPErrMemory(NULL,
 9892|      0|	    "allocating schema construction context", NULL);
 9893|      0|        return (NULL);
 9894|      0|    }
 9895|    198|    memset(ret, 0, sizeof(xmlSchemaConstructionCtxt));
 9896|       |
 9897|    198|    ret->buckets = xmlSchemaItemListCreate();
 9898|    198|    if (ret->buckets == NULL) {
  ------------------
  |  Branch (9898:9): [True: 0, False: 198]
  ------------------
 9899|      0|	xmlSchemaPErrMemory(NULL,
 9900|      0|	    "allocating list of schema buckets", NULL);
 9901|      0|	xmlFree(ret);
 9902|      0|        return (NULL);
 9903|      0|    }
 9904|    198|    ret->pending = xmlSchemaItemListCreate();
 9905|    198|    if (ret->pending == NULL) {
  ------------------
  |  Branch (9905:9): [True: 0, False: 198]
  ------------------
 9906|      0|	xmlSchemaPErrMemory(NULL,
 9907|      0|	    "allocating list of pending global components", NULL);
 9908|      0|	xmlSchemaConstructionCtxtFree(ret);
 9909|      0|        return (NULL);
 9910|      0|    }
 9911|    198|    ret->dict = dict;
 9912|    198|    xmlDictReference(dict);
 9913|    198|    return(ret);
 9914|    198|}
xmlschemas.c:xmlSchemaAddSchemaDoc:
10269|    247|{
10270|    247|    const xmlChar *targetNamespace = NULL;
10271|    247|    xmlSchemaSchemaRelationPtr relation = NULL;
10272|    247|    xmlDocPtr doc = NULL;
10273|    247|    int res = 0, err = 0, located = 0, preserveDoc = 0;
10274|    247|    xmlSchemaBucketPtr bkt = NULL;
10275|       |
10276|    247|    if (bucket != NULL)
  ------------------
  |  Branch (10276:9): [True: 247, False: 0]
  ------------------
10277|    247|	*bucket = NULL;
10278|       |
10279|    247|    switch (type) {
  ------------------
  |  Branch (10279:13): [True: 0, False: 247]
  ------------------
10280|     20|	case XML_SCHEMA_SCHEMA_IMPORT:
  ------------------
  |  |  372|     20|#define XML_SCHEMA_SCHEMA_IMPORT 1
  ------------------
  |  Branch (10280:2): [True: 20, False: 227]
  ------------------
10281|    218|	case XML_SCHEMA_SCHEMA_MAIN:
  ------------------
  |  |  371|    218|#define XML_SCHEMA_SCHEMA_MAIN 0
  ------------------
  |  Branch (10281:2): [True: 198, False: 49]
  ------------------
10282|    218|	    err = XML_SCHEMAP_SRC_IMPORT;
10283|    218|	    break;
10284|     29|	case XML_SCHEMA_SCHEMA_INCLUDE:
  ------------------
  |  |  373|     29|#define XML_SCHEMA_SCHEMA_INCLUDE 2
  ------------------
  |  Branch (10284:2): [True: 29, False: 218]
  ------------------
10285|     29|	    err = XML_SCHEMAP_SRC_INCLUDE;
10286|     29|	    break;
10287|      0|	case XML_SCHEMA_SCHEMA_REDEFINE:
  ------------------
  |  |  374|      0|#define XML_SCHEMA_SCHEMA_REDEFINE 3
  ------------------
  |  Branch (10287:2): [True: 0, False: 247]
  ------------------
10288|      0|	    err = XML_SCHEMAP_SRC_REDEFINE;
10289|      0|	    break;
10290|    247|    }
10291|       |
10292|       |
10293|       |    /* Special handling for the main schema:
10294|       |    * skip the location and relation logic and just parse the doc.
10295|       |    * We need just a bucket to be returned in this case.
10296|       |    */
10297|    247|    if ((type == XML_SCHEMA_SCHEMA_MAIN) || (! WXS_HAS_BUCKETS(pctxt)))
  ------------------
  |  |  371|    247|#define XML_SCHEMA_SCHEMA_MAIN 0
  ------------------
                  if ((type == XML_SCHEMA_SCHEMA_MAIN) || (! WXS_HAS_BUCKETS(pctxt)))
  ------------------
  |  |  280|     49|#define WXS_HAS_BUCKETS(ctx) \
  |  |  281|     49|( (WXS_CONSTRUCTOR((ctx))->buckets != NULL) && \
  |  |  ------------------
  |  |  |  |  278|     49|#define WXS_CONSTRUCTOR(ctx) (ctx)->constructor
  |  |  ------------------
  |  |  |  Branch (281:3): [True: 49, False: 0]
  |  |  |  Branch (281:48): [True: 49, False: 0]
  |  |  ------------------
  |  |  282|     49|(WXS_CONSTRUCTOR((ctx))->buckets->nbItems > 0) )
  |  |  ------------------
  |  |  |  |  278|     49|#define WXS_CONSTRUCTOR(ctx) (ctx)->constructor
  |  |  ------------------
  ------------------
  |  Branch (10297:9): [True: 198, False: 49]
  ------------------
10298|    198|	goto doc_load;
10299|       |
10300|       |    /* Note that we expect the location to be an absolute URI. */
10301|     49|    if (schemaLocation != NULL) {
  ------------------
  |  Branch (10301:9): [True: 47, False: 2]
  ------------------
10302|     47|	bkt = xmlSchemaGetSchemaBucket(pctxt, schemaLocation);
10303|     47|	if ((bkt != NULL) &&
  ------------------
  |  Branch (10303:6): [True: 4, False: 43]
  ------------------
10304|     47|	    (pctxt->constructor->bucket == bkt)) {
  ------------------
  |  Branch (10304:6): [True: 0, False: 4]
  ------------------
10305|       |	    /* Report self-imports/inclusions/redefinitions. */
10306|       |
10307|      0|	    xmlSchemaCustomErr(ACTXT_CAST pctxt, err,
  ------------------
  |  |  121|      0|#define ACTXT_CAST (xmlSchemaAbstractCtxtPtr)
  ------------------
10308|      0|		invokingNode, NULL,
10309|      0|		"The schema must not import/include/redefine itself",
10310|      0|		NULL, NULL);
10311|      0|	    goto exit;
10312|      0|	}
10313|     47|    }
10314|       |    /*
10315|       |    * Create a relation for the graph of schemas.
10316|       |    */
10317|     49|    relation = xmlSchemaSchemaRelationCreate();
10318|     49|    if (relation == NULL)
  ------------------
  |  Branch (10318:9): [True: 0, False: 49]
  ------------------
10319|      0|	return(-1);
10320|     49|    xmlSchemaSchemaRelationAddChild(pctxt->constructor->bucket,
10321|     49|	relation);
10322|     49|    relation->type = type;
10323|       |
10324|       |    /*
10325|       |    * Save the namespace import information.
10326|       |    */
10327|     49|    if (WXS_IS_BUCKET_IMPMAIN(type)) {
  ------------------
  |  |  199|     49|#define WXS_IS_BUCKET_IMPMAIN(t) (((t) == XML_SCHEMA_SCHEMA_MAIN) || \
  |  |  ------------------
  |  |  |  |  371|     49|#define XML_SCHEMA_SCHEMA_MAIN 0
  |  |  ------------------
  |  |  |  Branch (199:35): [True: 0, False: 49]
  |  |  ------------------
  |  |  200|     49|    ((t) == XML_SCHEMA_SCHEMA_IMPORT))
  |  |  ------------------
  |  |  |  |  372|     49|#define XML_SCHEMA_SCHEMA_IMPORT 1
  |  |  ------------------
  |  |  |  Branch (200:5): [True: 20, False: 29]
  |  |  ------------------
  ------------------
10328|     20|	relation->importNamespace = importNamespace;
10329|     20|	if (schemaLocation == NULL) {
  ------------------
  |  Branch (10329:6): [True: 2, False: 18]
  ------------------
10330|       |	    /*
10331|       |	    * No location; this is just an import of the namespace.
10332|       |	    * Note that we don't assign a bucket to the relation
10333|       |	    * in this case.
10334|       |	    */
10335|      2|	    goto exit;
10336|      2|	}
10337|     18|	targetNamespace = importNamespace;
10338|     18|    }
10339|       |
10340|       |    /* Did we already fetch the doc? */
10341|     47|    if (bkt != NULL) {
  ------------------
  |  Branch (10341:9): [True: 4, False: 43]
  ------------------
10342|      4|	if ((WXS_IS_BUCKET_IMPMAIN(type)) && (! bkt->imported)) {
  ------------------
  |  |  199|      4|#define WXS_IS_BUCKET_IMPMAIN(t) (((t) == XML_SCHEMA_SCHEMA_MAIN) || \
  |  |  ------------------
  |  |  |  |  371|      4|#define XML_SCHEMA_SCHEMA_MAIN 0
  |  |  ------------------
  |  |  |  Branch (199:35): [True: 0, False: 4]
  |  |  ------------------
  |  |  200|      4|    ((t) == XML_SCHEMA_SCHEMA_IMPORT))
  |  |  ------------------
  |  |  |  |  372|      4|#define XML_SCHEMA_SCHEMA_IMPORT 1
  |  |  ------------------
  |  |  |  Branch (200:5): [True: 0, False: 4]
  |  |  ------------------
  ------------------
  |  Branch (10342:39): [True: 0, False: 0]
  ------------------
10343|       |	    /*
10344|       |	    * We included/redefined and then try to import a schema,
10345|       |	    * but the new location provided for import was different.
10346|       |	    */
10347|      0|	    if (schemaLocation == NULL)
  ------------------
  |  Branch (10347:10): [True: 0, False: 0]
  ------------------
10348|      0|		schemaLocation = BAD_CAST "in_memory_buffer";
  ------------------
  |  |   35|      0|#define BAD_CAST (xmlChar *)
  ------------------
10349|      0|	    if (!xmlStrEqual(schemaLocation,
  ------------------
  |  Branch (10349:10): [True: 0, False: 0]
  ------------------
10350|      0|		bkt->schemaLocation)) {
10351|      0|		xmlSchemaCustomErr(ACTXT_CAST pctxt, err,
  ------------------
  |  |  121|      0|#define ACTXT_CAST (xmlSchemaAbstractCtxtPtr)
  ------------------
10352|      0|		    invokingNode, NULL,
10353|      0|		    "The schema document '%s' cannot be imported, since "
10354|      0|		    "it was already included or redefined",
10355|      0|		    schemaLocation, NULL);
10356|      0|		goto exit;
10357|      0|	    }
10358|      4|	} else if ((! WXS_IS_BUCKET_IMPMAIN(type)) && (bkt->imported)) {
  ------------------
  |  |  199|      4|#define WXS_IS_BUCKET_IMPMAIN(t) (((t) == XML_SCHEMA_SCHEMA_MAIN) || \
  |  |  ------------------
  |  |  |  |  371|      4|#define XML_SCHEMA_SCHEMA_MAIN 0
  |  |  ------------------
  |  |  |  Branch (199:35): [True: 0, False: 4]
  |  |  ------------------
  |  |  200|      4|    ((t) == XML_SCHEMA_SCHEMA_IMPORT))
  |  |  ------------------
  |  |  |  |  372|      4|#define XML_SCHEMA_SCHEMA_IMPORT 1
  |  |  ------------------
  |  |  |  Branch (200:5): [True: 0, False: 4]
  |  |  ------------------
  ------------------
  |  Branch (10358:48): [True: 1, False: 3]
  ------------------
10359|       |	    /*
10360|       |	    * We imported and then try to include/redefine a schema,
10361|       |	    * but the new location provided for the include/redefine
10362|       |	    * was different.
10363|       |	    */
10364|      1|	    if (schemaLocation == NULL)
  ------------------
  |  Branch (10364:10): [True: 0, False: 1]
  ------------------
10365|      0|		schemaLocation = BAD_CAST "in_memory_buffer";
  ------------------
  |  |   35|      0|#define BAD_CAST (xmlChar *)
  ------------------
10366|      1|	    if (!xmlStrEqual(schemaLocation,
  ------------------
  |  Branch (10366:10): [True: 0, False: 1]
  ------------------
10367|      1|		bkt->schemaLocation)) {
10368|      0|		xmlSchemaCustomErr(ACTXT_CAST pctxt, err,
  ------------------
  |  |  121|      0|#define ACTXT_CAST (xmlSchemaAbstractCtxtPtr)
  ------------------
10369|      0|		    invokingNode, NULL,
10370|      0|		    "The schema document '%s' cannot be included or "
10371|      0|		    "redefined, since it was already imported",
10372|      0|		    schemaLocation, NULL);
10373|      0|		goto exit;
10374|      0|	    }
10375|      1|	}
10376|      4|    }
10377|       |
10378|     47|    if (WXS_IS_BUCKET_IMPMAIN(type)) {
  ------------------
  |  |  199|     47|#define WXS_IS_BUCKET_IMPMAIN(t) (((t) == XML_SCHEMA_SCHEMA_MAIN) || \
  |  |  ------------------
  |  |  |  |  371|     47|#define XML_SCHEMA_SCHEMA_MAIN 0
  |  |  ------------------
  |  |  |  Branch (199:35): [True: 0, False: 47]
  |  |  ------------------
  |  |  200|     47|    ((t) == XML_SCHEMA_SCHEMA_IMPORT))
  |  |  ------------------
  |  |  |  |  372|     47|#define XML_SCHEMA_SCHEMA_IMPORT 1
  |  |  ------------------
  |  |  |  Branch (200:5): [True: 18, False: 29]
  |  |  ------------------
  ------------------
10379|       |	/*
10380|       |	* Given that the schemaLocation [attribute] is only a hint, it is open
10381|       |	* to applications to ignore all but the first <import> for a given
10382|       |	* namespace, regardless of the `actual value` of schemaLocation, but
10383|       |	* such a strategy risks missing useful information when new
10384|       |	* schemaLocations are offered.
10385|       |	*
10386|       |	* We will use the first <import> that comes with a location.
10387|       |	* Further <import>s *with* a location, will result in an error.
10388|       |	* TODO: Better would be to just report a warning here, but
10389|       |	* we'll try it this way until someone complains.
10390|       |	*
10391|       |	* Schema Document Location Strategy:
10392|       |	* 3 Based on the namespace name, identify an existing schema document,
10393|       |	* either as a resource which is an XML document or a <schema> element
10394|       |	* information item, in some local schema repository;
10395|       |	* 5 Attempt to resolve the namespace name to locate such a resource.
10396|       |	*
10397|       |	* NOTE: (3) and (5) are not supported.
10398|       |	*/
10399|     18|	if (bkt != NULL) {
  ------------------
  |  Branch (10399:6): [True: 0, False: 18]
  ------------------
10400|      0|	    relation->bucket = bkt;
10401|      0|	    goto exit;
10402|      0|	}
10403|     18|	bkt = xmlSchemaGetSchemaBucketByTNS(pctxt,
10404|     18|	    importNamespace, 1);
10405|       |
10406|     18|	if (bkt != NULL) {
  ------------------
  |  Branch (10406:6): [True: 0, False: 18]
  ------------------
10407|      0|	    relation->bucket = bkt;
10408|      0|	    if (bkt->schemaLocation == NULL) {
  ------------------
  |  Branch (10408:10): [True: 0, False: 0]
  ------------------
10409|       |		/* First given location of the schema; load the doc. */
10410|      0|		bkt->schemaLocation = schemaLocation;
10411|      0|	    } else {
10412|      0|		if (!xmlStrEqual(schemaLocation,
  ------------------
  |  Branch (10412:7): [True: 0, False: 0]
  ------------------
10413|      0|		    bkt->schemaLocation)) {
10414|       |		    /*
10415|       |		    * Additional location given; just skip it.
10416|       |		    * URGENT TODO: We should report a warning here.
10417|       |		    * res = XML_SCHEMAP_SRC_IMPORT;
10418|       |		    */
10419|      0|		    if (schemaLocation == NULL)
  ------------------
  |  Branch (10419:11): [True: 0, False: 0]
  ------------------
10420|      0|			schemaLocation = BAD_CAST "in_memory_buffer";
  ------------------
  |  |   35|      0|#define BAD_CAST (xmlChar *)
  ------------------
10421|       |
10422|      0|		    xmlSchemaCustomWarning(ACTXT_CAST pctxt,
  ------------------
  |  |  121|      0|#define ACTXT_CAST (xmlSchemaAbstractCtxtPtr)
  ------------------
10423|      0|			XML_SCHEMAP_WARN_SKIP_SCHEMA,
10424|      0|			invokingNode, NULL,
10425|      0|			"Skipping import of schema located at '%s' for the "
10426|      0|			"namespace '%s', since this namespace was already "
10427|      0|			"imported with the schema located at '%s'",
10428|      0|			schemaLocation, importNamespace, bkt->schemaLocation);
10429|      0|		}
10430|      0|		goto exit;
10431|      0|	    }
10432|      0|	}
10433|       |	/*
10434|       |	* No bucket + first location: load the doc and create a
10435|       |	* bucket.
10436|       |	*/
10437|     29|    } else {
10438|       |	/* <include> and <redefine> */
10439|     29|	if (bkt != NULL) {
  ------------------
  |  Branch (10439:6): [True: 4, False: 25]
  ------------------
10440|       |
10441|      4|	    if ((bkt->origTargetNamespace == NULL) &&
  ------------------
  |  Branch (10441:10): [True: 3, False: 1]
  ------------------
10442|      4|		(bkt->targetNamespace != sourceTargetNamespace)) {
  ------------------
  |  Branch (10442:3): [True: 2, False: 1]
  ------------------
10443|      2|		xmlSchemaBucketPtr chamel;
10444|       |
10445|       |		/*
10446|       |		* Chameleon include/redefine: skip loading only if it was
10447|       |		* already build for the targetNamespace of the including
10448|       |		* schema.
10449|       |		*/
10450|       |		/*
10451|       |		* URGENT TODO: If the schema is a chameleon-include then copy
10452|       |		* the components into the including schema and modify the
10453|       |		* targetNamespace of those components, do nothing otherwise.
10454|       |		* NOTE: This is currently worked-around by compiling the
10455|       |		* chameleon for every distinct including targetNamespace; thus
10456|       |		* not performant at the moment.
10457|       |		* TODO: Check when the namespace in wildcards for chameleons
10458|       |		* needs to be converted: before we built wildcard intersections
10459|       |		* or after.
10460|       |		*   Answer: after!
10461|       |		*/
10462|      2|		chamel = xmlSchemaGetChameleonSchemaBucket(pctxt,
10463|      2|		    schemaLocation, sourceTargetNamespace);
10464|      2|		if (chamel != NULL) {
  ------------------
  |  Branch (10464:7): [True: 1, False: 1]
  ------------------
10465|       |		    /* A fitting chameleon was already parsed; NOP. */
10466|      1|		    relation->bucket = chamel;
10467|      1|		    goto exit;
10468|      1|		}
10469|       |		/*
10470|       |		* We need to parse the chameleon again for a different
10471|       |		* targetNamespace.
10472|       |		* CHAMELEON TODO: Optimize this by only parsing the
10473|       |		* chameleon once, and then copying the components to
10474|       |		* the new targetNamespace.
10475|       |		*/
10476|      1|		bkt = NULL;
10477|      2|	    } else {
10478|      2|		relation->bucket = bkt;
10479|      2|		goto exit;
10480|      2|	    }
10481|      4|	}
10482|     29|    }
10483|     44|    if ((bkt != NULL) && (bkt->doc != NULL)) {
  ------------------
  |  Branch (10483:9): [True: 0, False: 44]
  |  Branch (10483:26): [True: 0, False: 0]
  ------------------
10484|      0|	PERROR_INT("xmlSchemaAddSchemaDoc",
  ------------------
  |  | 2824|      0|#define PERROR_INT(func, msg) xmlSchemaInternalErr(ACTXT_CAST pctxt, func, msg);
  |  |  ------------------
  |  |  |  |  121|      0|#define ACTXT_CAST (xmlSchemaAbstractCtxtPtr)
  |  |  ------------------
  ------------------
10485|      0|	    "trying to load a schema doc, but a doc is already "
10486|      0|	    "assigned to the schema bucket");
10487|      0|	goto exit_failure;
10488|      0|    }
10489|       |
10490|    242|doc_load:
10491|       |    /*
10492|       |    * Load the document.
10493|       |    */
10494|    242|    if (schemaDoc != NULL) {
  ------------------
  |  Branch (10494:9): [True: 0, False: 242]
  ------------------
10495|      0|	doc = schemaDoc;
10496|       |	/* Don' free this one, since it was provided by the caller. */
10497|      0|	preserveDoc = 1;
10498|       |	/* TODO: Does the context or the doc hold the location? */
10499|      0|	if (schemaDoc->URL != NULL)
  ------------------
  |  Branch (10499:6): [True: 0, False: 0]
  ------------------
10500|      0|	    schemaLocation = xmlDictLookup(pctxt->dict,
10501|      0|		schemaDoc->URL, -1);
10502|      0|        else
10503|      0|	    schemaLocation = BAD_CAST "in_memory_buffer";
  ------------------
  |  |   35|      0|#define BAD_CAST (xmlChar *)
  ------------------
10504|    242|    } else if ((schemaLocation != NULL) || (schemaBuffer != NULL)) {
  ------------------
  |  Branch (10504:16): [True: 242, False: 0]
  |  Branch (10504:44): [True: 0, False: 0]
  ------------------
10505|    242|	xmlParserCtxtPtr parserCtxt;
10506|       |
10507|    242|	parserCtxt = xmlNewParserCtxt();
10508|    242|	if (parserCtxt == NULL) {
  ------------------
  |  Branch (10508:6): [True: 0, False: 242]
  ------------------
10509|      0|	    xmlSchemaPErrMemory(NULL, "xmlSchemaGetDoc, "
10510|      0|		"allocating a parser context", NULL);
10511|      0|	    goto exit_failure;
10512|      0|	}
10513|    242|	if ((pctxt->dict != NULL) && (parserCtxt->dict != NULL)) {
  ------------------
  |  Branch (10513:6): [True: 242, False: 0]
  |  Branch (10513:31): [True: 242, False: 0]
  ------------------
10514|       |	    /*
10515|       |	    * TODO: Do we have to burden the schema parser dict with all
10516|       |	    * the content of the schema doc?
10517|       |	    */
10518|    242|	    xmlDictFree(parserCtxt->dict);
10519|    242|	    parserCtxt->dict = pctxt->dict;
10520|    242|	    xmlDictReference(parserCtxt->dict);
10521|    242|	}
10522|    242|	if (schemaLocation != NULL) {
  ------------------
  |  Branch (10522:6): [True: 242, False: 0]
  ------------------
10523|       |	    /* Parse from file. */
10524|    242|	    doc = xmlCtxtReadFile(parserCtxt, (const char *) schemaLocation,
10525|    242|		NULL, SCHEMAS_PARSE_OPTIONS);
  ------------------
  |  |  586|    242|#define SCHEMAS_PARSE_OPTIONS XML_PARSE_NOENT
  ------------------
10526|    242|	} else if (schemaBuffer != NULL) {
  ------------------
  |  Branch (10526:13): [True: 0, False: 0]
  ------------------
10527|       |	    /* Parse from memory buffer. */
10528|      0|	    doc = xmlCtxtReadMemory(parserCtxt, schemaBuffer, schemaBufferLen,
10529|      0|		NULL, NULL, SCHEMAS_PARSE_OPTIONS);
  ------------------
  |  |  586|      0|#define SCHEMAS_PARSE_OPTIONS XML_PARSE_NOENT
  ------------------
10530|      0|	    schemaLocation = BAD_CAST "in_memory_buffer";
  ------------------
  |  |   35|      0|#define BAD_CAST (xmlChar *)
  ------------------
10531|      0|	    if (doc != NULL)
  ------------------
  |  Branch (10531:10): [True: 0, False: 0]
  ------------------
10532|      0|		doc->URL = xmlStrdup(schemaLocation);
10533|      0|	}
10534|       |	/*
10535|       |	* For <import>:
10536|       |	* 2.1 The referent is (a fragment of) a resource which is an
10537|       |	* XML document (see clause 1.1), which in turn corresponds to
10538|       |	* a <schema> element information item in a well-formed information
10539|       |	* set, which in turn corresponds to a valid schema.
10540|       |	* TODO: (2.1) fragments of XML documents are not supported.
10541|       |	*
10542|       |	* 2.2 The referent is a <schema> element information item in
10543|       |	* a well-formed information set, which in turn corresponds
10544|       |	* to a valid schema.
10545|       |	* TODO: (2.2) is not supported.
10546|       |	*/
10547|    242|	if (doc == NULL) {
  ------------------
  |  Branch (10547:6): [True: 36, False: 206]
  ------------------
10548|     36|	    const xmlError *lerr;
10549|     36|	    lerr = xmlGetLastError();
10550|       |	    /*
10551|       |	    * Check if this a parser error, or if the document could
10552|       |	    * just not be located.
10553|       |	    * TODO: Try to find specific error codes to react only on
10554|       |	    * localisation failures.
10555|       |	    */
10556|     36|	    if ((lerr == NULL) || (lerr->domain != XML_FROM_IO)) {
  ------------------
  |  Branch (10556:10): [True: 4, False: 32]
  |  Branch (10556:28): [True: 32, False: 0]
  ------------------
10557|       |		/*
10558|       |		* We assume a parser error here.
10559|       |		*/
10560|     36|		located = 1;
10561|       |		/* TODO: Error code ?? */
10562|     36|		res = XML_SCHEMAP_SRC_IMPORT_2_1;
10563|     36|		xmlSchemaCustomErr(ACTXT_CAST pctxt, res,
  ------------------
  |  |  121|     36|#define ACTXT_CAST (xmlSchemaAbstractCtxtPtr)
  ------------------
10564|     36|		    invokingNode, NULL,
10565|     36|		    "Failed to parse the XML resource '%s'",
10566|     36|		    schemaLocation, NULL);
10567|     36|	    }
10568|     36|	}
10569|    242|	xmlFreeParserCtxt(parserCtxt);
10570|    242|	if ((doc == NULL) && located)
  ------------------
  |  Branch (10570:6): [True: 36, False: 206]
  |  Branch (10570:23): [True: 36, False: 0]
  ------------------
10571|     36|	    goto exit_error;
10572|    242|    } else {
10573|      0|	xmlSchemaPErr(pctxt, NULL,
10574|      0|	    XML_SCHEMAP_NOTHING_TO_PARSE,
10575|      0|	    "No information for parsing was provided with the "
10576|      0|	    "given schema parser context.\n",
10577|      0|	    NULL, NULL);
10578|      0|	goto exit_failure;
10579|      0|    }
10580|       |    /*
10581|       |    * Preprocess the document.
10582|       |    */
10583|    206|    if (doc != NULL) {
  ------------------
  |  Branch (10583:9): [True: 206, False: 0]
  ------------------
10584|    206|	xmlNodePtr docElem = NULL;
10585|       |
10586|    206|	located = 1;
10587|    206|	docElem = xmlDocGetRootElement(doc);
10588|    206|	if (docElem == NULL) {
  ------------------
  |  Branch (10588:6): [True: 0, False: 206]
  ------------------
10589|      0|	    xmlSchemaCustomErr(ACTXT_CAST pctxt, XML_SCHEMAP_NOROOT,
  ------------------
  |  |  121|      0|#define ACTXT_CAST (xmlSchemaAbstractCtxtPtr)
  ------------------
10590|      0|		invokingNode, NULL,
10591|      0|		"The document '%s' has no document element",
10592|      0|		schemaLocation, NULL);
10593|      0|	    goto exit_error;
10594|      0|	}
10595|       |	/*
10596|       |	* Remove all the blank text nodes.
10597|       |	*/
10598|    206|	xmlSchemaCleanupDoc(pctxt, docElem);
10599|       |	/*
10600|       |	* Check the schema's top level element.
10601|       |	*/
10602|    206|	if (!IS_SCHEMA(docElem, "schema")) {
  ------------------
  |  |  316|    206|   ((node != NULL) && (node->ns != NULL) && \
  |  |  ------------------
  |  |  |  Branch (316:5): [True: 206, False: 0]
  |  |  |  Branch (316:23): [True: 206, False: 0]
  |  |  ------------------
  |  |  317|    206|    (xmlStrEqual(node->name, (const xmlChar *) type)) && \
  |  |  ------------------
  |  |  |  Branch (317:5): [True: 206, False: 0]
  |  |  ------------------
  |  |  318|    206|    (xmlStrEqual(node->ns->href, xmlSchemaNs)))
  |  |  ------------------
  |  |  |  Branch (318:5): [True: 204, False: 2]
  |  |  ------------------
  ------------------
10603|      2|	    xmlSchemaCustomErr(ACTXT_CAST pctxt, XML_SCHEMAP_NOT_SCHEMA,
  ------------------
  |  |  121|      2|#define ACTXT_CAST (xmlSchemaAbstractCtxtPtr)
  ------------------
10604|      2|		invokingNode, NULL,
10605|      2|		"The XML document '%s' is not a schema document",
10606|      2|		schemaLocation, NULL);
10607|      2|	    goto exit_error;
10608|      2|	}
10609|       |	/*
10610|       |	* Note that we don't apply a type check for the
10611|       |	* targetNamespace value here.
10612|       |	*/
10613|    204|	targetNamespace = xmlSchemaGetProp(pctxt, docElem,
10614|    204|	    "targetNamespace");
10615|    204|    }
10616|       |
10617|       |/* after_doc_loading: */
10618|    204|    if ((bkt == NULL) && located) {
  ------------------
  |  Branch (10618:9): [True: 204, False: 0]
  |  Branch (10618:26): [True: 204, False: 0]
  ------------------
10619|       |	/* Only create a bucket if the schema was located. */
10620|    204|        bkt = xmlSchemaBucketCreate(pctxt, type,
10621|    204|	    targetNamespace);
10622|    204|	if (bkt == NULL)
  ------------------
  |  Branch (10622:6): [True: 0, False: 204]
  ------------------
10623|      0|	    goto exit_failure;
10624|    204|    }
10625|    204|    if (bkt != NULL) {
  ------------------
  |  Branch (10625:9): [True: 204, False: 0]
  ------------------
10626|    204|	bkt->schemaLocation = schemaLocation;
10627|    204|	bkt->located = located;
10628|    204|	if (doc != NULL) {
  ------------------
  |  Branch (10628:6): [True: 204, False: 0]
  ------------------
10629|    204|	    bkt->doc = doc;
10630|    204|	    bkt->targetNamespace = targetNamespace;
10631|    204|	    bkt->origTargetNamespace = targetNamespace;
10632|    204|	    if (preserveDoc)
  ------------------
  |  Branch (10632:10): [True: 0, False: 204]
  ------------------
10633|      0|		bkt->preserveDoc = 1;
10634|    204|	}
10635|    204|	if (WXS_IS_BUCKET_IMPMAIN(type))
  ------------------
  |  |  199|    204|#define WXS_IS_BUCKET_IMPMAIN(t) (((t) == XML_SCHEMA_SCHEMA_MAIN) || \
  |  |  ------------------
  |  |  |  |  371|    204|#define XML_SCHEMA_SCHEMA_MAIN 0
  |  |  ------------------
  |  |  |  Branch (199:35): [True: 167, False: 37]
  |  |  ------------------
  |  |  200|    204|    ((t) == XML_SCHEMA_SCHEMA_IMPORT))
  |  |  ------------------
  |  |  |  |  372|     37|#define XML_SCHEMA_SCHEMA_IMPORT 1
  |  |  ------------------
  |  |  |  Branch (200:5): [True: 16, False: 21]
  |  |  ------------------
  ------------------
10636|    183|	    bkt->imported++;
10637|       |	    /*
10638|       |	    * Add it to the graph of schemas.
10639|       |	    */
10640|    204|	if (relation != NULL)
  ------------------
  |  Branch (10640:6): [True: 37, False: 167]
  ------------------
10641|     37|	    relation->bucket = bkt;
10642|    204|    }
10643|       |
10644|    209|exit:
10645|       |    /*
10646|       |    * Return the bucket explicitly; this is needed for the
10647|       |    * main schema.
10648|       |    */
10649|    209|    if (bucket != NULL)
  ------------------
  |  Branch (10649:9): [True: 209, False: 0]
  ------------------
10650|    209|	*bucket = bkt;
10651|    209|    return (0);
10652|       |
10653|     38|exit_error:
10654|     38|    if ((doc != NULL) && (! preserveDoc)) {
  ------------------
  |  Branch (10654:9): [True: 2, False: 36]
  |  Branch (10654:26): [True: 2, False: 0]
  ------------------
10655|      2|	xmlFreeDoc(doc);
10656|      2|	if (bkt != NULL)
  ------------------
  |  Branch (10656:6): [True: 0, False: 2]
  ------------------
10657|      0|	    bkt->doc = NULL;
10658|      2|    }
10659|     38|    return(pctxt->err);
10660|       |
10661|      0|exit_failure:
10662|      0|    if ((doc != NULL) && (! preserveDoc)) {
  ------------------
  |  Branch (10662:9): [True: 0, False: 0]
  |  Branch (10662:26): [True: 0, False: 0]
  ------------------
10663|      0|	xmlFreeDoc(doc);
10664|      0|	if (bkt != NULL)
  ------------------
  |  Branch (10664:6): [True: 0, False: 0]
  ------------------
10665|      0|	    bkt->doc = NULL;
10666|      0|    }
10667|      0|    return (-1);
10668|    204|}
xmlschemas.c:xmlSchemaGetSchemaBucket:
 9998|     47|{
 9999|     47|    xmlSchemaBucketPtr cur;
10000|     47|    xmlSchemaItemListPtr list;
10001|       |
10002|     47|    list = pctxt->constructor->buckets;
10003|     47|    if (list->nbItems == 0)
  ------------------
  |  Branch (10003:9): [True: 0, False: 47]
  ------------------
10004|      0|	return(NULL);
10005|     47|    else {
10006|     47|	int i;
10007|    116|	for (i = 0; i < list->nbItems; i++) {
  ------------------
  |  Branch (10007:14): [True: 73, False: 43]
  ------------------
10008|     73|	    cur = (xmlSchemaBucketPtr) list->items[i];
10009|       |	    /* Pointer comparison! */
10010|     73|	    if (cur->schemaLocation == schemaLocation)
  ------------------
  |  Branch (10010:10): [True: 4, False: 69]
  ------------------
10011|      4|		return(cur);
10012|     73|	}
10013|     47|    }
10014|     43|    return(NULL);
10015|     47|}
xmlschemas.c:xmlSchemaSchemaRelationCreate:
 9828|     49|{
 9829|     49|    xmlSchemaSchemaRelationPtr ret;
 9830|       |
 9831|     49|    ret = (xmlSchemaSchemaRelationPtr)
 9832|     49|	xmlMalloc(sizeof(xmlSchemaSchemaRelation));
 9833|     49|    if (ret == NULL) {
  ------------------
  |  Branch (9833:9): [True: 0, False: 49]
  ------------------
 9834|      0|	xmlSchemaPErrMemory(NULL, "allocating schema relation", NULL);
 9835|      0|	return(NULL);
 9836|      0|    }
 9837|     49|    memset(ret, 0, sizeof(xmlSchemaSchemaRelation));
 9838|     49|    return(ret);
 9839|     49|}
xmlschemas.c:xmlSchemaSchemaRelationAddChild:
10200|     49|{
10201|     49|    xmlSchemaSchemaRelationPtr cur = bucket->relations;
10202|       |
10203|     49|    if (cur == NULL) {
  ------------------
  |  Branch (10203:9): [True: 39, False: 10]
  ------------------
10204|     39|	bucket->relations = rel;
10205|     39|	return;
10206|     39|    }
10207|     10|    while (cur->next != NULL)
  ------------------
  |  Branch (10207:12): [True: 0, False: 10]
  ------------------
10208|      0|	cur = cur->next;
10209|     10|    cur->next = rel;
10210|     10|}
xmlschemas.c:xmlSchemaGetSchemaBucketByTNS:
10050|     18|{
10051|     18|    xmlSchemaBucketPtr cur;
10052|     18|    xmlSchemaItemListPtr list;
10053|       |
10054|     18|    list = pctxt->constructor->buckets;
10055|     18|    if (list->nbItems == 0)
  ------------------
  |  Branch (10055:9): [True: 0, False: 18]
  ------------------
10056|      0|	return(NULL);
10057|     18|    else {
10058|     18|	int i;
10059|     42|	for (i = 0; i < list->nbItems; i++) {
  ------------------
  |  Branch (10059:14): [True: 24, False: 18]
  ------------------
10060|     24|	    cur = (xmlSchemaBucketPtr) list->items[i];
10061|     24|	    if ((! IS_BAD_SCHEMA_DOC(cur)) &&
  ------------------
  |  |10044|     24|    (((b)->doc == NULL) && ((b)->schemaLocation != NULL))
  |  |  ------------------
  |  |  |  Branch (10044:6): [True: 0, False: 24]
  |  |  |  Branch (10044:28): [True: 0, False: 0]
  |  |  ------------------
  ------------------
10062|     24|		(cur->origTargetNamespace == targetNamespace) &&
  ------------------
  |  Branch (10062:3): [True: 0, False: 24]
  ------------------
10063|     24|		((imported && cur->imported) ||
  ------------------
  |  Branch (10063:5): [True: 0, False: 0]
  |  Branch (10063:17): [True: 0, False: 0]
  ------------------
10064|      0|		 ((!imported) && (!cur->imported))))
  ------------------
  |  Branch (10064:5): [True: 0, False: 0]
  |  Branch (10064:20): [True: 0, False: 0]
  ------------------
10065|      0|		return(cur);
10066|     24|	}
10067|     18|    }
10068|     18|    return(NULL);
10069|     18|}
xmlschemas.c:xmlSchemaCustomWarning:
 2429|      2|{
 2430|      2|    xmlChar *msg = NULL;
 2431|       |
 2432|      2|    xmlSchemaFormatNodeForError(&msg, actxt, node);
 2433|      2|    msg = xmlStrcat(msg, (const xmlChar *) message);
 2434|      2|    msg = xmlStrcat(msg, BAD_CAST ".\n");
  ------------------
  |  |   35|      2|#define BAD_CAST (xmlChar *)
  ------------------
 2435|       |
 2436|       |    /* URGENT TODO: Set the error code to something sane. */
 2437|      2|    xmlSchemaErr4Line(actxt, XML_ERR_WARNING, error, node, 0,
 2438|      2|	(const char *) msg, str1, str2, str3, NULL);
 2439|       |
 2440|      2|    FREE_AND_NULL(msg)
  ------------------
  |  |  320|      2|#define FREE_AND_NULL(str) if ((str) != NULL) { xmlFree((xmlChar *) (str)); str = NULL; }
  |  |  ------------------
  |  |  |  Branch (320:32): [True: 2, False: 0]
  |  |  ------------------
  ------------------
 2441|      2|}
xmlschemas.c:xmlSchemaGetChameleonSchemaBucket:
10021|      2|{
10022|      2|    xmlSchemaBucketPtr cur;
10023|      2|    xmlSchemaItemListPtr list;
10024|       |
10025|      2|    list = pctxt->constructor->buckets;
10026|      2|    if (list->nbItems == 0)
  ------------------
  |  Branch (10026:9): [True: 0, False: 2]
  ------------------
10027|      0|	return(NULL);
10028|      2|    else {
10029|      2|	int i;
10030|     10|	for (i = 0; i < list->nbItems; i++) {
  ------------------
  |  Branch (10030:14): [True: 9, False: 1]
  ------------------
10031|      9|	    cur = (xmlSchemaBucketPtr) list->items[i];
10032|       |	    /* Pointer comparison! */
10033|      9|	    if ((cur->origTargetNamespace == NULL) &&
  ------------------
  |  Branch (10033:10): [True: 3, False: 6]
  ------------------
10034|      9|		(cur->schemaLocation == schemaLocation) &&
  ------------------
  |  Branch (10034:3): [True: 3, False: 0]
  ------------------
10035|      9|		(cur->targetNamespace == targetNamespace))
  ------------------
  |  Branch (10035:3): [True: 1, False: 2]
  ------------------
10036|      1|		return(cur);
10037|      9|	}
10038|      2|    }
10039|      1|    return(NULL);
10040|      2|}
xmlschemas.c:xmlSchemaPErr:
 1948|     17|{
 1949|     17|    xmlGenericErrorFunc channel = NULL;
 1950|     17|    xmlStructuredErrorFunc schannel = NULL;
 1951|     17|    void *data = NULL;
 1952|       |
 1953|     17|    if (ctxt != NULL) {
  ------------------
  |  Branch (1953:9): [True: 17, False: 0]
  ------------------
 1954|     17|        ctxt->nberrors++;
 1955|     17|	ctxt->err = error;
 1956|     17|        channel = ctxt->error;
 1957|     17|        data = ctxt->errCtxt;
 1958|     17|	schannel = ctxt->serror;
 1959|     17|    }
 1960|     17|    __xmlRaiseError(schannel, channel, data, ctxt, node, XML_FROM_SCHEMASP,
 1961|     17|                    error, XML_ERR_ERROR, NULL, 0,
 1962|     17|                    (const char *) str1, (const char *) str2, NULL, 0, 0,
 1963|     17|                    msg, str1, str2);
 1964|     17|}
xmlschemas.c:xmlSchemaCleanupDoc:
 9513|    206|{
 9514|    206|    xmlNodePtr delete, cur;
 9515|       |
 9516|    206|    if ((ctxt == NULL) || (root == NULL)) return;
  ------------------
  |  Branch (9516:9): [True: 0, False: 206]
  |  Branch (9516:27): [True: 0, False: 206]
  ------------------
 9517|       |
 9518|       |    /*
 9519|       |     * Remove all the blank text nodes
 9520|       |     */
 9521|    206|    delete = NULL;
 9522|    206|    cur = root;
 9523|  8.74k|    while (cur != NULL) {
  ------------------
  |  Branch (9523:12): [True: 8.54k, False: 206]
  ------------------
 9524|  8.54k|        if (delete != NULL) {
  ------------------
  |  Branch (9524:13): [True: 4.93k, False: 3.61k]
  ------------------
 9525|  4.93k|            xmlUnlinkNode(delete);
 9526|  4.93k|            xmlFreeNode(delete);
 9527|  4.93k|            delete = NULL;
 9528|  4.93k|        }
 9529|  8.54k|        if (cur->type == XML_TEXT_NODE) {
  ------------------
  |  Branch (9529:13): [True: 5.12k, False: 3.41k]
  ------------------
 9530|  5.12k|            if (IS_BLANK_NODE(cur)) {
  ------------------
  |  | 4949|  5.12k|    (((n)->type == XML_TEXT_NODE) && (xmlSchemaIsBlank((n)->content, -1)))
  |  |  ------------------
  |  |  |  Branch (4949:6): [True: 5.12k, False: 0]
  |  |  |  Branch (4949:38): [True: 5.03k, False: 97]
  |  |  ------------------
  ------------------
 9531|  5.03k|                if (xmlNodeGetSpacePreserve(cur) != 1) {
  ------------------
  |  Branch (9531:21): [True: 5.03k, False: 0]
  ------------------
 9532|  5.03k|                    delete = cur;
 9533|  5.03k|                }
 9534|  5.03k|            }
 9535|  5.12k|        } else if ((cur->type != XML_ELEMENT_NODE) &&
  ------------------
  |  Branch (9535:20): [True: 106, False: 3.30k]
  ------------------
 9536|  3.41k|                   (cur->type != XML_CDATA_SECTION_NODE)) {
  ------------------
  |  Branch (9536:20): [True: 106, False: 0]
  ------------------
 9537|    106|            delete = cur;
 9538|    106|            goto skip_children;
 9539|    106|        }
 9540|       |
 9541|       |        /*
 9542|       |         * Skip to next node
 9543|       |         */
 9544|  8.43k|        if (cur->children != NULL) {
  ------------------
  |  Branch (9544:13): [True: 1.92k, False: 6.51k]
  ------------------
 9545|  1.92k|            if ((cur->children->type != XML_ENTITY_DECL) &&
  ------------------
  |  Branch (9545:17): [True: 1.92k, False: 0]
  ------------------
 9546|  1.92k|                (cur->children->type != XML_ENTITY_REF_NODE) &&
  ------------------
  |  Branch (9546:17): [True: 1.92k, False: 0]
  ------------------
 9547|  1.92k|                (cur->children->type != XML_ENTITY_NODE)) {
  ------------------
  |  Branch (9547:17): [True: 1.92k, False: 0]
  ------------------
 9548|  1.92k|                cur = cur->children;
 9549|  1.92k|                continue;
 9550|  1.92k|            }
 9551|  1.92k|        }
 9552|  6.62k|      skip_children:
 9553|  6.62k|        if (cur->next != NULL) {
  ------------------
  |  Branch (9553:13): [True: 4.70k, False: 1.92k]
  ------------------
 9554|  4.70k|            cur = cur->next;
 9555|  4.70k|            continue;
 9556|  4.70k|        }
 9557|       |
 9558|  1.92k|        do {
 9559|  1.92k|            cur = cur->parent;
 9560|  1.92k|            if (cur == NULL)
  ------------------
  |  Branch (9560:17): [True: 0, False: 1.92k]
  ------------------
 9561|      0|                break;
 9562|  1.92k|            if (cur == root) {
  ------------------
  |  Branch (9562:17): [True: 206, False: 1.71k]
  ------------------
 9563|    206|                cur = NULL;
 9564|    206|                break;
 9565|    206|            }
 9566|  1.71k|            if (cur->next != NULL) {
  ------------------
  |  Branch (9566:17): [True: 1.71k, False: 0]
  ------------------
 9567|  1.71k|                cur = cur->next;
 9568|  1.71k|                break;
 9569|  1.71k|            }
 9570|  1.71k|        } while (cur != NULL);
  ------------------
  |  Branch (9570:18): [True: 0, False: 0]
  ------------------
 9571|  1.92k|    }
 9572|    206|    if (delete != NULL) {
  ------------------
  |  Branch (9572:9): [True: 206, False: 0]
  ------------------
 9573|    206|        xmlUnlinkNode(delete);
 9574|    206|        xmlFreeNode(delete);
 9575|    206|        delete = NULL;
 9576|    206|    }
 9577|    206|}
xmlschemas.c:xmlSchemaIsBlank:
 4962|  5.12k|{
 4963|  5.12k|    if (str == NULL)
  ------------------
  |  Branch (4963:9): [True: 0, False: 5.12k]
  ------------------
 4964|      0|        return (1);
 4965|  5.12k|    if (len < 0) {
  ------------------
  |  Branch (4965:9): [True: 5.12k, False: 0]
  ------------------
 4966|  35.4k|	while (*str != 0) {
  ------------------
  |  Branch (4966:9): [True: 30.4k, False: 5.03k]
  ------------------
 4967|  30.4k|	    if (!(IS_BLANK_CH(*str)))
  ------------------
  |  |  151|  30.4k|#define IS_BLANK_CH(c)  xmlIsBlank_ch(c)
  |  |  ------------------
  |  |  |  |   88|  30.4k|#define xmlIsBlank_ch(c)	(((c) == 0x20) || \
  |  |  |  |  ------------------
  |  |  |  |  |  Branch (88:27): [True: 17.8k, False: 12.6k]
  |  |  |  |  ------------------
  |  |  |  |   89|  30.4k|				 ((0x9 <= (c)) && ((c) <= 0xa)) || \
  |  |  |  |  ------------------
  |  |  |  |  |  Branch (89:7): [True: 12.6k, False: 0]
  |  |  |  |  |  Branch (89:23): [True: 12.5k, False: 97]
  |  |  |  |  ------------------
  |  |  |  |   90|  30.4k|				 ((c) == 0xd))
  |  |  |  |  ------------------
  |  |  |  |  |  Branch (90:6): [True: 0, False: 97]
  |  |  |  |  ------------------
  |  |  ------------------
  ------------------
 4968|     97|		return (0);
 4969|  30.3k|	    str++;
 4970|  30.3k|	}
 4971|  5.12k|    } else while ((*str != 0) && (len != 0)) {
  ------------------
  |  Branch (4971:19): [True: 0, False: 0]
  |  Branch (4971:34): [True: 0, False: 0]
  ------------------
 4972|      0|	if (!(IS_BLANK_CH(*str)))
  ------------------
  |  |  151|      0|#define IS_BLANK_CH(c)  xmlIsBlank_ch(c)
  |  |  ------------------
  |  |  |  |   88|      0|#define xmlIsBlank_ch(c)	(((c) == 0x20) || \
  |  |  |  |  ------------------
  |  |  |  |  |  Branch (88:27): [True: 0, False: 0]
  |  |  |  |  ------------------
  |  |  |  |   89|      0|				 ((0x9 <= (c)) && ((c) <= 0xa)) || \
  |  |  |  |  ------------------
  |  |  |  |  |  Branch (89:7): [True: 0, False: 0]
  |  |  |  |  |  Branch (89:23): [True: 0, False: 0]
  |  |  |  |  ------------------
  |  |  |  |   90|      0|				 ((c) == 0xd))
  |  |  |  |  ------------------
  |  |  |  |  |  Branch (90:6): [True: 0, False: 0]
  |  |  |  |  ------------------
  |  |  ------------------
  ------------------
 4973|      0|	    return (0);
 4974|      0|	str++;
 4975|      0|	len--;
 4976|      0|    }
 4977|       |
 4978|  5.03k|    return (1);
 4979|  5.12k|}
xmlschemas.c:xmlSchemaGetProp:
 4701|  2.24k|{
 4702|  2.24k|    xmlChar *val;
 4703|  2.24k|    const xmlChar *ret;
 4704|       |
 4705|  2.24k|    val = xmlGetNoNsProp(node, BAD_CAST name);
  ------------------
  |  |   35|  2.24k|#define BAD_CAST (xmlChar *)
  ------------------
 4706|  2.24k|    if (val == NULL)
  ------------------
  |  Branch (4706:9): [True: 1.76k, False: 484]
  ------------------
 4707|  1.76k|        return(NULL);
 4708|    484|    ret = xmlDictLookup(ctxt->dict, val, -1);
 4709|    484|    xmlFree(val);
 4710|    484|    return(ret);
 4711|  2.24k|}
xmlschemas.c:xmlSchemaBucketCreate:
 3612|    204|{
 3613|    204|    xmlSchemaBucketPtr ret;
 3614|    204|    int size;
 3615|    204|    xmlSchemaPtr mainSchema;
 3616|       |
 3617|    204|    if (WXS_CONSTRUCTOR(pctxt)->mainSchema == NULL) {
  ------------------
  |  |  278|    204|#define WXS_CONSTRUCTOR(ctx) (ctx)->constructor
  ------------------
  |  Branch (3617:9): [True: 0, False: 204]
  ------------------
 3618|      0|	PERROR_INT("xmlSchemaBucketCreate",
  ------------------
  |  | 2824|      0|#define PERROR_INT(func, msg) xmlSchemaInternalErr(ACTXT_CAST pctxt, func, msg);
  |  |  ------------------
  |  |  |  |  121|      0|#define ACTXT_CAST (xmlSchemaAbstractCtxtPtr)
  |  |  ------------------
  ------------------
 3619|      0|	    "no main schema on constructor");
 3620|      0|	return(NULL);
 3621|      0|    }
 3622|    204|    mainSchema = WXS_CONSTRUCTOR(pctxt)->mainSchema;
  ------------------
  |  |  278|    204|#define WXS_CONSTRUCTOR(ctx) (ctx)->constructor
  ------------------
 3623|       |    /* Create the schema bucket. */
 3624|    204|    if (WXS_IS_BUCKET_INCREDEF(type))
  ------------------
  |  |  196|    204|#define WXS_IS_BUCKET_INCREDEF(t) (((t) == XML_SCHEMA_SCHEMA_INCLUDE) || \
  |  |  ------------------
  |  |  |  |  373|    204|#define XML_SCHEMA_SCHEMA_INCLUDE 2
  |  |  ------------------
  |  |  |  Branch (196:36): [True: 21, False: 183]
  |  |  ------------------
  |  |  197|    204|    ((t) == XML_SCHEMA_SCHEMA_REDEFINE))
  |  |  ------------------
  |  |  |  |  374|    183|#define XML_SCHEMA_SCHEMA_REDEFINE 3
  |  |  ------------------
  |  |  |  Branch (197:5): [True: 0, False: 183]
  |  |  ------------------
  ------------------
 3625|     21|	size = sizeof(xmlSchemaInclude);
 3626|    183|    else
 3627|    183|	size = sizeof(xmlSchemaImport);
 3628|    204|    ret = (xmlSchemaBucketPtr) xmlMalloc(size);
 3629|    204|    if (ret == NULL) {
  ------------------
  |  Branch (3629:9): [True: 0, False: 204]
  ------------------
 3630|      0|	xmlSchemaPErrMemory(NULL, "allocating schema bucket", NULL);
 3631|      0|	return(NULL);
 3632|      0|    }
 3633|    204|    memset(ret, 0, size);
 3634|    204|    ret->targetNamespace = targetNamespace;
 3635|    204|    ret->type = type;
 3636|    204|    ret->globals = xmlSchemaItemListCreate();
 3637|    204|    if (ret->globals == NULL) {
  ------------------
  |  Branch (3637:9): [True: 0, False: 204]
  ------------------
 3638|      0|	xmlSchemaBucketFree(ret);
 3639|      0|	return(NULL);
 3640|      0|    }
 3641|    204|    ret->locals = xmlSchemaItemListCreate();
 3642|    204|    if (ret->locals == NULL) {
  ------------------
  |  Branch (3642:9): [True: 0, False: 204]
  ------------------
 3643|      0|	xmlSchemaBucketFree(ret);
 3644|      0|	return(NULL);
 3645|      0|    }
 3646|       |    /*
 3647|       |    * The following will assure that only the first bucket is marked as
 3648|       |    * XML_SCHEMA_SCHEMA_MAIN and it points to the *main* schema.
 3649|       |    * For each following import buckets an xmlSchema will be created.
 3650|       |    * An xmlSchema will be created for every distinct targetNamespace.
 3651|       |    * We assign the targetNamespace to the schemata here.
 3652|       |    */
 3653|    204|    if (! WXS_HAS_BUCKETS(pctxt)) {
  ------------------
  |  |  280|    204|#define WXS_HAS_BUCKETS(ctx) \
  |  |  281|    204|( (WXS_CONSTRUCTOR((ctx))->buckets != NULL) && \
  |  |  ------------------
  |  |  |  |  278|    204|#define WXS_CONSTRUCTOR(ctx) (ctx)->constructor
  |  |  ------------------
  |  |  |  Branch (281:3): [True: 204, False: 0]
  |  |  |  Branch (281:48): [True: 37, False: 167]
  |  |  ------------------
  |  |  282|    204|(WXS_CONSTRUCTOR((ctx))->buckets->nbItems > 0) )
  |  |  ------------------
  |  |  |  |  278|    204|#define WXS_CONSTRUCTOR(ctx) (ctx)->constructor
  |  |  ------------------
  ------------------
 3654|    167|	if (WXS_IS_BUCKET_INCREDEF(type)) {
  ------------------
  |  |  196|    167|#define WXS_IS_BUCKET_INCREDEF(t) (((t) == XML_SCHEMA_SCHEMA_INCLUDE) || \
  |  |  ------------------
  |  |  |  |  373|    167|#define XML_SCHEMA_SCHEMA_INCLUDE 2
  |  |  ------------------
  |  |  |  Branch (196:36): [True: 0, False: 167]
  |  |  ------------------
  |  |  197|    167|    ((t) == XML_SCHEMA_SCHEMA_REDEFINE))
  |  |  ------------------
  |  |  |  |  374|    167|#define XML_SCHEMA_SCHEMA_REDEFINE 3
  |  |  ------------------
  |  |  |  Branch (197:5): [True: 0, False: 167]
  |  |  ------------------
  ------------------
 3655|      0|	    PERROR_INT("xmlSchemaBucketCreate",
  ------------------
  |  | 2824|      0|#define PERROR_INT(func, msg) xmlSchemaInternalErr(ACTXT_CAST pctxt, func, msg);
  |  |  ------------------
  |  |  |  |  121|      0|#define ACTXT_CAST (xmlSchemaAbstractCtxtPtr)
  |  |  ------------------
  ------------------
 3656|      0|		"first bucket but it's an include or redefine");
 3657|      0|	    xmlSchemaBucketFree(ret);
 3658|      0|	    return(NULL);
 3659|      0|	}
 3660|       |	/* Force the type to be XML_SCHEMA_SCHEMA_MAIN. */
 3661|    167|	ret->type = XML_SCHEMA_SCHEMA_MAIN;
  ------------------
  |  |  371|    167|#define XML_SCHEMA_SCHEMA_MAIN 0
  ------------------
 3662|       |	/* Point to the *main* schema. */
 3663|    167|	WXS_CONSTRUCTOR(pctxt)->mainBucket = ret;
  ------------------
  |  |  278|    167|#define WXS_CONSTRUCTOR(ctx) (ctx)->constructor
  ------------------
 3664|    167|	WXS_IMPBUCKET(ret)->schema = mainSchema;
  ------------------
  |  |  202|    167|#define WXS_IMPBUCKET(b) ((xmlSchemaImportPtr) (b))
  ------------------
 3665|       |	/*
 3666|       |	* Ensure that the main schema gets a targetNamespace.
 3667|       |	*/
 3668|    167|	mainSchema->targetNamespace = targetNamespace;
 3669|    167|    } else {
 3670|     37|	if (type == XML_SCHEMA_SCHEMA_MAIN) {
  ------------------
  |  |  371|     37|#define XML_SCHEMA_SCHEMA_MAIN 0
  ------------------
  |  Branch (3670:6): [True: 0, False: 37]
  ------------------
 3671|      0|	    PERROR_INT("xmlSchemaBucketCreate",
  ------------------
  |  | 2824|      0|#define PERROR_INT(func, msg) xmlSchemaInternalErr(ACTXT_CAST pctxt, func, msg);
  |  |  ------------------
  |  |  |  |  121|      0|#define ACTXT_CAST (xmlSchemaAbstractCtxtPtr)
  |  |  ------------------
  ------------------
 3672|      0|		"main bucket but it's not the first one");
 3673|      0|	    xmlSchemaBucketFree(ret);
 3674|      0|	    return(NULL);
 3675|     37|	} else if (type == XML_SCHEMA_SCHEMA_IMPORT) {
  ------------------
  |  |  372|     37|#define XML_SCHEMA_SCHEMA_IMPORT 1
  ------------------
  |  Branch (3675:13): [True: 16, False: 21]
  ------------------
 3676|       |	    /*
 3677|       |	    * Create a schema for imports and assign the
 3678|       |	    * targetNamespace.
 3679|       |	    */
 3680|     16|	    WXS_IMPBUCKET(ret)->schema = xmlSchemaNewSchema(pctxt);
  ------------------
  |  |  202|     16|#define WXS_IMPBUCKET(b) ((xmlSchemaImportPtr) (b))
  ------------------
 3681|     16|	    if (WXS_IMPBUCKET(ret)->schema == NULL) {
  ------------------
  |  |  202|     16|#define WXS_IMPBUCKET(b) ((xmlSchemaImportPtr) (b))
  ------------------
  |  Branch (3681:10): [True: 0, False: 16]
  ------------------
 3682|      0|		xmlSchemaBucketFree(ret);
 3683|      0|		return(NULL);
 3684|      0|	    }
 3685|     16|	    WXS_IMPBUCKET(ret)->schema->targetNamespace = targetNamespace;
  ------------------
  |  |  202|     16|#define WXS_IMPBUCKET(b) ((xmlSchemaImportPtr) (b))
  ------------------
 3686|     16|	}
 3687|     37|    }
 3688|    204|    if (WXS_IS_BUCKET_IMPMAIN(type)) {
  ------------------
  |  |  199|    204|#define WXS_IS_BUCKET_IMPMAIN(t) (((t) == XML_SCHEMA_SCHEMA_MAIN) || \
  |  |  ------------------
  |  |  |  |  371|    204|#define XML_SCHEMA_SCHEMA_MAIN 0
  |  |  ------------------
  |  |  |  Branch (199:35): [True: 167, False: 37]
  |  |  ------------------
  |  |  200|    204|    ((t) == XML_SCHEMA_SCHEMA_IMPORT))
  |  |  ------------------
  |  |  |  |  372|     37|#define XML_SCHEMA_SCHEMA_IMPORT 1
  |  |  ------------------
  |  |  |  Branch (200:5): [True: 16, False: 21]
  |  |  ------------------
  ------------------
 3689|    183|	int res;
 3690|       |	/*
 3691|       |	* Imports go into the "schemasImports" slot of the main *schema*.
 3692|       |	* Note that we create an import entry for the main schema as well; i.e.,
 3693|       |	* even if there's only one schema, we'll get an import.
 3694|       |	*/
 3695|    183|	if (mainSchema->schemasImports == NULL) {
  ------------------
  |  Branch (3695:6): [True: 167, False: 16]
  ------------------
 3696|    167|	    mainSchema->schemasImports = xmlHashCreateDict(5,
 3697|    167|		WXS_CONSTRUCTOR(pctxt)->dict);
  ------------------
  |  |  278|    167|#define WXS_CONSTRUCTOR(ctx) (ctx)->constructor
  ------------------
 3698|    167|	    if (mainSchema->schemasImports == NULL) {
  ------------------
  |  Branch (3698:10): [True: 0, False: 167]
  ------------------
 3699|      0|		xmlSchemaBucketFree(ret);
 3700|      0|		return(NULL);
 3701|      0|	    }
 3702|    167|	}
 3703|    183|	if (targetNamespace == NULL)
  ------------------
  |  Branch (3703:6): [True: 73, False: 110]
  ------------------
 3704|     73|	    res = xmlHashAddEntry(mainSchema->schemasImports,
 3705|     73|		XML_SCHEMAS_NO_NAMESPACE, ret);
  ------------------
  |  |  104|     73|#define XML_SCHEMAS_NO_NAMESPACE (const xmlChar *) "##"
  ------------------
 3706|    110|	else
 3707|    110|	    res = xmlHashAddEntry(mainSchema->schemasImports,
 3708|    110|		targetNamespace, ret);
 3709|    183|	if (res != 0) {
  ------------------
  |  Branch (3709:6): [True: 0, False: 183]
  ------------------
 3710|      0|	    PERROR_INT("xmlSchemaBucketCreate",
  ------------------
  |  | 2824|      0|#define PERROR_INT(func, msg) xmlSchemaInternalErr(ACTXT_CAST pctxt, func, msg);
  |  |  ------------------
  |  |  |  |  121|      0|#define ACTXT_CAST (xmlSchemaAbstractCtxtPtr)
  |  |  ------------------
  ------------------
 3711|      0|		"failed to add the schema bucket to the hash");
 3712|      0|	    xmlSchemaBucketFree(ret);
 3713|      0|	    return(NULL);
 3714|      0|	}
 3715|    183|    } else {
 3716|       |	/* Set the @ownerImport of an include bucket. */
 3717|     21|	if (WXS_IS_BUCKET_IMPMAIN(WXS_CONSTRUCTOR(pctxt)->bucket->type))
  ------------------
  |  |  199|     21|#define WXS_IS_BUCKET_IMPMAIN(t) (((t) == XML_SCHEMA_SCHEMA_MAIN) || \
  |  |  ------------------
  |  |  |  |  371|     21|#define XML_SCHEMA_SCHEMA_MAIN 0
  |  |  ------------------
  |  |  |  Branch (199:35): [True: 15, False: 6]
  |  |  ------------------
  |  |  200|     21|    ((t) == XML_SCHEMA_SCHEMA_IMPORT))
  |  |  ------------------
  |  |  |  |  372|      6|#define XML_SCHEMA_SCHEMA_IMPORT 1
  |  |  ------------------
  |  |  |  Branch (200:5): [True: 6, False: 0]
  |  |  ------------------
  ------------------
 3718|     21|	    WXS_INCBUCKET(ret)->ownerImport =
  ------------------
  |  |  204|     21|#define WXS_INCBUCKET(b) ((xmlSchemaIncludePtr) (b))
  ------------------
 3719|     21|		WXS_IMPBUCKET(WXS_CONSTRUCTOR(pctxt)->bucket);
  ------------------
  |  |  202|     21|#define WXS_IMPBUCKET(b) ((xmlSchemaImportPtr) (b))
  ------------------
 3720|      0|	else
 3721|      0|	    WXS_INCBUCKET(ret)->ownerImport =
  ------------------
  |  |  204|      0|#define WXS_INCBUCKET(b) ((xmlSchemaIncludePtr) (b))
  ------------------
 3722|      0|		WXS_INCBUCKET(WXS_CONSTRUCTOR(pctxt)->bucket)->ownerImport;
  ------------------
  |  |  204|      0|#define WXS_INCBUCKET(b) ((xmlSchemaIncludePtr) (b))
  ------------------
 3723|       |
 3724|       |	/* Includes got into the "includes" slot of the *main* schema. */
 3725|     21|	if (mainSchema->includes == NULL) {
  ------------------
  |  Branch (3725:6): [True: 16, False: 5]
  ------------------
 3726|     16|	    mainSchema->includes = xmlSchemaItemListCreate();
 3727|     16|	    if (mainSchema->includes == NULL) {
  ------------------
  |  Branch (3727:10): [True: 0, False: 16]
  ------------------
 3728|      0|		xmlSchemaBucketFree(ret);
 3729|      0|		return(NULL);
 3730|      0|	    }
 3731|     16|	}
 3732|     21|	if (xmlSchemaItemListAdd(mainSchema->includes, ret) < 0) {
  ------------------
  |  Branch (3732:6): [True: 0, False: 21]
  ------------------
 3733|      0|	    xmlSchemaBucketFree(ret);
 3734|      0|	    return(NULL);
 3735|      0|        }
 3736|     21|    }
 3737|       |    /*
 3738|       |    * Add to list of all buckets; this is used for lookup
 3739|       |    * during schema construction time only.
 3740|       |    */
 3741|    204|    if (xmlSchemaItemListAdd(WXS_CONSTRUCTOR(pctxt)->buckets, ret) == -1)
  ------------------
  |  |  278|    204|#define WXS_CONSTRUCTOR(ctx) (ctx)->constructor
  ------------------
  |  Branch (3741:9): [True: 0, False: 204]
  ------------------
 3742|      0|	return(NULL);
 3743|    204|    return(ret);
 3744|    204|}
xmlschemas.c:xmlSchemaItemListAdd:
 3408|    249|{
 3409|    249|    if (list->sizeItems <= list->nbItems) {
  ------------------
  |  Branch (3409:9): [True: 189, False: 60]
  ------------------
 3410|    189|        void **tmp;
 3411|    189|        size_t newSize = list->sizeItems == 0 ? 20 : list->sizeItems * 2;
  ------------------
  |  Branch (3411:26): [True: 189, False: 0]
  ------------------
 3412|       |
 3413|    189|	tmp = (void **) xmlRealloc(list->items, newSize * sizeof(void *));
 3414|    189|	if (tmp == NULL) {
  ------------------
  |  Branch (3414:6): [True: 0, False: 189]
  ------------------
 3415|      0|	    xmlSchemaPErrMemory(NULL, "growing item list", NULL);
 3416|      0|	    return(-1);
 3417|      0|	}
 3418|    189|        list->items = tmp;
 3419|    189|	list->sizeItems = newSize;
 3420|    189|    }
 3421|    249|    list->items[list->nbItems++] = item;
 3422|    249|    return(0);
 3423|    249|}
xmlschemas.c:xmlSchemaParseNewDocWithContext:
10075|    200|{
10076|    200|    int oldFlags;
10077|    200|    xmlDocPtr oldDoc;
10078|    200|    xmlNodePtr node;
10079|    200|    int ret, oldErrs;
10080|    200|    xmlSchemaBucketPtr oldbucket = pctxt->constructor->bucket;
10081|       |
10082|       |    /*
10083|       |    * Save old values; reset the *main* schema.
10084|       |    * URGENT TODO: This is not good; move the per-document information
10085|       |    * to the parser. Get rid of passing the main schema to the
10086|       |    * parsing functions.
10087|       |    */
10088|    200|    oldFlags = schema->flags;
10089|    200|    oldDoc = schema->doc;
10090|    200|    if (schema->flags != 0)
  ------------------
  |  Branch (10090:9): [True: 25, False: 175]
  ------------------
10091|     25|	xmlSchemaClearSchemaDefaults(schema);
10092|    200|    schema->doc = bucket->doc;
10093|    200|    pctxt->schema = schema;
10094|       |    /*
10095|       |    * Keep the current target namespace on the parser *not* on the
10096|       |    * main schema.
10097|       |    */
10098|    200|    pctxt->targetNamespace = bucket->targetNamespace;
10099|    200|    WXS_CONSTRUCTOR(pctxt)->bucket = bucket;
  ------------------
  |  |  278|    200|#define WXS_CONSTRUCTOR(ctx) (ctx)->constructor
  ------------------
10100|       |
10101|    200|    if ((bucket->targetNamespace != NULL) &&
  ------------------
  |  Branch (10101:9): [True: 124, False: 76]
  ------------------
10102|    200|	xmlStrEqual(bucket->targetNamespace, xmlSchemaNs)) {
  ------------------
  |  Branch (10102:2): [True: 0, False: 124]
  ------------------
10103|       |	/*
10104|       |	* We are parsing the schema for schemas!
10105|       |	*/
10106|      0|	pctxt->isS4S = 1;
10107|      0|    }
10108|       |    /* Mark it as parsed, even if parsing fails. */
10109|    200|    bucket->parsed++;
10110|       |    /* Compile the schema doc. */
10111|    200|    node = xmlDocGetRootElement(bucket->doc);
10112|    200|    ret = xmlSchemaParseSchemaElement(pctxt, schema, node);
10113|    200|    if (ret != 0)
  ------------------
  |  Branch (10113:9): [True: 0, False: 200]
  ------------------
10114|      0|	goto exit;
10115|       |    /* An empty schema; just get out. */
10116|    200|    if (node->children == NULL)
  ------------------
  |  Branch (10116:9): [True: 8, False: 192]
  ------------------
10117|      8|	goto exit;
10118|    192|    oldErrs = pctxt->nberrors;
10119|    192|    ret = xmlSchemaParseSchemaTopLevel(pctxt, schema, node->children);
10120|    192|    if (ret != 0)
  ------------------
  |  Branch (10120:9): [True: 32, False: 160]
  ------------------
10121|     32|	goto exit;
10122|       |    /*
10123|       |    * TODO: Not nice, but I'm not 100% sure we will get always an error
10124|       |    * as a result of the above functions; so better rely on pctxt->err
10125|       |    * as well.
10126|       |    */
10127|    160|    if ((ret == 0) && (oldErrs != pctxt->nberrors)) {
  ------------------
  |  Branch (10127:9): [True: 160, False: 0]
  |  Branch (10127:23): [True: 0, False: 160]
  ------------------
10128|      0|	ret = pctxt->err;
10129|      0|	goto exit;
10130|      0|    }
10131|       |
10132|    200|exit:
10133|    200|    WXS_CONSTRUCTOR(pctxt)->bucket = oldbucket;
  ------------------
  |  |  278|    200|#define WXS_CONSTRUCTOR(ctx) (ctx)->constructor
  ------------------
10134|       |    /* Restore schema values. */
10135|    200|    schema->doc = oldDoc;
10136|    200|    schema->flags = oldFlags;
10137|    200|    return(ret);
10138|    160|}
xmlschemas.c:xmlSchemaClearSchemaDefaults:
 9582|     25|{
 9583|     25|    if (schema->flags & XML_SCHEMAS_QUALIF_ELEM)
  ------------------
  |  |  861|     25|#define XML_SCHEMAS_QUALIF_ELEM                1 << 0
  ------------------
  |  Branch (9583:9): [True: 22, False: 3]
  ------------------
 9584|     22|	schema->flags ^= XML_SCHEMAS_QUALIF_ELEM;
  ------------------
  |  |  861|     22|#define XML_SCHEMAS_QUALIF_ELEM                1 << 0
  ------------------
 9585|       |
 9586|     25|    if (schema->flags & XML_SCHEMAS_QUALIF_ATTR)
  ------------------
  |  |  868|     25|#define XML_SCHEMAS_QUALIF_ATTR            1 << 1
  ------------------
  |  Branch (9586:9): [True: 0, False: 25]
  ------------------
 9587|      0|	schema->flags ^= XML_SCHEMAS_QUALIF_ATTR;
  ------------------
  |  |  868|      0|#define XML_SCHEMAS_QUALIF_ATTR            1 << 1
  ------------------
 9588|       |
 9589|     25|    if (schema->flags & XML_SCHEMAS_FINAL_DEFAULT_EXTENSION)
  ------------------
  |  |  874|     25|#define XML_SCHEMAS_FINAL_DEFAULT_EXTENSION        1 << 2
  ------------------
  |  Branch (9589:9): [True: 0, False: 25]
  ------------------
 9590|      0|	schema->flags ^= XML_SCHEMAS_FINAL_DEFAULT_EXTENSION;
  ------------------
  |  |  874|      0|#define XML_SCHEMAS_FINAL_DEFAULT_EXTENSION        1 << 2
  ------------------
 9591|     25|    if (schema->flags & XML_SCHEMAS_FINAL_DEFAULT_RESTRICTION)
  ------------------
  |  |  880|     25|#define XML_SCHEMAS_FINAL_DEFAULT_RESTRICTION            1 << 3
  ------------------
  |  Branch (9591:9): [True: 0, False: 25]
  ------------------
 9592|      0|	schema->flags ^= XML_SCHEMAS_FINAL_DEFAULT_RESTRICTION;
  ------------------
  |  |  880|      0|#define XML_SCHEMAS_FINAL_DEFAULT_RESTRICTION            1 << 3
  ------------------
 9593|     25|    if (schema->flags & XML_SCHEMAS_FINAL_DEFAULT_LIST)
  ------------------
  |  |  886|     25|#define XML_SCHEMAS_FINAL_DEFAULT_LIST            1 << 4
  ------------------
  |  Branch (9593:9): [True: 0, False: 25]
  ------------------
 9594|      0|	schema->flags ^= XML_SCHEMAS_FINAL_DEFAULT_LIST;
  ------------------
  |  |  886|      0|#define XML_SCHEMAS_FINAL_DEFAULT_LIST            1 << 4
  ------------------
 9595|     25|    if (schema->flags & XML_SCHEMAS_FINAL_DEFAULT_UNION)
  ------------------
  |  |  892|     25|#define XML_SCHEMAS_FINAL_DEFAULT_UNION            1 << 5
  ------------------
  |  Branch (9595:9): [True: 0, False: 25]
  ------------------
 9596|      0|	schema->flags ^= XML_SCHEMAS_FINAL_DEFAULT_UNION;
  ------------------
  |  |  892|      0|#define XML_SCHEMAS_FINAL_DEFAULT_UNION            1 << 5
  ------------------
 9597|       |
 9598|     25|    if (schema->flags & XML_SCHEMAS_BLOCK_DEFAULT_EXTENSION)
  ------------------
  |  |  898|     25|#define XML_SCHEMAS_BLOCK_DEFAULT_EXTENSION            1 << 6
  ------------------
  |  Branch (9598:9): [True: 0, False: 25]
  ------------------
 9599|      0|	schema->flags ^= XML_SCHEMAS_BLOCK_DEFAULT_EXTENSION;
  ------------------
  |  |  898|      0|#define XML_SCHEMAS_BLOCK_DEFAULT_EXTENSION            1 << 6
  ------------------
 9600|     25|    if (schema->flags & XML_SCHEMAS_BLOCK_DEFAULT_RESTRICTION)
  ------------------
  |  |  904|     25|#define XML_SCHEMAS_BLOCK_DEFAULT_RESTRICTION            1 << 7
  ------------------
  |  Branch (9600:9): [True: 0, False: 25]
  ------------------
 9601|      0|	schema->flags ^= XML_SCHEMAS_BLOCK_DEFAULT_RESTRICTION;
  ------------------
  |  |  904|      0|#define XML_SCHEMAS_BLOCK_DEFAULT_RESTRICTION            1 << 7
  ------------------
 9602|     25|    if (schema->flags & XML_SCHEMAS_BLOCK_DEFAULT_SUBSTITUTION)
  ------------------
  |  |  910|     25|#define XML_SCHEMAS_BLOCK_DEFAULT_SUBSTITUTION            1 << 8
  ------------------
  |  Branch (9602:9): [True: 0, False: 25]
  ------------------
 9603|      0|	schema->flags ^= XML_SCHEMAS_BLOCK_DEFAULT_SUBSTITUTION;
  ------------------
  |  |  910|      0|#define XML_SCHEMAS_BLOCK_DEFAULT_SUBSTITUTION            1 << 8
  ------------------
 9604|     25|}
xmlschemas.c:xmlSchemaParseSchemaElement:
 9610|    200|{
 9611|    200|    xmlAttrPtr attr;
 9612|    200|    const xmlChar *val;
 9613|    200|    int res = 0, oldErrs = ctxt->nberrors;
 9614|       |
 9615|       |    /*
 9616|       |    * Those flags should be moved to the parser context flags,
 9617|       |    * since they are not visible at the component level. I.e.
 9618|       |    * they are used if processing schema *documents* only.
 9619|       |    */
 9620|    200|    res = xmlSchemaPValAttrID(ctxt, node, BAD_CAST "id");
  ------------------
  |  |   35|    200|#define BAD_CAST (xmlChar *)
  ------------------
 9621|    200|    HFAILURE;
  ------------------
  |  |  333|    200|#define HFAILURE if (res == -1) goto exit_failure;
  |  |  ------------------
  |  |  |  Branch (333:22): [True: 0, False: 200]
  |  |  ------------------
  ------------------
 9622|       |
 9623|       |    /*
 9624|       |    * Since the version is of type xs:token, we won't bother to
 9625|       |    * check it.
 9626|       |    */
 9627|       |    /* REMOVED:
 9628|       |    attr = xmlSchemaGetPropNode(node, "version");
 9629|       |    if (attr != NULL) {
 9630|       |	res = xmlSchemaPValAttrNode(ctxt, NULL, NULL, attr,
 9631|       |	    xmlSchemaGetBuiltInType(XML_SCHEMAS_TOKEN), &val);
 9632|       |	HFAILURE;
 9633|       |    }
 9634|       |    */
 9635|    200|    attr = xmlSchemaGetPropNode(node, "targetNamespace");
 9636|    200|    if (attr != NULL) {
  ------------------
  |  Branch (9636:9): [True: 114, False: 86]
  ------------------
 9637|    114|	res = xmlSchemaPValAttrNode(ctxt, NULL, attr,
 9638|    114|	    xmlSchemaGetBuiltInType(XML_SCHEMAS_ANYURI), NULL);
 9639|    114|	HFAILURE;
  ------------------
  |  |  333|    114|#define HFAILURE if (res == -1) goto exit_failure;
  |  |  ------------------
  |  |  |  Branch (333:22): [True: 0, False: 114]
  |  |  ------------------
  ------------------
 9640|    114|	if (res != 0) {
  ------------------
  |  Branch (9640:6): [True: 0, False: 114]
  ------------------
 9641|      0|	    ctxt->stop = XML_SCHEMAP_S4S_ATTR_INVALID_VALUE;
 9642|      0|	    goto exit;
 9643|      0|	}
 9644|    114|    }
 9645|    200|    attr = xmlSchemaGetPropNode(node, "elementFormDefault");
 9646|    200|    if (attr != NULL) {
  ------------------
  |  Branch (9646:9): [True: 74, False: 126]
  ------------------
 9647|     74|	val = xmlSchemaGetNodeContent(ctxt, (xmlNodePtr) attr);
 9648|     74|	res = xmlSchemaPValAttrFormDefault(val, &schema->flags,
 9649|     74|	    XML_SCHEMAS_QUALIF_ELEM);
  ------------------
  |  |  861|     74|#define XML_SCHEMAS_QUALIF_ELEM                1 << 0
  ------------------
 9650|     74|	HFAILURE;
  ------------------
  |  |  333|     74|#define HFAILURE if (res == -1) goto exit_failure;
  |  |  ------------------
  |  |  |  Branch (333:22): [True: 0, False: 74]
  |  |  ------------------
  ------------------
 9651|     74|	if (res != 0) {
  ------------------
  |  Branch (9651:6): [True: 0, False: 74]
  ------------------
 9652|      0|	    xmlSchemaPSimpleTypeErr(ctxt,
 9653|      0|		XML_SCHEMAP_ELEMFORMDEFAULT_VALUE,
 9654|      0|		NULL, (xmlNodePtr) attr, NULL,
 9655|      0|		"(qualified | unqualified)", val, NULL, NULL, NULL);
 9656|      0|	}
 9657|     74|    }
 9658|    200|    attr = xmlSchemaGetPropNode(node, "attributeFormDefault");
 9659|    200|    if (attr != NULL) {
  ------------------
  |  Branch (9659:9): [True: 46, False: 154]
  ------------------
 9660|     46|	val = xmlSchemaGetNodeContent(ctxt, (xmlNodePtr) attr);
 9661|     46|	res = xmlSchemaPValAttrFormDefault(val, &schema->flags,
 9662|     46|	    XML_SCHEMAS_QUALIF_ATTR);
  ------------------
  |  |  868|     46|#define XML_SCHEMAS_QUALIF_ATTR            1 << 1
  ------------------
 9663|     46|	HFAILURE;
  ------------------
  |  |  333|     46|#define HFAILURE if (res == -1) goto exit_failure;
  |  |  ------------------
  |  |  |  Branch (333:22): [True: 0, False: 46]
  |  |  ------------------
  ------------------
 9664|     46|	if (res != 0) {
  ------------------
  |  Branch (9664:6): [True: 0, False: 46]
  ------------------
 9665|      0|	    xmlSchemaPSimpleTypeErr(ctxt,
 9666|      0|		XML_SCHEMAP_ATTRFORMDEFAULT_VALUE,
 9667|      0|		NULL, (xmlNodePtr) attr, NULL,
 9668|      0|		"(qualified | unqualified)", val, NULL, NULL, NULL);
 9669|      0|	}
 9670|     46|    }
 9671|    200|    attr = xmlSchemaGetPropNode(node, "finalDefault");
 9672|    200|    if (attr != NULL) {
  ------------------
  |  Branch (9672:9): [True: 1, False: 199]
  ------------------
 9673|      1|	val = xmlSchemaGetNodeContent(ctxt, (xmlNodePtr) attr);
 9674|      1|	res = xmlSchemaPValAttrBlockFinal(val, &(schema->flags), -1,
 9675|      1|	    XML_SCHEMAS_FINAL_DEFAULT_EXTENSION,
  ------------------
  |  |  874|      1|#define XML_SCHEMAS_FINAL_DEFAULT_EXTENSION        1 << 2
  ------------------
 9676|      1|	    XML_SCHEMAS_FINAL_DEFAULT_RESTRICTION,
  ------------------
  |  |  880|      1|#define XML_SCHEMAS_FINAL_DEFAULT_RESTRICTION            1 << 3
  ------------------
 9677|      1|	    -1,
 9678|      1|	    XML_SCHEMAS_FINAL_DEFAULT_LIST,
  ------------------
  |  |  886|      1|#define XML_SCHEMAS_FINAL_DEFAULT_LIST            1 << 4
  ------------------
 9679|      1|	    XML_SCHEMAS_FINAL_DEFAULT_UNION);
  ------------------
  |  |  892|      1|#define XML_SCHEMAS_FINAL_DEFAULT_UNION            1 << 5
  ------------------
 9680|      1|	HFAILURE;
  ------------------
  |  |  333|      1|#define HFAILURE if (res == -1) goto exit_failure;
  |  |  ------------------
  |  |  |  Branch (333:22): [True: 0, False: 1]
  |  |  ------------------
  ------------------
 9681|      1|	if (res != 0) {
  ------------------
  |  Branch (9681:6): [True: 0, False: 1]
  ------------------
 9682|      0|	    xmlSchemaPSimpleTypeErr(ctxt,
 9683|      0|		XML_SCHEMAP_S4S_ATTR_INVALID_VALUE,
 9684|      0|		NULL, (xmlNodePtr) attr, NULL,
 9685|      0|		"(#all | List of (extension | restriction | list | union))",
 9686|      0|		val, NULL, NULL, NULL);
 9687|      0|	}
 9688|      1|    }
 9689|    200|    attr = xmlSchemaGetPropNode(node, "blockDefault");
 9690|    200|    if (attr != NULL) {
  ------------------
  |  Branch (9690:9): [True: 1, False: 199]
  ------------------
 9691|      1|	val = xmlSchemaGetNodeContent(ctxt, (xmlNodePtr) attr);
 9692|      1|	res = xmlSchemaPValAttrBlockFinal(val, &(schema->flags), -1,
 9693|      1|	    XML_SCHEMAS_BLOCK_DEFAULT_EXTENSION,
  ------------------
  |  |  898|      1|#define XML_SCHEMAS_BLOCK_DEFAULT_EXTENSION            1 << 6
  ------------------
 9694|      1|	    XML_SCHEMAS_BLOCK_DEFAULT_RESTRICTION,
  ------------------
  |  |  904|      1|#define XML_SCHEMAS_BLOCK_DEFAULT_RESTRICTION            1 << 7
  ------------------
 9695|      1|	    XML_SCHEMAS_BLOCK_DEFAULT_SUBSTITUTION, -1, -1);
  ------------------
  |  |  910|      1|#define XML_SCHEMAS_BLOCK_DEFAULT_SUBSTITUTION            1 << 8
  ------------------
 9696|      1|	HFAILURE;
  ------------------
  |  |  333|      1|#define HFAILURE if (res == -1) goto exit_failure;
  |  |  ------------------
  |  |  |  Branch (333:22): [True: 0, False: 1]
  |  |  ------------------
  ------------------
 9697|      1|	if (res != 0) {
  ------------------
  |  Branch (9697:6): [True: 0, False: 1]
  ------------------
 9698|      0|	    xmlSchemaPSimpleTypeErr(ctxt,
 9699|      0|		XML_SCHEMAP_S4S_ATTR_INVALID_VALUE,
 9700|      0|		NULL, (xmlNodePtr) attr, NULL,
 9701|      0|		"(#all | List of (extension | restriction | substitution))",
 9702|      0|		val, NULL, NULL, NULL);
 9703|      0|	}
 9704|      1|    }
 9705|       |
 9706|    200|exit:
 9707|    200|    if (oldErrs != ctxt->nberrors)
  ------------------
  |  Branch (9707:9): [True: 0, False: 200]
  ------------------
 9708|      0|	res = ctxt->err;
 9709|    200|    return(res);
 9710|      0|exit_failure:
 9711|      0|    return(-1);
 9712|    200|}
xmlschemas.c:xmlSchemaPValAttrID:
 5943|  2.42k|{
 5944|  2.42k|    xmlAttrPtr attr;
 5945|       |
 5946|  2.42k|    attr = xmlSchemaGetPropNode(ownerElem, (const char *) name);
 5947|  2.42k|    if (attr == NULL)
  ------------------
  |  Branch (5947:9): [True: 2.40k, False: 17]
  ------------------
 5948|  2.40k|	return(0);
 5949|     17|    return(xmlSchemaPValAttrNodeID(ctxt, attr));
 5950|       |
 5951|  2.42k|}
xmlschemas.c:xmlSchemaPValAttrNodeID:
 5886|     17|{
 5887|     17|    int ret;
 5888|     17|    const xmlChar *value;
 5889|       |
 5890|     17|    if (attr == NULL)
  ------------------
  |  Branch (5890:9): [True: 0, False: 17]
  ------------------
 5891|      0|	return(0);
 5892|     17|    value = xmlSchemaGetNodeContentNoDict((xmlNodePtr) attr);
 5893|     17|    ret = xmlValidateNCName(value, 1);
 5894|     17|    if (ret == 0) {
  ------------------
  |  Branch (5894:9): [True: 17, False: 0]
  ------------------
 5895|       |	/*
 5896|       |	* NOTE: the IDness might have already be declared in the DTD
 5897|       |	*/
 5898|     17|	if (attr->atype != XML_ATTRIBUTE_ID) {
  ------------------
  |  Branch (5898:6): [True: 17, False: 0]
  ------------------
 5899|     17|	    xmlIDPtr res;
 5900|     17|	    xmlChar *strip;
 5901|       |
 5902|       |	    /*
 5903|       |	    * TODO: Use xmlSchemaStrip here; it's not exported at this
 5904|       |	    * moment.
 5905|       |	    */
 5906|     17|	    strip = xmlSchemaCollapseString(value);
 5907|     17|	    if (strip != NULL) {
  ------------------
  |  Branch (5907:10): [True: 0, False: 17]
  ------------------
 5908|      0|		xmlFree((xmlChar *) value);
 5909|      0|		value = strip;
 5910|      0|	    }
 5911|     17|	    res = xmlAddID(NULL, attr->doc, value, attr);
 5912|     17|	    if (res == NULL) {
  ------------------
  |  Branch (5912:10): [True: 0, False: 17]
  ------------------
 5913|      0|		ret = XML_SCHEMAP_S4S_ATTR_INVALID_VALUE;
 5914|      0|		xmlSchemaPSimpleTypeErr(ctxt,
 5915|      0|		    XML_SCHEMAP_S4S_ATTR_INVALID_VALUE,
 5916|      0|		    NULL, (xmlNodePtr) attr,
 5917|      0|		    xmlSchemaGetBuiltInType(XML_SCHEMAS_ID),
 5918|      0|		    NULL, NULL, "Duplicate value '%s' of simple "
 5919|      0|		    "type 'xs:ID'", value, NULL);
 5920|      0|	    } else
 5921|     17|		attr->atype = XML_ATTRIBUTE_ID;
 5922|     17|	}
 5923|     17|    } else if (ret > 0) {
  ------------------
  |  Branch (5923:16): [True: 0, False: 0]
  ------------------
 5924|      0|	ret = XML_SCHEMAP_S4S_ATTR_INVALID_VALUE;
 5925|      0|	xmlSchemaPSimpleTypeErr(ctxt,
 5926|      0|	    XML_SCHEMAP_S4S_ATTR_INVALID_VALUE,
 5927|      0|	    NULL, (xmlNodePtr) attr,
 5928|      0|	    xmlSchemaGetBuiltInType(XML_SCHEMAS_ID),
 5929|      0|	    NULL, NULL, "The value '%s' of simple type 'xs:ID' is "
 5930|      0|	    "not a valid 'xs:NCName'",
 5931|      0|	    value, NULL);
 5932|      0|    }
 5933|     17|    if (value != NULL)
  ------------------
  |  Branch (5933:9): [True: 17, False: 0]
  ------------------
 5934|     17|	xmlFree((xmlChar *)value);
 5935|       |
 5936|     17|    return (ret);
 5937|     17|}
xmlschemas.c:xmlSchemaGetNodeContentNoDict:
 4684|     17|{
 4685|     17|    return((const xmlChar*) xmlNodeGetContent(node));
 4686|     17|}
xmlschemas.c:xmlSchemaGetPropNode:
 4623|  10.6k|{
 4624|  10.6k|    xmlAttrPtr prop;
 4625|       |
 4626|  10.6k|    if ((node == NULL) || (name == NULL))
  ------------------
  |  Branch (4626:9): [True: 0, False: 10.6k]
  |  Branch (4626:27): [True: 0, False: 10.6k]
  ------------------
 4627|      0|	return(NULL);
 4628|  10.6k|    prop = node->properties;
 4629|  22.2k|    while (prop != NULL) {
  ------------------
  |  Branch (4629:12): [True: 14.4k, False: 7.80k]
  ------------------
 4630|  14.4k|        if ((prop->ns == NULL) && xmlStrEqual(prop->name, BAD_CAST name))
  ------------------
  |  |   35|  14.4k|#define BAD_CAST (xmlChar *)
  ------------------
  |  Branch (4630:13): [True: 14.4k, False: 44]
  |  Branch (4630:35): [True: 2.84k, False: 11.5k]
  ------------------
 4631|  2.84k|	    return(prop);
 4632|  11.6k|	prop = prop->next;
 4633|  11.6k|    }
 4634|  7.80k|    return (NULL);
 4635|  10.6k|}
xmlschemas.c:xmlSchemaPValAttrNode:
 6309|  1.30k|{
 6310|  1.30k|    const xmlChar *val;
 6311|       |
 6312|  1.30k|    if ((ctxt == NULL) || (type == NULL) || (attr == NULL))
  ------------------
  |  Branch (6312:9): [True: 0, False: 1.30k]
  |  Branch (6312:27): [True: 0, False: 1.30k]
  |  Branch (6312:45): [True: 0, False: 1.30k]
  ------------------
 6313|      0|	return (-1);
 6314|       |
 6315|  1.30k|    val = xmlSchemaGetNodeContent(ctxt, (xmlNodePtr) attr);
 6316|  1.30k|    if (value != NULL)
  ------------------
  |  Branch (6316:9): [True: 1.18k, False: 125]
  ------------------
 6317|  1.18k|	*value = val;
 6318|       |
 6319|  1.30k|    return (xmlSchemaPValAttrNodeValue(ctxt, ownerItem, attr,
 6320|  1.30k|	val, type));
 6321|  1.30k|}
xmlschemas.c:xmlSchemaPValAttrNodeValue:
 6237|  1.34k|{
 6238|       |
 6239|  1.34k|    int ret = 0;
 6240|       |
 6241|       |    /*
 6242|       |    * NOTE: Should we move this to xmlschematypes.c? Hmm, but this
 6243|       |    * one is really meant to be used internally, so better not.
 6244|       |    */
 6245|  1.34k|    if ((pctxt == NULL) || (type == NULL) || (attr == NULL))
  ------------------
  |  Branch (6245:9): [True: 0, False: 1.34k]
  |  Branch (6245:28): [True: 0, False: 1.34k]
  |  Branch (6245:46): [True: 0, False: 1.34k]
  ------------------
 6246|      0|	return (-1);
 6247|  1.34k|    if (type->type != XML_SCHEMA_TYPE_BASIC) {
  ------------------
  |  Branch (6247:9): [True: 0, False: 1.34k]
  ------------------
 6248|      0|	PERROR_INT("xmlSchemaPValAttrNodeValue",
  ------------------
  |  | 2824|      0|#define PERROR_INT(func, msg) xmlSchemaInternalErr(ACTXT_CAST pctxt, func, msg);
  |  |  ------------------
  |  |  |  |  121|      0|#define ACTXT_CAST (xmlSchemaAbstractCtxtPtr)
  |  |  ------------------
  ------------------
 6249|      0|	    "the given type is not a built-in type");
 6250|      0|	return (-1);
 6251|      0|    }
 6252|  1.34k|    switch (type->builtInType) {
 6253|  1.11k|	case XML_SCHEMAS_NCNAME:
  ------------------
  |  Branch (6253:2): [True: 1.11k, False: 233]
  ------------------
 6254|  1.11k|	case XML_SCHEMAS_QNAME:
  ------------------
  |  Branch (6254:2): [True: 0, False: 1.34k]
  ------------------
 6255|  1.33k|	case XML_SCHEMAS_ANYURI:
  ------------------
  |  Branch (6255:2): [True: 223, False: 1.12k]
  ------------------
 6256|  1.33k|	case XML_SCHEMAS_TOKEN:
  ------------------
  |  Branch (6256:2): [True: 0, False: 1.34k]
  ------------------
 6257|  1.34k|	case XML_SCHEMAS_LANGUAGE:
  ------------------
  |  Branch (6257:2): [True: 10, False: 1.33k]
  ------------------
 6258|  1.34k|	    ret = xmlSchemaValPredefTypeNode(type, value, NULL,
 6259|  1.34k|		(xmlNodePtr) attr);
 6260|  1.34k|	    break;
 6261|      0|	default: {
  ------------------
  |  Branch (6261:2): [True: 0, False: 1.34k]
  ------------------
 6262|      0|	    PERROR_INT("xmlSchemaPValAttrNodeValue",
  ------------------
  |  | 2824|      0|#define PERROR_INT(func, msg) xmlSchemaInternalErr(ACTXT_CAST pctxt, func, msg);
  |  |  ------------------
  |  |  |  |  121|      0|#define ACTXT_CAST (xmlSchemaAbstractCtxtPtr)
  |  |  ------------------
  ------------------
 6263|      0|		"validation using the given type is not supported while "
 6264|      0|		"parsing a schema");
 6265|      0|	    return (-1);
 6266|  1.33k|	}
 6267|  1.34k|    }
 6268|       |    /*
 6269|       |    * TODO: Should we use the S4S error codes instead?
 6270|       |    */
 6271|  1.34k|    if (ret < 0) {
  ------------------
  |  Branch (6271:9): [True: 0, False: 1.34k]
  ------------------
 6272|      0|	PERROR_INT("xmlSchemaPValAttrNodeValue",
  ------------------
  |  | 2824|      0|#define PERROR_INT(func, msg) xmlSchemaInternalErr(ACTXT_CAST pctxt, func, msg);
  |  |  ------------------
  |  |  |  |  121|      0|#define ACTXT_CAST (xmlSchemaAbstractCtxtPtr)
  |  |  ------------------
  ------------------
 6273|      0|	    "failed to validate a schema attribute value");
 6274|      0|	return (-1);
 6275|  1.34k|    } else if (ret > 0) {
  ------------------
  |  Branch (6275:16): [True: 1, False: 1.34k]
  ------------------
 6276|      1|	if (WXS_IS_LIST(type))
  ------------------
  |  |  272|      1|#define WXS_IS_LIST(t) (t->flags & XML_SCHEMAS_TYPE_VARIETY_LIST)
  |  |  ------------------
  |  |  |  |  448|      1|#define XML_SCHEMAS_TYPE_VARIETY_LIST    1 << 6
  |  |  ------------------
  |  |  |  Branch (272:24): [True: 0, False: 1]
  |  |  ------------------
  ------------------
 6277|      0|	    ret = XML_SCHEMAV_CVC_DATATYPE_VALID_1_2_2;
 6278|      1|	else
 6279|      1|	    ret = XML_SCHEMAV_CVC_DATATYPE_VALID_1_2_1;
 6280|      1|	xmlSchemaPSimpleTypeErr(pctxt,
 6281|      1|	    ret, ownerItem, (xmlNodePtr) attr,
 6282|      1|	    type, NULL, value, NULL, NULL, NULL);
 6283|      1|    }
 6284|  1.34k|    return (ret);
 6285|  1.34k|}
xmlschemas.c:xmlSchemaGetNodeContent:
 4668|  3.08k|{
 4669|  3.08k|    xmlChar *val;
 4670|  3.08k|    const xmlChar *ret;
 4671|       |
 4672|  3.08k|    val = xmlNodeGetContent(node);
 4673|  3.08k|    if (val == NULL)
  ------------------
  |  Branch (4673:9): [True: 2, False: 3.08k]
  ------------------
 4674|      2|	val = xmlStrdup((xmlChar *)"");
 4675|  3.08k|    ret = xmlDictLookup(ctxt->dict, val, -1);
 4676|  3.08k|    xmlFree(val);
 4677|  3.08k|    if (ret == NULL)
  ------------------
  |  Branch (4677:9): [True: 0, False: 3.08k]
  ------------------
 4678|      0|        xmlSchemaPErrMemory(ctxt, "getting node content", node);
 4679|  3.08k|    return(ret);
 4680|  3.08k|}
xmlschemas.c:xmlSchemaPValAttrFormDefault:
 7844|    120|{
 7845|    120|    if (xmlStrEqual(value, BAD_CAST "qualified")) {
  ------------------
  |  |   35|    120|#define BAD_CAST (xmlChar *)
  ------------------
  |  Branch (7845:9): [True: 73, False: 47]
  ------------------
 7846|     73|	if  ((*flags & flagQualified) == 0)
  ------------------
  |  Branch (7846:7): [True: 73, False: 0]
  ------------------
 7847|     73|	    *flags |= flagQualified;
 7848|     73|    } else if (!xmlStrEqual(value, BAD_CAST "unqualified"))
  ------------------
  |  |   35|     47|#define BAD_CAST (xmlChar *)
  ------------------
  |  Branch (7848:16): [True: 0, False: 47]
  ------------------
 7849|      0|	return (1);
 7850|       |
 7851|    120|    return (0);
 7852|    120|}
xmlschemas.c:xmlSchemaPSimpleTypeErr:
 3176|      6|{
 3177|      6|    xmlChar *msg = NULL;
 3178|       |
 3179|      6|    xmlSchemaFormatNodeForError(&msg, ACTXT_CAST ctxt, node);
  ------------------
  |  |  121|      6|#define ACTXT_CAST (xmlSchemaAbstractCtxtPtr)
  ------------------
 3180|      6|    if (message == NULL) {
  ------------------
  |  Branch (3180:9): [True: 4, False: 2]
  ------------------
 3181|       |	/*
 3182|       |	* Use default messages.
 3183|       |	*/
 3184|      4|	if (type != NULL) {
  ------------------
  |  Branch (3184:6): [True: 1, False: 3]
  ------------------
 3185|      1|	    if (node->type == XML_ATTRIBUTE_NODE)
  ------------------
  |  Branch (3185:10): [True: 1, False: 0]
  ------------------
 3186|      1|		msg = xmlStrcat(msg, BAD_CAST "'%s' is not a valid value of ");
  ------------------
  |  |   35|      1|#define BAD_CAST (xmlChar *)
  ------------------
 3187|      0|	    else
 3188|      0|		msg = xmlStrcat(msg, BAD_CAST "The character content is not a "
  ------------------
  |  |   35|      0|#define BAD_CAST (xmlChar *)
  ------------------
 3189|      0|		"valid value of ");
 3190|      1|	    if (! xmlSchemaIsGlobalItem(type))
  ------------------
  |  Branch (3190:10): [True: 0, False: 1]
  ------------------
 3191|      0|		msg = xmlStrcat(msg, BAD_CAST "the local ");
  ------------------
  |  |   35|      0|#define BAD_CAST (xmlChar *)
  ------------------
 3192|      1|	    else
 3193|      1|		msg = xmlStrcat(msg, BAD_CAST "the ");
  ------------------
  |  |   35|      1|#define BAD_CAST (xmlChar *)
  ------------------
 3194|       |
 3195|      1|	    if (WXS_IS_ATOMIC(type))
  ------------------
  |  |  270|      1|#define WXS_IS_ATOMIC(t) (t->flags & XML_SCHEMAS_TYPE_VARIETY_ATOMIC)
  |  |  ------------------
  |  |  |  |  460|      1|#define XML_SCHEMAS_TYPE_VARIETY_ATOMIC    1 << 8
  |  |  ------------------
  |  |  |  Branch (270:26): [True: 1, False: 0]
  |  |  ------------------
  ------------------
 3196|      1|		msg = xmlStrcat(msg, BAD_CAST "atomic type");
  ------------------
  |  |   35|      1|#define BAD_CAST (xmlChar *)
  ------------------
 3197|      0|	    else if (WXS_IS_LIST(type))
  ------------------
  |  |  272|      0|#define WXS_IS_LIST(t) (t->flags & XML_SCHEMAS_TYPE_VARIETY_LIST)
  |  |  ------------------
  |  |  |  |  448|      0|#define XML_SCHEMAS_TYPE_VARIETY_LIST    1 << 6
  |  |  ------------------
  |  |  |  Branch (272:24): [True: 0, False: 0]
  |  |  ------------------
  ------------------
 3198|      0|		msg = xmlStrcat(msg, BAD_CAST "list type");
  ------------------
  |  |   35|      0|#define BAD_CAST (xmlChar *)
  ------------------
 3199|      0|	    else if (WXS_IS_UNION(type))
  ------------------
  |  |  274|      0|#define WXS_IS_UNION(t) (t->flags & XML_SCHEMAS_TYPE_VARIETY_UNION)
  |  |  ------------------
  |  |  |  |  454|      0|#define XML_SCHEMAS_TYPE_VARIETY_UNION    1 << 7
  |  |  ------------------
  |  |  |  Branch (274:25): [True: 0, False: 0]
  |  |  ------------------
  ------------------
 3200|      0|		msg = xmlStrcat(msg, BAD_CAST "union type");
  ------------------
  |  |   35|      0|#define BAD_CAST (xmlChar *)
  ------------------
 3201|       |
 3202|      1|	    if (xmlSchemaIsGlobalItem(type)) {
  ------------------
  |  Branch (3202:10): [True: 1, False: 0]
  ------------------
 3203|      1|		xmlChar *str = NULL;
 3204|      1|		msg = xmlStrcat(msg, BAD_CAST " '");
  ------------------
  |  |   35|      1|#define BAD_CAST (xmlChar *)
  ------------------
 3205|      1|		if (type->builtInType != 0) {
  ------------------
  |  Branch (3205:7): [True: 1, False: 0]
  ------------------
 3206|      1|		    msg = xmlStrcat(msg, BAD_CAST "xs:");
  ------------------
  |  |   35|      1|#define BAD_CAST (xmlChar *)
  ------------------
 3207|      1|		    str = xmlStrdup(type->name);
 3208|      1|		} else {
 3209|      0|		    const xmlChar *qName = xmlSchemaFormatQName(&str, type->targetNamespace, type->name);
 3210|      0|		    if (!str)
  ------------------
  |  Branch (3210:11): [True: 0, False: 0]
  ------------------
 3211|      0|			str = xmlStrdup(qName);
 3212|      0|		}
 3213|      1|		msg = xmlStrcat(msg, xmlEscapeFormatString(&str));
 3214|      1|		msg = xmlStrcat(msg, BAD_CAST "'.");
  ------------------
  |  |   35|      1|#define BAD_CAST (xmlChar *)
  ------------------
 3215|      1|		FREE_AND_NULL(str);
  ------------------
  |  |  320|      1|#define FREE_AND_NULL(str) if ((str) != NULL) { xmlFree((xmlChar *) (str)); str = NULL; }
  |  |  ------------------
  |  |  |  Branch (320:32): [True: 1, False: 0]
  |  |  ------------------
  ------------------
 3216|      1|	    }
 3217|      3|	} else {
 3218|      3|	    if (node->type == XML_ATTRIBUTE_NODE)
  ------------------
  |  Branch (3218:10): [True: 3, False: 0]
  ------------------
 3219|      3|		msg = xmlStrcat(msg, BAD_CAST "The value '%s' is not valid.");
  ------------------
  |  |   35|      3|#define BAD_CAST (xmlChar *)
  ------------------
 3220|      0|	    else
 3221|      0|		msg = xmlStrcat(msg, BAD_CAST "The character content is not "
  ------------------
  |  |   35|      0|#define BAD_CAST (xmlChar *)
  ------------------
 3222|      0|		"valid.");
 3223|      3|	}
 3224|      4|	if (expected) {
  ------------------
  |  Branch (3224:6): [True: 3, False: 1]
  ------------------
 3225|      3|	    xmlChar *expectedEscaped = xmlCharStrdup(expected);
 3226|      3|	    msg = xmlStrcat(msg, BAD_CAST " Expected is '");
  ------------------
  |  |   35|      3|#define BAD_CAST (xmlChar *)
  ------------------
 3227|      3|	    msg = xmlStrcat(msg, xmlEscapeFormatString(&expectedEscaped));
 3228|      3|	    FREE_AND_NULL(expectedEscaped);
  ------------------
  |  |  320|      3|#define FREE_AND_NULL(str) if ((str) != NULL) { xmlFree((xmlChar *) (str)); str = NULL; }
  |  |  ------------------
  |  |  |  Branch (320:32): [True: 3, False: 0]
  |  |  ------------------
  ------------------
 3229|      3|	    msg = xmlStrcat(msg, BAD_CAST "'.\n");
  ------------------
  |  |   35|      3|#define BAD_CAST (xmlChar *)
  ------------------
 3230|      3|	} else
 3231|      1|	    msg = xmlStrcat(msg, BAD_CAST "\n");
  ------------------
  |  |   35|      1|#define BAD_CAST (xmlChar *)
  ------------------
 3232|      4|	if (node->type == XML_ATTRIBUTE_NODE)
  ------------------
  |  Branch (3232:6): [True: 4, False: 0]
  ------------------
 3233|      4|	    xmlSchemaPErr(ctxt, node, error, (const char *) msg, value, NULL);
 3234|      0|	else
 3235|      0|	    xmlSchemaPErr(ctxt, node, error, (const char *) msg, NULL, NULL);
 3236|      4|    } else {
 3237|      2|	msg = xmlStrcat(msg, BAD_CAST message);
  ------------------
  |  |   35|      2|#define BAD_CAST (xmlChar *)
  ------------------
 3238|      2|	msg = xmlStrcat(msg, BAD_CAST ".\n");
  ------------------
  |  |   35|      2|#define BAD_CAST (xmlChar *)
  ------------------
 3239|      2|	xmlSchemaPErrExt(ctxt, node, error, NULL, NULL, NULL,
 3240|      2|	     (const char*) msg, str1, str2, NULL, NULL, NULL);
 3241|      2|    }
 3242|       |    /* Cleanup. */
 3243|      6|    FREE_AND_NULL(msg)
  ------------------
  |  |  320|      6|#define FREE_AND_NULL(str) if ((str) != NULL) { xmlFree((xmlChar *) (str)); str = NULL; }
  |  |  ------------------
  |  |  |  Branch (320:32): [True: 6, False: 0]
  |  |  ------------------
  ------------------
 3244|      6|}
xmlschemas.c:xmlSchemaIsGlobalItem:
 2483|      2|{
 2484|      2|    switch (item->type) {
 2485|      0|	case XML_SCHEMA_TYPE_COMPLEX:
  ------------------
  |  Branch (2485:2): [True: 0, False: 2]
  ------------------
 2486|      0|	case XML_SCHEMA_TYPE_SIMPLE:
  ------------------
  |  Branch (2486:2): [True: 0, False: 2]
  ------------------
 2487|      0|	    if (item->flags & XML_SCHEMAS_TYPE_GLOBAL)
  ------------------
  |  |  426|      0|#define XML_SCHEMAS_TYPE_GLOBAL                1 << 3
  ------------------
  |  Branch (2487:10): [True: 0, False: 0]
  ------------------
 2488|      0|		return(1);
 2489|      0|	    break;
 2490|      0|	case XML_SCHEMA_TYPE_GROUP:
  ------------------
  |  Branch (2490:2): [True: 0, False: 2]
  ------------------
 2491|      0|	    return (1);
 2492|      0|	case XML_SCHEMA_TYPE_ELEMENT:
  ------------------
  |  Branch (2492:2): [True: 0, False: 2]
  ------------------
 2493|      0|	    if ( ((xmlSchemaElementPtr) item)->flags &
  ------------------
  |  Branch (2493:11): [True: 0, False: 0]
  ------------------
 2494|      0|		XML_SCHEMAS_ELEM_GLOBAL)
  ------------------
  |  |  655|      0|#define XML_SCHEMAS_ELEM_GLOBAL                1 << 1
  ------------------
 2495|      0|		return(1);
 2496|      0|	    break;
 2497|      0|	case XML_SCHEMA_TYPE_ATTRIBUTE:
  ------------------
  |  Branch (2497:2): [True: 0, False: 2]
  ------------------
 2498|      0|	    if ( ((xmlSchemaAttributePtr) item)->flags &
  ------------------
  |  Branch (2498:11): [True: 0, False: 0]
  ------------------
 2499|      0|		XML_SCHEMAS_ATTR_GLOBAL)
  ------------------
  |  |  220|      0|#define XML_SCHEMAS_ATTR_GLOBAL        1 << 0
  ------------------
 2500|      0|		return(1);
 2501|      0|	    break;
 2502|       |	/* Note that attribute groups are always global. */
 2503|      2|	default:
  ------------------
  |  Branch (2503:2): [True: 2, False: 0]
  ------------------
 2504|      2|	    return(1);
 2505|      2|    }
 2506|      0|    return (0);
 2507|      2|}
xmlschemas.c:xmlSchemaPErrExt:
 2013|     38|{
 2014|       |
 2015|     38|    xmlGenericErrorFunc channel = NULL;
 2016|     38|    xmlStructuredErrorFunc schannel = NULL;
 2017|     38|    void *data = NULL;
 2018|       |
 2019|     38|    if (ctxt != NULL) {
  ------------------
  |  Branch (2019:9): [True: 38, False: 0]
  ------------------
 2020|     38|        ctxt->nberrors++;
 2021|     38|	ctxt->err = error;
 2022|     38|        channel = ctxt->error;
 2023|     38|        data = ctxt->errCtxt;
 2024|     38|	schannel = ctxt->serror;
 2025|     38|    }
 2026|     38|    __xmlRaiseError(schannel, channel, data, ctxt, node, XML_FROM_SCHEMASP,
 2027|     38|                    error, XML_ERR_ERROR, NULL, 0,
 2028|     38|                    (const char *) strData1, (const char *) strData2,
 2029|     38|		    (const char *) strData3, 0, 0, msg, str1, str2,
 2030|     38|		    str3, str4, str5);
 2031|     38|}
xmlschemas.c:xmlSchemaPValAttrBlockFinal:
 7880|      8|{
 7881|      8|    int ret = 0;
 7882|       |
 7883|       |    /*
 7884|       |    * TODO: This does not check for duplicate entries.
 7885|       |    */
 7886|      8|    if ((flags == NULL) || (value == NULL))
  ------------------
  |  Branch (7886:9): [True: 0, False: 8]
  |  Branch (7886:28): [True: 0, False: 8]
  ------------------
 7887|      0|	return (-1);
 7888|      8|    if (value[0] == 0)
  ------------------
  |  Branch (7888:9): [True: 0, False: 8]
  ------------------
 7889|      0|	return (0);
 7890|      8|    if (xmlStrEqual(value, BAD_CAST "#all")) {
  ------------------
  |  |   35|      8|#define BAD_CAST (xmlChar *)
  ------------------
  |  Branch (7890:9): [True: 1, False: 7]
  ------------------
 7891|      1|	if (flagAll != -1)
  ------------------
  |  Branch (7891:6): [True: 0, False: 1]
  ------------------
 7892|      0|	    *flags |= flagAll;
 7893|      1|	else {
 7894|      1|	    if (flagExtension != -1)
  ------------------
  |  Branch (7894:10): [True: 1, False: 0]
  ------------------
 7895|      1|		*flags |= flagExtension;
 7896|      1|	    if (flagRestriction != -1)
  ------------------
  |  Branch (7896:10): [True: 1, False: 0]
  ------------------
 7897|      1|		*flags |= flagRestriction;
 7898|      1|	    if (flagSubstitution != -1)
  ------------------
  |  Branch (7898:10): [True: 1, False: 0]
  ------------------
 7899|      1|		*flags |= flagSubstitution;
 7900|      1|	    if (flagList != -1)
  ------------------
  |  Branch (7900:10): [True: 0, False: 1]
  ------------------
 7901|      0|		*flags |= flagList;
 7902|      1|	    if (flagUnion != -1)
  ------------------
  |  Branch (7902:10): [True: 0, False: 1]
  ------------------
 7903|      0|		*flags |= flagUnion;
 7904|      1|	}
 7905|      7|    } else {
 7906|      7|	const xmlChar *end, *cur = value;
 7907|      7|	xmlChar *item;
 7908|       |
 7909|      8|	do {
 7910|      8|	    while (IS_BLANK_CH(*cur))
 7911|      1|		cur++;
 7912|      8|	    end = cur;
 7913|     74|	    while ((*end != 0) && (!(IS_BLANK_CH(*end))))
  ------------------
  |  |  151|     67|#define IS_BLANK_CH(c)  xmlIsBlank_ch(c)
  |  |  ------------------
  |  |  |  |   88|     67|#define xmlIsBlank_ch(c)	(((c) == 0x20) || \
  |  |  |  |  ------------------
  |  |  |  |  |  Branch (88:27): [True: 1, False: 66]
  |  |  |  |  ------------------
  |  |  |  |   89|     67|				 ((0x9 <= (c)) && ((c) <= 0xa)) || \
  |  |  |  |  ------------------
  |  |  |  |  |  Branch (89:7): [True: 66, False: 0]
  |  |  |  |  |  Branch (89:23): [True: 0, False: 66]
  |  |  |  |  ------------------
  |  |  |  |   90|     67|				 ((c) == 0xd))
  |  |  |  |  ------------------
  |  |  |  |  |  Branch (90:6): [True: 0, False: 66]
  |  |  |  |  ------------------
  |  |  ------------------
  ------------------
  |  Branch (7913:13): [True: 67, False: 7]
  ------------------
 7914|     66|		end++;
 7915|      8|	    if (end == cur)
  ------------------
  |  Branch (7915:10): [True: 0, False: 8]
  ------------------
 7916|      0|		break;
 7917|      8|	    item = xmlStrndup(cur, end - cur);
 7918|      8|	    if (xmlStrEqual(item, BAD_CAST "extension")) {
  ------------------
  |  |   35|      8|#define BAD_CAST (xmlChar *)
  ------------------
  |  Branch (7918:10): [True: 3, False: 5]
  ------------------
 7919|      3|		if (flagExtension != -1) {
  ------------------
  |  Branch (7919:7): [True: 3, False: 0]
  ------------------
 7920|      3|		    if ((*flags & flagExtension) == 0)
  ------------------
  |  Branch (7920:11): [True: 3, False: 0]
  ------------------
 7921|      3|			*flags |= flagExtension;
 7922|      3|		} else
 7923|      0|		    ret = 1;
 7924|      5|	    } else if (xmlStrEqual(item, BAD_CAST "restriction")) {
  ------------------
  |  |   35|      5|#define BAD_CAST (xmlChar *)
  ------------------
  |  Branch (7924:17): [True: 2, False: 3]
  ------------------
 7925|      2|		if (flagRestriction != -1) {
  ------------------
  |  Branch (7925:7): [True: 2, False: 0]
  ------------------
 7926|      2|		    if ((*flags & flagRestriction) == 0)
  ------------------
  |  Branch (7926:11): [True: 2, False: 0]
  ------------------
 7927|      2|			*flags |= flagRestriction;
 7928|      2|		} else
 7929|      0|		    ret = 1;
 7930|      3|	    } else if (xmlStrEqual(item, BAD_CAST "substitution")) {
  ------------------
  |  |   35|      3|#define BAD_CAST (xmlChar *)
  ------------------
  |  Branch (7930:17): [True: 0, False: 3]
  ------------------
 7931|      0|		if (flagSubstitution != -1) {
  ------------------
  |  Branch (7931:7): [True: 0, False: 0]
  ------------------
 7932|      0|		    if ((*flags & flagSubstitution) == 0)
  ------------------
  |  Branch (7932:11): [True: 0, False: 0]
  ------------------
 7933|      0|			*flags |= flagSubstitution;
 7934|      0|		} else
 7935|      0|		    ret = 1;
 7936|      3|	    } else if (xmlStrEqual(item, BAD_CAST "list")) {
  ------------------
  |  |   35|      3|#define BAD_CAST (xmlChar *)
  ------------------
  |  Branch (7936:17): [True: 0, False: 3]
  ------------------
 7937|      0|		if (flagList != -1) {
  ------------------
  |  Branch (7937:7): [True: 0, False: 0]
  ------------------
 7938|      0|		    if ((*flags & flagList) == 0)
  ------------------
  |  Branch (7938:11): [True: 0, False: 0]
  ------------------
 7939|      0|			*flags |= flagList;
 7940|      0|		} else
 7941|      0|		    ret = 1;
 7942|      3|	    } else if (xmlStrEqual(item, BAD_CAST "union")) {
  ------------------
  |  |   35|      3|#define BAD_CAST (xmlChar *)
  ------------------
  |  Branch (7942:17): [True: 0, False: 3]
  ------------------
 7943|      0|		if (flagUnion != -1) {
  ------------------
  |  Branch (7943:7): [True: 0, False: 0]
  ------------------
 7944|      0|		    if ((*flags & flagUnion) == 0)
  ------------------
  |  Branch (7944:11): [True: 0, False: 0]
  ------------------
 7945|      0|			*flags |= flagUnion;
 7946|      0|		} else
 7947|      0|		    ret = 1;
 7948|      0|	    } else
 7949|      3|		ret = 1;
 7950|      8|	    if (item != NULL)
  ------------------
  |  Branch (7950:10): [True: 8, False: 0]
  ------------------
 7951|      8|		xmlFree(item);
 7952|      8|	    cur = end;
 7953|      8|	} while ((ret == 0) && (*cur != 0));
  ------------------
  |  Branch (7953:11): [True: 5, False: 3]
  |  Branch (7953:25): [True: 1, False: 4]
  ------------------
 7954|      7|    }
 7955|       |
 7956|      0|    return (ret);
 7957|      8|}
xmlschemas.c:xmlSchemaParseSchemaTopLevel:
 9726|    192|{
 9727|    192|    xmlNodePtr child;
 9728|    192|    xmlSchemaAnnotPtr annot;
 9729|    192|    int res = 0, oldErrs, tmpOldErrs;
 9730|       |
 9731|    192|    if ((ctxt == NULL) || (schema == NULL) || (nodes == NULL))
  ------------------
  |  Branch (9731:9): [True: 0, False: 192]
  |  Branch (9731:27): [True: 0, False: 192]
  |  Branch (9731:47): [True: 0, False: 192]
  ------------------
 9732|      0|        return(-1);
 9733|       |
 9734|    192|    oldErrs = ctxt->nberrors;
 9735|    192|    child = nodes;
 9736|    245|    while ((IS_SCHEMA(child, "include")) ||
  ------------------
  |  |  316|    245|   ((node != NULL) && (node->ns != NULL) && \
  |  |  ------------------
  |  |  |  Branch (316:5): [True: 237, False: 8]
  |  |  |  Branch (316:23): [True: 237, False: 0]
  |  |  ------------------
  |  |  317|    245|    (xmlStrEqual(node->name, (const xmlChar *) type)) && \
  |  |  ------------------
  |  |  |  Branch (317:5): [True: 29, False: 208]
  |  |  ------------------
  |  |  318|    245|    (xmlStrEqual(node->ns->href, xmlSchemaNs)))
  |  |  ------------------
  |  |  |  Branch (318:5): [True: 29, False: 0]
  |  |  ------------------
  ------------------
 9737|    245|	   (IS_SCHEMA(child, "import")) ||
  ------------------
  |  |  316|    216|   ((node != NULL) && (node->ns != NULL) && \
  |  |  ------------------
  |  |  |  Branch (316:5): [True: 208, False: 8]
  |  |  |  Branch (316:23): [True: 208, False: 0]
  |  |  ------------------
  |  |  317|    216|    (xmlStrEqual(node->name, (const xmlChar *) type)) && \
  |  |  ------------------
  |  |  |  Branch (317:5): [True: 20, False: 188]
  |  |  ------------------
  |  |  318|    216|    (xmlStrEqual(node->ns->href, xmlSchemaNs)))
  |  |  ------------------
  |  |  |  Branch (318:5): [True: 20, False: 0]
  |  |  ------------------
  ------------------
 9738|    245|	   (IS_SCHEMA(child, "redefine")) ||
  ------------------
  |  |  316|    196|   ((node != NULL) && (node->ns != NULL) && \
  |  |  ------------------
  |  |  |  Branch (316:5): [True: 188, False: 8]
  |  |  |  Branch (316:23): [True: 188, False: 0]
  |  |  ------------------
  |  |  317|    196|    (xmlStrEqual(node->name, (const xmlChar *) type)) && \
  |  |  ------------------
  |  |  |  Branch (317:5): [True: 0, False: 188]
  |  |  ------------------
  |  |  318|    196|    (xmlStrEqual(node->ns->href, xmlSchemaNs)))
  |  |  ------------------
  |  |  |  Branch (318:5): [True: 0, False: 0]
  |  |  ------------------
  ------------------
 9739|    245|	   (IS_SCHEMA(child, "annotation"))) {
  ------------------
  |  |  316|    196|   ((node != NULL) && (node->ns != NULL) && \
  |  |  ------------------
  |  |  |  Branch (316:5): [True: 188, False: 8]
  |  |  |  Branch (316:23): [True: 188, False: 0]
  |  |  ------------------
  |  |  317|    196|    (xmlStrEqual(node->name, (const xmlChar *) type)) && \
  |  |  ------------------
  |  |  |  Branch (317:5): [True: 18, False: 170]
  |  |  ------------------
  |  |  318|    196|    (xmlStrEqual(node->ns->href, xmlSchemaNs)))
  |  |  ------------------
  |  |  |  Branch (318:5): [True: 18, False: 0]
  |  |  ------------------
  ------------------
 9740|     67|	if (IS_SCHEMA(child, "annotation")) {
  ------------------
  |  |  316|     67|   ((node != NULL) && (node->ns != NULL) && \
  |  |  ------------------
  |  |  |  Branch (316:5): [True: 67, False: 0]
  |  |  |  Branch (316:23): [True: 67, False: 0]
  |  |  ------------------
  |  |  317|     67|    (xmlStrEqual(node->name, (const xmlChar *) type)) && \
  |  |  ------------------
  |  |  |  Branch (317:5): [True: 18, False: 49]
  |  |  ------------------
  |  |  318|     67|    (xmlStrEqual(node->ns->href, xmlSchemaNs)))
  |  |  ------------------
  |  |  |  Branch (318:5): [True: 18, False: 0]
  |  |  ------------------
  ------------------
 9741|     18|	    annot = xmlSchemaParseAnnotation(ctxt, child, 1);
 9742|     18|	    if (schema->annot == NULL)
  ------------------
  |  Branch (9742:10): [True: 12, False: 6]
  ------------------
 9743|     12|		schema->annot = annot;
 9744|      6|	    else
 9745|      6|		xmlSchemaFreeAnnot(annot);
 9746|     49|	} else if (IS_SCHEMA(child, "import")) {
  ------------------
  |  |  316|     49|   ((node != NULL) && (node->ns != NULL) && \
  |  |  ------------------
  |  |  |  Branch (316:5): [True: 49, False: 0]
  |  |  |  Branch (316:23): [True: 49, False: 0]
  |  |  ------------------
  |  |  317|     49|    (xmlStrEqual(node->name, (const xmlChar *) type)) && \
  |  |  ------------------
  |  |  |  Branch (317:5): [True: 20, False: 29]
  |  |  ------------------
  |  |  318|     49|    (xmlStrEqual(node->ns->href, xmlSchemaNs)))
  |  |  ------------------
  |  |  |  Branch (318:5): [True: 20, False: 0]
  |  |  ------------------
  ------------------
 9747|     20|	    tmpOldErrs = ctxt->nberrors;
 9748|     20|	    res = xmlSchemaParseImport(ctxt, schema, child);
 9749|     20|	    HFAILURE;
  ------------------
  |  |  333|     20|#define HFAILURE if (res == -1) goto exit_failure;
  |  |  ------------------
  |  |  |  Branch (333:22): [True: 0, False: 20]
  |  |  ------------------
  ------------------
 9750|     20|	    HSTOP(ctxt);
  ------------------
  |  |  337|     20|#define HSTOP(ctx) if ((ctx)->stop) goto exit;
  |  |  ------------------
  |  |  |  Branch (337:24): [True: 0, False: 20]
  |  |  ------------------
  ------------------
 9751|     20|	    if (tmpOldErrs != ctxt->nberrors)
  ------------------
  |  Branch (9751:10): [True: 3, False: 17]
  ------------------
 9752|      3|		goto exit;
 9753|     29|	} else if (IS_SCHEMA(child, "include")) {
  ------------------
  |  |  316|     29|   ((node != NULL) && (node->ns != NULL) && \
  |  |  ------------------
  |  |  |  Branch (316:5): [True: 29, False: 0]
  |  |  |  Branch (316:23): [True: 29, False: 0]
  |  |  ------------------
  |  |  317|     29|    (xmlStrEqual(node->name, (const xmlChar *) type)) && \
  |  |  ------------------
  |  |  |  Branch (317:5): [True: 29, False: 0]
  |  |  ------------------
  |  |  318|     29|    (xmlStrEqual(node->ns->href, xmlSchemaNs)))
  |  |  ------------------
  |  |  |  Branch (318:5): [True: 29, False: 0]
  |  |  ------------------
  ------------------
 9754|     29|	    tmpOldErrs = ctxt->nberrors;
 9755|     29|	    res = xmlSchemaParseInclude(ctxt, schema, child);
 9756|     29|	    HFAILURE;
  ------------------
  |  |  333|     29|#define HFAILURE if (res == -1) goto exit_failure;
  |  |  ------------------
  |  |  |  Branch (333:22): [True: 0, False: 29]
  |  |  ------------------
  ------------------
 9757|     29|	    HSTOP(ctxt);
  ------------------
  |  |  337|     29|#define HSTOP(ctx) if ((ctx)->stop) goto exit;
  |  |  ------------------
  |  |  |  Branch (337:24): [True: 0, False: 29]
  |  |  ------------------
  ------------------
 9758|     29|	    if (tmpOldErrs != ctxt->nberrors)
  ------------------
  |  Branch (9758:10): [True: 11, False: 18]
  ------------------
 9759|     11|		goto exit;
 9760|     29|	} else if (IS_SCHEMA(child, "redefine")) {
  ------------------
  |  |  316|      0|   ((node != NULL) && (node->ns != NULL) && \
  |  |  ------------------
  |  |  |  Branch (316:5): [True: 0, False: 0]
  |  |  |  Branch (316:23): [True: 0, False: 0]
  |  |  ------------------
  |  |  317|      0|    (xmlStrEqual(node->name, (const xmlChar *) type)) && \
  |  |  ------------------
  |  |  |  Branch (317:5): [True: 0, False: 0]
  |  |  ------------------
  |  |  318|      0|    (xmlStrEqual(node->ns->href, xmlSchemaNs)))
  |  |  ------------------
  |  |  |  Branch (318:5): [True: 0, False: 0]
  |  |  ------------------
  ------------------
 9761|      0|	    tmpOldErrs = ctxt->nberrors;
 9762|      0|	    res = xmlSchemaParseRedefine(ctxt, schema, child);
 9763|      0|	    HFAILURE;
  ------------------
  |  |  333|      0|#define HFAILURE if (res == -1) goto exit_failure;
  |  |  ------------------
  |  |  |  Branch (333:22): [True: 0, False: 0]
  |  |  ------------------
  ------------------
 9764|      0|	    HSTOP(ctxt);
  ------------------
  |  |  337|      0|#define HSTOP(ctx) if ((ctx)->stop) goto exit;
  |  |  ------------------
  |  |  |  Branch (337:24): [True: 0, False: 0]
  |  |  ------------------
  ------------------
 9765|      0|	    if (tmpOldErrs != ctxt->nberrors)
  ------------------
  |  Branch (9765:10): [True: 0, False: 0]
  ------------------
 9766|      0|		goto exit;
 9767|      0|	}
 9768|     53|	child = child->next;
 9769|     53|    }
 9770|       |    /*
 9771|       |    * URGENT TODO: Change the functions to return int results.
 9772|       |    * We need especially to catch internal errors.
 9773|       |    */
 9774|    829|    while (child != NULL) {
  ------------------
  |  Branch (9774:12): [True: 651, False: 178]
  ------------------
 9775|    651|	if (IS_SCHEMA(child, "complexType")) {
  ------------------
  |  |  316|    651|   ((node != NULL) && (node->ns != NULL) && \
  |  |  ------------------
  |  |  |  Branch (316:5): [True: 651, False: 0]
  |  |  |  Branch (316:23): [True: 651, False: 0]
  |  |  ------------------
  |  |  317|    651|    (xmlStrEqual(node->name, (const xmlChar *) type)) && \
  |  |  ------------------
  |  |  |  Branch (317:5): [True: 182, False: 469]
  |  |  ------------------
  |  |  318|    651|    (xmlStrEqual(node->ns->href, xmlSchemaNs)))
  |  |  ------------------
  |  |  |  Branch (318:5): [True: 182, False: 0]
  |  |  ------------------
  ------------------
 9776|    182|	    xmlSchemaParseComplexType(ctxt, schema, child, 1);
 9777|    182|	    child = child->next;
 9778|    469|	} else if (IS_SCHEMA(child, "simpleType")) {
  ------------------
  |  |  316|    469|   ((node != NULL) && (node->ns != NULL) && \
  |  |  ------------------
  |  |  |  Branch (316:5): [True: 469, False: 0]
  |  |  |  Branch (316:23): [True: 469, False: 0]
  |  |  ------------------
  |  |  317|    469|    (xmlStrEqual(node->name, (const xmlChar *) type)) && \
  |  |  ------------------
  |  |  |  Branch (317:5): [True: 69, False: 400]
  |  |  ------------------
  |  |  318|    469|    (xmlStrEqual(node->ns->href, xmlSchemaNs)))
  |  |  ------------------
  |  |  |  Branch (318:5): [True: 69, False: 0]
  |  |  ------------------
  ------------------
 9779|     69|	    xmlSchemaParseSimpleType(ctxt, schema, child, 1);
 9780|     69|	    child = child->next;
 9781|    400|	} else if (IS_SCHEMA(child, "element")) {
  ------------------
  |  |  316|    400|   ((node != NULL) && (node->ns != NULL) && \
  |  |  ------------------
  |  |  |  Branch (316:5): [True: 400, False: 0]
  |  |  |  Branch (316:23): [True: 400, False: 0]
  |  |  ------------------
  |  |  317|    400|    (xmlStrEqual(node->name, (const xmlChar *) type)) && \
  |  |  ------------------
  |  |  |  Branch (317:5): [True: 315, False: 85]
  |  |  ------------------
  |  |  318|    400|    (xmlStrEqual(node->ns->href, xmlSchemaNs)))
  |  |  ------------------
  |  |  |  Branch (318:5): [True: 315, False: 0]
  |  |  ------------------
  ------------------
 9782|    315|	    xmlSchemaParseElement(ctxt, schema, child, NULL, 1);
 9783|    315|	    child = child->next;
 9784|    315|	} else if (IS_SCHEMA(child, "attribute")) {
  ------------------
  |  |  316|     85|   ((node != NULL) && (node->ns != NULL) && \
  |  |  ------------------
  |  |  |  Branch (316:5): [True: 85, False: 0]
  |  |  |  Branch (316:23): [True: 85, False: 0]
  |  |  ------------------
  |  |  317|     85|    (xmlStrEqual(node->name, (const xmlChar *) type)) && \
  |  |  ------------------
  |  |  |  Branch (317:5): [True: 36, False: 49]
  |  |  ------------------
  |  |  318|     85|    (xmlStrEqual(node->ns->href, xmlSchemaNs)))
  |  |  ------------------
  |  |  |  Branch (318:5): [True: 36, False: 0]
  |  |  ------------------
  ------------------
 9785|     36|	    xmlSchemaParseGlobalAttribute(ctxt, schema, child);
 9786|     36|	    child = child->next;
 9787|     49|	} else if (IS_SCHEMA(child, "attributeGroup")) {
  ------------------
  |  |  316|     49|   ((node != NULL) && (node->ns != NULL) && \
  |  |  ------------------
  |  |  |  Branch (316:5): [True: 49, False: 0]
  |  |  |  Branch (316:23): [True: 49, False: 0]
  |  |  ------------------
  |  |  317|     49|    (xmlStrEqual(node->name, (const xmlChar *) type)) && \
  |  |  ------------------
  |  |  |  Branch (317:5): [True: 40, False: 9]
  |  |  ------------------
  |  |  318|     49|    (xmlStrEqual(node->ns->href, xmlSchemaNs)))
  |  |  ------------------
  |  |  |  Branch (318:5): [True: 40, False: 0]
  |  |  ------------------
  ------------------
 9788|     40|	    xmlSchemaParseAttributeGroupDefinition(ctxt, schema, child);
 9789|     40|	    child = child->next;
 9790|     40|	} else if (IS_SCHEMA(child, "group")) {
  ------------------
  |  |  316|      9|   ((node != NULL) && (node->ns != NULL) && \
  |  |  ------------------
  |  |  |  Branch (316:5): [True: 9, False: 0]
  |  |  |  Branch (316:23): [True: 9, False: 0]
  |  |  ------------------
  |  |  317|      9|    (xmlStrEqual(node->name, (const xmlChar *) type)) && \
  |  |  ------------------
  |  |  |  Branch (317:5): [True: 9, False: 0]
  |  |  ------------------
  |  |  318|      9|    (xmlStrEqual(node->ns->href, xmlSchemaNs)))
  |  |  ------------------
  |  |  |  Branch (318:5): [True: 9, False: 0]
  |  |  ------------------
  ------------------
 9791|      9|	    xmlSchemaParseModelGroupDefinition(ctxt, schema, child);
 9792|      9|	    child = child->next;
 9793|      9|	} else if (IS_SCHEMA(child, "notation")) {
  ------------------
  |  |  316|      0|   ((node != NULL) && (node->ns != NULL) && \
  |  |  ------------------
  |  |  |  Branch (316:5): [True: 0, False: 0]
  |  |  |  Branch (316:23): [True: 0, False: 0]
  |  |  ------------------
  |  |  317|      0|    (xmlStrEqual(node->name, (const xmlChar *) type)) && \
  |  |  ------------------
  |  |  |  Branch (317:5): [True: 0, False: 0]
  |  |  ------------------
  |  |  318|      0|    (xmlStrEqual(node->ns->href, xmlSchemaNs)))
  |  |  ------------------
  |  |  |  Branch (318:5): [True: 0, False: 0]
  |  |  ------------------
  ------------------
 9794|      0|	    xmlSchemaParseNotation(ctxt, schema, child);
 9795|      0|	    child = child->next;
 9796|      0|	} else {
 9797|      0|	    xmlSchemaPContentErr(ctxt,
 9798|      0|		XML_SCHEMAP_S4S_ELEM_NOT_ALLOWED,
 9799|      0|		NULL, child->parent, child,
 9800|      0|		NULL, "((include | import | redefine | annotation)*, "
 9801|      0|		"(((simpleType | complexType | group | attributeGroup) "
 9802|      0|		"| element | attribute | notation), annotation*)*)");
 9803|      0|	    child = child->next;
 9804|      0|	}
 9805|    651|	while (IS_SCHEMA(child, "annotation")) {
  ------------------
  |  |  316|    651|   ((node != NULL) && (node->ns != NULL) && \
  |  |  ------------------
  |  |  |  Branch (316:5): [True: 481, False: 170]
  |  |  |  Branch (316:23): [True: 481, False: 0]
  |  |  ------------------
  |  |  317|    651|    (xmlStrEqual(node->name, (const xmlChar *) type)) && \
  |  |  ------------------
  |  |  |  Branch (317:5): [True: 0, False: 481]
  |  |  ------------------
  |  |  318|    651|    (xmlStrEqual(node->ns->href, xmlSchemaNs)))
  |  |  ------------------
  |  |  |  Branch (318:5): [True: 0, False: 0]
  |  |  ------------------
  ------------------
 9806|       |	    /*
 9807|       |	    * TODO: We should add all annotations.
 9808|       |	    */
 9809|      0|	    annot = xmlSchemaParseAnnotation(ctxt, child, 1);
 9810|      0|	    if (schema->annot == NULL)
  ------------------
  |  Branch (9810:10): [True: 0, False: 0]
  ------------------
 9811|      0|		schema->annot = annot;
 9812|      0|	    else
 9813|      0|		xmlSchemaFreeAnnot(annot);
 9814|      0|	    child = child->next;
 9815|      0|	}
 9816|    651|    }
 9817|    192|exit:
 9818|    192|    ctxt->ctxtType = NULL;
 9819|    192|    if (oldErrs != ctxt->nberrors)
  ------------------
  |  Branch (9819:9): [True: 32, False: 160]
  ------------------
 9820|     32|	res = ctxt->err;
 9821|    192|    return(res);
 9822|      0|exit_failure:
 9823|      0|    return(-1);
 9824|    178|}
xmlschemas.c:xmlSchemaParseAnnotation:
 6480|     88|{
 6481|     88|    xmlSchemaAnnotPtr ret;
 6482|     88|    xmlNodePtr child = NULL;
 6483|     88|    xmlAttrPtr attr;
 6484|     88|    int barked = 0;
 6485|       |
 6486|       |    /*
 6487|       |    * INFO: S4S completed.
 6488|       |    */
 6489|       |    /*
 6490|       |    * id = ID
 6491|       |    * {any attributes with non-schema namespace . . .}>
 6492|       |    * Content: (appinfo | documentation)*
 6493|       |    */
 6494|     88|    if ((ctxt == NULL) || (node == NULL))
  ------------------
  |  Branch (6494:9): [True: 0, False: 88]
  |  Branch (6494:27): [True: 0, False: 88]
  ------------------
 6495|      0|        return (NULL);
 6496|     88|    if (needed)
  ------------------
  |  Branch (6496:9): [True: 88, False: 0]
  ------------------
 6497|     88|	ret = xmlSchemaNewAnnot(ctxt, node);
 6498|      0|    else
 6499|      0|	ret = NULL;
 6500|     88|    attr = node->properties;
 6501|     91|    while (attr != NULL) {
  ------------------
  |  Branch (6501:12): [True: 3, False: 88]
  ------------------
 6502|      3|	if (((attr->ns == NULL) &&
  ------------------
  |  Branch (6502:7): [True: 2, False: 1]
  ------------------
 6503|      3|	    (!xmlStrEqual(attr->name, BAD_CAST "id"))) ||
  ------------------
  |  |   35|      2|#define BAD_CAST (xmlChar *)
  ------------------
  |  Branch (6503:6): [True: 1, False: 1]
  ------------------
 6504|      3|	    ((attr->ns != NULL) &&
  ------------------
  |  Branch (6504:7): [True: 1, False: 1]
  ------------------
 6505|      2|	    xmlStrEqual(attr->ns->href, xmlSchemaNs))) {
  ------------------
  |  Branch (6505:6): [True: 0, False: 1]
  ------------------
 6506|       |
 6507|      1|	    xmlSchemaPIllegalAttrErr(ctxt,
 6508|      1|		XML_SCHEMAP_S4S_ATTR_NOT_ALLOWED, NULL, attr);
 6509|      1|	}
 6510|      3|	attr = attr->next;
 6511|      3|    }
 6512|     88|    xmlSchemaPValAttrID(ctxt, node, BAD_CAST "id");
  ------------------
  |  |   35|     88|#define BAD_CAST (xmlChar *)
  ------------------
 6513|       |    /*
 6514|       |    * And now for the children...
 6515|       |    */
 6516|     88|    child = node->children;
 6517|    180|    while (child != NULL) {
  ------------------
  |  Branch (6517:12): [True: 92, False: 88]
  ------------------
 6518|     92|	if (IS_SCHEMA(child, "appinfo")) {
  ------------------
  |  |  316|     92|   ((node != NULL) && (node->ns != NULL) && \
  |  |  ------------------
  |  |  |  Branch (316:5): [True: 92, False: 0]
  |  |  |  Branch (316:23): [True: 90, False: 2]
  |  |  ------------------
  |  |  317|     92|    (xmlStrEqual(node->name, (const xmlChar *) type)) && \
  |  |  ------------------
  |  |  |  Branch (317:5): [True: 3, False: 87]
  |  |  ------------------
  |  |  318|     92|    (xmlStrEqual(node->ns->href, xmlSchemaNs)))
  |  |  ------------------
  |  |  |  Branch (318:5): [True: 3, False: 0]
  |  |  ------------------
  ------------------
 6519|       |	    /* TODO: make available the content of "appinfo". */
 6520|       |	    /*
 6521|       |	    * source = anyURI
 6522|       |	    * {any attributes with non-schema namespace . . .}>
 6523|       |	    * Content: ({any})*
 6524|       |	    */
 6525|      3|	    attr = child->properties;
 6526|      7|	    while (attr != NULL) {
  ------------------
  |  Branch (6526:13): [True: 4, False: 3]
  ------------------
 6527|      4|		if (((attr->ns == NULL) &&
  ------------------
  |  Branch (6527:8): [True: 3, False: 1]
  ------------------
 6528|      4|		     (!xmlStrEqual(attr->name, BAD_CAST "source"))) ||
  ------------------
  |  |   35|      3|#define BAD_CAST (xmlChar *)
  ------------------
  |  Branch (6528:8): [True: 2, False: 1]
  ------------------
 6529|      4|		     ((attr->ns != NULL) &&
  ------------------
  |  Branch (6529:9): [True: 1, False: 1]
  ------------------
 6530|      2|		      xmlStrEqual(attr->ns->href, xmlSchemaNs))) {
  ------------------
  |  Branch (6530:9): [True: 0, False: 1]
  ------------------
 6531|       |
 6532|      2|		    xmlSchemaPIllegalAttrErr(ctxt,
 6533|      2|			XML_SCHEMAP_S4S_ATTR_NOT_ALLOWED, NULL, attr);
 6534|      2|		}
 6535|      4|		attr = attr->next;
 6536|      4|	    }
 6537|      3|	    xmlSchemaPValAttr(ctxt, NULL, child, "source",
 6538|      3|		xmlSchemaGetBuiltInType(XML_SCHEMAS_ANYURI), NULL);
 6539|      3|	    child = child->next;
 6540|     89|	} else if (IS_SCHEMA(child, "documentation")) {
  ------------------
  |  |  316|     89|   ((node != NULL) && (node->ns != NULL) && \
  |  |  ------------------
  |  |  |  Branch (316:5): [True: 89, False: 0]
  |  |  |  Branch (316:23): [True: 87, False: 2]
  |  |  ------------------
  |  |  317|     89|    (xmlStrEqual(node->name, (const xmlChar *) type)) && \
  |  |  ------------------
  |  |  |  Branch (317:5): [True: 87, False: 0]
  |  |  ------------------
  |  |  318|     89|    (xmlStrEqual(node->ns->href, xmlSchemaNs)))
  |  |  ------------------
  |  |  |  Branch (318:5): [True: 87, False: 0]
  |  |  ------------------
  ------------------
 6541|       |	    /* TODO: make available the content of "documentation". */
 6542|       |	    /*
 6543|       |	    * source = anyURI
 6544|       |	    * {any attributes with non-schema namespace . . .}>
 6545|       |	    * Content: ({any})*
 6546|       |	    */
 6547|     87|	    attr = child->properties;
 6548|    101|	    while (attr != NULL) {
  ------------------
  |  Branch (6548:13): [True: 14, False: 87]
  ------------------
 6549|     14|		if (attr->ns == NULL) {
  ------------------
  |  Branch (6549:7): [True: 3, False: 11]
  ------------------
 6550|      3|		    if (!xmlStrEqual(attr->name, BAD_CAST "source")) {
  ------------------
  |  |   35|      3|#define BAD_CAST (xmlChar *)
  ------------------
  |  Branch (6550:11): [True: 2, False: 1]
  ------------------
 6551|      2|			xmlSchemaPIllegalAttrErr(ctxt,
 6552|      2|			    XML_SCHEMAP_S4S_ATTR_NOT_ALLOWED, NULL, attr);
 6553|      2|		    }
 6554|     11|		} else {
 6555|     11|		    if (xmlStrEqual(attr->ns->href, xmlSchemaNs) ||
  ------------------
  |  Branch (6555:11): [True: 0, False: 11]
  ------------------
 6556|     11|			(xmlStrEqual(attr->name, BAD_CAST "lang") &&
  ------------------
  |  |   35|     11|#define BAD_CAST (xmlChar *)
  ------------------
  |  Branch (6556:5): [True: 10, False: 1]
  ------------------
 6557|     11|			(!xmlStrEqual(attr->ns->href, XML_XML_NAMESPACE)))) {
  ------------------
  |  |  143|     10|    (const xmlChar *) "http://www.w3.org/XML/1998/namespace"
  ------------------
  |  Branch (6557:4): [True: 0, False: 10]
  ------------------
 6558|       |
 6559|      0|			xmlSchemaPIllegalAttrErr(ctxt,
 6560|      0|			    XML_SCHEMAP_S4S_ATTR_NOT_ALLOWED, NULL, attr);
 6561|      0|		    }
 6562|     11|		}
 6563|     14|		attr = attr->next;
 6564|     14|	    }
 6565|       |	    /*
 6566|       |	    * Attribute "xml:lang".
 6567|       |	    */
 6568|     87|	    attr = xmlSchemaGetPropNodeNs(child, (const char *) XML_XML_NAMESPACE, "lang");
  ------------------
  |  |  143|     87|    (const xmlChar *) "http://www.w3.org/XML/1998/namespace"
  ------------------
 6569|     87|	    if (attr != NULL)
  ------------------
  |  Branch (6569:10): [True: 10, False: 77]
  ------------------
 6570|     10|		xmlSchemaPValAttrNode(ctxt, NULL, attr,
 6571|     10|		xmlSchemaGetBuiltInType(XML_SCHEMAS_LANGUAGE), NULL);
 6572|     87|	    child = child->next;
 6573|     87|	} else {
 6574|      2|	    if (!barked)
  ------------------
  |  Branch (6574:10): [True: 1, False: 1]
  ------------------
 6575|      1|		xmlSchemaPContentErr(ctxt,
 6576|      1|		    XML_SCHEMAP_S4S_ELEM_NOT_ALLOWED,
 6577|      1|		    NULL, node, child, NULL, "(appinfo | documentation)*");
 6578|      2|	    barked = 1;
 6579|      2|	    child = child->next;
 6580|      2|	}
 6581|     92|    }
 6582|       |
 6583|     88|    return (ret);
 6584|     88|}
xmlschemas.c:xmlSchemaNewAnnot:
 3367|     88|{
 3368|     88|    xmlSchemaAnnotPtr ret;
 3369|       |
 3370|     88|    ret = (xmlSchemaAnnotPtr) xmlMalloc(sizeof(xmlSchemaAnnot));
 3371|     88|    if (ret == NULL) {
  ------------------
  |  Branch (3371:9): [True: 0, False: 88]
  ------------------
 3372|      0|        xmlSchemaPErrMemory(ctxt, "allocating annotation", node);
 3373|      0|        return (NULL);
 3374|      0|    }
 3375|     88|    memset(ret, 0, sizeof(xmlSchemaAnnot));
 3376|     88|    ret->content = node;
 3377|     88|    return (ret);
 3378|     88|}
xmlschemas.c:xmlSchemaPIllegalAttrErr:
 2957|     15|{
 2958|     15|    xmlChar *strA = NULL, *strB = NULL;
 2959|       |
 2960|     15|    xmlSchemaFormatNodeForError(&strA, ACTXT_CAST ctxt, attr->parent);
  ------------------
  |  |  121|     15|#define ACTXT_CAST (xmlSchemaAbstractCtxtPtr)
  ------------------
 2961|     15|    xmlSchemaErr4(ACTXT_CAST ctxt, error, (xmlNodePtr) attr,
  ------------------
  |  |  121|     15|#define ACTXT_CAST (xmlSchemaAbstractCtxtPtr)
  ------------------
 2962|     15|	"%sThe attribute '%s' is not allowed.\n", BAD_CAST strA,
  ------------------
  |  |   35|     15|#define BAD_CAST (xmlChar *)
  ------------------
 2963|     15|	xmlSchemaFormatQNameNs(&strB, attr->ns, attr->name),
 2964|     15|	NULL, NULL);
 2965|     15|    FREE_AND_NULL(strA);
  ------------------
  |  |  320|     15|#define FREE_AND_NULL(str) if ((str) != NULL) { xmlFree((xmlChar *) (str)); str = NULL; }
  |  |  ------------------
  |  |  |  Branch (320:32): [True: 15, False: 0]
  |  |  ------------------
  ------------------
 2966|     15|    FREE_AND_NULL(strB);
  ------------------
  |  |  320|     15|#define FREE_AND_NULL(str) if ((str) != NULL) { xmlFree((xmlChar *) (str)); str = NULL; }
  |  |  ------------------
  |  |  |  Branch (320:32): [True: 0, False: 15]
  |  |  ------------------
  ------------------
 2967|     15|}
xmlschemas.c:xmlSchemaFormatQNameNs:
 1328|     15|{
 1329|     15|    if (ns != NULL)
  ------------------
  |  Branch (1329:9): [True: 0, False: 15]
  ------------------
 1330|      0|	return (xmlSchemaFormatQName(buf, ns->href, localName));
 1331|     15|    else
 1332|     15|	return (xmlSchemaFormatQName(buf, NULL, localName));
 1333|     15|}
xmlschemas.c:xmlSchemaPValAttr:
 6348|     43|{
 6349|     43|    xmlAttrPtr attr;
 6350|       |
 6351|     43|    if ((ctxt == NULL) || (type == NULL)) {
  ------------------
  |  Branch (6351:9): [True: 0, False: 43]
  |  Branch (6351:27): [True: 0, False: 43]
  ------------------
 6352|      0|	if (value != NULL)
  ------------------
  |  Branch (6352:6): [True: 0, False: 0]
  ------------------
 6353|      0|	    *value = NULL;
 6354|      0|	return (-1);
 6355|      0|    }
 6356|     43|    if (type->type != XML_SCHEMA_TYPE_BASIC) {
  ------------------
  |  Branch (6356:9): [True: 0, False: 43]
  ------------------
 6357|      0|	if (value != NULL)
  ------------------
  |  Branch (6357:6): [True: 0, False: 0]
  ------------------
 6358|      0|	    *value = NULL;
 6359|      0|	xmlSchemaPErr(ctxt, ownerElem,
 6360|      0|	    XML_SCHEMAP_INTERNAL,
 6361|      0|	    "Internal error: xmlSchemaPValAttr, the given "
 6362|      0|	    "type '%s' is not a built-in type.\n",
 6363|      0|	    type->name, NULL);
 6364|      0|	return (-1);
 6365|      0|    }
 6366|     43|    attr = xmlSchemaGetPropNode(ownerElem, name);
 6367|     43|    if (attr == NULL) {
  ------------------
  |  Branch (6367:9): [True: 7, False: 36]
  ------------------
 6368|      7|	if (value != NULL)
  ------------------
  |  Branch (6368:6): [True: 5, False: 2]
  ------------------
 6369|      5|	    *value = NULL;
 6370|      7|	return (0);
 6371|      7|    }
 6372|     36|    return (xmlSchemaPValAttrNode(ctxt, ownerItem, attr,
 6373|     36|	type, value));
 6374|     43|}
xmlschemas.c:xmlSchemaGetPropNodeNs:
 4650|     87|{
 4651|     87|    xmlAttrPtr prop;
 4652|       |
 4653|     87|    if ((node == NULL) || (name == NULL))
  ------------------
  |  Branch (4653:9): [True: 0, False: 87]
  |  Branch (4653:27): [True: 0, False: 87]
  ------------------
 4654|      0|	return(NULL);
 4655|     87|    prop = node->properties;
 4656|     87|    while (prop != NULL) {
  ------------------
  |  Branch (4656:12): [True: 10, False: 77]
  ------------------
 4657|     10|	if ((prop->ns != NULL) &&
  ------------------
  |  Branch (4657:6): [True: 10, False: 0]
  ------------------
 4658|     10|	    xmlStrEqual(prop->name, BAD_CAST name) &&
  ------------------
  |  |   35|     10|#define BAD_CAST (xmlChar *)
  ------------------
  |  Branch (4658:6): [True: 10, False: 0]
  ------------------
 4659|     10|	    xmlStrEqual(prop->ns->href, BAD_CAST uri))
  ------------------
  |  |   35|     10|#define BAD_CAST (xmlChar *)
  ------------------
  |  Branch (4659:6): [True: 10, False: 0]
  ------------------
 4660|     10|	    return(prop);
 4661|      0|	prop = prop->next;
 4662|      0|    }
 4663|     77|    return (NULL);
 4664|     87|}
xmlschemas.c:xmlSchemaParseImport:
10685|     20|{
10686|     20|    xmlNodePtr child;
10687|     20|    const xmlChar *namespaceName = NULL, *schemaLocation = NULL;
10688|     20|    const xmlChar *thisTargetNamespace;
10689|     20|    xmlAttrPtr attr;
10690|     20|    int ret = 0;
10691|     20|    xmlSchemaBucketPtr bucket = NULL;
10692|       |
10693|     20|    if ((pctxt == NULL) || (schema == NULL) || (node == NULL))
  ------------------
  |  Branch (10693:9): [True: 0, False: 20]
  |  Branch (10693:28): [True: 0, False: 20]
  |  Branch (10693:48): [True: 0, False: 20]
  ------------------
10694|      0|        return (-1);
10695|       |
10696|       |    /*
10697|       |    * Check for illegal attributes.
10698|       |    */
10699|     20|    attr = node->properties;
10700|     55|    while (attr != NULL) {
  ------------------
  |  Branch (10700:12): [True: 35, False: 20]
  ------------------
10701|     35|	if (attr->ns == NULL) {
  ------------------
  |  Branch (10701:6): [True: 35, False: 0]
  ------------------
10702|     35|	    if ((!xmlStrEqual(attr->name, BAD_CAST "id")) &&
  ------------------
  |  |   35|     35|#define BAD_CAST (xmlChar *)
  ------------------
  |  Branch (10702:10): [True: 35, False: 0]
  ------------------
10703|     35|		(!xmlStrEqual(attr->name, BAD_CAST "namespace")) &&
  ------------------
  |  |   35|     35|#define BAD_CAST (xmlChar *)
  ------------------
  |  Branch (10703:3): [True: 18, False: 17]
  ------------------
10704|     35|		(!xmlStrEqual(attr->name, BAD_CAST "schemaLocation"))) {
  ------------------
  |  |   35|     18|#define BAD_CAST (xmlChar *)
  ------------------
  |  Branch (10704:3): [True: 0, False: 18]
  ------------------
10705|      0|		xmlSchemaPIllegalAttrErr(pctxt,
10706|      0|		    XML_SCHEMAP_S4S_ATTR_NOT_ALLOWED, NULL, attr);
10707|      0|	    }
10708|     35|	} else if (xmlStrEqual(attr->ns->href, xmlSchemaNs)) {
  ------------------
  |  Branch (10708:13): [True: 0, False: 0]
  ------------------
10709|      0|	    xmlSchemaPIllegalAttrErr(pctxt,
10710|      0|		XML_SCHEMAP_S4S_ATTR_NOT_ALLOWED, NULL, attr);
10711|      0|	}
10712|     35|	attr = attr->next;
10713|     35|    }
10714|       |    /*
10715|       |    * Extract and validate attributes.
10716|       |    */
10717|     20|    if (xmlSchemaPValAttr(pctxt, NULL, node,
  ------------------
  |  Branch (10717:9): [True: 0, False: 20]
  ------------------
10718|     20|	"namespace", xmlSchemaGetBuiltInType(XML_SCHEMAS_ANYURI),
10719|     20|	&namespaceName) != 0) {
10720|      0|	xmlSchemaPSimpleTypeErr(pctxt,
10721|      0|	    XML_SCHEMAP_S4S_ATTR_INVALID_VALUE,
10722|      0|	    NULL, node,
10723|      0|	    xmlSchemaGetBuiltInType(XML_SCHEMAS_ANYURI),
10724|      0|	    NULL, namespaceName, NULL, NULL, NULL);
10725|      0|	return (pctxt->err);
10726|      0|    }
10727|       |
10728|     20|    if (xmlSchemaPValAttr(pctxt, NULL, node,
  ------------------
  |  Branch (10728:9): [True: 0, False: 20]
  ------------------
10729|     20|	"schemaLocation", xmlSchemaGetBuiltInType(XML_SCHEMAS_ANYURI),
10730|     20|	&schemaLocation) != 0) {
10731|      0|	xmlSchemaPSimpleTypeErr(pctxt,
10732|      0|	    XML_SCHEMAP_S4S_ATTR_INVALID_VALUE,
10733|      0|	    NULL, node,
10734|      0|	    xmlSchemaGetBuiltInType(XML_SCHEMAS_ANYURI),
10735|      0|	    NULL, schemaLocation, NULL, NULL, NULL);
10736|      0|	return (pctxt->err);
10737|      0|    }
10738|       |    /*
10739|       |    * And now for the children...
10740|       |    */
10741|     20|    child = node->children;
10742|     20|    if (IS_SCHEMA(child, "annotation")) {
  ------------------
  |  |  316|     20|   ((node != NULL) && (node->ns != NULL) && \
  |  |  ------------------
  |  |  |  Branch (316:5): [True: 0, False: 20]
  |  |  |  Branch (316:23): [True: 0, False: 0]
  |  |  ------------------
  |  |  317|     20|    (xmlStrEqual(node->name, (const xmlChar *) type)) && \
  |  |  ------------------
  |  |  |  Branch (317:5): [True: 0, False: 0]
  |  |  ------------------
  |  |  318|     20|    (xmlStrEqual(node->ns->href, xmlSchemaNs)))
  |  |  ------------------
  |  |  |  Branch (318:5): [True: 0, False: 0]
  |  |  ------------------
  ------------------
10743|       |        /*
10744|       |         * the annotation here is simply discarded ...
10745|       |	 * TODO: really?
10746|       |         */
10747|      0|        child = child->next;
10748|      0|    }
10749|     20|    if (child != NULL) {
  ------------------
  |  Branch (10749:9): [True: 0, False: 20]
  ------------------
10750|      0|	xmlSchemaPContentErr(pctxt,
10751|      0|	    XML_SCHEMAP_S4S_ELEM_NOT_ALLOWED,
10752|      0|	    NULL, node, child, NULL,
10753|      0|	    "(annotation?)");
10754|      0|    }
10755|       |    /*
10756|       |    * Apply additional constraints.
10757|       |    *
10758|       |    * Note that it is important to use the original @targetNamespace
10759|       |    * (or none at all), to rule out imports of schemas _with_ a
10760|       |    * @targetNamespace if the importing schema is a chameleon schema
10761|       |    * (with no @targetNamespace).
10762|       |    */
10763|     20|    thisTargetNamespace = WXS_BUCKET(pctxt)->origTargetNamespace;
  ------------------
  |  |  286|     20|#define WXS_BUCKET(ctx) WXS_CONSTRUCTOR((ctx))->bucket
  |  |  ------------------
  |  |  |  |  278|     20|#define WXS_CONSTRUCTOR(ctx) (ctx)->constructor
  |  |  ------------------
  ------------------
10764|     20|    if (namespaceName != NULL) {
  ------------------
  |  Branch (10764:9): [True: 17, False: 3]
  ------------------
10765|       |	/*
10766|       |	* 1.1 If the namespace [attribute] is present, then its `actual value`
10767|       |	* must not match the `actual value` of the enclosing <schema>'s
10768|       |	* targetNamespace [attribute].
10769|       |	*/
10770|     17|	if (xmlStrEqual(thisTargetNamespace, namespaceName)) {
  ------------------
  |  Branch (10770:6): [True: 0, False: 17]
  ------------------
10771|      0|	    xmlSchemaPCustomErr(pctxt,
10772|      0|		XML_SCHEMAP_SRC_IMPORT_1_1,
10773|      0|		NULL, node,
10774|      0|		"The value of the attribute 'namespace' must not match "
10775|      0|		"the target namespace '%s' of the importing schema",
10776|      0|		thisTargetNamespace);
10777|      0|	    return (pctxt->err);
10778|      0|	}
10779|     17|    } else {
10780|       |	/*
10781|       |	* 1.2 If the namespace [attribute] is not present, then the enclosing
10782|       |	* <schema> must have a targetNamespace [attribute].
10783|       |	*/
10784|      3|	if (thisTargetNamespace == NULL) {
  ------------------
  |  Branch (10784:6): [True: 0, False: 3]
  ------------------
10785|      0|	    xmlSchemaPCustomErr(pctxt,
10786|      0|		XML_SCHEMAP_SRC_IMPORT_1_2,
10787|      0|		NULL, node,
10788|      0|		"The attribute 'namespace' must be existent if "
10789|      0|		"the importing schema has no target namespace",
10790|      0|		NULL);
10791|      0|	    return (pctxt->err);
10792|      0|	}
10793|      3|    }
10794|       |    /*
10795|       |    * Locate and acquire the schema document.
10796|       |    */
10797|     20|    if (schemaLocation != NULL)
  ------------------
  |  Branch (10797:9): [True: 18, False: 2]
  ------------------
10798|     18|	schemaLocation = xmlSchemaBuildAbsoluteURI(pctxt->dict,
10799|     18|	    schemaLocation, node);
10800|     20|    ret = xmlSchemaAddSchemaDoc(pctxt, XML_SCHEMA_SCHEMA_IMPORT,
  ------------------
  |  |  372|     20|#define XML_SCHEMA_SCHEMA_IMPORT 1
  ------------------
10801|     20|	schemaLocation, NULL, NULL, 0, node, thisTargetNamespace,
10802|     20|	namespaceName, &bucket);
10803|       |
10804|     20|    if (ret != 0)
  ------------------
  |  Branch (10804:9): [True: 2, False: 18]
  ------------------
10805|      2|	return(ret);
10806|       |
10807|       |    /*
10808|       |    * For <import>: "It is *not* an error for the application
10809|       |    * schema reference strategy to fail."
10810|       |    * So just don't parse if no schema document was found.
10811|       |    * Note that we will get no bucket if the schema could not be
10812|       |    * located or if there was no schemaLocation.
10813|       |    */
10814|     18|    if ((bucket == NULL) && (schemaLocation != NULL)) {
  ------------------
  |  Branch (10814:9): [True: 2, False: 16]
  |  Branch (10814:29): [True: 0, False: 2]
  ------------------
10815|      0|	xmlSchemaCustomWarning(ACTXT_CAST pctxt,
  ------------------
  |  |  121|      0|#define ACTXT_CAST (xmlSchemaAbstractCtxtPtr)
  ------------------
10816|      0|	    XML_SCHEMAP_WARN_UNLOCATED_SCHEMA,
10817|      0|	    node, NULL,
10818|      0|	    "Failed to locate a schema at location '%s'. "
10819|      0|	    "Skipping the import", schemaLocation, NULL, NULL);
10820|      0|    }
10821|       |
10822|     18|    if ((bucket != NULL) && CAN_PARSE_SCHEMA(bucket)) {
  ------------------
  |  |  331|     16|#define CAN_PARSE_SCHEMA(b) (((b)->doc != NULL) && ((b)->parsed == 0))
  |  |  ------------------
  |  |  |  Branch (331:30): [True: 16, False: 0]
  |  |  |  Branch (331:52): [True: 16, False: 0]
  |  |  ------------------
  ------------------
  |  Branch (10822:9): [True: 16, False: 2]
  ------------------
10823|     16|	ret = xmlSchemaParseNewDoc(pctxt, schema, bucket);
10824|     16|    }
10825|       |
10826|     18|    return (ret);
10827|     20|}
xmlschemas.c:xmlSchemaPCustomErr:
 3026|      3|{
 3027|      3|    xmlSchemaPCustomErrExt(ctxt, error, item, itemElem, message,
 3028|      3|	str1, NULL, NULL);
 3029|      3|}
xmlschemas.c:xmlSchemaPCustomErrExt:
 2992|      8|{
 2993|      8|    xmlChar *des = NULL, *msg = NULL;
 2994|       |
 2995|      8|    xmlSchemaFormatItemForReport(&des, NULL, item, itemElem);
 2996|      8|    msg = xmlStrdup(BAD_CAST "%s: ");
  ------------------
  |  |   35|      8|#define BAD_CAST (xmlChar *)
  ------------------
 2997|      8|    msg = xmlStrcat(msg, (const xmlChar *) message);
 2998|      8|    msg = xmlStrcat(msg, BAD_CAST ".\n");
  ------------------
  |  |   35|      8|#define BAD_CAST (xmlChar *)
  ------------------
 2999|      8|    if ((itemElem == NULL) && (item != NULL))
  ------------------
  |  Branch (2999:9): [True: 3, False: 5]
  |  Branch (2999:31): [True: 3, False: 0]
  ------------------
 3000|      3|	itemElem = WXS_ITEM_NODE(item);
  ------------------
  |  |  142|      3|#define WXS_ITEM_NODE(i) xmlSchemaGetComponentNode(WXS_BASIC_CAST (i))
  |  |  ------------------
  |  |  |  |  124|      3|#define WXS_BASIC_CAST (xmlSchemaBasicItemPtr)
  |  |  ------------------
  ------------------
 3001|      8|    xmlSchemaPErrExt(ctxt, itemElem, error, NULL, NULL, NULL,
 3002|      8|	(const char *) msg, BAD_CAST des, str1, str2, str3, NULL);
  ------------------
  |  |   35|      8|#define BAD_CAST (xmlChar *)
  ------------------
 3003|      8|    FREE_AND_NULL(des);
  ------------------
  |  |  320|      8|#define FREE_AND_NULL(str) if ((str) != NULL) { xmlFree((xmlChar *) (str)); str = NULL; }
  |  |  ------------------
  |  |  |  Branch (320:32): [True: 8, False: 0]
  |  |  ------------------
  ------------------
 3004|      8|    FREE_AND_NULL(msg);
  ------------------
  |  |  320|      8|#define FREE_AND_NULL(str) if ((str) != NULL) { xmlFree((xmlChar *) (str)); str = NULL; }
  |  |  ------------------
  |  |  |  Branch (320:32): [True: 8, False: 0]
  |  |  ------------------
  ------------------
 3005|      8|}
xmlschemas.c:xmlSchemaBuildAbsoluteURI:
10216|     18|{
10217|       |    /*
10218|       |    * Build an absolute location URI.
10219|       |    */
10220|     18|    if (location != NULL) {
  ------------------
  |  Branch (10220:9): [True: 18, False: 0]
  ------------------
10221|     18|	if (ctxtNode == NULL)
  ------------------
  |  Branch (10221:6): [True: 0, False: 18]
  ------------------
10222|      0|	    return(location);
10223|     18|	else {
10224|     18|	    xmlChar *base, *URI;
10225|     18|	    const xmlChar *ret = NULL;
10226|       |
10227|     18|	    base = xmlNodeGetBase(ctxtNode->doc, ctxtNode);
10228|     18|	    if (base == NULL) {
  ------------------
  |  Branch (10228:10): [True: 0, False: 18]
  ------------------
10229|      0|		URI = xmlBuildURI(location, ctxtNode->doc->URL);
10230|     18|	    } else {
10231|     18|		URI = xmlBuildURI(location, base);
10232|     18|		xmlFree(base);
10233|     18|	    }
10234|     18|	    if (URI != NULL) {
  ------------------
  |  Branch (10234:10): [True: 18, False: 0]
  ------------------
10235|     18|		ret = xmlDictLookup(dict, URI, -1);
10236|     18|		xmlFree(URI);
10237|     18|		return(ret);
10238|     18|	    }
10239|     18|	}
10240|     18|    }
10241|      0|    return(NULL);
10242|     18|}
xmlschemas.c:xmlSchemaParseNewDoc:
10144|     33|{
10145|     33|    xmlSchemaParserCtxtPtr newpctxt;
10146|     33|    int res = 0;
10147|       |
10148|     33|    if (bucket == NULL)
  ------------------
  |  Branch (10148:9): [True: 0, False: 33]
  ------------------
10149|      0|	return(0);
10150|     33|    if (bucket->parsed) {
  ------------------
  |  Branch (10150:9): [True: 0, False: 33]
  ------------------
10151|      0|	PERROR_INT("xmlSchemaParseNewDoc",
  ------------------
  |  | 2824|      0|#define PERROR_INT(func, msg) xmlSchemaInternalErr(ACTXT_CAST pctxt, func, msg);
  |  |  ------------------
  |  |  |  |  121|      0|#define ACTXT_CAST (xmlSchemaAbstractCtxtPtr)
  |  |  ------------------
  ------------------
10152|      0|	    "reparsing a schema doc");
10153|      0|	return(-1);
10154|      0|    }
10155|     33|    if (bucket->doc == NULL) {
  ------------------
  |  Branch (10155:9): [True: 0, False: 33]
  ------------------
10156|      0|	PERROR_INT("xmlSchemaParseNewDoc",
  ------------------
  |  | 2824|      0|#define PERROR_INT(func, msg) xmlSchemaInternalErr(ACTXT_CAST pctxt, func, msg);
  |  |  ------------------
  |  |  |  |  121|      0|#define ACTXT_CAST (xmlSchemaAbstractCtxtPtr)
  |  |  ------------------
  ------------------
10157|      0|	    "parsing a schema doc, but there's no doc");
10158|      0|	return(-1);
10159|      0|    }
10160|     33|    if (pctxt->constructor == NULL) {
  ------------------
  |  Branch (10160:9): [True: 0, False: 33]
  ------------------
10161|      0|	PERROR_INT("xmlSchemaParseNewDoc",
  ------------------
  |  | 2824|      0|#define PERROR_INT(func, msg) xmlSchemaInternalErr(ACTXT_CAST pctxt, func, msg);
  |  |  ------------------
  |  |  |  |  121|      0|#define ACTXT_CAST (xmlSchemaAbstractCtxtPtr)
  |  |  ------------------
  ------------------
10162|      0|	    "no constructor");
10163|      0|	return(-1);
10164|      0|    }
10165|       |    /* Create and init the temporary parser context. */
10166|     33|    newpctxt = xmlSchemaNewParserCtxtUseDict(
10167|     33|	(const char *) bucket->schemaLocation, pctxt->dict);
10168|     33|    if (newpctxt == NULL)
  ------------------
  |  Branch (10168:9): [True: 0, False: 33]
  ------------------
10169|      0|	return(-1);
10170|     33|    newpctxt->constructor = pctxt->constructor;
10171|       |    /*
10172|       |    * TODO: Can we avoid that the parser knows about the main schema?
10173|       |    * It would be better if he knows about the current schema bucket
10174|       |    * only.
10175|       |    */
10176|     33|    newpctxt->schema = schema;
10177|     33|    xmlSchemaSetParserErrors(newpctxt, pctxt->error, pctxt->warning,
10178|     33|	pctxt->errCtxt);
10179|     33|    xmlSchemaSetParserStructuredErrors(newpctxt, pctxt->serror,
10180|     33|	pctxt->errCtxt);
10181|     33|    newpctxt->counter = pctxt->counter;
10182|       |
10183|       |
10184|     33|    res = xmlSchemaParseNewDocWithContext(newpctxt, schema, bucket);
10185|       |
10186|       |    /* Channel back errors and cleanup the temporary parser context. */
10187|     33|    if (res != 0)
  ------------------
  |  Branch (10187:9): [True: 3, False: 30]
  ------------------
10188|      3|	pctxt->err = res;
10189|     33|    pctxt->nberrors += newpctxt->nberrors;
10190|     33|    pctxt->counter = newpctxt->counter;
10191|     33|    newpctxt->constructor = NULL;
10192|       |    /* Free the parser context. */
10193|     33|    xmlSchemaFreeParserCtxt(newpctxt);
10194|     33|    return(res);
10195|     33|}
xmlschemas.c:xmlSchemaNewParserCtxtUseDict:
 9949|     33|{
 9950|     33|    xmlSchemaParserCtxtPtr ret;
 9951|       |
 9952|     33|    ret = xmlSchemaParserCtxtCreate();
 9953|     33|    if (ret == NULL)
  ------------------
  |  Branch (9953:9): [True: 0, False: 33]
  ------------------
 9954|      0|        return (NULL);
 9955|     33|    ret->dict = dict;
 9956|     33|    xmlDictReference(dict);
 9957|     33|    if (URL != NULL)
  ------------------
  |  Branch (9957:9): [True: 33, False: 0]
  ------------------
 9958|     33|	ret->URL = xmlDictLookup(dict, (const xmlChar *) URL, -1);
 9959|     33|    return (ret);
 9960|     33|}
xmlschemas.c:xmlSchemaParseInclude:
11141|     29|{
11142|     29|    int res;
11143|       |
11144|     29|    res = xmlSchemaParseIncludeOrRedefine(pctxt, schema, node,
11145|     29|	XML_SCHEMA_SCHEMA_INCLUDE);
  ------------------
  |  |  373|     29|#define XML_SCHEMA_SCHEMA_INCLUDE 2
  ------------------
11146|     29|    if (res != 0)
  ------------------
  |  Branch (11146:9): [True: 9, False: 20]
  ------------------
11147|      9|	return(res);
11148|     20|    return(0);
11149|     29|}
xmlschemas.c:xmlSchemaParseIncludeOrRedefine:
10930|     29|{
10931|     29|    xmlNodePtr child = NULL;
10932|     29|    const xmlChar *schemaLocation = NULL;
10933|     29|    int res = 0; /* hasRedefinitions = 0 */
10934|     29|    int isChameleon = 0, wasChameleon = 0;
10935|     29|    xmlSchemaBucketPtr bucket = NULL;
10936|       |
10937|     29|    if ((pctxt == NULL) || (schema == NULL) || (node == NULL))
  ------------------
  |  Branch (10937:9): [True: 0, False: 29]
  |  Branch (10937:28): [True: 0, False: 29]
  |  Branch (10937:48): [True: 0, False: 29]
  ------------------
10938|      0|        return (-1);
10939|       |
10940|       |    /*
10941|       |    * Parse attributes. Note that the returned schemaLocation will
10942|       |    * be already converted to an absolute URI.
10943|       |    */
10944|     29|    res = xmlSchemaParseIncludeOrRedefineAttrs(pctxt, schema,
10945|     29|	node, (xmlChar **) (&schemaLocation), type);
10946|     29|    if (res != 0)
  ------------------
  |  Branch (10946:9): [True: 0, False: 29]
  ------------------
10947|      0|	return(res);
10948|       |    /*
10949|       |    * Load and add the schema document.
10950|       |    */
10951|     29|    res = xmlSchemaAddSchemaDoc(pctxt, type, schemaLocation, NULL,
10952|     29|	NULL, 0, node, pctxt->targetNamespace, NULL, &bucket);
10953|     29|    if (res != 0)
  ------------------
  |  Branch (10953:9): [True: 5, False: 24]
  ------------------
10954|      5|	return(res);
10955|       |    /*
10956|       |    * If we get no schema bucket back, then this means that the schema
10957|       |    * document could not be located or was broken XML or was not
10958|       |    * a schema document.
10959|       |    */
10960|     24|    if ((bucket == NULL) || (bucket->doc == NULL)) {
  ------------------
  |  Branch (10960:9): [True: 0, False: 24]
  |  Branch (10960:29): [True: 0, False: 24]
  ------------------
10961|      0|	if (type == XML_SCHEMA_SCHEMA_INCLUDE) {
  ------------------
  |  |  373|      0|#define XML_SCHEMA_SCHEMA_INCLUDE 2
  ------------------
  |  Branch (10961:6): [True: 0, False: 0]
  ------------------
10962|       |	    /*
10963|       |	    * WARNING for <include>:
10964|       |	    * We will raise an error if the schema cannot be located
10965|       |	    * for inclusions, since the that was the feedback from the
10966|       |	    * schema people. I.e. the following spec piece will *not* be
10967|       |	    * satisfied:
10968|       |	    * SPEC src-include: "It is not an error for the `actual value` of the
10969|       |	    * schemaLocation [attribute] to fail to resolve it all, in which
10970|       |	    * case no corresponding inclusion is performed.
10971|       |	    * So do we need a warning report here?"
10972|       |	    */
10973|      0|	    res = XML_SCHEMAP_SRC_INCLUDE;
10974|      0|	    xmlSchemaCustomErr(ACTXT_CAST pctxt, res,
  ------------------
  |  |  121|      0|#define ACTXT_CAST (xmlSchemaAbstractCtxtPtr)
  ------------------
10975|      0|		node, NULL,
10976|      0|		"Failed to load the document '%s' for inclusion",
10977|      0|		schemaLocation, NULL);
10978|      0|	} else {
10979|       |	    /*
10980|       |	    * NOTE: This was changed to raise an error even if no redefinitions
10981|       |	    * are specified.
10982|       |	    *
10983|       |	    * SPEC src-redefine (1)
10984|       |	    * "If there are any element information items among the [children]
10985|       |	    * other than <annotation> then the `actual value` of the
10986|       |	    * schemaLocation [attribute] must successfully resolve."
10987|       |	    * TODO: Ask the WG if a the location has always to resolve
10988|       |	    * here as well!
10989|       |	    */
10990|      0|	    res = XML_SCHEMAP_SRC_REDEFINE;
10991|      0|	    xmlSchemaCustomErr(ACTXT_CAST pctxt, res,
  ------------------
  |  |  121|      0|#define ACTXT_CAST (xmlSchemaAbstractCtxtPtr)
  ------------------
10992|      0|		node, NULL,
10993|      0|		"Failed to load the document '%s' for redefinition",
10994|      0|		schemaLocation, NULL);
10995|      0|	}
10996|     24|    } else {
10997|       |	/*
10998|       |	* Check targetNamespace sanity before parsing the new schema.
10999|       |	* TODO: Note that we won't check further content if the
11000|       |	* targetNamespace was bad.
11001|       |	*/
11002|     24|	if (bucket->origTargetNamespace != NULL) {
  ------------------
  |  Branch (11002:6): [True: 9, False: 15]
  ------------------
11003|       |	    /*
11004|       |	    * SPEC src-include (2.1)
11005|       |	    * "SII has a targetNamespace [attribute], and its `actual
11006|       |	    * value` is identical to the `actual value` of the targetNamespace
11007|       |	    * [attribute] of SII' (which must have such an [attribute])."
11008|       |	    */
11009|      9|	    if (pctxt->targetNamespace == NULL) {
  ------------------
  |  Branch (11009:10): [True: 1, False: 8]
  ------------------
11010|      1|		xmlSchemaCustomErr(ACTXT_CAST pctxt,
  ------------------
  |  |  121|      1|#define ACTXT_CAST (xmlSchemaAbstractCtxtPtr)
  ------------------
11011|      1|		    XML_SCHEMAP_SRC_INCLUDE,
11012|      1|		    node, NULL,
11013|      1|		    "The target namespace of the included/redefined schema "
11014|      1|		    "'%s' has to be absent, since the including/redefining "
11015|      1|		    "schema has no target namespace",
11016|      1|		    schemaLocation, NULL);
11017|      1|		goto exit_error;
11018|      8|	    } else if (!xmlStrEqual(bucket->origTargetNamespace,
  ------------------
  |  Branch (11018:17): [True: 3, False: 5]
  ------------------
11019|      8|		pctxt->targetNamespace)) {
11020|       |		/* TODO: Change error function. */
11021|      3|		xmlSchemaPCustomErrExt(pctxt,
11022|      3|		    XML_SCHEMAP_SRC_INCLUDE,
11023|      3|		    NULL, node,
11024|      3|		    "The target namespace '%s' of the included/redefined "
11025|      3|		    "schema '%s' differs from '%s' of the "
11026|      3|		    "including/redefining schema",
11027|      3|		    bucket->origTargetNamespace, schemaLocation,
11028|      3|		    pctxt->targetNamespace);
11029|      3|		goto exit_error;
11030|      3|	    }
11031|     15|	} else if (pctxt->targetNamespace != NULL) {
  ------------------
  |  Branch (11031:13): [True: 12, False: 3]
  ------------------
11032|       |	    /*
11033|       |	    * Chameleons: the original target namespace will
11034|       |	    * differ from the resulting namespace.
11035|       |	    */
11036|     12|	    isChameleon = 1;
11037|     12|	    bucket->targetNamespace = pctxt->targetNamespace;
11038|     12|	}
11039|     24|    }
11040|       |    /*
11041|       |    * Parse the schema.
11042|       |    */
11043|     20|    if (bucket && (!bucket->parsed) && (bucket->doc != NULL)) {
  ------------------
  |  Branch (11043:9): [True: 20, False: 0]
  |  Branch (11043:19): [True: 17, False: 3]
  |  Branch (11043:40): [True: 17, False: 0]
  ------------------
11044|     17|	if (isChameleon) {
  ------------------
  |  Branch (11044:6): [True: 10, False: 7]
  ------------------
11045|       |	    /* TODO: Get rid of this flag on the schema itself. */
11046|     10|	    if ((schema->flags & XML_SCHEMAS_INCLUDING_CONVERT_NS) == 0) {
  ------------------
  |  |  917|     10|#define XML_SCHEMAS_INCLUDING_CONVERT_NS            1 << 9
  ------------------
  |  Branch (11046:10): [True: 10, False: 0]
  ------------------
11047|     10|		schema->flags |= XML_SCHEMAS_INCLUDING_CONVERT_NS;
  ------------------
  |  |  917|     10|#define XML_SCHEMAS_INCLUDING_CONVERT_NS            1 << 9
  ------------------
11048|     10|	    } else
11049|      0|		wasChameleon = 1;
11050|     10|	}
11051|     17|	xmlSchemaParseNewDoc(pctxt, schema, bucket);
11052|       |	/* Restore chameleon flag. */
11053|     17|	if (isChameleon && (!wasChameleon))
  ------------------
  |  Branch (11053:6): [True: 10, False: 7]
  |  Branch (11053:21): [True: 10, False: 0]
  ------------------
11054|     10|	    schema->flags ^= XML_SCHEMAS_INCLUDING_CONVERT_NS;
  ------------------
  |  |  917|     10|#define XML_SCHEMAS_INCLUDING_CONVERT_NS            1 << 9
  ------------------
11055|     17|    }
11056|       |    /*
11057|       |    * And now for the children...
11058|       |    */
11059|     20|    child = node->children;
11060|     20|    if (type == XML_SCHEMA_SCHEMA_REDEFINE) {
  ------------------
  |  |  374|     20|#define XML_SCHEMA_SCHEMA_REDEFINE 3
  ------------------
  |  Branch (11060:9): [True: 0, False: 20]
  ------------------
11061|       |	/*
11062|       |	* Parse (simpleType | complexType | group | attributeGroup))*
11063|       |	*/
11064|      0|	pctxt->redefined = bucket;
11065|       |	/*
11066|       |	* How to proceed if the redefined schema was not located?
11067|       |	*/
11068|      0|	pctxt->isRedefine = 1;
11069|      0|	while (IS_SCHEMA(child, "annotation") ||
  ------------------
  |  |  316|      0|   ((node != NULL) && (node->ns != NULL) && \
  |  |  ------------------
  |  |  |  Branch (316:5): [True: 0, False: 0]
  |  |  |  Branch (316:23): [True: 0, False: 0]
  |  |  ------------------
  |  |  317|      0|    (xmlStrEqual(node->name, (const xmlChar *) type)) && \
  |  |  ------------------
  |  |  |  Branch (317:5): [True: 0, False: 0]
  |  |  ------------------
  |  |  318|      0|    (xmlStrEqual(node->ns->href, xmlSchemaNs)))
  |  |  ------------------
  |  |  |  Branch (318:5): [True: 0, False: 0]
  |  |  ------------------
  ------------------
11070|      0|	    IS_SCHEMA(child, "simpleType") ||
  ------------------
  |  |  316|      0|   ((node != NULL) && (node->ns != NULL) && \
  |  |  ------------------
  |  |  |  Branch (316:5): [True: 0, False: 0]
  |  |  |  Branch (316:23): [True: 0, False: 0]
  |  |  ------------------
  |  |  317|      0|    (xmlStrEqual(node->name, (const xmlChar *) type)) && \
  |  |  ------------------
  |  |  |  Branch (317:5): [True: 0, False: 0]
  |  |  ------------------
  |  |  318|      0|    (xmlStrEqual(node->ns->href, xmlSchemaNs)))
  |  |  ------------------
  |  |  |  Branch (318:5): [True: 0, False: 0]
  |  |  ------------------
  ------------------
11071|      0|	    IS_SCHEMA(child, "complexType") ||
  ------------------
  |  |  316|      0|   ((node != NULL) && (node->ns != NULL) && \
  |  |  ------------------
  |  |  |  Branch (316:5): [True: 0, False: 0]
  |  |  |  Branch (316:23): [True: 0, False: 0]
  |  |  ------------------
  |  |  317|      0|    (xmlStrEqual(node->name, (const xmlChar *) type)) && \
  |  |  ------------------
  |  |  |  Branch (317:5): [True: 0, False: 0]
  |  |  ------------------
  |  |  318|      0|    (xmlStrEqual(node->ns->href, xmlSchemaNs)))
  |  |  ------------------
  |  |  |  Branch (318:5): [True: 0, False: 0]
  |  |  ------------------
  ------------------
11072|      0|	    IS_SCHEMA(child, "group") ||
  ------------------
  |  |  316|      0|   ((node != NULL) && (node->ns != NULL) && \
  |  |  ------------------
  |  |  |  Branch (316:5): [True: 0, False: 0]
  |  |  |  Branch (316:23): [True: 0, False: 0]
  |  |  ------------------
  |  |  317|      0|    (xmlStrEqual(node->name, (const xmlChar *) type)) && \
  |  |  ------------------
  |  |  |  Branch (317:5): [True: 0, False: 0]
  |  |  ------------------
  |  |  318|      0|    (xmlStrEqual(node->ns->href, xmlSchemaNs)))
  |  |  ------------------
  |  |  |  Branch (318:5): [True: 0, False: 0]
  |  |  ------------------
  ------------------
11073|      0|	    IS_SCHEMA(child, "attributeGroup")) {
  ------------------
  |  |  316|      0|   ((node != NULL) && (node->ns != NULL) && \
  |  |  ------------------
  |  |  |  Branch (316:5): [True: 0, False: 0]
  |  |  |  Branch (316:23): [True: 0, False: 0]
  |  |  ------------------
  |  |  317|      0|    (xmlStrEqual(node->name, (const xmlChar *) type)) && \
  |  |  ------------------
  |  |  |  Branch (317:5): [True: 0, False: 0]
  |  |  ------------------
  |  |  318|      0|    (xmlStrEqual(node->ns->href, xmlSchemaNs)))
  |  |  ------------------
  |  |  |  Branch (318:5): [True: 0, False: 0]
  |  |  ------------------
  ------------------
11074|      0|	    if (IS_SCHEMA(child, "annotation")) {
  ------------------
  |  |  316|      0|   ((node != NULL) && (node->ns != NULL) && \
  |  |  ------------------
  |  |  |  Branch (316:5): [True: 0, False: 0]
  |  |  |  Branch (316:23): [True: 0, False: 0]
  |  |  ------------------
  |  |  317|      0|    (xmlStrEqual(node->name, (const xmlChar *) type)) && \
  |  |  ------------------
  |  |  |  Branch (317:5): [True: 0, False: 0]
  |  |  ------------------
  |  |  318|      0|    (xmlStrEqual(node->ns->href, xmlSchemaNs)))
  |  |  ------------------
  |  |  |  Branch (318:5): [True: 0, False: 0]
  |  |  ------------------
  ------------------
11075|       |		/*
11076|       |		* TODO: discard or not?
11077|       |		*/
11078|      0|	    } else if (IS_SCHEMA(child, "simpleType")) {
  ------------------
  |  |  316|      0|   ((node != NULL) && (node->ns != NULL) && \
  |  |  ------------------
  |  |  |  Branch (316:5): [True: 0, False: 0]
  |  |  |  Branch (316:23): [True: 0, False: 0]
  |  |  ------------------
  |  |  317|      0|    (xmlStrEqual(node->name, (const xmlChar *) type)) && \
  |  |  ------------------
  |  |  |  Branch (317:5): [True: 0, False: 0]
  |  |  ------------------
  |  |  318|      0|    (xmlStrEqual(node->ns->href, xmlSchemaNs)))
  |  |  ------------------
  |  |  |  Branch (318:5): [True: 0, False: 0]
  |  |  ------------------
  ------------------
11079|      0|		xmlSchemaParseSimpleType(pctxt, schema, child, 1);
11080|      0|	    } else if (IS_SCHEMA(child, "complexType")) {
  ------------------
  |  |  316|      0|   ((node != NULL) && (node->ns != NULL) && \
  |  |  ------------------
  |  |  |  Branch (316:5): [True: 0, False: 0]
  |  |  |  Branch (316:23): [True: 0, False: 0]
  |  |  ------------------
  |  |  317|      0|    (xmlStrEqual(node->name, (const xmlChar *) type)) && \
  |  |  ------------------
  |  |  |  Branch (317:5): [True: 0, False: 0]
  |  |  ------------------
  |  |  318|      0|    (xmlStrEqual(node->ns->href, xmlSchemaNs)))
  |  |  ------------------
  |  |  |  Branch (318:5): [True: 0, False: 0]
  |  |  ------------------
  ------------------
11081|      0|		xmlSchemaParseComplexType(pctxt, schema, child, 1);
11082|       |		/* hasRedefinitions = 1; */
11083|      0|	    } else if (IS_SCHEMA(child, "group")) {
  ------------------
  |  |  316|      0|   ((node != NULL) && (node->ns != NULL) && \
  |  |  ------------------
  |  |  |  Branch (316:5): [True: 0, False: 0]
  |  |  |  Branch (316:23): [True: 0, False: 0]
  |  |  ------------------
  |  |  317|      0|    (xmlStrEqual(node->name, (const xmlChar *) type)) && \
  |  |  ------------------
  |  |  |  Branch (317:5): [True: 0, False: 0]
  |  |  ------------------
  |  |  318|      0|    (xmlStrEqual(node->ns->href, xmlSchemaNs)))
  |  |  ------------------
  |  |  |  Branch (318:5): [True: 0, False: 0]
  |  |  ------------------
  ------------------
11084|       |		/* hasRedefinitions = 1; */
11085|      0|		xmlSchemaParseModelGroupDefinition(pctxt,
11086|      0|		    schema, child);
11087|      0|	    } else if (IS_SCHEMA(child, "attributeGroup")) {
  ------------------
  |  |  316|      0|   ((node != NULL) && (node->ns != NULL) && \
  |  |  ------------------
  |  |  |  Branch (316:5): [True: 0, False: 0]
  |  |  |  Branch (316:23): [True: 0, False: 0]
  |  |  ------------------
  |  |  317|      0|    (xmlStrEqual(node->name, (const xmlChar *) type)) && \
  |  |  ------------------
  |  |  |  Branch (317:5): [True: 0, False: 0]
  |  |  ------------------
  |  |  318|      0|    (xmlStrEqual(node->ns->href, xmlSchemaNs)))
  |  |  ------------------
  |  |  |  Branch (318:5): [True: 0, False: 0]
  |  |  ------------------
  ------------------
11088|       |		/* hasRedefinitions = 1; */
11089|      0|		xmlSchemaParseAttributeGroupDefinition(pctxt, schema,
11090|      0|		    child);
11091|      0|	    }
11092|      0|	    child = child->next;
11093|      0|	}
11094|      0|	pctxt->redefined = NULL;
11095|      0|	pctxt->isRedefine = 0;
11096|     20|    } else {
11097|     20|	if (IS_SCHEMA(child, "annotation")) {
  ------------------
  |  |  316|     20|   ((node != NULL) && (node->ns != NULL) && \
  |  |  ------------------
  |  |  |  Branch (316:5): [True: 0, False: 20]
  |  |  |  Branch (316:23): [True: 0, False: 0]
  |  |  ------------------
  |  |  317|     20|    (xmlStrEqual(node->name, (const xmlChar *) type)) && \
  |  |  ------------------
  |  |  |  Branch (317:5): [True: 0, False: 0]
  |  |  ------------------
  |  |  318|     20|    (xmlStrEqual(node->ns->href, xmlSchemaNs)))
  |  |  ------------------
  |  |  |  Branch (318:5): [True: 0, False: 0]
  |  |  ------------------
  ------------------
11098|       |	    /*
11099|       |	    * TODO: discard or not?
11100|       |	    */
11101|      0|	    child = child->next;
11102|      0|	}
11103|     20|    }
11104|     20|    if (child != NULL) {
  ------------------
  |  Branch (11104:9): [True: 0, False: 20]
  ------------------
11105|      0|	res = XML_SCHEMAP_S4S_ELEM_NOT_ALLOWED;
11106|      0|	if (type == XML_SCHEMA_SCHEMA_REDEFINE) {
  ------------------
  |  |  374|      0|#define XML_SCHEMA_SCHEMA_REDEFINE 3
  ------------------
  |  Branch (11106:6): [True: 0, False: 0]
  ------------------
11107|      0|	    xmlSchemaPContentErr(pctxt, res,
11108|      0|		NULL, node, child, NULL,
11109|      0|		"(annotation | (simpleType | complexType | group | attributeGroup))*");
11110|      0|	} else {
11111|      0|	     xmlSchemaPContentErr(pctxt, res,
11112|      0|		NULL, node, child, NULL,
11113|      0|		"(annotation?)");
11114|      0|	}
11115|      0|    }
11116|     20|    return(res);
11117|       |
11118|      4|exit_error:
11119|      4|    return(pctxt->err);
11120|     24|}
xmlschemas.c:xmlSchemaParseIncludeOrRedefineAttrs:
10835|     29|{
10836|     29|    xmlAttrPtr attr;
10837|       |
10838|     29|    if ((pctxt == NULL) || (schema == NULL) || (node == NULL) ||
  ------------------
  |  Branch (10838:9): [True: 0, False: 29]
  |  Branch (10838:28): [True: 0, False: 29]
  |  Branch (10838:48): [True: 0, False: 29]
  ------------------
10839|     29|	(schemaLocation == NULL))
  ------------------
  |  Branch (10839:2): [True: 0, False: 29]
  ------------------
10840|      0|        return (-1);
10841|       |
10842|     29|    *schemaLocation = NULL;
10843|       |    /*
10844|       |    * Check for illegal attributes.
10845|       |    * Applies for both <include> and <redefine>.
10846|       |    */
10847|     29|    attr = node->properties;
10848|     58|    while (attr != NULL) {
  ------------------
  |  Branch (10848:12): [True: 29, False: 29]
  ------------------
10849|     29|	if (attr->ns == NULL) {
  ------------------
  |  Branch (10849:6): [True: 29, False: 0]
  ------------------
10850|     29|	    if ((!xmlStrEqual(attr->name, BAD_CAST "id")) &&
  ------------------
  |  |   35|     29|#define BAD_CAST (xmlChar *)
  ------------------
  |  Branch (10850:10): [True: 29, False: 0]
  ------------------
10851|     29|		(!xmlStrEqual(attr->name, BAD_CAST "schemaLocation"))) {
  ------------------
  |  |   35|     29|#define BAD_CAST (xmlChar *)
  ------------------
  |  Branch (10851:3): [True: 0, False: 29]
  ------------------
10852|      0|		xmlSchemaPIllegalAttrErr(pctxt,
10853|      0|		    XML_SCHEMAP_S4S_ATTR_NOT_ALLOWED, NULL, attr);
10854|      0|	    }
10855|     29|	} else if (xmlStrEqual(attr->ns->href, xmlSchemaNs)) {
  ------------------
  |  Branch (10855:13): [True: 0, False: 0]
  ------------------
10856|      0|	    xmlSchemaPIllegalAttrErr(pctxt,
10857|      0|		XML_SCHEMAP_S4S_ATTR_NOT_ALLOWED, NULL, attr);
10858|      0|	}
10859|     29|	attr = attr->next;
10860|     29|    }
10861|     29|    xmlSchemaPValAttrID(pctxt, node, BAD_CAST "id");
  ------------------
  |  |   35|     29|#define BAD_CAST (xmlChar *)
  ------------------
10862|       |    /*
10863|       |    * Preliminary step, extract the URI-Reference and make an URI
10864|       |    * from the base.
10865|       |    */
10866|       |    /*
10867|       |    * Attribute "schemaLocation" is mandatory.
10868|       |    */
10869|     29|    attr = xmlSchemaGetPropNode(node, "schemaLocation");
10870|     29|    if (attr != NULL) {
  ------------------
  |  Branch (10870:9): [True: 29, False: 0]
  ------------------
10871|     29|        xmlChar *base = NULL;
10872|     29|        xmlChar *uri = NULL;
10873|       |
10874|     29|	if (xmlSchemaPValAttrNode(pctxt, NULL, attr,
  ------------------
  |  Branch (10874:6): [True: 0, False: 29]
  ------------------
10875|     29|	    xmlSchemaGetBuiltInType(XML_SCHEMAS_ANYURI),
10876|     29|	    (const xmlChar **) schemaLocation) != 0)
10877|      0|	    goto exit_error;
10878|     29|	base = xmlNodeGetBase(node->doc, node);
10879|     29|	if (base == NULL) {
  ------------------
  |  Branch (10879:6): [True: 0, False: 29]
  ------------------
10880|      0|	    uri = xmlBuildURI(*schemaLocation, node->doc->URL);
10881|     29|	} else {
10882|     29|	    uri = xmlBuildURI(*schemaLocation, base);
10883|     29|	    xmlFree(base);
10884|     29|	}
10885|     29|	if (uri == NULL) {
  ------------------
  |  Branch (10885:6): [True: 0, False: 29]
  ------------------
10886|      0|	    PERROR_INT("xmlSchemaParseIncludeOrRedefine",
  ------------------
  |  | 2824|      0|#define PERROR_INT(func, msg) xmlSchemaInternalErr(ACTXT_CAST pctxt, func, msg);
  |  |  ------------------
  |  |  |  |  121|      0|#define ACTXT_CAST (xmlSchemaAbstractCtxtPtr)
  |  |  ------------------
  ------------------
10887|      0|		"could not build an URI from the schemaLocation")
10888|      0|	    goto exit_failure;
10889|      0|	}
10890|     29|	(*schemaLocation) = (xmlChar *) xmlDictLookup(pctxt->dict, uri, -1);
10891|     29|	xmlFree(uri);
10892|     29|    } else {
10893|      0|	xmlSchemaPMissingAttrErr(pctxt,
10894|      0|	    XML_SCHEMAP_S4S_ATTR_MISSING,
10895|      0|	    NULL, node, "schemaLocation", NULL);
10896|      0|	goto exit_error;
10897|      0|    }
10898|       |    /*
10899|       |    * Report self-inclusion and self-redefinition.
10900|       |    */
10901|     29|    if (xmlStrEqual(*schemaLocation, pctxt->URL)) {
  ------------------
  |  Branch (10901:9): [True: 0, False: 29]
  ------------------
10902|      0|	if (type == XML_SCHEMA_SCHEMA_REDEFINE) {
  ------------------
  |  |  374|      0|#define XML_SCHEMA_SCHEMA_REDEFINE 3
  ------------------
  |  Branch (10902:6): [True: 0, False: 0]
  ------------------
10903|      0|	    xmlSchemaPCustomErr(pctxt,
10904|      0|		XML_SCHEMAP_SRC_REDEFINE,
10905|      0|		NULL, node,
10906|      0|		"The schema document '%s' cannot redefine itself.",
10907|      0|		*schemaLocation);
10908|      0|	} else {
10909|      0|	    xmlSchemaPCustomErr(pctxt,
10910|      0|		XML_SCHEMAP_SRC_INCLUDE,
10911|      0|		NULL, node,
10912|      0|		"The schema document '%s' cannot include itself.",
10913|      0|		*schemaLocation);
10914|      0|	}
10915|      0|	goto exit_error;
10916|      0|    }
10917|       |
10918|     29|    return(0);
10919|      0|exit_error:
10920|      0|    return(pctxt->err);
10921|      0|exit_failure:
10922|      0|    return(-1);
10923|     29|}
xmlschemas.c:xmlSchemaPMissingAttrErr:
 2847|      1|{
 2848|      1|    xmlChar *des = NULL;
 2849|       |
 2850|      1|    xmlSchemaFormatItemForReport(&des, NULL, ownerItem, ownerElem);
 2851|       |
 2852|      1|    if (message != NULL)
  ------------------
  |  Branch (2852:9): [True: 0, False: 1]
  ------------------
 2853|      0|	xmlSchemaPErr(ctxt, ownerElem, error, "%s: %s.\n", BAD_CAST des, BAD_CAST message);
  ------------------
  |  |   35|      0|#define BAD_CAST (xmlChar *)
  ------------------
              	xmlSchemaPErr(ctxt, ownerElem, error, "%s: %s.\n", BAD_CAST des, BAD_CAST message);
  ------------------
  |  |   35|      0|#define BAD_CAST (xmlChar *)
  ------------------
 2854|      1|    else
 2855|      1|	xmlSchemaPErr(ctxt, ownerElem, error,
 2856|      1|	    "%s: The attribute '%s' is required but missing.\n",
 2857|      1|	    BAD_CAST des, BAD_CAST name);
  ------------------
  |  |   35|      1|#define BAD_CAST (xmlChar *)
  ------------------
              	    BAD_CAST des, BAD_CAST name);
  ------------------
  |  |   35|      1|#define BAD_CAST (xmlChar *)
  ------------------
 2858|      1|    FREE_AND_NULL(des);
  ------------------
  |  |  320|      1|#define FREE_AND_NULL(str) if ((str) != NULL) { xmlFree((xmlChar *) (str)); str = NULL; }
  |  |  ------------------
  |  |  |  Branch (320:32): [True: 1, False: 0]
  |  |  ------------------
  ------------------
 2859|      1|}
xmlschemas.c:xmlSchemaParseComplexType:
12069|    380|{
12070|    380|    xmlSchemaTypePtr type, ctxtType;
12071|    380|    xmlNodePtr child = NULL;
12072|    380|    const xmlChar *name = NULL;
12073|    380|    xmlAttrPtr attr;
12074|    380|    const xmlChar *attrValue;
12075|       |#ifdef ENABLE_NAMED_LOCALS
12076|       |    char buf[40];
12077|       |#endif
12078|    380|    int final = 0, block = 0, hasRestrictionOrExtension = 0;
12079|       |
12080|       |
12081|    380|    if ((ctxt == NULL) || (schema == NULL) || (node == NULL))
  ------------------
  |  Branch (12081:9): [True: 0, False: 380]
  |  Branch (12081:27): [True: 0, False: 380]
  |  Branch (12081:47): [True: 0, False: 380]
  ------------------
12082|      0|        return (NULL);
12083|       |
12084|    380|    ctxtType = ctxt->ctxtType;
12085|       |
12086|    380|    if (topLevel) {
  ------------------
  |  Branch (12086:9): [True: 182, False: 198]
  ------------------
12087|    182|	attr = xmlSchemaGetPropNode(node, "name");
12088|    182|	if (attr == NULL) {
  ------------------
  |  Branch (12088:6): [True: 0, False: 182]
  ------------------
12089|      0|	    xmlSchemaPMissingAttrErr(ctxt,
12090|      0|		XML_SCHEMAP_S4S_ATTR_MISSING, NULL, node, "name", NULL);
12091|      0|	    return (NULL);
12092|    182|	} else if (xmlSchemaPValAttrNode(ctxt, NULL, attr,
  ------------------
  |  Branch (12092:13): [True: 0, False: 182]
  ------------------
12093|    182|	    xmlSchemaGetBuiltInType(XML_SCHEMAS_NCNAME), &name) != 0) {
12094|      0|	    return (NULL);
12095|      0|	}
12096|    182|    }
12097|       |
12098|    380|    if (topLevel == 0) {
  ------------------
  |  Branch (12098:9): [True: 198, False: 182]
  ------------------
12099|       |	/*
12100|       |	* Parse as local complex type definition.
12101|       |	*/
12102|       |#ifdef ENABLE_NAMED_LOCALS
12103|       |        snprintf(buf, 39, "#CT%d", ctxt->counter++ + 1);
12104|       |	type = xmlSchemaAddType(ctxt, schema,
12105|       |	    XML_SCHEMA_TYPE_COMPLEX,
12106|       |	    xmlDictLookup(ctxt->dict, (const xmlChar *)buf, -1),
12107|       |	    ctxt->targetNamespace, node, 0);
12108|       |#else
12109|    198|	type = xmlSchemaAddType(ctxt, schema,
12110|    198|	    XML_SCHEMA_TYPE_COMPLEX,
12111|    198|	    NULL, ctxt->targetNamespace, node, 0);
12112|    198|#endif
12113|    198|	if (type == NULL)
  ------------------
  |  Branch (12113:6): [True: 0, False: 198]
  ------------------
12114|      0|	    return (NULL);
12115|    198|	name = type->name;
12116|    198|	type->node = node;
12117|    198|	type->type = XML_SCHEMA_TYPE_COMPLEX;
12118|       |	/*
12119|       |	* TODO: We need the target namespace.
12120|       |	*/
12121|    198|    } else {
12122|       |	/*
12123|       |	* Parse as global complex type definition.
12124|       |	*/
12125|    182|	type = xmlSchemaAddType(ctxt, schema,
12126|    182|	    XML_SCHEMA_TYPE_COMPLEX,
12127|    182|	    name, ctxt->targetNamespace, node, 1);
12128|    182|	if (type == NULL)
  ------------------
  |  Branch (12128:6): [True: 0, False: 182]
  ------------------
12129|      0|	    return (NULL);
12130|    182|	type->node = node;
12131|    182|	type->type = XML_SCHEMA_TYPE_COMPLEX;
12132|    182|	type->flags |= XML_SCHEMAS_TYPE_GLOBAL;
  ------------------
  |  |  426|    182|#define XML_SCHEMAS_TYPE_GLOBAL                1 << 3
  ------------------
12133|    182|    }
12134|    380|    type->targetNamespace = ctxt->targetNamespace;
12135|       |    /*
12136|       |    * Handle attributes.
12137|       |    */
12138|    380|    attr = node->properties;
12139|    580|    while (attr != NULL) {
  ------------------
  |  Branch (12139:12): [True: 200, False: 380]
  ------------------
12140|    200|	if (attr->ns == NULL) {
  ------------------
  |  Branch (12140:6): [True: 200, False: 0]
  ------------------
12141|    200|	    if (xmlStrEqual(attr->name, BAD_CAST "id")) {
  ------------------
  |  |   35|    200|#define BAD_CAST (xmlChar *)
  ------------------
  |  Branch (12141:10): [True: 5, False: 195]
  ------------------
12142|       |		/*
12143|       |		* Attribute "id".
12144|       |		*/
12145|      5|		xmlSchemaPValAttrID(ctxt, node, BAD_CAST "id");
  ------------------
  |  |   35|      5|#define BAD_CAST (xmlChar *)
  ------------------
12146|    195|	    } else if (xmlStrEqual(attr->name, BAD_CAST "mixed")) {
  ------------------
  |  |   35|    195|#define BAD_CAST (xmlChar *)
  ------------------
  |  Branch (12146:17): [True: 11, False: 184]
  ------------------
12147|       |		/*
12148|       |		* Attribute "mixed".
12149|       |		*/
12150|     11|		if (xmlSchemaPGetBoolNodeValue(ctxt,
  ------------------
  |  Branch (12150:7): [True: 11, False: 0]
  ------------------
12151|     11|			NULL, (xmlNodePtr) attr))
12152|     11|		    type->flags |= XML_SCHEMAS_TYPE_MIXED;
  ------------------
  |  |  408|     11|#define XML_SCHEMAS_TYPE_MIXED                1 << 0
  ------------------
12153|    184|	    } else if (topLevel) {
  ------------------
  |  Branch (12153:17): [True: 184, False: 0]
  ------------------
12154|       |		/*
12155|       |		* Attributes of global complex type definitions.
12156|       |		*/
12157|    184|		if (xmlStrEqual(attr->name, BAD_CAST "name")) {
  ------------------
  |  |   35|    184|#define BAD_CAST (xmlChar *)
  ------------------
  |  Branch (12157:7): [True: 182, False: 2]
  ------------------
12158|       |		    /* Pass. */
12159|    182|		} else if (xmlStrEqual(attr->name, BAD_CAST "abstract")) {
  ------------------
  |  |   35|      2|#define BAD_CAST (xmlChar *)
  ------------------
  |  Branch (12159:14): [True: 2, False: 0]
  ------------------
12160|       |		    /*
12161|       |		    * Attribute "abstract".
12162|       |		    */
12163|      2|		    if (xmlSchemaPGetBoolNodeValue(ctxt,
  ------------------
  |  Branch (12163:11): [True: 2, False: 0]
  ------------------
12164|      2|			    NULL, (xmlNodePtr) attr))
12165|      2|			type->flags |= XML_SCHEMAS_TYPE_ABSTRACT;
  ------------------
  |  |  527|      2|#define XML_SCHEMAS_TYPE_ABSTRACT    1 << 20
  ------------------
12166|      2|		} else if (xmlStrEqual(attr->name, BAD_CAST "final")) {
  ------------------
  |  |   35|      0|#define BAD_CAST (xmlChar *)
  ------------------
  |  Branch (12166:14): [True: 0, False: 0]
  ------------------
12167|       |		    /*
12168|       |		    * Attribute "final".
12169|       |		    */
12170|      0|		    attrValue = xmlSchemaGetNodeContent(ctxt,
12171|      0|			(xmlNodePtr) attr);
12172|      0|		    if (xmlSchemaPValAttrBlockFinal(attrValue,
  ------------------
  |  Branch (12172:11): [True: 0, False: 0]
  ------------------
12173|      0|			&(type->flags),
12174|      0|			-1,
12175|      0|			XML_SCHEMAS_TYPE_FINAL_EXTENSION,
  ------------------
  |  |  466|      0|#define XML_SCHEMAS_TYPE_FINAL_EXTENSION    1 << 9
  ------------------
12176|      0|			XML_SCHEMAS_TYPE_FINAL_RESTRICTION,
  ------------------
  |  |  472|      0|#define XML_SCHEMAS_TYPE_FINAL_RESTRICTION    1 << 10
  ------------------
12177|      0|			-1, -1, -1) != 0)
12178|      0|		    {
12179|      0|			xmlSchemaPSimpleTypeErr(ctxt,
12180|      0|			    XML_SCHEMAP_S4S_ATTR_INVALID_VALUE,
12181|      0|			    NULL, (xmlNodePtr) attr, NULL,
12182|      0|			    "(#all | List of (extension | restriction))",
12183|      0|			    attrValue, NULL, NULL, NULL);
12184|      0|		    } else
12185|      0|			final = 1;
12186|      0|		} else if (xmlStrEqual(attr->name, BAD_CAST "block")) {
  ------------------
  |  |   35|      0|#define BAD_CAST (xmlChar *)
  ------------------
  |  Branch (12186:14): [True: 0, False: 0]
  ------------------
12187|       |		    /*
12188|       |		    * Attribute "block".
12189|       |		    */
12190|      0|		    attrValue = xmlSchemaGetNodeContent(ctxt,
12191|      0|			(xmlNodePtr) attr);
12192|      0|		    if (xmlSchemaPValAttrBlockFinal(attrValue, &(type->flags),
  ------------------
  |  Branch (12192:11): [True: 0, False: 0]
  ------------------
12193|      0|			-1,
12194|      0|			XML_SCHEMAS_TYPE_BLOCK_EXTENSION,
  ------------------
  |  |  515|      0|#define XML_SCHEMAS_TYPE_BLOCK_EXTENSION    1 << 18
  ------------------
12195|      0|			XML_SCHEMAS_TYPE_BLOCK_RESTRICTION,
  ------------------
  |  |  521|      0|#define XML_SCHEMAS_TYPE_BLOCK_RESTRICTION    1 << 19
  ------------------
12196|      0|			-1, -1, -1) != 0) {
12197|      0|			xmlSchemaPSimpleTypeErr(ctxt,
12198|      0|			    XML_SCHEMAP_S4S_ATTR_INVALID_VALUE,
12199|      0|			    NULL, (xmlNodePtr) attr, NULL,
12200|      0|			    "(#all | List of (extension | restriction)) ",
12201|      0|			    attrValue, NULL, NULL, NULL);
12202|      0|		    } else
12203|      0|			block = 1;
12204|      0|		} else {
12205|      0|			xmlSchemaPIllegalAttrErr(ctxt,
12206|      0|			    XML_SCHEMAP_S4S_ATTR_NOT_ALLOWED, NULL, attr);
12207|      0|		}
12208|    184|	    } else {
12209|      0|		xmlSchemaPIllegalAttrErr(ctxt,
12210|      0|		    XML_SCHEMAP_S4S_ATTR_NOT_ALLOWED, NULL, attr);
12211|      0|	    }
12212|    200|	} else if (xmlStrEqual(attr->ns->href, xmlSchemaNs)) {
  ------------------
  |  Branch (12212:13): [True: 0, False: 0]
  ------------------
12213|      0|	    xmlSchemaPIllegalAttrErr(ctxt,
12214|      0|		XML_SCHEMAP_S4S_ATTR_NOT_ALLOWED, NULL, attr);
12215|      0|	}
12216|    200|	attr = attr->next;
12217|    200|    }
12218|    380|    if (! block) {
  ------------------
  |  Branch (12218:9): [True: 380, False: 0]
  ------------------
12219|       |	/*
12220|       |	* Apply default "block" values.
12221|       |	*/
12222|    380|	if (schema->flags & XML_SCHEMAS_BLOCK_DEFAULT_RESTRICTION)
  ------------------
  |  |  904|    380|#define XML_SCHEMAS_BLOCK_DEFAULT_RESTRICTION            1 << 7
  ------------------
  |  Branch (12222:6): [True: 0, False: 380]
  ------------------
12223|      0|	    type->flags |= XML_SCHEMAS_TYPE_BLOCK_RESTRICTION;
  ------------------
  |  |  521|      0|#define XML_SCHEMAS_TYPE_BLOCK_RESTRICTION    1 << 19
  ------------------
12224|    380|	if (schema->flags & XML_SCHEMAS_BLOCK_DEFAULT_EXTENSION)
  ------------------
  |  |  898|    380|#define XML_SCHEMAS_BLOCK_DEFAULT_EXTENSION            1 << 6
  ------------------
  |  Branch (12224:6): [True: 1, False: 379]
  ------------------
12225|      1|	    type->flags |= XML_SCHEMAS_TYPE_BLOCK_EXTENSION;
  ------------------
  |  |  515|      1|#define XML_SCHEMAS_TYPE_BLOCK_EXTENSION    1 << 18
  ------------------
12226|    380|    }
12227|    380|    if (! final) {
  ------------------
  |  Branch (12227:9): [True: 380, False: 0]
  ------------------
12228|       |	/*
12229|       |	* Apply default "block" values.
12230|       |	*/
12231|    380|	if (schema->flags & XML_SCHEMAS_FINAL_DEFAULT_RESTRICTION)
  ------------------
  |  |  880|    380|#define XML_SCHEMAS_FINAL_DEFAULT_RESTRICTION            1 << 3
  ------------------
  |  Branch (12231:6): [True: 0, False: 380]
  ------------------
12232|      0|	    type->flags |= XML_SCHEMAS_TYPE_FINAL_RESTRICTION;
  ------------------
  |  |  472|      0|#define XML_SCHEMAS_TYPE_FINAL_RESTRICTION    1 << 10
  ------------------
12233|    380|	if (schema->flags & XML_SCHEMAS_FINAL_DEFAULT_EXTENSION)
  ------------------
  |  |  874|    380|#define XML_SCHEMAS_FINAL_DEFAULT_EXTENSION        1 << 2
  ------------------
  |  Branch (12233:6): [True: 1, False: 379]
  ------------------
12234|      1|	    type->flags |= XML_SCHEMAS_TYPE_FINAL_EXTENSION;
  ------------------
  |  |  466|      1|#define XML_SCHEMAS_TYPE_FINAL_EXTENSION    1 << 9
  ------------------
12235|    380|    }
12236|       |    /*
12237|       |    * And now for the children...
12238|       |    */
12239|    380|    child = node->children;
12240|    380|    if (IS_SCHEMA(child, "annotation")) {
  ------------------
  |  |  316|    380|   ((node != NULL) && (node->ns != NULL) && \
  |  |  ------------------
  |  |  |  Branch (316:5): [True: 374, False: 6]
  |  |  |  Branch (316:23): [True: 374, False: 0]
  |  |  ------------------
  |  |  317|    380|    (xmlStrEqual(node->name, (const xmlChar *) type)) && \
  |  |  ------------------
  |  |  |  Branch (317:5): [True: 8, False: 366]
  |  |  ------------------
  |  |  318|    380|    (xmlStrEqual(node->ns->href, xmlSchemaNs)))
  |  |  ------------------
  |  |  |  Branch (318:5): [True: 8, False: 0]
  |  |  ------------------
  ------------------
12241|      8|        type->annot = xmlSchemaParseAnnotation(ctxt, child, 1);
12242|      8|        child = child->next;
12243|      8|    }
12244|    380|    ctxt->ctxtType = type;
12245|    380|    if (IS_SCHEMA(child, "simpleContent")) {
  ------------------
  |  |  316|    380|   ((node != NULL) && (node->ns != NULL) && \
  |  |  ------------------
  |  |  |  Branch (316:5): [True: 374, False: 6]
  |  |  |  Branch (316:23): [True: 374, False: 0]
  |  |  ------------------
  |  |  317|    380|    (xmlStrEqual(node->name, (const xmlChar *) type)) && \
  |  |  ------------------
  |  |  |  Branch (317:5): [True: 40, False: 334]
  |  |  ------------------
  |  |  318|    380|    (xmlStrEqual(node->ns->href, xmlSchemaNs)))
  |  |  ------------------
  |  |  |  Branch (318:5): [True: 40, False: 0]
  |  |  ------------------
  ------------------
12246|       |	/*
12247|       |	* <complexType><simpleContent>...
12248|       |	* 3.4.3 : 2.2
12249|       |	* Specifying mixed='true' when the <simpleContent>
12250|       |	* alternative is chosen has no effect
12251|       |	*/
12252|     40|	if (type->flags & XML_SCHEMAS_TYPE_MIXED)
  ------------------
  |  |  408|     40|#define XML_SCHEMAS_TYPE_MIXED                1 << 0
  ------------------
  |  Branch (12252:6): [True: 2, False: 38]
  ------------------
12253|      2|	    type->flags ^= XML_SCHEMAS_TYPE_MIXED;
  ------------------
  |  |  408|      2|#define XML_SCHEMAS_TYPE_MIXED                1 << 0
  ------------------
12254|     40|        xmlSchemaParseSimpleContent(ctxt, schema, child,
12255|     40|	    &hasRestrictionOrExtension);
12256|     40|        child = child->next;
12257|    340|    } else if (IS_SCHEMA(child, "complexContent")) {
  ------------------
  |  |  316|    340|   ((node != NULL) && (node->ns != NULL) && \
  |  |  ------------------
  |  |  |  Branch (316:5): [True: 334, False: 6]
  |  |  |  Branch (316:23): [True: 334, False: 0]
  |  |  ------------------
  |  |  317|    340|    (xmlStrEqual(node->name, (const xmlChar *) type)) && \
  |  |  ------------------
  |  |  |  Branch (317:5): [True: 62, False: 272]
  |  |  ------------------
  |  |  318|    340|    (xmlStrEqual(node->ns->href, xmlSchemaNs)))
  |  |  ------------------
  |  |  |  Branch (318:5): [True: 62, False: 0]
  |  |  ------------------
  ------------------
12258|       |	/*
12259|       |	* <complexType><complexContent>...
12260|       |	*/
12261|     62|	type->contentType = XML_SCHEMA_CONTENT_EMPTY;
12262|     62|        xmlSchemaParseComplexContent(ctxt, schema, child,
12263|     62|	    &hasRestrictionOrExtension);
12264|     62|        child = child->next;
12265|    278|    } else {
12266|       |	/*
12267|       |	* E.g <complexType><sequence>... or <complexType><attribute>... etc.
12268|       |	*
12269|       |	* SPEC
12270|       |	* "...the third alternative (neither <simpleContent> nor
12271|       |	* <complexContent>) is chosen. This case is understood as shorthand
12272|       |	* for complex content restricting the `ur-type definition`, and the
12273|       |	* details of the mappings should be modified as necessary.
12274|       |	*/
12275|    278|	type->baseType = xmlSchemaGetBuiltInType(XML_SCHEMAS_ANYTYPE);
12276|    278|	type->flags |= XML_SCHEMAS_TYPE_DERIVATION_METHOD_RESTRICTION;
  ------------------
  |  |  420|    278|#define XML_SCHEMAS_TYPE_DERIVATION_METHOD_RESTRICTION                1 << 2
  ------------------
12277|       |	/*
12278|       |	* Parse model groups.
12279|       |	*/
12280|    278|        if (IS_SCHEMA(child, "all")) {
  ------------------
  |  |  316|    278|   ((node != NULL) && (node->ns != NULL) && \
  |  |  ------------------
  |  |  |  Branch (316:5): [True: 272, False: 6]
  |  |  |  Branch (316:23): [True: 272, False: 0]
  |  |  ------------------
  |  |  317|    278|    (xmlStrEqual(node->name, (const xmlChar *) type)) && \
  |  |  ------------------
  |  |  |  Branch (317:5): [True: 10, False: 262]
  |  |  ------------------
  |  |  318|    278|    (xmlStrEqual(node->ns->href, xmlSchemaNs)))
  |  |  ------------------
  |  |  |  Branch (318:5): [True: 10, False: 0]
  |  |  ------------------
  ------------------
12281|     10|            type->subtypes = (xmlSchemaTypePtr)
12282|     10|		xmlSchemaParseModelGroup(ctxt, schema, child,
12283|     10|		    XML_SCHEMA_TYPE_ALL, 1);
12284|     10|            child = child->next;
12285|    268|        } else if (IS_SCHEMA(child, "choice")) {
  ------------------
  |  |  316|    268|   ((node != NULL) && (node->ns != NULL) && \
  |  |  ------------------
  |  |  |  Branch (316:5): [True: 262, False: 6]
  |  |  |  Branch (316:23): [True: 262, False: 0]
  |  |  ------------------
  |  |  317|    268|    (xmlStrEqual(node->name, (const xmlChar *) type)) && \
  |  |  ------------------
  |  |  |  Branch (317:5): [True: 19, False: 243]
  |  |  ------------------
  |  |  318|    268|    (xmlStrEqual(node->ns->href, xmlSchemaNs)))
  |  |  ------------------
  |  |  |  Branch (318:5): [True: 19, False: 0]
  |  |  ------------------
  ------------------
12286|     19|            type->subtypes = (xmlSchemaTypePtr)
12287|     19|		xmlSchemaParseModelGroup(ctxt, schema, child,
12288|     19|		    XML_SCHEMA_TYPE_CHOICE, 1);
12289|     19|            child = child->next;
12290|    249|        } else if (IS_SCHEMA(child, "sequence")) {
  ------------------
  |  |  316|    249|   ((node != NULL) && (node->ns != NULL) && \
  |  |  ------------------
  |  |  |  Branch (316:5): [True: 243, False: 6]
  |  |  |  Branch (316:23): [True: 243, False: 0]
  |  |  ------------------
  |  |  317|    249|    (xmlStrEqual(node->name, (const xmlChar *) type)) && \
  |  |  ------------------
  |  |  |  Branch (317:5): [True: 141, False: 102]
  |  |  ------------------
  |  |  318|    249|    (xmlStrEqual(node->ns->href, xmlSchemaNs)))
  |  |  ------------------
  |  |  |  Branch (318:5): [True: 141, False: 0]
  |  |  ------------------
  ------------------
12291|    141|            type->subtypes = (xmlSchemaTypePtr)
12292|    141|		xmlSchemaParseModelGroup(ctxt, schema, child,
12293|    141|		    XML_SCHEMA_TYPE_SEQUENCE, 1);
12294|    141|            child = child->next;
12295|    141|        } else if (IS_SCHEMA(child, "group")) {
  ------------------
  |  |  316|    108|   ((node != NULL) && (node->ns != NULL) && \
  |  |  ------------------
  |  |  |  Branch (316:5): [True: 102, False: 6]
  |  |  |  Branch (316:23): [True: 102, False: 0]
  |  |  ------------------
  |  |  317|    108|    (xmlStrEqual(node->name, (const xmlChar *) type)) && \
  |  |  ------------------
  |  |  |  Branch (317:5): [True: 4, False: 98]
  |  |  ------------------
  |  |  318|    108|    (xmlStrEqual(node->ns->href, xmlSchemaNs)))
  |  |  ------------------
  |  |  |  Branch (318:5): [True: 4, False: 0]
  |  |  ------------------
  ------------------
12296|      4|            type->subtypes = (xmlSchemaTypePtr)
12297|      4|		xmlSchemaParseModelGroupDefRef(ctxt, schema, child);
12298|       |	    /*
12299|       |	    * Note that the reference will be resolved in
12300|       |	    * xmlSchemaResolveTypeReferences();
12301|       |	    */
12302|      4|            child = child->next;
12303|      4|        }
12304|       |	/*
12305|       |	* Parse attribute decls/refs.
12306|       |	*/
12307|    278|        if (xmlSchemaParseLocalAttributes(ctxt, schema, &child,
  ------------------
  |  Branch (12307:13): [True: 0, False: 278]
  ------------------
12308|    278|	    (xmlSchemaItemListPtr *) &(type->attrUses),
12309|    278|	    XML_SCHEMA_TYPE_RESTRICTION, NULL) == -1)
12310|      0|	    return(NULL);
12311|       |	/*
12312|       |	* Parse attribute wildcard.
12313|       |	*/
12314|    278|	if (IS_SCHEMA(child, "anyAttribute")) {
  ------------------
  |  |  316|    278|   ((node != NULL) && (node->ns != NULL) && \
  |  |  ------------------
  |  |  |  Branch (316:5): [True: 57, False: 221]
  |  |  |  Branch (316:23): [True: 57, False: 0]
  |  |  ------------------
  |  |  317|    278|    (xmlStrEqual(node->name, (const xmlChar *) type)) && \
  |  |  ------------------
  |  |  |  Branch (317:5): [True: 57, False: 0]
  |  |  ------------------
  |  |  318|    278|    (xmlStrEqual(node->ns->href, xmlSchemaNs)))
  |  |  ------------------
  |  |  |  Branch (318:5): [True: 57, False: 0]
  |  |  ------------------
  ------------------
12315|     57|	    type->attributeWildcard = xmlSchemaParseAnyAttribute(ctxt, schema, child);
12316|     57|	    child = child->next;
12317|     57|	}
12318|    278|    }
12319|    380|    if (child != NULL) {
  ------------------
  |  Branch (12319:9): [True: 0, False: 380]
  ------------------
12320|      0|	xmlSchemaPContentErr(ctxt,
12321|      0|	    XML_SCHEMAP_S4S_ELEM_NOT_ALLOWED,
12322|      0|	    NULL, node, child,
12323|      0|	    NULL, "(annotation?, (simpleContent | complexContent | "
12324|      0|	    "((group | all | choice | sequence)?, ((attribute | "
12325|      0|	    "attributeGroup)*, anyAttribute?))))");
12326|      0|    }
12327|       |    /*
12328|       |    * REDEFINE: SPEC src-redefine (5)
12329|       |    */
12330|    380|    if (topLevel && ctxt->isRedefine && (! hasRestrictionOrExtension)) {
  ------------------
  |  Branch (12330:9): [True: 182, False: 198]
  |  Branch (12330:21): [True: 0, False: 182]
  |  Branch (12330:41): [True: 0, False: 0]
  ------------------
12331|      0|	xmlSchemaPCustomErr(ctxt, XML_SCHEMAP_SRC_REDEFINE,
12332|      0|	    NULL, node, "This is a redefinition, thus the "
12333|      0|	    "<complexType> must have a <restriction> or <extension> "
12334|      0|	    "grand-child", NULL);
12335|      0|    }
12336|    380|    ctxt->ctxtType = ctxtType;
12337|    380|    return (type);
12338|    380|}
xmlschemas.c:xmlSchemaAddType:
 5325|    542|{
 5326|    542|    xmlSchemaTypePtr ret = NULL;
 5327|       |
 5328|    542|    if ((ctxt == NULL) || (schema == NULL))
  ------------------
  |  Branch (5328:9): [True: 0, False: 542]
  |  Branch (5328:27): [True: 0, False: 542]
  ------------------
 5329|      0|        return (NULL);
 5330|       |
 5331|    542|    ret = (xmlSchemaTypePtr) xmlMalloc(sizeof(xmlSchemaType));
 5332|    542|    if (ret == NULL) {
  ------------------
  |  Branch (5332:9): [True: 0, False: 542]
  ------------------
 5333|      0|        xmlSchemaPErrMemory(ctxt, "allocating type", NULL);
 5334|      0|        return (NULL);
 5335|      0|    }
 5336|    542|    memset(ret, 0, sizeof(xmlSchemaType));
 5337|    542|    ret->type = type;
 5338|    542|    ret->name = name;
 5339|    542|    ret->targetNamespace = nsName;
 5340|    542|    ret->node = node;
 5341|    542|    if (topLevel) {
  ------------------
  |  Branch (5341:9): [True: 251, False: 291]
  ------------------
 5342|    251|	if (ctxt->isRedefine) {
  ------------------
  |  Branch (5342:6): [True: 0, False: 251]
  ------------------
 5343|      0|	    ctxt->redef = xmlSchemaAddRedef(ctxt, ctxt->redefined,
 5344|      0|		ret, name, nsName);
 5345|      0|	    if (ctxt->redef == NULL) {
  ------------------
  |  Branch (5345:10): [True: 0, False: 0]
  ------------------
 5346|      0|		xmlFree(ret);
 5347|      0|		return(NULL);
 5348|      0|	    }
 5349|      0|	    ctxt->redefCounter = 0;
 5350|      0|	}
 5351|    251|	WXS_ADD_GLOBAL(ctxt, ret);
  ------------------
  |  |  299|    251|    do { \
  |  |  300|    251|        if (xmlSchemaAddItemSize(&(WXS_BUCKET(ctx)->globals), 5, item) < 0) { \
  |  |  ------------------
  |  |  |  |  286|    251|#define WXS_BUCKET(ctx) WXS_CONSTRUCTOR((ctx))->bucket
  |  |  |  |  ------------------
  |  |  |  |  |  |  278|    251|#define WXS_CONSTRUCTOR(ctx) (ctx)->constructor
  |  |  |  |  ------------------
  |  |  ------------------
  |  |  |  Branch (300:13): [True: 0, False: 251]
  |  |  ------------------
  |  |  301|      0|            xmlFree(item); \
  |  |  302|      0|            item = NULL; \
  |  |  303|      0|        } \
  |  |  304|    251|    } while (0)
  |  |  ------------------
  |  |  |  Branch (304:14): [Folded - Ignored]
  |  |  ------------------
  ------------------
 5352|    251|    } else
 5353|    291|	WXS_ADD_LOCAL(ctxt, ret);
  ------------------
  |  |  291|    291|    do { \
  |  |  292|    291|        if (xmlSchemaAddItemSize(&(WXS_BUCKET(ctx)->locals), 10, item) < 0) { \
  |  |  ------------------
  |  |  |  |  286|    291|#define WXS_BUCKET(ctx) WXS_CONSTRUCTOR((ctx))->bucket
  |  |  |  |  ------------------
  |  |  |  |  |  |  278|    291|#define WXS_CONSTRUCTOR(ctx) (ctx)->constructor
  |  |  |  |  ------------------
  |  |  ------------------
  |  |  |  Branch (292:13): [True: 0, False: 291]
  |  |  ------------------
  |  |  293|      0|            xmlFree(item); \
  |  |  294|      0|            item = NULL; \
  |  |  295|      0|        } \
  |  |  296|    291|    } while (0)
  |  |  ------------------
  |  |  |  Branch (296:14): [Folded - Ignored]
  |  |  ------------------
  ------------------
 5354|    542|    WXS_ADD_PENDING(ctxt, ret);
  ------------------
  |  |  307|    542|    xmlSchemaAddItemSize(&((ctx)->constructor->pending), 10, item)
  ------------------
 5355|    542|    return (ret);
 5356|    542|}
xmlschemas.c:xmlSchemaAddItemSize:
 3748|  5.11k|{
 3749|  5.11k|    if (*list == NULL) {
  ------------------
  |  Branch (3749:9): [True: 0, False: 5.11k]
  ------------------
 3750|      0|	*list = xmlSchemaItemListCreate();
 3751|      0|	if (*list == NULL)
  ------------------
  |  Branch (3751:6): [True: 0, False: 0]
  ------------------
 3752|      0|	    return(-1);
 3753|      0|    }
 3754|  5.11k|    return(xmlSchemaItemListAddSize(*list, initialSize, item));
 3755|  5.11k|}
xmlschemas.c:xmlSchemaItemListAddSize:
 3429|  5.39k|{
 3430|  5.39k|    if (list->items == NULL) {
  ------------------
  |  Branch (3430:9): [True: 651, False: 4.74k]
  ------------------
 3431|    651|	if (initialSize <= 0)
  ------------------
  |  Branch (3431:6): [True: 0, False: 651]
  ------------------
 3432|      0|	    initialSize = 1;
 3433|    651|	list->items = (void **) xmlMalloc(
 3434|    651|	    initialSize * sizeof(void *));
 3435|    651|	if (list->items == NULL) {
  ------------------
  |  Branch (3435:6): [True: 0, False: 651]
  ------------------
 3436|      0|	    xmlSchemaPErrMemory(NULL, "allocating new item list", NULL);
 3437|      0|	    return(-1);
 3438|      0|	}
 3439|    651|	list->sizeItems = initialSize;
 3440|  4.74k|    } else if (list->sizeItems <= list->nbItems) {
  ------------------
  |  Branch (3440:16): [True: 250, False: 4.49k]
  ------------------
 3441|    250|        void **tmp;
 3442|       |
 3443|    250|	list->sizeItems *= 2;
 3444|    250|	tmp = (void **) xmlRealloc(list->items,
 3445|    250|	    list->sizeItems * sizeof(void *));
 3446|    250|	if (tmp == NULL) {
  ------------------
  |  Branch (3446:6): [True: 0, False: 250]
  ------------------
 3447|      0|	    xmlSchemaPErrMemory(NULL, "growing item list", NULL);
 3448|      0|	    list->sizeItems /= 2;
 3449|      0|	    return(-1);
 3450|      0|	}
 3451|    250|        list->items = tmp;
 3452|    250|    }
 3453|  5.39k|    list->items[list->nbItems++] = item;
 3454|  5.39k|    return(0);
 3455|  5.39k|}
xmlschemas.c:xmlSchemaPGetBoolNodeValue:
 6106|     13|{
 6107|     13|    xmlChar *value = NULL;
 6108|     13|    int res = 0;
 6109|       |
 6110|     13|    value = xmlNodeGetContent(node);
 6111|       |    /*
 6112|       |    * 3.2.2.1 Lexical representation
 6113|       |    * An instance of a datatype that is defined as `boolean`
 6114|       |    * can have the following legal literals {true, false, 1, 0}.
 6115|       |    */
 6116|     13|    if (xmlStrEqual(BAD_CAST value, BAD_CAST "true"))
  ------------------
  |  |   35|     13|#define BAD_CAST (xmlChar *)
  ------------------
                  if (xmlStrEqual(BAD_CAST value, BAD_CAST "true"))
  ------------------
  |  |   35|     13|#define BAD_CAST (xmlChar *)
  ------------------
  |  Branch (6116:9): [True: 13, False: 0]
  ------------------
 6117|     13|        res = 1;
 6118|      0|    else if (xmlStrEqual(BAD_CAST value, BAD_CAST "false"))
  ------------------
  |  |   35|      0|#define BAD_CAST (xmlChar *)
  ------------------
                  else if (xmlStrEqual(BAD_CAST value, BAD_CAST "false"))
  ------------------
  |  |   35|      0|#define BAD_CAST (xmlChar *)
  ------------------
  |  Branch (6118:14): [True: 0, False: 0]
  ------------------
 6119|      0|        res = 0;
 6120|      0|    else if (xmlStrEqual(BAD_CAST value, BAD_CAST "1"))
  ------------------
  |  |   35|      0|#define BAD_CAST (xmlChar *)
  ------------------
                  else if (xmlStrEqual(BAD_CAST value, BAD_CAST "1"))
  ------------------
  |  |   35|      0|#define BAD_CAST (xmlChar *)
  ------------------
  |  Branch (6120:14): [True: 0, False: 0]
  ------------------
 6121|      0|	res = 1;
 6122|      0|    else if (xmlStrEqual(BAD_CAST value, BAD_CAST "0"))
  ------------------
  |  |   35|      0|#define BAD_CAST (xmlChar *)
  ------------------
                  else if (xmlStrEqual(BAD_CAST value, BAD_CAST "0"))
  ------------------
  |  |   35|      0|#define BAD_CAST (xmlChar *)
  ------------------
  |  Branch (6122:14): [True: 0, False: 0]
  ------------------
 6123|      0|        res = 0;
 6124|      0|    else {
 6125|      0|        xmlSchemaPSimpleTypeErr(ctxt,
 6126|      0|	    XML_SCHEMAP_INVALID_BOOLEAN,
 6127|      0|	    ownerItem, node,
 6128|      0|	    xmlSchemaGetBuiltInType(XML_SCHEMAS_BOOLEAN),
 6129|      0|	    NULL, BAD_CAST value,
  ------------------
  |  |   35|      0|#define BAD_CAST (xmlChar *)
  ------------------
 6130|      0|	    NULL, NULL, NULL);
 6131|      0|    }
 6132|     13|    if (value != NULL)
  ------------------
  |  Branch (6132:9): [True: 13, False: 0]
  ------------------
 6133|     13|	xmlFree(value);
 6134|     13|    return (res);
 6135|     13|}
xmlschemas.c:xmlSchemaParseSimpleContent:
11885|     40|{
11886|     40|    xmlSchemaTypePtr type;
11887|     40|    xmlNodePtr child = NULL;
11888|     40|    xmlAttrPtr attr;
11889|       |
11890|     40|    if ((ctxt == NULL) || (schema == NULL) || (node == NULL) ||
  ------------------
  |  Branch (11890:9): [True: 0, False: 40]
  |  Branch (11890:27): [True: 0, False: 40]
  |  Branch (11890:47): [True: 0, False: 40]
  ------------------
11891|     40|	(hasRestrictionOrExtension == NULL))
  ------------------
  |  Branch (11891:2): [True: 0, False: 40]
  ------------------
11892|      0|        return (-1);
11893|     40|    *hasRestrictionOrExtension = 0;
11894|       |    /* Not a component, don't create it. */
11895|     40|    type = ctxt->ctxtType;
11896|     40|    type->contentType = XML_SCHEMA_CONTENT_SIMPLE;
11897|       |    /*
11898|       |    * Check for illegal attributes.
11899|       |    */
11900|     40|    attr = node->properties;
11901|     40|    while (attr != NULL) {
  ------------------
  |  Branch (11901:12): [True: 0, False: 40]
  ------------------
11902|      0|	if (attr->ns == NULL) {
  ------------------
  |  Branch (11902:6): [True: 0, False: 0]
  ------------------
11903|      0|	    if ((!xmlStrEqual(attr->name, BAD_CAST "id"))) {
  ------------------
  |  |   35|      0|#define BAD_CAST (xmlChar *)
  ------------------
  |  Branch (11903:10): [True: 0, False: 0]
  ------------------
11904|      0|		xmlSchemaPIllegalAttrErr(ctxt,
11905|      0|		    XML_SCHEMAP_S4S_ATTR_NOT_ALLOWED, NULL, attr);
11906|      0|	    }
11907|      0|	} else if (xmlStrEqual(attr->ns->href, xmlSchemaNs)) {
  ------------------
  |  Branch (11907:13): [True: 0, False: 0]
  ------------------
11908|      0|	    xmlSchemaPIllegalAttrErr(ctxt,
11909|      0|		XML_SCHEMAP_S4S_ATTR_NOT_ALLOWED, NULL, attr);
11910|      0|	}
11911|      0|	attr = attr->next;
11912|      0|    }
11913|       |
11914|     40|    xmlSchemaPValAttrID(ctxt, node, BAD_CAST "id");
  ------------------
  |  |   35|     40|#define BAD_CAST (xmlChar *)
  ------------------
11915|       |
11916|       |    /*
11917|       |    * And now for the children...
11918|       |    */
11919|     40|    child = node->children;
11920|     40|    if (IS_SCHEMA(child, "annotation")) {
  ------------------
  |  |  316|     40|   ((node != NULL) && (node->ns != NULL) && \
  |  |  ------------------
  |  |  |  Branch (316:5): [True: 40, False: 0]
  |  |  |  Branch (316:23): [True: 40, False: 0]
  |  |  ------------------
  |  |  317|     40|    (xmlStrEqual(node->name, (const xmlChar *) type)) && \
  |  |  ------------------
  |  |  |  Branch (317:5): [True: 0, False: 40]
  |  |  ------------------
  |  |  318|     40|    (xmlStrEqual(node->ns->href, xmlSchemaNs)))
  |  |  ------------------
  |  |  |  Branch (318:5): [True: 0, False: 0]
  |  |  ------------------
  ------------------
11921|       |	/*
11922|       |	* Add the annotation to the complex type ancestor.
11923|       |	*/
11924|      0|	xmlSchemaAddAnnotation((xmlSchemaAnnotItemPtr) type,
11925|      0|	    xmlSchemaParseAnnotation(ctxt, child, 1));
11926|      0|        child = child->next;
11927|      0|    }
11928|     40|    if (child == NULL) {
  ------------------
  |  Branch (11928:9): [True: 0, False: 40]
  ------------------
11929|      0|	xmlSchemaPContentErr(ctxt,
11930|      0|	    XML_SCHEMAP_S4S_ELEM_MISSING,
11931|      0|	    NULL, node, NULL, NULL,
11932|      0|	    "(annotation?, (restriction | extension))");
11933|      0|    }
11934|     40|    if (child == NULL) {
  ------------------
  |  Branch (11934:9): [True: 0, False: 40]
  ------------------
11935|      0|	xmlSchemaPContentErr(ctxt,
11936|      0|	    XML_SCHEMAP_S4S_ELEM_MISSING,
11937|      0|	    NULL, node, NULL, NULL,
11938|      0|	    "(annotation?, (restriction | extension))");
11939|      0|    }
11940|     40|    if (IS_SCHEMA(child, "restriction")) {
  ------------------
  |  |  316|     40|   ((node != NULL) && (node->ns != NULL) && \
  |  |  ------------------
  |  |  |  Branch (316:5): [True: 40, False: 0]
  |  |  |  Branch (316:23): [True: 40, False: 0]
  |  |  ------------------
  |  |  317|     40|    (xmlStrEqual(node->name, (const xmlChar *) type)) && \
  |  |  ------------------
  |  |  |  Branch (317:5): [True: 8, False: 32]
  |  |  ------------------
  |  |  318|     40|    (xmlStrEqual(node->ns->href, xmlSchemaNs)))
  |  |  ------------------
  |  |  |  Branch (318:5): [True: 8, False: 0]
  |  |  ------------------
  ------------------
11941|      8|        xmlSchemaParseRestriction(ctxt, schema, child,
11942|      8|	    XML_SCHEMA_TYPE_SIMPLE_CONTENT);
11943|      8|	(*hasRestrictionOrExtension) = 1;
11944|      8|        child = child->next;
11945|     32|    } else if (IS_SCHEMA(child, "extension")) {
  ------------------
  |  |  316|     32|   ((node != NULL) && (node->ns != NULL) && \
  |  |  ------------------
  |  |  |  Branch (316:5): [True: 32, False: 0]
  |  |  |  Branch (316:23): [True: 32, False: 0]
  |  |  ------------------
  |  |  317|     32|    (xmlStrEqual(node->name, (const xmlChar *) type)) && \
  |  |  ------------------
  |  |  |  Branch (317:5): [True: 32, False: 0]
  |  |  ------------------
  |  |  318|     32|    (xmlStrEqual(node->ns->href, xmlSchemaNs)))
  |  |  ------------------
  |  |  |  Branch (318:5): [True: 32, False: 0]
  |  |  ------------------
  ------------------
11946|     32|        xmlSchemaParseExtension(ctxt, schema, child,
11947|     32|	    XML_SCHEMA_TYPE_SIMPLE_CONTENT);
11948|     32|	(*hasRestrictionOrExtension) = 1;
11949|     32|        child = child->next;
11950|     32|    }
11951|     40|    if (child != NULL) {
  ------------------
  |  Branch (11951:9): [True: 0, False: 40]
  ------------------
11952|      0|	xmlSchemaPContentErr(ctxt,
11953|      0|	    XML_SCHEMAP_S4S_ELEM_NOT_ALLOWED,
11954|      0|	    NULL, node, child, NULL,
11955|      0|	    "(annotation?, (restriction | extension))");
11956|      0|    }
11957|     40|    return (0);
11958|     40|}
xmlschemas.c:xmlSchemaParseRestriction:
11445|    148|{
11446|    148|    xmlSchemaTypePtr type;
11447|    148|    xmlNodePtr child = NULL;
11448|    148|    xmlAttrPtr attr;
11449|       |
11450|    148|    if ((ctxt == NULL) || (schema == NULL) || (node == NULL))
  ------------------
  |  Branch (11450:9): [True: 0, False: 148]
  |  Branch (11450:27): [True: 0, False: 148]
  |  Branch (11450:47): [True: 0, False: 148]
  ------------------
11451|      0|        return (NULL);
11452|       |    /* Not a component, don't create it. */
11453|    148|    type = ctxt->ctxtType;
11454|    148|    type->flags |= XML_SCHEMAS_TYPE_DERIVATION_METHOD_RESTRICTION;
  ------------------
  |  |  420|    148|#define XML_SCHEMAS_TYPE_DERIVATION_METHOD_RESTRICTION                1 << 2
  ------------------
11455|       |
11456|       |    /*
11457|       |    * Check for illegal attributes.
11458|       |    */
11459|    148|    attr = node->properties;
11460|    287|    while (attr != NULL) {
  ------------------
  |  Branch (11460:12): [True: 139, False: 148]
  ------------------
11461|    139|	if (attr->ns == NULL) {
  ------------------
  |  Branch (11461:6): [True: 139, False: 0]
  ------------------
11462|    139|	    if ((!xmlStrEqual(attr->name, BAD_CAST "id")) &&
  ------------------
  |  |   35|    139|#define BAD_CAST (xmlChar *)
  ------------------
  |  Branch (11462:10): [True: 139, False: 0]
  ------------------
11463|    139|		(!xmlStrEqual(attr->name, BAD_CAST "base"))) {
  ------------------
  |  |   35|    139|#define BAD_CAST (xmlChar *)
  ------------------
  |  Branch (11463:3): [True: 0, False: 139]
  ------------------
11464|      0|		xmlSchemaPIllegalAttrErr(ctxt,
11465|      0|		    XML_SCHEMAP_S4S_ATTR_NOT_ALLOWED, NULL, attr);
11466|      0|	    }
11467|    139|	} else if (xmlStrEqual(attr->ns->href, xmlSchemaNs)) {
  ------------------
  |  Branch (11467:13): [True: 0, False: 0]
  ------------------
11468|      0|	    xmlSchemaPIllegalAttrErr(ctxt,
11469|      0|		XML_SCHEMAP_S4S_ATTR_NOT_ALLOWED, NULL, attr);
11470|      0|	}
11471|    139|	attr = attr->next;
11472|    139|    }
11473|       |    /*
11474|       |    * Extract and validate attributes.
11475|       |    */
11476|    148|    xmlSchemaPValAttrID(ctxt, node, BAD_CAST "id");
  ------------------
  |  |   35|    148|#define BAD_CAST (xmlChar *)
  ------------------
11477|       |    /*
11478|       |    * Attribute
11479|       |    */
11480|       |    /*
11481|       |    * Extract the base type. The "base" attribute is mandatory if inside
11482|       |    * a complex type or if redefining.
11483|       |    *
11484|       |    * SPEC (1.2) "...otherwise (<restriction> has no <simpleType> "
11485|       |    * among its [children]), the simple type definition which is
11486|       |    * the {content type} of the type definition `resolved` to by
11487|       |    * the `actual value` of the base [attribute]"
11488|       |    */
11489|    148|    if (xmlSchemaPValAttrQName(ctxt, schema, NULL, node, "base",
  ------------------
  |  Branch (11489:9): [True: 148, False: 0]
  ------------------
11490|    148|	&(type->baseNs), &(type->base)) == 0)
11491|    148|    {
11492|    148|	if ((type->base == NULL) && (type->type == XML_SCHEMA_TYPE_COMPLEX)) {
  ------------------
  |  Branch (11492:6): [True: 9, False: 139]
  |  Branch (11492:30): [True: 0, False: 9]
  ------------------
11493|      0|	    xmlSchemaPMissingAttrErr(ctxt,
11494|      0|		XML_SCHEMAP_S4S_ATTR_MISSING,
11495|      0|		NULL, node, "base", NULL);
11496|    148|	} else if ((ctxt->isRedefine) &&
  ------------------
  |  Branch (11496:13): [True: 0, False: 148]
  ------------------
11497|    148|	    (type->flags & XML_SCHEMAS_TYPE_GLOBAL))
  ------------------
  |  |  426|      0|#define XML_SCHEMAS_TYPE_GLOBAL                1 << 3
  ------------------
  |  Branch (11497:6): [True: 0, False: 0]
  ------------------
11498|      0|	{
11499|      0|	    if (type->base == NULL) {
  ------------------
  |  Branch (11499:10): [True: 0, False: 0]
  ------------------
11500|      0|		xmlSchemaPMissingAttrErr(ctxt,
11501|      0|		    XML_SCHEMAP_S4S_ATTR_MISSING,
11502|      0|		    NULL, node, "base", NULL);
11503|      0|	    } else if ((! xmlStrEqual(type->base, type->name)) ||
  ------------------
  |  Branch (11503:17): [True: 0, False: 0]
  ------------------
11504|      0|		(! xmlStrEqual(type->baseNs, type->targetNamespace)))
  ------------------
  |  Branch (11504:3): [True: 0, False: 0]
  ------------------
11505|      0|	    {
11506|      0|		xmlChar *str1 = NULL, *str2 = NULL;
11507|       |		/*
11508|       |		* REDEFINE: SPEC src-redefine (5)
11509|       |		* "Within the [children], each <simpleType> must have a
11510|       |		* <restriction> among its [children] ... the `actual value` of
11511|       |		* whose base [attribute] must be the same as the `actual value`
11512|       |		* of its own name attribute plus target namespace;"
11513|       |		*/
11514|      0|		xmlSchemaPCustomErrExt(ctxt, XML_SCHEMAP_SRC_REDEFINE,
11515|      0|		    NULL, node, "This is a redefinition, but the QName "
11516|      0|		    "value '%s' of the 'base' attribute does not match the "
11517|      0|		    "type's designation '%s'",
11518|      0|		    xmlSchemaFormatQName(&str1, type->baseNs, type->base),
11519|      0|		    xmlSchemaFormatQName(&str2, type->targetNamespace,
11520|      0|			type->name), NULL);
11521|      0|		FREE_AND_NULL(str1);
  ------------------
  |  |  320|      0|#define FREE_AND_NULL(str) if ((str) != NULL) { xmlFree((xmlChar *) (str)); str = NULL; }
  |  |  ------------------
  |  |  |  Branch (320:32): [True: 0, False: 0]
  |  |  ------------------
  ------------------
11522|      0|		FREE_AND_NULL(str2);
  ------------------
  |  |  320|      0|#define FREE_AND_NULL(str) if ((str) != NULL) { xmlFree((xmlChar *) (str)); str = NULL; }
  |  |  ------------------
  |  |  |  Branch (320:32): [True: 0, False: 0]
  |  |  ------------------
  ------------------
11523|       |		/* Avoid confusion and erase the values. */
11524|      0|		type->base = NULL;
11525|      0|		type->baseNs = NULL;
11526|      0|	    }
11527|      0|	}
11528|    148|    }
11529|       |    /*
11530|       |    * And now for the children...
11531|       |    */
11532|    148|    child = node->children;
11533|    148|    if (IS_SCHEMA(child, "annotation")) {
  ------------------
  |  |  316|    148|   ((node != NULL) && (node->ns != NULL) && \
  |  |  ------------------
  |  |  |  Branch (316:5): [True: 145, False: 3]
  |  |  |  Branch (316:23): [True: 145, False: 0]
  |  |  ------------------
  |  |  317|    148|    (xmlStrEqual(node->name, (const xmlChar *) type)) && \
  |  |  ------------------
  |  |  |  Branch (317:5): [True: 0, False: 145]
  |  |  ------------------
  |  |  318|    148|    (xmlStrEqual(node->ns->href, xmlSchemaNs)))
  |  |  ------------------
  |  |  |  Branch (318:5): [True: 0, False: 0]
  |  |  ------------------
  ------------------
11534|       |	/*
11535|       |	* Add the annotation to the simple type ancestor.
11536|       |	*/
11537|      0|	xmlSchemaAddAnnotation((xmlSchemaAnnotItemPtr) type,
11538|      0|	    xmlSchemaParseAnnotation(ctxt, child, 1));
11539|      0|        child = child->next;
11540|      0|    }
11541|    148|    if (parentType == XML_SCHEMA_TYPE_SIMPLE) {
  ------------------
  |  Branch (11541:9): [True: 124, False: 24]
  ------------------
11542|       |	/*
11543|       |	* Corresponds to <simpleType><restriction><simpleType>.
11544|       |	*/
11545|    124|	if (IS_SCHEMA(child, "simpleType")) {
  ------------------
  |  |  316|    124|   ((node != NULL) && (node->ns != NULL) && \
  |  |  ------------------
  |  |  |  Branch (316:5): [True: 121, False: 3]
  |  |  |  Branch (316:23): [True: 121, False: 0]
  |  |  ------------------
  |  |  317|    124|    (xmlStrEqual(node->name, (const xmlChar *) type)) && \
  |  |  ------------------
  |  |  |  Branch (317:5): [True: 9, False: 112]
  |  |  ------------------
  |  |  318|    124|    (xmlStrEqual(node->ns->href, xmlSchemaNs)))
  |  |  ------------------
  |  |  |  Branch (318:5): [True: 9, False: 0]
  |  |  ------------------
  ------------------
11546|      9|	    if (type->base != NULL) {
  ------------------
  |  Branch (11546:10): [True: 0, False: 9]
  ------------------
11547|       |		/*
11548|       |		* src-restriction-base-or-simpleType
11549|       |		* Either the base [attribute] or the simpleType [child] of the
11550|       |		* <restriction> element must be present, but not both.
11551|       |		*/
11552|      0|		xmlSchemaPContentErr(ctxt,
11553|      0|		    XML_SCHEMAP_SRC_RESTRICTION_BASE_OR_SIMPLETYPE,
11554|      0|		    NULL, node, child,
11555|      0|		    "The attribute 'base' and the <simpleType> child are "
11556|      0|		    "mutually exclusive", NULL);
11557|      9|	    } else {
11558|      9|		type->baseType = (xmlSchemaTypePtr)
11559|      9|		    xmlSchemaParseSimpleType(ctxt, schema, child, 0);
11560|      9|	    }
11561|      9|	    child = child->next;
11562|    115|	} else if (type->base == NULL) {
  ------------------
  |  Branch (11562:13): [True: 0, False: 115]
  ------------------
11563|      0|	    xmlSchemaPContentErr(ctxt,
11564|      0|		XML_SCHEMAP_SRC_RESTRICTION_BASE_OR_SIMPLETYPE,
11565|      0|		NULL, node, child,
11566|      0|		"Either the attribute 'base' or a <simpleType> child "
11567|      0|		"must be present", NULL);
11568|      0|	}
11569|    124|    } else if (parentType == XML_SCHEMA_TYPE_COMPLEX_CONTENT) {
  ------------------
  |  Branch (11569:16): [True: 16, False: 8]
  ------------------
11570|       |	/*
11571|       |	* Corresponds to <complexType><complexContent><restriction>...
11572|       |	* followed by:
11573|       |	*
11574|       |	* Model groups <all>, <choice> and <sequence>.
11575|       |	*/
11576|     16|	if (IS_SCHEMA(child, "all")) {
  ------------------
  |  |  316|     16|   ((node != NULL) && (node->ns != NULL) && \
  |  |  ------------------
  |  |  |  Branch (316:5): [True: 16, False: 0]
  |  |  |  Branch (316:23): [True: 16, False: 0]
  |  |  ------------------
  |  |  317|     16|    (xmlStrEqual(node->name, (const xmlChar *) type)) && \
  |  |  ------------------
  |  |  |  Branch (317:5): [True: 0, False: 16]
  |  |  ------------------
  |  |  318|     16|    (xmlStrEqual(node->ns->href, xmlSchemaNs)))
  |  |  ------------------
  |  |  |  Branch (318:5): [True: 0, False: 0]
  |  |  ------------------
  ------------------
11577|      0|	    type->subtypes = (xmlSchemaTypePtr)
11578|      0|		xmlSchemaParseModelGroup(ctxt, schema, child,
11579|      0|		    XML_SCHEMA_TYPE_ALL, 1);
11580|      0|	    child = child->next;
11581|     16|	} else if (IS_SCHEMA(child, "choice")) {
  ------------------
  |  |  316|     16|   ((node != NULL) && (node->ns != NULL) && \
  |  |  ------------------
  |  |  |  Branch (316:5): [True: 16, False: 0]
  |  |  |  Branch (316:23): [True: 16, False: 0]
  |  |  ------------------
  |  |  317|     16|    (xmlStrEqual(node->name, (const xmlChar *) type)) && \
  |  |  ------------------
  |  |  |  Branch (317:5): [True: 0, False: 16]
  |  |  ------------------
  |  |  318|     16|    (xmlStrEqual(node->ns->href, xmlSchemaNs)))
  |  |  ------------------
  |  |  |  Branch (318:5): [True: 0, False: 0]
  |  |  ------------------
  ------------------
11582|      0|	    type->subtypes = (xmlSchemaTypePtr)
11583|      0|		xmlSchemaParseModelGroup(ctxt,
11584|      0|		    schema, child, XML_SCHEMA_TYPE_CHOICE, 1);
11585|      0|	    child = child->next;
11586|     16|	} else if (IS_SCHEMA(child, "sequence")) {
  ------------------
  |  |  316|     16|   ((node != NULL) && (node->ns != NULL) && \
  |  |  ------------------
  |  |  |  Branch (316:5): [True: 16, False: 0]
  |  |  |  Branch (316:23): [True: 16, False: 0]
  |  |  ------------------
  |  |  317|     16|    (xmlStrEqual(node->name, (const xmlChar *) type)) && \
  |  |  ------------------
  |  |  |  Branch (317:5): [True: 9, False: 7]
  |  |  ------------------
  |  |  318|     16|    (xmlStrEqual(node->ns->href, xmlSchemaNs)))
  |  |  ------------------
  |  |  |  Branch (318:5): [True: 9, False: 0]
  |  |  ------------------
  ------------------
11587|      9|	    type->subtypes = (xmlSchemaTypePtr)
11588|      9|		xmlSchemaParseModelGroup(ctxt, schema, child,
11589|      9|		    XML_SCHEMA_TYPE_SEQUENCE, 1);
11590|      9|	    child = child->next;
11591|       |	/*
11592|       |	* Model group reference <group>.
11593|       |	*/
11594|      9|	} else if (IS_SCHEMA(child, "group")) {
  ------------------
  |  |  316|      7|   ((node != NULL) && (node->ns != NULL) && \
  |  |  ------------------
  |  |  |  Branch (316:5): [True: 7, False: 0]
  |  |  |  Branch (316:23): [True: 7, False: 0]
  |  |  ------------------
  |  |  317|      7|    (xmlStrEqual(node->name, (const xmlChar *) type)) && \
  |  |  ------------------
  |  |  |  Branch (317:5): [True: 0, False: 7]
  |  |  ------------------
  |  |  318|      7|    (xmlStrEqual(node->ns->href, xmlSchemaNs)))
  |  |  ------------------
  |  |  |  Branch (318:5): [True: 0, False: 0]
  |  |  ------------------
  ------------------
11595|      0|	    type->subtypes = (xmlSchemaTypePtr)
11596|      0|		xmlSchemaParseModelGroupDefRef(ctxt, schema, child);
11597|       |	    /*
11598|       |	    * Note that the reference will be resolved in
11599|       |	    * xmlSchemaResolveTypeReferences();
11600|       |	    */
11601|      0|	    child = child->next;
11602|      0|	}
11603|     16|    } else if (parentType == XML_SCHEMA_TYPE_SIMPLE_CONTENT) {
  ------------------
  |  Branch (11603:16): [True: 8, False: 0]
  ------------------
11604|       |	/*
11605|       |	* Corresponds to <complexType><simpleContent><restriction>...
11606|       |	*
11607|       |	* "1.1 the simple type definition corresponding to the <simpleType>
11608|       |	* among the [children] of <restriction> if there is one;"
11609|       |	*/
11610|      8|	if (IS_SCHEMA(child, "simpleType")) {
  ------------------
  |  |  316|      8|   ((node != NULL) && (node->ns != NULL) && \
  |  |  ------------------
  |  |  |  Branch (316:5): [True: 8, False: 0]
  |  |  |  Branch (316:23): [True: 8, False: 0]
  |  |  ------------------
  |  |  317|      8|    (xmlStrEqual(node->name, (const xmlChar *) type)) && \
  |  |  ------------------
  |  |  |  Branch (317:5): [True: 8, False: 0]
  |  |  ------------------
  |  |  318|      8|    (xmlStrEqual(node->ns->href, xmlSchemaNs)))
  |  |  ------------------
  |  |  |  Branch (318:5): [True: 8, False: 0]
  |  |  ------------------
  ------------------
11611|       |	    /*
11612|       |	    * We will store the to-be-restricted simple type in
11613|       |	    * type->contentTypeDef *temporarily*.
11614|       |	    */
11615|      8|	    type->contentTypeDef = (xmlSchemaTypePtr)
11616|      8|		xmlSchemaParseSimpleType(ctxt, schema, child, 0);
11617|      8|	    if ( type->contentTypeDef == NULL)
  ------------------
  |  Branch (11617:11): [True: 0, False: 8]
  ------------------
11618|      0|		return (NULL);
11619|      8|	    child = child->next;
11620|      8|	}
11621|      8|    }
11622|       |
11623|    148|    if ((parentType == XML_SCHEMA_TYPE_SIMPLE) ||
  ------------------
  |  Branch (11623:9): [True: 124, False: 24]
  ------------------
11624|    148|	(parentType == XML_SCHEMA_TYPE_SIMPLE_CONTENT)) {
  ------------------
  |  Branch (11624:2): [True: 8, False: 16]
  ------------------
11625|    132|	xmlSchemaFacetPtr facet, lastfacet = NULL;
11626|       |	/*
11627|       |	* Corresponds to <complexType><simpleContent><restriction>...
11628|       |	* <simpleType><restriction>...
11629|       |	*/
11630|       |
11631|       |	/*
11632|       |	* Add the facets to the simple type ancestor.
11633|       |	*/
11634|       |	/*
11635|       |	* TODO: Datatypes: 4.1.3 Constraints on XML Representation of
11636|       |	* Simple Type Definition Schema Representation Constraint:
11637|       |	* *Single Facet Value*
11638|       |	*/
11639|    356|	while ((IS_SCHEMA(child, "minInclusive")) ||
  ------------------
  |  |  316|    356|   ((node != NULL) && (node->ns != NULL) && \
  |  |  ------------------
  |  |  |  Branch (316:5): [True: 230, False: 126]
  |  |  |  Branch (316:23): [True: 230, False: 0]
  |  |  ------------------
  |  |  317|    356|    (xmlStrEqual(node->name, (const xmlChar *) type)) && \
  |  |  ------------------
  |  |  |  Branch (317:5): [True: 17, False: 213]
  |  |  ------------------
  |  |  318|    356|    (xmlStrEqual(node->ns->href, xmlSchemaNs)))
  |  |  ------------------
  |  |  |  Branch (318:5): [True: 17, False: 0]
  |  |  ------------------
  ------------------
11640|    356|	    (IS_SCHEMA(child, "minExclusive")) ||
  ------------------
  |  |  316|    339|   ((node != NULL) && (node->ns != NULL) && \
  |  |  ------------------
  |  |  |  Branch (316:5): [True: 213, False: 126]
  |  |  |  Branch (316:23): [True: 213, False: 0]
  |  |  ------------------
  |  |  317|    339|    (xmlStrEqual(node->name, (const xmlChar *) type)) && \
  |  |  ------------------
  |  |  |  Branch (317:5): [True: 9, False: 204]
  |  |  ------------------
  |  |  318|    339|    (xmlStrEqual(node->ns->href, xmlSchemaNs)))
  |  |  ------------------
  |  |  |  Branch (318:5): [True: 9, False: 0]
  |  |  ------------------
  ------------------
11641|    356|	    (IS_SCHEMA(child, "maxInclusive")) ||
  ------------------
  |  |  316|    330|   ((node != NULL) && (node->ns != NULL) && \
  |  |  ------------------
  |  |  |  Branch (316:5): [True: 204, False: 126]
  |  |  |  Branch (316:23): [True: 204, False: 0]
  |  |  ------------------
  |  |  317|    330|    (xmlStrEqual(node->name, (const xmlChar *) type)) && \
  |  |  ------------------
  |  |  |  Branch (317:5): [True: 15, False: 189]
  |  |  ------------------
  |  |  318|    330|    (xmlStrEqual(node->ns->href, xmlSchemaNs)))
  |  |  ------------------
  |  |  |  Branch (318:5): [True: 15, False: 0]
  |  |  ------------------
  ------------------
11642|    356|	    (IS_SCHEMA(child, "maxExclusive")) ||
  ------------------
  |  |  316|    315|   ((node != NULL) && (node->ns != NULL) && \
  |  |  ------------------
  |  |  |  Branch (316:5): [True: 189, False: 126]
  |  |  |  Branch (316:23): [True: 189, False: 0]
  |  |  ------------------
  |  |  317|    315|    (xmlStrEqual(node->name, (const xmlChar *) type)) && \
  |  |  ------------------
  |  |  |  Branch (317:5): [True: 10, False: 179]
  |  |  ------------------
  |  |  318|    315|    (xmlStrEqual(node->ns->href, xmlSchemaNs)))
  |  |  ------------------
  |  |  |  Branch (318:5): [True: 10, False: 0]
  |  |  ------------------
  ------------------
11643|    356|	    (IS_SCHEMA(child, "totalDigits")) ||
  ------------------
  |  |  316|    305|   ((node != NULL) && (node->ns != NULL) && \
  |  |  ------------------
  |  |  |  Branch (316:5): [True: 179, False: 126]
  |  |  |  Branch (316:23): [True: 179, False: 0]
  |  |  ------------------
  |  |  317|    305|    (xmlStrEqual(node->name, (const xmlChar *) type)) && \
  |  |  ------------------
  |  |  |  Branch (317:5): [True: 7, False: 172]
  |  |  ------------------
  |  |  318|    305|    (xmlStrEqual(node->ns->href, xmlSchemaNs)))
  |  |  ------------------
  |  |  |  Branch (318:5): [True: 7, False: 0]
  |  |  ------------------
  ------------------
11644|    356|	    (IS_SCHEMA(child, "fractionDigits")) ||
  ------------------
  |  |  316|    298|   ((node != NULL) && (node->ns != NULL) && \
  |  |  ------------------
  |  |  |  Branch (316:5): [True: 172, False: 126]
  |  |  |  Branch (316:23): [True: 172, False: 0]
  |  |  ------------------
  |  |  317|    298|    (xmlStrEqual(node->name, (const xmlChar *) type)) && \
  |  |  ------------------
  |  |  |  Branch (317:5): [True: 0, False: 172]
  |  |  ------------------
  |  |  318|    298|    (xmlStrEqual(node->ns->href, xmlSchemaNs)))
  |  |  ------------------
  |  |  |  Branch (318:5): [True: 0, False: 0]
  |  |  ------------------
  ------------------
11645|    356|	    (IS_SCHEMA(child, "pattern")) ||
  ------------------
  |  |  316|    298|   ((node != NULL) && (node->ns != NULL) && \
  |  |  ------------------
  |  |  |  Branch (316:5): [True: 172, False: 126]
  |  |  |  Branch (316:23): [True: 172, False: 0]
  |  |  ------------------
  |  |  317|    298|    (xmlStrEqual(node->name, (const xmlChar *) type)) && \
  |  |  ------------------
  |  |  |  Branch (317:5): [True: 26, False: 146]
  |  |  ------------------
  |  |  318|    298|    (xmlStrEqual(node->ns->href, xmlSchemaNs)))
  |  |  ------------------
  |  |  |  Branch (318:5): [True: 26, False: 0]
  |  |  ------------------
  ------------------
11646|    356|	    (IS_SCHEMA(child, "enumeration")) ||
  ------------------
  |  |  316|    272|   ((node != NULL) && (node->ns != NULL) && \
  |  |  ------------------
  |  |  |  Branch (316:5): [True: 146, False: 126]
  |  |  |  Branch (316:23): [True: 146, False: 0]
  |  |  ------------------
  |  |  317|    272|    (xmlStrEqual(node->name, (const xmlChar *) type)) && \
  |  |  ------------------
  |  |  |  Branch (317:5): [True: 115, False: 31]
  |  |  ------------------
  |  |  318|    272|    (xmlStrEqual(node->ns->href, xmlSchemaNs)))
  |  |  ------------------
  |  |  |  Branch (318:5): [True: 115, False: 0]
  |  |  ------------------
  ------------------
11647|    356|	    (IS_SCHEMA(child, "whiteSpace")) ||
  ------------------
  |  |  316|    157|   ((node != NULL) && (node->ns != NULL) && \
  |  |  ------------------
  |  |  |  Branch (316:5): [True: 31, False: 126]
  |  |  |  Branch (316:23): [True: 31, False: 0]
  |  |  ------------------
  |  |  317|    157|    (xmlStrEqual(node->name, (const xmlChar *) type)) && \
  |  |  ------------------
  |  |  |  Branch (317:5): [True: 2, False: 29]
  |  |  ------------------
  |  |  318|    157|    (xmlStrEqual(node->ns->href, xmlSchemaNs)))
  |  |  ------------------
  |  |  |  Branch (318:5): [True: 2, False: 0]
  |  |  ------------------
  ------------------
11648|    356|	    (IS_SCHEMA(child, "length")) ||
  ------------------
  |  |  316|    155|   ((node != NULL) && (node->ns != NULL) && \
  |  |  ------------------
  |  |  |  Branch (316:5): [True: 29, False: 126]
  |  |  |  Branch (316:23): [True: 29, False: 0]
  |  |  ------------------
  |  |  317|    155|    (xmlStrEqual(node->name, (const xmlChar *) type)) && \
  |  |  ------------------
  |  |  |  Branch (317:5): [True: 3, False: 26]
  |  |  ------------------
  |  |  318|    155|    (xmlStrEqual(node->ns->href, xmlSchemaNs)))
  |  |  ------------------
  |  |  |  Branch (318:5): [True: 3, False: 0]
  |  |  ------------------
  ------------------
11649|    356|	    (IS_SCHEMA(child, "maxLength")) ||
  ------------------
  |  |  316|    152|   ((node != NULL) && (node->ns != NULL) && \
  |  |  ------------------
  |  |  |  Branch (316:5): [True: 26, False: 126]
  |  |  |  Branch (316:23): [True: 26, False: 0]
  |  |  ------------------
  |  |  317|    152|    (xmlStrEqual(node->name, (const xmlChar *) type)) && \
  |  |  ------------------
  |  |  |  Branch (317:5): [True: 13, False: 13]
  |  |  ------------------
  |  |  318|    152|    (xmlStrEqual(node->ns->href, xmlSchemaNs)))
  |  |  ------------------
  |  |  |  Branch (318:5): [True: 13, False: 0]
  |  |  ------------------
  ------------------
11650|    356|	    (IS_SCHEMA(child, "minLength"))) {
  ------------------
  |  |  316|    139|   ((node != NULL) && (node->ns != NULL) && \
  |  |  ------------------
  |  |  |  Branch (316:5): [True: 13, False: 126]
  |  |  |  Branch (316:23): [True: 13, False: 0]
  |  |  ------------------
  |  |  317|    139|    (xmlStrEqual(node->name, (const xmlChar *) type)) && \
  |  |  ------------------
  |  |  |  Branch (317:5): [True: 7, False: 6]
  |  |  ------------------
  |  |  318|    139|    (xmlStrEqual(node->ns->href, xmlSchemaNs)))
  |  |  ------------------
  |  |  |  Branch (318:5): [True: 7, False: 0]
  |  |  ------------------
  ------------------
11651|    224|	    facet = xmlSchemaParseFacet(ctxt, schema, child);
11652|    224|	    if (facet != NULL) {
  ------------------
  |  Branch (11652:10): [True: 224, False: 0]
  ------------------
11653|    224|		if (lastfacet == NULL)
  ------------------
  |  Branch (11653:7): [True: 120, False: 104]
  ------------------
11654|    120|		    type->facets = facet;
11655|    104|		else
11656|    104|		    lastfacet->next = facet;
11657|    224|		lastfacet = facet;
11658|    224|		lastfacet->next = NULL;
11659|    224|	    }
11660|    224|	    child = child->next;
11661|    224|	}
11662|       |	/*
11663|       |	* Create links for derivation and validation.
11664|       |	*/
11665|    132|	if (type->facets != NULL) {
  ------------------
  |  Branch (11665:6): [True: 120, False: 12]
  ------------------
11666|    120|	    xmlSchemaFacetLinkPtr facetLink, lastFacetLink = NULL;
11667|       |
11668|    120|	    facet = type->facets;
11669|    224|	    do {
11670|    224|		facetLink = (xmlSchemaFacetLinkPtr)
11671|    224|		    xmlMalloc(sizeof(xmlSchemaFacetLink));
11672|    224|		if (facetLink == NULL) {
  ------------------
  |  Branch (11672:7): [True: 0, False: 224]
  ------------------
11673|      0|		    xmlSchemaPErrMemory(ctxt, "allocating a facet link", NULL);
11674|      0|		    xmlFree(facetLink);
11675|      0|		    return (NULL);
11676|      0|		}
11677|    224|		facetLink->facet = facet;
11678|    224|		facetLink->next = NULL;
11679|    224|		if (lastFacetLink == NULL)
  ------------------
  |  Branch (11679:7): [True: 120, False: 104]
  ------------------
11680|    120|		    type->facetSet = facetLink;
11681|    104|		else
11682|    104|		    lastFacetLink->next = facetLink;
11683|    224|		lastFacetLink = facetLink;
11684|    224|		facet = facet->next;
11685|    224|	    } while (facet != NULL);
  ------------------
  |  Branch (11685:15): [True: 104, False: 120]
  ------------------
11686|    120|	}
11687|    132|    }
11688|    148|    if (type->type == XML_SCHEMA_TYPE_COMPLEX) {
  ------------------
  |  Branch (11688:9): [True: 24, False: 124]
  ------------------
11689|       |	/*
11690|       |	* Attribute uses/declarations.
11691|       |	*/
11692|     24|	if (xmlSchemaParseLocalAttributes(ctxt, schema, &child,
  ------------------
  |  Branch (11692:6): [True: 0, False: 24]
  ------------------
11693|     24|	    (xmlSchemaItemListPtr *) &(type->attrUses),
11694|     24|	    XML_SCHEMA_TYPE_RESTRICTION, NULL) == -1)
11695|      0|	    return(NULL);
11696|       |	/*
11697|       |	* Attribute wildcard.
11698|       |	*/
11699|     24|	if (IS_SCHEMA(child, "anyAttribute")) {
  ------------------
  |  |  316|     24|   ((node != NULL) && (node->ns != NULL) && \
  |  |  ------------------
  |  |  |  Branch (316:5): [True: 3, False: 21]
  |  |  |  Branch (316:23): [True: 3, False: 0]
  |  |  ------------------
  |  |  317|     24|    (xmlStrEqual(node->name, (const xmlChar *) type)) && \
  |  |  ------------------
  |  |  |  Branch (317:5): [True: 3, False: 0]
  |  |  ------------------
  |  |  318|     24|    (xmlStrEqual(node->ns->href, xmlSchemaNs)))
  |  |  ------------------
  |  |  |  Branch (318:5): [True: 3, False: 0]
  |  |  ------------------
  ------------------
11700|      3|	    type->attributeWildcard =
11701|      3|		xmlSchemaParseAnyAttribute(ctxt, schema, child);
11702|      3|	    child = child->next;
11703|      3|	}
11704|     24|    }
11705|    148|    if (child != NULL) {
  ------------------
  |  Branch (11705:9): [True: 0, False: 148]
  ------------------
11706|      0|	if (parentType == XML_SCHEMA_TYPE_COMPLEX_CONTENT) {
  ------------------
  |  Branch (11706:6): [True: 0, False: 0]
  ------------------
11707|      0|	    xmlSchemaPContentErr(ctxt,
11708|      0|		XML_SCHEMAP_S4S_ELEM_NOT_ALLOWED,
11709|      0|		NULL, node, child, NULL,
11710|      0|		"annotation?, (group | all | choice | sequence)?, "
11711|      0|		"((attribute | attributeGroup)*, anyAttribute?))");
11712|      0|	} else if (parentType == XML_SCHEMA_TYPE_SIMPLE_CONTENT) {
  ------------------
  |  Branch (11712:13): [True: 0, False: 0]
  ------------------
11713|      0|	     xmlSchemaPContentErr(ctxt,
11714|      0|		XML_SCHEMAP_S4S_ELEM_NOT_ALLOWED,
11715|      0|		NULL, node, child, NULL,
11716|      0|		"(annotation?, (simpleType?, (minExclusive | minInclusive | "
11717|      0|		"maxExclusive | maxInclusive | totalDigits | fractionDigits | "
11718|      0|		"length | minLength | maxLength | enumeration | whiteSpace | "
11719|      0|		"pattern)*)?, ((attribute | attributeGroup)*, anyAttribute?))");
11720|      0|	} else {
11721|       |	    /* Simple type */
11722|      0|	    xmlSchemaPContentErr(ctxt,
11723|      0|		XML_SCHEMAP_S4S_ELEM_NOT_ALLOWED,
11724|      0|		NULL, node, child, NULL,
11725|      0|		"(annotation?, (simpleType?, (minExclusive | minInclusive | "
11726|      0|		"maxExclusive | maxInclusive | totalDigits | fractionDigits | "
11727|      0|		"length | minLength | maxLength | enumeration | whiteSpace | "
11728|      0|		"pattern)*))");
11729|      0|	}
11730|      0|    }
11731|    148|    return (NULL);
11732|    148|}
xmlschemas.c:xmlSchemaPValAttrQName:
 5862|    587|{
 5863|    587|    xmlAttrPtr attr;
 5864|       |
 5865|    587|    attr = xmlSchemaGetPropNode(ownerElem, name);
 5866|    587|    if (attr == NULL) {
  ------------------
  |  Branch (5866:9): [True: 305, False: 282]
  ------------------
 5867|    305|	*local = NULL;
 5868|    305|	*uri = NULL;
 5869|    305|	return (0);
 5870|    305|    }
 5871|    282|    return (xmlSchemaPValAttrNodeQName(ctxt, schema,
 5872|    282|	ownerItem, attr, uri, local));
 5873|    587|}
xmlschemas.c:xmlSchemaPValAttrNodeQName:
 5831|  1.02k|{
 5832|  1.02k|    const xmlChar *value;
 5833|       |
 5834|  1.02k|    value = xmlSchemaGetNodeContent(ctxt, (xmlNodePtr) attr);
 5835|  1.02k|    return (xmlSchemaPValAttrNodeQNameValue(ctxt, schema,
 5836|  1.02k|	ownerItem, attr, value, uri, local));
 5837|  1.02k|}
xmlschemas.c:xmlSchemaPValAttrNodeQNameValue:
 5752|  1.07k|{
 5753|  1.07k|    const xmlChar *pref;
 5754|  1.07k|    xmlNsPtr ns;
 5755|  1.07k|    int len, ret;
 5756|       |
 5757|  1.07k|    *uri = NULL;
 5758|  1.07k|    *local = NULL;
 5759|  1.07k|    ret = xmlValidateQName(value, 1);
 5760|  1.07k|    if (ret > 0) {
  ------------------
  |  Branch (5760:9): [True: 0, False: 1.07k]
  ------------------
 5761|      0|	xmlSchemaPSimpleTypeErr(ctxt,
 5762|      0|	    XML_SCHEMAP_S4S_ATTR_INVALID_VALUE,
 5763|      0|	    ownerItem, (xmlNodePtr) attr,
 5764|      0|	    xmlSchemaGetBuiltInType(XML_SCHEMAS_QNAME),
 5765|      0|	    NULL, value, NULL, NULL, NULL);
 5766|      0|	*local = value;
 5767|      0|	return (ctxt->err);
 5768|  1.07k|    } else if (ret < 0)
  ------------------
  |  Branch (5768:16): [True: 0, False: 1.07k]
  ------------------
 5769|      0|	return (-1);
 5770|       |
 5771|  1.07k|    if (!strchr((char *) value, ':')) {
  ------------------
  |  Branch (5771:9): [True: 426, False: 646]
  ------------------
 5772|    426|	ns = xmlSearchNs(attr->doc, attr->parent, NULL);
 5773|    426|	if (ns && ns->href && ns->href[0])
  ------------------
  |  Branch (5773:6): [True: 87, False: 339]
  |  Branch (5773:12): [True: 87, False: 0]
  |  Branch (5773:24): [True: 86, False: 1]
  ------------------
 5774|     86|	    *uri = xmlDictLookup(ctxt->dict, ns->href, -1);
 5775|    340|	else if (schema->flags & XML_SCHEMAS_INCLUDING_CONVERT_NS) {
  ------------------
  |  |  917|    340|#define XML_SCHEMAS_INCLUDING_CONVERT_NS            1 << 9
  ------------------
  |  Branch (5775:11): [True: 3, False: 337]
  ------------------
 5776|       |	    /* TODO: move XML_SCHEMAS_INCLUDING_CONVERT_NS to the
 5777|       |	    * parser context. */
 5778|       |	    /*
 5779|       |	    * This one takes care of included schemas with no
 5780|       |	    * target namespace.
 5781|       |	    */
 5782|      3|	    *uri = ctxt->targetNamespace;
 5783|      3|	}
 5784|    426|	*local = xmlDictLookup(ctxt->dict, value, -1);
 5785|    426|	return (0);
 5786|    426|    }
 5787|       |    /*
 5788|       |    * At this point xmlSplitQName3 has to return a local name.
 5789|       |    */
 5790|    646|    *local = xmlSplitQName3(value, &len);
 5791|    646|    *local = xmlDictLookup(ctxt->dict, *local, -1);
 5792|    646|    pref = xmlDictLookup(ctxt->dict, value, len);
 5793|    646|    ns = xmlSearchNs(attr->doc, attr->parent, pref);
 5794|    646|    if (ns == NULL) {
  ------------------
  |  Branch (5794:9): [True: 0, False: 646]
  ------------------
 5795|      0|	xmlSchemaPSimpleTypeErr(ctxt,
 5796|      0|	    XML_SCHEMAP_S4S_ATTR_INVALID_VALUE,
 5797|      0|	    ownerItem, (xmlNodePtr) attr,
 5798|      0|	    xmlSchemaGetBuiltInType(XML_SCHEMAS_QNAME), NULL, value,
 5799|      0|	    "The value '%s' of simple type 'xs:QName' has no "
 5800|      0|	    "corresponding namespace declaration in scope", value, NULL);
 5801|      0|	return (ctxt->err);
 5802|    646|    } else {
 5803|    646|        *uri = xmlDictLookup(ctxt->dict, ns->href, -1);
 5804|    646|    }
 5805|    646|    return (0);
 5806|    646|}
xmlschemas.c:xmlSchemaParseFacet:
 6600|    224|{
 6601|    224|    xmlSchemaFacetPtr facet;
 6602|    224|    xmlNodePtr child = NULL;
 6603|    224|    const xmlChar *value;
 6604|       |
 6605|    224|    if ((ctxt == NULL) || (schema == NULL) || (node == NULL))
  ------------------
  |  Branch (6605:9): [True: 0, False: 224]
  |  Branch (6605:27): [True: 0, False: 224]
  |  Branch (6605:47): [True: 0, False: 224]
  ------------------
 6606|      0|        return (NULL);
 6607|       |
 6608|    224|    facet = xmlSchemaNewFacet();
 6609|    224|    if (facet == NULL) {
  ------------------
  |  Branch (6609:9): [True: 0, False: 224]
  ------------------
 6610|      0|        xmlSchemaPErrMemory(ctxt, "allocating facet", node);
 6611|      0|        return (NULL);
 6612|      0|    }
 6613|    224|    facet->node = node;
 6614|    224|    value = xmlSchemaGetProp(ctxt, node, "value");
 6615|    224|    if (value == NULL) {
  ------------------
  |  Branch (6615:9): [True: 0, False: 224]
  ------------------
 6616|      0|        xmlSchemaPErr2(ctxt, node, child, XML_SCHEMAP_FACET_NO_VALUE,
 6617|      0|                       "Facet %s has no value\n", node->name, NULL);
 6618|      0|        xmlSchemaFreeFacet(facet);
 6619|      0|        return (NULL);
 6620|      0|    }
 6621|    224|    if (IS_SCHEMA(node, "minInclusive")) {
  ------------------
  |  |  316|    224|   ((node != NULL) && (node->ns != NULL) && \
  |  |  ------------------
  |  |  |  Branch (316:5): [True: 224, False: 0]
  |  |  |  Branch (316:23): [True: 224, False: 0]
  |  |  ------------------
  |  |  317|    224|    (xmlStrEqual(node->name, (const xmlChar *) type)) && \
  |  |  ------------------
  |  |  |  Branch (317:5): [True: 17, False: 207]
  |  |  ------------------
  |  |  318|    224|    (xmlStrEqual(node->ns->href, xmlSchemaNs)))
  |  |  ------------------
  |  |  |  Branch (318:5): [True: 17, False: 0]
  |  |  ------------------
  ------------------
 6622|     17|        facet->type = XML_SCHEMA_FACET_MININCLUSIVE;
 6623|    207|    } else if (IS_SCHEMA(node, "minExclusive")) {
  ------------------
  |  |  316|    207|   ((node != NULL) && (node->ns != NULL) && \
  |  |  ------------------
  |  |  |  Branch (316:5): [True: 207, False: 0]
  |  |  |  Branch (316:23): [True: 207, False: 0]
  |  |  ------------------
  |  |  317|    207|    (xmlStrEqual(node->name, (const xmlChar *) type)) && \
  |  |  ------------------
  |  |  |  Branch (317:5): [True: 9, False: 198]
  |  |  ------------------
  |  |  318|    207|    (xmlStrEqual(node->ns->href, xmlSchemaNs)))
  |  |  ------------------
  |  |  |  Branch (318:5): [True: 9, False: 0]
  |  |  ------------------
  ------------------
 6624|      9|        facet->type = XML_SCHEMA_FACET_MINEXCLUSIVE;
 6625|    198|    } else if (IS_SCHEMA(node, "maxInclusive")) {
  ------------------
  |  |  316|    198|   ((node != NULL) && (node->ns != NULL) && \
  |  |  ------------------
  |  |  |  Branch (316:5): [True: 198, False: 0]
  |  |  |  Branch (316:23): [True: 198, False: 0]
  |  |  ------------------
  |  |  317|    198|    (xmlStrEqual(node->name, (const xmlChar *) type)) && \
  |  |  ------------------
  |  |  |  Branch (317:5): [True: 15, False: 183]
  |  |  ------------------
  |  |  318|    198|    (xmlStrEqual(node->ns->href, xmlSchemaNs)))
  |  |  ------------------
  |  |  |  Branch (318:5): [True: 15, False: 0]
  |  |  ------------------
  ------------------
 6626|     15|        facet->type = XML_SCHEMA_FACET_MAXINCLUSIVE;
 6627|    183|    } else if (IS_SCHEMA(node, "maxExclusive")) {
  ------------------
  |  |  316|    183|   ((node != NULL) && (node->ns != NULL) && \
  |  |  ------------------
  |  |  |  Branch (316:5): [True: 183, False: 0]
  |  |  |  Branch (316:23): [True: 183, False: 0]
  |  |  ------------------
  |  |  317|    183|    (xmlStrEqual(node->name, (const xmlChar *) type)) && \
  |  |  ------------------
  |  |  |  Branch (317:5): [True: 10, False: 173]
  |  |  ------------------
  |  |  318|    183|    (xmlStrEqual(node->ns->href, xmlSchemaNs)))
  |  |  ------------------
  |  |  |  Branch (318:5): [True: 10, False: 0]
  |  |  ------------------
  ------------------
 6628|     10|        facet->type = XML_SCHEMA_FACET_MAXEXCLUSIVE;
 6629|    173|    } else if (IS_SCHEMA(node, "totalDigits")) {
  ------------------
  |  |  316|    173|   ((node != NULL) && (node->ns != NULL) && \
  |  |  ------------------
  |  |  |  Branch (316:5): [True: 173, False: 0]
  |  |  |  Branch (316:23): [True: 173, False: 0]
  |  |  ------------------
  |  |  317|    173|    (xmlStrEqual(node->name, (const xmlChar *) type)) && \
  |  |  ------------------
  |  |  |  Branch (317:5): [True: 7, False: 166]
  |  |  ------------------
  |  |  318|    173|    (xmlStrEqual(node->ns->href, xmlSchemaNs)))
  |  |  ------------------
  |  |  |  Branch (318:5): [True: 7, False: 0]
  |  |  ------------------
  ------------------
 6630|      7|        facet->type = XML_SCHEMA_FACET_TOTALDIGITS;
 6631|    166|    } else if (IS_SCHEMA(node, "fractionDigits")) {
  ------------------
  |  |  316|    166|   ((node != NULL) && (node->ns != NULL) && \
  |  |  ------------------
  |  |  |  Branch (316:5): [True: 166, False: 0]
  |  |  |  Branch (316:23): [True: 166, False: 0]
  |  |  ------------------
  |  |  317|    166|    (xmlStrEqual(node->name, (const xmlChar *) type)) && \
  |  |  ------------------
  |  |  |  Branch (317:5): [True: 0, False: 166]
  |  |  ------------------
  |  |  318|    166|    (xmlStrEqual(node->ns->href, xmlSchemaNs)))
  |  |  ------------------
  |  |  |  Branch (318:5): [True: 0, False: 0]
  |  |  ------------------
  ------------------
 6632|      0|        facet->type = XML_SCHEMA_FACET_FRACTIONDIGITS;
 6633|    166|    } else if (IS_SCHEMA(node, "pattern")) {
  ------------------
  |  |  316|    166|   ((node != NULL) && (node->ns != NULL) && \
  |  |  ------------------
  |  |  |  Branch (316:5): [True: 166, False: 0]
  |  |  |  Branch (316:23): [True: 166, False: 0]
  |  |  ------------------
  |  |  317|    166|    (xmlStrEqual(node->name, (const xmlChar *) type)) && \
  |  |  ------------------
  |  |  |  Branch (317:5): [True: 26, False: 140]
  |  |  ------------------
  |  |  318|    166|    (xmlStrEqual(node->ns->href, xmlSchemaNs)))
  |  |  ------------------
  |  |  |  Branch (318:5): [True: 26, False: 0]
  |  |  ------------------
  ------------------
 6634|     26|        facet->type = XML_SCHEMA_FACET_PATTERN;
 6635|    140|    } else if (IS_SCHEMA(node, "enumeration")) {
  ------------------
  |  |  316|    140|   ((node != NULL) && (node->ns != NULL) && \
  |  |  ------------------
  |  |  |  Branch (316:5): [True: 140, False: 0]
  |  |  |  Branch (316:23): [True: 140, False: 0]
  |  |  ------------------
  |  |  317|    140|    (xmlStrEqual(node->name, (const xmlChar *) type)) && \
  |  |  ------------------
  |  |  |  Branch (317:5): [True: 115, False: 25]
  |  |  ------------------
  |  |  318|    140|    (xmlStrEqual(node->ns->href, xmlSchemaNs)))
  |  |  ------------------
  |  |  |  Branch (318:5): [True: 115, False: 0]
  |  |  ------------------
  ------------------
 6636|    115|        facet->type = XML_SCHEMA_FACET_ENUMERATION;
 6637|    115|    } else if (IS_SCHEMA(node, "whiteSpace")) {
  ------------------
  |  |  316|     25|   ((node != NULL) && (node->ns != NULL) && \
  |  |  ------------------
  |  |  |  Branch (316:5): [True: 25, False: 0]
  |  |  |  Branch (316:23): [True: 25, False: 0]
  |  |  ------------------
  |  |  317|     25|    (xmlStrEqual(node->name, (const xmlChar *) type)) && \
  |  |  ------------------
  |  |  |  Branch (317:5): [True: 2, False: 23]
  |  |  ------------------
  |  |  318|     25|    (xmlStrEqual(node->ns->href, xmlSchemaNs)))
  |  |  ------------------
  |  |  |  Branch (318:5): [True: 2, False: 0]
  |  |  ------------------
  ------------------
 6638|      2|        facet->type = XML_SCHEMA_FACET_WHITESPACE;
 6639|     23|    } else if (IS_SCHEMA(node, "length")) {
  ------------------
  |  |  316|     23|   ((node != NULL) && (node->ns != NULL) && \
  |  |  ------------------
  |  |  |  Branch (316:5): [True: 23, False: 0]
  |  |  |  Branch (316:23): [True: 23, False: 0]
  |  |  ------------------
  |  |  317|     23|    (xmlStrEqual(node->name, (const xmlChar *) type)) && \
  |  |  ------------------
  |  |  |  Branch (317:5): [True: 3, False: 20]
  |  |  ------------------
  |  |  318|     23|    (xmlStrEqual(node->ns->href, xmlSchemaNs)))
  |  |  ------------------
  |  |  |  Branch (318:5): [True: 3, False: 0]
  |  |  ------------------
  ------------------
 6640|      3|        facet->type = XML_SCHEMA_FACET_LENGTH;
 6641|     20|    } else if (IS_SCHEMA(node, "maxLength")) {
  ------------------
  |  |  316|     20|   ((node != NULL) && (node->ns != NULL) && \
  |  |  ------------------
  |  |  |  Branch (316:5): [True: 20, False: 0]
  |  |  |  Branch (316:23): [True: 20, False: 0]
  |  |  ------------------
  |  |  317|     20|    (xmlStrEqual(node->name, (const xmlChar *) type)) && \
  |  |  ------------------
  |  |  |  Branch (317:5): [True: 13, False: 7]
  |  |  ------------------
  |  |  318|     20|    (xmlStrEqual(node->ns->href, xmlSchemaNs)))
  |  |  ------------------
  |  |  |  Branch (318:5): [True: 13, False: 0]
  |  |  ------------------
  ------------------
 6642|     13|        facet->type = XML_SCHEMA_FACET_MAXLENGTH;
 6643|     13|    } else if (IS_SCHEMA(node, "minLength")) {
  ------------------
  |  |  316|      7|   ((node != NULL) && (node->ns != NULL) && \
  |  |  ------------------
  |  |  |  Branch (316:5): [True: 7, False: 0]
  |  |  |  Branch (316:23): [True: 7, False: 0]
  |  |  ------------------
  |  |  317|      7|    (xmlStrEqual(node->name, (const xmlChar *) type)) && \
  |  |  ------------------
  |  |  |  Branch (317:5): [True: 7, False: 0]
  |  |  ------------------
  |  |  318|      7|    (xmlStrEqual(node->ns->href, xmlSchemaNs)))
  |  |  ------------------
  |  |  |  Branch (318:5): [True: 7, False: 0]
  |  |  ------------------
  ------------------
 6644|      7|        facet->type = XML_SCHEMA_FACET_MINLENGTH;
 6645|      7|    } else {
 6646|      0|        xmlSchemaPErr2(ctxt, node, child, XML_SCHEMAP_UNKNOWN_FACET_TYPE,
 6647|      0|                       "Unknown facet type %s\n", node->name, NULL);
 6648|      0|        xmlSchemaFreeFacet(facet);
 6649|      0|        return (NULL);
 6650|      0|    }
 6651|    224|    xmlSchemaPValAttrID(ctxt, node, BAD_CAST "id");
  ------------------
  |  |   35|    224|#define BAD_CAST (xmlChar *)
  ------------------
 6652|    224|    facet->value = value;
 6653|    224|    if ((facet->type != XML_SCHEMA_FACET_PATTERN) &&
  ------------------
  |  Branch (6653:9): [True: 198, False: 26]
  ------------------
 6654|    224|	(facet->type != XML_SCHEMA_FACET_ENUMERATION)) {
  ------------------
  |  Branch (6654:2): [True: 83, False: 115]
  ------------------
 6655|     83|	const xmlChar *fixed;
 6656|       |
 6657|     83|	fixed = xmlSchemaGetProp(ctxt, node, "fixed");
 6658|     83|	if (fixed != NULL) {
  ------------------
  |  Branch (6658:6): [True: 2, False: 81]
  ------------------
 6659|      2|	    if (xmlStrEqual(fixed, BAD_CAST "true"))
  ------------------
  |  |   35|      2|#define BAD_CAST (xmlChar *)
  ------------------
  |  Branch (6659:10): [True: 2, False: 0]
  ------------------
 6660|      2|		facet->fixed = 1;
 6661|      2|	}
 6662|     83|    }
 6663|    224|    child = node->children;
 6664|       |
 6665|    224|    if (IS_SCHEMA(child, "annotation")) {
  ------------------
  |  |  316|    224|   ((node != NULL) && (node->ns != NULL) && \
  |  |  ------------------
  |  |  |  Branch (316:5): [True: 3, False: 221]
  |  |  |  Branch (316:23): [True: 3, False: 0]
  |  |  ------------------
  |  |  317|    224|    (xmlStrEqual(node->name, (const xmlChar *) type)) && \
  |  |  ------------------
  |  |  |  Branch (317:5): [True: 3, False: 0]
  |  |  ------------------
  |  |  318|    224|    (xmlStrEqual(node->ns->href, xmlSchemaNs)))
  |  |  ------------------
  |  |  |  Branch (318:5): [True: 3, False: 0]
  |  |  ------------------
  ------------------
 6666|      3|        facet->annot = xmlSchemaParseAnnotation(ctxt, child, 1);
 6667|      3|        child = child->next;
 6668|      3|    }
 6669|    224|    if (child != NULL) {
  ------------------
  |  Branch (6669:9): [True: 0, False: 224]
  ------------------
 6670|      0|        xmlSchemaPErr2(ctxt, node, child, XML_SCHEMAP_UNKNOWN_FACET_CHILD,
 6671|      0|                       "Facet %s has unexpected child content\n",
 6672|      0|                       node->name, NULL);
 6673|      0|    }
 6674|    224|    return (facet);
 6675|    224|}
xmlschemas.c:xmlSchemaPErr2:
 1982|     12|{
 1983|     12|    if (child != NULL)
  ------------------
  |  Branch (1983:9): [True: 12, False: 0]
  ------------------
 1984|     12|        xmlSchemaPErr(ctxt, child, error, msg, str1, str2);
 1985|      0|    else
 1986|      0|        xmlSchemaPErr(ctxt, node, error, msg, str1, str2);
 1987|     12|}
xmlschemas.c:xmlSchemaParseExtension:
11749|     78|{
11750|     78|    xmlSchemaTypePtr type;
11751|     78|    xmlNodePtr child = NULL;
11752|     78|    xmlAttrPtr attr;
11753|       |
11754|     78|    if ((ctxt == NULL) || (schema == NULL) || (node == NULL))
  ------------------
  |  Branch (11754:9): [True: 0, False: 78]
  |  Branch (11754:27): [True: 0, False: 78]
  |  Branch (11754:47): [True: 0, False: 78]
  ------------------
11755|      0|        return (NULL);
11756|       |    /* Not a component, don't create it. */
11757|     78|    type = ctxt->ctxtType;
11758|     78|    type->flags |= XML_SCHEMAS_TYPE_DERIVATION_METHOD_EXTENSION;
  ------------------
  |  |  414|     78|#define XML_SCHEMAS_TYPE_DERIVATION_METHOD_EXTENSION                1 << 1
  ------------------
11759|       |
11760|       |    /*
11761|       |    * Check for illegal attributes.
11762|       |    */
11763|     78|    attr = node->properties;
11764|    156|    while (attr != NULL) {
  ------------------
  |  Branch (11764:12): [True: 78, False: 78]
  ------------------
11765|     78|	if (attr->ns == NULL) {
  ------------------
  |  Branch (11765:6): [True: 78, False: 0]
  ------------------
11766|     78|	    if ((!xmlStrEqual(attr->name, BAD_CAST "id")) &&
  ------------------
  |  |   35|     78|#define BAD_CAST (xmlChar *)
  ------------------
  |  Branch (11766:10): [True: 78, False: 0]
  ------------------
11767|     78|		(!xmlStrEqual(attr->name, BAD_CAST "base"))) {
  ------------------
  |  |   35|     78|#define BAD_CAST (xmlChar *)
  ------------------
  |  Branch (11767:3): [True: 0, False: 78]
  ------------------
11768|      0|		xmlSchemaPIllegalAttrErr(ctxt,
11769|      0|		    XML_SCHEMAP_S4S_ATTR_NOT_ALLOWED, NULL, attr);
11770|      0|	    }
11771|     78|	} else if (xmlStrEqual(attr->ns->href, xmlSchemaNs)) {
  ------------------
  |  Branch (11771:13): [True: 0, False: 0]
  ------------------
11772|      0|	    xmlSchemaPIllegalAttrErr(ctxt,
11773|      0|		XML_SCHEMAP_S4S_ATTR_NOT_ALLOWED, NULL, attr);
11774|      0|	}
11775|     78|	attr = attr->next;
11776|     78|    }
11777|       |
11778|     78|    xmlSchemaPValAttrID(ctxt, node, BAD_CAST "id");
  ------------------
  |  |   35|     78|#define BAD_CAST (xmlChar *)
  ------------------
11779|       |
11780|       |    /*
11781|       |    * Attribute "base" - mandatory.
11782|       |    */
11783|     78|    if ((xmlSchemaPValAttrQName(ctxt, schema, NULL, node,
  ------------------
  |  Branch (11783:9): [True: 78, False: 0]
  ------------------
11784|     78|	"base", &(type->baseNs), &(type->base)) == 0) &&
11785|     78|	(type->base == NULL)) {
  ------------------
  |  Branch (11785:2): [True: 0, False: 78]
  ------------------
11786|      0|	xmlSchemaPMissingAttrErr(ctxt,
11787|      0|	    XML_SCHEMAP_S4S_ATTR_MISSING,
11788|      0|	    NULL, node, "base", NULL);
11789|      0|    }
11790|       |    /*
11791|       |    * And now for the children...
11792|       |    */
11793|     78|    child = node->children;
11794|     78|    if (IS_SCHEMA(child, "annotation")) {
  ------------------
  |  |  316|     78|   ((node != NULL) && (node->ns != NULL) && \
  |  |  ------------------
  |  |  |  Branch (316:5): [True: 72, False: 6]
  |  |  |  Branch (316:23): [True: 72, False: 0]
  |  |  ------------------
  |  |  317|     78|    (xmlStrEqual(node->name, (const xmlChar *) type)) && \
  |  |  ------------------
  |  |  |  Branch (317:5): [True: 0, False: 72]
  |  |  ------------------
  |  |  318|     78|    (xmlStrEqual(node->ns->href, xmlSchemaNs)))
  |  |  ------------------
  |  |  |  Branch (318:5): [True: 0, False: 0]
  |  |  ------------------
  ------------------
11795|       |	/*
11796|       |	* Add the annotation to the type ancestor.
11797|       |	*/
11798|      0|	xmlSchemaAddAnnotation((xmlSchemaAnnotItemPtr) type,
11799|      0|	    xmlSchemaParseAnnotation(ctxt, child, 1));
11800|      0|        child = child->next;
11801|      0|    }
11802|     78|    if (parentType == XML_SCHEMA_TYPE_COMPLEX_CONTENT) {
  ------------------
  |  Branch (11802:9): [True: 46, False: 32]
  ------------------
11803|       |	/*
11804|       |	* Corresponds to <complexType><complexContent><extension>... and:
11805|       |	*
11806|       |	* Model groups <all>, <choice>, <sequence> and <group>.
11807|       |	*/
11808|     46|	if (IS_SCHEMA(child, "all")) {
  ------------------
  |  |  316|     46|   ((node != NULL) && (node->ns != NULL) && \
  |  |  ------------------
  |  |  |  Branch (316:5): [True: 44, False: 2]
  |  |  |  Branch (316:23): [True: 44, False: 0]
  |  |  ------------------
  |  |  317|     46|    (xmlStrEqual(node->name, (const xmlChar *) type)) && \
  |  |  ------------------
  |  |  |  Branch (317:5): [True: 0, False: 44]
  |  |  ------------------
  |  |  318|     46|    (xmlStrEqual(node->ns->href, xmlSchemaNs)))
  |  |  ------------------
  |  |  |  Branch (318:5): [True: 0, False: 0]
  |  |  ------------------
  ------------------
11809|      0|	    type->subtypes = (xmlSchemaTypePtr)
11810|      0|		xmlSchemaParseModelGroup(ctxt, schema,
11811|      0|		    child, XML_SCHEMA_TYPE_ALL, 1);
11812|      0|	    child = child->next;
11813|     46|	} else if (IS_SCHEMA(child, "choice")) {
  ------------------
  |  |  316|     46|   ((node != NULL) && (node->ns != NULL) && \
  |  |  ------------------
  |  |  |  Branch (316:5): [True: 44, False: 2]
  |  |  |  Branch (316:23): [True: 44, False: 0]
  |  |  ------------------
  |  |  317|     46|    (xmlStrEqual(node->name, (const xmlChar *) type)) && \
  |  |  ------------------
  |  |  |  Branch (317:5): [True: 0, False: 44]
  |  |  ------------------
  |  |  318|     46|    (xmlStrEqual(node->ns->href, xmlSchemaNs)))
  |  |  ------------------
  |  |  |  Branch (318:5): [True: 0, False: 0]
  |  |  ------------------
  ------------------
11814|      0|	    type->subtypes = (xmlSchemaTypePtr)
11815|      0|		xmlSchemaParseModelGroup(ctxt, schema,
11816|      0|		    child, XML_SCHEMA_TYPE_CHOICE, 1);
11817|      0|	    child = child->next;
11818|     46|	} else if (IS_SCHEMA(child, "sequence")) {
  ------------------
  |  |  316|     46|   ((node != NULL) && (node->ns != NULL) && \
  |  |  ------------------
  |  |  |  Branch (316:5): [True: 44, False: 2]
  |  |  |  Branch (316:23): [True: 44, False: 0]
  |  |  ------------------
  |  |  317|     46|    (xmlStrEqual(node->name, (const xmlChar *) type)) && \
  |  |  ------------------
  |  |  |  Branch (317:5): [True: 11, False: 33]
  |  |  ------------------
  |  |  318|     46|    (xmlStrEqual(node->ns->href, xmlSchemaNs)))
  |  |  ------------------
  |  |  |  Branch (318:5): [True: 11, False: 0]
  |  |  ------------------
  ------------------
11819|     11|	    type->subtypes = (xmlSchemaTypePtr)
11820|     11|		xmlSchemaParseModelGroup(ctxt, schema,
11821|     11|		child, XML_SCHEMA_TYPE_SEQUENCE, 1);
11822|     11|	    child = child->next;
11823|     35|	} else if (IS_SCHEMA(child, "group")) {
  ------------------
  |  |  316|     35|   ((node != NULL) && (node->ns != NULL) && \
  |  |  ------------------
  |  |  |  Branch (316:5): [True: 33, False: 2]
  |  |  |  Branch (316:23): [True: 33, False: 0]
  |  |  ------------------
  |  |  317|     35|    (xmlStrEqual(node->name, (const xmlChar *) type)) && \
  |  |  ------------------
  |  |  |  Branch (317:5): [True: 0, False: 33]
  |  |  ------------------
  |  |  318|     35|    (xmlStrEqual(node->ns->href, xmlSchemaNs)))
  |  |  ------------------
  |  |  |  Branch (318:5): [True: 0, False: 0]
  |  |  ------------------
  ------------------
11824|      0|	    type->subtypes = (xmlSchemaTypePtr)
11825|      0|		xmlSchemaParseModelGroupDefRef(ctxt, schema, child);
11826|       |	    /*
11827|       |	    * Note that the reference will be resolved in
11828|       |	    * xmlSchemaResolveTypeReferences();
11829|       |	    */
11830|      0|	    child = child->next;
11831|      0|	}
11832|     46|    }
11833|     78|    if (child != NULL) {
  ------------------
  |  Branch (11833:9): [True: 65, False: 13]
  ------------------
11834|       |	/*
11835|       |	* Attribute uses/declarations.
11836|       |	*/
11837|     65|	if (xmlSchemaParseLocalAttributes(ctxt, schema, &child,
  ------------------
  |  Branch (11837:6): [True: 0, False: 65]
  ------------------
11838|     65|	    (xmlSchemaItemListPtr *) &(type->attrUses),
11839|     65|	    XML_SCHEMA_TYPE_EXTENSION, NULL) == -1)
11840|      0|	    return(NULL);
11841|       |	/*
11842|       |	* Attribute wildcard.
11843|       |	*/
11844|     65|	if (IS_SCHEMA(child, "anyAttribute")) {
  ------------------
  |  |  316|     65|   ((node != NULL) && (node->ns != NULL) && \
  |  |  ------------------
  |  |  |  Branch (316:5): [True: 28, False: 37]
  |  |  |  Branch (316:23): [True: 28, False: 0]
  |  |  ------------------
  |  |  317|     65|    (xmlStrEqual(node->name, (const xmlChar *) type)) && \
  |  |  ------------------
  |  |  |  Branch (317:5): [True: 28, False: 0]
  |  |  ------------------
  |  |  318|     65|    (xmlStrEqual(node->ns->href, xmlSchemaNs)))
  |  |  ------------------
  |  |  |  Branch (318:5): [True: 28, False: 0]
  |  |  ------------------
  ------------------
11845|     28|	    ctxt->ctxtType->attributeWildcard =
11846|     28|		xmlSchemaParseAnyAttribute(ctxt, schema, child);
11847|     28|	    child = child->next;
11848|     28|	}
11849|     65|    }
11850|     78|    if (child != NULL) {
  ------------------
  |  Branch (11850:9): [True: 0, False: 78]
  ------------------
11851|      0|	if (parentType == XML_SCHEMA_TYPE_COMPLEX_CONTENT) {
  ------------------
  |  Branch (11851:6): [True: 0, False: 0]
  ------------------
11852|       |	    /* Complex content extension. */
11853|      0|	    xmlSchemaPContentErr(ctxt,
11854|      0|		XML_SCHEMAP_S4S_ELEM_NOT_ALLOWED,
11855|      0|		NULL, node, child, NULL,
11856|      0|		"(annotation?, ((group | all | choice | sequence)?, "
11857|      0|		"((attribute | attributeGroup)*, anyAttribute?)))");
11858|      0|	} else {
11859|       |	    /* Simple content extension. */
11860|      0|	    xmlSchemaPContentErr(ctxt,
11861|      0|		XML_SCHEMAP_S4S_ELEM_NOT_ALLOWED,
11862|      0|		NULL, node, child, NULL,
11863|      0|		"(annotation?, ((attribute | attributeGroup)*, "
11864|      0|		"anyAttribute?))");
11865|      0|	}
11866|      0|    }
11867|     78|    return (NULL);
11868|     78|}
xmlschemas.c:xmlSchemaParseComplexContent:
11975|     62|{
11976|     62|    xmlSchemaTypePtr type;
11977|     62|    xmlNodePtr child = NULL;
11978|     62|    xmlAttrPtr attr;
11979|       |
11980|     62|    if ((ctxt == NULL) || (schema == NULL) || (node == NULL) ||
  ------------------
  |  Branch (11980:9): [True: 0, False: 62]
  |  Branch (11980:27): [True: 0, False: 62]
  |  Branch (11980:47): [True: 0, False: 62]
  ------------------
11981|     62|	(hasRestrictionOrExtension == NULL))
  ------------------
  |  Branch (11981:2): [True: 0, False: 62]
  ------------------
11982|      0|        return (-1);
11983|     62|    *hasRestrictionOrExtension = 0;
11984|       |    /* Not a component, don't create it. */
11985|     62|    type = ctxt->ctxtType;
11986|       |    /*
11987|       |    * Check for illegal attributes.
11988|       |    */
11989|     62|    attr = node->properties;
11990|     63|    while (attr != NULL) {
  ------------------
  |  Branch (11990:12): [True: 1, False: 62]
  ------------------
11991|      1|	if (attr->ns == NULL) {
  ------------------
  |  Branch (11991:6): [True: 1, False: 0]
  ------------------
11992|      1|	    if ((!xmlStrEqual(attr->name, BAD_CAST "id")) &&
  ------------------
  |  |   35|      1|#define BAD_CAST (xmlChar *)
  ------------------
  |  Branch (11992:10): [True: 1, False: 0]
  ------------------
11993|      1|		(!xmlStrEqual(attr->name, BAD_CAST "mixed")))
  ------------------
  |  |   35|      1|#define BAD_CAST (xmlChar *)
  ------------------
  |  Branch (11993:3): [True: 0, False: 1]
  ------------------
11994|      0|	    {
11995|      0|		xmlSchemaPIllegalAttrErr(ctxt,
11996|      0|		    XML_SCHEMAP_S4S_ATTR_NOT_ALLOWED, NULL, attr);
11997|      0|	    }
11998|      1|	} else if (xmlStrEqual(attr->ns->href, xmlSchemaNs)) {
  ------------------
  |  Branch (11998:13): [True: 0, False: 0]
  ------------------
11999|      0|	    xmlSchemaPIllegalAttrErr(ctxt,
12000|      0|		XML_SCHEMAP_S4S_ATTR_NOT_ALLOWED, NULL, attr);
12001|      0|	}
12002|      1|	attr = attr->next;
12003|      1|    }
12004|       |
12005|     62|    xmlSchemaPValAttrID(ctxt, node, BAD_CAST "id");
  ------------------
  |  |   35|     62|#define BAD_CAST (xmlChar *)
  ------------------
12006|       |
12007|       |    /*
12008|       |    * Set the 'mixed' on the complex type ancestor.
12009|       |    */
12010|     62|    if (xmlGetBooleanProp(ctxt, node, "mixed", 0))  {
  ------------------
  |  Branch (12010:9): [True: 1, False: 61]
  ------------------
12011|      1|	if ((type->flags & XML_SCHEMAS_TYPE_MIXED) == 0)
  ------------------
  |  |  408|      1|#define XML_SCHEMAS_TYPE_MIXED                1 << 0
  ------------------
  |  Branch (12011:6): [True: 1, False: 0]
  ------------------
12012|      1|	    type->flags |= XML_SCHEMAS_TYPE_MIXED;
  ------------------
  |  |  408|      1|#define XML_SCHEMAS_TYPE_MIXED                1 << 0
  ------------------
12013|      1|    }
12014|     62|    child = node->children;
12015|     62|    if (IS_SCHEMA(child, "annotation")) {
  ------------------
  |  |  316|     62|   ((node != NULL) && (node->ns != NULL) && \
  |  |  ------------------
  |  |  |  Branch (316:5): [True: 62, False: 0]
  |  |  |  Branch (316:23): [True: 62, False: 0]
  |  |  ------------------
  |  |  317|     62|    (xmlStrEqual(node->name, (const xmlChar *) type)) && \
  |  |  ------------------
  |  |  |  Branch (317:5): [True: 0, False: 62]
  |  |  ------------------
  |  |  318|     62|    (xmlStrEqual(node->ns->href, xmlSchemaNs)))
  |  |  ------------------
  |  |  |  Branch (318:5): [True: 0, False: 0]
  |  |  ------------------
  ------------------
12016|       |	/*
12017|       |	* Add the annotation to the complex type ancestor.
12018|       |	*/
12019|      0|	xmlSchemaAddAnnotation((xmlSchemaAnnotItemPtr) type,
12020|      0|	    xmlSchemaParseAnnotation(ctxt, child, 1));
12021|      0|        child = child->next;
12022|      0|    }
12023|     62|    if (child == NULL) {
  ------------------
  |  Branch (12023:9): [True: 0, False: 62]
  ------------------
12024|      0|	xmlSchemaPContentErr(ctxt,
12025|      0|	    XML_SCHEMAP_S4S_ELEM_MISSING,
12026|      0|	    NULL, node, NULL,
12027|      0|	    NULL, "(annotation?, (restriction | extension))");
12028|      0|    }
12029|     62|    if (child == NULL) {
  ------------------
  |  Branch (12029:9): [True: 0, False: 62]
  ------------------
12030|      0|	xmlSchemaPContentErr(ctxt,
12031|      0|	    XML_SCHEMAP_S4S_ELEM_MISSING,
12032|      0|	    NULL, node, NULL,
12033|      0|	    NULL, "(annotation?, (restriction | extension))");
12034|      0|    }
12035|     62|    if (IS_SCHEMA(child, "restriction")) {
  ------------------
  |  |  316|     62|   ((node != NULL) && (node->ns != NULL) && \
  |  |  ------------------
  |  |  |  Branch (316:5): [True: 62, False: 0]
  |  |  |  Branch (316:23): [True: 62, False: 0]
  |  |  ------------------
  |  |  317|     62|    (xmlStrEqual(node->name, (const xmlChar *) type)) && \
  |  |  ------------------
  |  |  |  Branch (317:5): [True: 16, False: 46]
  |  |  ------------------
  |  |  318|     62|    (xmlStrEqual(node->ns->href, xmlSchemaNs)))
  |  |  ------------------
  |  |  |  Branch (318:5): [True: 16, False: 0]
  |  |  ------------------
  ------------------
12036|     16|        xmlSchemaParseRestriction(ctxt, schema, child,
12037|     16|	    XML_SCHEMA_TYPE_COMPLEX_CONTENT);
12038|     16|	(*hasRestrictionOrExtension) = 1;
12039|     16|        child = child->next;
12040|     46|    } else if (IS_SCHEMA(child, "extension")) {
  ------------------
  |  |  316|     46|   ((node != NULL) && (node->ns != NULL) && \
  |  |  ------------------
  |  |  |  Branch (316:5): [True: 46, False: 0]
  |  |  |  Branch (316:23): [True: 46, False: 0]
  |  |  ------------------
  |  |  317|     46|    (xmlStrEqual(node->name, (const xmlChar *) type)) && \
  |  |  ------------------
  |  |  |  Branch (317:5): [True: 46, False: 0]
  |  |  ------------------
  |  |  318|     46|    (xmlStrEqual(node->ns->href, xmlSchemaNs)))
  |  |  ------------------
  |  |  |  Branch (318:5): [True: 46, False: 0]
  |  |  ------------------
  ------------------
12041|     46|        xmlSchemaParseExtension(ctxt, schema, child,
12042|     46|	    XML_SCHEMA_TYPE_COMPLEX_CONTENT);
12043|     46|	(*hasRestrictionOrExtension) = 1;
12044|     46|        child = child->next;
12045|     46|    }
12046|     62|    if (child != NULL) {
  ------------------
  |  Branch (12046:9): [True: 0, False: 62]
  ------------------
12047|      0|	xmlSchemaPContentErr(ctxt,
12048|      0|	    XML_SCHEMAP_S4S_ELEM_NOT_ALLOWED,
12049|      0|	    NULL, node, child,
12050|      0|	    NULL, "(annotation?, (restriction | extension))");
12051|      0|    }
12052|     62|    return (0);
12053|     62|}
xmlschemas.c:xmlGetBooleanProp:
 6153|    970|{
 6154|    970|    const xmlChar *val;
 6155|       |
 6156|    970|    val = xmlSchemaGetProp(ctxt, node, name);
 6157|    970|    if (val == NULL)
  ------------------
  |  Branch (6157:9): [True: 945, False: 25]
  ------------------
 6158|    945|        return (def);
 6159|       |    /*
 6160|       |    * 3.2.2.1 Lexical representation
 6161|       |    * An instance of a datatype that is defined as `boolean`
 6162|       |    * can have the following legal literals {true, false, 1, 0}.
 6163|       |    */
 6164|     25|    if (xmlStrEqual(val, BAD_CAST "true"))
  ------------------
  |  |   35|     25|#define BAD_CAST (xmlChar *)
  ------------------
  |  Branch (6164:9): [True: 19, False: 6]
  ------------------
 6165|     19|        def = 1;
 6166|      6|    else if (xmlStrEqual(val, BAD_CAST "false"))
  ------------------
  |  |   35|      6|#define BAD_CAST (xmlChar *)
  ------------------
  |  Branch (6166:14): [True: 6, False: 0]
  ------------------
 6167|      6|        def = 0;
 6168|      0|    else if (xmlStrEqual(val, BAD_CAST "1"))
  ------------------
  |  |   35|      0|#define BAD_CAST (xmlChar *)
  ------------------
  |  Branch (6168:14): [True: 0, False: 0]
  ------------------
 6169|      0|	def = 1;
 6170|      0|    else if (xmlStrEqual(val, BAD_CAST "0"))
  ------------------
  |  |   35|      0|#define BAD_CAST (xmlChar *)
  ------------------
  |  Branch (6170:14): [True: 0, False: 0]
  ------------------
 6171|      0|        def = 0;
 6172|      0|    else {
 6173|      0|        xmlSchemaPSimpleTypeErr(ctxt,
 6174|      0|	    XML_SCHEMAP_INVALID_BOOLEAN,
 6175|      0|	    NULL,
 6176|      0|	    (xmlNodePtr) xmlSchemaGetPropNode(node, name),
 6177|      0|	    xmlSchemaGetBuiltInType(XML_SCHEMAS_BOOLEAN),
 6178|      0|	    NULL, val, NULL, NULL, NULL);
 6179|      0|    }
 6180|     25|    return (def);
 6181|    970|}
xmlschemas.c:xmlSchemaParseModelGroup:
11180|    224|{
11181|    224|    xmlSchemaModelGroupPtr item;
11182|    224|    xmlSchemaParticlePtr particle = NULL;
11183|    224|    xmlNodePtr child = NULL;
11184|    224|    xmlAttrPtr attr;
11185|    224|    int min = 1, max = 1, isElemRef, hasRefs = 0;
11186|       |
11187|    224|    if ((ctxt == NULL) || (schema == NULL) || (node == NULL))
  ------------------
  |  Branch (11187:9): [True: 0, False: 224]
  |  Branch (11187:27): [True: 0, False: 224]
  |  Branch (11187:47): [True: 0, False: 224]
  ------------------
11188|      0|        return (NULL);
11189|       |    /*
11190|       |    * Create a model group with the given compositor.
11191|       |    */
11192|    224|    item = xmlSchemaAddModelGroup(ctxt, schema, type, node);
11193|    224|    if (item == NULL)
  ------------------
  |  Branch (11193:9): [True: 0, False: 224]
  ------------------
11194|      0|	return (NULL);
11195|       |
11196|    224|    if (withParticle) {
  ------------------
  |  Branch (11196:9): [True: 215, False: 9]
  ------------------
11197|    215|	if (type == XML_SCHEMA_TYPE_ALL) {
  ------------------
  |  Branch (11197:6): [True: 10, False: 205]
  ------------------
11198|     10|	    min = xmlGetMinOccurs(ctxt, node, 0, 1, 1, "(0 | 1)");
11199|     10|	    max = xmlGetMaxOccurs(ctxt, node, 1, 1, 1, "1");
11200|    205|	} else {
11201|       |	    /* choice + sequence */
11202|    205|	    min = xmlGetMinOccurs(ctxt, node, 0, -1, 1, "xs:nonNegativeInteger");
11203|    205|	    max = xmlGetMaxOccurs(ctxt, node, 0, UNBOUNDED, 1,
  ------------------
  |  |   98|    205|#define UNBOUNDED (1 << 30)
  ------------------
11204|    205|		"(xs:nonNegativeInteger | unbounded)");
11205|    205|	}
11206|    215|	xmlSchemaPCheckParticleCorrect_2(ctxt, NULL, node, min, max);
11207|       |	/*
11208|       |	* Create a particle
11209|       |	*/
11210|    215|	particle = xmlSchemaAddParticle(ctxt, node, min, max);
11211|    215|	if (particle == NULL)
  ------------------
  |  Branch (11211:6): [True: 0, False: 215]
  ------------------
11212|      0|	    return (NULL);
11213|    215|	particle->children = (xmlSchemaTreeItemPtr) item;
11214|       |	/*
11215|       |	* Check for illegal attributes.
11216|       |	*/
11217|    215|	attr = node->properties;
11218|    296|	while (attr != NULL) {
  ------------------
  |  Branch (11218:9): [True: 81, False: 215]
  ------------------
11219|     81|	    if (attr->ns == NULL) {
  ------------------
  |  Branch (11219:10): [True: 81, False: 0]
  ------------------
11220|     81|		if ((!xmlStrEqual(attr->name, BAD_CAST "id")) &&
  ------------------
  |  |   35|     81|#define BAD_CAST (xmlChar *)
  ------------------
  |  Branch (11220:7): [True: 81, False: 0]
  ------------------
11221|     81|		    (!xmlStrEqual(attr->name, BAD_CAST "maxOccurs")) &&
  ------------------
  |  |   35|     81|#define BAD_CAST (xmlChar *)
  ------------------
  |  Branch (11221:7): [True: 41, False: 40]
  ------------------
11222|     81|		    (!xmlStrEqual(attr->name, BAD_CAST "minOccurs"))) {
  ------------------
  |  |   35|     41|#define BAD_CAST (xmlChar *)
  ------------------
  |  Branch (11222:7): [True: 0, False: 41]
  ------------------
11223|      0|		    xmlSchemaPIllegalAttrErr(ctxt,
11224|      0|			XML_SCHEMAP_S4S_ATTR_NOT_ALLOWED, NULL, attr);
11225|      0|		}
11226|     81|	    } else if (xmlStrEqual(attr->ns->href, xmlSchemaNs)) {
  ------------------
  |  Branch (11226:17): [True: 0, False: 0]
  ------------------
11227|      0|		xmlSchemaPIllegalAttrErr(ctxt,
11228|      0|		    XML_SCHEMAP_S4S_ATTR_NOT_ALLOWED, NULL, attr);
11229|      0|	    }
11230|     81|	    attr = attr->next;
11231|     81|	}
11232|    215|    } else {
11233|       |	/*
11234|       |	* Check for illegal attributes.
11235|       |	*/
11236|      9|	attr = node->properties;
11237|      9|	while (attr != NULL) {
  ------------------
  |  Branch (11237:9): [True: 0, False: 9]
  ------------------
11238|      0|	    if (attr->ns == NULL) {
  ------------------
  |  Branch (11238:10): [True: 0, False: 0]
  ------------------
11239|      0|		if (!xmlStrEqual(attr->name, BAD_CAST "id")) {
  ------------------
  |  |   35|      0|#define BAD_CAST (xmlChar *)
  ------------------
  |  Branch (11239:7): [True: 0, False: 0]
  ------------------
11240|      0|		    xmlSchemaPIllegalAttrErr(ctxt,
11241|      0|			XML_SCHEMAP_S4S_ATTR_NOT_ALLOWED, NULL, attr);
11242|      0|		}
11243|      0|	    } else if (xmlStrEqual(attr->ns->href, xmlSchemaNs)) {
  ------------------
  |  Branch (11243:17): [True: 0, False: 0]
  ------------------
11244|      0|		xmlSchemaPIllegalAttrErr(ctxt,
11245|      0|		    XML_SCHEMAP_S4S_ATTR_NOT_ALLOWED, NULL, attr);
11246|      0|	    }
11247|      0|	    attr = attr->next;
11248|      0|	}
11249|      9|    }
11250|       |
11251|       |    /*
11252|       |    * Extract and validate attributes.
11253|       |    */
11254|    224|    xmlSchemaPValAttrID(ctxt, node, BAD_CAST "id");
  ------------------
  |  |   35|    224|#define BAD_CAST (xmlChar *)
  ------------------
11255|       |    /*
11256|       |    * And now for the children...
11257|       |    */
11258|    224|    child = node->children;
11259|    224|    if (IS_SCHEMA(child, "annotation")) {
  ------------------
  |  |  316|    224|   ((node != NULL) && (node->ns != NULL) && \
  |  |  ------------------
  |  |  |  Branch (316:5): [True: 222, False: 2]
  |  |  |  Branch (316:23): [True: 222, False: 0]
  |  |  ------------------
  |  |  317|    224|    (xmlStrEqual(node->name, (const xmlChar *) type)) && \
  |  |  ------------------
  |  |  |  Branch (317:5): [True: 0, False: 222]
  |  |  ------------------
  |  |  318|    224|    (xmlStrEqual(node->ns->href, xmlSchemaNs)))
  |  |  ------------------
  |  |  |  Branch (318:5): [True: 0, False: 0]
  |  |  ------------------
  ------------------
11260|      0|        item->annot = xmlSchemaParseAnnotation(ctxt, child, 1);
11261|      0|        child = child->next;
11262|      0|    }
11263|    224|    if (type == XML_SCHEMA_TYPE_ALL) {
  ------------------
  |  Branch (11263:9): [True: 10, False: 214]
  ------------------
11264|     10|	xmlSchemaParticlePtr part, last = NULL;
11265|       |
11266|     28|	while (IS_SCHEMA(child, "element")) {
  ------------------
  |  |  316|     28|   ((node != NULL) && (node->ns != NULL) && \
  |  |  ------------------
  |  |  |  Branch (316:5): [True: 19, False: 9]
  |  |  |  Branch (316:23): [True: 19, False: 0]
  |  |  ------------------
  |  |  317|     28|    (xmlStrEqual(node->name, (const xmlChar *) type)) && \
  |  |  ------------------
  |  |  |  Branch (317:5): [True: 18, False: 1]
  |  |  ------------------
  |  |  318|     28|    (xmlStrEqual(node->ns->href, xmlSchemaNs)))
  |  |  ------------------
  |  |  |  Branch (318:5): [True: 18, False: 0]
  |  |  ------------------
  ------------------
11267|     18|	    part = (xmlSchemaParticlePtr) xmlSchemaParseElement(ctxt,
11268|     18|		schema, child, &isElemRef, 0);
11269|       |	    /*
11270|       |	    * SPEC cos-all-limited (2)
11271|       |	    * "The {max occurs} of all the particles in the {particles}
11272|       |	    * of the ('all') group must be 0 or 1.
11273|       |	    */
11274|     18|	    if (part != NULL) {
  ------------------
  |  Branch (11274:10): [True: 18, False: 0]
  ------------------
11275|     18|		if (isElemRef)
  ------------------
  |  Branch (11275:7): [True: 7, False: 11]
  ------------------
11276|      7|		    hasRefs++;
11277|     18|		if (part->minOccurs > 1) {
  ------------------
  |  Branch (11277:7): [True: 0, False: 18]
  ------------------
11278|      0|		    xmlSchemaPCustomErr(ctxt,
11279|      0|			XML_SCHEMAP_COS_ALL_LIMITED,
11280|      0|			NULL, child,
11281|      0|			"Invalid value for minOccurs (must be 0 or 1)",
11282|      0|			NULL);
11283|       |		    /* Reset to 1. */
11284|      0|		    part->minOccurs = 1;
11285|      0|		}
11286|     18|		if (part->maxOccurs > 1) {
  ------------------
  |  Branch (11286:7): [True: 0, False: 18]
  ------------------
11287|      0|		    xmlSchemaPCustomErr(ctxt,
11288|      0|			XML_SCHEMAP_COS_ALL_LIMITED,
11289|      0|			NULL, child,
11290|      0|			"Invalid value for maxOccurs (must be 0 or 1)",
11291|      0|			NULL);
11292|       |		    /* Reset to 1. */
11293|      0|		    part->maxOccurs = 1;
11294|      0|		}
11295|     18|		if (last == NULL)
  ------------------
  |  Branch (11295:7): [True: 9, False: 9]
  ------------------
11296|      9|		    item->children = (xmlSchemaTreeItemPtr) part;
11297|      9|		else
11298|      9|		    last->next = (xmlSchemaTreeItemPtr) part;
11299|     18|		last = part;
11300|     18|	    }
11301|     18|	    child = child->next;
11302|     18|	}
11303|     10|	if (child != NULL) {
  ------------------
  |  Branch (11303:6): [True: 1, False: 9]
  ------------------
11304|      1|	    xmlSchemaPContentErr(ctxt,
11305|      1|		XML_SCHEMAP_S4S_ELEM_NOT_ALLOWED,
11306|      1|		NULL, node, child, NULL,
11307|      1|		"(annotation?, (annotation?, element*)");
11308|      1|	}
11309|    214|    } else {
11310|       |	/* choice + sequence */
11311|    214|	xmlSchemaTreeItemPtr part = NULL, last = NULL;
11312|       |
11313|    738|	while ((IS_SCHEMA(child, "element")) ||
  ------------------
  |  |  316|    738|   ((node != NULL) && (node->ns != NULL) && \
  |  |  ------------------
  |  |  |  Branch (316:5): [True: 525, False: 213]
  |  |  |  Branch (316:23): [True: 525, False: 0]
  |  |  ------------------
  |  |  317|    738|    (xmlStrEqual(node->name, (const xmlChar *) type)) && \
  |  |  ------------------
  |  |  |  Branch (317:5): [True: 475, False: 50]
  |  |  ------------------
  |  |  318|    738|    (xmlStrEqual(node->ns->href, xmlSchemaNs)))
  |  |  ------------------
  |  |  |  Branch (318:5): [True: 475, False: 0]
  |  |  ------------------
  ------------------
11314|    738|	    (IS_SCHEMA(child, "group")) ||
  ------------------
  |  |  316|    263|   ((node != NULL) && (node->ns != NULL) && \
  |  |  ------------------
  |  |  |  Branch (316:5): [True: 50, False: 213]
  |  |  |  Branch (316:23): [True: 50, False: 0]
  |  |  ------------------
  |  |  317|    263|    (xmlStrEqual(node->name, (const xmlChar *) type)) && \
  |  |  ------------------
  |  |  |  Branch (317:5): [True: 5, False: 45]
  |  |  ------------------
  |  |  318|    263|    (xmlStrEqual(node->ns->href, xmlSchemaNs)))
  |  |  ------------------
  |  |  |  Branch (318:5): [True: 5, False: 0]
  |  |  ------------------
  ------------------
11315|    738|	    (IS_SCHEMA(child, "any")) ||
  ------------------
  |  |  316|    258|   ((node != NULL) && (node->ns != NULL) && \
  |  |  ------------------
  |  |  |  Branch (316:5): [True: 45, False: 213]
  |  |  |  Branch (316:23): [True: 45, False: 0]
  |  |  ------------------
  |  |  317|    258|    (xmlStrEqual(node->name, (const xmlChar *) type)) && \
  |  |  ------------------
  |  |  |  Branch (317:5): [True: 19, False: 26]
  |  |  ------------------
  |  |  318|    258|    (xmlStrEqual(node->ns->href, xmlSchemaNs)))
  |  |  ------------------
  |  |  |  Branch (318:5): [True: 19, False: 0]
  |  |  ------------------
  ------------------
11316|    738|	    (IS_SCHEMA(child, "choice")) ||
  ------------------
  |  |  316|    239|   ((node != NULL) && (node->ns != NULL) && \
  |  |  ------------------
  |  |  |  Branch (316:5): [True: 26, False: 213]
  |  |  |  Branch (316:23): [True: 26, False: 0]
  |  |  ------------------
  |  |  317|    239|    (xmlStrEqual(node->name, (const xmlChar *) type)) && \
  |  |  ------------------
  |  |  |  Branch (317:5): [True: 17, False: 9]
  |  |  ------------------
  |  |  318|    239|    (xmlStrEqual(node->ns->href, xmlSchemaNs)))
  |  |  ------------------
  |  |  |  Branch (318:5): [True: 17, False: 0]
  |  |  ------------------
  ------------------
11317|    738|	    (IS_SCHEMA(child, "sequence"))) {
  ------------------
  |  |  316|    222|   ((node != NULL) && (node->ns != NULL) && \
  |  |  ------------------
  |  |  |  Branch (316:5): [True: 9, False: 213]
  |  |  |  Branch (316:23): [True: 9, False: 0]
  |  |  ------------------
  |  |  317|    222|    (xmlStrEqual(node->name, (const xmlChar *) type)) && \
  |  |  ------------------
  |  |  |  Branch (317:5): [True: 8, False: 1]
  |  |  ------------------
  |  |  318|    222|    (xmlStrEqual(node->ns->href, xmlSchemaNs)))
  |  |  ------------------
  |  |  |  Branch (318:5): [True: 8, False: 0]
  |  |  ------------------
  ------------------
11318|       |
11319|    524|	    if (IS_SCHEMA(child, "element")) {
  ------------------
  |  |  316|    524|   ((node != NULL) && (node->ns != NULL) && \
  |  |  ------------------
  |  |  |  Branch (316:5): [True: 524, False: 0]
  |  |  |  Branch (316:23): [True: 524, False: 0]
  |  |  ------------------
  |  |  317|    524|    (xmlStrEqual(node->name, (const xmlChar *) type)) && \
  |  |  ------------------
  |  |  |  Branch (317:5): [True: 475, False: 49]
  |  |  ------------------
  |  |  318|    524|    (xmlStrEqual(node->ns->href, xmlSchemaNs)))
  |  |  ------------------
  |  |  |  Branch (318:5): [True: 475, False: 0]
  |  |  ------------------
  ------------------
11320|    475|		part = (xmlSchemaTreeItemPtr)
11321|    475|		    xmlSchemaParseElement(ctxt, schema, child, &isElemRef, 0);
11322|    475|		if (part && isElemRef)
  ------------------
  |  Branch (11322:7): [True: 475, False: 0]
  |  Branch (11322:15): [True: 206, False: 269]
  ------------------
11323|    206|		    hasRefs++;
11324|    475|	    } else if (IS_SCHEMA(child, "group")) {
  ------------------
  |  |  316|     49|   ((node != NULL) && (node->ns != NULL) && \
  |  |  ------------------
  |  |  |  Branch (316:5): [True: 49, False: 0]
  |  |  |  Branch (316:23): [True: 49, False: 0]
  |  |  ------------------
  |  |  317|     49|    (xmlStrEqual(node->name, (const xmlChar *) type)) && \
  |  |  ------------------
  |  |  |  Branch (317:5): [True: 5, False: 44]
  |  |  ------------------
  |  |  318|     49|    (xmlStrEqual(node->ns->href, xmlSchemaNs)))
  |  |  ------------------
  |  |  |  Branch (318:5): [True: 5, False: 0]
  |  |  ------------------
  ------------------
11325|      5|		part =
11326|      5|		    xmlSchemaParseModelGroupDefRef(ctxt, schema, child);
11327|      5|		if (part != NULL)
  ------------------
  |  Branch (11327:7): [True: 5, False: 0]
  ------------------
11328|      5|		    hasRefs++;
11329|       |		/*
11330|       |		* Handle redefinitions.
11331|       |		*/
11332|      5|		if (ctxt->isRedefine && ctxt->redef &&
  ------------------
  |  Branch (11332:7): [True: 0, False: 5]
  |  Branch (11332:27): [True: 0, False: 0]
  ------------------
11333|      5|		    (ctxt->redef->item->type == XML_SCHEMA_TYPE_GROUP) &&
  ------------------
  |  Branch (11333:7): [True: 0, False: 0]
  ------------------
11334|      5|		    part && part->children)
  ------------------
  |  Branch (11334:7): [True: 0, False: 0]
  |  Branch (11334:15): [True: 0, False: 0]
  ------------------
11335|      0|		{
11336|      0|		    if ((xmlSchemaGetQNameRefName(part->children) ==
  ------------------
  |  | 1377|      0|#define xmlSchemaGetQNameRefName(r) (WXS_QNAME_CAST (r))->name
  |  |  ------------------
  |  |  |  |  136|      0|#define WXS_QNAME_CAST (xmlSchemaQNameRefPtr)
  |  |  ------------------
  ------------------
  |  Branch (11336:11): [True: 0, False: 0]
  ------------------
11337|      0|			    ctxt->redef->refName) &&
11338|      0|			(xmlSchemaGetQNameRefTargetNs(part->children) ==
  ------------------
  |  | 1378|      0|#define xmlSchemaGetQNameRefTargetNs(r) (WXS_QNAME_CAST (r))->targetNamespace
  |  |  ------------------
  |  |  |  |  136|      0|#define WXS_QNAME_CAST (xmlSchemaQNameRefPtr)
  |  |  ------------------
  ------------------
  |  Branch (11338:4): [True: 0, False: 0]
  ------------------
11339|      0|			    ctxt->redef->refTargetNs))
11340|      0|		    {
11341|       |			/*
11342|       |			* SPEC src-redefine:
11343|       |			* (6.1) "If it has a <group> among its contents at
11344|       |			* some level the `actual value` of whose ref
11345|       |			* [attribute] is the same as the `actual value` of
11346|       |			* its own name attribute plus target namespace, then
11347|       |			* all of the following must be true:"
11348|       |			* (6.1.1) "It must have exactly one such group."
11349|       |			*/
11350|      0|			if (ctxt->redefCounter != 0) {
  ------------------
  |  Branch (11350:8): [True: 0, False: 0]
  ------------------
11351|      0|			    xmlChar *str = NULL;
11352|       |
11353|      0|			    xmlSchemaCustomErr(ACTXT_CAST ctxt,
  ------------------
  |  |  121|      0|#define ACTXT_CAST (xmlSchemaAbstractCtxtPtr)
  ------------------
11354|      0|				XML_SCHEMAP_SRC_REDEFINE, child, NULL,
11355|      0|				"The redefining model group definition "
11356|      0|				"'%s' must not contain more than one "
11357|      0|				"reference to the redefined definition",
11358|      0|				xmlSchemaFormatQName(&str,
11359|      0|				    ctxt->redef->refTargetNs,
11360|      0|				    ctxt->redef->refName),
11361|      0|				NULL);
11362|      0|			    FREE_AND_NULL(str)
  ------------------
  |  |  320|      0|#define FREE_AND_NULL(str) if ((str) != NULL) { xmlFree((xmlChar *) (str)); str = NULL; }
  |  |  ------------------
  |  |  |  Branch (320:32): [True: 0, False: 0]
  |  |  ------------------
  ------------------
11363|      0|			    part = NULL;
11364|      0|			} else if (((WXS_PARTICLE(part))->minOccurs != 1) ||
  ------------------
  |  |  173|      0|#define WXS_PARTICLE(p) WXS_PTC_CAST (p)
  |  |  ------------------
  |  |  |  |  126|      0|#define WXS_PTC_CAST (xmlSchemaParticlePtr)
  |  |  ------------------
  ------------------
  |  Branch (11364:15): [True: 0, False: 0]
  ------------------
11365|      0|			    ((WXS_PARTICLE(part))->maxOccurs != 1))
  ------------------
  |  |  173|      0|#define WXS_PARTICLE(p) WXS_PTC_CAST (p)
  |  |  ------------------
  |  |  |  |  126|      0|#define WXS_PTC_CAST (xmlSchemaParticlePtr)
  |  |  ------------------
  ------------------
  |  Branch (11365:8): [True: 0, False: 0]
  ------------------
11366|      0|			{
11367|      0|			    xmlChar *str = NULL;
11368|       |			    /*
11369|       |			    * SPEC src-redefine:
11370|       |			    * (6.1.2) "The `actual value` of both that
11371|       |			    * group's minOccurs and maxOccurs [attribute]
11372|       |			    * must be 1 (or `absent`).
11373|       |			    */
11374|      0|			    xmlSchemaCustomErr(ACTXT_CAST ctxt,
  ------------------
  |  |  121|      0|#define ACTXT_CAST (xmlSchemaAbstractCtxtPtr)
  ------------------
11375|      0|				XML_SCHEMAP_SRC_REDEFINE, child, NULL,
11376|      0|				"The redefining model group definition "
11377|      0|				"'%s' must not contain a reference to the "
11378|      0|				"redefined definition with a "
11379|      0|				"maxOccurs/minOccurs other than 1",
11380|      0|				xmlSchemaFormatQName(&str,
11381|      0|				    ctxt->redef->refTargetNs,
11382|      0|				    ctxt->redef->refName),
11383|      0|				NULL);
11384|      0|			    FREE_AND_NULL(str)
  ------------------
  |  |  320|      0|#define FREE_AND_NULL(str) if ((str) != NULL) { xmlFree((xmlChar *) (str)); str = NULL; }
  |  |  ------------------
  |  |  |  Branch (320:32): [True: 0, False: 0]
  |  |  ------------------
  ------------------
11385|      0|			    part = NULL;
11386|      0|			}
11387|      0|			ctxt->redef->reference = WXS_BASIC_CAST part;
  ------------------
  |  |  124|      0|#define WXS_BASIC_CAST (xmlSchemaBasicItemPtr)
  ------------------
11388|      0|			ctxt->redefCounter++;
11389|      0|		    }
11390|      0|		}
11391|     44|	    } else if (IS_SCHEMA(child, "any")) {
  ------------------
  |  |  316|     44|   ((node != NULL) && (node->ns != NULL) && \
  |  |  ------------------
  |  |  |  Branch (316:5): [True: 44, False: 0]
  |  |  |  Branch (316:23): [True: 44, False: 0]
  |  |  ------------------
  |  |  317|     44|    (xmlStrEqual(node->name, (const xmlChar *) type)) && \
  |  |  ------------------
  |  |  |  Branch (317:5): [True: 19, False: 25]
  |  |  ------------------
  |  |  318|     44|    (xmlStrEqual(node->ns->href, xmlSchemaNs)))
  |  |  ------------------
  |  |  |  Branch (318:5): [True: 19, False: 0]
  |  |  ------------------
  ------------------
11392|     19|		part = (xmlSchemaTreeItemPtr)
11393|     19|		    xmlSchemaParseAny(ctxt, schema, child);
11394|     25|	    } else if (IS_SCHEMA(child, "choice")) {
  ------------------
  |  |  316|     25|   ((node != NULL) && (node->ns != NULL) && \
  |  |  ------------------
  |  |  |  Branch (316:5): [True: 25, False: 0]
  |  |  |  Branch (316:23): [True: 25, False: 0]
  |  |  ------------------
  |  |  317|     25|    (xmlStrEqual(node->name, (const xmlChar *) type)) && \
  |  |  ------------------
  |  |  |  Branch (317:5): [True: 17, False: 8]
  |  |  ------------------
  |  |  318|     25|    (xmlStrEqual(node->ns->href, xmlSchemaNs)))
  |  |  ------------------
  |  |  |  Branch (318:5): [True: 17, False: 0]
  |  |  ------------------
  ------------------
11395|     17|		part = xmlSchemaParseModelGroup(ctxt, schema, child,
11396|     17|		    XML_SCHEMA_TYPE_CHOICE, 1);
11397|     17|	    } else if (IS_SCHEMA(child, "sequence")) {
  ------------------
  |  |  316|      8|   ((node != NULL) && (node->ns != NULL) && \
  |  |  ------------------
  |  |  |  Branch (316:5): [True: 8, False: 0]
  |  |  |  Branch (316:23): [True: 8, False: 0]
  |  |  ------------------
  |  |  317|      8|    (xmlStrEqual(node->name, (const xmlChar *) type)) && \
  |  |  ------------------
  |  |  |  Branch (317:5): [True: 8, False: 0]
  |  |  ------------------
  |  |  318|      8|    (xmlStrEqual(node->ns->href, xmlSchemaNs)))
  |  |  ------------------
  |  |  |  Branch (318:5): [True: 8, False: 0]
  |  |  ------------------
  ------------------
11398|      8|		part = xmlSchemaParseModelGroup(ctxt, schema, child,
11399|      8|		    XML_SCHEMA_TYPE_SEQUENCE, 1);
11400|      8|	    }
11401|    524|	    if (part != NULL) {
  ------------------
  |  Branch (11401:10): [True: 524, False: 0]
  ------------------
11402|    524|		if (last == NULL)
  ------------------
  |  Branch (11402:7): [True: 211, False: 313]
  ------------------
11403|    211|		    item->children = part;
11404|    313|		else
11405|    313|		    last->next = part;
11406|    524|		last = part;
11407|    524|	    }
11408|    524|	    child = child->next;
11409|    524|	}
11410|    214|	if (child != NULL) {
  ------------------
  |  Branch (11410:6): [True: 1, False: 213]
  ------------------
11411|      1|	    xmlSchemaPContentErr(ctxt,
11412|      1|		XML_SCHEMAP_S4S_ELEM_NOT_ALLOWED,
11413|      1|		NULL, node, child, NULL,
11414|      1|		"(annotation?, (element | group | choice | sequence | any)*)");
11415|      1|	}
11416|    214|    }
11417|    224|    if ((max == 0) && (min == 0))
  ------------------
  |  Branch (11417:9): [True: 0, False: 224]
  |  Branch (11417:23): [True: 0, False: 0]
  ------------------
11418|      0|	return (NULL);
11419|    224|    if (hasRefs) {
  ------------------
  |  Branch (11419:9): [True: 100, False: 124]
  ------------------
11420|       |	/*
11421|       |	* We need to resolve references.
11422|       |	*/
11423|    100|	WXS_ADD_PENDING(ctxt, item);
  ------------------
  |  |  307|    100|    xmlSchemaAddItemSize(&((ctx)->constructor->pending), 10, item)
  ------------------
11424|    100|    }
11425|    224|    if (withParticle)
  ------------------
  |  Branch (11425:9): [True: 215, False: 9]
  ------------------
11426|    215|	return ((xmlSchemaTreeItemPtr) particle);
11427|      9|    else
11428|      9|	return ((xmlSchemaTreeItemPtr) item);
11429|    224|}
xmlschemas.c:xmlSchemaAddModelGroup:
 5422|    234|{
 5423|    234|    xmlSchemaModelGroupPtr ret = NULL;
 5424|       |
 5425|    234|    if ((ctxt == NULL) || (schema == NULL))
  ------------------
  |  Branch (5425:9): [True: 0, False: 234]
  |  Branch (5425:27): [True: 0, False: 234]
  ------------------
 5426|      0|        return (NULL);
 5427|       |
 5428|    234|    ret = (xmlSchemaModelGroupPtr)
 5429|    234|	xmlMalloc(sizeof(xmlSchemaModelGroup));
 5430|    234|    if (ret == NULL) {
  ------------------
  |  Branch (5430:9): [True: 0, False: 234]
  ------------------
 5431|      0|	xmlSchemaPErrMemory(ctxt, "allocating model group component",
 5432|      0|	    NULL);
 5433|      0|	return (NULL);
 5434|      0|    }
 5435|    234|    memset(ret, 0, sizeof(xmlSchemaModelGroup));
 5436|    234|    ret->type = type;
 5437|    234|    ret->node = node;
 5438|    234|    WXS_ADD_LOCAL(ctxt, ret);
  ------------------
  |  |  291|    234|    do { \
  |  |  292|    234|        if (xmlSchemaAddItemSize(&(WXS_BUCKET(ctx)->locals), 10, item) < 0) { \
  |  |  ------------------
  |  |  |  |  286|    234|#define WXS_BUCKET(ctx) WXS_CONSTRUCTOR((ctx))->bucket
  |  |  |  |  ------------------
  |  |  |  |  |  |  278|    234|#define WXS_CONSTRUCTOR(ctx) (ctx)->constructor
  |  |  |  |  ------------------
  |  |  ------------------
  |  |  |  Branch (292:13): [True: 0, False: 234]
  |  |  ------------------
  |  |  293|      0|            xmlFree(item); \
  |  |  294|      0|            item = NULL; \
  |  |  295|      0|        } \
  |  |  296|    234|    } while (0)
  |  |  ------------------
  |  |  |  Branch (296:14): [Folded - Ignored]
  |  |  ------------------
  ------------------
 5439|    234|    if ((type == XML_SCHEMA_TYPE_SEQUENCE) ||
  ------------------
  |  Branch (5439:9): [True: 187, False: 47]
  ------------------
 5440|    234|	(type == XML_SCHEMA_TYPE_CHOICE))
  ------------------
  |  Branch (5440:2): [True: 37, False: 10]
  ------------------
 5441|    224|	WXS_ADD_PENDING(ctxt, ret);
  ------------------
  |  |  307|    224|    xmlSchemaAddItemSize(&((ctx)->constructor->pending), 10, item)
  ------------------
 5442|    234|    return (ret);
 5443|    234|}
xmlschemas.c:xmlGetMinOccurs:
 6041|    736|{
 6042|    736|    const xmlChar *val, *cur;
 6043|    736|    int ret = 0;
 6044|    736|    xmlAttrPtr attr;
 6045|       |
 6046|    736|    attr = xmlSchemaGetPropNode(node, "minOccurs");
 6047|    736|    if (attr == NULL)
  ------------------
  |  Branch (6047:9): [True: 539, False: 197]
  ------------------
 6048|    539|	return (def);
 6049|    197|    val = xmlSchemaGetNodeContent(ctxt, (xmlNodePtr) attr);
 6050|    197|    if (val == NULL)
  ------------------
  |  Branch (6050:9): [True: 0, False: 197]
  ------------------
 6051|      0|	return (def);
 6052|    197|    cur = val;
 6053|    197|    while (IS_BLANK_CH(*cur))
 6054|      0|        cur++;
 6055|    197|    if (*cur == 0) {
  ------------------
  |  Branch (6055:9): [True: 0, False: 197]
  ------------------
 6056|      0|        xmlSchemaPSimpleTypeErr(ctxt,
 6057|      0|	    XML_SCHEMAP_S4S_ATTR_INVALID_VALUE,
 6058|       |	    /* XML_SCHEMAP_INVALID_MINOCCURS, */
 6059|      0|	    NULL, (xmlNodePtr) attr, NULL, expected,
 6060|      0|	    val, NULL, NULL, NULL);
 6061|      0|        return (def);
 6062|      0|    }
 6063|    395|    while ((*cur >= '0') && (*cur <= '9')) {
  ------------------
  |  Branch (6063:12): [True: 198, False: 197]
  |  Branch (6063:29): [True: 198, False: 0]
  ------------------
 6064|    198|        if (ret > INT_MAX / 10) {
  ------------------
  |  Branch (6064:13): [True: 0, False: 198]
  ------------------
 6065|      0|            ret = INT_MAX;
 6066|    198|        } else {
 6067|    198|            int digit = *cur - '0';
 6068|    198|            ret *= 10;
 6069|    198|            if (ret > INT_MAX - digit)
  ------------------
  |  Branch (6069:17): [True: 0, False: 198]
  ------------------
 6070|      0|                ret = INT_MAX;
 6071|    198|            else
 6072|    198|                ret += digit;
 6073|    198|        }
 6074|    198|        cur++;
 6075|    198|    }
 6076|    197|    while (IS_BLANK_CH(*cur))
 6077|      0|        cur++;
 6078|       |    /*
 6079|       |    * TODO: Restrict the maximal value to Integer.
 6080|       |    */
 6081|    197|    if ((*cur != 0) || (ret < min) || ((max != -1) && (ret > max))) {
  ------------------
  |  Branch (6081:9): [True: 0, False: 197]
  |  Branch (6081:24): [True: 0, False: 197]
  |  Branch (6081:40): [True: 3, False: 194]
  |  Branch (6081:55): [True: 0, False: 3]
  ------------------
 6082|      0|	xmlSchemaPSimpleTypeErr(ctxt,
 6083|      0|	    XML_SCHEMAP_S4S_ATTR_INVALID_VALUE,
 6084|       |	    /* XML_SCHEMAP_INVALID_MINOCCURS, */
 6085|      0|	    NULL, (xmlNodePtr) attr, NULL, expected,
 6086|      0|	    val, NULL, NULL, NULL);
 6087|      0|        return (def);
 6088|      0|    }
 6089|    197|    return (ret);
 6090|    197|}
xmlschemas.c:xmlGetMaxOccurs:
 5965|    736|{
 5966|    736|    const xmlChar *val, *cur;
 5967|    736|    int ret = 0;
 5968|    736|    xmlAttrPtr attr;
 5969|       |
 5970|    736|    attr = xmlSchemaGetPropNode(node, "maxOccurs");
 5971|    736|    if (attr == NULL)
  ------------------
  |  Branch (5971:9): [True: 590, False: 146]
  ------------------
 5972|    590|	return (def);
 5973|    146|    val = xmlSchemaGetNodeContent(ctxt, (xmlNodePtr) attr);
 5974|    146|    if (val == NULL)
  ------------------
  |  Branch (5974:9): [True: 0, False: 146]
  ------------------
 5975|      0|        return (def);
 5976|       |
 5977|    146|    if (xmlStrEqual(val, (const xmlChar *) "unbounded")) {
  ------------------
  |  Branch (5977:9): [True: 103, False: 43]
  ------------------
 5978|    103|	if (max != UNBOUNDED) {
  ------------------
  |  |   98|    103|#define UNBOUNDED (1 << 30)
  ------------------
  |  Branch (5978:6): [True: 0, False: 103]
  ------------------
 5979|      0|	    xmlSchemaPSimpleTypeErr(ctxt,
 5980|      0|		XML_SCHEMAP_S4S_ATTR_INVALID_VALUE,
 5981|       |		/* XML_SCHEMAP_INVALID_MINOCCURS, */
 5982|      0|		NULL, (xmlNodePtr) attr, NULL, expected,
 5983|      0|		val, NULL, NULL, NULL);
 5984|      0|	    return (def);
 5985|      0|	} else
 5986|    103|	    return (UNBOUNDED);  /* encoding it with -1 might be another option */
  ------------------
  |  |   98|    103|#define UNBOUNDED (1 << 30)
  ------------------
 5987|    103|    }
 5988|       |
 5989|     43|    cur = val;
 5990|     43|    while (IS_BLANK_CH(*cur))
 5991|      0|        cur++;
 5992|     43|    if (*cur == 0) {
  ------------------
  |  Branch (5992:9): [True: 0, False: 43]
  ------------------
 5993|      0|        xmlSchemaPSimpleTypeErr(ctxt,
 5994|      0|	    XML_SCHEMAP_S4S_ATTR_INVALID_VALUE,
 5995|       |	    /* XML_SCHEMAP_INVALID_MINOCCURS, */
 5996|      0|	    NULL, (xmlNodePtr) attr, NULL, expected,
 5997|      0|	    val, NULL, NULL, NULL);
 5998|      0|	return (def);
 5999|      0|    }
 6000|     87|    while ((*cur >= '0') && (*cur <= '9')) {
  ------------------
  |  Branch (6000:12): [True: 44, False: 43]
  |  Branch (6000:29): [True: 44, False: 0]
  ------------------
 6001|     44|        if (ret > INT_MAX / 10) {
  ------------------
  |  Branch (6001:13): [True: 0, False: 44]
  ------------------
 6002|      0|            ret = INT_MAX;
 6003|     44|        } else {
 6004|     44|            int digit = *cur - '0';
 6005|     44|            ret *= 10;
 6006|     44|            if (ret > INT_MAX - digit)
  ------------------
  |  Branch (6006:17): [True: 0, False: 44]
  ------------------
 6007|      0|                ret = INT_MAX;
 6008|     44|            else
 6009|     44|                ret += digit;
 6010|     44|        }
 6011|     44|        cur++;
 6012|     44|    }
 6013|     43|    while (IS_BLANK_CH(*cur))
 6014|      0|        cur++;
 6015|       |    /*
 6016|       |    * TODO: Restrict the maximal value to Integer.
 6017|       |    */
 6018|     43|    if ((*cur != 0) || (ret < min) || ((max != -1) && (ret > max))) {
  ------------------
  |  Branch (6018:9): [True: 0, False: 43]
  |  Branch (6018:24): [True: 0, False: 43]
  |  Branch (6018:40): [True: 43, False: 0]
  |  Branch (6018:55): [True: 0, False: 43]
  ------------------
 6019|      0|	xmlSchemaPSimpleTypeErr(ctxt,
 6020|      0|	    XML_SCHEMAP_S4S_ATTR_INVALID_VALUE,
 6021|       |	    /* XML_SCHEMAP_INVALID_MINOCCURS, */
 6022|      0|	    NULL, (xmlNodePtr) attr, NULL, expected,
 6023|      0|	    val, NULL, NULL, NULL);
 6024|      0|        return (def);
 6025|      0|    }
 6026|     43|    return (ret);
 6027|     43|}
xmlschemas.c:xmlSchemaPCheckParticleCorrect_2:
 6807|    736|				 int maxOccurs) {
 6808|       |
 6809|    736|    if ((maxOccurs == 0) && ( minOccurs == 0))
  ------------------
  |  Branch (6809:9): [True: 3, False: 733]
  |  Branch (6809:29): [True: 0, False: 3]
  ------------------
 6810|      0|	return (0);
 6811|    736|    if (maxOccurs != UNBOUNDED) {
  ------------------
  |  |   98|    736|#define UNBOUNDED (1 << 30)
  ------------------
  |  Branch (6811:9): [True: 633, False: 103]
  ------------------
 6812|       |	/*
 6813|       |	* TODO: Maybe we should better not create the particle,
 6814|       |	* if min/max is invalid, since it could confuse the build of the
 6815|       |	* content model.
 6816|       |	*/
 6817|       |	/*
 6818|       |	* 3.9.6 Schema Component Constraint: Particle Correct
 6819|       |	*
 6820|       |	*/
 6821|    633|	if (maxOccurs < 1) {
  ------------------
  |  Branch (6821:6): [True: 3, False: 630]
  ------------------
 6822|       |	    /*
 6823|       |	    * 2.2 {max occurs} must be greater than or equal to 1.
 6824|       |	    */
 6825|      3|	    xmlSchemaPCustomAttrErr(ctxt,
 6826|      3|		XML_SCHEMAP_P_PROPS_CORRECT_2_2,
 6827|      3|		NULL, NULL,
 6828|      3|		xmlSchemaGetPropNode(node, "maxOccurs"),
 6829|      3|		"The value must be greater than or equal to 1");
 6830|      3|	    return (XML_SCHEMAP_P_PROPS_CORRECT_2_2);
 6831|    630|	} else if (minOccurs > maxOccurs) {
  ------------------
  |  Branch (6831:13): [True: 1, False: 629]
  ------------------
 6832|       |	    /*
 6833|       |	    * 2.1 {min occurs} must not be greater than {max occurs}.
 6834|       |	    */
 6835|      1|	    xmlSchemaPCustomAttrErr(ctxt,
 6836|      1|		XML_SCHEMAP_P_PROPS_CORRECT_2_1,
 6837|      1|		NULL, NULL,
 6838|      1|		xmlSchemaGetPropNode(node, "minOccurs"),
 6839|      1|		"The value must not be greater than the value of 'maxOccurs'");
 6840|      1|	    return (XML_SCHEMAP_P_PROPS_CORRECT_2_1);
 6841|      1|	}
 6842|    633|    }
 6843|    732|    return (0);
 6844|    736|}
xmlschemas.c:xmlSchemaPCustomAttrErr:
 2919|     11|{
 2920|     11|    xmlChar *des = NULL;
 2921|       |
 2922|     11|    if (ownerDes == NULL)
  ------------------
  |  Branch (2922:9): [True: 11, False: 0]
  ------------------
 2923|     11|	xmlSchemaFormatItemForReport(&des, NULL, ownerItem, attr->parent);
 2924|      0|    else if (*ownerDes == NULL) {
  ------------------
  |  Branch (2924:14): [True: 0, False: 0]
  ------------------
 2925|      0|	xmlSchemaFormatItemForReport(ownerDes, NULL, ownerItem, attr->parent);
 2926|      0|	des = *ownerDes;
 2927|      0|    } else
 2928|      0|	des = *ownerDes;
 2929|     11|    if (attr == NULL) {
  ------------------
  |  Branch (2929:9): [True: 0, False: 11]
  ------------------
 2930|      0|	xmlSchemaPErrExt(ctxt, NULL, error, NULL, NULL, NULL,
 2931|      0|	    "%s, attribute '%s': %s.\n",
 2932|      0|	    BAD_CAST des, (const xmlChar *) "Unknown",
  ------------------
  |  |   35|      0|#define BAD_CAST (xmlChar *)
  ------------------
 2933|      0|	    (const xmlChar *) msg, NULL, NULL);
 2934|     11|    } else {
 2935|     11|	xmlSchemaPErrExt(ctxt, (xmlNodePtr) attr, error, NULL, NULL, NULL,
 2936|     11|	    "%s, attribute '%s': %s.\n",
 2937|     11|	    BAD_CAST des, attr->name, (const xmlChar *) msg, NULL, NULL);
  ------------------
  |  |   35|     11|#define BAD_CAST (xmlChar *)
  ------------------
 2938|     11|    }
 2939|     11|    if (ownerDes == NULL)
  ------------------
  |  Branch (2939:9): [True: 11, False: 0]
  ------------------
 2940|     11|	FREE_AND_NULL(des);
  ------------------
  |  |  320|     11|#define FREE_AND_NULL(str) if ((str) != NULL) { xmlFree((xmlChar *) (str)); str = NULL; }
  |  |  ------------------
  |  |  |  Branch (320:32): [True: 11, False: 0]
  |  |  ------------------
  ------------------
 2941|     11|}
xmlschemas.c:xmlSchemaAddParticle:
 5462|    748|{
 5463|    748|    xmlSchemaParticlePtr ret = NULL;
 5464|    748|    if (ctxt == NULL)
  ------------------
  |  Branch (5464:9): [True: 0, False: 748]
  ------------------
 5465|      0|        return (NULL);
 5466|       |
 5467|    748|    ret = (xmlSchemaParticlePtr)
 5468|    748|	xmlMalloc(sizeof(xmlSchemaParticle));
 5469|    748|    if (ret == NULL) {
  ------------------
  |  Branch (5469:9): [True: 0, False: 748]
  ------------------
 5470|      0|	xmlSchemaPErrMemory(ctxt, "allocating particle component",
 5471|      0|	    NULL);
 5472|      0|	return (NULL);
 5473|      0|    }
 5474|    748|    ret->type = XML_SCHEMA_TYPE_PARTICLE;
 5475|    748|    ret->annot = NULL;
 5476|    748|    ret->node = node;
 5477|    748|    ret->minOccurs = min;
 5478|    748|    ret->maxOccurs = max;
 5479|    748|    ret->next = NULL;
 5480|    748|    ret->children = NULL;
 5481|       |
 5482|    748|    WXS_ADD_LOCAL(ctxt, ret);
  ------------------
  |  |  291|    748|    do { \
  |  |  292|    748|        if (xmlSchemaAddItemSize(&(WXS_BUCKET(ctx)->locals), 10, item) < 0) { \
  |  |  ------------------
  |  |  |  |  286|    748|#define WXS_BUCKET(ctx) WXS_CONSTRUCTOR((ctx))->bucket
  |  |  |  |  ------------------
  |  |  |  |  |  |  278|    748|#define WXS_CONSTRUCTOR(ctx) (ctx)->constructor
  |  |  |  |  ------------------
  |  |  ------------------
  |  |  |  Branch (292:13): [True: 0, False: 748]
  |  |  ------------------
  |  |  293|      0|            xmlFree(item); \
  |  |  294|      0|            item = NULL; \
  |  |  295|      0|        } \
  |  |  296|    748|    } while (0)
  |  |  ------------------
  |  |  |  Branch (296:14): [Folded - Ignored]
  |  |  ------------------
  ------------------
 5483|       |    /*
 5484|       |    * Note that addition to pending components will be done locally
 5485|       |    * to the specific parsing function, since the most particles
 5486|       |    * need not to be fixed up (i.e. the reference to be resolved).
 5487|       |    * REMOVED: WXS_ADD_PENDING(ctxt, ret);
 5488|       |    */
 5489|    748|    return (ret);
 5490|    748|}
xmlschemas.c:xmlSchemaParseAny:
 6862|     19|{
 6863|     19|    xmlSchemaParticlePtr particle;
 6864|     19|    xmlNodePtr child = NULL;
 6865|     19|    xmlSchemaWildcardPtr wild;
 6866|     19|    int min, max;
 6867|     19|    xmlAttrPtr attr;
 6868|     19|    xmlSchemaAnnotPtr annot = NULL;
 6869|       |
 6870|     19|    if ((ctxt == NULL) || (schema == NULL) || (node == NULL))
  ------------------
  |  Branch (6870:9): [True: 0, False: 19]
  |  Branch (6870:27): [True: 0, False: 19]
  |  Branch (6870:47): [True: 0, False: 19]
  ------------------
 6871|      0|        return (NULL);
 6872|       |    /*
 6873|       |    * Check for illegal attributes.
 6874|       |    */
 6875|     19|    attr = node->properties;
 6876|     70|    while (attr != NULL) {
  ------------------
  |  Branch (6876:12): [True: 51, False: 19]
  ------------------
 6877|     51|	if (attr->ns == NULL) {
  ------------------
  |  Branch (6877:6): [True: 51, False: 0]
  ------------------
 6878|     51|	    if ((!xmlStrEqual(attr->name, BAD_CAST "id")) &&
  ------------------
  |  |   35|     51|#define BAD_CAST (xmlChar *)
  ------------------
  |  Branch (6878:10): [True: 51, False: 0]
  ------------------
 6879|     51|		(!xmlStrEqual(attr->name, BAD_CAST "minOccurs")) &&
  ------------------
  |  |   35|     51|#define BAD_CAST (xmlChar *)
  ------------------
  |  Branch (6879:3): [True: 46, False: 5]
  ------------------
 6880|     51|		(!xmlStrEqual(attr->name, BAD_CAST "maxOccurs")) &&
  ------------------
  |  |   35|     46|#define BAD_CAST (xmlChar *)
  ------------------
  |  Branch (6880:3): [True: 36, False: 10]
  ------------------
 6881|     51|	        (!xmlStrEqual(attr->name, BAD_CAST "namespace")) &&
  ------------------
  |  |   35|     36|#define BAD_CAST (xmlChar *)
  ------------------
  |  Branch (6881:10): [True: 19, False: 17]
  ------------------
 6882|     51|		(!xmlStrEqual(attr->name, BAD_CAST "processContents"))) {
  ------------------
  |  |   35|     19|#define BAD_CAST (xmlChar *)
  ------------------
  |  Branch (6882:3): [True: 0, False: 19]
  ------------------
 6883|      0|		xmlSchemaPIllegalAttrErr(ctxt,
 6884|      0|		    XML_SCHEMAP_S4S_ATTR_NOT_ALLOWED, NULL, attr);
 6885|      0|	    }
 6886|     51|	} else if (xmlStrEqual(attr->ns->href, xmlSchemaNs)) {
  ------------------
  |  Branch (6886:13): [True: 0, False: 0]
  ------------------
 6887|      0|	    xmlSchemaPIllegalAttrErr(ctxt,
 6888|      0|		XML_SCHEMAP_S4S_ATTR_NOT_ALLOWED, NULL, attr);
 6889|      0|	}
 6890|     51|	attr = attr->next;
 6891|     51|    }
 6892|     19|    xmlSchemaPValAttrID(ctxt, node, BAD_CAST "id");
  ------------------
  |  |   35|     19|#define BAD_CAST (xmlChar *)
  ------------------
 6893|       |    /*
 6894|       |    * minOccurs/maxOccurs.
 6895|       |    */
 6896|     19|    max = xmlGetMaxOccurs(ctxt, node, 0, UNBOUNDED, 1,
  ------------------
  |  |   98|     19|#define UNBOUNDED (1 << 30)
  ------------------
 6897|     19|	"(xs:nonNegativeInteger | unbounded)");
 6898|     19|    min = xmlGetMinOccurs(ctxt, node, 0, -1, 1,
 6899|     19|	"xs:nonNegativeInteger");
 6900|     19|    xmlSchemaPCheckParticleCorrect_2(ctxt, NULL, node, min, max);
 6901|       |    /*
 6902|       |    * Create & parse the wildcard.
 6903|       |    */
 6904|     19|    wild = xmlSchemaAddWildcard(ctxt, schema, XML_SCHEMA_TYPE_ANY, node);
 6905|     19|    if (wild == NULL)
  ------------------
  |  Branch (6905:9): [True: 0, False: 19]
  ------------------
 6906|      0|	return (NULL);
 6907|     19|    xmlSchemaParseWildcardNs(ctxt, schema, wild, node);
 6908|       |    /*
 6909|       |    * And now for the children...
 6910|       |    */
 6911|     19|    child = node->children;
 6912|     19|    if (IS_SCHEMA(child, "annotation")) {
  ------------------
  |  |  316|     19|   ((node != NULL) && (node->ns != NULL) && \
  |  |  ------------------
  |  |  |  Branch (316:5): [True: 0, False: 19]
  |  |  |  Branch (316:23): [True: 0, False: 0]
  |  |  ------------------
  |  |  317|     19|    (xmlStrEqual(node->name, (const xmlChar *) type)) && \
  |  |  ------------------
  |  |  |  Branch (317:5): [True: 0, False: 0]
  |  |  ------------------
  |  |  318|     19|    (xmlStrEqual(node->ns->href, xmlSchemaNs)))
  |  |  ------------------
  |  |  |  Branch (318:5): [True: 0, False: 0]
  |  |  ------------------
  ------------------
 6913|      0|        annot = xmlSchemaParseAnnotation(ctxt, child, 1);
 6914|      0|        child = child->next;
 6915|      0|    }
 6916|     19|    if (child != NULL) {
  ------------------
  |  Branch (6916:9): [True: 0, False: 19]
  ------------------
 6917|      0|	xmlSchemaPContentErr(ctxt,
 6918|      0|	    XML_SCHEMAP_S4S_ELEM_NOT_ALLOWED,
 6919|      0|	    NULL, node, child,
 6920|      0|	    NULL, "(annotation?)");
 6921|      0|    }
 6922|       |    /*
 6923|       |    * No component if minOccurs==maxOccurs==0.
 6924|       |    */
 6925|     19|    if ((min == 0) && (max == 0)) {
  ------------------
  |  Branch (6925:9): [True: 4, False: 15]
  |  Branch (6925:23): [True: 0, False: 4]
  ------------------
 6926|       |	/* Don't free the wildcard, since it's already on the list. */
 6927|      0|	return (NULL);
 6928|      0|    }
 6929|       |    /*
 6930|       |    * Create the particle.
 6931|       |    */
 6932|     19|    particle = xmlSchemaAddParticle(ctxt, node, min, max);
 6933|     19|    if (particle == NULL)
  ------------------
  |  Branch (6933:9): [True: 0, False: 19]
  ------------------
 6934|      0|        return (NULL);
 6935|     19|    particle->annot = annot;
 6936|     19|    particle->children = (xmlSchemaTreeItemPtr) wild;
 6937|       |
 6938|     19|    return (particle);
 6939|     19|}
xmlschemas.c:xmlSchemaAddWildcard:
 5609|    134|{
 5610|    134|    xmlSchemaWildcardPtr ret = NULL;
 5611|       |
 5612|    134|    if ((ctxt == NULL) || (schema == NULL))
  ------------------
  |  Branch (5612:9): [True: 0, False: 134]
  |  Branch (5612:27): [True: 0, False: 134]
  ------------------
 5613|      0|        return (NULL);
 5614|       |
 5615|    134|    ret = (xmlSchemaWildcardPtr) xmlMalloc(sizeof(xmlSchemaWildcard));
 5616|    134|    if (ret == NULL) {
  ------------------
  |  Branch (5616:9): [True: 0, False: 134]
  ------------------
 5617|      0|        xmlSchemaPErrMemory(ctxt, "adding wildcard", NULL);
 5618|      0|        return (NULL);
 5619|      0|    }
 5620|    134|    memset(ret, 0, sizeof(xmlSchemaWildcard));
 5621|    134|    ret->type = type;
 5622|    134|    ret->node = node;
 5623|    134|    WXS_ADD_LOCAL(ctxt, ret);
  ------------------
  |  |  291|    134|    do { \
  |  |  292|    134|        if (xmlSchemaAddItemSize(&(WXS_BUCKET(ctx)->locals), 10, item) < 0) { \
  |  |  ------------------
  |  |  |  |  286|    134|#define WXS_BUCKET(ctx) WXS_CONSTRUCTOR((ctx))->bucket
  |  |  |  |  ------------------
  |  |  |  |  |  |  278|    134|#define WXS_CONSTRUCTOR(ctx) (ctx)->constructor
  |  |  |  |  ------------------
  |  |  ------------------
  |  |  |  Branch (292:13): [True: 0, False: 134]
  |  |  ------------------
  |  |  293|      0|            xmlFree(item); \
  |  |  294|      0|            item = NULL; \
  |  |  295|      0|        } \
  |  |  296|    134|    } while (0)
  |  |  ------------------
  |  |  |  Branch (296:14): [Folded - Ignored]
  |  |  ------------------
  ------------------
 5624|    134|    return (ret);
 5625|    134|}
xmlschemas.c:xmlSchemaParseWildcardNs:
 6695|    134|{
 6696|    134|    const xmlChar *pc, *ns, *dictnsItem;
 6697|    134|    int ret = 0;
 6698|    134|    xmlChar *nsItem;
 6699|    134|    xmlSchemaWildcardNsPtr tmp, lastNs = NULL;
 6700|    134|    xmlAttrPtr attr;
 6701|       |
 6702|    134|    pc = xmlSchemaGetProp(ctxt, node, "processContents");
 6703|    134|    if ((pc == NULL)
  ------------------
  |  Branch (6703:9): [True: 24, False: 110]
  ------------------
 6704|    134|        || (xmlStrEqual(pc, (const xmlChar *) "strict"))) {
  ------------------
  |  Branch (6704:12): [True: 1, False: 109]
  ------------------
 6705|     25|        wildc->processContents = XML_SCHEMAS_ANY_STRICT;
  ------------------
  |  |  195|     25|#define XML_SCHEMAS_ANY_STRICT        3
  ------------------
 6706|    109|    } else if (xmlStrEqual(pc, (const xmlChar *) "skip")) {
  ------------------
  |  Branch (6706:16): [True: 14, False: 95]
  ------------------
 6707|     14|        wildc->processContents = XML_SCHEMAS_ANY_SKIP;
  ------------------
  |  |  181|     14|#define XML_SCHEMAS_ANY_SKIP        1
  ------------------
 6708|     95|    } else if (xmlStrEqual(pc, (const xmlChar *) "lax")) {
  ------------------
  |  Branch (6708:16): [True: 95, False: 0]
  ------------------
 6709|     95|        wildc->processContents = XML_SCHEMAS_ANY_LAX;
  ------------------
  |  |  188|     95|#define XML_SCHEMAS_ANY_LAX                2
  ------------------
 6710|     95|    } else {
 6711|      0|        xmlSchemaPSimpleTypeErr(ctxt,
 6712|      0|	    XML_SCHEMAP_S4S_ATTR_INVALID_VALUE,
 6713|      0|	    NULL, node,
 6714|      0|	    NULL, "(strict | skip | lax)", pc,
 6715|      0|	    NULL, NULL, NULL);
 6716|      0|        wildc->processContents = XML_SCHEMAS_ANY_STRICT;
  ------------------
  |  |  195|      0|#define XML_SCHEMAS_ANY_STRICT        3
  ------------------
 6717|      0|	ret = XML_SCHEMAP_S4S_ATTR_INVALID_VALUE;
 6718|      0|    }
 6719|       |    /*
 6720|       |     * Build the namespace constraints.
 6721|       |     */
 6722|    134|    attr = xmlSchemaGetPropNode(node, "namespace");
 6723|    134|    ns = xmlSchemaGetNodeContent(ctxt, (xmlNodePtr) attr);
 6724|    134|    if (ns == NULL)
  ------------------
  |  Branch (6724:9): [True: 0, False: 134]
  ------------------
 6725|      0|        return (-1);
 6726|    134|    if ((attr == NULL) || (xmlStrEqual(ns, BAD_CAST "##any")))
  ------------------
  |  |   35|    132|#define BAD_CAST (xmlChar *)
  ------------------
  |  Branch (6726:9): [True: 2, False: 132]
  |  Branch (6726:27): [True: 26, False: 106]
  ------------------
 6727|     28|	wildc->any = 1;
 6728|    106|    else if (xmlStrEqual(ns, BAD_CAST "##other")) {
  ------------------
  |  |   35|    106|#define BAD_CAST (xmlChar *)
  ------------------
  |  Branch (6728:14): [True: 53, False: 53]
  ------------------
 6729|     53|	wildc->negNsSet = xmlSchemaNewWildcardNsConstraint(ctxt);
 6730|     53|	if (wildc->negNsSet == NULL) {
  ------------------
  |  Branch (6730:6): [True: 0, False: 53]
  ------------------
 6731|      0|	    return (-1);
 6732|      0|	}
 6733|     53|	wildc->negNsSet->value = ctxt->targetNamespace;
 6734|     53|    } else {
 6735|     53|	const xmlChar *end, *cur;
 6736|       |
 6737|     53|	cur = ns;
 6738|    107|	do {
 6739|    107|	    while (IS_BLANK_CH(*cur))
 6740|     70|		cur++;
 6741|    107|	    end = cur;
 6742|  1.26k|	    while ((*end != 0) && (!(IS_BLANK_CH(*end))))
  ------------------
  |  |  151|  1.21k|#define IS_BLANK_CH(c)  xmlIsBlank_ch(c)
  |  |  ------------------
  |  |  |  |   88|  1.21k|#define xmlIsBlank_ch(c)	(((c) == 0x20) || \
  |  |  |  |  ------------------
  |  |  |  |  |  Branch (88:27): [True: 54, False: 1.16k]
  |  |  |  |  ------------------
  |  |  |  |   89|  1.21k|				 ((0x9 <= (c)) && ((c) <= 0xa)) || \
  |  |  |  |  ------------------
  |  |  |  |  |  Branch (89:7): [True: 1.16k, False: 0]
  |  |  |  |  |  Branch (89:23): [True: 0, False: 1.16k]
  |  |  |  |  ------------------
  |  |  |  |   90|  1.21k|				 ((c) == 0xd))
  |  |  |  |  ------------------
  |  |  |  |  |  Branch (90:6): [True: 0, False: 1.16k]
  |  |  |  |  ------------------
  |  |  ------------------
  ------------------
  |  Branch (6742:13): [True: 1.21k, False: 53]
  ------------------
 6743|  1.16k|		end++;
 6744|    107|	    if (end == cur)
  ------------------
  |  Branch (6744:10): [True: 3, False: 104]
  ------------------
 6745|      3|		break;
 6746|    104|	    nsItem = xmlStrndup(cur, end - cur);
 6747|    104|	    if ((xmlStrEqual(nsItem, BAD_CAST "##other")) ||
  ------------------
  |  |   35|    104|#define BAD_CAST (xmlChar *)
  ------------------
  |  Branch (6747:10): [True: 0, False: 104]
  ------------------
 6748|    104|		    (xmlStrEqual(nsItem, BAD_CAST "##any"))) {
  ------------------
  |  |   35|    104|#define BAD_CAST (xmlChar *)
  ------------------
  |  Branch (6748:7): [True: 0, False: 104]
  ------------------
 6749|      0|		xmlSchemaPSimpleTypeErr(ctxt,
 6750|      0|		    XML_SCHEMAP_WILDCARD_INVALID_NS_MEMBER,
 6751|      0|		    NULL, (xmlNodePtr) attr,
 6752|      0|		    NULL,
 6753|      0|		    "((##any | ##other) | List of (xs:anyURI | "
 6754|      0|		    "(##targetNamespace | ##local)))",
 6755|      0|		    nsItem, NULL, NULL, NULL);
 6756|      0|		ret = XML_SCHEMAP_WILDCARD_INVALID_NS_MEMBER;
 6757|    104|	    } else {
 6758|    104|		if (xmlStrEqual(nsItem, BAD_CAST "##targetNamespace")) {
  ------------------
  |  |   35|    104|#define BAD_CAST (xmlChar *)
  ------------------
  |  Branch (6758:7): [True: 30, False: 74]
  ------------------
 6759|     30|		    dictnsItem = ctxt->targetNamespace;
 6760|     74|		} else if (xmlStrEqual(nsItem, BAD_CAST "##local")) {
  ------------------
  |  |   35|     74|#define BAD_CAST (xmlChar *)
  ------------------
  |  Branch (6760:14): [True: 30, False: 44]
  ------------------
 6761|     30|		    dictnsItem = NULL;
 6762|     44|		} else {
 6763|       |		    /*
 6764|       |		    * Validate the item (anyURI).
 6765|       |		    */
 6766|     44|		    xmlSchemaPValAttrNodeValue(ctxt, NULL, attr,
 6767|     44|			nsItem, xmlSchemaGetBuiltInType(XML_SCHEMAS_ANYURI));
 6768|     44|		    dictnsItem = xmlDictLookup(ctxt->dict, nsItem, -1);
 6769|     44|		}
 6770|       |		/*
 6771|       |		* Avoid duplicate namespaces.
 6772|       |		*/
 6773|    104|		tmp = wildc->nsSet;
 6774|    170|		while (tmp != NULL) {
  ------------------
  |  Branch (6774:10): [True: 66, False: 104]
  ------------------
 6775|     66|		    if (dictnsItem == tmp->value)
  ------------------
  |  Branch (6775:11): [True: 0, False: 66]
  ------------------
 6776|      0|			break;
 6777|     66|		    tmp = tmp->next;
 6778|     66|		}
 6779|    104|		if (tmp == NULL) {
  ------------------
  |  Branch (6779:7): [True: 104, False: 0]
  ------------------
 6780|    104|		    tmp = xmlSchemaNewWildcardNsConstraint(ctxt);
 6781|    104|		    if (tmp == NULL) {
  ------------------
  |  Branch (6781:11): [True: 0, False: 104]
  ------------------
 6782|      0|			xmlFree(nsItem);
 6783|      0|			return (-1);
 6784|      0|		    }
 6785|    104|		    tmp->value = dictnsItem;
 6786|    104|		    tmp->next = NULL;
 6787|    104|		    if (wildc->nsSet == NULL)
  ------------------
  |  Branch (6787:11): [True: 53, False: 51]
  ------------------
 6788|     53|			wildc->nsSet = tmp;
 6789|     51|		    else if (lastNs != NULL)
  ------------------
  |  Branch (6789:16): [True: 51, False: 0]
  ------------------
 6790|     51|			lastNs->next = tmp;
 6791|    104|		    lastNs = tmp;
 6792|    104|		}
 6793|       |
 6794|    104|	    }
 6795|    104|	    xmlFree(nsItem);
 6796|    104|	    cur = end;
 6797|    104|	} while (*cur != 0);
  ------------------
  |  Branch (6797:11): [True: 54, False: 50]
  ------------------
 6798|     53|    }
 6799|    134|    return (ret);
 6800|    134|}
xmlschemas.c:xmlSchemaNewWildcardNsConstraint:
 5550|    175|{
 5551|    175|    xmlSchemaWildcardNsPtr ret;
 5552|       |
 5553|    175|    ret = (xmlSchemaWildcardNsPtr)
 5554|    175|	xmlMalloc(sizeof(xmlSchemaWildcardNs));
 5555|    175|    if (ret == NULL) {
  ------------------
  |  Branch (5555:9): [True: 0, False: 175]
  ------------------
 5556|      0|	xmlSchemaPErrMemory(ctxt, "creating wildcard namespace constraint", NULL);
 5557|      0|	return (NULL);
 5558|      0|    }
 5559|    175|    ret->value = NULL;
 5560|    175|    ret->next = NULL;
 5561|    175|    return (ret);
 5562|    175|}
xmlschemas.c:xmlSchemaParseModelGroupDefRef:
 9327|      9|{
 9328|      9|    xmlSchemaParticlePtr item;
 9329|      9|    xmlNodePtr child = NULL;
 9330|      9|    xmlAttrPtr attr;
 9331|      9|    const xmlChar *ref = NULL, *refNs = NULL;
 9332|      9|    int min, max;
 9333|       |
 9334|      9|    if ((ctxt == NULL) || (schema == NULL) || (node == NULL))
  ------------------
  |  Branch (9334:9): [True: 0, False: 9]
  |  Branch (9334:27): [True: 0, False: 9]
  |  Branch (9334:47): [True: 0, False: 9]
  ------------------
 9335|      0|        return (NULL);
 9336|       |
 9337|      9|    attr = xmlSchemaGetPropNode(node, "ref");
 9338|      9|    if (attr == NULL) {
  ------------------
  |  Branch (9338:9): [True: 0, False: 9]
  ------------------
 9339|      0|	xmlSchemaPMissingAttrErr(ctxt,
 9340|      0|	    XML_SCHEMAP_S4S_ATTR_MISSING,
 9341|      0|	    NULL, node, "ref", NULL);
 9342|      0|	return (NULL);
 9343|      9|    } else if (xmlSchemaPValAttrNodeQName(ctxt, schema, NULL,
  ------------------
  |  Branch (9343:16): [True: 0, False: 9]
  ------------------
 9344|      9|	attr, &refNs, &ref) != 0) {
 9345|      0|	return (NULL);
 9346|      0|    }
 9347|      9|    xmlSchemaCheckReference(ctxt, schema, node, attr, refNs);
 9348|      9|    min = xmlGetMinOccurs(ctxt, node, 0, -1, 1, "xs:nonNegativeInteger");
 9349|      9|    max = xmlGetMaxOccurs(ctxt, node, 0, UNBOUNDED, 1,
  ------------------
  |  |   98|      9|#define UNBOUNDED (1 << 30)
  ------------------
 9350|      9|	"(xs:nonNegativeInteger | unbounded)");
 9351|       |    /*
 9352|       |    * Check for illegal attributes.
 9353|       |    */
 9354|      9|    attr = node->properties;
 9355|     21|    while (attr != NULL) {
  ------------------
  |  Branch (9355:12): [True: 12, False: 9]
  ------------------
 9356|     12|	if (attr->ns == NULL) {
  ------------------
  |  Branch (9356:6): [True: 12, False: 0]
  ------------------
 9357|     12|	    if ((!xmlStrEqual(attr->name, BAD_CAST "ref")) &&
  ------------------
  |  |   35|     12|#define BAD_CAST (xmlChar *)
  ------------------
  |  Branch (9357:10): [True: 3, False: 9]
  ------------------
 9358|     12|		(!xmlStrEqual(attr->name, BAD_CAST "id")) &&
  ------------------
  |  |   35|      3|#define BAD_CAST (xmlChar *)
  ------------------
  |  Branch (9358:3): [True: 3, False: 0]
  ------------------
 9359|     12|		(!xmlStrEqual(attr->name, BAD_CAST "minOccurs")) &&
  ------------------
  |  |   35|      3|#define BAD_CAST (xmlChar *)
  ------------------
  |  Branch (9359:3): [True: 2, False: 1]
  ------------------
 9360|     12|		(!xmlStrEqual(attr->name, BAD_CAST "maxOccurs"))) {
  ------------------
  |  |   35|      2|#define BAD_CAST (xmlChar *)
  ------------------
  |  Branch (9360:3): [True: 0, False: 2]
  ------------------
 9361|      0|		xmlSchemaPIllegalAttrErr(ctxt,
 9362|      0|		    XML_SCHEMAP_S4S_ATTR_NOT_ALLOWED, NULL, attr);
 9363|      0|	    }
 9364|     12|	} else if (xmlStrEqual(attr->ns->href, xmlSchemaNs)) {
  ------------------
  |  Branch (9364:13): [True: 0, False: 0]
  ------------------
 9365|      0|	    xmlSchemaPIllegalAttrErr(ctxt,
 9366|      0|		XML_SCHEMAP_S4S_ATTR_NOT_ALLOWED, NULL, attr);
 9367|      0|	}
 9368|     12|	attr = attr->next;
 9369|     12|    }
 9370|      9|    xmlSchemaPValAttrID(ctxt, node, BAD_CAST "id");
  ------------------
  |  |   35|      9|#define BAD_CAST (xmlChar *)
  ------------------
 9371|      9|    item = xmlSchemaAddParticle(ctxt, node, min, max);
 9372|      9|    if (item == NULL)
  ------------------
  |  Branch (9372:9): [True: 0, False: 9]
  ------------------
 9373|      0|	return (NULL);
 9374|       |    /*
 9375|       |    * Create a qname-reference and set as the term; it will be substituted
 9376|       |    * for the model group after the reference has been resolved.
 9377|       |    */
 9378|      9|    item->children = (xmlSchemaTreeItemPtr)
 9379|      9|	xmlSchemaNewQNameRef(ctxt, XML_SCHEMA_TYPE_GROUP, ref, refNs);
 9380|      9|    xmlSchemaPCheckParticleCorrect_2(ctxt, item, node, min, max);
 9381|       |    /*
 9382|       |    * And now for the children...
 9383|       |    */
 9384|      9|    child = node->children;
 9385|       |    /* TODO: Is annotation even allowed for a model group reference? */
 9386|      9|    if (IS_SCHEMA(child, "annotation")) {
  ------------------
  |  |  316|      9|   ((node != NULL) && (node->ns != NULL) && \
  |  |  ------------------
  |  |  |  Branch (316:5): [True: 0, False: 9]
  |  |  |  Branch (316:23): [True: 0, False: 0]
  |  |  ------------------
  |  |  317|      9|    (xmlStrEqual(node->name, (const xmlChar *) type)) && \
  |  |  ------------------
  |  |  |  Branch (317:5): [True: 0, False: 0]
  |  |  ------------------
  |  |  318|      9|    (xmlStrEqual(node->ns->href, xmlSchemaNs)))
  |  |  ------------------
  |  |  |  Branch (318:5): [True: 0, False: 0]
  |  |  ------------------
  ------------------
 9387|       |	/*
 9388|       |	* TODO: What to do exactly with the annotation?
 9389|       |	*/
 9390|      0|	item->annot = xmlSchemaParseAnnotation(ctxt, child, 1);
 9391|      0|	child = child->next;
 9392|      0|    }
 9393|      9|    if (child != NULL) {
  ------------------
  |  Branch (9393:9): [True: 0, False: 9]
  ------------------
 9394|      0|	xmlSchemaPContentErr(ctxt,
 9395|      0|	    XML_SCHEMAP_S4S_ELEM_NOT_ALLOWED,
 9396|      0|	    NULL, node, child, NULL,
 9397|      0|	    "(annotation?)");
 9398|      0|    }
 9399|       |    /*
 9400|       |    * Corresponds to no component at all if minOccurs==maxOccurs==0.
 9401|       |    */
 9402|      9|    if ((min == 0) && (max == 0))
  ------------------
  |  Branch (9402:9): [True: 1, False: 8]
  |  Branch (9402:23): [True: 0, False: 1]
  ------------------
 9403|      0|	return (NULL);
 9404|       |
 9405|      9|    return ((xmlSchemaTreeItemPtr) item);
 9406|      9|}
xmlschemas.c:xmlSchemaCheckReference:
 6382|    587|{
 6383|       |    /* TODO: Pointer comparison instead? */
 6384|    587|    if (xmlStrEqual(pctxt->targetNamespace, namespaceName))
  ------------------
  |  Branch (6384:9): [True: 472, False: 115]
  ------------------
 6385|    472|	return (0);
 6386|    115|    if (xmlStrEqual(xmlSchemaNs, namespaceName))
  ------------------
  |  Branch (6386:9): [True: 102, False: 13]
  ------------------
 6387|    102|	return (0);
 6388|       |    /*
 6389|       |    * Check if the referenced namespace was <import>ed.
 6390|       |    */
 6391|     13|    if (WXS_BUCKET(pctxt)->relations != NULL) {
  ------------------
  |  |  286|     13|#define WXS_BUCKET(ctx) WXS_CONSTRUCTOR((ctx))->bucket
  |  |  ------------------
  |  |  |  |  278|     13|#define WXS_CONSTRUCTOR(ctx) (ctx)->constructor
  |  |  ------------------
  ------------------
  |  Branch (6391:9): [True: 13, False: 0]
  ------------------
 6392|     13|	xmlSchemaSchemaRelationPtr rel;
 6393|       |
 6394|     13|	rel = WXS_BUCKET(pctxt)->relations;
  ------------------
  |  |  286|     13|#define WXS_BUCKET(ctx) WXS_CONSTRUCTOR((ctx))->bucket
  |  |  ------------------
  |  |  |  |  278|     13|#define WXS_CONSTRUCTOR(ctx) (ctx)->constructor
  |  |  ------------------
  ------------------
 6395|     14|	do {
 6396|     14|	    if (WXS_IS_BUCKET_IMPMAIN(rel->type) &&
  ------------------
  |  |  199|     28|#define WXS_IS_BUCKET_IMPMAIN(t) (((t) == XML_SCHEMA_SCHEMA_MAIN) || \
  |  |  ------------------
  |  |  |  |  371|     14|#define XML_SCHEMA_SCHEMA_MAIN 0
  |  |  ------------------
  |  |  |  Branch (199:35): [True: 0, False: 14]
  |  |  ------------------
  |  |  200|     28|    ((t) == XML_SCHEMA_SCHEMA_IMPORT))
  |  |  ------------------
  |  |  |  |  372|     14|#define XML_SCHEMA_SCHEMA_IMPORT 1
  |  |  ------------------
  |  |  |  Branch (200:5): [True: 14, False: 0]
  |  |  ------------------
  ------------------
 6397|     14|		xmlStrEqual(namespaceName, rel->importNamespace))
  ------------------
  |  Branch (6397:3): [True: 13, False: 1]
  ------------------
 6398|     13|		return (0);
 6399|      1|	    rel = rel->next;
 6400|      1|	} while (rel != NULL);
  ------------------
  |  Branch (6400:11): [True: 1, False: 0]
  ------------------
 6401|     13|    }
 6402|       |    /*
 6403|       |    * No matching <import>ed namespace found.
 6404|       |    */
 6405|      0|    {
 6406|      0|	xmlNodePtr n = (attr != NULL) ? (xmlNodePtr) attr : node;
  ------------------
  |  Branch (6406:17): [True: 0, False: 0]
  ------------------
 6407|       |
 6408|      0|	if (namespaceName == NULL)
  ------------------
  |  Branch (6408:6): [True: 0, False: 0]
  ------------------
 6409|      0|	    xmlSchemaCustomErr(ACTXT_CAST pctxt,
  ------------------
  |  |  121|      0|#define ACTXT_CAST (xmlSchemaAbstractCtxtPtr)
  ------------------
 6410|      0|		XML_SCHEMAP_SRC_RESOLVE, n, NULL,
 6411|      0|		"References from this schema to components in no "
 6412|      0|		"namespace are not allowed, since not indicated by an "
 6413|      0|		"import statement", NULL, NULL);
 6414|      0|	else
 6415|      0|	    xmlSchemaCustomErr(ACTXT_CAST pctxt,
  ------------------
  |  |  121|      0|#define ACTXT_CAST (xmlSchemaAbstractCtxtPtr)
  ------------------
 6416|      0|		XML_SCHEMAP_SRC_RESOLVE, n, NULL,
 6417|      0|		"References from this schema to components in the "
 6418|      0|		"namespace '%s' are not allowed, since not indicated by an "
 6419|      0|		"import statement", namespaceName, NULL);
 6420|      0|    }
 6421|      0|    return (XML_SCHEMAP_SRC_RESOLVE);
 6422|     13|}
xmlschemas.c:xmlSchemaNewQNameRef:
 5363|    373|{
 5364|    373|    xmlSchemaQNameRefPtr ret;
 5365|       |
 5366|    373|    ret = (xmlSchemaQNameRefPtr)
 5367|    373|	xmlMalloc(sizeof(xmlSchemaQNameRef));
 5368|    373|    if (ret == NULL) {
  ------------------
  |  Branch (5368:9): [True: 0, False: 373]
  ------------------
 5369|      0|	xmlSchemaPErrMemory(pctxt,
 5370|      0|	    "allocating QName reference item", NULL);
 5371|      0|	return (NULL);
 5372|      0|    }
 5373|    373|    ret->node = NULL;
 5374|    373|    ret->type = XML_SCHEMA_EXTRA_QNAMEREF;
 5375|    373|    ret->name = refName;
 5376|    373|    ret->targetNamespace = refNs;
 5377|    373|    ret->item = NULL;
 5378|    373|    ret->itemType = refType;
 5379|       |    /*
 5380|       |    * Store the reference item in the schema.
 5381|       |    */
 5382|    373|    WXS_ADD_LOCAL(pctxt, ret);
  ------------------
  |  |  291|    373|    do { \
  |  |  292|    373|        if (xmlSchemaAddItemSize(&(WXS_BUCKET(ctx)->locals), 10, item) < 0) { \
  |  |  ------------------
  |  |  |  |  286|    373|#define WXS_BUCKET(ctx) WXS_CONSTRUCTOR((ctx))->bucket
  |  |  |  |  ------------------
  |  |  |  |  |  |  278|    373|#define WXS_CONSTRUCTOR(ctx) (ctx)->constructor
  |  |  |  |  ------------------
  |  |  ------------------
  |  |  |  Branch (292:13): [True: 0, False: 373]
  |  |  ------------------
  |  |  293|      0|            xmlFree(item); \
  |  |  294|      0|            item = NULL; \
  |  |  295|      0|        } \
  |  |  296|    373|    } while (0)
  |  |  ------------------
  |  |  |  Branch (296:14): [Folded - Ignored]
  |  |  ------------------
  ------------------
 5383|    373|    return (ret);
 5384|    373|}
xmlschemas.c:xmlSchemaParseLocalAttributes:
 6438|    407|{
 6439|    407|    void *item;
 6440|       |
 6441|    679|    while ((IS_SCHEMA((*child), "attribute")) ||
  ------------------
  |  |  316|    679|   ((node != NULL) && (node->ns != NULL) && \
  |  |  ------------------
  |  |  |  Branch (316:5): [True: 387, False: 292]
  |  |  |  Branch (316:23): [True: 387, False: 0]
  |  |  ------------------
  |  |  317|    679|    (xmlStrEqual(node->name, (const xmlChar *) type)) && \
  |  |  ------------------
  |  |  |  Branch (317:5): [True: 221, False: 166]
  |  |  ------------------
  |  |  318|    679|    (xmlStrEqual(node->ns->href, xmlSchemaNs)))
  |  |  ------------------
  |  |  |  Branch (318:5): [True: 221, False: 0]
  |  |  ------------------
  ------------------
 6442|    679|           (IS_SCHEMA((*child), "attributeGroup"))) {
  ------------------
  |  |  316|    458|   ((node != NULL) && (node->ns != NULL) && \
  |  |  ------------------
  |  |  |  Branch (316:5): [True: 166, False: 292]
  |  |  |  Branch (316:23): [True: 166, False: 0]
  |  |  ------------------
  |  |  317|    458|    (xmlStrEqual(node->name, (const xmlChar *) type)) && \
  |  |  ------------------
  |  |  |  Branch (317:5): [True: 51, False: 115]
  |  |  ------------------
  |  |  318|    458|    (xmlStrEqual(node->ns->href, xmlSchemaNs)))
  |  |  ------------------
  |  |  |  Branch (318:5): [True: 51, False: 0]
  |  |  ------------------
  ------------------
 6443|    272|        if (IS_SCHEMA((*child), "attribute")) {
  ------------------
  |  |  316|    272|   ((node != NULL) && (node->ns != NULL) && \
  |  |  ------------------
  |  |  |  Branch (316:5): [True: 272, False: 0]
  |  |  |  Branch (316:23): [True: 272, False: 0]
  |  |  ------------------
  |  |  317|    272|    (xmlStrEqual(node->name, (const xmlChar *) type)) && \
  |  |  ------------------
  |  |  |  Branch (317:5): [True: 221, False: 51]
  |  |  ------------------
  |  |  318|    272|    (xmlStrEqual(node->ns->href, xmlSchemaNs)))
  |  |  ------------------
  |  |  |  Branch (318:5): [True: 221, False: 0]
  |  |  ------------------
  ------------------
 6444|    221|	    item = xmlSchemaParseLocalAttribute(ctxt, schema, *child,
 6445|    221|		*list, parentType);
 6446|    221|        } else {
 6447|     51|            item = xmlSchemaParseAttributeGroupRef(ctxt, schema, *child);
 6448|     51|	    if ((item != NULL) && (hasRefs != NULL))
  ------------------
  |  Branch (6448:10): [True: 51, False: 0]
  |  Branch (6448:28): [True: 2, False: 49]
  ------------------
 6449|      2|		*hasRefs = 1;
 6450|     51|        }
 6451|    272|	if (item != NULL) {
  ------------------
  |  Branch (6451:6): [True: 264, False: 8]
  ------------------
 6452|    264|	    if (*list == NULL) {
  ------------------
  |  Branch (6452:10): [True: 172, False: 92]
  ------------------
 6453|       |		/* TODO: Customize grow factor. */
 6454|    172|		*list = xmlSchemaItemListCreate();
 6455|    172|		if (*list == NULL)
  ------------------
  |  Branch (6455:7): [True: 0, False: 172]
  ------------------
 6456|      0|		    return(-1);
 6457|    172|	    }
 6458|    264|	    if (xmlSchemaItemListAddSize(*list, 2, item) == -1)
  ------------------
  |  Branch (6458:10): [True: 0, False: 264]
  ------------------
 6459|      0|		return(-1);
 6460|    264|	}
 6461|    272|        *child = (*child)->next;
 6462|    272|    }
 6463|    407|    return (0);
 6464|    407|}
xmlschemas.c:xmlSchemaParseLocalAttribute:
 7075|    221|{
 7076|    221|    const xmlChar *attrValue, *name = NULL, *ns = NULL;
 7077|    221|    xmlSchemaAttributeUsePtr use = NULL;
 7078|    221|    xmlNodePtr child = NULL;
 7079|    221|    xmlAttrPtr attr;
 7080|    221|    const xmlChar *tmpNs = NULL, *tmpName = NULL, *defValue = NULL;
 7081|    221|    int isRef = 0, occurs = XML_SCHEMAS_ATTR_USE_OPTIONAL;
  ------------------
  |  |  214|    221|#define XML_SCHEMAS_ATTR_USE_OPTIONAL 2
  ------------------
 7082|    221|    int	nberrors, hasForm = 0, defValueType = 0;
 7083|       |
 7084|    221|#define WXS_ATTR_DEF_VAL_DEFAULT 1
 7085|    221|#define WXS_ATTR_DEF_VAL_FIXED 2
 7086|       |
 7087|       |    /*
 7088|       |     * 3.2.3 Constraints on XML Representations of Attribute Declarations
 7089|       |     */
 7090|       |
 7091|    221|    if ((pctxt == NULL) || (schema == NULL) || (node == NULL))
  ------------------
  |  Branch (7091:9): [True: 0, False: 221]
  |  Branch (7091:28): [True: 0, False: 221]
  |  Branch (7091:48): [True: 0, False: 221]
  ------------------
 7092|      0|        return (NULL);
 7093|    221|    attr = xmlSchemaGetPropNode(node, "ref");
 7094|    221|    if (attr != NULL) {
  ------------------
  |  Branch (7094:9): [True: 48, False: 173]
  ------------------
 7095|     48|	if (xmlSchemaPValAttrNodeQName(pctxt, schema,
  ------------------
  |  Branch (7095:6): [True: 0, False: 48]
  ------------------
 7096|     48|	    NULL, attr, &tmpNs, &tmpName) != 0) {
 7097|      0|	    return (NULL);
 7098|      0|	}
 7099|     48|	if (xmlSchemaCheckReference(pctxt, schema, node, attr, tmpNs) != 0)
  ------------------
  |  Branch (7099:6): [True: 0, False: 48]
  ------------------
 7100|      0|	    return(NULL);
 7101|     48|	isRef = 1;
 7102|     48|    }
 7103|    221|    nberrors = pctxt->nberrors;
 7104|       |    /*
 7105|       |    * Check for illegal attributes.
 7106|       |    */
 7107|    221|    attr = node->properties;
 7108|    694|    while (attr != NULL) {
  ------------------
  |  Branch (7108:12): [True: 473, False: 221]
  ------------------
 7109|    473|	if (attr->ns == NULL) {
  ------------------
  |  Branch (7109:6): [True: 472, False: 1]
  ------------------
 7110|    472|	    if (isRef) {
  ------------------
  |  Branch (7110:10): [True: 52, False: 420]
  ------------------
 7111|     52|		if (xmlStrEqual(attr->name, BAD_CAST "id")) {
  ------------------
  |  |   35|     52|#define BAD_CAST (xmlChar *)
  ------------------
  |  Branch (7111:7): [True: 0, False: 52]
  ------------------
 7112|      0|		    xmlSchemaPValAttrNodeID(pctxt, attr);
 7113|      0|		    goto attr_next;
 7114|     52|		} else if (xmlStrEqual(attr->name, BAD_CAST "ref")) {
  ------------------
  |  |   35|     52|#define BAD_CAST (xmlChar *)
  ------------------
  |  Branch (7114:14): [True: 48, False: 4]
  ------------------
 7115|     48|		    goto attr_next;
 7116|     48|		}
 7117|    420|	    } else {
 7118|    420|		if (xmlStrEqual(attr->name, BAD_CAST "name")) {
  ------------------
  |  |   35|    420|#define BAD_CAST (xmlChar *)
  ------------------
  |  Branch (7118:7): [True: 173, False: 247]
  ------------------
 7119|    173|		    goto attr_next;
 7120|    247|		} else if (xmlStrEqual(attr->name, BAD_CAST "id")) {
  ------------------
  |  |   35|    247|#define BAD_CAST (xmlChar *)
  ------------------
  |  Branch (7120:14): [True: 0, False: 247]
  ------------------
 7121|      0|		    xmlSchemaPValAttrNodeID(pctxt, attr);
 7122|      0|		    goto attr_next;
 7123|    247|		} else if (xmlStrEqual(attr->name, BAD_CAST "type")) {
  ------------------
  |  |   35|    247|#define BAD_CAST (xmlChar *)
  ------------------
  |  Branch (7123:14): [True: 152, False: 95]
  ------------------
 7124|    152|		    xmlSchemaPValAttrNodeQName(pctxt, schema, NULL,
 7125|    152|			attr, &tmpNs, &tmpName);
 7126|    152|		    goto attr_next;
 7127|    152|		} else if (xmlStrEqual(attr->name, BAD_CAST "form")) {
  ------------------
  |  |   35|     95|#define BAD_CAST (xmlChar *)
  ------------------
  |  Branch (7127:14): [True: 2, False: 93]
  ------------------
 7128|       |		    /*
 7129|       |		    * Evaluate the target namespace
 7130|       |		    */
 7131|      2|		    hasForm = 1;
 7132|      2|		    attrValue = xmlSchemaGetNodeContent(pctxt,
 7133|      2|			(xmlNodePtr) attr);
 7134|      2|		    if (xmlStrEqual(attrValue, BAD_CAST "qualified")) {
  ------------------
  |  |   35|      2|#define BAD_CAST (xmlChar *)
  ------------------
  |  Branch (7134:11): [True: 2, False: 0]
  ------------------
 7135|      2|			ns = pctxt->targetNamespace;
 7136|      2|		    } else if (!xmlStrEqual(attrValue, BAD_CAST "unqualified"))
  ------------------
  |  |   35|      0|#define BAD_CAST (xmlChar *)
  ------------------
  |  Branch (7136:18): [True: 0, False: 0]
  ------------------
 7137|      0|		    {
 7138|      0|			xmlSchemaPSimpleTypeErr(pctxt,
 7139|      0|			    XML_SCHEMAP_S4S_ATTR_INVALID_VALUE,
 7140|      0|			    NULL, (xmlNodePtr) attr,
 7141|      0|			    NULL, "(qualified | unqualified)",
 7142|      0|			    attrValue, NULL, NULL, NULL);
 7143|      0|		    }
 7144|      2|		    goto attr_next;
 7145|      2|		}
 7146|    420|	    }
 7147|     97|	    if (xmlStrEqual(attr->name, BAD_CAST "use")) {
  ------------------
  |  |   35|     97|#define BAD_CAST (xmlChar *)
  ------------------
  |  Branch (7147:10): [True: 84, False: 13]
  ------------------
 7148|       |
 7149|     84|		attrValue = xmlSchemaGetNodeContent(pctxt, (xmlNodePtr) attr);
 7150|       |		/* TODO: Maybe we need to normalize the value beforehand. */
 7151|     84|		if (xmlStrEqual(attrValue, BAD_CAST "optional"))
  ------------------
  |  |   35|     84|#define BAD_CAST (xmlChar *)
  ------------------
  |  Branch (7151:7): [True: 16, False: 68]
  ------------------
 7152|     16|		    occurs = XML_SCHEMAS_ATTR_USE_OPTIONAL;
  ------------------
  |  |  214|     16|#define XML_SCHEMAS_ATTR_USE_OPTIONAL 2
  ------------------
 7153|     68|		else if (xmlStrEqual(attrValue, BAD_CAST "prohibited"))
  ------------------
  |  |   35|     68|#define BAD_CAST (xmlChar *)
  ------------------
  |  Branch (7153:12): [True: 10, False: 58]
  ------------------
 7154|     10|		    occurs = XML_SCHEMAS_ATTR_USE_PROHIBITED;
  ------------------
  |  |  202|     10|#define XML_SCHEMAS_ATTR_USE_PROHIBITED 0
  ------------------
 7155|     58|		else if (xmlStrEqual(attrValue, BAD_CAST "required"))
  ------------------
  |  |   35|     58|#define BAD_CAST (xmlChar *)
  ------------------
  |  Branch (7155:12): [True: 58, False: 0]
  ------------------
 7156|     58|		    occurs = XML_SCHEMAS_ATTR_USE_REQUIRED;
  ------------------
  |  |  208|     58|#define XML_SCHEMAS_ATTR_USE_REQUIRED 1
  ------------------
 7157|      0|		else {
 7158|      0|		    xmlSchemaPSimpleTypeErr(pctxt,
 7159|      0|			XML_SCHEMAP_INVALID_ATTR_USE,
 7160|      0|			NULL, (xmlNodePtr) attr,
 7161|      0|			NULL, "(optional | prohibited | required)",
 7162|      0|			attrValue, NULL, NULL, NULL);
 7163|      0|		}
 7164|     84|		goto attr_next;
 7165|     84|	    } else if (xmlStrEqual(attr->name, BAD_CAST "default")) {
  ------------------
  |  |   35|     13|#define BAD_CAST (xmlChar *)
  ------------------
  |  Branch (7165:17): [True: 7, False: 6]
  ------------------
 7166|       |		/*
 7167|       |		* 3.2.3 : 1
 7168|       |		* default and fixed must not both be present.
 7169|       |		*/
 7170|      7|		if (defValue) {
  ------------------
  |  Branch (7170:7): [True: 0, False: 7]
  ------------------
 7171|      0|		    xmlSchemaPMutualExclAttrErr(pctxt,
 7172|      0|			XML_SCHEMAP_SRC_ATTRIBUTE_1,
 7173|      0|			NULL, attr, "default", "fixed");
 7174|      7|		} else {
 7175|      7|		    defValue = xmlSchemaGetNodeContent(pctxt, (xmlNodePtr) attr);
 7176|      7|		    defValueType = WXS_ATTR_DEF_VAL_DEFAULT;
  ------------------
  |  | 7084|      7|#define WXS_ATTR_DEF_VAL_DEFAULT 1
  ------------------
 7177|      7|		}
 7178|      7|		goto attr_next;
 7179|      7|	    } else if (xmlStrEqual(attr->name, BAD_CAST "fixed")) {
  ------------------
  |  |   35|      6|#define BAD_CAST (xmlChar *)
  ------------------
  |  Branch (7179:17): [True: 3, False: 3]
  ------------------
 7180|       |		/*
 7181|       |		* 3.2.3 : 1
 7182|       |		* default and fixed must not both be present.
 7183|       |		*/
 7184|      3|		if (defValue) {
  ------------------
  |  Branch (7184:7): [True: 1, False: 2]
  ------------------
 7185|      1|		    xmlSchemaPMutualExclAttrErr(pctxt,
 7186|      1|			XML_SCHEMAP_SRC_ATTRIBUTE_1,
 7187|      1|			NULL, attr, "default", "fixed");
 7188|      2|		} else {
 7189|      2|		    defValue = xmlSchemaGetNodeContent(pctxt, (xmlNodePtr) attr);
 7190|      2|		    defValueType = WXS_ATTR_DEF_VAL_FIXED;
  ------------------
  |  | 7085|      2|#define WXS_ATTR_DEF_VAL_FIXED 2
  ------------------
 7191|      2|		}
 7192|      3|		goto attr_next;
 7193|      3|	    }
 7194|     97|	} else if (! xmlStrEqual(attr->ns->href, xmlSchemaNs))
  ------------------
  |  Branch (7194:13): [True: 1, False: 0]
  ------------------
 7195|      1|	    goto attr_next;
 7196|       |
 7197|      3|	xmlSchemaPIllegalAttrErr(pctxt,
 7198|      3|	    XML_SCHEMAP_S4S_ATTR_NOT_ALLOWED, NULL, attr);
 7199|       |
 7200|    473|attr_next:
 7201|    473|	attr = attr->next;
 7202|    473|    }
 7203|       |    /*
 7204|       |    * 3.2.3 : 2
 7205|       |    * If default and use are both present, use must have
 7206|       |    * the actual value optional.
 7207|       |    */
 7208|    221|    if ((defValueType == WXS_ATTR_DEF_VAL_DEFAULT) &&
  ------------------
  |  | 7084|    221|#define WXS_ATTR_DEF_VAL_DEFAULT 1
  ------------------
  |  Branch (7208:9): [True: 7, False: 214]
  ------------------
 7209|    221|	(occurs != XML_SCHEMAS_ATTR_USE_OPTIONAL)) {
  ------------------
  |  |  214|      7|#define XML_SCHEMAS_ATTR_USE_OPTIONAL 2
  ------------------
  |  Branch (7209:2): [True: 1, False: 6]
  ------------------
 7210|      1|	xmlSchemaPSimpleTypeErr(pctxt,
 7211|      1|	    XML_SCHEMAP_SRC_ATTRIBUTE_2,
 7212|      1|	    NULL, node, NULL,
 7213|      1|	    "(optional | prohibited | required)", NULL,
 7214|      1|	    "The value of the attribute 'use' must be 'optional' "
 7215|      1|	    "if the attribute 'default' is present",
 7216|      1|	    NULL, NULL);
 7217|      1|    }
 7218|       |    /*
 7219|       |    * We want correct attributes.
 7220|       |    */
 7221|    221|    if (nberrors != pctxt->nberrors)
  ------------------
  |  Branch (7221:9): [True: 5, False: 216]
  ------------------
 7222|      5|	return(NULL);
 7223|    216|    if (! isRef) {
  ------------------
  |  Branch (7223:9): [True: 171, False: 45]
  ------------------
 7224|    171|	xmlSchemaAttributePtr attrDecl;
 7225|       |
 7226|       |	/* TODO: move XML_SCHEMAS_QUALIF_ATTR to the parser. */
 7227|    171|	if ((! hasForm) && (schema->flags & XML_SCHEMAS_QUALIF_ATTR))
  ------------------
  |  |  868|    169|#define XML_SCHEMAS_QUALIF_ATTR            1 << 1
  ------------------
  |  Branch (7227:6): [True: 169, False: 2]
  |  Branch (7227:21): [True: 5, False: 164]
  ------------------
 7228|      5|	    ns = pctxt->targetNamespace;
 7229|       |	/*
 7230|       |	* 3.2.6 Schema Component Constraint: xsi: Not Allowed
 7231|       |	* TODO: Move this to the component layer.
 7232|       |	*/
 7233|    171|	if (xmlStrEqual(ns, xmlSchemaInstanceNs)) {
  ------------------
  |  Branch (7233:6): [True: 1, False: 170]
  ------------------
 7234|      1|	    xmlSchemaCustomErr(ACTXT_CAST pctxt,
  ------------------
  |  |  121|      1|#define ACTXT_CAST (xmlSchemaAbstractCtxtPtr)
  ------------------
 7235|      1|		XML_SCHEMAP_NO_XSI,
 7236|      1|		node, NULL,
 7237|      1|		"The target namespace must not match '%s'",
 7238|      1|		xmlSchemaInstanceNs, NULL);
 7239|      1|	}
 7240|    171|	attr = xmlSchemaGetPropNode(node, "name");
 7241|    171|	if (attr == NULL) {
  ------------------
  |  Branch (7241:6): [True: 0, False: 171]
  ------------------
 7242|      0|	    xmlSchemaPMissingAttrErr(pctxt, XML_SCHEMAP_S4S_ATTR_MISSING,
 7243|      0|		NULL, node, "name", NULL);
 7244|      0|	    return (NULL);
 7245|      0|	}
 7246|    171|	if (xmlSchemaPValAttrNode(pctxt, NULL, attr,
  ------------------
  |  Branch (7246:6): [True: 0, False: 171]
  ------------------
 7247|    171|	    xmlSchemaGetBuiltInType(XML_SCHEMAS_NCNAME), &name) != 0) {
 7248|      0|	    return (NULL);
 7249|      0|	}
 7250|       |	/*
 7251|       |	* 3.2.6 Schema Component Constraint: xmlns Not Allowed
 7252|       |	* TODO: Move this to the component layer.
 7253|       |	*/
 7254|    171|	if (xmlStrEqual(name, BAD_CAST "xmlns")) {
  ------------------
  |  |   35|    171|#define BAD_CAST (xmlChar *)
  ------------------
  |  Branch (7254:6): [True: 1, False: 170]
  ------------------
 7255|      1|	    xmlSchemaPSimpleTypeErr(pctxt,
 7256|      1|		XML_SCHEMAP_NO_XMLNS,
 7257|      1|		NULL, (xmlNodePtr) attr,
 7258|      1|		xmlSchemaGetBuiltInType(XML_SCHEMAS_NCNAME), NULL, NULL,
 7259|      1|		"The value of the attribute must not match 'xmlns'",
 7260|      1|		NULL, NULL);
 7261|      1|	    return (NULL);
 7262|      1|	}
 7263|    170|	if (occurs == XML_SCHEMAS_ATTR_USE_PROHIBITED)
  ------------------
  |  |  202|    170|#define XML_SCHEMAS_ATTR_USE_PROHIBITED 0
  ------------------
  |  Branch (7263:6): [True: 10, False: 160]
  ------------------
 7264|     10|	    goto check_children;
 7265|       |	/*
 7266|       |	* Create the attribute use component.
 7267|       |	*/
 7268|    160|	use = xmlSchemaAddAttributeUse(pctxt, node);
 7269|    160|	if (use == NULL)
  ------------------
  |  Branch (7269:6): [True: 0, False: 160]
  ------------------
 7270|      0|	    return(NULL);
 7271|    160|	use->occurs = occurs;
 7272|       |	/*
 7273|       |	* Create the attribute declaration.
 7274|       |	*/
 7275|    160|	attrDecl = xmlSchemaAddAttribute(pctxt, schema, name, ns, node, 0);
 7276|    160|	if (attrDecl == NULL)
  ------------------
  |  Branch (7276:6): [True: 0, False: 160]
  ------------------
 7277|      0|	    return (NULL);
 7278|    160|	if (tmpName != NULL) {
  ------------------
  |  Branch (7278:6): [True: 139, False: 21]
  ------------------
 7279|    139|	    attrDecl->typeName = tmpName;
 7280|    139|	    attrDecl->typeNs = tmpNs;
 7281|    139|	}
 7282|    160|	use->attrDecl = attrDecl;
 7283|       |	/*
 7284|       |	* Value constraint.
 7285|       |	*/
 7286|    160|	if (defValue != NULL) {
  ------------------
  |  Branch (7286:6): [True: 7, False: 153]
  ------------------
 7287|      7|	    attrDecl->defValue = defValue;
 7288|      7|	    if (defValueType == WXS_ATTR_DEF_VAL_FIXED)
  ------------------
  |  | 7085|      7|#define WXS_ATTR_DEF_VAL_FIXED 2
  ------------------
  |  Branch (7288:10): [True: 2, False: 5]
  ------------------
 7289|      2|		attrDecl->flags |= XML_SCHEMAS_ATTR_FIXED;
  ------------------
  |  |  239|      2|#define XML_SCHEMAS_ATTR_FIXED        1 << 9
  ------------------
 7290|      7|	}
 7291|    160|    } else if (occurs != XML_SCHEMAS_ATTR_USE_PROHIBITED) {
  ------------------
  |  |  202|     45|#define XML_SCHEMAS_ATTR_USE_PROHIBITED 0
  ------------------
  |  Branch (7291:16): [True: 45, False: 0]
  ------------------
 7292|     45|	xmlSchemaQNameRefPtr ref;
 7293|       |
 7294|       |	/*
 7295|       |	* Create the attribute use component.
 7296|       |	*/
 7297|     45|	use = xmlSchemaAddAttributeUse(pctxt, node);
 7298|     45|	if (use == NULL)
  ------------------
  |  Branch (7298:6): [True: 0, False: 45]
  ------------------
 7299|      0|	    return(NULL);
 7300|       |	/*
 7301|       |	* We need to resolve the reference at later stage.
 7302|       |	*/
 7303|     45|	WXS_ADD_PENDING(pctxt, use);
  ------------------
  |  |  307|     45|    xmlSchemaAddItemSize(&((ctx)->constructor->pending), 10, item)
  ------------------
 7304|     45|	use->occurs = occurs;
 7305|       |	/*
 7306|       |	* Create a QName reference to the attribute declaration.
 7307|       |	*/
 7308|     45|	ref = xmlSchemaNewQNameRef(pctxt, XML_SCHEMA_TYPE_ATTRIBUTE,
 7309|     45|	    tmpName, tmpNs);
 7310|     45|	if (ref == NULL)
  ------------------
  |  Branch (7310:6): [True: 0, False: 45]
  ------------------
 7311|      0|	    return(NULL);
 7312|       |	/*
 7313|       |	* Assign the reference. This will be substituted for the
 7314|       |	* referenced attribute declaration when the QName is resolved.
 7315|       |	*/
 7316|     45|	use->attrDecl = WXS_ATTR_CAST ref;
  ------------------
  |  |  130|     45|#define WXS_ATTR_CAST (xmlSchemaAttributePtr)
  ------------------
 7317|       |	/*
 7318|       |	* Value constraint.
 7319|       |	*/
 7320|     45|	if (defValue != NULL)
  ------------------
  |  Branch (7320:6): [True: 0, False: 45]
  ------------------
 7321|      0|	    use->defValue = defValue;
 7322|     45|	if (defValueType == WXS_ATTR_DEF_VAL_FIXED)
  ------------------
  |  | 7085|     45|#define WXS_ATTR_DEF_VAL_FIXED 2
  ------------------
  |  Branch (7322:6): [True: 0, False: 45]
  ------------------
 7323|      0|	    use->flags |= XML_SCHEMA_ATTR_USE_FIXED;
  ------------------
  |  |  508|      0|#define XML_SCHEMA_ATTR_USE_FIXED 1<<0
  ------------------
 7324|     45|    }
 7325|       |
 7326|    215|check_children:
 7327|       |    /*
 7328|       |    * And now for the children...
 7329|       |    */
 7330|    215|    child = node->children;
 7331|    215|    if (occurs == XML_SCHEMAS_ATTR_USE_PROHIBITED) {
  ------------------
  |  |  202|    215|#define XML_SCHEMAS_ATTR_USE_PROHIBITED 0
  ------------------
  |  Branch (7331:9): [True: 10, False: 205]
  ------------------
 7332|     10|	xmlSchemaAttributeUseProhibPtr prohib;
 7333|       |
 7334|     10|	if (IS_SCHEMA(child, "annotation")) {
  ------------------
  |  |  316|     10|   ((node != NULL) && (node->ns != NULL) && \
  |  |  ------------------
  |  |  |  Branch (316:5): [True: 0, False: 10]
  |  |  |  Branch (316:23): [True: 0, False: 0]
  |  |  ------------------
  |  |  317|     10|    (xmlStrEqual(node->name, (const xmlChar *) type)) && \
  |  |  ------------------
  |  |  |  Branch (317:5): [True: 0, False: 0]
  |  |  ------------------
  |  |  318|     10|    (xmlStrEqual(node->ns->href, xmlSchemaNs)))
  |  |  ------------------
  |  |  |  Branch (318:5): [True: 0, False: 0]
  |  |  ------------------
  ------------------
 7335|      0|	    xmlSchemaParseAnnotation(pctxt, child, 0);
 7336|      0|	    child = child->next;
 7337|      0|	}
 7338|     10|	if (child != NULL) {
  ------------------
  |  Branch (7338:6): [True: 0, False: 10]
  ------------------
 7339|      0|	    xmlSchemaPContentErr(pctxt,
 7340|      0|		XML_SCHEMAP_S4S_ELEM_NOT_ALLOWED,
 7341|      0|		NULL, node, child, NULL,
 7342|      0|		"(annotation?)");
 7343|      0|	}
 7344|       |	/*
 7345|       |	* Check for pointlessness of attribute prohibitions.
 7346|       |	*/
 7347|     10|	if (parentType == XML_SCHEMA_TYPE_ATTRIBUTEGROUP) {
  ------------------
  |  Branch (7347:6): [True: 0, False: 10]
  ------------------
 7348|      0|	    xmlSchemaCustomWarning(ACTXT_CAST pctxt,
  ------------------
  |  |  121|      0|#define ACTXT_CAST (xmlSchemaAbstractCtxtPtr)
  ------------------
 7349|      0|		XML_SCHEMAP_WARN_ATTR_POINTLESS_PROH,
 7350|      0|		node, NULL,
 7351|      0|		"Skipping attribute use prohibition, since it is "
 7352|      0|		"pointless inside an <attributeGroup>",
 7353|      0|		NULL, NULL, NULL);
 7354|      0|	    return(NULL);
 7355|     10|	} else if (parentType == XML_SCHEMA_TYPE_EXTENSION) {
  ------------------
  |  Branch (7355:13): [True: 2, False: 8]
  ------------------
 7356|      2|	    xmlSchemaCustomWarning(ACTXT_CAST pctxt,
  ------------------
  |  |  121|      2|#define ACTXT_CAST (xmlSchemaAbstractCtxtPtr)
  ------------------
 7357|      2|		XML_SCHEMAP_WARN_ATTR_POINTLESS_PROH,
 7358|      2|		node, NULL,
 7359|      2|		"Skipping attribute use prohibition, since it is "
 7360|      2|		"pointless when extending a type",
 7361|      2|		NULL, NULL, NULL);
 7362|      2|	    return(NULL);
 7363|      2|	}
 7364|      8|	if (! isRef) {
  ------------------
  |  Branch (7364:6): [True: 8, False: 0]
  ------------------
 7365|      8|	    tmpName = name;
 7366|      8|	    tmpNs = ns;
 7367|      8|	}
 7368|       |	/*
 7369|       |	* Check for duplicate attribute prohibitions.
 7370|       |	*/
 7371|      8|	if (uses) {
  ------------------
  |  Branch (7371:6): [True: 7, False: 1]
  ------------------
 7372|      7|	    int i;
 7373|       |
 7374|     54|	    for (i = 0; i < uses->nbItems; i++) {
  ------------------
  |  Branch (7374:18): [True: 47, False: 7]
  ------------------
 7375|     47|		use = uses->items[i];
 7376|     47|		if ((use->type == XML_SCHEMA_EXTRA_ATTR_USE_PROHIB) &&
  ------------------
  |  Branch (7376:7): [True: 9, False: 38]
  ------------------
 7377|     47|		    (tmpName == (WXS_ATTR_PROHIB_CAST use)->name) &&
  ------------------
  |  |  132|      9|#define WXS_ATTR_PROHIB_CAST (xmlSchemaAttributeUseProhibPtr)
  ------------------
  |  Branch (7377:7): [True: 0, False: 9]
  ------------------
 7378|     47|		    (tmpNs == (WXS_ATTR_PROHIB_CAST use)->targetNamespace))
  ------------------
  |  |  132|      0|#define WXS_ATTR_PROHIB_CAST (xmlSchemaAttributeUseProhibPtr)
  ------------------
  |  Branch (7378:7): [True: 0, False: 0]
  ------------------
 7379|      0|		{
 7380|      0|		    xmlChar *str = NULL;
 7381|       |
 7382|      0|		    xmlSchemaCustomWarning(ACTXT_CAST pctxt,
  ------------------
  |  |  121|      0|#define ACTXT_CAST (xmlSchemaAbstractCtxtPtr)
  ------------------
 7383|      0|			XML_SCHEMAP_WARN_ATTR_POINTLESS_PROH,
 7384|      0|			node, NULL,
 7385|      0|			"Skipping duplicate attribute use prohibition '%s'",
 7386|      0|			xmlSchemaFormatQName(&str, tmpNs, tmpName),
 7387|      0|			NULL, NULL);
 7388|      0|		    FREE_AND_NULL(str)
  ------------------
  |  |  320|      0|#define FREE_AND_NULL(str) if ((str) != NULL) { xmlFree((xmlChar *) (str)); str = NULL; }
  |  |  ------------------
  |  |  |  Branch (320:32): [True: 0, False: 0]
  |  |  ------------------
  ------------------
 7389|      0|		    return(NULL);
 7390|      0|		}
 7391|     47|	    }
 7392|      7|	}
 7393|       |	/*
 7394|       |	* Create the attribute prohibition helper component.
 7395|       |	*/
 7396|      8|	prohib = xmlSchemaAddAttributeUseProhib(pctxt);
 7397|      8|	if (prohib == NULL)
  ------------------
  |  Branch (7397:6): [True: 0, False: 8]
  ------------------
 7398|      0|	    return(NULL);
 7399|      8|	prohib->node = node;
 7400|      8|	prohib->name = tmpName;
 7401|      8|	prohib->targetNamespace = tmpNs;
 7402|      8|	if (isRef) {
  ------------------
  |  Branch (7402:6): [True: 0, False: 8]
  ------------------
 7403|       |	    /*
 7404|       |	    * We need at least to resolve to the attribute declaration.
 7405|       |	    */
 7406|      0|	    WXS_ADD_PENDING(pctxt, prohib);
  ------------------
  |  |  307|      0|    xmlSchemaAddItemSize(&((ctx)->constructor->pending), 10, item)
  ------------------
 7407|      0|	}
 7408|      8|	return(WXS_BASIC_CAST prohib);
  ------------------
  |  |  124|      8|#define WXS_BASIC_CAST (xmlSchemaBasicItemPtr)
  ------------------
 7409|    205|    } else {
 7410|    205|	if (IS_SCHEMA(child, "annotation")) {
  ------------------
  |  |  316|    205|   ((node != NULL) && (node->ns != NULL) && \
  |  |  ------------------
  |  |  |  Branch (316:5): [True: 32, False: 173]
  |  |  |  Branch (316:23): [True: 32, False: 0]
  |  |  ------------------
  |  |  317|    205|    (xmlStrEqual(node->name, (const xmlChar *) type)) && \
  |  |  ------------------
  |  |  |  Branch (317:5): [True: 19, False: 13]
  |  |  ------------------
  |  |  318|    205|    (xmlStrEqual(node->ns->href, xmlSchemaNs)))
  |  |  ------------------
  |  |  |  Branch (318:5): [True: 19, False: 0]
  |  |  ------------------
  ------------------
 7411|       |	    /*
 7412|       |	    * TODO: Should this go into the attr decl?
 7413|       |	    */
 7414|     19|	    use->annot = xmlSchemaParseAnnotation(pctxt, child, 1);
 7415|     19|	    child = child->next;
 7416|     19|	}
 7417|    205|	if (isRef) {
  ------------------
  |  Branch (7417:6): [True: 45, False: 160]
  ------------------
 7418|     45|	    if (child != NULL) {
  ------------------
  |  Branch (7418:10): [True: 1, False: 44]
  ------------------
 7419|      1|		if (IS_SCHEMA(child, "simpleType"))
  ------------------
  |  |  316|      1|   ((node != NULL) && (node->ns != NULL) && \
  |  |  ------------------
  |  |  |  Branch (316:5): [True: 1, False: 0]
  |  |  |  Branch (316:23): [True: 1, False: 0]
  |  |  ------------------
  |  |  317|      1|    (xmlStrEqual(node->name, (const xmlChar *) type)) && \
  |  |  ------------------
  |  |  |  Branch (317:5): [True: 1, False: 0]
  |  |  ------------------
  |  |  318|      1|    (xmlStrEqual(node->ns->href, xmlSchemaNs)))
  |  |  ------------------
  |  |  |  Branch (318:5): [True: 1, False: 0]
  |  |  ------------------
  ------------------
 7420|       |		    /*
 7421|       |		    * 3.2.3 : 3.2
 7422|       |		    * If ref is present, then all of <simpleType>,
 7423|       |		    * form and type must be absent.
 7424|       |		    */
 7425|      1|		    xmlSchemaPContentErr(pctxt,
 7426|      1|			XML_SCHEMAP_SRC_ATTRIBUTE_3_2,
 7427|      1|			NULL, node, child, NULL,
 7428|      1|			"(annotation?)");
 7429|      0|		else
 7430|      0|		    xmlSchemaPContentErr(pctxt,
 7431|      0|			XML_SCHEMAP_S4S_ELEM_NOT_ALLOWED,
 7432|      0|			NULL, node, child, NULL,
 7433|      0|			"(annotation?)");
 7434|      1|	    }
 7435|    160|	} else {
 7436|    160|	    if (IS_SCHEMA(child, "simpleType")) {
  ------------------
  |  |  316|    160|   ((node != NULL) && (node->ns != NULL) && \
  |  |  ------------------
  |  |  |  Branch (316:5): [True: 16, False: 144]
  |  |  |  Branch (316:23): [True: 16, False: 0]
  |  |  ------------------
  |  |  317|    160|    (xmlStrEqual(node->name, (const xmlChar *) type)) && \
  |  |  ------------------
  |  |  |  Branch (317:5): [True: 16, False: 0]
  |  |  ------------------
  |  |  318|    160|    (xmlStrEqual(node->ns->href, xmlSchemaNs)))
  |  |  ------------------
  |  |  |  Branch (318:5): [True: 16, False: 0]
  |  |  ------------------
  ------------------
 7437|     16|		if (WXS_ATTRUSE_DECL(use)->typeName != NULL) {
  ------------------
  |  |  158|     16|#define WXS_ATTRUSE_DECL(au) (WXS_ATTR_USE_CAST (au))->attrDecl
  |  |  ------------------
  |  |  |  |  131|     16|#define WXS_ATTR_USE_CAST (xmlSchemaAttributeUsePtr)
  |  |  ------------------
  ------------------
  |  Branch (7437:7): [True: 0, False: 16]
  ------------------
 7438|       |		    /*
 7439|       |		    * 3.2.3 : 4
 7440|       |		    * type and <simpleType> must not both be present.
 7441|       |		    */
 7442|      0|		    xmlSchemaPContentErr(pctxt, XML_SCHEMAP_SRC_ATTRIBUTE_4,
 7443|      0|			NULL, node, child,
 7444|      0|			"The attribute 'type' and the <simpleType> child "
 7445|      0|			"are mutually exclusive", NULL);
 7446|      0|		} else
 7447|     16|		    WXS_ATTRUSE_TYPEDEF(use) =
  ------------------
  |  |  160|     16|#define WXS_ATTRUSE_TYPEDEF(au) WXS_ATTR_TYPEDEF(WXS_ATTRUSE_DECL( WXS_ATTR_USE_CAST au))
  |  |  ------------------
  |  |  |  |  154|     16|#define WXS_ATTR_TYPEDEF(a) (a)->subtypes
  |  |  ------------------
  ------------------
 7448|     16|			xmlSchemaParseSimpleType(pctxt, schema, child, 0);
 7449|     16|		child = child->next;
 7450|     16|	    }
 7451|    160|	    if (child != NULL)
  ------------------
  |  Branch (7451:10): [True: 0, False: 160]
  ------------------
 7452|      0|		xmlSchemaPContentErr(pctxt, XML_SCHEMAP_S4S_ELEM_NOT_ALLOWED,
 7453|      0|		NULL, node, child, NULL,
 7454|      0|		"(annotation?, simpleType?)");
 7455|    160|	}
 7456|    205|    }
 7457|    205|    return (WXS_BASIC_CAST use);
  ------------------
  |  |  124|    205|#define WXS_BASIC_CAST (xmlSchemaBasicItemPtr)
  ------------------
 7458|    215|}
xmlschemas.c:xmlSchemaPMutualExclAttrErr:
 3143|      6|{
 3144|      6|    xmlChar *des = NULL;
 3145|       |
 3146|      6|    xmlSchemaFormatItemForReport(&des, NULL, WXS_BASIC_CAST ownerItem, attr->parent);
  ------------------
  |  |  124|      6|#define WXS_BASIC_CAST (xmlSchemaBasicItemPtr)
  ------------------
 3147|      6|    xmlSchemaPErrExt(ctxt, (xmlNodePtr) attr, error, NULL, NULL, NULL,
 3148|      6|	"%s: The attributes '%s' and '%s' are mutually exclusive.\n",
 3149|      6|	BAD_CAST des, BAD_CAST name1, BAD_CAST name2, NULL, NULL);
  ------------------
  |  |   35|      6|#define BAD_CAST (xmlChar *)
  ------------------
              	BAD_CAST des, BAD_CAST name1, BAD_CAST name2, NULL, NULL);
  ------------------
  |  |   35|      6|#define BAD_CAST (xmlChar *)
  ------------------
              	BAD_CAST des, BAD_CAST name1, BAD_CAST name2, NULL, NULL);
  ------------------
  |  |   35|      6|#define BAD_CAST (xmlChar *)
  ------------------
 3150|      6|    FREE_AND_NULL(des);
  ------------------
  |  |  320|      6|#define FREE_AND_NULL(str) if ((str) != NULL) { xmlFree((xmlChar *) (str)); str = NULL; }
  |  |  ------------------
  |  |  |  Branch (320:32): [True: 6, False: 0]
  |  |  ------------------
  ------------------
 3151|      6|}
xmlschemas.c:xmlSchemaAddAttributeUse:
 5160|    205|{
 5161|    205|    xmlSchemaAttributeUsePtr ret = NULL;
 5162|       |
 5163|    205|    if (pctxt == NULL)
  ------------------
  |  Branch (5163:9): [True: 0, False: 205]
  ------------------
 5164|      0|        return (NULL);
 5165|       |
 5166|    205|    ret = (xmlSchemaAttributeUsePtr) xmlMalloc(sizeof(xmlSchemaAttributeUse));
 5167|    205|    if (ret == NULL) {
  ------------------
  |  Branch (5167:9): [True: 0, False: 205]
  ------------------
 5168|      0|        xmlSchemaPErrMemory(pctxt, "allocating attribute", NULL);
 5169|      0|        return (NULL);
 5170|      0|    }
 5171|    205|    memset(ret, 0, sizeof(xmlSchemaAttributeUse));
 5172|    205|    ret->type = XML_SCHEMA_TYPE_ATTRIBUTE_USE;
 5173|    205|    ret->node = node;
 5174|       |
 5175|    205|    WXS_ADD_LOCAL(pctxt, ret);
  ------------------
  |  |  291|    205|    do { \
  |  |  292|    205|        if (xmlSchemaAddItemSize(&(WXS_BUCKET(ctx)->locals), 10, item) < 0) { \
  |  |  ------------------
  |  |  |  |  286|    205|#define WXS_BUCKET(ctx) WXS_CONSTRUCTOR((ctx))->bucket
  |  |  |  |  ------------------
  |  |  |  |  |  |  278|    205|#define WXS_CONSTRUCTOR(ctx) (ctx)->constructor
  |  |  |  |  ------------------
  |  |  ------------------
  |  |  |  Branch (292:13): [True: 0, False: 205]
  |  |  ------------------
  |  |  293|      0|            xmlFree(item); \
  |  |  294|      0|            item = NULL; \
  |  |  295|      0|        } \
  |  |  296|    205|    } while (0)
  |  |  ------------------
  |  |  |  Branch (296:14): [Folded - Ignored]
  |  |  ------------------
  ------------------
 5176|    205|    return (ret);
 5177|    205|}
xmlschemas.c:xmlSchemaAddAttribute:
 5120|    196|{
 5121|    196|    xmlSchemaAttributePtr ret = NULL;
 5122|       |
 5123|    196|    if ((ctxt == NULL) || (schema == NULL))
  ------------------
  |  Branch (5123:9): [True: 0, False: 196]
  |  Branch (5123:27): [True: 0, False: 196]
  ------------------
 5124|      0|        return (NULL);
 5125|       |
 5126|    196|    ret = (xmlSchemaAttributePtr) xmlMalloc(sizeof(xmlSchemaAttribute));
 5127|    196|    if (ret == NULL) {
  ------------------
  |  Branch (5127:9): [True: 0, False: 196]
  ------------------
 5128|      0|        xmlSchemaPErrMemory(ctxt, "allocating attribute", NULL);
 5129|      0|        return (NULL);
 5130|      0|    }
 5131|    196|    memset(ret, 0, sizeof(xmlSchemaAttribute));
 5132|    196|    ret->type = XML_SCHEMA_TYPE_ATTRIBUTE;
 5133|    196|    ret->node = node;
 5134|    196|    ret->name = name;
 5135|    196|    ret->targetNamespace = nsName;
 5136|       |
 5137|    196|    if (topLevel)
  ------------------
  |  Branch (5137:9): [True: 36, False: 160]
  ------------------
 5138|     36|	WXS_ADD_GLOBAL(ctxt, ret);
  ------------------
  |  |  299|     36|    do { \
  |  |  300|     36|        if (xmlSchemaAddItemSize(&(WXS_BUCKET(ctx)->globals), 5, item) < 0) { \
  |  |  ------------------
  |  |  |  |  286|     36|#define WXS_BUCKET(ctx) WXS_CONSTRUCTOR((ctx))->bucket
  |  |  |  |  ------------------
  |  |  |  |  |  |  278|     36|#define WXS_CONSTRUCTOR(ctx) (ctx)->constructor
  |  |  |  |  ------------------
  |  |  ------------------
  |  |  |  Branch (300:13): [True: 0, False: 36]
  |  |  ------------------
  |  |  301|      0|            xmlFree(item); \
  |  |  302|      0|            item = NULL; \
  |  |  303|      0|        } \
  |  |  304|     36|    } while (0)
  |  |  ------------------
  |  |  |  Branch (304:14): [Folded - Ignored]
  |  |  ------------------
  ------------------
 5139|    160|    else
 5140|    160|	WXS_ADD_LOCAL(ctxt, ret);
  ------------------
  |  |  291|    160|    do { \
  |  |  292|    160|        if (xmlSchemaAddItemSize(&(WXS_BUCKET(ctx)->locals), 10, item) < 0) { \
  |  |  ------------------
  |  |  |  |  286|    160|#define WXS_BUCKET(ctx) WXS_CONSTRUCTOR((ctx))->bucket
  |  |  |  |  ------------------
  |  |  |  |  |  |  278|    160|#define WXS_CONSTRUCTOR(ctx) (ctx)->constructor
  |  |  |  |  ------------------
  |  |  ------------------
  |  |  |  Branch (292:13): [True: 0, False: 160]
  |  |  ------------------
  |  |  293|      0|            xmlFree(item); \
  |  |  294|      0|            item = NULL; \
  |  |  295|      0|        } \
  |  |  296|    160|    } while (0)
  |  |  ------------------
  |  |  |  Branch (296:14): [Folded - Ignored]
  |  |  ------------------
  ------------------
 5141|    196|    WXS_ADD_PENDING(ctxt, ret);
  ------------------
  |  |  307|    196|    xmlSchemaAddItemSize(&((ctx)->constructor->pending), 10, item)
  ------------------
 5142|    196|    return (ret);
 5143|    196|}
xmlschemas.c:xmlSchemaAddAttributeUseProhib:
 5388|      8|{
 5389|      8|    xmlSchemaAttributeUseProhibPtr ret;
 5390|       |
 5391|      8|    ret = (xmlSchemaAttributeUseProhibPtr)
 5392|      8|	xmlMalloc(sizeof(xmlSchemaAttributeUseProhib));
 5393|      8|    if (ret == NULL) {
  ------------------
  |  Branch (5393:9): [True: 0, False: 8]
  ------------------
 5394|      0|	xmlSchemaPErrMemory(pctxt,
 5395|      0|	    "allocating attribute use prohibition", NULL);
 5396|      0|	return (NULL);
 5397|      0|    }
 5398|      8|    memset(ret, 0, sizeof(xmlSchemaAttributeUseProhib));
 5399|      8|    ret->type = XML_SCHEMA_EXTRA_ATTR_USE_PROHIB;
 5400|      8|    WXS_ADD_LOCAL(pctxt, ret);
  ------------------
  |  |  291|      8|    do { \
  |  |  292|      8|        if (xmlSchemaAddItemSize(&(WXS_BUCKET(ctx)->locals), 10, item) < 0) { \
  |  |  ------------------
  |  |  |  |  286|      8|#define WXS_BUCKET(ctx) WXS_CONSTRUCTOR((ctx))->bucket
  |  |  |  |  ------------------
  |  |  |  |  |  |  278|      8|#define WXS_CONSTRUCTOR(ctx) (ctx)->constructor
  |  |  |  |  ------------------
  |  |  ------------------
  |  |  |  Branch (292:13): [True: 0, False: 8]
  |  |  ------------------
  |  |  293|      0|            xmlFree(item); \
  |  |  294|      0|            item = NULL; \
  |  |  295|      0|        } \
  |  |  296|      8|    } while (0)
  |  |  ------------------
  |  |  |  Branch (296:14): [Folded - Ignored]
  |  |  ------------------
  ------------------
 5401|      8|    return (ret);
 5402|      8|}
xmlschemas.c:xmlSchemaParseAttributeGroupRef:
 7618|     51|{
 7619|     51|    xmlSchemaQNameRefPtr ret;
 7620|     51|    xmlNodePtr child = NULL;
 7621|     51|    xmlAttrPtr attr;
 7622|     51|    const xmlChar *refNs = NULL, *ref = NULL;
 7623|       |
 7624|     51|    if ((pctxt == NULL) || (schema == NULL) || (node == NULL))
  ------------------
  |  Branch (7624:9): [True: 0, False: 51]
  |  Branch (7624:28): [True: 0, False: 51]
  |  Branch (7624:48): [True: 0, False: 51]
  ------------------
 7625|      0|        return (NULL);
 7626|       |
 7627|     51|    attr = xmlSchemaGetPropNode(node, "ref");
 7628|     51|    if (attr == NULL) {
  ------------------
  |  Branch (7628:9): [True: 0, False: 51]
  ------------------
 7629|      0|	xmlSchemaPMissingAttrErr(pctxt,
 7630|      0|	    XML_SCHEMAP_S4S_ATTR_MISSING,
 7631|      0|	    NULL, node, "ref", NULL);
 7632|      0|	return (NULL);
 7633|      0|    }
 7634|     51|    xmlSchemaPValAttrNodeQName(pctxt, schema,
 7635|     51|	NULL, attr, &refNs, &ref);
 7636|     51|    if (xmlSchemaCheckReference(pctxt, schema, node, attr, refNs) != 0)
  ------------------
  |  Branch (7636:9): [True: 0, False: 51]
  ------------------
 7637|      0|	return(NULL);
 7638|       |
 7639|       |    /*
 7640|       |    * Check for illegal attributes.
 7641|       |    */
 7642|     51|    attr = node->properties;
 7643|    102|    while (attr != NULL) {
  ------------------
  |  Branch (7643:12): [True: 51, False: 51]
  ------------------
 7644|     51|	if (attr->ns == NULL) {
  ------------------
  |  Branch (7644:6): [True: 51, False: 0]
  ------------------
 7645|     51|	    if ((!xmlStrEqual(attr->name, BAD_CAST "ref")) &&
  ------------------
  |  |   35|     51|#define BAD_CAST (xmlChar *)
  ------------------
  |  Branch (7645:10): [True: 0, False: 51]
  ------------------
 7646|     51|		(!xmlStrEqual(attr->name, BAD_CAST "id")))
  ------------------
  |  |   35|      0|#define BAD_CAST (xmlChar *)
  ------------------
  |  Branch (7646:3): [True: 0, False: 0]
  ------------------
 7647|      0|	    {
 7648|      0|		xmlSchemaPIllegalAttrErr(pctxt,
 7649|      0|		    XML_SCHEMAP_S4S_ATTR_NOT_ALLOWED, NULL, attr);
 7650|      0|	    }
 7651|     51|	} else if (xmlStrEqual(attr->ns->href, xmlSchemaNs)) {
  ------------------
  |  Branch (7651:13): [True: 0, False: 0]
  ------------------
 7652|      0|	    xmlSchemaPIllegalAttrErr(pctxt,
 7653|      0|		XML_SCHEMAP_S4S_ATTR_NOT_ALLOWED, NULL, attr);
 7654|      0|	}
 7655|     51|	attr = attr->next;
 7656|     51|    }
 7657|       |    /* Attribute ID */
 7658|     51|    xmlSchemaPValAttrID(pctxt, node, BAD_CAST "id");
  ------------------
  |  |   35|     51|#define BAD_CAST (xmlChar *)
  ------------------
 7659|       |
 7660|       |    /*
 7661|       |    * And now for the children...
 7662|       |    */
 7663|     51|    child = node->children;
 7664|     51|    if (IS_SCHEMA(child, "annotation")) {
  ------------------
  |  |  316|     51|   ((node != NULL) && (node->ns != NULL) && \
  |  |  ------------------
  |  |  |  Branch (316:5): [True: 0, False: 51]
  |  |  |  Branch (316:23): [True: 0, False: 0]
  |  |  ------------------
  |  |  317|     51|    (xmlStrEqual(node->name, (const xmlChar *) type)) && \
  |  |  ------------------
  |  |  |  Branch (317:5): [True: 0, False: 0]
  |  |  ------------------
  |  |  318|     51|    (xmlStrEqual(node->ns->href, xmlSchemaNs)))
  |  |  ------------------
  |  |  |  Branch (318:5): [True: 0, False: 0]
  |  |  ------------------
  ------------------
 7665|       |	/*
 7666|       |	* TODO: We do not have a place to store the annotation, do we?
 7667|       |	*/
 7668|      0|        xmlSchemaParseAnnotation(pctxt, child, 0);
 7669|      0|        child = child->next;
 7670|      0|    }
 7671|     51|    if (child != NULL) {
  ------------------
  |  Branch (7671:9): [True: 0, False: 51]
  ------------------
 7672|      0|	xmlSchemaPContentErr(pctxt,
 7673|      0|	    XML_SCHEMAP_S4S_ELEM_NOT_ALLOWED,
 7674|      0|	    NULL, node, child, NULL,
 7675|      0|	    "(annotation?)");
 7676|      0|    }
 7677|       |
 7678|       |    /*
 7679|       |    * Handle attribute group redefinitions.
 7680|       |    */
 7681|     51|    if (pctxt->isRedefine && pctxt->redef &&
  ------------------
  |  Branch (7681:9): [True: 0, False: 51]
  |  Branch (7681:30): [True: 0, False: 0]
  ------------------
 7682|     51|	(pctxt->redef->item->type ==
  ------------------
  |  Branch (7682:2): [True: 0, False: 0]
  ------------------
 7683|      0|	    XML_SCHEMA_TYPE_ATTRIBUTEGROUP) &&
 7684|     51|	(ref == pctxt->redef->refName) &&
  ------------------
  |  Branch (7684:2): [True: 0, False: 0]
  ------------------
 7685|     51|	(refNs == pctxt->redef->refTargetNs))
  ------------------
  |  Branch (7685:2): [True: 0, False: 0]
  ------------------
 7686|      0|    {
 7687|       |	/*
 7688|       |	* SPEC src-redefine:
 7689|       |	* (7.1) "If it has an <attributeGroup> among its contents
 7690|       |	* the `actual value` of whose ref [attribute] is the same
 7691|       |	* as the `actual value` of its own name attribute plus
 7692|       |	* target namespace, then it must have exactly one such group."
 7693|       |	*/
 7694|      0|	if (pctxt->redefCounter != 0) {
  ------------------
  |  Branch (7694:6): [True: 0, False: 0]
  ------------------
 7695|      0|	    xmlChar *str = NULL;
 7696|       |
 7697|      0|	    xmlSchemaCustomErr(ACTXT_CAST pctxt,
  ------------------
  |  |  121|      0|#define ACTXT_CAST (xmlSchemaAbstractCtxtPtr)
  ------------------
 7698|      0|		XML_SCHEMAP_SRC_REDEFINE, node, NULL,
 7699|      0|		"The redefining attribute group definition "
 7700|      0|		"'%s' must not contain more than one "
 7701|      0|		"reference to the redefined definition",
 7702|      0|		xmlSchemaFormatQName(&str, refNs, ref), NULL);
 7703|      0|	    FREE_AND_NULL(str);
  ------------------
  |  |  320|      0|#define FREE_AND_NULL(str) if ((str) != NULL) { xmlFree((xmlChar *) (str)); str = NULL; }
  |  |  ------------------
  |  |  |  Branch (320:32): [True: 0, False: 0]
  |  |  ------------------
  ------------------
 7704|      0|	    return(NULL);
 7705|      0|	}
 7706|      0|	pctxt->redefCounter++;
 7707|       |	/*
 7708|       |	* URGENT TODO: How to ensure that the reference will not be
 7709|       |	* handled by the normal component resolution mechanism?
 7710|       |	*/
 7711|      0|	ret = xmlSchemaNewQNameRef(pctxt,
 7712|      0|	    XML_SCHEMA_TYPE_ATTRIBUTEGROUP, ref, refNs);
 7713|      0|	if (ret == NULL)
  ------------------
  |  Branch (7713:6): [True: 0, False: 0]
  ------------------
 7714|      0|	    return(NULL);
 7715|      0|	ret->node = node;
 7716|      0|	pctxt->redef->reference = WXS_BASIC_CAST ret;
  ------------------
  |  |  124|      0|#define WXS_BASIC_CAST (xmlSchemaBasicItemPtr)
  ------------------
 7717|     51|    } else {
 7718|       |	/*
 7719|       |	* Create a QName-reference helper component. We will substitute this
 7720|       |	* component for the attribute uses of the referenced attribute group
 7721|       |	* definition.
 7722|       |	*/
 7723|     51|	ret = xmlSchemaNewQNameRef(pctxt,
 7724|     51|	    XML_SCHEMA_TYPE_ATTRIBUTEGROUP, ref, refNs);
 7725|     51|	if (ret == NULL)
  ------------------
  |  Branch (7725:6): [True: 0, False: 51]
  ------------------
 7726|      0|	    return(NULL);
 7727|     51|	ret->node = node;
 7728|       |	/* Add to pending items, to be able to resolve the reference. */
 7729|     51|	WXS_ADD_PENDING(pctxt, ret);
  ------------------
  |  |  307|     51|    xmlSchemaAddItemSize(&((ctx)->constructor->pending), 10, item)
  ------------------
 7730|     51|    }
 7731|     51|    return (ret);
 7732|     51|}
xmlschemas.c:xmlSchemaParseAnyAttribute:
 7002|    115|{
 7003|    115|    xmlSchemaWildcardPtr ret;
 7004|    115|    xmlNodePtr child = NULL;
 7005|    115|    xmlAttrPtr attr;
 7006|       |
 7007|    115|    if ((ctxt == NULL) || (schema == NULL) || (node == NULL))
  ------------------
  |  Branch (7007:9): [True: 0, False: 115]
  |  Branch (7007:27): [True: 0, False: 115]
  |  Branch (7007:47): [True: 0, False: 115]
  ------------------
 7008|      0|        return (NULL);
 7009|       |
 7010|    115|    ret = xmlSchemaAddWildcard(ctxt, schema, XML_SCHEMA_TYPE_ANY_ATTRIBUTE,
 7011|    115|	node);
 7012|    115|    if (ret == NULL) {
  ------------------
  |  Branch (7012:9): [True: 0, False: 115]
  ------------------
 7013|      0|        return (NULL);
 7014|      0|    }
 7015|       |    /*
 7016|       |    * Check for illegal attributes.
 7017|       |    */
 7018|    115|    attr = node->properties;
 7019|    321|    while (attr != NULL) {
  ------------------
  |  Branch (7019:12): [True: 206, False: 115]
  ------------------
 7020|    206|	if (attr->ns == NULL) {
  ------------------
  |  Branch (7020:6): [True: 206, False: 0]
  ------------------
 7021|    206|	    if ((!xmlStrEqual(attr->name, BAD_CAST "id")) &&
  ------------------
  |  |   35|    206|#define BAD_CAST (xmlChar *)
  ------------------
  |  Branch (7021:10): [True: 206, False: 0]
  ------------------
 7022|    206|	        (!xmlStrEqual(attr->name, BAD_CAST "namespace")) &&
  ------------------
  |  |   35|    206|#define BAD_CAST (xmlChar *)
  ------------------
  |  Branch (7022:10): [True: 91, False: 115]
  ------------------
 7023|    206|		(!xmlStrEqual(attr->name, BAD_CAST "processContents"))) {
  ------------------
  |  |   35|     91|#define BAD_CAST (xmlChar *)
  ------------------
  |  Branch (7023:3): [True: 0, False: 91]
  ------------------
 7024|      0|		xmlSchemaPIllegalAttrErr(ctxt,
 7025|      0|		    XML_SCHEMAP_S4S_ATTR_NOT_ALLOWED, NULL, attr);
 7026|      0|	    }
 7027|    206|	} else if (xmlStrEqual(attr->ns->href, xmlSchemaNs)) {
  ------------------
  |  Branch (7027:13): [True: 0, False: 0]
  ------------------
 7028|      0|	    xmlSchemaPIllegalAttrErr(ctxt,
 7029|      0|		XML_SCHEMAP_S4S_ATTR_NOT_ALLOWED, NULL, attr);
 7030|      0|	}
 7031|    206|	attr = attr->next;
 7032|    206|    }
 7033|    115|    xmlSchemaPValAttrID(ctxt, node, BAD_CAST "id");
  ------------------
  |  |   35|    115|#define BAD_CAST (xmlChar *)
  ------------------
 7034|       |    /*
 7035|       |    * Parse the namespace list.
 7036|       |    */
 7037|    115|    if (xmlSchemaParseWildcardNs(ctxt, schema, ret, node) != 0)
  ------------------
  |  Branch (7037:9): [True: 0, False: 115]
  ------------------
 7038|      0|	return (NULL);
 7039|       |    /*
 7040|       |    * And now for the children...
 7041|       |    */
 7042|    115|    child = node->children;
 7043|    115|    if (IS_SCHEMA(child, "annotation")) {
  ------------------
  |  |  316|    115|   ((node != NULL) && (node->ns != NULL) && \
  |  |  ------------------
  |  |  |  Branch (316:5): [True: 0, False: 115]
  |  |  |  Branch (316:23): [True: 0, False: 0]
  |  |  ------------------
  |  |  317|    115|    (xmlStrEqual(node->name, (const xmlChar *) type)) && \
  |  |  ------------------
  |  |  |  Branch (317:5): [True: 0, False: 0]
  |  |  ------------------
  |  |  318|    115|    (xmlStrEqual(node->ns->href, xmlSchemaNs)))
  |  |  ------------------
  |  |  |  Branch (318:5): [True: 0, False: 0]
  |  |  ------------------
  ------------------
 7044|      0|        ret->annot = xmlSchemaParseAnnotation(ctxt, child, 1);
 7045|      0|        child = child->next;
 7046|      0|    }
 7047|    115|    if (child != NULL) {
  ------------------
  |  Branch (7047:9): [True: 0, False: 115]
  ------------------
 7048|      0|	xmlSchemaPContentErr(ctxt,
 7049|      0|	    XML_SCHEMAP_S4S_ELEM_NOT_ALLOWED,
 7050|      0|	    NULL, node, child,
 7051|      0|	    NULL, "(annotation?)");
 7052|      0|    }
 7053|       |
 7054|    115|    return (ret);
 7055|    115|}
xmlschemas.c:xmlSchemaParseSimpleType:
 9112|    160|{
 9113|    160|    xmlSchemaTypePtr type, oldCtxtType;
 9114|    160|    xmlNodePtr child = NULL;
 9115|    160|    const xmlChar *attrValue = NULL;
 9116|    160|    xmlAttrPtr attr;
 9117|    160|    int hasRestriction = 0;
 9118|       |
 9119|    160|    if ((ctxt == NULL) || (schema == NULL) || (node == NULL))
  ------------------
  |  Branch (9119:9): [True: 0, False: 160]
  |  Branch (9119:27): [True: 0, False: 160]
  |  Branch (9119:47): [True: 0, False: 160]
  ------------------
 9120|      0|        return (NULL);
 9121|       |
 9122|    160|    if (topLevel) {
  ------------------
  |  Branch (9122:9): [True: 69, False: 91]
  ------------------
 9123|     69|	attr = xmlSchemaGetPropNode(node, "name");
 9124|     69|	if (attr == NULL) {
  ------------------
  |  Branch (9124:6): [True: 0, False: 69]
  ------------------
 9125|      0|	    xmlSchemaPMissingAttrErr(ctxt,
 9126|      0|		XML_SCHEMAP_S4S_ATTR_MISSING,
 9127|      0|		NULL, node,
 9128|      0|		"name", NULL);
 9129|      0|	    return (NULL);
 9130|     69|	} else {
 9131|     69|	    if (xmlSchemaPValAttrNode(ctxt,
  ------------------
  |  Branch (9131:10): [True: 0, False: 69]
  ------------------
 9132|     69|		NULL, attr,
 9133|     69|		xmlSchemaGetBuiltInType(XML_SCHEMAS_NCNAME), &attrValue) != 0)
 9134|      0|		return (NULL);
 9135|       |	    /*
 9136|       |	    * Skip built-in types.
 9137|       |	    */
 9138|     69|	    if (ctxt->isS4S) {
  ------------------
  |  Branch (9138:10): [True: 0, False: 69]
  ------------------
 9139|      0|		xmlSchemaTypePtr biType;
 9140|       |
 9141|      0|		if (ctxt->isRedefine) {
  ------------------
  |  Branch (9141:7): [True: 0, False: 0]
  ------------------
 9142|       |		    /*
 9143|       |		    * REDEFINE: Disallow redefinition of built-in-types.
 9144|       |		    * TODO: It seems that the spec does not say anything
 9145|       |		    * about this case.
 9146|       |		    */
 9147|      0|		    xmlSchemaPCustomErr(ctxt, XML_SCHEMAP_SRC_REDEFINE,
 9148|      0|			NULL, node,
 9149|      0|			"Redefinition of built-in simple types is not "
 9150|      0|			"supported", NULL);
 9151|      0|		    return(NULL);
 9152|      0|		}
 9153|      0|		biType = xmlSchemaGetPredefinedType(attrValue, xmlSchemaNs);
 9154|      0|		if (biType != NULL)
  ------------------
  |  Branch (9154:7): [True: 0, False: 0]
  ------------------
 9155|      0|		    return (biType);
 9156|      0|	    }
 9157|     69|	}
 9158|     69|    }
 9159|       |    /*
 9160|       |    * TargetNamespace:
 9161|       |    * SPEC "The `actual value` of the targetNamespace [attribute]
 9162|       |    * of the <schema> ancestor element information item if present,
 9163|       |    * otherwise `absent`.
 9164|       |    */
 9165|    160|    if (topLevel == 0) {
  ------------------
  |  Branch (9165:9): [True: 91, False: 69]
  ------------------
 9166|       |#ifdef ENABLE_NAMED_LOCALS
 9167|       |        char buf[40];
 9168|       |#endif
 9169|       |	/*
 9170|       |	* Parse as local simple type definition.
 9171|       |	*/
 9172|       |#ifdef ENABLE_NAMED_LOCALS
 9173|       |        snprintf(buf, 39, "#ST%d", ctxt->counter++ + 1);
 9174|       |	type = xmlSchemaAddType(ctxt, schema,
 9175|       |	    XML_SCHEMA_TYPE_SIMPLE,
 9176|       |	    xmlDictLookup(ctxt->dict, (const xmlChar *)buf, -1),
 9177|       |	    ctxt->targetNamespace, node, 0);
 9178|       |#else
 9179|     91|	type = xmlSchemaAddType(ctxt, schema,
 9180|     91|	    XML_SCHEMA_TYPE_SIMPLE,
 9181|     91|	    NULL, ctxt->targetNamespace, node, 0);
 9182|     91|#endif
 9183|     91|	if (type == NULL)
  ------------------
  |  Branch (9183:6): [True: 0, False: 91]
  ------------------
 9184|      0|	    return (NULL);
 9185|     91|	type->type = XML_SCHEMA_TYPE_SIMPLE;
 9186|     91|	type->contentType = XML_SCHEMA_CONTENT_SIMPLE;
 9187|       |	/*
 9188|       |	* Check for illegal attributes.
 9189|       |	*/
 9190|     91|	attr = node->properties;
 9191|     91|	while (attr != NULL) {
  ------------------
  |  Branch (9191:9): [True: 0, False: 91]
  ------------------
 9192|      0|	    if (attr->ns == NULL) {
  ------------------
  |  Branch (9192:10): [True: 0, False: 0]
  ------------------
 9193|      0|		if (!xmlStrEqual(attr->name, BAD_CAST "id")) {
  ------------------
  |  |   35|      0|#define BAD_CAST (xmlChar *)
  ------------------
  |  Branch (9193:7): [True: 0, False: 0]
  ------------------
 9194|      0|		    xmlSchemaPIllegalAttrErr(ctxt,
 9195|      0|			XML_SCHEMAP_S4S_ATTR_NOT_ALLOWED, NULL, attr);
 9196|      0|		}
 9197|      0|	    } else if (xmlStrEqual(attr->ns->href, xmlSchemaNs)) {
  ------------------
  |  Branch (9197:17): [True: 0, False: 0]
  ------------------
 9198|      0|		    xmlSchemaPIllegalAttrErr(ctxt,
 9199|      0|			XML_SCHEMAP_S4S_ATTR_NOT_ALLOWED, NULL, attr);
 9200|      0|	    }
 9201|      0|	    attr = attr->next;
 9202|      0|	}
 9203|     91|    } else {
 9204|       |	/*
 9205|       |	* Parse as global simple type definition.
 9206|       |	*
 9207|       |	* Note that attrValue is the value of the attribute "name" here.
 9208|       |	*/
 9209|     69|	type = xmlSchemaAddType(ctxt, schema, XML_SCHEMA_TYPE_SIMPLE,
 9210|     69|	    attrValue, ctxt->targetNamespace, node, 1);
 9211|     69|	if (type == NULL)
  ------------------
  |  Branch (9211:6): [True: 0, False: 69]
  ------------------
 9212|      0|	    return (NULL);
 9213|     69|	type->type = XML_SCHEMA_TYPE_SIMPLE;
 9214|     69|	type->contentType = XML_SCHEMA_CONTENT_SIMPLE;
 9215|     69|	type->flags |= XML_SCHEMAS_TYPE_GLOBAL;
  ------------------
  |  |  426|     69|#define XML_SCHEMAS_TYPE_GLOBAL                1 << 3
  ------------------
 9216|       |	/*
 9217|       |	* Check for illegal attributes.
 9218|       |	*/
 9219|     69|	attr = node->properties;
 9220|    139|	while (attr != NULL) {
  ------------------
  |  Branch (9220:9): [True: 70, False: 69]
  ------------------
 9221|     70|	    if (attr->ns == NULL) {
  ------------------
  |  Branch (9221:10): [True: 70, False: 0]
  ------------------
 9222|     70|		if ((!xmlStrEqual(attr->name, BAD_CAST "id")) &&
  ------------------
  |  |   35|     70|#define BAD_CAST (xmlChar *)
  ------------------
  |  Branch (9222:7): [True: 69, False: 1]
  ------------------
 9223|     70|		    (!xmlStrEqual(attr->name, BAD_CAST "name")) &&
  ------------------
  |  |   35|     69|#define BAD_CAST (xmlChar *)
  ------------------
  |  Branch (9223:7): [True: 0, False: 69]
  ------------------
 9224|     70|		    (!xmlStrEqual(attr->name, BAD_CAST "final"))) {
  ------------------
  |  |   35|      0|#define BAD_CAST (xmlChar *)
  ------------------
  |  Branch (9224:7): [True: 0, False: 0]
  ------------------
 9225|      0|		    xmlSchemaPIllegalAttrErr(ctxt,
 9226|      0|			XML_SCHEMAP_S4S_ATTR_NOT_ALLOWED, NULL, attr);
 9227|      0|		}
 9228|     70|	    } else if (xmlStrEqual(attr->ns->href, xmlSchemaNs)) {
  ------------------
  |  Branch (9228:17): [True: 0, False: 0]
  ------------------
 9229|      0|		xmlSchemaPIllegalAttrErr(ctxt,
 9230|      0|		    XML_SCHEMAP_S4S_ATTR_NOT_ALLOWED, NULL, attr);
 9231|      0|	    }
 9232|     70|	    attr = attr->next;
 9233|     70|	}
 9234|       |	/*
 9235|       |	* Attribute "final".
 9236|       |	*/
 9237|     69|	attr = xmlSchemaGetPropNode(node, "final");
 9238|     69|	if (attr == NULL) {
  ------------------
  |  Branch (9238:6): [True: 69, False: 0]
  ------------------
 9239|     69|	    if (schema->flags & XML_SCHEMAS_FINAL_DEFAULT_RESTRICTION)
  ------------------
  |  |  880|     69|#define XML_SCHEMAS_FINAL_DEFAULT_RESTRICTION            1 << 3
  ------------------
  |  Branch (9239:10): [True: 0, False: 69]
  ------------------
 9240|      0|		type->flags |= XML_SCHEMAS_TYPE_FINAL_RESTRICTION;
  ------------------
  |  |  472|      0|#define XML_SCHEMAS_TYPE_FINAL_RESTRICTION    1 << 10
  ------------------
 9241|     69|	    if (schema->flags & XML_SCHEMAS_FINAL_DEFAULT_LIST)
  ------------------
  |  |  886|     69|#define XML_SCHEMAS_FINAL_DEFAULT_LIST            1 << 4
  ------------------
  |  Branch (9241:10): [True: 0, False: 69]
  ------------------
 9242|      0|		type->flags |= XML_SCHEMAS_TYPE_FINAL_LIST;
  ------------------
  |  |  478|      0|#define XML_SCHEMAS_TYPE_FINAL_LIST    1 << 11
  ------------------
 9243|     69|	    if (schema->flags & XML_SCHEMAS_FINAL_DEFAULT_UNION)
  ------------------
  |  |  892|     69|#define XML_SCHEMAS_FINAL_DEFAULT_UNION            1 << 5
  ------------------
  |  Branch (9243:10): [True: 0, False: 69]
  ------------------
 9244|      0|		type->flags |= XML_SCHEMAS_TYPE_FINAL_UNION;
  ------------------
  |  |  484|      0|#define XML_SCHEMAS_TYPE_FINAL_UNION    1 << 12
  ------------------
 9245|     69|	} else {
 9246|      0|	    attrValue = xmlSchemaGetProp(ctxt, node, "final");
 9247|      0|	    if (xmlSchemaPValAttrBlockFinal(attrValue, &(type->flags),
  ------------------
  |  Branch (9247:10): [True: 0, False: 0]
  ------------------
 9248|      0|		-1, -1, XML_SCHEMAS_TYPE_FINAL_RESTRICTION, -1,
  ------------------
  |  |  472|      0|#define XML_SCHEMAS_TYPE_FINAL_RESTRICTION    1 << 10
  ------------------
 9249|      0|		XML_SCHEMAS_TYPE_FINAL_LIST,
  ------------------
  |  |  478|      0|#define XML_SCHEMAS_TYPE_FINAL_LIST    1 << 11
  ------------------
 9250|      0|		XML_SCHEMAS_TYPE_FINAL_UNION) != 0) {
  ------------------
  |  |  484|      0|#define XML_SCHEMAS_TYPE_FINAL_UNION    1 << 12
  ------------------
 9251|       |
 9252|      0|		xmlSchemaPSimpleTypeErr(ctxt,
 9253|      0|		    XML_SCHEMAP_S4S_ATTR_INVALID_VALUE,
 9254|      0|		    WXS_BASIC_CAST type, (xmlNodePtr) attr,
  ------------------
  |  |  124|      0|#define WXS_BASIC_CAST (xmlSchemaBasicItemPtr)
  ------------------
 9255|      0|		    NULL, "(#all | List of (list | union | restriction)",
 9256|      0|		    attrValue, NULL, NULL, NULL);
 9257|      0|	    }
 9258|      0|	}
 9259|     69|    }
 9260|    160|    type->targetNamespace = ctxt->targetNamespace;
 9261|    160|    xmlSchemaPValAttrID(ctxt, node, BAD_CAST "id");
  ------------------
  |  |   35|    160|#define BAD_CAST (xmlChar *)
  ------------------
 9262|       |    /*
 9263|       |    * And now for the children...
 9264|       |    */
 9265|    160|    oldCtxtType = ctxt->ctxtType;
 9266|       |
 9267|    160|    ctxt->ctxtType = type;
 9268|       |
 9269|    160|    child = node->children;
 9270|    160|    if (IS_SCHEMA(child, "annotation")) {
  ------------------
  |  |  316|    160|   ((node != NULL) && (node->ns != NULL) && \
  |  |  ------------------
  |  |  |  Branch (316:5): [True: 160, False: 0]
  |  |  |  Branch (316:23): [True: 160, False: 0]
  |  |  ------------------
  |  |  317|    160|    (xmlStrEqual(node->name, (const xmlChar *) type)) && \
  |  |  ------------------
  |  |  |  Branch (317:5): [True: 7, False: 153]
  |  |  ------------------
  |  |  318|    160|    (xmlStrEqual(node->ns->href, xmlSchemaNs)))
  |  |  ------------------
  |  |  |  Branch (318:5): [True: 7, False: 0]
  |  |  ------------------
  ------------------
 9271|      7|        type->annot = xmlSchemaParseAnnotation(ctxt, child, 1);
 9272|      7|        child = child->next;
 9273|      7|    }
 9274|    160|    if (child == NULL) {
  ------------------
  |  Branch (9274:9): [True: 0, False: 160]
  ------------------
 9275|      0|	xmlSchemaPContentErr(ctxt, XML_SCHEMAP_S4S_ELEM_MISSING,
 9276|      0|	    NULL, node, child, NULL,
 9277|      0|	    "(annotation?, (restriction | list | union))");
 9278|    160|    } else if (IS_SCHEMA(child, "restriction")) {
  ------------------
  |  |  316|    160|   ((node != NULL) && (node->ns != NULL) && \
  |  |  ------------------
  |  |  |  Branch (316:5): [True: 160, False: 0]
  |  |  |  Branch (316:23): [True: 160, False: 0]
  |  |  ------------------
  |  |  317|    160|    (xmlStrEqual(node->name, (const xmlChar *) type)) && \
  |  |  ------------------
  |  |  |  Branch (317:5): [True: 124, False: 36]
  |  |  ------------------
  |  |  318|    160|    (xmlStrEqual(node->ns->href, xmlSchemaNs)))
  |  |  ------------------
  |  |  |  Branch (318:5): [True: 124, False: 0]
  |  |  ------------------
  ------------------
 9279|    124|        xmlSchemaParseRestriction(ctxt, schema, child,
 9280|    124|	    XML_SCHEMA_TYPE_SIMPLE);
 9281|    124|	hasRestriction = 1;
 9282|    124|        child = child->next;
 9283|    124|    } else if (IS_SCHEMA(child, "list")) {
  ------------------
  |  |  316|     36|   ((node != NULL) && (node->ns != NULL) && \
  |  |  ------------------
  |  |  |  Branch (316:5): [True: 36, False: 0]
  |  |  |  Branch (316:23): [True: 36, False: 0]
  |  |  ------------------
  |  |  317|     36|    (xmlStrEqual(node->name, (const xmlChar *) type)) && \
  |  |  ------------------
  |  |  |  Branch (317:5): [True: 11, False: 25]
  |  |  ------------------
  |  |  318|     36|    (xmlStrEqual(node->ns->href, xmlSchemaNs)))
  |  |  ------------------
  |  |  |  Branch (318:5): [True: 11, False: 0]
  |  |  ------------------
  ------------------
 9284|     11|        xmlSchemaParseList(ctxt, schema, child);
 9285|     11|        child = child->next;
 9286|     25|    } else if (IS_SCHEMA(child, "union")) {
  ------------------
  |  |  316|     25|   ((node != NULL) && (node->ns != NULL) && \
  |  |  ------------------
  |  |  |  Branch (316:5): [True: 25, False: 0]
  |  |  |  Branch (316:23): [True: 25, False: 0]
  |  |  ------------------
  |  |  317|     25|    (xmlStrEqual(node->name, (const xmlChar *) type)) && \
  |  |  ------------------
  |  |  |  Branch (317:5): [True: 25, False: 0]
  |  |  ------------------
  |  |  318|     25|    (xmlStrEqual(node->ns->href, xmlSchemaNs)))
  |  |  ------------------
  |  |  |  Branch (318:5): [True: 25, False: 0]
  |  |  ------------------
  ------------------
 9287|     25|        xmlSchemaParseUnion(ctxt, schema, child);
 9288|     25|        child = child->next;
 9289|     25|    }
 9290|    160|    if (child != NULL) {
  ------------------
  |  Branch (9290:9): [True: 0, False: 160]
  ------------------
 9291|      0|	xmlSchemaPContentErr(ctxt, XML_SCHEMAP_S4S_ELEM_NOT_ALLOWED,
 9292|      0|	    NULL, node, child, NULL,
 9293|      0|	    "(annotation?, (restriction | list | union))");
 9294|      0|    }
 9295|       |    /*
 9296|       |    * REDEFINE: SPEC src-redefine (5)
 9297|       |    * "Within the [children], each <simpleType> must have a
 9298|       |    * <restriction> among its [children] ... the `actual value` of whose
 9299|       |    * base [attribute] must be the same as the `actual value` of its own
 9300|       |    * name attribute plus target namespace;"
 9301|       |    */
 9302|    160|    if (topLevel && ctxt->isRedefine && (! hasRestriction)) {
  ------------------
  |  Branch (9302:9): [True: 69, False: 91]
  |  Branch (9302:21): [True: 0, False: 69]
  |  Branch (9302:41): [True: 0, False: 0]
  ------------------
 9303|      0|	xmlSchemaPCustomErr(ctxt, XML_SCHEMAP_SRC_REDEFINE,
 9304|      0|	    NULL, node, "This is a redefinition, thus the "
 9305|      0|	    "<simpleType> must have a <restriction> child", NULL);
 9306|      0|    }
 9307|       |
 9308|    160|    ctxt->ctxtType = oldCtxtType;
 9309|    160|    return (type);
 9310|    160|}
xmlschemas.c:xmlSchemaParseList:
 9001|     11|{
 9002|     11|    xmlSchemaTypePtr type;
 9003|     11|    xmlNodePtr child = NULL;
 9004|     11|    xmlAttrPtr attr;
 9005|       |
 9006|     11|    if ((ctxt == NULL) || (schema == NULL) || (node == NULL))
  ------------------
  |  Branch (9006:9): [True: 0, False: 11]
  |  Branch (9006:27): [True: 0, False: 11]
  |  Branch (9006:47): [True: 0, False: 11]
  ------------------
 9007|      0|        return (NULL);
 9008|       |    /* Not a component, don't create it. */
 9009|     11|    type = ctxt->ctxtType;
 9010|       |    /*
 9011|       |    * Mark the type as being of variety "list".
 9012|       |    */
 9013|     11|    type->flags |= XML_SCHEMAS_TYPE_VARIETY_LIST;
  ------------------
  |  |  448|     11|#define XML_SCHEMAS_TYPE_VARIETY_LIST    1 << 6
  ------------------
 9014|       |    /*
 9015|       |    * SPEC (Base type) (2) "If the <list> or <union> alternative is chosen,
 9016|       |    * then the `simple ur-type definition`."
 9017|       |    */
 9018|     11|    type->baseType = xmlSchemaGetBuiltInType(XML_SCHEMAS_ANYSIMPLETYPE);
 9019|       |    /*
 9020|       |    * Check for illegal attributes.
 9021|       |    */
 9022|     11|    attr = node->properties;
 9023|     15|    while (attr != NULL) {
  ------------------
  |  Branch (9023:12): [True: 4, False: 11]
  ------------------
 9024|      4|	if (attr->ns == NULL) {
  ------------------
  |  Branch (9024:6): [True: 4, False: 0]
  ------------------
 9025|      4|	    if ((!xmlStrEqual(attr->name, BAD_CAST "id")) &&
  ------------------
  |  |   35|      4|#define BAD_CAST (xmlChar *)
  ------------------
  |  Branch (9025:10): [True: 4, False: 0]
  ------------------
 9026|      4|		(!xmlStrEqual(attr->name, BAD_CAST "itemType"))) {
  ------------------
  |  |   35|      4|#define BAD_CAST (xmlChar *)
  ------------------
  |  Branch (9026:3): [True: 0, False: 4]
  ------------------
 9027|      0|		xmlSchemaPIllegalAttrErr(ctxt,
 9028|      0|		    XML_SCHEMAP_S4S_ATTR_NOT_ALLOWED, NULL, attr);
 9029|      0|	    }
 9030|      4|	} else if (xmlStrEqual(attr->ns->href, xmlSchemaNs)) {
  ------------------
  |  Branch (9030:13): [True: 0, False: 0]
  ------------------
 9031|      0|	    xmlSchemaPIllegalAttrErr(ctxt,
 9032|      0|		XML_SCHEMAP_S4S_ATTR_NOT_ALLOWED, NULL, attr);
 9033|      0|	}
 9034|      4|	attr = attr->next;
 9035|      4|    }
 9036|       |
 9037|     11|    xmlSchemaPValAttrID(ctxt, node, BAD_CAST "id");
  ------------------
  |  |   35|     11|#define BAD_CAST (xmlChar *)
  ------------------
 9038|       |
 9039|       |    /*
 9040|       |    * Attribute "itemType". NOTE that we will use the "ref" and "refNs"
 9041|       |    * fields for holding the reference to the itemType.
 9042|       |    *
 9043|       |    * REVAMP TODO: Use the "base" and "baseNs" fields, since we will remove
 9044|       |    * the "ref" fields.
 9045|       |    */
 9046|     11|    xmlSchemaPValAttrQName(ctxt, schema, NULL,
 9047|     11|	node, "itemType", &(type->baseNs), &(type->base));
 9048|       |    /*
 9049|       |    * And now for the children...
 9050|       |    */
 9051|     11|    child = node->children;
 9052|     11|    if (IS_SCHEMA(child, "annotation")) {
  ------------------
  |  |  316|     11|   ((node != NULL) && (node->ns != NULL) && \
  |  |  ------------------
  |  |  |  Branch (316:5): [True: 7, False: 4]
  |  |  |  Branch (316:23): [True: 7, False: 0]
  |  |  ------------------
  |  |  317|     11|    (xmlStrEqual(node->name, (const xmlChar *) type)) && \
  |  |  ------------------
  |  |  |  Branch (317:5): [True: 0, False: 7]
  |  |  ------------------
  |  |  318|     11|    (xmlStrEqual(node->ns->href, xmlSchemaNs)))
  |  |  ------------------
  |  |  |  Branch (318:5): [True: 0, False: 0]
  |  |  ------------------
  ------------------
 9053|      0|	xmlSchemaAddAnnotation((xmlSchemaAnnotItemPtr) type,
 9054|      0|	    xmlSchemaParseAnnotation(ctxt, child, 1));
 9055|      0|        child = child->next;
 9056|      0|    }
 9057|     11|    if (IS_SCHEMA(child, "simpleType")) {
  ------------------
  |  |  316|     11|   ((node != NULL) && (node->ns != NULL) && \
  |  |  ------------------
  |  |  |  Branch (316:5): [True: 7, False: 4]
  |  |  |  Branch (316:23): [True: 7, False: 0]
  |  |  ------------------
  |  |  317|     11|    (xmlStrEqual(node->name, (const xmlChar *) type)) && \
  |  |  ------------------
  |  |  |  Branch (317:5): [True: 7, False: 0]
  |  |  ------------------
  |  |  318|     11|    (xmlStrEqual(node->ns->href, xmlSchemaNs)))
  |  |  ------------------
  |  |  |  Branch (318:5): [True: 7, False: 0]
  |  |  ------------------
  ------------------
 9058|       |	/*
 9059|       |	* src-list-itemType-or-simpleType
 9060|       |	* Either the itemType [attribute] or the <simpleType> [child] of
 9061|       |	* the <list> element must be present, but not both.
 9062|       |	*/
 9063|      7|	if (type->base != NULL) {
  ------------------
  |  Branch (9063:6): [True: 0, False: 7]
  ------------------
 9064|      0|	    xmlSchemaPCustomErr(ctxt,
 9065|      0|		XML_SCHEMAP_SRC_SIMPLE_TYPE_1,
 9066|      0|		NULL, node,
 9067|      0|		"The attribute 'itemType' and the <simpleType> child "
 9068|      0|		"are mutually exclusive", NULL);
 9069|      7|	} else {
 9070|      7|	    type->subtypes = xmlSchemaParseSimpleType(ctxt, schema, child, 0);
 9071|      7|	}
 9072|      7|        child = child->next;
 9073|      7|    } else if (type->base == NULL) {
  ------------------
  |  Branch (9073:16): [True: 0, False: 4]
  ------------------
 9074|      0|	xmlSchemaPCustomErr(ctxt,
 9075|      0|	    XML_SCHEMAP_SRC_SIMPLE_TYPE_1,
 9076|      0|	    NULL, node,
 9077|      0|	    "Either the attribute 'itemType' or the <simpleType> child "
 9078|      0|	    "must be present", NULL);
 9079|      0|    }
 9080|     11|    if (child != NULL) {
  ------------------
  |  Branch (9080:9): [True: 0, False: 11]
  ------------------
 9081|      0|	xmlSchemaPContentErr(ctxt,
 9082|      0|	    XML_SCHEMAP_S4S_ELEM_NOT_ALLOWED,
 9083|      0|	    NULL, node, child, NULL, "(annotation?, simpleType?)");
 9084|      0|    }
 9085|     11|    if ((type->base == NULL) &&
  ------------------
  |  Branch (9085:9): [True: 7, False: 4]
  ------------------
 9086|     11|	(type->subtypes == NULL) &&
  ------------------
  |  Branch (9086:2): [True: 0, False: 7]
  ------------------
 9087|     11|	(xmlSchemaGetPropNode(node, "itemType") == NULL)) {
  ------------------
  |  Branch (9087:2): [True: 0, False: 0]
  ------------------
 9088|      0|	xmlSchemaPCustomErr(ctxt,
 9089|      0|	    XML_SCHEMAP_SRC_SIMPLE_TYPE_1,
 9090|      0|	    NULL, node,
 9091|      0|	    "Either the attribute 'itemType' or the <simpleType> child "
 9092|      0|	    "must be present", NULL);
 9093|      0|    }
 9094|     11|    return (NULL);
 9095|     11|}
xmlschemas.c:xmlSchemaParseUnion:
 8824|     25|{
 8825|     25|    xmlSchemaTypePtr type;
 8826|     25|    xmlNodePtr child = NULL;
 8827|     25|    xmlAttrPtr attr;
 8828|     25|    const xmlChar *cur = NULL;
 8829|       |
 8830|     25|    if ((ctxt == NULL) || (schema == NULL) || (node == NULL))
  ------------------
  |  Branch (8830:9): [True: 0, False: 25]
  |  Branch (8830:27): [True: 0, False: 25]
  |  Branch (8830:47): [True: 0, False: 25]
  ------------------
 8831|      0|        return (-1);
 8832|       |    /* Not a component, don't create it. */
 8833|     25|    type = ctxt->ctxtType;
 8834|       |    /*
 8835|       |    * Mark the simple type as being of variety "union".
 8836|       |    */
 8837|     25|    type->flags |= XML_SCHEMAS_TYPE_VARIETY_UNION;
  ------------------
  |  |  454|     25|#define XML_SCHEMAS_TYPE_VARIETY_UNION    1 << 7
  ------------------
 8838|       |    /*
 8839|       |    * SPEC (Base type) (2) "If the <list> or <union> alternative is chosen,
 8840|       |    * then the `simple ur-type definition`."
 8841|       |    */
 8842|     25|    type->baseType = xmlSchemaGetBuiltInType(XML_SCHEMAS_ANYSIMPLETYPE);
 8843|       |    /*
 8844|       |    * Check for illegal attributes.
 8845|       |    */
 8846|     25|    attr = node->properties;
 8847|     44|    while (attr != NULL) {
  ------------------
  |  Branch (8847:12): [True: 19, False: 25]
  ------------------
 8848|     19|	if (attr->ns == NULL) {
  ------------------
  |  Branch (8848:6): [True: 19, False: 0]
  ------------------
 8849|     19|	    if ((!xmlStrEqual(attr->name, BAD_CAST "id")) &&
  ------------------
  |  |   35|     19|#define BAD_CAST (xmlChar *)
  ------------------
  |  Branch (8849:10): [True: 19, False: 0]
  ------------------
 8850|     19|		(!xmlStrEqual(attr->name, BAD_CAST "memberTypes"))) {
  ------------------
  |  |   35|     19|#define BAD_CAST (xmlChar *)
  ------------------
  |  Branch (8850:3): [True: 0, False: 19]
  ------------------
 8851|      0|		xmlSchemaPIllegalAttrErr(ctxt,
 8852|      0|		    XML_SCHEMAP_S4S_ATTR_NOT_ALLOWED, NULL, attr);
 8853|      0|	    }
 8854|     19|	} else if (xmlStrEqual(attr->ns->href, xmlSchemaNs)) {
  ------------------
  |  Branch (8854:13): [True: 0, False: 0]
  ------------------
 8855|      0|	    xmlSchemaPIllegalAttrErr(ctxt,
 8856|      0|		XML_SCHEMAP_S4S_ATTR_NOT_ALLOWED, NULL, attr);
 8857|      0|	}
 8858|     19|	attr = attr->next;
 8859|     19|    }
 8860|     25|    xmlSchemaPValAttrID(ctxt, node, BAD_CAST "id");
  ------------------
  |  |   35|     25|#define BAD_CAST (xmlChar *)
  ------------------
 8861|       |    /*
 8862|       |    * Attribute "memberTypes". This is a list of QNames.
 8863|       |    * TODO: Check the value to contain anything.
 8864|       |    */
 8865|     25|    attr = xmlSchemaGetPropNode(node, "memberTypes");
 8866|     25|    if (attr != NULL) {
  ------------------
  |  Branch (8866:9): [True: 19, False: 6]
  ------------------
 8867|     19|	const xmlChar *end;
 8868|     19|	xmlChar *tmp;
 8869|     19|	const xmlChar *localName, *nsName;
 8870|     19|	xmlSchemaTypeLinkPtr link, lastLink = NULL;
 8871|     19|	xmlSchemaQNameRefPtr ref;
 8872|       |
 8873|     19|	cur = xmlSchemaGetNodeContent(ctxt, (xmlNodePtr) attr);
 8874|     19|        if (cur == NULL)
  ------------------
  |  Branch (8874:13): [True: 0, False: 19]
  ------------------
 8875|      0|            return (-1);
 8876|     19|	type->base = cur;
 8877|     51|	do {
 8878|     51|	    while (IS_BLANK_CH(*cur))
 8879|     32|		cur++;
 8880|     51|	    end = cur;
 8881|    522|	    while ((*end != 0) && (!(IS_BLANK_CH(*end))))
  ------------------
  |  |  151|    503|#define IS_BLANK_CH(c)  xmlIsBlank_ch(c)
  |  |  ------------------
  |  |  |  |   88|    503|#define xmlIsBlank_ch(c)	(((c) == 0x20) || \
  |  |  |  |  ------------------
  |  |  |  |  |  Branch (88:27): [True: 32, False: 471]
  |  |  |  |  ------------------
  |  |  |  |   89|    503|				 ((0x9 <= (c)) && ((c) <= 0xa)) || \
  |  |  |  |  ------------------
  |  |  |  |  |  Branch (89:7): [True: 471, False: 0]
  |  |  |  |  |  Branch (89:23): [True: 0, False: 471]
  |  |  |  |  ------------------
  |  |  |  |   90|    503|				 ((c) == 0xd))
  |  |  |  |  ------------------
  |  |  |  |  |  Branch (90:6): [True: 0, False: 471]
  |  |  |  |  ------------------
  |  |  ------------------
  ------------------
  |  Branch (8881:13): [True: 503, False: 19]
  ------------------
 8882|    471|		end++;
 8883|     51|	    if (end == cur)
  ------------------
  |  Branch (8883:10): [True: 0, False: 51]
  ------------------
 8884|      0|		break;
 8885|     51|	    tmp = xmlStrndup(cur, end - cur);
 8886|     51|            if (tmp == NULL) {
  ------------------
  |  Branch (8886:17): [True: 0, False: 51]
  ------------------
 8887|      0|                xmlSchemaPErrMemory(ctxt, "xmlSchemaParseUnion, "
 8888|      0|                    "duplicating type name", NULL);
 8889|      0|                return (-1);
 8890|      0|            }
 8891|     51|	    if (xmlSchemaPValAttrNodeQNameValue(ctxt, schema,
  ------------------
  |  Branch (8891:10): [True: 51, False: 0]
  ------------------
 8892|     51|		NULL, attr, BAD_CAST tmp, &nsName, &localName) == 0) {
  ------------------
  |  |   35|     51|#define BAD_CAST (xmlChar *)
  ------------------
 8893|       |		/*
 8894|       |		* Create the member type link.
 8895|       |		*/
 8896|     51|		link = (xmlSchemaTypeLinkPtr)
 8897|     51|		    xmlMalloc(sizeof(xmlSchemaTypeLink));
 8898|     51|		if (link == NULL) {
  ------------------
  |  Branch (8898:7): [True: 0, False: 51]
  ------------------
 8899|      0|		    xmlSchemaPErrMemory(ctxt, "xmlSchemaParseUnion, "
 8900|      0|			"allocating a type link", NULL);
 8901|      0|	            FREE_AND_NULL(tmp)
  ------------------
  |  |  320|      0|#define FREE_AND_NULL(str) if ((str) != NULL) { xmlFree((xmlChar *) (str)); str = NULL; }
  |  |  ------------------
  |  |  |  Branch (320:32): [True: 0, False: 0]
  |  |  ------------------
  ------------------
 8902|      0|		    return (-1);
 8903|      0|		}
 8904|     51|		link->type = NULL;
 8905|     51|		link->next = NULL;
 8906|     51|		if (lastLink == NULL)
  ------------------
  |  Branch (8906:7): [True: 19, False: 32]
  ------------------
 8907|     19|		    type->memberTypes = link;
 8908|     32|		else
 8909|     32|		    lastLink->next = link;
 8910|     51|		lastLink = link;
 8911|       |		/*
 8912|       |		* Create a reference item.
 8913|       |		*/
 8914|     51|		ref = xmlSchemaNewQNameRef(ctxt, XML_SCHEMA_TYPE_SIMPLE,
 8915|     51|		    localName, nsName);
 8916|     51|		if (ref == NULL) {
  ------------------
  |  Branch (8916:7): [True: 0, False: 51]
  ------------------
 8917|      0|		    FREE_AND_NULL(tmp)
  ------------------
  |  |  320|      0|#define FREE_AND_NULL(str) if ((str) != NULL) { xmlFree((xmlChar *) (str)); str = NULL; }
  |  |  ------------------
  |  |  |  Branch (320:32): [True: 0, False: 0]
  |  |  ------------------
  ------------------
 8918|      0|		    return (-1);
 8919|      0|		}
 8920|       |		/*
 8921|       |		* Assign the reference to the link, it will be resolved
 8922|       |		* later during fixup of the union simple type.
 8923|       |		*/
 8924|     51|		link->type = (xmlSchemaTypePtr) ref;
 8925|     51|	    }
 8926|     51|	    FREE_AND_NULL(tmp)
  ------------------
  |  |  320|     51|#define FREE_AND_NULL(str) if ((str) != NULL) { xmlFree((xmlChar *) (str)); str = NULL; }
  |  |  ------------------
  |  |  |  Branch (320:32): [True: 51, False: 0]
  |  |  ------------------
  ------------------
 8927|     51|	    cur = end;
 8928|     51|	} while (*cur != 0);
  ------------------
  |  Branch (8928:11): [True: 32, False: 19]
  ------------------
 8929|       |
 8930|     19|    }
 8931|       |    /*
 8932|       |    * And now for the children...
 8933|       |    */
 8934|     25|    child = node->children;
 8935|     25|    if (IS_SCHEMA(child, "annotation")) {
  ------------------
  |  |  316|     25|   ((node != NULL) && (node->ns != NULL) && \
  |  |  ------------------
  |  |  |  Branch (316:5): [True: 8, False: 17]
  |  |  |  Branch (316:23): [True: 8, False: 0]
  |  |  ------------------
  |  |  317|     25|    (xmlStrEqual(node->name, (const xmlChar *) type)) && \
  |  |  ------------------
  |  |  |  Branch (317:5): [True: 0, False: 8]
  |  |  ------------------
  |  |  318|     25|    (xmlStrEqual(node->ns->href, xmlSchemaNs)))
  |  |  ------------------
  |  |  |  Branch (318:5): [True: 0, False: 0]
  |  |  ------------------
  ------------------
 8936|       |	/*
 8937|       |	* Add the annotation to the simple type ancestor.
 8938|       |	*/
 8939|      0|	xmlSchemaAddAnnotation((xmlSchemaAnnotItemPtr) type,
 8940|      0|	    xmlSchemaParseAnnotation(ctxt, child, 1));
 8941|      0|        child = child->next;
 8942|      0|    }
 8943|     25|    if (IS_SCHEMA(child, "simpleType")) {
  ------------------
  |  |  316|     25|   ((node != NULL) && (node->ns != NULL) && \
  |  |  ------------------
  |  |  |  Branch (316:5): [True: 8, False: 17]
  |  |  |  Branch (316:23): [True: 8, False: 0]
  |  |  ------------------
  |  |  317|     25|    (xmlStrEqual(node->name, (const xmlChar *) type)) && \
  |  |  ------------------
  |  |  |  Branch (317:5): [True: 8, False: 0]
  |  |  ------------------
  |  |  318|     25|    (xmlStrEqual(node->ns->href, xmlSchemaNs)))
  |  |  ------------------
  |  |  |  Branch (318:5): [True: 8, False: 0]
  |  |  ------------------
  ------------------
 8944|      8|	xmlSchemaTypePtr subtype, last = NULL;
 8945|       |
 8946|       |	/*
 8947|       |	* Anchor the member types in the "subtypes" field of the
 8948|       |	* simple type.
 8949|       |	*/
 8950|     26|	while (IS_SCHEMA(child, "simpleType")) {
  ------------------
  |  |  316|     26|   ((node != NULL) && (node->ns != NULL) && \
  |  |  ------------------
  |  |  |  Branch (316:5): [True: 18, False: 8]
  |  |  |  Branch (316:23): [True: 18, False: 0]
  |  |  ------------------
  |  |  317|     26|    (xmlStrEqual(node->name, (const xmlChar *) type)) && \
  |  |  ------------------
  |  |  |  Branch (317:5): [True: 18, False: 0]
  |  |  ------------------
  |  |  318|     26|    (xmlStrEqual(node->ns->href, xmlSchemaNs)))
  |  |  ------------------
  |  |  |  Branch (318:5): [True: 18, False: 0]
  |  |  ------------------
  ------------------
 8951|     18|	    subtype = (xmlSchemaTypePtr)
 8952|     18|		xmlSchemaParseSimpleType(ctxt, schema, child, 0);
 8953|     18|	    if (subtype != NULL) {
  ------------------
  |  Branch (8953:10): [True: 18, False: 0]
  ------------------
 8954|     18|		if (last == NULL) {
  ------------------
  |  Branch (8954:7): [True: 8, False: 10]
  ------------------
 8955|      8|		    type->subtypes = subtype;
 8956|      8|		    last = subtype;
 8957|     10|		} else {
 8958|     10|		    last->next = subtype;
 8959|     10|		    last = subtype;
 8960|     10|		}
 8961|     18|		last->next = NULL;
 8962|     18|	    }
 8963|     18|	    child = child->next;
 8964|     18|	}
 8965|      8|    }
 8966|     25|    if (child != NULL) {
  ------------------
  |  Branch (8966:9): [True: 0, False: 25]
  ------------------
 8967|      0|	xmlSchemaPContentErr(ctxt,
 8968|      0|	    XML_SCHEMAP_S4S_ELEM_NOT_ALLOWED,
 8969|      0|	    NULL, node, child, NULL, "(annotation?, simpleType*)");
 8970|      0|    }
 8971|     25|    if ((attr == NULL) && (type->subtypes == NULL)) {
  ------------------
  |  Branch (8971:9): [True: 6, False: 19]
  |  Branch (8971:27): [True: 0, False: 6]
  ------------------
 8972|       |	 /*
 8973|       |	* src-union-memberTypes-or-simpleTypes
 8974|       |	* Either the memberTypes [attribute] of the <union> element must
 8975|       |	* be non-empty or there must be at least one simpleType [child].
 8976|       |	*/
 8977|      0|	xmlSchemaPCustomErr(ctxt,
 8978|      0|	    XML_SCHEMAP_SRC_UNION_MEMBERTYPES_OR_SIMPLETYPES,
 8979|      0|	    NULL, node,
 8980|      0|	    "Either the attribute 'memberTypes' or "
 8981|      0|	    "at least one <simpleType> child must be present", NULL);
 8982|      0|    }
 8983|     25|    return (0);
 8984|     25|}
xmlschemas.c:xmlSchemaParseElement:
 8426|    808|{
 8427|    808|    xmlSchemaElementPtr decl = NULL;
 8428|    808|    xmlSchemaParticlePtr particle = NULL;
 8429|    808|    xmlSchemaAnnotPtr annot = NULL;
 8430|    808|    xmlNodePtr child = NULL;
 8431|    808|    xmlAttrPtr attr, nameAttr;
 8432|    808|    int min, max, isRef = 0;
 8433|    808|    xmlChar *des = NULL;
 8434|       |
 8435|       |    /* 3.3.3 Constraints on XML Representations of Element Declarations */
 8436|       |    /* TODO: Complete implementation of 3.3.6 */
 8437|       |
 8438|    808|    if ((ctxt == NULL) || (schema == NULL) || (node == NULL))
  ------------------
  |  Branch (8438:9): [True: 0, False: 808]
  |  Branch (8438:27): [True: 0, False: 808]
  |  Branch (8438:47): [True: 0, False: 808]
  ------------------
 8439|      0|        return (NULL);
 8440|       |
 8441|    808|    if (isElemRef != NULL)
  ------------------
  |  Branch (8441:9): [True: 493, False: 315]
  ------------------
 8442|    493|	*isElemRef = 0;
 8443|       |    /*
 8444|       |    * If we get a "ref" attribute on a local <element> we will assume it's
 8445|       |    * a reference - even if there's a "name" attribute; this seems to be more
 8446|       |    * robust.
 8447|       |    */
 8448|    808|    nameAttr = xmlSchemaGetPropNode(node, "name");
 8449|    808|    attr = xmlSchemaGetPropNode(node, "ref");
 8450|    808|    if ((topLevel) || (attr == NULL)) {
  ------------------
  |  Branch (8450:9): [True: 315, False: 493]
  |  Branch (8450:23): [True: 280, False: 213]
  ------------------
 8451|    595|	if (nameAttr == NULL) {
  ------------------
  |  Branch (8451:6): [True: 1, False: 594]
  ------------------
 8452|      1|	    xmlSchemaPMissingAttrErr(ctxt,
 8453|      1|		XML_SCHEMAP_S4S_ATTR_MISSING,
 8454|      1|		NULL, node, "name", NULL);
 8455|      1|	    return (NULL);
 8456|      1|	}
 8457|    595|    } else
 8458|    213|	isRef = 1;
 8459|       |
 8460|    807|    xmlSchemaPValAttrID(ctxt, node, BAD_CAST "id");
  ------------------
  |  |   35|    807|#define BAD_CAST (xmlChar *)
  ------------------
 8461|    807|    child = node->children;
 8462|    807|    if (IS_SCHEMA(child, "annotation")) {
  ------------------
  |  |  316|    807|   ((node != NULL) && (node->ns != NULL) && \
  |  |  ------------------
  |  |  |  Branch (316:5): [True: 253, False: 554]
  |  |  |  Branch (316:23): [True: 253, False: 0]
  |  |  ------------------
  |  |  317|    807|    (xmlStrEqual(node->name, (const xmlChar *) type)) && \
  |  |  ------------------
  |  |  |  Branch (317:5): [True: 27, False: 226]
  |  |  ------------------
  |  |  318|    807|    (xmlStrEqual(node->ns->href, xmlSchemaNs)))
  |  |  ------------------
  |  |  |  Branch (318:5): [True: 27, False: 0]
  |  |  ------------------
  ------------------
 8463|     27|	annot = xmlSchemaParseAnnotation(ctxt, child, 1);
 8464|     27|	child = child->next;
 8465|     27|    }
 8466|       |    /*
 8467|       |    * Skip particle part if a global declaration.
 8468|       |    */
 8469|    807|    if (topLevel)
  ------------------
  |  Branch (8469:9): [True: 314, False: 493]
  ------------------
 8470|    314|	goto declaration_part;
 8471|       |    /*
 8472|       |    * The particle part ==================================================
 8473|       |    */
 8474|    493|    min = xmlGetMinOccurs(ctxt, node, 0, -1, 1, "xs:nonNegativeInteger");
 8475|    493|    max = xmlGetMaxOccurs(ctxt, node, 0, UNBOUNDED, 1, "(xs:nonNegativeInteger | unbounded)");
  ------------------
  |  |   98|    493|#define UNBOUNDED (1 << 30)
  ------------------
 8476|    493|    xmlSchemaPCheckParticleCorrect_2(ctxt, NULL, node, min, max);
 8477|    493|    particle = xmlSchemaAddParticle(ctxt, node, min, max);
 8478|    493|    if (particle == NULL)
  ------------------
  |  Branch (8478:9): [True: 0, False: 493]
  ------------------
 8479|      0|	goto return_null;
 8480|       |
 8481|       |    /* ret->flags |= XML_SCHEMAS_ELEM_REF; */
 8482|       |
 8483|    493|    if (isRef) {
  ------------------
  |  Branch (8483:9): [True: 213, False: 280]
  ------------------
 8484|    213|	const xmlChar *refNs = NULL, *ref = NULL;
 8485|    213|	xmlSchemaQNameRefPtr refer = NULL;
 8486|       |	/*
 8487|       |	* The reference part =============================================
 8488|       |	*/
 8489|    213|	if (isElemRef != NULL)
  ------------------
  |  Branch (8489:6): [True: 213, False: 0]
  ------------------
 8490|    213|	    *isElemRef = 1;
 8491|       |
 8492|    213|	xmlSchemaPValAttrNodeQName(ctxt, schema,
 8493|    213|	    NULL, attr, &refNs, &ref);
 8494|    213|	xmlSchemaCheckReference(ctxt, schema, node, attr, refNs);
 8495|       |	/*
 8496|       |	* SPEC (3.3.3 : 2.1) "One of ref or name must be present, but not both"
 8497|       |	*/
 8498|    213|	if (nameAttr != NULL) {
  ------------------
  |  Branch (8498:6): [True: 2, False: 211]
  ------------------
 8499|      2|	    xmlSchemaPMutualExclAttrErr(ctxt,
 8500|      2|		XML_SCHEMAP_SRC_ELEMENT_2_1, NULL, nameAttr, "ref", "name");
 8501|      2|	}
 8502|       |	/*
 8503|       |	* Check for illegal attributes.
 8504|       |	*/
 8505|    213|	attr = node->properties;
 8506|    558|	while (attr != NULL) {
  ------------------
  |  Branch (8506:9): [True: 352, False: 206]
  ------------------
 8507|    352|	    if (attr->ns == NULL) {
  ------------------
  |  Branch (8507:10): [True: 352, False: 0]
  ------------------
 8508|    352|		if (xmlStrEqual(attr->name, BAD_CAST "ref") ||
  ------------------
  |  |   35|    352|#define BAD_CAST (xmlChar *)
  ------------------
  |  Branch (8508:7): [True: 213, False: 139]
  ------------------
 8509|    352|		    xmlStrEqual(attr->name, BAD_CAST "name") ||
  ------------------
  |  |   35|    139|#define BAD_CAST (xmlChar *)
  ------------------
  |  Branch (8509:7): [True: 2, False: 137]
  ------------------
 8510|    352|		    xmlStrEqual(attr->name, BAD_CAST "id") ||
  ------------------
  |  |   35|    137|#define BAD_CAST (xmlChar *)
  ------------------
  |  Branch (8510:7): [True: 1, False: 136]
  ------------------
 8511|    352|		    xmlStrEqual(attr->name, BAD_CAST "maxOccurs") ||
  ------------------
  |  |   35|    136|#define BAD_CAST (xmlChar *)
  ------------------
  |  Branch (8511:7): [True: 50, False: 86]
  ------------------
 8512|    352|		    xmlStrEqual(attr->name, BAD_CAST "minOccurs"))
  ------------------
  |  |   35|     86|#define BAD_CAST (xmlChar *)
  ------------------
  |  Branch (8512:7): [True: 79, False: 7]
  ------------------
 8513|    345|		{
 8514|    345|		    attr = attr->next;
 8515|    345|		    continue;
 8516|    345|		} else {
 8517|       |		    /* SPEC (3.3.3 : 2.2) */
 8518|      7|		    xmlSchemaPCustomAttrErr(ctxt,
 8519|      7|			XML_SCHEMAP_SRC_ELEMENT_2_2,
 8520|      7|			NULL, NULL, attr,
 8521|      7|			"Only the attributes 'minOccurs', 'maxOccurs' and "
 8522|      7|			"'id' are allowed in addition to 'ref'");
 8523|      7|		    break;
 8524|      7|		}
 8525|    352|	    } else if (xmlStrEqual(attr->ns->href, xmlSchemaNs)) {
  ------------------
  |  Branch (8525:17): [True: 0, False: 0]
  ------------------
 8526|      0|		xmlSchemaPIllegalAttrErr(ctxt,
 8527|      0|		    XML_SCHEMAP_S4S_ATTR_NOT_ALLOWED, NULL, attr);
 8528|      0|	    }
 8529|      0|	    attr = attr->next;
 8530|      0|	}
 8531|       |	/*
 8532|       |	* No children except <annotation> expected.
 8533|       |	*/
 8534|    213|	if (child != NULL) {
  ------------------
  |  Branch (8534:6): [True: 3, False: 210]
  ------------------
 8535|      3|	    xmlSchemaPContentErr(ctxt, XML_SCHEMAP_S4S_ELEM_NOT_ALLOWED,
 8536|      3|		NULL, node, child, NULL, "(annotation?)");
 8537|      3|	}
 8538|    213|	if ((min == 0) && (max == 0))
  ------------------
  |  Branch (8538:6): [True: 72, False: 141]
  |  Branch (8538:20): [True: 0, False: 72]
  ------------------
 8539|      0|	    goto return_null;
 8540|       |	/*
 8541|       |	* Create the reference item and attach it to the particle.
 8542|       |	*/
 8543|    213|	refer = xmlSchemaNewQNameRef(ctxt, XML_SCHEMA_TYPE_ELEMENT,
 8544|    213|	    ref, refNs);
 8545|    213|	if (refer == NULL)
  ------------------
  |  Branch (8545:6): [True: 0, False: 213]
  ------------------
 8546|      0|	    goto return_null;
 8547|    213|	particle->children = (xmlSchemaTreeItemPtr) refer;
 8548|    213|	particle->annot = annot;
 8549|       |	/*
 8550|       |	* Add the particle to pending components, since the reference
 8551|       |	* need to be resolved.
 8552|       |	*/
 8553|    213|	WXS_ADD_PENDING(ctxt, particle);
  ------------------
  |  |  307|    213|    xmlSchemaAddItemSize(&((ctx)->constructor->pending), 10, item)
  ------------------
 8554|    213|	return ((xmlSchemaBasicItemPtr) particle);
 8555|    213|    }
 8556|       |    /*
 8557|       |    * The declaration part ===============================================
 8558|       |    */
 8559|    594|declaration_part:
 8560|    594|    {
 8561|    594|	const xmlChar *ns = NULL, *fixed, *name, *attrValue;
 8562|    594|	xmlSchemaIDCPtr curIDC = NULL, lastIDC = NULL;
 8563|       |
 8564|    594|	if (xmlSchemaPValAttrNode(ctxt, NULL, nameAttr,
  ------------------
  |  Branch (8564:6): [True: 0, False: 594]
  ------------------
 8565|    594|	    xmlSchemaGetBuiltInType(XML_SCHEMAS_NCNAME), &name) != 0)
 8566|      0|	    goto return_null;
 8567|       |	/*
 8568|       |	* Evaluate the target namespace.
 8569|       |	*/
 8570|    594|	if (topLevel) {
  ------------------
  |  Branch (8570:6): [True: 314, False: 280]
  ------------------
 8571|    314|	    ns = ctxt->targetNamespace;
 8572|    314|	} else {
 8573|    280|	    attr = xmlSchemaGetPropNode(node, "form");
 8574|    280|	    if (attr != NULL) {
  ------------------
  |  Branch (8574:10): [True: 4, False: 276]
  ------------------
 8575|      4|		attrValue = xmlSchemaGetNodeContent(ctxt, (xmlNodePtr) attr);
 8576|      4|		if (xmlStrEqual(attrValue, BAD_CAST "qualified")) {
  ------------------
  |  |   35|      4|#define BAD_CAST (xmlChar *)
  ------------------
  |  Branch (8576:7): [True: 4, False: 0]
  ------------------
 8577|      4|		    ns = ctxt->targetNamespace;
 8578|      4|		} else if (!xmlStrEqual(attrValue, BAD_CAST "unqualified")) {
  ------------------
  |  |   35|      0|#define BAD_CAST (xmlChar *)
  ------------------
  |  Branch (8578:14): [True: 0, False: 0]
  ------------------
 8579|      0|		    xmlSchemaPSimpleTypeErr(ctxt,
 8580|      0|			XML_SCHEMAP_S4S_ATTR_INVALID_VALUE,
 8581|      0|			NULL, (xmlNodePtr) attr,
 8582|      0|			NULL, "(qualified | unqualified)",
 8583|      0|			attrValue, NULL, NULL, NULL);
 8584|      0|		}
 8585|    276|	    } else if (schema->flags & XML_SCHEMAS_QUALIF_ELEM)
  ------------------
  |  |  861|    276|#define XML_SCHEMAS_QUALIF_ELEM                1 << 0
  ------------------
  |  Branch (8585:17): [True: 125, False: 151]
  ------------------
 8586|    125|		ns = ctxt->targetNamespace;
 8587|    280|	}
 8588|    594|	decl = xmlSchemaAddElement(ctxt, name, ns, node, topLevel);
 8589|    594|	if (decl == NULL) {
  ------------------
  |  Branch (8589:6): [True: 0, False: 594]
  ------------------
 8590|      0|	    goto return_null;
 8591|      0|	}
 8592|       |	/*
 8593|       |	* Check for illegal attributes.
 8594|       |	*/
 8595|    594|	attr = node->properties;
 8596|  1.64k|	while (attr != NULL) {
  ------------------
  |  Branch (8596:9): [True: 1.05k, False: 594]
  ------------------
 8597|  1.05k|	    if (attr->ns == NULL) {
  ------------------
  |  Branch (8597:10): [True: 1.05k, False: 1]
  ------------------
 8598|  1.05k|		if ((!xmlStrEqual(attr->name, BAD_CAST "name")) &&
  ------------------
  |  |   35|  1.05k|#define BAD_CAST (xmlChar *)
  ------------------
  |  Branch (8598:7): [True: 458, False: 594]
  ------------------
 8599|  1.05k|		    (!xmlStrEqual(attr->name, BAD_CAST "type")) &&
  ------------------
  |  |   35|    458|#define BAD_CAST (xmlChar *)
  ------------------
  |  Branch (8599:7): [True: 196, False: 262]
  ------------------
 8600|  1.05k|		    (!xmlStrEqual(attr->name, BAD_CAST "id")) &&
  ------------------
  |  |   35|    196|#define BAD_CAST (xmlChar *)
  ------------------
  |  Branch (8600:7): [True: 190, False: 6]
  ------------------
 8601|  1.05k|		    (!xmlStrEqual(attr->name, BAD_CAST "default")) &&
  ------------------
  |  |   35|    190|#define BAD_CAST (xmlChar *)
  ------------------
  |  Branch (8601:7): [True: 186, False: 4]
  ------------------
 8602|  1.05k|		    (!xmlStrEqual(attr->name, BAD_CAST "fixed")) &&
  ------------------
  |  |   35|    186|#define BAD_CAST (xmlChar *)
  ------------------
  |  Branch (8602:7): [True: 183, False: 3]
  ------------------
 8603|  1.05k|		    (!xmlStrEqual(attr->name, BAD_CAST "block")) &&
  ------------------
  |  |   35|    183|#define BAD_CAST (xmlChar *)
  ------------------
  |  Branch (8603:7): [True: 179, False: 4]
  ------------------
 8604|  1.05k|		    (!xmlStrEqual(attr->name, BAD_CAST "nillable")))
  ------------------
  |  |   35|    179|#define BAD_CAST (xmlChar *)
  ------------------
  |  Branch (8604:7): [True: 161, False: 18]
  ------------------
 8605|    161|		{
 8606|    161|		    if (topLevel == 0) {
  ------------------
  |  Branch (8606:11): [True: 122, False: 39]
  ------------------
 8607|    122|			if ((!xmlStrEqual(attr->name, BAD_CAST "maxOccurs")) &&
  ------------------
  |  |   35|    122|#define BAD_CAST (xmlChar *)
  ------------------
  |  Branch (8607:8): [True: 78, False: 44]
  ------------------
 8608|    122|			    (!xmlStrEqual(attr->name, BAD_CAST "minOccurs")) &&
  ------------------
  |  |   35|     78|#define BAD_CAST (xmlChar *)
  ------------------
  |  Branch (8608:8): [True: 7, False: 71]
  ------------------
 8609|    122|			    (!xmlStrEqual(attr->name, BAD_CAST "form")))
  ------------------
  |  |   35|      7|#define BAD_CAST (xmlChar *)
  ------------------
  |  Branch (8609:8): [True: 3, False: 4]
  ------------------
 8610|      3|			{
 8611|      3|			    xmlSchemaPIllegalAttrErr(ctxt,
 8612|      3|				XML_SCHEMAP_S4S_ATTR_NOT_ALLOWED, NULL, attr);
 8613|      3|			}
 8614|    122|		    } else if ((!xmlStrEqual(attr->name, BAD_CAST "final")) &&
  ------------------
  |  |   35|     39|#define BAD_CAST (xmlChar *)
  ------------------
  |  Branch (8614:18): [True: 37, False: 2]
  ------------------
 8615|     39|			(!xmlStrEqual(attr->name, BAD_CAST "abstract")) &&
  ------------------
  |  |   35|     37|#define BAD_CAST (xmlChar *)
  ------------------
  |  Branch (8615:4): [True: 31, False: 6]
  ------------------
 8616|     39|			(!xmlStrEqual(attr->name, BAD_CAST "substitutionGroup"))) {
  ------------------
  |  |   35|     31|#define BAD_CAST (xmlChar *)
  ------------------
  |  Branch (8616:4): [True: 4, False: 27]
  ------------------
 8617|       |
 8618|      4|			xmlSchemaPIllegalAttrErr(ctxt,
 8619|      4|			    XML_SCHEMAP_S4S_ATTR_NOT_ALLOWED, NULL, attr);
 8620|      4|		    }
 8621|    161|		}
 8622|  1.05k|	    } else if (xmlStrEqual(attr->ns->href, xmlSchemaNs)) {
  ------------------
  |  Branch (8622:17): [True: 0, False: 1]
  ------------------
 8623|       |
 8624|      0|		xmlSchemaPIllegalAttrErr(ctxt,
 8625|      0|		    XML_SCHEMAP_S4S_ATTR_NOT_ALLOWED, NULL, attr);
 8626|      0|	    }
 8627|  1.05k|	    attr = attr->next;
 8628|  1.05k|	}
 8629|       |	/*
 8630|       |	* Extract/validate attributes.
 8631|       |	*/
 8632|    594|	if (topLevel) {
  ------------------
  |  Branch (8632:6): [True: 314, False: 280]
  ------------------
 8633|       |	    /*
 8634|       |	    * Process top attributes of global element declarations here.
 8635|       |	    */
 8636|    314|	    decl->flags |= XML_SCHEMAS_ELEM_GLOBAL;
  ------------------
  |  |  655|    314|#define XML_SCHEMAS_ELEM_GLOBAL                1 << 1
  ------------------
 8637|    314|	    decl->flags |= XML_SCHEMAS_ELEM_TOPLEVEL;
  ------------------
  |  |  680|    314|#define XML_SCHEMAS_ELEM_TOPLEVEL        1 << 5
  ------------------
 8638|    314|	    xmlSchemaPValAttrQName(ctxt, schema,
 8639|    314|		NULL, node, "substitutionGroup",
 8640|    314|		&(decl->substGroupNs), &(decl->substGroup));
 8641|    314|	    if (xmlGetBooleanProp(ctxt, node, "abstract", 0))
  ------------------
  |  Branch (8641:10): [True: 6, False: 308]
  ------------------
 8642|      6|		decl->flags |= XML_SCHEMAS_ELEM_ABSTRACT;
  ------------------
  |  |  673|      6|#define XML_SCHEMAS_ELEM_ABSTRACT        1 << 4
  ------------------
 8643|       |	    /*
 8644|       |	    * Attribute "final".
 8645|       |	    */
 8646|    314|	    attr = xmlSchemaGetPropNode(node, "final");
 8647|    314|	    if (attr == NULL) {
  ------------------
  |  Branch (8647:10): [True: 312, False: 2]
  ------------------
 8648|    312|		if (schema->flags & XML_SCHEMAS_FINAL_DEFAULT_EXTENSION)
  ------------------
  |  |  874|    312|#define XML_SCHEMAS_FINAL_DEFAULT_EXTENSION        1 << 2
  ------------------
  |  Branch (8648:7): [True: 1, False: 311]
  ------------------
 8649|      1|		    decl->flags |= XML_SCHEMAS_ELEM_FINAL_EXTENSION;
  ------------------
  |  |  742|      1|#define XML_SCHEMAS_ELEM_FINAL_EXTENSION        1 << 15
  ------------------
 8650|    312|		if (schema->flags & XML_SCHEMAS_FINAL_DEFAULT_RESTRICTION)
  ------------------
  |  |  880|    312|#define XML_SCHEMAS_FINAL_DEFAULT_RESTRICTION            1 << 3
  ------------------
  |  Branch (8650:7): [True: 0, False: 312]
  ------------------
 8651|      0|		    decl->flags |= XML_SCHEMAS_ELEM_FINAL_RESTRICTION;
  ------------------
  |  |  748|      0|#define XML_SCHEMAS_ELEM_FINAL_RESTRICTION        1 << 16
  ------------------
 8652|    312|	    } else {
 8653|      2|		attrValue = xmlSchemaGetNodeContent(ctxt, (xmlNodePtr) attr);
 8654|      2|		if (xmlSchemaPValAttrBlockFinal(attrValue, &(decl->flags),
  ------------------
  |  Branch (8654:7): [True: 1, False: 1]
  ------------------
 8655|      2|		    -1,
 8656|      2|		    XML_SCHEMAS_ELEM_FINAL_EXTENSION,
  ------------------
  |  |  742|      2|#define XML_SCHEMAS_ELEM_FINAL_EXTENSION        1 << 15
  ------------------
 8657|      2|		    XML_SCHEMAS_ELEM_FINAL_RESTRICTION, -1, -1, -1) != 0) {
  ------------------
  |  |  748|      2|#define XML_SCHEMAS_ELEM_FINAL_RESTRICTION        1 << 16
  ------------------
 8658|      1|		    xmlSchemaPSimpleTypeErr(ctxt,
 8659|      1|			XML_SCHEMAP_S4S_ATTR_INVALID_VALUE,
 8660|      1|			NULL, (xmlNodePtr) attr,
 8661|      1|			NULL, "(#all | List of (extension | restriction))",
 8662|      1|			attrValue, NULL, NULL, NULL);
 8663|      1|		}
 8664|      2|	    }
 8665|    314|	}
 8666|       |	/*
 8667|       |	* Attribute "block".
 8668|       |	*/
 8669|    594|	attr = xmlSchemaGetPropNode(node, "block");
 8670|    594|	if (attr == NULL) {
  ------------------
  |  Branch (8670:6): [True: 590, False: 4]
  ------------------
 8671|       |	    /*
 8672|       |	    * Apply default "block" values.
 8673|       |	    */
 8674|    590|	    if (schema->flags & XML_SCHEMAS_BLOCK_DEFAULT_RESTRICTION)
  ------------------
  |  |  904|    590|#define XML_SCHEMAS_BLOCK_DEFAULT_RESTRICTION            1 << 7
  ------------------
  |  Branch (8674:10): [True: 0, False: 590]
  ------------------
 8675|      0|		decl->flags |= XML_SCHEMAS_ELEM_BLOCK_RESTRICTION;
  ------------------
  |  |  724|      0|#define XML_SCHEMAS_ELEM_BLOCK_RESTRICTION        1 << 12
  ------------------
 8676|    590|	    if (schema->flags & XML_SCHEMAS_BLOCK_DEFAULT_EXTENSION)
  ------------------
  |  |  898|    590|#define XML_SCHEMAS_BLOCK_DEFAULT_EXTENSION            1 << 6
  ------------------
  |  Branch (8676:10): [True: 2, False: 588]
  ------------------
 8677|      2|		decl->flags |= XML_SCHEMAS_ELEM_BLOCK_EXTENSION;
  ------------------
  |  |  718|      2|#define XML_SCHEMAS_ELEM_BLOCK_EXTENSION        1 << 11
  ------------------
 8678|    590|	    if (schema->flags & XML_SCHEMAS_BLOCK_DEFAULT_SUBSTITUTION)
  ------------------
  |  |  910|    590|#define XML_SCHEMAS_BLOCK_DEFAULT_SUBSTITUTION            1 << 8
  ------------------
  |  Branch (8678:10): [True: 0, False: 590]
  ------------------
 8679|      0|		decl->flags |= XML_SCHEMAS_ELEM_BLOCK_SUBSTITUTION;
  ------------------
  |  |  730|      0|#define XML_SCHEMAS_ELEM_BLOCK_SUBSTITUTION        1 << 13
  ------------------
 8680|    590|	} else {
 8681|      4|	    attrValue = xmlSchemaGetNodeContent(ctxt, (xmlNodePtr) attr);
 8682|      4|	    if (xmlSchemaPValAttrBlockFinal(attrValue, &(decl->flags),
  ------------------
  |  Branch (8682:10): [True: 2, False: 2]
  ------------------
 8683|      4|		-1,
 8684|      4|		XML_SCHEMAS_ELEM_BLOCK_EXTENSION,
  ------------------
  |  |  718|      4|#define XML_SCHEMAS_ELEM_BLOCK_EXTENSION        1 << 11
  ------------------
 8685|      4|		XML_SCHEMAS_ELEM_BLOCK_RESTRICTION,
  ------------------
  |  |  724|      4|#define XML_SCHEMAS_ELEM_BLOCK_RESTRICTION        1 << 12
  ------------------
 8686|      4|		XML_SCHEMAS_ELEM_BLOCK_SUBSTITUTION, -1, -1) != 0) {
  ------------------
  |  |  730|      4|#define XML_SCHEMAS_ELEM_BLOCK_SUBSTITUTION        1 << 13
  ------------------
 8687|      2|		xmlSchemaPSimpleTypeErr(ctxt,
 8688|      2|		    XML_SCHEMAP_S4S_ATTR_INVALID_VALUE,
 8689|      2|		    NULL, (xmlNodePtr) attr,
 8690|      2|		    NULL, "(#all | List of (extension | "
 8691|      2|		    "restriction | substitution))", attrValue,
 8692|      2|		    NULL, NULL, NULL);
 8693|      2|	    }
 8694|      4|	}
 8695|    594|	if (xmlGetBooleanProp(ctxt, node, "nillable", 0))
  ------------------
  |  Branch (8695:6): [True: 12, False: 582]
  ------------------
 8696|     12|	    decl->flags |= XML_SCHEMAS_ELEM_NILLABLE;
  ------------------
  |  |  649|     12|#define XML_SCHEMAS_ELEM_NILLABLE        1 << 0
  ------------------
 8697|       |
 8698|    594|	attr = xmlSchemaGetPropNode(node, "type");
 8699|    594|	if (attr != NULL) {
  ------------------
  |  Branch (8699:6): [True: 262, False: 332]
  ------------------
 8700|    262|	    xmlSchemaPValAttrNodeQName(ctxt, schema,
 8701|    262|		NULL, attr,
 8702|    262|		&(decl->namedTypeNs), &(decl->namedType));
 8703|    262|	    xmlSchemaCheckReference(ctxt, schema, node,
 8704|    262|		attr, decl->namedTypeNs);
 8705|    262|	}
 8706|    594|	decl->value = xmlSchemaGetProp(ctxt, node, "default");
 8707|    594|	attr = xmlSchemaGetPropNode(node, "fixed");
 8708|    594|	if (attr != NULL) {
  ------------------
  |  Branch (8708:6): [True: 3, False: 591]
  ------------------
 8709|      3|	    fixed = xmlSchemaGetNodeContent(ctxt, (xmlNodePtr) attr);
 8710|      3|	    if (decl->value != NULL) {
  ------------------
  |  Branch (8710:10): [True: 3, False: 0]
  ------------------
 8711|       |		/*
 8712|       |		* 3.3.3 : 1
 8713|       |		* default and fixed must not both be present.
 8714|       |		*/
 8715|      3|		xmlSchemaPMutualExclAttrErr(ctxt,
 8716|      3|		    XML_SCHEMAP_SRC_ELEMENT_1,
 8717|      3|		    NULL, attr, "default", "fixed");
 8718|      3|	    } else {
 8719|      0|		decl->flags |= XML_SCHEMAS_ELEM_FIXED;
  ------------------
  |  |  667|      0|#define XML_SCHEMAS_ELEM_FIXED                1 << 3
  ------------------
 8720|      0|		decl->value = fixed;
 8721|      0|	    }
 8722|      3|	}
 8723|       |	/*
 8724|       |	* And now for the children...
 8725|       |	*/
 8726|    594|	if (IS_SCHEMA(child, "complexType")) {
  ------------------
  |  |  316|    594|   ((node != NULL) && (node->ns != NULL) && \
  |  |  ------------------
  |  |  |  Branch (316:5): [True: 239, False: 355]
  |  |  |  Branch (316:23): [True: 239, False: 0]
  |  |  ------------------
  |  |  317|    594|    (xmlStrEqual(node->name, (const xmlChar *) type)) && \
  |  |  ------------------
  |  |  |  Branch (317:5): [True: 200, False: 39]
  |  |  ------------------
  |  |  318|    594|    (xmlStrEqual(node->ns->href, xmlSchemaNs)))
  |  |  ------------------
  |  |  |  Branch (318:5): [True: 200, False: 0]
  |  |  ------------------
  ------------------
 8727|       |	    /*
 8728|       |	    * 3.3.3 : 3
 8729|       |	    * "type" and either <simpleType> or <complexType> are mutually
 8730|       |	    * exclusive
 8731|       |	    */
 8732|    200|	    if (decl->namedType != NULL) {
  ------------------
  |  Branch (8732:10): [True: 2, False: 198]
  ------------------
 8733|      2|		xmlSchemaPContentErr(ctxt,
 8734|      2|		    XML_SCHEMAP_SRC_ELEMENT_3,
 8735|      2|		    NULL, node, child,
 8736|      2|		    "The attribute 'type' and the <complexType> child are "
 8737|      2|		    "mutually exclusive", NULL);
 8738|      2|	    } else
 8739|    198|		WXS_ELEM_TYPEDEF(decl) = xmlSchemaParseComplexType(ctxt, schema, child, 0);
  ------------------
  |  |  148|    198|#define WXS_ELEM_TYPEDEF(e) (e)->subtypes
  ------------------
 8740|    200|	    child = child->next;
 8741|    394|	} else if (IS_SCHEMA(child, "simpleType")) {
  ------------------
  |  |  316|    394|   ((node != NULL) && (node->ns != NULL) && \
  |  |  ------------------
  |  |  |  Branch (316:5): [True: 39, False: 355]
  |  |  |  Branch (316:23): [True: 39, False: 0]
  |  |  ------------------
  |  |  317|    394|    (xmlStrEqual(node->name, (const xmlChar *) type)) && \
  |  |  ------------------
  |  |  |  Branch (317:5): [True: 32, False: 7]
  |  |  ------------------
  |  |  318|    394|    (xmlStrEqual(node->ns->href, xmlSchemaNs)))
  |  |  ------------------
  |  |  |  Branch (318:5): [True: 32, False: 0]
  |  |  ------------------
  ------------------
 8742|       |	    /*
 8743|       |	    * 3.3.3 : 3
 8744|       |	    * "type" and either <simpleType> or <complexType> are
 8745|       |	    * mutually exclusive
 8746|       |	    */
 8747|     32|	    if (decl->namedType != NULL) {
  ------------------
  |  Branch (8747:10): [True: 1, False: 31]
  ------------------
 8748|      1|		xmlSchemaPContentErr(ctxt,
 8749|      1|		    XML_SCHEMAP_SRC_ELEMENT_3,
 8750|      1|		    NULL, node, child,
 8751|      1|		    "The attribute 'type' and the <simpleType> child are "
 8752|      1|		    "mutually exclusive", NULL);
 8753|      1|	    } else
 8754|     31|		WXS_ELEM_TYPEDEF(decl) = xmlSchemaParseSimpleType(ctxt, schema, child, 0);
  ------------------
  |  |  148|     31|#define WXS_ELEM_TYPEDEF(e) (e)->subtypes
  ------------------
 8755|     32|	    child = child->next;
 8756|     32|	}
 8757|    609|	while ((IS_SCHEMA(child, "unique")) ||
  ------------------
  |  |  316|    609|   ((node != NULL) && (node->ns != NULL) && \
  |  |  ------------------
  |  |  |  Branch (316:5): [True: 16, False: 593]
  |  |  |  Branch (316:23): [True: 16, False: 0]
  |  |  ------------------
  |  |  317|    609|    (xmlStrEqual(node->name, (const xmlChar *) type)) && \
  |  |  ------------------
  |  |  |  Branch (317:5): [True: 5, False: 11]
  |  |  ------------------
  |  |  318|    609|    (xmlStrEqual(node->ns->href, xmlSchemaNs)))
  |  |  ------------------
  |  |  |  Branch (318:5): [True: 5, False: 0]
  |  |  ------------------
  ------------------
 8758|    609|	    (IS_SCHEMA(child, "key")) || (IS_SCHEMA(child, "keyref"))) {
  ------------------
  |  |  316|    604|   ((node != NULL) && (node->ns != NULL) && \
  |  |  ------------------
  |  |  |  Branch (316:5): [True: 11, False: 593]
  |  |  |  Branch (316:23): [True: 11, False: 0]
  |  |  ------------------
  |  |  317|    604|    (xmlStrEqual(node->name, (const xmlChar *) type)) && \
  |  |  ------------------
  |  |  |  Branch (317:5): [True: 6, False: 5]
  |  |  ------------------
  |  |  318|    604|    (xmlStrEqual(node->ns->href, xmlSchemaNs)))
  |  |  ------------------
  |  |  |  Branch (318:5): [True: 6, False: 0]
  |  |  ------------------
  ------------------
              	    (IS_SCHEMA(child, "key")) || (IS_SCHEMA(child, "keyref"))) {
  ------------------
  |  |  316|    598|   ((node != NULL) && (node->ns != NULL) && \
  |  |  ------------------
  |  |  |  Branch (316:5): [True: 5, False: 593]
  |  |  |  Branch (316:23): [True: 5, False: 0]
  |  |  ------------------
  |  |  317|    598|    (xmlStrEqual(node->name, (const xmlChar *) type)) && \
  |  |  ------------------
  |  |  |  Branch (317:5): [True: 4, False: 1]
  |  |  ------------------
  |  |  318|    598|    (xmlStrEqual(node->ns->href, xmlSchemaNs)))
  |  |  ------------------
  |  |  |  Branch (318:5): [True: 4, False: 0]
  |  |  ------------------
  ------------------
 8759|     15|	    if (IS_SCHEMA(child, "unique")) {
  ------------------
  |  |  316|     15|   ((node != NULL) && (node->ns != NULL) && \
  |  |  ------------------
  |  |  |  Branch (316:5): [True: 15, False: 0]
  |  |  |  Branch (316:23): [True: 15, False: 0]
  |  |  ------------------
  |  |  317|     15|    (xmlStrEqual(node->name, (const xmlChar *) type)) && \
  |  |  ------------------
  |  |  |  Branch (317:5): [True: 5, False: 10]
  |  |  ------------------
  |  |  318|     15|    (xmlStrEqual(node->ns->href, xmlSchemaNs)))
  |  |  ------------------
  |  |  |  Branch (318:5): [True: 5, False: 0]
  |  |  ------------------
  ------------------
 8760|      5|		curIDC = xmlSchemaParseIDC(ctxt, schema, child,
 8761|      5|		    XML_SCHEMA_TYPE_IDC_UNIQUE, decl->targetNamespace);
 8762|     10|	    } else if (IS_SCHEMA(child, "key")) {
  ------------------
  |  |  316|     10|   ((node != NULL) && (node->ns != NULL) && \
  |  |  ------------------
  |  |  |  Branch (316:5): [True: 10, False: 0]
  |  |  |  Branch (316:23): [True: 10, False: 0]
  |  |  ------------------
  |  |  317|     10|    (xmlStrEqual(node->name, (const xmlChar *) type)) && \
  |  |  ------------------
  |  |  |  Branch (317:5): [True: 6, False: 4]
  |  |  ------------------
  |  |  318|     10|    (xmlStrEqual(node->ns->href, xmlSchemaNs)))
  |  |  ------------------
  |  |  |  Branch (318:5): [True: 6, False: 0]
  |  |  ------------------
  ------------------
 8763|      6|		curIDC = xmlSchemaParseIDC(ctxt, schema, child,
 8764|      6|		    XML_SCHEMA_TYPE_IDC_KEY, decl->targetNamespace);
 8765|      6|	    } else if (IS_SCHEMA(child, "keyref")) {
  ------------------
  |  |  316|      4|   ((node != NULL) && (node->ns != NULL) && \
  |  |  ------------------
  |  |  |  Branch (316:5): [True: 4, False: 0]
  |  |  |  Branch (316:23): [True: 4, False: 0]
  |  |  ------------------
  |  |  317|      4|    (xmlStrEqual(node->name, (const xmlChar *) type)) && \
  |  |  ------------------
  |  |  |  Branch (317:5): [True: 4, False: 0]
  |  |  ------------------
  |  |  318|      4|    (xmlStrEqual(node->ns->href, xmlSchemaNs)))
  |  |  ------------------
  |  |  |  Branch (318:5): [True: 4, False: 0]
  |  |  ------------------
  ------------------
 8766|      4|		curIDC = xmlSchemaParseIDC(ctxt, schema, child,
 8767|      4|		    XML_SCHEMA_TYPE_IDC_KEYREF, decl->targetNamespace);
 8768|      4|	    }
 8769|     15|	    if (lastIDC != NULL)
  ------------------
  |  Branch (8769:10): [True: 3, False: 12]
  ------------------
 8770|      3|		lastIDC->next = curIDC;
 8771|     12|	    else
 8772|     12|		decl->idcs = (void *) curIDC;
 8773|     15|	    lastIDC = curIDC;
 8774|     15|	    child = child->next;
 8775|     15|	}
 8776|    594|	if (child != NULL) {
  ------------------
  |  Branch (8776:6): [True: 1, False: 593]
  ------------------
 8777|      1|	    xmlSchemaPContentErr(ctxt,
 8778|      1|		XML_SCHEMAP_S4S_ELEM_NOT_ALLOWED,
 8779|      1|		NULL, node, child,
 8780|      1|		NULL, "(annotation?, ((simpleType | complexType)?, "
 8781|      1|		"(unique | key | keyref)*))");
 8782|      1|	}
 8783|    594|	decl->annot = annot;
 8784|    594|    }
 8785|       |    /*
 8786|       |    * NOTE: Element Declaration Representation OK 4. will be checked at a
 8787|       |    * different layer.
 8788|       |    */
 8789|    594|    FREE_AND_NULL(des)
  ------------------
  |  |  320|    594|#define FREE_AND_NULL(str) if ((str) != NULL) { xmlFree((xmlChar *) (str)); str = NULL; }
  |  |  ------------------
  |  |  |  Branch (320:32): [True: 0, False: 594]
  |  |  ------------------
  ------------------
 8790|    594|    if (topLevel)
  ------------------
  |  Branch (8790:9): [True: 314, False: 280]
  ------------------
 8791|    314|	return ((xmlSchemaBasicItemPtr) decl);
 8792|    280|    else {
 8793|    280|	particle->children = (xmlSchemaTreeItemPtr) decl;
 8794|    280|	return ((xmlSchemaBasicItemPtr) particle);
 8795|    280|    }
 8796|       |
 8797|      0|return_null:
 8798|      0|    FREE_AND_NULL(des);
  ------------------
  |  |  320|      0|#define FREE_AND_NULL(str) if ((str) != NULL) { xmlFree((xmlChar *) (str)); str = NULL; }
  |  |  ------------------
  |  |  |  Branch (320:32): [True: 0, False: 0]
  |  |  ------------------
  ------------------
 8799|      0|    if (annot != NULL) {
  ------------------
  |  Branch (8799:9): [True: 0, False: 0]
  ------------------
 8800|      0|	if (particle != NULL)
  ------------------
  |  Branch (8800:6): [True: 0, False: 0]
  ------------------
 8801|      0|	    particle->annot = NULL;
 8802|      0|	if (decl != NULL)
  ------------------
  |  Branch (8802:6): [True: 0, False: 0]
  ------------------
 8803|      0|	    decl->annot = NULL;
 8804|      0|	xmlSchemaFreeAnnot(annot);
 8805|      0|    }
 8806|      0|    return (NULL);
 8807|    594|}
xmlschemas.c:xmlSchemaAddElement:
 5283|    594|{
 5284|    594|    xmlSchemaElementPtr ret = NULL;
 5285|       |
 5286|    594|    if ((ctxt == NULL) || (name == NULL))
  ------------------
  |  Branch (5286:9): [True: 0, False: 594]
  |  Branch (5286:27): [True: 0, False: 594]
  ------------------
 5287|      0|        return (NULL);
 5288|       |
 5289|    594|    ret = (xmlSchemaElementPtr) xmlMalloc(sizeof(xmlSchemaElement));
 5290|    594|    if (ret == NULL) {
  ------------------
  |  Branch (5290:9): [True: 0, False: 594]
  ------------------
 5291|      0|        xmlSchemaPErrMemory(ctxt, "allocating element", NULL);
 5292|      0|        return (NULL);
 5293|      0|    }
 5294|    594|    memset(ret, 0, sizeof(xmlSchemaElement));
 5295|    594|    ret->type = XML_SCHEMA_TYPE_ELEMENT;
 5296|    594|    ret->name = name;
 5297|    594|    ret->targetNamespace = nsName;
 5298|    594|    ret->node = node;
 5299|       |
 5300|    594|    if (topLevel)
  ------------------
  |  Branch (5300:9): [True: 314, False: 280]
  ------------------
 5301|    314|	WXS_ADD_GLOBAL(ctxt, ret);
  ------------------
  |  |  299|    314|    do { \
  |  |  300|    314|        if (xmlSchemaAddItemSize(&(WXS_BUCKET(ctx)->globals), 5, item) < 0) { \
  |  |  ------------------
  |  |  |  |  286|    314|#define WXS_BUCKET(ctx) WXS_CONSTRUCTOR((ctx))->bucket
  |  |  |  |  ------------------
  |  |  |  |  |  |  278|    314|#define WXS_CONSTRUCTOR(ctx) (ctx)->constructor
  |  |  |  |  ------------------
  |  |  ------------------
  |  |  |  Branch (300:13): [True: 0, False: 314]
  |  |  ------------------
  |  |  301|      0|            xmlFree(item); \
  |  |  302|      0|            item = NULL; \
  |  |  303|      0|        } \
  |  |  304|    314|    } while (0)
  |  |  ------------------
  |  |  |  Branch (304:14): [Folded - Ignored]
  |  |  ------------------
  ------------------
 5302|    280|    else
 5303|    280|	WXS_ADD_LOCAL(ctxt, ret);
  ------------------
  |  |  291|    280|    do { \
  |  |  292|    280|        if (xmlSchemaAddItemSize(&(WXS_BUCKET(ctx)->locals), 10, item) < 0) { \
  |  |  ------------------
  |  |  |  |  286|    280|#define WXS_BUCKET(ctx) WXS_CONSTRUCTOR((ctx))->bucket
  |  |  |  |  ------------------
  |  |  |  |  |  |  278|    280|#define WXS_CONSTRUCTOR(ctx) (ctx)->constructor
  |  |  |  |  ------------------
  |  |  ------------------
  |  |  |  Branch (292:13): [True: 0, False: 280]
  |  |  ------------------
  |  |  293|      0|            xmlFree(item); \
  |  |  294|      0|            item = NULL; \
  |  |  295|      0|        } \
  |  |  296|    280|    } while (0)
  |  |  ------------------
  |  |  |  Branch (296:14): [Folded - Ignored]
  |  |  ------------------
  ------------------
 5304|    594|    WXS_ADD_PENDING(ctxt, ret);
  ------------------
  |  |  307|    594|    xmlSchemaAddItemSize(&((ctx)->constructor->pending), 10, item)
  ------------------
 5305|    594|    return (ret);
 5306|    594|}
xmlschemas.c:xmlSchemaParseIDC:
 8279|     15|{
 8280|     15|    xmlSchemaIDCPtr item = NULL;
 8281|     15|    xmlNodePtr child = NULL;
 8282|     15|    xmlAttrPtr attr;
 8283|     15|    const xmlChar *name = NULL;
 8284|     15|    xmlSchemaIDCSelectPtr field = NULL, lastField = NULL;
 8285|       |
 8286|       |    /*
 8287|       |    * Check for illegal attributes.
 8288|       |    */
 8289|     15|    attr = node->properties;
 8290|     34|    while (attr != NULL) {
  ------------------
  |  Branch (8290:12): [True: 19, False: 15]
  ------------------
 8291|     19|	if (attr->ns == NULL) {
  ------------------
  |  Branch (8291:6): [True: 19, False: 0]
  ------------------
 8292|     19|	    if ((!xmlStrEqual(attr->name, BAD_CAST "id")) &&
  ------------------
  |  |   35|     19|#define BAD_CAST (xmlChar *)
  ------------------
  |  Branch (8292:10): [True: 19, False: 0]
  ------------------
 8293|     19|		(!xmlStrEqual(attr->name, BAD_CAST "name")) &&
  ------------------
  |  |   35|     19|#define BAD_CAST (xmlChar *)
  ------------------
  |  Branch (8293:3): [True: 4, False: 15]
  ------------------
 8294|     19|		((idcCategory != XML_SCHEMA_TYPE_IDC_KEYREF) ||
  ------------------
  |  Branch (8294:4): [True: 0, False: 4]
  ------------------
 8295|      4|		 (!xmlStrEqual(attr->name, BAD_CAST "refer")))) {
  ------------------
  |  |   35|      4|#define BAD_CAST (xmlChar *)
  ------------------
  |  Branch (8295:4): [True: 0, False: 4]
  ------------------
 8296|      0|		xmlSchemaPIllegalAttrErr(ctxt,
 8297|      0|		    XML_SCHEMAP_S4S_ATTR_NOT_ALLOWED, NULL, attr);
 8298|      0|	    }
 8299|     19|	} else if (xmlStrEqual(attr->ns->href, xmlSchemaNs)) {
  ------------------
  |  Branch (8299:13): [True: 0, False: 0]
  ------------------
 8300|      0|	    xmlSchemaPIllegalAttrErr(ctxt,
 8301|      0|		XML_SCHEMAP_S4S_ATTR_NOT_ALLOWED, NULL, attr);
 8302|      0|	}
 8303|     19|	attr = attr->next;
 8304|     19|    }
 8305|       |    /*
 8306|       |    * Attribute "name" (mandatory).
 8307|       |    */
 8308|     15|    attr = xmlSchemaGetPropNode(node, "name");
 8309|     15|    if (attr == NULL) {
  ------------------
  |  Branch (8309:9): [True: 0, False: 15]
  ------------------
 8310|      0|	xmlSchemaPMissingAttrErr(ctxt,
 8311|      0|	    XML_SCHEMAP_S4S_ATTR_MISSING,
 8312|      0|	    NULL, node,
 8313|      0|	    "name", NULL);
 8314|      0|	return (NULL);
 8315|     15|    } else if (xmlSchemaPValAttrNode(ctxt,
  ------------------
  |  Branch (8315:16): [True: 0, False: 15]
  ------------------
 8316|     15|	NULL, attr,
 8317|     15|	xmlSchemaGetBuiltInType(XML_SCHEMAS_NCNAME), &name) != 0) {
 8318|      0|	return (NULL);
 8319|      0|    }
 8320|       |    /* Create the component. */
 8321|     15|    item = xmlSchemaAddIDC(ctxt, schema, name, targetNamespace,
 8322|     15|	idcCategory, node);
 8323|     15|    if (item == NULL)
  ------------------
  |  Branch (8323:9): [True: 0, False: 15]
  ------------------
 8324|      0|	return(NULL);
 8325|       |
 8326|     15|    xmlSchemaPValAttrID(ctxt, node, BAD_CAST "id");
  ------------------
  |  |   35|     15|#define BAD_CAST (xmlChar *)
  ------------------
 8327|     15|    if (idcCategory == XML_SCHEMA_TYPE_IDC_KEYREF) {
  ------------------
  |  Branch (8327:9): [True: 4, False: 11]
  ------------------
 8328|       |	/*
 8329|       |	* Attribute "refer" (mandatory).
 8330|       |	*/
 8331|      4|	attr = xmlSchemaGetPropNode(node, "refer");
 8332|      4|	if (attr == NULL) {
  ------------------
  |  Branch (8332:6): [True: 0, False: 4]
  ------------------
 8333|      0|	    xmlSchemaPMissingAttrErr(ctxt,
 8334|      0|		XML_SCHEMAP_S4S_ATTR_MISSING,
 8335|      0|		NULL, node,
 8336|      0|		"refer", NULL);
 8337|      4|	} else {
 8338|       |	    /*
 8339|       |	    * Create a reference item.
 8340|       |	    */
 8341|      4|	    item->ref = xmlSchemaNewQNameRef(ctxt, XML_SCHEMA_TYPE_IDC_KEY,
 8342|      4|		NULL, NULL);
 8343|      4|	    if (item->ref == NULL)
  ------------------
  |  Branch (8343:10): [True: 0, False: 4]
  ------------------
 8344|      0|		return (NULL);
 8345|      4|	    xmlSchemaPValAttrNodeQName(ctxt, schema,
 8346|      4|		NULL, attr,
 8347|      4|		&(item->ref->targetNamespace),
 8348|      4|		&(item->ref->name));
 8349|      4|	    xmlSchemaCheckReference(ctxt, schema, node, attr,
 8350|      4|		item->ref->targetNamespace);
 8351|      4|	}
 8352|      4|    }
 8353|       |    /*
 8354|       |    * And now for the children...
 8355|       |    */
 8356|     15|    child = node->children;
 8357|     15|    if (IS_SCHEMA(child, "annotation")) {
  ------------------
  |  |  316|     15|   ((node != NULL) && (node->ns != NULL) && \
  |  |  ------------------
  |  |  |  Branch (316:5): [True: 15, False: 0]
  |  |  |  Branch (316:23): [True: 15, False: 0]
  |  |  ------------------
  |  |  317|     15|    (xmlStrEqual(node->name, (const xmlChar *) type)) && \
  |  |  ------------------
  |  |  |  Branch (317:5): [True: 0, False: 15]
  |  |  ------------------
  |  |  318|     15|    (xmlStrEqual(node->ns->href, xmlSchemaNs)))
  |  |  ------------------
  |  |  |  Branch (318:5): [True: 0, False: 0]
  |  |  ------------------
  ------------------
 8358|      0|	item->annot = xmlSchemaParseAnnotation(ctxt, child, 1);
 8359|      0|	child = child->next;
 8360|      0|    }
 8361|     15|    if (child == NULL) {
  ------------------
  |  Branch (8361:9): [True: 0, False: 15]
  ------------------
 8362|      0|	xmlSchemaPContentErr(ctxt,
 8363|      0|		XML_SCHEMAP_S4S_ELEM_MISSING,
 8364|      0|		NULL, node, child,
 8365|      0|		"A child element is missing",
 8366|      0|		"(annotation?, (selector, field+))");
 8367|      0|    }
 8368|       |    /*
 8369|       |    * Child element <selector>.
 8370|       |    */
 8371|     15|    if (IS_SCHEMA(child, "selector")) {
  ------------------
  |  |  316|     15|   ((node != NULL) && (node->ns != NULL) && \
  |  |  ------------------
  |  |  |  Branch (316:5): [True: 15, False: 0]
  |  |  |  Branch (316:23): [True: 15, False: 0]
  |  |  ------------------
  |  |  317|     15|    (xmlStrEqual(node->name, (const xmlChar *) type)) && \
  |  |  ------------------
  |  |  |  Branch (317:5): [True: 15, False: 0]
  |  |  ------------------
  |  |  318|     15|    (xmlStrEqual(node->ns->href, xmlSchemaNs)))
  |  |  ------------------
  |  |  |  Branch (318:5): [True: 15, False: 0]
  |  |  ------------------
  ------------------
 8372|     15|	item->selector = xmlSchemaParseIDCSelectorAndField(ctxt,
 8373|     15|	    item, child, 0);
 8374|     15|	child = child->next;
 8375|       |	/*
 8376|       |	* Child elements <field>.
 8377|       |	*/
 8378|     15|	if (IS_SCHEMA(child, "field")) {
  ------------------
  |  |  316|     15|   ((node != NULL) && (node->ns != NULL) && \
  |  |  ------------------
  |  |  |  Branch (316:5): [True: 15, False: 0]
  |  |  |  Branch (316:23): [True: 15, False: 0]
  |  |  ------------------
  |  |  317|     15|    (xmlStrEqual(node->name, (const xmlChar *) type)) && \
  |  |  ------------------
  |  |  |  Branch (317:5): [True: 15, False: 0]
  |  |  ------------------
  |  |  318|     15|    (xmlStrEqual(node->ns->href, xmlSchemaNs)))
  |  |  ------------------
  |  |  |  Branch (318:5): [True: 15, False: 0]
  |  |  ------------------
  ------------------
 8379|     15|	    do {
 8380|     15|		field = xmlSchemaParseIDCSelectorAndField(ctxt,
 8381|     15|		    item, child, 1);
 8382|     15|		if (field != NULL) {
  ------------------
  |  Branch (8382:7): [True: 15, False: 0]
  ------------------
 8383|     15|		    field->index = item->nbFields;
 8384|     15|		    item->nbFields++;
 8385|     15|		    if (lastField != NULL)
  ------------------
  |  Branch (8385:11): [True: 0, False: 15]
  ------------------
 8386|      0|			lastField->next = field;
 8387|     15|		    else
 8388|     15|			item->fields = field;
 8389|     15|		    lastField = field;
 8390|     15|		}
 8391|     15|		child = child->next;
 8392|     15|	    } while (IS_SCHEMA(child, "field"));
  ------------------
  |  |  316|     15|   ((node != NULL) && (node->ns != NULL) && \
  |  |  ------------------
  |  |  |  Branch (316:5): [True: 0, False: 15]
  |  |  |  Branch (316:23): [True: 0, False: 0]
  |  |  ------------------
  |  |  317|     15|    (xmlStrEqual(node->name, (const xmlChar *) type)) && \
  |  |  ------------------
  |  |  |  Branch (317:5): [True: 0, False: 0]
  |  |  ------------------
  |  |  318|     15|    (xmlStrEqual(node->ns->href, xmlSchemaNs)))
  |  |  ------------------
  |  |  |  Branch (318:5): [True: 0, False: 0]
  |  |  ------------------
  ------------------
 8393|     15|	} else {
 8394|      0|	    xmlSchemaPContentErr(ctxt,
 8395|      0|		XML_SCHEMAP_S4S_ELEM_NOT_ALLOWED,
 8396|      0|		NULL, node, child,
 8397|      0|		NULL, "(annotation?, (selector, field+))");
 8398|      0|	}
 8399|     15|    }
 8400|     15|    if (child != NULL) {
  ------------------
  |  Branch (8400:9): [True: 0, False: 15]
  ------------------
 8401|      0|	xmlSchemaPContentErr(ctxt,
 8402|      0|	    XML_SCHEMAP_S4S_ELEM_NOT_ALLOWED,
 8403|      0|	    NULL, node, child,
 8404|      0|	    NULL, "(annotation?, (selector, field+))");
 8405|      0|    }
 8406|       |
 8407|     15|    return (item);
 8408|     15|}
xmlschemas.c:xmlSchemaAddIDC:
 5568|     15|{
 5569|     15|    xmlSchemaIDCPtr ret = NULL;
 5570|       |
 5571|     15|    if ((ctxt == NULL) || (schema == NULL) || (name == NULL))
  ------------------
  |  Branch (5571:9): [True: 0, False: 15]
  |  Branch (5571:27): [True: 0, False: 15]
  |  Branch (5571:47): [True: 0, False: 15]
  ------------------
 5572|      0|        return (NULL);
 5573|       |
 5574|     15|    ret = (xmlSchemaIDCPtr) xmlMalloc(sizeof(xmlSchemaIDC));
 5575|     15|    if (ret == NULL) {
  ------------------
  |  Branch (5575:9): [True: 0, False: 15]
  ------------------
 5576|      0|        xmlSchemaPErrMemory(ctxt,
 5577|      0|	    "allocating an identity-constraint definition", NULL);
 5578|      0|        return (NULL);
 5579|      0|    }
 5580|     15|    memset(ret, 0, sizeof(xmlSchemaIDC));
 5581|       |    /* The target namespace of the parent element declaration. */
 5582|     15|    ret->targetNamespace = nsName;
 5583|     15|    ret->name = name;
 5584|     15|    ret->type = category;
 5585|     15|    ret->node = node;
 5586|       |
 5587|     15|    WXS_ADD_GLOBAL(ctxt, ret);
  ------------------
  |  |  299|     15|    do { \
  |  |  300|     15|        if (xmlSchemaAddItemSize(&(WXS_BUCKET(ctx)->globals), 5, item) < 0) { \
  |  |  ------------------
  |  |  |  |  286|     15|#define WXS_BUCKET(ctx) WXS_CONSTRUCTOR((ctx))->bucket
  |  |  |  |  ------------------
  |  |  |  |  |  |  278|     15|#define WXS_CONSTRUCTOR(ctx) (ctx)->constructor
  |  |  |  |  ------------------
  |  |  ------------------
  |  |  |  Branch (300:13): [True: 0, False: 15]
  |  |  ------------------
  |  |  301|      0|            xmlFree(item); \
  |  |  302|      0|            item = NULL; \
  |  |  303|      0|        } \
  |  |  304|     15|    } while (0)
  |  |  ------------------
  |  |  |  Branch (304:14): [Folded - Ignored]
  |  |  ------------------
  ------------------
 5588|       |    /*
 5589|       |    * Only keyrefs need to be fixup up.
 5590|       |    */
 5591|     15|    if (category == XML_SCHEMA_TYPE_IDC_KEYREF)
  ------------------
  |  Branch (5591:9): [True: 4, False: 11]
  ------------------
 5592|      4|	WXS_ADD_PENDING(ctxt, ret);
  ------------------
  |  |  307|      4|    xmlSchemaAddItemSize(&((ctx)->constructor->pending), 10, item)
  ------------------
 5593|     15|    return (ret);
 5594|     15|}
xmlschemas.c:xmlSchemaParseIDCSelectorAndField:
 8181|     30|{
 8182|     30|    xmlSchemaIDCSelectPtr item;
 8183|     30|    xmlNodePtr child = NULL;
 8184|     30|    xmlAttrPtr attr;
 8185|       |
 8186|       |    /*
 8187|       |    * Check for illegal attributes.
 8188|       |    */
 8189|     30|    attr = node->properties;
 8190|     60|    while (attr != NULL) {
  ------------------
  |  Branch (8190:12): [True: 30, False: 30]
  ------------------
 8191|     30|	if (attr->ns == NULL) {
  ------------------
  |  Branch (8191:6): [True: 30, False: 0]
  ------------------
 8192|     30|	    if ((!xmlStrEqual(attr->name, BAD_CAST "id")) &&
  ------------------
  |  |   35|     30|#define BAD_CAST (xmlChar *)
  ------------------
  |  Branch (8192:10): [True: 30, False: 0]
  ------------------
 8193|     30|		(!xmlStrEqual(attr->name, BAD_CAST "xpath"))) {
  ------------------
  |  |   35|     30|#define BAD_CAST (xmlChar *)
  ------------------
  |  Branch (8193:3): [True: 0, False: 30]
  ------------------
 8194|      0|		xmlSchemaPIllegalAttrErr(ctxt,
 8195|      0|		    XML_SCHEMAP_S4S_ATTR_NOT_ALLOWED, NULL, attr);
 8196|      0|	    }
 8197|     30|	} else if (xmlStrEqual(attr->ns->href, xmlSchemaNs)) {
  ------------------
  |  Branch (8197:13): [True: 0, False: 0]
  ------------------
 8198|      0|	    xmlSchemaPIllegalAttrErr(ctxt,
 8199|      0|		XML_SCHEMAP_S4S_ATTR_NOT_ALLOWED, NULL, attr);
 8200|      0|	}
 8201|     30|	attr = attr->next;
 8202|     30|    }
 8203|       |    /*
 8204|       |    * Create the item.
 8205|       |    */
 8206|     30|    item = (xmlSchemaIDCSelectPtr) xmlMalloc(sizeof(xmlSchemaIDCSelect));
 8207|     30|    if (item == NULL) {
  ------------------
  |  Branch (8207:9): [True: 0, False: 30]
  ------------------
 8208|      0|        xmlSchemaPErrMemory(ctxt,
 8209|      0|	    "allocating a 'selector' of an identity-constraint definition",
 8210|      0|	    NULL);
 8211|      0|        return (NULL);
 8212|      0|    }
 8213|     30|    memset(item, 0, sizeof(xmlSchemaIDCSelect));
 8214|       |    /*
 8215|       |    * Attribute "xpath" (mandatory).
 8216|       |    */
 8217|     30|    attr = xmlSchemaGetPropNode(node, "xpath");
 8218|     30|    if (attr == NULL) {
  ------------------
  |  Branch (8218:9): [True: 0, False: 30]
  ------------------
 8219|      0|	xmlSchemaPMissingAttrErr(ctxt,
 8220|      0|	    XML_SCHEMAP_S4S_ATTR_MISSING,
 8221|      0|	    NULL, node,
 8222|      0|	    "name", NULL);
 8223|     30|    } else {
 8224|     30|	item->xpath = xmlSchemaGetNodeContent(ctxt, (xmlNodePtr) attr);
 8225|       |	/*
 8226|       |	* URGENT TODO: "field"s have an other syntax than "selector"s.
 8227|       |	*/
 8228|       |
 8229|     30|	if (xmlSchemaCheckCSelectorXPath(ctxt, idc, item, attr,
  ------------------
  |  Branch (8229:6): [True: 0, False: 30]
  ------------------
 8230|     30|	    isField) == -1) {
 8231|      0|	    xmlSchemaPErr(ctxt,
 8232|      0|		(xmlNodePtr) attr,
 8233|      0|		XML_SCHEMAP_INTERNAL,
 8234|      0|		"Internal error: xmlSchemaParseIDCSelectorAndField, "
 8235|      0|		"validating the XPath expression of a IDC selector.\n",
 8236|      0|		NULL, NULL);
 8237|      0|	}
 8238|       |
 8239|     30|    }
 8240|     30|    xmlSchemaPValAttrID(ctxt, node, BAD_CAST "id");
  ------------------
  |  |   35|     30|#define BAD_CAST (xmlChar *)
  ------------------
 8241|       |    /*
 8242|       |    * And now for the children...
 8243|       |    */
 8244|     30|    child = node->children;
 8245|     30|    if (IS_SCHEMA(child, "annotation")) {
  ------------------
  |  |  316|     30|   ((node != NULL) && (node->ns != NULL) && \
  |  |  ------------------
  |  |  |  Branch (316:5): [True: 0, False: 30]
  |  |  |  Branch (316:23): [True: 0, False: 0]
  |  |  ------------------
  |  |  317|     30|    (xmlStrEqual(node->name, (const xmlChar *) type)) && \
  |  |  ------------------
  |  |  |  Branch (317:5): [True: 0, False: 0]
  |  |  ------------------
  |  |  318|     30|    (xmlStrEqual(node->ns->href, xmlSchemaNs)))
  |  |  ------------------
  |  |  |  Branch (318:5): [True: 0, False: 0]
  |  |  ------------------
  ------------------
 8246|       |	/*
 8247|       |	* Add the annotation to the parent IDC.
 8248|       |	*/
 8249|      0|	xmlSchemaAddAnnotation((xmlSchemaAnnotItemPtr) idc,
 8250|      0|	    xmlSchemaParseAnnotation(ctxt, child, 1));
 8251|      0|	child = child->next;
 8252|      0|    }
 8253|     30|    if (child != NULL) {
  ------------------
  |  Branch (8253:9): [True: 0, False: 30]
  ------------------
 8254|      0|	xmlSchemaPContentErr(ctxt,
 8255|      0|	    XML_SCHEMAP_S4S_ELEM_NOT_ALLOWED,
 8256|      0|	    NULL, node, child,
 8257|      0|	    NULL, "(annotation?)");
 8258|      0|    }
 8259|       |
 8260|     30|    return (item);
 8261|     30|}
xmlschemas.c:xmlSchemaCheckCSelectorXPath:
 7965|     30|{
 7966|     30|    xmlNodePtr node;
 7967|       |
 7968|       |    /*
 7969|       |    * c-selector-xpath:
 7970|       |    * Schema Component Constraint: Selector Value OK
 7971|       |    *
 7972|       |    * TODO: 1 The {selector} must be a valid XPath expression, as defined
 7973|       |    * in [XPath].
 7974|       |    */
 7975|     30|    if (selector == NULL) {
  ------------------
  |  Branch (7975:9): [True: 0, False: 30]
  ------------------
 7976|      0|	xmlSchemaPErr(ctxt, idc->node,
 7977|      0|	    XML_SCHEMAP_INTERNAL,
 7978|      0|	    "Internal error: xmlSchemaCheckCSelectorXPath, "
 7979|      0|	    "the selector is not specified.\n", NULL, NULL);
 7980|      0|	return (-1);
 7981|      0|    }
 7982|     30|    if (attr == NULL)
  ------------------
  |  Branch (7982:9): [True: 0, False: 30]
  ------------------
 7983|      0|	node = idc->node;
 7984|     30|    else
 7985|     30|	node = (xmlNodePtr) attr;
 7986|     30|    if (selector->xpath == NULL) {
  ------------------
  |  Branch (7986:9): [True: 0, False: 30]
  ------------------
 7987|      0|	xmlSchemaPCustomErr(ctxt,
 7988|       |	    /* TODO: Adjust error code. */
 7989|      0|	    XML_SCHEMAP_S4S_ATTR_INVALID_VALUE,
 7990|      0|	    NULL, node,
 7991|      0|	    "The XPath expression of the selector is not valid", NULL);
 7992|      0|	return (XML_SCHEMAP_S4S_ATTR_INVALID_VALUE);
 7993|     30|    } else {
 7994|     30|	const xmlChar **nsArray = NULL;
 7995|     30|	xmlNsPtr *nsList = NULL;
 7996|       |	/*
 7997|       |	* Compile the XPath expression.
 7998|       |	*/
 7999|       |	/*
 8000|       |	* TODO: We need the array of in-scope namespaces for compilation.
 8001|       |	* TODO: Call xmlPatterncompile with different options for selector/
 8002|       |	* field.
 8003|       |	*/
 8004|     30|	if (attr == NULL)
  ------------------
  |  Branch (8004:6): [True: 0, False: 30]
  ------------------
 8005|      0|	    nsList = NULL;
 8006|     30|	else
 8007|     30|	    nsList = xmlGetNsList(attr->doc, attr->parent);
 8008|       |	/*
 8009|       |	* Build an array of prefixes and namespaces.
 8010|       |	*/
 8011|     30|	if (nsList != NULL) {
  ------------------
  |  Branch (8011:6): [True: 30, False: 0]
  ------------------
 8012|     30|	    int i, count = 0;
 8013|       |
 8014|     80|	    for (i = 0; nsList[i] != NULL; i++)
  ------------------
  |  Branch (8014:18): [True: 50, False: 30]
  ------------------
 8015|     50|		count++;
 8016|       |
 8017|     30|	    nsArray = (const xmlChar **) xmlMalloc(
 8018|     30|		(count * 2 + 1) * sizeof(const xmlChar *));
 8019|     30|	    if (nsArray == NULL) {
  ------------------
  |  Branch (8019:10): [True: 0, False: 30]
  ------------------
 8020|      0|		xmlSchemaPErrMemory(ctxt, "allocating a namespace array",
 8021|      0|		    NULL);
 8022|      0|		xmlFree(nsList);
 8023|      0|		return (-1);
 8024|      0|	    }
 8025|     80|	    for (i = 0; i < count; i++) {
  ------------------
  |  Branch (8025:18): [True: 50, False: 30]
  ------------------
 8026|     50|		nsArray[2 * i] = nsList[i]->href;
 8027|     50|		nsArray[2 * i + 1] = nsList[i]->prefix;
 8028|     50|	    }
 8029|     30|	    nsArray[count * 2] = NULL;
 8030|     30|	    xmlFree(nsList);
 8031|     30|	}
 8032|       |	/*
 8033|       |	* TODO: Differentiate between "selector" and "field".
 8034|       |	*/
 8035|     30|	if (isField)
  ------------------
  |  Branch (8035:6): [True: 15, False: 15]
  ------------------
 8036|     15|	    selector->xpathComp = (void *) xmlPatterncompile(selector->xpath,
 8037|     15|		NULL, XML_PATTERN_XSFIELD, nsArray);
 8038|     15|	else
 8039|     15|	    selector->xpathComp = (void *) xmlPatterncompile(selector->xpath,
 8040|     15|		NULL, XML_PATTERN_XSSEL, nsArray);
 8041|     30|	if (nsArray != NULL)
  ------------------
  |  Branch (8041:6): [True: 30, False: 0]
  ------------------
 8042|     30|	    xmlFree((xmlChar **) nsArray);
 8043|       |
 8044|     30|	if (selector->xpathComp == NULL) {
  ------------------
  |  Branch (8044:6): [True: 0, False: 30]
  ------------------
 8045|      0|	    xmlSchemaPCustomErr(ctxt,
 8046|       |		/* TODO: Adjust error code? */
 8047|      0|		XML_SCHEMAP_S4S_ATTR_INVALID_VALUE,
 8048|      0|		NULL, node,
 8049|      0|		"The XPath expression '%s' could not be "
 8050|      0|		"compiled", selector->xpath);
 8051|      0|	    return (XML_SCHEMAP_S4S_ATTR_INVALID_VALUE);
 8052|      0|	}
 8053|     30|    }
 8054|     30|    return (0);
 8055|     30|}
xmlschemas.c:xmlSchemaParseGlobalAttribute:
 7465|     36|{
 7466|     36|    const xmlChar *attrValue;
 7467|     36|    xmlSchemaAttributePtr ret;
 7468|     36|    xmlNodePtr child = NULL;
 7469|     36|    xmlAttrPtr attr;
 7470|       |
 7471|       |    /*
 7472|       |     * Note that the w3c spec assumes the schema to be validated with schema
 7473|       |     * for schemas beforehand.
 7474|       |     *
 7475|       |     * 3.2.3 Constraints on XML Representations of Attribute Declarations
 7476|       |     */
 7477|     36|    if ((pctxt == NULL) || (schema == NULL) || (node == NULL))
  ------------------
  |  Branch (7477:9): [True: 0, False: 36]
  |  Branch (7477:28): [True: 0, False: 36]
  |  Branch (7477:48): [True: 0, False: 36]
  ------------------
 7478|      0|        return (NULL);
 7479|       |    /*
 7480|       |    * 3.2.3 : 3.1
 7481|       |    * One of ref or name must be present, but not both
 7482|       |    */
 7483|     36|    attr = xmlSchemaGetPropNode(node, "name");
 7484|     36|    if (attr == NULL) {
  ------------------
  |  Branch (7484:9): [True: 0, False: 36]
  ------------------
 7485|      0|	xmlSchemaPMissingAttrErr(pctxt, XML_SCHEMAP_S4S_ATTR_MISSING,
 7486|      0|	    NULL, node, "name", NULL);
 7487|      0|	return (NULL);
 7488|      0|    }
 7489|     36|    if (xmlSchemaPValAttrNode(pctxt, NULL, attr,
  ------------------
  |  Branch (7489:9): [True: 0, False: 36]
  ------------------
 7490|     36|	xmlSchemaGetBuiltInType(XML_SCHEMAS_NCNAME), &attrValue) != 0) {
 7491|      0|	return (NULL);
 7492|      0|    }
 7493|       |    /*
 7494|       |    * 3.2.6 Schema Component Constraint: xmlns Not Allowed
 7495|       |    * TODO: Move this to the component layer.
 7496|       |    */
 7497|     36|    if (xmlStrEqual(attrValue, BAD_CAST "xmlns")) {
  ------------------
  |  |   35|     36|#define BAD_CAST (xmlChar *)
  ------------------
  |  Branch (7497:9): [True: 0, False: 36]
  ------------------
 7498|      0|	xmlSchemaPSimpleTypeErr(pctxt,
 7499|      0|	    XML_SCHEMAP_NO_XMLNS,
 7500|      0|	    NULL, (xmlNodePtr) attr,
 7501|      0|	    xmlSchemaGetBuiltInType(XML_SCHEMAS_NCNAME), NULL, NULL,
 7502|      0|	    "The value of the attribute must not match 'xmlns'",
 7503|      0|	    NULL, NULL);
 7504|      0|	return (NULL);
 7505|      0|    }
 7506|       |    /*
 7507|       |    * 3.2.6 Schema Component Constraint: xsi: Not Allowed
 7508|       |    * TODO: Move this to the component layer.
 7509|       |    *       Or better leave it here and add it to the component layer
 7510|       |    *       if we have a schema construction API.
 7511|       |    */
 7512|     36|    if (xmlStrEqual(pctxt->targetNamespace, xmlSchemaInstanceNs)) {
  ------------------
  |  Branch (7512:9): [True: 0, False: 36]
  ------------------
 7513|      0|	xmlSchemaCustomErr(ACTXT_CAST pctxt,
  ------------------
  |  |  121|      0|#define ACTXT_CAST (xmlSchemaAbstractCtxtPtr)
  ------------------
 7514|      0|	    XML_SCHEMAP_NO_XSI, node, NULL,
 7515|      0|	    "The target namespace must not match '%s'",
 7516|      0|	    xmlSchemaInstanceNs, NULL);
 7517|      0|    }
 7518|       |
 7519|     36|    ret = xmlSchemaAddAttribute(pctxt, schema, attrValue,
 7520|     36|	pctxt->targetNamespace, node, 1);
 7521|     36|    if (ret == NULL)
  ------------------
  |  Branch (7521:9): [True: 0, False: 36]
  ------------------
 7522|      0|	return (NULL);
 7523|     36|    ret->flags |= XML_SCHEMAS_ATTR_GLOBAL;
  ------------------
  |  |  220|     36|#define XML_SCHEMAS_ATTR_GLOBAL        1 << 0
  ------------------
 7524|       |
 7525|       |    /*
 7526|       |    * Check for illegal attributes.
 7527|       |    */
 7528|     36|    attr = node->properties;
 7529|    109|    while (attr != NULL) {
  ------------------
  |  Branch (7529:12): [True: 73, False: 36]
  ------------------
 7530|     73|	if (attr->ns == NULL) {
  ------------------
  |  Branch (7530:6): [True: 73, False: 0]
  ------------------
 7531|     73|	    if ((!xmlStrEqual(attr->name, BAD_CAST "id")) &&
  ------------------
  |  |   35|     73|#define BAD_CAST (xmlChar *)
  ------------------
  |  Branch (7531:10): [True: 73, False: 0]
  ------------------
 7532|     73|		(!xmlStrEqual(attr->name, BAD_CAST "default")) &&
  ------------------
  |  |   35|     73|#define BAD_CAST (xmlChar *)
  ------------------
  |  Branch (7532:3): [True: 71, False: 2]
  ------------------
 7533|     73|		(!xmlStrEqual(attr->name, BAD_CAST "fixed")) &&
  ------------------
  |  |   35|     71|#define BAD_CAST (xmlChar *)
  ------------------
  |  Branch (7533:3): [True: 70, False: 1]
  ------------------
 7534|     73|		(!xmlStrEqual(attr->name, BAD_CAST "name")) &&
  ------------------
  |  |   35|     70|#define BAD_CAST (xmlChar *)
  ------------------
  |  Branch (7534:3): [True: 34, False: 36]
  ------------------
 7535|     73|		(!xmlStrEqual(attr->name, BAD_CAST "type")))
  ------------------
  |  |   35|     34|#define BAD_CAST (xmlChar *)
  ------------------
  |  Branch (7535:3): [True: 0, False: 34]
  ------------------
 7536|      0|	    {
 7537|      0|		xmlSchemaPIllegalAttrErr(pctxt,
 7538|      0|		    XML_SCHEMAP_S4S_ATTR_NOT_ALLOWED, NULL, attr);
 7539|      0|	    }
 7540|     73|	} else if (xmlStrEqual(attr->ns->href, xmlSchemaNs)) {
  ------------------
  |  Branch (7540:13): [True: 0, False: 0]
  ------------------
 7541|      0|	    xmlSchemaPIllegalAttrErr(pctxt,
 7542|      0|		XML_SCHEMAP_S4S_ATTR_NOT_ALLOWED, NULL, attr);
 7543|      0|	}
 7544|     73|	attr = attr->next;
 7545|     73|    }
 7546|     36|    xmlSchemaPValAttrQName(pctxt, schema, NULL,
 7547|     36|	node, "type", &ret->typeNs, &ret->typeName);
 7548|       |
 7549|     36|    xmlSchemaPValAttrID(pctxt, node, BAD_CAST "id");
  ------------------
  |  |   35|     36|#define BAD_CAST (xmlChar *)
  ------------------
 7550|       |    /*
 7551|       |    * Attribute "fixed".
 7552|       |    */
 7553|     36|    ret->defValue = xmlSchemaGetProp(pctxt, node, "fixed");
 7554|     36|    if (ret->defValue != NULL)
  ------------------
  |  Branch (7554:9): [True: 1, False: 35]
  ------------------
 7555|      1|	ret->flags |= XML_SCHEMAS_ATTR_FIXED;
  ------------------
  |  |  239|      1|#define XML_SCHEMAS_ATTR_FIXED        1 << 9
  ------------------
 7556|       |    /*
 7557|       |    * Attribute "default".
 7558|       |    */
 7559|     36|    attr = xmlSchemaGetPropNode(node, "default");
 7560|     36|    if (attr != NULL) {
  ------------------
  |  Branch (7560:9): [True: 2, False: 34]
  ------------------
 7561|       |	/*
 7562|       |	* 3.2.3 : 1
 7563|       |	* default and fixed must not both be present.
 7564|       |	*/
 7565|      2|	if (ret->flags & XML_SCHEMAS_ATTR_FIXED) {
  ------------------
  |  |  239|      2|#define XML_SCHEMAS_ATTR_FIXED        1 << 9
  ------------------
  |  Branch (7565:6): [True: 0, False: 2]
  ------------------
 7566|      0|	    xmlSchemaPMutualExclAttrErr(pctxt, XML_SCHEMAP_SRC_ATTRIBUTE_1,
 7567|      0|		WXS_BASIC_CAST ret, attr, "default", "fixed");
  ------------------
  |  |  124|      0|#define WXS_BASIC_CAST (xmlSchemaBasicItemPtr)
  ------------------
 7568|      0|	} else
 7569|      2|	    ret->defValue = xmlSchemaGetNodeContent(pctxt, (xmlNodePtr) attr);
 7570|      2|    }
 7571|       |    /*
 7572|       |    * And now for the children...
 7573|       |    */
 7574|     36|    child = node->children;
 7575|     36|    if (IS_SCHEMA(child, "annotation")) {
  ------------------
  |  |  316|     36|   ((node != NULL) && (node->ns != NULL) && \
  |  |  ------------------
  |  |  |  Branch (316:5): [True: 7, False: 29]
  |  |  |  Branch (316:23): [True: 7, False: 0]
  |  |  ------------------
  |  |  317|     36|    (xmlStrEqual(node->name, (const xmlChar *) type)) && \
  |  |  ------------------
  |  |  |  Branch (317:5): [True: 4, False: 3]
  |  |  ------------------
  |  |  318|     36|    (xmlStrEqual(node->ns->href, xmlSchemaNs)))
  |  |  ------------------
  |  |  |  Branch (318:5): [True: 4, False: 0]
  |  |  ------------------
  ------------------
 7576|      4|        ret->annot = xmlSchemaParseAnnotation(pctxt, child, 1);
 7577|      4|        child = child->next;
 7578|      4|    }
 7579|     36|    if (IS_SCHEMA(child, "simpleType")) {
  ------------------
  |  |  316|     36|   ((node != NULL) && (node->ns != NULL) && \
  |  |  ------------------
  |  |  |  Branch (316:5): [True: 3, False: 33]
  |  |  |  Branch (316:23): [True: 3, False: 0]
  |  |  ------------------
  |  |  317|     36|    (xmlStrEqual(node->name, (const xmlChar *) type)) && \
  |  |  ------------------
  |  |  |  Branch (317:5): [True: 3, False: 0]
  |  |  ------------------
  |  |  318|     36|    (xmlStrEqual(node->ns->href, xmlSchemaNs)))
  |  |  ------------------
  |  |  |  Branch (318:5): [True: 3, False: 0]
  |  |  ------------------
  ------------------
 7580|      3|	if (ret->typeName != NULL) {
  ------------------
  |  Branch (7580:6): [True: 1, False: 2]
  ------------------
 7581|       |	    /*
 7582|       |	    * 3.2.3 : 4
 7583|       |	    * type and <simpleType> must not both be present.
 7584|       |	    */
 7585|      1|	    xmlSchemaPContentErr(pctxt, XML_SCHEMAP_SRC_ATTRIBUTE_4,
 7586|      1|		NULL, node, child,
 7587|      1|		"The attribute 'type' and the <simpleType> child "
 7588|      1|		"are mutually exclusive", NULL);
 7589|      1|	} else
 7590|      2|	    ret->subtypes = xmlSchemaParseSimpleType(pctxt, schema, child, 0);
 7591|      3|	child = child->next;
 7592|      3|    }
 7593|     36|    if (child != NULL)
  ------------------
  |  Branch (7593:9): [True: 0, False: 36]
  ------------------
 7594|      0|	xmlSchemaPContentErr(pctxt, XML_SCHEMAP_S4S_ELEM_NOT_ALLOWED,
 7595|      0|	    NULL, node, child, NULL,
 7596|      0|	    "(annotation?, simpleType?)");
 7597|       |
 7598|     36|    return (ret);
 7599|     36|}
xmlschemas.c:xmlSchemaParseAttributeGroupDefinition:
 7749|     40|{
 7750|     40|    const xmlChar *name;
 7751|     40|    xmlSchemaAttributeGroupPtr ret;
 7752|     40|    xmlNodePtr child = NULL;
 7753|     40|    xmlAttrPtr attr;
 7754|     40|    int hasRefs = 0;
 7755|       |
 7756|     40|    if ((pctxt == NULL) || (schema == NULL) || (node == NULL))
  ------------------
  |  Branch (7756:9): [True: 0, False: 40]
  |  Branch (7756:28): [True: 0, False: 40]
  |  Branch (7756:48): [True: 0, False: 40]
  ------------------
 7757|      0|        return (NULL);
 7758|       |
 7759|     40|    attr = xmlSchemaGetPropNode(node, "name");
 7760|     40|    if (attr == NULL) {
  ------------------
  |  Branch (7760:9): [True: 0, False: 40]
  ------------------
 7761|      0|	xmlSchemaPMissingAttrErr(pctxt,
 7762|      0|	    XML_SCHEMAP_S4S_ATTR_MISSING,
 7763|      0|	    NULL, node, "name", NULL);
 7764|      0|	return (NULL);
 7765|      0|    }
 7766|       |    /*
 7767|       |    * The name is crucial, exit if invalid.
 7768|       |    */
 7769|     40|    if (xmlSchemaPValAttrNode(pctxt,
  ------------------
  |  Branch (7769:9): [True: 0, False: 40]
  ------------------
 7770|     40|	NULL, attr,
 7771|     40|	xmlSchemaGetBuiltInType(XML_SCHEMAS_NCNAME), &name) != 0) {
 7772|      0|	return (NULL);
 7773|      0|    }
 7774|     40|    ret = xmlSchemaAddAttributeGroupDefinition(pctxt, schema,
 7775|     40|	name, pctxt->targetNamespace, node);
 7776|     40|    if (ret == NULL)
  ------------------
  |  Branch (7776:9): [True: 0, False: 40]
  ------------------
 7777|      0|	return (NULL);
 7778|       |    /*
 7779|       |    * Check for illegal attributes.
 7780|       |    */
 7781|     40|    attr = node->properties;
 7782|     80|    while (attr != NULL) {
  ------------------
  |  Branch (7782:12): [True: 40, False: 40]
  ------------------
 7783|     40|	if (attr->ns == NULL) {
  ------------------
  |  Branch (7783:6): [True: 40, False: 0]
  ------------------
 7784|     40|	    if ((!xmlStrEqual(attr->name, BAD_CAST "name")) &&
  ------------------
  |  |   35|     40|#define BAD_CAST (xmlChar *)
  ------------------
  |  Branch (7784:10): [True: 0, False: 40]
  ------------------
 7785|     40|		(!xmlStrEqual(attr->name, BAD_CAST "id")))
  ------------------
  |  |   35|      0|#define BAD_CAST (xmlChar *)
  ------------------
  |  Branch (7785:3): [True: 0, False: 0]
  ------------------
 7786|      0|	    {
 7787|      0|		xmlSchemaPIllegalAttrErr(pctxt,
 7788|      0|		    XML_SCHEMAP_S4S_ATTR_NOT_ALLOWED, NULL, attr);
 7789|      0|	    }
 7790|     40|	} else if (xmlStrEqual(attr->ns->href, xmlSchemaNs)) {
  ------------------
  |  Branch (7790:13): [True: 0, False: 0]
  ------------------
 7791|      0|	    xmlSchemaPIllegalAttrErr(pctxt,
 7792|      0|		XML_SCHEMAP_S4S_ATTR_NOT_ALLOWED, NULL, attr);
 7793|      0|	}
 7794|     40|	attr = attr->next;
 7795|     40|    }
 7796|       |    /* Attribute ID */
 7797|     40|    xmlSchemaPValAttrID(pctxt, node, BAD_CAST "id");
  ------------------
  |  |   35|     40|#define BAD_CAST (xmlChar *)
  ------------------
 7798|       |    /*
 7799|       |    * And now for the children...
 7800|       |    */
 7801|     40|    child = node->children;
 7802|     40|    if (IS_SCHEMA(child, "annotation")) {
  ------------------
  |  |  316|     40|   ((node != NULL) && (node->ns != NULL) && \
  |  |  ------------------
  |  |  |  Branch (316:5): [True: 40, False: 0]
  |  |  |  Branch (316:23): [True: 40, False: 0]
  |  |  ------------------
  |  |  317|     40|    (xmlStrEqual(node->name, (const xmlChar *) type)) && \
  |  |  ------------------
  |  |  |  Branch (317:5): [True: 0, False: 40]
  |  |  ------------------
  |  |  318|     40|    (xmlStrEqual(node->ns->href, xmlSchemaNs)))
  |  |  ------------------
  |  |  |  Branch (318:5): [True: 0, False: 0]
  |  |  ------------------
  ------------------
 7803|      0|        ret->annot = xmlSchemaParseAnnotation(pctxt, child, 1);
 7804|      0|        child = child->next;
 7805|      0|    }
 7806|       |    /*
 7807|       |    * Parse contained attribute decls/refs.
 7808|       |    */
 7809|     40|    if (xmlSchemaParseLocalAttributes(pctxt, schema, &child,
  ------------------
  |  Branch (7809:9): [True: 0, False: 40]
  ------------------
 7810|     40|	(xmlSchemaItemListPtr *) &(ret->attrUses),
 7811|     40|	XML_SCHEMA_TYPE_ATTRIBUTEGROUP, &hasRefs) == -1)
 7812|      0|	return(NULL);
 7813|     40|    if (hasRefs)
  ------------------
  |  Branch (7813:9): [True: 1, False: 39]
  ------------------
 7814|      1|	ret->flags |= XML_SCHEMAS_ATTRGROUP_HAS_REFS;
  ------------------
  |  |  351|      1|#define XML_SCHEMAS_ATTRGROUP_HAS_REFS 1 << 4
  ------------------
 7815|       |    /*
 7816|       |    * Parse the attribute wildcard.
 7817|       |    */
 7818|     40|    if (IS_SCHEMA(child, "anyAttribute")) {
  ------------------
  |  |  316|     40|   ((node != NULL) && (node->ns != NULL) && \
  |  |  ------------------
  |  |  |  Branch (316:5): [True: 27, False: 13]
  |  |  |  Branch (316:23): [True: 27, False: 0]
  |  |  ------------------
  |  |  317|     40|    (xmlStrEqual(node->name, (const xmlChar *) type)) && \
  |  |  ------------------
  |  |  |  Branch (317:5): [True: 27, False: 0]
  |  |  ------------------
  |  |  318|     40|    (xmlStrEqual(node->ns->href, xmlSchemaNs)))
  |  |  ------------------
  |  |  |  Branch (318:5): [True: 27, False: 0]
  |  |  ------------------
  ------------------
 7819|     27|	ret->attributeWildcard = xmlSchemaParseAnyAttribute(pctxt,
 7820|     27|	    schema, child);
 7821|     27|	child = child->next;
 7822|     27|    }
 7823|     40|    if (child != NULL) {
  ------------------
  |  Branch (7823:9): [True: 0, False: 40]
  ------------------
 7824|      0|	xmlSchemaPContentErr(pctxt,
 7825|      0|	    XML_SCHEMAP_S4S_ELEM_NOT_ALLOWED,
 7826|      0|	    NULL, node, child, NULL,
 7827|      0|	    "(annotation?, ((attribute | attributeGroup)*, anyAttribute?))");
 7828|      0|    }
 7829|     40|    return (ret);
 7830|     40|}
xmlschemas.c:xmlSchemaAddAttributeGroupDefinition:
 5233|     40|{
 5234|     40|    xmlSchemaAttributeGroupPtr ret = NULL;
 5235|       |
 5236|     40|    if ((pctxt == NULL) || (name == NULL))
  ------------------
  |  Branch (5236:9): [True: 0, False: 40]
  |  Branch (5236:28): [True: 0, False: 40]
  ------------------
 5237|      0|        return (NULL);
 5238|       |
 5239|     40|    ret = (xmlSchemaAttributeGroupPtr)
 5240|     40|        xmlMalloc(sizeof(xmlSchemaAttributeGroup));
 5241|     40|    if (ret == NULL) {
  ------------------
  |  Branch (5241:9): [True: 0, False: 40]
  ------------------
 5242|      0|	xmlSchemaPErrMemory(pctxt, "allocating attribute group", NULL);
 5243|      0|	return (NULL);
 5244|      0|    }
 5245|     40|    memset(ret, 0, sizeof(xmlSchemaAttributeGroup));
 5246|     40|    ret->type = XML_SCHEMA_TYPE_ATTRIBUTEGROUP;
 5247|     40|    ret->name = name;
 5248|     40|    ret->targetNamespace = nsName;
 5249|     40|    ret->node = node;
 5250|       |
 5251|       |    /* TODO: Remove the flag. */
 5252|     40|    ret->flags |= XML_SCHEMAS_ATTRGROUP_GLOBAL;
  ------------------
  |  |  332|     40|#define XML_SCHEMAS_ATTRGROUP_GLOBAL 1 << 1
  ------------------
 5253|     40|    if (pctxt->isRedefine) {
  ------------------
  |  Branch (5253:9): [True: 0, False: 40]
  ------------------
 5254|      0|	pctxt->redef = xmlSchemaAddRedef(pctxt, pctxt->redefined,
 5255|      0|	    ret, name, nsName);
 5256|      0|	if (pctxt->redef == NULL) {
  ------------------
  |  Branch (5256:6): [True: 0, False: 0]
  ------------------
 5257|      0|	    xmlFree(ret);
 5258|      0|	    return(NULL);
 5259|      0|	}
 5260|      0|	pctxt->redefCounter = 0;
 5261|      0|    }
 5262|     40|    WXS_ADD_GLOBAL(pctxt, ret);
  ------------------
  |  |  299|     40|    do { \
  |  |  300|     40|        if (xmlSchemaAddItemSize(&(WXS_BUCKET(ctx)->globals), 5, item) < 0) { \
  |  |  ------------------
  |  |  |  |  286|     40|#define WXS_BUCKET(ctx) WXS_CONSTRUCTOR((ctx))->bucket
  |  |  |  |  ------------------
  |  |  |  |  |  |  278|     40|#define WXS_CONSTRUCTOR(ctx) (ctx)->constructor
  |  |  |  |  ------------------
  |  |  ------------------
  |  |  |  Branch (300:13): [True: 0, False: 40]
  |  |  ------------------
  |  |  301|      0|            xmlFree(item); \
  |  |  302|      0|            item = NULL; \
  |  |  303|      0|        } \
  |  |  304|     40|    } while (0)
  |  |  ------------------
  |  |  |  Branch (304:14): [Folded - Ignored]
  |  |  ------------------
  ------------------
 5263|     40|    WXS_ADD_PENDING(pctxt, ret);
  ------------------
  |  |  307|     40|    xmlSchemaAddItemSize(&((ctx)->constructor->pending), 10, item)
  ------------------
 5264|     40|    return (ret);
 5265|     40|}
xmlschemas.c:xmlSchemaParseModelGroupDefinition:
 9429|      9|{
 9430|      9|    xmlSchemaModelGroupDefPtr item;
 9431|      9|    xmlNodePtr child = NULL;
 9432|      9|    xmlAttrPtr attr;
 9433|      9|    const xmlChar *name;
 9434|       |
 9435|      9|    if ((ctxt == NULL) || (schema == NULL) || (node == NULL))
  ------------------
  |  Branch (9435:9): [True: 0, False: 9]
  |  Branch (9435:27): [True: 0, False: 9]
  |  Branch (9435:47): [True: 0, False: 9]
  ------------------
 9436|      0|        return (NULL);
 9437|       |
 9438|      9|    attr = xmlSchemaGetPropNode(node, "name");
 9439|      9|    if (attr == NULL) {
  ------------------
  |  Branch (9439:9): [True: 0, False: 9]
  ------------------
 9440|      0|	xmlSchemaPMissingAttrErr(ctxt,
 9441|      0|	    XML_SCHEMAP_S4S_ATTR_MISSING,
 9442|      0|	    NULL, node,
 9443|      0|	    "name", NULL);
 9444|      0|	return (NULL);
 9445|      9|    } else if (xmlSchemaPValAttrNode(ctxt, NULL, attr,
  ------------------
  |  Branch (9445:16): [True: 0, False: 9]
  ------------------
 9446|      9|	xmlSchemaGetBuiltInType(XML_SCHEMAS_NCNAME), &name) != 0) {
 9447|      0|	return (NULL);
 9448|      0|    }
 9449|      9|    item = xmlSchemaAddModelGroupDefinition(ctxt, schema, name,
 9450|      9|	ctxt->targetNamespace, node);
 9451|      9|    if (item == NULL)
  ------------------
  |  Branch (9451:9): [True: 0, False: 9]
  ------------------
 9452|      0|	return (NULL);
 9453|       |    /*
 9454|       |    * Check for illegal attributes.
 9455|       |    */
 9456|      9|    attr = node->properties;
 9457|     18|    while (attr != NULL) {
  ------------------
  |  Branch (9457:12): [True: 9, False: 9]
  ------------------
 9458|      9|	if (attr->ns == NULL) {
  ------------------
  |  Branch (9458:6): [True: 9, False: 0]
  ------------------
 9459|      9|	    if ((!xmlStrEqual(attr->name, BAD_CAST "name")) &&
  ------------------
  |  |   35|      9|#define BAD_CAST (xmlChar *)
  ------------------
  |  Branch (9459:10): [True: 0, False: 9]
  ------------------
 9460|      9|		(!xmlStrEqual(attr->name, BAD_CAST "id"))) {
  ------------------
  |  |   35|      0|#define BAD_CAST (xmlChar *)
  ------------------
  |  Branch (9460:3): [True: 0, False: 0]
  ------------------
 9461|      0|		xmlSchemaPIllegalAttrErr(ctxt,
 9462|      0|		    XML_SCHEMAP_S4S_ATTR_NOT_ALLOWED, NULL, attr);
 9463|      0|	    }
 9464|      9|	} else if (xmlStrEqual(attr->ns->href, xmlSchemaNs)) {
  ------------------
  |  Branch (9464:13): [True: 0, False: 0]
  ------------------
 9465|      0|	    xmlSchemaPIllegalAttrErr(ctxt,
 9466|      0|		XML_SCHEMAP_S4S_ATTR_NOT_ALLOWED, NULL, attr);
 9467|      0|	}
 9468|      9|	attr = attr->next;
 9469|      9|    }
 9470|      9|    xmlSchemaPValAttrID(ctxt, node, BAD_CAST "id");
  ------------------
  |  |   35|      9|#define BAD_CAST (xmlChar *)
  ------------------
 9471|       |    /*
 9472|       |    * And now for the children...
 9473|       |    */
 9474|      9|    child = node->children;
 9475|      9|    if (IS_SCHEMA(child, "annotation")) {
  ------------------
  |  |  316|      9|   ((node != NULL) && (node->ns != NULL) && \
  |  |  ------------------
  |  |  |  Branch (316:5): [True: 9, False: 0]
  |  |  |  Branch (316:23): [True: 9, False: 0]
  |  |  ------------------
  |  |  317|      9|    (xmlStrEqual(node->name, (const xmlChar *) type)) && \
  |  |  ------------------
  |  |  |  Branch (317:5): [True: 2, False: 7]
  |  |  ------------------
  |  |  318|      9|    (xmlStrEqual(node->ns->href, xmlSchemaNs)))
  |  |  ------------------
  |  |  |  Branch (318:5): [True: 2, False: 0]
  |  |  ------------------
  ------------------
 9476|      2|	item->annot = xmlSchemaParseAnnotation(ctxt, child, 1);
 9477|      2|	child = child->next;
 9478|      2|    }
 9479|      9|    if (IS_SCHEMA(child, "all")) {
  ------------------
  |  |  316|      9|   ((node != NULL) && (node->ns != NULL) && \
  |  |  ------------------
  |  |  |  Branch (316:5): [True: 9, False: 0]
  |  |  |  Branch (316:23): [True: 9, False: 0]
  |  |  ------------------
  |  |  317|      9|    (xmlStrEqual(node->name, (const xmlChar *) type)) && \
  |  |  ------------------
  |  |  |  Branch (317:5): [True: 0, False: 9]
  |  |  ------------------
  |  |  318|      9|    (xmlStrEqual(node->ns->href, xmlSchemaNs)))
  |  |  ------------------
  |  |  |  Branch (318:5): [True: 0, False: 0]
  |  |  ------------------
  ------------------
 9480|      0|	item->children = xmlSchemaParseModelGroup(ctxt, schema, child,
 9481|      0|	    XML_SCHEMA_TYPE_ALL, 0);
 9482|      0|	child = child->next;
 9483|      9|    } else if (IS_SCHEMA(child, "choice")) {
  ------------------
  |  |  316|      9|   ((node != NULL) && (node->ns != NULL) && \
  |  |  ------------------
  |  |  |  Branch (316:5): [True: 9, False: 0]
  |  |  |  Branch (316:23): [True: 9, False: 0]
  |  |  ------------------
  |  |  317|      9|    (xmlStrEqual(node->name, (const xmlChar *) type)) && \
  |  |  ------------------
  |  |  |  Branch (317:5): [True: 1, False: 8]
  |  |  ------------------
  |  |  318|      9|    (xmlStrEqual(node->ns->href, xmlSchemaNs)))
  |  |  ------------------
  |  |  |  Branch (318:5): [True: 1, False: 0]
  |  |  ------------------
  ------------------
 9484|      1|	item->children = xmlSchemaParseModelGroup(ctxt, schema, child,
 9485|      1|	    XML_SCHEMA_TYPE_CHOICE, 0);
 9486|      1|	child = child->next;
 9487|      8|    } else if (IS_SCHEMA(child, "sequence")) {
  ------------------
  |  |  316|      8|   ((node != NULL) && (node->ns != NULL) && \
  |  |  ------------------
  |  |  |  Branch (316:5): [True: 8, False: 0]
  |  |  |  Branch (316:23): [True: 8, False: 0]
  |  |  ------------------
  |  |  317|      8|    (xmlStrEqual(node->name, (const xmlChar *) type)) && \
  |  |  ------------------
  |  |  |  Branch (317:5): [True: 8, False: 0]
  |  |  ------------------
  |  |  318|      8|    (xmlStrEqual(node->ns->href, xmlSchemaNs)))
  |  |  ------------------
  |  |  |  Branch (318:5): [True: 8, False: 0]
  |  |  ------------------
  ------------------
 9488|      8|	item->children = xmlSchemaParseModelGroup(ctxt, schema, child,
 9489|      8|	    XML_SCHEMA_TYPE_SEQUENCE, 0);
 9490|      8|	child = child->next;
 9491|      8|    }
 9492|       |
 9493|       |
 9494|       |
 9495|      9|    if (child != NULL) {
  ------------------
  |  Branch (9495:9): [True: 0, False: 9]
  ------------------
 9496|      0|	xmlSchemaPContentErr(ctxt,
 9497|      0|	    XML_SCHEMAP_S4S_ELEM_NOT_ALLOWED,
 9498|      0|	    NULL, node, child, NULL,
 9499|      0|	    "(annotation?, (all | choice | sequence)?)");
 9500|      0|    }
 9501|      9|    return (item);
 9502|      9|}
xmlschemas.c:xmlSchemaAddModelGroupDefinition:
 5508|      9|{
 5509|      9|    xmlSchemaModelGroupDefPtr ret = NULL;
 5510|       |
 5511|      9|    if ((ctxt == NULL) || (schema == NULL) || (name == NULL))
  ------------------
  |  Branch (5511:9): [True: 0, False: 9]
  |  Branch (5511:27): [True: 0, False: 9]
  |  Branch (5511:47): [True: 0, False: 9]
  ------------------
 5512|      0|        return (NULL);
 5513|       |
 5514|      9|    ret = (xmlSchemaModelGroupDefPtr)
 5515|      9|	xmlMalloc(sizeof(xmlSchemaModelGroupDef));
 5516|      9|    if (ret == NULL) {
  ------------------
  |  Branch (5516:9): [True: 0, False: 9]
  ------------------
 5517|      0|        xmlSchemaPErrMemory(ctxt, "adding group", NULL);
 5518|      0|        return (NULL);
 5519|      0|    }
 5520|      9|    memset(ret, 0, sizeof(xmlSchemaModelGroupDef));
 5521|      9|    ret->name = name;
 5522|      9|    ret->type = XML_SCHEMA_TYPE_GROUP;
 5523|      9|    ret->node = node;
 5524|      9|    ret->targetNamespace = nsName;
 5525|       |
 5526|      9|    if (ctxt->isRedefine) {
  ------------------
  |  Branch (5526:9): [True: 0, False: 9]
  ------------------
 5527|      0|	ctxt->redef = xmlSchemaAddRedef(ctxt, ctxt->redefined,
 5528|      0|	    ret, name, nsName);
 5529|      0|	if (ctxt->redef == NULL) {
  ------------------
  |  Branch (5529:6): [True: 0, False: 0]
  ------------------
 5530|      0|	    xmlFree(ret);
 5531|      0|	    return(NULL);
 5532|      0|	}
 5533|      0|	ctxt->redefCounter = 0;
 5534|      0|    }
 5535|      9|    WXS_ADD_GLOBAL(ctxt, ret);
  ------------------
  |  |  299|      9|    do { \
  |  |  300|      9|        if (xmlSchemaAddItemSize(&(WXS_BUCKET(ctx)->globals), 5, item) < 0) { \
  |  |  ------------------
  |  |  |  |  286|      9|#define WXS_BUCKET(ctx) WXS_CONSTRUCTOR((ctx))->bucket
  |  |  |  |  ------------------
  |  |  |  |  |  |  278|      9|#define WXS_CONSTRUCTOR(ctx) (ctx)->constructor
  |  |  |  |  ------------------
  |  |  ------------------
  |  |  |  Branch (300:13): [True: 0, False: 9]
  |  |  ------------------
  |  |  301|      0|            xmlFree(item); \
  |  |  302|      0|            item = NULL; \
  |  |  303|      0|        } \
  |  |  304|      9|    } while (0)
  |  |  ------------------
  |  |  |  Branch (304:14): [Folded - Ignored]
  |  |  ------------------
  ------------------
 5536|      9|    WXS_ADD_PENDING(ctxt, ret);
  ------------------
  |  |  307|      9|    xmlSchemaAddItemSize(&((ctx)->constructor->pending), 10, item)
  ------------------
 5537|      9|    return (ret);
 5538|      9|}
xmlschemas.c:xmlSchemaPContentErr:
 3266|     12|{
 3267|     12|    xmlChar *des = NULL;
 3268|       |
 3269|     12|    xmlSchemaFormatItemForReport(&des, NULL, ownerItem, ownerElem);
 3270|     12|    if (message != NULL)
  ------------------
  |  Branch (3270:9): [True: 4, False: 8]
  ------------------
 3271|      4|	xmlSchemaPErr2(ctxt, ownerElem, child, error,
 3272|      4|	    "%s: %s.\n",
 3273|      4|	    BAD_CAST des, BAD_CAST message);
  ------------------
  |  |   35|      4|#define BAD_CAST (xmlChar *)
  ------------------
              	    BAD_CAST des, BAD_CAST message);
  ------------------
  |  |   35|      4|#define BAD_CAST (xmlChar *)
  ------------------
 3274|      8|    else {
 3275|      8|	if (content != NULL) {
  ------------------
  |  Branch (3275:6): [True: 8, False: 0]
  ------------------
 3276|      8|	    xmlSchemaPErr2(ctxt, ownerElem, child, error,
 3277|      8|		"%s: The content is not valid. Expected is %s.\n",
 3278|      8|		BAD_CAST des, BAD_CAST content);
  ------------------
  |  |   35|      8|#define BAD_CAST (xmlChar *)
  ------------------
              		BAD_CAST des, BAD_CAST content);
  ------------------
  |  |   35|      8|#define BAD_CAST (xmlChar *)
  ------------------
 3279|      8|	} else {
 3280|      0|	    xmlSchemaPErr2(ctxt, ownerElem, child, error,
 3281|      0|		"%s: The content is not valid.\n",
 3282|      0|		BAD_CAST des, NULL);
  ------------------
  |  |   35|      0|#define BAD_CAST (xmlChar *)
  ------------------
 3283|      0|	}
 3284|      8|    }
 3285|     12|    FREE_AND_NULL(des)
  ------------------
  |  |  320|     12|#define FREE_AND_NULL(str) if ((str) != NULL) { xmlFree((xmlChar *) (str)); str = NULL; }
  |  |  ------------------
  |  |  |  Branch (320:32): [True: 12, False: 0]
  |  |  ------------------
  ------------------
 3286|     12|}
xmlschemas.c:xmlSchemaFixupComponents:
20765|    138|{
20766|    138|    xmlSchemaConstructionCtxtPtr con = pctxt->constructor;
20767|    138|    xmlSchemaTreeItemPtr item, *items;
20768|    138|    int nbItems, i, ret = 0;
20769|    138|    xmlSchemaBucketPtr oldbucket = con->bucket;
20770|    138|    xmlSchemaElementPtr elemDecl;
20771|       |
20772|    138|#define FIXHFAILURE if (pctxt->err == XML_SCHEMAP_INTERNAL) goto exit_failure;
20773|       |
20774|    138|    if ((con->pending == NULL) ||
  ------------------
  |  Branch (20774:9): [True: 0, False: 138]
  ------------------
20775|    138|	(con->pending->nbItems == 0))
  ------------------
  |  Branch (20775:2): [True: 5, False: 133]
  ------------------
20776|      5|	return(0);
20777|       |
20778|       |    /*
20779|       |    * Since xmlSchemaFixupComplexType() will create new particles
20780|       |    * (local components), and those particle components need a bucket
20781|       |    * on the constructor, we'll assure here that the constructor has
20782|       |    * a bucket.
20783|       |    * TODO: Think about storing locals _only_ on the main bucket.
20784|       |    */
20785|    133|    if (con->bucket == NULL)
  ------------------
  |  Branch (20785:9): [True: 133, False: 0]
  ------------------
20786|    133|	con->bucket = rootBucket;
20787|       |
20788|       |    /* TODO:
20789|       |    * SPEC (src-redefine):
20790|       |    * (6.2) "If it has no such self-reference, then all of the
20791|       |    * following must be true:"
20792|       |
20793|       |    * (6.2.2) The {model group} of the model group definition which
20794|       |    * corresponds to it per XML Representation of Model Group
20795|       |    * Definition Schema Components ($3.7.2) must be a `valid
20796|       |    * restriction` of the {model group} of that model group definition
20797|       |    * in I, as defined in Particle Valid (Restriction) ($3.9.6)."
20798|       |    */
20799|    133|    xmlSchemaCheckSRCRedefineFirst(pctxt);
20800|       |
20801|       |    /*
20802|       |    * Add global components to the schemata's hash tables.
20803|       |    */
20804|    133|    xmlSchemaAddComponents(pctxt, rootBucket);
20805|       |
20806|    133|    pctxt->ctxtType = NULL;
20807|    133|    items = (xmlSchemaTreeItemPtr *) con->pending->items;
20808|    133|    nbItems = con->pending->nbItems;
20809|       |    /*
20810|       |    * Now that we have parsed *all* the schema document(s) and converted
20811|       |    * them to schema components, we can resolve references, apply component
20812|       |    * constraints, create the FSA from the content model, etc.
20813|       |    */
20814|       |    /*
20815|       |    * Resolve references of..
20816|       |    *
20817|       |    * 1. element declarations:
20818|       |    *   - the type definition
20819|       |    *   - the substitution group affiliation
20820|       |    * 2. simple/complex types:
20821|       |    *   - the base type definition
20822|       |    *   - the memberTypes of union types
20823|       |    *   - the itemType of list types
20824|       |    * 3. attributes declarations and attribute uses:
20825|       |    *   - the type definition
20826|       |    *   - if an attribute use, then the attribute declaration
20827|       |    * 4. attribute group references:
20828|       |    *   - the attribute group definition
20829|       |    * 5. particles:
20830|       |    *   - the term of the particle (e.g. a model group)
20831|       |    * 6. IDC key-references:
20832|       |    *   - the referenced IDC 'key' or 'unique' definition
20833|       |    * 7. Attribute prohibitions which had a "ref" attribute.
20834|       |    */
20835|  2.07k|    for (i = 0; i < nbItems; i++) {
  ------------------
  |  Branch (20835:17): [True: 1.93k, False: 133]
  ------------------
20836|  1.93k|	item = items[i];
20837|  1.93k|	switch (item->type) {
20838|    570|	    case XML_SCHEMA_TYPE_ELEMENT:
  ------------------
  |  Branch (20838:6): [True: 570, False: 1.36k]
  ------------------
20839|    570|		xmlSchemaResolveElementReferences(
20840|    570|		    (xmlSchemaElementPtr) item, pctxt);
20841|    570|		FIXHFAILURE;
  ------------------
  |  |20772|    570|#define FIXHFAILURE if (pctxt->err == XML_SCHEMAP_INTERNAL) goto exit_failure;
  |  |  ------------------
  |  |  |  Branch (20772:25): [True: 0, False: 570]
  |  |  ------------------
  ------------------
20842|    570|		break;
20843|    365|	    case XML_SCHEMA_TYPE_COMPLEX:
  ------------------
  |  Branch (20843:6): [True: 365, False: 1.57k]
  ------------------
20844|    525|	    case XML_SCHEMA_TYPE_SIMPLE:
  ------------------
  |  Branch (20844:6): [True: 160, False: 1.77k]
  ------------------
20845|    525|		xmlSchemaResolveTypeReferences(
20846|    525|		    (xmlSchemaTypePtr) item, pctxt);
20847|    525|		FIXHFAILURE;
  ------------------
  |  |20772|    525|#define FIXHFAILURE if (pctxt->err == XML_SCHEMAP_INTERNAL) goto exit_failure;
  |  |  ------------------
  |  |  |  Branch (20772:25): [True: 0, False: 525]
  |  |  ------------------
  ------------------
20848|    525|		break;
20849|    189|	    case XML_SCHEMA_TYPE_ATTRIBUTE:
  ------------------
  |  Branch (20849:6): [True: 189, False: 1.74k]
  ------------------
20850|    189|		xmlSchemaResolveAttrTypeReferences(
20851|    189|		    (xmlSchemaAttributePtr) item, pctxt);
20852|    189|		FIXHFAILURE;
  ------------------
  |  |20772|    189|#define FIXHFAILURE if (pctxt->err == XML_SCHEMAP_INTERNAL) goto exit_failure;
  |  |  ------------------
  |  |  |  Branch (20772:25): [True: 0, False: 189]
  |  |  ------------------
  ------------------
20853|    189|		break;
20854|     44|	    case XML_SCHEMA_TYPE_ATTRIBUTE_USE:
  ------------------
  |  Branch (20854:6): [True: 44, False: 1.89k]
  ------------------
20855|     44|		xmlSchemaResolveAttrUseReferences(
20856|     44|		    (xmlSchemaAttributeUsePtr) item, pctxt);
20857|     44|		FIXHFAILURE;
  ------------------
  |  |20772|     44|#define FIXHFAILURE if (pctxt->err == XML_SCHEMAP_INTERNAL) goto exit_failure;
  |  |  ------------------
  |  |  |  Branch (20772:25): [True: 0, False: 44]
  |  |  ------------------
  ------------------
20858|     44|		break;
20859|     51|	    case XML_SCHEMA_EXTRA_QNAMEREF:
  ------------------
  |  Branch (20859:6): [True: 51, False: 1.88k]
  ------------------
20860|     51|		if ((WXS_QNAME_CAST item)->itemType ==
  ------------------
  |  |  136|     51|#define WXS_QNAME_CAST (xmlSchemaQNameRefPtr)
  ------------------
  |  Branch (20860:7): [True: 51, False: 0]
  ------------------
20861|     51|		    XML_SCHEMA_TYPE_ATTRIBUTEGROUP)
20862|     51|		{
20863|     51|		    xmlSchemaResolveAttrGroupReferences(
20864|     51|			WXS_QNAME_CAST item, pctxt);
  ------------------
  |  |  136|     51|#define WXS_QNAME_CAST (xmlSchemaQNameRefPtr)
  ------------------
20865|     51|		}
20866|     51|		FIXHFAILURE;
  ------------------
  |  |20772|     51|#define FIXHFAILURE if (pctxt->err == XML_SCHEMAP_INTERNAL) goto exit_failure;
  |  |  ------------------
  |  |  |  Branch (20772:25): [True: 0, False: 51]
  |  |  ------------------
  ------------------
20867|     51|		break;
20868|    247|	    case XML_SCHEMA_TYPE_SEQUENCE:
  ------------------
  |  Branch (20868:6): [True: 247, False: 1.69k]
  ------------------
20869|    302|	    case XML_SCHEMA_TYPE_CHOICE:
  ------------------
  |  Branch (20869:6): [True: 55, False: 1.88k]
  ------------------
20870|    305|	    case XML_SCHEMA_TYPE_ALL:
  ------------------
  |  Branch (20870:6): [True: 3, False: 1.93k]
  ------------------
20871|    305|		xmlSchemaResolveModelGroupParticleReferences(pctxt,
20872|    305|		    WXS_MODEL_GROUP_CAST item);
  ------------------
  |  |  134|    305|#define WXS_MODEL_GROUP_CAST (xmlSchemaModelGroupPtr)
  ------------------
20873|    305|		FIXHFAILURE;
  ------------------
  |  |20772|    305|#define FIXHFAILURE if (pctxt->err == XML_SCHEMAP_INTERNAL) goto exit_failure;
  |  |  ------------------
  |  |  |  Branch (20772:25): [True: 0, False: 305]
  |  |  ------------------
  ------------------
20874|    305|		break;
20875|      0|	    case XML_SCHEMA_TYPE_IDC_KEY:
  ------------------
  |  Branch (20875:6): [True: 0, False: 1.93k]
  ------------------
20876|      0|	    case XML_SCHEMA_TYPE_IDC_UNIQUE:
  ------------------
  |  Branch (20876:6): [True: 0, False: 1.93k]
  ------------------
20877|      4|	    case XML_SCHEMA_TYPE_IDC_KEYREF:
  ------------------
  |  Branch (20877:6): [True: 4, False: 1.93k]
  ------------------
20878|      4|		xmlSchemaResolveIDCKeyReferences(
20879|      4|		    (xmlSchemaIDCPtr) item, pctxt);
20880|      4|		FIXHFAILURE;
  ------------------
  |  |20772|      4|#define FIXHFAILURE if (pctxt->err == XML_SCHEMAP_INTERNAL) goto exit_failure;
  |  |  ------------------
  |  |  |  Branch (20772:25): [True: 0, False: 4]
  |  |  ------------------
  ------------------
20881|      4|		break;
20882|      0|	    case XML_SCHEMA_EXTRA_ATTR_USE_PROHIB:
  ------------------
  |  Branch (20882:6): [True: 0, False: 1.93k]
  ------------------
20883|       |		/*
20884|       |		* Handle attribute prohibition which had a
20885|       |		* "ref" attribute.
20886|       |		*/
20887|      0|		xmlSchemaResolveAttrUseProhibReferences(
20888|      0|		    WXS_ATTR_PROHIB_CAST item, pctxt);
  ------------------
  |  |  132|      0|#define WXS_ATTR_PROHIB_CAST (xmlSchemaAttributeUseProhibPtr)
  ------------------
20889|      0|		FIXHFAILURE;
  ------------------
  |  |20772|      0|#define FIXHFAILURE if (pctxt->err == XML_SCHEMAP_INTERNAL) goto exit_failure;
  |  |  ------------------
  |  |  |  Branch (20772:25): [True: 0, False: 0]
  |  |  ------------------
  ------------------
20890|      0|		break;
20891|    249|	    default:
  ------------------
  |  Branch (20891:6): [True: 249, False: 1.68k]
  ------------------
20892|    249|		break;
20893|  1.93k|	}
20894|  1.93k|    }
20895|    133|    if (pctxt->nberrors != 0)
  ------------------
  |  Branch (20895:9): [True: 3, False: 130]
  ------------------
20896|      3|	goto exit_error;
20897|       |
20898|       |    /*
20899|       |    * Now that all references are resolved we
20900|       |    * can check for circularity of...
20901|       |    * 1. the base axis of type definitions
20902|       |    * 2. nested model group definitions
20903|       |    * 3. nested attribute group definitions
20904|       |    * TODO: check for circular substitution groups.
20905|       |    */
20906|  2.04k|    for (i = 0; i < nbItems; i++) {
  ------------------
  |  Branch (20906:17): [True: 1.91k, False: 130]
  ------------------
20907|  1.91k|	item = items[i];
20908|       |	/*
20909|       |	* Let's better stop on the first error here.
20910|       |	*/
20911|  1.91k|	switch (item->type) {
20912|    361|	    case XML_SCHEMA_TYPE_COMPLEX:
  ------------------
  |  Branch (20912:6): [True: 361, False: 1.55k]
  ------------------
20913|    521|	    case XML_SCHEMA_TYPE_SIMPLE:
  ------------------
  |  Branch (20913:6): [True: 160, False: 1.75k]
  ------------------
20914|    521|		xmlSchemaCheckTypeDefCircular(
20915|    521|		    (xmlSchemaTypePtr) item, pctxt);
20916|    521|		FIXHFAILURE;
  ------------------
  |  |20772|    521|#define FIXHFAILURE if (pctxt->err == XML_SCHEMAP_INTERNAL) goto exit_failure;
  |  |  ------------------
  |  |  |  Branch (20772:25): [True: 0, False: 521]
  |  |  ------------------
  ------------------
20917|    521|		if (pctxt->nberrors != 0)
  ------------------
  |  Branch (20917:7): [True: 0, False: 521]
  ------------------
20918|      0|		    goto exit_error;
20919|    521|		break;
20920|    521|	    case XML_SCHEMA_TYPE_GROUP:
  ------------------
  |  Branch (20920:6): [True: 9, False: 1.90k]
  ------------------
20921|      9|		xmlSchemaCheckGroupDefCircular(
20922|      9|		    (xmlSchemaModelGroupDefPtr) item, pctxt);
20923|      9|		FIXHFAILURE;
  ------------------
  |  |20772|      9|#define FIXHFAILURE if (pctxt->err == XML_SCHEMAP_INTERNAL) goto exit_failure;
  |  |  ------------------
  |  |  |  Branch (20772:25): [True: 0, False: 9]
  |  |  ------------------
  ------------------
20924|      9|		if (pctxt->nberrors != 0)
  ------------------
  |  Branch (20924:7): [True: 0, False: 9]
  ------------------
20925|      0|		    goto exit_error;
20926|      9|		break;
20927|     40|	    case XML_SCHEMA_TYPE_ATTRIBUTEGROUP:
  ------------------
  |  Branch (20927:6): [True: 40, False: 1.87k]
  ------------------
20928|     40|		xmlSchemaCheckAttrGroupCircular(
20929|     40|		    (xmlSchemaAttributeGroupPtr) item, pctxt);
20930|     40|		FIXHFAILURE;
  ------------------
  |  |20772|     40|#define FIXHFAILURE if (pctxt->err == XML_SCHEMAP_INTERNAL) goto exit_failure;
  |  |  ------------------
  |  |  |  Branch (20772:25): [True: 0, False: 40]
  |  |  ------------------
  ------------------
20931|     40|		if (pctxt->nberrors != 0)
  ------------------
  |  Branch (20931:7): [True: 0, False: 40]
  ------------------
20932|      0|		    goto exit_error;
20933|     40|		break;
20934|  1.34k|	    default:
  ------------------
  |  Branch (20934:6): [True: 1.34k, False: 570]
  ------------------
20935|  1.34k|		break;
20936|  1.91k|	}
20937|  1.91k|    }
20938|    130|    if (pctxt->nberrors != 0)
  ------------------
  |  Branch (20938:9): [True: 0, False: 130]
  ------------------
20939|      0|	goto exit_error;
20940|       |    /*
20941|       |    * Model group definition references:
20942|       |    * Such a reference is reflected by a particle at the component
20943|       |    * level. Until now the 'term' of such particles pointed
20944|       |    * to the model group definition; this was done, in order to
20945|       |    * ease circularity checks. Now we need to set the 'term' of
20946|       |    * such particles to the model group of the model group definition.
20947|       |    */
20948|  2.04k|    for (i = 0; i < nbItems; i++) {
  ------------------
  |  Branch (20948:17): [True: 1.91k, False: 130]
  ------------------
20949|  1.91k|	item = items[i];
20950|  1.91k|	switch (item->type) {
20951|    242|	    case XML_SCHEMA_TYPE_SEQUENCE:
  ------------------
  |  Branch (20951:6): [True: 242, False: 1.67k]
  ------------------
20952|    297|	    case XML_SCHEMA_TYPE_CHOICE:
  ------------------
  |  Branch (20952:6): [True: 55, False: 1.85k]
  ------------------
20953|    297|		xmlSchemaModelGroupToModelGroupDefFixup(pctxt,
20954|    297|		    WXS_MODEL_GROUP_CAST item);
  ------------------
  |  |  134|    297|#define WXS_MODEL_GROUP_CAST (xmlSchemaModelGroupPtr)
  ------------------
20955|    297|		break;
20956|  1.61k|	    default:
  ------------------
  |  Branch (20956:6): [True: 1.61k, False: 297]
  ------------------
20957|  1.61k|		break;
20958|  1.91k|	}
20959|  1.91k|    }
20960|    130|    if (pctxt->nberrors != 0)
  ------------------
  |  Branch (20960:9): [True: 0, False: 130]
  ------------------
20961|      0|	goto exit_error;
20962|       |    /*
20963|       |    * Expand attribute group references of attribute group definitions.
20964|       |    */
20965|  2.04k|    for (i = 0; i < nbItems; i++) {
  ------------------
  |  Branch (20965:17): [True: 1.91k, False: 130]
  ------------------
20966|  1.91k|	item = items[i];
20967|  1.91k|	switch (item->type) {
20968|     40|            case XML_SCHEMA_TYPE_ATTRIBUTEGROUP:
  ------------------
  |  Branch (20968:13): [True: 40, False: 1.87k]
  ------------------
20969|     40|		if ((! WXS_ATTR_GROUP_EXPANDED(item)) &&
  ------------------
  |  |  169|     40|#define WXS_ATTR_GROUP_EXPANDED(ag) ((WXS_ATTR_GROUP_CAST (ag))->flags & XML_SCHEMAS_ATTRGROUP_WILDCARD_BUILDED)
  |  |  ------------------
  |  |  |  |  129|     40|#define WXS_ATTR_GROUP_CAST (xmlSchemaAttributeGroupPtr)
  |  |  ------------------
  |  |               #define WXS_ATTR_GROUP_EXPANDED(ag) ((WXS_ATTR_GROUP_CAST (ag))->flags & XML_SCHEMAS_ATTRGROUP_WILDCARD_BUILDED)
  |  |  ------------------
  |  |  |  |  326|     40|#define XML_SCHEMAS_ATTRGROUP_WILDCARD_BUILDED 1 << 0
  |  |  ------------------
  ------------------
  |  Branch (20969:7): [True: 38, False: 2]
  ------------------
20970|     40|		    WXS_ATTR_GROUP_HAS_REFS(item))
  ------------------
  |  |  168|     38|#define WXS_ATTR_GROUP_HAS_REFS(ag) ((WXS_ATTR_GROUP_CAST (ag))->flags & XML_SCHEMAS_ATTRGROUP_HAS_REFS)
  |  |  ------------------
  |  |  |  |  129|     38|#define WXS_ATTR_GROUP_CAST (xmlSchemaAttributeGroupPtr)
  |  |  ------------------
  |  |               #define WXS_ATTR_GROUP_HAS_REFS(ag) ((WXS_ATTR_GROUP_CAST (ag))->flags & XML_SCHEMAS_ATTRGROUP_HAS_REFS)
  |  |  ------------------
  |  |  |  |  351|     38|#define XML_SCHEMAS_ATTRGROUP_HAS_REFS 1 << 4
  |  |  ------------------
  |  |  |  Branch (168:37): [True: 1, False: 37]
  |  |  ------------------
  ------------------
20971|      1|		{
20972|      1|		    xmlSchemaAttributeGroupExpandRefs(pctxt,
20973|      1|			WXS_ATTR_GROUP_CAST item);
  ------------------
  |  |  129|      1|#define WXS_ATTR_GROUP_CAST (xmlSchemaAttributeGroupPtr)
  ------------------
20974|      1|		    FIXHFAILURE;
  ------------------
  |  |20772|      1|#define FIXHFAILURE if (pctxt->err == XML_SCHEMAP_INTERNAL) goto exit_failure;
  |  |  ------------------
  |  |  |  Branch (20772:25): [True: 0, False: 1]
  |  |  ------------------
  ------------------
20975|      1|		}
20976|     40|		break;
20977|  1.87k|	    default:
  ------------------
  |  Branch (20977:6): [True: 1.87k, False: 40]
  ------------------
20978|  1.87k|		break;
20979|  1.91k|	}
20980|  1.91k|    }
20981|    130|    if (pctxt->nberrors != 0)
  ------------------
  |  Branch (20981:9): [True: 0, False: 130]
  ------------------
20982|      0|	goto exit_error;
20983|       |    /*
20984|       |    * First compute the variety of simple types. This is needed as
20985|       |    * a separate step, since otherwise we won't be able to detect
20986|       |    * circular union types in all cases.
20987|       |    */
20988|  2.04k|    for (i = 0; i < nbItems; i++) {
  ------------------
  |  Branch (20988:17): [True: 1.91k, False: 130]
  ------------------
20989|  1.91k|	item = items[i];
20990|  1.91k|	switch (item->type) {
20991|    160|            case XML_SCHEMA_TYPE_SIMPLE:
  ------------------
  |  Branch (20991:13): [True: 160, False: 1.75k]
  ------------------
20992|    160|		if (WXS_IS_TYPE_NOT_FIXED_1((xmlSchemaTypePtr) item)) {
  ------------------
  |  |  236|    160|    (((item)->type != XML_SCHEMA_TYPE_BASIC) && \
  |  |  ------------------
  |  |  |  Branch (236:6): [True: 160, False: 0]
  |  |  ------------------
  |  |  237|    160|     (((item)->flags & XML_SCHEMAS_TYPE_FIXUP_1) == 0))
  |  |  ------------------
  |  |  |  |  582|    160|#define XML_SCHEMAS_TYPE_FIXUP_1    1 << 29
  |  |  ------------------
  |  |  |  Branch (237:6): [True: 149, False: 11]
  |  |  ------------------
  ------------------
20993|    149|		    xmlSchemaFixupSimpleTypeStageOne(pctxt,
20994|    149|			(xmlSchemaTypePtr) item);
20995|    149|		    FIXHFAILURE;
  ------------------
  |  |20772|    149|#define FIXHFAILURE if (pctxt->err == XML_SCHEMAP_INTERNAL) goto exit_failure;
  |  |  ------------------
  |  |  |  Branch (20772:25): [True: 0, False: 149]
  |  |  ------------------
  ------------------
20996|    149|		}
20997|    160|		break;
20998|  1.75k|	    default:
  ------------------
  |  Branch (20998:6): [True: 1.75k, False: 160]
  ------------------
20999|  1.75k|		break;
21000|  1.91k|	}
21001|  1.91k|    }
21002|    130|    if (pctxt->nberrors != 0)
  ------------------
  |  Branch (21002:9): [True: 0, False: 130]
  ------------------
21003|      0|	goto exit_error;
21004|       |    /*
21005|       |    * Detect circular union types. Note that this needs the variety to
21006|       |    * be already computed.
21007|       |    */
21008|  2.04k|    for (i = 0; i < nbItems; i++) {
  ------------------
  |  Branch (21008:17): [True: 1.91k, False: 130]
  ------------------
21009|  1.91k|	item = items[i];
21010|  1.91k|	switch (item->type) {
21011|    160|            case XML_SCHEMA_TYPE_SIMPLE:
  ------------------
  |  Branch (21011:13): [True: 160, False: 1.75k]
  ------------------
21012|    160|		if (((xmlSchemaTypePtr) item)->memberTypes != NULL) {
  ------------------
  |  Branch (21012:7): [True: 25, False: 135]
  ------------------
21013|     25|		    xmlSchemaCheckUnionTypeDefCircular(pctxt,
21014|     25|			(xmlSchemaTypePtr) item);
21015|     25|		    FIXHFAILURE;
  ------------------
  |  |20772|     25|#define FIXHFAILURE if (pctxt->err == XML_SCHEMAP_INTERNAL) goto exit_failure;
  |  |  ------------------
  |  |  |  Branch (20772:25): [True: 0, False: 25]
  |  |  ------------------
  ------------------
21016|     25|		}
21017|    160|		break;
21018|  1.75k|	    default:
  ------------------
  |  Branch (21018:6): [True: 1.75k, False: 160]
  ------------------
21019|  1.75k|		break;
21020|  1.91k|	}
21021|  1.91k|    }
21022|    130|    if (pctxt->nberrors != 0)
  ------------------
  |  Branch (21022:9): [True: 0, False: 130]
  ------------------
21023|      0|	goto exit_error;
21024|       |
21025|       |    /*
21026|       |    * Do the complete type fixup for simple types.
21027|       |    */
21028|  2.04k|    for (i = 0; i < nbItems; i++) {
  ------------------
  |  Branch (21028:17): [True: 1.91k, False: 130]
  ------------------
21029|  1.91k|	item = items[i];
21030|  1.91k|	switch (item->type) {
21031|    160|            case XML_SCHEMA_TYPE_SIMPLE:
  ------------------
  |  Branch (21031:13): [True: 160, False: 1.75k]
  ------------------
21032|    160|		if (WXS_IS_TYPE_NOT_FIXED(WXS_TYPE_CAST item)) {
  ------------------
  |  |  232|    160|    (((i)->type != XML_SCHEMA_TYPE_BASIC) && \
  |  |  ------------------
  |  |  |  Branch (232:6): [True: 160, False: 0]
  |  |  ------------------
  |  |  233|    160|     (((i)->flags & XML_SCHEMAS_TYPE_INTERNAL_RESOLVED) == 0))
  |  |  ------------------
  |  |  |  |  539|    160|#define XML_SCHEMAS_TYPE_INTERNAL_RESOLVED    1 << 22
  |  |  ------------------
  |  |  |  Branch (233:6): [True: 122, False: 38]
  |  |  ------------------
  ------------------
21033|    122|		    xmlSchemaFixupSimpleTypeStageTwo(pctxt, WXS_TYPE_CAST item);
  ------------------
  |  |  127|    122|#define WXS_TYPE_CAST (xmlSchemaTypePtr)
  ------------------
21034|    122|		    FIXHFAILURE;
  ------------------
  |  |20772|    122|#define FIXHFAILURE if (pctxt->err == XML_SCHEMAP_INTERNAL) goto exit_failure;
  |  |  ------------------
  |  |  |  Branch (20772:25): [True: 0, False: 122]
  |  |  ------------------
  ------------------
21035|    122|		}
21036|    160|		break;
21037|  1.75k|	    default:
  ------------------
  |  Branch (21037:6): [True: 1.75k, False: 160]
  ------------------
21038|  1.75k|		break;
21039|  1.91k|	}
21040|  1.91k|    }
21041|    130|    if (pctxt->nberrors != 0)
  ------------------
  |  Branch (21041:9): [True: 0, False: 130]
  ------------------
21042|      0|	goto exit_error;
21043|       |    /*
21044|       |    * At this point we need build and check all simple types.
21045|       |    */
21046|       |    /*
21047|       |    * Apply constraints for attribute declarations.
21048|       |    */
21049|  2.04k|    for (i = 0; i < nbItems; i++) {
  ------------------
  |  Branch (21049:17): [True: 1.91k, False: 130]
  ------------------
21050|  1.91k|	item = items[i];
21051|  1.91k|	switch (item->type) {
21052|    189|	    case XML_SCHEMA_TYPE_ATTRIBUTE:
  ------------------
  |  Branch (21052:6): [True: 189, False: 1.72k]
  ------------------
21053|    189|		xmlSchemaCheckAttrPropsCorrect(pctxt, WXS_ATTR_CAST item);
  ------------------
  |  |  130|    189|#define WXS_ATTR_CAST (xmlSchemaAttributePtr)
  ------------------
21054|    189|		FIXHFAILURE;
  ------------------
  |  |20772|    189|#define FIXHFAILURE if (pctxt->err == XML_SCHEMAP_INTERNAL) goto exit_failure;
  |  |  ------------------
  |  |  |  Branch (20772:25): [True: 0, False: 189]
  |  |  ------------------
  ------------------
21055|    189|		break;
21056|  1.72k|	    default:
  ------------------
  |  Branch (21056:6): [True: 1.72k, False: 189]
  ------------------
21057|  1.72k|		break;
21058|  1.91k|	}
21059|  1.91k|    }
21060|    130|    if (pctxt->nberrors != 0)
  ------------------
  |  Branch (21060:9): [True: 0, False: 130]
  ------------------
21061|      0|	goto exit_error;
21062|       |    /*
21063|       |    * Apply constraints for attribute uses.
21064|       |    */
21065|  2.04k|    for (i = 0; i < nbItems; i++) {
  ------------------
  |  Branch (21065:17): [True: 1.91k, False: 130]
  ------------------
21066|  1.91k|	item = items[i];
21067|  1.91k|	switch (item->type) {
21068|     42|	    case XML_SCHEMA_TYPE_ATTRIBUTE_USE:
  ------------------
  |  Branch (21068:6): [True: 42, False: 1.87k]
  ------------------
21069|     42|		if (((xmlSchemaAttributeUsePtr)item)->defValue != NULL) {
  ------------------
  |  Branch (21069:7): [True: 0, False: 42]
  ------------------
21070|      0|		    xmlSchemaCheckAttrUsePropsCorrect(pctxt,
21071|      0|			WXS_ATTR_USE_CAST item);
  ------------------
  |  |  131|      0|#define WXS_ATTR_USE_CAST (xmlSchemaAttributeUsePtr)
  ------------------
21072|      0|		    FIXHFAILURE;
  ------------------
  |  |20772|      0|#define FIXHFAILURE if (pctxt->err == XML_SCHEMAP_INTERNAL) goto exit_failure;
  |  |  ------------------
  |  |  |  Branch (20772:25): [True: 0, False: 0]
  |  |  ------------------
  ------------------
21073|      0|		}
21074|     42|		break;
21075|  1.87k|	    default:
  ------------------
  |  Branch (21075:6): [True: 1.87k, False: 42]
  ------------------
21076|  1.87k|		break;
21077|  1.91k|	}
21078|  1.91k|    }
21079|    130|    if (pctxt->nberrors != 0)
  ------------------
  |  Branch (21079:9): [True: 0, False: 130]
  ------------------
21080|      0|	goto exit_error;
21081|       |
21082|       |    /*
21083|       |    * Apply constraints for attribute group definitions.
21084|       |    */
21085|  2.04k|    for (i = 0; i < nbItems; i++) {
  ------------------
  |  Branch (21085:17): [True: 1.91k, False: 130]
  ------------------
21086|  1.91k|	item = items[i];
21087|  1.91k|	switch (item->type) {
21088|     40|	case XML_SCHEMA_TYPE_ATTRIBUTEGROUP:
  ------------------
  |  Branch (21088:2): [True: 40, False: 1.87k]
  ------------------
21089|     40|	    if (( (WXS_ATTR_GROUP_CAST item)->attrUses != NULL) &&
  ------------------
  |  |  129|     40|#define WXS_ATTR_GROUP_CAST (xmlSchemaAttributeGroupPtr)
  ------------------
  |  Branch (21089:10): [True: 13, False: 27]
  ------------------
21090|     40|		( (WXS_LIST_CAST (WXS_ATTR_GROUP_CAST item)->attrUses)->nbItems > 1))
  ------------------
  |  |  137|     13|#define WXS_LIST_CAST (xmlSchemaItemListPtr)
  ------------------
              		( (WXS_LIST_CAST (WXS_ATTR_GROUP_CAST item)->attrUses)->nbItems > 1))
  ------------------
  |  |  129|     13|#define WXS_ATTR_GROUP_CAST (xmlSchemaAttributeGroupPtr)
  ------------------
  |  Branch (21090:3): [True: 4, False: 9]
  ------------------
21091|      4|	    {
21092|      4|		xmlSchemaCheckAGPropsCorrect(pctxt, WXS_ATTR_GROUP_CAST item);
  ------------------
  |  |  129|      4|#define WXS_ATTR_GROUP_CAST (xmlSchemaAttributeGroupPtr)
  ------------------
21093|      4|		FIXHFAILURE;
  ------------------
  |  |20772|      4|#define FIXHFAILURE if (pctxt->err == XML_SCHEMAP_INTERNAL) goto exit_failure;
  |  |  ------------------
  |  |  |  Branch (20772:25): [True: 0, False: 4]
  |  |  ------------------
  ------------------
21094|      4|	    }
21095|     40|	    break;
21096|  1.87k|	default:
  ------------------
  |  Branch (21096:2): [True: 1.87k, False: 40]
  ------------------
21097|  1.87k|	    break;
21098|  1.91k|	}
21099|  1.91k|    }
21100|    130|    if (pctxt->nberrors != 0)
  ------------------
  |  Branch (21100:9): [True: 0, False: 130]
  ------------------
21101|      0|	goto exit_error;
21102|       |
21103|       |    /*
21104|       |    * Apply constraints for redefinitions.
21105|       |    */
21106|    130|    if (WXS_CONSTRUCTOR(pctxt)->redefs != NULL)
  ------------------
  |  |  278|    130|#define WXS_CONSTRUCTOR(ctx) (ctx)->constructor
  ------------------
  |  Branch (21106:9): [True: 0, False: 130]
  ------------------
21107|      0|	xmlSchemaCheckSRCRedefineSecond(pctxt);
21108|    130|    if (pctxt->nberrors != 0)
  ------------------
  |  Branch (21108:9): [True: 0, False: 130]
  ------------------
21109|      0|	goto exit_error;
21110|       |
21111|       |    /*
21112|       |    * Complex types are built and checked.
21113|       |    */
21114|  2.04k|    for (i = 0; i < nbItems; i++) {
  ------------------
  |  Branch (21114:17): [True: 1.91k, False: 130]
  ------------------
21115|  1.91k|	item = con->pending->items[i];
21116|  1.91k|	switch (item->type) {
21117|    361|	    case XML_SCHEMA_TYPE_COMPLEX:
  ------------------
  |  Branch (21117:6): [True: 361, False: 1.55k]
  ------------------
21118|    361|		if (WXS_IS_TYPE_NOT_FIXED(WXS_TYPE_CAST item)) {
  ------------------
  |  |  232|    361|    (((i)->type != XML_SCHEMA_TYPE_BASIC) && \
  |  |  ------------------
  |  |  |  Branch (232:6): [True: 361, False: 0]
  |  |  ------------------
  |  |  233|    361|     (((i)->flags & XML_SCHEMAS_TYPE_INTERNAL_RESOLVED) == 0))
  |  |  ------------------
  |  |  |  |  539|    361|#define XML_SCHEMAS_TYPE_INTERNAL_RESOLVED    1 << 22
  |  |  ------------------
  |  |  |  Branch (233:6): [True: 331, False: 30]
  |  |  ------------------
  ------------------
21119|    331|		    xmlSchemaFixupComplexType(pctxt, WXS_TYPE_CAST item);
  ------------------
  |  |  127|    331|#define WXS_TYPE_CAST (xmlSchemaTypePtr)
  ------------------
21120|    331|		    FIXHFAILURE;
  ------------------
  |  |20772|    331|#define FIXHFAILURE if (pctxt->err == XML_SCHEMAP_INTERNAL) goto exit_failure;
  |  |  ------------------
  |  |  |  Branch (20772:25): [True: 0, False: 331]
  |  |  ------------------
  ------------------
21121|    331|		}
21122|    361|		break;
21123|  1.55k|	    default:
  ------------------
  |  Branch (21123:6): [True: 1.55k, False: 361]
  ------------------
21124|  1.55k|		break;
21125|  1.91k|	}
21126|  1.91k|    }
21127|    130|    if (pctxt->nberrors != 0)
  ------------------
  |  Branch (21127:9): [True: 5, False: 125]
  ------------------
21128|      5|	goto exit_error;
21129|       |
21130|       |    /*
21131|       |    * The list could have changed, since xmlSchemaFixupComplexType()
21132|       |    * will create particles and model groups in some cases.
21133|       |    */
21134|    125|    items = (xmlSchemaTreeItemPtr *) con->pending->items;
21135|    125|    nbItems = con->pending->nbItems;
21136|       |
21137|       |    /*
21138|       |    * Apply some constraints for element declarations.
21139|       |    */
21140|  2.00k|    for (i = 0; i < nbItems; i++) {
  ------------------
  |  Branch (21140:17): [True: 1.87k, False: 125]
  ------------------
21141|  1.87k|	item = items[i];
21142|  1.87k|	switch (item->type) {
21143|    555|	    case XML_SCHEMA_TYPE_ELEMENT:
  ------------------
  |  Branch (21143:6): [True: 555, False: 1.32k]
  ------------------
21144|    555|		elemDecl = (xmlSchemaElementPtr) item;
21145|       |
21146|    555|		if ((elemDecl->flags & XML_SCHEMAS_ELEM_INTERNAL_CHECKED) == 0)
  ------------------
  |  |  761|    555|#define XML_SCHEMAS_ELEM_INTERNAL_CHECKED        1 << 18
  ------------------
  |  Branch (21146:7): [True: 555, False: 0]
  ------------------
21147|    555|		{
21148|    555|		    xmlSchemaCheckElementDeclComponent(
21149|    555|			(xmlSchemaElementPtr) elemDecl, pctxt);
21150|    555|		    FIXHFAILURE;
  ------------------
  |  |20772|    555|#define FIXHFAILURE if (pctxt->err == XML_SCHEMAP_INTERNAL) goto exit_failure;
  |  |  ------------------
  |  |  |  Branch (20772:25): [True: 0, False: 555]
  |  |  ------------------
  ------------------
21151|    555|		}
21152|       |
21153|       |#ifdef WXS_ELEM_DECL_CONS_ENABLED
21154|       |		/*
21155|       |		* Schema Component Constraint: Element Declarations Consistent
21156|       |		* Apply this constraint to local types of element declarations.
21157|       |		*/
21158|       |		if ((WXS_ELEM_TYPEDEF(elemDecl) != NULL) &&
21159|       |		    (WXS_IS_COMPLEX(WXS_ELEM_TYPEDEF(elemDecl))) &&
21160|       |		    (WXS_TYPE_IS_LOCAL(WXS_ELEM_TYPEDEF(elemDecl))))
21161|       |		{
21162|       |		    xmlSchemaCheckElementDeclConsistent(pctxt,
21163|       |			WXS_BASIC_CAST elemDecl,
21164|       |			WXS_TYPE_PARTICLE(WXS_ELEM_TYPEDEF(elemDecl)),
21165|       |			NULL, NULL, 0);
21166|       |		}
21167|       |#endif
21168|    555|		break;
21169|  1.32k|	    default:
  ------------------
  |  Branch (21169:6): [True: 1.32k, False: 555]
  ------------------
21170|  1.32k|		break;
21171|  1.87k|	}
21172|  1.87k|    }
21173|    125|    if (pctxt->nberrors != 0)
  ------------------
  |  Branch (21173:9): [True: 1, False: 124]
  ------------------
21174|      1|	goto exit_error;
21175|       |
21176|       |    /*
21177|       |    * Finally we can build the automaton from the content model of
21178|       |    * complex types.
21179|       |    */
21180|       |
21181|  2.00k|    for (i = 0; i < nbItems; i++) {
  ------------------
  |  Branch (21181:17): [True: 1.87k, False: 124]
  ------------------
21182|  1.87k|	item = items[i];
21183|  1.87k|	switch (item->type) {
21184|    346|	    case XML_SCHEMA_TYPE_COMPLEX:
  ------------------
  |  Branch (21184:6): [True: 346, False: 1.53k]
  ------------------
21185|    346|		xmlSchemaBuildContentModel((xmlSchemaTypePtr) item, pctxt);
21186|       |		/* FIXHFAILURE; */
21187|    346|		break;
21188|  1.53k|	    default:
  ------------------
  |  Branch (21188:6): [True: 1.53k, False: 346]
  ------------------
21189|  1.53k|		break;
21190|  1.87k|	}
21191|  1.87k|    }
21192|    124|    if (pctxt->nberrors != 0)
  ------------------
  |  Branch (21192:9): [True: 2, False: 122]
  ------------------
21193|      2|	goto exit_error;
21194|       |    /*
21195|       |    * URGENT TODO: cos-element-consistent
21196|       |    */
21197|    122|    goto exit;
21198|       |
21199|    122|exit_error:
21200|     11|    ret = pctxt->err;
21201|     11|    goto exit;
21202|       |
21203|      0|exit_failure:
21204|      0|    ret = -1;
21205|       |
21206|    133|exit:
21207|       |    /*
21208|       |    * Reset the constructor. This is needed for XSI acquisition, since
21209|       |    * those items will be processed over and over again for every XSI
21210|       |    * if not cleared here.
21211|       |    */
21212|    133|    con->bucket = oldbucket;
21213|    133|    con->pending->nbItems = 0;
21214|    133|    if (con->substGroups != NULL) {
  ------------------
  |  Branch (21214:9): [True: 4, False: 129]
  ------------------
21215|      4|	xmlHashFree(con->substGroups, xmlSchemaSubstGroupFreeEntry);
21216|      4|	con->substGroups = NULL;
21217|      4|    }
21218|    133|    if (con->redefs != NULL) {
  ------------------
  |  Branch (21218:9): [True: 0, False: 133]
  ------------------
21219|      0|	xmlSchemaRedefListFree(con->redefs);
21220|      0|	con->redefs = NULL;
21221|      0|    }
21222|    133|    return(ret);
21223|      0|}
xmlschemas.c:xmlSchemaCheckSRCRedefineFirst:
20394|    133|{
20395|    133|    int err = 0;
20396|    133|    xmlSchemaRedefPtr redef = WXS_CONSTRUCTOR(pctxt)->redefs;
  ------------------
  |  |  278|    133|#define WXS_CONSTRUCTOR(ctx) (ctx)->constructor
  ------------------
20397|    133|    xmlSchemaBasicItemPtr prev, item;
20398|    133|    int wasRedefined;
20399|       |
20400|    133|    if (redef == NULL)
  ------------------
  |  Branch (20400:9): [True: 133, False: 0]
  ------------------
20401|    133|	return(0);
20402|       |
20403|      0|    do {
20404|      0|	item = redef->item;
20405|       |	/*
20406|       |	* First try to locate the redefined component in the
20407|       |	* schema graph starting with the redefined schema.
20408|       |	* NOTE: According to this schema bug entry:
20409|       |	*   http://lists.w3.org/Archives/Public/www-xml-schema-comments/2005OctDec/0019.html
20410|       |	*   it's not clear if the referenced component needs to originate
20411|       |	*   from the <redefine>d schema _document_ or the schema; the latter
20412|       |	*   would include all imported and included sub-schemas of the
20413|       |	*   <redefine>d schema. Currently the latter approach is used.
20414|       |	*   SUPPLEMENT: It seems that the WG moves towards the latter
20415|       |	*   approach, so we are doing it right.
20416|       |	*
20417|       |	*/
20418|      0|	prev = xmlSchemaFindRedefCompInGraph(
20419|      0|	    redef->targetBucket, item->type,
20420|      0|	    redef->refName, redef->refTargetNs);
20421|      0|	if (prev == NULL) {
  ------------------
  |  Branch (20421:6): [True: 0, False: 0]
  ------------------
20422|      0|	    xmlChar *str = NULL;
20423|      0|	    xmlNodePtr node;
20424|       |
20425|       |	    /*
20426|       |	    * SPEC src-redefine:
20427|       |	    * (6.2.1) "The `actual value` of its own name attribute plus
20428|       |	    * target namespace must successfully `resolve` to a model
20429|       |	    * group definition in I."
20430|       |	    * (7.2.1) "The `actual value` of its own name attribute plus
20431|       |	    * target namespace must successfully `resolve` to an attribute
20432|       |	    * group definition in I."
20433|       |
20434|       |	    *
20435|       |	    * Note that, if we are redefining with the use of references
20436|       |	    * to components, the spec assumes the src-resolve to be used;
20437|       |	    * but this won't assure that we search only *inside* the
20438|       |	    * redefined schema.
20439|       |	    */
20440|      0|	    if (redef->reference)
  ------------------
  |  Branch (20440:10): [True: 0, False: 0]
  ------------------
20441|      0|		node = WXS_ITEM_NODE(redef->reference);
  ------------------
  |  |  142|      0|#define WXS_ITEM_NODE(i) xmlSchemaGetComponentNode(WXS_BASIC_CAST (i))
  |  |  ------------------
  |  |  |  |  124|      0|#define WXS_BASIC_CAST (xmlSchemaBasicItemPtr)
  |  |  ------------------
  ------------------
20442|      0|	    else
20443|      0|		node = WXS_ITEM_NODE(item);
  ------------------
  |  |  142|      0|#define WXS_ITEM_NODE(i) xmlSchemaGetComponentNode(WXS_BASIC_CAST (i))
  |  |  ------------------
  |  |  |  |  124|      0|#define WXS_BASIC_CAST (xmlSchemaBasicItemPtr)
  |  |  ------------------
  ------------------
20444|      0|	    xmlSchemaCustomErr(ACTXT_CAST pctxt,
  ------------------
  |  |  121|      0|#define ACTXT_CAST (xmlSchemaAbstractCtxtPtr)
  ------------------
20445|       |		/*
20446|       |		* TODO: error code.
20447|       |		* Probably XML_SCHEMAP_SRC_RESOLVE, if this is using the
20448|       |		* reference kind.
20449|       |		*/
20450|      0|		XML_SCHEMAP_SRC_REDEFINE, node, NULL,
20451|      0|		"The %s '%s' to be redefined could not be found in "
20452|      0|		"the redefined schema",
20453|      0|		WXS_ITEM_TYPE_NAME(item),
  ------------------
  |  |  144|      0|#define WXS_ITEM_TYPE_NAME(i) xmlSchemaGetComponentTypeStr(WXS_BASIC_CAST (i))
  |  |  ------------------
  |  |  |  |  124|      0|#define WXS_BASIC_CAST (xmlSchemaBasicItemPtr)
  |  |  ------------------
  ------------------
20454|      0|		xmlSchemaFormatQName(&str, redef->refTargetNs,
20455|      0|		    redef->refName));
20456|      0|	    FREE_AND_NULL(str);
  ------------------
  |  |  320|      0|#define FREE_AND_NULL(str) if ((str) != NULL) { xmlFree((xmlChar *) (str)); str = NULL; }
  |  |  ------------------
  |  |  |  Branch (320:32): [True: 0, False: 0]
  |  |  ------------------
  ------------------
20457|      0|	    err = pctxt->err;
20458|      0|	    redef = redef->next;
20459|      0|	    continue;
20460|      0|	}
20461|       |	/*
20462|       |	* TODO: Obtaining and setting the redefinition state is really
20463|       |	* clumsy.
20464|       |	*/
20465|      0|	wasRedefined = 0;
20466|      0|	switch (item->type) {
20467|      0|	    case XML_SCHEMA_TYPE_COMPLEX:
  ------------------
  |  Branch (20467:6): [True: 0, False: 0]
  ------------------
20468|      0|	    case XML_SCHEMA_TYPE_SIMPLE:
  ------------------
  |  Branch (20468:6): [True: 0, False: 0]
  ------------------
20469|      0|		if ((WXS_TYPE_CAST prev)->flags &
  ------------------
  |  |  127|      0|#define WXS_TYPE_CAST (xmlSchemaTypePtr)
  ------------------
  |  Branch (20469:7): [True: 0, False: 0]
  ------------------
20470|      0|		    XML_SCHEMAS_TYPE_REDEFINED)
  ------------------
  |  |  589|      0|#define XML_SCHEMAS_TYPE_REDEFINED    1 << 30
  ------------------
20471|      0|		{
20472|      0|		    wasRedefined = 1;
20473|      0|		    break;
20474|      0|		}
20475|       |		/* Mark it as redefined. */
20476|      0|		(WXS_TYPE_CAST prev)->flags |= XML_SCHEMAS_TYPE_REDEFINED;
  ------------------
  |  |  127|      0|#define WXS_TYPE_CAST (xmlSchemaTypePtr)
  ------------------
              		(WXS_TYPE_CAST prev)->flags |= XML_SCHEMAS_TYPE_REDEFINED;
  ------------------
  |  |  589|      0|#define XML_SCHEMAS_TYPE_REDEFINED    1 << 30
  ------------------
20477|       |		/*
20478|       |		* Assign the redefined type to the
20479|       |		* base type of the redefining type.
20480|       |		* TODO: How
20481|       |		*/
20482|      0|		((xmlSchemaTypePtr) item)->baseType =
20483|      0|		    (xmlSchemaTypePtr) prev;
20484|      0|		break;
20485|      0|	    case XML_SCHEMA_TYPE_GROUP:
  ------------------
  |  Branch (20485:6): [True: 0, False: 0]
  ------------------
20486|      0|		if ((WXS_MODEL_GROUPDEF_CAST prev)->flags &
  ------------------
  |  |  133|      0|#define WXS_MODEL_GROUPDEF_CAST (xmlSchemaModelGroupDefPtr)
  ------------------
  |  Branch (20486:7): [True: 0, False: 0]
  ------------------
20487|      0|		    XML_SCHEMA_MODEL_GROUP_DEF_REDEFINED)
  ------------------
  |  |  691|      0|#define XML_SCHEMA_MODEL_GROUP_DEF_REDEFINED 1<<1
  ------------------
20488|      0|		{
20489|      0|		    wasRedefined = 1;
20490|      0|		    break;
20491|      0|		}
20492|       |		/* Mark it as redefined. */
20493|      0|		(WXS_MODEL_GROUPDEF_CAST prev)->flags |=
  ------------------
  |  |  133|      0|#define WXS_MODEL_GROUPDEF_CAST (xmlSchemaModelGroupDefPtr)
  ------------------
20494|      0|		    XML_SCHEMA_MODEL_GROUP_DEF_REDEFINED;
  ------------------
  |  |  691|      0|#define XML_SCHEMA_MODEL_GROUP_DEF_REDEFINED 1<<1
  ------------------
20495|      0|		if (redef->reference != NULL) {
  ------------------
  |  Branch (20495:7): [True: 0, False: 0]
  ------------------
20496|       |		    /*
20497|       |		    * Overwrite the QName-reference with the
20498|       |		    * referenced model group def.
20499|       |		    */
20500|      0|		    (WXS_PTC_CAST redef->reference)->children =
  ------------------
  |  |  126|      0|#define WXS_PTC_CAST (xmlSchemaParticlePtr)
  ------------------
20501|      0|			WXS_TREE_CAST prev;
  ------------------
  |  |  125|      0|#define WXS_TREE_CAST (xmlSchemaTreeItemPtr)
  ------------------
20502|      0|		}
20503|      0|		redef->target = prev;
20504|      0|		break;
20505|      0|	    case XML_SCHEMA_TYPE_ATTRIBUTEGROUP:
  ------------------
  |  Branch (20505:6): [True: 0, False: 0]
  ------------------
20506|      0|		if ((WXS_ATTR_GROUP_CAST prev)->flags &
  ------------------
  |  |  129|      0|#define WXS_ATTR_GROUP_CAST (xmlSchemaAttributeGroupPtr)
  ------------------
  |  Branch (20506:7): [True: 0, False: 0]
  ------------------
20507|      0|		    XML_SCHEMAS_ATTRGROUP_REDEFINED)
  ------------------
  |  |  345|      0|#define XML_SCHEMAS_ATTRGROUP_REDEFINED 1 << 3
  ------------------
20508|      0|		{
20509|      0|		    wasRedefined = 1;
20510|      0|		    break;
20511|      0|		}
20512|      0|		(WXS_ATTR_GROUP_CAST prev)->flags |=
  ------------------
  |  |  129|      0|#define WXS_ATTR_GROUP_CAST (xmlSchemaAttributeGroupPtr)
  ------------------
20513|      0|		    XML_SCHEMAS_ATTRGROUP_REDEFINED;
  ------------------
  |  |  345|      0|#define XML_SCHEMAS_ATTRGROUP_REDEFINED 1 << 3
  ------------------
20514|      0|		if (redef->reference != NULL) {
  ------------------
  |  Branch (20514:7): [True: 0, False: 0]
  ------------------
20515|       |		    /*
20516|       |		    * Assign the redefined attribute group to the
20517|       |		    * QName-reference component.
20518|       |		    * This is the easy case, since we will just
20519|       |		    * expand the redefined group.
20520|       |		    */
20521|      0|		    (WXS_QNAME_CAST redef->reference)->item = prev;
  ------------------
  |  |  136|      0|#define WXS_QNAME_CAST (xmlSchemaQNameRefPtr)
  ------------------
20522|      0|		    redef->target = NULL;
20523|      0|		} else {
20524|       |		    /*
20525|       |		    * This is the complicated case: we need
20526|       |		    * to apply src-redefine (7.2.2) at a later
20527|       |		    * stage, i.e. when attribute group references
20528|       |		    * have been expanded and simple types have
20529|       |		    * been fixed.
20530|       |		    */
20531|      0|		    redef->target = prev;
20532|      0|		}
20533|      0|		break;
20534|      0|	    default:
  ------------------
  |  Branch (20534:6): [True: 0, False: 0]
  ------------------
20535|      0|		PERROR_INT("xmlSchemaResolveRedefReferences",
  ------------------
  |  | 2824|      0|#define PERROR_INT(func, msg) xmlSchemaInternalErr(ACTXT_CAST pctxt, func, msg);
  |  |  ------------------
  |  |  |  |  121|      0|#define ACTXT_CAST (xmlSchemaAbstractCtxtPtr)
  |  |  ------------------
  ------------------
20536|      0|		    "Unexpected redefined component type");
20537|      0|		return(-1);
20538|      0|	}
20539|      0|	if (wasRedefined) {
  ------------------
  |  Branch (20539:6): [True: 0, False: 0]
  ------------------
20540|      0|	    xmlChar *str = NULL;
20541|      0|	    xmlNodePtr node;
20542|       |
20543|      0|	    if (redef->reference)
  ------------------
  |  Branch (20543:10): [True: 0, False: 0]
  ------------------
20544|      0|		node = WXS_ITEM_NODE(redef->reference);
  ------------------
  |  |  142|      0|#define WXS_ITEM_NODE(i) xmlSchemaGetComponentNode(WXS_BASIC_CAST (i))
  |  |  ------------------
  |  |  |  |  124|      0|#define WXS_BASIC_CAST (xmlSchemaBasicItemPtr)
  |  |  ------------------
  ------------------
20545|      0|	    else
20546|      0|		node = WXS_ITEM_NODE(redef->item);
  ------------------
  |  |  142|      0|#define WXS_ITEM_NODE(i) xmlSchemaGetComponentNode(WXS_BASIC_CAST (i))
  |  |  ------------------
  |  |  |  |  124|      0|#define WXS_BASIC_CAST (xmlSchemaBasicItemPtr)
  |  |  ------------------
  ------------------
20547|       |
20548|      0|	    xmlSchemaCustomErr(ACTXT_CAST pctxt,
  ------------------
  |  |  121|      0|#define ACTXT_CAST (xmlSchemaAbstractCtxtPtr)
  ------------------
20549|       |		/* TODO: error code. */
20550|      0|		XML_SCHEMAP_SRC_REDEFINE,
20551|      0|		node, NULL,
20552|      0|		"The referenced %s was already redefined. Multiple "
20553|      0|		"redefinition of the same component is not supported",
20554|      0|		xmlSchemaGetComponentDesignation(&str, prev),
20555|      0|		NULL);
20556|      0|	    FREE_AND_NULL(str)
  ------------------
  |  |  320|      0|#define FREE_AND_NULL(str) if ((str) != NULL) { xmlFree((xmlChar *) (str)); str = NULL; }
  |  |  ------------------
  |  |  |  Branch (320:32): [True: 0, False: 0]
  |  |  ------------------
  ------------------
20557|      0|	    err = pctxt->err;
20558|      0|	    redef = redef->next;
20559|      0|	    continue;
20560|      0|	}
20561|      0|	redef = redef->next;
20562|      0|    } while (redef != NULL);
  ------------------
  |  Branch (20562:14): [True: 0, False: 0]
  ------------------
20563|       |
20564|      0|    return(err);
20565|      0|}
xmlschemas.c:xmlSchemaAddComponents:
20646|    158|{
20647|    158|    xmlSchemaBasicItemPtr item;
20648|    158|    int err;
20649|    158|    xmlHashTablePtr *table;
20650|    158|    const xmlChar *name;
20651|    158|    int i;
20652|       |
20653|    158|#define WXS_GET_GLOBAL_HASH(c, slot) { \
20654|    158|    if (WXS_IS_BUCKET_IMPMAIN((c)->type)) \
20655|    158|	table = &(WXS_IMPBUCKET((c))->schema->slot); \
20656|    158|    else \
20657|    158|	table = &(WXS_INCBUCKET((c))->ownerImport->schema->slot); }
20658|       |
20659|       |    /*
20660|       |    * Add global components to the schema's hash tables.
20661|       |    * This is the place where duplicate components will be
20662|       |    * detected.
20663|       |    * TODO: I think normally we should support imports of the
20664|       |    *   same namespace from multiple locations. We don't do currently,
20665|       |    *   but if we do then according to:
20666|       |    *   http://www.w3.org/Bugs/Public/show_bug.cgi?id=2224
20667|       |    *   we would need, if imported directly, to import redefined
20668|       |    *   components as well to be able to catch clashing components.
20669|       |    *   (I hope I'll still know what this means after some months :-()
20670|       |    */
20671|    158|    if (bucket == NULL)
  ------------------
  |  Branch (20671:9): [True: 0, False: 158]
  ------------------
20672|      0|	return(-1);
20673|    158|    if (bucket->flags & XML_SCHEMA_BUCKET_COMPS_ADDED)
  ------------------
  |  |  391|    158|#define XML_SCHEMA_BUCKET_COMPS_ADDED 1<<1
  ------------------
  |  Branch (20673:9): [True: 0, False: 158]
  ------------------
20674|      0|	return(0);
20675|    158|    bucket->flags |= XML_SCHEMA_BUCKET_COMPS_ADDED;
  ------------------
  |  |  391|    158|#define XML_SCHEMA_BUCKET_COMPS_ADDED 1<<1
  ------------------
20676|       |
20677|    795|    for (i = 0; i < bucket->globals->nbItems; i++) {
  ------------------
  |  Branch (20677:17): [True: 637, False: 158]
  ------------------
20678|    637|	item = bucket->globals->items[i];
20679|    637|	table = NULL;
20680|    637|	switch (item->type) {
20681|    180|	    case XML_SCHEMA_TYPE_COMPLEX:
  ------------------
  |  Branch (20681:6): [True: 180, False: 457]
  ------------------
20682|    249|	    case XML_SCHEMA_TYPE_SIMPLE:
  ------------------
  |  Branch (20682:6): [True: 69, False: 568]
  ------------------
20683|    249|		if (WXS_REDEFINED_TYPE(item))
  ------------------
  |  |20383|    249|#define WXS_REDEFINED_TYPE(c) \
  |  |  ------------------
  |  |  |  Branch (20383:31): [True: 0, False: 249]
  |  |  ------------------
  |  |20384|    249|(((xmlSchemaTypePtr) item)->flags & XML_SCHEMAS_TYPE_REDEFINED)
  |  |  ------------------
  |  |  |  |  589|    249|#define XML_SCHEMAS_TYPE_REDEFINED    1 << 30
  |  |  ------------------
  ------------------
20684|      0|		    continue;
20685|    249|		name = (WXS_TYPE_CAST item)->name;
  ------------------
  |  |  127|    249|#define WXS_TYPE_CAST (xmlSchemaTypePtr)
  ------------------
20686|    249|		WXS_GET_GLOBAL_HASH(bucket, typeDecl)
  ------------------
  |  |20653|    249|#define WXS_GET_GLOBAL_HASH(c, slot) { \
  |  |20654|    249|    if (WXS_IS_BUCKET_IMPMAIN((c)->type)) \
  |  |  ------------------
  |  |  |  |  199|    249|#define WXS_IS_BUCKET_IMPMAIN(t) (((t) == XML_SCHEMA_SCHEMA_MAIN) || \
  |  |  |  |  ------------------
  |  |  |  |  |  |  371|    249|#define XML_SCHEMA_SCHEMA_MAIN 0
  |  |  |  |  ------------------
  |  |  |  |  |  Branch (199:35): [True: 221, False: 28]
  |  |  |  |  ------------------
  |  |  |  |  200|    249|    ((t) == XML_SCHEMA_SCHEMA_IMPORT))
  |  |  |  |  ------------------
  |  |  |  |  |  |  372|     28|#define XML_SCHEMA_SCHEMA_IMPORT 1
  |  |  |  |  ------------------
  |  |  |  |  |  Branch (200:5): [True: 16, False: 12]
  |  |  |  |  ------------------
  |  |  ------------------
  |  |20655|    249|	table = &(WXS_IMPBUCKET((c))->schema->slot); \
  |  |  ------------------
  |  |  |  |  202|    237|#define WXS_IMPBUCKET(b) ((xmlSchemaImportPtr) (b))
  |  |  ------------------
  |  |20656|    249|    else \
  |  |20657|    249|	table = &(WXS_INCBUCKET((c))->ownerImport->schema->slot); }
  |  |  ------------------
  |  |  |  |  204|     12|#define WXS_INCBUCKET(b) ((xmlSchemaIncludePtr) (b))
  |  |  ------------------
  ------------------
20687|    249|		break;
20688|    293|	    case XML_SCHEMA_TYPE_ELEMENT:
  ------------------
  |  Branch (20688:6): [True: 293, False: 344]
  ------------------
20689|    293|		name = (WXS_ELEM_CAST item)->name;
  ------------------
  |  |  128|    293|#define WXS_ELEM_CAST (xmlSchemaElementPtr)
  ------------------
20690|    293|		WXS_GET_GLOBAL_HASH(bucket, elemDecl)
  ------------------
  |  |20653|    293|#define WXS_GET_GLOBAL_HASH(c, slot) { \
  |  |20654|    293|    if (WXS_IS_BUCKET_IMPMAIN((c)->type)) \
  |  |  ------------------
  |  |  |  |  199|    293|#define WXS_IS_BUCKET_IMPMAIN(t) (((t) == XML_SCHEMA_SCHEMA_MAIN) || \
  |  |  |  |  ------------------
  |  |  |  |  |  |  371|    293|#define XML_SCHEMA_SCHEMA_MAIN 0
  |  |  |  |  ------------------
  |  |  |  |  |  Branch (199:35): [True: 267, False: 26]
  |  |  |  |  ------------------
  |  |  |  |  200|    293|    ((t) == XML_SCHEMA_SCHEMA_IMPORT))
  |  |  |  |  ------------------
  |  |  |  |  |  |  372|     26|#define XML_SCHEMA_SCHEMA_IMPORT 1
  |  |  |  |  ------------------
  |  |  |  |  |  Branch (200:5): [True: 21, False: 5]
  |  |  |  |  ------------------
  |  |  ------------------
  |  |20655|    293|	table = &(WXS_IMPBUCKET((c))->schema->slot); \
  |  |  ------------------
  |  |  |  |  202|    288|#define WXS_IMPBUCKET(b) ((xmlSchemaImportPtr) (b))
  |  |  ------------------
  |  |20656|    293|    else \
  |  |20657|    293|	table = &(WXS_INCBUCKET((c))->ownerImport->schema->slot); }
  |  |  ------------------
  |  |  |  |  204|      5|#define WXS_INCBUCKET(b) ((xmlSchemaIncludePtr) (b))
  |  |  ------------------
  ------------------
20691|    293|		break;
20692|     31|	    case XML_SCHEMA_TYPE_ATTRIBUTE:
  ------------------
  |  Branch (20692:6): [True: 31, False: 606]
  ------------------
20693|     31|		name = (WXS_ATTR_CAST item)->name;
  ------------------
  |  |  130|     31|#define WXS_ATTR_CAST (xmlSchemaAttributePtr)
  ------------------
20694|     31|		WXS_GET_GLOBAL_HASH(bucket, attrDecl)
  ------------------
  |  |20653|     31|#define WXS_GET_GLOBAL_HASH(c, slot) { \
  |  |20654|     31|    if (WXS_IS_BUCKET_IMPMAIN((c)->type)) \
  |  |  ------------------
  |  |  |  |  199|     31|#define WXS_IS_BUCKET_IMPMAIN(t) (((t) == XML_SCHEMA_SCHEMA_MAIN) || \
  |  |  |  |  ------------------
  |  |  |  |  |  |  371|     31|#define XML_SCHEMA_SCHEMA_MAIN 0
  |  |  |  |  ------------------
  |  |  |  |  |  Branch (199:35): [True: 24, False: 7]
  |  |  |  |  ------------------
  |  |  |  |  200|     31|    ((t) == XML_SCHEMA_SCHEMA_IMPORT))
  |  |  |  |  ------------------
  |  |  |  |  |  |  372|      7|#define XML_SCHEMA_SCHEMA_IMPORT 1
  |  |  |  |  ------------------
  |  |  |  |  |  Branch (200:5): [True: 6, False: 1]
  |  |  |  |  ------------------
  |  |  ------------------
  |  |20655|     31|	table = &(WXS_IMPBUCKET((c))->schema->slot); \
  |  |  ------------------
  |  |  |  |  202|     30|#define WXS_IMPBUCKET(b) ((xmlSchemaImportPtr) (b))
  |  |  ------------------
  |  |20656|     31|    else \
  |  |20657|     31|	table = &(WXS_INCBUCKET((c))->ownerImport->schema->slot); }
  |  |  ------------------
  |  |  |  |  204|      1|#define WXS_INCBUCKET(b) ((xmlSchemaIncludePtr) (b))
  |  |  ------------------
  ------------------
20695|     31|		break;
20696|      9|	    case XML_SCHEMA_TYPE_GROUP:
  ------------------
  |  Branch (20696:6): [True: 9, False: 628]
  ------------------
20697|      9|		if (WXS_REDEFINED_MODEL_GROUP_DEF(item))
  ------------------
  |  |20386|      9|#define WXS_REDEFINED_MODEL_GROUP_DEF(c) \
  |  |  ------------------
  |  |  |  Branch (20386:42): [True: 0, False: 9]
  |  |  ------------------
  |  |20387|      9|(((xmlSchemaModelGroupDefPtr) item)->flags & XML_SCHEMA_MODEL_GROUP_DEF_REDEFINED)
  |  |  ------------------
  |  |  |  |  691|      9|#define XML_SCHEMA_MODEL_GROUP_DEF_REDEFINED 1<<1
  |  |  ------------------
  ------------------
20698|      0|		    continue;
20699|      9|		name = (WXS_MODEL_GROUPDEF_CAST item)->name;
  ------------------
  |  |  133|      9|#define WXS_MODEL_GROUPDEF_CAST (xmlSchemaModelGroupDefPtr)
  ------------------
20700|      9|		WXS_GET_GLOBAL_HASH(bucket, groupDecl)
  ------------------
  |  |20653|      9|#define WXS_GET_GLOBAL_HASH(c, slot) { \
  |  |20654|      9|    if (WXS_IS_BUCKET_IMPMAIN((c)->type)) \
  |  |  ------------------
  |  |  |  |  199|      9|#define WXS_IS_BUCKET_IMPMAIN(t) (((t) == XML_SCHEMA_SCHEMA_MAIN) || \
  |  |  |  |  ------------------
  |  |  |  |  |  |  371|      9|#define XML_SCHEMA_SCHEMA_MAIN 0
  |  |  |  |  ------------------
  |  |  |  |  |  Branch (199:35): [True: 4, False: 5]
  |  |  |  |  ------------------
  |  |  |  |  200|      9|    ((t) == XML_SCHEMA_SCHEMA_IMPORT))
  |  |  |  |  ------------------
  |  |  |  |  |  |  372|      5|#define XML_SCHEMA_SCHEMA_IMPORT 1
  |  |  |  |  ------------------
  |  |  |  |  |  Branch (200:5): [True: 5, False: 0]
  |  |  |  |  ------------------
  |  |  ------------------
  |  |20655|      9|	table = &(WXS_IMPBUCKET((c))->schema->slot); \
  |  |  ------------------
  |  |  |  |  202|      9|#define WXS_IMPBUCKET(b) ((xmlSchemaImportPtr) (b))
  |  |  ------------------
  |  |20656|      9|    else \
  |  |20657|      9|	table = &(WXS_INCBUCKET((c))->ownerImport->schema->slot); }
  |  |  ------------------
  |  |  |  |  204|      0|#define WXS_INCBUCKET(b) ((xmlSchemaIncludePtr) (b))
  |  |  ------------------
  ------------------
20701|      9|		break;
20702|     40|	    case XML_SCHEMA_TYPE_ATTRIBUTEGROUP:
  ------------------
  |  Branch (20702:6): [True: 40, False: 597]
  ------------------
20703|     40|		if (WXS_REDEFINED_ATTR_GROUP(item))
  ------------------
  |  |20389|     40|#define WXS_REDEFINED_ATTR_GROUP(c) \
  |  |  ------------------
  |  |  |  Branch (20389:37): [True: 0, False: 40]
  |  |  ------------------
  |  |20390|     40|(((xmlSchemaAttributeGroupPtr) item)->flags & XML_SCHEMAS_ATTRGROUP_REDEFINED)
  |  |  ------------------
  |  |  |  |  345|     40|#define XML_SCHEMAS_ATTRGROUP_REDEFINED 1 << 3
  |  |  ------------------
  ------------------
20704|      0|		    continue;
20705|     40|		name = (WXS_ATTR_GROUP_CAST item)->name;
  ------------------
  |  |  129|     40|#define WXS_ATTR_GROUP_CAST (xmlSchemaAttributeGroupPtr)
  ------------------
20706|     40|		WXS_GET_GLOBAL_HASH(bucket, attrgrpDecl)
  ------------------
  |  |20653|     40|#define WXS_GET_GLOBAL_HASH(c, slot) { \
  |  |20654|     40|    if (WXS_IS_BUCKET_IMPMAIN((c)->type)) \
  |  |  ------------------
  |  |  |  |  199|     40|#define WXS_IS_BUCKET_IMPMAIN(t) (((t) == XML_SCHEMA_SCHEMA_MAIN) || \
  |  |  |  |  ------------------
  |  |  |  |  |  |  371|     40|#define XML_SCHEMA_SCHEMA_MAIN 0
  |  |  |  |  ------------------
  |  |  |  |  |  Branch (199:35): [True: 33, False: 7]
  |  |  |  |  ------------------
  |  |  |  |  200|     40|    ((t) == XML_SCHEMA_SCHEMA_IMPORT))
  |  |  |  |  ------------------
  |  |  |  |  |  |  372|      7|#define XML_SCHEMA_SCHEMA_IMPORT 1
  |  |  |  |  ------------------
  |  |  |  |  |  Branch (200:5): [True: 7, False: 0]
  |  |  |  |  ------------------
  |  |  ------------------
  |  |20655|     40|	table = &(WXS_IMPBUCKET((c))->schema->slot); \
  |  |  ------------------
  |  |  |  |  202|     40|#define WXS_IMPBUCKET(b) ((xmlSchemaImportPtr) (b))
  |  |  ------------------
  |  |20656|     40|    else \
  |  |20657|     40|	table = &(WXS_INCBUCKET((c))->ownerImport->schema->slot); }
  |  |  ------------------
  |  |  |  |  204|      0|#define WXS_INCBUCKET(b) ((xmlSchemaIncludePtr) (b))
  |  |  ------------------
  ------------------
20707|     40|		break;
20708|      6|	    case XML_SCHEMA_TYPE_IDC_KEY:
  ------------------
  |  Branch (20708:6): [True: 6, False: 631]
  ------------------
20709|     11|	    case XML_SCHEMA_TYPE_IDC_UNIQUE:
  ------------------
  |  Branch (20709:6): [True: 5, False: 632]
  ------------------
20710|     15|	    case XML_SCHEMA_TYPE_IDC_KEYREF:
  ------------------
  |  Branch (20710:6): [True: 4, False: 633]
  ------------------
20711|     15|		name = (WXS_IDC_CAST item)->name;
  ------------------
  |  |  135|     15|#define WXS_IDC_CAST (xmlSchemaIDCPtr)
  ------------------
20712|     15|		WXS_GET_GLOBAL_HASH(bucket, idcDef)
  ------------------
  |  |20653|     15|#define WXS_GET_GLOBAL_HASH(c, slot) { \
  |  |20654|     15|    if (WXS_IS_BUCKET_IMPMAIN((c)->type)) \
  |  |  ------------------
  |  |  |  |  199|     15|#define WXS_IS_BUCKET_IMPMAIN(t) (((t) == XML_SCHEMA_SCHEMA_MAIN) || \
  |  |  |  |  ------------------
  |  |  |  |  |  |  371|     15|#define XML_SCHEMA_SCHEMA_MAIN 0
  |  |  |  |  ------------------
  |  |  |  |  |  Branch (199:35): [True: 14, False: 1]
  |  |  |  |  ------------------
  |  |  |  |  200|     15|    ((t) == XML_SCHEMA_SCHEMA_IMPORT))
  |  |  |  |  ------------------
  |  |  |  |  |  |  372|      1|#define XML_SCHEMA_SCHEMA_IMPORT 1
  |  |  |  |  ------------------
  |  |  |  |  |  Branch (200:5): [True: 1, False: 0]
  |  |  |  |  ------------------
  |  |  ------------------
  |  |20655|     15|	table = &(WXS_IMPBUCKET((c))->schema->slot); \
  |  |  ------------------
  |  |  |  |  202|     15|#define WXS_IMPBUCKET(b) ((xmlSchemaImportPtr) (b))
  |  |  ------------------
  |  |20656|     15|    else \
  |  |20657|     15|	table = &(WXS_INCBUCKET((c))->ownerImport->schema->slot); }
  |  |  ------------------
  |  |  |  |  204|      0|#define WXS_INCBUCKET(b) ((xmlSchemaIncludePtr) (b))
  |  |  ------------------
  ------------------
20713|     15|		break;
20714|      0|	    case XML_SCHEMA_TYPE_NOTATION:
  ------------------
  |  Branch (20714:6): [True: 0, False: 637]
  ------------------
20715|      0|		name = ((xmlSchemaNotationPtr) item)->name;
20716|      0|		WXS_GET_GLOBAL_HASH(bucket, notaDecl)
  ------------------
  |  |20653|      0|#define WXS_GET_GLOBAL_HASH(c, slot) { \
  |  |20654|      0|    if (WXS_IS_BUCKET_IMPMAIN((c)->type)) \
  |  |  ------------------
  |  |  |  |  199|      0|#define WXS_IS_BUCKET_IMPMAIN(t) (((t) == XML_SCHEMA_SCHEMA_MAIN) || \
  |  |  |  |  ------------------
  |  |  |  |  |  |  371|      0|#define XML_SCHEMA_SCHEMA_MAIN 0
  |  |  |  |  ------------------
  |  |  |  |  |  Branch (199:35): [True: 0, False: 0]
  |  |  |  |  ------------------
  |  |  |  |  200|      0|    ((t) == XML_SCHEMA_SCHEMA_IMPORT))
  |  |  |  |  ------------------
  |  |  |  |  |  |  372|      0|#define XML_SCHEMA_SCHEMA_IMPORT 1
  |  |  |  |  ------------------
  |  |  |  |  |  Branch (200:5): [True: 0, False: 0]
  |  |  |  |  ------------------
  |  |  ------------------
  |  |20655|      0|	table = &(WXS_IMPBUCKET((c))->schema->slot); \
  |  |  ------------------
  |  |  |  |  202|      0|#define WXS_IMPBUCKET(b) ((xmlSchemaImportPtr) (b))
  |  |  ------------------
  |  |20656|      0|    else \
  |  |20657|      0|	table = &(WXS_INCBUCKET((c))->ownerImport->schema->slot); }
  |  |  ------------------
  |  |  |  |  204|      0|#define WXS_INCBUCKET(b) ((xmlSchemaIncludePtr) (b))
  |  |  ------------------
  ------------------
20717|      0|		break;
20718|      0|	    default:
  ------------------
  |  Branch (20718:6): [True: 0, False: 637]
  ------------------
20719|      0|		PERROR_INT("xmlSchemaAddComponents",
  ------------------
  |  | 2824|      0|#define PERROR_INT(func, msg) xmlSchemaInternalErr(ACTXT_CAST pctxt, func, msg);
  |  |  ------------------
  |  |  |  |  121|      0|#define ACTXT_CAST (xmlSchemaAbstractCtxtPtr)
  |  |  ------------------
  ------------------
20720|      0|		    "Unexpected global component type");
20721|      0|		continue;
20722|    637|	}
20723|    637|	if (*table == NULL) {
  ------------------
  |  Branch (20723:6): [True: 266, False: 371]
  ------------------
20724|    266|	    *table = xmlHashCreateDict(10, pctxt->dict);
20725|    266|	    if (*table == NULL) {
  ------------------
  |  Branch (20725:10): [True: 0, False: 266]
  ------------------
20726|      0|		PERROR_INT("xmlSchemaAddComponents",
  ------------------
  |  | 2824|      0|#define PERROR_INT(func, msg) xmlSchemaInternalErr(ACTXT_CAST pctxt, func, msg);
  |  |  ------------------
  |  |  |  |  121|      0|#define ACTXT_CAST (xmlSchemaAbstractCtxtPtr)
  |  |  ------------------
  ------------------
20727|      0|		    "failed to create a component hash table");
20728|      0|		return(-1);
20729|      0|	    }
20730|    266|	}
20731|    637|	err = xmlHashAddEntry(*table, name, item);
20732|    637|	if (err != 0) {
  ------------------
  |  Branch (20732:6): [True: 1, False: 636]
  ------------------
20733|      1|	    xmlChar *str = NULL;
20734|       |
20735|      1|	    xmlSchemaCustomErr(ACTXT_CAST pctxt,
  ------------------
  |  |  121|      1|#define ACTXT_CAST (xmlSchemaAbstractCtxtPtr)
  ------------------
20736|      1|		XML_SCHEMAP_REDEFINED_TYPE,
20737|      1|		WXS_ITEM_NODE(item),
  ------------------
  |  |  142|      1|#define WXS_ITEM_NODE(i) xmlSchemaGetComponentNode(WXS_BASIC_CAST (i))
  |  |  ------------------
  |  |  |  |  124|      1|#define WXS_BASIC_CAST (xmlSchemaBasicItemPtr)
  |  |  ------------------
  ------------------
20738|      1|		WXS_BASIC_CAST item,
  ------------------
  |  |  124|      1|#define WXS_BASIC_CAST (xmlSchemaBasicItemPtr)
  ------------------
20739|      1|		"A global %s '%s' does already exist",
20740|      1|		WXS_ITEM_TYPE_NAME(item),
  ------------------
  |  |  144|      1|#define WXS_ITEM_TYPE_NAME(i) xmlSchemaGetComponentTypeStr(WXS_BASIC_CAST (i))
  |  |  ------------------
  |  |  |  |  124|      1|#define WXS_BASIC_CAST (xmlSchemaBasicItemPtr)
  |  |  ------------------
  ------------------
20741|      1|		xmlSchemaGetComponentQName(&str, item));
20742|      1|	    FREE_AND_NULL(str);
  ------------------
  |  |  320|      1|#define FREE_AND_NULL(str) if ((str) != NULL) { xmlFree((xmlChar *) (str)); str = NULL; }
  |  |  ------------------
  |  |  |  Branch (320:32): [True: 1, False: 0]
  |  |  ------------------
  ------------------
20743|      1|	}
20744|    637|    }
20745|       |    /*
20746|       |    * Process imported/included schemas.
20747|       |    */
20748|    158|    if (bucket->relations != NULL) {
  ------------------
  |  Branch (20748:9): [True: 21, False: 137]
  ------------------
20749|     21|	xmlSchemaSchemaRelationPtr rel = bucket->relations;
20750|     28|	do {
20751|     28|	    if ((rel->bucket != NULL) &&
  ------------------
  |  Branch (20751:10): [True: 27, False: 1]
  ------------------
20752|     28|		((rel->bucket->flags & XML_SCHEMA_BUCKET_COMPS_ADDED) == 0)) {
  ------------------
  |  |  391|     27|#define XML_SCHEMA_BUCKET_COMPS_ADDED 1<<1
  ------------------
  |  Branch (20752:3): [True: 25, False: 2]
  ------------------
20753|     25|		if (xmlSchemaAddComponents(pctxt, rel->bucket) == -1)
  ------------------
  |  Branch (20753:7): [True: 0, False: 25]
  ------------------
20754|      0|		    return(-1);
20755|     25|	    }
20756|     28|	    rel = rel->next;
20757|     28|	} while (rel != NULL);
  ------------------
  |  Branch (20757:11): [True: 7, False: 21]
  ------------------
20758|     21|    }
20759|    158|    return(0);
20760|    158|}
xmlschemas.c:xmlSchemaResolveElementReferences:
13161|    596|{
13162|    596|    if ((ctxt == NULL) || (elemDecl == NULL) ||
  ------------------
  |  Branch (13162:9): [True: 0, False: 596]
  |  Branch (13162:27): [True: 0, False: 596]
  ------------------
13163|    596|	((elemDecl != NULL) &&
  ------------------
  |  Branch (13163:3): [True: 596, False: 0]
  ------------------
13164|    596|	(elemDecl->flags & XML_SCHEMAS_ELEM_INTERNAL_RESOLVED)))
  ------------------
  |  |  700|    596|#define XML_SCHEMAS_ELEM_INTERNAL_RESOLVED        1 << 8
  ------------------
  |  Branch (13164:2): [True: 26, False: 570]
  ------------------
13165|     26|        return;
13166|    570|    elemDecl->flags |= XML_SCHEMAS_ELEM_INTERNAL_RESOLVED;
  ------------------
  |  |  700|    570|#define XML_SCHEMAS_ELEM_INTERNAL_RESOLVED        1 << 8
  ------------------
13167|       |
13168|    570|    if ((elemDecl->subtypes == NULL) && (elemDecl->namedType != NULL)) {
  ------------------
  |  Branch (13168:9): [True: 354, False: 216]
  |  Branch (13168:41): [True: 254, False: 100]
  ------------------
13169|    254|	xmlSchemaTypePtr type;
13170|       |
13171|       |	/* (type definition) ... otherwise the type definition `resolved`
13172|       |	* to by the `actual value` of the type [attribute] ...
13173|       |	*/
13174|    254|	type = xmlSchemaGetType(ctxt->schema, elemDecl->namedType,
13175|    254|	    elemDecl->namedTypeNs);
13176|    254|	if (type == NULL) {
  ------------------
  |  Branch (13176:6): [True: 1, False: 253]
  ------------------
13177|      1|	    xmlSchemaPResCompAttrErr(ctxt,
13178|      1|		XML_SCHEMAP_SRC_RESOLVE,
13179|      1|		WXS_BASIC_CAST elemDecl, elemDecl->node,
  ------------------
  |  |  124|      1|#define WXS_BASIC_CAST (xmlSchemaBasicItemPtr)
  ------------------
13180|      1|		"type", elemDecl->namedType, elemDecl->namedTypeNs,
13181|      1|		XML_SCHEMA_TYPE_BASIC, "type definition");
13182|      1|	} else
13183|    253|	    elemDecl->subtypes = type;
13184|    254|    }
13185|    570|    if (elemDecl->substGroup != NULL) {
  ------------------
  |  Branch (13185:9): [True: 26, False: 544]
  ------------------
13186|     26|	xmlSchemaElementPtr substHead;
13187|       |
13188|       |	/*
13189|       |	* FIXME TODO: Do we need a new field in _xmlSchemaElement for
13190|       |	* substitutionGroup?
13191|       |	*/
13192|     26|	substHead = xmlSchemaGetElem(ctxt->schema, elemDecl->substGroup,
13193|     26|	    elemDecl->substGroupNs);
13194|     26|	if (substHead == NULL) {
  ------------------
  |  Branch (13194:6): [True: 0, False: 26]
  ------------------
13195|      0|	    xmlSchemaPResCompAttrErr(ctxt,
13196|      0|		XML_SCHEMAP_SRC_RESOLVE,
13197|      0|		WXS_BASIC_CAST elemDecl, NULL,
  ------------------
  |  |  124|      0|#define WXS_BASIC_CAST (xmlSchemaBasicItemPtr)
  ------------------
13198|      0|		"substitutionGroup", elemDecl->substGroup,
13199|      0|		elemDecl->substGroupNs, XML_SCHEMA_TYPE_ELEMENT, NULL);
13200|     26|	} else {
13201|     26|	    xmlSchemaResolveElementReferences(substHead, ctxt);
13202|       |	    /*
13203|       |	    * Set the "substitution group affiliation".
13204|       |	    * NOTE that now we use the "refDecl" field for this.
13205|       |	    */
13206|     26|	    WXS_SUBST_HEAD(elemDecl) = substHead;
  ------------------
  |  |  150|     26|#define WXS_SUBST_HEAD(item) (item)->refDecl
  ------------------
13207|       |	    /*
13208|       |	    * The type definitions is set to:
13209|       |	    * SPEC "...the {type definition} of the element
13210|       |	    * declaration `resolved` to by the `actual value`
13211|       |	    * of the substitutionGroup [attribute], if present"
13212|       |	    */
13213|     26|	    if (elemDecl->subtypes == NULL) {
  ------------------
  |  Branch (13213:10): [True: 24, False: 2]
  ------------------
13214|     24|                if (substHead->subtypes == NULL) {
  ------------------
  |  Branch (13214:21): [True: 1, False: 23]
  ------------------
13215|       |                    /*
13216|       |                     * This can happen with self-referencing substitution
13217|       |                     * groups. The cycle will be detected later, but we have
13218|       |                     * to set subtypes to avoid null-pointer dereferences.
13219|       |                     */
13220|      1|	            elemDecl->subtypes = xmlSchemaGetBuiltInType(
13221|      1|                            XML_SCHEMAS_ANYTYPE);
13222|     23|                } else {
13223|     23|		    elemDecl->subtypes = substHead->subtypes;
13224|     23|                }
13225|     24|            }
13226|     26|	}
13227|     26|    }
13228|       |    /*
13229|       |    * SPEC "The definition of anyType serves as the default type definition
13230|       |    * for element declarations whose XML representation does not specify one."
13231|       |    */
13232|    570|    if ((elemDecl->subtypes == NULL) &&
  ------------------
  |  Branch (13232:9): [True: 77, False: 493]
  ------------------
13233|    570|	(elemDecl->namedType == NULL) &&
  ------------------
  |  Branch (13233:2): [True: 76, False: 1]
  ------------------
13234|    570|	(elemDecl->substGroup == NULL))
  ------------------
  |  Branch (13234:2): [True: 76, False: 0]
  ------------------
13235|     76|	elemDecl->subtypes = xmlSchemaGetBuiltInType(XML_SCHEMAS_ANYTYPE);
13236|    570|}
xmlschemas.c:xmlSchemaGetType:
 4774|    692|{
 4775|    692|    xmlSchemaTypePtr ret = NULL;
 4776|       |
 4777|    692|    if (name == NULL)
  ------------------
  |  Branch (4777:9): [True: 0, False: 692]
  ------------------
 4778|      0|        return (NULL);
 4779|       |    /* First try the built-in types. */
 4780|    692|    if ((nsName != NULL) && xmlStrEqual(nsName, xmlSchemaNs)) {
  ------------------
  |  Branch (4780:9): [True: 573, False: 119]
  |  Branch (4780:29): [True: 405, False: 168]
  ------------------
 4781|    405|	ret = xmlSchemaGetPredefinedType(name, nsName);
 4782|    405|	if (ret != NULL)
  ------------------
  |  Branch (4782:6): [True: 404, False: 1]
  ------------------
 4783|    404|	    goto exit;
 4784|       |	/*
 4785|       |	* Note that we try the parsed schemas as well here
 4786|       |	* since one might have parsed the S4S, which contain more
 4787|       |	* than the built-in types.
 4788|       |	* TODO: Can we optimize this?
 4789|       |	*/
 4790|    405|    }
 4791|    288|    if (schema != NULL) {
  ------------------
  |  Branch (4791:9): [True: 288, False: 0]
  ------------------
 4792|    288|	WXS_FIND_GLOBAL_ITEM(typeDecl)
  ------------------
  |  | 4720|    288|    if (xmlStrEqual(nsName, schema->targetNamespace)) { \
  |  |  ------------------
  |  |  |  Branch (4720:9): [True: 276, False: 12]
  |  |  ------------------
  |  | 4721|    276|	ret = xmlHashLookup(schema->slot, name); \
  |  | 4722|    276|	if (ret != NULL) goto exit; \
  |  |  ------------------
  |  |  |  Branch (4722:6): [True: 276, False: 0]
  |  |  ------------------
  |  | 4723|    276|    } \
  |  | 4724|    288|    if (xmlHashSize(schema->schemasImports) > 1) { \
  |  |  ------------------
  |  |  |  Branch (4724:9): [True: 11, False: 1]
  |  |  ------------------
  |  | 4725|     11|	xmlSchemaImportPtr import; \
  |  | 4726|     11|	if (nsName == NULL) \
  |  |  ------------------
  |  |  |  Branch (4726:6): [True: 6, False: 5]
  |  |  ------------------
  |  | 4727|     11|	    import = xmlHashLookup(schema->schemasImports, \
  |  | 4728|      6|		XML_SCHEMAS_NO_NAMESPACE); \
  |  |  ------------------
  |  |  |  |  104|      6|#define XML_SCHEMAS_NO_NAMESPACE (const xmlChar *) "##"
  |  |  ------------------
  |  | 4729|     11|	else \
  |  | 4730|     11|	    import = xmlHashLookup(schema->schemasImports, nsName); \
  |  | 4731|     11|	if (import == NULL) \
  |  |  ------------------
  |  |  |  Branch (4731:6): [True: 0, False: 11]
  |  |  ------------------
  |  | 4732|     11|	    goto exit; \
  |  | 4733|     11|	ret = xmlHashLookup(import->schema->slot, name); \
  |  | 4734|     11|    }
  ------------------
 4793|     12|    }
 4794|    692|exit:
 4795|       |
 4796|    692|    return (ret);
 4797|    288|}
xmlschemas.c:xmlSchemaPResCompAttrErr:
 2886|     11|{
 2887|     11|    xmlChar *des = NULL, *strA = NULL;
 2888|       |
 2889|     11|    xmlSchemaFormatItemForReport(&des, NULL, ownerItem, ownerElem);
 2890|     11|    if (refTypeStr == NULL)
  ------------------
  |  Branch (2890:9): [True: 10, False: 1]
  ------------------
 2891|     10|	refTypeStr = (const char *) xmlSchemaItemTypeToStr(refType);
 2892|     11|    xmlSchemaPErrExt(ctxt, ownerElem, error,
 2893|     11|	    NULL, NULL, NULL,
 2894|     11|	    "%s, attribute '%s': The QName value '%s' does not resolve to a(n) "
 2895|     11|	    "%s.\n", BAD_CAST des, BAD_CAST name,
  ------------------
  |  |   35|     11|#define BAD_CAST (xmlChar *)
  ------------------
              	    "%s.\n", BAD_CAST des, BAD_CAST name,
  ------------------
  |  |   35|     11|#define BAD_CAST (xmlChar *)
  ------------------
 2896|     11|	    xmlSchemaFormatQName(&strA, refURI, refName),
 2897|     11|	    BAD_CAST refTypeStr, NULL);
  ------------------
  |  |   35|     11|#define BAD_CAST (xmlChar *)
  ------------------
 2898|     11|    FREE_AND_NULL(des)
  ------------------
  |  |  320|     11|#define FREE_AND_NULL(str) if ((str) != NULL) { xmlFree((xmlChar *) (str)); str = NULL; }
  |  |  ------------------
  |  |  |  Branch (320:32): [True: 11, False: 0]
  |  |  ------------------
  ------------------
 2899|     11|    FREE_AND_NULL(strA)
  ------------------
  |  |  320|     11|#define FREE_AND_NULL(str) if ((str) != NULL) { xmlFree((xmlChar *) (str)); str = NULL; }
  |  |  ------------------
  |  |  |  Branch (320:32): [True: 1, False: 10]
  |  |  ------------------
  ------------------
 2900|     11|}
xmlschemas.c:xmlSchemaGetElem:
 4749|    226|{
 4750|    226|    xmlSchemaElementPtr ret = NULL;
 4751|       |
 4752|    226|    if ((name == NULL) || (schema == NULL))
  ------------------
  |  Branch (4752:9): [True: 0, False: 226]
  |  Branch (4752:27): [True: 0, False: 226]
  ------------------
 4753|      0|        return(NULL);
 4754|    226|    if (schema != NULL) {
  ------------------
  |  Branch (4754:9): [True: 226, False: 0]
  ------------------
 4755|    226|	WXS_FIND_GLOBAL_ITEM(elemDecl)
  ------------------
  |  | 4720|    226|    if (xmlStrEqual(nsName, schema->targetNamespace)) { \
  |  |  ------------------
  |  |  |  Branch (4720:9): [True: 202, False: 24]
  |  |  ------------------
  |  | 4721|    202|	ret = xmlHashLookup(schema->slot, name); \
  |  | 4722|    202|	if (ret != NULL) goto exit; \
  |  |  ------------------
  |  |  |  Branch (4722:6): [True: 194, False: 8]
  |  |  ------------------
  |  | 4723|    202|    } \
  |  | 4724|    226|    if (xmlHashSize(schema->schemasImports) > 1) { \
  |  |  ------------------
  |  |  |  Branch (4724:9): [True: 24, False: 8]
  |  |  ------------------
  |  | 4725|     24|	xmlSchemaImportPtr import; \
  |  | 4726|     24|	if (nsName == NULL) \
  |  |  ------------------
  |  |  |  Branch (4726:6): [True: 0, False: 24]
  |  |  ------------------
  |  | 4727|     24|	    import = xmlHashLookup(schema->schemasImports, \
  |  | 4728|      0|		XML_SCHEMAS_NO_NAMESPACE); \
  |  |  ------------------
  |  |  |  |  104|      0|#define XML_SCHEMAS_NO_NAMESPACE (const xmlChar *) "##"
  |  |  ------------------
  |  | 4729|     24|	else \
  |  | 4730|     24|	    import = xmlHashLookup(schema->schemasImports, nsName); \
  |  | 4731|     24|	if (import == NULL) \
  |  |  ------------------
  |  |  |  Branch (4731:6): [True: 0, False: 24]
  |  |  ------------------
  |  | 4732|     24|	    goto exit; \
  |  | 4733|     24|	ret = xmlHashLookup(import->schema->slot, name); \
  |  | 4734|     24|    }
  ------------------
 4756|     32|    }
 4757|    226|exit:
 4758|    226|    return (ret);
 4759|    226|}
xmlschemas.c:xmlSchemaResolveTypeReferences:
15032|    525|{
15033|    525|    if (typeDef == NULL)
  ------------------
  |  Branch (15033:9): [True: 0, False: 525]
  ------------------
15034|      0|	return;
15035|       |
15036|       |    /*
15037|       |    * Resolve the base type.
15038|       |    */
15039|    525|    if (typeDef->baseType == NULL) {
  ------------------
  |  Branch (15039:9): [True: 217, False: 308]
  ------------------
15040|    217|	typeDef->baseType = xmlSchemaGetType(ctxt->schema,
15041|    217|	    typeDef->base, typeDef->baseNs);
15042|    217|	if (typeDef->baseType == NULL) {
  ------------------
  |  Branch (15042:6): [True: 0, False: 217]
  ------------------
15043|      0|	    xmlSchemaPResCompAttrErr(ctxt,
15044|      0|		XML_SCHEMAP_SRC_RESOLVE,
15045|      0|		WXS_BASIC_CAST typeDef, typeDef->node,
  ------------------
  |  |  124|      0|#define WXS_BASIC_CAST (xmlSchemaBasicItemPtr)
  ------------------
15046|      0|		"base", typeDef->base, typeDef->baseNs,
15047|      0|		XML_SCHEMA_TYPE_SIMPLE, NULL);
15048|      0|	    return;
15049|      0|	}
15050|    217|    }
15051|    525|    if (WXS_IS_SIMPLE(typeDef)) {
  ------------------
  |  |  217|    525|    ((item->type == XML_SCHEMA_TYPE_SIMPLE) || \
  |  |  ------------------
  |  |  |  Branch (217:6): [True: 160, False: 365]
  |  |  ------------------
  |  |  218|    525|     ((item->type == XML_SCHEMA_TYPE_BASIC) && \
  |  |  ------------------
  |  |  |  Branch (218:7): [True: 0, False: 365]
  |  |  ------------------
  |  |  219|    365|      (item->builtInType != XML_SCHEMAS_ANYTYPE)))
  |  |  ------------------
  |  |  |  Branch (219:7): [True: 0, False: 0]
  |  |  ------------------
  ------------------
15052|    160|	if (WXS_IS_UNION(typeDef)) {
  ------------------
  |  |  274|    160|#define WXS_IS_UNION(t) (t->flags & XML_SCHEMAS_TYPE_VARIETY_UNION)
  |  |  ------------------
  |  |  |  |  454|    160|#define XML_SCHEMAS_TYPE_VARIETY_UNION    1 << 7
  |  |  ------------------
  |  |  |  Branch (274:25): [True: 25, False: 135]
  |  |  ------------------
  ------------------
15053|       |	    /*
15054|       |	    * Resolve the memberTypes.
15055|       |	    */
15056|     25|	    xmlSchemaResolveUnionMemberTypes(ctxt, typeDef);
15057|     25|	    return;
15058|    135|	} else if (WXS_IS_LIST(typeDef)) {
  ------------------
  |  |  272|    135|#define WXS_IS_LIST(t) (t->flags & XML_SCHEMAS_TYPE_VARIETY_LIST)
  |  |  ------------------
  |  |  |  |  448|    135|#define XML_SCHEMAS_TYPE_VARIETY_LIST    1 << 6
  |  |  ------------------
  |  |  |  Branch (272:24): [True: 11, False: 124]
  |  |  ------------------
  ------------------
15059|       |	    /*
15060|       |	    * Resolve the itemType.
15061|       |	    */
15062|     11|	    if ((typeDef->subtypes == NULL) && (typeDef->base != NULL)) {
  ------------------
  |  Branch (15062:10): [True: 4, False: 7]
  |  Branch (15062:41): [True: 4, False: 0]
  ------------------
15063|       |
15064|      4|		typeDef->subtypes = xmlSchemaGetType(ctxt->schema,
15065|      4|		    typeDef->base, typeDef->baseNs);
15066|       |
15067|      4|		if ((typeDef->subtypes == NULL) ||
  ------------------
  |  Branch (15067:7): [True: 0, False: 4]
  ------------------
15068|      4|		    (! WXS_IS_SIMPLE(typeDef->subtypes)))
  ------------------
  |  |  217|      4|    ((item->type == XML_SCHEMA_TYPE_SIMPLE) || \
  |  |  ------------------
  |  |  |  Branch (217:6): [True: 1, False: 3]
  |  |  ------------------
  |  |  218|      4|     ((item->type == XML_SCHEMA_TYPE_BASIC) && \
  |  |  ------------------
  |  |  |  Branch (218:7): [True: 3, False: 0]
  |  |  ------------------
  |  |  219|      3|      (item->builtInType != XML_SCHEMAS_ANYTYPE)))
  |  |  ------------------
  |  |  |  Branch (219:7): [True: 3, False: 0]
  |  |  ------------------
  ------------------
15069|      0|		{
15070|      0|		    typeDef->subtypes = NULL;
15071|      0|		    xmlSchemaPResCompAttrErr(ctxt,
15072|      0|			XML_SCHEMAP_SRC_RESOLVE,
15073|      0|			WXS_BASIC_CAST typeDef, typeDef->node,
  ------------------
  |  |  124|      0|#define WXS_BASIC_CAST (xmlSchemaBasicItemPtr)
  ------------------
15074|      0|			"itemType", typeDef->base, typeDef->baseNs,
15075|      0|			XML_SCHEMA_TYPE_SIMPLE, NULL);
15076|      0|		}
15077|      4|	    }
15078|     11|	    return;
15079|     11|	}
15080|    160|    }
15081|       |    /*
15082|       |    * The ball of letters below means, that if we have a particle
15083|       |    * which has a QName-helper component as its {term}, we want
15084|       |    * to resolve it...
15085|       |    */
15086|    365|    else if ((WXS_TYPE_CONTENTTYPE(typeDef) != NULL) &&
  ------------------
  |  |  260|    365|#define WXS_TYPE_CONTENTTYPE(t) (t)->subtypes
  ------------------
  |  Branch (15086:14): [True: 187, False: 178]
  ------------------
15087|    365|	((WXS_TYPE_CONTENTTYPE(typeDef))->type ==
  ------------------
  |  |  260|    187|#define WXS_TYPE_CONTENTTYPE(t) (t)->subtypes
  ------------------
  |  Branch (15087:2): [True: 187, False: 0]
  ------------------
15088|    187|	    XML_SCHEMA_TYPE_PARTICLE) &&
15089|    365|	(WXS_TYPE_PARTICLE_TERM(typeDef) != NULL) &&
  ------------------
  |  |  264|    187|#define WXS_TYPE_PARTICLE_TERM(t) WXS_PARTICLE_TERM(WXS_TYPE_PARTICLE(t))
  |  |  ------------------
  |  |  |  |  175|    187|#define WXS_PARTICLE_TERM(p) (WXS_PARTICLE(p))->children
  |  |  |  |  ------------------
  |  |  |  |  |  |  173|    187|#define WXS_PARTICLE(p) WXS_PTC_CAST (p)
  |  |  |  |  |  |  ------------------
  |  |  |  |  |  |  |  |  126|    187|#define WXS_PTC_CAST (xmlSchemaParticlePtr)
  |  |  |  |  |  |  ------------------
  |  |  |  |  ------------------
  |  |  ------------------
  ------------------
  |  Branch (15089:2): [True: 187, False: 0]
  ------------------
15090|    365|	((WXS_TYPE_PARTICLE_TERM(typeDef))->type ==
  ------------------
  |  |  264|    187|#define WXS_TYPE_PARTICLE_TERM(t) WXS_PARTICLE_TERM(WXS_TYPE_PARTICLE(t))
  |  |  ------------------
  |  |  |  |  175|    187|#define WXS_PARTICLE_TERM(p) (WXS_PARTICLE(p))->children
  |  |  |  |  ------------------
  |  |  |  |  |  |  173|    187|#define WXS_PARTICLE(p) WXS_PTC_CAST (p)
  |  |  |  |  |  |  ------------------
  |  |  |  |  |  |  |  |  126|    187|#define WXS_PTC_CAST (xmlSchemaParticlePtr)
  |  |  |  |  |  |  ------------------
  |  |  |  |  ------------------
  |  |  ------------------
  ------------------
  |  Branch (15090:2): [True: 4, False: 183]
  ------------------
15091|    187|	    XML_SCHEMA_EXTRA_QNAMEREF))
15092|      4|    {
15093|      4|	xmlSchemaQNameRefPtr ref =
15094|      4|	    WXS_QNAME_CAST WXS_TYPE_PARTICLE_TERM(typeDef);
  ------------------
  |  |  136|      4|#define WXS_QNAME_CAST (xmlSchemaQNameRefPtr)
  ------------------
              	    WXS_QNAME_CAST WXS_TYPE_PARTICLE_TERM(typeDef);
  ------------------
  |  |  264|      4|#define WXS_TYPE_PARTICLE_TERM(t) WXS_PARTICLE_TERM(WXS_TYPE_PARTICLE(t))
  |  |  ------------------
  |  |  |  |  175|      4|#define WXS_PARTICLE_TERM(p) (WXS_PARTICLE(p))->children
  |  |  |  |  ------------------
  |  |  |  |  |  |  173|      4|#define WXS_PARTICLE(p) WXS_PTC_CAST (p)
  |  |  |  |  |  |  ------------------
  |  |  |  |  |  |  |  |  126|      4|#define WXS_PTC_CAST (xmlSchemaParticlePtr)
  |  |  |  |  |  |  ------------------
  |  |  |  |  ------------------
  |  |  ------------------
  ------------------
15095|      4|	xmlSchemaModelGroupDefPtr groupDef;
15096|       |
15097|       |	/*
15098|       |	* URGENT TODO: Test this.
15099|       |	*/
15100|      4|	WXS_TYPE_PARTICLE_TERM(typeDef) = NULL;
  ------------------
  |  |  264|      4|#define WXS_TYPE_PARTICLE_TERM(t) WXS_PARTICLE_TERM(WXS_TYPE_PARTICLE(t))
  |  |  ------------------
  |  |  |  |  175|      4|#define WXS_PARTICLE_TERM(p) (WXS_PARTICLE(p))->children
  |  |  |  |  ------------------
  |  |  |  |  |  |  173|      4|#define WXS_PARTICLE(p) WXS_PTC_CAST (p)
  |  |  |  |  |  |  ------------------
  |  |  |  |  |  |  |  |  126|      4|#define WXS_PTC_CAST (xmlSchemaParticlePtr)
  |  |  |  |  |  |  ------------------
  |  |  |  |  ------------------
  |  |  ------------------
  ------------------
15101|       |	/*
15102|       |	* Resolve the MG definition reference.
15103|       |	*/
15104|      4|	groupDef =
15105|      4|	    WXS_MODEL_GROUPDEF_CAST xmlSchemaGetNamedComponent(ctxt->schema,
  ------------------
  |  |  133|      4|#define WXS_MODEL_GROUPDEF_CAST (xmlSchemaModelGroupDefPtr)
  ------------------
15106|      4|		ref->itemType, ref->name, ref->targetNamespace);
15107|      4|	if (groupDef == NULL) {
  ------------------
  |  Branch (15107:6): [True: 0, False: 4]
  ------------------
15108|      0|	    xmlSchemaPResCompAttrErr(ctxt, XML_SCHEMAP_SRC_RESOLVE,
15109|      0|		NULL, WXS_ITEM_NODE(WXS_TYPE_PARTICLE(typeDef)),
  ------------------
  |  |  142|      0|#define WXS_ITEM_NODE(i) xmlSchemaGetComponentNode(WXS_BASIC_CAST (i))
  |  |  ------------------
  |  |  |  |  124|      0|#define WXS_BASIC_CAST (xmlSchemaBasicItemPtr)
  |  |  ------------------
  ------------------
15110|      0|		"ref", ref->name, ref->targetNamespace, ref->itemType,
15111|      0|		NULL);
15112|       |	    /* Remove the particle. */
15113|      0|	    WXS_TYPE_CONTENTTYPE(typeDef) = NULL;
  ------------------
  |  |  260|      0|#define WXS_TYPE_CONTENTTYPE(t) (t)->subtypes
  ------------------
15114|      4|	} else if (WXS_MODELGROUPDEF_MODEL(groupDef) == NULL)
  ------------------
  |  |  183|      4|#define WXS_MODELGROUPDEF_MODEL(mgd) (WXS_MODEL_GROUP_CAST (mgd))->children
  |  |  ------------------
  |  |  |  |  134|      4|#define WXS_MODEL_GROUP_CAST (xmlSchemaModelGroupPtr)
  |  |  ------------------
  ------------------
  |  Branch (15114:13): [True: 0, False: 4]
  ------------------
15115|       |	    /* Remove the particle. */
15116|      0|	    WXS_TYPE_CONTENTTYPE(typeDef) = NULL;
  ------------------
  |  |  260|      0|#define WXS_TYPE_CONTENTTYPE(t) (t)->subtypes
  ------------------
15117|      4|	else {
15118|       |	    /*
15119|       |	    * Assign the MG definition's {model group} to the
15120|       |	    * particle's {term}.
15121|       |	    */
15122|      4|	    WXS_TYPE_PARTICLE_TERM(typeDef) = WXS_MODELGROUPDEF_MODEL(groupDef);
  ------------------
  |  |  264|      4|#define WXS_TYPE_PARTICLE_TERM(t) WXS_PARTICLE_TERM(WXS_TYPE_PARTICLE(t))
  |  |  ------------------
  |  |  |  |  175|      4|#define WXS_PARTICLE_TERM(p) (WXS_PARTICLE(p))->children
  |  |  |  |  ------------------
  |  |  |  |  |  |  173|      4|#define WXS_PARTICLE(p) WXS_PTC_CAST (p)
  |  |  |  |  |  |  ------------------
  |  |  |  |  |  |  |  |  126|      4|#define WXS_PTC_CAST (xmlSchemaParticlePtr)
  |  |  |  |  |  |  ------------------
  |  |  |  |  ------------------
  |  |  ------------------
  ------------------
              	    WXS_TYPE_PARTICLE_TERM(typeDef) = WXS_MODELGROUPDEF_MODEL(groupDef);
  ------------------
  |  |  183|      4|#define WXS_MODELGROUPDEF_MODEL(mgd) (WXS_MODEL_GROUP_CAST (mgd))->children
  |  |  ------------------
  |  |  |  |  134|      4|#define WXS_MODEL_GROUP_CAST (xmlSchemaModelGroupPtr)
  |  |  ------------------
  ------------------
15123|       |
15124|      4|	    if (WXS_MODELGROUPDEF_MODEL(groupDef)->type == XML_SCHEMA_TYPE_ALL) {
  ------------------
  |  |  183|      4|#define WXS_MODELGROUPDEF_MODEL(mgd) (WXS_MODEL_GROUP_CAST (mgd))->children
  |  |  ------------------
  |  |  |  |  134|      4|#define WXS_MODEL_GROUP_CAST (xmlSchemaModelGroupPtr)
  |  |  ------------------
  ------------------
  |  Branch (15124:10): [True: 0, False: 4]
  ------------------
15125|       |		/*
15126|       |		* SPEC cos-all-limited (1.2)
15127|       |		* "1.2 the {term} property of a particle with
15128|       |		* {max occurs}=1 which is part of a pair which constitutes
15129|       |		* the {content type} of a complex type definition."
15130|       |		*/
15131|      0|		if ((WXS_TYPE_PARTICLE(typeDef))->maxOccurs != 1) {
  ------------------
  |  |  262|      0|#define WXS_TYPE_PARTICLE(t) WXS_PTC_CAST (t)->subtypes
  |  |  ------------------
  |  |  |  |  126|      0|#define WXS_PTC_CAST (xmlSchemaParticlePtr)
  |  |  ------------------
  ------------------
  |  Branch (15131:7): [True: 0, False: 0]
  ------------------
15132|      0|		    xmlSchemaCustomErr(ACTXT_CAST ctxt,
  ------------------
  |  |  121|      0|#define ACTXT_CAST (xmlSchemaAbstractCtxtPtr)
  ------------------
15133|       |			/* TODO: error code */
15134|      0|			XML_SCHEMAP_COS_ALL_LIMITED,
15135|      0|			WXS_ITEM_NODE(WXS_TYPE_PARTICLE(typeDef)), NULL,
  ------------------
  |  |  142|      0|#define WXS_ITEM_NODE(i) xmlSchemaGetComponentNode(WXS_BASIC_CAST (i))
  |  |  ------------------
  |  |  |  |  124|      0|#define WXS_BASIC_CAST (xmlSchemaBasicItemPtr)
  |  |  ------------------
  ------------------
15136|      0|			"The particle's {max occurs} must be 1, since the "
15137|      0|			"reference resolves to an 'all' model group",
15138|      0|			NULL, NULL);
15139|      0|		}
15140|      0|	    }
15141|      4|	}
15142|      4|    }
15143|    525|}
xmlschemas.c:xmlSchemaResolveUnionMemberTypes:
13252|     25|{
13253|       |
13254|     25|    xmlSchemaTypeLinkPtr link, lastLink, newLink;
13255|     25|    xmlSchemaTypePtr memberType;
13256|       |
13257|       |    /*
13258|       |    * SPEC (1) "If the <union> alternative is chosen, then [Definition:]
13259|       |    * define the explicit members as the type definitions `resolved`
13260|       |    * to by the items in the `actual value` of the memberTypes [attribute],
13261|       |    * if any, followed by the type definitions corresponding to the
13262|       |    * <simpleType>s among the [children] of <union>, if any."
13263|       |    */
13264|       |    /*
13265|       |    * Resolve references.
13266|       |    */
13267|     25|    link = type->memberTypes;
13268|     25|    lastLink = NULL;
13269|     76|    while (link != NULL) {
  ------------------
  |  Branch (13269:12): [True: 51, False: 25]
  ------------------
13270|     51|	const xmlChar *name, *nsName;
13271|       |
13272|     51|	name = ((xmlSchemaQNameRefPtr) link->type)->name;
13273|     51|	nsName = ((xmlSchemaQNameRefPtr) link->type)->targetNamespace;
13274|       |
13275|     51|	memberType = xmlSchemaGetType(ctxt->schema, name, nsName);
13276|     51|	if ((memberType == NULL) || (! WXS_IS_SIMPLE(memberType))) {
  ------------------
  |  |  217|     51|    ((item->type == XML_SCHEMA_TYPE_SIMPLE) || \
  |  |  ------------------
  |  |  |  Branch (217:6): [True: 4, False: 47]
  |  |  ------------------
  |  |  218|     51|     ((item->type == XML_SCHEMA_TYPE_BASIC) && \
  |  |  ------------------
  |  |  |  Branch (218:7): [True: 47, False: 0]
  |  |  ------------------
  |  |  219|     47|      (item->builtInType != XML_SCHEMAS_ANYTYPE)))
  |  |  ------------------
  |  |  |  Branch (219:7): [True: 47, False: 0]
  |  |  ------------------
  ------------------
  |  Branch (13276:6): [True: 0, False: 51]
  ------------------
13277|      0|	    xmlSchemaPResCompAttrErr(ctxt, XML_SCHEMAP_SRC_RESOLVE,
13278|      0|		WXS_BASIC_CAST type, type->node, "memberTypes",
  ------------------
  |  |  124|      0|#define WXS_BASIC_CAST (xmlSchemaBasicItemPtr)
  ------------------
13279|      0|		name, nsName, XML_SCHEMA_TYPE_SIMPLE, NULL);
13280|       |	    /*
13281|       |	    * Remove the member type link.
13282|       |	    */
13283|      0|	    if (lastLink == NULL)
  ------------------
  |  Branch (13283:10): [True: 0, False: 0]
  ------------------
13284|      0|		type->memberTypes = link->next;
13285|      0|	    else
13286|      0|		lastLink->next = link->next;
13287|      0|	    newLink = link;
13288|      0|	    link = link->next;
13289|      0|	    xmlFree(newLink);
13290|     51|	} else {
13291|     51|	    link->type = memberType;
13292|     51|	    lastLink = link;
13293|     51|	    link = link->next;
13294|     51|	}
13295|     51|    }
13296|       |    /*
13297|       |    * Add local simple types,
13298|       |    */
13299|     25|    memberType = type->subtypes;
13300|     43|    while (memberType != NULL) {
  ------------------
  |  Branch (13300:12): [True: 18, False: 25]
  ------------------
13301|     18|	link = (xmlSchemaTypeLinkPtr) xmlMalloc(sizeof(xmlSchemaTypeLink));
13302|     18|	if (link == NULL) {
  ------------------
  |  Branch (13302:6): [True: 0, False: 18]
  ------------------
13303|      0|	    xmlSchemaPErrMemory(ctxt, "allocating a type link", NULL);
13304|      0|	    return (-1);
13305|      0|	}
13306|     18|	link->type = memberType;
13307|     18|	link->next = NULL;
13308|     18|	if (lastLink == NULL)
  ------------------
  |  Branch (13308:6): [True: 6, False: 12]
  ------------------
13309|      6|	    type->memberTypes = link;
13310|     12|	else
13311|     12|	    lastLink->next = link;
13312|     18|	lastLink = link;
13313|     18|	memberType = memberType->next;
13314|     18|    }
13315|     25|    return (0);
13316|     25|}
xmlschemas.c:xmlSchemaGetNamedComponent:
 4928|    209|{
 4929|    209|    switch (itemType) {
 4930|      9|	case XML_SCHEMA_TYPE_GROUP:
  ------------------
  |  Branch (4930:2): [True: 9, False: 200]
  ------------------
 4931|      9|	    return ((xmlSchemaBasicItemPtr) xmlSchemaGetGroup(schema,
 4932|      9|		name, targetNs));
 4933|    200|	case XML_SCHEMA_TYPE_ELEMENT:
  ------------------
  |  Branch (4933:2): [True: 200, False: 9]
  ------------------
 4934|    200|	    return ((xmlSchemaBasicItemPtr) xmlSchemaGetElem(schema,
 4935|    200|		name, targetNs));
 4936|      0|	default:
  ------------------
  |  Branch (4936:2): [True: 0, False: 209]
  ------------------
 4937|      0|	    TODO
  ------------------
  |  |  100|      0|    xmlGenericError(xmlGenericErrorContext,				\
  |  |  ------------------
  |  |  |  |  875|      0|  #define xmlGenericError XML_GLOBAL_MACRO(xmlGenericError)
  |  |  |  |  ------------------
  |  |  |  |  |  |  500|      0|  #define XML_GLOBAL_MACRO(name) (*__##name())
  |  |  |  |  ------------------
  |  |  ------------------
  |  |                   xmlGenericError(xmlGenericErrorContext,				\
  |  |  ------------------
  |  |  |  |  876|      0|  #define xmlGenericErrorContext XML_GLOBAL_MACRO(xmlGenericErrorContext)
  |  |  |  |  ------------------
  |  |  |  |  |  |  500|      0|  #define XML_GLOBAL_MACRO(name) (*__##name())
  |  |  |  |  ------------------
  |  |  ------------------
  |  |  101|      0|	    "Unimplemented block at %s:%d\n",				\
  |  |  102|      0|            __FILE__, __LINE__);
  ------------------
 4938|      0|	    return (NULL);
 4939|    209|    }
 4940|    209|}
xmlschemas.c:xmlSchemaGetGroup:
 4868|      9|{
 4869|      9|    xmlSchemaModelGroupDefPtr ret = NULL;
 4870|       |
 4871|      9|    if ((name == NULL) || (schema == NULL))
  ------------------
  |  Branch (4871:9): [True: 0, False: 9]
  |  Branch (4871:27): [True: 0, False: 9]
  ------------------
 4872|      0|        return (NULL);
 4873|      9|    if (schema != NULL) {
  ------------------
  |  Branch (4873:9): [True: 9, False: 0]
  ------------------
 4874|      9|	WXS_FIND_GLOBAL_ITEM(groupDecl)
  ------------------
  |  | 4720|      9|    if (xmlStrEqual(nsName, schema->targetNamespace)) { \
  |  |  ------------------
  |  |  |  Branch (4720:9): [True: 6, False: 3]
  |  |  ------------------
  |  | 4721|      6|	ret = xmlHashLookup(schema->slot, name); \
  |  | 4722|      6|	if (ret != NULL) goto exit; \
  |  |  ------------------
  |  |  |  Branch (4722:6): [True: 6, False: 0]
  |  |  ------------------
  |  | 4723|      6|    } \
  |  | 4724|      9|    if (xmlHashSize(schema->schemasImports) > 1) { \
  |  |  ------------------
  |  |  |  Branch (4724:9): [True: 3, False: 0]
  |  |  ------------------
  |  | 4725|      3|	xmlSchemaImportPtr import; \
  |  | 4726|      3|	if (nsName == NULL) \
  |  |  ------------------
  |  |  |  Branch (4726:6): [True: 0, False: 3]
  |  |  ------------------
  |  | 4727|      3|	    import = xmlHashLookup(schema->schemasImports, \
  |  | 4728|      0|		XML_SCHEMAS_NO_NAMESPACE); \
  |  |  ------------------
  |  |  |  |  104|      0|#define XML_SCHEMAS_NO_NAMESPACE (const xmlChar *) "##"
  |  |  ------------------
  |  | 4729|      3|	else \
  |  | 4730|      3|	    import = xmlHashLookup(schema->schemasImports, nsName); \
  |  | 4731|      3|	if (import == NULL) \
  |  |  ------------------
  |  |  |  Branch (4731:6): [True: 0, False: 3]
  |  |  ------------------
  |  | 4732|      3|	    goto exit; \
  |  | 4733|      3|	ret = xmlHashLookup(import->schema->slot, name); \
  |  | 4734|      3|    }
  ------------------
 4875|      3|    }
 4876|      9|exit:
 4877|       |
 4878|      9|    return (ret);
 4879|      9|}
xmlschemas.c:xmlSchemaResolveAttrTypeReferences:
20258|    189|{
20259|       |    /*
20260|       |    * The simple type definition corresponding to the <simpleType> element
20261|       |    * information item in the [children], if present, otherwise the simple
20262|       |    * type definition `resolved` to by the `actual value` of the type
20263|       |    * [attribute], if present, otherwise the `simple ur-type definition`.
20264|       |    */
20265|    189|    if (item->flags & XML_SCHEMAS_ATTR_INTERNAL_RESOLVED)
  ------------------
  |  |  233|    189|#define XML_SCHEMAS_ATTR_INTERNAL_RESOLVED        1 << 8
  ------------------
  |  Branch (20265:9): [True: 0, False: 189]
  ------------------
20266|      0|	return(0);
20267|    189|    item->flags |= XML_SCHEMAS_ATTR_INTERNAL_RESOLVED;
  ------------------
  |  |  233|    189|#define XML_SCHEMAS_ATTR_INTERNAL_RESOLVED        1 << 8
  ------------------
20268|    189|    if (item->subtypes != NULL)
  ------------------
  |  Branch (20268:9): [True: 18, False: 171]
  ------------------
20269|     18|        return(0);
20270|    171|    if (item->typeName != NULL) {
  ------------------
  |  Branch (20270:9): [True: 166, False: 5]
  ------------------
20271|    166|        xmlSchemaTypePtr type;
20272|       |
20273|    166|	type = xmlSchemaGetType(ctxt->schema, item->typeName,
20274|    166|	    item->typeNs);
20275|    166|	if ((type == NULL) || (! WXS_IS_SIMPLE(type))) {
  ------------------
  |  |  217|    166|    ((item->type == XML_SCHEMA_TYPE_SIMPLE) || \
  |  |  ------------------
  |  |  |  Branch (217:6): [True: 48, False: 118]
  |  |  ------------------
  |  |  218|    166|     ((item->type == XML_SCHEMA_TYPE_BASIC) && \
  |  |  ------------------
  |  |  |  Branch (218:7): [True: 118, False: 0]
  |  |  ------------------
  |  |  219|    118|      (item->builtInType != XML_SCHEMAS_ANYTYPE)))
  |  |  ------------------
  |  |  |  Branch (219:7): [True: 118, False: 0]
  |  |  ------------------
  ------------------
  |  Branch (20275:6): [True: 0, False: 166]
  ------------------
20276|      0|	    xmlSchemaPResCompAttrErr(ctxt,
20277|      0|		XML_SCHEMAP_SRC_RESOLVE,
20278|      0|		WXS_BASIC_CAST item, item->node,
  ------------------
  |  |  124|      0|#define WXS_BASIC_CAST (xmlSchemaBasicItemPtr)
  ------------------
20279|      0|		"type", item->typeName, item->typeNs,
20280|      0|		XML_SCHEMA_TYPE_SIMPLE, NULL);
20281|      0|	    return(ctxt->err);
20282|      0|	} else
20283|    166|	    item->subtypes = type;
20284|       |
20285|    166|    } else {
20286|       |	/*
20287|       |	* The type defaults to the xs:anySimpleType.
20288|       |	*/
20289|      5|	item->subtypes = xmlSchemaGetBuiltInType(XML_SCHEMAS_ANYSIMPLETYPE);
20290|      5|    }
20291|    171|    return(0);
20292|    171|}
xmlschemas.c:xmlSchemaResolveAttrUseReferences:
20109|     44|{
20110|     44|    if ((ctxt == NULL) || (ause == NULL))
  ------------------
  |  Branch (20110:9): [True: 0, False: 44]
  |  Branch (20110:27): [True: 0, False: 44]
  ------------------
20111|      0|	return(-1);
20112|     44|    if ((ause->attrDecl == NULL) ||
  ------------------
  |  Branch (20112:9): [True: 0, False: 44]
  ------------------
20113|     44|	(ause->attrDecl->type != XML_SCHEMA_EXTRA_QNAMEREF))
  ------------------
  |  Branch (20113:2): [True: 0, False: 44]
  ------------------
20114|      0|	return(0);
20115|       |
20116|     44|    {
20117|     44|	xmlSchemaQNameRefPtr ref = WXS_QNAME_CAST ause->attrDecl;
  ------------------
  |  |  136|     44|#define WXS_QNAME_CAST (xmlSchemaQNameRefPtr)
  ------------------
20118|       |
20119|       |	/*
20120|       |	* TODO: Evaluate, what errors could occur if the declaration is not
20121|       |	* found.
20122|       |	*/
20123|     44|	ause->attrDecl = xmlSchemaGetAttributeDecl(ctxt->schema,
20124|     44|	    ref->name, ref->targetNamespace);
20125|     44|        if (ause->attrDecl == NULL) {
  ------------------
  |  Branch (20125:13): [True: 2, False: 42]
  ------------------
20126|      2|	    xmlSchemaPResCompAttrErr(ctxt,
20127|      2|		XML_SCHEMAP_SRC_RESOLVE,
20128|      2|		WXS_BASIC_CAST ause, ause->node,
  ------------------
  |  |  124|      2|#define WXS_BASIC_CAST (xmlSchemaBasicItemPtr)
  ------------------
20129|      2|		"ref", ref->name, ref->targetNamespace,
20130|      2|		XML_SCHEMA_TYPE_ATTRIBUTE, NULL);
20131|      2|            return(ctxt->err);;
20132|      0|        }
20133|     44|    }
20134|     42|    return(0);
20135|     44|}
xmlschemas.c:xmlSchemaGetAttributeDecl:
 4812|     44|{
 4813|     44|    xmlSchemaAttributePtr ret = NULL;
 4814|       |
 4815|     44|    if ((name == NULL) || (schema == NULL))
  ------------------
  |  Branch (4815:9): [True: 0, False: 44]
  |  Branch (4815:27): [True: 0, False: 44]
  ------------------
 4816|      0|        return (NULL);
 4817|     44|    if (schema != NULL) {
  ------------------
  |  Branch (4817:9): [True: 44, False: 0]
  ------------------
 4818|     44|	WXS_FIND_GLOBAL_ITEM(attrDecl)
  ------------------
  |  | 4720|     44|    if (xmlStrEqual(nsName, schema->targetNamespace)) { \
  |  |  ------------------
  |  |  |  Branch (4720:9): [True: 36, False: 8]
  |  |  ------------------
  |  | 4721|     36|	ret = xmlHashLookup(schema->slot, name); \
  |  | 4722|     36|	if (ret != NULL) goto exit; \
  |  |  ------------------
  |  |  |  Branch (4722:6): [True: 34, False: 2]
  |  |  ------------------
  |  | 4723|     36|    } \
  |  | 4724|     44|    if (xmlHashSize(schema->schemasImports) > 1) { \
  |  |  ------------------
  |  |  |  Branch (4724:9): [True: 8, False: 2]
  |  |  ------------------
  |  | 4725|      8|	xmlSchemaImportPtr import; \
  |  | 4726|      8|	if (nsName == NULL) \
  |  |  ------------------
  |  |  |  Branch (4726:6): [True: 0, False: 8]
  |  |  ------------------
  |  | 4727|      8|	    import = xmlHashLookup(schema->schemasImports, \
  |  | 4728|      0|		XML_SCHEMAS_NO_NAMESPACE); \
  |  |  ------------------
  |  |  |  |  104|      0|#define XML_SCHEMAS_NO_NAMESPACE (const xmlChar *) "##"
  |  |  ------------------
  |  | 4729|      8|	else \
  |  | 4730|      8|	    import = xmlHashLookup(schema->schemasImports, nsName); \
  |  | 4731|      8|	if (import == NULL) \
  |  |  ------------------
  |  |  |  Branch (4731:6): [True: 0, False: 8]
  |  |  ------------------
  |  | 4732|      8|	    goto exit; \
  |  | 4733|      8|	ret = xmlHashLookup(import->schema->slot, name); \
  |  | 4734|      8|    }
  ------------------
 4819|     10|    }
 4820|     44|exit:
 4821|     44|    return (ret);
 4822|     44|}
xmlschemas.c:xmlSchemaResolveAttrGroupReferences:
19393|     51|{
19394|     51|    xmlSchemaAttributeGroupPtr group;
19395|       |
19396|     51|    if (ref->item != NULL)
  ------------------
  |  Branch (19396:9): [True: 0, False: 51]
  ------------------
19397|      0|        return(0);
19398|     51|    group = xmlSchemaGetAttributeGroup(ctxt->schema,
19399|     51|	ref->name,
19400|     51|	ref->targetNamespace);
19401|     51|    if (group == NULL) {
  ------------------
  |  Branch (19401:9): [True: 0, False: 51]
  ------------------
19402|      0|	xmlSchemaPResCompAttrErr(ctxt,
19403|      0|	    XML_SCHEMAP_SRC_RESOLVE,
19404|      0|	    NULL, ref->node,
19405|      0|	    "ref", ref->name, ref->targetNamespace,
19406|      0|	    ref->itemType, NULL);
19407|      0|	return(ctxt->err);
19408|      0|    }
19409|     51|    ref->item = WXS_BASIC_CAST group;
  ------------------
  |  |  124|     51|#define WXS_BASIC_CAST (xmlSchemaBasicItemPtr)
  ------------------
19410|     51|    return(0);
19411|     51|}
xmlschemas.c:xmlSchemaGetAttributeGroup:
 4837|     51|{
 4838|     51|    xmlSchemaAttributeGroupPtr ret = NULL;
 4839|       |
 4840|     51|    if ((name == NULL) || (schema == NULL))
  ------------------
  |  Branch (4840:9): [True: 0, False: 51]
  |  Branch (4840:27): [True: 0, False: 51]
  ------------------
 4841|      0|        return (NULL);
 4842|     51|    if (schema != NULL) {
  ------------------
  |  Branch (4842:9): [True: 51, False: 0]
  ------------------
 4843|     51|	WXS_FIND_GLOBAL_ITEM(attrgrpDecl)
  ------------------
  |  | 4720|     51|    if (xmlStrEqual(nsName, schema->targetNamespace)) { \
  |  |  ------------------
  |  |  |  Branch (4720:9): [True: 50, False: 1]
  |  |  ------------------
  |  | 4721|     50|	ret = xmlHashLookup(schema->slot, name); \
  |  | 4722|     50|	if (ret != NULL) goto exit; \
  |  |  ------------------
  |  |  |  Branch (4722:6): [True: 50, False: 0]
  |  |  ------------------
  |  | 4723|     50|    } \
  |  | 4724|     51|    if (xmlHashSize(schema->schemasImports) > 1) { \
  |  |  ------------------
  |  |  |  Branch (4724:9): [True: 1, False: 0]
  |  |  ------------------
  |  | 4725|      1|	xmlSchemaImportPtr import; \
  |  | 4726|      1|	if (nsName == NULL) \
  |  |  ------------------
  |  |  |  Branch (4726:6): [True: 1, False: 0]
  |  |  ------------------
  |  | 4727|      1|	    import = xmlHashLookup(schema->schemasImports, \
  |  | 4728|      1|		XML_SCHEMAS_NO_NAMESPACE); \
  |  |  ------------------
  |  |  |  |  104|      1|#define XML_SCHEMAS_NO_NAMESPACE (const xmlChar *) "##"
  |  |  ------------------
  |  | 4729|      1|	else \
  |  | 4730|      1|	    import = xmlHashLookup(schema->schemasImports, nsName); \
  |  | 4731|      1|	if (import == NULL) \
  |  |  ------------------
  |  |  |  Branch (4731:6): [True: 0, False: 1]
  |  |  ------------------
  |  | 4732|      1|	    goto exit; \
  |  | 4733|      1|	ret = xmlHashLookup(import->schema->slot, name); \
  |  | 4734|      1|    }
  ------------------
 4844|      1|    }
 4845|     51|exit:
 4846|       |    /* TODO:
 4847|       |    if ((ret != NULL) && (ret->redef != NULL)) {
 4848|       |	* Return the last redefinition. *
 4849|       |	ret = ret->redef;
 4850|       |    }
 4851|       |    */
 4852|     51|    return (ret);
 4853|     51|}
xmlschemas.c:xmlSchemaResolveModelGroupParticleReferences:
19962|    305|{
19963|    305|    xmlSchemaParticlePtr particle = WXS_MODELGROUP_PARTICLE(mg);
  ------------------
  |  |  192|    305|#define WXS_MODELGROUP_PARTICLE(mg) WXS_PTC_CAST (mg)->children
  |  |  ------------------
  |  |  |  |  126|    305|#define WXS_PTC_CAST (xmlSchemaParticlePtr)
  |  |  ------------------
  ------------------
19964|    305|    xmlSchemaQNameRefPtr ref;
19965|    305|    xmlSchemaBasicItemPtr refItem;
19966|       |
19967|       |    /*
19968|       |    * URGENT TODO: Test this.
19969|       |    */
19970|  1.08k|    while (particle != NULL) {
  ------------------
  |  Branch (19970:12): [True: 775, False: 305]
  ------------------
19971|    775|	if ((WXS_PARTICLE_TERM(particle) == NULL) ||
  ------------------
  |  |  175|    775|#define WXS_PARTICLE_TERM(p) (WXS_PARTICLE(p))->children
  |  |  ------------------
  |  |  |  |  173|    775|#define WXS_PARTICLE(p) WXS_PTC_CAST (p)
  |  |  |  |  ------------------
  |  |  |  |  |  |  126|    775|#define WXS_PTC_CAST (xmlSchemaParticlePtr)
  |  |  |  |  ------------------
  |  |  ------------------
  ------------------
  |  Branch (19971:6): [True: 8, False: 767]
  ------------------
19972|    775|	    ((WXS_PARTICLE_TERM(particle))->type !=
  ------------------
  |  |  175|    767|#define WXS_PARTICLE_TERM(p) (WXS_PARTICLE(p))->children
  |  |  ------------------
  |  |  |  |  173|    767|#define WXS_PARTICLE(p) WXS_PTC_CAST (p)
  |  |  |  |  ------------------
  |  |  |  |  |  |  126|    767|#define WXS_PTC_CAST (xmlSchemaParticlePtr)
  |  |  |  |  ------------------
  |  |  ------------------
  ------------------
  |  Branch (19972:6): [True: 562, False: 205]
  ------------------
19973|    767|		XML_SCHEMA_EXTRA_QNAMEREF))
19974|    570|	{
19975|    570|	    goto next_particle;
19976|    570|	}
19977|    205|	ref = WXS_QNAME_CAST WXS_PARTICLE_TERM(particle);
  ------------------
  |  |  136|    205|#define WXS_QNAME_CAST (xmlSchemaQNameRefPtr)
  ------------------
              	ref = WXS_QNAME_CAST WXS_PARTICLE_TERM(particle);
  ------------------
  |  |  175|    205|#define WXS_PARTICLE_TERM(p) (WXS_PARTICLE(p))->children
  |  |  ------------------
  |  |  |  |  173|    205|#define WXS_PARTICLE(p) WXS_PTC_CAST (p)
  |  |  |  |  ------------------
  |  |  |  |  |  |  126|    205|#define WXS_PTC_CAST (xmlSchemaParticlePtr)
  |  |  |  |  ------------------
  |  |  ------------------
  ------------------
19978|       |	/*
19979|       |	* Resolve the reference.
19980|       |	* NULL the {term} by default.
19981|       |	*/
19982|    205|	particle->children = NULL;
19983|       |
19984|    205|	refItem = xmlSchemaGetNamedComponent(ctxt->schema,
19985|    205|	    ref->itemType, ref->name, ref->targetNamespace);
19986|    205|	if (refItem == NULL) {
  ------------------
  |  Branch (19986:6): [True: 8, False: 197]
  ------------------
19987|      8|	    xmlSchemaPResCompAttrErr(ctxt, XML_SCHEMAP_SRC_RESOLVE,
19988|      8|		NULL, WXS_ITEM_NODE(particle), "ref", ref->name,
  ------------------
  |  |  142|      8|#define WXS_ITEM_NODE(i) xmlSchemaGetComponentNode(WXS_BASIC_CAST (i))
  |  |  ------------------
  |  |  |  |  124|      8|#define WXS_BASIC_CAST (xmlSchemaBasicItemPtr)
  |  |  ------------------
  ------------------
19989|      8|		ref->targetNamespace, ref->itemType, NULL);
19990|       |	    /* TODO: remove the particle. */
19991|      8|	    goto next_particle;
19992|      8|	}
19993|    197|	if (refItem->type == XML_SCHEMA_TYPE_GROUP) {
  ------------------
  |  Branch (19993:6): [True: 5, False: 192]
  ------------------
19994|      5|	    if (WXS_MODELGROUPDEF_MODEL(refItem) == NULL)
  ------------------
  |  |  183|      5|#define WXS_MODELGROUPDEF_MODEL(mgd) (WXS_MODEL_GROUP_CAST (mgd))->children
  |  |  ------------------
  |  |  |  |  134|      5|#define WXS_MODEL_GROUP_CAST (xmlSchemaModelGroupPtr)
  |  |  ------------------
  ------------------
  |  Branch (19994:10): [True: 0, False: 5]
  ------------------
19995|       |		/* TODO: remove the particle. */
19996|      0|		goto next_particle;
19997|       |	    /*
19998|       |	    * NOTE that we will assign the model group definition
19999|       |	    * itself to the "term" of the particle. This will ease
20000|       |	    * the check for circular model group definitions. After
20001|       |	    * that the "term" will be assigned the model group of the
20002|       |	    * model group definition.
20003|       |	    */
20004|      5|	    if ((WXS_MODELGROUPDEF_MODEL(refItem))->type ==
  ------------------
  |  |  183|      5|#define WXS_MODELGROUPDEF_MODEL(mgd) (WXS_MODEL_GROUP_CAST (mgd))->children
  |  |  ------------------
  |  |  |  |  134|      5|#define WXS_MODEL_GROUP_CAST (xmlSchemaModelGroupPtr)
  |  |  ------------------
  ------------------
  |  Branch (20004:10): [True: 0, False: 5]
  ------------------
20005|      5|		    XML_SCHEMA_TYPE_ALL) {
20006|       |		/*
20007|       |		* SPEC cos-all-limited (1)
20008|       |		* SPEC cos-all-limited (1.2)
20009|       |		* "It appears only as the value of one or both of the
20010|       |		* following properties:"
20011|       |		* (1.1) "the {model group} property of a model group
20012|       |		*        definition."
20013|       |		* (1.2) "the {term} property of a particle [... of] the "
20014|       |		* {content type} of a complex type definition."
20015|       |		*/
20016|      0|		xmlSchemaCustomErr(ACTXT_CAST ctxt,
  ------------------
  |  |  121|      0|#define ACTXT_CAST (xmlSchemaAbstractCtxtPtr)
  ------------------
20017|       |		    /* TODO: error code */
20018|      0|		    XML_SCHEMAP_COS_ALL_LIMITED,
20019|      0|		    WXS_ITEM_NODE(particle), NULL,
  ------------------
  |  |  142|      0|#define WXS_ITEM_NODE(i) xmlSchemaGetComponentNode(WXS_BASIC_CAST (i))
  |  |  ------------------
  |  |  |  |  124|      0|#define WXS_BASIC_CAST (xmlSchemaBasicItemPtr)
  |  |  ------------------
  ------------------
20020|      0|		    "A model group definition is referenced, but "
20021|      0|		    "it contains an 'all' model group, which "
20022|      0|		    "cannot be contained by model groups",
20023|      0|		    NULL, NULL);
20024|       |		/* TODO: remove the particle. */
20025|      0|		goto next_particle;
20026|      0|	    }
20027|      5|	    particle->children = (xmlSchemaTreeItemPtr) refItem;
20028|    192|	} else {
20029|       |	    /*
20030|       |	    * TODO: Are referenced element declarations the only
20031|       |	    * other components we expect here?
20032|       |	    */
20033|    192|	    particle->children = (xmlSchemaTreeItemPtr) refItem;
20034|    192|	}
20035|    775|next_particle:
20036|    775|	particle = WXS_PTC_CAST particle->next;
  ------------------
  |  |  126|    775|#define WXS_PTC_CAST (xmlSchemaParticlePtr)
  ------------------
20037|    775|    }
20038|    305|}
xmlschemas.c:xmlSchemaResolveIDCKeyReferences:
20307|      4|{
20308|      4|    if (idc->type != XML_SCHEMA_TYPE_IDC_KEYREF)
  ------------------
  |  Branch (20308:9): [True: 0, False: 4]
  ------------------
20309|      0|        return(0);
20310|      4|    if (idc->ref->name != NULL) {
  ------------------
  |  Branch (20310:9): [True: 4, False: 0]
  ------------------
20311|      4|	idc->ref->item = (xmlSchemaBasicItemPtr)
20312|      4|	    xmlSchemaGetIDC(pctxt->schema, idc->ref->name,
20313|      4|		idc->ref->targetNamespace);
20314|      4|        if (idc->ref->item == NULL) {
  ------------------
  |  Branch (20314:13): [True: 0, False: 4]
  ------------------
20315|       |	    /*
20316|       |	    * TODO: It is actually not an error to fail to resolve
20317|       |	    * at this stage. BUT we need to be that strict!
20318|       |	    */
20319|      0|	    xmlSchemaPResCompAttrErr(pctxt,
20320|      0|		XML_SCHEMAP_SRC_RESOLVE,
20321|      0|		WXS_BASIC_CAST idc, idc->node,
  ------------------
  |  |  124|      0|#define WXS_BASIC_CAST (xmlSchemaBasicItemPtr)
  ------------------
20322|      0|		"refer", idc->ref->name,
20323|      0|		idc->ref->targetNamespace,
20324|      0|		XML_SCHEMA_TYPE_IDC_KEY, NULL);
20325|      0|            return(pctxt->err);
20326|      4|	} else if (idc->ref->item->type == XML_SCHEMA_TYPE_IDC_KEYREF) {
  ------------------
  |  Branch (20326:13): [True: 0, False: 4]
  ------------------
20327|       |	    /*
20328|       |	    * SPEC c-props-correct (1)
20329|       |	    */
20330|      0|	    xmlSchemaCustomErr(ACTXT_CAST pctxt,
  ------------------
  |  |  121|      0|#define ACTXT_CAST (xmlSchemaAbstractCtxtPtr)
  ------------------
20331|      0|		XML_SCHEMAP_C_PROPS_CORRECT,
20332|      0|		NULL, WXS_BASIC_CAST idc,
  ------------------
  |  |  124|      0|#define WXS_BASIC_CAST (xmlSchemaBasicItemPtr)
  ------------------
20333|      0|		"The keyref references a keyref",
20334|      0|		NULL, NULL);
20335|      0|	    idc->ref->item = NULL;
20336|      0|	    return(pctxt->err);
20337|      4|	} else {
20338|      4|	    if (idc->nbFields !=
  ------------------
  |  Branch (20338:10): [True: 0, False: 4]
  ------------------
20339|      4|		((xmlSchemaIDCPtr) idc->ref->item)->nbFields) {
20340|      0|		xmlChar *str = NULL;
20341|      0|		xmlSchemaIDCPtr refer;
20342|       |
20343|      0|		refer = (xmlSchemaIDCPtr) idc->ref->item;
20344|       |		/*
20345|       |		* SPEC c-props-correct(2)
20346|       |		* "If the {identity-constraint category} is keyref,
20347|       |		* the cardinality of the {fields} must equal that of
20348|       |		* the {fields} of the {referenced key}.
20349|       |		*/
20350|      0|		xmlSchemaCustomErr(ACTXT_CAST pctxt,
  ------------------
  |  |  121|      0|#define ACTXT_CAST (xmlSchemaAbstractCtxtPtr)
  ------------------
20351|      0|		    XML_SCHEMAP_C_PROPS_CORRECT,
20352|      0|		    NULL, WXS_BASIC_CAST idc,
  ------------------
  |  |  124|      0|#define WXS_BASIC_CAST (xmlSchemaBasicItemPtr)
  ------------------
20353|      0|		    "The cardinality of the keyref differs from the "
20354|      0|		    "cardinality of the referenced key/unique '%s'",
20355|      0|		    xmlSchemaFormatQName(&str, refer->targetNamespace,
20356|      0|			refer->name),
20357|      0|		    NULL);
20358|      0|		FREE_AND_NULL(str)
  ------------------
  |  |  320|      0|#define FREE_AND_NULL(str) if ((str) != NULL) { xmlFree((xmlChar *) (str)); str = NULL; }
  |  |  ------------------
  |  |  |  Branch (320:32): [True: 0, False: 0]
  |  |  ------------------
  ------------------
20359|      0|		return(pctxt->err);
20360|      0|	    }
20361|      4|	}
20362|      4|    }
20363|      4|    return(0);
20364|      4|}
xmlschemas.c:xmlSchemaGetIDC:
 4901|      4|{
 4902|      4|    xmlSchemaIDCPtr ret = NULL;
 4903|       |
 4904|      4|    if ((name == NULL) || (schema == NULL))
  ------------------
  |  Branch (4904:9): [True: 0, False: 4]
  |  Branch (4904:27): [True: 0, False: 4]
  ------------------
 4905|      0|        return (NULL);
 4906|      4|    if (schema != NULL) {
  ------------------
  |  Branch (4906:9): [True: 4, False: 0]
  ------------------
 4907|      4|	WXS_FIND_GLOBAL_ITEM(idcDef)
  ------------------
  |  | 4720|      4|    if (xmlStrEqual(nsName, schema->targetNamespace)) { \
  |  |  ------------------
  |  |  |  Branch (4720:9): [True: 4, False: 0]
  |  |  ------------------
  |  | 4721|      4|	ret = xmlHashLookup(schema->slot, name); \
  |  | 4722|      4|	if (ret != NULL) goto exit; \
  |  |  ------------------
  |  |  |  Branch (4722:6): [True: 4, False: 0]
  |  |  ------------------
  |  | 4723|      4|    } \
  |  | 4724|      4|    if (xmlHashSize(schema->schemasImports) > 1) { \
  |  |  ------------------
  |  |  |  Branch (4724:9): [True: 0, False: 0]
  |  |  ------------------
  |  | 4725|      0|	xmlSchemaImportPtr import; \
  |  | 4726|      0|	if (nsName == NULL) \
  |  |  ------------------
  |  |  |  Branch (4726:6): [True: 0, False: 0]
  |  |  ------------------
  |  | 4727|      0|	    import = xmlHashLookup(schema->schemasImports, \
  |  | 4728|      0|		XML_SCHEMAS_NO_NAMESPACE); \
  |  |  ------------------
  |  |  |  |  104|      0|#define XML_SCHEMAS_NO_NAMESPACE (const xmlChar *) "##"
  |  |  ------------------
  |  | 4729|      0|	else \
  |  | 4730|      0|	    import = xmlHashLookup(schema->schemasImports, nsName); \
  |  | 4731|      0|	if (import == NULL) \
  |  |  ------------------
  |  |  |  Branch (4731:6): [True: 0, False: 0]
  |  |  ------------------
  |  | 4732|      0|	    goto exit; \
  |  | 4733|      0|	ret = xmlHashLookup(import->schema->slot, name); \
  |  | 4734|      0|    }
  ------------------
 4908|      0|    }
 4909|      4|exit:
 4910|      4|    return (ret);
 4911|      4|}
xmlschemas.c:xmlSchemaCheckTypeDefCircular:
14950|    521|{
14951|    521|    if ((item == NULL) ||
  ------------------
  |  Branch (14951:9): [True: 0, False: 521]
  ------------------
14952|    521|	(item->type == XML_SCHEMA_TYPE_BASIC) ||
  ------------------
  |  Branch (14952:2): [True: 0, False: 521]
  ------------------
14953|    521|	(item->baseType == NULL))
  ------------------
  |  Branch (14953:2): [True: 0, False: 521]
  ------------------
14954|      0|	return;
14955|    521|    xmlSchemaCheckTypeDefCircularInternal(ctxt, item,
14956|    521|	item->baseType);
14957|    521|}
xmlschemas.c:xmlSchemaCheckTypeDefCircularInternal:
14913|    619|{
14914|    619|    int ret;
14915|       |
14916|    619|    if ((ancestor == NULL) || (ancestor->type == XML_SCHEMA_TYPE_BASIC))
  ------------------
  |  Branch (14916:9): [True: 0, False: 619]
  |  Branch (14916:31): [True: 521, False: 98]
  ------------------
14917|    521|	return (0);
14918|       |
14919|     98|    if (ctxtType == ancestor) {
  ------------------
  |  Branch (14919:9): [True: 0, False: 98]
  ------------------
14920|      0|	xmlSchemaPCustomErr(pctxt,
14921|      0|	    XML_SCHEMAP_ST_PROPS_CORRECT_2,
14922|      0|	    WXS_BASIC_CAST ctxtType, WXS_ITEM_NODE(ctxtType),
  ------------------
  |  |  124|      0|#define WXS_BASIC_CAST (xmlSchemaBasicItemPtr)
  ------------------
              	    WXS_BASIC_CAST ctxtType, WXS_ITEM_NODE(ctxtType),
  ------------------
  |  |  142|      0|#define WXS_ITEM_NODE(i) xmlSchemaGetComponentNode(WXS_BASIC_CAST (i))
  |  |  ------------------
  |  |  |  |  124|      0|#define WXS_BASIC_CAST (xmlSchemaBasicItemPtr)
  |  |  ------------------
  ------------------
14923|      0|	    "The definition is circular", NULL);
14924|      0|	return (XML_SCHEMAP_ST_PROPS_CORRECT_2);
14925|      0|    }
14926|     98|    if (ancestor->flags & XML_SCHEMAS_TYPE_MARKED) {
  ------------------
  |  |  502|     98|#define XML_SCHEMAS_TYPE_MARKED        1 << 16
  ------------------
  |  Branch (14926:9): [True: 0, False: 98]
  ------------------
14927|       |	/*
14928|       |	* Avoid infinite recursion on circular types not yet checked.
14929|       |	*/
14930|      0|	return (0);
14931|      0|    }
14932|     98|    ancestor->flags |= XML_SCHEMAS_TYPE_MARKED;
  ------------------
  |  |  502|     98|#define XML_SCHEMAS_TYPE_MARKED        1 << 16
  ------------------
14933|     98|    ret = xmlSchemaCheckTypeDefCircularInternal(pctxt, ctxtType,
14934|     98|	ancestor->baseType);
14935|     98|    ancestor->flags ^= XML_SCHEMAS_TYPE_MARKED;
  ------------------
  |  |  502|     98|#define XML_SCHEMAS_TYPE_MARKED        1 << 16
  ------------------
14936|     98|    return (ret);
14937|     98|}
xmlschemas.c:xmlSchemaCheckGroupDefCircular:
18882|      9|{
18883|       |    /*
18884|       |    * Schema Component Constraint: Model Group Correct
18885|       |    * 2 Circular groups are disallowed. That is, within the {particles}
18886|       |    * of a group there must not be at any depth a particle whose {term}
18887|       |    * is the group itself.
18888|       |    */
18889|      9|    if ((item == NULL) ||
  ------------------
  |  Branch (18889:9): [True: 0, False: 9]
  ------------------
18890|      9|	(item->type != XML_SCHEMA_TYPE_GROUP) ||
  ------------------
  |  Branch (18890:2): [True: 0, False: 9]
  ------------------
18891|      9|	(item->children == NULL))
  ------------------
  |  Branch (18891:2): [True: 0, False: 9]
  ------------------
18892|      0|	return;
18893|      9|    {
18894|      9|	xmlSchemaTreeItemPtr circ;
18895|       |
18896|      9|	circ = xmlSchemaGetCircModelGrDefRef(item, item->children->children);
18897|      9|	if (circ != NULL) {
  ------------------
  |  Branch (18897:6): [True: 0, False: 9]
  ------------------
18898|      0|	    xmlChar *str = NULL;
18899|       |	    /*
18900|       |	    * TODO: The error report is not adequate: this constraint
18901|       |	    * is defined for model groups but not definitions, but since
18902|       |	    * there cannot be any circular model groups without a model group
18903|       |	    * definition (if not using a construction API), we check those
18904|       |	    * definitions only.
18905|       |	    */
18906|      0|	    xmlSchemaPCustomErr(ctxt,
18907|      0|		XML_SCHEMAP_MG_PROPS_CORRECT_2,
18908|      0|		NULL, WXS_ITEM_NODE(circ),
  ------------------
  |  |  142|      0|#define WXS_ITEM_NODE(i) xmlSchemaGetComponentNode(WXS_BASIC_CAST (i))
  |  |  ------------------
  |  |  |  |  124|      0|#define WXS_BASIC_CAST (xmlSchemaBasicItemPtr)
  |  |  ------------------
  ------------------
18909|      0|		"Circular reference to the model group definition '%s' "
18910|      0|		"defined", xmlSchemaFormatQName(&str,
18911|      0|		    item->targetNamespace, item->name));
18912|      0|	    FREE_AND_NULL(str)
  ------------------
  |  |  320|      0|#define FREE_AND_NULL(str) if ((str) != NULL) { xmlFree((xmlChar *) (str)); str = NULL; }
  |  |  ------------------
  |  |  |  Branch (320:32): [True: 0, False: 0]
  |  |  ------------------
  ------------------
18913|       |	    /*
18914|       |	    * NOTE: We will cut the reference to avoid further
18915|       |	    * confusion of the processor. This is a fatal error.
18916|       |	    */
18917|      0|	    circ->children = NULL;
18918|      0|	}
18919|      9|    }
18920|      9|}
xmlschemas.c:xmlSchemaGetCircModelGrDefRef:
18828|     13|{
18829|     13|    xmlSchemaTreeItemPtr circ = NULL;
18830|     13|    xmlSchemaTreeItemPtr term;
18831|     13|    xmlSchemaModelGroupDefPtr gdef;
18832|       |
18833|     31|    for (; particle != NULL; particle = particle->next) {
  ------------------
  |  Branch (18833:12): [True: 18, False: 13]
  ------------------
18834|     18|	term = particle->children;
18835|     18|	if (term == NULL)
  ------------------
  |  Branch (18835:6): [True: 0, False: 18]
  ------------------
18836|      0|	    continue;
18837|     18|	switch (term->type) {
18838|      0|	    case XML_SCHEMA_TYPE_GROUP:
  ------------------
  |  Branch (18838:6): [True: 0, False: 18]
  ------------------
18839|      0|		gdef = (xmlSchemaModelGroupDefPtr) term;
18840|      0|		if (gdef == groupDef)
  ------------------
  |  Branch (18840:7): [True: 0, False: 0]
  ------------------
18841|      0|		    return (particle);
18842|       |		/*
18843|       |		* Mark this model group definition to avoid infinite
18844|       |		* recursion on circular references not yet examined.
18845|       |		*/
18846|      0|		if (gdef->flags & XML_SCHEMA_MODEL_GROUP_DEF_MARKED)
  ------------------
  |  |  690|      0|#define XML_SCHEMA_MODEL_GROUP_DEF_MARKED 1<<0
  ------------------
  |  Branch (18846:7): [True: 0, False: 0]
  ------------------
18847|      0|		    continue;
18848|      0|		if (gdef->children != NULL) {
  ------------------
  |  Branch (18848:7): [True: 0, False: 0]
  ------------------
18849|      0|		    gdef->flags |= XML_SCHEMA_MODEL_GROUP_DEF_MARKED;
  ------------------
  |  |  690|      0|#define XML_SCHEMA_MODEL_GROUP_DEF_MARKED 1<<0
  ------------------
18850|      0|		    circ = xmlSchemaGetCircModelGrDefRef(groupDef,
18851|      0|			gdef->children->children);
18852|      0|		    gdef->flags ^= XML_SCHEMA_MODEL_GROUP_DEF_MARKED;
  ------------------
  |  |  690|      0|#define XML_SCHEMA_MODEL_GROUP_DEF_MARKED 1<<0
  ------------------
18853|      0|		    if (circ != NULL)
  ------------------
  |  Branch (18853:11): [True: 0, False: 0]
  ------------------
18854|      0|			return (circ);
18855|      0|		}
18856|      0|		break;
18857|      1|	    case XML_SCHEMA_TYPE_SEQUENCE:
  ------------------
  |  Branch (18857:6): [True: 1, False: 17]
  ------------------
18858|      4|	    case XML_SCHEMA_TYPE_CHOICE:
  ------------------
  |  Branch (18858:6): [True: 3, False: 15]
  ------------------
18859|      4|	    case XML_SCHEMA_TYPE_ALL:
  ------------------
  |  Branch (18859:6): [True: 0, False: 18]
  ------------------
18860|      4|		circ = xmlSchemaGetCircModelGrDefRef(groupDef, term->children);
18861|      4|		if (circ != NULL)
  ------------------
  |  Branch (18861:7): [True: 0, False: 4]
  ------------------
18862|      0|		    return (circ);
18863|      4|		break;
18864|     14|	    default:
  ------------------
  |  Branch (18864:6): [True: 14, False: 4]
  ------------------
18865|     14|		break;
18866|     18|	}
18867|     18|    }
18868|     13|    return (NULL);
18869|     13|}
xmlschemas.c:xmlSchemaCheckAttrGroupCircular:
19032|     40|{
19033|       |    /*
19034|       |    * Schema Representation Constraint:
19035|       |    * Attribute Group Definition Representation OK
19036|       |    * 3 Circular group reference is disallowed outside <redefine>.
19037|       |    * That is, unless this element information item's parent is
19038|       |    * <redefine>, then among the [children], if any, there must
19039|       |    * not be an <attributeGroup> with ref [attribute] which resolves
19040|       |    * to the component corresponding to this <attributeGroup>. Indirect
19041|       |    * circularity is also ruled out. That is, when QName resolution
19042|       |    * (Schema Document) ($3.15.3) is applied to a `QName` arising from
19043|       |    * any <attributeGroup>s with a ref [attribute] among the [children],
19044|       |    * it must not be the case that a `QName` is encountered at any depth
19045|       |    * which resolves to the component corresponding to this <attributeGroup>.
19046|       |    */
19047|     40|    if (attrGr->attrUses == NULL)
  ------------------
  |  Branch (19047:9): [True: 27, False: 13]
  ------------------
19048|     27|	return(0);
19049|     13|    else if ((attrGr->flags & XML_SCHEMAS_ATTRGROUP_HAS_REFS) == 0)
  ------------------
  |  |  351|     13|#define XML_SCHEMAS_ATTRGROUP_HAS_REFS 1 << 4
  ------------------
  |  Branch (19049:14): [True: 12, False: 1]
  ------------------
19050|     12|	return(0);
19051|      1|    else {
19052|      1|	xmlSchemaQNameRefPtr circ;
19053|       |
19054|      1|	circ = xmlSchemaCheckAttrGroupCircularRecur(attrGr,
19055|      1|	    (xmlSchemaItemListPtr) attrGr->attrUses);
19056|      1|	if (circ != NULL) {
  ------------------
  |  Branch (19056:6): [True: 0, False: 1]
  ------------------
19057|      0|	    xmlChar *str = NULL;
19058|       |	    /*
19059|       |	    * TODO: Report the referenced attr group as QName.
19060|       |	    */
19061|      0|	    xmlSchemaPCustomErr(ctxt,
19062|      0|		XML_SCHEMAP_SRC_ATTRIBUTE_GROUP_3,
19063|      0|		NULL, WXS_ITEM_NODE(WXS_BASIC_CAST circ),
  ------------------
  |  |  142|      0|#define WXS_ITEM_NODE(i) xmlSchemaGetComponentNode(WXS_BASIC_CAST (i))
  |  |  ------------------
  |  |  |  |  124|      0|#define WXS_BASIC_CAST (xmlSchemaBasicItemPtr)
  |  |  ------------------
  ------------------
19064|      0|		"Circular reference to the attribute group '%s' "
19065|      0|		"defined", xmlSchemaGetComponentQName(&str, attrGr));
19066|      0|	    FREE_AND_NULL(str);
  ------------------
  |  |  320|      0|#define FREE_AND_NULL(str) if ((str) != NULL) { xmlFree((xmlChar *) (str)); str = NULL; }
  |  |  ------------------
  |  |  |  Branch (320:32): [True: 0, False: 0]
  |  |  ------------------
  ------------------
19067|       |	    /*
19068|       |	    * NOTE: We will cut the reference to avoid further
19069|       |	    * confusion of the processor.
19070|       |	    * BADSPEC TODO: The spec should define how to process in this case.
19071|       |	    */
19072|      0|	    circ->item = NULL;
19073|      0|	    return(ctxt->err);
19074|      0|	}
19075|      1|    }
19076|      1|    return(0);
19077|     40|}
xmlschemas.c:xmlSchemaCheckAttrGroupCircularRecur:
18982|      1|{
18983|      1|    xmlSchemaAttributeGroupPtr gr;
18984|      1|    xmlSchemaQNameRefPtr ref, circ;
18985|      1|    int i;
18986|       |    /*
18987|       |    * We will search for an attribute group reference which
18988|       |    * references the context attribute group.
18989|       |    */
18990|      3|    for (i = 0; i < list->nbItems; i++) {
  ------------------
  |  Branch (18990:17): [True: 2, False: 1]
  ------------------
18991|      2|	ref = list->items[i];
18992|      2|	if ((ref->type == XML_SCHEMA_EXTRA_QNAMEREF) &&
  ------------------
  |  Branch (18992:6): [True: 2, False: 0]
  ------------------
18993|      2|	    (ref->itemType == XML_SCHEMA_TYPE_ATTRIBUTEGROUP) &&
  ------------------
  |  Branch (18993:6): [True: 2, False: 0]
  ------------------
18994|      2|	    (ref->item != NULL))
  ------------------
  |  Branch (18994:6): [True: 2, False: 0]
  ------------------
18995|      2|	{
18996|      2|	    gr = WXS_ATTR_GROUP_CAST ref->item;
  ------------------
  |  |  129|      2|#define WXS_ATTR_GROUP_CAST (xmlSchemaAttributeGroupPtr)
  ------------------
18997|      2|	    if (gr == ctxtGr)
  ------------------
  |  Branch (18997:10): [True: 0, False: 2]
  ------------------
18998|      0|		return(ref);
18999|      2|	    if (gr->flags & XML_SCHEMAS_ATTRGROUP_MARKED)
  ------------------
  |  |  338|      2|#define XML_SCHEMAS_ATTRGROUP_MARKED 1 << 2
  ------------------
  |  Branch (18999:10): [True: 0, False: 2]
  ------------------
19000|      0|		continue;
19001|       |	    /*
19002|       |	    * Mark as visited to avoid infinite recursion on
19003|       |	    * circular references not yet examined.
19004|       |	    */
19005|      2|	    if ((gr->attrUses) &&
  ------------------
  |  Branch (19005:10): [True: 2, False: 0]
  ------------------
19006|      2|		(gr->flags & XML_SCHEMAS_ATTRGROUP_HAS_REFS))
  ------------------
  |  |  351|      2|#define XML_SCHEMAS_ATTRGROUP_HAS_REFS 1 << 4
  ------------------
  |  Branch (19006:3): [True: 0, False: 2]
  ------------------
19007|      0|	    {
19008|      0|		gr->flags |= XML_SCHEMAS_ATTRGROUP_MARKED;
  ------------------
  |  |  338|      0|#define XML_SCHEMAS_ATTRGROUP_MARKED 1 << 2
  ------------------
19009|      0|		circ = xmlSchemaCheckAttrGroupCircularRecur(ctxtGr,
19010|      0|		    (xmlSchemaItemListPtr) gr->attrUses);
19011|      0|		gr->flags ^= XML_SCHEMAS_ATTRGROUP_MARKED;
  ------------------
  |  |  338|      0|#define XML_SCHEMAS_ATTRGROUP_MARKED 1 << 2
  ------------------
19012|      0|		if (circ != NULL)
  ------------------
  |  Branch (19012:7): [True: 0, False: 0]
  ------------------
19013|      0|		    return (circ);
19014|      0|	    }
19015|       |
19016|      2|	}
19017|      2|    }
19018|      1|    return (NULL);
19019|      1|}
xmlschemas.c:xmlSchemaModelGroupToModelGroupDefFixup:
18940|    297|{
18941|    297|    xmlSchemaParticlePtr particle = WXS_MODELGROUP_PARTICLE(mg);
  ------------------
  |  |  192|    297|#define WXS_MODELGROUP_PARTICLE(mg) WXS_PTC_CAST (mg)->children
  |  |  ------------------
  |  |  |  |  126|    297|#define WXS_PTC_CAST (xmlSchemaParticlePtr)
  |  |  ------------------
  ------------------
18942|       |
18943|  1.04k|    while (particle != NULL) {
  ------------------
  |  Branch (18943:12): [True: 750, False: 297]
  ------------------
18944|    750|	if ((WXS_PARTICLE_TERM(particle) == NULL) ||
  ------------------
  |  |  175|    750|#define WXS_PARTICLE_TERM(p) (WXS_PARTICLE(p))->children
  |  |  ------------------
  |  |  |  |  173|    750|#define WXS_PARTICLE(p) WXS_PTC_CAST (p)
  |  |  |  |  ------------------
  |  |  |  |  |  |  126|    750|#define WXS_PTC_CAST (xmlSchemaParticlePtr)
  |  |  |  |  ------------------
  |  |  ------------------
  ------------------
  |  Branch (18944:6): [True: 0, False: 750]
  ------------------
18945|    750|	    ((WXS_PARTICLE_TERM(particle))->type !=
  ------------------
  |  |  175|    750|#define WXS_PARTICLE_TERM(p) (WXS_PARTICLE(p))->children
  |  |  ------------------
  |  |  |  |  173|    750|#define WXS_PARTICLE(p) WXS_PTC_CAST (p)
  |  |  |  |  ------------------
  |  |  |  |  |  |  126|    750|#define WXS_PTC_CAST (xmlSchemaParticlePtr)
  |  |  |  |  ------------------
  |  |  ------------------
  ------------------
  |  Branch (18945:6): [True: 745, False: 5]
  ------------------
18946|    750|		XML_SCHEMA_TYPE_GROUP))
18947|    745|	{
18948|    745|	    particle = WXS_PTC_CAST particle->next;
  ------------------
  |  |  126|    745|#define WXS_PTC_CAST (xmlSchemaParticlePtr)
  ------------------
18949|    745|	    continue;
18950|    745|	}
18951|      5|	if (WXS_MODELGROUPDEF_MODEL(WXS_PARTICLE_TERM(particle)) == NULL) {
  ------------------
  |  |  183|      5|#define WXS_MODELGROUPDEF_MODEL(mgd) (WXS_MODEL_GROUP_CAST (mgd))->children
  |  |  ------------------
  |  |  |  |  134|      5|#define WXS_MODEL_GROUP_CAST (xmlSchemaModelGroupPtr)
  |  |  ------------------
  ------------------
  |  Branch (18951:6): [True: 0, False: 5]
  ------------------
18952|       |	    /*
18953|       |	    * TODO: Remove the particle.
18954|       |	    */
18955|      0|	    WXS_PARTICLE_TERM(particle) = NULL;
  ------------------
  |  |  175|      0|#define WXS_PARTICLE_TERM(p) (WXS_PARTICLE(p))->children
  |  |  ------------------
  |  |  |  |  173|      0|#define WXS_PARTICLE(p) WXS_PTC_CAST (p)
  |  |  |  |  ------------------
  |  |  |  |  |  |  126|      0|#define WXS_PTC_CAST (xmlSchemaParticlePtr)
  |  |  |  |  ------------------
  |  |  ------------------
  ------------------
18956|      0|	    particle = WXS_PTC_CAST particle->next;
  ------------------
  |  |  126|      0|#define WXS_PTC_CAST (xmlSchemaParticlePtr)
  ------------------
18957|      0|	    continue;
18958|      0|	}
18959|       |	/*
18960|       |	* Assign the model group to the {term} of the particle.
18961|       |	*/
18962|      5|	WXS_PARTICLE_TERM(particle) =
  ------------------
  |  |  175|      5|#define WXS_PARTICLE_TERM(p) (WXS_PARTICLE(p))->children
  |  |  ------------------
  |  |  |  |  173|      5|#define WXS_PARTICLE(p) WXS_PTC_CAST (p)
  |  |  |  |  ------------------
  |  |  |  |  |  |  126|      5|#define WXS_PTC_CAST (xmlSchemaParticlePtr)
  |  |  |  |  ------------------
  |  |  ------------------
  ------------------
18963|      5|	    WXS_TREE_CAST WXS_MODELGROUPDEF_MODEL(WXS_PARTICLE_TERM(particle));
  ------------------
  |  |  125|      5|#define WXS_TREE_CAST (xmlSchemaTreeItemPtr)
  ------------------
              	    WXS_TREE_CAST WXS_MODELGROUPDEF_MODEL(WXS_PARTICLE_TERM(particle));
  ------------------
  |  |  183|      5|#define WXS_MODELGROUPDEF_MODEL(mgd) (WXS_MODEL_GROUP_CAST (mgd))->children
  |  |  ------------------
  |  |  |  |  134|      5|#define WXS_MODEL_GROUP_CAST (xmlSchemaModelGroupPtr)
  |  |  ------------------
  ------------------
18964|       |
18965|      5|	particle = WXS_PTC_CAST particle->next;
  ------------------
  |  |  126|      5|#define WXS_PTC_CAST (xmlSchemaParticlePtr)
  ------------------
18966|      5|    }
18967|    297|}
xmlschemas.c:xmlSchemaAttributeGroupExpandRefs:
19270|     25|{
19271|     25|    if ((attrGr->attrUses == NULL) ||
  ------------------
  |  Branch (19271:9): [True: 19, False: 6]
  ------------------
19272|     25|	(attrGr->flags & XML_SCHEMAS_ATTRGROUP_WILDCARD_BUILDED))
  ------------------
  |  |  326|      6|#define XML_SCHEMAS_ATTRGROUP_WILDCARD_BUILDED 1 << 0
  ------------------
  |  Branch (19272:2): [True: 0, False: 6]
  ------------------
19273|     19|	return(0);
19274|       |
19275|      6|    attrGr->flags |= XML_SCHEMAS_ATTRGROUP_WILDCARD_BUILDED;
  ------------------
  |  |  326|      6|#define XML_SCHEMAS_ATTRGROUP_WILDCARD_BUILDED 1 << 0
  ------------------
19276|      6|    if (xmlSchemaExpandAttributeGroupRefs(pctxt, WXS_BASIC_CAST attrGr,
  ------------------
  |  |  124|      6|#define WXS_BASIC_CAST (xmlSchemaBasicItemPtr)
  ------------------
  |  Branch (19276:9): [True: 0, False: 6]
  ------------------
19277|      6|	&(attrGr->attributeWildcard), attrGr->attrUses, NULL) == -1)
19278|      0|	return(-1);
19279|      6|    return(0);
19280|      6|}
xmlschemas.c:xmlSchemaExpandAttributeGroupRefs:
19103|    160|{
19104|    160|    xmlSchemaAttributeGroupPtr gr;
19105|    160|    xmlSchemaAttributeUsePtr use;
19106|    160|    xmlSchemaItemListPtr sublist;
19107|    160|    int i, j;
19108|    160|    int created = (*completeWild == NULL) ? 0 : 1;
  ------------------
  |  Branch (19108:19): [True: 141, False: 19]
  ------------------
19109|       |
19110|    160|    if (prohibs)
  ------------------
  |  Branch (19110:9): [True: 118, False: 42]
  ------------------
19111|    118|	prohibs->nbItems = 0;
19112|       |
19113|    408|    for (i = 0; i < list->nbItems; i++) {
  ------------------
  |  Branch (19113:17): [True: 248, False: 160]
  ------------------
19114|    248|	use = list->items[i];
19115|       |
19116|    248|	if (use->type == XML_SCHEMA_EXTRA_ATTR_USE_PROHIB) {
  ------------------
  |  Branch (19116:6): [True: 8, False: 240]
  ------------------
19117|      8|	    if (prohibs == NULL) {
  ------------------
  |  Branch (19117:10): [True: 0, False: 8]
  ------------------
19118|      0|		PERROR_INT("xmlSchemaExpandAttributeGroupRefs",
  ------------------
  |  | 2824|      0|#define PERROR_INT(func, msg) xmlSchemaInternalErr(ACTXT_CAST pctxt, func, msg);
  |  |  ------------------
  |  |  |  |  121|      0|#define ACTXT_CAST (xmlSchemaAbstractCtxtPtr)
  |  |  ------------------
  ------------------
19119|      0|		    "unexpected attr prohibition found");
19120|      0|		return(-1);
19121|      0|	    }
19122|       |	    /*
19123|       |	    * Remove from attribute uses.
19124|       |	    */
19125|      8|	    if (xmlSchemaItemListRemove(list, i) == -1)
  ------------------
  |  Branch (19125:10): [True: 0, False: 8]
  ------------------
19126|      0|		return(-1);
19127|      8|	    i--;
19128|       |	    /*
19129|       |	    * Note that duplicate prohibitions were already
19130|       |	    * handled at parsing time.
19131|       |	    */
19132|       |	    /*
19133|       |	    * Add to list of prohibitions.
19134|       |	    */
19135|      8|	    xmlSchemaItemListAddSize(prohibs, 2, use);
19136|      8|	    continue;
19137|      8|	}
19138|    240|	if ((use->type == XML_SCHEMA_EXTRA_QNAMEREF) &&
  ------------------
  |  Branch (19138:6): [True: 51, False: 189]
  ------------------
19139|    240|	    ((WXS_QNAME_CAST use)->itemType == XML_SCHEMA_TYPE_ATTRIBUTEGROUP))
  ------------------
  |  |  136|     51|#define WXS_QNAME_CAST (xmlSchemaQNameRefPtr)
  ------------------
  |  Branch (19139:6): [True: 51, False: 0]
  ------------------
19140|     51|	{
19141|     51|	    if ((WXS_QNAME_CAST use)->item == NULL)
  ------------------
  |  |  136|     51|#define WXS_QNAME_CAST (xmlSchemaQNameRefPtr)
  ------------------
  |  Branch (19141:10): [True: 0, False: 51]
  ------------------
19142|      0|		return(-1);
19143|     51|	    gr = WXS_ATTR_GROUP_CAST (WXS_QNAME_CAST use)->item;
  ------------------
  |  |  129|     51|#define WXS_ATTR_GROUP_CAST (xmlSchemaAttributeGroupPtr)
  ------------------
              	    gr = WXS_ATTR_GROUP_CAST (WXS_QNAME_CAST use)->item;
  ------------------
  |  |  136|     51|#define WXS_QNAME_CAST (xmlSchemaQNameRefPtr)
  ------------------
19144|       |	    /*
19145|       |	    * Expand the referenced attr. group.
19146|       |	    * TODO: remove this, this is done in a previous step, so
19147|       |	    * already done here.
19148|       |	    */
19149|     51|	    if ((gr->flags & XML_SCHEMAS_ATTRGROUP_WILDCARD_BUILDED) == 0) {
  ------------------
  |  |  326|     51|#define XML_SCHEMAS_ATTRGROUP_WILDCARD_BUILDED 1 << 0
  ------------------
  |  Branch (19149:10): [True: 24, False: 27]
  ------------------
19150|     24|		if (xmlSchemaAttributeGroupExpandRefs(pctxt, gr) == -1)
  ------------------
  |  Branch (19150:7): [True: 0, False: 24]
  ------------------
19151|      0|		    return(-1);
19152|     24|	    }
19153|       |	    /*
19154|       |	    * Build the 'complete' wildcard; i.e. intersect multiple
19155|       |	    * wildcards.
19156|       |	    */
19157|     51|	    if (gr->attributeWildcard != NULL) {
  ------------------
  |  Branch (19157:10): [True: 19, False: 32]
  ------------------
19158|     19|		if (*completeWild == NULL) {
  ------------------
  |  Branch (19158:7): [True: 0, False: 19]
  ------------------
19159|      0|		    *completeWild = gr->attributeWildcard;
19160|     19|		} else {
19161|     19|		    if (! created) {
  ------------------
  |  Branch (19161:11): [True: 0, False: 19]
  ------------------
19162|      0|			xmlSchemaWildcardPtr tmpWild;
19163|       |
19164|       |			 /*
19165|       |			* Copy the first encountered wildcard as context,
19166|       |			* except for the annotation.
19167|       |			*
19168|       |			* Although the complete wildcard might not correspond
19169|       |			* to any node in the schema, we will anchor it on
19170|       |			* the node of the owner component.
19171|       |			*/
19172|      0|			tmpWild =  xmlSchemaAddWildcard(pctxt, pctxt->schema,
19173|      0|			    XML_SCHEMA_TYPE_ANY_ATTRIBUTE,
19174|      0|			    WXS_ITEM_NODE(item));
  ------------------
  |  |  142|      0|#define WXS_ITEM_NODE(i) xmlSchemaGetComponentNode(WXS_BASIC_CAST (i))
  |  |  ------------------
  |  |  |  |  124|      0|#define WXS_BASIC_CAST (xmlSchemaBasicItemPtr)
  |  |  ------------------
  ------------------
19175|      0|			if (tmpWild == NULL)
  ------------------
  |  Branch (19175:8): [True: 0, False: 0]
  ------------------
19176|      0|			    return(-1);
19177|      0|			if (xmlSchemaCloneWildcardNsConstraints(pctxt,
  ------------------
  |  Branch (19177:8): [True: 0, False: 0]
  ------------------
19178|      0|			    tmpWild, *completeWild) == -1)
19179|      0|			    return (-1);
19180|      0|			tmpWild->processContents = (*completeWild)->processContents;
19181|      0|			*completeWild = tmpWild;
19182|      0|			created = 1;
19183|      0|		    }
19184|       |
19185|     19|		    if (xmlSchemaIntersectWildcards(pctxt, *completeWild,
  ------------------
  |  Branch (19185:11): [True: 0, False: 19]
  ------------------
19186|     19|			gr->attributeWildcard) == -1)
19187|      0|			return(-1);
19188|     19|		}
19189|     19|	    }
19190|       |	    /*
19191|       |	    * Just remove the reference if the referenced group does not
19192|       |	    * contain any attribute uses.
19193|       |	    */
19194|     51|	    sublist = ((xmlSchemaItemListPtr) gr->attrUses);
19195|     51|	    if ((sublist == NULL) || sublist->nbItems == 0) {
  ------------------
  |  Branch (19195:10): [True: 19, False: 32]
  |  Branch (19195:31): [True: 0, False: 32]
  ------------------
19196|     19|		if (xmlSchemaItemListRemove(list, i) == -1)
  ------------------
  |  Branch (19196:7): [True: 0, False: 19]
  ------------------
19197|      0|		    return(-1);
19198|     19|		i--;
19199|     19|		continue;
19200|     19|	    }
19201|       |	    /*
19202|       |	    * Add the attribute uses.
19203|       |	    */
19204|     32|	    list->items[i] = sublist->items[0];
19205|     32|	    if (sublist->nbItems != 1) {
  ------------------
  |  Branch (19205:10): [True: 8, False: 24]
  ------------------
19206|     17|		for (j = 1; j < sublist->nbItems; j++) {
  ------------------
  |  Branch (19206:15): [True: 9, False: 8]
  ------------------
19207|      9|		    i++;
19208|      9|		    if (xmlSchemaItemListInsert(list,
  ------------------
  |  Branch (19208:11): [True: 0, False: 9]
  ------------------
19209|      9|			    sublist->items[j], i) == -1)
19210|      0|			return(-1);
19211|      9|		}
19212|      8|	    }
19213|     32|	}
19214|       |
19215|    240|    }
19216|       |    /*
19217|       |    * Handle pointless prohibitions of declared attributes.
19218|       |    */
19219|    160|    if (prohibs && (prohibs->nbItems != 0) && (list->nbItems != 0)) {
  ------------------
  |  Branch (19219:9): [True: 118, False: 42]
  |  Branch (19219:20): [True: 3, False: 115]
  |  Branch (19219:47): [True: 2, False: 1]
  ------------------
19220|      2|	xmlSchemaAttributeUseProhibPtr prohib;
19221|       |
19222|      9|	for (i = prohibs->nbItems -1; i >= 0; i--) {
  ------------------
  |  Branch (19222:32): [True: 7, False: 2]
  ------------------
19223|      7|	    prohib = prohibs->items[i];
19224|     57|	    for (j = 0; j < list->nbItems; j++) {
  ------------------
  |  Branch (19224:18): [True: 50, False: 7]
  ------------------
19225|     50|		use = list->items[j];
19226|       |
19227|     50|		if ((prohib->name == WXS_ATTRUSE_DECL_NAME(use)) &&
  ------------------
  |  |  162|     50|#define WXS_ATTRUSE_DECL_NAME(au) (WXS_ATTRUSE_DECL(au))->name
  |  |  ------------------
  |  |  |  |  158|     50|#define WXS_ATTRUSE_DECL(au) (WXS_ATTR_USE_CAST (au))->attrDecl
  |  |  |  |  ------------------
  |  |  |  |  |  |  131|     50|#define WXS_ATTR_USE_CAST (xmlSchemaAttributeUsePtr)
  |  |  |  |  ------------------
  |  |  ------------------
  ------------------
  |  Branch (19227:7): [True: 0, False: 50]
  ------------------
19228|     50|		    (prohib->targetNamespace == WXS_ATTRUSE_DECL_TNS(use)))
  ------------------
  |  |  164|      0|#define WXS_ATTRUSE_DECL_TNS(au) (WXS_ATTRUSE_DECL(au))->targetNamespace
  |  |  ------------------
  |  |  |  |  158|      0|#define WXS_ATTRUSE_DECL(au) (WXS_ATTR_USE_CAST (au))->attrDecl
  |  |  |  |  ------------------
  |  |  |  |  |  |  131|      0|#define WXS_ATTR_USE_CAST (xmlSchemaAttributeUsePtr)
  |  |  |  |  ------------------
  |  |  ------------------
  ------------------
  |  Branch (19228:7): [True: 0, False: 0]
  ------------------
19229|      0|		{
19230|      0|		    xmlChar *str = NULL;
19231|       |
19232|      0|		    xmlSchemaCustomWarning(ACTXT_CAST pctxt,
  ------------------
  |  |  121|      0|#define ACTXT_CAST (xmlSchemaAbstractCtxtPtr)
  ------------------
19233|      0|			XML_SCHEMAP_WARN_ATTR_POINTLESS_PROH,
19234|      0|			prohib->node, NULL,
19235|      0|			"Skipping pointless attribute use prohibition "
19236|      0|			"'%s', since a corresponding attribute use "
19237|      0|			"exists already in the type definition",
19238|      0|			xmlSchemaFormatQName(&str,
19239|      0|			    prohib->targetNamespace, prohib->name),
19240|      0|			NULL, NULL);
19241|      0|		    FREE_AND_NULL(str);
  ------------------
  |  |  320|      0|#define FREE_AND_NULL(str) if ((str) != NULL) { xmlFree((xmlChar *) (str)); str = NULL; }
  |  |  ------------------
  |  |  |  Branch (320:32): [True: 0, False: 0]
  |  |  ------------------
  ------------------
19242|       |		    /*
19243|       |		    * Remove the prohibition.
19244|       |		    */
19245|      0|		    if (xmlSchemaItemListRemove(prohibs, i) == -1)
  ------------------
  |  Branch (19245:11): [True: 0, False: 0]
  ------------------
19246|      0|			return(-1);
19247|      0|		    break;
19248|      0|		}
19249|     50|	    }
19250|      7|	}
19251|      2|    }
19252|    160|    return(0);
19253|    160|}
xmlschemas.c:xmlSchemaItemListRemove:
 3532|     28|{
 3533|     28|    int i;
 3534|     28|    if ((list->items == NULL) || (idx >= list->nbItems)) {
  ------------------
  |  Branch (3534:9): [True: 0, False: 28]
  |  Branch (3534:34): [True: 0, False: 28]
  ------------------
 3535|      0|	xmlSchemaPSimpleErr("Internal error: xmlSchemaItemListRemove, "
 3536|      0|	    "index error.\n");
 3537|      0|	return(-1);
 3538|      0|    }
 3539|       |
 3540|     28|    if (list->nbItems == 1) {
  ------------------
  |  Branch (3540:9): [True: 19, False: 9]
  ------------------
 3541|       |	/* TODO: Really free the list? */
 3542|     19|	xmlFree(list->items);
 3543|     19|	list->items = NULL;
 3544|     19|	list->nbItems = 0;
 3545|     19|	list->sizeItems = 0;
 3546|     19|    } else if (list->nbItems -1 == idx) {
  ------------------
  |  Branch (3546:16): [True: 3, False: 6]
  ------------------
 3547|      3|	list->nbItems--;
 3548|      6|    } else {
 3549|     28|	for (i = idx; i < list->nbItems -1; i++)
  ------------------
  |  Branch (3549:16): [True: 22, False: 6]
  ------------------
 3550|     22|	    list->items[i] = list->items[i+1];
 3551|      6|	list->nbItems--;
 3552|      6|    }
 3553|     28|    return(0);
 3554|     28|}
xmlschemas.c:xmlSchemaCloneWildcardNsConstraints:
13449|      4|{
13450|      4|    xmlSchemaWildcardNsPtr cur, tmp, last;
13451|       |
13452|      4|    if ((source == NULL) || (dest == NULL))
  ------------------
  |  Branch (13452:9): [True: 0, False: 4]
  |  Branch (13452:29): [True: 0, False: 4]
  ------------------
13453|      0|	return(-1);
13454|      4|    dest->any = source->any;
13455|      4|    cur = source->nsSet;
13456|      4|    last = NULL;
13457|     13|    while (cur != NULL) {
  ------------------
  |  Branch (13457:12): [True: 9, False: 4]
  ------------------
13458|      9|	tmp = xmlSchemaNewWildcardNsConstraint(ctxt);
13459|      9|	if (tmp == NULL)
  ------------------
  |  Branch (13459:6): [True: 0, False: 9]
  ------------------
13460|      0|	    return(-1);
13461|      9|	tmp->value = cur->value;
13462|      9|	if (last == NULL)
  ------------------
  |  Branch (13462:6): [True: 4, False: 5]
  ------------------
13463|      4|	    dest->nsSet = tmp;
13464|      5|	else
13465|      5|	    last->next = tmp;
13466|      9|	last = tmp;
13467|      9|	cur = cur->next;
13468|      9|    }
13469|      4|    if (dest->negNsSet != NULL)
  ------------------
  |  Branch (13469:9): [True: 1, False: 3]
  ------------------
13470|      1|	xmlSchemaFreeWildcardNsSet(dest->negNsSet);
13471|      4|    if (source->negNsSet != NULL) {
  ------------------
  |  Branch (13471:9): [True: 0, False: 4]
  ------------------
13472|      0|	dest->negNsSet = xmlSchemaNewWildcardNsConstraint(ctxt);
13473|      0|	if (dest->negNsSet == NULL)
  ------------------
  |  Branch (13473:6): [True: 0, False: 0]
  ------------------
13474|      0|	    return(-1);
13475|      0|	dest->negNsSet->value = source->negNsSet->value;
13476|      0|    } else
13477|      4|	dest->negNsSet = NULL;
13478|      4|    return(0);
13479|      4|}
xmlschemas.c:xmlSchemaIntersectWildcards:
13756|     19|{
13757|     19|    xmlSchemaWildcardNsPtr cur, curB, prev,  tmp;
13758|       |
13759|       |    /*
13760|       |    * 1 If O1 and O2 are the same value, then that value must be the
13761|       |    * value.
13762|       |    */
13763|     19|    if ((completeWild->any == curWild->any) &&
  ------------------
  |  Branch (13763:9): [True: 16, False: 3]
  ------------------
13764|     19|	((completeWild->nsSet == NULL) == (curWild->nsSet == NULL)) &&
  ------------------
  |  Branch (13764:2): [True: 15, False: 1]
  ------------------
13765|     19|	((completeWild->negNsSet == NULL) == (curWild->negNsSet == NULL))) {
  ------------------
  |  Branch (13765:2): [True: 15, False: 0]
  ------------------
13766|       |
13767|     15|	if ((completeWild->negNsSet == NULL) ||
  ------------------
  |  Branch (13767:6): [True: 13, False: 2]
  ------------------
13768|     15|	    (completeWild->negNsSet->value == curWild->negNsSet->value)) {
  ------------------
  |  Branch (13768:6): [True: 1, False: 1]
  ------------------
13769|       |
13770|     14|	    if (completeWild->nsSet != NULL) {
  ------------------
  |  Branch (13770:10): [True: 10, False: 4]
  ------------------
13771|     10|		int found = 0;
13772|       |
13773|       |		/*
13774|       |		* Check equality of sets.
13775|       |		*/
13776|     10|		cur = completeWild->nsSet;
13777|     28|		while (cur != NULL) {
  ------------------
  |  Branch (13777:10): [True: 19, False: 9]
  ------------------
13778|     19|		    found = 0;
13779|     19|		    curB = curWild->nsSet;
13780|     34|		    while (curB != NULL) {
  ------------------
  |  Branch (13780:14): [True: 33, False: 1]
  ------------------
13781|     33|			if (cur->value == curB->value) {
  ------------------
  |  Branch (13781:8): [True: 18, False: 15]
  ------------------
13782|     18|			    found = 1;
13783|     18|			    break;
13784|     18|			}
13785|     15|			curB = curB->next;
13786|     15|		    }
13787|     19|		    if (!found)
  ------------------
  |  Branch (13787:11): [True: 1, False: 18]
  ------------------
13788|      1|			break;
13789|     18|		    cur = cur->next;
13790|     18|		}
13791|     10|		if (found)
  ------------------
  |  Branch (13791:7): [True: 9, False: 1]
  ------------------
13792|      9|		    return(0);
13793|     10|	    } else
13794|      4|		return(0);
13795|     14|	}
13796|     15|    }
13797|       |    /*
13798|       |    * 2 If either O1 or O2 is any, then the other must be the value.
13799|       |    */
13800|      6|    if ((completeWild->any != curWild->any) && (completeWild->any)) {
  ------------------
  |  Branch (13800:9): [True: 3, False: 3]
  |  Branch (13800:48): [True: 3, False: 0]
  ------------------
13801|      3|	if (xmlSchemaCloneWildcardNsConstraints(ctxt, completeWild, curWild) == -1)
  ------------------
  |  Branch (13801:6): [True: 0, False: 3]
  ------------------
13802|      0|	    return(-1);
13803|      3|	return(0);
13804|      3|    }
13805|       |    /*
13806|       |    * 3 If either O1 or O2 is a pair of not and a value (a namespace
13807|       |    * name or `absent`) and the other is a set of (namespace names or
13808|       |    * `absent`), then that set, minus the negated value if it was in
13809|       |    * the set, minus `absent` if it was in the set, must be the value.
13810|       |    */
13811|      3|    if (((completeWild->negNsSet != NULL) && (curWild->nsSet != NULL)) ||
  ------------------
  |  Branch (13811:10): [True: 2, False: 1]
  |  Branch (13811:46): [True: 1, False: 1]
  ------------------
13812|      3|	((curWild->negNsSet != NULL) && (completeWild->nsSet != NULL))) {
  ------------------
  |  Branch (13812:3): [True: 1, False: 1]
  |  Branch (13812:34): [True: 0, False: 1]
  ------------------
13813|      1|	const xmlChar *neg;
13814|       |
13815|      1|	if (completeWild->nsSet == NULL) {
  ------------------
  |  Branch (13815:6): [True: 1, False: 0]
  ------------------
13816|      1|	    neg = completeWild->negNsSet->value;
13817|      1|	    if (xmlSchemaCloneWildcardNsConstraints(ctxt, completeWild, curWild) == -1)
  ------------------
  |  Branch (13817:10): [True: 0, False: 1]
  ------------------
13818|      0|		return(-1);
13819|      1|	} else
13820|      0|	    neg = curWild->negNsSet->value;
13821|       |	/*
13822|       |	* Remove absent and negated.
13823|       |	*/
13824|      1|	prev = NULL;
13825|      1|	cur = completeWild->nsSet;
13826|      1|	while (cur != NULL) {
  ------------------
  |  Branch (13826:9): [True: 1, False: 0]
  ------------------
13827|      1|	    if (cur->value == NULL) {
  ------------------
  |  Branch (13827:10): [True: 1, False: 0]
  ------------------
13828|      1|		if (prev == NULL)
  ------------------
  |  Branch (13828:7): [True: 1, False: 0]
  ------------------
13829|      1|		    completeWild->nsSet = cur->next;
13830|      0|		else
13831|      0|		    prev->next = cur->next;
13832|      1|		xmlFree(cur);
13833|      1|		break;
13834|      1|	    }
13835|      0|	    prev = cur;
13836|      0|	    cur = cur->next;
13837|      0|	}
13838|      1|	if (neg != NULL) {
  ------------------
  |  Branch (13838:6): [True: 1, False: 0]
  ------------------
13839|      1|	    prev = NULL;
13840|      1|	    cur = completeWild->nsSet;
13841|      1|	    while (cur != NULL) {
  ------------------
  |  Branch (13841:13): [True: 1, False: 0]
  ------------------
13842|      1|		if (cur->value == neg) {
  ------------------
  |  Branch (13842:7): [True: 1, False: 0]
  ------------------
13843|      1|		    if (prev == NULL)
  ------------------
  |  Branch (13843:11): [True: 1, False: 0]
  ------------------
13844|      1|			completeWild->nsSet = cur->next;
13845|      0|		    else
13846|      0|			prev->next = cur->next;
13847|      1|		    xmlFree(cur);
13848|      1|		    break;
13849|      1|		}
13850|      0|		prev = cur;
13851|      0|		cur = cur->next;
13852|      0|	    }
13853|      1|	}
13854|       |
13855|      1|	return(0);
13856|      1|    }
13857|       |    /*
13858|       |    * 4 If both O1 and O2 are sets of (namespace names or `absent`),
13859|       |    * then the intersection of those sets must be the value.
13860|       |    */
13861|      2|    if ((completeWild->nsSet != NULL) && (curWild->nsSet != NULL)) {
  ------------------
  |  Branch (13861:9): [True: 1, False: 1]
  |  Branch (13861:42): [True: 1, False: 0]
  ------------------
13862|      1|	int found;
13863|       |
13864|      1|	cur = completeWild->nsSet;
13865|      1|	prev = NULL;
13866|      4|	while (cur != NULL) {
  ------------------
  |  Branch (13866:9): [True: 3, False: 1]
  ------------------
13867|      3|	    found = 0;
13868|      3|	    curB = curWild->nsSet;
13869|      6|	    while (curB != NULL) {
  ------------------
  |  Branch (13869:13): [True: 5, False: 1]
  ------------------
13870|      5|		if (cur->value == curB->value) {
  ------------------
  |  Branch (13870:7): [True: 2, False: 3]
  ------------------
13871|      2|		    found = 1;
13872|      2|		    break;
13873|      2|		}
13874|      3|		curB = curB->next;
13875|      3|	    }
13876|      3|	    if (!found) {
  ------------------
  |  Branch (13876:10): [True: 1, False: 2]
  ------------------
13877|      1|		if (prev == NULL)
  ------------------
  |  Branch (13877:7): [True: 0, False: 1]
  ------------------
13878|      0|		    completeWild->nsSet = cur->next;
13879|      1|		else
13880|      1|		    prev->next = cur->next;
13881|      1|		tmp = cur->next;
13882|      1|		xmlFree(cur);
13883|      1|		cur = tmp;
13884|      1|		continue;
13885|      1|	    }
13886|      2|	    prev = cur;
13887|      2|	    cur = cur->next;
13888|      2|	}
13889|       |
13890|      1|	return(0);
13891|      1|    }
13892|       |    /* 5 If the two are negations of different namespace names,
13893|       |    * then the intersection is not expressible
13894|       |    */
13895|      1|    if ((completeWild->negNsSet != NULL) &&
  ------------------
  |  Branch (13895:9): [True: 1, False: 0]
  ------------------
13896|      1|	(curWild->negNsSet != NULL) &&
  ------------------
  |  Branch (13896:2): [True: 1, False: 0]
  ------------------
13897|      1|	(completeWild->negNsSet->value != curWild->negNsSet->value) &&
  ------------------
  |  Branch (13897:2): [True: 1, False: 0]
  ------------------
13898|      1|	(completeWild->negNsSet->value != NULL) &&
  ------------------
  |  Branch (13898:2): [True: 1, False: 0]
  ------------------
13899|      1|	(curWild->negNsSet->value != NULL)) {
  ------------------
  |  Branch (13899:2): [True: 0, False: 1]
  ------------------
13900|       |
13901|      0|	xmlSchemaPErr(ctxt, completeWild->node, XML_SCHEMAP_INTERSECTION_NOT_EXPRESSIBLE,
13902|      0|	    "The intersection of the wildcard is not expressible.\n",
13903|      0|	    NULL, NULL);
13904|      0|	return(XML_SCHEMAP_INTERSECTION_NOT_EXPRESSIBLE);
13905|      0|    }
13906|       |    /*
13907|       |    * 6 If the one is a negation of a namespace name and the other
13908|       |    * is a negation of `absent`, then the one which is the negation
13909|       |    * of a namespace name must be the value.
13910|       |    */
13911|      1|    if ((completeWild->negNsSet != NULL) && (curWild->negNsSet != NULL) &&
  ------------------
  |  Branch (13911:9): [True: 1, False: 0]
  |  Branch (13911:45): [True: 1, False: 0]
  ------------------
13912|      1|	(completeWild->negNsSet->value != curWild->negNsSet->value) &&
  ------------------
  |  Branch (13912:2): [True: 1, False: 0]
  ------------------
13913|      1|	(completeWild->negNsSet->value == NULL)) {
  ------------------
  |  Branch (13913:2): [True: 0, False: 1]
  ------------------
13914|      0|	completeWild->negNsSet->value =  curWild->negNsSet->value;
13915|      0|    }
13916|      1|    return(0);
13917|      1|}
xmlschemas.c:xmlSchemaItemListInsert:
 3459|      9|{
 3460|      9|    if (list->sizeItems <= list->nbItems) {
  ------------------
  |  Branch (3460:9): [True: 2, False: 7]
  ------------------
 3461|      2|        void **tmp;
 3462|      2|        size_t newSize = list->sizeItems == 0 ? 20 : list->sizeItems * 2;
  ------------------
  |  Branch (3462:26): [True: 0, False: 2]
  ------------------
 3463|       |
 3464|      2|	tmp = (void **) xmlRealloc(list->items, newSize * sizeof(void *));
 3465|      2|	if (tmp == NULL) {
  ------------------
  |  Branch (3465:6): [True: 0, False: 2]
  ------------------
 3466|      0|	    xmlSchemaPErrMemory(NULL, "growing item list", NULL);
 3467|      0|	    return(-1);
 3468|      0|	}
 3469|      2|        list->items = tmp;
 3470|      2|	list->sizeItems = newSize;
 3471|      2|    }
 3472|       |    /*
 3473|       |    * Just append if the index is greater/equal than the item count.
 3474|       |    */
 3475|      9|    if (idx >= list->nbItems) {
  ------------------
  |  Branch (3475:9): [True: 8, False: 1]
  ------------------
 3476|      8|	list->items[list->nbItems++] = item;
 3477|      8|    } else {
 3478|      1|	int i;
 3479|      2|	for (i = list->nbItems; i > idx; i--)
  ------------------
  |  Branch (3479:26): [True: 1, False: 1]
  ------------------
 3480|      1|	    list->items[i] = list->items[i-1];
 3481|      1|	list->items[idx] = item;
 3482|      1|	list->nbItems++;
 3483|      1|    }
 3484|      9|    return(0);
 3485|      9|}
xmlschemas.c:xmlSchemaFixupSimpleTypeStageOne:
17938|    162|{
17939|    162|    if (type->type != XML_SCHEMA_TYPE_SIMPLE)
  ------------------
  |  Branch (17939:9): [True: 0, False: 162]
  ------------------
17940|      0|	return(0);
17941|    162|    if (! WXS_IS_TYPE_NOT_FIXED_1(type))
  ------------------
  |  |  236|    162|    (((item)->type != XML_SCHEMA_TYPE_BASIC) && \
  |  |  ------------------
  |  |  |  Branch (236:6): [True: 162, False: 0]
  |  |  ------------------
  |  |  237|    162|     (((item)->flags & XML_SCHEMAS_TYPE_FIXUP_1) == 0))
  |  |  ------------------
  |  |  |  |  582|    162|#define XML_SCHEMAS_TYPE_FIXUP_1    1 << 29
  |  |  ------------------
  |  |  |  Branch (237:6): [True: 162, False: 0]
  |  |  ------------------
  ------------------
17942|      0|	return(0);
17943|    162|    type->flags |= XML_SCHEMAS_TYPE_FIXUP_1;
  ------------------
  |  |  582|    162|#define XML_SCHEMAS_TYPE_FIXUP_1    1 << 29
  ------------------
17944|       |
17945|    162|    if (WXS_IS_LIST(type)) {
  ------------------
  |  |  272|    162|#define WXS_IS_LIST(t) (t->flags & XML_SCHEMAS_TYPE_VARIETY_LIST)
  |  |  ------------------
  |  |  |  |  448|    162|#define XML_SCHEMAS_TYPE_VARIETY_LIST    1 << 6
  |  |  ------------------
  |  |  |  Branch (272:24): [True: 11, False: 151]
  |  |  ------------------
  ------------------
17946|       |	/*
17947|       |	* Corresponds to <simpleType><list>...
17948|       |	*/
17949|     11|	if (type->subtypes == NULL) {
  ------------------
  |  Branch (17949:6): [True: 0, False: 11]
  ------------------
17950|       |	    /*
17951|       |	    * This one is really needed, so get out.
17952|       |	    */
17953|      0|	    PERROR_INT("xmlSchemaFixupSimpleTypeStageOne",
  ------------------
  |  | 2824|      0|#define PERROR_INT(func, msg) xmlSchemaInternalErr(ACTXT_CAST pctxt, func, msg);
  |  |  ------------------
  |  |  |  |  121|      0|#define ACTXT_CAST (xmlSchemaAbstractCtxtPtr)
  |  |  ------------------
  ------------------
17954|      0|		"list type has no item-type assigned");
17955|      0|	    return(-1);
17956|      0|	}
17957|    151|    } else if (WXS_IS_UNION(type)) {
  ------------------
  |  |  274|    151|#define WXS_IS_UNION(t) (t->flags & XML_SCHEMAS_TYPE_VARIETY_UNION)
  |  |  ------------------
  |  |  |  |  454|    151|#define XML_SCHEMAS_TYPE_VARIETY_UNION    1 << 7
  |  |  ------------------
  |  |  |  Branch (274:25): [True: 25, False: 126]
  |  |  ------------------
  ------------------
17958|       |	/*
17959|       |	* Corresponds to <simpleType><union>...
17960|       |	*/
17961|     25|	if (type->memberTypes == NULL) {
  ------------------
  |  Branch (17961:6): [True: 0, False: 25]
  ------------------
17962|       |	    /*
17963|       |	    * This one is really needed, so get out.
17964|       |	    */
17965|      0|	    PERROR_INT("xmlSchemaFixupSimpleTypeStageOne",
  ------------------
  |  | 2824|      0|#define PERROR_INT(func, msg) xmlSchemaInternalErr(ACTXT_CAST pctxt, func, msg);
  |  |  ------------------
  |  |  |  |  121|      0|#define ACTXT_CAST (xmlSchemaAbstractCtxtPtr)
  |  |  ------------------
  ------------------
17966|      0|		"union type has no member-types assigned");
17967|      0|	    return(-1);
17968|      0|	}
17969|    126|    } else {
17970|       |	/*
17971|       |	* Corresponds to <simpleType><restriction>...
17972|       |	*/
17973|    126|	if (type->baseType == NULL) {
  ------------------
  |  Branch (17973:6): [True: 0, False: 126]
  ------------------
17974|      0|	    PERROR_INT("xmlSchemaFixupSimpleTypeStageOne",
  ------------------
  |  | 2824|      0|#define PERROR_INT(func, msg) xmlSchemaInternalErr(ACTXT_CAST pctxt, func, msg);
  |  |  ------------------
  |  |  |  |  121|      0|#define ACTXT_CAST (xmlSchemaAbstractCtxtPtr)
  |  |  ------------------
  ------------------
17975|      0|		"type has no base-type assigned");
17976|      0|	    return(-1);
17977|      0|	}
17978|    126|	if (WXS_IS_TYPE_NOT_FIXED_1(type->baseType))
  ------------------
  |  |  236|    126|    (((item)->type != XML_SCHEMA_TYPE_BASIC) && \
  |  |  ------------------
  |  |  |  Branch (236:6): [True: 15, False: 111]
  |  |  ------------------
  |  |  237|    126|     (((item)->flags & XML_SCHEMAS_TYPE_FIXUP_1) == 0))
  |  |  ------------------
  |  |  |  |  582|     15|#define XML_SCHEMAS_TYPE_FIXUP_1    1 << 29
  |  |  ------------------
  |  |  |  Branch (237:6): [True: 11, False: 4]
  |  |  ------------------
  ------------------
17979|     11|	    if (xmlSchemaFixupSimpleTypeStageOne(pctxt, type->baseType) == -1)
  ------------------
  |  Branch (17979:10): [True: 0, False: 11]
  ------------------
17980|      0|		return(-1);
17981|       |	/*
17982|       |	* Variety
17983|       |	* If the <restriction> alternative is chosen, then the
17984|       |	* {variety} of the {base type definition}.
17985|       |	*/
17986|    126|	if (WXS_IS_ATOMIC(type->baseType))
  ------------------
  |  |  270|    126|#define WXS_IS_ATOMIC(t) (t->flags & XML_SCHEMAS_TYPE_VARIETY_ATOMIC)
  |  |  ------------------
  |  |  |  |  460|    126|#define XML_SCHEMAS_TYPE_VARIETY_ATOMIC    1 << 8
  |  |  ------------------
  |  |  |  Branch (270:26): [True: 114, False: 12]
  |  |  ------------------
  ------------------
17987|    114|	    type->flags |= XML_SCHEMAS_TYPE_VARIETY_ATOMIC;
  ------------------
  |  |  460|    114|#define XML_SCHEMAS_TYPE_VARIETY_ATOMIC    1 << 8
  ------------------
17988|     12|	else if (WXS_IS_LIST(type->baseType)) {
  ------------------
  |  |  272|     12|#define WXS_IS_LIST(t) (t->flags & XML_SCHEMAS_TYPE_VARIETY_LIST)
  |  |  ------------------
  |  |  |  |  448|     12|#define XML_SCHEMAS_TYPE_VARIETY_LIST    1 << 6
  |  |  ------------------
  |  |  |  Branch (272:24): [True: 10, False: 2]
  |  |  ------------------
  ------------------
17989|     10|	    type->flags |= XML_SCHEMAS_TYPE_VARIETY_LIST;
  ------------------
  |  |  448|     10|#define XML_SCHEMAS_TYPE_VARIETY_LIST    1 << 6
  ------------------
17990|       |	    /*
17991|       |	    * Inherit the itemType.
17992|       |	    */
17993|     10|	    type->subtypes = type->baseType->subtypes;
17994|     10|	} else if (WXS_IS_UNION(type->baseType)) {
  ------------------
  |  |  274|      2|#define WXS_IS_UNION(t) (t->flags & XML_SCHEMAS_TYPE_VARIETY_UNION)
  |  |  ------------------
  |  |  |  |  454|      2|#define XML_SCHEMAS_TYPE_VARIETY_UNION    1 << 7
  |  |  ------------------
  |  |  |  Branch (274:25): [True: 2, False: 0]
  |  |  ------------------
  ------------------
17995|      2|	    type->flags |= XML_SCHEMAS_TYPE_VARIETY_UNION;
  ------------------
  |  |  454|      2|#define XML_SCHEMAS_TYPE_VARIETY_UNION    1 << 7
  ------------------
17996|       |	    /*
17997|       |	    * NOTE that we won't assign the memberTypes of the base,
17998|       |	    * since this will make trouble when freeing them; we will
17999|       |	    * use a lookup function to access them instead.
18000|       |	    */
18001|      2|	}
18002|    126|    }
18003|    162|    return(0);
18004|    162|}
xmlschemas.c:xmlSchemaCheckUnionTypeDefCircular:
15014|     25|{
15015|     25|    if (! WXS_IS_UNION(type))
  ------------------
  |  |  274|     25|#define WXS_IS_UNION(t) (t->flags & XML_SCHEMAS_TYPE_VARIETY_UNION)
  |  |  ------------------
  |  |  |  |  454|     25|#define XML_SCHEMAS_TYPE_VARIETY_UNION    1 << 7
  |  |  ------------------
  ------------------
  |  Branch (15015:9): [True: 0, False: 25]
  ------------------
15016|      0|	return(0);
15017|     25|    return(xmlSchemaCheckUnionTypeDefCircularRecur(pctxt, type,
15018|     25|	type->memberTypes));
15019|     25|}
xmlschemas.c:xmlSchemaCheckUnionTypeDefCircularRecur:
14976|     38|{
14977|     38|    xmlSchemaTypeLinkPtr member;
14978|     38|    xmlSchemaTypePtr memberType;
14979|       |
14980|     38|    member = members;
14981|    146|    while (member != NULL) {
  ------------------
  |  Branch (14981:12): [True: 108, False: 38]
  ------------------
14982|    108|	memberType = member->type;
14983|    130|	while ((memberType != NULL) &&
  ------------------
  |  Branch (14983:9): [True: 130, False: 0]
  ------------------
14984|    130|	    (memberType->type != XML_SCHEMA_TYPE_BASIC)) {
  ------------------
  |  Branch (14984:6): [True: 22, False: 108]
  ------------------
14985|     22|	    if (memberType == ctxType) {
  ------------------
  |  Branch (14985:10): [True: 0, False: 22]
  ------------------
14986|      0|		xmlSchemaPCustomErr(pctxt,
14987|      0|		    XML_SCHEMAP_SRC_SIMPLE_TYPE_4,
14988|      0|		    WXS_BASIC_CAST ctxType, NULL,
  ------------------
  |  |  124|      0|#define WXS_BASIC_CAST (xmlSchemaBasicItemPtr)
  ------------------
14989|      0|		    "The union type definition is circular", NULL);
14990|      0|		return (XML_SCHEMAP_SRC_SIMPLE_TYPE_4);
14991|      0|	    }
14992|     22|	    if ((WXS_IS_UNION(memberType)) &&
  ------------------
  |  |  274|     22|#define WXS_IS_UNION(t) (t->flags & XML_SCHEMAS_TYPE_VARIETY_UNION)
  |  |  ------------------
  |  |  |  |  454|     22|#define XML_SCHEMAS_TYPE_VARIETY_UNION    1 << 7
  |  |  ------------------
  ------------------
  |  Branch (14992:10): [True: 13, False: 9]
  ------------------
14993|     22|		((memberType->flags & XML_SCHEMAS_TYPE_MARKED) == 0))
  ------------------
  |  |  502|     13|#define XML_SCHEMAS_TYPE_MARKED        1 << 16
  ------------------
  |  Branch (14993:3): [True: 13, False: 0]
  ------------------
14994|     13|	    {
14995|     13|		int res;
14996|     13|		memberType->flags |= XML_SCHEMAS_TYPE_MARKED;
  ------------------
  |  |  502|     13|#define XML_SCHEMAS_TYPE_MARKED        1 << 16
  ------------------
14997|     13|		res = xmlSchemaCheckUnionTypeDefCircularRecur(pctxt,
14998|     13|		    ctxType,
14999|     13|		    xmlSchemaGetUnionSimpleTypeMemberTypes(memberType));
15000|     13|		memberType->flags ^= XML_SCHEMAS_TYPE_MARKED;
  ------------------
  |  |  502|     13|#define XML_SCHEMAS_TYPE_MARKED        1 << 16
  ------------------
15001|     13|		if (res != 0)
  ------------------
  |  Branch (15001:7): [True: 0, False: 13]
  ------------------
15002|      0|		    return(res);
15003|     13|	    }
15004|     22|	    memberType = memberType->baseType;
15005|     22|	}
15006|    108|	member = member->next;
15007|    108|    }
15008|     38|    return(0);
15009|     38|}
xmlschemas.c:xmlSchemaGetUnionSimpleTypeMemberTypes:
14598|     27|{
14599|     27|    while ((type != NULL) && (type->type == XML_SCHEMA_TYPE_SIMPLE)) {
  ------------------
  |  Branch (14599:12): [True: 27, False: 0]
  |  Branch (14599:30): [True: 27, False: 0]
  ------------------
14600|     27|	if (type->memberTypes != NULL)
  ------------------
  |  Branch (14600:6): [True: 27, False: 0]
  ------------------
14601|     27|	    return (type->memberTypes);
14602|      0|	else
14603|      0|	    type = type->baseType;
14604|     27|    }
14605|      0|    return (NULL);
14606|     27|}
xmlschemas.c:xmlSchemaFixupSimpleTypeStageTwo:
18012|    162|{
18013|    162|    int res, olderrs = pctxt->nberrors;
18014|       |
18015|    162|    if (type->type != XML_SCHEMA_TYPE_SIMPLE)
  ------------------
  |  Branch (18015:9): [True: 0, False: 162]
  ------------------
18016|      0|	return(-1);
18017|       |
18018|    162|    if (! WXS_IS_TYPE_NOT_FIXED(type))
  ------------------
  |  |  232|    162|    (((i)->type != XML_SCHEMA_TYPE_BASIC) && \
  |  |  ------------------
  |  |  |  Branch (232:6): [True: 162, False: 0]
  |  |  ------------------
  |  |  233|    162|     (((i)->flags & XML_SCHEMAS_TYPE_INTERNAL_RESOLVED) == 0))
  |  |  ------------------
  |  |  |  |  539|    162|#define XML_SCHEMAS_TYPE_INTERNAL_RESOLVED    1 << 22
  |  |  ------------------
  |  |  |  Branch (233:6): [True: 162, False: 0]
  |  |  ------------------
  ------------------
18019|      0|	return(0);
18020|       |
18021|    162|    type->flags |= XML_SCHEMAS_TYPE_INTERNAL_RESOLVED;
  ------------------
  |  |  539|    162|#define XML_SCHEMAS_TYPE_INTERNAL_RESOLVED    1 << 22
  ------------------
18022|    162|    type->contentType = XML_SCHEMA_CONTENT_SIMPLE;
18023|       |
18024|    162|    if (type->baseType == NULL) {
  ------------------
  |  Branch (18024:9): [True: 0, False: 162]
  ------------------
18025|      0|	PERROR_INT("xmlSchemaFixupSimpleTypeStageTwo",
  ------------------
  |  | 2824|      0|#define PERROR_INT(func, msg) xmlSchemaInternalErr(ACTXT_CAST pctxt, func, msg);
  |  |  ------------------
  |  |  |  |  121|      0|#define ACTXT_CAST (xmlSchemaAbstractCtxtPtr)
  |  |  ------------------
  ------------------
18026|      0|	    "missing baseType");
18027|      0|	goto exit_failure;
18028|      0|    }
18029|    162|    if (WXS_IS_TYPE_NOT_FIXED(type->baseType))
  ------------------
  |  |  232|    162|    (((i)->type != XML_SCHEMA_TYPE_BASIC) && \
  |  |  ------------------
  |  |  |  Branch (232:6): [True: 15, False: 147]
  |  |  ------------------
  |  |  233|    162|     (((i)->flags & XML_SCHEMAS_TYPE_INTERNAL_RESOLVED) == 0))
  |  |  ------------------
  |  |  |  |  539|     15|#define XML_SCHEMAS_TYPE_INTERNAL_RESOLVED    1 << 22
  |  |  ------------------
  |  |  |  Branch (233:6): [True: 11, False: 4]
  |  |  ------------------
  ------------------
18030|     11|	xmlSchemaTypeFixup(type->baseType, ACTXT_CAST pctxt);
  ------------------
  |  |  121|     11|#define ACTXT_CAST (xmlSchemaAbstractCtxtPtr)
  ------------------
18031|       |    /*
18032|       |    * If a member type of a union is a union itself, we need to substitute
18033|       |    * that member type for its member types.
18034|       |    * NOTE that this might change in WXS 1.1; i.e. we will keep the union
18035|       |    * types in WXS 1.1.
18036|       |    */
18037|    162|    if ((type->memberTypes != NULL) &&
  ------------------
  |  Branch (18037:9): [True: 25, False: 137]
  ------------------
18038|    162|	(xmlSchemaFinishMemberTypeDefinitionsProperty(pctxt, type) == -1))
  ------------------
  |  Branch (18038:2): [True: 0, False: 25]
  ------------------
18039|      0|	return(-1);
18040|       |    /*
18041|       |    * SPEC src-simple-type 1
18042|       |    * "The corresponding simple type definition, if any, must satisfy
18043|       |    * the conditions set out in Constraints on Simple Type Definition
18044|       |    * Schema Components ($3.14.6)."
18045|       |    */
18046|       |    /*
18047|       |    * Schema Component Constraint: Simple Type Definition Properties Correct
18048|       |    * (st-props-correct)
18049|       |    */
18050|    162|    res = xmlSchemaCheckSTPropsCorrect(pctxt, type);
18051|    162|    HFAILURE HERROR
  ------------------
  |  |  333|    162|#define HFAILURE if (res == -1) goto exit_failure;
  |  |  ------------------
  |  |  |  Branch (333:22): [True: 0, False: 162]
  |  |  ------------------
  ------------------
                  HFAILURE HERROR
  ------------------
  |  |  335|    162|#define HERROR if (res != 0) goto exit_error;
  |  |  ------------------
  |  |  |  Branch (335:20): [True: 0, False: 162]
  |  |  ------------------
  ------------------
18052|       |    /*
18053|       |    * Schema Component Constraint: Derivation Valid (Restriction, Simple)
18054|       |    * (cos-st-restricts)
18055|       |    */
18056|    162|    res = xmlSchemaCheckCOSSTRestricts(pctxt, type);
18057|    162|    HFAILURE HERROR
  ------------------
  |  |  333|    162|#define HFAILURE if (res == -1) goto exit_failure;
  |  |  ------------------
  |  |  |  Branch (333:22): [True: 0, False: 162]
  |  |  ------------------
  ------------------
                  HFAILURE HERROR
  ------------------
  |  |  335|    162|#define HERROR if (res != 0) goto exit_error;
  |  |  ------------------
  |  |  |  Branch (335:20): [True: 0, False: 162]
  |  |  ------------------
  ------------------
18058|       |    /*
18059|       |    * TODO: Removed the error report, since it got annoying to get an
18060|       |    * extra error report, if anything failed until now.
18061|       |    * Enable this if needed.
18062|       |    *
18063|       |    * xmlSchemaPErr(ctxt, type->node,
18064|       |    *    XML_SCHEMAP_SRC_SIMPLE_TYPE_1,
18065|       |    *    "Simple type '%s' does not satisfy the constraints "
18066|       |    *    "on simple type definitions.\n",
18067|       |    *    type->name, NULL);
18068|       |    */
18069|       |    /*
18070|       |    * Schema Component Constraint: Simple Type Restriction (Facets)
18071|       |    * (st-restrict-facets)
18072|       |    */
18073|    162|    res = xmlSchemaCheckFacetValues(type, pctxt);
18074|    162|    HFAILURE HERROR
  ------------------
  |  |  333|    162|#define HFAILURE if (res == -1) goto exit_failure;
  |  |  ------------------
  |  |  |  Branch (333:22): [True: 0, False: 162]
  |  |  ------------------
  ------------------
                  HFAILURE HERROR
  ------------------
  |  |  335|    162|#define HERROR if (res != 0) goto exit_error;
  |  |  ------------------
  |  |  |  Branch (335:20): [True: 0, False: 162]
  |  |  ------------------
  ------------------
18075|    162|    if ((type->facetSet != NULL) ||
  ------------------
  |  Branch (18075:9): [True: 120, False: 42]
  ------------------
18076|    162|	(type->baseType->facetSet != NULL)) {
  ------------------
  |  Branch (18076:2): [True: 1, False: 41]
  ------------------
18077|    121|	res = xmlSchemaDeriveAndValidateFacets(pctxt, type);
18078|    121|	HFAILURE HERROR
  ------------------
  |  |  333|    121|#define HFAILURE if (res == -1) goto exit_failure;
  |  |  ------------------
  |  |  |  Branch (333:22): [True: 0, False: 121]
  |  |  ------------------
  ------------------
              	HFAILURE HERROR
  ------------------
  |  |  335|    121|#define HERROR if (res != 0) goto exit_error;
  |  |  ------------------
  |  |  |  Branch (335:20): [True: 0, False: 121]
  |  |  ------------------
  ------------------
18079|    121|    }
18080|       |    /*
18081|       |    * Whitespace value.
18082|       |    */
18083|    162|    res = xmlSchemaTypeFixupWhitespace(type);
18084|    162|    HFAILURE HERROR
  ------------------
  |  |  333|    162|#define HFAILURE if (res == -1) goto exit_failure;
  |  |  ------------------
  |  |  |  Branch (333:22): [True: 0, False: 162]
  |  |  ------------------
  ------------------
                  HFAILURE HERROR
  ------------------
  |  |  335|    162|#define HERROR if (res != 0) goto exit_error;
  |  |  ------------------
  |  |  |  Branch (335:20): [True: 0, False: 162]
  |  |  ------------------
  ------------------
18085|    162|    xmlSchemaTypeFixupOptimFacets(type);
18086|       |
18087|    162|exit_error:
18088|    162|    if (olderrs != pctxt->nberrors)
  ------------------
  |  Branch (18088:9): [True: 0, False: 162]
  ------------------
18089|      0|	return(pctxt->err);
18090|    162|    return(0);
18091|       |
18092|      0|exit_failure:
18093|      0|    return(-1);
18094|    162|}
xmlschemas.c:xmlSchemaTypeFixup:
18540|     68|{
18541|     68|    if (type == NULL)
  ------------------
  |  Branch (18541:9): [True: 0, False: 68]
  ------------------
18542|      0|        return(0);
18543|     68|    if (actxt->type != XML_SCHEMA_CTXT_PARSER) {
  ------------------
  |  |  358|     68|#define XML_SCHEMA_CTXT_PARSER 1
  ------------------
  |  Branch (18543:9): [True: 0, False: 68]
  ------------------
18544|      0|	AERROR_INT("xmlSchemaTypeFixup",
  ------------------
  |  | 2827|      0|#define AERROR_INT(func, msg) xmlSchemaInternalErr(actxt, func, msg);
  ------------------
18545|      0|	    "this function needs a parser context");
18546|      0|	return(-1);
18547|      0|    }
18548|     68|    if (! WXS_IS_TYPE_NOT_FIXED(type))
  ------------------
  |  |  232|     68|    (((i)->type != XML_SCHEMA_TYPE_BASIC) && \
  |  |  ------------------
  |  |  |  Branch (232:6): [True: 68, False: 0]
  |  |  ------------------
  |  |  233|     68|     (((i)->flags & XML_SCHEMAS_TYPE_INTERNAL_RESOLVED) == 0))
  |  |  ------------------
  |  |  |  |  539|     68|#define XML_SCHEMAS_TYPE_INTERNAL_RESOLVED    1 << 22
  |  |  ------------------
  |  |  |  Branch (233:6): [True: 68, False: 0]
  |  |  ------------------
  ------------------
18549|      0|	return(0);
18550|     68|    if (type->type == XML_SCHEMA_TYPE_COMPLEX)
  ------------------
  |  Branch (18550:9): [True: 30, False: 38]
  ------------------
18551|     30|	return(xmlSchemaFixupComplexType(PCTXT_CAST actxt, type));
  ------------------
  |  |  122|     30|#define PCTXT_CAST (xmlSchemaParserCtxtPtr)
  ------------------
18552|     38|    else if (type->type == XML_SCHEMA_TYPE_SIMPLE)
  ------------------
  |  Branch (18552:14): [True: 38, False: 0]
  ------------------
18553|     38|	return(xmlSchemaFixupSimpleTypeStageTwo(PCTXT_CAST actxt, type));
  ------------------
  |  |  122|     38|#define PCTXT_CAST (xmlSchemaParserCtxtPtr)
  ------------------
18554|      0|    return(0);
18555|     68|}
xmlschemas.c:xmlSchemaFinishMemberTypeDefinitionsProperty:
17769|     25|{
17770|     25|    xmlSchemaTypeLinkPtr link, lastLink, prevLink, subLink, newLink;
17771|       |    /*
17772|       |    * The actual value is then formed by replacing any union type
17773|       |    * definition in the `explicit members` with the members of their
17774|       |    * {member type definitions}, in order.
17775|       |    *
17776|       |    * TODO: There's a bug entry at
17777|       |    * "http://lists.w3.org/Archives/Public/www-xml-schema-comments/2005JulSep/0287.html"
17778|       |    * which indicates that we'll keep the union types the future.
17779|       |    */
17780|     25|    link = type->memberTypes;
17781|    120|    while (link != NULL) {
  ------------------
  |  Branch (17781:12): [True: 95, False: 25]
  ------------------
17782|       |
17783|     95|	if (WXS_IS_TYPE_NOT_FIXED(link->type))
  ------------------
  |  |  232|     95|    (((i)->type != XML_SCHEMA_TYPE_BASIC) && \
  |  |  ------------------
  |  |  |  Branch (232:6): [True: 22, False: 73]
  |  |  ------------------
  |  |  233|     95|     (((i)->flags & XML_SCHEMAS_TYPE_INTERNAL_RESOLVED) == 0))
  |  |  ------------------
  |  |  |  |  539|     22|#define XML_SCHEMAS_TYPE_INTERNAL_RESOLVED    1 << 22
  |  |  ------------------
  |  |  |  Branch (233:6): [True: 20, False: 2]
  |  |  ------------------
  ------------------
17784|     20|	    xmlSchemaTypeFixup(link->type, ACTXT_CAST pctxt);
  ------------------
  |  |  121|     20|#define ACTXT_CAST (xmlSchemaAbstractCtxtPtr)
  ------------------
17785|       |
17786|     95|	if (WXS_IS_UNION(link->type)) {
  ------------------
  |  |  274|     95|#define WXS_IS_UNION(t) (t->flags & XML_SCHEMAS_TYPE_VARIETY_UNION)
  |  |  ------------------
  |  |  |  |  454|     95|#define XML_SCHEMAS_TYPE_VARIETY_UNION    1 << 7
  |  |  ------------------
  |  |  |  Branch (274:25): [True: 13, False: 82]
  |  |  ------------------
  ------------------
17787|     13|	    subLink = xmlSchemaGetUnionSimpleTypeMemberTypes(link->type);
17788|     13|	    if (subLink != NULL) {
  ------------------
  |  Branch (17788:10): [True: 13, False: 0]
  ------------------
17789|     13|		link->type = subLink->type;
17790|     13|		if (subLink->next != NULL) {
  ------------------
  |  Branch (17790:7): [True: 13, False: 0]
  ------------------
17791|     13|		    lastLink = link->next;
17792|     13|		    subLink = subLink->next;
17793|     13|		    prevLink = link;
17794|     39|		    while (subLink != NULL) {
  ------------------
  |  Branch (17794:14): [True: 26, False: 13]
  ------------------
17795|     26|			newLink = (xmlSchemaTypeLinkPtr)
17796|     26|			    xmlMalloc(sizeof(xmlSchemaTypeLink));
17797|     26|			if (newLink == NULL) {
  ------------------
  |  Branch (17797:8): [True: 0, False: 26]
  ------------------
17798|      0|			    xmlSchemaPErrMemory(pctxt, "allocating a type link",
17799|      0|				NULL);
17800|      0|			    return (-1);
17801|      0|			}
17802|     26|			newLink->type = subLink->type;
17803|     26|			prevLink->next = newLink;
17804|     26|			prevLink = newLink;
17805|     26|			newLink->next = lastLink;
17806|       |
17807|     26|			subLink = subLink->next;
17808|     26|		    }
17809|     13|		}
17810|     13|	    }
17811|     13|	}
17812|     95|	link = link->next;
17813|     95|    }
17814|     25|    return (0);
17815|     25|}
xmlschemas.c:xmlSchemaCheckSTPropsCorrect:
15161|    162|{
15162|    162|    xmlSchemaTypePtr baseType = type->baseType;
15163|    162|    xmlChar *str = NULL;
15164|       |
15165|       |    /* STATE: error funcs converted. */
15166|       |    /*
15167|       |    * Schema Component Constraint: Simple Type Definition Properties Correct
15168|       |    *
15169|       |    * NOTE: This is somehow redundant, since we actually built a simple type
15170|       |    * to have all the needed information; this acts as an self test.
15171|       |    */
15172|       |    /* Base type: If the datatype has been `derived` by `restriction`
15173|       |    * then the Simple Type Definition component from which it is `derived`,
15174|       |    * otherwise the Simple Type Definition for anySimpleType ($4.1.6).
15175|       |    */
15176|    162|    if (baseType == NULL) {
  ------------------
  |  Branch (15176:9): [True: 0, False: 162]
  ------------------
15177|       |	/*
15178|       |	* TODO: Think about: "modulo the impact of Missing
15179|       |	* Sub-components ($5.3)."
15180|       |	*/
15181|      0|	xmlSchemaPCustomErr(ctxt,
15182|      0|	    XML_SCHEMAP_ST_PROPS_CORRECT_1,
15183|      0|	    WXS_BASIC_CAST type, NULL,
  ------------------
  |  |  124|      0|#define WXS_BASIC_CAST (xmlSchemaBasicItemPtr)
  ------------------
15184|      0|	    "No base type existent", NULL);
15185|      0|	return (XML_SCHEMAP_ST_PROPS_CORRECT_1);
15186|       |
15187|      0|    }
15188|    162|    if (! WXS_IS_SIMPLE(baseType)) {
  ------------------
  |  |  217|    162|    ((item->type == XML_SCHEMA_TYPE_SIMPLE) || \
  |  |  ------------------
  |  |  |  Branch (217:6): [True: 15, False: 147]
  |  |  ------------------
  |  |  218|    162|     ((item->type == XML_SCHEMA_TYPE_BASIC) && \
  |  |  ------------------
  |  |  |  Branch (218:7): [True: 147, False: 0]
  |  |  ------------------
  |  |  219|    147|      (item->builtInType != XML_SCHEMAS_ANYTYPE)))
  |  |  ------------------
  |  |  |  Branch (219:7): [True: 147, False: 0]
  |  |  ------------------
  ------------------
15189|      0|	xmlSchemaPCustomErr(ctxt,
15190|      0|	    XML_SCHEMAP_ST_PROPS_CORRECT_1,
15191|      0|	    WXS_BASIC_CAST type, NULL,
  ------------------
  |  |  124|      0|#define WXS_BASIC_CAST (xmlSchemaBasicItemPtr)
  ------------------
15192|      0|	    "The base type '%s' is not a simple type",
15193|      0|	    xmlSchemaGetComponentQName(&str, baseType));
15194|      0|	FREE_AND_NULL(str)
  ------------------
  |  |  320|      0|#define FREE_AND_NULL(str) if ((str) != NULL) { xmlFree((xmlChar *) (str)); str = NULL; }
  |  |  ------------------
  |  |  |  Branch (320:32): [True: 0, False: 0]
  |  |  ------------------
  ------------------
15195|      0|	return (XML_SCHEMAP_ST_PROPS_CORRECT_1);
15196|      0|    }
15197|    162|    if ((WXS_IS_LIST(type) || WXS_IS_UNION(type)) &&
  ------------------
  |  |  272|    324|#define WXS_IS_LIST(t) (t->flags & XML_SCHEMAS_TYPE_VARIETY_LIST)
  |  |  ------------------
  |  |  |  |  448|    162|#define XML_SCHEMAS_TYPE_VARIETY_LIST    1 << 6
  |  |  ------------------
  |  |  |  Branch (272:24): [True: 21, False: 141]
  |  |  ------------------
  ------------------
                  if ((WXS_IS_LIST(type) || WXS_IS_UNION(type)) &&
  ------------------
  |  |  274|    141|#define WXS_IS_UNION(t) (t->flags & XML_SCHEMAS_TYPE_VARIETY_UNION)
  |  |  ------------------
  |  |  |  |  454|    141|#define XML_SCHEMAS_TYPE_VARIETY_UNION    1 << 7
  |  |  ------------------
  |  |  |  Branch (274:25): [True: 27, False: 114]
  |  |  ------------------
  ------------------
15198|    162|	(WXS_IS_RESTRICTION(type) == 0) &&
  ------------------
  |  |  226|     48|    ((t)->flags & XML_SCHEMAS_TYPE_DERIVATION_METHOD_RESTRICTION)
  |  |  ------------------
  |  |  |  |  420|     48|#define XML_SCHEMAS_TYPE_DERIVATION_METHOD_RESTRICTION                1 << 2
  |  |  ------------------
  ------------------
  |  Branch (15198:2): [True: 36, False: 12]
  ------------------
15199|    162|	((! WXS_IS_ANY_SIMPLE_TYPE(baseType)) &&
  ------------------
  |  |  222|     36|    (((i)->type == XML_SCHEMA_TYPE_BASIC) && \
  |  |  ------------------
  |  |  |  Branch (222:6): [True: 36, False: 0]
  |  |  ------------------
  |  |  223|     36|      ((i)->builtInType == XML_SCHEMAS_ANYSIMPLETYPE))
  |  |  ------------------
  |  |  |  Branch (223:7): [True: 36, False: 0]
  |  |  ------------------
  ------------------
15200|     36|         (baseType->type != XML_SCHEMA_TYPE_SIMPLE))) {
  ------------------
  |  Branch (15200:10): [True: 0, False: 0]
  ------------------
15201|      0|	xmlSchemaPCustomErr(ctxt,
15202|      0|	    XML_SCHEMAP_ST_PROPS_CORRECT_1,
15203|      0|	    WXS_BASIC_CAST type, NULL,
  ------------------
  |  |  124|      0|#define WXS_BASIC_CAST (xmlSchemaBasicItemPtr)
  ------------------
15204|      0|	    "A type, derived by list or union, must have "
15205|      0|	    "the simple ur-type definition as base type, not '%s'",
15206|      0|	    xmlSchemaGetComponentQName(&str, baseType));
15207|      0|	FREE_AND_NULL(str)
  ------------------
  |  |  320|      0|#define FREE_AND_NULL(str) if ((str) != NULL) { xmlFree((xmlChar *) (str)); str = NULL; }
  |  |  ------------------
  |  |  |  Branch (320:32): [True: 0, False: 0]
  |  |  ------------------
  ------------------
15208|      0|	return (XML_SCHEMAP_ST_PROPS_CORRECT_1);
15209|      0|    }
15210|       |    /*
15211|       |    * Variety: One of {atomic, list, union}.
15212|       |    */
15213|    162|    if ((! WXS_IS_ATOMIC(type)) && (! WXS_IS_UNION(type)) &&
  ------------------
  |  |  270|    162|#define WXS_IS_ATOMIC(t) (t->flags & XML_SCHEMAS_TYPE_VARIETY_ATOMIC)
  |  |  ------------------
  |  |  |  |  460|    162|#define XML_SCHEMAS_TYPE_VARIETY_ATOMIC    1 << 8
  |  |  ------------------
  ------------------
                  if ((! WXS_IS_ATOMIC(type)) && (! WXS_IS_UNION(type)) &&
  ------------------
  |  |  274|     48|#define WXS_IS_UNION(t) (t->flags & XML_SCHEMAS_TYPE_VARIETY_UNION)
  |  |  ------------------
  |  |  |  |  454|     48|#define XML_SCHEMAS_TYPE_VARIETY_UNION    1 << 7
  |  |  ------------------
  ------------------
  |  Branch (15213:9): [True: 48, False: 114]
  |  Branch (15213:36): [True: 21, False: 27]
  ------------------
15214|    162|	(! WXS_IS_LIST(type))) {
  ------------------
  |  |  272|     21|#define WXS_IS_LIST(t) (t->flags & XML_SCHEMAS_TYPE_VARIETY_LIST)
  |  |  ------------------
  |  |  |  |  448|     21|#define XML_SCHEMAS_TYPE_VARIETY_LIST    1 << 6
  |  |  ------------------
  ------------------
  |  Branch (15214:2): [True: 0, False: 21]
  ------------------
15215|      0|	xmlSchemaPCustomErr(ctxt,
15216|      0|	    XML_SCHEMAP_ST_PROPS_CORRECT_1,
15217|      0|	    WXS_BASIC_CAST type, NULL,
  ------------------
  |  |  124|      0|#define WXS_BASIC_CAST (xmlSchemaBasicItemPtr)
  ------------------
15218|      0|	    "The variety is absent", NULL);
15219|      0|	return (XML_SCHEMAP_ST_PROPS_CORRECT_1);
15220|      0|    }
15221|       |    /* TODO: Finish this. Hmm, is this finished? */
15222|       |
15223|       |    /*
15224|       |    * 3 The {final} of the {base type definition} must not contain restriction.
15225|       |    */
15226|    162|    if (xmlSchemaTypeFinalContains(baseType,
  ------------------
  |  Branch (15226:9): [True: 0, False: 162]
  ------------------
15227|    162|	XML_SCHEMAS_TYPE_FINAL_RESTRICTION)) {
  ------------------
  |  |  472|    162|#define XML_SCHEMAS_TYPE_FINAL_RESTRICTION    1 << 10
  ------------------
15228|      0|	xmlSchemaPCustomErr(ctxt,
15229|      0|	    XML_SCHEMAP_ST_PROPS_CORRECT_3,
15230|      0|	    WXS_BASIC_CAST type, NULL,
  ------------------
  |  |  124|      0|#define WXS_BASIC_CAST (xmlSchemaBasicItemPtr)
  ------------------
15231|      0|	    "The 'final' of its base type '%s' must not contain "
15232|      0|	    "'restriction'",
15233|      0|	    xmlSchemaGetComponentQName(&str, baseType));
15234|      0|	FREE_AND_NULL(str)
  ------------------
  |  |  320|      0|#define FREE_AND_NULL(str) if ((str) != NULL) { xmlFree((xmlChar *) (str)); str = NULL; }
  |  |  ------------------
  |  |  |  Branch (320:32): [True: 0, False: 0]
  |  |  ------------------
  ------------------
15235|      0|	return (XML_SCHEMAP_ST_PROPS_CORRECT_3);
15236|      0|    }
15237|       |
15238|       |    /*
15239|       |    * 2 All simple type definitions must be derived ultimately from the `simple
15240|       |    * ur-type definition` (so circular definitions are disallowed). That is, it
15241|       |    * must be possible to reach a built-in primitive datatype or the `simple
15242|       |    * ur-type definition` by repeatedly following the {base type definition}.
15243|       |    *
15244|       |    * NOTE: this is done in xmlSchemaCheckTypeDefCircular().
15245|       |    */
15246|    162|    return (0);
15247|    162|}
xmlschemas.c:xmlSchemaTypeFinalContains:
14580|    404|{
14581|    404|    if (type == NULL)
  ------------------
  |  Branch (14581:9): [True: 0, False: 404]
  ------------------
14582|      0|	return (0);
14583|    404|    if (type->flags & final)
  ------------------
  |  Branch (14583:9): [True: 0, False: 404]
  ------------------
14584|      0|	return (1);
14585|    404|    else
14586|    404|	return (0);
14587|    404|}
xmlschemas.c:xmlSchemaCheckCOSSTRestricts:
15266|    162|{
15267|    162|    xmlChar *str = NULL;
15268|       |
15269|    162|    if (type->type != XML_SCHEMA_TYPE_SIMPLE) {
  ------------------
  |  Branch (15269:9): [True: 0, False: 162]
  ------------------
15270|      0|	PERROR_INT("xmlSchemaCheckCOSSTRestricts",
  ------------------
  |  | 2824|      0|#define PERROR_INT(func, msg) xmlSchemaInternalErr(ACTXT_CAST pctxt, func, msg);
  |  |  ------------------
  |  |  |  |  121|      0|#define ACTXT_CAST (xmlSchemaAbstractCtxtPtr)
  |  |  ------------------
  ------------------
15271|      0|	    "given type is not a user-derived simpleType");
15272|      0|	return (-1);
15273|      0|    }
15274|       |
15275|    162|    if (WXS_IS_ATOMIC(type)) {
  ------------------
  |  |  270|    162|#define WXS_IS_ATOMIC(t) (t->flags & XML_SCHEMAS_TYPE_VARIETY_ATOMIC)
  |  |  ------------------
  |  |  |  |  460|    162|#define XML_SCHEMAS_TYPE_VARIETY_ATOMIC    1 << 8
  |  |  ------------------
  |  |  |  Branch (270:26): [True: 114, False: 48]
  |  |  ------------------
  ------------------
15276|    114|	xmlSchemaTypePtr primitive;
15277|       |	/*
15278|       |	* 1.1 The {base type definition} must be an atomic simple
15279|       |	* type definition or a built-in primitive datatype.
15280|       |	*/
15281|    114|	if (! WXS_IS_ATOMIC(type->baseType)) {
  ------------------
  |  |  270|    114|#define WXS_IS_ATOMIC(t) (t->flags & XML_SCHEMAS_TYPE_VARIETY_ATOMIC)
  |  |  ------------------
  |  |  |  |  460|    114|#define XML_SCHEMAS_TYPE_VARIETY_ATOMIC    1 << 8
  |  |  ------------------
  ------------------
  |  Branch (15281:6): [True: 0, False: 114]
  ------------------
15282|      0|	    xmlSchemaPCustomErr(pctxt,
15283|      0|		XML_SCHEMAP_COS_ST_RESTRICTS_1_1,
15284|      0|		WXS_BASIC_CAST type, NULL,
  ------------------
  |  |  124|      0|#define WXS_BASIC_CAST (xmlSchemaBasicItemPtr)
  ------------------
15285|      0|		"The base type '%s' is not an atomic simple type",
15286|      0|		xmlSchemaGetComponentQName(&str, type->baseType));
15287|      0|	    FREE_AND_NULL(str)
  ------------------
  |  |  320|      0|#define FREE_AND_NULL(str) if ((str) != NULL) { xmlFree((xmlChar *) (str)); str = NULL; }
  |  |  ------------------
  |  |  |  Branch (320:32): [True: 0, False: 0]
  |  |  ------------------
  ------------------
15288|      0|	    return (XML_SCHEMAP_COS_ST_RESTRICTS_1_1);
15289|      0|	}
15290|       |	/* 1.2 The {final} of the {base type definition} must not contain
15291|       |	* restriction.
15292|       |	*/
15293|       |	/* OPTIMIZE TODO : This is already done in xmlSchemaCheckStPropsCorrect */
15294|    114|	if (xmlSchemaTypeFinalContains(type->baseType,
  ------------------
  |  Branch (15294:6): [True: 0, False: 114]
  ------------------
15295|    114|	    XML_SCHEMAS_TYPE_FINAL_RESTRICTION)) {
  ------------------
  |  |  472|    114|#define XML_SCHEMAS_TYPE_FINAL_RESTRICTION    1 << 10
  ------------------
15296|      0|	    xmlSchemaPCustomErr(pctxt,
15297|      0|		XML_SCHEMAP_COS_ST_RESTRICTS_1_2,
15298|      0|		WXS_BASIC_CAST type, NULL,
  ------------------
  |  |  124|      0|#define WXS_BASIC_CAST (xmlSchemaBasicItemPtr)
  ------------------
15299|      0|		"The final of its base type '%s' must not contain 'restriction'",
15300|      0|		xmlSchemaGetComponentQName(&str, type->baseType));
15301|      0|	    FREE_AND_NULL(str)
  ------------------
  |  |  320|      0|#define FREE_AND_NULL(str) if ((str) != NULL) { xmlFree((xmlChar *) (str)); str = NULL; }
  |  |  ------------------
  |  |  |  Branch (320:32): [True: 0, False: 0]
  |  |  ------------------
  ------------------
15302|      0|	    return (XML_SCHEMAP_COS_ST_RESTRICTS_1_2);
15303|      0|	}
15304|       |
15305|       |	/*
15306|       |	* 1.3.1 DF must be an allowed constraining facet for the {primitive
15307|       |	* type definition}, as specified in the appropriate subsection of 3.2
15308|       |	* Primitive datatypes.
15309|       |	*/
15310|    114|	if (type->facets != NULL) {
  ------------------
  |  Branch (15310:6): [True: 110, False: 4]
  ------------------
15311|    110|	    xmlSchemaFacetPtr facet;
15312|    110|	    int ok = 1;
15313|       |
15314|    110|	    primitive = xmlSchemaGetPrimitiveType(type);
15315|    110|	    if (primitive == NULL) {
  ------------------
  |  Branch (15315:10): [True: 0, False: 110]
  ------------------
15316|      0|		PERROR_INT("xmlSchemaCheckCOSSTRestricts",
  ------------------
  |  | 2824|      0|#define PERROR_INT(func, msg) xmlSchemaInternalErr(ACTXT_CAST pctxt, func, msg);
  |  |  ------------------
  |  |  |  |  121|      0|#define ACTXT_CAST (xmlSchemaAbstractCtxtPtr)
  |  |  ------------------
  ------------------
15317|      0|		    "failed to get primitive type");
15318|      0|		return (-1);
15319|      0|	    }
15320|    110|	    facet = type->facets;
15321|    214|	    do {
15322|    214|		if (xmlSchemaIsBuiltInTypeFacet(primitive, facet->type) == 0) {
  ------------------
  |  Branch (15322:7): [True: 0, False: 214]
  ------------------
15323|      0|		    ok = 0;
15324|      0|		    xmlSchemaPIllegalFacetAtomicErr(pctxt,
15325|      0|			XML_SCHEMAP_COS_ST_RESTRICTS_1_3_1,
15326|      0|			type, primitive, facet);
15327|      0|		}
15328|    214|		facet = facet->next;
15329|    214|	    } while (facet != NULL);
  ------------------
  |  Branch (15329:15): [True: 104, False: 110]
  ------------------
15330|    110|	    if (ok == 0)
  ------------------
  |  Branch (15330:10): [True: 0, False: 110]
  ------------------
15331|      0|		return (XML_SCHEMAP_COS_ST_RESTRICTS_1_3_1);
15332|    110|	}
15333|       |	/*
15334|       |	* SPEC (1.3.2) "If there is a facet of the same kind in the {facets}
15335|       |	* of the {base type definition} (call this BF),then the DF's {value}
15336|       |	* must be a valid restriction of BF's {value} as defined in
15337|       |	* [XML Schemas: Datatypes]."
15338|       |	*
15339|       |	* NOTE (1.3.2) Facet derivation constraints are currently handled in
15340|       |	* xmlSchemaDeriveAndValidateFacets()
15341|       |	*/
15342|    114|    } else if (WXS_IS_LIST(type)) {
  ------------------
  |  |  272|     48|#define WXS_IS_LIST(t) (t->flags & XML_SCHEMAS_TYPE_VARIETY_LIST)
  |  |  ------------------
  |  |  |  |  448|     48|#define XML_SCHEMAS_TYPE_VARIETY_LIST    1 << 6
  |  |  ------------------
  |  |  |  Branch (272:24): [True: 21, False: 27]
  |  |  ------------------
  ------------------
15343|     21|	xmlSchemaTypePtr itemType = NULL;
15344|       |
15345|     21|	itemType = type->subtypes;
15346|     21|	if ((itemType == NULL) || (! WXS_IS_SIMPLE(itemType))) {
  ------------------
  |  |  217|     21|    ((item->type == XML_SCHEMA_TYPE_SIMPLE) || \
  |  |  ------------------
  |  |  |  Branch (217:6): [True: 16, False: 5]
  |  |  ------------------
  |  |  218|     21|     ((item->type == XML_SCHEMA_TYPE_BASIC) && \
  |  |  ------------------
  |  |  |  Branch (218:7): [True: 5, False: 0]
  |  |  ------------------
  |  |  219|      5|      (item->builtInType != XML_SCHEMAS_ANYTYPE)))
  |  |  ------------------
  |  |  |  Branch (219:7): [True: 5, False: 0]
  |  |  ------------------
  ------------------
  |  Branch (15346:6): [True: 0, False: 21]
  ------------------
15347|      0|	    PERROR_INT("xmlSchemaCheckCOSSTRestricts",
  ------------------
  |  | 2824|      0|#define PERROR_INT(func, msg) xmlSchemaInternalErr(ACTXT_CAST pctxt, func, msg);
  |  |  ------------------
  |  |  |  |  121|      0|#define ACTXT_CAST (xmlSchemaAbstractCtxtPtr)
  |  |  ------------------
  ------------------
15348|      0|		"failed to evaluate the item type");
15349|      0|	    return (-1);
15350|      0|	}
15351|     21|	if (WXS_IS_TYPE_NOT_FIXED(itemType))
  ------------------
  |  |  232|     21|    (((i)->type != XML_SCHEMA_TYPE_BASIC) && \
  |  |  ------------------
  |  |  |  Branch (232:6): [True: 16, False: 5]
  |  |  ------------------
  |  |  233|     21|     (((i)->flags & XML_SCHEMAS_TYPE_INTERNAL_RESOLVED) == 0))
  |  |  ------------------
  |  |  |  |  539|     16|#define XML_SCHEMAS_TYPE_INTERNAL_RESOLVED    1 << 22
  |  |  ------------------
  |  |  |  Branch (233:6): [True: 7, False: 9]
  |  |  ------------------
  ------------------
15352|      7|	    xmlSchemaTypeFixup(itemType, ACTXT_CAST pctxt);
  ------------------
  |  |  121|      7|#define ACTXT_CAST (xmlSchemaAbstractCtxtPtr)
  ------------------
15353|       |	/*
15354|       |	* 2.1 The {item type definition} must have a {variety} of atomic or
15355|       |	* union (in which case all the {member type definitions}
15356|       |	* must be atomic).
15357|       |	*/
15358|     21|	if ((! WXS_IS_ATOMIC(itemType)) &&
  ------------------
  |  |  270|     21|#define WXS_IS_ATOMIC(t) (t->flags & XML_SCHEMAS_TYPE_VARIETY_ATOMIC)
  |  |  ------------------
  |  |  |  |  460|     21|#define XML_SCHEMAS_TYPE_VARIETY_ATOMIC    1 << 8
  |  |  ------------------
  ------------------
  |  Branch (15358:6): [True: 15, False: 6]
  ------------------
15359|     21|	    (! WXS_IS_UNION(itemType))) {
  ------------------
  |  |  274|     15|#define WXS_IS_UNION(t) (t->flags & XML_SCHEMAS_TYPE_VARIETY_UNION)
  |  |  ------------------
  |  |  |  |  454|     15|#define XML_SCHEMAS_TYPE_VARIETY_UNION    1 << 7
  |  |  ------------------
  ------------------
  |  Branch (15359:6): [True: 0, False: 15]
  ------------------
15360|      0|	    xmlSchemaPCustomErr(pctxt,
15361|      0|		XML_SCHEMAP_COS_ST_RESTRICTS_2_1,
15362|      0|		WXS_BASIC_CAST type, NULL,
  ------------------
  |  |  124|      0|#define WXS_BASIC_CAST (xmlSchemaBasicItemPtr)
  ------------------
15363|      0|		"The item type '%s' does not have a variety of atomic or union",
15364|      0|		xmlSchemaGetComponentQName(&str, itemType));
15365|      0|	    FREE_AND_NULL(str)
  ------------------
  |  |  320|      0|#define FREE_AND_NULL(str) if ((str) != NULL) { xmlFree((xmlChar *) (str)); str = NULL; }
  |  |  ------------------
  |  |  |  Branch (320:32): [True: 0, False: 0]
  |  |  ------------------
  ------------------
15366|      0|	    return (XML_SCHEMAP_COS_ST_RESTRICTS_2_1);
15367|     21|	} else if (WXS_IS_UNION(itemType)) {
  ------------------
  |  |  274|     21|#define WXS_IS_UNION(t) (t->flags & XML_SCHEMAS_TYPE_VARIETY_UNION)
  |  |  ------------------
  |  |  |  |  454|     21|#define XML_SCHEMAS_TYPE_VARIETY_UNION    1 << 7
  |  |  ------------------
  |  |  |  Branch (274:25): [True: 15, False: 6]
  |  |  ------------------
  ------------------
15368|     15|	    xmlSchemaTypeLinkPtr member;
15369|       |
15370|     15|	    member = itemType->memberTypes;
15371|    109|	    while (member != NULL) {
  ------------------
  |  Branch (15371:13): [True: 94, False: 15]
  ------------------
15372|     94|		if (! WXS_IS_ATOMIC(member->type)) {
  ------------------
  |  |  270|     94|#define WXS_IS_ATOMIC(t) (t->flags & XML_SCHEMAS_TYPE_VARIETY_ATOMIC)
  |  |  ------------------
  |  |  |  |  460|     94|#define XML_SCHEMAS_TYPE_VARIETY_ATOMIC    1 << 8
  |  |  ------------------
  ------------------
  |  Branch (15372:7): [True: 0, False: 94]
  ------------------
15373|      0|		    xmlSchemaPCustomErr(pctxt,
15374|      0|			XML_SCHEMAP_COS_ST_RESTRICTS_2_1,
15375|      0|			WXS_BASIC_CAST type, NULL,
  ------------------
  |  |  124|      0|#define WXS_BASIC_CAST (xmlSchemaBasicItemPtr)
  ------------------
15376|      0|			"The item type is a union type, but the "
15377|      0|			"member type '%s' of this item type is not atomic",
15378|      0|			xmlSchemaGetComponentQName(&str, member->type));
15379|      0|		    FREE_AND_NULL(str)
  ------------------
  |  |  320|      0|#define FREE_AND_NULL(str) if ((str) != NULL) { xmlFree((xmlChar *) (str)); str = NULL; }
  |  |  ------------------
  |  |  |  Branch (320:32): [True: 0, False: 0]
  |  |  ------------------
  ------------------
15380|      0|		    return (XML_SCHEMAP_COS_ST_RESTRICTS_2_1);
15381|      0|		}
15382|     94|		member = member->next;
15383|     94|	    }
15384|     15|	}
15385|       |
15386|     21|	if (WXS_IS_ANY_SIMPLE_TYPE(type->baseType)) {
  ------------------
  |  |  222|     21|    (((i)->type == XML_SCHEMA_TYPE_BASIC) && \
  |  |  ------------------
  |  |  |  Branch (222:6): [True: 11, False: 10]
  |  |  ------------------
  |  |  223|     21|      ((i)->builtInType == XML_SCHEMAS_ANYSIMPLETYPE))
  |  |  ------------------
  |  |  |  Branch (223:7): [True: 11, False: 0]
  |  |  ------------------
  ------------------
15387|     11|	    xmlSchemaFacetPtr facet;
15388|       |	    /*
15389|       |	    * This is the case if we have: <simpleType><list ..
15390|       |	    */
15391|       |	    /*
15392|       |	    * 2.3.1
15393|       |	    * 2.3.1.1 The {final} of the {item type definition} must not
15394|       |	    * contain list.
15395|       |	    */
15396|     11|	    if (xmlSchemaTypeFinalContains(itemType,
  ------------------
  |  Branch (15396:10): [True: 0, False: 11]
  ------------------
15397|     11|		XML_SCHEMAS_TYPE_FINAL_LIST)) {
  ------------------
  |  |  478|     11|#define XML_SCHEMAS_TYPE_FINAL_LIST    1 << 11
  ------------------
15398|      0|		xmlSchemaPCustomErr(pctxt,
15399|      0|		    XML_SCHEMAP_COS_ST_RESTRICTS_2_3_1_1,
15400|      0|		    WXS_BASIC_CAST type, NULL,
  ------------------
  |  |  124|      0|#define WXS_BASIC_CAST (xmlSchemaBasicItemPtr)
  ------------------
15401|      0|		    "The final of its item type '%s' must not contain 'list'",
15402|      0|		    xmlSchemaGetComponentQName(&str, itemType));
15403|      0|		FREE_AND_NULL(str)
  ------------------
  |  |  320|      0|#define FREE_AND_NULL(str) if ((str) != NULL) { xmlFree((xmlChar *) (str)); str = NULL; }
  |  |  ------------------
  |  |  |  Branch (320:32): [True: 0, False: 0]
  |  |  ------------------
  ------------------
15404|      0|		return (XML_SCHEMAP_COS_ST_RESTRICTS_2_3_1_1);
15405|      0|	    }
15406|       |	    /*
15407|       |	    * 2.3.1.2 The {facets} must only contain the whiteSpace
15408|       |	    * facet component.
15409|       |	    * OPTIMIZE TODO: the S4S already disallows any facet
15410|       |	    * to be specified.
15411|       |	    */
15412|     11|	    if (type->facets != NULL) {
  ------------------
  |  Branch (15412:10): [True: 0, False: 11]
  ------------------
15413|      0|		facet = type->facets;
15414|      0|		do {
15415|      0|		    if (facet->type != XML_SCHEMA_FACET_WHITESPACE) {
  ------------------
  |  Branch (15415:11): [True: 0, False: 0]
  ------------------
15416|      0|			xmlSchemaPIllegalFacetListUnionErr(pctxt,
15417|      0|			    XML_SCHEMAP_COS_ST_RESTRICTS_2_3_1_2,
15418|      0|			    type, facet);
15419|      0|			return (XML_SCHEMAP_COS_ST_RESTRICTS_2_3_1_2);
15420|      0|		    }
15421|      0|		    facet = facet->next;
15422|      0|		} while (facet != NULL);
  ------------------
  |  Branch (15422:12): [True: 0, False: 0]
  ------------------
15423|      0|	    }
15424|       |	    /*
15425|       |	    * MAYBE TODO: (Hmm, not really) Datatypes states:
15426|       |	    * A `list` datatype can be `derived` from an `atomic` datatype
15427|       |	    * whose `lexical space` allows space (such as string or anyURI)or
15428|       |	    * a `union` datatype any of whose {member type definitions}'s
15429|       |	    * `lexical space` allows space.
15430|       |	    */
15431|     11|	} else {
15432|       |	    /*
15433|       |	    * This is the case if we have: <simpleType><restriction ...
15434|       |	    * I.e. the variety of "list" is inherited.
15435|       |	    */
15436|       |	    /*
15437|       |	    * 2.3.2
15438|       |	    * 2.3.2.1 The {base type definition} must have a {variety} of list.
15439|       |	    */
15440|     10|	    if (! WXS_IS_LIST(type->baseType)) {
  ------------------
  |  |  272|     10|#define WXS_IS_LIST(t) (t->flags & XML_SCHEMAS_TYPE_VARIETY_LIST)
  |  |  ------------------
  |  |  |  |  448|     10|#define XML_SCHEMAS_TYPE_VARIETY_LIST    1 << 6
  |  |  ------------------
  ------------------
  |  Branch (15440:10): [True: 0, False: 10]
  ------------------
15441|      0|		xmlSchemaPCustomErr(pctxt,
15442|      0|		    XML_SCHEMAP_COS_ST_RESTRICTS_2_3_2_1,
15443|      0|		    WXS_BASIC_CAST type, NULL,
  ------------------
  |  |  124|      0|#define WXS_BASIC_CAST (xmlSchemaBasicItemPtr)
  ------------------
15444|      0|		    "The base type '%s' must be a list type",
15445|      0|		    xmlSchemaGetComponentQName(&str, type->baseType));
15446|      0|		FREE_AND_NULL(str)
  ------------------
  |  |  320|      0|#define FREE_AND_NULL(str) if ((str) != NULL) { xmlFree((xmlChar *) (str)); str = NULL; }
  |  |  ------------------
  |  |  |  Branch (320:32): [True: 0, False: 0]
  |  |  ------------------
  ------------------
15447|      0|		return (XML_SCHEMAP_COS_ST_RESTRICTS_2_3_2_1);
15448|      0|	    }
15449|       |	    /*
15450|       |	    * 2.3.2.2 The {final} of the {base type definition} must not
15451|       |	    * contain restriction.
15452|       |	    */
15453|     10|	    if (xmlSchemaTypeFinalContains(type->baseType,
  ------------------
  |  Branch (15453:10): [True: 0, False: 10]
  ------------------
15454|     10|		XML_SCHEMAS_TYPE_FINAL_RESTRICTION)) {
  ------------------
  |  |  472|     10|#define XML_SCHEMAS_TYPE_FINAL_RESTRICTION    1 << 10
  ------------------
15455|      0|		xmlSchemaPCustomErr(pctxt,
15456|      0|		    XML_SCHEMAP_COS_ST_RESTRICTS_2_3_2_2,
15457|      0|		    WXS_BASIC_CAST type, NULL,
  ------------------
  |  |  124|      0|#define WXS_BASIC_CAST (xmlSchemaBasicItemPtr)
  ------------------
15458|      0|		    "The 'final' of the base type '%s' must not contain 'restriction'",
15459|      0|		    xmlSchemaGetComponentQName(&str, type->baseType));
15460|      0|		FREE_AND_NULL(str)
  ------------------
  |  |  320|      0|#define FREE_AND_NULL(str) if ((str) != NULL) { xmlFree((xmlChar *) (str)); str = NULL; }
  |  |  ------------------
  |  |  |  Branch (320:32): [True: 0, False: 0]
  |  |  ------------------
  ------------------
15461|      0|		return (XML_SCHEMAP_COS_ST_RESTRICTS_2_3_2_2);
15462|      0|	    }
15463|       |	    /*
15464|       |	    * 2.3.2.3 The {item type definition} must be validly derived
15465|       |	    * from the {base type definition}'s {item type definition} given
15466|       |	    * the empty set, as defined in Type Derivation OK (Simple) ($3.14.6).
15467|       |	    */
15468|     10|	    {
15469|     10|		xmlSchemaTypePtr baseItemType;
15470|       |
15471|     10|		baseItemType = type->baseType->subtypes;
15472|     10|		if ((baseItemType == NULL) || (! WXS_IS_SIMPLE(baseItemType))) {
  ------------------
  |  |  217|     10|    ((item->type == XML_SCHEMA_TYPE_SIMPLE) || \
  |  |  ------------------
  |  |  |  Branch (217:6): [True: 8, False: 2]
  |  |  ------------------
  |  |  218|     10|     ((item->type == XML_SCHEMA_TYPE_BASIC) && \
  |  |  ------------------
  |  |  |  Branch (218:7): [True: 2, False: 0]
  |  |  ------------------
  |  |  219|      2|      (item->builtInType != XML_SCHEMAS_ANYTYPE)))
  |  |  ------------------
  |  |  |  Branch (219:7): [True: 2, False: 0]
  |  |  ------------------
  ------------------
  |  Branch (15472:7): [True: 0, False: 10]
  ------------------
15473|      0|		    PERROR_INT("xmlSchemaCheckCOSSTRestricts",
  ------------------
  |  | 2824|      0|#define PERROR_INT(func, msg) xmlSchemaInternalErr(ACTXT_CAST pctxt, func, msg);
  |  |  ------------------
  |  |  |  |  121|      0|#define ACTXT_CAST (xmlSchemaAbstractCtxtPtr)
  |  |  ------------------
  ------------------
15474|      0|			"failed to eval the item type of a base type");
15475|      0|		    return (-1);
15476|      0|		}
15477|     10|		if ((itemType != baseItemType) &&
  ------------------
  |  Branch (15477:7): [True: 0, False: 10]
  ------------------
15478|     10|		    (xmlSchemaCheckCOSSTDerivedOK(ACTXT_CAST pctxt, itemType,
  ------------------
  |  |  121|      0|#define ACTXT_CAST (xmlSchemaAbstractCtxtPtr)
  ------------------
  |  Branch (15478:7): [True: 0, False: 0]
  ------------------
15479|      0|			baseItemType, 0) != 0)) {
15480|      0|		    xmlChar *strBIT = NULL, *strBT = NULL;
15481|      0|		    xmlSchemaPCustomErrExt(pctxt,
15482|      0|			XML_SCHEMAP_COS_ST_RESTRICTS_2_3_2_3,
15483|      0|			WXS_BASIC_CAST type, NULL,
  ------------------
  |  |  124|      0|#define WXS_BASIC_CAST (xmlSchemaBasicItemPtr)
  ------------------
15484|      0|			"The item type '%s' is not validly derived from "
15485|      0|			"the item type '%s' of the base type '%s'",
15486|      0|			xmlSchemaGetComponentQName(&str, itemType),
15487|      0|			xmlSchemaGetComponentQName(&strBIT, baseItemType),
15488|      0|			xmlSchemaGetComponentQName(&strBT, type->baseType));
15489|       |
15490|      0|		    FREE_AND_NULL(str)
  ------------------
  |  |  320|      0|#define FREE_AND_NULL(str) if ((str) != NULL) { xmlFree((xmlChar *) (str)); str = NULL; }
  |  |  ------------------
  |  |  |  Branch (320:32): [True: 0, False: 0]
  |  |  ------------------
  ------------------
15491|      0|		    FREE_AND_NULL(strBIT)
  ------------------
  |  |  320|      0|#define FREE_AND_NULL(str) if ((str) != NULL) { xmlFree((xmlChar *) (str)); str = NULL; }
  |  |  ------------------
  |  |  |  Branch (320:32): [True: 0, False: 0]
  |  |  ------------------
  ------------------
15492|      0|		    FREE_AND_NULL(strBT)
  ------------------
  |  |  320|      0|#define FREE_AND_NULL(str) if ((str) != NULL) { xmlFree((xmlChar *) (str)); str = NULL; }
  |  |  ------------------
  |  |  |  Branch (320:32): [True: 0, False: 0]
  |  |  ------------------
  ------------------
15493|      0|		    return (XML_SCHEMAP_COS_ST_RESTRICTS_2_3_2_3);
15494|      0|		}
15495|     10|	    }
15496|       |
15497|     10|	    if (type->facets != NULL) {
  ------------------
  |  Branch (15497:10): [True: 8, False: 2]
  ------------------
15498|      8|		xmlSchemaFacetPtr facet;
15499|      8|		int ok = 1;
15500|       |		/*
15501|       |		* 2.3.2.4 Only length, minLength, maxLength, whiteSpace, pattern
15502|       |		* and enumeration facet components are allowed among the {facets}.
15503|       |		*/
15504|      8|		facet = type->facets;
15505|      8|		do {
15506|      8|		    switch (facet->type) {
15507|      2|			case XML_SCHEMA_FACET_LENGTH:
  ------------------
  |  Branch (15507:4): [True: 2, False: 6]
  ------------------
15508|      8|			case XML_SCHEMA_FACET_MINLENGTH:
  ------------------
  |  Branch (15508:4): [True: 6, False: 2]
  ------------------
15509|      8|			case XML_SCHEMA_FACET_MAXLENGTH:
  ------------------
  |  Branch (15509:4): [True: 0, False: 8]
  ------------------
15510|      8|			case XML_SCHEMA_FACET_WHITESPACE:
  ------------------
  |  Branch (15510:4): [True: 0, False: 8]
  ------------------
15511|       |			    /*
15512|       |			    * TODO: 2.5.1.2 List datatypes
15513|       |			    * The value of `whiteSpace` is fixed to the value collapse.
15514|       |			    */
15515|      8|			case XML_SCHEMA_FACET_PATTERN:
  ------------------
  |  Branch (15515:4): [True: 0, False: 8]
  ------------------
15516|      8|			case XML_SCHEMA_FACET_ENUMERATION:
  ------------------
  |  Branch (15516:4): [True: 0, False: 8]
  ------------------
15517|      8|			    break;
15518|      0|			default: {
  ------------------
  |  Branch (15518:4): [True: 0, False: 8]
  ------------------
15519|      0|			    xmlSchemaPIllegalFacetListUnionErr(pctxt,
15520|      0|				XML_SCHEMAP_COS_ST_RESTRICTS_2_3_2_4,
15521|      0|				type, facet);
15522|       |			    /*
15523|       |			    * We could return, but it's nicer to report all
15524|       |			    * invalid facets.
15525|       |			    */
15526|      0|			    ok = 0;
15527|      0|			}
15528|      8|		    }
15529|      8|		    facet = facet->next;
15530|      8|		} while (facet != NULL);
  ------------------
  |  Branch (15530:12): [True: 0, False: 8]
  ------------------
15531|      8|		if (ok == 0)
  ------------------
  |  Branch (15531:7): [True: 0, False: 8]
  ------------------
15532|      0|		    return (XML_SCHEMAP_COS_ST_RESTRICTS_2_3_2_4);
15533|       |		/*
15534|       |		* SPEC (2.3.2.5) (same as 1.3.2)
15535|       |		*
15536|       |		* NOTE (2.3.2.5) This is currently done in
15537|       |		* xmlSchemaDeriveAndValidateFacets()
15538|       |		*/
15539|      8|	    }
15540|     10|	}
15541|     27|    } else if (WXS_IS_UNION(type)) {
  ------------------
  |  |  274|     27|#define WXS_IS_UNION(t) (t->flags & XML_SCHEMAS_TYPE_VARIETY_UNION)
  |  |  ------------------
  |  |  |  |  454|     27|#define XML_SCHEMAS_TYPE_VARIETY_UNION    1 << 7
  |  |  ------------------
  |  |  |  Branch (274:25): [True: 27, False: 0]
  |  |  ------------------
  ------------------
15542|       |	/*
15543|       |	* 3.1 The {member type definitions} must all have {variety} of
15544|       |	* atomic or list.
15545|       |	*/
15546|     27|	xmlSchemaTypeLinkPtr member;
15547|       |
15548|     27|	member = type->memberTypes;
15549|    122|	while (member != NULL) {
  ------------------
  |  Branch (15549:9): [True: 95, False: 27]
  ------------------
15550|     95|	    if (WXS_IS_TYPE_NOT_FIXED(member->type))
  ------------------
  |  |  232|     95|    (((i)->type != XML_SCHEMA_TYPE_BASIC) && \
  |  |  ------------------
  |  |  |  Branch (232:6): [True: 9, False: 86]
  |  |  ------------------
  |  |  233|     95|     (((i)->flags & XML_SCHEMAS_TYPE_INTERNAL_RESOLVED) == 0))
  |  |  ------------------
  |  |  |  |  539|      9|#define XML_SCHEMAS_TYPE_INTERNAL_RESOLVED    1 << 22
  |  |  ------------------
  |  |  |  Branch (233:6): [True: 0, False: 9]
  |  |  ------------------
  ------------------
15551|      0|		xmlSchemaTypeFixup(member->type, ACTXT_CAST pctxt);
  ------------------
  |  |  121|      0|#define ACTXT_CAST (xmlSchemaAbstractCtxtPtr)
  ------------------
15552|       |
15553|     95|	    if ((! WXS_IS_ATOMIC(member->type)) &&
  ------------------
  |  |  270|     95|#define WXS_IS_ATOMIC(t) (t->flags & XML_SCHEMAS_TYPE_VARIETY_ATOMIC)
  |  |  ------------------
  |  |  |  |  460|     95|#define XML_SCHEMAS_TYPE_VARIETY_ATOMIC    1 << 8
  |  |  ------------------
  ------------------
  |  Branch (15553:10): [True: 0, False: 95]
  ------------------
15554|     95|		(! WXS_IS_LIST(member->type))) {
  ------------------
  |  |  272|      0|#define WXS_IS_LIST(t) (t->flags & XML_SCHEMAS_TYPE_VARIETY_LIST)
  |  |  ------------------
  |  |  |  |  448|      0|#define XML_SCHEMAS_TYPE_VARIETY_LIST    1 << 6
  |  |  ------------------
  ------------------
  |  Branch (15554:3): [True: 0, False: 0]
  ------------------
15555|      0|		xmlSchemaPCustomErr(pctxt,
15556|      0|		    XML_SCHEMAP_COS_ST_RESTRICTS_3_1,
15557|      0|		    WXS_BASIC_CAST type, NULL,
  ------------------
  |  |  124|      0|#define WXS_BASIC_CAST (xmlSchemaBasicItemPtr)
  ------------------
15558|      0|		    "The member type '%s' is neither an atomic, nor a list type",
15559|      0|		    xmlSchemaGetComponentQName(&str, member->type));
15560|      0|		FREE_AND_NULL(str)
  ------------------
  |  |  320|      0|#define FREE_AND_NULL(str) if ((str) != NULL) { xmlFree((xmlChar *) (str)); str = NULL; }
  |  |  ------------------
  |  |  |  Branch (320:32): [True: 0, False: 0]
  |  |  ------------------
  ------------------
15561|      0|		return (XML_SCHEMAP_COS_ST_RESTRICTS_3_1);
15562|      0|	    }
15563|     95|	    member = member->next;
15564|     95|	}
15565|       |	/*
15566|       |	* 3.3.1 If the {base type definition} is the `simple ur-type
15567|       |	* definition`
15568|       |	*/
15569|     27|	if (type->baseType->builtInType == XML_SCHEMAS_ANYSIMPLETYPE) {
  ------------------
  |  Branch (15569:6): [True: 25, False: 2]
  ------------------
15570|       |	    /*
15571|       |	    * 3.3.1.1 All of the {member type definitions} must have a
15572|       |	    * {final} which does not contain union.
15573|       |	    */
15574|     25|	    member = type->memberTypes;
15575|    120|	    while (member != NULL) {
  ------------------
  |  Branch (15575:13): [True: 95, False: 25]
  ------------------
15576|     95|		if (xmlSchemaTypeFinalContains(member->type,
  ------------------
  |  Branch (15576:7): [True: 0, False: 95]
  ------------------
15577|     95|		    XML_SCHEMAS_TYPE_FINAL_UNION)) {
  ------------------
  |  |  484|     95|#define XML_SCHEMAS_TYPE_FINAL_UNION    1 << 12
  ------------------
15578|      0|		    xmlSchemaPCustomErr(pctxt,
15579|      0|			XML_SCHEMAP_COS_ST_RESTRICTS_3_3_1,
15580|      0|			WXS_BASIC_CAST type, NULL,
  ------------------
  |  |  124|      0|#define WXS_BASIC_CAST (xmlSchemaBasicItemPtr)
  ------------------
15581|      0|			"The 'final' of member type '%s' contains 'union'",
15582|      0|			xmlSchemaGetComponentQName(&str, member->type));
15583|      0|		    FREE_AND_NULL(str)
  ------------------
  |  |  320|      0|#define FREE_AND_NULL(str) if ((str) != NULL) { xmlFree((xmlChar *) (str)); str = NULL; }
  |  |  ------------------
  |  |  |  Branch (320:32): [True: 0, False: 0]
  |  |  ------------------
  ------------------
15584|      0|		    return (XML_SCHEMAP_COS_ST_RESTRICTS_3_3_1);
15585|      0|		}
15586|     95|		member = member->next;
15587|     95|	    }
15588|       |	    /*
15589|       |	    * 3.3.1.2 The {facets} must be empty.
15590|       |	    */
15591|     25|	    if (type->facetSet != NULL) {
  ------------------
  |  Branch (15591:10): [True: 0, False: 25]
  ------------------
15592|      0|		xmlSchemaPCustomErr(pctxt,
15593|      0|		    XML_SCHEMAP_COS_ST_RESTRICTS_3_3_1_2,
15594|      0|		    WXS_BASIC_CAST type, NULL,
  ------------------
  |  |  124|      0|#define WXS_BASIC_CAST (xmlSchemaBasicItemPtr)
  ------------------
15595|      0|		    "No facets allowed", NULL);
15596|      0|		return (XML_SCHEMAP_COS_ST_RESTRICTS_3_3_1_2);
15597|      0|	    }
15598|     25|	} else {
15599|       |	    /*
15600|       |	    * 3.3.2.1 The {base type definition} must have a {variety} of union.
15601|       |	    * I.e. the variety of "list" is inherited.
15602|       |	    */
15603|      2|	    if (! WXS_IS_UNION(type->baseType)) {
  ------------------
  |  |  274|      2|#define WXS_IS_UNION(t) (t->flags & XML_SCHEMAS_TYPE_VARIETY_UNION)
  |  |  ------------------
  |  |  |  |  454|      2|#define XML_SCHEMAS_TYPE_VARIETY_UNION    1 << 7
  |  |  ------------------
  ------------------
  |  Branch (15603:10): [True: 0, False: 2]
  ------------------
15604|      0|		xmlSchemaPCustomErr(pctxt,
15605|      0|		    XML_SCHEMAP_COS_ST_RESTRICTS_3_3_2_1,
15606|      0|		    WXS_BASIC_CAST type, NULL,
  ------------------
  |  |  124|      0|#define WXS_BASIC_CAST (xmlSchemaBasicItemPtr)
  ------------------
15607|      0|		    "The base type '%s' is not a union type",
15608|      0|		    xmlSchemaGetComponentQName(&str, type->baseType));
15609|      0|		FREE_AND_NULL(str)
  ------------------
  |  |  320|      0|#define FREE_AND_NULL(str) if ((str) != NULL) { xmlFree((xmlChar *) (str)); str = NULL; }
  |  |  ------------------
  |  |  |  Branch (320:32): [True: 0, False: 0]
  |  |  ------------------
  ------------------
15610|      0|		return (XML_SCHEMAP_COS_ST_RESTRICTS_3_3_2_1);
15611|      0|	    }
15612|       |	    /*
15613|       |	    * 3.3.2.2 The {final} of the {base type definition} must not contain restriction.
15614|       |	    */
15615|      2|	    if (xmlSchemaTypeFinalContains(type->baseType,
  ------------------
  |  Branch (15615:10): [True: 0, False: 2]
  ------------------
15616|      2|		XML_SCHEMAS_TYPE_FINAL_RESTRICTION)) {
  ------------------
  |  |  472|      2|#define XML_SCHEMAS_TYPE_FINAL_RESTRICTION    1 << 10
  ------------------
15617|      0|		xmlSchemaPCustomErr(pctxt,
15618|      0|		    XML_SCHEMAP_COS_ST_RESTRICTS_3_3_2_2,
15619|      0|		    WXS_BASIC_CAST type, NULL,
  ------------------
  |  |  124|      0|#define WXS_BASIC_CAST (xmlSchemaBasicItemPtr)
  ------------------
15620|      0|		    "The 'final' of its base type '%s' must not contain 'restriction'",
15621|      0|		    xmlSchemaGetComponentQName(&str, type->baseType));
15622|      0|		FREE_AND_NULL(str)
  ------------------
  |  |  320|      0|#define FREE_AND_NULL(str) if ((str) != NULL) { xmlFree((xmlChar *) (str)); str = NULL; }
  |  |  ------------------
  |  |  |  Branch (320:32): [True: 0, False: 0]
  |  |  ------------------
  ------------------
15623|      0|		return (XML_SCHEMAP_COS_ST_RESTRICTS_3_3_2_2);
15624|      0|	    }
15625|       |	    /*
15626|       |	    * 3.3.2.3 The {member type definitions}, in order, must be validly
15627|       |	    * derived from the corresponding type definitions in the {base
15628|       |	    * type definition}'s {member type definitions} given the empty set,
15629|       |	    * as defined in Type Derivation OK (Simple) ($3.14.6).
15630|       |	    */
15631|      2|	    {
15632|      2|		xmlSchemaTypeLinkPtr baseMember;
15633|       |
15634|       |		/*
15635|       |		* OPTIMIZE: if the type is restricting, it has no local defined
15636|       |		* member types and inherits the member types of the base type;
15637|       |		* thus a check for equality can be skipped.
15638|       |		*/
15639|       |		/*
15640|       |		* Even worse: I cannot see a scenario where a restricting
15641|       |		* union simple type can have other member types as the member
15642|       |		* types of it's base type. This check seems not necessary with
15643|       |		* respect to the derivation process in libxml2.
15644|       |		* But necessary if constructing types with an API.
15645|       |		*/
15646|      2|		if (type->memberTypes != NULL) {
  ------------------
  |  Branch (15646:7): [True: 0, False: 2]
  ------------------
15647|      0|		    member = type->memberTypes;
15648|      0|		    baseMember = xmlSchemaGetUnionSimpleTypeMemberTypes(type->baseType);
15649|      0|		    if ((member == NULL) && (baseMember != NULL)) {
  ------------------
  |  Branch (15649:11): [True: 0, False: 0]
  |  Branch (15649:31): [True: 0, False: 0]
  ------------------
15650|      0|			PERROR_INT("xmlSchemaCheckCOSSTRestricts",
  ------------------
  |  | 2824|      0|#define PERROR_INT(func, msg) xmlSchemaInternalErr(ACTXT_CAST pctxt, func, msg);
  |  |  ------------------
  |  |  |  |  121|      0|#define ACTXT_CAST (xmlSchemaAbstractCtxtPtr)
  |  |  ------------------
  ------------------
15651|      0|			    "different number of member types in base");
15652|      0|		    }
15653|      0|		    while (member != NULL) {
  ------------------
  |  Branch (15653:14): [True: 0, False: 0]
  ------------------
15654|      0|			if (baseMember == NULL) {
  ------------------
  |  Branch (15654:8): [True: 0, False: 0]
  ------------------
15655|      0|			    PERROR_INT("xmlSchemaCheckCOSSTRestricts",
  ------------------
  |  | 2824|      0|#define PERROR_INT(func, msg) xmlSchemaInternalErr(ACTXT_CAST pctxt, func, msg);
  |  |  ------------------
  |  |  |  |  121|      0|#define ACTXT_CAST (xmlSchemaAbstractCtxtPtr)
  |  |  ------------------
  ------------------
15656|      0|			    "different number of member types in base");
15657|      0|			} else if ((member->type != baseMember->type) &&
  ------------------
  |  Branch (15657:15): [True: 0, False: 0]
  ------------------
15658|      0|			    (xmlSchemaCheckCOSSTDerivedOK(ACTXT_CAST pctxt,
  ------------------
  |  |  121|      0|#define ACTXT_CAST (xmlSchemaAbstractCtxtPtr)
  ------------------
  |  Branch (15658:8): [True: 0, False: 0]
  ------------------
15659|      0|				member->type, baseMember->type, 0) != 0)) {
15660|      0|			    xmlChar *strBMT = NULL, *strBT = NULL;
15661|       |
15662|      0|			    xmlSchemaPCustomErrExt(pctxt,
15663|      0|				XML_SCHEMAP_COS_ST_RESTRICTS_3_3_2_3,
15664|      0|				WXS_BASIC_CAST type, NULL,
  ------------------
  |  |  124|      0|#define WXS_BASIC_CAST (xmlSchemaBasicItemPtr)
  ------------------
15665|      0|				"The member type %s is not validly "
15666|      0|				"derived from its corresponding member "
15667|      0|				"type %s of the base type %s",
15668|      0|				xmlSchemaGetComponentQName(&str, member->type),
15669|      0|				xmlSchemaGetComponentQName(&strBMT, baseMember->type),
15670|      0|				xmlSchemaGetComponentQName(&strBT, type->baseType));
15671|      0|			    FREE_AND_NULL(str)
  ------------------
  |  |  320|      0|#define FREE_AND_NULL(str) if ((str) != NULL) { xmlFree((xmlChar *) (str)); str = NULL; }
  |  |  ------------------
  |  |  |  Branch (320:32): [True: 0, False: 0]
  |  |  ------------------
  ------------------
15672|      0|			    FREE_AND_NULL(strBMT)
  ------------------
  |  |  320|      0|#define FREE_AND_NULL(str) if ((str) != NULL) { xmlFree((xmlChar *) (str)); str = NULL; }
  |  |  ------------------
  |  |  |  Branch (320:32): [True: 0, False: 0]
  |  |  ------------------
  ------------------
15673|      0|			    FREE_AND_NULL(strBT)
  ------------------
  |  |  320|      0|#define FREE_AND_NULL(str) if ((str) != NULL) { xmlFree((xmlChar *) (str)); str = NULL; }
  |  |  ------------------
  |  |  |  Branch (320:32): [True: 0, False: 0]
  |  |  ------------------
  ------------------
15674|      0|			    return (XML_SCHEMAP_COS_ST_RESTRICTS_3_3_2_3);
15675|      0|			}
15676|      0|			member = member->next;
15677|      0|                        if (baseMember != NULL)
  ------------------
  |  Branch (15677:29): [True: 0, False: 0]
  ------------------
15678|      0|                            baseMember = baseMember->next;
15679|      0|		    }
15680|      0|		}
15681|      2|	    }
15682|       |	    /*
15683|       |	    * 3.3.2.4 Only pattern and enumeration facet components are
15684|       |	    * allowed among the {facets}.
15685|       |	    */
15686|      2|	    if (type->facets != NULL) {
  ------------------
  |  Branch (15686:10): [True: 2, False: 0]
  ------------------
15687|      2|		xmlSchemaFacetPtr facet;
15688|      2|		int ok = 1;
15689|       |
15690|      2|		facet = type->facets;
15691|      2|		do {
15692|      2|		    if ((facet->type != XML_SCHEMA_FACET_PATTERN) &&
  ------------------
  |  Branch (15692:11): [True: 1, False: 1]
  ------------------
15693|      2|			(facet->type != XML_SCHEMA_FACET_ENUMERATION)) {
  ------------------
  |  Branch (15693:4): [True: 0, False: 1]
  ------------------
15694|      0|			xmlSchemaPIllegalFacetListUnionErr(pctxt,
15695|      0|				XML_SCHEMAP_COS_ST_RESTRICTS_3_3_2_4,
15696|      0|				type, facet);
15697|      0|			ok = 0;
15698|      0|		    }
15699|      2|		    facet = facet->next;
15700|      2|		} while (facet != NULL);
  ------------------
  |  Branch (15700:12): [True: 0, False: 2]
  ------------------
15701|      2|		if (ok == 0)
  ------------------
  |  Branch (15701:7): [True: 0, False: 2]
  ------------------
15702|      0|		    return (XML_SCHEMAP_COS_ST_RESTRICTS_3_3_2_4);
15703|       |
15704|      2|	    }
15705|       |	    /*
15706|       |	    * SPEC (3.3.2.5) (same as 1.3.2)
15707|       |	    *
15708|       |	    * NOTE (3.3.2.5) This is currently done in
15709|       |	    * xmlSchemaDeriveAndValidateFacets()
15710|       |	    */
15711|      2|	}
15712|     27|    }
15713|       |
15714|    162|    return (0);
15715|    162|}
xmlschemas.c:xmlSchemaGetPrimitiveType:
13396|    227|{
13397|       |
13398|    715|    while (type != NULL) {
  ------------------
  |  Branch (13398:12): [True: 715, False: 0]
  ------------------
13399|       |	/*
13400|       |	* Note that anySimpleType is actually not a primitive type
13401|       |	* but we need that here.
13402|       |	*/
13403|    715|	if ((type->builtInType == XML_SCHEMAS_ANYSIMPLETYPE) ||
  ------------------
  |  Branch (13403:6): [True: 0, False: 715]
  ------------------
13404|    715|	   (type->flags & XML_SCHEMAS_TYPE_BUILTIN_PRIMITIVE))
  ------------------
  |  |  496|    715|#define XML_SCHEMAS_TYPE_BUILTIN_PRIMITIVE    1 << 14
  ------------------
  |  Branch (13404:5): [True: 227, False: 488]
  ------------------
13405|    227|	    return (type);
13406|    488|	type = type->baseType;
13407|    488|    }
13408|       |
13409|      0|    return (NULL);
13410|    227|}
xmlschemas.c:xmlSchemaCheckCOSSTDerivedOK:
14814|     20|{
14815|       |    /*
14816|       |    * 1 They are the same type definition.
14817|       |    * TODO: The identity check might have to be more complex than this.
14818|       |    */
14819|     20|    if (type == baseType)
  ------------------
  |  Branch (14819:9): [True: 10, False: 10]
  ------------------
14820|     10|	return (0);
14821|       |    /*
14822|       |    * 2.1 restriction is not in the subset, or in the {final}
14823|       |    * of its own {base type definition};
14824|       |    *
14825|       |    * NOTE that this will be used also via "xsi:type".
14826|       |    *
14827|       |    * TODO: Revise this, it looks strange. How can the "type"
14828|       |    * not be fixed or *in* fixing?
14829|       |    */
14830|     10|    if (WXS_IS_TYPE_NOT_FIXED(type))
  ------------------
  |  |  232|     10|    (((i)->type != XML_SCHEMA_TYPE_BASIC) && \
  |  |  ------------------
  |  |  |  Branch (232:6): [True: 7, False: 3]
  |  |  ------------------
  |  |  233|     10|     (((i)->flags & XML_SCHEMAS_TYPE_INTERNAL_RESOLVED) == 0))
  |  |  ------------------
  |  |  |  |  539|      7|#define XML_SCHEMAS_TYPE_INTERNAL_RESOLVED    1 << 22
  |  |  ------------------
  |  |  |  Branch (233:6): [True: 0, False: 7]
  |  |  ------------------
  ------------------
14831|      0|	if (xmlSchemaTypeFixup(type, actxt) == -1)
  ------------------
  |  Branch (14831:6): [True: 0, False: 0]
  ------------------
14832|      0|	    return(-1);
14833|     10|    if (WXS_IS_TYPE_NOT_FIXED(baseType))
  ------------------
  |  |  232|     10|    (((i)->type != XML_SCHEMA_TYPE_BASIC) && \
  |  |  ------------------
  |  |  |  Branch (232:6): [True: 0, False: 10]
  |  |  ------------------
  |  |  233|     10|     (((i)->flags & XML_SCHEMAS_TYPE_INTERNAL_RESOLVED) == 0))
  |  |  ------------------
  |  |  |  |  539|      0|#define XML_SCHEMAS_TYPE_INTERNAL_RESOLVED    1 << 22
  |  |  ------------------
  |  |  |  Branch (233:6): [True: 0, False: 0]
  |  |  ------------------
  ------------------
14834|      0|	if (xmlSchemaTypeFixup(baseType, actxt) == -1)
  ------------------
  |  Branch (14834:6): [True: 0, False: 0]
  ------------------
14835|      0|	    return(-1);
14836|     10|    if ((subset & SUBSET_RESTRICTION) ||
  ------------------
  |  |  341|     10|#define SUBSET_RESTRICTION  1<<0
  ------------------
  |  Branch (14836:9): [True: 0, False: 10]
  ------------------
14837|     10|	(xmlSchemaTypeFinalContains(type->baseType,
  ------------------
  |  Branch (14837:2): [True: 0, False: 10]
  ------------------
14838|     10|	    XML_SCHEMAS_TYPE_FINAL_RESTRICTION))) {
  ------------------
  |  |  472|     10|#define XML_SCHEMAS_TYPE_FINAL_RESTRICTION    1 << 10
  ------------------
14839|      0|	return (XML_SCHEMAP_COS_ST_DERIVED_OK_2_1);
14840|      0|    }
14841|       |    /* 2.2 */
14842|     10|    if (type->baseType == baseType) {
  ------------------
  |  Branch (14842:9): [True: 6, False: 4]
  ------------------
14843|       |	/*
14844|       |	* 2.2.1 D's `base type definition` is B.
14845|       |	*/
14846|      6|	return (0);
14847|      6|    }
14848|       |    /*
14849|       |    * 2.2.2 D's `base type definition` is not the `ur-type definition`
14850|       |    * and is validly derived from B given the subset, as defined by this
14851|       |    * constraint.
14852|       |    */
14853|      4|    if ((! WXS_IS_ANYTYPE(type->baseType)) &&
  ------------------
  |  |  209|      4|     (( (i)->type == XML_SCHEMA_TYPE_BASIC) && \
  |  |  ------------------
  |  |  |  Branch (209:7): [True: 2, False: 2]
  |  |  ------------------
  |  |  210|      4|      ( (WXS_TYPE_CAST (i))->builtInType == XML_SCHEMAS_ANYTYPE))
  |  |  ------------------
  |  |  |  |  127|      2|#define WXS_TYPE_CAST (xmlSchemaTypePtr)
  |  |  ------------------
  |  |  |  Branch (210:7): [True: 0, False: 2]
  |  |  ------------------
  ------------------
14854|      4|	(xmlSchemaCheckCOSSTDerivedOK(actxt, type->baseType,
  ------------------
  |  Branch (14854:2): [True: 4, False: 0]
  ------------------
14855|      4|	    baseType, subset) == 0)) {
14856|      4|	return (0);
14857|      4|    }
14858|       |    /*
14859|       |    * 2.2.3 D's {variety} is list or union and B is the `simple ur-type
14860|       |    * definition`.
14861|       |    */
14862|      0|    if (WXS_IS_ANY_SIMPLE_TYPE(baseType) &&
  ------------------
  |  |  222|      0|    (((i)->type == XML_SCHEMA_TYPE_BASIC) && \
  |  |  ------------------
  |  |  |  Branch (222:6): [True: 0, False: 0]
  |  |  ------------------
  |  |  223|      0|      ((i)->builtInType == XML_SCHEMAS_ANYSIMPLETYPE))
  |  |  ------------------
  |  |  |  Branch (223:7): [True: 0, False: 0]
  |  |  ------------------
  ------------------
14863|      0|	(WXS_IS_LIST(type) || WXS_IS_UNION(type))) {
  ------------------
  |  |  272|      0|#define WXS_IS_LIST(t) (t->flags & XML_SCHEMAS_TYPE_VARIETY_LIST)
  |  |  ------------------
  |  |  |  |  448|      0|#define XML_SCHEMAS_TYPE_VARIETY_LIST    1 << 6
  |  |  ------------------
  |  |  |  Branch (272:24): [True: 0, False: 0]
  |  |  ------------------
  ------------------
              	(WXS_IS_LIST(type) || WXS_IS_UNION(type))) {
  ------------------
  |  |  274|      0|#define WXS_IS_UNION(t) (t->flags & XML_SCHEMAS_TYPE_VARIETY_UNION)
  |  |  ------------------
  |  |  |  |  454|      0|#define XML_SCHEMAS_TYPE_VARIETY_UNION    1 << 7
  |  |  ------------------
  |  |  |  Branch (274:25): [True: 0, False: 0]
  |  |  ------------------
  ------------------
14864|      0|	return (0);
14865|      0|    }
14866|       |    /*
14867|       |    * 2.2.4 B's {variety} is union and D is validly derived from a type
14868|       |    * definition in B's {member type definitions} given the subset, as
14869|       |    * defined by this constraint.
14870|       |    *
14871|       |    * NOTE: This seems not to involve built-in types, since there is no
14872|       |    * built-in Union Simple Type.
14873|       |    */
14874|      0|    if (WXS_IS_UNION(baseType)) {
  ------------------
  |  |  274|      0|#define WXS_IS_UNION(t) (t->flags & XML_SCHEMAS_TYPE_VARIETY_UNION)
  |  |  ------------------
  |  |  |  |  454|      0|#define XML_SCHEMAS_TYPE_VARIETY_UNION    1 << 7
  |  |  ------------------
  |  |  |  Branch (274:25): [True: 0, False: 0]
  |  |  ------------------
  ------------------
14875|      0|	xmlSchemaTypeLinkPtr cur;
14876|       |
14877|      0|	cur = baseType->memberTypes;
14878|      0|	while (cur != NULL) {
  ------------------
  |  Branch (14878:9): [True: 0, False: 0]
  ------------------
14879|      0|	    if (WXS_IS_TYPE_NOT_FIXED(cur->type))
  ------------------
  |  |  232|      0|    (((i)->type != XML_SCHEMA_TYPE_BASIC) && \
  |  |  ------------------
  |  |  |  Branch (232:6): [True: 0, False: 0]
  |  |  ------------------
  |  |  233|      0|     (((i)->flags & XML_SCHEMAS_TYPE_INTERNAL_RESOLVED) == 0))
  |  |  ------------------
  |  |  |  |  539|      0|#define XML_SCHEMAS_TYPE_INTERNAL_RESOLVED    1 << 22
  |  |  ------------------
  |  |  |  Branch (233:6): [True: 0, False: 0]
  |  |  ------------------
  ------------------
14880|      0|		if (xmlSchemaTypeFixup(cur->type, actxt) == -1)
  ------------------
  |  Branch (14880:7): [True: 0, False: 0]
  ------------------
14881|      0|		    return(-1);
14882|      0|	    if (xmlSchemaCheckCOSSTDerivedOK(actxt,
  ------------------
  |  Branch (14882:10): [True: 0, False: 0]
  ------------------
14883|      0|		    type, cur->type, subset) == 0)
14884|      0|	    {
14885|       |		/*
14886|       |		* It just has to be validly derived from at least one
14887|       |		* member-type.
14888|       |		*/
14889|      0|		return (0);
14890|      0|	    }
14891|      0|	    cur = cur->next;
14892|      0|	}
14893|      0|    }
14894|      0|    return (XML_SCHEMAP_COS_ST_DERIVED_OK_2_2);
14895|      0|}
xmlschemas.c:xmlSchemaCheckFacetValues:
18780|    162|{
18781|    162|    int res, olderrs = pctxt->nberrors;
18782|    162|    const xmlChar *name = typeDecl->name;
18783|       |    /*
18784|       |    * NOTE: It is intended to use the facets list, instead
18785|       |    * of facetSet.
18786|       |    */
18787|    162|    if (typeDecl->facets != NULL) {
  ------------------
  |  Branch (18787:9): [True: 120, False: 42]
  ------------------
18788|    120|	xmlSchemaFacetPtr facet = typeDecl->facets;
18789|       |
18790|       |	/*
18791|       |	* Temporarily assign the "schema" to the validation context
18792|       |	* of the parser context. This is needed for NOTATION validation.
18793|       |	*/
18794|    120|	if (pctxt->vctxt == NULL) {
  ------------------
  |  Branch (18794:6): [True: 42, False: 78]
  ------------------
18795|     42|	    if (xmlSchemaCreateVCtxtOnPCtxt(pctxt) == -1)
  ------------------
  |  Branch (18795:10): [True: 0, False: 42]
  ------------------
18796|      0|		return(-1);
18797|     42|	}
18798|    120|	pctxt->vctxt->schema = pctxt->schema;
18799|    344|	while (facet != NULL) {
  ------------------
  |  Branch (18799:9): [True: 224, False: 120]
  ------------------
18800|    224|	    res = xmlSchemaCheckFacet(facet, typeDecl, pctxt, name);
18801|    224|	    HFAILURE
  ------------------
  |  |  333|    224|#define HFAILURE if (res == -1) goto exit_failure;
  |  |  ------------------
  |  |  |  Branch (333:22): [True: 0, False: 224]
  |  |  ------------------
  ------------------
18802|    224|	    facet = facet->next;
18803|    224|	}
18804|    120|	pctxt->vctxt->schema = NULL;
18805|    120|    }
18806|    162|    if (olderrs != pctxt->nberrors)
  ------------------
  |  Branch (18806:9): [True: 0, False: 162]
  ------------------
18807|      0|	return(pctxt->err);
18808|    162|    return(0);
18809|      0|exit_failure:
18810|      0|    return(-1);
18811|    162|}
xmlschemas.c:xmlSchemaCreateVCtxtOnPCtxt:
15766|     42|{
15767|     42|   if (ctxt->vctxt == NULL) {
  ------------------
  |  Branch (15767:8): [True: 42, False: 0]
  ------------------
15768|     42|	ctxt->vctxt = xmlSchemaNewValidCtxt(NULL);
15769|     42|	if (ctxt->vctxt == NULL) {
  ------------------
  |  Branch (15769:6): [True: 0, False: 42]
  ------------------
15770|      0|	    xmlSchemaPErr(ctxt, NULL,
15771|      0|		XML_SCHEMAP_INTERNAL,
15772|      0|		"Internal error: xmlSchemaCreateVCtxtOnPCtxt, "
15773|      0|		"failed to create a temp. validation context.\n",
15774|      0|		NULL, NULL);
15775|      0|	    return (-1);
15776|      0|	}
15777|       |	/* TODO: Pass user data. */
15778|     42|	xmlSchemaSetValidErrors(ctxt->vctxt,
15779|     42|	    ctxt->error, ctxt->warning, ctxt->errCtxt);
15780|     42|	xmlSchemaSetValidStructuredErrors(ctxt->vctxt,
15781|     42|	    ctxt->serror, ctxt->errCtxt);
15782|     42|    }
15783|     42|    return (0);
15784|     42|}
xmlschemas.c:xmlSchemaDeriveAndValidateFacets:
17230|    121|{
17231|    121|    xmlSchemaTypePtr base = type->baseType;
17232|    121|    xmlSchemaFacetLinkPtr link, cur, last = NULL;
17233|    121|    xmlSchemaFacetPtr facet, bfacet,
17234|    121|	flength = NULL, ftotdig = NULL, ffracdig = NULL,
17235|    121|	fmaxlen = NULL, fminlen = NULL, /* facets of the current type */
17236|    121|	fmininc = NULL, fmaxinc = NULL,
17237|    121|	fminexc = NULL, fmaxexc = NULL,
17238|    121|	bflength = NULL, bftotdig = NULL, bffracdig = NULL,
17239|    121|	bfmaxlen = NULL, bfminlen = NULL, /* facets of the base type */
17240|    121|	bfmininc = NULL, bfmaxinc = NULL,
17241|    121|	bfminexc = NULL, bfmaxexc = NULL;
17242|    121|    int res; /* err = 0, fixedErr; */
17243|       |
17244|       |    /*
17245|       |    * SPEC st-restrict-facets 1:
17246|       |    * "The {variety} of R is the same as that of B."
17247|       |    */
17248|       |    /*
17249|       |    * SPEC st-restrict-facets 2:
17250|       |    * "If {variety} is atomic, the {primitive type definition}
17251|       |    * of R is the same as that of B."
17252|       |    *
17253|       |    * NOTE: we leave 1 & 2 out for now, since this will be
17254|       |    * satisfied by the derivation process.
17255|       |    * CONSTRUCTION TODO: Maybe needed if using a construction API.
17256|       |    */
17257|       |    /*
17258|       |    * SPEC st-restrict-facets 3:
17259|       |    * "The {facets} of R are the union of S and the {facets}
17260|       |    * of B, eliminating duplicates. To eliminate duplicates,
17261|       |    * when a facet of the same kind occurs in both S and the
17262|       |    * {facets} of B, the one in the {facets} of B is not
17263|       |    * included, with the exception of enumeration and pattern
17264|       |    * facets, for which multiple occurrences with distinct values
17265|       |    * are allowed."
17266|       |    */
17267|       |
17268|    121|    if ((type->facetSet == NULL) && (base->facetSet == NULL))
  ------------------
  |  Branch (17268:9): [True: 1, False: 120]
  |  Branch (17268:37): [True: 0, False: 1]
  ------------------
17269|      0|	return (0);
17270|       |
17271|    121|    last = type->facetSet;
17272|    121|    if (last != NULL)
  ------------------
  |  Branch (17272:9): [True: 120, False: 1]
  ------------------
17273|    224|	while (last->next != NULL)
  ------------------
  |  Branch (17273:9): [True: 104, False: 120]
  ------------------
17274|    104|	    last = last->next;
17275|       |
17276|    345|    for (cur = type->facetSet; cur != NULL; cur = cur->next) {
  ------------------
  |  Branch (17276:32): [True: 224, False: 121]
  ------------------
17277|    224|	facet = cur->facet;
17278|    224|	switch (facet->type) {
17279|      3|	    case XML_SCHEMA_FACET_LENGTH:
  ------------------
  |  Branch (17279:6): [True: 3, False: 221]
  ------------------
17280|      3|		flength = facet; break;
17281|      7|	    case XML_SCHEMA_FACET_MINLENGTH:
  ------------------
  |  Branch (17281:6): [True: 7, False: 217]
  ------------------
17282|      7|		fminlen = facet; break;
17283|     17|	    case XML_SCHEMA_FACET_MININCLUSIVE:
  ------------------
  |  Branch (17283:6): [True: 17, False: 207]
  ------------------
17284|     17|		fmininc = facet; break;
17285|      9|	    case XML_SCHEMA_FACET_MINEXCLUSIVE:
  ------------------
  |  Branch (17285:6): [True: 9, False: 215]
  ------------------
17286|      9|		fminexc = facet; break;
17287|     13|	    case XML_SCHEMA_FACET_MAXLENGTH:
  ------------------
  |  Branch (17287:6): [True: 13, False: 211]
  ------------------
17288|     13|		fmaxlen = facet; break;
17289|     15|	    case XML_SCHEMA_FACET_MAXINCLUSIVE:
  ------------------
  |  Branch (17289:6): [True: 15, False: 209]
  ------------------
17290|     15|		fmaxinc = facet; break;
17291|     10|	    case XML_SCHEMA_FACET_MAXEXCLUSIVE:
  ------------------
  |  Branch (17291:6): [True: 10, False: 214]
  ------------------
17292|     10|		fmaxexc = facet; break;
17293|      7|	    case XML_SCHEMA_FACET_TOTALDIGITS:
  ------------------
  |  Branch (17293:6): [True: 7, False: 217]
  ------------------
17294|      7|		ftotdig = facet; break;
17295|      0|	    case XML_SCHEMA_FACET_FRACTIONDIGITS:
  ------------------
  |  Branch (17295:6): [True: 0, False: 224]
  ------------------
17296|      0|		ffracdig = facet; break;
17297|    143|	    default:
  ------------------
  |  Branch (17297:6): [True: 143, False: 81]
  ------------------
17298|    143|		break;
17299|    224|	}
17300|    224|    }
17301|    126|    for (cur = base->facetSet; cur != NULL; cur = cur->next) {
  ------------------
  |  Branch (17301:32): [True: 5, False: 121]
  ------------------
17302|      5|	facet = cur->facet;
17303|      5|	switch (facet->type) {
17304|      0|	    case XML_SCHEMA_FACET_LENGTH:
  ------------------
  |  Branch (17304:6): [True: 0, False: 5]
  ------------------
17305|      0|		bflength = facet; break;
17306|      1|	    case XML_SCHEMA_FACET_MINLENGTH:
  ------------------
  |  Branch (17306:6): [True: 1, False: 4]
  ------------------
17307|      1|		bfminlen = facet; break;
17308|      0|	    case XML_SCHEMA_FACET_MININCLUSIVE:
  ------------------
  |  Branch (17308:6): [True: 0, False: 5]
  ------------------
17309|      0|		bfmininc = facet; break;
17310|      0|	    case XML_SCHEMA_FACET_MINEXCLUSIVE:
  ------------------
  |  Branch (17310:6): [True: 0, False: 5]
  ------------------
17311|      0|		bfminexc = facet; break;
17312|      0|	    case XML_SCHEMA_FACET_MAXLENGTH:
  ------------------
  |  Branch (17312:6): [True: 0, False: 5]
  ------------------
17313|      0|		bfmaxlen = facet; break;
17314|      0|	    case XML_SCHEMA_FACET_MAXINCLUSIVE:
  ------------------
  |  Branch (17314:6): [True: 0, False: 5]
  ------------------
17315|      0|		bfmaxinc = facet; break;
17316|      0|	    case XML_SCHEMA_FACET_MAXEXCLUSIVE:
  ------------------
  |  Branch (17316:6): [True: 0, False: 5]
  ------------------
17317|      0|		bfmaxexc = facet; break;
17318|      0|	    case XML_SCHEMA_FACET_TOTALDIGITS:
  ------------------
  |  Branch (17318:6): [True: 0, False: 5]
  ------------------
17319|      0|		bftotdig = facet; break;
17320|      0|	    case XML_SCHEMA_FACET_FRACTIONDIGITS:
  ------------------
  |  Branch (17320:6): [True: 0, False: 5]
  ------------------
17321|      0|		bffracdig = facet; break;
17322|      4|	    default:
  ------------------
  |  Branch (17322:6): [True: 4, False: 1]
  ------------------
17323|      4|		break;
17324|      5|	}
17325|      5|    }
17326|       |    /*
17327|       |    * length and minLength or maxLength (2.2) + (3.2)
17328|       |    */
17329|    121|    if (flength && (fminlen || fmaxlen)) {
  ------------------
  |  Branch (17329:9): [True: 3, False: 118]
  |  Branch (17329:21): [True: 0, False: 3]
  |  Branch (17329:32): [True: 0, False: 3]
  ------------------
17330|      0|	FACET_RESTR_ERR(flength, "It is an error for both 'length' and "
  ------------------
  |  |17171|      0|    xmlSchemaPCustomErr(pctxt,      \
  |  |17172|      0|	XML_SCHEMAP_INVALID_FACET_VALUE, \
  |  |17173|      0|	WXS_BASIC_CAST fac1, fac1->node, \
  |  |  ------------------
  |  |  |  |  124|      0|#define WXS_BASIC_CAST (xmlSchemaBasicItemPtr)
  |  |  ------------------
  |  |17174|      0|	msg, NULL);
  ------------------
17331|      0|	    "either of 'minLength' or 'maxLength' to be specified on "
17332|      0|	    "the same type definition")
17333|      0|    }
17334|       |    /*
17335|       |    * Mutual exclusions in the same derivation step.
17336|       |    */
17337|    121|    if ((fmaxinc) && (fmaxexc)) {
  ------------------
  |  Branch (17337:9): [True: 15, False: 106]
  |  Branch (17337:22): [True: 0, False: 15]
  ------------------
17338|       |	/*
17339|       |	* SCC "maxInclusive and maxExclusive"
17340|       |	*/
17341|      0|	FACET_RESTR_MUTUAL_ERR(fmaxinc, fmaxexc)
  ------------------
  |  |17162|      0|    xmlSchemaPCustomErrExt(pctxt,      \
  |  |17163|      0|	XML_SCHEMAP_INVALID_FACET_VALUE, \
  |  |17164|      0|	WXS_BASIC_CAST fac1, fac1->node, \
  |  |  ------------------
  |  |  |  |  124|      0|#define WXS_BASIC_CAST (xmlSchemaBasicItemPtr)
  |  |  ------------------
  |  |17165|      0|	"It is an error for both '%s' and '%s' to be specified on the "\
  |  |17166|      0|	"same type definition", \
  |  |17167|      0|	BAD_CAST xmlSchemaFacetTypeToString(fac1->type), \
  |  |  ------------------
  |  |  |  |   35|      0|#define BAD_CAST (xmlChar *)
  |  |  ------------------
  |  |17168|      0|	BAD_CAST xmlSchemaFacetTypeToString(fac2->type), NULL);
  |  |  ------------------
  |  |  |  |   35|      0|#define BAD_CAST (xmlChar *)
  |  |  ------------------
  ------------------
17342|      0|    }
17343|    121|    if ((fmininc) && (fminexc)) {
  ------------------
  |  Branch (17343:9): [True: 17, False: 104]
  |  Branch (17343:22): [True: 0, False: 17]
  ------------------
17344|       |	/*
17345|       |	* SCC "minInclusive and minExclusive"
17346|       |	*/
17347|      0|	FACET_RESTR_MUTUAL_ERR(fmininc, fminexc)
  ------------------
  |  |17162|      0|    xmlSchemaPCustomErrExt(pctxt,      \
  |  |17163|      0|	XML_SCHEMAP_INVALID_FACET_VALUE, \
  |  |17164|      0|	WXS_BASIC_CAST fac1, fac1->node, \
  |  |  ------------------
  |  |  |  |  124|      0|#define WXS_BASIC_CAST (xmlSchemaBasicItemPtr)
  |  |  ------------------
  |  |17165|      0|	"It is an error for both '%s' and '%s' to be specified on the "\
  |  |17166|      0|	"same type definition", \
  |  |17167|      0|	BAD_CAST xmlSchemaFacetTypeToString(fac1->type), \
  |  |  ------------------
  |  |  |  |   35|      0|#define BAD_CAST (xmlChar *)
  |  |  ------------------
  |  |17168|      0|	BAD_CAST xmlSchemaFacetTypeToString(fac2->type), NULL);
  |  |  ------------------
  |  |  |  |   35|      0|#define BAD_CAST (xmlChar *)
  |  |  ------------------
  ------------------
17348|      0|    }
17349|       |
17350|    121|    if (flength && bflength) {
  ------------------
  |  Branch (17350:9): [True: 3, False: 118]
  |  Branch (17350:20): [True: 0, False: 3]
  ------------------
17351|       |	/*
17352|       |	* SCC "length valid restriction"
17353|       |	* The values have to be equal.
17354|       |	*/
17355|      0|	res = xmlSchemaCompareValues(flength->val, bflength->val);
17356|      0|	if (res == -2)
  ------------------
  |  Branch (17356:6): [True: 0, False: 0]
  ------------------
17357|      0|	    goto internal_error;
17358|      0|	if (res != 0)
  ------------------
  |  Branch (17358:6): [True: 0, False: 0]
  ------------------
17359|      0|	    xmlSchemaDeriveFacetErr(pctxt, flength, bflength, 0, 0, 1);
17360|      0|	if ((res != 0) && (bflength->fixed)) {
  ------------------
  |  Branch (17360:6): [True: 0, False: 0]
  |  Branch (17360:20): [True: 0, False: 0]
  ------------------
17361|      0|	    FACET_RESTR_FIXED_ERR(flength)
  ------------------
  |  |17177|      0|    xmlSchemaPCustomErr(pctxt, \
  |  |17178|      0|	XML_SCHEMAP_INVALID_FACET_VALUE, \
  |  |17179|      0|	WXS_BASIC_CAST fac, fac->node, \
  |  |  ------------------
  |  |  |  |  124|      0|#define WXS_BASIC_CAST (xmlSchemaBasicItemPtr)
  |  |  ------------------
  |  |17180|      0|	"The base type's facet is 'fixed', thus the value must not " \
  |  |17181|      0|	"differ", NULL);
  ------------------
17362|      0|	}
17363|       |
17364|      0|    }
17365|    121|    if (fminlen && bfminlen) {
  ------------------
  |  Branch (17365:9): [True: 7, False: 114]
  |  Branch (17365:20): [True: 0, False: 7]
  ------------------
17366|       |	/*
17367|       |	* SCC "minLength valid restriction"
17368|       |	* minLength >= BASE minLength
17369|       |	*/
17370|      0|	res = xmlSchemaCompareValues(fminlen->val, bfminlen->val);
17371|      0|	if (res == -2)
  ------------------
  |  Branch (17371:6): [True: 0, False: 0]
  ------------------
17372|      0|	    goto internal_error;
17373|      0|	if (res == -1)
  ------------------
  |  Branch (17373:6): [True: 0, False: 0]
  ------------------
17374|      0|	    xmlSchemaDeriveFacetErr(pctxt, fminlen, bfminlen, 1, 1, 1);
17375|      0|	if ((res != 0) && (bfminlen->fixed)) {
  ------------------
  |  Branch (17375:6): [True: 0, False: 0]
  |  Branch (17375:20): [True: 0, False: 0]
  ------------------
17376|      0|	    FACET_RESTR_FIXED_ERR(fminlen)
  ------------------
  |  |17177|      0|    xmlSchemaPCustomErr(pctxt, \
  |  |17178|      0|	XML_SCHEMAP_INVALID_FACET_VALUE, \
  |  |17179|      0|	WXS_BASIC_CAST fac, fac->node, \
  |  |  ------------------
  |  |  |  |  124|      0|#define WXS_BASIC_CAST (xmlSchemaBasicItemPtr)
  |  |  ------------------
  |  |17180|      0|	"The base type's facet is 'fixed', thus the value must not " \
  |  |17181|      0|	"differ", NULL);
  ------------------
17377|      0|	}
17378|      0|    }
17379|    121|    if (fmaxlen && bfmaxlen) {
  ------------------
  |  Branch (17379:9): [True: 13, False: 108]
  |  Branch (17379:20): [True: 0, False: 13]
  ------------------
17380|       |	/*
17381|       |	* SCC "maxLength valid restriction"
17382|       |	* maxLength <= BASE minLength
17383|       |	*/
17384|      0|	res = xmlSchemaCompareValues(fmaxlen->val, bfmaxlen->val);
17385|      0|	if (res == -2)
  ------------------
  |  Branch (17385:6): [True: 0, False: 0]
  ------------------
17386|      0|	    goto internal_error;
17387|      0|	if (res == 1)
  ------------------
  |  Branch (17387:6): [True: 0, False: 0]
  ------------------
17388|      0|	    xmlSchemaDeriveFacetErr(pctxt, fmaxlen, bfmaxlen, -1, 1, 1);
17389|      0|	if ((res != 0) && (bfmaxlen->fixed)) {
  ------------------
  |  Branch (17389:6): [True: 0, False: 0]
  |  Branch (17389:20): [True: 0, False: 0]
  ------------------
17390|      0|	    FACET_RESTR_FIXED_ERR(fmaxlen)
  ------------------
  |  |17177|      0|    xmlSchemaPCustomErr(pctxt, \
  |  |17178|      0|	XML_SCHEMAP_INVALID_FACET_VALUE, \
  |  |17179|      0|	WXS_BASIC_CAST fac, fac->node, \
  |  |  ------------------
  |  |  |  |  124|      0|#define WXS_BASIC_CAST (xmlSchemaBasicItemPtr)
  |  |  ------------------
  |  |17180|      0|	"The base type's facet is 'fixed', thus the value must not " \
  |  |17181|      0|	"differ", NULL);
  ------------------
17391|      0|	}
17392|      0|    }
17393|       |    /*
17394|       |    * SCC "length and minLength or maxLength"
17395|       |    */
17396|    121|    if (! flength)
  ------------------
  |  Branch (17396:9): [True: 118, False: 3]
  ------------------
17397|    118|	flength = bflength;
17398|    121|    if (flength) {
  ------------------
  |  Branch (17398:9): [True: 3, False: 118]
  ------------------
17399|      3|	if (! fminlen)
  ------------------
  |  Branch (17399:6): [True: 3, False: 0]
  ------------------
17400|      3|	    fminlen = bfminlen;
17401|      3|	if (fminlen) {
  ------------------
  |  Branch (17401:6): [True: 0, False: 3]
  ------------------
17402|       |	    /* (1.1) length >= minLength */
17403|      0|	    res = xmlSchemaCompareValues(flength->val, fminlen->val);
17404|      0|	    if (res == -2)
  ------------------
  |  Branch (17404:10): [True: 0, False: 0]
  ------------------
17405|      0|		goto internal_error;
17406|      0|	    if (res == -1)
  ------------------
  |  Branch (17406:10): [True: 0, False: 0]
  ------------------
17407|      0|		xmlSchemaDeriveFacetErr(pctxt, flength, fminlen, 1, 1, 0);
17408|      0|	}
17409|      3|	if (! fmaxlen)
  ------------------
  |  Branch (17409:6): [True: 3, False: 0]
  ------------------
17410|      3|	    fmaxlen = bfmaxlen;
17411|      3|	if (fmaxlen) {
  ------------------
  |  Branch (17411:6): [True: 0, False: 3]
  ------------------
17412|       |	    /* (2.1) length <= maxLength */
17413|      0|	    res = xmlSchemaCompareValues(flength->val, fmaxlen->val);
17414|      0|	    if (res == -2)
  ------------------
  |  Branch (17414:10): [True: 0, False: 0]
  ------------------
17415|      0|		goto internal_error;
17416|      0|	    if (res == 1)
  ------------------
  |  Branch (17416:10): [True: 0, False: 0]
  ------------------
17417|      0|		xmlSchemaDeriveFacetErr(pctxt, flength, fmaxlen, -1, 1, 0);
17418|      0|	}
17419|      3|    }
17420|    121|    if (fmaxinc) {
  ------------------
  |  Branch (17420:9): [True: 15, False: 106]
  ------------------
17421|       |	/*
17422|       |	* "maxInclusive"
17423|       |	*/
17424|     15|	if (fmininc) {
  ------------------
  |  Branch (17424:6): [True: 15, False: 0]
  ------------------
17425|       |	    /* SCC "maxInclusive >= minInclusive" */
17426|     15|	    res = xmlSchemaCompareValues(fmaxinc->val, fmininc->val);
17427|     15|	    if (res == -2)
  ------------------
  |  Branch (17427:10): [True: 0, False: 15]
  ------------------
17428|      0|		goto internal_error;
17429|     15|	    if (res == -1) {
  ------------------
  |  Branch (17429:10): [True: 0, False: 15]
  ------------------
17430|      0|		xmlSchemaDeriveFacetErr(pctxt, fmaxinc, fmininc, 1, 1, 0);
17431|      0|	    }
17432|     15|	}
17433|       |	/*
17434|       |	* SCC "maxInclusive valid restriction"
17435|       |	*/
17436|     15|	if (bfmaxinc) {
  ------------------
  |  Branch (17436:6): [True: 0, False: 15]
  ------------------
17437|       |	    /* maxInclusive <= BASE maxInclusive */
17438|      0|	    res = xmlSchemaCompareValues(fmaxinc->val, bfmaxinc->val);
17439|      0|	    if (res == -2)
  ------------------
  |  Branch (17439:10): [True: 0, False: 0]
  ------------------
17440|      0|		goto internal_error;
17441|      0|	    if (res == 1)
  ------------------
  |  Branch (17441:10): [True: 0, False: 0]
  ------------------
17442|      0|		xmlSchemaDeriveFacetErr(pctxt, fmaxinc, bfmaxinc, -1, 1, 1);
17443|      0|	    if ((res != 0) && (bfmaxinc->fixed)) {
  ------------------
  |  Branch (17443:10): [True: 0, False: 0]
  |  Branch (17443:24): [True: 0, False: 0]
  ------------------
17444|      0|		FACET_RESTR_FIXED_ERR(fmaxinc)
  ------------------
  |  |17177|      0|    xmlSchemaPCustomErr(pctxt, \
  |  |17178|      0|	XML_SCHEMAP_INVALID_FACET_VALUE, \
  |  |17179|      0|	WXS_BASIC_CAST fac, fac->node, \
  |  |  ------------------
  |  |  |  |  124|      0|#define WXS_BASIC_CAST (xmlSchemaBasicItemPtr)
  |  |  ------------------
  |  |17180|      0|	"The base type's facet is 'fixed', thus the value must not " \
  |  |17181|      0|	"differ", NULL);
  ------------------
17445|      0|	    }
17446|      0|	}
17447|     15|	if (bfmaxexc) {
  ------------------
  |  Branch (17447:6): [True: 0, False: 15]
  ------------------
17448|       |	    /* maxInclusive < BASE maxExclusive */
17449|      0|	    res = xmlSchemaCompareValues(fmaxinc->val, bfmaxexc->val);
17450|      0|	    if (res == -2)
  ------------------
  |  Branch (17450:10): [True: 0, False: 0]
  ------------------
17451|      0|		goto internal_error;
17452|      0|	    if (res != -1) {
  ------------------
  |  Branch (17452:10): [True: 0, False: 0]
  ------------------
17453|      0|		xmlSchemaDeriveFacetErr(pctxt, fmaxinc, bfmaxexc, -1, 0, 1);
17454|      0|	    }
17455|      0|	}
17456|     15|	if (bfmininc) {
  ------------------
  |  Branch (17456:6): [True: 0, False: 15]
  ------------------
17457|       |	    /* maxInclusive >= BASE minInclusive */
17458|      0|	    res = xmlSchemaCompareValues(fmaxinc->val, bfmininc->val);
17459|      0|	    if (res == -2)
  ------------------
  |  Branch (17459:10): [True: 0, False: 0]
  ------------------
17460|      0|		goto internal_error;
17461|      0|	    if (res == -1) {
  ------------------
  |  Branch (17461:10): [True: 0, False: 0]
  ------------------
17462|      0|		xmlSchemaDeriveFacetErr(pctxt, fmaxinc, bfmininc, 1, 1, 1);
17463|      0|	    }
17464|      0|	}
17465|     15|	if (bfminexc) {
  ------------------
  |  Branch (17465:6): [True: 0, False: 15]
  ------------------
17466|       |	    /* maxInclusive > BASE minExclusive */
17467|      0|	    res = xmlSchemaCompareValues(fmaxinc->val, bfminexc->val);
17468|      0|	    if (res == -2)
  ------------------
  |  Branch (17468:10): [True: 0, False: 0]
  ------------------
17469|      0|		goto internal_error;
17470|      0|	    if (res != 1) {
  ------------------
  |  Branch (17470:10): [True: 0, False: 0]
  ------------------
17471|      0|		xmlSchemaDeriveFacetErr(pctxt, fmaxinc, bfminexc, 1, 0, 1);
17472|      0|	    }
17473|      0|	}
17474|     15|    }
17475|    121|    if (fmaxexc) {
  ------------------
  |  Branch (17475:9): [True: 10, False: 111]
  ------------------
17476|       |	/*
17477|       |	* "maxExclusive >= minExclusive"
17478|       |	*/
17479|     10|	if (fminexc) {
  ------------------
  |  Branch (17479:6): [True: 6, False: 4]
  ------------------
17480|      6|	    res = xmlSchemaCompareValues(fmaxexc->val, fminexc->val);
17481|      6|	    if (res == -2)
  ------------------
  |  Branch (17481:10): [True: 0, False: 6]
  ------------------
17482|      0|		goto internal_error;
17483|      6|	    if (res == -1) {
  ------------------
  |  Branch (17483:10): [True: 0, False: 6]
  ------------------
17484|      0|		xmlSchemaDeriveFacetErr(pctxt, fmaxexc, fminexc, 1, 1, 0);
17485|      0|	    }
17486|      6|	}
17487|       |	/*
17488|       |	* "maxExclusive valid restriction"
17489|       |	*/
17490|     10|	if (bfmaxexc) {
  ------------------
  |  Branch (17490:6): [True: 0, False: 10]
  ------------------
17491|       |	    /* maxExclusive <= BASE maxExclusive */
17492|      0|	    res = xmlSchemaCompareValues(fmaxexc->val, bfmaxexc->val);
17493|      0|	    if (res == -2)
  ------------------
  |  Branch (17493:10): [True: 0, False: 0]
  ------------------
17494|      0|		goto internal_error;
17495|      0|	    if (res == 1) {
  ------------------
  |  Branch (17495:10): [True: 0, False: 0]
  ------------------
17496|      0|		xmlSchemaDeriveFacetErr(pctxt, fmaxexc, bfmaxexc, -1, 1, 1);
17497|      0|	    }
17498|      0|	    if ((res != 0) && (bfmaxexc->fixed)) {
  ------------------
  |  Branch (17498:10): [True: 0, False: 0]
  |  Branch (17498:24): [True: 0, False: 0]
  ------------------
17499|      0|		FACET_RESTR_FIXED_ERR(fmaxexc)
  ------------------
  |  |17177|      0|    xmlSchemaPCustomErr(pctxt, \
  |  |17178|      0|	XML_SCHEMAP_INVALID_FACET_VALUE, \
  |  |17179|      0|	WXS_BASIC_CAST fac, fac->node, \
  |  |  ------------------
  |  |  |  |  124|      0|#define WXS_BASIC_CAST (xmlSchemaBasicItemPtr)
  |  |  ------------------
  |  |17180|      0|	"The base type's facet is 'fixed', thus the value must not " \
  |  |17181|      0|	"differ", NULL);
  ------------------
17500|      0|	    }
17501|      0|	}
17502|     10|	if (bfmaxinc) {
  ------------------
  |  Branch (17502:6): [True: 0, False: 10]
  ------------------
17503|       |	    /* maxExclusive <= BASE maxInclusive */
17504|      0|	    res = xmlSchemaCompareValues(fmaxexc->val, bfmaxinc->val);
17505|      0|	    if (res == -2)
  ------------------
  |  Branch (17505:10): [True: 0, False: 0]
  ------------------
17506|      0|		goto internal_error;
17507|      0|	    if (res == 1) {
  ------------------
  |  Branch (17507:10): [True: 0, False: 0]
  ------------------
17508|      0|		xmlSchemaDeriveFacetErr(pctxt, fmaxexc, bfmaxinc, -1, 1, 1);
17509|      0|	    }
17510|      0|	}
17511|     10|	if (bfmininc) {
  ------------------
  |  Branch (17511:6): [True: 0, False: 10]
  ------------------
17512|       |	    /* maxExclusive > BASE minInclusive */
17513|      0|	    res = xmlSchemaCompareValues(fmaxexc->val, bfmininc->val);
17514|      0|	    if (res == -2)
  ------------------
  |  Branch (17514:10): [True: 0, False: 0]
  ------------------
17515|      0|		goto internal_error;
17516|      0|	    if (res != 1) {
  ------------------
  |  Branch (17516:10): [True: 0, False: 0]
  ------------------
17517|      0|		xmlSchemaDeriveFacetErr(pctxt, fmaxexc, bfmininc, 1, 0, 1);
17518|      0|	    }
17519|      0|	}
17520|     10|	if (bfminexc) {
  ------------------
  |  Branch (17520:6): [True: 0, False: 10]
  ------------------
17521|       |	    /* maxExclusive > BASE minExclusive */
17522|      0|	    res = xmlSchemaCompareValues(fmaxexc->val, bfminexc->val);
17523|      0|	    if (res == -2)
  ------------------
  |  Branch (17523:10): [True: 0, False: 0]
  ------------------
17524|      0|		goto internal_error;
17525|      0|	    if (res != 1) {
  ------------------
  |  Branch (17525:10): [True: 0, False: 0]
  ------------------
17526|      0|		xmlSchemaDeriveFacetErr(pctxt, fmaxexc, bfminexc, 1, 0, 1);
17527|      0|	    }
17528|      0|	}
17529|     10|    }
17530|    121|    if (fminexc) {
  ------------------
  |  Branch (17530:9): [True: 9, False: 112]
  ------------------
17531|       |	/*
17532|       |	* "minExclusive < maxInclusive"
17533|       |	*/
17534|      9|	if (fmaxinc) {
  ------------------
  |  Branch (17534:6): [True: 0, False: 9]
  ------------------
17535|      0|	    res = xmlSchemaCompareValues(fminexc->val, fmaxinc->val);
17536|      0|	    if (res == -2)
  ------------------
  |  Branch (17536:10): [True: 0, False: 0]
  ------------------
17537|      0|		goto internal_error;
17538|      0|	    if (res != -1) {
  ------------------
  |  Branch (17538:10): [True: 0, False: 0]
  ------------------
17539|      0|		xmlSchemaDeriveFacetErr(pctxt, fminexc, fmaxinc, -1, 0, 0);
17540|      0|	    }
17541|      0|	}
17542|       |	/*
17543|       |	* "minExclusive valid restriction"
17544|       |	*/
17545|      9|	if (bfminexc) {
  ------------------
  |  Branch (17545:6): [True: 0, False: 9]
  ------------------
17546|       |	    /* minExclusive >= BASE minExclusive */
17547|      0|	    res = xmlSchemaCompareValues(fminexc->val, bfminexc->val);
17548|      0|	    if (res == -2)
  ------------------
  |  Branch (17548:10): [True: 0, False: 0]
  ------------------
17549|      0|		goto internal_error;
17550|      0|	    if (res == -1) {
  ------------------
  |  Branch (17550:10): [True: 0, False: 0]
  ------------------
17551|      0|		xmlSchemaDeriveFacetErr(pctxt, fminexc, bfminexc, 1, 1, 1);
17552|      0|	    }
17553|      0|	    if ((res != 0) && (bfminexc->fixed)) {
  ------------------
  |  Branch (17553:10): [True: 0, False: 0]
  |  Branch (17553:24): [True: 0, False: 0]
  ------------------
17554|      0|		FACET_RESTR_FIXED_ERR(fminexc)
  ------------------
  |  |17177|      0|    xmlSchemaPCustomErr(pctxt, \
  |  |17178|      0|	XML_SCHEMAP_INVALID_FACET_VALUE, \
  |  |17179|      0|	WXS_BASIC_CAST fac, fac->node, \
  |  |  ------------------
  |  |  |  |  124|      0|#define WXS_BASIC_CAST (xmlSchemaBasicItemPtr)
  |  |  ------------------
  |  |17180|      0|	"The base type's facet is 'fixed', thus the value must not " \
  |  |17181|      0|	"differ", NULL);
  ------------------
17555|      0|	    }
17556|      0|	}
17557|      9|	if (bfmaxinc) {
  ------------------
  |  Branch (17557:6): [True: 0, False: 9]
  ------------------
17558|       |	    /* minExclusive <= BASE maxInclusive */
17559|      0|	    res = xmlSchemaCompareValues(fminexc->val, bfmaxinc->val);
17560|      0|	    if (res == -2)
  ------------------
  |  Branch (17560:10): [True: 0, False: 0]
  ------------------
17561|      0|		goto internal_error;
17562|      0|	    if (res == 1) {
  ------------------
  |  Branch (17562:10): [True: 0, False: 0]
  ------------------
17563|      0|		xmlSchemaDeriveFacetErr(pctxt, fminexc, bfmaxinc, -1, 1, 1);
17564|      0|	    }
17565|      0|	}
17566|      9|	if (bfmininc) {
  ------------------
  |  Branch (17566:6): [True: 0, False: 9]
  ------------------
17567|       |	    /* minExclusive >= BASE minInclusive */
17568|      0|	    res = xmlSchemaCompareValues(fminexc->val, bfmininc->val);
17569|      0|	    if (res == -2)
  ------------------
  |  Branch (17569:10): [True: 0, False: 0]
  ------------------
17570|      0|		goto internal_error;
17571|      0|	    if (res == -1) {
  ------------------
  |  Branch (17571:10): [True: 0, False: 0]
  ------------------
17572|      0|		xmlSchemaDeriveFacetErr(pctxt, fminexc, bfmininc, 1, 1, 1);
17573|      0|	    }
17574|      0|	}
17575|      9|	if (bfmaxexc) {
  ------------------
  |  Branch (17575:6): [True: 0, False: 9]
  ------------------
17576|       |	    /* minExclusive < BASE maxExclusive */
17577|      0|	    res = xmlSchemaCompareValues(fminexc->val, bfmaxexc->val);
17578|      0|	    if (res == -2)
  ------------------
  |  Branch (17578:10): [True: 0, False: 0]
  ------------------
17579|      0|		goto internal_error;
17580|      0|	    if (res != -1) {
  ------------------
  |  Branch (17580:10): [True: 0, False: 0]
  ------------------
17581|      0|		xmlSchemaDeriveFacetErr(pctxt, fminexc, bfmaxexc, -1, 0, 1);
17582|      0|	    }
17583|      0|	}
17584|      9|    }
17585|    121|    if (fmininc) {
  ------------------
  |  Branch (17585:9): [True: 17, False: 104]
  ------------------
17586|       |	/*
17587|       |	* "minInclusive < maxExclusive"
17588|       |	*/
17589|     17|	if (fmaxexc) {
  ------------------
  |  Branch (17589:6): [True: 0, False: 17]
  ------------------
17590|      0|	    res = xmlSchemaCompareValues(fmininc->val, fmaxexc->val);
17591|      0|	    if (res == -2)
  ------------------
  |  Branch (17591:10): [True: 0, False: 0]
  ------------------
17592|      0|		goto internal_error;
17593|      0|	    if (res != -1) {
  ------------------
  |  Branch (17593:10): [True: 0, False: 0]
  ------------------
17594|      0|		xmlSchemaDeriveFacetErr(pctxt, fmininc, fmaxexc, -1, 0, 0);
17595|      0|	    }
17596|      0|	}
17597|       |	/*
17598|       |	* "minExclusive valid restriction"
17599|       |	*/
17600|     17|	if (bfmininc) {
  ------------------
  |  Branch (17600:6): [True: 0, False: 17]
  ------------------
17601|       |	    /* minInclusive >= BASE minInclusive */
17602|      0|	    res = xmlSchemaCompareValues(fmininc->val, bfmininc->val);
17603|      0|	    if (res == -2)
  ------------------
  |  Branch (17603:10): [True: 0, False: 0]
  ------------------
17604|      0|		goto internal_error;
17605|      0|	    if (res == -1) {
  ------------------
  |  Branch (17605:10): [True: 0, False: 0]
  ------------------
17606|      0|		xmlSchemaDeriveFacetErr(pctxt, fmininc, bfmininc, 1, 1, 1);
17607|      0|	    }
17608|      0|	    if ((res != 0) && (bfmininc->fixed)) {
  ------------------
  |  Branch (17608:10): [True: 0, False: 0]
  |  Branch (17608:24): [True: 0, False: 0]
  ------------------
17609|      0|		FACET_RESTR_FIXED_ERR(fmininc)
  ------------------
  |  |17177|      0|    xmlSchemaPCustomErr(pctxt, \
  |  |17178|      0|	XML_SCHEMAP_INVALID_FACET_VALUE, \
  |  |17179|      0|	WXS_BASIC_CAST fac, fac->node, \
  |  |  ------------------
  |  |  |  |  124|      0|#define WXS_BASIC_CAST (xmlSchemaBasicItemPtr)
  |  |  ------------------
  |  |17180|      0|	"The base type's facet is 'fixed', thus the value must not " \
  |  |17181|      0|	"differ", NULL);
  ------------------
17610|      0|	    }
17611|      0|	}
17612|     17|	if (bfmaxinc) {
  ------------------
  |  Branch (17612:6): [True: 0, False: 17]
  ------------------
17613|       |	    /* minInclusive <= BASE maxInclusive */
17614|      0|	    res = xmlSchemaCompareValues(fmininc->val, bfmaxinc->val);
17615|      0|	    if (res == -2)
  ------------------
  |  Branch (17615:10): [True: 0, False: 0]
  ------------------
17616|      0|		goto internal_error;
17617|      0|	    if (res == 1) {
  ------------------
  |  Branch (17617:10): [True: 0, False: 0]
  ------------------
17618|      0|		xmlSchemaDeriveFacetErr(pctxt, fmininc, bfmaxinc, -1, 1, 1);
17619|      0|	    }
17620|      0|	}
17621|     17|	if (bfminexc) {
  ------------------
  |  Branch (17621:6): [True: 0, False: 17]
  ------------------
17622|       |	    /* minInclusive > BASE minExclusive */
17623|      0|	    res = xmlSchemaCompareValues(fmininc->val, bfminexc->val);
17624|      0|	    if (res == -2)
  ------------------
  |  Branch (17624:10): [True: 0, False: 0]
  ------------------
17625|      0|		goto internal_error;
17626|      0|	    if (res != 1)
  ------------------
  |  Branch (17626:10): [True: 0, False: 0]
  ------------------
17627|      0|		xmlSchemaDeriveFacetErr(pctxt, fmininc, bfminexc, 1, 0, 1);
17628|      0|	}
17629|     17|	if (bfmaxexc) {
  ------------------
  |  Branch (17629:6): [True: 0, False: 17]
  ------------------
17630|       |	    /* minInclusive < BASE maxExclusive */
17631|      0|	    res = xmlSchemaCompareValues(fmininc->val, bfmaxexc->val);
17632|      0|	    if (res == -2)
  ------------------
  |  Branch (17632:10): [True: 0, False: 0]
  ------------------
17633|      0|		goto internal_error;
17634|      0|	    if (res != -1)
  ------------------
  |  Branch (17634:10): [True: 0, False: 0]
  ------------------
17635|      0|		xmlSchemaDeriveFacetErr(pctxt, fmininc, bfmaxexc, -1, 0, 1);
17636|      0|	}
17637|     17|    }
17638|    121|    if (ftotdig && bftotdig) {
  ------------------
  |  Branch (17638:9): [True: 7, False: 114]
  |  Branch (17638:20): [True: 0, False: 7]
  ------------------
17639|       |	/*
17640|       |	* SCC " totalDigits valid restriction"
17641|       |	* totalDigits <= BASE totalDigits
17642|       |	*/
17643|      0|	res = xmlSchemaCompareValues(ftotdig->val, bftotdig->val);
17644|      0|	if (res == -2)
  ------------------
  |  Branch (17644:6): [True: 0, False: 0]
  ------------------
17645|      0|	    goto internal_error;
17646|      0|	if (res == 1)
  ------------------
  |  Branch (17646:6): [True: 0, False: 0]
  ------------------
17647|      0|	    xmlSchemaDeriveFacetErr(pctxt, ftotdig, bftotdig,
17648|      0|	    -1, 1, 1);
17649|      0|	if ((res != 0) && (bftotdig->fixed)) {
  ------------------
  |  Branch (17649:6): [True: 0, False: 0]
  |  Branch (17649:20): [True: 0, False: 0]
  ------------------
17650|      0|	    FACET_RESTR_FIXED_ERR(ftotdig)
  ------------------
  |  |17177|      0|    xmlSchemaPCustomErr(pctxt, \
  |  |17178|      0|	XML_SCHEMAP_INVALID_FACET_VALUE, \
  |  |17179|      0|	WXS_BASIC_CAST fac, fac->node, \
  |  |  ------------------
  |  |  |  |  124|      0|#define WXS_BASIC_CAST (xmlSchemaBasicItemPtr)
  |  |  ------------------
  |  |17180|      0|	"The base type's facet is 'fixed', thus the value must not " \
  |  |17181|      0|	"differ", NULL);
  ------------------
17651|      0|	}
17652|      0|    }
17653|    121|    if (ffracdig && bffracdig) {
  ------------------
  |  Branch (17653:9): [True: 0, False: 121]
  |  Branch (17653:21): [True: 0, False: 0]
  ------------------
17654|       |	/*
17655|       |	* SCC  "fractionDigits valid restriction"
17656|       |	* fractionDigits <= BASE fractionDigits
17657|       |	*/
17658|      0|	res = xmlSchemaCompareValues(ffracdig->val, bffracdig->val);
17659|      0|	if (res == -2)
  ------------------
  |  Branch (17659:6): [True: 0, False: 0]
  ------------------
17660|      0|	    goto internal_error;
17661|      0|	if (res == 1)
  ------------------
  |  Branch (17661:6): [True: 0, False: 0]
  ------------------
17662|      0|	    xmlSchemaDeriveFacetErr(pctxt, ffracdig, bffracdig,
17663|      0|	    -1, 1, 1);
17664|      0|	if ((res != 0) && (bffracdig->fixed)) {
  ------------------
  |  Branch (17664:6): [True: 0, False: 0]
  |  Branch (17664:20): [True: 0, False: 0]
  ------------------
17665|      0|	    FACET_RESTR_FIXED_ERR(ffracdig)
  ------------------
  |  |17177|      0|    xmlSchemaPCustomErr(pctxt, \
  |  |17178|      0|	XML_SCHEMAP_INVALID_FACET_VALUE, \
  |  |17179|      0|	WXS_BASIC_CAST fac, fac->node, \
  |  |  ------------------
  |  |  |  |  124|      0|#define WXS_BASIC_CAST (xmlSchemaBasicItemPtr)
  |  |  ------------------
  |  |17180|      0|	"The base type's facet is 'fixed', thus the value must not " \
  |  |17181|      0|	"differ", NULL);
  ------------------
17666|      0|	}
17667|      0|    }
17668|       |    /*
17669|       |    * SCC "fractionDigits less than or equal to totalDigits"
17670|       |    */
17671|    121|    if (! ftotdig)
  ------------------
  |  Branch (17671:9): [True: 114, False: 7]
  ------------------
17672|    114|	ftotdig = bftotdig;
17673|    121|    if (! ffracdig)
  ------------------
  |  Branch (17673:9): [True: 121, False: 0]
  ------------------
17674|    121|	ffracdig = bffracdig;
17675|    121|    if (ftotdig && ffracdig) {
  ------------------
  |  Branch (17675:9): [True: 7, False: 114]
  |  Branch (17675:20): [True: 0, False: 7]
  ------------------
17676|      0|	res = xmlSchemaCompareValues(ffracdig->val, ftotdig->val);
17677|      0|	if (res == -2)
  ------------------
  |  Branch (17677:6): [True: 0, False: 0]
  ------------------
17678|      0|	    goto internal_error;
17679|      0|	if (res == 1)
  ------------------
  |  Branch (17679:6): [True: 0, False: 0]
  ------------------
17680|      0|	    xmlSchemaDeriveFacetErr(pctxt, ffracdig, ftotdig,
17681|      0|		-1, 1, 0);
17682|      0|    }
17683|       |    /*
17684|       |    * *Enumerations* won' be added here, since only the first set
17685|       |    * of enumerations in the ancestor-or-self axis is used
17686|       |    * for validation, plus we need to use the base type of those
17687|       |    * enumerations for whitespace.
17688|       |    *
17689|       |    * *Patterns*: won't be add here, since they are ORed at
17690|       |    * type level and ANDed at ancestor level. This will
17691|       |    * happen during validation by walking the base axis
17692|       |    * of the type.
17693|       |    */
17694|    126|    for (cur = base->facetSet; cur != NULL; cur = cur->next) {
  ------------------
  |  Branch (17694:32): [True: 5, False: 121]
  ------------------
17695|      5|	bfacet = cur->facet;
17696|       |	/*
17697|       |	* Special handling of enumerations and patterns.
17698|       |	* TODO: hmm, they should not appear in the set, so remove this.
17699|       |	*/
17700|      5|	if ((bfacet->type == XML_SCHEMA_FACET_PATTERN) ||
  ------------------
  |  Branch (17700:6): [True: 0, False: 5]
  ------------------
17701|      5|	    (bfacet->type == XML_SCHEMA_FACET_ENUMERATION))
  ------------------
  |  Branch (17701:6): [True: 4, False: 1]
  ------------------
17702|      4|	    continue;
17703|       |	/*
17704|       |	* Search for a duplicate facet in the current type.
17705|       |	*/
17706|      1|	link = type->facetSet;
17707|       |	/* err = 0; */
17708|       |	/* fixedErr = 0; */
17709|      1|	while (link != NULL) {
  ------------------
  |  Branch (17709:9): [True: 0, False: 1]
  ------------------
17710|      0|	    facet = link->facet;
17711|      0|	    if (facet->type == bfacet->type) {
  ------------------
  |  Branch (17711:10): [True: 0, False: 0]
  ------------------
17712|      0|		switch (facet->type) {
17713|      0|		    case XML_SCHEMA_FACET_WHITESPACE:
  ------------------
  |  Branch (17713:7): [True: 0, False: 0]
  ------------------
17714|       |			/*
17715|       |			* The whitespace must be stronger.
17716|       |			*/
17717|      0|			if (facet->whitespace < bfacet->whitespace) {
  ------------------
  |  Branch (17717:8): [True: 0, False: 0]
  ------------------
17718|      0|			    FACET_RESTR_ERR(facet,
  ------------------
  |  |17171|      0|    xmlSchemaPCustomErr(pctxt,      \
  |  |17172|      0|	XML_SCHEMAP_INVALID_FACET_VALUE, \
  |  |17173|      0|	WXS_BASIC_CAST fac1, fac1->node, \
  |  |  ------------------
  |  |  |  |  124|      0|#define WXS_BASIC_CAST (xmlSchemaBasicItemPtr)
  |  |  ------------------
  |  |17174|      0|	msg, NULL);
  ------------------
17719|      0|				"The 'whitespace' value has to be equal to "
17720|      0|				"or stronger than the 'whitespace' value of "
17721|      0|				"the base type")
17722|      0|			}
17723|      0|			if ((bfacet->fixed) &&
  ------------------
  |  Branch (17723:8): [True: 0, False: 0]
  ------------------
17724|      0|			    (facet->whitespace != bfacet->whitespace)) {
  ------------------
  |  Branch (17724:8): [True: 0, False: 0]
  ------------------
17725|      0|			    FACET_RESTR_FIXED_ERR(facet)
  ------------------
  |  |17177|      0|    xmlSchemaPCustomErr(pctxt, \
  |  |17178|      0|	XML_SCHEMAP_INVALID_FACET_VALUE, \
  |  |17179|      0|	WXS_BASIC_CAST fac, fac->node, \
  |  |  ------------------
  |  |  |  |  124|      0|#define WXS_BASIC_CAST (xmlSchemaBasicItemPtr)
  |  |  ------------------
  |  |17180|      0|	"The base type's facet is 'fixed', thus the value must not " \
  |  |17181|      0|	"differ", NULL);
  ------------------
17726|      0|			}
17727|      0|			break;
17728|      0|		    default:
  ------------------
  |  Branch (17728:7): [True: 0, False: 0]
  ------------------
17729|      0|			break;
17730|      0|		}
17731|       |		/* Duplicate found. */
17732|      0|		break;
17733|      0|	    }
17734|      0|	    link = link->next;
17735|      0|	}
17736|       |	/*
17737|       |	* If no duplicate was found: add the base types's facet
17738|       |	* to the set.
17739|       |	*/
17740|      1|	if (link == NULL) {
  ------------------
  |  Branch (17740:6): [True: 1, False: 0]
  ------------------
17741|      1|	    link = (xmlSchemaFacetLinkPtr)
17742|      1|		xmlMalloc(sizeof(xmlSchemaFacetLink));
17743|      1|	    if (link == NULL) {
  ------------------
  |  Branch (17743:10): [True: 0, False: 1]
  ------------------
17744|      0|		xmlSchemaPErrMemory(pctxt,
17745|      0|		    "deriving facets, creating a facet link", NULL);
17746|      0|		return (-1);
17747|      0|	    }
17748|      1|	    link->facet = cur->facet;
17749|      1|	    link->next = NULL;
17750|      1|	    if (last == NULL)
  ------------------
  |  Branch (17750:10): [True: 1, False: 0]
  ------------------
17751|      1|		type->facetSet = link;
17752|      0|	    else
17753|      0|		last->next = link;
17754|      1|	    last = link;
17755|      1|	}
17756|       |
17757|      1|    }
17758|       |
17759|    121|    return (0);
17760|      0|internal_error:
17761|      0|    PERROR_INT("xmlSchemaDeriveAndValidateFacets",
  ------------------
  |  | 2824|      0|#define PERROR_INT(func, msg) xmlSchemaInternalErr(ACTXT_CAST pctxt, func, msg);
  |  |  ------------------
  |  |  |  |  121|      0|#define ACTXT_CAST (xmlSchemaAbstractCtxtPtr)
  |  |  ------------------
  ------------------
17762|      0|	"an error occurred");
17763|      0|    return (-1);
17764|    121|}
xmlschemas.c:xmlSchemaTypeFixupWhitespace:
17872|    162|{
17873|       |
17874|       |
17875|       |    /*
17876|       |    * Evaluate the whitespace-facet value.
17877|       |    */
17878|    162|    if (WXS_IS_LIST(type)) {
  ------------------
  |  |  272|    162|#define WXS_IS_LIST(t) (t->flags & XML_SCHEMAS_TYPE_VARIETY_LIST)
  |  |  ------------------
  |  |  |  |  448|    162|#define XML_SCHEMAS_TYPE_VARIETY_LIST    1 << 6
  |  |  ------------------
  |  |  |  Branch (272:24): [True: 21, False: 141]
  |  |  ------------------
  ------------------
17879|     21|	type->flags |= XML_SCHEMAS_TYPE_WHITESPACE_COLLAPSE;
  ------------------
  |  |  563|     21|#define XML_SCHEMAS_TYPE_WHITESPACE_COLLAPSE    1 << 26
  ------------------
17880|     21|	return (0);
17881|    141|    } else if (WXS_IS_UNION(type))
  ------------------
  |  |  274|    141|#define WXS_IS_UNION(t) (t->flags & XML_SCHEMAS_TYPE_VARIETY_UNION)
  |  |  ------------------
  |  |  |  |  454|    141|#define XML_SCHEMAS_TYPE_VARIETY_UNION    1 << 7
  |  |  ------------------
  |  |  |  Branch (274:25): [True: 27, False: 114]
  |  |  ------------------
  ------------------
17882|     27|	return (0);
17883|       |
17884|    114|    if (type->facetSet != NULL) {
  ------------------
  |  Branch (17884:9): [True: 110, False: 4]
  ------------------
17885|    110|	xmlSchemaFacetLinkPtr lin;
17886|       |
17887|    321|	for (lin = type->facetSet; lin != NULL; lin = lin->next) {
  ------------------
  |  Branch (17887:29): [True: 213, False: 108]
  ------------------
17888|    213|	    if (lin->facet->type == XML_SCHEMA_FACET_WHITESPACE) {
  ------------------
  |  Branch (17888:10): [True: 2, False: 211]
  ------------------
17889|      2|		switch (lin->facet->whitespace) {
17890|      0|		case XML_SCHEMAS_FACET_PRESERVE:
  ------------------
  |  |  807|      0|#define XML_SCHEMAS_FACET_PRESERVE        1
  ------------------
  |  Branch (17890:3): [True: 0, False: 2]
  ------------------
17891|      0|		    type->flags |= XML_SCHEMAS_TYPE_WHITESPACE_PRESERVE;
  ------------------
  |  |  551|      0|#define XML_SCHEMAS_TYPE_WHITESPACE_PRESERVE    1 << 24
  ------------------
17892|      0|		    break;
17893|      1|		case XML_SCHEMAS_FACET_REPLACE:
  ------------------
  |  |  813|      1|#define XML_SCHEMAS_FACET_REPLACE        2
  ------------------
  |  Branch (17893:3): [True: 1, False: 1]
  ------------------
17894|      1|		    type->flags |= XML_SCHEMAS_TYPE_WHITESPACE_REPLACE;
  ------------------
  |  |  557|      1|#define XML_SCHEMAS_TYPE_WHITESPACE_REPLACE    1 << 25
  ------------------
17895|      1|		    break;
17896|      1|		case XML_SCHEMAS_FACET_COLLAPSE:
  ------------------
  |  |  819|      1|#define XML_SCHEMAS_FACET_COLLAPSE        3
  ------------------
  |  Branch (17896:3): [True: 1, False: 1]
  ------------------
17897|      1|		    type->flags |= XML_SCHEMAS_TYPE_WHITESPACE_COLLAPSE;
  ------------------
  |  |  563|      1|#define XML_SCHEMAS_TYPE_WHITESPACE_COLLAPSE    1 << 26
  ------------------
17898|      1|		    break;
17899|      0|		default:
  ------------------
  |  Branch (17899:3): [True: 0, False: 2]
  ------------------
17900|      0|		    return (-1);
17901|      2|		}
17902|      2|		return (0);
17903|      2|	    }
17904|    213|	}
17905|    110|    }
17906|       |    /*
17907|       |    * For all `atomic` datatypes other than string (and types `derived`
17908|       |    * by `restriction` from it) the value of whiteSpace is fixed to
17909|       |    * collapse
17910|       |    */
17911|    112|    {
17912|    112|	xmlSchemaTypePtr anc;
17913|       |
17914|    115|	for (anc = type->baseType; anc != NULL &&
  ------------------
  |  Branch (17914:29): [True: 115, False: 0]
  ------------------
17915|    115|		anc->builtInType != XML_SCHEMAS_ANYTYPE;
  ------------------
  |  Branch (17915:3): [True: 115, False: 0]
  ------------------
17916|    115|		anc = anc->baseType) {
17917|       |
17918|    115|	    if (anc->type == XML_SCHEMA_TYPE_BASIC) {
  ------------------
  |  Branch (17918:10): [True: 112, False: 3]
  ------------------
17919|    112|		if (anc->builtInType == XML_SCHEMAS_NORMSTRING) {
  ------------------
  |  Branch (17919:7): [True: 0, False: 112]
  ------------------
17920|      0|		    type->flags |= XML_SCHEMAS_TYPE_WHITESPACE_REPLACE;
  ------------------
  |  |  557|      0|#define XML_SCHEMAS_TYPE_WHITESPACE_REPLACE    1 << 25
  ------------------
17921|       |
17922|    112|		} else if ((anc->builtInType == XML_SCHEMAS_STRING) ||
  ------------------
  |  Branch (17922:14): [True: 30, False: 82]
  ------------------
17923|    112|		    (anc->builtInType == XML_SCHEMAS_ANYSIMPLETYPE)) {
  ------------------
  |  Branch (17923:7): [True: 0, False: 82]
  ------------------
17924|     30|		    type->flags |= XML_SCHEMAS_TYPE_WHITESPACE_PRESERVE;
  ------------------
  |  |  551|     30|#define XML_SCHEMAS_TYPE_WHITESPACE_PRESERVE    1 << 24
  ------------------
17925|       |
17926|     30|		} else
17927|     82|		    type->flags |= XML_SCHEMAS_TYPE_WHITESPACE_COLLAPSE;
  ------------------
  |  |  563|     82|#define XML_SCHEMAS_TYPE_WHITESPACE_COLLAPSE    1 << 26
  ------------------
17928|    112|		break;
17929|    112|	    }
17930|    115|	}
17931|    112|    }
17932|    112|    return (0);
17933|    114|}
xmlschemas.c:xmlSchemaTypeFixupOptimFacets:
17819|    162|{
17820|    162|    int has = 0, needVal = 0, normVal = 0;
17821|       |
17822|    162|    has	= (type->baseType->flags & XML_SCHEMAS_TYPE_HAS_FACETS) ? 1 : 0;
  ------------------
  |  |  569|    162|#define XML_SCHEMAS_TYPE_HAS_FACETS    1 << 27
  ------------------
  |  Branch (17822:11): [True: 2, False: 160]
  ------------------
17823|    162|    if (has) {
  ------------------
  |  Branch (17823:9): [True: 2, False: 160]
  ------------------
17824|      2|	needVal = (type->baseType->flags &
  ------------------
  |  Branch (17824:12): [True: 1, False: 1]
  ------------------
17825|      2|	    XML_SCHEMAS_TYPE_FACETSNEEDVALUE) ? 1 : 0;
  ------------------
  |  |  533|      2|#define XML_SCHEMAS_TYPE_FACETSNEEDVALUE    1 << 21
  ------------------
17826|      2|	normVal = (type->baseType->flags &
  ------------------
  |  Branch (17826:12): [True: 1, False: 1]
  ------------------
17827|      2|	    XML_SCHEMAS_TYPE_NORMVALUENEEDED) ? 1 : 0;
  ------------------
  |  |  575|      2|#define XML_SCHEMAS_TYPE_NORMVALUENEEDED    1 << 28
  ------------------
17828|      2|    }
17829|    162|    if (type->facets != NULL) {
  ------------------
  |  Branch (17829:9): [True: 120, False: 42]
  ------------------
17830|    120|	xmlSchemaFacetPtr fac;
17831|       |
17832|    344|	for (fac = type->facets; fac != NULL; fac = fac->next) {
  ------------------
  |  Branch (17832:27): [True: 224, False: 120]
  ------------------
17833|    224|	    switch (fac->type) {
17834|      2|		case XML_SCHEMA_FACET_WHITESPACE:
  ------------------
  |  Branch (17834:3): [True: 2, False: 222]
  ------------------
17835|      2|		    break;
17836|     26|		case XML_SCHEMA_FACET_PATTERN:
  ------------------
  |  Branch (17836:3): [True: 26, False: 198]
  ------------------
17837|     26|		    normVal = 1;
17838|     26|		    has = 1;
17839|     26|		    break;
17840|    115|		case XML_SCHEMA_FACET_ENUMERATION:
  ------------------
  |  Branch (17840:3): [True: 115, False: 109]
  ------------------
17841|    115|		    needVal = 1;
17842|    115|		    normVal = 1;
17843|    115|		    has = 1;
17844|    115|		    break;
17845|     81|		default:
  ------------------
  |  Branch (17845:3): [True: 81, False: 143]
  ------------------
17846|     81|		    has = 1;
17847|     81|		    break;
17848|    224|	    }
17849|    224|	}
17850|    120|    }
17851|    162|    if (normVal)
  ------------------
  |  Branch (17851:9): [True: 63, False: 99]
  ------------------
17852|     63|	type->flags |= XML_SCHEMAS_TYPE_NORMVALUENEEDED;
  ------------------
  |  |  575|     63|#define XML_SCHEMAS_TYPE_NORMVALUENEEDED    1 << 28
  ------------------
17853|    162|    if (needVal)
  ------------------
  |  Branch (17853:9): [True: 37, False: 125]
  ------------------
17854|     37|	type->flags |= XML_SCHEMAS_TYPE_FACETSNEEDVALUE;
  ------------------
  |  |  533|     37|#define XML_SCHEMAS_TYPE_FACETSNEEDVALUE    1 << 21
  ------------------
17855|    162|    if (has)
  ------------------
  |  Branch (17855:9): [True: 120, False: 42]
  ------------------
17856|    120|	type->flags |= XML_SCHEMAS_TYPE_HAS_FACETS;
  ------------------
  |  |  569|    120|#define XML_SCHEMAS_TYPE_HAS_FACETS    1 << 27
  ------------------
17857|       |
17858|    162|    if (has && (! needVal) && WXS_IS_ATOMIC(type)) {
  ------------------
  |  |  270|     83|#define WXS_IS_ATOMIC(t) (t->flags & XML_SCHEMAS_TYPE_VARIETY_ATOMIC)
  |  |  ------------------
  |  |  |  |  460|     83|#define XML_SCHEMAS_TYPE_VARIETY_ATOMIC    1 << 8
  |  |  ------------------
  |  |  |  Branch (270:26): [True: 73, False: 10]
  |  |  ------------------
  ------------------
  |  Branch (17858:9): [True: 120, False: 42]
  |  Branch (17858:16): [True: 83, False: 37]
  ------------------
17859|     73|	xmlSchemaTypePtr prim = xmlSchemaGetPrimitiveType(type);
17860|       |	/*
17861|       |	* OPTIMIZE VAL TODO: Some facets need a computed value.
17862|       |	*/
17863|     73|	if ((prim->builtInType != XML_SCHEMAS_ANYSIMPLETYPE) &&
  ------------------
  |  Branch (17863:6): [True: 73, False: 0]
  ------------------
17864|     73|	    (prim->builtInType != XML_SCHEMAS_STRING)) {
  ------------------
  |  Branch (17864:6): [True: 43, False: 30]
  ------------------
17865|     43|	    type->flags |= XML_SCHEMAS_TYPE_FACETSNEEDVALUE;
  ------------------
  |  |  533|     43|#define XML_SCHEMAS_TYPE_FACETSNEEDVALUE    1 << 21
  ------------------
17866|     43|	}
17867|     73|    }
17868|    162|}
xmlschemas.c:xmlSchemaCheckAttrPropsCorrect:
19430|    189|{
19431|       |
19432|       |    /*
19433|       |    * SPEC a-props-correct (1)
19434|       |    * "The values of the properties of an attribute declaration must
19435|       |    * be as described in the property tableau in The Attribute
19436|       |    * Declaration Schema Component ($3.2.1), modulo the impact of
19437|       |    * Missing Sub-components ($5.3)."
19438|       |    */
19439|       |
19440|    189|    if (WXS_ATTR_TYPEDEF(attr) == NULL)
  ------------------
  |  |  154|    189|#define WXS_ATTR_TYPEDEF(a) (a)->subtypes
  ------------------
  |  Branch (19440:9): [True: 0, False: 189]
  ------------------
19441|      0|	return(0);
19442|       |
19443|    189|    if (attr->defValue != NULL) {
  ------------------
  |  Branch (19443:9): [True: 10, False: 179]
  ------------------
19444|     10|	int ret;
19445|       |
19446|       |	/*
19447|       |	* SPEC a-props-correct (3)
19448|       |	* "If the {type definition} is or is derived from ID then there
19449|       |	* must not be a {value constraint}."
19450|       |	*/
19451|     10|	if (xmlSchemaIsDerivedFromBuiltInType(
  ------------------
  |  Branch (19451:6): [True: 0, False: 10]
  ------------------
19452|     10|	    WXS_ATTR_TYPEDEF(attr), XML_SCHEMAS_ID))
  ------------------
  |  |  154|     10|#define WXS_ATTR_TYPEDEF(a) (a)->subtypes
  ------------------
19453|      0|	{
19454|      0|	    xmlSchemaCustomErr(ACTXT_CAST pctxt,
  ------------------
  |  |  121|      0|#define ACTXT_CAST (xmlSchemaAbstractCtxtPtr)
  ------------------
19455|      0|		XML_SCHEMAP_A_PROPS_CORRECT_3,
19456|      0|		NULL, WXS_BASIC_CAST attr,
  ------------------
  |  |  124|      0|#define WXS_BASIC_CAST (xmlSchemaBasicItemPtr)
  ------------------
19457|      0|		"Value constraints are not allowed if the type definition "
19458|      0|		"is or is derived from xs:ID",
19459|      0|		NULL, NULL);
19460|      0|	    return(pctxt->err);
19461|      0|	}
19462|       |	/*
19463|       |	* SPEC a-props-correct (2)
19464|       |	* "if there is a {value constraint}, the canonical lexical
19465|       |	* representation of its value must be `valid` with respect
19466|       |	* to the {type definition} as defined in String Valid ($3.14.4)."
19467|       |	* TODO: Don't care about the *canonical* stuff here, this requirement
19468|       |	* will be removed in WXS 1.1 anyway.
19469|       |	*/
19470|     10|	ret = xmlSchemaVCheckCVCSimpleType(ACTXT_CAST pctxt,
  ------------------
  |  |  121|     10|#define ACTXT_CAST (xmlSchemaAbstractCtxtPtr)
  ------------------
19471|     10|	    attr->node, WXS_ATTR_TYPEDEF(attr),
  ------------------
  |  |  154|     10|#define WXS_ATTR_TYPEDEF(a) (a)->subtypes
  ------------------
19472|     10|	    attr->defValue, &(attr->defVal),
19473|     10|	    1, 1, 0);
19474|     10|	if (ret != 0) {
  ------------------
  |  Branch (19474:6): [True: 0, False: 10]
  ------------------
19475|      0|	    if (ret < 0) {
  ------------------
  |  Branch (19475:10): [True: 0, False: 0]
  ------------------
19476|      0|		PERROR_INT("xmlSchemaCheckAttrPropsCorrect",
  ------------------
  |  | 2824|      0|#define PERROR_INT(func, msg) xmlSchemaInternalErr(ACTXT_CAST pctxt, func, msg);
  |  |  ------------------
  |  |  |  |  121|      0|#define ACTXT_CAST (xmlSchemaAbstractCtxtPtr)
  |  |  ------------------
  ------------------
19477|      0|		    "calling xmlSchemaVCheckCVCSimpleType()");
19478|      0|		return(-1);
19479|      0|	    }
19480|      0|	    xmlSchemaCustomErr(ACTXT_CAST pctxt,
  ------------------
  |  |  121|      0|#define ACTXT_CAST (xmlSchemaAbstractCtxtPtr)
  ------------------
19481|      0|		XML_SCHEMAP_A_PROPS_CORRECT_2,
19482|      0|		NULL, WXS_BASIC_CAST attr,
  ------------------
  |  |  124|      0|#define WXS_BASIC_CAST (xmlSchemaBasicItemPtr)
  ------------------
19483|      0|		"The value of the value constraint is not valid",
19484|      0|		NULL, NULL);
19485|      0|	    return(pctxt->err);
19486|      0|	}
19487|     10|    }
19488|       |
19489|    189|    return(0);
19490|    189|}
xmlschemas.c:xmlSchemaIsDerivedFromBuiltInType:
13330|    315|{
13331|    315|    if (type == NULL)
  ------------------
  |  Branch (13331:9): [True: 153, False: 162]
  ------------------
13332|    153|	return (0);
13333|    162|    if (WXS_IS_COMPLEX(type))
  ------------------
  |  |  213|    162|    (((i)->type == XML_SCHEMA_TYPE_COMPLEX) || \
  |  |  ------------------
  |  |  |  Branch (213:6): [True: 0, False: 162]
  |  |  ------------------
  |  |  214|    162|     ((i)->builtInType == XML_SCHEMAS_ANYTYPE))
  |  |  ------------------
  |  |  |  Branch (214:6): [True: 0, False: 162]
  |  |  ------------------
  ------------------
13334|      0|	return (0);
13335|    162|    if (type->type == XML_SCHEMA_TYPE_BASIC) {
  ------------------
  |  Branch (13335:9): [True: 76, False: 86]
  ------------------
13336|     76|	if (type->builtInType == valType)
  ------------------
  |  Branch (13336:6): [True: 9, False: 67]
  ------------------
13337|      9|	    return(1);
13338|     67|	if ((type->builtInType == XML_SCHEMAS_ANYSIMPLETYPE) ||
  ------------------
  |  Branch (13338:6): [True: 0, False: 67]
  ------------------
13339|     67|	    (type->builtInType == XML_SCHEMAS_ANYTYPE))
  ------------------
  |  Branch (13339:6): [True: 0, False: 67]
  ------------------
13340|      0|	    return (0);
13341|     67|	return(xmlSchemaIsDerivedFromBuiltInType(type->subtypes, valType));
13342|     67|    }
13343|     86|    return(xmlSchemaIsDerivedFromBuiltInType(type->subtypes, valType));
13344|    162|}
xmlschemas.c:xmlSchemaAreValuesEqual:
20043|     17|{
20044|     17|    xmlSchemaTypePtr tx, ty, ptx, pty;
20045|     17|    int ret;
20046|       |
20047|     17|    while (x != NULL) {
  ------------------
  |  Branch (20047:12): [True: 17, False: 0]
  ------------------
20048|       |	/* Same types. */
20049|     17|	tx = xmlSchemaGetBuiltInType(xmlSchemaGetValType(x));
20050|     17|	ty = xmlSchemaGetBuiltInType(xmlSchemaGetValType(y));
20051|     17|	ptx = xmlSchemaGetPrimitiveType(tx);
20052|     17|	pty = xmlSchemaGetPrimitiveType(ty);
20053|       |	/*
20054|       |	* (1) if a datatype T' is `derived` by `restriction` from an
20055|       |	* atomic datatype T then the `value space` of T' is a subset of
20056|       |	* the `value space` of T. */
20057|       |	/*
20058|       |	* (2) if datatypes T' and T'' are `derived` by `restriction`
20059|       |	* from a common atomic ancestor T then the `value space`s of T'
20060|       |	* and T'' may overlap.
20061|       |	*/
20062|     17|	if (ptx != pty)
  ------------------
  |  Branch (20062:6): [True: 0, False: 17]
  ------------------
20063|      0|	    return(0);
20064|       |	/*
20065|       |	* We assume computed values to be normalized, so do a fast
20066|       |	* string comparison for string based types.
20067|       |	*/
20068|     17|	if ((ptx->builtInType == XML_SCHEMAS_STRING) ||
  ------------------
  |  Branch (20068:6): [True: 17, False: 0]
  ------------------
20069|     17|	    WXS_IS_ANY_SIMPLE_TYPE(ptx)) {
  ------------------
  |  |  222|      0|    (((i)->type == XML_SCHEMA_TYPE_BASIC) && \
  |  |  ------------------
  |  |  |  Branch (222:6): [True: 0, False: 0]
  |  |  ------------------
  |  |  223|      0|      ((i)->builtInType == XML_SCHEMAS_ANYSIMPLETYPE))
  |  |  ------------------
  |  |  |  Branch (223:7): [True: 0, False: 0]
  |  |  ------------------
  ------------------
20070|     17|	    if (! xmlStrEqual(
  ------------------
  |  Branch (20070:10): [True: 8, False: 9]
  ------------------
20071|     17|		xmlSchemaValueGetAsString(x),
20072|     17|		xmlSchemaValueGetAsString(y)))
20073|      8|		return (0);
20074|     17|	} else {
20075|      0|	    ret = xmlSchemaCompareValuesWhtsp(
20076|      0|		x, XML_SCHEMA_WHITESPACE_PRESERVE,
20077|      0|		y, XML_SCHEMA_WHITESPACE_PRESERVE);
20078|      0|	    if (ret == -2)
  ------------------
  |  Branch (20078:10): [True: 0, False: 0]
  ------------------
20079|      0|		return(-1);
20080|      0|	    if (ret != 0)
  ------------------
  |  Branch (20080:10): [True: 0, False: 0]
  ------------------
20081|      0|		return(0);
20082|      0|	}
20083|       |	/*
20084|       |	* Lists.
20085|       |	*/
20086|      9|	x = xmlSchemaValueGetNext(x);
20087|      9|	if (x != NULL) {
  ------------------
  |  Branch (20087:6): [True: 0, False: 9]
  ------------------
20088|      0|	    y = xmlSchemaValueGetNext(y);
20089|      0|	    if (y == NULL)
  ------------------
  |  Branch (20089:10): [True: 0, False: 0]
  ------------------
20090|      0|		return (0);
20091|      9|	} else if (xmlSchemaValueGetNext(y) != NULL)
  ------------------
  |  Branch (20091:13): [True: 0, False: 9]
  ------------------
20092|      0|	    return (0);
20093|      9|	else
20094|      9|	    return (1);
20095|      9|    }
20096|      0|    return (0);
20097|     17|}
xmlschemas.c:xmlSchemaCheckAGPropsCorrect:
19296|      4|{
19297|       |    /*
19298|       |    * SPEC ag-props-correct
19299|       |    * (1) "The values of the properties of an attribute group definition
19300|       |    * must be as described in the property tableau in The Attribute
19301|       |    * Group Definition Schema Component ($3.6.1), modulo the impact of
19302|       |    * Missing Sub-components ($5.3);"
19303|       |    */
19304|       |
19305|      4|    if ((attrGr->attrUses != NULL) &&
  ------------------
  |  Branch (19305:9): [True: 4, False: 0]
  ------------------
19306|      4|	(WXS_LIST_CAST attrGr->attrUses)->nbItems > 1)
  ------------------
  |  |  137|      4|#define WXS_LIST_CAST (xmlSchemaItemListPtr)
  ------------------
  |  Branch (19306:2): [True: 4, False: 0]
  ------------------
19307|      4|    {
19308|      4|	xmlSchemaItemListPtr uses = WXS_LIST_CAST attrGr->attrUses;
  ------------------
  |  |  137|      4|#define WXS_LIST_CAST (xmlSchemaItemListPtr)
  ------------------
19309|      4|	xmlSchemaAttributeUsePtr use, tmp;
19310|      4|	int i, j, hasId = 0;
19311|       |
19312|     15|	for (i = uses->nbItems -1; i >= 0; i--) {
  ------------------
  |  Branch (19312:29): [True: 11, False: 4]
  ------------------
19313|     11|	    use = uses->items[i];
19314|       |	    /*
19315|       |	    * SPEC ag-props-correct
19316|       |	    * (2) "Two distinct members of the {attribute uses} must not have
19317|       |	    * {attribute declaration}s both of whose {name}s match and whose
19318|       |	    * {target namespace}s are identical."
19319|       |	    */
19320|     11|	    if (i > 0) {
  ------------------
  |  Branch (19320:10): [True: 7, False: 4]
  ------------------
19321|     17|		for (j = i -1; j >= 0; j--) {
  ------------------
  |  Branch (19321:18): [True: 10, False: 7]
  ------------------
19322|     10|		    tmp = uses->items[j];
19323|     10|		    if ((WXS_ATTRUSE_DECL_NAME(use) ==
  ------------------
  |  |  162|     10|#define WXS_ATTRUSE_DECL_NAME(au) (WXS_ATTRUSE_DECL(au))->name
  |  |  ------------------
  |  |  |  |  158|     10|#define WXS_ATTRUSE_DECL(au) (WXS_ATTR_USE_CAST (au))->attrDecl
  |  |  |  |  ------------------
  |  |  |  |  |  |  131|     10|#define WXS_ATTR_USE_CAST (xmlSchemaAttributeUsePtr)
  |  |  |  |  ------------------
  |  |  ------------------
  ------------------
  |  Branch (19323:11): [True: 0, False: 10]
  ------------------
19324|     10|			WXS_ATTRUSE_DECL_NAME(tmp)) &&
  ------------------
  |  |  162|     10|#define WXS_ATTRUSE_DECL_NAME(au) (WXS_ATTRUSE_DECL(au))->name
  |  |  ------------------
  |  |  |  |  158|     10|#define WXS_ATTRUSE_DECL(au) (WXS_ATTR_USE_CAST (au))->attrDecl
  |  |  |  |  ------------------
  |  |  |  |  |  |  131|     10|#define WXS_ATTR_USE_CAST (xmlSchemaAttributeUsePtr)
  |  |  |  |  ------------------
  |  |  ------------------
  ------------------
19325|     10|			(WXS_ATTRUSE_DECL_TNS(use) ==
  ------------------
  |  |  164|      0|#define WXS_ATTRUSE_DECL_TNS(au) (WXS_ATTRUSE_DECL(au))->targetNamespace
  |  |  ------------------
  |  |  |  |  158|      0|#define WXS_ATTRUSE_DECL(au) (WXS_ATTR_USE_CAST (au))->attrDecl
  |  |  |  |  ------------------
  |  |  |  |  |  |  131|      0|#define WXS_ATTR_USE_CAST (xmlSchemaAttributeUsePtr)
  |  |  |  |  ------------------
  |  |  ------------------
  ------------------
  |  Branch (19325:4): [True: 0, False: 0]
  ------------------
19326|      0|			WXS_ATTRUSE_DECL_TNS(tmp)))
  ------------------
  |  |  164|      0|#define WXS_ATTRUSE_DECL_TNS(au) (WXS_ATTRUSE_DECL(au))->targetNamespace
  |  |  ------------------
  |  |  |  |  158|      0|#define WXS_ATTRUSE_DECL(au) (WXS_ATTR_USE_CAST (au))->attrDecl
  |  |  |  |  ------------------
  |  |  |  |  |  |  131|      0|#define WXS_ATTR_USE_CAST (xmlSchemaAttributeUsePtr)
  |  |  |  |  ------------------
  |  |  ------------------
  ------------------
19327|      0|		    {
19328|      0|			xmlChar *str = NULL;
19329|       |
19330|      0|			xmlSchemaCustomErr(ACTXT_CAST pctxt,
  ------------------
  |  |  121|      0|#define ACTXT_CAST (xmlSchemaAbstractCtxtPtr)
  ------------------
19331|      0|			    XML_SCHEMAP_AG_PROPS_CORRECT,
19332|      0|			    attrGr->node, WXS_BASIC_CAST attrGr,
  ------------------
  |  |  124|      0|#define WXS_BASIC_CAST (xmlSchemaBasicItemPtr)
  ------------------
19333|      0|			    "Duplicate %s",
19334|      0|			    xmlSchemaGetComponentDesignation(&str, use),
19335|      0|			    NULL);
19336|      0|			FREE_AND_NULL(str);
  ------------------
  |  |  320|      0|#define FREE_AND_NULL(str) if ((str) != NULL) { xmlFree((xmlChar *) (str)); str = NULL; }
  |  |  ------------------
  |  |  |  Branch (320:32): [True: 0, False: 0]
  |  |  ------------------
  ------------------
19337|       |			/*
19338|       |			* Remove the duplicate.
19339|       |			*/
19340|      0|			if (xmlSchemaItemListRemove(uses, i) == -1)
  ------------------
  |  Branch (19340:8): [True: 0, False: 0]
  ------------------
19341|      0|			    return(-1);
19342|      0|			goto next_use;
19343|      0|		    }
19344|     10|		}
19345|      7|	    }
19346|       |	    /*
19347|       |	    * SPEC ag-props-correct
19348|       |	    * (3) "Two distinct members of the {attribute uses} must not have
19349|       |	    * {attribute declaration}s both of whose {type definition}s are or
19350|       |	    * are derived from ID."
19351|       |	    * TODO: Does 'derived' include member-types of unions?
19352|       |	    */
19353|     11|	    if (WXS_ATTRUSE_TYPEDEF(use) != NULL) {
  ------------------
  |  |  160|     11|#define WXS_ATTRUSE_TYPEDEF(au) WXS_ATTR_TYPEDEF(WXS_ATTRUSE_DECL( WXS_ATTR_USE_CAST au))
  |  |  ------------------
  |  |  |  |  154|     11|#define WXS_ATTR_TYPEDEF(a) (a)->subtypes
  |  |  ------------------
  ------------------
  |  Branch (19353:10): [True: 11, False: 0]
  ------------------
19354|     11|		if (xmlSchemaIsDerivedFromBuiltInType(
  ------------------
  |  Branch (19354:7): [True: 0, False: 11]
  ------------------
19355|     11|		    WXS_ATTRUSE_TYPEDEF(use), XML_SCHEMAS_ID))
  ------------------
  |  |  160|     11|#define WXS_ATTRUSE_TYPEDEF(au) WXS_ATTR_TYPEDEF(WXS_ATTRUSE_DECL( WXS_ATTR_USE_CAST au))
  |  |  ------------------
  |  |  |  |  154|     11|#define WXS_ATTR_TYPEDEF(a) (a)->subtypes
  |  |  ------------------
  ------------------
19356|      0|		{
19357|      0|		    if (hasId) {
  ------------------
  |  Branch (19357:11): [True: 0, False: 0]
  ------------------
19358|      0|			xmlChar *str = NULL;
19359|       |
19360|      0|			xmlSchemaCustomErr(ACTXT_CAST pctxt,
  ------------------
  |  |  121|      0|#define ACTXT_CAST (xmlSchemaAbstractCtxtPtr)
  ------------------
19361|      0|			    XML_SCHEMAP_AG_PROPS_CORRECT,
19362|      0|			    attrGr->node, WXS_BASIC_CAST attrGr,
  ------------------
  |  |  124|      0|#define WXS_BASIC_CAST (xmlSchemaBasicItemPtr)
  ------------------
19363|      0|			    "There must not exist more than one attribute "
19364|      0|			    "declaration of type 'xs:ID' "
19365|      0|			    "(or derived from 'xs:ID'). The %s violates this "
19366|      0|			    "constraint",
19367|      0|			    xmlSchemaGetComponentDesignation(&str, use),
19368|      0|			    NULL);
19369|      0|			FREE_AND_NULL(str);
  ------------------
  |  |  320|      0|#define FREE_AND_NULL(str) if ((str) != NULL) { xmlFree((xmlChar *) (str)); str = NULL; }
  |  |  ------------------
  |  |  |  Branch (320:32): [True: 0, False: 0]
  |  |  ------------------
  ------------------
19370|      0|			if (xmlSchemaItemListRemove(uses, i) == -1)
  ------------------
  |  Branch (19370:8): [True: 0, False: 0]
  ------------------
19371|      0|			    return(-1);
19372|      0|		    }
19373|      0|		    hasId = 1;
19374|      0|		}
19375|     11|	    }
19376|     11|next_use: {}
19377|     11|	}
19378|      4|    }
19379|      4|    return(0);
19380|      4|}
xmlschemas.c:xmlSchemaCheckDerivationOKRestriction2to4:
14084|    285|{
14085|    285|    xmlSchemaAttributeUsePtr cur = NULL, bcur;
14086|    285|    int i, j, found; /* err = 0; */
14087|    285|    const xmlChar *bEffValue;
14088|    285|    int effFixed;
14089|       |
14090|    285|    if (uses != NULL) {
  ------------------
  |  Branch (14090:9): [True: 100, False: 185]
  ------------------
14091|    272|	for (i = 0; i < uses->nbItems; i++) {
  ------------------
  |  Branch (14091:14): [True: 172, False: 100]
  ------------------
14092|    172|	    cur = uses->items[i];
14093|    172|	    found = 0;
14094|    172|	    if (baseUses == NULL)
  ------------------
  |  Branch (14094:10): [True: 153, False: 19]
  ------------------
14095|    153|		goto not_found;
14096|     53|	    for (j = 0; j < baseUses->nbItems; j++) {
  ------------------
  |  Branch (14096:18): [True: 49, False: 4]
  ------------------
14097|     49|		bcur = baseUses->items[j];
14098|     49|		if ((WXS_ATTRUSE_DECL_NAME(cur) ==
  ------------------
  |  |  162|     49|#define WXS_ATTRUSE_DECL_NAME(au) (WXS_ATTRUSE_DECL(au))->name
  |  |  ------------------
  |  |  |  |  158|     49|#define WXS_ATTRUSE_DECL(au) (WXS_ATTR_USE_CAST (au))->attrDecl
  |  |  |  |  ------------------
  |  |  |  |  |  |  131|     49|#define WXS_ATTR_USE_CAST (xmlSchemaAttributeUsePtr)
  |  |  |  |  ------------------
  |  |  ------------------
  ------------------
  |  Branch (14098:7): [True: 15, False: 34]
  ------------------
14099|     49|			WXS_ATTRUSE_DECL_NAME(bcur)) &&
  ------------------
  |  |  162|     49|#define WXS_ATTRUSE_DECL_NAME(au) (WXS_ATTRUSE_DECL(au))->name
  |  |  ------------------
  |  |  |  |  158|     49|#define WXS_ATTRUSE_DECL(au) (WXS_ATTR_USE_CAST (au))->attrDecl
  |  |  |  |  ------------------
  |  |  |  |  |  |  131|     49|#define WXS_ATTR_USE_CAST (xmlSchemaAttributeUsePtr)
  |  |  |  |  ------------------
  |  |  ------------------
  ------------------
14100|     49|		    (WXS_ATTRUSE_DECL_TNS(cur) ==
  ------------------
  |  |  164|     15|#define WXS_ATTRUSE_DECL_TNS(au) (WXS_ATTRUSE_DECL(au))->targetNamespace
  |  |  ------------------
  |  |  |  |  158|     15|#define WXS_ATTRUSE_DECL(au) (WXS_ATTR_USE_CAST (au))->attrDecl
  |  |  |  |  ------------------
  |  |  |  |  |  |  131|     15|#define WXS_ATTR_USE_CAST (xmlSchemaAttributeUsePtr)
  |  |  |  |  ------------------
  |  |  ------------------
  ------------------
  |  Branch (14100:7): [True: 15, False: 0]
  ------------------
14101|     15|			WXS_ATTRUSE_DECL_TNS(bcur)))
  ------------------
  |  |  164|     15|#define WXS_ATTRUSE_DECL_TNS(au) (WXS_ATTRUSE_DECL(au))->targetNamespace
  |  |  ------------------
  |  |  |  |  158|     15|#define WXS_ATTRUSE_DECL(au) (WXS_ATTR_USE_CAST (au))->attrDecl
  |  |  |  |  ------------------
  |  |  |  |  |  |  131|     15|#define WXS_ATTR_USE_CAST (xmlSchemaAttributeUsePtr)
  |  |  |  |  ------------------
  |  |  ------------------
  ------------------
14102|     15|		{
14103|       |		    /*
14104|       |		    * (2.1) "If there is an attribute use in the {attribute
14105|       |		    * uses} of the {base type definition} (call this B) whose
14106|       |		    * {attribute declaration} has the same {name} and {target
14107|       |		    * namespace}, then  all of the following must be true:"
14108|       |		    */
14109|     15|		    found = 1;
14110|       |
14111|     15|		    if ((cur->occurs == XML_SCHEMAS_ATTR_USE_OPTIONAL) &&
  ------------------
  |  |  214|     15|#define XML_SCHEMAS_ATTR_USE_OPTIONAL 2
  ------------------
  |  Branch (14111:11): [True: 13, False: 2]
  ------------------
14112|     15|			(bcur->occurs == XML_SCHEMAS_ATTR_USE_REQUIRED))
  ------------------
  |  |  208|     13|#define XML_SCHEMAS_ATTR_USE_REQUIRED 1
  ------------------
  |  Branch (14112:4): [True: 2, False: 11]
  ------------------
14113|      2|		    {
14114|      2|			xmlChar *str = NULL;
14115|       |			/*
14116|       |			* (2.1.1) "one of the following must be true:"
14117|       |			* (2.1.1.1) "B's {required} is false."
14118|       |			* (2.1.1.2) "R's {required} is true."
14119|       |			*/
14120|      2|			xmlSchemaPAttrUseErr4(pctxt,
14121|      2|			    XML_SCHEMAP_DERIVATION_OK_RESTRICTION_2_1_1,
14122|      2|			    WXS_ITEM_NODE(item), item, cur,
  ------------------
  |  |  142|      2|#define WXS_ITEM_NODE(i) xmlSchemaGetComponentNode(WXS_BASIC_CAST (i))
  |  |  ------------------
  |  |  |  |  124|      2|#define WXS_BASIC_CAST (xmlSchemaBasicItemPtr)
  |  |  ------------------
  ------------------
14123|      2|			    "The 'optional' attribute use is inconsistent "
14124|      2|			    "with the corresponding 'required' attribute use of "
14125|      2|			    "the %s %s",
14126|      2|			    WXS_ACTION_STR(action),
  ------------------
  |  |14061|      2|#define WXS_ACTION_STR(a) \
  |  |  ------------------
  |  |  |  Branch (14061:27): [True: 2, False: 0]
  |  |  ------------------
  |  |14062|      2|((a) == XML_SCHEMA_ACTION_DERIVE) ? (const xmlChar *) "base" : (const xmlChar *) "redefined"
  |  |  ------------------
  |  |  |  |14058|      2|#define XML_SCHEMA_ACTION_DERIVE 0
  |  |  ------------------
  ------------------
14127|      2|			    xmlSchemaGetComponentDesignation(&str, baseItem),
14128|      2|			    NULL, NULL);
14129|      2|			FREE_AND_NULL(str);
  ------------------
  |  |  320|      2|#define FREE_AND_NULL(str) if ((str) != NULL) { xmlFree((xmlChar *) (str)); str = NULL; }
  |  |  ------------------
  |  |  |  Branch (320:32): [True: 2, False: 0]
  |  |  ------------------
  ------------------
14130|       |			/* err = pctxt->err; */
14131|     13|		    } else if (xmlSchemaCheckCOSSTDerivedOK(ACTXT_CAST pctxt,
  ------------------
  |  |  121|     13|#define ACTXT_CAST (xmlSchemaAbstractCtxtPtr)
  ------------------
  |  Branch (14131:18): [True: 0, False: 13]
  ------------------
14132|     13|			WXS_ATTRUSE_TYPEDEF(cur),
  ------------------
  |  |  160|     13|#define WXS_ATTRUSE_TYPEDEF(au) WXS_ATTR_TYPEDEF(WXS_ATTRUSE_DECL( WXS_ATTR_USE_CAST au))
  |  |  ------------------
  |  |  |  |  154|     13|#define WXS_ATTR_TYPEDEF(a) (a)->subtypes
  |  |  ------------------
  ------------------
14133|     13|			WXS_ATTRUSE_TYPEDEF(bcur), 0) != 0)
  ------------------
  |  |  160|     13|#define WXS_ATTRUSE_TYPEDEF(au) WXS_ATTR_TYPEDEF(WXS_ATTRUSE_DECL( WXS_ATTR_USE_CAST au))
  |  |  ------------------
  |  |  |  |  154|     13|#define WXS_ATTR_TYPEDEF(a) (a)->subtypes
  |  |  ------------------
  ------------------
14134|      0|		    {
14135|      0|			xmlChar *strA = NULL, *strB = NULL, *strC = NULL;
14136|       |
14137|       |			/*
14138|       |			* SPEC (2.1.2) "R's {attribute declaration}'s
14139|       |			* {type definition} must be validly derived from
14140|       |			* B's {type definition} given the empty set as
14141|       |			* defined in Type Derivation OK (Simple) ($3.14.6)."
14142|       |			*/
14143|      0|			xmlSchemaPAttrUseErr4(pctxt,
14144|      0|			    XML_SCHEMAP_DERIVATION_OK_RESTRICTION_2_1_2,
14145|      0|			    WXS_ITEM_NODE(item), item, cur,
  ------------------
  |  |  142|      0|#define WXS_ITEM_NODE(i) xmlSchemaGetComponentNode(WXS_BASIC_CAST (i))
  |  |  ------------------
  |  |  |  |  124|      0|#define WXS_BASIC_CAST (xmlSchemaBasicItemPtr)
  |  |  ------------------
  ------------------
14146|      0|			    "The attribute declaration's %s "
14147|      0|			    "is not validly derived from "
14148|      0|			    "the corresponding %s of the "
14149|      0|			    "attribute declaration in the %s %s",
14150|      0|			    xmlSchemaGetComponentDesignation(&strA,
14151|      0|				WXS_ATTRUSE_TYPEDEF(cur)),
  ------------------
  |  |  160|      0|#define WXS_ATTRUSE_TYPEDEF(au) WXS_ATTR_TYPEDEF(WXS_ATTRUSE_DECL( WXS_ATTR_USE_CAST au))
  |  |  ------------------
  |  |  |  |  154|      0|#define WXS_ATTR_TYPEDEF(a) (a)->subtypes
  |  |  ------------------
  ------------------
14152|      0|			    xmlSchemaGetComponentDesignation(&strB,
14153|      0|				WXS_ATTRUSE_TYPEDEF(bcur)),
  ------------------
  |  |  160|      0|#define WXS_ATTRUSE_TYPEDEF(au) WXS_ATTR_TYPEDEF(WXS_ATTRUSE_DECL( WXS_ATTR_USE_CAST au))
  |  |  ------------------
  |  |  |  |  154|      0|#define WXS_ATTR_TYPEDEF(a) (a)->subtypes
  |  |  ------------------
  ------------------
14154|      0|			    WXS_ACTION_STR(action),
  ------------------
  |  |14061|      0|#define WXS_ACTION_STR(a) \
  |  |  ------------------
  |  |  |  Branch (14061:27): [True: 0, False: 0]
  |  |  ------------------
  |  |14062|      0|((a) == XML_SCHEMA_ACTION_DERIVE) ? (const xmlChar *) "base" : (const xmlChar *) "redefined"
  |  |  ------------------
  |  |  |  |14058|      0|#define XML_SCHEMA_ACTION_DERIVE 0
  |  |  ------------------
  ------------------
14155|      0|			    xmlSchemaGetComponentDesignation(&strC, baseItem));
14156|       |			    /* xmlSchemaGetComponentDesignation(&str, baseItem), */
14157|      0|			FREE_AND_NULL(strA);
  ------------------
  |  |  320|      0|#define FREE_AND_NULL(str) if ((str) != NULL) { xmlFree((xmlChar *) (str)); str = NULL; }
  |  |  ------------------
  |  |  |  Branch (320:32): [True: 0, False: 0]
  |  |  ------------------
  ------------------
14158|      0|			FREE_AND_NULL(strB);
  ------------------
  |  |  320|      0|#define FREE_AND_NULL(str) if ((str) != NULL) { xmlFree((xmlChar *) (str)); str = NULL; }
  |  |  ------------------
  |  |  |  Branch (320:32): [True: 0, False: 0]
  |  |  ------------------
  ------------------
14159|      0|			FREE_AND_NULL(strC);
  ------------------
  |  |  320|      0|#define FREE_AND_NULL(str) if ((str) != NULL) { xmlFree((xmlChar *) (str)); str = NULL; }
  |  |  ------------------
  |  |  |  Branch (320:32): [True: 0, False: 0]
  |  |  ------------------
  ------------------
14160|       |			/* err = pctxt->err; */
14161|     13|		    } else {
14162|       |			/*
14163|       |			* 2.1.3 [Definition:]  Let the effective value
14164|       |			* constraint of an attribute use be its {value
14165|       |			* constraint}, if present, otherwise its {attribute
14166|       |			* declaration}'s {value constraint} .
14167|       |			*/
14168|     13|			xmlSchemaGetEffectiveValueConstraint(bcur,
14169|     13|			    &effFixed, &bEffValue, NULL);
14170|       |			/*
14171|       |			* 2.1.3 ... one of the following must be true
14172|       |			*
14173|       |			* 2.1.3.1 B's `effective value constraint` is
14174|       |			* `absent` or default.
14175|       |			*/
14176|     13|			if ((bEffValue != NULL) &&
  ------------------
  |  Branch (14176:8): [True: 0, False: 13]
  ------------------
14177|     13|			    (effFixed == 1)) {
  ------------------
  |  Branch (14177:8): [True: 0, False: 0]
  ------------------
14178|      0|			    const xmlChar *rEffValue = NULL;
14179|       |
14180|      0|			    xmlSchemaGetEffectiveValueConstraint(bcur,
14181|      0|				&effFixed, &rEffValue, NULL);
14182|       |			    /*
14183|       |			    * 2.1.3.2 R's `effective value constraint` is
14184|       |			    * fixed with the same string as B's.
14185|       |			    * MAYBE TODO: Compare the computed values.
14186|       |			    *       Hmm, it says "same string" so
14187|       |			    *       string-equality might really be sufficient.
14188|       |			    */
14189|      0|			    if ((effFixed == 0) ||
  ------------------
  |  Branch (14189:12): [True: 0, False: 0]
  ------------------
14190|      0|				(! WXS_ARE_DEFAULT_STR_EQUAL(rEffValue, bEffValue)))
  ------------------
  |  |  327|      0|#define WXS_ARE_DEFAULT_STR_EQUAL(v1, v2) ((v1) == (v2))
  ------------------
  |  Branch (14190:5): [True: 0, False: 0]
  ------------------
14191|      0|			    {
14192|      0|				xmlChar *str = NULL;
14193|       |
14194|      0|				xmlSchemaPAttrUseErr4(pctxt,
14195|      0|				    XML_SCHEMAP_DERIVATION_OK_RESTRICTION_2_1_3,
14196|      0|				    WXS_ITEM_NODE(item), item, cur,
  ------------------
  |  |  142|      0|#define WXS_ITEM_NODE(i) xmlSchemaGetComponentNode(WXS_BASIC_CAST (i))
  |  |  ------------------
  |  |  |  |  124|      0|#define WXS_BASIC_CAST (xmlSchemaBasicItemPtr)
  |  |  ------------------
  ------------------
14197|      0|				    "The effective value constraint of the "
14198|      0|				    "attribute use is inconsistent with "
14199|      0|				    "its correspondent in the %s %s",
14200|      0|				    WXS_ACTION_STR(action),
  ------------------
  |  |14061|      0|#define WXS_ACTION_STR(a) \
  |  |  ------------------
  |  |  |  Branch (14061:27): [True: 0, False: 0]
  |  |  ------------------
  |  |14062|      0|((a) == XML_SCHEMA_ACTION_DERIVE) ? (const xmlChar *) "base" : (const xmlChar *) "redefined"
  |  |  ------------------
  |  |  |  |14058|      0|#define XML_SCHEMA_ACTION_DERIVE 0
  |  |  ------------------
  ------------------
14201|      0|				    xmlSchemaGetComponentDesignation(&str,
14202|      0|					baseItem),
14203|      0|				    NULL, NULL);
14204|      0|				FREE_AND_NULL(str);
  ------------------
  |  |  320|      0|#define FREE_AND_NULL(str) if ((str) != NULL) { xmlFree((xmlChar *) (str)); str = NULL; }
  |  |  ------------------
  |  |  |  Branch (320:32): [True: 0, False: 0]
  |  |  ------------------
  ------------------
14205|       |				/* err = pctxt->err; */
14206|      0|			    }
14207|      0|			}
14208|     13|		    }
14209|     15|		    break;
14210|     15|		}
14211|     49|	    }
14212|    172|not_found:
14213|    172|	    if (!found) {
  ------------------
  |  Branch (14213:10): [True: 157, False: 15]
  ------------------
14214|       |		/*
14215|       |		* (2.2) "otherwise the {base type definition} must have an
14216|       |		* {attribute wildcard} and the {target namespace} of the
14217|       |		* R's {attribute declaration} must be `valid` with respect
14218|       |		* to that wildcard, as defined in Wildcard allows Namespace
14219|       |		* Name ($3.10.4)."
14220|       |		*/
14221|    157|		if ((baseWild == NULL) ||
  ------------------
  |  Branch (14221:7): [True: 4, False: 153]
  ------------------
14222|    157|		    (xmlSchemaCheckCVCWildcardNamespace(baseWild,
  ------------------
  |  Branch (14222:7): [True: 0, False: 153]
  ------------------
14223|    153|		    (WXS_ATTRUSE_DECL(cur))->targetNamespace) != 0))
  ------------------
  |  |  158|    153|#define WXS_ATTRUSE_DECL(au) (WXS_ATTR_USE_CAST (au))->attrDecl
  |  |  ------------------
  |  |  |  |  131|    153|#define WXS_ATTR_USE_CAST (xmlSchemaAttributeUsePtr)
  |  |  ------------------
  ------------------
14224|      4|		{
14225|      4|		    xmlChar *str = NULL;
14226|       |
14227|      4|		    xmlSchemaPAttrUseErr4(pctxt,
14228|      4|			XML_SCHEMAP_DERIVATION_OK_RESTRICTION_2_2,
14229|      4|			WXS_ITEM_NODE(item), item, cur,
  ------------------
  |  |  142|      4|#define WXS_ITEM_NODE(i) xmlSchemaGetComponentNode(WXS_BASIC_CAST (i))
  |  |  ------------------
  |  |  |  |  124|      4|#define WXS_BASIC_CAST (xmlSchemaBasicItemPtr)
  |  |  ------------------
  ------------------
14230|      4|			"Neither a matching attribute use, "
14231|      4|			"nor a matching wildcard exists in the %s %s",
14232|      4|			WXS_ACTION_STR(action),
  ------------------
  |  |14061|      4|#define WXS_ACTION_STR(a) \
  |  |  ------------------
  |  |  |  Branch (14061:27): [True: 4, False: 0]
  |  |  ------------------
  |  |14062|      4|((a) == XML_SCHEMA_ACTION_DERIVE) ? (const xmlChar *) "base" : (const xmlChar *) "redefined"
  |  |  ------------------
  |  |  |  |14058|      4|#define XML_SCHEMA_ACTION_DERIVE 0
  |  |  ------------------
  ------------------
14233|      4|			xmlSchemaGetComponentDesignation(&str, baseItem),
14234|      4|			NULL, NULL);
14235|      4|		    FREE_AND_NULL(str);
  ------------------
  |  |  320|      4|#define FREE_AND_NULL(str) if ((str) != NULL) { xmlFree((xmlChar *) (str)); str = NULL; }
  |  |  ------------------
  |  |  |  Branch (320:32): [True: 4, False: 0]
  |  |  ------------------
  ------------------
14236|       |		    /* err = pctxt->err; */
14237|      4|		}
14238|    157|	    }
14239|    172|	}
14240|    100|    }
14241|       |    /*
14242|       |    * SPEC derivation-ok-restriction (3):
14243|       |    * (3) "For each attribute use in the {attribute uses} of the {base type
14244|       |    * definition} whose {required} is true, there must be an attribute
14245|       |    * use with an {attribute declaration} with the same {name} and
14246|       |    * {target namespace} as its {attribute declaration} in the {attribute
14247|       |    * uses} of the complex type definition itself whose {required} is true.
14248|       |    */
14249|    285|    if (baseUses != NULL) {
  ------------------
  |  Branch (14249:9): [True: 10, False: 275]
  ------------------
14250|     27|	for (j = 0; j < baseUses->nbItems; j++) {
  ------------------
  |  Branch (14250:14): [True: 17, False: 10]
  ------------------
14251|     17|	    bcur = baseUses->items[j];
14252|     17|	    if (bcur->occurs != XML_SCHEMAS_ATTR_USE_REQUIRED)
  ------------------
  |  |  208|     17|#define XML_SCHEMAS_ATTR_USE_REQUIRED 1
  ------------------
  |  Branch (14252:10): [True: 13, False: 4]
  ------------------
14253|     13|		continue;
14254|      4|	    found = 0;
14255|      4|	    if (uses != NULL) {
  ------------------
  |  Branch (14255:10): [True: 4, False: 0]
  ------------------
14256|     17|		for (i = 0; i < uses->nbItems; i++) {
  ------------------
  |  Branch (14256:15): [True: 16, False: 1]
  ------------------
14257|     16|		    cur = uses->items[i];
14258|     16|		    if ((WXS_ATTRUSE_DECL_NAME(cur) ==
  ------------------
  |  |  162|     16|#define WXS_ATTRUSE_DECL_NAME(au) (WXS_ATTRUSE_DECL(au))->name
  |  |  ------------------
  |  |  |  |  158|     16|#define WXS_ATTRUSE_DECL(au) (WXS_ATTR_USE_CAST (au))->attrDecl
  |  |  |  |  ------------------
  |  |  |  |  |  |  131|     16|#define WXS_ATTR_USE_CAST (xmlSchemaAttributeUsePtr)
  |  |  |  |  ------------------
  |  |  ------------------
  ------------------
  |  Branch (14258:11): [True: 3, False: 13]
  ------------------
14259|     16|			WXS_ATTRUSE_DECL_NAME(bcur)) &&
  ------------------
  |  |  162|     16|#define WXS_ATTRUSE_DECL_NAME(au) (WXS_ATTRUSE_DECL(au))->name
  |  |  ------------------
  |  |  |  |  158|     16|#define WXS_ATTRUSE_DECL(au) (WXS_ATTR_USE_CAST (au))->attrDecl
  |  |  |  |  ------------------
  |  |  |  |  |  |  131|     16|#define WXS_ATTR_USE_CAST (xmlSchemaAttributeUsePtr)
  |  |  |  |  ------------------
  |  |  ------------------
  ------------------
14260|     16|			(WXS_ATTRUSE_DECL_TNS(cur) ==
  ------------------
  |  |  164|      3|#define WXS_ATTRUSE_DECL_TNS(au) (WXS_ATTRUSE_DECL(au))->targetNamespace
  |  |  ------------------
  |  |  |  |  158|      3|#define WXS_ATTRUSE_DECL(au) (WXS_ATTR_USE_CAST (au))->attrDecl
  |  |  |  |  ------------------
  |  |  |  |  |  |  131|      3|#define WXS_ATTR_USE_CAST (xmlSchemaAttributeUsePtr)
  |  |  |  |  ------------------
  |  |  ------------------
  ------------------
  |  Branch (14260:4): [True: 3, False: 0]
  ------------------
14261|      3|			WXS_ATTRUSE_DECL_TNS(bcur))) {
  ------------------
  |  |  164|      3|#define WXS_ATTRUSE_DECL_TNS(au) (WXS_ATTRUSE_DECL(au))->targetNamespace
  |  |  ------------------
  |  |  |  |  158|      3|#define WXS_ATTRUSE_DECL(au) (WXS_ATTR_USE_CAST (au))->attrDecl
  |  |  |  |  ------------------
  |  |  |  |  |  |  131|      3|#define WXS_ATTR_USE_CAST (xmlSchemaAttributeUsePtr)
  |  |  |  |  ------------------
  |  |  ------------------
  ------------------
14262|      3|			found = 1;
14263|      3|			break;
14264|      3|		    }
14265|     16|		}
14266|      4|	    }
14267|      4|	    if (!found) {
  ------------------
  |  Branch (14267:10): [True: 1, False: 3]
  ------------------
14268|      1|		xmlChar *strA = NULL, *strB = NULL;
14269|       |
14270|      1|		xmlSchemaCustomErr4(ACTXT_CAST pctxt,
  ------------------
  |  |  121|      1|#define ACTXT_CAST (xmlSchemaAbstractCtxtPtr)
  ------------------
14271|      1|		    XML_SCHEMAP_DERIVATION_OK_RESTRICTION_3,
14272|      1|		    NULL, item,
14273|      1|		    "A matching attribute use for the "
14274|      1|		    "'required' %s of the %s %s is missing",
14275|      1|		    xmlSchemaGetComponentDesignation(&strA, bcur),
14276|      1|		    WXS_ACTION_STR(action),
  ------------------
  |  |14061|      1|#define WXS_ACTION_STR(a) \
  |  |  ------------------
  |  |  |  Branch (14061:27): [True: 1, False: 0]
  |  |  ------------------
  |  |14062|      1|((a) == XML_SCHEMA_ACTION_DERIVE) ? (const xmlChar *) "base" : (const xmlChar *) "redefined"
  |  |  ------------------
  |  |  |  |14058|      1|#define XML_SCHEMA_ACTION_DERIVE 0
  |  |  ------------------
  ------------------
14277|      1|		    xmlSchemaGetComponentDesignation(&strB, baseItem),
14278|      1|		    NULL);
14279|      1|		FREE_AND_NULL(strA);
  ------------------
  |  |  320|      1|#define FREE_AND_NULL(str) if ((str) != NULL) { xmlFree((xmlChar *) (str)); str = NULL; }
  |  |  ------------------
  |  |  |  Branch (320:32): [True: 1, False: 0]
  |  |  ------------------
  ------------------
14280|      1|		FREE_AND_NULL(strB);
  ------------------
  |  |  320|      1|#define FREE_AND_NULL(str) if ((str) != NULL) { xmlFree((xmlChar *) (str)); str = NULL; }
  |  |  ------------------
  |  |  |  Branch (320:32): [True: 1, False: 0]
  |  |  ------------------
  ------------------
14281|      1|	    }
14282|      4|	}
14283|     10|    }
14284|       |    /*
14285|       |    * derivation-ok-restriction (4)
14286|       |    */
14287|    285|    if (wild != NULL) {
  ------------------
  |  Branch (14287:9): [True: 60, False: 225]
  ------------------
14288|       |	/*
14289|       |	* (4) "If there is an {attribute wildcard}, all of the
14290|       |	* following must be true:"
14291|       |	*/
14292|     60|	if (baseWild == NULL) {
  ------------------
  |  Branch (14292:6): [True: 1, False: 59]
  ------------------
14293|      1|	    xmlChar *str = NULL;
14294|       |
14295|       |	    /*
14296|       |	    * (4.1) "The {base type definition} must also have one."
14297|       |	    */
14298|      1|	    xmlSchemaCustomErr4(ACTXT_CAST pctxt,
  ------------------
  |  |  121|      1|#define ACTXT_CAST (xmlSchemaAbstractCtxtPtr)
  ------------------
14299|      1|		XML_SCHEMAP_DERIVATION_OK_RESTRICTION_4_1,
14300|      1|		NULL, item,
14301|      1|		"The %s has an attribute wildcard, "
14302|      1|		"but the %s %s '%s' does not have one",
14303|      1|		WXS_ITEM_TYPE_NAME(item),
  ------------------
  |  |  144|      1|#define WXS_ITEM_TYPE_NAME(i) xmlSchemaGetComponentTypeStr(WXS_BASIC_CAST (i))
  |  |  ------------------
  |  |  |  |  124|      1|#define WXS_BASIC_CAST (xmlSchemaBasicItemPtr)
  |  |  ------------------
  ------------------
14304|      1|		WXS_ACTION_STR(action),
  ------------------
  |  |14061|      1|#define WXS_ACTION_STR(a) \
  |  |  ------------------
  |  |  |  Branch (14061:27): [True: 1, False: 0]
  |  |  ------------------
  |  |14062|      1|((a) == XML_SCHEMA_ACTION_DERIVE) ? (const xmlChar *) "base" : (const xmlChar *) "redefined"
  |  |  ------------------
  |  |  |  |14058|      1|#define XML_SCHEMA_ACTION_DERIVE 0
  |  |  ------------------
  ------------------
14305|      1|		WXS_ITEM_TYPE_NAME(baseItem),
  ------------------
  |  |  144|      1|#define WXS_ITEM_TYPE_NAME(i) xmlSchemaGetComponentTypeStr(WXS_BASIC_CAST (i))
  |  |  ------------------
  |  |  |  |  124|      1|#define WXS_BASIC_CAST (xmlSchemaBasicItemPtr)
  |  |  ------------------
  ------------------
14306|      1|		xmlSchemaGetComponentQName(&str, baseItem));
14307|      1|	    FREE_AND_NULL(str);
  ------------------
  |  |  320|      1|#define FREE_AND_NULL(str) if ((str) != NULL) { xmlFree((xmlChar *) (str)); str = NULL; }
  |  |  ------------------
  |  |  |  Branch (320:32): [True: 1, False: 0]
  |  |  ------------------
  ------------------
14308|      1|	    return(pctxt->err);
14309|     59|	} else if ((baseWild->any == 0) &&
  ------------------
  |  Branch (14309:13): [True: 1, False: 58]
  ------------------
14310|     59|		xmlSchemaCheckCOSNSSubset(wild, baseWild))
  ------------------
  |  Branch (14310:3): [True: 1, False: 0]
  ------------------
14311|      1|	{
14312|      1|	    xmlChar *str = NULL;
14313|       |	    /*
14314|       |	    * (4.2) "The complex type definition's {attribute wildcard}'s
14315|       |	    * {namespace constraint} must be a subset of the {base type
14316|       |	    * definition}'s {attribute wildcard}'s {namespace constraint},
14317|       |	    * as defined by Wildcard Subset ($3.10.6)."
14318|       |	    */
14319|      1|	    xmlSchemaCustomErr4(ACTXT_CAST pctxt,
  ------------------
  |  |  121|      1|#define ACTXT_CAST (xmlSchemaAbstractCtxtPtr)
  ------------------
14320|      1|		XML_SCHEMAP_DERIVATION_OK_RESTRICTION_4_2,
14321|      1|		NULL, item,
14322|      1|		"The attribute wildcard is not a valid "
14323|      1|		"subset of the wildcard in the %s %s '%s'",
14324|      1|		WXS_ACTION_STR(action),
  ------------------
  |  |14061|      1|#define WXS_ACTION_STR(a) \
  |  |  ------------------
  |  |  |  Branch (14061:27): [True: 1, False: 0]
  |  |  ------------------
  |  |14062|      1|((a) == XML_SCHEMA_ACTION_DERIVE) ? (const xmlChar *) "base" : (const xmlChar *) "redefined"
  |  |  ------------------
  |  |  |  |14058|      1|#define XML_SCHEMA_ACTION_DERIVE 0
  |  |  ------------------
  ------------------
14325|      1|		WXS_ITEM_TYPE_NAME(baseItem),
  ------------------
  |  |  144|      1|#define WXS_ITEM_TYPE_NAME(i) xmlSchemaGetComponentTypeStr(WXS_BASIC_CAST (i))
  |  |  ------------------
  |  |  |  |  124|      1|#define WXS_BASIC_CAST (xmlSchemaBasicItemPtr)
  |  |  ------------------
  ------------------
14326|      1|		xmlSchemaGetComponentQName(&str, baseItem),
14327|      1|		NULL);
14328|      1|	    FREE_AND_NULL(str);
  ------------------
  |  |  320|      1|#define FREE_AND_NULL(str) if ((str) != NULL) { xmlFree((xmlChar *) (str)); str = NULL; }
  |  |  ------------------
  |  |  |  Branch (320:32): [True: 1, False: 0]
  |  |  ------------------
  ------------------
14329|      1|	    return(pctxt->err);
14330|      1|	}
14331|       |	/* 4.3 Unless the {base type definition} is the `ur-type
14332|       |	* definition`, the complex type definition's {attribute
14333|       |	* wildcard}'s {process contents} must be identical to or
14334|       |	* stronger than the {base type definition}'s {attribute
14335|       |	* wildcard}'s {process contents}, where strict is stronger
14336|       |	* than lax is stronger than skip.
14337|       |	*/
14338|     58|	if ((! WXS_IS_ANYTYPE(baseItem)) &&
  ------------------
  |  |  209|     58|     (( (i)->type == XML_SCHEMA_TYPE_BASIC) && \
  |  |  ------------------
  |  |  |  Branch (209:7): [True: 57, False: 1]
  |  |  ------------------
  |  |  210|     58|      ( (WXS_TYPE_CAST (i))->builtInType == XML_SCHEMAS_ANYTYPE))
  |  |  ------------------
  |  |  |  |  127|     57|#define WXS_TYPE_CAST (xmlSchemaTypePtr)
  |  |  ------------------
  |  |  |  Branch (210:7): [True: 57, False: 0]
  |  |  ------------------
  ------------------
14339|     58|	    (wild->processContents < baseWild->processContents)) {
  ------------------
  |  Branch (14339:6): [True: 1, False: 0]
  ------------------
14340|      1|	    xmlChar *str = NULL;
14341|      1|	    xmlSchemaCustomErr4(ACTXT_CAST pctxt,
  ------------------
  |  |  121|      1|#define ACTXT_CAST (xmlSchemaAbstractCtxtPtr)
  ------------------
14342|      1|		XML_SCHEMAP_DERIVATION_OK_RESTRICTION_4_3,
14343|      1|		NULL, baseItem,
14344|      1|		"The {process contents} of the attribute wildcard is "
14345|      1|		"weaker than the one in the %s %s '%s'",
14346|      1|		WXS_ACTION_STR(action),
  ------------------
  |  |14061|      1|#define WXS_ACTION_STR(a) \
  |  |  ------------------
  |  |  |  Branch (14061:27): [True: 1, False: 0]
  |  |  ------------------
  |  |14062|      1|((a) == XML_SCHEMA_ACTION_DERIVE) ? (const xmlChar *) "base" : (const xmlChar *) "redefined"
  |  |  ------------------
  |  |  |  |14058|      1|#define XML_SCHEMA_ACTION_DERIVE 0
  |  |  ------------------
  ------------------
14347|      1|		WXS_ITEM_TYPE_NAME(baseItem),
  ------------------
  |  |  144|      1|#define WXS_ITEM_TYPE_NAME(i) xmlSchemaGetComponentTypeStr(WXS_BASIC_CAST (i))
  |  |  ------------------
  |  |  |  |  124|      1|#define WXS_BASIC_CAST (xmlSchemaBasicItemPtr)
  |  |  ------------------
  ------------------
14348|      1|		xmlSchemaGetComponentQName(&str, baseItem),
14349|      1|		NULL);
14350|      1|	    FREE_AND_NULL(str)
  ------------------
  |  |  320|      1|#define FREE_AND_NULL(str) if ((str) != NULL) { xmlFree((xmlChar *) (str)); str = NULL; }
  |  |  ------------------
  |  |  |  Branch (320:32): [True: 1, False: 0]
  |  |  ------------------
  ------------------
14351|      1|		return(pctxt->err);
14352|      1|	}
14353|     58|    }
14354|    282|    return(0);
14355|    285|}
xmlschemas.c:xmlSchemaPAttrUseErr4:
 3053|      6|{
 3054|      6|    xmlChar *str = NULL, *msg = NULL;
 3055|       |
 3056|      6|    xmlSchemaFormatItemForReport(&msg, NULL, ownerItem, NULL);
 3057|      6|    msg = xmlStrcat(msg, BAD_CAST ", ");
  ------------------
  |  |   35|      6|#define BAD_CAST (xmlChar *)
  ------------------
 3058|      6|    msg = xmlStrcat(msg,
 3059|      6|	BAD_CAST xmlSchemaFormatItemForReport(&str, NULL,
  ------------------
  |  |   35|      6|#define BAD_CAST (xmlChar *)
  ------------------
 3060|      6|	WXS_BASIC_CAST attruse, NULL));
  ------------------
  |  |  124|      6|#define WXS_BASIC_CAST (xmlSchemaBasicItemPtr)
  ------------------
 3061|      6|    FREE_AND_NULL(str);
  ------------------
  |  |  320|      6|#define FREE_AND_NULL(str) if ((str) != NULL) { xmlFree((xmlChar *) (str)); str = NULL; }
  |  |  ------------------
  |  |  |  Branch (320:32): [True: 6, False: 0]
  |  |  ------------------
  ------------------
 3062|      6|    msg = xmlStrcat(msg, BAD_CAST ": ");
  ------------------
  |  |   35|      6|#define BAD_CAST (xmlChar *)
  ------------------
 3063|      6|    msg = xmlStrcat(msg, (const xmlChar *) message);
 3064|      6|    msg = xmlStrcat(msg, BAD_CAST ".\n");
  ------------------
  |  |   35|      6|#define BAD_CAST (xmlChar *)
  ------------------
 3065|      6|    xmlSchemaErr4(ACTXT_CAST ctxt, error, node,
  ------------------
  |  |  121|      6|#define ACTXT_CAST (xmlSchemaAbstractCtxtPtr)
  ------------------
 3066|      6|	(const char *) msg, str1, str2, str3, str4);
 3067|      6|    xmlFree(msg);
 3068|      6|}
xmlschemas.c:xmlSchemaGetEffectiveValueConstraint:
13998|     13|{
13999|     13|    *fixed = 0;
14000|     13|    *value = NULL;
14001|     13|    if (val != 0)
  ------------------
  |  Branch (14001:9): [True: 0, False: 13]
  ------------------
14002|      0|	*val = NULL;
14003|       |
14004|     13|    if (attruse->defValue != NULL) {
  ------------------
  |  Branch (14004:9): [True: 0, False: 13]
  ------------------
14005|      0|	*value = attruse->defValue;
14006|      0|	if (val != NULL)
  ------------------
  |  Branch (14006:6): [True: 0, False: 0]
  ------------------
14007|      0|	    *val = attruse->defVal;
14008|      0|	if (attruse->flags & XML_SCHEMA_ATTR_USE_FIXED)
  ------------------
  |  |  508|      0|#define XML_SCHEMA_ATTR_USE_FIXED 1<<0
  ------------------
  |  Branch (14008:6): [True: 0, False: 0]
  ------------------
14009|      0|	    *fixed = 1;
14010|      0|	return(1);
14011|     13|    } else if ((attruse->attrDecl != NULL) &&
  ------------------
  |  Branch (14011:16): [True: 13, False: 0]
  ------------------
14012|     13|	(attruse->attrDecl->defValue != NULL)) {
  ------------------
  |  Branch (14012:2): [True: 0, False: 13]
  ------------------
14013|      0|	*value = attruse->attrDecl->defValue;
14014|      0|	if (val != NULL)
  ------------------
  |  Branch (14014:6): [True: 0, False: 0]
  ------------------
14015|      0|	    *val = attruse->attrDecl->defVal;
14016|      0|	if (attruse->attrDecl->flags & XML_SCHEMAS_ATTR_FIXED)
  ------------------
  |  |  239|      0|#define XML_SCHEMAS_ATTR_FIXED        1 << 9
  ------------------
  |  Branch (14016:6): [True: 0, False: 0]
  ------------------
14017|      0|	    *fixed = 1;
14018|      0|	return(1);
14019|      0|    }
14020|     13|    return(0);
14021|     13|}
xmlschemas.c:xmlSchemaCheckCVCWildcardNamespace:
14036|    153|{
14037|    153|    if (wild == NULL)
  ------------------
  |  Branch (14037:9): [True: 0, False: 153]
  ------------------
14038|      0|	return(-1);
14039|       |
14040|    153|    if (wild->any)
  ------------------
  |  Branch (14040:9): [True: 153, False: 0]
  ------------------
14041|    153|	return(0);
14042|      0|    else if (wild->nsSet != NULL) {
  ------------------
  |  Branch (14042:14): [True: 0, False: 0]
  ------------------
14043|      0|	xmlSchemaWildcardNsPtr cur;
14044|       |
14045|      0|	cur = wild->nsSet;
14046|      0|	while (cur != NULL) {
  ------------------
  |  Branch (14046:9): [True: 0, False: 0]
  ------------------
14047|      0|	    if (xmlStrEqual(cur->value, ns))
  ------------------
  |  Branch (14047:10): [True: 0, False: 0]
  ------------------
14048|      0|		return(0);
14049|      0|	    cur = cur->next;
14050|      0|	}
14051|      0|    } else if ((wild->negNsSet != NULL) && (ns != NULL) &&
  ------------------
  |  Branch (14051:16): [True: 0, False: 0]
  |  Branch (14051:44): [True: 0, False: 0]
  ------------------
14052|      0|	(!xmlStrEqual(wild->negNsSet->value, ns)))
  ------------------
  |  Branch (14052:2): [True: 0, False: 0]
  ------------------
14053|      0|	return(0);
14054|       |
14055|      0|    return(1);
14056|    153|}
xmlschemas.c:xmlSchemaCheckCOSNSSubset:
13933|      1|{
13934|       |    /*
13935|       |    * 1 super must be any.
13936|       |    */
13937|      1|    if (super->any)
  ------------------
  |  Branch (13937:9): [True: 0, False: 1]
  ------------------
13938|      0|	return (0);
13939|       |    /*
13940|       |    * 2.1 sub must be a pair of not and a namespace name or `absent`.
13941|       |    * 2.2 super must be a pair of not and the same value.
13942|       |    */
13943|      1|    if ((sub->negNsSet != NULL) &&
  ------------------
  |  Branch (13943:9): [True: 0, False: 1]
  ------------------
13944|      1|	(super->negNsSet != NULL) &&
  ------------------
  |  Branch (13944:2): [True: 0, False: 0]
  ------------------
13945|      1|	(sub->negNsSet->value == super->negNsSet->value))
  ------------------
  |  Branch (13945:2): [True: 0, False: 0]
  ------------------
13946|      0|	return (0);
13947|       |    /*
13948|       |    * 3.1 sub must be a set whose members are either namespace names or `absent`.
13949|       |    */
13950|      1|    if (sub->nsSet != NULL) {
  ------------------
  |  Branch (13950:9): [True: 0, False: 1]
  ------------------
13951|       |	/*
13952|       |	* 3.2.1 super must be the same set or a superset thereof.
13953|       |	*/
13954|      0|	if (super->nsSet != NULL) {
  ------------------
  |  Branch (13954:6): [True: 0, False: 0]
  ------------------
13955|      0|	    xmlSchemaWildcardNsPtr cur, curB;
13956|      0|	    int found = 0;
13957|       |
13958|      0|	    cur = sub->nsSet;
13959|      0|	    while (cur != NULL) {
  ------------------
  |  Branch (13959:13): [True: 0, False: 0]
  ------------------
13960|      0|		found = 0;
13961|      0|		curB = super->nsSet;
13962|      0|		while (curB != NULL) {
  ------------------
  |  Branch (13962:10): [True: 0, False: 0]
  ------------------
13963|      0|		    if (cur->value == curB->value) {
  ------------------
  |  Branch (13963:11): [True: 0, False: 0]
  ------------------
13964|      0|			found = 1;
13965|      0|			break;
13966|      0|		    }
13967|      0|		    curB = curB->next;
13968|      0|		}
13969|      0|		if (!found)
  ------------------
  |  Branch (13969:7): [True: 0, False: 0]
  ------------------
13970|      0|		    return (1);
13971|      0|		cur = cur->next;
13972|      0|	    }
13973|      0|	    if (found)
  ------------------
  |  Branch (13973:10): [True: 0, False: 0]
  ------------------
13974|      0|		return (0);
13975|      0|	} else if (super->negNsSet != NULL) {
  ------------------
  |  Branch (13975:13): [True: 0, False: 0]
  ------------------
13976|      0|	    xmlSchemaWildcardNsPtr cur;
13977|       |	    /*
13978|       |	    * 3.2.2 super must be a pair of not and a namespace name or
13979|       |	    * `absent` and that value must not be in sub's set.
13980|       |	    */
13981|      0|	    cur = sub->nsSet;
13982|      0|	    while (cur != NULL) {
  ------------------
  |  Branch (13982:13): [True: 0, False: 0]
  ------------------
13983|      0|		if (cur->value == super->negNsSet->value)
  ------------------
  |  Branch (13983:7): [True: 0, False: 0]
  ------------------
13984|      0|		    return (1);
13985|      0|		cur = cur->next;
13986|      0|	    }
13987|      0|	    return (0);
13988|      0|	}
13989|      0|    }
13990|      1|    return (1);
13991|      1|}
xmlschemas.c:xmlSchemaFixupComplexType:
18099|    361|{
18100|    361|    int res = 0, olderrs = pctxt->nberrors;
18101|    361|    xmlSchemaTypePtr baseType = type->baseType;
18102|       |
18103|    361|    if (! WXS_IS_TYPE_NOT_FIXED(type))
  ------------------
  |  |  232|    361|    (((i)->type != XML_SCHEMA_TYPE_BASIC) && \
  |  |  ------------------
  |  |  |  Branch (232:6): [True: 361, False: 0]
  |  |  ------------------
  |  |  233|    361|     (((i)->flags & XML_SCHEMAS_TYPE_INTERNAL_RESOLVED) == 0))
  |  |  ------------------
  |  |  |  |  539|    361|#define XML_SCHEMAS_TYPE_INTERNAL_RESOLVED    1 << 22
  |  |  ------------------
  |  |  |  Branch (233:6): [True: 361, False: 0]
  |  |  ------------------
  ------------------
18104|      0|	return(0);
18105|    361|    type->flags |= XML_SCHEMAS_TYPE_INTERNAL_RESOLVED;
  ------------------
  |  |  539|    361|#define XML_SCHEMAS_TYPE_INTERNAL_RESOLVED    1 << 22
  ------------------
18106|    361|    if (baseType == NULL) {
  ------------------
  |  Branch (18106:9): [True: 0, False: 361]
  ------------------
18107|      0|	PERROR_INT("xmlSchemaFixupComplexType",
  ------------------
  |  | 2824|      0|#define PERROR_INT(func, msg) xmlSchemaInternalErr(ACTXT_CAST pctxt, func, msg);
  |  |  ------------------
  |  |  |  |  121|      0|#define ACTXT_CAST (xmlSchemaAbstractCtxtPtr)
  |  |  ------------------
  ------------------
18108|      0|	    "missing baseType");
18109|      0|	goto exit_failure;
18110|      0|    }
18111|       |    /*
18112|       |    * Fixup the base type.
18113|       |    */
18114|    361|    if (WXS_IS_TYPE_NOT_FIXED(baseType))
  ------------------
  |  |  232|    361|    (((i)->type != XML_SCHEMA_TYPE_BASIC) && \
  |  |  ------------------
  |  |  |  Branch (232:6): [True: 70, False: 291]
  |  |  ------------------
  |  |  233|    361|     (((i)->flags & XML_SCHEMAS_TYPE_INTERNAL_RESOLVED) == 0))
  |  |  ------------------
  |  |  |  |  539|     70|#define XML_SCHEMAS_TYPE_INTERNAL_RESOLVED    1 << 22
  |  |  ------------------
  |  |  |  Branch (233:6): [True: 30, False: 40]
  |  |  ------------------
  ------------------
18115|     30|	xmlSchemaTypeFixup(baseType, ACTXT_CAST pctxt);
  ------------------
  |  |  121|     30|#define ACTXT_CAST (xmlSchemaAbstractCtxtPtr)
  ------------------
18116|    361|    if (baseType->flags & XML_SCHEMAS_TYPE_INTERNAL_INVALID) {
  ------------------
  |  |  545|    361|#define XML_SCHEMAS_TYPE_INTERNAL_INVALID    1 << 23
  ------------------
  |  Branch (18116:9): [True: 0, False: 361]
  ------------------
18117|       |	/*
18118|       |	* Skip fixup if the base type is invalid.
18119|       |	* TODO: Generate a warning!
18120|       |	*/
18121|      0|	return(0);
18122|      0|    }
18123|       |    /*
18124|       |    * This basically checks if the base type can be derived.
18125|       |    */
18126|    361|    res = xmlSchemaCheckSRCCT(pctxt, type);
18127|    361|    HFAILURE HERROR
  ------------------
  |  |  333|    361|#define HFAILURE if (res == -1) goto exit_failure;
  |  |  ------------------
  |  |  |  Branch (333:22): [True: 0, False: 361]
  |  |  ------------------
  ------------------
                  HFAILURE HERROR
  ------------------
  |  |  335|    361|#define HERROR if (res != 0) goto exit_error;
  |  |  ------------------
  |  |  |  Branch (335:20): [True: 0, False: 361]
  |  |  ------------------
  ------------------
18128|       |    /*
18129|       |    * Fixup the content type.
18130|       |    */
18131|    361|    if (type->contentType == XML_SCHEMA_CONTENT_SIMPLE) {
  ------------------
  |  Branch (18131:9): [True: 40, False: 321]
  ------------------
18132|       |	/*
18133|       |	* Corresponds to <complexType><simpleContent>...
18134|       |	*/
18135|     40|	if ((WXS_IS_COMPLEX(baseType)) &&
  ------------------
  |  |  213|     40|    (((i)->type == XML_SCHEMA_TYPE_COMPLEX) || \
  |  |  ------------------
  |  |  |  Branch (213:6): [True: 2, False: 38]
  |  |  ------------------
  |  |  214|     40|     ((i)->builtInType == XML_SCHEMAS_ANYTYPE))
  |  |  ------------------
  |  |  |  Branch (214:6): [True: 6, False: 32]
  |  |  ------------------
  ------------------
18136|     40|	    (baseType->contentTypeDef != NULL) &&
  ------------------
  |  Branch (18136:6): [True: 2, False: 6]
  ------------------
18137|     40|	    (WXS_IS_RESTRICTION(type))) {
  ------------------
  |  |  226|      2|    ((t)->flags & XML_SCHEMAS_TYPE_DERIVATION_METHOD_RESTRICTION)
  |  |  ------------------
  |  |  |  |  420|      2|#define XML_SCHEMAS_TYPE_DERIVATION_METHOD_RESTRICTION                1 << 2
  |  |  ------------------
  ------------------
  |  Branch (18137:6): [True: 2, False: 0]
  ------------------
18138|      2|	    xmlSchemaTypePtr contentBase, content;
18139|       |#ifdef ENABLE_NAMED_LOCALS
18140|       |	    char buf[30];
18141|       |	    const xmlChar *tmpname;
18142|       |#endif
18143|       |	    /*
18144|       |	    * SPEC (1) If <restriction> + base type is <complexType>,
18145|       |	    * "whose own {content type} is a simple type..."
18146|       |	    */
18147|      2|	    if (type->contentTypeDef != NULL) {
  ------------------
  |  Branch (18147:10): [True: 2, False: 0]
  ------------------
18148|       |		/*
18149|       |		* SPEC (1.1) "the simple type definition corresponding to the
18150|       |		* <simpleType> among the [children] of <restriction> if there
18151|       |		* is one;"
18152|       |		* Note that this "<simpleType> among the [children]" was put
18153|       |		* into ->contentTypeDef during parsing.
18154|       |		*/
18155|      2|		contentBase = type->contentTypeDef;
18156|      2|		type->contentTypeDef = NULL;
18157|      2|	    } else {
18158|       |		/*
18159|       |		* (1.2) "...otherwise (<restriction> has no <simpleType>
18160|       |		* among its [children]), the simple type definition which
18161|       |		* is the {content type} of the ... base type."
18162|       |		*/
18163|      0|		contentBase = baseType->contentTypeDef;
18164|      0|	    }
18165|       |	    /*
18166|       |	    * SPEC
18167|       |	    * "... a simple type definition which restricts the simple
18168|       |	    * type definition identified in clause 1.1 or clause 1.2
18169|       |	    * with a set of facet components"
18170|       |	    *
18171|       |	    * Create the anonymous simple type, which will be the content
18172|       |	    * type of the complex type.
18173|       |	    */
18174|       |#ifdef ENABLE_NAMED_LOCALS
18175|       |	    snprintf(buf, 29, "#scST%d", ++(pctxt->counter));
18176|       |	    tmpname = xmlDictLookup(pctxt->dict, BAD_CAST buf, -1);
18177|       |	    content = xmlSchemaAddType(pctxt, pctxt->schema,
18178|       |		XML_SCHEMA_TYPE_SIMPLE, tmpname, type->targetNamespace,
18179|       |		type->node, 0);
18180|       |#else
18181|      2|	    content = xmlSchemaAddType(pctxt, pctxt->schema,
18182|      2|		XML_SCHEMA_TYPE_SIMPLE, NULL, type->targetNamespace,
18183|      2|		type->node, 0);
18184|      2|#endif
18185|      2|	    if (content == NULL)
  ------------------
  |  Branch (18185:10): [True: 0, False: 2]
  ------------------
18186|      0|		goto exit_failure;
18187|       |	    /*
18188|       |	    * We will use the same node as for the <complexType>
18189|       |	    * to have it somehow anchored in the schema doc.
18190|       |	    */
18191|      2|	    content->type = XML_SCHEMA_TYPE_SIMPLE;
18192|      2|	    content->baseType = contentBase;
18193|       |	    /*
18194|       |	    * Move the facets, previously anchored on the
18195|       |	    * complexType during parsing.
18196|       |	    */
18197|      2|	    content->facets = type->facets;
18198|      2|	    type->facets = NULL;
18199|      2|	    content->facetSet = type->facetSet;
18200|      2|	    type->facetSet = NULL;
18201|       |
18202|      2|	    type->contentTypeDef = content;
18203|      2|	    if (WXS_IS_TYPE_NOT_FIXED(contentBase))
  ------------------
  |  |  232|      2|    (((i)->type != XML_SCHEMA_TYPE_BASIC) && \
  |  |  ------------------
  |  |  |  Branch (232:6): [True: 2, False: 0]
  |  |  ------------------
  |  |  233|      2|     (((i)->flags & XML_SCHEMAS_TYPE_INTERNAL_RESOLVED) == 0))
  |  |  ------------------
  |  |  |  |  539|      2|#define XML_SCHEMAS_TYPE_INTERNAL_RESOLVED    1 << 22
  |  |  ------------------
  |  |  |  Branch (233:6): [True: 0, False: 2]
  |  |  ------------------
  ------------------
18204|      0|		xmlSchemaTypeFixup(contentBase, ACTXT_CAST pctxt);
  ------------------
  |  |  121|      0|#define ACTXT_CAST (xmlSchemaAbstractCtxtPtr)
  ------------------
18205|       |	    /*
18206|       |	    * Fixup the newly created type. We don't need to check
18207|       |	    * for circularity here.
18208|       |	    */
18209|      2|	    res = xmlSchemaFixupSimpleTypeStageOne(pctxt, content);
18210|      2|	    HFAILURE HERROR
  ------------------
  |  |  333|      2|#define HFAILURE if (res == -1) goto exit_failure;
  |  |  ------------------
  |  |  |  Branch (333:22): [True: 0, False: 2]
  |  |  ------------------
  ------------------
              	    HFAILURE HERROR
  ------------------
  |  |  335|      2|#define HERROR if (res != 0) goto exit_error;
  |  |  ------------------
  |  |  |  Branch (335:20): [True: 0, False: 2]
  |  |  ------------------
  ------------------
18211|      2|	    res = xmlSchemaFixupSimpleTypeStageTwo(pctxt, content);
18212|      2|	    HFAILURE HERROR
  ------------------
  |  |  333|      2|#define HFAILURE if (res == -1) goto exit_failure;
  |  |  ------------------
  |  |  |  Branch (333:22): [True: 0, False: 2]
  |  |  ------------------
  ------------------
              	    HFAILURE HERROR
  ------------------
  |  |  335|      2|#define HERROR if (res != 0) goto exit_error;
  |  |  ------------------
  |  |  |  Branch (335:20): [True: 0, False: 2]
  |  |  ------------------
  ------------------
18213|       |
18214|     38|	} else if ((WXS_IS_COMPLEX(baseType)) &&
  ------------------
  |  |  213|     38|    (((i)->type == XML_SCHEMA_TYPE_COMPLEX) || \
  |  |  ------------------
  |  |  |  Branch (213:6): [True: 0, False: 38]
  |  |  ------------------
  |  |  214|     38|     ((i)->builtInType == XML_SCHEMAS_ANYTYPE))
  |  |  ------------------
  |  |  |  Branch (214:6): [True: 6, False: 32]
  |  |  ------------------
  ------------------
18215|     38|	    (baseType->contentType == XML_SCHEMA_CONTENT_MIXED) &&
  ------------------
  |  Branch (18215:6): [True: 6, False: 0]
  ------------------
18216|     38|	    (WXS_IS_RESTRICTION(type))) {
  ------------------
  |  |  226|      6|    ((t)->flags & XML_SCHEMAS_TYPE_DERIVATION_METHOD_RESTRICTION)
  |  |  ------------------
  |  |  |  |  420|      6|#define XML_SCHEMAS_TYPE_DERIVATION_METHOD_RESTRICTION                1 << 2
  |  |  ------------------
  ------------------
  |  Branch (18216:6): [True: 6, False: 0]
  ------------------
18217|       |	    /*
18218|       |	    * SPEC (2) If <restriction> + base is a mixed <complexType> with
18219|       |	    * an emptiable particle, then a simple type definition which
18220|       |	    * restricts the <restriction>'s <simpleType> child.
18221|       |	    */
18222|      6|	    if ((type->contentTypeDef == NULL) ||
  ------------------
  |  Branch (18222:10): [True: 0, False: 6]
  ------------------
18223|      6|		(type->contentTypeDef->baseType == NULL)) {
  ------------------
  |  Branch (18223:3): [True: 0, False: 6]
  ------------------
18224|       |		/*
18225|       |		* TODO: Check if this ever happens.
18226|       |		*/
18227|      0|		xmlSchemaPCustomErr(pctxt,
18228|      0|		    XML_SCHEMAP_INTERNAL,
18229|      0|		    WXS_BASIC_CAST type, NULL,
  ------------------
  |  |  124|      0|#define WXS_BASIC_CAST (xmlSchemaBasicItemPtr)
  ------------------
18230|      0|		    "Internal error: xmlSchemaTypeFixup, "
18231|      0|		    "complex type '%s': the <simpleContent><restriction> "
18232|      0|		    "is missing a <simpleType> child, but was not caught "
18233|      0|		    "by xmlSchemaCheckSRCCT()", type->name);
18234|      0|		goto exit_failure;
18235|      0|	    }
18236|     32|	} else if ((WXS_IS_COMPLEX(baseType)) && WXS_IS_EXTENSION(type)) {
  ------------------
  |  |  213|     32|    (((i)->type == XML_SCHEMA_TYPE_COMPLEX) || \
  |  |  ------------------
  |  |  |  Branch (213:6): [True: 0, False: 32]
  |  |  ------------------
  |  |  214|     32|     ((i)->builtInType == XML_SCHEMAS_ANYTYPE))
  |  |  ------------------
  |  |  |  Branch (214:6): [True: 0, False: 32]
  |  |  ------------------
  ------------------
              	} else if ((WXS_IS_COMPLEX(baseType)) && WXS_IS_EXTENSION(type)) {
  ------------------
  |  |  229|      0|    ((t)->flags & XML_SCHEMAS_TYPE_DERIVATION_METHOD_EXTENSION)
  |  |  ------------------
  |  |  |  |  414|      0|#define XML_SCHEMAS_TYPE_DERIVATION_METHOD_EXTENSION                1 << 1
  |  |  ------------------
  |  |  |  Branch (229:5): [True: 0, False: 0]
  |  |  ------------------
  ------------------
18237|       |	    /*
18238|       |	    * SPEC (3) If <extension> + base is <complexType> with
18239|       |	    * <simpleType> content, "...then the {content type} of that
18240|       |	    * complex type definition"
18241|       |	    */
18242|      0|	    if (baseType->contentTypeDef == NULL) {
  ------------------
  |  Branch (18242:10): [True: 0, False: 0]
  ------------------
18243|       |		/*
18244|       |		* TODO: Check if this ever happens. xmlSchemaCheckSRCCT
18245|       |		* should have caught this already.
18246|       |		*/
18247|      0|		xmlSchemaPCustomErr(pctxt,
18248|      0|		    XML_SCHEMAP_INTERNAL,
18249|      0|		    WXS_BASIC_CAST type, NULL,
  ------------------
  |  |  124|      0|#define WXS_BASIC_CAST (xmlSchemaBasicItemPtr)
  ------------------
18250|      0|		    "Internal error: xmlSchemaTypeFixup, "
18251|      0|		    "complex type '%s': the <extension>ed base type is "
18252|      0|		    "a complex type with no simple content type",
18253|      0|		    type->name);
18254|      0|		goto exit_failure;
18255|      0|	    }
18256|      0|	    type->contentTypeDef = baseType->contentTypeDef;
18257|     32|	} else if ((WXS_IS_SIMPLE(baseType)) && WXS_IS_EXTENSION(type)) {
  ------------------
  |  |  217|     32|    ((item->type == XML_SCHEMA_TYPE_SIMPLE) || \
  |  |  ------------------
  |  |  |  Branch (217:6): [True: 13, False: 19]
  |  |  ------------------
  |  |  218|     32|     ((item->type == XML_SCHEMA_TYPE_BASIC) && \
  |  |  ------------------
  |  |  |  Branch (218:7): [True: 19, False: 0]
  |  |  ------------------
  |  |  219|     19|      (item->builtInType != XML_SCHEMAS_ANYTYPE)))
  |  |  ------------------
  |  |  |  Branch (219:7): [True: 19, False: 0]
  |  |  ------------------
  ------------------
              	} else if ((WXS_IS_SIMPLE(baseType)) && WXS_IS_EXTENSION(type)) {
  ------------------
  |  |  229|     32|    ((t)->flags & XML_SCHEMAS_TYPE_DERIVATION_METHOD_EXTENSION)
  |  |  ------------------
  |  |  |  |  414|     32|#define XML_SCHEMAS_TYPE_DERIVATION_METHOD_EXTENSION                1 << 1
  |  |  ------------------
  |  |  |  Branch (229:5): [True: 32, False: 0]
  |  |  ------------------
  ------------------
18258|       |	    /*
18259|       |	    * SPEC (4) <extension> + base is <simpleType>
18260|       |	    * "... then that simple type definition"
18261|       |	    */
18262|     32|	    type->contentTypeDef = baseType;
18263|     32|	} else {
18264|       |	    /*
18265|       |	    * TODO: Check if this ever happens.
18266|       |	    */
18267|      0|	    xmlSchemaPCustomErr(pctxt,
18268|      0|		XML_SCHEMAP_INTERNAL,
18269|      0|		WXS_BASIC_CAST type, NULL,
  ------------------
  |  |  124|      0|#define WXS_BASIC_CAST (xmlSchemaBasicItemPtr)
  ------------------
18270|      0|		"Internal error: xmlSchemaTypeFixup, "
18271|      0|		"complex type '%s' with <simpleContent>: unhandled "
18272|      0|		"derivation case", type->name);
18273|      0|	    goto exit_failure;
18274|      0|	}
18275|    321|    } else {
18276|    321|	int dummySequence = 0;
18277|    321|	xmlSchemaParticlePtr particle =
18278|    321|	    (xmlSchemaParticlePtr) type->subtypes;
18279|       |	/*
18280|       |	* Corresponds to <complexType><complexContent>...
18281|       |	*
18282|       |	* NOTE that the effective mixed was already set during parsing of
18283|       |	* <complexType> and <complexContent>; its flag value is
18284|       |	* XML_SCHEMAS_TYPE_MIXED.
18285|       |	*
18286|       |	* Compute the "effective content":
18287|       |	* (2.1.1) + (2.1.2) + (2.1.3)
18288|       |	*/
18289|    321|	if ((particle == NULL) ||
  ------------------
  |  Branch (18289:6): [True: 137, False: 184]
  ------------------
18290|    321|	    ((particle->type == XML_SCHEMA_TYPE_PARTICLE) &&
  ------------------
  |  Branch (18290:7): [True: 184, False: 0]
  ------------------
18291|    184|	    ((particle->children->type == XML_SCHEMA_TYPE_ALL) ||
  ------------------
  |  Branch (18291:7): [True: 9, False: 175]
  ------------------
18292|    184|	    (particle->children->type == XML_SCHEMA_TYPE_SEQUENCE) ||
  ------------------
  |  Branch (18292:6): [True: 156, False: 19]
  ------------------
18293|    184|	    ((particle->children->type == XML_SCHEMA_TYPE_CHOICE) &&
  ------------------
  |  Branch (18293:7): [True: 19, False: 0]
  ------------------
18294|     19|	    (particle->minOccurs == 0))) &&
  ------------------
  |  Branch (18294:6): [True: 11, False: 8]
  ------------------
18295|    184|	    ( ((xmlSchemaTreeItemPtr) particle->children)->children == NULL))) {
  ------------------
  |  Branch (18295:6): [True: 2, False: 174]
  ------------------
18296|    139|	    if (type->flags & XML_SCHEMAS_TYPE_MIXED) {
  ------------------
  |  |  408|    139|#define XML_SCHEMAS_TYPE_MIXED                1 << 0
  ------------------
  |  Branch (18296:10): [True: 8, False: 131]
  ------------------
18297|       |		/*
18298|       |		* SPEC (2.1.4) "If the `effective mixed` is true, then
18299|       |		* a particle whose properties are as follows:..."
18300|       |		*
18301|       |		* Empty sequence model group with
18302|       |		* minOccurs/maxOccurs = 1 (i.e. a "particle emptiable").
18303|       |		* NOTE that we sill assign it the <complexType> node to
18304|       |		* somehow anchor it in the doc.
18305|       |		*/
18306|      8|		if ((particle == NULL) ||
  ------------------
  |  Branch (18306:7): [True: 6, False: 2]
  ------------------
18307|      8|		    (particle->children->type != XML_SCHEMA_TYPE_SEQUENCE)) {
  ------------------
  |  Branch (18307:7): [True: 2, False: 0]
  ------------------
18308|       |		    /*
18309|       |		    * Create the particle.
18310|       |		    */
18311|      8|		    particle = xmlSchemaAddParticle(pctxt,
18312|      8|			type->node, 1, 1);
18313|      8|		    if (particle == NULL)
  ------------------
  |  Branch (18313:11): [True: 0, False: 8]
  ------------------
18314|      0|			goto exit_failure;
18315|       |		    /*
18316|       |		    * Create the model group.
18317|       |		    */ /* URGENT TODO: avoid adding to pending items. */
18318|      8|		    particle->children = (xmlSchemaTreeItemPtr)
18319|      8|			xmlSchemaAddModelGroup(pctxt, pctxt->schema,
18320|      8|			XML_SCHEMA_TYPE_SEQUENCE, type->node);
18321|      8|		    if (particle->children == NULL)
  ------------------
  |  Branch (18321:11): [True: 0, False: 8]
  ------------------
18322|      0|			goto exit_failure;
18323|       |
18324|      8|		    type->subtypes = (xmlSchemaTypePtr) particle;
18325|      8|		}
18326|      8|		dummySequence = 1;
18327|      8|		type->contentType = XML_SCHEMA_CONTENT_ELEMENTS;
18328|    131|	    } else {
18329|       |		/*
18330|       |		* SPEC (2.1.5) "otherwise empty"
18331|       |		*/
18332|    131|		type->contentType = XML_SCHEMA_CONTENT_EMPTY;
18333|    131|	    }
18334|    182|	} else {
18335|       |	    /*
18336|       |	    * SPEC (2.2) "otherwise the particle corresponding to the
18337|       |	    * <all>, <choice>, <group> or <sequence> among the
18338|       |	    * [children]."
18339|       |	    */
18340|    182|	    type->contentType = XML_SCHEMA_CONTENT_ELEMENTS;
18341|    182|	}
18342|       |	/*
18343|       |	* Compute the "content type".
18344|       |	*/
18345|    321|	if (WXS_IS_RESTRICTION(type)) {
  ------------------
  |  |  226|    321|    ((t)->flags & XML_SCHEMAS_TYPE_DERIVATION_METHOD_RESTRICTION)
  |  |  ------------------
  |  |  |  |  420|    321|#define XML_SCHEMAS_TYPE_DERIVATION_METHOD_RESTRICTION                1 << 2
  |  |  ------------------
  |  |  |  Branch (226:5): [True: 277, False: 44]
  |  |  ------------------
  ------------------
18346|       |	    /*
18347|       |	    * SPEC (3.1) "If <restriction>..."
18348|       |	    * (3.1.1) + (3.1.2) */
18349|    277|	    if (type->contentType != XML_SCHEMA_CONTENT_EMPTY) {
  ------------------
  |  Branch (18349:10): [True: 181, False: 96]
  ------------------
18350|    181|		if (type->flags & XML_SCHEMAS_TYPE_MIXED)
  ------------------
  |  |  408|    181|#define XML_SCHEMAS_TYPE_MIXED                1 << 0
  ------------------
  |  Branch (18350:7): [True: 10, False: 171]
  ------------------
18351|     10|		    type->contentType = XML_SCHEMA_CONTENT_MIXED;
18352|    181|	    }
18353|    277|	} else {
18354|       |	    /*
18355|       |	    * SPEC (3.2) "If <extension>..."
18356|       |	    */
18357|     44|	    if (type->contentType == XML_SCHEMA_CONTENT_EMPTY) {
  ------------------
  |  Branch (18357:10): [True: 35, False: 9]
  ------------------
18358|       |		/*
18359|       |		* SPEC (3.2.1)
18360|       |		* "If the `effective content` is empty, then the
18361|       |		*  {content type} of the [...] base ..."
18362|       |		*/
18363|     35|		type->contentType = baseType->contentType;
18364|     35|		type->subtypes = baseType->subtypes;
18365|       |		/*
18366|       |		* Fixes bug #347316:
18367|       |		* This is the case when the base type has a simple
18368|       |		* type definition as content.
18369|       |		*/
18370|     35|		type->contentTypeDef = baseType->contentTypeDef;
18371|       |		/*
18372|       |		* NOTE that the effective mixed is ignored here.
18373|       |		*/
18374|     35|	    } else if (baseType->contentType == XML_SCHEMA_CONTENT_EMPTY) {
  ------------------
  |  Branch (18374:17): [True: 6, False: 3]
  ------------------
18375|       |		/*
18376|       |		* SPEC (3.2.2)
18377|       |		*/
18378|      6|		if (type->flags & XML_SCHEMAS_TYPE_MIXED)
  ------------------
  |  |  408|      6|#define XML_SCHEMAS_TYPE_MIXED                1 << 0
  ------------------
  |  Branch (18378:7): [True: 0, False: 6]
  ------------------
18379|      0|		    type->contentType = XML_SCHEMA_CONTENT_MIXED;
18380|      6|	    } else {
18381|       |		/*
18382|       |		* SPEC (3.2.3)
18383|       |		*/
18384|      3|		if (type->flags & XML_SCHEMAS_TYPE_MIXED)
  ------------------
  |  |  408|      3|#define XML_SCHEMAS_TYPE_MIXED                1 << 0
  ------------------
  |  Branch (18384:7): [True: 0, False: 3]
  ------------------
18385|      0|		    type->contentType = XML_SCHEMA_CONTENT_MIXED;
18386|       |		    /*
18387|       |		    * "A model group whose {compositor} is sequence and whose
18388|       |		    * {particles} are..."
18389|       |		    */
18390|      3|		if ((WXS_TYPE_PARTICLE(type) != NULL) &&
  ------------------
  |  |  262|      3|#define WXS_TYPE_PARTICLE(t) WXS_PTC_CAST (t)->subtypes
  |  |  ------------------
  |  |  |  |  126|      3|#define WXS_PTC_CAST (xmlSchemaParticlePtr)
  |  |  ------------------
  ------------------
  |  Branch (18390:7): [True: 3, False: 0]
  ------------------
18391|      3|		    (WXS_TYPE_PARTICLE_TERM(type) != NULL) &&
  ------------------
  |  |  264|      3|#define WXS_TYPE_PARTICLE_TERM(t) WXS_PARTICLE_TERM(WXS_TYPE_PARTICLE(t))
  |  |  ------------------
  |  |  |  |  175|      3|#define WXS_PARTICLE_TERM(p) (WXS_PARTICLE(p))->children
  |  |  |  |  ------------------
  |  |  |  |  |  |  173|      3|#define WXS_PARTICLE(p) WXS_PTC_CAST (p)
  |  |  |  |  |  |  ------------------
  |  |  |  |  |  |  |  |  126|      3|#define WXS_PTC_CAST (xmlSchemaParticlePtr)
  |  |  |  |  |  |  ------------------
  |  |  |  |  ------------------
  |  |  ------------------
  ------------------
  |  Branch (18391:7): [True: 3, False: 0]
  ------------------
18392|      3|		    ((WXS_TYPE_PARTICLE_TERM(type))->type ==
  ------------------
  |  |  264|      3|#define WXS_TYPE_PARTICLE_TERM(t) WXS_PARTICLE_TERM(WXS_TYPE_PARTICLE(t))
  |  |  ------------------
  |  |  |  |  175|      3|#define WXS_PARTICLE_TERM(p) (WXS_PARTICLE(p))->children
  |  |  |  |  ------------------
  |  |  |  |  |  |  173|      3|#define WXS_PARTICLE(p) WXS_PTC_CAST (p)
  |  |  |  |  |  |  ------------------
  |  |  |  |  |  |  |  |  126|      3|#define WXS_PTC_CAST (xmlSchemaParticlePtr)
  |  |  |  |  |  |  ------------------
  |  |  |  |  ------------------
  |  |  ------------------
  ------------------
  |  Branch (18392:7): [True: 0, False: 3]
  ------------------
18393|      3|			XML_SCHEMA_TYPE_ALL))
18394|      0|		{
18395|       |		    /*
18396|       |		    * SPEC cos-all-limited (1)
18397|       |		    */
18398|      0|		    xmlSchemaCustomErr(ACTXT_CAST pctxt,
  ------------------
  |  |  121|      0|#define ACTXT_CAST (xmlSchemaAbstractCtxtPtr)
  ------------------
18399|       |			/* TODO: error code */
18400|      0|			XML_SCHEMAP_COS_ALL_LIMITED,
18401|      0|			WXS_ITEM_NODE(type), NULL,
  ------------------
  |  |  142|      0|#define WXS_ITEM_NODE(i) xmlSchemaGetComponentNode(WXS_BASIC_CAST (i))
  |  |  ------------------
  |  |  |  |  124|      0|#define WXS_BASIC_CAST (xmlSchemaBasicItemPtr)
  |  |  ------------------
  ------------------
18402|      0|			"The type has an 'all' model group in its "
18403|      0|			"{content type} and thus cannot be derived from "
18404|      0|			"a non-empty type, since this would produce a "
18405|      0|			"'sequence' model group containing the 'all' "
18406|      0|			"model group; 'all' model groups are not "
18407|      0|			"allowed to appear inside other model groups",
18408|      0|			NULL, NULL);
18409|       |
18410|      3|		} else if ((WXS_TYPE_PARTICLE(baseType) != NULL) &&
  ------------------
  |  |  262|      3|#define WXS_TYPE_PARTICLE(t) WXS_PTC_CAST (t)->subtypes
  |  |  ------------------
  |  |  |  |  126|      3|#define WXS_PTC_CAST (xmlSchemaParticlePtr)
  |  |  ------------------
  ------------------
  |  Branch (18410:14): [True: 2, False: 1]
  ------------------
18411|      3|		    (WXS_TYPE_PARTICLE_TERM(baseType) != NULL) &&
  ------------------
  |  |  264|      2|#define WXS_TYPE_PARTICLE_TERM(t) WXS_PARTICLE_TERM(WXS_TYPE_PARTICLE(t))
  |  |  ------------------
  |  |  |  |  175|      2|#define WXS_PARTICLE_TERM(p) (WXS_PARTICLE(p))->children
  |  |  |  |  ------------------
  |  |  |  |  |  |  173|      2|#define WXS_PARTICLE(p) WXS_PTC_CAST (p)
  |  |  |  |  |  |  ------------------
  |  |  |  |  |  |  |  |  126|      2|#define WXS_PTC_CAST (xmlSchemaParticlePtr)
  |  |  |  |  |  |  ------------------
  |  |  |  |  ------------------
  |  |  ------------------
  ------------------
  |  Branch (18411:7): [True: 2, False: 0]
  ------------------
18412|      3|		    ((WXS_TYPE_PARTICLE_TERM(baseType))->type ==
  ------------------
  |  |  264|      2|#define WXS_TYPE_PARTICLE_TERM(t) WXS_PARTICLE_TERM(WXS_TYPE_PARTICLE(t))
  |  |  ------------------
  |  |  |  |  175|      2|#define WXS_PARTICLE_TERM(p) (WXS_PARTICLE(p))->children
  |  |  |  |  ------------------
  |  |  |  |  |  |  173|      2|#define WXS_PARTICLE(p) WXS_PTC_CAST (p)
  |  |  |  |  |  |  ------------------
  |  |  |  |  |  |  |  |  126|      2|#define WXS_PTC_CAST (xmlSchemaParticlePtr)
  |  |  |  |  |  |  ------------------
  |  |  |  |  ------------------
  |  |  ------------------
  ------------------
  |  Branch (18412:7): [True: 0, False: 2]
  ------------------
18413|      2|			XML_SCHEMA_TYPE_ALL))
18414|      0|		{
18415|       |		    /*
18416|       |		    * SPEC cos-all-limited (1)
18417|       |		    */
18418|      0|		    xmlSchemaCustomErr(ACTXT_CAST pctxt,
  ------------------
  |  |  121|      0|#define ACTXT_CAST (xmlSchemaAbstractCtxtPtr)
  ------------------
18419|       |			/* TODO: error code */
18420|      0|			XML_SCHEMAP_COS_ALL_LIMITED,
18421|      0|			WXS_ITEM_NODE(type), NULL,
  ------------------
  |  |  142|      0|#define WXS_ITEM_NODE(i) xmlSchemaGetComponentNode(WXS_BASIC_CAST (i))
  |  |  ------------------
  |  |  |  |  124|      0|#define WXS_BASIC_CAST (xmlSchemaBasicItemPtr)
  |  |  ------------------
  ------------------
18422|      0|			"A type cannot be derived by extension from a type "
18423|      0|			"which has an 'all' model group in its "
18424|      0|			"{content type}, since this would produce a "
18425|      0|			"'sequence' model group containing the 'all' "
18426|      0|			"model group; 'all' model groups are not "
18427|      0|			"allowed to appear inside other model groups",
18428|      0|			NULL, NULL);
18429|       |
18430|      3|		} else if ((!dummySequence) && (baseType->subtypes != NULL)) {
  ------------------
  |  Branch (18430:14): [True: 3, False: 0]
  |  Branch (18430:34): [True: 2, False: 1]
  ------------------
18431|      2|		    xmlSchemaTreeItemPtr effectiveContent =
18432|      2|			(xmlSchemaTreeItemPtr) type->subtypes;
18433|       |		    /*
18434|       |		    * Create the particle.
18435|       |		    */
18436|      2|		    particle = xmlSchemaAddParticle(pctxt,
18437|      2|			type->node, 1, 1);
18438|      2|		    if (particle == NULL)
  ------------------
  |  Branch (18438:11): [True: 0, False: 2]
  ------------------
18439|      0|			goto exit_failure;
18440|       |		    /*
18441|       |		    * Create the "sequence" model group.
18442|       |		    */
18443|      2|		    particle->children = (xmlSchemaTreeItemPtr)
18444|      2|			xmlSchemaAddModelGroup(pctxt, pctxt->schema,
18445|      2|			XML_SCHEMA_TYPE_SEQUENCE, type->node);
18446|      2|		    if (particle->children == NULL)
  ------------------
  |  Branch (18446:11): [True: 0, False: 2]
  ------------------
18447|      0|			goto exit_failure;
18448|      2|		    WXS_TYPE_CONTENTTYPE(type) = (xmlSchemaTypePtr) particle;
  ------------------
  |  |  260|      2|#define WXS_TYPE_CONTENTTYPE(t) (t)->subtypes
  ------------------
18449|       |		    /*
18450|       |		    * SPEC "the particle of the {content type} of
18451|       |		    * the ... base ..."
18452|       |		    * Create a duplicate of the base type's particle
18453|       |		    * and assign its "term" to it.
18454|       |		    */
18455|      2|		    particle->children->children =
18456|      2|			(xmlSchemaTreeItemPtr) xmlSchemaAddParticle(pctxt,
18457|      2|			type->node,
18458|      2|			((xmlSchemaParticlePtr) baseType->subtypes)->minOccurs,
18459|      2|			((xmlSchemaParticlePtr) baseType->subtypes)->maxOccurs);
18460|      2|		    if (particle->children->children == NULL)
  ------------------
  |  Branch (18460:11): [True: 0, False: 2]
  ------------------
18461|      0|			goto exit_failure;
18462|      2|		    particle = (xmlSchemaParticlePtr)
18463|      2|			particle->children->children;
18464|      2|		    particle->children =
18465|      2|			((xmlSchemaParticlePtr) baseType->subtypes)->children;
18466|       |		    /*
18467|       |		    * SPEC "followed by the `effective content`."
18468|       |		    */
18469|      2|		    particle->next = effectiveContent;
18470|       |		    /*
18471|       |		    * This all will result in:
18472|       |		    * new-particle
18473|       |		    *   --> new-sequence(
18474|       |		    *         new-particle
18475|       |		    *           --> base-model,
18476|       |		    *         this-particle
18477|       |		    *	        --> this-model
18478|       |		    *	    )
18479|       |		    */
18480|      2|		} else {
18481|       |		    /*
18482|       |		    * This is the case when there is already an empty
18483|       |		    * <sequence> with minOccurs==maxOccurs==1.
18484|       |		    * Just add the base types's content type.
18485|       |		    * NOTE that, although we miss to add an intermediate
18486|       |		    * <sequence>, this should produce no difference to
18487|       |		    * neither the regex compilation of the content model,
18488|       |		    * nor to the complex type constraints.
18489|       |		    */
18490|      1|		    particle->children->children =
18491|      1|			(xmlSchemaTreeItemPtr) baseType->subtypes;
18492|      1|		}
18493|      3|	    }
18494|     44|	}
18495|    321|    }
18496|       |    /*
18497|       |    * Now fixup attribute uses:
18498|       |    *   - expand attr. group references
18499|       |    *     - intersect attribute wildcards
18500|       |    *   - inherit attribute uses of the base type
18501|       |    *   - inherit or union attr. wildcards if extending
18502|       |    *   - apply attr. use prohibitions if restricting
18503|       |    */
18504|    361|    res = xmlSchemaFixupTypeAttributeUses(pctxt, type);
18505|    361|    HFAILURE HERROR
  ------------------
  |  |  333|    361|#define HFAILURE if (res == -1) goto exit_failure;
  |  |  ------------------
  |  |  |  Branch (333:22): [True: 0, False: 361]
  |  |  ------------------
  ------------------
                  HFAILURE HERROR
  ------------------
  |  |  335|    361|#define HERROR if (res != 0) goto exit_error;
  |  |  ------------------
  |  |  |  Branch (335:20): [True: 0, False: 361]
  |  |  ------------------
  ------------------
18506|       |    /*
18507|       |    * Apply the complex type component constraints; this will not
18508|       |    * check attributes, since this is done in
18509|       |    * xmlSchemaFixupTypeAttributeUses().
18510|       |    */
18511|    361|    res = xmlSchemaCheckCTComponent(pctxt, type);
18512|    361|    HFAILURE HERROR
  ------------------
  |  |  333|    361|#define HFAILURE if (res == -1) goto exit_failure;
  |  |  ------------------
  |  |  |  Branch (333:22): [True: 0, False: 361]
  |  |  ------------------
  ------------------
                  HFAILURE HERROR
  ------------------
  |  |  335|    361|#define HERROR if (res != 0) goto exit_error;
  |  |  ------------------
  |  |  |  Branch (335:20): [True: 1, False: 360]
  |  |  ------------------
  ------------------
18513|       |
18514|    360|    if (olderrs != pctxt->nberrors)
  ------------------
  |  Branch (18514:9): [True: 6, False: 354]
  ------------------
18515|      6|	return(pctxt->err);
18516|    354|    else
18517|    354|	return(0);
18518|       |
18519|      1|exit_error:
18520|      1|    type->flags |= XML_SCHEMAS_TYPE_INTERNAL_INVALID;
  ------------------
  |  |  545|      1|#define XML_SCHEMAS_TYPE_INTERNAL_INVALID    1 << 23
  ------------------
18521|      1|    return(pctxt->err);
18522|       |
18523|      0|exit_failure:
18524|      0|    type->flags |= XML_SCHEMAS_TYPE_INTERNAL_INVALID;
  ------------------
  |  |  545|      0|#define XML_SCHEMAS_TYPE_INTERNAL_INVALID    1 << 23
  ------------------
18525|      0|    return(-1);
18526|    360|}
xmlschemas.c:xmlSchemaCheckSRCCT:
16617|    361|{
16618|    361|    xmlSchemaTypePtr base;
16619|    361|    int ret = 0;
16620|       |
16621|       |    /*
16622|       |    * TODO: Adjust the error codes here, as I used
16623|       |    * XML_SCHEMAP_SRC_CT_1 only yet.
16624|       |    */
16625|    361|    base = type->baseType;
16626|    361|    if (! WXS_HAS_SIMPLE_CONTENT(type)) {
  ------------------
  |  |  251|    361|    ((item->contentType == XML_SCHEMA_CONTENT_SIMPLE) || \
  |  |  ------------------
  |  |  |  Branch (251:6): [True: 40, False: 321]
  |  |  ------------------
  |  |  252|    361|     (item->contentType == XML_SCHEMA_CONTENT_BASIC))
  |  |  ------------------
  |  |  |  Branch (252:6): [True: 0, False: 321]
  |  |  ------------------
  ------------------
16627|       |	/*
16628|       |	* 1 If the <complexContent> alternative is chosen, the type definition
16629|       |	* `resolved` to by the `actual value` of the base [attribute]
16630|       |	* must be a complex type definition;
16631|       |	*/
16632|    321|	if (! WXS_IS_COMPLEX(base)) {
  ------------------
  |  |  213|    321|    (((i)->type == XML_SCHEMA_TYPE_COMPLEX) || \
  |  |  ------------------
  |  |  |  Branch (213:6): [True: 55, False: 266]
  |  |  ------------------
  |  |  214|    321|     ((i)->builtInType == XML_SCHEMAS_ANYTYPE))
  |  |  ------------------
  |  |  |  Branch (214:6): [True: 266, False: 0]
  |  |  ------------------
  ------------------
16633|      0|	    xmlChar *str = NULL;
16634|      0|	    xmlSchemaPCustomErr(ctxt,
16635|      0|		XML_SCHEMAP_SRC_CT_1,
16636|      0|		WXS_BASIC_CAST type, type->node,
  ------------------
  |  |  124|      0|#define WXS_BASIC_CAST (xmlSchemaBasicItemPtr)
  ------------------
16637|      0|		"If using <complexContent>, the base type is expected to be "
16638|      0|		"a complex type. The base type '%s' is a simple type",
16639|      0|		xmlSchemaFormatQName(&str, base->targetNamespace,
16640|      0|		base->name));
16641|      0|	    FREE_AND_NULL(str)
  ------------------
  |  |  320|      0|#define FREE_AND_NULL(str) if ((str) != NULL) { xmlFree((xmlChar *) (str)); str = NULL; }
  |  |  ------------------
  |  |  |  Branch (320:32): [True: 0, False: 0]
  |  |  ------------------
  ------------------
16642|      0|	    return (XML_SCHEMAP_SRC_CT_1);
16643|      0|	}
16644|    321|    } else {
16645|       |	/*
16646|       |	* SPEC
16647|       |	* 2 If the <simpleContent> alternative is chosen, all of the
16648|       |	* following must be true:
16649|       |	* 2.1 The type definition `resolved` to by the `actual value` of the
16650|       |	* base [attribute] must be one of the following:
16651|       |	*/
16652|     40|	if (WXS_IS_SIMPLE(base)) {
  ------------------
  |  |  217|     40|    ((item->type == XML_SCHEMA_TYPE_SIMPLE) || \
  |  |  ------------------
  |  |  |  Branch (217:6): [True: 13, False: 27]
  |  |  ------------------
  |  |  218|     40|     ((item->type == XML_SCHEMA_TYPE_BASIC) && \
  |  |  ------------------
  |  |  |  Branch (218:7): [True: 25, False: 2]
  |  |  ------------------
  |  |  219|     27|      (item->builtInType != XML_SCHEMAS_ANYTYPE)))
  |  |  ------------------
  |  |  |  Branch (219:7): [True: 19, False: 6]
  |  |  ------------------
  ------------------
16653|     32|	    if (WXS_IS_EXTENSION(type) == 0) {
  ------------------
  |  |  229|     32|    ((t)->flags & XML_SCHEMAS_TYPE_DERIVATION_METHOD_EXTENSION)
  |  |  ------------------
  |  |  |  |  414|     32|#define XML_SCHEMAS_TYPE_DERIVATION_METHOD_EXTENSION                1 << 1
  |  |  ------------------
  ------------------
  |  Branch (16653:10): [True: 0, False: 32]
  ------------------
16654|      0|		xmlChar *str = NULL;
16655|       |		/*
16656|       |		* 2.1.3 only if the <extension> alternative is also
16657|       |		* chosen, a simple type definition.
16658|       |		*/
16659|       |		/* TODO: Change error code to ..._SRC_CT_2_1_3. */
16660|      0|		xmlSchemaPCustomErr(ctxt,
16661|      0|		    XML_SCHEMAP_SRC_CT_1,
16662|      0|		    WXS_BASIC_CAST type, NULL,
  ------------------
  |  |  124|      0|#define WXS_BASIC_CAST (xmlSchemaBasicItemPtr)
  ------------------
16663|      0|		    "If using <simpleContent> and <restriction>, the base "
16664|      0|		    "type must be a complex type. The base type '%s' is "
16665|      0|		    "a simple type",
16666|      0|		    xmlSchemaFormatQName(&str, base->targetNamespace,
16667|      0|			base->name));
16668|      0|		FREE_AND_NULL(str)
  ------------------
  |  |  320|      0|#define FREE_AND_NULL(str) if ((str) != NULL) { xmlFree((xmlChar *) (str)); str = NULL; }
  |  |  ------------------
  |  |  |  Branch (320:32): [True: 0, False: 0]
  |  |  ------------------
  ------------------
16669|      0|		return (XML_SCHEMAP_SRC_CT_1);
16670|      0|	    }
16671|     32|	} else {
16672|       |	    /* Base type is a complex type. */
16673|      8|	    if ((base->contentType == XML_SCHEMA_CONTENT_SIMPLE) ||
  ------------------
  |  Branch (16673:10): [True: 2, False: 6]
  ------------------
16674|      8|		(base->contentType == XML_SCHEMA_CONTENT_BASIC)) {
  ------------------
  |  Branch (16674:3): [True: 0, False: 6]
  ------------------
16675|       |		/*
16676|       |		* 2.1.1 a complex type definition whose {content type} is a
16677|       |		* simple type definition;
16678|       |		* PASS
16679|       |		*/
16680|      2|		if (base->contentTypeDef == NULL) {
  ------------------
  |  Branch (16680:7): [True: 0, False: 2]
  ------------------
16681|      0|		    xmlSchemaPCustomErr(ctxt, XML_SCHEMAP_INTERNAL,
16682|      0|			WXS_BASIC_CAST type, NULL,
  ------------------
  |  |  124|      0|#define WXS_BASIC_CAST (xmlSchemaBasicItemPtr)
  ------------------
16683|      0|			"Internal error: xmlSchemaCheckSRCCT, "
16684|      0|			"'%s', base type has no content type",
16685|      0|			type->name);
16686|      0|		    return (-1);
16687|      0|		}
16688|      6|	    } else if ((base->contentType == XML_SCHEMA_CONTENT_MIXED) &&
  ------------------
  |  Branch (16688:17): [True: 6, False: 0]
  ------------------
16689|      6|		(WXS_IS_RESTRICTION(type))) {
  ------------------
  |  |  226|      6|    ((t)->flags & XML_SCHEMAS_TYPE_DERIVATION_METHOD_RESTRICTION)
  |  |  ------------------
  |  |  |  |  420|      6|#define XML_SCHEMAS_TYPE_DERIVATION_METHOD_RESTRICTION                1 << 2
  |  |  ------------------
  ------------------
  |  Branch (16689:3): [True: 6, False: 0]
  ------------------
16690|       |
16691|       |		/*
16692|       |		* 2.1.2 only if the <restriction> alternative is also
16693|       |		* chosen, a complex type definition whose {content type}
16694|       |		* is mixed and a particle emptiable.
16695|       |		*/
16696|      6|		if (! xmlSchemaIsParticleEmptiable(
  ------------------
  |  Branch (16696:7): [True: 0, False: 6]
  ------------------
16697|      6|		    (xmlSchemaParticlePtr) base->subtypes)) {
16698|      0|		    ret = XML_SCHEMAP_SRC_CT_1;
16699|      0|		} else
16700|       |		    /*
16701|       |		    * Attention: at this point the <simpleType> child is in
16702|       |		    * ->contentTypeDef (put there during parsing).
16703|       |		    */
16704|      6|		    if (type->contentTypeDef == NULL) {
  ------------------
  |  Branch (16704:11): [True: 0, False: 6]
  ------------------
16705|      0|		    xmlChar *str = NULL;
16706|       |		    /*
16707|       |		    * 2.2 If clause 2.1.2 above is satisfied, then there
16708|       |		    * must be a <simpleType> among the [children] of
16709|       |		    * <restriction>.
16710|       |		    */
16711|       |		    /* TODO: Change error code to ..._SRC_CT_2_2. */
16712|      0|		    xmlSchemaPCustomErr(ctxt,
16713|      0|			XML_SCHEMAP_SRC_CT_1,
16714|      0|			WXS_BASIC_CAST type, NULL,
  ------------------
  |  |  124|      0|#define WXS_BASIC_CAST (xmlSchemaBasicItemPtr)
  ------------------
16715|      0|			"A <simpleType> is expected among the children "
16716|      0|			"of <restriction>, if <simpleContent> is used and "
16717|      0|			"the base type '%s' is a complex type",
16718|      0|			xmlSchemaFormatQName(&str, base->targetNamespace,
16719|      0|			base->name));
16720|      0|		    FREE_AND_NULL(str)
  ------------------
  |  |  320|      0|#define FREE_AND_NULL(str) if ((str) != NULL) { xmlFree((xmlChar *) (str)); str = NULL; }
  |  |  ------------------
  |  |  |  Branch (320:32): [True: 0, False: 0]
  |  |  ------------------
  ------------------
16721|      0|		    return (XML_SCHEMAP_SRC_CT_1);
16722|      0|		}
16723|      6|	    } else {
16724|      0|		ret = XML_SCHEMAP_SRC_CT_1;
16725|      0|	    }
16726|      8|	}
16727|     40|	if (ret > 0) {
  ------------------
  |  Branch (16727:6): [True: 0, False: 40]
  ------------------
16728|      0|	    xmlChar *str = NULL;
16729|      0|	    if (WXS_IS_RESTRICTION(type)) {
  ------------------
  |  |  226|      0|    ((t)->flags & XML_SCHEMAS_TYPE_DERIVATION_METHOD_RESTRICTION)
  |  |  ------------------
  |  |  |  |  420|      0|#define XML_SCHEMAS_TYPE_DERIVATION_METHOD_RESTRICTION                1 << 2
  |  |  ------------------
  |  |  |  Branch (226:5): [True: 0, False: 0]
  |  |  ------------------
  ------------------
16730|      0|		xmlSchemaPCustomErr(ctxt,
16731|      0|		    XML_SCHEMAP_SRC_CT_1,
16732|      0|		    WXS_BASIC_CAST type, NULL,
  ------------------
  |  |  124|      0|#define WXS_BASIC_CAST (xmlSchemaBasicItemPtr)
  ------------------
16733|      0|		    "If <simpleContent> and <restriction> is used, the "
16734|      0|		    "base type must be a simple type or a complex type with "
16735|      0|		    "mixed content and particle emptiable. The base type "
16736|      0|		    "'%s' is none of those",
16737|      0|		    xmlSchemaFormatQName(&str, base->targetNamespace,
16738|      0|		    base->name));
16739|      0|	    } else {
16740|      0|		xmlSchemaPCustomErr(ctxt,
16741|      0|		    XML_SCHEMAP_SRC_CT_1,
16742|      0|		    WXS_BASIC_CAST type, NULL,
  ------------------
  |  |  124|      0|#define WXS_BASIC_CAST (xmlSchemaBasicItemPtr)
  ------------------
16743|      0|		    "If <simpleContent> and <extension> is used, the "
16744|      0|		    "base type must be a simple type. The base type '%s' "
16745|      0|		    "is a complex type",
16746|      0|		    xmlSchemaFormatQName(&str, base->targetNamespace,
16747|      0|		    base->name));
16748|      0|	    }
16749|      0|	    FREE_AND_NULL(str)
  ------------------
  |  |  320|      0|#define FREE_AND_NULL(str) if ((str) != NULL) { xmlFree((xmlChar *) (str)); str = NULL; }
  |  |  ------------------
  |  |  |  Branch (320:32): [True: 0, False: 0]
  |  |  ------------------
  ------------------
16750|      0|	}
16751|     40|    }
16752|       |    /*
16753|       |    * SPEC (3) "The corresponding complex type definition component must
16754|       |    * satisfy the conditions set out in Constraints on Complex Type
16755|       |    * Definition Schema Components ($3.4.6);"
16756|       |    * NOTE (3) will be done in xmlSchemaTypeFixup().
16757|       |    */
16758|       |    /*
16759|       |    * SPEC (4) If clause 2.2.1 or clause 2.2.2 in the correspondence specification
16760|       |    * above for {attribute wildcard} is satisfied, the intensional
16761|       |    * intersection must be expressible, as defined in Attribute Wildcard
16762|       |    * Intersection ($3.10.6).
16763|       |    * NOTE (4) is done in xmlSchemaFixupTypeAttributeUses().
16764|       |    */
16765|    361|    return (ret);
16766|    361|}
xmlschemas.c:xmlSchemaIsParticleEmptiable:
14778|      6|{
14779|       |    /*
14780|       |    * SPEC (1) "Its {min occurs} is 0."
14781|       |    */
14782|      6|    if ((particle == NULL) || (particle->minOccurs == 0) ||
  ------------------
  |  Branch (14782:9): [True: 0, False: 6]
  |  Branch (14782:31): [True: 0, False: 6]
  ------------------
14783|      6|	(particle->children == NULL))
  ------------------
  |  Branch (14783:2): [True: 0, False: 6]
  ------------------
14784|      0|	return (1);
14785|       |    /*
14786|       |    * SPEC (2) "Its {term} is a group and the minimum part of the
14787|       |    * effective total range of that group, [...] is 0."
14788|       |    */
14789|      6|    if (WXS_IS_MODEL_GROUP(particle->children))
  ------------------
  |  |  188|      6|    (((i)->type == XML_SCHEMA_TYPE_SEQUENCE) || \
  |  |  ------------------
  |  |  |  Branch (188:6): [True: 6, False: 0]
  |  |  ------------------
  |  |  189|      6|     ((i)->type == XML_SCHEMA_TYPE_CHOICE) || \
  |  |  ------------------
  |  |  |  Branch (189:6): [True: 0, False: 0]
  |  |  ------------------
  |  |  190|      6|     ((i)->type == XML_SCHEMA_TYPE_ALL))
  |  |  ------------------
  |  |  |  Branch (190:6): [True: 0, False: 0]
  |  |  ------------------
  ------------------
14790|      6|	return (xmlSchemaGetParticleEmptiable(particle));
14791|      0|    return (0);
14792|      6|}
xmlschemas.c:xmlSchemaGetParticleEmptiable:
14733|      6|{
14734|      6|    xmlSchemaParticlePtr part;
14735|      6|    int emptiable;
14736|       |
14737|      6|    if ((particle->children == NULL) || (particle->minOccurs == 0))
  ------------------
  |  Branch (14737:9): [True: 0, False: 6]
  |  Branch (14737:41): [True: 0, False: 6]
  ------------------
14738|      0|	return (1);
14739|       |
14740|      6|    part = (xmlSchemaParticlePtr) particle->children->children;
14741|      6|    if (part == NULL)
  ------------------
  |  Branch (14741:9): [True: 0, False: 6]
  ------------------
14742|      0|        return (1);
14743|       |
14744|     12|    while (part != NULL) {
  ------------------
  |  Branch (14744:12): [True: 6, False: 6]
  ------------------
14745|      6|        if ((part->children->type == XML_SCHEMA_TYPE_ELEMENT) ||
  ------------------
  |  Branch (14745:13): [True: 0, False: 6]
  ------------------
14746|      6|            (part->children->type == XML_SCHEMA_TYPE_ANY))
  ------------------
  |  Branch (14746:13): [True: 6, False: 0]
  ------------------
14747|      6|            emptiable = (part->minOccurs == 0);
14748|      0|        else
14749|      0|            emptiable = xmlSchemaGetParticleEmptiable(part);
14750|      6|        if (particle->children->type == XML_SCHEMA_TYPE_CHOICE) {
  ------------------
  |  Branch (14750:13): [True: 0, False: 6]
  ------------------
14751|      0|            if (emptiable)
  ------------------
  |  Branch (14751:17): [True: 0, False: 0]
  ------------------
14752|      0|                return (1);
14753|      6|        } else {
14754|       |	    /* <all> and <sequence> */
14755|      6|            if (!emptiable)
  ------------------
  |  Branch (14755:17): [True: 0, False: 6]
  ------------------
14756|      0|                return (0);
14757|      6|        }
14758|      6|        part = (xmlSchemaParticlePtr) part->next;
14759|      6|    }
14760|       |
14761|      6|    if (particle->children->type == XML_SCHEMA_TYPE_CHOICE)
  ------------------
  |  Branch (14761:9): [True: 0, False: 6]
  ------------------
14762|      0|        return (0);
14763|      6|    else
14764|      6|        return (1);
14765|      6|}
xmlschemas.c:xmlSchemaFixupTypeAttributeUses:
14381|    361|{
14382|    361|    xmlSchemaTypePtr baseType = NULL;
14383|    361|    xmlSchemaAttributeUsePtr use;
14384|    361|    xmlSchemaItemListPtr uses, baseUses, prohibs = NULL;
14385|       |
14386|    361|    if (type->baseType == NULL) {
  ------------------
  |  Branch (14386:9): [True: 0, False: 361]
  ------------------
14387|      0|	PERROR_INT("xmlSchemaFixupTypeAttributeUses",
  ------------------
  |  | 2824|      0|#define PERROR_INT(func, msg) xmlSchemaInternalErr(ACTXT_CAST pctxt, func, msg);
  |  |  ------------------
  |  |  |  |  121|      0|#define ACTXT_CAST (xmlSchemaAbstractCtxtPtr)
  |  |  ------------------
  ------------------
14388|      0|	    "no base type");
14389|      0|        return (-1);
14390|      0|    }
14391|    361|    baseType = type->baseType;
14392|    361|    if (WXS_IS_TYPE_NOT_FIXED(baseType))
  ------------------
  |  |  232|    361|    (((i)->type != XML_SCHEMA_TYPE_BASIC) && \
  |  |  ------------------
  |  |  |  Branch (232:6): [True: 70, False: 291]
  |  |  ------------------
  |  |  233|    361|     (((i)->flags & XML_SCHEMAS_TYPE_INTERNAL_RESOLVED) == 0))
  |  |  ------------------
  |  |  |  |  539|     70|#define XML_SCHEMAS_TYPE_INTERNAL_RESOLVED    1 << 22
  |  |  ------------------
  |  |  |  Branch (233:6): [True: 0, False: 70]
  |  |  ------------------
  ------------------
14393|      0|	if (xmlSchemaTypeFixup(baseType, ACTXT_CAST pctxt) == -1)
  ------------------
  |  |  121|      0|#define ACTXT_CAST (xmlSchemaAbstractCtxtPtr)
  ------------------
  |  Branch (14393:6): [True: 0, False: 0]
  ------------------
14394|      0|	    return(-1);
14395|       |
14396|    361|    uses = type->attrUses;
14397|    361|    baseUses = baseType->attrUses;
14398|       |    /*
14399|       |    * Expand attribute group references. And build the 'complete'
14400|       |    * wildcard, i.e. intersect multiple wildcards.
14401|       |    * Move attribute prohibitions into a separate list.
14402|       |    */
14403|    361|    if (uses != NULL) {
  ------------------
  |  Branch (14403:9): [True: 154, False: 207]
  ------------------
14404|    154|	if (WXS_IS_RESTRICTION(type)) {
  ------------------
  |  |  226|    154|    ((t)->flags & XML_SCHEMAS_TYPE_DERIVATION_METHOD_RESTRICTION)
  |  |  ------------------
  |  |  |  |  420|    154|#define XML_SCHEMAS_TYPE_DERIVATION_METHOD_RESTRICTION                1 << 2
  |  |  ------------------
  |  |  |  Branch (226:5): [True: 118, False: 36]
  |  |  ------------------
  ------------------
14405|       |	    /*
14406|       |	    * This one will transfer all attr. prohibitions
14407|       |	    * into pctxt->attrProhibs.
14408|       |	    */
14409|    118|	    if (xmlSchemaExpandAttributeGroupRefs(pctxt,
  ------------------
  |  Branch (14409:10): [True: 0, False: 118]
  ------------------
14410|    118|		WXS_BASIC_CAST type, &(type->attributeWildcard), uses,
  ------------------
  |  |  124|    118|#define WXS_BASIC_CAST (xmlSchemaBasicItemPtr)
  ------------------
14411|    118|		pctxt->attrProhibs) == -1)
14412|      0|	    {
14413|      0|		PERROR_INT("xmlSchemaFixupTypeAttributeUses",
  ------------------
  |  | 2824|      0|#define PERROR_INT(func, msg) xmlSchemaInternalErr(ACTXT_CAST pctxt, func, msg);
  |  |  ------------------
  |  |  |  |  121|      0|#define ACTXT_CAST (xmlSchemaAbstractCtxtPtr)
  |  |  ------------------
  ------------------
14414|      0|		"failed to expand attributes");
14415|      0|                return(-1);
14416|      0|	    }
14417|    118|	    if (pctxt->attrProhibs->nbItems != 0)
  ------------------
  |  Branch (14417:10): [True: 3, False: 115]
  ------------------
14418|      3|		prohibs = pctxt->attrProhibs;
14419|    118|	} else {
14420|     36|	    if (xmlSchemaExpandAttributeGroupRefs(pctxt,
  ------------------
  |  Branch (14420:10): [True: 0, False: 36]
  ------------------
14421|     36|		WXS_BASIC_CAST type, &(type->attributeWildcard), uses,
  ------------------
  |  |  124|     36|#define WXS_BASIC_CAST (xmlSchemaBasicItemPtr)
  ------------------
14422|     36|		NULL) == -1)
14423|      0|	    {
14424|      0|		PERROR_INT("xmlSchemaFixupTypeAttributeUses",
  ------------------
  |  | 2824|      0|#define PERROR_INT(func, msg) xmlSchemaInternalErr(ACTXT_CAST pctxt, func, msg);
  |  |  ------------------
  |  |  |  |  121|      0|#define ACTXT_CAST (xmlSchemaAbstractCtxtPtr)
  |  |  ------------------
  ------------------
14425|      0|		"failed to expand attributes");
14426|      0|                return(-1);
14427|      0|	    }
14428|     36|	}
14429|    154|    }
14430|       |    /*
14431|       |    * Inherit the attribute uses of the base type.
14432|       |    */
14433|    361|    if (baseUses != NULL) {
  ------------------
  |  Branch (14433:9): [True: 18, False: 343]
  ------------------
14434|     18|	int i, j;
14435|     18|	xmlSchemaAttributeUseProhibPtr pro;
14436|       |
14437|     18|	if (WXS_IS_RESTRICTION(type)) {
  ------------------
  |  |  226|     18|    ((t)->flags & XML_SCHEMAS_TYPE_DERIVATION_METHOD_RESTRICTION)
  |  |  ------------------
  |  |  |  |  420|     18|#define XML_SCHEMAS_TYPE_DERIVATION_METHOD_RESTRICTION                1 << 2
  |  |  ------------------
  |  |  |  Branch (226:5): [True: 10, False: 8]
  |  |  ------------------
  ------------------
14438|     10|	    int usesCount;
14439|     10|	    xmlSchemaAttributeUsePtr tmp;
14440|       |
14441|     10|	    if (uses != NULL)
  ------------------
  |  Branch (14441:10): [True: 9, False: 1]
  ------------------
14442|      9|		usesCount = uses->nbItems;
14443|      1|	    else
14444|      1|		usesCount = 0;
14445|       |
14446|       |	    /* Restriction. */
14447|     27|	    for (i = 0; i < baseUses->nbItems; i++) {
  ------------------
  |  Branch (14447:18): [True: 17, False: 10]
  ------------------
14448|     17|		use = baseUses->items[i];
14449|     17|		if (prohibs) {
  ------------------
  |  Branch (14449:7): [True: 6, False: 11]
  ------------------
14450|       |		    /*
14451|       |		    * Filter out prohibited uses.
14452|       |		    */
14453|     23|		    for (j = 0; j < prohibs->nbItems; j++) {
  ------------------
  |  Branch (14453:19): [True: 19, False: 4]
  ------------------
14454|     19|			pro = prohibs->items[j];
14455|     19|			if ((WXS_ATTRUSE_DECL_NAME(use) == pro->name) &&
  ------------------
  |  |  162|     19|#define WXS_ATTRUSE_DECL_NAME(au) (WXS_ATTRUSE_DECL(au))->name
  |  |  ------------------
  |  |  |  |  158|     19|#define WXS_ATTRUSE_DECL(au) (WXS_ATTR_USE_CAST (au))->attrDecl
  |  |  |  |  ------------------
  |  |  |  |  |  |  131|     19|#define WXS_ATTR_USE_CAST (xmlSchemaAttributeUsePtr)
  |  |  |  |  ------------------
  |  |  ------------------
  ------------------
  |  Branch (14455:8): [True: 2, False: 17]
  ------------------
14456|     19|			    (WXS_ATTRUSE_DECL_TNS(use) ==
  ------------------
  |  |  164|      2|#define WXS_ATTRUSE_DECL_TNS(au) (WXS_ATTRUSE_DECL(au))->targetNamespace
  |  |  ------------------
  |  |  |  |  158|      2|#define WXS_ATTRUSE_DECL(au) (WXS_ATTR_USE_CAST (au))->attrDecl
  |  |  |  |  ------------------
  |  |  |  |  |  |  131|      2|#define WXS_ATTR_USE_CAST (xmlSchemaAttributeUsePtr)
  |  |  |  |  ------------------
  |  |  ------------------
  ------------------
  |  Branch (14456:8): [True: 2, False: 0]
  ------------------
14457|      2|				pro->targetNamespace))
14458|      2|			{
14459|      2|			    goto inherit_next;
14460|      2|			}
14461|     19|		    }
14462|      6|		}
14463|     15|		if (usesCount) {
  ------------------
  |  Branch (14463:7): [True: 14, False: 1]
  ------------------
14464|       |		    /*
14465|       |		    * Filter out existing uses.
14466|       |		    */
14467|     22|		    for (j = 0; j < usesCount; j++) {
  ------------------
  |  Branch (14467:19): [True: 22, False: 0]
  ------------------
14468|     22|			tmp = uses->items[j];
14469|     22|			if ((WXS_ATTRUSE_DECL_NAME(use) ==
  ------------------
  |  |  162|     22|#define WXS_ATTRUSE_DECL_NAME(au) (WXS_ATTRUSE_DECL(au))->name
  |  |  ------------------
  |  |  |  |  158|     22|#define WXS_ATTRUSE_DECL(au) (WXS_ATTR_USE_CAST (au))->attrDecl
  |  |  |  |  ------------------
  |  |  |  |  |  |  131|     22|#define WXS_ATTR_USE_CAST (xmlSchemaAttributeUsePtr)
  |  |  |  |  ------------------
  |  |  ------------------
  ------------------
  |  Branch (14469:8): [True: 14, False: 8]
  ------------------
14470|     22|				WXS_ATTRUSE_DECL_NAME(tmp)) &&
  ------------------
  |  |  162|     22|#define WXS_ATTRUSE_DECL_NAME(au) (WXS_ATTRUSE_DECL(au))->name
  |  |  ------------------
  |  |  |  |  158|     22|#define WXS_ATTRUSE_DECL(au) (WXS_ATTR_USE_CAST (au))->attrDecl
  |  |  |  |  ------------------
  |  |  |  |  |  |  131|     22|#define WXS_ATTR_USE_CAST (xmlSchemaAttributeUsePtr)
  |  |  |  |  ------------------
  |  |  ------------------
  ------------------
14471|     22|			    (WXS_ATTRUSE_DECL_TNS(use) ==
  ------------------
  |  |  164|     14|#define WXS_ATTRUSE_DECL_TNS(au) (WXS_ATTRUSE_DECL(au))->targetNamespace
  |  |  ------------------
  |  |  |  |  158|     14|#define WXS_ATTRUSE_DECL(au) (WXS_ATTR_USE_CAST (au))->attrDecl
  |  |  |  |  ------------------
  |  |  |  |  |  |  131|     14|#define WXS_ATTR_USE_CAST (xmlSchemaAttributeUsePtr)
  |  |  |  |  ------------------
  |  |  ------------------
  ------------------
  |  Branch (14471:8): [True: 14, False: 0]
  ------------------
14472|     14|				WXS_ATTRUSE_DECL_TNS(tmp)))
  ------------------
  |  |  164|     14|#define WXS_ATTRUSE_DECL_TNS(au) (WXS_ATTRUSE_DECL(au))->targetNamespace
  |  |  ------------------
  |  |  |  |  158|     14|#define WXS_ATTRUSE_DECL(au) (WXS_ATTR_USE_CAST (au))->attrDecl
  |  |  |  |  ------------------
  |  |  |  |  |  |  131|     14|#define WXS_ATTR_USE_CAST (xmlSchemaAttributeUsePtr)
  |  |  |  |  ------------------
  |  |  ------------------
  ------------------
14473|     14|			{
14474|     14|			    goto inherit_next;
14475|     14|			}
14476|     22|		    }
14477|     14|		}
14478|      1|		if (uses == NULL) {
  ------------------
  |  Branch (14478:7): [True: 1, False: 0]
  ------------------
14479|      1|		    type->attrUses = xmlSchemaItemListCreate();
14480|      1|		    if (type->attrUses == NULL)
  ------------------
  |  Branch (14480:11): [True: 0, False: 1]
  ------------------
14481|      0|			goto exit_failure;
14482|      1|		    uses = type->attrUses;
14483|      1|		}
14484|      1|		xmlSchemaItemListAddSize(uses, 2, use);
14485|     17|inherit_next: {}
14486|     17|	    }
14487|     10|	} else {
14488|       |	    /* Extension. */
14489|     16|	    for (i = 0; i < baseUses->nbItems; i++) {
  ------------------
  |  Branch (14489:18): [True: 8, False: 8]
  ------------------
14490|      8|		use = baseUses->items[i];
14491|      8|		if (uses == NULL) {
  ------------------
  |  Branch (14491:7): [True: 2, False: 6]
  ------------------
14492|      2|		    type->attrUses = xmlSchemaItemListCreate();
14493|      2|		    if (type->attrUses == NULL)
  ------------------
  |  Branch (14493:11): [True: 0, False: 2]
  ------------------
14494|      0|			goto exit_failure;
14495|      2|		    uses = type->attrUses;
14496|      2|		}
14497|      8|		xmlSchemaItemListAddSize(uses, baseUses->nbItems, use);
14498|      8|	    }
14499|      8|	}
14500|     18|    }
14501|       |    /*
14502|       |    * Shrink attr. uses.
14503|       |    */
14504|    361|    if (uses) {
  ------------------
  |  Branch (14504:9): [True: 157, False: 204]
  ------------------
14505|    157|	if (uses->nbItems == 0) {
  ------------------
  |  Branch (14505:6): [True: 19, False: 138]
  ------------------
14506|     19|	    xmlSchemaItemListFree(uses);
14507|     19|	    type->attrUses = NULL;
14508|     19|	}
14509|       |	/*
14510|       |	* TODO: We could shrink the size of the array
14511|       |	* to fit the actual number of items.
14512|       |	*/
14513|    157|    }
14514|       |    /*
14515|       |    * Compute the complete wildcard.
14516|       |    */
14517|    361|    if (WXS_IS_EXTENSION(type)) {
  ------------------
  |  |  229|    361|    ((t)->flags & XML_SCHEMAS_TYPE_DERIVATION_METHOD_EXTENSION)
  |  |  ------------------
  |  |  |  |  414|    361|#define XML_SCHEMAS_TYPE_DERIVATION_METHOD_EXTENSION                1 << 1
  |  |  ------------------
  |  |  |  Branch (229:5): [True: 76, False: 285]
  |  |  ------------------
  ------------------
14518|     76|	if (baseType->attributeWildcard != NULL) {
  ------------------
  |  Branch (14518:6): [True: 31, False: 45]
  ------------------
14519|       |	    /*
14520|       |	    * (3.2.2.1) "If the `base wildcard` is non-`absent`, then
14521|       |	    * the appropriate case among the following:"
14522|       |	    */
14523|     31|	    if (type->attributeWildcard != NULL) {
  ------------------
  |  Branch (14523:10): [True: 28, False: 3]
  ------------------
14524|       |		/*
14525|       |		* Union the complete wildcard with the base wildcard.
14526|       |		* SPEC {attribute wildcard}
14527|       |		* (3.2.2.1.2) "otherwise a wildcard whose {process contents}
14528|       |		* and {annotation} are those of the `complete wildcard`,
14529|       |		* and whose {namespace constraint} is the intensional union
14530|       |		* of the {namespace constraint} of the `complete wildcard`
14531|       |		* and of the `base wildcard`, as defined in Attribute
14532|       |		* Wildcard Union ($3.10.6)."
14533|       |		*/
14534|     28|		if (xmlSchemaUnionWildcards(pctxt, type->attributeWildcard,
  ------------------
  |  Branch (14534:7): [True: 0, False: 28]
  ------------------
14535|     28|		    baseType->attributeWildcard) == -1)
14536|      0|		    goto exit_failure;
14537|     28|	    } else {
14538|       |		/*
14539|       |		* (3.2.2.1.1) "If the `complete wildcard` is `absent`,
14540|       |		* then the `base wildcard`."
14541|       |		*/
14542|      3|		type->attributeWildcard = baseType->attributeWildcard;
14543|      3|	    }
14544|     45|	} else {
14545|       |	    /*
14546|       |	    * (3.2.2.2) "otherwise (the `base wildcard` is `absent`) the
14547|       |	    * `complete wildcard`"
14548|       |	    * NOOP
14549|       |	    */
14550|     45|	}
14551|    285|    } else {
14552|       |	/*
14553|       |	* SPEC {attribute wildcard}
14554|       |	* (3.1) "If the <restriction> alternative is chosen, then the
14555|       |	* `complete wildcard`;"
14556|       |	* NOOP
14557|       |	*/
14558|    285|    }
14559|       |
14560|    361|    return (0);
14561|       |
14562|      0|exit_failure:
14563|      0|    return(-1);
14564|    361|}
xmlschemas.c:xmlSchemaUnionWildcards:
13496|     28|{
13497|     28|    xmlSchemaWildcardNsPtr cur, curB, tmp;
13498|       |
13499|       |    /*
13500|       |    * 1 If O1 and O2 are the same value, then that value must be the
13501|       |    * value.
13502|       |    */
13503|     28|    if ((completeWild->any == curWild->any) &&
  ------------------
  |  Branch (13503:9): [True: 25, False: 3]
  ------------------
13504|     28|	((completeWild->nsSet == NULL) == (curWild->nsSet == NULL)) &&
  ------------------
  |  Branch (13504:2): [True: 9, False: 16]
  ------------------
13505|     28|	((completeWild->negNsSet == NULL) == (curWild->negNsSet == NULL))) {
  ------------------
  |  Branch (13505:2): [True: 9, False: 0]
  ------------------
13506|       |
13507|      9|	if ((completeWild->negNsSet == NULL) ||
  ------------------
  |  Branch (13507:6): [True: 7, False: 2]
  ------------------
13508|      9|	    (completeWild->negNsSet->value == curWild->negNsSet->value)) {
  ------------------
  |  Branch (13508:6): [True: 0, False: 2]
  ------------------
13509|       |
13510|      7|	    if (completeWild->nsSet != NULL) {
  ------------------
  |  Branch (13510:10): [True: 5, False: 2]
  ------------------
13511|      5|		int found = 0;
13512|       |
13513|       |		/*
13514|       |		* Check equality of sets.
13515|       |		*/
13516|      5|		cur = completeWild->nsSet;
13517|     11|		while (cur != NULL) {
  ------------------
  |  Branch (13517:10): [True: 9, False: 2]
  ------------------
13518|      9|		    found = 0;
13519|      9|		    curB = curWild->nsSet;
13520|     18|		    while (curB != NULL) {
  ------------------
  |  Branch (13520:14): [True: 15, False: 3]
  ------------------
13521|     15|			if (cur->value == curB->value) {
  ------------------
  |  Branch (13521:8): [True: 6, False: 9]
  ------------------
13522|      6|			    found = 1;
13523|      6|			    break;
13524|      6|			}
13525|      9|			curB = curB->next;
13526|      9|		    }
13527|      9|		    if (!found)
  ------------------
  |  Branch (13527:11): [True: 3, False: 6]
  ------------------
13528|      3|			break;
13529|      6|		    cur = cur->next;
13530|      6|		}
13531|      5|		if (found)
  ------------------
  |  Branch (13531:7): [True: 2, False: 3]
  ------------------
13532|      2|		    return(0);
13533|      5|	    } else
13534|      2|		return(0);
13535|      7|	}
13536|      9|    }
13537|       |    /*
13538|       |    * 2 If either O1 or O2 is any, then any must be the value
13539|       |    */
13540|     24|    if (completeWild->any != curWild->any) {
  ------------------
  |  Branch (13540:9): [True: 3, False: 21]
  ------------------
13541|      3|	if (completeWild->any == 0) {
  ------------------
  |  Branch (13541:6): [True: 1, False: 2]
  ------------------
13542|      1|	    completeWild->any = 1;
13543|      1|	    if (completeWild->nsSet != NULL) {
  ------------------
  |  Branch (13543:10): [True: 1, False: 0]
  ------------------
13544|      1|		xmlSchemaFreeWildcardNsSet(completeWild->nsSet);
13545|      1|		completeWild->nsSet = NULL;
13546|      1|	    }
13547|      1|	    if (completeWild->negNsSet != NULL) {
  ------------------
  |  Branch (13547:10): [True: 0, False: 1]
  ------------------
13548|      0|		xmlFree(completeWild->negNsSet);
13549|      0|		completeWild->negNsSet = NULL;
13550|      0|	    }
13551|      1|	}
13552|      3|	return (0);
13553|      3|    }
13554|       |    /*
13555|       |    * 3 If both O1 and O2 are sets of (namespace names or `absent`),
13556|       |    * then the union of those sets must be the value.
13557|       |    */
13558|     21|    if ((completeWild->nsSet != NULL) && (curWild->nsSet != NULL)) {
  ------------------
  |  Branch (13558:9): [True: 13, False: 8]
  |  Branch (13558:42): [True: 3, False: 10]
  ------------------
13559|      3|	int found;
13560|      3|	xmlSchemaWildcardNsPtr start;
13561|       |
13562|      3|	cur = curWild->nsSet;
13563|      3|	start = completeWild->nsSet;
13564|      6|	while (cur != NULL) {
  ------------------
  |  Branch (13564:9): [True: 3, False: 3]
  ------------------
13565|      3|	    found = 0;
13566|      3|	    curB = start;
13567|      8|	    while (curB != NULL) {
  ------------------
  |  Branch (13567:13): [True: 5, False: 3]
  ------------------
13568|      5|		if (cur->value == curB->value) {
  ------------------
  |  Branch (13568:7): [True: 0, False: 5]
  ------------------
13569|      0|		    found = 1;
13570|      0|		    break;
13571|      0|		}
13572|      5|		curB = curB->next;
13573|      5|	    }
13574|      3|	    if (!found) {
  ------------------
  |  Branch (13574:10): [True: 3, False: 0]
  ------------------
13575|      3|		tmp = xmlSchemaNewWildcardNsConstraint(ctxt);
13576|      3|		if (tmp == NULL)
  ------------------
  |  Branch (13576:7): [True: 0, False: 3]
  ------------------
13577|      0|		    return (-1);
13578|      3|		tmp->value = cur->value;
13579|      3|		tmp->next = completeWild->nsSet;
13580|      3|		completeWild->nsSet = tmp;
13581|      3|	    }
13582|      3|	    cur = cur->next;
13583|      3|	}
13584|       |
13585|      3|	return(0);
13586|      3|    }
13587|       |    /*
13588|       |    * 4 If the two are negations of different values (namespace names
13589|       |    * or `absent`), then a pair of not and `absent` must be the value.
13590|       |    */
13591|     18|    if ((completeWild->negNsSet != NULL) &&
  ------------------
  |  Branch (13591:9): [True: 8, False: 10]
  ------------------
13592|     18|	(curWild->negNsSet != NULL) &&
  ------------------
  |  Branch (13592:2): [True: 2, False: 6]
  ------------------
13593|     18|	(completeWild->negNsSet->value != curWild->negNsSet->value)) {
  ------------------
  |  Branch (13593:2): [True: 2, False: 0]
  ------------------
13594|      2|	completeWild->negNsSet->value = NULL;
13595|       |
13596|      2|	return(0);
13597|      2|    }
13598|       |    /*
13599|       |     * 5.
13600|       |     */
13601|     16|    if (((completeWild->negNsSet != NULL) &&
  ------------------
  |  Branch (13601:10): [True: 6, False: 10]
  ------------------
13602|     16|	(completeWild->negNsSet->value != NULL) &&
  ------------------
  |  Branch (13602:2): [True: 6, False: 0]
  ------------------
13603|     16|	(curWild->nsSet != NULL)) ||
  ------------------
  |  Branch (13603:2): [True: 6, False: 0]
  ------------------
13604|     16|	((curWild->negNsSet != NULL) &&
  ------------------
  |  Branch (13604:3): [True: 10, False: 0]
  ------------------
13605|     10|	(curWild->negNsSet->value != NULL) &&
  ------------------
  |  Branch (13605:2): [True: 6, False: 4]
  ------------------
13606|     12|	(completeWild->nsSet != NULL))) {
  ------------------
  |  Branch (13606:2): [True: 6, False: 0]
  ------------------
13607|       |
13608|     12|	int nsFound, absentFound = 0;
13609|       |
13610|     12|	if (completeWild->nsSet != NULL) {
  ------------------
  |  Branch (13610:6): [True: 6, False: 6]
  ------------------
13611|      6|	    cur = completeWild->nsSet;
13612|      6|	    curB = curWild->negNsSet;
13613|      6|	} else {
13614|      6|	    cur = curWild->nsSet;
13615|      6|	    curB = completeWild->negNsSet;
13616|      6|	}
13617|     12|	nsFound = 0;
13618|     28|	while (cur != NULL) {
  ------------------
  |  Branch (13618:9): [True: 20, False: 8]
  ------------------
13619|     20|	    if (cur->value == NULL)
  ------------------
  |  Branch (13619:10): [True: 4, False: 16]
  ------------------
13620|      4|		absentFound = 1;
13621|     16|	    else if (cur->value == curB->value)
  ------------------
  |  Branch (13621:15): [True: 8, False: 8]
  ------------------
13622|      8|		nsFound = 1;
13623|     20|	    if (nsFound && absentFound)
  ------------------
  |  Branch (13623:10): [True: 12, False: 8]
  |  Branch (13623:21): [True: 4, False: 8]
  ------------------
13624|      4|		break;
13625|     16|	    cur = cur->next;
13626|     16|	}
13627|       |
13628|     12|	if (nsFound && absentFound) {
  ------------------
  |  Branch (13628:6): [True: 8, False: 4]
  |  Branch (13628:17): [True: 4, False: 4]
  ------------------
13629|       |	    /*
13630|       |	    * 5.1 If the set S includes both the negated namespace
13631|       |	    * name and `absent`, then any must be the value.
13632|       |	    */
13633|      4|	    completeWild->any = 1;
13634|      4|	    if (completeWild->nsSet != NULL) {
  ------------------
  |  Branch (13634:10): [True: 2, False: 2]
  ------------------
13635|      2|		xmlSchemaFreeWildcardNsSet(completeWild->nsSet);
13636|      2|		completeWild->nsSet = NULL;
13637|      2|	    }
13638|      4|	    if (completeWild->negNsSet != NULL) {
  ------------------
  |  Branch (13638:10): [True: 2, False: 2]
  ------------------
13639|      2|		xmlFree(completeWild->negNsSet);
13640|      2|		completeWild->negNsSet = NULL;
13641|      2|	    }
13642|      8|	} else if (nsFound && (!absentFound)) {
  ------------------
  |  Branch (13642:13): [True: 4, False: 4]
  |  Branch (13642:24): [True: 4, False: 0]
  ------------------
13643|       |	    /*
13644|       |	    * 5.2 If the set S includes the negated namespace name
13645|       |	    * but not `absent`, then a pair of not and `absent` must
13646|       |	    * be the value.
13647|       |	    */
13648|      4|	    if (completeWild->nsSet != NULL) {
  ------------------
  |  Branch (13648:10): [True: 2, False: 2]
  ------------------
13649|      2|		xmlSchemaFreeWildcardNsSet(completeWild->nsSet);
13650|      2|		completeWild->nsSet = NULL;
13651|      2|	    }
13652|      4|	    if (completeWild->negNsSet == NULL) {
  ------------------
  |  Branch (13652:10): [True: 2, False: 2]
  ------------------
13653|      2|		completeWild->negNsSet = xmlSchemaNewWildcardNsConstraint(ctxt);
13654|      2|		if (completeWild->negNsSet == NULL)
  ------------------
  |  Branch (13654:7): [True: 0, False: 2]
  ------------------
13655|      0|		    return (-1);
13656|      2|	    }
13657|      4|	    completeWild->negNsSet->value = NULL;
13658|      4|	} else if ((!nsFound) && absentFound) {
  ------------------
  |  Branch (13658:13): [True: 4, False: 0]
  |  Branch (13658:27): [True: 0, False: 4]
  ------------------
13659|       |	    /*
13660|       |	    * 5.3 If the set S includes `absent` but not the negated
13661|       |	    * namespace name, then the union is not expressible.
13662|       |	    */
13663|      0|	    xmlSchemaPErr(ctxt, completeWild->node,
13664|      0|		XML_SCHEMAP_UNION_NOT_EXPRESSIBLE,
13665|      0|		"The union of the wildcard is not expressible.\n",
13666|      0|		NULL, NULL);
13667|      0|	    return(XML_SCHEMAP_UNION_NOT_EXPRESSIBLE);
13668|      4|	} else if ((!nsFound) && (!absentFound)) {
  ------------------
  |  Branch (13668:13): [True: 4, False: 0]
  |  Branch (13668:27): [True: 4, False: 0]
  ------------------
13669|       |	    /*
13670|       |	    * 5.4 If the set S does not include either the negated namespace
13671|       |	    * name or `absent`, then whichever of O1 or O2 is a pair of not
13672|       |	    * and a namespace name must be the value.
13673|       |	    */
13674|      4|	    if (completeWild->negNsSet == NULL) {
  ------------------
  |  Branch (13674:10): [True: 2, False: 2]
  ------------------
13675|      2|		if (completeWild->nsSet != NULL) {
  ------------------
  |  Branch (13675:7): [True: 2, False: 0]
  ------------------
13676|      2|		    xmlSchemaFreeWildcardNsSet(completeWild->nsSet);
13677|      2|		    completeWild->nsSet = NULL;
13678|      2|		}
13679|      2|		completeWild->negNsSet = xmlSchemaNewWildcardNsConstraint(ctxt);
13680|      2|		if (completeWild->negNsSet == NULL)
  ------------------
  |  Branch (13680:7): [True: 0, False: 2]
  ------------------
13681|      0|		    return (-1);
13682|      2|		completeWild->negNsSet->value = curWild->negNsSet->value;
13683|      2|	    }
13684|      4|	}
13685|     12|	return (0);
13686|     12|    }
13687|       |    /*
13688|       |     * 6.
13689|       |     */
13690|      4|    if (((completeWild->negNsSet != NULL) &&
  ------------------
  |  Branch (13690:10): [True: 0, False: 4]
  ------------------
13691|      4|	(completeWild->negNsSet->value == NULL) &&
  ------------------
  |  Branch (13691:2): [True: 0, False: 0]
  ------------------
13692|      4|	(curWild->nsSet != NULL)) ||
  ------------------
  |  Branch (13692:2): [True: 0, False: 0]
  ------------------
13693|      4|	((curWild->negNsSet != NULL) &&
  ------------------
  |  Branch (13693:3): [True: 4, False: 0]
  ------------------
13694|      4|	(curWild->negNsSet->value == NULL) &&
  ------------------
  |  Branch (13694:2): [True: 4, False: 0]
  ------------------
13695|      4|	(completeWild->nsSet != NULL))) {
  ------------------
  |  Branch (13695:2): [True: 4, False: 0]
  ------------------
13696|       |
13697|      4|	if (completeWild->nsSet != NULL) {
  ------------------
  |  Branch (13697:6): [True: 4, False: 0]
  ------------------
13698|      4|	    cur = completeWild->nsSet;
13699|      4|	} else {
13700|      0|	    cur = curWild->nsSet;
13701|      0|	}
13702|      8|	while (cur != NULL) {
  ------------------
  |  Branch (13702:9): [True: 6, False: 2]
  ------------------
13703|      6|	    if (cur->value == NULL) {
  ------------------
  |  Branch (13703:10): [True: 2, False: 4]
  ------------------
13704|       |		/*
13705|       |		* 6.1 If the set S includes `absent`, then any must be the
13706|       |		* value.
13707|       |		*/
13708|      2|		completeWild->any = 1;
13709|      2|		if (completeWild->nsSet != NULL) {
  ------------------
  |  Branch (13709:7): [True: 2, False: 0]
  ------------------
13710|      2|		    xmlSchemaFreeWildcardNsSet(completeWild->nsSet);
13711|      2|		    completeWild->nsSet = NULL;
13712|      2|		}
13713|      2|		if (completeWild->negNsSet != NULL) {
  ------------------
  |  Branch (13713:7): [True: 0, False: 2]
  ------------------
13714|      0|		    xmlFree(completeWild->negNsSet);
13715|      0|		    completeWild->negNsSet = NULL;
13716|      0|		}
13717|      2|		return (0);
13718|      2|	    }
13719|      4|	    cur = cur->next;
13720|      4|	}
13721|      2|	if (completeWild->negNsSet == NULL) {
  ------------------
  |  Branch (13721:6): [True: 2, False: 0]
  ------------------
13722|       |	    /*
13723|       |	    * 6.2 If the set S does not include `absent`, then a pair of not
13724|       |	    * and `absent` must be the value.
13725|       |	    */
13726|      2|	    if (completeWild->nsSet != NULL) {
  ------------------
  |  Branch (13726:10): [True: 2, False: 0]
  ------------------
13727|      2|		xmlSchemaFreeWildcardNsSet(completeWild->nsSet);
13728|      2|		completeWild->nsSet = NULL;
13729|      2|	    }
13730|      2|	    completeWild->negNsSet = xmlSchemaNewWildcardNsConstraint(ctxt);
13731|      2|	    if (completeWild->negNsSet == NULL)
  ------------------
  |  Branch (13731:10): [True: 0, False: 2]
  ------------------
13732|      0|		return (-1);
13733|      2|	    completeWild->negNsSet->value = NULL;
13734|      2|	}
13735|      2|	return (0);
13736|      2|    }
13737|      0|    return (0);
13738|       |
13739|      4|}
xmlschemas.c:xmlSchemaCheckCTComponent:
16587|    361|{
16588|    361|    int ret;
16589|       |    /*
16590|       |    * Complex Type Definition Properties Correct
16591|       |    */
16592|    361|    ret = xmlSchemaCheckCTPropsCorrect(ctxt, type);
16593|    361|    if (ret != 0)
  ------------------
  |  Branch (16593:9): [True: 0, False: 361]
  ------------------
16594|      0|	return (ret);
16595|    361|    if (WXS_IS_EXTENSION(type))
  ------------------
  |  |  229|    361|    ((t)->flags & XML_SCHEMAS_TYPE_DERIVATION_METHOD_EXTENSION)
  |  |  ------------------
  |  |  |  |  414|    361|#define XML_SCHEMAS_TYPE_DERIVATION_METHOD_EXTENSION                1 << 1
  |  |  ------------------
  |  |  |  Branch (229:5): [True: 76, False: 285]
  |  |  ------------------
  ------------------
16596|     76|	ret = xmlSchemaCheckCOSCTExtends(ctxt, type);
16597|    285|    else
16598|    285|	ret = xmlSchemaCheckDerivationOKRestriction(ctxt, type);
16599|    361|    return (ret);
16600|    361|}
xmlschemas.c:xmlSchemaCheckCTPropsCorrect:
15893|    361|{
15894|       |    /*
15895|       |    * TODO: Correct the error code; XML_SCHEMAP_SRC_CT_1 is used temporarily.
15896|       |    *
15897|       |    * SPEC (1) "The values of the properties of a complex type definition must
15898|       |    * be as described in the property tableau in The Complex Type Definition
15899|       |    * Schema Component ($3.4.1), modulo the impact of Missing
15900|       |    * Sub-components ($5.3)."
15901|       |    */
15902|    361|    if ((type->baseType != NULL) &&
  ------------------
  |  Branch (15902:9): [True: 361, False: 0]
  ------------------
15903|    361|	(WXS_IS_SIMPLE(type->baseType)) &&
  ------------------
  |  |  217|    361|    ((item->type == XML_SCHEMA_TYPE_SIMPLE) || \
  |  |  ------------------
  |  |  |  Branch (217:6): [True: 13, False: 348]
  |  |  ------------------
  |  |  218|    361|     ((item->type == XML_SCHEMA_TYPE_BASIC) && \
  |  |  ------------------
  |  |  |  Branch (218:7): [True: 291, False: 57]
  |  |  ------------------
  |  |  219|    348|      (item->builtInType != XML_SCHEMAS_ANYTYPE)))
  |  |  ------------------
  |  |  |  Branch (219:7): [True: 19, False: 272]
  |  |  ------------------
  ------------------
15904|    361|	(WXS_IS_EXTENSION(type) == 0)) {
  ------------------
  |  |  229|     32|    ((t)->flags & XML_SCHEMAS_TYPE_DERIVATION_METHOD_EXTENSION)
  |  |  ------------------
  |  |  |  |  414|     32|#define XML_SCHEMAS_TYPE_DERIVATION_METHOD_EXTENSION                1 << 1
  |  |  ------------------
  ------------------
  |  Branch (15904:2): [True: 0, False: 32]
  ------------------
15905|       |	/*
15906|       |	* SPEC (2) "If the {base type definition} is a simple type definition,
15907|       |	* the {derivation method} must be extension."
15908|       |	*/
15909|      0|	xmlSchemaCustomErr(ACTXT_CAST pctxt,
  ------------------
  |  |  121|      0|#define ACTXT_CAST (xmlSchemaAbstractCtxtPtr)
  ------------------
15910|      0|	    XML_SCHEMAP_SRC_CT_1,
15911|      0|	    NULL, WXS_BASIC_CAST type,
  ------------------
  |  |  124|      0|#define WXS_BASIC_CAST (xmlSchemaBasicItemPtr)
  ------------------
15912|      0|	    "If the base type is a simple type, the derivation method must be "
15913|      0|	    "'extension'", NULL, NULL);
15914|      0|	return (XML_SCHEMAP_SRC_CT_1);
15915|      0|    }
15916|       |    /*
15917|       |    * SPEC (3) "Circular definitions are disallowed, except for the `ur-type
15918|       |    * definition`. That is, it must be possible to reach the `ur-type
15919|       |    * definition` by repeatedly following the {base type definition}."
15920|       |    *
15921|       |    * NOTE (3) is done in xmlSchemaCheckTypeDefCircular().
15922|       |    */
15923|       |    /*
15924|       |    * NOTE that (4) and (5) need the following:
15925|       |    *   - attribute uses need to be already inherited (apply attr. prohibitions)
15926|       |    *   - attribute group references need to be expanded already
15927|       |    *   - simple types need to be typefixed already
15928|       |    */
15929|    361|    if (type->attrUses &&
  ------------------
  |  Branch (15929:9): [True: 138, False: 223]
  ------------------
15930|    361|	(((xmlSchemaItemListPtr) type->attrUses)->nbItems > 1))
  ------------------
  |  Branch (15930:2): [True: 49, False: 89]
  ------------------
15931|     49|    {
15932|     49|	xmlSchemaItemListPtr uses = (xmlSchemaItemListPtr) type->attrUses;
15933|     49|	xmlSchemaAttributeUsePtr use, tmp;
15934|     49|	int i, j, hasId = 0;
15935|       |
15936|    190|	for (i = uses->nbItems -1; i >= 0; i--) {
  ------------------
  |  Branch (15936:29): [True: 141, False: 49]
  ------------------
15937|    141|	    use = uses->items[i];
15938|       |
15939|       |	    /*
15940|       |	    * SPEC ct-props-correct
15941|       |	    * (4) "Two distinct attribute declarations in the
15942|       |	    * {attribute uses} must not have identical {name}s and
15943|       |	    * {target namespace}s."
15944|       |	    */
15945|    141|	    if (i > 0) {
  ------------------
  |  Branch (15945:10): [True: 92, False: 49]
  ------------------
15946|    337|		for (j = i -1; j >= 0; j--) {
  ------------------
  |  Branch (15946:18): [True: 246, False: 91]
  ------------------
15947|    246|		    tmp = uses->items[j];
15948|    246|		    if ((WXS_ATTRUSE_DECL_NAME(use) ==
  ------------------
  |  |  162|    246|#define WXS_ATTRUSE_DECL_NAME(au) (WXS_ATTRUSE_DECL(au))->name
  |  |  ------------------
  |  |  |  |  158|    246|#define WXS_ATTRUSE_DECL(au) (WXS_ATTR_USE_CAST (au))->attrDecl
  |  |  |  |  ------------------
  |  |  |  |  |  |  131|    246|#define WXS_ATTR_USE_CAST (xmlSchemaAttributeUsePtr)
  |  |  |  |  ------------------
  |  |  ------------------
  ------------------
  |  Branch (15948:11): [True: 1, False: 245]
  ------------------
15949|    246|			WXS_ATTRUSE_DECL_NAME(tmp)) &&
  ------------------
  |  |  162|    246|#define WXS_ATTRUSE_DECL_NAME(au) (WXS_ATTRUSE_DECL(au))->name
  |  |  ------------------
  |  |  |  |  158|    246|#define WXS_ATTRUSE_DECL(au) (WXS_ATTR_USE_CAST (au))->attrDecl
  |  |  |  |  ------------------
  |  |  |  |  |  |  131|    246|#define WXS_ATTR_USE_CAST (xmlSchemaAttributeUsePtr)
  |  |  |  |  ------------------
  |  |  ------------------
  ------------------
15950|    246|			(WXS_ATTRUSE_DECL_TNS(use) ==
  ------------------
  |  |  164|      1|#define WXS_ATTRUSE_DECL_TNS(au) (WXS_ATTRUSE_DECL(au))->targetNamespace
  |  |  ------------------
  |  |  |  |  158|      1|#define WXS_ATTRUSE_DECL(au) (WXS_ATTR_USE_CAST (au))->attrDecl
  |  |  |  |  ------------------
  |  |  |  |  |  |  131|      1|#define WXS_ATTR_USE_CAST (xmlSchemaAttributeUsePtr)
  |  |  |  |  ------------------
  |  |  ------------------
  ------------------
  |  Branch (15950:4): [True: 1, False: 0]
  ------------------
15951|      1|			WXS_ATTRUSE_DECL_TNS(tmp)))
  ------------------
  |  |  164|      1|#define WXS_ATTRUSE_DECL_TNS(au) (WXS_ATTRUSE_DECL(au))->targetNamespace
  |  |  ------------------
  |  |  |  |  158|      1|#define WXS_ATTRUSE_DECL(au) (WXS_ATTR_USE_CAST (au))->attrDecl
  |  |  |  |  ------------------
  |  |  |  |  |  |  131|      1|#define WXS_ATTR_USE_CAST (xmlSchemaAttributeUsePtr)
  |  |  |  |  ------------------
  |  |  ------------------
  ------------------
15952|      1|		    {
15953|      1|			xmlChar *str = NULL;
15954|       |
15955|      1|			xmlSchemaCustomErr(ACTXT_CAST pctxt,
  ------------------
  |  |  121|      1|#define ACTXT_CAST (xmlSchemaAbstractCtxtPtr)
  ------------------
15956|      1|			    XML_SCHEMAP_AG_PROPS_CORRECT,
15957|      1|			    NULL, WXS_BASIC_CAST type,
  ------------------
  |  |  124|      1|#define WXS_BASIC_CAST (xmlSchemaBasicItemPtr)
  ------------------
15958|      1|			    "Duplicate %s",
15959|      1|			    xmlSchemaGetComponentDesignation(&str, use),
15960|      1|			    NULL);
15961|      1|			FREE_AND_NULL(str);
  ------------------
  |  |  320|      1|#define FREE_AND_NULL(str) if ((str) != NULL) { xmlFree((xmlChar *) (str)); str = NULL; }
  |  |  ------------------
  |  |  |  Branch (320:32): [True: 1, False: 0]
  |  |  ------------------
  ------------------
15962|       |			/*
15963|       |			* Remove the duplicate.
15964|       |			*/
15965|      1|			if (xmlSchemaItemListRemove(uses, i) == -1)
  ------------------
  |  Branch (15965:8): [True: 0, False: 1]
  ------------------
15966|      0|			    goto exit_failure;
15967|      1|			goto next_use;
15968|      1|		    }
15969|    246|		}
15970|     92|	    }
15971|       |	    /*
15972|       |	    * SPEC ct-props-correct
15973|       |	    * (5) "Two distinct attribute declarations in the
15974|       |	    * {attribute uses} must not have {type definition}s which
15975|       |	    * are or are derived from ID."
15976|       |	    */
15977|    140|	    if (WXS_ATTRUSE_TYPEDEF(use) != NULL) {
  ------------------
  |  |  160|    140|#define WXS_ATTRUSE_TYPEDEF(au) WXS_ATTR_TYPEDEF(WXS_ATTRUSE_DECL( WXS_ATTR_USE_CAST au))
  |  |  ------------------
  |  |  |  |  154|    140|#define WXS_ATTR_TYPEDEF(a) (a)->subtypes
  |  |  ------------------
  ------------------
  |  Branch (15977:10): [True: 140, False: 0]
  ------------------
15978|    140|		if (xmlSchemaIsDerivedFromBuiltInType(
  ------------------
  |  Branch (15978:7): [True: 9, False: 131]
  ------------------
15979|    140|		    WXS_ATTRUSE_TYPEDEF(use), XML_SCHEMAS_ID))
  ------------------
  |  |  160|    140|#define WXS_ATTRUSE_TYPEDEF(au) WXS_ATTR_TYPEDEF(WXS_ATTRUSE_DECL( WXS_ATTR_USE_CAST au))
  |  |  ------------------
  |  |  |  |  154|    140|#define WXS_ATTR_TYPEDEF(a) (a)->subtypes
  |  |  ------------------
  ------------------
15980|      9|		{
15981|      9|		    if (hasId) {
  ------------------
  |  Branch (15981:11): [True: 0, False: 9]
  ------------------
15982|      0|			xmlChar *str = NULL;
15983|       |
15984|      0|			xmlSchemaCustomErr(ACTXT_CAST pctxt,
  ------------------
  |  |  121|      0|#define ACTXT_CAST (xmlSchemaAbstractCtxtPtr)
  ------------------
15985|      0|			    XML_SCHEMAP_AG_PROPS_CORRECT,
15986|      0|			    NULL, WXS_BASIC_CAST type,
  ------------------
  |  |  124|      0|#define WXS_BASIC_CAST (xmlSchemaBasicItemPtr)
  ------------------
15987|      0|			    "There must not exist more than one attribute "
15988|      0|			    "declaration of type 'xs:ID' "
15989|      0|			    "(or derived from 'xs:ID'). The %s violates this "
15990|      0|			    "constraint",
15991|      0|			    xmlSchemaGetComponentDesignation(&str, use),
15992|      0|			    NULL);
15993|      0|			FREE_AND_NULL(str);
  ------------------
  |  |  320|      0|#define FREE_AND_NULL(str) if ((str) != NULL) { xmlFree((xmlChar *) (str)); str = NULL; }
  |  |  ------------------
  |  |  |  Branch (320:32): [True: 0, False: 0]
  |  |  ------------------
  ------------------
15994|      0|			if (xmlSchemaItemListRemove(uses, i) == -1)
  ------------------
  |  Branch (15994:8): [True: 0, False: 0]
  ------------------
15995|      0|			    goto exit_failure;
15996|      0|		    }
15997|       |
15998|      9|		    hasId = 1;
15999|      9|		}
16000|    140|	    }
16001|    141|next_use: {}
16002|    141|	}
16003|     49|    }
16004|    361|    return (0);
16005|      0|exit_failure:
16006|      0|    return(-1);
16007|    361|}
xmlschemas.c:xmlSchemaCheckCOSCTExtends:
16140|     76|{
16141|     76|    xmlSchemaTypePtr base = type->baseType;
16142|       |    /*
16143|       |    * TODO: Correct the error code; XML_SCHEMAP_COS_CT_EXTENDS_1_1 is used
16144|       |    * temporarily only.
16145|       |    */
16146|       |    /*
16147|       |    * SPEC (1) "If the {base type definition} is a complex type definition,
16148|       |    * then all of the following must be true:"
16149|       |    */
16150|     76|    if (WXS_IS_COMPLEX(base)) {
  ------------------
  |  |  213|     76|    (((i)->type == XML_SCHEMA_TYPE_COMPLEX) || \
  |  |  ------------------
  |  |  |  Branch (213:6): [True: 42, False: 34]
  |  |  ------------------
  |  |  214|     76|     ((i)->builtInType == XML_SCHEMAS_ANYTYPE))
  |  |  ------------------
  |  |  |  Branch (214:6): [True: 2, False: 32]
  |  |  ------------------
  ------------------
16151|       |	/*
16152|       |	* SPEC (1.1) "The {final} of the {base type definition} must not
16153|       |	* contain extension."
16154|       |	*/
16155|     44|	if (base->flags & XML_SCHEMAS_TYPE_FINAL_EXTENSION) {
  ------------------
  |  |  466|     44|#define XML_SCHEMAS_TYPE_FINAL_EXTENSION    1 << 9
  ------------------
  |  Branch (16155:6): [True: 0, False: 44]
  ------------------
16156|      0|	    xmlSchemaPCustomErr(ctxt,
16157|      0|		XML_SCHEMAP_COS_CT_EXTENDS_1_1,
16158|      0|		WXS_BASIC_CAST type, NULL,
  ------------------
  |  |  124|      0|#define WXS_BASIC_CAST (xmlSchemaBasicItemPtr)
  ------------------
16159|      0|		"The 'final' of the base type definition "
16160|      0|		"contains 'extension'", NULL);
16161|      0|	    return (XML_SCHEMAP_COS_CT_EXTENDS_1_1);
16162|      0|	}
16163|       |
16164|       |	/*
16165|       |	* ATTENTION: The constrains (1.2) and (1.3) are not applied,
16166|       |	* since they are automatically satisfied through the
16167|       |	* inheriting mechanism.
16168|       |	* Note that even if redefining components, the inheriting mechanism
16169|       |	* is used.
16170|       |	*/
16171|       |#if 0
16172|       |	/*
16173|       |	* SPEC (1.2) "Its {attribute uses} must be a subset of the {attribute
16174|       |	* uses}
16175|       |	* of the complex type definition itself, that is, for every attribute
16176|       |	* use in the {attribute uses} of the {base type definition}, there
16177|       |	* must be an attribute use in the {attribute uses} of the complex
16178|       |	* type definition itself whose {attribute declaration} has the same
16179|       |	* {name}, {target namespace} and {type definition} as its attribute
16180|       |	* declaration"
16181|       |	*/
16182|       |	if (base->attrUses != NULL) {
16183|       |	    int i, j, found;
16184|       |	    xmlSchemaAttributeUsePtr use, buse;
16185|       |
16186|       |	    for (i = 0; i < (WXS_LIST_CAST base->attrUses)->nbItems; i ++) {
16187|       |		buse = (WXS_LIST_CAST base->attrUses)->items[i];
16188|       |		found = 0;
16189|       |		if (type->attrUses != NULL) {
16190|       |		    use = (WXS_LIST_CAST type->attrUses)->items[j];
16191|       |		    for (j = 0; j < (WXS_LIST_CAST type->attrUses)->nbItems; j ++)
16192|       |		    {
16193|       |			if ((WXS_ATTRUSE_DECL_NAME(use) ==
16194|       |				WXS_ATTRUSE_DECL_NAME(buse)) &&
16195|       |			    (WXS_ATTRUSE_DECL_TNS(use) ==
16196|       |				WXS_ATTRUSE_DECL_TNS(buse)) &&
16197|       |			    (WXS_ATTRUSE_TYPEDEF(use) ==
16198|       |				WXS_ATTRUSE_TYPEDEF(buse))
16199|       |			{
16200|       |			    found = 1;
16201|       |			    break;
16202|       |			}
16203|       |		    }
16204|       |		}
16205|       |		if (! found) {
16206|       |		    xmlChar *str = NULL;
16207|       |
16208|       |		    xmlSchemaCustomErr(ACTXT_CAST ctxt,
16209|       |			XML_SCHEMAP_COS_CT_EXTENDS_1_2,
16210|       |			NULL, WXS_BASIC_CAST type,
16211|       |			/*
16212|       |			* TODO: The report does not indicate that also the
16213|       |			* type needs to be the same.
16214|       |			*/
16215|       |			"This type is missing a matching correspondent "
16216|       |			"for its {base type}'s %s in its {attribute uses}",
16217|       |			xmlSchemaGetComponentDesignation(&str,
16218|       |			    buse->children),
16219|       |			NULL);
16220|       |		    FREE_AND_NULL(str)
16221|       |		}
16222|       |	    }
16223|       |	}
16224|       |	/*
16225|       |	* SPEC (1.3) "If it has an {attribute wildcard}, the complex type
16226|       |	* definition must also have one, and the base type definition's
16227|       |	* {attribute  wildcard}'s {namespace constraint} must be a subset
16228|       |	* of the complex  type definition's {attribute wildcard}'s {namespace
16229|       |	* constraint}, as defined by Wildcard Subset ($3.10.6)."
16230|       |	*/
16231|       |
16232|       |	/*
16233|       |	* MAYBE TODO: Enable if ever needed. But this will be needed only
16234|       |	* if created the type via a schema construction API.
16235|       |	*/
16236|       |	if (base->attributeWildcard != NULL) {
16237|       |	    if (type->attributeWildcard == NULL) {
16238|       |		xmlChar *str = NULL;
16239|       |
16240|       |		xmlSchemaCustomErr(ACTXT_CAST pctxt,
16241|       |		    XML_SCHEMAP_COS_CT_EXTENDS_1_3,
16242|       |		    NULL, type,
16243|       |		    "The base %s has an attribute wildcard, "
16244|       |		    "but this type is missing an attribute wildcard",
16245|       |		    xmlSchemaGetComponentDesignation(&str, base));
16246|       |		FREE_AND_NULL(str)
16247|       |
16248|       |	    } else if (xmlSchemaCheckCOSNSSubset(
16249|       |		base->attributeWildcard, type->attributeWildcard))
16250|       |	    {
16251|       |		xmlChar *str = NULL;
16252|       |
16253|       |		xmlSchemaCustomErr(ACTXT_CAST pctxt,
16254|       |		    XML_SCHEMAP_COS_CT_EXTENDS_1_3,
16255|       |		    NULL, type,
16256|       |		    "The attribute wildcard is not a valid "
16257|       |		    "superset of the one in the base %s",
16258|       |		    xmlSchemaGetComponentDesignation(&str, base));
16259|       |		FREE_AND_NULL(str)
16260|       |	    }
16261|       |	}
16262|       |#endif
16263|       |	/*
16264|       |	* SPEC (1.4) "One of the following must be true:"
16265|       |	*/
16266|     44|	if ((type->contentTypeDef != NULL) &&
  ------------------
  |  Branch (16266:6): [True: 0, False: 44]
  ------------------
16267|     44|	    (type->contentTypeDef == base->contentTypeDef)) {
  ------------------
  |  Branch (16267:6): [True: 0, False: 0]
  ------------------
16268|       |	    /*
16269|       |	    * SPEC (1.4.1) "The {content type} of the {base type definition}
16270|       |	    * and the {content type} of the complex type definition itself
16271|       |	    * must be the same simple type definition"
16272|       |	    * PASS
16273|       |	    */
16274|     44|	} else if ((type->contentType == XML_SCHEMA_CONTENT_EMPTY) &&
  ------------------
  |  Branch (16274:13): [True: 31, False: 13]
  ------------------
16275|     44|	    (base->contentType == XML_SCHEMA_CONTENT_EMPTY) ) {
  ------------------
  |  Branch (16275:6): [True: 31, False: 0]
  ------------------
16276|       |	    /*
16277|       |	    * SPEC (1.4.2) "The {content type} of both the {base type
16278|       |	    * definition} and the complex type definition itself must
16279|       |	    * be empty."
16280|       |	    * PASS
16281|       |	    */
16282|     31|	} else {
16283|       |	    /*
16284|       |	    * SPEC (1.4.3) "All of the following must be true:"
16285|       |	    */
16286|     13|	    if (type->subtypes == NULL) {
  ------------------
  |  Branch (16286:10): [True: 0, False: 13]
  ------------------
16287|       |		/*
16288|       |		* SPEC 1.4.3.1 The {content type} of the complex type
16289|       |		* definition itself must specify a particle.
16290|       |		*/
16291|      0|		xmlSchemaPCustomErr(ctxt,
16292|      0|		    XML_SCHEMAP_COS_CT_EXTENDS_1_1,
16293|      0|		    WXS_BASIC_CAST type, NULL,
  ------------------
  |  |  124|      0|#define WXS_BASIC_CAST (xmlSchemaBasicItemPtr)
  ------------------
16294|      0|		    "The content type must specify a particle", NULL);
16295|      0|		return (XML_SCHEMAP_COS_CT_EXTENDS_1_1);
16296|      0|	    }
16297|       |	    /*
16298|       |	    * SPEC (1.4.3.2) "One of the following must be true:"
16299|       |	    */
16300|     13|	    if (base->contentType == XML_SCHEMA_CONTENT_EMPTY) {
  ------------------
  |  Branch (16300:10): [True: 6, False: 7]
  ------------------
16301|       |		/*
16302|       |		* SPEC (1.4.3.2.1) "The {content type} of the {base type
16303|       |		* definition} must be empty.
16304|       |		* PASS
16305|       |		*/
16306|      7|	    } else {
16307|       |		/*
16308|       |		* SPEC (1.4.3.2.2) "All of the following must be true:"
16309|       |		*/
16310|      7|		if ((type->contentType != base->contentType) ||
  ------------------
  |  Branch (16310:7): [True: 1, False: 6]
  ------------------
16311|      7|		    ((type->contentType != XML_SCHEMA_CONTENT_MIXED) &&
  ------------------
  |  Branch (16311:8): [True: 4, False: 2]
  ------------------
16312|      6|		    (type->contentType != XML_SCHEMA_CONTENT_ELEMENTS))) {
  ------------------
  |  Branch (16312:7): [True: 0, False: 4]
  ------------------
16313|       |		    /*
16314|       |		    * SPEC (1.4.3.2.2.1) "Both {content type}s must be mixed
16315|       |		    * or both must be element-only."
16316|       |		    */
16317|      1|		    xmlSchemaPCustomErr(ctxt,
16318|      1|			XML_SCHEMAP_COS_CT_EXTENDS_1_1,
16319|      1|			WXS_BASIC_CAST type, NULL,
  ------------------
  |  |  124|      1|#define WXS_BASIC_CAST (xmlSchemaBasicItemPtr)
  ------------------
16320|      1|			"The content type of both, the type and its base "
16321|      1|			"type, must either 'mixed' or 'element-only'", NULL);
16322|      1|		    return (XML_SCHEMAP_COS_CT_EXTENDS_1_1);
16323|      1|		}
16324|       |		/*
16325|       |		* URGENT TODO SPEC (1.4.3.2.2.2) "The particle of the
16326|       |		* complex type definition must be a `valid extension`
16327|       |		* of the {base type definition}'s particle, as defined
16328|       |		* in Particle Valid (Extension) ($3.9.6)."
16329|       |		*
16330|       |		* NOTE that we won't check "Particle Valid (Extension)",
16331|       |		* since it is ensured by the derivation process in
16332|       |		* xmlSchemaTypeFixup(). We need to implement this when heading
16333|       |		* for a construction API
16334|       |		* TODO: !! This is needed to be checked if redefining a type !!
16335|       |		*/
16336|      7|	    }
16337|       |	    /*
16338|       |	    * URGENT TODO (1.5)
16339|       |	    */
16340|     13|	}
16341|     44|    } else {
16342|       |	/*
16343|       |	* SPEC (2) "If the {base type definition} is a simple type definition,
16344|       |	* then all of the following must be true:"
16345|       |	*/
16346|     32|	if (type->contentTypeDef != base) {
  ------------------
  |  Branch (16346:6): [True: 0, False: 32]
  ------------------
16347|       |	    /*
16348|       |	    * SPEC (2.1) "The {content type} must be the same simple type
16349|       |	    * definition."
16350|       |	    */
16351|      0|	    xmlSchemaPCustomErr(ctxt,
16352|      0|		XML_SCHEMAP_COS_CT_EXTENDS_1_1,
16353|      0|		WXS_BASIC_CAST type, NULL,
  ------------------
  |  |  124|      0|#define WXS_BASIC_CAST (xmlSchemaBasicItemPtr)
  ------------------
16354|      0|		"The content type must be the simple base type", NULL);
16355|      0|	    return (XML_SCHEMAP_COS_CT_EXTENDS_1_1);
16356|      0|	}
16357|     32|	if (base->flags & XML_SCHEMAS_TYPE_FINAL_EXTENSION) {
  ------------------
  |  |  466|     32|#define XML_SCHEMAS_TYPE_FINAL_EXTENSION    1 << 9
  ------------------
  |  Branch (16357:6): [True: 0, False: 32]
  ------------------
16358|       |	    /*
16359|       |	    * SPEC (2.2) "The {final} of the {base type definition} must not
16360|       |	    * contain extension"
16361|       |	    * NOTE that this is the same as (1.1).
16362|       |	    */
16363|      0|	    xmlSchemaPCustomErr(ctxt,
16364|      0|		XML_SCHEMAP_COS_CT_EXTENDS_1_1,
16365|      0|		WXS_BASIC_CAST type, NULL,
  ------------------
  |  |  124|      0|#define WXS_BASIC_CAST (xmlSchemaBasicItemPtr)
  ------------------
16366|      0|		"The 'final' of the base type definition "
16367|      0|		"contains 'extension'", NULL);
16368|      0|	    return (XML_SCHEMAP_COS_CT_EXTENDS_1_1);
16369|      0|	}
16370|     32|    }
16371|     75|    return (0);
16372|     76|}
xmlschemas.c:xmlSchemaCheckDerivationOKRestriction:
16397|    285|{
16398|    285|    xmlSchemaTypePtr base;
16399|       |
16400|       |    /*
16401|       |    * TODO: Correct the error code; XML_SCHEMAP_DERIVATION_OK_RESTRICTION_1 is used
16402|       |    * temporarily only.
16403|       |    */
16404|    285|    base = type->baseType;
16405|    285|    if (! WXS_IS_COMPLEX(base)) {
  ------------------
  |  |  213|    285|    (((i)->type == XML_SCHEMA_TYPE_COMPLEX) || \
  |  |  ------------------
  |  |  |  Branch (213:6): [True: 15, False: 270]
  |  |  ------------------
  |  |  214|    285|     ((i)->builtInType == XML_SCHEMAS_ANYTYPE))
  |  |  ------------------
  |  |  |  Branch (214:6): [True: 270, False: 0]
  |  |  ------------------
  ------------------
16406|      0|	xmlSchemaCustomErr(ACTXT_CAST ctxt,
  ------------------
  |  |  121|      0|#define ACTXT_CAST (xmlSchemaAbstractCtxtPtr)
  ------------------
16407|      0|	    XML_SCHEMAP_DERIVATION_OK_RESTRICTION_1,
16408|      0|	    type->node, WXS_BASIC_CAST type,
  ------------------
  |  |  124|      0|#define WXS_BASIC_CAST (xmlSchemaBasicItemPtr)
  ------------------
16409|      0|	    "The base type must be a complex type", NULL, NULL);
16410|      0|	return(ctxt->err);
16411|      0|    }
16412|    285|    if (base->flags & XML_SCHEMAS_TYPE_FINAL_RESTRICTION) {
  ------------------
  |  |  472|    285|#define XML_SCHEMAS_TYPE_FINAL_RESTRICTION    1 << 10
  ------------------
  |  Branch (16412:9): [True: 0, False: 285]
  ------------------
16413|       |	/*
16414|       |	* SPEC (1) "The {base type definition} must be a complex type
16415|       |	* definition whose {final} does not contain restriction."
16416|       |	*/
16417|      0|	xmlSchemaCustomErr(ACTXT_CAST ctxt,
  ------------------
  |  |  121|      0|#define ACTXT_CAST (xmlSchemaAbstractCtxtPtr)
  ------------------
16418|      0|	    XML_SCHEMAP_DERIVATION_OK_RESTRICTION_1,
16419|      0|	    type->node, WXS_BASIC_CAST type,
  ------------------
  |  |  124|      0|#define WXS_BASIC_CAST (xmlSchemaBasicItemPtr)
  ------------------
16420|      0|	    "The 'final' of the base type definition "
16421|      0|	    "contains 'restriction'", NULL, NULL);
16422|      0|	return (ctxt->err);
16423|      0|    }
16424|       |    /*
16425|       |    * SPEC (2), (3) and (4)
16426|       |    * Those are handled in a separate function, since the
16427|       |    * same constraints are needed for redefinition of
16428|       |    * attribute groups as well.
16429|       |    */
16430|    285|    if (xmlSchemaCheckDerivationOKRestriction2to4(ctxt,
  ------------------
  |  Branch (16430:9): [True: 0, False: 285]
  ------------------
16431|    285|	XML_SCHEMA_ACTION_DERIVE,
  ------------------
  |  |14058|    285|#define XML_SCHEMA_ACTION_DERIVE 0
  ------------------
16432|    285|	WXS_BASIC_CAST type, WXS_BASIC_CAST base,
  ------------------
  |  |  124|    285|#define WXS_BASIC_CAST (xmlSchemaBasicItemPtr)
  ------------------
              	WXS_BASIC_CAST type, WXS_BASIC_CAST base,
  ------------------
  |  |  124|    285|#define WXS_BASIC_CAST (xmlSchemaBasicItemPtr)
  ------------------
16433|    285|	type->attrUses, base->attrUses,
16434|    285|	type->attributeWildcard,
16435|    285|	base->attributeWildcard) == -1)
16436|      0|    {
16437|      0|	return(-1);
16438|      0|    }
16439|       |    /*
16440|       |    * SPEC (5) "One of the following must be true:"
16441|       |    */
16442|    285|    if (base->builtInType == XML_SCHEMAS_ANYTYPE) {
  ------------------
  |  Branch (16442:9): [True: 270, False: 15]
  ------------------
16443|       |	/*
16444|       |	* SPEC (5.1) "The {base type definition} must be the
16445|       |	* `ur-type definition`."
16446|       |	* PASS
16447|       |	*/
16448|    270|    } else if ((type->contentType == XML_SCHEMA_CONTENT_SIMPLE) ||
  ------------------
  |  Branch (16448:16): [True: 2, False: 13]
  ------------------
16449|     15|	    (type->contentType == XML_SCHEMA_CONTENT_BASIC)) {
  ------------------
  |  Branch (16449:6): [True: 0, False: 13]
  ------------------
16450|       |	/*
16451|       |	* SPEC (5.2.1) "The {content type} of the complex type definition
16452|       |	* must be a simple type definition"
16453|       |	*
16454|       |	* SPEC (5.2.2) "One of the following must be true:"
16455|       |	*/
16456|      2|	if ((base->contentType == XML_SCHEMA_CONTENT_SIMPLE) ||
  ------------------
  |  Branch (16456:6): [True: 2, False: 0]
  ------------------
16457|      2|	    (base->contentType == XML_SCHEMA_CONTENT_BASIC))
  ------------------
  |  Branch (16457:6): [True: 0, False: 0]
  ------------------
16458|      2|	{
16459|      2|	    int err;
16460|       |	    /*
16461|       |	    * SPEC (5.2.2.1) "The {content type} of the {base type
16462|       |	    * definition} must be a simple type definition from which
16463|       |	    * the {content type} is validly derived given the empty
16464|       |	    * set as defined in Type Derivation OK (Simple) ($3.14.6)."
16465|       |	    *
16466|       |	    * ATTENTION TODO: This seems not needed if the type implicitly
16467|       |	    * derived from the base type.
16468|       |	    *
16469|       |	    */
16470|      2|	    err = xmlSchemaCheckCOSSTDerivedOK(ACTXT_CAST ctxt,
  ------------------
  |  |  121|      2|#define ACTXT_CAST (xmlSchemaAbstractCtxtPtr)
  ------------------
16471|      2|		type->contentTypeDef, base->contentTypeDef, 0);
16472|      2|	    if (err != 0) {
  ------------------
  |  Branch (16472:10): [True: 0, False: 2]
  ------------------
16473|      0|		xmlChar *strA = NULL, *strB = NULL;
16474|       |
16475|      0|		if (err == -1)
  ------------------
  |  Branch (16475:7): [True: 0, False: 0]
  ------------------
16476|      0|		    return(-1);
16477|      0|		xmlSchemaCustomErr(ACTXT_CAST ctxt,
  ------------------
  |  |  121|      0|#define ACTXT_CAST (xmlSchemaAbstractCtxtPtr)
  ------------------
16478|      0|		    XML_SCHEMAP_DERIVATION_OK_RESTRICTION_1,
16479|      0|		    NULL, WXS_BASIC_CAST type,
  ------------------
  |  |  124|      0|#define WXS_BASIC_CAST (xmlSchemaBasicItemPtr)
  ------------------
16480|      0|		    "The {content type} %s is not validly derived from the "
16481|      0|		    "base type's {content type} %s",
16482|      0|		    xmlSchemaGetComponentDesignation(&strA,
16483|      0|			type->contentTypeDef),
16484|      0|		    xmlSchemaGetComponentDesignation(&strB,
16485|      0|			base->contentTypeDef));
16486|      0|		FREE_AND_NULL(strA);
  ------------------
  |  |  320|      0|#define FREE_AND_NULL(str) if ((str) != NULL) { xmlFree((xmlChar *) (str)); str = NULL; }
  |  |  ------------------
  |  |  |  Branch (320:32): [True: 0, False: 0]
  |  |  ------------------
  ------------------
16487|      0|		FREE_AND_NULL(strB);
  ------------------
  |  |  320|      0|#define FREE_AND_NULL(str) if ((str) != NULL) { xmlFree((xmlChar *) (str)); str = NULL; }
  |  |  ------------------
  |  |  |  Branch (320:32): [True: 0, False: 0]
  |  |  ------------------
  ------------------
16488|      0|		return(ctxt->err);
16489|      0|	    }
16490|      2|	} else if ((base->contentType == XML_SCHEMA_CONTENT_MIXED) &&
  ------------------
  |  Branch (16490:13): [True: 0, False: 0]
  ------------------
16491|      0|	    (xmlSchemaIsParticleEmptiable(
  ------------------
  |  Branch (16491:6): [True: 0, False: 0]
  ------------------
16492|      0|		(xmlSchemaParticlePtr) base->subtypes))) {
16493|       |	    /*
16494|       |	    * SPEC (5.2.2.2) "The {base type definition} must be mixed
16495|       |	    * and have a particle which is `emptiable` as defined in
16496|       |	    * Particle Emptiable ($3.9.6)."
16497|       |	    * PASS
16498|       |	    */
16499|      0|	} else {
16500|      0|	    xmlSchemaPCustomErr(ctxt,
16501|      0|		XML_SCHEMAP_DERIVATION_OK_RESTRICTION_1,
16502|      0|		WXS_BASIC_CAST type, NULL,
  ------------------
  |  |  124|      0|#define WXS_BASIC_CAST (xmlSchemaBasicItemPtr)
  ------------------
16503|      0|		"The content type of the base type must be either "
16504|      0|		"a simple type or 'mixed' and an emptiable particle", NULL);
16505|      0|	    return (ctxt->err);
16506|      0|	}
16507|     13|    } else if (type->contentType == XML_SCHEMA_CONTENT_EMPTY) {
  ------------------
  |  Branch (16507:16): [True: 6, False: 7]
  ------------------
16508|       |	/*
16509|       |	* SPEC (5.3.1) "The {content type} of the complex type itself must
16510|       |	* be empty"
16511|       |	*/
16512|      6|	if (base->contentType == XML_SCHEMA_CONTENT_EMPTY) {
  ------------------
  |  Branch (16512:6): [True: 6, False: 0]
  ------------------
16513|       |	    /*
16514|       |	    * SPEC (5.3.2.1) "The {content type} of the {base type
16515|       |	    * definition} must also be empty."
16516|       |	    * PASS
16517|       |	    */
16518|      6|	} else if (((base->contentType == XML_SCHEMA_CONTENT_ELEMENTS) ||
  ------------------
  |  Branch (16518:14): [True: 0, False: 0]
  ------------------
16519|      0|	    (base->contentType == XML_SCHEMA_CONTENT_MIXED)) &&
  ------------------
  |  Branch (16519:6): [True: 0, False: 0]
  ------------------
16520|      0|	    xmlSchemaIsParticleEmptiable(
  ------------------
  |  Branch (16520:6): [True: 0, False: 0]
  ------------------
16521|      0|		(xmlSchemaParticlePtr) base->subtypes)) {
16522|       |	    /*
16523|       |	    * SPEC (5.3.2.2) "The {content type} of the {base type
16524|       |	    * definition} must be elementOnly or mixed and have a particle
16525|       |	    * which is `emptiable` as defined in Particle Emptiable ($3.9.6)."
16526|       |	    * PASS
16527|       |	    */
16528|      0|	} else {
16529|      0|	    xmlSchemaPCustomErr(ctxt,
16530|      0|		XML_SCHEMAP_DERIVATION_OK_RESTRICTION_1,
16531|      0|		WXS_BASIC_CAST type, NULL,
  ------------------
  |  |  124|      0|#define WXS_BASIC_CAST (xmlSchemaBasicItemPtr)
  ------------------
16532|      0|		"The content type of the base type must be either "
16533|      0|		"empty or 'mixed' (or 'elements-only') and an emptiable "
16534|      0|		"particle", NULL);
16535|      0|	    return (ctxt->err);
16536|      0|	}
16537|      7|    } else if ((type->contentType == XML_SCHEMA_CONTENT_ELEMENTS) ||
  ------------------
  |  Branch (16537:16): [True: 7, False: 0]
  ------------------
16538|      7|	WXS_HAS_MIXED_CONTENT(type)) {
  ------------------
  |  |  255|      0|    (item->contentType == XML_SCHEMA_CONTENT_MIXED)
  |  |  ------------------
  |  |  |  Branch (255:5): [True: 0, False: 0]
  |  |  ------------------
  ------------------
16539|       |	/*
16540|       |	* SPEC (5.4.1.1) "The {content type} of the complex type definition
16541|       |	* itself must be element-only"
16542|       |	*/
16543|      7|	if (WXS_HAS_MIXED_CONTENT(type) && (! WXS_HAS_MIXED_CONTENT(base))) {
  ------------------
  |  |  255|     14|    (item->contentType == XML_SCHEMA_CONTENT_MIXED)
  |  |  ------------------
  |  |  |  Branch (255:5): [True: 0, False: 7]
  |  |  ------------------
  ------------------
              	if (WXS_HAS_MIXED_CONTENT(type) && (! WXS_HAS_MIXED_CONTENT(base))) {
  ------------------
  |  |  255|      0|    (item->contentType == XML_SCHEMA_CONTENT_MIXED)
  ------------------
  |  Branch (16543:37): [True: 0, False: 0]
  ------------------
16544|       |	    /*
16545|       |	    * SPEC (5.4.1.2) "The {content type} of the complex type
16546|       |	    * definition itself and of the {base type definition} must be
16547|       |	    * mixed"
16548|       |	    */
16549|      0|	    xmlSchemaPCustomErr(ctxt,
16550|      0|		XML_SCHEMAP_DERIVATION_OK_RESTRICTION_1,
16551|      0|		WXS_BASIC_CAST type, NULL,
  ------------------
  |  |  124|      0|#define WXS_BASIC_CAST (xmlSchemaBasicItemPtr)
  ------------------
16552|      0|		"If the content type is 'mixed', then the content type of the "
16553|      0|		"base type must also be 'mixed'", NULL);
16554|      0|	    return (ctxt->err);
16555|      0|	}
16556|       |	/*
16557|       |	* SPEC (5.4.2) "The particle of the complex type definition itself
16558|       |	* must be a `valid restriction` of the particle of the {content
16559|       |	* type} of the {base type definition} as defined in Particle Valid
16560|       |	* (Restriction) ($3.9.6).
16561|       |	*
16562|       |	* URGENT TODO: (5.4.2)
16563|       |	*/
16564|      7|    } else {
16565|      0|	xmlSchemaPCustomErr(ctxt,
16566|      0|	    XML_SCHEMAP_DERIVATION_OK_RESTRICTION_1,
16567|      0|	    WXS_BASIC_CAST type, NULL,
  ------------------
  |  |  124|      0|#define WXS_BASIC_CAST (xmlSchemaBasicItemPtr)
  ------------------
16568|      0|	    "The type is not a valid restriction of its base type", NULL);
16569|      0|	return (ctxt->err);
16570|      0|    }
16571|    285|    return (0);
16572|    285|}
xmlschemas.c:xmlSchemaCheckElementDeclComponent:
19936|    581|{
19937|    581|    if (elemDecl == NULL)
  ------------------
  |  Branch (19937:9): [True: 0, False: 581]
  ------------------
19938|      0|	return;
19939|    581|    if (elemDecl->flags & XML_SCHEMAS_ELEM_INTERNAL_CHECKED)
  ------------------
  |  |  761|    581|#define XML_SCHEMAS_ELEM_INTERNAL_CHECKED        1 << 18
  ------------------
  |  Branch (19939:9): [True: 26, False: 555]
  ------------------
19940|     26|	return;
19941|    555|    elemDecl->flags |= XML_SCHEMAS_ELEM_INTERNAL_CHECKED;
  ------------------
  |  |  761|    555|#define XML_SCHEMAS_ELEM_INTERNAL_CHECKED        1 << 18
  ------------------
19942|    555|    if (xmlSchemaCheckElemPropsCorrect(ctxt, elemDecl) == 0) {
  ------------------
  |  Branch (19942:9): [True: 553, False: 2]
  ------------------
19943|       |	/*
19944|       |	* Adds substitution group members.
19945|       |	*/
19946|    553|	xmlSchemaCheckElemSubstGroup(ctxt, elemDecl);
19947|    553|    }
19948|    555|}
xmlschemas.c:xmlSchemaCheckElemPropsCorrect:
19528|    555|{
19529|    555|    int ret = 0;
19530|    555|    xmlSchemaTypePtr typeDef = WXS_ELEM_TYPEDEF(elemDecl);
  ------------------
  |  |  148|    555|#define WXS_ELEM_TYPEDEF(e) (e)->subtypes
  ------------------
19531|       |    /*
19532|       |    * SPEC (1) "The values of the properties of an element declaration
19533|       |    * must be as described in the property tableau in The Element
19534|       |    * Declaration Schema Component ($3.3.1), modulo the impact of Missing
19535|       |    * Sub-components ($5.3)."
19536|       |    */
19537|    555|    if (WXS_SUBST_HEAD(elemDecl) != NULL) {
  ------------------
  |  |  150|    555|#define WXS_SUBST_HEAD(item) (item)->refDecl
  ------------------
  |  Branch (19537:9): [True: 26, False: 529]
  ------------------
19538|     26|	xmlSchemaElementPtr head = WXS_SUBST_HEAD(elemDecl), circ;
  ------------------
  |  |  150|     26|#define WXS_SUBST_HEAD(item) (item)->refDecl
  ------------------
19539|       |
19540|     26|	xmlSchemaCheckElementDeclComponent(head, pctxt);
19541|       |	/*
19542|       |	* SPEC (3) "If there is a non-`absent` {substitution group
19543|       |	* affiliation}, then {scope} must be global."
19544|       |	*/
19545|     26|	if ((elemDecl->flags & XML_SCHEMAS_ELEM_GLOBAL) == 0) {
  ------------------
  |  |  655|     26|#define XML_SCHEMAS_ELEM_GLOBAL                1 << 1
  ------------------
  |  Branch (19545:6): [True: 0, False: 26]
  ------------------
19546|      0|	    xmlSchemaPCustomErr(pctxt,
19547|      0|		XML_SCHEMAP_E_PROPS_CORRECT_3,
19548|      0|		WXS_BASIC_CAST elemDecl, NULL,
  ------------------
  |  |  124|      0|#define WXS_BASIC_CAST (xmlSchemaBasicItemPtr)
  ------------------
19549|      0|		"Only global element declarations can have a "
19550|      0|		"substitution group affiliation", NULL);
19551|      0|	    ret = XML_SCHEMAP_E_PROPS_CORRECT_3;
19552|      0|	}
19553|       |	/*
19554|       |	* TODO: SPEC (6) "Circular substitution groups are disallowed.
19555|       |	* That is, it must not be possible to return to an element declaration
19556|       |	* by repeatedly following the {substitution group affiliation}
19557|       |	* property."
19558|       |	*/
19559|     26|	if (head == elemDecl)
  ------------------
  |  Branch (19559:6): [True: 1, False: 25]
  ------------------
19560|      1|	    circ = head;
19561|     25|	else if (WXS_SUBST_HEAD(head) != NULL)
  ------------------
  |  |  150|     25|#define WXS_SUBST_HEAD(item) (item)->refDecl
  ------------------
  |  Branch (19561:11): [True: 1, False: 24]
  ------------------
19562|      1|	    circ = xmlSchemaCheckSubstGroupCircular(head, head);
19563|     24|	else
19564|     24|	    circ = NULL;
19565|     26|	if (circ != NULL) {
  ------------------
  |  Branch (19565:6): [True: 2, False: 24]
  ------------------
19566|      2|	    xmlChar *strA = NULL, *strB = NULL;
19567|       |
19568|      2|	    xmlSchemaPCustomErrExt(pctxt,
19569|      2|		XML_SCHEMAP_E_PROPS_CORRECT_6,
19570|      2|		WXS_BASIC_CAST circ, NULL,
  ------------------
  |  |  124|      2|#define WXS_BASIC_CAST (xmlSchemaBasicItemPtr)
  ------------------
19571|      2|		"The element declaration '%s' defines a circular "
19572|      2|		"substitution group to element declaration '%s'",
19573|      2|		xmlSchemaGetComponentQName(&strA, circ),
19574|      2|		xmlSchemaGetComponentQName(&strB, head),
19575|      2|		NULL);
19576|      2|	    FREE_AND_NULL(strA)
  ------------------
  |  |  320|      2|#define FREE_AND_NULL(str) if ((str) != NULL) { xmlFree((xmlChar *) (str)); str = NULL; }
  |  |  ------------------
  |  |  |  Branch (320:32): [True: 0, False: 2]
  |  |  ------------------
  ------------------
19577|      2|	    FREE_AND_NULL(strB)
  ------------------
  |  |  320|      2|#define FREE_AND_NULL(str) if ((str) != NULL) { xmlFree((xmlChar *) (str)); str = NULL; }
  |  |  ------------------
  |  |  |  Branch (320:32): [True: 0, False: 2]
  |  |  ------------------
  ------------------
19578|      2|	    ret = XML_SCHEMAP_E_PROPS_CORRECT_6;
19579|      2|	}
19580|       |	/*
19581|       |	* SPEC (4) "If there is a {substitution group affiliation},
19582|       |	* the {type definition}
19583|       |	* of the element declaration must be validly derived from the {type
19584|       |	* definition} of the {substitution group affiliation}, given the value
19585|       |	* of the {substitution group exclusions} of the {substitution group
19586|       |	* affiliation}, as defined in Type Derivation OK (Complex) ($3.4.6)
19587|       |	* (if the {type definition} is complex) or as defined in
19588|       |	* Type Derivation OK (Simple) ($3.14.6) (if the {type definition} is
19589|       |	* simple)."
19590|       |	*
19591|       |	* NOTE: {substitution group exclusions} means the values of the
19592|       |	* attribute "final".
19593|       |	*/
19594|       |
19595|     26|	if (typeDef != WXS_ELEM_TYPEDEF(WXS_SUBST_HEAD(elemDecl))) {
  ------------------
  |  |  148|     26|#define WXS_ELEM_TYPEDEF(e) (e)->subtypes
  ------------------
  |  Branch (19595:6): [True: 2, False: 24]
  ------------------
19596|      2|	    int set = 0;
19597|       |
19598|      2|	    if (head->flags & XML_SCHEMAS_ELEM_FINAL_EXTENSION)
  ------------------
  |  |  742|      2|#define XML_SCHEMAS_ELEM_FINAL_EXTENSION        1 << 15
  ------------------
  |  Branch (19598:10): [True: 0, False: 2]
  ------------------
19599|      0|		set |= SUBSET_EXTENSION;
  ------------------
  |  |  342|      0|#define SUBSET_EXTENSION    1<<1
  ------------------
19600|      2|	    if (head->flags & XML_SCHEMAS_ELEM_FINAL_RESTRICTION)
  ------------------
  |  |  748|      2|#define XML_SCHEMAS_ELEM_FINAL_RESTRICTION        1 << 16
  ------------------
  |  Branch (19600:10): [True: 0, False: 2]
  ------------------
19601|      0|		set |= SUBSET_RESTRICTION;
  ------------------
  |  |  341|      0|#define SUBSET_RESTRICTION  1<<0
  ------------------
19602|       |
19603|      2|	    if (xmlSchemaCheckCOSDerivedOK(ACTXT_CAST pctxt, typeDef,
  ------------------
  |  |  121|      2|#define ACTXT_CAST (xmlSchemaAbstractCtxtPtr)
  ------------------
  |  Branch (19603:10): [True: 0, False: 2]
  ------------------
19604|      2|		WXS_ELEM_TYPEDEF(head), set) != 0) {
  ------------------
  |  |  148|      2|#define WXS_ELEM_TYPEDEF(e) (e)->subtypes
  ------------------
19605|      0|		xmlChar *strA = NULL, *strB = NULL, *strC = NULL;
19606|       |
19607|      0|		ret = XML_SCHEMAP_E_PROPS_CORRECT_4;
19608|      0|		xmlSchemaPCustomErrExt(pctxt,
19609|      0|		    XML_SCHEMAP_E_PROPS_CORRECT_4,
19610|      0|		    WXS_BASIC_CAST elemDecl, NULL,
  ------------------
  |  |  124|      0|#define WXS_BASIC_CAST (xmlSchemaBasicItemPtr)
  ------------------
19611|      0|		    "The type definition '%s' was "
19612|      0|		    "either rejected by the substitution group "
19613|      0|		    "affiliation '%s', or not validly derived from its type "
19614|      0|		    "definition '%s'",
19615|      0|		    xmlSchemaGetComponentQName(&strA, typeDef),
19616|      0|		    xmlSchemaGetComponentQName(&strB, head),
19617|      0|		    xmlSchemaGetComponentQName(&strC, WXS_ELEM_TYPEDEF(head)));
  ------------------
  |  |  148|      0|#define WXS_ELEM_TYPEDEF(e) (e)->subtypes
  ------------------
19618|      0|		FREE_AND_NULL(strA)
  ------------------
  |  |  320|      0|#define FREE_AND_NULL(str) if ((str) != NULL) { xmlFree((xmlChar *) (str)); str = NULL; }
  |  |  ------------------
  |  |  |  Branch (320:32): [True: 0, False: 0]
  |  |  ------------------
  ------------------
19619|      0|		FREE_AND_NULL(strB)
  ------------------
  |  |  320|      0|#define FREE_AND_NULL(str) if ((str) != NULL) { xmlFree((xmlChar *) (str)); str = NULL; }
  |  |  ------------------
  |  |  |  Branch (320:32): [True: 0, False: 0]
  |  |  ------------------
  ------------------
19620|      0|		FREE_AND_NULL(strC)
  ------------------
  |  |  320|      0|#define FREE_AND_NULL(str) if ((str) != NULL) { xmlFree((xmlChar *) (str)); str = NULL; }
  |  |  ------------------
  |  |  |  Branch (320:32): [True: 0, False: 0]
  |  |  ------------------
  ------------------
19621|      0|	    }
19622|      2|	}
19623|     26|    }
19624|       |    /*
19625|       |    * SPEC (5) "If the {type definition} or {type definition}'s
19626|       |    * {content type}
19627|       |    * is or is derived from ID then there must not be a {value constraint}.
19628|       |    * Note: The use of ID as a type definition for elements goes beyond
19629|       |    * XML 1.0, and should be avoided if backwards compatibility is desired"
19630|       |    */
19631|    555|    if ((elemDecl->value != NULL) &&
  ------------------
  |  Branch (19631:9): [True: 1, False: 554]
  ------------------
19632|    555|	((WXS_IS_SIMPLE(typeDef) &&
  ------------------
  |  |  217|      2|    ((item->type == XML_SCHEMA_TYPE_SIMPLE) || \
  |  |  ------------------
  |  |  |  Branch (217:6): [True: 0, False: 1]
  |  |  ------------------
  |  |  218|      2|     ((item->type == XML_SCHEMA_TYPE_BASIC) && \
  |  |  ------------------
  |  |  |  Branch (218:7): [True: 1, False: 0]
  |  |  ------------------
  |  |  219|      1|      (item->builtInType != XML_SCHEMAS_ANYTYPE)))
  |  |  ------------------
  |  |  |  Branch (219:7): [True: 1, False: 0]
  |  |  ------------------
  ------------------
19633|      1|	  xmlSchemaIsDerivedFromBuiltInType(typeDef, XML_SCHEMAS_ID)) ||
  ------------------
  |  Branch (19633:4): [True: 0, False: 1]
  ------------------
19634|      1|	 (WXS_IS_COMPLEX(typeDef) &&
  ------------------
  |  |  213|      2|    (((i)->type == XML_SCHEMA_TYPE_COMPLEX) || \
  |  |  ------------------
  |  |  |  Branch (213:6): [True: 0, False: 1]
  |  |  ------------------
  |  |  214|      2|     ((i)->builtInType == XML_SCHEMAS_ANYTYPE))
  |  |  ------------------
  |  |  |  Branch (214:6): [True: 0, False: 1]
  |  |  ------------------
  ------------------
19635|      1|	  WXS_HAS_SIMPLE_CONTENT(typeDef) &&
  ------------------
  |  |  251|      1|    ((item->contentType == XML_SCHEMA_CONTENT_SIMPLE) || \
  |  |  ------------------
  |  |  |  Branch (251:6): [True: 0, False: 0]
  |  |  ------------------
  |  |  252|      1|     (item->contentType == XML_SCHEMA_CONTENT_BASIC))
  |  |  ------------------
  |  |  |  Branch (252:6): [True: 0, False: 0]
  |  |  ------------------
  ------------------
19636|      1|	  xmlSchemaIsDerivedFromBuiltInType(typeDef->contentTypeDef,
  ------------------
  |  Branch (19636:4): [True: 0, False: 0]
  ------------------
19637|      0|	    XML_SCHEMAS_ID)))) {
19638|       |
19639|      0|	ret = XML_SCHEMAP_E_PROPS_CORRECT_5;
19640|      0|	xmlSchemaPCustomErr(pctxt,
19641|      0|	    XML_SCHEMAP_E_PROPS_CORRECT_5,
19642|      0|	    WXS_BASIC_CAST elemDecl, NULL,
  ------------------
  |  |  124|      0|#define WXS_BASIC_CAST (xmlSchemaBasicItemPtr)
  ------------------
19643|      0|	    "The type definition (or type definition's content type) is or "
19644|      0|	    "is derived from ID; value constraints are not allowed in "
19645|      0|	    "conjunction with such a type definition", NULL);
19646|    555|    } else if (elemDecl->value != NULL) {
  ------------------
  |  Branch (19646:16): [True: 1, False: 554]
  ------------------
19647|      1|	int vcret;
19648|      1|	xmlNodePtr node = NULL;
19649|       |
19650|       |	/*
19651|       |	* SPEC (2) "If there is a {value constraint}, the canonical lexical
19652|       |	* representation of its value must be `valid` with respect to the
19653|       |	* {type definition} as defined in Element Default Valid (Immediate)
19654|       |	* ($3.3.6)."
19655|       |	*/
19656|      1|	if (typeDef == NULL) {
  ------------------
  |  Branch (19656:6): [True: 0, False: 1]
  ------------------
19657|      0|	    xmlSchemaPErr(pctxt, elemDecl->node,
19658|      0|		XML_SCHEMAP_INTERNAL,
19659|      0|		"Internal error: xmlSchemaCheckElemPropsCorrect, "
19660|      0|		"type is missing... skipping validation of "
19661|      0|		"the value constraint", NULL, NULL);
19662|      0|	    return (-1);
19663|      0|	}
19664|      1|	if (elemDecl->node != NULL) {
  ------------------
  |  Branch (19664:6): [True: 1, False: 0]
  ------------------
19665|      1|	    if (elemDecl->flags & XML_SCHEMAS_ELEM_FIXED)
  ------------------
  |  |  667|      1|#define XML_SCHEMAS_ELEM_FIXED                1 << 3
  ------------------
  |  Branch (19665:10): [True: 0, False: 1]
  ------------------
19666|      0|		node = (xmlNodePtr) xmlHasProp(elemDecl->node,
19667|      0|		    BAD_CAST "fixed");
  ------------------
  |  |   35|      0|#define BAD_CAST (xmlChar *)
  ------------------
19668|      1|	    else
19669|      1|		node = (xmlNodePtr) xmlHasProp(elemDecl->node,
19670|      1|		    BAD_CAST "default");
  ------------------
  |  |   35|      1|#define BAD_CAST (xmlChar *)
  ------------------
19671|      1|	}
19672|      1|	vcret = xmlSchemaParseCheckCOSValidDefault(pctxt, node,
19673|      1|	    typeDef, elemDecl->value, &(elemDecl->defVal));
19674|      1|	if (vcret != 0) {
  ------------------
  |  Branch (19674:6): [True: 0, False: 1]
  ------------------
19675|      0|	    if (vcret < 0) {
  ------------------
  |  Branch (19675:10): [True: 0, False: 0]
  ------------------
19676|      0|		PERROR_INT("xmlSchemaElemCheckValConstr",
  ------------------
  |  | 2824|      0|#define PERROR_INT(func, msg) xmlSchemaInternalErr(ACTXT_CAST pctxt, func, msg);
  |  |  ------------------
  |  |  |  |  121|      0|#define ACTXT_CAST (xmlSchemaAbstractCtxtPtr)
  |  |  ------------------
  ------------------
19677|      0|		    "failed to validate the value constraint of an "
19678|      0|		    "element declaration");
19679|      0|		return (-1);
19680|      0|	    }
19681|      0|	    return (vcret);
19682|      0|	}
19683|      1|    }
19684|       |
19685|    555|    return (ret);
19686|    555|}
xmlschemas.c:xmlSchemaCheckSubstGroupCircular:
19495|      1|{
19496|      1|    xmlSchemaElementPtr ret;
19497|       |
19498|      1|    if (WXS_SUBST_HEAD(ancestor) == NULL)
  ------------------
  |  |  150|      1|#define WXS_SUBST_HEAD(item) (item)->refDecl
  ------------------
  |  Branch (19498:9): [True: 0, False: 1]
  ------------------
19499|      0|	return (NULL);
19500|      1|    if (WXS_SUBST_HEAD(ancestor) == elemDecl)
  ------------------
  |  |  150|      1|#define WXS_SUBST_HEAD(item) (item)->refDecl
  ------------------
  |  Branch (19500:9): [True: 1, False: 0]
  ------------------
19501|      1|	return (ancestor);
19502|       |
19503|      0|    if (WXS_SUBST_HEAD(ancestor)->flags & XML_SCHEMAS_ELEM_CIRCULAR)
  ------------------
  |  |  150|      0|#define WXS_SUBST_HEAD(item) (item)->refDecl
  ------------------
                  if (WXS_SUBST_HEAD(ancestor)->flags & XML_SCHEMAS_ELEM_CIRCULAR)
  ------------------
  |  |  706|      0|#define XML_SCHEMAS_ELEM_CIRCULAR        1 << 9
  ------------------
  |  Branch (19503:9): [True: 0, False: 0]
  ------------------
19504|      0|	return (NULL);
19505|      0|    WXS_SUBST_HEAD(ancestor)->flags |= XML_SCHEMAS_ELEM_CIRCULAR;
  ------------------
  |  |  150|      0|#define WXS_SUBST_HEAD(item) (item)->refDecl
  ------------------
                  WXS_SUBST_HEAD(ancestor)->flags |= XML_SCHEMAS_ELEM_CIRCULAR;
  ------------------
  |  |  706|      0|#define XML_SCHEMAS_ELEM_CIRCULAR        1 << 9
  ------------------
19506|      0|    ret = xmlSchemaCheckSubstGroupCircular(elemDecl,
19507|      0|	WXS_SUBST_HEAD(ancestor));
  ------------------
  |  |  150|      0|#define WXS_SUBST_HEAD(item) (item)->refDecl
  ------------------
19508|      0|    WXS_SUBST_HEAD(ancestor)->flags ^= XML_SCHEMAS_ELEM_CIRCULAR;
  ------------------
  |  |  150|      0|#define WXS_SUBST_HEAD(item) (item)->refDecl
  ------------------
                  WXS_SUBST_HEAD(ancestor)->flags ^= XML_SCHEMAS_ELEM_CIRCULAR;
  ------------------
  |  |  706|      0|#define XML_SCHEMAS_ELEM_CIRCULAR        1 << 9
  ------------------
19509|       |
19510|      0|    return (ret);
19511|      0|}
xmlschemas.c:xmlSchemaCheckCOSDerivedOK:
16113|      2|{
16114|      2|    if (WXS_IS_SIMPLE(type))
  ------------------
  |  |  217|      2|    ((item->type == XML_SCHEMA_TYPE_SIMPLE) || \
  |  |  ------------------
  |  |  |  Branch (217:6): [True: 0, False: 2]
  |  |  ------------------
  |  |  218|      2|     ((item->type == XML_SCHEMA_TYPE_BASIC) && \
  |  |  ------------------
  |  |  |  Branch (218:7): [True: 1, False: 1]
  |  |  ------------------
  |  |  219|      2|      (item->builtInType != XML_SCHEMAS_ANYTYPE)))
  |  |  ------------------
  |  |  |  Branch (219:7): [True: 1, False: 0]
  |  |  ------------------
  ------------------
16115|      1|	return (xmlSchemaCheckCOSSTDerivedOK(actxt, type, baseType, set));
16116|      1|    else
16117|      1|	return (xmlSchemaCheckCOSCTDerivedOK(actxt, type, baseType, set));
16118|      2|}
xmlschemas.c:xmlSchemaCheckCOSCTDerivedOK:
16042|      1|{
16043|      1|    int equal = xmlSchemaAreEqualTypes(type, baseType);
16044|       |    /* TODO: Error codes. */
16045|       |    /*
16046|       |    * SPEC "For a complex type definition (call it D, for derived)
16047|       |    * to be validly derived from a type definition (call this
16048|       |    * B, for base) given a subset of {extension, restriction}
16049|       |    * all of the following must be true:"
16050|       |    */
16051|      1|    if (! equal) {
  ------------------
  |  Branch (16051:9): [True: 1, False: 0]
  ------------------
16052|       |	/*
16053|       |	* SPEC (1) "If B and D are not the same type definition, then the
16054|       |	* {derivation method} of D must not be in the subset."
16055|       |	*/
16056|      1|	if (((set & SUBSET_EXTENSION) && (WXS_IS_EXTENSION(type))) ||
  ------------------
  |  |  342|      1|#define SUBSET_EXTENSION    1<<1
  ------------------
              	if (((set & SUBSET_EXTENSION) && (WXS_IS_EXTENSION(type))) ||
  ------------------
  |  |  229|      0|    ((t)->flags & XML_SCHEMAS_TYPE_DERIVATION_METHOD_EXTENSION)
  |  |  ------------------
  |  |  |  |  414|      0|#define XML_SCHEMAS_TYPE_DERIVATION_METHOD_EXTENSION                1 << 1
  |  |  ------------------
  ------------------
  |  Branch (16056:7): [True: 0, False: 1]
  |  Branch (16056:35): [True: 0, False: 0]
  ------------------
16057|      1|	    ((set & SUBSET_RESTRICTION) && (WXS_IS_RESTRICTION(type))))
  ------------------
  |  |  341|      1|#define SUBSET_RESTRICTION  1<<0
  ------------------
              	    ((set & SUBSET_RESTRICTION) && (WXS_IS_RESTRICTION(type))))
  ------------------
  |  |  226|      0|    ((t)->flags & XML_SCHEMAS_TYPE_DERIVATION_METHOD_RESTRICTION)
  |  |  ------------------
  |  |  |  |  420|      0|#define XML_SCHEMAS_TYPE_DERIVATION_METHOD_RESTRICTION                1 << 2
  |  |  ------------------
  ------------------
  |  Branch (16057:7): [True: 0, False: 1]
  |  Branch (16057:37): [True: 0, False: 0]
  ------------------
16058|      0|	    return (1);
16059|      1|    } else {
16060|       |	/*
16061|       |	* SPEC (2.1) "B and D must be the same type definition."
16062|       |	*/
16063|      0|	return (0);
16064|      0|    }
16065|       |    /*
16066|       |    * SPEC (2.2) "B must be D's {base type definition}."
16067|       |    */
16068|      1|    if (type->baseType == baseType)
  ------------------
  |  Branch (16068:9): [True: 1, False: 0]
  ------------------
16069|      1|	return (0);
16070|       |    /*
16071|       |    * SPEC (2.3.1) "D's {base type definition} must not be the `ur-type
16072|       |    * definition`."
16073|       |    */
16074|      0|    if (WXS_IS_ANYTYPE(type->baseType))
  ------------------
  |  |  209|      0|     (( (i)->type == XML_SCHEMA_TYPE_BASIC) && \
  |  |  ------------------
  |  |  |  Branch (209:7): [True: 0, False: 0]
  |  |  ------------------
  |  |  210|      0|      ( (WXS_TYPE_CAST (i))->builtInType == XML_SCHEMAS_ANYTYPE))
  |  |  ------------------
  |  |  |  |  127|      0|#define WXS_TYPE_CAST (xmlSchemaTypePtr)
  |  |  ------------------
  |  |  |  Branch (210:7): [True: 0, False: 0]
  |  |  ------------------
  ------------------
16075|      0|	return (1);
16076|       |
16077|      0|    if (WXS_IS_COMPLEX(type->baseType)) {
  ------------------
  |  |  213|      0|    (((i)->type == XML_SCHEMA_TYPE_COMPLEX) || \
  |  |  ------------------
  |  |  |  Branch (213:6): [True: 0, False: 0]
  |  |  ------------------
  |  |  214|      0|     ((i)->builtInType == XML_SCHEMAS_ANYTYPE))
  |  |  ------------------
  |  |  |  Branch (214:6): [True: 0, False: 0]
  |  |  ------------------
  ------------------
16078|       |	/*
16079|       |	* SPEC (2.3.2.1) "If D's {base type definition} is complex, then it
16080|       |	* must be validly derived from B given the subset as defined by this
16081|       |	* constraint."
16082|       |	*/
16083|      0|	return (xmlSchemaCheckCOSCTDerivedOK(actxt, type->baseType,
16084|      0|	    baseType, set));
16085|      0|    } else {
16086|       |	/*
16087|       |	* SPEC (2.3.2.2) "If D's {base type definition} is simple, then it
16088|       |	* must be validly derived from B given the subset as defined in Type
16089|       |	* Derivation OK (Simple) ($3.14.6).
16090|       |	*/
16091|      0|	return (xmlSchemaCheckCOSSTDerivedOK(actxt, type->baseType,
16092|      0|	    baseType, set));
16093|      0|    }
16094|      0|}
xmlschemas.c:xmlSchemaAreEqualTypes:
16012|      1|{
16013|       |    /*
16014|       |    * TODO: This should implement component-identity
16015|       |    * in the future.
16016|       |    */
16017|      1|    if ((typeA == NULL) || (typeB == NULL))
  ------------------
  |  Branch (16017:9): [True: 0, False: 1]
  |  Branch (16017:28): [True: 0, False: 1]
  ------------------
16018|      0|	return (0);
16019|      1|    return (typeA == typeB);
16020|      1|}
xmlschemas.c:xmlSchemaParseCheckCOSValidDefault:
15818|      1|{
15819|      1|    int ret = 0;
15820|       |
15821|       |    /*
15822|       |    * cos-valid-default:
15823|       |    * Schema Component Constraint: Element Default Valid (Immediate)
15824|       |    * For a string to be a valid default with respect to a type
15825|       |    * definition the appropriate case among the following must be true:
15826|       |    */
15827|      1|    if WXS_IS_COMPLEX(type) {
  ------------------
  |  |  213|      1|    (((i)->type == XML_SCHEMA_TYPE_COMPLEX) || \
  |  |  ------------------
  |  |  |  Branch (213:6): [True: 0, False: 1]
  |  |  ------------------
  |  |  214|      1|     ((i)->builtInType == XML_SCHEMAS_ANYTYPE))
  |  |  ------------------
  |  |  |  Branch (214:6): [True: 0, False: 1]
  |  |  ------------------
  ------------------
15828|       |	/*
15829|       |	* Complex type.
15830|       |	*
15831|       |	* SPEC (2.1) "its {content type} must be a simple type definition
15832|       |	* or mixed."
15833|       |	* SPEC (2.2.2) "If the {content type} is mixed, then the {content
15834|       |	* type}'s particle must be `emptiable` as defined by
15835|       |	* Particle Emptiable ($3.9.6)."
15836|       |	*/
15837|      0|	if ((! WXS_HAS_SIMPLE_CONTENT(type)) &&
  ------------------
  |  |  251|      0|    ((item->contentType == XML_SCHEMA_CONTENT_SIMPLE) || \
  |  |  ------------------
  |  |  |  Branch (251:6): [True: 0, False: 0]
  |  |  ------------------
  |  |  252|      0|     (item->contentType == XML_SCHEMA_CONTENT_BASIC))
  |  |  ------------------
  |  |  |  Branch (252:6): [True: 0, False: 0]
  |  |  ------------------
  ------------------
15838|      0|	    ((! WXS_HAS_MIXED_CONTENT(type)) || (! WXS_EMPTIABLE(type)))) {
  ------------------
  |  |  255|      0|    (item->contentType == XML_SCHEMA_CONTENT_MIXED)
  ------------------
              	    ((! WXS_HAS_MIXED_CONTENT(type)) || (! WXS_EMPTIABLE(type)))) {
  ------------------
  |  |  258|      0|    (xmlSchemaIsParticleEmptiable(WXS_PTC_CAST (t)->subtypes))
  |  |  ------------------
  |  |  |  |  126|      0|#define WXS_PTC_CAST (xmlSchemaParticlePtr)
  |  |  ------------------
  ------------------
  |  Branch (15838:7): [True: 0, False: 0]
  |  Branch (15838:42): [True: 0, False: 0]
  ------------------
15839|       |	    /* NOTE that this covers (2.2.2) as well. */
15840|      0|	    xmlSchemaPCustomErr(pctxt,
15841|      0|		XML_SCHEMAP_COS_VALID_DEFAULT_2_1,
15842|      0|		WXS_BASIC_CAST type, type->node,
  ------------------
  |  |  124|      0|#define WXS_BASIC_CAST (xmlSchemaBasicItemPtr)
  ------------------
15843|      0|		"For a string to be a valid default, the type definition "
15844|      0|		"must be a simple type or a complex type with mixed content "
15845|      0|		"and a particle emptiable", NULL);
15846|      0|	    return(XML_SCHEMAP_COS_VALID_DEFAULT_2_1);
15847|      0|	}
15848|      0|    }
15849|       |    /*
15850|       |    * 1 If the type definition is a simple type definition, then the string
15851|       |    * must be `valid` with respect to that definition as defined by String
15852|       |    * Valid ($3.14.4).
15853|       |    *
15854|       |    * AND
15855|       |    *
15856|       |    * 2.2.1 If the {content type} is a simple type definition, then the
15857|       |    * string must be `valid` with respect to that simple type definition
15858|       |    * as defined by String Valid ($3.14.4).
15859|       |    */
15860|      1|    if (WXS_IS_SIMPLE(type))
  ------------------
  |  |  217|      1|    ((item->type == XML_SCHEMA_TYPE_SIMPLE) || \
  |  |  ------------------
  |  |  |  Branch (217:6): [True: 0, False: 1]
  |  |  ------------------
  |  |  218|      1|     ((item->type == XML_SCHEMA_TYPE_BASIC) && \
  |  |  ------------------
  |  |  |  Branch (218:7): [True: 1, False: 0]
  |  |  ------------------
  |  |  219|      1|      (item->builtInType != XML_SCHEMAS_ANYTYPE)))
  |  |  ------------------
  |  |  |  Branch (219:7): [True: 1, False: 0]
  |  |  ------------------
  ------------------
15861|      1|	ret = xmlSchemaVCheckCVCSimpleType(ACTXT_CAST pctxt, node,
  ------------------
  |  |  121|      1|#define ACTXT_CAST (xmlSchemaAbstractCtxtPtr)
  ------------------
15862|      1|	    type, value, val, 1, 1, 0);
15863|      0|    else if (WXS_HAS_SIMPLE_CONTENT(type))
  ------------------
  |  |  251|      0|    ((item->contentType == XML_SCHEMA_CONTENT_SIMPLE) || \
  |  |  ------------------
  |  |  |  Branch (251:6): [True: 0, False: 0]
  |  |  ------------------
  |  |  252|      0|     (item->contentType == XML_SCHEMA_CONTENT_BASIC))
  |  |  ------------------
  |  |  |  Branch (252:6): [True: 0, False: 0]
  |  |  ------------------
  ------------------
15864|      0|	ret = xmlSchemaVCheckCVCSimpleType(ACTXT_CAST pctxt, node,
  ------------------
  |  |  121|      0|#define ACTXT_CAST (xmlSchemaAbstractCtxtPtr)
  ------------------
15865|      0|	    type->contentTypeDef, value, val, 1, 1, 0);
15866|      0|    else
15867|      0|	return (ret);
15868|       |
15869|      1|    if (ret < 0) {
  ------------------
  |  Branch (15869:9): [True: 0, False: 1]
  ------------------
15870|      0|	PERROR_INT("xmlSchemaParseCheckCOSValidDefault",
  ------------------
  |  | 2824|      0|#define PERROR_INT(func, msg) xmlSchemaInternalErr(ACTXT_CAST pctxt, func, msg);
  |  |  ------------------
  |  |  |  |  121|      0|#define ACTXT_CAST (xmlSchemaAbstractCtxtPtr)
  |  |  ------------------
  ------------------
15871|      0|	    "calling xmlSchemaVCheckCVCSimpleType()");
15872|      0|    }
15873|       |
15874|      1|    return (ret);
15875|      1|}
xmlschemas.c:xmlSchemaCheckElemSubstGroup:
19710|    553|{
19711|    553|    if ((WXS_SUBST_HEAD(elemDecl) == NULL) ||
  ------------------
  |  |  150|    553|#define WXS_SUBST_HEAD(item) (item)->refDecl
  ------------------
  |  Branch (19711:9): [True: 529, False: 24]
  ------------------
19712|       |	/* SPEC (1) "Its {abstract} is false." */
19713|    553|	(elemDecl->flags & XML_SCHEMAS_ELEM_ABSTRACT))
  ------------------
  |  |  673|     24|#define XML_SCHEMAS_ELEM_ABSTRACT        1 << 4
  ------------------
  |  Branch (19713:2): [True: 0, False: 24]
  ------------------
19714|    529|	return;
19715|     24|    {
19716|     24|	xmlSchemaElementPtr head;
19717|     24|	xmlSchemaTypePtr headType, type;
19718|     24|	int set, methSet;
19719|       |	/*
19720|       |	* SPEC (2) "It is validly substitutable for HEAD subject to HEAD's
19721|       |	* {disallowed substitutions} as the blocking constraint, as defined in
19722|       |	* Substitution Group OK (Transitive) ($3.3.6)."
19723|       |	*/
19724|     48|	for (head = WXS_SUBST_HEAD(elemDecl); head != NULL;
  ------------------
  |  |  150|     24|#define WXS_SUBST_HEAD(item) (item)->refDecl
  ------------------
  |  Branch (19724:40): [True: 24, False: 24]
  ------------------
19725|     24|	    head = WXS_SUBST_HEAD(head)) {
  ------------------
  |  |  150|     24|#define WXS_SUBST_HEAD(item) (item)->refDecl
  ------------------
19726|     24|	    set = 0;
19727|     24|	    methSet = 0;
19728|       |	    /*
19729|       |	    * The blocking constraints.
19730|       |	    */
19731|     24|	    if (head->flags & XML_SCHEMAS_ELEM_BLOCK_SUBSTITUTION)
  ------------------
  |  |  730|     24|#define XML_SCHEMAS_ELEM_BLOCK_SUBSTITUTION        1 << 13
  ------------------
  |  Branch (19731:10): [True: 0, False: 24]
  ------------------
19732|      0|		continue;
19733|     24|	    headType = head->subtypes;
19734|     24|	    type = elemDecl->subtypes;
19735|     24|	    if (headType == type)
  ------------------
  |  Branch (19735:10): [True: 23, False: 1]
  ------------------
19736|     23|		goto add_member;
19737|      1|	    if (head->flags & XML_SCHEMAS_ELEM_BLOCK_RESTRICTION)
  ------------------
  |  |  724|      1|#define XML_SCHEMAS_ELEM_BLOCK_RESTRICTION        1 << 12
  ------------------
  |  Branch (19737:10): [True: 0, False: 1]
  ------------------
19738|      0|		set |= XML_SCHEMAS_TYPE_BLOCK_RESTRICTION;
  ------------------
  |  |  521|      0|#define XML_SCHEMAS_TYPE_BLOCK_RESTRICTION    1 << 19
  ------------------
19739|      1|	    if (head->flags & XML_SCHEMAS_ELEM_BLOCK_EXTENSION)
  ------------------
  |  |  718|      1|#define XML_SCHEMAS_ELEM_BLOCK_EXTENSION        1 << 11
  ------------------
  |  Branch (19739:10): [True: 0, False: 1]
  ------------------
19740|      0|		set |= XML_SCHEMAS_TYPE_BLOCK_EXTENSION;
  ------------------
  |  |  515|      0|#define XML_SCHEMAS_TYPE_BLOCK_EXTENSION    1 << 18
  ------------------
19741|       |	    /*
19742|       |	    * SPEC: Substitution Group OK (Transitive) (2.3)
19743|       |	    * "The set of all {derivation method}s involved in the
19744|       |	    * derivation of D's {type definition} from C's {type definition}
19745|       |	    * does not intersect with the union of the blocking constraint,
19746|       |	    * C's {prohibited substitutions} (if C is complex, otherwise the
19747|       |	    * empty set) and the {prohibited substitutions} (respectively the
19748|       |	    * empty set) of any intermediate {type definition}s in the
19749|       |	    * derivation of D's {type definition} from C's {type definition}."
19750|       |	    */
19751|       |	    /*
19752|       |	    * OPTIMIZE TODO: Optimize this a bit, since, if traversing the
19753|       |	    * subst.head axis, the methSet does not need to be computed for
19754|       |	    * the full depth over and over.
19755|       |	    */
19756|       |	    /*
19757|       |	    * The set of all {derivation method}s involved in the derivation
19758|       |	    */
19759|      2|	    while ((type != NULL) && (type != headType) &&
  ------------------
  |  Branch (19759:13): [True: 2, False: 0]
  |  Branch (19759:31): [True: 1, False: 1]
  ------------------
19760|      2|                   (type != type->baseType)) {
  ------------------
  |  Branch (19760:20): [True: 1, False: 0]
  ------------------
19761|      1|		if ((WXS_IS_EXTENSION(type)) &&
  ------------------
  |  |  229|      1|    ((t)->flags & XML_SCHEMAS_TYPE_DERIVATION_METHOD_EXTENSION)
  |  |  ------------------
  |  |  |  |  414|      1|#define XML_SCHEMAS_TYPE_DERIVATION_METHOD_EXTENSION                1 << 1
  |  |  ------------------
  ------------------
  |  Branch (19761:7): [True: 0, False: 1]
  ------------------
19762|      1|		    ((methSet & XML_SCHEMAS_TYPE_BLOCK_RESTRICTION) == 0))
  ------------------
  |  |  521|      0|#define XML_SCHEMAS_TYPE_BLOCK_RESTRICTION    1 << 19
  ------------------
  |  Branch (19762:7): [True: 0, False: 0]
  ------------------
19763|      0|		    methSet |= XML_SCHEMAS_TYPE_BLOCK_EXTENSION;
  ------------------
  |  |  515|      0|#define XML_SCHEMAS_TYPE_BLOCK_EXTENSION    1 << 18
  ------------------
19764|       |
19765|      1|		if (WXS_IS_RESTRICTION(type) &&
  ------------------
  |  |  226|      2|    ((t)->flags & XML_SCHEMAS_TYPE_DERIVATION_METHOD_RESTRICTION)
  |  |  ------------------
  |  |  |  |  420|      1|#define XML_SCHEMAS_TYPE_DERIVATION_METHOD_RESTRICTION                1 << 2
  |  |  ------------------
  |  |  |  Branch (226:5): [True: 1, False: 0]
  |  |  ------------------
  ------------------
19766|      1|		    ((methSet & XML_SCHEMAS_TYPE_BLOCK_RESTRICTION) == 0))
  ------------------
  |  |  521|      1|#define XML_SCHEMAS_TYPE_BLOCK_RESTRICTION    1 << 19
  ------------------
  |  Branch (19766:7): [True: 1, False: 0]
  ------------------
19767|      1|		    methSet |= XML_SCHEMAS_TYPE_BLOCK_RESTRICTION;
  ------------------
  |  |  521|      1|#define XML_SCHEMAS_TYPE_BLOCK_RESTRICTION    1 << 19
  ------------------
19768|       |
19769|      1|		type = type->baseType;
19770|      1|	    }
19771|       |	    /*
19772|       |	    * The {prohibited substitutions} of all intermediate types +
19773|       |	    * the head's type.
19774|       |	    */
19775|      1|	    type = elemDecl->subtypes->baseType;
19776|      1|	    while (type != NULL) {
  ------------------
  |  Branch (19776:13): [True: 1, False: 0]
  ------------------
19777|      1|		if (WXS_IS_COMPLEX(type)) {
  ------------------
  |  |  213|      1|    (((i)->type == XML_SCHEMA_TYPE_COMPLEX) || \
  |  |  ------------------
  |  |  |  Branch (213:6): [True: 1, False: 0]
  |  |  ------------------
  |  |  214|      1|     ((i)->builtInType == XML_SCHEMAS_ANYTYPE))
  |  |  ------------------
  |  |  |  Branch (214:6): [True: 0, False: 0]
  |  |  ------------------
  ------------------
19778|      1|		    if ((type->flags &
  ------------------
  |  Branch (19778:11): [True: 0, False: 1]
  ------------------
19779|      1|			    XML_SCHEMAS_TYPE_BLOCK_EXTENSION) &&
  ------------------
  |  |  515|      1|#define XML_SCHEMAS_TYPE_BLOCK_EXTENSION    1 << 18
  ------------------
19780|      1|			((set & XML_SCHEMAS_TYPE_BLOCK_EXTENSION) == 0))
  ------------------
  |  |  515|      0|#define XML_SCHEMAS_TYPE_BLOCK_EXTENSION    1 << 18
  ------------------
  |  Branch (19780:4): [True: 0, False: 0]
  ------------------
19781|      0|		    set |= XML_SCHEMAS_TYPE_BLOCK_EXTENSION;
  ------------------
  |  |  515|      0|#define XML_SCHEMAS_TYPE_BLOCK_EXTENSION    1 << 18
  ------------------
19782|      1|		    if ((type->flags &
  ------------------
  |  Branch (19782:11): [True: 0, False: 1]
  ------------------
19783|      1|			    XML_SCHEMAS_TYPE_BLOCK_RESTRICTION) &&
  ------------------
  |  |  521|      1|#define XML_SCHEMAS_TYPE_BLOCK_RESTRICTION    1 << 19
  ------------------
19784|      1|			((set & XML_SCHEMAS_TYPE_BLOCK_RESTRICTION) == 0))
  ------------------
  |  |  521|      0|#define XML_SCHEMAS_TYPE_BLOCK_RESTRICTION    1 << 19
  ------------------
  |  Branch (19784:4): [True: 0, False: 0]
  ------------------
19785|      0|		    set |= XML_SCHEMAS_TYPE_BLOCK_RESTRICTION;
  ------------------
  |  |  521|      0|#define XML_SCHEMAS_TYPE_BLOCK_RESTRICTION    1 << 19
  ------------------
19786|      1|		} else
19787|      0|		    break;
19788|      1|		if (type == headType)
  ------------------
  |  Branch (19788:7): [True: 1, False: 0]
  ------------------
19789|      1|		    break;
19790|      0|		type = type->baseType;
19791|      0|	    }
19792|      1|	    if ((set != 0) &&
  ------------------
  |  Branch (19792:10): [True: 0, False: 1]
  ------------------
19793|      1|		(((set & XML_SCHEMAS_TYPE_BLOCK_EXTENSION) &&
  ------------------
  |  |  515|      0|#define XML_SCHEMAS_TYPE_BLOCK_EXTENSION    1 << 18
  ------------------
  |  Branch (19793:5): [True: 0, False: 0]
  ------------------
19794|      0|		(methSet & XML_SCHEMAS_TYPE_BLOCK_EXTENSION)) ||
  ------------------
  |  |  515|      0|#define XML_SCHEMAS_TYPE_BLOCK_EXTENSION    1 << 18
  ------------------
  |  Branch (19794:3): [True: 0, False: 0]
  ------------------
19795|      0|		((set & XML_SCHEMAS_TYPE_BLOCK_RESTRICTION) &&
  ------------------
  |  |  521|      0|#define XML_SCHEMAS_TYPE_BLOCK_RESTRICTION    1 << 19
  ------------------
  |  Branch (19795:4): [True: 0, False: 0]
  ------------------
19796|      0|		(methSet & XML_SCHEMAS_TYPE_BLOCK_RESTRICTION)))) {
  ------------------
  |  |  521|      0|#define XML_SCHEMAS_TYPE_BLOCK_RESTRICTION    1 << 19
  ------------------
  |  Branch (19796:3): [True: 0, False: 0]
  ------------------
19797|      0|		continue;
19798|      0|	    }
19799|     24|add_member:
19800|     24|	    xmlSchemaAddElementSubstitutionMember(ctxt, head, elemDecl);
19801|     24|	    if ((head->flags & XML_SCHEMAS_ELEM_SUBST_GROUP_HEAD) == 0)
  ------------------
  |  |  754|     24|#define XML_SCHEMAS_ELEM_SUBST_GROUP_HEAD        1 << 17
  ------------------
  |  Branch (19801:10): [True: 6, False: 18]
  ------------------
19802|      6|		head->flags |= XML_SCHEMAS_ELEM_SUBST_GROUP_HEAD;
  ------------------
  |  |  754|      6|#define XML_SCHEMAS_ELEM_SUBST_GROUP_HEAD        1 << 17
  ------------------
19803|     24|	}
19804|     24|    }
19805|     24|}
xmlschemas.c:xmlSchemaAddElementSubstitutionMember:
 5706|     24|{
 5707|     24|    xmlSchemaSubstGroupPtr substGroup = NULL;
 5708|       |
 5709|     24|    if ((pctxt == NULL) || (head == NULL) || (member == NULL))
  ------------------
  |  Branch (5709:9): [True: 0, False: 24]
  |  Branch (5709:28): [True: 0, False: 24]
  |  Branch (5709:46): [True: 0, False: 24]
  ------------------
 5710|      0|	return (-1);
 5711|       |
 5712|     24|    substGroup = xmlSchemaSubstGroupGet(pctxt, head);
 5713|     24|    if (substGroup == NULL)
  ------------------
  |  Branch (5713:9): [True: 6, False: 18]
  ------------------
 5714|      6|	substGroup = xmlSchemaSubstGroupAdd(pctxt, head);
 5715|     24|    if (substGroup == NULL)
  ------------------
  |  Branch (5715:9): [True: 0, False: 24]
  ------------------
 5716|      0|	return(-1);
 5717|     24|    if (xmlSchemaItemListAdd(substGroup->members, member) == -1)
  ------------------
  |  Branch (5717:9): [True: 0, False: 24]
  ------------------
 5718|      0|	return(-1);
 5719|     24|    return(0);
 5720|     24|}
xmlschemas.c:xmlSchemaSubstGroupGet:
 5684|     30|{
 5685|     30|    if (WXS_SUBST_GROUPS(pctxt) == NULL)
  ------------------
  |  |  284|     30|#define WXS_SUBST_GROUPS(ctx) WXS_CONSTRUCTOR((ctx))->substGroups
  |  |  ------------------
  |  |  |  |  278|     30|#define WXS_CONSTRUCTOR(ctx) (ctx)->constructor
  |  |  ------------------
  ------------------
  |  Branch (5685:9): [True: 4, False: 26]
  ------------------
 5686|      4|	return(NULL);
 5687|     26|    return(xmlHashLookup2(WXS_SUBST_GROUPS(pctxt),
  ------------------
  |  |  284|     26|#define WXS_SUBST_GROUPS(ctx) WXS_CONSTRUCTOR((ctx))->substGroups
  |  |  ------------------
  |  |  |  |  278|     26|#define WXS_CONSTRUCTOR(ctx) (ctx)->constructor
  |  |  ------------------
  ------------------
 5688|     26|	head->name, head->targetNamespace));
 5689|       |
 5690|     30|}
xmlschemas.c:xmlSchemaSubstGroupAdd:
 5646|      6|{
 5647|      6|    xmlSchemaSubstGroupPtr ret;
 5648|       |
 5649|       |    /* Init subst group hash. */
 5650|      6|    if (WXS_SUBST_GROUPS(pctxt) == NULL) {
  ------------------
  |  |  284|      6|#define WXS_SUBST_GROUPS(ctx) WXS_CONSTRUCTOR((ctx))->substGroups
  |  |  ------------------
  |  |  |  |  278|      6|#define WXS_CONSTRUCTOR(ctx) (ctx)->constructor
  |  |  ------------------
  ------------------
  |  Branch (5650:9): [True: 4, False: 2]
  ------------------
 5651|      4|	WXS_SUBST_GROUPS(pctxt) = xmlHashCreateDict(10, pctxt->dict);
  ------------------
  |  |  284|      4|#define WXS_SUBST_GROUPS(ctx) WXS_CONSTRUCTOR((ctx))->substGroups
  |  |  ------------------
  |  |  |  |  278|      4|#define WXS_CONSTRUCTOR(ctx) (ctx)->constructor
  |  |  ------------------
  ------------------
 5652|      4|	if (WXS_SUBST_GROUPS(pctxt) == NULL)
  ------------------
  |  |  284|      4|#define WXS_SUBST_GROUPS(ctx) WXS_CONSTRUCTOR((ctx))->substGroups
  |  |  ------------------
  |  |  |  |  278|      4|#define WXS_CONSTRUCTOR(ctx) (ctx)->constructor
  |  |  ------------------
  ------------------
  |  Branch (5652:6): [True: 0, False: 4]
  ------------------
 5653|      0|	    return(NULL);
 5654|      4|    }
 5655|       |    /* Create a new substitution group. */
 5656|      6|    ret = (xmlSchemaSubstGroupPtr) xmlMalloc(sizeof(xmlSchemaSubstGroup));
 5657|      6|    if (ret == NULL) {
  ------------------
  |  Branch (5657:9): [True: 0, False: 6]
  ------------------
 5658|      0|	xmlSchemaPErrMemory(NULL,
 5659|      0|	    "allocating a substitution group container", NULL);
 5660|      0|	return(NULL);
 5661|      0|    }
 5662|      6|    memset(ret, 0, sizeof(xmlSchemaSubstGroup));
 5663|      6|    ret->head = head;
 5664|       |    /* Create list of members. */
 5665|      6|    ret->members = xmlSchemaItemListCreate();
 5666|      6|    if (ret->members == NULL) {
  ------------------
  |  Branch (5666:9): [True: 0, False: 6]
  ------------------
 5667|      0|	xmlSchemaSubstGroupFree(ret);
 5668|      0|	return(NULL);
 5669|      0|    }
 5670|       |    /* Add subst group to hash. */
 5671|      6|    if (xmlHashAddEntry2(WXS_SUBST_GROUPS(pctxt),
  ------------------
  |  |  284|      6|#define WXS_SUBST_GROUPS(ctx) WXS_CONSTRUCTOR((ctx))->substGroups
  |  |  ------------------
  |  |  |  |  278|      6|#define WXS_CONSTRUCTOR(ctx) (ctx)->constructor
  |  |  ------------------
  ------------------
  |  Branch (5671:9): [True: 0, False: 6]
  ------------------
 5672|      6|	head->name, head->targetNamespace, ret) != 0) {
 5673|      0|	PERROR_INT("xmlSchemaSubstGroupAdd",
  ------------------
  |  | 2824|      0|#define PERROR_INT(func, msg) xmlSchemaInternalErr(ACTXT_CAST pctxt, func, msg);
  |  |  ------------------
  |  |  |  |  121|      0|#define ACTXT_CAST (xmlSchemaAbstractCtxtPtr)
  |  |  ------------------
  ------------------
 5674|      0|	    "failed to add a new substitution container");
 5675|      0|	xmlSchemaSubstGroupFree(ret);
 5676|      0|	return(NULL);
 5677|      0|    }
 5678|      6|    return(ret);
 5679|      6|}
xmlschemas.c:xmlSchemaBuildContentModel:
13110|    346|{
13111|    346|    if ((type->type != XML_SCHEMA_TYPE_COMPLEX) ||
  ------------------
  |  Branch (13111:9): [True: 0, False: 346]
  ------------------
13112|    346|	(type->contModel != NULL) ||
  ------------------
  |  Branch (13112:2): [True: 0, False: 346]
  ------------------
13113|    346|	((type->contentType != XML_SCHEMA_CONTENT_ELEMENTS) &&
  ------------------
  |  Branch (13113:3): [True: 166, False: 180]
  ------------------
13114|    346|	(type->contentType != XML_SCHEMA_CONTENT_MIXED)))
  ------------------
  |  Branch (13114:2): [True: 154, False: 12]
  ------------------
13115|    154|	return;
13116|       |
13117|    192|    ctxt->am = NULL;
13118|    192|    ctxt->am = xmlNewAutomata();
13119|    192|    if (ctxt->am == NULL) {
  ------------------
  |  Branch (13119:9): [True: 0, False: 192]
  ------------------
13120|      0|        xmlGenericError(xmlGenericErrorContext,
  ------------------
  |  |  875|      0|  #define xmlGenericError XML_GLOBAL_MACRO(xmlGenericError)
  |  |  ------------------
  |  |  |  |  500|      0|  #define XML_GLOBAL_MACRO(name) (*__##name())
  |  |  ------------------
  ------------------
                      xmlGenericError(xmlGenericErrorContext,
  ------------------
  |  |  876|      0|  #define xmlGenericErrorContext XML_GLOBAL_MACRO(xmlGenericErrorContext)
  |  |  ------------------
  |  |  |  |  500|      0|  #define XML_GLOBAL_MACRO(name) (*__##name())
  |  |  ------------------
  ------------------
13121|      0|	    "Cannot create automata for complex type %s\n", type->name);
13122|      0|        return;
13123|      0|    }
13124|    192|    ctxt->state = xmlAutomataGetInitState(ctxt->am);
13125|       |    /*
13126|       |    * Build the automaton.
13127|       |    */
13128|    192|    xmlSchemaBuildAContentModel(ctxt, WXS_TYPE_PARTICLE(type));
  ------------------
  |  |  262|    192|#define WXS_TYPE_PARTICLE(t) WXS_PTC_CAST (t)->subtypes
  |  |  ------------------
  |  |  |  |  126|    192|#define WXS_PTC_CAST (xmlSchemaParticlePtr)
  |  |  ------------------
  ------------------
13129|    192|    xmlAutomataSetFinalState(ctxt->am, ctxt->state);
13130|    192|    type->contModel = xmlAutomataCompile(ctxt->am);
13131|    192|    if (type->contModel == NULL) {
  ------------------
  |  Branch (13131:9): [True: 0, False: 192]
  ------------------
13132|      0|        xmlSchemaPCustomErr(ctxt,
13133|      0|	    XML_SCHEMAP_INTERNAL,
13134|      0|	    WXS_BASIC_CAST type, type->node,
  ------------------
  |  |  124|      0|#define WXS_BASIC_CAST (xmlSchemaBasicItemPtr)
  ------------------
13135|      0|	    "Failed to compile the content model", NULL);
13136|    192|    } else if (xmlRegexpIsDeterminist(type->contModel) != 1) {
  ------------------
  |  Branch (13136:16): [True: 2, False: 190]
  ------------------
13137|      2|        xmlSchemaPCustomErr(ctxt,
13138|      2|	    XML_SCHEMAP_NOT_DETERMINISTIC,
13139|       |	    /* XML_SCHEMAS_ERR_NOTDETERMINIST, */
13140|      2|	    WXS_BASIC_CAST type, type->node,
  ------------------
  |  |  124|      2|#define WXS_BASIC_CAST (xmlSchemaBasicItemPtr)
  ------------------
13141|      2|	    "The content model is not determinist", NULL);
13142|    190|    } else {
13143|    190|    }
13144|    192|    ctxt->state = NULL;
13145|    192|    xmlFreeAutomata(ctxt->am);
13146|    192|    ctxt->am = NULL;
13147|    192|}
xmlschemas.c:xmlSchemaBuildAContentModel:
12703|    702|{
12704|    702|    int ret = 0, tmp2;
12705|       |
12706|    702|    if (particle == NULL) {
  ------------------
  |  Branch (12706:9): [True: 0, False: 702]
  ------------------
12707|      0|	PERROR_INT("xmlSchemaBuildAContentModel", "particle is NULL");
  ------------------
  |  | 2824|      0|#define PERROR_INT(func, msg) xmlSchemaInternalErr(ACTXT_CAST pctxt, func, msg);
  |  |  ------------------
  |  |  |  |  121|      0|#define ACTXT_CAST (xmlSchemaAbstractCtxtPtr)
  |  |  ------------------
  ------------------
12708|      0|	return(1);
12709|      0|    }
12710|    702|    if (particle->children == NULL) {
  ------------------
  |  Branch (12710:9): [True: 0, False: 702]
  ------------------
12711|       |	/*
12712|       |	* Just return in this case. A missing "term" of the particle
12713|       |	* might arise due to an invalid "term" component.
12714|       |	*/
12715|      0|	return(1);
12716|      0|    }
12717|       |
12718|    702|    switch (particle->children->type) {
12719|     21|	case XML_SCHEMA_TYPE_ANY: {
  ------------------
  |  Branch (12719:2): [True: 21, False: 681]
  ------------------
12720|     21|	    xmlAutomataStatePtr start, end;
12721|     21|	    xmlSchemaWildcardPtr wild;
12722|     21|	    xmlSchemaWildcardNsPtr ns;
12723|       |
12724|     21|	    wild = (xmlSchemaWildcardPtr) particle->children;
12725|       |
12726|     21|	    start = pctxt->state;
12727|     21|	    end = xmlAutomataNewState(pctxt->am);
12728|       |
12729|     21|	    if (particle->maxOccurs == 1) {
  ------------------
  |  Branch (12729:10): [True: 11, False: 10]
  ------------------
12730|     11|		if (wild->any == 1) {
  ------------------
  |  Branch (12730:7): [True: 1, False: 10]
  ------------------
12731|       |		    /*
12732|       |		    * We need to add both transitions:
12733|       |		    *
12734|       |		    * 1. the {"*", "*"} for elements in a namespace.
12735|       |		    */
12736|      1|		    pctxt->state =
12737|      1|			xmlAutomataNewTransition2(pctxt->am,
12738|      1|			start, NULL, BAD_CAST "*", BAD_CAST "*", wild);
  ------------------
  |  |   35|      1|#define BAD_CAST (xmlChar *)
  ------------------
              			start, NULL, BAD_CAST "*", BAD_CAST "*", wild);
  ------------------
  |  |   35|      1|#define BAD_CAST (xmlChar *)
  ------------------
12739|      1|		    xmlAutomataNewEpsilon(pctxt->am, pctxt->state, end);
12740|       |		    /*
12741|       |		    * 2. the {"*"} for elements in no namespace.
12742|       |		    */
12743|      1|		    pctxt->state =
12744|      1|			xmlAutomataNewTransition2(pctxt->am,
12745|      1|			start, NULL, BAD_CAST "*", NULL, wild);
  ------------------
  |  |   35|      1|#define BAD_CAST (xmlChar *)
  ------------------
12746|      1|		    xmlAutomataNewEpsilon(pctxt->am, pctxt->state, end);
12747|       |
12748|     10|		} else if (wild->nsSet != NULL) {
  ------------------
  |  Branch (12748:14): [True: 2, False: 8]
  ------------------
12749|      2|		    ns = wild->nsSet;
12750|      2|		    do {
12751|      2|			pctxt->state = start;
12752|      2|			pctxt->state = xmlAutomataNewTransition2(pctxt->am,
12753|      2|			    pctxt->state, NULL, BAD_CAST "*", ns->value, wild);
  ------------------
  |  |   35|      2|#define BAD_CAST (xmlChar *)
  ------------------
12754|      2|			xmlAutomataNewEpsilon(pctxt->am, pctxt->state, end);
12755|      2|			ns = ns->next;
12756|      2|		    } while (ns != NULL);
  ------------------
  |  Branch (12756:16): [True: 0, False: 2]
  ------------------
12757|       |
12758|      8|		} else if (wild->negNsSet != NULL) {
  ------------------
  |  Branch (12758:14): [True: 8, False: 0]
  ------------------
12759|      8|		    pctxt->state = xmlAutomataNewNegTrans(pctxt->am,
12760|      8|			start, end, BAD_CAST "*", wild->negNsSet->value,
  ------------------
  |  |   35|      8|#define BAD_CAST (xmlChar *)
  ------------------
12761|      8|			wild);
12762|      8|		}
12763|     11|	    } else {
12764|     10|		int counter;
12765|     10|		xmlAutomataStatePtr hop;
12766|     10|		int maxOccurs =
12767|     10|		    particle->maxOccurs == UNBOUNDED ? UNBOUNDED :
  ------------------
  |  |   98|     10|#define UNBOUNDED (1 << 30)
  ------------------
              		    particle->maxOccurs == UNBOUNDED ? UNBOUNDED :
  ------------------
  |  |   98|      4|#define UNBOUNDED (1 << 30)
  ------------------
  |  Branch (12767:7): [True: 4, False: 6]
  ------------------
12768|     10|                                           particle->maxOccurs - 1;
12769|     10|		int minOccurs =
12770|     10|		    particle->minOccurs < 1 ? 0 : particle->minOccurs - 1;
  ------------------
  |  Branch (12770:7): [True: 5, False: 5]
  ------------------
12771|       |
12772|     10|		counter = xmlAutomataNewCounter(pctxt->am, minOccurs, maxOccurs);
12773|     10|		hop = xmlAutomataNewState(pctxt->am);
12774|     10|		if (wild->any == 1) {
  ------------------
  |  Branch (12774:7): [True: 4, False: 6]
  ------------------
12775|      4|		    pctxt->state =
12776|      4|			xmlAutomataNewTransition2(pctxt->am,
12777|      4|			start, NULL, BAD_CAST "*", BAD_CAST "*", wild);
  ------------------
  |  |   35|      4|#define BAD_CAST (xmlChar *)
  ------------------
              			start, NULL, BAD_CAST "*", BAD_CAST "*", wild);
  ------------------
  |  |   35|      4|#define BAD_CAST (xmlChar *)
  ------------------
12778|      4|		    xmlAutomataNewEpsilon(pctxt->am, pctxt->state, hop);
12779|      4|		    pctxt->state =
12780|      4|			xmlAutomataNewTransition2(pctxt->am,
12781|      4|			start, NULL, BAD_CAST "*", NULL, wild);
  ------------------
  |  |   35|      4|#define BAD_CAST (xmlChar *)
  ------------------
12782|      4|		    xmlAutomataNewEpsilon(pctxt->am, pctxt->state, hop);
12783|      6|		} else if (wild->nsSet != NULL) {
  ------------------
  |  Branch (12783:14): [True: 1, False: 5]
  ------------------
12784|      1|		    ns = wild->nsSet;
12785|      3|		    do {
12786|      3|			pctxt->state =
12787|      3|			    xmlAutomataNewTransition2(pctxt->am,
12788|      3|				start, NULL, BAD_CAST "*", ns->value, wild);
  ------------------
  |  |   35|      3|#define BAD_CAST (xmlChar *)
  ------------------
12789|      3|			xmlAutomataNewEpsilon(pctxt->am, pctxt->state, hop);
12790|      3|			ns = ns->next;
12791|      3|		    } while (ns != NULL);
  ------------------
  |  Branch (12791:16): [True: 2, False: 1]
  ------------------
12792|       |
12793|      5|		} else if (wild->negNsSet != NULL) {
  ------------------
  |  Branch (12793:14): [True: 5, False: 0]
  ------------------
12794|      5|		    pctxt->state = xmlAutomataNewNegTrans(pctxt->am,
12795|      5|			start, hop, BAD_CAST "*", wild->negNsSet->value,
  ------------------
  |  |   35|      5|#define BAD_CAST (xmlChar *)
  ------------------
12796|      5|			wild);
12797|      5|		}
12798|     10|		xmlAutomataNewCountedTrans(pctxt->am, hop, start, counter);
12799|     10|		xmlAutomataNewCounterTrans(pctxt->am, hop, end, counter);
12800|     10|	    }
12801|     21|	    if (particle->minOccurs == 0) {
  ------------------
  |  Branch (12801:10): [True: 6, False: 15]
  ------------------
12802|      6|		xmlAutomataNewEpsilon(pctxt->am, start, end);
12803|      6|                ret = 1;
12804|      6|	    }
12805|     21|	    pctxt->state = end;
12806|     21|            break;
12807|      0|	}
12808|    452|        case XML_SCHEMA_TYPE_ELEMENT:
  ------------------
  |  Branch (12808:9): [True: 452, False: 250]
  ------------------
12809|    452|	    ret = xmlSchemaBuildContentModelForElement(pctxt, particle);
12810|    452|	    break;
12811|    181|        case XML_SCHEMA_TYPE_SEQUENCE:{
  ------------------
  |  Branch (12811:9): [True: 181, False: 521]
  ------------------
12812|    181|            xmlSchemaTreeItemPtr sub;
12813|       |
12814|    181|            ret = 1;
12815|       |            /*
12816|       |             * If max and min occurrences are default (1) then
12817|       |             * simply iterate over the particles of the <sequence>.
12818|       |             */
12819|    181|            if ((particle->minOccurs == 1) && (particle->maxOccurs == 1)) {
  ------------------
  |  Branch (12819:17): [True: 170, False: 11]
  |  Branch (12819:47): [True: 163, False: 7]
  ------------------
12820|    163|                sub = particle->children->children;
12821|       |
12822|    541|                while (sub != NULL) {
  ------------------
  |  Branch (12822:24): [True: 378, False: 163]
  ------------------
12823|    378|                    tmp2 = xmlSchemaBuildAContentModel(pctxt,
12824|    378|                                        (xmlSchemaParticlePtr) sub);
12825|    378|                    if (tmp2 != 1) ret = 0;
  ------------------
  |  Branch (12825:25): [True: 249, False: 129]
  ------------------
12826|    378|                    sub = sub->next;
12827|    378|                }
12828|    163|            } else {
12829|     18|                xmlAutomataStatePtr oldstate = pctxt->state;
12830|       |
12831|     18|                if (particle->maxOccurs >= UNBOUNDED) {
  ------------------
  |  |   98|     18|#define UNBOUNDED (1 << 30)
  ------------------
  |  Branch (12831:21): [True: 11, False: 7]
  ------------------
12832|     11|                    if (particle->minOccurs > 1) {
  ------------------
  |  Branch (12832:25): [True: 0, False: 11]
  ------------------
12833|      0|                        xmlAutomataStatePtr tmp;
12834|      0|                        int counter;
12835|       |
12836|      0|                        pctxt->state = xmlAutomataNewEpsilon(pctxt->am,
12837|      0|                            oldstate, NULL);
12838|      0|                        oldstate = pctxt->state;
12839|       |
12840|      0|                        counter = xmlAutomataNewCounter(pctxt->am,
12841|      0|                            particle->minOccurs - 1, UNBOUNDED);
  ------------------
  |  |   98|      0|#define UNBOUNDED (1 << 30)
  ------------------
12842|       |
12843|      0|                        sub = particle->children->children;
12844|      0|                        while (sub != NULL) {
  ------------------
  |  Branch (12844:32): [True: 0, False: 0]
  ------------------
12845|      0|                            tmp2 = xmlSchemaBuildAContentModel(pctxt,
12846|      0|                                            (xmlSchemaParticlePtr) sub);
12847|      0|                            if (tmp2 != 1) ret = 0;
  ------------------
  |  Branch (12847:33): [True: 0, False: 0]
  ------------------
12848|      0|                            sub = sub->next;
12849|      0|                        }
12850|      0|                        tmp = pctxt->state;
12851|      0|                        xmlAutomataNewCountedTrans(pctxt->am, tmp,
12852|      0|                                                   oldstate, counter);
12853|      0|                        pctxt->state =
12854|      0|                            xmlAutomataNewCounterTrans(pctxt->am, tmp,
12855|      0|                                                       NULL, counter);
12856|      0|                        if (ret == 1)
  ------------------
  |  Branch (12856:29): [True: 0, False: 0]
  ------------------
12857|      0|                            xmlAutomataNewEpsilon(pctxt->am,
12858|      0|                                                oldstate, pctxt->state);
12859|       |
12860|     11|                    } else {
12861|     11|                        pctxt->state = xmlAutomataNewEpsilon(pctxt->am,
12862|     11|                            oldstate, NULL);
12863|     11|                        oldstate = pctxt->state;
12864|       |
12865|     11|                        sub = particle->children->children;
12866|     30|                        while (sub != NULL) {
  ------------------
  |  Branch (12866:32): [True: 19, False: 11]
  ------------------
12867|     19|                            tmp2 = xmlSchemaBuildAContentModel(pctxt,
12868|     19|                                        (xmlSchemaParticlePtr) sub);
12869|     19|                            if (tmp2 != 1) ret = 0;
  ------------------
  |  Branch (12869:33): [True: 17, False: 2]
  ------------------
12870|     19|                            sub = sub->next;
12871|     19|                        }
12872|     11|                        xmlAutomataNewEpsilon(pctxt->am, pctxt->state,
12873|     11|                                              oldstate);
12874|       |                        /*
12875|       |                         * epsilon needed to block previous trans from
12876|       |                         * being allowed to enter back from another
12877|       |                         * construct
12878|       |                         */
12879|     11|                        pctxt->state = xmlAutomataNewEpsilon(pctxt->am,
12880|     11|                                            pctxt->state, NULL);
12881|     11|                        if (particle->minOccurs == 0) {
  ------------------
  |  Branch (12881:29): [True: 6, False: 5]
  ------------------
12882|      6|                            xmlAutomataNewEpsilon(pctxt->am,
12883|      6|                                oldstate, pctxt->state);
12884|      6|                            ret = 1;
12885|      6|                        }
12886|     11|                    }
12887|     11|                } else if ((particle->maxOccurs > 1)
  ------------------
  |  Branch (12887:28): [True: 5, False: 2]
  ------------------
12888|      7|                           || (particle->minOccurs > 1)) {
  ------------------
  |  Branch (12888:31): [True: 0, False: 2]
  ------------------
12889|      5|                    xmlAutomataStatePtr tmp;
12890|      5|                    int counter;
12891|       |
12892|      5|                    pctxt->state = xmlAutomataNewEpsilon(pctxt->am,
12893|      5|                        oldstate, NULL);
12894|      5|                    oldstate = pctxt->state;
12895|       |
12896|      5|                    counter = xmlAutomataNewCounter(pctxt->am,
12897|      5|                        particle->minOccurs - 1,
12898|      5|                        particle->maxOccurs - 1);
12899|       |
12900|      5|                    sub = particle->children->children;
12901|     11|                    while (sub != NULL) {
  ------------------
  |  Branch (12901:28): [True: 6, False: 5]
  ------------------
12902|      6|                        tmp2 = xmlSchemaBuildAContentModel(pctxt,
12903|      6|                                        (xmlSchemaParticlePtr) sub);
12904|      6|                        if (tmp2 != 1) ret = 0;
  ------------------
  |  Branch (12904:29): [True: 4, False: 2]
  ------------------
12905|      6|                        sub = sub->next;
12906|      6|                    }
12907|      5|                    tmp = pctxt->state;
12908|      5|                    xmlAutomataNewCountedTrans(pctxt->am,
12909|      5|                        tmp, oldstate, counter);
12910|      5|                    pctxt->state =
12911|      5|                        xmlAutomataNewCounterTrans(pctxt->am, tmp, NULL,
12912|      5|                                                   counter);
12913|      5|                    if ((particle->minOccurs == 0) || (ret == 1)) {
  ------------------
  |  Branch (12913:25): [True: 1, False: 4]
  |  Branch (12913:55): [True: 1, False: 3]
  ------------------
12914|      2|                        xmlAutomataNewEpsilon(pctxt->am,
12915|      2|                                            oldstate, pctxt->state);
12916|      2|                        ret = 1;
12917|      2|                    }
12918|      5|                } else {
12919|      2|                    sub = particle->children->children;
12920|      5|                    while (sub != NULL) {
  ------------------
  |  Branch (12920:28): [True: 3, False: 2]
  ------------------
12921|      3|                        tmp2 = xmlSchemaBuildAContentModel(pctxt,
12922|      3|                                        (xmlSchemaParticlePtr) sub);
12923|      3|                        if (tmp2 != 1) ret = 0;
  ------------------
  |  Branch (12923:29): [True: 1, False: 2]
  ------------------
12924|      3|                        sub = sub->next;
12925|      3|                    }
12926|       |
12927|       |		    /*
12928|       |		     * epsilon needed to block previous trans from
12929|       |		     * being allowed to enter back from another
12930|       |		     * construct
12931|       |		     */
12932|      2|		    pctxt->state = xmlAutomataNewEpsilon(pctxt->am,
12933|      2|					pctxt->state, NULL);
12934|       |
12935|      2|                    if (particle->minOccurs == 0) {
  ------------------
  |  Branch (12935:25): [True: 2, False: 0]
  ------------------
12936|      2|                        xmlAutomataNewEpsilon(pctxt->am, oldstate,
12937|      2|                                              pctxt->state);
12938|      2|                        ret = 1;
12939|      2|                    }
12940|      2|                }
12941|     18|            }
12942|    181|            break;
12943|      0|        }
12944|     37|        case XML_SCHEMA_TYPE_CHOICE:{
  ------------------
  |  Branch (12944:9): [True: 37, False: 665]
  ------------------
12945|     37|            xmlSchemaTreeItemPtr sub;
12946|     37|            xmlAutomataStatePtr start, end;
12947|       |
12948|     37|            ret = 0;
12949|     37|            start = pctxt->state;
12950|     37|            end = xmlAutomataNewState(pctxt->am);
12951|       |
12952|       |            /*
12953|       |             * iterate over the subtypes and remerge the end with an
12954|       |             * epsilon transition
12955|       |             */
12956|     37|            if (particle->maxOccurs == 1) {
  ------------------
  |  Branch (12956:17): [True: 15, False: 22]
  ------------------
12957|     15|                sub = particle->children->children;
12958|     45|                while (sub != NULL) {
  ------------------
  |  Branch (12958:24): [True: 30, False: 15]
  ------------------
12959|     30|                    pctxt->state = start;
12960|     30|                    tmp2 = xmlSchemaBuildAContentModel(pctxt,
12961|     30|                                        (xmlSchemaParticlePtr) sub);
12962|     30|                    if (tmp2 == 1) ret = 1;
  ------------------
  |  Branch (12962:25): [True: 3, False: 27]
  ------------------
12963|     30|                    xmlAutomataNewEpsilon(pctxt->am, pctxt->state, end);
12964|     30|                    sub = sub->next;
12965|     30|                }
12966|     22|            } else {
12967|     22|                int counter;
12968|     22|                xmlAutomataStatePtr hop, base;
12969|     22|                int maxOccurs = particle->maxOccurs == UNBOUNDED ?
  ------------------
  |  |   98|     22|#define UNBOUNDED (1 << 30)
  ------------------
  |  Branch (12969:33): [True: 19, False: 3]
  ------------------
12970|     19|                    UNBOUNDED : particle->maxOccurs - 1;
  ------------------
  |  |   98|     19|#define UNBOUNDED (1 << 30)
  ------------------
12971|     22|                int minOccurs =
12972|     22|                    particle->minOccurs < 1 ? 0 : particle->minOccurs - 1;
  ------------------
  |  Branch (12972:21): [True: 16, False: 6]
  ------------------
12973|       |
12974|       |                /*
12975|       |                 * use a counter to keep track of the number of transitions
12976|       |                 * which went through the choice.
12977|       |                 */
12978|     22|                counter =
12979|     22|                    xmlAutomataNewCounter(pctxt->am, minOccurs, maxOccurs);
12980|     22|                hop = xmlAutomataNewState(pctxt->am);
12981|     22|                base = xmlAutomataNewState(pctxt->am);
12982|       |
12983|     22|                sub = particle->children->children;
12984|     96|                while (sub != NULL) {
  ------------------
  |  Branch (12984:24): [True: 74, False: 22]
  ------------------
12985|     74|                    pctxt->state = base;
12986|     74|                    tmp2 = xmlSchemaBuildAContentModel(pctxt,
12987|     74|                                        (xmlSchemaParticlePtr) sub);
12988|     74|                    if (tmp2 == 1) ret = 1;
  ------------------
  |  Branch (12988:25): [True: 6, False: 68]
  ------------------
12989|     74|                    xmlAutomataNewEpsilon(pctxt->am, pctxt->state, hop);
12990|     74|                    sub = sub->next;
12991|     74|                }
12992|     22|                xmlAutomataNewEpsilon(pctxt->am, start, base);
12993|     22|                xmlAutomataNewCountedTrans(pctxt->am, hop, base, counter);
12994|     22|                xmlAutomataNewCounterTrans(pctxt->am, hop, end, counter);
12995|     22|                if (ret == 1)
  ------------------
  |  Branch (12995:21): [True: 6, False: 16]
  ------------------
12996|      6|                    xmlAutomataNewEpsilon(pctxt->am, base, end);
12997|     22|            }
12998|     37|            if (particle->minOccurs == 0) {
  ------------------
  |  Branch (12998:17): [True: 17, False: 20]
  ------------------
12999|     17|                xmlAutomataNewEpsilon(pctxt->am, start, end);
13000|     17|                ret = 1;
13001|     17|            }
13002|     37|            pctxt->state = end;
13003|     37|            break;
13004|      0|        }
13005|     11|        case XML_SCHEMA_TYPE_ALL:{
  ------------------
  |  Branch (13005:9): [True: 11, False: 691]
  ------------------
13006|     11|            xmlAutomataStatePtr start, tmp;
13007|     11|            xmlSchemaParticlePtr sub;
13008|     11|            xmlSchemaElementPtr elemDecl;
13009|       |
13010|     11|            ret = 1;
13011|       |
13012|     11|            sub = (xmlSchemaParticlePtr) particle->children->children;
13013|     11|            if (sub == NULL)
  ------------------
  |  Branch (13013:17): [True: 0, False: 11]
  ------------------
13014|      0|                break;
13015|       |
13016|     11|            ret = 0;
13017|       |
13018|     11|            start = pctxt->state;
13019|     11|            tmp = xmlAutomataNewState(pctxt->am);
13020|     11|            xmlAutomataNewEpsilon(pctxt->am, pctxt->state, tmp);
13021|     11|            pctxt->state = tmp;
13022|     31|            while (sub != NULL) {
  ------------------
  |  Branch (13022:20): [True: 20, False: 11]
  ------------------
13023|     20|                pctxt->state = tmp;
13024|       |
13025|     20|                elemDecl = (xmlSchemaElementPtr) sub->children;
13026|     20|                if (elemDecl == NULL) {
  ------------------
  |  Branch (13026:21): [True: 0, False: 20]
  ------------------
13027|      0|                    PERROR_INT("xmlSchemaBuildAContentModel",
  ------------------
  |  | 2824|      0|#define PERROR_INT(func, msg) xmlSchemaInternalErr(ACTXT_CAST pctxt, func, msg);
  |  |  ------------------
  |  |  |  |  121|      0|#define ACTXT_CAST (xmlSchemaAbstractCtxtPtr)
  |  |  ------------------
  ------------------
13028|      0|                        "<element> particle has no term");
13029|      0|                    return(ret);
13030|     20|                };
13031|       |                /*
13032|       |                * NOTE: The {max occurs} of all the particles in the
13033|       |                * {particles} of the group must be 0 or 1; this is
13034|       |                * already ensured during the parse of the content of
13035|       |                * <all>.
13036|       |                */
13037|     20|                if (elemDecl->flags & XML_SCHEMAS_ELEM_SUBST_GROUP_HEAD) {
  ------------------
  |  |  754|     20|#define XML_SCHEMAS_ELEM_SUBST_GROUP_HEAD        1 << 17
  ------------------
  |  Branch (13037:21): [True: 4, False: 16]
  ------------------
13038|      4|                    int counter;
13039|       |
13040|       |                    /*
13041|       |                     * This is an abstract group, we need to share
13042|       |                     * the same counter for all the element transitions
13043|       |                     * derived from the group
13044|       |                     */
13045|      4|                    counter = xmlAutomataNewCounter(pctxt->am,
13046|      4|                                       sub->minOccurs, sub->maxOccurs);
13047|      4|                    xmlSchemaBuildContentModelForSubstGroup(pctxt,
13048|      4|                                       sub, counter, pctxt->state);
13049|     16|                } else {
13050|     16|                    if ((sub->minOccurs == 1) &&
  ------------------
  |  Branch (13050:25): [True: 7, False: 9]
  ------------------
13051|     16|                        (sub->maxOccurs == 1)) {
  ------------------
  |  Branch (13051:25): [True: 7, False: 0]
  ------------------
13052|      7|                        xmlAutomataNewOnceTrans2(pctxt->am, pctxt->state,
13053|      7|                                                pctxt->state,
13054|      7|                                                elemDecl->name,
13055|      7|                                                elemDecl->targetNamespace,
13056|      7|                                                1, 1, elemDecl);
13057|      9|                    } else if ((sub->minOccurs == 0) &&
  ------------------
  |  Branch (13057:32): [True: 9, False: 0]
  ------------------
13058|      9|                        (sub->maxOccurs == 1)) {
  ------------------
  |  Branch (13058:25): [True: 9, False: 0]
  ------------------
13059|       |
13060|      9|                        xmlAutomataNewCountTrans2(pctxt->am, pctxt->state,
13061|      9|                                                 pctxt->state,
13062|      9|                                                 elemDecl->name,
13063|      9|                                                 elemDecl->targetNamespace,
13064|      9|                                                 0,
13065|      9|                                                 1,
13066|      9|                                                 elemDecl);
13067|      9|                    }
13068|     16|                }
13069|     20|                sub = (xmlSchemaParticlePtr) sub->next;
13070|     20|            }
13071|     11|            pctxt->state =
13072|     11|                xmlAutomataNewAllTrans(pctxt->am, pctxt->state, NULL, 0);
13073|     11|            if (particle->minOccurs == 0) {
  ------------------
  |  Branch (13073:17): [True: 1, False: 10]
  ------------------
13074|      1|                xmlAutomataNewEpsilon(pctxt->am, start, pctxt->state);
13075|      1|                ret = 1;
13076|      1|            }
13077|     11|            break;
13078|     11|        }
13079|      0|	case XML_SCHEMA_TYPE_GROUP:
  ------------------
  |  Branch (13079:2): [True: 0, False: 702]
  ------------------
13080|       |	    /*
13081|       |	    * If we hit a model group definition, then this means that
13082|       |	    * it was empty, thus was not substituted for the containing
13083|       |	    * model group. Just do nothing in this case.
13084|       |	    * TODO: But the group should be substituted and not occur at
13085|       |	    * all in the content model at this point. Fix this.
13086|       |	    */
13087|      0|            ret = 1;
13088|      0|	    break;
13089|      0|        default:
  ------------------
  |  Branch (13089:9): [True: 0, False: 702]
  ------------------
13090|      0|	    xmlSchemaInternalErr2(ACTXT_CAST pctxt,
  ------------------
  |  |  121|      0|#define ACTXT_CAST (xmlSchemaAbstractCtxtPtr)
  ------------------
13091|      0|		"xmlSchemaBuildAContentModel",
13092|      0|		"found unexpected term of type '%s' in content model",
13093|      0|		WXS_ITEM_TYPE_NAME(particle->children), NULL);
  ------------------
  |  |  144|      0|#define WXS_ITEM_TYPE_NAME(i) xmlSchemaGetComponentTypeStr(WXS_BASIC_CAST (i))
  |  |  ------------------
  |  |  |  |  124|      0|#define WXS_BASIC_CAST (xmlSchemaBasicItemPtr)
  |  |  ------------------
  ------------------
13094|      0|            return(ret);
13095|    702|    }
13096|    702|    return(ret);
13097|    702|}
xmlschemas.c:xmlSchemaBuildContentModelForElement:
12638|    452|{
12639|    452|    int ret = 0;
12640|       |
12641|    452|    if (((xmlSchemaElementPtr) particle->children)->flags &
  ------------------
  |  Branch (12641:9): [True: 2, False: 450]
  ------------------
12642|    452|	XML_SCHEMAS_ELEM_SUBST_GROUP_HEAD) {
  ------------------
  |  |  754|    452|#define XML_SCHEMAS_ELEM_SUBST_GROUP_HEAD        1 << 17
  ------------------
12643|       |	/*
12644|       |	* Substitution groups.
12645|       |	*/
12646|      2|	ret = xmlSchemaBuildContentModelForSubstGroup(ctxt, particle, -1, NULL);
12647|    450|    } else {
12648|    450|	xmlSchemaElementPtr elemDecl;
12649|    450|	xmlAutomataStatePtr start;
12650|       |
12651|    450|	elemDecl = (xmlSchemaElementPtr) particle->children;
12652|       |
12653|    450|	if (elemDecl->flags & XML_SCHEMAS_ELEM_ABSTRACT)
  ------------------
  |  |  673|    450|#define XML_SCHEMAS_ELEM_ABSTRACT        1 << 4
  ------------------
  |  Branch (12653:6): [True: 0, False: 450]
  ------------------
12654|      0|	    return(0);
12655|    450|	if (particle->maxOccurs == 1) {
  ------------------
  |  Branch (12655:6): [True: 371, False: 79]
  ------------------
12656|    371|	    start = ctxt->state;
12657|    371|	    ctxt->state = xmlAutomataNewTransition2(ctxt->am, start, NULL,
12658|    371|		    elemDecl->name, elemDecl->targetNamespace, elemDecl);
12659|    371|	} else if ((particle->maxOccurs >= UNBOUNDED) &&
  ------------------
  |  |   98|     79|#define UNBOUNDED (1 << 30)
  ------------------
  |  Branch (12659:13): [True: 73, False: 6]
  ------------------
12660|     79|	           (particle->minOccurs < 2)) {
  ------------------
  |  Branch (12660:13): [True: 72, False: 1]
  ------------------
12661|       |	    /* Special case. */
12662|     72|	    start = ctxt->state;
12663|     72|	    ctxt->state = xmlAutomataNewTransition2(ctxt->am, start, NULL,
12664|     72|		elemDecl->name, elemDecl->targetNamespace, elemDecl);
12665|     72|	    ctxt->state = xmlAutomataNewTransition2(ctxt->am, ctxt->state, ctxt->state,
12666|     72|		elemDecl->name, elemDecl->targetNamespace, elemDecl);
12667|     72|	} else {
12668|      7|	    int counter;
12669|      7|	    int maxOccurs = particle->maxOccurs == UNBOUNDED ?
  ------------------
  |  |   98|      7|#define UNBOUNDED (1 << 30)
  ------------------
  |  Branch (12669:22): [True: 1, False: 6]
  ------------------
12670|      6|			    UNBOUNDED : particle->maxOccurs - 1;
  ------------------
  |  |   98|      1|#define UNBOUNDED (1 << 30)
  ------------------
12671|      7|	    int minOccurs = particle->minOccurs < 1 ?
  ------------------
  |  Branch (12671:22): [True: 3, False: 4]
  ------------------
12672|      4|			    0 : particle->minOccurs - 1;
12673|       |
12674|      7|	    start = xmlAutomataNewEpsilon(ctxt->am, ctxt->state, NULL);
12675|      7|	    counter = xmlAutomataNewCounter(ctxt->am, minOccurs, maxOccurs);
12676|      7|	    ctxt->state = xmlAutomataNewTransition2(ctxt->am, start, NULL,
12677|      7|		elemDecl->name, elemDecl->targetNamespace, elemDecl);
12678|      7|	    xmlAutomataNewCountedTrans(ctxt->am, ctxt->state, start, counter);
12679|      7|	    ctxt->state = xmlAutomataNewCounterTrans(ctxt->am, ctxt->state,
12680|      7|		NULL, counter);
12681|      7|	}
12682|    450|	if (particle->minOccurs == 0) {
  ------------------
  |  Branch (12682:6): [True: 122, False: 328]
  ------------------
12683|    122|	    xmlAutomataNewEpsilon(ctxt->am, start, ctxt->state);
12684|    122|            ret = 1;
12685|    122|        }
12686|    450|    }
12687|    452|    return(ret);
12688|    452|}
xmlschemas.c:xmlSchemaBuildContentModelForSubstGroup:
12521|      6|{
12522|      6|    xmlAutomataStatePtr start, tmp;
12523|      6|    xmlSchemaElementPtr elemDecl, member;
12524|      6|    xmlSchemaSubstGroupPtr substGroup;
12525|      6|    int i;
12526|      6|    int ret = 0;
12527|       |
12528|      6|    elemDecl = (xmlSchemaElementPtr) particle->children;
12529|       |    /*
12530|       |    * Wrap the substitution group with a CHOICE.
12531|       |    */
12532|      6|    start = pctxt->state;
12533|      6|    if (end == NULL)
  ------------------
  |  Branch (12533:9): [True: 2, False: 4]
  ------------------
12534|      2|	end = xmlAutomataNewState(pctxt->am);
12535|      6|    substGroup = xmlSchemaSubstGroupGet(pctxt, elemDecl);
12536|      6|    if (substGroup == NULL) {
  ------------------
  |  Branch (12536:9): [True: 0, False: 6]
  ------------------
12537|      0|	xmlSchemaPErr(pctxt, WXS_ITEM_NODE(particle),
  ------------------
  |  |  142|      0|#define WXS_ITEM_NODE(i) xmlSchemaGetComponentNode(WXS_BASIC_CAST (i))
  |  |  ------------------
  |  |  |  |  124|      0|#define WXS_BASIC_CAST (xmlSchemaBasicItemPtr)
  |  |  ------------------
  ------------------
12538|      0|	    XML_SCHEMAP_INTERNAL,
12539|      0|	    "Internal error: xmlSchemaBuildContentModelForSubstGroup, "
12540|      0|	    "declaration is marked having a subst. group but none "
12541|      0|	    "available.\n", elemDecl->name, NULL);
12542|      0|	return(0);
12543|      0|    }
12544|      6|    if (counter >= 0) {
  ------------------
  |  Branch (12544:9): [True: 4, False: 2]
  ------------------
12545|       |	/*
12546|       |	* NOTE that we put the declaration in, even if it's abstract.
12547|       |	* However, an error will be raised during *validation* if an element
12548|       |	* information item shall be validated against an abstract element
12549|       |	* declaration.
12550|       |	*/
12551|      4|	tmp = xmlAutomataNewCountedTrans(pctxt->am, start, NULL, counter);
12552|      4|        xmlAutomataNewTransition2(pctxt->am, tmp, end,
12553|      4|	            elemDecl->name, elemDecl->targetNamespace, elemDecl);
12554|       |	/*
12555|       |	* Add subst. group members.
12556|       |	*/
12557|     12|	for (i = 0; i < substGroup->members->nbItems; i++) {
  ------------------
  |  Branch (12557:14): [True: 8, False: 4]
  ------------------
12558|      8|	    member = (xmlSchemaElementPtr) substGroup->members->items[i];
12559|      8|            xmlAutomataNewTransition2(pctxt->am, tmp, end,
12560|      8|		               member->name, member->targetNamespace, member);
12561|      8|	}
12562|      4|    } else if (particle->maxOccurs == 1) {
  ------------------
  |  Branch (12562:16): [True: 2, False: 0]
  ------------------
12563|       |	/*
12564|       |	* NOTE that we put the declaration in, even if it's abstract,
12565|       |	*/
12566|      2|	xmlAutomataNewEpsilon(pctxt->am,
12567|      2|	    xmlAutomataNewTransition2(pctxt->am,
12568|      2|	    start, NULL,
12569|      2|	    elemDecl->name, elemDecl->targetNamespace, elemDecl), end);
12570|       |	/*
12571|       |	* Add subst. group members.
12572|       |	*/
12573|     18|	for (i = 0; i < substGroup->members->nbItems; i++) {
  ------------------
  |  Branch (12573:14): [True: 16, False: 2]
  ------------------
12574|     16|	    member = (xmlSchemaElementPtr) substGroup->members->items[i];
12575|       |	    /*
12576|       |	    * NOTE: This fixes bug #341150. xmlAutomataNewOnceTrans2()
12577|       |	    *  was incorrectly used instead of xmlAutomataNewTransition2()
12578|       |	    *  (seems like a copy&paste bug from the XML_SCHEMA_TYPE_ALL
12579|       |	    *  section in xmlSchemaBuildAContentModel() ).
12580|       |	    * TODO: Check if xmlAutomataNewOnceTrans2() was instead
12581|       |	    *  intended for the above "counter" section originally. I.e.,
12582|       |	    *  check xs:all with subst-groups.
12583|       |	    *
12584|       |	    * tmp = xmlAutomataNewOnceTrans2(pctxt->am, start, NULL,
12585|       |	    *	               member->name, member->targetNamespace,
12586|       |	    *		       1, 1, member);
12587|       |	    */
12588|     16|	    tmp = xmlAutomataNewTransition2(pctxt->am, start, NULL,
12589|     16|		member->name, member->targetNamespace, member);
12590|     16|	    xmlAutomataNewEpsilon(pctxt->am, tmp, end);
12591|     16|	}
12592|      2|    } else {
12593|      0|	xmlAutomataStatePtr hop;
12594|      0|	int maxOccurs = particle->maxOccurs == UNBOUNDED ?
  ------------------
  |  |   98|      0|#define UNBOUNDED (1 << 30)
  ------------------
  |  Branch (12594:18): [True: 0, False: 0]
  ------------------
12595|      0|	    UNBOUNDED : particle->maxOccurs - 1;
  ------------------
  |  |   98|      0|#define UNBOUNDED (1 << 30)
  ------------------
12596|      0|	int minOccurs = particle->minOccurs < 1 ? 0 : particle->minOccurs - 1;
  ------------------
  |  Branch (12596:18): [True: 0, False: 0]
  ------------------
12597|       |
12598|      0|	counter =
12599|      0|	    xmlAutomataNewCounter(pctxt->am, minOccurs,
12600|      0|	    maxOccurs);
12601|      0|	hop = xmlAutomataNewState(pctxt->am);
12602|       |
12603|      0|	xmlAutomataNewEpsilon(pctxt->am,
12604|      0|	    xmlAutomataNewTransition2(pctxt->am,
12605|      0|	    start, NULL,
12606|      0|	    elemDecl->name, elemDecl->targetNamespace, elemDecl),
12607|      0|	    hop);
12608|       |	/*
12609|       |	 * Add subst. group members.
12610|       |	 */
12611|      0|	for (i = 0; i < substGroup->members->nbItems; i++) {
  ------------------
  |  Branch (12611:14): [True: 0, False: 0]
  ------------------
12612|      0|	    member = (xmlSchemaElementPtr) substGroup->members->items[i];
12613|      0|	    xmlAutomataNewEpsilon(pctxt->am,
12614|      0|		xmlAutomataNewTransition2(pctxt->am,
12615|      0|		start, NULL,
12616|      0|		member->name, member->targetNamespace, member),
12617|      0|		hop);
12618|      0|	}
12619|      0|	xmlAutomataNewCountedTrans(pctxt->am, hop, start, counter);
12620|      0|	xmlAutomataNewCounterTrans(pctxt->am, hop, end, counter);
12621|      0|    }
12622|      6|    if (particle->minOccurs == 0) {
  ------------------
  |  Branch (12622:9): [True: 0, False: 6]
  ------------------
12623|      0|	xmlAutomataNewEpsilon(pctxt->am, start, end);
12624|      0|        ret = 1;
12625|      0|    }
12626|      6|    pctxt->state = end;
12627|      6|    return(ret);
12628|      6|}
xmlschemas.c:xmlSchemaVCheckCVCSimpleType:
24450|    178|{
24451|    178|    int ret = 0, valNeeded = (retVal) ? 1 : 0;
  ------------------
  |  Branch (24451:30): [True: 178, False: 0]
  ------------------
24452|    178|    xmlSchemaValPtr val = NULL;
24453|       |    /* xmlSchemaWhitespaceValueType ws; */
24454|    178|    xmlChar *normValue = NULL;
24455|       |
24456|    178|#define NORMALIZE(atype) \
24457|    178|    if ((! isNormalized) && \
24458|    178|    (normalize || (type->flags & XML_SCHEMAS_TYPE_NORMVALUENEEDED))) { \
24459|    178|	normValue = xmlSchemaNormalizeValue(atype, value); \
24460|    178|	if (normValue != NULL) \
24461|    178|	    value = normValue; \
24462|    178|	isNormalized = 1; \
24463|    178|    }
24464|       |
24465|    178|    if ((retVal != NULL) && (*retVal != NULL)) {
  ------------------
  |  Branch (24465:9): [True: 178, False: 0]
  |  Branch (24465:29): [True: 0, False: 178]
  ------------------
24466|      0|	xmlSchemaFreeValue(*retVal);
24467|      0|	*retVal = NULL;
24468|      0|    }
24469|       |    /*
24470|       |    * 3.14.4 Simple Type Definition Validation Rules
24471|       |    * Validation Rule: String Valid
24472|       |    */
24473|       |    /*
24474|       |    * 1 It is schema-valid with respect to that definition as defined
24475|       |    * by Datatype Valid in [XML Schemas: Datatypes].
24476|       |    */
24477|       |    /*
24478|       |    * 2.1 If The definition is ENTITY or is validly derived from ENTITY given
24479|       |    * the empty set, as defined in Type Derivation OK (Simple) ($3.14.6), then
24480|       |    * the string must be a `declared entity name`.
24481|       |    */
24482|       |    /*
24483|       |    * 2.2 If The definition is ENTITIES or is validly derived from ENTITIES
24484|       |    * given the empty set, as defined in Type Derivation OK (Simple) ($3.14.6),
24485|       |    * then every whitespace-delimited substring of the string must be a `declared
24486|       |    * entity name`.
24487|       |    */
24488|       |    /*
24489|       |    * 2.3 otherwise no further condition applies.
24490|       |    */
24491|    178|    if ((! valNeeded) && (type->flags & XML_SCHEMAS_TYPE_FACETSNEEDVALUE))
  ------------------
  |  |  533|      0|#define XML_SCHEMAS_TYPE_FACETSNEEDVALUE    1 << 21
  ------------------
  |  Branch (24491:9): [True: 0, False: 178]
  |  Branch (24491:26): [True: 0, False: 0]
  ------------------
24492|      0|	valNeeded = 1;
24493|    178|    if (value == NULL)
  ------------------
  |  Branch (24493:9): [True: 0, False: 178]
  ------------------
24494|      0|	value = BAD_CAST "";
  ------------------
  |  |   35|      0|#define BAD_CAST (xmlChar *)
  ------------------
24495|    178|    if (WXS_IS_ANY_SIMPLE_TYPE(type) || WXS_IS_ATOMIC(type)) {
  ------------------
  |  |  222|    356|    (((i)->type == XML_SCHEMA_TYPE_BASIC) && \
  |  |  ------------------
  |  |  |  Branch (222:6): [True: 167, False: 11]
  |  |  ------------------
  |  |  223|    356|      ((i)->builtInType == XML_SCHEMAS_ANYSIMPLETYPE))
  |  |  ------------------
  |  |  |  Branch (223:7): [True: 0, False: 167]
  |  |  ------------------
  ------------------
                  if (WXS_IS_ANY_SIMPLE_TYPE(type) || WXS_IS_ATOMIC(type)) {
  ------------------
  |  |  270|    178|#define WXS_IS_ATOMIC(t) (t->flags & XML_SCHEMAS_TYPE_VARIETY_ATOMIC)
  |  |  ------------------
  |  |  |  |  460|    178|#define XML_SCHEMAS_TYPE_VARIETY_ATOMIC    1 << 8
  |  |  ------------------
  |  |  |  Branch (270:26): [True: 177, False: 1]
  |  |  ------------------
  ------------------
24496|    177|	xmlSchemaTypePtr biType; /* The built-in type. */
24497|       |	/*
24498|       |	* SPEC (1.2.1) "if {variety} is `atomic` then the string must `match`
24499|       |	* a literal in the `lexical space` of {base type definition}"
24500|       |	*/
24501|       |	/*
24502|       |	* Whitespace-normalize.
24503|       |	*/
24504|    177|	NORMALIZE(type);
  ------------------
  |  |24457|    177|    if ((! isNormalized) && \
  |  |  ------------------
  |  |  |  Branch (24457:9): [True: 177, False: 0]
  |  |  ------------------
  |  |24458|    177|    (normalize || (type->flags & XML_SCHEMAS_TYPE_NORMVALUENEEDED))) { \
  |  |  ------------------
  |  |  |  |  575|      0|#define XML_SCHEMAS_TYPE_NORMVALUENEEDED    1 << 28
  |  |  ------------------
  |  |  |  Branch (24458:6): [True: 177, False: 0]
  |  |  |  Branch (24458:19): [True: 0, False: 0]
  |  |  ------------------
  |  |24459|    177|	normValue = xmlSchemaNormalizeValue(atype, value); \
  |  |24460|    177|	if (normValue != NULL) \
  |  |  ------------------
  |  |  |  Branch (24460:6): [True: 0, False: 177]
  |  |  ------------------
  |  |24461|    177|	    value = normValue; \
  |  |24462|    177|	isNormalized = 1; \
  |  |24463|    177|    }
  ------------------
24505|    177|	if (type->type != XML_SCHEMA_TYPE_BASIC) {
  ------------------
  |  Branch (24505:6): [True: 10, False: 167]
  ------------------
24506|       |	    /*
24507|       |	    * Get the built-in type.
24508|       |	    */
24509|     10|	    biType = type->baseType;
24510|     10|	    while ((biType != NULL) &&
  ------------------
  |  Branch (24510:13): [True: 10, False: 0]
  ------------------
24511|     10|		(biType->type != XML_SCHEMA_TYPE_BASIC))
  ------------------
  |  Branch (24511:3): [True: 0, False: 10]
  ------------------
24512|      0|		biType = biType->baseType;
24513|       |
24514|     10|	    if (biType == NULL) {
  ------------------
  |  Branch (24514:10): [True: 0, False: 10]
  ------------------
24515|      0|		AERROR_INT("xmlSchemaVCheckCVCSimpleType",
  ------------------
  |  | 2827|      0|#define AERROR_INT(func, msg) xmlSchemaInternalErr(actxt, func, msg);
  ------------------
24516|      0|		    "could not get the built-in type");
24517|      0|		goto internal_error;
24518|      0|	    }
24519|     10|	} else
24520|    167|	    biType = type;
24521|       |	/*
24522|       |	* NOTATIONs need to be processed here, since they need
24523|       |	* to lookup in the hashtable of NOTATION declarations of the schema.
24524|       |	*/
24525|    177|	if (actxt->type == XML_SCHEMA_CTXT_VALIDATOR) {
  ------------------
  |  |  359|    177|#define XML_SCHEMA_CTXT_VALIDATOR 2
  ------------------
  |  Branch (24525:6): [True: 0, False: 177]
  ------------------
24526|      0|	    switch (biType->builtInType) {
24527|      0|		case XML_SCHEMAS_NOTATION:
  ------------------
  |  Branch (24527:3): [True: 0, False: 0]
  ------------------
24528|      0|		    ret = xmlSchemaValidateNotation(
24529|      0|			(xmlSchemaValidCtxtPtr) actxt,
24530|      0|			((xmlSchemaValidCtxtPtr) actxt)->schema,
24531|      0|			NULL, value, &val, valNeeded);
24532|      0|		    break;
24533|      0|		case XML_SCHEMAS_QNAME:
  ------------------
  |  Branch (24533:3): [True: 0, False: 0]
  ------------------
24534|      0|		    ret = xmlSchemaValidateQName((xmlSchemaValidCtxtPtr) actxt,
24535|      0|			value, &val, valNeeded);
24536|      0|		    break;
24537|      0|		default:
  ------------------
  |  Branch (24537:3): [True: 0, False: 0]
  ------------------
24538|       |		    /* ws = xmlSchemaGetWhiteSpaceFacetValue(type); */
24539|      0|		    if (valNeeded)
  ------------------
  |  Branch (24539:11): [True: 0, False: 0]
  ------------------
24540|      0|			ret = xmlSchemaValPredefTypeNodeNoNorm(biType,
24541|      0|			    value, &val, node);
24542|      0|		    else
24543|      0|			ret = xmlSchemaValPredefTypeNodeNoNorm(biType,
24544|      0|			    value, NULL, node);
24545|      0|		    break;
24546|      0|	    }
24547|    177|	} else if (actxt->type == XML_SCHEMA_CTXT_PARSER) {
  ------------------
  |  |  358|    177|#define XML_SCHEMA_CTXT_PARSER 1
  ------------------
  |  Branch (24547:13): [True: 177, False: 0]
  ------------------
24548|    177|	    switch (biType->builtInType) {
24549|      0|		case XML_SCHEMAS_NOTATION:
  ------------------
  |  Branch (24549:3): [True: 0, False: 177]
  ------------------
24550|      0|		    ret = xmlSchemaValidateNotation(NULL,
24551|      0|			((xmlSchemaParserCtxtPtr) actxt)->schema, node,
24552|      0|			value, &val, valNeeded);
24553|      0|		    break;
24554|    177|		default:
  ------------------
  |  Branch (24554:3): [True: 177, False: 0]
  ------------------
24555|       |		    /* ws = xmlSchemaGetWhiteSpaceFacetValue(type); */
24556|    177|		    if (valNeeded)
  ------------------
  |  Branch (24556:11): [True: 177, False: 0]
  ------------------
24557|    177|			ret = xmlSchemaValPredefTypeNodeNoNorm(biType,
24558|    177|			    value, &val, node);
24559|      0|		    else
24560|      0|			ret = xmlSchemaValPredefTypeNodeNoNorm(biType,
24561|      0|			    value, NULL, node);
24562|    177|		    break;
24563|    177|	    }
24564|    177|	} else {
24565|       |	    /*
24566|       |	    * Validation via a public API is not implemented yet.
24567|       |	    */
24568|      0|	    TODO
  ------------------
  |  |  100|      0|    xmlGenericError(xmlGenericErrorContext,				\
  |  |  ------------------
  |  |  |  |  875|      0|  #define xmlGenericError XML_GLOBAL_MACRO(xmlGenericError)
  |  |  |  |  ------------------
  |  |  |  |  |  |  500|      0|  #define XML_GLOBAL_MACRO(name) (*__##name())
  |  |  |  |  ------------------
  |  |  ------------------
  |  |                   xmlGenericError(xmlGenericErrorContext,				\
  |  |  ------------------
  |  |  |  |  876|      0|  #define xmlGenericErrorContext XML_GLOBAL_MACRO(xmlGenericErrorContext)
  |  |  |  |  ------------------
  |  |  |  |  |  |  500|      0|  #define XML_GLOBAL_MACRO(name) (*__##name())
  |  |  |  |  ------------------
  |  |  ------------------
  |  |  101|      0|	    "Unimplemented block at %s:%d\n",				\
  |  |  102|      0|            __FILE__, __LINE__);
  ------------------
24569|      0|	    goto internal_error;
24570|      0|	}
24571|    177|	if (ret != 0) {
  ------------------
  |  Branch (24571:6): [True: 0, False: 177]
  ------------------
24572|      0|	    if (ret < 0) {
  ------------------
  |  Branch (24572:10): [True: 0, False: 0]
  ------------------
24573|      0|		AERROR_INT("xmlSchemaVCheckCVCSimpleType",
  ------------------
  |  | 2827|      0|#define AERROR_INT(func, msg) xmlSchemaInternalErr(actxt, func, msg);
  ------------------
24574|      0|		    "validating against a built-in type");
24575|      0|		goto internal_error;
24576|      0|	    }
24577|      0|	    if (WXS_IS_LIST(type))
  ------------------
  |  |  272|      0|#define WXS_IS_LIST(t) (t->flags & XML_SCHEMAS_TYPE_VARIETY_LIST)
  |  |  ------------------
  |  |  |  |  448|      0|#define XML_SCHEMAS_TYPE_VARIETY_LIST    1 << 6
  |  |  ------------------
  |  |  |  Branch (272:24): [True: 0, False: 0]
  |  |  ------------------
  ------------------
24578|      0|		ret = XML_SCHEMAV_CVC_DATATYPE_VALID_1_2_2;
24579|      0|	    else
24580|      0|		ret = XML_SCHEMAV_CVC_DATATYPE_VALID_1_2_1;
24581|      0|	}
24582|    177|	if ((ret == 0) && (type->flags & XML_SCHEMAS_TYPE_HAS_FACETS)) {
  ------------------
  |  |  569|    177|#define XML_SCHEMAS_TYPE_HAS_FACETS    1 << 27
  ------------------
  |  Branch (24582:6): [True: 177, False: 0]
  |  Branch (24582:20): [True: 10, False: 167]
  ------------------
24583|       |	    /*
24584|       |	    * Check facets.
24585|       |	    */
24586|     10|	    ret = xmlSchemaValidateFacets(actxt, node, type,
24587|     10|		(xmlSchemaValType) biType->builtInType, value, val,
24588|     10|		0, fireErrors);
24589|     10|	    if (ret != 0) {
  ------------------
  |  Branch (24589:10): [True: 0, False: 10]
  ------------------
24590|      0|		if (ret < 0) {
  ------------------
  |  Branch (24590:7): [True: 0, False: 0]
  ------------------
24591|      0|		    AERROR_INT("xmlSchemaVCheckCVCSimpleType",
  ------------------
  |  | 2827|      0|#define AERROR_INT(func, msg) xmlSchemaInternalErr(actxt, func, msg);
  ------------------
24592|      0|			"validating facets of atomic simple type");
24593|      0|		    goto internal_error;
24594|      0|		}
24595|      0|		if (WXS_IS_LIST(type))
  ------------------
  |  |  272|      0|#define WXS_IS_LIST(t) (t->flags & XML_SCHEMAS_TYPE_VARIETY_LIST)
  |  |  ------------------
  |  |  |  |  448|      0|#define XML_SCHEMAS_TYPE_VARIETY_LIST    1 << 6
  |  |  ------------------
  |  |  |  Branch (272:24): [True: 0, False: 0]
  |  |  ------------------
  ------------------
24596|      0|		    ret = XML_SCHEMAV_CVC_DATATYPE_VALID_1_2_2;
24597|      0|		else
24598|      0|		    ret = XML_SCHEMAV_CVC_DATATYPE_VALID_1_2_1;
24599|      0|	    }
24600|     10|	}
24601|    167|	else if (fireErrors && (ret > 0))
  ------------------
  |  Branch (24601:11): [True: 167, False: 0]
  |  Branch (24601:25): [True: 0, False: 167]
  ------------------
24602|      0|	    xmlSchemaSimpleTypeErr(actxt, ret, node, value, type, 1);
24603|    177|    } else if (WXS_IS_LIST(type)) {
  ------------------
  |  |  272|      1|#define WXS_IS_LIST(t) (t->flags & XML_SCHEMAS_TYPE_VARIETY_LIST)
  |  |  ------------------
  |  |  |  |  448|      1|#define XML_SCHEMAS_TYPE_VARIETY_LIST    1 << 6
  |  |  ------------------
  |  |  |  Branch (272:24): [True: 0, False: 1]
  |  |  ------------------
  ------------------
24604|       |
24605|      0|	xmlSchemaTypePtr itemType;
24606|      0|	const xmlChar *cur, *end;
24607|      0|	xmlChar *tmpValue = NULL;
24608|      0|	unsigned long len = 0;
24609|      0|	xmlSchemaValPtr prevVal = NULL, curVal = NULL;
24610|       |	/* 1.2.2 if {variety} is `list` then the string must be a sequence
24611|       |	* of white space separated tokens, each of which `match`es a literal
24612|       |	* in the `lexical space` of {item type definition}
24613|       |	*/
24614|       |	/*
24615|       |	* Note that XML_SCHEMAS_TYPE_NORMVALUENEEDED will be set if
24616|       |	* the list type has an enum or pattern facet.
24617|       |	*/
24618|      0|	NORMALIZE(type);
  ------------------
  |  |24457|      0|    if ((! isNormalized) && \
  |  |  ------------------
  |  |  |  Branch (24457:9): [True: 0, False: 0]
  |  |  ------------------
  |  |24458|      0|    (normalize || (type->flags & XML_SCHEMAS_TYPE_NORMVALUENEEDED))) { \
  |  |  ------------------
  |  |  |  |  575|      0|#define XML_SCHEMAS_TYPE_NORMVALUENEEDED    1 << 28
  |  |  ------------------
  |  |  |  Branch (24458:6): [True: 0, False: 0]
  |  |  |  Branch (24458:19): [True: 0, False: 0]
  |  |  ------------------
  |  |24459|      0|	normValue = xmlSchemaNormalizeValue(atype, value); \
  |  |24460|      0|	if (normValue != NULL) \
  |  |  ------------------
  |  |  |  Branch (24460:6): [True: 0, False: 0]
  |  |  ------------------
  |  |24461|      0|	    value = normValue; \
  |  |24462|      0|	isNormalized = 1; \
  |  |24463|      0|    }
  ------------------
24619|       |	/*
24620|       |	* VAL TODO: Optimize validation of empty values.
24621|       |	* VAL TODO: We do not have computed values for lists.
24622|       |	*/
24623|      0|	itemType = WXS_LIST_ITEMTYPE(type);
  ------------------
  |  |  268|      0|#define WXS_LIST_ITEMTYPE(t) (t)->subtypes
  ------------------
24624|      0|	cur = value;
24625|      0|	do {
24626|      0|	    while (IS_BLANK_CH(*cur))
24627|      0|		cur++;
24628|      0|	    end = cur;
24629|      0|	    while ((*end != 0) && (!(IS_BLANK_CH(*end))))
  ------------------
  |  |  151|      0|#define IS_BLANK_CH(c)  xmlIsBlank_ch(c)
  |  |  ------------------
  |  |  |  |   88|      0|#define xmlIsBlank_ch(c)	(((c) == 0x20) || \
  |  |  |  |  ------------------
  |  |  |  |  |  Branch (88:27): [True: 0, False: 0]
  |  |  |  |  ------------------
  |  |  |  |   89|      0|				 ((0x9 <= (c)) && ((c) <= 0xa)) || \
  |  |  |  |  ------------------
  |  |  |  |  |  Branch (89:7): [True: 0, False: 0]
  |  |  |  |  |  Branch (89:23): [True: 0, False: 0]
  |  |  |  |  ------------------
  |  |  |  |   90|      0|				 ((c) == 0xd))
  |  |  |  |  ------------------
  |  |  |  |  |  Branch (90:6): [True: 0, False: 0]
  |  |  |  |  ------------------
  |  |  ------------------
  ------------------
  |  Branch (24629:13): [True: 0, False: 0]
  ------------------
24630|      0|		end++;
24631|      0|	    if (end == cur)
  ------------------
  |  Branch (24631:10): [True: 0, False: 0]
  ------------------
24632|      0|		break;
24633|      0|	    tmpValue = xmlStrndup(cur, end - cur);
24634|      0|	    len++;
24635|       |
24636|      0|	    if (valNeeded)
  ------------------
  |  Branch (24636:10): [True: 0, False: 0]
  ------------------
24637|      0|		ret = xmlSchemaVCheckCVCSimpleType(actxt, node, itemType,
24638|      0|		    tmpValue, &curVal, fireErrors, 0, 1);
24639|      0|	    else
24640|      0|		ret = xmlSchemaVCheckCVCSimpleType(actxt, node, itemType,
24641|      0|		    tmpValue, NULL, fireErrors, 0, 1);
24642|      0|	    FREE_AND_NULL(tmpValue);
  ------------------
  |  |  320|      0|#define FREE_AND_NULL(str) if ((str) != NULL) { xmlFree((xmlChar *) (str)); str = NULL; }
  |  |  ------------------
  |  |  |  Branch (320:32): [True: 0, False: 0]
  |  |  ------------------
  ------------------
24643|      0|	    if (curVal != NULL) {
  ------------------
  |  Branch (24643:10): [True: 0, False: 0]
  ------------------
24644|       |		/*
24645|       |		* Add to list of computed values.
24646|       |		*/
24647|      0|		if (val == NULL)
  ------------------
  |  Branch (24647:7): [True: 0, False: 0]
  ------------------
24648|      0|		    val = curVal;
24649|      0|		else
24650|      0|		    xmlSchemaValueAppend(prevVal, curVal);
24651|      0|		prevVal = curVal;
24652|      0|		curVal = NULL;
24653|      0|	    }
24654|      0|	    if (ret != 0) {
  ------------------
  |  Branch (24654:10): [True: 0, False: 0]
  ------------------
24655|      0|		if (ret < 0) {
  ------------------
  |  Branch (24655:7): [True: 0, False: 0]
  ------------------
24656|      0|		    AERROR_INT("xmlSchemaVCheckCVCSimpleType",
  ------------------
  |  | 2827|      0|#define AERROR_INT(func, msg) xmlSchemaInternalErr(actxt, func, msg);
  ------------------
24657|      0|			"validating an item of list simple type");
24658|      0|		    goto internal_error;
24659|      0|		}
24660|      0|		ret = XML_SCHEMAV_CVC_DATATYPE_VALID_1_2_2;
24661|      0|		break;
24662|      0|	    }
24663|      0|	    cur = end;
24664|      0|	} while (*cur != 0);
  ------------------
  |  Branch (24664:11): [True: 0, False: 0]
  ------------------
24665|      0|	FREE_AND_NULL(tmpValue);
  ------------------
  |  |  320|      0|#define FREE_AND_NULL(str) if ((str) != NULL) { xmlFree((xmlChar *) (str)); str = NULL; }
  |  |  ------------------
  |  |  |  Branch (320:32): [True: 0, False: 0]
  |  |  ------------------
  ------------------
24666|      0|	if ((ret == 0) && (type->flags & XML_SCHEMAS_TYPE_HAS_FACETS)) {
  ------------------
  |  |  569|      0|#define XML_SCHEMAS_TYPE_HAS_FACETS    1 << 27
  ------------------
  |  Branch (24666:6): [True: 0, False: 0]
  |  Branch (24666:20): [True: 0, False: 0]
  ------------------
24667|       |	    /*
24668|       |	    * Apply facets (pattern, enumeration).
24669|       |	    */
24670|      0|	    ret = xmlSchemaValidateFacets(actxt, node, type,
24671|      0|		XML_SCHEMAS_UNKNOWN, value, val,
24672|      0|		len, fireErrors);
24673|      0|	    if (ret != 0) {
  ------------------
  |  Branch (24673:10): [True: 0, False: 0]
  ------------------
24674|      0|		if (ret < 0) {
  ------------------
  |  Branch (24674:7): [True: 0, False: 0]
  ------------------
24675|      0|		    AERROR_INT("xmlSchemaVCheckCVCSimpleType",
  ------------------
  |  | 2827|      0|#define AERROR_INT(func, msg) xmlSchemaInternalErr(actxt, func, msg);
  ------------------
24676|      0|			"validating facets of list simple type");
24677|      0|		    goto internal_error;
24678|      0|		}
24679|      0|		ret = XML_SCHEMAV_CVC_DATATYPE_VALID_1_2_2;
24680|      0|	    }
24681|      0|	}
24682|      0|	if (fireErrors && (ret > 0)) {
  ------------------
  |  Branch (24682:6): [True: 0, False: 0]
  |  Branch (24682:20): [True: 0, False: 0]
  ------------------
24683|       |	    /*
24684|       |	    * Report the normalized value.
24685|       |	    */
24686|      0|	    normalize = 1;
24687|      0|	    NORMALIZE(type);
  ------------------
  |  |24457|      0|    if ((! isNormalized) && \
  |  |  ------------------
  |  |  |  Branch (24457:9): [True: 0, False: 0]
  |  |  ------------------
  |  |24458|      0|    (normalize || (type->flags & XML_SCHEMAS_TYPE_NORMVALUENEEDED))) { \
  |  |  ------------------
  |  |  |  |  575|      0|#define XML_SCHEMAS_TYPE_NORMVALUENEEDED    1 << 28
  |  |  ------------------
  |  |  |  Branch (24458:6): [True: 0, False: 0]
  |  |  |  Branch (24458:19): [True: 0, False: 0]
  |  |  ------------------
  |  |24459|      0|	normValue = xmlSchemaNormalizeValue(atype, value); \
  |  |24460|      0|	if (normValue != NULL) \
  |  |  ------------------
  |  |  |  Branch (24460:6): [True: 0, False: 0]
  |  |  ------------------
  |  |24461|      0|	    value = normValue; \
  |  |24462|      0|	isNormalized = 1; \
  |  |24463|      0|    }
  ------------------
24688|      0|	    xmlSchemaSimpleTypeErr(actxt, ret, node, value, type, 1);
24689|      0|	}
24690|      1|    } else if (WXS_IS_UNION(type)) {
  ------------------
  |  |  274|      1|#define WXS_IS_UNION(t) (t->flags & XML_SCHEMAS_TYPE_VARIETY_UNION)
  |  |  ------------------
  |  |  |  |  454|      1|#define XML_SCHEMAS_TYPE_VARIETY_UNION    1 << 7
  |  |  ------------------
  |  |  |  Branch (274:25): [True: 1, False: 0]
  |  |  ------------------
  ------------------
24691|      1|	xmlSchemaTypeLinkPtr memberLink;
24692|       |	/*
24693|       |	* TODO: For all datatypes `derived` by `union`  whiteSpace does
24694|       |	* not apply directly; however, the normalization behavior of `union`
24695|       |	* types is controlled by the value of whiteSpace on that one of the
24696|       |	* `memberTypes` against which the `union` is successfully validated.
24697|       |	*
24698|       |	* This means that the value is normalized by the first validating
24699|       |	* member type, then the facets of the union type are applied. This
24700|       |	* needs changing of the value!
24701|       |	*/
24702|       |
24703|       |	/*
24704|       |	* 1.2.3 if {variety} is `union` then the string must `match` a
24705|       |	* literal in the `lexical space` of at least one member of
24706|       |	* {member type definitions}
24707|       |	*/
24708|      1|	memberLink = xmlSchemaGetUnionSimpleTypeMemberTypes(type);
24709|      1|	if (memberLink == NULL) {
  ------------------
  |  Branch (24709:6): [True: 0, False: 1]
  ------------------
24710|      0|	    AERROR_INT("xmlSchemaVCheckCVCSimpleType",
  ------------------
  |  | 2827|      0|#define AERROR_INT(func, msg) xmlSchemaInternalErr(actxt, func, msg);
  ------------------
24711|      0|		"union simple type has no member types");
24712|      0|	    goto internal_error;
24713|      0|	}
24714|       |	/*
24715|       |	* Always normalize union type values, since we currently
24716|       |	* cannot store the whitespace information with the value
24717|       |	* itself; otherwise a later value-comparison would be
24718|       |	* not possible.
24719|       |	*/
24720|      1|	while (memberLink != NULL) {
  ------------------
  |  Branch (24720:9): [True: 1, False: 0]
  ------------------
24721|      1|	    if (valNeeded)
  ------------------
  |  Branch (24721:10): [True: 1, False: 0]
  ------------------
24722|      1|		ret = xmlSchemaVCheckCVCSimpleType(actxt, node,
24723|      1|		    memberLink->type, value, &val, 0, 1, 0);
24724|      0|	    else
24725|      0|		ret = xmlSchemaVCheckCVCSimpleType(actxt, node,
24726|      0|		    memberLink->type, value, NULL, 0, 1, 0);
24727|      1|	    if (ret <= 0)
  ------------------
  |  Branch (24727:10): [True: 1, False: 0]
  ------------------
24728|      1|		break;
24729|      0|	    memberLink = memberLink->next;
24730|      0|	}
24731|      1|	if (ret != 0) {
  ------------------
  |  Branch (24731:6): [True: 0, False: 1]
  ------------------
24732|      0|	    if (ret < 0) {
  ------------------
  |  Branch (24732:10): [True: 0, False: 0]
  ------------------
24733|      0|		AERROR_INT("xmlSchemaVCheckCVCSimpleType",
  ------------------
  |  | 2827|      0|#define AERROR_INT(func, msg) xmlSchemaInternalErr(actxt, func, msg);
  ------------------
24734|      0|		    "validating members of union simple type");
24735|      0|		goto internal_error;
24736|      0|	    }
24737|      0|	    ret = XML_SCHEMAV_CVC_DATATYPE_VALID_1_2_3;
24738|      0|	}
24739|       |	/*
24740|       |	* Apply facets (pattern, enumeration).
24741|       |	*/
24742|      1|	if ((ret == 0) && (type->flags & XML_SCHEMAS_TYPE_HAS_FACETS)) {
  ------------------
  |  |  569|      1|#define XML_SCHEMAS_TYPE_HAS_FACETS    1 << 27
  ------------------
  |  Branch (24742:6): [True: 1, False: 0]
  |  Branch (24742:20): [True: 0, False: 1]
  ------------------
24743|       |	    /*
24744|       |	    * The normalization behavior of `union` types is controlled by
24745|       |	    * the value of whiteSpace on that one of the `memberTypes`
24746|       |	    * against which the `union` is successfully validated.
24747|       |	    */
24748|      0|	    NORMALIZE(memberLink->type);
  ------------------
  |  |24457|      0|    if ((! isNormalized) && \
  |  |  ------------------
  |  |  |  Branch (24457:9): [True: 0, False: 0]
  |  |  ------------------
  |  |24458|      0|    (normalize || (type->flags & XML_SCHEMAS_TYPE_NORMVALUENEEDED))) { \
  |  |  ------------------
  |  |  |  |  575|      0|#define XML_SCHEMAS_TYPE_NORMVALUENEEDED    1 << 28
  |  |  ------------------
  |  |  |  Branch (24458:6): [True: 0, False: 0]
  |  |  |  Branch (24458:19): [True: 0, False: 0]
  |  |  ------------------
  |  |24459|      0|	normValue = xmlSchemaNormalizeValue(atype, value); \
  |  |24460|      0|	if (normValue != NULL) \
  |  |  ------------------
  |  |  |  Branch (24460:6): [True: 0, False: 0]
  |  |  ------------------
  |  |24461|      0|	    value = normValue; \
  |  |24462|      0|	isNormalized = 1; \
  |  |24463|      0|    }
  ------------------
24749|      0|	    ret = xmlSchemaValidateFacets(actxt, node, type,
24750|      0|		XML_SCHEMAS_UNKNOWN, value, val,
24751|      0|		0, fireErrors);
24752|      0|	    if (ret != 0) {
  ------------------
  |  Branch (24752:10): [True: 0, False: 0]
  ------------------
24753|      0|		if (ret < 0) {
  ------------------
  |  Branch (24753:7): [True: 0, False: 0]
  ------------------
24754|      0|		    AERROR_INT("xmlSchemaVCheckCVCSimpleType",
  ------------------
  |  | 2827|      0|#define AERROR_INT(func, msg) xmlSchemaInternalErr(actxt, func, msg);
  ------------------
24755|      0|			"validating facets of union simple type");
24756|      0|		    goto internal_error;
24757|      0|		}
24758|      0|		ret = XML_SCHEMAV_CVC_DATATYPE_VALID_1_2_3;
24759|      0|	    }
24760|      0|	}
24761|      1|	if (fireErrors && (ret > 0))
  ------------------
  |  Branch (24761:6): [True: 1, False: 0]
  |  Branch (24761:20): [True: 0, False: 1]
  ------------------
24762|      0|	    xmlSchemaSimpleTypeErr(actxt, ret, node, value, type, 1);
24763|      1|    }
24764|       |
24765|    178|    if (normValue != NULL)
  ------------------
  |  Branch (24765:9): [True: 0, False: 178]
  ------------------
24766|      0|	xmlFree(normValue);
24767|    178|    if (ret == 0) {
  ------------------
  |  Branch (24767:9): [True: 178, False: 0]
  ------------------
24768|    178|	if (retVal != NULL)
  ------------------
  |  Branch (24768:6): [True: 178, False: 0]
  ------------------
24769|    178|	    *retVal = val;
24770|      0|	else if (val != NULL)
  ------------------
  |  Branch (24770:11): [True: 0, False: 0]
  ------------------
24771|      0|	    xmlSchemaFreeValue(val);
24772|    178|    } else if (val != NULL)
  ------------------
  |  Branch (24772:16): [True: 0, False: 0]
  ------------------
24773|      0|	xmlSchemaFreeValue(val);
24774|    178|    return (ret);
24775|      0|internal_error:
24776|      0|    if (normValue != NULL)
  ------------------
  |  Branch (24776:9): [True: 0, False: 0]
  ------------------
24777|      0|	xmlFree(normValue);
24778|      0|    if (val != NULL)
  ------------------
  |  Branch (24778:9): [True: 0, False: 0]
  ------------------
24779|      0|	xmlSchemaFreeValue(val);
24780|      0|    return (-1);
24781|    178|}
xmlschemas.c:xmlSchemaNormalizeValue:
24360|    177|{
24361|    177|    switch (xmlSchemaGetWhiteSpaceFacetValue(type)) {
24362|    141|	case XML_SCHEMA_WHITESPACE_COLLAPSE:
  ------------------
  |  Branch (24362:2): [True: 141, False: 36]
  ------------------
24363|    141|	    return (xmlSchemaCollapseString(value));
24364|      0|	case XML_SCHEMA_WHITESPACE_REPLACE:
  ------------------
  |  Branch (24364:2): [True: 0, False: 177]
  ------------------
24365|      0|	    return (xmlSchemaWhiteSpaceReplace(value));
24366|     36|	default:
  ------------------
  |  Branch (24366:2): [True: 36, False: 141]
  ------------------
24367|     36|	    return (NULL);
24368|    177|    }
24369|    177|}
xmlschemas.c:xmlSchemaGetWhiteSpaceFacetValue:
21465|    187|{
21466|       |    /*
21467|       |    * The normalization type can be changed only for types which are derived
21468|       |    * from xsd:string.
21469|       |    */
21470|    187|    if (type->type == XML_SCHEMA_TYPE_BASIC) {
  ------------------
  |  Branch (21470:9): [True: 167, False: 20]
  ------------------
21471|       |	/*
21472|       |	* Note that we assume a whitespace of preserve for anySimpleType.
21473|       |	*/
21474|    167|	if ((type->builtInType == XML_SCHEMAS_STRING) ||
  ------------------
  |  Branch (21474:6): [True: 29, False: 138]
  ------------------
21475|    167|	    (type->builtInType == XML_SCHEMAS_ANYSIMPLETYPE))
  ------------------
  |  Branch (21475:6): [True: 0, False: 138]
  ------------------
21476|     29|	    return(XML_SCHEMA_WHITESPACE_PRESERVE);
21477|    138|	else if (type->builtInType == XML_SCHEMAS_NORMSTRING)
  ------------------
  |  Branch (21477:11): [True: 0, False: 138]
  ------------------
21478|      0|	    return(XML_SCHEMA_WHITESPACE_REPLACE);
21479|    138|	else {
21480|       |	    /*
21481|       |	    * For all `atomic` datatypes other than string (and types `derived`
21482|       |	    * by `restriction` from it) the value of whiteSpace is fixed to
21483|       |	    * collapse
21484|       |	    * Note that this includes built-in list datatypes.
21485|       |	    */
21486|    138|	    return(XML_SCHEMA_WHITESPACE_COLLAPSE);
21487|    138|	}
21488|    167|    } else if (WXS_IS_LIST(type)) {
  ------------------
  |  |  272|     20|#define WXS_IS_LIST(t) (t->flags & XML_SCHEMAS_TYPE_VARIETY_LIST)
  |  |  ------------------
  |  |  |  |  448|     20|#define XML_SCHEMAS_TYPE_VARIETY_LIST    1 << 6
  |  |  ------------------
  |  |  |  Branch (272:24): [True: 0, False: 20]
  |  |  ------------------
  ------------------
21489|       |	/*
21490|       |	* For list types the facet "whiteSpace" is fixed to "collapse".
21491|       |	*/
21492|      0|	return (XML_SCHEMA_WHITESPACE_COLLAPSE);
21493|     20|    } else if (WXS_IS_UNION(type)) {
  ------------------
  |  |  274|     20|#define WXS_IS_UNION(t) (t->flags & XML_SCHEMAS_TYPE_VARIETY_UNION)
  |  |  ------------------
  |  |  |  |  454|     20|#define XML_SCHEMAS_TYPE_VARIETY_UNION    1 << 7
  |  |  ------------------
  |  |  |  Branch (274:25): [True: 0, False: 20]
  |  |  ------------------
  ------------------
21494|      0|	return (XML_SCHEMA_WHITESPACE_UNKNOWN);
21495|     20|    } else if (WXS_IS_ATOMIC(type)) {
  ------------------
  |  |  270|     20|#define WXS_IS_ATOMIC(t) (t->flags & XML_SCHEMAS_TYPE_VARIETY_ATOMIC)
  |  |  ------------------
  |  |  |  |  460|     20|#define XML_SCHEMAS_TYPE_VARIETY_ATOMIC    1 << 8
  |  |  ------------------
  |  |  |  Branch (270:26): [True: 20, False: 0]
  |  |  ------------------
  ------------------
21496|     20|	if (type->flags & XML_SCHEMAS_TYPE_WHITESPACE_PRESERVE)
  ------------------
  |  |  551|     20|#define XML_SCHEMAS_TYPE_WHITESPACE_PRESERVE    1 << 24
  ------------------
  |  Branch (21496:6): [True: 14, False: 6]
  ------------------
21497|     14|	    return (XML_SCHEMA_WHITESPACE_PRESERVE);
21498|      6|	else if (type->flags & XML_SCHEMAS_TYPE_WHITESPACE_REPLACE)
  ------------------
  |  |  557|      6|#define XML_SCHEMAS_TYPE_WHITESPACE_REPLACE    1 << 25
  ------------------
  |  Branch (21498:11): [True: 0, False: 6]
  ------------------
21499|      0|	    return (XML_SCHEMA_WHITESPACE_REPLACE);
21500|      6|	else
21501|      6|	    return (XML_SCHEMA_WHITESPACE_COLLAPSE);
21502|     20|    }
21503|      0|    return (-1);
21504|    187|}
xmlschemas.c:xmlSchemaValidateFacets:
24136|     10|{
24137|     10|    int ret, error = 0, found;
24138|       |
24139|     10|    xmlSchemaTypePtr tmpType;
24140|     10|    xmlSchemaFacetLinkPtr facetLink;
24141|     10|    xmlSchemaFacetPtr facet;
24142|     10|    unsigned long len = 0;
24143|     10|    xmlSchemaWhitespaceValueType ws;
24144|       |
24145|       |    /*
24146|       |    * In Libxml2, derived built-in types have currently no explicit facets.
24147|       |    */
24148|     10|    if (type->type == XML_SCHEMA_TYPE_BASIC)
  ------------------
  |  Branch (24148:9): [True: 0, False: 10]
  ------------------
24149|      0|	return (0);
24150|       |
24151|       |    /*
24152|       |    * NOTE: Do not jump away, if the facetSet of the given type is
24153|       |    * empty: until now, "pattern" and "enumeration" facets of the
24154|       |    * *base types* need to be checked as well.
24155|       |    */
24156|     10|    if (type->facetSet == NULL)
  ------------------
  |  Branch (24156:9): [True: 0, False: 10]
  ------------------
24157|      0|	goto pattern_and_enum;
24158|       |
24159|     10|    if (! WXS_IS_ATOMIC(type)) {
  ------------------
  |  |  270|     10|#define WXS_IS_ATOMIC(t) (t->flags & XML_SCHEMAS_TYPE_VARIETY_ATOMIC)
  |  |  ------------------
  |  |  |  |  460|     10|#define XML_SCHEMAS_TYPE_VARIETY_ATOMIC    1 << 8
  |  |  ------------------
  ------------------
  |  Branch (24159:9): [True: 0, False: 10]
  ------------------
24160|      0|	if (WXS_IS_LIST(type))
  ------------------
  |  |  272|      0|#define WXS_IS_LIST(t) (t->flags & XML_SCHEMAS_TYPE_VARIETY_LIST)
  |  |  ------------------
  |  |  |  |  448|      0|#define XML_SCHEMAS_TYPE_VARIETY_LIST    1 << 6
  |  |  ------------------
  |  |  |  Branch (272:24): [True: 0, False: 0]
  |  |  ------------------
  ------------------
24161|      0|	    goto WXS_IS_LIST;
24162|      0|	else
24163|      0|	    goto pattern_and_enum;
24164|      0|    }
24165|       |
24166|       |    /*
24167|       |    * Whitespace handling is only of importance for string-based
24168|       |    * types.
24169|       |    */
24170|     10|    tmpType = xmlSchemaGetPrimitiveType(type);
24171|     10|    if ((tmpType->builtInType == XML_SCHEMAS_STRING) ||
  ------------------
  |  Branch (24171:9): [True: 10, False: 0]
  ------------------
24172|     10|	WXS_IS_ANY_SIMPLE_TYPE(tmpType)) {
  ------------------
  |  |  222|      0|    (((i)->type == XML_SCHEMA_TYPE_BASIC) && \
  |  |  ------------------
  |  |  |  Branch (222:6): [True: 0, False: 0]
  |  |  ------------------
  |  |  223|      0|      ((i)->builtInType == XML_SCHEMAS_ANYSIMPLETYPE))
  |  |  ------------------
  |  |  |  Branch (223:7): [True: 0, False: 0]
  |  |  ------------------
  ------------------
24173|     10|	ws = xmlSchemaGetWhiteSpaceFacetValue(type);
24174|     10|    } else
24175|      0|	ws = XML_SCHEMA_WHITESPACE_COLLAPSE;
24176|       |
24177|       |    /*
24178|       |    * If the value was not computed (for string or
24179|       |    * anySimpleType based types), then use the provided
24180|       |    * type.
24181|       |    */
24182|     10|    if (val != NULL)
  ------------------
  |  Branch (24182:9): [True: 10, False: 0]
  ------------------
24183|     10|	valType = xmlSchemaGetValType(val);
24184|       |
24185|     10|    ret = 0;
24186|     43|    for (facetLink = type->facetSet; facetLink != NULL;
  ------------------
  |  Branch (24186:38): [True: 33, False: 10]
  ------------------
24187|     33|	facetLink = facetLink->next) {
24188|       |	/*
24189|       |	* Skip the pattern "whiteSpace": it is used to
24190|       |	* format the character content beforehand.
24191|       |	*/
24192|     33|	switch (facetLink->facet->type) {
24193|      0|	    case XML_SCHEMA_FACET_WHITESPACE:
  ------------------
  |  Branch (24193:6): [True: 0, False: 33]
  ------------------
24194|      0|	    case XML_SCHEMA_FACET_PATTERN:
  ------------------
  |  Branch (24194:6): [True: 0, False: 33]
  ------------------
24195|     32|	    case XML_SCHEMA_FACET_ENUMERATION:
  ------------------
  |  Branch (24195:6): [True: 32, False: 1]
  ------------------
24196|     32|		continue;
24197|      0|	    case XML_SCHEMA_FACET_LENGTH:
  ------------------
  |  Branch (24197:6): [True: 0, False: 33]
  ------------------
24198|      0|	    case XML_SCHEMA_FACET_MINLENGTH:
  ------------------
  |  Branch (24198:6): [True: 0, False: 33]
  ------------------
24199|      1|	    case XML_SCHEMA_FACET_MAXLENGTH:
  ------------------
  |  Branch (24199:6): [True: 1, False: 32]
  ------------------
24200|      1|		ret = xmlSchemaValidateLengthFacetWhtsp(facetLink->facet,
24201|      1|		    valType, value, val, &len, ws);
24202|      1|		break;
24203|      0|	    default:
  ------------------
  |  Branch (24203:6): [True: 0, False: 33]
  ------------------
24204|      0|		ret = xmlSchemaValidateFacetWhtsp(facetLink->facet, ws,
24205|      0|		    valType, value, val, ws);
24206|      0|		break;
24207|     33|	}
24208|      1|	if (ret < 0) {
  ------------------
  |  Branch (24208:6): [True: 0, False: 1]
  ------------------
24209|      0|	    AERROR_INT("xmlSchemaValidateFacets",
  ------------------
  |  | 2827|      0|#define AERROR_INT(func, msg) xmlSchemaInternalErr(actxt, func, msg);
  ------------------
24210|      0|		"validating against a atomic type facet");
24211|      0|	    return (-1);
24212|      1|	} else if (ret > 0) {
  ------------------
  |  Branch (24212:13): [True: 0, False: 1]
  ------------------
24213|      0|	    if (fireErrors)
  ------------------
  |  Branch (24213:10): [True: 0, False: 0]
  ------------------
24214|      0|		xmlSchemaFacetErr(actxt, ret, node,
24215|      0|		value, len, type, facetLink->facet, NULL, NULL, NULL);
24216|      0|	    else
24217|      0|		return (ret);
24218|      0|	    if (error == 0)
  ------------------
  |  Branch (24218:10): [True: 0, False: 0]
  ------------------
24219|      0|		error = ret;
24220|      0|	}
24221|      1|	ret = 0;
24222|      1|    }
24223|       |
24224|     10|WXS_IS_LIST:
24225|     10|    if (! WXS_IS_LIST(type))
  ------------------
  |  |  272|     10|#define WXS_IS_LIST(t) (t->flags & XML_SCHEMAS_TYPE_VARIETY_LIST)
  |  |  ------------------
  |  |  |  |  448|     10|#define XML_SCHEMAS_TYPE_VARIETY_LIST    1 << 6
  |  |  ------------------
  ------------------
  |  Branch (24225:9): [True: 10, False: 0]
  ------------------
24226|     10|	goto pattern_and_enum;
24227|       |    /*
24228|       |    * "length", "minLength" and "maxLength" of list types.
24229|       |    */
24230|      0|    ret = 0;
24231|      0|    for (facetLink = type->facetSet; facetLink != NULL;
  ------------------
  |  Branch (24231:38): [True: 0, False: 0]
  ------------------
24232|      0|	facetLink = facetLink->next) {
24233|       |
24234|      0|	switch (facetLink->facet->type) {
24235|      0|	    case XML_SCHEMA_FACET_LENGTH:
  ------------------
  |  Branch (24235:6): [True: 0, False: 0]
  ------------------
24236|      0|	    case XML_SCHEMA_FACET_MINLENGTH:
  ------------------
  |  Branch (24236:6): [True: 0, False: 0]
  ------------------
24237|      0|	    case XML_SCHEMA_FACET_MAXLENGTH:
  ------------------
  |  Branch (24237:6): [True: 0, False: 0]
  ------------------
24238|      0|		ret = xmlSchemaValidateListSimpleTypeFacet(facetLink->facet,
24239|      0|		    value, length, NULL);
24240|      0|		break;
24241|      0|	    default:
  ------------------
  |  Branch (24241:6): [True: 0, False: 0]
  ------------------
24242|      0|		continue;
24243|      0|	}
24244|      0|	if (ret < 0) {
  ------------------
  |  Branch (24244:6): [True: 0, False: 0]
  ------------------
24245|      0|	    AERROR_INT("xmlSchemaValidateFacets",
  ------------------
  |  | 2827|      0|#define AERROR_INT(func, msg) xmlSchemaInternalErr(actxt, func, msg);
  ------------------
24246|      0|		"validating against a list type facet");
24247|      0|	    return (-1);
24248|      0|	} else if (ret > 0) {
  ------------------
  |  Branch (24248:13): [True: 0, False: 0]
  ------------------
24249|      0|	    if (fireErrors)
  ------------------
  |  Branch (24249:10): [True: 0, False: 0]
  ------------------
24250|      0|		xmlSchemaFacetErr(actxt, ret, node,
24251|      0|		value, length, type, facetLink->facet, NULL, NULL, NULL);
24252|      0|	    else
24253|      0|		return (ret);
24254|      0|	    if (error == 0)
  ------------------
  |  Branch (24254:10): [True: 0, False: 0]
  ------------------
24255|      0|		error = ret;
24256|      0|	}
24257|      0|	ret = 0;
24258|      0|    }
24259|       |
24260|     10|pattern_and_enum:
24261|     10|    found = 0;
24262|       |    /*
24263|       |    * Process enumerations. Facet values are in the value space
24264|       |    * of the defining type's base type. This seems to be a bug in the
24265|       |    * XML Schema 1.0 spec. Use the whitespace type of the base type.
24266|       |    * Only the first set of enumerations in the ancestor-or-self axis
24267|       |    * is used for validation.
24268|       |    */
24269|     10|    ret = 0;
24270|     10|    tmpType = type;
24271|     10|    do {
24272|     19|        for (facet = tmpType->facets; facet != NULL; facet = facet->next) {
  ------------------
  |  Branch (24272:39): [True: 18, False: 1]
  ------------------
24273|     18|            if (facet->type != XML_SCHEMA_FACET_ENUMERATION)
  ------------------
  |  Branch (24273:17): [True: 1, False: 17]
  ------------------
24274|      1|                continue;
24275|     17|            found = 1;
24276|     17|            ret = xmlSchemaAreValuesEqual(facet->val, val);
24277|     17|            if (ret == 1)
  ------------------
  |  Branch (24277:17): [True: 9, False: 8]
  ------------------
24278|      9|                break;
24279|      8|            else if (ret < 0) {
  ------------------
  |  Branch (24279:22): [True: 0, False: 8]
  ------------------
24280|      0|                AERROR_INT("xmlSchemaValidateFacets",
  ------------------
  |  | 2827|      0|#define AERROR_INT(func, msg) xmlSchemaInternalErr(actxt, func, msg);
  ------------------
24281|      0|                    "validating against an enumeration facet");
24282|      0|                return (-1);
24283|      0|            }
24284|     17|        }
24285|     10|        if (ret != 0)
  ------------------
  |  Branch (24285:13): [True: 9, False: 1]
  ------------------
24286|      9|            break;
24287|       |        /*
24288|       |        * Break on the first set of enumerations. Any additional
24289|       |        *  enumerations which might be existent on the ancestors
24290|       |        *  of the current type are restricted by this set; thus
24291|       |        *  *must* *not* be taken into account.
24292|       |        */
24293|      1|        if (found)
  ------------------
  |  Branch (24293:13): [True: 0, False: 1]
  ------------------
24294|      0|            break;
24295|      1|        tmpType = tmpType->baseType;
24296|      1|    } while ((tmpType != NULL) &&
  ------------------
  |  Branch (24296:14): [True: 1, False: 0]
  ------------------
24297|      1|        (tmpType->type != XML_SCHEMA_TYPE_BASIC));
  ------------------
  |  Branch (24297:9): [True: 0, False: 1]
  ------------------
24298|     10|    if (found && (ret == 0)) {
  ------------------
  |  Branch (24298:9): [True: 9, False: 1]
  |  Branch (24298:18): [True: 0, False: 9]
  ------------------
24299|      0|        ret = XML_SCHEMAV_CVC_ENUMERATION_VALID;
24300|      0|        if (fireErrors) {
  ------------------
  |  Branch (24300:13): [True: 0, False: 0]
  ------------------
24301|      0|            xmlSchemaFacetErr(actxt, ret, node,
24302|      0|                value, 0, type, NULL, NULL, NULL, NULL);
24303|      0|        } else
24304|      0|            return (ret);
24305|      0|        if (error == 0)
  ------------------
  |  Branch (24305:13): [True: 0, False: 0]
  ------------------
24306|      0|            error = ret;
24307|      0|    }
24308|       |
24309|       |    /*
24310|       |    * Process patters. Pattern facets are ORed at type level
24311|       |    * and ANDed if derived. Walk the base type axis.
24312|       |    */
24313|     10|    tmpType = type;
24314|     10|    facet = NULL;
24315|     10|    do {
24316|     10|        found = 0;
24317|     43|        for (facetLink = tmpType->facetSet; facetLink != NULL;
  ------------------
  |  Branch (24317:45): [True: 33, False: 10]
  ------------------
24318|     33|            facetLink = facetLink->next) {
24319|     33|            if (facetLink->facet->type != XML_SCHEMA_FACET_PATTERN)
  ------------------
  |  Branch (24319:17): [True: 33, False: 0]
  ------------------
24320|     33|                continue;
24321|      0|            found = 1;
24322|       |            /*
24323|       |            * NOTE that for patterns, @value needs to be the
24324|       |            * normalized value.
24325|       |            */
24326|      0|            ret = xmlRegexpExec(facetLink->facet->regexp, value);
24327|      0|            if (ret == 1)
  ------------------
  |  Branch (24327:17): [True: 0, False: 0]
  ------------------
24328|      0|                break;
24329|      0|            else if (ret < 0) {
  ------------------
  |  Branch (24329:22): [True: 0, False: 0]
  ------------------
24330|      0|                AERROR_INT("xmlSchemaValidateFacets",
  ------------------
  |  | 2827|      0|#define AERROR_INT(func, msg) xmlSchemaInternalErr(actxt, func, msg);
  ------------------
24331|      0|                    "validating against a pattern facet");
24332|      0|                return (-1);
24333|      0|            } else {
24334|       |                /*
24335|       |                * Save the last non-validating facet.
24336|       |                */
24337|      0|                facet = facetLink->facet;
24338|      0|            }
24339|      0|        }
24340|     10|        if (found && (ret != 1)) {
  ------------------
  |  Branch (24340:13): [True: 0, False: 10]
  |  Branch (24340:22): [True: 0, False: 0]
  ------------------
24341|      0|            ret = XML_SCHEMAV_CVC_PATTERN_VALID;
24342|      0|            if (fireErrors) {
  ------------------
  |  Branch (24342:17): [True: 0, False: 0]
  ------------------
24343|      0|                xmlSchemaFacetErr(actxt, ret, node,
24344|      0|                    value, 0, type, facet, NULL, NULL, NULL);
24345|      0|            } else
24346|      0|                return (ret);
24347|      0|            if (error == 0)
  ------------------
  |  Branch (24347:17): [True: 0, False: 0]
  ------------------
24348|      0|                error = ret;
24349|      0|            break;
24350|      0|        }
24351|     10|        tmpType = tmpType->baseType;
24352|     10|    } while ((tmpType != NULL) && (tmpType->type != XML_SCHEMA_TYPE_BASIC));
  ------------------
  |  Branch (24352:14): [True: 10, False: 0]
  |  Branch (24352:35): [True: 0, False: 10]
  ------------------
24353|       |
24354|     10|    return (error);
24355|     10|}
xmlschemas.c:xmlSchemaItemListCreate:
 3382|  1.27k|{
 3383|  1.27k|    xmlSchemaItemListPtr ret;
 3384|       |
 3385|  1.27k|    ret = xmlMalloc(sizeof(xmlSchemaItemList));
 3386|  1.27k|    if (ret == NULL) {
  ------------------
  |  Branch (3386:9): [True: 0, False: 1.27k]
  ------------------
 3387|      0|	xmlSchemaPErrMemory(NULL,
 3388|      0|	    "allocating an item list structure", NULL);
 3389|      0|	return (NULL);
 3390|      0|    }
 3391|  1.27k|    memset(ret, 0, sizeof(xmlSchemaItemList));
 3392|  1.27k|    return (ret);
 3393|  1.27k|}

xmlSchemaInitTypes:
  433|    198|{
  434|    198|    if (xmlSchemaTypesInitialized != 0)
  ------------------
  |  Branch (434:9): [True: 197, False: 1]
  ------------------
  435|    197|        return (0);
  436|      1|    xmlSchemaTypesBank = xmlHashCreate(40);
  437|      1|    if (xmlSchemaTypesBank == NULL) {
  ------------------
  |  Branch (437:9): [True: 0, False: 1]
  ------------------
  438|      0|	xmlSchemaTypeErrMemory(NULL, NULL);
  439|      0|        goto error;
  440|      0|    }
  441|       |
  442|       |    /*
  443|       |    * 3.4.7 Built-in Complex Type Definition
  444|       |    */
  445|      1|    xmlSchemaTypeAnyTypeDef = xmlSchemaInitBasicType("anyType",
  446|      1|                                                     XML_SCHEMAS_ANYTYPE,
  447|      1|						     NULL);
  448|      1|    if (xmlSchemaTypeAnyTypeDef == NULL)
  ------------------
  |  Branch (448:9): [True: 0, False: 1]
  ------------------
  449|      0|        goto error;
  450|      1|    xmlSchemaTypeAnyTypeDef->baseType = xmlSchemaTypeAnyTypeDef;
  451|      1|    xmlSchemaTypeAnyTypeDef->contentType = XML_SCHEMA_CONTENT_MIXED;
  452|       |    /*
  453|       |    * Init the content type.
  454|       |    */
  455|      1|    xmlSchemaTypeAnyTypeDef->contentType = XML_SCHEMA_CONTENT_MIXED;
  456|      1|    {
  457|      1|	xmlSchemaParticlePtr particle;
  458|      1|	xmlSchemaModelGroupPtr sequence;
  459|      1|	xmlSchemaWildcardPtr wild;
  460|       |	/* First particle. */
  461|      1|	particle = xmlSchemaAddParticle();
  462|      1|	if (particle == NULL)
  ------------------
  |  Branch (462:6): [True: 0, False: 1]
  ------------------
  463|      0|	    goto error;
  464|      1|	xmlSchemaTypeAnyTypeDef->subtypes = (xmlSchemaTypePtr) particle;
  465|       |	/* Sequence model group. */
  466|      1|	sequence = (xmlSchemaModelGroupPtr)
  467|      1|	    xmlMalloc(sizeof(xmlSchemaModelGroup));
  468|      1|	if (sequence == NULL) {
  ------------------
  |  Branch (468:6): [True: 0, False: 1]
  ------------------
  469|      0|	    xmlSchemaTypeErrMemory(NULL, "allocating model group component");
  470|      0|	    goto error;
  471|      0|	}
  472|      1|	memset(sequence, 0, sizeof(xmlSchemaModelGroup));
  473|      1|	sequence->type = XML_SCHEMA_TYPE_SEQUENCE;
  474|      1|	particle->children = (xmlSchemaTreeItemPtr) sequence;
  475|       |	/* Second particle. */
  476|      1|	particle = xmlSchemaAddParticle();
  477|      1|	if (particle == NULL)
  ------------------
  |  Branch (477:6): [True: 0, False: 1]
  ------------------
  478|      0|	    goto error;
  479|      1|	particle->minOccurs = 0;
  480|      1|	particle->maxOccurs = UNBOUNDED;
  ------------------
  |  |  335|      1|#define UNBOUNDED (1 << 30)
  ------------------
  481|      1|	sequence->children = (xmlSchemaTreeItemPtr) particle;
  482|       |	/* The wildcard */
  483|      1|	wild = (xmlSchemaWildcardPtr) xmlMalloc(sizeof(xmlSchemaWildcard));
  484|      1|	if (wild == NULL) {
  ------------------
  |  Branch (484:6): [True: 0, False: 1]
  ------------------
  485|      0|	    xmlSchemaTypeErrMemory(NULL, "allocating wildcard component");
  486|      0|	    goto error;
  487|      0|	}
  488|      1|	memset(wild, 0, sizeof(xmlSchemaWildcard));
  489|      1|	wild->type = XML_SCHEMA_TYPE_ANY;
  490|      1|	wild->any = 1;
  491|      1|	wild->processContents = XML_SCHEMAS_ANY_LAX;
  ------------------
  |  |  188|      1|#define XML_SCHEMAS_ANY_LAX                2
  ------------------
  492|      1|	particle->children = (xmlSchemaTreeItemPtr) wild;
  493|       |	/*
  494|       |	* Create the attribute wildcard.
  495|       |	*/
  496|      1|	wild = (xmlSchemaWildcardPtr) xmlMalloc(sizeof(xmlSchemaWildcard));
  497|      1|	if (wild == NULL) {
  ------------------
  |  Branch (497:6): [True: 0, False: 1]
  ------------------
  498|      0|	    xmlSchemaTypeErrMemory(NULL, "could not create an attribute "
  499|      0|		"wildcard on anyType");
  500|      0|	    goto error;
  501|      0|	}
  502|      1|	memset(wild, 0, sizeof(xmlSchemaWildcard));
  503|      1|	wild->any = 1;
  504|      1|	wild->processContents = XML_SCHEMAS_ANY_LAX;
  ------------------
  |  |  188|      1|#define XML_SCHEMAS_ANY_LAX                2
  ------------------
  505|      1|	xmlSchemaTypeAnyTypeDef->attributeWildcard = wild;
  506|      1|    }
  507|      0|    xmlSchemaTypeAnySimpleTypeDef = xmlSchemaInitBasicType("anySimpleType",
  508|      1|                                                           XML_SCHEMAS_ANYSIMPLETYPE,
  509|      1|							   xmlSchemaTypeAnyTypeDef);
  510|      1|    if (xmlSchemaTypeAnySimpleTypeDef == NULL)
  ------------------
  |  Branch (510:9): [True: 0, False: 1]
  ------------------
  511|      0|        goto error;
  512|       |    /*
  513|       |    * primitive datatypes
  514|       |    */
  515|      1|    xmlSchemaTypeStringDef = xmlSchemaInitBasicType("string",
  516|      1|                                                    XML_SCHEMAS_STRING,
  517|      1|						    xmlSchemaTypeAnySimpleTypeDef);
  518|      1|    if (xmlSchemaTypeStringDef == NULL)
  ------------------
  |  Branch (518:9): [True: 0, False: 1]
  ------------------
  519|      0|        goto error;
  520|      1|    xmlSchemaTypeDecimalDef = xmlSchemaInitBasicType("decimal",
  521|      1|                                                     XML_SCHEMAS_DECIMAL,
  522|      1|						     xmlSchemaTypeAnySimpleTypeDef);
  523|      1|    if (xmlSchemaTypeDecimalDef == NULL)
  ------------------
  |  Branch (523:9): [True: 0, False: 1]
  ------------------
  524|      0|        goto error;
  525|      1|    xmlSchemaTypeDateDef = xmlSchemaInitBasicType("date",
  526|      1|                                                  XML_SCHEMAS_DATE,
  527|      1|						  xmlSchemaTypeAnySimpleTypeDef);
  528|      1|    if (xmlSchemaTypeDateDef == NULL)
  ------------------
  |  Branch (528:9): [True: 0, False: 1]
  ------------------
  529|      0|        goto error;
  530|      1|    xmlSchemaTypeDatetimeDef = xmlSchemaInitBasicType("dateTime",
  531|      1|                                                      XML_SCHEMAS_DATETIME,
  532|      1|						      xmlSchemaTypeAnySimpleTypeDef);
  533|      1|    if (xmlSchemaTypeDatetimeDef == NULL)
  ------------------
  |  Branch (533:9): [True: 0, False: 1]
  ------------------
  534|      0|        goto error;
  535|      1|    xmlSchemaTypeTimeDef = xmlSchemaInitBasicType("time",
  536|      1|                                                  XML_SCHEMAS_TIME,
  537|      1|						  xmlSchemaTypeAnySimpleTypeDef);
  538|      1|    if (xmlSchemaTypeTimeDef == NULL)
  ------------------
  |  Branch (538:9): [True: 0, False: 1]
  ------------------
  539|      0|        goto error;
  540|      1|    xmlSchemaTypeGYearDef = xmlSchemaInitBasicType("gYear",
  541|      1|                                                   XML_SCHEMAS_GYEAR,
  542|      1|						   xmlSchemaTypeAnySimpleTypeDef);
  543|      1|    if (xmlSchemaTypeGYearDef == NULL)
  ------------------
  |  Branch (543:9): [True: 0, False: 1]
  ------------------
  544|      0|        goto error;
  545|      1|    xmlSchemaTypeGYearMonthDef = xmlSchemaInitBasicType("gYearMonth",
  546|      1|                                                        XML_SCHEMAS_GYEARMONTH,
  547|      1|							xmlSchemaTypeAnySimpleTypeDef);
  548|      1|    if (xmlSchemaTypeGYearMonthDef == NULL)
  ------------------
  |  Branch (548:9): [True: 0, False: 1]
  ------------------
  549|      0|        goto error;
  550|      1|    xmlSchemaTypeGMonthDef = xmlSchemaInitBasicType("gMonth",
  551|      1|                                                    XML_SCHEMAS_GMONTH,
  552|      1|						    xmlSchemaTypeAnySimpleTypeDef);
  553|      1|    if (xmlSchemaTypeGMonthDef == NULL)
  ------------------
  |  Branch (553:9): [True: 0, False: 1]
  ------------------
  554|      0|        goto error;
  555|      1|    xmlSchemaTypeGMonthDayDef = xmlSchemaInitBasicType("gMonthDay",
  556|      1|                                                       XML_SCHEMAS_GMONTHDAY,
  557|      1|						       xmlSchemaTypeAnySimpleTypeDef);
  558|      1|    if (xmlSchemaTypeGMonthDayDef == NULL)
  ------------------
  |  Branch (558:9): [True: 0, False: 1]
  ------------------
  559|      0|        goto error;
  560|      1|    xmlSchemaTypeGDayDef = xmlSchemaInitBasicType("gDay",
  561|      1|                                                  XML_SCHEMAS_GDAY,
  562|      1|						  xmlSchemaTypeAnySimpleTypeDef);
  563|      1|    if (xmlSchemaTypeGDayDef == NULL)
  ------------------
  |  Branch (563:9): [True: 0, False: 1]
  ------------------
  564|      0|        goto error;
  565|      1|    xmlSchemaTypeDurationDef = xmlSchemaInitBasicType("duration",
  566|      1|                                                      XML_SCHEMAS_DURATION,
  567|      1|						      xmlSchemaTypeAnySimpleTypeDef);
  568|      1|    if (xmlSchemaTypeDurationDef == NULL)
  ------------------
  |  Branch (568:9): [True: 0, False: 1]
  ------------------
  569|      0|        goto error;
  570|      1|    xmlSchemaTypeFloatDef = xmlSchemaInitBasicType("float",
  571|      1|                                                   XML_SCHEMAS_FLOAT,
  572|      1|						   xmlSchemaTypeAnySimpleTypeDef);
  573|      1|    if (xmlSchemaTypeFloatDef == NULL)
  ------------------
  |  Branch (573:9): [True: 0, False: 1]
  ------------------
  574|      0|        goto error;
  575|      1|    xmlSchemaTypeDoubleDef = xmlSchemaInitBasicType("double",
  576|      1|                                                    XML_SCHEMAS_DOUBLE,
  577|      1|						    xmlSchemaTypeAnySimpleTypeDef);
  578|      1|    if (xmlSchemaTypeDoubleDef == NULL)
  ------------------
  |  Branch (578:9): [True: 0, False: 1]
  ------------------
  579|      0|        goto error;
  580|      1|    xmlSchemaTypeBooleanDef = xmlSchemaInitBasicType("boolean",
  581|      1|                                                     XML_SCHEMAS_BOOLEAN,
  582|      1|						     xmlSchemaTypeAnySimpleTypeDef);
  583|      1|    if (xmlSchemaTypeBooleanDef == NULL)
  ------------------
  |  Branch (583:9): [True: 0, False: 1]
  ------------------
  584|      0|        goto error;
  585|      1|    xmlSchemaTypeAnyURIDef = xmlSchemaInitBasicType("anyURI",
  586|      1|                                                    XML_SCHEMAS_ANYURI,
  587|      1|						    xmlSchemaTypeAnySimpleTypeDef);
  588|      1|    if (xmlSchemaTypeAnyURIDef == NULL)
  ------------------
  |  Branch (588:9): [True: 0, False: 1]
  ------------------
  589|      0|        goto error;
  590|      1|    xmlSchemaTypeHexBinaryDef = xmlSchemaInitBasicType("hexBinary",
  591|      1|                                                     XML_SCHEMAS_HEXBINARY,
  592|      1|						     xmlSchemaTypeAnySimpleTypeDef);
  593|      1|    if (xmlSchemaTypeHexBinaryDef == NULL)
  ------------------
  |  Branch (593:9): [True: 0, False: 1]
  ------------------
  594|      0|        goto error;
  595|      1|    xmlSchemaTypeBase64BinaryDef
  596|      1|        = xmlSchemaInitBasicType("base64Binary", XML_SCHEMAS_BASE64BINARY,
  597|      1|	xmlSchemaTypeAnySimpleTypeDef);
  598|      1|    if (xmlSchemaTypeBase64BinaryDef == NULL)
  ------------------
  |  Branch (598:9): [True: 0, False: 1]
  ------------------
  599|      0|        goto error;
  600|      1|    xmlSchemaTypeNotationDef = xmlSchemaInitBasicType("NOTATION",
  601|      1|                                                    XML_SCHEMAS_NOTATION,
  602|      1|						    xmlSchemaTypeAnySimpleTypeDef);
  603|      1|    if (xmlSchemaTypeNotationDef == NULL)
  ------------------
  |  Branch (603:9): [True: 0, False: 1]
  ------------------
  604|      0|        goto error;
  605|      1|    xmlSchemaTypeQNameDef = xmlSchemaInitBasicType("QName",
  606|      1|                                                   XML_SCHEMAS_QNAME,
  607|      1|						   xmlSchemaTypeAnySimpleTypeDef);
  608|      1|    if (xmlSchemaTypeQNameDef == NULL)
  ------------------
  |  Branch (608:9): [True: 0, False: 1]
  ------------------
  609|      0|        goto error;
  610|       |
  611|       |    /*
  612|       |     * derived datatypes
  613|       |     */
  614|      1|    xmlSchemaTypeIntegerDef = xmlSchemaInitBasicType("integer",
  615|      1|                                                     XML_SCHEMAS_INTEGER,
  616|      1|						     xmlSchemaTypeDecimalDef);
  617|      1|    if (xmlSchemaTypeIntegerDef == NULL)
  ------------------
  |  Branch (617:9): [True: 0, False: 1]
  ------------------
  618|      0|        goto error;
  619|      1|    xmlSchemaTypeNonPositiveIntegerDef =
  620|      1|        xmlSchemaInitBasicType("nonPositiveInteger",
  621|      1|                               XML_SCHEMAS_NPINTEGER,
  622|      1|			       xmlSchemaTypeIntegerDef);
  623|      1|    if (xmlSchemaTypeNonPositiveIntegerDef == NULL)
  ------------------
  |  Branch (623:9): [True: 0, False: 1]
  ------------------
  624|      0|        goto error;
  625|      1|    xmlSchemaTypeNegativeIntegerDef =
  626|      1|        xmlSchemaInitBasicType("negativeInteger", XML_SCHEMAS_NINTEGER,
  627|      1|	xmlSchemaTypeNonPositiveIntegerDef);
  628|      1|    if (xmlSchemaTypeNegativeIntegerDef == NULL)
  ------------------
  |  Branch (628:9): [True: 0, False: 1]
  ------------------
  629|      0|        goto error;
  630|      1|    xmlSchemaTypeLongDef =
  631|      1|        xmlSchemaInitBasicType("long", XML_SCHEMAS_LONG,
  632|      1|	xmlSchemaTypeIntegerDef);
  633|      1|    if (xmlSchemaTypeLongDef == NULL)
  ------------------
  |  Branch (633:9): [True: 0, False: 1]
  ------------------
  634|      0|        goto error;
  635|      1|    xmlSchemaTypeIntDef = xmlSchemaInitBasicType("int", XML_SCHEMAS_INT,
  636|      1|	xmlSchemaTypeLongDef);
  637|      1|    if (xmlSchemaTypeIntDef == NULL)
  ------------------
  |  Branch (637:9): [True: 0, False: 1]
  ------------------
  638|      0|        goto error;
  639|      1|    xmlSchemaTypeShortDef = xmlSchemaInitBasicType("short",
  640|      1|                                                   XML_SCHEMAS_SHORT,
  641|      1|						   xmlSchemaTypeIntDef);
  642|      1|    if (xmlSchemaTypeShortDef == NULL)
  ------------------
  |  Branch (642:9): [True: 0, False: 1]
  ------------------
  643|      0|        goto error;
  644|      1|    xmlSchemaTypeByteDef = xmlSchemaInitBasicType("byte",
  645|      1|                                                  XML_SCHEMAS_BYTE,
  646|      1|						  xmlSchemaTypeShortDef);
  647|      1|    if (xmlSchemaTypeByteDef == NULL)
  ------------------
  |  Branch (647:9): [True: 0, False: 1]
  ------------------
  648|      0|        goto error;
  649|      1|    xmlSchemaTypeNonNegativeIntegerDef =
  650|      1|        xmlSchemaInitBasicType("nonNegativeInteger",
  651|      1|                               XML_SCHEMAS_NNINTEGER,
  652|      1|			       xmlSchemaTypeIntegerDef);
  653|      1|    if (xmlSchemaTypeNonNegativeIntegerDef == NULL)
  ------------------
  |  Branch (653:9): [True: 0, False: 1]
  ------------------
  654|      0|        goto error;
  655|      1|    xmlSchemaTypeUnsignedLongDef =
  656|      1|        xmlSchemaInitBasicType("unsignedLong", XML_SCHEMAS_ULONG,
  657|      1|	xmlSchemaTypeNonNegativeIntegerDef);
  658|      1|    if (xmlSchemaTypeUnsignedLongDef == NULL)
  ------------------
  |  Branch (658:9): [True: 0, False: 1]
  ------------------
  659|      0|        goto error;
  660|      1|    xmlSchemaTypeUnsignedIntDef =
  661|      1|        xmlSchemaInitBasicType("unsignedInt", XML_SCHEMAS_UINT,
  662|      1|	xmlSchemaTypeUnsignedLongDef);
  663|      1|    if (xmlSchemaTypeUnsignedIntDef == NULL)
  ------------------
  |  Branch (663:9): [True: 0, False: 1]
  ------------------
  664|      0|        goto error;
  665|      1|    xmlSchemaTypeUnsignedShortDef =
  666|      1|        xmlSchemaInitBasicType("unsignedShort", XML_SCHEMAS_USHORT,
  667|      1|	xmlSchemaTypeUnsignedIntDef);
  668|      1|    if (xmlSchemaTypeUnsignedShortDef == NULL)
  ------------------
  |  Branch (668:9): [True: 0, False: 1]
  ------------------
  669|      0|        goto error;
  670|      1|    xmlSchemaTypeUnsignedByteDef =
  671|      1|        xmlSchemaInitBasicType("unsignedByte", XML_SCHEMAS_UBYTE,
  672|      1|	xmlSchemaTypeUnsignedShortDef);
  673|      1|    if (xmlSchemaTypeUnsignedByteDef == NULL)
  ------------------
  |  Branch (673:9): [True: 0, False: 1]
  ------------------
  674|      0|        goto error;
  675|      1|    xmlSchemaTypePositiveIntegerDef =
  676|      1|        xmlSchemaInitBasicType("positiveInteger", XML_SCHEMAS_PINTEGER,
  677|      1|	xmlSchemaTypeNonNegativeIntegerDef);
  678|      1|    if (xmlSchemaTypePositiveIntegerDef == NULL)
  ------------------
  |  Branch (678:9): [True: 0, False: 1]
  ------------------
  679|      0|        goto error;
  680|      1|    xmlSchemaTypeNormStringDef = xmlSchemaInitBasicType("normalizedString",
  681|      1|                                                        XML_SCHEMAS_NORMSTRING,
  682|      1|							xmlSchemaTypeStringDef);
  683|      1|    if (xmlSchemaTypeNormStringDef == NULL)
  ------------------
  |  Branch (683:9): [True: 0, False: 1]
  ------------------
  684|      0|        goto error;
  685|      1|    xmlSchemaTypeTokenDef = xmlSchemaInitBasicType("token",
  686|      1|                                                   XML_SCHEMAS_TOKEN,
  687|      1|						   xmlSchemaTypeNormStringDef);
  688|      1|    if (xmlSchemaTypeTokenDef == NULL)
  ------------------
  |  Branch (688:9): [True: 0, False: 1]
  ------------------
  689|      0|        goto error;
  690|      1|    xmlSchemaTypeLanguageDef = xmlSchemaInitBasicType("language",
  691|      1|                                                      XML_SCHEMAS_LANGUAGE,
  692|      1|						      xmlSchemaTypeTokenDef);
  693|      1|    if (xmlSchemaTypeLanguageDef == NULL)
  ------------------
  |  Branch (693:9): [True: 0, False: 1]
  ------------------
  694|      0|        goto error;
  695|      1|    xmlSchemaTypeNameDef = xmlSchemaInitBasicType("Name",
  696|      1|                                                  XML_SCHEMAS_NAME,
  697|      1|						  xmlSchemaTypeTokenDef);
  698|      1|    if (xmlSchemaTypeNameDef == NULL)
  ------------------
  |  Branch (698:9): [True: 0, False: 1]
  ------------------
  699|      0|        goto error;
  700|      1|    xmlSchemaTypeNmtokenDef = xmlSchemaInitBasicType("NMTOKEN",
  701|      1|                                                     XML_SCHEMAS_NMTOKEN,
  702|      1|						     xmlSchemaTypeTokenDef);
  703|      1|    if (xmlSchemaTypeNmtokenDef == NULL)
  ------------------
  |  Branch (703:9): [True: 0, False: 1]
  ------------------
  704|      0|        goto error;
  705|      1|    xmlSchemaTypeNCNameDef = xmlSchemaInitBasicType("NCName",
  706|      1|                                                    XML_SCHEMAS_NCNAME,
  707|      1|						    xmlSchemaTypeNameDef);
  708|      1|    if (xmlSchemaTypeNCNameDef == NULL)
  ------------------
  |  Branch (708:9): [True: 0, False: 1]
  ------------------
  709|      0|        goto error;
  710|      1|    xmlSchemaTypeIdDef = xmlSchemaInitBasicType("ID", XML_SCHEMAS_ID,
  711|      1|						    xmlSchemaTypeNCNameDef);
  712|      1|    if (xmlSchemaTypeIdDef == NULL)
  ------------------
  |  Branch (712:9): [True: 0, False: 1]
  ------------------
  713|      0|        goto error;
  714|      1|    xmlSchemaTypeIdrefDef = xmlSchemaInitBasicType("IDREF",
  715|      1|                                                   XML_SCHEMAS_IDREF,
  716|      1|						   xmlSchemaTypeNCNameDef);
  717|      1|    if (xmlSchemaTypeIdrefDef == NULL)
  ------------------
  |  Branch (717:9): [True: 0, False: 1]
  ------------------
  718|      0|        goto error;
  719|      1|    xmlSchemaTypeEntityDef = xmlSchemaInitBasicType("ENTITY",
  720|      1|                                                    XML_SCHEMAS_ENTITY,
  721|      1|						    xmlSchemaTypeNCNameDef);
  722|      1|    if (xmlSchemaTypeEntityDef == NULL)
  ------------------
  |  Branch (722:9): [True: 0, False: 1]
  ------------------
  723|      0|        goto error;
  724|       |    /*
  725|       |    * Derived list types.
  726|       |    */
  727|       |    /* ENTITIES */
  728|      1|    xmlSchemaTypeEntitiesDef = xmlSchemaInitBasicType("ENTITIES",
  729|      1|                                                      XML_SCHEMAS_ENTITIES,
  730|      1|						      xmlSchemaTypeAnySimpleTypeDef);
  731|      1|    if (xmlSchemaTypeEntitiesDef == NULL)
  ------------------
  |  Branch (731:9): [True: 0, False: 1]
  ------------------
  732|      0|        goto error;
  733|      1|    xmlSchemaTypeEntitiesDef->subtypes = xmlSchemaTypeEntityDef;
  734|       |    /* IDREFS */
  735|      1|    xmlSchemaTypeIdrefsDef = xmlSchemaInitBasicType("IDREFS",
  736|      1|                                                    XML_SCHEMAS_IDREFS,
  737|      1|						    xmlSchemaTypeAnySimpleTypeDef);
  738|      1|    if (xmlSchemaTypeIdrefsDef == NULL)
  ------------------
  |  Branch (738:9): [True: 0, False: 1]
  ------------------
  739|      0|        goto error;
  740|      1|    xmlSchemaTypeIdrefsDef->subtypes = xmlSchemaTypeIdrefDef;
  741|       |
  742|       |    /* NMTOKENS */
  743|      1|    xmlSchemaTypeNmtokensDef = xmlSchemaInitBasicType("NMTOKENS",
  744|      1|                                                      XML_SCHEMAS_NMTOKENS,
  745|      1|						      xmlSchemaTypeAnySimpleTypeDef);
  746|      1|    if (xmlSchemaTypeNmtokensDef == NULL)
  ------------------
  |  Branch (746:9): [True: 0, False: 1]
  ------------------
  747|      0|        goto error;
  748|      1|    xmlSchemaTypeNmtokensDef->subtypes = xmlSchemaTypeNmtokenDef;
  749|       |
  750|      1|    xmlSchemaTypesInitialized = 1;
  751|      1|    return (0);
  752|       |
  753|      0|error:
  754|      0|    xmlSchemaCleanupTypesInternal();
  755|      0|    return (-1);
  756|      1|}
xmlSchemaIsBuiltInTypeFacet:
  789|    214|{
  790|    214|    if (type == NULL)
  ------------------
  |  Branch (790:9): [True: 0, False: 214]
  ------------------
  791|      0|	return (-1);
  792|    214|    if (type->type != XML_SCHEMA_TYPE_BASIC)
  ------------------
  |  Branch (792:9): [True: 0, False: 214]
  ------------------
  793|      0|	return (-1);
  794|    214|    switch (type->builtInType) {
  795|      0|	case XML_SCHEMAS_BOOLEAN:
  ------------------
  |  Branch (795:2): [True: 0, False: 214]
  ------------------
  796|      0|	    if ((facetType == XML_SCHEMA_FACET_PATTERN) ||
  ------------------
  |  Branch (796:10): [True: 0, False: 0]
  ------------------
  797|      0|		(facetType == XML_SCHEMA_FACET_WHITESPACE))
  ------------------
  |  Branch (797:3): [True: 0, False: 0]
  ------------------
  798|      0|		return (1);
  799|      0|	    else
  800|      0|		return (0);
  801|    142|	case XML_SCHEMAS_STRING:
  ------------------
  |  Branch (801:2): [True: 142, False: 72]
  ------------------
  802|    142|	case XML_SCHEMAS_NOTATION:
  ------------------
  |  Branch (802:2): [True: 0, False: 214]
  ------------------
  803|    142|	case XML_SCHEMAS_QNAME:
  ------------------
  |  Branch (803:2): [True: 0, False: 214]
  ------------------
  804|    144|	case XML_SCHEMAS_ANYURI:
  ------------------
  |  Branch (804:2): [True: 2, False: 212]
  ------------------
  805|    144|	case XML_SCHEMAS_BASE64BINARY:
  ------------------
  |  Branch (805:2): [True: 0, False: 214]
  ------------------
  806|    147|	case XML_SCHEMAS_HEXBINARY:
  ------------------
  |  Branch (806:2): [True: 3, False: 211]
  ------------------
  807|    147|	    if ((facetType == XML_SCHEMA_FACET_LENGTH) ||
  ------------------
  |  Branch (807:10): [True: 1, False: 146]
  ------------------
  808|    147|		(facetType == XML_SCHEMA_FACET_MINLENGTH) ||
  ------------------
  |  Branch (808:3): [True: 1, False: 145]
  ------------------
  809|    147|		(facetType == XML_SCHEMA_FACET_MAXLENGTH) ||
  ------------------
  |  Branch (809:3): [True: 13, False: 132]
  ------------------
  810|    147|		(facetType == XML_SCHEMA_FACET_PATTERN) ||
  ------------------
  |  Branch (810:3): [True: 19, False: 113]
  ------------------
  811|    147|		(facetType == XML_SCHEMA_FACET_ENUMERATION) ||
  ------------------
  |  Branch (811:3): [True: 111, False: 2]
  ------------------
  812|    147|		(facetType == XML_SCHEMA_FACET_WHITESPACE))
  ------------------
  |  Branch (812:3): [True: 2, False: 0]
  ------------------
  813|    147|		return (1);
  814|      0|	    else
  815|      0|		return (0);
  816|     25|	case XML_SCHEMAS_DECIMAL:
  ------------------
  |  Branch (816:2): [True: 25, False: 189]
  ------------------
  817|     25|	    if ((facetType == XML_SCHEMA_FACET_TOTALDIGITS) ||
  ------------------
  |  Branch (817:10): [True: 7, False: 18]
  ------------------
  818|     25|		(facetType == XML_SCHEMA_FACET_FRACTIONDIGITS) ||
  ------------------
  |  Branch (818:3): [True: 0, False: 18]
  ------------------
  819|     25|		(facetType == XML_SCHEMA_FACET_PATTERN) ||
  ------------------
  |  Branch (819:3): [True: 3, False: 15]
  ------------------
  820|     25|		(facetType == XML_SCHEMA_FACET_WHITESPACE) ||
  ------------------
  |  Branch (820:3): [True: 0, False: 15]
  ------------------
  821|     25|		(facetType == XML_SCHEMA_FACET_ENUMERATION) ||
  ------------------
  |  Branch (821:3): [True: 0, False: 15]
  ------------------
  822|     25|		(facetType == XML_SCHEMA_FACET_MAXINCLUSIVE) ||
  ------------------
  |  Branch (822:3): [True: 4, False: 11]
  ------------------
  823|     25|		(facetType == XML_SCHEMA_FACET_MAXEXCLUSIVE) ||
  ------------------
  |  Branch (823:3): [True: 4, False: 7]
  ------------------
  824|     25|		(facetType == XML_SCHEMA_FACET_MININCLUSIVE) ||
  ------------------
  |  Branch (824:3): [True: 6, False: 1]
  ------------------
  825|     25|		(facetType == XML_SCHEMA_FACET_MINEXCLUSIVE))
  ------------------
  |  Branch (825:3): [True: 1, False: 0]
  ------------------
  826|     25|		return (1);
  827|      0|	    else
  828|      0|		return (0);
  829|      4|	case XML_SCHEMAS_TIME:
  ------------------
  |  Branch (829:2): [True: 4, False: 210]
  ------------------
  830|      6|	case XML_SCHEMAS_GDAY:
  ------------------
  |  Branch (830:2): [True: 2, False: 212]
  ------------------
  831|      8|	case XML_SCHEMAS_GMONTH:
  ------------------
  |  Branch (831:2): [True: 2, False: 212]
  ------------------
  832|     11|	case XML_SCHEMAS_GMONTHDAY:
  ------------------
  |  Branch (832:2): [True: 3, False: 211]
  ------------------
  833|     13|	case XML_SCHEMAS_GYEAR:
  ------------------
  |  Branch (833:2): [True: 2, False: 212]
  ------------------
  834|     15|	case XML_SCHEMAS_GYEARMONTH:
  ------------------
  |  Branch (834:2): [True: 2, False: 212]
  ------------------
  835|     22|	case XML_SCHEMAS_DATE:
  ------------------
  |  Branch (835:2): [True: 7, False: 207]
  ------------------
  836|     26|	case XML_SCHEMAS_DATETIME:
  ------------------
  |  Branch (836:2): [True: 4, False: 210]
  ------------------
  837|     40|	case XML_SCHEMAS_DURATION:
  ------------------
  |  Branch (837:2): [True: 14, False: 200]
  ------------------
  838|     40|	case XML_SCHEMAS_FLOAT:
  ------------------
  |  Branch (838:2): [True: 0, False: 214]
  ------------------
  839|     42|	case XML_SCHEMAS_DOUBLE:
  ------------------
  |  Branch (839:2): [True: 2, False: 212]
  ------------------
  840|     42|	    if ((facetType == XML_SCHEMA_FACET_PATTERN) ||
  ------------------
  |  Branch (840:10): [True: 3, False: 39]
  ------------------
  841|     42|		(facetType == XML_SCHEMA_FACET_ENUMERATION) ||
  ------------------
  |  Branch (841:3): [True: 3, False: 36]
  ------------------
  842|     42|		(facetType == XML_SCHEMA_FACET_WHITESPACE) ||
  ------------------
  |  Branch (842:3): [True: 0, False: 36]
  ------------------
  843|     42|		(facetType == XML_SCHEMA_FACET_MAXINCLUSIVE) ||
  ------------------
  |  Branch (843:3): [True: 11, False: 25]
  ------------------
  844|     42|		(facetType == XML_SCHEMA_FACET_MAXEXCLUSIVE) ||
  ------------------
  |  Branch (844:3): [True: 6, False: 19]
  ------------------
  845|     42|		(facetType == XML_SCHEMA_FACET_MININCLUSIVE) ||
  ------------------
  |  Branch (845:3): [True: 11, False: 8]
  ------------------
  846|     42|		(facetType == XML_SCHEMA_FACET_MINEXCLUSIVE))
  ------------------
  |  Branch (846:3): [True: 8, False: 0]
  ------------------
  847|     42|		return (1);
  848|      0|	    else
  849|      0|		return (0);
  850|      0|	default:
  ------------------
  |  Branch (850:2): [True: 0, False: 214]
  ------------------
  851|      0|	    break;
  852|    214|    }
  853|      0|    return (0);
  854|    214|}
xmlSchemaGetBuiltInType:
  867|  1.81k|{
  868|  1.81k|    if ((xmlSchemaTypesInitialized == 0) &&
  ------------------
  |  Branch (868:9): [True: 0, False: 1.81k]
  ------------------
  869|  1.81k|	(xmlSchemaInitTypes() < 0))
  ------------------
  |  Branch (869:2): [True: 0, False: 0]
  ------------------
  870|      0|        return (NULL);
  871|  1.81k|    switch (type) {
  872|       |
  873|     41|	case XML_SCHEMAS_ANYSIMPLETYPE:
  ------------------
  |  Branch (873:2): [True: 41, False: 1.77k]
  ------------------
  874|     41|	    return (xmlSchemaTypeAnySimpleTypeDef);
  875|     22|	case XML_SCHEMAS_STRING:
  ------------------
  |  Branch (875:2): [True: 22, False: 1.79k]
  ------------------
  876|     22|	    return (xmlSchemaTypeStringDef);
  877|      0|	case XML_SCHEMAS_NORMSTRING:
  ------------------
  |  Branch (877:2): [True: 0, False: 1.81k]
  ------------------
  878|      0|	    return (xmlSchemaTypeNormStringDef);
  879|      0|	case XML_SCHEMAS_DECIMAL:
  ------------------
  |  Branch (879:2): [True: 0, False: 1.81k]
  ------------------
  880|      0|	    return (xmlSchemaTypeDecimalDef);
  881|      0|	case XML_SCHEMAS_TIME:
  ------------------
  |  Branch (881:2): [True: 0, False: 1.81k]
  ------------------
  882|      0|	    return (xmlSchemaTypeTimeDef);
  883|      0|	case XML_SCHEMAS_GDAY:
  ------------------
  |  Branch (883:2): [True: 0, False: 1.81k]
  ------------------
  884|      0|	    return (xmlSchemaTypeGDayDef);
  885|      0|	case XML_SCHEMAS_GMONTH:
  ------------------
  |  Branch (885:2): [True: 0, False: 1.81k]
  ------------------
  886|      0|	    return (xmlSchemaTypeGMonthDef);
  887|      0|	case XML_SCHEMAS_GMONTHDAY:
  ------------------
  |  Branch (887:2): [True: 0, False: 1.81k]
  ------------------
  888|      0|	    return (xmlSchemaTypeGMonthDayDef);
  889|      0|	case XML_SCHEMAS_GYEAR:
  ------------------
  |  Branch (889:2): [True: 0, False: 1.81k]
  ------------------
  890|      0|	    return (xmlSchemaTypeGYearDef);
  891|      0|	case XML_SCHEMAS_GYEARMONTH:
  ------------------
  |  Branch (891:2): [True: 0, False: 1.81k]
  ------------------
  892|      0|	    return (xmlSchemaTypeGYearMonthDef);
  893|      0|	case XML_SCHEMAS_DATE:
  ------------------
  |  Branch (893:2): [True: 0, False: 1.81k]
  ------------------
  894|      0|	    return (xmlSchemaTypeDateDef);
  895|      0|	case XML_SCHEMAS_DATETIME:
  ------------------
  |  Branch (895:2): [True: 0, False: 1.81k]
  ------------------
  896|      0|	    return (xmlSchemaTypeDatetimeDef);
  897|      0|	case XML_SCHEMAS_DURATION:
  ------------------
  |  Branch (897:2): [True: 0, False: 1.81k]
  ------------------
  898|      0|	    return (xmlSchemaTypeDurationDef);
  899|      0|	case XML_SCHEMAS_FLOAT:
  ------------------
  |  Branch (899:2): [True: 0, False: 1.81k]
  ------------------
  900|      0|	    return (xmlSchemaTypeFloatDef);
  901|      0|	case XML_SCHEMAS_DOUBLE:
  ------------------
  |  Branch (901:2): [True: 0, False: 1.81k]
  ------------------
  902|      0|	    return (xmlSchemaTypeDoubleDef);
  903|      0|	case XML_SCHEMAS_BOOLEAN:
  ------------------
  |  Branch (903:2): [True: 0, False: 1.81k]
  ------------------
  904|      0|	    return (xmlSchemaTypeBooleanDef);
  905|      0|	case XML_SCHEMAS_TOKEN:
  ------------------
  |  Branch (905:2): [True: 0, False: 1.81k]
  ------------------
  906|      0|	    return (xmlSchemaTypeTokenDef);
  907|     10|	case XML_SCHEMAS_LANGUAGE:
  ------------------
  |  Branch (907:2): [True: 10, False: 1.80k]
  ------------------
  908|     10|	    return (xmlSchemaTypeLanguageDef);
  909|      4|	case XML_SCHEMAS_NMTOKEN:
  ------------------
  |  Branch (909:2): [True: 4, False: 1.81k]
  ------------------
  910|      4|	    return (xmlSchemaTypeNmtokenDef);
  911|      0|	case XML_SCHEMAS_NMTOKENS:
  ------------------
  |  Branch (911:2): [True: 0, False: 1.81k]
  ------------------
  912|      0|	    return (xmlSchemaTypeNmtokensDef);
  913|      0|	case XML_SCHEMAS_NAME:
  ------------------
  |  Branch (913:2): [True: 0, False: 1.81k]
  ------------------
  914|      0|	    return (xmlSchemaTypeNameDef);
  915|      0|	case XML_SCHEMAS_QNAME:
  ------------------
  |  Branch (915:2): [True: 0, False: 1.81k]
  ------------------
  916|      0|	    return (xmlSchemaTypeQNameDef);
  917|  1.12k|	case XML_SCHEMAS_NCNAME:
  ------------------
  |  Branch (917:2): [True: 1.12k, False: 692]
  ------------------
  918|  1.12k|	    return (xmlSchemaTypeNCNameDef);
  919|      0|	case XML_SCHEMAS_ID:
  ------------------
  |  Branch (919:2): [True: 0, False: 1.81k]
  ------------------
  920|      0|	    return (xmlSchemaTypeIdDef);
  921|      0|	case XML_SCHEMAS_IDREF:
  ------------------
  |  Branch (921:2): [True: 0, False: 1.81k]
  ------------------
  922|      0|	    return (xmlSchemaTypeIdrefDef);
  923|      0|	case XML_SCHEMAS_IDREFS:
  ------------------
  |  Branch (923:2): [True: 0, False: 1.81k]
  ------------------
  924|      0|	    return (xmlSchemaTypeIdrefsDef);
  925|      0|	case XML_SCHEMAS_ENTITY:
  ------------------
  |  Branch (925:2): [True: 0, False: 1.81k]
  ------------------
  926|      0|	    return (xmlSchemaTypeEntityDef);
  927|      0|	case XML_SCHEMAS_ENTITIES:
  ------------------
  |  Branch (927:2): [True: 0, False: 1.81k]
  ------------------
  928|      0|	    return (xmlSchemaTypeEntitiesDef);
  929|      0|	case XML_SCHEMAS_NOTATION:
  ------------------
  |  Branch (929:2): [True: 0, False: 1.81k]
  ------------------
  930|      0|	    return (xmlSchemaTypeNotationDef);
  931|    230|	case XML_SCHEMAS_ANYURI:
  ------------------
  |  Branch (931:2): [True: 230, False: 1.58k]
  ------------------
  932|    230|	    return (xmlSchemaTypeAnyURIDef);
  933|      0|	case XML_SCHEMAS_INTEGER:
  ------------------
  |  Branch (933:2): [True: 0, False: 1.81k]
  ------------------
  934|      0|	    return (xmlSchemaTypeIntegerDef);
  935|      0|	case XML_SCHEMAS_NPINTEGER:
  ------------------
  |  Branch (935:2): [True: 0, False: 1.81k]
  ------------------
  936|      0|	    return (xmlSchemaTypeNonPositiveIntegerDef);
  937|      0|	case XML_SCHEMAS_NINTEGER:
  ------------------
  |  Branch (937:2): [True: 0, False: 1.81k]
  ------------------
  938|      0|	    return (xmlSchemaTypeNegativeIntegerDef);
  939|     23|	case XML_SCHEMAS_NNINTEGER:
  ------------------
  |  Branch (939:2): [True: 23, False: 1.79k]
  ------------------
  940|     23|	    return (xmlSchemaTypeNonNegativeIntegerDef);
  941|      7|	case XML_SCHEMAS_PINTEGER:
  ------------------
  |  Branch (941:2): [True: 7, False: 1.81k]
  ------------------
  942|      7|	    return (xmlSchemaTypePositiveIntegerDef);
  943|      0|	case XML_SCHEMAS_INT:
  ------------------
  |  Branch (943:2): [True: 0, False: 1.81k]
  ------------------
  944|      0|	    return (xmlSchemaTypeIntDef);
  945|      0|	case XML_SCHEMAS_UINT:
  ------------------
  |  Branch (945:2): [True: 0, False: 1.81k]
  ------------------
  946|      0|	    return (xmlSchemaTypeUnsignedIntDef);
  947|      0|	case XML_SCHEMAS_LONG:
  ------------------
  |  Branch (947:2): [True: 0, False: 1.81k]
  ------------------
  948|      0|	    return (xmlSchemaTypeLongDef);
  949|      0|	case XML_SCHEMAS_ULONG:
  ------------------
  |  Branch (949:2): [True: 0, False: 1.81k]
  ------------------
  950|      0|	    return (xmlSchemaTypeUnsignedLongDef);
  951|      0|	case XML_SCHEMAS_SHORT:
  ------------------
  |  Branch (951:2): [True: 0, False: 1.81k]
  ------------------
  952|      0|	    return (xmlSchemaTypeShortDef);
  953|      0|	case XML_SCHEMAS_USHORT:
  ------------------
  |  Branch (953:2): [True: 0, False: 1.81k]
  ------------------
  954|      0|	    return (xmlSchemaTypeUnsignedShortDef);
  955|      0|	case XML_SCHEMAS_BYTE:
  ------------------
  |  Branch (955:2): [True: 0, False: 1.81k]
  ------------------
  956|      0|	    return (xmlSchemaTypeByteDef);
  957|      0|	case XML_SCHEMAS_UBYTE:
  ------------------
  |  Branch (957:2): [True: 0, False: 1.81k]
  ------------------
  958|      0|	    return (xmlSchemaTypeUnsignedByteDef);
  959|      0|	case XML_SCHEMAS_HEXBINARY:
  ------------------
  |  Branch (959:2): [True: 0, False: 1.81k]
  ------------------
  960|      0|	    return (xmlSchemaTypeHexBinaryDef);
  961|      0|	case XML_SCHEMAS_BASE64BINARY:
  ------------------
  |  Branch (961:2): [True: 0, False: 1.81k]
  ------------------
  962|      0|	    return (xmlSchemaTypeBase64BinaryDef);
  963|    355|	case XML_SCHEMAS_ANYTYPE:
  ------------------
  |  Branch (963:2): [True: 355, False: 1.46k]
  ------------------
  964|    355|	    return (xmlSchemaTypeAnyTypeDef);
  965|      0|	default:
  ------------------
  |  Branch (965:2): [True: 0, False: 1.81k]
  ------------------
  966|      0|	    return (NULL);
  967|  1.81k|    }
  968|  1.81k|}
xmlSchemaValueGetNext:
  998|     18|xmlSchemaValueGetNext(xmlSchemaValPtr cur) {
  999|       |
 1000|     18|    if (cur == NULL)
  ------------------
  |  Branch (1000:9): [True: 0, False: 18]
  ------------------
 1001|      0|	return (NULL);
 1002|     18|    return (cur->next);
 1003|     18|}
xmlSchemaValueGetAsString:
 1016|     34|{
 1017|     34|    if (val == NULL)
  ------------------
  |  Branch (1017:9): [True: 0, False: 34]
  ------------------
 1018|      0|	return (NULL);
 1019|     34|    switch (val->type) {
 1020|     22|	case XML_SCHEMAS_STRING:
  ------------------
  |  Branch (1020:2): [True: 22, False: 12]
  ------------------
 1021|     22|	case XML_SCHEMAS_NORMSTRING:
  ------------------
  |  Branch (1021:2): [True: 0, False: 34]
  ------------------
 1022|     22|	case XML_SCHEMAS_ANYSIMPLETYPE:
  ------------------
  |  Branch (1022:2): [True: 0, False: 34]
  ------------------
 1023|     22|	case XML_SCHEMAS_TOKEN:
  ------------------
  |  Branch (1023:2): [True: 0, False: 34]
  ------------------
 1024|     22|        case XML_SCHEMAS_LANGUAGE:
  ------------------
  |  Branch (1024:9): [True: 0, False: 34]
  ------------------
 1025|     26|        case XML_SCHEMAS_NMTOKEN:
  ------------------
  |  Branch (1025:9): [True: 4, False: 30]
  ------------------
 1026|     26|        case XML_SCHEMAS_NAME:
  ------------------
  |  Branch (1026:9): [True: 0, False: 34]
  ------------------
 1027|     34|        case XML_SCHEMAS_NCNAME:
  ------------------
  |  Branch (1027:9): [True: 8, False: 26]
  ------------------
 1028|     34|        case XML_SCHEMAS_ID:
  ------------------
  |  Branch (1028:9): [True: 0, False: 34]
  ------------------
 1029|     34|        case XML_SCHEMAS_IDREF:
  ------------------
  |  Branch (1029:9): [True: 0, False: 34]
  ------------------
 1030|     34|        case XML_SCHEMAS_ENTITY:
  ------------------
  |  Branch (1030:9): [True: 0, False: 34]
  ------------------
 1031|     34|        case XML_SCHEMAS_ANYURI:
  ------------------
  |  Branch (1031:9): [True: 0, False: 34]
  ------------------
 1032|     34|	    return (BAD_CAST val->value.str);
  ------------------
  |  |   35|     34|#define BAD_CAST (xmlChar *)
  ------------------
 1033|      0|	default:
  ------------------
  |  Branch (1033:2): [True: 0, False: 34]
  ------------------
 1034|      0|	    break;
 1035|     34|    }
 1036|      0|    return (NULL);
 1037|     34|}
xmlSchemaFreeValue:
 1144|    227|xmlSchemaFreeValue(xmlSchemaValPtr value) {
 1145|    227|    xmlSchemaValPtr prev;
 1146|       |
 1147|    454|    while (value != NULL) {
  ------------------
  |  Branch (1147:12): [True: 227, False: 227]
  ------------------
 1148|    227|	switch (value->type) {
 1149|     36|	    case XML_SCHEMAS_STRING:
  ------------------
  |  Branch (1149:6): [True: 36, False: 191]
  ------------------
 1150|     36|	    case XML_SCHEMAS_NORMSTRING:
  ------------------
  |  Branch (1150:6): [True: 0, False: 227]
  ------------------
 1151|     79|	    case XML_SCHEMAS_TOKEN:
  ------------------
  |  Branch (1151:6): [True: 43, False: 184]
  ------------------
 1152|     88|	    case XML_SCHEMAS_LANGUAGE:
  ------------------
  |  Branch (1152:6): [True: 9, False: 218]
  ------------------
 1153|    108|	    case XML_SCHEMAS_NMTOKEN:
  ------------------
  |  Branch (1153:6): [True: 20, False: 207]
  ------------------
 1154|    108|	    case XML_SCHEMAS_NMTOKENS:
  ------------------
  |  Branch (1154:6): [True: 0, False: 227]
  ------------------
 1155|    108|	    case XML_SCHEMAS_NAME:
  ------------------
  |  Branch (1155:6): [True: 0, False: 227]
  ------------------
 1156|    114|	    case XML_SCHEMAS_NCNAME:
  ------------------
  |  Branch (1156:6): [True: 6, False: 221]
  ------------------
 1157|    122|	    case XML_SCHEMAS_ID:
  ------------------
  |  Branch (1157:6): [True: 8, False: 219]
  ------------------
 1158|    122|	    case XML_SCHEMAS_IDREF:
  ------------------
  |  Branch (1158:6): [True: 0, False: 227]
  ------------------
 1159|    122|	    case XML_SCHEMAS_IDREFS:
  ------------------
  |  Branch (1159:6): [True: 0, False: 227]
  ------------------
 1160|    122|	    case XML_SCHEMAS_ENTITY:
  ------------------
  |  Branch (1160:6): [True: 0, False: 227]
  ------------------
 1161|    122|	    case XML_SCHEMAS_ENTITIES:
  ------------------
  |  Branch (1161:6): [True: 0, False: 227]
  ------------------
 1162|    123|	    case XML_SCHEMAS_ANYURI:
  ------------------
  |  Branch (1162:6): [True: 1, False: 226]
  ------------------
 1163|    123|	    case XML_SCHEMAS_ANYSIMPLETYPE:
  ------------------
  |  Branch (1163:6): [True: 0, False: 227]
  ------------------
 1164|    123|		if (value->value.str != NULL)
  ------------------
  |  Branch (1164:7): [True: 123, False: 0]
  ------------------
 1165|    123|		    xmlFree(value->value.str);
 1166|    123|		break;
 1167|      0|	    case XML_SCHEMAS_NOTATION:
  ------------------
  |  Branch (1167:6): [True: 0, False: 227]
  ------------------
 1168|      0|	    case XML_SCHEMAS_QNAME:
  ------------------
  |  Branch (1168:6): [True: 0, False: 227]
  ------------------
 1169|      0|		if (value->value.qname.uri != NULL)
  ------------------
  |  Branch (1169:7): [True: 0, False: 0]
  ------------------
 1170|      0|		    xmlFree(value->value.qname.uri);
 1171|      0|		if (value->value.qname.name != NULL)
  ------------------
  |  Branch (1171:7): [True: 0, False: 0]
  ------------------
 1172|      0|		    xmlFree(value->value.qname.name);
 1173|      0|		break;
 1174|      0|	    case XML_SCHEMAS_HEXBINARY:
  ------------------
  |  Branch (1174:6): [True: 0, False: 227]
  ------------------
 1175|      0|		if (value->value.hex.str != NULL)
  ------------------
  |  Branch (1175:7): [True: 0, False: 0]
  ------------------
 1176|      0|		    xmlFree(value->value.hex.str);
 1177|      0|		break;
 1178|      0|	    case XML_SCHEMAS_BASE64BINARY:
  ------------------
  |  Branch (1178:6): [True: 0, False: 227]
  ------------------
 1179|      0|		if (value->value.base64.str != NULL)
  ------------------
  |  Branch (1179:7): [True: 0, False: 0]
  ------------------
 1180|      0|		    xmlFree(value->value.base64.str);
 1181|      0|		break;
 1182|    104|	    default:
  ------------------
  |  Branch (1182:6): [True: 104, False: 123]
  ------------------
 1183|    104|		break;
 1184|    227|	}
 1185|    227|	prev = value;
 1186|    227|	value = value->next;
 1187|    227|	xmlFree(prev);
 1188|    227|    }
 1189|    227|}
xmlSchemaGetPredefinedType:
 1201|    405|xmlSchemaGetPredefinedType(const xmlChar *name, const xmlChar *ns) {
 1202|    405|    if ((xmlSchemaTypesInitialized == 0) &&
  ------------------
  |  Branch (1202:9): [True: 0, False: 405]
  ------------------
 1203|    405|	(xmlSchemaInitTypes() < 0))
  ------------------
  |  Branch (1203:2): [True: 0, False: 0]
  ------------------
 1204|      0|        return (NULL);
 1205|    405|    if (name == NULL)
  ------------------
  |  Branch (1205:9): [True: 0, False: 405]
  ------------------
 1206|      0|	return(NULL);
 1207|    405|    return((xmlSchemaTypePtr) xmlHashLookup2(xmlSchemaTypesBank, name, ns));
 1208|    405|}
xmlSchemaCollapseString:
 2125|  1.78k|xmlSchemaCollapseString(const xmlChar *value) {
 2126|  1.78k|    const xmlChar *start = value, *end, *f;
 2127|  1.78k|    xmlChar *g;
 2128|  1.78k|    int col = 0;
 2129|       |
 2130|  1.78k|    if (value == NULL) return(NULL);
  ------------------
  |  Branch (2130:9): [True: 0, False: 1.78k]
  ------------------
 2131|  1.78k|    while ((*start != 0) && (IS_BLANK_CH(*start))) start++;
  ------------------
  |  |  151|  1.78k|#define IS_BLANK_CH(c)  xmlIsBlank_ch(c)
  |  |  ------------------
  |  |  |  |   88|  1.78k|#define xmlIsBlank_ch(c)	(((c) == 0x20) || \
  |  |  |  |  ------------------
  |  |  |  |  |  Branch (88:27): [True: 0, False: 1.78k]
  |  |  |  |  ------------------
  |  |  |  |   89|  1.78k|				 ((0x9 <= (c)) && ((c) <= 0xa)) || \
  |  |  |  |  ------------------
  |  |  |  |  |  Branch (89:7): [True: 1.78k, False: 0]
  |  |  |  |  |  Branch (89:23): [True: 0, False: 1.78k]
  |  |  |  |  ------------------
  |  |  |  |   90|  1.78k|				 ((c) == 0xd))
  |  |  |  |  ------------------
  |  |  |  |  |  Branch (90:6): [True: 0, False: 1.78k]
  |  |  |  |  ------------------
  |  |  ------------------
  ------------------
  |  Branch (2131:12): [True: 1.78k, False: 0]
  ------------------
 2132|  1.78k|    end = start;
 2133|  18.9k|    while (*end != 0) {
  ------------------
  |  Branch (2133:12): [True: 17.1k, False: 1.78k]
  ------------------
 2134|  17.1k|	if ((*end == ' ') && (IS_BLANK_CH(end[1]))) {
  ------------------
  |  |  151|      0|#define IS_BLANK_CH(c)  xmlIsBlank_ch(c)
  |  |  ------------------
  |  |  |  |   88|      0|#define xmlIsBlank_ch(c)	(((c) == 0x20) || \
  |  |  |  |  ------------------
  |  |  |  |  |  Branch (88:27): [True: 0, False: 0]
  |  |  |  |  ------------------
  |  |  |  |   89|      0|				 ((0x9 <= (c)) && ((c) <= 0xa)) || \
  |  |  |  |  ------------------
  |  |  |  |  |  Branch (89:7): [True: 0, False: 0]
  |  |  |  |  |  Branch (89:23): [True: 0, False: 0]
  |  |  |  |  ------------------
  |  |  |  |   90|      0|				 ((c) == 0xd))
  |  |  |  |  ------------------
  |  |  |  |  |  Branch (90:6): [True: 0, False: 0]
  |  |  |  |  ------------------
  |  |  ------------------
  ------------------
  |  Branch (2134:6): [True: 0, False: 17.1k]
  ------------------
 2135|      0|	    col = end - start;
 2136|      0|	    break;
 2137|  17.1k|	} else if ((*end == 0xa) || (*end == 0x9) || (*end == 0xd)) {
  ------------------
  |  Branch (2137:13): [True: 0, False: 17.1k]
  |  Branch (2137:30): [True: 0, False: 17.1k]
  |  Branch (2137:47): [True: 0, False: 17.1k]
  ------------------
 2138|      0|	    col = end - start;
 2139|      0|	    break;
 2140|      0|	}
 2141|  17.1k|	end++;
 2142|  17.1k|    }
 2143|  1.78k|    if (col == 0) {
  ------------------
  |  Branch (2143:9): [True: 1.78k, False: 0]
  ------------------
 2144|  1.78k|	f = end;
 2145|  1.78k|	end--;
 2146|  1.78k|	while ((end > start) && (IS_BLANK_CH(*end))) end--;
  ------------------
  |  |  151|  1.71k|#define IS_BLANK_CH(c)  xmlIsBlank_ch(c)
  |  |  ------------------
  |  |  |  |   88|  1.71k|#define xmlIsBlank_ch(c)	(((c) == 0x20) || \
  |  |  |  |  ------------------
  |  |  |  |  |  Branch (88:27): [True: 0, False: 1.71k]
  |  |  |  |  ------------------
  |  |  |  |   89|  1.71k|				 ((0x9 <= (c)) && ((c) <= 0xa)) || \
  |  |  |  |  ------------------
  |  |  |  |  |  Branch (89:7): [True: 1.71k, False: 0]
  |  |  |  |  |  Branch (89:23): [True: 0, False: 1.71k]
  |  |  |  |  ------------------
  |  |  |  |   90|  1.71k|				 ((c) == 0xd))
  |  |  |  |  ------------------
  |  |  |  |  |  Branch (90:6): [True: 0, False: 1.71k]
  |  |  |  |  ------------------
  |  |  ------------------
  ------------------
  |  Branch (2146:9): [True: 1.71k, False: 65]
  ------------------
 2147|  1.78k|	end++;
 2148|  1.78k|	if ((start == value) && (f == end)) return(NULL);
  ------------------
  |  Branch (2148:6): [True: 1.78k, False: 0]
  |  Branch (2148:26): [True: 1.78k, False: 0]
  ------------------
 2149|      0|	return(xmlStrndup(start, end - start));
 2150|  1.78k|    }
 2151|      0|    start = xmlStrdup(start);
 2152|      0|    if (start == NULL) return(NULL);
  ------------------
  |  Branch (2152:9): [True: 0, False: 0]
  ------------------
 2153|      0|    g = (xmlChar *) (start + col);
 2154|      0|    end = g;
 2155|      0|    while (*end != 0) {
  ------------------
  |  Branch (2155:12): [True: 0, False: 0]
  ------------------
 2156|      0|	if (IS_BLANK_CH(*end)) {
  ------------------
  |  |  151|      0|#define IS_BLANK_CH(c)  xmlIsBlank_ch(c)
  |  |  ------------------
  |  |  |  |   88|      0|#define xmlIsBlank_ch(c)	(((c) == 0x20) || \
  |  |  |  |  ------------------
  |  |  |  |  |  Branch (88:27): [True: 0, False: 0]
  |  |  |  |  ------------------
  |  |  |  |   89|      0|				 ((0x9 <= (c)) && ((c) <= 0xa)) || \
  |  |  |  |  ------------------
  |  |  |  |  |  Branch (89:7): [True: 0, False: 0]
  |  |  |  |  |  Branch (89:23): [True: 0, False: 0]
  |  |  |  |  ------------------
  |  |  |  |   90|      0|				 ((c) == 0xd))
  |  |  |  |  ------------------
  |  |  |  |  |  Branch (90:6): [True: 0, False: 0]
  |  |  |  |  ------------------
  |  |  ------------------
  ------------------
 2157|      0|	    end++;
 2158|      0|	    while (IS_BLANK_CH(*end)) end++;
 2159|      0|	    if (*end != 0)
  ------------------
  |  Branch (2159:10): [True: 0, False: 0]
  ------------------
 2160|      0|		*g++ = ' ';
 2161|      0|	} else
 2162|      0|	    *g++ = *end++;
 2163|      0|    }
 2164|      0|    *g = 0;
 2165|      0|    return((xmlChar *) start);
 2166|      0|}
xmlSchemaValPredefTypeNode:
 3583|  1.37k|	                   xmlSchemaValPtr *val, xmlNodePtr node) {
 3584|  1.37k|    return(xmlSchemaValAtomicType(type, value, val, node, 0,
 3585|  1.37k|	XML_SCHEMA_WHITESPACE_UNKNOWN, 1, 1, 0));
 3586|  1.37k|}
xmlSchemaValPredefTypeNodeNoNorm:
 3604|    177|				 xmlSchemaValPtr *val, xmlNodePtr node) {
 3605|    177|    return(xmlSchemaValAtomicType(type, value, val, node, 1,
 3606|    177|	XML_SCHEMA_WHITESPACE_UNKNOWN, 1, 0, 1));
 3607|    177|}
xmlSchemaValidatePredefinedType:
 3623|     30|	                        xmlSchemaValPtr *val) {
 3624|     30|    return(xmlSchemaValPredefTypeNode(type, value, val, NULL));
 3625|     30|}
xmlSchemaCompareValues:
 5190|     21|xmlSchemaCompareValues(xmlSchemaValPtr x, xmlSchemaValPtr y) {
 5191|     21|    xmlSchemaWhitespaceValueType xws, yws;
 5192|       |
 5193|     21|    if ((x == NULL) || (y == NULL))
  ------------------
  |  Branch (5193:9): [True: 0, False: 21]
  |  Branch (5193:24): [True: 0, False: 21]
  ------------------
 5194|      0|        return(-2);
 5195|     21|    if (x->type == XML_SCHEMAS_STRING)
  ------------------
  |  Branch (5195:9): [True: 0, False: 21]
  ------------------
 5196|      0|	xws = XML_SCHEMA_WHITESPACE_PRESERVE;
 5197|     21|    else if (x->type == XML_SCHEMAS_NORMSTRING)
  ------------------
  |  Branch (5197:14): [True: 0, False: 21]
  ------------------
 5198|      0|        xws = XML_SCHEMA_WHITESPACE_REPLACE;
 5199|     21|    else
 5200|     21|        xws = XML_SCHEMA_WHITESPACE_COLLAPSE;
 5201|       |
 5202|     21|    if (y->type == XML_SCHEMAS_STRING)
  ------------------
  |  Branch (5202:9): [True: 0, False: 21]
  ------------------
 5203|      0|	yws = XML_SCHEMA_WHITESPACE_PRESERVE;
 5204|     21|    else if (y->type == XML_SCHEMAS_NORMSTRING)
  ------------------
  |  Branch (5204:14): [True: 0, False: 21]
  ------------------
 5205|      0|        yws = XML_SCHEMA_WHITESPACE_REPLACE;
 5206|     21|    else
 5207|     21|        yws = XML_SCHEMA_WHITESPACE_COLLAPSE;
 5208|       |
 5209|     21|    return(xmlSchemaCompareValuesInternal(x->type, x, NULL, xws, y->type,
 5210|     21|	y, NULL, yws));
 5211|     21|}
xmlSchemaValidateLengthFacetWhtsp:
 5545|      1|{
 5546|      1|    return (xmlSchemaValidateLengthFacetInternal(facet, valType, value, val,
 5547|      1|	length, ws));
 5548|      1|}
xmlSchemaGetValType:
 6412|     44|{
 6413|     44|    if (val == NULL)
  ------------------
  |  Branch (6413:9): [True: 0, False: 44]
  ------------------
 6414|      0|        return(XML_SCHEMAS_UNKNOWN);
 6415|     44|    return (val->type);
 6416|     44|}
xmlschemastypes.c:xmlSchemaInitBasicType:
  263|     46|		       xmlSchemaTypePtr baseType) {
  264|     46|    xmlSchemaTypePtr ret;
  265|       |
  266|     46|    ret = (xmlSchemaTypePtr) xmlMalloc(sizeof(xmlSchemaType));
  267|     46|    if (ret == NULL) {
  ------------------
  |  Branch (267:9): [True: 0, False: 46]
  ------------------
  268|      0|        xmlSchemaTypeErrMemory(NULL, "could not initialize basic types");
  269|      0|	return(NULL);
  270|      0|    }
  271|     46|    memset(ret, 0, sizeof(xmlSchemaType));
  272|     46|    ret->name = (const xmlChar *)name;
  273|     46|    ret->targetNamespace = XML_SCHEMAS_NAMESPACE_NAME;
  ------------------
  |  |   50|     46|    (const xmlChar *)"http://www.w3.org/2001/XMLSchema"
  ------------------
  274|     46|    ret->type = XML_SCHEMA_TYPE_BASIC;
  275|     46|    ret->baseType = baseType;
  276|     46|    ret->contentType = XML_SCHEMA_CONTENT_BASIC;
  277|       |    /*
  278|       |    * Primitive types.
  279|       |    */
  280|     46|    switch (type) {
  281|      1|	case XML_SCHEMAS_STRING:
  ------------------
  |  Branch (281:2): [True: 1, False: 45]
  ------------------
  282|      2|	case XML_SCHEMAS_DECIMAL:
  ------------------
  |  Branch (282:2): [True: 1, False: 45]
  ------------------
  283|      3|	case XML_SCHEMAS_DATE:
  ------------------
  |  Branch (283:2): [True: 1, False: 45]
  ------------------
  284|      4|	case XML_SCHEMAS_DATETIME:
  ------------------
  |  Branch (284:2): [True: 1, False: 45]
  ------------------
  285|      5|	case XML_SCHEMAS_TIME:
  ------------------
  |  Branch (285:2): [True: 1, False: 45]
  ------------------
  286|      6|	case XML_SCHEMAS_GYEAR:
  ------------------
  |  Branch (286:2): [True: 1, False: 45]
  ------------------
  287|      7|	case XML_SCHEMAS_GYEARMONTH:
  ------------------
  |  Branch (287:2): [True: 1, False: 45]
  ------------------
  288|      8|	case XML_SCHEMAS_GMONTH:
  ------------------
  |  Branch (288:2): [True: 1, False: 45]
  ------------------
  289|      9|	case XML_SCHEMAS_GMONTHDAY:
  ------------------
  |  Branch (289:2): [True: 1, False: 45]
  ------------------
  290|     10|	case XML_SCHEMAS_GDAY:
  ------------------
  |  Branch (290:2): [True: 1, False: 45]
  ------------------
  291|     11|	case XML_SCHEMAS_DURATION:
  ------------------
  |  Branch (291:2): [True: 1, False: 45]
  ------------------
  292|     12|	case XML_SCHEMAS_FLOAT:
  ------------------
  |  Branch (292:2): [True: 1, False: 45]
  ------------------
  293|     13|	case XML_SCHEMAS_DOUBLE:
  ------------------
  |  Branch (293:2): [True: 1, False: 45]
  ------------------
  294|     14|	case XML_SCHEMAS_BOOLEAN:
  ------------------
  |  Branch (294:2): [True: 1, False: 45]
  ------------------
  295|     15|	case XML_SCHEMAS_ANYURI:
  ------------------
  |  Branch (295:2): [True: 1, False: 45]
  ------------------
  296|     16|	case XML_SCHEMAS_HEXBINARY:
  ------------------
  |  Branch (296:2): [True: 1, False: 45]
  ------------------
  297|     17|	case XML_SCHEMAS_BASE64BINARY:
  ------------------
  |  Branch (297:2): [True: 1, False: 45]
  ------------------
  298|     18|	case XML_SCHEMAS_QNAME:
  ------------------
  |  Branch (298:2): [True: 1, False: 45]
  ------------------
  299|     19|	case XML_SCHEMAS_NOTATION:
  ------------------
  |  Branch (299:2): [True: 1, False: 45]
  ------------------
  300|     19|	    ret->flags |= XML_SCHEMAS_TYPE_BUILTIN_PRIMITIVE;
  ------------------
  |  |  496|     19|#define XML_SCHEMAS_TYPE_BUILTIN_PRIMITIVE    1 << 14
  ------------------
  301|     19|	    break;
  302|     27|	default:
  ------------------
  |  Branch (302:2): [True: 27, False: 19]
  ------------------
  303|     27|	    break;
  304|     46|    }
  305|       |    /*
  306|       |    * Set variety.
  307|       |    */
  308|     46|    switch (type) {
  309|      1|	case XML_SCHEMAS_ANYTYPE:
  ------------------
  |  Branch (309:2): [True: 1, False: 45]
  ------------------
  310|      2|	case XML_SCHEMAS_ANYSIMPLETYPE:
  ------------------
  |  Branch (310:2): [True: 1, False: 45]
  ------------------
  311|      2|	    break;
  312|      1|	case XML_SCHEMAS_IDREFS:
  ------------------
  |  Branch (312:2): [True: 1, False: 45]
  ------------------
  313|      2|	case XML_SCHEMAS_NMTOKENS:
  ------------------
  |  Branch (313:2): [True: 1, False: 45]
  ------------------
  314|      3|	case XML_SCHEMAS_ENTITIES:
  ------------------
  |  Branch (314:2): [True: 1, False: 45]
  ------------------
  315|      3|	    ret->flags |= XML_SCHEMAS_TYPE_VARIETY_LIST;
  ------------------
  |  |  448|      3|#define XML_SCHEMAS_TYPE_VARIETY_LIST    1 << 6
  ------------------
  316|      3|	    ret->facets = xmlSchemaNewMinLengthFacet(1);
  317|      3|	    ret->flags |= XML_SCHEMAS_TYPE_HAS_FACETS;
  ------------------
  |  |  569|      3|#define XML_SCHEMAS_TYPE_HAS_FACETS    1 << 27
  ------------------
  318|      3|	    break;
  319|     41|	default:
  ------------------
  |  Branch (319:2): [True: 41, False: 5]
  ------------------
  320|     41|	    ret->flags |= XML_SCHEMAS_TYPE_VARIETY_ATOMIC;
  ------------------
  |  |  460|     41|#define XML_SCHEMAS_TYPE_VARIETY_ATOMIC    1 << 8
  ------------------
  321|     41|	    break;
  322|     46|    }
  323|     46|    xmlHashAddEntry2(xmlSchemaTypesBank, ret->name,
  324|     46|	             XML_SCHEMAS_NAMESPACE_NAME, ret);
  ------------------
  |  |   50|     46|    (const xmlChar *)"http://www.w3.org/2001/XMLSchema"
  ------------------
  325|     46|    ret->builtInType = type;
  326|     46|    return(ret);
  327|     46|}
xmlschemastypes.c:xmlSchemaNewMinLengthFacet:
  237|      3|{
  238|      3|    xmlSchemaFacetPtr ret;
  239|       |
  240|      3|    ret = xmlSchemaNewFacet();
  241|      3|    if (ret == NULL) {
  ------------------
  |  Branch (241:9): [True: 0, False: 3]
  ------------------
  242|      0|        return(NULL);
  243|      0|    }
  244|      3|    ret->type = XML_SCHEMA_FACET_MINLENGTH;
  245|      3|    ret->val = xmlSchemaNewValue(XML_SCHEMAS_NNINTEGER);
  246|      3|    if (ret->val == NULL) {
  ------------------
  |  Branch (246:9): [True: 0, False: 3]
  ------------------
  247|      0|        xmlFree(ret);
  248|      0|	return(NULL);
  249|      0|    }
  250|      3|    ret->val->value.decimal.lo = value;
  251|      3|    return (ret);
  252|      3|}
xmlschemastypes.c:xmlSchemaAddParticle:
  370|      2|{
  371|      2|    xmlSchemaParticlePtr ret = NULL;
  372|       |
  373|      2|    ret = (xmlSchemaParticlePtr)
  374|      2|	xmlMalloc(sizeof(xmlSchemaParticle));
  375|      2|    if (ret == NULL) {
  ------------------
  |  Branch (375:9): [True: 0, False: 2]
  ------------------
  376|      0|	xmlSchemaTypeErrMemory(NULL, "allocating particle component");
  377|      0|	return (NULL);
  378|      0|    }
  379|      2|    memset(ret, 0, sizeof(xmlSchemaParticle));
  380|      2|    ret->type = XML_SCHEMA_TYPE_PARTICLE;
  381|      2|    ret->minOccurs = 1;
  382|      2|    ret->maxOccurs = 1;
  383|      2|    return (ret);
  384|      2|}
xmlschemastypes.c:xmlSchemaNewValue:
  223|    230|xmlSchemaNewValue(xmlSchemaValType type) {
  224|    230|    xmlSchemaValPtr value;
  225|       |
  226|    230|    value = (xmlSchemaValPtr) xmlMalloc(sizeof(xmlSchemaVal));
  227|    230|    if (value == NULL) {
  ------------------
  |  Branch (227:9): [True: 0, False: 230]
  ------------------
  228|      0|	return(NULL);
  229|      0|    }
  230|    230|    memset(value, 0, sizeof(xmlSchemaVal));
  231|    230|    value->type = type;
  232|    230|    return(value);
  233|    230|}
xmlschemastypes.c:xmlSchemaValAtomicType:
 2349|  1.55k|{
 2350|  1.55k|    xmlSchemaValPtr v;
 2351|  1.55k|    xmlChar *norm = NULL;
 2352|  1.55k|    int ret = 0;
 2353|       |
 2354|  1.55k|    if ((xmlSchemaTypesInitialized == 0) &&
  ------------------
  |  Branch (2354:9): [True: 0, False: 1.55k]
  ------------------
 2355|  1.55k|	(xmlSchemaInitTypes() < 0))
  ------------------
  |  Branch (2355:2): [True: 0, False: 0]
  ------------------
 2356|      0|        return (-1);
 2357|  1.55k|    if (type == NULL)
  ------------------
  |  Branch (2357:9): [True: 0, False: 1.55k]
  ------------------
 2358|      0|        return (-1);
 2359|       |
 2360|       |    /*
 2361|       |     * validating a non existent text node is similar to validating
 2362|       |     * an empty one.
 2363|       |     */
 2364|  1.55k|    if (value == NULL)
  ------------------
  |  Branch (2364:9): [True: 0, False: 1.55k]
  ------------------
 2365|      0|        value = BAD_CAST "";
  ------------------
  |  |   35|      0|#define BAD_CAST (xmlChar *)
  ------------------
 2366|       |
 2367|  1.55k|    if (val != NULL)
  ------------------
  |  Branch (2367:9): [True: 207, False: 1.34k]
  ------------------
 2368|    207|        *val = NULL;
 2369|  1.55k|    if ((flags == 0) && (value != NULL)) {
  ------------------
  |  Branch (2369:9): [True: 1.37k, False: 177]
  |  Branch (2369:25): [True: 1.37k, False: 0]
  ------------------
 2370|       |
 2371|  1.37k|        if ((type->builtInType != XML_SCHEMAS_STRING) &&
  ------------------
  |  Branch (2371:13): [True: 1.37k, False: 0]
  ------------------
 2372|  1.37k|	  (type->builtInType != XML_SCHEMAS_ANYTYPE) &&
  ------------------
  |  Branch (2372:4): [True: 1.37k, False: 0]
  ------------------
 2373|  1.37k|	  (type->builtInType != XML_SCHEMAS_ANYSIMPLETYPE)) {
  ------------------
  |  Branch (2373:4): [True: 1.37k, False: 0]
  ------------------
 2374|  1.37k|	    if (type->builtInType == XML_SCHEMAS_NORMSTRING)
  ------------------
  |  Branch (2374:10): [True: 0, False: 1.37k]
  ------------------
 2375|      0|		norm = xmlSchemaWhiteSpaceReplace(value);
 2376|  1.37k|            else
 2377|  1.37k|		norm = xmlSchemaCollapseString(value);
 2378|  1.37k|            if (norm != NULL)
  ------------------
  |  Branch (2378:17): [True: 0, False: 1.37k]
  ------------------
 2379|      0|                value = norm;
 2380|  1.37k|        }
 2381|  1.37k|    }
 2382|       |
 2383|  1.55k|    switch (type->builtInType) {
  ------------------
  |  Branch (2383:13): [True: 0, False: 1.55k]
  ------------------
 2384|      0|        case XML_SCHEMAS_UNKNOWN:
  ------------------
  |  Branch (2384:9): [True: 0, False: 1.55k]
  ------------------
 2385|      0|            goto error;
 2386|      0|	case XML_SCHEMAS_ANYTYPE:
  ------------------
  |  Branch (2386:2): [True: 0, False: 1.55k]
  ------------------
 2387|      0|	case XML_SCHEMAS_ANYSIMPLETYPE:
  ------------------
  |  Branch (2387:2): [True: 0, False: 1.55k]
  ------------------
 2388|      0|	    if ((createStringValue) && (val != NULL)) {
  ------------------
  |  Branch (2388:10): [True: 0, False: 0]
  |  Branch (2388:33): [True: 0, False: 0]
  ------------------
 2389|      0|		v = xmlSchemaNewValue(XML_SCHEMAS_ANYSIMPLETYPE);
 2390|      0|		if (v != NULL) {
  ------------------
  |  Branch (2390:7): [True: 0, False: 0]
  ------------------
 2391|      0|		    v->value.str = xmlStrdup(value);
 2392|      0|		    *val = v;
 2393|      0|		} else {
 2394|      0|		    goto error;
 2395|      0|		}
 2396|      0|	    }
 2397|      0|	    goto return0;
 2398|     36|        case XML_SCHEMAS_STRING:
  ------------------
  |  Branch (2398:9): [True: 36, False: 1.52k]
  ------------------
 2399|     36|	    if (! normOnTheFly) {
  ------------------
  |  Branch (2399:10): [True: 0, False: 36]
  ------------------
 2400|      0|		const xmlChar *cur = value;
 2401|       |
 2402|      0|		if (ws == XML_SCHEMA_WHITESPACE_REPLACE) {
  ------------------
  |  Branch (2402:7): [True: 0, False: 0]
  ------------------
 2403|      0|		    while (*cur != 0) {
  ------------------
  |  Branch (2403:14): [True: 0, False: 0]
  ------------------
 2404|      0|			if ((*cur == 0xd) || (*cur == 0xa) || (*cur == 0x9)) {
  ------------------
  |  Branch (2404:8): [True: 0, False: 0]
  |  Branch (2404:25): [True: 0, False: 0]
  |  Branch (2404:42): [True: 0, False: 0]
  ------------------
 2405|      0|			    goto return1;
 2406|      0|			} else {
 2407|      0|			    cur++;
 2408|      0|			}
 2409|      0|		    }
 2410|      0|		} else if (ws == XML_SCHEMA_WHITESPACE_COLLAPSE) {
  ------------------
  |  Branch (2410:14): [True: 0, False: 0]
  ------------------
 2411|      0|		    while (*cur != 0) {
  ------------------
  |  Branch (2411:14): [True: 0, False: 0]
  ------------------
 2412|      0|			if ((*cur == 0xd) || (*cur == 0xa) || (*cur == 0x9)) {
  ------------------
  |  Branch (2412:8): [True: 0, False: 0]
  |  Branch (2412:25): [True: 0, False: 0]
  |  Branch (2412:42): [True: 0, False: 0]
  ------------------
 2413|      0|			    goto return1;
 2414|      0|			} else if IS_WSP_SPACE_CH(*cur) {
  ------------------
  |  |   55|      0|#define IS_WSP_SPACE_CH(c)	((c) == 0x20)
  |  |  ------------------
  |  |  |  Branch (55:29): [True: 0, False: 0]
  |  |  ------------------
  ------------------
 2415|      0|			    cur++;
 2416|      0|			    if IS_WSP_SPACE_CH(*cur)
  ------------------
  |  |   55|      0|#define IS_WSP_SPACE_CH(c)	((c) == 0x20)
  |  |  ------------------
  |  |  |  Branch (55:29): [True: 0, False: 0]
  |  |  ------------------
  ------------------
 2417|      0|				goto return1;
 2418|      0|			} else {
 2419|      0|			    cur++;
 2420|      0|			}
 2421|      0|		    }
 2422|      0|		}
 2423|      0|	    }
 2424|     36|	    if (createStringValue && (val != NULL)) {
  ------------------
  |  Branch (2424:10): [True: 36, False: 0]
  |  Branch (2424:31): [True: 36, False: 0]
  ------------------
 2425|     36|		if (applyNorm) {
  ------------------
  |  Branch (2425:7): [True: 0, False: 36]
  ------------------
 2426|      0|		    if (ws == XML_SCHEMA_WHITESPACE_COLLAPSE)
  ------------------
  |  Branch (2426:11): [True: 0, False: 0]
  ------------------
 2427|      0|			norm = xmlSchemaCollapseString(value);
 2428|      0|		    else if (ws == XML_SCHEMA_WHITESPACE_REPLACE)
  ------------------
  |  Branch (2428:16): [True: 0, False: 0]
  ------------------
 2429|      0|			norm = xmlSchemaWhiteSpaceReplace(value);
 2430|      0|		    if (norm != NULL)
  ------------------
  |  Branch (2430:11): [True: 0, False: 0]
  ------------------
 2431|      0|			value = norm;
 2432|      0|		}
 2433|     36|		v = xmlSchemaNewValue(XML_SCHEMAS_STRING);
 2434|     36|		if (v != NULL) {
  ------------------
  |  Branch (2434:7): [True: 36, False: 0]
  ------------------
 2435|     36|		    v->value.str = xmlStrdup(value);
 2436|     36|		    *val = v;
 2437|     36|		} else {
 2438|      0|		    goto error;
 2439|      0|		}
 2440|     36|	    }
 2441|     36|            goto return0;
 2442|     36|        case XML_SCHEMAS_NORMSTRING:{
  ------------------
  |  Branch (2442:9): [True: 0, False: 1.55k]
  ------------------
 2443|      0|		if (normOnTheFly) {
  ------------------
  |  Branch (2443:7): [True: 0, False: 0]
  ------------------
 2444|      0|		    if (applyNorm) {
  ------------------
  |  Branch (2444:11): [True: 0, False: 0]
  ------------------
 2445|      0|			if (ws == XML_SCHEMA_WHITESPACE_COLLAPSE)
  ------------------
  |  Branch (2445:8): [True: 0, False: 0]
  ------------------
 2446|      0|			    norm = xmlSchemaCollapseString(value);
 2447|      0|			else
 2448|      0|			    norm = xmlSchemaWhiteSpaceReplace(value);
 2449|      0|			if (norm != NULL)
  ------------------
  |  Branch (2449:8): [True: 0, False: 0]
  ------------------
 2450|      0|			    value = norm;
 2451|      0|		    }
 2452|      0|		} else {
 2453|      0|		    const xmlChar *cur = value;
 2454|      0|		    while (*cur != 0) {
  ------------------
  |  Branch (2454:14): [True: 0, False: 0]
  ------------------
 2455|      0|			if ((*cur == 0xd) || (*cur == 0xa) || (*cur == 0x9)) {
  ------------------
  |  Branch (2455:8): [True: 0, False: 0]
  |  Branch (2455:25): [True: 0, False: 0]
  |  Branch (2455:42): [True: 0, False: 0]
  ------------------
 2456|      0|			    goto return1;
 2457|      0|			} else {
 2458|      0|			    cur++;
 2459|      0|			}
 2460|      0|		    }
 2461|      0|		}
 2462|      0|                if (val != NULL) {
  ------------------
  |  Branch (2462:21): [True: 0, False: 0]
  ------------------
 2463|      0|                    v = xmlSchemaNewValue(XML_SCHEMAS_NORMSTRING);
 2464|      0|                    if (v != NULL) {
  ------------------
  |  Branch (2464:25): [True: 0, False: 0]
  ------------------
 2465|      0|                        v->value.str = xmlStrdup(value);
 2466|      0|                        *val = v;
 2467|      0|                    } else {
 2468|      0|                        goto error;
 2469|      0|                    }
 2470|      0|                }
 2471|      0|                goto return0;
 2472|      0|            }
 2473|      5|        case XML_SCHEMAS_DECIMAL:{
  ------------------
  |  Branch (2473:9): [True: 5, False: 1.55k]
  ------------------
 2474|      5|                const xmlChar *cur = value;
 2475|      5|                unsigned int len, neg, integ, hasLeadingZeroes;
 2476|      5|		xmlChar cval[25];
 2477|      5|		xmlChar *cptr = cval;
 2478|       |
 2479|      5|                if ((cur == NULL) || (*cur == 0))
  ------------------
  |  Branch (2479:21): [True: 0, False: 5]
  |  Branch (2479:38): [True: 0, False: 5]
  ------------------
 2480|      0|                    goto return1;
 2481|       |
 2482|       |		/*
 2483|       |		* xs:decimal has a whitespace-facet value of 'collapse'.
 2484|       |		*/
 2485|      5|		if (normOnTheFly)
  ------------------
  |  Branch (2485:7): [True: 5, False: 0]
  ------------------
 2486|      5|		    while IS_WSP_BLANK_CH(*cur) cur++;
 2487|       |
 2488|       |		/*
 2489|       |		* First we handle an optional sign.
 2490|       |		*/
 2491|      5|		neg = 0;
 2492|      5|                if (*cur == '-') {
  ------------------
  |  Branch (2492:21): [True: 0, False: 5]
  ------------------
 2493|      0|		    neg = 1;
 2494|      0|                    cur++;
 2495|      5|		} else if (*cur == '+')
  ------------------
  |  Branch (2495:14): [True: 0, False: 5]
  ------------------
 2496|      0|                    cur++;
 2497|       |		/*
 2498|       |		* Disallow: "", "-", "- "
 2499|       |		*/
 2500|      5|		if (*cur == 0)
  ------------------
  |  Branch (2500:7): [True: 0, False: 5]
  ------------------
 2501|      0|		    goto return1;
 2502|       |		/*
 2503|       |		 * Next we "pre-parse" the number, in preparation for calling
 2504|       |		 * the common routine xmlSchemaParseUInt.  We get rid of any
 2505|       |		 * leading zeroes (because we have reserved only 25 chars),
 2506|       |		 * and note the position of a decimal point.
 2507|       |		 */
 2508|      5|		len = 0;
 2509|      5|		integ = ~0u;
 2510|      5|		hasLeadingZeroes = 0;
 2511|       |		/*
 2512|       |		* Skip leading zeroes.
 2513|       |		*/
 2514|      9|		while (*cur == '0') {
  ------------------
  |  Branch (2514:10): [True: 4, False: 5]
  ------------------
 2515|      4|		    cur++;
 2516|      4|		    hasLeadingZeroes = 1;
 2517|      4|		}
 2518|      5|		if (*cur != 0) {
  ------------------
  |  Branch (2518:7): [True: 1, False: 4]
  ------------------
 2519|      3|		    do {
 2520|      3|			if ((*cur >= '0') && (*cur <= '9')) {
  ------------------
  |  Branch (2520:8): [True: 2, False: 1]
  |  Branch (2520:25): [True: 2, False: 0]
  ------------------
 2521|      2|			    *cptr++ = *cur++;
 2522|      2|			    len++;
 2523|      2|			} else if (*cur == '.') {
  ------------------
  |  Branch (2523:15): [True: 0, False: 1]
  ------------------
 2524|      0|			    cur++;
 2525|      0|			    integ = len;
 2526|      0|			    do {
 2527|      0|				if ((*cur >= '0') && (*cur <= '9')) {
  ------------------
  |  Branch (2527:9): [True: 0, False: 0]
  |  Branch (2527:26): [True: 0, False: 0]
  ------------------
 2528|      0|				    *cptr++ = *cur++;
 2529|      0|				    len++;
 2530|      0|				} else
 2531|      0|				    break;
 2532|      0|			    } while (len < 24);
  ------------------
  |  Branch (2532:17): [True: 0, False: 0]
  ------------------
 2533|       |			    /*
 2534|       |			    * Disallow "." but allow "00."
 2535|       |			    */
 2536|      0|			    if ((len == 0) && (!hasLeadingZeroes))
  ------------------
  |  Branch (2536:12): [True: 0, False: 0]
  |  Branch (2536:26): [True: 0, False: 0]
  ------------------
 2537|      0|				goto return1;
 2538|      0|			    break;
 2539|      0|			} else
 2540|      1|			    break;
 2541|      3|		    } while (len < 24);
  ------------------
  |  Branch (2541:16): [True: 2, False: 0]
  ------------------
 2542|      1|		}
 2543|      5|		if (normOnTheFly)
  ------------------
  |  Branch (2543:7): [True: 5, False: 0]
  ------------------
 2544|      5|		    while IS_WSP_BLANK_CH(*cur) cur++;
 2545|      5|		if (*cur != 0)
  ------------------
  |  Branch (2545:7): [True: 0, False: 5]
  ------------------
 2546|      0|		    goto return1; /* error if any extraneous chars */
 2547|      5|                if (val != NULL) {
  ------------------
  |  Branch (2547:21): [True: 5, False: 0]
  ------------------
 2548|      5|                    v = xmlSchemaNewValue(XML_SCHEMAS_DECIMAL);
 2549|      5|                    if (v != NULL) {
  ------------------
  |  Branch (2549:25): [True: 5, False: 0]
  ------------------
 2550|       |			/*
 2551|       |			* Now evaluate the significant digits of the number
 2552|       |			*/
 2553|      5|			if (len != 0) {
  ------------------
  |  Branch (2553:8): [True: 1, False: 4]
  ------------------
 2554|       |
 2555|      1|			    if (integ != ~0u) {
  ------------------
  |  Branch (2555:12): [True: 0, False: 1]
  ------------------
 2556|       |				/*
 2557|       |				* Get rid of trailing zeroes in the
 2558|       |				* fractional part.
 2559|       |				*/
 2560|      0|				while ((len != integ) && (*(cptr-1) == '0')) {
  ------------------
  |  Branch (2560:12): [True: 0, False: 0]
  |  Branch (2560:30): [True: 0, False: 0]
  ------------------
 2561|      0|				    cptr--;
 2562|      0|				    len--;
 2563|      0|				}
 2564|      0|			    }
 2565|       |			    /*
 2566|       |			    * Terminate the (preparsed) string.
 2567|       |			    */
 2568|      1|			    if (len != 0) {
  ------------------
  |  Branch (2568:12): [True: 1, False: 0]
  ------------------
 2569|      1|				*cptr = 0;
 2570|      1|				cptr = cval;
 2571|       |
 2572|      1|				xmlSchemaParseUInt((const xmlChar **)&cptr,
 2573|      1|				    &v->value.decimal.lo,
 2574|      1|				    &v->value.decimal.mi,
 2575|      1|				    &v->value.decimal.hi);
 2576|      1|			    }
 2577|      1|			}
 2578|       |			/*
 2579|       |			* Set the total digits to 1 if a zero value.
 2580|       |			*/
 2581|      5|                        v->value.decimal.sign = neg;
 2582|      5|			if (len == 0) {
  ------------------
  |  Branch (2582:8): [True: 4, False: 1]
  ------------------
 2583|       |			    /* Speedup for zero values. */
 2584|      4|			    v->value.decimal.total = 1;
 2585|      4|			} else {
 2586|      1|			    v->value.decimal.total = len;
 2587|      1|			    if (integ == ~0u)
  ------------------
  |  Branch (2587:12): [True: 1, False: 0]
  ------------------
 2588|      1|				v->value.decimal.frac = 0;
 2589|      0|			    else
 2590|      0|				v->value.decimal.frac = len - integ;
 2591|      1|			}
 2592|      5|                        *val = v;
 2593|      5|                    }
 2594|      5|                }
 2595|      5|                goto return0;
 2596|      5|            }
 2597|      4|        case XML_SCHEMAS_TIME:
  ------------------
  |  Branch (2597:9): [True: 4, False: 1.55k]
  ------------------
 2598|      6|        case XML_SCHEMAS_GDAY:
  ------------------
  |  Branch (2598:9): [True: 2, False: 1.55k]
  ------------------
 2599|      8|        case XML_SCHEMAS_GMONTH:
  ------------------
  |  Branch (2599:9): [True: 2, False: 1.55k]
  ------------------
 2600|     11|        case XML_SCHEMAS_GMONTHDAY:
  ------------------
  |  Branch (2600:9): [True: 3, False: 1.55k]
  ------------------
 2601|     13|        case XML_SCHEMAS_GYEAR:
  ------------------
  |  Branch (2601:9): [True: 2, False: 1.55k]
  ------------------
 2602|     15|        case XML_SCHEMAS_GYEARMONTH:
  ------------------
  |  Branch (2602:9): [True: 2, False: 1.55k]
  ------------------
 2603|     19|        case XML_SCHEMAS_DATE:
  ------------------
  |  Branch (2603:9): [True: 4, False: 1.55k]
  ------------------
 2604|     23|        case XML_SCHEMAS_DATETIME:
  ------------------
  |  Branch (2604:9): [True: 4, False: 1.55k]
  ------------------
 2605|     23|            ret = xmlSchemaValidateDates(type->builtInType, value, val,
 2606|     23|		normOnTheFly);
 2607|     23|            break;
 2608|     14|        case XML_SCHEMAS_DURATION:
  ------------------
  |  Branch (2608:9): [True: 14, False: 1.54k]
  ------------------
 2609|     14|            ret = xmlSchemaValidateDuration(type, value, val,
 2610|     14|		normOnTheFly);
 2611|     14|            break;
 2612|      0|        case XML_SCHEMAS_FLOAT:
  ------------------
  |  Branch (2612:9): [True: 0, False: 1.55k]
  ------------------
 2613|      2|        case XML_SCHEMAS_DOUBLE: {
  ------------------
  |  Branch (2613:9): [True: 2, False: 1.55k]
  ------------------
 2614|      2|                const xmlChar *cur = value;
 2615|      2|                int neg = 0;
 2616|      2|                int digits_before = 0;
 2617|      2|                int digits_after = 0;
 2618|       |
 2619|      2|		if (normOnTheFly)
  ------------------
  |  Branch (2619:7): [True: 2, False: 0]
  ------------------
 2620|      2|		    while IS_WSP_BLANK_CH(*cur) cur++;
 2621|       |
 2622|      2|                if ((cur[0] == 'N') && (cur[1] == 'a') && (cur[2] == 'N')) {
  ------------------
  |  Branch (2622:21): [True: 0, False: 2]
  |  Branch (2622:40): [True: 0, False: 0]
  |  Branch (2622:59): [True: 0, False: 0]
  ------------------
 2623|      0|                    cur += 3;
 2624|      0|                    if (*cur != 0)
  ------------------
  |  Branch (2624:25): [True: 0, False: 0]
  ------------------
 2625|      0|                        goto return1;
 2626|      0|                    if (val != NULL) {
  ------------------
  |  Branch (2626:25): [True: 0, False: 0]
  ------------------
 2627|      0|                        if (type == xmlSchemaTypeFloatDef) {
  ------------------
  |  Branch (2627:29): [True: 0, False: 0]
  ------------------
 2628|      0|                            v = xmlSchemaNewValue(XML_SCHEMAS_FLOAT);
 2629|      0|                            if (v != NULL) {
  ------------------
  |  Branch (2629:33): [True: 0, False: 0]
  ------------------
 2630|      0|                                v->value.f = (float) xmlXPathNAN;
 2631|      0|                            } else {
 2632|      0|                                xmlSchemaFreeValue(v);
 2633|      0|                                goto error;
 2634|      0|                            }
 2635|      0|                        } else {
 2636|      0|                            v = xmlSchemaNewValue(XML_SCHEMAS_DOUBLE);
 2637|      0|                            if (v != NULL) {
  ------------------
  |  Branch (2637:33): [True: 0, False: 0]
  ------------------
 2638|      0|                                v->value.d = xmlXPathNAN;
 2639|      0|                            } else {
 2640|      0|                                xmlSchemaFreeValue(v);
 2641|      0|                                goto error;
 2642|      0|                            }
 2643|      0|                        }
 2644|      0|                        *val = v;
 2645|      0|                    }
 2646|      0|                    goto return0;
 2647|      0|                }
 2648|      2|                if (*cur == '-') {
  ------------------
  |  Branch (2648:21): [True: 0, False: 2]
  ------------------
 2649|      0|                    neg = 1;
 2650|      0|                    cur++;
 2651|      0|                }
 2652|      2|                if ((cur[0] == 'I') && (cur[1] == 'N') && (cur[2] == 'F')) {
  ------------------
  |  Branch (2652:21): [True: 0, False: 2]
  |  Branch (2652:40): [True: 0, False: 0]
  |  Branch (2652:59): [True: 0, False: 0]
  ------------------
 2653|      0|                    cur += 3;
 2654|      0|                    if (*cur != 0)
  ------------------
  |  Branch (2654:25): [True: 0, False: 0]
  ------------------
 2655|      0|                        goto return1;
 2656|      0|                    if (val != NULL) {
  ------------------
  |  Branch (2656:25): [True: 0, False: 0]
  ------------------
 2657|      0|                        if (type == xmlSchemaTypeFloatDef) {
  ------------------
  |  Branch (2657:29): [True: 0, False: 0]
  ------------------
 2658|      0|                            v = xmlSchemaNewValue(XML_SCHEMAS_FLOAT);
 2659|      0|                            if (v != NULL) {
  ------------------
  |  Branch (2659:33): [True: 0, False: 0]
  ------------------
 2660|      0|                                if (neg)
  ------------------
  |  Branch (2660:37): [True: 0, False: 0]
  ------------------
 2661|      0|                                    v->value.f = (float) xmlXPathNINF;
 2662|      0|                                else
 2663|      0|                                    v->value.f = (float) xmlXPathPINF;
 2664|      0|                            } else {
 2665|      0|                                xmlSchemaFreeValue(v);
 2666|      0|                                goto error;
 2667|      0|                            }
 2668|      0|                        } else {
 2669|      0|                            v = xmlSchemaNewValue(XML_SCHEMAS_DOUBLE);
 2670|      0|                            if (v != NULL) {
  ------------------
  |  Branch (2670:33): [True: 0, False: 0]
  ------------------
 2671|      0|                                if (neg)
  ------------------
  |  Branch (2671:37): [True: 0, False: 0]
  ------------------
 2672|      0|                                    v->value.d = xmlXPathNINF;
 2673|      0|                                else
 2674|      0|                                    v->value.d = xmlXPathPINF;
 2675|      0|                            } else {
 2676|      0|                                xmlSchemaFreeValue(v);
 2677|      0|                                goto error;
 2678|      0|                            }
 2679|      0|                        }
 2680|      0|                        *val = v;
 2681|      0|                    }
 2682|      0|                    goto return0;
 2683|      0|                }
 2684|      2|                if ((neg == 0) && (*cur == '+'))
  ------------------
  |  Branch (2684:21): [True: 2, False: 0]
  |  Branch (2684:35): [True: 0, False: 2]
  ------------------
 2685|      0|                    cur++;
 2686|      2|                if ((cur[0] == 0) || (cur[0] == '+') || (cur[0] == '-'))
  ------------------
  |  Branch (2686:21): [True: 0, False: 2]
  |  Branch (2686:38): [True: 0, False: 2]
  |  Branch (2686:57): [True: 0, False: 2]
  ------------------
 2687|      0|                    goto return1;
 2688|      4|                while ((*cur >= '0') && (*cur <= '9')) {
  ------------------
  |  Branch (2688:24): [True: 2, False: 2]
  |  Branch (2688:41): [True: 2, False: 0]
  ------------------
 2689|      2|                    cur++;
 2690|      2|                    digits_before++;
 2691|      2|                }
 2692|      2|                if (*cur == '.') {
  ------------------
  |  Branch (2692:21): [True: 0, False: 2]
  ------------------
 2693|      0|                    cur++;
 2694|      0|                    while ((*cur >= '0') && (*cur <= '9')) {
  ------------------
  |  Branch (2694:28): [True: 0, False: 0]
  |  Branch (2694:45): [True: 0, False: 0]
  ------------------
 2695|      0|                        cur++;
 2696|      0|                        digits_after++;
 2697|      0|                    }
 2698|      0|                }
 2699|      2|                if ((digits_before == 0) && (digits_after == 0))
  ------------------
  |  Branch (2699:21): [True: 0, False: 2]
  |  Branch (2699:45): [True: 0, False: 0]
  ------------------
 2700|      0|                    goto return1;
 2701|      2|                if ((*cur == 'e') || (*cur == 'E')) {
  ------------------
  |  Branch (2701:21): [True: 0, False: 2]
  |  Branch (2701:38): [True: 0, False: 2]
  ------------------
 2702|      0|                    cur++;
 2703|      0|                    if ((*cur == '-') || (*cur == '+'))
  ------------------
  |  Branch (2703:25): [True: 0, False: 0]
  |  Branch (2703:42): [True: 0, False: 0]
  ------------------
 2704|      0|                        cur++;
 2705|      0|                    while ((*cur >= '0') && (*cur <= '9'))
  ------------------
  |  Branch (2705:28): [True: 0, False: 0]
  |  Branch (2705:45): [True: 0, False: 0]
  ------------------
 2706|      0|                        cur++;
 2707|      0|                }
 2708|      2|		if (normOnTheFly)
  ------------------
  |  Branch (2708:7): [True: 2, False: 0]
  ------------------
 2709|      2|		    while IS_WSP_BLANK_CH(*cur) cur++;
 2710|       |
 2711|      2|                if (*cur != 0)
  ------------------
  |  Branch (2711:21): [True: 0, False: 2]
  ------------------
 2712|      0|                    goto return1;
 2713|      2|                if (val != NULL) {
  ------------------
  |  Branch (2713:21): [True: 2, False: 0]
  ------------------
 2714|      2|                    if (type == xmlSchemaTypeFloatDef) {
  ------------------
  |  Branch (2714:25): [True: 0, False: 2]
  ------------------
 2715|      0|                        v = xmlSchemaNewValue(XML_SCHEMAS_FLOAT);
 2716|      0|                        if (v != NULL) {
  ------------------
  |  Branch (2716:29): [True: 0, False: 0]
  ------------------
 2717|       |			    /*
 2718|       |			    * TODO: sscanf seems not to give the correct
 2719|       |			    * value for extremely high/low values.
 2720|       |			    * E.g. "1E-149" results in zero.
 2721|       |			    */
 2722|      0|                            if (sscanf((const char *) value, "%f",
  ------------------
  |  Branch (2722:33): [True: 0, False: 0]
  ------------------
 2723|      0|                                 &(v->value.f)) == 1) {
 2724|      0|                                *val = v;
 2725|      0|                            } else {
 2726|      0|                                xmlSchemaFreeValue(v);
 2727|      0|                                goto return1;
 2728|      0|                            }
 2729|      0|                        } else {
 2730|      0|                            goto error;
 2731|      0|                        }
 2732|      2|                    } else {
 2733|      2|                        v = xmlSchemaNewValue(XML_SCHEMAS_DOUBLE);
 2734|      2|                        if (v != NULL) {
  ------------------
  |  Branch (2734:29): [True: 2, False: 0]
  ------------------
 2735|       |			    /*
 2736|       |			    * TODO: sscanf seems not to give the correct
 2737|       |			    * value for extremely high/low values.
 2738|       |			    */
 2739|      2|                            if (sscanf((const char *) value, "%lf",
  ------------------
  |  Branch (2739:33): [True: 2, False: 0]
  ------------------
 2740|      2|                                 &(v->value.d)) == 1) {
 2741|      2|                                *val = v;
 2742|      2|                            } else {
 2743|      0|                                xmlSchemaFreeValue(v);
 2744|      0|                                goto return1;
 2745|      0|                            }
 2746|      2|                        } else {
 2747|      0|                            goto error;
 2748|      0|                        }
 2749|      2|                    }
 2750|      2|                }
 2751|      2|                goto return0;
 2752|      2|            }
 2753|      2|        case XML_SCHEMAS_BOOLEAN:{
  ------------------
  |  Branch (2753:9): [True: 0, False: 1.55k]
  ------------------
 2754|      0|                const xmlChar *cur = value;
 2755|       |
 2756|      0|		if (normOnTheFly) {
  ------------------
  |  Branch (2756:7): [True: 0, False: 0]
  ------------------
 2757|      0|		    while IS_WSP_BLANK_CH(*cur) cur++;
 2758|      0|		    if (*cur == '0') {
  ------------------
  |  Branch (2758:11): [True: 0, False: 0]
  ------------------
 2759|      0|			ret = 0;
 2760|      0|			cur++;
 2761|      0|		    } else if (*cur == '1') {
  ------------------
  |  Branch (2761:18): [True: 0, False: 0]
  ------------------
 2762|      0|			ret = 1;
 2763|      0|			cur++;
 2764|      0|		    } else if (*cur == 't') {
  ------------------
  |  Branch (2764:18): [True: 0, False: 0]
  ------------------
 2765|      0|			cur++;
 2766|      0|			if ((*cur++ == 'r') && (*cur++ == 'u') &&
  ------------------
  |  Branch (2766:8): [True: 0, False: 0]
  |  Branch (2766:27): [True: 0, False: 0]
  ------------------
 2767|      0|			    (*cur++ == 'e')) {
  ------------------
  |  Branch (2767:8): [True: 0, False: 0]
  ------------------
 2768|      0|			    ret = 1;
 2769|      0|			} else
 2770|      0|			    goto return1;
 2771|      0|		    } else if (*cur == 'f') {
  ------------------
  |  Branch (2771:18): [True: 0, False: 0]
  ------------------
 2772|      0|			cur++;
 2773|      0|			if ((*cur++ == 'a') && (*cur++ == 'l') &&
  ------------------
  |  Branch (2773:8): [True: 0, False: 0]
  |  Branch (2773:27): [True: 0, False: 0]
  ------------------
 2774|      0|			    (*cur++ == 's') && (*cur++ == 'e')) {
  ------------------
  |  Branch (2774:8): [True: 0, False: 0]
  |  Branch (2774:27): [True: 0, False: 0]
  ------------------
 2775|      0|			    ret = 0;
 2776|      0|			} else
 2777|      0|			    goto return1;
 2778|      0|		    } else
 2779|      0|			goto return1;
 2780|      0|		    if (*cur != 0) {
  ------------------
  |  Branch (2780:11): [True: 0, False: 0]
  ------------------
 2781|      0|			while IS_WSP_BLANK_CH(*cur) cur++;
 2782|      0|			if (*cur != 0)
  ------------------
  |  Branch (2782:8): [True: 0, False: 0]
  ------------------
 2783|      0|			    goto return1;
 2784|      0|		    }
 2785|      0|		} else {
 2786|      0|		    if ((cur[0] == '0') && (cur[1] == 0))
  ------------------
  |  Branch (2786:11): [True: 0, False: 0]
  |  Branch (2786:30): [True: 0, False: 0]
  ------------------
 2787|      0|			ret = 0;
 2788|      0|		    else if ((cur[0] == '1') && (cur[1] == 0))
  ------------------
  |  Branch (2788:16): [True: 0, False: 0]
  |  Branch (2788:35): [True: 0, False: 0]
  ------------------
 2789|      0|			ret = 1;
 2790|      0|		    else if ((cur[0] == 't') && (cur[1] == 'r')
  ------------------
  |  Branch (2790:16): [True: 0, False: 0]
  |  Branch (2790:35): [True: 0, False: 0]
  ------------------
 2791|      0|			&& (cur[2] == 'u') && (cur[3] == 'e')
  ------------------
  |  Branch (2791:7): [True: 0, False: 0]
  |  Branch (2791:26): [True: 0, False: 0]
  ------------------
 2792|      0|			&& (cur[4] == 0))
  ------------------
  |  Branch (2792:7): [True: 0, False: 0]
  ------------------
 2793|      0|			ret = 1;
 2794|      0|		    else if ((cur[0] == 'f') && (cur[1] == 'a')
  ------------------
  |  Branch (2794:16): [True: 0, False: 0]
  |  Branch (2794:35): [True: 0, False: 0]
  ------------------
 2795|      0|			&& (cur[2] == 'l') && (cur[3] == 's')
  ------------------
  |  Branch (2795:7): [True: 0, False: 0]
  |  Branch (2795:26): [True: 0, False: 0]
  ------------------
 2796|      0|			&& (cur[4] == 'e') && (cur[5] == 0))
  ------------------
  |  Branch (2796:7): [True: 0, False: 0]
  |  Branch (2796:26): [True: 0, False: 0]
  ------------------
 2797|      0|			ret = 0;
 2798|      0|		    else
 2799|      0|			goto return1;
 2800|      0|		}
 2801|      0|                if (val != NULL) {
  ------------------
  |  Branch (2801:21): [True: 0, False: 0]
  ------------------
 2802|      0|                    v = xmlSchemaNewValue(XML_SCHEMAS_BOOLEAN);
 2803|      0|                    if (v != NULL) {
  ------------------
  |  Branch (2803:25): [True: 0, False: 0]
  ------------------
 2804|      0|                        v->value.b = ret;
 2805|      0|                        *val = v;
 2806|      0|                    } else {
 2807|      0|                        goto error;
 2808|      0|                    }
 2809|      0|                }
 2810|      0|                goto return0;
 2811|      0|            }
 2812|     43|        case XML_SCHEMAS_TOKEN:{
  ------------------
  |  Branch (2812:9): [True: 43, False: 1.51k]
  ------------------
 2813|     43|                const xmlChar *cur = value;
 2814|       |
 2815|     43|		if (! normOnTheFly) {
  ------------------
  |  Branch (2815:7): [True: 0, False: 43]
  ------------------
 2816|      0|		    while (*cur != 0) {
  ------------------
  |  Branch (2816:14): [True: 0, False: 0]
  ------------------
 2817|      0|			if ((*cur == 0xd) || (*cur == 0xa) || (*cur == 0x9)) {
  ------------------
  |  Branch (2817:8): [True: 0, False: 0]
  |  Branch (2817:25): [True: 0, False: 0]
  |  Branch (2817:42): [True: 0, False: 0]
  ------------------
 2818|      0|			    goto return1;
 2819|      0|			} else if (*cur == ' ') {
  ------------------
  |  Branch (2819:15): [True: 0, False: 0]
  ------------------
 2820|      0|			    cur++;
 2821|      0|			    if (*cur == 0)
  ------------------
  |  Branch (2821:12): [True: 0, False: 0]
  ------------------
 2822|      0|				goto return1;
 2823|      0|			    if (*cur == ' ')
  ------------------
  |  Branch (2823:12): [True: 0, False: 0]
  ------------------
 2824|      0|				goto return1;
 2825|      0|			} else {
 2826|      0|			    cur++;
 2827|      0|			}
 2828|      0|		    }
 2829|      0|		}
 2830|     43|                if (val != NULL) {
  ------------------
  |  Branch (2830:21): [True: 43, False: 0]
  ------------------
 2831|     43|                    v = xmlSchemaNewValue(XML_SCHEMAS_TOKEN);
 2832|     43|                    if (v != NULL) {
  ------------------
  |  Branch (2832:25): [True: 43, False: 0]
  ------------------
 2833|     43|                        v->value.str = xmlStrdup(value);
 2834|     43|                        *val = v;
 2835|     43|                    } else {
 2836|      0|                        goto error;
 2837|      0|                    }
 2838|     43|                }
 2839|     43|                goto return0;
 2840|     43|            }
 2841|     43|        case XML_SCHEMAS_LANGUAGE:
  ------------------
  |  Branch (2841:9): [True: 19, False: 1.53k]
  ------------------
 2842|     19|	    if ((norm == NULL) && (normOnTheFly)) {
  ------------------
  |  Branch (2842:10): [True: 19, False: 0]
  |  Branch (2842:28): [True: 19, False: 0]
  ------------------
 2843|     19|		norm = xmlSchemaCollapseString(value);
 2844|     19|		if (norm != NULL)
  ------------------
  |  Branch (2844:7): [True: 0, False: 19]
  ------------------
 2845|      0|		    value = norm;
 2846|     19|	    }
 2847|       |
 2848|     19|            if (xmlSchemaCheckLanguageType(value) == 1) {
  ------------------
  |  Branch (2848:17): [True: 18, False: 1]
  ------------------
 2849|     18|                if (val != NULL) {
  ------------------
  |  Branch (2849:21): [True: 9, False: 9]
  ------------------
 2850|      9|                    v = xmlSchemaNewValue(XML_SCHEMAS_LANGUAGE);
 2851|      9|                    if (v != NULL) {
  ------------------
  |  Branch (2851:25): [True: 9, False: 0]
  ------------------
 2852|      9|                        v->value.str = xmlStrdup(value);
 2853|      9|                        *val = v;
 2854|      9|                    } else {
 2855|      0|                        goto error;
 2856|      0|                    }
 2857|      9|                }
 2858|     18|                goto return0;
 2859|     18|            }
 2860|      1|            goto return1;
 2861|     20|        case XML_SCHEMAS_NMTOKEN:
  ------------------
  |  Branch (2861:9): [True: 20, False: 1.53k]
  ------------------
 2862|     20|            if (xmlValidateNMToken(value, 1) == 0) {
  ------------------
  |  Branch (2862:17): [True: 20, False: 0]
  ------------------
 2863|     20|                if (val != NULL) {
  ------------------
  |  Branch (2863:21): [True: 20, False: 0]
  ------------------
 2864|     20|                    v = xmlSchemaNewValue(XML_SCHEMAS_NMTOKEN);
 2865|     20|                    if (v != NULL) {
  ------------------
  |  Branch (2865:25): [True: 20, False: 0]
  ------------------
 2866|     20|                        v->value.str = xmlStrdup(value);
 2867|     20|                        *val = v;
 2868|     20|                    } else {
 2869|      0|                        goto error;
 2870|      0|                    }
 2871|     20|                }
 2872|     20|                goto return0;
 2873|     20|            }
 2874|      0|            goto return1;
 2875|      0|        case XML_SCHEMAS_NMTOKENS:
  ------------------
  |  Branch (2875:9): [True: 0, False: 1.55k]
  ------------------
 2876|      0|            ret = xmlSchemaValAtomicListNode(xmlSchemaTypeNmtokenDef,
 2877|      0|                                             value, val, node);
 2878|      0|            if (ret > 0)
  ------------------
  |  Branch (2878:17): [True: 0, False: 0]
  ------------------
 2879|      0|                ret = 0;
 2880|      0|            else
 2881|      0|                ret = 1;
 2882|      0|            goto done;
 2883|      0|        case XML_SCHEMAS_NAME:
  ------------------
  |  Branch (2883:9): [True: 0, False: 1.55k]
  ------------------
 2884|      0|            ret = xmlValidateName(value, 1);
 2885|      0|            if ((ret == 0) && (val != NULL) && (value != NULL)) {
  ------------------
  |  Branch (2885:17): [True: 0, False: 0]
  |  Branch (2885:31): [True: 0, False: 0]
  |  Branch (2885:48): [True: 0, False: 0]
  ------------------
 2886|      0|		v = xmlSchemaNewValue(XML_SCHEMAS_NAME);
 2887|      0|		if (v != NULL) {
  ------------------
  |  Branch (2887:7): [True: 0, False: 0]
  ------------------
 2888|      0|		     const xmlChar *start = value, *end;
 2889|      0|		     while (IS_BLANK_CH(*start)) start++;
 2890|      0|		     end = start;
 2891|      0|		     while ((*end != 0) && (!IS_BLANK_CH(*end))) end++;
  ------------------
  |  |  151|      0|#define IS_BLANK_CH(c)  xmlIsBlank_ch(c)
  |  |  ------------------
  |  |  |  |   88|      0|#define xmlIsBlank_ch(c)	(((c) == 0x20) || \
  |  |  |  |  ------------------
  |  |  |  |  |  Branch (88:27): [True: 0, False: 0]
  |  |  |  |  ------------------
  |  |  |  |   89|      0|				 ((0x9 <= (c)) && ((c) <= 0xa)) || \
  |  |  |  |  ------------------
  |  |  |  |  |  Branch (89:7): [True: 0, False: 0]
  |  |  |  |  |  Branch (89:23): [True: 0, False: 0]
  |  |  |  |  ------------------
  |  |  |  |   90|      0|				 ((c) == 0xd))
  |  |  |  |  ------------------
  |  |  |  |  |  Branch (90:6): [True: 0, False: 0]
  |  |  |  |  ------------------
  |  |  ------------------
  ------------------
  |  Branch (2891:15): [True: 0, False: 0]
  ------------------
 2892|      0|		     v->value.str = xmlStrndup(start, end - start);
 2893|      0|		    *val = v;
 2894|      0|		} else {
 2895|      0|		    goto error;
 2896|      0|		}
 2897|      0|            }
 2898|      0|            goto done;
 2899|      0|        case XML_SCHEMAS_QNAME:{
  ------------------
  |  Branch (2899:9): [True: 0, False: 1.55k]
  ------------------
 2900|      0|                const xmlChar *uri = NULL;
 2901|      0|                xmlChar *local = NULL;
 2902|       |
 2903|      0|                ret = xmlValidateQName(value, 1);
 2904|      0|		if (ret != 0)
  ------------------
  |  Branch (2904:7): [True: 0, False: 0]
  ------------------
 2905|      0|		    goto done;
 2906|      0|                if (node != NULL) {
  ------------------
  |  Branch (2906:21): [True: 0, False: 0]
  ------------------
 2907|      0|                    xmlChar *prefix;
 2908|      0|		    xmlNsPtr ns;
 2909|       |
 2910|      0|                    local = xmlSplitQName2(value, &prefix);
 2911|      0|		    ns = xmlSearchNs(node->doc, node, prefix);
 2912|      0|		    if ((ns == NULL) && (prefix != NULL)) {
  ------------------
  |  Branch (2912:11): [True: 0, False: 0]
  |  Branch (2912:27): [True: 0, False: 0]
  ------------------
 2913|      0|			xmlFree(prefix);
 2914|      0|			if (local != NULL)
  ------------------
  |  Branch (2914:8): [True: 0, False: 0]
  ------------------
 2915|      0|			    xmlFree(local);
 2916|      0|			goto return1;
 2917|      0|		    }
 2918|      0|		    if (ns != NULL)
  ------------------
  |  Branch (2918:11): [True: 0, False: 0]
  ------------------
 2919|      0|			uri = ns->href;
 2920|      0|                    if (prefix != NULL)
  ------------------
  |  Branch (2920:25): [True: 0, False: 0]
  ------------------
 2921|      0|                        xmlFree(prefix);
 2922|      0|                }
 2923|      0|                if (val != NULL) {
  ------------------
  |  Branch (2923:21): [True: 0, False: 0]
  ------------------
 2924|      0|                    v = xmlSchemaNewValue(XML_SCHEMAS_QNAME);
 2925|      0|                    if (v == NULL) {
  ------------------
  |  Branch (2925:25): [True: 0, False: 0]
  ------------------
 2926|      0|			if (local != NULL)
  ------------------
  |  Branch (2926:8): [True: 0, False: 0]
  ------------------
 2927|      0|			    xmlFree(local);
 2928|      0|			goto error;
 2929|      0|		    }
 2930|      0|		    if (local != NULL)
  ------------------
  |  Branch (2930:11): [True: 0, False: 0]
  ------------------
 2931|      0|			v->value.qname.name = local;
 2932|      0|		    else
 2933|      0|			v->value.qname.name = xmlStrdup(value);
 2934|      0|		    if (uri != NULL)
  ------------------
  |  Branch (2934:11): [True: 0, False: 0]
  ------------------
 2935|      0|			v->value.qname.uri = xmlStrdup(uri);
 2936|      0|		    *val = v;
 2937|      0|                } else
 2938|      0|		    if (local != NULL)
  ------------------
  |  Branch (2938:11): [True: 0, False: 0]
  ------------------
 2939|      0|			xmlFree(local);
 2940|      0|                goto done;
 2941|      0|            }
 2942|  1.12k|        case XML_SCHEMAS_NCNAME:
  ------------------
  |  Branch (2942:9): [True: 1.12k, False: 434]
  ------------------
 2943|  1.12k|            ret = xmlValidateNCName(value, 1);
 2944|  1.12k|            if ((ret == 0) && (val != NULL)) {
  ------------------
  |  Branch (2944:17): [True: 1.12k, False: 0]
  |  Branch (2944:31): [True: 6, False: 1.11k]
  ------------------
 2945|      6|                v = xmlSchemaNewValue(XML_SCHEMAS_NCNAME);
 2946|      6|                if (v != NULL) {
  ------------------
  |  Branch (2946:21): [True: 6, False: 0]
  ------------------
 2947|      6|                    v->value.str = xmlStrdup(value);
 2948|      6|                    *val = v;
 2949|      6|                } else {
 2950|      0|                    goto error;
 2951|      0|                }
 2952|      6|            }
 2953|  1.12k|            goto done;
 2954|  1.12k|        case XML_SCHEMAS_ID:
  ------------------
  |  Branch (2954:9): [True: 8, False: 1.54k]
  ------------------
 2955|      8|            ret = xmlValidateNCName(value, 1);
 2956|      8|            if ((ret == 0) && (val != NULL)) {
  ------------------
  |  Branch (2956:17): [True: 8, False: 0]
  |  Branch (2956:31): [True: 8, False: 0]
  ------------------
 2957|      8|                v = xmlSchemaNewValue(XML_SCHEMAS_ID);
 2958|      8|                if (v != NULL) {
  ------------------
  |  Branch (2958:21): [True: 8, False: 0]
  ------------------
 2959|      8|                    v->value.str = xmlStrdup(value);
 2960|      8|                    *val = v;
 2961|      8|                } else {
 2962|      0|                    goto error;
 2963|      0|                }
 2964|      8|            }
 2965|      8|            if ((ret == 0) && (node != NULL) &&
  ------------------
  |  Branch (2965:17): [True: 8, False: 0]
  |  Branch (2965:31): [True: 8, False: 0]
  ------------------
 2966|      8|                (node->type == XML_ATTRIBUTE_NODE)) {
  ------------------
  |  Branch (2966:17): [True: 0, False: 8]
  ------------------
 2967|      0|                xmlAttrPtr attr = (xmlAttrPtr) node;
 2968|       |
 2969|       |                /*
 2970|       |                 * NOTE: the IDness might have already be declared in the DTD
 2971|       |                 */
 2972|      0|                if (attr->atype != XML_ATTRIBUTE_ID) {
  ------------------
  |  Branch (2972:21): [True: 0, False: 0]
  ------------------
 2973|      0|                    xmlIDPtr res;
 2974|      0|                    xmlChar *strip;
 2975|       |
 2976|      0|                    strip = xmlSchemaStrip(value);
 2977|      0|                    if (strip != NULL) {
  ------------------
  |  Branch (2977:25): [True: 0, False: 0]
  ------------------
 2978|      0|                        res = xmlAddID(NULL, node->doc, strip, attr);
 2979|      0|                        xmlFree(strip);
 2980|      0|                    } else
 2981|      0|                        res = xmlAddID(NULL, node->doc, value, attr);
 2982|      0|                    if (res == NULL) {
  ------------------
  |  Branch (2982:25): [True: 0, False: 0]
  ------------------
 2983|      0|                        ret = 2;
 2984|      0|                    } else {
 2985|      0|                        attr->atype = XML_ATTRIBUTE_ID;
 2986|      0|                    }
 2987|      0|                }
 2988|      0|            }
 2989|      8|            goto done;
 2990|      0|        case XML_SCHEMAS_IDREF:
  ------------------
  |  Branch (2990:9): [True: 0, False: 1.55k]
  ------------------
 2991|      0|            ret = xmlValidateNCName(value, 1);
 2992|      0|            if ((ret == 0) && (val != NULL)) {
  ------------------
  |  Branch (2992:17): [True: 0, False: 0]
  |  Branch (2992:31): [True: 0, False: 0]
  ------------------
 2993|      0|		v = xmlSchemaNewValue(XML_SCHEMAS_IDREF);
 2994|      0|		if (v == NULL)
  ------------------
  |  Branch (2994:7): [True: 0, False: 0]
  ------------------
 2995|      0|		    goto error;
 2996|      0|		v->value.str = xmlStrdup(value);
 2997|      0|		*val = v;
 2998|      0|            }
 2999|      0|            if ((ret == 0) && (node != NULL) &&
  ------------------
  |  Branch (2999:17): [True: 0, False: 0]
  |  Branch (2999:31): [True: 0, False: 0]
  ------------------
 3000|      0|                (node->type == XML_ATTRIBUTE_NODE)) {
  ------------------
  |  Branch (3000:17): [True: 0, False: 0]
  ------------------
 3001|      0|                xmlAttrPtr attr = (xmlAttrPtr) node;
 3002|      0|                xmlChar *strip;
 3003|       |
 3004|      0|                strip = xmlSchemaStrip(value);
 3005|      0|                if (strip != NULL) {
  ------------------
  |  Branch (3005:21): [True: 0, False: 0]
  ------------------
 3006|      0|                    xmlAddRef(NULL, node->doc, strip, attr);
 3007|      0|                    xmlFree(strip);
 3008|      0|                } else
 3009|      0|                    xmlAddRef(NULL, node->doc, value, attr);
 3010|      0|                attr->atype = XML_ATTRIBUTE_IDREF;
 3011|      0|            }
 3012|      0|            goto done;
 3013|      0|        case XML_SCHEMAS_IDREFS:
  ------------------
  |  Branch (3013:9): [True: 0, False: 1.55k]
  ------------------
 3014|      0|            ret = xmlSchemaValAtomicListNode(xmlSchemaTypeIdrefDef,
 3015|      0|                                             value, val, node);
 3016|      0|            if (ret < 0)
  ------------------
  |  Branch (3016:17): [True: 0, False: 0]
  ------------------
 3017|      0|                ret = 2;
 3018|      0|            else
 3019|      0|                ret = 0;
 3020|      0|            if ((ret == 0) && (node != NULL) &&
  ------------------
  |  Branch (3020:17): [True: 0, False: 0]
  |  Branch (3020:31): [True: 0, False: 0]
  ------------------
 3021|      0|                (node->type == XML_ATTRIBUTE_NODE)) {
  ------------------
  |  Branch (3021:17): [True: 0, False: 0]
  ------------------
 3022|      0|                xmlAttrPtr attr = (xmlAttrPtr) node;
 3023|       |
 3024|      0|                attr->atype = XML_ATTRIBUTE_IDREFS;
 3025|      0|            }
 3026|      0|            goto done;
 3027|      0|        case XML_SCHEMAS_ENTITY:{
  ------------------
  |  Branch (3027:9): [True: 0, False: 1.55k]
  ------------------
 3028|      0|                xmlChar *strip;
 3029|       |
 3030|      0|                ret = xmlValidateNCName(value, 1);
 3031|      0|                if ((node == NULL) || (node->doc == NULL))
  ------------------
  |  Branch (3031:21): [True: 0, False: 0]
  |  Branch (3031:39): [True: 0, False: 0]
  ------------------
 3032|      0|                    ret = 3;
 3033|      0|                if (ret == 0) {
  ------------------
  |  Branch (3033:21): [True: 0, False: 0]
  ------------------
 3034|      0|                    xmlEntityPtr ent;
 3035|       |
 3036|      0|                    strip = xmlSchemaStrip(value);
 3037|      0|                    if (strip != NULL) {
  ------------------
  |  Branch (3037:25): [True: 0, False: 0]
  ------------------
 3038|      0|                        ent = xmlGetDocEntity(node->doc, strip);
 3039|      0|                        xmlFree(strip);
 3040|      0|                    } else {
 3041|      0|                        ent = xmlGetDocEntity(node->doc, value);
 3042|      0|                    }
 3043|      0|                    if ((ent == NULL) ||
  ------------------
  |  Branch (3043:25): [True: 0, False: 0]
  ------------------
 3044|      0|                        (ent->etype !=
  ------------------
  |  Branch (3044:25): [True: 0, False: 0]
  ------------------
 3045|      0|                         XML_EXTERNAL_GENERAL_UNPARSED_ENTITY))
 3046|      0|                        ret = 4;
 3047|      0|                }
 3048|      0|                if ((ret == 0) && (val != NULL)) {
  ------------------
  |  Branch (3048:21): [True: 0, False: 0]
  |  Branch (3048:35): [True: 0, False: 0]
  ------------------
 3049|      0|                    TODO;
  ------------------
  |  |   45|      0|    xmlGenericError(xmlGenericErrorContext,				\
  |  |  ------------------
  |  |  |  |  875|      0|  #define xmlGenericError XML_GLOBAL_MACRO(xmlGenericError)
  |  |  |  |  ------------------
  |  |  |  |  |  |  500|      0|  #define XML_GLOBAL_MACRO(name) (*__##name())
  |  |  |  |  ------------------
  |  |  ------------------
  |  |                   xmlGenericError(xmlGenericErrorContext,				\
  |  |  ------------------
  |  |  |  |  876|      0|  #define xmlGenericErrorContext XML_GLOBAL_MACRO(xmlGenericErrorContext)
  |  |  |  |  ------------------
  |  |  |  |  |  |  500|      0|  #define XML_GLOBAL_MACRO(name) (*__##name())
  |  |  |  |  ------------------
  |  |  ------------------
  |  |   46|      0|	    "Unimplemented block at %s:%d\n",				\
  |  |   47|      0|            __FILE__, __LINE__);
  ------------------
 3050|      0|                }
 3051|      0|                if ((ret == 0) && (node != NULL) &&
  ------------------
  |  Branch (3051:21): [True: 0, False: 0]
  |  Branch (3051:35): [True: 0, False: 0]
  ------------------
 3052|      0|                    (node->type == XML_ATTRIBUTE_NODE)) {
  ------------------
  |  Branch (3052:21): [True: 0, False: 0]
  ------------------
 3053|      0|                    xmlAttrPtr attr = (xmlAttrPtr) node;
 3054|       |
 3055|      0|                    attr->atype = XML_ATTRIBUTE_ENTITY;
 3056|      0|                }
 3057|      0|                goto done;
 3058|      0|            }
 3059|      0|        case XML_SCHEMAS_ENTITIES:
  ------------------
  |  Branch (3059:9): [True: 0, False: 1.55k]
  ------------------
 3060|      0|            if ((node == NULL) || (node->doc == NULL))
  ------------------
  |  Branch (3060:17): [True: 0, False: 0]
  |  Branch (3060:35): [True: 0, False: 0]
  ------------------
 3061|      0|                goto return3;
 3062|      0|            ret = xmlSchemaValAtomicListNode(xmlSchemaTypeEntityDef,
 3063|      0|                                             value, val, node);
 3064|      0|            if (ret <= 0)
  ------------------
  |  Branch (3064:17): [True: 0, False: 0]
  ------------------
 3065|      0|                ret = 1;
 3066|      0|            else
 3067|      0|                ret = 0;
 3068|      0|            if ((ret == 0) && (node != NULL) &&
  ------------------
  |  Branch (3068:17): [True: 0, False: 0]
  |  Branch (3068:31): [True: 0, False: 0]
  ------------------
 3069|      0|                (node->type == XML_ATTRIBUTE_NODE)) {
  ------------------
  |  Branch (3069:17): [True: 0, False: 0]
  ------------------
 3070|      0|                xmlAttrPtr attr = (xmlAttrPtr) node;
 3071|       |
 3072|      0|                attr->atype = XML_ATTRIBUTE_ENTITIES;
 3073|      0|            }
 3074|      0|            goto done;
 3075|      0|        case XML_SCHEMAS_NOTATION:{
  ------------------
  |  Branch (3075:9): [True: 0, False: 1.55k]
  ------------------
 3076|      0|                xmlChar *uri = NULL;
 3077|      0|                xmlChar *local = NULL;
 3078|       |
 3079|      0|                ret = xmlValidateQName(value, 1);
 3080|      0|                if ((ret == 0) && (node != NULL)) {
  ------------------
  |  Branch (3080:21): [True: 0, False: 0]
  |  Branch (3080:35): [True: 0, False: 0]
  ------------------
 3081|      0|                    xmlChar *prefix;
 3082|       |
 3083|      0|                    local = xmlSplitQName2(value, &prefix);
 3084|      0|                    if (prefix != NULL) {
  ------------------
  |  Branch (3084:25): [True: 0, False: 0]
  ------------------
 3085|      0|                        xmlNsPtr ns;
 3086|       |
 3087|      0|                        ns = xmlSearchNs(node->doc, node, prefix);
 3088|      0|                        if (ns == NULL)
  ------------------
  |  Branch (3088:29): [True: 0, False: 0]
  ------------------
 3089|      0|                            ret = 1;
 3090|      0|                        else if (val != NULL)
  ------------------
  |  Branch (3090:34): [True: 0, False: 0]
  ------------------
 3091|      0|                            uri = xmlStrdup(ns->href);
 3092|      0|                    }
 3093|      0|                    if ((local != NULL) && ((val == NULL) || (ret != 0)))
  ------------------
  |  Branch (3093:25): [True: 0, False: 0]
  |  Branch (3093:45): [True: 0, False: 0]
  |  Branch (3093:62): [True: 0, False: 0]
  ------------------
 3094|      0|                        xmlFree(local);
 3095|      0|                    if (prefix != NULL)
  ------------------
  |  Branch (3095:25): [True: 0, False: 0]
  ------------------
 3096|      0|                        xmlFree(prefix);
 3097|      0|                }
 3098|      0|                if ((node == NULL) || (node->doc == NULL))
  ------------------
  |  Branch (3098:21): [True: 0, False: 0]
  |  Branch (3098:39): [True: 0, False: 0]
  ------------------
 3099|      0|                    ret = 3;
 3100|      0|                if (ret == 0) {
  ------------------
  |  Branch (3100:21): [True: 0, False: 0]
  ------------------
 3101|      0|                    ret = xmlValidateNotationUse(NULL, node->doc, value);
 3102|      0|                    if (ret == 1)
  ------------------
  |  Branch (3102:25): [True: 0, False: 0]
  ------------------
 3103|      0|                        ret = 0;
 3104|      0|                    else
 3105|      0|                        ret = 1;
 3106|      0|                }
 3107|      0|                if ((ret == 0) && (val != NULL)) {
  ------------------
  |  Branch (3107:21): [True: 0, False: 0]
  |  Branch (3107:35): [True: 0, False: 0]
  ------------------
 3108|      0|                    v = xmlSchemaNewValue(XML_SCHEMAS_NOTATION);
 3109|      0|                    if (v != NULL) {
  ------------------
  |  Branch (3109:25): [True: 0, False: 0]
  ------------------
 3110|      0|                        if (local != NULL)
  ------------------
  |  Branch (3110:29): [True: 0, False: 0]
  ------------------
 3111|      0|                            v->value.qname.name = local;
 3112|      0|                        else
 3113|      0|                            v->value.qname.name = xmlStrdup(value);
 3114|      0|                        if (uri != NULL)
  ------------------
  |  Branch (3114:29): [True: 0, False: 0]
  ------------------
 3115|      0|                            v->value.qname.uri = uri;
 3116|       |
 3117|      0|                        *val = v;
 3118|      0|                    } else {
 3119|      0|                        if (local != NULL)
  ------------------
  |  Branch (3119:29): [True: 0, False: 0]
  ------------------
 3120|      0|                            xmlFree(local);
 3121|      0|                        if (uri != NULL)
  ------------------
  |  Branch (3121:29): [True: 0, False: 0]
  ------------------
 3122|      0|                            xmlFree(uri);
 3123|      0|                        goto error;
 3124|      0|                    }
 3125|      0|                }
 3126|      0|                goto done;
 3127|      0|            }
 3128|    224|        case XML_SCHEMAS_ANYURI:{
  ------------------
  |  Branch (3128:9): [True: 224, False: 1.33k]
  ------------------
 3129|    224|                if (*value != 0) {
  ------------------
  |  Branch (3129:21): [True: 224, False: 0]
  ------------------
 3130|    224|		    xmlURIPtr uri;
 3131|    224|		    xmlChar *tmpval, *cur;
 3132|    224|		    if ((norm == NULL) && (normOnTheFly)) {
  ------------------
  |  Branch (3132:11): [True: 224, False: 0]
  |  Branch (3132:29): [True: 224, False: 0]
  ------------------
 3133|    224|			norm = xmlSchemaCollapseString(value);
 3134|    224|			if (norm != NULL)
  ------------------
  |  Branch (3134:8): [True: 0, False: 224]
  ------------------
 3135|      0|			    value = norm;
 3136|    224|		    }
 3137|    224|		    tmpval = xmlStrdup(value);
 3138|    224|                    if (tmpval == NULL)
  ------------------
  |  Branch (3138:25): [True: 0, False: 224]
  ------------------
 3139|      0|                        goto error;
 3140|  4.15k|		    for (cur = tmpval; *cur; ++cur) {
  ------------------
  |  Branch (3140:26): [True: 3.93k, False: 224]
  ------------------
 3141|  3.93k|			if (*cur < 32 || *cur >= 127 || *cur == ' ' ||
  ------------------
  |  Branch (3141:8): [True: 0, False: 3.93k]
  |  Branch (3141:21): [True: 0, False: 3.93k]
  |  Branch (3141:36): [True: 0, False: 3.93k]
  ------------------
 3142|  3.93k|			    *cur == '<' || *cur == '>' || *cur == '"' ||
  ------------------
  |  Branch (3142:8): [True: 0, False: 3.93k]
  |  Branch (3142:23): [True: 0, False: 3.93k]
  |  Branch (3142:38): [True: 0, False: 3.93k]
  ------------------
 3143|  3.93k|			    *cur == '{' || *cur == '}' || *cur == '|' ||
  ------------------
  |  Branch (3143:8): [True: 0, False: 3.93k]
  |  Branch (3143:23): [True: 0, False: 3.93k]
  |  Branch (3143:38): [True: 0, False: 3.93k]
  ------------------
 3144|  3.93k|			    *cur == '\\' || *cur == '^' || *cur == '`' ||
  ------------------
  |  Branch (3144:8): [True: 0, False: 3.93k]
  |  Branch (3144:24): [True: 0, False: 3.93k]
  |  Branch (3144:39): [True: 0, False: 3.93k]
  ------------------
 3145|  3.93k|			    *cur == '\'')
  ------------------
  |  Branch (3145:8): [True: 0, False: 3.93k]
  ------------------
 3146|      0|			    *cur = '_';
 3147|  3.93k|		    }
 3148|    224|                    uri = xmlParseURI((const char *) tmpval);
 3149|    224|		    xmlFree(tmpval);
 3150|    224|                    if (uri == NULL)
  ------------------
  |  Branch (3150:25): [True: 0, False: 224]
  ------------------
 3151|      0|                        goto return1;
 3152|    224|                    xmlFreeURI(uri);
 3153|    224|                }
 3154|       |
 3155|    224|                if (val != NULL) {
  ------------------
  |  Branch (3155:21): [True: 1, False: 223]
  ------------------
 3156|      1|                    v = xmlSchemaNewValue(XML_SCHEMAS_ANYURI);
 3157|      1|                    if (v == NULL)
  ------------------
  |  Branch (3157:25): [True: 0, False: 1]
  ------------------
 3158|      0|                        goto error;
 3159|      1|                    v->value.str = xmlStrdup(value);
 3160|      1|                    *val = v;
 3161|      1|                }
 3162|    224|                goto return0;
 3163|    224|            }
 3164|    224|        case XML_SCHEMAS_HEXBINARY:{
  ------------------
  |  Branch (3164:9): [True: 0, False: 1.55k]
  ------------------
 3165|      0|                const xmlChar *cur = value, *start;
 3166|      0|                xmlChar *base;
 3167|      0|                int total, i = 0;
 3168|       |
 3169|      0|                if (cur == NULL)
  ------------------
  |  Branch (3169:21): [True: 0, False: 0]
  ------------------
 3170|      0|                    goto return1;
 3171|       |
 3172|      0|		if (normOnTheFly)
  ------------------
  |  Branch (3172:7): [True: 0, False: 0]
  ------------------
 3173|      0|		    while IS_WSP_BLANK_CH(*cur) cur++;
 3174|       |
 3175|      0|		start = cur;
 3176|      0|                while (((*cur >= '0') && (*cur <= '9')) ||
  ------------------
  |  Branch (3176:25): [True: 0, False: 0]
  |  Branch (3176:42): [True: 0, False: 0]
  ------------------
 3177|      0|                       ((*cur >= 'A') && (*cur <= 'F')) ||
  ------------------
  |  Branch (3177:25): [True: 0, False: 0]
  |  Branch (3177:42): [True: 0, False: 0]
  ------------------
 3178|      0|                       ((*cur >= 'a') && (*cur <= 'f'))) {
  ------------------
  |  Branch (3178:25): [True: 0, False: 0]
  |  Branch (3178:42): [True: 0, False: 0]
  ------------------
 3179|      0|                    i++;
 3180|      0|                    cur++;
 3181|      0|                }
 3182|      0|		if (normOnTheFly)
  ------------------
  |  Branch (3182:7): [True: 0, False: 0]
  ------------------
 3183|      0|		    while IS_WSP_BLANK_CH(*cur) cur++;
 3184|       |
 3185|      0|                if (*cur != 0)
  ------------------
  |  Branch (3185:21): [True: 0, False: 0]
  ------------------
 3186|      0|                    goto return1;
 3187|      0|                if ((i % 2) != 0)
  ------------------
  |  Branch (3187:21): [True: 0, False: 0]
  ------------------
 3188|      0|                    goto return1;
 3189|       |
 3190|      0|                if (val != NULL) {
  ------------------
  |  Branch (3190:21): [True: 0, False: 0]
  ------------------
 3191|       |
 3192|      0|                    v = xmlSchemaNewValue(XML_SCHEMAS_HEXBINARY);
 3193|      0|                    if (v == NULL)
  ------------------
  |  Branch (3193:25): [True: 0, False: 0]
  ------------------
 3194|      0|                        goto error;
 3195|       |		    /*
 3196|       |		    * Copy only the normalized piece.
 3197|       |		    * CRITICAL TODO: Check this.
 3198|       |		    */
 3199|      0|                    cur = xmlStrndup(start, i);
 3200|      0|                    if (cur == NULL) {
  ------------------
  |  Branch (3200:25): [True: 0, False: 0]
  ------------------
 3201|      0|		        xmlSchemaTypeErrMemory(node, "allocating hexbin data");
 3202|      0|                        xmlFree(v);
 3203|      0|                        goto return1;
 3204|      0|                    }
 3205|       |
 3206|      0|                    total = i / 2;      /* number of octets */
 3207|       |
 3208|      0|                    base = (xmlChar *) cur;
 3209|      0|                    while (i-- > 0) {
  ------------------
  |  Branch (3209:28): [True: 0, False: 0]
  ------------------
 3210|      0|                        if (*base >= 'a')
  ------------------
  |  Branch (3210:29): [True: 0, False: 0]
  ------------------
 3211|      0|                            *base = *base - ('a' - 'A');
 3212|      0|                        base++;
 3213|      0|                    }
 3214|       |
 3215|      0|                    v->value.hex.str = (xmlChar *) cur;
 3216|      0|                    v->value.hex.total = total;
 3217|      0|                    *val = v;
 3218|      0|                }
 3219|      0|                goto return0;
 3220|      0|            }
 3221|      0|        case XML_SCHEMAS_BASE64BINARY:{
  ------------------
  |  Branch (3221:9): [True: 0, False: 1.55k]
  ------------------
 3222|       |                /* ISSUE:
 3223|       |                 *
 3224|       |                 * Ignore all stray characters? (yes, currently)
 3225|       |                 * Worry about long lines? (no, currently)
 3226|       |                 *
 3227|       |                 * rfc2045.txt:
 3228|       |                 *
 3229|       |                 * "The encoded output stream must be represented in lines of
 3230|       |                 * no more than 76 characters each.  All line breaks or other
 3231|       |                 * characters not found in Table 1 must be ignored by decoding
 3232|       |                 * software.  In base64 data, characters other than those in
 3233|       |                 * Table 1, line breaks, and other white space probably
 3234|       |                 * indicate a transmission error, about which a warning
 3235|       |                 * message or even a message rejection might be appropriate
 3236|       |                 * under some circumstances." */
 3237|      0|                const xmlChar *cur = value;
 3238|      0|                xmlChar *base;
 3239|      0|                int total, i = 0, pad = 0;
 3240|       |
 3241|      0|                if (cur == NULL)
  ------------------
  |  Branch (3241:21): [True: 0, False: 0]
  ------------------
 3242|      0|                    goto return1;
 3243|       |
 3244|      0|                for (; *cur; ++cur) {
  ------------------
  |  Branch (3244:24): [True: 0, False: 0]
  ------------------
 3245|      0|                    int decc;
 3246|       |
 3247|      0|                    decc = _xmlSchemaBase64Decode(*cur);
 3248|      0|                    if (decc < 0) ;
  ------------------
  |  Branch (3248:25): [True: 0, False: 0]
  ------------------
 3249|      0|                    else if (decc < 64)
  ------------------
  |  Branch (3249:30): [True: 0, False: 0]
  ------------------
 3250|      0|                        i++;
 3251|      0|                    else
 3252|      0|                        break;
 3253|      0|                }
 3254|      0|                for (; *cur; ++cur) {
  ------------------
  |  Branch (3254:24): [True: 0, False: 0]
  ------------------
 3255|      0|                    int decc;
 3256|       |
 3257|      0|                    decc = _xmlSchemaBase64Decode(*cur);
 3258|      0|                    if (decc < 0) ;
  ------------------
  |  Branch (3258:25): [True: 0, False: 0]
  ------------------
 3259|      0|                    else if (decc < 64)
  ------------------
  |  Branch (3259:30): [True: 0, False: 0]
  ------------------
 3260|      0|                        goto return1;
 3261|      0|                    if (decc == 64)
  ------------------
  |  Branch (3261:25): [True: 0, False: 0]
  ------------------
 3262|      0|                        pad++;
 3263|      0|                }
 3264|       |
 3265|       |                /* rfc2045.txt: "Special processing is performed if fewer than
 3266|       |                 * 24 bits are available at the end of the data being encoded.
 3267|       |                 * A full encoding quantum is always completed at the end of a
 3268|       |                 * body.  When fewer than 24 input bits are available in an
 3269|       |                 * input group, zero bits are added (on the right) to form an
 3270|       |                 * integral number of 6-bit groups.  Padding at the end of the
 3271|       |                 * data is performed using the "=" character.  Since all
 3272|       |                 * base64 input is an integral number of octets, only the
 3273|       |                 * following cases can arise: (1) the final quantum of
 3274|       |                 * encoding input is an integral multiple of 24 bits; here,
 3275|       |                 * the final unit of encoded output will be an integral
 3276|       |                 * multiple of indent: Standard input:701: Warning:old style
 3277|       |		 * assignment ambiguity in "=*".  Assuming "= *" 4 characters
 3278|       |		 * with no "=" padding, (2) the final
 3279|       |                 * quantum of encoding input is exactly 8 bits; here, the
 3280|       |                 * final unit of encoded output will be two characters
 3281|       |                 * followed by two "=" padding characters, or (3) the final
 3282|       |                 * quantum of encoding input is exactly 16 bits; here, the
 3283|       |                 * final unit of encoded output will be three characters
 3284|       |                 * followed by one "=" padding character." */
 3285|       |
 3286|      0|                total = 3 * (i / 4);
 3287|      0|                if (pad == 0) {
  ------------------
  |  Branch (3287:21): [True: 0, False: 0]
  ------------------
 3288|      0|                    if (i % 4 != 0)
  ------------------
  |  Branch (3288:25): [True: 0, False: 0]
  ------------------
 3289|      0|                        goto return1;
 3290|      0|                } else if (pad == 1) {
  ------------------
  |  Branch (3290:28): [True: 0, False: 0]
  ------------------
 3291|      0|                    int decc;
 3292|       |
 3293|      0|                    if (i % 4 != 3)
  ------------------
  |  Branch (3293:25): [True: 0, False: 0]
  ------------------
 3294|      0|                        goto return1;
 3295|      0|                    for (decc = _xmlSchemaBase64Decode(*cur);
 3296|      0|                         (decc < 0) || (decc > 63);
  ------------------
  |  Branch (3296:26): [True: 0, False: 0]
  |  Branch (3296:40): [True: 0, False: 0]
  ------------------
 3297|      0|                         decc = _xmlSchemaBase64Decode(*cur))
 3298|      0|                        --cur;
 3299|       |                    /* 16bits in 24bits means 2 pad bits: nnnnnn nnmmmm mmmm00*/
 3300|       |                    /* 00111100 -> 0x3c */
 3301|      0|                    if (decc & ~0x3c)
  ------------------
  |  Branch (3301:25): [True: 0, False: 0]
  ------------------
 3302|      0|                        goto return1;
 3303|      0|                    total += 2;
 3304|      0|                } else if (pad == 2) {
  ------------------
  |  Branch (3304:28): [True: 0, False: 0]
  ------------------
 3305|      0|                    int decc;
 3306|       |
 3307|      0|                    if (i % 4 != 2)
  ------------------
  |  Branch (3307:25): [True: 0, False: 0]
  ------------------
 3308|      0|                        goto return1;
 3309|      0|                    for (decc = _xmlSchemaBase64Decode(*cur);
 3310|      0|                         (decc < 0) || (decc > 63);
  ------------------
  |  Branch (3310:26): [True: 0, False: 0]
  |  Branch (3310:40): [True: 0, False: 0]
  ------------------
 3311|      0|                         decc = _xmlSchemaBase64Decode(*cur))
 3312|      0|                        --cur;
 3313|       |                    /* 8bits in 12bits means 4 pad bits: nnnnnn nn0000 */
 3314|       |                    /* 00110000 -> 0x30 */
 3315|      0|                    if (decc & ~0x30)
  ------------------
  |  Branch (3315:25): [True: 0, False: 0]
  ------------------
 3316|      0|                        goto return1;
 3317|      0|                    total += 1;
 3318|      0|                } else
 3319|      0|                    goto return1;
 3320|       |
 3321|      0|                if (val != NULL) {
  ------------------
  |  Branch (3321:21): [True: 0, False: 0]
  ------------------
 3322|      0|                    v = xmlSchemaNewValue(XML_SCHEMAS_BASE64BINARY);
 3323|      0|                    if (v == NULL)
  ------------------
  |  Branch (3323:25): [True: 0, False: 0]
  ------------------
 3324|      0|                        goto error;
 3325|      0|                    base =
 3326|      0|                        (xmlChar *) xmlMallocAtomic(i + pad + 1);
 3327|      0|                    if (base == NULL) {
  ------------------
  |  Branch (3327:25): [True: 0, False: 0]
  ------------------
 3328|      0|		        xmlSchemaTypeErrMemory(node, "allocating base64 data");
 3329|      0|                        xmlFree(v);
 3330|      0|                        goto return1;
 3331|      0|                    }
 3332|      0|                    v->value.base64.str = base;
 3333|      0|                    for (cur = value; *cur; ++cur)
  ------------------
  |  Branch (3333:39): [True: 0, False: 0]
  ------------------
 3334|      0|                        if (_xmlSchemaBase64Decode(*cur) >= 0) {
  ------------------
  |  Branch (3334:29): [True: 0, False: 0]
  ------------------
 3335|      0|                            *base = *cur;
 3336|      0|                            ++base;
 3337|      0|                        }
 3338|      0|                    *base = 0;
 3339|      0|                    v->value.base64.total = total;
 3340|      0|                    *val = v;
 3341|      0|                }
 3342|      0|                goto return0;
 3343|      0|            }
 3344|      0|        case XML_SCHEMAS_INTEGER:
  ------------------
  |  Branch (3344:9): [True: 0, False: 1.55k]
  ------------------
 3345|     11|        case XML_SCHEMAS_PINTEGER:
  ------------------
  |  Branch (3345:9): [True: 11, False: 1.54k]
  ------------------
 3346|     11|        case XML_SCHEMAS_NPINTEGER:
  ------------------
  |  Branch (3346:9): [True: 0, False: 1.55k]
  ------------------
 3347|     11|        case XML_SCHEMAS_NINTEGER:
  ------------------
  |  Branch (3347:9): [True: 0, False: 1.55k]
  ------------------
 3348|     34|        case XML_SCHEMAS_NNINTEGER:{
  ------------------
  |  Branch (3348:9): [True: 23, False: 1.53k]
  ------------------
 3349|     34|                const xmlChar *cur = value;
 3350|     34|                unsigned long lo, mi, hi;
 3351|     34|                int sign = 0;
 3352|       |
 3353|     34|                if (cur == NULL)
  ------------------
  |  Branch (3353:21): [True: 0, False: 34]
  ------------------
 3354|      0|                    goto return1;
 3355|     34|		if (normOnTheFly)
  ------------------
  |  Branch (3355:7): [True: 34, False: 0]
  ------------------
 3356|     34|		    while IS_WSP_BLANK_CH(*cur) cur++;
 3357|     34|                if (*cur == '-') {
  ------------------
  |  Branch (3357:21): [True: 0, False: 34]
  ------------------
 3358|      0|                    sign = 1;
 3359|      0|                    cur++;
 3360|     34|                } else if (*cur == '+')
  ------------------
  |  Branch (3360:28): [True: 0, False: 34]
  ------------------
 3361|      0|                    cur++;
 3362|     34|                ret = xmlSchemaParseUInt(&cur, &lo, &mi, &hi);
 3363|     34|                if (ret < 0)
  ------------------
  |  Branch (3363:21): [True: 0, False: 34]
  ------------------
 3364|      0|                    goto return1;
 3365|     34|		if (normOnTheFly)
  ------------------
  |  Branch (3365:7): [True: 34, False: 0]
  ------------------
 3366|     34|		    while IS_WSP_BLANK_CH(*cur) cur++;
 3367|     34|                if (*cur != 0)
  ------------------
  |  Branch (3367:21): [True: 0, False: 34]
  ------------------
 3368|      0|                    goto return1;
 3369|     34|                if (type->builtInType == XML_SCHEMAS_NPINTEGER) {
  ------------------
  |  Branch (3369:21): [True: 0, False: 34]
  ------------------
 3370|      0|                    if ((sign == 0) &&
  ------------------
  |  Branch (3370:25): [True: 0, False: 0]
  ------------------
 3371|      0|                        ((hi != 0) || (mi != 0) || (lo != 0)))
  ------------------
  |  Branch (3371:26): [True: 0, False: 0]
  |  Branch (3371:39): [True: 0, False: 0]
  |  Branch (3371:52): [True: 0, False: 0]
  ------------------
 3372|      0|                        goto return1;
 3373|     34|                } else if (type->builtInType == XML_SCHEMAS_PINTEGER) {
  ------------------
  |  Branch (3373:28): [True: 11, False: 23]
  ------------------
 3374|     11|                    if (sign == 1)
  ------------------
  |  Branch (3374:25): [True: 0, False: 11]
  ------------------
 3375|      0|                        goto return1;
 3376|     11|                    if ((hi == 0) && (mi == 0) && (lo == 0))
  ------------------
  |  Branch (3376:25): [True: 11, False: 0]
  |  Branch (3376:38): [True: 11, False: 0]
  |  Branch (3376:51): [True: 0, False: 11]
  ------------------
 3377|      0|                        goto return1;
 3378|     23|                } else if (type->builtInType == XML_SCHEMAS_NINTEGER) {
  ------------------
  |  Branch (3378:28): [True: 0, False: 23]
  ------------------
 3379|      0|                    if (sign == 0)
  ------------------
  |  Branch (3379:25): [True: 0, False: 0]
  ------------------
 3380|      0|                        goto return1;
 3381|      0|                    if ((hi == 0) && (mi == 0) && (lo == 0))
  ------------------
  |  Branch (3381:25): [True: 0, False: 0]
  |  Branch (3381:38): [True: 0, False: 0]
  |  Branch (3381:51): [True: 0, False: 0]
  ------------------
 3382|      0|                        goto return1;
 3383|     23|                } else if (type->builtInType == XML_SCHEMAS_NNINTEGER) {
  ------------------
  |  Branch (3383:28): [True: 23, False: 0]
  ------------------
 3384|     23|                    if ((sign == 1) &&
  ------------------
  |  Branch (3384:25): [True: 0, False: 23]
  ------------------
 3385|     23|                        ((hi != 0) || (mi != 0) || (lo != 0)))
  ------------------
  |  Branch (3385:26): [True: 0, False: 0]
  |  Branch (3385:39): [True: 0, False: 0]
  |  Branch (3385:52): [True: 0, False: 0]
  ------------------
 3386|      0|                        goto return1;
 3387|     23|                }
 3388|     34|                if (val != NULL) {
  ------------------
  |  Branch (3388:21): [True: 34, False: 0]
  ------------------
 3389|     34|                    v = xmlSchemaNewValue(type->builtInType);
 3390|     34|                    if (v != NULL) {
  ------------------
  |  Branch (3390:25): [True: 34, False: 0]
  ------------------
 3391|     34|			if (ret == 0)
  ------------------
  |  Branch (3391:8): [True: 0, False: 34]
  ------------------
 3392|      0|			    ret++;
 3393|     34|                        v->value.decimal.lo = lo;
 3394|     34|                        v->value.decimal.mi = mi;
 3395|     34|                        v->value.decimal.hi = hi;
 3396|     34|                        v->value.decimal.sign = sign;
 3397|     34|                        v->value.decimal.frac = 0;
 3398|     34|                        v->value.decimal.total = ret;
 3399|     34|                        *val = v;
 3400|     34|                    }
 3401|     34|                }
 3402|     34|                goto return0;
 3403|     34|            }
 3404|      0|        case XML_SCHEMAS_LONG:
  ------------------
  |  Branch (3404:9): [True: 0, False: 1.55k]
  ------------------
 3405|      2|        case XML_SCHEMAS_BYTE:
  ------------------
  |  Branch (3405:9): [True: 2, False: 1.55k]
  ------------------
 3406|      2|        case XML_SCHEMAS_SHORT:
  ------------------
  |  Branch (3406:9): [True: 0, False: 1.55k]
  ------------------
 3407|      6|        case XML_SCHEMAS_INT:{
  ------------------
  |  Branch (3407:9): [True: 4, False: 1.55k]
  ------------------
 3408|      6|                const xmlChar *cur = value;
 3409|      6|                unsigned long lo, mi, hi;
 3410|      6|                int sign = 0;
 3411|       |
 3412|      6|                if (cur == NULL)
  ------------------
  |  Branch (3412:21): [True: 0, False: 6]
  ------------------
 3413|      0|                    goto return1;
 3414|      6|		if (normOnTheFly)
  ------------------
  |  Branch (3414:7): [True: 6, False: 0]
  ------------------
 3415|      6|		    while IS_WSP_BLANK_CH(*cur) cur++;
 3416|      6|                if (*cur == '-') {
  ------------------
  |  Branch (3416:21): [True: 0, False: 6]
  ------------------
 3417|      0|                    sign = 1;
 3418|      0|                    cur++;
 3419|      6|                } else if (*cur == '+')
  ------------------
  |  Branch (3419:28): [True: 0, False: 6]
  ------------------
 3420|      0|                    cur++;
 3421|      6|                ret = xmlSchemaParseUInt(&cur, &lo, &mi, &hi);
 3422|      6|                if (ret < 0)
  ------------------
  |  Branch (3422:21): [True: 0, False: 6]
  ------------------
 3423|      0|                    goto return1;
 3424|      6|		if (normOnTheFly)
  ------------------
  |  Branch (3424:7): [True: 6, False: 0]
  ------------------
 3425|      6|		    while IS_WSP_BLANK_CH(*cur) cur++;
 3426|      6|                if (*cur != 0)
  ------------------
  |  Branch (3426:21): [True: 0, False: 6]
  ------------------
 3427|      0|                    goto return1;
 3428|      6|                if (type->builtInType == XML_SCHEMAS_LONG) {
  ------------------
  |  Branch (3428:21): [True: 0, False: 6]
  ------------------
 3429|      0|                    if (hi >= 922) {
  ------------------
  |  Branch (3429:25): [True: 0, False: 0]
  ------------------
 3430|      0|                        if (hi > 922)
  ------------------
  |  Branch (3430:29): [True: 0, False: 0]
  ------------------
 3431|      0|                            goto return1;
 3432|      0|                        if (mi >= 33720368) {
  ------------------
  |  Branch (3432:29): [True: 0, False: 0]
  ------------------
 3433|      0|                            if (mi > 33720368)
  ------------------
  |  Branch (3433:33): [True: 0, False: 0]
  ------------------
 3434|      0|                                goto return1;
 3435|      0|                            if ((sign == 0) && (lo > 54775807))
  ------------------
  |  Branch (3435:33): [True: 0, False: 0]
  |  Branch (3435:48): [True: 0, False: 0]
  ------------------
 3436|      0|                                goto return1;
 3437|      0|                            if ((sign == 1) && (lo > 54775808))
  ------------------
  |  Branch (3437:33): [True: 0, False: 0]
  |  Branch (3437:48): [True: 0, False: 0]
  ------------------
 3438|      0|                                goto return1;
 3439|      0|                        }
 3440|      0|                    }
 3441|      6|                } else if (type->builtInType == XML_SCHEMAS_INT) {
  ------------------
  |  Branch (3441:28): [True: 4, False: 2]
  ------------------
 3442|      4|                    if (hi != 0)
  ------------------
  |  Branch (3442:25): [True: 0, False: 4]
  ------------------
 3443|      0|                        goto return1;
 3444|      4|                    if (mi >= 21) {
  ------------------
  |  Branch (3444:25): [True: 0, False: 4]
  ------------------
 3445|      0|                        if (mi > 21)
  ------------------
  |  Branch (3445:29): [True: 0, False: 0]
  ------------------
 3446|      0|                            goto return1;
 3447|      0|                        if ((sign == 0) && (lo > 47483647))
  ------------------
  |  Branch (3447:29): [True: 0, False: 0]
  |  Branch (3447:44): [True: 0, False: 0]
  ------------------
 3448|      0|                            goto return1;
 3449|      0|                        if ((sign == 1) && (lo > 47483648))
  ------------------
  |  Branch (3449:29): [True: 0, False: 0]
  |  Branch (3449:44): [True: 0, False: 0]
  ------------------
 3450|      0|                            goto return1;
 3451|      0|                    }
 3452|      4|                } else if (type->builtInType == XML_SCHEMAS_SHORT) {
  ------------------
  |  Branch (3452:28): [True: 0, False: 2]
  ------------------
 3453|      0|                    if ((mi != 0) || (hi != 0))
  ------------------
  |  Branch (3453:25): [True: 0, False: 0]
  |  Branch (3453:38): [True: 0, False: 0]
  ------------------
 3454|      0|                        goto return1;
 3455|      0|                    if ((sign == 1) && (lo > 32768))
  ------------------
  |  Branch (3455:25): [True: 0, False: 0]
  |  Branch (3455:40): [True: 0, False: 0]
  ------------------
 3456|      0|                        goto return1;
 3457|      0|                    if ((sign == 0) && (lo > 32767))
  ------------------
  |  Branch (3457:25): [True: 0, False: 0]
  |  Branch (3457:40): [True: 0, False: 0]
  ------------------
 3458|      0|                        goto return1;
 3459|      2|                } else if (type->builtInType == XML_SCHEMAS_BYTE) {
  ------------------
  |  Branch (3459:28): [True: 2, False: 0]
  ------------------
 3460|      2|                    if ((mi != 0) || (hi != 0))
  ------------------
  |  Branch (3460:25): [True: 0, False: 2]
  |  Branch (3460:38): [True: 0, False: 2]
  ------------------
 3461|      0|                        goto return1;
 3462|      2|                    if ((sign == 1) && (lo > 128))
  ------------------
  |  Branch (3462:25): [True: 0, False: 2]
  |  Branch (3462:40): [True: 0, False: 0]
  ------------------
 3463|      0|                        goto return1;
 3464|      2|                    if ((sign == 0) && (lo > 127))
  ------------------
  |  Branch (3464:25): [True: 2, False: 0]
  |  Branch (3464:40): [True: 0, False: 2]
  ------------------
 3465|      0|                        goto return1;
 3466|      2|                }
 3467|      6|                if (val != NULL) {
  ------------------
  |  Branch (3467:21): [True: 6, False: 0]
  ------------------
 3468|      6|                    v = xmlSchemaNewValue(type->builtInType);
 3469|      6|                    if (v != NULL) {
  ------------------
  |  Branch (3469:25): [True: 6, False: 0]
  ------------------
 3470|      6|                        v->value.decimal.lo = lo;
 3471|      6|                        v->value.decimal.mi = mi;
 3472|      6|                        v->value.decimal.hi = hi;
 3473|      6|                        v->value.decimal.sign = sign;
 3474|      6|                        v->value.decimal.frac = 0;
 3475|      6|                        v->value.decimal.total = ret;
 3476|      6|                        *val = v;
 3477|      6|                    }
 3478|      6|                }
 3479|      6|                goto return0;
 3480|      6|            }
 3481|      0|        case XML_SCHEMAS_UINT:
  ------------------
  |  Branch (3481:9): [True: 0, False: 1.55k]
  ------------------
 3482|      0|        case XML_SCHEMAS_ULONG:
  ------------------
  |  Branch (3482:9): [True: 0, False: 1.55k]
  ------------------
 3483|      0|        case XML_SCHEMAS_USHORT:
  ------------------
  |  Branch (3483:9): [True: 0, False: 1.55k]
  ------------------
 3484|      0|        case XML_SCHEMAS_UBYTE:{
  ------------------
  |  Branch (3484:9): [True: 0, False: 1.55k]
  ------------------
 3485|      0|                const xmlChar *cur = value;
 3486|      0|                unsigned long lo, mi, hi;
 3487|       |
 3488|      0|                if (cur == NULL)
  ------------------
  |  Branch (3488:21): [True: 0, False: 0]
  ------------------
 3489|      0|                    goto return1;
 3490|      0|		if (normOnTheFly)
  ------------------
  |  Branch (3490:7): [True: 0, False: 0]
  ------------------
 3491|      0|		    while IS_WSP_BLANK_CH(*cur) cur++;
 3492|      0|                ret = xmlSchemaParseUInt(&cur, &lo, &mi, &hi);
 3493|      0|                if (ret < 0)
  ------------------
  |  Branch (3493:21): [True: 0, False: 0]
  ------------------
 3494|      0|                    goto return1;
 3495|      0|		if (normOnTheFly)
  ------------------
  |  Branch (3495:7): [True: 0, False: 0]
  ------------------
 3496|      0|		    while IS_WSP_BLANK_CH(*cur) cur++;
 3497|      0|                if (*cur != 0)
  ------------------
  |  Branch (3497:21): [True: 0, False: 0]
  ------------------
 3498|      0|                    goto return1;
 3499|      0|                if (type->builtInType == XML_SCHEMAS_ULONG) {
  ------------------
  |  Branch (3499:21): [True: 0, False: 0]
  ------------------
 3500|      0|                    if (hi >= 1844) {
  ------------------
  |  Branch (3500:25): [True: 0, False: 0]
  ------------------
 3501|      0|                        if (hi > 1844)
  ------------------
  |  Branch (3501:29): [True: 0, False: 0]
  ------------------
 3502|      0|                            goto return1;
 3503|      0|                        if (mi >= 67440737) {
  ------------------
  |  Branch (3503:29): [True: 0, False: 0]
  ------------------
 3504|      0|                            if (mi > 67440737)
  ------------------
  |  Branch (3504:33): [True: 0, False: 0]
  ------------------
 3505|      0|                                goto return1;
 3506|      0|                            if (lo > 9551615)
  ------------------
  |  Branch (3506:33): [True: 0, False: 0]
  ------------------
 3507|      0|                                goto return1;
 3508|      0|                        }
 3509|      0|                    }
 3510|      0|                } else if (type->builtInType == XML_SCHEMAS_UINT) {
  ------------------
  |  Branch (3510:28): [True: 0, False: 0]
  ------------------
 3511|      0|                    if (hi != 0)
  ------------------
  |  Branch (3511:25): [True: 0, False: 0]
  ------------------
 3512|      0|                        goto return1;
 3513|      0|                    if (mi >= 42) {
  ------------------
  |  Branch (3513:25): [True: 0, False: 0]
  ------------------
 3514|      0|                        if (mi > 42)
  ------------------
  |  Branch (3514:29): [True: 0, False: 0]
  ------------------
 3515|      0|                            goto return1;
 3516|      0|                        if (lo > 94967295)
  ------------------
  |  Branch (3516:29): [True: 0, False: 0]
  ------------------
 3517|      0|                            goto return1;
 3518|      0|                    }
 3519|      0|                } else if (type->builtInType == XML_SCHEMAS_USHORT) {
  ------------------
  |  Branch (3519:28): [True: 0, False: 0]
  ------------------
 3520|      0|                    if ((mi != 0) || (hi != 0))
  ------------------
  |  Branch (3520:25): [True: 0, False: 0]
  |  Branch (3520:38): [True: 0, False: 0]
  ------------------
 3521|      0|                        goto return1;
 3522|      0|                    if (lo > 65535)
  ------------------
  |  Branch (3522:25): [True: 0, False: 0]
  ------------------
 3523|      0|                        goto return1;
 3524|      0|                } else if (type->builtInType == XML_SCHEMAS_UBYTE) {
  ------------------
  |  Branch (3524:28): [True: 0, False: 0]
  ------------------
 3525|      0|                    if ((mi != 0) || (hi != 0))
  ------------------
  |  Branch (3525:25): [True: 0, False: 0]
  |  Branch (3525:38): [True: 0, False: 0]
  ------------------
 3526|      0|                        goto return1;
 3527|      0|                    if (lo > 255)
  ------------------
  |  Branch (3527:25): [True: 0, False: 0]
  ------------------
 3528|      0|                        goto return1;
 3529|      0|                }
 3530|      0|                if (val != NULL) {
  ------------------
  |  Branch (3530:21): [True: 0, False: 0]
  ------------------
 3531|      0|                    v = xmlSchemaNewValue(type->builtInType);
 3532|      0|                    if (v != NULL) {
  ------------------
  |  Branch (3532:25): [True: 0, False: 0]
  ------------------
 3533|      0|                        v->value.decimal.lo = lo;
 3534|      0|                        v->value.decimal.mi = mi;
 3535|      0|                        v->value.decimal.hi = hi;
 3536|      0|                        v->value.decimal.sign = 0;
 3537|      0|                        v->value.decimal.frac = 0;
 3538|      0|                        v->value.decimal.total = ret;
 3539|      0|                        *val = v;
 3540|      0|                    }
 3541|      0|                }
 3542|      0|                goto return0;
 3543|      0|            }
 3544|  1.55k|    }
 3545|       |
 3546|  1.16k|  done:
 3547|  1.16k|    if (norm != NULL)
  ------------------
  |  Branch (3547:9): [True: 0, False: 1.16k]
  ------------------
 3548|      0|        xmlFree(norm);
 3549|  1.16k|    return (ret);
 3550|      0|  return3:
 3551|      0|    if (norm != NULL)
  ------------------
  |  Branch (3551:9): [True: 0, False: 0]
  ------------------
 3552|      0|        xmlFree(norm);
 3553|      0|    return (3);
 3554|      1|  return1:
 3555|      1|    if (norm != NULL)
  ------------------
  |  Branch (3555:9): [True: 0, False: 1]
  ------------------
 3556|      0|        xmlFree(norm);
 3557|      1|    return (1);
 3558|    388|  return0:
 3559|    388|    if (norm != NULL)
  ------------------
  |  Branch (3559:9): [True: 0, False: 388]
  ------------------
 3560|      0|        xmlFree(norm);
 3561|    388|    return (0);
 3562|      0|  error:
 3563|      0|    if (norm != NULL)
  ------------------
  |  Branch (3563:9): [True: 0, False: 0]
  ------------------
 3564|      0|        xmlFree(norm);
 3565|      0|    return (-1);
 3566|  1.55k|}
xmlschemastypes.c:xmlSchemaParseUInt:
 2252|     41|                   unsigned long *lmi, unsigned long *lhi) {
 2253|     41|    unsigned long lo = 0, mi = 0, hi = 0;
 2254|     41|    const xmlChar *tmp, *cur = *str;
 2255|     41|    int ret = 0, i = 0;
 2256|       |
 2257|     41|    if (!((*cur >= '0') && (*cur <= '9')))
  ------------------
  |  Branch (2257:11): [True: 41, False: 0]
  |  Branch (2257:28): [True: 41, False: 0]
  ------------------
 2258|      0|        return(-2);
 2259|       |
 2260|     41|    while (*cur == '0') {        /* ignore leading zeroes */
  ------------------
  |  Branch (2260:12): [True: 0, False: 41]
  ------------------
 2261|      0|        cur++;
 2262|      0|    }
 2263|     41|    tmp = cur;
 2264|    118|    while ((*tmp != 0) && (*tmp >= '0') && (*tmp <= '9')) {
  ------------------
  |  Branch (2264:12): [True: 77, False: 41]
  |  Branch (2264:27): [True: 77, False: 0]
  |  Branch (2264:44): [True: 77, False: 0]
  ------------------
 2265|     77|        i++;tmp++;ret++;
 2266|     77|    }
 2267|     41|    if (i > 24) {
  ------------------
  |  Branch (2267:9): [True: 0, False: 41]
  ------------------
 2268|      0|        *str = tmp;
 2269|      0|        return(-1);
 2270|      0|    }
 2271|     41|    while (i > 16) {
  ------------------
  |  Branch (2271:12): [True: 0, False: 41]
  ------------------
 2272|      0|        hi = hi * 10 + (*cur++ - '0');
 2273|      0|        i--;
 2274|      0|    }
 2275|     41|    while (i > 8) {
  ------------------
  |  Branch (2275:12): [True: 0, False: 41]
  ------------------
 2276|      0|        mi = mi * 10 + (*cur++ - '0');
 2277|      0|        i--;
 2278|      0|    }
 2279|    118|    while (i > 0) {
  ------------------
  |  Branch (2279:12): [True: 77, False: 41]
  ------------------
 2280|     77|        lo = lo * 10 + (*cur++ - '0');
 2281|     77|        i--;
 2282|     77|    }
 2283|       |
 2284|     41|    *str = cur;
 2285|     41|    *llo = lo;
 2286|     41|    *lmi = mi;
 2287|     41|    *lhi = hi;
 2288|     41|    return(ret);
 2289|     41|}
xmlschemastypes.c:xmlSchemaValidateDates:
 1677|     23|			int collapse) {
 1678|     23|    xmlSchemaValPtr dt;
 1679|     23|    int ret;
 1680|     23|    const xmlChar *cur = dateTime;
 1681|       |
 1682|     23|#define RETURN_TYPE_IF_VALID(t)					\
 1683|     23|    if (IS_TZO_CHAR(*cur)) {					\
 1684|     23|	ret = _xmlSchemaParseTimeZone(&(dt->value.date), &cur);	\
 1685|     23|	if (ret == 0) {						\
 1686|     23|	    if (*cur != 0)					\
 1687|     23|		goto error;					\
 1688|     23|	    dt->type = t;					\
 1689|     23|	    goto done;						\
 1690|     23|	}							\
 1691|     23|    }
 1692|       |
 1693|     23|    if (dateTime == NULL)
  ------------------
  |  Branch (1693:9): [True: 0, False: 23]
  ------------------
 1694|      0|	return -1;
 1695|       |
 1696|     23|    if (collapse)
  ------------------
  |  Branch (1696:9): [True: 23, False: 0]
  ------------------
 1697|     23|	while IS_WSP_BLANK_CH(*cur) cur++;
 1698|       |
 1699|     23|    if ((*cur != '-') && (*cur < '0') && (*cur > '9'))
  ------------------
  |  Branch (1699:9): [True: 16, False: 7]
  |  Branch (1699:26): [True: 0, False: 16]
  |  Branch (1699:42): [True: 0, False: 0]
  ------------------
 1700|      0|	return 1;
 1701|       |
 1702|     23|    dt = xmlSchemaNewValue(XML_SCHEMAS_UNKNOWN);
 1703|     23|    if (dt == NULL)
  ------------------
  |  Branch (1703:9): [True: 0, False: 23]
  ------------------
 1704|      0|	return -1;
 1705|       |
 1706|     23|    if ((cur[0] == '-') && (cur[1] == '-')) {
  ------------------
  |  Branch (1706:9): [True: 7, False: 16]
  |  Branch (1706:28): [True: 7, False: 0]
  ------------------
 1707|       |	/*
 1708|       |	 * It's an incomplete date (xs:gMonthDay, xs:gMonth or
 1709|       |	 * xs:gDay)
 1710|       |	 */
 1711|      7|	cur += 2;
 1712|       |
 1713|       |	/* is it an xs:gDay? */
 1714|      7|	if (*cur == '-') {
  ------------------
  |  Branch (1714:6): [True: 2, False: 5]
  ------------------
 1715|      2|	    if (type == XML_SCHEMAS_GMONTH)
  ------------------
  |  Branch (1715:10): [True: 0, False: 2]
  ------------------
 1716|      0|		goto error;
 1717|      2|	  ++cur;
 1718|      2|	    ret = _xmlSchemaParseGDay(&(dt->value.date), &cur);
 1719|      2|	    if (ret != 0)
  ------------------
  |  Branch (1719:10): [True: 0, False: 2]
  ------------------
 1720|      0|		goto error;
 1721|       |
 1722|      2|	    RETURN_TYPE_IF_VALID(XML_SCHEMAS_GDAY);
  ------------------
  |  | 1683|      2|    if (IS_TZO_CHAR(*cur)) {					\
  |  |  ------------------
  |  |  |  | 1243|      2|	((c == 0) || (c == 'Z') || (c == '+') || (c == '-'))
  |  |  |  |  ------------------
  |  |  |  |  |  Branch (1243:3): [True: 2, False: 0]
  |  |  |  |  |  Branch (1243:15): [True: 0, False: 0]
  |  |  |  |  |  Branch (1243:29): [True: 0, False: 0]
  |  |  |  |  |  Branch (1243:43): [True: 0, False: 0]
  |  |  |  |  ------------------
  |  |  ------------------
  |  | 1684|      2|	ret = _xmlSchemaParseTimeZone(&(dt->value.date), &cur);	\
  |  | 1685|      2|	if (ret == 0) {						\
  |  |  ------------------
  |  |  |  Branch (1685:6): [True: 2, False: 0]
  |  |  ------------------
  |  | 1686|      2|	    if (*cur != 0)					\
  |  |  ------------------
  |  |  |  Branch (1686:10): [True: 0, False: 2]
  |  |  ------------------
  |  | 1687|      2|		goto error;					\
  |  | 1688|      2|	    dt->type = t;					\
  |  | 1689|      2|	    goto done;						\
  |  | 1690|      2|	}							\
  |  | 1691|      2|    }
  ------------------
 1723|       |
 1724|      0|	    goto error;
 1725|      2|	}
 1726|       |
 1727|       |	/*
 1728|       |	 * it should be an xs:gMonthDay or xs:gMonth
 1729|       |	 */
 1730|      5|	ret = _xmlSchemaParseGMonth(&(dt->value.date), &cur);
 1731|      5|	if (ret != 0)
  ------------------
  |  Branch (1731:6): [True: 0, False: 5]
  ------------------
 1732|      0|	    goto error;
 1733|       |
 1734|       |        /*
 1735|       |         * a '-' char could indicate this type is xs:gMonthDay or
 1736|       |         * a negative time zone offset. Check for xs:gMonthDay first.
 1737|       |         * Also the first three char's of a negative tzo (-MM:SS) can
 1738|       |         * appear to be a valid day; so even if the day portion
 1739|       |         * of the xs:gMonthDay verifies, we must insure it was not
 1740|       |         * a tzo.
 1741|       |         */
 1742|      5|        if (*cur == '-') {
  ------------------
  |  Branch (1742:13): [True: 3, False: 2]
  ------------------
 1743|      3|            const xmlChar *rewnd = cur;
 1744|      3|            cur++;
 1745|       |
 1746|      3|	    ret = _xmlSchemaParseGDay(&(dt->value.date), &cur);
 1747|      3|            if ((ret == 0) && ((*cur == 0) || (*cur != ':'))) {
  ------------------
  |  Branch (1747:17): [True: 3, False: 0]
  |  Branch (1747:32): [True: 3, False: 0]
  |  Branch (1747:47): [True: 0, False: 0]
  ------------------
 1748|       |
 1749|       |                /*
 1750|       |                 * we can use the VALID_MDAY macro to validate the month
 1751|       |                 * and day because the leap year test will flag year zero
 1752|       |                 * as a leap year (even though zero is an invalid year).
 1753|       |		 * FUTURE TODO: Zero will become valid in XML Schema 1.1
 1754|       |		 * probably.
 1755|       |                 */
 1756|      3|                if (VALID_MDAY((&(dt->value.date)))) {
  ------------------
  |  | 1265|      3|	(IS_LEAP(dt->year) ?				        \
  |  |  ------------------
  |  |  |  | 1254|      3|	(((y % 4 == 0) && (y % 100 != 0)) || (y % 400 == 0))
  |  |  |  |  ------------------
  |  |  |  |  |  Branch (1254:4): [True: 3, False: 0]
  |  |  |  |  |  Branch (1254:20): [True: 0, False: 3]
  |  |  |  |  |  Branch (1254:39): [True: 3, False: 0]
  |  |  |  |  ------------------
  |  |  ------------------
  |  |  |  Branch (1265:2): [True: 3, False: 0]
  |  |  ------------------
  |  | 1266|      3|	    (dt->day <= daysInMonthLeap[dt->mon - 1]) :	        \
  |  | 1267|      3|	    (dt->day <= daysInMonth[dt->mon - 1]))
  ------------------
 1757|       |
 1758|      3|	            RETURN_TYPE_IF_VALID(XML_SCHEMAS_GMONTHDAY);
  ------------------
  |  | 1683|      3|    if (IS_TZO_CHAR(*cur)) {					\
  |  |  ------------------
  |  |  |  | 1243|      3|	((c == 0) || (c == 'Z') || (c == '+') || (c == '-'))
  |  |  |  |  ------------------
  |  |  |  |  |  Branch (1243:3): [True: 3, False: 0]
  |  |  |  |  |  Branch (1243:15): [True: 0, False: 0]
  |  |  |  |  |  Branch (1243:29): [True: 0, False: 0]
  |  |  |  |  |  Branch (1243:43): [True: 0, False: 0]
  |  |  |  |  ------------------
  |  |  ------------------
  |  | 1684|      3|	ret = _xmlSchemaParseTimeZone(&(dt->value.date), &cur);	\
  |  | 1685|      3|	if (ret == 0) {						\
  |  |  ------------------
  |  |  |  Branch (1685:6): [True: 3, False: 0]
  |  |  ------------------
  |  | 1686|      3|	    if (*cur != 0)					\
  |  |  ------------------
  |  |  |  Branch (1686:10): [True: 0, False: 3]
  |  |  ------------------
  |  | 1687|      3|		goto error;					\
  |  | 1688|      3|	    dt->type = t;					\
  |  | 1689|      3|	    goto done;						\
  |  | 1690|      3|	}							\
  |  | 1691|      3|    }
  ------------------
 1759|       |
 1760|      0|                    goto error;
 1761|      3|                }
 1762|      3|            }
 1763|       |
 1764|       |            /*
 1765|       |             * not xs:gMonthDay so rewind and check if just xs:gMonth
 1766|       |             * with an optional time zone.
 1767|       |             */
 1768|      0|            cur = rewnd;
 1769|      0|        }
 1770|       |
 1771|      2|	RETURN_TYPE_IF_VALID(XML_SCHEMAS_GMONTH);
  ------------------
  |  | 1683|      2|    if (IS_TZO_CHAR(*cur)) {					\
  |  |  ------------------
  |  |  |  | 1243|      2|	((c == 0) || (c == 'Z') || (c == '+') || (c == '-'))
  |  |  |  |  ------------------
  |  |  |  |  |  Branch (1243:3): [True: 0, False: 2]
  |  |  |  |  |  Branch (1243:15): [True: 2, False: 0]
  |  |  |  |  |  Branch (1243:29): [True: 0, False: 0]
  |  |  |  |  |  Branch (1243:43): [True: 0, False: 0]
  |  |  |  |  ------------------
  |  |  ------------------
  |  | 1684|      2|	ret = _xmlSchemaParseTimeZone(&(dt->value.date), &cur);	\
  |  | 1685|      2|	if (ret == 0) {						\
  |  |  ------------------
  |  |  |  Branch (1685:6): [True: 2, False: 0]
  |  |  ------------------
  |  | 1686|      2|	    if (*cur != 0)					\
  |  |  ------------------
  |  |  |  Branch (1686:10): [True: 0, False: 2]
  |  |  ------------------
  |  | 1687|      2|		goto error;					\
  |  | 1688|      2|	    dt->type = t;					\
  |  | 1689|      2|	    goto done;						\
  |  | 1690|      2|	}							\
  |  | 1691|      2|    }
  ------------------
 1772|       |
 1773|      0|	goto error;
 1774|      2|    }
 1775|       |
 1776|       |    /*
 1777|       |     * It's a right-truncated date or an xs:time.
 1778|       |     * Try to parse an xs:time then fallback on right-truncated dates.
 1779|       |     */
 1780|     16|    if ((*cur >= '0') && (*cur <= '9')) {
  ------------------
  |  Branch (1780:9): [True: 16, False: 0]
  |  Branch (1780:26): [True: 16, False: 0]
  ------------------
 1781|     16|	ret = _xmlSchemaParseTime(&(dt->value.date), &cur);
 1782|     16|	if (ret == 0) {
  ------------------
  |  Branch (1782:6): [True: 4, False: 12]
  ------------------
 1783|       |	    /* it's an xs:time */
 1784|      4|	    RETURN_TYPE_IF_VALID(XML_SCHEMAS_TIME);
  ------------------
  |  | 1683|      4|    if (IS_TZO_CHAR(*cur)) {					\
  |  |  ------------------
  |  |  |  | 1243|      4|	((c == 0) || (c == 'Z') || (c == '+') || (c == '-'))
  |  |  |  |  ------------------
  |  |  |  |  |  Branch (1243:3): [True: 4, False: 0]
  |  |  |  |  |  Branch (1243:15): [True: 0, False: 0]
  |  |  |  |  |  Branch (1243:29): [True: 0, False: 0]
  |  |  |  |  |  Branch (1243:43): [True: 0, False: 0]
  |  |  |  |  ------------------
  |  |  ------------------
  |  | 1684|      4|	ret = _xmlSchemaParseTimeZone(&(dt->value.date), &cur);	\
  |  | 1685|      4|	if (ret == 0) {						\
  |  |  ------------------
  |  |  |  Branch (1685:6): [True: 4, False: 0]
  |  |  ------------------
  |  | 1686|      4|	    if (*cur != 0)					\
  |  |  ------------------
  |  |  |  Branch (1686:10): [True: 0, False: 4]
  |  |  ------------------
  |  | 1687|      4|		goto error;					\
  |  | 1688|      4|	    dt->type = t;					\
  |  | 1689|      4|	    goto done;						\
  |  | 1690|      4|	}							\
  |  | 1691|      4|    }
  ------------------
 1785|      0|	}
 1786|     16|    }
 1787|       |
 1788|       |    /* fallback on date parsing */
 1789|     12|    cur = dateTime;
 1790|       |
 1791|     12|    ret = _xmlSchemaParseGYear(&(dt->value.date), &cur);
 1792|     12|    if (ret != 0)
  ------------------
  |  Branch (1792:9): [True: 0, False: 12]
  ------------------
 1793|      0|	goto error;
 1794|       |
 1795|       |    /* is it an xs:gYear? */
 1796|     12|    RETURN_TYPE_IF_VALID(XML_SCHEMAS_GYEAR);
  ------------------
  |  | 1683|     12|    if (IS_TZO_CHAR(*cur)) {					\
  |  |  ------------------
  |  |  |  | 1243|     12|	((c == 0) || (c == 'Z') || (c == '+') || (c == '-'))
  |  |  |  |  ------------------
  |  |  |  |  |  Branch (1243:3): [True: 0, False: 12]
  |  |  |  |  |  Branch (1243:15): [True: 2, False: 10]
  |  |  |  |  |  Branch (1243:29): [True: 0, False: 10]
  |  |  |  |  |  Branch (1243:43): [True: 10, False: 0]
  |  |  |  |  ------------------
  |  |  ------------------
  |  | 1684|     12|	ret = _xmlSchemaParseTimeZone(&(dt->value.date), &cur);	\
  |  | 1685|     12|	if (ret == 0) {						\
  |  |  ------------------
  |  |  |  Branch (1685:6): [True: 2, False: 10]
  |  |  ------------------
  |  | 1686|      2|	    if (*cur != 0)					\
  |  |  ------------------
  |  |  |  Branch (1686:10): [True: 0, False: 2]
  |  |  ------------------
  |  | 1687|      2|		goto error;					\
  |  | 1688|      2|	    dt->type = t;					\
  |  | 1689|      2|	    goto done;						\
  |  | 1690|      2|	}							\
  |  | 1691|     12|    }
  ------------------
 1797|       |
 1798|     10|    if (*cur != '-')
  ------------------
  |  Branch (1798:9): [True: 0, False: 10]
  ------------------
 1799|      0|	goto error;
 1800|     10|    cur++;
 1801|       |
 1802|     10|    ret = _xmlSchemaParseGMonth(&(dt->value.date), &cur);
 1803|     10|    if (ret != 0)
  ------------------
  |  Branch (1803:9): [True: 0, False: 10]
  ------------------
 1804|      0|	goto error;
 1805|       |
 1806|       |    /* is it an xs:gYearMonth? */
 1807|     10|    RETURN_TYPE_IF_VALID(XML_SCHEMAS_GYEARMONTH);
  ------------------
  |  | 1683|     10|    if (IS_TZO_CHAR(*cur)) {					\
  |  |  ------------------
  |  |  |  | 1243|     10|	((c == 0) || (c == 'Z') || (c == '+') || (c == '-'))
  |  |  |  |  ------------------
  |  |  |  |  |  Branch (1243:3): [True: 0, False: 10]
  |  |  |  |  |  Branch (1243:15): [True: 2, False: 8]
  |  |  |  |  |  Branch (1243:29): [True: 0, False: 8]
  |  |  |  |  |  Branch (1243:43): [True: 8, False: 0]
  |  |  |  |  ------------------
  |  |  ------------------
  |  | 1684|     10|	ret = _xmlSchemaParseTimeZone(&(dt->value.date), &cur);	\
  |  | 1685|     10|	if (ret == 0) {						\
  |  |  ------------------
  |  |  |  Branch (1685:6): [True: 2, False: 8]
  |  |  ------------------
  |  | 1686|      2|	    if (*cur != 0)					\
  |  |  ------------------
  |  |  |  Branch (1686:10): [True: 0, False: 2]
  |  |  ------------------
  |  | 1687|      2|		goto error;					\
  |  | 1688|      2|	    dt->type = t;					\
  |  | 1689|      2|	    goto done;						\
  |  | 1690|      2|	}							\
  |  | 1691|     10|    }
  ------------------
 1808|       |
 1809|      8|    if (*cur != '-')
  ------------------
  |  Branch (1809:9): [True: 0, False: 8]
  ------------------
 1810|      0|	goto error;
 1811|      8|    cur++;
 1812|       |
 1813|      8|    ret = _xmlSchemaParseGDay(&(dt->value.date), &cur);
 1814|      8|    if ((ret != 0) || !VALID_DATE((&(dt->value.date))))
  ------------------
  |  | 1270|      8|	(VALID_YEAR(dt->year) && VALID_MONTH(dt->mon) && VALID_MDAY(dt))
  |  |  ------------------
  |  |  |  | 1245|     16|#define VALID_YEAR(yr)          (yr != 0)
  |  |  |  |  ------------------
  |  |  |  |  |  Branch (1245:33): [True: 8, False: 0]
  |  |  |  |  ------------------
  |  |  ------------------
  |  |               	(VALID_YEAR(dt->year) && VALID_MONTH(dt->mon) && VALID_MDAY(dt))
  |  |  ------------------
  |  |  |  | 1246|     16|#define VALID_MONTH(mon)        ((mon >= 1) && (mon <= 12))
  |  |  |  |  ------------------
  |  |  |  |  |  Branch (1246:34): [True: 8, False: 0]
  |  |  |  |  |  Branch (1246:48): [True: 8, False: 0]
  |  |  |  |  ------------------
  |  |  ------------------
  |  |               	(VALID_YEAR(dt->year) && VALID_MONTH(dt->mon) && VALID_MDAY(dt))
  |  |  ------------------
  |  |  |  | 1265|      8|	(IS_LEAP(dt->year) ?				        \
  |  |  |  |  ------------------
  |  |  |  |  |  | 1254|      8|	(((y % 4 == 0) && (y % 100 != 0)) || (y % 400 == 0))
  |  |  |  |  |  |  ------------------
  |  |  |  |  |  |  |  Branch (1254:4): [True: 3, False: 5]
  |  |  |  |  |  |  |  Branch (1254:20): [True: 3, False: 0]
  |  |  |  |  |  |  |  Branch (1254:39): [True: 0, False: 5]
  |  |  |  |  |  |  ------------------
  |  |  |  |  ------------------
  |  |  |  |  |  Branch (1265:2): [True: 8, False: 0]
  |  |  |  |  ------------------
  |  |  |  | 1266|      8|	    (dt->day <= daysInMonthLeap[dt->mon - 1]) :	        \
  |  |  |  | 1267|      8|	    (dt->day <= daysInMonth[dt->mon - 1]))
  |  |  ------------------
  ------------------
  |  Branch (1814:9): [True: 0, False: 8]
  ------------------
 1815|      0|	goto error;
 1816|       |
 1817|       |    /* is it an xs:date? */
 1818|      8|    RETURN_TYPE_IF_VALID(XML_SCHEMAS_DATE);
  ------------------
  |  | 1683|      8|    if (IS_TZO_CHAR(*cur)) {					\
  |  |  ------------------
  |  |  |  | 1243|      8|	((c == 0) || (c == 'Z') || (c == '+') || (c == '-'))
  |  |  |  |  ------------------
  |  |  |  |  |  Branch (1243:3): [True: 2, False: 6]
  |  |  |  |  |  Branch (1243:15): [True: 2, False: 4]
  |  |  |  |  |  Branch (1243:29): [True: 0, False: 4]
  |  |  |  |  |  Branch (1243:43): [True: 0, False: 4]
  |  |  |  |  ------------------
  |  |  ------------------
  |  | 1684|      4|	ret = _xmlSchemaParseTimeZone(&(dt->value.date), &cur);	\
  |  | 1685|      4|	if (ret == 0) {						\
  |  |  ------------------
  |  |  |  Branch (1685:6): [True: 4, False: 0]
  |  |  ------------------
  |  | 1686|      4|	    if (*cur != 0)					\
  |  |  ------------------
  |  |  |  Branch (1686:10): [True: 0, False: 4]
  |  |  ------------------
  |  | 1687|      4|		goto error;					\
  |  | 1688|      4|	    dt->type = t;					\
  |  | 1689|      4|	    goto done;						\
  |  | 1690|      4|	}							\
  |  | 1691|      4|    }
  ------------------
 1819|       |
 1820|      4|    if (*cur != 'T')
  ------------------
  |  Branch (1820:9): [True: 0, False: 4]
  ------------------
 1821|      0|	goto error;
 1822|      4|    cur++;
 1823|       |
 1824|       |    /* it should be an xs:dateTime */
 1825|      4|    ret = _xmlSchemaParseTime(&(dt->value.date), &cur);
 1826|      4|    if (ret != 0)
  ------------------
  |  Branch (1826:9): [True: 0, False: 4]
  ------------------
 1827|      0|	goto error;
 1828|       |
 1829|      4|    ret = _xmlSchemaParseTimeZone(&(dt->value.date), &cur);
 1830|      4|    if (collapse)
  ------------------
  |  Branch (1830:9): [True: 4, False: 0]
  ------------------
 1831|      4|	while IS_WSP_BLANK_CH(*cur) cur++;
 1832|      4|    if ((ret != 0) || (*cur != 0) || (!(VALID_DATETIME((&(dt->value.date))))))
  ------------------
  |  | 1281|      4|	(VALID_DATE(dt) && VALID_TIME(dt))
  |  |  ------------------
  |  |  |  | 1270|      8|	(VALID_YEAR(dt->year) && VALID_MONTH(dt->mon) && VALID_MDAY(dt))
  |  |  |  |  ------------------
  |  |  |  |  |  | 1245|      8|#define VALID_YEAR(yr)          (yr != 0)
  |  |  |  |  |  |  ------------------
  |  |  |  |  |  |  |  Branch (1245:33): [True: 4, False: 0]
  |  |  |  |  |  |  ------------------
  |  |  |  |  ------------------
  |  |  |  |               	(VALID_YEAR(dt->year) && VALID_MONTH(dt->mon) && VALID_MDAY(dt))
  |  |  |  |  ------------------
  |  |  |  |  |  | 1246|      8|#define VALID_MONTH(mon)        ((mon >= 1) && (mon <= 12))
  |  |  |  |  |  |  ------------------
  |  |  |  |  |  |  |  Branch (1246:34): [True: 4, False: 0]
  |  |  |  |  |  |  |  Branch (1246:48): [True: 4, False: 0]
  |  |  |  |  |  |  ------------------
  |  |  |  |  ------------------
  |  |  |  |               	(VALID_YEAR(dt->year) && VALID_MONTH(dt->mon) && VALID_MDAY(dt))
  |  |  |  |  ------------------
  |  |  |  |  |  | 1265|      4|	(IS_LEAP(dt->year) ?				        \
  |  |  |  |  |  |  ------------------
  |  |  |  |  |  |  |  | 1254|      4|	(((y % 4 == 0) && (y % 100 != 0)) || (y % 400 == 0))
  |  |  |  |  |  |  |  |  ------------------
  |  |  |  |  |  |  |  |  |  Branch (1254:4): [True: 1, False: 3]
  |  |  |  |  |  |  |  |  |  Branch (1254:20): [True: 1, False: 0]
  |  |  |  |  |  |  |  |  |  Branch (1254:39): [True: 0, False: 3]
  |  |  |  |  |  |  |  |  ------------------
  |  |  |  |  |  |  ------------------
  |  |  |  |  |  |  |  Branch (1265:2): [True: 4, False: 0]
  |  |  |  |  |  |  ------------------
  |  |  |  |  |  | 1266|      4|	    (dt->day <= daysInMonthLeap[dt->mon - 1]) :	        \
  |  |  |  |  |  | 1267|      4|	    (dt->day <= daysInMonth[dt->mon - 1]))
  |  |  |  |  ------------------
  |  |  ------------------
  |  |               	(VALID_DATE(dt) && VALID_TIME(dt))
  |  |  ------------------
  |  |  |  | 1276|      4|	(((VALID_HOUR(dt->hour) && VALID_MIN(dt->min) &&	\
  |  |  |  |  ------------------
  |  |  |  |  |  | 1249|      8|#define VALID_HOUR(hr)          ((hr >= 0) && (hr <= 23))
  |  |  |  |  |  |  ------------------
  |  |  |  |  |  |  |  Branch (1249:34): [True: 4, False: 0]
  |  |  |  |  |  |  |  Branch (1249:47): [True: 4, False: 0]
  |  |  |  |  |  |  ------------------
  |  |  |  |  ------------------
  |  |  |  |               	(((VALID_HOUR(dt->hour) && VALID_MIN(dt->min) &&	\
  |  |  |  |  ------------------
  |  |  |  |  |  | 1250|      8|#define VALID_MIN(min)          ((min >= 0) && (min <= 59))
  |  |  |  |  |  |  ------------------
  |  |  |  |  |  |  |  Branch (1250:34): [True: 4, False: 0]
  |  |  |  |  |  |  |  Branch (1250:48): [True: 4, False: 0]
  |  |  |  |  |  |  ------------------
  |  |  |  |  ------------------
  |  |  |  | 1277|      4|	  VALID_SEC(dt->sec)) || VALID_END_OF_DAY(dt)) &&	\
  |  |  |  |  ------------------
  |  |  |  |  |  | 1251|      4|#define VALID_SEC(sec)          ((sec >= 0) && (sec < 60))
  |  |  |  |  |  |  ------------------
  |  |  |  |  |  |  |  Branch (1251:34): [True: 4, False: 0]
  |  |  |  |  |  |  |  Branch (1251:48): [True: 4, False: 0]
  |  |  |  |  |  |  ------------------
  |  |  |  |  ------------------
  |  |  |  |               	  VALID_SEC(dt->sec)) || VALID_END_OF_DAY(dt)) &&	\
  |  |  |  |  ------------------
  |  |  |  |  |  | 1273|      0|	((dt)->hour == 24 && (dt)->min == 0 && (dt)->sec == 0)
  |  |  |  |  |  |  ------------------
  |  |  |  |  |  |  |  Branch (1273:3): [True: 0, False: 0]
  |  |  |  |  |  |  |  Branch (1273:23): [True: 0, False: 0]
  |  |  |  |  |  |  |  Branch (1273:41): [True: 0, False: 0]
  |  |  |  |  |  |  ------------------
  |  |  |  |  ------------------
  |  |  |  | 1278|      4|	 VALID_TZO(dt->tzo))
  |  |  |  |  ------------------
  |  |  |  |  |  | 1252|      4|#define VALID_TZO(tzo)          ((tzo >= -840) && (tzo <= 840))
  |  |  |  |  |  |  ------------------
  |  |  |  |  |  |  |  Branch (1252:34): [True: 4, False: 0]
  |  |  |  |  |  |  |  Branch (1252:51): [True: 4, False: 0]
  |  |  |  |  |  |  ------------------
  |  |  |  |  ------------------
  |  |  ------------------
  ------------------
  |  Branch (1832:9): [True: 0, False: 4]
  |  Branch (1832:23): [True: 0, False: 4]
  ------------------
 1833|      0|	goto error;
 1834|       |
 1835|       |
 1836|      4|    dt->type = XML_SCHEMAS_DATETIME;
 1837|       |
 1838|     23|done:
 1839|     23|#if 1
 1840|     23|    if ((type != XML_SCHEMAS_UNKNOWN) && (type != dt->type))
  ------------------
  |  Branch (1840:9): [True: 23, False: 0]
  |  Branch (1840:42): [True: 0, False: 23]
  ------------------
 1841|      0|        goto error;
 1842|       |#else
 1843|       |    /*
 1844|       |     * insure the parsed type is equal to or less significant (right
 1845|       |     * truncated) than the desired type.
 1846|       |     */
 1847|       |    if ((type != XML_SCHEMAS_UNKNOWN) && (type != dt->type)) {
 1848|       |
 1849|       |        /* time only matches time */
 1850|       |        if ((type == XML_SCHEMAS_TIME) && (dt->type == XML_SCHEMAS_TIME))
 1851|       |            goto error;
 1852|       |
 1853|       |        if ((type == XML_SCHEMAS_DATETIME) &&
 1854|       |            ((dt->type != XML_SCHEMAS_DATE) ||
 1855|       |             (dt->type != XML_SCHEMAS_GYEARMONTH) ||
 1856|       |             (dt->type != XML_SCHEMAS_GYEAR)))
 1857|       |            goto error;
 1858|       |
 1859|       |        if ((type == XML_SCHEMAS_DATE) &&
 1860|       |            ((dt->type != XML_SCHEMAS_GYEAR) ||
 1861|       |             (dt->type != XML_SCHEMAS_GYEARMONTH)))
 1862|       |            goto error;
 1863|       |
 1864|       |        if ((type == XML_SCHEMAS_GYEARMONTH) && (dt->type != XML_SCHEMAS_GYEAR))
 1865|       |            goto error;
 1866|       |
 1867|       |        if ((type == XML_SCHEMAS_GMONTHDAY) && (dt->type != XML_SCHEMAS_GMONTH))
 1868|       |            goto error;
 1869|       |    }
 1870|       |#endif
 1871|       |
 1872|     23|    if (val != NULL)
  ------------------
  |  Branch (1872:9): [True: 23, False: 0]
  ------------------
 1873|     23|        *val = dt;
 1874|      0|    else
 1875|      0|	xmlSchemaFreeValue(dt);
 1876|       |
 1877|     23|    return 0;
 1878|       |
 1879|      0|error:
 1880|      0|    if (dt != NULL)
  ------------------
  |  Branch (1880:9): [True: 0, False: 0]
  ------------------
 1881|      0|	xmlSchemaFreeValue(dt);
 1882|      0|    return 1;
 1883|     23|}
xmlschemastypes.c:_xmlSchemaParseGDay:
 1443|     13|_xmlSchemaParseGDay (xmlSchemaValDatePtr dt, const xmlChar **str) {
 1444|     13|    const xmlChar *cur = *str;
 1445|     13|    int ret = 0;
 1446|     13|    unsigned int value = 0;
 1447|       |
 1448|     13|    PARSE_2_DIGITS(value, cur, ret);
  ------------------
  |  | 1368|     13|	if ((cur[0] < '0') || (cur[0] > '9') ||			\
  |  |  ------------------
  |  |  |  Branch (1368:6): [True: 0, False: 13]
  |  |  |  Branch (1368:24): [True: 0, False: 13]
  |  |  ------------------
  |  | 1369|     13|	    (cur[1] < '0') || (cur[1] > '9'))			\
  |  |  ------------------
  |  |  |  Branch (1369:6): [True: 0, False: 13]
  |  |  |  Branch (1369:24): [True: 0, False: 13]
  |  |  ------------------
  |  | 1370|     13|	    invalid = 1;					\
  |  | 1371|     13|	else							\
  |  | 1372|     13|	    num = (cur[0] - '0') * 10 + (cur[1] - '0');		\
  |  | 1373|     13|	cur += 2;
  ------------------
 1449|     13|    if (ret != 0)
  ------------------
  |  Branch (1449:9): [True: 0, False: 13]
  ------------------
 1450|      0|	return ret;
 1451|       |
 1452|     13|    if (!VALID_DAY(value))
  ------------------
  |  | 1248|     13|#define VALID_DAY(day)          ((day >= 1) && (day <= 31))
  |  |  ------------------
  |  |  |  Branch (1248:34): [True: 13, False: 0]
  |  |  |  Branch (1248:48): [True: 13, False: 0]
  |  |  ------------------
  ------------------
 1453|      0|	return 2;
 1454|       |
 1455|     13|    dt->day = value;
 1456|     13|    *str = cur;
 1457|     13|    return 0;
 1458|     13|}
xmlschemastypes.c:_xmlSchemaParseTimeZone:
 1524|     41|_xmlSchemaParseTimeZone (xmlSchemaValDatePtr dt, const xmlChar **str) {
 1525|     41|    const xmlChar *cur;
 1526|     41|    int ret = 0;
 1527|       |
 1528|     41|    if (str == NULL)
  ------------------
  |  Branch (1528:9): [True: 0, False: 41]
  ------------------
 1529|      0|	return -1;
 1530|     41|    cur = *str;
 1531|       |
 1532|     41|    switch (*cur) {
 1533|     11|    case 0:
  ------------------
  |  Branch (1533:5): [True: 11, False: 30]
  ------------------
 1534|     11|	dt->tz_flag = 0;
 1535|     11|	dt->tzo = 0;
 1536|     11|	break;
 1537|       |
 1538|     12|    case 'Z':
  ------------------
  |  Branch (1538:5): [True: 12, False: 29]
  ------------------
 1539|     12|	dt->tz_flag = 1;
 1540|     12|	dt->tzo = 0;
 1541|     12|	cur++;
 1542|     12|	break;
 1543|       |
 1544|      0|    case '+':
  ------------------
  |  Branch (1544:5): [True: 0, False: 41]
  ------------------
 1545|     18|    case '-': {
  ------------------
  |  Branch (1545:5): [True: 18, False: 23]
  ------------------
 1546|     18|	int isneg = 0, tmp = 0;
 1547|     18|	isneg = (*cur == '-');
 1548|       |
 1549|     18|	cur++;
 1550|       |
 1551|     18|	PARSE_2_DIGITS(tmp, cur, ret);
  ------------------
  |  | 1368|     18|	if ((cur[0] < '0') || (cur[0] > '9') ||			\
  |  |  ------------------
  |  |  |  Branch (1368:6): [True: 0, False: 18]
  |  |  |  Branch (1368:24): [True: 0, False: 18]
  |  |  ------------------
  |  | 1369|     18|	    (cur[1] < '0') || (cur[1] > '9'))			\
  |  |  ------------------
  |  |  |  Branch (1369:6): [True: 0, False: 18]
  |  |  |  Branch (1369:24): [True: 0, False: 18]
  |  |  ------------------
  |  | 1370|     18|	    invalid = 1;					\
  |  | 1371|     18|	else							\
  |  | 1372|     18|	    num = (cur[0] - '0') * 10 + (cur[1] - '0');		\
  |  | 1373|     18|	cur += 2;
  ------------------
 1552|     18|	if (ret != 0)
  ------------------
  |  Branch (1552:6): [True: 0, False: 18]
  ------------------
 1553|      0|	    return ret;
 1554|     18|	if (!VALID_HOUR(tmp))
  ------------------
  |  | 1249|     18|#define VALID_HOUR(hr)          ((hr >= 0) && (hr <= 23))
  |  |  ------------------
  |  |  |  Branch (1249:34): [True: 18, False: 0]
  |  |  |  Branch (1249:47): [True: 18, False: 0]
  |  |  ------------------
  ------------------
 1555|      0|	    return 2;
 1556|       |
 1557|     18|	if (*cur != ':')
  ------------------
  |  Branch (1557:6): [True: 18, False: 0]
  ------------------
 1558|     18|	    return 1;
 1559|      0|	cur++;
 1560|       |
 1561|      0|	dt->tzo = tmp * 60;
 1562|       |
 1563|      0|	PARSE_2_DIGITS(tmp, cur, ret);
  ------------------
  |  | 1368|      0|	if ((cur[0] < '0') || (cur[0] > '9') ||			\
  |  |  ------------------
  |  |  |  Branch (1368:6): [True: 0, False: 0]
  |  |  |  Branch (1368:24): [True: 0, False: 0]
  |  |  ------------------
  |  | 1369|      0|	    (cur[1] < '0') || (cur[1] > '9'))			\
  |  |  ------------------
  |  |  |  Branch (1369:6): [True: 0, False: 0]
  |  |  |  Branch (1369:24): [True: 0, False: 0]
  |  |  ------------------
  |  | 1370|      0|	    invalid = 1;					\
  |  | 1371|      0|	else							\
  |  | 1372|      0|	    num = (cur[0] - '0') * 10 + (cur[1] - '0');		\
  |  | 1373|      0|	cur += 2;
  ------------------
 1564|      0|	if (ret != 0)
  ------------------
  |  Branch (1564:6): [True: 0, False: 0]
  ------------------
 1565|      0|	    return ret;
 1566|      0|	if (!VALID_MIN(tmp))
  ------------------
  |  | 1250|      0|#define VALID_MIN(min)          ((min >= 0) && (min <= 59))
  |  |  ------------------
  |  |  |  Branch (1250:34): [True: 0, False: 0]
  |  |  |  Branch (1250:48): [True: 0, False: 0]
  |  |  ------------------
  ------------------
 1567|      0|	    return 2;
 1568|       |
 1569|      0|	dt->tzo += tmp;
 1570|      0|	if (isneg)
  ------------------
  |  Branch (1570:6): [True: 0, False: 0]
  ------------------
 1571|      0|	    dt->tzo = - dt->tzo;
 1572|       |
 1573|      0|	if (!VALID_TZO(dt->tzo))
  ------------------
  |  | 1252|      0|#define VALID_TZO(tzo)          ((tzo >= -840) && (tzo <= 840))
  |  |  ------------------
  |  |  |  Branch (1252:34): [True: 0, False: 0]
  |  |  |  Branch (1252:51): [True: 0, False: 0]
  |  |  ------------------
  ------------------
 1574|      0|	    return 2;
 1575|       |
 1576|      0|	dt->tz_flag = 1;
 1577|      0|	break;
 1578|      0|      }
 1579|      0|    default:
  ------------------
  |  Branch (1579:5): [True: 0, False: 41]
  ------------------
 1580|      0|	return 1;
 1581|     41|    }
 1582|       |
 1583|     23|    *str = cur;
 1584|     23|    return 0;
 1585|     41|}
xmlschemastypes.c:_xmlSchemaParseGMonth:
 1413|     15|_xmlSchemaParseGMonth (xmlSchemaValDatePtr dt, const xmlChar **str) {
 1414|     15|    const xmlChar *cur = *str;
 1415|     15|    int ret = 0;
 1416|     15|    unsigned int value = 0;
 1417|       |
 1418|     15|    PARSE_2_DIGITS(value, cur, ret);
  ------------------
  |  | 1368|     15|	if ((cur[0] < '0') || (cur[0] > '9') ||			\
  |  |  ------------------
  |  |  |  Branch (1368:6): [True: 0, False: 15]
  |  |  |  Branch (1368:24): [True: 0, False: 15]
  |  |  ------------------
  |  | 1369|     15|	    (cur[1] < '0') || (cur[1] > '9'))			\
  |  |  ------------------
  |  |  |  Branch (1369:6): [True: 0, False: 15]
  |  |  |  Branch (1369:24): [True: 0, False: 15]
  |  |  ------------------
  |  | 1370|     15|	    invalid = 1;					\
  |  | 1371|     15|	else							\
  |  | 1372|     15|	    num = (cur[0] - '0') * 10 + (cur[1] - '0');		\
  |  | 1373|     15|	cur += 2;
  ------------------
 1419|     15|    if (ret != 0)
  ------------------
  |  Branch (1419:9): [True: 0, False: 15]
  ------------------
 1420|      0|	return ret;
 1421|       |
 1422|     15|    if (!VALID_MONTH(value))
  ------------------
  |  | 1246|     15|#define VALID_MONTH(mon)        ((mon >= 1) && (mon <= 12))
  |  |  ------------------
  |  |  |  Branch (1246:34): [True: 15, False: 0]
  |  |  |  Branch (1246:48): [True: 15, False: 0]
  |  |  ------------------
  ------------------
 1423|      0|	return 2;
 1424|       |
 1425|     15|    dt->mon = value;
 1426|       |
 1427|     15|    *str = cur;
 1428|     15|    return 0;
 1429|     15|}
xmlschemastypes.c:_xmlSchemaParseTime:
 1473|     20|_xmlSchemaParseTime (xmlSchemaValDatePtr dt, const xmlChar **str) {
 1474|     20|    const xmlChar *cur = *str;
 1475|     20|    int ret = 0;
 1476|     20|    int value = 0;
 1477|       |
 1478|     20|    PARSE_2_DIGITS(value, cur, ret);
  ------------------
  |  | 1368|     20|	if ((cur[0] < '0') || (cur[0] > '9') ||			\
  |  |  ------------------
  |  |  |  Branch (1368:6): [True: 0, False: 20]
  |  |  |  Branch (1368:24): [True: 0, False: 20]
  |  |  ------------------
  |  | 1369|     20|	    (cur[1] < '0') || (cur[1] > '9'))			\
  |  |  ------------------
  |  |  |  Branch (1369:6): [True: 0, False: 20]
  |  |  |  Branch (1369:24): [True: 0, False: 20]
  |  |  ------------------
  |  | 1370|     20|	    invalid = 1;					\
  |  | 1371|     20|	else							\
  |  | 1372|     20|	    num = (cur[0] - '0') * 10 + (cur[1] - '0');		\
  |  | 1373|     20|	cur += 2;
  ------------------
 1479|     20|    if (ret != 0)
  ------------------
  |  Branch (1479:9): [True: 0, False: 20]
  ------------------
 1480|      0|	return ret;
 1481|     20|    if (*cur != ':')
  ------------------
  |  Branch (1481:9): [True: 12, False: 8]
  ------------------
 1482|     12|	return 1;
 1483|      8|    if (!VALID_HOUR(value) && value != 24 /* Allow end-of-day hour */)
  ------------------
  |  | 1249|     16|#define VALID_HOUR(hr)          ((hr >= 0) && (hr <= 23))
  |  |  ------------------
  |  |  |  Branch (1249:34): [True: 8, False: 0]
  |  |  |  Branch (1249:47): [True: 8, False: 0]
  |  |  ------------------
  ------------------
  |  Branch (1483:31): [True: 0, False: 0]
  ------------------
 1484|      0|	return 2;
 1485|      8|    cur++;
 1486|       |
 1487|       |    /* the ':' insures this string is xs:time */
 1488|      8|    dt->hour = value;
 1489|       |
 1490|      8|    PARSE_2_DIGITS(value, cur, ret);
  ------------------
  |  | 1368|      8|	if ((cur[0] < '0') || (cur[0] > '9') ||			\
  |  |  ------------------
  |  |  |  Branch (1368:6): [True: 0, False: 8]
  |  |  |  Branch (1368:24): [True: 0, False: 8]
  |  |  ------------------
  |  | 1369|      8|	    (cur[1] < '0') || (cur[1] > '9'))			\
  |  |  ------------------
  |  |  |  Branch (1369:6): [True: 0, False: 8]
  |  |  |  Branch (1369:24): [True: 0, False: 8]
  |  |  ------------------
  |  | 1370|      8|	    invalid = 1;					\
  |  | 1371|      8|	else							\
  |  | 1372|      8|	    num = (cur[0] - '0') * 10 + (cur[1] - '0');		\
  |  | 1373|      8|	cur += 2;
  ------------------
 1491|      8|    if (ret != 0)
  ------------------
  |  Branch (1491:9): [True: 0, False: 8]
  ------------------
 1492|      0|	return ret;
 1493|      8|    if (!VALID_MIN(value))
  ------------------
  |  | 1250|      8|#define VALID_MIN(min)          ((min >= 0) && (min <= 59))
  |  |  ------------------
  |  |  |  Branch (1250:34): [True: 8, False: 0]
  |  |  |  Branch (1250:48): [True: 8, False: 0]
  |  |  ------------------
  ------------------
 1494|      0|	return 2;
 1495|      8|    dt->min = value;
 1496|       |
 1497|      8|    if (*cur != ':')
  ------------------
  |  Branch (1497:9): [True: 0, False: 8]
  ------------------
 1498|      0|	return 1;
 1499|      8|    cur++;
 1500|       |
 1501|      8|    PARSE_FLOAT(dt->sec, cur, ret);
  ------------------
  |  | 1388|      8|	PARSE_2_DIGITS(num, cur, invalid);			\
  |  |  ------------------
  |  |  |  | 1368|      8|	if ((cur[0] < '0') || (cur[0] > '9') ||			\
  |  |  |  |  ------------------
  |  |  |  |  |  Branch (1368:6): [True: 0, False: 8]
  |  |  |  |  |  Branch (1368:24): [True: 0, False: 8]
  |  |  |  |  ------------------
  |  |  |  | 1369|      8|	    (cur[1] < '0') || (cur[1] > '9'))			\
  |  |  |  |  ------------------
  |  |  |  |  |  Branch (1369:6): [True: 0, False: 8]
  |  |  |  |  |  Branch (1369:24): [True: 0, False: 8]
  |  |  |  |  ------------------
  |  |  |  | 1370|      8|	    invalid = 1;					\
  |  |  |  | 1371|      8|	else							\
  |  |  |  | 1372|      8|	    num = (cur[0] - '0') * 10 + (cur[1] - '0');		\
  |  |  |  | 1373|      8|	cur += 2;
  |  |  ------------------
  |  | 1389|      8|	if (!invalid && (*cur == '.')) {			\
  |  |  ------------------
  |  |  |  Branch (1389:6): [True: 8, False: 0]
  |  |  |  Branch (1389:18): [True: 1, False: 7]
  |  |  ------------------
  |  | 1390|      1|	    double mult = 1;				        \
  |  | 1391|      1|	    cur++;						\
  |  | 1392|      1|	    if ((*cur < '0') || (*cur > '9'))			\
  |  |  ------------------
  |  |  |  Branch (1392:10): [True: 0, False: 1]
  |  |  |  Branch (1392:26): [True: 0, False: 1]
  |  |  ------------------
  |  | 1393|      1|		invalid = 1;					\
  |  | 1394|      8|	    while ((*cur >= '0') && (*cur <= '9')) {		\
  |  |  ------------------
  |  |  |  Branch (1394:13): [True: 7, False: 1]
  |  |  |  Branch (1394:30): [True: 7, False: 0]
  |  |  ------------------
  |  | 1395|      7|		mult /= 10;					\
  |  | 1396|      7|		num += (*cur - '0') * mult;			\
  |  | 1397|      7|		cur++;						\
  |  | 1398|      7|	    }							\
  |  | 1399|      1|	}
  ------------------
 1502|      8|    if (ret != 0)
  ------------------
  |  Branch (1502:9): [True: 0, False: 8]
  ------------------
 1503|      0|	return ret;
 1504|       |
 1505|      8|    if (!VALID_TIME(dt))
  ------------------
  |  | 1276|      8|	(((VALID_HOUR(dt->hour) && VALID_MIN(dt->min) &&	\
  |  |  ------------------
  |  |  |  | 1249|     16|#define VALID_HOUR(hr)          ((hr >= 0) && (hr <= 23))
  |  |  |  |  ------------------
  |  |  |  |  |  Branch (1249:34): [True: 8, False: 0]
  |  |  |  |  |  Branch (1249:47): [True: 8, False: 0]
  |  |  |  |  ------------------
  |  |  ------------------
  |  |               	(((VALID_HOUR(dt->hour) && VALID_MIN(dt->min) &&	\
  |  |  ------------------
  |  |  |  | 1250|     16|#define VALID_MIN(min)          ((min >= 0) && (min <= 59))
  |  |  |  |  ------------------
  |  |  |  |  |  Branch (1250:34): [True: 8, False: 0]
  |  |  |  |  |  Branch (1250:48): [True: 8, False: 0]
  |  |  |  |  ------------------
  |  |  ------------------
  |  | 1277|      8|	  VALID_SEC(dt->sec)) || VALID_END_OF_DAY(dt)) &&	\
  |  |  ------------------
  |  |  |  | 1251|      8|#define VALID_SEC(sec)          ((sec >= 0) && (sec < 60))
  |  |  |  |  ------------------
  |  |  |  |  |  Branch (1251:34): [True: 8, False: 0]
  |  |  |  |  |  Branch (1251:48): [True: 8, False: 0]
  |  |  |  |  ------------------
  |  |  ------------------
  |  |               	  VALID_SEC(dt->sec)) || VALID_END_OF_DAY(dt)) &&	\
  |  |  ------------------
  |  |  |  | 1273|      0|	((dt)->hour == 24 && (dt)->min == 0 && (dt)->sec == 0)
  |  |  |  |  ------------------
  |  |  |  |  |  Branch (1273:3): [True: 0, False: 0]
  |  |  |  |  |  Branch (1273:23): [True: 0, False: 0]
  |  |  |  |  |  Branch (1273:41): [True: 0, False: 0]
  |  |  |  |  ------------------
  |  |  ------------------
  |  | 1278|      8|	 VALID_TZO(dt->tzo))
  |  |  ------------------
  |  |  |  | 1252|      8|#define VALID_TZO(tzo)          ((tzo >= -840) && (tzo <= 840))
  |  |  |  |  ------------------
  |  |  |  |  |  Branch (1252:34): [True: 8, False: 0]
  |  |  |  |  |  Branch (1252:51): [True: 8, False: 0]
  |  |  |  |  ------------------
  |  |  ------------------
  ------------------
 1506|      0|	return 2;
 1507|       |
 1508|      8|    *str = cur;
 1509|      8|    return 0;
 1510|      8|}
xmlschemastypes.c:_xmlSchemaParseGYear:
 1313|     12|_xmlSchemaParseGYear (xmlSchemaValDatePtr dt, const xmlChar **str) {
 1314|     12|    const xmlChar *cur = *str, *firstChar;
 1315|     12|    int isneg = 0, digcnt = 0;
 1316|       |
 1317|     12|    if (((*cur < '0') || (*cur > '9')) &&
  ------------------
  |  Branch (1317:10): [True: 0, False: 12]
  |  Branch (1317:26): [True: 0, False: 12]
  ------------------
 1318|     12|	(*cur != '-') && (*cur != '+'))
  ------------------
  |  Branch (1318:2): [True: 0, False: 0]
  |  Branch (1318:19): [True: 0, False: 0]
  ------------------
 1319|      0|	return -1;
 1320|       |
 1321|     12|    if (*cur == '-') {
  ------------------
  |  Branch (1321:9): [True: 0, False: 12]
  ------------------
 1322|      0|	isneg = 1;
 1323|      0|	cur++;
 1324|      0|    }
 1325|       |
 1326|     12|    firstChar = cur;
 1327|       |
 1328|     60|    while ((*cur >= '0') && (*cur <= '9')) {
  ------------------
  |  Branch (1328:12): [True: 50, False: 10]
  |  Branch (1328:29): [True: 48, False: 2]
  ------------------
 1329|     48|        int digit = *cur - '0';
 1330|       |
 1331|     48|        if (dt->year > LONG_MAX / 10)
  ------------------
  |  Branch (1331:13): [True: 0, False: 48]
  ------------------
 1332|      0|            return 2;
 1333|     48|	dt->year *= 10;
 1334|     48|        if (dt->year > LONG_MAX - digit)
  ------------------
  |  Branch (1334:13): [True: 0, False: 48]
  ------------------
 1335|      0|            return 2;
 1336|     48|        dt->year += digit;
 1337|     48|	cur++;
 1338|     48|	digcnt++;
 1339|     48|    }
 1340|       |
 1341|       |    /* year must be at least 4 digits (CCYY); over 4
 1342|       |     * digits cannot have a leading zero. */
 1343|     12|    if ((digcnt < 4) || ((digcnt > 4) && (*firstChar == '0')))
  ------------------
  |  Branch (1343:9): [True: 0, False: 12]
  |  Branch (1343:26): [True: 0, False: 12]
  |  Branch (1343:42): [True: 0, False: 0]
  ------------------
 1344|      0|	return 1;
 1345|       |
 1346|     12|    if (isneg)
  ------------------
  |  Branch (1346:9): [True: 0, False: 12]
  ------------------
 1347|      0|	dt->year = - dt->year;
 1348|       |
 1349|     12|    if (!VALID_YEAR(dt->year))
  ------------------
  |  | 1245|     12|#define VALID_YEAR(yr)          (yr != 0)
  ------------------
  |  Branch (1349:9): [True: 0, False: 12]
  ------------------
 1350|      0|	return 2;
 1351|       |
 1352|     12|    *str = cur;
 1353|     12|    return 0;
 1354|     12|}
xmlschemastypes.c:xmlSchemaValidateDuration:
 1900|     14|			   int collapse) {
 1901|     14|    const xmlChar  *cur = duration;
 1902|     14|    xmlSchemaValPtr dur;
 1903|     14|    int isneg = 0;
 1904|     14|    unsigned int seq = 0;
 1905|     14|    long days, secs = 0;
 1906|     14|    double sec_frac = 0.0;
 1907|       |
 1908|     14|    if (duration == NULL)
  ------------------
  |  Branch (1908:9): [True: 0, False: 14]
  ------------------
 1909|      0|	return -1;
 1910|       |
 1911|     14|    if (collapse)
  ------------------
  |  Branch (1911:9): [True: 14, False: 0]
  ------------------
 1912|     14|	while IS_WSP_BLANK_CH(*cur) cur++;
 1913|       |
 1914|     14|    if (*cur == '-') {
  ------------------
  |  Branch (1914:9): [True: 1, False: 13]
  ------------------
 1915|      1|        isneg = 1;
 1916|      1|        cur++;
 1917|      1|    }
 1918|       |
 1919|       |    /* duration must start with 'P' (after sign) */
 1920|     14|    if (*cur++ != 'P')
  ------------------
  |  Branch (1920:9): [True: 0, False: 14]
  ------------------
 1921|      0|	return 1;
 1922|       |
 1923|     14|    if (*cur == 0)
  ------------------
  |  Branch (1923:9): [True: 0, False: 14]
  ------------------
 1924|      0|	return 1;
 1925|       |
 1926|     14|    dur = xmlSchemaNewValue(XML_SCHEMAS_DURATION);
 1927|     14|    if (dur == NULL)
  ------------------
  |  Branch (1927:9): [True: 0, False: 14]
  ------------------
 1928|      0|	return -1;
 1929|       |
 1930|     28|    while (*cur != 0) {
  ------------------
  |  Branch (1930:12): [True: 14, False: 14]
  ------------------
 1931|     14|        long           num = 0;
 1932|     14|        size_t         has_digits = 0;
 1933|     14|        int            has_frac = 0;
 1934|     14|        const xmlChar  desig[] = {'Y', 'M', 'D', 'H', 'M', 'S'};
 1935|       |
 1936|       |        /* input string should be empty or invalid date/time item */
 1937|     14|        if (seq >= sizeof(desig))
  ------------------
  |  Branch (1937:13): [True: 0, False: 14]
  ------------------
 1938|      0|            goto error;
 1939|       |
 1940|       |        /* T designator must be present for time items */
 1941|     14|        if (*cur == 'T') {
  ------------------
  |  Branch (1941:13): [True: 6, False: 8]
  ------------------
 1942|      6|            if (seq > 3)
  ------------------
  |  Branch (1942:17): [True: 0, False: 6]
  ------------------
 1943|      0|                goto error;
 1944|      6|            cur++;
 1945|      6|            seq = 3;
 1946|      8|        } else if (seq == 3)
  ------------------
  |  Branch (1946:20): [True: 0, False: 8]
  ------------------
 1947|      0|            goto error;
 1948|       |
 1949|       |        /* Parse integral part. */
 1950|     30|        while (*cur >= '0' && *cur <= '9') {
  ------------------
  |  Branch (1950:16): [True: 28, False: 2]
  |  Branch (1950:31): [True: 16, False: 12]
  ------------------
 1951|     16|            long digit = *cur - '0';
 1952|       |
 1953|     16|            if (num > LONG_MAX / 10)
  ------------------
  |  Branch (1953:17): [True: 0, False: 16]
  ------------------
 1954|      0|                goto error;
 1955|     16|            num *= 10;
 1956|     16|            if (num > LONG_MAX - digit)
  ------------------
  |  Branch (1956:17): [True: 0, False: 16]
  ------------------
 1957|      0|                goto error;
 1958|     16|            num += digit;
 1959|       |
 1960|     16|            has_digits = 1;
 1961|     16|            cur++;
 1962|     16|        }
 1963|       |
 1964|     14|        if (*cur == '.') {
  ------------------
  |  Branch (1964:13): [True: 2, False: 12]
  ------------------
 1965|       |            /* Parse fractional part. */
 1966|      2|            double mult = 1.0;
 1967|      2|            cur++;
 1968|      2|            has_frac = 1;
 1969|      4|            while (*cur >= '0' && *cur <= '9') {
  ------------------
  |  Branch (1969:20): [True: 4, False: 0]
  |  Branch (1969:35): [True: 2, False: 2]
  ------------------
 1970|      2|                mult /= 10.0;
 1971|      2|                sec_frac += (*cur - '0') * mult;
 1972|      2|                has_digits = 1;
 1973|      2|                cur++;
 1974|      2|            }
 1975|      2|        }
 1976|       |
 1977|     26|        while (*cur != desig[seq]) {
  ------------------
  |  Branch (1977:16): [True: 12, False: 14]
  ------------------
 1978|     12|            seq++;
 1979|       |            /* No T designator or invalid char. */
 1980|     12|            if (seq == 3 || seq == sizeof(desig))
  ------------------
  |  Branch (1980:17): [True: 0, False: 12]
  |  Branch (1980:29): [True: 0, False: 12]
  ------------------
 1981|      0|                goto error;
 1982|     12|        }
 1983|     14|	cur++;
 1984|       |
 1985|     14|        if (!has_digits || (has_frac && (seq != 5)))
  ------------------
  |  Branch (1985:13): [True: 0, False: 14]
  |  Branch (1985:29): [True: 2, False: 12]
  |  Branch (1985:41): [True: 0, False: 2]
  ------------------
 1986|      0|            goto error;
 1987|       |
 1988|     14|        switch (seq) {
  ------------------
  |  Branch (1988:17): [True: 0, False: 14]
  ------------------
 1989|      4|            case 0:
  ------------------
  |  Branch (1989:13): [True: 4, False: 10]
  ------------------
 1990|       |                /* Year */
 1991|      4|                if (num > LONG_MAX / 12)
  ------------------
  |  Branch (1991:21): [True: 0, False: 4]
  ------------------
 1992|      0|                    goto error;
 1993|      4|                dur->value.dur.mon = num * 12;
 1994|      4|                break;
 1995|      4|            case 1:
  ------------------
  |  Branch (1995:13): [True: 4, False: 10]
  ------------------
 1996|       |                /* Month */
 1997|      4|                if (dur->value.dur.mon > LONG_MAX - num)
  ------------------
  |  Branch (1997:21): [True: 0, False: 4]
  ------------------
 1998|      0|                    goto error;
 1999|      4|                dur->value.dur.mon += num;
 2000|      4|                break;
 2001|      0|            case 2:
  ------------------
  |  Branch (2001:13): [True: 0, False: 14]
  ------------------
 2002|       |                /* Day */
 2003|      0|                dur->value.dur.day = num;
 2004|      0|                break;
 2005|      2|            case 3:
  ------------------
  |  Branch (2005:13): [True: 2, False: 12]
  ------------------
 2006|       |                /* Hour */
 2007|      2|                days = num / HOURS_PER_DAY;
  ------------------
  |  | 1285|      2|#define HOURS_PER_DAY           24
  ------------------
 2008|      2|                if (dur->value.dur.day > LONG_MAX - days)
  ------------------
  |  Branch (2008:21): [True: 0, False: 2]
  ------------------
 2009|      0|                    goto error;
 2010|      2|                dur->value.dur.day += days;
 2011|      2|                secs = (num % HOURS_PER_DAY) * SECS_PER_HOUR;
  ------------------
  |  | 1285|      2|#define HOURS_PER_DAY           24
  ------------------
                              secs = (num % HOURS_PER_DAY) * SECS_PER_HOUR;
  ------------------
  |  | 1286|      2|#define SECS_PER_HOUR           (MINS_PER_HOUR * SECS_PER_MIN)
  |  |  ------------------
  |  |  |  | 1284|      2|#define MINS_PER_HOUR           60
  |  |  ------------------
  |  |               #define SECS_PER_HOUR           (MINS_PER_HOUR * SECS_PER_MIN)
  |  |  ------------------
  |  |  |  | 1283|      2|#define SECS_PER_MIN            60
  |  |  ------------------
  ------------------
 2012|      2|                break;
 2013|      0|            case 4:
  ------------------
  |  Branch (2013:13): [True: 0, False: 14]
  ------------------
 2014|       |                /* Minute */
 2015|      0|                days = num / MINS_PER_DAY;
  ------------------
  |  | 1288|      0|#define MINS_PER_DAY            (HOURS_PER_DAY * MINS_PER_HOUR)
  |  |  ------------------
  |  |  |  | 1285|      0|#define HOURS_PER_DAY           24
  |  |  ------------------
  |  |               #define MINS_PER_DAY            (HOURS_PER_DAY * MINS_PER_HOUR)
  |  |  ------------------
  |  |  |  | 1284|      0|#define MINS_PER_HOUR           60
  |  |  ------------------
  ------------------
 2016|      0|                if (dur->value.dur.day > LONG_MAX - days)
  ------------------
  |  Branch (2016:21): [True: 0, False: 0]
  ------------------
 2017|      0|                    goto error;
 2018|      0|                dur->value.dur.day += days;
 2019|      0|                secs += (num % MINS_PER_DAY) * SECS_PER_MIN;
  ------------------
  |  | 1288|      0|#define MINS_PER_DAY            (HOURS_PER_DAY * MINS_PER_HOUR)
  |  |  ------------------
  |  |  |  | 1285|      0|#define HOURS_PER_DAY           24
  |  |  ------------------
  |  |               #define MINS_PER_DAY            (HOURS_PER_DAY * MINS_PER_HOUR)
  |  |  ------------------
  |  |  |  | 1284|      0|#define MINS_PER_HOUR           60
  |  |  ------------------
  ------------------
                              secs += (num % MINS_PER_DAY) * SECS_PER_MIN;
  ------------------
  |  | 1283|      0|#define SECS_PER_MIN            60
  ------------------
 2020|      0|                break;
 2021|      4|            case 5:
  ------------------
  |  Branch (2021:13): [True: 4, False: 10]
  ------------------
 2022|       |                /* Second */
 2023|      4|                days = num / SECS_PER_DAY;
  ------------------
  |  | 1287|      4|#define SECS_PER_DAY            (HOURS_PER_DAY * SECS_PER_HOUR)
  |  |  ------------------
  |  |  |  | 1285|      4|#define HOURS_PER_DAY           24
  |  |  ------------------
  |  |               #define SECS_PER_DAY            (HOURS_PER_DAY * SECS_PER_HOUR)
  |  |  ------------------
  |  |  |  | 1286|      4|#define SECS_PER_HOUR           (MINS_PER_HOUR * SECS_PER_MIN)
  |  |  |  |  ------------------
  |  |  |  |  |  | 1284|      4|#define MINS_PER_HOUR           60
  |  |  |  |  ------------------
  |  |  |  |               #define SECS_PER_HOUR           (MINS_PER_HOUR * SECS_PER_MIN)
  |  |  |  |  ------------------
  |  |  |  |  |  | 1283|      4|#define SECS_PER_MIN            60
  |  |  |  |  ------------------
  |  |  ------------------
  ------------------
 2024|      4|                if (dur->value.dur.day > LONG_MAX - days)
  ------------------
  |  Branch (2024:21): [True: 0, False: 4]
  ------------------
 2025|      0|                    goto error;
 2026|      4|                dur->value.dur.day += days;
 2027|      4|                secs += num % SECS_PER_DAY;
  ------------------
  |  | 1287|      4|#define SECS_PER_DAY            (HOURS_PER_DAY * SECS_PER_HOUR)
  |  |  ------------------
  |  |  |  | 1285|      4|#define HOURS_PER_DAY           24
  |  |  ------------------
  |  |               #define SECS_PER_DAY            (HOURS_PER_DAY * SECS_PER_HOUR)
  |  |  ------------------
  |  |  |  | 1286|      4|#define SECS_PER_HOUR           (MINS_PER_HOUR * SECS_PER_MIN)
  |  |  |  |  ------------------
  |  |  |  |  |  | 1284|      4|#define MINS_PER_HOUR           60
  |  |  |  |  ------------------
  |  |  |  |               #define SECS_PER_HOUR           (MINS_PER_HOUR * SECS_PER_MIN)
  |  |  |  |  ------------------
  |  |  |  |  |  | 1283|      4|#define SECS_PER_MIN            60
  |  |  |  |  ------------------
  |  |  ------------------
  ------------------
 2028|      4|                break;
 2029|     14|        }
 2030|       |
 2031|     14|        seq++;
 2032|     14|    }
 2033|       |
 2034|     14|    days = secs / SECS_PER_DAY;
  ------------------
  |  | 1287|     14|#define SECS_PER_DAY            (HOURS_PER_DAY * SECS_PER_HOUR)
  |  |  ------------------
  |  |  |  | 1285|     14|#define HOURS_PER_DAY           24
  |  |  ------------------
  |  |               #define SECS_PER_DAY            (HOURS_PER_DAY * SECS_PER_HOUR)
  |  |  ------------------
  |  |  |  | 1286|     14|#define SECS_PER_HOUR           (MINS_PER_HOUR * SECS_PER_MIN)
  |  |  |  |  ------------------
  |  |  |  |  |  | 1284|     14|#define MINS_PER_HOUR           60
  |  |  |  |  ------------------
  |  |  |  |               #define SECS_PER_HOUR           (MINS_PER_HOUR * SECS_PER_MIN)
  |  |  |  |  ------------------
  |  |  |  |  |  | 1283|     14|#define SECS_PER_MIN            60
  |  |  |  |  ------------------
  |  |  ------------------
  ------------------
 2035|     14|    if (dur->value.dur.day > LONG_MAX - days)
  ------------------
  |  Branch (2035:9): [True: 0, False: 14]
  ------------------
 2036|      0|        goto error;
 2037|     14|    dur->value.dur.day += days;
 2038|     14|    dur->value.dur.sec = (secs % SECS_PER_DAY) + sec_frac;
  ------------------
  |  | 1287|     14|#define SECS_PER_DAY            (HOURS_PER_DAY * SECS_PER_HOUR)
  |  |  ------------------
  |  |  |  | 1285|     14|#define HOURS_PER_DAY           24
  |  |  ------------------
  |  |               #define SECS_PER_DAY            (HOURS_PER_DAY * SECS_PER_HOUR)
  |  |  ------------------
  |  |  |  | 1286|     14|#define SECS_PER_HOUR           (MINS_PER_HOUR * SECS_PER_MIN)
  |  |  |  |  ------------------
  |  |  |  |  |  | 1284|     14|#define MINS_PER_HOUR           60
  |  |  |  |  ------------------
  |  |  |  |               #define SECS_PER_HOUR           (MINS_PER_HOUR * SECS_PER_MIN)
  |  |  |  |  ------------------
  |  |  |  |  |  | 1283|     14|#define SECS_PER_MIN            60
  |  |  |  |  ------------------
  |  |  ------------------
  ------------------
 2039|       |
 2040|     14|    if (isneg) {
  ------------------
  |  Branch (2040:9): [True: 1, False: 13]
  ------------------
 2041|      1|        dur->value.dur.mon = -dur->value.dur.mon;
 2042|      1|        dur->value.dur.day = -dur->value.dur.day;
 2043|      1|        dur->value.dur.sec = -dur->value.dur.sec;
 2044|      1|    }
 2045|       |
 2046|     14|    if (val != NULL)
  ------------------
  |  Branch (2046:9): [True: 14, False: 0]
  ------------------
 2047|     14|        *val = dur;
 2048|      0|    else
 2049|      0|	xmlSchemaFreeValue(dur);
 2050|       |
 2051|     14|    return 0;
 2052|       |
 2053|      0|error:
 2054|      0|    if (dur != NULL)
  ------------------
  |  Branch (2054:9): [True: 0, False: 0]
  ------------------
 2055|      0|	xmlSchemaFreeValue(dur);
 2056|      0|    return 1;
 2057|     14|}
xmlschemastypes.c:xmlSchemaCheckLanguageType:
 2301|     19|xmlSchemaCheckLanguageType(const xmlChar* value) {
 2302|     19|    int first = 1, len = 0;
 2303|     19|    const xmlChar* cur = value;
 2304|       |
 2305|     19|    if (value == NULL)
  ------------------
  |  Branch (2305:9): [True: 0, False: 19]
  ------------------
 2306|      0|        return (0);
 2307|       |
 2308|     58|    while (cur[0] != 0) {
  ------------------
  |  Branch (2308:12): [True: 40, False: 18]
  ------------------
 2309|     40|        if (!( ((cur[0] >= 'a') && (cur[0] <= 'z')) || ((cur[0] >= 'A') && (cur[0] <= 'Z'))
  ------------------
  |  Branch (2309:17): [True: 36, False: 4]
  |  Branch (2309:36): [True: 36, False: 0]
  |  Branch (2309:57): [True: 2, False: 2]
  |  Branch (2309:76): [True: 2, False: 0]
  ------------------
 2310|     40|            || (cur[0] == '-')
  ------------------
  |  Branch (2310:16): [True: 1, False: 1]
  ------------------
 2311|     40|            || ((first == 0) && (xmlIsDigit_ch(cur[0]))) ))
  ------------------
  |  |  144|      0|#define xmlIsDigit_ch(c)	(((0x30 <= (c)) && ((c) <= 0x39)))
  |  |  ------------------
  |  |  |  Branch (144:28): [True: 0, False: 0]
  |  |  |  Branch (144:45): [True: 0, False: 0]
  |  |  ------------------
  ------------------
  |  Branch (2311:17): [True: 0, False: 1]
  ------------------
 2312|      1|            return (0);
 2313|     39|        if (cur[0] == '-') {
  ------------------
  |  Branch (2313:13): [True: 1, False: 38]
  ------------------
 2314|      1|            if ((len < 1) || (len > 8))
  ------------------
  |  Branch (2314:17): [True: 0, False: 1]
  |  Branch (2314:30): [True: 0, False: 1]
  ------------------
 2315|      0|                return (0);
 2316|      1|            len = 0;
 2317|      1|            first = 0;
 2318|      1|        }
 2319|     38|        else
 2320|     38|            len++;
 2321|     39|        cur++;
 2322|     39|    }
 2323|     18|    if ((len < 1) || (len > 8))
  ------------------
  |  Branch (2323:9): [True: 0, False: 18]
  |  Branch (2323:22): [True: 0, False: 18]
  ------------------
 2324|      0|        return (0);
 2325|       |
 2326|     18|    return (1);
 2327|     18|}
xmlschemastypes.c:xmlSchemaDupVal:
 3887|     20|{
 3888|     20|    xmlSchemaValPtr ret = xmlSchemaNewValue(v->type);
 3889|     20|    if (ret == NULL)
  ------------------
  |  Branch (3889:9): [True: 0, False: 20]
  ------------------
 3890|      0|        return NULL;
 3891|       |
 3892|     20|    memcpy(ret, v, sizeof(xmlSchemaVal));
 3893|     20|    ret->next = NULL;
 3894|     20|    return ret;
 3895|     20|}
xmlschemastypes.c:xmlSchemaCompareValuesInternal:
 4952|     21|{
 4953|     21|    switch (xtype) {
  ------------------
  |  Branch (4953:13): [True: 0, False: 21]
  ------------------
 4954|      0|	case XML_SCHEMAS_UNKNOWN:
  ------------------
  |  Branch (4954:2): [True: 0, False: 21]
  ------------------
 4955|      0|	case XML_SCHEMAS_ANYTYPE:
  ------------------
  |  Branch (4955:2): [True: 0, False: 21]
  ------------------
 4956|      0|	    return(-2);
 4957|      0|        case XML_SCHEMAS_INTEGER:
  ------------------
  |  Branch (4957:9): [True: 0, False: 21]
  ------------------
 4958|      0|        case XML_SCHEMAS_NPINTEGER:
  ------------------
  |  Branch (4958:9): [True: 0, False: 21]
  ------------------
 4959|      0|        case XML_SCHEMAS_NINTEGER:
  ------------------
  |  Branch (4959:9): [True: 0, False: 21]
  ------------------
 4960|      0|        case XML_SCHEMAS_NNINTEGER:
  ------------------
  |  Branch (4960:9): [True: 0, False: 21]
  ------------------
 4961|      0|        case XML_SCHEMAS_PINTEGER:
  ------------------
  |  Branch (4961:9): [True: 0, False: 21]
  ------------------
 4962|      2|        case XML_SCHEMAS_INT:
  ------------------
  |  Branch (4962:9): [True: 2, False: 19]
  ------------------
 4963|      2|        case XML_SCHEMAS_UINT:
  ------------------
  |  Branch (4963:9): [True: 0, False: 21]
  ------------------
 4964|      2|        case XML_SCHEMAS_LONG:
  ------------------
  |  Branch (4964:9): [True: 0, False: 21]
  ------------------
 4965|      2|        case XML_SCHEMAS_ULONG:
  ------------------
  |  Branch (4965:9): [True: 0, False: 21]
  ------------------
 4966|      2|        case XML_SCHEMAS_SHORT:
  ------------------
  |  Branch (4966:9): [True: 0, False: 21]
  ------------------
 4967|      2|        case XML_SCHEMAS_USHORT:
  ------------------
  |  Branch (4967:9): [True: 0, False: 21]
  ------------------
 4968|      3|        case XML_SCHEMAS_BYTE:
  ------------------
  |  Branch (4968:9): [True: 1, False: 20]
  ------------------
 4969|      3|        case XML_SCHEMAS_UBYTE:
  ------------------
  |  Branch (4969:9): [True: 0, False: 21]
  ------------------
 4970|      4|	case XML_SCHEMAS_DECIMAL:
  ------------------
  |  Branch (4970:2): [True: 1, False: 20]
  ------------------
 4971|      4|	    if ((x == NULL) || (y == NULL))
  ------------------
  |  Branch (4971:10): [True: 0, False: 4]
  |  Branch (4971:25): [True: 0, False: 4]
  ------------------
 4972|      0|		return(-2);
 4973|      4|	    if (ytype == xtype)
  ------------------
  |  Branch (4973:10): [True: 4, False: 0]
  ------------------
 4974|      4|		return(xmlSchemaCompareDecimals(x, y));
 4975|      0|	    if ((ytype == XML_SCHEMAS_DECIMAL) ||
  ------------------
  |  Branch (4975:10): [True: 0, False: 0]
  ------------------
 4976|      0|		(ytype == XML_SCHEMAS_INTEGER) ||
  ------------------
  |  Branch (4976:3): [True: 0, False: 0]
  ------------------
 4977|      0|		(ytype == XML_SCHEMAS_NPINTEGER) ||
  ------------------
  |  Branch (4977:3): [True: 0, False: 0]
  ------------------
 4978|      0|		(ytype == XML_SCHEMAS_NINTEGER) ||
  ------------------
  |  Branch (4978:3): [True: 0, False: 0]
  ------------------
 4979|      0|		(ytype == XML_SCHEMAS_NNINTEGER) ||
  ------------------
  |  Branch (4979:3): [True: 0, False: 0]
  ------------------
 4980|      0|		(ytype == XML_SCHEMAS_PINTEGER) ||
  ------------------
  |  Branch (4980:3): [True: 0, False: 0]
  ------------------
 4981|      0|		(ytype == XML_SCHEMAS_INT) ||
  ------------------
  |  Branch (4981:3): [True: 0, False: 0]
  ------------------
 4982|      0|		(ytype == XML_SCHEMAS_UINT) ||
  ------------------
  |  Branch (4982:3): [True: 0, False: 0]
  ------------------
 4983|      0|		(ytype == XML_SCHEMAS_LONG) ||
  ------------------
  |  Branch (4983:3): [True: 0, False: 0]
  ------------------
 4984|      0|		(ytype == XML_SCHEMAS_ULONG) ||
  ------------------
  |  Branch (4984:3): [True: 0, False: 0]
  ------------------
 4985|      0|		(ytype == XML_SCHEMAS_SHORT) ||
  ------------------
  |  Branch (4985:3): [True: 0, False: 0]
  ------------------
 4986|      0|		(ytype == XML_SCHEMAS_USHORT) ||
  ------------------
  |  Branch (4986:3): [True: 0, False: 0]
  ------------------
 4987|      0|		(ytype == XML_SCHEMAS_BYTE) ||
  ------------------
  |  Branch (4987:3): [True: 0, False: 0]
  ------------------
 4988|      0|		(ytype == XML_SCHEMAS_UBYTE))
  ------------------
  |  Branch (4988:3): [True: 0, False: 0]
  ------------------
 4989|      0|		return(xmlSchemaCompareDecimals(x, y));
 4990|      0|	    return(-2);
 4991|      7|        case XML_SCHEMAS_DURATION:
  ------------------
  |  Branch (4991:9): [True: 7, False: 14]
  ------------------
 4992|      7|	    if ((x == NULL) || (y == NULL))
  ------------------
  |  Branch (4992:10): [True: 0, False: 7]
  |  Branch (4992:25): [True: 0, False: 7]
  ------------------
 4993|      0|		return(-2);
 4994|      7|	    if (ytype == XML_SCHEMAS_DURATION)
  ------------------
  |  Branch (4994:10): [True: 7, False: 0]
  ------------------
 4995|      7|                return(xmlSchemaCompareDurations(x, y));
 4996|      0|            return(-2);
 4997|      2|        case XML_SCHEMAS_TIME:
  ------------------
  |  Branch (4997:9): [True: 2, False: 19]
  ------------------
 4998|      3|        case XML_SCHEMAS_GDAY:
  ------------------
  |  Branch (4998:9): [True: 1, False: 20]
  ------------------
 4999|      4|        case XML_SCHEMAS_GMONTH:
  ------------------
  |  Branch (4999:9): [True: 1, False: 20]
  ------------------
 5000|      4|        case XML_SCHEMAS_GMONTHDAY:
  ------------------
  |  Branch (5000:9): [True: 0, False: 21]
  ------------------
 5001|      5|        case XML_SCHEMAS_GYEAR:
  ------------------
  |  Branch (5001:9): [True: 1, False: 20]
  ------------------
 5002|      6|        case XML_SCHEMAS_GYEARMONTH:
  ------------------
  |  Branch (5002:9): [True: 1, False: 20]
  ------------------
 5003|      8|        case XML_SCHEMAS_DATE:
  ------------------
  |  Branch (5003:9): [True: 2, False: 19]
  ------------------
 5004|     10|        case XML_SCHEMAS_DATETIME:
  ------------------
  |  Branch (5004:9): [True: 2, False: 19]
  ------------------
 5005|     10|	    if ((x == NULL) || (y == NULL))
  ------------------
  |  Branch (5005:10): [True: 0, False: 10]
  |  Branch (5005:25): [True: 0, False: 10]
  ------------------
 5006|      0|		return(-2);
 5007|     10|            if ((ytype == XML_SCHEMAS_DATETIME)  ||
  ------------------
  |  Branch (5007:17): [True: 2, False: 8]
  ------------------
 5008|     10|                (ytype == XML_SCHEMAS_TIME)      ||
  ------------------
  |  Branch (5008:17): [True: 2, False: 6]
  ------------------
 5009|     10|                (ytype == XML_SCHEMAS_GDAY)      ||
  ------------------
  |  Branch (5009:17): [True: 1, False: 5]
  ------------------
 5010|     10|                (ytype == XML_SCHEMAS_GMONTH)    ||
  ------------------
  |  Branch (5010:17): [True: 1, False: 4]
  ------------------
 5011|     10|                (ytype == XML_SCHEMAS_GMONTHDAY) ||
  ------------------
  |  Branch (5011:17): [True: 0, False: 4]
  ------------------
 5012|     10|                (ytype == XML_SCHEMAS_GYEAR)     ||
  ------------------
  |  Branch (5012:17): [True: 1, False: 3]
  ------------------
 5013|     10|                (ytype == XML_SCHEMAS_DATE)      ||
  ------------------
  |  Branch (5013:17): [True: 2, False: 1]
  ------------------
 5014|     10|                (ytype == XML_SCHEMAS_GYEARMONTH))
  ------------------
  |  Branch (5014:17): [True: 1, False: 0]
  ------------------
 5015|     10|                return (xmlSchemaCompareDates(x, y));
 5016|      0|            return (-2);
 5017|       |	/*
 5018|       |	* Note that we will support comparison of string types against
 5019|       |	* anySimpleType as well.
 5020|       |	*/
 5021|      0|	case XML_SCHEMAS_ANYSIMPLETYPE:
  ------------------
  |  Branch (5021:2): [True: 0, False: 21]
  ------------------
 5022|      0|	case XML_SCHEMAS_STRING:
  ------------------
  |  Branch (5022:2): [True: 0, False: 21]
  ------------------
 5023|      0|        case XML_SCHEMAS_NORMSTRING:
  ------------------
  |  Branch (5023:9): [True: 0, False: 21]
  ------------------
 5024|      0|        case XML_SCHEMAS_TOKEN:
  ------------------
  |  Branch (5024:9): [True: 0, False: 21]
  ------------------
 5025|      0|        case XML_SCHEMAS_LANGUAGE:
  ------------------
  |  Branch (5025:9): [True: 0, False: 21]
  ------------------
 5026|      0|        case XML_SCHEMAS_NMTOKEN:
  ------------------
  |  Branch (5026:9): [True: 0, False: 21]
  ------------------
 5027|      0|        case XML_SCHEMAS_NAME:
  ------------------
  |  Branch (5027:9): [True: 0, False: 21]
  ------------------
 5028|      0|        case XML_SCHEMAS_NCNAME:
  ------------------
  |  Branch (5028:9): [True: 0, False: 21]
  ------------------
 5029|      0|        case XML_SCHEMAS_ID:
  ------------------
  |  Branch (5029:9): [True: 0, False: 21]
  ------------------
 5030|      0|        case XML_SCHEMAS_IDREF:
  ------------------
  |  Branch (5030:9): [True: 0, False: 21]
  ------------------
 5031|      0|        case XML_SCHEMAS_ENTITY:
  ------------------
  |  Branch (5031:9): [True: 0, False: 21]
  ------------------
 5032|      0|        case XML_SCHEMAS_ANYURI:
  ------------------
  |  Branch (5032:9): [True: 0, False: 21]
  ------------------
 5033|      0|	{
 5034|      0|	    const xmlChar *xv, *yv;
 5035|       |
 5036|      0|	    if (x == NULL)
  ------------------
  |  Branch (5036:10): [True: 0, False: 0]
  ------------------
 5037|      0|		xv = xvalue;
 5038|      0|	    else
 5039|      0|		xv = x->value.str;
 5040|      0|	    if (y == NULL)
  ------------------
  |  Branch (5040:10): [True: 0, False: 0]
  ------------------
 5041|      0|		yv = yvalue;
 5042|      0|	    else
 5043|      0|		yv = y->value.str;
 5044|       |	    /*
 5045|       |	    * TODO: Compare those against QName.
 5046|       |	    */
 5047|      0|	    if (ytype == XML_SCHEMAS_QNAME) {
  ------------------
  |  Branch (5047:10): [True: 0, False: 0]
  ------------------
 5048|      0|		TODO
  ------------------
  |  |   45|      0|    xmlGenericError(xmlGenericErrorContext,				\
  |  |  ------------------
  |  |  |  |  875|      0|  #define xmlGenericError XML_GLOBAL_MACRO(xmlGenericError)
  |  |  |  |  ------------------
  |  |  |  |  |  |  500|      0|  #define XML_GLOBAL_MACRO(name) (*__##name())
  |  |  |  |  ------------------
  |  |  ------------------
  |  |                   xmlGenericError(xmlGenericErrorContext,				\
  |  |  ------------------
  |  |  |  |  876|      0|  #define xmlGenericErrorContext XML_GLOBAL_MACRO(xmlGenericErrorContext)
  |  |  |  |  ------------------
  |  |  |  |  |  |  500|      0|  #define XML_GLOBAL_MACRO(name) (*__##name())
  |  |  |  |  ------------------
  |  |  ------------------
  |  |   46|      0|	    "Unimplemented block at %s:%d\n",				\
  |  |   47|      0|            __FILE__, __LINE__);
  ------------------
 5049|      0|		if (y == NULL)
  ------------------
  |  Branch (5049:7): [True: 0, False: 0]
  ------------------
 5050|      0|		    return(-2);
 5051|      0|		return (-2);
 5052|      0|	    }
 5053|      0|            if ((ytype == XML_SCHEMAS_ANYSIMPLETYPE) ||
  ------------------
  |  Branch (5053:17): [True: 0, False: 0]
  ------------------
 5054|      0|		(ytype == XML_SCHEMAS_STRING) ||
  ------------------
  |  Branch (5054:3): [True: 0, False: 0]
  ------------------
 5055|      0|		(ytype == XML_SCHEMAS_NORMSTRING) ||
  ------------------
  |  Branch (5055:3): [True: 0, False: 0]
  ------------------
 5056|      0|                (ytype == XML_SCHEMAS_TOKEN) ||
  ------------------
  |  Branch (5056:17): [True: 0, False: 0]
  ------------------
 5057|      0|                (ytype == XML_SCHEMAS_LANGUAGE) ||
  ------------------
  |  Branch (5057:17): [True: 0, False: 0]
  ------------------
 5058|      0|                (ytype == XML_SCHEMAS_NMTOKEN) ||
  ------------------
  |  Branch (5058:17): [True: 0, False: 0]
  ------------------
 5059|      0|                (ytype == XML_SCHEMAS_NAME) ||
  ------------------
  |  Branch (5059:17): [True: 0, False: 0]
  ------------------
 5060|      0|                (ytype == XML_SCHEMAS_NCNAME) ||
  ------------------
  |  Branch (5060:17): [True: 0, False: 0]
  ------------------
 5061|      0|                (ytype == XML_SCHEMAS_ID) ||
  ------------------
  |  Branch (5061:17): [True: 0, False: 0]
  ------------------
 5062|      0|                (ytype == XML_SCHEMAS_IDREF) ||
  ------------------
  |  Branch (5062:17): [True: 0, False: 0]
  ------------------
 5063|      0|                (ytype == XML_SCHEMAS_ENTITY) ||
  ------------------
  |  Branch (5063:17): [True: 0, False: 0]
  ------------------
 5064|      0|                (ytype == XML_SCHEMAS_ANYURI)) {
  ------------------
  |  Branch (5064:17): [True: 0, False: 0]
  ------------------
 5065|       |
 5066|      0|		if (xws == XML_SCHEMA_WHITESPACE_PRESERVE) {
  ------------------
  |  Branch (5066:7): [True: 0, False: 0]
  ------------------
 5067|       |
 5068|      0|		    if (yws == XML_SCHEMA_WHITESPACE_PRESERVE) {
  ------------------
  |  Branch (5068:11): [True: 0, False: 0]
  ------------------
 5069|       |			/* TODO: What about x < y or x > y. */
 5070|      0|			if (xmlStrEqual(xv, yv))
  ------------------
  |  Branch (5070:8): [True: 0, False: 0]
  ------------------
 5071|      0|			    return (0);
 5072|      0|			else
 5073|      0|			    return (2);
 5074|      0|		    } else if (yws == XML_SCHEMA_WHITESPACE_REPLACE)
  ------------------
  |  Branch (5074:18): [True: 0, False: 0]
  ------------------
 5075|      0|			return (xmlSchemaComparePreserveReplaceStrings(xv, yv, 0));
 5076|      0|		    else if (yws == XML_SCHEMA_WHITESPACE_COLLAPSE)
  ------------------
  |  Branch (5076:16): [True: 0, False: 0]
  ------------------
 5077|      0|			return (xmlSchemaComparePreserveCollapseStrings(xv, yv, 0));
 5078|       |
 5079|      0|		} else if (xws == XML_SCHEMA_WHITESPACE_REPLACE) {
  ------------------
  |  Branch (5079:14): [True: 0, False: 0]
  ------------------
 5080|       |
 5081|      0|		    if (yws == XML_SCHEMA_WHITESPACE_PRESERVE)
  ------------------
  |  Branch (5081:11): [True: 0, False: 0]
  ------------------
 5082|      0|			return (xmlSchemaComparePreserveReplaceStrings(yv, xv, 1));
 5083|      0|		    if (yws == XML_SCHEMA_WHITESPACE_REPLACE)
  ------------------
  |  Branch (5083:11): [True: 0, False: 0]
  ------------------
 5084|      0|			return (xmlSchemaCompareReplacedStrings(xv, yv));
 5085|      0|		    if (yws == XML_SCHEMA_WHITESPACE_COLLAPSE)
  ------------------
  |  Branch (5085:11): [True: 0, False: 0]
  ------------------
 5086|      0|			return (xmlSchemaCompareReplaceCollapseStrings(xv, yv, 0));
 5087|       |
 5088|      0|		} else if (xws == XML_SCHEMA_WHITESPACE_COLLAPSE) {
  ------------------
  |  Branch (5088:14): [True: 0, False: 0]
  ------------------
 5089|       |
 5090|      0|		    if (yws == XML_SCHEMA_WHITESPACE_PRESERVE)
  ------------------
  |  Branch (5090:11): [True: 0, False: 0]
  ------------------
 5091|      0|			return (xmlSchemaComparePreserveCollapseStrings(yv, xv, 1));
 5092|      0|		    if (yws == XML_SCHEMA_WHITESPACE_REPLACE)
  ------------------
  |  Branch (5092:11): [True: 0, False: 0]
  ------------------
 5093|      0|			return (xmlSchemaCompareReplaceCollapseStrings(yv, xv, 1));
 5094|      0|		    if (yws == XML_SCHEMA_WHITESPACE_COLLAPSE)
  ------------------
  |  Branch (5094:11): [True: 0, False: 0]
  ------------------
 5095|      0|			return (xmlSchemaCompareNormStrings(xv, yv));
 5096|      0|		} else
 5097|      0|		    return (-2);
 5098|       |
 5099|      0|	    }
 5100|      0|            return (-2);
 5101|      0|	}
 5102|      0|        case XML_SCHEMAS_QNAME:
  ------------------
  |  Branch (5102:9): [True: 0, False: 21]
  ------------------
 5103|      0|	case XML_SCHEMAS_NOTATION:
  ------------------
  |  Branch (5103:2): [True: 0, False: 21]
  ------------------
 5104|      0|	    if ((x == NULL) || (y == NULL))
  ------------------
  |  Branch (5104:10): [True: 0, False: 0]
  |  Branch (5104:25): [True: 0, False: 0]
  ------------------
 5105|      0|		return(-2);
 5106|      0|            if ((ytype == XML_SCHEMAS_QNAME) ||
  ------------------
  |  Branch (5106:17): [True: 0, False: 0]
  ------------------
 5107|      0|		(ytype == XML_SCHEMAS_NOTATION)) {
  ------------------
  |  Branch (5107:3): [True: 0, False: 0]
  ------------------
 5108|      0|		if ((xmlStrEqual(x->value.qname.name, y->value.qname.name)) &&
  ------------------
  |  Branch (5108:7): [True: 0, False: 0]
  ------------------
 5109|      0|		    (xmlStrEqual(x->value.qname.uri, y->value.qname.uri)))
  ------------------
  |  Branch (5109:7): [True: 0, False: 0]
  ------------------
 5110|      0|		    return(0);
 5111|      0|		return(2);
 5112|      0|	    }
 5113|      0|	    return (-2);
 5114|      0|        case XML_SCHEMAS_FLOAT:
  ------------------
  |  Branch (5114:9): [True: 0, False: 21]
  ------------------
 5115|      0|        case XML_SCHEMAS_DOUBLE:
  ------------------
  |  Branch (5115:9): [True: 0, False: 21]
  ------------------
 5116|      0|	    if ((x == NULL) || (y == NULL))
  ------------------
  |  Branch (5116:10): [True: 0, False: 0]
  |  Branch (5116:25): [True: 0, False: 0]
  ------------------
 5117|      0|		return(-2);
 5118|      0|            if ((ytype == XML_SCHEMAS_FLOAT) ||
  ------------------
  |  Branch (5118:17): [True: 0, False: 0]
  ------------------
 5119|      0|                (ytype == XML_SCHEMAS_DOUBLE))
  ------------------
  |  Branch (5119:17): [True: 0, False: 0]
  ------------------
 5120|      0|                return (xmlSchemaCompareFloats(x, y));
 5121|      0|            return (-2);
 5122|      0|        case XML_SCHEMAS_BOOLEAN:
  ------------------
  |  Branch (5122:9): [True: 0, False: 21]
  ------------------
 5123|      0|	    if ((x == NULL) || (y == NULL))
  ------------------
  |  Branch (5123:10): [True: 0, False: 0]
  |  Branch (5123:25): [True: 0, False: 0]
  ------------------
 5124|      0|		return(-2);
 5125|      0|            if (ytype == XML_SCHEMAS_BOOLEAN) {
  ------------------
  |  Branch (5125:17): [True: 0, False: 0]
  ------------------
 5126|      0|		if (x->value.b == y->value.b)
  ------------------
  |  Branch (5126:7): [True: 0, False: 0]
  ------------------
 5127|      0|		    return(0);
 5128|      0|		if (x->value.b == 0)
  ------------------
  |  Branch (5128:7): [True: 0, False: 0]
  ------------------
 5129|      0|		    return(-1);
 5130|      0|		return(1);
 5131|      0|	    }
 5132|      0|	    return (-2);
 5133|      0|        case XML_SCHEMAS_HEXBINARY:
  ------------------
  |  Branch (5133:9): [True: 0, False: 21]
  ------------------
 5134|      0|	    if ((x == NULL) || (y == NULL))
  ------------------
  |  Branch (5134:10): [True: 0, False: 0]
  |  Branch (5134:25): [True: 0, False: 0]
  ------------------
 5135|      0|		return(-2);
 5136|      0|            if (ytype == XML_SCHEMAS_HEXBINARY) {
  ------------------
  |  Branch (5136:17): [True: 0, False: 0]
  ------------------
 5137|      0|	        if (x->value.hex.total == y->value.hex.total) {
  ------------------
  |  Branch (5137:14): [True: 0, False: 0]
  ------------------
 5138|      0|		    int ret = xmlStrcmp(x->value.hex.str, y->value.hex.str);
 5139|      0|		    if (ret > 0)
  ------------------
  |  Branch (5139:11): [True: 0, False: 0]
  ------------------
 5140|      0|			return(1);
 5141|      0|		    else if (ret == 0)
  ------------------
  |  Branch (5141:16): [True: 0, False: 0]
  ------------------
 5142|      0|			return(0);
 5143|      0|		}
 5144|      0|		else if (x->value.hex.total > y->value.hex.total)
  ------------------
  |  Branch (5144:12): [True: 0, False: 0]
  ------------------
 5145|      0|		    return(1);
 5146|       |
 5147|      0|		return(-1);
 5148|      0|            }
 5149|      0|            return (-2);
 5150|      0|        case XML_SCHEMAS_BASE64BINARY:
  ------------------
  |  Branch (5150:9): [True: 0, False: 21]
  ------------------
 5151|      0|	    if ((x == NULL) || (y == NULL))
  ------------------
  |  Branch (5151:10): [True: 0, False: 0]
  |  Branch (5151:25): [True: 0, False: 0]
  ------------------
 5152|      0|		return(-2);
 5153|      0|            if (ytype == XML_SCHEMAS_BASE64BINARY) {
  ------------------
  |  Branch (5153:17): [True: 0, False: 0]
  ------------------
 5154|      0|                if (x->value.base64.total == y->value.base64.total) {
  ------------------
  |  Branch (5154:21): [True: 0, False: 0]
  ------------------
 5155|      0|                    int ret = xmlStrcmp(x->value.base64.str,
 5156|      0|		                        y->value.base64.str);
 5157|      0|                    if (ret > 0)
  ------------------
  |  Branch (5157:25): [True: 0, False: 0]
  ------------------
 5158|      0|                        return(1);
 5159|      0|                    else if (ret == 0)
  ------------------
  |  Branch (5159:30): [True: 0, False: 0]
  ------------------
 5160|      0|                        return(0);
 5161|      0|		    else
 5162|      0|		        return(-1);
 5163|      0|                }
 5164|      0|                else if (x->value.base64.total > y->value.base64.total)
  ------------------
  |  Branch (5164:26): [True: 0, False: 0]
  ------------------
 5165|      0|                    return(1);
 5166|      0|                else
 5167|      0|                    return(-1);
 5168|      0|            }
 5169|      0|            return (-2);
 5170|      0|        case XML_SCHEMAS_IDREFS:
  ------------------
  |  Branch (5170:9): [True: 0, False: 21]
  ------------------
 5171|      0|        case XML_SCHEMAS_ENTITIES:
  ------------------
  |  Branch (5171:9): [True: 0, False: 21]
  ------------------
 5172|      0|        case XML_SCHEMAS_NMTOKENS:
  ------------------
  |  Branch (5172:9): [True: 0, False: 21]
  ------------------
 5173|      0|	    TODO
  ------------------
  |  |   45|      0|    xmlGenericError(xmlGenericErrorContext,				\
  |  |  ------------------
  |  |  |  |  875|      0|  #define xmlGenericError XML_GLOBAL_MACRO(xmlGenericError)
  |  |  |  |  ------------------
  |  |  |  |  |  |  500|      0|  #define XML_GLOBAL_MACRO(name) (*__##name())
  |  |  |  |  ------------------
  |  |  ------------------
  |  |                   xmlGenericError(xmlGenericErrorContext,				\
  |  |  ------------------
  |  |  |  |  876|      0|  #define xmlGenericErrorContext XML_GLOBAL_MACRO(xmlGenericErrorContext)
  |  |  |  |  ------------------
  |  |  |  |  |  |  500|      0|  #define XML_GLOBAL_MACRO(name) (*__##name())
  |  |  |  |  ------------------
  |  |  ------------------
  |  |   46|      0|	    "Unimplemented block at %s:%d\n",				\
  |  |   47|      0|            __FILE__, __LINE__);
  ------------------
 5174|      0|	    break;
 5175|     21|    }
 5176|      0|    return -2;
 5177|     21|}
xmlschemastypes.c:xmlSchemaCompareDecimals:
 3638|      4|{
 3639|      4|    xmlSchemaValPtr swp;
 3640|      4|    int order = 1, integx, integy, dlen;
 3641|      4|    unsigned long hi, mi, lo;
 3642|       |
 3643|       |    /*
 3644|       |     * First test: If x is -ve and not zero
 3645|       |     */
 3646|      4|    if ((x->value.decimal.sign) &&
  ------------------
  |  Branch (3646:9): [True: 0, False: 4]
  ------------------
 3647|      4|	((x->value.decimal.lo != 0) ||
  ------------------
  |  Branch (3647:3): [True: 0, False: 0]
  ------------------
 3648|      0|	 (x->value.decimal.mi != 0) ||
  ------------------
  |  Branch (3648:3): [True: 0, False: 0]
  ------------------
 3649|      0|	 (x->value.decimal.hi != 0))) {
  ------------------
  |  Branch (3649:3): [True: 0, False: 0]
  ------------------
 3650|       |	/*
 3651|       |	 * Then if y is -ve and not zero reverse the compare
 3652|       |	 */
 3653|      0|	if ((y->value.decimal.sign) &&
  ------------------
  |  Branch (3653:6): [True: 0, False: 0]
  ------------------
 3654|      0|	    ((y->value.decimal.lo != 0) ||
  ------------------
  |  Branch (3654:7): [True: 0, False: 0]
  ------------------
 3655|      0|	     (y->value.decimal.mi != 0) ||
  ------------------
  |  Branch (3655:7): [True: 0, False: 0]
  ------------------
 3656|      0|	     (y->value.decimal.hi != 0)))
  ------------------
  |  Branch (3656:7): [True: 0, False: 0]
  ------------------
 3657|      0|	    order = -1;
 3658|       |	/*
 3659|       |	 * Otherwise (y >= 0) we have the answer
 3660|       |	 */
 3661|      0|	else
 3662|      0|	    return (-1);
 3663|       |    /*
 3664|       |     * If x is not -ve and y is -ve we have the answer
 3665|       |     */
 3666|      4|    } else if ((y->value.decimal.sign) &&
  ------------------
  |  Branch (3666:16): [True: 0, False: 4]
  ------------------
 3667|      4|	       ((y->value.decimal.lo != 0) ||
  ------------------
  |  Branch (3667:10): [True: 0, False: 0]
  ------------------
 3668|      0|		(y->value.decimal.mi != 0) ||
  ------------------
  |  Branch (3668:3): [True: 0, False: 0]
  ------------------
 3669|      0|		(y->value.decimal.hi != 0))) {
  ------------------
  |  Branch (3669:3): [True: 0, False: 0]
  ------------------
 3670|      0|        return (1);
 3671|      0|    }
 3672|       |    /*
 3673|       |     * If it's not simply determined by a difference in sign,
 3674|       |     * then we need to compare the actual values of the two nums.
 3675|       |     * To do this, we start by looking at the integral parts.
 3676|       |     * If the number of integral digits differ, then we have our
 3677|       |     * answer.
 3678|       |     */
 3679|      4|    integx = x->value.decimal.total - x->value.decimal.frac;
 3680|      4|    integy = y->value.decimal.total - y->value.decimal.frac;
 3681|       |    /*
 3682|       |    * NOTE: We changed the "total" for values like "0.1"
 3683|       |    *   (or "-0.1" or ".1") to be 1, which was 2 previously.
 3684|       |    *   Therefore the special case, when such values are
 3685|       |    *   compared with 0, needs to be handled separately;
 3686|       |    *   otherwise a zero would be recognized incorrectly as
 3687|       |    *   greater than those values. This has the nice side effect
 3688|       |    *   that we gain an overall optimized comparison with zeroes.
 3689|       |    * Note that a "0" has a "total" of 1 already.
 3690|       |    */
 3691|      4|    if (integx == 1) {
  ------------------
  |  Branch (3691:9): [True: 0, False: 4]
  ------------------
 3692|      0|	if (x->value.decimal.lo == 0) {
  ------------------
  |  Branch (3692:6): [True: 0, False: 0]
  ------------------
 3693|      0|	    if (integy != 1)
  ------------------
  |  Branch (3693:10): [True: 0, False: 0]
  ------------------
 3694|      0|		return -order;
 3695|      0|	    else if (y->value.decimal.lo != 0)
  ------------------
  |  Branch (3695:15): [True: 0, False: 0]
  ------------------
 3696|      0|		return -order;
 3697|      0|	    else
 3698|      0|		return(0);
 3699|      0|	}
 3700|      0|    }
 3701|      4|    if (integy == 1) {
  ------------------
  |  Branch (3701:9): [True: 2, False: 2]
  ------------------
 3702|      2|	if (y->value.decimal.lo == 0) {
  ------------------
  |  Branch (3702:6): [True: 1, False: 1]
  ------------------
 3703|      1|	    if (integx != 1)
  ------------------
  |  Branch (3703:10): [True: 1, False: 0]
  ------------------
 3704|      1|		return order;
 3705|      0|	    else if (x->value.decimal.lo != 0)
  ------------------
  |  Branch (3705:15): [True: 0, False: 0]
  ------------------
 3706|      0|		return order;
 3707|      0|	    else
 3708|      0|		return(0);
 3709|      1|	}
 3710|      2|    }
 3711|       |
 3712|      3|    if (integx > integy)
  ------------------
  |  Branch (3712:9): [True: 1, False: 2]
  ------------------
 3713|      1|	return order;
 3714|      2|    else if (integy > integx)
  ------------------
  |  Branch (3714:14): [True: 0, False: 2]
  ------------------
 3715|      0|	return -order;
 3716|       |
 3717|       |    /*
 3718|       |     * If the number of integral digits is the same for both numbers,
 3719|       |     * then things get a little more complicated.  We need to "normalize"
 3720|       |     * the numbers in order to properly compare them.  To do this, we
 3721|       |     * look at the total length of each number (length => number of
 3722|       |     * significant digits), and divide the "shorter" by 10 (decreasing
 3723|       |     * the length) until they are of equal length.
 3724|       |     */
 3725|      2|    dlen = x->value.decimal.total - y->value.decimal.total;
 3726|      2|    if (dlen < 0) {	/* y has more digits than x */
  ------------------
  |  Branch (3726:9): [True: 0, False: 2]
  ------------------
 3727|      0|	swp = x;
 3728|      0|	hi = y->value.decimal.hi;
 3729|      0|	mi = y->value.decimal.mi;
 3730|      0|	lo = y->value.decimal.lo;
 3731|      0|	dlen = -dlen;
 3732|      0|	order = -order;
 3733|      2|    } else {		/* x has more digits than y */
 3734|      2|	swp = y;
 3735|      2|	hi = x->value.decimal.hi;
 3736|      2|	mi = x->value.decimal.mi;
 3737|      2|	lo = x->value.decimal.lo;
 3738|      2|    }
 3739|      2|    while (dlen > 8) {	/* in effect, right shift by 10**8 */
  ------------------
  |  Branch (3739:12): [True: 0, False: 2]
  ------------------
 3740|      0|	lo = mi;
 3741|      0|	mi = hi;
 3742|      0|	hi = 0;
 3743|      0|	dlen -= 8;
 3744|      0|    }
 3745|      2|    while (dlen > 0) {
  ------------------
  |  Branch (3745:12): [True: 0, False: 2]
  ------------------
 3746|      0|	unsigned long rem1, rem2;
 3747|      0|	rem1 = (hi % 10) * 100000000L;
 3748|      0|	hi = hi / 10;
 3749|      0|	rem2 = (mi % 10) * 100000000L;
 3750|      0|	mi = (mi + rem1) / 10;
 3751|      0|	lo = (lo + rem2) / 10;
 3752|      0|	dlen--;
 3753|      0|    }
 3754|      2|    if (hi > swp->value.decimal.hi) {
  ------------------
  |  Branch (3754:9): [True: 0, False: 2]
  ------------------
 3755|      0|	return order;
 3756|      2|    } else if (hi == swp->value.decimal.hi) {
  ------------------
  |  Branch (3756:16): [True: 2, False: 0]
  ------------------
 3757|      2|	if (mi > swp->value.decimal.mi) {
  ------------------
  |  Branch (3757:6): [True: 0, False: 2]
  ------------------
 3758|      0|	    return order;
 3759|      2|	} else if (mi == swp->value.decimal.mi) {
  ------------------
  |  Branch (3759:13): [True: 2, False: 0]
  ------------------
 3760|      2|	    if (lo > swp->value.decimal.lo) {
  ------------------
  |  Branch (3760:10): [True: 2, False: 0]
  ------------------
 3761|      2|		return order;
 3762|      2|	    } else if (lo == swp->value.decimal.lo) {
  ------------------
  |  Branch (3762:17): [True: 0, False: 0]
  ------------------
 3763|      0|		if (x->value.decimal.total == y->value.decimal.total) {
  ------------------
  |  Branch (3763:7): [True: 0, False: 0]
  ------------------
 3764|      0|		    return 0;
 3765|      0|		} else {
 3766|      0|		    return order;
 3767|      0|		}
 3768|      0|	    }
 3769|      2|	}
 3770|      2|    }
 3771|      0|    return -order;
 3772|      2|}
xmlschemastypes.c:xmlSchemaCompareDurations:
 3786|      7|{
 3787|      7|    long carry, mon, day;
 3788|      7|    double sec;
 3789|      7|    int invert = 1;
 3790|      7|    long xmon, xday, myear, minday, maxday;
 3791|      7|    static const long dayRange [2][12] = {
 3792|      7|        { 0, 28, 59, 89, 120, 150, 181, 212, 242, 273, 303, 334, },
 3793|      7|        { 0, 31, 62, 92, 123, 153, 184, 215, 245, 276, 306, 337} };
 3794|       |
 3795|      7|    if ((x == NULL) || (y == NULL))
  ------------------
  |  Branch (3795:9): [True: 0, False: 7]
  |  Branch (3795:24): [True: 0, False: 7]
  ------------------
 3796|      0|        return -2;
 3797|       |
 3798|       |    /* months */
 3799|      7|    mon = x->value.dur.mon - y->value.dur.mon;
 3800|       |
 3801|       |    /* seconds */
 3802|      7|    sec = x->value.dur.sec - y->value.dur.sec;
 3803|      7|    carry = (long)(sec / SECS_PER_DAY);
  ------------------
  |  | 1287|      7|#define SECS_PER_DAY            (HOURS_PER_DAY * SECS_PER_HOUR)
  |  |  ------------------
  |  |  |  | 1285|      7|#define HOURS_PER_DAY           24
  |  |  ------------------
  |  |               #define SECS_PER_DAY            (HOURS_PER_DAY * SECS_PER_HOUR)
  |  |  ------------------
  |  |  |  | 1286|      7|#define SECS_PER_HOUR           (MINS_PER_HOUR * SECS_PER_MIN)
  |  |  |  |  ------------------
  |  |  |  |  |  | 1284|      7|#define MINS_PER_HOUR           60
  |  |  |  |  ------------------
  |  |  |  |               #define SECS_PER_HOUR           (MINS_PER_HOUR * SECS_PER_MIN)
  |  |  |  |  ------------------
  |  |  |  |  |  | 1283|      7|#define SECS_PER_MIN            60
  |  |  |  |  ------------------
  |  |  ------------------
  ------------------
 3804|      7|    sec -= ((double)carry) * SECS_PER_DAY;
  ------------------
  |  | 1287|      7|#define SECS_PER_DAY            (HOURS_PER_DAY * SECS_PER_HOUR)
  |  |  ------------------
  |  |  |  | 1285|      7|#define HOURS_PER_DAY           24
  |  |  ------------------
  |  |               #define SECS_PER_DAY            (HOURS_PER_DAY * SECS_PER_HOUR)
  |  |  ------------------
  |  |  |  | 1286|      7|#define SECS_PER_HOUR           (MINS_PER_HOUR * SECS_PER_MIN)
  |  |  |  |  ------------------
  |  |  |  |  |  | 1284|      7|#define MINS_PER_HOUR           60
  |  |  |  |  ------------------
  |  |  |  |               #define SECS_PER_HOUR           (MINS_PER_HOUR * SECS_PER_MIN)
  |  |  |  |  ------------------
  |  |  |  |  |  | 1283|      7|#define SECS_PER_MIN            60
  |  |  |  |  ------------------
  |  |  ------------------
  ------------------
 3805|       |
 3806|       |    /* days */
 3807|      7|    day = x->value.dur.day - y->value.dur.day + carry;
 3808|       |
 3809|       |    /* easy test */
 3810|      7|    if (mon == 0) {
  ------------------
  |  Branch (3810:9): [True: 3, False: 4]
  ------------------
 3811|      3|        if (day == 0)
  ------------------
  |  Branch (3811:13): [True: 2, False: 1]
  ------------------
 3812|      2|            if (sec == 0.0)
  ------------------
  |  Branch (3812:17): [True: 0, False: 2]
  ------------------
 3813|      0|                return 0;
 3814|      2|            else if (sec < 0.0)
  ------------------
  |  Branch (3814:22): [True: 0, False: 2]
  ------------------
 3815|      0|                return -1;
 3816|      2|            else
 3817|      2|                return 1;
 3818|      1|        else if (day < 0)
  ------------------
  |  Branch (3818:18): [True: 0, False: 1]
  ------------------
 3819|      0|            return -1;
 3820|      1|        else
 3821|      1|            return 1;
 3822|      3|    }
 3823|       |
 3824|      4|    if (mon > 0) {
  ------------------
  |  Branch (3824:9): [True: 4, False: 0]
  ------------------
 3825|      4|        if ((day >= 0) && (sec >= 0.0))
  ------------------
  |  Branch (3825:13): [True: 4, False: 0]
  |  Branch (3825:27): [True: 4, False: 0]
  ------------------
 3826|      4|            return 1;
 3827|      0|        else {
 3828|      0|            xmon = mon;
 3829|      0|            xday = -day;
 3830|      0|        }
 3831|      4|    } else if ((day <= 0) && (sec <= 0.0)) {
  ------------------
  |  Branch (3831:16): [True: 0, False: 0]
  |  Branch (3831:30): [True: 0, False: 0]
  ------------------
 3832|      0|        return -1;
 3833|      0|    } else {
 3834|      0|	invert = -1;
 3835|      0|        xmon = -mon;
 3836|      0|        xday = day;
 3837|      0|    }
 3838|       |
 3839|      0|    myear = xmon / 12;
 3840|      0|    if (myear == 0) {
  ------------------
  |  Branch (3840:9): [True: 0, False: 0]
  ------------------
 3841|      0|	minday = 0;
 3842|      0|	maxday = 0;
 3843|      0|    } else {
 3844|      0|        if (myear > LONG_MAX / 366)
  ------------------
  |  Branch (3844:13): [True: 0, False: 0]
  ------------------
 3845|      0|            return -2;
 3846|       |        /* FIXME: This doesn't take leap year exceptions every 100/400 years
 3847|       |           into account. */
 3848|      0|	maxday = 365 * myear + (myear + 3) / 4;
 3849|       |        /* FIXME: Needs to be calculated separately */
 3850|      0|	minday = maxday - 1;
 3851|      0|    }
 3852|       |
 3853|      0|    xmon = xmon % 12;
 3854|      0|    minday += dayRange[0][xmon];
 3855|      0|    maxday += dayRange[1][xmon];
 3856|       |
 3857|      0|    if ((maxday == minday) && (maxday == xday))
  ------------------
  |  Branch (3857:9): [True: 0, False: 0]
  |  Branch (3857:31): [True: 0, False: 0]
  ------------------
 3858|      0|	return(0); /* can this really happen ? */
 3859|      0|    if (maxday < xday)
  ------------------
  |  Branch (3859:9): [True: 0, False: 0]
  ------------------
 3860|      0|        return(-invert);
 3861|      0|    if (minday > xday)
  ------------------
  |  Branch (3861:9): [True: 0, False: 0]
  ------------------
 3862|      0|        return(invert);
 3863|       |
 3864|       |    /* indeterminate */
 3865|      0|    return 2;
 3866|      0|}
xmlschemastypes.c:xmlSchemaCompareDates:
 4226|     10|{
 4227|     10|    unsigned char xmask, ymask, xor_mask, and_mask;
 4228|     10|    xmlSchemaValPtr p1, p2, q1, q2;
 4229|     10|    long p1d, p2d, q1d, q2d;
 4230|       |
 4231|     10|    if ((x == NULL) || (y == NULL))
  ------------------
  |  Branch (4231:9): [True: 0, False: 10]
  |  Branch (4231:24): [True: 0, False: 10]
  ------------------
 4232|      0|        return -2;
 4233|       |
 4234|     10|    if ((x->value.date.year > LONG_MAX / 366) ||
  ------------------
  |  Branch (4234:9): [True: 0, False: 10]
  ------------------
 4235|     10|        (x->value.date.year < LONG_MIN / 366) ||
  ------------------
  |  Branch (4235:9): [True: 0, False: 10]
  ------------------
 4236|     10|        (y->value.date.year > LONG_MAX / 366) ||
  ------------------
  |  Branch (4236:9): [True: 0, False: 10]
  ------------------
 4237|     10|        (y->value.date.year < LONG_MIN / 366)) {
  ------------------
  |  Branch (4237:9): [True: 0, False: 10]
  ------------------
 4238|       |        /* Possible overflow when converting to days. */
 4239|      0|        return -2;
 4240|      0|    }
 4241|       |
 4242|     10|    if (x->value.date.tz_flag) {
  ------------------
  |  Branch (4242:9): [True: 6, False: 4]
  ------------------
 4243|       |
 4244|      6|        if (!y->value.date.tz_flag) {
  ------------------
  |  Branch (4244:13): [True: 0, False: 6]
  ------------------
 4245|      0|            p1 = xmlSchemaDateNormalize(x, 0);
 4246|      0|            if (p1 == NULL)
  ------------------
  |  Branch (4246:17): [True: 0, False: 0]
  ------------------
 4247|      0|                return -2;
 4248|      0|            p1d = _xmlSchemaDateCastYMToDays(p1) + p1->value.date.day;
 4249|       |            /* normalize y + 14:00 */
 4250|      0|            q1 = xmlSchemaDateNormalize(y, (14 * SECS_PER_HOUR));
  ------------------
  |  | 1286|      0|#define SECS_PER_HOUR           (MINS_PER_HOUR * SECS_PER_MIN)
  |  |  ------------------
  |  |  |  | 1284|      0|#define MINS_PER_HOUR           60
  |  |  ------------------
  |  |               #define SECS_PER_HOUR           (MINS_PER_HOUR * SECS_PER_MIN)
  |  |  ------------------
  |  |  |  | 1283|      0|#define SECS_PER_MIN            60
  |  |  ------------------
  ------------------
 4251|      0|            if (q1 == NULL) {
  ------------------
  |  Branch (4251:17): [True: 0, False: 0]
  ------------------
 4252|      0|		xmlSchemaFreeValue(p1);
 4253|      0|                return -2;
 4254|      0|            }
 4255|       |
 4256|      0|            q1d = _xmlSchemaDateCastYMToDays(q1) + q1->value.date.day;
 4257|      0|            if (p1d < q1d) {
  ------------------
  |  Branch (4257:17): [True: 0, False: 0]
  ------------------
 4258|      0|		xmlSchemaFreeValue(p1);
 4259|      0|		xmlSchemaFreeValue(q1);
 4260|      0|                return -1;
 4261|      0|	    } else if (p1d == q1d) {
  ------------------
  |  Branch (4261:17): [True: 0, False: 0]
  ------------------
 4262|      0|                double sec;
 4263|       |
 4264|      0|                sec = TIME_TO_NUMBER(p1) - TIME_TO_NUMBER(q1);
  ------------------
  |  | 4209|      0|    ((double)((dt->value.date.hour * SECS_PER_HOUR) +   \
  |  |  ------------------
  |  |  |  | 1286|      0|#define SECS_PER_HOUR           (MINS_PER_HOUR * SECS_PER_MIN)
  |  |  |  |  ------------------
  |  |  |  |  |  | 1284|      0|#define MINS_PER_HOUR           60
  |  |  |  |  ------------------
  |  |  |  |               #define SECS_PER_HOUR           (MINS_PER_HOUR * SECS_PER_MIN)
  |  |  |  |  ------------------
  |  |  |  |  |  | 1283|      0|#define SECS_PER_MIN            60
  |  |  |  |  ------------------
  |  |  ------------------
  |  | 4210|      0|              (dt->value.date.min * SECS_PER_MIN) +	\
  |  |  ------------------
  |  |  |  | 1283|      0|#define SECS_PER_MIN            60
  |  |  ------------------
  |  | 4211|      0|              (dt->value.date.tzo * SECS_PER_MIN)) +	\
  |  |  ------------------
  |  |  |  | 1283|      0|#define SECS_PER_MIN            60
  |  |  ------------------
  |  | 4212|      0|               dt->value.date.sec)
  ------------------
                              sec = TIME_TO_NUMBER(p1) - TIME_TO_NUMBER(q1);
  ------------------
  |  | 4209|      0|    ((double)((dt->value.date.hour * SECS_PER_HOUR) +   \
  |  |  ------------------
  |  |  |  | 1286|      0|#define SECS_PER_HOUR           (MINS_PER_HOUR * SECS_PER_MIN)
  |  |  |  |  ------------------
  |  |  |  |  |  | 1284|      0|#define MINS_PER_HOUR           60
  |  |  |  |  ------------------
  |  |  |  |               #define SECS_PER_HOUR           (MINS_PER_HOUR * SECS_PER_MIN)
  |  |  |  |  ------------------
  |  |  |  |  |  | 1283|      0|#define SECS_PER_MIN            60
  |  |  |  |  ------------------
  |  |  ------------------
  |  | 4210|      0|              (dt->value.date.min * SECS_PER_MIN) +	\
  |  |  ------------------
  |  |  |  | 1283|      0|#define SECS_PER_MIN            60
  |  |  ------------------
  |  | 4211|      0|              (dt->value.date.tzo * SECS_PER_MIN)) +	\
  |  |  ------------------
  |  |  |  | 1283|      0|#define SECS_PER_MIN            60
  |  |  ------------------
  |  | 4212|      0|               dt->value.date.sec)
  ------------------
 4265|      0|                if (sec < 0.0) {
  ------------------
  |  Branch (4265:21): [True: 0, False: 0]
  ------------------
 4266|      0|		    xmlSchemaFreeValue(p1);
 4267|      0|		    xmlSchemaFreeValue(q1);
 4268|      0|                    return -1;
 4269|      0|		} else {
 4270|      0|		    int ret = 0;
 4271|       |                    /* normalize y - 14:00 */
 4272|      0|                    q2 = xmlSchemaDateNormalize(y, -(14 * SECS_PER_HOUR));
  ------------------
  |  | 1286|      0|#define SECS_PER_HOUR           (MINS_PER_HOUR * SECS_PER_MIN)
  |  |  ------------------
  |  |  |  | 1284|      0|#define MINS_PER_HOUR           60
  |  |  ------------------
  |  |               #define SECS_PER_HOUR           (MINS_PER_HOUR * SECS_PER_MIN)
  |  |  ------------------
  |  |  |  | 1283|      0|#define SECS_PER_MIN            60
  |  |  ------------------
  ------------------
 4273|      0|                    if (q2 == NULL) {
  ------------------
  |  Branch (4273:25): [True: 0, False: 0]
  ------------------
 4274|      0|                        xmlSchemaFreeValue(p1);
 4275|      0|                        xmlSchemaFreeValue(q1);
 4276|      0|                        return -2;
 4277|      0|                    }
 4278|      0|                    q2d = _xmlSchemaDateCastYMToDays(q2) + q2->value.date.day;
 4279|      0|                    if (p1d > q2d)
  ------------------
  |  Branch (4279:25): [True: 0, False: 0]
  ------------------
 4280|      0|                        ret = 1;
 4281|      0|                    else if (p1d == q2d) {
  ------------------
  |  Branch (4281:30): [True: 0, False: 0]
  ------------------
 4282|      0|                        sec = TIME_TO_NUMBER(p1) - TIME_TO_NUMBER(q2);
  ------------------
  |  | 4209|      0|    ((double)((dt->value.date.hour * SECS_PER_HOUR) +   \
  |  |  ------------------
  |  |  |  | 1286|      0|#define SECS_PER_HOUR           (MINS_PER_HOUR * SECS_PER_MIN)
  |  |  |  |  ------------------
  |  |  |  |  |  | 1284|      0|#define MINS_PER_HOUR           60
  |  |  |  |  ------------------
  |  |  |  |               #define SECS_PER_HOUR           (MINS_PER_HOUR * SECS_PER_MIN)
  |  |  |  |  ------------------
  |  |  |  |  |  | 1283|      0|#define SECS_PER_MIN            60
  |  |  |  |  ------------------
  |  |  ------------------
  |  | 4210|      0|              (dt->value.date.min * SECS_PER_MIN) +	\
  |  |  ------------------
  |  |  |  | 1283|      0|#define SECS_PER_MIN            60
  |  |  ------------------
  |  | 4211|      0|              (dt->value.date.tzo * SECS_PER_MIN)) +	\
  |  |  ------------------
  |  |  |  | 1283|      0|#define SECS_PER_MIN            60
  |  |  ------------------
  |  | 4212|      0|               dt->value.date.sec)
  ------------------
                                      sec = TIME_TO_NUMBER(p1) - TIME_TO_NUMBER(q2);
  ------------------
  |  | 4209|      0|    ((double)((dt->value.date.hour * SECS_PER_HOUR) +   \
  |  |  ------------------
  |  |  |  | 1286|      0|#define SECS_PER_HOUR           (MINS_PER_HOUR * SECS_PER_MIN)
  |  |  |  |  ------------------
  |  |  |  |  |  | 1284|      0|#define MINS_PER_HOUR           60
  |  |  |  |  ------------------
  |  |  |  |               #define SECS_PER_HOUR           (MINS_PER_HOUR * SECS_PER_MIN)
  |  |  |  |  ------------------
  |  |  |  |  |  | 1283|      0|#define SECS_PER_MIN            60
  |  |  |  |  ------------------
  |  |  ------------------
  |  | 4210|      0|              (dt->value.date.min * SECS_PER_MIN) +	\
  |  |  ------------------
  |  |  |  | 1283|      0|#define SECS_PER_MIN            60
  |  |  ------------------
  |  | 4211|      0|              (dt->value.date.tzo * SECS_PER_MIN)) +	\
  |  |  ------------------
  |  |  |  | 1283|      0|#define SECS_PER_MIN            60
  |  |  ------------------
  |  | 4212|      0|               dt->value.date.sec)
  ------------------
 4283|      0|                        if (sec > 0.0)
  ------------------
  |  Branch (4283:29): [True: 0, False: 0]
  ------------------
 4284|      0|                            ret = 1;
 4285|      0|                        else
 4286|      0|                            ret = 2; /* indeterminate */
 4287|      0|                    }
 4288|      0|		    xmlSchemaFreeValue(p1);
 4289|      0|		    xmlSchemaFreeValue(q1);
 4290|      0|		    xmlSchemaFreeValue(q2);
 4291|      0|		    if (ret != 0)
  ------------------
  |  Branch (4291:11): [True: 0, False: 0]
  ------------------
 4292|      0|		        return(ret);
 4293|      0|                }
 4294|      0|            } else {
 4295|      0|		xmlSchemaFreeValue(p1);
 4296|      0|		xmlSchemaFreeValue(q1);
 4297|      0|	    }
 4298|      0|        }
 4299|      6|    } else if (y->value.date.tz_flag) {
  ------------------
  |  Branch (4299:16): [True: 0, False: 4]
  ------------------
 4300|      0|        q1 = xmlSchemaDateNormalize(y, 0);
 4301|      0|        if (q1 == NULL)
  ------------------
  |  Branch (4301:13): [True: 0, False: 0]
  ------------------
 4302|      0|            return -2;
 4303|      0|        q1d = _xmlSchemaDateCastYMToDays(q1) + q1->value.date.day;
 4304|       |
 4305|       |        /* normalize x - 14:00 */
 4306|      0|        p1 = xmlSchemaDateNormalize(x, -(14 * SECS_PER_HOUR));
  ------------------
  |  | 1286|      0|#define SECS_PER_HOUR           (MINS_PER_HOUR * SECS_PER_MIN)
  |  |  ------------------
  |  |  |  | 1284|      0|#define MINS_PER_HOUR           60
  |  |  ------------------
  |  |               #define SECS_PER_HOUR           (MINS_PER_HOUR * SECS_PER_MIN)
  |  |  ------------------
  |  |  |  | 1283|      0|#define SECS_PER_MIN            60
  |  |  ------------------
  ------------------
 4307|      0|        if (p1 == NULL) {
  ------------------
  |  Branch (4307:13): [True: 0, False: 0]
  ------------------
 4308|      0|	    xmlSchemaFreeValue(q1);
 4309|      0|            return -2;
 4310|      0|        }
 4311|      0|        p1d = _xmlSchemaDateCastYMToDays(p1) + p1->value.date.day;
 4312|       |
 4313|      0|        if (p1d < q1d) {
  ------------------
  |  Branch (4313:13): [True: 0, False: 0]
  ------------------
 4314|      0|	    xmlSchemaFreeValue(p1);
 4315|      0|	    xmlSchemaFreeValue(q1);
 4316|      0|            return -1;
 4317|      0|	} else if (p1d == q1d) {
  ------------------
  |  Branch (4317:13): [True: 0, False: 0]
  ------------------
 4318|      0|            double sec;
 4319|       |
 4320|      0|            sec = TIME_TO_NUMBER(p1) - TIME_TO_NUMBER(q1);
  ------------------
  |  | 4209|      0|    ((double)((dt->value.date.hour * SECS_PER_HOUR) +   \
  |  |  ------------------
  |  |  |  | 1286|      0|#define SECS_PER_HOUR           (MINS_PER_HOUR * SECS_PER_MIN)
  |  |  |  |  ------------------
  |  |  |  |  |  | 1284|      0|#define MINS_PER_HOUR           60
  |  |  |  |  ------------------
  |  |  |  |               #define SECS_PER_HOUR           (MINS_PER_HOUR * SECS_PER_MIN)
  |  |  |  |  ------------------
  |  |  |  |  |  | 1283|      0|#define SECS_PER_MIN            60
  |  |  |  |  ------------------
  |  |  ------------------
  |  | 4210|      0|              (dt->value.date.min * SECS_PER_MIN) +	\
  |  |  ------------------
  |  |  |  | 1283|      0|#define SECS_PER_MIN            60
  |  |  ------------------
  |  | 4211|      0|              (dt->value.date.tzo * SECS_PER_MIN)) +	\
  |  |  ------------------
  |  |  |  | 1283|      0|#define SECS_PER_MIN            60
  |  |  ------------------
  |  | 4212|      0|               dt->value.date.sec)
  ------------------
                          sec = TIME_TO_NUMBER(p1) - TIME_TO_NUMBER(q1);
  ------------------
  |  | 4209|      0|    ((double)((dt->value.date.hour * SECS_PER_HOUR) +   \
  |  |  ------------------
  |  |  |  | 1286|      0|#define SECS_PER_HOUR           (MINS_PER_HOUR * SECS_PER_MIN)
  |  |  |  |  ------------------
  |  |  |  |  |  | 1284|      0|#define MINS_PER_HOUR           60
  |  |  |  |  ------------------
  |  |  |  |               #define SECS_PER_HOUR           (MINS_PER_HOUR * SECS_PER_MIN)
  |  |  |  |  ------------------
  |  |  |  |  |  | 1283|      0|#define SECS_PER_MIN            60
  |  |  |  |  ------------------
  |  |  ------------------
  |  | 4210|      0|              (dt->value.date.min * SECS_PER_MIN) +	\
  |  |  ------------------
  |  |  |  | 1283|      0|#define SECS_PER_MIN            60
  |  |  ------------------
  |  | 4211|      0|              (dt->value.date.tzo * SECS_PER_MIN)) +	\
  |  |  ------------------
  |  |  |  | 1283|      0|#define SECS_PER_MIN            60
  |  |  ------------------
  |  | 4212|      0|               dt->value.date.sec)
  ------------------
 4321|      0|            if (sec < 0.0) {
  ------------------
  |  Branch (4321:17): [True: 0, False: 0]
  ------------------
 4322|      0|		xmlSchemaFreeValue(p1);
 4323|      0|		xmlSchemaFreeValue(q1);
 4324|      0|                return -1;
 4325|      0|	    } else {
 4326|      0|	        int ret = 0;
 4327|       |                /* normalize x + 14:00 */
 4328|      0|                p2 = xmlSchemaDateNormalize(x, (14 * SECS_PER_HOUR));
  ------------------
  |  | 1286|      0|#define SECS_PER_HOUR           (MINS_PER_HOUR * SECS_PER_MIN)
  |  |  ------------------
  |  |  |  | 1284|      0|#define MINS_PER_HOUR           60
  |  |  ------------------
  |  |               #define SECS_PER_HOUR           (MINS_PER_HOUR * SECS_PER_MIN)
  |  |  ------------------
  |  |  |  | 1283|      0|#define SECS_PER_MIN            60
  |  |  ------------------
  ------------------
 4329|      0|                if (p2 == NULL) {
  ------------------
  |  Branch (4329:21): [True: 0, False: 0]
  ------------------
 4330|      0|                    xmlSchemaFreeValue(p1);
 4331|      0|                    xmlSchemaFreeValue(q1);
 4332|      0|                    return -2;
 4333|      0|                }
 4334|      0|                p2d = _xmlSchemaDateCastYMToDays(p2) + p2->value.date.day;
 4335|       |
 4336|      0|                if (p2d > q1d) {
  ------------------
  |  Branch (4336:21): [True: 0, False: 0]
  ------------------
 4337|      0|                    ret = 1;
 4338|      0|		} else if (p2d == q1d) {
  ------------------
  |  Branch (4338:14): [True: 0, False: 0]
  ------------------
 4339|      0|                    sec = TIME_TO_NUMBER(p2) - TIME_TO_NUMBER(q1);
  ------------------
  |  | 4209|      0|    ((double)((dt->value.date.hour * SECS_PER_HOUR) +   \
  |  |  ------------------
  |  |  |  | 1286|      0|#define SECS_PER_HOUR           (MINS_PER_HOUR * SECS_PER_MIN)
  |  |  |  |  ------------------
  |  |  |  |  |  | 1284|      0|#define MINS_PER_HOUR           60
  |  |  |  |  ------------------
  |  |  |  |               #define SECS_PER_HOUR           (MINS_PER_HOUR * SECS_PER_MIN)
  |  |  |  |  ------------------
  |  |  |  |  |  | 1283|      0|#define SECS_PER_MIN            60
  |  |  |  |  ------------------
  |  |  ------------------
  |  | 4210|      0|              (dt->value.date.min * SECS_PER_MIN) +	\
  |  |  ------------------
  |  |  |  | 1283|      0|#define SECS_PER_MIN            60
  |  |  ------------------
  |  | 4211|      0|              (dt->value.date.tzo * SECS_PER_MIN)) +	\
  |  |  ------------------
  |  |  |  | 1283|      0|#define SECS_PER_MIN            60
  |  |  ------------------
  |  | 4212|      0|               dt->value.date.sec)
  ------------------
                                  sec = TIME_TO_NUMBER(p2) - TIME_TO_NUMBER(q1);
  ------------------
  |  | 4209|      0|    ((double)((dt->value.date.hour * SECS_PER_HOUR) +   \
  |  |  ------------------
  |  |  |  | 1286|      0|#define SECS_PER_HOUR           (MINS_PER_HOUR * SECS_PER_MIN)
  |  |  |  |  ------------------
  |  |  |  |  |  | 1284|      0|#define MINS_PER_HOUR           60
  |  |  |  |  ------------------
  |  |  |  |               #define SECS_PER_HOUR           (MINS_PER_HOUR * SECS_PER_MIN)
  |  |  |  |  ------------------
  |  |  |  |  |  | 1283|      0|#define SECS_PER_MIN            60
  |  |  |  |  ------------------
  |  |  ------------------
  |  | 4210|      0|              (dt->value.date.min * SECS_PER_MIN) +	\
  |  |  ------------------
  |  |  |  | 1283|      0|#define SECS_PER_MIN            60
  |  |  ------------------
  |  | 4211|      0|              (dt->value.date.tzo * SECS_PER_MIN)) +	\
  |  |  ------------------
  |  |  |  | 1283|      0|#define SECS_PER_MIN            60
  |  |  ------------------
  |  | 4212|      0|               dt->value.date.sec)
  ------------------
 4340|      0|                    if (sec > 0.0)
  ------------------
  |  Branch (4340:25): [True: 0, False: 0]
  ------------------
 4341|      0|                        ret = 1;
 4342|      0|                    else
 4343|      0|                        ret = 2; /* indeterminate */
 4344|      0|                }
 4345|      0|		xmlSchemaFreeValue(p1);
 4346|      0|		xmlSchemaFreeValue(q1);
 4347|      0|		xmlSchemaFreeValue(p2);
 4348|      0|		if (ret != 0)
  ------------------
  |  Branch (4348:7): [True: 0, False: 0]
  ------------------
 4349|      0|		    return(ret);
 4350|      0|            }
 4351|      0|	} else {
 4352|      0|	    xmlSchemaFreeValue(p1);
 4353|      0|	    xmlSchemaFreeValue(q1);
 4354|      0|        }
 4355|      0|    }
 4356|       |
 4357|       |    /*
 4358|       |     * if the same type then calculate the difference
 4359|       |     */
 4360|     10|    if (x->type == y->type) {
  ------------------
  |  Branch (4360:9): [True: 10, False: 0]
  ------------------
 4361|     10|        int ret = 0;
 4362|     10|        q1 = xmlSchemaDateNormalize(y, 0);
 4363|     10|        if (q1 == NULL)
  ------------------
  |  Branch (4363:13): [True: 0, False: 10]
  ------------------
 4364|      0|            return -2;
 4365|     10|        q1d = _xmlSchemaDateCastYMToDays(q1) + q1->value.date.day;
 4366|       |
 4367|     10|        p1 = xmlSchemaDateNormalize(x, 0);
 4368|     10|        if (p1 == NULL) {
  ------------------
  |  Branch (4368:13): [True: 0, False: 10]
  ------------------
 4369|      0|	    xmlSchemaFreeValue(q1);
 4370|      0|            return -2;
 4371|      0|        }
 4372|     10|        p1d = _xmlSchemaDateCastYMToDays(p1) + p1->value.date.day;
 4373|       |
 4374|     10|        if (p1d < q1d) {
  ------------------
  |  Branch (4374:13): [True: 0, False: 10]
  ------------------
 4375|      0|            ret = -1;
 4376|     10|	} else if (p1d > q1d) {
  ------------------
  |  Branch (4376:13): [True: 8, False: 2]
  ------------------
 4377|      8|            ret = 1;
 4378|      8|	} else {
 4379|      2|            double sec;
 4380|       |
 4381|      2|            sec = TIME_TO_NUMBER(p1) - TIME_TO_NUMBER(q1);
  ------------------
  |  | 4209|      2|    ((double)((dt->value.date.hour * SECS_PER_HOUR) +   \
  |  |  ------------------
  |  |  |  | 1286|      2|#define SECS_PER_HOUR           (MINS_PER_HOUR * SECS_PER_MIN)
  |  |  |  |  ------------------
  |  |  |  |  |  | 1284|      2|#define MINS_PER_HOUR           60
  |  |  |  |  ------------------
  |  |  |  |               #define SECS_PER_HOUR           (MINS_PER_HOUR * SECS_PER_MIN)
  |  |  |  |  ------------------
  |  |  |  |  |  | 1283|      2|#define SECS_PER_MIN            60
  |  |  |  |  ------------------
  |  |  ------------------
  |  | 4210|      2|              (dt->value.date.min * SECS_PER_MIN) +	\
  |  |  ------------------
  |  |  |  | 1283|      2|#define SECS_PER_MIN            60
  |  |  ------------------
  |  | 4211|      2|              (dt->value.date.tzo * SECS_PER_MIN)) +	\
  |  |  ------------------
  |  |  |  | 1283|      2|#define SECS_PER_MIN            60
  |  |  ------------------
  |  | 4212|      2|               dt->value.date.sec)
  ------------------
                          sec = TIME_TO_NUMBER(p1) - TIME_TO_NUMBER(q1);
  ------------------
  |  | 4209|      2|    ((double)((dt->value.date.hour * SECS_PER_HOUR) +   \
  |  |  ------------------
  |  |  |  | 1286|      2|#define SECS_PER_HOUR           (MINS_PER_HOUR * SECS_PER_MIN)
  |  |  |  |  ------------------
  |  |  |  |  |  | 1284|      2|#define MINS_PER_HOUR           60
  |  |  |  |  ------------------
  |  |  |  |               #define SECS_PER_HOUR           (MINS_PER_HOUR * SECS_PER_MIN)
  |  |  |  |  ------------------
  |  |  |  |  |  | 1283|      2|#define SECS_PER_MIN            60
  |  |  |  |  ------------------
  |  |  ------------------
  |  | 4210|      2|              (dt->value.date.min * SECS_PER_MIN) +	\
  |  |  ------------------
  |  |  |  | 1283|      2|#define SECS_PER_MIN            60
  |  |  ------------------
  |  | 4211|      2|              (dt->value.date.tzo * SECS_PER_MIN)) +	\
  |  |  ------------------
  |  |  |  | 1283|      2|#define SECS_PER_MIN            60
  |  |  ------------------
  |  | 4212|      2|               dt->value.date.sec)
  ------------------
 4382|      2|            if (sec < 0.0)
  ------------------
  |  Branch (4382:17): [True: 0, False: 2]
  ------------------
 4383|      0|                ret = -1;
 4384|      2|            else if (sec > 0.0)
  ------------------
  |  Branch (4384:22): [True: 2, False: 0]
  ------------------
 4385|      2|                ret = 1;
 4386|       |
 4387|      2|        }
 4388|     10|	xmlSchemaFreeValue(p1);
 4389|     10|	xmlSchemaFreeValue(q1);
 4390|     10|        return(ret);
 4391|     10|    }
 4392|       |
 4393|      0|    switch (x->type) {
 4394|      0|        case XML_SCHEMAS_DATETIME:
  ------------------
  |  Branch (4394:9): [True: 0, False: 0]
  ------------------
 4395|      0|            xmask = 0xf;
 4396|      0|            break;
 4397|      0|        case XML_SCHEMAS_DATE:
  ------------------
  |  Branch (4397:9): [True: 0, False: 0]
  ------------------
 4398|      0|            xmask = 0x7;
 4399|      0|            break;
 4400|      0|        case XML_SCHEMAS_GYEAR:
  ------------------
  |  Branch (4400:9): [True: 0, False: 0]
  ------------------
 4401|      0|            xmask = 0x1;
 4402|      0|            break;
 4403|      0|        case XML_SCHEMAS_GMONTH:
  ------------------
  |  Branch (4403:9): [True: 0, False: 0]
  ------------------
 4404|      0|            xmask = 0x2;
 4405|      0|            break;
 4406|      0|        case XML_SCHEMAS_GDAY:
  ------------------
  |  Branch (4406:9): [True: 0, False: 0]
  ------------------
 4407|      0|            xmask = 0x3;
 4408|      0|            break;
 4409|      0|        case XML_SCHEMAS_GYEARMONTH:
  ------------------
  |  Branch (4409:9): [True: 0, False: 0]
  ------------------
 4410|      0|            xmask = 0x3;
 4411|      0|            break;
 4412|      0|        case XML_SCHEMAS_GMONTHDAY:
  ------------------
  |  Branch (4412:9): [True: 0, False: 0]
  ------------------
 4413|      0|            xmask = 0x6;
 4414|      0|            break;
 4415|      0|        case XML_SCHEMAS_TIME:
  ------------------
  |  Branch (4415:9): [True: 0, False: 0]
  ------------------
 4416|      0|            xmask = 0x8;
 4417|      0|            break;
 4418|      0|        default:
  ------------------
  |  Branch (4418:9): [True: 0, False: 0]
  ------------------
 4419|      0|            xmask = 0;
 4420|      0|            break;
 4421|      0|    }
 4422|       |
 4423|      0|    switch (y->type) {
 4424|      0|        case XML_SCHEMAS_DATETIME:
  ------------------
  |  Branch (4424:9): [True: 0, False: 0]
  ------------------
 4425|      0|            ymask = 0xf;
 4426|      0|            break;
 4427|      0|        case XML_SCHEMAS_DATE:
  ------------------
  |  Branch (4427:9): [True: 0, False: 0]
  ------------------
 4428|      0|            ymask = 0x7;
 4429|      0|            break;
 4430|      0|        case XML_SCHEMAS_GYEAR:
  ------------------
  |  Branch (4430:9): [True: 0, False: 0]
  ------------------
 4431|      0|            ymask = 0x1;
 4432|      0|            break;
 4433|      0|        case XML_SCHEMAS_GMONTH:
  ------------------
  |  Branch (4433:9): [True: 0, False: 0]
  ------------------
 4434|      0|            ymask = 0x2;
 4435|      0|            break;
 4436|      0|        case XML_SCHEMAS_GDAY:
  ------------------
  |  Branch (4436:9): [True: 0, False: 0]
  ------------------
 4437|      0|            ymask = 0x3;
 4438|      0|            break;
 4439|      0|        case XML_SCHEMAS_GYEARMONTH:
  ------------------
  |  Branch (4439:9): [True: 0, False: 0]
  ------------------
 4440|      0|            ymask = 0x3;
 4441|      0|            break;
 4442|      0|        case XML_SCHEMAS_GMONTHDAY:
  ------------------
  |  Branch (4442:9): [True: 0, False: 0]
  ------------------
 4443|      0|            ymask = 0x6;
 4444|      0|            break;
 4445|      0|        case XML_SCHEMAS_TIME:
  ------------------
  |  Branch (4445:9): [True: 0, False: 0]
  ------------------
 4446|      0|            ymask = 0x8;
 4447|      0|            break;
 4448|      0|        default:
  ------------------
  |  Branch (4448:9): [True: 0, False: 0]
  ------------------
 4449|      0|            ymask = 0;
 4450|      0|            break;
 4451|      0|    }
 4452|       |
 4453|      0|    xor_mask = xmask ^ ymask;           /* mark type differences */
 4454|      0|    and_mask = xmask & ymask;           /* mark field specification */
 4455|       |
 4456|       |    /* year */
 4457|      0|    if (xor_mask & 1)
  ------------------
  |  Branch (4457:9): [True: 0, False: 0]
  ------------------
 4458|      0|        return 2; /* indeterminate */
 4459|      0|    else if (and_mask & 1) {
  ------------------
  |  Branch (4459:14): [True: 0, False: 0]
  ------------------
 4460|      0|        if (x->value.date.year < y->value.date.year)
  ------------------
  |  Branch (4460:13): [True: 0, False: 0]
  ------------------
 4461|      0|            return -1;
 4462|      0|        else if (x->value.date.year > y->value.date.year)
  ------------------
  |  Branch (4462:18): [True: 0, False: 0]
  ------------------
 4463|      0|            return 1;
 4464|      0|    }
 4465|       |
 4466|       |    /* month */
 4467|      0|    if (xor_mask & 2)
  ------------------
  |  Branch (4467:9): [True: 0, False: 0]
  ------------------
 4468|      0|        return 2; /* indeterminate */
 4469|      0|    else if (and_mask & 2) {
  ------------------
  |  Branch (4469:14): [True: 0, False: 0]
  ------------------
 4470|      0|        if (x->value.date.mon < y->value.date.mon)
  ------------------
  |  Branch (4470:13): [True: 0, False: 0]
  ------------------
 4471|      0|            return -1;
 4472|      0|        else if (x->value.date.mon > y->value.date.mon)
  ------------------
  |  Branch (4472:18): [True: 0, False: 0]
  ------------------
 4473|      0|            return 1;
 4474|      0|    }
 4475|       |
 4476|       |    /* day */
 4477|      0|    if (xor_mask & 4)
  ------------------
  |  Branch (4477:9): [True: 0, False: 0]
  ------------------
 4478|      0|        return 2; /* indeterminate */
 4479|      0|    else if (and_mask & 4) {
  ------------------
  |  Branch (4479:14): [True: 0, False: 0]
  ------------------
 4480|      0|        if (x->value.date.day < y->value.date.day)
  ------------------
  |  Branch (4480:13): [True: 0, False: 0]
  ------------------
 4481|      0|            return -1;
 4482|      0|        else if (x->value.date.day > y->value.date.day)
  ------------------
  |  Branch (4482:18): [True: 0, False: 0]
  ------------------
 4483|      0|            return 1;
 4484|      0|    }
 4485|       |
 4486|       |    /* time */
 4487|      0|    if (xor_mask & 8)
  ------------------
  |  Branch (4487:9): [True: 0, False: 0]
  ------------------
 4488|      0|        return 2; /* indeterminate */
 4489|      0|    else if (and_mask & 8) {
  ------------------
  |  Branch (4489:14): [True: 0, False: 0]
  ------------------
 4490|      0|        if (x->value.date.hour < y->value.date.hour)
  ------------------
  |  Branch (4490:13): [True: 0, False: 0]
  ------------------
 4491|      0|            return -1;
 4492|      0|        else if (x->value.date.hour > y->value.date.hour)
  ------------------
  |  Branch (4492:18): [True: 0, False: 0]
  ------------------
 4493|      0|            return 1;
 4494|      0|        else if (x->value.date.min < y->value.date.min)
  ------------------
  |  Branch (4494:18): [True: 0, False: 0]
  ------------------
 4495|      0|            return -1;
 4496|      0|        else if (x->value.date.min > y->value.date.min)
  ------------------
  |  Branch (4496:18): [True: 0, False: 0]
  ------------------
 4497|      0|            return 1;
 4498|      0|        else if (x->value.date.sec < y->value.date.sec)
  ------------------
  |  Branch (4498:18): [True: 0, False: 0]
  ------------------
 4499|      0|            return -1;
 4500|      0|        else if (x->value.date.sec > y->value.date.sec)
  ------------------
  |  Branch (4500:18): [True: 0, False: 0]
  ------------------
 4501|      0|            return 1;
 4502|      0|    }
 4503|       |
 4504|      0|    return 0;
 4505|      0|}
xmlschemastypes.c:_xmlSchemaDateCastYMToDays:
 4179|     20|{
 4180|     20|    long ret;
 4181|     20|    int mon;
 4182|       |
 4183|     20|    mon = dt->value.date.mon;
 4184|     20|    if (mon <= 0) mon = 1; /* normalization */
  ------------------
  |  Branch (4184:9): [True: 8, False: 12]
  ------------------
 4185|       |
 4186|     20|    if (dt->value.date.year <= 0)
  ------------------
  |  Branch (4186:9): [True: 8, False: 12]
  ------------------
 4187|      8|        ret = (dt->value.date.year * 365) +
 4188|      8|              (((dt->value.date.year+1)/4)-((dt->value.date.year+1)/100)+
 4189|      8|               ((dt->value.date.year+1)/400)) +
 4190|      8|              DAY_IN_YEAR(0, mon, dt->value.date.year);
  ------------------
  |  | 1296|      8|        ((IS_LEAP(year) ?					\
  |  |  ------------------
  |  |  |  | 1254|      8|	(((y % 4 == 0) && (y % 100 != 0)) || (y % 400 == 0))
  |  |  |  |  ------------------
  |  |  |  |  |  Branch (1254:4): [True: 8, False: 0]
  |  |  |  |  |  Branch (1254:20): [True: 0, False: 8]
  |  |  |  |  |  Branch (1254:39): [True: 8, False: 0]
  |  |  |  |  ------------------
  |  |  ------------------
  |  | 1297|      8|                dayInLeapYearByMonth[month - 1] :		\
  |  | 1298|      8|                dayInYearByMonth[month - 1]) + day)
  ------------------
 4191|     12|    else
 4192|     12|        ret = ((dt->value.date.year-1) * 365) +
 4193|     12|              (((dt->value.date.year-1)/4)-((dt->value.date.year-1)/100)+
 4194|     12|               ((dt->value.date.year-1)/400)) +
 4195|     12|              DAY_IN_YEAR(0, mon, dt->value.date.year);
  ------------------
  |  | 1296|     12|        ((IS_LEAP(year) ?					\
  |  |  ------------------
  |  |  |  | 1254|     12|	(((y % 4 == 0) && (y % 100 != 0)) || (y % 400 == 0))
  |  |  |  |  ------------------
  |  |  |  |  |  Branch (1254:4): [True: 5, False: 7]
  |  |  |  |  |  Branch (1254:20): [True: 5, False: 0]
  |  |  |  |  |  Branch (1254:39): [True: 0, False: 7]
  |  |  |  |  ------------------
  |  |  ------------------
  |  | 1297|     12|                dayInLeapYearByMonth[month - 1] :		\
  |  | 1298|     12|                dayInYearByMonth[month - 1]) + day)
  ------------------
 4196|       |
 4197|     20|    return ret;
 4198|     20|}
xmlschemastypes.c:xmlSchemaValidateLengthFacetInternal:
 5402|      1|{
 5403|      1|    unsigned int len = 0;
 5404|       |
 5405|      1|    if ((length == NULL) || (facet == NULL))
  ------------------
  |  Branch (5405:9): [True: 0, False: 1]
  |  Branch (5405:29): [True: 0, False: 1]
  ------------------
 5406|      0|        return (-1);
 5407|      1|    *length = 0;
 5408|      1|    if ((facet->type != XML_SCHEMA_FACET_LENGTH) &&
  ------------------
  |  Branch (5408:9): [True: 1, False: 0]
  ------------------
 5409|      1|	(facet->type != XML_SCHEMA_FACET_MAXLENGTH) &&
  ------------------
  |  Branch (5409:2): [True: 0, False: 1]
  ------------------
 5410|      1|	(facet->type != XML_SCHEMA_FACET_MINLENGTH))
  ------------------
  |  Branch (5410:2): [True: 0, False: 0]
  ------------------
 5411|      0|	return (-1);
 5412|       |
 5413|       |    /*
 5414|       |    * TODO: length, maxLength and minLength must be of type
 5415|       |    * nonNegativeInteger only. Check if decimal is used somehow.
 5416|       |    */
 5417|      1|    if ((facet->val == NULL) ||
  ------------------
  |  Branch (5417:9): [True: 0, False: 1]
  ------------------
 5418|      1|	((facet->val->type != XML_SCHEMAS_DECIMAL) &&
  ------------------
  |  Branch (5418:3): [True: 1, False: 0]
  ------------------
 5419|      1|	 (facet->val->type != XML_SCHEMAS_NNINTEGER)) ||
  ------------------
  |  Branch (5419:3): [True: 0, False: 1]
  ------------------
 5420|      1|	(facet->val->value.decimal.frac != 0)) {
  ------------------
  |  Branch (5420:2): [True: 0, False: 1]
  ------------------
 5421|      0|	return(-1);
 5422|      0|    }
 5423|      1|    if ((val != NULL) && (val->type == XML_SCHEMAS_HEXBINARY))
  ------------------
  |  Branch (5423:9): [True: 1, False: 0]
  |  Branch (5423:26): [True: 0, False: 1]
  ------------------
 5424|      0|	len = val->value.hex.total;
 5425|      1|    else if ((val != NULL) && (val->type == XML_SCHEMAS_BASE64BINARY))
  ------------------
  |  Branch (5425:14): [True: 1, False: 0]
  |  Branch (5425:31): [True: 0, False: 1]
  ------------------
 5426|      0|	len = val->value.base64.total;
 5427|      1|    else {
 5428|      1|	switch (valType) {
 5429|      1|	    case XML_SCHEMAS_STRING:
  ------------------
  |  Branch (5429:6): [True: 1, False: 0]
  ------------------
 5430|      1|	    case XML_SCHEMAS_NORMSTRING:
  ------------------
  |  Branch (5430:6): [True: 0, False: 1]
  ------------------
 5431|      1|		if (ws == XML_SCHEMA_WHITESPACE_UNKNOWN) {
  ------------------
  |  Branch (5431:7): [True: 0, False: 1]
  ------------------
 5432|       |		    /*
 5433|       |		    * This is to ensure API compatibility with the old
 5434|       |		    * xmlSchemaValidateLengthFacet(). Anyway, this was and
 5435|       |		    * is not the correct handling.
 5436|       |		    * TODO: Get rid of this case somehow.
 5437|       |		    */
 5438|      0|		    if (valType == XML_SCHEMAS_STRING)
  ------------------
  |  Branch (5438:11): [True: 0, False: 0]
  ------------------
 5439|      0|			len = xmlUTF8Strlen(value);
 5440|      0|		    else
 5441|      0|			len = xmlSchemaNormLen(value);
 5442|      1|		} else if (value != NULL) {
  ------------------
  |  Branch (5442:14): [True: 1, False: 0]
  ------------------
 5443|      1|		    if (ws == XML_SCHEMA_WHITESPACE_COLLAPSE)
  ------------------
  |  Branch (5443:11): [True: 0, False: 1]
  ------------------
 5444|      0|			len = xmlSchemaNormLen(value);
 5445|      1|		    else
 5446|       |		    /*
 5447|       |		    * Should be OK for "preserve" as well.
 5448|       |		    */
 5449|      1|		    len = xmlUTF8Strlen(value);
 5450|      1|		}
 5451|      1|		break;
 5452|      0|	    case XML_SCHEMAS_IDREF:
  ------------------
  |  Branch (5452:6): [True: 0, False: 1]
  ------------------
 5453|      0|	    case XML_SCHEMAS_TOKEN:
  ------------------
  |  Branch (5453:6): [True: 0, False: 1]
  ------------------
 5454|      0|	    case XML_SCHEMAS_LANGUAGE:
  ------------------
  |  Branch (5454:6): [True: 0, False: 1]
  ------------------
 5455|      0|	    case XML_SCHEMAS_NMTOKEN:
  ------------------
  |  Branch (5455:6): [True: 0, False: 1]
  ------------------
 5456|      0|	    case XML_SCHEMAS_NAME:
  ------------------
  |  Branch (5456:6): [True: 0, False: 1]
  ------------------
 5457|      0|	    case XML_SCHEMAS_NCNAME:
  ------------------
  |  Branch (5457:6): [True: 0, False: 1]
  ------------------
 5458|      0|	    case XML_SCHEMAS_ID:
  ------------------
  |  Branch (5458:6): [True: 0, False: 1]
  ------------------
 5459|       |		/*
 5460|       |		* FIXME: What exactly to do with anyURI?
 5461|       |		*/
 5462|      0|	    case XML_SCHEMAS_ANYURI:
  ------------------
  |  Branch (5462:6): [True: 0, False: 1]
  ------------------
 5463|      0|		if (value != NULL)
  ------------------
  |  Branch (5463:7): [True: 0, False: 0]
  ------------------
 5464|      0|		    len = xmlSchemaNormLen(value);
 5465|      0|		break;
 5466|      0|	    case XML_SCHEMAS_QNAME:
  ------------------
  |  Branch (5466:6): [True: 0, False: 1]
  ------------------
 5467|      0|	    case XML_SCHEMAS_NOTATION:
  ------------------
  |  Branch (5467:6): [True: 0, False: 1]
  ------------------
 5468|       |		/*
 5469|       |		* For QName and NOTATION, those facets are
 5470|       |		* deprecated and should be ignored.
 5471|       |		*/
 5472|      0|		return (0);
 5473|      0|	    default:
  ------------------
  |  Branch (5473:6): [True: 0, False: 1]
  ------------------
 5474|      0|		TODO
  ------------------
  |  |   45|      0|    xmlGenericError(xmlGenericErrorContext,				\
  |  |  ------------------
  |  |  |  |  875|      0|  #define xmlGenericError XML_GLOBAL_MACRO(xmlGenericError)
  |  |  |  |  ------------------
  |  |  |  |  |  |  500|      0|  #define XML_GLOBAL_MACRO(name) (*__##name())
  |  |  |  |  ------------------
  |  |  ------------------
  |  |                   xmlGenericError(xmlGenericErrorContext,				\
  |  |  ------------------
  |  |  |  |  876|      0|  #define xmlGenericErrorContext XML_GLOBAL_MACRO(xmlGenericErrorContext)
  |  |  |  |  ------------------
  |  |  |  |  |  |  500|      0|  #define XML_GLOBAL_MACRO(name) (*__##name())
  |  |  |  |  ------------------
  |  |  ------------------
  |  |   46|      0|	    "Unimplemented block at %s:%d\n",				\
  |  |   47|      0|            __FILE__, __LINE__);
  ------------------
 5475|      1|	}
 5476|      1|    }
 5477|      1|    *length = (unsigned long) len;
 5478|       |    /*
 5479|       |    * TODO: Return the whole expected value, i.e. "lo", "mi" and "hi".
 5480|       |    */
 5481|      1|    if (facet->type == XML_SCHEMA_FACET_LENGTH) {
  ------------------
  |  Branch (5481:9): [True: 0, False: 1]
  ------------------
 5482|      0|	if (len != facet->val->value.decimal.lo)
  ------------------
  |  Branch (5482:6): [True: 0, False: 0]
  ------------------
 5483|      0|	    return(XML_SCHEMAV_CVC_LENGTH_VALID);
 5484|      1|    } else if (facet->type == XML_SCHEMA_FACET_MINLENGTH) {
  ------------------
  |  Branch (5484:16): [True: 0, False: 1]
  ------------------
 5485|      0|	if (len < facet->val->value.decimal.lo)
  ------------------
  |  Branch (5485:6): [True: 0, False: 0]
  ------------------
 5486|      0|	    return(XML_SCHEMAV_CVC_MINLENGTH_VALID);
 5487|      1|    } else {
 5488|      1|	if (len > facet->val->value.decimal.lo)
  ------------------
  |  Branch (5488:6): [True: 0, False: 1]
  ------------------
 5489|      0|	    return(XML_SCHEMAV_CVC_MAXLENGTH_VALID);
 5490|      1|    }
 5491|       |
 5492|      1|    return (0);
 5493|      1|}
xmlschemastypes.c:xmlSchemaDateNormalize:
 4139|     20|{
 4140|     20|    xmlSchemaValPtr dur, ret;
 4141|       |
 4142|     20|    if (dt == NULL)
  ------------------
  |  Branch (4142:9): [True: 0, False: 20]
  ------------------
 4143|      0|        return NULL;
 4144|       |
 4145|     20|    if (((dt->type != XML_SCHEMAS_TIME) &&
  ------------------
  |  Branch (4145:10): [True: 16, False: 4]
  ------------------
 4146|     20|         (dt->type != XML_SCHEMAS_DATETIME) &&
  ------------------
  |  Branch (4146:10): [True: 12, False: 4]
  ------------------
 4147|     20|	 (dt->type != XML_SCHEMAS_DATE)) || (dt->value.date.tzo == 0))
  ------------------
  |  Branch (4147:3): [True: 8, False: 4]
  |  Branch (4147:38): [True: 12, False: 0]
  ------------------
 4148|     20|        return xmlSchemaDupVal(dt);
 4149|       |
 4150|      0|    dur = xmlSchemaNewValue(XML_SCHEMAS_DURATION);
 4151|      0|    if (dur == NULL)
  ------------------
  |  Branch (4151:9): [True: 0, False: 0]
  ------------------
 4152|      0|        return NULL;
 4153|       |
 4154|      0|    dur->value.date.sec -= offset;
 4155|       |
 4156|      0|    ret = _xmlSchemaDateAdd(dt, dur);
 4157|      0|    if (ret == NULL)
  ------------------
  |  Branch (4157:9): [True: 0, False: 0]
  ------------------
 4158|      0|        return NULL;
 4159|       |
 4160|      0|    xmlSchemaFreeValue(dur);
 4161|       |
 4162|       |    /* ret->value.date.tzo = 0; */
 4163|      0|    return ret;
 4164|      0|}

xmlStrndup:
   45|  11.8k|xmlStrndup(const xmlChar *cur, int len) {
   46|  11.8k|    xmlChar *ret;
   47|       |
   48|  11.8k|    if ((cur == NULL) || (len < 0)) return(NULL);
  ------------------
  |  Branch (48:9): [True: 0, False: 11.8k]
  |  Branch (48:26): [True: 0, False: 11.8k]
  ------------------
   49|  11.8k|    ret = (xmlChar *) xmlMallocAtomic((size_t) len + 1);
   50|  11.8k|    if (ret == NULL) {
  ------------------
  |  Branch (50:9): [True: 0, False: 11.8k]
  ------------------
   51|      0|        return(NULL);
   52|      0|    }
   53|  11.8k|    memcpy(ret, cur, len);
   54|  11.8k|    ret[len] = 0;
   55|  11.8k|    return(ret);
   56|  11.8k|}
xmlStrdup:
   69|  7.77k|xmlStrdup(const xmlChar *cur) {
   70|  7.77k|    const xmlChar *p = cur;
   71|       |
   72|  7.77k|    if (cur == NULL) return(NULL);
  ------------------
  |  Branch (72:9): [True: 254, False: 7.52k]
  ------------------
   73|  96.4k|    while (*p != 0) p++; /* non input consuming */
  ------------------
  |  Branch (73:12): [True: 88.9k, False: 7.52k]
  ------------------
   74|  7.52k|    return(xmlStrndup(cur, p - cur));
   75|  7.77k|}
xmlCharStrndup:
   88|    252|xmlCharStrndup(const char *cur, int len) {
   89|    252|    int i;
   90|    252|    xmlChar *ret;
   91|       |
   92|    252|    if ((cur == NULL) || (len < 0)) return(NULL);
  ------------------
  |  Branch (92:9): [True: 0, False: 252]
  |  Branch (92:26): [True: 0, False: 252]
  ------------------
   93|    252|    ret = (xmlChar *) xmlMallocAtomic((size_t) len + 1);
   94|    252|    if (ret == NULL) {
  ------------------
  |  Branch (94:9): [True: 0, False: 252]
  ------------------
   95|      0|        return(NULL);
   96|      0|    }
   97|  1.18k|    for (i = 0;i < len;i++) {
  ------------------
  |  Branch (97:16): [True: 929, False: 252]
  ------------------
   98|       |        /* Explicit sign change */
   99|    929|        ret[i] = (xmlChar) cur[i];
  100|    929|        if (ret[i] == 0) return(ret);
  ------------------
  |  Branch (100:13): [True: 0, False: 929]
  ------------------
  101|    929|    }
  102|    252|    ret[len] = 0;
  103|    252|    return(ret);
  104|    252|}
xmlCharStrdup:
  116|    252|xmlCharStrdup(const char *cur) {
  117|    252|    const char *p = cur;
  118|       |
  119|    252|    if (cur == NULL) return(NULL);
  ------------------
  |  Branch (119:9): [True: 0, False: 252]
  ------------------
  120|  1.18k|    while (*p != '\0') p++; /* non input consuming */
  ------------------
  |  Branch (120:12): [True: 929, False: 252]
  ------------------
  121|    252|    return(xmlCharStrndup(cur, p - cur));
  122|    252|}
xmlStrEqual:
  162|  51.0k|xmlStrEqual(const xmlChar *str1, const xmlChar *str2) {
  163|  51.0k|    if (str1 == str2) return(1);
  ------------------
  |  Branch (163:9): [True: 1.06k, False: 49.9k]
  ------------------
  164|  49.9k|    if (str1 == NULL) return(0);
  ------------------
  |  Branch (164:9): [True: 261, False: 49.7k]
  ------------------
  165|  49.7k|    if (str2 == NULL) return(0);
  ------------------
  |  Branch (165:9): [True: 3, False: 49.7k]
  ------------------
  166|  49.7k|#ifdef FUZZING_BUILD_MODE_UNSAFE_FOR_PRODUCTION
  167|  49.7k|    return(strcmp((const char *)str1, (const char *)str2) == 0);
  168|       |#else
  169|       |    do {
  170|       |        if (*str1++ != *str2) return(0);
  171|       |    } while (*str2++);
  172|       |    return(1);
  173|       |#endif
  174|  49.7k|}
xmlStrcasecmp:
  277|    123|xmlStrcasecmp(const xmlChar *str1, const xmlChar *str2) {
  278|    123|    register int tmp;
  279|       |
  280|    123|    if (str1 == str2) return(0);
  ------------------
  |  Branch (280:9): [True: 71, False: 52]
  ------------------
  281|     52|    if (str1 == NULL) return(-1);
  ------------------
  |  Branch (281:9): [True: 0, False: 52]
  ------------------
  282|     52|    if (str2 == NULL) return(1);
  ------------------
  |  Branch (282:9): [True: 0, False: 52]
  ------------------
  283|     52|    do {
  284|     52|        tmp = casemap[*str1++] - casemap[*str2];
  285|     52|        if (tmp != 0) return(tmp);
  ------------------
  |  Branch (285:13): [True: 52, False: 0]
  ------------------
  286|     52|    } while (*str2++ != 0);
  ------------------
  |  Branch (286:14): [True: 0, False: 0]
  ------------------
  287|      0|    return 0;
  288|     52|}
xmlStrncasecmp:
  302|    484|xmlStrncasecmp(const xmlChar *str1, const xmlChar *str2, int len) {
  303|    484|    register int tmp;
  304|       |
  305|    484|    if (len <= 0) return(0);
  ------------------
  |  Branch (305:9): [True: 0, False: 484]
  ------------------
  306|    484|    if (str1 == str2) return(0);
  ------------------
  |  Branch (306:9): [True: 0, False: 484]
  ------------------
  307|    484|    if (str1 == NULL) return(-1);
  ------------------
  |  Branch (307:9): [True: 0, False: 484]
  ------------------
  308|    484|    if (str2 == NULL) return(1);
  ------------------
  |  Branch (308:9): [True: 0, False: 484]
  ------------------
  309|    484|    do {
  310|    484|        tmp = casemap[*str1++] - casemap[*str2];
  311|    484|        if (tmp != 0 || --len == 0) return(tmp);
  ------------------
  |  Branch (311:13): [True: 484, False: 0]
  |  Branch (311:25): [True: 0, False: 0]
  ------------------
  312|    484|    } while (*str2++ != 0);
  ------------------
  |  Branch (312:14): [True: 0, False: 0]
  ------------------
  313|      0|    return 0;
  314|    484|}
xmlStrchr:
  327|  6.30k|xmlStrchr(const xmlChar *str, xmlChar val) {
  328|  6.30k|    if (str == NULL) return(NULL);
  ------------------
  |  Branch (328:9): [True: 0, False: 6.30k]
  ------------------
  329|  50.2k|    while (*str != 0) { /* non input consuming */
  ------------------
  |  Branch (329:12): [True: 48.6k, False: 1.59k]
  ------------------
  330|  48.6k|        if (*str == val) return((xmlChar *) str);
  ------------------
  |  Branch (330:13): [True: 4.70k, False: 43.9k]
  ------------------
  331|  43.9k|        str++;
  332|  43.9k|    }
  333|  1.59k|    return(NULL);
  334|  6.30k|}
xmlStrstr:
  347|      2|xmlStrstr(const xmlChar *str, const xmlChar *val) {
  348|      2|    int n;
  349|       |
  350|      2|    if (str == NULL) return(NULL);
  ------------------
  |  Branch (350:9): [True: 0, False: 2]
  ------------------
  351|      2|    if (val == NULL) return(NULL);
  ------------------
  |  Branch (351:9): [True: 0, False: 2]
  ------------------
  352|      2|    n = xmlStrlen(val);
  353|       |
  354|      2|    if (n == 0) return(str);
  ------------------
  |  Branch (354:9): [True: 0, False: 2]
  ------------------
  355|     10|    while (*str != 0) { /* non input consuming */
  ------------------
  |  Branch (355:12): [True: 8, False: 2]
  ------------------
  356|      8|        if (*str == *val) {
  ------------------
  |  Branch (356:13): [True: 0, False: 8]
  ------------------
  357|      0|            if (!xmlStrncmp(str, val, n)) return((const xmlChar *) str);
  ------------------
  |  Branch (357:17): [True: 0, False: 0]
  ------------------
  358|      0|        }
  359|      8|        str++;
  360|      8|    }
  361|      2|    return(NULL);
  362|      2|}
xmlStrlen:
  428|    807|xmlStrlen(const xmlChar *str) {
  429|    807|    size_t len = str ? strlen((const char *)str) : 0;
  ------------------
  |  Branch (429:18): [True: 807, False: 0]
  ------------------
  430|    807|    return(len > INT_MAX ? 0 : len);
  ------------------
  |  Branch (430:12): [True: 0, False: 807]
  ------------------
  431|    807|}
xmlStrncat:
  448|    677|xmlStrncat(xmlChar *cur, const xmlChar *add, int len) {
  449|    677|    int size;
  450|    677|    xmlChar *ret;
  451|       |
  452|    677|    if ((add == NULL) || (len == 0))
  ------------------
  |  Branch (452:9): [True: 0, False: 677]
  |  Branch (452:26): [True: 0, False: 677]
  ------------------
  453|      0|        return(cur);
  454|    677|    if (len < 0)
  ------------------
  |  Branch (454:9): [True: 0, False: 677]
  ------------------
  455|      0|	return(NULL);
  456|    677|    if (cur == NULL)
  ------------------
  |  Branch (456:9): [True: 0, False: 677]
  ------------------
  457|      0|        return(xmlStrndup(add, len));
  458|       |
  459|    677|    size = xmlStrlen(cur);
  460|    677|    if ((size < 0) || (size > INT_MAX - len))
  ------------------
  |  Branch (460:9): [True: 0, False: 677]
  |  Branch (460:23): [True: 0, False: 677]
  ------------------
  461|      0|        return(NULL);
  462|    677|    ret = (xmlChar *) xmlRealloc(cur, (size_t) size + len + 1);
  463|    677|    if (ret == NULL) {
  ------------------
  |  Branch (463:9): [True: 0, False: 677]
  ------------------
  464|      0|        return(cur);
  465|      0|    }
  466|    677|    memcpy(&ret[size], add, len);
  467|    677|    ret[size + len] = 0;
  468|    677|    return(ret);
  469|    677|}
xmlStrcat:
  524|    686|xmlStrcat(xmlChar *cur, const xmlChar *add) {
  525|    686|    const xmlChar *p = add;
  526|       |
  527|    686|    if (add == NULL) return(cur);
  ------------------
  |  Branch (527:9): [True: 0, False: 686]
  ------------------
  528|    686|    if (cur == NULL)
  ------------------
  |  Branch (528:9): [True: 9, False: 677]
  ------------------
  529|      9|        return(xmlStrdup(add));
  530|       |
  531|  11.8k|    while (*p != 0) p++; /* non input consuming */
  ------------------
  |  Branch (531:12): [True: 11.1k, False: 677]
  ------------------
  532|    677|    return(xmlStrncat(cur, add, p - add));
  533|    686|}
xmlUTF8Strlen:
  664|      1|xmlUTF8Strlen(const xmlChar *utf) {
  665|      1|    size_t ret = 0;
  666|       |
  667|      1|    if (utf == NULL)
  ------------------
  |  Branch (667:9): [True: 0, False: 1]
  ------------------
  668|      0|        return(-1);
  669|       |
  670|      2|    while (*utf != 0) {
  ------------------
  |  Branch (670:12): [True: 1, False: 1]
  ------------------
  671|      1|        if (utf[0] & 0x80) {
  ------------------
  |  Branch (671:13): [True: 0, False: 1]
  ------------------
  672|      0|            if ((utf[1] & 0xc0) != 0x80)
  ------------------
  |  Branch (672:17): [True: 0, False: 0]
  ------------------
  673|      0|                return(-1);
  674|      0|            if ((utf[0] & 0xe0) == 0xe0) {
  ------------------
  |  Branch (674:17): [True: 0, False: 0]
  ------------------
  675|      0|                if ((utf[2] & 0xc0) != 0x80)
  ------------------
  |  Branch (675:21): [True: 0, False: 0]
  ------------------
  676|      0|                    return(-1);
  677|      0|                if ((utf[0] & 0xf0) == 0xf0) {
  ------------------
  |  Branch (677:21): [True: 0, False: 0]
  ------------------
  678|      0|                    if ((utf[0] & 0xf8) != 0xf0 || (utf[3] & 0xc0) != 0x80)
  ------------------
  |  Branch (678:25): [True: 0, False: 0]
  |  Branch (678:52): [True: 0, False: 0]
  ------------------
  679|      0|                        return(-1);
  680|      0|                    utf += 4;
  681|      0|                } else {
  682|      0|                    utf += 3;
  683|      0|                }
  684|      0|            } else {
  685|      0|                utf += 2;
  686|      0|            }
  687|      1|        } else {
  688|      1|            utf++;
  689|      1|        }
  690|      1|        ret++;
  691|      1|    }
  692|      1|    return(ret > INT_MAX ? 0 : ret);
  ------------------
  |  Branch (692:12): [True: 0, False: 1]
  ------------------
  693|      1|}
xmlGetUTF8Char:
  708|  4.48k|xmlGetUTF8Char(const unsigned char *utf, int *len) {
  709|  4.48k|    unsigned int c;
  710|       |
  711|  4.48k|    if (utf == NULL)
  ------------------
  |  Branch (711:9): [True: 0, False: 4.48k]
  ------------------
  712|      0|        goto error;
  713|  4.48k|    if (len == NULL)
  ------------------
  |  Branch (713:9): [True: 0, False: 4.48k]
  ------------------
  714|      0|        goto error;
  715|       |
  716|  4.48k|    c = utf[0];
  717|  4.48k|    if (c < 0x80) {
  ------------------
  |  Branch (717:9): [True: 4.45k, False: 27]
  ------------------
  718|  4.45k|        if (*len < 1)
  ------------------
  |  Branch (718:13): [True: 0, False: 4.45k]
  ------------------
  719|      0|            goto error;
  720|       |        /* 1-byte code */
  721|  4.45k|        *len = 1;
  722|  4.45k|    } else {
  723|     27|        if ((*len < 2) || ((utf[1] & 0xc0) != 0x80))
  ------------------
  |  Branch (723:13): [True: 0, False: 27]
  |  Branch (723:27): [True: 13, False: 14]
  ------------------
  724|     13|            goto error;
  725|     14|        if (c < 0xe0) {
  ------------------
  |  Branch (725:13): [True: 14, False: 0]
  ------------------
  726|     14|            if (c < 0xc2)
  ------------------
  |  Branch (726:17): [True: 7, False: 7]
  ------------------
  727|      7|                goto error;
  728|       |            /* 2-byte code */
  729|      7|            *len = 2;
  730|      7|            c = (c & 0x1f) << 6;
  731|      7|            c |= utf[1] & 0x3f;
  732|      7|        } else {
  733|      0|            if ((*len < 3) || ((utf[2] & 0xc0) != 0x80))
  ------------------
  |  Branch (733:17): [True: 0, False: 0]
  |  Branch (733:31): [True: 0, False: 0]
  ------------------
  734|      0|                goto error;
  735|      0|            if (c < 0xf0) {
  ------------------
  |  Branch (735:17): [True: 0, False: 0]
  ------------------
  736|       |                /* 3-byte code */
  737|      0|                *len = 3;
  738|      0|                c = (c & 0xf) << 12;
  739|      0|                c |= (utf[1] & 0x3f) << 6;
  740|      0|                c |= utf[2] & 0x3f;
  741|      0|                if ((c < 0x800) || ((c >= 0xd800) && (c < 0xe000)))
  ------------------
  |  Branch (741:21): [True: 0, False: 0]
  |  Branch (741:37): [True: 0, False: 0]
  |  Branch (741:54): [True: 0, False: 0]
  ------------------
  742|      0|                    goto error;
  743|      0|            } else {
  744|      0|                if ((*len < 4) || ((utf[3] & 0xc0) != 0x80))
  ------------------
  |  Branch (744:21): [True: 0, False: 0]
  |  Branch (744:35): [True: 0, False: 0]
  ------------------
  745|      0|                    goto error;
  746|      0|                *len = 4;
  747|       |                /* 4-byte code */
  748|      0|                c = (c & 0x7) << 18;
  749|      0|                c |= (utf[1] & 0x3f) << 12;
  750|      0|                c |= (utf[2] & 0x3f) << 6;
  751|      0|                c |= utf[3] & 0x3f;
  752|      0|                if ((c < 0x10000) || (c >= 0x110000))
  ------------------
  |  Branch (752:21): [True: 0, False: 0]
  |  Branch (752:38): [True: 0, False: 0]
  ------------------
  753|      0|                    goto error;
  754|      0|            }
  755|      0|        }
  756|     14|    }
  757|  4.46k|    return(c);
  758|       |
  759|     20|error:
  760|     20|    if (len != NULL)
  ------------------
  |  Branch (760:9): [True: 20, False: 0]
  ------------------
  761|     20|	*len = 0;
  762|     20|    return(-1);
  763|  4.48k|}
xmlEscapeFormatString:
 1002|    134|{
 1003|    134|    xmlChar *msgPtr = NULL;
 1004|    134|    xmlChar *result = NULL;
 1005|    134|    xmlChar *resultPtr = NULL;
 1006|    134|    size_t count = 0;
 1007|    134|    size_t msgLen = 0;
 1008|    134|    size_t resultLen = 0;
 1009|       |
 1010|    134|    if (!msg || !*msg)
  ------------------
  |  Branch (1010:9): [True: 0, False: 134]
  |  Branch (1010:17): [True: 0, False: 134]
  ------------------
 1011|      0|        return(NULL);
 1012|       |
 1013|  4.81k|    for (msgPtr = *msg; *msgPtr != '\0'; ++msgPtr) {
  ------------------
  |  Branch (1013:25): [True: 4.67k, False: 134]
  ------------------
 1014|  4.67k|        ++msgLen;
 1015|  4.67k|        if (*msgPtr == '%')
  ------------------
  |  Branch (1015:13): [True: 0, False: 4.67k]
  ------------------
 1016|      0|            ++count;
 1017|  4.67k|    }
 1018|       |
 1019|    134|    if (count == 0)
  ------------------
  |  Branch (1019:9): [True: 134, False: 0]
  ------------------
 1020|    134|        return(*msg);
 1021|       |
 1022|      0|    if ((count > INT_MAX) || (msgLen > INT_MAX - count))
  ------------------
  |  Branch (1022:9): [True: 0, False: 0]
  |  Branch (1022:30): [True: 0, False: 0]
  ------------------
 1023|      0|        return(NULL);
 1024|      0|    resultLen = msgLen + count + 1;
 1025|      0|    result = (xmlChar *) xmlMallocAtomic(resultLen);
 1026|      0|    if (result == NULL) {
  ------------------
  |  Branch (1026:9): [True: 0, False: 0]
  ------------------
 1027|       |        /* Clear *msg to prevent format string vulnerabilities in
 1028|       |           out-of-memory situations. */
 1029|      0|        xmlFree(*msg);
 1030|      0|        *msg = NULL;
 1031|      0|        return(NULL);
 1032|      0|    }
 1033|       |
 1034|      0|    for (msgPtr = *msg, resultPtr = result; *msgPtr != '\0'; ++msgPtr, ++resultPtr) {
  ------------------
  |  Branch (1034:45): [True: 0, False: 0]
  ------------------
 1035|      0|        *resultPtr = *msgPtr;
 1036|      0|        if (*msgPtr == '%')
  ------------------
  |  Branch (1036:13): [True: 0, False: 0]
  ------------------
 1037|      0|            *(++resultPtr) = '%';
 1038|      0|    }
 1039|      0|    result[resultLen - 1] = '\0';
 1040|       |
 1041|      0|    xmlFree(*msg);
 1042|      0|    *msg = result;
 1043|       |
 1044|      0|    return *msg;
 1045|      0|}

xmlUCSIsCatNd:
 2881|      2|xmlUCSIsCatNd(int code) {
 2882|      2|    return(xmlCharInRange((unsigned int)code, &xmlNdG));
 2883|      2|}

xmlInitXPathInternal:
  168|      2|xmlInitXPathInternal(void) {
  169|      2|#if defined(NAN) && defined(INFINITY)
  170|      2|    xmlXPathNAN = NAN;
  171|      2|    xmlXPathPINF = INFINITY;
  172|      2|    xmlXPathNINF = -INFINITY;
  173|       |#else
  174|       |    /* MSVC doesn't allow division by zero in constant expressions. */
  175|       |    double zero = 0.0;
  176|       |    xmlXPathNAN = 0.0 / zero;
  177|       |    xmlXPathPINF = 1.0 / zero;
  178|       |    xmlXPathNINF = -xmlXPathPINF;
  179|       |#endif
  180|      2|}

