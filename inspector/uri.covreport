xmlInitDictInternal:
   99|      2|xmlInitDictInternal(void) {
  100|      2|    xmlInitMutex(&xmlDictMutex);
  101|      2|}
xmlInitRandom:
  918|      2|xmlInitRandom(void) {
  919|      2|    int var;
  920|       |
  921|      2|    xmlInitMutex(&xmlRngMutex);
  922|       |
  923|       |    /* TODO: Get seed values from system PRNG */
  924|       |
  925|      2|    globalRngState[0] = (unsigned) time(NULL) ^
  926|      2|                        HASH_ROL((unsigned) (size_t) &xmlInitRandom, 8);
  ------------------
  |  |   12|      2|#define HASH_ROL(x,n) ((x) << (n) | ((x) & 0xFFFFFFFF) >> (32 - (n)))
  ------------------
  927|      2|    globalRngState[1] = HASH_ROL((unsigned) (size_t) &xmlRngMutex, 16) ^
  ------------------
  |  |   12|      2|#define HASH_ROL(x,n) ((x) << (n) | ((x) & 0xFFFFFFFF) >> (32 - (n)))
  ------------------
  928|      2|                        HASH_ROL((unsigned) (size_t) &var, 24);
  ------------------
  |  |   12|      2|#define HASH_ROL(x,n) ((x) << (n) | ((x) & 0xFFFFFFFF) >> (32 - (n)))
  ------------------
  929|      2|}
xmlRandom:
  951|    426|xmlRandom(void) {
  952|    426|#ifdef XML_THREAD_LOCAL
  953|    426|    if (!localRngInitialized) {
  ------------------
  |  Branch (953:9): [True: 1, False: 425]
  ------------------
  954|      1|        xmlMutexLock(&xmlRngMutex);
  955|      1|        localRngState[0] = xoroshiro64ss(globalRngState);
  956|      1|        localRngState[1] = xoroshiro64ss(globalRngState);
  957|      1|        localRngInitialized = 1;
  958|      1|        xmlMutexUnlock(&xmlRngMutex);
  959|      1|    }
  960|       |
  961|    426|    return(xoroshiro64ss(localRngState));
  962|       |#else
  963|       |    unsigned ret;
  964|       |
  965|       |    xmlMutexLock(&xmlRngMutex);
  966|       |    ret = xoroshiro64ss(globalRngState);
  967|       |    xmlMutexUnlock(&xmlRngMutex);
  968|       |
  969|       |    return(ret);
  970|       |#endif
  971|    426|}
dict.c:xoroshiro64ss:
  938|    428|xoroshiro64ss(unsigned *s) {
  939|    428|    unsigned s0 = s[0];
  940|    428|    unsigned s1 = s[1];
  941|    428|    unsigned result = HASH_ROL(s0 * 0x9E3779BB, 5) * 5;
  ------------------
  |  |   12|    428|#define HASH_ROL(x,n) ((x) << (n) | ((x) & 0xFFFFFFFF) >> (32 - (n)))
  ------------------
  942|       |
  943|    428|    s1 ^= s0;
  944|    428|    s[0] = HASH_ROL(s0, 26) ^ s1 ^ (s1 << 9);
  ------------------
  |  |   12|    428|#define HASH_ROL(x,n) ((x) << (n) | ((x) & 0xFFFFFFFF) >> (32 - (n)))
  ------------------
  945|    428|    s[1] = HASH_ROL(s1, 13);
  ------------------
  |  |   12|    428|#define HASH_ROL(x,n) ((x) << (n) | ((x) & 0xFFFFFFFF) >> (32 - (n)))
  ------------------
  946|       |
  947|    428|    return(result & 0xFFFFFFFF);
  948|    428|}

xmlInitEncodingInternal:
 1470|      2|xmlInitEncodingInternal(void) {
 1471|      2|    unsigned short int tst = 0x1234;
 1472|      2|    unsigned char *ptr = (unsigned char *) &tst;
 1473|       |
 1474|      2|    if (*ptr == 0x12) xmlLittleEndian = 0;
  ------------------
  |  Branch (1474:9): [True: 0, False: 2]
  ------------------
 1475|      2|    else xmlLittleEndian = 1;
 1476|      2|}

xmlSetGenericErrorFunc:
  114|      2|xmlSetGenericErrorFunc(void *ctx, xmlGenericErrorFunc handler) {
  115|      2|    xmlGenericErrorContext = ctx;
  ------------------
  |  |  876|      2|  #define xmlGenericErrorContext XML_GLOBAL_MACRO(xmlGenericErrorContext)
  |  |  ------------------
  |  |  |  |  500|      2|  #define XML_GLOBAL_MACRO(name) (*__##name())
  |  |  ------------------
  ------------------
  116|      2|    if (handler != NULL)
  ------------------
  |  Branch (116:9): [True: 2, False: 0]
  ------------------
  117|      2|	xmlGenericError = handler;
  ------------------
  |  |  875|      2|  #define xmlGenericError XML_GLOBAL_MACRO(xmlGenericError)
  |  |  ------------------
  |  |  |  |  500|      2|  #define XML_GLOBAL_MACRO(name) (*__##name())
  |  |  ------------------
  ------------------
  118|      0|    else
  119|      0|	xmlGenericError = xmlGenericErrorDefaultFunc;
  ------------------
  |  |  875|      0|  #define xmlGenericError XML_GLOBAL_MACRO(xmlGenericError)
  |  |  ------------------
  |  |  |  |  500|      0|  #define XML_GLOBAL_MACRO(name) (*__##name())
  |  |  ------------------
  ------------------
  120|      2|}
__xmlRaiseError:
  475|    661|{
  476|    661|    xmlParserCtxtPtr ctxt = NULL;
  477|    661|    xmlNodePtr node = (xmlNodePtr) nod;
  478|    661|    char *str = NULL;
  479|    661|    xmlParserInputPtr input = NULL;
  480|    661|    xmlErrorPtr to = &xmlLastError;
  ------------------
  |  |  874|    661|  #define xmlLastError XML_GLOBAL_MACRO(xmlLastError)
  |  |  ------------------
  |  |  |  |  500|    661|  #define XML_GLOBAL_MACRO(name) (*__##name())
  |  |  ------------------
  ------------------
  481|    661|    xmlNodePtr baseptr = NULL;
  482|       |
  483|    661|    if (code == XML_ERR_OK)
  ------------------
  |  Branch (483:9): [True: 0, False: 661]
  ------------------
  484|      0|        return;
  485|    661|    if ((xmlGetWarningsDefaultValue == 0) && (level == XML_ERR_WARNING))
  ------------------
  |  |  865|    661|    XML_GLOBAL_MACRO(xmlGetWarningsDefaultValue)
  |  |  ------------------
  |  |  |  |  500|    661|  #define XML_GLOBAL_MACRO(name) (*__##name())
  |  |  ------------------
  ------------------
  |  Branch (485:9): [True: 0, False: 661]
  |  Branch (485:46): [True: 0, False: 0]
  ------------------
  486|      0|        return;
  487|    661|    if ((domain == XML_FROM_PARSER) || (domain == XML_FROM_HTML) ||
  ------------------
  |  Branch (487:9): [True: 0, False: 661]
  |  Branch (487:40): [True: 0, False: 661]
  ------------------
  488|    661|        (domain == XML_FROM_DTD) || (domain == XML_FROM_NAMESPACE) ||
  ------------------
  |  Branch (488:9): [True: 0, False: 661]
  |  Branch (488:37): [True: 0, False: 661]
  ------------------
  489|    661|	(domain == XML_FROM_IO) || (domain == XML_FROM_VALID)) {
  ------------------
  |  Branch (489:2): [True: 0, False: 661]
  |  Branch (489:29): [True: 0, False: 661]
  ------------------
  490|      0|	ctxt = (xmlParserCtxtPtr) ctx;
  491|       |
  492|      0|        if (ctxt != NULL) {
  ------------------
  |  Branch (492:13): [True: 0, False: 0]
  ------------------
  493|      0|            if (level == XML_ERR_WARNING) {
  ------------------
  |  Branch (493:17): [True: 0, False: 0]
  ------------------
  494|      0|                if (ctxt->nbWarnings >= XML_MAX_ERRORS)
  ------------------
  |  |   20|      0|#define XML_MAX_ERRORS 100
  ------------------
  |  Branch (494:21): [True: 0, False: 0]
  ------------------
  495|      0|                    return;
  496|      0|                ctxt->nbWarnings += 1;
  497|      0|            } else {
  498|      0|                if (ctxt->nbErrors >= XML_MAX_ERRORS)
  ------------------
  |  |   20|      0|#define XML_MAX_ERRORS 100
  ------------------
  |  Branch (498:21): [True: 0, False: 0]
  ------------------
  499|      0|                    return;
  500|      0|                ctxt->nbErrors += 1;
  501|      0|            }
  502|       |
  503|      0|            if ((schannel == NULL) && (ctxt->sax != NULL) &&
  ------------------
  |  Branch (503:17): [True: 0, False: 0]
  |  Branch (503:39): [True: 0, False: 0]
  ------------------
  504|      0|                (ctxt->sax->initialized == XML_SAX2_MAGIC) &&
  ------------------
  |  |  685|      0|#define XML_SAX2_MAGIC 0xDEEDBEAF
  ------------------
  |  Branch (504:17): [True: 0, False: 0]
  ------------------
  505|      0|                (ctxt->sax->serror != NULL)) {
  ------------------
  |  Branch (505:17): [True: 0, False: 0]
  ------------------
  506|      0|                schannel = ctxt->sax->serror;
  507|      0|                data = ctxt->userData;
  508|      0|            }
  509|      0|        }
  510|      0|    }
  511|       |    /*
  512|       |     * Check if structured error handler set
  513|       |     */
  514|    661|    if (schannel == NULL) {
  ------------------
  |  Branch (514:9): [True: 661, False: 0]
  ------------------
  515|    661|	schannel = xmlStructuredError;
  ------------------
  |  |  877|    661|  #define xmlStructuredError XML_GLOBAL_MACRO(xmlStructuredError)
  |  |  ------------------
  |  |  |  |  500|    661|  #define XML_GLOBAL_MACRO(name) (*__##name())
  |  |  ------------------
  ------------------
  516|       |	/*
  517|       |	 * if user has defined handler, change data ptr to user's choice
  518|       |	 */
  519|    661|	if (schannel != NULL)
  ------------------
  |  Branch (519:6): [True: 0, False: 661]
  ------------------
  520|      0|	    data = xmlStructuredErrorContext;
  ------------------
  |  |  878|      0|  #define xmlStructuredErrorContext XML_GLOBAL_MACRO(xmlStructuredErrorContext)
  |  |  ------------------
  |  |  |  |  500|      0|  #define XML_GLOBAL_MACRO(name) (*__##name())
  |  |  ------------------
  ------------------
  521|    661|    }
  522|       |    /*
  523|       |     * Formatting the message
  524|       |     */
  525|    661|    if (msg == NULL) {
  ------------------
  |  Branch (525:9): [True: 0, False: 661]
  ------------------
  526|      0|        str = (char *) xmlStrdup(BAD_CAST "No error message provided");
  ------------------
  |  |   35|      0|#define BAD_CAST (xmlChar *)
  ------------------
  527|    661|    } else {
  528|    661|        XML_GET_VAR_STR(msg, str);
  ------------------
  |  |   22|    661|#define XML_GET_VAR_STR(msg, str) {				\
  |  |   23|    661|    int       size, prev_size = -1;				\
  |  |   24|    661|    int       chars;						\
  |  |   25|    661|    char      *larger;						\
  |  |   26|    661|    va_list   ap;						\
  |  |   27|    661|								\
  |  |   28|    661|    str = (char *) xmlMalloc(150);				\
  |  |   29|    661|    if (str != NULL) {						\
  |  |  ------------------
  |  |  |  Branch (29:9): [True: 0, False: 661]
  |  |  ------------------
  |  |   30|      0|								\
  |  |   31|      0|    size = 150;							\
  |  |   32|      0|								\
  |  |   33|      0|    while (size < 64000) {					\
  |  |  ------------------
  |  |  |  Branch (33:12): [True: 0, False: 0]
  |  |  ------------------
  |  |   34|      0|	va_start(ap, msg);					\
  |  |   35|      0|	chars = vsnprintf(str, size, msg, ap);			\
  |  |   36|      0|	va_end(ap);						\
  |  |   37|      0|	if ((chars > -1) && (chars < size)) {			\
  |  |  ------------------
  |  |  |  Branch (37:6): [True: 0, False: 0]
  |  |  |  Branch (37:22): [True: 0, False: 0]
  |  |  ------------------
  |  |   38|      0|	    if (prev_size == chars) {				\
  |  |  ------------------
  |  |  |  Branch (38:10): [True: 0, False: 0]
  |  |  ------------------
  |  |   39|      0|		break;						\
  |  |   40|      0|	    } else {						\
  |  |   41|      0|		prev_size = chars;				\
  |  |   42|      0|	    }							\
  |  |   43|      0|	}							\
  |  |   44|      0|	if (chars > -1)						\
  |  |  ------------------
  |  |  |  Branch (44:6): [True: 0, False: 0]
  |  |  ------------------
  |  |   45|      0|	    size += chars + 1;					\
  |  |   46|      0|	else							\
  |  |   47|      0|	    size += 100;					\
  |  |   48|      0|	if ((larger = (char *) xmlRealloc(str, size)) == NULL) {\
  |  |  ------------------
  |  |  |  Branch (48:6): [True: 0, False: 0]
  |  |  ------------------
  |  |   49|      0|	    break;						\
  |  |   50|      0|	}							\
  |  |   51|      0|	str = larger;						\
  |  |   52|      0|    }}								\
  |  |   53|    661|}
  ------------------
  529|    661|    }
  530|       |
  531|       |    /*
  532|       |     * specific processing if a parser context is provided
  533|       |     */
  534|    661|    if (ctxt != NULL) {
  ------------------
  |  Branch (534:9): [True: 0, False: 661]
  ------------------
  535|      0|        if (file == NULL) {
  ------------------
  |  Branch (535:13): [True: 0, False: 0]
  ------------------
  536|      0|            input = ctxt->input;
  537|      0|            if ((input != NULL) && (input->filename == NULL) &&
  ------------------
  |  Branch (537:17): [True: 0, False: 0]
  |  Branch (537:36): [True: 0, False: 0]
  ------------------
  538|      0|                (ctxt->inputNr > 1)) {
  ------------------
  |  Branch (538:17): [True: 0, False: 0]
  ------------------
  539|      0|                input = ctxt->inputTab[ctxt->inputNr - 2];
  540|      0|            }
  541|      0|            if (input != NULL) {
  ------------------
  |  Branch (541:17): [True: 0, False: 0]
  ------------------
  542|      0|                file = input->filename;
  543|      0|                line = input->line;
  544|      0|                col = input->col;
  545|      0|            }
  546|      0|        }
  547|      0|        to = &ctxt->lastError;
  548|    661|    } else if ((node != NULL) && (file == NULL)) {
  ------------------
  |  Branch (548:16): [True: 0, False: 661]
  |  Branch (548:34): [True: 0, False: 0]
  ------------------
  549|      0|	int i;
  550|       |
  551|      0|	if ((node->doc != NULL) && (node->doc->URL != NULL)) {
  ------------------
  |  Branch (551:6): [True: 0, False: 0]
  |  Branch (551:29): [True: 0, False: 0]
  ------------------
  552|      0|	    baseptr = node;
  553|       |/*	    file = (const char *) node->doc->URL; */
  554|      0|	}
  555|      0|	for (i = 0;
  556|      0|	     ((i < 10) && (node != NULL) && (node->type != XML_ELEMENT_NODE));
  ------------------
  |  Branch (556:8): [True: 0, False: 0]
  |  Branch (556:20): [True: 0, False: 0]
  |  Branch (556:38): [True: 0, False: 0]
  ------------------
  557|      0|	     i++)
  558|      0|	     node = node->parent;
  559|      0|        if ((baseptr == NULL) && (node != NULL) &&
  ------------------
  |  Branch (559:13): [True: 0, False: 0]
  |  Branch (559:34): [True: 0, False: 0]
  ------------------
  560|      0|	    (node->doc != NULL) && (node->doc->URL != NULL))
  ------------------
  |  Branch (560:6): [True: 0, False: 0]
  |  Branch (560:29): [True: 0, False: 0]
  ------------------
  561|      0|	    baseptr = node;
  562|       |
  563|      0|	if ((node != NULL) && (node->type == XML_ELEMENT_NODE))
  ------------------
  |  Branch (563:6): [True: 0, False: 0]
  |  Branch (563:24): [True: 0, False: 0]
  ------------------
  564|      0|	    line = node->line;
  565|      0|	if ((line == 0) || (line == 65535))
  ------------------
  |  Branch (565:6): [True: 0, False: 0]
  |  Branch (565:21): [True: 0, False: 0]
  ------------------
  566|      0|	    line = xmlGetLineNo(node);
  567|      0|    }
  568|       |
  569|       |    /*
  570|       |     * Save the information about the error
  571|       |     */
  572|    661|    xmlResetError(to);
  573|    661|    to->domain = domain;
  574|    661|    to->code = code;
  575|    661|    to->message = str;
  576|    661|    to->level = level;
  577|    661|    if (file != NULL)
  ------------------
  |  Branch (577:9): [True: 0, False: 661]
  ------------------
  578|      0|        to->file = (char *) xmlStrdup((const xmlChar *) file);
  579|    661|    else if (baseptr != NULL) {
  ------------------
  |  Branch (579:14): [True: 0, False: 661]
  ------------------
  580|      0|#ifdef LIBXML_XINCLUDE_ENABLED
  581|       |	/*
  582|       |	 * We check if the error is within an XInclude section and,
  583|       |	 * if so, attempt to print out the href of the XInclude instead
  584|       |	 * of the usual "base" (doc->URL) for the node (bug 152623).
  585|       |	 */
  586|      0|        xmlNodePtr prev = baseptr;
  587|      0|        char *href = NULL;
  588|      0|	int inclcount = 0;
  589|      0|	while (prev != NULL) {
  ------------------
  |  Branch (589:9): [True: 0, False: 0]
  ------------------
  590|      0|	    if (prev->prev == NULL)
  ------------------
  |  Branch (590:10): [True: 0, False: 0]
  ------------------
  591|      0|	        prev = prev->parent;
  592|      0|	    else {
  593|      0|	        prev = prev->prev;
  594|      0|		if (prev->type == XML_XINCLUDE_START) {
  ------------------
  |  Branch (594:7): [True: 0, False: 0]
  ------------------
  595|      0|		    if (inclcount > 0) {
  ------------------
  |  Branch (595:11): [True: 0, False: 0]
  ------------------
  596|      0|                        --inclcount;
  597|      0|                    } else {
  598|      0|                        href = (char *) xmlGetProp(prev, BAD_CAST "href");
  ------------------
  |  |   35|      0|#define BAD_CAST (xmlChar *)
  ------------------
  599|      0|                        if (href != NULL)
  ------------------
  |  Branch (599:29): [True: 0, False: 0]
  ------------------
  600|      0|		            break;
  601|      0|                    }
  602|      0|		} else if (prev->type == XML_XINCLUDE_END)
  ------------------
  |  Branch (602:14): [True: 0, False: 0]
  ------------------
  603|      0|		    inclcount++;
  604|      0|	    }
  605|      0|	}
  606|      0|        if (href != NULL)
  ------------------
  |  Branch (606:13): [True: 0, False: 0]
  ------------------
  607|      0|            to->file = href;
  608|      0|	else
  609|      0|#endif
  610|      0|	    to->file = (char *) xmlStrdup(baseptr->doc->URL);
  611|      0|	if ((to->file == NULL) && (node != NULL) && (node->doc != NULL)) {
  ------------------
  |  Branch (611:6): [True: 0, False: 0]
  |  Branch (611:28): [True: 0, False: 0]
  |  Branch (611:46): [True: 0, False: 0]
  ------------------
  612|      0|	    to->file = (char *) xmlStrdup(node->doc->URL);
  613|      0|	}
  614|      0|    }
  615|    661|    to->line = line;
  616|    661|    if (str1 != NULL)
  ------------------
  |  Branch (616:9): [True: 661, False: 0]
  ------------------
  617|    661|        to->str1 = (char *) xmlStrdup((const xmlChar *) str1);
  618|    661|    if (str2 != NULL)
  ------------------
  |  Branch (618:9): [True: 0, False: 661]
  ------------------
  619|      0|        to->str2 = (char *) xmlStrdup((const xmlChar *) str2);
  620|    661|    if (str3 != NULL)
  ------------------
  |  Branch (620:9): [True: 0, False: 661]
  ------------------
  621|      0|        to->str3 = (char *) xmlStrdup((const xmlChar *) str3);
  622|    661|    to->int1 = int1;
  623|    661|    to->int2 = col;
  624|    661|    to->node = node;
  625|    661|    to->ctxt = ctx;
  626|       |
  627|    661|    if (to != &xmlLastError)
  ------------------
  |  |  874|    661|  #define xmlLastError XML_GLOBAL_MACRO(xmlLastError)
  |  |  ------------------
  |  |  |  |  500|    661|  #define XML_GLOBAL_MACRO(name) (*__##name())
  |  |  ------------------
  ------------------
  |  Branch (627:9): [True: 0, False: 661]
  ------------------
  628|      0|        xmlCopyError(to,&xmlLastError);
  ------------------
  |  |  874|      0|  #define xmlLastError XML_GLOBAL_MACRO(xmlLastError)
  |  |  ------------------
  |  |  |  |  500|      0|  #define XML_GLOBAL_MACRO(name) (*__##name())
  |  |  ------------------
  ------------------
  629|       |
  630|    661|    if (schannel != NULL) {
  ------------------
  |  Branch (630:9): [True: 0, False: 661]
  ------------------
  631|      0|	schannel(data, to);
  632|      0|	return;
  633|      0|    }
  634|       |
  635|       |    /*
  636|       |     * Find the callback channel if channel param is NULL
  637|       |     */
  638|    661|    if ((ctxt != NULL) && (channel == NULL) &&
  ------------------
  |  Branch (638:9): [True: 0, False: 661]
  |  Branch (638:27): [True: 0, False: 0]
  ------------------
  639|    661|        (xmlStructuredError == NULL) && (ctxt->sax != NULL)) {
  ------------------
  |  |  877|      0|  #define xmlStructuredError XML_GLOBAL_MACRO(xmlStructuredError)
  |  |  ------------------
  |  |  |  |  500|      0|  #define XML_GLOBAL_MACRO(name) (*__##name())
  |  |  ------------------
  ------------------
  |  Branch (639:9): [True: 0, False: 0]
  |  Branch (639:41): [True: 0, False: 0]
  ------------------
  640|      0|        if (level == XML_ERR_WARNING)
  ------------------
  |  Branch (640:13): [True: 0, False: 0]
  ------------------
  641|      0|	    channel = ctxt->sax->warning;
  642|      0|        else
  643|      0|	    channel = ctxt->sax->error;
  644|      0|	data = ctxt->userData;
  645|    661|    } else if (channel == NULL) {
  ------------------
  |  Branch (645:16): [True: 661, False: 0]
  ------------------
  646|    661|	channel = xmlGenericError;
  ------------------
  |  |  875|    661|  #define xmlGenericError XML_GLOBAL_MACRO(xmlGenericError)
  |  |  ------------------
  |  |  |  |  500|    661|  #define XML_GLOBAL_MACRO(name) (*__##name())
  |  |  ------------------
  ------------------
  647|    661|	if (ctxt != NULL) {
  ------------------
  |  Branch (647:6): [True: 0, False: 661]
  ------------------
  648|      0|	    data = ctxt;
  649|    661|	} else {
  650|    661|	    data = xmlGenericErrorContext;
  ------------------
  |  |  876|    661|  #define xmlGenericErrorContext XML_GLOBAL_MACRO(xmlGenericErrorContext)
  |  |  ------------------
  |  |  |  |  500|    661|  #define XML_GLOBAL_MACRO(name) (*__##name())
  |  |  ------------------
  ------------------
  651|    661|	}
  652|    661|    }
  653|    661|    if (channel == NULL)
  ------------------
  |  Branch (653:9): [True: 0, False: 661]
  ------------------
  654|      0|        return;
  655|       |
  656|    661|    if ((channel == xmlParserError) ||
  ------------------
  |  Branch (656:9): [True: 0, False: 661]
  ------------------
  657|    661|        (channel == xmlParserWarning) ||
  ------------------
  |  Branch (657:9): [True: 0, False: 661]
  ------------------
  658|    661|	(channel == xmlParserValidityError) ||
  ------------------
  |  Branch (658:2): [True: 0, False: 661]
  ------------------
  659|    661|	(channel == xmlParserValidityWarning))
  ------------------
  |  Branch (659:2): [True: 0, False: 661]
  ------------------
  660|      0|	xmlReportError(to, ctxt, str, NULL, NULL);
  661|    661|    else if (((void(*)(void)) channel == (void(*)(void)) fprintf) ||
  ------------------
  |  Branch (661:14): [True: 0, False: 661]
  ------------------
  662|    661|             (channel == xmlGenericErrorDefaultFunc))
  ------------------
  |  Branch (662:14): [True: 0, False: 661]
  ------------------
  663|      0|	xmlReportError(to, ctxt, str, channel, data);
  664|    661|    else
  665|    661|	channel(data, "%s", str);
  666|    661|}
xmlResetError:
  901|    661|{
  902|    661|    if (err == NULL)
  ------------------
  |  Branch (902:9): [True: 0, False: 661]
  ------------------
  903|      0|        return;
  904|    661|    if (err->code == XML_ERR_OK)
  ------------------
  |  Branch (904:9): [True: 1, False: 660]
  ------------------
  905|      1|        return;
  906|    660|    if (err->message != NULL)
  ------------------
  |  Branch (906:9): [True: 0, False: 660]
  ------------------
  907|      0|        xmlFree(err->message);
  908|    660|    if (err->file != NULL)
  ------------------
  |  Branch (908:9): [True: 0, False: 660]
  ------------------
  909|      0|        xmlFree(err->file);
  910|    660|    if (err->str1 != NULL)
  ------------------
  |  Branch (910:9): [True: 0, False: 660]
  ------------------
  911|      0|        xmlFree(err->str1);
  912|    660|    if (err->str2 != NULL)
  ------------------
  |  Branch (912:9): [True: 0, False: 660]
  ------------------
  913|      0|        xmlFree(err->str2);
  914|    660|    if (err->str3 != NULL)
  ------------------
  |  Branch (914:9): [True: 0, False: 660]
  ------------------
  915|      0|        xmlFree(err->str3);
  916|    660|    memset(err, 0, sizeof(xmlError));
  917|    660|    err->code = XML_ERR_OK;
  918|    660|}

xmlFuzzErrorFunc:
   56|    661|                 ...) {
   57|    661|}
xmlFuzzMemSetup:
  103|      2|xmlFuzzMemSetup(void) {
  104|      2|    xmlMemSetup(free, xmlFuzzMalloc, xmlFuzzRealloc, xmlMemStrdup);
  105|      2|}
xmlFuzzMemSetLimit:
  108|    852|xmlFuzzMemSetLimit(size_t limit) {
  109|    852|    fuzzNumAllocs = 0;
  110|    852|    fuzzMaxAllocs = limit ? limit + XML_FUZZ_MALLOC_OFFSET : 0;
  ------------------
  |  |   69|    285|#define XML_FUZZ_MALLOC_OFFSET  0
  ------------------
  |  Branch (110:21): [True: 285, False: 567]
  ------------------
  111|    852|    fuzzAllocFailed = 0;
  112|    852|}
xmlFuzzDataInit:
  125|    426|xmlFuzzDataInit(const char *data, size_t size) {
  126|    426|    fuzzData.data = data;
  127|    426|    fuzzData.size = size;
  128|    426|    fuzzData.ptr = data;
  129|    426|    fuzzData.remaining = size;
  130|       |
  131|    426|    fuzzData.outBuf = xmlMalloc(size + 1);
  132|    426|    fuzzData.outPtr = fuzzData.outBuf;
  133|       |
  134|    426|    fuzzData.entities = xmlHashCreate(8);
  135|    426|    fuzzData.mainUrl = NULL;
  136|    426|    fuzzData.mainEntity = NULL;
  137|    426|}
xmlFuzzDataCleanup:
  145|    426|xmlFuzzDataCleanup(void) {
  146|    426|    xmlFree(fuzzData.outBuf);
  147|    426|    xmlHashFree(fuzzData.entities, xmlHashDefaultDeallocator);
  148|    426|}
xmlFuzzReadInt:
  181|    426|xmlFuzzReadInt(int size) {
  182|    426|    size_t ret = 0;
  183|       |
  184|  2.12k|    while ((size > 0) && (fuzzData.remaining > 0)) {
  ------------------
  |  Branch (184:12): [True: 1.70k, False: 423]
  |  Branch (184:26): [True: 1.69k, False: 3]
  ------------------
  185|  1.69k|        unsigned char c = (unsigned char) *fuzzData.ptr++;
  186|  1.69k|        fuzzData.remaining--;
  187|  1.69k|        ret = (ret << 8) | c;
  188|  1.69k|        size--;
  189|  1.69k|    }
  190|       |
  191|    426|    return ret;
  192|    426|}
xmlFuzzReadString:
  245|    852|xmlFuzzReadString(size_t *size) {
  246|    852|    const char *out = fuzzData.outPtr;
  247|       |
  248|  10.8k|    while (fuzzData.remaining > 0) {
  ------------------
  |  Branch (248:12): [True: 9.96k, False: 852]
  ------------------
  249|  9.96k|        int c = *fuzzData.ptr++;
  250|  9.96k|        fuzzData.remaining--;
  251|       |
  252|  9.96k|        if ((c == '\\') && (fuzzData.remaining > 0)) {
  ------------------
  |  Branch (252:13): [True: 7, False: 9.95k]
  |  Branch (252:28): [True: 5, False: 2]
  ------------------
  253|      5|            int c2 = *fuzzData.ptr;
  254|       |
  255|      5|            if (c2 == '\n') {
  ------------------
  |  Branch (255:17): [True: 0, False: 5]
  ------------------
  256|      0|                fuzzData.ptr++;
  257|      0|                fuzzData.remaining--;
  258|      0|                if (size != NULL)
  ------------------
  |  Branch (258:21): [True: 0, False: 0]
  ------------------
  259|      0|                    *size = fuzzData.outPtr - out;
  260|      0|                *fuzzData.outPtr++ = '\0';
  261|      0|                return(out);
  262|      0|            }
  263|      5|            if (c2 == '\\') {
  ------------------
  |  Branch (263:17): [True: 1, False: 4]
  ------------------
  264|      1|                fuzzData.ptr++;
  265|      1|                fuzzData.remaining--;
  266|      1|            }
  267|      5|        }
  268|       |
  269|  9.96k|        *fuzzData.outPtr++ = c;
  270|  9.96k|    }
  271|       |
  272|    852|    if (fuzzData.outPtr > out) {
  ------------------
  |  Branch (272:9): [True: 423, False: 429]
  ------------------
  273|    423|        if (size != NULL)
  ------------------
  |  Branch (273:13): [True: 0, False: 423]
  ------------------
  274|      0|            *size = fuzzData.outPtr - out;
  275|    423|        *fuzzData.outPtr++ = '\0';
  276|    423|        return(out);
  277|    423|    }
  278|       |
  279|    429|    if (size != NULL)
  ------------------
  |  Branch (279:9): [True: 0, False: 429]
  ------------------
  280|      0|        *size = 0;
  281|    429|    return(NULL);
  282|    852|}
fuzz.c:xmlFuzzMalloc:
   73|  13.4k|xmlFuzzMalloc(size_t size) {
   74|  13.4k|    if (fuzzMaxAllocs > 0) {
  ------------------
  |  Branch (74:9): [True: 8.21k, False: 5.24k]
  ------------------
   75|  8.21k|        if (fuzzNumAllocs >= fuzzMaxAllocs - 1) {
  ------------------
  |  Branch (75:13): [True: 2.36k, False: 5.84k]
  ------------------
   76|       |#if XML_FUZZ_MALLOC_ABORT
   77|       |            abort();
   78|       |#endif
   79|  2.36k|            fuzzAllocFailed = 1;
   80|  2.36k|            return(NULL);
   81|  2.36k|        }
   82|  5.84k|        fuzzNumAllocs += 1;
   83|  5.84k|    }
   84|  11.0k|    return malloc(size);
   85|  13.4k|}
fuzz.c:xmlFuzzRealloc:
   88|    555|xmlFuzzRealloc(void *ptr, size_t size) {
   89|    555|    if (fuzzMaxAllocs > 0) {
  ------------------
  |  Branch (89:9): [True: 308, False: 247]
  ------------------
   90|    308|        if (fuzzNumAllocs >= fuzzMaxAllocs - 1) {
  ------------------
  |  Branch (90:13): [True: 5, False: 303]
  ------------------
   91|       |#if XML_FUZZ_MALLOC_ABORT
   92|       |            abort();
   93|       |#endif
   94|      5|            fuzzAllocFailed = 1;
   95|      5|            return(NULL);
   96|      5|        }
   97|    303|        fuzzNumAllocs += 1;
   98|    303|    }
   99|    550|    return realloc(ptr, size);
  100|    555|}

LLVMFuzzerInitialize:
   12|      2|                     char ***argv ATTRIBUTE_UNUSED) {
   13|      2|    xmlFuzzMemSetup();
   14|      2|    xmlSetGenericErrorFunc(NULL, xmlFuzzErrorFunc);
   15|       |
   16|      2|    return 0;
   17|      2|}
LLVMFuzzerTestOneInput:
   20|    426|LLVMFuzzerTestOneInput(const char *data, size_t size) {
   21|    426|    xmlURIPtr uri;
   22|    426|    size_t maxAlloc;
   23|    426|    const char *str1, *str2;
   24|    426|    char *copy;
   25|       |
   26|    426|    if (size > 10000)
  ------------------
  |  Branch (26:9): [True: 0, False: 426]
  ------------------
   27|      0|        return(0);
   28|       |
   29|    426|    xmlFuzzDataInit(data, size);
   30|    426|    maxAlloc = xmlFuzzReadInt(4) % (size * 8 + 1);
   31|    426|    str1 = xmlFuzzReadString(NULL);
   32|    426|    str2 = xmlFuzzReadString(NULL);
   33|       |
   34|    426|    xmlFuzzMemSetLimit(maxAlloc);
   35|       |
   36|    426|    uri = xmlParseURI(str1);
   37|    426|    xmlFree(xmlSaveUri(uri));
   38|    426|    xmlFreeURI(uri);
   39|       |
   40|    426|    uri = xmlParseURIRaw(str1, 1);
   41|    426|    xmlFree(xmlSaveUri(uri));
   42|    426|    xmlFreeURI(uri);
   43|       |
   44|    426|    xmlFree(xmlURIUnescapeString(str1, -1, NULL));
   45|    426|    xmlFree(xmlURIEscape(BAD_CAST str1));
  ------------------
  |  |   35|    426|#define BAD_CAST (xmlChar *)
  ------------------
   46|    426|    xmlFree(xmlCanonicPath(BAD_CAST str1));
  ------------------
  |  |   35|    426|#define BAD_CAST (xmlChar *)
  ------------------
   47|    426|    xmlFree(xmlPathToURI(BAD_CAST str1));
  ------------------
  |  |   35|    426|#define BAD_CAST (xmlChar *)
  ------------------
   48|       |
   49|    426|    xmlFree(xmlBuildURI(BAD_CAST str2, BAD_CAST str1));
  ------------------
  |  |   35|    426|#define BAD_CAST (xmlChar *)
  ------------------
                  xmlFree(xmlBuildURI(BAD_CAST str2, BAD_CAST str1));
  ------------------
  |  |   35|    426|#define BAD_CAST (xmlChar *)
  ------------------
   50|    426|    xmlFree(xmlBuildRelativeURI(BAD_CAST str2, BAD_CAST str1));
  ------------------
  |  |   35|    426|#define BAD_CAST (xmlChar *)
  ------------------
                  xmlFree(xmlBuildRelativeURI(BAD_CAST str2, BAD_CAST str1));
  ------------------
  |  |   35|    426|#define BAD_CAST (xmlChar *)
  ------------------
   51|    426|    xmlFree(xmlURIEscapeStr(BAD_CAST str1, BAD_CAST str2));
  ------------------
  |  |   35|    426|#define BAD_CAST (xmlChar *)
  ------------------
                  xmlFree(xmlURIEscapeStr(BAD_CAST str1, BAD_CAST str2));
  ------------------
  |  |   35|    426|#define BAD_CAST (xmlChar *)
  ------------------
   52|       |
   53|    426|    copy = (char *) xmlCharStrdup(str1);
   54|    426|    xmlNormalizeURIPath(copy);
   55|    426|    xmlFree(copy);
   56|       |
   57|    426|    xmlFuzzMemSetLimit(0);
   58|    426|    xmlFuzzDataCleanup();
   59|       |
   60|    426|    return 0;
   61|    426|}

xmlInitGlobalsInternal:
  566|      2|void xmlInitGlobalsInternal(void) {
  567|      2|    xmlInitMutex(&xmlThrDefMutex);
  568|       |
  569|      2|#ifdef HAVE_POSIX_THREADS
  570|      2|#ifdef XML_PTHREAD_WEAK
  571|      2|    if (libxml_is_threaded == -1)
  ------------------
  |  Branch (571:9): [True: 2, False: 0]
  ------------------
  572|      2|        libxml_is_threaded =
  573|      2|            (pthread_getspecific != NULL) &&
  ------------------
  |  Branch (573:13): [True: 2, False: 0]
  ------------------
  574|      2|            (pthread_setspecific != NULL) &&
  ------------------
  |  Branch (574:13): [True: 2, False: 0]
  ------------------
  575|      2|            (pthread_key_create != NULL) &&
  ------------------
  |  Branch (575:13): [True: 2, False: 0]
  ------------------
  576|      2|            (pthread_key_delete != NULL) &&
  ------------------
  |  Branch (576:13): [True: 2, False: 0]
  ------------------
  577|       |            /*
  578|       |             * pthread_equal can be inline, resuting in -Waddress warnings.
  579|       |             * Let's assume it's available if all the other functions are.
  580|       |             */
  581|       |            /* (pthread_equal != NULL) && */
  582|      2|            (pthread_self != NULL);
  ------------------
  |  Branch (582:13): [True: 2, False: 0]
  ------------------
  583|      2|    if (libxml_is_threaded == 0)
  ------------------
  |  Branch (583:9): [True: 0, False: 2]
  ------------------
  584|      0|        return;
  585|      2|#endif /* XML_PTHREAD_WEAK */
  586|      2|    pthread_key_create(&globalkey, xmlFreeGlobalState);
  587|      2|    mainthread = pthread_self();
  588|       |#elif defined(HAVE_WIN32_THREADS)
  589|       |#ifndef USE_TLS
  590|       |    globalkey = TlsAlloc();
  591|       |#endif
  592|       |    mainthread = GetCurrentThreadId();
  593|       |#endif
  594|      2|}
__xmlLastError:
  892|  1.32k|    type *__##name(void) { \
  893|  1.32k|        if (IS_MAIN_THREAD) \
  ------------------
  |  |   62|  1.32k|#define IS_MAIN_THREAD (xmlIsMainThreadInternal())
  |  |  ------------------
  |  |  |  Branch (62:24): [True: 1.32k, False: 0]
  |  |  ------------------
  ------------------
  894|  1.32k|            return (&name); \
  895|  1.32k|        else \
  896|  1.32k|            return (&xmlGetThreadLocalStorage(0)->gs_##name); \
  897|  1.32k|    }
__xmlGenericError:
  892|    663|    type *__##name(void) { \
  893|    663|        if (IS_MAIN_THREAD) \
  ------------------
  |  |   62|    663|#define IS_MAIN_THREAD (xmlIsMainThreadInternal())
  |  |  ------------------
  |  |  |  Branch (62:24): [True: 663, False: 0]
  |  |  ------------------
  ------------------
  894|    663|            return (&name); \
  895|    663|        else \
  896|    663|            return (&xmlGetThreadLocalStorage(0)->gs_##name); \
  897|    663|    }
__xmlGenericErrorContext:
  892|    663|    type *__##name(void) { \
  893|    663|        if (IS_MAIN_THREAD) \
  ------------------
  |  |   62|    663|#define IS_MAIN_THREAD (xmlIsMainThreadInternal())
  |  |  ------------------
  |  |  |  Branch (62:24): [True: 663, False: 0]
  |  |  ------------------
  ------------------
  894|    663|            return (&name); \
  895|    663|        else \
  896|    663|            return (&xmlGetThreadLocalStorage(0)->gs_##name); \
  897|    663|    }
__xmlStructuredError:
  892|    661|    type *__##name(void) { \
  893|    661|        if (IS_MAIN_THREAD) \
  ------------------
  |  |   62|    661|#define IS_MAIN_THREAD (xmlIsMainThreadInternal())
  |  |  ------------------
  |  |  |  Branch (62:24): [True: 661, False: 0]
  |  |  ------------------
  ------------------
  894|    661|            return (&name); \
  895|    661|        else \
  896|    661|            return (&xmlGetThreadLocalStorage(0)->gs_##name); \
  897|    661|    }
__xmlGetWarningsDefaultValue:
  892|    661|    type *__##name(void) { \
  893|    661|        if (IS_MAIN_THREAD) \
  ------------------
  |  |   62|    661|#define IS_MAIN_THREAD (xmlIsMainThreadInternal())
  |  |  ------------------
  |  |  |  Branch (62:24): [True: 661, False: 0]
  |  |  ------------------
  ------------------
  894|    661|            return (&name); \
  895|    661|        else \
  896|    661|            return (&xmlGetThreadLocalStorage(0)->gs_##name); \
  897|    661|    }
globals.c:xmlIsMainThreadInternal:
  660|  3.97k|xmlIsMainThreadInternal(void) {
  661|  3.97k|    if (parserInitialized == 0) {
  ------------------
  |  Branch (661:9): [True: 2, False: 3.96k]
  ------------------
  662|      2|        xmlInitParser();
  663|      2|        parserInitialized = 1;
  664|      2|    }
  665|       |
  666|  3.97k|#ifdef HAVE_POSIX_THREADS
  667|  3.97k|#ifdef XML_PTHREAD_WEAK
  668|  3.97k|    if (libxml_is_threaded == 0)
  ------------------
  |  Branch (668:9): [True: 0, False: 3.97k]
  ------------------
  669|      0|        return (1);
  670|  3.97k|#endif
  671|  3.97k|    return (pthread_equal(mainthread, pthread_self()));
  672|       |#elif defined HAVE_WIN32_THREADS
  673|       |    return (mainthread == GetCurrentThreadId());
  674|       |#else
  675|       |    return (1);
  676|       |#endif
  677|  3.97k|}

xmlHashCreate:
  160|    426|xmlHashCreate(int size) {
  161|    426|    xmlHashTablePtr hash;
  162|       |
  163|    426|    xmlInitParser();
  164|       |
  165|    426|    hash = xmlMalloc(sizeof(*hash));
  166|    426|    if (hash == NULL)
  ------------------
  |  Branch (166:9): [True: 0, False: 426]
  ------------------
  167|      0|        return(NULL);
  168|    426|    hash->dict = NULL;
  169|    426|    hash->size = 0;
  170|    426|    hash->table = NULL;
  171|    426|    hash->nbElems = 0;
  172|    426|    hash->randomSeed = xmlRandom();
  173|    426|#ifdef FUZZING_BUILD_MODE_UNSAFE_FOR_PRODUCTION
  174|    426|    hash->randomSeed = 0;
  175|    426|#endif
  176|       |
  177|       |    /*
  178|       |     * Unless a larger size is passed, the backing table is created
  179|       |     * lazily with MIN_HASH_SIZE capacity. In practice, there are many
  180|       |     * hash tables which are never filled.
  181|       |     */
  182|    426|    if (size > MIN_HASH_SIZE) {
  ------------------
  |  |   30|    426|#define MIN_HASH_SIZE 8
  ------------------
  |  Branch (182:9): [True: 0, False: 426]
  ------------------
  183|      0|        unsigned newSize = MIN_HASH_SIZE * 2;
  ------------------
  |  |   30|      0|#define MIN_HASH_SIZE 8
  ------------------
  184|       |
  185|      0|        while ((newSize < (unsigned) size) && (newSize < MAX_HASH_SIZE))
  ------------------
  |  |   31|      0|#define MAX_HASH_SIZE (1u << 31)
  ------------------
  |  Branch (185:16): [True: 0, False: 0]
  |  Branch (185:47): [True: 0, False: 0]
  ------------------
  186|      0|            newSize *= 2;
  187|       |
  188|      0|        if (xmlHashGrow(hash, newSize) != 0) {
  ------------------
  |  Branch (188:13): [True: 0, False: 0]
  ------------------
  189|      0|            xmlFree(hash);
  190|      0|            return(NULL);
  191|      0|        }
  192|      0|    }
  193|       |
  194|    426|    return(hash);
  195|    426|}
xmlHashFree:
  229|    426|xmlHashFree(xmlHashTablePtr hash, xmlHashDeallocator dealloc) {
  230|    426|    if (hash == NULL)
  ------------------
  |  Branch (230:9): [True: 0, False: 426]
  ------------------
  231|      0|        return;
  232|       |
  233|    426|    if (hash->table) {
  ------------------
  |  Branch (233:9): [True: 0, False: 426]
  ------------------
  234|      0|        const xmlHashEntry *end = &hash->table[hash->size];
  235|      0|        const xmlHashEntry *entry;
  236|       |
  237|      0|        for (entry = hash->table; entry < end; entry++) {
  ------------------
  |  Branch (237:35): [True: 0, False: 0]
  ------------------
  238|      0|            if (entry->hashValue == 0)
  ------------------
  |  Branch (238:17): [True: 0, False: 0]
  ------------------
  239|      0|                continue;
  240|      0|            if ((dealloc != NULL) && (entry->payload != NULL))
  ------------------
  |  Branch (240:17): [True: 0, False: 0]
  |  Branch (240:38): [True: 0, False: 0]
  ------------------
  241|      0|                dealloc(entry->payload, entry->key);
  242|      0|            if (hash->dict == NULL) {
  ------------------
  |  Branch (242:17): [True: 0, False: 0]
  ------------------
  243|      0|                if (entry->key)
  ------------------
  |  Branch (243:21): [True: 0, False: 0]
  ------------------
  244|      0|                    xmlFree(entry->key);
  245|      0|                if (entry->key2)
  ------------------
  |  Branch (245:21): [True: 0, False: 0]
  ------------------
  246|      0|                    xmlFree(entry->key2);
  247|      0|                if (entry->key3)
  ------------------
  |  Branch (247:21): [True: 0, False: 0]
  ------------------
  248|      0|                    xmlFree(entry->key3);
  249|      0|            }
  250|      0|        }
  251|       |
  252|      0|        xmlFree(hash->table);
  253|      0|    }
  254|       |
  255|    426|    if (hash->dict)
  ------------------
  |  Branch (255:9): [True: 0, False: 426]
  ------------------
  256|      0|        xmlDictFree(hash->dict);
  257|       |
  258|    426|    xmlFree(hash);
  259|    426|}

xmlInitMutex:
  129|      8|{
  130|      8|#ifdef HAVE_POSIX_THREADS
  131|      8|    if (XML_IS_NEVER_THREADED() == 0)
  ------------------
  |  |   85|      8|#define XML_IS_NEVER_THREADED() (!libxml_is_threaded)
  ------------------
  |  Branch (131:9): [True: 8, False: 0]
  ------------------
  132|      8|        pthread_mutex_init(&mutex->lock, NULL);
  133|       |#elif defined HAVE_WIN32_THREADS
  134|       |    InitializeCriticalSection(&mutex->cs);
  135|       |#else
  136|       |    (void) mutex;
  137|       |#endif
  138|      8|}
xmlMutexLock:
  202|      1|{
  203|      1|    if (tok == NULL)
  ------------------
  |  Branch (203:9): [True: 0, False: 1]
  ------------------
  204|      0|        return;
  205|      1|#ifdef HAVE_POSIX_THREADS
  206|       |    /*
  207|       |     * This assumes that __libc_single_threaded won't change while the
  208|       |     * lock is held.
  209|       |     */
  210|      1|    if (XML_IS_THREADED() != 0)
  ------------------
  |  |   84|      1|#define XML_IS_THREADED() libxml_is_threaded
  ------------------
  |  Branch (210:9): [True: 1, False: 0]
  ------------------
  211|      1|        pthread_mutex_lock(&tok->lock);
  212|       |#elif defined HAVE_WIN32_THREADS
  213|       |    EnterCriticalSection(&tok->cs);
  214|       |#endif
  215|       |
  216|      1|}
xmlMutexUnlock:
  226|      1|{
  227|      1|    if (tok == NULL)
  ------------------
  |  Branch (227:9): [True: 0, False: 1]
  ------------------
  228|      0|        return;
  229|      1|#ifdef HAVE_POSIX_THREADS
  230|      1|    if (XML_IS_THREADED() != 0)
  ------------------
  |  |   84|      1|#define XML_IS_THREADED() libxml_is_threaded
  ------------------
  |  Branch (230:9): [True: 1, False: 0]
  ------------------
  231|      1|        pthread_mutex_unlock(&tok->lock);
  232|       |#elif defined HAVE_WIN32_THREADS
  233|       |    LeaveCriticalSection(&tok->cs);
  234|       |#endif
  235|      1|}
xmlInitParser:
  569|    428|xmlInitParser(void) {
  570|       |    /*
  571|       |     * Note that the initialization code must not make memory allocations.
  572|       |     */
  573|    428|    if (xmlParserInitialized != 0)
  ------------------
  |  Branch (573:9): [True: 426, False: 2]
  ------------------
  574|    426|        return;
  575|       |
  576|      2|    xmlGlobalInitMutexLock();
  577|       |
  578|      2|    if (xmlParserInnerInitialized == 0) {
  ------------------
  |  Branch (578:9): [True: 2, False: 0]
  ------------------
  579|       |#if defined(_WIN32) && \
  580|       |    !defined(LIBXML_THREAD_ALLOC_ENABLED) && \
  581|       |    (!defined(LIBXML_STATIC) || defined(LIBXML_STATIC_FOR_DLL))
  582|       |        if (xmlFree == free)
  583|       |            atexit(xmlCleanupParser);
  584|       |#endif
  585|       |
  586|      2|        xmlInitMemoryInternal(); /* Should come second */
  587|      2|        xmlInitGlobalsInternal();
  588|      2|        xmlInitRandom();
  589|      2|        xmlInitDictInternal();
  590|      2|        xmlInitEncodingInternal();
  591|      2|#if defined(LIBXML_XPATH_ENABLED) || defined(LIBXML_SCHEMAS_ENABLED)
  592|      2|        xmlInitXPathInternal();
  593|      2|#endif
  594|       |
  595|      2|        xmlRegisterDefaultInputCallbacks();
  596|      2|#ifdef LIBXML_OUTPUT_ENABLED
  597|      2|        xmlRegisterDefaultOutputCallbacks();
  598|      2|#endif /* LIBXML_OUTPUT_ENABLED */
  599|       |
  600|      2|        xmlParserInnerInitialized = 1;
  601|      2|    }
  602|       |
  603|      2|    xmlGlobalInitMutexUnlock();
  604|       |
  605|      2|    xmlParserInitialized = 1;
  606|      2|}
threads.c:xmlGlobalInitMutexLock:
  462|      2|xmlGlobalInitMutexLock(void) {
  463|      2|#ifdef HAVE_POSIX_THREADS
  464|       |
  465|      2|#ifdef XML_PTHREAD_WEAK
  466|       |    /*
  467|       |     * This is somewhat unreliable since libpthread could be loaded
  468|       |     * later with dlopen() and threads could be created. But it's
  469|       |     * long-standing behavior and hard to work around.
  470|       |     */
  471|      2|    if (libxml_is_threaded == -1)
  ------------------
  |  Branch (471:9): [True: 2, False: 0]
  ------------------
  472|      2|        libxml_is_threaded =
  473|      2|            (pthread_mutex_init != NULL) &&
  ------------------
  |  Branch (473:13): [True: 2, False: 0]
  ------------------
  474|      2|            (pthread_mutex_destroy != NULL) &&
  ------------------
  |  Branch (474:13): [True: 2, False: 0]
  ------------------
  475|      2|            (pthread_mutex_lock != NULL) &&
  ------------------
  |  Branch (475:13): [True: 2, False: 0]
  ------------------
  476|      2|            (pthread_mutex_unlock != NULL) &&
  ------------------
  |  Branch (476:13): [True: 2, False: 0]
  ------------------
  477|      2|            (pthread_cond_init != NULL) &&
  ------------------
  |  Branch (477:13): [True: 2, False: 0]
  ------------------
  478|      2|            (pthread_cond_destroy != NULL) &&
  ------------------
  |  Branch (478:13): [True: 2, False: 0]
  ------------------
  479|      2|            (pthread_cond_wait != NULL) &&
  ------------------
  |  Branch (479:13): [True: 2, False: 0]
  ------------------
  480|       |            /*
  481|       |             * pthread_equal can be inline, resuting in -Waddress warnings.
  482|       |             * Let's assume it's available if all the other functions are.
  483|       |             */
  484|       |            /* (pthread_equal != NULL) && */
  485|      2|            (pthread_self != NULL) &&
  ------------------
  |  Branch (485:13): [True: 2, False: 0]
  ------------------
  486|      2|            (pthread_cond_signal != NULL);
  ------------------
  |  Branch (486:13): [True: 2, False: 0]
  ------------------
  487|      2|#endif
  488|       |
  489|       |    /* The mutex is statically initialized, so we just lock it. */
  490|      2|    if (XML_IS_THREADED() != 0)
  ------------------
  |  |   84|      2|#define XML_IS_THREADED() libxml_is_threaded
  ------------------
  |  Branch (490:9): [True: 2, False: 0]
  ------------------
  491|      2|        pthread_mutex_lock(&global_init_lock);
  492|       |
  493|       |#elif defined HAVE_WIN32_THREADS
  494|       |
  495|       |    LPCRITICAL_SECTION cs;
  496|       |
  497|       |    /* Create a new critical section */
  498|       |    if (global_init_lock == NULL) {
  499|       |        cs = malloc(sizeof(CRITICAL_SECTION));
  500|       |        if (cs == NULL) {
  501|       |            xmlGenericError(xmlGenericErrorContext,
  502|       |                            "xmlGlobalInitMutexLock: out of memory\n");
  503|       |            return;
  504|       |        }
  505|       |        InitializeCriticalSection(cs);
  506|       |
  507|       |        /* Swap it into the global_init_lock */
  508|       |#ifdef InterlockedCompareExchangePointer
  509|       |        InterlockedCompareExchangePointer((void **) &global_init_lock,
  510|       |                                          cs, NULL);
  511|       |#else /* Use older void* version */
  512|       |        InterlockedCompareExchange((void **) &global_init_lock,
  513|       |                                   (void *) cs, NULL);
  514|       |#endif /* InterlockedCompareExchangePointer */
  515|       |
  516|       |        /* If another thread successfully recorded its critical
  517|       |         * section in the global_init_lock then discard the one
  518|       |         * allocated by this thread. */
  519|       |        if (global_init_lock != cs) {
  520|       |            DeleteCriticalSection(cs);
  521|       |            free(cs);
  522|       |        }
  523|       |    }
  524|       |
  525|       |    /* Lock the chosen critical section */
  526|       |    EnterCriticalSection(global_init_lock);
  527|       |
  528|       |#endif
  529|      2|}
threads.c:xmlGlobalInitMutexUnlock:
  532|      2|xmlGlobalInitMutexUnlock(void) {
  533|      2|#ifdef HAVE_POSIX_THREADS
  534|      2|    if (XML_IS_THREADED() != 0)
  ------------------
  |  |   84|      2|#define XML_IS_THREADED() libxml_is_threaded
  ------------------
  |  Branch (534:9): [True: 2, False: 0]
  ------------------
  535|      2|        pthread_mutex_unlock(&global_init_lock);
  536|       |#elif defined HAVE_WIN32_THREADS
  537|       |    if (global_init_lock != NULL)
  538|       |	LeaveCriticalSection(global_init_lock);
  539|       |#endif
  540|      2|}

xmlParseURI:
  947|  1.68k|xmlParseURI(const char *str) {
  948|  1.68k|    xmlURIPtr uri;
  949|  1.68k|    int ret;
  950|       |
  951|  1.68k|    if (str == NULL)
  ------------------
  |  Branch (951:9): [True: 3, False: 1.67k]
  ------------------
  952|      3|	return(NULL);
  953|  1.67k|    uri = xmlCreateURI();
  954|  1.67k|    if (uri != NULL) {
  ------------------
  |  Branch (954:9): [True: 1.38k, False: 296]
  ------------------
  955|  1.38k|	ret = xmlParse3986URIReference(uri, str);
  956|  1.38k|        if (ret) {
  ------------------
  |  Branch (956:13): [True: 863, False: 519]
  ------------------
  957|    863|	    xmlFreeURI(uri);
  958|    863|	    return(NULL);
  959|    863|	}
  960|  1.38k|    }
  961|    815|    return(uri);
  962|  1.67k|}
xmlParseURIReference:
  977|    768|xmlParseURIReference(xmlURIPtr uri, const char *str) {
  978|    768|    return(xmlParse3986URIReference(uri, str));
  979|    768|}
xmlParseURIRaw:
  993|    426|xmlParseURIRaw(const char *str, int raw) {
  994|    426|    xmlURIPtr uri;
  995|    426|    int ret;
  996|       |
  997|    426|    if (str == NULL)
  ------------------
  |  Branch (997:9): [True: 3, False: 423]
  ------------------
  998|      3|	return(NULL);
  999|    423|    uri = xmlCreateURI();
 1000|    423|    if (uri != NULL) {
  ------------------
  |  Branch (1000:9): [True: 398, False: 25]
  ------------------
 1001|    398|        if (raw) {
  ------------------
  |  Branch (1001:13): [True: 398, False: 0]
  ------------------
 1002|    398|	    uri->cleanup |= 2;
 1003|    398|	}
 1004|    398|	ret = xmlParseURIReference(uri, str);
 1005|    398|        if (ret) {
  ------------------
  |  Branch (1005:13): [True: 217, False: 181]
  ------------------
 1006|    217|	    xmlFreeURI(uri);
 1007|    217|	    return(NULL);
 1008|    217|	}
 1009|    398|    }
 1010|    206|    return(uri);
 1011|    423|}
xmlCreateURI:
 1027|  2.52k|xmlCreateURI(void) {
 1028|  2.52k|    xmlURIPtr ret;
 1029|       |
 1030|  2.52k|    ret = (xmlURIPtr) xmlMalloc(sizeof(xmlURI));
 1031|  2.52k|    if (ret == NULL) {
  ------------------
  |  Branch (1031:9): [True: 374, False: 2.15k]
  ------------------
 1032|    374|        xmlURIErrMemory("creating URI structure\n");
 1033|    374|	return(NULL);
 1034|    374|    }
 1035|  2.15k|    memset(ret, 0, sizeof(xmlURI));
 1036|  2.15k|    ret->port = PORT_EMPTY;
  ------------------
  |  |   37|  2.15k|#define PORT_EMPTY           0
  ------------------
 1037|  2.15k|    return(ret);
 1038|  2.52k|}
xmlSaveUri:
 1074|  1.04k|xmlSaveUri(xmlURIPtr uri) {
 1075|  1.04k|    xmlChar *ret = NULL;
 1076|  1.04k|    xmlChar *temp;
 1077|  1.04k|    const char *p;
 1078|  1.04k|    int len;
 1079|  1.04k|    int max;
 1080|       |
 1081|  1.04k|    if (uri == NULL) return(NULL);
  ------------------
  |  Branch (1081:9): [True: 476, False: 565]
  ------------------
 1082|       |
 1083|       |
 1084|    565|    max = 80;
 1085|    565|    ret = (xmlChar *) xmlMallocAtomic(max + 1);
 1086|    565|    if (ret == NULL) {
  ------------------
  |  Branch (1086:9): [True: 27, False: 538]
  ------------------
 1087|     27|        xmlURIErrMemory("saving URI\n");
 1088|     27|	return(NULL);
 1089|     27|    }
 1090|    538|    len = 0;
 1091|       |
 1092|    538|    if (uri->scheme != NULL) {
  ------------------
  |  Branch (1092:9): [True: 116, False: 422]
  ------------------
 1093|    116|	p = uri->scheme;
 1094|    571|	while (*p != 0) {
  ------------------
  |  Branch (1094:9): [True: 455, False: 116]
  ------------------
 1095|    455|	    if (len >= max) {
  ------------------
  |  Branch (1095:10): [True: 0, False: 455]
  ------------------
 1096|      0|                temp = xmlSaveUriRealloc(ret, &max);
 1097|      0|                if (temp == NULL) goto mem_error;
  ------------------
  |  Branch (1097:21): [True: 0, False: 0]
  ------------------
 1098|      0|		ret = temp;
 1099|      0|	    }
 1100|    455|	    ret[len++] = *p++;
 1101|    455|	}
 1102|    116|	if (len >= max) {
  ------------------
  |  Branch (1102:6): [True: 0, False: 116]
  ------------------
 1103|      0|            temp = xmlSaveUriRealloc(ret, &max);
 1104|      0|            if (temp == NULL) goto mem_error;
  ------------------
  |  Branch (1104:17): [True: 0, False: 0]
  ------------------
 1105|      0|            ret = temp;
 1106|      0|	}
 1107|    116|	ret[len++] = ':';
 1108|    116|    }
 1109|    538|    if (uri->opaque != NULL) {
  ------------------
  |  Branch (1109:9): [True: 0, False: 538]
  ------------------
 1110|      0|	p = uri->opaque;
 1111|      0|	while (*p != 0) {
  ------------------
  |  Branch (1111:9): [True: 0, False: 0]
  ------------------
 1112|      0|	    if (len + 3 >= max) {
  ------------------
  |  Branch (1112:10): [True: 0, False: 0]
  ------------------
 1113|      0|                temp = xmlSaveUriRealloc(ret, &max);
 1114|      0|                if (temp == NULL) goto mem_error;
  ------------------
  |  Branch (1114:21): [True: 0, False: 0]
  ------------------
 1115|      0|                ret = temp;
 1116|      0|	    }
 1117|      0|	    if (IS_RESERVED(*(p)) || IS_UNRESERVED(*(p)))
  ------------------
  |  |  116|      0|#define IS_RESERVED(x) (((x) == ';') || ((x) == '/') || ((x) == '?') || \
  |  |  ------------------
  |  |  |  Branch (116:25): [True: 0, False: 0]
  |  |  |  Branch (116:41): [True: 0, False: 0]
  |  |  |  Branch (116:57): [True: 0, False: 0]
  |  |  ------------------
  |  |  117|      0|        ((x) == ':') || ((x) == '@') || ((x) == '&') || ((x) == '=') || \
  |  |  ------------------
  |  |  |  Branch (117:9): [True: 0, False: 0]
  |  |  |  Branch (117:25): [True: 0, False: 0]
  |  |  |  Branch (117:41): [True: 0, False: 0]
  |  |  |  Branch (117:57): [True: 0, False: 0]
  |  |  ------------------
  |  |  118|      0|        ((x) == '+') || ((x) == '$') || ((x) == ',') || ((x) == '[') || \
  |  |  ------------------
  |  |  |  Branch (118:9): [True: 0, False: 0]
  |  |  |  Branch (118:25): [True: 0, False: 0]
  |  |  |  Branch (118:41): [True: 0, False: 0]
  |  |  |  Branch (118:57): [True: 0, False: 0]
  |  |  ------------------
  |  |  119|      0|        ((x) == ']'))
  |  |  ------------------
  |  |  |  Branch (119:9): [True: 0, False: 0]
  |  |  ------------------
  ------------------
              	    if (IS_RESERVED(*(p)) || IS_UNRESERVED(*(p)))
  ------------------
  |  |  125|      0|#define IS_UNRESERVED(x) (IS_ALPHANUM(x) || IS_MARK(x))
  |  |  ------------------
  |  |  |  |   93|      0|#define IS_ALPHANUM(x) (IS_ALPHA(x) || IS_DIGIT(x))
  |  |  |  |  ------------------
  |  |  |  |  |  |   63|      0|#define IS_ALPHA(x) (IS_LOWALPHA(x) || IS_UPALPHA(x))
  |  |  |  |  |  |  ------------------
  |  |  |  |  |  |  |  |   72|      0|#define IS_LOWALPHA(x) (((x) >= 'a') && ((x) <= 'z'))
  |  |  |  |  |  |  |  |  ------------------
  |  |  |  |  |  |  |  |  |  Branch (72:25): [True: 0, False: 0]
  |  |  |  |  |  |  |  |  |  Branch (72:41): [True: 0, False: 0]
  |  |  |  |  |  |  |  |  ------------------
  |  |  |  |  |  |  ------------------
  |  |  |  |  |  |               #define IS_ALPHA(x) (IS_LOWALPHA(x) || IS_UPALPHA(x))
  |  |  |  |  |  |  ------------------
  |  |  |  |  |  |  |  |   79|      0|#define IS_UPALPHA(x) (((x) >= 'A') && ((x) <= 'Z'))
  |  |  |  |  |  |  |  |  ------------------
  |  |  |  |  |  |  |  |  |  Branch (79:24): [True: 0, False: 0]
  |  |  |  |  |  |  |  |  |  Branch (79:40): [True: 0, False: 0]
  |  |  |  |  |  |  |  |  ------------------
  |  |  |  |  |  |  ------------------
  |  |  |  |  ------------------
  |  |  |  |               #define IS_ALPHANUM(x) (IS_ALPHA(x) || IS_DIGIT(x))
  |  |  |  |  ------------------
  |  |  |  |  |  |   87|      0|#define IS_DIGIT(x) (((x) >= '0') && ((x) <= '9'))
  |  |  |  |  |  |  ------------------
  |  |  |  |  |  |  |  Branch (87:22): [True: 0, False: 0]
  |  |  |  |  |  |  |  Branch (87:38): [True: 0, False: 0]
  |  |  |  |  |  |  ------------------
  |  |  |  |  ------------------
  |  |  ------------------
  |  |               #define IS_UNRESERVED(x) (IS_ALPHANUM(x) || IS_MARK(x))
  |  |  ------------------
  |  |  |  |   99|      0|#define IS_MARK(x) (((x) == '-') || ((x) == '_') || ((x) == '.') ||     \
  |  |  |  |  ------------------
  |  |  |  |  |  Branch (99:21): [True: 0, False: 0]
  |  |  |  |  |  Branch (99:37): [True: 0, False: 0]
  |  |  |  |  |  Branch (99:53): [True: 0, False: 0]
  |  |  |  |  ------------------
  |  |  |  |  100|      0|    ((x) == '!') || ((x) == '~') || ((x) == '*') || ((x) == '\'') ||    \
  |  |  |  |  ------------------
  |  |  |  |  |  Branch (100:5): [True: 0, False: 0]
  |  |  |  |  |  Branch (100:21): [True: 0, False: 0]
  |  |  |  |  |  Branch (100:37): [True: 0, False: 0]
  |  |  |  |  |  Branch (100:53): [True: 0, False: 0]
  |  |  |  |  ------------------
  |  |  |  |  101|      0|    ((x) == '(') || ((x) == ')'))
  |  |  |  |  ------------------
  |  |  |  |  |  Branch (101:5): [True: 0, False: 0]
  |  |  |  |  |  Branch (101:21): [True: 0, False: 0]
  |  |  |  |  ------------------
  |  |  ------------------
  ------------------
 1118|      0|		ret[len++] = *p++;
 1119|      0|	    else {
 1120|      0|		int val = *(unsigned char *)p++;
 1121|      0|		int hi = val / 0x10, lo = val % 0x10;
 1122|      0|		ret[len++] = '%';
 1123|      0|		ret[len++] = hi + (hi > 9? 'A'-10 : '0');
  ------------------
  |  Branch (1123:22): [True: 0, False: 0]
  ------------------
 1124|      0|		ret[len++] = lo + (lo > 9? 'A'-10 : '0');
  ------------------
  |  Branch (1124:22): [True: 0, False: 0]
  ------------------
 1125|      0|	    }
 1126|      0|	}
 1127|    538|    } else {
 1128|    538|	if ((uri->server != NULL) || (uri->port != PORT_EMPTY)) {
  ------------------
  |  |   37|    501|#define PORT_EMPTY           0
  ------------------
  |  Branch (1128:6): [True: 37, False: 501]
  |  Branch (1128:31): [True: 2, False: 499]
  ------------------
 1129|     39|	    if (len + 3 >= max) {
  ------------------
  |  Branch (1129:10): [True: 0, False: 39]
  ------------------
 1130|      0|                temp = xmlSaveUriRealloc(ret, &max);
 1131|      0|                if (temp == NULL) goto mem_error;
  ------------------
  |  Branch (1131:21): [True: 0, False: 0]
  ------------------
 1132|      0|                ret = temp;
 1133|      0|	    }
 1134|     39|	    ret[len++] = '/';
 1135|     39|	    ret[len++] = '/';
 1136|     39|	    if (uri->user != NULL) {
  ------------------
  |  Branch (1136:10): [True: 24, False: 15]
  ------------------
 1137|     24|		p = uri->user;
 1138|    100|		while (*p != 0) {
  ------------------
  |  Branch (1138:10): [True: 76, False: 24]
  ------------------
 1139|     76|		    if (len + 3 >= max) {
  ------------------
  |  Branch (1139:11): [True: 0, False: 76]
  ------------------
 1140|      0|                        temp = xmlSaveUriRealloc(ret, &max);
 1141|      0|                        if (temp == NULL) goto mem_error;
  ------------------
  |  Branch (1141:29): [True: 0, False: 0]
  ------------------
 1142|      0|                        ret = temp;
 1143|      0|		    }
 1144|     76|		    if ((IS_UNRESERVED(*(p))) ||
  ------------------
  |  |  125|     76|#define IS_UNRESERVED(x) (IS_ALPHANUM(x) || IS_MARK(x))
  |  |  ------------------
  |  |  |  |   93|    152|#define IS_ALPHANUM(x) (IS_ALPHA(x) || IS_DIGIT(x))
  |  |  |  |  ------------------
  |  |  |  |  |  |   63|    152|#define IS_ALPHA(x) (IS_LOWALPHA(x) || IS_UPALPHA(x))
  |  |  |  |  |  |  ------------------
  |  |  |  |  |  |  |  |   72|    152|#define IS_LOWALPHA(x) (((x) >= 'a') && ((x) <= 'z'))
  |  |  |  |  |  |  |  |  ------------------
  |  |  |  |  |  |  |  |  |  Branch (72:25): [True: 50, False: 26]
  |  |  |  |  |  |  |  |  |  Branch (72:41): [True: 48, False: 2]
  |  |  |  |  |  |  |  |  ------------------
  |  |  |  |  |  |  ------------------
  |  |  |  |  |  |               #define IS_ALPHA(x) (IS_LOWALPHA(x) || IS_UPALPHA(x))
  |  |  |  |  |  |  ------------------
  |  |  |  |  |  |  |  |   79|     28|#define IS_UPALPHA(x) (((x) >= 'A') && ((x) <= 'Z'))
  |  |  |  |  |  |  |  |  ------------------
  |  |  |  |  |  |  |  |  |  Branch (79:24): [True: 2, False: 26]
  |  |  |  |  |  |  |  |  |  Branch (79:40): [True: 0, False: 2]
  |  |  |  |  |  |  |  |  ------------------
  |  |  |  |  |  |  ------------------
  |  |  |  |  ------------------
  |  |  |  |               #define IS_ALPHANUM(x) (IS_ALPHA(x) || IS_DIGIT(x))
  |  |  |  |  ------------------
  |  |  |  |  |  |   87|     28|#define IS_DIGIT(x) (((x) >= '0') && ((x) <= '9'))
  |  |  |  |  |  |  ------------------
  |  |  |  |  |  |  |  Branch (87:22): [True: 28, False: 0]
  |  |  |  |  |  |  |  Branch (87:38): [True: 2, False: 26]
  |  |  |  |  |  |  ------------------
  |  |  |  |  ------------------
  |  |  ------------------
  |  |               #define IS_UNRESERVED(x) (IS_ALPHANUM(x) || IS_MARK(x))
  |  |  ------------------
  |  |  |  |   99|     26|#define IS_MARK(x) (((x) == '-') || ((x) == '_') || ((x) == '.') ||     \
  |  |  |  |  ------------------
  |  |  |  |  |  Branch (99:21): [True: 0, False: 26]
  |  |  |  |  |  Branch (99:37): [True: 0, False: 26]
  |  |  |  |  |  Branch (99:53): [True: 0, False: 26]
  |  |  |  |  ------------------
  |  |  |  |  100|     26|    ((x) == '!') || ((x) == '~') || ((x) == '*') || ((x) == '\'') ||    \
  |  |  |  |  ------------------
  |  |  |  |  |  Branch (100:5): [True: 0, False: 26]
  |  |  |  |  |  Branch (100:21): [True: 2, False: 24]
  |  |  |  |  |  Branch (100:37): [True: 0, False: 24]
  |  |  |  |  |  Branch (100:53): [True: 0, False: 24]
  |  |  |  |  ------------------
  |  |  |  |  101|     26|    ((x) == '(') || ((x) == ')'))
  |  |  |  |  ------------------
  |  |  |  |  |  Branch (101:5): [True: 0, False: 24]
  |  |  |  |  |  Branch (101:21): [True: 0, False: 24]
  |  |  |  |  ------------------
  |  |  ------------------
  ------------------
 1145|     76|			((*(p) == ';')) || ((*(p) == ':')) ||
  ------------------
  |  Branch (1145:4): [True: 0, False: 24]
  |  Branch (1145:23): [True: 24, False: 0]
  ------------------
 1146|     76|			((*(p) == '&')) || ((*(p) == '=')) ||
  ------------------
  |  Branch (1146:4): [True: 0, False: 0]
  |  Branch (1146:23): [True: 0, False: 0]
  ------------------
 1147|     76|			((*(p) == '+')) || ((*(p) == '$')) ||
  ------------------
  |  Branch (1147:4): [True: 0, False: 0]
  |  Branch (1147:23): [True: 0, False: 0]
  ------------------
 1148|     76|			((*(p) == ',')))
  ------------------
  |  Branch (1148:4): [True: 0, False: 0]
  ------------------
 1149|     76|			ret[len++] = *p++;
 1150|      0|		    else {
 1151|      0|			int val = *(unsigned char *)p++;
 1152|      0|			int hi = val / 0x10, lo = val % 0x10;
 1153|      0|			ret[len++] = '%';
 1154|      0|			ret[len++] = hi + (hi > 9? 'A'-10 : '0');
  ------------------
  |  Branch (1154:23): [True: 0, False: 0]
  ------------------
 1155|      0|			ret[len++] = lo + (lo > 9? 'A'-10 : '0');
  ------------------
  |  Branch (1155:23): [True: 0, False: 0]
  ------------------
 1156|      0|		    }
 1157|     76|		}
 1158|     24|		if (len + 3 >= max) {
  ------------------
  |  Branch (1158:7): [True: 0, False: 24]
  ------------------
 1159|      0|                    temp = xmlSaveUriRealloc(ret, &max);
 1160|      0|                    if (temp == NULL) goto mem_error;
  ------------------
  |  Branch (1160:25): [True: 0, False: 0]
  ------------------
 1161|      0|                    ret = temp;
 1162|      0|		}
 1163|     24|		ret[len++] = '@';
 1164|     24|	    }
 1165|     39|	    if (uri->server != NULL) {
  ------------------
  |  Branch (1165:10): [True: 37, False: 2]
  ------------------
 1166|     37|		p = uri->server;
 1167|    181|		while (*p != 0) {
  ------------------
  |  Branch (1167:10): [True: 144, False: 37]
  ------------------
 1168|    144|		    if (len >= max) {
  ------------------
  |  Branch (1168:11): [True: 0, False: 144]
  ------------------
 1169|      0|			temp = xmlSaveUriRealloc(ret, &max);
 1170|      0|			if (temp == NULL) goto mem_error;
  ------------------
  |  Branch (1170:8): [True: 0, False: 0]
  ------------------
 1171|      0|			ret = temp;
 1172|      0|		    }
 1173|       |                    /* TODO: escaping? */
 1174|    144|		    ret[len++] = (xmlChar) *p++;
 1175|    144|		}
 1176|     37|	    }
 1177|     39|            if (uri->port > 0) {
  ------------------
  |  Branch (1177:17): [True: 13, False: 26]
  ------------------
 1178|     13|                if (len + 10 >= max) {
  ------------------
  |  Branch (1178:21): [True: 0, False: 13]
  ------------------
 1179|      0|                    temp = xmlSaveUriRealloc(ret, &max);
 1180|      0|                    if (temp == NULL) goto mem_error;
  ------------------
  |  Branch (1180:25): [True: 0, False: 0]
  ------------------
 1181|      0|                    ret = temp;
 1182|      0|                }
 1183|     13|                len += snprintf((char *) &ret[len], max - len, ":%d", uri->port);
 1184|     13|            }
 1185|    499|	} else if (uri->authority != NULL) {
  ------------------
  |  Branch (1185:13): [True: 0, False: 499]
  ------------------
 1186|      0|	    if (len + 3 >= max) {
  ------------------
  |  Branch (1186:10): [True: 0, False: 0]
  ------------------
 1187|      0|                temp = xmlSaveUriRealloc(ret, &max);
 1188|      0|                if (temp == NULL) goto mem_error;
  ------------------
  |  Branch (1188:21): [True: 0, False: 0]
  ------------------
 1189|      0|                ret = temp;
 1190|      0|	    }
 1191|      0|	    ret[len++] = '/';
 1192|      0|	    ret[len++] = '/';
 1193|      0|	    p = uri->authority;
 1194|      0|	    while (*p != 0) {
  ------------------
  |  Branch (1194:13): [True: 0, False: 0]
  ------------------
 1195|      0|		if (len + 3 >= max) {
  ------------------
  |  Branch (1195:7): [True: 0, False: 0]
  ------------------
 1196|      0|                    temp = xmlSaveUriRealloc(ret, &max);
 1197|      0|                    if (temp == NULL) goto mem_error;
  ------------------
  |  Branch (1197:25): [True: 0, False: 0]
  ------------------
 1198|      0|                    ret = temp;
 1199|      0|		}
 1200|      0|		if ((IS_UNRESERVED(*(p))) ||
  ------------------
  |  |  125|      0|#define IS_UNRESERVED(x) (IS_ALPHANUM(x) || IS_MARK(x))
  |  |  ------------------
  |  |  |  |   93|      0|#define IS_ALPHANUM(x) (IS_ALPHA(x) || IS_DIGIT(x))
  |  |  |  |  ------------------
  |  |  |  |  |  |   63|      0|#define IS_ALPHA(x) (IS_LOWALPHA(x) || IS_UPALPHA(x))
  |  |  |  |  |  |  ------------------
  |  |  |  |  |  |  |  |   72|      0|#define IS_LOWALPHA(x) (((x) >= 'a') && ((x) <= 'z'))
  |  |  |  |  |  |  |  |  ------------------
  |  |  |  |  |  |  |  |  |  Branch (72:25): [True: 0, False: 0]
  |  |  |  |  |  |  |  |  |  Branch (72:41): [True: 0, False: 0]
  |  |  |  |  |  |  |  |  ------------------
  |  |  |  |  |  |  ------------------
  |  |  |  |  |  |               #define IS_ALPHA(x) (IS_LOWALPHA(x) || IS_UPALPHA(x))
  |  |  |  |  |  |  ------------------
  |  |  |  |  |  |  |  |   79|      0|#define IS_UPALPHA(x) (((x) >= 'A') && ((x) <= 'Z'))
  |  |  |  |  |  |  |  |  ------------------
  |  |  |  |  |  |  |  |  |  Branch (79:24): [True: 0, False: 0]
  |  |  |  |  |  |  |  |  |  Branch (79:40): [True: 0, False: 0]
  |  |  |  |  |  |  |  |  ------------------
  |  |  |  |  |  |  ------------------
  |  |  |  |  ------------------
  |  |  |  |               #define IS_ALPHANUM(x) (IS_ALPHA(x) || IS_DIGIT(x))
  |  |  |  |  ------------------
  |  |  |  |  |  |   87|      0|#define IS_DIGIT(x) (((x) >= '0') && ((x) <= '9'))
  |  |  |  |  |  |  ------------------
  |  |  |  |  |  |  |  Branch (87:22): [True: 0, False: 0]
  |  |  |  |  |  |  |  Branch (87:38): [True: 0, False: 0]
  |  |  |  |  |  |  ------------------
  |  |  |  |  ------------------
  |  |  ------------------
  |  |               #define IS_UNRESERVED(x) (IS_ALPHANUM(x) || IS_MARK(x))
  |  |  ------------------
  |  |  |  |   99|      0|#define IS_MARK(x) (((x) == '-') || ((x) == '_') || ((x) == '.') ||     \
  |  |  |  |  ------------------
  |  |  |  |  |  Branch (99:21): [True: 0, False: 0]
  |  |  |  |  |  Branch (99:37): [True: 0, False: 0]
  |  |  |  |  |  Branch (99:53): [True: 0, False: 0]
  |  |  |  |  ------------------
  |  |  |  |  100|      0|    ((x) == '!') || ((x) == '~') || ((x) == '*') || ((x) == '\'') ||    \
  |  |  |  |  ------------------
  |  |  |  |  |  Branch (100:5): [True: 0, False: 0]
  |  |  |  |  |  Branch (100:21): [True: 0, False: 0]
  |  |  |  |  |  Branch (100:37): [True: 0, False: 0]
  |  |  |  |  |  Branch (100:53): [True: 0, False: 0]
  |  |  |  |  ------------------
  |  |  |  |  101|      0|    ((x) == '(') || ((x) == ')'))
  |  |  |  |  ------------------
  |  |  |  |  |  Branch (101:5): [True: 0, False: 0]
  |  |  |  |  |  Branch (101:21): [True: 0, False: 0]
  |  |  |  |  ------------------
  |  |  ------------------
  ------------------
 1201|      0|                    ((*(p) == '$')) || ((*(p) == ',')) || ((*(p) == ';')) ||
  ------------------
  |  Branch (1201:21): [True: 0, False: 0]
  |  Branch (1201:40): [True: 0, False: 0]
  |  Branch (1201:59): [True: 0, False: 0]
  ------------------
 1202|      0|                    ((*(p) == ':')) || ((*(p) == '@')) || ((*(p) == '&')) ||
  ------------------
  |  Branch (1202:21): [True: 0, False: 0]
  |  Branch (1202:40): [True: 0, False: 0]
  |  Branch (1202:59): [True: 0, False: 0]
  ------------------
 1203|      0|                    ((*(p) == '=')) || ((*(p) == '+')))
  ------------------
  |  Branch (1203:21): [True: 0, False: 0]
  |  Branch (1203:40): [True: 0, False: 0]
  ------------------
 1204|      0|		    ret[len++] = *p++;
 1205|      0|		else {
 1206|      0|		    int val = *(unsigned char *)p++;
 1207|      0|		    int hi = val / 0x10, lo = val % 0x10;
 1208|      0|		    ret[len++] = '%';
 1209|      0|		    ret[len++] = hi + (hi > 9? 'A'-10 : '0');
  ------------------
  |  Branch (1209:26): [True: 0, False: 0]
  ------------------
 1210|      0|		    ret[len++] = lo + (lo > 9? 'A'-10 : '0');
  ------------------
  |  Branch (1210:26): [True: 0, False: 0]
  ------------------
 1211|      0|		}
 1212|      0|	    }
 1213|    499|	} else if (uri->scheme != NULL) {
  ------------------
  |  Branch (1213:13): [True: 79, False: 420]
  ------------------
 1214|     79|	    if (len + 3 >= max) {
  ------------------
  |  Branch (1214:10): [True: 0, False: 79]
  ------------------
 1215|      0|                temp = xmlSaveUriRealloc(ret, &max);
 1216|      0|                if (temp == NULL) goto mem_error;
  ------------------
  |  Branch (1216:21): [True: 0, False: 0]
  ------------------
 1217|      0|                ret = temp;
 1218|      0|	    }
 1219|     79|	}
 1220|    538|	if (uri->path != NULL) {
  ------------------
  |  Branch (1220:6): [True: 493, False: 45]
  ------------------
 1221|    493|	    p = uri->path;
 1222|       |	    /*
 1223|       |	     * the colon in file:///d: should not be escaped or
 1224|       |	     * Windows accesses fail later.
 1225|       |	     */
 1226|    493|	    if ((uri->scheme != NULL) &&
  ------------------
  |  Branch (1226:10): [True: 90, False: 403]
  ------------------
 1227|    493|		(p[0] == '/') &&
  ------------------
  |  Branch (1227:3): [True: 56, False: 34]
  ------------------
 1228|    493|		(((p[1] >= 'a') && (p[1] <= 'z')) ||
  ------------------
  |  Branch (1228:5): [True: 25, False: 31]
  |  Branch (1228:22): [True: 25, False: 0]
  ------------------
 1229|     56|		 ((p[1] >= 'A') && (p[1] <= 'Z'))) &&
  ------------------
  |  Branch (1229:5): [True: 0, False: 31]
  |  Branch (1229:22): [True: 0, False: 0]
  ------------------
 1230|    493|		(p[2] == ':') &&
  ------------------
  |  Branch (1230:3): [True: 2, False: 23]
  ------------------
 1231|    493|	        (xmlStrEqual(BAD_CAST uri->scheme, BAD_CAST "file"))) {
  ------------------
  |  |   35|      2|#define BAD_CAST (xmlChar *)
  ------------------
              	        (xmlStrEqual(BAD_CAST uri->scheme, BAD_CAST "file"))) {
  ------------------
  |  |   35|      2|#define BAD_CAST (xmlChar *)
  ------------------
  |  Branch (1231:10): [True: 0, False: 2]
  ------------------
 1232|      0|		if (len + 3 >= max) {
  ------------------
  |  Branch (1232:7): [True: 0, False: 0]
  ------------------
 1233|      0|                    temp = xmlSaveUriRealloc(ret, &max);
 1234|      0|                    if (temp == NULL) goto mem_error;
  ------------------
  |  Branch (1234:25): [True: 0, False: 0]
  ------------------
 1235|      0|                    ret = temp;
 1236|      0|		}
 1237|      0|		ret[len++] = *p++;
 1238|      0|		ret[len++] = *p++;
 1239|      0|		ret[len++] = *p++;
 1240|      0|	    }
 1241|  7.80k|	    while (*p != 0) {
  ------------------
  |  Branch (1241:13): [True: 7.30k, False: 493]
  ------------------
 1242|  7.30k|		if (len + 3 >= max) {
  ------------------
  |  Branch (1242:7): [True: 6, False: 7.30k]
  ------------------
 1243|      6|                    temp = xmlSaveUriRealloc(ret, &max);
 1244|      6|                    if (temp == NULL) goto mem_error;
  ------------------
  |  Branch (1244:25): [True: 0, False: 6]
  ------------------
 1245|      6|                    ret = temp;
 1246|      6|		}
 1247|  7.30k|		if ((IS_UNRESERVED(*(p))) || ((*(p) == '/')) ||
  ------------------
  |  |  125|  7.30k|#define IS_UNRESERVED(x) (IS_ALPHANUM(x) || IS_MARK(x))
  |  |  ------------------
  |  |  |  |   93|  14.6k|#define IS_ALPHANUM(x) (IS_ALPHA(x) || IS_DIGIT(x))
  |  |  |  |  ------------------
  |  |  |  |  |  |   63|  14.6k|#define IS_ALPHA(x) (IS_LOWALPHA(x) || IS_UPALPHA(x))
  |  |  |  |  |  |  ------------------
  |  |  |  |  |  |  |  |   72|  14.6k|#define IS_LOWALPHA(x) (((x) >= 'a') && ((x) <= 'z'))
  |  |  |  |  |  |  |  |  ------------------
  |  |  |  |  |  |  |  |  |  Branch (72:25): [True: 2.86k, False: 4.44k]
  |  |  |  |  |  |  |  |  |  Branch (72:41): [True: 2.80k, False: 55]
  |  |  |  |  |  |  |  |  ------------------
  |  |  |  |  |  |  ------------------
  |  |  |  |  |  |               #define IS_ALPHA(x) (IS_LOWALPHA(x) || IS_UPALPHA(x))
  |  |  |  |  |  |  ------------------
  |  |  |  |  |  |  |  |   79|  4.49k|#define IS_UPALPHA(x) (((x) >= 'A') && ((x) <= 'Z'))
  |  |  |  |  |  |  |  |  ------------------
  |  |  |  |  |  |  |  |  |  Branch (79:24): [True: 349, False: 4.15k]
  |  |  |  |  |  |  |  |  |  Branch (79:40): [True: 239, False: 110]
  |  |  |  |  |  |  |  |  ------------------
  |  |  |  |  |  |  ------------------
  |  |  |  |  ------------------
  |  |  |  |               #define IS_ALPHANUM(x) (IS_ALPHA(x) || IS_DIGIT(x))
  |  |  |  |  ------------------
  |  |  |  |  |  |   87|  4.26k|#define IS_DIGIT(x) (((x) >= '0') && ((x) <= '9'))
  |  |  |  |  |  |  ------------------
  |  |  |  |  |  |  |  Branch (87:22): [True: 1.68k, False: 2.57k]
  |  |  |  |  |  |  |  Branch (87:38): [True: 689, False: 992]
  |  |  |  |  |  |  ------------------
  |  |  |  |  ------------------
  |  |  ------------------
  |  |               #define IS_UNRESERVED(x) (IS_ALPHANUM(x) || IS_MARK(x))
  |  |  ------------------
  |  |  |  |   99|  3.57k|#define IS_MARK(x) (((x) == '-') || ((x) == '_') || ((x) == '.') ||     \
  |  |  |  |  ------------------
  |  |  |  |  |  Branch (99:21): [True: 41, False: 3.53k]
  |  |  |  |  |  Branch (99:37): [True: 3, False: 3.52k]
  |  |  |  |  |  Branch (99:53): [True: 428, False: 3.09k]
  |  |  |  |  ------------------
  |  |  |  |  100|  3.57k|    ((x) == '!') || ((x) == '~') || ((x) == '*') || ((x) == '\'') ||    \
  |  |  |  |  ------------------
  |  |  |  |  |  Branch (100:5): [True: 27, False: 3.07k]
  |  |  |  |  |  Branch (100:21): [True: 32, False: 3.04k]
  |  |  |  |  |  Branch (100:37): [True: 15, False: 3.02k]
  |  |  |  |  |  Branch (100:53): [True: 69, False: 2.95k]
  |  |  |  |  ------------------
  |  |  |  |  101|  3.57k|    ((x) == '(') || ((x) == ')'))
  |  |  |  |  ------------------
  |  |  |  |  |  Branch (101:5): [True: 46, False: 2.91k]
  |  |  |  |  |  Branch (101:21): [True: 5, False: 2.90k]
  |  |  |  |  ------------------
  |  |  ------------------
  ------------------
  |  Branch (1247:32): [True: 1.11k, False: 1.79k]
  ------------------
 1248|  7.30k|                    ((*(p) == ';')) || ((*(p) == '@')) || ((*(p) == '&')) ||
  ------------------
  |  Branch (1248:21): [True: 24, False: 1.76k]
  |  Branch (1248:40): [True: 90, False: 1.67k]
  |  Branch (1248:59): [True: 186, False: 1.49k]
  ------------------
 1249|  7.30k|	            ((*(p) == '=')) || ((*(p) == '+')) || ((*(p) == '$')) ||
  ------------------
  |  Branch (1249:14): [True: 121, False: 1.37k]
  |  Branch (1249:33): [True: 25, False: 1.34k]
  |  Branch (1249:52): [True: 8, False: 1.33k]
  ------------------
 1250|  7.30k|	            ((*(p) == ',')))
  ------------------
  |  Branch (1250:14): [True: 10, False: 1.32k]
  ------------------
 1251|  5.97k|		    ret[len++] = *p++;
 1252|  1.32k|		else {
 1253|  1.32k|		    int val = *(unsigned char *)p++;
 1254|  1.32k|		    int hi = val / 0x10, lo = val % 0x10;
 1255|  1.32k|		    ret[len++] = '%';
 1256|  1.32k|		    ret[len++] = hi + (hi > 9? 'A'-10 : '0');
  ------------------
  |  Branch (1256:26): [True: 322, False: 1.00k]
  ------------------
 1257|  1.32k|		    ret[len++] = lo + (lo > 9? 'A'-10 : '0');
  ------------------
  |  Branch (1257:26): [True: 979, False: 349]
  ------------------
 1258|  1.32k|		}
 1259|  7.30k|	    }
 1260|    493|	}
 1261|    538|	if (uri->query_raw != NULL) {
  ------------------
  |  Branch (1261:6): [True: 137, False: 401]
  ------------------
 1262|    137|	    if (len + 1 >= max) {
  ------------------
  |  Branch (1262:10): [True: 0, False: 137]
  ------------------
 1263|      0|                temp = xmlSaveUriRealloc(ret, &max);
 1264|      0|                if (temp == NULL) goto mem_error;
  ------------------
  |  Branch (1264:21): [True: 0, False: 0]
  ------------------
 1265|      0|                ret = temp;
 1266|      0|	    }
 1267|    137|	    ret[len++] = '?';
 1268|    137|	    p = uri->query_raw;
 1269|    661|	    while (*p != 0) {
  ------------------
  |  Branch (1269:13): [True: 524, False: 137]
  ------------------
 1270|    524|		if (len + 1 >= max) {
  ------------------
  |  Branch (1270:7): [True: 0, False: 524]
  ------------------
 1271|      0|                    temp = xmlSaveUriRealloc(ret, &max);
 1272|      0|                    if (temp == NULL) goto mem_error;
  ------------------
  |  Branch (1272:25): [True: 0, False: 0]
  ------------------
 1273|      0|                    ret = temp;
 1274|      0|		}
 1275|    524|		ret[len++] = *p++;
 1276|    524|	    }
 1277|    401|	} else if (uri->query != NULL) {
  ------------------
  |  Branch (1277:13): [True: 0, False: 401]
  ------------------
 1278|      0|	    if (len + 3 >= max) {
  ------------------
  |  Branch (1278:10): [True: 0, False: 0]
  ------------------
 1279|      0|                temp = xmlSaveUriRealloc(ret, &max);
 1280|      0|                if (temp == NULL) goto mem_error;
  ------------------
  |  Branch (1280:21): [True: 0, False: 0]
  ------------------
 1281|      0|                ret = temp;
 1282|      0|	    }
 1283|      0|	    ret[len++] = '?';
 1284|      0|	    p = uri->query;
 1285|      0|	    while (*p != 0) {
  ------------------
  |  Branch (1285:13): [True: 0, False: 0]
  ------------------
 1286|      0|		if (len + 3 >= max) {
  ------------------
  |  Branch (1286:7): [True: 0, False: 0]
  ------------------
 1287|      0|                    temp = xmlSaveUriRealloc(ret, &max);
 1288|      0|                    if (temp == NULL) goto mem_error;
  ------------------
  |  Branch (1288:25): [True: 0, False: 0]
  ------------------
 1289|      0|                    ret = temp;
 1290|      0|		}
 1291|      0|		if ((IS_UNRESERVED(*(p))) || (IS_RESERVED(*(p))))
  ------------------
  |  |  125|      0|#define IS_UNRESERVED(x) (IS_ALPHANUM(x) || IS_MARK(x))
  |  |  ------------------
  |  |  |  |   93|      0|#define IS_ALPHANUM(x) (IS_ALPHA(x) || IS_DIGIT(x))
  |  |  |  |  ------------------
  |  |  |  |  |  |   63|      0|#define IS_ALPHA(x) (IS_LOWALPHA(x) || IS_UPALPHA(x))
  |  |  |  |  |  |  ------------------
  |  |  |  |  |  |  |  |   72|      0|#define IS_LOWALPHA(x) (((x) >= 'a') && ((x) <= 'z'))
  |  |  |  |  |  |  |  |  ------------------
  |  |  |  |  |  |  |  |  |  Branch (72:25): [True: 0, False: 0]
  |  |  |  |  |  |  |  |  |  Branch (72:41): [True: 0, False: 0]
  |  |  |  |  |  |  |  |  ------------------
  |  |  |  |  |  |  ------------------
  |  |  |  |  |  |               #define IS_ALPHA(x) (IS_LOWALPHA(x) || IS_UPALPHA(x))
  |  |  |  |  |  |  ------------------
  |  |  |  |  |  |  |  |   79|      0|#define IS_UPALPHA(x) (((x) >= 'A') && ((x) <= 'Z'))
  |  |  |  |  |  |  |  |  ------------------
  |  |  |  |  |  |  |  |  |  Branch (79:24): [True: 0, False: 0]
  |  |  |  |  |  |  |  |  |  Branch (79:40): [True: 0, False: 0]
  |  |  |  |  |  |  |  |  ------------------
  |  |  |  |  |  |  ------------------
  |  |  |  |  ------------------
  |  |  |  |               #define IS_ALPHANUM(x) (IS_ALPHA(x) || IS_DIGIT(x))
  |  |  |  |  ------------------
  |  |  |  |  |  |   87|      0|#define IS_DIGIT(x) (((x) >= '0') && ((x) <= '9'))
  |  |  |  |  |  |  ------------------
  |  |  |  |  |  |  |  Branch (87:22): [True: 0, False: 0]
  |  |  |  |  |  |  |  Branch (87:38): [True: 0, False: 0]
  |  |  |  |  |  |  ------------------
  |  |  |  |  ------------------
  |  |  ------------------
  |  |               #define IS_UNRESERVED(x) (IS_ALPHANUM(x) || IS_MARK(x))
  |  |  ------------------
  |  |  |  |   99|      0|#define IS_MARK(x) (((x) == '-') || ((x) == '_') || ((x) == '.') ||     \
  |  |  |  |  ------------------
  |  |  |  |  |  Branch (99:21): [True: 0, False: 0]
  |  |  |  |  |  Branch (99:37): [True: 0, False: 0]
  |  |  |  |  |  Branch (99:53): [True: 0, False: 0]
  |  |  |  |  ------------------
  |  |  |  |  100|      0|    ((x) == '!') || ((x) == '~') || ((x) == '*') || ((x) == '\'') ||    \
  |  |  |  |  ------------------
  |  |  |  |  |  Branch (100:5): [True: 0, False: 0]
  |  |  |  |  |  Branch (100:21): [True: 0, False: 0]
  |  |  |  |  |  Branch (100:37): [True: 0, False: 0]
  |  |  |  |  |  Branch (100:53): [True: 0, False: 0]
  |  |  |  |  ------------------
  |  |  |  |  101|      0|    ((x) == '(') || ((x) == ')'))
  |  |  |  |  ------------------
  |  |  |  |  |  Branch (101:5): [True: 0, False: 0]
  |  |  |  |  |  Branch (101:21): [True: 0, False: 0]
  |  |  |  |  ------------------
  |  |  ------------------
  ------------------
              		if ((IS_UNRESERVED(*(p))) || (IS_RESERVED(*(p))))
  ------------------
  |  |  116|      0|#define IS_RESERVED(x) (((x) == ';') || ((x) == '/') || ((x) == '?') || \
  |  |  ------------------
  |  |  |  Branch (116:25): [True: 0, False: 0]
  |  |  |  Branch (116:41): [True: 0, False: 0]
  |  |  |  Branch (116:57): [True: 0, False: 0]
  |  |  ------------------
  |  |  117|      0|        ((x) == ':') || ((x) == '@') || ((x) == '&') || ((x) == '=') || \
  |  |  ------------------
  |  |  |  Branch (117:9): [True: 0, False: 0]
  |  |  |  Branch (117:25): [True: 0, False: 0]
  |  |  |  Branch (117:41): [True: 0, False: 0]
  |  |  |  Branch (117:57): [True: 0, False: 0]
  |  |  ------------------
  |  |  118|      0|        ((x) == '+') || ((x) == '$') || ((x) == ',') || ((x) == '[') || \
  |  |  ------------------
  |  |  |  Branch (118:9): [True: 0, False: 0]
  |  |  |  Branch (118:25): [True: 0, False: 0]
  |  |  |  Branch (118:41): [True: 0, False: 0]
  |  |  |  Branch (118:57): [True: 0, False: 0]
  |  |  ------------------
  |  |  119|      0|        ((x) == ']'))
  |  |  ------------------
  |  |  |  Branch (119:9): [True: 0, False: 0]
  |  |  ------------------
  ------------------
 1292|      0|		    ret[len++] = *p++;
 1293|      0|		else {
 1294|      0|		    int val = *(unsigned char *)p++;
 1295|      0|		    int hi = val / 0x10, lo = val % 0x10;
 1296|      0|		    ret[len++] = '%';
 1297|      0|		    ret[len++] = hi + (hi > 9? 'A'-10 : '0');
  ------------------
  |  Branch (1297:26): [True: 0, False: 0]
  ------------------
 1298|      0|		    ret[len++] = lo + (lo > 9? 'A'-10 : '0');
  ------------------
  |  Branch (1298:26): [True: 0, False: 0]
  ------------------
 1299|      0|		}
 1300|      0|	    }
 1301|      0|	}
 1302|    538|    }
 1303|    538|    if (uri->fragment != NULL) {
  ------------------
  |  Branch (1303:9): [True: 151, False: 387]
  ------------------
 1304|    151|	if (len + 3 >= max) {
  ------------------
  |  Branch (1304:6): [True: 0, False: 151]
  ------------------
 1305|      0|            temp = xmlSaveUriRealloc(ret, &max);
 1306|      0|            if (temp == NULL) goto mem_error;
  ------------------
  |  Branch (1306:17): [True: 0, False: 0]
  ------------------
 1307|      0|            ret = temp;
 1308|      0|	}
 1309|    151|	ret[len++] = '#';
 1310|    151|	p = uri->fragment;
 1311|    532|	while (*p != 0) {
  ------------------
  |  Branch (1311:9): [True: 381, False: 151]
  ------------------
 1312|    381|	    if (len + 3 >= max) {
  ------------------
  |  Branch (1312:10): [True: 0, False: 381]
  ------------------
 1313|      0|                temp = xmlSaveUriRealloc(ret, &max);
 1314|      0|                if (temp == NULL) goto mem_error;
  ------------------
  |  Branch (1314:21): [True: 0, False: 0]
  ------------------
 1315|      0|                ret = temp;
 1316|      0|	    }
 1317|    381|	    if ((IS_UNRESERVED(*(p))) || (IS_RESERVED(*(p))))
  ------------------
  |  |  125|    381|#define IS_UNRESERVED(x) (IS_ALPHANUM(x) || IS_MARK(x))
  |  |  ------------------
  |  |  |  |   93|    762|#define IS_ALPHANUM(x) (IS_ALPHA(x) || IS_DIGIT(x))
  |  |  |  |  ------------------
  |  |  |  |  |  |   63|    762|#define IS_ALPHA(x) (IS_LOWALPHA(x) || IS_UPALPHA(x))
  |  |  |  |  |  |  ------------------
  |  |  |  |  |  |  |  |   72|    762|#define IS_LOWALPHA(x) (((x) >= 'a') && ((x) <= 'z'))
  |  |  |  |  |  |  |  |  ------------------
  |  |  |  |  |  |  |  |  |  Branch (72:25): [True: 233, False: 148]
  |  |  |  |  |  |  |  |  |  Branch (72:41): [True: 223, False: 10]
  |  |  |  |  |  |  |  |  ------------------
  |  |  |  |  |  |  ------------------
  |  |  |  |  |  |               #define IS_ALPHA(x) (IS_LOWALPHA(x) || IS_UPALPHA(x))
  |  |  |  |  |  |  ------------------
  |  |  |  |  |  |  |  |   79|    158|#define IS_UPALPHA(x) (((x) >= 'A') && ((x) <= 'Z'))
  |  |  |  |  |  |  |  |  ------------------
  |  |  |  |  |  |  |  |  |  Branch (79:24): [True: 14, False: 144]
  |  |  |  |  |  |  |  |  |  Branch (79:40): [True: 4, False: 10]
  |  |  |  |  |  |  |  |  ------------------
  |  |  |  |  |  |  ------------------
  |  |  |  |  ------------------
  |  |  |  |               #define IS_ALPHANUM(x) (IS_ALPHA(x) || IS_DIGIT(x))
  |  |  |  |  ------------------
  |  |  |  |  |  |   87|    154|#define IS_DIGIT(x) (((x) >= '0') && ((x) <= '9'))
  |  |  |  |  |  |  ------------------
  |  |  |  |  |  |  |  Branch (87:22): [True: 109, False: 45]
  |  |  |  |  |  |  |  Branch (87:38): [True: 10, False: 99]
  |  |  |  |  |  |  ------------------
  |  |  |  |  ------------------
  |  |  ------------------
  |  |               #define IS_UNRESERVED(x) (IS_ALPHANUM(x) || IS_MARK(x))
  |  |  ------------------
  |  |  |  |   99|    144|#define IS_MARK(x) (((x) == '-') || ((x) == '_') || ((x) == '.') ||     \
  |  |  |  |  ------------------
  |  |  |  |  |  Branch (99:21): [True: 2, False: 142]
  |  |  |  |  |  Branch (99:37): [True: 0, False: 142]
  |  |  |  |  |  Branch (99:53): [True: 13, False: 129]
  |  |  |  |  ------------------
  |  |  |  |  100|    144|    ((x) == '!') || ((x) == '~') || ((x) == '*') || ((x) == '\'') ||    \
  |  |  |  |  ------------------
  |  |  |  |  |  Branch (100:5): [True: 2, False: 127]
  |  |  |  |  |  Branch (100:21): [True: 10, False: 117]
  |  |  |  |  |  Branch (100:37): [True: 0, False: 117]
  |  |  |  |  |  Branch (100:53): [True: 2, False: 115]
  |  |  |  |  ------------------
  |  |  |  |  101|    144|    ((x) == '(') || ((x) == ')'))
  |  |  |  |  ------------------
  |  |  |  |  |  Branch (101:5): [True: 2, False: 113]
  |  |  |  |  |  Branch (101:21): [True: 0, False: 113]
  |  |  |  |  ------------------
  |  |  ------------------
  ------------------
              	    if ((IS_UNRESERVED(*(p))) || (IS_RESERVED(*(p))))
  ------------------
  |  |  116|    113|#define IS_RESERVED(x) (((x) == ';') || ((x) == '/') || ((x) == '?') || \
  |  |  ------------------
  |  |  |  Branch (116:25): [True: 4, False: 109]
  |  |  |  Branch (116:41): [True: 22, False: 87]
  |  |  |  Branch (116:57): [True: 29, False: 58]
  |  |  ------------------
  |  |  117|    113|        ((x) == ':') || ((x) == '@') || ((x) == '&') || ((x) == '=') || \
  |  |  ------------------
  |  |  |  Branch (117:9): [True: 12, False: 46]
  |  |  |  Branch (117:25): [True: 22, False: 24]
  |  |  |  Branch (117:41): [True: 2, False: 22]
  |  |  |  Branch (117:57): [True: 22, False: 0]
  |  |  ------------------
  |  |  118|    113|        ((x) == '+') || ((x) == '$') || ((x) == ',') || ((x) == '[') || \
  |  |  ------------------
  |  |  |  Branch (118:9): [True: 0, False: 0]
  |  |  |  Branch (118:25): [True: 0, False: 0]
  |  |  |  Branch (118:41): [True: 0, False: 0]
  |  |  |  Branch (118:57): [True: 0, False: 0]
  |  |  ------------------
  |  |  119|    113|        ((x) == ']'))
  |  |  ------------------
  |  |  |  Branch (119:9): [True: 0, False: 0]
  |  |  ------------------
  ------------------
 1318|    381|		ret[len++] = *p++;
 1319|      0|	    else {
 1320|      0|		int val = *(unsigned char *)p++;
 1321|      0|		int hi = val / 0x10, lo = val % 0x10;
 1322|      0|		ret[len++] = '%';
 1323|      0|		ret[len++] = hi + (hi > 9? 'A'-10 : '0');
  ------------------
  |  Branch (1323:22): [True: 0, False: 0]
  ------------------
 1324|      0|		ret[len++] = lo + (lo > 9? 'A'-10 : '0');
  ------------------
  |  Branch (1324:22): [True: 0, False: 0]
  ------------------
 1325|      0|	    }
 1326|    381|	}
 1327|    151|    }
 1328|    538|    if (len >= max) {
  ------------------
  |  Branch (1328:9): [True: 0, False: 538]
  ------------------
 1329|      0|        temp = xmlSaveUriRealloc(ret, &max);
 1330|      0|        if (temp == NULL) goto mem_error;
  ------------------
  |  Branch (1330:13): [True: 0, False: 0]
  ------------------
 1331|      0|        ret = temp;
 1332|      0|    }
 1333|    538|    ret[len] = 0;
 1334|    538|    return(ret);
 1335|       |
 1336|      0|mem_error:
 1337|      0|    xmlFree(ret);
 1338|      0|    return(NULL);
 1339|    538|}
xmlFreeURI:
 1396|  2.62k|xmlFreeURI(xmlURIPtr uri) {
 1397|  2.62k|    if (uri == NULL) return;
  ------------------
  |  Branch (1397:9): [True: 476, False: 2.15k]
  ------------------
 1398|       |
 1399|  2.15k|    if (uri->scheme != NULL) xmlFree(uri->scheme);
  ------------------
  |  Branch (1399:9): [True: 331, False: 1.81k]
  ------------------
 1400|  2.15k|    if (uri->server != NULL) xmlFree(uri->server);
  ------------------
  |  Branch (1400:9): [True: 140, False: 2.01k]
  ------------------
 1401|  2.15k|    if (uri->user != NULL) xmlFree(uri->user);
  ------------------
  |  Branch (1401:9): [True: 80, False: 2.07k]
  ------------------
 1402|  2.15k|    if (uri->path != NULL) xmlFree(uri->path);
  ------------------
  |  Branch (1402:9): [True: 727, False: 1.42k]
  ------------------
 1403|  2.15k|    if (uri->fragment != NULL) xmlFree(uri->fragment);
  ------------------
  |  Branch (1403:9): [True: 351, False: 1.79k]
  ------------------
 1404|  2.15k|    if (uri->opaque != NULL) xmlFree(uri->opaque);
  ------------------
  |  Branch (1404:9): [True: 0, False: 2.15k]
  ------------------
 1405|  2.15k|    if (uri->authority != NULL) xmlFree(uri->authority);
  ------------------
  |  Branch (1405:9): [True: 0, False: 2.15k]
  ------------------
 1406|  2.15k|    if (uri->query != NULL) xmlFree(uri->query);
  ------------------
  |  Branch (1406:9): [True: 336, False: 1.81k]
  ------------------
 1407|  2.15k|    if (uri->query_raw != NULL) xmlFree(uri->query_raw);
  ------------------
  |  Branch (1407:9): [True: 332, False: 1.81k]
  ------------------
 1408|  2.15k|    xmlFree(uri);
 1409|  2.15k|}
xmlNormalizeURIPath:
 1429|    426|xmlNormalizeURIPath(char *path) {
 1430|    426|    char *cur, *out;
 1431|       |
 1432|    426|    if (path == NULL)
  ------------------
  |  Branch (1432:9): [True: 124, False: 302]
  ------------------
 1433|    124|	return(-1);
 1434|       |
 1435|       |    /* Skip all initial "/" chars.  We want to get to the beginning of the
 1436|       |     * first non-empty segment.
 1437|       |     */
 1438|    302|    cur = path;
 1439|    317|    while (cur[0] == '/')
  ------------------
  |  Branch (1439:12): [True: 15, False: 302]
  ------------------
 1440|     15|      ++cur;
 1441|    302|    if (cur[0] == '\0')
  ------------------
  |  Branch (1441:9): [True: 2, False: 300]
  ------------------
 1442|      2|      return(0);
 1443|       |
 1444|       |    /* Keep everything we've seen so far.  */
 1445|    300|    out = cur;
 1446|       |
 1447|       |    /*
 1448|       |     * Analyze each segment in sequence for cases (c) and (d).
 1449|       |     */
 1450|    997|    while (cur[0] != '\0') {
  ------------------
  |  Branch (1450:12): [True: 987, False: 10]
  ------------------
 1451|       |	/*
 1452|       |	 * c) All occurrences of "./", where "." is a complete path segment,
 1453|       |	 *    are removed from the buffer string.
 1454|       |	 */
 1455|    987|	if ((cur[0] == '.') && (cur[1] == '/')) {
  ------------------
  |  Branch (1455:6): [True: 68, False: 919]
  |  Branch (1455:25): [True: 2, False: 66]
  ------------------
 1456|      2|	    cur += 2;
 1457|       |	    /* '//' normalization should be done at this point too */
 1458|      2|	    while (cur[0] == '/')
  ------------------
  |  Branch (1458:13): [True: 0, False: 2]
  ------------------
 1459|      0|		cur++;
 1460|      2|	    continue;
 1461|      2|	}
 1462|       |
 1463|       |	/*
 1464|       |	 * d) If the buffer string ends with "." as a complete path segment,
 1465|       |	 *    that "." is removed.
 1466|       |	 */
 1467|    985|	if ((cur[0] == '.') && (cur[1] == '\0'))
  ------------------
  |  Branch (1467:6): [True: 66, False: 919]
  |  Branch (1467:25): [True: 4, False: 62]
  ------------------
 1468|      4|	    break;
 1469|       |
 1470|       |	/* Otherwise keep the segment.  */
 1471|  6.20k|	while (cur[0] != '/') {
  ------------------
  |  Branch (1471:9): [True: 5.51k, False: 695]
  ------------------
 1472|  5.51k|            if (cur[0] == '\0')
  ------------------
  |  Branch (1472:17): [True: 286, False: 5.22k]
  ------------------
 1473|    286|              goto done_cd;
 1474|  5.22k|	    (out++)[0] = (cur++)[0];
 1475|  5.22k|	}
 1476|       |	/* normalize // */
 1477|    822|	while ((cur[0] == '/') && (cur[1] == '/'))
  ------------------
  |  Branch (1477:9): [True: 822, False: 0]
  |  Branch (1477:28): [True: 127, False: 695]
  ------------------
 1478|    127|	    cur++;
 1479|       |
 1480|    695|        (out++)[0] = (cur++)[0];
 1481|    695|    }
 1482|    300| done_cd:
 1483|    300|    out[0] = '\0';
 1484|       |
 1485|       |    /* Reset to the beginning of the first segment for the next sequence.  */
 1486|    300|    cur = path;
 1487|    313|    while (cur[0] == '/')
  ------------------
  |  Branch (1487:12): [True: 13, False: 300]
  ------------------
 1488|     13|      ++cur;
 1489|    300|    if (cur[0] == '\0')
  ------------------
  |  Branch (1489:9): [True: 1, False: 299]
  ------------------
 1490|      1|	return(0);
 1491|       |
 1492|       |    /*
 1493|       |     * Analyze each segment in sequence for cases (e) and (f).
 1494|       |     *
 1495|       |     * e) All occurrences of "<segment>/../", where <segment> is a
 1496|       |     *    complete path segment not equal to "..", are removed from the
 1497|       |     *    buffer string.  Removal of these path segments is performed
 1498|       |     *    iteratively, removing the leftmost matching pattern on each
 1499|       |     *    iteration, until no matching pattern remains.
 1500|       |     *
 1501|       |     * f) If the buffer string ends with "<segment>/..", where <segment>
 1502|       |     *    is a complete path segment not equal to "..", that
 1503|       |     *    "<segment>/.." is removed.
 1504|       |     *
 1505|       |     * To satisfy the "iterative" clause in (e), we need to collapse the
 1506|       |     * string every time we find something that needs to be removed.  Thus,
 1507|       |     * we don't need to keep two pointers into the string: we only need a
 1508|       |     * "current position" pointer.
 1509|       |     */
 1510|    993|    while (1) {
  ------------------
  |  Branch (1510:12): [Folded - Ignored]
  ------------------
 1511|    993|        char *segp, *tmp;
 1512|       |
 1513|       |        /* At the beginning of each iteration of this loop, "cur" points to
 1514|       |         * the first character of the segment we want to examine.
 1515|       |         */
 1516|       |
 1517|       |        /* Find the end of the current segment.  */
 1518|    993|        segp = cur;
 1519|  6.21k|        while ((segp[0] != '/') && (segp[0] != '\0'))
  ------------------
  |  Branch (1519:16): [True: 5.52k, False: 695]
  |  Branch (1519:36): [True: 5.22k, False: 298]
  ------------------
 1520|  5.22k|          ++segp;
 1521|       |
 1522|       |        /* If this is the last segment, we're done (we need at least two
 1523|       |         * segments to meet the criteria for the (e) and (f) cases).
 1524|       |         */
 1525|    993|        if (segp[0] == '\0')
  ------------------
  |  Branch (1525:13): [True: 298, False: 695]
  ------------------
 1526|    298|          break;
 1527|       |
 1528|       |        /* If the first segment is "..", or if the next segment _isn't_ "..",
 1529|       |         * keep this segment and try the next one.
 1530|       |         */
 1531|    695|        ++segp;
 1532|    695|        if (((cur[0] == '.') && (cur[1] == '.') && (segp == cur+3))
  ------------------
  |  Branch (1532:14): [True: 45, False: 650]
  |  Branch (1532:33): [True: 5, False: 40]
  |  Branch (1532:52): [True: 0, False: 5]
  ------------------
 1533|    695|            || ((segp[0] != '.') || (segp[1] != '.')
  ------------------
  |  Branch (1533:17): [True: 675, False: 20]
  |  Branch (1533:37): [True: 19, False: 1]
  ------------------
 1534|    695|                || ((segp[2] != '/') && (segp[2] != '\0')))) {
  ------------------
  |  Branch (1534:21): [True: 1, False: 0]
  |  Branch (1534:41): [True: 0, False: 1]
  ------------------
 1535|    694|          cur = segp;
 1536|    694|          continue;
 1537|    694|        }
 1538|       |
 1539|       |        /* If we get here, remove this segment and the next one and back up
 1540|       |         * to the previous segment (if there is one), to implement the
 1541|       |         * "iteratively" clause.  It's pretty much impossible to back up
 1542|       |         * while maintaining two pointers into the buffer, so just compact
 1543|       |         * the whole buffer now.
 1544|       |         */
 1545|       |
 1546|       |        /* If this is the end of the buffer, we're done.  */
 1547|      1|        if (segp[2] == '\0') {
  ------------------
  |  Branch (1547:13): [True: 1, False: 0]
  ------------------
 1548|      1|          cur[0] = '\0';
 1549|      1|          break;
 1550|      1|        }
 1551|       |        /* Valgrind complained, strcpy(cur, segp + 3); */
 1552|       |        /* string will overlap, do not use strcpy */
 1553|      0|        tmp = cur;
 1554|      0|        segp += 3;
 1555|      0|        while ((*tmp++ = *segp++) != 0)
  ------------------
  |  Branch (1555:16): [True: 0, False: 0]
  ------------------
 1556|      0|          ;
 1557|       |
 1558|       |        /* If there are no previous segments, then keep going from here.  */
 1559|      0|        segp = cur;
 1560|      0|        while ((segp > path) && ((--segp)[0] == '/'))
  ------------------
  |  Branch (1560:16): [True: 0, False: 0]
  |  Branch (1560:33): [True: 0, False: 0]
  ------------------
 1561|      0|          ;
 1562|      0|        if (segp == path)
  ------------------
  |  Branch (1562:13): [True: 0, False: 0]
  ------------------
 1563|      0|          continue;
 1564|       |
 1565|       |        /* "segp" is pointing to the end of a previous segment; find it's
 1566|       |         * start.  We need to back up to the previous segment and start
 1567|       |         * over with that to handle things like "foo/bar/../..".  If we
 1568|       |         * don't do this, then on the first pass we'll remove the "bar/..",
 1569|       |         * but be pointing at the second ".." so we won't realize we can also
 1570|       |         * remove the "foo/..".
 1571|       |         */
 1572|      0|        cur = segp;
 1573|      0|        while ((cur > path) && (cur[-1] != '/'))
  ------------------
  |  Branch (1573:16): [True: 0, False: 0]
  |  Branch (1573:32): [True: 0, False: 0]
  ------------------
 1574|      0|          --cur;
 1575|      0|    }
 1576|    299|    out[0] = '\0';
 1577|       |
 1578|       |    /*
 1579|       |     * g) If the resulting buffer string still begins with one or more
 1580|       |     *    complete path segments of "..", then the reference is
 1581|       |     *    considered to be in error. Implementations may handle this
 1582|       |     *    error by retaining these components in the resolved path (i.e.,
 1583|       |     *    treating them as part of the final URI), by removing them from
 1584|       |     *    the resolved path (i.e., discarding relative levels above the
 1585|       |     *    root), or by avoiding traversal of the reference.
 1586|       |     *
 1587|       |     * We discard them from the final path.
 1588|       |     */
 1589|    299|    if (path[0] == '/') {
  ------------------
  |  Branch (1589:9): [True: 9, False: 290]
  ------------------
 1590|      9|      cur = path;
 1591|      9|      while ((cur[0] == '/') && (cur[1] == '.') && (cur[2] == '.')
  ------------------
  |  Branch (1591:14): [True: 9, False: 0]
  |  Branch (1591:33): [True: 1, False: 8]
  |  Branch (1591:52): [True: 0, False: 1]
  ------------------
 1592|      9|             && ((cur[3] == '/') || (cur[3] == '\0')))
  ------------------
  |  Branch (1592:18): [True: 0, False: 0]
  |  Branch (1592:37): [True: 0, False: 0]
  ------------------
 1593|      0|	cur += 3;
 1594|       |
 1595|      9|      if (cur != path) {
  ------------------
  |  Branch (1595:11): [True: 0, False: 9]
  ------------------
 1596|      0|	out = path;
 1597|      0|	while (cur[0] != '\0')
  ------------------
  |  Branch (1597:9): [True: 0, False: 0]
  ------------------
 1598|      0|          (out++)[0] = (cur++)[0];
 1599|      0|	out[0] = 0;
 1600|      0|      }
 1601|      9|    }
 1602|       |
 1603|    299|    return(0);
 1604|    300|}
xmlURIUnescapeString:
 1629|  3.53k|xmlURIUnescapeString(const char *str, int len, char *target) {
 1630|  3.53k|    char *ret, *out;
 1631|  3.53k|    const char *in;
 1632|       |
 1633|  3.53k|    if (str == NULL)
  ------------------
  |  Branch (1633:9): [True: 3, False: 3.53k]
  ------------------
 1634|      3|	return(NULL);
 1635|  3.53k|    if (len <= 0) len = strlen(str);
  ------------------
  |  Branch (1635:9): [True: 479, False: 3.05k]
  ------------------
 1636|  3.53k|    if (len < 0) return(NULL);
  ------------------
  |  Branch (1636:9): [True: 0, False: 3.53k]
  ------------------
 1637|       |
 1638|  3.53k|    if (target == NULL) {
  ------------------
  |  Branch (1638:9): [True: 3.53k, False: 0]
  ------------------
 1639|  3.53k|	ret = (char *) xmlMallocAtomic(len + 1);
 1640|  3.53k|	if (ret == NULL) {
  ------------------
  |  Branch (1640:6): [True: 107, False: 3.42k]
  ------------------
 1641|    107|            xmlURIErrMemory("unescaping URI value\n");
 1642|    107|	    return(NULL);
 1643|    107|	}
 1644|  3.53k|    } else
 1645|      0|	ret = target;
 1646|  3.42k|    in = str;
 1647|  3.42k|    out = ret;
 1648|  28.0k|    while(len > 0) {
  ------------------
  |  Branch (1648:11): [True: 24.6k, False: 3.42k]
  ------------------
 1649|  24.6k|	if ((len > 2) && (*in == '%') && (is_hex(in[1])) && (is_hex(in[2]))) {
  ------------------
  |  Branch (1649:6): [True: 18.6k, False: 6.04k]
  |  Branch (1649:19): [True: 185, False: 18.4k]
  |  Branch (1649:35): [True: 183, False: 2]
  |  Branch (1649:54): [True: 182, False: 1]
  ------------------
 1650|    182|            int c = 0;
 1651|    182|	    in++;
 1652|    182|	    if ((*in >= '0') && (*in <= '9'))
  ------------------
  |  Branch (1652:10): [True: 182, False: 0]
  |  Branch (1652:26): [True: 65, False: 117]
  ------------------
 1653|     65|	        c = (*in - '0');
 1654|    117|	    else if ((*in >= 'a') && (*in <= 'f'))
  ------------------
  |  Branch (1654:15): [True: 0, False: 117]
  |  Branch (1654:31): [True: 0, False: 0]
  ------------------
 1655|      0|	        c = (*in - 'a') + 10;
 1656|    117|	    else if ((*in >= 'A') && (*in <= 'F'))
  ------------------
  |  Branch (1656:15): [True: 117, False: 0]
  |  Branch (1656:31): [True: 117, False: 0]
  ------------------
 1657|    117|	        c = (*in - 'A') + 10;
 1658|    182|	    in++;
 1659|    182|	    if ((*in >= '0') && (*in <= '9'))
  ------------------
  |  Branch (1659:10): [True: 182, False: 0]
  |  Branch (1659:26): [True: 76, False: 106]
  ------------------
 1660|     76|	        c = c * 16 + (*in - '0');
 1661|    106|	    else if ((*in >= 'a') && (*in <= 'f'))
  ------------------
  |  Branch (1661:15): [True: 0, False: 106]
  |  Branch (1661:31): [True: 0, False: 0]
  ------------------
 1662|      0|	        c = c * 16 + (*in - 'a') + 10;
 1663|    106|	    else if ((*in >= 'A') && (*in <= 'F'))
  ------------------
  |  Branch (1663:15): [True: 106, False: 0]
  |  Branch (1663:31): [True: 106, False: 0]
  ------------------
 1664|    106|	        c = c * 16 + (*in - 'A') + 10;
 1665|    182|	    in++;
 1666|    182|	    len -= 3;
 1667|       |            /* Explicit sign change */
 1668|    182|	    *out++ = (char) c;
 1669|  24.4k|	} else {
 1670|  24.4k|	    *out++ = *in++;
 1671|  24.4k|	    len--;
 1672|  24.4k|	}
 1673|  24.6k|    }
 1674|  3.42k|    *out = 0;
 1675|  3.42k|    return(ret);
 1676|  3.53k|}
xmlURIEscapeStr:
 1689|    848|xmlURIEscapeStr(const xmlChar *str, const xmlChar *list) {
 1690|    848|    xmlChar *ret, ch;
 1691|    848|    xmlChar *temp;
 1692|    848|    const xmlChar *in;
 1693|    848|    int len, out;
 1694|       |
 1695|    848|    if (str == NULL)
  ------------------
  |  Branch (1695:9): [True: 3, False: 845]
  ------------------
 1696|      3|	return(NULL);
 1697|    845|    if (str[0] == 0)
  ------------------
  |  Branch (1697:9): [True: 10, False: 835]
  ------------------
 1698|     10|	return(xmlStrdup(str));
 1699|    835|    len = xmlStrlen(str);
 1700|    835|    if (!(len > 0)) return(NULL);
  ------------------
  |  Branch (1700:9): [True: 0, False: 835]
  ------------------
 1701|       |
 1702|    835|    len += 20;
 1703|    835|    ret = (xmlChar *) xmlMallocAtomic(len);
 1704|    835|    if (ret == NULL) {
  ------------------
  |  Branch (1704:9): [True: 139, False: 696]
  ------------------
 1705|    139|        xmlURIErrMemory("escaping URI value\n");
 1706|    139|	return(NULL);
 1707|    139|    }
 1708|    696|    in = (const xmlChar *) str;
 1709|    696|    out = 0;
 1710|  11.4k|    while(*in != 0) {
  ------------------
  |  Branch (1710:11): [True: 10.8k, False: 694]
  ------------------
 1711|  10.8k|	if (len - out <= 3) {
  ------------------
  |  Branch (1711:6): [True: 144, False: 10.6k]
  ------------------
 1712|    144|            temp = xmlSaveUriRealloc(ret, &len);
 1713|    144|	    if (temp == NULL) {
  ------------------
  |  Branch (1713:10): [True: 2, False: 142]
  ------------------
 1714|      2|                xmlURIErrMemory("escaping URI value\n");
 1715|      2|		xmlFree(ret);
 1716|      2|		return(NULL);
 1717|      2|	    }
 1718|    142|	    ret = temp;
 1719|    142|	}
 1720|       |
 1721|  10.7k|	ch = *in;
 1722|       |
 1723|  10.7k|	if ((ch != '@') && (!IS_UNRESERVED(ch)) && (!xmlStrchr(list, ch))) {
  ------------------
  |  |  125|  10.6k|#define IS_UNRESERVED(x) (IS_ALPHANUM(x) || IS_MARK(x))
  |  |  ------------------
  |  |  |  |   93|  21.2k|#define IS_ALPHANUM(x) (IS_ALPHA(x) || IS_DIGIT(x))
  |  |  |  |  ------------------
  |  |  |  |  |  |   63|  21.2k|#define IS_ALPHA(x) (IS_LOWALPHA(x) || IS_UPALPHA(x))
  |  |  |  |  |  |  ------------------
  |  |  |  |  |  |  |  |   72|  21.2k|#define IS_LOWALPHA(x) (((x) >= 'a') && ((x) <= 'z'))
  |  |  |  |  |  |  |  |  ------------------
  |  |  |  |  |  |  |  |  |  Branch (72:25): [True: 5.30k, False: 5.33k]
  |  |  |  |  |  |  |  |  |  Branch (72:41): [True: 4.64k, False: 653]
  |  |  |  |  |  |  |  |  ------------------
  |  |  |  |  |  |  ------------------
  |  |  |  |  |  |               #define IS_ALPHA(x) (IS_LOWALPHA(x) || IS_UPALPHA(x))
  |  |  |  |  |  |  ------------------
  |  |  |  |  |  |  |  |   79|  5.99k|#define IS_UPALPHA(x) (((x) >= 'A') && ((x) <= 'Z'))
  |  |  |  |  |  |  |  |  ------------------
  |  |  |  |  |  |  |  |  |  Branch (79:24): [True: 904, False: 5.08k]
  |  |  |  |  |  |  |  |  |  Branch (79:40): [True: 183, False: 721]
  |  |  |  |  |  |  |  |  ------------------
  |  |  |  |  |  |  ------------------
  |  |  |  |  ------------------
  |  |  |  |               #define IS_ALPHANUM(x) (IS_ALPHA(x) || IS_DIGIT(x))
  |  |  |  |  ------------------
  |  |  |  |  |  |   87|  5.80k|#define IS_DIGIT(x) (((x) >= '0') && ((x) <= '9'))
  |  |  |  |  |  |  ------------------
  |  |  |  |  |  |  |  Branch (87:22): [True: 2.89k, False: 2.91k]
  |  |  |  |  |  |  |  Branch (87:38): [True: 783, False: 2.11k]
  |  |  |  |  |  |  ------------------
  |  |  |  |  ------------------
  |  |  ------------------
  |  |               #define IS_UNRESERVED(x) (IS_ALPHANUM(x) || IS_MARK(x))
  |  |  ------------------
  |  |  |  |   99|  5.02k|#define IS_MARK(x) (((x) == '-') || ((x) == '_') || ((x) == '.') ||     \
  |  |  |  |  ------------------
  |  |  |  |  |  Branch (99:21): [True: 62, False: 4.96k]
  |  |  |  |  |  Branch (99:37): [True: 4, False: 4.95k]
  |  |  |  |  |  Branch (99:53): [True: 566, False: 4.39k]
  |  |  |  |  ------------------
  |  |  |  |  100|  5.02k|    ((x) == '!') || ((x) == '~') || ((x) == '*') || ((x) == '\'') ||    \
  |  |  |  |  ------------------
  |  |  |  |  |  Branch (100:5): [True: 25, False: 4.36k]
  |  |  |  |  |  Branch (100:21): [True: 45, False: 4.32k]
  |  |  |  |  |  Branch (100:37): [True: 19, False: 4.30k]
  |  |  |  |  |  Branch (100:53): [True: 72, False: 4.23k]
  |  |  |  |  ------------------
  |  |  |  |  101|  5.02k|    ((x) == '(') || ((x) == ')'))
  |  |  |  |  ------------------
  |  |  |  |  |  Branch (101:5): [True: 46, False: 4.18k]
  |  |  |  |  |  Branch (101:21): [True: 5, False: 4.18k]
  |  |  |  |  ------------------
  |  |  ------------------
  ------------------
  |  Branch (1723:6): [True: 10.6k, False: 160]
  |  Branch (1723:45): [True: 2.81k, False: 1.36k]
  ------------------
 1724|  2.81k|	    unsigned char val;
 1725|  2.81k|	    ret[out++] = '%';
 1726|  2.81k|	    val = ch >> 4;
 1727|  2.81k|	    if (val <= 9)
  ------------------
  |  Branch (1727:10): [True: 2.31k, False: 499]
  ------------------
 1728|  2.31k|		ret[out++] = '0' + val;
 1729|    499|	    else
 1730|    499|		ret[out++] = 'A' + val - 0xA;
 1731|  2.81k|	    val = ch & 0xF;
 1732|  2.81k|	    if (val <= 9)
  ------------------
  |  Branch (1732:10): [True: 576, False: 2.24k]
  ------------------
 1733|    576|		ret[out++] = '0' + val;
 1734|  2.24k|	    else
 1735|  2.24k|		ret[out++] = 'A' + val - 0xA;
 1736|  2.81k|	    in++;
 1737|  7.98k|	} else {
 1738|  7.98k|	    ret[out++] = *in++;
 1739|  7.98k|	}
 1740|       |
 1741|  10.7k|    }
 1742|    694|    ret[out] = 0;
 1743|    694|    return(ret);
 1744|    696|}
xmlURIEscape:
 1763|    426|{
 1764|    426|    xmlChar *ret, *segment = NULL;
 1765|    426|    xmlURIPtr uri;
 1766|    426|    int ret2;
 1767|       |
 1768|    426|    if (str == NULL)
  ------------------
  |  Branch (1768:9): [True: 3, False: 423]
  ------------------
 1769|      3|        return (NULL);
 1770|       |
 1771|    423|    uri = xmlCreateURI();
 1772|    423|    if (uri != NULL) {
  ------------------
  |  Branch (1772:9): [True: 370, False: 53]
  ------------------
 1773|       |	/*
 1774|       |	 * Allow escaping errors in the unescaped form
 1775|       |	 */
 1776|    370|        uri->cleanup = 1;
 1777|    370|        ret2 = xmlParseURIReference(uri, (const char *)str);
 1778|    370|        if (ret2) {
  ------------------
  |  Branch (1778:13): [True: 204, False: 166]
  ------------------
 1779|    204|            xmlFreeURI(uri);
 1780|    204|            return (NULL);
 1781|    204|        }
 1782|    370|    }
 1783|       |
 1784|    219|    if (!uri)
  ------------------
  |  Branch (1784:9): [True: 53, False: 166]
  ------------------
 1785|     53|        return NULL;
 1786|       |
 1787|    166|    ret = NULL;
 1788|       |
 1789|    166|#define NULLCHK(p) if(!p) { \
 1790|    166|         xmlURIErrMemory("escaping URI value\n"); \
 1791|    166|         xmlFreeURI(uri); \
 1792|    166|         xmlFree(ret); \
 1793|    166|         return NULL; } \
 1794|    166|
 1795|    166|    if (uri->scheme) {
  ------------------
  |  Branch (1795:9): [True: 52, False: 114]
  ------------------
 1796|     52|        segment = xmlURIEscapeStr(BAD_CAST uri->scheme, BAD_CAST "+-.");
  ------------------
  |  |   35|     52|#define BAD_CAST (xmlChar *)
  ------------------
                      segment = xmlURIEscapeStr(BAD_CAST uri->scheme, BAD_CAST "+-.");
  ------------------
  |  |   35|     52|#define BAD_CAST (xmlChar *)
  ------------------
 1797|     52|        NULLCHK(segment)
  ------------------
  |  | 1789|     52|#define NULLCHK(p) if(!p) { \
  |  |  ------------------
  |  |  |  Branch (1789:23): [True: 0, False: 52]
  |  |  ------------------
  |  | 1790|      0|         xmlURIErrMemory("escaping URI value\n"); \
  |  | 1791|      0|         xmlFreeURI(uri); \
  |  | 1792|      0|         xmlFree(ret); \
  |  | 1793|      0|         return NULL; } \
  ------------------
 1798|     52|        ret = xmlStrcat(ret, segment);
 1799|     52|        ret = xmlStrcat(ret, BAD_CAST ":");
  ------------------
  |  |   35|     52|#define BAD_CAST (xmlChar *)
  ------------------
 1800|     52|        xmlFree(segment);
 1801|     52|    }
 1802|       |
 1803|    166|    if (uri->authority) {
  ------------------
  |  Branch (1803:9): [True: 0, False: 166]
  ------------------
 1804|      0|        segment =
 1805|      0|            xmlURIEscapeStr(BAD_CAST uri->authority, BAD_CAST "/?;:@");
  ------------------
  |  |   35|      0|#define BAD_CAST (xmlChar *)
  ------------------
                          xmlURIEscapeStr(BAD_CAST uri->authority, BAD_CAST "/?;:@");
  ------------------
  |  |   35|      0|#define BAD_CAST (xmlChar *)
  ------------------
 1806|      0|        NULLCHK(segment)
  ------------------
  |  | 1789|      0|#define NULLCHK(p) if(!p) { \
  |  |  ------------------
  |  |  |  Branch (1789:23): [True: 0, False: 0]
  |  |  ------------------
  |  | 1790|      0|         xmlURIErrMemory("escaping URI value\n"); \
  |  | 1791|      0|         xmlFreeURI(uri); \
  |  | 1792|      0|         xmlFree(ret); \
  |  | 1793|      0|         return NULL; } \
  ------------------
 1807|      0|        ret = xmlStrcat(ret, BAD_CAST "//");
  ------------------
  |  |   35|      0|#define BAD_CAST (xmlChar *)
  ------------------
 1808|      0|        ret = xmlStrcat(ret, segment);
 1809|      0|        xmlFree(segment);
 1810|      0|    }
 1811|       |
 1812|    166|    if (uri->user) {
  ------------------
  |  Branch (1812:9): [True: 11, False: 155]
  ------------------
 1813|     11|        segment = xmlURIEscapeStr(BAD_CAST uri->user, BAD_CAST ";:&=+$,");
  ------------------
  |  |   35|     11|#define BAD_CAST (xmlChar *)
  ------------------
                      segment = xmlURIEscapeStr(BAD_CAST uri->user, BAD_CAST ";:&=+$,");
  ------------------
  |  |   35|     11|#define BAD_CAST (xmlChar *)
  ------------------
 1814|     11|        NULLCHK(segment)
  ------------------
  |  | 1789|     11|#define NULLCHK(p) if(!p) { \
  |  |  ------------------
  |  |  |  Branch (1789:23): [True: 1, False: 10]
  |  |  ------------------
  |  | 1790|      1|         xmlURIErrMemory("escaping URI value\n"); \
  |  | 1791|      1|         xmlFreeURI(uri); \
  |  | 1792|      1|         xmlFree(ret); \
  |  | 1793|      1|         return NULL; } \
  ------------------
 1815|     10|        ret = xmlStrcat(ret,BAD_CAST "//");
  ------------------
  |  |   35|     10|#define BAD_CAST (xmlChar *)
  ------------------
 1816|     10|        ret = xmlStrcat(ret, segment);
 1817|     10|        ret = xmlStrcat(ret, BAD_CAST "@");
  ------------------
  |  |   35|     10|#define BAD_CAST (xmlChar *)
  ------------------
 1818|     10|        xmlFree(segment);
 1819|     10|    }
 1820|       |
 1821|    165|    if (uri->server) {
  ------------------
  |  Branch (1821:9): [True: 16, False: 149]
  ------------------
 1822|     16|        segment = xmlURIEscapeStr(BAD_CAST uri->server, BAD_CAST "/?;:@");
  ------------------
  |  |   35|     16|#define BAD_CAST (xmlChar *)
  ------------------
                      segment = xmlURIEscapeStr(BAD_CAST uri->server, BAD_CAST "/?;:@");
  ------------------
  |  |   35|     16|#define BAD_CAST (xmlChar *)
  ------------------
 1823|     16|        NULLCHK(segment)
  ------------------
  |  | 1789|     16|#define NULLCHK(p) if(!p) { \
  |  |  ------------------
  |  |  |  Branch (1789:23): [True: 0, False: 16]
  |  |  ------------------
  |  | 1790|      0|         xmlURIErrMemory("escaping URI value\n"); \
  |  | 1791|      0|         xmlFreeURI(uri); \
  |  | 1792|      0|         xmlFree(ret); \
  |  | 1793|      0|         return NULL; } \
  ------------------
 1824|     16|        if (uri->user == NULL)
  ------------------
  |  Branch (1824:13): [True: 6, False: 10]
  ------------------
 1825|      6|            ret = xmlStrcat(ret, BAD_CAST "//");
  ------------------
  |  |   35|      6|#define BAD_CAST (xmlChar *)
  ------------------
 1826|     16|        ret = xmlStrcat(ret, segment);
 1827|     16|        xmlFree(segment);
 1828|     16|    }
 1829|       |
 1830|    165|    if (uri->port > 0) {
  ------------------
  |  Branch (1830:9): [True: 6, False: 159]
  ------------------
 1831|      6|        xmlChar port[11];
 1832|       |
 1833|      6|        snprintf((char *) port, 11, "%d", uri->port);
 1834|      6|        ret = xmlStrcat(ret, BAD_CAST ":");
  ------------------
  |  |   35|      6|#define BAD_CAST (xmlChar *)
  ------------------
 1835|      6|        ret = xmlStrcat(ret, port);
 1836|      6|    }
 1837|       |
 1838|    165|    if (uri->path) {
  ------------------
  |  Branch (1838:9): [True: 141, False: 24]
  ------------------
 1839|    141|        segment =
 1840|    141|            xmlURIEscapeStr(BAD_CAST uri->path, BAD_CAST ":@&=+$,/?;");
  ------------------
  |  |   35|    141|#define BAD_CAST (xmlChar *)
  ------------------
                          xmlURIEscapeStr(BAD_CAST uri->path, BAD_CAST ":@&=+$,/?;");
  ------------------
  |  |   35|    141|#define BAD_CAST (xmlChar *)
  ------------------
 1841|    141|        NULLCHK(segment)
  ------------------
  |  | 1789|    141|#define NULLCHK(p) if(!p) { \
  |  |  ------------------
  |  |  |  Branch (1789:23): [True: 5, False: 136]
  |  |  ------------------
  |  | 1790|      5|         xmlURIErrMemory("escaping URI value\n"); \
  |  | 1791|      5|         xmlFreeURI(uri); \
  |  | 1792|      5|         xmlFree(ret); \
  |  | 1793|      5|         return NULL; } \
  ------------------
 1842|    136|        ret = xmlStrcat(ret, segment);
 1843|    136|        xmlFree(segment);
 1844|    136|    }
 1845|       |
 1846|    160|    if (uri->query_raw) {
  ------------------
  |  Branch (1846:9): [True: 62, False: 98]
  ------------------
 1847|     62|        ret = xmlStrcat(ret, BAD_CAST "?");
  ------------------
  |  |   35|     62|#define BAD_CAST (xmlChar *)
  ------------------
 1848|     62|        ret = xmlStrcat(ret, BAD_CAST uri->query_raw);
  ------------------
  |  |   35|     62|#define BAD_CAST (xmlChar *)
  ------------------
 1849|     62|    }
 1850|     98|    else if (uri->query) {
  ------------------
  |  Branch (1850:14): [True: 0, False: 98]
  ------------------
 1851|      0|        segment =
 1852|      0|            xmlURIEscapeStr(BAD_CAST uri->query, BAD_CAST ";/?:@&=+,$");
  ------------------
  |  |   35|      0|#define BAD_CAST (xmlChar *)
  ------------------
                          xmlURIEscapeStr(BAD_CAST uri->query, BAD_CAST ";/?:@&=+,$");
  ------------------
  |  |   35|      0|#define BAD_CAST (xmlChar *)
  ------------------
 1853|      0|        NULLCHK(segment)
  ------------------
  |  | 1789|      0|#define NULLCHK(p) if(!p) { \
  |  |  ------------------
  |  |  |  Branch (1789:23): [True: 0, False: 0]
  |  |  ------------------
  |  | 1790|      0|         xmlURIErrMemory("escaping URI value\n"); \
  |  | 1791|      0|         xmlFreeURI(uri); \
  |  | 1792|      0|         xmlFree(ret); \
  |  | 1793|      0|         return NULL; } \
  ------------------
 1854|      0|        ret = xmlStrcat(ret, BAD_CAST "?");
  ------------------
  |  |   35|      0|#define BAD_CAST (xmlChar *)
  ------------------
 1855|      0|        ret = xmlStrcat(ret, segment);
 1856|      0|        xmlFree(segment);
 1857|      0|    }
 1858|       |
 1859|    160|    if (uri->opaque) {
  ------------------
  |  Branch (1859:9): [True: 0, False: 160]
  ------------------
 1860|      0|        segment = xmlURIEscapeStr(BAD_CAST uri->opaque, BAD_CAST "");
  ------------------
  |  |   35|      0|#define BAD_CAST (xmlChar *)
  ------------------
                      segment = xmlURIEscapeStr(BAD_CAST uri->opaque, BAD_CAST "");
  ------------------
  |  |   35|      0|#define BAD_CAST (xmlChar *)
  ------------------
 1861|      0|        NULLCHK(segment)
  ------------------
  |  | 1789|      0|#define NULLCHK(p) if(!p) { \
  |  |  ------------------
  |  |  |  Branch (1789:23): [True: 0, False: 0]
  |  |  ------------------
  |  | 1790|      0|         xmlURIErrMemory("escaping URI value\n"); \
  |  | 1791|      0|         xmlFreeURI(uri); \
  |  | 1792|      0|         xmlFree(ret); \
  |  | 1793|      0|         return NULL; } \
  ------------------
 1862|      0|        ret = xmlStrcat(ret, segment);
 1863|      0|        xmlFree(segment);
 1864|      0|    }
 1865|       |
 1866|    160|    if (uri->fragment) {
  ------------------
  |  Branch (1866:9): [True: 70, False: 90]
  ------------------
 1867|     70|        segment = xmlURIEscapeStr(BAD_CAST uri->fragment, BAD_CAST "#");
  ------------------
  |  |   35|     70|#define BAD_CAST (xmlChar *)
  ------------------
                      segment = xmlURIEscapeStr(BAD_CAST uri->fragment, BAD_CAST "#");
  ------------------
  |  |   35|     70|#define BAD_CAST (xmlChar *)
  ------------------
 1868|     70|        NULLCHK(segment)
  ------------------
  |  | 1789|     70|#define NULLCHK(p) if(!p) { \
  |  |  ------------------
  |  |  |  Branch (1789:23): [True: 4, False: 66]
  |  |  ------------------
  |  | 1790|      4|         xmlURIErrMemory("escaping URI value\n"); \
  |  | 1791|      4|         xmlFreeURI(uri); \
  |  | 1792|      4|         xmlFree(ret); \
  |  | 1793|      4|         return NULL; } \
  ------------------
 1869|     66|        ret = xmlStrcat(ret, BAD_CAST "#");
  ------------------
  |  |   35|     66|#define BAD_CAST (xmlChar *)
  ------------------
 1870|     66|        ret = xmlStrcat(ret, segment);
 1871|     66|        xmlFree(segment);
 1872|     66|    }
 1873|       |
 1874|    156|    xmlFreeURI(uri);
 1875|    156|#undef NULLCHK
 1876|       |
 1877|    156|    return (ret);
 1878|    160|}
xmlBuildURI:
 1902|    426|xmlBuildURI(const xmlChar *URI, const xmlChar *base) {
 1903|    426|    xmlChar *val = NULL;
 1904|    426|    int ret, len, indx, cur, out;
 1905|    426|    xmlURIPtr ref = NULL;
 1906|    426|    xmlURIPtr bas = NULL;
 1907|    426|    xmlURIPtr res = NULL;
 1908|       |
 1909|       |    /*
 1910|       |     * 1) The URI reference is parsed into the potential four components and
 1911|       |     *    fragment identifier, as described in Section 4.3.
 1912|       |     *
 1913|       |     *    NOTE that a completely empty URI is treated by modern browsers
 1914|       |     *    as a reference to "." rather than as a synonym for the current
 1915|       |     *    URI.  Should we do that here?
 1916|       |     */
 1917|    426|    if (URI == NULL)
  ------------------
  |  Branch (1917:9): [True: 426, False: 0]
  ------------------
 1918|    426|	ret = -1;
 1919|      0|    else {
 1920|      0|	if (*URI) {
  ------------------
  |  Branch (1920:6): [True: 0, False: 0]
  ------------------
 1921|      0|	    ref = xmlCreateURI();
 1922|      0|	    if (ref == NULL)
  ------------------
  |  Branch (1922:10): [True: 0, False: 0]
  ------------------
 1923|      0|		goto done;
 1924|      0|	    ret = xmlParseURIReference(ref, (const char *) URI);
 1925|      0|	}
 1926|      0|	else
 1927|      0|	    ret = 0;
 1928|      0|    }
 1929|    426|    if (ret != 0)
  ------------------
  |  Branch (1929:9): [True: 426, False: 0]
  ------------------
 1930|    426|	goto done;
 1931|      0|    if ((ref != NULL) && (ref->scheme != NULL)) {
  ------------------
  |  Branch (1931:9): [True: 0, False: 0]
  |  Branch (1931:26): [True: 0, False: 0]
  ------------------
 1932|       |	/*
 1933|       |	 * The URI is absolute don't modify.
 1934|       |	 */
 1935|      0|	val = xmlStrdup(URI);
 1936|      0|	goto done;
 1937|      0|    }
 1938|      0|    if (base == NULL)
  ------------------
  |  Branch (1938:9): [True: 0, False: 0]
  ------------------
 1939|      0|	ret = -1;
 1940|      0|    else {
 1941|      0|	bas = xmlCreateURI();
 1942|      0|	if (bas == NULL)
  ------------------
  |  Branch (1942:6): [True: 0, False: 0]
  ------------------
 1943|      0|	    goto done;
 1944|      0|	ret = xmlParseURIReference(bas, (const char *) base);
 1945|      0|    }
 1946|      0|    if (ret != 0) {
  ------------------
  |  Branch (1946:9): [True: 0, False: 0]
  ------------------
 1947|      0|	if (ref)
  ------------------
  |  Branch (1947:6): [True: 0, False: 0]
  ------------------
 1948|      0|	    val = xmlSaveUri(ref);
 1949|      0|	goto done;
 1950|      0|    }
 1951|      0|    if (ref == NULL) {
  ------------------
  |  Branch (1951:9): [True: 0, False: 0]
  ------------------
 1952|       |	/*
 1953|       |	 * the base fragment must be ignored
 1954|       |	 */
 1955|      0|	if (bas->fragment != NULL) {
  ------------------
  |  Branch (1955:6): [True: 0, False: 0]
  ------------------
 1956|      0|	    xmlFree(bas->fragment);
 1957|      0|	    bas->fragment = NULL;
 1958|      0|	}
 1959|      0|	val = xmlSaveUri(bas);
 1960|      0|	goto done;
 1961|      0|    }
 1962|       |
 1963|       |    /*
 1964|       |     * 2) If the path component is empty and the scheme, authority, and
 1965|       |     *    query components are undefined, then it is a reference to the
 1966|       |     *    current document and we are done.  Otherwise, the reference URI's
 1967|       |     *    query and fragment components are defined as found (or not found)
 1968|       |     *    within the URI reference and not inherited from the base URI.
 1969|       |     *
 1970|       |     *    NOTE that in modern browsers, the parsing differs from the above
 1971|       |     *    in the following aspect:  the query component is allowed to be
 1972|       |     *    defined while still treating this as a reference to the current
 1973|       |     *    document.
 1974|       |     */
 1975|      0|    res = xmlCreateURI();
 1976|      0|    if (res == NULL)
  ------------------
  |  Branch (1976:9): [True: 0, False: 0]
  ------------------
 1977|      0|	goto done;
 1978|      0|    if ((ref->scheme == NULL) && (ref->path == NULL) &&
  ------------------
  |  Branch (1978:9): [True: 0, False: 0]
  |  Branch (1978:34): [True: 0, False: 0]
  ------------------
 1979|      0|	((ref->authority == NULL) && (ref->server == NULL) &&
  ------------------
  |  Branch (1979:3): [True: 0, False: 0]
  |  Branch (1979:31): [True: 0, False: 0]
  ------------------
 1980|      0|         (ref->port == PORT_EMPTY))) {
  ------------------
  |  |   37|      0|#define PORT_EMPTY           0
  ------------------
  |  Branch (1980:10): [True: 0, False: 0]
  ------------------
 1981|      0|	if (bas->scheme != NULL)
  ------------------
  |  Branch (1981:6): [True: 0, False: 0]
  ------------------
 1982|      0|	    res->scheme = xmlMemStrdup(bas->scheme);
 1983|      0|	if (bas->authority != NULL)
  ------------------
  |  Branch (1983:6): [True: 0, False: 0]
  ------------------
 1984|      0|	    res->authority = xmlMemStrdup(bas->authority);
 1985|      0|	else {
 1986|      0|	    if (bas->server != NULL)
  ------------------
  |  Branch (1986:10): [True: 0, False: 0]
  ------------------
 1987|      0|		res->server = xmlMemStrdup(bas->server);
 1988|      0|	    if (bas->user != NULL)
  ------------------
  |  Branch (1988:10): [True: 0, False: 0]
  ------------------
 1989|      0|		res->user = xmlMemStrdup(bas->user);
 1990|      0|	    res->port = bas->port;
 1991|      0|	}
 1992|      0|	if (bas->path != NULL)
  ------------------
  |  Branch (1992:6): [True: 0, False: 0]
  ------------------
 1993|      0|	    res->path = xmlMemStrdup(bas->path);
 1994|      0|	if (ref->query_raw != NULL)
  ------------------
  |  Branch (1994:6): [True: 0, False: 0]
  ------------------
 1995|      0|	    res->query_raw = xmlMemStrdup (ref->query_raw);
 1996|      0|	else if (ref->query != NULL)
  ------------------
  |  Branch (1996:11): [True: 0, False: 0]
  ------------------
 1997|      0|	    res->query = xmlMemStrdup(ref->query);
 1998|      0|	else if (bas->query_raw != NULL)
  ------------------
  |  Branch (1998:11): [True: 0, False: 0]
  ------------------
 1999|      0|	    res->query_raw = xmlMemStrdup(bas->query_raw);
 2000|      0|	else if (bas->query != NULL)
  ------------------
  |  Branch (2000:11): [True: 0, False: 0]
  ------------------
 2001|      0|	    res->query = xmlMemStrdup(bas->query);
 2002|      0|	if (ref->fragment != NULL)
  ------------------
  |  Branch (2002:6): [True: 0, False: 0]
  ------------------
 2003|      0|	    res->fragment = xmlMemStrdup(ref->fragment);
 2004|      0|	goto step_7;
 2005|      0|    }
 2006|       |
 2007|       |    /*
 2008|       |     * 3) If the scheme component is defined, indicating that the reference
 2009|       |     *    starts with a scheme name, then the reference is interpreted as an
 2010|       |     *    absolute URI and we are done.  Otherwise, the reference URI's
 2011|       |     *    scheme is inherited from the base URI's scheme component.
 2012|       |     */
 2013|      0|    if (ref->scheme != NULL) {
  ------------------
  |  Branch (2013:9): [True: 0, False: 0]
  ------------------
 2014|      0|	val = xmlSaveUri(ref);
 2015|      0|	goto done;
 2016|      0|    }
 2017|      0|    if (bas->scheme != NULL)
  ------------------
  |  Branch (2017:9): [True: 0, False: 0]
  ------------------
 2018|      0|	res->scheme = xmlMemStrdup(bas->scheme);
 2019|       |
 2020|      0|    if (ref->query_raw != NULL)
  ------------------
  |  Branch (2020:9): [True: 0, False: 0]
  ------------------
 2021|      0|	res->query_raw = xmlMemStrdup(ref->query_raw);
 2022|      0|    else if (ref->query != NULL)
  ------------------
  |  Branch (2022:14): [True: 0, False: 0]
  ------------------
 2023|      0|	res->query = xmlMemStrdup(ref->query);
 2024|      0|    if (ref->fragment != NULL)
  ------------------
  |  Branch (2024:9): [True: 0, False: 0]
  ------------------
 2025|      0|	res->fragment = xmlMemStrdup(ref->fragment);
 2026|       |
 2027|       |    /*
 2028|       |     * 4) If the authority component is defined, then the reference is a
 2029|       |     *    network-path and we skip to step 7.  Otherwise, the reference
 2030|       |     *    URI's authority is inherited from the base URI's authority
 2031|       |     *    component, which will also be undefined if the URI scheme does not
 2032|       |     *    use an authority component.
 2033|       |     */
 2034|      0|    if ((ref->authority != NULL) || (ref->server != NULL) ||
  ------------------
  |  Branch (2034:9): [True: 0, False: 0]
  |  Branch (2034:37): [True: 0, False: 0]
  ------------------
 2035|      0|         (ref->port != PORT_EMPTY)) {
  ------------------
  |  |   37|      0|#define PORT_EMPTY           0
  ------------------
  |  Branch (2035:10): [True: 0, False: 0]
  ------------------
 2036|      0|	if (ref->authority != NULL)
  ------------------
  |  Branch (2036:6): [True: 0, False: 0]
  ------------------
 2037|      0|	    res->authority = xmlMemStrdup(ref->authority);
 2038|      0|	else {
 2039|      0|            if (ref->server != NULL)
  ------------------
  |  Branch (2039:17): [True: 0, False: 0]
  ------------------
 2040|      0|                res->server = xmlMemStrdup(ref->server);
 2041|      0|	    if (ref->user != NULL)
  ------------------
  |  Branch (2041:10): [True: 0, False: 0]
  ------------------
 2042|      0|		res->user = xmlMemStrdup(ref->user);
 2043|      0|            res->port = ref->port;
 2044|      0|	}
 2045|      0|	if (ref->path != NULL)
  ------------------
  |  Branch (2045:6): [True: 0, False: 0]
  ------------------
 2046|      0|	    res->path = xmlMemStrdup(ref->path);
 2047|      0|	goto step_7;
 2048|      0|    }
 2049|      0|    if (bas->authority != NULL)
  ------------------
  |  Branch (2049:9): [True: 0, False: 0]
  ------------------
 2050|      0|	res->authority = xmlMemStrdup(bas->authority);
 2051|      0|    else if ((bas->server != NULL) || (bas->port != PORT_EMPTY)) {
  ------------------
  |  |   37|      0|#define PORT_EMPTY           0
  ------------------
  |  Branch (2051:14): [True: 0, False: 0]
  |  Branch (2051:39): [True: 0, False: 0]
  ------------------
 2052|      0|	if (bas->server != NULL)
  ------------------
  |  Branch (2052:6): [True: 0, False: 0]
  ------------------
 2053|      0|	    res->server = xmlMemStrdup(bas->server);
 2054|      0|	if (bas->user != NULL)
  ------------------
  |  Branch (2054:6): [True: 0, False: 0]
  ------------------
 2055|      0|	    res->user = xmlMemStrdup(bas->user);
 2056|      0|	res->port = bas->port;
 2057|      0|    }
 2058|       |
 2059|       |    /*
 2060|       |     * 5) If the path component begins with a slash character ("/"), then
 2061|       |     *    the reference is an absolute-path and we skip to step 7.
 2062|       |     */
 2063|      0|    if ((ref->path != NULL) && (ref->path[0] == '/')) {
  ------------------
  |  Branch (2063:9): [True: 0, False: 0]
  |  Branch (2063:32): [True: 0, False: 0]
  ------------------
 2064|      0|	res->path = xmlMemStrdup(ref->path);
 2065|      0|	goto step_7;
 2066|      0|    }
 2067|       |
 2068|       |
 2069|       |    /*
 2070|       |     * 6) If this step is reached, then we are resolving a relative-path
 2071|       |     *    reference.  The relative path needs to be merged with the base
 2072|       |     *    URI's path.  Although there are many ways to do this, we will
 2073|       |     *    describe a simple method using a separate string buffer.
 2074|       |     *
 2075|       |     * Allocate a buffer large enough for the result string.
 2076|       |     */
 2077|      0|    len = 2; /* extra / and 0 */
 2078|      0|    if (ref->path != NULL)
  ------------------
  |  Branch (2078:9): [True: 0, False: 0]
  ------------------
 2079|      0|	len += strlen(ref->path);
 2080|      0|    if (bas->path != NULL)
  ------------------
  |  Branch (2080:9): [True: 0, False: 0]
  ------------------
 2081|      0|	len += strlen(bas->path);
 2082|      0|    res->path = (char *) xmlMallocAtomic(len);
 2083|      0|    if (res->path == NULL) {
  ------------------
  |  Branch (2083:9): [True: 0, False: 0]
  ------------------
 2084|      0|        xmlURIErrMemory("resolving URI against base\n");
 2085|      0|	goto done;
 2086|      0|    }
 2087|      0|    res->path[0] = 0;
 2088|       |
 2089|       |    /*
 2090|       |     * a) All but the last segment of the base URI's path component is
 2091|       |     *    copied to the buffer.  In other words, any characters after the
 2092|       |     *    last (right-most) slash character, if any, are excluded.
 2093|       |     */
 2094|      0|    cur = 0;
 2095|      0|    out = 0;
 2096|      0|    if (bas->path != NULL) {
  ------------------
  |  Branch (2096:9): [True: 0, False: 0]
  ------------------
 2097|      0|	while (bas->path[cur] != 0) {
  ------------------
  |  Branch (2097:9): [True: 0, False: 0]
  ------------------
 2098|      0|	    while ((bas->path[cur] != 0) && (bas->path[cur] != '/'))
  ------------------
  |  Branch (2098:13): [True: 0, False: 0]
  |  Branch (2098:38): [True: 0, False: 0]
  ------------------
 2099|      0|		cur++;
 2100|      0|	    if (bas->path[cur] == 0)
  ------------------
  |  Branch (2100:10): [True: 0, False: 0]
  ------------------
 2101|      0|		break;
 2102|       |
 2103|      0|	    cur++;
 2104|      0|	    while (out < cur) {
  ------------------
  |  Branch (2104:13): [True: 0, False: 0]
  ------------------
 2105|      0|		res->path[out] = bas->path[out];
 2106|      0|		out++;
 2107|      0|	    }
 2108|      0|	}
 2109|      0|    }
 2110|      0|    res->path[out] = 0;
 2111|       |
 2112|       |    /*
 2113|       |     * b) The reference's path component is appended to the buffer
 2114|       |     *    string.
 2115|       |     */
 2116|      0|    if (ref->path != NULL && ref->path[0] != 0) {
  ------------------
  |  Branch (2116:9): [True: 0, False: 0]
  |  Branch (2116:30): [True: 0, False: 0]
  ------------------
 2117|      0|	indx = 0;
 2118|       |	/*
 2119|       |	 * Ensure the path includes a '/'
 2120|       |	 */
 2121|      0|	if ((out == 0) && ((bas->server != NULL) || bas->port != PORT_EMPTY))
  ------------------
  |  |   37|      0|#define PORT_EMPTY           0
  ------------------
  |  Branch (2121:6): [True: 0, False: 0]
  |  Branch (2121:21): [True: 0, False: 0]
  |  Branch (2121:46): [True: 0, False: 0]
  ------------------
 2122|      0|	    res->path[out++] = '/';
 2123|      0|	while (ref->path[indx] != 0) {
  ------------------
  |  Branch (2123:9): [True: 0, False: 0]
  ------------------
 2124|      0|	    res->path[out++] = ref->path[indx++];
 2125|      0|	}
 2126|      0|    }
 2127|      0|    res->path[out] = 0;
 2128|       |
 2129|       |    /*
 2130|       |     * Steps c) to h) are really path normalization steps
 2131|       |     */
 2132|      0|    xmlNormalizeURIPath(res->path);
 2133|       |
 2134|      0|step_7:
 2135|       |
 2136|       |    /*
 2137|       |     * 7) The resulting URI components, including any inherited from the
 2138|       |     *    base URI, are recombined to give the absolute form of the URI
 2139|       |     *    reference.
 2140|       |     */
 2141|      0|    val = xmlSaveUri(res);
 2142|       |
 2143|    426|done:
 2144|    426|    if (ref != NULL)
  ------------------
  |  Branch (2144:9): [True: 0, False: 426]
  ------------------
 2145|      0|	xmlFreeURI(ref);
 2146|    426|    if (bas != NULL)
  ------------------
  |  Branch (2146:9): [True: 0, False: 426]
  ------------------
 2147|      0|	xmlFreeURI(bas);
 2148|    426|    if (res != NULL)
  ------------------
  |  Branch (2148:9): [True: 0, False: 426]
  ------------------
 2149|      0|	xmlFreeURI(res);
 2150|    426|    return(val);
 2151|      0|}
xmlBuildRelativeURI:
 2187|    426|{
 2188|    426|    xmlChar *val = NULL;
 2189|    426|    int ret;
 2190|    426|    int ix;
 2191|    426|    int nbslash = 0;
 2192|    426|    int len;
 2193|    426|    xmlURIPtr ref = NULL;
 2194|    426|    xmlURIPtr bas = NULL;
 2195|    426|    xmlChar *bptr, *uptr, *vptr;
 2196|    426|    int remove_path = 0;
 2197|       |
 2198|    426|    if ((URI == NULL) || (*URI == 0))
  ------------------
  |  Branch (2198:9): [True: 426, False: 0]
  |  Branch (2198:26): [True: 0, False: 0]
  ------------------
 2199|    426|	return NULL;
 2200|       |
 2201|       |    /*
 2202|       |     * First parse URI into a standard form
 2203|       |     */
 2204|      0|    ref = xmlCreateURI ();
 2205|      0|    if (ref == NULL)
  ------------------
  |  Branch (2205:9): [True: 0, False: 0]
  ------------------
 2206|      0|	return NULL;
 2207|       |    /* If URI not already in "relative" form */
 2208|      0|    if (URI[0] != '.') {
  ------------------
  |  Branch (2208:9): [True: 0, False: 0]
  ------------------
 2209|      0|	ret = xmlParseURIReference (ref, (const char *) URI);
 2210|      0|	if (ret != 0)
  ------------------
  |  Branch (2210:6): [True: 0, False: 0]
  ------------------
 2211|      0|	    goto done;		/* Error in URI, return NULL */
 2212|      0|    } else
 2213|      0|	ref->path = (char *)xmlStrdup(URI);
 2214|       |
 2215|       |    /*
 2216|       |     * Next parse base into the same standard form
 2217|       |     */
 2218|      0|    if ((base == NULL) || (*base == 0)) {
  ------------------
  |  Branch (2218:9): [True: 0, False: 0]
  |  Branch (2218:27): [True: 0, False: 0]
  ------------------
 2219|      0|	val = xmlStrdup (URI);
 2220|      0|	goto done;
 2221|      0|    }
 2222|      0|    bas = xmlCreateURI ();
 2223|      0|    if (bas == NULL)
  ------------------
  |  Branch (2223:9): [True: 0, False: 0]
  ------------------
 2224|      0|	goto done;
 2225|      0|    if (base[0] != '.') {
  ------------------
  |  Branch (2225:9): [True: 0, False: 0]
  ------------------
 2226|      0|	ret = xmlParseURIReference (bas, (const char *) base);
 2227|      0|	if (ret != 0)
  ------------------
  |  Branch (2227:6): [True: 0, False: 0]
  ------------------
 2228|      0|	    goto done;		/* Error in base, return NULL */
 2229|      0|    } else
 2230|      0|	bas->path = (char *)xmlStrdup(base);
 2231|       |
 2232|       |    /*
 2233|       |     * If the scheme / server on the URI differs from the base,
 2234|       |     * just return the URI
 2235|       |     */
 2236|      0|    if ((ref->scheme != NULL) &&
  ------------------
  |  Branch (2236:9): [True: 0, False: 0]
  ------------------
 2237|      0|	((bas->scheme == NULL) ||
  ------------------
  |  Branch (2237:3): [True: 0, False: 0]
  ------------------
 2238|      0|	 (xmlStrcmp ((xmlChar *)bas->scheme, (xmlChar *)ref->scheme)) ||
  ------------------
  |  Branch (2238:3): [True: 0, False: 0]
  ------------------
 2239|      0|	 (xmlStrcmp ((xmlChar *)bas->server, (xmlChar *)ref->server)) ||
  ------------------
  |  Branch (2239:3): [True: 0, False: 0]
  ------------------
 2240|      0|         (bas->port != ref->port))) {
  ------------------
  |  Branch (2240:10): [True: 0, False: 0]
  ------------------
 2241|      0|	val = xmlStrdup (URI);
 2242|      0|	goto done;
 2243|      0|    }
 2244|      0|    if (xmlStrEqual((xmlChar *)bas->path, (xmlChar *)ref->path)) {
  ------------------
  |  Branch (2244:9): [True: 0, False: 0]
  ------------------
 2245|      0|	val = xmlStrdup(BAD_CAST "");
  ------------------
  |  |   35|      0|#define BAD_CAST (xmlChar *)
  ------------------
 2246|      0|	goto done;
 2247|      0|    }
 2248|      0|    if (bas->path == NULL) {
  ------------------
  |  Branch (2248:9): [True: 0, False: 0]
  ------------------
 2249|      0|	val = xmlStrdup((xmlChar *)ref->path);
 2250|      0|	goto done;
 2251|      0|    }
 2252|      0|    if (ref->path == NULL) {
  ------------------
  |  Branch (2252:9): [True: 0, False: 0]
  ------------------
 2253|      0|        ref->path = (char *) "/";
 2254|      0|	remove_path = 1;
 2255|      0|    }
 2256|       |
 2257|       |    /*
 2258|       |     * At this point (at last!) we can compare the two paths
 2259|       |     *
 2260|       |     * First we take care of the special case where either of the
 2261|       |     * two path components may be missing (bug 316224)
 2262|       |     */
 2263|      0|    bptr = (xmlChar *)bas->path;
 2264|      0|    {
 2265|      0|        xmlChar *rptr = (xmlChar *) ref->path;
 2266|      0|        int pos = 0;
 2267|       |
 2268|       |        /*
 2269|       |         * Next we compare the two strings and find where they first differ
 2270|       |         */
 2271|      0|	if ((*rptr == '.') && (rptr[1] == '/'))
  ------------------
  |  Branch (2271:6): [True: 0, False: 0]
  |  Branch (2271:24): [True: 0, False: 0]
  ------------------
 2272|      0|            rptr += 2;
 2273|      0|	if ((*bptr == '.') && (bptr[1] == '/'))
  ------------------
  |  Branch (2273:6): [True: 0, False: 0]
  |  Branch (2273:24): [True: 0, False: 0]
  ------------------
 2274|      0|            bptr += 2;
 2275|      0|	else if ((*bptr == '/') && (*rptr != '/'))
  ------------------
  |  Branch (2275:11): [True: 0, False: 0]
  |  Branch (2275:29): [True: 0, False: 0]
  ------------------
 2276|      0|	    bptr++;
 2277|      0|	while ((bptr[pos] == rptr[pos]) && (bptr[pos] != 0))
  ------------------
  |  Branch (2277:9): [True: 0, False: 0]
  |  Branch (2277:37): [True: 0, False: 0]
  ------------------
 2278|      0|	    pos++;
 2279|       |
 2280|      0|	if (bptr[pos] == rptr[pos]) {
  ------------------
  |  Branch (2280:6): [True: 0, False: 0]
  ------------------
 2281|      0|	    val = xmlStrdup(BAD_CAST "");
  ------------------
  |  |   35|      0|#define BAD_CAST (xmlChar *)
  ------------------
 2282|      0|	    goto done;		/* (I can't imagine why anyone would do this) */
 2283|      0|	}
 2284|       |
 2285|       |	/*
 2286|       |	 * In URI, "back up" to the last '/' encountered.  This will be the
 2287|       |	 * beginning of the "unique" suffix of URI
 2288|       |	 */
 2289|      0|	ix = pos;
 2290|      0|	for (; ix > 0; ix--) {
  ------------------
  |  Branch (2290:9): [True: 0, False: 0]
  ------------------
 2291|      0|	    if (rptr[ix - 1] == '/')
  ------------------
  |  Branch (2291:10): [True: 0, False: 0]
  ------------------
 2292|      0|		break;
 2293|      0|	}
 2294|      0|	uptr = (xmlChar *)&rptr[ix];
 2295|       |
 2296|       |	/*
 2297|       |	 * In base, count the number of '/' from the differing point
 2298|       |	 */
 2299|      0|	for (; bptr[ix] != 0; ix++) {
  ------------------
  |  Branch (2299:9): [True: 0, False: 0]
  ------------------
 2300|      0|	    if (bptr[ix] == '/')
  ------------------
  |  Branch (2300:10): [True: 0, False: 0]
  ------------------
 2301|      0|		nbslash++;
 2302|      0|	}
 2303|       |
 2304|       |	/*
 2305|       |	 * e.g: URI="foo/" base="foo/bar" -> "./"
 2306|       |	 */
 2307|      0|	if (nbslash == 0 && !uptr[0]) {
  ------------------
  |  Branch (2307:6): [True: 0, False: 0]
  |  Branch (2307:22): [True: 0, False: 0]
  ------------------
 2308|      0|	    val = xmlStrdup(BAD_CAST "./");
  ------------------
  |  |   35|      0|#define BAD_CAST (xmlChar *)
  ------------------
 2309|      0|	    goto done;
 2310|      0|	}
 2311|       |
 2312|      0|	len = xmlStrlen (uptr) + 1;
 2313|      0|    }
 2314|       |
 2315|      0|    if (nbslash == 0) {
  ------------------
  |  Branch (2315:9): [True: 0, False: 0]
  ------------------
 2316|      0|	if (uptr != NULL)
  ------------------
  |  Branch (2316:6): [True: 0, False: 0]
  ------------------
 2317|       |	    /* exception characters from xmlSaveUri */
 2318|      0|	    val = xmlURIEscapeStr(uptr, BAD_CAST "/;&=+$,");
  ------------------
  |  |   35|      0|#define BAD_CAST (xmlChar *)
  ------------------
 2319|      0|	goto done;
 2320|      0|    }
 2321|       |
 2322|       |    /*
 2323|       |     * Allocate just enough space for the returned string -
 2324|       |     * length of the remainder of the URI, plus enough space
 2325|       |     * for the "../" groups, plus one for the terminator
 2326|       |     */
 2327|      0|    val = (xmlChar *) xmlMalloc (len + 3 * nbslash);
 2328|      0|    if (val == NULL) {
  ------------------
  |  Branch (2328:9): [True: 0, False: 0]
  ------------------
 2329|      0|        xmlURIErrMemory("building relative URI\n");
 2330|      0|	goto done;
 2331|      0|    }
 2332|      0|    vptr = val;
 2333|       |    /*
 2334|       |     * Put in as many "../" as needed
 2335|       |     */
 2336|      0|    for (; nbslash>0; nbslash--) {
  ------------------
  |  Branch (2336:12): [True: 0, False: 0]
  ------------------
 2337|      0|	*vptr++ = '.';
 2338|      0|	*vptr++ = '.';
 2339|      0|	*vptr++ = '/';
 2340|      0|    }
 2341|       |    /*
 2342|       |     * Finish up with the end of the URI
 2343|       |     */
 2344|      0|    if (uptr != NULL) {
  ------------------
  |  Branch (2344:9): [True: 0, False: 0]
  ------------------
 2345|      0|        if ((vptr > val) && (len > 0) &&
  ------------------
  |  Branch (2345:13): [True: 0, False: 0]
  |  Branch (2345:29): [True: 0, False: 0]
  ------------------
 2346|      0|	    (uptr[0] == '/') && (vptr[-1] == '/')) {
  ------------------
  |  Branch (2346:6): [True: 0, False: 0]
  |  Branch (2346:26): [True: 0, False: 0]
  ------------------
 2347|      0|	    memcpy (vptr, uptr + 1, len - 1);
 2348|      0|	    vptr[len - 2] = 0;
 2349|      0|	} else {
 2350|      0|	    memcpy (vptr, uptr, len);
 2351|      0|	    vptr[len - 1] = 0;
 2352|      0|	}
 2353|      0|    } else {
 2354|      0|	vptr[len - 1] = 0;
 2355|      0|    }
 2356|       |
 2357|       |    /* escape the freshly-built path */
 2358|      0|    vptr = val;
 2359|       |	/* exception characters from xmlSaveUri */
 2360|      0|    val = xmlURIEscapeStr(vptr, BAD_CAST "/;&=+$,");
  ------------------
  |  |   35|      0|#define BAD_CAST (xmlChar *)
  ------------------
 2361|      0|    xmlFree(vptr);
 2362|       |
 2363|      0|done:
 2364|       |    /*
 2365|       |     * Free the working variables
 2366|       |     */
 2367|      0|    if (remove_path != 0)
  ------------------
  |  Branch (2367:9): [True: 0, False: 0]
  ------------------
 2368|      0|        ref->path = NULL;
 2369|      0|    if (ref != NULL)
  ------------------
  |  Branch (2369:9): [True: 0, False: 0]
  ------------------
 2370|      0|	xmlFreeURI (ref);
 2371|      0|    if (bas != NULL)
  ------------------
  |  Branch (2371:9): [True: 0, False: 0]
  ------------------
 2372|      0|	xmlFreeURI (bas);
 2373|       |
 2374|      0|    return val;
 2375|      0|}
xmlCanonicPath:
 2395|    722|{
 2396|       |/*
 2397|       | * For Windows implementations, additional work needs to be done to
 2398|       | * replace backslashes in pathnames with "forward slashes"
 2399|       | */
 2400|       |#if defined(_WIN32)
 2401|       |    int len = 0;
 2402|       |    char *p = NULL;
 2403|       |#endif
 2404|    722|    xmlURIPtr uri;
 2405|    722|    xmlChar *ret;
 2406|    722|    const xmlChar *absuri;
 2407|       |
 2408|    722|    if (path == NULL)
  ------------------
  |  Branch (2408:9): [True: 3, False: 719]
  ------------------
 2409|      3|	return(NULL);
 2410|       |
 2411|       |#if defined(_WIN32)
 2412|       |    /*
 2413|       |     * We must not change the backslashes to slashes if the the path
 2414|       |     * starts with \\?\
 2415|       |     * Those paths can be up to 32k characters long.
 2416|       |     * Was added specifically for OpenOffice, those paths can't be converted
 2417|       |     * to URIs anyway.
 2418|       |     */
 2419|       |    if ((path[0] == '\\') && (path[1] == '\\') && (path[2] == '?') &&
 2420|       |        (path[3] == '\\') )
 2421|       |	return xmlStrdup((const xmlChar *) path);
 2422|       |#endif
 2423|       |
 2424|       |	/* sanitize filename starting with // so it can be used as URI */
 2425|    719|    if ((path[0] == '/') && (path[1] == '/') && (path[2] != '/'))
  ------------------
  |  Branch (2425:9): [True: 32, False: 687]
  |  Branch (2425:29): [True: 10, False: 22]
  |  Branch (2425:49): [True: 10, False: 0]
  ------------------
 2426|     10|        path++;
 2427|       |
 2428|    719|    if ((uri = xmlParseURI((const char *) path)) != NULL) {
  ------------------
  |  Branch (2428:9): [True: 138, False: 581]
  ------------------
 2429|    138|	xmlFreeURI(uri);
 2430|    138|	return xmlStrdup(path);
 2431|    138|    }
 2432|       |
 2433|       |    /* Check if this is an "absolute uri" */
 2434|    581|    absuri = xmlStrstr(path, BAD_CAST "://");
  ------------------
  |  |   35|    581|#define BAD_CAST (xmlChar *)
  ------------------
 2435|    581|    if (absuri != NULL) {
  ------------------
  |  Branch (2435:9): [True: 177, False: 404]
  ------------------
 2436|    177|        int l, j;
 2437|    177|	unsigned char c;
 2438|    177|	xmlChar *escURI;
 2439|       |
 2440|       |        /*
 2441|       |	 * this looks like an URI where some parts have not been
 2442|       |	 * escaped leading to a parsing problem.  Check that the first
 2443|       |	 * part matches a protocol.
 2444|       |	 */
 2445|    177|	l = absuri - path;
 2446|       |	/* Bypass if first part (part before the '://') is > 20 chars */
 2447|    177|	if ((l <= 0) || (l > 20))
  ------------------
  |  Branch (2447:6): [True: 2, False: 175]
  |  Branch (2447:18): [True: 4, False: 171]
  ------------------
 2448|      6|	    goto path_processing;
 2449|       |	/* Bypass if any non-alpha characters are present in first part */
 2450|    815|	for (j = 0;j < l;j++) {
  ------------------
  |  Branch (2450:13): [True: 683, False: 132]
  ------------------
 2451|    683|	    c = path[j];
 2452|    683|	    if (!(((c >= 'a') && (c <= 'z')) || ((c >= 'A') && (c <= 'Z'))))
  ------------------
  |  Branch (2452:13): [True: 586, False: 97]
  |  Branch (2452:27): [True: 584, False: 2]
  |  Branch (2452:43): [True: 72, False: 27]
  |  Branch (2452:57): [True: 60, False: 12]
  ------------------
 2453|     39|	        goto path_processing;
 2454|    683|	}
 2455|       |
 2456|       |	/* Escape all except the characters specified in the supplied path */
 2457|    132|        escURI = xmlURIEscapeStr(path, BAD_CAST ":/?_.#&;=");
  ------------------
  |  |   35|    132|#define BAD_CAST (xmlChar *)
  ------------------
 2458|    132|	if (escURI != NULL) {
  ------------------
  |  Branch (2458:6): [True: 113, False: 19]
  ------------------
 2459|       |	    /* Try parsing the escaped path */
 2460|    113|	    uri = xmlParseURI((const char *) escURI);
 2461|       |	    /* If successful, return the escaped string */
 2462|    113|	    if (uri != NULL) {
  ------------------
  |  Branch (2462:10): [True: 59, False: 54]
  ------------------
 2463|     59|	        xmlFreeURI(uri);
 2464|     59|		return escURI;
 2465|     59|	    }
 2466|     54|            xmlFree(escURI);
 2467|     54|	}
 2468|    132|    }
 2469|       |
 2470|    522|path_processing:
 2471|       |/* For Windows implementations, replace backslashes with 'forward slashes' */
 2472|       |#if defined(_WIN32)
 2473|       |    /*
 2474|       |     * Create a URI structure
 2475|       |     */
 2476|       |    uri = xmlCreateURI();
 2477|       |    if (uri == NULL) {		/* Guard against 'out of memory' */
 2478|       |        return(NULL);
 2479|       |    }
 2480|       |
 2481|       |    len = xmlStrlen(path);
 2482|       |    if ((len > 2) && IS_WINDOWS_PATH(path)) {
 2483|       |        /* make the scheme 'file' */
 2484|       |	uri->scheme = (char *) xmlStrdup(BAD_CAST "file");
 2485|       |	/* allocate space for leading '/' + path + string terminator */
 2486|       |	uri->path = xmlMallocAtomic(len + 2);
 2487|       |	if (uri->path == NULL) {
 2488|       |	    xmlFreeURI(uri);	/* Guard against 'out of memory' */
 2489|       |	    return(NULL);
 2490|       |	}
 2491|       |	/* Put in leading '/' plus path */
 2492|       |	uri->path[0] = '/';
 2493|       |	p = uri->path + 1;
 2494|       |	strncpy(p, (char *) path, len + 1);
 2495|       |    } else {
 2496|       |	uri->path = (char *) xmlStrdup(path);
 2497|       |	if (uri->path == NULL) {
 2498|       |	    xmlFreeURI(uri);
 2499|       |	    return(NULL);
 2500|       |	}
 2501|       |	p = uri->path;
 2502|       |    }
 2503|       |    /* Now change all occurrences of '\' to '/' */
 2504|       |    while (*p != '\0') {
 2505|       |	if (*p == '\\')
 2506|       |	    *p = '/';
 2507|       |	p++;
 2508|       |    }
 2509|       |
 2510|       |    if (uri->scheme == NULL) {
 2511|       |	ret = xmlStrdup((const xmlChar *) uri->path);
 2512|       |    } else {
 2513|       |	ret = xmlSaveUri(uri);
 2514|       |    }
 2515|       |
 2516|       |    xmlFreeURI(uri);
 2517|       |#else
 2518|    522|    ret = xmlStrdup((const xmlChar *) path);
 2519|    522|#endif
 2520|    522|    return(ret);
 2521|    581|}
xmlPathToURI:
 2536|    426|{
 2537|    426|    xmlURIPtr uri;
 2538|    426|    xmlURI temp;
 2539|    426|    xmlChar *ret, *cal;
 2540|       |
 2541|    426|    if (path == NULL)
  ------------------
  |  Branch (2541:9): [True: 3, False: 423]
  ------------------
 2542|      3|        return(NULL);
 2543|       |
 2544|    423|    if ((uri = xmlParseURI((const char *) path)) != NULL) {
  ------------------
  |  Branch (2544:9): [True: 127, False: 296]
  ------------------
 2545|    127|	xmlFreeURI(uri);
 2546|    127|	return xmlStrdup(path);
 2547|    127|    }
 2548|    296|    cal = xmlCanonicPath(path);
 2549|    296|    if (cal == NULL)
  ------------------
  |  Branch (2549:9): [True: 107, False: 189]
  ------------------
 2550|    107|        return(NULL);
 2551|       |#if defined(_WIN32)
 2552|       |    /* xmlCanonicPath can return an URI on Windows (is that the intended behaviour?)
 2553|       |       If 'cal' is a valid URI already then we are done here, as continuing would make
 2554|       |       it invalid. */
 2555|       |    if ((uri = xmlParseURI((const char *) cal)) != NULL) {
 2556|       |	xmlFreeURI(uri);
 2557|       |	return cal;
 2558|       |    }
 2559|       |    /* 'cal' can contain a relative path with backslashes. If that is processed
 2560|       |       by xmlSaveURI, they will be escaped and the external entity loader machinery
 2561|       |       will fail. So convert them to slashes. Misuse 'ret' for walking. */
 2562|       |    ret = cal;
 2563|       |    while (*ret != '\0') {
 2564|       |	if (*ret == '\\')
 2565|       |	    *ret = '/';
 2566|       |	ret++;
 2567|       |    }
 2568|       |#endif
 2569|    189|    memset(&temp, 0, sizeof(temp));
 2570|    189|    temp.path = (char *) cal;
 2571|    189|    ret = xmlSaveUri(&temp);
 2572|    189|    xmlFree(cal);
 2573|    189|    return(ret);
 2574|    296|}
uri.c:xmlParse3986URIReference:
  913|  2.15k|xmlParse3986URIReference(xmlURIPtr uri, const char *str) {
  914|  2.15k|    int ret;
  915|       |
  916|  2.15k|    if (str == NULL)
  ------------------
  |  Branch (916:9): [True: 0, False: 2.15k]
  ------------------
  917|      0|	return(-1);
  918|  2.15k|    xmlCleanURI(uri);
  919|       |
  920|       |    /*
  921|       |     * Try first to parse absolute refs, then fallback to relative if
  922|       |     * it fails.
  923|       |     */
  924|  2.15k|    ret = xmlParse3986URI(uri, str);
  925|  2.15k|    if (ret != 0) {
  ------------------
  |  Branch (925:9): [True: 1.81k, False: 334]
  ------------------
  926|  1.81k|	xmlCleanURI(uri);
  927|  1.81k|        ret = xmlParse3986RelativeRef(uri, str);
  928|  1.81k|	if (ret != 0) {
  ------------------
  |  Branch (928:6): [True: 1.28k, False: 532]
  ------------------
  929|  1.28k|	    xmlCleanURI(uri);
  930|  1.28k|	    return(ret);
  931|  1.28k|	}
  932|  1.81k|    }
  933|    866|    return(0);
  934|  2.15k|}
uri.c:xmlCleanURI:
 1366|  6.90k|xmlCleanURI(xmlURIPtr uri) {
 1367|  6.90k|    if (uri == NULL) return;
  ------------------
  |  Branch (1367:9): [True: 0, False: 6.90k]
  ------------------
 1368|       |
 1369|  6.90k|    if (uri->scheme != NULL) xmlFree(uri->scheme);
  ------------------
  |  Branch (1369:9): [True: 928, False: 5.98k]
  ------------------
 1370|  6.90k|    uri->scheme = NULL;
 1371|  6.90k|    if (uri->server != NULL) xmlFree(uri->server);
  ------------------
  |  Branch (1371:9): [True: 369, False: 6.54k]
  ------------------
 1372|  6.90k|    uri->server = NULL;
 1373|  6.90k|    if (uri->user != NULL) xmlFree(uri->user);
  ------------------
  |  Branch (1373:9): [True: 104, False: 6.80k]
  ------------------
 1374|  6.90k|    uri->user = NULL;
 1375|  6.90k|    if (uri->path != NULL) xmlFree(uri->path);
  ------------------
  |  Branch (1375:9): [True: 1.33k, False: 5.57k]
  ------------------
 1376|  6.90k|    uri->path = NULL;
 1377|  6.90k|    if (uri->fragment != NULL) xmlFree(uri->fragment);
  ------------------
  |  Branch (1377:9): [True: 122, False: 6.78k]
  ------------------
 1378|  6.90k|    uri->fragment = NULL;
 1379|  6.90k|    if (uri->opaque != NULL) xmlFree(uri->opaque);
  ------------------
  |  Branch (1379:9): [True: 0, False: 6.90k]
  ------------------
 1380|  6.90k|    uri->opaque = NULL;
 1381|  6.90k|    if (uri->authority != NULL) xmlFree(uri->authority);
  ------------------
  |  Branch (1381:9): [True: 0, False: 6.90k]
  ------------------
 1382|  6.90k|    uri->authority = NULL;
 1383|  6.90k|    if (uri->query != NULL) xmlFree(uri->query);
  ------------------
  |  Branch (1383:9): [True: 149, False: 6.76k]
  ------------------
 1384|  6.90k|    uri->query = NULL;
 1385|  6.90k|    if (uri->query_raw != NULL) xmlFree(uri->query_raw);
  ------------------
  |  Branch (1385:9): [True: 147, False: 6.76k]
  ------------------
 1386|  6.90k|    uri->query_raw = NULL;
 1387|  6.90k|}
uri.c:xmlParse3986URI:
  872|  2.15k|xmlParse3986URI(xmlURIPtr uri, const char *str) {
  873|  2.15k|    int ret;
  874|       |
  875|  2.15k|    ret = xmlParse3986Scheme(uri, &str);
  876|  2.15k|    if (ret != 0) return(ret);
  ------------------
  |  Branch (876:9): [True: 882, False: 1.26k]
  ------------------
  877|  1.26k|    if (*str != ':') {
  ------------------
  |  Branch (877:9): [True: 381, False: 887]
  ------------------
  878|    381|	return(1);
  879|    381|    }
  880|    887|    str++;
  881|    887|    ret = xmlParse3986HierPart(uri, &str);
  882|    887|    if (ret != 0) return(ret);
  ------------------
  |  Branch (882:9): [True: 174, False: 713]
  ------------------
  883|    713|    if (*str == '?') {
  ------------------
  |  Branch (883:9): [True: 211, False: 502]
  ------------------
  884|    211|	str++;
  885|    211|	ret = xmlParse3986Query(uri, &str);
  886|    211|	if (ret != 0) return(ret);
  ------------------
  |  Branch (886:6): [True: 0, False: 211]
  ------------------
  887|    211|    }
  888|    713|    if (*str == '#') {
  ------------------
  |  Branch (888:9): [True: 190, False: 523]
  ------------------
  889|    190|	str++;
  890|    190|	ret = xmlParse3986Fragment(uri, &str);
  891|    190|	if (ret != 0) return(ret);
  ------------------
  |  Branch (891:6): [True: 0, False: 190]
  ------------------
  892|    190|    }
  893|    713|    if (*str != 0) {
  ------------------
  |  Branch (893:9): [True: 379, False: 334]
  ------------------
  894|    379|	xmlCleanURI(uri);
  895|    379|	return(1);
  896|    379|    }
  897|    334|    return(0);
  898|    713|}
uri.c:xmlParse3986Scheme:
  213|  2.15k|xmlParse3986Scheme(xmlURIPtr uri, const char **str) {
  214|  2.15k|    const char *cur;
  215|       |
  216|  2.15k|    if (str == NULL)
  ------------------
  |  Branch (216:9): [True: 0, False: 2.15k]
  ------------------
  217|      0|	return(-1);
  218|       |
  219|  2.15k|    cur = *str;
  220|  2.15k|    if (!ISA_ALPHA(cur))
  ------------------
  |  |  152|  2.15k|#define ISA_ALPHA(p) (((*(p) >= 'a') && (*(p) <= 'z')) ||		\
  |  |  ------------------
  |  |  |  Branch (152:24): [True: 1.26k, False: 888]
  |  |  |  Branch (152:41): [True: 1.23k, False: 30]
  |  |  ------------------
  |  |  153|  2.15k|                      ((*(p) >= 'A') && (*(p) <= 'Z')))
  |  |  ------------------
  |  |  |  Branch (153:24): [True: 96, False: 822]
  |  |  |  Branch (153:41): [True: 36, False: 60]
  |  |  ------------------
  ------------------
  221|    882|	return(2);
  222|  1.26k|    cur++;
  223|  4.86k|    while (ISA_ALPHA(cur) || ISA_DIGIT(cur) ||
  ------------------
  |  |  152|  9.72k|#define ISA_ALPHA(p) (((*(p) >= 'a') && (*(p) <= 'z')) ||		\
  |  |  ------------------
  |  |  |  Branch (152:24): [True: 3.09k, False: 1.77k]
  |  |  |  Branch (152:41): [True: 3.08k, False: 5]
  |  |  ------------------
  |  |  153|  9.72k|                      ((*(p) >= 'A') && (*(p) <= 'Z')))
  |  |  ------------------
  |  |  |  Branch (153:24): [True: 339, False: 1.43k]
  |  |  |  Branch (153:41): [True: 315, False: 24]
  |  |  ------------------
  ------------------
                  while (ISA_ALPHA(cur) || ISA_DIGIT(cur) ||
  ------------------
  |  |  151|  6.32k|#define ISA_DIGIT(p) ((*(p) >= '0') && (*(p) <= '9'))
  |  |  ------------------
  |  |  |  Branch (151:23): [True: 1.09k, False: 364]
  |  |  |  Branch (151:40): [True: 125, False: 971]
  |  |  ------------------
  ------------------
  224|  4.86k|           (*cur == '+') || (*cur == '-') || (*cur == '.')) cur++;
  ------------------
  |  Branch (224:12): [True: 6, False: 1.32k]
  |  Branch (224:29): [True: 11, False: 1.31k]
  |  Branch (224:46): [True: 50, False: 1.26k]
  ------------------
  225|  1.26k|    if (uri != NULL) {
  ------------------
  |  Branch (225:9): [True: 1.26k, False: 0]
  ------------------
  226|  1.26k|	if (uri->scheme != NULL) xmlFree(uri->scheme);
  ------------------
  |  Branch (226:6): [True: 0, False: 1.26k]
  ------------------
  227|  1.26k|	uri->scheme = STRNDUP(*str, cur - *str);
  ------------------
  |  |  143|  1.26k|#define STRNDUP(s, n) (char *) xmlStrndup((const xmlChar *)(s), (n))
  ------------------
  228|  1.26k|    }
  229|  1.26k|    *str = cur;
  230|  1.26k|    return(0);
  231|  2.15k|}
uri.c:xmlParse3986HierPart:
  765|    887|{
  766|    887|    const char *cur;
  767|    887|    int ret;
  768|       |
  769|    887|    cur = *str;
  770|       |
  771|    887|    if ((*cur == '/') && (*(cur + 1) == '/')) {
  ------------------
  |  Branch (771:9): [True: 715, False: 172]
  |  Branch (771:26): [True: 555, False: 160]
  ------------------
  772|    555|        cur += 2;
  773|    555|	ret = xmlParse3986Authority(uri, &cur);
  774|    555|	if (ret != 0) return(ret);
  ------------------
  |  Branch (774:6): [True: 174, False: 381]
  ------------------
  775|       |        /*
  776|       |         * An empty server is marked with a special URI value.
  777|       |         */
  778|    381|	if ((uri->server == NULL) && (uri->port == PORT_EMPTY))
  ------------------
  |  |   37|     56|#define PORT_EMPTY           0
  ------------------
  |  Branch (778:6): [True: 56, False: 325]
  |  Branch (778:31): [True: 54, False: 2]
  ------------------
  779|     54|	    uri->port = PORT_EMPTY_SERVER;
  ------------------
  |  |   38|     54|#define PORT_EMPTY_SERVER   -1
  ------------------
  780|    381|	ret = xmlParse3986PathAbEmpty(uri, &cur);
  781|    381|	if (ret != 0) return(ret);
  ------------------
  |  Branch (781:6): [True: 0, False: 381]
  ------------------
  782|    381|	*str = cur;
  783|    381|	return(0);
  784|    381|    } else if (*cur == '/') {
  ------------------
  |  Branch (784:16): [True: 160, False: 172]
  ------------------
  785|    160|        ret = xmlParse3986PathAbsolute(uri, &cur);
  786|    160|	if (ret != 0) return(ret);
  ------------------
  |  Branch (786:6): [True: 0, False: 160]
  ------------------
  787|    172|    } else if (ISA_PCHAR(cur)) {
  ------------------
  |  |  198|    172|     (ISA_UNRESERVED(p) || ISA_PCT_ENCODED(p) || ISA_SUB_DELIM(p) ||	\
  |  |  ------------------
  |  |  |  |  185|    344|      ((ISA_ALPHA(p)) || (ISA_DIGIT(p)) || ((*(p) == '-')) ||		\
  |  |  |  |  ------------------
  |  |  |  |  |  |  152|    172|#define ISA_ALPHA(p) (((*(p) >= 'a') && (*(p) <= 'z')) ||		\
  |  |  |  |  |  |  ------------------
  |  |  |  |  |  |  |  Branch (152:24): [True: 55, False: 117]
  |  |  |  |  |  |  |  Branch (152:41): [True: 55, False: 0]
  |  |  |  |  |  |  ------------------
  |  |  |  |  |  |  153|    172|                      ((*(p) >= 'A') && (*(p) <= 'Z')))
  |  |  |  |  |  |  ------------------
  |  |  |  |  |  |  |  Branch (153:24): [True: 6, False: 111]
  |  |  |  |  |  |  |  Branch (153:41): [True: 6, False: 0]
  |  |  |  |  |  |  ------------------
  |  |  |  |  ------------------
  |  |  |  |                     ((ISA_ALPHA(p)) || (ISA_DIGIT(p)) || ((*(p) == '-')) ||		\
  |  |  |  |  ------------------
  |  |  |  |  |  |  151|    111|#define ISA_DIGIT(p) ((*(p) >= '0') && (*(p) <= '9'))
  |  |  |  |  |  |  ------------------
  |  |  |  |  |  |  |  Branch (151:23): [True: 46, False: 65]
  |  |  |  |  |  |  |  Branch (151:40): [True: 14, False: 32]
  |  |  |  |  |  |  ------------------
  |  |  |  |  ------------------
  |  |  |  |  |  Branch (185:44): [True: 10, False: 87]
  |  |  |  |  ------------------
  |  |  |  |  186|    172|       ((*(p) == '.')) || ((*(p) == '_')) || ((*(p) == '~')))
  |  |  |  |  ------------------
  |  |  |  |  |  Branch (186:8): [True: 6, False: 81]
  |  |  |  |  |  Branch (186:27): [True: 0, False: 81]
  |  |  |  |  |  Branch (186:46): [True: 0, False: 81]
  |  |  |  |  ------------------
  |  |  ------------------
  |  |                    (ISA_UNRESERVED(p) || ISA_PCT_ENCODED(p) || ISA_SUB_DELIM(p) ||	\
  |  |  ------------------
  |  |  |  |  192|    253|     ((*(p) == '%') && (ISA_HEXDIG(p + 1)) && (ISA_HEXDIG(p + 2)))
  |  |  |  |  ------------------
  |  |  |  |  |  |  155|      0|       (ISA_DIGIT(p) || ((*(p) >= 'a') && (*(p) <= 'f')) ||		\
  |  |  |  |  |  |  ------------------
  |  |  |  |  |  |  |  |  151|      0|#define ISA_DIGIT(p) ((*(p) >= '0') && (*(p) <= '9'))
  |  |  |  |  |  |  |  |  ------------------
  |  |  |  |  |  |  |  |  |  Branch (151:23): [True: 0, False: 0]
  |  |  |  |  |  |  |  |  |  Branch (151:40): [True: 0, False: 0]
  |  |  |  |  |  |  |  |  ------------------
  |  |  |  |  |  |  ------------------
  |  |  |  |  |  |  |  Branch (155:26): [True: 0, False: 0]
  |  |  |  |  |  |  |  Branch (155:43): [True: 0, False: 0]
  |  |  |  |  |  |  ------------------
  |  |  |  |  |  |  156|      0|        ((*(p) >= 'A') && (*(p) <= 'F')))
  |  |  |  |  |  |  ------------------
  |  |  |  |  |  |  |  Branch (156:10): [True: 0, False: 0]
  |  |  |  |  |  |  |  Branch (156:27): [True: 0, False: 0]
  |  |  |  |  |  |  ------------------
  |  |  |  |  ------------------
  |  |  |  |                    ((*(p) == '%') && (ISA_HEXDIG(p + 1)) && (ISA_HEXDIG(p + 2)))
  |  |  |  |  ------------------
  |  |  |  |  |  |  155|      0|       (ISA_DIGIT(p) || ((*(p) >= 'a') && (*(p) <= 'f')) ||		\
  |  |  |  |  |  |  ------------------
  |  |  |  |  |  |  |  |  151|      0|#define ISA_DIGIT(p) ((*(p) >= '0') && (*(p) <= '9'))
  |  |  |  |  |  |  |  |  ------------------
  |  |  |  |  |  |  |  |  |  Branch (151:23): [True: 0, False: 0]
  |  |  |  |  |  |  |  |  |  Branch (151:40): [True: 0, False: 0]
  |  |  |  |  |  |  |  |  ------------------
  |  |  |  |  |  |  ------------------
  |  |  |  |  |  |  |  Branch (155:26): [True: 0, False: 0]
  |  |  |  |  |  |  |  Branch (155:43): [True: 0, False: 0]
  |  |  |  |  |  |  ------------------
  |  |  |  |  |  |  156|      0|        ((*(p) >= 'A') && (*(p) <= 'F')))
  |  |  |  |  |  |  ------------------
  |  |  |  |  |  |  |  Branch (156:10): [True: 0, False: 0]
  |  |  |  |  |  |  |  Branch (156:27): [True: 0, False: 0]
  |  |  |  |  |  |  ------------------
  |  |  |  |  ------------------
  |  |  |  |  |  Branch (192:7): [True: 0, False: 81]
  |  |  |  |  ------------------
  |  |  ------------------
  |  |                    (ISA_UNRESERVED(p) || ISA_PCT_ENCODED(p) || ISA_SUB_DELIM(p) ||	\
  |  |  ------------------
  |  |  |  |  163|    253|      (((*(p) == '!')) || ((*(p) == '$')) || ((*(p) == '&')) ||		\
  |  |  |  |  ------------------
  |  |  |  |  |  Branch (163:8): [True: 5, False: 76]
  |  |  |  |  |  Branch (163:27): [True: 0, False: 76]
  |  |  |  |  |  Branch (163:46): [True: 5, False: 71]
  |  |  |  |  ------------------
  |  |  |  |  164|     81|       ((*(p) == '(')) || ((*(p) == ')')) || ((*(p) == '*')) ||		\
  |  |  |  |  ------------------
  |  |  |  |  |  Branch (164:8): [True: 0, False: 71]
  |  |  |  |  |  Branch (164:27): [True: 0, False: 71]
  |  |  |  |  |  Branch (164:46): [True: 4, False: 67]
  |  |  |  |  ------------------
  |  |  |  |  165|     81|       ((*(p) == '+')) || ((*(p) == ',')) || ((*(p) == ';')) ||		\
  |  |  |  |  ------------------
  |  |  |  |  |  Branch (165:8): [True: 10, False: 57]
  |  |  |  |  |  Branch (165:27): [True: 0, False: 57]
  |  |  |  |  |  Branch (165:46): [True: 6, False: 51]
  |  |  |  |  ------------------
  |  |  |  |  166|     81|       ((*(p) == '=')) || ((*(p) == '\'')))
  |  |  |  |  ------------------
  |  |  |  |  |  Branch (166:8): [True: 0, False: 51]
  |  |  |  |  |  Branch (166:27): [True: 7, False: 44]
  |  |  |  |  ------------------
  |  |  ------------------
  |  |  199|    172|      ((*(p) == ':')) || ((*(p) == '@')))
  |  |  ------------------
  |  |  |  Branch (199:7): [True: 26, False: 18]
  |  |  |  Branch (199:26): [True: 0, False: 18]
  |  |  ------------------
  ------------------
  788|    154|        ret = xmlParse3986PathRootless(uri, &cur);
  789|    154|	if (ret != 0) return(ret);
  ------------------
  |  Branch (789:6): [True: 0, False: 154]
  ------------------
  790|    154|    } else {
  791|       |	/* path-empty is effectively empty */
  792|     18|	if (uri != NULL) {
  ------------------
  |  Branch (792:6): [True: 18, False: 0]
  ------------------
  793|     18|	    if (uri->path != NULL) xmlFree(uri->path);
  ------------------
  |  Branch (793:10): [True: 0, False: 18]
  ------------------
  794|     18|	    uri->path = NULL;
  795|     18|	}
  796|     18|    }
  797|    332|    *str = cur;
  798|    332|    return (0);
  799|    887|}
uri.c:xmlParse3986Authority:
  521|    577|{
  522|    577|    const char *cur;
  523|    577|    int ret;
  524|       |
  525|    577|    cur = *str;
  526|       |    /*
  527|       |     * try to parse an userinfo and check for the trailing @
  528|       |     */
  529|    577|    ret = xmlParse3986Userinfo(uri, &cur);
  530|    577|    if ((ret != 0) || (*cur != '@'))
  ------------------
  |  Branch (530:9): [True: 389, False: 188]
  |  Branch (530:23): [True: 0, False: 188]
  ------------------
  531|    389|        cur = *str;
  532|    188|    else
  533|    188|        cur++;
  534|    577|    ret = xmlParse3986Host(uri, &cur);
  535|    577|    if (ret != 0) return(ret);
  ------------------
  |  Branch (535:9): [True: 6, False: 571]
  ------------------
  536|    571|    if (*cur == ':') {
  ------------------
  |  Branch (536:9): [True: 305, False: 266]
  ------------------
  537|    305|        cur++;
  538|    305|        ret = xmlParse3986Port(uri, &cur);
  539|    305|	if (ret != 0) return(ret);
  ------------------
  |  Branch (539:6): [True: 172, False: 133]
  ------------------
  540|    305|    }
  541|    399|    *str = cur;
  542|    399|    return(0);
  543|    571|}
uri.c:xmlParse3986Userinfo:
  370|    577|{
  371|    577|    const char *cur;
  372|       |
  373|    577|    cur = *str;
  374|  2.32k|    while (ISA_UNRESERVED(cur) || ISA_PCT_ENCODED(cur) ||
  ------------------
  |  |  185|  4.65k|      ((ISA_ALPHA(p)) || (ISA_DIGIT(p)) || ((*(p) == '-')) ||		\
  |  |  ------------------
  |  |  |  |  152|  2.32k|#define ISA_ALPHA(p) (((*(p) >= 'a') && (*(p) <= 'z')) ||		\
  |  |  |  |  ------------------
  |  |  |  |  |  Branch (152:24): [True: 1.03k, False: 1.29k]
  |  |  |  |  |  Branch (152:41): [True: 1.02k, False: 11]
  |  |  |  |  ------------------
  |  |  |  |  153|  2.32k|                      ((*(p) >= 'A') && (*(p) <= 'Z')))
  |  |  |  |  ------------------
  |  |  |  |  |  Branch (153:24): [True: 17, False: 1.28k]
  |  |  |  |  |  Branch (153:41): [True: 6, False: 11]
  |  |  |  |  ------------------
  |  |  ------------------
  |  |                     ((ISA_ALPHA(p)) || (ISA_DIGIT(p)) || ((*(p) == '-')) ||		\
  |  |  ------------------
  |  |  |  |  151|  1.29k|#define ISA_DIGIT(p) ((*(p) >= '0') && (*(p) <= '9'))
  |  |  |  |  ------------------
  |  |  |  |  |  Branch (151:23): [True: 779, False: 520]
  |  |  |  |  |  Branch (151:40): [True: 133, False: 646]
  |  |  |  |  ------------------
  |  |  ------------------
  |  |  |  Branch (185:44): [True: 0, False: 1.16k]
  |  |  ------------------
  |  |  186|  2.32k|       ((*(p) == '.')) || ((*(p) == '_')) || ((*(p) == '~')))
  |  |  ------------------
  |  |  |  Branch (186:8): [True: 54, False: 1.11k]
  |  |  |  Branch (186:27): [True: 0, False: 1.11k]
  |  |  |  Branch (186:46): [True: 5, False: 1.10k]
  |  |  ------------------
  ------------------
                  while (ISA_UNRESERVED(cur) || ISA_PCT_ENCODED(cur) ||
  ------------------
  |  |  192|  3.43k|     ((*(p) == '%') && (ISA_HEXDIG(p + 1)) && (ISA_HEXDIG(p + 2)))
  |  |  ------------------
  |  |  |  |  155|     82|       (ISA_DIGIT(p) || ((*(p) >= 'a') && (*(p) <= 'f')) ||		\
  |  |  |  |  ------------------
  |  |  |  |  |  |  151|    164|#define ISA_DIGIT(p) ((*(p) >= '0') && (*(p) <= '9'))
  |  |  |  |  |  |  ------------------
  |  |  |  |  |  |  |  Branch (151:23): [True: 82, False: 0]
  |  |  |  |  |  |  |  Branch (151:40): [True: 27, False: 55]
  |  |  |  |  |  |  ------------------
  |  |  |  |  ------------------
  |  |  |  |  |  Branch (155:26): [True: 0, False: 55]
  |  |  |  |  |  Branch (155:43): [True: 0, False: 0]
  |  |  |  |  ------------------
  |  |  |  |  156|     82|        ((*(p) >= 'A') && (*(p) <= 'F')))
  |  |  |  |  ------------------
  |  |  |  |  |  Branch (156:10): [True: 55, False: 0]
  |  |  |  |  |  Branch (156:27): [True: 55, False: 0]
  |  |  |  |  ------------------
  |  |  ------------------
  |  |                    ((*(p) == '%') && (ISA_HEXDIG(p + 1)) && (ISA_HEXDIG(p + 2)))
  |  |  ------------------
  |  |  |  |  155|     82|       (ISA_DIGIT(p) || ((*(p) >= 'a') && (*(p) <= 'f')) ||		\
  |  |  |  |  ------------------
  |  |  |  |  |  |  151|    164|#define ISA_DIGIT(p) ((*(p) >= '0') && (*(p) <= '9'))
  |  |  |  |  |  |  ------------------
  |  |  |  |  |  |  |  Branch (151:23): [True: 82, False: 0]
  |  |  |  |  |  |  |  Branch (151:40): [True: 38, False: 44]
  |  |  |  |  |  |  ------------------
  |  |  |  |  ------------------
  |  |  |  |  |  Branch (155:26): [True: 0, False: 44]
  |  |  |  |  |  Branch (155:43): [True: 0, False: 0]
  |  |  |  |  ------------------
  |  |  |  |  156|     82|        ((*(p) >= 'A') && (*(p) <= 'F')))
  |  |  |  |  ------------------
  |  |  |  |  |  Branch (156:10): [True: 44, False: 0]
  |  |  |  |  |  Branch (156:27): [True: 44, False: 0]
  |  |  |  |  ------------------
  |  |  ------------------
  |  |  |  Branch (192:7): [True: 82, False: 1.02k]
  |  |  ------------------
  ------------------
  375|  2.32k|           ISA_SUB_DELIM(cur) || (*cur == ':'))
  ------------------
  |  |  163|  3.35k|      (((*(p) == '!')) || ((*(p) == '$')) || ((*(p) == '&')) ||		\
  |  |  ------------------
  |  |  |  Branch (163:8): [True: 0, False: 1.02k]
  |  |  |  Branch (163:27): [True: 0, False: 1.02k]
  |  |  |  Branch (163:46): [True: 31, False: 994]
  |  |  ------------------
  |  |  164|  1.02k|       ((*(p) == '(')) || ((*(p) == ')')) || ((*(p) == '*')) ||		\
  |  |  ------------------
  |  |  |  Branch (164:8): [True: 2, False: 992]
  |  |  |  Branch (164:27): [True: 0, False: 992]
  |  |  |  Branch (164:46): [True: 4, False: 988]
  |  |  ------------------
  |  |  165|  1.02k|       ((*(p) == '+')) || ((*(p) == ',')) || ((*(p) == ';')) ||		\
  |  |  ------------------
  |  |  |  Branch (165:8): [True: 10, False: 978]
  |  |  |  Branch (165:27): [True: 0, False: 978]
  |  |  |  Branch (165:46): [True: 0, False: 978]
  |  |  ------------------
  |  |  166|  1.02k|       ((*(p) == '=')) || ((*(p) == '\'')))
  |  |  ------------------
  |  |  |  Branch (166:8): [True: 5, False: 973]
  |  |  |  Branch (166:27): [True: 0, False: 973]
  |  |  ------------------
  ------------------
  |  Branch (375:34): [True: 396, False: 577]
  ------------------
  376|  1.75k|	NEXT(cur);
  ------------------
  |  |  131|  1.75k|#define NEXT(p) ((*p == '%')? p += 3 : p++)
  |  |  ------------------
  |  |  |  Branch (131:18): [True: 82, False: 1.67k]
  |  |  ------------------
  ------------------
  377|    577|    if (*cur == '@') {
  ------------------
  |  Branch (377:9): [True: 188, False: 389]
  ------------------
  378|    188|	if (uri != NULL) {
  ------------------
  |  Branch (378:6): [True: 188, False: 0]
  ------------------
  379|    188|	    if (uri->user != NULL) xmlFree(uri->user);
  ------------------
  |  Branch (379:10): [True: 0, False: 188]
  ------------------
  380|    188|	    if (uri->cleanup & 2)
  ------------------
  |  Branch (380:10): [True: 30, False: 158]
  ------------------
  381|     30|		uri->user = STRNDUP(*str, cur - *str);
  ------------------
  |  |  143|     30|#define STRNDUP(s, n) (char *) xmlStrndup((const xmlChar *)(s), (n))
  ------------------
  382|    158|	    else
  383|    158|		uri->user = xmlURIUnescapeString(*str, cur - *str, NULL);
  384|    188|	}
  385|    188|	*str = cur;
  386|    188|	return(0);
  387|    188|    }
  388|    389|    return(1);
  389|    577|}
uri.c:xmlParse3986Host:
  445|    577|{
  446|    577|    const char *cur = *str;
  447|    577|    const char *host;
  448|       |
  449|    577|    host = cur;
  450|       |    /*
  451|       |     * IPv6 and future addressing scheme are enclosed between brackets
  452|       |     */
  453|    577|    if (*cur == '[') {
  ------------------
  |  Branch (453:9): [True: 6, False: 571]
  ------------------
  454|      6|        cur++;
  455|     30|	while ((*cur != ']') && (*cur != 0))
  ------------------
  |  Branch (455:9): [True: 30, False: 0]
  |  Branch (455:26): [True: 24, False: 6]
  ------------------
  456|     24|	    cur++;
  457|      6|	if (*cur != ']')
  ------------------
  |  Branch (457:6): [True: 6, False: 0]
  ------------------
  458|      6|	    return(1);
  459|      0|	cur++;
  460|      0|	goto found;
  461|      6|    }
  462|       |    /*
  463|       |     * try to parse an IPv4
  464|       |     */
  465|    571|    if (ISA_DIGIT(cur)) {
  ------------------
  |  |  151|    571|#define ISA_DIGIT(p) ((*(p) >= '0') && (*(p) <= '9'))
  |  |  ------------------
  |  |  |  Branch (151:23): [True: 493, False: 78]
  |  |  |  Branch (151:40): [True: 0, False: 493]
  |  |  ------------------
  ------------------
  466|      0|        if (xmlParse3986DecOctet(&cur) != 0)
  ------------------
  |  Branch (466:13): [True: 0, False: 0]
  ------------------
  467|      0|	    goto not_ipv4;
  468|      0|	if (*cur != '.')
  ------------------
  |  Branch (468:6): [True: 0, False: 0]
  ------------------
  469|      0|	    goto not_ipv4;
  470|      0|	cur++;
  471|      0|        if (xmlParse3986DecOctet(&cur) != 0)
  ------------------
  |  Branch (471:13): [True: 0, False: 0]
  ------------------
  472|      0|	    goto not_ipv4;
  473|      0|	if (*cur != '.')
  ------------------
  |  Branch (473:6): [True: 0, False: 0]
  ------------------
  474|      0|	    goto not_ipv4;
  475|      0|        if (xmlParse3986DecOctet(&cur) != 0)
  ------------------
  |  Branch (475:13): [True: 0, False: 0]
  ------------------
  476|      0|	    goto not_ipv4;
  477|      0|	if (*cur != '.')
  ------------------
  |  Branch (477:6): [True: 0, False: 0]
  ------------------
  478|      0|	    goto not_ipv4;
  479|      0|        if (xmlParse3986DecOctet(&cur) != 0)
  ------------------
  |  Branch (479:13): [True: 0, False: 0]
  ------------------
  480|      0|	    goto not_ipv4;
  481|      0|	goto found;
  482|      0|not_ipv4:
  483|      0|        cur = *str;
  484|      0|    }
  485|       |    /*
  486|       |     * then this should be a hostname which can be empty
  487|       |     */
  488|  2.03k|    while (ISA_UNRESERVED(cur) || ISA_PCT_ENCODED(cur) || ISA_SUB_DELIM(cur))
  ------------------
  |  |  185|  4.07k|      ((ISA_ALPHA(p)) || (ISA_DIGIT(p)) || ((*(p) == '-')) ||		\
  |  |  ------------------
  |  |  |  |  152|  2.03k|#define ISA_ALPHA(p) (((*(p) >= 'a') && (*(p) <= 'z')) ||		\
  |  |  |  |  ------------------
  |  |  |  |  |  Branch (152:24): [True: 1.03k, False: 1.00k]
  |  |  |  |  |  Branch (152:41): [True: 1.02k, False: 12]
  |  |  |  |  ------------------
  |  |  |  |  153|  2.03k|                      ((*(p) >= 'A') && (*(p) <= 'Z')))
  |  |  |  |  ------------------
  |  |  |  |  |  Branch (153:24): [True: 20, False: 997]
  |  |  |  |  |  Branch (153:41): [True: 8, False: 12]
  |  |  |  |  ------------------
  |  |  ------------------
  |  |                     ((ISA_ALPHA(p)) || (ISA_DIGIT(p)) || ((*(p) == '-')) ||		\
  |  |  ------------------
  |  |  |  |  151|  1.00k|#define ISA_DIGIT(p) ((*(p) >= '0') && (*(p) <= '9'))
  |  |  |  |  ------------------
  |  |  |  |  |  Branch (151:23): [True: 530, False: 479]
  |  |  |  |  |  Branch (151:40): [True: 162, False: 368]
  |  |  |  |  ------------------
  |  |  ------------------
  |  |  |  Branch (185:44): [True: 0, False: 847]
  |  |  ------------------
  |  |  186|  2.03k|       ((*(p) == '.')) || ((*(p) == '_')) || ((*(p) == '~')))
  |  |  ------------------
  |  |  |  Branch (186:8): [True: 170, False: 677]
  |  |  |  Branch (186:27): [True: 0, False: 677]
  |  |  |  Branch (186:46): [True: 0, False: 677]
  |  |  ------------------
  ------------------
                  while (ISA_UNRESERVED(cur) || ISA_PCT_ENCODED(cur) || ISA_SUB_DELIM(cur))
  ------------------
  |  |  192|  2.71k|     ((*(p) == '%') && (ISA_HEXDIG(p + 1)) && (ISA_HEXDIG(p + 2)))
  |  |  ------------------
  |  |  |  |  155|     62|       (ISA_DIGIT(p) || ((*(p) >= 'a') && (*(p) <= 'f')) ||		\
  |  |  |  |  ------------------
  |  |  |  |  |  |  151|    124|#define ISA_DIGIT(p) ((*(p) >= '0') && (*(p) <= '9'))
  |  |  |  |  |  |  ------------------
  |  |  |  |  |  |  |  Branch (151:23): [True: 62, False: 0]
  |  |  |  |  |  |  |  Branch (151:40): [True: 25, False: 37]
  |  |  |  |  |  |  ------------------
  |  |  |  |  ------------------
  |  |  |  |  |  Branch (155:26): [True: 0, False: 37]
  |  |  |  |  |  Branch (155:43): [True: 0, False: 0]
  |  |  |  |  ------------------
  |  |  |  |  156|     62|        ((*(p) >= 'A') && (*(p) <= 'F')))
  |  |  |  |  ------------------
  |  |  |  |  |  Branch (156:10): [True: 37, False: 0]
  |  |  |  |  |  Branch (156:27): [True: 37, False: 0]
  |  |  |  |  ------------------
  |  |  ------------------
  |  |                    ((*(p) == '%') && (ISA_HEXDIG(p + 1)) && (ISA_HEXDIG(p + 2)))
  |  |  ------------------
  |  |  |  |  155|     62|       (ISA_DIGIT(p) || ((*(p) >= 'a') && (*(p) <= 'f')) ||		\
  |  |  |  |  ------------------
  |  |  |  |  |  |  151|    124|#define ISA_DIGIT(p) ((*(p) >= '0') && (*(p) <= '9'))
  |  |  |  |  |  |  ------------------
  |  |  |  |  |  |  |  Branch (151:23): [True: 62, False: 0]
  |  |  |  |  |  |  |  Branch (151:40): [True: 24, False: 38]
  |  |  |  |  |  |  ------------------
  |  |  |  |  ------------------
  |  |  |  |  |  Branch (155:26): [True: 0, False: 38]
  |  |  |  |  |  Branch (155:43): [True: 0, False: 0]
  |  |  |  |  ------------------
  |  |  |  |  156|     62|        ((*(p) >= 'A') && (*(p) <= 'F')))
  |  |  |  |  ------------------
  |  |  |  |  |  Branch (156:10): [True: 38, False: 0]
  |  |  |  |  |  Branch (156:27): [True: 38, False: 0]
  |  |  |  |  ------------------
  |  |  ------------------
  |  |  |  Branch (192:7): [True: 62, False: 615]
  |  |  ------------------
  ------------------
                  while (ISA_UNRESERVED(cur) || ISA_PCT_ENCODED(cur) || ISA_SUB_DELIM(cur))
  ------------------
  |  |  163|    615|      (((*(p) == '!')) || ((*(p) == '$')) || ((*(p) == '&')) ||		\
  |  |  ------------------
  |  |  |  Branch (163:8): [True: 0, False: 615]
  |  |  |  Branch (163:27): [True: 0, False: 615]
  |  |  |  Branch (163:46): [True: 31, False: 584]
  |  |  ------------------
  |  |  164|    615|       ((*(p) == '(')) || ((*(p) == ')')) || ((*(p) == '*')) ||		\
  |  |  ------------------
  |  |  |  Branch (164:8): [True: 8, False: 576]
  |  |  |  Branch (164:27): [True: 0, False: 576]
  |  |  |  Branch (164:46): [True: 0, False: 576]
  |  |  ------------------
  |  |  165|    615|       ((*(p) == '+')) || ((*(p) == ',')) || ((*(p) == ';')) ||		\
  |  |  ------------------
  |  |  |  Branch (165:8): [True: 0, False: 576]
  |  |  |  Branch (165:27): [True: 0, False: 576]
  |  |  |  Branch (165:46): [True: 0, False: 576]
  |  |  ------------------
  |  |  166|    615|       ((*(p) == '=')) || ((*(p) == '\'')))
  |  |  ------------------
  |  |  |  Branch (166:8): [True: 5, False: 571]
  |  |  |  Branch (166:27): [True: 0, False: 571]
  |  |  ------------------
  ------------------
  489|  1.46k|        NEXT(cur);
  ------------------
  |  |  131|  2.03k|#define NEXT(p) ((*p == '%')? p += 3 : p++)
  |  |  ------------------
  |  |  |  Branch (131:18): [True: 62, False: 1.40k]
  |  |  ------------------
  ------------------
  490|    571|found:
  491|    571|    if (uri != NULL) {
  ------------------
  |  Branch (491:9): [True: 571, False: 0]
  ------------------
  492|    571|	if (uri->authority != NULL) xmlFree(uri->authority);
  ------------------
  |  Branch (492:6): [True: 0, False: 571]
  ------------------
  493|    571|	uri->authority = NULL;
  494|    571|	if (uri->server != NULL) xmlFree(uri->server);
  ------------------
  |  Branch (494:6): [True: 0, False: 571]
  ------------------
  495|    571|	if (cur != host) {
  ------------------
  |  Branch (495:6): [True: 514, False: 57]
  ------------------
  496|    514|	    if (uri->cleanup & 2)
  ------------------
  |  Branch (496:10): [True: 78, False: 436]
  ------------------
  497|     78|		uri->server = STRNDUP(host, cur - host);
  ------------------
  |  |  143|     78|#define STRNDUP(s, n) (char *) xmlStrndup((const xmlChar *)(s), (n))
  ------------------
  498|    436|	    else
  499|    436|		uri->server = xmlURIUnescapeString(host, cur - host, NULL);
  500|    514|	} else
  501|     57|	    uri->server = NULL;
  502|    571|    }
  503|    571|    *str = cur;
  504|    571|    return(0);
  505|    571|}
uri.c:xmlParse3986Port:
  331|    305|{
  332|    305|    const char *cur = *str;
  333|    305|    int port = 0;
  334|       |
  335|    305|    if (ISA_DIGIT(cur)) {
  ------------------
  |  |  151|    305|#define ISA_DIGIT(p) ((*(p) >= '0') && (*(p) <= '9'))
  |  |  ------------------
  |  |  |  Branch (151:23): [True: 209, False: 96]
  |  |  |  Branch (151:40): [True: 133, False: 76]
  |  |  ------------------
  ------------------
  336|    339|	while (ISA_DIGIT(cur)) {
  ------------------
  |  |  151|    339|#define ISA_DIGIT(p) ((*(p) >= '0') && (*(p) <= '9'))
  |  |  ------------------
  |  |  |  Branch (151:23): [True: 226, False: 113]
  |  |  |  Branch (151:40): [True: 206, False: 20]
  |  |  ------------------
  ------------------
  337|    206|            int digit = *cur - '0';
  338|       |
  339|    206|            if (port > INT_MAX / 10)
  ------------------
  |  Branch (339:17): [True: 0, False: 206]
  ------------------
  340|      0|                return(1);
  341|    206|            port *= 10;
  342|    206|            if (port > INT_MAX - digit)
  ------------------
  |  Branch (342:17): [True: 0, False: 206]
  ------------------
  343|      0|                return(1);
  344|    206|	    port += digit;
  345|       |
  346|    206|	    cur++;
  347|    206|	}
  348|    133|	if (uri != NULL)
  ------------------
  |  Branch (348:6): [True: 133, False: 0]
  ------------------
  349|    133|	    uri->port = port;
  350|    133|	*str = cur;
  351|    133|	return(0);
  352|    133|    }
  353|    172|    return(1);
  354|    305|}
uri.c:xmlParse3986PathAbEmpty:
  592|    399|{
  593|    399|    const char *cur;
  594|    399|    int ret;
  595|       |
  596|    399|    cur = *str;
  597|       |
  598|    693|    while (*cur == '/') {
  ------------------
  |  Branch (598:12): [True: 294, False: 399]
  ------------------
  599|    294|        cur++;
  600|    294|	ret = xmlParse3986Segment(&cur, 0, 1);
  601|    294|	if (ret != 0) return(ret);
  ------------------
  |  Branch (601:6): [True: 0, False: 294]
  ------------------
  602|    294|    }
  603|    399|    if (uri != NULL) {
  ------------------
  |  Branch (603:9): [True: 399, False: 0]
  ------------------
  604|    399|	if (uri->path != NULL) xmlFree(uri->path);
  ------------------
  |  Branch (604:6): [True: 0, False: 399]
  ------------------
  605|    399|        if (*str != cur) {
  ------------------
  |  Branch (605:13): [True: 151, False: 248]
  ------------------
  606|    151|            if (uri->cleanup & 2)
  ------------------
  |  Branch (606:17): [True: 22, False: 129]
  ------------------
  607|     22|                uri->path = STRNDUP(*str, cur - *str);
  ------------------
  |  |  143|     22|#define STRNDUP(s, n) (char *) xmlStrndup((const xmlChar *)(s), (n))
  ------------------
  608|    129|            else
  609|    129|                uri->path = xmlURIUnescapeString(*str, cur - *str, NULL);
  610|    248|        } else {
  611|    248|            uri->path = NULL;
  612|    248|        }
  613|    399|    }
  614|    399|    *str = cur;
  615|    399|    return (0);
  616|    399|}
uri.c:xmlParse3986Segment:
  563|  4.30k|{
  564|  4.30k|    const char *cur;
  565|       |
  566|  4.30k|    cur = *str;
  567|  4.30k|    if (!ISA_PCHAR(cur)) {
  ------------------
  |  |  198|  4.30k|     (ISA_UNRESERVED(p) || ISA_PCT_ENCODED(p) || ISA_SUB_DELIM(p) ||	\
  |  |  ------------------
  |  |  |  |  185|  8.60k|      ((ISA_ALPHA(p)) || (ISA_DIGIT(p)) || ((*(p) == '-')) ||		\
  |  |  |  |  ------------------
  |  |  |  |  |  |  152|  4.30k|#define ISA_ALPHA(p) (((*(p) >= 'a') && (*(p) <= 'z')) ||		\
  |  |  |  |  |  |  ------------------
  |  |  |  |  |  |  |  Branch (152:24): [True: 2.57k, False: 1.72k]
  |  |  |  |  |  |  |  Branch (152:41): [True: 2.54k, False: 36]
  |  |  |  |  |  |  ------------------
  |  |  |  |  |  |  153|  4.30k|                      ((*(p) >= 'A') && (*(p) <= 'Z')))
  |  |  |  |  |  |  ------------------
  |  |  |  |  |  |  |  Branch (153:24): [True: 79, False: 1.68k]
  |  |  |  |  |  |  |  Branch (153:41): [True: 43, False: 36]
  |  |  |  |  |  |  ------------------
  |  |  |  |  ------------------
  |  |  |  |                     ((ISA_ALPHA(p)) || (ISA_DIGIT(p)) || ((*(p) == '-')) ||		\
  |  |  |  |  ------------------
  |  |  |  |  |  |  151|  1.71k|#define ISA_DIGIT(p) ((*(p) >= '0') && (*(p) <= '9'))
  |  |  |  |  |  |  ------------------
  |  |  |  |  |  |  |  Branch (151:23): [True: 825, False: 891]
  |  |  |  |  |  |  |  Branch (151:40): [True: 369, False: 456]
  |  |  |  |  |  |  ------------------
  |  |  |  |  ------------------
  |  |  |  |  |  Branch (185:44): [True: 16, False: 1.33k]
  |  |  |  |  ------------------
  |  |  |  |  186|  4.30k|       ((*(p) == '.')) || ((*(p) == '_')) || ((*(p) == '~')))
  |  |  |  |  ------------------
  |  |  |  |  |  Branch (186:8): [True: 365, False: 966]
  |  |  |  |  |  Branch (186:27): [True: 0, False: 966]
  |  |  |  |  |  Branch (186:46): [True: 22, False: 944]
  |  |  |  |  ------------------
  |  |  ------------------
  |  |                    (ISA_UNRESERVED(p) || ISA_PCT_ENCODED(p) || ISA_SUB_DELIM(p) ||	\
  |  |  ------------------
  |  |  |  |  192|  5.24k|     ((*(p) == '%') && (ISA_HEXDIG(p + 1)) && (ISA_HEXDIG(p + 2)))
  |  |  |  |  ------------------
  |  |  |  |  |  |  155|     26|       (ISA_DIGIT(p) || ((*(p) >= 'a') && (*(p) <= 'f')) ||		\
  |  |  |  |  |  |  ------------------
  |  |  |  |  |  |  |  |  151|     52|#define ISA_DIGIT(p) ((*(p) >= '0') && (*(p) <= '9'))
  |  |  |  |  |  |  |  |  ------------------
  |  |  |  |  |  |  |  |  |  Branch (151:23): [True: 26, False: 0]
  |  |  |  |  |  |  |  |  |  Branch (151:40): [True: 2, False: 24]
  |  |  |  |  |  |  |  |  ------------------
  |  |  |  |  |  |  ------------------
  |  |  |  |  |  |  |  Branch (155:26): [True: 12, False: 12]
  |  |  |  |  |  |  |  Branch (155:43): [True: 6, False: 6]
  |  |  |  |  |  |  ------------------
  |  |  |  |  |  |  156|     26|        ((*(p) >= 'A') && (*(p) <= 'F')))
  |  |  |  |  |  |  ------------------
  |  |  |  |  |  |  |  Branch (156:10): [True: 18, False: 0]
  |  |  |  |  |  |  |  Branch (156:27): [True: 12, False: 6]
  |  |  |  |  |  |  ------------------
  |  |  |  |  ------------------
  |  |  |  |                    ((*(p) == '%') && (ISA_HEXDIG(p + 1)) && (ISA_HEXDIG(p + 2)))
  |  |  |  |  ------------------
  |  |  |  |  |  |  155|     20|       (ISA_DIGIT(p) || ((*(p) >= 'a') && (*(p) <= 'f')) ||		\
  |  |  |  |  |  |  ------------------
  |  |  |  |  |  |  |  |  151|     40|#define ISA_DIGIT(p) ((*(p) >= '0') && (*(p) <= '9'))
  |  |  |  |  |  |  |  |  ------------------
  |  |  |  |  |  |  |  |  |  Branch (151:23): [True: 14, False: 6]
  |  |  |  |  |  |  |  |  |  Branch (151:40): [True: 2, False: 12]
  |  |  |  |  |  |  |  |  ------------------
  |  |  |  |  |  |  ------------------
  |  |  |  |  |  |  |  Branch (155:26): [True: 0, False: 18]
  |  |  |  |  |  |  |  Branch (155:43): [True: 0, False: 0]
  |  |  |  |  |  |  ------------------
  |  |  |  |  |  |  156|     20|        ((*(p) >= 'A') && (*(p) <= 'F')))
  |  |  |  |  |  |  ------------------
  |  |  |  |  |  |  |  Branch (156:10): [True: 12, False: 6]
  |  |  |  |  |  |  |  Branch (156:27): [True: 12, False: 0]
  |  |  |  |  |  |  ------------------
  |  |  |  |  ------------------
  |  |  |  |  |  Branch (192:7): [True: 26, False: 918]
  |  |  |  |  ------------------
  |  |  ------------------
  |  |                    (ISA_UNRESERVED(p) || ISA_PCT_ENCODED(p) || ISA_SUB_DELIM(p) ||	\
  |  |  ------------------
  |  |  |  |  163|  5.23k|      (((*(p) == '!')) || ((*(p) == '$')) || ((*(p) == '&')) ||		\
  |  |  |  |  ------------------
  |  |  |  |  |  Branch (163:8): [True: 13, False: 917]
  |  |  |  |  |  Branch (163:27): [True: 16, False: 901]
  |  |  |  |  |  Branch (163:46): [True: 50, False: 851]
  |  |  |  |  ------------------
  |  |  |  |  164|    930|       ((*(p) == '(')) || ((*(p) == ')')) || ((*(p) == '*')) ||		\
  |  |  |  |  ------------------
  |  |  |  |  |  Branch (164:8): [True: 68, False: 783]
  |  |  |  |  |  Branch (164:27): [True: 6, False: 777]
  |  |  |  |  |  Branch (164:46): [True: 20, False: 757]
  |  |  |  |  ------------------
  |  |  |  |  165|    930|       ((*(p) == '+')) || ((*(p) == ',')) || ((*(p) == ';')) ||		\
  |  |  |  |  ------------------
  |  |  |  |  |  Branch (165:8): [True: 18, False: 739]
  |  |  |  |  |  Branch (165:27): [True: 11, False: 728]
  |  |  |  |  |  Branch (165:46): [True: 11, False: 717]
  |  |  |  |  ------------------
  |  |  |  |  166|    930|       ((*(p) == '=')) || ((*(p) == '\'')))
  |  |  |  |  ------------------
  |  |  |  |  |  Branch (166:8): [True: 15, False: 702]
  |  |  |  |  |  Branch (166:27): [True: 36, False: 666]
  |  |  |  |  ------------------
  |  |  ------------------
  |  |  199|  4.30k|      ((*(p) == ':')) || ((*(p) == '@')))
  |  |  ------------------
  |  |  |  Branch (199:7): [True: 361, False: 305]
  |  |  |  Branch (199:26): [True: 11, False: 294]
  |  |  ------------------
  ------------------
  568|    294|        if (empty)
  ------------------
  |  Branch (568:13): [True: 276, False: 18]
  ------------------
  569|    276|	    return(0);
  570|     18|	return(1);
  571|    294|    }
  572|  16.9k|    while (ISA_PCHAR(cur) && (*cur != forbid))
  ------------------
  |  |  198|  33.9k|     (ISA_UNRESERVED(p) || ISA_PCT_ENCODED(p) || ISA_SUB_DELIM(p) ||	\
  |  |  ------------------
  |  |  |  |  185|  33.9k|      ((ISA_ALPHA(p)) || (ISA_DIGIT(p)) || ((*(p) == '-')) ||		\
  |  |  |  |  ------------------
  |  |  |  |  |  |  152|  16.9k|#define ISA_ALPHA(p) (((*(p) >= 'a') && (*(p) <= 'z')) ||		\
  |  |  |  |  |  |  ------------------
  |  |  |  |  |  |  |  Branch (152:24): [True: 7.52k, False: 9.46k]
  |  |  |  |  |  |  |  Branch (152:41): [True: 7.44k, False: 80]
  |  |  |  |  |  |  ------------------
  |  |  |  |  |  |  153|  16.9k|                      ((*(p) >= 'A') && (*(p) <= 'Z')))
  |  |  |  |  |  |  ------------------
  |  |  |  |  |  |  |  Branch (153:24): [True: 572, False: 8.97k]
  |  |  |  |  |  |  |  Branch (153:41): [True: 450, False: 122]
  |  |  |  |  |  |  ------------------
  |  |  |  |  ------------------
  |  |  |  |                     ((ISA_ALPHA(p)) || (ISA_DIGIT(p)) || ((*(p) == '-')) ||		\
  |  |  |  |  ------------------
  |  |  |  |  |  |  151|  9.09k|#define ISA_DIGIT(p) ((*(p) >= '0') && (*(p) <= '9'))
  |  |  |  |  |  |  ------------------
  |  |  |  |  |  |  |  Branch (151:23): [True: 4.07k, False: 5.02k]
  |  |  |  |  |  |  |  Branch (151:40): [True: 1.61k, False: 2.46k]
  |  |  |  |  |  |  ------------------
  |  |  |  |  ------------------
  |  |  |  |  |  Branch (185:44): [True: 38, False: 7.44k]
  |  |  |  |  ------------------
  |  |  |  |  186|  16.9k|       ((*(p) == '.')) || ((*(p) == '_')) || ((*(p) == '~')))
  |  |  |  |  ------------------
  |  |  |  |  |  Branch (186:8): [True: 953, False: 6.49k]
  |  |  |  |  |  Branch (186:27): [True: 5, False: 6.49k]
  |  |  |  |  |  Branch (186:46): [True: 69, False: 6.42k]
  |  |  |  |  ------------------
  |  |  ------------------
  |  |                    (ISA_UNRESERVED(p) || ISA_PCT_ENCODED(p) || ISA_SUB_DELIM(p) ||	\
  |  |  ------------------
  |  |  |  |  192|  23.4k|     ((*(p) == '%') && (ISA_HEXDIG(p + 1)) && (ISA_HEXDIG(p + 2)))
  |  |  |  |  ------------------
  |  |  |  |  |  |  155|    103|       (ISA_DIGIT(p) || ((*(p) >= 'a') && (*(p) <= 'f')) ||		\
  |  |  |  |  |  |  ------------------
  |  |  |  |  |  |  |  |  151|    206|#define ISA_DIGIT(p) ((*(p) >= '0') && (*(p) <= '9'))
  |  |  |  |  |  |  |  |  ------------------
  |  |  |  |  |  |  |  |  |  Branch (151:23): [True: 97, False: 6]
  |  |  |  |  |  |  |  |  |  Branch (151:40): [True: 36, False: 61]
  |  |  |  |  |  |  |  |  ------------------
  |  |  |  |  |  |  ------------------
  |  |  |  |  |  |  |  Branch (155:26): [True: 1, False: 66]
  |  |  |  |  |  |  |  Branch (155:43): [True: 1, False: 0]
  |  |  |  |  |  |  ------------------
  |  |  |  |  |  |  156|    103|        ((*(p) >= 'A') && (*(p) <= 'F')))
  |  |  |  |  |  |  ------------------
  |  |  |  |  |  |  |  Branch (156:10): [True: 60, False: 6]
  |  |  |  |  |  |  |  Branch (156:27): [True: 60, False: 0]
  |  |  |  |  |  |  ------------------
  |  |  |  |  ------------------
  |  |  |  |                    ((*(p) == '%') && (ISA_HEXDIG(p + 1)) && (ISA_HEXDIG(p + 2)))
  |  |  |  |  ------------------
  |  |  |  |  |  |  155|     97|       (ISA_DIGIT(p) || ((*(p) >= 'a') && (*(p) <= 'f')) ||		\
  |  |  |  |  |  |  ------------------
  |  |  |  |  |  |  |  |  151|    194|#define ISA_DIGIT(p) ((*(p) >= '0') && (*(p) <= '9'))
  |  |  |  |  |  |  |  |  ------------------
  |  |  |  |  |  |  |  |  |  Branch (151:23): [True: 96, False: 1]
  |  |  |  |  |  |  |  |  |  Branch (151:40): [True: 38, False: 58]
  |  |  |  |  |  |  |  |  ------------------
  |  |  |  |  |  |  ------------------
  |  |  |  |  |  |  |  Branch (155:26): [True: 0, False: 59]
  |  |  |  |  |  |  |  Branch (155:43): [True: 0, False: 0]
  |  |  |  |  |  |  ------------------
  |  |  |  |  |  |  156|     97|        ((*(p) >= 'A') && (*(p) <= 'F')))
  |  |  |  |  |  |  ------------------
  |  |  |  |  |  |  |  Branch (156:10): [True: 58, False: 1]
  |  |  |  |  |  |  |  Branch (156:27): [True: 58, False: 0]
  |  |  |  |  |  |  ------------------
  |  |  |  |  ------------------
  |  |  |  |  |  Branch (192:7): [True: 103, False: 6.31k]
  |  |  |  |  ------------------
  |  |  ------------------
  |  |                    (ISA_UNRESERVED(p) || ISA_PCT_ENCODED(p) || ISA_SUB_DELIM(p) ||	\
  |  |  ------------------
  |  |  |  |  163|  23.3k|      (((*(p) == '!')) || ((*(p) == '$')) || ((*(p) == '&')) ||		\
  |  |  |  |  ------------------
  |  |  |  |  |  Branch (163:8): [True: 67, False: 6.25k]
  |  |  |  |  |  Branch (163:27): [True: 21, False: 6.23k]
  |  |  |  |  |  Branch (163:46): [True: 563, False: 5.67k]
  |  |  |  |  ------------------
  |  |  |  |  164|  6.32k|       ((*(p) == '(')) || ((*(p) == ')')) || ((*(p) == '*')) ||		\
  |  |  |  |  ------------------
  |  |  |  |  |  Branch (164:8): [True: 119, False: 5.55k]
  |  |  |  |  |  Branch (164:27): [True: 11, False: 5.54k]
  |  |  |  |  |  Branch (164:46): [True: 42, False: 5.50k]
  |  |  |  |  ------------------
  |  |  |  |  165|  6.32k|       ((*(p) == '+')) || ((*(p) == ',')) || ((*(p) == ';')) ||		\
  |  |  |  |  ------------------
  |  |  |  |  |  Branch (165:8): [True: 52, False: 5.45k]
  |  |  |  |  |  Branch (165:27): [True: 34, False: 5.41k]
  |  |  |  |  |  Branch (165:46): [True: 41, False: 5.37k]
  |  |  |  |  ------------------
  |  |  |  |  166|  6.32k|       ((*(p) == '=')) || ((*(p) == '\'')))
  |  |  |  |  ------------------
  |  |  |  |  |  Branch (166:8): [True: 147, False: 5.22k]
  |  |  |  |  |  Branch (166:27): [True: 206, False: 5.02k]
  |  |  |  |  ------------------
  |  |  ------------------
  |  |  199|  16.9k|      ((*(p) == ':')) || ((*(p) == '@')))
  |  |  ------------------
  |  |  |  Branch (199:7): [True: 1.56k, False: 3.45k]
  |  |  |  Branch (199:26): [True: 162, False: 3.29k]
  |  |  ------------------
  ------------------
  |  Branch (572:30): [True: 12.9k, False: 711]
  ------------------
  573|  12.9k|        NEXT(cur);
  ------------------
  |  |  131|  16.9k|#define NEXT(p) ((*p == '%')? p += 3 : p++)
  |  |  ------------------
  |  |  |  Branch (131:18): [True: 96, False: 12.8k]
  |  |  ------------------
  ------------------
  574|  4.00k|    *str = cur;
  575|  4.00k|    return (0);
  576|  4.30k|}
uri.c:xmlParse3986PathAbsolute:
  632|    215|{
  633|    215|    const char *cur;
  634|    215|    int ret;
  635|       |
  636|    215|    cur = *str;
  637|       |
  638|    215|    if (*cur != '/')
  ------------------
  |  Branch (638:9): [True: 0, False: 215]
  ------------------
  639|      0|        return(1);
  640|    215|    cur++;
  641|    215|    ret = xmlParse3986Segment(&cur, 0, 0);
  642|    215|    if (ret == 0) {
  ------------------
  |  Branch (642:9): [True: 197, False: 18]
  ------------------
  643|    713|	while (*cur == '/') {
  ------------------
  |  Branch (643:9): [True: 516, False: 197]
  ------------------
  644|    516|	    cur++;
  645|    516|	    ret = xmlParse3986Segment(&cur, 0, 1);
  646|    516|	    if (ret != 0) return(ret);
  ------------------
  |  Branch (646:10): [True: 0, False: 516]
  ------------------
  647|    516|	}
  648|    197|    }
  649|    215|    if (uri != NULL) {
  ------------------
  |  Branch (649:9): [True: 215, False: 0]
  ------------------
  650|    215|	if (uri->path != NULL) xmlFree(uri->path);
  ------------------
  |  Branch (650:6): [True: 0, False: 215]
  ------------------
  651|    215|        if (cur != *str) {
  ------------------
  |  Branch (651:13): [True: 215, False: 0]
  ------------------
  652|    215|            if (uri->cleanup & 2)
  ------------------
  |  Branch (652:17): [True: 43, False: 172]
  ------------------
  653|     43|                uri->path = STRNDUP(*str, cur - *str);
  ------------------
  |  |  143|     43|#define STRNDUP(s, n) (char *) xmlStrndup((const xmlChar *)(s), (n))
  ------------------
  654|    172|            else
  655|    172|                uri->path = xmlURIUnescapeString(*str, cur - *str, NULL);
  656|    215|        } else {
  657|      0|            uri->path = NULL;
  658|      0|        }
  659|    215|    }
  660|    215|    *str = cur;
  661|    215|    return (0);
  662|    215|}
uri.c:xmlParse3986PathRootless:
  678|    154|{
  679|    154|    const char *cur;
  680|    154|    int ret;
  681|       |
  682|    154|    cur = *str;
  683|       |
  684|    154|    ret = xmlParse3986Segment(&cur, 0, 0);
  685|    154|    if (ret != 0) return(ret);
  ------------------
  |  Branch (685:9): [True: 0, False: 154]
  ------------------
  686|    514|    while (*cur == '/') {
  ------------------
  |  Branch (686:12): [True: 360, False: 154]
  ------------------
  687|    360|        cur++;
  688|    360|	ret = xmlParse3986Segment(&cur, 0, 1);
  689|    360|	if (ret != 0) return(ret);
  ------------------
  |  Branch (689:6): [True: 0, False: 360]
  ------------------
  690|    360|    }
  691|    154|    if (uri != NULL) {
  ------------------
  |  Branch (691:9): [True: 154, False: 0]
  ------------------
  692|    154|	if (uri->path != NULL) xmlFree(uri->path);
  ------------------
  |  Branch (692:6): [True: 0, False: 154]
  ------------------
  693|    154|        if (cur != *str) {
  ------------------
  |  Branch (693:13): [True: 154, False: 0]
  ------------------
  694|    154|            if (uri->cleanup & 2)
  ------------------
  |  Branch (694:17): [True: 33, False: 121]
  ------------------
  695|     33|                uri->path = STRNDUP(*str, cur - *str);
  ------------------
  |  |  143|     33|#define STRNDUP(s, n) (char *) xmlStrndup((const xmlChar *)(s), (n))
  ------------------
  696|    121|            else
  697|    121|                uri->path = xmlURIUnescapeString(*str, cur - *str, NULL);
  698|    154|        } else {
  699|      0|            uri->path = NULL;
  700|      0|        }
  701|    154|    }
  702|    154|    *str = cur;
  703|    154|    return (0);
  704|    154|}
uri.c:xmlParse3986Query:
  287|    499|{
  288|    499|    const char *cur;
  289|       |
  290|    499|    if (str == NULL)
  ------------------
  |  Branch (290:9): [True: 0, False: 499]
  ------------------
  291|      0|        return (-1);
  292|       |
  293|    499|    cur = *str;
  294|       |
  295|  2.49k|    while ((ISA_PCHAR(cur)) || (*cur == '/') || (*cur == '?') ||
  ------------------
  |  |  198|  2.49k|     (ISA_UNRESERVED(p) || ISA_PCT_ENCODED(p) || ISA_SUB_DELIM(p) ||	\
  |  |  ------------------
  |  |  |  |  185|  4.99k|      ((ISA_ALPHA(p)) || (ISA_DIGIT(p)) || ((*(p) == '-')) ||		\
  |  |  |  |  ------------------
  |  |  |  |  |  |  152|  2.49k|#define ISA_ALPHA(p) (((*(p) >= 'a') && (*(p) <= 'z')) ||		\
  |  |  |  |  |  |  ------------------
  |  |  |  |  |  |  |  Branch (152:24): [True: 929, False: 1.56k]
  |  |  |  |  |  |  |  Branch (152:41): [True: 924, False: 5]
  |  |  |  |  |  |  ------------------
  |  |  |  |  |  |  153|  2.49k|                      ((*(p) >= 'A') && (*(p) <= 'Z')))
  |  |  |  |  |  |  ------------------
  |  |  |  |  |  |  |  Branch (153:24): [True: 43, False: 1.53k]
  |  |  |  |  |  |  |  Branch (153:41): [True: 9, False: 34]
  |  |  |  |  |  |  ------------------
  |  |  |  |  ------------------
  |  |  |  |                     ((ISA_ALPHA(p)) || (ISA_DIGIT(p)) || ((*(p) == '-')) ||		\
  |  |  |  |  ------------------
  |  |  |  |  |  |  151|  1.56k|#define ISA_DIGIT(p) ((*(p) >= '0') && (*(p) <= '9'))
  |  |  |  |  |  |  ------------------
  |  |  |  |  |  |  |  Branch (151:23): [True: 555, False: 1.01k]
  |  |  |  |  |  |  |  Branch (151:40): [True: 84, False: 471]
  |  |  |  |  |  |  ------------------
  |  |  |  |  ------------------
  |  |  |  |  |  Branch (185:44): [True: 35, False: 1.44k]
  |  |  |  |  ------------------
  |  |  |  |  186|  2.49k|       ((*(p) == '.')) || ((*(p) == '_')) || ((*(p) == '~')))
  |  |  |  |  ------------------
  |  |  |  |  |  Branch (186:8): [True: 148, False: 1.29k]
  |  |  |  |  |  Branch (186:27): [True: 5, False: 1.29k]
  |  |  |  |  |  Branch (186:46): [True: 5, False: 1.28k]
  |  |  |  |  ------------------
  |  |  ------------------
  |  |                    (ISA_UNRESERVED(p) || ISA_PCT_ENCODED(p) || ISA_SUB_DELIM(p) ||	\
  |  |  ------------------
  |  |  |  |  192|  3.78k|     ((*(p) == '%') && (ISA_HEXDIG(p + 1)) && (ISA_HEXDIG(p + 2)))
  |  |  |  |  ------------------
  |  |  |  |  |  |  155|     10|       (ISA_DIGIT(p) || ((*(p) >= 'a') && (*(p) <= 'f')) ||		\
  |  |  |  |  |  |  ------------------
  |  |  |  |  |  |  |  |  151|     20|#define ISA_DIGIT(p) ((*(p) >= '0') && (*(p) <= '9'))
  |  |  |  |  |  |  |  |  ------------------
  |  |  |  |  |  |  |  |  |  Branch (151:23): [True: 10, False: 0]
  |  |  |  |  |  |  |  |  |  Branch (151:40): [True: 6, False: 4]
  |  |  |  |  |  |  |  |  ------------------
  |  |  |  |  |  |  ------------------
  |  |  |  |  |  |  |  Branch (155:26): [True: 0, False: 4]
  |  |  |  |  |  |  |  Branch (155:43): [True: 0, False: 0]
  |  |  |  |  |  |  ------------------
  |  |  |  |  |  |  156|     10|        ((*(p) >= 'A') && (*(p) <= 'F')))
  |  |  |  |  |  |  ------------------
  |  |  |  |  |  |  |  Branch (156:10): [True: 4, False: 0]
  |  |  |  |  |  |  |  Branch (156:27): [True: 4, False: 0]
  |  |  |  |  |  |  ------------------
  |  |  |  |  ------------------
  |  |  |  |                    ((*(p) == '%') && (ISA_HEXDIG(p + 1)) && (ISA_HEXDIG(p + 2)))
  |  |  |  |  ------------------
  |  |  |  |  |  |  155|     10|       (ISA_DIGIT(p) || ((*(p) >= 'a') && (*(p) <= 'f')) ||		\
  |  |  |  |  |  |  ------------------
  |  |  |  |  |  |  |  |  151|     20|#define ISA_DIGIT(p) ((*(p) >= '0') && (*(p) <= '9'))
  |  |  |  |  |  |  |  |  ------------------
  |  |  |  |  |  |  |  |  |  Branch (151:23): [True: 10, False: 0]
  |  |  |  |  |  |  |  |  |  Branch (151:40): [True: 4, False: 6]
  |  |  |  |  |  |  |  |  ------------------
  |  |  |  |  |  |  ------------------
  |  |  |  |  |  |  |  Branch (155:26): [True: 0, False: 6]
  |  |  |  |  |  |  |  Branch (155:43): [True: 0, False: 0]
  |  |  |  |  |  |  ------------------
  |  |  |  |  |  |  156|     10|        ((*(p) >= 'A') && (*(p) <= 'F')))
  |  |  |  |  |  |  ------------------
  |  |  |  |  |  |  |  Branch (156:10): [True: 6, False: 0]
  |  |  |  |  |  |  |  Branch (156:27): [True: 6, False: 0]
  |  |  |  |  |  |  ------------------
  |  |  |  |  ------------------
  |  |  |  |  |  Branch (192:7): [True: 10, False: 1.27k]
  |  |  |  |  ------------------
  |  |  ------------------
  |  |                    (ISA_UNRESERVED(p) || ISA_PCT_ENCODED(p) || ISA_SUB_DELIM(p) ||	\
  |  |  ------------------
  |  |  |  |  163|  3.77k|      (((*(p) == '!')) || ((*(p) == '$')) || ((*(p) == '&')) ||		\
  |  |  |  |  ------------------
  |  |  |  |  |  Branch (163:8): [True: 0, False: 1.27k]
  |  |  |  |  |  Branch (163:27): [True: 5, False: 1.27k]
  |  |  |  |  |  Branch (163:46): [True: 5, False: 1.26k]
  |  |  |  |  ------------------
  |  |  |  |  164|  1.27k|       ((*(p) == '(')) || ((*(p) == ')')) || ((*(p) == '*')) ||		\
  |  |  |  |  ------------------
  |  |  |  |  |  Branch (164:8): [True: 6, False: 1.26k]
  |  |  |  |  |  Branch (164:27): [True: 6, False: 1.25k]
  |  |  |  |  |  Branch (164:46): [True: 5, False: 1.25k]
  |  |  |  |  ------------------
  |  |  |  |  165|  1.27k|       ((*(p) == '+')) || ((*(p) == ',')) || ((*(p) == ';')) ||		\
  |  |  |  |  ------------------
  |  |  |  |  |  Branch (165:8): [True: 0, False: 1.25k]
  |  |  |  |  |  Branch (165:27): [True: 0, False: 1.25k]
  |  |  |  |  |  Branch (165:46): [True: 5, False: 1.24k]
  |  |  |  |  ------------------
  |  |  |  |  166|  1.27k|       ((*(p) == '=')) || ((*(p) == '\'')))
  |  |  |  |  ------------------
  |  |  |  |  |  Branch (166:8): [True: 267, False: 979]
  |  |  |  |  |  Branch (166:27): [True: 22, False: 957]
  |  |  |  |  ------------------
  |  |  ------------------
  |  |  199|  2.49k|      ((*(p) == ':')) || ((*(p) == '@')))
  |  |  ------------------
  |  |  |  Branch (199:7): [True: 107, False: 850]
  |  |  |  Branch (199:26): [True: 5, False: 845]
  |  |  ------------------
  ------------------
  |  Branch (295:32): [True: 295, False: 550]
  |  Branch (295:49): [True: 47, False: 503]
  ------------------
  296|  2.49k|           ((uri != NULL) && (uri->cleanup & 1) && (IS_UNWISE(cur))))
  ------------------
  |  |  108|     93|      (((*(p) == '{')) || ((*(p) == '}')) || ((*(p) == '|')) ||         \
  |  |  ------------------
  |  |  |  Branch (108:8): [True: 0, False: 93]
  |  |  |  Branch (108:27): [True: 0, False: 93]
  |  |  |  Branch (108:46): [True: 0, False: 93]
  |  |  ------------------
  |  |  109|     93|       ((*(p) == '\\')) || ((*(p) == '^')) || ((*(p) == '[')) ||        \
  |  |  ------------------
  |  |  |  Branch (109:8): [True: 0, False: 93]
  |  |  |  Branch (109:28): [True: 0, False: 93]
  |  |  |  Branch (109:47): [True: 1, False: 92]
  |  |  ------------------
  |  |  110|     93|       ((*(p) == ']')) || ((*(p) == '`')))
  |  |  ------------------
  |  |  |  Branch (110:8): [True: 1, False: 91]
  |  |  |  Branch (110:27): [True: 2, False: 89]
  |  |  ------------------
  ------------------
  |  Branch (296:13): [True: 503, False: 0]
  |  Branch (296:30): [True: 93, False: 410]
  ------------------
  297|  1.99k|        NEXT(cur);
  ------------------
  |  |  131|  2.49k|#define NEXT(p) ((*p == '%')? p += 3 : p++)
  |  |  ------------------
  |  |  |  Branch (131:18): [True: 10, False: 1.98k]
  |  |  ------------------
  ------------------
  298|    499|    if (uri != NULL) {
  ------------------
  |  Branch (298:9): [True: 499, False: 0]
  ------------------
  299|    499|        if (uri->query != NULL)
  ------------------
  |  Branch (299:13): [True: 0, False: 499]
  ------------------
  300|      0|            xmlFree(uri->query);
  301|    499|	if (uri->cleanup & 2)
  ------------------
  |  Branch (301:6): [True: 96, False: 403]
  ------------------
  302|     96|	    uri->query = STRNDUP(*str, cur - *str);
  ------------------
  |  |  143|     96|#define STRNDUP(s, n) (char *) xmlStrndup((const xmlChar *)(s), (n))
  ------------------
  303|    403|	else
  304|    403|	    uri->query = xmlURIUnescapeString(*str, cur - *str, NULL);
  305|       |
  306|       |	/* Save the raw bytes of the query as well.
  307|       |	 * See: http://mail.gnome.org/archives/xml/2007-April/thread.html#00114
  308|       |	 */
  309|    499|	if (uri->query_raw != NULL)
  ------------------
  |  Branch (309:6): [True: 0, False: 499]
  ------------------
  310|      0|	    xmlFree (uri->query_raw);
  311|    499|	uri->query_raw = STRNDUP (*str, cur - *str);
  ------------------
  |  |  143|    499|#define STRNDUP(s, n) (char *) xmlStrndup((const xmlChar *)(s), (n))
  ------------------
  312|    499|    }
  313|    499|    *str = cur;
  314|    499|    return (0);
  315|    499|}
uri.c:xmlParse3986Fragment:
  250|    494|{
  251|    494|    const char *cur;
  252|       |
  253|    494|    if (str == NULL)
  ------------------
  |  Branch (253:9): [True: 0, False: 494]
  ------------------
  254|      0|        return (-1);
  255|       |
  256|    494|    cur = *str;
  257|       |
  258|  2.51k|    while ((ISA_PCHAR(cur)) || (*cur == '/') || (*cur == '?') ||
  ------------------
  |  |  198|  2.51k|     (ISA_UNRESERVED(p) || ISA_PCT_ENCODED(p) || ISA_SUB_DELIM(p) ||	\
  |  |  ------------------
  |  |  |  |  185|  5.03k|      ((ISA_ALPHA(p)) || (ISA_DIGIT(p)) || ((*(p) == '-')) ||		\
  |  |  |  |  ------------------
  |  |  |  |  |  |  152|  2.51k|#define ISA_ALPHA(p) (((*(p) >= 'a') && (*(p) <= 'z')) ||		\
  |  |  |  |  |  |  ------------------
  |  |  |  |  |  |  |  Branch (152:24): [True: 1.14k, False: 1.37k]
  |  |  |  |  |  |  |  Branch (152:41): [True: 1.12k, False: 23]
  |  |  |  |  |  |  ------------------
  |  |  |  |  |  |  153|  2.51k|                      ((*(p) >= 'A') && (*(p) <= 'Z')))
  |  |  |  |  |  |  ------------------
  |  |  |  |  |  |  |  Branch (153:24): [True: 53, False: 1.34k]
  |  |  |  |  |  |  |  Branch (153:41): [True: 24, False: 29]
  |  |  |  |  |  |  ------------------
  |  |  |  |  ------------------
  |  |  |  |                     ((ISA_ALPHA(p)) || (ISA_DIGIT(p)) || ((*(p) == '-')) ||		\
  |  |  |  |  ------------------
  |  |  |  |  |  |  151|  1.37k|#define ISA_DIGIT(p) ((*(p) >= '0') && (*(p) <= '9'))
  |  |  |  |  |  |  ------------------
  |  |  |  |  |  |  |  Branch (151:23): [True: 543, False: 828]
  |  |  |  |  |  |  |  Branch (151:40): [True: 83, False: 460]
  |  |  |  |  |  |  ------------------
  |  |  |  |  ------------------
  |  |  |  |  |  Branch (185:44): [True: 5, False: 1.28k]
  |  |  |  |  ------------------
  |  |  |  |  186|  2.51k|       ((*(p) == '.')) || ((*(p) == '_')) || ((*(p) == '~')))
  |  |  |  |  ------------------
  |  |  |  |  |  Branch (186:8): [True: 105, False: 1.17k]
  |  |  |  |  |  Branch (186:27): [True: 0, False: 1.17k]
  |  |  |  |  |  Branch (186:46): [True: 23, False: 1.15k]
  |  |  |  |  ------------------
  |  |  ------------------
  |  |                    (ISA_UNRESERVED(p) || ISA_PCT_ENCODED(p) || ISA_SUB_DELIM(p) ||	\
  |  |  ------------------
  |  |  |  |  192|  3.67k|     ((*(p) == '%') && (ISA_HEXDIG(p + 1)) && (ISA_HEXDIG(p + 2)))
  |  |  |  |  ------------------
  |  |  |  |  |  |  155|      0|       (ISA_DIGIT(p) || ((*(p) >= 'a') && (*(p) <= 'f')) ||		\
  |  |  |  |  |  |  ------------------
  |  |  |  |  |  |  |  |  151|      0|#define ISA_DIGIT(p) ((*(p) >= '0') && (*(p) <= '9'))
  |  |  |  |  |  |  |  |  ------------------
  |  |  |  |  |  |  |  |  |  Branch (151:23): [True: 0, False: 0]
  |  |  |  |  |  |  |  |  |  Branch (151:40): [True: 0, False: 0]
  |  |  |  |  |  |  |  |  ------------------
  |  |  |  |  |  |  ------------------
  |  |  |  |  |  |  |  Branch (155:26): [True: 0, False: 0]
  |  |  |  |  |  |  |  Branch (155:43): [True: 0, False: 0]
  |  |  |  |  |  |  ------------------
  |  |  |  |  |  |  156|      0|        ((*(p) >= 'A') && (*(p) <= 'F')))
  |  |  |  |  |  |  ------------------
  |  |  |  |  |  |  |  Branch (156:10): [True: 0, False: 0]
  |  |  |  |  |  |  |  Branch (156:27): [True: 0, False: 0]
  |  |  |  |  |  |  ------------------
  |  |  |  |  ------------------
  |  |  |  |                    ((*(p) == '%') && (ISA_HEXDIG(p + 1)) && (ISA_HEXDIG(p + 2)))
  |  |  |  |  ------------------
  |  |  |  |  |  |  155|      0|       (ISA_DIGIT(p) || ((*(p) >= 'a') && (*(p) <= 'f')) ||		\
  |  |  |  |  |  |  ------------------
  |  |  |  |  |  |  |  |  151|      0|#define ISA_DIGIT(p) ((*(p) >= '0') && (*(p) <= '9'))
  |  |  |  |  |  |  |  |  ------------------
  |  |  |  |  |  |  |  |  |  Branch (151:23): [True: 0, False: 0]
  |  |  |  |  |  |  |  |  |  Branch (151:40): [True: 0, False: 0]
  |  |  |  |  |  |  |  |  ------------------
  |  |  |  |  |  |  ------------------
  |  |  |  |  |  |  |  Branch (155:26): [True: 0, False: 0]
  |  |  |  |  |  |  |  Branch (155:43): [True: 0, False: 0]
  |  |  |  |  |  |  ------------------
  |  |  |  |  |  |  156|      0|        ((*(p) >= 'A') && (*(p) <= 'F')))
  |  |  |  |  |  |  ------------------
  |  |  |  |  |  |  |  Branch (156:10): [True: 0, False: 0]
  |  |  |  |  |  |  |  Branch (156:27): [True: 0, False: 0]
  |  |  |  |  |  |  ------------------
  |  |  |  |  ------------------
  |  |  |  |  |  Branch (192:7): [True: 0, False: 1.15k]
  |  |  |  |  ------------------
  |  |  ------------------
  |  |                    (ISA_UNRESERVED(p) || ISA_PCT_ENCODED(p) || ISA_SUB_DELIM(p) ||	\
  |  |  ------------------
  |  |  |  |  163|  3.67k|      (((*(p) == '!')) || ((*(p) == '$')) || ((*(p) == '&')) ||		\
  |  |  |  |  ------------------
  |  |  |  |  |  Branch (163:8): [True: 11, False: 1.14k]
  |  |  |  |  |  Branch (163:27): [True: 0, False: 1.14k]
  |  |  |  |  |  Branch (163:46): [True: 4, False: 1.14k]
  |  |  |  |  ------------------
  |  |  |  |  164|  1.15k|       ((*(p) == '(')) || ((*(p) == ')')) || ((*(p) == '*')) ||		\
  |  |  |  |  ------------------
  |  |  |  |  |  Branch (164:8): [True: 22, False: 1.11k]
  |  |  |  |  |  Branch (164:27): [True: 0, False: 1.11k]
  |  |  |  |  |  Branch (164:46): [True: 6, False: 1.11k]
  |  |  |  |  ------------------
  |  |  |  |  165|  1.15k|       ((*(p) == '+')) || ((*(p) == ',')) || ((*(p) == ';')) ||		\
  |  |  |  |  ------------------
  |  |  |  |  |  Branch (165:8): [True: 0, False: 1.11k]
  |  |  |  |  |  Branch (165:27): [True: 5, False: 1.10k]
  |  |  |  |  |  Branch (165:46): [True: 10, False: 1.09k]
  |  |  |  |  ------------------
  |  |  |  |  166|  1.15k|       ((*(p) == '=')) || ((*(p) == '\'')))
  |  |  |  |  ------------------
  |  |  |  |  |  Branch (166:8): [True: 128, False: 969]
  |  |  |  |  |  Branch (166:27): [True: 11, False: 958]
  |  |  |  |  ------------------
  |  |  ------------------
  |  |  199|  2.51k|      ((*(p) == ':')) || ((*(p) == '@')))
  |  |  ------------------
  |  |  |  Branch (199:7): [True: 81, False: 877]
  |  |  |  Branch (199:26): [True: 59, False: 818]
  |  |  ------------------
  ------------------
  |  Branch (258:32): [True: 170, False: 648]
  |  Branch (258:49): [True: 153, False: 495]
  ------------------
  259|  2.51k|           (*cur == '[') || (*cur == ']') ||
  ------------------
  |  Branch (259:12): [True: 0, False: 495]
  |  Branch (259:29): [True: 0, False: 495]
  ------------------
  260|  2.51k|           ((uri != NULL) && (uri->cleanup & 1) && (IS_UNWISE(cur))))
  ------------------
  |  |  108|     97|      (((*(p) == '{')) || ((*(p) == '}')) || ((*(p) == '|')) ||         \
  |  |  ------------------
  |  |  |  Branch (108:8): [True: 0, False: 97]
  |  |  |  Branch (108:27): [True: 0, False: 97]
  |  |  |  Branch (108:46): [True: 0, False: 97]
  |  |  ------------------
  |  |  109|     97|       ((*(p) == '\\')) || ((*(p) == '^')) || ((*(p) == '[')) ||        \
  |  |  ------------------
  |  |  |  Branch (109:8): [True: 0, False: 97]
  |  |  |  Branch (109:28): [True: 0, False: 97]
  |  |  |  Branch (109:47): [True: 0, False: 97]
  |  |  ------------------
  |  |  110|     97|       ((*(p) == ']')) || ((*(p) == '`')))
  |  |  ------------------
  |  |  |  Branch (110:8): [True: 0, False: 97]
  |  |  |  Branch (110:27): [True: 1, False: 96]
  |  |  ------------------
  ------------------
  |  Branch (260:13): [True: 495, False: 0]
  |  Branch (260:30): [True: 97, False: 398]
  ------------------
  261|  2.02k|        NEXT(cur);
  ------------------
  |  |  131|  2.51k|#define NEXT(p) ((*p == '%')? p += 3 : p++)
  |  |  ------------------
  |  |  |  Branch (131:18): [True: 0, False: 2.02k]
  |  |  ------------------
  ------------------
  262|    494|    if (uri != NULL) {
  ------------------
  |  Branch (262:9): [True: 494, False: 0]
  ------------------
  263|    494|        if (uri->fragment != NULL)
  ------------------
  |  Branch (263:13): [True: 0, False: 494]
  ------------------
  264|      0|            xmlFree(uri->fragment);
  265|    494|	if (uri->cleanup & 2)
  ------------------
  |  Branch (265:6): [True: 99, False: 395]
  ------------------
  266|     99|	    uri->fragment = STRNDUP(*str, cur - *str);
  ------------------
  |  |  143|     99|#define STRNDUP(s, n) (char *) xmlStrndup((const xmlChar *)(s), (n))
  ------------------
  267|    395|	else
  268|    395|	    uri->fragment = xmlURIUnescapeString(*str, cur - *str, NULL);
  269|    494|    }
  270|    494|    *str = cur;
  271|    494|    return (0);
  272|    494|}
uri.c:xmlParse3986RelativeRef:
  818|  1.81k|xmlParse3986RelativeRef(xmlURIPtr uri, const char *str) {
  819|  1.81k|    int ret;
  820|       |
  821|  1.81k|    if ((*str == '/') && (*(str + 1) == '/')) {
  ------------------
  |  Branch (821:9): [True: 77, False: 1.73k]
  |  Branch (821:26): [True: 22, False: 55]
  ------------------
  822|     22|        str += 2;
  823|     22|	ret = xmlParse3986Authority(uri, &str);
  824|     22|	if (ret != 0) return(ret);
  ------------------
  |  Branch (824:6): [True: 4, False: 18]
  ------------------
  825|     18|	ret = xmlParse3986PathAbEmpty(uri, &str);
  826|     18|	if (ret != 0) return(ret);
  ------------------
  |  Branch (826:6): [True: 0, False: 18]
  ------------------
  827|  1.79k|    } else if (*str == '/') {
  ------------------
  |  Branch (827:16): [True: 55, False: 1.73k]
  ------------------
  828|     55|	ret = xmlParse3986PathAbsolute(uri, &str);
  829|     55|	if (ret != 0) return(ret);
  ------------------
  |  Branch (829:6): [True: 0, False: 55]
  ------------------
  830|  1.73k|    } else if (ISA_PCHAR(str)) {
  ------------------
  |  |  198|  1.73k|     (ISA_UNRESERVED(p) || ISA_PCT_ENCODED(p) || ISA_SUB_DELIM(p) ||	\
  |  |  ------------------
  |  |  |  |  185|  3.47k|      ((ISA_ALPHA(p)) || (ISA_DIGIT(p)) || ((*(p) == '-')) ||		\
  |  |  |  |  ------------------
  |  |  |  |  |  |  152|  1.73k|#define ISA_ALPHA(p) (((*(p) >= 'a') && (*(p) <= 'z')) ||		\
  |  |  |  |  |  |  ------------------
  |  |  |  |  |  |  |  Branch (152:24): [True: 938, False: 801]
  |  |  |  |  |  |  |  Branch (152:41): [True: 908, False: 30]
  |  |  |  |  |  |  ------------------
  |  |  |  |  |  |  153|  1.73k|                      ((*(p) >= 'A') && (*(p) <= 'Z')))
  |  |  |  |  |  |  ------------------
  |  |  |  |  |  |  |  Branch (153:24): [True: 86, False: 745]
  |  |  |  |  |  |  |  Branch (153:41): [True: 26, False: 60]
  |  |  |  |  |  |  ------------------
  |  |  |  |  ------------------
  |  |  |  |                     ((ISA_ALPHA(p)) || (ISA_DIGIT(p)) || ((*(p) == '-')) ||		\
  |  |  |  |  ------------------
  |  |  |  |  |  |  151|    805|#define ISA_DIGIT(p) ((*(p) >= '0') && (*(p) <= '9'))
  |  |  |  |  |  |  ------------------
  |  |  |  |  |  |  |  Branch (151:23): [True: 353, False: 452]
  |  |  |  |  |  |  |  Branch (151:40): [True: 245, False: 108]
  |  |  |  |  |  |  ------------------
  |  |  |  |  ------------------
  |  |  |  |  |  Branch (185:44): [True: 6, False: 554]
  |  |  |  |  ------------------
  |  |  |  |  186|  1.73k|       ((*(p) == '.')) || ((*(p) == '_')) || ((*(p) == '~')))
  |  |  |  |  ------------------
  |  |  |  |  |  Branch (186:8): [True: 261, False: 293]
  |  |  |  |  |  Branch (186:27): [True: 0, False: 293]
  |  |  |  |  |  Branch (186:46): [True: 11, False: 282]
  |  |  |  |  ------------------
  |  |  ------------------
  |  |                    (ISA_UNRESERVED(p) || ISA_PCT_ENCODED(p) || ISA_SUB_DELIM(p) ||	\
  |  |  ------------------
  |  |  |  |  192|  2.02k|     ((*(p) == '%') && (ISA_HEXDIG(p + 1)) && (ISA_HEXDIG(p + 2)))
  |  |  |  |  ------------------
  |  |  |  |  |  |  155|     13|       (ISA_DIGIT(p) || ((*(p) >= 'a') && (*(p) <= 'f')) ||		\
  |  |  |  |  |  |  ------------------
  |  |  |  |  |  |  |  |  151|     26|#define ISA_DIGIT(p) ((*(p) >= '0') && (*(p) <= '9'))
  |  |  |  |  |  |  |  |  ------------------
  |  |  |  |  |  |  |  |  |  Branch (151:23): [True: 6, False: 7]
  |  |  |  |  |  |  |  |  |  Branch (151:40): [True: 0, False: 6]
  |  |  |  |  |  |  |  |  ------------------
  |  |  |  |  |  |  ------------------
  |  |  |  |  |  |  |  Branch (155:26): [True: 0, False: 13]
  |  |  |  |  |  |  |  Branch (155:43): [True: 0, False: 0]
  |  |  |  |  |  |  ------------------
  |  |  |  |  |  |  156|     13|        ((*(p) >= 'A') && (*(p) <= 'F')))
  |  |  |  |  |  |  ------------------
  |  |  |  |  |  |  |  Branch (156:10): [True: 0, False: 13]
  |  |  |  |  |  |  |  Branch (156:27): [True: 0, False: 0]
  |  |  |  |  |  |  ------------------
  |  |  |  |  ------------------
  |  |  |  |                    ((*(p) == '%') && (ISA_HEXDIG(p + 1)) && (ISA_HEXDIG(p + 2)))
  |  |  |  |  ------------------
  |  |  |  |  |  |  155|      0|       (ISA_DIGIT(p) || ((*(p) >= 'a') && (*(p) <= 'f')) ||		\
  |  |  |  |  |  |  ------------------
  |  |  |  |  |  |  |  |  151|      0|#define ISA_DIGIT(p) ((*(p) >= '0') && (*(p) <= '9'))
  |  |  |  |  |  |  |  |  ------------------
  |  |  |  |  |  |  |  |  |  Branch (151:23): [True: 0, False: 0]
  |  |  |  |  |  |  |  |  |  Branch (151:40): [True: 0, False: 0]
  |  |  |  |  |  |  |  |  ------------------
  |  |  |  |  |  |  ------------------
  |  |  |  |  |  |  |  Branch (155:26): [True: 0, False: 0]
  |  |  |  |  |  |  |  Branch (155:43): [True: 0, False: 0]
  |  |  |  |  |  |  ------------------
  |  |  |  |  |  |  156|      0|        ((*(p) >= 'A') && (*(p) <= 'F')))
  |  |  |  |  |  |  ------------------
  |  |  |  |  |  |  |  Branch (156:10): [True: 0, False: 0]
  |  |  |  |  |  |  |  Branch (156:27): [True: 0, False: 0]
  |  |  |  |  |  |  ------------------
  |  |  |  |  ------------------
  |  |  |  |  |  Branch (192:7): [True: 13, False: 269]
  |  |  |  |  ------------------
  |  |  ------------------
  |  |                    (ISA_UNRESERVED(p) || ISA_PCT_ENCODED(p) || ISA_SUB_DELIM(p) ||	\
  |  |  ------------------
  |  |  |  |  163|  2.02k|      (((*(p) == '!')) || ((*(p) == '$')) || ((*(p) == '&')) ||		\
  |  |  |  |  ------------------
  |  |  |  |  |  Branch (163:8): [True: 8, False: 274]
  |  |  |  |  |  Branch (163:27): [True: 16, False: 258]
  |  |  |  |  |  Branch (163:46): [True: 39, False: 219]
  |  |  |  |  ------------------
  |  |  |  |  164|    282|       ((*(p) == '(')) || ((*(p) == ')')) || ((*(p) == '*')) ||		\
  |  |  |  |  ------------------
  |  |  |  |  |  Branch (164:8): [True: 15, False: 204]
  |  |  |  |  |  Branch (164:27): [True: 6, False: 198]
  |  |  |  |  |  Branch (164:46): [True: 6, False: 192]
  |  |  |  |  ------------------
  |  |  |  |  165|    282|       ((*(p) == '+')) || ((*(p) == ',')) || ((*(p) == ';')) ||		\
  |  |  |  |  ------------------
  |  |  |  |  |  Branch (165:8): [True: 8, False: 184]
  |  |  |  |  |  Branch (165:27): [True: 6, False: 178]
  |  |  |  |  |  Branch (165:46): [True: 5, False: 173]
  |  |  |  |  ------------------
  |  |  |  |  166|    282|       ((*(p) == '=')) || ((*(p) == '\'')))
  |  |  |  |  ------------------
  |  |  |  |  |  Branch (166:8): [True: 5, False: 168]
  |  |  |  |  |  Branch (166:27): [True: 8, False: 160]
  |  |  |  |  ------------------
  |  |  ------------------
  |  |  199|  1.73k|      ((*(p) == ':')) || ((*(p) == '@')))
  |  |  ------------------
  |  |  |  Branch (199:7): [True: 27, False: 133]
  |  |  |  Branch (199:26): [True: 6, False: 127]
  |  |  ------------------
  ------------------
  831|  1.61k|        ret = xmlParse3986PathNoScheme(uri, &str);
  832|  1.61k|	if (ret != 0) return(ret);
  ------------------
  |  Branch (832:6): [True: 0, False: 1.61k]
  ------------------
  833|  1.61k|    } else {
  834|       |	/* path-empty is effectively empty */
  835|    127|	if (uri != NULL) {
  ------------------
  |  Branch (835:6): [True: 127, False: 0]
  ------------------
  836|    127|	    if (uri->path != NULL) xmlFree(uri->path);
  ------------------
  |  Branch (836:10): [True: 0, False: 127]
  ------------------
  837|    127|	    uri->path = NULL;
  838|    127|	}
  839|    127|    }
  840|       |
  841|  1.81k|    if (*str == '?') {
  ------------------
  |  Branch (841:9): [True: 288, False: 1.52k]
  ------------------
  842|    288|	str++;
  843|    288|	ret = xmlParse3986Query(uri, &str);
  844|    288|	if (ret != 0) return(ret);
  ------------------
  |  Branch (844:6): [True: 0, False: 288]
  ------------------
  845|    288|    }
  846|  1.81k|    if (*str == '#') {
  ------------------
  |  Branch (846:9): [True: 304, False: 1.50k]
  ------------------
  847|    304|	str++;
  848|    304|	ret = xmlParse3986Fragment(uri, &str);
  849|    304|	if (ret != 0) return(ret);
  ------------------
  |  Branch (849:6): [True: 0, False: 304]
  ------------------
  850|    304|    }
  851|  1.81k|    if (*str != 0) {
  ------------------
  |  Branch (851:9): [True: 1.28k, False: 532]
  ------------------
  852|  1.28k|	xmlCleanURI(uri);
  853|  1.28k|	return(1);
  854|  1.28k|    }
  855|    532|    return(0);
  856|  1.81k|}
uri.c:xmlParse3986PathNoScheme:
  720|  1.61k|{
  721|  1.61k|    const char *cur;
  722|  1.61k|    int ret;
  723|       |
  724|  1.61k|    cur = *str;
  725|       |
  726|  1.61k|    ret = xmlParse3986Segment(&cur, ':', 0);
  727|  1.61k|    if (ret != 0) return(ret);
  ------------------
  |  Branch (727:9): [True: 0, False: 1.61k]
  ------------------
  728|  2.76k|    while (*cur == '/') {
  ------------------
  |  Branch (728:12): [True: 1.14k, False: 1.61k]
  ------------------
  729|  1.14k|        cur++;
  730|  1.14k|	ret = xmlParse3986Segment(&cur, 0, 1);
  731|  1.14k|	if (ret != 0) return(ret);
  ------------------
  |  Branch (731:6): [True: 0, False: 1.14k]
  ------------------
  732|  1.14k|    }
  733|  1.61k|    if (uri != NULL) {
  ------------------
  |  Branch (733:9): [True: 1.61k, False: 0]
  ------------------
  734|  1.61k|	if (uri->path != NULL) xmlFree(uri->path);
  ------------------
  |  Branch (734:6): [True: 0, False: 1.61k]
  ------------------
  735|  1.61k|        if (cur != *str) {
  ------------------
  |  Branch (735:13): [True: 1.58k, False: 27]
  ------------------
  736|  1.58k|            if (uri->cleanup & 2)
  ------------------
  |  Branch (736:17): [True: 290, False: 1.29k]
  ------------------
  737|    290|                uri->path = STRNDUP(*str, cur - *str);
  ------------------
  |  |  143|    290|#define STRNDUP(s, n) (char *) xmlStrndup((const xmlChar *)(s), (n))
  ------------------
  738|  1.29k|            else
  739|  1.29k|                uri->path = xmlURIUnescapeString(*str, cur - *str, NULL);
  740|  1.58k|        } else {
  741|     27|            uri->path = NULL;
  742|     27|        }
  743|  1.61k|    }
  744|  1.61k|    *str = cur;
  745|  1.61k|    return (0);
  746|  1.61k|}
uri.c:xmlURIErrMemory:
   42|    661|{
   43|    661|    if (extra)
  ------------------
  |  Branch (43:9): [True: 661, False: 0]
  ------------------
   44|    661|        __xmlRaiseError(NULL, NULL, NULL,
   45|    661|                        NULL, NULL, XML_FROM_URI,
   46|    661|                        XML_ERR_NO_MEMORY, XML_ERR_FATAL, NULL, 0,
   47|    661|                        extra, NULL, NULL, 0, 0,
   48|    661|                        "Memory allocation failed : %s\n", extra);
   49|      0|    else
   50|      0|        __xmlRaiseError(NULL, NULL, NULL,
   51|      0|                        NULL, NULL, XML_FROM_URI,
   52|      0|                        XML_ERR_NO_MEMORY, XML_ERR_FATAL, NULL, 0,
   53|      0|                        NULL, NULL, NULL, 0, 0,
   54|      0|                        "Memory allocation failed\n");
   55|    661|}
uri.c:xmlSaveUriRealloc:
 1047|    150|xmlSaveUriRealloc(xmlChar *ret, int *max) {
 1048|    150|    xmlChar *temp;
 1049|    150|    int tmp;
 1050|       |
 1051|    150|    if (*max > MAX_URI_LENGTH) {
  ------------------
  |  |   35|    150|#define MAX_URI_LENGTH 1024 * 1024
  ------------------
  |  Branch (1051:9): [True: 0, False: 150]
  ------------------
 1052|      0|        xmlURIErrMemory("reaching arbitrary MAX_URI_LENGTH limit\n");
 1053|      0|        return(NULL);
 1054|      0|    }
 1055|    150|    tmp = *max * 2;
 1056|    150|    temp = (xmlChar *) xmlRealloc(ret, (tmp + 1));
 1057|    150|    if (temp == NULL) {
  ------------------
  |  Branch (1057:9): [True: 2, False: 148]
  ------------------
 1058|      2|        xmlURIErrMemory("saving URI\n");
 1059|      2|        return(NULL);
 1060|      2|    }
 1061|    148|    *max = tmp;
 1062|    148|    return(temp);
 1063|    150|}
uri.c:is_hex:
 1606|    368|static int is_hex(char c) {
 1607|    368|    if (((c >= '0') && (c <= '9')) ||
  ------------------
  |  Branch (1607:10): [True: 366, False: 2]
  |  Branch (1607:24): [True: 141, False: 225]
  ------------------
 1608|    368|        ((c >= 'a') && (c <= 'f')) ||
  ------------------
  |  Branch (1608:10): [True: 2, False: 225]
  |  Branch (1608:24): [True: 1, False: 1]
  ------------------
 1609|    368|        ((c >= 'A') && (c <= 'F')))
  ------------------
  |  Branch (1609:10): [True: 224, False: 2]
  |  Branch (1609:24): [True: 223, False: 1]
  ------------------
 1610|    365|	return(1);
 1611|      3|    return(0);
 1612|    368|}

xmlRegisterInputCallbacks:
 2102|      6|	xmlInputCloseCallback closeFunc) {
 2103|      6|    if (xmlInputCallbackNr >= MAX_INPUT_CALLBACK) {
  ------------------
  |  |   85|      6|#define MAX_INPUT_CALLBACK 15
  ------------------
  |  Branch (2103:9): [True: 0, False: 6]
  ------------------
 2104|      0|	return(-1);
 2105|      0|    }
 2106|      6|    xmlInputCallbackTable[xmlInputCallbackNr].matchcallback = matchFunc;
 2107|      6|    xmlInputCallbackTable[xmlInputCallbackNr].opencallback = openFunc;
 2108|      6|    xmlInputCallbackTable[xmlInputCallbackNr].readcallback = readFunc;
 2109|      6|    xmlInputCallbackTable[xmlInputCallbackNr].closecallback = closeFunc;
 2110|      6|    xmlInputCallbackInitialized = 1;
 2111|      6|    return(xmlInputCallbackNr++);
 2112|      6|}
xmlRegisterOutputCallbacks:
 2129|      2|	xmlOutputCloseCallback closeFunc) {
 2130|      2|    if (xmlOutputCallbackNr >= MAX_OUTPUT_CALLBACK) {
  ------------------
  |  |  102|      2|#define MAX_OUTPUT_CALLBACK 15
  ------------------
  |  Branch (2130:9): [True: 0, False: 2]
  ------------------
 2131|      0|	return(-1);
 2132|      0|    }
 2133|      2|    xmlOutputCallbackTable[xmlOutputCallbackNr].matchcallback = matchFunc;
 2134|      2|    xmlOutputCallbackTable[xmlOutputCallbackNr].opencallback = openFunc;
 2135|      2|    xmlOutputCallbackTable[xmlOutputCallbackNr].writecallback = writeFunc;
 2136|      2|    xmlOutputCallbackTable[xmlOutputCallbackNr].closecallback = closeFunc;
 2137|      2|    xmlOutputCallbackInitialized = 1;
 2138|      2|    return(xmlOutputCallbackNr++);
 2139|      2|}
xmlRegisterDefaultInputCallbacks:
 2148|      2|xmlRegisterDefaultInputCallbacks(void) {
 2149|      2|    if (xmlInputCallbackInitialized)
  ------------------
  |  Branch (2149:9): [True: 0, False: 2]
  ------------------
 2150|      0|	return;
 2151|       |
 2152|      2|    xmlRegisterInputCallbacks(xmlFileMatch, xmlFileOpen,
 2153|      2|	                      xmlFileRead, xmlFileClose);
 2154|      2|#ifdef LIBXML_ZLIB_ENABLED
 2155|      2|    xmlRegisterInputCallbacks(xmlGzfileMatch, xmlGzfileOpen,
 2156|      2|	                      xmlGzfileRead, xmlGzfileClose);
 2157|      2|#endif /* LIBXML_ZLIB_ENABLED */
 2158|      2|#ifdef LIBXML_LZMA_ENABLED
 2159|      2|    xmlRegisterInputCallbacks(xmlXzfileMatch, xmlXzfileOpen,
 2160|      2|	                      xmlXzfileRead, xmlXzfileClose);
 2161|      2|#endif /* LIBXML_LZMA_ENABLED */
 2162|       |
 2163|       |#ifdef LIBXML_HTTP_ENABLED
 2164|       |    xmlRegisterInputCallbacks(xmlIOHTTPMatch, xmlIOHTTPOpen,
 2165|       |	                      xmlIOHTTPRead, xmlIOHTTPClose);
 2166|       |#endif /* LIBXML_HTTP_ENABLED */
 2167|       |
 2168|       |#ifdef LIBXML_FTP_ENABLED
 2169|       |    xmlRegisterInputCallbacks(xmlIOFTPMatch, xmlIOFTPOpen,
 2170|       |	                      xmlIOFTPRead, xmlIOFTPClose);
 2171|       |#endif /* LIBXML_FTP_ENABLED */
 2172|      2|    xmlInputCallbackInitialized = 1;
 2173|      2|}
xmlRegisterDefaultOutputCallbacks:
 2182|      2|xmlRegisterDefaultOutputCallbacks (void) {
 2183|      2|    if (xmlOutputCallbackInitialized)
  ------------------
  |  Branch (2183:9): [True: 0, False: 2]
  ------------------
 2184|      0|	return;
 2185|       |
 2186|      2|    xmlRegisterOutputCallbacks(xmlFileMatch, xmlFileOpenW,
 2187|      2|	                      xmlFileWrite, xmlFileClose);
 2188|       |
 2189|       |#ifdef LIBXML_HTTP_ENABLED
 2190|       |    xmlRegisterOutputCallbacks(xmlIOHTTPMatch, xmlIOHTTPDfltOpenW,
 2191|       |	                       xmlIOHTTPWrite, xmlIOHTTPClosePut);
 2192|       |#endif
 2193|       |
 2194|       |/*********************************
 2195|       | No way a-priori to distinguish between gzipped files from
 2196|       | uncompressed ones except opening if existing then closing
 2197|       | and saving with same compression ratio ... a pain.
 2198|       |
 2199|       |#ifdef LIBXML_ZLIB_ENABLED
 2200|       |    xmlRegisterOutputCallbacks(xmlGzfileMatch, xmlGzfileOpen,
 2201|       |	                       xmlGzfileWrite, xmlGzfileClose);
 2202|       |#endif
 2203|       |
 2204|       | Nor FTP PUT ....
 2205|       |#ifdef LIBXML_FTP_ENABLED
 2206|       |    xmlRegisterOutputCallbacks(xmlIOFTPMatch, xmlIOFTPOpen,
 2207|       |	                       xmlIOFTPWrite, xmlIOFTPClose);
 2208|       |#endif
 2209|       | **********************************/
 2210|      2|    xmlOutputCallbackInitialized = 1;
 2211|      2|}

xmlInitMemoryInternal:
  846|      2|xmlInitMemoryInternal(void) {
  847|      2|     char *breakpoint;
  848|      2|     xmlInitMutex(&xmlMemMutex);
  849|       |
  850|      2|     breakpoint = getenv("XML_MEM_BREAKPOINT");
  851|      2|     if (breakpoint != NULL) {
  ------------------
  |  Branch (851:10): [True: 0, False: 2]
  ------------------
  852|      0|         sscanf(breakpoint, "%ud", &xmlMemStopAtBlock);
  853|      0|     }
  854|      2|     breakpoint = getenv("XML_MEM_TRACE");
  855|      2|     if (breakpoint != NULL) {
  ------------------
  |  Branch (855:10): [True: 0, False: 2]
  ------------------
  856|      0|         sscanf(breakpoint, "%p", &xmlMemTraceBlockAt);
  857|      0|     }
  858|       |
  859|      2|}
xmlMemSetup:
  910|      2|            xmlReallocFunc reallocFunc, xmlStrdupFunc strdupFunc) {
  911|      2|    if (freeFunc == NULL)
  ------------------
  |  Branch (911:9): [True: 0, False: 2]
  ------------------
  912|      0|	return(-1);
  913|      2|    if (mallocFunc == NULL)
  ------------------
  |  Branch (913:9): [True: 0, False: 2]
  ------------------
  914|      0|	return(-1);
  915|      2|    if (reallocFunc == NULL)
  ------------------
  |  Branch (915:9): [True: 0, False: 2]
  ------------------
  916|      0|	return(-1);
  917|      2|    if (strdupFunc == NULL)
  ------------------
  |  Branch (917:9): [True: 0, False: 2]
  ------------------
  918|      0|	return(-1);
  919|      2|    xmlFree = freeFunc;
  920|      2|    xmlMalloc = mallocFunc;
  921|      2|    xmlMallocAtomic = mallocFunc;
  922|      2|    xmlRealloc = reallocFunc;
  923|      2|    xmlMemStrdup = strdupFunc;
  924|      2|    return(0);
  925|      2|}

xmlStrndup:
   45|  4.06k|xmlStrndup(const xmlChar *cur, int len) {
   46|  4.06k|    xmlChar *ret;
   47|       |
   48|  4.06k|    if ((cur == NULL) || (len < 0)) return(NULL);
  ------------------
  |  Branch (48:9): [True: 0, False: 4.06k]
  |  Branch (48:26): [True: 0, False: 4.06k]
  ------------------
   49|  4.06k|    ret = (xmlChar *) xmlMallocAtomic((size_t) len + 1);
   50|  4.06k|    if (ret == NULL) {
  ------------------
  |  Branch (50:9): [True: 935, False: 3.13k]
  ------------------
   51|    935|        return(NULL);
   52|    935|    }
   53|  3.13k|    memcpy(ret, cur, len);
   54|  3.13k|    ret[len] = 0;
   55|  3.13k|    return(ret);
   56|  4.06k|}
xmlStrdup:
   69|  1.60k|xmlStrdup(const xmlChar *cur) {
   70|  1.60k|    const xmlChar *p = cur;
   71|       |
   72|  1.60k|    if (cur == NULL) return(NULL);
  ------------------
  |  Branch (72:9): [True: 0, False: 1.60k]
  ------------------
   73|  30.5k|    while (*p != 0) p++; /* non input consuming */
  ------------------
  |  Branch (73:12): [True: 28.8k, False: 1.60k]
  ------------------
   74|  1.60k|    return(xmlStrndup(cur, p - cur));
   75|  1.60k|}
xmlCharStrndup:
   88|    423|xmlCharStrndup(const char *cur, int len) {
   89|    423|    int i;
   90|    423|    xmlChar *ret;
   91|       |
   92|    423|    if ((cur == NULL) || (len < 0)) return(NULL);
  ------------------
  |  Branch (92:9): [True: 0, False: 423]
  |  Branch (92:26): [True: 0, False: 423]
  ------------------
   93|    423|    ret = (xmlChar *) xmlMallocAtomic((size_t) len + 1);
   94|    423|    if (ret == NULL) {
  ------------------
  |  Branch (94:9): [True: 121, False: 302]
  ------------------
   95|    121|        return(NULL);
   96|    121|    }
   97|  6.37k|    for (i = 0;i < len;i++) {
  ------------------
  |  Branch (97:16): [True: 6.06k, False: 302]
  ------------------
   98|       |        /* Explicit sign change */
   99|  6.06k|        ret[i] = (xmlChar) cur[i];
  100|  6.06k|        if (ret[i] == 0) return(ret);
  ------------------
  |  Branch (100:13): [True: 0, False: 6.06k]
  ------------------
  101|  6.06k|    }
  102|    302|    ret[len] = 0;
  103|    302|    return(ret);
  104|    302|}
xmlCharStrdup:
  116|    426|xmlCharStrdup(const char *cur) {
  117|    426|    const char *p = cur;
  118|       |
  119|    426|    if (cur == NULL) return(NULL);
  ------------------
  |  Branch (119:9): [True: 3, False: 423]
  ------------------
  120|  8.03k|    while (*p != '\0') p++; /* non input consuming */
  ------------------
  |  Branch (120:12): [True: 7.61k, False: 423]
  ------------------
  121|    423|    return(xmlCharStrndup(cur, p - cur));
  122|    426|}
xmlStrEqual:
  162|      2|xmlStrEqual(const xmlChar *str1, const xmlChar *str2) {
  163|      2|    if (str1 == str2) return(1);
  ------------------
  |  Branch (163:9): [True: 0, False: 2]
  ------------------
  164|      2|    if (str1 == NULL) return(0);
  ------------------
  |  Branch (164:9): [True: 0, False: 2]
  ------------------
  165|      2|    if (str2 == NULL) return(0);
  ------------------
  |  Branch (165:9): [True: 0, False: 2]
  ------------------
  166|      2|#ifdef FUZZING_BUILD_MODE_UNSAFE_FOR_PRODUCTION
  167|      2|    return(strcmp((const char *)str1, (const char *)str2) == 0);
  168|       |#else
  169|       |    do {
  170|       |        if (*str1++ != *str2) return(0);
  171|       |    } while (*str2++);
  172|       |    return(1);
  173|       |#endif
  174|      2|}
xmlStrncmp:
  215|    608|xmlStrncmp(const xmlChar *str1, const xmlChar *str2, int len) {
  216|    608|    if (len <= 0) return(0);
  ------------------
  |  Branch (216:9): [True: 0, False: 608]
  ------------------
  217|    608|    if (str1 == str2) return(0);
  ------------------
  |  Branch (217:9): [True: 0, False: 608]
  ------------------
  218|    608|    if (str1 == NULL) return(-1);
  ------------------
  |  Branch (218:9): [True: 0, False: 608]
  ------------------
  219|    608|    if (str2 == NULL) return(1);
  ------------------
  |  Branch (219:9): [True: 0, False: 608]
  ------------------
  220|    608|#ifdef FUZZING_BUILD_MODE_UNSAFE_FOR_PRODUCTION
  221|    608|    return(strncmp((const char *)str1, (const char *)str2, len));
  222|       |#else
  223|       |    do {
  224|       |        int tmp = *str1++ - *str2;
  225|       |        if (tmp != 0 || --len == 0) return(tmp);
  226|       |    } while (*str2++ != 0);
  227|       |    return 0;
  228|       |#endif
  229|    608|}
xmlStrchr:
  327|  4.18k|xmlStrchr(const xmlChar *str, xmlChar val) {
  328|  4.18k|    if (str == NULL) return(NULL);
  ------------------
  |  Branch (328:9): [True: 2.54k, False: 1.64k]
  ------------------
  329|  6.85k|    while (*str != 0) { /* non input consuming */
  ------------------
  |  Branch (329:12): [True: 6.57k, False: 277]
  ------------------
  330|  6.57k|        if (*str == val) return((xmlChar *) str);
  ------------------
  |  Branch (330:13): [True: 1.36k, False: 5.21k]
  ------------------
  331|  5.21k|        str++;
  332|  5.21k|    }
  333|    277|    return(NULL);
  334|  1.64k|}
xmlStrstr:
  347|    581|xmlStrstr(const xmlChar *str, const xmlChar *val) {
  348|    581|    int n;
  349|       |
  350|    581|    if (str == NULL) return(NULL);
  ------------------
  |  Branch (350:9): [True: 0, False: 581]
  ------------------
  351|    581|    if (val == NULL) return(NULL);
  ------------------
  |  Branch (351:9): [True: 0, False: 581]
  ------------------
  352|    581|    n = xmlStrlen(val);
  353|       |
  354|    581|    if (n == 0) return(str);
  ------------------
  |  Branch (354:9): [True: 0, False: 581]
  ------------------
  355|  8.26k|    while (*str != 0) { /* non input consuming */
  ------------------
  |  Branch (355:12): [True: 7.86k, False: 404]
  ------------------
  356|  7.86k|        if (*str == *val) {
  ------------------
  |  Branch (356:13): [True: 608, False: 7.25k]
  ------------------
  357|    608|            if (!xmlStrncmp(str, val, n)) return((const xmlChar *) str);
  ------------------
  |  Branch (357:17): [True: 177, False: 431]
  ------------------
  358|    608|        }
  359|  7.68k|        str++;
  360|  7.68k|    }
  361|    404|    return(NULL);
  362|    581|}
xmlStrlen:
  428|  1.82k|xmlStrlen(const xmlChar *str) {
  429|  1.82k|    size_t len = str ? strlen((const char *)str) : 0;
  ------------------
  |  Branch (429:18): [True: 1.82k, False: 0]
  ------------------
  430|  1.82k|    return(len > INT_MAX ? 0 : len);
  ------------------
  |  Branch (430:12): [True: 0, False: 1.82k]
  ------------------
  431|  1.82k|}
xmlStrncat:
  448|    409|xmlStrncat(xmlChar *cur, const xmlChar *add, int len) {
  449|    409|    int size;
  450|    409|    xmlChar *ret;
  451|       |
  452|    409|    if ((add == NULL) || (len == 0))
  ------------------
  |  Branch (452:9): [True: 0, False: 409]
  |  Branch (452:26): [True: 4, False: 405]
  ------------------
  453|      4|        return(cur);
  454|    405|    if (len < 0)
  ------------------
  |  Branch (454:9): [True: 0, False: 405]
  ------------------
  455|      0|	return(NULL);
  456|    405|    if (cur == NULL)
  ------------------
  |  Branch (456:9): [True: 0, False: 405]
  ------------------
  457|      0|        return(xmlStrndup(add, len));
  458|       |
  459|    405|    size = xmlStrlen(cur);
  460|    405|    if ((size < 0) || (size > INT_MAX - len))
  ------------------
  |  Branch (460:9): [True: 0, False: 405]
  |  Branch (460:23): [True: 0, False: 405]
  ------------------
  461|      0|        return(NULL);
  462|    405|    ret = (xmlChar *) xmlRealloc(cur, (size_t) size + len + 1);
  463|    405|    if (ret == NULL) {
  ------------------
  |  Branch (463:9): [True: 3, False: 402]
  ------------------
  464|      3|        return(cur);
  465|      3|    }
  466|    402|    memcpy(&ret[size], add, len);
  467|    402|    ret[size + len] = 0;
  468|    402|    return(ret);
  469|    405|}
xmlStrcat:
  524|    560|xmlStrcat(xmlChar *cur, const xmlChar *add) {
  525|    560|    const xmlChar *p = add;
  526|       |
  527|    560|    if (add == NULL) return(cur);
  ------------------
  |  Branch (527:9): [True: 0, False: 560]
  ------------------
  528|    560|    if (cur == NULL)
  ------------------
  |  Branch (528:9): [True: 151, False: 409]
  ------------------
  529|    151|        return(xmlStrdup(add));
  530|       |
  531|  1.75k|    while (*p != 0) p++; /* non input consuming */
  ------------------
  |  Branch (531:12): [True: 1.34k, False: 409]
  ------------------
  532|    409|    return(xmlStrncat(cur, add, p - add));
  533|    560|}

xmlInitXPathInternal:
  168|      2|xmlInitXPathInternal(void) {
  169|      2|#if defined(NAN) && defined(INFINITY)
  170|      2|    xmlXPathNAN = NAN;
  171|      2|    xmlXPathPINF = INFINITY;
  172|      2|    xmlXPathNINF = -INFINITY;
  173|       |#else
  174|       |    /* MSVC doesn't allow division by zero in constant expressions. */
  175|       |    double zero = 0.0;
  176|       |    xmlXPathNAN = 0.0 / zero;
  177|       |    xmlXPathPINF = 1.0 / zero;
  178|       |    xmlXPathNINF = -xmlXPathPINF;
  179|       |#endif
  180|      2|}

