xmlSAX2InternalSubset:
  326|    760|{
  327|    760|    xmlParserCtxtPtr ctxt = (xmlParserCtxtPtr) ctx;
  328|    760|    xmlDtdPtr dtd;
  329|    760|    if (ctx == NULL) return;
  ------------------
  |  Branch (329:9): [True: 0, False: 760]
  ------------------
  330|       |
  331|    760|    if (ctxt->myDoc == NULL)
  ------------------
  |  Branch (331:9): [True: 0, False: 760]
  ------------------
  332|      0|	return;
  333|    760|    dtd = xmlGetIntSubset(ctxt->myDoc);
  334|    760|    if (dtd != NULL) {
  ------------------
  |  Branch (334:9): [True: 0, False: 760]
  ------------------
  335|      0|	if (ctxt->html)
  ------------------
  |  Branch (335:6): [True: 0, False: 0]
  ------------------
  336|      0|	    return;
  337|      0|	xmlUnlinkNode((xmlNodePtr) dtd);
  338|      0|	xmlFreeDtd(dtd);
  339|      0|	ctxt->myDoc->intSubset = NULL;
  340|      0|    }
  341|    760|    ctxt->myDoc->intSubset =
  342|    760|	xmlCreateIntSubset(ctxt->myDoc, name, ExternalID, SystemID);
  343|    760|    if (ctxt->myDoc->intSubset == NULL)
  ------------------
  |  Branch (343:9): [True: 0, False: 760]
  ------------------
  344|      0|        xmlSAX2ErrMemory(ctxt, "xmlSAX2InternalSubset");
  345|    760|}
xmlSAX2ExternalSubset:
  359|    716|{
  360|    716|    xmlParserCtxtPtr ctxt = (xmlParserCtxtPtr) ctx;
  361|    716|    if (ctx == NULL) return;
  ------------------
  |  Branch (361:9): [True: 0, False: 716]
  ------------------
  362|    716|    if (((ExternalID != NULL) || (SystemID != NULL)) &&
  ------------------
  |  Branch (362:10): [True: 160, False: 556]
  |  Branch (362:34): [True: 108, False: 448]
  ------------------
  363|    716|        (((ctxt->validate) || (ctxt->loadsubset != 0)) &&
  ------------------
  |  Branch (363:11): [True: 201, False: 67]
  |  Branch (363:31): [True: 67, False: 0]
  ------------------
  364|    268|	 (ctxt->wellFormed && ctxt->myDoc))) {
  ------------------
  |  Branch (364:4): [True: 268, False: 0]
  |  Branch (364:24): [True: 268, False: 0]
  ------------------
  365|       |	/*
  366|       |	 * Try to fetch and parse the external subset.
  367|       |	 */
  368|    268|	xmlParserInputPtr oldinput;
  369|    268|	int oldinputNr;
  370|    268|	int oldinputMax;
  371|    268|	xmlParserInputPtr *oldinputTab;
  372|    268|	xmlParserInputPtr input = NULL;
  373|    268|	const xmlChar *oldencoding;
  374|    268|	int oldprogressive;
  375|    268|        unsigned long consumed;
  376|    268|        size_t buffered;
  377|       |
  378|       |	/*
  379|       |	 * Ask the Entity resolver to load the damn thing
  380|       |	 */
  381|    268|	if ((ctxt->sax != NULL) && (ctxt->sax->resolveEntity != NULL))
  ------------------
  |  Branch (381:6): [True: 268, False: 0]
  |  Branch (381:29): [True: 268, False: 0]
  ------------------
  382|    268|	    input = ctxt->sax->resolveEntity(ctxt->userData, ExternalID,
  383|    268|	                                        SystemID);
  384|    268|	if (input == NULL) {
  ------------------
  |  Branch (384:6): [True: 184, False: 84]
  ------------------
  385|    184|	    return;
  386|    184|	}
  387|       |
  388|     84|	xmlNewDtd(ctxt->myDoc, name, ExternalID, SystemID);
  389|       |
  390|       |	/*
  391|       |	 * make sure we won't destroy the main document context
  392|       |	 */
  393|     84|	oldinput = ctxt->input;
  394|     84|	oldinputNr = ctxt->inputNr;
  395|     84|	oldinputMax = ctxt->inputMax;
  396|     84|	oldinputTab = ctxt->inputTab;
  397|     84|	oldencoding = ctxt->encoding;
  398|     84|        oldprogressive = ctxt->progressive;
  399|     84|	ctxt->encoding = NULL;
  400|     84|        ctxt->progressive = 0;
  401|       |
  402|     84|	ctxt->inputTab = (xmlParserInputPtr *)
  403|     84|	                 xmlMalloc(5 * sizeof(xmlParserInputPtr));
  404|     84|	if (ctxt->inputTab == NULL) {
  ------------------
  |  Branch (404:6): [True: 0, False: 84]
  ------------------
  405|      0|	    xmlSAX2ErrMemory(ctxt, "xmlSAX2ExternalSubset");
  406|      0|            xmlFreeInputStream(input);
  407|      0|	    ctxt->input = oldinput;
  408|      0|	    ctxt->inputNr = oldinputNr;
  409|      0|	    ctxt->inputMax = oldinputMax;
  410|      0|	    ctxt->inputTab = oldinputTab;
  411|      0|	    ctxt->encoding = oldencoding;
  412|      0|            ctxt->progressive = oldprogressive;
  413|      0|	    return;
  414|      0|	}
  415|     84|	ctxt->inputNr = 0;
  416|     84|	ctxt->inputMax = 5;
  417|     84|	ctxt->input = NULL;
  418|     84|	xmlPushInput(ctxt, input);
  419|       |
  420|     84|	if (input->filename == NULL)
  ------------------
  |  Branch (420:6): [True: 0, False: 84]
  ------------------
  421|      0|	    input->filename = (char *) xmlCanonicPath(SystemID);
  422|     84|	input->line = 1;
  423|     84|	input->col = 1;
  424|     84|	input->base = ctxt->input->cur;
  425|     84|	input->cur = ctxt->input->cur;
  426|     84|	input->free = NULL;
  427|       |
  428|       |	/*
  429|       |	 * let's parse that entity knowing it's an external subset.
  430|       |	 */
  431|     84|	xmlParseExternalSubset(ctxt, ExternalID, SystemID);
  432|       |
  433|       |        /*
  434|       |	 * Free up the external entities
  435|       |	 */
  436|       |
  437|     84|	while (ctxt->inputNr > 1)
  ------------------
  |  Branch (437:9): [True: 0, False: 84]
  ------------------
  438|      0|	    xmlPopInput(ctxt);
  439|       |
  440|     84|        consumed = ctxt->input->consumed;
  441|     84|        buffered = ctxt->input->cur - ctxt->input->base;
  442|     84|        if (buffered > ULONG_MAX - consumed)
  ------------------
  |  Branch (442:13): [True: 0, False: 84]
  ------------------
  443|      0|            consumed = ULONG_MAX;
  444|     84|        else
  445|     84|            consumed += buffered;
  446|     84|        if (consumed > ULONG_MAX - ctxt->sizeentities)
  ------------------
  |  Branch (446:13): [True: 0, False: 84]
  ------------------
  447|      0|            ctxt->sizeentities = ULONG_MAX;
  448|     84|        else
  449|     84|            ctxt->sizeentities += consumed;
  450|       |
  451|     84|	xmlFreeInputStream(ctxt->input);
  452|     84|        xmlFree(ctxt->inputTab);
  453|       |
  454|       |	/*
  455|       |	 * Restore the parsing context of the main entity
  456|       |	 */
  457|     84|	ctxt->input = oldinput;
  458|     84|	ctxt->inputNr = oldinputNr;
  459|     84|	ctxt->inputMax = oldinputMax;
  460|     84|	ctxt->inputTab = oldinputTab;
  461|     84|	if ((ctxt->encoding != NULL) &&
  ------------------
  |  Branch (461:6): [True: 12, False: 72]
  ------------------
  462|     84|	    ((ctxt->dict == NULL) ||
  ------------------
  |  Branch (462:7): [True: 0, False: 12]
  ------------------
  463|     12|	     (!xmlDictOwns(ctxt->dict, ctxt->encoding))))
  ------------------
  |  Branch (463:7): [True: 12, False: 0]
  ------------------
  464|     12|	    xmlFree((xmlChar *) ctxt->encoding);
  465|     84|	ctxt->encoding = oldencoding;
  466|     84|        ctxt->progressive = oldprogressive;
  467|       |	/* ctxt->wellFormed = oldwellFormed; */
  468|     84|    }
  469|    716|}
xmlSAX2ResolveEntity:
  487|    312|{
  488|    312|    xmlParserCtxtPtr ctxt = (xmlParserCtxtPtr) ctx;
  489|    312|    xmlParserInputPtr ret;
  490|    312|    xmlChar *URI;
  491|    312|    const char *base = NULL;
  492|       |
  493|    312|    if (ctx == NULL) return(NULL);
  ------------------
  |  Branch (493:9): [True: 0, False: 312]
  ------------------
  494|    312|    if (ctxt->input != NULL)
  ------------------
  |  Branch (494:9): [True: 268, False: 44]
  ------------------
  495|    268|	base = ctxt->input->filename;
  496|    312|    if (base == NULL)
  ------------------
  |  Branch (496:9): [True: 111, False: 201]
  ------------------
  497|    111|	base = ctxt->directory;
  498|       |
  499|    312|    URI = xmlBuildURI(systemId, (const xmlChar *) base);
  500|       |
  501|    312|    ret = xmlLoadExternalEntity((const char *) URI,
  502|    312|				(const char *) publicId, ctxt);
  503|    312|    if (URI != NULL)
  ------------------
  |  Branch (503:9): [True: 312, False: 0]
  ------------------
  504|    312|	xmlFree(URI);
  505|    312|    return(ret);
  506|    312|}
xmlSAX2GetEntity:
  519|   223k|{
  520|   223k|    xmlParserCtxtPtr ctxt = (xmlParserCtxtPtr) ctx;
  521|   223k|    xmlEntityPtr ret = NULL;
  522|       |
  523|   223k|    if (ctx == NULL) return(NULL);
  ------------------
  |  Branch (523:9): [True: 0, False: 223k]
  ------------------
  524|       |
  525|   223k|    if (ctxt->inSubset == 0) {
  ------------------
  |  Branch (525:9): [True: 221k, False: 1.38k]
  ------------------
  526|   221k|	ret = xmlGetPredefinedEntity(name);
  527|   221k|	if (ret != NULL)
  ------------------
  |  Branch (527:6): [True: 0, False: 221k]
  ------------------
  528|      0|	    return(ret);
  529|   221k|    }
  530|   223k|    if ((ctxt->myDoc != NULL) && (ctxt->myDoc->standalone == 1)) {
  ------------------
  |  Branch (530:9): [True: 223k, False: 0]
  |  Branch (530:34): [True: 32, False: 223k]
  ------------------
  531|     32|	if (ctxt->inSubset == 2) {
  ------------------
  |  Branch (531:6): [True: 0, False: 32]
  ------------------
  532|      0|	    ctxt->myDoc->standalone = 0;
  533|      0|	    ret = xmlGetDocEntity(ctxt->myDoc, name);
  534|      0|	    ctxt->myDoc->standalone = 1;
  535|     32|	} else {
  536|     32|	    ret = xmlGetDocEntity(ctxt->myDoc, name);
  537|     32|	    if (ret == NULL) {
  ------------------
  |  Branch (537:10): [True: 0, False: 32]
  ------------------
  538|      0|		ctxt->myDoc->standalone = 0;
  539|      0|		ret = xmlGetDocEntity(ctxt->myDoc, name);
  540|      0|		if (ret != NULL) {
  ------------------
  |  Branch (540:7): [True: 0, False: 0]
  ------------------
  541|      0|		    xmlFatalErrMsg(ctxt, XML_ERR_NOT_STANDALONE,
  542|      0|	 "Entity(%s) document marked standalone but requires external subset\n",
  543|      0|				   name, NULL);
  544|      0|		}
  545|      0|		ctxt->myDoc->standalone = 1;
  546|      0|	    }
  547|     32|	}
  548|   223k|    } else {
  549|   223k|	ret = xmlGetDocEntity(ctxt->myDoc, name);
  550|   223k|    }
  551|   223k|    return(ret);
  552|   223k|}
xmlSAX2GetParameterEntity:
  565|   139k|{
  566|   139k|    xmlParserCtxtPtr ctxt = (xmlParserCtxtPtr) ctx;
  567|   139k|    xmlEntityPtr ret;
  568|       |
  569|   139k|    if (ctx == NULL) return(NULL);
  ------------------
  |  Branch (569:9): [True: 0, False: 139k]
  ------------------
  570|       |
  571|   139k|    ret = xmlGetParameterEntity(ctxt->myDoc, name);
  572|   139k|    return(ret);
  573|   139k|}
xmlSAX2EntityDecl:
  590|  2.33k|{
  591|  2.33k|    xmlEntityPtr ent;
  592|  2.33k|    xmlParserCtxtPtr ctxt = (xmlParserCtxtPtr) ctx;
  593|       |
  594|  2.33k|    if (ctx == NULL) return;
  ------------------
  |  Branch (594:9): [True: 0, False: 2.33k]
  ------------------
  595|  2.33k|    if (ctxt->inSubset == 1) {
  ------------------
  |  Branch (595:9): [True: 1.65k, False: 684]
  ------------------
  596|  1.65k|	ent = xmlAddDocEntity(ctxt->myDoc, name, type, publicId,
  597|  1.65k|		              systemId, content);
  598|  1.65k|	if ((ent == NULL) && (ctxt->pedantic))
  ------------------
  |  Branch (598:6): [True: 8, False: 1.64k]
  |  Branch (598:23): [True: 0, False: 8]
  ------------------
  599|      0|	    xmlWarnMsg(ctxt, XML_WAR_ENTITY_REDEFINED,
  600|      0|	     "Entity(%s) already defined in the internal subset\n",
  601|      0|	               name);
  602|  1.65k|	if ((ent != NULL) && (ent->URI == NULL) && (systemId != NULL)) {
  ------------------
  |  Branch (602:6): [True: 1.64k, False: 8]
  |  Branch (602:23): [True: 1.64k, False: 0]
  |  Branch (602:45): [True: 72, False: 1.57k]
  ------------------
  603|     72|	    xmlChar *URI;
  604|     72|	    const char *base = NULL;
  605|       |
  606|     72|	    if (ctxt->input != NULL)
  ------------------
  |  Branch (606:10): [True: 72, False: 0]
  ------------------
  607|     72|		base = ctxt->input->filename;
  608|     72|	    if (base == NULL)
  ------------------
  |  Branch (608:10): [True: 18, False: 54]
  ------------------
  609|     18|		base = ctxt->directory;
  610|       |
  611|     72|	    URI = xmlBuildURI(systemId, (const xmlChar *) base);
  612|     72|	    ent->URI = URI;
  613|     72|	}
  614|  1.65k|    } else if (ctxt->inSubset == 2) {
  ------------------
  |  Branch (614:16): [True: 684, False: 0]
  ------------------
  615|    684|	ent = xmlAddDtdEntity(ctxt->myDoc, name, type, publicId,
  616|    684|		              systemId, content);
  617|    684|	if ((ent == NULL) && (ctxt->pedantic) &&
  ------------------
  |  Branch (617:6): [True: 0, False: 684]
  |  Branch (617:23): [True: 0, False: 0]
  ------------------
  618|    684|	    (ctxt->sax != NULL) && (ctxt->sax->warning != NULL))
  ------------------
  |  Branch (618:6): [True: 0, False: 0]
  |  Branch (618:29): [True: 0, False: 0]
  ------------------
  619|      0|	    ctxt->sax->warning(ctxt->userData,
  620|      0|	     "Entity(%s) already defined in the external subset\n", name);
  621|    684|	if ((ent != NULL) && (ent->URI == NULL) && (systemId != NULL)) {
  ------------------
  |  Branch (621:6): [True: 684, False: 0]
  |  Branch (621:23): [True: 684, False: 0]
  |  Branch (621:45): [True: 8, False: 676]
  ------------------
  622|      8|	    xmlChar *URI;
  623|      8|	    const char *base = NULL;
  624|       |
  625|      8|	    if (ctxt->input != NULL)
  ------------------
  |  Branch (625:10): [True: 8, False: 0]
  ------------------
  626|      8|		base = ctxt->input->filename;
  627|      8|	    if (base == NULL)
  ------------------
  |  Branch (627:10): [True: 0, False: 8]
  ------------------
  628|      0|		base = ctxt->directory;
  629|       |
  630|      8|	    URI = xmlBuildURI(systemId, (const xmlChar *) base);
  631|      8|	    ent->URI = URI;
  632|      8|	}
  633|    684|    } else {
  634|      0|	xmlFatalErrMsg(ctxt, XML_ERR_ENTITY_PROCESSING,
  635|      0|	               "SAX.xmlSAX2EntityDecl(%s) called while not in subset\n",
  636|      0|		       name, NULL);
  637|      0|    }
  638|  2.33k|}
xmlSAX2AttributeDecl:
  656|  7.78k|{
  657|  7.78k|    xmlParserCtxtPtr ctxt = (xmlParserCtxtPtr) ctx;
  658|  7.78k|    xmlAttributePtr attr;
  659|  7.78k|    xmlChar *name = NULL, *prefix = NULL;
  660|       |
  661|       |    /* Avoid unused variable warning if features are disabled. */
  662|  7.78k|    (void) attr;
  663|       |
  664|  7.78k|    if ((ctxt == NULL) || (ctxt->myDoc == NULL))
  ------------------
  |  Branch (664:9): [True: 0, False: 7.78k]
  |  Branch (664:27): [True: 0, False: 7.78k]
  ------------------
  665|      0|        return;
  666|       |
  667|  7.78k|    if ((xmlStrEqual(fullname, BAD_CAST "xml:id")) &&
  ------------------
  |  |   35|  7.78k|#define BAD_CAST (xmlChar *)
  ------------------
  |  Branch (667:9): [True: 4, False: 7.77k]
  ------------------
  668|  7.78k|        (type != XML_ATTRIBUTE_ID)) {
  ------------------
  |  Branch (668:9): [True: 4, False: 0]
  ------------------
  669|       |	/*
  670|       |	 * Raise the error but keep the validity flag
  671|       |	 */
  672|      4|	int tmp = ctxt->valid;
  673|      4|	xmlErrValid(ctxt, XML_DTD_XMLID_TYPE,
  674|      4|	      "xml:id : attribute type should be ID\n", NULL, NULL);
  675|      4|	ctxt->valid = tmp;
  676|      4|    }
  677|       |    /* TODO: optimize name/prefix allocation */
  678|  7.78k|    name = xmlSplitQName(ctxt, fullname, &prefix);
  679|  7.78k|    ctxt->vctxt.valid = 1;
  680|  7.78k|    if (ctxt->inSubset == 1)
  ------------------
  |  Branch (680:9): [True: 3.58k, False: 4.19k]
  ------------------
  681|  3.58k|	attr = xmlAddAttributeDecl(&ctxt->vctxt, ctxt->myDoc->intSubset, elem,
  682|  3.58k|	       name, prefix, (xmlAttributeType) type,
  683|  3.58k|	       (xmlAttributeDefault) def, defaultValue, tree);
  684|  4.19k|    else if (ctxt->inSubset == 2)
  ------------------
  |  Branch (684:14): [True: 4.19k, False: 0]
  ------------------
  685|  4.19k|	attr = xmlAddAttributeDecl(&ctxt->vctxt, ctxt->myDoc->extSubset, elem,
  686|  4.19k|	   name, prefix, (xmlAttributeType) type,
  687|  4.19k|	   (xmlAttributeDefault) def, defaultValue, tree);
  688|      0|    else {
  689|      0|        xmlFatalErrMsg(ctxt, XML_ERR_INTERNAL_ERROR,
  690|      0|	     "SAX.xmlSAX2AttributeDecl(%s) called while not in subset\n",
  691|      0|	               name, NULL);
  692|      0|	xmlFree(name);
  693|      0|	xmlFreeEnumeration(tree);
  694|      0|	return;
  695|      0|    }
  696|  7.78k|#ifdef LIBXML_VALID_ENABLED
  697|  7.78k|    if (ctxt->vctxt.valid == 0)
  ------------------
  |  Branch (697:9): [True: 24, False: 7.75k]
  ------------------
  698|     24|	ctxt->valid = 0;
  699|  7.78k|    if ((attr != NULL) && (ctxt->validate) && (ctxt->wellFormed) &&
  ------------------
  |  Branch (699:9): [True: 7.77k, False: 4]
  |  Branch (699:27): [True: 5.83k, False: 1.94k]
  |  Branch (699:47): [True: 5.83k, False: 0]
  ------------------
  700|  7.78k|        (ctxt->myDoc->intSubset != NULL))
  ------------------
  |  Branch (700:9): [True: 5.83k, False: 0]
  ------------------
  701|  5.83k|	ctxt->valid &= xmlValidateAttributeDecl(&ctxt->vctxt, ctxt->myDoc,
  702|  5.83k|	                                        attr);
  703|  7.78k|#endif /* LIBXML_VALID_ENABLED */
  704|  7.78k|    if (prefix != NULL)
  ------------------
  |  Branch (704:9): [True: 312, False: 7.46k]
  ------------------
  705|    312|	xmlFree(prefix);
  706|  7.78k|    if (name != NULL)
  ------------------
  |  Branch (706:9): [True: 7.78k, False: 0]
  ------------------
  707|  7.78k|	xmlFree(name);
  708|  7.78k|}
xmlSAX2ElementDecl:
  722|  3.11k|{
  723|  3.11k|    xmlParserCtxtPtr ctxt = (xmlParserCtxtPtr) ctx;
  724|  3.11k|    xmlElementPtr elem = NULL;
  725|       |
  726|       |    /* Avoid unused variable warning if features are disabled. */
  727|  3.11k|    (void) elem;
  728|       |
  729|  3.11k|    if ((ctxt == NULL) || (ctxt->myDoc == NULL))
  ------------------
  |  Branch (729:9): [True: 0, False: 3.11k]
  |  Branch (729:27): [True: 0, False: 3.11k]
  ------------------
  730|      0|        return;
  731|       |
  732|  3.11k|    if (ctxt->inSubset == 1)
  ------------------
  |  Branch (732:9): [True: 1.62k, False: 1.48k]
  ------------------
  733|  1.62k|        elem = xmlAddElementDecl(&ctxt->vctxt, ctxt->myDoc->intSubset,
  734|  1.62k|                                 name, (xmlElementTypeVal) type, content);
  735|  1.48k|    else if (ctxt->inSubset == 2)
  ------------------
  |  Branch (735:14): [True: 1.48k, False: 0]
  ------------------
  736|  1.48k|        elem = xmlAddElementDecl(&ctxt->vctxt, ctxt->myDoc->extSubset,
  737|  1.48k|                                 name, (xmlElementTypeVal) type, content);
  738|      0|    else {
  739|      0|        xmlFatalErrMsg(ctxt, XML_ERR_INTERNAL_ERROR,
  740|      0|	     "SAX.xmlSAX2ElementDecl(%s) called while not in subset\n",
  741|      0|	               name, NULL);
  742|      0|        return;
  743|      0|    }
  744|  3.11k|#ifdef LIBXML_VALID_ENABLED
  745|  3.11k|    if (elem == NULL)
  ------------------
  |  Branch (745:9): [True: 4, False: 3.10k]
  ------------------
  746|      4|        ctxt->valid = 0;
  747|  3.11k|    if (ctxt->validate && ctxt->wellFormed &&
  ------------------
  |  Branch (747:9): [True: 2.33k, False: 778]
  |  Branch (747:27): [True: 2.33k, False: 0]
  ------------------
  748|  3.11k|        ctxt->myDoc && ctxt->myDoc->intSubset)
  ------------------
  |  Branch (748:9): [True: 2.33k, False: 0]
  |  Branch (748:24): [True: 2.33k, False: 0]
  ------------------
  749|  2.33k|        ctxt->valid &=
  750|  2.33k|            xmlValidateElementDecl(&ctxt->vctxt, ctxt->myDoc, elem);
  751|  3.11k|#endif /* LIBXML_VALID_ENABLED */
  752|  3.11k|}
xmlSAX2UnparsedEntityDecl:
  816|      4|{
  817|      4|    xmlEntityPtr ent;
  818|      4|    xmlParserCtxtPtr ctxt = (xmlParserCtxtPtr) ctx;
  819|      4|    if (ctx == NULL) return;
  ------------------
  |  Branch (819:9): [True: 0, False: 4]
  ------------------
  820|      4|    if (ctxt->inSubset == 1) {
  ------------------
  |  Branch (820:9): [True: 4, False: 0]
  ------------------
  821|      4|	ent = xmlAddDocEntity(ctxt->myDoc, name,
  822|      4|			XML_EXTERNAL_GENERAL_UNPARSED_ENTITY,
  823|      4|			publicId, systemId, notationName);
  824|      4|	if ((ent == NULL) && (ctxt->pedantic) &&
  ------------------
  |  Branch (824:6): [True: 0, False: 4]
  |  Branch (824:23): [True: 0, False: 0]
  ------------------
  825|      4|	    (ctxt->sax != NULL) && (ctxt->sax->warning != NULL))
  ------------------
  |  Branch (825:6): [True: 0, False: 0]
  |  Branch (825:29): [True: 0, False: 0]
  ------------------
  826|      0|	    ctxt->sax->warning(ctxt->userData,
  827|      0|	     "Entity(%s) already defined in the internal subset\n", name);
  828|      4|	if ((ent != NULL) && (ent->URI == NULL) && (systemId != NULL)) {
  ------------------
  |  Branch (828:6): [True: 4, False: 0]
  |  Branch (828:23): [True: 4, False: 0]
  |  Branch (828:45): [True: 4, False: 0]
  ------------------
  829|      4|	    xmlChar *URI;
  830|      4|	    const char *base = NULL;
  831|       |
  832|      4|	    if (ctxt->input != NULL)
  ------------------
  |  Branch (832:10): [True: 4, False: 0]
  ------------------
  833|      4|		base = ctxt->input->filename;
  834|      4|	    if (base == NULL)
  ------------------
  |  Branch (834:10): [True: 1, False: 3]
  ------------------
  835|      1|		base = ctxt->directory;
  836|       |
  837|      4|	    URI = xmlBuildURI(systemId, (const xmlChar *) base);
  838|      4|	    ent->URI = URI;
  839|      4|	}
  840|      4|    } else if (ctxt->inSubset == 2) {
  ------------------
  |  Branch (840:16): [True: 0, False: 0]
  ------------------
  841|      0|	ent = xmlAddDtdEntity(ctxt->myDoc, name,
  842|      0|			XML_EXTERNAL_GENERAL_UNPARSED_ENTITY,
  843|      0|			publicId, systemId, notationName);
  844|      0|	if ((ent == NULL) && (ctxt->pedantic) &&
  ------------------
  |  Branch (844:6): [True: 0, False: 0]
  |  Branch (844:23): [True: 0, False: 0]
  ------------------
  845|      0|	    (ctxt->sax != NULL) && (ctxt->sax->warning != NULL))
  ------------------
  |  Branch (845:6): [True: 0, False: 0]
  |  Branch (845:29): [True: 0, False: 0]
  ------------------
  846|      0|	    ctxt->sax->warning(ctxt->userData,
  847|      0|	     "Entity(%s) already defined in the external subset\n", name);
  848|      0|	if ((ent != NULL) && (ent->URI == NULL) && (systemId != NULL)) {
  ------------------
  |  Branch (848:6): [True: 0, False: 0]
  |  Branch (848:23): [True: 0, False: 0]
  |  Branch (848:45): [True: 0, False: 0]
  ------------------
  849|      0|	    xmlChar *URI;
  850|      0|	    const char *base = NULL;
  851|       |
  852|      0|	    if (ctxt->input != NULL)
  ------------------
  |  Branch (852:10): [True: 0, False: 0]
  ------------------
  853|      0|		base = ctxt->input->filename;
  854|      0|	    if (base == NULL)
  ------------------
  |  Branch (854:10): [True: 0, False: 0]
  ------------------
  855|      0|		base = ctxt->directory;
  856|       |
  857|      0|	    URI = xmlBuildURI(systemId, (const xmlChar *) base);
  858|      0|	    ent->URI = URI;
  859|      0|	}
  860|      0|    } else {
  861|      0|        xmlFatalErrMsg(ctxt, XML_ERR_INTERNAL_ERROR,
  862|      0|	     "SAX.xmlSAX2UnparsedEntityDecl(%s) called while not in subset\n",
  863|      0|	               name, NULL);
  864|      0|    }
  865|      4|}
xmlSAX2SetDocumentLocator:
  877|  1.28k|{
  878|  1.28k|}
xmlSAX2StartDocument:
  888|  1.28k|{
  889|  1.28k|    xmlParserCtxtPtr ctxt = (xmlParserCtxtPtr) ctx;
  890|  1.28k|    xmlDocPtr doc;
  891|       |
  892|  1.28k|    if (ctx == NULL) return;
  ------------------
  |  Branch (892:9): [True: 0, False: 1.28k]
  ------------------
  893|       |
  894|  1.28k|    if (ctxt->html) {
  ------------------
  |  Branch (894:9): [True: 0, False: 1.28k]
  ------------------
  895|      0|#ifdef LIBXML_HTML_ENABLED
  896|      0|	if (ctxt->myDoc == NULL)
  ------------------
  |  Branch (896:6): [True: 0, False: 0]
  ------------------
  897|      0|	    ctxt->myDoc = htmlNewDocNoDtD(NULL, NULL);
  898|      0|	if (ctxt->myDoc == NULL) {
  ------------------
  |  Branch (898:6): [True: 0, False: 0]
  ------------------
  899|      0|	    xmlSAX2ErrMemory(ctxt, "xmlSAX2StartDocument");
  900|      0|	    return;
  901|      0|	}
  902|      0|	ctxt->myDoc->properties = XML_DOC_HTML;
  903|      0|	ctxt->myDoc->parseFlags = ctxt->options;
  904|       |#else
  905|       |        xmlGenericError(xmlGenericErrorContext,
  906|       |		"libxml2 built without HTML support\n");
  907|       |	ctxt->errNo = XML_ERR_INTERNAL_ERROR;
  908|       |	ctxt->instate = XML_PARSER_EOF;
  909|       |	ctxt->disableSAX = 1;
  910|       |	return;
  911|       |#endif
  912|  1.28k|    } else {
  913|  1.28k|	doc = ctxt->myDoc = xmlNewDoc(ctxt->version);
  914|  1.28k|	if (doc != NULL) {
  ------------------
  |  Branch (914:6): [True: 1.28k, False: 0]
  ------------------
  915|  1.28k|	    doc->properties = 0;
  916|  1.28k|	    if (ctxt->options & XML_PARSE_OLD10)
  ------------------
  |  Branch (916:10): [True: 0, False: 1.28k]
  ------------------
  917|      0|	        doc->properties |= XML_DOC_OLD10;
  918|  1.28k|	    doc->parseFlags = ctxt->options;
  919|  1.28k|	    doc->standalone = ctxt->standalone;
  920|  1.28k|	} else {
  921|      0|	    xmlSAX2ErrMemory(ctxt, "xmlSAX2StartDocument");
  922|      0|	    return;
  923|      0|	}
  924|  1.28k|	if ((ctxt->dictNames) && (doc != NULL)) {
  ------------------
  |  Branch (924:6): [True: 1.28k, False: 0]
  |  Branch (924:27): [True: 1.28k, False: 0]
  ------------------
  925|  1.28k|	    doc->dict = ctxt->dict;
  926|  1.28k|	    xmlDictReference(doc->dict);
  927|  1.28k|	}
  928|  1.28k|    }
  929|  1.28k|    if ((ctxt->myDoc != NULL) && (ctxt->myDoc->URL == NULL) &&
  ------------------
  |  Branch (929:9): [True: 1.28k, False: 0]
  |  Branch (929:34): [True: 1.28k, False: 0]
  ------------------
  930|  1.28k|	(ctxt->input != NULL) && (ctxt->input->filename != NULL)) {
  ------------------
  |  Branch (930:2): [True: 1.28k, False: 0]
  |  Branch (930:27): [True: 966, False: 322]
  ------------------
  931|    966|	ctxt->myDoc->URL = xmlPathToURI((const xmlChar *)ctxt->input->filename);
  932|    966|	if (ctxt->myDoc->URL == NULL)
  ------------------
  |  Branch (932:6): [True: 0, False: 966]
  ------------------
  933|      0|	    xmlSAX2ErrMemory(ctxt, "xmlSAX2StartDocument");
  934|    966|    }
  935|  1.28k|}
xmlSAX2EndDocument:
  945|  1.18k|{
  946|  1.18k|    xmlParserCtxtPtr ctxt = (xmlParserCtxtPtr) ctx;
  947|  1.18k|    xmlDocPtr doc;
  948|       |
  949|  1.18k|    if (ctx == NULL) return;
  ------------------
  |  Branch (949:9): [True: 0, False: 1.18k]
  ------------------
  950|  1.18k|#ifdef LIBXML_VALID_ENABLED
  951|  1.18k|    if (ctxt->validate && ctxt->wellFormed &&
  ------------------
  |  Branch (951:9): [True: 424, False: 756]
  |  Branch (951:27): [True: 363, False: 61]
  ------------------
  952|  1.18k|        ctxt->myDoc && ctxt->myDoc->intSubset)
  ------------------
  |  Branch (952:9): [True: 363, False: 0]
  |  Branch (952:24): [True: 363, False: 0]
  ------------------
  953|    363|	ctxt->valid &= xmlValidateDocumentFinal(&ctxt->vctxt, ctxt->myDoc);
  954|  1.18k|#endif /* LIBXML_VALID_ENABLED */
  955|       |
  956|  1.18k|    doc = ctxt->myDoc;
  957|  1.18k|    if ((doc != NULL) && (doc->encoding == NULL)) {
  ------------------
  |  Branch (957:9): [True: 1.17k, False: 2]
  |  Branch (957:26): [True: 1.17k, False: 0]
  ------------------
  958|  1.17k|        const xmlChar *encoding = NULL;
  959|       |
  960|  1.17k|        if ((ctxt->input->flags & XML_INPUT_USES_ENC_DECL) ||
  ------------------
  |  |   26|  1.17k|#define XML_INPUT_USES_ENC_DECL     (1u << 4)
  ------------------
  |  Branch (960:13): [True: 126, False: 1.05k]
  ------------------
  961|  1.17k|            (ctxt->input->flags & XML_INPUT_AUTO_ENCODING)) {
  ------------------
  |  |   21|  1.05k|#define XML_INPUT_AUTO_ENCODING     (7u << 1)
  ------------------
  |  Branch (961:13): [True: 12, False: 1.04k]
  ------------------
  962|       |            /* Preserve encoding exactly */
  963|    138|            encoding = ctxt->encoding;
  964|  1.04k|        } else if ((ctxt->input->buf) && (ctxt->input->buf->encoder)) {
  ------------------
  |  Branch (964:20): [True: 992, False: 48]
  |  Branch (964:42): [True: 0, False: 992]
  ------------------
  965|      0|            encoding = BAD_CAST ctxt->input->buf->encoder->name;
  ------------------
  |  |   35|      0|#define BAD_CAST (xmlChar *)
  ------------------
  966|  1.04k|        } else if (ctxt->input->flags & XML_INPUT_HAS_ENCODING) {
  ------------------
  |  |   20|  1.04k|#define XML_INPUT_HAS_ENCODING      (1u << 0)
  ------------------
  |  Branch (966:20): [True: 0, False: 1.04k]
  ------------------
  967|      0|            encoding = BAD_CAST "UTF-8";
  ------------------
  |  |   35|      0|#define BAD_CAST (xmlChar *)
  ------------------
  968|      0|        }
  969|       |
  970|  1.17k|        if (encoding != NULL) {
  ------------------
  |  Branch (970:13): [True: 130, False: 1.04k]
  ------------------
  971|    130|            doc->encoding = xmlStrdup(encoding);
  972|    130|            if (doc->encoding == NULL)
  ------------------
  |  Branch (972:17): [True: 0, False: 130]
  ------------------
  973|      0|                xmlSAX2ErrMemory(ctxt, "xmlSAX2EndDocument");
  974|    130|        }
  975|  1.17k|    }
  976|  1.18k|}
xmlSAX2StartElementNs:
 2087|  57.3k|{
 2088|  57.3k|    xmlParserCtxtPtr ctxt = (xmlParserCtxtPtr) ctx;
 2089|  57.3k|    xmlNodePtr ret;
 2090|  57.3k|    xmlNodePtr parent;
 2091|  57.3k|    xmlNsPtr last = NULL, ns;
 2092|  57.3k|    const xmlChar *uri, *pref;
 2093|  57.3k|    xmlChar *lname = NULL;
 2094|  57.3k|    int i, j;
 2095|       |
 2096|  57.3k|    if (ctx == NULL) return;
  ------------------
  |  Branch (2096:9): [True: 0, False: 57.3k]
  ------------------
 2097|       |    /*
 2098|       |     * First check on validity:
 2099|       |     */
 2100|  57.3k|    if (ctxt->validate && (ctxt->myDoc->extSubset == NULL) &&
  ------------------
  |  Branch (2100:9): [True: 10.8k, False: 46.4k]
  |  Branch (2100:27): [True: 2.17k, False: 8.67k]
  ------------------
 2101|  57.3k|        ((ctxt->myDoc->intSubset == NULL) ||
  ------------------
  |  Branch (2101:10): [True: 339, False: 1.83k]
  ------------------
 2102|  2.17k|	 ((ctxt->myDoc->intSubset->notations == NULL) &&
  ------------------
  |  Branch (2102:4): [True: 1.83k, False: 0]
  ------------------
 2103|  1.83k|	  (ctxt->myDoc->intSubset->elements == NULL) &&
  ------------------
  |  Branch (2103:4): [True: 582, False: 1.25k]
  ------------------
 2104|  1.83k|	  (ctxt->myDoc->intSubset->attributes == NULL) &&
  ------------------
  |  Branch (2104:4): [True: 582, False: 0]
  ------------------
 2105|  1.83k|	  (ctxt->myDoc->intSubset->entities == NULL)))) {
  ------------------
  |  Branch (2105:4): [True: 126, False: 456]
  ------------------
 2106|    465|	xmlErrValid(ctxt, XML_DTD_NO_DTD,
 2107|    465|	  "Validation failed: no DTD found !", NULL, NULL);
 2108|    465|	ctxt->validate = 0;
 2109|    465|    }
 2110|       |
 2111|       |    /*
 2112|       |     * Take care of the rare case of an undefined namespace prefix
 2113|       |     */
 2114|  57.3k|    if ((prefix != NULL) && (URI == NULL)) {
  ------------------
  |  Branch (2114:9): [True: 1.89k, False: 55.4k]
  |  Branch (2114:29): [True: 12, False: 1.88k]
  ------------------
 2115|     12|        if (ctxt->dictNames) {
  ------------------
  |  Branch (2115:13): [True: 12, False: 0]
  ------------------
 2116|     12|	    const xmlChar *fullname;
 2117|       |
 2118|     12|	    fullname = xmlDictQLookup(ctxt->dict, prefix, localname);
 2119|     12|	    if (fullname != NULL)
  ------------------
  |  Branch (2119:10): [True: 12, False: 0]
  ------------------
 2120|     12|	        localname = fullname;
 2121|     12|	} else {
 2122|      0|	    lname = xmlBuildQName(localname, prefix, NULL, 0);
 2123|      0|	}
 2124|     12|    }
 2125|       |    /*
 2126|       |     * allocate the node
 2127|       |     */
 2128|  57.3k|    if (ctxt->freeElems != NULL) {
  ------------------
  |  Branch (2128:9): [True: 836, False: 56.4k]
  ------------------
 2129|    836|        ret = ctxt->freeElems;
 2130|    836|	ctxt->freeElems = ret->next;
 2131|    836|	ctxt->freeElemsNr--;
 2132|    836|	memset(ret, 0, sizeof(xmlNode));
 2133|    836|        ret->doc = ctxt->myDoc;
 2134|    836|	ret->type = XML_ELEMENT_NODE;
 2135|       |
 2136|    836|	if (ctxt->dictNames)
  ------------------
  |  Branch (2136:6): [True: 836, False: 0]
  ------------------
 2137|    836|	    ret->name = localname;
 2138|      0|	else {
 2139|      0|	    if (lname == NULL)
  ------------------
  |  Branch (2139:10): [True: 0, False: 0]
  ------------------
 2140|      0|		ret->name = xmlStrdup(localname);
 2141|      0|	    else
 2142|      0|	        ret->name = lname;
 2143|      0|	    if (ret->name == NULL) {
  ------------------
  |  Branch (2143:10): [True: 0, False: 0]
  ------------------
 2144|      0|	        xmlSAX2ErrMemory(ctxt, "xmlSAX2StartElementNs");
 2145|      0|                xmlFree(ret);
 2146|      0|		return;
 2147|      0|	    }
 2148|      0|	}
 2149|    836|	if ((__xmlRegisterCallbacks) && (xmlRegisterNodeDefaultValue))
  ------------------
  |  |  682|      0|    XML_GLOBAL_MACRO(xmlRegisterNodeDefaultValue)
  |  |  ------------------
  |  |  |  |  500|      0|  #define XML_GLOBAL_MACRO(name) (*__##name())
  |  |  ------------------
  ------------------
  |  Branch (2149:6): [True: 0, False: 836]
  |  Branch (2149:34): [True: 0, False: 0]
  ------------------
 2150|      0|	    xmlRegisterNodeDefaultValue(ret);
  ------------------
  |  |  682|      0|    XML_GLOBAL_MACRO(xmlRegisterNodeDefaultValue)
  |  |  ------------------
  |  |  |  |  500|      0|  #define XML_GLOBAL_MACRO(name) (*__##name())
  |  |  ------------------
  ------------------
 2151|  56.4k|    } else {
 2152|  56.4k|	if (ctxt->dictNames)
  ------------------
  |  Branch (2152:6): [True: 56.4k, False: 0]
  ------------------
 2153|  56.4k|	    ret = xmlNewDocNodeEatName(ctxt->myDoc, NULL,
 2154|  56.4k|	                               (xmlChar *) localname, NULL);
 2155|      0|	else if (lname == NULL)
  ------------------
  |  Branch (2155:11): [True: 0, False: 0]
  ------------------
 2156|      0|	    ret = xmlNewDocNode(ctxt->myDoc, NULL, localname, NULL);
 2157|      0|	else
 2158|      0|	    ret = xmlNewDocNodeEatName(ctxt->myDoc, NULL,
 2159|      0|	                               (xmlChar *) lname, NULL);
 2160|  56.4k|	if (ret == NULL) {
  ------------------
  |  Branch (2160:6): [True: 0, False: 56.4k]
  ------------------
 2161|      0|	    xmlSAX2ErrMemory(ctxt, "xmlSAX2StartElementNs");
 2162|      0|	    return;
 2163|      0|	}
 2164|  56.4k|    }
 2165|  57.3k|    if (ctxt->linenumbers) {
  ------------------
  |  Branch (2165:9): [True: 57.2k, False: 68]
  ------------------
 2166|  57.2k|	if (ctxt->input != NULL) {
  ------------------
  |  Branch (2166:6): [True: 57.2k, False: 0]
  ------------------
 2167|  57.2k|	    if ((unsigned) ctxt->input->line < (unsigned) USHRT_MAX)
  ------------------
  |  Branch (2167:10): [True: 57.2k, False: 0]
  ------------------
 2168|  57.2k|		ret->line = ctxt->input->line;
 2169|      0|	    else
 2170|      0|	        ret->line = USHRT_MAX;
 2171|  57.2k|	}
 2172|  57.2k|    }
 2173|       |
 2174|       |    /*
 2175|       |     * Build the namespace list
 2176|       |     */
 2177|  57.7k|    for (i = 0,j = 0;j < nb_namespaces;j++) {
  ------------------
  |  Branch (2177:22): [True: 412, False: 57.3k]
  ------------------
 2178|    412|        pref = namespaces[i++];
 2179|    412|	uri = namespaces[i++];
 2180|    412|	ns = xmlNewNs(NULL, uri, pref);
 2181|    412|	if (ns != NULL) {
  ------------------
  |  Branch (2181:6): [True: 412, False: 0]
  ------------------
 2182|    412|	    if (last == NULL) {
  ------------------
  |  Branch (2182:10): [True: 308, False: 104]
  ------------------
 2183|    308|	        ret->nsDef = last = ns;
 2184|    308|	    } else {
 2185|    104|	        last->next = ns;
 2186|    104|		last = ns;
 2187|    104|	    }
 2188|    412|	    if ((URI != NULL) && (prefix == pref))
  ------------------
  |  Branch (2188:10): [True: 356, False: 56]
  |  Branch (2188:27): [True: 260, False: 96]
  ------------------
 2189|    260|		ret->ns = ns;
 2190|    412|	} else {
 2191|       |            /*
 2192|       |             * any out of memory error would already have been raised
 2193|       |             * but we can't be guaranteed it's the actual error due to the
 2194|       |             * API, best is to skip in this case
 2195|       |             */
 2196|      0|	    continue;
 2197|      0|	}
 2198|       |
 2199|    412|        xmlParserNsUpdateSax(ctxt, pref, ns);
 2200|       |
 2201|    412|#ifdef LIBXML_VALID_ENABLED
 2202|    412|	if ((!ctxt->html) && ctxt->validate && ctxt->wellFormed &&
  ------------------
  |  Branch (2202:6): [True: 412, False: 0]
  |  Branch (2202:23): [True: 51, False: 361]
  |  Branch (2202:41): [True: 51, False: 0]
  ------------------
 2203|    412|	    ctxt->myDoc && ctxt->myDoc->intSubset) {
  ------------------
  |  Branch (2203:6): [True: 51, False: 0]
  |  Branch (2203:21): [True: 51, False: 0]
  ------------------
 2204|     51|	    ctxt->valid &= xmlValidateOneNamespace(&ctxt->vctxt, ctxt->myDoc,
 2205|     51|	                                           ret, prefix, ns, uri);
 2206|     51|	}
 2207|    412|#endif /* LIBXML_VALID_ENABLED */
 2208|    412|    }
 2209|  57.3k|    ctxt->nodemem = -1;
 2210|       |
 2211|       |    /* Initialize parent before pushing node */
 2212|  57.3k|    parent = ctxt->node;
 2213|  57.3k|    if (parent == NULL)
  ------------------
  |  Branch (2213:9): [True: 1.13k, False: 56.1k]
  ------------------
 2214|  1.13k|        parent = (xmlNodePtr) ctxt->myDoc;
 2215|       |
 2216|       |    /*
 2217|       |     * We are parsing a new node.
 2218|       |     */
 2219|  57.3k|    if (nodePush(ctxt, ret) < 0) {
  ------------------
  |  Branch (2219:9): [True: 0, False: 57.3k]
  ------------------
 2220|      0|        xmlUnlinkNode(ret);
 2221|      0|        xmlFreeNode(ret);
 2222|      0|        return;
 2223|      0|    }
 2224|       |
 2225|       |    /*
 2226|       |     * Link the child element
 2227|       |     */
 2228|  57.3k|    xmlAddChild(parent, ret);
 2229|       |
 2230|       |    /*
 2231|       |     * Insert the defaulted attributes from the DTD only if requested:
 2232|       |     */
 2233|  57.3k|    if ((nb_defaulted != 0) &&
  ------------------
  |  Branch (2233:9): [True: 1.45k, False: 55.8k]
  ------------------
 2234|  57.3k|        ((ctxt->loadsubset & XML_COMPLETE_ATTRS) == 0))
  ------------------
  |  |  150|  1.45k|#define XML_COMPLETE_ATTRS	4
  ------------------
  |  Branch (2234:9): [True: 1.45k, False: 0]
  ------------------
 2235|  1.45k|	nb_attributes -= nb_defaulted;
 2236|       |
 2237|       |    /*
 2238|       |     * Search the namespace if it wasn't already found
 2239|       |     * Note that, if prefix is NULL, this searches for the default Ns
 2240|       |     */
 2241|  57.3k|    if ((URI != NULL) && (ret->ns == NULL)) {
  ------------------
  |  Branch (2241:9): [True: 2.31k, False: 55.0k]
  |  Branch (2241:26): [True: 2.05k, False: 260]
  ------------------
 2242|  2.05k|        ret->ns = xmlParserNsLookupSax(ctxt, prefix);
 2243|  2.05k|	if ((ret->ns == NULL) && (xmlStrEqual(prefix, BAD_CAST "xml"))) {
  ------------------
  |  |   35|     12|#define BAD_CAST (xmlChar *)
  ------------------
  |  Branch (2243:6): [True: 12, False: 2.04k]
  |  Branch (2243:27): [True: 4, False: 8]
  ------------------
 2244|      4|	    ret->ns = xmlSearchNs(ctxt->myDoc, ret, prefix);
 2245|      4|	}
 2246|  2.05k|	if (ret->ns == NULL) {
  ------------------
  |  Branch (2246:6): [True: 8, False: 2.04k]
  ------------------
 2247|      8|	    ns = xmlNewNs(ret, NULL, prefix);
 2248|      8|	    if (ns == NULL) {
  ------------------
  |  Branch (2248:10): [True: 0, False: 8]
  ------------------
 2249|       |
 2250|      0|	        xmlSAX2ErrMemory(ctxt, "xmlSAX2StartElementNs");
 2251|      0|		return;
 2252|      0|	    }
 2253|      8|            if (prefix != NULL)
  ------------------
  |  Branch (2253:17): [True: 4, False: 4]
  ------------------
 2254|      4|                xmlNsWarnMsg(ctxt, XML_NS_ERR_UNDEFINED_NAMESPACE,
 2255|      4|                             "Namespace prefix %s was not found\n",
 2256|      4|                             prefix, NULL);
 2257|      4|            else
 2258|      4|                xmlNsWarnMsg(ctxt, XML_NS_ERR_UNDEFINED_NAMESPACE,
 2259|      4|                             "Namespace default prefix was not found\n",
 2260|      4|                             NULL, NULL);
 2261|      8|	}
 2262|  2.05k|    }
 2263|       |
 2264|       |    /*
 2265|       |     * process all the other attributes
 2266|       |     */
 2267|  57.3k|    if (nb_attributes > 0) {
  ------------------
  |  Branch (2267:9): [True: 46.2k, False: 11.1k]
  ------------------
 2268|  46.2k|        xmlAttrPtr prev = NULL;
 2269|       |
 2270|   131k|        for (j = 0,i = 0;i < nb_attributes;i++,j+=5) {
  ------------------
  |  Branch (2270:26): [True: 85.4k, False: 46.2k]
  ------------------
 2271|  85.4k|            xmlAttrPtr attr = NULL;
 2272|       |
 2273|       |	    /*
 2274|       |	     * Handle the rare case of an undefined attribute prefix
 2275|       |	     */
 2276|  85.4k|	    if ((attributes[j+1] != NULL) && (attributes[j+2] == NULL)) {
  ------------------
  |  Branch (2276:10): [True: 804, False: 84.6k]
  |  Branch (2276:39): [True: 0, False: 804]
  ------------------
 2277|      0|		if (ctxt->dictNames) {
  ------------------
  |  Branch (2277:7): [True: 0, False: 0]
  ------------------
 2278|      0|		    const xmlChar *fullname;
 2279|       |
 2280|      0|		    fullname = xmlDictQLookup(ctxt->dict, attributes[j+1],
 2281|      0|		                              attributes[j]);
 2282|      0|		    if (fullname != NULL) {
  ------------------
  |  Branch (2282:11): [True: 0, False: 0]
  ------------------
 2283|      0|                        attr = xmlSAX2AttributeNs(ctxt, fullname, NULL,
 2284|      0|                                                  attributes[j+3],
 2285|      0|                                                  attributes[j+4]);
 2286|      0|                        goto have_attr;
 2287|      0|		    }
 2288|      0|		} else {
 2289|      0|		    lname = xmlBuildQName(attributes[j], attributes[j+1],
 2290|      0|		                          NULL, 0);
 2291|      0|		    if (lname != NULL) {
  ------------------
  |  Branch (2291:11): [True: 0, False: 0]
  ------------------
 2292|      0|                        attr = xmlSAX2AttributeNs(ctxt, lname, NULL,
 2293|      0|                                                  attributes[j+3],
 2294|      0|                                                  attributes[j+4]);
 2295|      0|			xmlFree(lname);
 2296|      0|                        goto have_attr;
 2297|      0|		    }
 2298|      0|		}
 2299|      0|	    }
 2300|  85.4k|            attr = xmlSAX2AttributeNs(ctxt, attributes[j], attributes[j+1],
 2301|  85.4k|                                      attributes[j+3], attributes[j+4]);
 2302|  85.4k|have_attr:
 2303|  85.4k|            if (attr == NULL)
  ------------------
  |  Branch (2303:17): [True: 0, False: 85.4k]
  ------------------
 2304|      0|                continue;
 2305|       |
 2306|       |            /* link at the end to preserve order */
 2307|  85.4k|            if (prev == NULL) {
  ------------------
  |  Branch (2307:17): [True: 46.2k, False: 39.2k]
  ------------------
 2308|  46.2k|                ctxt->node->properties = attr;
 2309|  46.2k|            } else {
 2310|  39.2k|                prev->next = attr;
 2311|  39.2k|                attr->prev = prev;
 2312|  39.2k|            }
 2313|       |
 2314|  85.4k|            prev = attr;
 2315|  85.4k|	}
 2316|  46.2k|    }
 2317|       |
 2318|  57.3k|#ifdef LIBXML_VALID_ENABLED
 2319|       |    /*
 2320|       |     * If it's the Document root, finish the DTD validation and
 2321|       |     * check the document root element for validity
 2322|       |     */
 2323|  57.3k|    if ((ctxt->validate) &&
  ------------------
  |  Branch (2323:9): [True: 10.3k, False: 46.9k]
  ------------------
 2324|  57.3k|        ((ctxt->vctxt.flags & XML_VCTXT_DTD_VALIDATED) == 0)) {
  ------------------
  |  |   12|  10.3k|#define XML_VCTXT_DTD_VALIDATED (1u << 0)
  ------------------
  |  Branch (2324:9): [True: 384, False: 10.0k]
  ------------------
 2325|    384|	int chk;
 2326|       |
 2327|    384|	chk = xmlValidateDtdFinal(&ctxt->vctxt, ctxt->myDoc);
 2328|    384|	if (chk <= 0)
  ------------------
  |  Branch (2328:6): [True: 3, False: 381]
  ------------------
 2329|      3|	    ctxt->valid = 0;
 2330|    384|	if (chk < 0)
  ------------------
  |  Branch (2330:6): [True: 0, False: 384]
  ------------------
 2331|      0|	    ctxt->wellFormed = 0;
 2332|    384|	ctxt->valid &= xmlValidateRoot(&ctxt->vctxt, ctxt->myDoc);
 2333|    384|	ctxt->vctxt.flags |= XML_VCTXT_DTD_VALIDATED;
  ------------------
  |  |   12|    384|#define XML_VCTXT_DTD_VALIDATED (1u << 0)
  ------------------
 2334|    384|    }
 2335|  57.3k|#endif /* LIBXML_VALID_ENABLED */
 2336|  57.3k|}
xmlSAX2EndElementNs:
 2353|  57.2k|{
 2354|  57.2k|    xmlParserCtxtPtr ctxt = (xmlParserCtxtPtr) ctx;
 2355|       |
 2356|  57.2k|    if (ctx == NULL) return;
  ------------------
  |  Branch (2356:9): [True: 0, False: 57.2k]
  ------------------
 2357|  57.2k|    ctxt->nodemem = -1;
 2358|       |
 2359|  57.2k|#ifdef LIBXML_VALID_ENABLED
 2360|  57.2k|    if (ctxt->validate && ctxt->wellFormed &&
  ------------------
  |  Branch (2360:9): [True: 10.3k, False: 46.8k]
  |  Branch (2360:27): [True: 10.3k, False: 0]
  ------------------
 2361|  57.2k|        ctxt->myDoc && ctxt->myDoc->intSubset)
  ------------------
  |  Branch (2361:9): [True: 10.3k, False: 0]
  |  Branch (2361:24): [True: 10.3k, False: 0]
  ------------------
 2362|  10.3k|        ctxt->valid &= xmlValidateOneElement(&ctxt->vctxt, ctxt->myDoc,
 2363|  10.3k|                                             ctxt->node);
 2364|  57.2k|#endif /* LIBXML_VALID_ENABLED */
 2365|       |
 2366|       |    /*
 2367|       |     * end of parsing of this node.
 2368|       |     */
 2369|  57.2k|    nodePop(ctxt);
 2370|  57.2k|}
xmlSAX2Reference:
 2381|      4|{
 2382|      4|    xmlParserCtxtPtr ctxt = (xmlParserCtxtPtr) ctx;
 2383|      4|    xmlNodePtr ret;
 2384|       |
 2385|      4|    if (ctx == NULL) return;
  ------------------
  |  Branch (2385:9): [True: 0, False: 4]
  ------------------
 2386|      4|    ret = xmlNewReference(ctxt->myDoc, name);
 2387|      4|    if (xmlAddChild(ctxt->node, ret) == NULL) {
  ------------------
  |  Branch (2387:9): [True: 0, False: 4]
  ------------------
 2388|      0|        xmlFreeNode(ret);
 2389|      0|    }
 2390|      4|}
xmlSAX2Characters:
 2541|  73.4k|{
 2542|  73.4k|    xmlSAX2Text((xmlParserCtxtPtr) ctx, ch, len, XML_TEXT_NODE);
 2543|  73.4k|}
xmlSAX2ProcessingInstruction:
 2570|     84|{
 2571|     84|    xmlParserCtxtPtr ctxt = (xmlParserCtxtPtr) ctx;
 2572|     84|    xmlNodePtr ret;
 2573|     84|    xmlNodePtr parent;
 2574|       |
 2575|     84|    if (ctx == NULL) return;
  ------------------
  |  Branch (2575:9): [True: 0, False: 84]
  ------------------
 2576|     84|    parent = ctxt->node;
 2577|       |
 2578|     84|    ret = xmlNewDocPI(ctxt->myDoc, target, data);
 2579|     84|    if (ret == NULL) return;
  ------------------
  |  Branch (2579:9): [True: 0, False: 84]
  ------------------
 2580|       |
 2581|     84|    if (ctxt->linenumbers) {
  ------------------
  |  Branch (2581:9): [True: 84, False: 0]
  ------------------
 2582|     84|	if (ctxt->input != NULL) {
  ------------------
  |  Branch (2582:6): [True: 84, False: 0]
  ------------------
 2583|     84|	    if ((unsigned) ctxt->input->line < (unsigned) USHRT_MAX)
  ------------------
  |  Branch (2583:10): [True: 84, False: 0]
  ------------------
 2584|     84|		ret->line = ctxt->input->line;
 2585|      0|	    else
 2586|      0|	        ret->line = USHRT_MAX;
 2587|     84|	}
 2588|     84|    }
 2589|     84|    if (ctxt->inSubset == 1) {
  ------------------
  |  Branch (2589:9): [True: 0, False: 84]
  ------------------
 2590|      0|	xmlAddChild((xmlNodePtr) ctxt->myDoc->intSubset, ret);
 2591|      0|	return;
 2592|     84|    } else if (ctxt->inSubset == 2) {
  ------------------
  |  Branch (2592:16): [True: 0, False: 84]
  ------------------
 2593|      0|	xmlAddChild((xmlNodePtr) ctxt->myDoc->extSubset, ret);
 2594|      0|	return;
 2595|      0|    }
 2596|     84|    if (parent == NULL) {
  ------------------
  |  Branch (2596:9): [True: 52, False: 32]
  ------------------
 2597|     52|        xmlAddChild((xmlNodePtr) ctxt->myDoc, (xmlNodePtr) ret);
 2598|     52|	return;
 2599|     52|    }
 2600|     32|    if (parent->type == XML_ELEMENT_NODE) {
  ------------------
  |  Branch (2600:9): [True: 32, False: 0]
  ------------------
 2601|     32|	xmlAddChild(parent, ret);
 2602|     32|    } else {
 2603|      0|	xmlAddSibling(parent, ret);
 2604|      0|    }
 2605|     32|}
xmlSAX2Comment:
 2616|   643k|{
 2617|   643k|    xmlParserCtxtPtr ctxt = (xmlParserCtxtPtr) ctx;
 2618|   643k|    xmlNodePtr ret;
 2619|   643k|    xmlNodePtr parent;
 2620|       |
 2621|   643k|    if (ctx == NULL) return;
  ------------------
  |  Branch (2621:9): [True: 0, False: 643k]
  ------------------
 2622|   643k|    parent = ctxt->node;
 2623|   643k|    ret = xmlNewDocComment(ctxt->myDoc, value);
 2624|   643k|    if (ret == NULL) return;
  ------------------
  |  Branch (2624:9): [True: 0, False: 643k]
  ------------------
 2625|   643k|    if (ctxt->linenumbers) {
  ------------------
  |  Branch (2625:9): [True: 643k, False: 0]
  ------------------
 2626|   643k|	if (ctxt->input != NULL) {
  ------------------
  |  Branch (2626:6): [True: 643k, False: 0]
  ------------------
 2627|   643k|	    if ((unsigned) ctxt->input->line < (unsigned) USHRT_MAX)
  ------------------
  |  Branch (2627:10): [True: 643k, False: 0]
  ------------------
 2628|   643k|		ret->line = ctxt->input->line;
 2629|      0|	    else
 2630|      0|	        ret->line = USHRT_MAX;
 2631|   643k|	}
 2632|   643k|    }
 2633|       |
 2634|   643k|    if (ctxt->inSubset == 1) {
  ------------------
  |  Branch (2634:9): [True: 641k, False: 2.08k]
  ------------------
 2635|   641k|	xmlAddChild((xmlNodePtr) ctxt->myDoc->intSubset, ret);
 2636|   641k|	return;
 2637|   641k|    } else if (ctxt->inSubset == 2) {
  ------------------
  |  Branch (2637:16): [True: 1.48k, False: 604]
  ------------------
 2638|  1.48k|	xmlAddChild((xmlNodePtr) ctxt->myDoc->extSubset, ret);
 2639|  1.48k|	return;
 2640|  1.48k|    }
 2641|    604|    if (parent == NULL) {
  ------------------
  |  Branch (2641:9): [True: 108, False: 496]
  ------------------
 2642|    108|        xmlAddChild((xmlNodePtr) ctxt->myDoc, (xmlNodePtr) ret);
 2643|    108|	return;
 2644|    108|    }
 2645|    496|    if (parent->type == XML_ELEMENT_NODE) {
  ------------------
  |  Branch (2645:9): [True: 496, False: 0]
  ------------------
 2646|    496|	xmlAddChild(parent, ret);
 2647|    496|    } else {
 2648|      0|	xmlAddSibling(parent, ret);
 2649|      0|    }
 2650|    496|}
xmlSAX2CDataBlock:
 2662|    182|{
 2663|    182|    xmlSAX2Text((xmlParserCtxtPtr) ctx, value, len, XML_CDATA_SECTION_NODE);
 2664|    182|}
xmlSAXVersion:
 2706|  2.08k|{
 2707|  2.08k|    if (hdlr == NULL) return(-1);
  ------------------
  |  Branch (2707:9): [True: 0, False: 2.08k]
  ------------------
 2708|  2.08k|    if (version == 2) {
  ------------------
  |  Branch (2708:9): [True: 2.08k, False: 0]
  ------------------
 2709|  2.08k|	hdlr->startElementNs = xmlSAX2StartElementNs;
 2710|  2.08k|	hdlr->endElementNs = xmlSAX2EndElementNs;
 2711|  2.08k|	hdlr->serror = NULL;
 2712|  2.08k|	hdlr->initialized = XML_SAX2_MAGIC;
  ------------------
  |  |  685|  2.08k|#define XML_SAX2_MAGIC 0xDEEDBEAF
  ------------------
 2713|  2.08k|#ifdef LIBXML_SAX1_ENABLED
 2714|  2.08k|    } else if (version == 1) {
  ------------------
  |  Branch (2714:16): [True: 0, False: 0]
  ------------------
 2715|      0|	hdlr->initialized = 1;
 2716|      0|#endif /* LIBXML_SAX1_ENABLED */
 2717|      0|    } else
 2718|      0|        return(-1);
 2719|  2.08k|#ifdef LIBXML_SAX1_ENABLED
 2720|  2.08k|    hdlr->startElement = xmlSAX2StartElement;
 2721|  2.08k|    hdlr->endElement = xmlSAX2EndElement;
 2722|       |#else
 2723|       |    hdlr->startElement = NULL;
 2724|       |    hdlr->endElement = NULL;
 2725|       |#endif /* LIBXML_SAX1_ENABLED */
 2726|  2.08k|    hdlr->internalSubset = xmlSAX2InternalSubset;
 2727|  2.08k|    hdlr->externalSubset = xmlSAX2ExternalSubset;
 2728|  2.08k|    hdlr->isStandalone = xmlSAX2IsStandalone;
 2729|  2.08k|    hdlr->hasInternalSubset = xmlSAX2HasInternalSubset;
 2730|  2.08k|    hdlr->hasExternalSubset = xmlSAX2HasExternalSubset;
 2731|  2.08k|    hdlr->resolveEntity = xmlSAX2ResolveEntity;
 2732|  2.08k|    hdlr->getEntity = xmlSAX2GetEntity;
 2733|  2.08k|    hdlr->getParameterEntity = xmlSAX2GetParameterEntity;
 2734|  2.08k|    hdlr->entityDecl = xmlSAX2EntityDecl;
 2735|  2.08k|    hdlr->attributeDecl = xmlSAX2AttributeDecl;
 2736|  2.08k|    hdlr->elementDecl = xmlSAX2ElementDecl;
 2737|  2.08k|    hdlr->notationDecl = xmlSAX2NotationDecl;
 2738|  2.08k|    hdlr->unparsedEntityDecl = xmlSAX2UnparsedEntityDecl;
 2739|  2.08k|    hdlr->setDocumentLocator = xmlSAX2SetDocumentLocator;
 2740|  2.08k|    hdlr->startDocument = xmlSAX2StartDocument;
 2741|  2.08k|    hdlr->endDocument = xmlSAX2EndDocument;
 2742|  2.08k|    hdlr->reference = xmlSAX2Reference;
 2743|  2.08k|    hdlr->characters = xmlSAX2Characters;
 2744|  2.08k|    hdlr->cdataBlock = xmlSAX2CDataBlock;
 2745|  2.08k|    hdlr->ignorableWhitespace = xmlSAX2Characters;
 2746|  2.08k|    hdlr->processingInstruction = xmlSAX2ProcessingInstruction;
 2747|  2.08k|    hdlr->comment = xmlSAX2Comment;
 2748|  2.08k|    hdlr->warning = xmlParserWarning;
 2749|  2.08k|    hdlr->error = xmlParserError;
 2750|  2.08k|    hdlr->fatalError = xmlParserError;
 2751|       |
 2752|  2.08k|    return(0);
 2753|  2.08k|}
SAX2.c:xmlErrValid:
   95|    473|{
   96|    473|    xmlStructuredErrorFunc schannel = NULL;
   97|       |
   98|    473|    if ((ctxt != NULL) && (ctxt->disableSAX != 0) &&
  ------------------
  |  Branch (98:9): [True: 473, False: 0]
  |  Branch (98:27): [True: 0, False: 473]
  ------------------
   99|    473|        (ctxt->instate == XML_PARSER_EOF))
  ------------------
  |  Branch (99:9): [True: 0, False: 0]
  ------------------
  100|      0|	return;
  101|    473|    if (ctxt != NULL) {
  ------------------
  |  Branch (101:9): [True: 473, False: 0]
  ------------------
  102|    473|	ctxt->errNo = error;
  103|    473|	if ((ctxt->sax != NULL) && (ctxt->sax->initialized == XML_SAX2_MAGIC))
  ------------------
  |  |  685|    473|#define XML_SAX2_MAGIC 0xDEEDBEAF
  ------------------
  |  Branch (103:6): [True: 473, False: 0]
  |  Branch (103:29): [True: 473, False: 0]
  ------------------
  104|    473|	    schannel = ctxt->sax->serror;
  105|    473|	__xmlRaiseError(schannel,
  106|    473|			ctxt->vctxt.error, ctxt->vctxt.userData,
  107|    473|			ctxt, NULL, XML_FROM_DTD, error,
  108|    473|			XML_ERR_ERROR, NULL, 0, (const char *) str1,
  109|    473|			(const char *) str2, NULL, 0, 0,
  110|    473|			msg, (const char *) str1, (const char *) str2);
  111|    473|	ctxt->valid = 0;
  112|    473|    } else {
  113|      0|	__xmlRaiseError(schannel,
  114|      0|			NULL, NULL,
  115|      0|			ctxt, NULL, XML_FROM_DTD, error,
  116|      0|			XML_ERR_ERROR, NULL, 0, (const char *) str1,
  117|      0|			(const char *) str2, NULL, 0, 0,
  118|      0|			msg, (const char *) str1, (const char *) str2);
  119|      0|    }
  120|    473|}
SAX2.c:xmlNsWarnMsg:
  190|      8|{
  191|      8|    if ((ctxt != NULL) && (ctxt->disableSAX != 0) &&
  ------------------
  |  Branch (191:9): [True: 8, False: 0]
  |  Branch (191:27): [True: 0, False: 8]
  ------------------
  192|      8|        (ctxt->instate == XML_PARSER_EOF))
  ------------------
  |  Branch (192:9): [True: 0, False: 0]
  ------------------
  193|      0|	return;
  194|      8|    if (ctxt != NULL)
  ------------------
  |  Branch (194:9): [True: 8, False: 0]
  ------------------
  195|      8|	ctxt->errNo = error;
  196|      8|    __xmlRaiseError(NULL, NULL, NULL, ctxt, NULL, XML_FROM_NAMESPACE, error,
  197|      8|                    XML_ERR_WARNING, NULL, 0,
  198|      8|		    (const char *) str1, (const char *) str2,
  199|      8|		    NULL, 0, 0, msg, str1, str2);
  200|      8|}
SAX2.c:xmlSAX2AttributeNs:
 1867|  85.4k|{
 1868|  85.4k|    xmlAttrPtr ret;
 1869|  85.4k|    xmlNsPtr namespace = NULL;
 1870|  85.4k|    xmlChar *dup = NULL;
 1871|       |
 1872|       |    /*
 1873|       |     * Note: if prefix == NULL, the attribute is not in the default namespace
 1874|       |     */
 1875|  85.4k|    if (prefix != NULL) {
  ------------------
  |  Branch (1875:9): [True: 804, False: 84.6k]
  ------------------
 1876|    804|	namespace = xmlParserNsLookupSax(ctxt, prefix);
 1877|    804|	if ((namespace == NULL) && (xmlStrEqual(prefix, BAD_CAST "xml"))) {
  ------------------
  |  |   35|     60|#define BAD_CAST (xmlChar *)
  ------------------
  |  Branch (1877:6): [True: 60, False: 744]
  |  Branch (1877:29): [True: 60, False: 0]
  ------------------
 1878|     60|	    namespace = xmlSearchNs(ctxt->myDoc, ctxt->node, prefix);
 1879|     60|	}
 1880|    804|    }
 1881|       |
 1882|       |    /*
 1883|       |     * allocate the node
 1884|       |     */
 1885|  85.4k|    if (ctxt->freeAttrs != NULL) {
  ------------------
  |  Branch (1885:9): [True: 1.19k, False: 84.2k]
  ------------------
 1886|  1.19k|        ret = ctxt->freeAttrs;
 1887|  1.19k|	ctxt->freeAttrs = ret->next;
 1888|  1.19k|	ctxt->freeAttrsNr--;
 1889|  84.2k|    } else {
 1890|  84.2k|        ret = xmlMalloc(sizeof(*ret));
 1891|  84.2k|        if (ret == NULL) {
  ------------------
  |  Branch (1891:13): [True: 0, False: 84.2k]
  ------------------
 1892|      0|            xmlSAX2ErrMemory(ctxt, NULL);
 1893|      0|            return(NULL);
 1894|      0|        }
 1895|  84.2k|    }
 1896|       |
 1897|  85.4k|    memset(ret, 0, sizeof(xmlAttr));
 1898|  85.4k|    ret->type = XML_ATTRIBUTE_NODE;
 1899|       |
 1900|  85.4k|    ret->parent = ctxt->node;
 1901|  85.4k|    ret->doc = ctxt->myDoc;
 1902|  85.4k|    ret->ns = namespace;
 1903|       |
 1904|  85.4k|    if (ctxt->dictNames)
  ------------------
  |  Branch (1904:9): [True: 85.4k, False: 0]
  ------------------
 1905|  85.4k|        ret->name = localname;
 1906|      0|    else
 1907|      0|        ret->name = xmlStrdup(localname);
 1908|       |
 1909|  85.4k|    if ((__xmlRegisterCallbacks) && (xmlRegisterNodeDefaultValue))
  ------------------
  |  |  682|      0|    XML_GLOBAL_MACRO(xmlRegisterNodeDefaultValue)
  |  |  ------------------
  |  |  |  |  500|      0|  #define XML_GLOBAL_MACRO(name) (*__##name())
  |  |  ------------------
  ------------------
  |  Branch (1909:9): [True: 0, False: 85.4k]
  |  Branch (1909:37): [True: 0, False: 0]
  ------------------
 1910|      0|        xmlRegisterNodeDefaultValue((xmlNodePtr)ret);
  ------------------
  |  |  682|      0|    XML_GLOBAL_MACRO(xmlRegisterNodeDefaultValue)
  |  |  ------------------
  |  |  |  |  500|      0|  #define XML_GLOBAL_MACRO(name) (*__##name())
  |  |  ------------------
  ------------------
 1911|       |
 1912|  85.4k|    if ((ctxt->replaceEntities == 0) && (!ctxt->html)) {
  ------------------
  |  Branch (1912:9): [True: 0, False: 85.4k]
  |  Branch (1912:41): [True: 0, False: 0]
  ------------------
 1913|      0|	xmlNodePtr tmp;
 1914|       |
 1915|       |	/*
 1916|       |	 * We know that if there is an entity reference, then
 1917|       |	 * the string has been dup'ed and terminates with 0
 1918|       |	 * otherwise with ' or "
 1919|       |	 */
 1920|      0|	if (*valueend != 0) {
  ------------------
  |  Branch (1920:6): [True: 0, False: 0]
  ------------------
 1921|      0|	    tmp = xmlSAX2TextNode(ctxt, value, valueend - value);
 1922|      0|	    ret->children = tmp;
 1923|      0|	    ret->last = tmp;
 1924|      0|	    if (tmp != NULL) {
  ------------------
  |  Branch (1924:10): [True: 0, False: 0]
  ------------------
 1925|      0|		tmp->doc = ret->doc;
 1926|      0|		tmp->parent = (xmlNodePtr) ret;
 1927|      0|	    }
 1928|      0|	} else {
 1929|      0|	    ret->children = xmlStringLenGetNodeList(ctxt->myDoc, value,
 1930|      0|						    valueend - value);
 1931|      0|	    tmp = ret->children;
 1932|      0|	    while (tmp != NULL) {
  ------------------
  |  Branch (1932:13): [True: 0, False: 0]
  ------------------
 1933|      0|	        tmp->doc = ret->doc;
 1934|      0|		tmp->parent = (xmlNodePtr) ret;
 1935|      0|		if (tmp->next == NULL)
  ------------------
  |  Branch (1935:7): [True: 0, False: 0]
  ------------------
 1936|      0|		    ret->last = tmp;
 1937|      0|		tmp = tmp->next;
 1938|      0|	    }
 1939|      0|	}
 1940|  85.4k|    } else if (value != NULL) {
  ------------------
  |  Branch (1940:16): [True: 85.4k, False: 0]
  ------------------
 1941|  85.4k|	xmlNodePtr tmp;
 1942|       |
 1943|  85.4k|	tmp = xmlSAX2TextNode(ctxt, value, valueend - value);
 1944|  85.4k|	ret->children = tmp;
 1945|  85.4k|	ret->last = tmp;
 1946|  85.4k|	if (tmp != NULL) {
  ------------------
  |  Branch (1946:6): [True: 85.4k, False: 0]
  ------------------
 1947|  85.4k|	    tmp->doc = ret->doc;
 1948|  85.4k|	    tmp->parent = (xmlNodePtr) ret;
 1949|  85.4k|	}
 1950|  85.4k|    }
 1951|       |
 1952|  85.4k|#ifdef LIBXML_VALID_ENABLED
 1953|  85.4k|    if ((!ctxt->html) && ctxt->validate && ctxt->wellFormed &&
  ------------------
  |  Branch (1953:9): [True: 85.4k, False: 0]
  |  Branch (1953:26): [True: 4.45k, False: 80.9k]
  |  Branch (1953:44): [True: 4.45k, False: 0]
  ------------------
 1954|  85.4k|        ctxt->myDoc && ctxt->myDoc->intSubset) {
  ------------------
  |  Branch (1954:9): [True: 4.45k, False: 0]
  |  Branch (1954:24): [True: 4.45k, False: 0]
  ------------------
 1955|       |	/*
 1956|       |	 * If we don't substitute entities, the validation should be
 1957|       |	 * done on a value with replaced entities anyway.
 1958|       |	 */
 1959|  4.45k|        if (!ctxt->replaceEntities) {
  ------------------
  |  Branch (1959:13): [True: 0, False: 4.45k]
  ------------------
 1960|      0|	    dup = xmlSAX2DecodeAttrEntities(ctxt, value, valueend);
 1961|      0|	    if (dup == NULL) {
  ------------------
  |  Branch (1961:10): [True: 0, False: 0]
  ------------------
 1962|      0|	        if (*valueend == 0) {
  ------------------
  |  Branch (1962:14): [True: 0, False: 0]
  ------------------
 1963|      0|		    ctxt->valid &= xmlValidateOneAttribute(&ctxt->vctxt,
 1964|      0|				    ctxt->myDoc, ctxt->node, ret, value);
 1965|      0|		} else {
 1966|       |		    /*
 1967|       |		     * That should already be normalized.
 1968|       |		     * cheaper to finally allocate here than duplicate
 1969|       |		     * entry points in the full validation code
 1970|       |		     */
 1971|      0|		    dup = xmlStrndup(value, valueend - value);
 1972|       |
 1973|      0|		    ctxt->valid &= xmlValidateOneAttribute(&ctxt->vctxt,
 1974|      0|				    ctxt->myDoc, ctxt->node, ret, dup);
 1975|      0|		}
 1976|      0|	    } else {
 1977|       |	        /*
 1978|       |		 * dup now contains a string of the flattened attribute
 1979|       |		 * content with entities substituted. Check if we need to
 1980|       |		 * apply an extra layer of normalization.
 1981|       |		 * It need to be done twice ... it's an extra burden related
 1982|       |		 * to the ability to keep references in attributes
 1983|       |		 */
 1984|      0|		if (ctxt->attsSpecial != NULL) {
  ------------------
  |  Branch (1984:7): [True: 0, False: 0]
  ------------------
 1985|      0|		    xmlChar *nvalnorm;
 1986|      0|		    xmlChar fn[50];
 1987|      0|		    xmlChar *fullname;
 1988|       |
 1989|      0|		    fullname = xmlBuildQName(localname, prefix, fn, 50);
 1990|      0|		    if (fullname != NULL) {
  ------------------
  |  Branch (1990:11): [True: 0, False: 0]
  ------------------
 1991|      0|			ctxt->vctxt.valid = 1;
 1992|      0|		        nvalnorm = xmlValidCtxtNormalizeAttributeValue(
 1993|      0|			                 &ctxt->vctxt, ctxt->myDoc,
 1994|      0|					 ctxt->node, fullname, dup);
 1995|      0|			if (ctxt->vctxt.valid != 1)
  ------------------
  |  Branch (1995:8): [True: 0, False: 0]
  ------------------
 1996|      0|			    ctxt->valid = 0;
 1997|       |
 1998|      0|			if ((fullname != fn) && (fullname != localname))
  ------------------
  |  Branch (1998:8): [True: 0, False: 0]
  |  Branch (1998:28): [True: 0, False: 0]
  ------------------
 1999|      0|			    xmlFree(fullname);
 2000|      0|			if (nvalnorm != NULL) {
  ------------------
  |  Branch (2000:8): [True: 0, False: 0]
  ------------------
 2001|      0|			    xmlFree(dup);
 2002|      0|			    dup = nvalnorm;
 2003|      0|			}
 2004|      0|		    }
 2005|      0|		}
 2006|       |
 2007|      0|		ctxt->valid &= xmlValidateOneAttribute(&ctxt->vctxt,
 2008|      0|			        ctxt->myDoc, ctxt->node, ret, dup);
 2009|      0|	    }
 2010|  4.45k|	} else {
 2011|       |	    /*
 2012|       |	     * if entities already have been substituted, then
 2013|       |	     * the attribute as passed is already normalized
 2014|       |	     */
 2015|  4.45k|	    dup = xmlStrndup(value, valueend - value);
 2016|       |
 2017|  4.45k|	    ctxt->valid &= xmlValidateOneAttribute(&ctxt->vctxt,
 2018|  4.45k|	                             ctxt->myDoc, ctxt->node, ret, dup);
 2019|  4.45k|	}
 2020|  4.45k|    } else
 2021|  80.9k|#endif /* LIBXML_VALID_ENABLED */
 2022|  80.9k|           if (((ctxt->loadsubset & XML_SKIP_IDS) == 0) &&
  ------------------
  |  |  158|  80.9k|#define XML_SKIP_IDS		8
  ------------------
  |  Branch (2022:16): [True: 80.9k, False: 4]
  ------------------
 2023|  80.9k|	       (((ctxt->replaceEntities == 0) && (ctxt->external != 2)) ||
  ------------------
  |  Branch (2023:11): [True: 0, False: 80.9k]
  |  Branch (2023:43): [True: 0, False: 0]
  ------------------
 2024|  80.9k|	        ((ctxt->replaceEntities != 0) && (ctxt->inSubset == 0))) &&
  ------------------
  |  Branch (2024:11): [True: 80.9k, False: 0]
  |  Branch (2024:43): [True: 80.9k, False: 0]
  ------------------
 2025|       |               /* Don't create IDs containing entity references */
 2026|  80.9k|               (ret->children != NULL) &&
  ------------------
  |  Branch (2026:16): [True: 80.9k, False: 0]
  ------------------
 2027|  80.9k|               (ret->children->type == XML_TEXT_NODE) &&
  ------------------
  |  Branch (2027:16): [True: 80.9k, False: 0]
  ------------------
 2028|  80.9k|               (ret->children->next == NULL)) {
  ------------------
  |  Branch (2028:16): [True: 80.9k, False: 0]
  ------------------
 2029|  80.9k|        xmlChar *content = ret->children->content;
 2030|       |        /*
 2031|       |	 * when validating, the ID registration is done at the attribute
 2032|       |	 * validation level. Otherwise we have to do specific handling here.
 2033|       |	 */
 2034|  80.9k|        if ((prefix == ctxt->str_xml) &&
  ------------------
  |  Branch (2034:13): [True: 57, False: 80.9k]
  ------------------
 2035|  80.9k|	           (localname[0] == 'i') && (localname[1] == 'd') &&
  ------------------
  |  Branch (2035:13): [True: 25, False: 32]
  |  Branch (2035:38): [True: 25, False: 0]
  ------------------
 2036|  80.9k|		   (localname[2] == 0)) {
  ------------------
  |  Branch (2036:6): [True: 25, False: 0]
  ------------------
 2037|       |	    /*
 2038|       |	     * Add the xml:id value
 2039|       |	     *
 2040|       |	     * Open issue: normalization of the value.
 2041|       |	     */
 2042|     25|	    if (xmlValidateNCName(content, 1) != 0) {
  ------------------
  |  Branch (2042:10): [True: 4, False: 21]
  ------------------
 2043|      4|	        xmlErrValid(ctxt, XML_DTD_XMLID_VALUE,
 2044|      4|		      "xml:id : attribute value %s is not an NCName\n",
 2045|      4|			    (const char *) content, NULL);
 2046|      4|	    }
 2047|     25|	    xmlAddID(&ctxt->vctxt, ctxt->myDoc, content, ret);
 2048|  80.9k|	} else if (xmlIsID(ctxt->myDoc, ctxt->node, ret)) {
  ------------------
  |  Branch (2048:13): [True: 324, False: 80.6k]
  ------------------
 2049|    324|	    xmlAddID(&ctxt->vctxt, ctxt->myDoc, content, ret);
 2050|  80.6k|	} else if (xmlIsRef(ctxt->myDoc, ctxt->node, ret)) {
  ------------------
  |  Branch (2050:13): [True: 663, False: 79.9k]
  ------------------
 2051|    663|	    xmlAddRef(&ctxt->vctxt, ctxt->myDoc, content, ret);
 2052|    663|	}
 2053|  80.9k|    }
 2054|  85.4k|    if (dup != NULL)
  ------------------
  |  Branch (2054:9): [True: 4.45k, False: 80.9k]
  ------------------
 2055|  4.45k|	xmlFree(dup);
 2056|       |
 2057|  85.4k|    return(ret);
 2058|  85.4k|}
SAX2.c:xmlSAX2TextNode:
 1749|   154k|xmlSAX2TextNode(xmlParserCtxtPtr ctxt, const xmlChar *str, int len) {
 1750|   154k|    xmlNodePtr ret;
 1751|   154k|    const xmlChar *intern = NULL;
 1752|       |
 1753|       |    /*
 1754|       |     * Allocate
 1755|       |     */
 1756|   154k|    if (ctxt->freeElems != NULL) {
  ------------------
  |  Branch (1756:9): [True: 515, False: 154k]
  ------------------
 1757|    515|	ret = ctxt->freeElems;
 1758|    515|	ctxt->freeElems = ret->next;
 1759|    515|	ctxt->freeElemsNr--;
 1760|   154k|    } else {
 1761|   154k|	ret = (xmlNodePtr) xmlMalloc(sizeof(xmlNode));
 1762|   154k|    }
 1763|   154k|    if (ret == NULL) {
  ------------------
  |  Branch (1763:9): [True: 0, False: 154k]
  ------------------
 1764|      0|        xmlErrMemory(ctxt, "xmlSAX2Characters");
 1765|      0|	return(NULL);
 1766|      0|    }
 1767|   154k|    memset(ret, 0, sizeof(xmlNode));
 1768|       |    /*
 1769|       |     * intern the formatting blanks found between tags, or the
 1770|       |     * very short strings
 1771|       |     */
 1772|   154k|    if (ctxt->dictNames) {
  ------------------
  |  Branch (1772:9): [True: 154k, False: 0]
  ------------------
 1773|   154k|        xmlChar cur = str[len];
 1774|       |
 1775|   154k|	if ((len < (int) (2 * sizeof(void *))) &&
  ------------------
  |  Branch (1775:6): [True: 144k, False: 10.1k]
  ------------------
 1776|   154k|	    (ctxt->options & XML_PARSE_COMPACT)) {
  ------------------
  |  Branch (1776:6): [True: 36.1k, False: 108k]
  ------------------
 1777|       |	    /* store the string in the node overriding properties and nsDef */
 1778|  36.1k|	    xmlChar *tmp = (xmlChar *) &(ret->properties);
 1779|  36.1k|	    memcpy(tmp, str, len);
 1780|  36.1k|	    tmp[len] = 0;
 1781|  36.1k|	    intern = tmp;
 1782|   118k|	} else if ((len <= 3) && ((cur == '"') || (cur == '\'') ||
  ------------------
  |  Branch (1782:13): [True: 25.2k, False: 93.3k]
  |  Branch (1782:28): [True: 14.1k, False: 11.0k]
  |  Branch (1782:44): [True: 60, False: 11.0k]
  ------------------
 1783|  25.2k|	    ((cur == '<') && (str[len + 1] != '!')))) {
  ------------------
  |  Branch (1783:7): [True: 10.5k, False: 456]
  |  Branch (1783:23): [True: 10.3k, False: 201]
  ------------------
 1784|  24.5k|	    intern = xmlDictLookup(ctxt->dict, str, len);
 1785|  93.9k|	} else if (IS_BLANK_CH(*str) && (len < 60) && (cur == '<') &&
  ------------------
  |  |  151|  93.9k|#define IS_BLANK_CH(c)  xmlIsBlank_ch(c)
  |  |  ------------------
  |  |  |  |   88|   187k|#define xmlIsBlank_ch(c)	(((c) == 0x20) || \
  |  |  |  |  ------------------
  |  |  |  |  |  Branch (88:27): [True: 2.88k, False: 91.0k]
  |  |  |  |  ------------------
  |  |  |  |   89|  93.9k|				 ((0x9 <= (c)) && ((c) <= 0xa)) || \
  |  |  |  |  ------------------
  |  |  |  |  |  Branch (89:7): [True: 91.0k, False: 0]
  |  |  |  |  |  Branch (89:23): [True: 32.4k, False: 58.6k]
  |  |  |  |  ------------------
  |  |  |  |   90|   187k|				 ((c) == 0xd))
  |  |  |  |  ------------------
  |  |  |  |  |  Branch (90:6): [True: 9, False: 58.6k]
  |  |  |  |  ------------------
  |  |  ------------------
  ------------------
  |  Branch (1785:34): [True: 34.1k, False: 1.24k]
  |  Branch (1785:48): [True: 33.7k, False: 427]
  ------------------
 1786|  93.9k|	           (str[len + 1] != '!')) {
  ------------------
  |  Branch (1786:13): [True: 33.4k, False: 277]
  ------------------
 1787|  33.4k|	    int i;
 1788|       |
 1789|   193k|	    for (i = 1;i < len;i++) {
  ------------------
  |  Branch (1789:17): [True: 161k, False: 31.8k]
  ------------------
 1790|   161k|		if (!IS_BLANK_CH(str[i])) goto skip;
  ------------------
  |  |  151|   161k|#define IS_BLANK_CH(c)  xmlIsBlank_ch(c)
  |  |  ------------------
  |  |  |  |   88|   161k|#define xmlIsBlank_ch(c)	(((c) == 0x20) || \
  |  |  |  |  ------------------
  |  |  |  |  |  Branch (88:27): [True: 19.2k, False: 142k]
  |  |  |  |  ------------------
  |  |  |  |   89|   161k|				 ((0x9 <= (c)) && ((c) <= 0xa)) || \
  |  |  |  |  ------------------
  |  |  |  |  |  Branch (89:7): [True: 142k, False: 0]
  |  |  |  |  |  Branch (89:23): [True: 140k, False: 1.59k]
  |  |  |  |  ------------------
  |  |  |  |   90|   161k|				 ((c) == 0xd))
  |  |  |  |  ------------------
  |  |  |  |  |  Branch (90:6): [True: 0, False: 1.59k]
  |  |  |  |  ------------------
  |  |  ------------------
  ------------------
 1791|   161k|	    }
 1792|  31.8k|	    intern = xmlDictLookup(ctxt->dict, str, len);
 1793|  31.8k|	}
 1794|   154k|    }
 1795|   154k|skip:
 1796|   154k|    ret->type = XML_TEXT_NODE;
 1797|       |
 1798|   154k|    ret->name = xmlStringText;
 1799|   154k|    if (intern == NULL) {
  ------------------
  |  Branch (1799:9): [True: 62.1k, False: 92.5k]
  ------------------
 1800|  62.1k|	ret->content = xmlStrndup(str, len);
 1801|  62.1k|	if (ret->content == NULL) {
  ------------------
  |  Branch (1801:6): [True: 0, False: 62.1k]
  ------------------
 1802|      0|	    xmlSAX2ErrMemory(ctxt, "xmlSAX2TextNode");
 1803|      0|	    xmlFree(ret);
 1804|      0|	    return(NULL);
 1805|      0|	}
 1806|  62.1k|    } else
 1807|  92.5k|	ret->content = (xmlChar *) intern;
 1808|       |
 1809|   154k|    if ((__xmlRegisterCallbacks) && (xmlRegisterNodeDefaultValue))
  ------------------
  |  |  682|      0|    XML_GLOBAL_MACRO(xmlRegisterNodeDefaultValue)
  |  |  ------------------
  |  |  |  |  500|      0|  #define XML_GLOBAL_MACRO(name) (*__##name())
  |  |  ------------------
  ------------------
  |  Branch (1809:9): [True: 0, False: 154k]
  |  Branch (1809:37): [True: 0, False: 0]
  ------------------
 1810|      0|	xmlRegisterNodeDefaultValue(ret);
  ------------------
  |  |  682|      0|    XML_GLOBAL_MACRO(xmlRegisterNodeDefaultValue)
  |  |  ------------------
  |  |  |  |  500|      0|  #define XML_GLOBAL_MACRO(name) (*__##name())
  |  |  ------------------
  ------------------
 1811|   154k|    return(ret);
 1812|   154k|}
SAX2.c:xmlSAX2Text:
 2404|  73.6k|{
 2405|  73.6k|    xmlNodePtr lastChild;
 2406|       |
 2407|  73.6k|    if (ctxt == NULL) return;
  ------------------
  |  Branch (2407:9): [True: 0, False: 73.6k]
  ------------------
 2408|       |    /*
 2409|       |     * Handle the data if any. If there is no child
 2410|       |     * add it as content, otherwise if the last child is text,
 2411|       |     * concatenate it, else create a new node of type text.
 2412|       |     */
 2413|       |
 2414|  73.6k|    if (ctxt->node == NULL) {
  ------------------
  |  Branch (2414:9): [True: 0, False: 73.6k]
  ------------------
 2415|      0|        return;
 2416|      0|    }
 2417|  73.6k|    lastChild = ctxt->node->last;
 2418|       |
 2419|       |    /*
 2420|       |     * Here we needed an accelerator mechanism in case of very large
 2421|       |     * elements. Use an attribute in the structure !!!
 2422|       |     */
 2423|  73.6k|    if (lastChild == NULL) {
  ------------------
  |  Branch (2423:9): [True: 14.7k, False: 58.8k]
  ------------------
 2424|  14.7k|        if (type == XML_TEXT_NODE)
  ------------------
  |  Branch (2424:13): [True: 14.6k, False: 116]
  ------------------
 2425|  14.6k|            lastChild = xmlSAX2TextNode(ctxt, ch, len);
 2426|    116|        else
 2427|    116|            lastChild = xmlNewCDataBlock(ctxt->myDoc, ch, len);
 2428|  14.7k|	if (lastChild != NULL) {
  ------------------
  |  Branch (2428:6): [True: 14.7k, False: 0]
  ------------------
 2429|  14.7k|	    ctxt->node->children = lastChild;
 2430|  14.7k|	    ctxt->node->last = lastChild;
 2431|  14.7k|	    lastChild->parent = ctxt->node;
 2432|  14.7k|	    lastChild->doc = ctxt->node->doc;
 2433|  14.7k|	    ctxt->nodelen = len;
 2434|  14.7k|	    ctxt->nodemem = len + 1;
 2435|  14.7k|	} else {
 2436|      0|	    xmlSAX2ErrMemory(ctxt, "xmlSAX2Characters");
 2437|      0|	    return;
 2438|      0|	}
 2439|  58.8k|    } else {
 2440|  58.8k|	int coalesceText = (lastChild != NULL) &&
  ------------------
  |  Branch (2440:21): [True: 58.8k, False: 0]
  ------------------
 2441|  58.8k|	    (lastChild->type == type) &&
  ------------------
  |  Branch (2441:6): [True: 4.20k, False: 54.6k]
  ------------------
 2442|  58.8k|	    ((type != XML_TEXT_NODE) ||
  ------------------
  |  Branch (2442:7): [True: 50, False: 4.15k]
  ------------------
 2443|  4.20k|             (lastChild->name == xmlStringText));
  ------------------
  |  Branch (2443:14): [True: 4.15k, False: 0]
  ------------------
 2444|  58.8k|	if ((coalesceText) && (ctxt->nodemem != 0)) {
  ------------------
  |  Branch (2444:6): [True: 4.20k, False: 54.6k]
  |  Branch (2444:24): [True: 2.32k, False: 1.88k]
  ------------------
 2445|       |	    /*
 2446|       |	     * The whole point of maintaining nodelen and nodemem,
 2447|       |	     * xmlTextConcat is too costly, i.e. compute length,
 2448|       |	     * reallocate a new buffer, move data, append ch. Here
 2449|       |	     * We try to minimize realloc() uses and avoid copying
 2450|       |	     * and recomputing length over and over.
 2451|       |	     */
 2452|  2.32k|	    if (lastChild->content == (xmlChar *)&(lastChild->properties)) {
  ------------------
  |  Branch (2452:10): [True: 123, False: 2.20k]
  ------------------
 2453|    123|		lastChild->content = xmlStrdup(lastChild->content);
 2454|    123|		lastChild->properties = NULL;
 2455|  2.20k|	    } else if ((ctxt->nodemem == ctxt->nodelen + 1) &&
  ------------------
  |  Branch (2455:17): [True: 712, False: 1.49k]
  ------------------
 2456|  2.20k|	               (xmlDictOwns(ctxt->dict, lastChild->content))) {
  ------------------
  |  Branch (2456:17): [True: 0, False: 712]
  ------------------
 2457|      0|		lastChild->content = xmlStrdup(lastChild->content);
 2458|      0|	    }
 2459|  2.32k|	    if (lastChild->content == NULL) {
  ------------------
  |  Branch (2459:10): [True: 0, False: 2.32k]
  ------------------
 2460|      0|		xmlSAX2ErrMemory(ctxt, "xmlSAX2Characters: xmlStrdup returned NULL");
 2461|      0|		return;
 2462|      0| 	    }
 2463|  2.32k|	    if (ctxt->nodelen > INT_MAX - len) {
  ------------------
  |  Branch (2463:10): [True: 0, False: 2.32k]
  ------------------
 2464|      0|                xmlSAX2ErrMemory(ctxt, "xmlSAX2Characters overflow prevented");
 2465|      0|                return;
 2466|      0|	    }
 2467|  2.32k|            if ((ctxt->nodelen + len > XML_MAX_TEXT_LENGTH) &&
  ------------------
  |  |   42|  2.32k|#define XML_MAX_TEXT_LENGTH 10000000
  ------------------
  |  Branch (2467:17): [True: 0, False: 2.32k]
  ------------------
 2468|  2.32k|                ((ctxt->options & XML_PARSE_HUGE) == 0)) {
  ------------------
  |  Branch (2468:17): [True: 0, False: 0]
  ------------------
 2469|      0|                xmlSAX2ErrMemory(ctxt, "xmlSAX2Characters: huge text node");
 2470|      0|                return;
 2471|      0|            }
 2472|  2.32k|	    if (ctxt->nodelen + len >= ctxt->nodemem) {
  ------------------
  |  Branch (2472:10): [True: 1.03k, False: 1.28k]
  ------------------
 2473|  1.03k|		xmlChar *newbuf;
 2474|  1.03k|		int size;
 2475|       |
 2476|  1.03k|		size = ctxt->nodemem > INT_MAX - len ?
  ------------------
  |  Branch (2476:10): [True: 0, False: 1.03k]
  ------------------
 2477|      0|                       INT_MAX :
 2478|  1.03k|                       ctxt->nodemem + len;
 2479|  1.03k|		size = size > INT_MAX / 2 ? INT_MAX : size * 2;
  ------------------
  |  Branch (2479:10): [True: 0, False: 1.03k]
  ------------------
 2480|  1.03k|                newbuf = (xmlChar *) xmlRealloc(lastChild->content,size);
 2481|  1.03k|		if (newbuf == NULL) {
  ------------------
  |  Branch (2481:7): [True: 0, False: 1.03k]
  ------------------
 2482|      0|		    xmlSAX2ErrMemory(ctxt, "xmlSAX2Characters");
 2483|      0|		    return;
 2484|      0|		}
 2485|  1.03k|		ctxt->nodemem = size;
 2486|  1.03k|		lastChild->content = newbuf;
 2487|  1.03k|	    }
 2488|  2.32k|	    memcpy(&lastChild->content[ctxt->nodelen], ch, len);
 2489|  2.32k|	    ctxt->nodelen += len;
 2490|  2.32k|	    lastChild->content[ctxt->nodelen] = 0;
 2491|  56.5k|	} else if (coalesceText) {
  ------------------
  |  Branch (2491:13): [True: 1.88k, False: 54.6k]
  ------------------
 2492|  1.88k|	    if (xmlTextConcat(lastChild, ch, len)) {
  ------------------
  |  Branch (2492:10): [True: 0, False: 1.88k]
  ------------------
 2493|      0|		xmlSAX2ErrMemory(ctxt, "xmlSAX2Characters");
 2494|      0|	    }
 2495|  1.88k|	    if (ctxt->node->children != NULL) {
  ------------------
  |  Branch (2495:10): [True: 1.88k, False: 0]
  ------------------
 2496|  1.88k|		ctxt->nodelen = xmlStrlen(lastChild->content);
 2497|  1.88k|		ctxt->nodemem = ctxt->nodelen + 1;
 2498|  1.88k|	    }
 2499|  54.6k|	} else {
 2500|       |	    /* Mixed content, first time */
 2501|  54.6k|            if (type == XML_TEXT_NODE) {
  ------------------
  |  Branch (2501:17): [True: 54.6k, False: 16]
  ------------------
 2502|  54.6k|                lastChild = xmlSAX2TextNode(ctxt, ch, len);
 2503|  54.6k|                if (lastChild != NULL)
  ------------------
  |  Branch (2503:21): [True: 54.6k, False: 0]
  ------------------
 2504|  54.6k|                    lastChild->doc = ctxt->myDoc;
 2505|  54.6k|            } else
 2506|     16|                lastChild = xmlNewCDataBlock(ctxt->myDoc, ch, len);
 2507|  54.6k|	    if (lastChild != NULL) {
  ------------------
  |  Branch (2507:10): [True: 54.6k, False: 0]
  ------------------
 2508|  54.6k|		xmlAddChild(ctxt->node, lastChild);
 2509|  54.6k|		if (ctxt->node->children != NULL) {
  ------------------
  |  Branch (2509:7): [True: 54.6k, False: 0]
  ------------------
 2510|  54.6k|		    ctxt->nodelen = len;
 2511|  54.6k|		    ctxt->nodemem = len + 1;
 2512|  54.6k|		}
 2513|  54.6k|	    }
 2514|  54.6k|	}
 2515|  58.8k|    }
 2516|       |
 2517|  73.6k|    if ((lastChild != NULL) &&
  ------------------
  |  Branch (2517:9): [True: 73.6k, False: 0]
  ------------------
 2518|  73.6k|        (type == XML_TEXT_NODE) &&
  ------------------
  |  Branch (2518:9): [True: 73.4k, False: 182]
  ------------------
 2519|  73.6k|        (ctxt->linenumbers) &&
  ------------------
  |  Branch (2519:9): [True: 73.1k, False: 272]
  ------------------
 2520|  73.6k|        (ctxt->input != NULL)) {
  ------------------
  |  Branch (2520:9): [True: 73.1k, False: 0]
  ------------------
 2521|  73.1k|        if ((unsigned) ctxt->input->line < (unsigned) USHRT_MAX)
  ------------------
  |  Branch (2521:13): [True: 73.1k, False: 0]
  ------------------
 2522|  73.1k|            lastChild->line = ctxt->input->line;
 2523|      0|        else {
 2524|      0|            lastChild->line = USHRT_MAX;
 2525|      0|            if (ctxt->options & XML_PARSE_BIG_LINES)
  ------------------
  |  Branch (2525:17): [True: 0, False: 0]
  ------------------
 2526|      0|                lastChild->psvi = (void *) (ptrdiff_t) ctxt->input->line;
 2527|      0|        }
 2528|  73.1k|    }
 2529|  73.6k|}

xmlBufCreate:
  122|     72|xmlBufCreate(void) {
  123|     72|    xmlBufPtr ret;
  124|       |
  125|     72|    ret = (xmlBufPtr) xmlMalloc(sizeof(xmlBuf));
  126|     72|    if (ret == NULL) {
  ------------------
  |  Branch (126:9): [True: 0, False: 72]
  ------------------
  127|      0|	xmlBufMemoryError(NULL, "creating buffer");
  128|      0|        return(NULL);
  129|      0|    }
  130|     72|    ret->use = 0;
  131|     72|    ret->error = 0;
  132|     72|    ret->buffer = NULL;
  133|     72|    ret->size = xmlDefaultBufferSize;
  ------------------
  |  |  680|     72|  #define xmlDefaultBufferSize XML_GLOBAL_MACRO(xmlDefaultBufferSize)
  |  |  ------------------
  |  |  |  |  500|     72|  #define XML_GLOBAL_MACRO(name) (*__##name())
  |  |  ------------------
  ------------------
  134|     72|    UPDATE_COMPAT(ret);
  ------------------
  |  |   61|     72|     if (buf->size < INT_MAX) buf->compat_size = buf->size; \
  |  |  ------------------
  |  |  |  Branch (61:10): [True: 72, False: 0]
  |  |  ------------------
  |  |   62|     72|     else buf->compat_size = INT_MAX;			    \
  |  |   63|     72|     if (buf->use < INT_MAX) buf->compat_use = buf->use; \
  |  |  ------------------
  |  |  |  Branch (63:10): [True: 72, False: 0]
  |  |  ------------------
  |  |   64|     72|     else buf->compat_use = INT_MAX;
  ------------------
  135|     72|    ret->alloc = xmlBufferAllocScheme;
  ------------------
  |  |  679|     72|  #define xmlBufferAllocScheme XML_GLOBAL_MACRO(xmlBufferAllocScheme)
  |  |  ------------------
  |  |  |  |  500|     72|  #define XML_GLOBAL_MACRO(name) (*__##name())
  |  |  ------------------
  ------------------
  136|     72|    ret->content = (xmlChar *) xmlMallocAtomic(ret->size);
  137|     72|    if (ret->content == NULL) {
  ------------------
  |  Branch (137:9): [True: 0, False: 72]
  ------------------
  138|      0|	xmlBufMemoryError(ret, "creating buffer");
  139|      0|	xmlFree(ret);
  140|      0|        return(NULL);
  141|      0|    }
  142|     72|    ret->content[0] = 0;
  143|     72|    ret->contentIO = NULL;
  144|     72|    return(ret);
  145|     72|}
xmlBufCreateSize:
  155|  15.6k|xmlBufCreateSize(size_t size) {
  156|  15.6k|    xmlBufPtr ret;
  157|       |
  158|  15.6k|    if (size == SIZE_MAX)
  ------------------
  |  |   30|  15.6k|#define SIZE_MAX ((size_t) -1)
  ------------------
  |  Branch (158:9): [True: 0, False: 15.6k]
  ------------------
  159|      0|        return(NULL);
  160|  15.6k|    ret = (xmlBufPtr) xmlMalloc(sizeof(xmlBuf));
  161|  15.6k|    if (ret == NULL) {
  ------------------
  |  Branch (161:9): [True: 0, False: 15.6k]
  ------------------
  162|      0|	xmlBufMemoryError(NULL, "creating buffer");
  163|      0|        return(NULL);
  164|      0|    }
  165|  15.6k|    ret->use = 0;
  166|  15.6k|    ret->error = 0;
  167|  15.6k|    ret->buffer = NULL;
  168|  15.6k|    ret->alloc = xmlBufferAllocScheme;
  ------------------
  |  |  679|  15.6k|  #define xmlBufferAllocScheme XML_GLOBAL_MACRO(xmlBufferAllocScheme)
  |  |  ------------------
  |  |  |  |  500|  15.6k|  #define XML_GLOBAL_MACRO(name) (*__##name())
  |  |  ------------------
  ------------------
  169|  15.6k|    ret->size = (size ? size + 1 : 0);         /* +1 for ending null */
  ------------------
  |  Branch (169:18): [True: 15.6k, False: 0]
  ------------------
  170|  15.6k|    UPDATE_COMPAT(ret);
  ------------------
  |  |   61|  15.6k|     if (buf->size < INT_MAX) buf->compat_size = buf->size; \
  |  |  ------------------
  |  |  |  Branch (61:10): [True: 15.6k, False: 0]
  |  |  ------------------
  |  |   62|  15.6k|     else buf->compat_size = INT_MAX;			    \
  |  |   63|  15.6k|     if (buf->use < INT_MAX) buf->compat_use = buf->use; \
  |  |  ------------------
  |  |  |  Branch (63:10): [True: 15.6k, False: 0]
  |  |  ------------------
  |  |   64|  15.6k|     else buf->compat_use = INT_MAX;
  ------------------
  171|  15.6k|    if (ret->size){
  ------------------
  |  Branch (171:9): [True: 15.6k, False: 0]
  ------------------
  172|  15.6k|        ret->content = (xmlChar *) xmlMallocAtomic(ret->size);
  173|  15.6k|        if (ret->content == NULL) {
  ------------------
  |  Branch (173:13): [True: 0, False: 15.6k]
  ------------------
  174|      0|	    xmlBufMemoryError(ret, "creating buffer");
  175|      0|            xmlFree(ret);
  176|      0|            return(NULL);
  177|      0|        }
  178|  15.6k|        ret->content[0] = 0;
  179|  15.6k|    } else
  180|      0|	ret->content = NULL;
  181|  15.6k|    ret->contentIO = NULL;
  182|  15.6k|    return(ret);
  183|  15.6k|}
xmlBufDetach:
  196|      8|xmlBufDetach(xmlBufPtr buf) {
  197|      8|    xmlChar *ret;
  198|       |
  199|      8|    if (buf == NULL)
  ------------------
  |  Branch (199:9): [True: 0, False: 8]
  ------------------
  200|      0|        return(NULL);
  201|      8|    if (buf->buffer != NULL)
  ------------------
  |  Branch (201:9): [True: 0, False: 8]
  ------------------
  202|      0|        return(NULL);
  203|      8|    if (buf->error)
  ------------------
  |  Branch (203:9): [True: 0, False: 8]
  ------------------
  204|      0|        return(NULL);
  205|       |
  206|      8|    ret = buf->content;
  207|      8|    buf->content = NULL;
  208|      8|    buf->size = 0;
  209|      8|    buf->use = 0;
  210|      8|    UPDATE_COMPAT(buf);
  ------------------
  |  |   61|      8|     if (buf->size < INT_MAX) buf->compat_size = buf->size; \
  |  |  ------------------
  |  |  |  Branch (61:10): [True: 8, False: 0]
  |  |  ------------------
  |  |   62|      8|     else buf->compat_size = INT_MAX;			    \
  |  |   63|      8|     if (buf->use < INT_MAX) buf->compat_use = buf->use; \
  |  |  ------------------
  |  |  |  Branch (63:10): [True: 8, False: 0]
  |  |  ------------------
  |  |   64|      8|     else buf->compat_use = INT_MAX;
  ------------------
  211|       |
  212|      8|    return ret;
  213|      8|}
xmlBufSetAllocationScheme:
  242|  15.9k|                          xmlBufferAllocationScheme scheme) {
  243|  15.9k|    if ((buf == NULL) || (buf->error != 0)) {
  ------------------
  |  Branch (243:9): [True: 0, False: 15.9k]
  |  Branch (243:26): [True: 0, False: 15.9k]
  ------------------
  244|      0|        return(-1);
  245|      0|    }
  246|  15.9k|    if (buf->alloc == XML_BUFFER_ALLOC_IO)
  ------------------
  |  Branch (246:9): [True: 0, False: 15.9k]
  ------------------
  247|      0|        return(-1);
  248|  15.9k|    if ((scheme == XML_BUFFER_ALLOC_DOUBLEIT) ||
  ------------------
  |  Branch (248:9): [True: 15.9k, False: 0]
  ------------------
  249|  15.9k|        (scheme == XML_BUFFER_ALLOC_EXACT) ||
  ------------------
  |  Branch (249:9): [True: 0, False: 0]
  ------------------
  250|  15.9k|        (scheme == XML_BUFFER_ALLOC_HYBRID) ||
  ------------------
  |  Branch (250:9): [True: 0, False: 0]
  ------------------
  251|  15.9k|	(scheme == XML_BUFFER_ALLOC_BOUNDED)) {
  ------------------
  |  Branch (251:2): [True: 0, False: 0]
  ------------------
  252|  15.9k|	buf->alloc = scheme;
  253|  15.9k|        if (buf->buffer)
  ------------------
  |  Branch (253:13): [True: 0, False: 15.9k]
  ------------------
  254|      0|            buf->buffer->alloc = scheme;
  255|  15.9k|        return(0);
  256|  15.9k|    }
  257|       |    /*
  258|       |     * Switching a buffer ALLOC_IO has the side effect of initializing
  259|       |     * the contentIO field with the current content
  260|       |     */
  261|      0|    if (scheme == XML_BUFFER_ALLOC_IO) {
  ------------------
  |  Branch (261:9): [True: 0, False: 0]
  ------------------
  262|      0|        buf->alloc = XML_BUFFER_ALLOC_IO;
  263|      0|        buf->contentIO = buf->content;
  264|      0|    }
  265|      0|    return(-1);
  266|  15.9k|}
xmlBufFree:
  276|  15.7k|xmlBufFree(xmlBufPtr buf) {
  277|  15.7k|    if (buf == NULL) {
  ------------------
  |  Branch (277:9): [True: 0, False: 15.7k]
  ------------------
  278|      0|	return;
  279|      0|    }
  280|       |
  281|  15.7k|    if ((buf->alloc == XML_BUFFER_ALLOC_IO) &&
  ------------------
  |  Branch (281:9): [True: 0, False: 15.7k]
  ------------------
  282|  15.7k|        (buf->contentIO != NULL)) {
  ------------------
  |  Branch (282:9): [True: 0, False: 0]
  ------------------
  283|      0|        xmlFree(buf->contentIO);
  284|  15.7k|    } else if (buf->content != NULL) {
  ------------------
  |  Branch (284:16): [True: 15.7k, False: 8]
  ------------------
  285|  15.7k|        xmlFree(buf->content);
  286|  15.7k|    }
  287|  15.7k|    xmlFree(buf);
  288|  15.7k|}
xmlBufShrink:
  328|  3.48k|xmlBufShrink(xmlBufPtr buf, size_t len) {
  329|  3.48k|    if ((buf == NULL) || (buf->error != 0)) return(0);
  ------------------
  |  Branch (329:9): [True: 0, False: 3.48k]
  |  Branch (329:26): [True: 0, False: 3.48k]
  ------------------
  330|  3.48k|    CHECK_COMPAT(buf)
  ------------------
  |  |   72|  3.48k|     if (buf->size != (size_t) buf->compat_size)	    \
  |  |  ------------------
  |  |  |  Branch (72:10): [True: 0, False: 3.48k]
  |  |  ------------------
  |  |   73|  3.48k|         if (buf->compat_size < INT_MAX)		    \
  |  |  ------------------
  |  |  |  Branch (73:14): [True: 0, False: 0]
  |  |  ------------------
  |  |   74|      0|	     buf->size = buf->compat_size;		    \
  |  |   75|  3.48k|     if (buf->use != (size_t) buf->compat_use)		    \
  |  |  ------------------
  |  |  |  Branch (75:10): [True: 0, False: 3.48k]
  |  |  ------------------
  |  |   76|  3.48k|         if (buf->compat_use < INT_MAX)			    \
  |  |  ------------------
  |  |  |  Branch (76:14): [True: 0, False: 0]
  |  |  ------------------
  |  |   77|      0|	     buf->use = buf->compat_use;
  ------------------
  331|  3.48k|    if (len == 0) return(0);
  ------------------
  |  Branch (331:9): [True: 8, False: 3.47k]
  ------------------
  332|  3.47k|    if (len > buf->use) return(0);
  ------------------
  |  Branch (332:9): [True: 0, False: 3.47k]
  ------------------
  333|       |
  334|  3.47k|    buf->use -= len;
  335|  3.47k|    if ((buf->alloc == XML_BUFFER_ALLOC_IO) && (buf->contentIO != NULL)) {
  ------------------
  |  Branch (335:9): [True: 0, False: 3.47k]
  |  Branch (335:48): [True: 0, False: 0]
  ------------------
  336|       |	/*
  337|       |	 * we just move the content pointer, but also make sure
  338|       |	 * the perceived buffer size has shrunk accordingly
  339|       |	 */
  340|      0|        buf->content += len;
  341|      0|	buf->size -= len;
  342|       |
  343|       |        /*
  344|       |	 * sometimes though it maybe be better to really shrink
  345|       |	 * on IO buffers
  346|       |	 */
  347|      0|	if ((buf->alloc == XML_BUFFER_ALLOC_IO) && (buf->contentIO != NULL)) {
  ------------------
  |  Branch (347:6): [True: 0, False: 0]
  |  Branch (347:45): [True: 0, False: 0]
  ------------------
  348|      0|	    size_t start_buf = buf->content - buf->contentIO;
  349|      0|	    if (start_buf >= buf->size) {
  ------------------
  |  Branch (349:10): [True: 0, False: 0]
  ------------------
  350|      0|		memmove(buf->contentIO, &buf->content[0], buf->use);
  351|      0|		buf->content = buf->contentIO;
  352|      0|		buf->content[buf->use] = 0;
  353|      0|		buf->size += start_buf;
  354|      0|	    }
  355|      0|	}
  356|  3.47k|    } else {
  357|  3.47k|	memmove(buf->content, &buf->content[len], buf->use);
  358|  3.47k|	buf->content[buf->use] = 0;
  359|  3.47k|    }
  360|  3.47k|    UPDATE_COMPAT(buf)
  ------------------
  |  |   61|  3.47k|     if (buf->size < INT_MAX) buf->compat_size = buf->size; \
  |  |  ------------------
  |  |  |  Branch (61:10): [True: 3.47k, False: 0]
  |  |  ------------------
  |  |   62|  3.47k|     else buf->compat_size = INT_MAX;			    \
  |  |   63|  3.47k|     if (buf->use < INT_MAX) buf->compat_use = buf->use; \
  |  |  ------------------
  |  |  |  Branch (63:10): [True: 3.47k, False: 0]
  |  |  ------------------
  |  |   64|  3.47k|     else buf->compat_use = INT_MAX;
  ------------------
  361|  3.47k|    return(len);
  362|  3.47k|}
xmlBufGrow:
  443|  1.99M|xmlBufGrow(xmlBufPtr buf, int len) {
  444|  1.99M|    size_t ret;
  445|       |
  446|  1.99M|    if ((buf == NULL) || (len < 0)) return(-1);
  ------------------
  |  Branch (446:9): [True: 0, False: 1.99M]
  |  Branch (446:26): [True: 0, False: 1.99M]
  ------------------
  447|  1.99M|    if (len == 0)
  ------------------
  |  Branch (447:9): [True: 0, False: 1.99M]
  ------------------
  448|      0|        return(0);
  449|  1.99M|    ret = xmlBufGrowInternal(buf, len);
  450|  1.99M|    if (buf->error != 0)
  ------------------
  |  Branch (450:9): [True: 0, False: 1.99M]
  ------------------
  451|      0|        return(-1);
  452|  1.99M|    return(ret > INT_MAX ? INT_MAX : ret);
  ------------------
  |  Branch (452:12): [True: 0, False: 1.99M]
  ------------------
  453|  1.99M|}
xmlBufContent:
  491|  18.5k|{
  492|  18.5k|    if ((!buf) || (buf->error))
  ------------------
  |  Branch (492:9): [True: 0, False: 18.5k]
  |  Branch (492:19): [True: 0, False: 18.5k]
  ------------------
  493|      0|        return NULL;
  494|       |
  495|  18.5k|    return(buf->content);
  496|  18.5k|}
xmlBufEnd:
  509|  1.99M|{
  510|  1.99M|    if ((!buf) || (buf->error))
  ------------------
  |  Branch (510:9): [True: 0, False: 1.99M]
  |  Branch (510:19): [True: 0, False: 1.99M]
  ------------------
  511|      0|        return NULL;
  512|  1.99M|    CHECK_COMPAT(buf)
  ------------------
  |  |   72|  1.99M|     if (buf->size != (size_t) buf->compat_size)	    \
  |  |  ------------------
  |  |  |  Branch (72:10): [True: 0, False: 1.99M]
  |  |  ------------------
  |  |   73|  1.99M|         if (buf->compat_size < INT_MAX)		    \
  |  |  ------------------
  |  |  |  Branch (73:14): [True: 0, False: 0]
  |  |  ------------------
  |  |   74|      0|	     buf->size = buf->compat_size;		    \
  |  |   75|  1.99M|     if (buf->use != (size_t) buf->compat_use)		    \
  |  |  ------------------
  |  |  |  Branch (75:10): [True: 0, False: 1.99M]
  |  |  ------------------
  |  |   76|  1.99M|         if (buf->compat_use < INT_MAX)			    \
  |  |  ------------------
  |  |  |  Branch (76:14): [True: 0, False: 0]
  |  |  ------------------
  |  |   77|      0|	     buf->use = buf->compat_use;
  ------------------
  513|       |
  514|  1.99M|    return(&buf->content[buf->use]);
  515|  1.99M|}
xmlBufAddLen:
  529|  1.99M|xmlBufAddLen(xmlBufPtr buf, size_t len) {
  530|  1.99M|    if ((buf == NULL) || (buf->error))
  ------------------
  |  Branch (530:9): [True: 0, False: 1.99M]
  |  Branch (530:26): [True: 0, False: 1.99M]
  ------------------
  531|      0|        return(-1);
  532|  1.99M|    CHECK_COMPAT(buf)
  ------------------
  |  |   72|  1.99M|     if (buf->size != (size_t) buf->compat_size)	    \
  |  |  ------------------
  |  |  |  Branch (72:10): [True: 0, False: 1.99M]
  |  |  ------------------
  |  |   73|  1.99M|         if (buf->compat_size < INT_MAX)		    \
  |  |  ------------------
  |  |  |  Branch (73:14): [True: 0, False: 0]
  |  |  ------------------
  |  |   74|      0|	     buf->size = buf->compat_size;		    \
  |  |   75|  1.99M|     if (buf->use != (size_t) buf->compat_use)		    \
  |  |  ------------------
  |  |  |  Branch (75:10): [True: 0, False: 1.99M]
  |  |  ------------------
  |  |   76|  1.99M|         if (buf->compat_use < INT_MAX)			    \
  |  |  ------------------
  |  |  |  Branch (76:14): [True: 0, False: 0]
  |  |  ------------------
  |  |   77|      0|	     buf->use = buf->compat_use;
  ------------------
  533|  1.99M|    if (len >= (buf->size - buf->use))
  ------------------
  |  Branch (533:9): [True: 0, False: 1.99M]
  ------------------
  534|      0|        return(-1);
  535|  1.99M|    buf->use += len;
  536|  1.99M|    buf->content[buf->use] = 0;
  537|  1.99M|    UPDATE_COMPAT(buf)
  ------------------
  |  |   61|  1.99M|     if (buf->size < INT_MAX) buf->compat_size = buf->size; \
  |  |  ------------------
  |  |  |  Branch (61:10): [True: 1.99M, False: 0]
  |  |  ------------------
  |  |   62|  1.99M|     else buf->compat_size = INT_MAX;			    \
  |  |   63|  1.99M|     if (buf->use < INT_MAX) buf->compat_use = buf->use; \
  |  |  ------------------
  |  |  |  Branch (63:10): [True: 1.99M, False: 0]
  |  |  ------------------
  |  |   64|  1.99M|     else buf->compat_use = INT_MAX;
  ------------------
  538|  1.99M|    return(0);
  539|  1.99M|}
xmlBufUse:
  571|  25.3k|{
  572|  25.3k|    if ((!buf) || (buf->error))
  ------------------
  |  Branch (572:9): [True: 0, False: 25.3k]
  |  Branch (572:19): [True: 0, False: 25.3k]
  ------------------
  573|      0|        return 0;
  574|  25.3k|    CHECK_COMPAT(buf)
  ------------------
  |  |   72|  25.3k|     if (buf->size != (size_t) buf->compat_size)	    \
  |  |  ------------------
  |  |  |  Branch (72:10): [True: 0, False: 25.3k]
  |  |  ------------------
  |  |   73|  25.3k|         if (buf->compat_size < INT_MAX)		    \
  |  |  ------------------
  |  |  |  Branch (73:14): [True: 0, False: 0]
  |  |  ------------------
  |  |   74|      0|	     buf->size = buf->compat_size;		    \
  |  |   75|  25.3k|     if (buf->use != (size_t) buf->compat_use)		    \
  |  |  ------------------
  |  |  |  Branch (75:10): [True: 0, False: 25.3k]
  |  |  ------------------
  |  |   76|  25.3k|         if (buf->compat_use < INT_MAX)			    \
  |  |  ------------------
  |  |  |  Branch (76:14): [True: 0, False: 0]
  |  |  ------------------
  |  |   77|      0|	     buf->use = buf->compat_use;
  ------------------
  575|       |
  576|  25.3k|    return(buf->use);
  577|  25.3k|}
xmlBufAvail:
  593|  2.19k|{
  594|  2.19k|    if ((!buf) || (buf->error))
  ------------------
  |  Branch (594:9): [True: 0, False: 2.19k]
  |  Branch (594:19): [True: 0, False: 2.19k]
  ------------------
  595|      0|        return 0;
  596|  2.19k|    CHECK_COMPAT(buf)
  ------------------
  |  |   72|  2.19k|     if (buf->size != (size_t) buf->compat_size)	    \
  |  |  ------------------
  |  |  |  Branch (72:10): [True: 0, False: 2.19k]
  |  |  ------------------
  |  |   73|  2.19k|         if (buf->compat_size < INT_MAX)		    \
  |  |  ------------------
  |  |  |  Branch (73:14): [True: 0, False: 0]
  |  |  ------------------
  |  |   74|      0|	     buf->size = buf->compat_size;		    \
  |  |   75|  2.19k|     if (buf->use != (size_t) buf->compat_use)		    \
  |  |  ------------------
  |  |  |  Branch (75:10): [True: 0, False: 2.19k]
  |  |  ------------------
  |  |   76|  2.19k|         if (buf->compat_use < INT_MAX)			    \
  |  |  ------------------
  |  |  |  Branch (76:14): [True: 0, False: 0]
  |  |  ------------------
  |  |   77|      0|	     buf->use = buf->compat_use;
  ------------------
  597|       |
  598|  2.19k|    return((buf->size > buf->use) ? (buf->size - buf->use - 1) : 0);
  ------------------
  |  Branch (598:12): [True: 2.19k, False: 0]
  ------------------
  599|  2.19k|}
xmlBufIsEmpty:
  611|    132|{
  612|    132|    if ((!buf) || (buf->error))
  ------------------
  |  Branch (612:9): [True: 0, False: 132]
  |  Branch (612:19): [True: 0, False: 132]
  ------------------
  613|      0|        return(-1);
  614|    132|    CHECK_COMPAT(buf)
  ------------------
  |  |   72|    132|     if (buf->size != (size_t) buf->compat_size)	    \
  |  |  ------------------
  |  |  |  Branch (72:10): [True: 0, False: 132]
  |  |  ------------------
  |  |   73|    132|         if (buf->compat_size < INT_MAX)		    \
  |  |  ------------------
  |  |  |  Branch (73:14): [True: 0, False: 0]
  |  |  ------------------
  |  |   74|      0|	     buf->size = buf->compat_size;		    \
  |  |   75|    132|     if (buf->use != (size_t) buf->compat_use)		    \
  |  |  ------------------
  |  |  |  Branch (75:10): [True: 0, False: 132]
  |  |  ------------------
  |  |   76|    132|         if (buf->compat_use < INT_MAX)			    \
  |  |  ------------------
  |  |  |  Branch (76:14): [True: 0, False: 0]
  |  |  ------------------
  |  |   77|      0|	     buf->use = buf->compat_use;
  ------------------
  615|       |
  616|    132|    return(buf->use == 0);
  617|    132|}
xmlBufResize:
  630|     31|{
  631|     31|    size_t newSize;
  632|     31|    xmlChar* rebuf = NULL;
  633|     31|    size_t start_buf;
  634|       |
  635|     31|    if ((buf == NULL) || (buf->error))
  ------------------
  |  Branch (635:9): [True: 0, False: 31]
  |  Branch (635:26): [True: 0, False: 31]
  ------------------
  636|      0|        return(0);
  637|     31|    CHECK_COMPAT(buf)
  ------------------
  |  |   72|     31|     if (buf->size != (size_t) buf->compat_size)	    \
  |  |  ------------------
  |  |  |  Branch (72:10): [True: 0, False: 31]
  |  |  ------------------
  |  |   73|     31|         if (buf->compat_size < INT_MAX)		    \
  |  |  ------------------
  |  |  |  Branch (73:14): [True: 0, False: 0]
  |  |  ------------------
  |  |   74|      0|	     buf->size = buf->compat_size;		    \
  |  |   75|     31|     if (buf->use != (size_t) buf->compat_use)		    \
  |  |  ------------------
  |  |  |  Branch (75:10): [True: 0, False: 31]
  |  |  ------------------
  |  |   76|     31|         if (buf->compat_use < INT_MAX)			    \
  |  |  ------------------
  |  |  |  Branch (76:14): [True: 0, False: 0]
  |  |  ------------------
  |  |   77|      0|	     buf->use = buf->compat_use;
  ------------------
  638|       |
  639|     31|    if (buf->alloc == XML_BUFFER_ALLOC_BOUNDED) {
  ------------------
  |  Branch (639:9): [True: 0, False: 31]
  ------------------
  640|       |        /*
  641|       |	 * Used to provide parsing limits
  642|       |	 */
  643|      0|        if (size >= XML_MAX_TEXT_LENGTH) {
  ------------------
  |  |   42|      0|#define XML_MAX_TEXT_LENGTH 10000000
  ------------------
  |  Branch (643:13): [True: 0, False: 0]
  ------------------
  644|      0|	    xmlBufMemoryError(buf, "buffer error: text too long\n");
  645|      0|	    return(0);
  646|      0|	}
  647|      0|    }
  648|       |
  649|       |    /* Don't resize if we don't have to */
  650|     31|    if (size < buf->size)
  ------------------
  |  Branch (650:9): [True: 0, False: 31]
  ------------------
  651|      0|        return 1;
  652|       |
  653|       |    /* figure out new size */
  654|     31|    switch (buf->alloc){
  655|      0|	case XML_BUFFER_ALLOC_IO:
  ------------------
  |  Branch (655:2): [True: 0, False: 31]
  ------------------
  656|     31|	case XML_BUFFER_ALLOC_DOUBLEIT:
  ------------------
  |  Branch (656:2): [True: 31, False: 0]
  ------------------
  657|       |	    /*take care of empty case*/
  658|     31|            if (buf->size == 0) {
  ------------------
  |  Branch (658:17): [True: 0, False: 31]
  ------------------
  659|      0|                newSize = (size > SIZE_MAX - 10 ? SIZE_MAX : size + 10);
  ------------------
  |  |   30|      0|#define SIZE_MAX ((size_t) -1)
  ------------------
                              newSize = (size > SIZE_MAX - 10 ? SIZE_MAX : size + 10);
  ------------------
  |  |   30|      0|#define SIZE_MAX ((size_t) -1)
  ------------------
  |  Branch (659:28): [True: 0, False: 0]
  ------------------
  660|     31|            } else {
  661|     31|                newSize = buf->size;
  662|     31|            }
  663|     62|	    while (size > newSize) {
  ------------------
  |  Branch (663:13): [True: 31, False: 31]
  ------------------
  664|     31|	        if (newSize > SIZE_MAX / 2) {
  ------------------
  |  |   30|     31|#define SIZE_MAX ((size_t) -1)
  ------------------
  |  Branch (664:14): [True: 0, False: 31]
  ------------------
  665|      0|	            xmlBufMemoryError(buf, "growing buffer");
  666|      0|	            return 0;
  667|      0|	        }
  668|     31|	        newSize *= 2;
  669|     31|	    }
  670|     31|	    break;
  671|     31|	case XML_BUFFER_ALLOC_EXACT:
  ------------------
  |  Branch (671:2): [True: 0, False: 31]
  ------------------
  672|      0|            newSize = (size > SIZE_MAX - 10 ? SIZE_MAX : size + 10);
  ------------------
  |  |   30|      0|#define SIZE_MAX ((size_t) -1)
  ------------------
                          newSize = (size > SIZE_MAX - 10 ? SIZE_MAX : size + 10);
  ------------------
  |  |   30|      0|#define SIZE_MAX ((size_t) -1)
  ------------------
  |  Branch (672:24): [True: 0, False: 0]
  ------------------
  673|      0|	    break;
  674|      0|        case XML_BUFFER_ALLOC_HYBRID:
  ------------------
  |  Branch (674:9): [True: 0, False: 31]
  ------------------
  675|      0|            if (buf->use < BASE_BUFFER_SIZE)
  ------------------
  |  |   58|      0|#define BASE_BUFFER_SIZE 4096
  ------------------
  |  Branch (675:17): [True: 0, False: 0]
  ------------------
  676|      0|                newSize = size;
  677|      0|            else {
  678|      0|                newSize = buf->size;
  679|      0|                while (size > newSize) {
  ------------------
  |  Branch (679:24): [True: 0, False: 0]
  ------------------
  680|      0|                    if (newSize > SIZE_MAX / 2) {
  ------------------
  |  |   30|      0|#define SIZE_MAX ((size_t) -1)
  ------------------
  |  Branch (680:25): [True: 0, False: 0]
  ------------------
  681|      0|                        xmlBufMemoryError(buf, "growing buffer");
  682|      0|                        return 0;
  683|      0|                    }
  684|      0|                    newSize *= 2;
  685|      0|                }
  686|      0|            }
  687|      0|            break;
  688|       |
  689|      0|	default:
  ------------------
  |  Branch (689:2): [True: 0, False: 31]
  ------------------
  690|      0|            newSize = (size > SIZE_MAX - 10 ? SIZE_MAX : size + 10);
  ------------------
  |  |   30|      0|#define SIZE_MAX ((size_t) -1)
  ------------------
                          newSize = (size > SIZE_MAX - 10 ? SIZE_MAX : size + 10);
  ------------------
  |  |   30|      0|#define SIZE_MAX ((size_t) -1)
  ------------------
  |  Branch (690:24): [True: 0, False: 0]
  ------------------
  691|      0|	    break;
  692|     31|    }
  693|       |
  694|     31|    if ((buf->alloc == XML_BUFFER_ALLOC_IO) && (buf->contentIO != NULL)) {
  ------------------
  |  Branch (694:9): [True: 0, False: 31]
  |  Branch (694:48): [True: 0, False: 0]
  ------------------
  695|      0|        start_buf = buf->content - buf->contentIO;
  696|       |
  697|      0|        if (start_buf > newSize) {
  ------------------
  |  Branch (697:13): [True: 0, False: 0]
  ------------------
  698|       |	    /* move data back to start */
  699|      0|	    memmove(buf->contentIO, buf->content, buf->use);
  700|      0|	    buf->content = buf->contentIO;
  701|      0|	    buf->content[buf->use] = 0;
  702|      0|	    buf->size += start_buf;
  703|      0|	} else {
  704|      0|	    rebuf = (xmlChar *) xmlRealloc(buf->contentIO, start_buf + newSize);
  705|      0|	    if (rebuf == NULL) {
  ------------------
  |  Branch (705:10): [True: 0, False: 0]
  ------------------
  706|      0|		xmlBufMemoryError(buf, "growing buffer");
  707|      0|		return 0;
  708|      0|	    }
  709|      0|	    buf->contentIO = rebuf;
  710|      0|	    buf->content = rebuf + start_buf;
  711|      0|	}
  712|     31|    } else {
  713|     31|	if (buf->content == NULL) {
  ------------------
  |  Branch (713:6): [True: 0, False: 31]
  ------------------
  714|      0|	    rebuf = (xmlChar *) xmlMallocAtomic(newSize);
  715|      0|	    buf->use = 0;
  716|      0|            if (rebuf != NULL)
  ------------------
  |  Branch (716:17): [True: 0, False: 0]
  ------------------
  717|      0|	        rebuf[buf->use] = 0;
  718|     31|	} else if (buf->size - buf->use < 100) {
  ------------------
  |  Branch (718:13): [True: 15, False: 16]
  ------------------
  719|     15|	    rebuf = (xmlChar *) xmlRealloc(buf->content, newSize);
  720|     16|        } else {
  721|       |	    /*
  722|       |	     * if we are reallocating a buffer far from being full, it's
  723|       |	     * better to make a new allocation and copy only the used range
  724|       |	     * and free the old one.
  725|       |	     */
  726|     16|	    rebuf = (xmlChar *) xmlMallocAtomic(newSize);
  727|     16|	    if (rebuf != NULL) {
  ------------------
  |  Branch (727:10): [True: 16, False: 0]
  ------------------
  728|     16|		memcpy(rebuf, buf->content, buf->use);
  729|     16|		xmlFree(buf->content);
  730|     16|		rebuf[buf->use] = 0;
  731|     16|	    }
  732|     16|	}
  733|     31|	if (rebuf == NULL) {
  ------------------
  |  Branch (733:6): [True: 0, False: 31]
  ------------------
  734|      0|	    xmlBufMemoryError(buf, "growing buffer");
  735|      0|	    return 0;
  736|      0|	}
  737|     31|	buf->content = rebuf;
  738|     31|    }
  739|     31|    buf->size = newSize;
  740|     31|    UPDATE_COMPAT(buf)
  ------------------
  |  |   61|     31|     if (buf->size < INT_MAX) buf->compat_size = buf->size; \
  |  |  ------------------
  |  |  |  Branch (61:10): [True: 31, False: 0]
  |  |  ------------------
  |  |   62|     31|     else buf->compat_size = INT_MAX;			    \
  |  |   63|     31|     if (buf->use < INT_MAX) buf->compat_use = buf->use; \
  |  |  ------------------
  |  |  |  Branch (63:10): [True: 31, False: 0]
  |  |  ------------------
  |  |   64|     31|     else buf->compat_use = INT_MAX;
  ------------------
  741|       |
  742|     31|    return 1;
  743|     31|}
xmlBufAdd:
  758|  12.2k|xmlBufAdd(xmlBufPtr buf, const xmlChar *str, int len) {
  759|  12.2k|    size_t needSize;
  760|       |
  761|  12.2k|    if ((str == NULL) || (buf == NULL) || (buf->error))
  ------------------
  |  Branch (761:9): [True: 0, False: 12.2k]
  |  Branch (761:26): [True: 0, False: 12.2k]
  |  Branch (761:43): [True: 0, False: 12.2k]
  ------------------
  762|      0|	return -1;
  763|  12.2k|    CHECK_COMPAT(buf)
  ------------------
  |  |   72|  12.2k|     if (buf->size != (size_t) buf->compat_size)	    \
  |  |  ------------------
  |  |  |  Branch (72:10): [True: 0, False: 12.2k]
  |  |  ------------------
  |  |   73|  12.2k|         if (buf->compat_size < INT_MAX)		    \
  |  |  ------------------
  |  |  |  Branch (73:14): [True: 0, False: 0]
  |  |  ------------------
  |  |   74|      0|	     buf->size = buf->compat_size;		    \
  |  |   75|  12.2k|     if (buf->use != (size_t) buf->compat_use)		    \
  |  |  ------------------
  |  |  |  Branch (75:10): [True: 0, False: 12.2k]
  |  |  ------------------
  |  |   76|  12.2k|         if (buf->compat_use < INT_MAX)			    \
  |  |  ------------------
  |  |  |  Branch (76:14): [True: 0, False: 0]
  |  |  ------------------
  |  |   77|      0|	     buf->use = buf->compat_use;
  ------------------
  764|       |
  765|  12.2k|    if (len < -1) {
  ------------------
  |  Branch (765:9): [True: 0, False: 12.2k]
  ------------------
  766|      0|	return -1;
  767|      0|    }
  768|  12.2k|    if (len == 0) return 0;
  ------------------
  |  Branch (768:9): [True: 0, False: 12.2k]
  ------------------
  769|       |
  770|  12.2k|    if (len < 0)
  ------------------
  |  Branch (770:9): [True: 0, False: 12.2k]
  ------------------
  771|      0|        len = xmlStrlen(str);
  772|       |
  773|  12.2k|    if (len < 0) return -1;
  ------------------
  |  Branch (773:9): [True: 0, False: 12.2k]
  ------------------
  774|  12.2k|    if (len == 0) return 0;
  ------------------
  |  Branch (774:9): [True: 0, False: 12.2k]
  ------------------
  775|       |
  776|       |    /* Note that both buf->size and buf->use can be zero here. */
  777|  12.2k|    if ((size_t) len >= buf->size - buf->use) {
  ------------------
  |  Branch (777:9): [True: 31, False: 12.2k]
  ------------------
  778|     31|        if ((size_t) len >= SIZE_MAX - buf->use) {
  ------------------
  |  |   30|     31|#define SIZE_MAX ((size_t) -1)
  ------------------
  |  Branch (778:13): [True: 0, False: 31]
  ------------------
  779|      0|            xmlBufMemoryError(buf, "growing buffer past SIZE_MAX");
  780|      0|            return(-1);
  781|      0|        }
  782|     31|        needSize = buf->use + len + 1;
  783|     31|	if (buf->alloc == XML_BUFFER_ALLOC_BOUNDED) {
  ------------------
  |  Branch (783:6): [True: 0, False: 31]
  ------------------
  784|       |	    /*
  785|       |	     * Used to provide parsing limits
  786|       |	     */
  787|      0|	    if (needSize >= XML_MAX_TEXT_LENGTH) {
  ------------------
  |  |   42|      0|#define XML_MAX_TEXT_LENGTH 10000000
  ------------------
  |  Branch (787:10): [True: 0, False: 0]
  ------------------
  788|      0|		xmlBufMemoryError(buf, "buffer error: text too long\n");
  789|      0|		return(-1);
  790|      0|	    }
  791|      0|	}
  792|     31|        if (!xmlBufResize(buf, needSize)){
  ------------------
  |  Branch (792:13): [True: 0, False: 31]
  ------------------
  793|      0|	    xmlBufMemoryError(buf, "growing buffer");
  794|      0|            return XML_ERR_NO_MEMORY;
  795|      0|        }
  796|     31|    }
  797|       |
  798|  12.2k|    memmove(&buf->content[buf->use], str, len);
  799|  12.2k|    buf->use += len;
  800|  12.2k|    buf->content[buf->use] = 0;
  801|  12.2k|    UPDATE_COMPAT(buf)
  ------------------
  |  |   61|  12.2k|     if (buf->size < INT_MAX) buf->compat_size = buf->size; \
  |  |  ------------------
  |  |  |  Branch (61:10): [True: 12.2k, False: 0]
  |  |  ------------------
  |  |   62|  12.2k|     else buf->compat_size = INT_MAX;			    \
  |  |   63|  12.2k|     if (buf->use < INT_MAX) buf->compat_use = buf->use; \
  |  |  ------------------
  |  |  |  Branch (63:10): [True: 12.2k, False: 0]
  |  |  ------------------
  |  |   64|  12.2k|     else buf->compat_use = INT_MAX;
  ------------------
  802|  12.2k|    return 0;
  803|  12.2k|}
xmlBufResetInput:
 1019|  1.81k|xmlBufResetInput(xmlBufPtr buf, xmlParserInputPtr input) {
 1020|  1.81k|    if (input == NULL)
  ------------------
  |  Branch (1020:9): [True: 0, False: 1.81k]
  ------------------
 1021|      0|        return(-1);
 1022|  1.81k|    if ((buf == NULL) || (buf->error)) {
  ------------------
  |  Branch (1022:9): [True: 0, False: 1.81k]
  |  Branch (1022:26): [True: 0, False: 1.81k]
  ------------------
 1023|      0|        input->base = input->cur = input->end = BAD_CAST "";
  ------------------
  |  |   35|      0|#define BAD_CAST (xmlChar *)
  ------------------
 1024|      0|        return(-1);
 1025|      0|    }
 1026|  1.81k|    CHECK_COMPAT(buf)
  ------------------
  |  |   72|  1.81k|     if (buf->size != (size_t) buf->compat_size)	    \
  |  |  ------------------
  |  |  |  Branch (72:10): [True: 0, False: 1.81k]
  |  |  ------------------
  |  |   73|  1.81k|         if (buf->compat_size < INT_MAX)		    \
  |  |  ------------------
  |  |  |  Branch (73:14): [True: 0, False: 0]
  |  |  ------------------
  |  |   74|      0|	     buf->size = buf->compat_size;		    \
  |  |   75|  1.81k|     if (buf->use != (size_t) buf->compat_use)		    \
  |  |  ------------------
  |  |  |  Branch (75:10): [True: 0, False: 1.81k]
  |  |  ------------------
  |  |   76|  1.81k|         if (buf->compat_use < INT_MAX)			    \
  |  |  ------------------
  |  |  |  Branch (76:14): [True: 0, False: 0]
  |  |  ------------------
  |  |   77|      0|	     buf->use = buf->compat_use;
  ------------------
 1027|  1.81k|    input->base = input->cur = buf->content;
 1028|  1.81k|    input->end = &buf->content[buf->use];
 1029|  1.81k|    return(0);
 1030|  1.81k|}
xmlBufUpdateInput:
 1044|  2.00M|xmlBufUpdateInput(xmlBufPtr buf, xmlParserInputPtr input, size_t pos) {
 1045|  2.00M|    if (input == NULL)
  ------------------
  |  Branch (1045:9): [True: 0, False: 2.00M]
  ------------------
 1046|      0|        return(-1);
 1047|       |    /*
 1048|       |     * TODO: It might be safer to keep using the buffer content if there
 1049|       |     * was an error.
 1050|       |     */
 1051|  2.00M|    if ((buf == NULL) || (buf->error)) {
  ------------------
  |  Branch (1051:9): [True: 0, False: 2.00M]
  |  Branch (1051:26): [True: 0, False: 2.00M]
  ------------------
 1052|      0|        input->base = input->cur = input->end = BAD_CAST "";
  ------------------
  |  |   35|      0|#define BAD_CAST (xmlChar *)
  ------------------
 1053|      0|        return(-1);
 1054|      0|    }
 1055|  2.00M|    CHECK_COMPAT(buf)
  ------------------
  |  |   72|  2.00M|     if (buf->size != (size_t) buf->compat_size)	    \
  |  |  ------------------
  |  |  |  Branch (72:10): [True: 0, False: 2.00M]
  |  |  ------------------
  |  |   73|  2.00M|         if (buf->compat_size < INT_MAX)		    \
  |  |  ------------------
  |  |  |  Branch (73:14): [True: 0, False: 0]
  |  |  ------------------
  |  |   74|      0|	     buf->size = buf->compat_size;		    \
  |  |   75|  2.00M|     if (buf->use != (size_t) buf->compat_use)		    \
  |  |  ------------------
  |  |  |  Branch (75:10): [True: 0, False: 2.00M]
  |  |  ------------------
  |  |   76|  2.00M|         if (buf->compat_use < INT_MAX)			    \
  |  |  ------------------
  |  |  |  Branch (76:14): [True: 0, False: 0]
  |  |  ------------------
  |  |   77|      0|	     buf->use = buf->compat_use;
  ------------------
 1056|  2.00M|    input->base = buf->content;
 1057|  2.00M|    input->cur = input->base + pos;
 1058|  2.00M|    input->end = &buf->content[buf->use];
 1059|  2.00M|    return(0);
 1060|  2.00M|}
buf.c:xmlBufGrowInternal:
  376|  1.99M|xmlBufGrowInternal(xmlBufPtr buf, size_t len) {
  377|  1.99M|    size_t size;
  378|  1.99M|    xmlChar *newbuf;
  379|       |
  380|  1.99M|    if ((buf == NULL) || (buf->error != 0)) return(0);
  ------------------
  |  Branch (380:9): [True: 0, False: 1.99M]
  |  Branch (380:26): [True: 0, False: 1.99M]
  ------------------
  381|  1.99M|    CHECK_COMPAT(buf)
  ------------------
  |  |   72|  1.99M|     if (buf->size != (size_t) buf->compat_size)	    \
  |  |  ------------------
  |  |  |  Branch (72:10): [True: 0, False: 1.99M]
  |  |  ------------------
  |  |   73|  1.99M|         if (buf->compat_size < INT_MAX)		    \
  |  |  ------------------
  |  |  |  Branch (73:14): [True: 0, False: 0]
  |  |  ------------------
  |  |   74|      0|	     buf->size = buf->compat_size;		    \
  |  |   75|  1.99M|     if (buf->use != (size_t) buf->compat_use)		    \
  |  |  ------------------
  |  |  |  Branch (75:10): [True: 0, False: 1.99M]
  |  |  ------------------
  |  |   76|  1.99M|         if (buf->compat_use < INT_MAX)			    \
  |  |  ------------------
  |  |  |  Branch (76:14): [True: 0, False: 0]
  |  |  ------------------
  |  |   77|      0|	     buf->use = buf->compat_use;
  ------------------
  382|       |
  383|  1.99M|    if (len < buf->size - buf->use)
  ------------------
  |  Branch (383:9): [True: 1.99M, False: 212]
  ------------------
  384|  1.99M|        return(buf->size - buf->use - 1);
  385|    212|    if (len >= SIZE_MAX - buf->use) {
  ------------------
  |  |   30|    212|#define SIZE_MAX ((size_t) -1)
  ------------------
  |  Branch (385:9): [True: 0, False: 212]
  ------------------
  386|      0|        xmlBufMemoryError(buf, "growing buffer past SIZE_MAX");
  387|      0|        return(0);
  388|      0|    }
  389|       |
  390|    212|    if (buf->size > (size_t) len) {
  ------------------
  |  Branch (390:9): [True: 140, False: 72]
  ------------------
  391|    140|        size = buf->size > SIZE_MAX / 2 ? SIZE_MAX : buf->size * 2;
  ------------------
  |  |   30|    140|#define SIZE_MAX ((size_t) -1)
  ------------------
                      size = buf->size > SIZE_MAX / 2 ? SIZE_MAX : buf->size * 2;
  ------------------
  |  |   30|      0|#define SIZE_MAX ((size_t) -1)
  ------------------
  |  Branch (391:16): [True: 0, False: 140]
  ------------------
  392|    140|    } else {
  393|     72|        size = buf->use + len;
  394|     72|        size = size > SIZE_MAX - 100 ? SIZE_MAX : size + 100;
  ------------------
  |  |   30|     72|#define SIZE_MAX ((size_t) -1)
  ------------------
                      size = size > SIZE_MAX - 100 ? SIZE_MAX : size + 100;
  ------------------
  |  |   30|      0|#define SIZE_MAX ((size_t) -1)
  ------------------
  |  Branch (394:16): [True: 0, False: 72]
  ------------------
  395|     72|    }
  396|       |
  397|    212|    if (buf->alloc == XML_BUFFER_ALLOC_BOUNDED) {
  ------------------
  |  Branch (397:9): [True: 0, False: 212]
  ------------------
  398|       |        /*
  399|       |	 * Used to provide parsing limits
  400|       |	 */
  401|      0|        if ((buf->use + len + 1 >= XML_MAX_TEXT_LENGTH) ||
  ------------------
  |  |   42|      0|#define XML_MAX_TEXT_LENGTH 10000000
  ------------------
  |  Branch (401:13): [True: 0, False: 0]
  ------------------
  402|      0|	    (buf->size >= XML_MAX_TEXT_LENGTH)) {
  ------------------
  |  |   42|      0|#define XML_MAX_TEXT_LENGTH 10000000
  ------------------
  |  Branch (402:6): [True: 0, False: 0]
  ------------------
  403|      0|	    xmlBufMemoryError(buf, "buffer error: text too long\n");
  404|      0|	    return(0);
  405|      0|	}
  406|      0|	if (size >= XML_MAX_TEXT_LENGTH)
  ------------------
  |  |   42|      0|#define XML_MAX_TEXT_LENGTH 10000000
  ------------------
  |  Branch (406:6): [True: 0, False: 0]
  ------------------
  407|      0|	    size = XML_MAX_TEXT_LENGTH;
  ------------------
  |  |   42|      0|#define XML_MAX_TEXT_LENGTH 10000000
  ------------------
  408|      0|    }
  409|    212|    if ((buf->alloc == XML_BUFFER_ALLOC_IO) && (buf->contentIO != NULL)) {
  ------------------
  |  Branch (409:9): [True: 0, False: 212]
  |  Branch (409:48): [True: 0, False: 0]
  ------------------
  410|      0|        size_t start_buf = buf->content - buf->contentIO;
  411|       |
  412|      0|	newbuf = (xmlChar *) xmlRealloc(buf->contentIO, start_buf + size);
  413|      0|	if (newbuf == NULL) {
  ------------------
  |  Branch (413:6): [True: 0, False: 0]
  ------------------
  414|      0|	    xmlBufMemoryError(buf, "growing buffer");
  415|      0|	    return(0);
  416|      0|	}
  417|      0|	buf->contentIO = newbuf;
  418|      0|	buf->content = newbuf + start_buf;
  419|    212|    } else {
  420|    212|	newbuf = (xmlChar *) xmlRealloc(buf->content, size);
  421|    212|	if (newbuf == NULL) {
  ------------------
  |  Branch (421:6): [True: 0, False: 212]
  ------------------
  422|      0|	    xmlBufMemoryError(buf, "growing buffer");
  423|      0|	    return(0);
  424|      0|	}
  425|    212|	buf->content = newbuf;
  426|    212|    }
  427|    212|    buf->size = size;
  428|    212|    UPDATE_COMPAT(buf)
  ------------------
  |  |   61|    212|     if (buf->size < INT_MAX) buf->compat_size = buf->size; \
  |  |  ------------------
  |  |  |  Branch (61:10): [True: 212, False: 0]
  |  |  ------------------
  |  |   62|    212|     else buf->compat_size = INT_MAX;			    \
  |  |   63|    212|     if (buf->use < INT_MAX) buf->compat_use = buf->use; \
  |  |  ------------------
  |  |  |  Branch (63:10): [True: 212, False: 0]
  |  |  ------------------
  |  |   64|    212|     else buf->compat_use = INT_MAX;
  ------------------
  429|    212|    return(buf->size - buf->use - 1);
  430|    212|}

xmlInitializeCatalog:
 3096|      2|xmlInitializeCatalog(void) {
 3097|      2|    if (xmlCatalogInitialized != 0)
  ------------------
  |  Branch (3097:9): [True: 0, False: 2]
  ------------------
 3098|      0|	return;
 3099|       |
 3100|      2|    xmlInitializeCatalogData();
 3101|      2|    xmlRMutexLock(xmlCatalogMutex);
 3102|       |
 3103|      2|    if (getenv("XML_DEBUG_CATALOG"))
  ------------------
  |  Branch (3103:9): [True: 0, False: 2]
  ------------------
 3104|      0|	xmlDebugCatalogs = 1;
 3105|       |
 3106|      2|    if (xmlDefaultCatalog == NULL) {
  ------------------
  |  Branch (3106:9): [True: 2, False: 0]
  ------------------
 3107|      2|	const char *catalogs;
 3108|      2|	char *path;
 3109|      2|	const char *cur, *paths;
 3110|      2|	xmlCatalogPtr catal;
 3111|      2|	xmlCatalogEntryPtr *nextent;
 3112|       |
 3113|      2|	catalogs = (const char *) getenv("XML_CATALOG_FILES");
 3114|      2|	if (catalogs == NULL)
  ------------------
  |  Branch (3114:6): [True: 2, False: 0]
  ------------------
 3115|       |#if defined(_WIN32) && defined(_MSC_VER)
 3116|       |    {
 3117|       |		void* hmodule;
 3118|       |		hmodule = GetModuleHandleA("libxml2.dll");
 3119|       |		if (hmodule == NULL)
 3120|       |			hmodule = GetModuleHandleA(NULL);
 3121|       |		if (hmodule != NULL) {
 3122|       |			char buf[256];
 3123|       |			unsigned long len = GetModuleFileNameA(hmodule, buf, 255);
 3124|       |			if (len != 0) {
 3125|       |				char* p = &(buf[len]);
 3126|       |				while (*p != '\\' && p > buf)
 3127|       |					p--;
 3128|       |				if (p != buf) {
 3129|       |					xmlChar* uri;
 3130|       |					strncpy(p, "\\..\\etc\\catalog", 255 - (p - buf));
 3131|       |					uri = xmlCanonicPath((const xmlChar*)buf);
 3132|       |					if (uri != NULL) {
 3133|       |						strncpy(XML_XML_DEFAULT_CATALOG, (char* )uri, 255);
 3134|       |						xmlFree(uri);
 3135|       |					}
 3136|       |				}
 3137|       |			}
 3138|       |		}
 3139|       |		catalogs = XML_XML_DEFAULT_CATALOG;
 3140|       |    }
 3141|       |#else
 3142|      2|	    catalogs = XML_XML_DEFAULT_CATALOG;
  ------------------
  |  |   70|      2|#define XML_XML_DEFAULT_CATALOG "file://" SYSCONFDIR "/xml/catalog"
  ------------------
 3143|      2|#endif
 3144|       |
 3145|      2|	catal = xmlCreateNewCatalog(XML_XML_CATALOG_TYPE,
 3146|      2|		xmlCatalogDefaultPrefer);
 3147|      2|	if (catal != NULL) {
  ------------------
  |  Branch (3147:6): [True: 2, False: 0]
  ------------------
 3148|       |	    /* the XML_CATALOG_FILES envvar is allowed to contain a
 3149|       |	       space-separated list of entries. */
 3150|      2|	    cur = catalogs;
 3151|      2|	    nextent = &catal->xml;
 3152|      4|	    while (*cur != '\0') {
  ------------------
  |  Branch (3152:13): [True: 2, False: 2]
  ------------------
 3153|      2|		while (xmlIsBlank_ch(*cur))
  ------------------
  |  |   88|      2|#define xmlIsBlank_ch(c)	(((c) == 0x20) || \
  |  |  ------------------
  |  |  |  Branch (88:27): [True: 0, False: 2]
  |  |  ------------------
  |  |   89|      2|				 ((0x9 <= (c)) && ((c) <= 0xa)) || \
  |  |  ------------------
  |  |  |  Branch (89:7): [True: 2, False: 0]
  |  |  |  Branch (89:23): [True: 0, False: 2]
  |  |  ------------------
  |  |   90|      2|				 ((c) == 0xd))
  |  |  ------------------
  |  |  |  Branch (90:6): [True: 0, False: 2]
  |  |  ------------------
  ------------------
 3154|      0|		    cur++;
 3155|      2|		if (*cur != 0) {
  ------------------
  |  Branch (3155:7): [True: 2, False: 0]
  ------------------
 3156|      2|		    paths = cur;
 3157|     68|		    while ((*cur != 0) && (!xmlIsBlank_ch(*cur)))
  ------------------
  |  |   88|     66|#define xmlIsBlank_ch(c)	(((c) == 0x20) || \
  |  |  ------------------
  |  |  |  Branch (88:27): [True: 0, False: 66]
  |  |  ------------------
  |  |   89|     66|				 ((0x9 <= (c)) && ((c) <= 0xa)) || \
  |  |  ------------------
  |  |  |  Branch (89:7): [True: 66, False: 0]
  |  |  |  Branch (89:23): [True: 0, False: 66]
  |  |  ------------------
  |  |   90|     66|				 ((c) == 0xd))
  |  |  ------------------
  |  |  |  Branch (90:6): [True: 0, False: 66]
  |  |  ------------------
  ------------------
  |  Branch (3157:14): [True: 66, False: 2]
  ------------------
 3158|     66|			cur++;
 3159|      2|		    path = (char *) xmlStrndup((const xmlChar *)paths, cur - paths);
 3160|      2|		    if (path != NULL) {
  ------------------
  |  Branch (3160:11): [True: 2, False: 0]
  ------------------
 3161|      2|			*nextent = xmlNewCatalogEntry(XML_CATA_CATALOG, NULL,
 3162|      2|				NULL, BAD_CAST path, xmlCatalogDefaultPrefer, NULL);
  ------------------
  |  |   35|      2|#define BAD_CAST (xmlChar *)
  ------------------
 3163|      2|			if (*nextent != NULL)
  ------------------
  |  Branch (3163:8): [True: 2, False: 0]
  ------------------
 3164|      2|			    nextent = &((*nextent)->next);
 3165|      2|			xmlFree(path);
 3166|      2|		    }
 3167|      2|		}
 3168|      2|	    }
 3169|      2|	    xmlDefaultCatalog = catal;
 3170|      2|	}
 3171|      2|    }
 3172|       |
 3173|      2|    xmlRMutexUnlock(xmlCatalogMutex);
 3174|      2|}
catalog.c:xmlCreateNewCatalog:
  406|      2|xmlCreateNewCatalog(xmlCatalogType type, xmlCatalogPrefer prefer) {
  407|      2|    xmlCatalogPtr ret;
  408|       |
  409|      2|    ret = (xmlCatalogPtr) xmlMalloc(sizeof(xmlCatalog));
  410|      2|    if (ret == NULL) {
  ------------------
  |  Branch (410:9): [True: 0, False: 2]
  ------------------
  411|      0|        xmlCatalogErrMemory("allocating catalog");
  412|      0|	return(NULL);
  413|      0|    }
  414|      2|    memset(ret, 0, sizeof(xmlCatalog));
  415|      2|    ret->type = type;
  416|      2|    ret->catalNr = 0;
  417|      2|    ret->catalMax = XML_MAX_SGML_CATA_DEPTH;
  ------------------
  |  |  144|      2|#define XML_MAX_SGML_CATA_DEPTH 10
  ------------------
  418|      2|    ret->prefer = prefer;
  419|      2|    if (ret->type == XML_SGML_CATALOG_TYPE)
  ------------------
  |  Branch (419:9): [True: 0, False: 2]
  ------------------
  420|      0|	ret->sgml = xmlHashCreate(10);
  421|      2|    return(ret);
  422|      2|}
catalog.c:xmlNewCatalogEntry:
  267|      2|	   xmlCatalogEntryPtr group) {
  268|      2|    xmlCatalogEntryPtr ret;
  269|      2|    xmlChar *normid = NULL;
  270|       |
  271|      2|    ret = (xmlCatalogEntryPtr) xmlMalloc(sizeof(xmlCatalogEntry));
  272|      2|    if (ret == NULL) {
  ------------------
  |  Branch (272:9): [True: 0, False: 2]
  ------------------
  273|      0|        xmlCatalogErrMemory("allocating catalog entry");
  274|      0|	return(NULL);
  275|      0|    }
  276|      2|    ret->next = NULL;
  277|      2|    ret->parent = NULL;
  278|      2|    ret->children = NULL;
  279|      2|    ret->type = type;
  280|      2|    if (type == XML_CATA_PUBLIC || type == XML_CATA_DELEGATE_PUBLIC) {
  ------------------
  |  Branch (280:9): [True: 0, False: 2]
  |  Branch (280:36): [True: 0, False: 2]
  ------------------
  281|      0|        normid = xmlCatalogNormalizePublic(name);
  282|      0|        if (normid != NULL)
  ------------------
  |  Branch (282:13): [True: 0, False: 0]
  ------------------
  283|      0|            name = (*normid != 0 ? normid : NULL);
  ------------------
  |  Branch (283:21): [True: 0, False: 0]
  ------------------
  284|      0|    }
  285|      2|    if (name != NULL)
  ------------------
  |  Branch (285:9): [True: 0, False: 2]
  ------------------
  286|      0|	ret->name = xmlStrdup(name);
  287|      2|    else
  288|      2|	ret->name = NULL;
  289|      2|    if (normid != NULL)
  ------------------
  |  Branch (289:9): [True: 0, False: 2]
  ------------------
  290|      0|        xmlFree(normid);
  291|      2|    if (value != NULL)
  ------------------
  |  Branch (291:9): [True: 0, False: 2]
  ------------------
  292|      0|	ret->value = xmlStrdup(value);
  293|      2|    else
  294|      2|	ret->value = NULL;
  295|      2|    if (URL == NULL)
  ------------------
  |  Branch (295:9): [True: 0, False: 2]
  ------------------
  296|      0|	URL = value;
  297|      2|    if (URL != NULL)
  ------------------
  |  Branch (297:9): [True: 2, False: 0]
  ------------------
  298|      2|	ret->URL = xmlStrdup(URL);
  299|      0|    else
  300|      0|	ret->URL = NULL;
  301|      2|    ret->prefer = prefer;
  302|      2|    ret->dealloc = 0;
  303|      2|    ret->depth = 0;
  304|      2|    ret->group = group;
  305|      2|    return(ret);
  306|      2|}
catalog.c:xmlInitializeCatalogData:
 3078|      2|xmlInitializeCatalogData(void) {
 3079|      2|    if (xmlCatalogInitialized != 0)
  ------------------
  |  Branch (3079:9): [True: 0, False: 2]
  ------------------
 3080|      0|	return;
 3081|       |
 3082|      2|    if (getenv("XML_DEBUG_CATALOG"))
  ------------------
  |  Branch (3082:9): [True: 0, False: 2]
  ------------------
 3083|      0|	xmlDebugCatalogs = 1;
 3084|      2|    xmlCatalogMutex = xmlNewRMutex();
 3085|       |
 3086|      2|    xmlCatalogInitialized = 1;
 3087|      2|}

xmlInitDictInternal:
   99|      2|xmlInitDictInternal(void) {
  100|      2|    xmlInitMutex(&xmlDictMutex);
  101|      2|}
xmlDictCreate:
  262|  1.80k|xmlDictCreate(void) {
  263|  1.80k|    xmlDictPtr dict;
  264|       |
  265|  1.80k|    xmlInitParser();
  266|       |
  267|  1.80k|    dict = xmlMalloc(sizeof(xmlDict));
  268|  1.80k|    if (dict == NULL)
  ------------------
  |  Branch (268:9): [True: 0, False: 1.80k]
  ------------------
  269|      0|        return(NULL);
  270|  1.80k|    dict->ref_counter = 1;
  271|  1.80k|    dict->limit = 0;
  272|       |
  273|  1.80k|    dict->size = 0;
  274|  1.80k|    dict->nbElems = 0;
  275|  1.80k|    dict->table = NULL;
  276|  1.80k|    dict->strings = NULL;
  277|  1.80k|    dict->subdict = NULL;
  278|  1.80k|    dict->seed = xmlRandom();
  279|  1.80k|#ifdef FUZZING_BUILD_MODE_UNSAFE_FOR_PRODUCTION
  280|  1.80k|    dict->seed = 0;
  281|  1.80k|#endif
  282|  1.80k|    return(dict);
  283|  1.80k|}
xmlDictReference:
  317|  2.63k|xmlDictReference(xmlDictPtr dict) {
  318|  2.63k|    if (dict == NULL) return -1;
  ------------------
  |  Branch (318:9): [True: 0, False: 2.63k]
  ------------------
  319|  2.63k|    xmlMutexLock(&xmlDictMutex);
  320|  2.63k|    dict->ref_counter++;
  321|  2.63k|    xmlMutexUnlock(&xmlDictMutex);
  322|  2.63k|    return(0);
  323|  2.63k|}
xmlDictFree:
  333|  4.44k|xmlDictFree(xmlDictPtr dict) {
  334|  4.44k|    xmlDictStringsPtr pool, nextp;
  335|       |
  336|  4.44k|    if (dict == NULL)
  ------------------
  |  Branch (336:9): [True: 0, False: 4.44k]
  ------------------
  337|      0|	return;
  338|       |
  339|       |    /* decrement the counter, it may be shared by a parser and docs */
  340|  4.44k|    xmlMutexLock(&xmlDictMutex);
  341|  4.44k|    dict->ref_counter--;
  342|  4.44k|    if (dict->ref_counter > 0) {
  ------------------
  |  Branch (342:9): [True: 2.63k, False: 1.80k]
  ------------------
  343|  2.63k|        xmlMutexUnlock(&xmlDictMutex);
  344|  2.63k|        return;
  345|  2.63k|    }
  346|       |
  347|  1.80k|    xmlMutexUnlock(&xmlDictMutex);
  348|       |
  349|  1.80k|    if (dict->subdict != NULL) {
  ------------------
  |  Branch (349:9): [True: 0, False: 1.80k]
  ------------------
  350|      0|        xmlDictFree(dict->subdict);
  351|      0|    }
  352|       |
  353|  1.80k|    if (dict->table) {
  ------------------
  |  Branch (353:9): [True: 1.32k, False: 480]
  ------------------
  354|  1.32k|	xmlFree(dict->table);
  355|  1.32k|    }
  356|  1.80k|    pool = dict->strings;
  357|  3.18k|    while (pool != NULL) {
  ------------------
  |  Branch (357:12): [True: 1.38k, False: 1.80k]
  ------------------
  358|  1.38k|        nextp = pool->next;
  359|  1.38k|	xmlFree(pool);
  360|  1.38k|	pool = nextp;
  361|  1.38k|    }
  362|  1.80k|    xmlFree(dict);
  363|  1.80k|}
xmlDictOwns:
  376|  1.00M|xmlDictOwns(xmlDictPtr dict, const xmlChar *str) {
  377|  1.00M|    xmlDictStringsPtr pool;
  378|       |
  379|  1.00M|    if ((dict == NULL) || (str == NULL))
  ------------------
  |  Branch (379:9): [True: 0, False: 1.00M]
  |  Branch (379:27): [True: 0, False: 1.00M]
  ------------------
  380|      0|	return(-1);
  381|  1.00M|    pool = dict->strings;
  382|  1.99M|    while (pool != NULL) {
  ------------------
  |  Branch (382:12): [True: 1.25M, False: 741k]
  ------------------
  383|  1.25M|        if ((str >= &pool->array[0]) && (str <= pool->free))
  ------------------
  |  Branch (383:13): [True: 1.02M, False: 229k]
  |  Branch (383:41): [True: 266k, False: 757k]
  ------------------
  384|   266k|	    return(1);
  385|   986k|	pool = pool->next;
  386|   986k|    }
  387|   741k|    if (dict->subdict)
  ------------------
  |  Branch (387:9): [True: 0, False: 741k]
  ------------------
  388|      0|        return(xmlDictOwns(dict->subdict, str));
  389|   741k|    return(0);
  390|   741k|}
xmlDictSetLimit:
  421|  1.80k|xmlDictSetLimit(xmlDictPtr dict, size_t limit) {
  422|  1.80k|    size_t ret;
  423|       |
  424|  1.80k|    if (dict == NULL)
  ------------------
  |  Branch (424:9): [True: 0, False: 1.80k]
  ------------------
  425|      0|	return(0);
  426|  1.80k|    ret = dict->limit;
  427|  1.80k|    dict->limit = limit;
  428|  1.80k|    return(ret);
  429|  1.80k|}
xmlDictComputeHash:
  512|  2.76k|xmlDictComputeHash(const xmlDict *dict, const xmlChar *string) {
  513|  2.76k|    size_t len;
  514|  2.76k|    return(xmlDictHashName(dict->seed, string, SIZE_MAX, &len));
  ------------------
  |  |   35|  2.76k|  #define SIZE_MAX ((size_t) -1)
  ------------------
  515|  2.76k|}
xmlDictCombineHash:
  521|   255k|xmlDictCombineHash(unsigned v1, unsigned v2) {
  522|       |    /*
  523|       |     * The upper bit of hash values is always set, so we have to operate on
  524|       |     * 31-bit hashes here.
  525|       |     */
  526|   255k|    v1 ^= v2;
  527|   255k|    v1 += HASH_ROL31(v2, 5);
  ------------------
  |  |  517|   255k|#define HASH_ROL31(x,n) ((x) << (n) | ((x) & 0x7FFFFFFF) >> (31 - (n)))
  ------------------
  528|       |
  529|   255k|    return((v1 & 0xFFFFFFFF) | 0x80000000);
  530|   255k|}
xmlDictLookup:
  824|   287k|xmlDictLookup(xmlDictPtr dict, const xmlChar *name, int len) {
  825|   287k|    const xmlDictEntry *entry;
  826|       |
  827|   287k|    entry = xmlDictLookupInternal(dict, NULL, name, len, 1);
  828|   287k|    if (entry == NULL)
  ------------------
  |  Branch (828:9): [True: 7.46k, False: 279k]
  ------------------
  829|  7.46k|        return(NULL);
  830|   279k|    return(entry->name);
  831|   287k|}
xmlDictLookupHashed:
  845|   177k|xmlDictLookupHashed(xmlDictPtr dict, const xmlChar *name, int len) {
  846|   177k|    const xmlDictEntry *entry;
  847|   177k|    xmlHashedString ret;
  848|       |
  849|   177k|    entry = xmlDictLookupInternal(dict, NULL, name, len, 1);
  850|       |
  851|   177k|    if (entry == NULL) {
  ------------------
  |  Branch (851:9): [True: 0, False: 177k]
  ------------------
  852|      0|        ret.name = NULL;
  853|      0|        ret.hashValue = 0;
  854|   177k|    } else {
  855|   177k|        ret = *entry;
  856|   177k|    }
  857|       |
  858|   177k|    return(ret);
  859|   177k|}
xmlDictQLookup:
  894|     12|xmlDictQLookup(xmlDictPtr dict, const xmlChar *prefix, const xmlChar *name) {
  895|     12|    const xmlDictEntry *entry;
  896|       |
  897|     12|    entry = xmlDictLookupInternal(dict, prefix, name, -1, 1);
  898|     12|    if (entry == NULL)
  ------------------
  |  Branch (898:9): [True: 0, False: 12]
  ------------------
  899|      0|        return(NULL);
  900|     12|    return(entry->name);
  901|     12|}
xmlInitRandom:
  918|      2|xmlInitRandom(void) {
  919|      2|    int var;
  920|       |
  921|      2|    xmlInitMutex(&xmlRngMutex);
  922|       |
  923|       |    /* TODO: Get seed values from system PRNG */
  924|       |
  925|      2|    globalRngState[0] = (unsigned) time(NULL) ^
  926|      2|                        HASH_ROL((unsigned) (size_t) &xmlInitRandom, 8);
  ------------------
  |  |   12|      2|#define HASH_ROL(x,n) ((x) << (n) | ((x) & 0xFFFFFFFF) >> (32 - (n)))
  ------------------
  927|      2|    globalRngState[1] = HASH_ROL((unsigned) (size_t) &xmlRngMutex, 16) ^
  ------------------
  |  |   12|      2|#define HASH_ROL(x,n) ((x) << (n) | ((x) & 0xFFFFFFFF) >> (32 - (n)))
  ------------------
  928|      2|                        HASH_ROL((unsigned) (size_t) &var, 24);
  ------------------
  |  |   12|      2|#define HASH_ROL(x,n) ((x) << (n) | ((x) & 0xFFFFFFFF) >> (32 - (n)))
  ------------------
  929|      2|}
xmlRandom:
  951|  3.44k|xmlRandom(void) {
  952|  3.44k|#ifdef XML_THREAD_LOCAL
  953|  3.44k|    if (!localRngInitialized) {
  ------------------
  |  Branch (953:9): [True: 1, False: 3.44k]
  ------------------
  954|      1|        xmlMutexLock(&xmlRngMutex);
  955|      1|        localRngState[0] = xoroshiro64ss(globalRngState);
  956|      1|        localRngState[1] = xoroshiro64ss(globalRngState);
  957|      1|        localRngInitialized = 1;
  958|      1|        xmlMutexUnlock(&xmlRngMutex);
  959|      1|    }
  960|       |
  961|  3.44k|    return(xoroshiro64ss(localRngState));
  962|       |#else
  963|       |    unsigned ret;
  964|       |
  965|       |    xmlMutexLock(&xmlRngMutex);
  966|       |    ret = xoroshiro64ss(globalRngState);
  967|       |    xmlMutexUnlock(&xmlRngMutex);
  968|       |
  969|       |    return(ret);
  970|       |#endif
  971|  3.44k|}
dict.c:xmlDictHashName:
  465|   460k|                size_t *plen) {
  466|   460k|    unsigned h1, h2;
  467|   460k|    size_t i;
  468|       |
  469|   460k|    HASH_INIT(h1, h2, seed);
  ------------------
  |  |   23|   460k|    do { \
  |  |   24|   460k|        h1 = seed ^ 0x3b00; \
  |  |   25|   460k|        h2 = HASH_ROL(seed, 15); \
  |  |  ------------------
  |  |  |  |   12|   460k|#define HASH_ROL(x,n) ((x) << (n) | ((x) & 0xFFFFFFFF) >> (32 - (n)))
  |  |  ------------------
  |  |   26|   460k|    } while (0)
  |  |  ------------------
  |  |  |  Branch (26:14): [Folded - Ignored]
  |  |  ------------------
  ------------------
  470|       |
  471|  2.62M|    for (i = 0; i < maxLen && data[i]; i++) {
  ------------------
  |  Branch (471:17): [True: 2.20M, False: 421k]
  |  Branch (471:31): [True: 2.16M, False: 38.8k]
  ------------------
  472|  2.16M|        HASH_UPDATE(h1, h2, data[i]);
  ------------------
  |  |   29|  2.16M|    do { \
  |  |   30|  2.16M|        h1 += ch; \
  |  |   31|  2.16M|        h1 += h1 << 3; \
  |  |   32|  2.16M|        h2 += h1; \
  |  |   33|  2.16M|        h2 = HASH_ROL(h2, 7); \
  |  |  ------------------
  |  |  |  |   12|  2.16M|#define HASH_ROL(x,n) ((x) << (n) | ((x) & 0xFFFFFFFF) >> (32 - (n)))
  |  |  ------------------
  |  |   34|  2.16M|        h2 += h2 << 2; \
  |  |   35|  2.16M|    } while (0)
  |  |  ------------------
  |  |  |  Branch (35:14): [Folded - Ignored]
  |  |  ------------------
  ------------------
  473|  2.16M|    }
  474|       |
  475|   460k|    HASH_FINISH(h1, h2);
  ------------------
  |  |   39|   460k|    do { \
  |  |   40|   460k|        h1 ^= h2; \
  |  |   41|   460k|        h1 += HASH_ROL(h2, 14); \
  |  |  ------------------
  |  |  |  |   12|   460k|#define HASH_ROL(x,n) ((x) << (n) | ((x) & 0xFFFFFFFF) >> (32 - (n)))
  |  |  ------------------
  |  |   42|   460k|        h2 ^= h1; h2 += HASH_ROR(h1, 6); \
  |  |  ------------------
  |  |  |  |   13|   460k|#define HASH_ROR(x,n) (((x) & 0xFFFFFFFF) >> (n) | (x) << (32 - (n)))
  |  |  ------------------
  |  |   43|   460k|        h1 ^= h2; h1 += HASH_ROL(h2, 5); \
  |  |  ------------------
  |  |  |  |   12|   460k|#define HASH_ROL(x,n) ((x) << (n) | ((x) & 0xFFFFFFFF) >> (32 - (n)))
  |  |  ------------------
  |  |   44|   460k|        h2 ^= h1; h2 += HASH_ROR(h1, 8); \
  |  |  ------------------
  |  |  |  |   13|   460k|#define HASH_ROR(x,n) (((x) & 0xFFFFFFFF) >> (n) | (x) << (32 - (n)))
  |  |  ------------------
  |  |   45|   460k|        h2 &= 0xFFFFFFFF; \
  |  |   46|   460k|    } while (0)
  |  |  ------------------
  |  |  |  Branch (46:14): [Folded - Ignored]
  |  |  ------------------
  ------------------
  476|       |
  477|   460k|    *plen = i;
  478|   460k|    return(h2 | MAX_HASH_SIZE);
  ------------------
  |  |   41|   460k|#define MAX_HASH_SIZE (1u << 31)
  ------------------
  479|   460k|}
dict.c:xmlDictLookupInternal:
  679|   464k|                      const xmlChar *name, int maybeLen, int update) {
  680|   464k|    xmlDictEntry *entry = NULL;
  681|   464k|    const xmlChar *ret;
  682|   464k|    unsigned hashValue;
  683|   464k|    size_t maxLen, len, plen, klen;
  684|   464k|    int found = 0;
  685|       |
  686|   464k|    if ((dict == NULL) || (name == NULL))
  ------------------
  |  Branch (686:9): [True: 0, False: 464k]
  |  Branch (686:27): [True: 7.46k, False: 457k]
  ------------------
  687|  7.46k|	return(NULL);
  688|       |
  689|   457k|    maxLen = (maybeLen < 0) ? SIZE_MAX : (size_t) maybeLen;
  ------------------
  |  |   35|  36.0k|  #define SIZE_MAX ((size_t) -1)
  ------------------
  |  Branch (689:14): [True: 36.0k, False: 421k]
  ------------------
  690|       |
  691|   457k|    if (prefix == NULL) {
  ------------------
  |  Branch (691:9): [True: 457k, False: 12]
  ------------------
  692|   457k|        hashValue = xmlDictHashName(dict->seed, name, maxLen, &len);
  693|   457k|        if (len > INT_MAX / 2)
  ------------------
  |  Branch (693:13): [True: 0, False: 457k]
  ------------------
  694|      0|            return(NULL);
  695|   457k|        klen = len;
  696|   457k|    } else {
  697|     12|        hashValue = xmlDictHashQName(dict->seed, prefix, name, &plen, &len);
  698|     12|        if ((len > INT_MAX / 2) || (plen >= INT_MAX / 2 - len))
  ------------------
  |  Branch (698:13): [True: 0, False: 12]
  |  Branch (698:36): [True: 0, False: 12]
  ------------------
  699|      0|            return(NULL);
  700|     12|        klen = plen + 1 + len;
  701|     12|    }
  702|       |
  703|   457k|    if ((dict->limit > 0) && (klen >= dict->limit))
  ------------------
  |  Branch (703:9): [True: 457k, False: 0]
  |  Branch (703:30): [True: 0, False: 457k]
  ------------------
  704|      0|        return(NULL);
  705|       |
  706|       |    /*
  707|       |     * Check for an existing entry
  708|       |     */
  709|   457k|    if (dict->size > 0)
  ------------------
  |  Branch (709:9): [True: 456k, False: 1.32k]
  ------------------
  710|   456k|        entry = xmlDictFindEntry(dict, prefix, name, klen, hashValue, &found);
  711|   457k|    if (found)
  ------------------
  |  Branch (711:9): [True: 434k, False: 22.5k]
  ------------------
  712|   434k|        return(entry);
  713|       |
  714|  22.5k|    if ((dict->subdict != NULL) && (dict->subdict->size > 0)) {
  ------------------
  |  Branch (714:9): [True: 0, False: 22.5k]
  |  Branch (714:36): [True: 0, False: 0]
  ------------------
  715|      0|        xmlDictEntry *subEntry;
  716|      0|        unsigned subHashValue;
  717|       |
  718|      0|        if (prefix == NULL)
  ------------------
  |  Branch (718:13): [True: 0, False: 0]
  ------------------
  719|      0|            subHashValue = xmlDictHashName(dict->subdict->seed, name, len,
  720|      0|                                           &len);
  721|      0|        else
  722|      0|            subHashValue = xmlDictHashQName(dict->subdict->seed, prefix, name,
  723|      0|                                            &plen, &len);
  724|      0|        subEntry = xmlDictFindEntry(dict->subdict, prefix, name, klen,
  725|      0|                                    subHashValue, &found);
  726|      0|        if (found)
  ------------------
  |  Branch (726:13): [True: 0, False: 0]
  ------------------
  727|      0|            return(subEntry);
  728|      0|    }
  729|       |
  730|  22.5k|    if (!update)
  ------------------
  |  Branch (730:9): [True: 0, False: 22.5k]
  ------------------
  731|      0|        return(NULL);
  732|       |
  733|       |    /*
  734|       |     * Grow the hash table if needed
  735|       |     */
  736|  22.5k|    if (dict->nbElems + 1 > dict->size / MAX_FILL_DENOM * MAX_FILL_NUM) {
  ------------------
  |  |   39|  22.5k|#define MAX_FILL_DENOM 8
  ------------------
                  if (dict->nbElems + 1 > dict->size / MAX_FILL_DENOM * MAX_FILL_NUM) {
  ------------------
  |  |   38|  22.5k|#define MAX_FILL_NUM 7
  ------------------
  |  Branch (736:9): [True: 2.48k, False: 20.0k]
  ------------------
  737|  2.48k|        unsigned newSize, mask, displ, pos;
  738|       |
  739|  2.48k|        if (dict->size == 0) {
  ------------------
  |  Branch (739:13): [True: 1.32k, False: 1.16k]
  ------------------
  740|  1.32k|            newSize = MIN_HASH_SIZE;
  ------------------
  |  |   40|  1.32k|#define MIN_HASH_SIZE 8
  ------------------
  741|  1.32k|        } else {
  742|  1.16k|            if (dict->size >= MAX_HASH_SIZE)
  ------------------
  |  |   41|  1.16k|#define MAX_HASH_SIZE (1u << 31)
  ------------------
  |  Branch (742:17): [True: 0, False: 1.16k]
  ------------------
  743|      0|                return(NULL);
  744|  1.16k|            newSize = dict->size * 2;
  745|  1.16k|        }
  746|  2.48k|        if (xmlDictGrow(dict, newSize) != 0)
  ------------------
  |  Branch (746:13): [True: 0, False: 2.48k]
  ------------------
  747|      0|            return(NULL);
  748|       |
  749|       |        /*
  750|       |         * Find new entry
  751|       |         */
  752|  2.48k|        mask = dict->size - 1;
  753|  2.48k|        displ = 0;
  754|  2.48k|        pos = hashValue & mask;
  755|  2.48k|        entry = &dict->table[pos];
  756|       |
  757|  2.94k|        while ((entry->hashValue != 0) &&
  ------------------
  |  Branch (757:16): [True: 605, False: 2.33k]
  ------------------
  758|  2.94k|               ((pos - entry->hashValue) & mask) >= displ) {
  ------------------
  |  Branch (758:16): [True: 452, False: 153]
  ------------------
  759|    452|            displ++;
  760|    452|            pos++;
  761|    452|            entry++;
  762|    452|            if ((pos & mask) == 0)
  ------------------
  |  Branch (762:17): [True: 33, False: 419]
  ------------------
  763|     33|                entry = dict->table;
  764|    452|        }
  765|  2.48k|    }
  766|       |
  767|  22.5k|    if (prefix == NULL)
  ------------------
  |  Branch (767:9): [True: 22.5k, False: 12]
  ------------------
  768|  22.5k|        ret = xmlDictAddString(dict, name, len);
  769|     12|    else
  770|     12|        ret = xmlDictAddQString(dict, prefix, plen, name, len);
  771|  22.5k|    if (ret == NULL)
  ------------------
  |  Branch (771:9): [True: 0, False: 22.5k]
  ------------------
  772|      0|        return(NULL);
  773|       |
  774|       |    /*
  775|       |     * Shift the remainder of the probe sequence to the right
  776|       |     */
  777|  22.5k|    if (entry->hashValue != 0) {
  ------------------
  |  Branch (777:9): [True: 5.96k, False: 16.5k]
  ------------------
  778|  5.96k|        const xmlDictEntry *end = &dict->table[dict->size];
  779|  5.96k|        const xmlDictEntry *cur = entry;
  780|       |
  781|  34.6k|        do {
  782|  34.6k|            cur++;
  783|  34.6k|            if (cur >= end)
  ------------------
  |  Branch (783:17): [True: 688, False: 33.9k]
  ------------------
  784|    688|                cur = dict->table;
  785|  34.6k|        } while (cur->hashValue != 0);
  ------------------
  |  Branch (785:18): [True: 28.6k, False: 5.96k]
  ------------------
  786|       |
  787|  5.96k|        if (cur < entry) {
  ------------------
  |  Branch (787:13): [True: 688, False: 5.28k]
  ------------------
  788|       |            /*
  789|       |             * If we traversed the end of the buffer, handle the part
  790|       |             * at the start of the buffer.
  791|       |             */
  792|    688|            memmove(&dict->table[1], dict->table,
  793|    688|                    (char *) cur - (char *) dict->table);
  794|    688|            cur = end - 1;
  795|    688|            dict->table[0] = *cur;
  796|    688|        }
  797|       |
  798|  5.96k|        memmove(&entry[1], entry, (char *) cur - (char *) entry);
  799|  5.96k|    }
  800|       |
  801|       |    /*
  802|       |     * Populate entry
  803|       |     */
  804|  22.5k|    entry->hashValue = hashValue;
  805|  22.5k|    entry->name = ret;
  806|       |
  807|  22.5k|    dict->nbElems++;
  808|       |
  809|  22.5k|    return(entry);
  810|  22.5k|}
dict.c:xmlDictHashQName:
  484|     12|                 size_t *pplen, size_t *plen) {
  485|     12|    unsigned h1, h2;
  486|     12|    size_t i;
  487|       |
  488|     12|    HASH_INIT(h1, h2, seed);
  ------------------
  |  |   23|     12|    do { \
  |  |   24|     12|        h1 = seed ^ 0x3b00; \
  |  |   25|     12|        h2 = HASH_ROL(seed, 15); \
  |  |  ------------------
  |  |  |  |   12|     12|#define HASH_ROL(x,n) ((x) << (n) | ((x) & 0xFFFFFFFF) >> (32 - (n)))
  |  |  ------------------
  |  |   26|     12|    } while (0)
  |  |  ------------------
  |  |  |  Branch (26:14): [Folded - Ignored]
  |  |  ------------------
  ------------------
  489|       |
  490|  40.9k|    for (i = 0; prefix[i] != 0; i++) {
  ------------------
  |  Branch (490:17): [True: 40.9k, False: 12]
  ------------------
  491|  40.9k|        HASH_UPDATE(h1, h2, prefix[i]);
  ------------------
  |  |   29|  40.9k|    do { \
  |  |   30|  40.9k|        h1 += ch; \
  |  |   31|  40.9k|        h1 += h1 << 3; \
  |  |   32|  40.9k|        h2 += h1; \
  |  |   33|  40.9k|        h2 = HASH_ROL(h2, 7); \
  |  |  ------------------
  |  |  |  |   12|  40.9k|#define HASH_ROL(x,n) ((x) << (n) | ((x) & 0xFFFFFFFF) >> (32 - (n)))
  |  |  ------------------
  |  |   34|  40.9k|        h2 += h2 << 2; \
  |  |   35|  40.9k|    } while (0)
  |  |  ------------------
  |  |  |  Branch (35:14): [Folded - Ignored]
  |  |  ------------------
  ------------------
  492|  40.9k|    }
  493|     12|    *pplen = i;
  494|       |
  495|     12|    HASH_UPDATE(h1, h2, ':');
  ------------------
  |  |   29|     12|    do { \
  |  |   30|     12|        h1 += ch; \
  |  |   31|     12|        h1 += h1 << 3; \
  |  |   32|     12|        h2 += h1; \
  |  |   33|     12|        h2 = HASH_ROL(h2, 7); \
  |  |  ------------------
  |  |  |  |   12|     12|#define HASH_ROL(x,n) ((x) << (n) | ((x) & 0xFFFFFFFF) >> (32 - (n)))
  |  |  ------------------
  |  |   34|     12|        h2 += h2 << 2; \
  |  |   35|     12|    } while (0)
  |  |  ------------------
  |  |  |  Branch (35:14): [Folded - Ignored]
  |  |  ------------------
  ------------------
  496|       |
  497|     40|    for (i = 0; name[i] != 0; i++) {
  ------------------
  |  Branch (497:17): [True: 28, False: 12]
  ------------------
  498|     28|        HASH_UPDATE(h1, h2, name[i]);
  ------------------
  |  |   29|     28|    do { \
  |  |   30|     28|        h1 += ch; \
  |  |   31|     28|        h1 += h1 << 3; \
  |  |   32|     28|        h2 += h1; \
  |  |   33|     28|        h2 = HASH_ROL(h2, 7); \
  |  |  ------------------
  |  |  |  |   12|     28|#define HASH_ROL(x,n) ((x) << (n) | ((x) & 0xFFFFFFFF) >> (32 - (n)))
  |  |  ------------------
  |  |   34|     28|        h2 += h2 << 2; \
  |  |   35|     28|    } while (0)
  |  |  ------------------
  |  |  |  Branch (35:14): [Folded - Ignored]
  |  |  ------------------
  ------------------
  499|     28|    }
  500|     12|    *plen = i;
  501|       |
  502|     12|    HASH_FINISH(h1, h2);
  ------------------
  |  |   39|     12|    do { \
  |  |   40|     12|        h1 ^= h2; \
  |  |   41|     12|        h1 += HASH_ROL(h2, 14); \
  |  |  ------------------
  |  |  |  |   12|     12|#define HASH_ROL(x,n) ((x) << (n) | ((x) & 0xFFFFFFFF) >> (32 - (n)))
  |  |  ------------------
  |  |   42|     12|        h2 ^= h1; h2 += HASH_ROR(h1, 6); \
  |  |  ------------------
  |  |  |  |   13|     12|#define HASH_ROR(x,n) (((x) & 0xFFFFFFFF) >> (n) | (x) << (32 - (n)))
  |  |  ------------------
  |  |   43|     12|        h1 ^= h2; h1 += HASH_ROL(h2, 5); \
  |  |  ------------------
  |  |  |  |   12|     12|#define HASH_ROL(x,n) ((x) << (n) | ((x) & 0xFFFFFFFF) >> (32 - (n)))
  |  |  ------------------
  |  |   44|     12|        h2 ^= h1; h2 += HASH_ROR(h1, 8); \
  |  |  ------------------
  |  |  |  |   13|     12|#define HASH_ROR(x,n) (((x) & 0xFFFFFFFF) >> (n) | (x) << (32 - (n)))
  |  |  ------------------
  |  |   45|     12|        h2 &= 0xFFFFFFFF; \
  |  |   46|     12|    } while (0)
  |  |  ------------------
  |  |  |  Branch (46:14): [Folded - Ignored]
  |  |  ------------------
  ------------------
  503|       |
  504|       |    /*
  505|       |     * Always set the upper bit of hash values since 0 means an unoccupied
  506|       |     * bucket.
  507|       |     */
  508|     12|    return(h2 | MAX_HASH_SIZE);
  ------------------
  |  |   41|     12|#define MAX_HASH_SIZE (1u << 31)
  ------------------
  509|     12|}
dict.c:xmlDictFindEntry:
  549|   456k|                 int *pfound) {
  550|   456k|    xmlDictEntry *entry;
  551|   456k|    unsigned mask, pos, displ;
  552|   456k|    int found = 0;
  553|       |
  554|   456k|    mask = dict->size - 1;
  555|   456k|    pos = hashValue & mask;
  556|   456k|    entry = &dict->table[pos];
  557|       |
  558|   456k|    if (entry->hashValue != 0) {
  ------------------
  |  Branch (558:9): [True: 446k, False: 9.76k]
  ------------------
  559|       |        /*
  560|       |         * Robin hood hashing: abort if the displacement of the entry
  561|       |         * is smaller than the displacement of the key we look for.
  562|       |         * This also stops at the correct position when inserting.
  563|       |         */
  564|   446k|        displ = 0;
  565|       |
  566|   771k|        do {
  567|   771k|            if (entry->hashValue == hashValue) {
  ------------------
  |  Branch (567:17): [True: 434k, False: 337k]
  ------------------
  568|   434k|                if (prefix == NULL) {
  ------------------
  |  Branch (568:21): [True: 434k, False: 0]
  ------------------
  569|       |                    /*
  570|       |                     * name is not necessarily null-terminated.
  571|       |                     */
  572|   434k|                    if ((strncmp((const char *) entry->name,
  ------------------
  |  Branch (572:25): [True: 434k, False: 0]
  ------------------
  573|   434k|                                 (const char *) name, len) == 0) &&
  574|   434k|                        (entry->name[len] == 0)) {
  ------------------
  |  Branch (574:25): [True: 434k, False: 0]
  ------------------
  575|   434k|                        found = 1;
  576|   434k|                        break;
  577|   434k|                    }
  578|   434k|                } else {
  579|      0|                    if (xmlStrQEqual(prefix, name, entry->name)) {
  ------------------
  |  Branch (579:25): [True: 0, False: 0]
  ------------------
  580|      0|                        found = 1;
  581|      0|                        break;
  582|      0|                    }
  583|      0|                }
  584|   434k|            }
  585|       |
  586|   337k|            displ++;
  587|   337k|            pos++;
  588|   337k|            entry++;
  589|   337k|            if ((pos & mask) == 0)
  ------------------
  |  Branch (589:17): [True: 4.41k, False: 332k]
  ------------------
  590|  4.41k|                entry = dict->table;
  591|   337k|        } while ((entry->hashValue != 0) &&
  ------------------
  |  Branch (591:18): [True: 332k, False: 4.94k]
  ------------------
  592|   337k|                 (((pos - entry->hashValue) & mask) >= displ));
  ------------------
  |  Branch (592:18): [True: 325k, False: 6.50k]
  ------------------
  593|   446k|    }
  594|       |
  595|      0|    *pfound = found;
  596|   456k|    return(entry);
  597|   456k|}
dict.c:xmlDictGrow:
  609|  2.48k|xmlDictGrow(xmlDictPtr dict, unsigned size) {
  610|  2.48k|    const xmlDictEntry *oldentry, *oldend, *end;
  611|  2.48k|    xmlDictEntry *table;
  612|  2.48k|    unsigned oldsize, i;
  613|       |
  614|       |    /* Add 0 to avoid spurious -Wtype-limits warning on 64-bit GCC */
  615|  2.48k|    if ((size_t) size + 0 > SIZE_MAX / sizeof(table[0]))
  ------------------
  |  |   35|  2.48k|  #define SIZE_MAX ((size_t) -1)
  ------------------
  |  Branch (615:9): [True: 0, False: 2.48k]
  ------------------
  616|      0|        return(-1);
  617|  2.48k|    table = xmlMalloc(size * sizeof(table[0]));
  618|  2.48k|    if (table == NULL)
  ------------------
  |  Branch (618:9): [True: 0, False: 2.48k]
  ------------------
  619|      0|        return(-1);
  620|  2.48k|    memset(table, 0, size * sizeof(table[0]));
  621|       |
  622|  2.48k|    oldsize = dict->size;
  623|  2.48k|    if (oldsize == 0)
  ------------------
  |  Branch (623:9): [True: 1.32k, False: 1.16k]
  ------------------
  624|  1.32k|        goto done;
  625|       |
  626|  1.16k|    oldend = &dict->table[oldsize];
  627|  1.16k|    end = &table[size];
  628|       |
  629|       |    /*
  630|       |     * Robin Hood sorting order is maintained if we
  631|       |     *
  632|       |     * - compute dict indices with modulo
  633|       |     * - resize by an integer factor
  634|       |     * - start to copy from the beginning of a probe sequence
  635|       |     */
  636|  1.16k|    oldentry = dict->table;
  637|  8.18k|    while (oldentry->hashValue != 0) {
  ------------------
  |  Branch (637:12): [True: 7.02k, False: 1.16k]
  ------------------
  638|  7.02k|        if (++oldentry >= oldend)
  ------------------
  |  Branch (638:13): [True: 0, False: 7.02k]
  ------------------
  639|      0|            oldentry = dict->table;
  640|  7.02k|    }
  641|       |
  642|  27.0k|    for (i = 0; i < oldsize; i++) {
  ------------------
  |  Branch (642:17): [True: 25.8k, False: 1.16k]
  ------------------
  643|  25.8k|        if (oldentry->hashValue != 0) {
  ------------------
  |  Branch (643:13): [True: 22.6k, False: 3.23k]
  ------------------
  644|  22.6k|            xmlDictEntry *entry = &table[oldentry->hashValue & (size - 1)];
  645|       |
  646|  31.3k|            while (entry->hashValue != 0) {
  ------------------
  |  Branch (646:20): [True: 8.68k, False: 22.6k]
  ------------------
  647|  8.68k|                if (++entry >= end)
  ------------------
  |  Branch (647:21): [True: 406, False: 8.28k]
  ------------------
  648|    406|                    entry = table;
  649|  8.68k|            }
  650|  22.6k|            *entry = *oldentry;
  651|  22.6k|        }
  652|       |
  653|  25.8k|        if (++oldentry >= oldend)
  ------------------
  |  Branch (653:13): [True: 1.16k, False: 24.7k]
  ------------------
  654|  1.16k|            oldentry = dict->table;
  655|  25.8k|    }
  656|       |
  657|  1.16k|    xmlFree(dict->table);
  658|       |
  659|  2.48k|done:
  660|  2.48k|    dict->table = table;
  661|  2.48k|    dict->size = size;
  662|       |
  663|  2.48k|    return(0);
  664|  1.16k|}
dict.c:xmlDictAddString:
  136|  22.5k|xmlDictAddString(xmlDictPtr dict, const xmlChar *name, unsigned int namelen) {
  137|  22.5k|    xmlDictStringsPtr pool;
  138|  22.5k|    const xmlChar *ret;
  139|  22.5k|    size_t size = 0; /* + sizeof(_xmlDictStrings) == 1024 */
  140|  22.5k|    size_t limit = 0;
  141|       |
  142|  22.5k|    pool = dict->strings;
  143|  22.5k|    while (pool != NULL) {
  ------------------
  |  Branch (143:12): [True: 21.2k, False: 1.38k]
  ------------------
  144|  21.2k|	if ((size_t)(pool->end - pool->free) > namelen)
  ------------------
  |  Branch (144:6): [True: 21.1k, False: 61]
  ------------------
  145|  21.1k|	    goto found_pool;
  146|     61|	if (pool->size > size) size = pool->size;
  ------------------
  |  Branch (146:6): [True: 57, False: 4]
  ------------------
  147|     61|        limit += pool->size;
  148|     61|	pool = pool->next;
  149|     61|    }
  150|       |    /*
  151|       |     * Not found, need to allocate
  152|       |     */
  153|  1.38k|    if (pool == NULL) {
  ------------------
  |  Branch (153:9): [True: 1.38k, False: 0]
  ------------------
  154|  1.38k|        if ((dict->limit > 0) && (limit > dict->limit)) {
  ------------------
  |  Branch (154:13): [True: 1.38k, False: 0]
  |  Branch (154:34): [True: 0, False: 1.38k]
  ------------------
  155|      0|            return(NULL);
  156|      0|        }
  157|       |
  158|  1.38k|        if (size == 0) {
  ------------------
  |  Branch (158:13): [True: 1.32k, False: 57]
  ------------------
  159|  1.32k|            size = 1000;
  160|  1.32k|        } else {
  161|     57|            if (size < (SIZE_MAX - sizeof(xmlDictStrings)) / 4)
  ------------------
  |  |   35|     57|  #define SIZE_MAX ((size_t) -1)
  ------------------
  |  Branch (161:17): [True: 57, False: 0]
  ------------------
  162|     57|                size *= 4; /* exponential growth */
  163|      0|            else
  164|      0|                size = SIZE_MAX - sizeof(xmlDictStrings);
  ------------------
  |  |   35|      0|  #define SIZE_MAX ((size_t) -1)
  ------------------
  165|     57|        }
  166|  1.38k|        if (size / 4 < namelen) {
  ------------------
  |  Branch (166:13): [True: 30, False: 1.35k]
  ------------------
  167|     30|            if ((size_t) namelen + 0 < (SIZE_MAX - sizeof(xmlDictStrings)) / 4)
  ------------------
  |  |   35|     30|  #define SIZE_MAX ((size_t) -1)
  ------------------
  |  Branch (167:17): [True: 30, False: 0]
  ------------------
  168|     30|                size = 4 * (size_t) namelen; /* just in case ! */
  169|      0|            else
  170|      0|                return(NULL);
  171|     30|        }
  172|  1.38k|	pool = (xmlDictStringsPtr) xmlMalloc(sizeof(xmlDictStrings) + size);
  173|  1.38k|	if (pool == NULL)
  ------------------
  |  Branch (173:6): [True: 0, False: 1.38k]
  ------------------
  174|      0|	    return(NULL);
  175|  1.38k|	pool->size = size;
  176|  1.38k|	pool->nbStrings = 0;
  177|  1.38k|	pool->free = &pool->array[0];
  178|  1.38k|	pool->end = &pool->array[size];
  179|  1.38k|	pool->next = dict->strings;
  180|  1.38k|	dict->strings = pool;
  181|  1.38k|    }
  182|  22.5k|found_pool:
  183|  22.5k|    ret = pool->free;
  184|  22.5k|    memcpy(pool->free, name, namelen);
  185|  22.5k|    pool->free += namelen;
  186|  22.5k|    *(pool->free++) = 0;
  187|  22.5k|    pool->nbStrings++;
  188|  22.5k|    return(ret);
  189|  1.38k|}
dict.c:xmlDictAddQString:
  206|     12|{
  207|     12|    xmlDictStringsPtr pool;
  208|     12|    const xmlChar *ret;
  209|     12|    size_t size = 0; /* + sizeof(_xmlDictStrings) == 1024 */
  210|     12|    size_t limit = 0;
  211|       |
  212|     12|    pool = dict->strings;
  213|     12|    while (pool != NULL) {
  ------------------
  |  Branch (213:12): [True: 12, False: 0]
  ------------------
  214|     12|	if ((size_t)(pool->end - pool->free) > namelen + plen + 1)
  ------------------
  |  Branch (214:6): [True: 12, False: 0]
  ------------------
  215|     12|	    goto found_pool;
  216|      0|	if (pool->size > size) size = pool->size;
  ------------------
  |  Branch (216:6): [True: 0, False: 0]
  ------------------
  217|      0|        limit += pool->size;
  218|      0|	pool = pool->next;
  219|      0|    }
  220|       |    /*
  221|       |     * Not found, need to allocate
  222|       |     */
  223|      0|    if (pool == NULL) {
  ------------------
  |  Branch (223:9): [True: 0, False: 0]
  ------------------
  224|      0|        if ((dict->limit > 0) && (limit > dict->limit)) {
  ------------------
  |  Branch (224:13): [True: 0, False: 0]
  |  Branch (224:34): [True: 0, False: 0]
  ------------------
  225|      0|            return(NULL);
  226|      0|        }
  227|       |
  228|      0|        if (size == 0) size = 1000;
  ------------------
  |  Branch (228:13): [True: 0, False: 0]
  ------------------
  229|      0|	else size *= 4; /* exponential growth */
  230|      0|        if (size < 4 * (namelen + plen + 1))
  ------------------
  |  Branch (230:13): [True: 0, False: 0]
  ------------------
  231|      0|	    size = 4 * (namelen + plen + 1); /* just in case ! */
  232|      0|	pool = (xmlDictStringsPtr) xmlMalloc(sizeof(xmlDictStrings) + size);
  233|      0|	if (pool == NULL)
  ------------------
  |  Branch (233:6): [True: 0, False: 0]
  ------------------
  234|      0|	    return(NULL);
  235|      0|	pool->size = size;
  236|      0|	pool->nbStrings = 0;
  237|      0|	pool->free = &pool->array[0];
  238|      0|	pool->end = &pool->array[size];
  239|      0|	pool->next = dict->strings;
  240|      0|	dict->strings = pool;
  241|      0|    }
  242|     12|found_pool:
  243|     12|    ret = pool->free;
  244|     12|    memcpy(pool->free, prefix, plen);
  245|     12|    pool->free += plen;
  246|     12|    *(pool->free++) = ':';
  247|     12|    memcpy(pool->free, name, namelen);
  248|     12|    pool->free += namelen;
  249|     12|    *(pool->free++) = 0;
  250|     12|    pool->nbStrings++;
  251|     12|    return(ret);
  252|      0|}
dict.c:xoroshiro64ss:
  938|  3.44k|xoroshiro64ss(unsigned *s) {
  939|  3.44k|    unsigned s0 = s[0];
  940|  3.44k|    unsigned s1 = s[1];
  941|  3.44k|    unsigned result = HASH_ROL(s0 * 0x9E3779BB, 5) * 5;
  ------------------
  |  |   12|  3.44k|#define HASH_ROL(x,n) ((x) << (n) | ((x) & 0xFFFFFFFF) >> (32 - (n)))
  ------------------
  942|       |
  943|  3.44k|    s1 ^= s0;
  944|  3.44k|    s[0] = HASH_ROL(s0, 26) ^ s1 ^ (s1 << 9);
  ------------------
  |  |   12|  3.44k|#define HASH_ROL(x,n) ((x) << (n) | ((x) & 0xFFFFFFFF) >> (32 - (n)))
  ------------------
  945|  3.44k|    s[1] = HASH_ROL(s1, 13);
  ------------------
  |  |   12|  3.44k|#define HASH_ROL(x,n) ((x) << (n) | ((x) & 0xFFFFFFFF) >> (32 - (n)))
  ------------------
  946|       |
  947|  3.44k|    return(result & 0xFFFFFFFF);
  948|  3.44k|}

isolat1ToUTF8:
  284|  1.96k|              const unsigned char* in, int *inlen) {
  285|  1.96k|    unsigned char* outstart = out;
  286|  1.96k|    const unsigned char* base = in;
  287|  1.96k|    unsigned char* outend;
  288|  1.96k|    const unsigned char* inend;
  289|  1.96k|    const unsigned char* instop;
  290|       |
  291|  1.96k|    if ((out == NULL) || (in == NULL) || (outlen == NULL) || (inlen == NULL))
  ------------------
  |  Branch (291:9): [True: 0, False: 1.96k]
  |  Branch (291:26): [True: 0, False: 1.96k]
  |  Branch (291:42): [True: 0, False: 1.96k]
  |  Branch (291:62): [True: 0, False: 1.96k]
  ------------------
  292|      0|	return(XML_ENC_ERR_INTERNAL);
  293|       |
  294|  1.96k|    outend = out + *outlen;
  295|  1.96k|    inend = in + (*inlen);
  296|  1.96k|    instop = inend;
  297|       |
  298|  4.43k|    while ((in < inend) && (out < outend - 1)) {
  ------------------
  |  Branch (298:12): [True: 2.47k, False: 1.96k]
  |  Branch (298:28): [True: 2.47k, False: 0]
  ------------------
  299|  2.47k|	if (*in >= 0x80) {
  ------------------
  |  Branch (299:6): [True: 508, False: 1.96k]
  ------------------
  300|    508|	    *out++ = (((*in) >>  6) & 0x1F) | 0xC0;
  301|    508|            *out++ = ((*in) & 0x3F) | 0x80;
  302|    508|	    ++in;
  303|    508|	}
  304|  2.47k|	if ((instop - in) > (outend - out)) instop = in + (outend - out);
  ------------------
  |  Branch (304:6): [True: 0, False: 2.47k]
  ------------------
  305|   751k|	while ((in < instop) && (*in < 0x80)) {
  ------------------
  |  Branch (305:9): [True: 749k, False: 1.96k]
  |  Branch (305:26): [True: 749k, False: 508]
  ------------------
  306|   749k|	    *out++ = *in++;
  307|   749k|	}
  308|  2.47k|    }
  309|  1.96k|    if ((in < inend) && (out < outend) && (*in < 0x80)) {
  ------------------
  |  Branch (309:9): [True: 0, False: 1.96k]
  |  Branch (309:25): [True: 0, False: 0]
  |  Branch (309:43): [True: 0, False: 0]
  ------------------
  310|      0|        *out++ = *in++;
  311|      0|    }
  312|  1.96k|    *outlen = out - outstart;
  313|  1.96k|    *inlen = in - base;
  314|  1.96k|    return(*outlen);
  315|  1.96k|}
xmlGetEncodingAlias:
 1003|    172|xmlGetEncodingAlias(const char *alias) {
 1004|    172|    int i;
 1005|    172|    char upper[100];
 1006|       |
 1007|    172|    if (alias == NULL)
  ------------------
  |  Branch (1007:9): [True: 0, False: 172]
  ------------------
 1008|      0|	return(NULL);
 1009|       |
 1010|    172|    if (xmlCharEncodingAliases == NULL)
  ------------------
  |  Branch (1010:9): [True: 172, False: 0]
  ------------------
 1011|    172|	return(NULL);
 1012|       |
 1013|      0|    for (i = 0;i < 99;i++) {
  ------------------
  |  Branch (1013:16): [True: 0, False: 0]
  ------------------
 1014|      0|        upper[i] = (char) toupper((unsigned char) alias[i]);
 1015|      0|	if (upper[i] == 0) break;
  ------------------
  |  Branch (1015:6): [True: 0, False: 0]
  ------------------
 1016|      0|    }
 1017|      0|    upper[i] = 0;
 1018|       |
 1019|       |    /*
 1020|       |     * Walk down the list looking for a definition of the alias
 1021|       |     */
 1022|      0|    for (i = 0;i < xmlCharEncodingAliasesNb;i++) {
  ------------------
  |  Branch (1022:16): [True: 0, False: 0]
  ------------------
 1023|      0|	if (!strcmp(xmlCharEncodingAliases[i].alias, upper)) {
  ------------------
  |  Branch (1023:6): [True: 0, False: 0]
  ------------------
 1024|      0|	    return(xmlCharEncodingAliases[i].name);
 1025|      0|	}
 1026|      0|    }
 1027|      0|    return(NULL);
 1028|      0|}
xmlParseCharEncoding:
 1149|      8|{
 1150|      8|    const char *alias;
 1151|      8|    char upper[500];
 1152|      8|    int i;
 1153|       |
 1154|      8|    if (name == NULL)
  ------------------
  |  Branch (1154:9): [True: 0, False: 8]
  ------------------
 1155|      0|	return(XML_CHAR_ENCODING_NONE);
 1156|       |
 1157|       |    /*
 1158|       |     * Do the alias resolution
 1159|       |     */
 1160|      8|    alias = xmlGetEncodingAlias(name);
 1161|      8|    if (alias != NULL)
  ------------------
  |  Branch (1161:9): [True: 0, False: 8]
  ------------------
 1162|      0|	name = alias;
 1163|       |
 1164|     56|    for (i = 0;i < 499;i++) {
  ------------------
  |  Branch (1164:16): [True: 56, False: 0]
  ------------------
 1165|     56|        upper[i] = (char) toupper((unsigned char) name[i]);
 1166|     56|	if (upper[i] == 0) break;
  ------------------
  |  Branch (1166:6): [True: 8, False: 48]
  ------------------
 1167|     56|    }
 1168|      8|    upper[i] = 0;
 1169|       |
 1170|      8|    if (!strcmp(upper, "")) return(XML_CHAR_ENCODING_NONE);
  ------------------
  |  Branch (1170:9): [True: 0, False: 8]
  ------------------
 1171|      8|    if (!strcmp(upper, "UTF-8")) return(XML_CHAR_ENCODING_UTF8);
  ------------------
  |  Branch (1171:9): [True: 0, False: 8]
  ------------------
 1172|      8|    if (!strcmp(upper, "UTF8")) return(XML_CHAR_ENCODING_UTF8);
  ------------------
  |  Branch (1172:9): [True: 0, False: 8]
  ------------------
 1173|       |
 1174|       |    /*
 1175|       |     * NOTE: if we were able to parse this, the endianness of UTF16 is
 1176|       |     *       already found and in use
 1177|       |     */
 1178|      8|    if (!strcmp(upper, "UTF-16")) return(XML_CHAR_ENCODING_UTF16LE);
  ------------------
  |  Branch (1178:9): [True: 0, False: 8]
  ------------------
 1179|      8|    if (!strcmp(upper, "UTF16")) return(XML_CHAR_ENCODING_UTF16LE);
  ------------------
  |  Branch (1179:9): [True: 0, False: 8]
  ------------------
 1180|       |
 1181|      8|    if (!strcmp(upper, "ISO-10646-UCS-2")) return(XML_CHAR_ENCODING_UCS2);
  ------------------
  |  Branch (1181:9): [True: 0, False: 8]
  ------------------
 1182|      8|    if (!strcmp(upper, "UCS-2")) return(XML_CHAR_ENCODING_UCS2);
  ------------------
  |  Branch (1182:9): [True: 0, False: 8]
  ------------------
 1183|      8|    if (!strcmp(upper, "UCS2")) return(XML_CHAR_ENCODING_UCS2);
  ------------------
  |  Branch (1183:9): [True: 0, False: 8]
  ------------------
 1184|       |
 1185|       |    /*
 1186|       |     * NOTE: if we were able to parse this, the endianness of UCS4 is
 1187|       |     *       already found and in use
 1188|       |     */
 1189|      8|    if (!strcmp(upper, "ISO-10646-UCS-4")) return(XML_CHAR_ENCODING_UCS4LE);
  ------------------
  |  Branch (1189:9): [True: 0, False: 8]
  ------------------
 1190|      8|    if (!strcmp(upper, "UCS-4")) return(XML_CHAR_ENCODING_UCS4LE);
  ------------------
  |  Branch (1190:9): [True: 0, False: 8]
  ------------------
 1191|      8|    if (!strcmp(upper, "UCS4")) return(XML_CHAR_ENCODING_UCS4LE);
  ------------------
  |  Branch (1191:9): [True: 0, False: 8]
  ------------------
 1192|       |
 1193|       |
 1194|      8|    if (!strcmp(upper,  "ISO-8859-1")) return(XML_CHAR_ENCODING_8859_1);
  ------------------
  |  Branch (1194:9): [True: 0, False: 8]
  ------------------
 1195|      8|    if (!strcmp(upper,  "ISO-LATIN-1")) return(XML_CHAR_ENCODING_8859_1);
  ------------------
  |  Branch (1195:9): [True: 0, False: 8]
  ------------------
 1196|      8|    if (!strcmp(upper,  "ISO LATIN 1")) return(XML_CHAR_ENCODING_8859_1);
  ------------------
  |  Branch (1196:9): [True: 0, False: 8]
  ------------------
 1197|       |
 1198|      8|    if (!strcmp(upper,  "ISO-8859-2")) return(XML_CHAR_ENCODING_8859_2);
  ------------------
  |  Branch (1198:9): [True: 0, False: 8]
  ------------------
 1199|      8|    if (!strcmp(upper,  "ISO-LATIN-2")) return(XML_CHAR_ENCODING_8859_2);
  ------------------
  |  Branch (1199:9): [True: 0, False: 8]
  ------------------
 1200|      8|    if (!strcmp(upper,  "ISO LATIN 2")) return(XML_CHAR_ENCODING_8859_2);
  ------------------
  |  Branch (1200:9): [True: 0, False: 8]
  ------------------
 1201|       |
 1202|      8|    if (!strcmp(upper,  "ISO-8859-3")) return(XML_CHAR_ENCODING_8859_3);
  ------------------
  |  Branch (1202:9): [True: 0, False: 8]
  ------------------
 1203|      8|    if (!strcmp(upper,  "ISO-8859-4")) return(XML_CHAR_ENCODING_8859_4);
  ------------------
  |  Branch (1203:9): [True: 0, False: 8]
  ------------------
 1204|      8|    if (!strcmp(upper,  "ISO-8859-5")) return(XML_CHAR_ENCODING_8859_5);
  ------------------
  |  Branch (1204:9): [True: 0, False: 8]
  ------------------
 1205|      8|    if (!strcmp(upper,  "ISO-8859-6")) return(XML_CHAR_ENCODING_8859_6);
  ------------------
  |  Branch (1205:9): [True: 0, False: 8]
  ------------------
 1206|      8|    if (!strcmp(upper,  "ISO-8859-7")) return(XML_CHAR_ENCODING_8859_7);
  ------------------
  |  Branch (1206:9): [True: 0, False: 8]
  ------------------
 1207|      8|    if (!strcmp(upper,  "ISO-8859-8")) return(XML_CHAR_ENCODING_8859_8);
  ------------------
  |  Branch (1207:9): [True: 0, False: 8]
  ------------------
 1208|      8|    if (!strcmp(upper,  "ISO-8859-9")) return(XML_CHAR_ENCODING_8859_9);
  ------------------
  |  Branch (1208:9): [True: 0, False: 8]
  ------------------
 1209|       |
 1210|      8|    if (!strcmp(upper, "ISO-2022-JP")) return(XML_CHAR_ENCODING_2022_JP);
  ------------------
  |  Branch (1210:9): [True: 0, False: 8]
  ------------------
 1211|      8|    if (!strcmp(upper, "SHIFT_JIS")) return(XML_CHAR_ENCODING_SHIFT_JIS);
  ------------------
  |  Branch (1211:9): [True: 0, False: 8]
  ------------------
 1212|      8|    if (!strcmp(upper, "EUC-JP")) return(XML_CHAR_ENCODING_EUC_JP);
  ------------------
  |  Branch (1212:9): [True: 0, False: 8]
  ------------------
 1213|       |
 1214|      8|    return(XML_CHAR_ENCODING_ERROR);
 1215|      8|}
xmlInitEncodingInternal:
 1470|      2|xmlInitEncodingInternal(void) {
 1471|      2|    unsigned short int tst = 0x1234;
 1472|      2|    unsigned char *ptr = (unsigned char *) &tst;
 1473|       |
 1474|      2|    if (*ptr == 0x12) xmlLittleEndian = 0;
  ------------------
  |  Branch (1474:9): [True: 0, False: 2]
  ------------------
 1475|      2|    else xmlLittleEndian = 1;
 1476|      2|}
xmlGetCharEncodingHandler:
 1547|  15.3k|xmlGetCharEncodingHandler(xmlCharEncoding enc) {
 1548|  15.3k|    xmlCharEncodingHandlerPtr handler;
 1549|       |
 1550|  15.3k|    switch (enc) {
 1551|      0|        case XML_CHAR_ENCODING_ERROR:
  ------------------
  |  Branch (1551:9): [True: 0, False: 15.3k]
  ------------------
 1552|      0|	    return(NULL);
 1553|  15.3k|        case XML_CHAR_ENCODING_NONE:
  ------------------
  |  Branch (1553:9): [True: 15.3k, False: 4]
  ------------------
 1554|  15.3k|	    return(NULL);
 1555|      0|        case XML_CHAR_ENCODING_UTF8:
  ------------------
  |  Branch (1555:9): [True: 0, False: 15.3k]
  ------------------
 1556|      0|	    return(NULL);
 1557|      0|        case XML_CHAR_ENCODING_UTF16LE:
  ------------------
  |  Branch (1557:9): [True: 0, False: 15.3k]
  ------------------
 1558|      0|	    return((xmlCharEncodingHandlerPtr) xmlUTF16LEHandler);
 1559|      0|        case XML_CHAR_ENCODING_UTF16BE:
  ------------------
  |  Branch (1559:9): [True: 0, False: 15.3k]
  ------------------
 1560|      0|	    return((xmlCharEncodingHandlerPtr) xmlUTF16BEHandler);
 1561|      4|        case XML_CHAR_ENCODING_EBCDIC:
  ------------------
  |  Branch (1561:9): [True: 4, False: 15.3k]
  ------------------
 1562|      4|            handler = xmlFindCharEncodingHandler("EBCDIC");
 1563|      4|            if (handler != NULL) return(handler);
  ------------------
  |  Branch (1563:17): [True: 0, False: 4]
  ------------------
 1564|      4|            handler = xmlFindCharEncodingHandler("ebcdic");
 1565|      4|            if (handler != NULL) return(handler);
  ------------------
  |  Branch (1565:17): [True: 0, False: 4]
  ------------------
 1566|      4|            handler = xmlFindCharEncodingHandler("EBCDIC-US");
 1567|      4|            if (handler != NULL) return(handler);
  ------------------
  |  Branch (1567:17): [True: 4, False: 0]
  ------------------
 1568|      0|            handler = xmlFindCharEncodingHandler("IBM-037");
 1569|      0|            if (handler != NULL) return(handler);
  ------------------
  |  Branch (1569:17): [True: 0, False: 0]
  ------------------
 1570|      0|	    break;
 1571|      0|        case XML_CHAR_ENCODING_UCS4BE:
  ------------------
  |  Branch (1571:9): [True: 0, False: 15.3k]
  ------------------
 1572|      0|            handler = xmlFindCharEncodingHandler("ISO-10646-UCS-4");
 1573|      0|            if (handler != NULL) return(handler);
  ------------------
  |  Branch (1573:17): [True: 0, False: 0]
  ------------------
 1574|      0|            handler = xmlFindCharEncodingHandler("UCS-4");
 1575|      0|            if (handler != NULL) return(handler);
  ------------------
  |  Branch (1575:17): [True: 0, False: 0]
  ------------------
 1576|      0|            handler = xmlFindCharEncodingHandler("UCS4");
 1577|      0|            if (handler != NULL) return(handler);
  ------------------
  |  Branch (1577:17): [True: 0, False: 0]
  ------------------
 1578|      0|	    break;
 1579|      0|        case XML_CHAR_ENCODING_UCS4LE:
  ------------------
  |  Branch (1579:9): [True: 0, False: 15.3k]
  ------------------
 1580|      0|            handler = xmlFindCharEncodingHandler("ISO-10646-UCS-4");
 1581|      0|            if (handler != NULL) return(handler);
  ------------------
  |  Branch (1581:17): [True: 0, False: 0]
  ------------------
 1582|      0|            handler = xmlFindCharEncodingHandler("UCS-4");
 1583|      0|            if (handler != NULL) return(handler);
  ------------------
  |  Branch (1583:17): [True: 0, False: 0]
  ------------------
 1584|      0|            handler = xmlFindCharEncodingHandler("UCS4");
 1585|      0|            if (handler != NULL) return(handler);
  ------------------
  |  Branch (1585:17): [True: 0, False: 0]
  ------------------
 1586|      0|	    break;
 1587|      0|        case XML_CHAR_ENCODING_UCS4_2143:
  ------------------
  |  Branch (1587:9): [True: 0, False: 15.3k]
  ------------------
 1588|      0|	    break;
 1589|      0|        case XML_CHAR_ENCODING_UCS4_3412:
  ------------------
  |  Branch (1589:9): [True: 0, False: 15.3k]
  ------------------
 1590|      0|	    break;
 1591|      0|        case XML_CHAR_ENCODING_UCS2:
  ------------------
  |  Branch (1591:9): [True: 0, False: 15.3k]
  ------------------
 1592|      0|            handler = xmlFindCharEncodingHandler("ISO-10646-UCS-2");
 1593|      0|            if (handler != NULL) return(handler);
  ------------------
  |  Branch (1593:17): [True: 0, False: 0]
  ------------------
 1594|      0|            handler = xmlFindCharEncodingHandler("UCS-2");
 1595|      0|            if (handler != NULL) return(handler);
  ------------------
  |  Branch (1595:17): [True: 0, False: 0]
  ------------------
 1596|      0|            handler = xmlFindCharEncodingHandler("UCS2");
 1597|      0|            if (handler != NULL) return(handler);
  ------------------
  |  Branch (1597:17): [True: 0, False: 0]
  ------------------
 1598|      0|	    break;
 1599|       |
 1600|       |	    /*
 1601|       |	     * We used to keep ISO Latin encodings native in the
 1602|       |	     * generated data. This led to so many problems that
 1603|       |	     * this has been removed. One can still change this
 1604|       |	     * back by registering no-ops encoders for those
 1605|       |	     */
 1606|      0|        case XML_CHAR_ENCODING_8859_1:
  ------------------
  |  Branch (1606:9): [True: 0, False: 15.3k]
  ------------------
 1607|      0|	    handler = xmlFindCharEncodingHandler("ISO-8859-1");
 1608|      0|	    if (handler != NULL) return(handler);
  ------------------
  |  Branch (1608:10): [True: 0, False: 0]
  ------------------
 1609|      0|	    break;
 1610|      0|        case XML_CHAR_ENCODING_8859_2:
  ------------------
  |  Branch (1610:9): [True: 0, False: 15.3k]
  ------------------
 1611|      0|	    handler = xmlFindCharEncodingHandler("ISO-8859-2");
 1612|      0|	    if (handler != NULL) return(handler);
  ------------------
  |  Branch (1612:10): [True: 0, False: 0]
  ------------------
 1613|      0|	    break;
 1614|      0|        case XML_CHAR_ENCODING_8859_3:
  ------------------
  |  Branch (1614:9): [True: 0, False: 15.3k]
  ------------------
 1615|      0|	    handler = xmlFindCharEncodingHandler("ISO-8859-3");
 1616|      0|	    if (handler != NULL) return(handler);
  ------------------
  |  Branch (1616:10): [True: 0, False: 0]
  ------------------
 1617|      0|	    break;
 1618|      0|        case XML_CHAR_ENCODING_8859_4:
  ------------------
  |  Branch (1618:9): [True: 0, False: 15.3k]
  ------------------
 1619|      0|	    handler = xmlFindCharEncodingHandler("ISO-8859-4");
 1620|      0|	    if (handler != NULL) return(handler);
  ------------------
  |  Branch (1620:10): [True: 0, False: 0]
  ------------------
 1621|      0|	    break;
 1622|      0|        case XML_CHAR_ENCODING_8859_5:
  ------------------
  |  Branch (1622:9): [True: 0, False: 15.3k]
  ------------------
 1623|      0|	    handler = xmlFindCharEncodingHandler("ISO-8859-5");
 1624|      0|	    if (handler != NULL) return(handler);
  ------------------
  |  Branch (1624:10): [True: 0, False: 0]
  ------------------
 1625|      0|	    break;
 1626|      0|        case XML_CHAR_ENCODING_8859_6:
  ------------------
  |  Branch (1626:9): [True: 0, False: 15.3k]
  ------------------
 1627|      0|	    handler = xmlFindCharEncodingHandler("ISO-8859-6");
 1628|      0|	    if (handler != NULL) return(handler);
  ------------------
  |  Branch (1628:10): [True: 0, False: 0]
  ------------------
 1629|      0|	    break;
 1630|      0|        case XML_CHAR_ENCODING_8859_7:
  ------------------
  |  Branch (1630:9): [True: 0, False: 15.3k]
  ------------------
 1631|      0|	    handler = xmlFindCharEncodingHandler("ISO-8859-7");
 1632|      0|	    if (handler != NULL) return(handler);
  ------------------
  |  Branch (1632:10): [True: 0, False: 0]
  ------------------
 1633|      0|	    break;
 1634|      0|        case XML_CHAR_ENCODING_8859_8:
  ------------------
  |  Branch (1634:9): [True: 0, False: 15.3k]
  ------------------
 1635|      0|	    handler = xmlFindCharEncodingHandler("ISO-8859-8");
 1636|      0|	    if (handler != NULL) return(handler);
  ------------------
  |  Branch (1636:10): [True: 0, False: 0]
  ------------------
 1637|      0|	    break;
 1638|      0|        case XML_CHAR_ENCODING_8859_9:
  ------------------
  |  Branch (1638:9): [True: 0, False: 15.3k]
  ------------------
 1639|      0|	    handler = xmlFindCharEncodingHandler("ISO-8859-9");
 1640|      0|	    if (handler != NULL) return(handler);
  ------------------
  |  Branch (1640:10): [True: 0, False: 0]
  ------------------
 1641|      0|	    break;
 1642|       |
 1643|       |
 1644|      0|        case XML_CHAR_ENCODING_2022_JP:
  ------------------
  |  Branch (1644:9): [True: 0, False: 15.3k]
  ------------------
 1645|      0|            handler = xmlFindCharEncodingHandler("ISO-2022-JP");
 1646|      0|            if (handler != NULL) return(handler);
  ------------------
  |  Branch (1646:17): [True: 0, False: 0]
  ------------------
 1647|      0|	    break;
 1648|      0|        case XML_CHAR_ENCODING_SHIFT_JIS:
  ------------------
  |  Branch (1648:9): [True: 0, False: 15.3k]
  ------------------
 1649|      0|            handler = xmlFindCharEncodingHandler("SHIFT-JIS");
 1650|      0|            if (handler != NULL) return(handler);
  ------------------
  |  Branch (1650:17): [True: 0, False: 0]
  ------------------
 1651|      0|            handler = xmlFindCharEncodingHandler("SHIFT_JIS");
 1652|      0|            if (handler != NULL) return(handler);
  ------------------
  |  Branch (1652:17): [True: 0, False: 0]
  ------------------
 1653|      0|            handler = xmlFindCharEncodingHandler("Shift_JIS");
 1654|      0|            if (handler != NULL) return(handler);
  ------------------
  |  Branch (1654:17): [True: 0, False: 0]
  ------------------
 1655|      0|	    break;
 1656|      0|        case XML_CHAR_ENCODING_EUC_JP:
  ------------------
  |  Branch (1656:9): [True: 0, False: 15.3k]
  ------------------
 1657|      0|            handler = xmlFindCharEncodingHandler("EUC-JP");
 1658|      0|            if (handler != NULL) return(handler);
  ------------------
  |  Branch (1658:17): [True: 0, False: 0]
  ------------------
 1659|      0|	    break;
 1660|      0|	default:
  ------------------
  |  Branch (1660:2): [True: 0, False: 15.3k]
  ------------------
 1661|      0|	    break;
 1662|  15.3k|    }
 1663|       |
 1664|      0|    return(NULL);
 1665|  15.3k|}
xmlFindCharEncodingHandler:
 1677|    164|xmlFindCharEncodingHandler(const char *name) {
 1678|    164|    const char *nalias;
 1679|    164|    const char *norig;
 1680|    164|    xmlCharEncoding alias;
 1681|    164|#ifdef LIBXML_ICONV_ENABLED
 1682|    164|    xmlCharEncodingHandlerPtr enc;
 1683|    164|    iconv_t icv_in, icv_out;
 1684|    164|#endif /* LIBXML_ICONV_ENABLED */
 1685|       |#ifdef LIBXML_ICU_ENABLED
 1686|       |    xmlCharEncodingHandlerPtr encu;
 1687|       |    uconv_t *ucv_in, *ucv_out;
 1688|       |#endif /* LIBXML_ICU_ENABLED */
 1689|    164|    char upper[100];
 1690|    164|    int i;
 1691|       |
 1692|    164|    if (name == NULL) return(NULL);
  ------------------
  |  Branch (1692:9): [True: 0, False: 164]
  ------------------
 1693|    164|    if (name[0] == 0) return(NULL);
  ------------------
  |  Branch (1693:9): [True: 0, False: 164]
  ------------------
 1694|       |
 1695|       |    /*
 1696|       |     * Do the alias resolution
 1697|       |     */
 1698|    164|    norig = name;
 1699|    164|    nalias = xmlGetEncodingAlias(name);
 1700|    164|    if (nalias != NULL)
  ------------------
  |  Branch (1700:9): [True: 0, False: 164]
  ------------------
 1701|      0|	name = nalias;
 1702|       |
 1703|       |    /*
 1704|       |     * Check first for directly registered encoding names
 1705|       |     */
 1706|  1.33k|    for (i = 0;i < 99;i++) {
  ------------------
  |  Branch (1706:16): [True: 1.33k, False: 0]
  ------------------
 1707|  1.33k|        upper[i] = (char) toupper((unsigned char) name[i]);
 1708|  1.33k|	if (upper[i] == 0) break;
  ------------------
  |  Branch (1708:6): [True: 164, False: 1.17k]
  ------------------
 1709|  1.33k|    }
 1710|    164|    upper[i] = 0;
 1711|       |
 1712|    604|    for (i = 0; i < (int) NUM_DEFAULT_HANDLERS; i++) {
  ------------------
  |  | 1373|    604|    (sizeof(defaultHandlers) / sizeof(defaultHandlers[0]))
  ------------------
  |  Branch (1712:17): [True: 580, False: 24]
  ------------------
 1713|    580|        if (strcmp(upper, defaultHandlers[i].name) == 0)
  ------------------
  |  Branch (1713:13): [True: 140, False: 440]
  ------------------
 1714|    140|            return((xmlCharEncodingHandlerPtr) &defaultHandlers[i]);
 1715|    580|    }
 1716|       |
 1717|     24|    if (handlers != NULL) {
  ------------------
  |  Branch (1717:9): [True: 0, False: 24]
  ------------------
 1718|      0|        for (i = 0;i < nbCharEncodingHandler; i++) {
  ------------------
  |  Branch (1718:20): [True: 0, False: 0]
  ------------------
 1719|      0|            if (!strcmp(upper, handlers[i]->name)) {
  ------------------
  |  Branch (1719:17): [True: 0, False: 0]
  ------------------
 1720|      0|                return(handlers[i]);
 1721|      0|            }
 1722|      0|        }
 1723|      0|    }
 1724|       |
 1725|     24|#ifdef LIBXML_ICONV_ENABLED
 1726|       |    /* check whether iconv can handle this */
 1727|     24|    icv_in = iconv_open("UTF-8", name);
 1728|     24|    icv_out = iconv_open(name, "UTF-8");
 1729|     24|    if (icv_in == (iconv_t) -1) {
  ------------------
  |  Branch (1729:9): [True: 8, False: 16]
  ------------------
 1730|      8|        icv_in = iconv_open("UTF-8", upper);
 1731|      8|    }
 1732|     24|    if (icv_out == (iconv_t) -1) {
  ------------------
  |  Branch (1732:9): [True: 8, False: 16]
  ------------------
 1733|      8|	icv_out = iconv_open(upper, "UTF-8");
 1734|      8|    }
 1735|     24|    if ((icv_in != (iconv_t) -1) && (icv_out != (iconv_t) -1)) {
  ------------------
  |  Branch (1735:9): [True: 16, False: 8]
  |  Branch (1735:37): [True: 16, False: 0]
  ------------------
 1736|     16|	    enc = (xmlCharEncodingHandlerPtr)
 1737|     16|	          xmlMalloc(sizeof(xmlCharEncodingHandler));
 1738|     16|	    if (enc == NULL) {
  ------------------
  |  Branch (1738:10): [True: 0, False: 16]
  ------------------
 1739|      0|	        iconv_close(icv_in);
 1740|      0|	        iconv_close(icv_out);
 1741|      0|		return(NULL);
 1742|      0|	    }
 1743|     16|            memset(enc, 0, sizeof(xmlCharEncodingHandler));
 1744|     16|	    enc->name = xmlMemStrdup(name);
 1745|     16|            if (enc->name == NULL) {
  ------------------
  |  Branch (1745:17): [True: 0, False: 16]
  ------------------
 1746|      0|                xmlFree(enc);
 1747|      0|                iconv_close(icv_in);
 1748|      0|                iconv_close(icv_out);
 1749|      0|                return(NULL);
 1750|      0|            }
 1751|     16|	    enc->input = NULL;
 1752|     16|	    enc->output = NULL;
 1753|     16|	    enc->iconv_in = icv_in;
 1754|     16|	    enc->iconv_out = icv_out;
 1755|     16|	    return enc;
 1756|     16|    } else if ((icv_in != (iconv_t) -1) || icv_out != (iconv_t) -1) {
  ------------------
  |  Branch (1756:16): [True: 0, False: 8]
  |  Branch (1756:44): [True: 0, False: 8]
  ------------------
 1757|      0|	    if (icv_in != (iconv_t) -1)
  ------------------
  |  Branch (1757:10): [True: 0, False: 0]
  ------------------
 1758|      0|		iconv_close(icv_in);
 1759|      0|	    else
 1760|      0|		iconv_close(icv_out);
 1761|      0|    }
 1762|      8|#endif /* LIBXML_ICONV_ENABLED */
 1763|       |#ifdef LIBXML_ICU_ENABLED
 1764|       |    /* check whether icu can handle this */
 1765|       |    ucv_in = openIcuConverter(name, 1);
 1766|       |    ucv_out = openIcuConverter(name, 0);
 1767|       |    if (ucv_in != NULL && ucv_out != NULL) {
 1768|       |	    encu = (xmlCharEncodingHandlerPtr)
 1769|       |	           xmlMalloc(sizeof(xmlCharEncodingHandler));
 1770|       |	    if (encu == NULL) {
 1771|       |                closeIcuConverter(ucv_in);
 1772|       |                closeIcuConverter(ucv_out);
 1773|       |		return(NULL);
 1774|       |	    }
 1775|       |            memset(encu, 0, sizeof(xmlCharEncodingHandler));
 1776|       |	    encu->name = xmlMemStrdup(name);
 1777|       |            if (encu->name == NULL) {
 1778|       |                xmlFree(encu);
 1779|       |                closeIcuConverter(ucv_in);
 1780|       |                closeIcuConverter(ucv_out);
 1781|       |                return(NULL);
 1782|       |            }
 1783|       |	    encu->input = NULL;
 1784|       |	    encu->output = NULL;
 1785|       |	    encu->uconv_in = ucv_in;
 1786|       |	    encu->uconv_out = ucv_out;
 1787|       |	    return encu;
 1788|       |    } else if (ucv_in != NULL || ucv_out != NULL) {
 1789|       |            closeIcuConverter(ucv_in);
 1790|       |            closeIcuConverter(ucv_out);
 1791|       |    }
 1792|       |#endif /* LIBXML_ICU_ENABLED */
 1793|       |
 1794|       |    /*
 1795|       |     * Fallback using the canonical names
 1796|       |     */
 1797|      8|    alias = xmlParseCharEncoding(norig);
 1798|      8|    if (alias != XML_CHAR_ENCODING_ERROR) {
  ------------------
  |  Branch (1798:9): [True: 0, False: 8]
  ------------------
 1799|      0|        const char* canon;
 1800|      0|        canon = xmlGetCharEncodingName(alias);
 1801|      0|        if ((canon != NULL) && (strcmp(name, canon))) {
  ------------------
  |  Branch (1801:13): [True: 0, False: 0]
  |  Branch (1801:32): [True: 0, False: 0]
  ------------------
 1802|      0|	    return(xmlFindCharEncodingHandler(canon));
 1803|      0|        }
 1804|      0|    }
 1805|       |
 1806|       |    /* If "none of the above", give up */
 1807|      8|    return(NULL);
 1808|      8|}
xmlEncInputChunk:
 1988|  2.09k|                 int *outlen, const unsigned char *in, int *inlen) {
 1989|  2.09k|    int ret;
 1990|       |
 1991|  2.09k|    if (handler->input != NULL) {
  ------------------
  |  Branch (1991:9): [True: 1.97k, False: 122]
  ------------------
 1992|  1.97k|        int oldinlen = *inlen;
 1993|       |
 1994|  1.97k|        ret = handler->input(out, outlen, in, inlen);
 1995|  1.97k|        if (ret >= 0) {
  ------------------
  |  Branch (1995:13): [True: 1.97k, False: 0]
  ------------------
 1996|       |            /*
 1997|       |             * The built-in converters don't signal XML_ENC_ERR_SPACE.
 1998|       |             */
 1999|  1.97k|            if (*inlen < oldinlen) {
  ------------------
  |  Branch (1999:17): [True: 0, False: 1.97k]
  ------------------
 2000|      0|                if (*outlen > 0)
  ------------------
  |  Branch (2000:21): [True: 0, False: 0]
  ------------------
 2001|      0|                    ret = XML_ENC_ERR_SPACE;
 2002|      0|                else
 2003|      0|                    ret = XML_ENC_ERR_PARTIAL;
 2004|  1.97k|            } else {
 2005|  1.97k|                ret = XML_ENC_ERR_SUCCESS;
 2006|  1.97k|            }
 2007|  1.97k|        }
 2008|  1.97k|    }
 2009|    122|#ifdef LIBXML_ICONV_ENABLED
 2010|    122|    else if (handler->iconv_in != NULL) {
  ------------------
  |  Branch (2010:14): [True: 122, False: 0]
  ------------------
 2011|    122|        ret = xmlIconvWrapper(handler->iconv_in, out, outlen, in, inlen);
 2012|    122|    }
 2013|      0|#endif /* LIBXML_ICONV_ENABLED */
 2014|       |#ifdef LIBXML_ICU_ENABLED
 2015|       |    else if (handler->uconv_in != NULL) {
 2016|       |        ret = xmlUconvWrapper(handler->uconv_in, 1, out, outlen, in, inlen);
 2017|       |    }
 2018|       |#endif /* LIBXML_ICU_ENABLED */
 2019|      0|    else {
 2020|      0|        *outlen = 0;
 2021|      0|        *inlen = 0;
 2022|      0|        ret = XML_ENC_ERR_INTERNAL;
 2023|      0|    }
 2024|       |
 2025|       |    /* Ignore partial errors when reading. */
 2026|  2.09k|    if (ret == XML_ENC_ERR_PARTIAL)
  ------------------
  |  Branch (2026:9): [True: 0, False: 2.09k]
  ------------------
 2027|      0|        ret = XML_ENC_ERR_SUCCESS;
 2028|       |
 2029|  2.09k|    return(ret);
 2030|  2.09k|}
xmlCharEncInput:
 2118|  4.54k|{
 2119|  4.54k|    int ret;
 2120|  4.54k|    size_t avail;
 2121|  4.54k|    size_t toconv;
 2122|  4.54k|    int c_in;
 2123|  4.54k|    int c_out;
 2124|  4.54k|    xmlBufPtr in;
 2125|  4.54k|    xmlBufPtr out;
 2126|  4.54k|    const xmlChar *inData;
 2127|  4.54k|    size_t inTotal = 0;
 2128|       |
 2129|  4.54k|    if ((input == NULL) || (input->encoder == NULL) ||
  ------------------
  |  Branch (2129:9): [True: 0, False: 4.54k]
  |  Branch (2129:28): [True: 0, False: 4.54k]
  ------------------
 2130|  4.54k|        (input->buffer == NULL) || (input->raw == NULL))
  ------------------
  |  Branch (2130:9): [True: 0, False: 4.54k]
  |  Branch (2130:36): [True: 0, False: 4.54k]
  ------------------
 2131|      0|        return(XML_ENC_ERR_INTERNAL);
 2132|  4.54k|    out = input->buffer;
 2133|  4.54k|    in = input->raw;
 2134|       |
 2135|  4.54k|    toconv = xmlBufUse(in);
 2136|  4.54k|    if (toconv == 0)
  ------------------
  |  Branch (2136:9): [True: 2.45k, False: 2.08k]
  ------------------
 2137|  2.45k|        return (0);
 2138|  2.08k|    inData = xmlBufContent(in);
 2139|  2.08k|    inTotal = 0;
 2140|       |
 2141|  2.08k|    do {
 2142|  2.08k|        c_in = toconv > INT_MAX / 2 ? INT_MAX / 2 : toconv;
  ------------------
  |  Branch (2142:16): [True: 0, False: 2.08k]
  ------------------
 2143|       |
 2144|  2.08k|        avail = xmlBufAvail(out);
 2145|  2.08k|        if (avail > INT_MAX)
  ------------------
  |  Branch (2145:13): [True: 0, False: 2.08k]
  ------------------
 2146|      0|            avail = INT_MAX;
 2147|  2.08k|        if (avail < 4096) {
  ------------------
  |  Branch (2147:13): [True: 107, False: 1.98k]
  ------------------
 2148|    107|            if (xmlBufGrow(out, 4096) < 0) {
  ------------------
  |  Branch (2148:17): [True: 0, False: 107]
  ------------------
 2149|      0|                input->error = XML_ERR_NO_MEMORY;
 2150|      0|                return(XML_ENC_ERR_MEMORY);
 2151|      0|            }
 2152|    107|            avail = xmlBufAvail(out);
 2153|    107|        }
 2154|       |
 2155|  2.08k|        c_in = toconv;
 2156|  2.08k|        c_out = avail;
 2157|  2.08k|        ret = xmlEncInputChunk(input->encoder, xmlBufEnd(out), &c_out,
 2158|  2.08k|                               inData, &c_in);
 2159|  2.08k|        inTotal += c_in;
 2160|  2.08k|        inData += c_in;
 2161|  2.08k|        toconv -= c_in;
 2162|  2.08k|        xmlBufAddLen(out, c_out);
 2163|  2.08k|    } while (ret == XML_ENC_ERR_SPACE);
  ------------------
  |  Branch (2163:14): [True: 0, False: 2.08k]
  ------------------
 2164|       |
 2165|  2.08k|    xmlBufShrink(in, inTotal);
 2166|       |
 2167|  2.08k|    if (input->rawconsumed > ULONG_MAX - (unsigned long)c_in)
  ------------------
  |  Branch (2167:9): [True: 0, False: 2.08k]
  ------------------
 2168|      0|        input->rawconsumed = ULONG_MAX;
 2169|  2.08k|    else
 2170|  2.08k|        input->rawconsumed += c_in;
 2171|       |
 2172|  2.08k|    if ((c_out == 0) && (ret != 0)) {
  ------------------
  |  Branch (2172:9): [True: 0, False: 2.08k]
  |  Branch (2172:25): [True: 0, False: 0]
  ------------------
 2173|      0|        if (input->error == 0)
  ------------------
  |  Branch (2173:13): [True: 0, False: 0]
  ------------------
 2174|      0|            input->error = xmlEncConvertError(ret);
 2175|      0|        return(ret);
 2176|      0|    }
 2177|       |
 2178|  2.08k|    return (c_out);
 2179|  2.08k|}
xmlCharEncCloseFunc:
 2454|    156|xmlCharEncCloseFunc(xmlCharEncodingHandler *handler) {
 2455|    156|    int ret = 0;
 2456|    156|    int tofree = 0;
 2457|    156|    int i = 0;
 2458|       |
 2459|    156|    if (handler == NULL) return(-1);
  ------------------
  |  Branch (2459:9): [True: 0, False: 156]
  ------------------
 2460|       |
 2461|    532|    for (i = 0; i < (int) NUM_DEFAULT_HANDLERS; i++) {
  ------------------
  |  | 1373|    532|    (sizeof(defaultHandlers) / sizeof(defaultHandlers[0]))
  ------------------
  |  Branch (2461:17): [True: 516, False: 16]
  ------------------
 2462|    516|        if (handler == &defaultHandlers[i])
  ------------------
  |  Branch (2462:13): [True: 140, False: 376]
  ------------------
 2463|    140|            return(0);
 2464|    516|    }
 2465|       |
 2466|     16|    if (handlers != NULL) {
  ------------------
  |  Branch (2466:9): [True: 0, False: 16]
  ------------------
 2467|      0|        for (i = 0;i < nbCharEncodingHandler; i++) {
  ------------------
  |  Branch (2467:20): [True: 0, False: 0]
  ------------------
 2468|      0|            if (handler == handlers[i])
  ------------------
  |  Branch (2468:17): [True: 0, False: 0]
  ------------------
 2469|      0|                return(0);
 2470|      0|	}
 2471|      0|    }
 2472|     16|#ifdef LIBXML_ICONV_ENABLED
 2473|       |    /*
 2474|       |     * Iconv handlers can be used only once, free the whole block.
 2475|       |     * and the associated icon resources.
 2476|       |     */
 2477|     16|    if ((handler->iconv_out != NULL) || (handler->iconv_in != NULL)) {
  ------------------
  |  Branch (2477:9): [True: 16, False: 0]
  |  Branch (2477:41): [True: 0, False: 0]
  ------------------
 2478|     16|        tofree = 1;
 2479|     16|	if (handler->iconv_out != NULL) {
  ------------------
  |  Branch (2479:6): [True: 16, False: 0]
  ------------------
 2480|     16|	    if (iconv_close(handler->iconv_out))
  ------------------
  |  Branch (2480:10): [True: 0, False: 16]
  ------------------
 2481|      0|		ret = -1;
 2482|     16|	    handler->iconv_out = NULL;
 2483|     16|	}
 2484|     16|	if (handler->iconv_in != NULL) {
  ------------------
  |  Branch (2484:6): [True: 16, False: 0]
  ------------------
 2485|     16|	    if (iconv_close(handler->iconv_in))
  ------------------
  |  Branch (2485:10): [True: 0, False: 16]
  ------------------
 2486|      0|		ret = -1;
 2487|     16|	    handler->iconv_in = NULL;
 2488|     16|	}
 2489|     16|    }
 2490|     16|#endif /* LIBXML_ICONV_ENABLED */
 2491|       |#ifdef LIBXML_ICU_ENABLED
 2492|       |    if ((handler->uconv_out != NULL) || (handler->uconv_in != NULL)) {
 2493|       |        tofree = 1;
 2494|       |	if (handler->uconv_out != NULL) {
 2495|       |	    closeIcuConverter(handler->uconv_out);
 2496|       |	    handler->uconv_out = NULL;
 2497|       |	}
 2498|       |	if (handler->uconv_in != NULL) {
 2499|       |	    closeIcuConverter(handler->uconv_in);
 2500|       |	    handler->uconv_in = NULL;
 2501|       |	}
 2502|       |    }
 2503|       |#endif
 2504|     16|    if (tofree) {
  ------------------
  |  Branch (2504:9): [True: 16, False: 0]
  ------------------
 2505|       |        /* free up only dynamic handlers iconv/uconv */
 2506|     16|        if (handler->name != NULL)
  ------------------
  |  Branch (2506:13): [True: 16, False: 0]
  ------------------
 2507|     16|            xmlFree(handler->name);
 2508|     16|        handler->name = NULL;
 2509|     16|        xmlFree(handler);
 2510|     16|    }
 2511|       |
 2512|     16|    return(ret);
 2513|     16|}
encoding.c:asciiToUTF8:
  149|      6|              const unsigned char* in, int *inlen) {
  150|      6|    unsigned char* outstart = out;
  151|      6|    const unsigned char* base = in;
  152|      6|    const unsigned char* processed = in;
  153|      6|    unsigned char* outend = out + *outlen;
  154|      6|    const unsigned char* inend;
  155|      6|    unsigned int c;
  156|       |
  157|      6|    inend = in + (*inlen);
  158|  1.06k|    while ((in < inend) && (out - outstart + 5 < *outlen)) {
  ------------------
  |  Branch (158:12): [True: 1.05k, False: 6]
  |  Branch (158:28): [True: 1.05k, False: 0]
  ------------------
  159|  1.05k|	c= *in++;
  160|       |
  161|  1.05k|        if (out >= outend)
  ------------------
  |  Branch (161:13): [True: 0, False: 1.05k]
  ------------------
  162|      0|	    break;
  163|  1.05k|        if (c < 0x80) {
  ------------------
  |  Branch (163:13): [True: 1.05k, False: 0]
  ------------------
  164|  1.05k|	    *out++ = c;
  165|  1.05k|	} else {
  166|      0|	    *outlen = out - outstart;
  167|      0|	    *inlen = processed - base;
  168|      0|	    return(XML_ENC_ERR_INPUT);
  169|      0|	}
  170|       |
  171|  1.05k|	processed = (const unsigned char*) in;
  172|  1.05k|    }
  173|      6|    *outlen = out - outstart;
  174|      6|    *inlen = processed - base;
  175|      6|    return(*outlen);
  176|      6|}
encoding.c:xmlIconvWrapper:
 1833|    122|                const unsigned char *in, int *inlen) {
 1834|    122|    size_t icv_inlen, icv_outlen;
 1835|    122|    const char *icv_in = (const char *) in;
 1836|    122|    char *icv_out = (char *) out;
 1837|    122|    size_t ret;
 1838|       |
 1839|    122|    if ((out == NULL) || (outlen == NULL) || (inlen == NULL) || (in == NULL)) {
  ------------------
  |  Branch (1839:9): [True: 0, False: 122]
  |  Branch (1839:26): [True: 0, False: 122]
  |  Branch (1839:46): [True: 0, False: 122]
  |  Branch (1839:65): [True: 0, False: 122]
  ------------------
 1840|      0|        if (outlen != NULL) *outlen = 0;
  ------------------
  |  Branch (1840:13): [True: 0, False: 0]
  ------------------
 1841|      0|        return(XML_ENC_ERR_INTERNAL);
 1842|      0|    }
 1843|    122|    icv_inlen = *inlen;
 1844|    122|    icv_outlen = *outlen;
 1845|       |    /*
 1846|       |     * Some versions take const, other versions take non-const input.
 1847|       |     */
 1848|    122|    ret = iconv(cd, (void *) &icv_in, &icv_inlen, &icv_out, &icv_outlen);
 1849|    122|    *inlen -= icv_inlen;
 1850|    122|    *outlen -= icv_outlen;
 1851|    122|    if (ret == (size_t) -1) {
  ------------------
  |  Branch (1851:9): [True: 0, False: 122]
  ------------------
 1852|      0|        if (errno == EILSEQ)
  ------------------
  |  Branch (1852:13): [True: 0, False: 0]
  ------------------
 1853|      0|            return(XML_ENC_ERR_INPUT);
 1854|      0|        if (errno == E2BIG)
  ------------------
  |  Branch (1854:13): [True: 0, False: 0]
  ------------------
 1855|      0|            return(XML_ENC_ERR_SPACE);
 1856|      0|        if (errno == EINVAL)
  ------------------
  |  Branch (1856:13): [True: 0, False: 0]
  ------------------
 1857|      0|            return(XML_ENC_ERR_PARTIAL);
 1858|      0|        return(XML_ENC_ERR_INTERNAL);
 1859|      0|    }
 1860|    122|    return(XML_ENC_ERR_SUCCESS);
 1861|    122|}

xmlFreeEntity:
  118|  2.33k|{
  119|  2.33k|    xmlDictPtr dict = NULL;
  120|       |
  121|  2.33k|    if (entity == NULL)
  ------------------
  |  Branch (121:9): [True: 0, False: 2.33k]
  ------------------
  122|      0|        return;
  123|       |
  124|  2.33k|    if (entity->doc != NULL)
  ------------------
  |  Branch (124:9): [True: 2.33k, False: 0]
  ------------------
  125|  2.33k|        dict = entity->doc->dict;
  126|       |
  127|       |
  128|  2.33k|    if ((entity->children) && (entity->owner == 1) &&
  ------------------
  |  Branch (128:9): [True: 280, False: 2.05k]
  |  Branch (128:31): [True: 280, False: 0]
  ------------------
  129|  2.33k|        (entity == (xmlEntityPtr) entity->children->parent))
  ------------------
  |  Branch (129:9): [True: 280, False: 0]
  ------------------
  130|    280|        xmlFreeNodeList(entity->children);
  131|  2.33k|    if ((entity->name != NULL) &&
  ------------------
  |  Branch (131:9): [True: 2.33k, False: 0]
  ------------------
  132|  2.33k|        ((dict == NULL) || (!xmlDictOwns(dict, entity->name))))
  ------------------
  |  Branch (132:10): [True: 0, False: 2.33k]
  |  Branch (132:28): [True: 0, False: 2.33k]
  ------------------
  133|      0|        xmlFree((char *) entity->name);
  134|  2.33k|    if (entity->ExternalID != NULL)
  ------------------
  |  Branch (134:9): [True: 8, False: 2.32k]
  ------------------
  135|      8|        xmlFree((char *) entity->ExternalID);
  136|  2.33k|    if (entity->SystemID != NULL)
  ------------------
  |  Branch (136:9): [True: 84, False: 2.25k]
  ------------------
  137|     84|        xmlFree((char *) entity->SystemID);
  138|  2.33k|    if (entity->URI != NULL)
  ------------------
  |  Branch (138:9): [True: 84, False: 2.25k]
  ------------------
  139|     84|        xmlFree((char *) entity->URI);
  140|  2.33k|    if (entity->content != NULL)
  ------------------
  |  Branch (140:9): [True: 2.26k, False: 72]
  ------------------
  141|  2.26k|        xmlFree((char *) entity->content);
  142|  2.33k|    if (entity->orig != NULL)
  ------------------
  |  Branch (142:9): [True: 2.23k, False: 104]
  ------------------
  143|  2.23k|        xmlFree((char *) entity->orig);
  144|  2.33k|    xmlFree(entity);
  145|  2.33k|}
xmlGetPredefinedEntity:
  295|   445k|xmlGetPredefinedEntity(const xmlChar *name) {
  296|   445k|    if (name == NULL) return(NULL);
  ------------------
  |  Branch (296:9): [True: 0, False: 445k]
  ------------------
  297|   445k|    switch (name[0]) {
  298|   299k|        case 'l':
  ------------------
  |  Branch (298:9): [True: 299k, False: 146k]
  ------------------
  299|   299k|	    if (xmlStrEqual(name, BAD_CAST "lt"))
  ------------------
  |  |   35|   299k|#define BAD_CAST (xmlChar *)
  ------------------
  |  Branch (299:10): [True: 500, False: 298k]
  ------------------
  300|    500|	        return(&xmlEntityLt);
  301|   298k|	    break;
  302|   298k|        case 'g':
  ------------------
  |  Branch (302:9): [True: 1.16k, False: 444k]
  ------------------
  303|  1.16k|	    if (xmlStrEqual(name, BAD_CAST "gt"))
  ------------------
  |  |   35|  1.16k|#define BAD_CAST (xmlChar *)
  ------------------
  |  Branch (303:10): [True: 208, False: 960]
  ------------------
  304|    208|	        return(&xmlEntityGt);
  305|    960|	    break;
  306|    960|        case 'a':
  ------------------
  |  Branch (306:9): [True: 496, False: 445k]
  ------------------
  307|    496|	    if (xmlStrEqual(name, BAD_CAST "amp"))
  ------------------
  |  |   35|    496|#define BAD_CAST (xmlChar *)
  ------------------
  |  Branch (307:10): [True: 256, False: 240]
  ------------------
  308|    256|	        return(&xmlEntityAmp);
  309|    240|	    if (xmlStrEqual(name, BAD_CAST "apos"))
  ------------------
  |  |   35|    240|#define BAD_CAST (xmlChar *)
  ------------------
  |  Branch (309:10): [True: 36, False: 204]
  ------------------
  310|     36|	        return(&xmlEntityApos);
  311|    204|	    break;
  312|    204|        case 'q':
  ------------------
  |  Branch (312:9): [True: 16, False: 445k]
  ------------------
  313|     16|	    if (xmlStrEqual(name, BAD_CAST "quot"))
  ------------------
  |  |   35|     16|#define BAD_CAST (xmlChar *)
  ------------------
  |  Branch (313:10): [True: 16, False: 0]
  ------------------
  314|     16|	        return(&xmlEntityQuot);
  315|      0|	    break;
  316|   144k|	default:
  ------------------
  |  Branch (316:2): [True: 144k, False: 300k]
  ------------------
  317|   144k|	    break;
  318|   445k|    }
  319|   444k|    return(NULL);
  320|   445k|}
xmlAddDtdEntity:
  338|    684|		const xmlChar *content) {
  339|    684|    xmlEntityPtr ret;
  340|    684|    xmlDtdPtr dtd;
  341|       |
  342|    684|    if (doc == NULL) {
  ------------------
  |  Branch (342:9): [True: 0, False: 684]
  ------------------
  343|      0|	xmlEntitiesErr(XML_DTD_NO_DOC,
  344|      0|	        "xmlAddDtdEntity: document is NULL");
  345|      0|	return(NULL);
  346|      0|    }
  347|    684|    if (doc->extSubset == NULL) {
  ------------------
  |  Branch (347:9): [True: 0, False: 684]
  ------------------
  348|      0|	xmlEntitiesErr(XML_DTD_NO_DTD,
  349|      0|	        "xmlAddDtdEntity: document without external subset");
  350|      0|	return(NULL);
  351|      0|    }
  352|    684|    dtd = doc->extSubset;
  353|    684|    ret = xmlAddEntity(dtd, name, type, ExternalID, SystemID, content);
  354|    684|    if (ret == NULL) return(NULL);
  ------------------
  |  Branch (354:9): [True: 0, False: 684]
  ------------------
  355|       |
  356|       |    /*
  357|       |     * Link it to the DTD
  358|       |     */
  359|    684|    ret->parent = dtd;
  360|    684|    ret->doc = dtd->doc;
  361|    684|    if (dtd->last == NULL) {
  ------------------
  |  Branch (361:9): [True: 28, False: 656]
  ------------------
  362|     28|	dtd->children = dtd->last = (xmlNodePtr) ret;
  363|    656|    } else {
  364|    656|        dtd->last->next = (xmlNodePtr) ret;
  365|    656|	ret->prev = dtd->last;
  366|    656|	dtd->last = (xmlNodePtr) ret;
  367|    656|    }
  368|    684|    return(ret);
  369|    684|}
xmlAddDocEntity:
  387|  1.65k|	        const xmlChar *content) {
  388|  1.65k|    xmlEntityPtr ret;
  389|  1.65k|    xmlDtdPtr dtd;
  390|       |
  391|  1.65k|    if (doc == NULL) {
  ------------------
  |  Branch (391:9): [True: 0, False: 1.65k]
  ------------------
  392|      0|	xmlEntitiesErr(XML_DTD_NO_DOC,
  393|      0|	        "xmlAddDocEntity: document is NULL");
  394|      0|	return(NULL);
  395|      0|    }
  396|  1.65k|    if (doc->intSubset == NULL) {
  ------------------
  |  Branch (396:9): [True: 0, False: 1.65k]
  ------------------
  397|      0|	xmlEntitiesErr(XML_DTD_NO_DTD,
  398|      0|	        "xmlAddDocEntity: document without internal subset");
  399|      0|	return(NULL);
  400|      0|    }
  401|  1.65k|    dtd = doc->intSubset;
  402|  1.65k|    ret = xmlAddEntity(dtd, name, type, ExternalID, SystemID, content);
  403|  1.65k|    if (ret == NULL) return(NULL);
  ------------------
  |  Branch (403:9): [True: 8, False: 1.64k]
  ------------------
  404|       |
  405|       |    /*
  406|       |     * Link it to the DTD
  407|       |     */
  408|  1.64k|    ret->parent = dtd;
  409|  1.64k|    ret->doc = dtd->doc;
  410|  1.64k|    if (dtd->last == NULL) {
  ------------------
  |  Branch (410:9): [True: 152, False: 1.49k]
  ------------------
  411|    152|	dtd->children = dtd->last = (xmlNodePtr) ret;
  412|  1.49k|    } else {
  413|  1.49k|	dtd->last->next = (xmlNodePtr) ret;
  414|  1.49k|	ret->prev = dtd->last;
  415|  1.49k|	dtd->last = (xmlNodePtr) ret;
  416|  1.49k|    }
  417|  1.64k|    return(ret);
  418|  1.65k|}
xmlGetParameterEntity:
  485|   139k|xmlGetParameterEntity(xmlDocPtr doc, const xmlChar *name) {
  486|   139k|    xmlEntitiesTablePtr table;
  487|   139k|    xmlEntityPtr ret;
  488|       |
  489|   139k|    if (doc == NULL)
  ------------------
  |  Branch (489:9): [True: 0, False: 139k]
  ------------------
  490|      0|	return(NULL);
  491|   139k|    if ((doc->intSubset != NULL) && (doc->intSubset->pentities != NULL)) {
  ------------------
  |  Branch (491:9): [True: 139k, False: 0]
  |  Branch (491:37): [True: 136k, False: 3.04k]
  ------------------
  492|   136k|	table = (xmlEntitiesTablePtr) doc->intSubset->pentities;
  493|   136k|	ret = xmlGetEntityFromTable(table, name);
  494|   136k|	if (ret != NULL)
  ------------------
  |  Branch (494:6): [True: 135k, False: 704]
  ------------------
  495|   135k|	    return(ret);
  496|   136k|    }
  497|  3.74k|    if ((doc->extSubset != NULL) && (doc->extSubset->pentities != NULL)) {
  ------------------
  |  Branch (497:9): [True: 3.74k, False: 0]
  |  Branch (497:37): [True: 3.74k, False: 0]
  ------------------
  498|  3.74k|	table = (xmlEntitiesTablePtr) doc->extSubset->pentities;
  499|  3.74k|	return(xmlGetEntityFromTable(table, name));
  500|  3.74k|    }
  501|      0|    return(NULL);
  502|  3.74k|}
xmlGetDocEntity:
  540|   223k|xmlGetDocEntity(const xmlDoc *doc, const xmlChar *name) {
  541|   223k|    xmlEntityPtr cur;
  542|   223k|    xmlEntitiesTablePtr table;
  543|       |
  544|   223k|    if (doc != NULL) {
  ------------------
  |  Branch (544:9): [True: 223k, False: 0]
  ------------------
  545|   223k|	if ((doc->intSubset != NULL) && (doc->intSubset->entities != NULL)) {
  ------------------
  |  Branch (545:6): [True: 223k, False: 0]
  |  Branch (545:34): [True: 223k, False: 72]
  ------------------
  546|   223k|	    table = (xmlEntitiesTablePtr) doc->intSubset->entities;
  547|   223k|	    cur = xmlGetEntityFromTable(table, name);
  548|   223k|	    if (cur != NULL)
  ------------------
  |  Branch (548:10): [True: 223k, False: 52]
  ------------------
  549|   223k|		return(cur);
  550|   223k|	}
  551|    124|	if (doc->standalone != 1) {
  ------------------
  |  Branch (551:6): [True: 124, False: 0]
  ------------------
  552|    124|	    if ((doc->extSubset != NULL) &&
  ------------------
  |  Branch (552:10): [True: 100, False: 24]
  ------------------
  553|    124|		(doc->extSubset->entities != NULL)) {
  ------------------
  |  Branch (553:3): [True: 100, False: 0]
  ------------------
  554|    100|		table = (xmlEntitiesTablePtr) doc->extSubset->entities;
  555|    100|		cur = xmlGetEntityFromTable(table, name);
  556|    100|		if (cur != NULL)
  ------------------
  |  Branch (556:7): [True: 100, False: 0]
  ------------------
  557|    100|		    return(cur);
  558|    100|	    }
  559|    124|	}
  560|    124|    }
  561|     24|    return(xmlGetPredefinedEntity(name));
  562|   223k|}
xmlEncodeAttributeEntities:
  799|  1.46k|xmlEncodeAttributeEntities(xmlDocPtr doc, const xmlChar *input) {
  800|  1.46k|    return xmlEncodeEntitiesInternal(doc, input, 1);
  801|  1.46k|}
xmlFreeEntitiesTable:
  940|    344|xmlFreeEntitiesTable(xmlEntitiesTablePtr table) {
  941|    344|    xmlHashFree(table, xmlFreeEntityWrapper);
  942|    344|}
entities.c:xmlAddEntity:
  202|  2.34k|	  const xmlChar *content) {
  203|  2.34k|    xmlDictPtr dict = NULL;
  204|  2.34k|    xmlEntitiesTablePtr table = NULL;
  205|  2.34k|    xmlEntityPtr ret, predef;
  206|       |
  207|  2.34k|    if (name == NULL)
  ------------------
  |  Branch (207:9): [True: 0, False: 2.34k]
  ------------------
  208|      0|	return(NULL);
  209|  2.34k|    if (dtd == NULL)
  ------------------
  |  Branch (209:9): [True: 0, False: 2.34k]
  ------------------
  210|      0|	return(NULL);
  211|  2.34k|    if (dtd->doc != NULL)
  ------------------
  |  Branch (211:9): [True: 2.34k, False: 0]
  ------------------
  212|  2.34k|        dict = dtd->doc->dict;
  213|       |
  214|  2.34k|    switch (type) {
  ------------------
  |  Branch (214:13): [True: 0, False: 2.34k]
  ------------------
  215|  1.36k|        case XML_INTERNAL_GENERAL_ENTITY:
  ------------------
  |  Branch (215:9): [True: 1.36k, False: 972]
  ------------------
  216|  1.41k|        case XML_EXTERNAL_GENERAL_PARSED_ENTITY:
  ------------------
  |  Branch (216:9): [True: 44, False: 2.29k]
  ------------------
  217|  1.41k|        case XML_EXTERNAL_GENERAL_UNPARSED_ENTITY:
  ------------------
  |  Branch (217:9): [True: 4, False: 2.33k]
  ------------------
  218|  1.41k|            predef = xmlGetPredefinedEntity(name);
  219|  1.41k|            if (predef != NULL) {
  ------------------
  |  Branch (219:17): [True: 100, False: 1.31k]
  ------------------
  220|    100|                int valid = 0;
  221|       |
  222|       |                /* 4.6 Predefined Entities */
  223|    100|                if ((type == XML_INTERNAL_GENERAL_ENTITY) &&
  ------------------
  |  Branch (223:21): [True: 100, False: 0]
  ------------------
  224|    100|                    (content != NULL)) {
  ------------------
  |  Branch (224:21): [True: 100, False: 0]
  ------------------
  225|    100|                    int c = predef->content[0];
  226|       |
  227|    100|                    if (((content[0] == c) && (content[1] == 0)) &&
  ------------------
  |  Branch (227:26): [True: 64, False: 36]
  |  Branch (227:47): [True: 48, False: 16]
  ------------------
  228|    100|                        ((c == '>') || (c == '\'') || (c == '"'))) {
  ------------------
  |  Branch (228:26): [True: 20, False: 28]
  |  Branch (228:40): [True: 12, False: 16]
  |  Branch (228:55): [True: 12, False: 4]
  ------------------
  229|     44|                        valid = 1;
  230|     56|                    } else if ((content[0] == '&') && (content[1] == '#')) {
  ------------------
  |  Branch (230:32): [True: 52, False: 4]
  |  Branch (230:55): [True: 52, False: 0]
  ------------------
  231|     52|                        if (content[2] == 'x') {
  ------------------
  |  Branch (231:29): [True: 20, False: 32]
  ------------------
  232|     20|                            xmlChar *hex = BAD_CAST "0123456789ABCDEF";
  ------------------
  |  |   35|     20|#define BAD_CAST (xmlChar *)
  ------------------
  233|     20|                            xmlChar ref[] = "00;";
  234|       |
  235|     20|                            ref[0] = hex[c / 16 % 16];
  236|     20|                            ref[1] = hex[c % 16];
  237|     20|                            if (xmlStrcasecmp(&content[3], ref) == 0)
  ------------------
  |  Branch (237:33): [True: 20, False: 0]
  ------------------
  238|     20|                                valid = 1;
  239|     32|                        } else {
  240|     32|                            xmlChar ref[] = "00;";
  241|       |
  242|     32|                            ref[0] = '0' + c / 10 % 10;
  243|     32|                            ref[1] = '0' + c % 10;
  244|     32|                            if (xmlStrEqual(&content[2], ref))
  ------------------
  |  Branch (244:33): [True: 32, False: 0]
  ------------------
  245|     32|                                valid = 1;
  246|     32|                        }
  247|     52|                    }
  248|    100|                }
  249|    100|                if (!valid) {
  ------------------
  |  Branch (249:21): [True: 4, False: 96]
  ------------------
  250|      4|                    xmlEntitiesWarn(XML_ERR_ENTITY_PROCESSING,
  251|      4|                            "xmlAddEntity: invalid redeclaration of predefined"
  252|      4|                            " entity '%s'", name);
  253|      4|                    return(NULL);
  254|      4|                }
  255|    100|            }
  256|  1.41k|	    if (dtd->entities == NULL)
  ------------------
  |  Branch (256:10): [True: 216, False: 1.19k]
  ------------------
  257|    216|		dtd->entities = xmlHashCreateDict(0, dict);
  258|  1.41k|	    table = dtd->entities;
  259|  1.41k|	    break;
  260|    888|        case XML_INTERNAL_PARAMETER_ENTITY:
  ------------------
  |  Branch (260:9): [True: 888, False: 1.45k]
  ------------------
  261|    924|        case XML_EXTERNAL_PARAMETER_ENTITY:
  ------------------
  |  Branch (261:9): [True: 36, False: 2.30k]
  ------------------
  262|    924|	    if (dtd->pentities == NULL)
  ------------------
  |  Branch (262:10): [True: 128, False: 796]
  ------------------
  263|    128|		dtd->pentities = xmlHashCreateDict(0, dict);
  264|    924|	    table = dtd->pentities;
  265|    924|	    break;
  266|      0|        case XML_INTERNAL_PREDEFINED_ENTITY:
  ------------------
  |  Branch (266:9): [True: 0, False: 2.34k]
  ------------------
  267|      0|	    return(NULL);
  268|  2.34k|    }
  269|  2.33k|    if (table == NULL)
  ------------------
  |  Branch (269:9): [True: 0, False: 2.33k]
  ------------------
  270|      0|	return(NULL);
  271|  2.33k|    ret = xmlCreateEntity(dict, name, type, ExternalID, SystemID, content);
  272|  2.33k|    if (ret == NULL)
  ------------------
  |  Branch (272:9): [True: 0, False: 2.33k]
  ------------------
  273|      0|        return(NULL);
  274|  2.33k|    ret->doc = dtd->doc;
  275|       |
  276|  2.33k|    if (xmlHashAddEntry(table, name, ret)) {
  ------------------
  |  Branch (276:9): [True: 4, False: 2.33k]
  ------------------
  277|       |	/*
  278|       |	 * entity was already defined at another level.
  279|       |	 */
  280|      4|        xmlFreeEntity(ret);
  281|      4|	return(NULL);
  282|      4|    }
  283|  2.33k|    return(ret);
  284|  2.33k|}
entities.c:xmlEntitiesWarn:
  105|      4|{
  106|      4|    __xmlRaiseError(NULL, NULL, NULL,
  107|      4|                NULL, NULL, XML_FROM_TREE, code,
  108|      4|                XML_ERR_WARNING, NULL, 0,
  109|      4|                (const char *)str1, NULL, NULL, 0, 0,
  110|      4|                msg, (const char *)str1, NULL);
  111|      4|}
entities.c:xmlCreateEntity:
  155|  2.33k|	        const xmlChar *content) {
  156|  2.33k|    xmlEntityPtr ret;
  157|       |
  158|  2.33k|    ret = (xmlEntityPtr) xmlMalloc(sizeof(xmlEntity));
  159|  2.33k|    if (ret == NULL) {
  ------------------
  |  Branch (159:9): [True: 0, False: 2.33k]
  ------------------
  160|      0|        xmlEntitiesErrMemory("xmlCreateEntity: malloc failed");
  161|      0|	return(NULL);
  162|      0|    }
  163|  2.33k|    memset(ret, 0, sizeof(xmlEntity));
  164|  2.33k|    ret->type = XML_ENTITY_DECL;
  165|       |
  166|       |    /*
  167|       |     * fill the structure.
  168|       |     */
  169|  2.33k|    ret->etype = (xmlEntityType) type;
  170|  2.33k|    if (dict == NULL) {
  ------------------
  |  Branch (170:9): [True: 0, False: 2.33k]
  ------------------
  171|      0|	ret->name = xmlStrdup(name);
  172|      0|	if (ExternalID != NULL)
  ------------------
  |  Branch (172:6): [True: 0, False: 0]
  ------------------
  173|      0|	    ret->ExternalID = xmlStrdup(ExternalID);
  174|      0|	if (SystemID != NULL)
  ------------------
  |  Branch (174:6): [True: 0, False: 0]
  ------------------
  175|      0|	    ret->SystemID = xmlStrdup(SystemID);
  176|  2.33k|    } else {
  177|  2.33k|        ret->name = xmlDictLookup(dict, name, -1);
  178|  2.33k|	ret->ExternalID = xmlStrdup(ExternalID);
  179|  2.33k|	ret->SystemID = xmlStrdup(SystemID);
  180|  2.33k|    }
  181|  2.33k|    if (content != NULL) {
  ------------------
  |  Branch (181:9): [True: 2.25k, False: 80]
  ------------------
  182|  2.25k|        ret->length = xmlStrlen(content);
  183|  2.25k|	ret->content = xmlStrndup(content, ret->length);
  184|  2.25k|     } else {
  185|     80|        ret->length = 0;
  186|     80|        ret->content = NULL;
  187|     80|    }
  188|  2.33k|    ret->URI = NULL; /* to be computed by the layer knowing
  189|       |			the defining entity */
  190|  2.33k|    ret->orig = NULL;
  191|  2.33k|    ret->owner = 0;
  192|       |
  193|  2.33k|    return(ret);
  194|  2.33k|}
entities.c:xmlGetEntityFromTable:
  470|   363k|xmlGetEntityFromTable(xmlEntitiesTablePtr table, const xmlChar *name) {
  471|   363k|    return((xmlEntityPtr) xmlHashLookup(table, name));
  472|   363k|}
entities.c:xmlEncodeEntitiesInternal:
  591|  1.46k|xmlEncodeEntitiesInternal(xmlDocPtr doc, const xmlChar *input, int attr) {
  592|  1.46k|    const xmlChar *cur = input;
  593|  1.46k|    xmlChar *buffer = NULL;
  594|  1.46k|    xmlChar *out = NULL;
  595|  1.46k|    size_t buffer_size = 0;
  596|  1.46k|    int html = 0;
  597|       |
  598|  1.46k|    if (input == NULL) return(NULL);
  ------------------
  |  Branch (598:9): [True: 0, False: 1.46k]
  ------------------
  599|  1.46k|    if (doc != NULL)
  ------------------
  |  Branch (599:9): [True: 1.46k, False: 0]
  ------------------
  600|  1.46k|        html = (doc->type == XML_HTML_DOCUMENT_NODE);
  601|       |
  602|       |    /*
  603|       |     * allocate an translation buffer.
  604|       |     */
  605|  1.46k|    buffer_size = 1000;
  606|  1.46k|    buffer = (xmlChar *) xmlMalloc(buffer_size);
  607|  1.46k|    if (buffer == NULL) {
  ------------------
  |  Branch (607:9): [True: 0, False: 1.46k]
  ------------------
  608|      0|        xmlEntitiesErrMemory("xmlEncodeEntities: malloc failed");
  609|      0|	return(NULL);
  610|      0|    }
  611|  1.46k|    out = buffer;
  612|       |
  613|   488k|    while (*cur != '\0') {
  ------------------
  |  Branch (613:12): [True: 486k, False: 1.46k]
  ------------------
  614|   486k|        size_t indx = out - buffer;
  615|   486k|        if (indx + 100 > buffer_size) {
  ------------------
  |  Branch (615:13): [True: 9, False: 486k]
  ------------------
  616|       |
  617|     18|	    growBufferReentrant();
  ------------------
  |  |  567|      9|#define growBufferReentrant() {						\
  |  |  568|      9|    xmlChar *tmp;                                                       \
  |  |  569|      9|    size_t new_size = buffer_size * 2;                                  \
  |  |  570|      9|    if (new_size < buffer_size) goto mem_error;                         \
  |  |  ------------------
  |  |  |  Branch (570:9): [True: 0, False: 9]
  |  |  ------------------
  |  |  571|      9|    tmp = (xmlChar *) xmlRealloc(buffer, new_size);	                \
  |  |  572|      9|    if (tmp == NULL) goto mem_error;                                    \
  |  |  ------------------
  |  |  |  Branch (572:9): [True: 0, False: 9]
  |  |  ------------------
  |  |  573|      9|    buffer = tmp;							\
  |  |  574|      9|    buffer_size = new_size;						\
  |  |  575|      9|}
  ------------------
  618|     18|	    out = &buffer[indx];
  619|     18|	}
  620|       |
  621|       |	/*
  622|       |	 * By default one have to encode at least '<', '>', '"' and '&' !
  623|       |	 */
  624|   486k|	if (*cur == '<') {
  ------------------
  |  Branch (624:6): [True: 10, False: 486k]
  ------------------
  625|     10|	    const xmlChar *end;
  626|       |
  627|       |	    /*
  628|       |	     * Special handling of server side include in HTML attributes
  629|       |	     */
  630|     10|	    if (html && attr &&
  ------------------
  |  Branch (630:10): [True: 0, False: 10]
  |  Branch (630:18): [True: 0, False: 0]
  ------------------
  631|     10|	        (cur[1] == '!') && (cur[2] == '-') && (cur[3] == '-') &&
  ------------------
  |  Branch (631:10): [True: 0, False: 0]
  |  Branch (631:29): [True: 0, False: 0]
  |  Branch (631:48): [True: 0, False: 0]
  ------------------
  632|     10|	        ((end = xmlStrstr(cur, BAD_CAST "-->")) != NULL)) {
  ------------------
  |  |   35|      0|#define BAD_CAST (xmlChar *)
  ------------------
  |  Branch (632:10): [True: 0, False: 0]
  ------------------
  633|      0|	        while (cur != end) {
  ------------------
  |  Branch (633:17): [True: 0, False: 0]
  ------------------
  634|      0|		    *out++ = *cur++;
  635|      0|		    indx = out - buffer;
  636|      0|		    if (indx + 100 > buffer_size) {
  ------------------
  |  Branch (636:11): [True: 0, False: 0]
  ------------------
  637|      0|			growBufferReentrant();
  ------------------
  |  |  567|      0|#define growBufferReentrant() {						\
  |  |  568|      0|    xmlChar *tmp;                                                       \
  |  |  569|      0|    size_t new_size = buffer_size * 2;                                  \
  |  |  570|      0|    if (new_size < buffer_size) goto mem_error;                         \
  |  |  ------------------
  |  |  |  Branch (570:9): [True: 0, False: 0]
  |  |  ------------------
  |  |  571|      0|    tmp = (xmlChar *) xmlRealloc(buffer, new_size);	                \
  |  |  572|      0|    if (tmp == NULL) goto mem_error;                                    \
  |  |  ------------------
  |  |  |  Branch (572:9): [True: 0, False: 0]
  |  |  ------------------
  |  |  573|      0|    buffer = tmp;							\
  |  |  574|      0|    buffer_size = new_size;						\
  |  |  575|      0|}
  ------------------
  638|      0|			out = &buffer[indx];
  639|      0|		    }
  640|      0|		}
  641|      0|		*out++ = *cur++;
  642|      0|		*out++ = *cur++;
  643|      0|		*out++ = *cur++;
  644|      0|		continue;
  645|      0|	    }
  646|     10|	    *out++ = '&';
  647|     10|	    *out++ = 'l';
  648|     10|	    *out++ = 't';
  649|     10|	    *out++ = ';';
  650|   486k|	} else if (*cur == '>') {
  ------------------
  |  Branch (650:13): [True: 2, False: 486k]
  ------------------
  651|      2|	    *out++ = '&';
  652|      2|	    *out++ = 'g';
  653|      2|	    *out++ = 't';
  654|      2|	    *out++ = ';';
  655|   486k|	} else if (*cur == '&') {
  ------------------
  |  Branch (655:13): [True: 10, False: 486k]
  ------------------
  656|       |	    /*
  657|       |	     * Special handling of &{...} construct from HTML 4, see
  658|       |	     * http://www.w3.org/TR/html401/appendix/notes.html#h-B.7.1
  659|       |	     */
  660|     10|	    if (html && attr && (cur[1] == '{') &&
  ------------------
  |  Branch (660:10): [True: 0, False: 10]
  |  Branch (660:18): [True: 0, False: 0]
  |  Branch (660:26): [True: 0, False: 0]
  ------------------
  661|     10|	        (strchr((const char *) cur, '}'))) {
  ------------------
  |  Branch (661:10): [True: 0, False: 0]
  ------------------
  662|      0|	        while (*cur != '}') {
  ------------------
  |  Branch (662:17): [True: 0, False: 0]
  ------------------
  663|      0|		    *out++ = *cur++;
  664|      0|		    indx = out - buffer;
  665|      0|		    if (indx + 100 > buffer_size) {
  ------------------
  |  Branch (665:11): [True: 0, False: 0]
  ------------------
  666|      0|			growBufferReentrant();
  ------------------
  |  |  567|      0|#define growBufferReentrant() {						\
  |  |  568|      0|    xmlChar *tmp;                                                       \
  |  |  569|      0|    size_t new_size = buffer_size * 2;                                  \
  |  |  570|      0|    if (new_size < buffer_size) goto mem_error;                         \
  |  |  ------------------
  |  |  |  Branch (570:9): [True: 0, False: 0]
  |  |  ------------------
  |  |  571|      0|    tmp = (xmlChar *) xmlRealloc(buffer, new_size);	                \
  |  |  572|      0|    if (tmp == NULL) goto mem_error;                                    \
  |  |  ------------------
  |  |  |  Branch (572:9): [True: 0, False: 0]
  |  |  ------------------
  |  |  573|      0|    buffer = tmp;							\
  |  |  574|      0|    buffer_size = new_size;						\
  |  |  575|      0|}
  ------------------
  667|      0|			out = &buffer[indx];
  668|      0|		    }
  669|      0|		}
  670|      0|		*out++ = *cur++;
  671|      0|		continue;
  672|      0|	    }
  673|     10|	    *out++ = '&';
  674|     10|	    *out++ = 'a';
  675|     10|	    *out++ = 'm';
  676|     10|	    *out++ = 'p';
  677|     10|	    *out++ = ';';
  678|   486k|	} else if (((*cur >= 0x20) && (*cur < 0x80)) ||
  ------------------
  |  Branch (678:14): [True: 486k, False: 21]
  |  Branch (678:32): [True: 486k, False: 4]
  ------------------
  679|   486k|	    (*cur == '\n') || (*cur == '\t') || ((html) && (*cur == '\r'))) {
  ------------------
  |  Branch (679:6): [True: 9, False: 16]
  |  Branch (679:24): [True: 3, False: 13]
  |  Branch (679:43): [True: 0, False: 13]
  |  Branch (679:53): [True: 0, False: 0]
  ------------------
  680|       |	    /*
  681|       |	     * default case, just copy !
  682|       |	     */
  683|   486k|	    *out++ = *cur;
  684|   486k|	} else if (*cur >= 0x80) {
  ------------------
  |  Branch (684:13): [True: 4, False: 9]
  ------------------
  685|      4|	    if (((doc != NULL) && (doc->encoding != NULL)) || (html)) {
  ------------------
  |  Branch (685:11): [True: 4, False: 0]
  |  Branch (685:28): [True: 4, False: 0]
  |  Branch (685:56): [True: 0, False: 0]
  ------------------
  686|       |		/*
  687|       |		 * Bjrn Reese <br@sseusa.com> provided the patch
  688|       |	        xmlChar xc;
  689|       |	        xc = (*cur & 0x3F) << 6;
  690|       |	        if (cur[1] != 0) {
  691|       |		    xc += *(++cur) & 0x3F;
  692|       |		    *out++ = xc;
  693|       |	        } else
  694|       |		 */
  695|      4|		*out++ = *cur;
  696|      4|	    } else {
  697|       |		/*
  698|       |		 * We assume we have UTF-8 input.
  699|       |		 * It must match either:
  700|       |		 *   110xxxxx 10xxxxxx
  701|       |		 *   1110xxxx 10xxxxxx 10xxxxxx
  702|       |		 *   11110xxx 10xxxxxx 10xxxxxx 10xxxxxx
  703|       |		 * That is:
  704|       |		 *   cur[0] is 11xxxxxx
  705|       |		 *   cur[1] is 10xxxxxx
  706|       |		 *   cur[2] is 10xxxxxx if cur[0] is 111xxxxx
  707|       |		 *   cur[3] is 10xxxxxx if cur[0] is 1111xxxx
  708|       |		 *   cur[0] is not 11111xxx
  709|       |		 */
  710|      0|		char buf[11], *ptr;
  711|      0|		int val = 0, l = 1;
  712|       |
  713|      0|		if (((cur[0] & 0xC0) != 0xC0) ||
  ------------------
  |  Branch (713:7): [True: 0, False: 0]
  ------------------
  714|      0|		    ((cur[1] & 0xC0) != 0x80) ||
  ------------------
  |  Branch (714:7): [True: 0, False: 0]
  ------------------
  715|      0|		    (((cur[0] & 0xE0) == 0xE0) && ((cur[2] & 0xC0) != 0x80)) ||
  ------------------
  |  Branch (715:8): [True: 0, False: 0]
  |  Branch (715:37): [True: 0, False: 0]
  ------------------
  716|      0|		    (((cur[0] & 0xF0) == 0xF0) && ((cur[3] & 0xC0) != 0x80)) ||
  ------------------
  |  Branch (716:8): [True: 0, False: 0]
  |  Branch (716:37): [True: 0, False: 0]
  ------------------
  717|      0|		    (((cur[0] & 0xF8) == 0xF8))) {
  ------------------
  |  Branch (717:7): [True: 0, False: 0]
  ------------------
  718|      0|		    xmlEntitiesErr(XML_CHECK_NOT_UTF8,
  719|      0|			    "xmlEncodeEntities: input not UTF-8");
  720|      0|		    snprintf(buf, sizeof(buf), "&#%d;", *cur);
  721|      0|		    buf[sizeof(buf) - 1] = 0;
  722|      0|		    ptr = buf;
  723|      0|		    while (*ptr != 0) *out++ = *ptr++;
  ------------------
  |  Branch (723:14): [True: 0, False: 0]
  ------------------
  724|      0|		    cur++;
  725|      0|		    continue;
  726|      0|		} else if (*cur < 0xE0) {
  ------------------
  |  Branch (726:14): [True: 0, False: 0]
  ------------------
  727|      0|                    val = (cur[0]) & 0x1F;
  728|      0|		    val <<= 6;
  729|      0|		    val |= (cur[1]) & 0x3F;
  730|      0|		    l = 2;
  731|      0|		} else if (*cur < 0xF0) {
  ------------------
  |  Branch (731:14): [True: 0, False: 0]
  ------------------
  732|      0|                    val = (cur[0]) & 0x0F;
  733|      0|		    val <<= 6;
  734|      0|		    val |= (cur[1]) & 0x3F;
  735|      0|		    val <<= 6;
  736|      0|		    val |= (cur[2]) & 0x3F;
  737|      0|		    l = 3;
  738|      0|		} else if (*cur < 0xF8) {
  ------------------
  |  Branch (738:14): [True: 0, False: 0]
  ------------------
  739|      0|                    val = (cur[0]) & 0x07;
  740|      0|		    val <<= 6;
  741|      0|		    val |= (cur[1]) & 0x3F;
  742|      0|		    val <<= 6;
  743|      0|		    val |= (cur[2]) & 0x3F;
  744|      0|		    val <<= 6;
  745|      0|		    val |= (cur[3]) & 0x3F;
  746|      0|		    l = 4;
  747|      0|		}
  748|      0|		if ((l == 1) || (!IS_CHAR(val))) {
  ------------------
  |  |  125|      0|#define IS_CHAR(c)   xmlIsCharQ(c)
  |  |  ------------------
  |  |  |  |  118|      0|#define xmlIsCharQ(c)		(((c) < 0x100) ? \
  |  |  |  |  ------------------
  |  |  |  |  |  Branch (118:25): [True: 0, False: 0]
  |  |  |  |  ------------------
  |  |  |  |  119|      0|				 xmlIsChar_ch((c)) :\
  |  |  |  |  ------------------
  |  |  |  |  |  |  108|      0|#define xmlIsChar_ch(c)		(((0x9 <= (c)) && ((c) <= 0xa)) || \
  |  |  |  |  |  |  ------------------
  |  |  |  |  |  |  |  Branch (108:28): [True: 0, False: 0]
  |  |  |  |  |  |  |  Branch (108:44): [True: 0, False: 0]
  |  |  |  |  |  |  ------------------
  |  |  |  |  |  |  109|      0|				 ((c) == 0xd) || \
  |  |  |  |  |  |  ------------------
  |  |  |  |  |  |  |  Branch (109:6): [True: 0, False: 0]
  |  |  |  |  |  |  ------------------
  |  |  |  |  |  |  110|      0|				  (0x20 <= (c)))
  |  |  |  |  |  |  ------------------
  |  |  |  |  |  |  |  Branch (110:7): [True: 0, False: 0]
  |  |  |  |  |  |  ------------------
  |  |  |  |  ------------------
  |  |  |  |  120|      0|				(((0x100 <= (c)) && ((c) <= 0xd7ff)) || \
  |  |  |  |  ------------------
  |  |  |  |  |  Branch (120:7): [True: 0, False: 0]
  |  |  |  |  |  Branch (120:25): [True: 0, False: 0]
  |  |  |  |  ------------------
  |  |  |  |  121|      0|				 ((0xe000 <= (c)) && ((c) <= 0xfffd)) || \
  |  |  |  |  ------------------
  |  |  |  |  |  Branch (121:7): [True: 0, False: 0]
  |  |  |  |  |  Branch (121:26): [True: 0, False: 0]
  |  |  |  |  ------------------
  |  |  |  |  122|      0|				 ((0x10000 <= (c)) && ((c) <= 0x10ffff))))
  |  |  |  |  ------------------
  |  |  |  |  |  Branch (122:7): [True: 0, False: 0]
  |  |  |  |  |  Branch (122:27): [True: 0, False: 0]
  |  |  |  |  ------------------
  |  |  ------------------
  ------------------
  |  Branch (748:7): [True: 0, False: 0]
  |  Branch (748:19): [True: 0, False: 0]
  ------------------
  749|      0|		    xmlEntitiesErr(XML_ERR_INVALID_CHAR,
  750|      0|			"xmlEncodeEntities: char out of range\n");
  751|      0|		    snprintf(buf, sizeof(buf), "&#%d;", *cur);
  752|      0|		    buf[sizeof(buf) - 1] = 0;
  753|      0|		    ptr = buf;
  754|      0|		    while (*ptr != 0) *out++ = *ptr++;
  ------------------
  |  Branch (754:14): [True: 0, False: 0]
  ------------------
  755|      0|		    cur++;
  756|      0|		    continue;
  757|      0|		}
  758|       |		/*
  759|       |		 * We could do multiple things here. Just save as a char ref
  760|       |		 */
  761|      0|		snprintf(buf, sizeof(buf), "&#x%X;", val);
  762|      0|		buf[sizeof(buf) - 1] = 0;
  763|      0|		ptr = buf;
  764|      0|		while (*ptr != 0) *out++ = *ptr++;
  ------------------
  |  Branch (764:10): [True: 0, False: 0]
  ------------------
  765|      0|		cur += l;
  766|      0|		continue;
  767|      0|	    }
  768|      9|	} else if (IS_BYTE_CHAR(*cur)) {
  ------------------
  |  |  113|      9|#define IS_BYTE_CHAR(c)	 xmlIsChar_ch(c)
  |  |  ------------------
  |  |  |  |  108|      9|#define xmlIsChar_ch(c)		(((0x9 <= (c)) && ((c) <= 0xa)) || \
  |  |  |  |  ------------------
  |  |  |  |  |  Branch (108:28): [True: 9, False: 0]
  |  |  |  |  |  Branch (108:44): [True: 0, False: 9]
  |  |  |  |  ------------------
  |  |  |  |  109|      9|				 ((c) == 0xd) || \
  |  |  |  |  ------------------
  |  |  |  |  |  Branch (109:6): [True: 9, False: 0]
  |  |  |  |  ------------------
  |  |  |  |  110|      9|				  (0x20 <= (c)))
  |  |  |  |  ------------------
  |  |  |  |  |  Branch (110:7): [True: 0, False: 0]
  |  |  |  |  ------------------
  |  |  ------------------
  ------------------
  769|      9|	    char buf[11], *ptr;
  770|       |
  771|      9|	    snprintf(buf, sizeof(buf), "&#%d;", *cur);
  772|      9|	    buf[sizeof(buf) - 1] = 0;
  773|      9|            ptr = buf;
  774|     54|	    while (*ptr != 0) *out++ = *ptr++;
  ------------------
  |  Branch (774:13): [True: 45, False: 9]
  ------------------
  775|      9|	}
  776|   486k|	cur++;
  777|   486k|    }
  778|  1.46k|    *out = 0;
  779|  1.46k|    return(buffer);
  780|       |
  781|      0|mem_error:
  782|      0|    xmlEntitiesErrMemory("xmlEncodeEntities: realloc failed");
  783|      0|    xmlFree(buffer);
  784|      0|    return(NULL);
  785|  1.46k|}
entities.c:xmlFreeEntityWrapper:
  928|  2.33k|xmlFreeEntityWrapper(void *entity, const xmlChar *name ATTRIBUTE_UNUSED) {
  929|  2.33k|    if (entity != NULL)
  ------------------
  |  Branch (929:9): [True: 2.33k, False: 0]
  ------------------
  930|  2.33k|	xmlFreeEntity((xmlEntityPtr) entity);
  931|  2.33k|}

xmlSetGenericErrorFunc:
  114|      2|xmlSetGenericErrorFunc(void *ctx, xmlGenericErrorFunc handler) {
  115|      2|    xmlGenericErrorContext = ctx;
  ------------------
  |  |  876|      2|  #define xmlGenericErrorContext XML_GLOBAL_MACRO(xmlGenericErrorContext)
  |  |  ------------------
  |  |  |  |  500|      2|  #define XML_GLOBAL_MACRO(name) (*__##name())
  |  |  ------------------
  ------------------
  116|      2|    if (handler != NULL)
  ------------------
  |  Branch (116:9): [True: 2, False: 0]
  ------------------
  117|      2|	xmlGenericError = handler;
  ------------------
  |  |  875|      2|  #define xmlGenericError XML_GLOBAL_MACRO(xmlGenericError)
  |  |  ------------------
  |  |  |  |  500|      2|  #define XML_GLOBAL_MACRO(name) (*__##name())
  |  |  ------------------
  ------------------
  118|      0|    else
  119|      0|	xmlGenericError = xmlGenericErrorDefaultFunc;
  ------------------
  |  |  875|      0|  #define xmlGenericError XML_GLOBAL_MACRO(xmlGenericError)
  |  |  ------------------
  |  |  |  |  500|      0|  #define XML_GLOBAL_MACRO(name) (*__##name())
  |  |  ------------------
  ------------------
  120|      2|}
__xmlRaiseError:
  475|  2.29k|{
  476|  2.29k|    xmlParserCtxtPtr ctxt = NULL;
  477|  2.29k|    xmlNodePtr node = (xmlNodePtr) nod;
  478|  2.29k|    char *str = NULL;
  479|  2.29k|    xmlParserInputPtr input = NULL;
  480|  2.29k|    xmlErrorPtr to = &xmlLastError;
  ------------------
  |  |  874|  2.29k|  #define xmlLastError XML_GLOBAL_MACRO(xmlLastError)
  |  |  ------------------
  |  |  |  |  500|  2.29k|  #define XML_GLOBAL_MACRO(name) (*__##name())
  |  |  ------------------
  ------------------
  481|  2.29k|    xmlNodePtr baseptr = NULL;
  482|       |
  483|  2.29k|    if (code == XML_ERR_OK)
  ------------------
  |  Branch (483:9): [True: 0, False: 2.29k]
  ------------------
  484|      0|        return;
  485|  2.29k|    if ((xmlGetWarningsDefaultValue == 0) && (level == XML_ERR_WARNING))
  ------------------
  |  |  865|  2.29k|    XML_GLOBAL_MACRO(xmlGetWarningsDefaultValue)
  |  |  ------------------
  |  |  |  |  500|  2.29k|  #define XML_GLOBAL_MACRO(name) (*__##name())
  |  |  ------------------
  ------------------
  |  Branch (485:9): [True: 0, False: 2.29k]
  |  Branch (485:46): [True: 0, False: 0]
  ------------------
  486|      0|        return;
  487|  2.29k|    if ((domain == XML_FROM_PARSER) || (domain == XML_FROM_HTML) ||
  ------------------
  |  Branch (487:9): [True: 387, False: 1.90k]
  |  Branch (487:40): [True: 0, False: 1.90k]
  ------------------
  488|  2.29k|        (domain == XML_FROM_DTD) || (domain == XML_FROM_NAMESPACE) ||
  ------------------
  |  Branch (488:9): [True: 473, False: 1.43k]
  |  Branch (488:37): [True: 60, False: 1.37k]
  ------------------
  489|  2.29k|	(domain == XML_FROM_IO) || (domain == XML_FROM_VALID)) {
  ------------------
  |  Branch (489:2): [True: 0, False: 1.37k]
  |  Branch (489:29): [True: 1.37k, False: 4]
  ------------------
  490|  2.29k|	ctxt = (xmlParserCtxtPtr) ctx;
  491|       |
  492|  2.29k|        if (ctxt != NULL) {
  ------------------
  |  Branch (492:13): [True: 1.95k, False: 335]
  ------------------
  493|  1.95k|            if (level == XML_ERR_WARNING) {
  ------------------
  |  Branch (493:17): [True: 16, False: 1.94k]
  ------------------
  494|     16|                if (ctxt->nbWarnings >= XML_MAX_ERRORS)
  ------------------
  |  |   20|     16|#define XML_MAX_ERRORS 100
  ------------------
  |  Branch (494:21): [True: 0, False: 16]
  ------------------
  495|      0|                    return;
  496|     16|                ctxt->nbWarnings += 1;
  497|  1.94k|            } else {
  498|  1.94k|                if (ctxt->nbErrors >= XML_MAX_ERRORS)
  ------------------
  |  |   20|  1.94k|#define XML_MAX_ERRORS 100
  ------------------
  |  Branch (498:21): [True: 62, False: 1.87k]
  ------------------
  499|     62|                    return;
  500|  1.87k|                ctxt->nbErrors += 1;
  501|  1.87k|            }
  502|       |
  503|  1.89k|            if ((schannel == NULL) && (ctxt->sax != NULL) &&
  ------------------
  |  Branch (503:17): [True: 1.89k, False: 0]
  |  Branch (503:39): [True: 1.89k, False: 0]
  ------------------
  504|  1.89k|                (ctxt->sax->initialized == XML_SAX2_MAGIC) &&
  ------------------
  |  |  685|  1.89k|#define XML_SAX2_MAGIC 0xDEEDBEAF
  ------------------
  |  Branch (504:17): [True: 1.89k, False: 0]
  ------------------
  505|  1.89k|                (ctxt->sax->serror != NULL)) {
  ------------------
  |  Branch (505:17): [True: 0, False: 1.89k]
  ------------------
  506|      0|                schannel = ctxt->sax->serror;
  507|      0|                data = ctxt->userData;
  508|      0|            }
  509|  1.89k|        }
  510|  2.29k|    }
  511|       |    /*
  512|       |     * Check if structured error handler set
  513|       |     */
  514|  2.23k|    if (schannel == NULL) {
  ------------------
  |  Branch (514:9): [True: 2.23k, False: 0]
  ------------------
  515|  2.23k|	schannel = xmlStructuredError;
  ------------------
  |  |  877|  2.23k|  #define xmlStructuredError XML_GLOBAL_MACRO(xmlStructuredError)
  |  |  ------------------
  |  |  |  |  500|  2.23k|  #define XML_GLOBAL_MACRO(name) (*__##name())
  |  |  ------------------
  ------------------
  516|       |	/*
  517|       |	 * if user has defined handler, change data ptr to user's choice
  518|       |	 */
  519|  2.23k|	if (schannel != NULL)
  ------------------
  |  Branch (519:6): [True: 0, False: 2.23k]
  ------------------
  520|      0|	    data = xmlStructuredErrorContext;
  ------------------
  |  |  878|      0|  #define xmlStructuredErrorContext XML_GLOBAL_MACRO(xmlStructuredErrorContext)
  |  |  ------------------
  |  |  |  |  500|      0|  #define XML_GLOBAL_MACRO(name) (*__##name())
  |  |  ------------------
  ------------------
  521|  2.23k|    }
  522|       |    /*
  523|       |     * Formatting the message
  524|       |     */
  525|  2.23k|    if (msg == NULL) {
  ------------------
  |  Branch (525:9): [True: 0, False: 2.23k]
  ------------------
  526|      0|        str = (char *) xmlStrdup(BAD_CAST "No error message provided");
  ------------------
  |  |   35|      0|#define BAD_CAST (xmlChar *)
  ------------------
  527|  2.23k|    } else {
  528|  2.23k|        XML_GET_VAR_STR(msg, str);
  ------------------
  |  |   22|  2.23k|#define XML_GET_VAR_STR(msg, str) {				\
  |  |   23|  2.23k|    int       size, prev_size = -1;				\
  |  |   24|  2.23k|    int       chars;						\
  |  |   25|  2.23k|    char      *larger;						\
  |  |   26|  2.23k|    va_list   ap;						\
  |  |   27|  2.23k|								\
  |  |   28|  2.23k|    str = (char *) xmlMalloc(150);				\
  |  |   29|  2.23k|    if (str != NULL) {						\
  |  |  ------------------
  |  |  |  Branch (29:9): [True: 2.23k, False: 0]
  |  |  ------------------
  |  |   30|  2.23k|								\
  |  |   31|  2.23k|    size = 150;							\
  |  |   32|  2.23k|								\
  |  |   33|  4.48k|    while (size < 64000) {					\
  |  |  ------------------
  |  |  |  Branch (33:12): [True: 4.48k, False: 0]
  |  |  ------------------
  |  |   34|  4.48k|	va_start(ap, msg);					\
  |  |   35|  4.48k|	chars = vsnprintf(str, size, msg, ap);			\
  |  |   36|  4.48k|	va_end(ap);						\
  |  |   37|  4.48k|	if ((chars > -1) && (chars < size)) {			\
  |  |  ------------------
  |  |  |  Branch (37:6): [True: 4.48k, False: 0]
  |  |  |  Branch (37:22): [True: 4.46k, False: 18]
  |  |  ------------------
  |  |   38|  4.46k|	    if (prev_size == chars) {				\
  |  |  ------------------
  |  |  |  Branch (38:10): [True: 2.23k, False: 2.23k]
  |  |  ------------------
  |  |   39|  2.23k|		break;						\
  |  |   40|  2.23k|	    } else {						\
  |  |   41|  2.23k|		prev_size = chars;				\
  |  |   42|  2.23k|	    }							\
  |  |   43|  4.46k|	}							\
  |  |   44|  4.48k|	if (chars > -1)						\
  |  |  ------------------
  |  |  |  Branch (44:6): [True: 2.25k, False: 0]
  |  |  ------------------
  |  |   45|  2.25k|	    size += chars + 1;					\
  |  |   46|  2.25k|	else							\
  |  |   47|  2.25k|	    size += 100;					\
  |  |   48|  2.25k|	if ((larger = (char *) xmlRealloc(str, size)) == NULL) {\
  |  |  ------------------
  |  |  |  Branch (48:6): [True: 0, False: 2.25k]
  |  |  ------------------
  |  |   49|      0|	    break;						\
  |  |   50|      0|	}							\
  |  |   51|  2.25k|	str = larger;						\
  |  |   52|  2.25k|    }}								\
  |  |   53|  2.23k|}
  ------------------
  529|  2.23k|    }
  530|       |
  531|       |    /*
  532|       |     * specific processing if a parser context is provided
  533|       |     */
  534|  2.23k|    if (ctxt != NULL) {
  ------------------
  |  Branch (534:9): [True: 1.89k, False: 339]
  ------------------
  535|  1.89k|        if (file == NULL) {
  ------------------
  |  Branch (535:13): [True: 1.89k, False: 0]
  ------------------
  536|  1.89k|            input = ctxt->input;
  537|  1.89k|            if ((input != NULL) && (input->filename == NULL) &&
  ------------------
  |  Branch (537:17): [True: 1.89k, False: 0]
  |  Branch (537:36): [True: 695, False: 1.19k]
  ------------------
  538|  1.89k|                (ctxt->inputNr > 1)) {
  ------------------
  |  Branch (538:17): [True: 56, False: 639]
  ------------------
  539|     56|                input = ctxt->inputTab[ctxt->inputNr - 2];
  540|     56|            }
  541|  1.89k|            if (input != NULL) {
  ------------------
  |  Branch (541:17): [True: 1.89k, False: 0]
  ------------------
  542|  1.89k|                file = input->filename;
  543|  1.89k|                line = input->line;
  544|  1.89k|                col = input->col;
  545|  1.89k|            }
  546|  1.89k|        }
  547|  1.89k|        to = &ctxt->lastError;
  548|  1.89k|    } else if ((node != NULL) && (file == NULL)) {
  ------------------
  |  Branch (548:16): [True: 191, False: 148]
  |  Branch (548:34): [True: 191, False: 0]
  ------------------
  549|    191|	int i;
  550|       |
  551|    191|	if ((node->doc != NULL) && (node->doc->URL != NULL)) {
  ------------------
  |  Branch (551:6): [True: 191, False: 0]
  |  Branch (551:29): [True: 191, False: 0]
  ------------------
  552|    191|	    baseptr = node;
  553|       |/*	    file = (const char *) node->doc->URL; */
  554|    191|	}
  555|    191|	for (i = 0;
  556|    194|	     ((i < 10) && (node != NULL) && (node->type != XML_ELEMENT_NODE));
  ------------------
  |  Branch (556:8): [True: 194, False: 0]
  |  Branch (556:20): [True: 193, False: 1]
  |  Branch (556:38): [True: 3, False: 190]
  ------------------
  557|    191|	     i++)
  558|      3|	     node = node->parent;
  559|    191|        if ((baseptr == NULL) && (node != NULL) &&
  ------------------
  |  Branch (559:13): [True: 0, False: 191]
  |  Branch (559:34): [True: 0, False: 0]
  ------------------
  560|    191|	    (node->doc != NULL) && (node->doc->URL != NULL))
  ------------------
  |  Branch (560:6): [True: 0, False: 0]
  |  Branch (560:29): [True: 0, False: 0]
  ------------------
  561|      0|	    baseptr = node;
  562|       |
  563|    191|	if ((node != NULL) && (node->type == XML_ELEMENT_NODE))
  ------------------
  |  Branch (563:6): [True: 190, False: 1]
  |  Branch (563:24): [True: 190, False: 0]
  ------------------
  564|    190|	    line = node->line;
  565|    191|	if ((line == 0) || (line == 65535))
  ------------------
  |  Branch (565:6): [True: 14, False: 177]
  |  Branch (565:21): [True: 0, False: 177]
  ------------------
  566|     14|	    line = xmlGetLineNo(node);
  567|    191|    }
  568|       |
  569|       |    /*
  570|       |     * Save the information about the error
  571|       |     */
  572|  2.23k|    xmlResetError(to);
  573|  2.23k|    to->domain = domain;
  574|  2.23k|    to->code = code;
  575|  2.23k|    to->message = str;
  576|  2.23k|    to->level = level;
  577|  2.23k|    if (file != NULL)
  ------------------
  |  Branch (577:9): [True: 1.23k, False: 1.00k]
  ------------------
  578|  1.23k|        to->file = (char *) xmlStrdup((const xmlChar *) file);
  579|  1.00k|    else if (baseptr != NULL) {
  ------------------
  |  Branch (579:14): [True: 191, False: 811]
  ------------------
  580|    191|#ifdef LIBXML_XINCLUDE_ENABLED
  581|       |	/*
  582|       |	 * We check if the error is within an XInclude section and,
  583|       |	 * if so, attempt to print out the href of the XInclude instead
  584|       |	 * of the usual "base" (doc->URL) for the node (bug 152623).
  585|       |	 */
  586|    191|        xmlNodePtr prev = baseptr;
  587|    191|        char *href = NULL;
  588|    191|	int inclcount = 0;
  589|  6.79k|	while (prev != NULL) {
  ------------------
  |  Branch (589:9): [True: 6.59k, False: 191]
  ------------------
  590|  6.59k|	    if (prev->prev == NULL)
  ------------------
  |  Branch (590:10): [True: 571, False: 6.02k]
  ------------------
  591|    571|	        prev = prev->parent;
  592|  6.02k|	    else {
  593|  6.02k|	        prev = prev->prev;
  594|  6.02k|		if (prev->type == XML_XINCLUDE_START) {
  ------------------
  |  Branch (594:7): [True: 0, False: 6.02k]
  ------------------
  595|      0|		    if (inclcount > 0) {
  ------------------
  |  Branch (595:11): [True: 0, False: 0]
  ------------------
  596|      0|                        --inclcount;
  597|      0|                    } else {
  598|      0|                        href = (char *) xmlGetProp(prev, BAD_CAST "href");
  ------------------
  |  |   35|      0|#define BAD_CAST (xmlChar *)
  ------------------
  599|      0|                        if (href != NULL)
  ------------------
  |  Branch (599:29): [True: 0, False: 0]
  ------------------
  600|      0|		            break;
  601|      0|                    }
  602|  6.02k|		} else if (prev->type == XML_XINCLUDE_END)
  ------------------
  |  Branch (602:14): [True: 0, False: 6.02k]
  ------------------
  603|      0|		    inclcount++;
  604|  6.02k|	    }
  605|  6.59k|	}
  606|    191|        if (href != NULL)
  ------------------
  |  Branch (606:13): [True: 0, False: 191]
  ------------------
  607|      0|            to->file = href;
  608|    191|	else
  609|    191|#endif
  610|    191|	    to->file = (char *) xmlStrdup(baseptr->doc->URL);
  611|    191|	if ((to->file == NULL) && (node != NULL) && (node->doc != NULL)) {
  ------------------
  |  Branch (611:6): [True: 0, False: 191]
  |  Branch (611:28): [True: 0, False: 0]
  |  Branch (611:46): [True: 0, False: 0]
  ------------------
  612|      0|	    to->file = (char *) xmlStrdup(node->doc->URL);
  613|      0|	}
  614|    191|    }
  615|  2.23k|    to->line = line;
  616|  2.23k|    if (str1 != NULL)
  ------------------
  |  Branch (616:9): [True: 1.42k, False: 808]
  ------------------
  617|  1.42k|        to->str1 = (char *) xmlStrdup((const xmlChar *) str1);
  618|  2.23k|    if (str2 != NULL)
  ------------------
  |  Branch (618:9): [True: 385, False: 1.84k]
  ------------------
  619|    385|        to->str2 = (char *) xmlStrdup((const xmlChar *) str2);
  620|  2.23k|    if (str3 != NULL)
  ------------------
  |  Branch (620:9): [True: 36, False: 2.19k]
  ------------------
  621|     36|        to->str3 = (char *) xmlStrdup((const xmlChar *) str3);
  622|  2.23k|    to->int1 = int1;
  623|  2.23k|    to->int2 = col;
  624|  2.23k|    to->node = node;
  625|  2.23k|    to->ctxt = ctx;
  626|       |
  627|  2.23k|    if (to != &xmlLastError)
  ------------------
  |  |  874|  2.23k|  #define xmlLastError XML_GLOBAL_MACRO(xmlLastError)
  |  |  ------------------
  |  |  |  |  500|  2.23k|  #define XML_GLOBAL_MACRO(name) (*__##name())
  |  |  ------------------
  ------------------
  |  Branch (627:9): [True: 1.89k, False: 339]
  ------------------
  628|  1.89k|        xmlCopyError(to,&xmlLastError);
  ------------------
  |  |  874|  1.89k|  #define xmlLastError XML_GLOBAL_MACRO(xmlLastError)
  |  |  ------------------
  |  |  |  |  500|  1.89k|  #define XML_GLOBAL_MACRO(name) (*__##name())
  |  |  ------------------
  ------------------
  629|       |
  630|  2.23k|    if (schannel != NULL) {
  ------------------
  |  Branch (630:9): [True: 0, False: 2.23k]
  ------------------
  631|      0|	schannel(data, to);
  632|      0|	return;
  633|      0|    }
  634|       |
  635|       |    /*
  636|       |     * Find the callback channel if channel param is NULL
  637|       |     */
  638|  2.23k|    if ((ctxt != NULL) && (channel == NULL) &&
  ------------------
  |  Branch (638:9): [True: 1.89k, False: 339]
  |  Branch (638:27): [True: 446, False: 1.44k]
  ------------------
  639|  2.23k|        (xmlStructuredError == NULL) && (ctxt->sax != NULL)) {
  ------------------
  |  |  877|    446|  #define xmlStructuredError XML_GLOBAL_MACRO(xmlStructuredError)
  |  |  ------------------
  |  |  |  |  500|    446|  #define XML_GLOBAL_MACRO(name) (*__##name())
  |  |  ------------------
  ------------------
  |  Branch (639:9): [True: 446, False: 0]
  |  Branch (639:41): [True: 446, False: 0]
  ------------------
  640|    446|        if (level == XML_ERR_WARNING)
  ------------------
  |  Branch (640:13): [True: 12, False: 434]
  ------------------
  641|     12|	    channel = ctxt->sax->warning;
  642|    434|        else
  643|    434|	    channel = ctxt->sax->error;
  644|    446|	data = ctxt->userData;
  645|  1.78k|    } else if (channel == NULL) {
  ------------------
  |  Branch (645:16): [True: 336, False: 1.45k]
  ------------------
  646|    336|	channel = xmlGenericError;
  ------------------
  |  |  875|    336|  #define xmlGenericError XML_GLOBAL_MACRO(xmlGenericError)
  |  |  ------------------
  |  |  |  |  500|    336|  #define XML_GLOBAL_MACRO(name) (*__##name())
  |  |  ------------------
  ------------------
  647|    336|	if (ctxt != NULL) {
  ------------------
  |  Branch (647:6): [True: 0, False: 336]
  ------------------
  648|      0|	    data = ctxt;
  649|    336|	} else {
  650|    336|	    data = xmlGenericErrorContext;
  ------------------
  |  |  876|    336|  #define xmlGenericErrorContext XML_GLOBAL_MACRO(xmlGenericErrorContext)
  |  |  ------------------
  |  |  |  |  500|    336|  #define XML_GLOBAL_MACRO(name) (*__##name())
  |  |  ------------------
  ------------------
  651|    336|	}
  652|    336|    }
  653|  2.23k|    if (channel == NULL)
  ------------------
  |  Branch (653:9): [True: 0, False: 2.23k]
  ------------------
  654|      0|        return;
  655|       |
  656|  2.23k|    if ((channel == xmlParserError) ||
  ------------------
  |  Branch (656:9): [True: 434, False: 1.79k]
  ------------------
  657|  2.23k|        (channel == xmlParserWarning) ||
  ------------------
  |  Branch (657:9): [True: 12, False: 1.78k]
  ------------------
  658|  2.23k|	(channel == xmlParserValidityError) ||
  ------------------
  |  Branch (658:2): [True: 1.44k, False: 340]
  ------------------
  659|  2.23k|	(channel == xmlParserValidityWarning))
  ------------------
  |  Branch (659:2): [True: 4, False: 336]
  ------------------
  660|  1.89k|	xmlReportError(to, ctxt, str, NULL, NULL);
  661|    336|    else if (((void(*)(void)) channel == (void(*)(void)) fprintf) ||
  ------------------
  |  Branch (661:14): [True: 0, False: 336]
  ------------------
  662|    336|             (channel == xmlGenericErrorDefaultFunc))
  ------------------
  |  Branch (662:14): [True: 0, False: 336]
  ------------------
  663|      0|	xmlReportError(to, ctxt, str, channel, data);
  664|    336|    else
  665|    336|	channel(data, "%s", str);
  666|  2.23k|}
xmlResetError:
  901|  2.48k|{
  902|  2.48k|    if (err == NULL)
  ------------------
  |  Branch (902:9): [True: 0, False: 2.48k]
  ------------------
  903|      0|        return;
  904|  2.48k|    if (err->code == XML_ERR_OK)
  ------------------
  |  Branch (904:9): [True: 843, False: 1.64k]
  ------------------
  905|    843|        return;
  906|  1.64k|    if (err->message != NULL)
  ------------------
  |  Branch (906:9): [True: 1.64k, False: 0]
  ------------------
  907|  1.64k|        xmlFree(err->message);
  908|  1.64k|    if (err->file != NULL)
  ------------------
  |  Branch (908:9): [True: 992, False: 649]
  ------------------
  909|    992|        xmlFree(err->file);
  910|  1.64k|    if (err->str1 != NULL)
  ------------------
  |  Branch (910:9): [True: 1.19k, False: 447]
  ------------------
  911|  1.19k|        xmlFree(err->str1);
  912|  1.64k|    if (err->str2 != NULL)
  ------------------
  |  Branch (912:9): [True: 319, False: 1.32k]
  ------------------
  913|    319|        xmlFree(err->str2);
  914|  1.64k|    if (err->str3 != NULL)
  ------------------
  |  Branch (914:9): [True: 24, False: 1.61k]
  ------------------
  915|     24|        xmlFree(err->str3);
  916|  1.64k|    memset(err, 0, sizeof(xmlError));
  917|  1.64k|    err->code = XML_ERR_OK;
  918|  1.64k|}
xmlResetLastError:
  928|    323|{
  929|    323|    if (xmlLastError.code == XML_ERR_OK)
  ------------------
  |  |  874|    323|  #define xmlLastError XML_GLOBAL_MACRO(xmlLastError)
  |  |  ------------------
  |  |  |  |  500|    323|  #define XML_GLOBAL_MACRO(name) (*__##name())
  |  |  ------------------
  ------------------
  |  Branch (929:9): [True: 72, False: 251]
  ------------------
  930|     72|        return;
  931|    251|    xmlResetError(&xmlLastError);
  ------------------
  |  |  874|    251|  #define xmlLastError XML_GLOBAL_MACRO(xmlLastError)
  |  |  ------------------
  |  |  |  |  500|    251|  #define XML_GLOBAL_MACRO(name) (*__##name())
  |  |  ------------------
  ------------------
  932|    251|}
xmlCopyError:
  984|  2.08k|xmlCopyError(const xmlError *from, xmlErrorPtr to) {
  985|  2.08k|    char *message, *file, *str1, *str2, *str3;
  986|       |
  987|  2.08k|    if ((from == NULL) || (to == NULL))
  ------------------
  |  Branch (987:9): [True: 0, False: 2.08k]
  |  Branch (987:27): [True: 0, False: 2.08k]
  ------------------
  988|      0|        return(-1);
  989|       |
  990|  2.08k|    message = (char *) xmlStrdup((xmlChar *) from->message);
  991|  2.08k|    file = (char *) xmlStrdup ((xmlChar *) from->file);
  992|  2.08k|    str1 = (char *) xmlStrdup ((xmlChar *) from->str1);
  993|  2.08k|    str2 = (char *) xmlStrdup ((xmlChar *) from->str2);
  994|  2.08k|    str3 = (char *) xmlStrdup ((xmlChar *) from->str3);
  995|       |
  996|  2.08k|    if (to->message != NULL)
  ------------------
  |  Branch (996:9): [True: 1.64k, False: 438]
  ------------------
  997|  1.64k|        xmlFree(to->message);
  998|  2.08k|    if (to->file != NULL)
  ------------------
  |  Branch (998:9): [True: 1.07k, False: 1.00k]
  ------------------
  999|  1.07k|        xmlFree(to->file);
 1000|  2.08k|    if (to->str1 != NULL)
  ------------------
  |  Branch (1000:9): [True: 1.14k, False: 942]
  ------------------
 1001|  1.14k|        xmlFree(to->str1);
 1002|  2.08k|    if (to->str2 != NULL)
  ------------------
  |  Branch (1002:9): [True: 315, False: 1.76k]
  ------------------
 1003|    315|        xmlFree(to->str2);
 1004|  2.08k|    if (to->str3 != NULL)
  ------------------
  |  Branch (1004:9): [True: 28, False: 2.05k]
  ------------------
 1005|     28|        xmlFree(to->str3);
 1006|  2.08k|    to->domain = from->domain;
 1007|  2.08k|    to->code = from->code;
 1008|  2.08k|    to->level = from->level;
 1009|  2.08k|    to->line = from->line;
 1010|  2.08k|    to->node = from->node;
 1011|  2.08k|    to->int1 = from->int1;
 1012|  2.08k|    to->int2 = from->int2;
 1013|  2.08k|    to->node = from->node;
 1014|  2.08k|    to->ctxt = from->ctxt;
 1015|  2.08k|    to->message = message;
 1016|  2.08k|    to->file = file;
 1017|  2.08k|    to->str1 = str1;
 1018|  2.08k|    to->str2 = str2;
 1019|  2.08k|    to->str3 = str3;
 1020|       |
 1021|  2.08k|    return 0;
 1022|  2.08k|}
error.c:xmlParserPrintFileContextInternal:
  175|  1.95k|		xmlGenericErrorFunc channel, void *data ) {
  176|  1.95k|    const xmlChar *cur, *base, *start;
  177|  1.95k|    unsigned int n, col;	/* GCC warns if signed, because compared with sizeof() */
  178|  1.95k|    xmlChar  content[81]; /* space for 80 chars + line terminator */
  179|  1.95k|    xmlChar *ctnt;
  180|       |
  181|  1.95k|    if ((input == NULL) || (input->cur == NULL))
  ------------------
  |  Branch (181:9): [True: 0, False: 1.95k]
  |  Branch (181:28): [True: 0, False: 1.95k]
  ------------------
  182|      0|        return;
  183|       |
  184|  1.95k|    cur = input->cur;
  185|  1.95k|    base = input->base;
  186|       |    /* skip backwards over any end-of-lines */
  187|  2.49k|    while ((cur > base) && ((*(cur) == '\n') || (*(cur) == '\r'))) {
  ------------------
  |  Branch (187:12): [True: 2.42k, False: 70]
  |  Branch (187:29): [True: 539, False: 1.88k]
  |  Branch (187:49): [True: 2, False: 1.88k]
  ------------------
  188|    541|	cur--;
  189|    541|    }
  190|  1.95k|    n = 0;
  191|       |    /* search backwards for beginning-of-line (to max buff size) */
  192|  59.5k|    while ((n < sizeof(content) - 1) && (cur > base) &&
  ------------------
  |  Branch (192:12): [True: 59.3k, False: 163]
  |  Branch (192:41): [True: 59.0k, False: 325]
  ------------------
  193|  59.5k|	   (*cur != '\n') && (*cur != '\r')) {
  ------------------
  |  Branch (193:5): [True: 57.5k, False: 1.45k]
  |  Branch (193:23): [True: 57.5k, False: 3]
  ------------------
  194|  57.5k|        cur--;
  195|  57.5k|        n++;
  196|  57.5k|    }
  197|  1.95k|    if ((n > 0) && ((*cur == '\n') || (*cur == '\r'))) {
  ------------------
  |  Branch (197:9): [True: 1.88k, False: 70]
  |  Branch (197:21): [True: 1.46k, False: 417]
  |  Branch (197:39): [True: 3, False: 414]
  ------------------
  198|  1.46k|        cur++;
  199|  1.46k|    } else {
  200|       |        /* skip over continuation bytes */
  201|    490|        while ((cur < input->cur) && ((*cur & 0xC0) == 0x80))
  ------------------
  |  Branch (201:16): [True: 424, False: 66]
  |  Branch (201:38): [True: 6, False: 418]
  ------------------
  202|      6|            cur++;
  203|    484|    }
  204|       |    /* calculate the error position in terms of the current position */
  205|  1.95k|    col = input->cur - cur;
  206|       |    /* search forward for end-of-line (to max buff size) */
  207|  1.95k|    n = 0;
  208|  1.95k|    start = cur;
  209|       |    /* copy selected text to our buffer */
  210|  67.6k|    while ((*cur != 0) && (*(cur) != '\n') && (*(cur) != '\r')) {
  ------------------
  |  Branch (210:12): [True: 67.3k, False: 292]
  |  Branch (210:27): [True: 66.1k, False: 1.26k]
  |  Branch (210:47): [True: 65.9k, False: 171]
  ------------------
  211|  65.9k|        int len = input->end - cur;
  212|  65.9k|        int c = xmlGetUTF8Char(cur, &len);
  213|       |
  214|  65.9k|        if ((c < 0) || (n + len > sizeof(content)-1))
  ------------------
  |  Branch (214:13): [True: 58, False: 65.9k]
  |  Branch (214:24): [True: 164, False: 65.7k]
  ------------------
  215|    222|            break;
  216|  65.7k|        cur += len;
  217|  65.7k|	n += len;
  218|  65.7k|    }
  219|  1.95k|    memcpy(content, start, n);
  220|  1.95k|    content[n] = 0;
  221|       |    /* print out the selected text */
  222|  1.95k|    channel(data ,"%s\n", content);
  223|       |    /* create blank line with problem pointer */
  224|  1.95k|    n = 0;
  225|  1.95k|    ctnt = content;
  226|       |    /* (leave buffer space for pointer + line terminator) */
  227|  58.4k|    while ((n<col) && (n++ < sizeof(content)-2) && (*ctnt != 0)) {
  ------------------
  |  Branch (227:12): [True: 56.6k, False: 1.78k]
  |  Branch (227:23): [True: 56.4k, False: 159]
  |  Branch (227:52): [True: 56.4k, False: 4]
  ------------------
  228|  56.4k|	if (*(ctnt) != '\t')
  ------------------
  |  Branch (228:6): [True: 56.4k, False: 4]
  ------------------
  229|  56.4k|	    *(ctnt) = ' ';
  230|  56.4k|	ctnt++;
  231|  56.4k|    }
  232|  1.95k|    *ctnt++ = '^';
  233|  1.95k|    *ctnt = 0;
  234|  1.95k|    channel(data ,"%s\n", content);
  235|  1.95k|}
error.c:xmlReportError:
  261|  1.89k|{
  262|  1.89k|    char *file = NULL;
  263|  1.89k|    int line = 0;
  264|  1.89k|    int code = -1;
  265|  1.89k|    int domain;
  266|  1.89k|    const xmlChar *name = NULL;
  267|  1.89k|    xmlNodePtr node;
  268|  1.89k|    xmlErrorLevel level;
  269|  1.89k|    xmlParserInputPtr input = NULL;
  270|  1.89k|    xmlParserInputPtr cur = NULL;
  271|       |
  272|  1.89k|    if (err == NULL)
  ------------------
  |  Branch (272:9): [True: 0, False: 1.89k]
  ------------------
  273|      0|        return;
  274|       |
  275|  1.89k|    if (channel == NULL) {
  ------------------
  |  Branch (275:9): [True: 1.89k, False: 0]
  ------------------
  276|  1.89k|	channel = xmlGenericError;
  ------------------
  |  |  875|  1.89k|  #define xmlGenericError XML_GLOBAL_MACRO(xmlGenericError)
  |  |  ------------------
  |  |  |  |  500|  1.89k|  #define XML_GLOBAL_MACRO(name) (*__##name())
  |  |  ------------------
  ------------------
  277|  1.89k|	data = xmlGenericErrorContext;
  ------------------
  |  |  876|  1.89k|  #define xmlGenericErrorContext XML_GLOBAL_MACRO(xmlGenericErrorContext)
  |  |  ------------------
  |  |  |  |  500|  1.89k|  #define XML_GLOBAL_MACRO(name) (*__##name())
  |  |  ------------------
  ------------------
  278|  1.89k|    }
  279|  1.89k|    file = err->file;
  280|  1.89k|    line = err->line;
  281|  1.89k|    code = err->code;
  282|  1.89k|    domain = err->domain;
  283|  1.89k|    level = err->level;
  284|  1.89k|    node = err->node;
  285|       |
  286|  1.89k|    if (code == XML_ERR_OK)
  ------------------
  |  Branch (286:9): [True: 0, False: 1.89k]
  ------------------
  287|      0|        return;
  288|       |
  289|  1.89k|    if ((node != NULL) && (node->type == XML_ELEMENT_NODE))
  ------------------
  |  Branch (289:9): [True: 977, False: 920]
  |  Branch (289:27): [True: 924, False: 53]
  ------------------
  290|    924|        name = node->name;
  291|       |
  292|       |    /*
  293|       |     * Maintain the compatibility with the legacy error handling
  294|       |     */
  295|  1.89k|    if (ctxt != NULL) {
  ------------------
  |  Branch (295:9): [True: 1.89k, False: 3]
  ------------------
  296|  1.89k|        input = ctxt->input;
  297|  1.89k|        if ((input != NULL) && (input->filename == NULL) &&
  ------------------
  |  Branch (297:13): [True: 1.89k, False: 0]
  |  Branch (297:32): [True: 695, False: 1.19k]
  ------------------
  298|  1.89k|            (ctxt->inputNr > 1)) {
  ------------------
  |  Branch (298:13): [True: 56, False: 639]
  ------------------
  299|     56|            cur = input;
  300|     56|            input = ctxt->inputTab[ctxt->inputNr - 2];
  301|     56|        }
  302|  1.89k|        if (input != NULL) {
  ------------------
  |  Branch (302:13): [True: 1.89k, False: 0]
  ------------------
  303|  1.89k|            if (input->filename)
  ------------------
  |  Branch (303:17): [True: 1.23k, False: 663]
  ------------------
  304|  1.23k|                channel(data, "%s:%d: ", input->filename, input->line);
  305|    663|            else if ((line != 0) && (domain == XML_FROM_PARSER))
  ------------------
  |  Branch (305:22): [True: 663, False: 0]
  |  Branch (305:37): [True: 91, False: 572]
  ------------------
  306|     91|                channel(data, "Entity: line %d: ", input->line);
  307|  1.89k|        }
  308|  1.89k|    } else {
  309|      3|        if (file != NULL)
  ------------------
  |  Branch (309:13): [True: 2, False: 1]
  ------------------
  310|      2|            channel(data, "%s:%d: ", file, line);
  311|      1|        else if ((line != 0) &&
  ------------------
  |  Branch (311:18): [True: 0, False: 1]
  ------------------
  312|      1|	         ((domain == XML_FROM_PARSER) || (domain == XML_FROM_SCHEMASV)||
  ------------------
  |  Branch (312:12): [True: 0, False: 0]
  |  Branch (312:43): [True: 0, False: 0]
  ------------------
  313|      0|		  (domain == XML_FROM_SCHEMASP)||(domain == XML_FROM_DTD) ||
  ------------------
  |  Branch (313:5): [True: 0, False: 0]
  |  Branch (313:36): [True: 0, False: 0]
  ------------------
  314|      0|		  (domain == XML_FROM_RELAXNGP)||(domain == XML_FROM_RELAXNGV)))
  ------------------
  |  Branch (314:5): [True: 0, False: 0]
  |  Branch (314:36): [True: 0, False: 0]
  ------------------
  315|      0|            channel(data, "Entity: line %d: ", line);
  316|      3|    }
  317|  1.89k|    if (name != NULL) {
  ------------------
  |  Branch (317:9): [True: 924, False: 973]
  ------------------
  318|    924|        channel(data, "element %s: ", name);
  319|    924|    }
  320|  1.89k|    switch (domain) {
  321|    386|        case XML_FROM_PARSER:
  ------------------
  |  Branch (321:9): [True: 386, False: 1.51k]
  ------------------
  322|    386|            channel(data, "parser ");
  323|    386|            break;
  324|     60|        case XML_FROM_NAMESPACE:
  ------------------
  |  Branch (324:9): [True: 60, False: 1.83k]
  ------------------
  325|     60|            channel(data, "namespace ");
  326|     60|            break;
  327|    473|        case XML_FROM_DTD:
  ------------------
  |  Branch (327:9): [True: 473, False: 1.42k]
  ------------------
  328|  1.45k|        case XML_FROM_VALID:
  ------------------
  |  Branch (328:9): [True: 978, False: 919]
  ------------------
  329|  1.45k|            channel(data, "validity ");
  330|  1.45k|            break;
  331|      0|        case XML_FROM_HTML:
  ------------------
  |  Branch (331:9): [True: 0, False: 1.89k]
  ------------------
  332|      0|            channel(data, "HTML parser ");
  333|      0|            break;
  334|      0|        case XML_FROM_MEMORY:
  ------------------
  |  Branch (334:9): [True: 0, False: 1.89k]
  ------------------
  335|      0|            channel(data, "memory ");
  336|      0|            break;
  337|      0|        case XML_FROM_OUTPUT:
  ------------------
  |  Branch (337:9): [True: 0, False: 1.89k]
  ------------------
  338|      0|            channel(data, "output ");
  339|      0|            break;
  340|      0|        case XML_FROM_IO:
  ------------------
  |  Branch (340:9): [True: 0, False: 1.89k]
  ------------------
  341|      0|            channel(data, "I/O ");
  342|      0|            break;
  343|      0|        case XML_FROM_XINCLUDE:
  ------------------
  |  Branch (343:9): [True: 0, False: 1.89k]
  ------------------
  344|      0|            channel(data, "XInclude ");
  345|      0|            break;
  346|      0|        case XML_FROM_XPATH:
  ------------------
  |  Branch (346:9): [True: 0, False: 1.89k]
  ------------------
  347|      0|            channel(data, "XPath ");
  348|      0|            break;
  349|      0|        case XML_FROM_XPOINTER:
  ------------------
  |  Branch (349:9): [True: 0, False: 1.89k]
  ------------------
  350|      0|            channel(data, "parser ");
  351|      0|            break;
  352|      0|        case XML_FROM_REGEXP:
  ------------------
  |  Branch (352:9): [True: 0, False: 1.89k]
  ------------------
  353|      0|            channel(data, "regexp ");
  354|      0|            break;
  355|      0|        case XML_FROM_MODULE:
  ------------------
  |  Branch (355:9): [True: 0, False: 1.89k]
  ------------------
  356|      0|            channel(data, "module ");
  357|      0|            break;
  358|      0|        case XML_FROM_SCHEMASV:
  ------------------
  |  Branch (358:9): [True: 0, False: 1.89k]
  ------------------
  359|      0|            channel(data, "Schemas validity ");
  360|      0|            break;
  361|      0|        case XML_FROM_SCHEMASP:
  ------------------
  |  Branch (361:9): [True: 0, False: 1.89k]
  ------------------
  362|      0|            channel(data, "Schemas parser ");
  363|      0|            break;
  364|      0|        case XML_FROM_RELAXNGP:
  ------------------
  |  Branch (364:9): [True: 0, False: 1.89k]
  ------------------
  365|      0|            channel(data, "Relax-NG parser ");
  366|      0|            break;
  367|      0|        case XML_FROM_RELAXNGV:
  ------------------
  |  Branch (367:9): [True: 0, False: 1.89k]
  ------------------
  368|      0|            channel(data, "Relax-NG validity ");
  369|      0|            break;
  370|      0|        case XML_FROM_CATALOG:
  ------------------
  |  Branch (370:9): [True: 0, False: 1.89k]
  ------------------
  371|      0|            channel(data, "Catalog ");
  372|      0|            break;
  373|      0|        case XML_FROM_C14N:
  ------------------
  |  Branch (373:9): [True: 0, False: 1.89k]
  ------------------
  374|      0|            channel(data, "C14N ");
  375|      0|            break;
  376|      0|        case XML_FROM_XSLT:
  ------------------
  |  Branch (376:9): [True: 0, False: 1.89k]
  ------------------
  377|      0|            channel(data, "XSLT ");
  378|      0|            break;
  379|      0|        case XML_FROM_I18N:
  ------------------
  |  Branch (379:9): [True: 0, False: 1.89k]
  ------------------
  380|      0|            channel(data, "encoding ");
  381|      0|            break;
  382|      0|        case XML_FROM_SCHEMATRONV:
  ------------------
  |  Branch (382:9): [True: 0, False: 1.89k]
  ------------------
  383|      0|            channel(data, "schematron ");
  384|      0|            break;
  385|      0|        case XML_FROM_BUFFER:
  ------------------
  |  Branch (385:9): [True: 0, False: 1.89k]
  ------------------
  386|      0|            channel(data, "internal buffer ");
  387|      0|            break;
  388|      0|        case XML_FROM_URI:
  ------------------
  |  Branch (388:9): [True: 0, False: 1.89k]
  ------------------
  389|      0|            channel(data, "URI ");
  390|      0|            break;
  391|      0|        default:
  ------------------
  |  Branch (391:9): [True: 0, False: 1.89k]
  ------------------
  392|      0|            break;
  393|  1.89k|    }
  394|  1.89k|    switch (level) {
  ------------------
  |  Branch (394:13): [True: 0, False: 1.89k]
  ------------------
  395|      0|        case XML_ERR_NONE:
  ------------------
  |  Branch (395:9): [True: 0, False: 1.89k]
  ------------------
  396|      0|            channel(data, ": ");
  397|      0|            break;
  398|     16|        case XML_ERR_WARNING:
  ------------------
  |  Branch (398:9): [True: 16, False: 1.88k]
  ------------------
  399|     16|            channel(data, "warning : ");
  400|     16|            break;
  401|  1.50k|        case XML_ERR_ERROR:
  ------------------
  |  Branch (401:9): [True: 1.50k, False: 394]
  ------------------
  402|  1.50k|            channel(data, "error : ");
  403|  1.50k|            break;
  404|    378|        case XML_ERR_FATAL:
  ------------------
  |  Branch (404:9): [True: 378, False: 1.51k]
  ------------------
  405|    378|            channel(data, "error : ");
  406|    378|            break;
  407|  1.89k|    }
  408|  1.89k|    if (str != NULL) {
  ------------------
  |  Branch (408:9): [True: 1.89k, False: 0]
  ------------------
  409|  1.89k|        int len;
  410|  1.89k|	len = xmlStrlen((const xmlChar *)str);
  411|  1.89k|	if ((len > 0) && (str[len - 1] != '\n'))
  ------------------
  |  Branch (411:6): [True: 1.89k, False: 0]
  |  Branch (411:19): [True: 487, False: 1.41k]
  ------------------
  412|    487|	    channel(data, "%s\n", str);
  413|  1.41k|	else
  414|  1.41k|	    channel(data, "%s", str);
  415|  1.89k|    } else {
  416|      0|        channel(data, "%s\n", "out of memory error");
  417|      0|    }
  418|       |
  419|  1.89k|    if (ctxt != NULL) {
  ------------------
  |  Branch (419:9): [True: 1.89k, False: 3]
  ------------------
  420|  1.89k|        xmlParserPrintFileContextInternal(input, channel, data);
  421|  1.89k|        if (cur != NULL) {
  ------------------
  |  Branch (421:13): [True: 56, False: 1.83k]
  ------------------
  422|     56|            if (cur->filename)
  ------------------
  |  Branch (422:17): [True: 0, False: 56]
  ------------------
  423|      0|                channel(data, "%s:%d: \n", cur->filename, cur->line);
  424|     56|            else if ((line != 0) && (domain == XML_FROM_PARSER))
  ------------------
  |  Branch (424:22): [True: 56, False: 0]
  |  Branch (424:37): [True: 56, False: 0]
  ------------------
  425|     56|                channel(data, "Entity: line %d: \n", cur->line);
  426|     56|            xmlParserPrintFileContextInternal(cur, channel, data);
  427|     56|        }
  428|  1.89k|    }
  429|  1.89k|    if ((domain == XML_FROM_XPATH) && (err->str1 != NULL) &&
  ------------------
  |  Branch (429:9): [True: 0, False: 1.89k]
  |  Branch (429:39): [True: 0, False: 0]
  ------------------
  430|  1.89k|        (err->int1 < 100) &&
  ------------------
  |  Branch (430:9): [True: 0, False: 0]
  ------------------
  431|  1.89k|	(err->int1 < xmlStrlen((const xmlChar *)err->str1))) {
  ------------------
  |  Branch (431:2): [True: 0, False: 0]
  ------------------
  432|      0|	xmlChar buf[150];
  433|      0|	int i;
  434|       |
  435|      0|	channel(data, "%s\n", err->str1);
  436|      0|	for (i=0;i < err->int1;i++)
  ------------------
  |  Branch (436:11): [True: 0, False: 0]
  ------------------
  437|      0|	     buf[i] = ' ';
  438|      0|	buf[i++] = '^';
  439|      0|	buf[i] = 0;
  440|      0|	channel(data, "%s\n", buf);
  441|      0|    }
  442|  1.89k|}

xmlFuzzErrorFunc:
   56|  12.2k|                 ...) {
   57|  12.2k|}
xmlFuzzMemSetup:
  103|      2|xmlFuzzMemSetup(void) {
  104|      2|    xmlMemSetup(free, xmlFuzzMalloc, xmlFuzzRealloc, xmlMemStrdup);
  105|      2|}
xmlFuzzMemSetLimit:
  108|  1.61k|xmlFuzzMemSetLimit(size_t limit) {
  109|  1.61k|    fuzzNumAllocs = 0;
  110|  1.61k|    fuzzMaxAllocs = limit ? limit + XML_FUZZ_MALLOC_OFFSET : 0;
  ------------------
  |  |   69|      0|#define XML_FUZZ_MALLOC_OFFSET  0
  ------------------
  |  Branch (110:21): [True: 0, False: 1.61k]
  ------------------
  111|  1.61k|    fuzzAllocFailed = 0;
  112|  1.61k|}
xmlFuzzDataInit:
  125|    323|xmlFuzzDataInit(const char *data, size_t size) {
  126|    323|    fuzzData.data = data;
  127|    323|    fuzzData.size = size;
  128|    323|    fuzzData.ptr = data;
  129|    323|    fuzzData.remaining = size;
  130|       |
  131|    323|    fuzzData.outBuf = xmlMalloc(size + 1);
  132|    323|    fuzzData.outPtr = fuzzData.outBuf;
  133|       |
  134|    323|    fuzzData.entities = xmlHashCreate(8);
  135|    323|    fuzzData.mainUrl = NULL;
  136|    323|    fuzzData.mainEntity = NULL;
  137|    323|}
xmlFuzzDataCleanup:
  145|    323|xmlFuzzDataCleanup(void) {
  146|    323|    xmlFree(fuzzData.outBuf);
  147|    323|    xmlHashFree(fuzzData.entities, xmlHashDefaultDeallocator);
  148|    323|}
xmlFuzzReadInt:
  181|    646|xmlFuzzReadInt(int size) {
  182|    646|    size_t ret = 0;
  183|       |
  184|  3.23k|    while ((size > 0) && (fuzzData.remaining > 0)) {
  ------------------
  |  Branch (184:12): [True: 2.58k, False: 646]
  |  Branch (184:26): [True: 2.58k, False: 0]
  ------------------
  185|  2.58k|        unsigned char c = (unsigned char) *fuzzData.ptr++;
  186|  2.58k|        fuzzData.remaining--;
  187|  2.58k|        ret = (ret << 8) | c;
  188|  2.58k|        size--;
  189|  2.58k|    }
  190|       |
  191|    646|    return ret;
  192|    646|}
xmlFuzzReadString:
  245|  1.04k|xmlFuzzReadString(size_t *size) {
  246|  1.04k|    const char *out = fuzzData.outPtr;
  247|       |
  248|  1.43M|    while (fuzzData.remaining > 0) {
  ------------------
  |  Branch (248:12): [True: 1.43M, False: 323]
  ------------------
  249|  1.43M|        int c = *fuzzData.ptr++;
  250|  1.43M|        fuzzData.remaining--;
  251|       |
  252|  1.43M|        if ((c == '\\') && (fuzzData.remaining > 0)) {
  ------------------
  |  Branch (252:13): [True: 729, False: 1.43M]
  |  Branch (252:28): [True: 729, False: 0]
  ------------------
  253|    729|            int c2 = *fuzzData.ptr;
  254|       |
  255|    729|            if (c2 == '\n') {
  ------------------
  |  Branch (255:17): [True: 726, False: 3]
  ------------------
  256|    726|                fuzzData.ptr++;
  257|    726|                fuzzData.remaining--;
  258|    726|                if (size != NULL)
  ------------------
  |  Branch (258:21): [True: 363, False: 363]
  ------------------
  259|    363|                    *size = fuzzData.outPtr - out;
  260|    726|                *fuzzData.outPtr++ = '\0';
  261|    726|                return(out);
  262|    726|            }
  263|      3|            if (c2 == '\\') {
  ------------------
  |  Branch (263:17): [True: 3, False: 0]
  ------------------
  264|      3|                fuzzData.ptr++;
  265|      3|                fuzzData.remaining--;
  266|      3|            }
  267|      3|        }
  268|       |
  269|  1.43M|        *fuzzData.outPtr++ = c;
  270|  1.43M|    }
  271|       |
  272|    323|    if (fuzzData.outPtr > out) {
  ------------------
  |  Branch (272:9): [True: 0, False: 323]
  ------------------
  273|      0|        if (size != NULL)
  ------------------
  |  Branch (273:13): [True: 0, False: 0]
  ------------------
  274|      0|            *size = fuzzData.outPtr - out;
  275|      0|        *fuzzData.outPtr++ = '\0';
  276|      0|        return(out);
  277|      0|    }
  278|       |
  279|    323|    if (size != NULL)
  ------------------
  |  Branch (279:9): [True: 0, False: 323]
  ------------------
  280|      0|        *size = 0;
  281|    323|    return(NULL);
  282|    323|}
xmlFuzzReadEntities:
  291|    323|xmlFuzzReadEntities(void) {
  292|    323|    size_t num = 0;
  293|       |
  294|    686|    while (1) {
  ------------------
  |  Branch (294:12): [Folded - Ignored]
  ------------------
  295|    686|        const char *url, *entity;
  296|    686|        size_t entitySize;
  297|    686|        xmlFuzzEntityInfo *entityInfo;
  298|       |
  299|    686|        url = xmlFuzzReadString(NULL);
  300|    686|        if (url == NULL) break;
  ------------------
  |  Branch (300:13): [True: 323, False: 363]
  ------------------
  301|       |
  302|    363|        entity = xmlFuzzReadString(&entitySize);
  303|    363|        if (entity == NULL) break;
  ------------------
  |  Branch (303:13): [True: 0, False: 363]
  ------------------
  304|       |
  305|    363|        if (xmlHashLookup(fuzzData.entities, (xmlChar *)url) == NULL) {
  ------------------
  |  Branch (305:13): [True: 363, False: 0]
  ------------------
  306|    363|            entityInfo = xmlMalloc(sizeof(xmlFuzzEntityInfo));
  307|    363|            if (entityInfo == NULL)
  ------------------
  |  Branch (307:17): [True: 0, False: 363]
  ------------------
  308|      0|                break;
  309|    363|            entityInfo->data = entity;
  310|    363|            entityInfo->size = entitySize;
  311|       |
  312|    363|            xmlHashAddEntry(fuzzData.entities, (xmlChar *)url, entityInfo);
  313|       |
  314|    363|            if (num == 0) {
  ------------------
  |  Branch (314:17): [True: 323, False: 40]
  ------------------
  315|    323|                fuzzData.mainUrl = url;
  316|    323|                fuzzData.mainEntity = entityInfo;
  317|    323|            }
  318|       |
  319|    363|            num++;
  320|    363|        }
  321|    363|    }
  322|    323|}
xmlFuzzMainUrl:
  330|    323|xmlFuzzMainUrl(void) {
  331|    323|    return(fuzzData.mainUrl);
  332|    323|}
xmlFuzzMainEntity:
  341|    323|xmlFuzzMainEntity(size_t *size) {
  342|    323|    if (fuzzData.mainEntity == NULL)
  ------------------
  |  Branch (342:9): [True: 0, False: 323]
  ------------------
  343|      0|        return(NULL);
  344|    323|    *size = fuzzData.mainEntity->size;
  345|    323|    return(fuzzData.mainEntity->data);
  346|    323|}
xmlFuzzEntityLoader:
  355|  13.5k|                    xmlParserCtxtPtr ctxt) {
  356|  13.5k|    xmlParserInputPtr input;
  357|  13.5k|    xmlFuzzEntityInfo *entity;
  358|       |
  359|  13.5k|    if (URL == NULL)
  ------------------
  |  Branch (359:9): [True: 0, False: 13.5k]
  ------------------
  360|      0|        return(NULL);
  361|  13.5k|    entity = xmlHashLookup(fuzzData.entities, (xmlChar *) URL);
  362|  13.5k|    if (entity == NULL)
  ------------------
  |  Branch (362:9): [True: 232, False: 13.3k]
  ------------------
  363|    232|        return(NULL);
  364|       |
  365|  13.3k|    input = xmlNewInputStream(ctxt);
  366|  13.3k|    if (input == NULL)
  ------------------
  |  Branch (366:9): [True: 0, False: 13.3k]
  ------------------
  367|      0|        return(NULL);
  368|  13.3k|    input->filename = (char *) xmlCharStrdup(URL);
  369|  13.3k|    input->buf = xmlParserInputBufferCreateMem(entity->data, entity->size,
  370|  13.3k|                                               XML_CHAR_ENCODING_NONE);
  371|  13.3k|    if (input->buf == NULL) {
  ------------------
  |  Branch (371:9): [True: 0, False: 13.3k]
  ------------------
  372|      0|        xmlFreeInputStream(input);
  373|      0|        return(NULL);
  374|      0|    }
  375|  13.3k|    input->base = input->cur = xmlBufContent(input->buf->buffer);
  376|  13.3k|    input->end = input->base + xmlBufUse(input->buf->buffer);
  377|       |
  378|  13.3k|    return input;
  379|  13.3k|}
fuzz.c:xmlFuzzMalloc:
   73|  2.52M|xmlFuzzMalloc(size_t size) {
   74|  2.52M|    if (fuzzMaxAllocs > 0) {
  ------------------
  |  Branch (74:9): [True: 0, False: 2.52M]
  ------------------
   75|      0|        if (fuzzNumAllocs >= fuzzMaxAllocs - 1) {
  ------------------
  |  Branch (75:13): [True: 0, False: 0]
  ------------------
   76|       |#if XML_FUZZ_MALLOC_ABORT
   77|       |            abort();
   78|       |#endif
   79|      0|            fuzzAllocFailed = 1;
   80|      0|            return(NULL);
   81|      0|        }
   82|      0|        fuzzNumAllocs += 1;
   83|      0|    }
   84|  2.52M|    return malloc(size);
   85|  2.52M|}
fuzz.c:xmlFuzzRealloc:
   88|  49.5k|xmlFuzzRealloc(void *ptr, size_t size) {
   89|  49.5k|    if (fuzzMaxAllocs > 0) {
  ------------------
  |  Branch (89:9): [True: 0, False: 49.5k]
  ------------------
   90|      0|        if (fuzzNumAllocs >= fuzzMaxAllocs - 1) {
  ------------------
  |  Branch (90:13): [True: 0, False: 0]
  ------------------
   91|       |#if XML_FUZZ_MALLOC_ABORT
   92|       |            abort();
   93|       |#endif
   94|      0|            fuzzAllocFailed = 1;
   95|      0|            return(NULL);
   96|      0|        }
   97|      0|        fuzzNumAllocs += 1;
   98|      0|    }
   99|  49.5k|    return realloc(ptr, size);
  100|  49.5k|}

LLVMFuzzerInitialize:
   16|      2|                     char ***argv ATTRIBUTE_UNUSED) {
   17|      2|    xmlFuzzMemSetup();
   18|      2|    xmlInitParser();
   19|      2|#ifdef LIBXML_CATALOG_ENABLED
   20|      2|    xmlInitializeCatalog();
   21|      2|#endif
   22|      2|    xmlSetGenericErrorFunc(NULL, xmlFuzzErrorFunc);
   23|      2|    xmlSetExternalEntityLoader(xmlFuzzEntityLoader);
   24|       |
   25|      2|    return 0;
   26|      2|}
LLVMFuzzerTestOneInput:
   29|    323|LLVMFuzzerTestOneInput(const char *data, size_t size) {
   30|    323|    xmlDocPtr doc;
   31|    323|    xmlValidCtxtPtr vctxt;
   32|    323|    const char *docBuffer, *docUrl;
   33|    323|    size_t maxAlloc, docSize;
   34|    323|    int opts;
   35|       |
   36|    323|    xmlFuzzDataInit(data, size);
   37|    323|    opts = (int) xmlFuzzReadInt(4);
   38|    323|    opts &= ~XML_PARSE_XINCLUDE;
   39|    323|    opts |= XML_PARSE_DTDVALID;
   40|    323|    maxAlloc = xmlFuzzReadInt(4) % (size + 1);
   41|       |
   42|    323|    xmlFuzzReadEntities();
   43|    323|    docBuffer = xmlFuzzMainEntity(&docSize);
   44|    323|    docUrl = xmlFuzzMainUrl();
   45|    323|    if (docBuffer == NULL)
  ------------------
  |  Branch (45:9): [True: 0, False: 323]
  ------------------
   46|      0|        goto exit;
   47|       |
   48|       |    /* Pull parser */
   49|       |
   50|    323|    xmlFuzzMemSetLimit(maxAlloc);
   51|    323|    doc = xmlReadMemory(docBuffer, docSize, docUrl, NULL, opts);
   52|    323|    xmlFreeDoc(doc);
   53|       |
   54|       |    /* Post validation */
   55|       |
   56|    323|    xmlFuzzMemSetLimit(maxAlloc);
   57|    323|    doc = xmlReadMemory(docBuffer, docSize, docUrl, NULL, opts & ~XML_PARSE_DTDVALID);
   58|    323|    vctxt = xmlNewValidCtxt();
   59|    323|    xmlValidateDocument(vctxt, doc);
   60|    323|    xmlFreeValidCtxt(vctxt);
   61|    323|    xmlFreeDoc(doc);
   62|       |
   63|       |    /* Push parser */
   64|       |
   65|    323|#ifdef LIBXML_PUSH_ENABLED
   66|    323|    {
   67|    323|        static const size_t maxChunkSize = 128;
   68|    323|        xmlParserCtxtPtr ctxt;
   69|    323|        size_t consumed, chunkSize;
   70|       |
   71|    323|        xmlFuzzMemSetLimit(maxAlloc);
   72|    323|        ctxt = xmlCreatePushParserCtxt(NULL, NULL, NULL, 0, docUrl);
   73|    323|        if (ctxt == NULL)
  ------------------
  |  Branch (73:13): [True: 0, False: 323]
  ------------------
   74|      0|            goto exit;
   75|    323|        xmlCtxtUseOptions(ctxt, opts);
   76|       |
   77|  10.1k|        for (consumed = 0; consumed < docSize; consumed += chunkSize) {
  ------------------
  |  Branch (77:28): [True: 9.85k, False: 323]
  ------------------
   78|  9.85k|            chunkSize = docSize - consumed;
   79|  9.85k|            if (chunkSize > maxChunkSize)
  ------------------
  |  Branch (79:17): [True: 9.53k, False: 322]
  ------------------
   80|  9.53k|                chunkSize = maxChunkSize;
   81|  9.85k|            xmlParseChunk(ctxt, docBuffer + consumed, chunkSize, 0);
   82|  9.85k|        }
   83|       |
   84|    323|        xmlParseChunk(ctxt, NULL, 0, 1);
   85|    323|        xmlFreeDoc(ctxt->myDoc);
   86|    323|        xmlFreeParserCtxt(ctxt);
   87|    323|    }
   88|      0|#endif
   89|       |
   90|       |    /* Reader */
   91|       |
   92|      0|#ifdef LIBXML_READER_ENABLED
   93|      0|    {
   94|    323|        xmlTextReaderPtr reader;
   95|    323|        int j;
   96|       |
   97|    323|        xmlFuzzMemSetLimit(maxAlloc);
   98|    323|        reader = xmlReaderForMemory(docBuffer, docSize, NULL, NULL, opts);
   99|    323|        if (reader == NULL)
  ------------------
  |  Branch (99:13): [True: 0, False: 323]
  ------------------
  100|      0|            goto exit;
  101|  36.4k|        while (xmlTextReaderRead(reader) == 1) {
  ------------------
  |  Branch (101:16): [True: 36.0k, False: 323]
  ------------------
  102|  36.0k|            if (xmlTextReaderNodeType(reader) == XML_ELEMENT_NODE) {
  ------------------
  |  Branch (102:17): [True: 14.2k, False: 21.8k]
  ------------------
  103|  14.2k|                int i, n = xmlTextReaderAttributeCount(reader);
  104|  35.6k|                for (i=0; i<n; i++) {
  ------------------
  |  Branch (104:27): [True: 21.4k, False: 14.2k]
  ------------------
  105|  21.4k|                    xmlTextReaderMoveToAttributeNo(reader, i);
  106|  42.9k|                    while (xmlTextReaderReadAttributeValue(reader) == 1);
  ------------------
  |  Branch (106:28): [True: 21.4k, False: 21.4k]
  ------------------
  107|  21.4k|                }
  108|  14.2k|            }
  109|  36.0k|        }
  110|  3.55k|        for (j = 0; j < 10; j++)
  ------------------
  |  Branch (110:21): [True: 3.23k, False: 323]
  ------------------
  111|  3.23k|            xmlTextReaderRead(reader);
  112|    323|        xmlFreeTextReader(reader);
  113|    323|    }
  114|      0|#endif
  115|       |
  116|    323|exit:
  117|    323|    xmlFuzzMemSetLimit(0);
  118|    323|    xmlFuzzDataCleanup();
  119|    323|    xmlResetLastError();
  120|    323|    return(0);
  121|    323|}

xmlInitGlobalsInternal:
  566|      2|void xmlInitGlobalsInternal(void) {
  567|      2|    xmlInitMutex(&xmlThrDefMutex);
  568|       |
  569|      2|#ifdef HAVE_POSIX_THREADS
  570|      2|#ifdef XML_PTHREAD_WEAK
  571|      2|    if (libxml_is_threaded == -1)
  ------------------
  |  Branch (571:9): [True: 2, False: 0]
  ------------------
  572|      2|        libxml_is_threaded =
  573|      2|            (pthread_getspecific != NULL) &&
  ------------------
  |  Branch (573:13): [True: 2, False: 0]
  ------------------
  574|      2|            (pthread_setspecific != NULL) &&
  ------------------
  |  Branch (574:13): [True: 2, False: 0]
  ------------------
  575|      2|            (pthread_key_create != NULL) &&
  ------------------
  |  Branch (575:13): [True: 2, False: 0]
  ------------------
  576|      2|            (pthread_key_delete != NULL) &&
  ------------------
  |  Branch (576:13): [True: 2, False: 0]
  ------------------
  577|       |            /*
  578|       |             * pthread_equal can be inline, resuting in -Waddress warnings.
  579|       |             * Let's assume it's available if all the other functions are.
  580|       |             */
  581|       |            /* (pthread_equal != NULL) && */
  582|      2|            (pthread_self != NULL);
  ------------------
  |  Branch (582:13): [True: 2, False: 0]
  ------------------
  583|      2|    if (libxml_is_threaded == 0)
  ------------------
  |  Branch (583:9): [True: 0, False: 2]
  ------------------
  584|      0|        return;
  585|      2|#endif /* XML_PTHREAD_WEAK */
  586|      2|    pthread_key_create(&globalkey, xmlFreeGlobalState);
  587|      2|    mainthread = pthread_self();
  588|       |#elif defined(HAVE_WIN32_THREADS)
  589|       |#ifndef USE_TLS
  590|       |    globalkey = TlsAlloc();
  591|       |#endif
  592|       |    mainthread = GetCurrentThreadId();
  593|       |#endif
  594|      2|}
__xmlLastError:
  892|  6.99k|    type *__##name(void) { \
  893|  6.99k|        if (IS_MAIN_THREAD) \
  ------------------
  |  |   62|  6.99k|#define IS_MAIN_THREAD (xmlIsMainThreadInternal())
  |  |  ------------------
  |  |  |  Branch (62:24): [True: 6.99k, False: 0]
  |  |  ------------------
  ------------------
  894|  6.99k|            return (&name); \
  895|  6.99k|        else \
  896|  6.99k|            return (&xmlGetThreadLocalStorage(0)->gs_##name); \
  897|  6.99k|    }
__xmlGenericError:
  892|  2.23k|    type *__##name(void) { \
  893|  2.23k|        if (IS_MAIN_THREAD) \
  ------------------
  |  |   62|  2.23k|#define IS_MAIN_THREAD (xmlIsMainThreadInternal())
  |  |  ------------------
  |  |  |  Branch (62:24): [True: 2.23k, False: 0]
  |  |  ------------------
  ------------------
  894|  2.23k|            return (&name); \
  895|  2.23k|        else \
  896|  2.23k|            return (&xmlGetThreadLocalStorage(0)->gs_##name); \
  897|  2.23k|    }
__xmlGenericErrorContext:
  892|  2.23k|    type *__##name(void) { \
  893|  2.23k|        if (IS_MAIN_THREAD) \
  ------------------
  |  |   62|  2.23k|#define IS_MAIN_THREAD (xmlIsMainThreadInternal())
  |  |  ------------------
  |  |  |  Branch (62:24): [True: 2.23k, False: 0]
  |  |  ------------------
  ------------------
  894|  2.23k|            return (&name); \
  895|  2.23k|        else \
  896|  2.23k|            return (&xmlGetThreadLocalStorage(0)->gs_##name); \
  897|  2.23k|    }
__xmlStructuredError:
  892|  2.67k|    type *__##name(void) { \
  893|  2.67k|        if (IS_MAIN_THREAD) \
  ------------------
  |  |   62|  2.67k|#define IS_MAIN_THREAD (xmlIsMainThreadInternal())
  |  |  ------------------
  |  |  |  Branch (62:24): [True: 2.67k, False: 0]
  |  |  ------------------
  ------------------
  894|  2.67k|            return (&name); \
  895|  2.67k|        else \
  896|  2.67k|            return (&xmlGetThreadLocalStorage(0)->gs_##name); \
  897|  2.67k|    }
__xmlDefaultSAXLocator:
  892|  1.28k|    type *__##name(void) { \
  893|  1.28k|        if (IS_MAIN_THREAD) \
  ------------------
  |  |   62|  1.28k|#define IS_MAIN_THREAD (xmlIsMainThreadInternal())
  |  |  ------------------
  |  |  |  Branch (62:24): [True: 1.28k, False: 0]
  |  |  ------------------
  ------------------
  894|  1.28k|            return (&name); \
  895|  1.28k|        else \
  896|  1.28k|            return (&xmlGetThreadLocalStorage(0)->gs_##name); \
  897|  1.28k|    }
__xmlDoValidityCheckingDefaultValue:
  892|  1.80k|    type *__##name(void) { \
  893|  1.80k|        if (IS_MAIN_THREAD) \
  ------------------
  |  |   62|  1.80k|#define IS_MAIN_THREAD (xmlIsMainThreadInternal())
  |  |  ------------------
  |  |  |  Branch (62:24): [True: 1.80k, False: 0]
  |  |  ------------------
  ------------------
  894|  1.80k|            return (&name); \
  895|  1.80k|        else \
  896|  1.80k|            return (&xmlGetThreadLocalStorage(0)->gs_##name); \
  897|  1.80k|    }
__xmlGetWarningsDefaultValue:
  892|  2.29k|    type *__##name(void) { \
  893|  2.29k|        if (IS_MAIN_THREAD) \
  ------------------
  |  |   62|  2.29k|#define IS_MAIN_THREAD (xmlIsMainThreadInternal())
  |  |  ------------------
  |  |  |  Branch (62:24): [True: 2.29k, False: 0]
  |  |  ------------------
  ------------------
  894|  2.29k|            return (&name); \
  895|  2.29k|        else \
  896|  2.29k|            return (&xmlGetThreadLocalStorage(0)->gs_##name); \
  897|  2.29k|    }
__xmlKeepBlanksDefaultValue:
  892|  1.80k|    type *__##name(void) { \
  893|  1.80k|        if (IS_MAIN_THREAD) \
  ------------------
  |  |   62|  1.80k|#define IS_MAIN_THREAD (xmlIsMainThreadInternal())
  |  |  ------------------
  |  |  |  Branch (62:24): [True: 1.80k, False: 0]
  |  |  ------------------
  ------------------
  894|  1.80k|            return (&name); \
  895|  1.80k|        else \
  896|  1.80k|            return (&xmlGetThreadLocalStorage(0)->gs_##name); \
  897|  1.80k|    }
__xmlLineNumbersDefaultValue:
  892|  1.80k|    type *__##name(void) { \
  893|  1.80k|        if (IS_MAIN_THREAD) \
  ------------------
  |  |   62|  1.80k|#define IS_MAIN_THREAD (xmlIsMainThreadInternal())
  |  |  ------------------
  |  |  |  Branch (62:24): [True: 1.80k, False: 0]
  |  |  ------------------
  ------------------
  894|  1.80k|            return (&name); \
  895|  1.80k|        else \
  896|  1.80k|            return (&xmlGetThreadLocalStorage(0)->gs_##name); \
  897|  1.80k|    }
__xmlLoadExtDtdDefaultValue:
  892|  1.80k|    type *__##name(void) { \
  893|  1.80k|        if (IS_MAIN_THREAD) \
  ------------------
  |  |   62|  1.80k|#define IS_MAIN_THREAD (xmlIsMainThreadInternal())
  |  |  ------------------
  |  |  |  Branch (62:24): [True: 1.80k, False: 0]
  |  |  ------------------
  ------------------
  894|  1.80k|            return (&name); \
  895|  1.80k|        else \
  896|  1.80k|            return (&xmlGetThreadLocalStorage(0)->gs_##name); \
  897|  1.80k|    }
__xmlParserDebugEntities:
  892|   752k|    type *__##name(void) { \
  893|   752k|        if (IS_MAIN_THREAD) \
  ------------------
  |  |   62|   752k|#define IS_MAIN_THREAD (xmlIsMainThreadInternal())
  |  |  ------------------
  |  |  |  Branch (62:24): [True: 752k, False: 0]
  |  |  ------------------
  ------------------
  894|   752k|            return (&name); \
  895|   752k|        else \
  896|   752k|            return (&xmlGetThreadLocalStorage(0)->gs_##name); \
  897|   752k|    }
__xmlPedanticParserDefaultValue:
  892|  1.80k|    type *__##name(void) { \
  893|  1.80k|        if (IS_MAIN_THREAD) \
  ------------------
  |  |   62|  1.80k|#define IS_MAIN_THREAD (xmlIsMainThreadInternal())
  |  |  ------------------
  |  |  |  Branch (62:24): [True: 1.80k, False: 0]
  |  |  ------------------
  ------------------
  894|  1.80k|            return (&name); \
  895|  1.80k|        else \
  896|  1.80k|            return (&xmlGetThreadLocalStorage(0)->gs_##name); \
  897|  1.80k|    }
__xmlSubstituteEntitiesDefaultValue:
  892|  1.80k|    type *__##name(void) { \
  893|  1.80k|        if (IS_MAIN_THREAD) \
  ------------------
  |  |   62|  1.80k|#define IS_MAIN_THREAD (xmlIsMainThreadInternal())
  |  |  ------------------
  |  |  |  Branch (62:24): [True: 1.80k, False: 0]
  |  |  ------------------
  ------------------
  894|  1.80k|            return (&name); \
  895|  1.80k|        else \
  896|  1.80k|            return (&xmlGetThreadLocalStorage(0)->gs_##name); \
  897|  1.80k|    }
__xmlDefaultSAXHandler:
  892|  1.80k|    type *__##name(void) { \
  893|  1.80k|        if (IS_MAIN_THREAD) \
  ------------------
  |  |   62|  1.80k|#define IS_MAIN_THREAD (xmlIsMainThreadInternal())
  |  |  ------------------
  |  |  |  Branch (62:24): [True: 1.80k, False: 0]
  |  |  ------------------
  ------------------
  894|  1.80k|            return (&name); \
  895|  1.80k|        else \
  896|  1.80k|            return (&xmlGetThreadLocalStorage(0)->gs_##name); \
  897|  1.80k|    }
__xmlBufferAllocScheme:
  892|  15.7k|    type *__##name(void) { \
  893|  15.7k|        if (IS_MAIN_THREAD) \
  ------------------
  |  |   62|  15.7k|#define IS_MAIN_THREAD (xmlIsMainThreadInternal())
  |  |  ------------------
  |  |  |  Branch (62:24): [True: 15.7k, False: 0]
  |  |  ------------------
  ------------------
  894|  15.7k|            return (&name); \
  895|  15.7k|        else \
  896|  15.7k|            return (&xmlGetThreadLocalStorage(0)->gs_##name); \
  897|  15.7k|    }
__xmlDefaultBufferSize:
  892|  15.4k|    type *__##name(void) { \
  893|  15.4k|        if (IS_MAIN_THREAD) \
  ------------------
  |  |   62|  15.4k|#define IS_MAIN_THREAD (xmlIsMainThreadInternal())
  |  |  ------------------
  |  |  |  Branch (62:24): [True: 15.4k, False: 0]
  |  |  ------------------
  ------------------
  894|  15.4k|            return (&name); \
  895|  15.4k|        else \
  896|  15.4k|            return (&xmlGetThreadLocalStorage(0)->gs_##name); \
  897|  15.4k|    }
globals.c:xmlPosixStrdup:
  219|    378|xmlPosixStrdup(const char *cur) {
  220|    378|    return((char*) xmlCharStrdup(cur));
  221|    378|}
globals.c:xmlIsMainThreadInternal:
  660|   813k|xmlIsMainThreadInternal(void) {
  661|   813k|    if (parserInitialized == 0) {
  ------------------
  |  Branch (661:9): [True: 2, False: 813k]
  ------------------
  662|      2|        xmlInitParser();
  663|      2|        parserInitialized = 1;
  664|      2|    }
  665|       |
  666|   813k|#ifdef HAVE_POSIX_THREADS
  667|   813k|#ifdef XML_PTHREAD_WEAK
  668|   813k|    if (libxml_is_threaded == 0)
  ------------------
  |  Branch (668:9): [True: 0, False: 813k]
  ------------------
  669|      0|        return (1);
  670|   813k|#endif
  671|   813k|    return (pthread_equal(mainthread, pthread_self()));
  672|       |#elif defined HAVE_WIN32_THREADS
  673|       |    return (mainthread == GetCurrentThreadId());
  674|       |#else
  675|       |    return (1);
  676|       |#endif
  677|   813k|}

xmlHashCreate:
  160|  1.63k|xmlHashCreate(int size) {
  161|  1.63k|    xmlHashTablePtr hash;
  162|       |
  163|  1.63k|    xmlInitParser();
  164|       |
  165|  1.63k|    hash = xmlMalloc(sizeof(*hash));
  166|  1.63k|    if (hash == NULL)
  ------------------
  |  Branch (166:9): [True: 0, False: 1.63k]
  ------------------
  167|      0|        return(NULL);
  168|  1.63k|    hash->dict = NULL;
  169|  1.63k|    hash->size = 0;
  170|  1.63k|    hash->table = NULL;
  171|  1.63k|    hash->nbElems = 0;
  172|  1.63k|    hash->randomSeed = xmlRandom();
  173|  1.63k|#ifdef FUZZING_BUILD_MODE_UNSAFE_FOR_PRODUCTION
  174|  1.63k|    hash->randomSeed = 0;
  175|  1.63k|#endif
  176|       |
  177|       |    /*
  178|       |     * Unless a larger size is passed, the backing table is created
  179|       |     * lazily with MIN_HASH_SIZE capacity. In practice, there are many
  180|       |     * hash tables which are never filled.
  181|       |     */
  182|  1.63k|    if (size > MIN_HASH_SIZE) {
  ------------------
  |  |   30|  1.63k|#define MIN_HASH_SIZE 8
  ------------------
  |  Branch (182:9): [True: 232, False: 1.40k]
  ------------------
  183|    232|        unsigned newSize = MIN_HASH_SIZE * 2;
  ------------------
  |  |   30|    232|#define MIN_HASH_SIZE 8
  ------------------
  184|       |
  185|    232|        while ((newSize < (unsigned) size) && (newSize < MAX_HASH_SIZE))
  ------------------
  |  |   31|      0|#define MAX_HASH_SIZE (1u << 31)
  ------------------
  |  Branch (185:16): [True: 0, False: 232]
  |  Branch (185:47): [True: 0, False: 0]
  ------------------
  186|      0|            newSize *= 2;
  187|       |
  188|    232|        if (xmlHashGrow(hash, newSize) != 0) {
  ------------------
  |  Branch (188:13): [True: 0, False: 232]
  ------------------
  189|      0|            xmlFree(hash);
  190|      0|            return(NULL);
  191|      0|        }
  192|    232|    }
  193|       |
  194|  1.63k|    return(hash);
  195|  1.63k|}
xmlHashCreateDict:
  209|  1.31k|xmlHashCreateDict(int size, xmlDictPtr dict) {
  210|  1.31k|    xmlHashTablePtr hash;
  211|       |
  212|  1.31k|    hash = xmlHashCreate(size);
  213|  1.31k|    if (hash != NULL) {
  ------------------
  |  Branch (213:9): [True: 1.31k, False: 0]
  ------------------
  214|  1.31k|        hash->dict = dict;
  215|  1.31k|        xmlDictReference(dict);
  216|  1.31k|    }
  217|  1.31k|    return(hash);
  218|  1.31k|}
xmlHashFree:
  229|  1.63k|xmlHashFree(xmlHashTablePtr hash, xmlHashDeallocator dealloc) {
  230|  1.63k|    if (hash == NULL)
  ------------------
  |  Branch (230:9): [True: 0, False: 1.63k]
  ------------------
  231|      0|        return;
  232|       |
  233|  1.63k|    if (hash->table) {
  ------------------
  |  Branch (233:9): [True: 1.63k, False: 0]
  ------------------
  234|  1.63k|        const xmlHashEntry *end = &hash->table[hash->size];
  235|  1.63k|        const xmlHashEntry *entry;
  236|       |
  237|  55.5k|        for (entry = hash->table; entry < end; entry++) {
  ------------------
  |  Branch (237:35): [True: 53.9k, False: 1.63k]
  ------------------
  238|  53.9k|            if (entry->hashValue == 0)
  ------------------
  |  Branch (238:17): [True: 32.2k, False: 21.7k]
  ------------------
  239|  32.2k|                continue;
  240|  21.7k|            if ((dealloc != NULL) && (entry->payload != NULL))
  ------------------
  |  Branch (240:17): [True: 16.5k, False: 5.17k]
  |  Branch (240:38): [True: 16.5k, False: 0]
  ------------------
  241|  16.5k|                dealloc(entry->payload, entry->key);
  242|  21.7k|            if (hash->dict == NULL) {
  ------------------
  |  Branch (242:17): [True: 363, False: 21.3k]
  ------------------
  243|    363|                if (entry->key)
  ------------------
  |  Branch (243:21): [True: 363, False: 0]
  ------------------
  244|    363|                    xmlFree(entry->key);
  245|    363|                if (entry->key2)
  ------------------
  |  Branch (245:21): [True: 0, False: 363]
  ------------------
  246|      0|                    xmlFree(entry->key2);
  247|    363|                if (entry->key3)
  ------------------
  |  Branch (247:21): [True: 0, False: 363]
  ------------------
  248|      0|                    xmlFree(entry->key3);
  249|    363|            }
  250|  21.7k|        }
  251|       |
  252|  1.63k|        xmlFree(hash->table);
  253|  1.63k|    }
  254|       |
  255|  1.63k|    if (hash->dict)
  ------------------
  |  Branch (255:9): [True: 1.31k, False: 323]
  ------------------
  256|  1.31k|        xmlDictFree(hash->dict);
  257|       |
  258|  1.63k|    xmlFree(hash);
  259|  1.63k|}
xmlHashDefaultDeallocator:
  603|    587|xmlHashDefaultDeallocator(void *entry, const xmlChar *key ATTRIBUTE_UNUSED) {
  604|    587|    xmlFree(entry);
  605|    587|}
xmlHashAddEntry:
  621|  5.45k|xmlHashAddEntry(xmlHashTablePtr hash, const xmlChar *key, void *payload) {
  622|  5.45k|    return(xmlHashUpdateInternal(hash, key, NULL, NULL, payload, NULL, 0));
  623|  5.45k|}
xmlHashAddEntry2:
  640|  10.9k|                 const xmlChar *key2, void *payload) {
  641|  10.9k|    return(xmlHashUpdateInternal(hash, key, key2, NULL, payload, NULL, 0));
  642|  10.9k|}
xmlHashAddEntry3:
  661|  7.78k|                 void *payload) {
  662|  7.78k|    return(xmlHashUpdateInternal(hash, key, key2, key3, payload, NULL, 0));
  663|  7.78k|}
xmlHashUpdateEntry2:
  701|    256|                   xmlHashDeallocator dealloc) {
  702|    256|    return(xmlHashUpdateInternal(hash, key, key2, NULL, payload,
  703|    256|                                 dealloc, 1));
  704|    256|}
xmlHashLookup:
  739|   383k|xmlHashLookup(xmlHashTablePtr hash, const xmlChar *key) {
  740|   383k|    return(xmlHashLookup3(hash, key, NULL, NULL));
  741|   383k|}
xmlHashLookup2:
  755|  70.6k|              const xmlChar *key2) {
  756|  70.6k|    return(xmlHashLookup3(hash, key, key2, NULL));
  757|  70.6k|}
xmlHashQLookup2:
  790|  5.83k|                const xmlChar *name2) {
  791|  5.83k|    return(xmlHashQLookup3(hash, prefix, name, prefix2, name2, NULL, NULL));
  792|  5.83k|}
xmlHashLookup3:
  807|   464k|               const xmlChar *key2, const xmlChar *key3) {
  808|   464k|    const xmlHashEntry *entry;
  809|   464k|    unsigned hashValue;
  810|   464k|    int found;
  811|       |
  812|   464k|    if ((hash == NULL) || (hash->size == 0) || (key == NULL))
  ------------------
  |  Branch (812:9): [True: 1.00k, False: 463k]
  |  Branch (812:27): [True: 1.20k, False: 462k]
  |  Branch (812:48): [True: 0, False: 462k]
  ------------------
  813|  2.21k|        return(NULL);
  814|   462k|    hashValue = xmlHashValue(hash->randomSeed, key, key2, key3, NULL);
  815|   462k|    entry = xmlHashFindEntry(hash, key, key2, key3, hashValue, &found);
  816|   462k|    if (found)
  ------------------
  |  Branch (816:9): [True: 420k, False: 41.1k]
  ------------------
  817|   420k|        return(entry->payload);
  818|  41.1k|    return(NULL);
  819|   462k|}
xmlHashQLookup3:
  840|  5.83k|                const xmlChar *prefix3, const xmlChar *name3) {
  841|  5.83k|    const xmlHashEntry *entry;
  842|  5.83k|    unsigned hashValue, mask, pos, displ;
  843|       |
  844|  5.83k|    if ((hash == NULL) || (hash->size == 0) || (name == NULL))
  ------------------
  |  Branch (844:9): [True: 0, False: 5.83k]
  |  Branch (844:27): [True: 0, False: 5.83k]
  |  Branch (844:48): [True: 0, False: 5.83k]
  ------------------
  845|      0|        return(NULL);
  846|       |
  847|  5.83k|    hashValue = xmlHashQNameValue(hash->randomSeed, prefix, name, prefix2,
  848|  5.83k|                                  name2, prefix3, name3);
  849|  5.83k|    mask = hash->size - 1;
  850|  5.83k|    pos = hashValue & mask;
  851|  5.83k|    entry = &hash->table[pos];
  852|       |
  853|  5.83k|    if (entry->hashValue != 0) {
  ------------------
  |  Branch (853:9): [True: 5.01k, False: 820]
  ------------------
  854|  5.01k|        displ = 0;
  855|  5.01k|        hashValue |= MAX_HASH_SIZE;
  ------------------
  |  |   31|  5.01k|#define MAX_HASH_SIZE (1u << 31)
  ------------------
  856|       |
  857|  6.50k|        do {
  858|  6.50k|            if ((hashValue == entry->hashValue) &&
  ------------------
  |  Branch (858:17): [True: 4.27k, False: 2.23k]
  ------------------
  859|  6.50k|                (xmlStrQEqual(prefix, name, entry->key)) &&
  ------------------
  |  Branch (859:17): [True: 4.27k, False: 0]
  ------------------
  860|  6.50k|                (xmlStrQEqual(prefix2, name2, entry->key2)) &&
  ------------------
  |  Branch (860:17): [True: 4.27k, False: 0]
  ------------------
  861|  6.50k|                (xmlStrQEqual(prefix3, name3, entry->key3)))
  ------------------
  |  Branch (861:17): [True: 4.27k, False: 0]
  ------------------
  862|  4.27k|                return(entry->payload);
  863|       |
  864|  2.23k|            displ++;
  865|  2.23k|            pos++;
  866|  2.23k|            entry++;
  867|  2.23k|            if ((pos & mask) == 0)
  ------------------
  |  Branch (867:17): [True: 0, False: 2.23k]
  ------------------
  868|      0|                entry = hash->table;
  869|  2.23k|        } while ((entry->hashValue != 0) &&
  ------------------
  |  Branch (869:18): [True: 2.03k, False: 200]
  ------------------
  870|  2.23k|                 (((pos - entry->hashValue) & mask) >= displ));
  ------------------
  |  Branch (870:18): [True: 1.49k, False: 540]
  ------------------
  871|  5.01k|    }
  872|       |
  873|  1.56k|    return(NULL);
  874|  5.83k|}
xmlHashScan:
  898|    833|xmlHashScan(xmlHashTablePtr hash, xmlHashScanner scan, void *data) {
  899|    833|    stubData sdata;
  900|    833|    sdata.data = data;
  901|    833|    sdata.scan = scan;
  902|    833|    xmlHashScanFull(hash, stubHashScannerFull, &sdata);
  903|    833|}
xmlHashScanFull:
  914|    993|xmlHashScanFull(xmlHashTablePtr hash, xmlHashScannerFull scan, void *data) {
  915|    993|    const xmlHashEntry *entry, *end;
  916|       |
  917|    993|    if ((hash == NULL) || (hash->size == 0) || (scan == NULL))
  ------------------
  |  Branch (917:9): [True: 456, False: 537]
  |  Branch (917:27): [True: 0, False: 537]
  |  Branch (917:48): [True: 0, False: 537]
  ------------------
  918|    456|        return;
  919|       |
  920|    537|    end = &hash->table[hash->size];
  921|       |
  922|  36.0k|    for (entry = hash->table; entry < end; entry++) {
  ------------------
  |  Branch (922:31): [True: 35.4k, False: 537]
  ------------------
  923|  35.4k|        if ((entry->hashValue != 0) && (entry->payload != NULL))
  ------------------
  |  Branch (923:13): [True: 16.4k, False: 19.0k]
  |  Branch (923:40): [True: 16.4k, False: 0]
  ------------------
  924|  16.4k|            scan(entry->payload, data, entry->key, entry->key2, entry->key3);
  925|  35.4k|    }
  926|    537|}
xmlHashScan3:
  944|    894|             xmlHashScanner scan, void *data) {
  945|    894|    stubData sdata;
  946|    894|    sdata.data = data;
  947|    894|    sdata.scan = scan;
  948|    894|    xmlHashScanFull3(hash, key, key2, key3, stubHashScannerFull, &sdata);
  949|    894|}
xmlHashScanFull3:
  967|    894|                 xmlHashScannerFull scan, void *data) {
  968|    894|    const xmlHashEntry *entry, *end;
  969|       |
  970|    894|    if ((hash == NULL) || (hash->size == 0) || (scan == NULL))
  ------------------
  |  Branch (970:9): [True: 558, False: 336]
  |  Branch (970:27): [True: 0, False: 336]
  |  Branch (970:48): [True: 0, False: 336]
  ------------------
  971|    558|        return;
  972|       |
  973|    336|    end = &hash->table[hash->size];
  974|       |
  975|   341k|    for (entry = hash->table; entry < end; entry++) {
  ------------------
  |  Branch (975:31): [True: 341k, False: 336]
  ------------------
  976|   341k|        if (entry->hashValue == 0)
  ------------------
  |  Branch (976:13): [True: 170k, False: 170k]
  ------------------
  977|   170k|            continue;
  978|   170k|        if (((key == NULL) ||
  ------------------
  |  Branch (978:14): [True: 170k, False: 0]
  ------------------
  979|   170k|             (strcmp((const char *) key, (const char *) entry->key) == 0)) &&
  ------------------
  |  Branch (979:14): [True: 0, False: 0]
  ------------------
  980|   170k|            ((key2 == NULL) || (xmlFastStrEqual(key2, entry->key2))) &&
  ------------------
  |  Branch (980:14): [True: 170k, False: 0]
  |  Branch (980:32): [True: 0, False: 0]
  ------------------
  981|   170k|            ((key3 == NULL) || (xmlFastStrEqual(key3, entry->key3))) &&
  ------------------
  |  Branch (981:14): [True: 0, False: 170k]
  |  Branch (981:32): [True: 3, False: 170k]
  ------------------
  982|   170k|            (entry->payload != NULL)) {
  ------------------
  |  Branch (982:13): [True: 3, False: 0]
  ------------------
  983|      3|            scan(entry->payload, data, entry->key, entry->key2, entry->key3);
  984|      3|        }
  985|   170k|    }
  986|    336|}
xmlHashSize:
 1033|    160|xmlHashSize(xmlHashTablePtr hash) {
 1034|    160|    if (hash == NULL)
  ------------------
  |  Branch (1034:9): [True: 0, False: 160]
  ------------------
 1035|      0|        return(-1);
 1036|    160|    return(hash->nbElems);
 1037|    160|}
xmlHashRemoveEntry2:
 1070|  2.61k|                    const xmlChar *key2, xmlHashDeallocator dealloc) {
 1071|  2.61k|    return(xmlHashRemoveEntry3(hash, key, key2, NULL, dealloc));
 1072|  2.61k|}
xmlHashRemoveEntry3:
 1092|  2.61k|                    xmlHashDeallocator dealloc) {
 1093|  2.61k|    xmlHashEntry *entry, *cur, *next;
 1094|  2.61k|    unsigned hashValue, mask, pos, nextpos;
 1095|  2.61k|    int found;
 1096|       |
 1097|  2.61k|    if ((hash == NULL) || (hash->size == 0) || (key == NULL))
  ------------------
  |  Branch (1097:9): [True: 0, False: 2.61k]
  |  Branch (1097:27): [True: 0, False: 2.61k]
  |  Branch (1097:48): [True: 0, False: 2.61k]
  ------------------
 1098|      0|        return(-1);
 1099|       |
 1100|  2.61k|    hashValue = xmlHashValue(hash->randomSeed, key, key2, key3, NULL);
 1101|  2.61k|    entry = xmlHashFindEntry(hash, key, key2, key3, hashValue, &found);
 1102|  2.61k|    if (!found)
  ------------------
  |  Branch (1102:9): [True: 0, False: 2.61k]
  ------------------
 1103|      0|        return(-1);
 1104|       |
 1105|  2.61k|    if ((dealloc != NULL) && (entry->payload != NULL))
  ------------------
  |  Branch (1105:9): [True: 0, False: 2.61k]
  |  Branch (1105:30): [True: 0, False: 0]
  ------------------
 1106|      0|        dealloc(entry->payload, entry->key);
 1107|  2.61k|    if (hash->dict == NULL) {
  ------------------
  |  Branch (1107:9): [True: 0, False: 2.61k]
  ------------------
 1108|      0|        if (entry->key)
  ------------------
  |  Branch (1108:13): [True: 0, False: 0]
  ------------------
 1109|      0|            xmlFree(entry->key);
 1110|      0|        if (entry->key2)
  ------------------
  |  Branch (1110:13): [True: 0, False: 0]
  ------------------
 1111|      0|            xmlFree(entry->key2);
 1112|      0|        if (entry->key3)
  ------------------
  |  Branch (1112:13): [True: 0, False: 0]
  ------------------
 1113|      0|            xmlFree(entry->key3);
 1114|      0|    }
 1115|       |
 1116|       |    /*
 1117|       |     * Find end of probe sequence. Entries at their initial probe
 1118|       |     * position start a new sequence.
 1119|       |     */
 1120|  2.61k|    mask = hash->size - 1;
 1121|  2.61k|    pos = entry - hash->table;
 1122|  2.61k|    cur = entry;
 1123|       |
 1124|  4.28k|    while (1) {
  ------------------
  |  Branch (1124:12): [Folded - Ignored]
  ------------------
 1125|  4.28k|        nextpos = pos + 1;
 1126|  4.28k|        next = cur + 1;
 1127|  4.28k|        if ((nextpos & mask) == 0)
  ------------------
  |  Branch (1127:13): [True: 16, False: 4.27k]
  ------------------
 1128|     16|            next = hash->table;
 1129|       |
 1130|  4.28k|        if ((next->hashValue == 0) ||
  ------------------
  |  Branch (1130:13): [True: 1.66k, False: 2.62k]
  ------------------
 1131|  4.28k|            (((next->hashValue - nextpos) & mask) == 0))
  ------------------
  |  Branch (1131:13): [True: 956, False: 1.67k]
  ------------------
 1132|  2.61k|            break;
 1133|       |
 1134|  1.67k|        cur = next;
 1135|  1.67k|        pos = nextpos;
 1136|  1.67k|    }
 1137|       |
 1138|       |    /*
 1139|       |     * Backward shift
 1140|       |     */
 1141|  2.61k|    next = entry + 1;
 1142|       |
 1143|  2.61k|    if (cur < entry) {
  ------------------
  |  Branch (1143:9): [True: 4, False: 2.61k]
  ------------------
 1144|      4|        xmlHashEntry *end = &hash->table[hash->size];
 1145|       |
 1146|      4|        memmove(entry, next, (char *) end - (char *) next);
 1147|      4|        entry = hash->table;
 1148|      4|        end[-1] = *entry;
 1149|      4|        next = entry + 1;
 1150|      4|    }
 1151|       |
 1152|  2.61k|    memmove(entry, next, (char *) cur - (char *) entry);
 1153|       |
 1154|       |    /*
 1155|       |     * Update entry
 1156|       |     */
 1157|  2.61k|    cur->hashValue = 0;
 1158|       |
 1159|  2.61k|    hash->nbElems--;
 1160|       |
 1161|  2.61k|    return(0);
 1162|  2.61k|}
hash.c:xmlHashGrow:
  354|  2.18k|xmlHashGrow(xmlHashTablePtr hash, unsigned size) {
  355|  2.18k|    const xmlHashEntry *oldentry, *oldend, *end;
  356|  2.18k|    xmlHashEntry *table;
  357|  2.18k|    unsigned oldsize, i;
  358|       |
  359|       |    /* Add 0 to avoid spurious -Wtype-limits warning on 64-bit GCC */
  360|  2.18k|    if ((size_t) size + 0 > SIZE_MAX / sizeof(table[0]))
  ------------------
  |  |   25|  2.18k|  #define SIZE_MAX ((size_t) -1)
  ------------------
  |  Branch (360:9): [True: 0, False: 2.18k]
  ------------------
  361|      0|        return(-1);
  362|  2.18k|    table = xmlMalloc(size * sizeof(table[0]));
  363|  2.18k|    if (table == NULL)
  ------------------
  |  Branch (363:9): [True: 0, False: 2.18k]
  ------------------
  364|      0|        return(-1);
  365|  2.18k|    memset(table, 0, size * sizeof(table[0]));
  366|       |
  367|  2.18k|    oldsize = hash->size;
  368|  2.18k|    if (oldsize == 0)
  ------------------
  |  Branch (368:9): [True: 1.63k, False: 548]
  ------------------
  369|  1.63k|        goto done;
  370|       |
  371|    548|    oldend = &hash->table[oldsize];
  372|    548|    end = &table[size];
  373|       |
  374|       |    /*
  375|       |     * Robin Hood sorting order is maintained if we
  376|       |     *
  377|       |     * - compute hash indices with modulo
  378|       |     * - resize by an integer factor
  379|       |     * - start to copy from the beginning of a probe sequence
  380|       |     */
  381|    548|    oldentry = hash->table;
  382|  3.78k|    while (oldentry->hashValue != 0) {
  ------------------
  |  Branch (382:12): [True: 3.24k, False: 548]
  ------------------
  383|  3.24k|        if (++oldentry >= oldend)
  ------------------
  |  Branch (383:13): [True: 0, False: 3.24k]
  ------------------
  384|      0|            oldentry = hash->table;
  385|  3.24k|    }
  386|       |
  387|  39.5k|    for (i = 0; i < oldsize; i++) {
  ------------------
  |  Branch (387:17): [True: 38.9k, False: 548]
  ------------------
  388|  38.9k|        if (oldentry->hashValue != 0) {
  ------------------
  |  Branch (388:13): [True: 34.1k, False: 4.87k]
  ------------------
  389|  34.1k|            xmlHashEntry *entry = &table[oldentry->hashValue & (size - 1)];
  390|       |
  391|  46.2k|            while (entry->hashValue != 0) {
  ------------------
  |  Branch (391:20): [True: 12.1k, False: 34.1k]
  ------------------
  392|  12.1k|                if (++entry >= end)
  ------------------
  |  Branch (392:21): [True: 90, False: 12.0k]
  ------------------
  393|     90|                    entry = table;
  394|  12.1k|            }
  395|  34.1k|            *entry = *oldentry;
  396|  34.1k|        }
  397|       |
  398|  38.9k|        if (++oldentry >= oldend)
  ------------------
  |  Branch (398:13): [True: 548, False: 38.4k]
  ------------------
  399|    548|            oldentry = hash->table;
  400|  38.9k|    }
  401|       |
  402|    548|    xmlFree(hash->table);
  403|       |
  404|  2.18k|done:
  405|  2.18k|    hash->table = table;
  406|  2.18k|    hash->size = size;
  407|       |
  408|  2.18k|    return(0);
  409|    548|}
hash.c:xmlHashUpdateInternal:
  427|  24.4k|                      void *payload, xmlHashDeallocator dealloc, int update) {
  428|  24.4k|    xmlChar *copy, *copy2, *copy3;
  429|  24.4k|    xmlHashEntry *entry = NULL;
  430|  24.4k|    size_t lengths[3];
  431|  24.4k|    unsigned hashValue;
  432|  24.4k|    int found = 0;
  433|       |
  434|  24.4k|    if ((hash == NULL) || (key == NULL))
  ------------------
  |  Branch (434:9): [True: 0, False: 24.4k]
  |  Branch (434:27): [True: 0, False: 24.4k]
  ------------------
  435|      0|        return(-1);
  436|       |
  437|       |    /*
  438|       |     * Check for an existing entry
  439|       |     */
  440|  24.4k|    hashValue = xmlHashValue(hash->randomSeed, key, key2, key3, lengths);
  441|  24.4k|    if (hash->size > 0)
  ------------------
  |  Branch (441:9): [True: 23.0k, False: 1.40k]
  ------------------
  442|  23.0k|        entry = xmlHashFindEntry(hash, key, key2, key3, hashValue, &found);
  443|  24.4k|    if (found) {
  ------------------
  |  Branch (443:9): [True: 60, False: 24.3k]
  ------------------
  444|     60|        if (update) {
  ------------------
  |  Branch (444:13): [True: 32, False: 28]
  ------------------
  445|     32|            if (dealloc)
  ------------------
  |  Branch (445:17): [True: 0, False: 32]
  ------------------
  446|      0|                dealloc(entry->payload, entry->key);
  447|     32|            entry->payload = payload;
  448|     32|            return(0);
  449|     32|        } else {
  450|       |            /*
  451|       |             * xmlHashAddEntry found an existing entry.
  452|       |             *
  453|       |             * TODO: We should return a different error code here to
  454|       |             * distinguish from malloc failures.
  455|       |             */
  456|     28|            return(-1);
  457|     28|        }
  458|     60|    }
  459|       |
  460|       |    /*
  461|       |     * Grow the hash table if needed
  462|       |     */
  463|  24.3k|    if (hash->nbElems + 1 > hash->size / MAX_FILL_DENOM * MAX_FILL_NUM) {
  ------------------
  |  |   29|  24.3k|#define MAX_FILL_DENOM 8
  ------------------
                  if (hash->nbElems + 1 > hash->size / MAX_FILL_DENOM * MAX_FILL_NUM) {
  ------------------
  |  |   28|  24.3k|#define MAX_FILL_NUM 7
  ------------------
  |  Branch (463:9): [True: 1.95k, False: 22.3k]
  ------------------
  464|  1.95k|        unsigned newSize, mask, displ, pos;
  465|       |
  466|  1.95k|        if (hash->size == 0) {
  ------------------
  |  Branch (466:13): [True: 1.40k, False: 548]
  ------------------
  467|  1.40k|            newSize = MIN_HASH_SIZE;
  ------------------
  |  |   30|  1.40k|#define MIN_HASH_SIZE 8
  ------------------
  468|  1.40k|        } else {
  469|       |            /* This guarantees that nbElems < INT_MAX */
  470|    548|            if (hash->size >= MAX_HASH_SIZE)
  ------------------
  |  |   31|    548|#define MAX_HASH_SIZE (1u << 31)
  ------------------
  |  Branch (470:17): [True: 0, False: 548]
  ------------------
  471|      0|                return(-1);
  472|    548|            newSize = hash->size * 2;
  473|    548|        }
  474|  1.95k|        if (xmlHashGrow(hash, newSize) != 0)
  ------------------
  |  Branch (474:13): [True: 0, False: 1.95k]
  ------------------
  475|      0|            return(-1);
  476|       |
  477|       |        /*
  478|       |         * Find new entry
  479|       |         */
  480|  1.95k|        mask = hash->size - 1;
  481|  1.95k|        displ = 0;
  482|  1.95k|        pos = hashValue & mask;
  483|  1.95k|        entry = &hash->table[pos];
  484|       |
  485|  1.95k|        if (entry->hashValue != 0) {
  ------------------
  |  Branch (485:13): [True: 245, False: 1.70k]
  ------------------
  486|    310|            do {
  487|    310|                displ++;
  488|    310|                pos++;
  489|    310|                entry++;
  490|    310|                if ((pos & mask) == 0)
  ------------------
  |  Branch (490:21): [True: 16, False: 294]
  ------------------
  491|     16|                    entry = hash->table;
  492|    310|            } while ((entry->hashValue != 0) &&
  ------------------
  |  Branch (492:22): [True: 167, False: 143]
  ------------------
  493|    310|                     ((pos - entry->hashValue) & mask) >= displ);
  ------------------
  |  Branch (493:22): [True: 65, False: 102]
  ------------------
  494|    245|        }
  495|  1.95k|    }
  496|       |
  497|       |    /*
  498|       |     * Copy keys
  499|       |     */
  500|  24.3k|    if (hash->dict != NULL) {
  ------------------
  |  Branch (500:9): [True: 23.9k, False: 363]
  ------------------
  501|  23.9k|        if (xmlDictOwns(hash->dict, key)) {
  ------------------
  |  Branch (501:13): [True: 21.1k, False: 2.81k]
  ------------------
  502|  21.1k|            copy = (xmlChar *) key;
  503|  21.1k|        } else {
  504|  2.81k|            copy = (xmlChar *) xmlDictLookup(hash->dict, key, -1);
  505|  2.81k|            if (copy == NULL)
  ------------------
  |  Branch (505:17): [True: 0, False: 2.81k]
  ------------------
  506|      0|                return(-1);
  507|  2.81k|        }
  508|       |
  509|  23.9k|        if ((key2 == NULL) || (xmlDictOwns(hash->dict, key2))) {
  ------------------
  |  Branch (509:13): [True: 15.7k, False: 8.21k]
  |  Branch (509:31): [True: 8.10k, False: 108]
  ------------------
  510|  23.8k|            copy2 = (xmlChar *) key2;
  511|  23.8k|        } else {
  512|    108|            copy2 = (xmlChar *) xmlDictLookup(hash->dict, key2, -1);
  513|    108|            if (copy2 == NULL)
  ------------------
  |  Branch (513:17): [True: 0, False: 108]
  ------------------
  514|      0|                return(-1);
  515|    108|        }
  516|  23.9k|        if ((key3 == NULL) || (xmlDictOwns(hash->dict, key3))) {
  ------------------
  |  Branch (516:13): [True: 16.2k, False: 7.77k]
  |  Branch (516:31): [True: 7.77k, False: 0]
  ------------------
  517|  23.9k|            copy3 = (xmlChar *) key3;
  518|  23.9k|        } else {
  519|      0|            copy3 = (xmlChar *) xmlDictLookup(hash->dict, key3, -1);
  520|      0|            if (copy3 == NULL)
  ------------------
  |  Branch (520:17): [True: 0, False: 0]
  ------------------
  521|      0|                return(-1);
  522|      0|        }
  523|  23.9k|    } else {
  524|    363|        copy = xmlMalloc(lengths[0] + 1);
  525|    363|        if (copy == NULL)
  ------------------
  |  Branch (525:13): [True: 0, False: 363]
  ------------------
  526|      0|            return(-1);
  527|    363|        memcpy(copy, key, lengths[0] + 1);
  528|       |
  529|    363|        if (key2 != NULL) {
  ------------------
  |  Branch (529:13): [True: 0, False: 363]
  ------------------
  530|      0|            copy2 = xmlMalloc(lengths[1] + 1);
  531|      0|            if (copy2 == NULL) {
  ------------------
  |  Branch (531:17): [True: 0, False: 0]
  ------------------
  532|      0|                xmlFree(copy);
  533|      0|                return(-1);
  534|      0|            }
  535|      0|            memcpy(copy2, key2, lengths[1] + 1);
  536|    363|        } else {
  537|    363|            copy2 = NULL;
  538|    363|        }
  539|       |
  540|    363|        if (key3 != NULL) {
  ------------------
  |  Branch (540:13): [True: 0, False: 363]
  ------------------
  541|      0|            copy3 = xmlMalloc(lengths[2] + 1);
  542|      0|            if (copy3 == NULL) {
  ------------------
  |  Branch (542:17): [True: 0, False: 0]
  ------------------
  543|      0|                xmlFree(copy);
  544|      0|                xmlFree(copy2);
  545|      0|                return(-1);
  546|      0|            }
  547|      0|            memcpy(copy3, key3, lengths[2] + 1);
  548|    363|        } else {
  549|    363|            copy3 = NULL;
  550|    363|        }
  551|    363|    }
  552|       |
  553|       |    /*
  554|       |     * Shift the remainder of the probe sequence to the right
  555|       |     */
  556|  24.3k|    if (entry->hashValue != 0) {
  ------------------
  |  Branch (556:9): [True: 8.45k, False: 15.8k]
  ------------------
  557|  8.45k|        const xmlHashEntry *end = &hash->table[hash->size];
  558|  8.45k|        const xmlHashEntry *cur = entry;
  559|       |
  560|  55.1k|        do {
  561|  55.1k|            cur++;
  562|  55.1k|            if (cur >= end)
  ------------------
  |  Branch (562:17): [True: 349, False: 54.7k]
  ------------------
  563|    349|                cur = hash->table;
  564|  55.1k|        } while (cur->hashValue != 0);
  ------------------
  |  Branch (564:18): [True: 46.6k, False: 8.45k]
  ------------------
  565|       |
  566|  8.45k|        if (cur < entry) {
  ------------------
  |  Branch (566:13): [True: 349, False: 8.10k]
  ------------------
  567|       |            /*
  568|       |             * If we traversed the end of the buffer, handle the part
  569|       |             * at the start of the buffer.
  570|       |             */
  571|    349|            memmove(&hash->table[1], hash->table,
  572|    349|                    (char *) cur - (char *) hash->table);
  573|    349|            cur = end - 1;
  574|    349|            hash->table[0] = *cur;
  575|    349|        }
  576|       |
  577|  8.45k|        memmove(&entry[1], entry, (char *) cur - (char *) entry);
  578|  8.45k|    }
  579|       |
  580|       |    /*
  581|       |     * Populate entry
  582|       |     */
  583|  24.3k|    entry->key = copy;
  584|  24.3k|    entry->key2 = copy2;
  585|  24.3k|    entry->key3 = copy3;
  586|  24.3k|    entry->payload = payload;
  587|       |    /* OR with MAX_HASH_SIZE to make sure that the value is non-zero */
  588|  24.3k|    entry->hashValue = hashValue | MAX_HASH_SIZE;
  ------------------
  |  |   31|  24.3k|#define MAX_HASH_SIZE (1u << 31)
  ------------------
  589|       |
  590|  24.3k|    hash->nbElems++;
  591|       |
  592|  24.3k|    return(0);
  593|  24.3k|}
hash.c:xmlHashValue:
   62|   489k|             const xmlChar *key3, size_t *lengths) {
   63|   489k|    unsigned h1, h2;
   64|   489k|    size_t i;
   65|       |
   66|   489k|    HASH_INIT(h1, h2, seed);
  ------------------
  |  |   23|   489k|    do { \
  |  |   24|   489k|        h1 = seed ^ 0x3b00; \
  |  |   25|   489k|        h2 = HASH_ROL(seed, 15); \
  |  |  ------------------
  |  |  |  |   12|   489k|#define HASH_ROL(x,n) ((x) << (n) | ((x) & 0xFFFFFFFF) >> (32 - (n)))
  |  |  ------------------
  |  |   26|   489k|    } while (0)
  |  |  ------------------
  |  |  |  Branch (26:14): [Folded - Ignored]
  |  |  ------------------
  ------------------
   67|       |
   68|  6.32M|    for (i = 0; key[i] != 0; i++) {
  ------------------
  |  Branch (68:17): [True: 5.83M, False: 489k]
  ------------------
   69|  5.83M|        HASH_UPDATE(h1, h2, key[i]);
  ------------------
  |  |   29|  5.83M|    do { \
  |  |   30|  5.83M|        h1 += ch; \
  |  |   31|  5.83M|        h1 += h1 << 3; \
  |  |   32|  5.83M|        h2 += h1; \
  |  |   33|  5.83M|        h2 = HASH_ROL(h2, 7); \
  |  |  ------------------
  |  |  |  |   12|  5.83M|#define HASH_ROL(x,n) ((x) << (n) | ((x) & 0xFFFFFFFF) >> (32 - (n)))
  |  |  ------------------
  |  |   34|  5.83M|        h2 += h2 << 2; \
  |  |   35|  5.83M|    } while (0)
  |  |  ------------------
  |  |  |  Branch (35:14): [Folded - Ignored]
  |  |  ------------------
  ------------------
   70|  5.83M|    }
   71|   489k|    if (lengths)
  ------------------
  |  Branch (71:9): [True: 24.4k, False: 464k]
  ------------------
   72|  24.4k|        lengths[0] = i;
   73|       |
   74|   489k|    HASH_UPDATE(h1, h2, 0);
  ------------------
  |  |   29|   489k|    do { \
  |  |   30|   489k|        h1 += ch; \
  |  |   31|   489k|        h1 += h1 << 3; \
  |  |   32|   489k|        h2 += h1; \
  |  |   33|   489k|        h2 = HASH_ROL(h2, 7); \
  |  |  ------------------
  |  |  |  |   12|   489k|#define HASH_ROL(x,n) ((x) << (n) | ((x) & 0xFFFFFFFF) >> (32 - (n)))
  |  |  ------------------
  |  |   34|   489k|        h2 += h2 << 2; \
  |  |   35|   489k|    } while (0)
  |  |  ------------------
  |  |  |  Branch (35:14): [Folded - Ignored]
  |  |  ------------------
  ------------------
   75|       |
   76|   489k|    if (key2 != NULL) {
  ------------------
  |  Branch (76:9): [True: 21.9k, False: 467k]
  ------------------
   77|   132k|        for (i = 0; key2[i] != 0; i++) {
  ------------------
  |  Branch (77:21): [True: 110k, False: 21.9k]
  ------------------
   78|   110k|            HASH_UPDATE(h1, h2, key2[i]);
  ------------------
  |  |   29|   110k|    do { \
  |  |   30|   110k|        h1 += ch; \
  |  |   31|   110k|        h1 += h1 << 3; \
  |  |   32|   110k|        h2 += h1; \
  |  |   33|   110k|        h2 = HASH_ROL(h2, 7); \
  |  |  ------------------
  |  |  |  |   12|   110k|#define HASH_ROL(x,n) ((x) << (n) | ((x) & 0xFFFFFFFF) >> (32 - (n)))
  |  |  ------------------
  |  |   34|   110k|        h2 += h2 << 2; \
  |  |   35|   110k|    } while (0)
  |  |  ------------------
  |  |  |  Branch (35:14): [Folded - Ignored]
  |  |  ------------------
  ------------------
   79|   110k|        }
   80|  21.9k|        if (lengths)
  ------------------
  |  Branch (80:13): [True: 8.21k, False: 13.7k]
  ------------------
   81|  8.21k|            lengths[1] = i;
   82|  21.9k|    }
   83|       |
   84|   489k|    HASH_UPDATE(h1, h2, 0);
  ------------------
  |  |   29|   489k|    do { \
  |  |   30|   489k|        h1 += ch; \
  |  |   31|   489k|        h1 += h1 << 3; \
  |  |   32|   489k|        h2 += h1; \
  |  |   33|   489k|        h2 = HASH_ROL(h2, 7); \
  |  |  ------------------
  |  |  |  |   12|   489k|#define HASH_ROL(x,n) ((x) << (n) | ((x) & 0xFFFFFFFF) >> (32 - (n)))
  |  |  ------------------
  |  |   34|   489k|        h2 += h2 << 2; \
  |  |   35|   489k|    } while (0)
  |  |  ------------------
  |  |  |  Branch (35:14): [Folded - Ignored]
  |  |  ------------------
  ------------------
   85|       |
   86|   489k|    if (key3 != NULL) {
  ------------------
  |  Branch (86:9): [True: 18.3k, False: 470k]
  ------------------
   87|   131k|        for (i = 0; key3[i] != 0; i++) {
  ------------------
  |  Branch (87:21): [True: 113k, False: 18.3k]
  ------------------
   88|   113k|            HASH_UPDATE(h1, h2, key3[i]);
  ------------------
  |  |   29|   113k|    do { \
  |  |   30|   113k|        h1 += ch; \
  |  |   31|   113k|        h1 += h1 << 3; \
  |  |   32|   113k|        h2 += h1; \
  |  |   33|   113k|        h2 = HASH_ROL(h2, 7); \
  |  |  ------------------
  |  |  |  |   12|   113k|#define HASH_ROL(x,n) ((x) << (n) | ((x) & 0xFFFFFFFF) >> (32 - (n)))
  |  |  ------------------
  |  |   34|   113k|        h2 += h2 << 2; \
  |  |   35|   113k|    } while (0)
  |  |  ------------------
  |  |  |  Branch (35:14): [Folded - Ignored]
  |  |  ------------------
  ------------------
   89|   113k|        }
   90|  18.3k|        if (lengths)
  ------------------
  |  Branch (90:13): [True: 7.78k, False: 10.6k]
  ------------------
   91|  7.78k|            lengths[2] = i;
   92|  18.3k|    }
   93|       |
   94|   489k|    HASH_FINISH(h1, h2);
  ------------------
  |  |   39|   489k|    do { \
  |  |   40|   489k|        h1 ^= h2; \
  |  |   41|   489k|        h1 += HASH_ROL(h2, 14); \
  |  |  ------------------
  |  |  |  |   12|   489k|#define HASH_ROL(x,n) ((x) << (n) | ((x) & 0xFFFFFFFF) >> (32 - (n)))
  |  |  ------------------
  |  |   42|   489k|        h2 ^= h1; h2 += HASH_ROR(h1, 6); \
  |  |  ------------------
  |  |  |  |   13|   489k|#define HASH_ROR(x,n) (((x) & 0xFFFFFFFF) >> (n) | (x) << (32 - (n)))
  |  |  ------------------
  |  |   43|   489k|        h1 ^= h2; h1 += HASH_ROL(h2, 5); \
  |  |  ------------------
  |  |  |  |   12|   489k|#define HASH_ROL(x,n) ((x) << (n) | ((x) & 0xFFFFFFFF) >> (32 - (n)))
  |  |  ------------------
  |  |   44|   489k|        h2 ^= h1; h2 += HASH_ROR(h1, 8); \
  |  |  ------------------
  |  |  |  |   13|   489k|#define HASH_ROR(x,n) (((x) & 0xFFFFFFFF) >> (n) | (x) << (32 - (n)))
  |  |  ------------------
  |  |   45|   489k|        h2 &= 0xFFFFFFFF; \
  |  |   46|   489k|    } while (0)
  |  |  ------------------
  |  |  |  Branch (46:14): [Folded - Ignored]
  |  |  ------------------
  ------------------
   95|       |
   96|   489k|    return(h2);
   97|   489k|}
hash.c:xmlHashFindEntry:
  294|   487k|                 unsigned hashValue, int *pfound) {
  295|   487k|    xmlHashEntry *entry;
  296|   487k|    unsigned mask, pos, displ;
  297|   487k|    int found = 0;
  298|       |
  299|   487k|    mask = hash->size - 1;
  300|   487k|    pos = hashValue & mask;
  301|   487k|    entry = &hash->table[pos];
  302|       |
  303|   487k|    if (entry->hashValue != 0) {
  ------------------
  |  Branch (303:9): [True: 467k, False: 20.2k]
  ------------------
  304|       |        /*
  305|       |         * Robin hood hashing: abort if the displacement of the entry
  306|       |         * is smaller than the displacement of the key we look for.
  307|       |         * This also stops at the correct position when inserting.
  308|       |         */
  309|   467k|        displ = 0;
  310|   467k|        hashValue |= MAX_HASH_SIZE;
  ------------------
  |  |   31|   467k|#define MAX_HASH_SIZE (1u << 31)
  ------------------
  311|       |
  312|   871k|        do {
  313|   871k|            if (entry->hashValue == hashValue) {
  ------------------
  |  Branch (313:17): [True: 423k, False: 448k]
  ------------------
  314|   423k|                if (hash->dict) {
  ------------------
  |  Branch (314:21): [True: 410k, False: 13.3k]
  ------------------
  315|   410k|                    if ((entry->key == key) &&
  ------------------
  |  Branch (315:25): [True: 202k, False: 208k]
  ------------------
  316|   410k|                        (entry->key2 == key2) &&
  ------------------
  |  Branch (316:25): [True: 201k, False: 657]
  ------------------
  317|   410k|                        (entry->key3 == key3)) {
  ------------------
  |  Branch (317:25): [True: 201k, False: 0]
  ------------------
  318|   201k|                        found = 1;
  319|   201k|                        break;
  320|   201k|                    }
  321|   410k|                }
  322|   221k|                if ((strcmp((const char *) entry->key,
  ------------------
  |  Branch (322:21): [True: 221k, False: 0]
  ------------------
  323|   221k|                            (const char *) key) == 0) &&
  324|   221k|                    (xmlFastStrEqual(entry->key2, key2)) &&
  ------------------
  |  Branch (324:21): [True: 221k, False: 0]
  ------------------
  325|   221k|                    (xmlFastStrEqual(entry->key3, key3))) {
  ------------------
  |  Branch (325:21): [True: 221k, False: 0]
  ------------------
  326|   221k|                    found = 1;
  327|   221k|                    break;
  328|   221k|                }
  329|   221k|            }
  330|       |
  331|   448k|            displ++;
  332|   448k|            pos++;
  333|   448k|            entry++;
  334|   448k|            if ((pos & mask) == 0)
  ------------------
  |  Branch (334:17): [True: 4.78k, False: 443k]
  ------------------
  335|  4.78k|                entry = hash->table;
  336|   448k|        } while ((entry->hashValue != 0) &&
  ------------------
  |  Branch (336:18): [True: 432k, False: 15.4k]
  ------------------
  337|   448k|                 (((pos - entry->hashValue) & mask) >= displ));
  ------------------
  |  Branch (337:18): [True: 404k, False: 28.4k]
  ------------------
  338|   467k|    }
  339|       |
  340|      0|    *pfound = found;
  341|   487k|    return(entry);
  342|   487k|}
hash.c:xmlHashQNameValue:
  104|  5.83k|                  const xmlChar *prefix3, const xmlChar *name3) {
  105|  5.83k|    unsigned h1, h2, ch;
  106|       |
  107|  5.83k|    HASH_INIT(h1, h2, seed);
  ------------------
  |  |   23|  5.83k|    do { \
  |  |   24|  5.83k|        h1 = seed ^ 0x3b00; \
  |  |   25|  5.83k|        h2 = HASH_ROL(seed, 15); \
  |  |  ------------------
  |  |  |  |   12|  5.83k|#define HASH_ROL(x,n) ((x) << (n) | ((x) & 0xFFFFFFFF) >> (32 - (n)))
  |  |  ------------------
  |  |   26|  5.83k|    } while (0)
  |  |  ------------------
  |  |  |  Branch (26:14): [Folded - Ignored]
  |  |  ------------------
  ------------------
  108|       |
  109|  5.83k|    if (prefix != NULL) {
  ------------------
  |  Branch (109:9): [True: 280, False: 5.55k]
  ------------------
  110|  1.12k|        while ((ch = *prefix++) != 0) {
  ------------------
  |  Branch (110:16): [True: 840, False: 280]
  ------------------
  111|    840|            HASH_UPDATE(h1, h2, ch);
  ------------------
  |  |   29|    840|    do { \
  |  |   30|    840|        h1 += ch; \
  |  |   31|    840|        h1 += h1 << 3; \
  |  |   32|    840|        h2 += h1; \
  |  |   33|    840|        h2 = HASH_ROL(h2, 7); \
  |  |  ------------------
  |  |  |  |   12|    840|#define HASH_ROL(x,n) ((x) << (n) | ((x) & 0xFFFFFFFF) >> (32 - (n)))
  |  |  ------------------
  |  |   34|    840|        h2 += h2 << 2; \
  |  |   35|    840|    } while (0)
  |  |  ------------------
  |  |  |  Branch (35:14): [Folded - Ignored]
  |  |  ------------------
  ------------------
  112|    840|        }
  113|    280|        HASH_UPDATE(h1, h2, ':');
  ------------------
  |  |   29|    280|    do { \
  |  |   30|    280|        h1 += ch; \
  |  |   31|    280|        h1 += h1 << 3; \
  |  |   32|    280|        h2 += h1; \
  |  |   33|    280|        h2 = HASH_ROL(h2, 7); \
  |  |  ------------------
  |  |  |  |   12|    280|#define HASH_ROL(x,n) ((x) << (n) | ((x) & 0xFFFFFFFF) >> (32 - (n)))
  |  |  ------------------
  |  |   34|    280|        h2 += h2 << 2; \
  |  |   35|    280|    } while (0)
  |  |  ------------------
  |  |  |  Branch (35:14): [Folded - Ignored]
  |  |  ------------------
  ------------------
  114|    280|    }
  115|  5.83k|    if (name != NULL) {
  ------------------
  |  Branch (115:9): [True: 5.83k, False: 0]
  ------------------
  116|  34.8k|        while ((ch = *name++) != 0) {
  ------------------
  |  Branch (116:16): [True: 29.0k, False: 5.83k]
  ------------------
  117|  29.0k|            HASH_UPDATE(h1, h2, ch);
  ------------------
  |  |   29|  29.0k|    do { \
  |  |   30|  29.0k|        h1 += ch; \
  |  |   31|  29.0k|        h1 += h1 << 3; \
  |  |   32|  29.0k|        h2 += h1; \
  |  |   33|  29.0k|        h2 = HASH_ROL(h2, 7); \
  |  |  ------------------
  |  |  |  |   12|  29.0k|#define HASH_ROL(x,n) ((x) << (n) | ((x) & 0xFFFFFFFF) >> (32 - (n)))
  |  |  ------------------
  |  |   34|  29.0k|        h2 += h2 << 2; \
  |  |   35|  29.0k|    } while (0)
  |  |  ------------------
  |  |  |  Branch (35:14): [Folded - Ignored]
  |  |  ------------------
  ------------------
  118|  29.0k|        }
  119|  5.83k|    }
  120|  5.83k|    HASH_UPDATE(h1, h2, 0);
  ------------------
  |  |   29|  5.83k|    do { \
  |  |   30|  5.83k|        h1 += ch; \
  |  |   31|  5.83k|        h1 += h1 << 3; \
  |  |   32|  5.83k|        h2 += h1; \
  |  |   33|  5.83k|        h2 = HASH_ROL(h2, 7); \
  |  |  ------------------
  |  |  |  |   12|  5.83k|#define HASH_ROL(x,n) ((x) << (n) | ((x) & 0xFFFFFFFF) >> (32 - (n)))
  |  |  ------------------
  |  |   34|  5.83k|        h2 += h2 << 2; \
  |  |   35|  5.83k|    } while (0)
  |  |  ------------------
  |  |  |  Branch (35:14): [Folded - Ignored]
  |  |  ------------------
  ------------------
  121|  5.83k|    if (prefix2 != NULL) {
  ------------------
  |  Branch (121:9): [True: 296, False: 5.53k]
  ------------------
  122|  1.21k|        while ((ch = *prefix2++) != 0) {
  ------------------
  |  Branch (122:16): [True: 920, False: 296]
  ------------------
  123|    920|            HASH_UPDATE(h1, h2, ch);
  ------------------
  |  |   29|    920|    do { \
  |  |   30|    920|        h1 += ch; \
  |  |   31|    920|        h1 += h1 << 3; \
  |  |   32|    920|        h2 += h1; \
  |  |   33|    920|        h2 = HASH_ROL(h2, 7); \
  |  |  ------------------
  |  |  |  |   12|    920|#define HASH_ROL(x,n) ((x) << (n) | ((x) & 0xFFFFFFFF) >> (32 - (n)))
  |  |  ------------------
  |  |   34|    920|        h2 += h2 << 2; \
  |  |   35|    920|    } while (0)
  |  |  ------------------
  |  |  |  Branch (35:14): [Folded - Ignored]
  |  |  ------------------
  ------------------
  124|    920|        }
  125|    296|        HASH_UPDATE(h1, h2, ':');
  ------------------
  |  |   29|    296|    do { \
  |  |   30|    296|        h1 += ch; \
  |  |   31|    296|        h1 += h1 << 3; \
  |  |   32|    296|        h2 += h1; \
  |  |   33|    296|        h2 = HASH_ROL(h2, 7); \
  |  |  ------------------
  |  |  |  |   12|    296|#define HASH_ROL(x,n) ((x) << (n) | ((x) & 0xFFFFFFFF) >> (32 - (n)))
  |  |  ------------------
  |  |   34|    296|        h2 += h2 << 2; \
  |  |   35|    296|    } while (0)
  |  |  ------------------
  |  |  |  Branch (35:14): [Folded - Ignored]
  |  |  ------------------
  ------------------
  126|    296|    }
  127|  5.83k|    if (name2 != NULL) {
  ------------------
  |  Branch (127:9): [True: 5.83k, False: 0]
  ------------------
  128|  24.9k|        while ((ch = *name2++) != 0) {
  ------------------
  |  Branch (128:16): [True: 19.0k, False: 5.83k]
  ------------------
  129|  19.0k|            HASH_UPDATE(h1, h2, ch);
  ------------------
  |  |   29|  19.0k|    do { \
  |  |   30|  19.0k|        h1 += ch; \
  |  |   31|  19.0k|        h1 += h1 << 3; \
  |  |   32|  19.0k|        h2 += h1; \
  |  |   33|  19.0k|        h2 = HASH_ROL(h2, 7); \
  |  |  ------------------
  |  |  |  |   12|  19.0k|#define HASH_ROL(x,n) ((x) << (n) | ((x) & 0xFFFFFFFF) >> (32 - (n)))
  |  |  ------------------
  |  |   34|  19.0k|        h2 += h2 << 2; \
  |  |   35|  19.0k|    } while (0)
  |  |  ------------------
  |  |  |  Branch (35:14): [Folded - Ignored]
  |  |  ------------------
  ------------------
  130|  19.0k|        }
  131|  5.83k|    }
  132|  5.83k|    HASH_UPDATE(h1, h2, 0);
  ------------------
  |  |   29|  5.83k|    do { \
  |  |   30|  5.83k|        h1 += ch; \
  |  |   31|  5.83k|        h1 += h1 << 3; \
  |  |   32|  5.83k|        h2 += h1; \
  |  |   33|  5.83k|        h2 = HASH_ROL(h2, 7); \
  |  |  ------------------
  |  |  |  |   12|  5.83k|#define HASH_ROL(x,n) ((x) << (n) | ((x) & 0xFFFFFFFF) >> (32 - (n)))
  |  |  ------------------
  |  |   34|  5.83k|        h2 += h2 << 2; \
  |  |   35|  5.83k|    } while (0)
  |  |  ------------------
  |  |  |  Branch (35:14): [Folded - Ignored]
  |  |  ------------------
  ------------------
  133|  5.83k|    if (prefix3 != NULL) {
  ------------------
  |  Branch (133:9): [True: 0, False: 5.83k]
  ------------------
  134|      0|        while ((ch = *prefix3++) != 0) {
  ------------------
  |  Branch (134:16): [True: 0, False: 0]
  ------------------
  135|      0|            HASH_UPDATE(h1, h2, ch);
  ------------------
  |  |   29|      0|    do { \
  |  |   30|      0|        h1 += ch; \
  |  |   31|      0|        h1 += h1 << 3; \
  |  |   32|      0|        h2 += h1; \
  |  |   33|      0|        h2 = HASH_ROL(h2, 7); \
  |  |  ------------------
  |  |  |  |   12|      0|#define HASH_ROL(x,n) ((x) << (n) | ((x) & 0xFFFFFFFF) >> (32 - (n)))
  |  |  ------------------
  |  |   34|      0|        h2 += h2 << 2; \
  |  |   35|      0|    } while (0)
  |  |  ------------------
  |  |  |  Branch (35:14): [Folded - Ignored]
  |  |  ------------------
  ------------------
  136|      0|        }
  137|      0|        HASH_UPDATE(h1, h2, ':');
  ------------------
  |  |   29|      0|    do { \
  |  |   30|      0|        h1 += ch; \
  |  |   31|      0|        h1 += h1 << 3; \
  |  |   32|      0|        h2 += h1; \
  |  |   33|      0|        h2 = HASH_ROL(h2, 7); \
  |  |  ------------------
  |  |  |  |   12|      0|#define HASH_ROL(x,n) ((x) << (n) | ((x) & 0xFFFFFFFF) >> (32 - (n)))
  |  |  ------------------
  |  |   34|      0|        h2 += h2 << 2; \
  |  |   35|      0|    } while (0)
  |  |  ------------------
  |  |  |  Branch (35:14): [Folded - Ignored]
  |  |  ------------------
  ------------------
  138|      0|    }
  139|  5.83k|    if (name3 != NULL) {
  ------------------
  |  Branch (139:9): [True: 0, False: 5.83k]
  ------------------
  140|      0|        while ((ch = *name3++) != 0) {
  ------------------
  |  Branch (140:16): [True: 0, False: 0]
  ------------------
  141|      0|            HASH_UPDATE(h1, h2, ch);
  ------------------
  |  |   29|      0|    do { \
  |  |   30|      0|        h1 += ch; \
  |  |   31|      0|        h1 += h1 << 3; \
  |  |   32|      0|        h2 += h1; \
  |  |   33|      0|        h2 = HASH_ROL(h2, 7); \
  |  |  ------------------
  |  |  |  |   12|      0|#define HASH_ROL(x,n) ((x) << (n) | ((x) & 0xFFFFFFFF) >> (32 - (n)))
  |  |  ------------------
  |  |   34|      0|        h2 += h2 << 2; \
  |  |   35|      0|    } while (0)
  |  |  ------------------
  |  |  |  Branch (35:14): [Folded - Ignored]
  |  |  ------------------
  ------------------
  142|      0|        }
  143|      0|    }
  144|       |
  145|  5.83k|    HASH_FINISH(h1, h2);
  ------------------
  |  |   39|  5.83k|    do { \
  |  |   40|  5.83k|        h1 ^= h2; \
  |  |   41|  5.83k|        h1 += HASH_ROL(h2, 14); \
  |  |  ------------------
  |  |  |  |   12|  5.83k|#define HASH_ROL(x,n) ((x) << (n) | ((x) & 0xFFFFFFFF) >> (32 - (n)))
  |  |  ------------------
  |  |   42|  5.83k|        h2 ^= h1; h2 += HASH_ROR(h1, 6); \
  |  |  ------------------
  |  |  |  |   13|  5.83k|#define HASH_ROR(x,n) (((x) & 0xFFFFFFFF) >> (n) | (x) << (32 - (n)))
  |  |  ------------------
  |  |   43|  5.83k|        h1 ^= h2; h1 += HASH_ROL(h2, 5); \
  |  |  ------------------
  |  |  |  |   12|  5.83k|#define HASH_ROL(x,n) ((x) << (n) | ((x) & 0xFFFFFFFF) >> (32 - (n)))
  |  |  ------------------
  |  |   44|  5.83k|        h2 ^= h1; h2 += HASH_ROR(h1, 8); \
  |  |  ------------------
  |  |  |  |   13|  5.83k|#define HASH_ROR(x,n) (((x) & 0xFFFFFFFF) >> (n) | (x) << (32 - (n)))
  |  |  ------------------
  |  |   45|  5.83k|        h2 &= 0xFFFFFFFF; \
  |  |   46|  5.83k|    } while (0)
  |  |  ------------------
  |  |  |  Branch (46:14): [Folded - Ignored]
  |  |  ------------------
  ------------------
  146|       |
  147|  5.83k|    return(h2);
  148|  5.83k|}
hash.c:stubHashScannerFull:
  884|  9.42k|                    const xmlChar *key3 ATTRIBUTE_UNUSED) {
  885|  9.42k|    stubData *sdata = (stubData *) data;
  886|  9.42k|    sdata->scan(payload, sdata->data, key);
  887|  9.42k|}
hash.c:xmlFastStrEqual:
  269|   614k|xmlFastStrEqual(const xmlChar *s1, const xmlChar *s2) {
  270|   614k|    if (s1 == NULL)
  ------------------
  |  Branch (270:9): [True: 442k, False: 172k]
  ------------------
  271|   442k|        return(s2 == NULL);
  272|   172k|    else
  273|   172k|        return((s2 != NULL) &&
  ------------------
  |  Branch (273:16): [True: 172k, False: 0]
  ------------------
  274|   172k|               (strcmp((const char *) s1, (const char *) s2) == 0));
  ------------------
  |  Branch (274:16): [True: 1.30k, False: 170k]
  ------------------
  275|   614k|}

xmlListCreate:
  189|  1.09k|{
  190|  1.09k|    xmlListPtr l;
  191|  1.09k|    if (NULL == (l = (xmlListPtr )xmlMalloc( sizeof(xmlList)))) {
  ------------------
  |  Branch (191:9): [True: 0, False: 1.09k]
  ------------------
  192|      0|        xmlGenericError(xmlGenericErrorContext,
  ------------------
  |  |  875|      0|  #define xmlGenericError XML_GLOBAL_MACRO(xmlGenericError)
  |  |  ------------------
  |  |  |  |  500|      0|  #define XML_GLOBAL_MACRO(name) (*__##name())
  |  |  ------------------
  ------------------
                      xmlGenericError(xmlGenericErrorContext,
  ------------------
  |  |  876|      0|  #define xmlGenericErrorContext XML_GLOBAL_MACRO(xmlGenericErrorContext)
  |  |  ------------------
  |  |  |  |  500|      0|  #define XML_GLOBAL_MACRO(name) (*__##name())
  |  |  ------------------
  ------------------
  193|      0|		        "Cannot initialize memory for list");
  194|      0|        return (NULL);
  195|      0|    }
  196|       |    /* Initialize the list to NULL */
  197|  1.09k|    memset(l, 0, sizeof(xmlList));
  198|       |
  199|       |    /* Add the sentinel */
  200|  1.09k|    if (NULL ==(l->sentinel = (xmlLinkPtr )xmlMalloc(sizeof(xmlLink)))) {
  ------------------
  |  Branch (200:9): [True: 0, False: 1.09k]
  ------------------
  201|      0|        xmlGenericError(xmlGenericErrorContext,
  ------------------
  |  |  875|      0|  #define xmlGenericError XML_GLOBAL_MACRO(xmlGenericError)
  |  |  ------------------
  |  |  |  |  500|      0|  #define XML_GLOBAL_MACRO(name) (*__##name())
  |  |  ------------------
  ------------------
                      xmlGenericError(xmlGenericErrorContext,
  ------------------
  |  |  876|      0|  #define xmlGenericErrorContext XML_GLOBAL_MACRO(xmlGenericErrorContext)
  |  |  ------------------
  |  |  |  |  500|      0|  #define XML_GLOBAL_MACRO(name) (*__##name())
  |  |  ------------------
  ------------------
  202|      0|		        "Cannot initialize memory for sentinel");
  203|      0|	xmlFree(l);
  204|      0|        return (NULL);
  205|      0|    }
  206|  1.09k|    l->sentinel->next = l->sentinel;
  207|  1.09k|    l->sentinel->prev = l->sentinel;
  208|  1.09k|    l->sentinel->data = NULL;
  209|       |
  210|       |    /* If there is a link deallocator, use it */
  211|  1.09k|    if (deallocator != NULL)
  ------------------
  |  Branch (211:9): [True: 1.09k, False: 0]
  ------------------
  212|  1.09k|        l->linkDeallocator = deallocator;
  213|       |    /* If there is a link comparator, use it */
  214|  1.09k|    if (compare != NULL)
  ------------------
  |  Branch (214:9): [True: 1.09k, False: 0]
  ------------------
  215|  1.09k|        l->linkCompare = compare;
  216|      0|    else /* Use our own */
  217|      0|        l->linkCompare = xmlLinkCompare;
  218|  1.09k|    return l;
  219|  1.09k|}
xmlListAppend:
  306|  3.31k|{
  307|  3.31k|    xmlLinkPtr lkPlace, lkNew;
  308|       |
  309|  3.31k|    if (l == NULL)
  ------------------
  |  Branch (309:9): [True: 0, False: 3.31k]
  ------------------
  310|      0|        return(1);
  311|  3.31k|    lkPlace = xmlListHigherSearch(l, data);
  312|       |    /* Add the new link */
  313|  3.31k|    lkNew = (xmlLinkPtr) xmlMalloc(sizeof(xmlLink));
  314|  3.31k|    if (lkNew == NULL) {
  ------------------
  |  Branch (314:9): [True: 0, False: 3.31k]
  ------------------
  315|      0|        xmlGenericError(xmlGenericErrorContext,
  ------------------
  |  |  875|      0|  #define xmlGenericError XML_GLOBAL_MACRO(xmlGenericError)
  |  |  ------------------
  |  |  |  |  500|      0|  #define XML_GLOBAL_MACRO(name) (*__##name())
  |  |  ------------------
  ------------------
                      xmlGenericError(xmlGenericErrorContext,
  ------------------
  |  |  876|      0|  #define xmlGenericErrorContext XML_GLOBAL_MACRO(xmlGenericErrorContext)
  |  |  ------------------
  |  |  |  |  500|      0|  #define XML_GLOBAL_MACRO(name) (*__##name())
  |  |  ------------------
  ------------------
  316|      0|		        "Cannot initialize memory for new link");
  317|      0|        return (1);
  318|      0|    }
  319|  3.31k|    lkNew->data = data;
  320|  3.31k|    lkNew->next = lkPlace->next;
  321|  3.31k|    (lkPlace->next)->prev = lkNew;
  322|  3.31k|    lkPlace->next = lkNew;
  323|  3.31k|    lkNew->prev = lkPlace;
  324|  3.31k|    return 0;
  325|  3.31k|}
xmlListDelete:
  334|  1.09k|{
  335|  1.09k|    if (l == NULL)
  ------------------
  |  Branch (335:9): [True: 0, False: 1.09k]
  ------------------
  336|      0|        return;
  337|       |
  338|  1.09k|    xmlListClear(l);
  339|  1.09k|    xmlFree(l->sentinel);
  340|  1.09k|    xmlFree(l);
  341|  1.09k|}
xmlListClear:
  423|  1.09k|{
  424|  1.09k|    xmlLinkPtr  lk;
  425|       |
  426|  1.09k|    if (l == NULL)
  ------------------
  |  Branch (426:9): [True: 0, False: 1.09k]
  ------------------
  427|      0|        return;
  428|  1.09k|    lk = l->sentinel->next;
  429|  4.41k|    while(lk != l->sentinel) {
  ------------------
  |  Branch (429:11): [True: 3.31k, False: 1.09k]
  ------------------
  430|  3.31k|        xmlLinkPtr next = lk->next;
  431|       |
  432|  3.31k|        xmlLinkDeallocator(l, lk);
  433|  3.31k|        lk = next;
  434|  3.31k|    }
  435|  1.09k|}
xmlLinkGetData:
  605|  3.31k|{
  606|  3.31k|    if (lk == NULL)
  ------------------
  |  Branch (606:9): [True: 0, False: 3.31k]
  ------------------
  607|      0|        return(NULL);
  608|  3.31k|    return lk->data;
  609|  3.31k|}
xmlListWalk:
  676|    880|xmlListWalk(xmlListPtr l, xmlListWalker walker, void *user) {
  677|    880|    xmlLinkPtr lk;
  678|       |
  679|    880|    if ((l == NULL) || (walker == NULL))
  ------------------
  |  Branch (679:9): [True: 0, False: 880]
  |  Branch (679:24): [True: 0, False: 880]
  ------------------
  680|      0|        return;
  681|  3.53k|    for(lk = l->sentinel->next; lk != l->sentinel; lk = lk->next) {
  ------------------
  |  Branch (681:33): [True: 2.65k, False: 880]
  ------------------
  682|  2.65k|        if((walker(lk->data, user)) == 0)
  ------------------
  |  Branch (682:12): [True: 0, False: 2.65k]
  ------------------
  683|      0|                break;
  684|  2.65k|    }
  685|    880|}
list.c:xmlListHigherSearch:
  119|  3.31k|{
  120|  3.31k|    xmlLinkPtr lk;
  121|       |
  122|  3.31k|    if (l == NULL)
  ------------------
  |  Branch (122:9): [True: 0, False: 3.31k]
  ------------------
  123|      0|        return(NULL);
  124|  3.31k|    for(lk = l->sentinel->prev;lk != l->sentinel && l->linkCompare(lk->data, data) >0 ;lk = lk->prev);
  ------------------
  |  Branch (124:32): [True: 2.22k, False: 1.09k]
  |  Branch (124:53): [True: 0, False: 2.22k]
  ------------------
  125|  3.31k|    return lk;
  126|  3.31k|}
list.c:xmlLinkDeallocator:
   60|  3.31k|{
   61|  3.31k|    (lk->prev)->next = lk->next;
   62|  3.31k|    (lk->next)->prev = lk->prev;
   63|  3.31k|    if(l->linkDeallocator)
  ------------------
  |  Branch (63:8): [True: 3.31k, False: 0]
  ------------------
   64|  3.31k|        l->linkDeallocator(lk);
   65|  3.31k|    xmlFree(lk);
   66|  3.31k|}

xmlParserNsCreate:
 1407|  1.80k|xmlParserNsCreate(void) {
 1408|  1.80k|    xmlParserNsData *nsdb = xmlMalloc(sizeof(*nsdb));
 1409|       |
 1410|  1.80k|    if (nsdb == NULL)
  ------------------
  |  Branch (1410:9): [True: 0, False: 1.80k]
  ------------------
 1411|      0|        return(NULL);
 1412|  1.80k|    memset(nsdb, 0, sizeof(*nsdb));
 1413|  1.80k|    nsdb->defaultNsIndex = INT_MAX;
 1414|       |
 1415|  1.80k|    return(nsdb);
 1416|  1.80k|}
xmlParserNsFree:
 1425|  1.80k|xmlParserNsFree(xmlParserNsData *nsdb) {
 1426|  1.80k|    if (nsdb == NULL)
  ------------------
  |  Branch (1426:9): [True: 0, False: 1.80k]
  ------------------
 1427|      0|        return;
 1428|       |
 1429|  1.80k|    xmlFree(nsdb->extra);
 1430|  1.80k|    xmlFree(nsdb->hash);
 1431|  1.80k|    xmlFree(nsdb);
 1432|  1.80k|}
xmlParserNsLookupSax:
 1560|  2.86k|xmlParserNsLookupSax(xmlParserCtxtPtr ctxt, const xmlChar *prefix) {
 1561|  2.86k|    xmlHashedString hprefix;
 1562|  2.86k|    int nsIndex;
 1563|       |
 1564|  2.86k|    if (prefix == ctxt->str_xml)
  ------------------
  |  Branch (1564:9): [True: 64, False: 2.79k]
  ------------------
 1565|     64|        return(NULL);
 1566|       |
 1567|  2.79k|    hprefix.name = prefix;
 1568|  2.79k|    if (prefix != NULL)
  ------------------
  |  Branch (1568:9): [True: 2.47k, False: 324]
  ------------------
 1569|  2.47k|        hprefix.hashValue = xmlDictComputeHash(ctxt->dict, prefix);
 1570|    324|    else
 1571|    324|        hprefix.hashValue = 0;
 1572|  2.79k|    nsIndex = xmlParserNsLookup(ctxt, &hprefix, NULL);
 1573|  2.79k|    if (nsIndex == INT_MAX)
  ------------------
  |  Branch (1573:9): [True: 0, False: 2.79k]
  ------------------
 1574|      0|        return(NULL);
 1575|       |
 1576|  2.79k|    return(ctxt->nsdb->extra[nsIndex].saxData);
 1577|  2.79k|}
xmlParserNsUpdateSax:
 1593|    412|                     void *saxData) {
 1594|    412|    xmlHashedString hprefix;
 1595|    412|    int nsIndex;
 1596|       |
 1597|    412|    if (prefix == ctxt->str_xml)
  ------------------
  |  Branch (1597:9): [True: 0, False: 412]
  ------------------
 1598|      0|        return(-1);
 1599|       |
 1600|    412|    hprefix.name = prefix;
 1601|    412|    if (prefix != NULL)
  ------------------
  |  Branch (1601:9): [True: 296, False: 116]
  ------------------
 1602|    296|        hprefix.hashValue = xmlDictComputeHash(ctxt->dict, prefix);
 1603|    116|    else
 1604|    116|        hprefix.hashValue = 0;
 1605|    412|    nsIndex = xmlParserNsLookup(ctxt, &hprefix, NULL);
 1606|    412|    if (nsIndex == INT_MAX)
  ------------------
  |  Branch (1606:9): [True: 0, False: 412]
  ------------------
 1607|      0|        return(-1);
 1608|       |
 1609|    412|    ctxt->nsdb->extra[nsIndex].saxData = saxData;
 1610|    412|    return(0);
 1611|    412|}
inputPush:
 1893|   139k|{
 1894|   139k|    if ((ctxt == NULL) || (value == NULL))
  ------------------
  |  Branch (1894:9): [True: 0, False: 139k]
  |  Branch (1894:27): [True: 0, False: 139k]
  ------------------
 1895|      0|        return(-1);
 1896|   139k|    if (ctxt->inputNr >= ctxt->inputMax) {
  ------------------
  |  Branch (1896:9): [True: 12, False: 139k]
  ------------------
 1897|     12|        size_t newSize = ctxt->inputMax * 2;
 1898|     12|        xmlParserInputPtr *tmp;
 1899|       |
 1900|     12|        tmp = (xmlParserInputPtr *) xmlRealloc(ctxt->inputTab,
 1901|     12|                                               newSize * sizeof(*tmp));
 1902|     12|        if (tmp == NULL) {
  ------------------
  |  Branch (1902:13): [True: 0, False: 12]
  ------------------
 1903|      0|            xmlErrMemory(ctxt, NULL);
 1904|      0|            return (-1);
 1905|      0|        }
 1906|     12|        ctxt->inputTab = tmp;
 1907|     12|        ctxt->inputMax = newSize;
 1908|     12|    }
 1909|   139k|    ctxt->inputTab[ctxt->inputNr] = value;
 1910|   139k|    ctxt->input = value;
 1911|   139k|    return (ctxt->inputNr++);
 1912|   139k|}
inputPop:
 1923|   142k|{
 1924|   142k|    xmlParserInputPtr ret;
 1925|       |
 1926|   142k|    if (ctxt == NULL)
  ------------------
  |  Branch (1926:9): [True: 0, False: 142k]
  ------------------
 1927|      0|        return(NULL);
 1928|   142k|    if (ctxt->inputNr <= 0)
  ------------------
  |  Branch (1928:9): [True: 3.61k, False: 139k]
  ------------------
 1929|  3.61k|        return (NULL);
 1930|   139k|    ctxt->inputNr--;
 1931|   139k|    if (ctxt->inputNr > 0)
  ------------------
  |  Branch (1931:9): [True: 137k, False: 1.76k]
  ------------------
 1932|   137k|        ctxt->input = ctxt->inputTab[ctxt->inputNr - 1];
 1933|  1.76k|    else
 1934|  1.76k|        ctxt->input = NULL;
 1935|   139k|    ret = ctxt->inputTab[ctxt->inputNr];
 1936|   139k|    ctxt->inputTab[ctxt->inputNr] = NULL;
 1937|   139k|    return (ret);
 1938|   142k|}
nodePush:
 1952|  57.7k|{
 1953|  57.7k|    if (ctxt == NULL) return(0);
  ------------------
  |  Branch (1953:9): [True: 0, False: 57.7k]
  ------------------
 1954|  57.7k|    if (ctxt->nodeNr >= ctxt->nodeMax) {
  ------------------
  |  Branch (1954:9): [True: 4, False: 57.7k]
  ------------------
 1955|      4|        xmlNodePtr *tmp;
 1956|       |
 1957|      4|	tmp = (xmlNodePtr *) xmlRealloc(ctxt->nodeTab,
 1958|      4|                                      ctxt->nodeMax * 2 *
 1959|      4|                                      sizeof(ctxt->nodeTab[0]));
 1960|      4|        if (tmp == NULL) {
  ------------------
  |  Branch (1960:13): [True: 0, False: 4]
  ------------------
 1961|      0|            xmlErrMemory(ctxt, NULL);
 1962|      0|            return (-1);
 1963|      0|        }
 1964|      4|        ctxt->nodeTab = tmp;
 1965|      4|	ctxt->nodeMax *= 2;
 1966|      4|    }
 1967|  57.7k|    if ((((unsigned int) ctxt->nodeNr) > xmlParserMaxDepth) &&
  ------------------
  |  Branch (1967:9): [True: 0, False: 57.7k]
  ------------------
 1968|  57.7k|        ((ctxt->options & XML_PARSE_HUGE) == 0)) {
  ------------------
  |  Branch (1968:9): [True: 0, False: 0]
  ------------------
 1969|      0|	xmlFatalErrMsgInt(ctxt, XML_ERR_INTERNAL_ERROR,
 1970|      0|		 "Excessive depth in document: %d use XML_PARSE_HUGE option\n",
 1971|      0|			  xmlParserMaxDepth);
 1972|      0|	xmlHaltParser(ctxt);
 1973|      0|	return(-1);
 1974|      0|    }
 1975|  57.7k|    ctxt->nodeTab[ctxt->nodeNr] = value;
 1976|  57.7k|    ctxt->node = value;
 1977|  57.7k|    return (ctxt->nodeNr++);
 1978|  57.7k|}
nodePop:
 1992|  57.2k|{
 1993|  57.2k|    xmlNodePtr ret;
 1994|       |
 1995|  57.2k|    if (ctxt == NULL) return(NULL);
  ------------------
  |  Branch (1995:9): [True: 0, False: 57.2k]
  ------------------
 1996|  57.2k|    if (ctxt->nodeNr <= 0)
  ------------------
  |  Branch (1996:9): [True: 16, False: 57.2k]
  ------------------
 1997|     16|        return (NULL);
 1998|  57.2k|    ctxt->nodeNr--;
 1999|  57.2k|    if (ctxt->nodeNr > 0)
  ------------------
  |  Branch (1999:9): [True: 56.1k, False: 1.06k]
  ------------------
 2000|  56.1k|        ctxt->node = ctxt->nodeTab[ctxt->nodeNr - 1];
 2001|  1.06k|    else
 2002|  1.06k|        ctxt->node = NULL;
 2003|  57.2k|    ret = ctxt->nodeTab[ctxt->nodeNr];
 2004|  57.2k|    ctxt->nodeTab[ctxt->nodeNr] = NULL;
 2005|  57.2k|    return (ret);
 2006|  57.2k|}
namePop:
 2139|  28.8k|{
 2140|  28.8k|    const xmlChar *ret;
 2141|       |
 2142|  28.8k|    if ((ctxt == NULL) || (ctxt->nameNr <= 0))
  ------------------
  |  Branch (2142:9): [True: 0, False: 28.8k]
  |  Branch (2142:27): [True: 0, False: 28.8k]
  ------------------
 2143|      0|        return (NULL);
 2144|  28.8k|    ctxt->nameNr--;
 2145|  28.8k|    if (ctxt->nameNr > 0)
  ------------------
  |  Branch (2145:9): [True: 28.2k, False: 638]
  ------------------
 2146|  28.2k|        ctxt->name = ctxt->nameTab[ctxt->nameNr - 1];
 2147|    638|    else
 2148|    638|        ctxt->name = NULL;
 2149|  28.8k|    ret = ctxt->nameTab[ctxt->nameNr];
 2150|  28.8k|    ctxt->nameTab[ctxt->nameNr] = NULL;
 2151|  28.8k|    return (ret);
 2152|  28.8k|}
xmlSkipBlankChars:
 2311|  1.06M|xmlSkipBlankChars(xmlParserCtxtPtr ctxt) {
 2312|  1.06M|    int res = 0;
 2313|       |
 2314|       |    /*
 2315|       |     * It's Okay to use CUR/NEXT here since all the blanks are on
 2316|       |     * the ASCII range.
 2317|       |     */
 2318|  1.06M|    if (((ctxt->inputNr == 1) && (ctxt->instate != XML_PARSER_DTD)) ||
  ------------------
  |  Branch (2318:10): [True: 387k, False: 679k]
  |  Branch (2318:34): [True: 342k, False: 45.0k]
  ------------------
 2319|  1.06M|        (ctxt->instate == XML_PARSER_START)) {
  ------------------
  |  Branch (2319:9): [True: 32, False: 724k]
  ------------------
 2320|   342k|	const xmlChar *cur;
 2321|       |	/*
 2322|       |	 * if we are in the document content, go really fast
 2323|       |	 */
 2324|   342k|	cur = ctxt->input->cur;
 2325|   342k|	while (IS_BLANK_CH(*cur)) {
 2326|   279k|	    if (*cur == '\n') {
  ------------------
  |  Branch (2326:10): [True: 5.36k, False: 274k]
  ------------------
 2327|  5.36k|		ctxt->input->line++; ctxt->input->col = 1;
 2328|   274k|	    } else {
 2329|   274k|		ctxt->input->col++;
 2330|   274k|	    }
 2331|   279k|	    cur++;
 2332|   279k|	    if (res < INT_MAX)
  ------------------
  |  Branch (2332:10): [True: 279k, False: 0]
  ------------------
 2333|   279k|		res++;
 2334|   279k|	    if (*cur == 0) {
  ------------------
  |  Branch (2334:10): [True: 1.08k, False: 278k]
  ------------------
 2335|  1.08k|		ctxt->input->cur = cur;
 2336|  1.08k|		xmlParserGrow(ctxt);
 2337|  1.08k|		cur = ctxt->input->cur;
 2338|  1.08k|	    }
 2339|   279k|	}
 2340|   342k|	ctxt->input->cur = cur;
 2341|   724k|    } else {
 2342|   724k|        int expandPE = ((ctxt->external != 0) || (ctxt->inputNr != 1));
  ------------------
  |  Branch (2342:25): [True: 43.6k, False: 680k]
  |  Branch (2342:50): [True: 658k, False: 22.6k]
  ------------------
 2343|       |
 2344|  1.28M|	while (ctxt->instate != XML_PARSER_EOF) {
  ------------------
  |  Branch (2344:9): [True: 1.28M, False: 12]
  ------------------
 2345|  1.28M|            if (IS_BLANK_CH(CUR)) { /* CHECKED tstblanks.xml */
  ------------------
  |  |  151|  1.28M|#define IS_BLANK_CH(c)  xmlIsBlank_ch(c)
  |  |  ------------------
  |  |  |  |   88|  1.28M|#define xmlIsBlank_ch(c)	(((c) == 0x20) || \
  |  |  |  |  ------------------
  |  |  |  |  |  Branch (88:27): [True: 190k, False: 1.09M]
  |  |  |  |  ------------------
  |  |  |  |   89|  1.28M|				 ((0x9 <= (c)) && ((c) <= 0xa)) || \
  |  |  |  |  ------------------
  |  |  |  |  |  Branch (89:7): [True: 959k, False: 137k]
  |  |  |  |  |  Branch (89:23): [True: 90.5k, False: 868k]
  |  |  |  |  ------------------
  |  |  |  |   90|  1.28M|				 ((c) == 0xd))
  |  |  |  |  ------------------
  |  |  |  |  |  Branch (90:6): [True: 7.12k, False: 999k]
  |  |  |  |  ------------------
  |  |  ------------------
  ------------------
 2346|   288k|		NEXT;
  ------------------
  |  | 2275|   288k|#define NEXT xmlNextChar(ctxt)
  ------------------
 2347|   999k|	    } else if (CUR == '%') {
  ------------------
  |  | 2222|   999k|#define CUR (*ctxt->input->cur)
  ------------------
  |  Branch (2347:17): [True: 138k, False: 860k]
  ------------------
 2348|       |                /*
 2349|       |                 * Need to handle support of entities branching here
 2350|       |                 */
 2351|   138k|	        if ((expandPE == 0) || (IS_BLANK_CH(NXT(1))) || (NXT(1) == 0))
  ------------------
  |  |  151|   137k|#define IS_BLANK_CH(c)  xmlIsBlank_ch(c)
  |  |  ------------------
  |  |  |  |   88|   137k|#define xmlIsBlank_ch(c)	(((c) == 0x20) || \
  |  |  |  |  ------------------
  |  |  |  |  |  Branch (88:27): [True: 636, False: 137k]
  |  |  |  |  ------------------
  |  |  |  |   89|   137k|				 ((0x9 <= (c)) && ((c) <= 0xa)) || \
  |  |  |  |  ------------------
  |  |  |  |  |  Branch (89:7): [True: 137k, False: 8]
  |  |  |  |  |  Branch (89:23): [True: 0, False: 137k]
  |  |  |  |  ------------------
  |  |  |  |   90|   137k|				 ((c) == 0xd))
  |  |  |  |  ------------------
  |  |  |  |  |  Branch (90:6): [True: 0, False: 137k]
  |  |  |  |  ------------------
  |  |  ------------------
  ------------------
              	        if ((expandPE == 0) || (IS_BLANK_CH(NXT(1))) || (NXT(1) == 0))
  ------------------
  |  | 2223|   137k|#define NXT(val) ctxt->input->cur[(val)]
  ------------------
  |  Branch (2351:14): [True: 356, False: 137k]
  |  Branch (2351:58): [True: 8, False: 137k]
  ------------------
 2352|  1.00k|                    break;
 2353|   137k|	        xmlParsePEReference(ctxt);
 2354|   860k|            } else if (CUR == 0) {
  ------------------
  |  | 2222|   860k|#define CUR (*ctxt->input->cur)
  ------------------
  |  Branch (2354:24): [True: 137k, False: 723k]
  ------------------
 2355|   137k|                unsigned long consumed;
 2356|   137k|                xmlEntityPtr ent;
 2357|       |
 2358|   137k|                if (ctxt->inputNr <= 1)
  ------------------
  |  Branch (2358:21): [True: 80, False: 137k]
  ------------------
 2359|     80|                    break;
 2360|       |
 2361|   137k|                consumed = ctxt->input->consumed;
 2362|   137k|                xmlSaturatedAddSizeT(&consumed,
 2363|   137k|                                     ctxt->input->cur - ctxt->input->base);
 2364|       |
 2365|       |                /*
 2366|       |                 * Add to sizeentities when parsing an external entity
 2367|       |                 * for the first time.
 2368|       |                 */
 2369|   137k|                ent = ctxt->input->entity;
 2370|   137k|                if ((ent->etype == XML_EXTERNAL_PARAMETER_ENTITY) &&
  ------------------
  |  Branch (2370:21): [True: 13.1k, False: 124k]
  ------------------
 2371|   137k|                    ((ent->flags & XML_ENT_PARSED) == 0)) {
  ------------------
  |  |   14|  13.1k|#define XML_ENT_PARSED      (1<<0)
  ------------------
  |  Branch (2371:21): [True: 20, False: 13.1k]
  ------------------
 2372|     20|                    ent->flags |= XML_ENT_PARSED;
  ------------------
  |  |   14|     20|#define XML_ENT_PARSED      (1<<0)
  ------------------
 2373|       |
 2374|     20|                    xmlSaturatedAdd(&ctxt->sizeentities, consumed);
 2375|     20|                }
 2376|       |
 2377|   137k|                xmlParserEntityCheck(ctxt, consumed);
 2378|       |
 2379|   137k|                xmlPopInput(ctxt);
 2380|   723k|            } else {
 2381|   723k|                break;
 2382|   723k|            }
 2383|       |
 2384|       |            /*
 2385|       |             * Also increase the counter when entering or exiting a PERef.
 2386|       |             * The spec says: "When a parameter-entity reference is recognized
 2387|       |             * in the DTD and included, its replacement text MUST be enlarged
 2388|       |             * by the attachment of one leading and one following space (#x20)
 2389|       |             * character."
 2390|       |             */
 2391|   562k|	    if (res < INT_MAX)
  ------------------
  |  Branch (2391:10): [True: 562k, False: 0]
  ------------------
 2392|   562k|		res++;
 2393|   562k|        }
 2394|   724k|    }
 2395|  1.06M|    return(res);
 2396|  1.06M|}
xmlPopInput:
 2414|   137k|xmlPopInput(xmlParserCtxtPtr ctxt) {
 2415|   137k|    xmlParserInputPtr input;
 2416|       |
 2417|   137k|    if ((ctxt == NULL) || (ctxt->inputNr <= 1)) return(0);
  ------------------
  |  Branch (2417:9): [True: 0, False: 137k]
  |  Branch (2417:27): [True: 8, False: 137k]
  ------------------
 2418|   137k|    if (xmlParserDebugEntities)
  ------------------
  |  |  870|   137k|  #define xmlParserDebugEntities XML_GLOBAL_MACRO(xmlParserDebugEntities)
  |  |  ------------------
  |  |  |  |  500|   137k|  #define XML_GLOBAL_MACRO(name) (*__##name())
  |  |  |  |  ------------------
  |  |  |  |  |  Branch (500:34): [True: 0, False: 137k]
  |  |  |  |  ------------------
  |  |  ------------------
  ------------------
 2419|      0|	xmlGenericError(xmlGenericErrorContext,
  ------------------
  |  |  875|      0|  #define xmlGenericError XML_GLOBAL_MACRO(xmlGenericError)
  |  |  ------------------
  |  |  |  |  500|      0|  #define XML_GLOBAL_MACRO(name) (*__##name())
  |  |  ------------------
  ------------------
              	xmlGenericError(xmlGenericErrorContext,
  ------------------
  |  |  876|      0|  #define xmlGenericErrorContext XML_GLOBAL_MACRO(xmlGenericErrorContext)
  |  |  ------------------
  |  |  |  |  500|      0|  #define XML_GLOBAL_MACRO(name) (*__##name())
  |  |  ------------------
  ------------------
 2420|      0|		"Popping input %d\n", ctxt->inputNr);
 2421|   137k|    if ((ctxt->inputNr > 1) && (ctxt->inSubset == 0) &&
  ------------------
  |  Branch (2421:9): [True: 137k, False: 0]
  |  Branch (2421:32): [True: 0, False: 137k]
  ------------------
 2422|   137k|        (ctxt->instate != XML_PARSER_EOF))
  ------------------
  |  Branch (2422:9): [True: 0, False: 0]
  ------------------
 2423|      0|        xmlFatalErr(ctxt, XML_ERR_INTERNAL_ERROR,
 2424|      0|                    "Unfinished entity outside the DTD");
 2425|   137k|    input = inputPop(ctxt);
 2426|   137k|    if (input->entity != NULL)
  ------------------
  |  Branch (2426:9): [True: 137k, False: 0]
  ------------------
 2427|   137k|        input->entity->flags &= ~XML_ENT_EXPANDING;
  ------------------
  |  |   16|   137k|#define XML_ENT_EXPANDING   (1<<2)
  ------------------
 2428|   137k|    xmlFreeInputStream(input);
 2429|   137k|    if (*ctxt->input->cur == 0)
  ------------------
  |  Branch (2429:9): [True: 60.5k, False: 76.6k]
  ------------------
 2430|  60.5k|        xmlParserGrow(ctxt);
 2431|   137k|    return(CUR);
  ------------------
  |  | 2222|   137k|#define CUR (*ctxt->input->cur)
  ------------------
 2432|   137k|}
xmlPushInput:
 2444|   137k|xmlPushInput(xmlParserCtxtPtr ctxt, xmlParserInputPtr input) {
 2445|   137k|    int ret;
 2446|   137k|    if (input == NULL) return(-1);
  ------------------
  |  Branch (2446:9): [True: 0, False: 137k]
  ------------------
 2447|       |
 2448|   137k|    if (xmlParserDebugEntities) {
  ------------------
  |  |  870|   137k|  #define xmlParserDebugEntities XML_GLOBAL_MACRO(xmlParserDebugEntities)
  |  |  ------------------
  |  |  |  |  500|   137k|  #define XML_GLOBAL_MACRO(name) (*__##name())
  |  |  |  |  ------------------
  |  |  |  |  |  Branch (500:34): [True: 0, False: 137k]
  |  |  |  |  ------------------
  |  |  ------------------
  ------------------
 2449|      0|	if ((ctxt->input != NULL) && (ctxt->input->filename))
  ------------------
  |  Branch (2449:6): [True: 0, False: 0]
  |  Branch (2449:31): [True: 0, False: 0]
  ------------------
 2450|      0|	    xmlGenericError(xmlGenericErrorContext,
  ------------------
  |  |  875|      0|  #define xmlGenericError XML_GLOBAL_MACRO(xmlGenericError)
  |  |  ------------------
  |  |  |  |  500|      0|  #define XML_GLOBAL_MACRO(name) (*__##name())
  |  |  ------------------
  ------------------
              	    xmlGenericError(xmlGenericErrorContext,
  ------------------
  |  |  876|      0|  #define xmlGenericErrorContext XML_GLOBAL_MACRO(xmlGenericErrorContext)
  |  |  ------------------
  |  |  |  |  500|      0|  #define XML_GLOBAL_MACRO(name) (*__##name())
  |  |  ------------------
  ------------------
 2451|      0|		    "%s(%d): ", ctxt->input->filename,
 2452|      0|		    ctxt->input->line);
 2453|      0|	xmlGenericError(xmlGenericErrorContext,
  ------------------
  |  |  875|      0|  #define xmlGenericError XML_GLOBAL_MACRO(xmlGenericError)
  |  |  ------------------
  |  |  |  |  500|      0|  #define XML_GLOBAL_MACRO(name) (*__##name())
  |  |  ------------------
  ------------------
              	xmlGenericError(xmlGenericErrorContext,
  ------------------
  |  |  876|      0|  #define xmlGenericErrorContext XML_GLOBAL_MACRO(xmlGenericErrorContext)
  |  |  ------------------
  |  |  |  |  500|      0|  #define XML_GLOBAL_MACRO(name) (*__##name())
  |  |  ------------------
  ------------------
 2454|      0|		"Pushing input %d : %.30s\n", ctxt->inputNr+1, input->cur);
 2455|      0|    }
 2456|   137k|    if (((ctxt->inputNr > 40) && ((ctxt->options & XML_PARSE_HUGE) == 0)) ||
  ------------------
  |  Branch (2456:10): [True: 0, False: 137k]
  |  Branch (2456:34): [True: 0, False: 0]
  ------------------
 2457|   137k|        (ctxt->inputNr > 100)) {
  ------------------
  |  Branch (2457:9): [True: 0, False: 137k]
  ------------------
 2458|      0|        xmlFatalErr(ctxt, XML_ERR_ENTITY_LOOP, NULL);
 2459|      0|        while (ctxt->inputNr > 1)
  ------------------
  |  Branch (2459:16): [True: 0, False: 0]
  ------------------
 2460|      0|            xmlFreeInputStream(inputPop(ctxt));
 2461|      0|	return(-1);
 2462|      0|    }
 2463|   137k|    ret = inputPush(ctxt, input);
 2464|   137k|    if (ctxt->instate == XML_PARSER_EOF)
  ------------------
  |  Branch (2464:9): [True: 0, False: 137k]
  ------------------
 2465|      0|        return(-1);
 2466|   137k|    GROW;
  ------------------
  |  | 2270|   137k|#define GROW if (ctxt->input->end - ctxt->input->cur < INPUT_CHUNK)	\
  |  |  ------------------
  |  |  |  |   97|   137k|#define INPUT_CHUNK	250
  |  |  ------------------
  |  |  |  Branch (2270:18): [True: 137k, False: 188]
  |  |  ------------------
  |  | 2271|   137k|	xmlParserGrow(ctxt);
  ------------------
 2467|   137k|    return(ret);
 2468|   137k|}
xmlParseCharRef:
 2488|    408|xmlParseCharRef(xmlParserCtxtPtr ctxt) {
 2489|    408|    int val = 0;
 2490|    408|    int count = 0;
 2491|       |
 2492|       |    /*
 2493|       |     * Using RAW/CUR/NEXT is okay since we are working on ASCII range here
 2494|       |     */
 2495|    408|    if ((RAW == '&') && (NXT(1) == '#') &&
  ------------------
  |  | 2221|    408|#define RAW (*ctxt->input->cur)
  ------------------
                  if ((RAW == '&') && (NXT(1) == '#') &&
  ------------------
  |  | 2223|    408|#define NXT(val) ctxt->input->cur[(val)]
  ------------------
  |  Branch (2495:9): [True: 408, False: 0]
  |  Branch (2495:25): [True: 408, False: 0]
  ------------------
 2496|    408|        (NXT(2) == 'x')) {
  ------------------
  |  | 2223|    408|#define NXT(val) ctxt->input->cur[(val)]
  ------------------
  |  Branch (2496:9): [True: 92, False: 316]
  ------------------
 2497|     92|	SKIP(3);
  ------------------
  |  | 2245|     92|#define SKIP(val) do {							\
  |  | 2246|     92|    ctxt->input->cur += (val),ctxt->input->col+=(val);			\
  |  | 2247|     92|    if (*ctxt->input->cur == 0)						\
  |  |  ------------------
  |  |  |  Branch (2247:9): [True: 0, False: 92]
  |  |  ------------------
  |  | 2248|     92|        xmlParserGrow(ctxt);						\
  |  | 2249|     92|  } while (0)
  |  |  ------------------
  |  |  |  Branch (2249:12): [Folded - Ignored]
  |  |  ------------------
  ------------------
 2498|     92|	GROW;
  ------------------
  |  | 2270|     92|#define GROW if (ctxt->input->end - ctxt->input->cur < INPUT_CHUNK)	\
  |  |  ------------------
  |  |  |  |   97|     92|#define INPUT_CHUNK	250
  |  |  ------------------
  |  |  |  Branch (2270:18): [True: 83, False: 9]
  |  |  ------------------
  |  | 2271|     92|	xmlParserGrow(ctxt);
  ------------------
 2499|    216|	while (RAW != ';') { /* loop blocked by count */
  ------------------
  |  | 2221|    216|#define RAW (*ctxt->input->cur)
  ------------------
  |  Branch (2499:9): [True: 124, False: 92]
  ------------------
 2500|    124|	    if (count++ > 20) {
  ------------------
  |  Branch (2500:10): [True: 0, False: 124]
  ------------------
 2501|      0|		count = 0;
 2502|      0|		GROW;
  ------------------
  |  | 2270|      0|#define GROW if (ctxt->input->end - ctxt->input->cur < INPUT_CHUNK)	\
  |  |  ------------------
  |  |  |  |   97|      0|#define INPUT_CHUNK	250
  |  |  ------------------
  |  |  |  Branch (2270:18): [True: 0, False: 0]
  |  |  ------------------
  |  | 2271|      0|	xmlParserGrow(ctxt);
  ------------------
 2503|      0|                if (ctxt->instate == XML_PARSER_EOF)
  ------------------
  |  Branch (2503:21): [True: 0, False: 0]
  ------------------
 2504|      0|                    return(0);
 2505|      0|	    }
 2506|    124|	    if ((RAW >= '0') && (RAW <= '9'))
  ------------------
  |  | 2221|    124|#define RAW (*ctxt->input->cur)
  ------------------
              	    if ((RAW >= '0') && (RAW <= '9'))
  ------------------
  |  | 2221|    124|#define RAW (*ctxt->input->cur)
  ------------------
  |  Branch (2506:10): [True: 124, False: 0]
  |  Branch (2506:26): [True: 56, False: 68]
  ------------------
 2507|     56|	        val = val * 16 + (CUR - '0');
  ------------------
  |  | 2222|     56|#define CUR (*ctxt->input->cur)
  ------------------
 2508|     68|	    else if ((RAW >= 'a') && (RAW <= 'f') && (count < 20))
  ------------------
  |  | 2221|     68|#define RAW (*ctxt->input->cur)
  ------------------
              	    else if ((RAW >= 'a') && (RAW <= 'f') && (count < 20))
  ------------------
  |  | 2221|     64|#define RAW (*ctxt->input->cur)
  ------------------
  |  Branch (2508:15): [True: 64, False: 4]
  |  Branch (2508:31): [True: 64, False: 0]
  |  Branch (2508:47): [True: 64, False: 0]
  ------------------
 2509|     64|	        val = val * 16 + (CUR - 'a') + 10;
  ------------------
  |  | 2222|     64|#define CUR (*ctxt->input->cur)
  ------------------
 2510|      4|	    else if ((RAW >= 'A') && (RAW <= 'F') && (count < 20))
  ------------------
  |  | 2221|      4|#define RAW (*ctxt->input->cur)
  ------------------
              	    else if ((RAW >= 'A') && (RAW <= 'F') && (count < 20))
  ------------------
  |  | 2221|      4|#define RAW (*ctxt->input->cur)
  ------------------
  |  Branch (2510:15): [True: 4, False: 0]
  |  Branch (2510:31): [True: 4, False: 0]
  |  Branch (2510:47): [True: 4, False: 0]
  ------------------
 2511|      4|	        val = val * 16 + (CUR - 'A') + 10;
  ------------------
  |  | 2222|      4|#define CUR (*ctxt->input->cur)
  ------------------
 2512|      0|	    else {
 2513|      0|		xmlFatalErr(ctxt, XML_ERR_INVALID_HEX_CHARREF, NULL);
 2514|      0|		val = 0;
 2515|      0|		break;
 2516|      0|	    }
 2517|    124|	    if (val > 0x110000)
  ------------------
  |  Branch (2517:10): [True: 0, False: 124]
  ------------------
 2518|      0|	        val = 0x110000;
 2519|       |
 2520|    124|	    NEXT;
  ------------------
  |  | 2275|    124|#define NEXT xmlNextChar(ctxt)
  ------------------
 2521|    124|	    count++;
 2522|    124|	}
 2523|     92|	if (RAW == ';') {
  ------------------
  |  | 2221|     92|#define RAW (*ctxt->input->cur)
  ------------------
  |  Branch (2523:6): [True: 92, False: 0]
  ------------------
 2524|       |	    /* on purpose to avoid reentrancy problems with NEXT and SKIP */
 2525|     92|	    ctxt->input->col++;
 2526|     92|	    ctxt->input->cur++;
 2527|     92|	}
 2528|    316|    } else if  ((RAW == '&') && (NXT(1) == '#')) {
  ------------------
  |  | 2221|    316|#define RAW (*ctxt->input->cur)
  ------------------
                  } else if  ((RAW == '&') && (NXT(1) == '#')) {
  ------------------
  |  | 2223|    316|#define NXT(val) ctxt->input->cur[(val)]
  ------------------
  |  Branch (2528:17): [True: 316, False: 0]
  |  Branch (2528:33): [True: 316, False: 0]
  ------------------
 2529|    316|	SKIP(2);
  ------------------
  |  | 2245|    316|#define SKIP(val) do {							\
  |  | 2246|    316|    ctxt->input->cur += (val),ctxt->input->col+=(val);			\
  |  | 2247|    316|    if (*ctxt->input->cur == 0)						\
  |  |  ------------------
  |  |  |  Branch (2247:9): [True: 0, False: 316]
  |  |  ------------------
  |  | 2248|    316|        xmlParserGrow(ctxt);						\
  |  | 2249|    316|  } while (0)
  |  |  ------------------
  |  |  |  Branch (2249:12): [Folded - Ignored]
  |  |  ------------------
  ------------------
 2530|    316|	GROW;
  ------------------
  |  | 2270|    316|#define GROW if (ctxt->input->end - ctxt->input->cur < INPUT_CHUNK)	\
  |  |  ------------------
  |  |  |  |   97|    316|#define INPUT_CHUNK	250
  |  |  ------------------
  |  |  |  Branch (2270:18): [True: 207, False: 109]
  |  |  ------------------
  |  | 2271|    316|	xmlParserGrow(ctxt);
  ------------------
 2531|  1.38k|	while (RAW != ';') { /* loop blocked by count */
  ------------------
  |  | 2221|  1.38k|#define RAW (*ctxt->input->cur)
  ------------------
  |  Branch (2531:9): [True: 1.07k, False: 316]
  ------------------
 2532|  1.07k|	    if (count++ > 20) {
  ------------------
  |  Branch (2532:10): [True: 16, False: 1.05k]
  ------------------
 2533|     16|		count = 0;
 2534|     16|		GROW;
  ------------------
  |  | 2270|     16|#define GROW if (ctxt->input->end - ctxt->input->cur < INPUT_CHUNK)	\
  |  |  ------------------
  |  |  |  |   97|     16|#define INPUT_CHUNK	250
  |  |  ------------------
  |  |  |  Branch (2270:18): [True: 16, False: 0]
  |  |  ------------------
  |  | 2271|     16|	xmlParserGrow(ctxt);
  ------------------
 2535|     16|                if (ctxt->instate == XML_PARSER_EOF)
  ------------------
  |  Branch (2535:21): [True: 0, False: 16]
  ------------------
 2536|      0|                    return(0);
 2537|     16|	    }
 2538|  1.07k|	    if ((RAW >= '0') && (RAW <= '9'))
  ------------------
  |  | 2221|  1.07k|#define RAW (*ctxt->input->cur)
  ------------------
              	    if ((RAW >= '0') && (RAW <= '9'))
  ------------------
  |  | 2221|  1.07k|#define RAW (*ctxt->input->cur)
  ------------------
  |  Branch (2538:10): [True: 1.07k, False: 0]
  |  Branch (2538:26): [True: 1.07k, False: 0]
  ------------------
 2539|  1.07k|	        val = val * 10 + (CUR - '0');
  ------------------
  |  | 2222|  1.07k|#define CUR (*ctxt->input->cur)
  ------------------
 2540|      0|	    else {
 2541|      0|		xmlFatalErr(ctxt, XML_ERR_INVALID_DEC_CHARREF, NULL);
 2542|      0|		val = 0;
 2543|      0|		break;
 2544|      0|	    }
 2545|  1.07k|	    if (val > 0x110000)
  ------------------
  |  Branch (2545:10): [True: 184, False: 888]
  ------------------
 2546|    184|	        val = 0x110000;
 2547|       |
 2548|  1.07k|	    NEXT;
  ------------------
  |  | 2275|  1.07k|#define NEXT xmlNextChar(ctxt)
  ------------------
 2549|  1.07k|	    count++;
 2550|  1.07k|	}
 2551|    316|	if (RAW == ';') {
  ------------------
  |  | 2221|    316|#define RAW (*ctxt->input->cur)
  ------------------
  |  Branch (2551:6): [True: 316, False: 0]
  ------------------
 2552|       |	    /* on purpose to avoid reentrancy problems with NEXT and SKIP */
 2553|    316|	    ctxt->input->col++;
 2554|    316|	    ctxt->input->cur++;
 2555|    316|	}
 2556|    316|    } else {
 2557|      0|        if (RAW == '&')
  ------------------
  |  | 2221|      0|#define RAW (*ctxt->input->cur)
  ------------------
  |  Branch (2557:13): [True: 0, False: 0]
  ------------------
 2558|      0|            SKIP(1);
  ------------------
  |  | 2245|      0|#define SKIP(val) do {							\
  |  | 2246|      0|    ctxt->input->cur += (val),ctxt->input->col+=(val);			\
  |  | 2247|      0|    if (*ctxt->input->cur == 0)						\
  |  |  ------------------
  |  |  |  Branch (2247:9): [True: 0, False: 0]
  |  |  ------------------
  |  | 2248|      0|        xmlParserGrow(ctxt);						\
  |  | 2249|      0|  } while (0)
  |  |  ------------------
  |  |  |  Branch (2249:12): [Folded - Ignored]
  |  |  ------------------
  ------------------
 2559|      0|        xmlFatalErr(ctxt, XML_ERR_INVALID_CHARREF, NULL);
 2560|      0|    }
 2561|       |
 2562|       |    /*
 2563|       |     * [ WFC: Legal Character ]
 2564|       |     * Characters referred to using character references must match the
 2565|       |     * production for Char.
 2566|       |     */
 2567|    408|    if (val >= 0x110000) {
  ------------------
  |  Branch (2567:9): [True: 4, False: 404]
  ------------------
 2568|      4|        xmlFatalErrMsgInt(ctxt, XML_ERR_INVALID_CHAR,
 2569|      4|                "xmlParseCharRef: character reference out of bounds\n",
 2570|      4|	        val);
 2571|    404|    } else if (IS_CHAR(val)) {
  ------------------
  |  |  125|    404|#define IS_CHAR(c)   xmlIsCharQ(c)
  |  |  ------------------
  |  |  |  |  118|    404|#define xmlIsCharQ(c)		(((c) < 0x100) ? \
  |  |  |  |  ------------------
  |  |  |  |  |  Branch (118:24): [True: 404, False: 0]
  |  |  |  |  |  Branch (118:25): [True: 404, False: 0]
  |  |  |  |  ------------------
  |  |  |  |  119|    404|				 xmlIsChar_ch((c)) :\
  |  |  |  |  ------------------
  |  |  |  |  |  |  108|    404|#define xmlIsChar_ch(c)		(((0x9 <= (c)) && ((c) <= 0xa)) || \
  |  |  |  |  |  |  ------------------
  |  |  |  |  |  |  |  Branch (108:28): [True: 404, False: 0]
  |  |  |  |  |  |  |  Branch (108:44): [True: 52, False: 352]
  |  |  |  |  |  |  ------------------
  |  |  |  |  |  |  109|    404|				 ((c) == 0xd) || \
  |  |  |  |  |  |  ------------------
  |  |  |  |  |  |  |  Branch (109:6): [True: 36, False: 316]
  |  |  |  |  |  |  ------------------
  |  |  |  |  |  |  110|    404|				  (0x20 <= (c)))
  |  |  |  |  |  |  ------------------
  |  |  |  |  |  |  |  Branch (110:7): [True: 316, False: 0]
  |  |  |  |  |  |  ------------------
  |  |  |  |  ------------------
  |  |  |  |  120|    404|				(((0x100 <= (c)) && ((c) <= 0xd7ff)) || \
  |  |  |  |  ------------------
  |  |  |  |  |  Branch (120:7): [True: 0, False: 0]
  |  |  |  |  |  Branch (120:25): [True: 0, False: 0]
  |  |  |  |  ------------------
  |  |  |  |  121|      0|				 ((0xe000 <= (c)) && ((c) <= 0xfffd)) || \
  |  |  |  |  ------------------
  |  |  |  |  |  Branch (121:7): [True: 0, False: 0]
  |  |  |  |  |  Branch (121:26): [True: 0, False: 0]
  |  |  |  |  ------------------
  |  |  |  |  122|      0|				 ((0x10000 <= (c)) && ((c) <= 0x10ffff))))
  |  |  |  |  ------------------
  |  |  |  |  |  Branch (122:7): [True: 0, False: 0]
  |  |  |  |  |  Branch (122:27): [True: 0, False: 0]
  |  |  |  |  ------------------
  |  |  ------------------
  ------------------
 2572|    404|        return(val);
 2573|    404|    } else {
 2574|      0|        xmlFatalErrMsgInt(ctxt, XML_ERR_INVALID_CHAR,
 2575|      0|                          "xmlParseCharRef: invalid xmlChar value %d\n",
 2576|      0|	                  val);
 2577|      0|    }
 2578|      4|    return(0);
 2579|    408|}
xmlSplitQName:
 3152|  7.78k|xmlSplitQName(xmlParserCtxtPtr ctxt, const xmlChar *name, xmlChar **prefix) {
 3153|  7.78k|    xmlChar buf[XML_MAX_NAMELEN + 5];
 3154|  7.78k|    xmlChar *buffer = NULL;
 3155|  7.78k|    int len = 0;
 3156|  7.78k|    int max = XML_MAX_NAMELEN;
  ------------------
  |  |   89|  7.78k|#define XML_MAX_NAMELEN 100
  ------------------
 3157|  7.78k|    xmlChar *ret = NULL;
 3158|  7.78k|    const xmlChar *cur = name;
 3159|  7.78k|    int c;
 3160|       |
 3161|  7.78k|    if (prefix == NULL) return(NULL);
  ------------------
  |  Branch (3161:9): [True: 0, False: 7.78k]
  ------------------
 3162|  7.78k|    *prefix = NULL;
 3163|       |
 3164|  7.78k|    if (cur == NULL) return(NULL);
  ------------------
  |  Branch (3164:9): [True: 0, False: 7.78k]
  ------------------
 3165|       |
 3166|       |#ifndef XML_XML_NAMESPACE
 3167|       |    /* xml: prefix is not really a namespace */
 3168|       |    if ((cur[0] == 'x') && (cur[1] == 'm') &&
 3169|       |        (cur[2] == 'l') && (cur[3] == ':'))
 3170|       |	return(xmlStrdup(name));
 3171|       |#endif
 3172|       |
 3173|       |    /* nasty but well=formed */
 3174|  7.78k|    if (cur[0] == ':')
  ------------------
  |  Branch (3174:9): [True: 0, False: 7.78k]
  ------------------
 3175|      0|	return(xmlStrdup(name));
 3176|       |
 3177|  7.78k|    c = *cur++;
 3178|  45.5k|    while ((c != 0) && (c != ':') && (len < max)) { /* tested bigname.xml */
  ------------------
  |  Branch (3178:12): [True: 38.0k, False: 7.46k]
  |  Branch (3178:24): [True: 37.7k, False: 312]
  |  Branch (3178:38): [True: 37.7k, False: 0]
  ------------------
 3179|  37.7k|	buf[len++] = c;
 3180|  37.7k|	c = *cur++;
 3181|  37.7k|    }
 3182|  7.78k|    if (len >= max) {
  ------------------
  |  Branch (3182:9): [True: 0, False: 7.78k]
  ------------------
 3183|       |	/*
 3184|       |	 * Okay someone managed to make a huge name, so he's ready to pay
 3185|       |	 * for the processing speed.
 3186|       |	 */
 3187|      0|	max = len * 2;
 3188|       |
 3189|      0|	buffer = (xmlChar *) xmlMallocAtomic(max);
 3190|      0|	if (buffer == NULL) {
  ------------------
  |  Branch (3190:6): [True: 0, False: 0]
  ------------------
 3191|      0|	    xmlErrMemory(ctxt, NULL);
 3192|      0|	    return(NULL);
 3193|      0|	}
 3194|      0|	memcpy(buffer, buf, len);
 3195|      0|	while ((c != 0) && (c != ':')) { /* tested bigname.xml */
  ------------------
  |  Branch (3195:9): [True: 0, False: 0]
  |  Branch (3195:21): [True: 0, False: 0]
  ------------------
 3196|      0|	    if (len + 10 > max) {
  ------------------
  |  Branch (3196:10): [True: 0, False: 0]
  ------------------
 3197|      0|	        xmlChar *tmp;
 3198|       |
 3199|      0|		max *= 2;
 3200|      0|		tmp = (xmlChar *) xmlRealloc(buffer, max);
 3201|      0|		if (tmp == NULL) {
  ------------------
  |  Branch (3201:7): [True: 0, False: 0]
  ------------------
 3202|      0|		    xmlFree(buffer);
 3203|      0|		    xmlErrMemory(ctxt, NULL);
 3204|      0|		    return(NULL);
 3205|      0|		}
 3206|      0|		buffer = tmp;
 3207|      0|	    }
 3208|      0|	    buffer[len++] = c;
 3209|      0|	    c = *cur++;
 3210|      0|	}
 3211|      0|	buffer[len] = 0;
 3212|      0|    }
 3213|       |
 3214|  7.78k|    if ((c == ':') && (*cur == 0)) {
  ------------------
  |  Branch (3214:9): [True: 312, False: 7.46k]
  |  Branch (3214:23): [True: 0, False: 312]
  ------------------
 3215|      0|        if (buffer != NULL)
  ------------------
  |  Branch (3215:13): [True: 0, False: 0]
  ------------------
 3216|      0|	    xmlFree(buffer);
 3217|      0|	*prefix = NULL;
 3218|      0|	return(xmlStrdup(name));
 3219|      0|    }
 3220|       |
 3221|  7.78k|    if (buffer == NULL)
  ------------------
  |  Branch (3221:9): [True: 7.78k, False: 0]
  ------------------
 3222|  7.78k|	ret = xmlStrndup(buf, len);
 3223|      0|    else {
 3224|      0|	ret = buffer;
 3225|      0|	buffer = NULL;
 3226|      0|	max = XML_MAX_NAMELEN;
  ------------------
  |  |   89|      0|#define XML_MAX_NAMELEN 100
  ------------------
 3227|      0|    }
 3228|       |
 3229|       |
 3230|  7.78k|    if (c == ':') {
  ------------------
  |  Branch (3230:9): [True: 312, False: 7.46k]
  ------------------
 3231|    312|	c = *cur;
 3232|    312|        *prefix = ret;
 3233|    312|	if (c == 0) {
  ------------------
  |  Branch (3233:6): [True: 0, False: 312]
  ------------------
 3234|      0|	    return(xmlStrndup(BAD_CAST "", 0));
  ------------------
  |  |   35|      0|#define BAD_CAST (xmlChar *)
  ------------------
 3235|      0|	}
 3236|    312|	len = 0;
 3237|       |
 3238|       |	/*
 3239|       |	 * Check that the first character is proper to start
 3240|       |	 * a new name
 3241|       |	 */
 3242|    312|	if (!(((c >= 0x61) && (c <= 0x7A)) ||
  ------------------
  |  Branch (3242:9): [True: 312, False: 0]
  |  Branch (3242:24): [True: 312, False: 0]
  ------------------
 3243|    312|	      ((c >= 0x41) && (c <= 0x5A)) ||
  ------------------
  |  Branch (3243:9): [True: 0, False: 0]
  |  Branch (3243:24): [True: 0, False: 0]
  ------------------
 3244|    312|	      (c == '_') || (c == ':'))) {
  ------------------
  |  Branch (3244:8): [True: 0, False: 0]
  |  Branch (3244:22): [True: 0, False: 0]
  ------------------
 3245|      0|	    int l;
 3246|      0|	    int first = CUR_SCHAR(cur, l);
  ------------------
  |  | 2292|      0|#define CUR_SCHAR(s, l) xmlStringCurrentChar(ctxt, s, &l)
  ------------------
 3247|       |
 3248|      0|	    if (!IS_LETTER(first) && (first != '_')) {
  ------------------
  |  |  240|      0|#define IS_LETTER(c) (IS_BASECHAR(c) || IS_IDEOGRAPHIC(c))
  |  |  ------------------
  |  |  |  |  161|      0|#define IS_BASECHAR(c) xmlIsBaseCharQ(c)
  |  |  |  |  ------------------
  |  |  |  |  |  |   76|      0|#define xmlIsBaseCharQ(c)	(((c) < 0x100) ? \
  |  |  |  |  |  |  ------------------
  |  |  |  |  |  |  |  Branch (76:27): [True: 0, False: 0]
  |  |  |  |  |  |  |  Branch (76:28): [True: 0, False: 0]
  |  |  |  |  |  |  ------------------
  |  |  |  |  |  |   77|      0|				 xmlIsBaseChar_ch((c)) : \
  |  |  |  |  |  |  ------------------
  |  |  |  |  |  |  |  |   64|      0|#define xmlIsBaseChar_ch(c)	(((0x41 <= (c)) && ((c) <= 0x5a)) || \
  |  |  |  |  |  |  |  |  ------------------
  |  |  |  |  |  |  |  |  |  Branch (64:31): [True: 0, False: 0]
  |  |  |  |  |  |  |  |  |  Branch (64:48): [True: 0, False: 0]
  |  |  |  |  |  |  |  |  ------------------
  |  |  |  |  |  |  |  |   65|      0|				 ((0x61 <= (c)) && ((c) <= 0x7a)) || \
  |  |  |  |  |  |  |  |  ------------------
  |  |  |  |  |  |  |  |  |  Branch (65:7): [True: 0, False: 0]
  |  |  |  |  |  |  |  |  |  Branch (65:24): [True: 0, False: 0]
  |  |  |  |  |  |  |  |  ------------------
  |  |  |  |  |  |  |  |   66|      0|				 ((0xc0 <= (c)) && ((c) <= 0xd6)) || \
  |  |  |  |  |  |  |  |  ------------------
  |  |  |  |  |  |  |  |  |  Branch (66:7): [True: 0, False: 0]
  |  |  |  |  |  |  |  |  |  Branch (66:24): [True: 0, False: 0]
  |  |  |  |  |  |  |  |  ------------------
  |  |  |  |  |  |  |  |   67|      0|				 ((0xd8 <= (c)) && ((c) <= 0xf6)) || \
  |  |  |  |  |  |  |  |  ------------------
  |  |  |  |  |  |  |  |  |  Branch (67:7): [True: 0, False: 0]
  |  |  |  |  |  |  |  |  |  Branch (67:24): [True: 0, False: 0]
  |  |  |  |  |  |  |  |  ------------------
  |  |  |  |  |  |  |  |   68|      0|				  (0xf8 <= (c)))
  |  |  |  |  |  |  |  |  ------------------
  |  |  |  |  |  |  |  |  |  Branch (68:7): [True: 0, False: 0]
  |  |  |  |  |  |  |  |  ------------------
  |  |  |  |  |  |  ------------------
  |  |  |  |  |  |   78|      0|				 xmlCharInRange((c), &xmlIsBaseCharGroup))
  |  |  |  |  ------------------
  |  |  ------------------
  |  |               #define IS_LETTER(c) (IS_BASECHAR(c) || IS_IDEOGRAPHIC(c))
  |  |  ------------------
  |  |  |  |  229|      0|#define IS_IDEOGRAPHIC(c) xmlIsIdeographicQ(c)
  |  |  |  |  ------------------
  |  |  |  |  |  |  184|      0|#define xmlIsIdeographicQ(c)	(((c) < 0x100) ? \
  |  |  |  |  |  |  ------------------
  |  |  |  |  |  |  |  Branch (184:30): [True: 0, False: 0]
  |  |  |  |  |  |  |  Branch (184:31): [True: 0, False: 0]
  |  |  |  |  |  |  ------------------
  |  |  |  |  |  |  185|      0|				 0 :\
  |  |  |  |  |  |  186|      0|				(((0x4e00 <= (c)) && ((c) <= 0x9fa5)) || \
  |  |  |  |  |  |  ------------------
  |  |  |  |  |  |  |  Branch (186:7): [True: 0, False: 0]
  |  |  |  |  |  |  |  Branch (186:26): [True: 0, False: 0]
  |  |  |  |  |  |  ------------------
  |  |  |  |  |  |  187|      0|				 ((c) == 0x3007) || \
  |  |  |  |  |  |  ------------------
  |  |  |  |  |  |  |  Branch (187:6): [True: 0, False: 0]
  |  |  |  |  |  |  ------------------
  |  |  |  |  |  |  188|      0|				 ((0x3021 <= (c)) && ((c) <= 0x3029))))
  |  |  |  |  |  |  ------------------
  |  |  |  |  |  |  |  Branch (188:7): [True: 0, False: 0]
  |  |  |  |  |  |  |  Branch (188:26): [True: 0, False: 0]
  |  |  |  |  |  |  ------------------
  |  |  |  |  ------------------
  |  |  ------------------
  ------------------
  |  Branch (3248:31): [True: 0, False: 0]
  ------------------
 3249|      0|		xmlFatalErrMsgStr(ctxt, XML_NS_ERR_QNAME,
 3250|      0|			    "Name %s is not XML Namespace compliant\n",
 3251|      0|				  name);
 3252|      0|	    }
 3253|      0|	}
 3254|    312|	cur++;
 3255|       |
 3256|  1.50k|	while ((c != 0) && (len < max)) { /* tested bigname2.xml */
  ------------------
  |  Branch (3256:9): [True: 1.19k, False: 312]
  |  Branch (3256:21): [True: 1.19k, False: 0]
  ------------------
 3257|  1.19k|	    buf[len++] = c;
 3258|  1.19k|	    c = *cur++;
 3259|  1.19k|	}
 3260|    312|	if (len >= max) {
  ------------------
  |  Branch (3260:6): [True: 0, False: 312]
  ------------------
 3261|       |	    /*
 3262|       |	     * Okay someone managed to make a huge name, so he's ready to pay
 3263|       |	     * for the processing speed.
 3264|       |	     */
 3265|      0|	    max = len * 2;
 3266|       |
 3267|      0|	    buffer = (xmlChar *) xmlMallocAtomic(max);
 3268|      0|	    if (buffer == NULL) {
  ------------------
  |  Branch (3268:10): [True: 0, False: 0]
  ------------------
 3269|      0|	        xmlErrMemory(ctxt, NULL);
 3270|      0|		return(NULL);
 3271|      0|	    }
 3272|      0|	    memcpy(buffer, buf, len);
 3273|      0|	    while (c != 0) { /* tested bigname2.xml */
  ------------------
  |  Branch (3273:13): [True: 0, False: 0]
  ------------------
 3274|      0|		if (len + 10 > max) {
  ------------------
  |  Branch (3274:7): [True: 0, False: 0]
  ------------------
 3275|      0|		    xmlChar *tmp;
 3276|       |
 3277|      0|		    max *= 2;
 3278|      0|		    tmp = (xmlChar *) xmlRealloc(buffer, max);
 3279|      0|		    if (tmp == NULL) {
  ------------------
  |  Branch (3279:11): [True: 0, False: 0]
  ------------------
 3280|      0|			xmlErrMemory(ctxt, NULL);
 3281|      0|			xmlFree(buffer);
 3282|      0|			return(NULL);
 3283|      0|		    }
 3284|      0|		    buffer = tmp;
 3285|      0|		}
 3286|      0|		buffer[len++] = c;
 3287|      0|		c = *cur++;
 3288|      0|	    }
 3289|      0|	    buffer[len] = 0;
 3290|      0|	}
 3291|       |
 3292|    312|	if (buffer == NULL)
  ------------------
  |  Branch (3292:6): [True: 312, False: 0]
  ------------------
 3293|    312|	    ret = xmlStrndup(buf, len);
 3294|      0|	else {
 3295|      0|	    ret = buffer;
 3296|      0|	}
 3297|    312|    }
 3298|       |
 3299|  7.78k|    return(ret);
 3300|  7.78k|}
xmlParseName:
 3524|   183k|xmlParseName(xmlParserCtxtPtr ctxt) {
 3525|   183k|    const xmlChar *in;
 3526|   183k|    const xmlChar *ret;
 3527|   183k|    size_t count = 0;
 3528|   183k|    size_t maxLength = (ctxt->options & XML_PARSE_HUGE) ?
  ------------------
  |  Branch (3528:24): [True: 0, False: 183k]
  ------------------
 3529|      0|                       XML_MAX_TEXT_LENGTH :
  ------------------
  |  |   42|      0|#define XML_MAX_TEXT_LENGTH 10000000
  ------------------
 3530|   183k|                       XML_MAX_NAME_LENGTH;
  ------------------
  |  |   61|   367k|#define XML_MAX_NAME_LENGTH 50000
  ------------------
 3531|       |
 3532|   183k|    GROW;
  ------------------
  |  | 2270|   183k|#define GROW if (ctxt->input->end - ctxt->input->cur < INPUT_CHUNK)	\
  |  |  ------------------
  |  |  |  |   97|   183k|#define INPUT_CHUNK	250
  |  |  ------------------
  |  |  |  Branch (2270:18): [True: 151k, False: 32.1k]
  |  |  ------------------
  |  | 2271|   183k|	xmlParserGrow(ctxt);
  ------------------
 3533|   183k|    if (ctxt->instate == XML_PARSER_EOF)
  ------------------
  |  Branch (3533:9): [True: 0, False: 183k]
  ------------------
 3534|      0|        return(NULL);
 3535|       |
 3536|       |    /*
 3537|       |     * Accelerator for simple ASCII names
 3538|       |     */
 3539|   183k|    in = ctxt->input->cur;
 3540|   183k|    if (((*in >= 0x61) && (*in <= 0x7A)) ||
  ------------------
  |  Branch (3540:10): [True: 179k, False: 3.99k]
  |  Branch (3540:27): [True: 179k, False: 12]
  ------------------
 3541|   183k|	((*in >= 0x41) && (*in <= 0x5A)) ||
  ------------------
  |  Branch (3541:3): [True: 4.00k, False: 8]
  |  Branch (3541:20): [True: 3.98k, False: 12]
  ------------------
 3542|   183k|	(*in == '_') || (*in == ':')) {
  ------------------
  |  Branch (3542:2): [True: 0, False: 20]
  |  Branch (3542:18): [True: 0, False: 20]
  ------------------
 3543|   183k|	in++;
 3544|   782k|	while (((*in >= 0x61) && (*in <= 0x7A)) ||
  ------------------
  |  Branch (3544:10): [True: 300k, False: 482k]
  |  Branch (3544:27): [True: 297k, False: 2.64k]
  ------------------
 3545|   782k|	       ((*in >= 0x41) && (*in <= 0x5A)) ||
  ------------------
  |  Branch (3545:10): [True: 126k, False: 358k]
  |  Branch (3545:27): [True: 2.27k, False: 123k]
  ------------------
 3546|   782k|	       ((*in >= 0x30) && (*in <= 0x39)) ||
  ------------------
  |  Branch (3546:10): [True: 456k, False: 26.2k]
  |  Branch (3546:27): [True: 172k, False: 283k]
  ------------------
 3547|   782k|	       (*in == '_') || (*in == '-') ||
  ------------------
  |  Branch (3547:9): [True: 121k, False: 188k]
  |  Branch (3547:25): [True: 1.32k, False: 187k]
  ------------------
 3548|   782k|	       (*in == ':') || (*in == '.'))
  ------------------
  |  Branch (3548:9): [True: 638, False: 186k]
  |  Branch (3548:25): [True: 3.14k, False: 183k]
  ------------------
 3549|   599k|	    in++;
 3550|   183k|	if ((*in > 0) && (*in < 0x80)) {
  ------------------
  |  Branch (3550:6): [True: 183k, False: 70]
  |  Branch (3550:19): [True: 183k, False: 136]
  ------------------
 3551|   183k|	    count = in - ctxt->input->cur;
 3552|   183k|            if (count > maxLength) {
  ------------------
  |  Branch (3552:17): [True: 0, False: 183k]
  ------------------
 3553|      0|                xmlFatalErr(ctxt, XML_ERR_NAME_TOO_LONG, "Name");
 3554|      0|                return(NULL);
 3555|      0|            }
 3556|   183k|	    ret = xmlDictLookup(ctxt->dict, ctxt->input->cur, count);
 3557|   183k|	    ctxt->input->cur = in;
 3558|   183k|	    ctxt->input->col += count;
 3559|   183k|	    if (ret == NULL)
  ------------------
  |  Branch (3559:10): [True: 0, False: 183k]
  ------------------
 3560|      0|	        xmlErrMemory(ctxt, NULL);
 3561|   183k|	    return(ret);
 3562|   183k|	}
 3563|   183k|    }
 3564|       |    /* accelerator for special cases */
 3565|    226|    return(xmlParseNameComplex(ctxt));
 3566|   183k|}
xmlParseNmtoken:
 3816|  2.76k|xmlParseNmtoken(xmlParserCtxtPtr ctxt) {
 3817|  2.76k|    xmlChar buf[XML_MAX_NAMELEN + 5];
 3818|  2.76k|    int len = 0, l;
 3819|  2.76k|    int c;
 3820|  2.76k|    int maxLength = (ctxt->options & XML_PARSE_HUGE) ?
  ------------------
  |  Branch (3820:21): [True: 0, False: 2.76k]
  ------------------
 3821|      0|                    XML_MAX_TEXT_LENGTH :
  ------------------
  |  |   42|      0|#define XML_MAX_TEXT_LENGTH 10000000
  ------------------
 3822|  2.76k|                    XML_MAX_NAME_LENGTH;
  ------------------
  |  |   61|  2.76k|#define XML_MAX_NAME_LENGTH 50000
  ------------------
 3823|       |
 3824|  2.76k|    c = CUR_CHAR(l);
  ------------------
  |  | 2291|  2.76k|#define CUR_CHAR(l) xmlCurrentChar(ctxt, &l)
  ------------------
 3825|       |
 3826|  11.4k|    while (xmlIsNameChar(ctxt, c)) {
  ------------------
  |  Branch (3826:12): [True: 8.65k, False: 2.76k]
  ------------------
 3827|  8.65k|	COPY_BUF(buf, len, c);
  ------------------
  |  | 2295|  8.65k|    if (v < 0x80) b[i++] = v;						\
  |  |  ------------------
  |  |  |  Branch (2295:9): [True: 8.65k, False: 0]
  |  |  ------------------
  |  | 2296|  8.65k|    else i += xmlCopyCharMultiByte(&b[i],v)
  ------------------
 3828|  8.65k|	NEXTL(l);
  ------------------
  |  | 2284|  8.65k|#define NEXTL(l) do {							\
  |  | 2285|  8.65k|    if (*(ctxt->input->cur) == '\n') {					\
  |  |  ------------------
  |  |  |  Branch (2285:9): [True: 0, False: 8.65k]
  |  |  ------------------
  |  | 2286|      0|	ctxt->input->line++; ctxt->input->col = 1;			\
  |  | 2287|  8.65k|    } else ctxt->input->col++;						\
  |  | 2288|  8.65k|    ctxt->input->cur += l;				\
  |  | 2289|  8.65k|  } while (0)
  |  |  ------------------
  |  |  |  Branch (2289:12): [Folded - Ignored]
  |  |  ------------------
  ------------------
 3829|  8.65k|	c = CUR_CHAR(l);
  ------------------
  |  | 2291|  8.65k|#define CUR_CHAR(l) xmlCurrentChar(ctxt, &l)
  ------------------
 3830|  8.65k|	if (len >= XML_MAX_NAMELEN) {
  ------------------
  |  |   89|  8.65k|#define XML_MAX_NAMELEN 100
  ------------------
  |  Branch (3830:6): [True: 0, False: 8.65k]
  ------------------
 3831|       |	    /*
 3832|       |	     * Okay someone managed to make a huge token, so he's ready to pay
 3833|       |	     * for the processing speed.
 3834|       |	     */
 3835|      0|	    xmlChar *buffer;
 3836|      0|	    int max = len * 2;
 3837|       |
 3838|      0|	    buffer = (xmlChar *) xmlMallocAtomic(max);
 3839|      0|	    if (buffer == NULL) {
  ------------------
  |  Branch (3839:10): [True: 0, False: 0]
  ------------------
 3840|      0|	        xmlErrMemory(ctxt, NULL);
 3841|      0|		return(NULL);
 3842|      0|	    }
 3843|      0|	    memcpy(buffer, buf, len);
 3844|      0|	    while (xmlIsNameChar(ctxt, c)) {
  ------------------
  |  Branch (3844:13): [True: 0, False: 0]
  ------------------
 3845|      0|		if (len + 10 > max) {
  ------------------
  |  Branch (3845:7): [True: 0, False: 0]
  ------------------
 3846|      0|		    xmlChar *tmp;
 3847|       |
 3848|      0|		    max *= 2;
 3849|      0|		    tmp = (xmlChar *) xmlRealloc(buffer, max);
 3850|      0|		    if (tmp == NULL) {
  ------------------
  |  Branch (3850:11): [True: 0, False: 0]
  ------------------
 3851|      0|			xmlErrMemory(ctxt, NULL);
 3852|      0|			xmlFree(buffer);
 3853|      0|			return(NULL);
 3854|      0|		    }
 3855|      0|		    buffer = tmp;
 3856|      0|		}
 3857|      0|		COPY_BUF(buffer, len, c);
  ------------------
  |  | 2295|      0|    if (v < 0x80) b[i++] = v;						\
  |  |  ------------------
  |  |  |  Branch (2295:9): [True: 0, False: 0]
  |  |  ------------------
  |  | 2296|      0|    else i += xmlCopyCharMultiByte(&b[i],v)
  ------------------
 3858|      0|                if (len > maxLength) {
  ------------------
  |  Branch (3858:21): [True: 0, False: 0]
  ------------------
 3859|      0|                    xmlFatalErr(ctxt, XML_ERR_NAME_TOO_LONG, "NmToken");
 3860|      0|                    xmlFree(buffer);
 3861|      0|                    return(NULL);
 3862|      0|                }
 3863|      0|		NEXTL(l);
  ------------------
  |  | 2284|      0|#define NEXTL(l) do {							\
  |  | 2285|      0|    if (*(ctxt->input->cur) == '\n') {					\
  |  |  ------------------
  |  |  |  Branch (2285:9): [True: 0, False: 0]
  |  |  ------------------
  |  | 2286|      0|	ctxt->input->line++; ctxt->input->col = 1;			\
  |  | 2287|      0|    } else ctxt->input->col++;						\
  |  | 2288|      0|    ctxt->input->cur += l;				\
  |  | 2289|      0|  } while (0)
  |  |  ------------------
  |  |  |  Branch (2289:12): [Folded - Ignored]
  |  |  ------------------
  ------------------
 3864|      0|		c = CUR_CHAR(l);
  ------------------
  |  | 2291|      0|#define CUR_CHAR(l) xmlCurrentChar(ctxt, &l)
  ------------------
 3865|      0|	    }
 3866|      0|	    buffer[len] = 0;
 3867|      0|            if (ctxt->instate == XML_PARSER_EOF) {
  ------------------
  |  Branch (3867:17): [True: 0, False: 0]
  ------------------
 3868|      0|                xmlFree(buffer);
 3869|      0|                return(NULL);
 3870|      0|            }
 3871|      0|	    return(buffer);
 3872|      0|	}
 3873|  8.65k|    }
 3874|  2.76k|    if (ctxt->instate == XML_PARSER_EOF)
  ------------------
  |  Branch (3874:9): [True: 0, False: 2.76k]
  ------------------
 3875|      0|        return(NULL);
 3876|  2.76k|    if (len == 0)
  ------------------
  |  Branch (3876:9): [True: 8, False: 2.75k]
  ------------------
 3877|      8|        return(NULL);
 3878|  2.75k|    if (len > maxLength) {
  ------------------
  |  Branch (3878:9): [True: 0, False: 2.75k]
  ------------------
 3879|      0|        xmlFatalErr(ctxt, XML_ERR_NAME_TOO_LONG, "NmToken");
 3880|      0|        return(NULL);
 3881|      0|    }
 3882|  2.75k|    return(xmlStrndup(buf, len));
 3883|  2.75k|}
xmlParseEntityValue:
 3901|  2.26k|xmlParseEntityValue(xmlParserCtxtPtr ctxt, xmlChar **orig) {
 3902|  2.26k|    xmlChar *buf = NULL;
 3903|  2.26k|    int len = 0;
 3904|  2.26k|    int size = XML_PARSER_BUFFER_SIZE;
  ------------------
  |  |  167|  2.26k|#define XML_PARSER_BUFFER_SIZE 100
  ------------------
 3905|  2.26k|    int c, l;
 3906|  2.26k|    int maxLength = (ctxt->options & XML_PARSE_HUGE) ?
  ------------------
  |  Branch (3906:21): [True: 0, False: 2.26k]
  ------------------
 3907|      0|                    XML_MAX_HUGE_LENGTH :
  ------------------
  |  |   49|      0|#define XML_MAX_HUGE_LENGTH 1000000000
  ------------------
 3908|  2.26k|                    XML_MAX_TEXT_LENGTH;
  ------------------
  |  |   42|  2.26k|#define XML_MAX_TEXT_LENGTH 10000000
  ------------------
 3909|  2.26k|    xmlChar stop;
 3910|  2.26k|    xmlChar *ret = NULL;
 3911|  2.26k|    const xmlChar *cur = NULL;
 3912|  2.26k|    xmlParserInputPtr input;
 3913|       |
 3914|  2.26k|    if (RAW == '"') stop = '"';
  ------------------
  |  | 2221|  2.26k|#define RAW (*ctxt->input->cur)
  ------------------
  |  Branch (3914:9): [True: 1.97k, False: 288]
  ------------------
 3915|    288|    else if (RAW == '\'') stop = '\'';
  ------------------
  |  | 2221|    288|#define RAW (*ctxt->input->cur)
  ------------------
  |  Branch (3915:14): [True: 288, False: 0]
  ------------------
 3916|      0|    else {
 3917|      0|	xmlFatalErr(ctxt, XML_ERR_ENTITY_NOT_STARTED, NULL);
 3918|      0|	return(NULL);
 3919|      0|    }
 3920|  2.26k|    buf = (xmlChar *) xmlMallocAtomic(size);
 3921|  2.26k|    if (buf == NULL) {
  ------------------
  |  Branch (3921:9): [True: 0, False: 2.26k]
  ------------------
 3922|      0|	xmlErrMemory(ctxt, NULL);
 3923|      0|	return(NULL);
 3924|      0|    }
 3925|       |
 3926|       |    /*
 3927|       |     * The content of the entity definition is copied in a buffer.
 3928|       |     */
 3929|       |
 3930|  2.26k|    ctxt->instate = XML_PARSER_ENTITY_VALUE;
 3931|  2.26k|    input = ctxt->input;
 3932|  2.26k|    GROW;
  ------------------
  |  | 2270|  2.26k|#define GROW if (ctxt->input->end - ctxt->input->cur < INPUT_CHUNK)	\
  |  |  ------------------
  |  |  |  |   97|  2.26k|#define INPUT_CHUNK	250
  |  |  ------------------
  |  |  |  Branch (2270:18): [True: 412, False: 1.85k]
  |  |  ------------------
  |  | 2271|  2.26k|	xmlParserGrow(ctxt);
  ------------------
 3933|  2.26k|    if (ctxt->instate == XML_PARSER_EOF)
  ------------------
  |  Branch (3933:9): [True: 0, False: 2.26k]
  ------------------
 3934|      0|        goto error;
 3935|  2.26k|    NEXT;
  ------------------
  |  | 2275|  2.26k|#define NEXT xmlNextChar(ctxt)
  ------------------
 3936|  2.26k|    c = CUR_CHAR(l);
  ------------------
  |  | 2291|  2.26k|#define CUR_CHAR(l) xmlCurrentChar(ctxt, &l)
  ------------------
 3937|       |    /*
 3938|       |     * NOTE: 4.4.5 Included in Literal
 3939|       |     * When a parameter entity reference appears in a literal entity
 3940|       |     * value, ... a single or double quote character in the replacement
 3941|       |     * text is always treated as a normal data character and will not
 3942|       |     * terminate the literal.
 3943|       |     * In practice it means we stop the loop only when back at parsing
 3944|       |     * the initial entity and the quote is found
 3945|       |     */
 3946|   442k|    while (((IS_CHAR(c)) && ((c != stop) || /* checked */
  ------------------
  |  |  125|   442k|#define IS_CHAR(c)   xmlIsCharQ(c)
  |  |  ------------------
  |  |  |  |  118|   442k|#define xmlIsCharQ(c)		(((c) < 0x100) ? \
  |  |  |  |  ------------------
  |  |  |  |  |  Branch (118:25): [True: 442k, False: 12]
  |  |  |  |  ------------------
  |  |  |  |  119|   442k|				 xmlIsChar_ch((c)) :\
  |  |  |  |  ------------------
  |  |  |  |  |  |  108|   442k|#define xmlIsChar_ch(c)		(((0x9 <= (c)) && ((c) <= 0xa)) || \
  |  |  |  |  |  |  ------------------
  |  |  |  |  |  |  |  Branch (108:28): [True: 442k, False: 0]
  |  |  |  |  |  |  |  Branch (108:44): [True: 1.00k, False: 441k]
  |  |  |  |  |  |  ------------------
  |  |  |  |  |  |  109|   442k|				 ((c) == 0xd) || \
  |  |  |  |  |  |  ------------------
  |  |  |  |  |  |  |  Branch (109:6): [True: 0, False: 441k]
  |  |  |  |  |  |  ------------------
  |  |  |  |  |  |  110|   442k|				  (0x20 <= (c)))
  |  |  |  |  |  |  ------------------
  |  |  |  |  |  |  |  Branch (110:7): [True: 441k, False: 0]
  |  |  |  |  |  |  ------------------
  |  |  |  |  ------------------
  |  |  |  |  120|   442k|				(((0x100 <= (c)) && ((c) <= 0xd7ff)) || \
  |  |  |  |  ------------------
  |  |  |  |  |  Branch (120:7): [True: 12, False: 0]
  |  |  |  |  |  Branch (120:25): [True: 12, False: 0]
  |  |  |  |  ------------------
  |  |  |  |  121|     12|				 ((0xe000 <= (c)) && ((c) <= 0xfffd)) || \
  |  |  |  |  ------------------
  |  |  |  |  |  Branch (121:7): [True: 0, False: 0]
  |  |  |  |  |  Branch (121:26): [True: 0, False: 0]
  |  |  |  |  ------------------
  |  |  |  |  122|     12|				 ((0x10000 <= (c)) && ((c) <= 0x10ffff))))
  |  |  |  |  ------------------
  |  |  |  |  |  Branch (122:7): [True: 0, False: 0]
  |  |  |  |  |  Branch (122:27): [True: 0, False: 0]
  |  |  |  |  ------------------
  |  |  ------------------
  ------------------
  |  Branch (3946:13): [True: 442k, False: 0]
  |  Branch (3946:30): [True: 439k, False: 2.26k]
  ------------------
 3947|   442k|	    (ctxt->input != input))) && (ctxt->instate != XML_PARSER_EOF)) {
  ------------------
  |  Branch (3947:6): [True: 0, False: 2.26k]
  |  Branch (3947:34): [True: 439k, False: 0]
  ------------------
 3948|   439k|	if (len + 5 >= size) {
  ------------------
  |  Branch (3948:6): [True: 508, False: 439k]
  ------------------
 3949|    508|	    xmlChar *tmp;
 3950|       |
 3951|    508|	    size *= 2;
 3952|    508|	    tmp = (xmlChar *) xmlRealloc(buf, size);
 3953|    508|	    if (tmp == NULL) {
  ------------------
  |  Branch (3953:10): [True: 0, False: 508]
  ------------------
 3954|      0|		xmlErrMemory(ctxt, NULL);
 3955|      0|                goto error;
 3956|      0|	    }
 3957|    508|	    buf = tmp;
 3958|    508|	}
 3959|   439k|	COPY_BUF(buf, len, c);
  ------------------
  |  | 2295|   439k|    if (v < 0x80) b[i++] = v;						\
  |  |  ------------------
  |  |  |  Branch (2295:9): [True: 439k, False: 24]
  |  |  ------------------
  |  | 2296|   439k|    else i += xmlCopyCharMultiByte(&b[i],v)
  ------------------
 3960|   439k|	NEXTL(l);
  ------------------
  |  | 2284|   439k|#define NEXTL(l) do {							\
  |  | 2285|   439k|    if (*(ctxt->input->cur) == '\n') {					\
  |  |  ------------------
  |  |  |  Branch (2285:9): [True: 448, False: 439k]
  |  |  ------------------
  |  | 2286|    448|	ctxt->input->line++; ctxt->input->col = 1;			\
  |  | 2287|   439k|    } else ctxt->input->col++;						\
  |  | 2288|   439k|    ctxt->input->cur += l;				\
  |  | 2289|   439k|  } while (0)
  |  |  ------------------
  |  |  |  Branch (2289:12): [Folded - Ignored]
  |  |  ------------------
  ------------------
 3961|       |
 3962|   439k|	GROW;
  ------------------
  |  | 2270|   439k|#define GROW if (ctxt->input->end - ctxt->input->cur < INPUT_CHUNK)	\
  |  |  ------------------
  |  |  |  |   97|   439k|#define INPUT_CHUNK	250
  |  |  ------------------
  |  |  |  Branch (2270:18): [True: 11.0k, False: 428k]
  |  |  ------------------
  |  | 2271|   439k|	xmlParserGrow(ctxt);
  ------------------
 3963|   439k|	c = CUR_CHAR(l);
  ------------------
  |  | 2291|   439k|#define CUR_CHAR(l) xmlCurrentChar(ctxt, &l)
  ------------------
 3964|   439k|	if (c == 0) {
  ------------------
  |  Branch (3964:6): [True: 0, False: 439k]
  ------------------
 3965|      0|	    GROW;
  ------------------
  |  | 2270|      0|#define GROW if (ctxt->input->end - ctxt->input->cur < INPUT_CHUNK)	\
  |  |  ------------------
  |  |  |  |   97|      0|#define INPUT_CHUNK	250
  |  |  ------------------
  |  |  |  Branch (2270:18): [True: 0, False: 0]
  |  |  ------------------
  |  | 2271|      0|	xmlParserGrow(ctxt);
  ------------------
 3966|      0|	    c = CUR_CHAR(l);
  ------------------
  |  | 2291|      0|#define CUR_CHAR(l) xmlCurrentChar(ctxt, &l)
  ------------------
 3967|      0|	}
 3968|       |
 3969|   439k|        if (len > maxLength) {
  ------------------
  |  Branch (3969:13): [True: 0, False: 439k]
  ------------------
 3970|      0|            xmlFatalErrMsg(ctxt, XML_ERR_ENTITY_NOT_FINISHED,
 3971|      0|                           "entity value too long\n");
 3972|      0|            goto error;
 3973|      0|        }
 3974|   439k|    }
 3975|  2.26k|    buf[len] = 0;
 3976|  2.26k|    if (ctxt->instate == XML_PARSER_EOF)
  ------------------
  |  Branch (3976:9): [True: 0, False: 2.26k]
  ------------------
 3977|      0|        goto error;
 3978|  2.26k|    if (c != stop) {
  ------------------
  |  Branch (3978:9): [True: 0, False: 2.26k]
  ------------------
 3979|      0|        xmlFatalErr(ctxt, XML_ERR_ENTITY_NOT_FINISHED, NULL);
 3980|      0|        goto error;
 3981|      0|    }
 3982|  2.26k|    NEXT;
  ------------------
  |  | 2275|  2.26k|#define NEXT xmlNextChar(ctxt)
  ------------------
 3983|       |
 3984|       |    /*
 3985|       |     * Raise problem w.r.t. '&' and '%' being used in non-entities
 3986|       |     * reference constructs. Note Charref will be handled in
 3987|       |     * xmlStringDecodeEntities()
 3988|       |     */
 3989|  2.26k|    cur = buf;
 3990|   210k|    while (*cur != 0) { /* non input consuming */
  ------------------
  |  Branch (3990:12): [True: 208k, False: 2.26k]
  ------------------
 3991|   208k|	if ((*cur == '%') || ((*cur == '&') && (cur[1] != '#'))) {
  ------------------
  |  Branch (3991:6): [True: 1.28k, False: 206k]
  |  Branch (3991:24): [True: 3.50k, False: 203k]
  |  Branch (3991:41): [True: 2.47k, False: 1.02k]
  ------------------
 3992|  3.76k|	    xmlChar *name;
 3993|  3.76k|	    xmlChar tmp = *cur;
 3994|  3.76k|            int nameOk = 0;
 3995|       |
 3996|  3.76k|	    cur++;
 3997|  3.76k|	    name = xmlParseStringName(ctxt, &cur);
 3998|  3.76k|            if (name != NULL) {
  ------------------
  |  Branch (3998:17): [True: 3.76k, False: 0]
  ------------------
 3999|  3.76k|                nameOk = 1;
 4000|  3.76k|                xmlFree(name);
 4001|  3.76k|            }
 4002|  3.76k|            if ((nameOk == 0) || (*cur != ';')) {
  ------------------
  |  Branch (4002:17): [True: 0, False: 3.76k]
  |  Branch (4002:34): [True: 0, False: 3.76k]
  ------------------
 4003|      0|		xmlFatalErrMsgInt(ctxt, XML_ERR_ENTITY_CHAR_ERROR,
 4004|      0|	    "EntityValue: '%c' forbidden except for entities references\n",
 4005|      0|	                          tmp);
 4006|      0|                goto error;
 4007|      0|	    }
 4008|  3.76k|	    if ((tmp == '%') && (ctxt->inSubset == 1) &&
  ------------------
  |  Branch (4008:10): [True: 1.28k, False: 2.47k]
  |  Branch (4008:26): [True: 4, False: 1.28k]
  ------------------
 4009|  3.76k|		(ctxt->inputNr == 1)) {
  ------------------
  |  Branch (4009:3): [True: 0, False: 4]
  ------------------
 4010|      0|		xmlFatalErr(ctxt, XML_ERR_ENTITY_PE_INTERNAL, NULL);
 4011|      0|                goto error;
 4012|      0|	    }
 4013|  3.76k|	    if (*cur == 0)
  ------------------
  |  Branch (4013:10): [True: 0, False: 3.76k]
  ------------------
 4014|      0|	        break;
 4015|  3.76k|	}
 4016|   208k|	cur++;
 4017|   208k|    }
 4018|       |
 4019|       |    /*
 4020|       |     * Then PEReference entities are substituted.
 4021|       |     *
 4022|       |     * NOTE: 4.4.7 Bypassed
 4023|       |     * When a general entity reference appears in the EntityValue in
 4024|       |     * an entity declaration, it is bypassed and left as is.
 4025|       |     * so XML_SUBSTITUTE_REF is not set here.
 4026|       |     */
 4027|  2.26k|    ++ctxt->depth;
 4028|  2.26k|    ret = xmlStringDecodeEntitiesInt(ctxt, buf, len, XML_SUBSTITUTE_PEREF,
  ------------------
  |  |  527|  2.26k|#define XML_SUBSTITUTE_PEREF	2
  ------------------
 4029|  2.26k|                                     0, 0, 0, /* check */ 1);
 4030|  2.26k|    --ctxt->depth;
 4031|       |
 4032|  2.26k|    if (orig != NULL) {
  ------------------
  |  Branch (4032:9): [True: 2.26k, False: 0]
  ------------------
 4033|  2.26k|        *orig = buf;
 4034|  2.26k|        buf = NULL;
 4035|  2.26k|    }
 4036|       |
 4037|  2.26k|error:
 4038|  2.26k|    if (buf != NULL)
  ------------------
  |  Branch (4038:9): [True: 0, False: 2.26k]
  ------------------
 4039|      0|        xmlFree(buf);
 4040|  2.26k|    return(ret);
 4041|  2.26k|}
xmlParseAttValue:
 4337|  1.64k|xmlParseAttValue(xmlParserCtxtPtr ctxt) {
 4338|  1.64k|    if ((ctxt == NULL) || (ctxt->input == NULL)) return(NULL);
  ------------------
  |  Branch (4338:9): [True: 0, False: 1.64k]
  |  Branch (4338:27): [True: 0, False: 1.64k]
  ------------------
 4339|  1.64k|    return(xmlParseAttValueInternal(ctxt, NULL, NULL, 0));
 4340|  1.64k|}
xmlParseSystemLiteral:
 4356|    352|xmlParseSystemLiteral(xmlParserCtxtPtr ctxt) {
 4357|    352|    xmlChar *buf = NULL;
 4358|    352|    int len = 0;
 4359|    352|    int size = XML_PARSER_BUFFER_SIZE;
  ------------------
  |  |  167|    352|#define XML_PARSER_BUFFER_SIZE 100
  ------------------
 4360|    352|    int cur, l;
 4361|    352|    int maxLength = (ctxt->options & XML_PARSE_HUGE) ?
  ------------------
  |  Branch (4361:21): [True: 0, False: 352]
  ------------------
 4362|      0|                    XML_MAX_TEXT_LENGTH :
  ------------------
  |  |   42|      0|#define XML_MAX_TEXT_LENGTH 10000000
  ------------------
 4363|    352|                    XML_MAX_NAME_LENGTH;
  ------------------
  |  |   61|    352|#define XML_MAX_NAME_LENGTH 50000
  ------------------
 4364|    352|    xmlChar stop;
 4365|    352|    int state = ctxt->instate;
 4366|       |
 4367|    352|    if (RAW == '"') {
  ------------------
  |  | 2221|    352|#define RAW (*ctxt->input->cur)
  ------------------
  |  Branch (4367:9): [True: 340, False: 12]
  ------------------
 4368|    340|        NEXT;
  ------------------
  |  | 2275|    340|#define NEXT xmlNextChar(ctxt)
  ------------------
 4369|    340|	stop = '"';
 4370|    340|    } else if (RAW == '\'') {
  ------------------
  |  | 2221|     12|#define RAW (*ctxt->input->cur)
  ------------------
  |  Branch (4370:16): [True: 12, False: 0]
  ------------------
 4371|     12|        NEXT;
  ------------------
  |  | 2275|     12|#define NEXT xmlNextChar(ctxt)
  ------------------
 4372|     12|	stop = '\'';
 4373|     12|    } else {
 4374|      0|	xmlFatalErr(ctxt, XML_ERR_LITERAL_NOT_STARTED, NULL);
 4375|      0|	return(NULL);
 4376|      0|    }
 4377|       |
 4378|    352|    buf = (xmlChar *) xmlMallocAtomic(size);
 4379|    352|    if (buf == NULL) {
  ------------------
  |  Branch (4379:9): [True: 0, False: 352]
  ------------------
 4380|      0|        xmlErrMemory(ctxt, NULL);
 4381|      0|	return(NULL);
 4382|      0|    }
 4383|    352|    ctxt->instate = XML_PARSER_SYSTEM_LITERAL;
 4384|    352|    cur = CUR_CHAR(l);
  ------------------
  |  | 2291|    352|#define CUR_CHAR(l) xmlCurrentChar(ctxt, &l)
  ------------------
 4385|  10.0k|    while ((IS_CHAR(cur)) && (cur != stop)) { /* checked */
  ------------------
  |  |  125|  10.0k|#define IS_CHAR(c)   xmlIsCharQ(c)
  |  |  ------------------
  |  |  |  |  118|  10.0k|#define xmlIsCharQ(c)		(((c) < 0x100) ? \
  |  |  |  |  ------------------
  |  |  |  |  |  Branch (118:25): [True: 10.0k, False: 0]
  |  |  |  |  ------------------
  |  |  |  |  119|  10.0k|				 xmlIsChar_ch((c)) :\
  |  |  |  |  ------------------
  |  |  |  |  |  |  108|  10.0k|#define xmlIsChar_ch(c)		(((0x9 <= (c)) && ((c) <= 0xa)) || \
  |  |  |  |  |  |  ------------------
  |  |  |  |  |  |  |  Branch (108:28): [True: 10.0k, False: 0]
  |  |  |  |  |  |  |  Branch (108:44): [True: 0, False: 10.0k]
  |  |  |  |  |  |  ------------------
  |  |  |  |  |  |  109|  10.0k|				 ((c) == 0xd) || \
  |  |  |  |  |  |  ------------------
  |  |  |  |  |  |  |  Branch (109:6): [True: 0, False: 10.0k]
  |  |  |  |  |  |  ------------------
  |  |  |  |  |  |  110|  10.0k|				  (0x20 <= (c)))
  |  |  |  |  |  |  ------------------
  |  |  |  |  |  |  |  Branch (110:7): [True: 10.0k, False: 0]
  |  |  |  |  |  |  ------------------
  |  |  |  |  ------------------
  |  |  |  |  120|  10.0k|				(((0x100 <= (c)) && ((c) <= 0xd7ff)) || \
  |  |  |  |  ------------------
  |  |  |  |  |  Branch (120:7): [True: 0, False: 0]
  |  |  |  |  |  Branch (120:25): [True: 0, False: 0]
  |  |  |  |  ------------------
  |  |  |  |  121|      0|				 ((0xe000 <= (c)) && ((c) <= 0xfffd)) || \
  |  |  |  |  ------------------
  |  |  |  |  |  Branch (121:7): [True: 0, False: 0]
  |  |  |  |  |  Branch (121:26): [True: 0, False: 0]
  |  |  |  |  ------------------
  |  |  |  |  122|      0|				 ((0x10000 <= (c)) && ((c) <= 0x10ffff))))
  |  |  |  |  ------------------
  |  |  |  |  |  Branch (122:7): [True: 0, False: 0]
  |  |  |  |  |  Branch (122:27): [True: 0, False: 0]
  |  |  |  |  ------------------
  |  |  ------------------
  ------------------
  |  Branch (4385:12): [True: 10.0k, False: 0]
  |  Branch (4385:30): [True: 9.72k, False: 352]
  ------------------
 4386|  9.72k|	if (len + 5 >= size) {
  ------------------
  |  Branch (4386:6): [True: 0, False: 9.72k]
  ------------------
 4387|      0|	    xmlChar *tmp;
 4388|       |
 4389|      0|	    size *= 2;
 4390|      0|	    tmp = (xmlChar *) xmlRealloc(buf, size);
 4391|      0|	    if (tmp == NULL) {
  ------------------
  |  Branch (4391:10): [True: 0, False: 0]
  ------------------
 4392|      0|	        xmlFree(buf);
 4393|      0|		xmlErrMemory(ctxt, NULL);
 4394|      0|		ctxt->instate = (xmlParserInputState) state;
 4395|      0|		return(NULL);
 4396|      0|	    }
 4397|      0|	    buf = tmp;
 4398|      0|	}
 4399|  9.72k|	COPY_BUF(buf, len, cur);
  ------------------
  |  | 2295|  9.72k|    if (v < 0x80) b[i++] = v;						\
  |  |  ------------------
  |  |  |  Branch (2295:9): [True: 9.72k, False: 0]
  |  |  ------------------
  |  | 2296|  9.72k|    else i += xmlCopyCharMultiByte(&b[i],v)
  ------------------
 4400|  9.72k|        if (len > maxLength) {
  ------------------
  |  Branch (4400:13): [True: 0, False: 9.72k]
  ------------------
 4401|      0|            xmlFatalErr(ctxt, XML_ERR_NAME_TOO_LONG, "SystemLiteral");
 4402|      0|            xmlFree(buf);
 4403|      0|            ctxt->instate = (xmlParserInputState) state;
 4404|      0|            return(NULL);
 4405|      0|        }
 4406|  9.72k|	NEXTL(l);
  ------------------
  |  | 2284|  9.72k|#define NEXTL(l) do {							\
  |  | 2285|  9.72k|    if (*(ctxt->input->cur) == '\n') {					\
  |  |  ------------------
  |  |  |  Branch (2285:9): [True: 0, False: 9.72k]
  |  |  ------------------
  |  | 2286|      0|	ctxt->input->line++; ctxt->input->col = 1;			\
  |  | 2287|  9.72k|    } else ctxt->input->col++;						\
  |  | 2288|  9.72k|    ctxt->input->cur += l;				\
  |  | 2289|  9.72k|  } while (0)
  |  |  ------------------
  |  |  |  Branch (2289:12): [Folded - Ignored]
  |  |  ------------------
  ------------------
 4407|  9.72k|	cur = CUR_CHAR(l);
  ------------------
  |  | 2291|  9.72k|#define CUR_CHAR(l) xmlCurrentChar(ctxt, &l)
  ------------------
 4408|  9.72k|    }
 4409|    352|    buf[len] = 0;
 4410|    352|    if (ctxt->instate == XML_PARSER_EOF) {
  ------------------
  |  Branch (4410:9): [True: 0, False: 352]
  ------------------
 4411|      0|        xmlFree(buf);
 4412|      0|        return(NULL);
 4413|      0|    }
 4414|    352|    ctxt->instate = (xmlParserInputState) state;
 4415|    352|    if (!IS_CHAR(cur)) {
  ------------------
  |  |  125|    352|#define IS_CHAR(c)   xmlIsCharQ(c)
  |  |  ------------------
  |  |  |  |  118|    352|#define xmlIsCharQ(c)		(((c) < 0x100) ? \
  |  |  |  |  ------------------
  |  |  |  |  |  Branch (118:25): [True: 352, False: 0]
  |  |  |  |  ------------------
  |  |  |  |  119|    352|				 xmlIsChar_ch((c)) :\
  |  |  |  |  ------------------
  |  |  |  |  |  |  108|    352|#define xmlIsChar_ch(c)		(((0x9 <= (c)) && ((c) <= 0xa)) || \
  |  |  |  |  |  |  ------------------
  |  |  |  |  |  |  |  Branch (108:28): [True: 352, False: 0]
  |  |  |  |  |  |  |  Branch (108:44): [True: 0, False: 352]
  |  |  |  |  |  |  ------------------
  |  |  |  |  |  |  109|    352|				 ((c) == 0xd) || \
  |  |  |  |  |  |  ------------------
  |  |  |  |  |  |  |  Branch (109:6): [True: 0, False: 352]
  |  |  |  |  |  |  ------------------
  |  |  |  |  |  |  110|    352|				  (0x20 <= (c)))
  |  |  |  |  |  |  ------------------
  |  |  |  |  |  |  |  Branch (110:7): [True: 352, False: 0]
  |  |  |  |  |  |  ------------------
  |  |  |  |  ------------------
  |  |  |  |  120|    352|				(((0x100 <= (c)) && ((c) <= 0xd7ff)) || \
  |  |  |  |  ------------------
  |  |  |  |  |  Branch (120:7): [True: 0, False: 0]
  |  |  |  |  |  Branch (120:25): [True: 0, False: 0]
  |  |  |  |  ------------------
  |  |  |  |  121|      0|				 ((0xe000 <= (c)) && ((c) <= 0xfffd)) || \
  |  |  |  |  ------------------
  |  |  |  |  |  Branch (121:7): [True: 0, False: 0]
  |  |  |  |  |  Branch (121:26): [True: 0, False: 0]
  |  |  |  |  ------------------
  |  |  |  |  122|      0|				 ((0x10000 <= (c)) && ((c) <= 0x10ffff))))
  |  |  |  |  ------------------
  |  |  |  |  |  Branch (122:7): [True: 0, False: 0]
  |  |  |  |  |  Branch (122:27): [True: 0, False: 0]
  |  |  |  |  ------------------
  |  |  ------------------
  ------------------
  |  Branch (4415:9): [True: 0, False: 352]
  ------------------
 4416|      0|	xmlFatalErr(ctxt, XML_ERR_LITERAL_NOT_FINISHED, NULL);
 4417|    352|    } else {
 4418|    352|	NEXT;
  ------------------
  |  | 2275|    352|#define NEXT xmlNextChar(ctxt)
  ------------------
 4419|    352|    }
 4420|    352|    return(buf);
 4421|    352|}
xmlParsePubidLiteral:
 4437|    168|xmlParsePubidLiteral(xmlParserCtxtPtr ctxt) {
 4438|    168|    xmlChar *buf = NULL;
 4439|    168|    int len = 0;
 4440|    168|    int size = XML_PARSER_BUFFER_SIZE;
  ------------------
  |  |  167|    168|#define XML_PARSER_BUFFER_SIZE 100
  ------------------
 4441|    168|    int maxLength = (ctxt->options & XML_PARSE_HUGE) ?
  ------------------
  |  Branch (4441:21): [True: 0, False: 168]
  ------------------
 4442|      0|                    XML_MAX_TEXT_LENGTH :
  ------------------
  |  |   42|      0|#define XML_MAX_TEXT_LENGTH 10000000
  ------------------
 4443|    168|                    XML_MAX_NAME_LENGTH;
  ------------------
  |  |   61|    168|#define XML_MAX_NAME_LENGTH 50000
  ------------------
 4444|    168|    xmlChar cur;
 4445|    168|    xmlChar stop;
 4446|    168|    xmlParserInputState oldstate = ctxt->instate;
 4447|       |
 4448|    168|    if (RAW == '"') {
  ------------------
  |  | 2221|    168|#define RAW (*ctxt->input->cur)
  ------------------
  |  Branch (4448:9): [True: 168, False: 0]
  ------------------
 4449|    168|        NEXT;
  ------------------
  |  | 2275|    168|#define NEXT xmlNextChar(ctxt)
  ------------------
 4450|    168|	stop = '"';
 4451|    168|    } else if (RAW == '\'') {
  ------------------
  |  | 2221|      0|#define RAW (*ctxt->input->cur)
  ------------------
  |  Branch (4451:16): [True: 0, False: 0]
  ------------------
 4452|      0|        NEXT;
  ------------------
  |  | 2275|      0|#define NEXT xmlNextChar(ctxt)
  ------------------
 4453|      0|	stop = '\'';
 4454|      0|    } else {
 4455|      0|	xmlFatalErr(ctxt, XML_ERR_LITERAL_NOT_STARTED, NULL);
 4456|      0|	return(NULL);
 4457|      0|    }
 4458|    168|    buf = (xmlChar *) xmlMallocAtomic(size);
 4459|    168|    if (buf == NULL) {
  ------------------
  |  Branch (4459:9): [True: 0, False: 168]
  ------------------
 4460|      0|	xmlErrMemory(ctxt, NULL);
 4461|      0|	return(NULL);
 4462|      0|    }
 4463|    168|    ctxt->instate = XML_PARSER_PUBLIC_LITERAL;
 4464|    168|    cur = CUR;
  ------------------
  |  | 2222|    168|#define CUR (*ctxt->input->cur)
  ------------------
 4465|  4.99k|    while ((IS_PUBIDCHAR_CH(cur)) && (cur != stop)) { /* checked */
  ------------------
  |  |  287|  4.99k|#define IS_PUBIDCHAR_CH(c) xmlIsPubidChar_ch(c)
  |  |  ------------------
  |  |  |  |  199|  4.99k|#define xmlIsPubidChar_ch(c)	(xmlIsPubidChar_tab[(c)])
  |  |  ------------------
  ------------------
  |  Branch (4465:12): [True: 4.82k, False: 168]
  |  Branch (4465:38): [True: 4.82k, False: 0]
  ------------------
 4466|  4.82k|	if (len + 1 >= size) {
  ------------------
  |  Branch (4466:6): [True: 0, False: 4.82k]
  ------------------
 4467|      0|	    xmlChar *tmp;
 4468|       |
 4469|      0|	    size *= 2;
 4470|      0|	    tmp = (xmlChar *) xmlRealloc(buf, size);
 4471|      0|	    if (tmp == NULL) {
  ------------------
  |  Branch (4471:10): [True: 0, False: 0]
  ------------------
 4472|      0|		xmlErrMemory(ctxt, NULL);
 4473|      0|		xmlFree(buf);
 4474|      0|		return(NULL);
 4475|      0|	    }
 4476|      0|	    buf = tmp;
 4477|      0|	}
 4478|  4.82k|	buf[len++] = cur;
 4479|  4.82k|        if (len > maxLength) {
  ------------------
  |  Branch (4479:13): [True: 0, False: 4.82k]
  ------------------
 4480|      0|            xmlFatalErr(ctxt, XML_ERR_NAME_TOO_LONG, "Public ID");
 4481|      0|            xmlFree(buf);
 4482|      0|            return(NULL);
 4483|      0|        }
 4484|  4.82k|	NEXT;
  ------------------
  |  | 2275|  4.82k|#define NEXT xmlNextChar(ctxt)
  ------------------
 4485|  4.82k|	cur = CUR;
  ------------------
  |  | 2222|  4.82k|#define CUR (*ctxt->input->cur)
  ------------------
 4486|  4.82k|    }
 4487|    168|    buf[len] = 0;
 4488|    168|    if (ctxt->instate == XML_PARSER_EOF) {
  ------------------
  |  Branch (4488:9): [True: 0, False: 168]
  ------------------
 4489|      0|        xmlFree(buf);
 4490|      0|        return(NULL);
 4491|      0|    }
 4492|    168|    if (cur != stop) {
  ------------------
  |  Branch (4492:9): [True: 0, False: 168]
  ------------------
 4493|      0|	xmlFatalErr(ctxt, XML_ERR_LITERAL_NOT_FINISHED, NULL);
 4494|    168|    } else {
 4495|    168|	NEXTL(1);
  ------------------
  |  | 2284|    168|#define NEXTL(l) do {							\
  |  | 2285|    168|    if (*(ctxt->input->cur) == '\n') {					\
  |  |  ------------------
  |  |  |  Branch (2285:9): [True: 0, False: 168]
  |  |  ------------------
  |  | 2286|      0|	ctxt->input->line++; ctxt->input->col = 1;			\
  |  | 2287|    168|    } else ctxt->input->col++;						\
  |  | 2288|    168|    ctxt->input->cur += l;				\
  |  | 2289|    168|  } while (0)
  |  |  ------------------
  |  |  |  Branch (2289:12): [Folded - Ignored]
  |  |  ------------------
  ------------------
 4496|    168|    }
 4497|    168|    ctxt->instate = oldstate;
 4498|    168|    return(buf);
 4499|    168|}
xmlParseExternalID:
 4835|    848|xmlParseExternalID(xmlParserCtxtPtr ctxt, xmlChar **publicID, int strict) {
 4836|    848|    xmlChar *URI = NULL;
 4837|       |
 4838|    848|    *publicID = NULL;
 4839|    848|    if (CMP6(CUR_PTR, 'S', 'Y', 'S', 'T', 'E', 'M')) {
  ------------------
  |  | 2233|    848|  ( CMP5( s, c1, c2, c3, c4, c5 ) && ((unsigned char *) s)[ 5 ] == c6 )
  |  |  ------------------
  |  |  |  | 2231|  1.69k|  ( CMP4( s, c1, c2, c3, c4 ) && ((unsigned char *) s)[ 4 ] == c5 )
  |  |  |  |  ------------------
  |  |  |  |  |  | 2228|  1.69k|  ( ((unsigned char *) s)[ 0 ] == c1 && ((unsigned char *) s)[ 1 ] == c2 && \
  |  |  |  |  |  |  ------------------
  |  |  |  |  |  |  |  Branch (2228:5): [True: 184, False: 664]
  |  |  |  |  |  |  |  Branch (2228:41): [True: 184, False: 0]
  |  |  |  |  |  |  ------------------
  |  |  |  |  |  | 2229|    848|    ((unsigned char *) s)[ 2 ] == c3 && ((unsigned char *) s)[ 3 ] == c4 )
  |  |  |  |  |  |  ------------------
  |  |  |  |  |  |  |  Branch (2229:5): [True: 184, False: 0]
  |  |  |  |  |  |  |  Branch (2229:41): [True: 184, False: 0]
  |  |  |  |  |  |  ------------------
  |  |  |  |  ------------------
  |  |  |  |  |  Branch (2231:34): [True: 184, False: 0]
  |  |  |  |  ------------------
  |  |  ------------------
  |  |  |  Branch (2233:38): [True: 184, False: 0]
  |  |  ------------------
  ------------------
 4840|    184|        SKIP(6);
  ------------------
  |  | 2245|    184|#define SKIP(val) do {							\
  |  | 2246|    184|    ctxt->input->cur += (val),ctxt->input->col+=(val);			\
  |  | 2247|    184|    if (*ctxt->input->cur == 0)						\
  |  |  ------------------
  |  |  |  Branch (2247:9): [True: 0, False: 184]
  |  |  ------------------
  |  | 2248|    184|        xmlParserGrow(ctxt);						\
  |  | 2249|    184|  } while (0)
  |  |  ------------------
  |  |  |  Branch (2249:12): [Folded - Ignored]
  |  |  ------------------
  ------------------
 4841|    184|	if (SKIP_BLANKS == 0) {
  ------------------
  |  | 2273|    184|#define SKIP_BLANKS xmlSkipBlankChars(ctxt)
  ------------------
  |  Branch (4841:6): [True: 0, False: 184]
  ------------------
 4842|      0|	    xmlFatalErrMsg(ctxt, XML_ERR_SPACE_REQUIRED,
 4843|      0|	                   "Space required after 'SYSTEM'\n");
 4844|      0|	}
 4845|    184|	URI = xmlParseSystemLiteral(ctxt);
 4846|    184|	if (URI == NULL) {
  ------------------
  |  Branch (4846:6): [True: 0, False: 184]
  ------------------
 4847|      0|	    xmlFatalErr(ctxt, XML_ERR_URI_REQUIRED, NULL);
 4848|      0|        }
 4849|    664|    } else if (CMP6(CUR_PTR, 'P', 'U', 'B', 'L', 'I', 'C')) {
  ------------------
  |  | 2233|    664|  ( CMP5( s, c1, c2, c3, c4, c5 ) && ((unsigned char *) s)[ 5 ] == c6 )
  |  |  ------------------
  |  |  |  | 2231|  1.32k|  ( CMP4( s, c1, c2, c3, c4 ) && ((unsigned char *) s)[ 4 ] == c5 )
  |  |  |  |  ------------------
  |  |  |  |  |  | 2228|  1.32k|  ( ((unsigned char *) s)[ 0 ] == c1 && ((unsigned char *) s)[ 1 ] == c2 && \
  |  |  |  |  |  |  ------------------
  |  |  |  |  |  |  |  Branch (2228:5): [True: 168, False: 496]
  |  |  |  |  |  |  |  Branch (2228:41): [True: 168, False: 0]
  |  |  |  |  |  |  ------------------
  |  |  |  |  |  | 2229|    664|    ((unsigned char *) s)[ 2 ] == c3 && ((unsigned char *) s)[ 3 ] == c4 )
  |  |  |  |  |  |  ------------------
  |  |  |  |  |  |  |  Branch (2229:5): [True: 168, False: 0]
  |  |  |  |  |  |  |  Branch (2229:41): [True: 168, False: 0]
  |  |  |  |  |  |  ------------------
  |  |  |  |  ------------------
  |  |  |  |  |  Branch (2231:34): [True: 168, False: 0]
  |  |  |  |  ------------------
  |  |  ------------------
  |  |  |  Branch (2233:38): [True: 168, False: 0]
  |  |  ------------------
  ------------------
 4850|    168|        SKIP(6);
  ------------------
  |  | 2245|    168|#define SKIP(val) do {							\
  |  | 2246|    168|    ctxt->input->cur += (val),ctxt->input->col+=(val);			\
  |  | 2247|    168|    if (*ctxt->input->cur == 0)						\
  |  |  ------------------
  |  |  |  Branch (2247:9): [True: 0, False: 168]
  |  |  ------------------
  |  | 2248|    168|        xmlParserGrow(ctxt);						\
  |  | 2249|    168|  } while (0)
  |  |  ------------------
  |  |  |  Branch (2249:12): [Folded - Ignored]
  |  |  ------------------
  ------------------
 4851|    168|	if (SKIP_BLANKS == 0) {
  ------------------
  |  | 2273|    168|#define SKIP_BLANKS xmlSkipBlankChars(ctxt)
  ------------------
  |  Branch (4851:6): [True: 0, False: 168]
  ------------------
 4852|      0|	    xmlFatalErrMsg(ctxt, XML_ERR_SPACE_REQUIRED,
 4853|      0|		    "Space required after 'PUBLIC'\n");
 4854|      0|	}
 4855|    168|	*publicID = xmlParsePubidLiteral(ctxt);
 4856|    168|	if (*publicID == NULL) {
  ------------------
  |  Branch (4856:6): [True: 0, False: 168]
  ------------------
 4857|      0|	    xmlFatalErr(ctxt, XML_ERR_PUBID_REQUIRED, NULL);
 4858|      0|	}
 4859|    168|	if (strict) {
  ------------------
  |  Branch (4859:6): [True: 168, False: 0]
  ------------------
 4860|       |	    /*
 4861|       |	     * We don't handle [83] so "S SystemLiteral" is required.
 4862|       |	     */
 4863|    168|	    if (SKIP_BLANKS == 0) {
  ------------------
  |  | 2273|    168|#define SKIP_BLANKS xmlSkipBlankChars(ctxt)
  ------------------
  |  Branch (4863:10): [True: 0, False: 168]
  ------------------
 4864|      0|		xmlFatalErrMsg(ctxt, XML_ERR_SPACE_REQUIRED,
 4865|      0|			"Space required after the Public Identifier\n");
 4866|      0|	    }
 4867|    168|	} else {
 4868|       |	    /*
 4869|       |	     * We handle [83] so we return immediately, if
 4870|       |	     * "S SystemLiteral" is not detected. We skip blanks if no
 4871|       |             * system literal was found, but this is harmless since we must
 4872|       |             * be at the end of a NotationDecl.
 4873|       |	     */
 4874|      0|	    if (SKIP_BLANKS == 0) return(NULL);
  ------------------
  |  | 2273|      0|#define SKIP_BLANKS xmlSkipBlankChars(ctxt)
  ------------------
  |  Branch (4874:10): [True: 0, False: 0]
  ------------------
 4875|      0|	    if ((CUR != '\'') && (CUR != '"')) return(NULL);
  ------------------
  |  | 2222|      0|#define CUR (*ctxt->input->cur)
  ------------------
              	    if ((CUR != '\'') && (CUR != '"')) return(NULL);
  ------------------
  |  | 2222|      0|#define CUR (*ctxt->input->cur)
  ------------------
  |  Branch (4875:10): [True: 0, False: 0]
  |  Branch (4875:27): [True: 0, False: 0]
  ------------------
 4876|      0|	}
 4877|    168|	URI = xmlParseSystemLiteral(ctxt);
 4878|    168|	if (URI == NULL) {
  ------------------
  |  Branch (4878:6): [True: 0, False: 168]
  ------------------
 4879|      0|	    xmlFatalErr(ctxt, XML_ERR_URI_REQUIRED, NULL);
 4880|      0|        }
 4881|    168|    }
 4882|    848|    return(URI);
 4883|    848|}
xmlParseComment:
 5029|   643k|xmlParseComment(xmlParserCtxtPtr ctxt) {
 5030|   643k|    xmlChar *buf = NULL;
 5031|   643k|    size_t size = XML_PARSER_BUFFER_SIZE;
  ------------------
  |  |  167|   643k|#define XML_PARSER_BUFFER_SIZE 100
  ------------------
 5032|   643k|    size_t len = 0;
 5033|   643k|    size_t maxLength = (ctxt->options & XML_PARSE_HUGE) ?
  ------------------
  |  Branch (5033:24): [True: 0, False: 643k]
  ------------------
 5034|      0|                       XML_MAX_HUGE_LENGTH :
  ------------------
  |  |   49|      0|#define XML_MAX_HUGE_LENGTH 1000000000
  ------------------
 5035|   643k|                       XML_MAX_TEXT_LENGTH;
  ------------------
  |  |   42|  1.28M|#define XML_MAX_TEXT_LENGTH 10000000
  ------------------
 5036|   643k|    xmlParserInputState state;
 5037|   643k|    const xmlChar *in;
 5038|   643k|    size_t nbchar = 0;
 5039|   643k|    int ccol;
 5040|   643k|    int inputid;
 5041|       |
 5042|       |    /*
 5043|       |     * Check that there is a comment right here.
 5044|       |     */
 5045|   643k|    if ((RAW != '<') || (NXT(1) != '!'))
  ------------------
  |  | 2221|   643k|#define RAW (*ctxt->input->cur)
  ------------------
                  if ((RAW != '<') || (NXT(1) != '!'))
  ------------------
  |  | 2223|   643k|#define NXT(val) ctxt->input->cur[(val)]
  ------------------
  |  Branch (5045:9): [True: 0, False: 643k]
  |  Branch (5045:25): [True: 0, False: 643k]
  ------------------
 5046|      0|        return;
 5047|   643k|    SKIP(2);
  ------------------
  |  | 2245|   643k|#define SKIP(val) do {							\
  |  | 2246|   643k|    ctxt->input->cur += (val),ctxt->input->col+=(val);			\
  |  | 2247|   643k|    if (*ctxt->input->cur == 0)						\
  |  |  ------------------
  |  |  |  Branch (2247:9): [True: 0, False: 643k]
  |  |  ------------------
  |  | 2248|   643k|        xmlParserGrow(ctxt);						\
  |  | 2249|   643k|  } while (0)
  |  |  ------------------
  |  |  |  Branch (2249:12): [Folded - Ignored]
  |  |  ------------------
  ------------------
 5048|   643k|    if ((RAW != '-') || (NXT(1) != '-'))
  ------------------
  |  | 2221|   643k|#define RAW (*ctxt->input->cur)
  ------------------
                  if ((RAW != '-') || (NXT(1) != '-'))
  ------------------
  |  | 2223|   643k|#define NXT(val) ctxt->input->cur[(val)]
  ------------------
  |  Branch (5048:9): [True: 0, False: 643k]
  |  Branch (5048:25): [True: 0, False: 643k]
  ------------------
 5049|      0|        return;
 5050|   643k|    state = ctxt->instate;
 5051|   643k|    ctxt->instate = XML_PARSER_COMMENT;
 5052|   643k|    inputid = ctxt->input->id;
 5053|   643k|    SKIP(2);
  ------------------
  |  | 2245|   643k|#define SKIP(val) do {							\
  |  | 2246|   643k|    ctxt->input->cur += (val),ctxt->input->col+=(val);			\
  |  | 2247|   643k|    if (*ctxt->input->cur == 0)						\
  |  |  ------------------
  |  |  |  Branch (2247:9): [True: 0, False: 643k]
  |  |  ------------------
  |  | 2248|   643k|        xmlParserGrow(ctxt);						\
  |  | 2249|   643k|  } while (0)
  |  |  ------------------
  |  |  |  Branch (2249:12): [Folded - Ignored]
  |  |  ------------------
  ------------------
 5054|   643k|    GROW;
  ------------------
  |  | 2270|   643k|#define GROW if (ctxt->input->end - ctxt->input->cur < INPUT_CHUNK)	\
  |  |  ------------------
  |  |  |  |   97|   643k|#define INPUT_CHUNK	250
  |  |  ------------------
  |  |  |  Branch (2270:18): [True: 575k, False: 67.6k]
  |  |  ------------------
  |  | 2271|   643k|	xmlParserGrow(ctxt);
  ------------------
 5055|       |
 5056|       |    /*
 5057|       |     * Accelerated common case where input don't need to be
 5058|       |     * modified before passing it to the handler.
 5059|       |     */
 5060|   643k|    in = ctxt->input->cur;
 5061|   643k|    do {
 5062|   643k|	if (*in == 0xA) {
  ------------------
  |  Branch (5062:6): [True: 296, False: 643k]
  ------------------
 5063|    300|	    do {
 5064|    300|		ctxt->input->line++; ctxt->input->col = 1;
 5065|    300|		in++;
 5066|    300|	    } while (*in == 0xA);
  ------------------
  |  Branch (5066:15): [True: 4, False: 296]
  ------------------
 5067|    296|	}
 5068|   655k|get_more:
 5069|   655k|        ccol = ctxt->input->col;
 5070|  1.23M|	while (((*in > '-') && (*in <= 0x7F)) ||
  ------------------
  |  Branch (5070:10): [True: 496k, False: 743k]
  |  Branch (5070:25): [True: 496k, False: 20]
  ------------------
 5071|  1.23M|	       ((*in >= 0x20) && (*in < '-')) ||
  ------------------
  |  Branch (5071:10): [True: 733k, False: 10.6k]
  |  Branch (5071:27): [True: 86.6k, False: 646k]
  ------------------
 5072|  1.23M|	       (*in == 0x09)) {
  ------------------
  |  Branch (5072:9): [True: 1.16k, False: 655k]
  ------------------
 5073|   583k|		    in++;
 5074|   583k|		    ccol++;
 5075|   583k|	}
 5076|   655k|	ctxt->input->col = ccol;
 5077|   655k|	if (*in == 0xA) {
  ------------------
  |  Branch (5077:6): [True: 4.30k, False: 651k]
  ------------------
 5078|  4.42k|	    do {
 5079|  4.42k|		ctxt->input->line++; ctxt->input->col = 1;
 5080|  4.42k|		in++;
 5081|  4.42k|	    } while (*in == 0xA);
  ------------------
  |  Branch (5081:15): [True: 116, False: 4.30k]
  ------------------
 5082|  4.30k|	    goto get_more;
 5083|  4.30k|	}
 5084|   651k|	nbchar = in - ctxt->input->cur;
 5085|       |	/*
 5086|       |	 * save current set of data
 5087|       |	 */
 5088|   651k|	if (nbchar > 0) {
  ------------------
  |  Branch (5088:6): [True: 11.3k, False: 640k]
  ------------------
 5089|  11.3k|            if (buf == NULL) {
  ------------------
  |  Branch (5089:17): [True: 3.08k, False: 8.23k]
  ------------------
 5090|  3.08k|                if ((*in == '-') && (in[1] == '-'))
  ------------------
  |  Branch (5090:21): [True: 2.47k, False: 618]
  |  Branch (5090:37): [True: 1.86k, False: 608]
  ------------------
 5091|  1.86k|                    size = nbchar + 1;
 5092|  1.22k|                else
 5093|  1.22k|                    size = XML_PARSER_BUFFER_SIZE + nbchar;
  ------------------
  |  |  167|  1.22k|#define XML_PARSER_BUFFER_SIZE 100
  ------------------
 5094|  3.08k|                buf = (xmlChar *) xmlMallocAtomic(size);
 5095|  3.08k|                if (buf == NULL) {
  ------------------
  |  Branch (5095:21): [True: 0, False: 3.08k]
  ------------------
 5096|      0|                    xmlErrMemory(ctxt, NULL);
 5097|      0|                    ctxt->instate = state;
 5098|      0|                    return;
 5099|      0|                }
 5100|  3.08k|                len = 0;
 5101|  8.23k|            } else if (len + nbchar + 1 >= size) {
  ------------------
  |  Branch (5101:24): [True: 1.23k, False: 6.99k]
  ------------------
 5102|  1.23k|                xmlChar *new_buf;
 5103|  1.23k|                size  += len + nbchar + XML_PARSER_BUFFER_SIZE;
  ------------------
  |  |  167|  1.23k|#define XML_PARSER_BUFFER_SIZE 100
  ------------------
 5104|  1.23k|                new_buf = (xmlChar *) xmlRealloc(buf, size);
 5105|  1.23k|                if (new_buf == NULL) {
  ------------------
  |  Branch (5105:21): [True: 0, False: 1.23k]
  ------------------
 5106|      0|                    xmlFree (buf);
 5107|      0|                    xmlErrMemory(ctxt, NULL);
 5108|      0|                    ctxt->instate = state;
 5109|      0|                    return;
 5110|      0|                }
 5111|  1.23k|                buf = new_buf;
 5112|  1.23k|            }
 5113|  11.3k|            memcpy(&buf[len], ctxt->input->cur, nbchar);
 5114|  11.3k|            len += nbchar;
 5115|  11.3k|            buf[len] = 0;
 5116|  11.3k|	}
 5117|   651k|        if (len > maxLength) {
  ------------------
  |  Branch (5117:13): [True: 0, False: 651k]
  ------------------
 5118|      0|            xmlFatalErrMsgStr(ctxt, XML_ERR_COMMENT_NOT_FINISHED,
 5119|      0|                         "Comment too big found", NULL);
 5120|      0|            xmlFree (buf);
 5121|      0|            return;
 5122|      0|        }
 5123|   651k|	ctxt->input->cur = in;
 5124|   651k|	if (*in == 0xA) {
  ------------------
  |  Branch (5124:6): [True: 0, False: 651k]
  ------------------
 5125|      0|	    in++;
 5126|      0|	    ctxt->input->line++; ctxt->input->col = 1;
 5127|      0|	}
 5128|   651k|	if (*in == 0xD) {
  ------------------
  |  Branch (5128:6): [True: 5.11k, False: 646k]
  ------------------
 5129|  5.11k|	    in++;
 5130|  5.11k|	    if (*in == 0xA) {
  ------------------
  |  Branch (5130:10): [True: 5.11k, False: 0]
  ------------------
 5131|  5.11k|		ctxt->input->cur = in;
 5132|  5.11k|		in++;
 5133|  5.11k|		ctxt->input->line++; ctxt->input->col = 1;
 5134|  5.11k|		goto get_more;
 5135|  5.11k|	    }
 5136|      0|	    in--;
 5137|      0|	}
 5138|   646k|	SHRINK;
  ------------------
  |  | 2265|   646k|    if (((ctxt->progressive == 0) || (ctxt->inputNr > 1)) && \
  |  |  ------------------
  |  |  |  Branch (2265:10): [True: 325k, False: 321k]
  |  |  |  Branch (2265:38): [True: 320k, False: 1.06k]
  |  |  ------------------
  |  | 2266|   646k|        (ctxt->input->cur - ctxt->input->base > 2 * INPUT_CHUNK) && \
  |  |  ------------------
  |  |  |  |   97|   645k|#define INPUT_CHUNK	250
  |  |  ------------------
  |  |  |  Branch (2266:9): [True: 4.34k, False: 641k]
  |  |  ------------------
  |  | 2267|   646k|	(ctxt->input->end - ctxt->input->cur < 2 * INPUT_CHUNK)) \
  |  |  ------------------
  |  |  |  |   97|  4.34k|#define INPUT_CHUNK	250
  |  |  ------------------
  |  |  |  Branch (2267:2): [True: 160, False: 4.18k]
  |  |  ------------------
  |  | 2268|   646k|	xmlParserShrink(ctxt);
  ------------------
 5139|   646k|	GROW;
  ------------------
  |  | 2270|   646k|#define GROW if (ctxt->input->end - ctxt->input->cur < INPUT_CHUNK)	\
  |  |  ------------------
  |  |  |  |   97|   646k|#define INPUT_CHUNK	250
  |  |  ------------------
  |  |  |  Branch (2270:18): [True: 576k, False: 70.3k]
  |  |  ------------------
  |  | 2271|   646k|	xmlParserGrow(ctxt);
  ------------------
 5140|   646k|        if (ctxt->instate == XML_PARSER_EOF) {
  ------------------
  |  Branch (5140:13): [True: 0, False: 646k]
  ------------------
 5141|      0|            xmlFree(buf);
 5142|      0|            return;
 5143|      0|        }
 5144|   646k|	in = ctxt->input->cur;
 5145|   646k|	if (*in == '-') {
  ------------------
  |  Branch (5145:6): [True: 646k, False: 64]
  ------------------
 5146|   646k|	    if (in[1] == '-') {
  ------------------
  |  Branch (5146:10): [True: 643k, False: 3.12k]
  ------------------
 5147|   643k|	        if (in[2] == '>') {
  ------------------
  |  Branch (5147:14): [True: 643k, False: 0]
  ------------------
 5148|   643k|		    if (ctxt->input->id != inputid) {
  ------------------
  |  Branch (5148:11): [True: 0, False: 643k]
  ------------------
 5149|      0|			xmlFatalErrMsg(ctxt, XML_ERR_ENTITY_BOUNDARY,
 5150|      0|			               "comment doesn't start and stop in the"
 5151|      0|                                       " same entity\n");
 5152|      0|		    }
 5153|   643k|		    SKIP(3);
  ------------------
  |  | 2245|   643k|#define SKIP(val) do {							\
  |  | 2246|   643k|    ctxt->input->cur += (val),ctxt->input->col+=(val);			\
  |  | 2247|   643k|    if (*ctxt->input->cur == 0)						\
  |  |  ------------------
  |  |  |  Branch (2247:9): [True: 60.6k, False: 582k]
  |  |  ------------------
  |  | 2248|   643k|        xmlParserGrow(ctxt);						\
  |  | 2249|   643k|  } while (0)
  |  |  ------------------
  |  |  |  Branch (2249:12): [Folded - Ignored]
  |  |  ------------------
  ------------------
 5154|   643k|		    if ((ctxt->sax != NULL) && (ctxt->sax->comment != NULL) &&
  ------------------
  |  Branch (5154:11): [True: 643k, False: 0]
  |  Branch (5154:34): [True: 643k, False: 0]
  ------------------
 5155|   643k|		        (!ctxt->disableSAX)) {
  ------------------
  |  Branch (5155:11): [True: 643k, False: 0]
  ------------------
 5156|   643k|			if (buf != NULL)
  ------------------
  |  Branch (5156:8): [True: 3.06k, False: 640k]
  ------------------
 5157|  3.06k|			    ctxt->sax->comment(ctxt->userData, buf);
 5158|   640k|			else
 5159|   640k|			    ctxt->sax->comment(ctxt->userData, BAD_CAST "");
  ------------------
  |  |   35|   640k|#define BAD_CAST (xmlChar *)
  ------------------
 5160|   643k|		    }
 5161|   643k|		    if (buf != NULL)
  ------------------
  |  Branch (5161:11): [True: 3.06k, False: 640k]
  ------------------
 5162|  3.06k|		        xmlFree(buf);
 5163|   643k|		    if (ctxt->instate != XML_PARSER_EOF)
  ------------------
  |  Branch (5163:11): [True: 643k, False: 0]
  ------------------
 5164|   643k|			ctxt->instate = state;
 5165|   643k|		    return;
 5166|   643k|		}
 5167|      0|		if (buf != NULL) {
  ------------------
  |  Branch (5167:7): [True: 0, False: 0]
  ------------------
 5168|      0|		    xmlFatalErrMsgStr(ctxt, XML_ERR_HYPHEN_IN_COMMENT,
 5169|      0|		                      "Double hyphen within comment: "
 5170|      0|                                      "<!--%.50s\n",
 5171|      0|				      buf);
 5172|      0|		} else
 5173|      0|		    xmlFatalErrMsgStr(ctxt, XML_ERR_HYPHEN_IN_COMMENT,
 5174|      0|		                      "Double hyphen within comment\n", NULL);
 5175|      0|                if (ctxt->instate == XML_PARSER_EOF) {
  ------------------
  |  Branch (5175:21): [True: 0, False: 0]
  ------------------
 5176|      0|                    xmlFree(buf);
 5177|      0|                    return;
 5178|      0|                }
 5179|      0|		in++;
 5180|      0|		ctxt->input->col++;
 5181|      0|	    }
 5182|  3.12k|	    in++;
 5183|  3.12k|	    ctxt->input->col++;
 5184|  3.12k|	    goto get_more;
 5185|   646k|	}
 5186|   646k|    } while (((*in >= 0x20) && (*in <= 0x7F)) || (*in == 0x09) || (*in == 0x0a));
  ------------------
  |  Branch (5186:15): [True: 60, False: 4]
  |  Branch (5186:32): [True: 40, False: 20]
  |  Branch (5186:50): [True: 0, False: 24]
  |  Branch (5186:67): [True: 0, False: 24]
  ------------------
 5187|     24|    xmlParseCommentComplex(ctxt, buf, len, size);
 5188|     24|    ctxt->instate = state;
 5189|     24|    return;
 5190|   643k|}
xmlParsePITarget:
 5207|     88|xmlParsePITarget(xmlParserCtxtPtr ctxt) {
 5208|     88|    const xmlChar *name;
 5209|       |
 5210|     88|    name = xmlParseName(ctxt);
 5211|     88|    if ((name != NULL) &&
  ------------------
  |  Branch (5211:9): [True: 88, False: 0]
  ------------------
 5212|     88|        ((name[0] == 'x') || (name[0] == 'X')) &&
  ------------------
  |  Branch (5212:10): [True: 12, False: 76]
  |  Branch (5212:30): [True: 0, False: 76]
  ------------------
 5213|     88|        ((name[1] == 'm') || (name[1] == 'M')) &&
  ------------------
  |  Branch (5213:10): [True: 8, False: 4]
  |  Branch (5213:30): [True: 0, False: 4]
  ------------------
 5214|     88|        ((name[2] == 'l') || (name[2] == 'L'))) {
  ------------------
  |  Branch (5214:10): [True: 4, False: 4]
  |  Branch (5214:30): [True: 0, False: 4]
  ------------------
 5215|      4|	int i;
 5216|      4|	if ((name[0] == 'x') && (name[1] == 'm') &&
  ------------------
  |  Branch (5216:6): [True: 4, False: 0]
  |  Branch (5216:26): [True: 4, False: 0]
  ------------------
 5217|      4|	    (name[2] == 'l') && (name[3] == 0)) {
  ------------------
  |  Branch (5217:6): [True: 4, False: 0]
  |  Branch (5217:26): [True: 0, False: 4]
  ------------------
 5218|      0|	    xmlFatalErrMsg(ctxt, XML_ERR_RESERVED_XML_NAME,
 5219|      0|		 "XML declaration allowed only at the start of the document\n");
 5220|      0|	    return(name);
 5221|      4|	} else if (name[3] == 0) {
  ------------------
  |  Branch (5221:13): [True: 0, False: 4]
  ------------------
 5222|      0|	    xmlFatalErr(ctxt, XML_ERR_RESERVED_XML_NAME, NULL);
 5223|      0|	    return(name);
 5224|      0|	}
 5225|      4|	for (i = 0;;i++) {
 5226|      4|	    if (xmlW3CPIs[i] == NULL) break;
  ------------------
  |  Branch (5226:10): [True: 0, False: 4]
  ------------------
 5227|      4|	    if (xmlStrEqual(name, (const xmlChar *)xmlW3CPIs[i]))
  ------------------
  |  Branch (5227:10): [True: 4, False: 0]
  ------------------
 5228|      4|	        return(name);
 5229|      4|	}
 5230|      0|	xmlWarningMsg(ctxt, XML_ERR_RESERVED_XML_NAME,
 5231|      0|		      "xmlParsePITarget: invalid name prefix 'xml'\n",
 5232|      0|		      NULL, NULL);
 5233|      0|    }
 5234|     84|    if ((name != NULL) && (xmlStrchr(name, ':') != NULL)) {
  ------------------
  |  Branch (5234:9): [True: 84, False: 0]
  |  Branch (5234:27): [True: 0, False: 84]
  ------------------
 5235|      0|	xmlNsErr(ctxt, XML_NS_ERR_COLON,
 5236|      0|		 "colons are forbidden from PI names '%s'\n", name, NULL, NULL);
 5237|      0|    }
 5238|     84|    return(name);
 5239|     88|}
xmlParsePI:
 5317|     88|xmlParsePI(xmlParserCtxtPtr ctxt) {
 5318|     88|    xmlChar *buf = NULL;
 5319|     88|    size_t len = 0;
 5320|     88|    size_t size = XML_PARSER_BUFFER_SIZE;
  ------------------
  |  |  167|     88|#define XML_PARSER_BUFFER_SIZE 100
  ------------------
 5321|     88|    size_t maxLength = (ctxt->options & XML_PARSE_HUGE) ?
  ------------------
  |  Branch (5321:24): [True: 0, False: 88]
  ------------------
 5322|      0|                       XML_MAX_HUGE_LENGTH :
  ------------------
  |  |   49|      0|#define XML_MAX_HUGE_LENGTH 1000000000
  ------------------
 5323|     88|                       XML_MAX_TEXT_LENGTH;
  ------------------
  |  |   42|    176|#define XML_MAX_TEXT_LENGTH 10000000
  ------------------
 5324|     88|    int cur, l;
 5325|     88|    const xmlChar *target;
 5326|     88|    xmlParserInputState state;
 5327|       |
 5328|     88|    if ((RAW == '<') && (NXT(1) == '?')) {
  ------------------
  |  | 2221|     88|#define RAW (*ctxt->input->cur)
  ------------------
                  if ((RAW == '<') && (NXT(1) == '?')) {
  ------------------
  |  | 2223|     88|#define NXT(val) ctxt->input->cur[(val)]
  ------------------
  |  Branch (5328:9): [True: 88, False: 0]
  |  Branch (5328:25): [True: 88, False: 0]
  ------------------
 5329|     88|	int inputid = ctxt->input->id;
 5330|     88|	state = ctxt->instate;
 5331|     88|        ctxt->instate = XML_PARSER_PI;
 5332|       |	/*
 5333|       |	 * this is a Processing Instruction.
 5334|       |	 */
 5335|     88|	SKIP(2);
  ------------------
  |  | 2245|     88|#define SKIP(val) do {							\
  |  | 2246|     88|    ctxt->input->cur += (val),ctxt->input->col+=(val);			\
  |  | 2247|     88|    if (*ctxt->input->cur == 0)						\
  |  |  ------------------
  |  |  |  Branch (2247:9): [True: 0, False: 88]
  |  |  ------------------
  |  | 2248|     88|        xmlParserGrow(ctxt);						\
  |  | 2249|     88|  } while (0)
  |  |  ------------------
  |  |  |  Branch (2249:12): [Folded - Ignored]
  |  |  ------------------
  ------------------
 5336|       |
 5337|       |	/*
 5338|       |	 * Parse the target name and check for special support like
 5339|       |	 * namespace.
 5340|       |	 */
 5341|     88|        target = xmlParsePITarget(ctxt);
 5342|     88|	if (target != NULL) {
  ------------------
  |  Branch (5342:6): [True: 88, False: 0]
  ------------------
 5343|     88|	    if ((RAW == '?') && (NXT(1) == '>')) {
  ------------------
  |  | 2221|     88|#define RAW (*ctxt->input->cur)
  ------------------
              	    if ((RAW == '?') && (NXT(1) == '>')) {
  ------------------
  |  | 2223|      4|#define NXT(val) ctxt->input->cur[(val)]
  ------------------
  |  Branch (5343:10): [True: 4, False: 84]
  |  Branch (5343:26): [True: 4, False: 0]
  ------------------
 5344|      4|		if (inputid != ctxt->input->id) {
  ------------------
  |  Branch (5344:7): [True: 0, False: 4]
  ------------------
 5345|      0|		    xmlFatalErrMsg(ctxt, XML_ERR_ENTITY_BOUNDARY,
 5346|      0|	                           "PI declaration doesn't start and stop in"
 5347|      0|                                   " the same entity\n");
 5348|      0|		}
 5349|      4|		SKIP(2);
  ------------------
  |  | 2245|      4|#define SKIP(val) do {							\
  |  | 2246|      4|    ctxt->input->cur += (val),ctxt->input->col+=(val);			\
  |  | 2247|      4|    if (*ctxt->input->cur == 0)						\
  |  |  ------------------
  |  |  |  Branch (2247:9): [True: 0, False: 4]
  |  |  ------------------
  |  | 2248|      4|        xmlParserGrow(ctxt);						\
  |  | 2249|      4|  } while (0)
  |  |  ------------------
  |  |  |  Branch (2249:12): [Folded - Ignored]
  |  |  ------------------
  ------------------
 5350|       |
 5351|       |		/*
 5352|       |		 * SAX: PI detected.
 5353|       |		 */
 5354|      4|		if ((ctxt->sax) && (!ctxt->disableSAX) &&
  ------------------
  |  Branch (5354:7): [True: 4, False: 0]
  |  Branch (5354:22): [True: 4, False: 0]
  ------------------
 5355|      4|		    (ctxt->sax->processingInstruction != NULL))
  ------------------
  |  Branch (5355:7): [True: 4, False: 0]
  ------------------
 5356|      4|		    ctxt->sax->processingInstruction(ctxt->userData,
 5357|      4|		                                     target, NULL);
 5358|      4|		if (ctxt->instate != XML_PARSER_EOF)
  ------------------
  |  Branch (5358:7): [True: 4, False: 0]
  ------------------
 5359|      4|		    ctxt->instate = state;
 5360|      4|		return;
 5361|      4|	    }
 5362|     84|	    buf = (xmlChar *) xmlMallocAtomic(size);
 5363|     84|	    if (buf == NULL) {
  ------------------
  |  Branch (5363:10): [True: 0, False: 84]
  ------------------
 5364|      0|		xmlErrMemory(ctxt, NULL);
 5365|      0|		ctxt->instate = state;
 5366|      0|		return;
 5367|      0|	    }
 5368|     84|	    if (SKIP_BLANKS == 0) {
  ------------------
  |  | 2273|     84|#define SKIP_BLANKS xmlSkipBlankChars(ctxt)
  ------------------
  |  Branch (5368:10): [True: 4, False: 80]
  ------------------
 5369|      4|		xmlFatalErrMsgStr(ctxt, XML_ERR_SPACE_REQUIRED,
 5370|      4|			  "ParsePI: PI %s space expected\n", target);
 5371|      4|	    }
 5372|     84|	    cur = CUR_CHAR(l);
  ------------------
  |  | 2291|     84|#define CUR_CHAR(l) xmlCurrentChar(ctxt, &l)
  ------------------
 5373|    916|	    while (IS_CHAR(cur) && /* checked */
  ------------------
  |  |  125|    916|#define IS_CHAR(c)   xmlIsCharQ(c)
  |  |  ------------------
  |  |  |  |  118|  1.83k|#define xmlIsCharQ(c)		(((c) < 0x100) ? \
  |  |  |  |  ------------------
  |  |  |  |  |  Branch (118:24): [True: 916, False: 0]
  |  |  |  |  |  Branch (118:25): [True: 916, False: 0]
  |  |  |  |  ------------------
  |  |  |  |  119|  1.83k|				 xmlIsChar_ch((c)) :\
  |  |  |  |  ------------------
  |  |  |  |  |  |  108|    916|#define xmlIsChar_ch(c)		(((0x9 <= (c)) && ((c) <= 0xa)) || \
  |  |  |  |  |  |  ------------------
  |  |  |  |  |  |  |  Branch (108:28): [True: 916, False: 0]
  |  |  |  |  |  |  |  Branch (108:44): [True: 4, False: 912]
  |  |  |  |  |  |  ------------------
  |  |  |  |  |  |  109|    916|				 ((c) == 0xd) || \
  |  |  |  |  |  |  ------------------
  |  |  |  |  |  |  |  Branch (109:6): [True: 0, False: 912]
  |  |  |  |  |  |  ------------------
  |  |  |  |  |  |  110|    916|				  (0x20 <= (c)))
  |  |  |  |  |  |  ------------------
  |  |  |  |  |  |  |  Branch (110:7): [True: 912, False: 0]
  |  |  |  |  |  |  ------------------
  |  |  |  |  ------------------
  |  |  |  |  120|  1.83k|				(((0x100 <= (c)) && ((c) <= 0xd7ff)) || \
  |  |  |  |  ------------------
  |  |  |  |  |  Branch (120:7): [True: 0, False: 0]
  |  |  |  |  |  Branch (120:25): [True: 0, False: 0]
  |  |  |  |  ------------------
  |  |  |  |  121|      0|				 ((0xe000 <= (c)) && ((c) <= 0xfffd)) || \
  |  |  |  |  ------------------
  |  |  |  |  |  Branch (121:7): [True: 0, False: 0]
  |  |  |  |  |  Branch (121:26): [True: 0, False: 0]
  |  |  |  |  ------------------
  |  |  |  |  122|      0|				 ((0x10000 <= (c)) && ((c) <= 0x10ffff))))
  |  |  |  |  ------------------
  |  |  |  |  |  Branch (122:7): [True: 0, False: 0]
  |  |  |  |  |  Branch (122:27): [True: 0, False: 0]
  |  |  |  |  ------------------
  |  |  ------------------
  ------------------
 5374|    916|		   ((cur != '?') || (NXT(1) != '>'))) {
  ------------------
  |  | 2223|     84|#define NXT(val) ctxt->input->cur[(val)]
  ------------------
  |  Branch (5374:7): [True: 832, False: 84]
  |  Branch (5374:23): [True: 0, False: 84]
  ------------------
 5375|    832|		if (len + 5 >= size) {
  ------------------
  |  Branch (5375:7): [True: 0, False: 832]
  ------------------
 5376|      0|		    xmlChar *tmp;
 5377|      0|                    size_t new_size = size * 2;
 5378|      0|		    tmp = (xmlChar *) xmlRealloc(buf, new_size);
 5379|      0|		    if (tmp == NULL) {
  ------------------
  |  Branch (5379:11): [True: 0, False: 0]
  ------------------
 5380|      0|			xmlErrMemory(ctxt, NULL);
 5381|      0|			xmlFree(buf);
 5382|      0|			ctxt->instate = state;
 5383|      0|			return;
 5384|      0|		    }
 5385|      0|		    buf = tmp;
 5386|      0|                    size = new_size;
 5387|      0|		}
 5388|    832|		COPY_BUF(buf, len, cur);
  ------------------
  |  | 2295|    832|    if (v < 0x80) b[i++] = v;						\
  |  |  ------------------
  |  |  |  Branch (2295:9): [True: 832, False: 0]
  |  |  ------------------
  |  | 2296|    832|    else i += xmlCopyCharMultiByte(&b[i],v)
  ------------------
 5389|    832|                if (len > maxLength) {
  ------------------
  |  Branch (5389:21): [True: 0, False: 832]
  ------------------
 5390|      0|                    xmlFatalErrMsgStr(ctxt, XML_ERR_PI_NOT_FINISHED,
 5391|      0|                                      "PI %s too big found", target);
 5392|      0|                    xmlFree(buf);
 5393|      0|                    ctxt->instate = state;
 5394|      0|                    return;
 5395|      0|                }
 5396|    832|		NEXTL(l);
  ------------------
  |  | 2284|    832|#define NEXTL(l) do {							\
  |  | 2285|    832|    if (*(ctxt->input->cur) == '\n') {					\
  |  |  ------------------
  |  |  |  Branch (2285:9): [True: 4, False: 828]
  |  |  ------------------
  |  | 2286|      4|	ctxt->input->line++; ctxt->input->col = 1;			\
  |  | 2287|    828|    } else ctxt->input->col++;						\
  |  | 2288|    832|    ctxt->input->cur += l;				\
  |  | 2289|    832|  } while (0)
  |  |  ------------------
  |  |  |  Branch (2289:12): [Folded - Ignored]
  |  |  ------------------
  ------------------
 5397|    832|		cur = CUR_CHAR(l);
  ------------------
  |  | 2291|    832|#define CUR_CHAR(l) xmlCurrentChar(ctxt, &l)
  ------------------
 5398|    832|	    }
 5399|     84|	    buf[len] = 0;
 5400|     84|            if (ctxt->instate == XML_PARSER_EOF) {
  ------------------
  |  Branch (5400:17): [True: 0, False: 84]
  ------------------
 5401|      0|                xmlFree(buf);
 5402|      0|                return;
 5403|      0|            }
 5404|     84|	    if (cur != '?') {
  ------------------
  |  Branch (5404:10): [True: 0, False: 84]
  ------------------
 5405|      0|		xmlFatalErrMsgStr(ctxt, XML_ERR_PI_NOT_FINISHED,
 5406|      0|		      "ParsePI: PI %s never end ...\n", target);
 5407|     84|	    } else {
 5408|     84|		if (inputid != ctxt->input->id) {
  ------------------
  |  Branch (5408:7): [True: 0, False: 84]
  ------------------
 5409|      0|		    xmlFatalErrMsg(ctxt, XML_ERR_ENTITY_BOUNDARY,
 5410|      0|	                           "PI declaration doesn't start and stop in"
 5411|      0|                                   " the same entity\n");
 5412|      0|		}
 5413|     84|		SKIP(2);
  ------------------
  |  | 2245|     84|#define SKIP(val) do {							\
  |  | 2246|     84|    ctxt->input->cur += (val),ctxt->input->col+=(val);			\
  |  | 2247|     84|    if (*ctxt->input->cur == 0)						\
  |  |  ------------------
  |  |  |  Branch (2247:9): [True: 4, False: 80]
  |  |  ------------------
  |  | 2248|     84|        xmlParserGrow(ctxt);						\
  |  | 2249|     84|  } while (0)
  |  |  ------------------
  |  |  |  Branch (2249:12): [Folded - Ignored]
  |  |  ------------------
  ------------------
 5414|       |
 5415|     84|#ifdef LIBXML_CATALOG_ENABLED
 5416|     84|		if (((state == XML_PARSER_MISC) ||
  ------------------
  |  Branch (5416:8): [True: 6, False: 78]
  ------------------
 5417|     84|	             (state == XML_PARSER_START)) &&
  ------------------
  |  Branch (5417:15): [True: 6, False: 72]
  ------------------
 5418|     84|		    (xmlStrEqual(target, XML_CATALOG_PI))) {
  ------------------
  |  |   45|     12|    (const xmlChar *) "oasis-xml-catalog"
  ------------------
  |  Branch (5418:7): [True: 0, False: 12]
  ------------------
 5419|      0|		    xmlCatalogAllow allow = xmlCatalogGetDefaults();
 5420|      0|		    if ((allow == XML_CATA_ALLOW_DOCUMENT) ||
  ------------------
  |  Branch (5420:11): [True: 0, False: 0]
  ------------------
 5421|      0|			(allow == XML_CATA_ALLOW_ALL))
  ------------------
  |  Branch (5421:4): [True: 0, False: 0]
  ------------------
 5422|      0|			xmlParseCatalogPI(ctxt, buf);
 5423|      0|		}
 5424|     84|#endif
 5425|       |
 5426|       |
 5427|       |		/*
 5428|       |		 * SAX: PI detected.
 5429|       |		 */
 5430|     84|		if ((ctxt->sax) && (!ctxt->disableSAX) &&
  ------------------
  |  Branch (5430:7): [True: 84, False: 0]
  |  Branch (5430:22): [True: 80, False: 4]
  ------------------
 5431|     84|		    (ctxt->sax->processingInstruction != NULL))
  ------------------
  |  Branch (5431:7): [True: 80, False: 0]
  ------------------
 5432|     80|		    ctxt->sax->processingInstruction(ctxt->userData,
 5433|     80|		                                     target, buf);
 5434|     84|	    }
 5435|     84|	    xmlFree(buf);
 5436|     84|	} else {
 5437|      0|	    xmlFatalErr(ctxt, XML_ERR_PI_NOT_STARTED, NULL);
 5438|      0|	}
 5439|     84|	if (ctxt->instate != XML_PARSER_EOF)
  ------------------
  |  Branch (5439:6): [True: 84, False: 0]
  ------------------
 5440|     84|	    ctxt->instate = state;
 5441|     84|    }
 5442|     88|}
xmlParseEntityDecl:
 5546|  2.35k|xmlParseEntityDecl(xmlParserCtxtPtr ctxt) {
 5547|  2.35k|    const xmlChar *name = NULL;
 5548|  2.35k|    xmlChar *value = NULL;
 5549|  2.35k|    xmlChar *URI = NULL, *literal = NULL;
 5550|  2.35k|    const xmlChar *ndata = NULL;
 5551|  2.35k|    int isParameter = 0;
 5552|  2.35k|    xmlChar *orig = NULL;
 5553|       |
 5554|  2.35k|    if ((CUR != '<') || (NXT(1) != '!'))
  ------------------
  |  | 2222|  2.35k|#define CUR (*ctxt->input->cur)
  ------------------
                  if ((CUR != '<') || (NXT(1) != '!'))
  ------------------
  |  | 2223|  2.35k|#define NXT(val) ctxt->input->cur[(val)]
  ------------------
  |  Branch (5554:9): [True: 0, False: 2.35k]
  |  Branch (5554:25): [True: 0, False: 2.35k]
  ------------------
 5555|      0|        return;
 5556|  2.35k|    SKIP(2);
  ------------------
  |  | 2245|  2.35k|#define SKIP(val) do {							\
  |  | 2246|  2.35k|    ctxt->input->cur += (val),ctxt->input->col+=(val);			\
  |  | 2247|  2.35k|    if (*ctxt->input->cur == 0)						\
  |  |  ------------------
  |  |  |  Branch (2247:9): [True: 0, False: 2.35k]
  |  |  ------------------
  |  | 2248|  2.35k|        xmlParserGrow(ctxt);						\
  |  | 2249|  2.35k|  } while (0)
  |  |  ------------------
  |  |  |  Branch (2249:12): [Folded - Ignored]
  |  |  ------------------
  ------------------
 5557|       |
 5558|       |    /* GROW; done in the caller */
 5559|  2.35k|    if (CMP6(CUR_PTR, 'E', 'N', 'T', 'I', 'T', 'Y')) {
  ------------------
  |  | 2233|  2.35k|  ( CMP5( s, c1, c2, c3, c4, c5 ) && ((unsigned char *) s)[ 5 ] == c6 )
  |  |  ------------------
  |  |  |  | 2231|  4.71k|  ( CMP4( s, c1, c2, c3, c4 ) && ((unsigned char *) s)[ 4 ] == c5 )
  |  |  |  |  ------------------
  |  |  |  |  |  | 2228|  4.71k|  ( ((unsigned char *) s)[ 0 ] == c1 && ((unsigned char *) s)[ 1 ] == c2 && \
  |  |  |  |  |  |  ------------------
  |  |  |  |  |  |  |  Branch (2228:5): [True: 2.35k, False: 0]
  |  |  |  |  |  |  |  Branch (2228:41): [True: 2.35k, False: 0]
  |  |  |  |  |  |  ------------------
  |  |  |  |  |  | 2229|  2.35k|    ((unsigned char *) s)[ 2 ] == c3 && ((unsigned char *) s)[ 3 ] == c4 )
  |  |  |  |  |  |  ------------------
  |  |  |  |  |  |  |  Branch (2229:5): [True: 2.35k, False: 0]
  |  |  |  |  |  |  |  Branch (2229:41): [True: 2.35k, False: 0]
  |  |  |  |  |  |  ------------------
  |  |  |  |  ------------------
  |  |  |  |  |  Branch (2231:34): [True: 2.35k, False: 0]
  |  |  |  |  ------------------
  |  |  ------------------
  |  |  |  Branch (2233:38): [True: 2.35k, False: 0]
  |  |  ------------------
  ------------------
 5560|  2.35k|	int inputid = ctxt->input->id;
 5561|  2.35k|	SKIP(6);
  ------------------
  |  | 2245|  2.35k|#define SKIP(val) do {							\
  |  | 2246|  2.35k|    ctxt->input->cur += (val),ctxt->input->col+=(val);			\
  |  | 2247|  2.35k|    if (*ctxt->input->cur == 0)						\
  |  |  ------------------
  |  |  |  Branch (2247:9): [True: 0, False: 2.35k]
  |  |  ------------------
  |  | 2248|  2.35k|        xmlParserGrow(ctxt);						\
  |  | 2249|  2.35k|  } while (0)
  |  |  ------------------
  |  |  |  Branch (2249:12): [Folded - Ignored]
  |  |  ------------------
  ------------------
 5562|  2.35k|	if (SKIP_BLANKS == 0) {
  ------------------
  |  | 2273|  2.35k|#define SKIP_BLANKS xmlSkipBlankChars(ctxt)
  ------------------
  |  Branch (5562:6): [True: 8, False: 2.34k]
  ------------------
 5563|      8|	    xmlFatalErrMsg(ctxt, XML_ERR_SPACE_REQUIRED,
 5564|      8|			   "Space required after '<!ENTITY'\n");
 5565|      8|	}
 5566|       |
 5567|  2.35k|	if (RAW == '%') {
  ------------------
  |  | 2221|  2.35k|#define RAW (*ctxt->input->cur)
  ------------------
  |  Branch (5567:6): [True: 932, False: 1.42k]
  ------------------
 5568|    932|	    NEXT;
  ------------------
  |  | 2275|    932|#define NEXT xmlNextChar(ctxt)
  ------------------
 5569|    932|	    if (SKIP_BLANKS == 0) {
  ------------------
  |  | 2273|    932|#define SKIP_BLANKS xmlSkipBlankChars(ctxt)
  ------------------
  |  Branch (5569:10): [True: 0, False: 932]
  ------------------
 5570|      0|		xmlFatalErrMsg(ctxt, XML_ERR_SPACE_REQUIRED,
 5571|      0|			       "Space required after '%%'\n");
 5572|      0|	    }
 5573|    932|	    isParameter = 1;
 5574|    932|	}
 5575|       |
 5576|  2.35k|        name = xmlParseName(ctxt);
 5577|  2.35k|	if (name == NULL) {
  ------------------
  |  Branch (5577:6): [True: 4, False: 2.35k]
  ------------------
 5578|      4|	    xmlFatalErrMsg(ctxt, XML_ERR_NAME_REQUIRED,
 5579|      4|	                   "xmlParseEntityDecl: no name\n");
 5580|      4|            return;
 5581|      4|	}
 5582|  2.35k|	if (xmlStrchr(name, ':') != NULL) {
  ------------------
  |  Branch (5582:6): [True: 0, False: 2.35k]
  ------------------
 5583|      0|	    xmlNsErr(ctxt, XML_NS_ERR_COLON,
 5584|      0|		     "colons are forbidden from entities names '%s'\n",
 5585|      0|		     name, NULL, NULL);
 5586|      0|	}
 5587|  2.35k|	if (SKIP_BLANKS == 0) {
  ------------------
  |  | 2273|  2.35k|#define SKIP_BLANKS xmlSkipBlankChars(ctxt)
  ------------------
  |  Branch (5587:6): [True: 4, False: 2.34k]
  ------------------
 5588|      4|	    xmlFatalErrMsg(ctxt, XML_ERR_SPACE_REQUIRED,
 5589|      4|			   "Space required after the entity name\n");
 5590|      4|	}
 5591|       |
 5592|  2.35k|	ctxt->instate = XML_PARSER_ENTITY_DECL;
 5593|       |	/*
 5594|       |	 * handle the various case of definitions...
 5595|       |	 */
 5596|  2.35k|	if (isParameter) {
  ------------------
  |  Branch (5596:6): [True: 932, False: 1.42k]
  ------------------
 5597|    932|	    if ((RAW == '"') || (RAW == '\'')) {
  ------------------
  |  | 2221|    932|#define RAW (*ctxt->input->cur)
  ------------------
              	    if ((RAW == '"') || (RAW == '\'')) {
  ------------------
  |  | 2221|    248|#define RAW (*ctxt->input->cur)
  ------------------
  |  Branch (5597:10): [True: 684, False: 248]
  |  Branch (5597:26): [True: 212, False: 36]
  ------------------
 5598|    896|	        value = xmlParseEntityValue(ctxt, &orig);
 5599|    896|		if (value) {
  ------------------
  |  Branch (5599:7): [True: 888, False: 8]
  ------------------
 5600|    888|		    if ((ctxt->sax != NULL) &&
  ------------------
  |  Branch (5600:11): [True: 888, False: 0]
  ------------------
 5601|    888|			(!ctxt->disableSAX) && (ctxt->sax->entityDecl != NULL))
  ------------------
  |  Branch (5601:4): [True: 888, False: 0]
  |  Branch (5601:27): [True: 888, False: 0]
  ------------------
 5602|    888|			ctxt->sax->entityDecl(ctxt->userData, name,
 5603|    888|		                    XML_INTERNAL_PARAMETER_ENTITY,
 5604|    888|				    NULL, NULL, value);
 5605|    888|		}
 5606|    896|	    } else {
 5607|     36|	        URI = xmlParseExternalID(ctxt, &literal, 1);
 5608|     36|		if ((URI == NULL) && (literal == NULL)) {
  ------------------
  |  Branch (5608:7): [True: 0, False: 36]
  |  Branch (5608:24): [True: 0, False: 0]
  ------------------
 5609|      0|		    xmlFatalErr(ctxt, XML_ERR_VALUE_REQUIRED, NULL);
 5610|      0|		}
 5611|     36|		if (URI) {
  ------------------
  |  Branch (5611:7): [True: 36, False: 0]
  ------------------
 5612|     36|		    xmlURIPtr uri;
 5613|       |
 5614|     36|		    uri = xmlParseURI((const char *) URI);
 5615|     36|		    if (uri == NULL) {
  ------------------
  |  Branch (5615:11): [True: 0, False: 36]
  ------------------
 5616|      0|		        xmlErrMsgStr(ctxt, XML_ERR_INVALID_URI,
 5617|      0|				     "Invalid URI: %s\n", URI);
 5618|       |			/*
 5619|       |			 * This really ought to be a well formedness error
 5620|       |			 * but the XML Core WG decided otherwise c.f. issue
 5621|       |			 * E26 of the XML erratas.
 5622|       |			 */
 5623|     36|		    } else {
 5624|     36|			if (uri->fragment != NULL) {
  ------------------
  |  Branch (5624:8): [True: 0, False: 36]
  ------------------
 5625|       |			    /*
 5626|       |			     * Okay this is foolish to block those but not
 5627|       |			     * invalid URIs.
 5628|       |			     */
 5629|      0|			    xmlFatalErr(ctxt, XML_ERR_URI_FRAGMENT, NULL);
 5630|     36|			} else {
 5631|     36|			    if ((ctxt->sax != NULL) &&
  ------------------
  |  Branch (5631:12): [True: 36, False: 0]
  ------------------
 5632|     36|				(!ctxt->disableSAX) &&
  ------------------
  |  Branch (5632:5): [True: 36, False: 0]
  ------------------
 5633|     36|				(ctxt->sax->entityDecl != NULL))
  ------------------
  |  Branch (5633:5): [True: 36, False: 0]
  ------------------
 5634|     36|				ctxt->sax->entityDecl(ctxt->userData, name,
 5635|     36|					    XML_EXTERNAL_PARAMETER_ENTITY,
 5636|     36|					    literal, URI, NULL);
 5637|     36|			}
 5638|     36|			xmlFreeURI(uri);
 5639|     36|		    }
 5640|     36|		}
 5641|     36|	    }
 5642|  1.42k|	} else {
 5643|  1.42k|	    if ((RAW == '"') || (RAW == '\'')) {
  ------------------
  |  | 2221|  1.42k|#define RAW (*ctxt->input->cur)
  ------------------
              	    if ((RAW == '"') || (RAW == '\'')) {
  ------------------
  |  | 2221|    128|#define RAW (*ctxt->input->cur)
  ------------------
  |  Branch (5643:10): [True: 1.29k, False: 128]
  |  Branch (5643:26): [True: 76, False: 52]
  ------------------
 5644|  1.36k|	        value = xmlParseEntityValue(ctxt, &orig);
 5645|  1.36k|		if ((ctxt->sax != NULL) &&
  ------------------
  |  Branch (5645:7): [True: 1.36k, False: 0]
  ------------------
 5646|  1.36k|		    (!ctxt->disableSAX) && (ctxt->sax->entityDecl != NULL))
  ------------------
  |  Branch (5646:7): [True: 1.36k, False: 0]
  |  Branch (5646:30): [True: 1.36k, False: 0]
  ------------------
 5647|  1.36k|		    ctxt->sax->entityDecl(ctxt->userData, name,
 5648|  1.36k|				XML_INTERNAL_GENERAL_ENTITY,
 5649|  1.36k|				NULL, NULL, value);
 5650|       |		/*
 5651|       |		 * For expat compatibility in SAX mode.
 5652|       |		 */
 5653|  1.36k|		if ((ctxt->myDoc == NULL) ||
  ------------------
  |  Branch (5653:7): [True: 0, False: 1.36k]
  ------------------
 5654|  1.36k|		    (xmlStrEqual(ctxt->myDoc->version, SAX_COMPAT_MODE))) {
  ------------------
  |  |  168|  1.36k|#define SAX_COMPAT_MODE BAD_CAST "SAX compatibility mode document"
  |  |  ------------------
  |  |  |  |   35|  1.36k|#define BAD_CAST (xmlChar *)
  |  |  ------------------
  ------------------
  |  Branch (5654:7): [True: 0, False: 1.36k]
  ------------------
 5655|      0|		    if (ctxt->myDoc == NULL) {
  ------------------
  |  Branch (5655:11): [True: 0, False: 0]
  ------------------
 5656|      0|			ctxt->myDoc = xmlNewDoc(SAX_COMPAT_MODE);
  ------------------
  |  |  168|      0|#define SAX_COMPAT_MODE BAD_CAST "SAX compatibility mode document"
  |  |  ------------------
  |  |  |  |   35|      0|#define BAD_CAST (xmlChar *)
  |  |  ------------------
  ------------------
 5657|      0|			if (ctxt->myDoc == NULL) {
  ------------------
  |  Branch (5657:8): [True: 0, False: 0]
  ------------------
 5658|      0|			    xmlErrMemory(ctxt, "New Doc failed");
 5659|      0|			    goto done;
 5660|      0|			}
 5661|      0|			ctxt->myDoc->properties = XML_DOC_INTERNAL;
 5662|      0|		    }
 5663|      0|		    if (ctxt->myDoc->intSubset == NULL)
  ------------------
  |  Branch (5663:11): [True: 0, False: 0]
  ------------------
 5664|      0|			ctxt->myDoc->intSubset = xmlNewDtd(ctxt->myDoc,
 5665|      0|					    BAD_CAST "fake", NULL, NULL);
  ------------------
  |  |   35|      0|#define BAD_CAST (xmlChar *)
  ------------------
 5666|       |
 5667|      0|		    xmlSAX2EntityDecl(ctxt, name, XML_INTERNAL_GENERAL_ENTITY,
 5668|      0|			              NULL, NULL, value);
 5669|      0|		}
 5670|  1.36k|	    } else {
 5671|     52|	        URI = xmlParseExternalID(ctxt, &literal, 1);
 5672|     52|		if ((URI == NULL) && (literal == NULL)) {
  ------------------
  |  Branch (5672:7): [True: 4, False: 48]
  |  Branch (5672:24): [True: 4, False: 0]
  ------------------
 5673|      4|		    xmlFatalErr(ctxt, XML_ERR_VALUE_REQUIRED, NULL);
 5674|      4|		}
 5675|     52|		if (URI) {
  ------------------
  |  Branch (5675:7): [True: 48, False: 4]
  ------------------
 5676|     48|		    xmlURIPtr uri;
 5677|       |
 5678|     48|		    uri = xmlParseURI((const char *)URI);
 5679|     48|		    if (uri == NULL) {
  ------------------
  |  Branch (5679:11): [True: 0, False: 48]
  ------------------
 5680|      0|		        xmlErrMsgStr(ctxt, XML_ERR_INVALID_URI,
 5681|      0|				     "Invalid URI: %s\n", URI);
 5682|       |			/*
 5683|       |			 * This really ought to be a well formedness error
 5684|       |			 * but the XML Core WG decided otherwise c.f. issue
 5685|       |			 * E26 of the XML erratas.
 5686|       |			 */
 5687|     48|		    } else {
 5688|     48|			if (uri->fragment != NULL) {
  ------------------
  |  Branch (5688:8): [True: 0, False: 48]
  ------------------
 5689|       |			    /*
 5690|       |			     * Okay this is foolish to block those but not
 5691|       |			     * invalid URIs.
 5692|       |			     */
 5693|      0|			    xmlFatalErr(ctxt, XML_ERR_URI_FRAGMENT, NULL);
 5694|      0|			}
 5695|     48|			xmlFreeURI(uri);
 5696|     48|		    }
 5697|     48|		}
 5698|     52|		if ((RAW != '>') && (SKIP_BLANKS == 0)) {
  ------------------
  |  | 2221|     52|#define RAW (*ctxt->input->cur)
  ------------------
              		if ((RAW != '>') && (SKIP_BLANKS == 0)) {
  ------------------
  |  | 2273|      4|#define SKIP_BLANKS xmlSkipBlankChars(ctxt)
  ------------------
  |  Branch (5698:7): [True: 4, False: 48]
  |  Branch (5698:23): [True: 0, False: 4]
  ------------------
 5699|      0|		    xmlFatalErrMsg(ctxt, XML_ERR_SPACE_REQUIRED,
 5700|      0|				   "Space required before 'NDATA'\n");
 5701|      0|		}
 5702|     52|		if (CMP5(CUR_PTR, 'N', 'D', 'A', 'T', 'A')) {
  ------------------
  |  | 2231|     52|  ( CMP4( s, c1, c2, c3, c4 ) && ((unsigned char *) s)[ 4 ] == c5 )
  |  |  ------------------
  |  |  |  | 2228|    104|  ( ((unsigned char *) s)[ 0 ] == c1 && ((unsigned char *) s)[ 1 ] == c2 && \
  |  |  |  |  ------------------
  |  |  |  |  |  Branch (2228:5): [True: 4, False: 48]
  |  |  |  |  |  Branch (2228:41): [True: 4, False: 0]
  |  |  |  |  ------------------
  |  |  |  | 2229|     52|    ((unsigned char *) s)[ 2 ] == c3 && ((unsigned char *) s)[ 3 ] == c4 )
  |  |  |  |  ------------------
  |  |  |  |  |  Branch (2229:5): [True: 4, False: 0]
  |  |  |  |  |  Branch (2229:41): [True: 4, False: 0]
  |  |  |  |  ------------------
  |  |  ------------------
  |  |  |  Branch (2231:34): [True: 4, False: 0]
  |  |  ------------------
  ------------------
 5703|      4|		    SKIP(5);
  ------------------
  |  | 2245|      4|#define SKIP(val) do {							\
  |  | 2246|      4|    ctxt->input->cur += (val),ctxt->input->col+=(val);			\
  |  | 2247|      4|    if (*ctxt->input->cur == 0)						\
  |  |  ------------------
  |  |  |  Branch (2247:9): [True: 0, False: 4]
  |  |  ------------------
  |  | 2248|      4|        xmlParserGrow(ctxt);						\
  |  | 2249|      4|  } while (0)
  |  |  ------------------
  |  |  |  Branch (2249:12): [Folded - Ignored]
  |  |  ------------------
  ------------------
 5704|      4|		    if (SKIP_BLANKS == 0) {
  ------------------
  |  | 2273|      4|#define SKIP_BLANKS xmlSkipBlankChars(ctxt)
  ------------------
  |  Branch (5704:11): [True: 0, False: 4]
  ------------------
 5705|      0|			xmlFatalErrMsg(ctxt, XML_ERR_SPACE_REQUIRED,
 5706|      0|				       "Space required after 'NDATA'\n");
 5707|      0|		    }
 5708|      4|		    ndata = xmlParseName(ctxt);
 5709|      4|		    if ((ctxt->sax != NULL) && (!ctxt->disableSAX) &&
  ------------------
  |  Branch (5709:11): [True: 4, False: 0]
  |  Branch (5709:34): [True: 4, False: 0]
  ------------------
 5710|      4|		        (ctxt->sax->unparsedEntityDecl != NULL))
  ------------------
  |  Branch (5710:11): [True: 4, False: 0]
  ------------------
 5711|      4|			ctxt->sax->unparsedEntityDecl(ctxt->userData, name,
 5712|      4|				    literal, URI, ndata);
 5713|     48|		} else {
 5714|     48|		    if ((ctxt->sax != NULL) &&
  ------------------
  |  Branch (5714:11): [True: 48, False: 0]
  ------------------
 5715|     48|		        (!ctxt->disableSAX) && (ctxt->sax->entityDecl != NULL))
  ------------------
  |  Branch (5715:11): [True: 44, False: 4]
  |  Branch (5715:34): [True: 44, False: 0]
  ------------------
 5716|     44|			ctxt->sax->entityDecl(ctxt->userData, name,
 5717|     44|				    XML_EXTERNAL_GENERAL_PARSED_ENTITY,
 5718|     44|				    literal, URI, NULL);
 5719|       |		    /*
 5720|       |		     * For expat compatibility in SAX mode.
 5721|       |		     * assuming the entity replacement was asked for
 5722|       |		     */
 5723|     48|		    if ((ctxt->replaceEntities != 0) &&
  ------------------
  |  Branch (5723:11): [True: 48, False: 0]
  ------------------
 5724|     48|			((ctxt->myDoc == NULL) ||
  ------------------
  |  Branch (5724:5): [True: 0, False: 48]
  ------------------
 5725|     48|			(xmlStrEqual(ctxt->myDoc->version, SAX_COMPAT_MODE)))) {
  ------------------
  |  |  168|     48|#define SAX_COMPAT_MODE BAD_CAST "SAX compatibility mode document"
  |  |  ------------------
  |  |  |  |   35|     48|#define BAD_CAST (xmlChar *)
  |  |  ------------------
  ------------------
  |  Branch (5725:4): [True: 0, False: 48]
  ------------------
 5726|      0|			if (ctxt->myDoc == NULL) {
  ------------------
  |  Branch (5726:8): [True: 0, False: 0]
  ------------------
 5727|      0|			    ctxt->myDoc = xmlNewDoc(SAX_COMPAT_MODE);
  ------------------
  |  |  168|      0|#define SAX_COMPAT_MODE BAD_CAST "SAX compatibility mode document"
  |  |  ------------------
  |  |  |  |   35|      0|#define BAD_CAST (xmlChar *)
  |  |  ------------------
  ------------------
 5728|      0|			    if (ctxt->myDoc == NULL) {
  ------------------
  |  Branch (5728:12): [True: 0, False: 0]
  ------------------
 5729|      0|			        xmlErrMemory(ctxt, "New Doc failed");
 5730|      0|				goto done;
 5731|      0|			    }
 5732|      0|			    ctxt->myDoc->properties = XML_DOC_INTERNAL;
 5733|      0|			}
 5734|       |
 5735|      0|			if (ctxt->myDoc->intSubset == NULL)
  ------------------
  |  Branch (5735:8): [True: 0, False: 0]
  ------------------
 5736|      0|			    ctxt->myDoc->intSubset = xmlNewDtd(ctxt->myDoc,
 5737|      0|						BAD_CAST "fake", NULL, NULL);
  ------------------
  |  |   35|      0|#define BAD_CAST (xmlChar *)
  ------------------
 5738|      0|			xmlSAX2EntityDecl(ctxt, name,
 5739|      0|				          XML_EXTERNAL_GENERAL_PARSED_ENTITY,
 5740|      0|				          literal, URI, NULL);
 5741|      0|		    }
 5742|     48|		}
 5743|     52|	    }
 5744|  1.42k|	}
 5745|  2.35k|	if (ctxt->instate == XML_PARSER_EOF)
  ------------------
  |  Branch (5745:6): [True: 8, False: 2.34k]
  ------------------
 5746|      8|	    goto done;
 5747|  2.34k|	SKIP_BLANKS;
  ------------------
  |  | 2273|  2.34k|#define SKIP_BLANKS xmlSkipBlankChars(ctxt)
  ------------------
 5748|  2.34k|	if (RAW != '>') {
  ------------------
  |  | 2221|  2.34k|#define RAW (*ctxt->input->cur)
  ------------------
  |  Branch (5748:6): [True: 0, False: 2.34k]
  ------------------
 5749|      0|	    xmlFatalErrMsgStr(ctxt, XML_ERR_ENTITY_NOT_FINISHED,
 5750|      0|	            "xmlParseEntityDecl: entity %s not terminated\n", name);
 5751|      0|	    xmlHaltParser(ctxt);
 5752|  2.34k|	} else {
 5753|  2.34k|	    if (inputid != ctxt->input->id) {
  ------------------
  |  Branch (5753:10): [True: 0, False: 2.34k]
  ------------------
 5754|      0|		xmlFatalErrMsg(ctxt, XML_ERR_ENTITY_BOUNDARY,
 5755|      0|	                       "Entity declaration doesn't start and stop in"
 5756|      0|                               " the same entity\n");
 5757|      0|	    }
 5758|  2.34k|	    NEXT;
  ------------------
  |  | 2275|  2.34k|#define NEXT xmlNextChar(ctxt)
  ------------------
 5759|  2.34k|	}
 5760|  2.34k|	if (orig != NULL) {
  ------------------
  |  Branch (5760:6): [True: 2.25k, False: 88]
  ------------------
 5761|       |	    /*
 5762|       |	     * Ugly mechanism to save the raw entity value.
 5763|       |	     */
 5764|  2.25k|	    xmlEntityPtr cur = NULL;
 5765|       |
 5766|  2.25k|	    if (isParameter) {
  ------------------
  |  Branch (5766:10): [True: 888, False: 1.36k]
  ------------------
 5767|    888|	        if ((ctxt->sax != NULL) &&
  ------------------
  |  Branch (5767:14): [True: 888, False: 0]
  ------------------
 5768|    888|		    (ctxt->sax->getParameterEntity != NULL))
  ------------------
  |  Branch (5768:7): [True: 888, False: 0]
  ------------------
 5769|    888|		    cur = ctxt->sax->getParameterEntity(ctxt->userData, name);
 5770|  1.36k|	    } else {
 5771|  1.36k|	        if ((ctxt->sax != NULL) &&
  ------------------
  |  Branch (5771:14): [True: 1.36k, False: 0]
  ------------------
 5772|  1.36k|		    (ctxt->sax->getEntity != NULL))
  ------------------
  |  Branch (5772:7): [True: 1.36k, False: 0]
  ------------------
 5773|  1.36k|		    cur = ctxt->sax->getEntity(ctxt->userData, name);
 5774|  1.36k|		if ((cur == NULL) && (ctxt->userData==ctxt)) {
  ------------------
  |  Branch (5774:7): [True: 0, False: 1.36k]
  |  Branch (5774:24): [True: 0, False: 0]
  ------------------
 5775|      0|		    cur = xmlSAX2GetEntity(ctxt, name);
 5776|      0|		}
 5777|  1.36k|	    }
 5778|  2.25k|            if ((cur != NULL) && (cur->orig == NULL)) {
  ------------------
  |  Branch (5778:17): [True: 2.25k, False: 0]
  |  Branch (5778:34): [True: 2.23k, False: 24]
  ------------------
 5779|  2.23k|		cur->orig = orig;
 5780|  2.23k|                orig = NULL;
 5781|  2.23k|	    }
 5782|  2.25k|	}
 5783|       |
 5784|  2.35k|done:
 5785|  2.35k|	if (value != NULL) xmlFree(value);
  ------------------
  |  Branch (5785:6): [True: 2.25k, False: 96]
  ------------------
 5786|  2.35k|	if (URI != NULL) xmlFree(URI);
  ------------------
  |  Branch (5786:6): [True: 84, False: 2.26k]
  ------------------
 5787|  2.35k|	if (literal != NULL) xmlFree(literal);
  ------------------
  |  Branch (5787:6): [True: 8, False: 2.34k]
  ------------------
 5788|  2.35k|        if (orig != NULL) xmlFree(orig);
  ------------------
  |  Branch (5788:13): [True: 32, False: 2.32k]
  ------------------
 5789|  2.35k|    }
 5790|  2.35k|}
xmlParseDefaultDecl:
 5824|  7.78k|xmlParseDefaultDecl(xmlParserCtxtPtr ctxt, xmlChar **value) {
 5825|  7.78k|    int val;
 5826|  7.78k|    xmlChar *ret;
 5827|       |
 5828|  7.78k|    *value = NULL;
 5829|  7.78k|    if (CMP9(CUR_PTR, '#', 'R', 'E', 'Q', 'U', 'I', 'R', 'E', 'D')) {
  ------------------
  |  | 2239|  7.78k|  ( CMP8( s, c1, c2, c3, c4, c5, c6, c7, c8 ) && \
  |  |  ------------------
  |  |  |  | 2237|  15.5k|  ( CMP7( s, c1, c2, c3, c4, c5, c6, c7 ) && ((unsigned char *) s)[ 7 ] == c8 )
  |  |  |  |  ------------------
  |  |  |  |  |  | 2235|  15.5k|  ( CMP6( s, c1, c2, c3, c4, c5, c6 ) && ((unsigned char *) s)[ 6 ] == c7 )
  |  |  |  |  |  |  ------------------
  |  |  |  |  |  |  |  | 2233|  15.5k|  ( CMP5( s, c1, c2, c3, c4, c5 ) && ((unsigned char *) s)[ 5 ] == c6 )
  |  |  |  |  |  |  |  |  ------------------
  |  |  |  |  |  |  |  |  |  | 2231|  15.5k|  ( CMP4( s, c1, c2, c3, c4 ) && ((unsigned char *) s)[ 4 ] == c5 )
  |  |  |  |  |  |  |  |  |  |  ------------------
  |  |  |  |  |  |  |  |  |  |  |  | 2228|  15.5k|  ( ((unsigned char *) s)[ 0 ] == c1 && ((unsigned char *) s)[ 1 ] == c2 && \
  |  |  |  |  |  |  |  |  |  |  |  |  ------------------
  |  |  |  |  |  |  |  |  |  |  |  |  |  Branch (2228:5): [True: 6.41k, False: 1.36k]
  |  |  |  |  |  |  |  |  |  |  |  |  |  Branch (2228:41): [True: 504, False: 5.91k]
  |  |  |  |  |  |  |  |  |  |  |  |  ------------------
  |  |  |  |  |  |  |  |  |  |  |  | 2229|  7.78k|    ((unsigned char *) s)[ 2 ] == c3 && ((unsigned char *) s)[ 3 ] == c4 )
  |  |  |  |  |  |  |  |  |  |  |  |  ------------------
  |  |  |  |  |  |  |  |  |  |  |  |  |  Branch (2229:5): [True: 504, False: 0]
  |  |  |  |  |  |  |  |  |  |  |  |  |  Branch (2229:41): [True: 504, False: 0]
  |  |  |  |  |  |  |  |  |  |  |  |  ------------------
  |  |  |  |  |  |  |  |  |  |  ------------------
  |  |  |  |  |  |  |  |  |  |  |  Branch (2231:34): [True: 504, False: 0]
  |  |  |  |  |  |  |  |  |  |  ------------------
  |  |  |  |  |  |  |  |  ------------------
  |  |  |  |  |  |  |  |  |  Branch (2233:38): [True: 504, False: 0]
  |  |  |  |  |  |  |  |  ------------------
  |  |  |  |  |  |  ------------------
  |  |  |  |  |  |  |  Branch (2235:42): [True: 504, False: 0]
  |  |  |  |  |  |  ------------------
  |  |  |  |  ------------------
  |  |  |  |  |  Branch (2237:46): [True: 504, False: 0]
  |  |  |  |  ------------------
  |  |  ------------------
  |  | 2240|  7.78k|    ((unsigned char *) s)[ 8 ] == c9 )
  |  |  ------------------
  |  |  |  Branch (2240:5): [True: 504, False: 0]
  |  |  ------------------
  ------------------
 5830|    504|	SKIP(9);
  ------------------
  |  | 2245|    504|#define SKIP(val) do {							\
  |  | 2246|    504|    ctxt->input->cur += (val),ctxt->input->col+=(val);			\
  |  | 2247|    504|    if (*ctxt->input->cur == 0)						\
  |  |  ------------------
  |  |  |  Branch (2247:9): [True: 52, False: 452]
  |  |  ------------------
  |  | 2248|    504|        xmlParserGrow(ctxt);						\
  |  | 2249|    504|  } while (0)
  |  |  ------------------
  |  |  |  Branch (2249:12): [Folded - Ignored]
  |  |  ------------------
  ------------------
 5831|    504|	return(XML_ATTRIBUTE_REQUIRED);
 5832|    504|    }
 5833|  7.27k|    if (CMP8(CUR_PTR, '#', 'I', 'M', 'P', 'L', 'I', 'E', 'D')) {
  ------------------
  |  | 2237|  7.27k|  ( CMP7( s, c1, c2, c3, c4, c5, c6, c7 ) && ((unsigned char *) s)[ 7 ] == c8 )
  |  |  ------------------
  |  |  |  | 2235|  14.5k|  ( CMP6( s, c1, c2, c3, c4, c5, c6 ) && ((unsigned char *) s)[ 6 ] == c7 )
  |  |  |  |  ------------------
  |  |  |  |  |  | 2233|  14.5k|  ( CMP5( s, c1, c2, c3, c4, c5 ) && ((unsigned char *) s)[ 5 ] == c6 )
  |  |  |  |  |  |  ------------------
  |  |  |  |  |  |  |  | 2231|  14.5k|  ( CMP4( s, c1, c2, c3, c4 ) && ((unsigned char *) s)[ 4 ] == c5 )
  |  |  |  |  |  |  |  |  ------------------
  |  |  |  |  |  |  |  |  |  | 2228|  14.5k|  ( ((unsigned char *) s)[ 0 ] == c1 && ((unsigned char *) s)[ 1 ] == c2 && \
  |  |  |  |  |  |  |  |  |  |  ------------------
  |  |  |  |  |  |  |  |  |  |  |  Branch (2228:5): [True: 5.91k, False: 1.36k]
  |  |  |  |  |  |  |  |  |  |  |  Branch (2228:41): [True: 5.63k, False: 280]
  |  |  |  |  |  |  |  |  |  |  ------------------
  |  |  |  |  |  |  |  |  |  | 2229|  7.27k|    ((unsigned char *) s)[ 2 ] == c3 && ((unsigned char *) s)[ 3 ] == c4 )
  |  |  |  |  |  |  |  |  |  |  ------------------
  |  |  |  |  |  |  |  |  |  |  |  Branch (2229:5): [True: 5.63k, False: 0]
  |  |  |  |  |  |  |  |  |  |  |  Branch (2229:41): [True: 5.63k, False: 0]
  |  |  |  |  |  |  |  |  |  |  ------------------
  |  |  |  |  |  |  |  |  ------------------
  |  |  |  |  |  |  |  |  |  Branch (2231:34): [True: 5.63k, False: 0]
  |  |  |  |  |  |  |  |  ------------------
  |  |  |  |  |  |  ------------------
  |  |  |  |  |  |  |  Branch (2233:38): [True: 5.63k, False: 0]
  |  |  |  |  |  |  ------------------
  |  |  |  |  ------------------
  |  |  |  |  |  Branch (2235:42): [True: 5.63k, False: 0]
  |  |  |  |  ------------------
  |  |  ------------------
  |  |  |  Branch (2237:46): [True: 5.63k, False: 0]
  |  |  ------------------
  ------------------
 5834|  5.63k|	SKIP(8);
  ------------------
  |  | 2245|  5.63k|#define SKIP(val) do {							\
  |  | 2246|  5.63k|    ctxt->input->cur += (val),ctxt->input->col+=(val);			\
  |  | 2247|  5.63k|    if (*ctxt->input->cur == 0)						\
  |  |  ------------------
  |  |  |  Branch (2247:9): [True: 1.49k, False: 4.14k]
  |  |  ------------------
  |  | 2248|  5.63k|        xmlParserGrow(ctxt);						\
  |  | 2249|  5.63k|  } while (0)
  |  |  ------------------
  |  |  |  Branch (2249:12): [Folded - Ignored]
  |  |  ------------------
  ------------------
 5835|  5.63k|	return(XML_ATTRIBUTE_IMPLIED);
 5836|  5.63k|    }
 5837|  1.64k|    val = XML_ATTRIBUTE_NONE;
 5838|  1.64k|    if (CMP6(CUR_PTR, '#', 'F', 'I', 'X', 'E', 'D')) {
  ------------------
  |  | 2233|  1.64k|  ( CMP5( s, c1, c2, c3, c4, c5 ) && ((unsigned char *) s)[ 5 ] == c6 )
  |  |  ------------------
  |  |  |  | 2231|  3.28k|  ( CMP4( s, c1, c2, c3, c4 ) && ((unsigned char *) s)[ 4 ] == c5 )
  |  |  |  |  ------------------
  |  |  |  |  |  | 2228|  3.28k|  ( ((unsigned char *) s)[ 0 ] == c1 && ((unsigned char *) s)[ 1 ] == c2 && \
  |  |  |  |  |  |  ------------------
  |  |  |  |  |  |  |  Branch (2228:5): [True: 280, False: 1.36k]
  |  |  |  |  |  |  |  Branch (2228:41): [True: 280, False: 0]
  |  |  |  |  |  |  ------------------
  |  |  |  |  |  | 2229|  1.64k|    ((unsigned char *) s)[ 2 ] == c3 && ((unsigned char *) s)[ 3 ] == c4 )
  |  |  |  |  |  |  ------------------
  |  |  |  |  |  |  |  Branch (2229:5): [True: 280, False: 0]
  |  |  |  |  |  |  |  Branch (2229:41): [True: 280, False: 0]
  |  |  |  |  |  |  ------------------
  |  |  |  |  ------------------
  |  |  |  |  |  Branch (2231:34): [True: 280, False: 0]
  |  |  |  |  ------------------
  |  |  ------------------
  |  |  |  Branch (2233:38): [True: 280, False: 0]
  |  |  ------------------
  ------------------
 5839|    280|	SKIP(6);
  ------------------
  |  | 2245|    280|#define SKIP(val) do {							\
  |  | 2246|    280|    ctxt->input->cur += (val),ctxt->input->col+=(val);			\
  |  | 2247|    280|    if (*ctxt->input->cur == 0)						\
  |  |  ------------------
  |  |  |  Branch (2247:9): [True: 0, False: 280]
  |  |  ------------------
  |  | 2248|    280|        xmlParserGrow(ctxt);						\
  |  | 2249|    280|  } while (0)
  |  |  ------------------
  |  |  |  Branch (2249:12): [Folded - Ignored]
  |  |  ------------------
  ------------------
 5840|    280|	val = XML_ATTRIBUTE_FIXED;
 5841|    280|	if (SKIP_BLANKS == 0) {
  ------------------
  |  | 2273|    280|#define SKIP_BLANKS xmlSkipBlankChars(ctxt)
  ------------------
  |  Branch (5841:6): [True: 0, False: 280]
  ------------------
 5842|      0|	    xmlFatalErrMsg(ctxt, XML_ERR_SPACE_REQUIRED,
 5843|      0|			   "Space required after '#FIXED'\n");
 5844|      0|	}
 5845|    280|    }
 5846|  1.64k|    ret = xmlParseAttValue(ctxt);
 5847|  1.64k|    ctxt->instate = XML_PARSER_DTD;
 5848|  1.64k|    if (ret == NULL) {
  ------------------
  |  Branch (5848:9): [True: 0, False: 1.64k]
  ------------------
 5849|      0|	xmlFatalErrMsg(ctxt, (xmlParserErrors)ctxt->errNo,
 5850|      0|		       "Attribute default value declaration error\n");
 5851|      0|    } else
 5852|  1.64k|        *value = ret;
 5853|  1.64k|    return(val);
 5854|  7.27k|}
xmlParseEnumerationType:
 5947|  1.68k|xmlParseEnumerationType(xmlParserCtxtPtr ctxt) {
 5948|  1.68k|    xmlChar *name;
 5949|  1.68k|    xmlEnumerationPtr ret = NULL, last = NULL, cur, tmp;
 5950|       |
 5951|  1.68k|    if (RAW != '(') {
  ------------------
  |  | 2221|  1.68k|#define RAW (*ctxt->input->cur)
  ------------------
  |  Branch (5951:9): [True: 0, False: 1.68k]
  ------------------
 5952|      0|	xmlFatalErr(ctxt, XML_ERR_ATTLIST_NOT_STARTED, NULL);
 5953|      0|	return(NULL);
 5954|      0|    }
 5955|  2.73k|    do {
 5956|  2.73k|        NEXT;
  ------------------
  |  | 2275|  2.73k|#define NEXT xmlNextChar(ctxt)
  ------------------
 5957|  2.73k|	SKIP_BLANKS;
  ------------------
  |  | 2273|  2.73k|#define SKIP_BLANKS xmlSkipBlankChars(ctxt)
  ------------------
 5958|  2.73k|        name = xmlParseNmtoken(ctxt);
 5959|  2.73k|	if (name == NULL) {
  ------------------
  |  Branch (5959:6): [True: 0, False: 2.73k]
  ------------------
 5960|      0|	    xmlFatalErr(ctxt, XML_ERR_NMTOKEN_REQUIRED, NULL);
 5961|      0|	    return(ret);
 5962|      0|	}
 5963|  2.73k|	tmp = ret;
 5964|  5.15k|	while (tmp != NULL) {
  ------------------
  |  Branch (5964:9): [True: 2.42k, False: 2.73k]
  ------------------
 5965|  2.42k|	    if (xmlStrEqual(name, tmp->name)) {
  ------------------
  |  Branch (5965:10): [True: 0, False: 2.42k]
  ------------------
 5966|      0|		xmlValidityError(ctxt, XML_DTD_DUP_TOKEN,
 5967|      0|	  "standalone: attribute enumeration value token %s duplicated\n",
 5968|      0|				 name, NULL);
 5969|      0|		if (!xmlDictOwns(ctxt->dict, name))
  ------------------
  |  Branch (5969:7): [True: 0, False: 0]
  ------------------
 5970|      0|		    xmlFree(name);
 5971|      0|		break;
 5972|      0|	    }
 5973|  2.42k|	    tmp = tmp->next;
 5974|  2.42k|	}
 5975|  2.73k|	if (tmp == NULL) {
  ------------------
  |  Branch (5975:6): [True: 2.73k, False: 0]
  ------------------
 5976|  2.73k|	    cur = xmlCreateEnumeration(name);
 5977|  2.73k|	    if (!xmlDictOwns(ctxt->dict, name))
  ------------------
  |  Branch (5977:10): [True: 2.73k, False: 0]
  ------------------
 5978|  2.73k|		xmlFree(name);
 5979|  2.73k|	    if (cur == NULL) {
  ------------------
  |  Branch (5979:10): [True: 0, False: 2.73k]
  ------------------
 5980|      0|                xmlFreeEnumeration(ret);
 5981|      0|                return(NULL);
 5982|      0|            }
 5983|  2.73k|	    if (last == NULL) ret = last = cur;
  ------------------
  |  Branch (5983:10): [True: 1.68k, False: 1.04k]
  ------------------
 5984|  1.04k|	    else {
 5985|  1.04k|		last->next = cur;
 5986|  1.04k|		last = cur;
 5987|  1.04k|	    }
 5988|  2.73k|	}
 5989|  2.73k|	SKIP_BLANKS;
  ------------------
  |  | 2273|  2.73k|#define SKIP_BLANKS xmlSkipBlankChars(ctxt)
  ------------------
 5990|  2.73k|    } while (RAW == '|');
  ------------------
  |  | 2221|  2.73k|#define RAW (*ctxt->input->cur)
  ------------------
  |  Branch (5990:14): [True: 1.04k, False: 1.68k]
  ------------------
 5991|  1.68k|    if (RAW != ')') {
  ------------------
  |  | 2221|  1.68k|#define RAW (*ctxt->input->cur)
  ------------------
  |  Branch (5991:9): [True: 0, False: 1.68k]
  ------------------
 5992|      0|	xmlFatalErr(ctxt, XML_ERR_ATTLIST_NOT_FINISHED, NULL);
 5993|      0|	return(ret);
 5994|      0|    }
 5995|  1.68k|    NEXT;
  ------------------
  |  | 2275|  1.68k|#define NEXT xmlNextChar(ctxt)
  ------------------
 5996|  1.68k|    return(ret);
 5997|  1.68k|}
xmlParseEnumeratedType:
 6017|  1.68k|xmlParseEnumeratedType(xmlParserCtxtPtr ctxt, xmlEnumerationPtr *tree) {
 6018|  1.68k|    if (CMP8(CUR_PTR, 'N', 'O', 'T', 'A', 'T', 'I', 'O', 'N')) {
  ------------------
  |  | 2237|  1.68k|  ( CMP7( s, c1, c2, c3, c4, c5, c6, c7 ) && ((unsigned char *) s)[ 7 ] == c8 )
  |  |  ------------------
  |  |  |  | 2235|  3.37k|  ( CMP6( s, c1, c2, c3, c4, c5, c6 ) && ((unsigned char *) s)[ 6 ] == c7 )
  |  |  |  |  ------------------
  |  |  |  |  |  | 2233|  3.37k|  ( CMP5( s, c1, c2, c3, c4, c5 ) && ((unsigned char *) s)[ 5 ] == c6 )
  |  |  |  |  |  |  ------------------
  |  |  |  |  |  |  |  | 2231|  3.37k|  ( CMP4( s, c1, c2, c3, c4 ) && ((unsigned char *) s)[ 4 ] == c5 )
  |  |  |  |  |  |  |  |  ------------------
  |  |  |  |  |  |  |  |  |  | 2228|  3.37k|  ( ((unsigned char *) s)[ 0 ] == c1 && ((unsigned char *) s)[ 1 ] == c2 && \
  |  |  |  |  |  |  |  |  |  |  ------------------
  |  |  |  |  |  |  |  |  |  |  |  Branch (2228:5): [True: 0, False: 1.68k]
  |  |  |  |  |  |  |  |  |  |  |  Branch (2228:41): [True: 0, False: 0]
  |  |  |  |  |  |  |  |  |  |  ------------------
  |  |  |  |  |  |  |  |  |  | 2229|  1.68k|    ((unsigned char *) s)[ 2 ] == c3 && ((unsigned char *) s)[ 3 ] == c4 )
  |  |  |  |  |  |  |  |  |  |  ------------------
  |  |  |  |  |  |  |  |  |  |  |  Branch (2229:5): [True: 0, False: 0]
  |  |  |  |  |  |  |  |  |  |  |  Branch (2229:41): [True: 0, False: 0]
  |  |  |  |  |  |  |  |  |  |  ------------------
  |  |  |  |  |  |  |  |  ------------------
  |  |  |  |  |  |  |  |  |  Branch (2231:34): [True: 0, False: 0]
  |  |  |  |  |  |  |  |  ------------------
  |  |  |  |  |  |  ------------------
  |  |  |  |  |  |  |  Branch (2233:38): [True: 0, False: 0]
  |  |  |  |  |  |  ------------------
  |  |  |  |  ------------------
  |  |  |  |  |  Branch (2235:42): [True: 0, False: 0]
  |  |  |  |  ------------------
  |  |  ------------------
  |  |  |  Branch (2237:46): [True: 0, False: 0]
  |  |  ------------------
  ------------------
 6019|      0|	SKIP(8);
  ------------------
  |  | 2245|      0|#define SKIP(val) do {							\
  |  | 2246|      0|    ctxt->input->cur += (val),ctxt->input->col+=(val);			\
  |  | 2247|      0|    if (*ctxt->input->cur == 0)						\
  |  |  ------------------
  |  |  |  Branch (2247:9): [True: 0, False: 0]
  |  |  ------------------
  |  | 2248|      0|        xmlParserGrow(ctxt);						\
  |  | 2249|      0|  } while (0)
  |  |  ------------------
  |  |  |  Branch (2249:12): [Folded - Ignored]
  |  |  ------------------
  ------------------
 6020|      0|	if (SKIP_BLANKS == 0) {
  ------------------
  |  | 2273|      0|#define SKIP_BLANKS xmlSkipBlankChars(ctxt)
  ------------------
  |  Branch (6020:6): [True: 0, False: 0]
  ------------------
 6021|      0|	    xmlFatalErrMsg(ctxt, XML_ERR_SPACE_REQUIRED,
 6022|      0|			   "Space required after 'NOTATION'\n");
 6023|      0|	    return(0);
 6024|      0|	}
 6025|      0|	*tree = xmlParseNotationType(ctxt);
 6026|      0|	if (*tree == NULL) return(0);
  ------------------
  |  Branch (6026:6): [True: 0, False: 0]
  ------------------
 6027|      0|	return(XML_ATTRIBUTE_NOTATION);
 6028|      0|    }
 6029|  1.68k|    *tree = xmlParseEnumerationType(ctxt);
 6030|  1.68k|    if (*tree == NULL) return(0);
  ------------------
  |  Branch (6030:9): [True: 0, False: 1.68k]
  ------------------
 6031|  1.68k|    return(XML_ATTRIBUTE_ENUMERATION);
 6032|  1.68k|}
xmlParseAttributeType:
 6082|  7.78k|xmlParseAttributeType(xmlParserCtxtPtr ctxt, xmlEnumerationPtr *tree) {
 6083|  7.78k|    if (CMP5(CUR_PTR, 'C', 'D', 'A', 'T', 'A')) {
  ------------------
  |  | 2231|  7.78k|  ( CMP4( s, c1, c2, c3, c4 ) && ((unsigned char *) s)[ 4 ] == c5 )
  |  |  ------------------
  |  |  |  | 2228|  15.5k|  ( ((unsigned char *) s)[ 0 ] == c1 && ((unsigned char *) s)[ 1 ] == c2 && \
  |  |  |  |  ------------------
  |  |  |  |  |  Branch (2228:5): [True: 3.00k, False: 4.77k]
  |  |  |  |  |  Branch (2228:41): [True: 3.00k, False: 0]
  |  |  |  |  ------------------
  |  |  |  | 2229|  7.78k|    ((unsigned char *) s)[ 2 ] == c3 && ((unsigned char *) s)[ 3 ] == c4 )
  |  |  |  |  ------------------
  |  |  |  |  |  Branch (2229:5): [True: 3.00k, False: 0]
  |  |  |  |  |  Branch (2229:41): [True: 3.00k, False: 0]
  |  |  |  |  ------------------
  |  |  ------------------
  |  |  |  Branch (2231:34): [True: 3.00k, False: 0]
  |  |  ------------------
  ------------------
 6084|  3.00k|	SKIP(5);
  ------------------
  |  | 2245|  3.00k|#define SKIP(val) do {							\
  |  | 2246|  3.00k|    ctxt->input->cur += (val),ctxt->input->col+=(val);			\
  |  | 2247|  3.00k|    if (*ctxt->input->cur == 0)						\
  |  |  ------------------
  |  |  |  Branch (2247:9): [True: 0, False: 3.00k]
  |  |  ------------------
  |  | 2248|  3.00k|        xmlParserGrow(ctxt);						\
  |  | 2249|  3.00k|  } while (0)
  |  |  ------------------
  |  |  |  Branch (2249:12): [Folded - Ignored]
  |  |  ------------------
  ------------------
 6085|  3.00k|	return(XML_ATTRIBUTE_CDATA);
 6086|  4.77k|     } else if (CMP6(CUR_PTR, 'I', 'D', 'R', 'E', 'F', 'S')) {
  ------------------
  |  | 2233|  4.77k|  ( CMP5( s, c1, c2, c3, c4, c5 ) && ((unsigned char *) s)[ 5 ] == c6 )
  |  |  ------------------
  |  |  |  | 2231|  9.55k|  ( CMP4( s, c1, c2, c3, c4 ) && ((unsigned char *) s)[ 4 ] == c5 )
  |  |  |  |  ------------------
  |  |  |  |  |  | 2228|  9.55k|  ( ((unsigned char *) s)[ 0 ] == c1 && ((unsigned char *) s)[ 1 ] == c2 && \
  |  |  |  |  |  |  ------------------
  |  |  |  |  |  |  |  Branch (2228:5): [True: 1.82k, False: 2.94k]
  |  |  |  |  |  |  |  Branch (2228:41): [True: 1.82k, False: 0]
  |  |  |  |  |  |  ------------------
  |  |  |  |  |  | 2229|  4.77k|    ((unsigned char *) s)[ 2 ] == c3 && ((unsigned char *) s)[ 3 ] == c4 )
  |  |  |  |  |  |  ------------------
  |  |  |  |  |  |  |  Branch (2229:5): [True: 104, False: 1.72k]
  |  |  |  |  |  |  |  Branch (2229:41): [True: 104, False: 0]
  |  |  |  |  |  |  ------------------
  |  |  |  |  ------------------
  |  |  |  |  |  Branch (2231:34): [True: 104, False: 0]
  |  |  |  |  ------------------
  |  |  ------------------
  |  |  |  Branch (2233:38): [True: 16, False: 88]
  |  |  ------------------
  ------------------
 6087|     16|	SKIP(6);
  ------------------
  |  | 2245|     16|#define SKIP(val) do {							\
  |  | 2246|     16|    ctxt->input->cur += (val),ctxt->input->col+=(val);			\
  |  | 2247|     16|    if (*ctxt->input->cur == 0)						\
  |  |  ------------------
  |  |  |  Branch (2247:9): [True: 0, False: 16]
  |  |  ------------------
  |  | 2248|     16|        xmlParserGrow(ctxt);						\
  |  | 2249|     16|  } while (0)
  |  |  ------------------
  |  |  |  Branch (2249:12): [Folded - Ignored]
  |  |  ------------------
  ------------------
 6088|     16|	return(XML_ATTRIBUTE_IDREFS);
 6089|  4.76k|     } else if (CMP5(CUR_PTR, 'I', 'D', 'R', 'E', 'F')) {
  ------------------
  |  | 2231|  4.76k|  ( CMP4( s, c1, c2, c3, c4 ) && ((unsigned char *) s)[ 4 ] == c5 )
  |  |  ------------------
  |  |  |  | 2228|  9.52k|  ( ((unsigned char *) s)[ 0 ] == c1 && ((unsigned char *) s)[ 1 ] == c2 && \
  |  |  |  |  ------------------
  |  |  |  |  |  Branch (2228:5): [True: 1.81k, False: 2.94k]
  |  |  |  |  |  Branch (2228:41): [True: 1.81k, False: 0]
  |  |  |  |  ------------------
  |  |  |  | 2229|  4.76k|    ((unsigned char *) s)[ 2 ] == c3 && ((unsigned char *) s)[ 3 ] == c4 )
  |  |  |  |  ------------------
  |  |  |  |  |  Branch (2229:5): [True: 88, False: 1.72k]
  |  |  |  |  |  Branch (2229:41): [True: 88, False: 0]
  |  |  |  |  ------------------
  |  |  ------------------
  |  |  |  Branch (2231:34): [True: 88, False: 0]
  |  |  ------------------
  ------------------
 6090|     88|	SKIP(5);
  ------------------
  |  | 2245|     88|#define SKIP(val) do {							\
  |  | 2246|     88|    ctxt->input->cur += (val),ctxt->input->col+=(val);			\
  |  | 2247|     88|    if (*ctxt->input->cur == 0)						\
  |  |  ------------------
  |  |  |  Branch (2247:9): [True: 0, False: 88]
  |  |  ------------------
  |  | 2248|     88|        xmlParserGrow(ctxt);						\
  |  | 2249|     88|  } while (0)
  |  |  ------------------
  |  |  |  Branch (2249:12): [Folded - Ignored]
  |  |  ------------------
  ------------------
 6091|     88|	return(XML_ATTRIBUTE_IDREF);
 6092|  4.67k|     } else if ((RAW == 'I') && (NXT(1) == 'D')) {
  ------------------
  |  | 2221|  4.67k|#define RAW (*ctxt->input->cur)
  ------------------
                   } else if ((RAW == 'I') && (NXT(1) == 'D')) {
  ------------------
  |  | 2223|  1.72k|#define NXT(val) ctxt->input->cur[(val)]
  ------------------
  |  Branch (6092:17): [True: 1.72k, False: 2.94k]
  |  Branch (6092:33): [True: 1.72k, False: 0]
  ------------------
 6093|  1.72k|        SKIP(2);
  ------------------
  |  | 2245|  1.72k|#define SKIP(val) do {							\
  |  | 2246|  1.72k|    ctxt->input->cur += (val),ctxt->input->col+=(val);			\
  |  | 2247|  1.72k|    if (*ctxt->input->cur == 0)						\
  |  |  ------------------
  |  |  |  Branch (2247:9): [True: 0, False: 1.72k]
  |  |  ------------------
  |  | 2248|  1.72k|        xmlParserGrow(ctxt);						\
  |  | 2249|  1.72k|  } while (0)
  |  |  ------------------
  |  |  |  Branch (2249:12): [Folded - Ignored]
  |  |  ------------------
  ------------------
 6094|  1.72k|	return(XML_ATTRIBUTE_ID);
 6095|  2.94k|     } else if (CMP6(CUR_PTR, 'E', 'N', 'T', 'I', 'T', 'Y')) {
  ------------------
  |  | 2233|  2.94k|  ( CMP5( s, c1, c2, c3, c4, c5 ) && ((unsigned char *) s)[ 5 ] == c6 )
  |  |  ------------------
  |  |  |  | 2231|  5.89k|  ( CMP4( s, c1, c2, c3, c4 ) && ((unsigned char *) s)[ 4 ] == c5 )
  |  |  |  |  ------------------
  |  |  |  |  |  | 2228|  5.89k|  ( ((unsigned char *) s)[ 0 ] == c1 && ((unsigned char *) s)[ 1 ] == c2 && \
  |  |  |  |  |  |  ------------------
  |  |  |  |  |  |  |  Branch (2228:5): [True: 12, False: 2.93k]
  |  |  |  |  |  |  |  Branch (2228:41): [True: 12, False: 0]
  |  |  |  |  |  |  ------------------
  |  |  |  |  |  | 2229|  2.94k|    ((unsigned char *) s)[ 2 ] == c3 && ((unsigned char *) s)[ 3 ] == c4 )
  |  |  |  |  |  |  ------------------
  |  |  |  |  |  |  |  Branch (2229:5): [True: 12, False: 0]
  |  |  |  |  |  |  |  Branch (2229:41): [True: 12, False: 0]
  |  |  |  |  |  |  ------------------
  |  |  |  |  ------------------
  |  |  |  |  |  Branch (2231:34): [True: 12, False: 0]
  |  |  |  |  ------------------
  |  |  ------------------
  |  |  |  Branch (2233:38): [True: 12, False: 0]
  |  |  ------------------
  ------------------
 6096|     12|	SKIP(6);
  ------------------
  |  | 2245|     12|#define SKIP(val) do {							\
  |  | 2246|     12|    ctxt->input->cur += (val),ctxt->input->col+=(val);			\
  |  | 2247|     12|    if (*ctxt->input->cur == 0)						\
  |  |  ------------------
  |  |  |  Branch (2247:9): [True: 0, False: 12]
  |  |  ------------------
  |  | 2248|     12|        xmlParserGrow(ctxt);						\
  |  | 2249|     12|  } while (0)
  |  |  ------------------
  |  |  |  Branch (2249:12): [Folded - Ignored]
  |  |  ------------------
  ------------------
 6097|     12|	return(XML_ATTRIBUTE_ENTITY);
 6098|  2.93k|     } else if (CMP8(CUR_PTR, 'E', 'N', 'T', 'I', 'T', 'I', 'E', 'S')) {
  ------------------
  |  | 2237|  2.93k|  ( CMP7( s, c1, c2, c3, c4, c5, c6, c7 ) && ((unsigned char *) s)[ 7 ] == c8 )
  |  |  ------------------
  |  |  |  | 2235|  5.87k|  ( CMP6( s, c1, c2, c3, c4, c5, c6 ) && ((unsigned char *) s)[ 6 ] == c7 )
  |  |  |  |  ------------------
  |  |  |  |  |  | 2233|  5.87k|  ( CMP5( s, c1, c2, c3, c4, c5 ) && ((unsigned char *) s)[ 5 ] == c6 )
  |  |  |  |  |  |  ------------------
  |  |  |  |  |  |  |  | 2231|  5.87k|  ( CMP4( s, c1, c2, c3, c4 ) && ((unsigned char *) s)[ 4 ] == c5 )
  |  |  |  |  |  |  |  |  ------------------
  |  |  |  |  |  |  |  |  |  | 2228|  5.87k|  ( ((unsigned char *) s)[ 0 ] == c1 && ((unsigned char *) s)[ 1 ] == c2 && \
  |  |  |  |  |  |  |  |  |  |  ------------------
  |  |  |  |  |  |  |  |  |  |  |  Branch (2228:5): [True: 0, False: 2.93k]
  |  |  |  |  |  |  |  |  |  |  |  Branch (2228:41): [True: 0, False: 0]
  |  |  |  |  |  |  |  |  |  |  ------------------
  |  |  |  |  |  |  |  |  |  | 2229|  2.93k|    ((unsigned char *) s)[ 2 ] == c3 && ((unsigned char *) s)[ 3 ] == c4 )
  |  |  |  |  |  |  |  |  |  |  ------------------
  |  |  |  |  |  |  |  |  |  |  |  Branch (2229:5): [True: 0, False: 0]
  |  |  |  |  |  |  |  |  |  |  |  Branch (2229:41): [True: 0, False: 0]
  |  |  |  |  |  |  |  |  |  |  ------------------
  |  |  |  |  |  |  |  |  ------------------
  |  |  |  |  |  |  |  |  |  Branch (2231:34): [True: 0, False: 0]
  |  |  |  |  |  |  |  |  ------------------
  |  |  |  |  |  |  ------------------
  |  |  |  |  |  |  |  Branch (2233:38): [True: 0, False: 0]
  |  |  |  |  |  |  ------------------
  |  |  |  |  ------------------
  |  |  |  |  |  Branch (2235:42): [True: 0, False: 0]
  |  |  |  |  ------------------
  |  |  ------------------
  |  |  |  Branch (2237:46): [True: 0, False: 0]
  |  |  ------------------
  ------------------
 6099|      0|	SKIP(8);
  ------------------
  |  | 2245|      0|#define SKIP(val) do {							\
  |  | 2246|      0|    ctxt->input->cur += (val),ctxt->input->col+=(val);			\
  |  | 2247|      0|    if (*ctxt->input->cur == 0)						\
  |  |  ------------------
  |  |  |  Branch (2247:9): [True: 0, False: 0]
  |  |  ------------------
  |  | 2248|      0|        xmlParserGrow(ctxt);						\
  |  | 2249|      0|  } while (0)
  |  |  ------------------
  |  |  |  Branch (2249:12): [Folded - Ignored]
  |  |  ------------------
  ------------------
 6100|      0|	return(XML_ATTRIBUTE_ENTITIES);
 6101|  2.93k|     } else if (CMP8(CUR_PTR, 'N', 'M', 'T', 'O', 'K', 'E', 'N', 'S')) {
  ------------------
  |  | 2237|  2.93k|  ( CMP7( s, c1, c2, c3, c4, c5, c6, c7 ) && ((unsigned char *) s)[ 7 ] == c8 )
  |  |  ------------------
  |  |  |  | 2235|  5.87k|  ( CMP6( s, c1, c2, c3, c4, c5, c6 ) && ((unsigned char *) s)[ 6 ] == c7 )
  |  |  |  |  ------------------
  |  |  |  |  |  | 2233|  5.87k|  ( CMP5( s, c1, c2, c3, c4, c5 ) && ((unsigned char *) s)[ 5 ] == c6 )
  |  |  |  |  |  |  ------------------
  |  |  |  |  |  |  |  | 2231|  5.87k|  ( CMP4( s, c1, c2, c3, c4 ) && ((unsigned char *) s)[ 4 ] == c5 )
  |  |  |  |  |  |  |  |  ------------------
  |  |  |  |  |  |  |  |  |  | 2228|  5.87k|  ( ((unsigned char *) s)[ 0 ] == c1 && ((unsigned char *) s)[ 1 ] == c2 && \
  |  |  |  |  |  |  |  |  |  |  ------------------
  |  |  |  |  |  |  |  |  |  |  |  Branch (2228:5): [True: 1.24k, False: 1.68k]
  |  |  |  |  |  |  |  |  |  |  |  Branch (2228:41): [True: 1.24k, False: 0]
  |  |  |  |  |  |  |  |  |  |  ------------------
  |  |  |  |  |  |  |  |  |  | 2229|  2.93k|    ((unsigned char *) s)[ 2 ] == c3 && ((unsigned char *) s)[ 3 ] == c4 )
  |  |  |  |  |  |  |  |  |  |  ------------------
  |  |  |  |  |  |  |  |  |  |  |  Branch (2229:5): [True: 1.24k, False: 0]
  |  |  |  |  |  |  |  |  |  |  |  Branch (2229:41): [True: 1.24k, False: 0]
  |  |  |  |  |  |  |  |  |  |  ------------------
  |  |  |  |  |  |  |  |  ------------------
  |  |  |  |  |  |  |  |  |  Branch (2231:34): [True: 1.24k, False: 0]
  |  |  |  |  |  |  |  |  ------------------
  |  |  |  |  |  |  ------------------
  |  |  |  |  |  |  |  Branch (2233:38): [True: 1.24k, False: 0]
  |  |  |  |  |  |  ------------------
  |  |  |  |  ------------------
  |  |  |  |  |  Branch (2235:42): [True: 1.24k, False: 0]
  |  |  |  |  ------------------
  |  |  ------------------
  |  |  |  Branch (2237:46): [True: 196, False: 1.05k]
  |  |  ------------------
  ------------------
 6102|    196|	SKIP(8);
  ------------------
  |  | 2245|    196|#define SKIP(val) do {							\
  |  | 2246|    196|    ctxt->input->cur += (val),ctxt->input->col+=(val);			\
  |  | 2247|    196|    if (*ctxt->input->cur == 0)						\
  |  |  ------------------
  |  |  |  Branch (2247:9): [True: 0, False: 196]
  |  |  ------------------
  |  | 2248|    196|        xmlParserGrow(ctxt);						\
  |  | 2249|    196|  } while (0)
  |  |  ------------------
  |  |  |  Branch (2249:12): [Folded - Ignored]
  |  |  ------------------
  ------------------
 6103|    196|	return(XML_ATTRIBUTE_NMTOKENS);
 6104|  2.74k|     } else if (CMP7(CUR_PTR, 'N', 'M', 'T', 'O', 'K', 'E', 'N')) {
  ------------------
  |  | 2235|  2.74k|  ( CMP6( s, c1, c2, c3, c4, c5, c6 ) && ((unsigned char *) s)[ 6 ] == c7 )
  |  |  ------------------
  |  |  |  | 2233|  5.48k|  ( CMP5( s, c1, c2, c3, c4, c5 ) && ((unsigned char *) s)[ 5 ] == c6 )
  |  |  |  |  ------------------
  |  |  |  |  |  | 2231|  5.48k|  ( CMP4( s, c1, c2, c3, c4 ) && ((unsigned char *) s)[ 4 ] == c5 )
  |  |  |  |  |  |  ------------------
  |  |  |  |  |  |  |  | 2228|  5.48k|  ( ((unsigned char *) s)[ 0 ] == c1 && ((unsigned char *) s)[ 1 ] == c2 && \
  |  |  |  |  |  |  |  |  ------------------
  |  |  |  |  |  |  |  |  |  Branch (2228:5): [True: 1.05k, False: 1.68k]
  |  |  |  |  |  |  |  |  |  Branch (2228:41): [True: 1.05k, False: 0]
  |  |  |  |  |  |  |  |  ------------------
  |  |  |  |  |  |  |  | 2229|  2.74k|    ((unsigned char *) s)[ 2 ] == c3 && ((unsigned char *) s)[ 3 ] == c4 )
  |  |  |  |  |  |  |  |  ------------------
  |  |  |  |  |  |  |  |  |  Branch (2229:5): [True: 1.05k, False: 0]
  |  |  |  |  |  |  |  |  |  Branch (2229:41): [True: 1.05k, False: 0]
  |  |  |  |  |  |  |  |  ------------------
  |  |  |  |  |  |  ------------------
  |  |  |  |  |  |  |  Branch (2231:34): [True: 1.05k, False: 0]
  |  |  |  |  |  |  ------------------
  |  |  |  |  ------------------
  |  |  |  |  |  Branch (2233:38): [True: 1.05k, False: 0]
  |  |  |  |  ------------------
  |  |  ------------------
  |  |  |  Branch (2235:42): [True: 1.05k, False: 0]
  |  |  ------------------
  ------------------
 6105|  1.05k|	SKIP(7);
  ------------------
  |  | 2245|  1.05k|#define SKIP(val) do {							\
  |  | 2246|  1.05k|    ctxt->input->cur += (val),ctxt->input->col+=(val);			\
  |  | 2247|  1.05k|    if (*ctxt->input->cur == 0)						\
  |  |  ------------------
  |  |  |  Branch (2247:9): [True: 0, False: 1.05k]
  |  |  ------------------
  |  | 2248|  1.05k|        xmlParserGrow(ctxt);						\
  |  | 2249|  1.05k|  } while (0)
  |  |  ------------------
  |  |  |  Branch (2249:12): [Folded - Ignored]
  |  |  ------------------
  ------------------
 6106|  1.05k|	return(XML_ATTRIBUTE_NMTOKEN);
 6107|  1.05k|     }
 6108|  1.68k|     return(xmlParseEnumeratedType(ctxt, tree));
 6109|  7.78k|}
xmlParseAttributeListDecl:
 6125|  2.00k|xmlParseAttributeListDecl(xmlParserCtxtPtr ctxt) {
 6126|  2.00k|    const xmlChar *elemName;
 6127|  2.00k|    const xmlChar *attrName;
 6128|  2.00k|    xmlEnumerationPtr tree;
 6129|       |
 6130|  2.00k|    if ((CUR != '<') || (NXT(1) != '!'))
  ------------------
  |  | 2222|  2.00k|#define CUR (*ctxt->input->cur)
  ------------------
                  if ((CUR != '<') || (NXT(1) != '!'))
  ------------------
  |  | 2223|  2.00k|#define NXT(val) ctxt->input->cur[(val)]
  ------------------
  |  Branch (6130:9): [True: 0, False: 2.00k]
  |  Branch (6130:25): [True: 0, False: 2.00k]
  ------------------
 6131|      0|        return;
 6132|  2.00k|    SKIP(2);
  ------------------
  |  | 2245|  2.00k|#define SKIP(val) do {							\
  |  | 2246|  2.00k|    ctxt->input->cur += (val),ctxt->input->col+=(val);			\
  |  | 2247|  2.00k|    if (*ctxt->input->cur == 0)						\
  |  |  ------------------
  |  |  |  Branch (2247:9): [True: 0, False: 2.00k]
  |  |  ------------------
  |  | 2248|  2.00k|        xmlParserGrow(ctxt);						\
  |  | 2249|  2.00k|  } while (0)
  |  |  ------------------
  |  |  |  Branch (2249:12): [Folded - Ignored]
  |  |  ------------------
  ------------------
 6133|       |
 6134|  2.00k|    if (CMP7(CUR_PTR, 'A', 'T', 'T', 'L', 'I', 'S', 'T')) {
  ------------------
  |  | 2235|  2.00k|  ( CMP6( s, c1, c2, c3, c4, c5, c6 ) && ((unsigned char *) s)[ 6 ] == c7 )
  |  |  ------------------
  |  |  |  | 2233|  4.01k|  ( CMP5( s, c1, c2, c3, c4, c5 ) && ((unsigned char *) s)[ 5 ] == c6 )
  |  |  |  |  ------------------
  |  |  |  |  |  | 2231|  4.01k|  ( CMP4( s, c1, c2, c3, c4 ) && ((unsigned char *) s)[ 4 ] == c5 )
  |  |  |  |  |  |  ------------------
  |  |  |  |  |  |  |  | 2228|  4.01k|  ( ((unsigned char *) s)[ 0 ] == c1 && ((unsigned char *) s)[ 1 ] == c2 && \
  |  |  |  |  |  |  |  |  ------------------
  |  |  |  |  |  |  |  |  |  Branch (2228:5): [True: 2.00k, False: 0]
  |  |  |  |  |  |  |  |  |  Branch (2228:41): [True: 2.00k, False: 0]
  |  |  |  |  |  |  |  |  ------------------
  |  |  |  |  |  |  |  | 2229|  2.00k|    ((unsigned char *) s)[ 2 ] == c3 && ((unsigned char *) s)[ 3 ] == c4 )
  |  |  |  |  |  |  |  |  ------------------
  |  |  |  |  |  |  |  |  |  Branch (2229:5): [True: 2.00k, False: 0]
  |  |  |  |  |  |  |  |  |  Branch (2229:41): [True: 2.00k, False: 0]
  |  |  |  |  |  |  |  |  ------------------
  |  |  |  |  |  |  ------------------
  |  |  |  |  |  |  |  Branch (2231:34): [True: 2.00k, False: 0]
  |  |  |  |  |  |  ------------------
  |  |  |  |  ------------------
  |  |  |  |  |  Branch (2233:38): [True: 2.00k, False: 0]
  |  |  |  |  ------------------
  |  |  ------------------
  |  |  |  Branch (2235:42): [True: 2.00k, False: 0]
  |  |  ------------------
  ------------------
 6135|  2.00k|	int inputid = ctxt->input->id;
 6136|       |
 6137|  2.00k|	SKIP(7);
  ------------------
  |  | 2245|  2.00k|#define SKIP(val) do {							\
  |  | 2246|  2.00k|    ctxt->input->cur += (val),ctxt->input->col+=(val);			\
  |  | 2247|  2.00k|    if (*ctxt->input->cur == 0)						\
  |  |  ------------------
  |  |  |  Branch (2247:9): [True: 0, False: 2.00k]
  |  |  ------------------
  |  | 2248|  2.00k|        xmlParserGrow(ctxt);						\
  |  | 2249|  2.00k|  } while (0)
  |  |  ------------------
  |  |  |  Branch (2249:12): [Folded - Ignored]
  |  |  ------------------
  ------------------
 6138|  2.00k|	if (SKIP_BLANKS == 0) {
  ------------------
  |  | 2273|  2.00k|#define SKIP_BLANKS xmlSkipBlankChars(ctxt)
  ------------------
  |  Branch (6138:6): [True: 0, False: 2.00k]
  ------------------
 6139|      0|	    xmlFatalErrMsg(ctxt, XML_ERR_SPACE_REQUIRED,
 6140|      0|		                 "Space required after '<!ATTLIST'\n");
 6141|      0|	}
 6142|  2.00k|        elemName = xmlParseName(ctxt);
 6143|  2.00k|	if (elemName == NULL) {
  ------------------
  |  Branch (6143:6): [True: 0, False: 2.00k]
  ------------------
 6144|      0|	    xmlFatalErrMsg(ctxt, XML_ERR_NAME_REQUIRED,
 6145|      0|			   "ATTLIST: no name for Element\n");
 6146|      0|	    return;
 6147|      0|	}
 6148|  2.00k|	SKIP_BLANKS;
  ------------------
  |  | 2273|  2.00k|#define SKIP_BLANKS xmlSkipBlankChars(ctxt)
  ------------------
 6149|  2.00k|	GROW;
  ------------------
  |  | 2270|  2.00k|#define GROW if (ctxt->input->end - ctxt->input->cur < INPUT_CHUNK)	\
  |  |  ------------------
  |  |  |  |   97|  2.00k|#define INPUT_CHUNK	250
  |  |  ------------------
  |  |  |  Branch (2270:18): [True: 1.86k, False: 144]
  |  |  ------------------
  |  | 2271|  2.00k|	xmlParserGrow(ctxt);
  ------------------
 6150|  9.78k|	while ((RAW != '>') && (ctxt->instate != XML_PARSER_EOF)) {
  ------------------
  |  | 2221|  9.78k|#define RAW (*ctxt->input->cur)
  ------------------
  |  Branch (6150:9): [True: 7.78k, False: 2.00k]
  |  Branch (6150:25): [True: 7.78k, False: 0]
  ------------------
 6151|  7.78k|	    int type;
 6152|  7.78k|	    int def;
 6153|  7.78k|	    xmlChar *defaultValue = NULL;
 6154|       |
 6155|  7.78k|	    GROW;
  ------------------
  |  | 2270|  7.78k|#define GROW if (ctxt->input->end - ctxt->input->cur < INPUT_CHUNK)	\
  |  |  ------------------
  |  |  |  |   97|  7.78k|#define INPUT_CHUNK	250
  |  |  ------------------
  |  |  |  Branch (2270:18): [True: 5.21k, False: 2.56k]
  |  |  ------------------
  |  | 2271|  7.78k|	xmlParserGrow(ctxt);
  ------------------
 6156|  7.78k|            tree = NULL;
 6157|  7.78k|	    attrName = xmlParseName(ctxt);
 6158|  7.78k|	    if (attrName == NULL) {
  ------------------
  |  Branch (6158:10): [True: 0, False: 7.78k]
  ------------------
 6159|      0|		xmlFatalErrMsg(ctxt, XML_ERR_NAME_REQUIRED,
 6160|      0|			       "ATTLIST: no name for Attribute\n");
 6161|      0|		break;
 6162|      0|	    }
 6163|  7.78k|	    GROW;
  ------------------
  |  | 2270|  7.78k|#define GROW if (ctxt->input->end - ctxt->input->cur < INPUT_CHUNK)	\
  |  |  ------------------
  |  |  |  |   97|  7.78k|#define INPUT_CHUNK	250
  |  |  ------------------
  |  |  |  Branch (2270:18): [True: 5.22k, False: 2.55k]
  |  |  ------------------
  |  | 2271|  7.78k|	xmlParserGrow(ctxt);
  ------------------
 6164|  7.78k|	    if (SKIP_BLANKS == 0) {
  ------------------
  |  | 2273|  7.78k|#define SKIP_BLANKS xmlSkipBlankChars(ctxt)
  ------------------
  |  Branch (6164:10): [True: 0, False: 7.78k]
  ------------------
 6165|      0|		xmlFatalErrMsg(ctxt, XML_ERR_SPACE_REQUIRED,
 6166|      0|		        "Space required after the attribute name\n");
 6167|      0|		break;
 6168|      0|	    }
 6169|       |
 6170|  7.78k|	    type = xmlParseAttributeType(ctxt, &tree);
 6171|  7.78k|	    if (type <= 0) {
  ------------------
  |  Branch (6171:10): [True: 0, False: 7.78k]
  ------------------
 6172|      0|	        break;
 6173|      0|	    }
 6174|       |
 6175|  7.78k|	    GROW;
  ------------------
  |  | 2270|  7.78k|#define GROW if (ctxt->input->end - ctxt->input->cur < INPUT_CHUNK)	\
  |  |  ------------------
  |  |  |  |   97|  7.78k|#define INPUT_CHUNK	250
  |  |  ------------------
  |  |  |  Branch (2270:18): [True: 5.25k, False: 2.52k]
  |  |  ------------------
  |  | 2271|  7.78k|	xmlParserGrow(ctxt);
  ------------------
 6176|  7.78k|	    if (SKIP_BLANKS == 0) {
  ------------------
  |  | 2273|  7.78k|#define SKIP_BLANKS xmlSkipBlankChars(ctxt)
  ------------------
  |  Branch (6176:10): [True: 0, False: 7.78k]
  ------------------
 6177|      0|		xmlFatalErrMsg(ctxt, XML_ERR_SPACE_REQUIRED,
 6178|      0|			       "Space required after the attribute type\n");
 6179|      0|	        if (tree != NULL)
  ------------------
  |  Branch (6179:14): [True: 0, False: 0]
  ------------------
 6180|      0|		    xmlFreeEnumeration(tree);
 6181|      0|		break;
 6182|      0|	    }
 6183|       |
 6184|  7.78k|	    def = xmlParseDefaultDecl(ctxt, &defaultValue);
 6185|  7.78k|	    if (def <= 0) {
  ------------------
  |  Branch (6185:10): [True: 0, False: 7.78k]
  ------------------
 6186|      0|                if (defaultValue != NULL)
  ------------------
  |  Branch (6186:21): [True: 0, False: 0]
  ------------------
 6187|      0|		    xmlFree(defaultValue);
 6188|      0|	        if (tree != NULL)
  ------------------
  |  Branch (6188:14): [True: 0, False: 0]
  ------------------
 6189|      0|		    xmlFreeEnumeration(tree);
 6190|      0|	        break;
 6191|      0|	    }
 6192|  7.78k|	    if ((type != XML_ATTRIBUTE_CDATA) && (defaultValue != NULL))
  ------------------
  |  Branch (6192:10): [True: 4.77k, False: 3.00k]
  |  Branch (6192:43): [True: 1.34k, False: 3.42k]
  ------------------
 6193|  1.34k|	        xmlAttrNormalizeSpace(defaultValue, defaultValue);
 6194|       |
 6195|  7.78k|	    GROW;
  ------------------
  |  | 2270|  7.78k|#define GROW if (ctxt->input->end - ctxt->input->cur < INPUT_CHUNK)	\
  |  |  ------------------
  |  |  |  |   97|  7.78k|#define INPUT_CHUNK	250
  |  |  ------------------
  |  |  |  Branch (2270:18): [True: 5.23k, False: 2.54k]
  |  |  ------------------
  |  | 2271|  7.78k|	xmlParserGrow(ctxt);
  ------------------
 6196|  7.78k|            if (RAW != '>') {
  ------------------
  |  | 2221|  7.78k|#define RAW (*ctxt->input->cur)
  ------------------
  |  Branch (6196:17): [True: 7.43k, False: 348]
  ------------------
 6197|  7.43k|		if (SKIP_BLANKS == 0) {
  ------------------
  |  | 2273|  7.43k|#define SKIP_BLANKS xmlSkipBlankChars(ctxt)
  ------------------
  |  Branch (6197:7): [True: 0, False: 7.43k]
  ------------------
 6198|      0|		    xmlFatalErrMsg(ctxt, XML_ERR_SPACE_REQUIRED,
 6199|      0|			"Space required after the attribute default value\n");
 6200|      0|		    if (defaultValue != NULL)
  ------------------
  |  Branch (6200:11): [True: 0, False: 0]
  ------------------
 6201|      0|			xmlFree(defaultValue);
 6202|      0|		    if (tree != NULL)
  ------------------
  |  Branch (6202:11): [True: 0, False: 0]
  ------------------
 6203|      0|			xmlFreeEnumeration(tree);
 6204|      0|		    break;
 6205|      0|		}
 6206|  7.43k|	    }
 6207|  7.78k|	    if ((ctxt->sax != NULL) && (!ctxt->disableSAX) &&
  ------------------
  |  Branch (6207:10): [True: 7.78k, False: 0]
  |  Branch (6207:33): [True: 7.78k, False: 0]
  ------------------
 6208|  7.78k|		(ctxt->sax->attributeDecl != NULL))
  ------------------
  |  Branch (6208:3): [True: 7.78k, False: 0]
  ------------------
 6209|  7.78k|		ctxt->sax->attributeDecl(ctxt->userData, elemName, attrName,
 6210|  7.78k|	                        type, def, defaultValue, tree);
 6211|      0|	    else if (tree != NULL)
  ------------------
  |  Branch (6211:15): [True: 0, False: 0]
  ------------------
 6212|      0|		xmlFreeEnumeration(tree);
 6213|       |
 6214|  7.78k|	    if ((ctxt->sax2) && (defaultValue != NULL) &&
  ------------------
  |  Branch (6214:10): [True: 7.78k, False: 0]
  |  Branch (6214:26): [True: 1.64k, False: 6.13k]
  ------------------
 6215|  7.78k|	        (def != XML_ATTRIBUTE_IMPLIED) &&
  ------------------
  |  Branch (6215:10): [True: 1.64k, False: 0]
  ------------------
 6216|  7.78k|		(def != XML_ATTRIBUTE_REQUIRED)) {
  ------------------
  |  Branch (6216:3): [True: 1.64k, False: 0]
  ------------------
 6217|  1.64k|		xmlAddDefAttrs(ctxt, elemName, attrName, defaultValue);
 6218|  1.64k|	    }
 6219|  7.78k|	    if (ctxt->sax2) {
  ------------------
  |  Branch (6219:10): [True: 7.78k, False: 0]
  ------------------
 6220|  7.78k|		xmlAddSpecialAttr(ctxt, elemName, attrName, type);
 6221|  7.78k|	    }
 6222|  7.78k|	    if (defaultValue != NULL)
  ------------------
  |  Branch (6222:10): [True: 1.64k, False: 6.13k]
  ------------------
 6223|  1.64k|	        xmlFree(defaultValue);
 6224|  7.78k|	    GROW;
  ------------------
  |  | 2270|  7.78k|#define GROW if (ctxt->input->end - ctxt->input->cur < INPUT_CHUNK)	\
  |  |  ------------------
  |  |  |  |   97|  7.78k|#define INPUT_CHUNK	250
  |  |  ------------------
  |  |  |  Branch (2270:18): [True: 3.56k, False: 4.21k]
  |  |  ------------------
  |  | 2271|  7.78k|	xmlParserGrow(ctxt);
  ------------------
 6225|  7.78k|	}
 6226|  2.00k|	if (RAW == '>') {
  ------------------
  |  | 2221|  2.00k|#define RAW (*ctxt->input->cur)
  ------------------
  |  Branch (6226:6): [True: 2.00k, False: 0]
  ------------------
 6227|  2.00k|	    if (inputid != ctxt->input->id) {
  ------------------
  |  Branch (6227:10): [True: 0, False: 2.00k]
  ------------------
 6228|      0|		xmlFatalErrMsg(ctxt, XML_ERR_ENTITY_BOUNDARY,
 6229|      0|                               "Attribute list declaration doesn't start and"
 6230|      0|                               " stop in the same entity\n");
 6231|      0|	    }
 6232|  2.00k|	    NEXT;
  ------------------
  |  | 2275|  2.00k|#define NEXT xmlNextChar(ctxt)
  ------------------
 6233|  2.00k|	}
 6234|  2.00k|    }
 6235|  2.00k|}
xmlParseElementMixedContentDecl:
 6259|  1.36k|xmlParseElementMixedContentDecl(xmlParserCtxtPtr ctxt, int inputchk) {
 6260|  1.36k|    xmlElementContentPtr ret = NULL, cur = NULL, n;
 6261|  1.36k|    const xmlChar *elem = NULL;
 6262|       |
 6263|  1.36k|    GROW;
  ------------------
  |  | 2270|  1.36k|#define GROW if (ctxt->input->end - ctxt->input->cur < INPUT_CHUNK)	\
  |  |  ------------------
  |  |  |  |   97|  1.36k|#define INPUT_CHUNK	250
  |  |  ------------------
  |  |  |  Branch (2270:18): [True: 497, False: 871]
  |  |  ------------------
  |  | 2271|  1.36k|	xmlParserGrow(ctxt);
  ------------------
 6264|  1.36k|    if (CMP7(CUR_PTR, '#', 'P', 'C', 'D', 'A', 'T', 'A')) {
  ------------------
  |  | 2235|  1.36k|  ( CMP6( s, c1, c2, c3, c4, c5, c6 ) && ((unsigned char *) s)[ 6 ] == c7 )
  |  |  ------------------
  |  |  |  | 2233|  2.73k|  ( CMP5( s, c1, c2, c3, c4, c5 ) && ((unsigned char *) s)[ 5 ] == c6 )
  |  |  |  |  ------------------
  |  |  |  |  |  | 2231|  2.73k|  ( CMP4( s, c1, c2, c3, c4 ) && ((unsigned char *) s)[ 4 ] == c5 )
  |  |  |  |  |  |  ------------------
  |  |  |  |  |  |  |  | 2228|  2.73k|  ( ((unsigned char *) s)[ 0 ] == c1 && ((unsigned char *) s)[ 1 ] == c2 && \
  |  |  |  |  |  |  |  |  ------------------
  |  |  |  |  |  |  |  |  |  Branch (2228:5): [True: 1.36k, False: 0]
  |  |  |  |  |  |  |  |  |  Branch (2228:41): [True: 1.36k, False: 0]
  |  |  |  |  |  |  |  |  ------------------
  |  |  |  |  |  |  |  | 2229|  1.36k|    ((unsigned char *) s)[ 2 ] == c3 && ((unsigned char *) s)[ 3 ] == c4 )
  |  |  |  |  |  |  |  |  ------------------
  |  |  |  |  |  |  |  |  |  Branch (2229:5): [True: 1.36k, False: 0]
  |  |  |  |  |  |  |  |  |  Branch (2229:41): [True: 1.36k, False: 0]
  |  |  |  |  |  |  |  |  ------------------
  |  |  |  |  |  |  ------------------
  |  |  |  |  |  |  |  Branch (2231:34): [True: 1.36k, False: 0]
  |  |  |  |  |  |  ------------------
  |  |  |  |  ------------------
  |  |  |  |  |  Branch (2233:38): [True: 1.36k, False: 0]
  |  |  |  |  ------------------
  |  |  ------------------
  |  |  |  Branch (2235:42): [True: 1.36k, False: 0]
  |  |  ------------------
  ------------------
 6265|  1.36k|	SKIP(7);
  ------------------
  |  | 2245|  1.36k|#define SKIP(val) do {							\
  |  | 2246|  1.36k|    ctxt->input->cur += (val),ctxt->input->col+=(val);			\
  |  | 2247|  1.36k|    if (*ctxt->input->cur == 0)						\
  |  |  ------------------
  |  |  |  Branch (2247:9): [True: 0, False: 1.36k]
  |  |  ------------------
  |  | 2248|  1.36k|        xmlParserGrow(ctxt);						\
  |  | 2249|  1.36k|  } while (0)
  |  |  ------------------
  |  |  |  Branch (2249:12): [Folded - Ignored]
  |  |  ------------------
  ------------------
 6266|  1.36k|	SKIP_BLANKS;
  ------------------
  |  | 2273|  1.36k|#define SKIP_BLANKS xmlSkipBlankChars(ctxt)
  ------------------
 6267|  1.36k|	if (RAW == ')') {
  ------------------
  |  | 2221|  1.36k|#define RAW (*ctxt->input->cur)
  ------------------
  |  Branch (6267:6): [True: 896, False: 472]
  ------------------
 6268|    896|	    if (ctxt->input->id != inputchk) {
  ------------------
  |  Branch (6268:10): [True: 0, False: 896]
  ------------------
 6269|      0|		xmlFatalErrMsg(ctxt, XML_ERR_ENTITY_BOUNDARY,
 6270|      0|                               "Element content declaration doesn't start and"
 6271|      0|                               " stop in the same entity\n");
 6272|      0|	    }
 6273|    896|	    NEXT;
  ------------------
  |  | 2275|    896|#define NEXT xmlNextChar(ctxt)
  ------------------
 6274|    896|	    ret = xmlNewDocElementContent(ctxt->myDoc, NULL, XML_ELEMENT_CONTENT_PCDATA);
 6275|    896|	    if (ret == NULL)
  ------------------
  |  Branch (6275:10): [True: 0, False: 896]
  ------------------
 6276|      0|	        return(NULL);
 6277|    896|	    if (RAW == '*') {
  ------------------
  |  | 2221|    896|#define RAW (*ctxt->input->cur)
  ------------------
  |  Branch (6277:10): [True: 0, False: 896]
  ------------------
 6278|      0|		ret->ocur = XML_ELEMENT_CONTENT_MULT;
 6279|      0|		NEXT;
  ------------------
  |  | 2275|      0|#define NEXT xmlNextChar(ctxt)
  ------------------
 6280|      0|	    }
 6281|    896|	    return(ret);
 6282|    896|	}
 6283|    472|	if ((RAW == '(') || (RAW == '|')) {
  ------------------
  |  | 2221|    472|#define RAW (*ctxt->input->cur)
  ------------------
              	if ((RAW == '(') || (RAW == '|')) {
  ------------------
  |  | 2221|    472|#define RAW (*ctxt->input->cur)
  ------------------
  |  Branch (6283:6): [True: 0, False: 472]
  |  Branch (6283:22): [True: 472, False: 0]
  ------------------
 6284|    472|	    ret = cur = xmlNewDocElementContent(ctxt->myDoc, NULL, XML_ELEMENT_CONTENT_PCDATA);
 6285|    472|	    if (ret == NULL) return(NULL);
  ------------------
  |  Branch (6285:10): [True: 0, False: 472]
  ------------------
 6286|    472|	}
 6287|  4.59k|	while ((RAW == '|') && (ctxt->instate != XML_PARSER_EOF)) {
  ------------------
  |  | 2221|  4.59k|#define RAW (*ctxt->input->cur)
  ------------------
  |  Branch (6287:9): [True: 4.12k, False: 472]
  |  Branch (6287:25): [True: 4.12k, False: 0]
  ------------------
 6288|  4.12k|	    NEXT;
  ------------------
  |  | 2275|  4.12k|#define NEXT xmlNextChar(ctxt)
  ------------------
 6289|  4.12k|	    if (elem == NULL) {
  ------------------
  |  Branch (6289:10): [True: 472, False: 3.65k]
  ------------------
 6290|    472|	        ret = xmlNewDocElementContent(ctxt->myDoc, NULL, XML_ELEMENT_CONTENT_OR);
 6291|    472|		if (ret == NULL) {
  ------------------
  |  Branch (6291:7): [True: 0, False: 472]
  ------------------
 6292|      0|		    xmlFreeDocElementContent(ctxt->myDoc, cur);
 6293|      0|                    return(NULL);
 6294|      0|                }
 6295|    472|		ret->c1 = cur;
 6296|    472|		if (cur != NULL)
  ------------------
  |  Branch (6296:7): [True: 472, False: 0]
  ------------------
 6297|    472|		    cur->parent = ret;
 6298|    472|		cur = ret;
 6299|  3.65k|	    } else {
 6300|  3.65k|	        n = xmlNewDocElementContent(ctxt->myDoc, NULL, XML_ELEMENT_CONTENT_OR);
 6301|  3.65k|		if (n == NULL) {
  ------------------
  |  Branch (6301:7): [True: 0, False: 3.65k]
  ------------------
 6302|      0|		    xmlFreeDocElementContent(ctxt->myDoc, ret);
 6303|      0|                    return(NULL);
 6304|      0|                }
 6305|  3.65k|		n->c1 = xmlNewDocElementContent(ctxt->myDoc, elem, XML_ELEMENT_CONTENT_ELEMENT);
 6306|  3.65k|		if (n->c1 != NULL)
  ------------------
  |  Branch (6306:7): [True: 3.65k, False: 0]
  ------------------
 6307|  3.65k|		    n->c1->parent = n;
 6308|  3.65k|	        cur->c2 = n;
 6309|  3.65k|		if (n != NULL)
  ------------------
  |  Branch (6309:7): [True: 3.65k, False: 0]
  ------------------
 6310|  3.65k|		    n->parent = cur;
 6311|  3.65k|		cur = n;
 6312|  3.65k|	    }
 6313|  4.12k|	    SKIP_BLANKS;
  ------------------
  |  | 2273|  4.12k|#define SKIP_BLANKS xmlSkipBlankChars(ctxt)
  ------------------
 6314|  4.12k|	    elem = xmlParseName(ctxt);
 6315|  4.12k|	    if (elem == NULL) {
  ------------------
  |  Branch (6315:10): [True: 0, False: 4.12k]
  ------------------
 6316|      0|		xmlFatalErrMsg(ctxt, XML_ERR_NAME_REQUIRED,
 6317|      0|			"xmlParseElementMixedContentDecl : Name expected\n");
 6318|      0|		xmlFreeDocElementContent(ctxt->myDoc, ret);
 6319|      0|		return(NULL);
 6320|      0|	    }
 6321|  4.12k|	    SKIP_BLANKS;
  ------------------
  |  | 2273|  4.12k|#define SKIP_BLANKS xmlSkipBlankChars(ctxt)
  ------------------
 6322|  4.12k|	    GROW;
  ------------------
  |  | 2270|  4.12k|#define GROW if (ctxt->input->end - ctxt->input->cur < INPUT_CHUNK)	\
  |  |  ------------------
  |  |  |  |   97|  4.12k|#define INPUT_CHUNK	250
  |  |  ------------------
  |  |  |  Branch (2270:18): [True: 3.18k, False: 938]
  |  |  ------------------
  |  | 2271|  4.12k|	xmlParserGrow(ctxt);
  ------------------
 6323|  4.12k|	}
 6324|    472|	if ((RAW == ')') && (NXT(1) == '*')) {
  ------------------
  |  | 2221|    472|#define RAW (*ctxt->input->cur)
  ------------------
              	if ((RAW == ')') && (NXT(1) == '*')) {
  ------------------
  |  | 2223|    472|#define NXT(val) ctxt->input->cur[(val)]
  ------------------
  |  Branch (6324:6): [True: 472, False: 0]
  |  Branch (6324:22): [True: 472, False: 0]
  ------------------
 6325|    472|	    if (elem != NULL) {
  ------------------
  |  Branch (6325:10): [True: 472, False: 0]
  ------------------
 6326|    472|		cur->c2 = xmlNewDocElementContent(ctxt->myDoc, elem,
 6327|    472|		                               XML_ELEMENT_CONTENT_ELEMENT);
 6328|    472|		if (cur->c2 != NULL)
  ------------------
  |  Branch (6328:7): [True: 472, False: 0]
  ------------------
 6329|    472|		    cur->c2->parent = cur;
 6330|    472|            }
 6331|    472|            if (ret != NULL)
  ------------------
  |  Branch (6331:17): [True: 472, False: 0]
  ------------------
 6332|    472|                ret->ocur = XML_ELEMENT_CONTENT_MULT;
 6333|    472|	    if (ctxt->input->id != inputchk) {
  ------------------
  |  Branch (6333:10): [True: 0, False: 472]
  ------------------
 6334|      0|		xmlFatalErrMsg(ctxt, XML_ERR_ENTITY_BOUNDARY,
 6335|      0|                               "Element content declaration doesn't start and"
 6336|      0|                               " stop in the same entity\n");
 6337|      0|	    }
 6338|    472|	    SKIP(2);
  ------------------
  |  | 2245|    472|#define SKIP(val) do {							\
  |  | 2246|    472|    ctxt->input->cur += (val),ctxt->input->col+=(val);			\
  |  | 2247|    472|    if (*ctxt->input->cur == 0)						\
  |  |  ------------------
  |  |  |  Branch (2247:9): [True: 0, False: 472]
  |  |  ------------------
  |  | 2248|    472|        xmlParserGrow(ctxt);						\
  |  | 2249|    472|  } while (0)
  |  |  ------------------
  |  |  |  Branch (2249:12): [Folded - Ignored]
  |  |  ------------------
  ------------------
 6339|    472|	} else {
 6340|      0|	    xmlFreeDocElementContent(ctxt->myDoc, ret);
 6341|      0|	    xmlFatalErr(ctxt, XML_ERR_MIXED_NOT_STARTED, NULL);
 6342|      0|	    return(NULL);
 6343|      0|	}
 6344|       |
 6345|    472|    } else {
 6346|      0|	xmlFatalErr(ctxt, XML_ERR_PCDATA_REQUIRED, NULL);
 6347|      0|    }
 6348|    472|    return(ret);
 6349|  1.36k|}
xmlParseElementContentDecl:
 6711|  2.40k|                           xmlElementContentPtr *result) {
 6712|       |
 6713|  2.40k|    xmlElementContentPtr tree = NULL;
 6714|  2.40k|    int inputid = ctxt->input->id;
 6715|  2.40k|    int res;
 6716|       |
 6717|  2.40k|    *result = NULL;
 6718|       |
 6719|  2.40k|    if (RAW != '(') {
  ------------------
  |  | 2221|  2.40k|#define RAW (*ctxt->input->cur)
  ------------------
  |  Branch (6719:9): [True: 0, False: 2.40k]
  ------------------
 6720|      0|	xmlFatalErrMsgStr(ctxt, XML_ERR_ELEMCONTENT_NOT_STARTED,
 6721|      0|		"xmlParseElementContentDecl : %s '(' expected\n", name);
 6722|      0|	return(-1);
 6723|      0|    }
 6724|  2.40k|    NEXT;
  ------------------
  |  | 2275|  2.40k|#define NEXT xmlNextChar(ctxt)
  ------------------
 6725|  2.40k|    GROW;
  ------------------
  |  | 2270|  2.40k|#define GROW if (ctxt->input->end - ctxt->input->cur < INPUT_CHUNK)	\
  |  |  ------------------
  |  |  |  |   97|  2.40k|#define INPUT_CHUNK	250
  |  |  ------------------
  |  |  |  Branch (2270:18): [True: 519, False: 1.88k]
  |  |  ------------------
  |  | 2271|  2.40k|	xmlParserGrow(ctxt);
  ------------------
 6726|  2.40k|    if (ctxt->instate == XML_PARSER_EOF)
  ------------------
  |  Branch (6726:9): [True: 0, False: 2.40k]
  ------------------
 6727|      0|        return(-1);
 6728|  2.40k|    SKIP_BLANKS;
  ------------------
  |  | 2273|  2.40k|#define SKIP_BLANKS xmlSkipBlankChars(ctxt)
  ------------------
 6729|  2.40k|    if (CMP7(CUR_PTR, '#', 'P', 'C', 'D', 'A', 'T', 'A')) {
  ------------------
  |  | 2235|  2.40k|  ( CMP6( s, c1, c2, c3, c4, c5, c6 ) && ((unsigned char *) s)[ 6 ] == c7 )
  |  |  ------------------
  |  |  |  | 2233|  4.80k|  ( CMP5( s, c1, c2, c3, c4, c5 ) && ((unsigned char *) s)[ 5 ] == c6 )
  |  |  |  |  ------------------
  |  |  |  |  |  | 2231|  4.80k|  ( CMP4( s, c1, c2, c3, c4 ) && ((unsigned char *) s)[ 4 ] == c5 )
  |  |  |  |  |  |  ------------------
  |  |  |  |  |  |  |  | 2228|  4.80k|  ( ((unsigned char *) s)[ 0 ] == c1 && ((unsigned char *) s)[ 1 ] == c2 && \
  |  |  |  |  |  |  |  |  ------------------
  |  |  |  |  |  |  |  |  |  Branch (2228:5): [True: 1.36k, False: 1.03k]
  |  |  |  |  |  |  |  |  |  Branch (2228:41): [True: 1.36k, False: 0]
  |  |  |  |  |  |  |  |  ------------------
  |  |  |  |  |  |  |  | 2229|  2.40k|    ((unsigned char *) s)[ 2 ] == c3 && ((unsigned char *) s)[ 3 ] == c4 )
  |  |  |  |  |  |  |  |  ------------------
  |  |  |  |  |  |  |  |  |  Branch (2229:5): [True: 1.36k, False: 0]
  |  |  |  |  |  |  |  |  |  Branch (2229:41): [True: 1.36k, False: 0]
  |  |  |  |  |  |  |  |  ------------------
  |  |  |  |  |  |  ------------------
  |  |  |  |  |  |  |  Branch (2231:34): [True: 1.36k, False: 0]
  |  |  |  |  |  |  ------------------
  |  |  |  |  ------------------
  |  |  |  |  |  Branch (2233:38): [True: 1.36k, False: 0]
  |  |  |  |  ------------------
  |  |  ------------------
  |  |  |  Branch (2235:42): [True: 1.36k, False: 0]
  |  |  ------------------
  ------------------
 6730|  1.36k|        tree = xmlParseElementMixedContentDecl(ctxt, inputid);
 6731|  1.36k|	res = XML_ELEMENT_TYPE_MIXED;
 6732|  1.36k|    } else {
 6733|  1.03k|        tree = xmlParseElementChildrenContentDeclPriv(ctxt, inputid, 1);
 6734|  1.03k|	res = XML_ELEMENT_TYPE_ELEMENT;
 6735|  1.03k|    }
 6736|  2.40k|    SKIP_BLANKS;
  ------------------
  |  | 2273|  2.40k|#define SKIP_BLANKS xmlSkipBlankChars(ctxt)
  ------------------
 6737|  2.40k|    *result = tree;
 6738|  2.40k|    return(res);
 6739|  2.40k|}
xmlParseElementDecl:
 6757|  3.12k|xmlParseElementDecl(xmlParserCtxtPtr ctxt) {
 6758|  3.12k|    const xmlChar *name;
 6759|  3.12k|    int ret = -1;
 6760|  3.12k|    xmlElementContentPtr content  = NULL;
 6761|       |
 6762|  3.12k|    if ((CUR != '<') || (NXT(1) != '!'))
  ------------------
  |  | 2222|  3.12k|#define CUR (*ctxt->input->cur)
  ------------------
                  if ((CUR != '<') || (NXT(1) != '!'))
  ------------------
  |  | 2223|  3.12k|#define NXT(val) ctxt->input->cur[(val)]
  ------------------
  |  Branch (6762:9): [True: 0, False: 3.12k]
  |  Branch (6762:25): [True: 0, False: 3.12k]
  ------------------
 6763|      0|        return(ret);
 6764|  3.12k|    SKIP(2);
  ------------------
  |  | 2245|  3.12k|#define SKIP(val) do {							\
  |  | 2246|  3.12k|    ctxt->input->cur += (val),ctxt->input->col+=(val);			\
  |  | 2247|  3.12k|    if (*ctxt->input->cur == 0)						\
  |  |  ------------------
  |  |  |  Branch (2247:9): [True: 0, False: 3.12k]
  |  |  ------------------
  |  | 2248|  3.12k|        xmlParserGrow(ctxt);						\
  |  | 2249|  3.12k|  } while (0)
  |  |  ------------------
  |  |  |  Branch (2249:12): [Folded - Ignored]
  |  |  ------------------
  ------------------
 6765|       |
 6766|       |    /* GROW; done in the caller */
 6767|  3.12k|    if (CMP7(CUR_PTR, 'E', 'L', 'E', 'M', 'E', 'N', 'T')) {
  ------------------
  |  | 2235|  3.12k|  ( CMP6( s, c1, c2, c3, c4, c5, c6 ) && ((unsigned char *) s)[ 6 ] == c7 )
  |  |  ------------------
  |  |  |  | 2233|  6.24k|  ( CMP5( s, c1, c2, c3, c4, c5 ) && ((unsigned char *) s)[ 5 ] == c6 )
  |  |  |  |  ------------------
  |  |  |  |  |  | 2231|  6.24k|  ( CMP4( s, c1, c2, c3, c4 ) && ((unsigned char *) s)[ 4 ] == c5 )
  |  |  |  |  |  |  ------------------
  |  |  |  |  |  |  |  | 2228|  6.24k|  ( ((unsigned char *) s)[ 0 ] == c1 && ((unsigned char *) s)[ 1 ] == c2 && \
  |  |  |  |  |  |  |  |  ------------------
  |  |  |  |  |  |  |  |  |  Branch (2228:5): [True: 3.12k, False: 0]
  |  |  |  |  |  |  |  |  |  Branch (2228:41): [True: 3.12k, False: 0]
  |  |  |  |  |  |  |  |  ------------------
  |  |  |  |  |  |  |  | 2229|  3.12k|    ((unsigned char *) s)[ 2 ] == c3 && ((unsigned char *) s)[ 3 ] == c4 )
  |  |  |  |  |  |  |  |  ------------------
  |  |  |  |  |  |  |  |  |  Branch (2229:5): [True: 3.12k, False: 0]
  |  |  |  |  |  |  |  |  |  Branch (2229:41): [True: 3.12k, False: 0]
  |  |  |  |  |  |  |  |  ------------------
  |  |  |  |  |  |  ------------------
  |  |  |  |  |  |  |  Branch (2231:34): [True: 3.12k, False: 0]
  |  |  |  |  |  |  ------------------
  |  |  |  |  ------------------
  |  |  |  |  |  Branch (2233:38): [True: 3.12k, False: 0]
  |  |  |  |  ------------------
  |  |  ------------------
  |  |  |  Branch (2235:42): [True: 3.12k, False: 0]
  |  |  ------------------
  ------------------
 6768|  3.12k|	int inputid = ctxt->input->id;
 6769|       |
 6770|  3.12k|	SKIP(7);
  ------------------
  |  | 2245|  3.12k|#define SKIP(val) do {							\
  |  | 2246|  3.12k|    ctxt->input->cur += (val),ctxt->input->col+=(val);			\
  |  | 2247|  3.12k|    if (*ctxt->input->cur == 0)						\
  |  |  ------------------
  |  |  |  Branch (2247:9): [True: 0, False: 3.12k]
  |  |  ------------------
  |  | 2248|  3.12k|        xmlParserGrow(ctxt);						\
  |  | 2249|  3.12k|  } while (0)
  |  |  ------------------
  |  |  |  Branch (2249:12): [Folded - Ignored]
  |  |  ------------------
  ------------------
 6771|  3.12k|	if (SKIP_BLANKS == 0) {
  ------------------
  |  | 2273|  3.12k|#define SKIP_BLANKS xmlSkipBlankChars(ctxt)
  ------------------
  |  Branch (6771:6): [True: 0, False: 3.12k]
  ------------------
 6772|      0|	    xmlFatalErrMsg(ctxt, XML_ERR_SPACE_REQUIRED,
 6773|      0|		           "Space required after 'ELEMENT'\n");
 6774|      0|	    return(-1);
 6775|      0|	}
 6776|  3.12k|        name = xmlParseName(ctxt);
 6777|  3.12k|	if (name == NULL) {
  ------------------
  |  Branch (6777:6): [True: 0, False: 3.12k]
  ------------------
 6778|      0|	    xmlFatalErrMsg(ctxt, XML_ERR_NAME_REQUIRED,
 6779|      0|			   "xmlParseElementDecl: no name for Element\n");
 6780|      0|	    return(-1);
 6781|      0|	}
 6782|  3.12k|	if (SKIP_BLANKS == 0) {
  ------------------
  |  | 2273|  3.12k|#define SKIP_BLANKS xmlSkipBlankChars(ctxt)
  ------------------
  |  Branch (6782:6): [True: 0, False: 3.12k]
  ------------------
 6783|      0|	    xmlFatalErrMsg(ctxt, XML_ERR_SPACE_REQUIRED,
 6784|      0|			   "Space required after the element name\n");
 6785|      0|	}
 6786|  3.12k|	if (CMP5(CUR_PTR, 'E', 'M', 'P', 'T', 'Y')) {
  ------------------
  |  | 2231|  3.12k|  ( CMP4( s, c1, c2, c3, c4 ) && ((unsigned char *) s)[ 4 ] == c5 )
  |  |  ------------------
  |  |  |  | 2228|  6.24k|  ( ((unsigned char *) s)[ 0 ] == c1 && ((unsigned char *) s)[ 1 ] == c2 && \
  |  |  |  |  ------------------
  |  |  |  |  |  Branch (2228:5): [True: 676, False: 2.44k]
  |  |  |  |  |  Branch (2228:41): [True: 676, False: 0]
  |  |  |  |  ------------------
  |  |  |  | 2229|  3.12k|    ((unsigned char *) s)[ 2 ] == c3 && ((unsigned char *) s)[ 3 ] == c4 )
  |  |  |  |  ------------------
  |  |  |  |  |  Branch (2229:5): [True: 676, False: 0]
  |  |  |  |  |  Branch (2229:41): [True: 676, False: 0]
  |  |  |  |  ------------------
  |  |  ------------------
  |  |  |  Branch (2231:34): [True: 676, False: 0]
  |  |  ------------------
  ------------------
 6787|    676|	    SKIP(5);
  ------------------
  |  | 2245|    676|#define SKIP(val) do {							\
  |  | 2246|    676|    ctxt->input->cur += (val),ctxt->input->col+=(val);			\
  |  | 2247|    676|    if (*ctxt->input->cur == 0)						\
  |  |  ------------------
  |  |  |  Branch (2247:9): [True: 0, False: 676]
  |  |  ------------------
  |  | 2248|    676|        xmlParserGrow(ctxt);						\
  |  | 2249|    676|  } while (0)
  |  |  ------------------
  |  |  |  Branch (2249:12): [Folded - Ignored]
  |  |  ------------------
  ------------------
 6788|       |	    /*
 6789|       |	     * Element must always be empty.
 6790|       |	     */
 6791|    676|	    ret = XML_ELEMENT_TYPE_EMPTY;
 6792|  2.44k|	} else if ((RAW == 'A') && (NXT(1) == 'N') &&
  ------------------
  |  | 2221|  2.44k|#define RAW (*ctxt->input->cur)
  ------------------
              	} else if ((RAW == 'A') && (NXT(1) == 'N') &&
  ------------------
  |  | 2223|     36|#define NXT(val) ctxt->input->cur[(val)]
  ------------------
  |  Branch (6792:13): [True: 36, False: 2.40k]
  |  Branch (6792:29): [True: 36, False: 0]
  ------------------
 6793|  2.44k|	           (NXT(2) == 'Y')) {
  ------------------
  |  | 2223|     36|#define NXT(val) ctxt->input->cur[(val)]
  ------------------
  |  Branch (6793:13): [True: 36, False: 0]
  ------------------
 6794|     36|	    SKIP(3);
  ------------------
  |  | 2245|     36|#define SKIP(val) do {							\
  |  | 2246|     36|    ctxt->input->cur += (val),ctxt->input->col+=(val);			\
  |  | 2247|     36|    if (*ctxt->input->cur == 0)						\
  |  |  ------------------
  |  |  |  Branch (2247:9): [True: 0, False: 36]
  |  |  ------------------
  |  | 2248|     36|        xmlParserGrow(ctxt);						\
  |  | 2249|     36|  } while (0)
  |  |  ------------------
  |  |  |  Branch (2249:12): [Folded - Ignored]
  |  |  ------------------
  ------------------
 6795|       |	    /*
 6796|       |	     * Element is a generic container.
 6797|       |	     */
 6798|     36|	    ret = XML_ELEMENT_TYPE_ANY;
 6799|  2.40k|	} else if (RAW == '(') {
  ------------------
  |  | 2221|  2.40k|#define RAW (*ctxt->input->cur)
  ------------------
  |  Branch (6799:13): [True: 2.40k, False: 4]
  ------------------
 6800|  2.40k|	    ret = xmlParseElementContentDecl(ctxt, name, &content);
 6801|  2.40k|	} else {
 6802|       |	    /*
 6803|       |	     * [ WFC: PEs in Internal Subset ] error handling.
 6804|       |	     */
 6805|      4|	    if ((RAW == '%') && (ctxt->external == 0) &&
  ------------------
  |  | 2221|      4|#define RAW (*ctxt->input->cur)
  ------------------
  |  Branch (6805:10): [True: 0, False: 4]
  |  Branch (6805:26): [True: 0, False: 0]
  ------------------
 6806|      4|	        (ctxt->inputNr == 1)) {
  ------------------
  |  Branch (6806:10): [True: 0, False: 0]
  ------------------
 6807|      0|		xmlFatalErrMsg(ctxt, XML_ERR_PEREF_IN_INT_SUBSET,
 6808|      0|	  "PEReference: forbidden within markup decl in internal subset\n");
 6809|      4|	    } else {
 6810|      4|		xmlFatalErrMsg(ctxt, XML_ERR_ELEMCONTENT_NOT_STARTED,
 6811|      4|		      "xmlParseElementDecl: 'EMPTY', 'ANY' or '(' expected\n");
 6812|      4|            }
 6813|      4|	    return(-1);
 6814|      4|	}
 6815|       |
 6816|  3.11k|	SKIP_BLANKS;
  ------------------
  |  | 2273|  3.11k|#define SKIP_BLANKS xmlSkipBlankChars(ctxt)
  ------------------
 6817|       |
 6818|  3.11k|	if (RAW != '>') {
  ------------------
  |  | 2221|  3.11k|#define RAW (*ctxt->input->cur)
  ------------------
  |  Branch (6818:6): [True: 4, False: 3.11k]
  ------------------
 6819|      4|	    xmlFatalErr(ctxt, XML_ERR_GT_REQUIRED, NULL);
 6820|      4|	    if (content != NULL) {
  ------------------
  |  Branch (6820:10): [True: 0, False: 4]
  ------------------
 6821|      0|		xmlFreeDocElementContent(ctxt->myDoc, content);
 6822|      0|	    }
 6823|  3.11k|	} else {
 6824|  3.11k|	    if (inputid != ctxt->input->id) {
  ------------------
  |  Branch (6824:10): [True: 0, False: 3.11k]
  ------------------
 6825|      0|		xmlFatalErrMsg(ctxt, XML_ERR_ENTITY_BOUNDARY,
 6826|      0|                               "Element declaration doesn't start and stop in"
 6827|      0|                               " the same entity\n");
 6828|      0|	    }
 6829|       |
 6830|  3.11k|	    NEXT;
  ------------------
  |  | 2275|  3.11k|#define NEXT xmlNextChar(ctxt)
  ------------------
 6831|  3.11k|	    if ((ctxt->sax != NULL) && (!ctxt->disableSAX) &&
  ------------------
  |  Branch (6831:10): [True: 3.11k, False: 0]
  |  Branch (6831:33): [True: 3.11k, False: 0]
  ------------------
 6832|  3.11k|		(ctxt->sax->elementDecl != NULL)) {
  ------------------
  |  Branch (6832:3): [True: 3.11k, False: 0]
  ------------------
 6833|  3.11k|		if (content != NULL)
  ------------------
  |  Branch (6833:7): [True: 2.40k, False: 712]
  ------------------
 6834|  2.40k|		    content->parent = NULL;
 6835|  3.11k|	        ctxt->sax->elementDecl(ctxt->userData, name, ret,
 6836|  3.11k|		                       content);
 6837|  3.11k|		if ((content != NULL) && (content->parent == NULL)) {
  ------------------
  |  Branch (6837:7): [True: 2.40k, False: 712]
  |  Branch (6837:28): [True: 4, False: 2.39k]
  ------------------
 6838|       |		    /*
 6839|       |		     * this is a trick: if xmlAddElementDecl is called,
 6840|       |		     * instead of copying the full tree it is plugged directly
 6841|       |		     * if called from the parser. Avoid duplicating the
 6842|       |		     * interfaces or change the API/ABI
 6843|       |		     */
 6844|      4|		    xmlFreeDocElementContent(ctxt->myDoc, content);
 6845|      4|		}
 6846|  3.11k|	    } else if (content != NULL) {
  ------------------
  |  Branch (6846:17): [True: 0, False: 0]
  ------------------
 6847|      0|		xmlFreeDocElementContent(ctxt->myDoc, content);
 6848|      0|	    }
 6849|  3.11k|	}
 6850|  3.11k|    }
 6851|  3.11k|    return(ret);
 6852|  3.12k|}
xmlParseMarkupDecl:
 7015|   650k|xmlParseMarkupDecl(xmlParserCtxtPtr ctxt) {
 7016|   650k|    GROW;
  ------------------
  |  | 2270|   650k|#define GROW if (ctxt->input->end - ctxt->input->cur < INPUT_CHUNK)	\
  |  |  ------------------
  |  |  |  |   97|   650k|#define INPUT_CHUNK	250
  |  |  ------------------
  |  |  |  Branch (2270:18): [True: 577k, False: 73.2k]
  |  |  ------------------
  |  | 2271|   650k|	xmlParserGrow(ctxt);
  ------------------
 7017|   650k|    if (CUR == '<') {
  ------------------
  |  | 2222|   650k|#define CUR (*ctxt->input->cur)
  ------------------
  |  Branch (7017:9): [True: 650k, False: 0]
  ------------------
 7018|   650k|        if (NXT(1) == '!') {
  ------------------
  |  | 2223|   650k|#define NXT(val) ctxt->input->cur[(val)]
  ------------------
  |  Branch (7018:13): [True: 650k, False: 4]
  ------------------
 7019|   650k|	    switch (NXT(2)) {
  ------------------
  |  | 2223|   650k|#define NXT(val) ctxt->input->cur[(val)]
  ------------------
 7020|  5.47k|	        case 'E':
  ------------------
  |  Branch (7020:10): [True: 5.47k, False: 644k]
  ------------------
 7021|  5.47k|		    if (NXT(3) == 'L')
  ------------------
  |  | 2223|  5.47k|#define NXT(val) ctxt->input->cur[(val)]
  ------------------
  |  Branch (7021:11): [True: 3.12k, False: 2.35k]
  ------------------
 7022|  3.12k|			xmlParseElementDecl(ctxt);
 7023|  2.35k|		    else if (NXT(3) == 'N')
  ------------------
  |  | 2223|  2.35k|#define NXT(val) ctxt->input->cur[(val)]
  ------------------
  |  Branch (7023:16): [True: 2.35k, False: 0]
  ------------------
 7024|  2.35k|			xmlParseEntityDecl(ctxt);
 7025|      0|                    else
 7026|      0|                        SKIP(2);
  ------------------
  |  | 2245|      0|#define SKIP(val) do {							\
  |  | 2246|      0|    ctxt->input->cur += (val),ctxt->input->col+=(val);			\
  |  | 2247|      0|    if (*ctxt->input->cur == 0)						\
  |  |  ------------------
  |  |  |  Branch (2247:9): [True: 0, False: 0]
  |  |  ------------------
  |  | 2248|      0|        xmlParserGrow(ctxt);						\
  |  | 2249|      0|  } while (0)
  |  |  ------------------
  |  |  |  Branch (2249:12): [Folded - Ignored]
  |  |  ------------------
  ------------------
 7027|  5.47k|		    break;
 7028|  2.00k|	        case 'A':
  ------------------
  |  Branch (7028:10): [True: 2.00k, False: 648k]
  ------------------
 7029|  2.00k|		    xmlParseAttributeListDecl(ctxt);
 7030|  2.00k|		    break;
 7031|      0|	        case 'N':
  ------------------
  |  Branch (7031:10): [True: 0, False: 650k]
  ------------------
 7032|      0|		    xmlParseNotationDecl(ctxt);
 7033|      0|		    break;
 7034|   642k|	        case '-':
  ------------------
  |  Branch (7034:10): [True: 642k, False: 7.49k]
  ------------------
 7035|   642k|		    xmlParseComment(ctxt);
 7036|   642k|		    break;
 7037|      8|		default:
  ------------------
  |  Branch (7037:3): [True: 8, False: 650k]
  ------------------
 7038|       |		    /* there is an error but it will be detected later */
 7039|      8|                    SKIP(2);
  ------------------
  |  | 2245|      8|#define SKIP(val) do {							\
  |  | 2246|      8|    ctxt->input->cur += (val),ctxt->input->col+=(val);			\
  |  | 2247|      8|    if (*ctxt->input->cur == 0)						\
  |  |  ------------------
  |  |  |  Branch (2247:9): [True: 0, False: 8]
  |  |  ------------------
  |  | 2248|      8|        xmlParserGrow(ctxt);						\
  |  | 2249|      8|  } while (0)
  |  |  ------------------
  |  |  |  Branch (2249:12): [Folded - Ignored]
  |  |  ------------------
  ------------------
 7040|      8|		    break;
 7041|   650k|	    }
 7042|   650k|	} else if (NXT(1) == '?') {
  ------------------
  |  | 2223|      4|#define NXT(val) ctxt->input->cur[(val)]
  ------------------
  |  Branch (7042:13): [True: 4, False: 0]
  ------------------
 7043|      4|	    xmlParsePI(ctxt);
 7044|      4|	}
 7045|   650k|    }
 7046|       |
 7047|       |    /*
 7048|       |     * detect requirement to exit there and act accordingly
 7049|       |     * and avoid having instate overridden later on
 7050|       |     */
 7051|   650k|    if (ctxt->instate == XML_PARSER_EOF)
  ------------------
  |  Branch (7051:9): [True: 8, False: 650k]
  ------------------
 7052|      8|        return;
 7053|       |
 7054|   650k|    ctxt->instate = XML_PARSER_DTD;
 7055|   650k|}
xmlParseTextDecl:
 7069|     24|xmlParseTextDecl(xmlParserCtxtPtr ctxt) {
 7070|     24|    xmlChar *version;
 7071|     24|    int oldstate;
 7072|       |
 7073|       |    /*
 7074|       |     * We know that '<?xml' is here.
 7075|       |     */
 7076|     24|    if ((CMP5(CUR_PTR, '<', '?', 'x', 'm', 'l')) && (IS_BLANK_CH(NXT(5)))) {
  ------------------
  |  | 2231|     24|  ( CMP4( s, c1, c2, c3, c4 ) && ((unsigned char *) s)[ 4 ] == c5 )
  |  |  ------------------
  |  |  |  | 2228|     48|  ( ((unsigned char *) s)[ 0 ] == c1 && ((unsigned char *) s)[ 1 ] == c2 && \
  |  |  |  |  ------------------
  |  |  |  |  |  Branch (2228:5): [True: 24, False: 0]
  |  |  |  |  |  Branch (2228:41): [True: 24, False: 0]
  |  |  |  |  ------------------
  |  |  |  | 2229|     24|    ((unsigned char *) s)[ 2 ] == c3 && ((unsigned char *) s)[ 3 ] == c4 )
  |  |  |  |  ------------------
  |  |  |  |  |  Branch (2229:5): [True: 24, False: 0]
  |  |  |  |  |  Branch (2229:41): [True: 24, False: 0]
  |  |  |  |  ------------------
  |  |  ------------------
  |  |  |  Branch (2231:34): [True: 24, False: 0]
  |  |  ------------------
  ------------------
                  if ((CMP5(CUR_PTR, '<', '?', 'x', 'm', 'l')) && (IS_BLANK_CH(NXT(5)))) {
  ------------------
  |  |  151|     24|#define IS_BLANK_CH(c)  xmlIsBlank_ch(c)
  |  |  ------------------
  |  |  |  |   88|     24|#define xmlIsBlank_ch(c)	(((c) == 0x20) || \
  |  |  |  |  ------------------
  |  |  |  |  |  Branch (88:27): [True: 24, False: 0]
  |  |  |  |  ------------------
  |  |  |  |   89|     24|				 ((0x9 <= (c)) && ((c) <= 0xa)) || \
  |  |  |  |  ------------------
  |  |  |  |  |  Branch (89:7): [True: 0, False: 0]
  |  |  |  |  |  Branch (89:23): [True: 0, False: 0]
  |  |  |  |  ------------------
  |  |  |  |   90|     24|				 ((c) == 0xd))
  |  |  |  |  ------------------
  |  |  |  |  |  Branch (90:6): [True: 0, False: 0]
  |  |  |  |  ------------------
  |  |  ------------------
  ------------------
 7077|     24|	SKIP(5);
  ------------------
  |  | 2245|     24|#define SKIP(val) do {							\
  |  | 2246|     24|    ctxt->input->cur += (val),ctxt->input->col+=(val);			\
  |  | 2247|     24|    if (*ctxt->input->cur == 0)						\
  |  |  ------------------
  |  |  |  Branch (2247:9): [True: 0, False: 24]
  |  |  ------------------
  |  | 2248|     24|        xmlParserGrow(ctxt);						\
  |  | 2249|     24|  } while (0)
  |  |  ------------------
  |  |  |  Branch (2249:12): [Folded - Ignored]
  |  |  ------------------
  ------------------
 7078|     24|    } else {
 7079|      0|	xmlFatalErr(ctxt, XML_ERR_XMLDECL_NOT_STARTED, NULL);
 7080|      0|	return;
 7081|      0|    }
 7082|       |
 7083|       |    /* Avoid expansion of parameter entities when skipping blanks. */
 7084|     24|    oldstate = ctxt->instate;
 7085|     24|    ctxt->instate = XML_PARSER_START;
 7086|       |
 7087|     24|    if (SKIP_BLANKS == 0) {
  ------------------
  |  | 2273|     24|#define SKIP_BLANKS xmlSkipBlankChars(ctxt)
  ------------------
  |  Branch (7087:9): [True: 0, False: 24]
  ------------------
 7088|      0|	xmlFatalErrMsg(ctxt, XML_ERR_SPACE_REQUIRED,
 7089|      0|		       "Space needed after '<?xml'\n");
 7090|      0|    }
 7091|       |
 7092|       |    /*
 7093|       |     * We may have the VersionInfo here.
 7094|       |     */
 7095|     24|    version = xmlParseVersionInfo(ctxt);
 7096|     24|    if (version == NULL)
  ------------------
  |  Branch (7096:9): [True: 0, False: 24]
  ------------------
 7097|      0|	version = xmlCharStrdup(XML_DEFAULT_VERSION);
  ------------------
  |  |   37|      0|#define XML_DEFAULT_VERSION	"1.0"
  ------------------
 7098|     24|    else {
 7099|     24|	if (SKIP_BLANKS == 0) {
  ------------------
  |  | 2273|     24|#define SKIP_BLANKS xmlSkipBlankChars(ctxt)
  ------------------
  |  Branch (7099:6): [True: 0, False: 24]
  ------------------
 7100|      0|	    xmlFatalErrMsg(ctxt, XML_ERR_SPACE_REQUIRED,
 7101|      0|		           "Space needed here\n");
 7102|      0|	}
 7103|     24|    }
 7104|     24|    ctxt->input->version = version;
 7105|       |
 7106|       |    /*
 7107|       |     * We must have the encoding declaration
 7108|       |     */
 7109|     24|    xmlParseEncodingDecl(ctxt);
 7110|     24|    if (ctxt->instate == XML_PARSER_EOF)
  ------------------
  |  Branch (7110:9): [True: 0, False: 24]
  ------------------
 7111|      0|        return;
 7112|     24|    if (ctxt->errNo == XML_ERR_UNSUPPORTED_ENCODING) {
  ------------------
  |  Branch (7112:9): [True: 0, False: 24]
  ------------------
 7113|       |	/*
 7114|       |	 * The XML REC instructs us to stop parsing right here
 7115|       |	 */
 7116|      0|        ctxt->instate = oldstate;
 7117|      0|        return;
 7118|      0|    }
 7119|       |
 7120|     24|    SKIP_BLANKS;
  ------------------
  |  | 2273|     24|#define SKIP_BLANKS xmlSkipBlankChars(ctxt)
  ------------------
 7121|     24|    if ((RAW == '?') && (NXT(1) == '>')) {
  ------------------
  |  | 2221|     24|#define RAW (*ctxt->input->cur)
  ------------------
                  if ((RAW == '?') && (NXT(1) == '>')) {
  ------------------
  |  | 2223|     24|#define NXT(val) ctxt->input->cur[(val)]
  ------------------
  |  Branch (7121:9): [True: 24, False: 0]
  |  Branch (7121:25): [True: 24, False: 0]
  ------------------
 7122|     24|        SKIP(2);
  ------------------
  |  | 2245|     24|#define SKIP(val) do {							\
  |  | 2246|     24|    ctxt->input->cur += (val),ctxt->input->col+=(val);			\
  |  | 2247|     24|    if (*ctxt->input->cur == 0)						\
  |  |  ------------------
  |  |  |  Branch (2247:9): [True: 0, False: 24]
  |  |  ------------------
  |  | 2248|     24|        xmlParserGrow(ctxt);						\
  |  | 2249|     24|  } while (0)
  |  |  ------------------
  |  |  |  Branch (2249:12): [Folded - Ignored]
  |  |  ------------------
  ------------------
 7123|     24|    } else if (RAW == '>') {
  ------------------
  |  | 2221|      0|#define RAW (*ctxt->input->cur)
  ------------------
  |  Branch (7123:16): [True: 0, False: 0]
  ------------------
 7124|       |        /* Deprecated old WD ... */
 7125|      0|	xmlFatalErr(ctxt, XML_ERR_XMLDECL_NOT_FINISHED, NULL);
 7126|      0|	NEXT;
  ------------------
  |  | 2275|      0|#define NEXT xmlNextChar(ctxt)
  ------------------
 7127|      0|    } else {
 7128|      0|        int c;
 7129|       |
 7130|      0|	xmlFatalErr(ctxt, XML_ERR_XMLDECL_NOT_FINISHED, NULL);
 7131|      0|        while ((c = CUR) != 0) {
  ------------------
  |  | 2222|      0|#define CUR (*ctxt->input->cur)
  ------------------
  |  Branch (7131:16): [True: 0, False: 0]
  ------------------
 7132|      0|            NEXT;
  ------------------
  |  | 2275|      0|#define NEXT xmlNextChar(ctxt)
  ------------------
 7133|      0|            if (c == '>')
  ------------------
  |  Branch (7133:17): [True: 0, False: 0]
  ------------------
 7134|      0|                break;
 7135|      0|        }
 7136|      0|    }
 7137|       |
 7138|     24|    if (ctxt->instate != XML_PARSER_EOF)
  ------------------
  |  Branch (7138:9): [True: 24, False: 0]
  ------------------
 7139|     24|        ctxt->instate = oldstate;
 7140|     24|}
xmlParseExternalSubset:
 7156|     84|                       const xmlChar *SystemID) {
 7157|     84|    xmlDetectSAX2(ctxt);
 7158|       |
 7159|     84|    xmlDetectEncoding(ctxt);
 7160|       |
 7161|     84|    if (CMP5(CUR_PTR, '<', '?', 'x', 'm', 'l')) {
  ------------------
  |  | 2231|     84|  ( CMP4( s, c1, c2, c3, c4 ) && ((unsigned char *) s)[ 4 ] == c5 )
  |  |  ------------------
  |  |  |  | 2228|    168|  ( ((unsigned char *) s)[ 0 ] == c1 && ((unsigned char *) s)[ 1 ] == c2 && \
  |  |  |  |  ------------------
  |  |  |  |  |  Branch (2228:5): [True: 84, False: 0]
  |  |  |  |  |  Branch (2228:41): [True: 12, False: 72]
  |  |  |  |  ------------------
  |  |  |  | 2229|     84|    ((unsigned char *) s)[ 2 ] == c3 && ((unsigned char *) s)[ 3 ] == c4 )
  |  |  |  |  ------------------
  |  |  |  |  |  Branch (2229:5): [True: 12, False: 0]
  |  |  |  |  |  Branch (2229:41): [True: 12, False: 0]
  |  |  |  |  ------------------
  |  |  ------------------
  |  |  |  Branch (2231:34): [True: 12, False: 0]
  |  |  ------------------
  ------------------
 7162|     12|	xmlParseTextDecl(ctxt);
 7163|     12|	if (ctxt->errNo == XML_ERR_UNSUPPORTED_ENCODING) {
  ------------------
  |  Branch (7163:6): [True: 0, False: 12]
  ------------------
 7164|       |	    /*
 7165|       |	     * The XML REC instructs us to stop parsing right here
 7166|       |	     */
 7167|      0|	    xmlHaltParser(ctxt);
 7168|      0|	    return;
 7169|      0|	}
 7170|     12|    }
 7171|     84|    if (ctxt->myDoc == NULL) {
  ------------------
  |  Branch (7171:9): [True: 0, False: 84]
  ------------------
 7172|      0|        ctxt->myDoc = xmlNewDoc(BAD_CAST "1.0");
  ------------------
  |  |   35|      0|#define BAD_CAST (xmlChar *)
  ------------------
 7173|      0|	if (ctxt->myDoc == NULL) {
  ------------------
  |  Branch (7173:6): [True: 0, False: 0]
  ------------------
 7174|      0|	    xmlErrMemory(ctxt, "New Doc failed");
 7175|      0|	    return;
 7176|      0|	}
 7177|      0|	ctxt->myDoc->properties = XML_DOC_INTERNAL;
 7178|      0|    }
 7179|     84|    if ((ctxt->myDoc != NULL) && (ctxt->myDoc->intSubset == NULL))
  ------------------
  |  Branch (7179:9): [True: 84, False: 0]
  |  Branch (7179:34): [True: 0, False: 84]
  ------------------
 7180|      0|        xmlCreateIntSubset(ctxt->myDoc, NULL, ExternalID, SystemID);
 7181|       |
 7182|     84|    ctxt->instate = XML_PARSER_DTD;
 7183|     84|    ctxt->external = 1;
 7184|     84|    SKIP_BLANKS;
  ------------------
  |  | 2273|     84|#define SKIP_BLANKS xmlSkipBlankChars(ctxt)
  ------------------
 7185|  4.97k|    while ((ctxt->instate != XML_PARSER_EOF) && (RAW != 0)) {
  ------------------
  |  | 2221|  4.96k|#define RAW (*ctxt->input->cur)
  ------------------
  |  Branch (7185:12): [True: 4.96k, False: 12]
  |  Branch (7185:49): [True: 4.89k, False: 68]
  ------------------
 7186|  4.89k|	GROW;
  ------------------
  |  | 2270|  4.89k|#define GROW if (ctxt->input->end - ctxt->input->cur < INPUT_CHUNK)	\
  |  |  ------------------
  |  |  |  |   97|  4.89k|#define INPUT_CHUNK	250
  |  |  ------------------
  |  |  |  Branch (2270:18): [True: 224, False: 4.67k]
  |  |  ------------------
  |  | 2271|  4.89k|	xmlParserGrow(ctxt);
  ------------------
 7187|  4.89k|        if ((RAW == '<') && (NXT(1) == '!') && (NXT(2) == '[')) {
  ------------------
  |  | 2221|  4.89k|#define RAW (*ctxt->input->cur)
  ------------------
                      if ((RAW == '<') && (NXT(1) == '!') && (NXT(2) == '[')) {
  ------------------
  |  | 2223|  4.89k|#define NXT(val) ctxt->input->cur[(val)]
  ------------------
                      if ((RAW == '<') && (NXT(1) == '!') && (NXT(2) == '[')) {
  ------------------
  |  | 2223|  4.89k|#define NXT(val) ctxt->input->cur[(val)]
  ------------------
  |  Branch (7187:13): [True: 4.89k, False: 4]
  |  Branch (7187:29): [True: 4.89k, False: 0]
  |  Branch (7187:48): [True: 12, False: 4.88k]
  ------------------
 7188|     12|            xmlParseConditionalSections(ctxt);
 7189|  4.88k|        } else if ((RAW == '<') && ((NXT(1) == '!') || (NXT(1) == '?'))) {
  ------------------
  |  | 2221|  4.88k|#define RAW (*ctxt->input->cur)
  ------------------
                      } else if ((RAW == '<') && ((NXT(1) == '!') || (NXT(1) == '?'))) {
  ------------------
  |  | 2223|  4.88k|#define NXT(val) ctxt->input->cur[(val)]
  ------------------
                      } else if ((RAW == '<') && ((NXT(1) == '!') || (NXT(1) == '?'))) {
  ------------------
  |  | 2223|      0|#define NXT(val) ctxt->input->cur[(val)]
  ------------------
  |  Branch (7189:20): [True: 4.88k, False: 4]
  |  Branch (7189:37): [True: 4.88k, False: 0]
  |  Branch (7189:56): [True: 0, False: 0]
  ------------------
 7190|  4.88k|            xmlParseMarkupDecl(ctxt);
 7191|  4.88k|        } else {
 7192|      4|            xmlFatalErr(ctxt, XML_ERR_EXT_SUBSET_NOT_FINISHED, NULL);
 7193|      4|            xmlHaltParser(ctxt);
 7194|      4|            return;
 7195|      4|        }
 7196|  4.89k|        SKIP_BLANKS;
  ------------------
  |  | 2273|  4.89k|#define SKIP_BLANKS xmlSkipBlankChars(ctxt)
  ------------------
 7197|  4.89k|        SHRINK;
  ------------------
  |  | 2265|  4.89k|    if (((ctxt->progressive == 0) || (ctxt->inputNr > 1)) && \
  |  |  ------------------
  |  |  |  Branch (2265:10): [True: 4.89k, False: 0]
  |  |  |  Branch (2265:38): [True: 0, False: 0]
  |  |  ------------------
  |  | 2266|  4.89k|        (ctxt->input->cur - ctxt->input->base > 2 * INPUT_CHUNK) && \
  |  |  ------------------
  |  |  |  |   97|  4.89k|#define INPUT_CHUNK	250
  |  |  ------------------
  |  |  |  Branch (2266:9): [True: 3.96k, False: 928]
  |  |  ------------------
  |  | 2267|  4.89k|	(ctxt->input->end - ctxt->input->cur < 2 * INPUT_CHUNK)) \
  |  |  ------------------
  |  |  |  |   97|  3.96k|#define INPUT_CHUNK	250
  |  |  ------------------
  |  |  |  Branch (2267:2): [True: 68, False: 3.89k]
  |  |  ------------------
  |  | 2268|  4.89k|	xmlParserShrink(ctxt);
  ------------------
 7198|  4.89k|    }
 7199|       |
 7200|     80|    if (RAW != 0) {
  ------------------
  |  | 2221|     80|#define RAW (*ctxt->input->cur)
  ------------------
  |  Branch (7200:9): [True: 0, False: 80]
  ------------------
 7201|      0|	xmlFatalErr(ctxt, XML_ERR_EXT_SUBSET_NOT_FINISHED, NULL);
 7202|      0|    }
 7203|       |
 7204|     80|}
xmlParseReference:
 7222|  12.1k|xmlParseReference(xmlParserCtxtPtr ctxt) {
 7223|  12.1k|    xmlEntityPtr ent;
 7224|  12.1k|    xmlChar *val;
 7225|  12.1k|    int was_checked;
 7226|  12.1k|    xmlNodePtr list = NULL;
 7227|  12.1k|    xmlParserErrors ret = XML_ERR_OK;
 7228|       |
 7229|       |
 7230|  12.1k|    if (RAW != '&')
  ------------------
  |  | 2221|  12.1k|#define RAW (*ctxt->input->cur)
  ------------------
  |  Branch (7230:9): [True: 0, False: 12.1k]
  ------------------
 7231|      0|        return;
 7232|       |
 7233|       |    /*
 7234|       |     * Simple case of a CharRef
 7235|       |     */
 7236|  12.1k|    if (NXT(1) == '#') {
  ------------------
  |  | 2223|  12.1k|#define NXT(val) ctxt->input->cur[(val)]
  ------------------
  |  Branch (7236:9): [True: 64, False: 12.0k]
  ------------------
 7237|     64|	int i = 0;
 7238|     64|	xmlChar out[16];
 7239|     64|	int value = xmlParseCharRef(ctxt);
 7240|       |
 7241|     64|	if (value == 0)
  ------------------
  |  Branch (7241:6): [True: 4, False: 60]
  ------------------
 7242|      4|	    return;
 7243|       |
 7244|       |        /*
 7245|       |         * Just encode the value in UTF-8
 7246|       |         */
 7247|     60|        COPY_BUF(out, i, value);
  ------------------
  |  | 2295|     60|    if (v < 0x80) b[i++] = v;						\
  |  |  ------------------
  |  |  |  Branch (2295:9): [True: 12, False: 48]
  |  |  ------------------
  |  | 2296|     60|    else i += xmlCopyCharMultiByte(&b[i],v)
  ------------------
 7248|     60|        out[i] = 0;
 7249|     60|        if ((ctxt->sax != NULL) && (ctxt->sax->characters != NULL) &&
  ------------------
  |  Branch (7249:13): [True: 60, False: 0]
  |  Branch (7249:36): [True: 60, False: 0]
  ------------------
 7250|     60|            (!ctxt->disableSAX))
  ------------------
  |  Branch (7250:13): [True: 60, False: 0]
  ------------------
 7251|     60|            ctxt->sax->characters(ctxt->userData, out, i);
 7252|     60|	return;
 7253|     64|    }
 7254|       |
 7255|       |    /*
 7256|       |     * We are seeing an entity reference
 7257|       |     */
 7258|  12.0k|    ent = xmlParseEntityRef(ctxt);
 7259|  12.0k|    if (ent == NULL) return;
  ------------------
  |  Branch (7259:9): [True: 4, False: 12.0k]
  ------------------
 7260|  12.0k|    if (!ctxt->wellFormed)
  ------------------
  |  Branch (7260:9): [True: 6, False: 12.0k]
  ------------------
 7261|      6|	return;
 7262|  12.0k|    was_checked = ent->flags & XML_ENT_PARSED;
  ------------------
  |  |   14|  12.0k|#define XML_ENT_PARSED      (1<<0)
  ------------------
 7263|       |
 7264|       |    /* special case of predefined entities */
 7265|  12.0k|    if ((ent->name == NULL) ||
  ------------------
  |  Branch (7265:9): [True: 0, False: 12.0k]
  ------------------
 7266|  12.0k|        (ent->etype == XML_INTERNAL_PREDEFINED_ENTITY)) {
  ------------------
  |  Branch (7266:9): [True: 808, False: 11.2k]
  ------------------
 7267|    808|	val = ent->content;
 7268|    808|	if (val == NULL) return;
  ------------------
  |  Branch (7268:6): [True: 0, False: 808]
  ------------------
 7269|       |	/*
 7270|       |	 * inline the entity.
 7271|       |	 */
 7272|    808|	if ((ctxt->sax != NULL) && (ctxt->sax->characters != NULL) &&
  ------------------
  |  Branch (7272:6): [True: 808, False: 0]
  |  Branch (7272:29): [True: 808, False: 0]
  ------------------
 7273|    808|	    (!ctxt->disableSAX))
  ------------------
  |  Branch (7273:6): [True: 808, False: 0]
  ------------------
 7274|    808|	    ctxt->sax->characters(ctxt->userData, val, xmlStrlen(val));
 7275|    808|	return;
 7276|    808|    }
 7277|       |
 7278|       |    /*
 7279|       |     * The first reference to the entity trigger a parsing phase
 7280|       |     * where the ent->children is filled with the result from
 7281|       |     * the parsing.
 7282|       |     * Note: external parsed entities will not be loaded, it is not
 7283|       |     * required for a non-validating parser, unless the parsing option
 7284|       |     * of validating, or substituting entities were given. Doing so is
 7285|       |     * far more secure as the parser will only process data coming from
 7286|       |     * the document entity by default.
 7287|       |     *
 7288|       |     * FIXME: This doesn't work correctly since entities can be
 7289|       |     * expanded with different namespace declarations in scope.
 7290|       |     * For example:
 7291|       |     *
 7292|       |     * <!DOCTYPE doc [
 7293|       |     *   <!ENTITY ent "<ns:elem/>">
 7294|       |     * ]>
 7295|       |     * <doc>
 7296|       |     *   <decl1 xmlns:ns="urn:ns1">
 7297|       |     *     &ent;
 7298|       |     *   </decl1>
 7299|       |     *   <decl2 xmlns:ns="urn:ns2">
 7300|       |     *     &ent;
 7301|       |     *   </decl2>
 7302|       |     * </doc>
 7303|       |     *
 7304|       |     * Proposed fix:
 7305|       |     *
 7306|       |     * - Remove the ent->owner optimization which tries to avoid the
 7307|       |     *   initial copy of the entity. Always make entities own the
 7308|       |     *   subtree.
 7309|       |     * - Ignore current namespace declarations when parsing the
 7310|       |     *   entity. If a prefix can't be resolved, don't report an error
 7311|       |     *   but mark it as unresolved.
 7312|       |     * - Try to resolve these prefixes when expanding the entity.
 7313|       |     *   This will require a specialized version of xmlStaticCopyNode
 7314|       |     *   which can also make use of the namespace hash table to avoid
 7315|       |     *   quadratic behavior.
 7316|       |     *
 7317|       |     * Alternatively, we could simply reparse the entity on each
 7318|       |     * expansion like we already do with custom SAX callbacks.
 7319|       |     * External entity content should be cached in this case.
 7320|       |     */
 7321|  11.2k|    if (((ent->flags & XML_ENT_PARSED) == 0) &&
  ------------------
  |  |   14|  11.2k|#define XML_ENT_PARSED      (1<<0)
  ------------------
  |  Branch (7321:9): [True: 480, False: 10.7k]
  ------------------
 7322|  11.2k|        ((ent->etype != XML_EXTERNAL_GENERAL_PARSED_ENTITY) ||
  ------------------
  |  Branch (7322:10): [True: 436, False: 44]
  ------------------
 7323|    480|         (ctxt->options & (XML_PARSE_NOENT | XML_PARSE_DTDVALID)))) {
  ------------------
  |  Branch (7323:10): [True: 44, False: 0]
  ------------------
 7324|    480|	unsigned long oldsizeentcopy = ctxt->sizeentcopy;
 7325|       |
 7326|       |	/*
 7327|       |	 * This is a bit hackish but this seems the best
 7328|       |	 * way to make sure both SAX and DOM entity support
 7329|       |	 * behaves okay.
 7330|       |	 */
 7331|    480|	void *user_data;
 7332|    480|	if (ctxt->userData == ctxt)
  ------------------
  |  Branch (7332:6): [True: 480, False: 0]
  ------------------
 7333|    480|	    user_data = NULL;
 7334|      0|	else
 7335|      0|	    user_data = ctxt->userData;
 7336|       |
 7337|       |        /* Avoid overflow as much as possible */
 7338|    480|        ctxt->sizeentcopy = 0;
 7339|       |
 7340|    480|        if (ent->flags & XML_ENT_EXPANDING) {
  ------------------
  |  |   16|    480|#define XML_ENT_EXPANDING   (1<<2)
  ------------------
  |  Branch (7340:13): [True: 4, False: 476]
  ------------------
 7341|      4|            xmlFatalErr(ctxt, XML_ERR_ENTITY_LOOP, NULL);
 7342|      4|            xmlHaltParser(ctxt);
 7343|      4|            return;
 7344|      4|        }
 7345|       |
 7346|    476|        ent->flags |= XML_ENT_EXPANDING;
  ------------------
  |  |   16|    476|#define XML_ENT_EXPANDING   (1<<2)
  ------------------
 7347|       |
 7348|       |	/*
 7349|       |	 * Check that this entity is well formed
 7350|       |	 * 4.3.2: An internal general parsed entity is well-formed
 7351|       |	 * if its replacement text matches the production labeled
 7352|       |	 * content.
 7353|       |	 */
 7354|    476|	if (ent->etype == XML_INTERNAL_GENERAL_ENTITY) {
  ------------------
  |  Branch (7354:6): [True: 436, False: 40]
  ------------------
 7355|    436|	    ctxt->depth++;
 7356|    436|	    ret = xmlParseBalancedChunkMemoryInternal(ctxt, ent->content,
 7357|    436|	                                              user_data, &list);
 7358|    436|	    ctxt->depth--;
 7359|       |
 7360|    436|	} else if (ent->etype == XML_EXTERNAL_GENERAL_PARSED_ENTITY) {
  ------------------
  |  Branch (7360:13): [True: 40, False: 0]
  ------------------
 7361|     40|	    ctxt->depth++;
 7362|     40|	    ret = xmlParseExternalEntityPrivate(ctxt->myDoc, ctxt, ctxt->sax,
 7363|     40|	                                   user_data, ctxt->depth, ent->URI,
 7364|     40|					   ent->ExternalID, &list);
 7365|     40|	    ctxt->depth--;
 7366|     40|	} else {
 7367|      0|	    ret = XML_ERR_ENTITY_PE_INTERNAL;
 7368|      0|	    xmlErrMsgStr(ctxt, XML_ERR_INTERNAL_ERROR,
 7369|      0|			 "invalid entity type found\n", NULL);
 7370|      0|	}
 7371|       |
 7372|    476|        ent->flags &= ~XML_ENT_EXPANDING;
  ------------------
  |  |   16|    476|#define XML_ENT_EXPANDING   (1<<2)
  ------------------
 7373|    476|        ent->flags |= XML_ENT_PARSED | XML_ENT_CHECKED;
  ------------------
  |  |   14|    476|#define XML_ENT_PARSED      (1<<0)
  ------------------
                      ent->flags |= XML_ENT_PARSED | XML_ENT_CHECKED;
  ------------------
  |  |   15|    476|#define XML_ENT_CHECKED     (1<<1)
  ------------------
 7374|    476|        ent->expandedSize = ctxt->sizeentcopy;
 7375|    476|	if (ret == XML_ERR_ENTITY_LOOP) {
  ------------------
  |  Branch (7375:6): [True: 188, False: 288]
  ------------------
 7376|    188|            xmlHaltParser(ctxt);
 7377|    188|	    xmlFreeNodeList(list);
 7378|    188|	    return;
 7379|    188|	}
 7380|    288|	if (xmlParserEntityCheck(ctxt, oldsizeentcopy)) {
  ------------------
  |  Branch (7380:6): [True: 0, False: 288]
  ------------------
 7381|      0|	    xmlFreeNodeList(list);
 7382|      0|	    return;
 7383|      0|	}
 7384|       |
 7385|    288|	if ((ret == XML_ERR_OK) && (list != NULL)) {
  ------------------
  |  Branch (7385:6): [True: 280, False: 8]
  |  Branch (7385:29): [True: 280, False: 0]
  ------------------
 7386|    280|            ent->children = list;
 7387|       |            /*
 7388|       |             * Prune it directly in the generated document
 7389|       |             * except for single text nodes.
 7390|       |             */
 7391|    280|            if ((ctxt->replaceEntities == 0) ||
  ------------------
  |  Branch (7391:17): [True: 0, False: 280]
  ------------------
 7392|    280|                (ctxt->parseMode == XML_PARSE_READER) ||
  ------------------
  |  Branch (7392:17): [True: 52, False: 228]
  ------------------
 7393|    280|                ((list->type == XML_TEXT_NODE) &&
  ------------------
  |  Branch (7393:18): [True: 191, False: 37]
  ------------------
 7394|    237|                 (list->next == NULL))) {
  ------------------
  |  Branch (7394:18): [True: 185, False: 6]
  ------------------
 7395|    237|                ent->owner = 1;
 7396|    494|                while (list != NULL) {
  ------------------
  |  Branch (7396:24): [True: 257, False: 237]
  ------------------
 7397|    257|                    list->parent = (xmlNodePtr) ent;
 7398|    257|                    if (list->doc != ent->doc)
  ------------------
  |  Branch (7398:25): [True: 0, False: 257]
  ------------------
 7399|      0|                        xmlSetTreeDoc(list, ent->doc);
 7400|    257|                    if (list->next == NULL)
  ------------------
  |  Branch (7400:25): [True: 237, False: 20]
  ------------------
 7401|    237|                        ent->last = list;
 7402|    257|                    list = list->next;
 7403|    257|                }
 7404|    237|                list = NULL;
 7405|    237|            } else {
 7406|     43|                ent->owner = 0;
 7407|    146|                while (list != NULL) {
  ------------------
  |  Branch (7407:24): [True: 103, False: 43]
  ------------------
 7408|    103|                    list->parent = (xmlNodePtr) ctxt->node;
 7409|    103|                    list->doc = ctxt->myDoc;
 7410|    103|                    if (list->next == NULL)
  ------------------
  |  Branch (7410:25): [True: 43, False: 60]
  ------------------
 7411|     43|                        ent->last = list;
 7412|    103|                    list = list->next;
 7413|    103|                }
 7414|     43|                list = ent->children;
 7415|       |#ifdef LIBXML_LEGACY_ENABLED
 7416|       |                if (ent->etype == XML_EXTERNAL_GENERAL_PARSED_ENTITY)
 7417|       |                    xmlAddEntityReference(ent, list, NULL);
 7418|       |#endif /* LIBXML_LEGACY_ENABLED */
 7419|     43|            }
 7420|    280|	} else if ((ret != XML_ERR_OK) &&
  ------------------
  |  Branch (7420:13): [True: 8, False: 0]
  ------------------
 7421|      8|		   (ret != XML_WAR_UNDECLARED_ENTITY)) {
  ------------------
  |  Branch (7421:6): [True: 4, False: 4]
  ------------------
 7422|      4|	    xmlFatalErrMsgStr(ctxt, XML_ERR_UNDECLARED_ENTITY,
 7423|      4|		     "Entity '%s' failed to parse\n", ent->name);
 7424|      4|            if (ent->content != NULL)
  ------------------
  |  Branch (7424:17): [True: 0, False: 4]
  ------------------
 7425|      0|                ent->content[0] = 0;
 7426|      4|	} else if (list != NULL) {
  ------------------
  |  Branch (7426:13): [True: 0, False: 4]
  ------------------
 7427|      0|	    xmlFreeNodeList(list);
 7428|      0|	    list = NULL;
 7429|      0|	}
 7430|       |
 7431|       |        /* Prevent entity from being parsed and expanded twice (Bug 760367). */
 7432|    288|        was_checked = 0;
 7433|    288|    }
 7434|       |
 7435|       |    /*
 7436|       |     * Now that the entity content has been gathered
 7437|       |     * provide it to the application, this can take different forms based
 7438|       |     * on the parsing modes.
 7439|       |     */
 7440|  11.0k|    if (ent->children == NULL) {
  ------------------
  |  Branch (7440:9): [True: 8, False: 11.0k]
  ------------------
 7441|       |	/*
 7442|       |	 * Probably running in SAX mode and the callbacks don't
 7443|       |	 * build the entity content. So unless we already went
 7444|       |	 * though parsing for first checking go though the entity
 7445|       |	 * content to generate callbacks associated to the entity
 7446|       |	 */
 7447|      8|	if (was_checked != 0) {
  ------------------
  |  Branch (7447:6): [True: 0, False: 8]
  ------------------
 7448|      0|	    void *user_data;
 7449|       |	    /*
 7450|       |	     * This is a bit hackish but this seems the best
 7451|       |	     * way to make sure both SAX and DOM entity support
 7452|       |	     * behaves okay.
 7453|       |	     */
 7454|      0|	    if (ctxt->userData == ctxt)
  ------------------
  |  Branch (7454:10): [True: 0, False: 0]
  ------------------
 7455|      0|		user_data = NULL;
 7456|      0|	    else
 7457|      0|		user_data = ctxt->userData;
 7458|       |
 7459|      0|	    if (ent->etype == XML_INTERNAL_GENERAL_ENTITY) {
  ------------------
  |  Branch (7459:10): [True: 0, False: 0]
  ------------------
 7460|      0|		ctxt->depth++;
 7461|      0|		ret = xmlParseBalancedChunkMemoryInternal(ctxt,
 7462|      0|				   ent->content, user_data, NULL);
 7463|      0|		ctxt->depth--;
 7464|      0|	    } else if (ent->etype ==
  ------------------
  |  Branch (7464:17): [True: 0, False: 0]
  ------------------
 7465|      0|		       XML_EXTERNAL_GENERAL_PARSED_ENTITY) {
 7466|      0|	        unsigned long oldsizeentities = ctxt->sizeentities;
 7467|       |
 7468|      0|		ctxt->depth++;
 7469|      0|		ret = xmlParseExternalEntityPrivate(ctxt->myDoc, ctxt,
 7470|      0|			   ctxt->sax, user_data, ctxt->depth,
 7471|      0|			   ent->URI, ent->ExternalID, NULL);
 7472|      0|		ctxt->depth--;
 7473|       |
 7474|       |                /* Undo the change to sizeentities */
 7475|      0|                ctxt->sizeentities = oldsizeentities;
 7476|      0|	    } else {
 7477|      0|		ret = XML_ERR_ENTITY_PE_INTERNAL;
 7478|      0|		xmlErrMsgStr(ctxt, XML_ERR_INTERNAL_ERROR,
 7479|      0|			     "invalid entity type found\n", NULL);
 7480|      0|	    }
 7481|      0|	    if (ret == XML_ERR_ENTITY_LOOP) {
  ------------------
  |  Branch (7481:10): [True: 0, False: 0]
  ------------------
 7482|      0|		xmlFatalErr(ctxt, XML_ERR_ENTITY_LOOP, NULL);
 7483|      0|		return;
 7484|      0|	    }
 7485|      0|            if (xmlParserEntityCheck(ctxt, 0))
  ------------------
  |  Branch (7485:17): [True: 0, False: 0]
  ------------------
 7486|      0|                return;
 7487|      0|	}
 7488|      8|	if ((ctxt->sax != NULL) && (ctxt->sax->reference != NULL) &&
  ------------------
  |  Branch (7488:6): [True: 8, False: 0]
  |  Branch (7488:29): [True: 8, False: 0]
  ------------------
 7489|      8|	    (ctxt->replaceEntities == 0) && (!ctxt->disableSAX)) {
  ------------------
  |  Branch (7489:6): [True: 0, False: 8]
  |  Branch (7489:38): [True: 0, False: 0]
  ------------------
 7490|       |	    /*
 7491|       |	     * Entity reference callback comes second, it's somewhat
 7492|       |	     * superfluous but a compatibility to historical behaviour
 7493|       |	     */
 7494|      0|	    ctxt->sax->reference(ctxt->userData, ent->name);
 7495|      0|	}
 7496|      8|	return;
 7497|      8|    }
 7498|       |
 7499|       |    /*
 7500|       |     * We also check for amplification if entities aren't substituted.
 7501|       |     * They might be expanded later.
 7502|       |     */
 7503|  11.0k|    if ((was_checked != 0) &&
  ------------------
  |  Branch (7503:9): [True: 10.7k, False: 280]
  ------------------
 7504|  11.0k|        (xmlParserEntityCheck(ctxt, ent->expandedSize)))
  ------------------
  |  Branch (7504:9): [True: 8, False: 10.7k]
  ------------------
 7505|      8|        return;
 7506|       |
 7507|       |    /*
 7508|       |     * If we didn't get any children for the entity being built
 7509|       |     */
 7510|  11.0k|    if ((ctxt->sax != NULL) && (ctxt->sax->reference != NULL) &&
  ------------------
  |  Branch (7510:9): [True: 11.0k, False: 0]
  |  Branch (7510:32): [True: 11.0k, False: 0]
  ------------------
 7511|  11.0k|	(ctxt->replaceEntities == 0) && (!ctxt->disableSAX)) {
  ------------------
  |  Branch (7511:2): [True: 0, False: 11.0k]
  |  Branch (7511:34): [True: 0, False: 0]
  ------------------
 7512|       |	/*
 7513|       |	 * Create a node.
 7514|       |	 */
 7515|      0|	ctxt->sax->reference(ctxt->userData, ent->name);
 7516|      0|	return;
 7517|      0|    }
 7518|       |
 7519|  11.0k|    if (ctxt->replaceEntities)  {
  ------------------
  |  Branch (7519:9): [True: 11.0k, False: 0]
  ------------------
 7520|       |	/*
 7521|       |	 * There is a problem on the handling of _private for entities
 7522|       |	 * (bug 155816): Should we copy the content of the field from
 7523|       |	 * the entity (possibly overwriting some value set by the user
 7524|       |	 * when a copy is created), should we leave it alone, or should
 7525|       |	 * we try to take care of different situations?  The problem
 7526|       |	 * is exacerbated by the usage of this field by the xmlReader.
 7527|       |	 * To fix this bug, we look at _private on the created node
 7528|       |	 * and, if it's NULL, we copy in whatever was in the entity.
 7529|       |	 * If it's not NULL we leave it alone.  This is somewhat of a
 7530|       |	 * hack - maybe we should have further tests to determine
 7531|       |	 * what to do.
 7532|       |	 */
 7533|  11.0k|	if (ctxt->node != NULL) {
  ------------------
  |  Branch (7533:6): [True: 11.0k, False: 0]
  ------------------
 7534|       |	    /*
 7535|       |	     * Seems we are generating the DOM content, do
 7536|       |	     * a simple tree copy for all references except the first
 7537|       |	     * In the first occurrence list contains the replacement.
 7538|       |	     */
 7539|  11.0k|	    if (((list == NULL) && (ent->owner == 0)) ||
  ------------------
  |  Branch (7539:11): [True: 10.9k, False: 43]
  |  Branch (7539:29): [True: 0, False: 10.9k]
  ------------------
 7540|  11.0k|		(ctxt->parseMode == XML_PARSE_READER)) {
  ------------------
  |  Branch (7540:3): [True: 2.59k, False: 8.43k]
  ------------------
 7541|  2.59k|		xmlNodePtr nw = NULL, cur, firstChild = NULL;
 7542|       |
 7543|       |		/*
 7544|       |		 * when operating on a reader, the entities definitions
 7545|       |		 * are always owning the entities subtree.
 7546|       |		if (ctxt->parseMode == XML_PARSE_READER)
 7547|       |		    ent->owner = 1;
 7548|       |		 */
 7549|       |
 7550|  2.59k|		cur = ent->children;
 7551|  2.65k|		while (cur != NULL) {
  ------------------
  |  Branch (7551:10): [True: 2.65k, False: 0]
  ------------------
 7552|  2.65k|		    nw = xmlDocCopyNode(cur, ctxt->myDoc, 1);
 7553|  2.65k|		    if (nw != NULL) {
  ------------------
  |  Branch (7553:11): [True: 2.65k, False: 0]
  ------------------
 7554|  2.65k|			if (nw->_private == NULL)
  ------------------
  |  Branch (7554:8): [True: 2.65k, False: 0]
  ------------------
 7555|  2.65k|			    nw->_private = cur->_private;
 7556|  2.65k|			if (firstChild == NULL){
  ------------------
  |  Branch (7556:8): [True: 2.59k, False: 59]
  ------------------
 7557|  2.59k|			    firstChild = nw;
 7558|  2.59k|			}
 7559|  2.65k|			nw = xmlAddChild(ctxt->node, nw);
 7560|  2.65k|		    }
 7561|  2.65k|		    if (cur == ent->last) {
  ------------------
  |  Branch (7561:11): [True: 2.59k, False: 59]
  ------------------
 7562|       |			/*
 7563|       |			 * needed to detect some strange empty
 7564|       |			 * node cases in the reader tests
 7565|       |			 */
 7566|  2.59k|			if ((ctxt->parseMode == XML_PARSE_READER) &&
  ------------------
  |  Branch (7566:8): [True: 2.59k, False: 0]
  ------------------
 7567|  2.59k|			    (nw != NULL) &&
  ------------------
  |  Branch (7567:8): [True: 2.59k, False: 0]
  ------------------
 7568|  2.59k|			    (nw->type == XML_ELEMENT_NODE) &&
  ------------------
  |  Branch (7568:8): [True: 17, False: 2.58k]
  ------------------
 7569|  2.59k|			    (nw->children == NULL))
  ------------------
  |  Branch (7569:8): [True: 11, False: 6]
  ------------------
 7570|     11|			    nw->extra = 1;
 7571|       |
 7572|  2.59k|			break;
 7573|  2.59k|		    }
 7574|     59|		    cur = cur->next;
 7575|     59|		}
 7576|       |#ifdef LIBXML_LEGACY_ENABLED
 7577|       |		if (ent->etype == XML_EXTERNAL_GENERAL_PARSED_ENTITY)
 7578|       |		  xmlAddEntityReference(ent, firstChild, nw);
 7579|       |#endif /* LIBXML_LEGACY_ENABLED */
 7580|  8.43k|	    } else if ((list == NULL) || (ctxt->inputNr > 0)) {
  ------------------
  |  Branch (7580:17): [True: 8.39k, False: 43]
  |  Branch (7580:35): [True: 43, False: 0]
  ------------------
 7581|  8.43k|		xmlNodePtr nw = NULL, cur, next, last,
 7582|  8.43k|			   firstChild = NULL;
 7583|       |
 7584|       |		/*
 7585|       |		 * Copy the entity child list and make it the new
 7586|       |		 * entity child list. The goal is to make sure any
 7587|       |		 * ID or REF referenced will be the one from the
 7588|       |		 * document content and not the entity copy.
 7589|       |		 */
 7590|  8.43k|		cur = ent->children;
 7591|  8.43k|		ent->children = NULL;
 7592|  8.43k|		last = ent->last;
 7593|  8.43k|		ent->last = NULL;
 7594|  8.61k|		while (cur != NULL) {
  ------------------
  |  Branch (7594:10): [True: 8.61k, False: 0]
  ------------------
 7595|  8.61k|		    next = cur->next;
 7596|  8.61k|		    cur->next = NULL;
 7597|  8.61k|		    cur->parent = NULL;
 7598|  8.61k|		    nw = xmlDocCopyNode(cur, ctxt->myDoc, 1);
 7599|  8.61k|		    if (nw != NULL) {
  ------------------
  |  Branch (7599:11): [True: 8.61k, False: 0]
  ------------------
 7600|  8.61k|			if (nw->_private == NULL)
  ------------------
  |  Branch (7600:8): [True: 8.61k, False: 0]
  ------------------
 7601|  8.61k|			    nw->_private = cur->_private;
 7602|  8.61k|			if (firstChild == NULL){
  ------------------
  |  Branch (7602:8): [True: 8.43k, False: 177]
  ------------------
 7603|  8.43k|			    firstChild = cur;
 7604|  8.43k|			}
 7605|  8.61k|			xmlAddChild((xmlNodePtr) ent, nw);
 7606|  8.61k|		    }
 7607|  8.61k|		    xmlAddChild(ctxt->node, cur);
 7608|  8.61k|		    if (cur == last)
  ------------------
  |  Branch (7608:11): [True: 8.43k, False: 177]
  ------------------
 7609|  8.43k|			break;
 7610|    177|		    cur = next;
 7611|    177|		}
 7612|  8.43k|		if (ent->owner == 0)
  ------------------
  |  Branch (7612:7): [True: 43, False: 8.39k]
  ------------------
 7613|     43|		    ent->owner = 1;
 7614|       |#ifdef LIBXML_LEGACY_ENABLED
 7615|       |		if (ent->etype == XML_EXTERNAL_GENERAL_PARSED_ENTITY)
 7616|       |		  xmlAddEntityReference(ent, firstChild, nw);
 7617|       |#endif /* LIBXML_LEGACY_ENABLED */
 7618|  8.43k|	    } else {
 7619|      0|		const xmlChar *nbktext;
 7620|       |
 7621|       |		/*
 7622|       |		 * the name change is to avoid coalescing of the
 7623|       |		 * node with a possible previous text one which
 7624|       |		 * would make ent->children a dangling pointer
 7625|       |		 */
 7626|      0|		nbktext = xmlDictLookup(ctxt->dict, BAD_CAST "nbktext",
  ------------------
  |  |   35|      0|#define BAD_CAST (xmlChar *)
  ------------------
 7627|      0|					-1);
 7628|      0|		if (ent->children->type == XML_TEXT_NODE)
  ------------------
  |  Branch (7628:7): [True: 0, False: 0]
  ------------------
 7629|      0|		    ent->children->name = nbktext;
 7630|      0|		if ((ent->last != ent->children) &&
  ------------------
  |  Branch (7630:7): [True: 0, False: 0]
  ------------------
 7631|      0|		    (ent->last->type == XML_TEXT_NODE))
  ------------------
  |  Branch (7631:7): [True: 0, False: 0]
  ------------------
 7632|      0|		    ent->last->name = nbktext;
 7633|      0|		xmlAddChildList(ctxt->node, ent->children);
 7634|      0|	    }
 7635|       |
 7636|       |	    /*
 7637|       |	     * This is to avoid a nasty side effect, see
 7638|       |	     * characters() in SAX.c
 7639|       |	     */
 7640|  11.0k|	    ctxt->nodemem = 0;
 7641|  11.0k|	    ctxt->nodelen = 0;
 7642|  11.0k|	    return;
 7643|  11.0k|	}
 7644|  11.0k|    }
 7645|  11.0k|}
xmlParseEntityRef:
 7678|  21.1k|xmlParseEntityRef(xmlParserCtxtPtr ctxt) {
 7679|  21.1k|    const xmlChar *name;
 7680|  21.1k|    xmlEntityPtr ent = NULL;
 7681|       |
 7682|  21.1k|    GROW;
  ------------------
  |  | 2270|  21.1k|#define GROW if (ctxt->input->end - ctxt->input->cur < INPUT_CHUNK)	\
  |  |  ------------------
  |  |  |  |   97|  21.1k|#define INPUT_CHUNK	250
  |  |  ------------------
  |  |  |  Branch (2270:18): [True: 5.67k, False: 15.4k]
  |  |  ------------------
  |  | 2271|  21.1k|	xmlParserGrow(ctxt);
  ------------------
 7683|  21.1k|    if (ctxt->instate == XML_PARSER_EOF)
  ------------------
  |  Branch (7683:9): [True: 0, False: 21.1k]
  ------------------
 7684|      0|        return(NULL);
 7685|       |
 7686|  21.1k|    if (RAW != '&')
  ------------------
  |  | 2221|  21.1k|#define RAW (*ctxt->input->cur)
  ------------------
  |  Branch (7686:9): [True: 0, False: 21.1k]
  ------------------
 7687|      0|        return(NULL);
 7688|  21.1k|    NEXT;
  ------------------
  |  | 2275|  21.1k|#define NEXT xmlNextChar(ctxt)
  ------------------
 7689|  21.1k|    name = xmlParseName(ctxt);
 7690|  21.1k|    if (name == NULL) {
  ------------------
  |  Branch (7690:9): [True: 0, False: 21.1k]
  ------------------
 7691|      0|	xmlFatalErrMsg(ctxt, XML_ERR_NAME_REQUIRED,
 7692|      0|		       "xmlParseEntityRef: no name\n");
 7693|      0|        return(NULL);
 7694|      0|    }
 7695|  21.1k|    if (RAW != ';') {
  ------------------
  |  | 2221|  21.1k|#define RAW (*ctxt->input->cur)
  ------------------
  |  Branch (7695:9): [True: 0, False: 21.1k]
  ------------------
 7696|      0|	xmlFatalErr(ctxt, XML_ERR_ENTITYREF_SEMICOL_MISSING, NULL);
 7697|      0|	return(NULL);
 7698|      0|    }
 7699|  21.1k|    NEXT;
  ------------------
  |  | 2275|  21.1k|#define NEXT xmlNextChar(ctxt)
  ------------------
 7700|       |
 7701|       |    /*
 7702|       |     * Predefined entities override any extra definition
 7703|       |     */
 7704|  21.1k|    if ((ctxt->options & XML_PARSE_OLDSAX) == 0) {
  ------------------
  |  Branch (7704:9): [True: 21.1k, False: 0]
  ------------------
 7705|  21.1k|        ent = xmlGetPredefinedEntity(name);
 7706|  21.1k|        if (ent != NULL)
  ------------------
  |  Branch (7706:13): [True: 908, False: 20.2k]
  ------------------
 7707|    908|            return(ent);
 7708|  21.1k|    }
 7709|       |
 7710|       |    /*
 7711|       |     * Ask first SAX for entity resolution, otherwise try the
 7712|       |     * entities which may have stored in the parser context.
 7713|       |     */
 7714|  20.2k|    if (ctxt->sax != NULL) {
  ------------------
  |  Branch (7714:9): [True: 20.2k, False: 0]
  ------------------
 7715|  20.2k|	if (ctxt->sax->getEntity != NULL)
  ------------------
  |  Branch (7715:6): [True: 20.2k, False: 0]
  ------------------
 7716|  20.2k|	    ent = ctxt->sax->getEntity(ctxt->userData, name);
 7717|  20.2k|	if ((ctxt->wellFormed == 1 ) && (ent == NULL) &&
  ------------------
  |  Branch (7717:6): [True: 20.2k, False: 2]
  |  Branch (7717:34): [True: 4, False: 20.2k]
  ------------------
 7718|  20.2k|	    (ctxt->options & XML_PARSE_OLDSAX))
  ------------------
  |  Branch (7718:6): [True: 0, False: 4]
  ------------------
 7719|      0|	    ent = xmlGetPredefinedEntity(name);
 7720|  20.2k|	if ((ctxt->wellFormed == 1 ) && (ent == NULL) &&
  ------------------
  |  Branch (7720:6): [True: 20.2k, False: 2]
  |  Branch (7720:34): [True: 4, False: 20.2k]
  ------------------
 7721|  20.2k|	    (ctxt->userData==ctxt)) {
  ------------------
  |  Branch (7721:6): [True: 4, False: 0]
  ------------------
 7722|      4|	    ent = xmlSAX2GetEntity(ctxt, name);
 7723|      4|	}
 7724|  20.2k|    }
 7725|  20.2k|    if (ctxt->instate == XML_PARSER_EOF)
  ------------------
  |  Branch (7725:9): [True: 0, False: 20.2k]
  ------------------
 7726|      0|	return(NULL);
 7727|       |    /*
 7728|       |     * [ WFC: Entity Declared ]
 7729|       |     * In a document without any DTD, a document with only an
 7730|       |     * internal DTD subset which contains no parameter entity
 7731|       |     * references, or a document with "standalone='yes'", the
 7732|       |     * Name given in the entity reference must match that in an
 7733|       |     * entity declaration, except that well-formed documents
 7734|       |     * need not declare any of the following entities: amp, lt,
 7735|       |     * gt, apos, quot.
 7736|       |     * The declaration of a parameter entity must precede any
 7737|       |     * reference to it.
 7738|       |     * Similarly, the declaration of a general entity must
 7739|       |     * precede any reference to it which appears in a default
 7740|       |     * value in an attribute-list declaration. Note that if
 7741|       |     * entities are declared in the external subset or in
 7742|       |     * external parameter entities, a non-validating processor
 7743|       |     * is not obligated to read and process their declarations;
 7744|       |     * for such documents, the rule that an entity must be
 7745|       |     * declared is a well-formedness constraint only if
 7746|       |     * standalone='yes'.
 7747|       |     */
 7748|  20.2k|    if (ent == NULL) {
  ------------------
  |  Branch (7748:9): [True: 4, False: 20.2k]
  ------------------
 7749|      4|	if ((ctxt->standalone == 1) ||
  ------------------
  |  Branch (7749:6): [True: 0, False: 4]
  ------------------
 7750|      4|	    ((ctxt->hasExternalSubset == 0) &&
  ------------------
  |  Branch (7750:7): [True: 0, False: 4]
  ------------------
 7751|      4|	     (ctxt->hasPErefs == 0))) {
  ------------------
  |  Branch (7751:7): [True: 0, False: 0]
  ------------------
 7752|      0|	    xmlFatalErrMsgStr(ctxt, XML_ERR_UNDECLARED_ENTITY,
 7753|      0|		     "Entity '%s' not defined\n", name);
 7754|      4|	} else {
 7755|      4|	    xmlErrMsgStr(ctxt, XML_WAR_UNDECLARED_ENTITY,
 7756|      4|		     "Entity '%s' not defined\n", name);
 7757|      4|	    if ((ctxt->inSubset == 0) &&
  ------------------
  |  Branch (7757:10): [True: 4, False: 0]
  ------------------
 7758|      4|		(ctxt->sax != NULL) &&
  ------------------
  |  Branch (7758:3): [True: 4, False: 0]
  ------------------
 7759|      4|                (ctxt->disableSAX == 0) &&
  ------------------
  |  Branch (7759:17): [True: 4, False: 0]
  ------------------
 7760|      4|		(ctxt->sax->reference != NULL)) {
  ------------------
  |  Branch (7760:3): [True: 4, False: 0]
  ------------------
 7761|      4|		ctxt->sax->reference(ctxt->userData, name);
 7762|      4|	    }
 7763|      4|	}
 7764|      4|	ctxt->valid = 0;
 7765|      4|    }
 7766|       |
 7767|       |    /*
 7768|       |     * [ WFC: Parsed Entity ]
 7769|       |     * An entity reference must not contain the name of an
 7770|       |     * unparsed entity
 7771|       |     */
 7772|  20.2k|    else if (ent->etype == XML_EXTERNAL_GENERAL_UNPARSED_ENTITY) {
  ------------------
  |  Branch (7772:14): [True: 0, False: 20.2k]
  ------------------
 7773|      0|	xmlFatalErrMsgStr(ctxt, XML_ERR_UNPARSED_ENTITY,
 7774|      0|		 "Entity reference to unparsed entity %s\n", name);
 7775|      0|    }
 7776|       |
 7777|       |    /*
 7778|       |     * [ WFC: No External Entity References ]
 7779|       |     * Attribute values cannot contain direct or indirect
 7780|       |     * entity references to external entities.
 7781|       |     */
 7782|  20.2k|    else if ((ctxt->instate == XML_PARSER_ATTRIBUTE_VALUE) &&
  ------------------
  |  Branch (7782:14): [True: 9.01k, False: 11.2k]
  ------------------
 7783|  20.2k|	     (ent->etype == XML_EXTERNAL_GENERAL_PARSED_ENTITY)) {
  ------------------
  |  Branch (7783:7): [True: 0, False: 9.01k]
  ------------------
 7784|      0|	xmlFatalErrMsgStr(ctxt, XML_ERR_ENTITY_IS_EXTERNAL,
 7785|      0|	     "Attribute references external entity '%s'\n", name);
 7786|      0|    }
 7787|       |    /*
 7788|       |     * [ WFC: No < in Attribute Values ]
 7789|       |     * The replacement text of any entity referred to directly or
 7790|       |     * indirectly in an attribute value (other than "&lt;") must
 7791|       |     * not contain a <.
 7792|       |     */
 7793|  20.2k|    else if ((ctxt->instate == XML_PARSER_ATTRIBUTE_VALUE) &&
  ------------------
  |  Branch (7793:14): [True: 9.01k, False: 11.2k]
  ------------------
 7794|  20.2k|	     (ent->etype != XML_INTERNAL_PREDEFINED_ENTITY)) {
  ------------------
  |  Branch (7794:7): [True: 9.01k, False: 0]
  ------------------
 7795|  9.01k|	if ((ent->flags & XML_ENT_CHECKED_LT) == 0) {
  ------------------
  |  |   17|  9.01k|#define XML_ENT_CHECKED_LT  (1<<3)
  ------------------
  |  Branch (7795:6): [True: 64, False: 8.95k]
  ------------------
 7796|     64|            if ((ent->content != NULL) && (xmlStrchr(ent->content, '<')))
  ------------------
  |  Branch (7796:17): [True: 64, False: 0]
  |  Branch (7796:43): [True: 0, False: 64]
  ------------------
 7797|      0|                ent->flags |= XML_ENT_CONTAINS_LT;
  ------------------
  |  |   18|      0|#define XML_ENT_CONTAINS_LT (1<<4)
  ------------------
 7798|     64|            ent->flags |= XML_ENT_CHECKED_LT;
  ------------------
  |  |   17|     64|#define XML_ENT_CHECKED_LT  (1<<3)
  ------------------
 7799|     64|        }
 7800|  9.01k|        if (ent->flags & XML_ENT_CONTAINS_LT)
  ------------------
  |  |   18|  9.01k|#define XML_ENT_CONTAINS_LT (1<<4)
  ------------------
  |  Branch (7800:13): [True: 0, False: 9.01k]
  ------------------
 7801|      0|            xmlFatalErrMsgStr(ctxt, XML_ERR_LT_IN_ATTRIBUTE,
 7802|      0|                    "'<' in entity '%s' is not allowed in attributes "
 7803|      0|                    "values\n", name);
 7804|  9.01k|    }
 7805|       |
 7806|       |    /*
 7807|       |     * Internal check, no parameter entities here ...
 7808|       |     */
 7809|  11.2k|    else {
 7810|  11.2k|	switch (ent->etype) {
 7811|      0|	    case XML_INTERNAL_PARAMETER_ENTITY:
  ------------------
  |  Branch (7811:6): [True: 0, False: 11.2k]
  ------------------
 7812|      0|	    case XML_EXTERNAL_PARAMETER_ENTITY:
  ------------------
  |  Branch (7812:6): [True: 0, False: 11.2k]
  ------------------
 7813|      0|	    xmlFatalErrMsgStr(ctxt, XML_ERR_ENTITY_IS_PARAMETER,
 7814|      0|	     "Attempt to reference the parameter entity '%s'\n",
 7815|      0|			      name);
 7816|      0|	    break;
 7817|  11.2k|	    default:
  ------------------
  |  Branch (7817:6): [True: 11.2k, False: 0]
  ------------------
 7818|  11.2k|	    break;
 7819|  11.2k|	}
 7820|  11.2k|    }
 7821|       |
 7822|       |    /*
 7823|       |     * [ WFC: No Recursion ]
 7824|       |     * A parsed entity must not contain a recursive reference
 7825|       |     * to itself, either directly or indirectly.
 7826|       |     * Done somewhere else
 7827|       |     */
 7828|  20.2k|    return(ent);
 7829|  20.2k|}
xmlParsePEReference:
 8059|   137k|{
 8060|   137k|    const xmlChar *name;
 8061|   137k|    xmlEntityPtr entity = NULL;
 8062|   137k|    xmlParserInputPtr input;
 8063|       |
 8064|   137k|    if (RAW != '%')
  ------------------
  |  | 2221|   137k|#define RAW (*ctxt->input->cur)
  ------------------
  |  Branch (8064:9): [True: 0, False: 137k]
  ------------------
 8065|      0|        return;
 8066|   137k|    NEXT;
  ------------------
  |  | 2275|   137k|#define NEXT xmlNextChar(ctxt)
  ------------------
 8067|   137k|    name = xmlParseName(ctxt);
 8068|   137k|    if (name == NULL) {
  ------------------
  |  Branch (8068:9): [True: 4, False: 137k]
  ------------------
 8069|      4|	xmlFatalErrMsg(ctxt, XML_ERR_PEREF_NO_NAME, "PEReference: no name\n");
 8070|      4|	return;
 8071|      4|    }
 8072|   137k|    if (xmlParserDebugEntities)
  ------------------
  |  |  870|   137k|  #define xmlParserDebugEntities XML_GLOBAL_MACRO(xmlParserDebugEntities)
  |  |  ------------------
  |  |  |  |  500|   137k|  #define XML_GLOBAL_MACRO(name) (*__##name())
  |  |  |  |  ------------------
  |  |  |  |  |  Branch (500:34): [True: 0, False: 137k]
  |  |  |  |  ------------------
  |  |  ------------------
  ------------------
 8073|      0|	xmlGenericError(xmlGenericErrorContext,
  ------------------
  |  |  875|      0|  #define xmlGenericError XML_GLOBAL_MACRO(xmlGenericError)
  |  |  ------------------
  |  |  |  |  500|      0|  #define XML_GLOBAL_MACRO(name) (*__##name())
  |  |  ------------------
  ------------------
              	xmlGenericError(xmlGenericErrorContext,
  ------------------
  |  |  876|      0|  #define xmlGenericErrorContext XML_GLOBAL_MACRO(xmlGenericErrorContext)
  |  |  ------------------
  |  |  |  |  500|      0|  #define XML_GLOBAL_MACRO(name) (*__##name())
  |  |  ------------------
  ------------------
 8074|      0|		"PEReference: %s\n", name);
 8075|   137k|    if (RAW != ';') {
  ------------------
  |  | 2221|   137k|#define RAW (*ctxt->input->cur)
  ------------------
  |  Branch (8075:9): [True: 4, False: 137k]
  ------------------
 8076|      4|	xmlFatalErr(ctxt, XML_ERR_PEREF_SEMICOL_MISSING, NULL);
 8077|      4|        return;
 8078|      4|    }
 8079|       |
 8080|   137k|    NEXT;
  ------------------
  |  | 2275|   137k|#define NEXT xmlNextChar(ctxt)
  ------------------
 8081|       |
 8082|       |    /*
 8083|       |     * Request the entity from SAX
 8084|       |     */
 8085|   137k|    if ((ctxt->sax != NULL) &&
  ------------------
  |  Branch (8085:9): [True: 137k, False: 0]
  ------------------
 8086|   137k|	(ctxt->sax->getParameterEntity != NULL))
  ------------------
  |  Branch (8086:2): [True: 137k, False: 0]
  ------------------
 8087|   137k|	entity = ctxt->sax->getParameterEntity(ctxt->userData, name);
 8088|   137k|    if (ctxt->instate == XML_PARSER_EOF)
  ------------------
  |  Branch (8088:9): [True: 0, False: 137k]
  ------------------
 8089|      0|	return;
 8090|   137k|    if (entity == NULL) {
  ------------------
  |  Branch (8090:9): [True: 0, False: 137k]
  ------------------
 8091|       |	/*
 8092|       |	 * [ WFC: Entity Declared ]
 8093|       |	 * In a document without any DTD, a document with only an
 8094|       |	 * internal DTD subset which contains no parameter entity
 8095|       |	 * references, or a document with "standalone='yes'", ...
 8096|       |	 * ... The declaration of a parameter entity must precede
 8097|       |	 * any reference to it...
 8098|       |	 */
 8099|      0|	if ((ctxt->standalone == 1) ||
  ------------------
  |  Branch (8099:6): [True: 0, False: 0]
  ------------------
 8100|      0|	    ((ctxt->hasExternalSubset == 0) &&
  ------------------
  |  Branch (8100:7): [True: 0, False: 0]
  ------------------
 8101|      0|	     (ctxt->hasPErefs == 0))) {
  ------------------
  |  Branch (8101:7): [True: 0, False: 0]
  ------------------
 8102|      0|	    xmlFatalErrMsgStr(ctxt, XML_ERR_UNDECLARED_ENTITY,
 8103|      0|			      "PEReference: %%%s; not found\n",
 8104|      0|			      name);
 8105|      0|	} else {
 8106|       |	    /*
 8107|       |	     * [ VC: Entity Declared ]
 8108|       |	     * In a document with an external subset or external
 8109|       |	     * parameter entities with "standalone='no'", ...
 8110|       |	     * ... The declaration of a parameter entity must
 8111|       |	     * precede any reference to it...
 8112|       |	     */
 8113|      0|            if ((ctxt->validate) && (ctxt->vctxt.error != NULL)) {
  ------------------
  |  Branch (8113:17): [True: 0, False: 0]
  |  Branch (8113:37): [True: 0, False: 0]
  ------------------
 8114|      0|                xmlValidityError(ctxt, XML_WAR_UNDECLARED_ENTITY,
 8115|      0|                                 "PEReference: %%%s; not found\n",
 8116|      0|                                 name, NULL);
 8117|      0|            } else
 8118|      0|                xmlWarningMsg(ctxt, XML_WAR_UNDECLARED_ENTITY,
 8119|      0|                              "PEReference: %%%s; not found\n",
 8120|      0|                              name, NULL);
 8121|      0|            ctxt->valid = 0;
 8122|      0|	}
 8123|   137k|    } else {
 8124|       |	/*
 8125|       |	 * Internal checking in case the entity quest barfed
 8126|       |	 */
 8127|   137k|	if ((entity->etype != XML_INTERNAL_PARAMETER_ENTITY) &&
  ------------------
  |  Branch (8127:6): [True: 13.1k, False: 124k]
  ------------------
 8128|   137k|	    (entity->etype != XML_EXTERNAL_PARAMETER_ENTITY)) {
  ------------------
  |  Branch (8128:6): [True: 0, False: 13.1k]
  ------------------
 8129|      0|	    xmlWarningMsg(ctxt, XML_WAR_UNDECLARED_ENTITY,
 8130|      0|		  "Internal: %%%s; is not a parameter entity\n",
 8131|      0|			  name, NULL);
 8132|   137k|	} else {
 8133|   137k|            unsigned long parentConsumed;
 8134|   137k|            xmlEntityPtr oldEnt;
 8135|       |
 8136|   137k|	    if ((entity->etype == XML_EXTERNAL_PARAMETER_ENTITY) &&
  ------------------
  |  Branch (8136:10): [True: 13.1k, False: 124k]
  ------------------
 8137|   137k|	        ((ctxt->options & XML_PARSE_NOENT) == 0) &&
  ------------------
  |  Branch (8137:10): [True: 0, False: 13.1k]
  ------------------
 8138|   137k|		((ctxt->options & XML_PARSE_DTDVALID) == 0) &&
  ------------------
  |  Branch (8138:3): [True: 0, False: 0]
  ------------------
 8139|   137k|		((ctxt->options & XML_PARSE_DTDLOAD) == 0) &&
  ------------------
  |  Branch (8139:3): [True: 0, False: 0]
  ------------------
 8140|   137k|		((ctxt->options & XML_PARSE_DTDATTR) == 0) &&
  ------------------
  |  Branch (8140:3): [True: 0, False: 0]
  ------------------
 8141|   137k|		(ctxt->replaceEntities == 0) &&
  ------------------
  |  Branch (8141:3): [True: 0, False: 0]
  ------------------
 8142|   137k|		(ctxt->validate == 0))
  ------------------
  |  Branch (8142:3): [True: 0, False: 0]
  ------------------
 8143|      0|		return;
 8144|       |
 8145|   137k|            if (entity->flags & XML_ENT_EXPANDING) {
  ------------------
  |  |   16|   137k|#define XML_ENT_EXPANDING   (1<<2)
  ------------------
  |  Branch (8145:17): [True: 4, False: 137k]
  ------------------
 8146|      4|                xmlFatalErr(ctxt, XML_ERR_ENTITY_LOOP, NULL);
 8147|      4|                xmlHaltParser(ctxt);
 8148|      4|                return;
 8149|      4|            }
 8150|       |
 8151|       |            /* Must be computed from old input before pushing new input. */
 8152|   137k|            parentConsumed = ctxt->input->parentConsumed;
 8153|   137k|            oldEnt = ctxt->input->entity;
 8154|   137k|            if ((oldEnt == NULL) ||
  ------------------
  |  Branch (8154:17): [True: 2.18k, False: 135k]
  ------------------
 8155|   137k|                ((oldEnt->etype == XML_EXTERNAL_PARAMETER_ENTITY) &&
  ------------------
  |  Branch (8155:18): [True: 13.8k, False: 121k]
  ------------------
 8156|   135k|                 ((oldEnt->flags & XML_ENT_PARSED) == 0))) {
  ------------------
  |  |   14|  13.8k|#define XML_ENT_PARSED      (1<<0)
  ------------------
  |  Branch (8156:18): [True: 1.16k, False: 12.6k]
  ------------------
 8157|  3.35k|                xmlSaturatedAdd(&parentConsumed, ctxt->input->consumed);
 8158|  3.35k|                xmlSaturatedAddSizeT(&parentConsumed,
 8159|  3.35k|                                     ctxt->input->cur - ctxt->input->base);
 8160|  3.35k|            }
 8161|       |
 8162|   137k|	    input = xmlNewEntityInputStream(ctxt, entity);
 8163|   137k|	    if (xmlPushInput(ctxt, input) < 0) {
  ------------------
  |  Branch (8163:10): [True: 0, False: 137k]
  ------------------
 8164|      0|                xmlFreeInputStream(input);
 8165|      0|		return;
 8166|      0|            }
 8167|       |
 8168|   137k|            entity->flags |= XML_ENT_EXPANDING;
  ------------------
  |  |   16|   137k|#define XML_ENT_EXPANDING   (1<<2)
  ------------------
 8169|       |
 8170|   137k|            input->parentConsumed = parentConsumed;
 8171|       |
 8172|   137k|	    if (entity->etype == XML_EXTERNAL_PARAMETER_ENTITY) {
  ------------------
  |  Branch (8172:10): [True: 13.1k, False: 124k]
  ------------------
 8173|  13.1k|                xmlDetectEncoding(ctxt);
 8174|       |
 8175|  13.1k|                if ((CMP5(CUR_PTR, '<', '?', 'x', 'm', 'l')) &&
  ------------------
  |  | 2231|  13.1k|  ( CMP4( s, c1, c2, c3, c4 ) && ((unsigned char *) s)[ 4 ] == c5 )
  |  |  ------------------
  |  |  |  | 2228|  26.3k|  ( ((unsigned char *) s)[ 0 ] == c1 && ((unsigned char *) s)[ 1 ] == c2 && \
  |  |  |  |  ------------------
  |  |  |  |  |  Branch (2228:5): [True: 12.9k, False: 196]
  |  |  |  |  |  Branch (2228:41): [True: 4, False: 12.9k]
  |  |  |  |  ------------------
  |  |  |  | 2229|  13.1k|    ((unsigned char *) s)[ 2 ] == c3 && ((unsigned char *) s)[ 3 ] == c4 )
  |  |  |  |  ------------------
  |  |  |  |  |  Branch (2229:5): [True: 4, False: 0]
  |  |  |  |  |  Branch (2229:41): [True: 4, False: 0]
  |  |  |  |  ------------------
  |  |  ------------------
  |  |  |  Branch (2231:34): [True: 4, False: 0]
  |  |  ------------------
  ------------------
 8176|  13.1k|                    (IS_BLANK_CH(NXT(5)))) {
  ------------------
  |  |  151|      4|#define IS_BLANK_CH(c)  xmlIsBlank_ch(c)
  |  |  ------------------
  |  |  |  |   88|      4|#define xmlIsBlank_ch(c)	(((c) == 0x20) || \
  |  |  |  |  ------------------
  |  |  |  |  |  Branch (88:27): [True: 4, False: 0]
  |  |  |  |  ------------------
  |  |  |  |   89|      4|				 ((0x9 <= (c)) && ((c) <= 0xa)) || \
  |  |  |  |  ------------------
  |  |  |  |  |  Branch (89:7): [True: 0, False: 0]
  |  |  |  |  |  Branch (89:23): [True: 0, False: 0]
  |  |  |  |  ------------------
  |  |  |  |   90|      4|				 ((c) == 0xd))
  |  |  |  |  ------------------
  |  |  |  |  |  Branch (90:6): [True: 0, False: 0]
  |  |  |  |  ------------------
  |  |  ------------------
  ------------------
 8177|      4|                    xmlParseTextDecl(ctxt);
 8178|      4|                }
 8179|  13.1k|            }
 8180|   137k|	}
 8181|   137k|    }
 8182|   137k|    ctxt->hasPErefs = 1;
 8183|   137k|}
xmlParseDocTypeDecl:
 8461|    760|xmlParseDocTypeDecl(xmlParserCtxtPtr ctxt) {
 8462|    760|    const xmlChar *name = NULL;
 8463|    760|    xmlChar *ExternalID = NULL;
 8464|    760|    xmlChar *URI = NULL;
 8465|       |
 8466|       |    /*
 8467|       |     * We know that '<!DOCTYPE' has been detected.
 8468|       |     */
 8469|    760|    SKIP(9);
  ------------------
  |  | 2245|    760|#define SKIP(val) do {							\
  |  | 2246|    760|    ctxt->input->cur += (val),ctxt->input->col+=(val);			\
  |  | 2247|    760|    if (*ctxt->input->cur == 0)						\
  |  |  ------------------
  |  |  |  Branch (2247:9): [True: 0, False: 760]
  |  |  ------------------
  |  | 2248|    760|        xmlParserGrow(ctxt);						\
  |  | 2249|    760|  } while (0)
  |  |  ------------------
  |  |  |  Branch (2249:12): [Folded - Ignored]
  |  |  ------------------
  ------------------
 8470|       |
 8471|    760|    SKIP_BLANKS;
  ------------------
  |  | 2273|    760|#define SKIP_BLANKS xmlSkipBlankChars(ctxt)
  ------------------
 8472|       |
 8473|       |    /*
 8474|       |     * Parse the DOCTYPE name.
 8475|       |     */
 8476|    760|    name = xmlParseName(ctxt);
 8477|    760|    if (name == NULL) {
  ------------------
  |  Branch (8477:9): [True: 0, False: 760]
  ------------------
 8478|      0|	xmlFatalErrMsg(ctxt, XML_ERR_NAME_REQUIRED,
 8479|      0|		       "xmlParseDocTypeDecl : no DOCTYPE name !\n");
 8480|      0|    }
 8481|    760|    ctxt->intSubName = name;
 8482|       |
 8483|    760|    SKIP_BLANKS;
  ------------------
  |  | 2273|    760|#define SKIP_BLANKS xmlSkipBlankChars(ctxt)
  ------------------
 8484|       |
 8485|       |    /*
 8486|       |     * Check for SystemID and ExternalID
 8487|       |     */
 8488|    760|    URI = xmlParseExternalID(ctxt, &ExternalID, 1);
 8489|       |
 8490|    760|    if ((URI != NULL) || (ExternalID != NULL)) {
  ------------------
  |  Branch (8490:9): [True: 268, False: 492]
  |  Branch (8490:26): [True: 0, False: 492]
  ------------------
 8491|    268|        ctxt->hasExternalSubset = 1;
 8492|    268|    }
 8493|    760|    ctxt->extSubURI = URI;
 8494|    760|    ctxt->extSubSystem = ExternalID;
 8495|       |
 8496|    760|    SKIP_BLANKS;
  ------------------
  |  | 2273|    760|#define SKIP_BLANKS xmlSkipBlankChars(ctxt)
  ------------------
 8497|       |
 8498|       |    /*
 8499|       |     * Create and update the internal subset.
 8500|       |     */
 8501|    760|    if ((ctxt->sax != NULL) && (ctxt->sax->internalSubset != NULL) &&
  ------------------
  |  Branch (8501:9): [True: 760, False: 0]
  |  Branch (8501:32): [True: 760, False: 0]
  ------------------
 8502|    760|	(!ctxt->disableSAX))
  ------------------
  |  Branch (8502:2): [True: 760, False: 0]
  ------------------
 8503|    760|	ctxt->sax->internalSubset(ctxt->userData, name, ExternalID, URI);
 8504|    760|    if (ctxt->instate == XML_PARSER_EOF)
  ------------------
  |  Branch (8504:9): [True: 0, False: 760]
  ------------------
 8505|      0|	return;
 8506|       |
 8507|       |    /*
 8508|       |     * Is there any internal subset declarations ?
 8509|       |     * they are handled separately in xmlParseInternalSubset()
 8510|       |     */
 8511|    760|    if (RAW == '[')
  ------------------
  |  | 2221|    760|#define RAW (*ctxt->input->cur)
  ------------------
  |  Branch (8511:9): [True: 544, False: 216]
  ------------------
 8512|    544|	return;
 8513|       |
 8514|       |    /*
 8515|       |     * We should be at the end of the DOCTYPE declaration.
 8516|       |     */
 8517|    216|    if (RAW != '>') {
  ------------------
  |  | 2221|    216|#define RAW (*ctxt->input->cur)
  ------------------
  |  Branch (8517:9): [True: 0, False: 216]
  ------------------
 8518|      0|	xmlFatalErr(ctxt, XML_ERR_DOCTYPE_NOT_FINISHED, NULL);
 8519|      0|    }
 8520|    216|    NEXT;
  ------------------
  |  | 2275|    216|#define NEXT xmlNextChar(ctxt)
  ------------------
 8521|    216|}
xmlParseCDSect:
10109|     72|xmlParseCDSect(xmlParserCtxtPtr ctxt) {
10110|     72|    xmlChar *buf = NULL;
10111|     72|    int len = 0;
10112|     72|    int size = XML_PARSER_BUFFER_SIZE;
  ------------------
  |  |  167|     72|#define XML_PARSER_BUFFER_SIZE 100
  ------------------
10113|     72|    int r, rl;
10114|     72|    int	s, sl;
10115|     72|    int cur, l;
10116|     72|    int maxLength = (ctxt->options & XML_PARSE_HUGE) ?
  ------------------
  |  Branch (10116:21): [True: 0, False: 72]
  ------------------
10117|      0|                    XML_MAX_HUGE_LENGTH :
  ------------------
  |  |   49|      0|#define XML_MAX_HUGE_LENGTH 1000000000
  ------------------
10118|     72|                    XML_MAX_TEXT_LENGTH;
  ------------------
  |  |   42|     72|#define XML_MAX_TEXT_LENGTH 10000000
  ------------------
10119|       |
10120|     72|    if ((CUR != '<') || (NXT(1) != '!') || (NXT(2) != '['))
  ------------------
  |  | 2222|     72|#define CUR (*ctxt->input->cur)
  ------------------
                  if ((CUR != '<') || (NXT(1) != '!') || (NXT(2) != '['))
  ------------------
  |  | 2223|     72|#define NXT(val) ctxt->input->cur[(val)]
  ------------------
                  if ((CUR != '<') || (NXT(1) != '!') || (NXT(2) != '['))
  ------------------
  |  | 2223|     72|#define NXT(val) ctxt->input->cur[(val)]
  ------------------
  |  Branch (10120:9): [True: 0, False: 72]
  |  Branch (10120:25): [True: 0, False: 72]
  |  Branch (10120:44): [True: 0, False: 72]
  ------------------
10121|      0|        return;
10122|     72|    SKIP(3);
  ------------------
  |  | 2245|     72|#define SKIP(val) do {							\
  |  | 2246|     72|    ctxt->input->cur += (val),ctxt->input->col+=(val);			\
  |  | 2247|     72|    if (*ctxt->input->cur == 0)						\
  |  |  ------------------
  |  |  |  Branch (2247:9): [True: 0, False: 72]
  |  |  ------------------
  |  | 2248|     72|        xmlParserGrow(ctxt);						\
  |  | 2249|     72|  } while (0)
  |  |  ------------------
  |  |  |  Branch (2249:12): [Folded - Ignored]
  |  |  ------------------
  ------------------
10123|       |
10124|     72|    if (!CMP6(CUR_PTR, 'C', 'D', 'A', 'T', 'A', '['))
  ------------------
  |  | 2233|     72|  ( CMP5( s, c1, c2, c3, c4, c5 ) && ((unsigned char *) s)[ 5 ] == c6 )
  |  |  ------------------
  |  |  |  | 2231|    144|  ( CMP4( s, c1, c2, c3, c4 ) && ((unsigned char *) s)[ 4 ] == c5 )
  |  |  |  |  ------------------
  |  |  |  |  |  | 2228|    144|  ( ((unsigned char *) s)[ 0 ] == c1 && ((unsigned char *) s)[ 1 ] == c2 && \
  |  |  |  |  |  |  ------------------
  |  |  |  |  |  |  |  Branch (2228:5): [True: 72, False: 0]
  |  |  |  |  |  |  |  Branch (2228:41): [True: 72, False: 0]
  |  |  |  |  |  |  ------------------
  |  |  |  |  |  | 2229|     72|    ((unsigned char *) s)[ 2 ] == c3 && ((unsigned char *) s)[ 3 ] == c4 )
  |  |  |  |  |  |  ------------------
  |  |  |  |  |  |  |  Branch (2229:5): [True: 72, False: 0]
  |  |  |  |  |  |  |  Branch (2229:41): [True: 72, False: 0]
  |  |  |  |  |  |  ------------------
  |  |  |  |  ------------------
  |  |  |  |  |  Branch (2231:34): [True: 72, False: 0]
  |  |  |  |  ------------------
  |  |  ------------------
  |  |  |  Branch (2233:38): [True: 72, False: 0]
  |  |  ------------------
  ------------------
10125|      0|        return;
10126|     72|    SKIP(6);
  ------------------
  |  | 2245|     72|#define SKIP(val) do {							\
  |  | 2246|     72|    ctxt->input->cur += (val),ctxt->input->col+=(val);			\
  |  | 2247|     72|    if (*ctxt->input->cur == 0)						\
  |  |  ------------------
  |  |  |  Branch (2247:9): [True: 0, False: 72]
  |  |  ------------------
  |  | 2248|     72|        xmlParserGrow(ctxt);						\
  |  | 2249|     72|  } while (0)
  |  |  ------------------
  |  |  |  Branch (2249:12): [Folded - Ignored]
  |  |  ------------------
  ------------------
10127|       |
10128|     72|    ctxt->instate = XML_PARSER_CDATA_SECTION;
10129|     72|    r = CUR_CHAR(rl);
  ------------------
  |  | 2291|     72|#define CUR_CHAR(l) xmlCurrentChar(ctxt, &l)
  ------------------
10130|     72|    if (!IS_CHAR(r)) {
  ------------------
  |  |  125|     72|#define IS_CHAR(c)   xmlIsCharQ(c)
  |  |  ------------------
  |  |  |  |  118|     72|#define xmlIsCharQ(c)		(((c) < 0x100) ? \
  |  |  |  |  ------------------
  |  |  |  |  |  Branch (118:25): [True: 66, False: 6]
  |  |  |  |  ------------------
  |  |  |  |  119|     72|				 xmlIsChar_ch((c)) :\
  |  |  |  |  ------------------
  |  |  |  |  |  |  108|     66|#define xmlIsChar_ch(c)		(((0x9 <= (c)) && ((c) <= 0xa)) || \
  |  |  |  |  |  |  ------------------
  |  |  |  |  |  |  |  Branch (108:28): [True: 66, False: 0]
  |  |  |  |  |  |  |  Branch (108:44): [True: 8, False: 58]
  |  |  |  |  |  |  ------------------
  |  |  |  |  |  |  109|     66|				 ((c) == 0xd) || \
  |  |  |  |  |  |  ------------------
  |  |  |  |  |  |  |  Branch (109:6): [True: 0, False: 58]
  |  |  |  |  |  |  ------------------
  |  |  |  |  |  |  110|     66|				  (0x20 <= (c)))
  |  |  |  |  |  |  ------------------
  |  |  |  |  |  |  |  Branch (110:7): [True: 58, False: 0]
  |  |  |  |  |  |  ------------------
  |  |  |  |  ------------------
  |  |  |  |  120|     72|				(((0x100 <= (c)) && ((c) <= 0xd7ff)) || \
  |  |  |  |  ------------------
  |  |  |  |  |  Branch (120:7): [True: 6, False: 0]
  |  |  |  |  |  Branch (120:25): [True: 4, False: 2]
  |  |  |  |  ------------------
  |  |  |  |  121|      6|				 ((0xe000 <= (c)) && ((c) <= 0xfffd)) || \
  |  |  |  |  ------------------
  |  |  |  |  |  Branch (121:7): [True: 2, False: 0]
  |  |  |  |  |  Branch (121:26): [True: 0, False: 2]
  |  |  |  |  ------------------
  |  |  |  |  122|      6|				 ((0x10000 <= (c)) && ((c) <= 0x10ffff))))
  |  |  |  |  ------------------
  |  |  |  |  |  Branch (122:7): [True: 2, False: 0]
  |  |  |  |  |  Branch (122:27): [True: 2, False: 0]
  |  |  |  |  ------------------
  |  |  ------------------
  ------------------
  |  Branch (10130:9): [True: 0, False: 72]
  ------------------
10131|      0|	xmlFatalErr(ctxt, XML_ERR_CDATA_NOT_FINISHED, NULL);
10132|      0|        goto out;
10133|      0|    }
10134|     72|    NEXTL(rl);
  ------------------
  |  | 2284|     72|#define NEXTL(l) do {							\
  |  | 2285|     72|    if (*(ctxt->input->cur) == '\n') {					\
  |  |  ------------------
  |  |  |  Branch (2285:9): [True: 4, False: 68]
  |  |  ------------------
  |  | 2286|      4|	ctxt->input->line++; ctxt->input->col = 1;			\
  |  | 2287|     68|    } else ctxt->input->col++;						\
  |  | 2288|     72|    ctxt->input->cur += l;				\
  |  | 2289|     72|  } while (0)
  |  |  ------------------
  |  |  |  Branch (2289:12): [Folded - Ignored]
  |  |  ------------------
  ------------------
10135|     72|    s = CUR_CHAR(sl);
  ------------------
  |  | 2291|     72|#define CUR_CHAR(l) xmlCurrentChar(ctxt, &l)
  ------------------
10136|     72|    if (!IS_CHAR(s)) {
  ------------------
  |  |  125|     72|#define IS_CHAR(c)   xmlIsCharQ(c)
  |  |  ------------------
  |  |  |  |  118|     72|#define xmlIsCharQ(c)		(((c) < 0x100) ? \
  |  |  |  |  ------------------
  |  |  |  |  |  Branch (118:25): [True: 58, False: 14]
  |  |  |  |  ------------------
  |  |  |  |  119|     72|				 xmlIsChar_ch((c)) :\
  |  |  |  |  ------------------
  |  |  |  |  |  |  108|     58|#define xmlIsChar_ch(c)		(((0x9 <= (c)) && ((c) <= 0xa)) || \
  |  |  |  |  |  |  ------------------
  |  |  |  |  |  |  |  Branch (108:28): [True: 58, False: 0]
  |  |  |  |  |  |  |  Branch (108:44): [True: 0, False: 58]
  |  |  |  |  |  |  ------------------
  |  |  |  |  |  |  109|     58|				 ((c) == 0xd) || \
  |  |  |  |  |  |  ------------------
  |  |  |  |  |  |  |  Branch (109:6): [True: 0, False: 58]
  |  |  |  |  |  |  ------------------
  |  |  |  |  |  |  110|     58|				  (0x20 <= (c)))
  |  |  |  |  |  |  ------------------
  |  |  |  |  |  |  |  Branch (110:7): [True: 58, False: 0]
  |  |  |  |  |  |  ------------------
  |  |  |  |  ------------------
  |  |  |  |  120|     72|				(((0x100 <= (c)) && ((c) <= 0xd7ff)) || \
  |  |  |  |  ------------------
  |  |  |  |  |  Branch (120:7): [True: 14, False: 0]
  |  |  |  |  |  Branch (120:25): [True: 8, False: 6]
  |  |  |  |  ------------------
  |  |  |  |  121|     14|				 ((0xe000 <= (c)) && ((c) <= 0xfffd)) || \
  |  |  |  |  ------------------
  |  |  |  |  |  Branch (121:7): [True: 6, False: 0]
  |  |  |  |  |  Branch (121:26): [True: 2, False: 4]
  |  |  |  |  ------------------
  |  |  |  |  122|     14|				 ((0x10000 <= (c)) && ((c) <= 0x10ffff))))
  |  |  |  |  ------------------
  |  |  |  |  |  Branch (122:7): [True: 4, False: 0]
  |  |  |  |  |  Branch (122:27): [True: 4, False: 0]
  |  |  |  |  ------------------
  |  |  ------------------
  ------------------
  |  Branch (10136:9): [True: 0, False: 72]
  ------------------
10137|      0|	xmlFatalErr(ctxt, XML_ERR_CDATA_NOT_FINISHED, NULL);
10138|      0|        goto out;
10139|      0|    }
10140|     72|    NEXTL(sl);
  ------------------
  |  | 2284|     72|#define NEXTL(l) do {							\
  |  | 2285|     72|    if (*(ctxt->input->cur) == '\n') {					\
  |  |  ------------------
  |  |  |  Branch (2285:9): [True: 0, False: 72]
  |  |  ------------------
  |  | 2286|      0|	ctxt->input->line++; ctxt->input->col = 1;			\
  |  | 2287|     72|    } else ctxt->input->col++;						\
  |  | 2288|     72|    ctxt->input->cur += l;				\
  |  | 2289|     72|  } while (0)
  |  |  ------------------
  |  |  |  Branch (2289:12): [Folded - Ignored]
  |  |  ------------------
  ------------------
10141|     72|    cur = CUR_CHAR(l);
  ------------------
  |  | 2291|     72|#define CUR_CHAR(l) xmlCurrentChar(ctxt, &l)
  ------------------
10142|     72|    buf = (xmlChar *) xmlMallocAtomic(size);
10143|     72|    if (buf == NULL) {
  ------------------
  |  Branch (10143:9): [True: 0, False: 72]
  ------------------
10144|      0|	xmlErrMemory(ctxt, NULL);
10145|      0|        goto out;
10146|      0|    }
10147|  12.0k|    while (IS_CHAR(cur) &&
  ------------------
  |  |  125|  12.0k|#define IS_CHAR(c)   xmlIsCharQ(c)
  |  |  ------------------
  |  |  |  |  118|  24.1k|#define xmlIsCharQ(c)		(((c) < 0x100) ? \
  |  |  |  |  ------------------
  |  |  |  |  |  Branch (118:24): [True: 12.0k, False: 0]
  |  |  |  |  |  Branch (118:25): [True: 4.91k, False: 7.18k]
  |  |  |  |  ------------------
  |  |  |  |  119|  24.1k|				 xmlIsChar_ch((c)) :\
  |  |  |  |  ------------------
  |  |  |  |  |  |  108|  4.91k|#define xmlIsChar_ch(c)		(((0x9 <= (c)) && ((c) <= 0xa)) || \
  |  |  |  |  |  |  ------------------
  |  |  |  |  |  |  |  Branch (108:28): [True: 4.91k, False: 0]
  |  |  |  |  |  |  |  Branch (108:44): [True: 116, False: 4.79k]
  |  |  |  |  |  |  ------------------
  |  |  |  |  |  |  109|  4.91k|				 ((c) == 0xd) || \
  |  |  |  |  |  |  ------------------
  |  |  |  |  |  |  |  Branch (109:6): [True: 0, False: 4.79k]
  |  |  |  |  |  |  ------------------
  |  |  |  |  |  |  110|  4.91k|				  (0x20 <= (c)))
  |  |  |  |  |  |  ------------------
  |  |  |  |  |  |  |  Branch (110:7): [True: 4.79k, False: 0]
  |  |  |  |  |  |  ------------------
  |  |  |  |  ------------------
  |  |  |  |  120|  24.1k|				(((0x100 <= (c)) && ((c) <= 0xd7ff)) || \
  |  |  |  |  ------------------
  |  |  |  |  |  Branch (120:7): [True: 7.18k, False: 0]
  |  |  |  |  |  Branch (120:25): [True: 4.78k, False: 2.39k]
  |  |  |  |  ------------------
  |  |  |  |  121|  7.18k|				 ((0xe000 <= (c)) && ((c) <= 0xfffd)) || \
  |  |  |  |  ------------------
  |  |  |  |  |  Branch (121:7): [True: 2.39k, False: 0]
  |  |  |  |  |  Branch (121:26): [True: 2, False: 2.39k]
  |  |  |  |  ------------------
  |  |  |  |  122|  7.18k|				 ((0x10000 <= (c)) && ((c) <= 0x10ffff))))
  |  |  |  |  ------------------
  |  |  |  |  |  Branch (122:7): [True: 2.39k, False: 0]
  |  |  |  |  |  Branch (122:27): [True: 2.39k, False: 0]
  |  |  |  |  ------------------
  |  |  ------------------
  ------------------
10148|  12.0k|           ((r != ']') || (s != ']') || (cur != '>'))) {
  ------------------
  |  Branch (10148:13): [True: 12.0k, False: 78]
  |  Branch (10148:27): [True: 4, False: 74]
  |  Branch (10148:41): [True: 2, False: 72]
  ------------------
10149|  12.0k|	if (len + 5 >= size) {
  ------------------
  |  Branch (10149:6): [True: 98, False: 11.9k]
  ------------------
10150|     98|	    xmlChar *tmp;
10151|       |
10152|     98|	    tmp = (xmlChar *) xmlRealloc(buf, size * 2);
10153|     98|	    if (tmp == NULL) {
  ------------------
  |  Branch (10153:10): [True: 0, False: 98]
  ------------------
10154|      0|		xmlErrMemory(ctxt, NULL);
10155|      0|                goto out;
10156|      0|	    }
10157|     98|	    buf = tmp;
10158|     98|	    size *= 2;
10159|     98|	}
10160|  12.0k|	COPY_BUF(buf, len, r);
  ------------------
  |  | 2295|  12.0k|    if (v < 0x80) b[i++] = v;						\
  |  |  ------------------
  |  |  |  Branch (2295:9): [True: 4.81k, False: 7.20k]
  |  |  ------------------
  |  | 2296|  12.0k|    else i += xmlCopyCharMultiByte(&b[i],v)
  ------------------
10161|  12.0k|        if (len > maxLength) {
  ------------------
  |  Branch (10161:13): [True: 0, False: 12.0k]
  ------------------
10162|      0|            xmlFatalErrMsg(ctxt, XML_ERR_CDATA_NOT_FINISHED,
10163|      0|                           "CData section too big found\n");
10164|      0|            goto out;
10165|      0|        }
10166|  12.0k|	r = s;
10167|  12.0k|	rl = sl;
10168|  12.0k|	s = cur;
10169|  12.0k|	sl = l;
10170|  12.0k|	NEXTL(l);
  ------------------
  |  | 2284|  12.0k|#define NEXTL(l) do {							\
  |  | 2285|  12.0k|    if (*(ctxt->input->cur) == '\n') {					\
  |  |  ------------------
  |  |  |  Branch (2285:9): [True: 112, False: 11.9k]
  |  |  ------------------
  |  | 2286|    112|	ctxt->input->line++; ctxt->input->col = 1;			\
  |  | 2287|  11.9k|    } else ctxt->input->col++;						\
  |  | 2288|  12.0k|    ctxt->input->cur += l;				\
  |  | 2289|  12.0k|  } while (0)
  |  |  ------------------
  |  |  |  Branch (2289:12): [Folded - Ignored]
  |  |  ------------------
  ------------------
10171|  12.0k|	cur = CUR_CHAR(l);
  ------------------
  |  | 2291|  12.0k|#define CUR_CHAR(l) xmlCurrentChar(ctxt, &l)
  ------------------
10172|  12.0k|    }
10173|     72|    buf[len] = 0;
10174|     72|    if (ctxt->instate == XML_PARSER_EOF) {
  ------------------
  |  Branch (10174:9): [True: 0, False: 72]
  ------------------
10175|      0|        xmlFree(buf);
10176|      0|        return;
10177|      0|    }
10178|     72|    if (cur != '>') {
  ------------------
  |  Branch (10178:9): [True: 0, False: 72]
  ------------------
10179|      0|	xmlFatalErrMsgStr(ctxt, XML_ERR_CDATA_NOT_FINISHED,
10180|      0|	                     "CData section not finished\n%.50s\n", buf);
10181|      0|        goto out;
10182|      0|    }
10183|     72|    NEXTL(l);
  ------------------
  |  | 2284|     72|#define NEXTL(l) do {							\
  |  | 2285|     72|    if (*(ctxt->input->cur) == '\n') {					\
  |  |  ------------------
  |  |  |  Branch (2285:9): [True: 0, False: 72]
  |  |  ------------------
  |  | 2286|      0|	ctxt->input->line++; ctxt->input->col = 1;			\
  |  | 2287|     72|    } else ctxt->input->col++;						\
  |  | 2288|     72|    ctxt->input->cur += l;				\
  |  | 2289|     72|  } while (0)
  |  |  ------------------
  |  |  |  Branch (2289:12): [Folded - Ignored]
  |  |  ------------------
  ------------------
10184|       |
10185|       |    /*
10186|       |     * OK the buffer is to be consumed as cdata.
10187|       |     */
10188|     72|    if ((ctxt->sax != NULL) && (!ctxt->disableSAX)) {
  ------------------
  |  Branch (10188:9): [True: 72, False: 0]
  |  Branch (10188:32): [True: 68, False: 4]
  ------------------
10189|     68|	if (ctxt->sax->cdataBlock != NULL)
  ------------------
  |  Branch (10189:6): [True: 68, False: 0]
  ------------------
10190|     68|	    ctxt->sax->cdataBlock(ctxt->userData, buf, len);
10191|      0|	else if (ctxt->sax->characters != NULL)
  ------------------
  |  Branch (10191:11): [True: 0, False: 0]
  ------------------
10192|      0|	    ctxt->sax->characters(ctxt->userData, buf, len);
10193|     68|    }
10194|       |
10195|     72|out:
10196|     72|    if (ctxt->instate != XML_PARSER_EOF)
  ------------------
  |  Branch (10196:9): [True: 72, False: 0]
  ------------------
10197|     72|        ctxt->instate = XML_PARSER_CONTENT;
10198|     72|    xmlFree(buf);
10199|     72|}
xmlParseContent:
10286|    468|xmlParseContent(xmlParserCtxtPtr ctxt) {
10287|    468|    int nameNr = ctxt->nameNr;
10288|       |
10289|    468|    xmlParseContentInternal(ctxt);
10290|       |
10291|    468|    if ((ctxt->instate != XML_PARSER_EOF) &&
  ------------------
  |  Branch (10291:9): [True: 284, False: 184]
  ------------------
10292|    468|        (ctxt->errNo == XML_ERR_OK) &&
  ------------------
  |  Branch (10292:9): [True: 272, False: 12]
  ------------------
10293|    468|        (ctxt->nameNr > nameNr)) {
  ------------------
  |  Branch (10293:9): [True: 0, False: 272]
  ------------------
10294|      0|        const xmlChar *name = ctxt->nameTab[ctxt->nameNr - 1];
10295|      0|        int line = ctxt->pushTab[ctxt->nameNr - 1].line;
10296|      0|        xmlFatalErrMsgStrIntStr(ctxt, XML_ERR_TAG_NOT_FINISHED,
10297|      0|                "Premature end of data in tag %s line %d\n",
10298|      0|		name, line, NULL);
10299|      0|    }
10300|    468|}
xmlParseElement:
10319|    594|xmlParseElement(xmlParserCtxtPtr ctxt) {
10320|    594|    if (xmlParseElementStart(ctxt) != 0)
  ------------------
  |  Branch (10320:9): [True: 134, False: 460]
  ------------------
10321|    134|        return;
10322|       |
10323|    460|    xmlParseContentInternal(ctxt);
10324|    460|    if (ctxt->instate == XML_PARSER_EOF)
  ------------------
  |  Branch (10324:9): [True: 10, False: 450]
  ------------------
10325|     10|	return;
10326|       |
10327|    450|    if (ctxt->input->cur >= ctxt->input->end) {
  ------------------
  |  Branch (10327:9): [True: 10, False: 440]
  ------------------
10328|     10|        if (ctxt->errNo == XML_ERR_OK) {
  ------------------
  |  Branch (10328:13): [True: 2, False: 8]
  ------------------
10329|      2|            const xmlChar *name = ctxt->nameTab[ctxt->nameNr - 1];
10330|      2|            int line = ctxt->pushTab[ctxt->nameNr - 1].line;
10331|      2|            xmlFatalErrMsgStrIntStr(ctxt, XML_ERR_TAG_NOT_FINISHED,
10332|      2|                    "Premature end of data in tag %s line %d\n",
10333|      2|                    name, line, NULL);
10334|      2|        }
10335|     10|        return;
10336|     10|    }
10337|       |
10338|    440|    xmlParseElementEnd(ctxt);
10339|    440|}
xmlParseVersionNum:
10526|    676|xmlParseVersionNum(xmlParserCtxtPtr ctxt) {
10527|    676|    xmlChar *buf = NULL;
10528|    676|    int len = 0;
10529|    676|    int size = 10;
10530|    676|    xmlChar cur;
10531|       |
10532|    676|    buf = (xmlChar *) xmlMallocAtomic(size);
10533|    676|    if (buf == NULL) {
  ------------------
  |  Branch (10533:9): [True: 0, False: 676]
  ------------------
10534|      0|	xmlErrMemory(ctxt, NULL);
10535|      0|	return(NULL);
10536|      0|    }
10537|    676|    cur = CUR;
  ------------------
  |  | 2222|    676|#define CUR (*ctxt->input->cur)
  ------------------
10538|    676|    if (!((cur >= '0') && (cur <= '9'))) {
  ------------------
  |  Branch (10538:11): [True: 676, False: 0]
  |  Branch (10538:27): [True: 676, False: 0]
  ------------------
10539|      0|	xmlFree(buf);
10540|      0|	return(NULL);
10541|      0|    }
10542|    676|    buf[len++] = cur;
10543|    676|    NEXT;
  ------------------
  |  | 2275|    676|#define NEXT xmlNextChar(ctxt)
  ------------------
10544|    676|    cur=CUR;
  ------------------
  |  | 2222|    676|#define CUR (*ctxt->input->cur)
  ------------------
10545|    676|    if (cur != '.') {
  ------------------
  |  Branch (10545:9): [True: 0, False: 676]
  ------------------
10546|      0|	xmlFree(buf);
10547|      0|	return(NULL);
10548|      0|    }
10549|    676|    buf[len++] = cur;
10550|    676|    NEXT;
  ------------------
  |  | 2275|    676|#define NEXT xmlNextChar(ctxt)
  ------------------
10551|    676|    cur=CUR;
  ------------------
  |  | 2222|    676|#define CUR (*ctxt->input->cur)
  ------------------
10552|  1.35k|    while ((cur >= '0') && (cur <= '9')) {
  ------------------
  |  Branch (10552:12): [True: 676, False: 676]
  |  Branch (10552:28): [True: 676, False: 0]
  ------------------
10553|    676|	if (len + 1 >= size) {
  ------------------
  |  Branch (10553:6): [True: 0, False: 676]
  ------------------
10554|      0|	    xmlChar *tmp;
10555|       |
10556|      0|	    size *= 2;
10557|      0|	    tmp = (xmlChar *) xmlRealloc(buf, size);
10558|      0|	    if (tmp == NULL) {
  ------------------
  |  Branch (10558:10): [True: 0, False: 0]
  ------------------
10559|      0|	        xmlFree(buf);
10560|      0|		xmlErrMemory(ctxt, NULL);
10561|      0|		return(NULL);
10562|      0|	    }
10563|      0|	    buf = tmp;
10564|      0|	}
10565|    676|	buf[len++] = cur;
10566|    676|	NEXT;
  ------------------
  |  | 2275|    676|#define NEXT xmlNextChar(ctxt)
  ------------------
10567|    676|	cur=CUR;
  ------------------
  |  | 2222|    676|#define CUR (*ctxt->input->cur)
  ------------------
10568|    676|    }
10569|    676|    buf[len] = 0;
10570|    676|    return(buf);
10571|    676|}
xmlParseVersionInfo:
10589|    676|xmlParseVersionInfo(xmlParserCtxtPtr ctxt) {
10590|    676|    xmlChar *version = NULL;
10591|       |
10592|    676|    if (CMP7(CUR_PTR, 'v', 'e', 'r', 's', 'i', 'o', 'n')) {
  ------------------
  |  | 2235|    676|  ( CMP6( s, c1, c2, c3, c4, c5, c6 ) && ((unsigned char *) s)[ 6 ] == c7 )
  |  |  ------------------
  |  |  |  | 2233|  1.35k|  ( CMP5( s, c1, c2, c3, c4, c5 ) && ((unsigned char *) s)[ 5 ] == c6 )
  |  |  |  |  ------------------
  |  |  |  |  |  | 2231|  1.35k|  ( CMP4( s, c1, c2, c3, c4 ) && ((unsigned char *) s)[ 4 ] == c5 )
  |  |  |  |  |  |  ------------------
  |  |  |  |  |  |  |  | 2228|  1.35k|  ( ((unsigned char *) s)[ 0 ] == c1 && ((unsigned char *) s)[ 1 ] == c2 && \
  |  |  |  |  |  |  |  |  ------------------
  |  |  |  |  |  |  |  |  |  Branch (2228:5): [True: 676, False: 0]
  |  |  |  |  |  |  |  |  |  Branch (2228:41): [True: 676, False: 0]
  |  |  |  |  |  |  |  |  ------------------
  |  |  |  |  |  |  |  | 2229|    676|    ((unsigned char *) s)[ 2 ] == c3 && ((unsigned char *) s)[ 3 ] == c4 )
  |  |  |  |  |  |  |  |  ------------------
  |  |  |  |  |  |  |  |  |  Branch (2229:5): [True: 676, False: 0]
  |  |  |  |  |  |  |  |  |  Branch (2229:41): [True: 676, False: 0]
  |  |  |  |  |  |  |  |  ------------------
  |  |  |  |  |  |  ------------------
  |  |  |  |  |  |  |  Branch (2231:34): [True: 676, False: 0]
  |  |  |  |  |  |  ------------------
  |  |  |  |  ------------------
  |  |  |  |  |  Branch (2233:38): [True: 676, False: 0]
  |  |  |  |  ------------------
  |  |  ------------------
  |  |  |  Branch (2235:42): [True: 676, False: 0]
  |  |  ------------------
  ------------------
10593|    676|	SKIP(7);
  ------------------
  |  | 2245|    676|#define SKIP(val) do {							\
  |  | 2246|    676|    ctxt->input->cur += (val),ctxt->input->col+=(val);			\
  |  | 2247|    676|    if (*ctxt->input->cur == 0)						\
  |  |  ------------------
  |  |  |  Branch (2247:9): [True: 0, False: 676]
  |  |  ------------------
  |  | 2248|    676|        xmlParserGrow(ctxt);						\
  |  | 2249|    676|  } while (0)
  |  |  ------------------
  |  |  |  Branch (2249:12): [Folded - Ignored]
  |  |  ------------------
  ------------------
10594|    676|	SKIP_BLANKS;
  ------------------
  |  | 2273|    676|#define SKIP_BLANKS xmlSkipBlankChars(ctxt)
  ------------------
10595|    676|	if (RAW != '=') {
  ------------------
  |  | 2221|    676|#define RAW (*ctxt->input->cur)
  ------------------
  |  Branch (10595:6): [True: 0, False: 676]
  ------------------
10596|      0|	    xmlFatalErr(ctxt, XML_ERR_EQUAL_REQUIRED, NULL);
10597|      0|	    return(NULL);
10598|      0|        }
10599|    676|	NEXT;
  ------------------
  |  | 2275|    676|#define NEXT xmlNextChar(ctxt)
  ------------------
10600|    676|	SKIP_BLANKS;
  ------------------
  |  | 2273|    676|#define SKIP_BLANKS xmlSkipBlankChars(ctxt)
  ------------------
10601|    676|	if (RAW == '"') {
  ------------------
  |  | 2221|    676|#define RAW (*ctxt->input->cur)
  ------------------
  |  Branch (10601:6): [True: 624, False: 52]
  ------------------
10602|    624|	    NEXT;
  ------------------
  |  | 2275|    624|#define NEXT xmlNextChar(ctxt)
  ------------------
10603|    624|	    version = xmlParseVersionNum(ctxt);
10604|    624|	    if (RAW != '"') {
  ------------------
  |  | 2221|    624|#define RAW (*ctxt->input->cur)
  ------------------
  |  Branch (10604:10): [True: 0, False: 624]
  ------------------
10605|      0|		xmlFatalErr(ctxt, XML_ERR_STRING_NOT_CLOSED, NULL);
10606|      0|	    } else
10607|    624|	        NEXT;
  ------------------
  |  | 2275|    624|#define NEXT xmlNextChar(ctxt)
  ------------------
10608|    624|	} else if (RAW == '\''){
  ------------------
  |  | 2221|     52|#define RAW (*ctxt->input->cur)
  ------------------
  |  Branch (10608:13): [True: 52, False: 0]
  ------------------
10609|     52|	    NEXT;
  ------------------
  |  | 2275|     52|#define NEXT xmlNextChar(ctxt)
  ------------------
10610|     52|	    version = xmlParseVersionNum(ctxt);
10611|     52|	    if (RAW != '\'') {
  ------------------
  |  | 2221|     52|#define RAW (*ctxt->input->cur)
  ------------------
  |  Branch (10611:10): [True: 0, False: 52]
  ------------------
10612|      0|		xmlFatalErr(ctxt, XML_ERR_STRING_NOT_CLOSED, NULL);
10613|      0|	    } else
10614|     52|	        NEXT;
  ------------------
  |  | 2275|     52|#define NEXT xmlNextChar(ctxt)
  ------------------
10615|     52|	} else {
10616|      0|	    xmlFatalErr(ctxt, XML_ERR_STRING_NOT_STARTED, NULL);
10617|      0|	}
10618|    676|    }
10619|    676|    return(version);
10620|    676|}
xmlParseEncName:
10635|    156|xmlParseEncName(xmlParserCtxtPtr ctxt) {
10636|    156|    xmlChar *buf = NULL;
10637|    156|    int len = 0;
10638|    156|    int size = 10;
10639|    156|    int maxLength = (ctxt->options & XML_PARSE_HUGE) ?
  ------------------
  |  Branch (10639:21): [True: 0, False: 156]
  ------------------
10640|      0|                    XML_MAX_TEXT_LENGTH :
  ------------------
  |  |   42|      0|#define XML_MAX_TEXT_LENGTH 10000000
  ------------------
10641|    156|                    XML_MAX_NAME_LENGTH;
  ------------------
  |  |   61|    156|#define XML_MAX_NAME_LENGTH 50000
  ------------------
10642|    156|    xmlChar cur;
10643|       |
10644|    156|    cur = CUR;
  ------------------
  |  | 2222|    156|#define CUR (*ctxt->input->cur)
  ------------------
10645|    156|    if (((cur >= 'a') && (cur <= 'z')) ||
  ------------------
  |  Branch (10645:10): [True: 36, False: 120]
  |  Branch (10645:26): [True: 36, False: 0]
  ------------------
10646|    156|        ((cur >= 'A') && (cur <= 'Z'))) {
  ------------------
  |  Branch (10646:10): [True: 120, False: 0]
  |  Branch (10646:26): [True: 120, False: 0]
  ------------------
10647|    156|	buf = (xmlChar *) xmlMallocAtomic(size);
10648|    156|	if (buf == NULL) {
  ------------------
  |  Branch (10648:6): [True: 0, False: 156]
  ------------------
10649|      0|	    xmlErrMemory(ctxt, NULL);
10650|      0|	    return(NULL);
10651|      0|	}
10652|       |
10653|    156|	buf[len++] = cur;
10654|    156|	NEXT;
  ------------------
  |  | 2275|    156|#define NEXT xmlNextChar(ctxt)
  ------------------
10655|    156|	cur = CUR;
  ------------------
  |  | 2222|    156|#define CUR (*ctxt->input->cur)
  ------------------
10656|  1.10k|	while (((cur >= 'a') && (cur <= 'z')) ||
  ------------------
  |  Branch (10656:10): [True: 72, False: 1.03k]
  |  Branch (10656:26): [True: 72, False: 0]
  ------------------
10657|  1.10k|	       ((cur >= 'A') && (cur <= 'Z')) ||
  ------------------
  |  Branch (10657:10): [True: 264, False: 772]
  |  Branch (10657:26): [True: 264, False: 0]
  ------------------
10658|  1.10k|	       ((cur >= '0') && (cur <= '9')) ||
  ------------------
  |  Branch (10658:10): [True: 400, False: 372]
  |  Branch (10658:26): [True: 400, False: 0]
  ------------------
10659|  1.10k|	       (cur == '.') || (cur == '_') ||
  ------------------
  |  Branch (10659:9): [True: 0, False: 372]
  |  Branch (10659:25): [True: 0, False: 372]
  ------------------
10660|  1.10k|	       (cur == '-')) {
  ------------------
  |  Branch (10660:9): [True: 216, False: 156]
  ------------------
10661|    952|	    if (len + 1 >= size) {
  ------------------
  |  Branch (10661:10): [True: 60, False: 892]
  ------------------
10662|     60|	        xmlChar *tmp;
10663|       |
10664|     60|		size *= 2;
10665|     60|		tmp = (xmlChar *) xmlRealloc(buf, size);
10666|     60|		if (tmp == NULL) {
  ------------------
  |  Branch (10666:7): [True: 0, False: 60]
  ------------------
10667|      0|		    xmlErrMemory(ctxt, NULL);
10668|      0|		    xmlFree(buf);
10669|      0|		    return(NULL);
10670|      0|		}
10671|     60|		buf = tmp;
10672|     60|	    }
10673|    952|	    buf[len++] = cur;
10674|    952|            if (len > maxLength) {
  ------------------
  |  Branch (10674:17): [True: 0, False: 952]
  ------------------
10675|      0|                xmlFatalErr(ctxt, XML_ERR_NAME_TOO_LONG, "EncName");
10676|      0|                xmlFree(buf);
10677|      0|                return(NULL);
10678|      0|            }
10679|    952|	    NEXT;
  ------------------
  |  | 2275|    952|#define NEXT xmlNextChar(ctxt)
  ------------------
10680|    952|	    cur = CUR;
  ------------------
  |  | 2222|    952|#define CUR (*ctxt->input->cur)
  ------------------
10681|    952|        }
10682|    156|	buf[len] = 0;
10683|    156|    } else {
10684|      0|	xmlFatalErr(ctxt, XML_ERR_ENCODING_NAME, NULL);
10685|      0|    }
10686|    156|    return(buf);
10687|    156|}
xmlParseEncodingDecl:
10705|    360|xmlParseEncodingDecl(xmlParserCtxtPtr ctxt) {
10706|    360|    xmlChar *encoding = NULL;
10707|       |
10708|    360|    SKIP_BLANKS;
  ------------------
  |  | 2273|    360|#define SKIP_BLANKS xmlSkipBlankChars(ctxt)
  ------------------
10709|    360|    if (CMP8(CUR_PTR, 'e', 'n', 'c', 'o', 'd', 'i', 'n', 'g') == 0)
  ------------------
  |  | 2237|    360|  ( CMP7( s, c1, c2, c3, c4, c5, c6, c7 ) && ((unsigned char *) s)[ 7 ] == c8 )
  |  |  ------------------
  |  |  |  | 2235|    720|  ( CMP6( s, c1, c2, c3, c4, c5, c6 ) && ((unsigned char *) s)[ 6 ] == c7 )
  |  |  |  |  ------------------
  |  |  |  |  |  | 2233|    720|  ( CMP5( s, c1, c2, c3, c4, c5 ) && ((unsigned char *) s)[ 5 ] == c6 )
  |  |  |  |  |  |  ------------------
  |  |  |  |  |  |  |  | 2231|    720|  ( CMP4( s, c1, c2, c3, c4 ) && ((unsigned char *) s)[ 4 ] == c5 )
  |  |  |  |  |  |  |  |  ------------------
  |  |  |  |  |  |  |  |  |  | 2228|    720|  ( ((unsigned char *) s)[ 0 ] == c1 && ((unsigned char *) s)[ 1 ] == c2 && \
  |  |  |  |  |  |  |  |  |  |  ------------------
  |  |  |  |  |  |  |  |  |  |  |  Branch (2228:5): [True: 156, False: 204]
  |  |  |  |  |  |  |  |  |  |  |  Branch (2228:41): [True: 156, False: 0]
  |  |  |  |  |  |  |  |  |  |  ------------------
  |  |  |  |  |  |  |  |  |  | 2229|    360|    ((unsigned char *) s)[ 2 ] == c3 && ((unsigned char *) s)[ 3 ] == c4 )
  |  |  |  |  |  |  |  |  |  |  ------------------
  |  |  |  |  |  |  |  |  |  |  |  Branch (2229:5): [True: 156, False: 0]
  |  |  |  |  |  |  |  |  |  |  |  Branch (2229:41): [True: 156, False: 0]
  |  |  |  |  |  |  |  |  |  |  ------------------
  |  |  |  |  |  |  |  |  ------------------
  |  |  |  |  |  |  |  |  |  Branch (2231:34): [True: 156, False: 0]
  |  |  |  |  |  |  |  |  ------------------
  |  |  |  |  |  |  ------------------
  |  |  |  |  |  |  |  Branch (2233:38): [True: 156, False: 0]
  |  |  |  |  |  |  ------------------
  |  |  |  |  ------------------
  |  |  |  |  |  Branch (2235:42): [True: 156, False: 0]
  |  |  |  |  ------------------
  |  |  ------------------
  |  |  |  Branch (2237:46): [True: 156, False: 0]
  |  |  ------------------
  ------------------
  |  Branch (10709:9): [True: 204, False: 156]
  ------------------
10710|    204|        return(NULL);
10711|       |
10712|    156|    SKIP(8);
  ------------------
  |  | 2245|    156|#define SKIP(val) do {							\
  |  | 2246|    156|    ctxt->input->cur += (val),ctxt->input->col+=(val);			\
  |  | 2247|    156|    if (*ctxt->input->cur == 0)						\
  |  |  ------------------
  |  |  |  Branch (2247:9): [True: 0, False: 156]
  |  |  ------------------
  |  | 2248|    156|        xmlParserGrow(ctxt);						\
  |  | 2249|    156|  } while (0)
  |  |  ------------------
  |  |  |  Branch (2249:12): [Folded - Ignored]
  |  |  ------------------
  ------------------
10713|    156|    SKIP_BLANKS;
  ------------------
  |  | 2273|    156|#define SKIP_BLANKS xmlSkipBlankChars(ctxt)
  ------------------
10714|    156|    if (RAW != '=') {
  ------------------
  |  | 2221|    156|#define RAW (*ctxt->input->cur)
  ------------------
  |  Branch (10714:9): [True: 0, False: 156]
  ------------------
10715|      0|        xmlFatalErr(ctxt, XML_ERR_EQUAL_REQUIRED, NULL);
10716|      0|        return(NULL);
10717|      0|    }
10718|    156|    NEXT;
  ------------------
  |  | 2275|    156|#define NEXT xmlNextChar(ctxt)
  ------------------
10719|    156|    SKIP_BLANKS;
  ------------------
  |  | 2273|    156|#define SKIP_BLANKS xmlSkipBlankChars(ctxt)
  ------------------
10720|    156|    if (RAW == '"') {
  ------------------
  |  | 2221|    156|#define RAW (*ctxt->input->cur)
  ------------------
  |  Branch (10720:9): [True: 144, False: 12]
  ------------------
10721|    144|        NEXT;
  ------------------
  |  | 2275|    144|#define NEXT xmlNextChar(ctxt)
  ------------------
10722|    144|        encoding = xmlParseEncName(ctxt);
10723|    144|        if (RAW != '"') {
  ------------------
  |  | 2221|    144|#define RAW (*ctxt->input->cur)
  ------------------
  |  Branch (10723:13): [True: 0, False: 144]
  ------------------
10724|      0|            xmlFatalErr(ctxt, XML_ERR_STRING_NOT_CLOSED, NULL);
10725|      0|            xmlFree((xmlChar *) encoding);
10726|      0|            return(NULL);
10727|      0|        } else
10728|    144|            NEXT;
  ------------------
  |  | 2275|    144|#define NEXT xmlNextChar(ctxt)
  ------------------
10729|    144|    } else if (RAW == '\''){
  ------------------
  |  | 2221|     12|#define RAW (*ctxt->input->cur)
  ------------------
  |  Branch (10729:16): [True: 12, False: 0]
  ------------------
10730|     12|        NEXT;
  ------------------
  |  | 2275|     12|#define NEXT xmlNextChar(ctxt)
  ------------------
10731|     12|        encoding = xmlParseEncName(ctxt);
10732|     12|        if (RAW != '\'') {
  ------------------
  |  | 2221|     12|#define RAW (*ctxt->input->cur)
  ------------------
  |  Branch (10732:13): [True: 0, False: 12]
  ------------------
10733|      0|            xmlFatalErr(ctxt, XML_ERR_STRING_NOT_CLOSED, NULL);
10734|      0|            xmlFree((xmlChar *) encoding);
10735|      0|            return(NULL);
10736|      0|        } else
10737|     12|            NEXT;
  ------------------
  |  | 2275|     12|#define NEXT xmlNextChar(ctxt)
  ------------------
10738|     12|    } else {
10739|      0|        xmlFatalErr(ctxt, XML_ERR_STRING_NOT_STARTED, NULL);
10740|      0|    }
10741|       |
10742|    156|    if (encoding == NULL)
  ------------------
  |  Branch (10742:9): [True: 0, False: 156]
  ------------------
10743|      0|        return(NULL);
10744|       |
10745|    156|    xmlSetDeclaredEncoding(ctxt, encoding);
10746|       |
10747|    156|    return(ctxt->encoding);
10748|    156|}
xmlParseSDDecl:
10784|    228|xmlParseSDDecl(xmlParserCtxtPtr ctxt) {
10785|    228|    int standalone = -2;
10786|       |
10787|    228|    SKIP_BLANKS;
  ------------------
  |  | 2273|    228|#define SKIP_BLANKS xmlSkipBlankChars(ctxt)
  ------------------
10788|    228|    if (CMP10(CUR_PTR, 's', 't', 'a', 'n', 'd', 'a', 'l', 'o', 'n', 'e')) {
  ------------------
  |  | 2242|    228|  ( CMP9( s, c1, c2, c3, c4, c5, c6, c7, c8, c9 ) && \
  |  |  ------------------
  |  |  |  | 2239|    456|  ( CMP8( s, c1, c2, c3, c4, c5, c6, c7, c8 ) && \
  |  |  |  |  ------------------
  |  |  |  |  |  | 2237|    456|  ( CMP7( s, c1, c2, c3, c4, c5, c6, c7 ) && ((unsigned char *) s)[ 7 ] == c8 )
  |  |  |  |  |  |  ------------------
  |  |  |  |  |  |  |  | 2235|    456|  ( CMP6( s, c1, c2, c3, c4, c5, c6 ) && ((unsigned char *) s)[ 6 ] == c7 )
  |  |  |  |  |  |  |  |  ------------------
  |  |  |  |  |  |  |  |  |  | 2233|    456|  ( CMP5( s, c1, c2, c3, c4, c5 ) && ((unsigned char *) s)[ 5 ] == c6 )
  |  |  |  |  |  |  |  |  |  |  ------------------
  |  |  |  |  |  |  |  |  |  |  |  | 2231|    456|  ( CMP4( s, c1, c2, c3, c4 ) && ((unsigned char *) s)[ 4 ] == c5 )
  |  |  |  |  |  |  |  |  |  |  |  |  ------------------
  |  |  |  |  |  |  |  |  |  |  |  |  |  | 2228|    456|  ( ((unsigned char *) s)[ 0 ] == c1 && ((unsigned char *) s)[ 1 ] == c2 && \
  |  |  |  |  |  |  |  |  |  |  |  |  |  |  ------------------
  |  |  |  |  |  |  |  |  |  |  |  |  |  |  |  Branch (2228:5): [True: 200, False: 28]
  |  |  |  |  |  |  |  |  |  |  |  |  |  |  |  Branch (2228:41): [True: 200, False: 0]
  |  |  |  |  |  |  |  |  |  |  |  |  |  |  ------------------
  |  |  |  |  |  |  |  |  |  |  |  |  |  | 2229|    228|    ((unsigned char *) s)[ 2 ] == c3 && ((unsigned char *) s)[ 3 ] == c4 )
  |  |  |  |  |  |  |  |  |  |  |  |  |  |  ------------------
  |  |  |  |  |  |  |  |  |  |  |  |  |  |  |  Branch (2229:5): [True: 200, False: 0]
  |  |  |  |  |  |  |  |  |  |  |  |  |  |  |  Branch (2229:41): [True: 200, False: 0]
  |  |  |  |  |  |  |  |  |  |  |  |  |  |  ------------------
  |  |  |  |  |  |  |  |  |  |  |  |  ------------------
  |  |  |  |  |  |  |  |  |  |  |  |  |  Branch (2231:34): [True: 200, False: 0]
  |  |  |  |  |  |  |  |  |  |  |  |  ------------------
  |  |  |  |  |  |  |  |  |  |  ------------------
  |  |  |  |  |  |  |  |  |  |  |  Branch (2233:38): [True: 200, False: 0]
  |  |  |  |  |  |  |  |  |  |  ------------------
  |  |  |  |  |  |  |  |  ------------------
  |  |  |  |  |  |  |  |  |  Branch (2235:42): [True: 200, False: 0]
  |  |  |  |  |  |  |  |  ------------------
  |  |  |  |  |  |  ------------------
  |  |  |  |  |  |  |  Branch (2237:46): [True: 200, False: 0]
  |  |  |  |  |  |  ------------------
  |  |  |  |  ------------------
  |  |  |  | 2240|    456|    ((unsigned char *) s)[ 8 ] == c9 )
  |  |  |  |  ------------------
  |  |  |  |  |  Branch (2240:5): [True: 200, False: 0]
  |  |  |  |  ------------------
  |  |  ------------------
  |  | 2243|    228|    ((unsigned char *) s)[ 9 ] == c10 )
  |  |  ------------------
  |  |  |  Branch (2243:5): [True: 200, False: 0]
  |  |  ------------------
  ------------------
10789|    200|	SKIP(10);
  ------------------
  |  | 2245|    200|#define SKIP(val) do {							\
  |  | 2246|    200|    ctxt->input->cur += (val),ctxt->input->col+=(val);			\
  |  | 2247|    200|    if (*ctxt->input->cur == 0)						\
  |  |  ------------------
  |  |  |  Branch (2247:9): [True: 0, False: 200]
  |  |  ------------------
  |  | 2248|    200|        xmlParserGrow(ctxt);						\
  |  | 2249|    200|  } while (0)
  |  |  ------------------
  |  |  |  Branch (2249:12): [Folded - Ignored]
  |  |  ------------------
  ------------------
10790|    200|        SKIP_BLANKS;
  ------------------
  |  | 2273|    200|#define SKIP_BLANKS xmlSkipBlankChars(ctxt)
  ------------------
10791|    200|	if (RAW != '=') {
  ------------------
  |  | 2221|    200|#define RAW (*ctxt->input->cur)
  ------------------
  |  Branch (10791:6): [True: 0, False: 200]
  ------------------
10792|      0|	    xmlFatalErr(ctxt, XML_ERR_EQUAL_REQUIRED, NULL);
10793|      0|	    return(standalone);
10794|      0|        }
10795|    200|	NEXT;
  ------------------
  |  | 2275|    200|#define NEXT xmlNextChar(ctxt)
  ------------------
10796|    200|	SKIP_BLANKS;
  ------------------
  |  | 2273|    200|#define SKIP_BLANKS xmlSkipBlankChars(ctxt)
  ------------------
10797|    200|        if (RAW == '\''){
  ------------------
  |  | 2221|    200|#define RAW (*ctxt->input->cur)
  ------------------
  |  Branch (10797:13): [True: 12, False: 188]
  ------------------
10798|     12|	    NEXT;
  ------------------
  |  | 2275|     12|#define NEXT xmlNextChar(ctxt)
  ------------------
10799|     12|	    if ((RAW == 'n') && (NXT(1) == 'o')) {
  ------------------
  |  | 2221|     12|#define RAW (*ctxt->input->cur)
  ------------------
              	    if ((RAW == 'n') && (NXT(1) == 'o')) {
  ------------------
  |  | 2223|      8|#define NXT(val) ctxt->input->cur[(val)]
  ------------------
  |  Branch (10799:10): [True: 8, False: 4]
  |  Branch (10799:26): [True: 8, False: 0]
  ------------------
10800|      8|	        standalone = 0;
10801|      8|                SKIP(2);
  ------------------
  |  | 2245|      8|#define SKIP(val) do {							\
  |  | 2246|      8|    ctxt->input->cur += (val),ctxt->input->col+=(val);			\
  |  | 2247|      8|    if (*ctxt->input->cur == 0)						\
  |  |  ------------------
  |  |  |  Branch (2247:9): [True: 0, False: 8]
  |  |  ------------------
  |  | 2248|      8|        xmlParserGrow(ctxt);						\
  |  | 2249|      8|  } while (0)
  |  |  ------------------
  |  |  |  Branch (2249:12): [Folded - Ignored]
  |  |  ------------------
  ------------------
10802|      8|	    } else if ((RAW == 'y') && (NXT(1) == 'e') &&
  ------------------
  |  | 2221|      4|#define RAW (*ctxt->input->cur)
  ------------------
              	    } else if ((RAW == 'y') && (NXT(1) == 'e') &&
  ------------------
  |  | 2223|      4|#define NXT(val) ctxt->input->cur[(val)]
  ------------------
  |  Branch (10802:17): [True: 4, False: 0]
  |  Branch (10802:33): [True: 4, False: 0]
  ------------------
10803|      4|	               (NXT(2) == 's')) {
  ------------------
  |  | 2223|      4|#define NXT(val) ctxt->input->cur[(val)]
  ------------------
  |  Branch (10803:17): [True: 4, False: 0]
  ------------------
10804|      4|	        standalone = 1;
10805|      4|		SKIP(3);
  ------------------
  |  | 2245|      4|#define SKIP(val) do {							\
  |  | 2246|      4|    ctxt->input->cur += (val),ctxt->input->col+=(val);			\
  |  | 2247|      4|    if (*ctxt->input->cur == 0)						\
  |  |  ------------------
  |  |  |  Branch (2247:9): [True: 0, False: 4]
  |  |  ------------------
  |  | 2248|      4|        xmlParserGrow(ctxt);						\
  |  | 2249|      4|  } while (0)
  |  |  ------------------
  |  |  |  Branch (2249:12): [Folded - Ignored]
  |  |  ------------------
  ------------------
10806|      4|            } else {
10807|      0|		xmlFatalErr(ctxt, XML_ERR_STANDALONE_VALUE, NULL);
10808|      0|	    }
10809|     12|	    if (RAW != '\'') {
  ------------------
  |  | 2221|     12|#define RAW (*ctxt->input->cur)
  ------------------
  |  Branch (10809:10): [True: 0, False: 12]
  ------------------
10810|      0|		xmlFatalErr(ctxt, XML_ERR_STRING_NOT_CLOSED, NULL);
10811|      0|	    } else
10812|     12|	        NEXT;
  ------------------
  |  | 2275|     12|#define NEXT xmlNextChar(ctxt)
  ------------------
10813|    188|	} else if (RAW == '"'){
  ------------------
  |  | 2221|    188|#define RAW (*ctxt->input->cur)
  ------------------
  |  Branch (10813:13): [True: 188, False: 0]
  ------------------
10814|    188|	    NEXT;
  ------------------
  |  | 2275|    188|#define NEXT xmlNextChar(ctxt)
  ------------------
10815|    188|	    if ((RAW == 'n') && (NXT(1) == 'o')) {
  ------------------
  |  | 2221|    188|#define RAW (*ctxt->input->cur)
  ------------------
              	    if ((RAW == 'n') && (NXT(1) == 'o')) {
  ------------------
  |  | 2223|    120|#define NXT(val) ctxt->input->cur[(val)]
  ------------------
  |  Branch (10815:10): [True: 120, False: 68]
  |  Branch (10815:26): [True: 120, False: 0]
  ------------------
10816|    120|	        standalone = 0;
10817|    120|		SKIP(2);
  ------------------
  |  | 2245|    120|#define SKIP(val) do {							\
  |  | 2246|    120|    ctxt->input->cur += (val),ctxt->input->col+=(val);			\
  |  | 2247|    120|    if (*ctxt->input->cur == 0)						\
  |  |  ------------------
  |  |  |  Branch (2247:9): [True: 0, False: 120]
  |  |  ------------------
  |  | 2248|    120|        xmlParserGrow(ctxt);						\
  |  | 2249|    120|  } while (0)
  |  |  ------------------
  |  |  |  Branch (2249:12): [Folded - Ignored]
  |  |  ------------------
  ------------------
10818|    120|	    } else if ((RAW == 'y') && (NXT(1) == 'e') &&
  ------------------
  |  | 2221|     68|#define RAW (*ctxt->input->cur)
  ------------------
              	    } else if ((RAW == 'y') && (NXT(1) == 'e') &&
  ------------------
  |  | 2223|     68|#define NXT(val) ctxt->input->cur[(val)]
  ------------------
  |  Branch (10818:17): [True: 68, False: 0]
  |  Branch (10818:33): [True: 68, False: 0]
  ------------------
10819|     68|	               (NXT(2) == 's')) {
  ------------------
  |  | 2223|     68|#define NXT(val) ctxt->input->cur[(val)]
  ------------------
  |  Branch (10819:17): [True: 68, False: 0]
  ------------------
10820|     68|	        standalone = 1;
10821|     68|                SKIP(3);
  ------------------
  |  | 2245|     68|#define SKIP(val) do {							\
  |  | 2246|     68|    ctxt->input->cur += (val),ctxt->input->col+=(val);			\
  |  | 2247|     68|    if (*ctxt->input->cur == 0)						\
  |  |  ------------------
  |  |  |  Branch (2247:9): [True: 0, False: 68]
  |  |  ------------------
  |  | 2248|     68|        xmlParserGrow(ctxt);						\
  |  | 2249|     68|  } while (0)
  |  |  ------------------
  |  |  |  Branch (2249:12): [Folded - Ignored]
  |  |  ------------------
  ------------------
10822|     68|            } else {
10823|      0|		xmlFatalErr(ctxt, XML_ERR_STANDALONE_VALUE, NULL);
10824|      0|	    }
10825|    188|	    if (RAW != '"') {
  ------------------
  |  | 2221|    188|#define RAW (*ctxt->input->cur)
  ------------------
  |  Branch (10825:10): [True: 0, False: 188]
  ------------------
10826|      0|		xmlFatalErr(ctxt, XML_ERR_STRING_NOT_CLOSED, NULL);
10827|      0|	    } else
10828|    188|	        NEXT;
  ------------------
  |  | 2275|    188|#define NEXT xmlNextChar(ctxt)
  ------------------
10829|    188|	} else {
10830|      0|	    xmlFatalErr(ctxt, XML_ERR_STRING_NOT_STARTED, NULL);
10831|      0|        }
10832|    200|    }
10833|    228|    return(standalone);
10834|    228|}
xmlParseXMLDecl:
10848|    652|xmlParseXMLDecl(xmlParserCtxtPtr ctxt) {
10849|    652|    xmlChar *version;
10850|       |
10851|       |    /*
10852|       |     * This value for standalone indicates that the document has an
10853|       |     * XML declaration but it does not have a standalone attribute.
10854|       |     * It will be overwritten later if a standalone attribute is found.
10855|       |     */
10856|       |
10857|    652|    ctxt->standalone = -2;
10858|       |
10859|       |    /*
10860|       |     * We know that '<?xml' is here.
10861|       |     */
10862|    652|    SKIP(5);
  ------------------
  |  | 2245|    652|#define SKIP(val) do {							\
  |  | 2246|    652|    ctxt->input->cur += (val),ctxt->input->col+=(val);			\
  |  | 2247|    652|    if (*ctxt->input->cur == 0)						\
  |  |  ------------------
  |  |  |  Branch (2247:9): [True: 0, False: 652]
  |  |  ------------------
  |  | 2248|    652|        xmlParserGrow(ctxt);						\
  |  | 2249|    652|  } while (0)
  |  |  ------------------
  |  |  |  Branch (2249:12): [Folded - Ignored]
  |  |  ------------------
  ------------------
10863|       |
10864|    652|    if (!IS_BLANK_CH(RAW)) {
  ------------------
  |  |  151|    652|#define IS_BLANK_CH(c)  xmlIsBlank_ch(c)
  |  |  ------------------
  |  |  |  |   88|    652|#define xmlIsBlank_ch(c)	(((c) == 0x20) || \
  |  |  |  |  ------------------
  |  |  |  |  |  Branch (88:27): [True: 652, False: 0]
  |  |  |  |  ------------------
  |  |  |  |   89|    652|				 ((0x9 <= (c)) && ((c) <= 0xa)) || \
  |  |  |  |  ------------------
  |  |  |  |  |  Branch (89:7): [True: 0, False: 0]
  |  |  |  |  |  Branch (89:23): [True: 0, False: 0]
  |  |  |  |  ------------------
  |  |  |  |   90|    652|				 ((c) == 0xd))
  |  |  |  |  ------------------
  |  |  |  |  |  Branch (90:6): [True: 0, False: 0]
  |  |  |  |  ------------------
  |  |  ------------------
  ------------------
10865|      0|	xmlFatalErrMsg(ctxt, XML_ERR_SPACE_REQUIRED,
10866|      0|	               "Blank needed after '<?xml'\n");
10867|      0|    }
10868|    652|    SKIP_BLANKS;
  ------------------
  |  | 2273|    652|#define SKIP_BLANKS xmlSkipBlankChars(ctxt)
  ------------------
10869|       |
10870|       |    /*
10871|       |     * We must have the VersionInfo here.
10872|       |     */
10873|    652|    version = xmlParseVersionInfo(ctxt);
10874|    652|    if (version == NULL) {
  ------------------
  |  Branch (10874:9): [True: 0, False: 652]
  ------------------
10875|      0|	xmlFatalErr(ctxt, XML_ERR_VERSION_MISSING, NULL);
10876|    652|    } else {
10877|    652|	if (!xmlStrEqual(version, (const xmlChar *) XML_DEFAULT_VERSION)) {
  ------------------
  |  |   37|    652|#define XML_DEFAULT_VERSION	"1.0"
  ------------------
  |  Branch (10877:6): [True: 0, False: 652]
  ------------------
10878|       |	    /*
10879|       |	     * Changed here for XML-1.0 5th edition
10880|       |	     */
10881|      0|	    if (ctxt->options & XML_PARSE_OLD10) {
  ------------------
  |  Branch (10881:10): [True: 0, False: 0]
  ------------------
10882|      0|		xmlFatalErrMsgStr(ctxt, XML_ERR_UNKNOWN_VERSION,
10883|      0|			          "Unsupported version '%s'\n",
10884|      0|			          version);
10885|      0|	    } else {
10886|      0|	        if ((version[0] == '1') && ((version[1] == '.'))) {
  ------------------
  |  Branch (10886:14): [True: 0, False: 0]
  |  Branch (10886:37): [True: 0, False: 0]
  ------------------
10887|      0|		    xmlWarningMsg(ctxt, XML_WAR_UNKNOWN_VERSION,
10888|      0|		                  "Unsupported version '%s'\n",
10889|      0|				  version, NULL);
10890|      0|		} else {
10891|      0|		    xmlFatalErrMsgStr(ctxt, XML_ERR_UNKNOWN_VERSION,
10892|      0|				      "Unsupported version '%s'\n",
10893|      0|				      version);
10894|      0|		}
10895|      0|	    }
10896|      0|	}
10897|    652|	if (ctxt->version != NULL)
  ------------------
  |  Branch (10897:6): [True: 0, False: 652]
  ------------------
10898|      0|	    xmlFree((void *) ctxt->version);
10899|    652|	ctxt->version = version;
10900|    652|    }
10901|       |
10902|       |    /*
10903|       |     * We may have the encoding declaration
10904|       |     */
10905|    652|    if (!IS_BLANK_CH(RAW)) {
  ------------------
  |  |  151|    652|#define IS_BLANK_CH(c)  xmlIsBlank_ch(c)
  |  |  ------------------
  |  |  |  |   88|    652|#define xmlIsBlank_ch(c)	(((c) == 0x20) || \
  |  |  |  |  ------------------
  |  |  |  |  |  Branch (88:27): [True: 336, False: 316]
  |  |  |  |  ------------------
  |  |  |  |   89|    652|				 ((0x9 <= (c)) && ((c) <= 0xa)) || \
  |  |  |  |  ------------------
  |  |  |  |  |  Branch (89:7): [True: 316, False: 0]
  |  |  |  |  |  Branch (89:23): [True: 0, False: 316]
  |  |  |  |  ------------------
  |  |  |  |   90|    652|				 ((c) == 0xd))
  |  |  |  |  ------------------
  |  |  |  |  |  Branch (90:6): [True: 0, False: 316]
  |  |  |  |  ------------------
  |  |  ------------------
  ------------------
10906|    316|        if ((RAW == '?') && (NXT(1) == '>')) {
  ------------------
  |  | 2221|    316|#define RAW (*ctxt->input->cur)
  ------------------
                      if ((RAW == '?') && (NXT(1) == '>')) {
  ------------------
  |  | 2223|    316|#define NXT(val) ctxt->input->cur[(val)]
  ------------------
  |  Branch (10906:13): [True: 316, False: 0]
  |  Branch (10906:29): [True: 316, False: 0]
  ------------------
10907|    316|	    SKIP(2);
  ------------------
  |  | 2245|    316|#define SKIP(val) do {							\
  |  | 2246|    316|    ctxt->input->cur += (val),ctxt->input->col+=(val);			\
  |  | 2247|    316|    if (*ctxt->input->cur == 0)						\
  |  |  ------------------
  |  |  |  Branch (2247:9): [True: 0, False: 316]
  |  |  ------------------
  |  | 2248|    316|        xmlParserGrow(ctxt);						\
  |  | 2249|    316|  } while (0)
  |  |  ------------------
  |  |  |  Branch (2249:12): [Folded - Ignored]
  |  |  ------------------
  ------------------
10908|    316|	    return;
10909|    316|	}
10910|      0|	xmlFatalErrMsg(ctxt, XML_ERR_SPACE_REQUIRED, "Blank needed here\n");
10911|      0|    }
10912|    336|    xmlParseEncodingDecl(ctxt);
10913|    336|    if ((ctxt->errNo == XML_ERR_UNSUPPORTED_ENCODING) ||
  ------------------
  |  Branch (10913:9): [True: 0, False: 336]
  ------------------
10914|    336|         (ctxt->instate == XML_PARSER_EOF)) {
  ------------------
  |  Branch (10914:10): [True: 0, False: 336]
  ------------------
10915|       |	/*
10916|       |	 * The XML REC instructs us to stop parsing right here
10917|       |	 */
10918|      0|        return;
10919|      0|    }
10920|       |
10921|       |    /*
10922|       |     * We may have the standalone status.
10923|       |     */
10924|    336|    if ((ctxt->encoding != NULL) && (!IS_BLANK_CH(RAW))) {
  ------------------
  |  |  151|    132|#define IS_BLANK_CH(c)  xmlIsBlank_ch(c)
  |  |  ------------------
  |  |  |  |   88|    132|#define xmlIsBlank_ch(c)	(((c) == 0x20) || \
  |  |  |  |  ------------------
  |  |  |  |  |  Branch (88:27): [True: 24, False: 108]
  |  |  |  |  ------------------
  |  |  |  |   89|    132|				 ((0x9 <= (c)) && ((c) <= 0xa)) || \
  |  |  |  |  ------------------
  |  |  |  |  |  Branch (89:7): [True: 108, False: 0]
  |  |  |  |  |  Branch (89:23): [True: 0, False: 108]
  |  |  |  |  ------------------
  |  |  |  |   90|    132|				 ((c) == 0xd))
  |  |  |  |  ------------------
  |  |  |  |  |  Branch (90:6): [True: 0, False: 108]
  |  |  |  |  ------------------
  |  |  ------------------
  ------------------
  |  Branch (10924:9): [True: 132, False: 204]
  ------------------
10925|    108|        if ((RAW == '?') && (NXT(1) == '>')) {
  ------------------
  |  | 2221|    108|#define RAW (*ctxt->input->cur)
  ------------------
                      if ((RAW == '?') && (NXT(1) == '>')) {
  ------------------
  |  | 2223|    108|#define NXT(val) ctxt->input->cur[(val)]
  ------------------
  |  Branch (10925:13): [True: 108, False: 0]
  |  Branch (10925:29): [True: 108, False: 0]
  ------------------
10926|    108|	    SKIP(2);
  ------------------
  |  | 2245|    108|#define SKIP(val) do {							\
  |  | 2246|    108|    ctxt->input->cur += (val),ctxt->input->col+=(val);			\
  |  | 2247|    108|    if (*ctxt->input->cur == 0)						\
  |  |  ------------------
  |  |  |  Branch (2247:9): [True: 0, False: 108]
  |  |  ------------------
  |  | 2248|    108|        xmlParserGrow(ctxt);						\
  |  | 2249|    108|  } while (0)
  |  |  ------------------
  |  |  |  Branch (2249:12): [Folded - Ignored]
  |  |  ------------------
  ------------------
10927|    108|	    return;
10928|    108|	}
10929|      0|	xmlFatalErrMsg(ctxt, XML_ERR_SPACE_REQUIRED, "Blank needed here\n");
10930|      0|    }
10931|       |
10932|       |    /*
10933|       |     * We can grow the input buffer freely at that point
10934|       |     */
10935|    228|    GROW;
  ------------------
  |  | 2270|    228|#define GROW if (ctxt->input->end - ctxt->input->cur < INPUT_CHUNK)	\
  |  |  ------------------
  |  |  |  |   97|    228|#define INPUT_CHUNK	250
  |  |  ------------------
  |  |  |  Branch (2270:18): [True: 93, False: 135]
  |  |  ------------------
  |  | 2271|    228|	xmlParserGrow(ctxt);
  ------------------
10936|       |
10937|    228|    SKIP_BLANKS;
  ------------------
  |  | 2273|    228|#define SKIP_BLANKS xmlSkipBlankChars(ctxt)
  ------------------
10938|    228|    ctxt->standalone = xmlParseSDDecl(ctxt);
10939|       |
10940|    228|    SKIP_BLANKS;
  ------------------
  |  | 2273|    228|#define SKIP_BLANKS xmlSkipBlankChars(ctxt)
  ------------------
10941|    228|    if ((RAW == '?') && (NXT(1) == '>')) {
  ------------------
  |  | 2221|    228|#define RAW (*ctxt->input->cur)
  ------------------
                  if ((RAW == '?') && (NXT(1) == '>')) {
  ------------------
  |  | 2223|    228|#define NXT(val) ctxt->input->cur[(val)]
  ------------------
  |  Branch (10941:9): [True: 228, False: 0]
  |  Branch (10941:25): [True: 228, False: 0]
  ------------------
10942|    228|        SKIP(2);
  ------------------
  |  | 2245|    228|#define SKIP(val) do {							\
  |  | 2246|    228|    ctxt->input->cur += (val),ctxt->input->col+=(val);			\
  |  | 2247|    228|    if (*ctxt->input->cur == 0)						\
  |  |  ------------------
  |  |  |  Branch (2247:9): [True: 0, False: 228]
  |  |  ------------------
  |  | 2248|    228|        xmlParserGrow(ctxt);						\
  |  | 2249|    228|  } while (0)
  |  |  ------------------
  |  |  |  Branch (2249:12): [Folded - Ignored]
  |  |  ------------------
  ------------------
10943|    228|    } else if (RAW == '>') {
  ------------------
  |  | 2221|      0|#define RAW (*ctxt->input->cur)
  ------------------
  |  Branch (10943:16): [True: 0, False: 0]
  ------------------
10944|       |        /* Deprecated old WD ... */
10945|      0|	xmlFatalErr(ctxt, XML_ERR_XMLDECL_NOT_FINISHED, NULL);
10946|      0|	NEXT;
  ------------------
  |  | 2275|      0|#define NEXT xmlNextChar(ctxt)
  ------------------
10947|      0|    } else {
10948|      0|        int c;
10949|       |
10950|      0|	xmlFatalErr(ctxt, XML_ERR_XMLDECL_NOT_FINISHED, NULL);
10951|      0|        while ((c = CUR) != 0) {
  ------------------
  |  | 2222|      0|#define CUR (*ctxt->input->cur)
  ------------------
  |  Branch (10951:16): [True: 0, False: 0]
  ------------------
10952|      0|            NEXT;
  ------------------
  |  | 2275|      0|#define NEXT xmlNextChar(ctxt)
  ------------------
10953|      0|            if (c == '>')
  ------------------
  |  Branch (10953:17): [True: 0, False: 0]
  ------------------
10954|      0|                break;
10955|      0|        }
10956|      0|    }
10957|    228|}
xmlParseMisc:
10971|  1.58k|xmlParseMisc(xmlParserCtxtPtr ctxt) {
10972|  1.67k|    while (ctxt->instate != XML_PARSER_EOF) {
  ------------------
  |  Branch (10972:12): [True: 1.67k, False: 0]
  ------------------
10973|  1.67k|        SKIP_BLANKS;
  ------------------
  |  | 2273|  1.67k|#define SKIP_BLANKS xmlSkipBlankChars(ctxt)
  ------------------
10974|  1.67k|        GROW;
  ------------------
  |  | 2270|  1.67k|#define GROW if (ctxt->input->end - ctxt->input->cur < INPUT_CHUNK)	\
  |  |  ------------------
  |  |  |  |   97|  1.67k|#define INPUT_CHUNK	250
  |  |  ------------------
  |  |  |  Branch (2270:18): [True: 1.30k, False: 364]
  |  |  ------------------
  |  | 2271|  1.67k|	xmlParserGrow(ctxt);
  ------------------
10975|  1.67k|        if ((RAW == '<') && (NXT(1) == '?')) {
  ------------------
  |  | 2221|  1.67k|#define RAW (*ctxt->input->cur)
  ------------------
                      if ((RAW == '<') && (NXT(1) == '?')) {
  ------------------
  |  | 2223|  1.05k|#define NXT(val) ctxt->input->cur[(val)]
  ------------------
  |  Branch (10975:13): [True: 1.05k, False: 612]
  |  Branch (10975:29): [True: 26, False: 1.03k]
  ------------------
10976|     26|	    xmlParsePI(ctxt);
10977|  1.64k|        } else if (CMP4(CUR_PTR, '<', '!', '-', '-')) {
  ------------------
  |  | 2228|  1.64k|  ( ((unsigned char *) s)[ 0 ] == c1 && ((unsigned char *) s)[ 1 ] == c2 && \
  |  |  ------------------
  |  |  |  Branch (2228:5): [True: 1.03k, False: 612]
  |  |  |  Branch (2228:41): [True: 440, False: 592]
  |  |  ------------------
  |  | 2229|  1.64k|    ((unsigned char *) s)[ 2 ] == c3 && ((unsigned char *) s)[ 3 ] == c4 )
  |  |  ------------------
  |  |  |  Branch (2229:5): [True: 56, False: 384]
  |  |  |  Branch (2229:41): [True: 56, False: 0]
  |  |  ------------------
  ------------------
10978|     56|	    xmlParseComment(ctxt);
10979|  1.58k|        } else {
10980|  1.58k|            break;
10981|  1.58k|        }
10982|  1.67k|    }
10983|  1.58k|}
xmlParseDocument:
11001|    644|xmlParseDocument(xmlParserCtxtPtr ctxt) {
11002|    644|    xmlInitParser();
11003|       |
11004|    644|    if ((ctxt == NULL) || (ctxt->input == NULL))
  ------------------
  |  Branch (11004:9): [True: 0, False: 644]
  |  Branch (11004:27): [True: 0, False: 644]
  ------------------
11005|      0|        return(-1);
11006|       |
11007|    644|    GROW;
  ------------------
  |  | 2270|    644|#define GROW if (ctxt->input->end - ctxt->input->cur < INPUT_CHUNK)	\
  |  |  ------------------
  |  |  |  |   97|    644|#define INPUT_CHUNK	250
  |  |  ------------------
  |  |  |  Branch (2270:18): [True: 644, False: 0]
  |  |  ------------------
  |  | 2271|    644|	xmlParserGrow(ctxt);
  ------------------
11008|       |
11009|       |    /*
11010|       |     * SAX: detecting the level.
11011|       |     */
11012|    644|    xmlDetectSAX2(ctxt);
11013|       |
11014|       |    /*
11015|       |     * SAX: beginning of the document processing.
11016|       |     */
11017|    644|    if ((ctxt->sax) && (ctxt->sax->setDocumentLocator))
  ------------------
  |  Branch (11017:9): [True: 644, False: 0]
  |  Branch (11017:24): [True: 644, False: 0]
  ------------------
11018|    644|        ctxt->sax->setDocumentLocator(ctxt->userData, &xmlDefaultSAXLocator);
  ------------------
  |  |  861|    644|  #define xmlDefaultSAXLocator XML_GLOBAL_MACRO(xmlDefaultSAXLocator)
  |  |  ------------------
  |  |  |  |  500|    644|  #define XML_GLOBAL_MACRO(name) (*__##name())
  |  |  ------------------
  ------------------
11019|    644|    if (ctxt->instate == XML_PARSER_EOF)
  ------------------
  |  Branch (11019:9): [True: 0, False: 644]
  ------------------
11020|      0|	return(-1);
11021|       |
11022|    644|    xmlDetectEncoding(ctxt);
11023|       |
11024|    644|    if (CUR == 0) {
  ------------------
  |  | 2222|    644|#define CUR (*ctxt->input->cur)
  ------------------
  |  Branch (11024:9): [True: 0, False: 644]
  ------------------
11025|      0|	xmlFatalErr(ctxt, XML_ERR_DOCUMENT_EMPTY, NULL);
11026|      0|	return(-1);
11027|      0|    }
11028|       |
11029|    644|    GROW;
  ------------------
  |  | 2270|    644|#define GROW if (ctxt->input->end - ctxt->input->cur < INPUT_CHUNK)	\
  |  |  ------------------
  |  |  |  |   97|    644|#define INPUT_CHUNK	250
  |  |  ------------------
  |  |  |  Branch (2270:18): [True: 378, False: 266]
  |  |  ------------------
  |  | 2271|    644|	xmlParserGrow(ctxt);
  ------------------
11030|    644|    if ((CMP5(CUR_PTR, '<', '?', 'x', 'm', 'l')) && (IS_BLANK_CH(NXT(5)))) {
  ------------------
  |  | 2231|    644|  ( CMP4( s, c1, c2, c3, c4 ) && ((unsigned char *) s)[ 4 ] == c5 )
  |  |  ------------------
  |  |  |  | 2228|  1.28k|  ( ((unsigned char *) s)[ 0 ] == c1 && ((unsigned char *) s)[ 1 ] == c2 && \
  |  |  |  |  ------------------
  |  |  |  |  |  Branch (2228:5): [True: 626, False: 18]
  |  |  |  |  |  Branch (2228:41): [True: 332, False: 294]
  |  |  |  |  ------------------
  |  |  |  | 2229|    644|    ((unsigned char *) s)[ 2 ] == c3 && ((unsigned char *) s)[ 3 ] == c4 )
  |  |  |  |  ------------------
  |  |  |  |  |  Branch (2229:5): [True: 328, False: 4]
  |  |  |  |  |  Branch (2229:41): [True: 328, False: 0]
  |  |  |  |  ------------------
  |  |  ------------------
  |  |  |  Branch (2231:34): [True: 326, False: 2]
  |  |  ------------------
  ------------------
                  if ((CMP5(CUR_PTR, '<', '?', 'x', 'm', 'l')) && (IS_BLANK_CH(NXT(5)))) {
  ------------------
  |  |  151|    326|#define IS_BLANK_CH(c)  xmlIsBlank_ch(c)
  |  |  ------------------
  |  |  |  |   88|    326|#define xmlIsBlank_ch(c)	(((c) == 0x20) || \
  |  |  |  |  ------------------
  |  |  |  |  |  Branch (88:27): [True: 326, False: 0]
  |  |  |  |  ------------------
  |  |  |  |   89|    326|				 ((0x9 <= (c)) && ((c) <= 0xa)) || \
  |  |  |  |  ------------------
  |  |  |  |  |  Branch (89:7): [True: 0, False: 0]
  |  |  |  |  |  Branch (89:23): [True: 0, False: 0]
  |  |  |  |  ------------------
  |  |  |  |   90|    326|				 ((c) == 0xd))
  |  |  |  |  ------------------
  |  |  |  |  |  Branch (90:6): [True: 0, False: 0]
  |  |  |  |  ------------------
  |  |  ------------------
  ------------------
11031|       |
11032|       |	/*
11033|       |	 * Note that we will switch encoding on the fly.
11034|       |	 */
11035|    326|	xmlParseXMLDecl(ctxt);
11036|    326|	if ((ctxt->errNo == XML_ERR_UNSUPPORTED_ENCODING) ||
  ------------------
  |  Branch (11036:6): [True: 0, False: 326]
  ------------------
11037|    326|	    (ctxt->instate == XML_PARSER_EOF)) {
  ------------------
  |  Branch (11037:6): [True: 0, False: 326]
  ------------------
11038|       |	    /*
11039|       |	     * The XML REC instructs us to stop parsing right here
11040|       |	     */
11041|      0|	    return(-1);
11042|      0|	}
11043|    326|	SKIP_BLANKS;
  ------------------
  |  | 2273|    326|#define SKIP_BLANKS xmlSkipBlankChars(ctxt)
  ------------------
11044|    326|    } else {
11045|    318|	ctxt->version = xmlCharStrdup(XML_DEFAULT_VERSION);
  ------------------
  |  |   37|    318|#define XML_DEFAULT_VERSION	"1.0"
  ------------------
11046|    318|    }
11047|    644|    if ((ctxt->sax) && (ctxt->sax->startDocument) && (!ctxt->disableSAX))
  ------------------
  |  Branch (11047:9): [True: 644, False: 0]
  |  Branch (11047:24): [True: 644, False: 0]
  |  Branch (11047:54): [True: 644, False: 0]
  ------------------
11048|    644|        ctxt->sax->startDocument(ctxt->userData);
11049|    644|    if (ctxt->instate == XML_PARSER_EOF)
  ------------------
  |  Branch (11049:9): [True: 0, False: 644]
  ------------------
11050|      0|	return(-1);
11051|    644|    if ((ctxt->myDoc != NULL) && (ctxt->input != NULL) &&
  ------------------
  |  Branch (11051:9): [True: 644, False: 0]
  |  Branch (11051:34): [True: 644, False: 0]
  ------------------
11052|    644|        (ctxt->input->buf != NULL) && (ctxt->input->buf->compressed >= 0)) {
  ------------------
  |  Branch (11052:9): [True: 644, False: 0]
  |  Branch (11052:39): [True: 0, False: 644]
  ------------------
11053|      0|	ctxt->myDoc->compression = ctxt->input->buf->compressed;
11054|      0|    }
11055|       |
11056|       |    /*
11057|       |     * The Misc part of the Prolog
11058|       |     */
11059|    644|    xmlParseMisc(ctxt);
11060|       |
11061|       |    /*
11062|       |     * Then possibly doc type declaration(s) and more Misc
11063|       |     * (doctypedecl Misc*)?
11064|       |     */
11065|    644|    GROW;
  ------------------
  |  | 2270|    644|#define GROW if (ctxt->input->end - ctxt->input->cur < INPUT_CHUNK)	\
  |  |  ------------------
  |  |  |  |   97|    644|#define INPUT_CHUNK	250
  |  |  ------------------
  |  |  |  Branch (2270:18): [True: 386, False: 258]
  |  |  ------------------
  |  | 2271|    644|	xmlParserGrow(ctxt);
  ------------------
11066|    644|    if (CMP9(CUR_PTR, '<', '!', 'D', 'O', 'C', 'T', 'Y', 'P', 'E')) {
  ------------------
  |  | 2239|    644|  ( CMP8( s, c1, c2, c3, c4, c5, c6, c7, c8 ) && \
  |  |  ------------------
  |  |  |  | 2237|  1.28k|  ( CMP7( s, c1, c2, c3, c4, c5, c6, c7 ) && ((unsigned char *) s)[ 7 ] == c8 )
  |  |  |  |  ------------------
  |  |  |  |  |  | 2235|  1.28k|  ( CMP6( s, c1, c2, c3, c4, c5, c6 ) && ((unsigned char *) s)[ 6 ] == c7 )
  |  |  |  |  |  |  ------------------
  |  |  |  |  |  |  |  | 2233|  1.28k|  ( CMP5( s, c1, c2, c3, c4, c5 ) && ((unsigned char *) s)[ 5 ] == c6 )
  |  |  |  |  |  |  |  |  ------------------
  |  |  |  |  |  |  |  |  |  | 2231|  1.28k|  ( CMP4( s, c1, c2, c3, c4 ) && ((unsigned char *) s)[ 4 ] == c5 )
  |  |  |  |  |  |  |  |  |  |  ------------------
  |  |  |  |  |  |  |  |  |  |  |  | 2228|  1.28k|  ( ((unsigned char *) s)[ 0 ] == c1 && ((unsigned char *) s)[ 1 ] == c2 && \
  |  |  |  |  |  |  |  |  |  |  |  |  ------------------
  |  |  |  |  |  |  |  |  |  |  |  |  |  Branch (2228:5): [True: 626, False: 18]
  |  |  |  |  |  |  |  |  |  |  |  |  |  Branch (2228:41): [True: 384, False: 242]
  |  |  |  |  |  |  |  |  |  |  |  |  ------------------
  |  |  |  |  |  |  |  |  |  |  |  | 2229|    644|    ((unsigned char *) s)[ 2 ] == c3 && ((unsigned char *) s)[ 3 ] == c4 )
  |  |  |  |  |  |  |  |  |  |  |  |  ------------------
  |  |  |  |  |  |  |  |  |  |  |  |  |  Branch (2229:5): [True: 380, False: 4]
  |  |  |  |  |  |  |  |  |  |  |  |  |  Branch (2229:41): [True: 380, False: 0]
  |  |  |  |  |  |  |  |  |  |  |  |  ------------------
  |  |  |  |  |  |  |  |  |  |  ------------------
  |  |  |  |  |  |  |  |  |  |  |  Branch (2231:34): [True: 380, False: 0]
  |  |  |  |  |  |  |  |  |  |  ------------------
  |  |  |  |  |  |  |  |  ------------------
  |  |  |  |  |  |  |  |  |  Branch (2233:38): [True: 380, False: 0]
  |  |  |  |  |  |  |  |  ------------------
  |  |  |  |  |  |  ------------------
  |  |  |  |  |  |  |  Branch (2235:42): [True: 380, False: 0]
  |  |  |  |  |  |  ------------------
  |  |  |  |  ------------------
  |  |  |  |  |  Branch (2237:46): [True: 380, False: 0]
  |  |  |  |  ------------------
  |  |  ------------------
  |  | 2240|    644|    ((unsigned char *) s)[ 8 ] == c9 )
  |  |  ------------------
  |  |  |  Branch (2240:5): [True: 380, False: 0]
  |  |  ------------------
  ------------------
11067|       |
11068|    380|	ctxt->inSubset = 1;
11069|    380|	xmlParseDocTypeDecl(ctxt);
11070|    380|	if (RAW == '[') {
  ------------------
  |  | 2221|    380|#define RAW (*ctxt->input->cur)
  ------------------
  |  Branch (11070:6): [True: 272, False: 108]
  ------------------
11071|    272|	    ctxt->instate = XML_PARSER_DTD;
11072|    272|	    xmlParseInternalSubset(ctxt);
11073|    272|	    if (ctxt->instate == XML_PARSER_EOF)
  ------------------
  |  Branch (11073:10): [True: 22, False: 250]
  ------------------
11074|     22|		return(-1);
11075|    272|	}
11076|       |
11077|       |	/*
11078|       |	 * Create and update the external subset.
11079|       |	 */
11080|    358|	ctxt->inSubset = 2;
11081|    358|	if ((ctxt->sax != NULL) && (ctxt->sax->externalSubset != NULL) &&
  ------------------
  |  Branch (11081:6): [True: 358, False: 0]
  |  Branch (11081:29): [True: 358, False: 0]
  ------------------
11082|    358|	    (!ctxt->disableSAX))
  ------------------
  |  Branch (11082:6): [True: 358, False: 0]
  ------------------
11083|    358|	    ctxt->sax->externalSubset(ctxt->userData, ctxt->intSubName,
11084|    358|	                              ctxt->extSubSystem, ctxt->extSubURI);
11085|    358|	if (ctxt->instate == XML_PARSER_EOF)
  ------------------
  |  Branch (11085:6): [True: 8, False: 350]
  ------------------
11086|      8|	    return(-1);
11087|    350|	ctxt->inSubset = 0;
11088|       |
11089|    350|        xmlCleanSpecialAttr(ctxt);
11090|       |
11091|    350|	ctxt->instate = XML_PARSER_PROLOG;
11092|    350|	xmlParseMisc(ctxt);
11093|    350|    }
11094|       |
11095|       |    /*
11096|       |     * Time to start parsing the tree itself
11097|       |     */
11098|    614|    GROW;
  ------------------
  |  | 2270|    614|#define GROW if (ctxt->input->end - ctxt->input->cur < INPUT_CHUNK)	\
  |  |  ------------------
  |  |  |  |   97|    614|#define INPUT_CHUNK	250
  |  |  ------------------
  |  |  |  Branch (2270:18): [True: 442, False: 172]
  |  |  ------------------
  |  | 2271|    614|	xmlParserGrow(ctxt);
  ------------------
11099|    614|    if (RAW != '<') {
  ------------------
  |  | 2221|    614|#define RAW (*ctxt->input->cur)
  ------------------
  |  Branch (11099:9): [True: 20, False: 594]
  ------------------
11100|     20|	xmlFatalErrMsg(ctxt, XML_ERR_DOCUMENT_EMPTY,
11101|     20|		       "Start tag expected, '<' not found\n");
11102|    594|    } else {
11103|    594|	ctxt->instate = XML_PARSER_CONTENT;
11104|    594|	xmlParseElement(ctxt);
11105|    594|	ctxt->instate = XML_PARSER_EPILOG;
11106|       |
11107|       |
11108|       |	/*
11109|       |	 * The Misc part at the end
11110|       |	 */
11111|    594|	xmlParseMisc(ctxt);
11112|       |
11113|    594|        if (ctxt->input->cur < ctxt->input->end) {
  ------------------
  |  Branch (11113:13): [True: 10, False: 584]
  ------------------
11114|     10|            if (ctxt->errNo == XML_ERR_OK)
  ------------------
  |  Branch (11114:17): [True: 1, False: 9]
  ------------------
11115|      1|	        xmlFatalErr(ctxt, XML_ERR_DOCUMENT_END, NULL);
11116|    584|        } else if ((ctxt->input->buf != NULL) &&
  ------------------
  |  Branch (11116:20): [True: 566, False: 18]
  ------------------
11117|    584|                   (ctxt->input->buf->encoder != NULL) &&
  ------------------
  |  Branch (11117:20): [True: 30, False: 536]
  ------------------
11118|    584|                   (!xmlBufIsEmpty(ctxt->input->buf->raw))) {
  ------------------
  |  Branch (11118:20): [True: 0, False: 30]
  ------------------
11119|      0|            xmlFatalErrMsg(ctxt, XML_ERR_INVALID_CHAR,
11120|      0|                           "Truncated multi-byte sequence at EOF\n");
11121|      0|        }
11122|    594|	ctxt->instate = XML_PARSER_EOF;
11123|    594|    }
11124|       |
11125|       |    /*
11126|       |     * SAX: end of the document processing.
11127|       |     */
11128|    614|    if ((ctxt->sax) && (ctxt->sax->endDocument != NULL))
  ------------------
  |  Branch (11128:9): [True: 614, False: 0]
  |  Branch (11128:24): [True: 614, False: 0]
  ------------------
11129|    614|        ctxt->sax->endDocument(ctxt->userData);
11130|       |
11131|       |    /*
11132|       |     * Remove locally kept entity definitions if the tree was not built
11133|       |     */
11134|    614|    if ((ctxt->myDoc != NULL) &&
  ------------------
  |  Branch (11134:9): [True: 614, False: 0]
  ------------------
11135|    614|	(xmlStrEqual(ctxt->myDoc->version, SAX_COMPAT_MODE))) {
  ------------------
  |  |  168|    614|#define SAX_COMPAT_MODE BAD_CAST "SAX compatibility mode document"
  |  |  ------------------
  |  |  |  |   35|    614|#define BAD_CAST (xmlChar *)
  |  |  ------------------
  ------------------
  |  Branch (11135:2): [True: 0, False: 614]
  ------------------
11136|      0|	xmlFreeDoc(ctxt->myDoc);
11137|      0|	ctxt->myDoc = NULL;
11138|      0|    }
11139|       |
11140|    614|    if ((ctxt->wellFormed) && (ctxt->myDoc != NULL)) {
  ------------------
  |  Branch (11140:9): [True: 527, False: 87]
  |  Branch (11140:31): [True: 527, False: 0]
  ------------------
11141|    527|        ctxt->myDoc->properties |= XML_DOC_WELLFORMED;
11142|    527|	if (ctxt->valid)
  ------------------
  |  Branch (11142:6): [True: 330, False: 197]
  ------------------
11143|    330|	    ctxt->myDoc->properties |= XML_DOC_DTDVALID;
11144|    527|	if (ctxt->nsWellFormed)
  ------------------
  |  Branch (11144:6): [True: 505, False: 22]
  ------------------
11145|    505|	    ctxt->myDoc->properties |= XML_DOC_NSVALID;
11146|    527|	if (ctxt->options & XML_PARSE_OLD10)
  ------------------
  |  Branch (11146:6): [True: 0, False: 527]
  ------------------
11147|      0|	    ctxt->myDoc->properties |= XML_DOC_OLD10;
11148|    527|    }
11149|    614|    if (! ctxt->wellFormed) {
  ------------------
  |  Branch (11149:9): [True: 87, False: 527]
  ------------------
11150|     87|	ctxt->valid = 0;
11151|     87|	return(-1);
11152|     87|    }
11153|    527|    return(0);
11154|    614|}
xmlParseChunk:
12110|  13.0k|              int terminate) {
12111|  13.0k|    int end_in_lf = 0;
12112|       |
12113|  13.0k|    if (ctxt == NULL)
  ------------------
  |  Branch (12113:9): [True: 0, False: 13.0k]
  ------------------
12114|      0|        return(XML_ERR_INTERNAL_ERROR);
12115|  13.0k|    if ((ctxt->errNo != XML_ERR_OK) && (ctxt->disableSAX == 1))
  ------------------
  |  Branch (12115:9): [True: 6.82k, False: 6.18k]
  |  Branch (12115:40): [True: 534, False: 6.29k]
  ------------------
12116|    534|        return(ctxt->errNo);
12117|  12.4k|    if (ctxt->instate == XML_PARSER_EOF)
  ------------------
  |  Branch (12117:9): [True: 1, False: 12.4k]
  ------------------
12118|      1|        return(-1);
12119|  12.4k|    if (ctxt->input == NULL)
  ------------------
  |  Branch (12119:9): [True: 0, False: 12.4k]
  ------------------
12120|      0|        return(-1);
12121|       |
12122|  12.4k|    ctxt->progressive = 1;
12123|  12.4k|    if (ctxt->instate == XML_PARSER_START)
  ------------------
  |  Branch (12123:9): [True: 672, False: 11.8k]
  ------------------
12124|    672|        xmlDetectSAX2(ctxt);
12125|  12.4k|    if ((size > 0) && (chunk != NULL) && (!terminate) &&
  ------------------
  |  Branch (12125:9): [True: 11.8k, False: 578]
  |  Branch (12125:23): [True: 11.8k, False: 0]
  |  Branch (12125:42): [True: 11.8k, False: 0]
  ------------------
12126|  12.4k|        (chunk[size - 1] == '\r')) {
  ------------------
  |  Branch (12126:9): [True: 89, False: 11.8k]
  ------------------
12127|     89|	end_in_lf = 1;
12128|     89|	size--;
12129|     89|    }
12130|       |
12131|  12.4k|    if ((size > 0) && (chunk != NULL) && (ctxt->input != NULL) &&
  ------------------
  |  Branch (12131:9): [True: 11.8k, False: 578]
  |  Branch (12131:23): [True: 11.8k, False: 0]
  |  Branch (12131:42): [True: 11.8k, False: 0]
  ------------------
12132|  12.4k|        (ctxt->input->buf != NULL) && (ctxt->instate != XML_PARSER_EOF))  {
  ------------------
  |  Branch (12132:9): [True: 11.8k, False: 0]
  |  Branch (12132:39): [True: 11.8k, False: 0]
  ------------------
12133|  11.8k|	size_t pos = ctxt->input->cur - ctxt->input->base;
12134|  11.8k|	int res;
12135|       |
12136|  11.8k|	res = xmlParserInputBufferPush(ctxt->input->buf, size, chunk);
12137|  11.8k|        xmlBufUpdateInput(ctxt->input->buf->buffer, ctxt->input, pos);
12138|  11.8k|	if (res < 0) {
  ------------------
  |  Branch (12138:6): [True: 0, False: 11.8k]
  ------------------
12139|      0|            xmlFatalErr(ctxt, ctxt->input->buf->error, NULL);
12140|      0|	    xmlHaltParser(ctxt);
12141|      0|	    return(ctxt->errNo);
12142|      0|	}
12143|  11.8k|    }
12144|       |
12145|  12.4k|    xmlParseTryOrFinish(ctxt, terminate);
12146|  12.4k|    if (ctxt->instate == XML_PARSER_EOF)
  ------------------
  |  Branch (12146:9): [True: 84, False: 12.3k]
  ------------------
12147|     84|        return(ctxt->errNo);
12148|       |
12149|  12.3k|    if ((ctxt->input != NULL) &&
  ------------------
  |  Branch (12149:9): [True: 12.3k, False: 0]
  ------------------
12150|  12.3k|         (((ctxt->input->end - ctxt->input->cur) > XML_MAX_LOOKUP_LIMIT) ||
  ------------------
  |  |   81|  12.3k|#define XML_MAX_LOOKUP_LIMIT 10000000
  ------------------
  |  Branch (12150:11): [True: 0, False: 12.3k]
  ------------------
12151|  12.3k|         ((ctxt->input->cur - ctxt->input->base) > XML_MAX_LOOKUP_LIMIT)) &&
  ------------------
  |  |   81|  12.3k|#define XML_MAX_LOOKUP_LIMIT 10000000
  ------------------
  |  Branch (12151:10): [True: 0, False: 12.3k]
  ------------------
12152|  12.3k|        ((ctxt->options & XML_PARSE_HUGE) == 0)) {
  ------------------
  |  Branch (12152:9): [True: 0, False: 0]
  ------------------
12153|      0|        xmlFatalErr(ctxt, XML_ERR_INTERNAL_ERROR, "Huge input lookup");
12154|      0|        xmlHaltParser(ctxt);
12155|      0|    }
12156|  12.3k|    if ((ctxt->errNo != XML_ERR_OK) && (ctxt->disableSAX == 1))
  ------------------
  |  Branch (12156:9): [True: 6.61k, False: 5.77k]
  |  Branch (12156:40): [True: 32, False: 6.57k]
  ------------------
12157|     32|        return(ctxt->errNo);
12158|       |
12159|  12.3k|    if ((end_in_lf == 1) && (ctxt->input != NULL) &&
  ------------------
  |  Branch (12159:9): [True: 89, False: 12.2k]
  |  Branch (12159:29): [True: 89, False: 0]
  ------------------
12160|  12.3k|        (ctxt->input->buf != NULL)) {
  ------------------
  |  Branch (12160:9): [True: 89, False: 0]
  ------------------
12161|     89|	size_t pos = ctxt->input->cur - ctxt->input->base;
12162|     89|        int res;
12163|       |
12164|     89|	res = xmlParserInputBufferPush(ctxt->input->buf, 1, "\r");
12165|     89|	xmlBufUpdateInput(ctxt->input->buf->buffer, ctxt->input, pos);
12166|     89|        if (res < 0) {
  ------------------
  |  Branch (12166:13): [True: 0, False: 89]
  ------------------
12167|      0|            xmlFatalErr(ctxt, ctxt->input->buf->error, NULL);
12168|      0|            xmlHaltParser(ctxt);
12169|      0|            return(ctxt->errNo);
12170|      0|        }
12171|     89|    }
12172|  12.3k|    if (terminate) {
  ------------------
  |  Branch (12172:9): [True: 530, False: 11.8k]
  ------------------
12173|       |	/*
12174|       |	 * Check for termination
12175|       |	 */
12176|    530|        if ((ctxt->instate != XML_PARSER_EOF) &&
  ------------------
  |  Branch (12176:13): [True: 530, False: 0]
  ------------------
12177|    530|            (ctxt->instate != XML_PARSER_EPILOG)) {
  ------------------
  |  Branch (12177:13): [True: 6, False: 524]
  ------------------
12178|      6|            if (ctxt->nameNr > 0) {
  ------------------
  |  Branch (12178:17): [True: 4, False: 2]
  ------------------
12179|      4|                const xmlChar *name = ctxt->nameTab[ctxt->nameNr - 1];
12180|      4|                int line = ctxt->pushTab[ctxt->nameNr - 1].line;
12181|      4|                xmlFatalErrMsgStrIntStr(ctxt, XML_ERR_TAG_NOT_FINISHED,
12182|      4|                        "Premature end of data in tag %s line %d\n",
12183|      4|                        name, line, NULL);
12184|      4|            } else if (ctxt->instate == XML_PARSER_START) {
  ------------------
  |  Branch (12184:24): [True: 2, False: 0]
  ------------------
12185|      2|                xmlFatalErr(ctxt, XML_ERR_DOCUMENT_EMPTY, NULL);
12186|      2|            } else {
12187|      0|                xmlFatalErrMsg(ctxt, XML_ERR_DOCUMENT_EMPTY,
12188|      0|                               "Start tag expected, '<' not found\n");
12189|      0|            }
12190|    524|        } else if ((ctxt->input->buf != NULL) &&
  ------------------
  |  Branch (12190:20): [True: 524, False: 0]
  ------------------
12191|    524|                   (ctxt->input->buf->encoder != NULL) &&
  ------------------
  |  Branch (12191:20): [True: 30, False: 494]
  ------------------
12192|    524|                   (!xmlBufIsEmpty(ctxt->input->buf->raw))) {
  ------------------
  |  Branch (12192:20): [True: 0, False: 30]
  ------------------
12193|      0|            xmlFatalErrMsg(ctxt, XML_ERR_INVALID_CHAR,
12194|      0|                           "Truncated multi-byte sequence at EOF\n");
12195|      0|        }
12196|    530|	if (ctxt->instate != XML_PARSER_EOF) {
  ------------------
  |  Branch (12196:6): [True: 530, False: 0]
  ------------------
12197|    530|	    if ((ctxt->sax) && (ctxt->sax->endDocument != NULL))
  ------------------
  |  Branch (12197:10): [True: 530, False: 0]
  |  Branch (12197:25): [True: 530, False: 0]
  ------------------
12198|    530|		ctxt->sax->endDocument(ctxt->userData);
12199|    530|	}
12200|    530|	ctxt->instate = XML_PARSER_EOF;
12201|    530|    }
12202|  12.3k|    if (ctxt->wellFormed == 0)
  ------------------
  |  Branch (12202:9): [True: 6, False: 12.3k]
  ------------------
12203|      6|	return((xmlParserErrors) ctxt->errNo);
12204|  12.3k|    else
12205|  12.3k|        return(0);
12206|  12.3k|}
xmlCreatePushParserCtxt:
12235|    646|                        const char *chunk, int size, const char *filename) {
12236|    646|    xmlParserCtxtPtr ctxt;
12237|    646|    xmlParserInputPtr inputStream;
12238|    646|    xmlParserInputBufferPtr buf;
12239|       |
12240|    646|    buf = xmlAllocParserInputBuffer(XML_CHAR_ENCODING_NONE);
12241|    646|    if (buf == NULL) return(NULL);
  ------------------
  |  Branch (12241:9): [True: 0, False: 646]
  ------------------
12242|       |
12243|    646|    ctxt = xmlNewSAXParserCtxt(sax, user_data);
12244|    646|    if (ctxt == NULL) {
  ------------------
  |  Branch (12244:9): [True: 0, False: 646]
  ------------------
12245|      0|        xmlErrMemory(NULL, "creating parser: out of memory\n");
12246|      0|	xmlFreeParserInputBuffer(buf);
12247|      0|	return(NULL);
12248|      0|    }
12249|    646|    ctxt->dictNames = 1;
12250|    646|    if (filename == NULL) {
  ------------------
  |  Branch (12250:9): [True: 323, False: 323]
  ------------------
12251|    323|	ctxt->directory = NULL;
12252|    323|    } else {
12253|    323|        ctxt->directory = xmlParserGetDirectory(filename);
12254|    323|    }
12255|       |
12256|    646|    inputStream = xmlNewInputStream(ctxt);
12257|    646|    if (inputStream == NULL) {
  ------------------
  |  Branch (12257:9): [True: 0, False: 646]
  ------------------
12258|      0|	xmlFreeParserCtxt(ctxt);
12259|      0|	xmlFreeParserInputBuffer(buf);
12260|      0|	return(NULL);
12261|      0|    }
12262|       |
12263|    646|    if (filename == NULL)
  ------------------
  |  Branch (12263:9): [True: 323, False: 323]
  ------------------
12264|    323|	inputStream->filename = NULL;
12265|    323|    else {
12266|    323|	inputStream->filename = (char *)
12267|    323|	    xmlCanonicPath((const xmlChar *) filename);
12268|    323|	if (inputStream->filename == NULL) {
  ------------------
  |  Branch (12268:6): [True: 0, False: 323]
  ------------------
12269|      0|            xmlFreeInputStream(inputStream);
12270|      0|	    xmlFreeParserCtxt(ctxt);
12271|      0|	    xmlFreeParserInputBuffer(buf);
12272|      0|	    return(NULL);
12273|      0|	}
12274|    323|    }
12275|    646|    inputStream->buf = buf;
12276|    646|    xmlBufResetInput(inputStream->buf->buffer, inputStream);
12277|    646|    inputPush(ctxt, inputStream);
12278|       |
12279|    646|    if ((size != 0) && (chunk != NULL) &&
  ------------------
  |  Branch (12279:9): [True: 310, False: 336]
  |  Branch (12279:24): [True: 310, False: 0]
  ------------------
12280|    646|        (ctxt->input != NULL) && (ctxt->input->buf != NULL)) {
  ------------------
  |  Branch (12280:9): [True: 310, False: 0]
  |  Branch (12280:34): [True: 310, False: 0]
  ------------------
12281|    310|	size_t pos = ctxt->input->cur - ctxt->input->base;
12282|    310|        int res;
12283|       |
12284|    310|	res = xmlParserInputBufferPush(ctxt->input->buf, size, chunk);
12285|    310|        xmlBufUpdateInput(ctxt->input->buf->buffer, ctxt->input, pos);
12286|    310|        if (res < 0) {
  ------------------
  |  Branch (12286:13): [True: 0, False: 310]
  ------------------
12287|      0|            xmlFatalErr(ctxt, ctxt->input->buf->error, NULL);
12288|      0|            xmlHaltParser(ctxt);
12289|      0|        }
12290|    310|    }
12291|       |
12292|    646|    return(ctxt);
12293|    646|}
xmlStopParser:
12303|    323|xmlStopParser(xmlParserCtxtPtr ctxt) {
12304|    323|    if (ctxt == NULL)
  ------------------
  |  Branch (12304:9): [True: 0, False: 323]
  ------------------
12305|      0|        return;
12306|    323|    xmlHaltParser(ctxt);
12307|    323|    ctxt->errNo = XML_ERR_USER_STOP;
12308|    323|}
xmlSAXParseDTD:
12476|     44|                          const xmlChar *SystemID) {
12477|     44|    xmlDtdPtr ret = NULL;
12478|     44|    xmlParserCtxtPtr ctxt;
12479|     44|    xmlParserInputPtr input = NULL;
12480|     44|    xmlChar* systemIdCanonic;
12481|       |
12482|     44|    if ((ExternalID == NULL) && (SystemID == NULL)) return(NULL);
  ------------------
  |  Branch (12482:9): [True: 6, False: 38]
  |  Branch (12482:33): [True: 0, False: 6]
  ------------------
12483|       |
12484|     44|    ctxt = xmlNewSAXParserCtxt(sax, NULL);
12485|     44|    if (ctxt == NULL) {
  ------------------
  |  Branch (12485:9): [True: 0, False: 44]
  ------------------
12486|      0|	return(NULL);
12487|      0|    }
12488|       |
12489|       |    /* We are loading a DTD */
12490|     44|    ctxt->options |= XML_PARSE_DTDLOAD;
12491|       |
12492|       |    /*
12493|       |     * Canonicalise the system ID
12494|       |     */
12495|     44|    systemIdCanonic = xmlCanonicPath(SystemID);
12496|     44|    if ((SystemID != NULL) && (systemIdCanonic == NULL)) {
  ------------------
  |  Branch (12496:9): [True: 44, False: 0]
  |  Branch (12496:31): [True: 0, False: 44]
  ------------------
12497|      0|	xmlFreeParserCtxt(ctxt);
12498|      0|	return(NULL);
12499|      0|    }
12500|       |
12501|       |    /*
12502|       |     * Ask the Entity resolver to load the damn thing
12503|       |     */
12504|       |
12505|     44|    if ((ctxt->sax != NULL) && (ctxt->sax->resolveEntity != NULL))
  ------------------
  |  Branch (12505:9): [True: 44, False: 0]
  |  Branch (12505:32): [True: 44, False: 0]
  ------------------
12506|     44|	input = ctxt->sax->resolveEntity(ctxt->userData, ExternalID,
12507|     44|	                                 systemIdCanonic);
12508|     44|    if (input == NULL) {
  ------------------
  |  Branch (12508:9): [True: 44, False: 0]
  ------------------
12509|     44|	xmlFreeParserCtxt(ctxt);
12510|     44|	if (systemIdCanonic != NULL)
  ------------------
  |  Branch (12510:6): [True: 44, False: 0]
  ------------------
12511|     44|	    xmlFree(systemIdCanonic);
12512|     44|	return(NULL);
12513|     44|    }
12514|       |
12515|       |    /*
12516|       |     * plug some encoding conversion routines here.
12517|       |     */
12518|      0|    if (xmlPushInput(ctxt, input) < 0) {
  ------------------
  |  Branch (12518:9): [True: 0, False: 0]
  ------------------
12519|      0|	xmlFreeParserCtxt(ctxt);
12520|      0|	if (systemIdCanonic != NULL)
  ------------------
  |  Branch (12520:6): [True: 0, False: 0]
  ------------------
12521|      0|	    xmlFree(systemIdCanonic);
12522|      0|	return(NULL);
12523|      0|    }
12524|       |
12525|      0|    xmlDetectEncoding(ctxt);
12526|       |
12527|      0|    if (input->filename == NULL)
  ------------------
  |  Branch (12527:9): [True: 0, False: 0]
  ------------------
12528|      0|	input->filename = (char *) systemIdCanonic;
12529|      0|    else
12530|      0|	xmlFree(systemIdCanonic);
12531|       |
12532|       |    /*
12533|       |     * let's parse that entity knowing it's an external subset.
12534|       |     */
12535|      0|    ctxt->inSubset = 2;
12536|      0|    ctxt->myDoc = xmlNewDoc(BAD_CAST "1.0");
  ------------------
  |  |   35|      0|#define BAD_CAST (xmlChar *)
  ------------------
12537|      0|    if (ctxt->myDoc == NULL) {
  ------------------
  |  Branch (12537:9): [True: 0, False: 0]
  ------------------
12538|      0|	xmlErrMemory(ctxt, "New Doc failed");
12539|      0|	xmlFreeParserCtxt(ctxt);
12540|      0|	return(NULL);
12541|      0|    }
12542|      0|    ctxt->myDoc->properties = XML_DOC_INTERNAL;
12543|      0|    ctxt->myDoc->extSubset = xmlNewDtd(ctxt->myDoc, BAD_CAST "none",
  ------------------
  |  |   35|      0|#define BAD_CAST (xmlChar *)
  ------------------
12544|      0|	                               ExternalID, SystemID);
12545|      0|    xmlParseExternalSubset(ctxt, ExternalID, SystemID);
12546|       |
12547|      0|    if (ctxt->myDoc != NULL) {
  ------------------
  |  Branch (12547:9): [True: 0, False: 0]
  ------------------
12548|      0|	if (ctxt->wellFormed) {
  ------------------
  |  Branch (12548:6): [True: 0, False: 0]
  ------------------
12549|      0|	    ret = ctxt->myDoc->extSubset;
12550|      0|	    ctxt->myDoc->extSubset = NULL;
12551|      0|	    if (ret != NULL) {
  ------------------
  |  Branch (12551:10): [True: 0, False: 0]
  ------------------
12552|      0|		xmlNodePtr tmp;
12553|       |
12554|      0|		ret->doc = NULL;
12555|      0|		tmp = ret->children;
12556|      0|		while (tmp != NULL) {
  ------------------
  |  Branch (12556:10): [True: 0, False: 0]
  ------------------
12557|      0|		    tmp->doc = NULL;
12558|      0|		    tmp = tmp->next;
12559|      0|		}
12560|      0|	    }
12561|      0|	} else {
12562|      0|	    ret = NULL;
12563|      0|	}
12564|      0|        xmlFreeDoc(ctxt->myDoc);
12565|      0|        ctxt->myDoc = NULL;
12566|      0|    }
12567|      0|    xmlFreeParserCtxt(ctxt);
12568|       |
12569|      0|    return(ret);
12570|      0|}
xmlParseDTD:
12584|     44|xmlParseDTD(const xmlChar *ExternalID, const xmlChar *SystemID) {
12585|     44|    return(xmlSAXParseDTD(NULL, ExternalID, SystemID));
12586|     44|}
xmlCreateMemoryParserCtxt:
13985|    646|xmlCreateMemoryParserCtxt(const char *buffer, int size) {
13986|    646|    xmlParserCtxtPtr ctxt;
13987|    646|    xmlParserInputPtr input;
13988|    646|    xmlParserInputBufferPtr buf;
13989|       |
13990|    646|    if (buffer == NULL)
  ------------------
  |  Branch (13990:9): [True: 0, False: 646]
  ------------------
13991|      0|	return(NULL);
13992|    646|    if (size <= 0)
  ------------------
  |  Branch (13992:9): [True: 2, False: 644]
  ------------------
13993|      2|	return(NULL);
13994|       |
13995|    644|    ctxt = xmlNewParserCtxt();
13996|    644|    if (ctxt == NULL)
  ------------------
  |  Branch (13996:9): [True: 0, False: 644]
  ------------------
13997|      0|	return(NULL);
13998|       |
13999|    644|    buf = xmlParserInputBufferCreateMem(buffer, size, XML_CHAR_ENCODING_NONE);
14000|    644|    if (buf == NULL) {
  ------------------
  |  Branch (14000:9): [True: 0, False: 644]
  ------------------
14001|      0|	xmlFreeParserCtxt(ctxt);
14002|      0|	return(NULL);
14003|      0|    }
14004|       |
14005|    644|    input = xmlNewInputStream(ctxt);
14006|    644|    if (input == NULL) {
  ------------------
  |  Branch (14006:9): [True: 0, False: 644]
  ------------------
14007|      0|	xmlFreeParserInputBuffer(buf);
14008|      0|	xmlFreeParserCtxt(ctxt);
14009|      0|	return(NULL);
14010|      0|    }
14011|       |
14012|    644|    input->filename = NULL;
14013|    644|    input->buf = buf;
14014|    644|    xmlBufResetInput(input->buf->buffer, input);
14015|       |
14016|    644|    inputPush(ctxt, input);
14017|    644|    return(ctxt);
14018|    644|}
xmlCreateDocParserCtxt:
14196|    432|xmlCreateDocParserCtxt(const xmlChar *str) {
14197|    432|    xmlParserCtxtPtr ctxt;
14198|    432|    xmlParserInputPtr input;
14199|    432|    xmlParserInputBufferPtr buf;
14200|       |
14201|    432|    if (str == NULL)
  ------------------
  |  Branch (14201:9): [True: 0, False: 432]
  ------------------
14202|      0|	return(NULL);
14203|       |
14204|    432|    ctxt = xmlNewParserCtxt();
14205|    432|    if (ctxt == NULL)
  ------------------
  |  Branch (14205:9): [True: 0, False: 432]
  ------------------
14206|      0|	return(NULL);
14207|       |
14208|    432|    buf = xmlParserInputBufferCreateString(str);
14209|    432|    if (buf == NULL) {
  ------------------
  |  Branch (14209:9): [True: 0, False: 432]
  ------------------
14210|      0|	xmlFreeParserCtxt(ctxt);
14211|      0|	return(NULL);
14212|      0|    }
14213|       |
14214|    432|    input = xmlNewInputStream(ctxt);
14215|    432|    if (input == NULL) {
  ------------------
  |  Branch (14215:9): [True: 0, False: 432]
  ------------------
14216|      0|	xmlFreeParserInputBuffer(buf);
14217|      0|	xmlFreeParserCtxt(ctxt);
14218|      0|	return(NULL);
14219|      0|    }
14220|       |
14221|    432|    input->filename = NULL;
14222|    432|    input->buf = buf;
14223|    432|    xmlBufResetInput(input->buf->buffer, input);
14224|       |
14225|    432|    inputPush(ctxt, input);
14226|    432|    return(ctxt);
14227|    432|}
xmlCtxtUseOptions:
14693|    646|{
14694|    646|   return(xmlCtxtUseOptionsInternal(ctxt, options, NULL));
14695|    646|}
xmlReadMemory:
14830|    646|{
14831|    646|    xmlParserCtxtPtr ctxt;
14832|       |
14833|    646|    xmlInitParser();
14834|    646|    ctxt = xmlCreateMemoryParserCtxt(buffer, size);
14835|    646|    if (ctxt == NULL)
  ------------------
  |  Branch (14835:9): [True: 2, False: 644]
  ------------------
14836|      2|        return (NULL);
14837|    644|    return (xmlDoRead(ctxt, URL, encoding, options, 0));
14838|    646|}
parser.c:xmlParserNsLookup:
 1485|  73.4k|                  xmlParserNsBucket **bucketPtr) {
 1486|  73.4k|    xmlParserNsBucket *bucket;
 1487|  73.4k|    unsigned index, hashValue;
 1488|       |
 1489|  73.4k|    if (prefix->name == NULL)
  ------------------
  |  Branch (1489:9): [True: 56.5k, False: 16.9k]
  ------------------
 1490|  56.5k|        return(ctxt->nsdb->defaultNsIndex);
 1491|       |
 1492|  16.9k|    if (ctxt->nsdb->hashSize == 0)
  ------------------
  |  Branch (1492:9): [True: 232, False: 16.7k]
  ------------------
 1493|    232|        return(INT_MAX);
 1494|       |
 1495|  16.7k|    hashValue = prefix->hashValue;
 1496|  16.7k|    index = hashValue & (ctxt->nsdb->hashSize - 1);
 1497|  16.7k|    bucket = &ctxt->nsdb->hash[index];
 1498|       |
 1499|  19.7k|    while (bucket->hashValue) {
  ------------------
  |  Branch (1499:12): [True: 19.6k, False: 84]
  ------------------
 1500|  19.6k|        if ((bucket->hashValue == hashValue) &&
  ------------------
  |  Branch (1500:13): [True: 16.6k, False: 2.98k]
  ------------------
 1501|  19.6k|            (bucket->index != INT_MAX)) {
  ------------------
  |  Branch (1501:13): [True: 16.6k, False: 12]
  ------------------
 1502|  16.6k|            if (ctxt->nsTab[bucket->index * 2] == prefix->name) {
  ------------------
  |  Branch (1502:17): [True: 16.6k, False: 0]
  ------------------
 1503|  16.6k|                if (bucketPtr != NULL)
  ------------------
  |  Branch (1503:21): [True: 308, False: 16.3k]
  ------------------
 1504|    308|                    *bucketPtr = bucket;
 1505|  16.6k|                return(bucket->index);
 1506|  16.6k|            }
 1507|  16.6k|        }
 1508|       |
 1509|  2.99k|        index++;
 1510|  2.99k|        bucket++;
 1511|  2.99k|        if (index == ctxt->nsdb->hashSize) {
  ------------------
  |  Branch (1511:13): [True: 0, False: 2.99k]
  ------------------
 1512|      0|            index = 0;
 1513|      0|            bucket = ctxt->nsdb->hash;
 1514|      0|        }
 1515|  2.99k|    }
 1516|       |
 1517|     84|    if (bucketPtr != NULL)
  ------------------
  |  Branch (1517:9): [True: 84, False: 0]
  ------------------
 1518|     84|        *bucketPtr = bucket;
 1519|     84|    return(INT_MAX);
 1520|  16.7k|}
parser.c:xmlFatalErrMsgInt:
  385|     12|{
  386|     12|    if ((ctxt != NULL) && (ctxt->disableSAX != 0) &&
  ------------------
  |  Branch (386:9): [True: 12, False: 0]
  |  Branch (386:27): [True: 4, False: 8]
  ------------------
  387|     12|        (ctxt->instate == XML_PARSER_EOF))
  ------------------
  |  Branch (387:9): [True: 0, False: 4]
  ------------------
  388|      0|	return;
  389|     12|    if (ctxt != NULL)
  ------------------
  |  Branch (389:9): [True: 12, False: 0]
  ------------------
  390|     12|	ctxt->errNo = error;
  391|     12|    __xmlRaiseError(NULL, NULL, NULL,
  392|     12|                    ctxt, NULL, XML_FROM_PARSER, error, XML_ERR_FATAL,
  393|     12|                    NULL, 0, NULL, NULL, NULL, val, 0, msg, val);
  394|     12|    if (ctxt != NULL) {
  ------------------
  |  Branch (394:9): [True: 12, False: 0]
  ------------------
  395|     12|	ctxt->wellFormed = 0;
  396|     12|	if (ctxt->recovery == 0)
  ------------------
  |  Branch (396:6): [True: 12, False: 0]
  ------------------
  397|     12|	    ctxt->disableSAX = 1;
  398|     12|    }
  399|     12|}
parser.c:xmlSaturatedAddSizeT:
  549|   526k|xmlSaturatedAddSizeT(unsigned long *dst, unsigned long val) {
  550|   526k|    if (val > ULONG_MAX - *dst)
  ------------------
  |  Branch (550:9): [True: 0, False: 526k]
  ------------------
  551|      0|        *dst = ULONG_MAX;
  552|   526k|    else
  553|   526k|        *dst += val;
  554|   526k|}
parser.c:xmlSaturatedAdd:
  541|  1.95M|xmlSaturatedAdd(unsigned long *dst, unsigned long val) {
  542|  1.95M|    if (val > ULONG_MAX - *dst)
  ------------------
  |  Branch (542:9): [True: 0, False: 1.95M]
  ------------------
  543|      0|        *dst = ULONG_MAX;
  544|  1.95M|    else
  545|  1.95M|        *dst += val;
  546|  1.95M|}
parser.c:xmlParserEntityCheck:
  582|   522k|{
  583|   522k|    unsigned long consumed;
  584|   522k|    xmlParserInputPtr input = ctxt->input;
  585|   522k|    xmlEntityPtr entity = input->entity;
  586|       |
  587|       |    /*
  588|       |     * Compute total consumed bytes so far, including input streams of
  589|       |     * external entities.
  590|       |     */
  591|   522k|    consumed = input->parentConsumed;
  592|   522k|    if ((entity == NULL) ||
  ------------------
  |  Branch (592:9): [True: 385k, False: 137k]
  ------------------
  593|   522k|        ((entity->etype == XML_EXTERNAL_PARAMETER_ENTITY) &&
  ------------------
  |  Branch (593:10): [True: 13.1k, False: 124k]
  ------------------
  594|   385k|         ((entity->flags & XML_ENT_PARSED) == 0))) {
  ------------------
  |  |   14|  13.1k|#define XML_ENT_PARSED      (1<<0)
  ------------------
  |  Branch (594:10): [True: 4, False: 13.1k]
  ------------------
  595|   385k|        xmlSaturatedAdd(&consumed, input->consumed);
  596|   385k|        xmlSaturatedAddSizeT(&consumed, input->cur - input->base);
  597|   385k|    }
  598|   522k|    xmlSaturatedAdd(&consumed, ctxt->sizeentities);
  599|       |
  600|       |    /*
  601|       |     * Add extra cost and some fixed cost.
  602|       |     */
  603|   522k|    xmlSaturatedAdd(&ctxt->sizeentcopy, extra);
  604|   522k|    xmlSaturatedAdd(&ctxt->sizeentcopy, XML_ENT_FIXED_COST);
  ------------------
  |  |  152|   522k|#define XML_ENT_FIXED_COST 20
  ------------------
  605|       |
  606|       |    /*
  607|       |     * It's important to always use saturation arithmetic when tracking
  608|       |     * entity sizes to make the size checks reliable. If "sizeentcopy"
  609|       |     * overflows, we have to abort.
  610|       |     */
  611|   522k|    if ((ctxt->sizeentcopy > XML_PARSER_ALLOWED_EXPANSION) &&
  ------------------
  |  |  145|   522k|#define XML_PARSER_ALLOWED_EXPANSION 1000000
  ------------------
  |  Branch (611:9): [True: 836, False: 522k]
  ------------------
  612|   522k|        ((ctxt->sizeentcopy >= ULONG_MAX) ||
  ------------------
  |  Branch (612:10): [True: 0, False: 836]
  ------------------
  613|    836|         (ctxt->sizeentcopy / ctxt->maxAmpl > consumed))) {
  ------------------
  |  Branch (613:10): [True: 836, False: 0]
  ------------------
  614|    836|        xmlFatalErrMsg(ctxt, XML_ERR_ENTITY_LOOP,
  615|    836|                       "Maximum entity amplification factor exceeded, see "
  616|    836|                       "xmlCtxtSetMaxAmplification.\n");
  617|    836|        xmlHaltParser(ctxt);
  618|    836|        return(1);
  619|    836|    }
  620|       |
  621|   522k|    return(0);
  622|   522k|}
parser.c:xmlStringDecodeEntitiesInt:
 2798|   213k|                           int check) {
 2799|   213k|    xmlChar *buffer = NULL;
 2800|   213k|    size_t buffer_size = 0;
 2801|   213k|    size_t nbchars = 0;
 2802|       |
 2803|   213k|    xmlChar *current = NULL;
 2804|   213k|    xmlChar *rep = NULL;
 2805|   213k|    const xmlChar *last;
 2806|   213k|    xmlEntityPtr ent;
 2807|   213k|    int c,l;
 2808|       |
 2809|   213k|    if (str == NULL)
  ------------------
  |  Branch (2809:9): [True: 0, False: 213k]
  ------------------
 2810|      0|        return(NULL);
 2811|   213k|    last = str + len;
 2812|       |
 2813|   213k|    if (((ctxt->depth > 40) &&
  ------------------
  |  Branch (2813:10): [True: 0, False: 213k]
  ------------------
 2814|   213k|         ((ctxt->options & XML_PARSE_HUGE) == 0)) ||
  ------------------
  |  Branch (2814:10): [True: 0, False: 0]
  ------------------
 2815|   213k|	(ctxt->depth > 100)) {
  ------------------
  |  Branch (2815:2): [True: 0, False: 213k]
  ------------------
 2816|      0|	xmlFatalErrMsg(ctxt, XML_ERR_ENTITY_LOOP,
 2817|      0|                       "Maximum entity nesting depth exceeded");
 2818|      0|	return(NULL);
 2819|      0|    }
 2820|       |
 2821|       |    /*
 2822|       |     * allocate a translation buffer.
 2823|       |     */
 2824|   213k|    buffer_size = XML_PARSER_BIG_BUFFER_SIZE;
  ------------------
  |  |  166|   213k|#define XML_PARSER_BIG_BUFFER_SIZE 300
  ------------------
 2825|   213k|    buffer = (xmlChar *) xmlMallocAtomic(buffer_size);
 2826|   213k|    if (buffer == NULL) goto mem_error;
  ------------------
  |  Branch (2826:9): [True: 0, False: 213k]
  ------------------
 2827|       |
 2828|       |    /*
 2829|       |     * OK loop until we reach one of the ending char or a size limit.
 2830|       |     * we are operating on already parsed values.
 2831|       |     */
 2832|   213k|    if (str < last)
  ------------------
  |  Branch (2832:9): [True: 213k, False: 208]
  ------------------
 2833|   213k|	c = CUR_SCHAR(str, l);
  ------------------
  |  | 2292|   213k|#define CUR_SCHAR(s, l) xmlStringCurrentChar(ctxt, s, &l)
  ------------------
 2834|    208|    else
 2835|    208|        c = 0;
 2836|  12.4M|    while ((c != 0) && (c != end) && /* non input consuming loop */
  ------------------
  |  Branch (2836:12): [True: 12.1M, False: 213k]
  |  Branch (2836:24): [True: 12.1M, False: 0]
  ------------------
 2837|  12.4M|           (c != end2) && (c != end3) &&
  ------------------
  |  Branch (2837:12): [True: 12.1M, False: 0]
  |  Branch (2837:27): [True: 12.1M, False: 0]
  ------------------
 2838|  12.4M|           (ctxt->instate != XML_PARSER_EOF)) {
  ------------------
  |  Branch (2838:12): [True: 12.1M, False: 0]
  ------------------
 2839|       |
 2840|  12.1M|	if (c == 0) break;
  ------------------
  |  Branch (2840:6): [True: 0, False: 12.1M]
  ------------------
 2841|  12.1M|        if ((c == '&') && (str[1] == '#')) {
  ------------------
  |  Branch (2841:13): [True: 205k, False: 11.9M]
  |  Branch (2841:27): [True: 1.02k, False: 204k]
  ------------------
 2842|  1.02k|	    int val = xmlParseStringCharRef(ctxt, &str);
 2843|  1.02k|	    if (val == 0)
  ------------------
  |  Branch (2843:10): [True: 0, False: 1.02k]
  ------------------
 2844|      0|                goto int_error;
 2845|  1.02k|	    COPY_BUF(buffer, nbchars, val);
  ------------------
  |  | 2295|  1.02k|    if (v < 0x80) b[i++] = v;						\
  |  |  ------------------
  |  |  |  Branch (2295:9): [True: 616, False: 408]
  |  |  ------------------
  |  | 2296|  1.02k|    else i += xmlCopyCharMultiByte(&b[i],v)
  ------------------
 2846|  1.02k|	    if (nbchars + XML_PARSER_BUFFER_SIZE > buffer_size) {
  ------------------
  |  |  167|  1.02k|#define XML_PARSER_BUFFER_SIZE 100
  ------------------
  |  Branch (2846:10): [True: 0, False: 1.02k]
  ------------------
 2847|      0|	        growBuffer(buffer, XML_PARSER_BUFFER_SIZE);
  ------------------
  |  | 2774|      0|#define growBuffer(buffer, n) {						\
  |  | 2775|      0|    xmlChar *tmp;							\
  |  | 2776|      0|    size_t new_size = buffer##_size * 2 + n;                            \
  |  | 2777|      0|    if (new_size < buffer##_size) goto mem_error;                       \
  |  |  ------------------
  |  |  |  Branch (2777:9): [True: 0, False: 0]
  |  |  ------------------
  |  | 2778|      0|    tmp = (xmlChar *) xmlRealloc(buffer, new_size);                     \
  |  | 2779|      0|    if (tmp == NULL) goto mem_error;					\
  |  |  ------------------
  |  |  |  Branch (2779:9): [True: 0, False: 0]
  |  |  ------------------
  |  | 2780|      0|    buffer = tmp;							\
  |  | 2781|      0|    buffer##_size = new_size;                                           \
  |  | 2782|      0|}
  ------------------
 2848|      0|	    }
 2849|  12.1M|	} else if ((c == '&') && (what & XML_SUBSTITUTE_REF)) {
  ------------------
  |  |  521|   204k|#define XML_SUBSTITUTE_REF	1
  ------------------
  |  Branch (2849:13): [True: 204k, False: 11.9M]
  |  Branch (2849:27): [True: 201k, False: 2.47k]
  ------------------
 2850|   201k|	    if (xmlParserDebugEntities)
  ------------------
  |  |  870|   201k|  #define xmlParserDebugEntities XML_GLOBAL_MACRO(xmlParserDebugEntities)
  |  |  ------------------
  |  |  |  |  500|   201k|  #define XML_GLOBAL_MACRO(name) (*__##name())
  |  |  |  |  ------------------
  |  |  |  |  |  Branch (500:34): [True: 0, False: 201k]
  |  |  |  |  ------------------
  |  |  ------------------
  ------------------
 2851|      0|		xmlGenericError(xmlGenericErrorContext,
  ------------------
  |  |  875|      0|  #define xmlGenericError XML_GLOBAL_MACRO(xmlGenericError)
  |  |  ------------------
  |  |  |  |  500|      0|  #define XML_GLOBAL_MACRO(name) (*__##name())
  |  |  ------------------
  ------------------
              		xmlGenericError(xmlGenericErrorContext,
  ------------------
  |  |  876|      0|  #define xmlGenericErrorContext XML_GLOBAL_MACRO(xmlGenericErrorContext)
  |  |  ------------------
  |  |  |  |  500|      0|  #define XML_GLOBAL_MACRO(name) (*__##name())
  |  |  ------------------
  ------------------
 2852|      0|			"String decoding Entity Reference: %.30s\n",
 2853|      0|			str);
 2854|   201k|	    ent = xmlParseStringEntityRef(ctxt, &str);
 2855|   201k|	    if ((ent != NULL) &&
  ------------------
  |  Branch (2855:10): [True: 201k, False: 4]
  ------------------
 2856|   201k|		(ent->etype == XML_INTERNAL_PREDEFINED_ENTITY)) {
  ------------------
  |  Branch (2856:3): [True: 4, False: 201k]
  ------------------
 2857|      4|		if (ent->content != NULL) {
  ------------------
  |  Branch (2857:7): [True: 4, False: 0]
  ------------------
 2858|      4|		    COPY_BUF(buffer, nbchars, ent->content[0]);
  ------------------
  |  | 2295|      4|    if (v < 0x80) b[i++] = v;						\
  |  |  ------------------
  |  |  |  Branch (2295:9): [True: 4, False: 0]
  |  |  ------------------
  |  | 2296|      4|    else i += xmlCopyCharMultiByte(&b[i],v)
  ------------------
 2859|      4|		    if (nbchars + XML_PARSER_BUFFER_SIZE > buffer_size) {
  ------------------
  |  |  167|      4|#define XML_PARSER_BUFFER_SIZE 100
  ------------------
  |  Branch (2859:11): [True: 0, False: 4]
  ------------------
 2860|      0|			growBuffer(buffer, XML_PARSER_BUFFER_SIZE);
  ------------------
  |  | 2774|      0|#define growBuffer(buffer, n) {						\
  |  | 2775|      0|    xmlChar *tmp;							\
  |  | 2776|      0|    size_t new_size = buffer##_size * 2 + n;                            \
  |  | 2777|      0|    if (new_size < buffer##_size) goto mem_error;                       \
  |  |  ------------------
  |  |  |  Branch (2777:9): [True: 0, False: 0]
  |  |  ------------------
  |  | 2778|      0|    tmp = (xmlChar *) xmlRealloc(buffer, new_size);                     \
  |  | 2779|      0|    if (tmp == NULL) goto mem_error;					\
  |  |  ------------------
  |  |  |  Branch (2779:9): [True: 0, False: 0]
  |  |  ------------------
  |  | 2780|      0|    buffer = tmp;							\
  |  | 2781|      0|    buffer##_size = new_size;                                           \
  |  | 2782|      0|}
  ------------------
 2861|      0|		    }
 2862|      4|		} else {
 2863|      0|		    xmlFatalErrMsg(ctxt, XML_ERR_INTERNAL_ERROR,
 2864|      0|			    "predefined entity has no content\n");
 2865|      0|                    goto int_error;
 2866|      0|		}
 2867|   201k|	    } else if ((ent != NULL) && (ent->content != NULL)) {
  ------------------
  |  Branch (2867:17): [True: 201k, False: 4]
  |  Branch (2867:34): [True: 201k, False: 0]
  ------------------
 2868|   201k|	        if ((check) && (xmlParserEntityCheck(ctxt, ent->length)))
  ------------------
  |  Branch (2868:14): [True: 201k, False: 0]
  |  Branch (2868:25): [True: 12, False: 201k]
  ------------------
 2869|     12|                    goto int_error;
 2870|       |
 2871|   201k|                if (ent->flags & XML_ENT_EXPANDING) {
  ------------------
  |  |   16|   201k|#define XML_ENT_EXPANDING   (1<<2)
  ------------------
  |  Branch (2871:21): [True: 4, False: 201k]
  ------------------
 2872|      4|	            xmlFatalErr(ctxt, XML_ERR_ENTITY_LOOP, NULL);
 2873|      4|                    xmlHaltParser(ctxt);
 2874|      4|                    ent->content[0] = 0;
 2875|      4|                    goto int_error;
 2876|      4|                }
 2877|       |
 2878|   201k|                ent->flags |= XML_ENT_EXPANDING;
  ------------------
  |  |   16|   201k|#define XML_ENT_EXPANDING   (1<<2)
  ------------------
 2879|   201k|		ctxt->depth++;
 2880|   201k|		rep = xmlStringDecodeEntitiesInt(ctxt, ent->content,
 2881|   201k|                        ent->length, what, 0, 0, 0, check);
 2882|   201k|		ctxt->depth--;
 2883|   201k|                ent->flags &= ~XML_ENT_EXPANDING;
  ------------------
  |  |   16|   201k|#define XML_ENT_EXPANDING   (1<<2)
  ------------------
 2884|       |
 2885|   201k|		if (rep == NULL) {
  ------------------
  |  Branch (2885:7): [True: 208, False: 201k]
  ------------------
 2886|    208|                    ent->content[0] = 0;
 2887|    208|                    goto int_error;
 2888|    208|                }
 2889|       |
 2890|   201k|                current = rep;
 2891|  23.5M|                while (*current != 0) { /* non input consuming loop */
  ------------------
  |  Branch (2891:24): [True: 23.3M, False: 201k]
  ------------------
 2892|  23.3M|                    buffer[nbchars++] = *current++;
 2893|  23.3M|                    if (nbchars + XML_PARSER_BUFFER_SIZE > buffer_size) {
  ------------------
  |  |  167|  23.3M|#define XML_PARSER_BUFFER_SIZE 100
  ------------------
  |  Branch (2893:25): [True: 10.9k, False: 23.3M]
  ------------------
 2894|  21.9k|                        growBuffer(buffer, XML_PARSER_BUFFER_SIZE);
  ------------------
  |  | 2774|  10.9k|#define growBuffer(buffer, n) {						\
  |  | 2775|  10.9k|    xmlChar *tmp;							\
  |  | 2776|  10.9k|    size_t new_size = buffer##_size * 2 + n;                            \
  |  | 2777|  10.9k|    if (new_size < buffer##_size) goto mem_error;                       \
  |  |  ------------------
  |  |  |  Branch (2777:9): [True: 0, False: 10.9k]
  |  |  ------------------
  |  | 2778|  10.9k|    tmp = (xmlChar *) xmlRealloc(buffer, new_size);                     \
  |  | 2779|  10.9k|    if (tmp == NULL) goto mem_error;					\
  |  |  ------------------
  |  |  |  Branch (2779:9): [True: 0, False: 10.9k]
  |  |  ------------------
  |  | 2780|  10.9k|    buffer = tmp;							\
  |  | 2781|  10.9k|    buffer##_size = new_size;                                           \
  |  | 2782|  10.9k|}
  ------------------
 2895|  21.9k|                    }
 2896|  23.3M|                }
 2897|   201k|                xmlFree(rep);
 2898|   201k|                rep = NULL;
 2899|   201k|	    } else if (ent != NULL) {
  ------------------
  |  Branch (2899:17): [True: 0, False: 4]
  ------------------
 2900|      0|		int i = xmlStrlen(ent->name);
 2901|      0|		const xmlChar *cur = ent->name;
 2902|       |
 2903|      0|		buffer[nbchars++] = '&';
 2904|      0|		if (nbchars + i + XML_PARSER_BUFFER_SIZE > buffer_size) {
  ------------------
  |  |  167|      0|#define XML_PARSER_BUFFER_SIZE 100
  ------------------
  |  Branch (2904:7): [True: 0, False: 0]
  ------------------
 2905|      0|		    growBuffer(buffer, i + XML_PARSER_BUFFER_SIZE);
  ------------------
  |  | 2774|      0|#define growBuffer(buffer, n) {						\
  |  | 2775|      0|    xmlChar *tmp;							\
  |  | 2776|      0|    size_t new_size = buffer##_size * 2 + n;                            \
  |  | 2777|      0|    if (new_size < buffer##_size) goto mem_error;                       \
  |  |  ------------------
  |  |  |  Branch (2777:9): [True: 0, False: 0]
  |  |  ------------------
  |  | 2778|      0|    tmp = (xmlChar *) xmlRealloc(buffer, new_size);                     \
  |  | 2779|      0|    if (tmp == NULL) goto mem_error;					\
  |  |  ------------------
  |  |  |  Branch (2779:9): [True: 0, False: 0]
  |  |  ------------------
  |  | 2780|      0|    buffer = tmp;							\
  |  | 2781|      0|    buffer##_size = new_size;                                           \
  |  | 2782|      0|}
  ------------------
 2906|      0|		}
 2907|      0|		for (;i > 0;i--)
  ------------------
  |  Branch (2907:9): [True: 0, False: 0]
  ------------------
 2908|      0|		    buffer[nbchars++] = *cur++;
 2909|      0|		buffer[nbchars++] = ';';
 2910|      0|	    }
 2911|  11.9M|	} else if (c == '%' && (what & XML_SUBSTITUTE_PEREF)) {
  ------------------
  |  |  527|  1.08k|#define XML_SUBSTITUTE_PEREF	2
  ------------------
  |  Branch (2911:13): [True: 1.08k, False: 11.9M]
  |  Branch (2911:25): [True: 1.08k, False: 0]
  ------------------
 2912|  1.08k|	    if (xmlParserDebugEntities)
  ------------------
  |  |  870|  1.08k|  #define xmlParserDebugEntities XML_GLOBAL_MACRO(xmlParserDebugEntities)
  |  |  ------------------
  |  |  |  |  500|  1.08k|  #define XML_GLOBAL_MACRO(name) (*__##name())
  |  |  |  |  ------------------
  |  |  |  |  |  Branch (500:34): [True: 0, False: 1.08k]
  |  |  |  |  ------------------
  |  |  ------------------
  ------------------
 2913|      0|		xmlGenericError(xmlGenericErrorContext,
  ------------------
  |  |  875|      0|  #define xmlGenericError XML_GLOBAL_MACRO(xmlGenericError)
  |  |  ------------------
  |  |  |  |  500|      0|  #define XML_GLOBAL_MACRO(name) (*__##name())
  |  |  ------------------
  ------------------
              		xmlGenericError(xmlGenericErrorContext,
  ------------------
  |  |  876|      0|  #define xmlGenericErrorContext XML_GLOBAL_MACRO(xmlGenericErrorContext)
  |  |  ------------------
  |  |  |  |  500|      0|  #define XML_GLOBAL_MACRO(name) (*__##name())
  |  |  ------------------
  ------------------
 2914|      0|			"String decoding PE Reference: %.30s\n", str);
 2915|  1.08k|	    ent = xmlParseStringPEReference(ctxt, &str);
 2916|  1.08k|	    if (ent != NULL) {
  ------------------
  |  Branch (2916:10): [True: 1.08k, False: 0]
  ------------------
 2917|  1.08k|                if (ent->content == NULL) {
  ------------------
  |  Branch (2917:21): [True: 8, False: 1.07k]
  ------------------
 2918|       |		    /*
 2919|       |		     * Note: external parsed entities will not be loaded,
 2920|       |		     * it is not required for a non-validating parser to
 2921|       |		     * complete external PEReferences coming from the
 2922|       |		     * internal subset
 2923|       |		     */
 2924|      8|		    if (((ctxt->options & XML_PARSE_NOENT) != 0) ||
  ------------------
  |  Branch (2924:11): [True: 8, False: 0]
  ------------------
 2925|      8|			((ctxt->options & XML_PARSE_DTDVALID) != 0) ||
  ------------------
  |  Branch (2925:4): [True: 0, False: 0]
  ------------------
 2926|      8|			(ctxt->validate != 0)) {
  ------------------
  |  Branch (2926:4): [True: 0, False: 0]
  ------------------
 2927|      8|			xmlLoadEntityContent(ctxt, ent);
 2928|      8|		    } else {
 2929|      0|			xmlWarningMsg(ctxt, XML_ERR_ENTITY_PROCESSING,
 2930|      0|		  "not validating will not read content for PE entity %s\n",
 2931|      0|		                      ent->name, NULL);
 2932|      0|		    }
 2933|      8|		}
 2934|       |
 2935|  1.08k|	        if ((check) && (xmlParserEntityCheck(ctxt, ent->length)))
  ------------------
  |  Branch (2935:14): [True: 1.08k, False: 0]
  |  Branch (2935:25): [True: 8, False: 1.07k]
  ------------------
 2936|      8|                    goto int_error;
 2937|       |
 2938|  1.07k|                if (ent->flags & XML_ENT_EXPANDING) {
  ------------------
  |  |   16|  1.07k|#define XML_ENT_EXPANDING   (1<<2)
  ------------------
  |  Branch (2938:21): [True: 0, False: 1.07k]
  ------------------
 2939|      0|	            xmlFatalErr(ctxt, XML_ERR_ENTITY_LOOP, NULL);
 2940|      0|                    xmlHaltParser(ctxt);
 2941|      0|                    if (ent->content != NULL)
  ------------------
  |  Branch (2941:25): [True: 0, False: 0]
  ------------------
 2942|      0|                        ent->content[0] = 0;
 2943|      0|                    goto int_error;
 2944|      0|                }
 2945|       |
 2946|  1.07k|                ent->flags |= XML_ENT_EXPANDING;
  ------------------
  |  |   16|  1.07k|#define XML_ENT_EXPANDING   (1<<2)
  ------------------
 2947|  1.07k|		ctxt->depth++;
 2948|  1.07k|		rep = xmlStringDecodeEntitiesInt(ctxt, ent->content,
 2949|  1.07k|                        ent->length, what, 0, 0, 0, check);
 2950|  1.07k|		ctxt->depth--;
 2951|  1.07k|                ent->flags &= ~XML_ENT_EXPANDING;
  ------------------
  |  |   16|  1.07k|#define XML_ENT_EXPANDING   (1<<2)
  ------------------
 2952|       |
 2953|  1.07k|		if (rep == NULL) {
  ------------------
  |  Branch (2953:7): [True: 0, False: 1.07k]
  ------------------
 2954|      0|                    if (ent->content != NULL)
  ------------------
  |  Branch (2954:25): [True: 0, False: 0]
  ------------------
 2955|      0|                        ent->content[0] = 0;
 2956|      0|                    goto int_error;
 2957|      0|                }
 2958|  1.07k|                current = rep;
 2959|  5.67M|                while (*current != 0) { /* non input consuming loop */
  ------------------
  |  Branch (2959:24): [True: 5.67M, False: 1.07k]
  ------------------
 2960|  5.67M|                    buffer[nbchars++] = *current++;
 2961|  5.67M|                    if (nbchars + XML_PARSER_BUFFER_SIZE > buffer_size) {
  ------------------
  |  |  167|  5.67M|#define XML_PARSER_BUFFER_SIZE 100
  ------------------
  |  Branch (2961:25): [True: 300, False: 5.67M]
  ------------------
 2962|    600|                        growBuffer(buffer, XML_PARSER_BUFFER_SIZE);
  ------------------
  |  | 2774|    300|#define growBuffer(buffer, n) {						\
  |  | 2775|    300|    xmlChar *tmp;							\
  |  | 2776|    300|    size_t new_size = buffer##_size * 2 + n;                            \
  |  | 2777|    300|    if (new_size < buffer##_size) goto mem_error;                       \
  |  |  ------------------
  |  |  |  Branch (2777:9): [True: 0, False: 300]
  |  |  ------------------
  |  | 2778|    300|    tmp = (xmlChar *) xmlRealloc(buffer, new_size);                     \
  |  | 2779|    300|    if (tmp == NULL) goto mem_error;					\
  |  |  ------------------
  |  |  |  Branch (2779:9): [True: 0, False: 300]
  |  |  ------------------
  |  | 2780|    300|    buffer = tmp;							\
  |  | 2781|    300|    buffer##_size = new_size;                                           \
  |  | 2782|    300|}
  ------------------
 2963|    600|                    }
 2964|  5.67M|                }
 2965|  1.07k|                xmlFree(rep);
 2966|  1.07k|                rep = NULL;
 2967|  1.07k|	    }
 2968|  11.9M|	} else {
 2969|  11.9M|	    COPY_BUF(buffer, nbchars, c);
  ------------------
  |  | 2295|  11.9M|    if (v < 0x80) b[i++] = v;						\
  |  |  ------------------
  |  |  |  Branch (2295:9): [True: 11.9M, False: 36]
  |  |  ------------------
  |  | 2296|  11.9M|    else i += xmlCopyCharMultiByte(&b[i],v)
  ------------------
 2970|  11.9M|	    str += l;
 2971|  11.9M|	    if (nbchars + XML_PARSER_BUFFER_SIZE > buffer_size) {
  ------------------
  |  |  167|  11.9M|#define XML_PARSER_BUFFER_SIZE 100
  ------------------
  |  Branch (2971:10): [True: 2.60k, False: 11.9M]
  ------------------
 2972|  5.21k|	        growBuffer(buffer, XML_PARSER_BUFFER_SIZE);
  ------------------
  |  | 2774|  2.60k|#define growBuffer(buffer, n) {						\
  |  | 2775|  2.60k|    xmlChar *tmp;							\
  |  | 2776|  2.60k|    size_t new_size = buffer##_size * 2 + n;                            \
  |  | 2777|  2.60k|    if (new_size < buffer##_size) goto mem_error;                       \
  |  |  ------------------
  |  |  |  Branch (2777:9): [True: 0, False: 2.60k]
  |  |  ------------------
  |  | 2778|  2.60k|    tmp = (xmlChar *) xmlRealloc(buffer, new_size);                     \
  |  | 2779|  2.60k|    if (tmp == NULL) goto mem_error;					\
  |  |  ------------------
  |  |  |  Branch (2779:9): [True: 0, False: 2.60k]
  |  |  ------------------
  |  | 2780|  2.60k|    buffer = tmp;							\
  |  | 2781|  2.60k|    buffer##_size = new_size;                                           \
  |  | 2782|  2.60k|}
  ------------------
 2973|  5.21k|	    }
 2974|  11.9M|	}
 2975|  12.1M|	if (str < last)
  ------------------
  |  Branch (2975:6): [True: 11.9M, False: 213k]
  ------------------
 2976|  11.9M|	    c = CUR_SCHAR(str, l);
  ------------------
  |  | 2292|  11.9M|#define CUR_SCHAR(s, l) xmlStringCurrentChar(ctxt, s, &l)
  ------------------
 2977|   213k|	else
 2978|   213k|	    c = 0;
 2979|  12.1M|    }
 2980|   213k|    buffer[nbchars] = 0;
 2981|   213k|    return(buffer);
 2982|       |
 2983|      0|mem_error:
 2984|      0|    xmlErrMemory(ctxt, NULL);
 2985|    232|int_error:
 2986|    232|    if (rep != NULL)
  ------------------
  |  Branch (2986:9): [True: 0, False: 232]
  ------------------
 2987|      0|        xmlFree(rep);
 2988|    232|    if (buffer != NULL)
  ------------------
  |  Branch (2988:9): [True: 232, False: 0]
  ------------------
 2989|    232|        xmlFree(buffer);
 2990|    232|    return(NULL);
 2991|      0|}
parser.c:xmlParseStringCharRef:
 2600|  1.02k|xmlParseStringCharRef(xmlParserCtxtPtr ctxt, const xmlChar **str) {
 2601|  1.02k|    const xmlChar *ptr;
 2602|  1.02k|    xmlChar cur;
 2603|  1.02k|    int val = 0;
 2604|       |
 2605|  1.02k|    if ((str == NULL) || (*str == NULL)) return(0);
  ------------------
  |  Branch (2605:9): [True: 0, False: 1.02k]
  |  Branch (2605:26): [True: 0, False: 1.02k]
  ------------------
 2606|  1.02k|    ptr = *str;
 2607|  1.02k|    cur = *ptr;
 2608|  1.02k|    if ((cur == '&') && (ptr[1] == '#') && (ptr[2] == 'x')) {
  ------------------
  |  Branch (2608:9): [True: 1.02k, False: 0]
  |  Branch (2608:25): [True: 1.02k, False: 0]
  |  Branch (2608:44): [True: 44, False: 980]
  ------------------
 2609|     44|	ptr += 3;
 2610|     44|	cur = *ptr;
 2611|    116|	while (cur != ';') { /* Non input consuming loop */
  ------------------
  |  Branch (2611:9): [True: 72, False: 44]
  ------------------
 2612|     72|	    if ((cur >= '0') && (cur <= '9'))
  ------------------
  |  Branch (2612:10): [True: 72, False: 0]
  |  Branch (2612:26): [True: 56, False: 16]
  ------------------
 2613|     56|	        val = val * 16 + (cur - '0');
 2614|     16|	    else if ((cur >= 'a') && (cur <= 'f'))
  ------------------
  |  Branch (2614:15): [True: 0, False: 16]
  |  Branch (2614:31): [True: 0, False: 0]
  ------------------
 2615|      0|	        val = val * 16 + (cur - 'a') + 10;
 2616|     16|	    else if ((cur >= 'A') && (cur <= 'F'))
  ------------------
  |  Branch (2616:15): [True: 16, False: 0]
  |  Branch (2616:31): [True: 16, False: 0]
  ------------------
 2617|     16|	        val = val * 16 + (cur - 'A') + 10;
 2618|      0|	    else {
 2619|      0|		xmlFatalErr(ctxt, XML_ERR_INVALID_HEX_CHARREF, NULL);
 2620|      0|		val = 0;
 2621|      0|		break;
 2622|      0|	    }
 2623|     72|	    if (val > 0x110000)
  ------------------
  |  Branch (2623:10): [True: 0, False: 72]
  ------------------
 2624|      0|	        val = 0x110000;
 2625|       |
 2626|     72|	    ptr++;
 2627|     72|	    cur = *ptr;
 2628|     72|	}
 2629|     44|	if (cur == ';')
  ------------------
  |  Branch (2629:6): [True: 44, False: 0]
  ------------------
 2630|     44|	    ptr++;
 2631|    980|    } else if  ((cur == '&') && (ptr[1] == '#')){
  ------------------
  |  Branch (2631:17): [True: 980, False: 0]
  |  Branch (2631:33): [True: 980, False: 0]
  ------------------
 2632|    980|	ptr += 2;
 2633|    980|	cur = *ptr;
 2634|  3.35k|	while (cur != ';') { /* Non input consuming loops */
  ------------------
  |  Branch (2634:9): [True: 2.37k, False: 980]
  ------------------
 2635|  2.37k|	    if ((cur >= '0') && (cur <= '9'))
  ------------------
  |  Branch (2635:10): [True: 2.37k, False: 0]
  |  Branch (2635:26): [True: 2.37k, False: 0]
  ------------------
 2636|  2.37k|	        val = val * 10 + (cur - '0');
 2637|      0|	    else {
 2638|      0|		xmlFatalErr(ctxt, XML_ERR_INVALID_DEC_CHARREF, NULL);
 2639|      0|		val = 0;
 2640|      0|		break;
 2641|      0|	    }
 2642|  2.37k|	    if (val > 0x110000)
  ------------------
  |  Branch (2642:10): [True: 0, False: 2.37k]
  ------------------
 2643|      0|	        val = 0x110000;
 2644|       |
 2645|  2.37k|	    ptr++;
 2646|  2.37k|	    cur = *ptr;
 2647|  2.37k|	}
 2648|    980|	if (cur == ';')
  ------------------
  |  Branch (2648:6): [True: 980, False: 0]
  ------------------
 2649|    980|	    ptr++;
 2650|    980|    } else {
 2651|      0|	xmlFatalErr(ctxt, XML_ERR_INVALID_CHARREF, NULL);
 2652|      0|	return(0);
 2653|      0|    }
 2654|  1.02k|    *str = ptr;
 2655|       |
 2656|       |    /*
 2657|       |     * [ WFC: Legal Character ]
 2658|       |     * Characters referred to using character references must match the
 2659|       |     * production for Char.
 2660|       |     */
 2661|  1.02k|    if (val >= 0x110000) {
  ------------------
  |  Branch (2661:9): [True: 0, False: 1.02k]
  ------------------
 2662|      0|        xmlFatalErrMsgInt(ctxt, XML_ERR_INVALID_CHAR,
 2663|      0|                "xmlParseStringCharRef: character reference out of bounds\n",
 2664|      0|                val);
 2665|  1.02k|    } else if (IS_CHAR(val)) {
  ------------------
  |  |  125|  1.02k|#define IS_CHAR(c)   xmlIsCharQ(c)
  |  |  ------------------
  |  |  |  |  118|  1.02k|#define xmlIsCharQ(c)		(((c) < 0x100) ? \
  |  |  |  |  ------------------
  |  |  |  |  |  Branch (118:24): [True: 1.02k, False: 0]
  |  |  |  |  |  Branch (118:25): [True: 1.01k, False: 8]
  |  |  |  |  ------------------
  |  |  |  |  119|  1.02k|				 xmlIsChar_ch((c)) :\
  |  |  |  |  ------------------
  |  |  |  |  |  |  108|  1.01k|#define xmlIsChar_ch(c)		(((0x9 <= (c)) && ((c) <= 0xa)) || \
  |  |  |  |  |  |  ------------------
  |  |  |  |  |  |  |  Branch (108:28): [True: 1.01k, False: 0]
  |  |  |  |  |  |  |  Branch (108:44): [True: 8, False: 1.00k]
  |  |  |  |  |  |  ------------------
  |  |  |  |  |  |  109|  1.01k|				 ((c) == 0xd) || \
  |  |  |  |  |  |  ------------------
  |  |  |  |  |  |  |  Branch (109:6): [True: 12, False: 996]
  |  |  |  |  |  |  ------------------
  |  |  |  |  |  |  110|  1.01k|				  (0x20 <= (c)))
  |  |  |  |  |  |  ------------------
  |  |  |  |  |  |  |  Branch (110:7): [True: 996, False: 0]
  |  |  |  |  |  |  ------------------
  |  |  |  |  ------------------
  |  |  |  |  120|  1.02k|				(((0x100 <= (c)) && ((c) <= 0xd7ff)) || \
  |  |  |  |  ------------------
  |  |  |  |  |  Branch (120:7): [True: 8, False: 0]
  |  |  |  |  |  Branch (120:25): [True: 8, False: 0]
  |  |  |  |  ------------------
  |  |  |  |  121|      8|				 ((0xe000 <= (c)) && ((c) <= 0xfffd)) || \
  |  |  |  |  ------------------
  |  |  |  |  |  Branch (121:7): [True: 0, False: 0]
  |  |  |  |  |  Branch (121:26): [True: 0, False: 0]
  |  |  |  |  ------------------
  |  |  |  |  122|      8|				 ((0x10000 <= (c)) && ((c) <= 0x10ffff))))
  |  |  |  |  ------------------
  |  |  |  |  |  Branch (122:7): [True: 0, False: 0]
  |  |  |  |  |  Branch (122:27): [True: 0, False: 0]
  |  |  |  |  ------------------
  |  |  ------------------
  ------------------
 2666|  1.02k|        return(val);
 2667|  1.02k|    } else {
 2668|      0|        xmlFatalErrMsgInt(ctxt, XML_ERR_INVALID_CHAR,
 2669|      0|			  "xmlParseStringCharRef: invalid xmlChar value %d\n",
 2670|      0|			  val);
 2671|      0|    }
 2672|      0|    return(0);
 2673|  1.02k|}
parser.c:xmlParseStringEntityRef:
 7863|   201k|xmlParseStringEntityRef(xmlParserCtxtPtr ctxt, const xmlChar ** str) {
 7864|   201k|    xmlChar *name;
 7865|   201k|    const xmlChar *ptr;
 7866|   201k|    xmlChar cur;
 7867|   201k|    xmlEntityPtr ent = NULL;
 7868|       |
 7869|   201k|    if ((str == NULL) || (*str == NULL))
  ------------------
  |  Branch (7869:9): [True: 0, False: 201k]
  |  Branch (7869:26): [True: 0, False: 201k]
  ------------------
 7870|      0|        return(NULL);
 7871|   201k|    ptr = *str;
 7872|   201k|    cur = *ptr;
 7873|   201k|    if (cur != '&')
  ------------------
  |  Branch (7873:9): [True: 0, False: 201k]
  ------------------
 7874|      0|	return(NULL);
 7875|       |
 7876|   201k|    ptr++;
 7877|   201k|    name = xmlParseStringName(ctxt, &ptr);
 7878|   201k|    if (name == NULL) {
  ------------------
  |  Branch (7878:9): [True: 0, False: 201k]
  ------------------
 7879|      0|	xmlFatalErrMsg(ctxt, XML_ERR_NAME_REQUIRED,
 7880|      0|		       "xmlParseStringEntityRef: no name\n");
 7881|      0|	*str = ptr;
 7882|      0|	return(NULL);
 7883|      0|    }
 7884|   201k|    if (*ptr != ';') {
  ------------------
  |  Branch (7884:9): [True: 0, False: 201k]
  ------------------
 7885|      0|	xmlFatalErr(ctxt, XML_ERR_ENTITYREF_SEMICOL_MISSING, NULL);
 7886|      0|        xmlFree(name);
 7887|      0|	*str = ptr;
 7888|      0|	return(NULL);
 7889|      0|    }
 7890|   201k|    ptr++;
 7891|       |
 7892|       |
 7893|       |    /*
 7894|       |     * Predefined entities override any extra definition
 7895|       |     */
 7896|   201k|    if ((ctxt->options & XML_PARSE_OLDSAX) == 0) {
  ------------------
  |  Branch (7896:9): [True: 201k, False: 0]
  ------------------
 7897|   201k|        ent = xmlGetPredefinedEntity(name);
 7898|   201k|        if (ent != NULL) {
  ------------------
  |  Branch (7898:13): [True: 4, False: 201k]
  ------------------
 7899|      4|            xmlFree(name);
 7900|      4|            *str = ptr;
 7901|      4|            return(ent);
 7902|      4|        }
 7903|   201k|    }
 7904|       |
 7905|       |    /*
 7906|       |     * Ask first SAX for entity resolution, otherwise try the
 7907|       |     * entities which may have stored in the parser context.
 7908|       |     */
 7909|   201k|    if (ctxt->sax != NULL) {
  ------------------
  |  Branch (7909:9): [True: 201k, False: 0]
  ------------------
 7910|   201k|	if (ctxt->sax->getEntity != NULL)
  ------------------
  |  Branch (7910:6): [True: 201k, False: 0]
  ------------------
 7911|   201k|	    ent = ctxt->sax->getEntity(ctxt->userData, name);
 7912|   201k|	if ((ent == NULL) && (ctxt->options & XML_PARSE_OLDSAX))
  ------------------
  |  Branch (7912:6): [True: 4, False: 201k]
  |  Branch (7912:23): [True: 0, False: 4]
  ------------------
 7913|      0|	    ent = xmlGetPredefinedEntity(name);
 7914|   201k|	if ((ent == NULL) && (ctxt->userData==ctxt)) {
  ------------------
  |  Branch (7914:6): [True: 4, False: 201k]
  |  Branch (7914:23): [True: 4, False: 0]
  ------------------
 7915|      4|	    ent = xmlSAX2GetEntity(ctxt, name);
 7916|      4|	}
 7917|   201k|    }
 7918|   201k|    if (ctxt->instate == XML_PARSER_EOF) {
  ------------------
  |  Branch (7918:9): [True: 0, False: 201k]
  ------------------
 7919|      0|	xmlFree(name);
 7920|      0|	return(NULL);
 7921|      0|    }
 7922|       |
 7923|       |    /*
 7924|       |     * [ WFC: Entity Declared ]
 7925|       |     * In a document without any DTD, a document with only an
 7926|       |     * internal DTD subset which contains no parameter entity
 7927|       |     * references, or a document with "standalone='yes'", the
 7928|       |     * Name given in the entity reference must match that in an
 7929|       |     * entity declaration, except that well-formed documents
 7930|       |     * need not declare any of the following entities: amp, lt,
 7931|       |     * gt, apos, quot.
 7932|       |     * The declaration of a parameter entity must precede any
 7933|       |     * reference to it.
 7934|       |     * Similarly, the declaration of a general entity must
 7935|       |     * precede any reference to it which appears in a default
 7936|       |     * value in an attribute-list declaration. Note that if
 7937|       |     * entities are declared in the external subset or in
 7938|       |     * external parameter entities, a non-validating processor
 7939|       |     * is not obligated to read and process their declarations;
 7940|       |     * for such documents, the rule that an entity must be
 7941|       |     * declared is a well-formedness constraint only if
 7942|       |     * standalone='yes'.
 7943|       |     */
 7944|   201k|    if (ent == NULL) {
  ------------------
  |  Branch (7944:9): [True: 4, False: 201k]
  ------------------
 7945|      4|	if ((ctxt->standalone == 1) ||
  ------------------
  |  Branch (7945:6): [True: 0, False: 4]
  ------------------
 7946|      4|	    ((ctxt->hasExternalSubset == 0) &&
  ------------------
  |  Branch (7946:7): [True: 0, False: 4]
  ------------------
 7947|      4|	     (ctxt->hasPErefs == 0))) {
  ------------------
  |  Branch (7947:7): [True: 0, False: 0]
  ------------------
 7948|      0|	    xmlFatalErrMsgStr(ctxt, XML_ERR_UNDECLARED_ENTITY,
 7949|      0|		     "Entity '%s' not defined\n", name);
 7950|      4|	} else {
 7951|      4|	    xmlErrMsgStr(ctxt, XML_WAR_UNDECLARED_ENTITY,
 7952|      4|			  "Entity '%s' not defined\n",
 7953|      4|			  name);
 7954|      4|	}
 7955|       |	/* TODO ? check regressions ctxt->valid = 0; */
 7956|      4|    }
 7957|       |
 7958|       |    /*
 7959|       |     * [ WFC: Parsed Entity ]
 7960|       |     * An entity reference must not contain the name of an
 7961|       |     * unparsed entity
 7962|       |     */
 7963|   201k|    else if (ent->etype == XML_EXTERNAL_GENERAL_UNPARSED_ENTITY) {
  ------------------
  |  Branch (7963:14): [True: 0, False: 201k]
  ------------------
 7964|      0|	xmlFatalErrMsgStr(ctxt, XML_ERR_UNPARSED_ENTITY,
 7965|      0|		 "Entity reference to unparsed entity %s\n", name);
 7966|      0|    }
 7967|       |
 7968|       |    /*
 7969|       |     * [ WFC: No External Entity References ]
 7970|       |     * Attribute values cannot contain direct or indirect
 7971|       |     * entity references to external entities.
 7972|       |     */
 7973|   201k|    else if ((ctxt->instate == XML_PARSER_ATTRIBUTE_VALUE) &&
  ------------------
  |  Branch (7973:14): [True: 201k, False: 0]
  ------------------
 7974|   201k|	     (ent->etype == XML_EXTERNAL_GENERAL_PARSED_ENTITY)) {
  ------------------
  |  Branch (7974:7): [True: 0, False: 201k]
  ------------------
 7975|      0|	xmlFatalErrMsgStr(ctxt, XML_ERR_ENTITY_IS_EXTERNAL,
 7976|      0|	 "Attribute references external entity '%s'\n", name);
 7977|      0|    }
 7978|       |    /*
 7979|       |     * [ WFC: No < in Attribute Values ]
 7980|       |     * The replacement text of any entity referred to directly or
 7981|       |     * indirectly in an attribute value (other than "&lt;") must
 7982|       |     * not contain a <.
 7983|       |     */
 7984|   201k|    else if ((ctxt->instate == XML_PARSER_ATTRIBUTE_VALUE) &&
  ------------------
  |  Branch (7984:14): [True: 201k, False: 0]
  ------------------
 7985|   201k|	     (ent->etype != XML_INTERNAL_PREDEFINED_ENTITY)) {
  ------------------
  |  Branch (7985:7): [True: 201k, False: 0]
  ------------------
 7986|   201k|	if ((ent->flags & XML_ENT_CHECKED_LT) == 0) {
  ------------------
  |  |   17|   201k|#define XML_ENT_CHECKED_LT  (1<<3)
  ------------------
  |  Branch (7986:6): [True: 240, False: 201k]
  ------------------
 7987|    240|            if ((ent->content != NULL) && (xmlStrchr(ent->content, '<')))
  ------------------
  |  Branch (7987:17): [True: 240, False: 0]
  |  Branch (7987:43): [True: 0, False: 240]
  ------------------
 7988|      0|                ent->flags |= XML_ENT_CONTAINS_LT;
  ------------------
  |  |   18|      0|#define XML_ENT_CONTAINS_LT (1<<4)
  ------------------
 7989|    240|            ent->flags |= XML_ENT_CHECKED_LT;
  ------------------
  |  |   17|    240|#define XML_ENT_CHECKED_LT  (1<<3)
  ------------------
 7990|    240|        }
 7991|   201k|        if (ent->flags & XML_ENT_CONTAINS_LT)
  ------------------
  |  |   18|   201k|#define XML_ENT_CONTAINS_LT (1<<4)
  ------------------
  |  Branch (7991:13): [True: 0, False: 201k]
  ------------------
 7992|      0|            xmlFatalErrMsgStr(ctxt, XML_ERR_LT_IN_ATTRIBUTE,
 7993|      0|                    "'<' in entity '%s' is not allowed in attributes "
 7994|      0|                    "values\n", name);
 7995|   201k|    }
 7996|       |
 7997|       |    /*
 7998|       |     * Internal check, no parameter entities here ...
 7999|       |     */
 8000|      0|    else {
 8001|      0|	switch (ent->etype) {
 8002|      0|	    case XML_INTERNAL_PARAMETER_ENTITY:
  ------------------
  |  Branch (8002:6): [True: 0, False: 0]
  ------------------
 8003|      0|	    case XML_EXTERNAL_PARAMETER_ENTITY:
  ------------------
  |  Branch (8003:6): [True: 0, False: 0]
  ------------------
 8004|      0|		xmlFatalErrMsgStr(ctxt, XML_ERR_ENTITY_IS_PARAMETER,
 8005|      0|	     "Attempt to reference the parameter entity '%s'\n",
 8006|      0|				  name);
 8007|      0|	    break;
 8008|      0|	    default:
  ------------------
  |  Branch (8008:6): [True: 0, False: 0]
  ------------------
 8009|      0|	    break;
 8010|      0|	}
 8011|      0|    }
 8012|       |
 8013|       |    /*
 8014|       |     * [ WFC: No Recursion ]
 8015|       |     * A parsed entity must not contain a recursive reference
 8016|       |     * to itself, either directly or indirectly.
 8017|       |     * Done somewhere else
 8018|       |     */
 8019|       |
 8020|   201k|    xmlFree(name);
 8021|   201k|    *str = ptr;
 8022|   201k|    return(ent);
 8023|   201k|}
parser.c:xmlParseStringPEReference:
 8362|  1.08k|xmlParseStringPEReference(xmlParserCtxtPtr ctxt, const xmlChar **str) {
 8363|  1.08k|    const xmlChar *ptr;
 8364|  1.08k|    xmlChar cur;
 8365|  1.08k|    xmlChar *name;
 8366|  1.08k|    xmlEntityPtr entity = NULL;
 8367|       |
 8368|  1.08k|    if ((str == NULL) || (*str == NULL)) return(NULL);
  ------------------
  |  Branch (8368:9): [True: 0, False: 1.08k]
  |  Branch (8368:26): [True: 0, False: 1.08k]
  ------------------
 8369|  1.08k|    ptr = *str;
 8370|  1.08k|    cur = *ptr;
 8371|  1.08k|    if (cur != '%')
  ------------------
  |  Branch (8371:9): [True: 0, False: 1.08k]
  ------------------
 8372|      0|        return(NULL);
 8373|  1.08k|    ptr++;
 8374|  1.08k|    name = xmlParseStringName(ctxt, &ptr);
 8375|  1.08k|    if (name == NULL) {
  ------------------
  |  Branch (8375:9): [True: 0, False: 1.08k]
  ------------------
 8376|      0|	xmlFatalErrMsg(ctxt, XML_ERR_NAME_REQUIRED,
 8377|      0|		       "xmlParseStringPEReference: no name\n");
 8378|      0|	*str = ptr;
 8379|      0|	return(NULL);
 8380|      0|    }
 8381|  1.08k|    cur = *ptr;
 8382|  1.08k|    if (cur != ';') {
  ------------------
  |  Branch (8382:9): [True: 0, False: 1.08k]
  ------------------
 8383|      0|	xmlFatalErr(ctxt, XML_ERR_ENTITYREF_SEMICOL_MISSING, NULL);
 8384|      0|	xmlFree(name);
 8385|      0|	*str = ptr;
 8386|      0|	return(NULL);
 8387|      0|    }
 8388|  1.08k|    ptr++;
 8389|       |
 8390|       |    /*
 8391|       |     * Request the entity from SAX
 8392|       |     */
 8393|  1.08k|    if ((ctxt->sax != NULL) &&
  ------------------
  |  Branch (8393:9): [True: 1.08k, False: 0]
  ------------------
 8394|  1.08k|	(ctxt->sax->getParameterEntity != NULL))
  ------------------
  |  Branch (8394:2): [True: 1.08k, False: 0]
  ------------------
 8395|  1.08k|	entity = ctxt->sax->getParameterEntity(ctxt->userData, name);
 8396|  1.08k|    if (ctxt->instate == XML_PARSER_EOF) {
  ------------------
  |  Branch (8396:9): [True: 0, False: 1.08k]
  ------------------
 8397|      0|	xmlFree(name);
 8398|      0|	*str = ptr;
 8399|      0|	return(NULL);
 8400|      0|    }
 8401|  1.08k|    if (entity == NULL) {
  ------------------
  |  Branch (8401:9): [True: 0, False: 1.08k]
  ------------------
 8402|       |	/*
 8403|       |	 * [ WFC: Entity Declared ]
 8404|       |	 * In a document without any DTD, a document with only an
 8405|       |	 * internal DTD subset which contains no parameter entity
 8406|       |	 * references, or a document with "standalone='yes'", ...
 8407|       |	 * ... The declaration of a parameter entity must precede
 8408|       |	 * any reference to it...
 8409|       |	 */
 8410|      0|	if ((ctxt->standalone == 1) ||
  ------------------
  |  Branch (8410:6): [True: 0, False: 0]
  ------------------
 8411|      0|	    ((ctxt->hasExternalSubset == 0) && (ctxt->hasPErefs == 0))) {
  ------------------
  |  Branch (8411:7): [True: 0, False: 0]
  |  Branch (8411:41): [True: 0, False: 0]
  ------------------
 8412|      0|	    xmlFatalErrMsgStr(ctxt, XML_ERR_UNDECLARED_ENTITY,
 8413|      0|		 "PEReference: %%%s; not found\n", name);
 8414|      0|	} else {
 8415|       |	    /*
 8416|       |	     * [ VC: Entity Declared ]
 8417|       |	     * In a document with an external subset or external
 8418|       |	     * parameter entities with "standalone='no'", ...
 8419|       |	     * ... The declaration of a parameter entity must
 8420|       |	     * precede any reference to it...
 8421|       |	     */
 8422|      0|	    xmlWarningMsg(ctxt, XML_WAR_UNDECLARED_ENTITY,
 8423|      0|			  "PEReference: %%%s; not found\n",
 8424|      0|			  name, NULL);
 8425|      0|	    ctxt->valid = 0;
 8426|      0|	}
 8427|  1.08k|    } else {
 8428|       |	/*
 8429|       |	 * Internal checking in case the entity quest barfed
 8430|       |	 */
 8431|  1.08k|	if ((entity->etype != XML_INTERNAL_PARAMETER_ENTITY) &&
  ------------------
  |  Branch (8431:6): [True: 8, False: 1.07k]
  ------------------
 8432|  1.08k|	    (entity->etype != XML_EXTERNAL_PARAMETER_ENTITY)) {
  ------------------
  |  Branch (8432:6): [True: 0, False: 8]
  ------------------
 8433|      0|	    xmlWarningMsg(ctxt, XML_WAR_UNDECLARED_ENTITY,
 8434|      0|			  "%%%s; is not a parameter entity\n",
 8435|      0|			  name, NULL);
 8436|      0|	}
 8437|  1.08k|    }
 8438|  1.08k|    ctxt->hasPErefs = 1;
 8439|  1.08k|    xmlFree(name);
 8440|  1.08k|    *str = ptr;
 8441|  1.08k|    return(entity);
 8442|  1.08k|}
parser.c:xmlLoadEntityContent:
 8197|      8|xmlLoadEntityContent(xmlParserCtxtPtr ctxt, xmlEntityPtr entity) {
 8198|      8|    xmlParserInputPtr oldinput, input = NULL;
 8199|      8|    xmlParserInputPtr *oldinputTab;
 8200|      8|    const xmlChar *oldencoding;
 8201|      8|    xmlChar *content = NULL;
 8202|      8|    size_t length, i;
 8203|      8|    int oldinputNr, oldinputMax, oldprogressive;
 8204|      8|    int ret = -1;
 8205|      8|    int res;
 8206|       |
 8207|      8|    if ((ctxt == NULL) || (entity == NULL) ||
  ------------------
  |  Branch (8207:9): [True: 0, False: 8]
  |  Branch (8207:27): [True: 0, False: 8]
  ------------------
 8208|      8|        ((entity->etype != XML_EXTERNAL_PARAMETER_ENTITY) &&
  ------------------
  |  Branch (8208:10): [True: 0, False: 8]
  ------------------
 8209|      8|	 (entity->etype != XML_EXTERNAL_GENERAL_PARSED_ENTITY)) ||
  ------------------
  |  Branch (8209:3): [True: 0, False: 0]
  ------------------
 8210|      8|	(entity->content != NULL)) {
  ------------------
  |  Branch (8210:2): [True: 0, False: 8]
  ------------------
 8211|      0|	xmlFatalErr(ctxt, XML_ERR_INTERNAL_ERROR,
 8212|      0|	            "xmlLoadEntityContent parameter error");
 8213|      0|        return(-1);
 8214|      0|    }
 8215|       |
 8216|      8|    if (xmlParserDebugEntities)
  ------------------
  |  |  870|      8|  #define xmlParserDebugEntities XML_GLOBAL_MACRO(xmlParserDebugEntities)
  |  |  ------------------
  |  |  |  |  500|      8|  #define XML_GLOBAL_MACRO(name) (*__##name())
  |  |  |  |  ------------------
  |  |  |  |  |  Branch (500:34): [True: 0, False: 8]
  |  |  |  |  ------------------
  |  |  ------------------
  ------------------
 8217|      0|	xmlGenericError(xmlGenericErrorContext,
  ------------------
  |  |  875|      0|  #define xmlGenericError XML_GLOBAL_MACRO(xmlGenericError)
  |  |  ------------------
  |  |  |  |  500|      0|  #define XML_GLOBAL_MACRO(name) (*__##name())
  |  |  ------------------
  ------------------
              	xmlGenericError(xmlGenericErrorContext,
  ------------------
  |  |  876|      0|  #define xmlGenericErrorContext XML_GLOBAL_MACRO(xmlGenericErrorContext)
  |  |  ------------------
  |  |  |  |  500|      0|  #define XML_GLOBAL_MACRO(name) (*__##name())
  |  |  ------------------
  ------------------
 8218|      0|		"Reading %s entity content input\n", entity->name);
 8219|       |
 8220|      8|    input = xmlLoadExternalEntity((char *) entity->URI,
 8221|      8|           (char *) entity->ExternalID, ctxt);
 8222|      8|    if (input == NULL) {
  ------------------
  |  Branch (8222:9): [True: 0, False: 8]
  ------------------
 8223|      0|	xmlFatalErr(ctxt, XML_ERR_INTERNAL_ERROR,
 8224|      0|	            "xmlLoadEntityContent input error");
 8225|      0|        return(-1);
 8226|      0|    }
 8227|       |
 8228|      8|    oldinput = ctxt->input;
 8229|      8|    oldinputNr = ctxt->inputNr;
 8230|      8|    oldinputMax = ctxt->inputMax;
 8231|      8|    oldinputTab = ctxt->inputTab;
 8232|      8|    oldencoding = ctxt->encoding;
 8233|      8|    oldprogressive = ctxt->progressive;
 8234|       |
 8235|      8|    ctxt->input = NULL;
 8236|      8|    ctxt->inputNr = 0;
 8237|      8|    ctxt->inputMax = 1;
 8238|      8|    ctxt->encoding = NULL;
 8239|      8|    ctxt->progressive = 0;
 8240|      8|    ctxt->inputTab = xmlMalloc(sizeof(xmlParserInputPtr));
 8241|      8|    if (ctxt->inputTab == NULL) {
  ------------------
  |  Branch (8241:9): [True: 0, False: 8]
  ------------------
 8242|      0|        xmlErrMemory(ctxt, NULL);
 8243|      0|        xmlFreeInputStream(input);
 8244|      0|        goto error;
 8245|      0|    }
 8246|       |
 8247|      8|    xmlBufResetInput(input->buf->buffer, input);
 8248|       |
 8249|      8|    inputPush(ctxt, input);
 8250|       |
 8251|      8|    xmlDetectEncoding(ctxt);
 8252|       |
 8253|       |    /*
 8254|       |     * Parse a possible text declaration first
 8255|       |     */
 8256|      8|    if ((CMP5(CUR_PTR, '<', '?', 'x', 'm', 'l')) && (IS_BLANK_CH(NXT(5)))) {
  ------------------
  |  | 2231|      8|  ( CMP4( s, c1, c2, c3, c4 ) && ((unsigned char *) s)[ 4 ] == c5 )
  |  |  ------------------
  |  |  |  | 2228|     16|  ( ((unsigned char *) s)[ 0 ] == c1 && ((unsigned char *) s)[ 1 ] == c2 && \
  |  |  |  |  ------------------
  |  |  |  |  |  Branch (2228:5): [True: 8, False: 0]
  |  |  |  |  |  Branch (2228:41): [True: 4, False: 4]
  |  |  |  |  ------------------
  |  |  |  | 2229|      8|    ((unsigned char *) s)[ 2 ] == c3 && ((unsigned char *) s)[ 3 ] == c4 )
  |  |  |  |  ------------------
  |  |  |  |  |  Branch (2229:5): [True: 4, False: 0]
  |  |  |  |  |  Branch (2229:41): [True: 4, False: 0]
  |  |  |  |  ------------------
  |  |  ------------------
  |  |  |  Branch (2231:34): [True: 4, False: 0]
  |  |  ------------------
  ------------------
                  if ((CMP5(CUR_PTR, '<', '?', 'x', 'm', 'l')) && (IS_BLANK_CH(NXT(5)))) {
  ------------------
  |  |  151|      4|#define IS_BLANK_CH(c)  xmlIsBlank_ch(c)
  |  |  ------------------
  |  |  |  |   88|      4|#define xmlIsBlank_ch(c)	(((c) == 0x20) || \
  |  |  |  |  ------------------
  |  |  |  |  |  Branch (88:27): [True: 4, False: 0]
  |  |  |  |  ------------------
  |  |  |  |   89|      4|				 ((0x9 <= (c)) && ((c) <= 0xa)) || \
  |  |  |  |  ------------------
  |  |  |  |  |  Branch (89:7): [True: 0, False: 0]
  |  |  |  |  |  Branch (89:23): [True: 0, False: 0]
  |  |  |  |  ------------------
  |  |  |  |   90|      4|				 ((c) == 0xd))
  |  |  |  |  ------------------
  |  |  |  |  |  Branch (90:6): [True: 0, False: 0]
  |  |  |  |  ------------------
  |  |  ------------------
  ------------------
 8257|      4|	xmlParseTextDecl(ctxt);
 8258|       |        /*
 8259|       |         * An XML-1.0 document can't reference an entity not XML-1.0
 8260|       |         */
 8261|      4|        if ((xmlStrEqual(ctxt->version, BAD_CAST "1.0")) &&
  ------------------
  |  |   35|      4|#define BAD_CAST (xmlChar *)
  ------------------
  |  Branch (8261:13): [True: 4, False: 0]
  ------------------
 8262|      4|            (!xmlStrEqual(ctxt->input->version, BAD_CAST "1.0"))) {
  ------------------
  |  |   35|      4|#define BAD_CAST (xmlChar *)
  ------------------
  |  Branch (8262:13): [True: 0, False: 4]
  ------------------
 8263|      0|            xmlFatalErrMsg(ctxt, XML_ERR_VERSION_MISMATCH,
 8264|      0|                           "Version mismatch between document and entity\n");
 8265|      0|        }
 8266|      4|    }
 8267|       |
 8268|      8|    if (ctxt->instate == XML_PARSER_EOF)
  ------------------
  |  Branch (8268:9): [True: 0, False: 8]
  ------------------
 8269|      0|        goto error;
 8270|       |
 8271|      8|    length = input->cur - input->base;
 8272|      8|    xmlBufShrink(input->buf->buffer, length);
 8273|      8|    xmlSaturatedAdd(&ctxt->sizeentities, length);
 8274|       |
 8275|      8|    while ((res = xmlParserInputBufferGrow(input->buf, 4096)) > 0)
  ------------------
  |  Branch (8275:12): [True: 0, False: 8]
  ------------------
 8276|      0|        ;
 8277|       |
 8278|      8|    xmlBufResetInput(input->buf->buffer, input);
 8279|       |
 8280|      8|    if (res < 0) {
  ------------------
  |  Branch (8280:9): [True: 0, False: 8]
  ------------------
 8281|      0|        xmlFatalErr(ctxt, input->buf->error, NULL);
 8282|      0|        goto error;
 8283|      0|    }
 8284|       |
 8285|      8|    length = xmlBufUse(input->buf->buffer);
 8286|      8|    content = xmlBufDetach(input->buf->buffer);
 8287|       |
 8288|      8|    if (length > INT_MAX) {
  ------------------
  |  Branch (8288:9): [True: 0, False: 8]
  ------------------
 8289|      0|        xmlErrMemory(ctxt, NULL);
 8290|      0|        goto error;
 8291|      0|    }
 8292|       |
 8293|    196|    for (i = 0; i < length; ) {
  ------------------
  |  Branch (8293:17): [True: 188, False: 8]
  ------------------
 8294|    188|        int clen = length - i;
 8295|    188|        int c = xmlGetUTF8Char(content + i, &clen);
 8296|       |
 8297|    188|        if ((c < 0) || (!IS_CHAR(c))) {
  ------------------
  |  |  125|    188|#define IS_CHAR(c)   xmlIsCharQ(c)
  |  |  ------------------
  |  |  |  |  118|    188|#define xmlIsCharQ(c)		(((c) < 0x100) ? \
  |  |  |  |  ------------------
  |  |  |  |  |  Branch (118:25): [True: 188, False: 0]
  |  |  |  |  ------------------
  |  |  |  |  119|    188|				 xmlIsChar_ch((c)) :\
  |  |  |  |  ------------------
  |  |  |  |  |  |  108|    188|#define xmlIsChar_ch(c)		(((0x9 <= (c)) && ((c) <= 0xa)) || \
  |  |  |  |  |  |  ------------------
  |  |  |  |  |  |  |  Branch (108:28): [True: 188, False: 0]
  |  |  |  |  |  |  |  Branch (108:44): [True: 12, False: 176]
  |  |  |  |  |  |  ------------------
  |  |  |  |  |  |  109|    188|				 ((c) == 0xd) || \
  |  |  |  |  |  |  ------------------
  |  |  |  |  |  |  |  Branch (109:6): [True: 0, False: 176]
  |  |  |  |  |  |  ------------------
  |  |  |  |  |  |  110|    188|				  (0x20 <= (c)))
  |  |  |  |  |  |  ------------------
  |  |  |  |  |  |  |  Branch (110:7): [True: 176, False: 0]
  |  |  |  |  |  |  ------------------
  |  |  |  |  ------------------
  |  |  |  |  120|    188|				(((0x100 <= (c)) && ((c) <= 0xd7ff)) || \
  |  |  |  |  ------------------
  |  |  |  |  |  Branch (120:7): [True: 0, False: 0]
  |  |  |  |  |  Branch (120:25): [True: 0, False: 0]
  |  |  |  |  ------------------
  |  |  |  |  121|      0|				 ((0xe000 <= (c)) && ((c) <= 0xfffd)) || \
  |  |  |  |  ------------------
  |  |  |  |  |  Branch (121:7): [True: 0, False: 0]
  |  |  |  |  |  Branch (121:26): [True: 0, False: 0]
  |  |  |  |  ------------------
  |  |  |  |  122|      0|				 ((0x10000 <= (c)) && ((c) <= 0x10ffff))))
  |  |  |  |  ------------------
  |  |  |  |  |  Branch (122:7): [True: 0, False: 0]
  |  |  |  |  |  Branch (122:27): [True: 0, False: 0]
  |  |  |  |  ------------------
  |  |  ------------------
  ------------------
  |  Branch (8297:13): [True: 0, False: 188]
  |  Branch (8297:24): [True: 0, False: 188]
  ------------------
 8298|      0|            xmlFatalErrMsgInt(ctxt, XML_ERR_INVALID_CHAR,
 8299|      0|                              "xmlLoadEntityContent: invalid char value %d\n",
 8300|      0|                              content[i]);
 8301|      0|            goto error;
 8302|      0|        }
 8303|    188|        i += clen;
 8304|    188|    }
 8305|       |
 8306|      8|    xmlSaturatedAdd(&ctxt->sizeentities, length);
 8307|      8|    entity->content = content;
 8308|      8|    entity->length = length;
 8309|      8|    content = NULL;
 8310|      8|    ret = 0;
 8311|       |
 8312|      8|error:
 8313|     16|    while (ctxt->inputNr > 0)
  ------------------
  |  Branch (8313:12): [True: 8, False: 8]
  ------------------
 8314|      8|        xmlFreeInputStream(inputPop(ctxt));
 8315|      8|    xmlFree(ctxt->inputTab);
 8316|      8|    xmlFree((xmlChar *) ctxt->encoding);
 8317|       |
 8318|      8|    ctxt->input = oldinput;
 8319|      8|    ctxt->inputNr = oldinputNr;
 8320|      8|    ctxt->inputMax = oldinputMax;
 8321|      8|    ctxt->inputTab = oldinputTab;
 8322|      8|    ctxt->encoding = oldencoding;
 8323|      8|    ctxt->progressive = oldprogressive;
 8324|       |
 8325|      8|    xmlFree(content);
 8326|       |
 8327|      8|    return(ret);
 8328|      8|}
parser.c:xmlFatalErrMsgStr:
  445|     24|{
  446|     24|    if ((ctxt != NULL) && (ctxt->disableSAX != 0) &&
  ------------------
  |  Branch (446:9): [True: 24, False: 0]
  |  Branch (446:27): [True: 12, False: 12]
  ------------------
  447|     24|        (ctxt->instate == XML_PARSER_EOF))
  ------------------
  |  Branch (447:9): [True: 0, False: 12]
  ------------------
  448|      0|	return;
  449|     24|    if (ctxt != NULL)
  ------------------
  |  Branch (449:9): [True: 24, False: 0]
  ------------------
  450|     24|	ctxt->errNo = error;
  451|     24|    __xmlRaiseError(NULL, NULL, NULL, ctxt, NULL,
  452|     24|                    XML_FROM_PARSER, error, XML_ERR_FATAL,
  453|     24|                    NULL, 0, (const char *) val, NULL, NULL, 0, 0, msg,
  454|     24|                    val);
  455|     24|    if (ctxt != NULL) {
  ------------------
  |  Branch (455:9): [True: 24, False: 0]
  ------------------
  456|     24|	ctxt->wellFormed = 0;
  457|     24|	if (ctxt->recovery == 0)
  ------------------
  |  Branch (457:6): [True: 24, False: 0]
  ------------------
  458|     24|	    ctxt->disableSAX = 1;
  459|     24|    }
  460|     24|}
parser.c:xmlParseNameComplex:
 3399|    226|xmlParseNameComplex(xmlParserCtxtPtr ctxt) {
 3400|    226|    int len = 0, l;
 3401|    226|    int c;
 3402|    226|    int maxLength = (ctxt->options & XML_PARSE_HUGE) ?
  ------------------
  |  Branch (3402:21): [True: 0, False: 226]
  ------------------
 3403|      0|                    XML_MAX_TEXT_LENGTH :
  ------------------
  |  |   42|      0|#define XML_MAX_TEXT_LENGTH 10000000
  ------------------
 3404|    226|                    XML_MAX_NAME_LENGTH;
  ------------------
  |  |   61|    226|#define XML_MAX_NAME_LENGTH 50000
  ------------------
 3405|       |
 3406|       |    /*
 3407|       |     * Handler for more complex cases
 3408|       |     */
 3409|    226|    c = CUR_CHAR(l);
  ------------------
  |  | 2291|    226|#define CUR_CHAR(l) xmlCurrentChar(ctxt, &l)
  ------------------
 3410|    226|    if ((ctxt->options & XML_PARSE_OLD10) == 0) {
  ------------------
  |  Branch (3410:9): [True: 226, False: 0]
  ------------------
 3411|       |        /*
 3412|       |	 * Use the new checks of production [4] [4a] amd [5] of the
 3413|       |	 * Update 5 of XML-1.0
 3414|       |	 */
 3415|    226|	if ((c == ' ') || (c == '>') || (c == '/') || /* accelerators */
  ------------------
  |  Branch (3415:6): [True: 0, False: 226]
  |  Branch (3415:20): [True: 0, False: 226]
  |  Branch (3415:34): [True: 0, False: 226]
  ------------------
 3416|    226|	    (!(((c >= 'a') && (c <= 'z')) ||
  ------------------
  |  Branch (3416:10): [True: 82, False: 144]
  |  Branch (3416:24): [True: 70, False: 12]
  ------------------
 3417|    226|	       ((c >= 'A') && (c <= 'Z')) ||
  ------------------
  |  Branch (3417:10): [True: 148, False: 8]
  |  Branch (3417:24): [True: 136, False: 12]
  ------------------
 3418|    226|	       (c == '_') || (c == ':') ||
  ------------------
  |  Branch (3418:9): [True: 0, False: 20]
  |  Branch (3418:23): [True: 0, False: 20]
  ------------------
 3419|    226|	       ((c >= 0xC0) && (c <= 0xD6)) ||
  ------------------
  |  Branch (3419:10): [True: 12, False: 8]
  |  Branch (3419:25): [True: 0, False: 12]
  ------------------
 3420|    226|	       ((c >= 0xD8) && (c <= 0xF6)) ||
  ------------------
  |  Branch (3420:10): [True: 12, False: 8]
  |  Branch (3420:25): [True: 4, False: 8]
  ------------------
 3421|    226|	       ((c >= 0xF8) && (c <= 0x2FF)) ||
  ------------------
  |  Branch (3421:10): [True: 8, False: 8]
  |  Branch (3421:25): [True: 8, False: 0]
  ------------------
 3422|    226|	       ((c >= 0x370) && (c <= 0x37D)) ||
  ------------------
  |  Branch (3422:10): [True: 0, False: 8]
  |  Branch (3422:26): [True: 0, False: 0]
  ------------------
 3423|    226|	       ((c >= 0x37F) && (c <= 0x1FFF)) ||
  ------------------
  |  Branch (3423:10): [True: 0, False: 8]
  |  Branch (3423:26): [True: 0, False: 0]
  ------------------
 3424|    226|	       ((c >= 0x200C) && (c <= 0x200D)) ||
  ------------------
  |  Branch (3424:10): [True: 0, False: 8]
  |  Branch (3424:27): [True: 0, False: 0]
  ------------------
 3425|    226|	       ((c >= 0x2070) && (c <= 0x218F)) ||
  ------------------
  |  Branch (3425:10): [True: 0, False: 8]
  |  Branch (3425:27): [True: 0, False: 0]
  ------------------
 3426|    226|	       ((c >= 0x2C00) && (c <= 0x2FEF)) ||
  ------------------
  |  Branch (3426:10): [True: 0, False: 8]
  |  Branch (3426:27): [True: 0, False: 0]
  ------------------
 3427|    226|	       ((c >= 0x3001) && (c <= 0xD7FF)) ||
  ------------------
  |  Branch (3427:10): [True: 0, False: 8]
  |  Branch (3427:27): [True: 0, False: 0]
  ------------------
 3428|    226|	       ((c >= 0xF900) && (c <= 0xFDCF)) ||
  ------------------
  |  Branch (3428:10): [True: 0, False: 8]
  |  Branch (3428:27): [True: 0, False: 0]
  ------------------
 3429|    226|	       ((c >= 0xFDF0) && (c <= 0xFFFD)) ||
  ------------------
  |  Branch (3429:10): [True: 0, False: 8]
  |  Branch (3429:27): [True: 0, False: 0]
  ------------------
 3430|    226|	       ((c >= 0x10000) && (c <= 0xEFFFF))))) {
  ------------------
  |  Branch (3430:10): [True: 0, False: 8]
  |  Branch (3430:28): [True: 0, False: 0]
  ------------------
 3431|      8|	    return(NULL);
 3432|      8|	}
 3433|    218|	len += l;
 3434|    218|	NEXTL(l);
  ------------------
  |  | 2284|    218|#define NEXTL(l) do {							\
  |  | 2285|    218|    if (*(ctxt->input->cur) == '\n') {					\
  |  |  ------------------
  |  |  |  Branch (2285:9): [True: 0, False: 218]
  |  |  ------------------
  |  | 2286|      0|	ctxt->input->line++; ctxt->input->col = 1;			\
  |  | 2287|    218|    } else ctxt->input->col++;						\
  |  | 2288|    218|    ctxt->input->cur += l;				\
  |  | 2289|    218|  } while (0)
  |  |  ------------------
  |  |  |  Branch (2289:12): [Folded - Ignored]
  |  |  ------------------
  ------------------
 3435|    218|	c = CUR_CHAR(l);
  ------------------
  |  | 2291|    218|#define CUR_CHAR(l) xmlCurrentChar(ctxt, &l)
  ------------------
 3436|  13.4k|	while ((c != ' ') && (c != '>') && (c != '/') && /* accelerators */
  ------------------
  |  Branch (3436:9): [True: 13.4k, False: 64]
  |  Branch (3436:23): [True: 13.4k, False: 0]
  |  Branch (3436:37): [True: 13.4k, False: 0]
  ------------------
 3437|  13.4k|	       (((c >= 'a') && (c <= 'z')) ||
  ------------------
  |  Branch (3437:11): [True: 13.1k, False: 256]
  |  Branch (3437:25): [True: 12.9k, False: 192]
  ------------------
 3438|  13.4k|	        ((c >= 'A') && (c <= 'Z')) ||
  ------------------
  |  Branch (3438:11): [True: 252, False: 196]
  |  Branch (3438:25): [True: 60, False: 192]
  ------------------
 3439|  13.4k|	        ((c >= '0') && (c <= '9')) || /* !start */
  ------------------
  |  Branch (3439:11): [True: 238, False: 150]
  |  Branch (3439:25): [True: 40, False: 198]
  ------------------
 3440|  13.4k|	        (c == '_') || (c == ':') ||
  ------------------
  |  Branch (3440:10): [True: 0, False: 348]
  |  Branch (3440:24): [True: 2, False: 346]
  ------------------
 3441|  13.4k|	        (c == '-') || (c == '.') || (c == 0xB7) || /* !start */
  ------------------
  |  Branch (3441:10): [True: 0, False: 346]
  |  Branch (3441:24): [True: 0, False: 346]
  |  Branch (3441:38): [True: 0, False: 346]
  ------------------
 3442|  13.4k|	        ((c >= 0xC0) && (c <= 0xD6)) ||
  ------------------
  |  Branch (3442:11): [True: 192, False: 154]
  |  Branch (3442:26): [True: 0, False: 192]
  ------------------
 3443|  13.4k|	        ((c >= 0xD8) && (c <= 0xF6)) ||
  ------------------
  |  Branch (3443:11): [True: 192, False: 154]
  |  Branch (3443:26): [True: 92, False: 100]
  ------------------
 3444|  13.4k|	        ((c >= 0xF8) && (c <= 0x2FF)) ||
  ------------------
  |  Branch (3444:11): [True: 100, False: 154]
  |  Branch (3444:26): [True: 100, False: 0]
  ------------------
 3445|  13.4k|	        ((c >= 0x300) && (c <= 0x36F)) || /* !start */
  ------------------
  |  Branch (3445:11): [True: 0, False: 154]
  |  Branch (3445:27): [True: 0, False: 0]
  ------------------
 3446|  13.4k|	        ((c >= 0x370) && (c <= 0x37D)) ||
  ------------------
  |  Branch (3446:11): [True: 0, False: 154]
  |  Branch (3446:27): [True: 0, False: 0]
  ------------------
 3447|  13.4k|	        ((c >= 0x37F) && (c <= 0x1FFF)) ||
  ------------------
  |  Branch (3447:11): [True: 0, False: 154]
  |  Branch (3447:27): [True: 0, False: 0]
  ------------------
 3448|  13.4k|	        ((c >= 0x200C) && (c <= 0x200D)) ||
  ------------------
  |  Branch (3448:11): [True: 0, False: 154]
  |  Branch (3448:28): [True: 0, False: 0]
  ------------------
 3449|  13.4k|	        ((c >= 0x203F) && (c <= 0x2040)) || /* !start */
  ------------------
  |  Branch (3449:11): [True: 0, False: 154]
  |  Branch (3449:28): [True: 0, False: 0]
  ------------------
 3450|  13.4k|	        ((c >= 0x2070) && (c <= 0x218F)) ||
  ------------------
  |  Branch (3450:11): [True: 0, False: 154]
  |  Branch (3450:28): [True: 0, False: 0]
  ------------------
 3451|  13.4k|	        ((c >= 0x2C00) && (c <= 0x2FEF)) ||
  ------------------
  |  Branch (3451:11): [True: 0, False: 154]
  |  Branch (3451:28): [True: 0, False: 0]
  ------------------
 3452|  13.4k|	        ((c >= 0x3001) && (c <= 0xD7FF)) ||
  ------------------
  |  Branch (3452:11): [True: 0, False: 154]
  |  Branch (3452:28): [True: 0, False: 0]
  ------------------
 3453|  13.4k|	        ((c >= 0xF900) && (c <= 0xFDCF)) ||
  ------------------
  |  Branch (3453:11): [True: 0, False: 154]
  |  Branch (3453:28): [True: 0, False: 0]
  ------------------
 3454|  13.4k|	        ((c >= 0xFDF0) && (c <= 0xFFFD)) ||
  ------------------
  |  Branch (3454:11): [True: 0, False: 154]
  |  Branch (3454:28): [True: 0, False: 0]
  ------------------
 3455|  13.4k|	        ((c >= 0x10000) && (c <= 0xEFFFF))
  ------------------
  |  Branch (3455:11): [True: 0, False: 154]
  |  Branch (3455:29): [True: 0, False: 0]
  ------------------
 3456|  13.4k|		)) {
 3457|  13.2k|            if (len <= INT_MAX - l)
  ------------------
  |  Branch (3457:17): [True: 13.2k, False: 0]
  ------------------
 3458|  13.2k|	        len += l;
 3459|  13.2k|	    NEXTL(l);
  ------------------
  |  | 2284|  13.2k|#define NEXTL(l) do {							\
  |  | 2285|  13.2k|    if (*(ctxt->input->cur) == '\n') {					\
  |  |  ------------------
  |  |  |  Branch (2285:9): [True: 0, False: 13.2k]
  |  |  ------------------
  |  | 2286|      0|	ctxt->input->line++; ctxt->input->col = 1;			\
  |  | 2287|  13.2k|    } else ctxt->input->col++;						\
  |  | 2288|  13.2k|    ctxt->input->cur += l;				\
  |  | 2289|  13.2k|  } while (0)
  |  |  ------------------
  |  |  |  Branch (2289:12): [Folded - Ignored]
  |  |  ------------------
  ------------------
 3460|  13.2k|	    c = CUR_CHAR(l);
  ------------------
  |  | 2291|  13.2k|#define CUR_CHAR(l) xmlCurrentChar(ctxt, &l)
  ------------------
 3461|  13.2k|	}
 3462|    218|    } else {
 3463|      0|	if ((c == ' ') || (c == '>') || (c == '/') || /* accelerators */
  ------------------
  |  Branch (3463:6): [True: 0, False: 0]
  |  Branch (3463:20): [True: 0, False: 0]
  |  Branch (3463:34): [True: 0, False: 0]
  ------------------
 3464|      0|	    (!IS_LETTER(c) && (c != '_') &&
  ------------------
  |  |  240|      0|#define IS_LETTER(c) (IS_BASECHAR(c) || IS_IDEOGRAPHIC(c))
  |  |  ------------------
  |  |  |  |  161|      0|#define IS_BASECHAR(c) xmlIsBaseCharQ(c)
  |  |  |  |  ------------------
  |  |  |  |  |  |   76|      0|#define xmlIsBaseCharQ(c)	(((c) < 0x100) ? \
  |  |  |  |  |  |  ------------------
  |  |  |  |  |  |  |  Branch (76:27): [True: 0, False: 0]
  |  |  |  |  |  |  |  Branch (76:28): [True: 0, False: 0]
  |  |  |  |  |  |  ------------------
  |  |  |  |  |  |   77|      0|				 xmlIsBaseChar_ch((c)) : \
  |  |  |  |  |  |  ------------------
  |  |  |  |  |  |  |  |   64|      0|#define xmlIsBaseChar_ch(c)	(((0x41 <= (c)) && ((c) <= 0x5a)) || \
  |  |  |  |  |  |  |  |  ------------------
  |  |  |  |  |  |  |  |  |  Branch (64:31): [True: 0, False: 0]
  |  |  |  |  |  |  |  |  |  Branch (64:48): [True: 0, False: 0]
  |  |  |  |  |  |  |  |  ------------------
  |  |  |  |  |  |  |  |   65|      0|				 ((0x61 <= (c)) && ((c) <= 0x7a)) || \
  |  |  |  |  |  |  |  |  ------------------
  |  |  |  |  |  |  |  |  |  Branch (65:7): [True: 0, False: 0]
  |  |  |  |  |  |  |  |  |  Branch (65:24): [True: 0, False: 0]
  |  |  |  |  |  |  |  |  ------------------
  |  |  |  |  |  |  |  |   66|      0|				 ((0xc0 <= (c)) && ((c) <= 0xd6)) || \
  |  |  |  |  |  |  |  |  ------------------
  |  |  |  |  |  |  |  |  |  Branch (66:7): [True: 0, False: 0]
  |  |  |  |  |  |  |  |  |  Branch (66:24): [True: 0, False: 0]
  |  |  |  |  |  |  |  |  ------------------
  |  |  |  |  |  |  |  |   67|      0|				 ((0xd8 <= (c)) && ((c) <= 0xf6)) || \
  |  |  |  |  |  |  |  |  ------------------
  |  |  |  |  |  |  |  |  |  Branch (67:7): [True: 0, False: 0]
  |  |  |  |  |  |  |  |  |  Branch (67:24): [True: 0, False: 0]
  |  |  |  |  |  |  |  |  ------------------
  |  |  |  |  |  |  |  |   68|      0|				  (0xf8 <= (c)))
  |  |  |  |  |  |  |  |  ------------------
  |  |  |  |  |  |  |  |  |  Branch (68:7): [True: 0, False: 0]
  |  |  |  |  |  |  |  |  ------------------
  |  |  |  |  |  |  ------------------
  |  |  |  |  |  |   78|      0|				 xmlCharInRange((c), &xmlIsBaseCharGroup))
  |  |  |  |  ------------------
  |  |  ------------------
  |  |               #define IS_LETTER(c) (IS_BASECHAR(c) || IS_IDEOGRAPHIC(c))
  |  |  ------------------
  |  |  |  |  229|      0|#define IS_IDEOGRAPHIC(c) xmlIsIdeographicQ(c)
  |  |  |  |  ------------------
  |  |  |  |  |  |  184|      0|#define xmlIsIdeographicQ(c)	(((c) < 0x100) ? \
  |  |  |  |  |  |  ------------------
  |  |  |  |  |  |  |  Branch (184:30): [True: 0, False: 0]
  |  |  |  |  |  |  |  Branch (184:31): [True: 0, False: 0]
  |  |  |  |  |  |  ------------------
  |  |  |  |  |  |  185|      0|				 0 :\
  |  |  |  |  |  |  186|      0|				(((0x4e00 <= (c)) && ((c) <= 0x9fa5)) || \
  |  |  |  |  |  |  ------------------
  |  |  |  |  |  |  |  Branch (186:7): [True: 0, False: 0]
  |  |  |  |  |  |  |  Branch (186:26): [True: 0, False: 0]
  |  |  |  |  |  |  ------------------
  |  |  |  |  |  |  187|      0|				 ((c) == 0x3007) || \
  |  |  |  |  |  |  ------------------
  |  |  |  |  |  |  |  Branch (187:6): [True: 0, False: 0]
  |  |  |  |  |  |  ------------------
  |  |  |  |  |  |  188|      0|				 ((0x3021 <= (c)) && ((c) <= 0x3029))))
  |  |  |  |  |  |  ------------------
  |  |  |  |  |  |  |  Branch (188:7): [True: 0, False: 0]
  |  |  |  |  |  |  |  Branch (188:26): [True: 0, False: 0]
  |  |  |  |  |  |  ------------------
  |  |  |  |  ------------------
  |  |  ------------------
  ------------------
  |  Branch (3464:24): [True: 0, False: 0]
  ------------------
 3465|      0|	     (c != ':'))) {
  ------------------
  |  Branch (3465:7): [True: 0, False: 0]
  ------------------
 3466|      0|	    return(NULL);
 3467|      0|	}
 3468|      0|	len += l;
 3469|      0|	NEXTL(l);
  ------------------
  |  | 2284|      0|#define NEXTL(l) do {							\
  |  | 2285|      0|    if (*(ctxt->input->cur) == '\n') {					\
  |  |  ------------------
  |  |  |  Branch (2285:9): [True: 0, False: 0]
  |  |  ------------------
  |  | 2286|      0|	ctxt->input->line++; ctxt->input->col = 1;			\
  |  | 2287|      0|    } else ctxt->input->col++;						\
  |  | 2288|      0|    ctxt->input->cur += l;				\
  |  | 2289|      0|  } while (0)
  |  |  ------------------
  |  |  |  Branch (2289:12): [Folded - Ignored]
  |  |  ------------------
  ------------------
 3470|      0|	c = CUR_CHAR(l);
  ------------------
  |  | 2291|      0|#define CUR_CHAR(l) xmlCurrentChar(ctxt, &l)
  ------------------
 3471|       |
 3472|      0|	while ((c != ' ') && (c != '>') && (c != '/') && /* test bigname.xml */
  ------------------
  |  Branch (3472:9): [True: 0, False: 0]
  |  Branch (3472:23): [True: 0, False: 0]
  |  Branch (3472:37): [True: 0, False: 0]
  ------------------
 3473|      0|	       ((IS_LETTER(c)) || (IS_DIGIT(c)) ||
  ------------------
  |  |  240|      0|#define IS_LETTER(c) (IS_BASECHAR(c) || IS_IDEOGRAPHIC(c))
  |  |  ------------------
  |  |  |  |  161|      0|#define IS_BASECHAR(c) xmlIsBaseCharQ(c)
  |  |  |  |  ------------------
  |  |  |  |  |  |   76|      0|#define xmlIsBaseCharQ(c)	(((c) < 0x100) ? \
  |  |  |  |  |  |  ------------------
  |  |  |  |  |  |  |  Branch (76:27): [True: 0, False: 0]
  |  |  |  |  |  |  |  Branch (76:28): [True: 0, False: 0]
  |  |  |  |  |  |  ------------------
  |  |  |  |  |  |   77|      0|				 xmlIsBaseChar_ch((c)) : \
  |  |  |  |  |  |  ------------------
  |  |  |  |  |  |  |  |   64|      0|#define xmlIsBaseChar_ch(c)	(((0x41 <= (c)) && ((c) <= 0x5a)) || \
  |  |  |  |  |  |  |  |  ------------------
  |  |  |  |  |  |  |  |  |  Branch (64:31): [True: 0, False: 0]
  |  |  |  |  |  |  |  |  |  Branch (64:48): [True: 0, False: 0]
  |  |  |  |  |  |  |  |  ------------------
  |  |  |  |  |  |  |  |   65|      0|				 ((0x61 <= (c)) && ((c) <= 0x7a)) || \
  |  |  |  |  |  |  |  |  ------------------
  |  |  |  |  |  |  |  |  |  Branch (65:7): [True: 0, False: 0]
  |  |  |  |  |  |  |  |  |  Branch (65:24): [True: 0, False: 0]
  |  |  |  |  |  |  |  |  ------------------
  |  |  |  |  |  |  |  |   66|      0|				 ((0xc0 <= (c)) && ((c) <= 0xd6)) || \
  |  |  |  |  |  |  |  |  ------------------
  |  |  |  |  |  |  |  |  |  Branch (66:7): [True: 0, False: 0]
  |  |  |  |  |  |  |  |  |  Branch (66:24): [True: 0, False: 0]
  |  |  |  |  |  |  |  |  ------------------
  |  |  |  |  |  |  |  |   67|      0|				 ((0xd8 <= (c)) && ((c) <= 0xf6)) || \
  |  |  |  |  |  |  |  |  ------------------
  |  |  |  |  |  |  |  |  |  Branch (67:7): [True: 0, False: 0]
  |  |  |  |  |  |  |  |  |  Branch (67:24): [True: 0, False: 0]
  |  |  |  |  |  |  |  |  ------------------
  |  |  |  |  |  |  |  |   68|      0|				  (0xf8 <= (c)))
  |  |  |  |  |  |  |  |  ------------------
  |  |  |  |  |  |  |  |  |  Branch (68:7): [True: 0, False: 0]
  |  |  |  |  |  |  |  |  ------------------
  |  |  |  |  |  |  ------------------
  |  |  |  |  |  |   78|      0|				 xmlCharInRange((c), &xmlIsBaseCharGroup))
  |  |  |  |  ------------------
  |  |  ------------------
  |  |               #define IS_LETTER(c) (IS_BASECHAR(c) || IS_IDEOGRAPHIC(c))
  |  |  ------------------
  |  |  |  |  229|      0|#define IS_IDEOGRAPHIC(c) xmlIsIdeographicQ(c)
  |  |  |  |  ------------------
  |  |  |  |  |  |  184|      0|#define xmlIsIdeographicQ(c)	(((c) < 0x100) ? \
  |  |  |  |  |  |  ------------------
  |  |  |  |  |  |  |  Branch (184:30): [True: 0, False: 0]
  |  |  |  |  |  |  |  Branch (184:31): [True: 0, False: 0]
  |  |  |  |  |  |  ------------------
  |  |  |  |  |  |  185|      0|				 0 :\
  |  |  |  |  |  |  186|      0|				(((0x4e00 <= (c)) && ((c) <= 0x9fa5)) || \
  |  |  |  |  |  |  ------------------
  |  |  |  |  |  |  |  Branch (186:7): [True: 0, False: 0]
  |  |  |  |  |  |  |  Branch (186:26): [True: 0, False: 0]
  |  |  |  |  |  |  ------------------
  |  |  |  |  |  |  187|      0|				 ((c) == 0x3007) || \
  |  |  |  |  |  |  ------------------
  |  |  |  |  |  |  |  Branch (187:6): [True: 0, False: 0]
  |  |  |  |  |  |  ------------------
  |  |  |  |  |  |  188|      0|				 ((0x3021 <= (c)) && ((c) <= 0x3029))))
  |  |  |  |  |  |  ------------------
  |  |  |  |  |  |  |  Branch (188:7): [True: 0, False: 0]
  |  |  |  |  |  |  |  Branch (188:26): [True: 0, False: 0]
  |  |  |  |  |  |  ------------------
  |  |  |  |  ------------------
  |  |  ------------------
  ------------------
              	       ((IS_LETTER(c)) || (IS_DIGIT(c)) ||
  ------------------
  |  |  171|      0|#define IS_DIGIT(c) xmlIsDigitQ(c)
  |  |  ------------------
  |  |  |  |  152|      0|#define xmlIsDigitQ(c)		(((c) < 0x100) ? \
  |  |  |  |  ------------------
  |  |  |  |  |  Branch (152:26): [True: 0, False: 0]
  |  |  |  |  ------------------
  |  |  |  |  153|      0|				 xmlIsDigit_ch((c)) : \
  |  |  |  |  ------------------
  |  |  |  |  |  |  144|      0|#define xmlIsDigit_ch(c)	(((0x30 <= (c)) && ((c) <= 0x39)))
  |  |  |  |  |  |  ------------------
  |  |  |  |  |  |  |  Branch (144:28): [True: 0, False: 0]
  |  |  |  |  |  |  |  Branch (144:45): [True: 0, False: 0]
  |  |  |  |  |  |  ------------------
  |  |  |  |  ------------------
  |  |  |  |  154|      0|				 xmlCharInRange((c), &xmlIsDigitGroup))
  |  |  ------------------
  ------------------
  |  Branch (3473:28): [True: 0, False: 0]
  ------------------
 3474|      0|		(c == '.') || (c == '-') ||
  ------------------
  |  Branch (3474:3): [True: 0, False: 0]
  |  Branch (3474:17): [True: 0, False: 0]
  ------------------
 3475|      0|		(c == '_') || (c == ':') ||
  ------------------
  |  Branch (3475:3): [True: 0, False: 0]
  |  Branch (3475:17): [True: 0, False: 0]
  ------------------
 3476|      0|		(IS_COMBINING(c)) ||
  ------------------
  |  |  189|      0|#define IS_COMBINING(c) xmlIsCombiningQ(c)
  |  |  ------------------
  |  |  |  |  132|      0|#define xmlIsCombiningQ(c)	(((c) < 0x100) ? \
  |  |  |  |  ------------------
  |  |  |  |  |  Branch (132:29): [True: 0, False: 0]
  |  |  |  |  ------------------
  |  |  |  |  133|      0|				 0 : \
  |  |  |  |  134|      0|				 xmlCharInRange((c), &xmlIsCombiningGroup))
  |  |  ------------------
  ------------------
  |  Branch (3476:3): [True: 0, False: 0]
  ------------------
 3477|      0|		(IS_EXTENDER(c)))) {
  ------------------
  |  |  210|      0|#define IS_EXTENDER(c) xmlIsExtenderQ(c)
  |  |  ------------------
  |  |  |  |  172|      0|#define xmlIsExtenderQ(c)	(((c) < 0x100) ? \
  |  |  |  |  ------------------
  |  |  |  |  |  Branch (172:28): [True: 0, False: 0]
  |  |  |  |  ------------------
  |  |  |  |  173|      0|				 xmlIsExtender_ch((c)) : \
  |  |  |  |  ------------------
  |  |  |  |  |  |  164|      0|#define xmlIsExtender_ch(c)	(((c) == 0xb7))
  |  |  |  |  ------------------
  |  |  |  |  174|      0|				 xmlCharInRange((c), &xmlIsExtenderGroup))
  |  |  ------------------
  ------------------
  |  Branch (3477:3): [True: 0, False: 0]
  ------------------
 3478|      0|            if (len <= INT_MAX - l)
  ------------------
  |  Branch (3478:17): [True: 0, False: 0]
  ------------------
 3479|      0|	        len += l;
 3480|      0|	    NEXTL(l);
  ------------------
  |  | 2284|      0|#define NEXTL(l) do {							\
  |  | 2285|      0|    if (*(ctxt->input->cur) == '\n') {					\
  |  |  ------------------
  |  |  |  Branch (2285:9): [True: 0, False: 0]
  |  |  ------------------
  |  | 2286|      0|	ctxt->input->line++; ctxt->input->col = 1;			\
  |  | 2287|      0|    } else ctxt->input->col++;						\
  |  | 2288|      0|    ctxt->input->cur += l;				\
  |  | 2289|      0|  } while (0)
  |  |  ------------------
  |  |  |  Branch (2289:12): [Folded - Ignored]
  |  |  ------------------
  ------------------
 3481|      0|	    c = CUR_CHAR(l);
  ------------------
  |  | 2291|      0|#define CUR_CHAR(l) xmlCurrentChar(ctxt, &l)
  ------------------
 3482|      0|	}
 3483|      0|    }
 3484|    218|    if (ctxt->instate == XML_PARSER_EOF)
  ------------------
  |  Branch (3484:9): [True: 0, False: 218]
  ------------------
 3485|      0|        return(NULL);
 3486|    218|    if (len > maxLength) {
  ------------------
  |  Branch (3486:9): [True: 0, False: 218]
  ------------------
 3487|      0|        xmlFatalErr(ctxt, XML_ERR_NAME_TOO_LONG, "Name");
 3488|      0|        return(NULL);
 3489|      0|    }
 3490|    218|    if (ctxt->input->cur - ctxt->input->base < len) {
  ------------------
  |  Branch (3490:9): [True: 0, False: 218]
  ------------------
 3491|       |        /*
 3492|       |         * There were a couple of bugs where PERefs lead to to a change
 3493|       |         * of the buffer. Check the buffer size to avoid passing an invalid
 3494|       |         * pointer to xmlDictLookup.
 3495|       |         */
 3496|      0|        xmlFatalErr(ctxt, XML_ERR_INTERNAL_ERROR,
 3497|      0|                    "unexpected change of input buffer");
 3498|      0|        return (NULL);
 3499|      0|    }
 3500|    218|    if ((*ctxt->input->cur == '\n') && (ctxt->input->cur[-1] == '\r'))
  ------------------
  |  Branch (3500:9): [True: 0, False: 218]
  |  Branch (3500:40): [True: 0, False: 0]
  ------------------
 3501|      0|        return(xmlDictLookup(ctxt->dict, ctxt->input->cur - (len + 1), len));
 3502|    218|    return(xmlDictLookup(ctxt->dict, ctxt->input->cur - len, len));
 3503|    218|}
parser.c:xmlIsNameChar:
 3357|  4.87M|xmlIsNameChar(xmlParserCtxtPtr ctxt, int c) {
 3358|  4.87M|    if ((ctxt->options & XML_PARSE_OLD10) == 0) {
  ------------------
  |  Branch (3358:9): [True: 4.87M, False: 0]
  ------------------
 3359|       |        /*
 3360|       |	 * Use the new checks of production [4] [4a] amd [5] of the
 3361|       |	 * Update 5 of XML-1.0
 3362|       |	 */
 3363|  4.87M|	if ((c != ' ') && (c != '>') && (c != '/') && /* accelerators */
  ------------------
  |  Branch (3363:6): [True: 4.87M, False: 460]
  |  Branch (3363:20): [True: 4.87M, False: 0]
  |  Branch (3363:34): [True: 4.87M, False: 8]
  ------------------
 3364|  4.87M|	    (((c >= 'a') && (c <= 'z')) ||
  ------------------
  |  Branch (3364:8): [True: 4.35M, False: 524k]
  |  Branch (3364:22): [True: 4.35M, False: 2.58k]
  ------------------
 3365|  4.87M|	     ((c >= 'A') && (c <= 'Z')) ||
  ------------------
  |  Branch (3365:8): [True: 2.84k, False: 524k]
  |  Branch (3365:22): [True: 140, False: 2.70k]
  ------------------
 3366|  4.87M|	     ((c >= '0') && (c <= '9')) || /* !start */
  ------------------
  |  Branch (3366:8): [True: 523k, False: 3.51k]
  |  Branch (3366:22): [True: 314k, False: 209k]
  ------------------
 3367|  4.87M|	     (c == '_') || (c == ':') ||
  ------------------
  |  Branch (3367:7): [True: 118, False: 212k]
  |  Branch (3367:21): [True: 24, False: 212k]
  ------------------
 3368|  4.87M|	     (c == '-') || (c == '.') || (c == 0xB7) || /* !start */
  ------------------
  |  Branch (3368:7): [True: 18, False: 212k]
  |  Branch (3368:21): [True: 1.34k, False: 211k]
  |  Branch (3368:35): [True: 0, False: 211k]
  ------------------
 3369|  4.87M|	     ((c >= 0xC0) && (c <= 0xD6)) ||
  ------------------
  |  Branch (3369:8): [True: 2.43k, False: 208k]
  |  Branch (3369:23): [True: 0, False: 2.43k]
  ------------------
 3370|  4.87M|	     ((c >= 0xD8) && (c <= 0xF6)) ||
  ------------------
  |  Branch (3370:8): [True: 2.43k, False: 208k]
  |  Branch (3370:23): [True: 68, False: 2.36k]
  ------------------
 3371|  4.87M|	     ((c >= 0xF8) && (c <= 0x2FF)) ||
  ------------------
  |  Branch (3371:8): [True: 2.36k, False: 208k]
  |  Branch (3371:23): [True: 68, False: 2.29k]
  ------------------
 3372|  4.87M|	     ((c >= 0x300) && (c <= 0x36F)) || /* !start */
  ------------------
  |  Branch (3372:8): [True: 2.29k, False: 208k]
  |  Branch (3372:24): [True: 0, False: 2.29k]
  ------------------
 3373|  4.87M|	     ((c >= 0x370) && (c <= 0x37D)) ||
  ------------------
  |  Branch (3373:8): [True: 2.29k, False: 208k]
  |  Branch (3373:24): [True: 0, False: 2.29k]
  ------------------
 3374|  4.87M|	     ((c >= 0x37F) && (c <= 0x1FFF)) ||
  ------------------
  |  Branch (3374:8): [True: 2.29k, False: 208k]
  |  Branch (3374:24): [True: 0, False: 2.29k]
  ------------------
 3375|  4.87M|	     ((c >= 0x200C) && (c <= 0x200D)) ||
  ------------------
  |  Branch (3375:8): [True: 2.29k, False: 208k]
  |  Branch (3375:25): [True: 0, False: 2.29k]
  ------------------
 3376|  4.87M|	     ((c >= 0x203F) && (c <= 0x2040)) || /* !start */
  ------------------
  |  Branch (3376:8): [True: 2.29k, False: 208k]
  |  Branch (3376:25): [True: 0, False: 2.29k]
  ------------------
 3377|  4.87M|	     ((c >= 0x2070) && (c <= 0x218F)) ||
  ------------------
  |  Branch (3377:8): [True: 2.29k, False: 208k]
  |  Branch (3377:25): [True: 2.26k, False: 28]
  ------------------
 3378|  4.87M|	     ((c >= 0x2C00) && (c <= 0x2FEF)) ||
  ------------------
  |  Branch (3378:8): [True: 28, False: 208k]
  |  Branch (3378:25): [True: 0, False: 28]
  ------------------
 3379|  4.87M|	     ((c >= 0x3001) && (c <= 0xD7FF)) ||
  ------------------
  |  Branch (3379:8): [True: 28, False: 208k]
  |  Branch (3379:25): [True: 28, False: 0]
  ------------------
 3380|  4.87M|	     ((c >= 0xF900) && (c <= 0xFDCF)) ||
  ------------------
  |  Branch (3380:8): [True: 0, False: 208k]
  |  Branch (3380:25): [True: 0, False: 0]
  ------------------
 3381|  4.87M|	     ((c >= 0xFDF0) && (c <= 0xFFFD)) ||
  ------------------
  |  Branch (3381:8): [True: 0, False: 208k]
  |  Branch (3381:25): [True: 0, False: 0]
  ------------------
 3382|  4.87M|	     ((c >= 0x10000) && (c <= 0xEFFFF))))
  ------------------
  |  Branch (3382:8): [True: 0, False: 208k]
  |  Branch (3382:26): [True: 0, False: 0]
  ------------------
 3383|  4.66M|	     return(1);
 3384|  4.87M|    } else {
 3385|      0|        if ((IS_LETTER(c)) || (IS_DIGIT(c)) ||
  ------------------
  |  |  240|      0|#define IS_LETTER(c) (IS_BASECHAR(c) || IS_IDEOGRAPHIC(c))
  |  |  ------------------
  |  |  |  |  161|      0|#define IS_BASECHAR(c) xmlIsBaseCharQ(c)
  |  |  |  |  ------------------
  |  |  |  |  |  |   76|      0|#define xmlIsBaseCharQ(c)	(((c) < 0x100) ? \
  |  |  |  |  |  |  ------------------
  |  |  |  |  |  |  |  Branch (76:27): [True: 0, False: 0]
  |  |  |  |  |  |  |  Branch (76:28): [True: 0, False: 0]
  |  |  |  |  |  |  ------------------
  |  |  |  |  |  |   77|      0|				 xmlIsBaseChar_ch((c)) : \
  |  |  |  |  |  |  ------------------
  |  |  |  |  |  |  |  |   64|      0|#define xmlIsBaseChar_ch(c)	(((0x41 <= (c)) && ((c) <= 0x5a)) || \
  |  |  |  |  |  |  |  |  ------------------
  |  |  |  |  |  |  |  |  |  Branch (64:31): [True: 0, False: 0]
  |  |  |  |  |  |  |  |  |  Branch (64:48): [True: 0, False: 0]
  |  |  |  |  |  |  |  |  ------------------
  |  |  |  |  |  |  |  |   65|      0|				 ((0x61 <= (c)) && ((c) <= 0x7a)) || \
  |  |  |  |  |  |  |  |  ------------------
  |  |  |  |  |  |  |  |  |  Branch (65:7): [True: 0, False: 0]
  |  |  |  |  |  |  |  |  |  Branch (65:24): [True: 0, False: 0]
  |  |  |  |  |  |  |  |  ------------------
  |  |  |  |  |  |  |  |   66|      0|				 ((0xc0 <= (c)) && ((c) <= 0xd6)) || \
  |  |  |  |  |  |  |  |  ------------------
  |  |  |  |  |  |  |  |  |  Branch (66:7): [True: 0, False: 0]
  |  |  |  |  |  |  |  |  |  Branch (66:24): [True: 0, False: 0]
  |  |  |  |  |  |  |  |  ------------------
  |  |  |  |  |  |  |  |   67|      0|				 ((0xd8 <= (c)) && ((c) <= 0xf6)) || \
  |  |  |  |  |  |  |  |  ------------------
  |  |  |  |  |  |  |  |  |  Branch (67:7): [True: 0, False: 0]
  |  |  |  |  |  |  |  |  |  Branch (67:24): [True: 0, False: 0]
  |  |  |  |  |  |  |  |  ------------------
  |  |  |  |  |  |  |  |   68|      0|				  (0xf8 <= (c)))
  |  |  |  |  |  |  |  |  ------------------
  |  |  |  |  |  |  |  |  |  Branch (68:7): [True: 0, False: 0]
  |  |  |  |  |  |  |  |  ------------------
  |  |  |  |  |  |  ------------------
  |  |  |  |  |  |   78|      0|				 xmlCharInRange((c), &xmlIsBaseCharGroup))
  |  |  |  |  ------------------
  |  |  ------------------
  |  |               #define IS_LETTER(c) (IS_BASECHAR(c) || IS_IDEOGRAPHIC(c))
  |  |  ------------------
  |  |  |  |  229|      0|#define IS_IDEOGRAPHIC(c) xmlIsIdeographicQ(c)
  |  |  |  |  ------------------
  |  |  |  |  |  |  184|      0|#define xmlIsIdeographicQ(c)	(((c) < 0x100) ? \
  |  |  |  |  |  |  ------------------
  |  |  |  |  |  |  |  Branch (184:30): [True: 0, False: 0]
  |  |  |  |  |  |  |  Branch (184:31): [True: 0, False: 0]
  |  |  |  |  |  |  ------------------
  |  |  |  |  |  |  185|      0|				 0 :\
  |  |  |  |  |  |  186|      0|				(((0x4e00 <= (c)) && ((c) <= 0x9fa5)) || \
  |  |  |  |  |  |  ------------------
  |  |  |  |  |  |  |  Branch (186:7): [True: 0, False: 0]
  |  |  |  |  |  |  |  Branch (186:26): [True: 0, False: 0]
  |  |  |  |  |  |  ------------------
  |  |  |  |  |  |  187|      0|				 ((c) == 0x3007) || \
  |  |  |  |  |  |  ------------------
  |  |  |  |  |  |  |  Branch (187:6): [True: 0, False: 0]
  |  |  |  |  |  |  ------------------
  |  |  |  |  |  |  188|      0|				 ((0x3021 <= (c)) && ((c) <= 0x3029))))
  |  |  |  |  |  |  ------------------
  |  |  |  |  |  |  |  Branch (188:7): [True: 0, False: 0]
  |  |  |  |  |  |  |  Branch (188:26): [True: 0, False: 0]
  |  |  |  |  |  |  ------------------
  |  |  |  |  ------------------
  |  |  ------------------
  ------------------
                      if ((IS_LETTER(c)) || (IS_DIGIT(c)) ||
  ------------------
  |  |  171|      0|#define IS_DIGIT(c) xmlIsDigitQ(c)
  |  |  ------------------
  |  |  |  |  152|      0|#define xmlIsDigitQ(c)		(((c) < 0x100) ? \
  |  |  |  |  ------------------
  |  |  |  |  |  Branch (152:26): [True: 0, False: 0]
  |  |  |  |  ------------------
  |  |  |  |  153|      0|				 xmlIsDigit_ch((c)) : \
  |  |  |  |  ------------------
  |  |  |  |  |  |  144|      0|#define xmlIsDigit_ch(c)	(((0x30 <= (c)) && ((c) <= 0x39)))
  |  |  |  |  |  |  ------------------
  |  |  |  |  |  |  |  Branch (144:28): [True: 0, False: 0]
  |  |  |  |  |  |  |  Branch (144:45): [True: 0, False: 0]
  |  |  |  |  |  |  ------------------
  |  |  |  |  ------------------
  |  |  |  |  154|      0|				 xmlCharInRange((c), &xmlIsDigitGroup))
  |  |  ------------------
  ------------------
  |  Branch (3385:31): [True: 0, False: 0]
  ------------------
 3386|      0|            (c == '.') || (c == '-') ||
  ------------------
  |  Branch (3386:13): [True: 0, False: 0]
  |  Branch (3386:27): [True: 0, False: 0]
  ------------------
 3387|      0|	    (c == '_') || (c == ':') ||
  ------------------
  |  Branch (3387:6): [True: 0, False: 0]
  |  Branch (3387:20): [True: 0, False: 0]
  ------------------
 3388|      0|	    (IS_COMBINING(c)) ||
  ------------------
  |  |  189|      0|#define IS_COMBINING(c) xmlIsCombiningQ(c)
  |  |  ------------------
  |  |  |  |  132|      0|#define xmlIsCombiningQ(c)	(((c) < 0x100) ? \
  |  |  |  |  ------------------
  |  |  |  |  |  Branch (132:29): [True: 0, False: 0]
  |  |  |  |  ------------------
  |  |  |  |  133|      0|				 0 : \
  |  |  |  |  134|      0|				 xmlCharInRange((c), &xmlIsCombiningGroup))
  |  |  ------------------
  ------------------
  |  Branch (3388:6): [True: 0, False: 0]
  ------------------
 3389|      0|	    (IS_EXTENDER(c)))
  ------------------
  |  |  210|      0|#define IS_EXTENDER(c) xmlIsExtenderQ(c)
  |  |  ------------------
  |  |  |  |  172|      0|#define xmlIsExtenderQ(c)	(((c) < 0x100) ? \
  |  |  |  |  ------------------
  |  |  |  |  |  Branch (172:28): [True: 0, False: 0]
  |  |  |  |  ------------------
  |  |  |  |  173|      0|				 xmlIsExtender_ch((c)) : \
  |  |  |  |  ------------------
  |  |  |  |  |  |  164|      0|#define xmlIsExtender_ch(c)	(((c) == 0xb7))
  |  |  |  |  ------------------
  |  |  |  |  174|      0|				 xmlCharInRange((c), &xmlIsExtenderGroup))
  |  |  ------------------
  ------------------
  |  Branch (3389:6): [True: 0, False: 0]
  ------------------
 3390|      0|	    return(1);
 3391|      0|    }
 3392|   209k|    return(0);
 3393|  4.87M|}
parser.c:xmlFatalErrMsg:
  279|    970|{
  280|    970|    if ((ctxt != NULL) && (ctxt->disableSAX != 0) &&
  ------------------
  |  Branch (280:9): [True: 970, False: 0]
  |  Branch (280:27): [True: 830, False: 140]
  ------------------
  281|    970|        (ctxt->instate == XML_PARSER_EOF))
  ------------------
  |  Branch (281:9): [True: 796, False: 34]
  ------------------
  282|    796|	return;
  283|    174|    if (ctxt != NULL)
  ------------------
  |  Branch (283:9): [True: 174, False: 0]
  ------------------
  284|    174|	ctxt->errNo = error;
  285|    174|    __xmlRaiseError(NULL, NULL, NULL, ctxt, NULL, XML_FROM_PARSER, error,
  286|    174|                    XML_ERR_FATAL, NULL, 0, NULL, NULL, NULL, 0, 0, "%s", msg);
  287|    174|    if (ctxt != NULL) {
  ------------------
  |  Branch (287:9): [True: 174, False: 0]
  ------------------
  288|    174|	ctxt->wellFormed = 0;
  289|    174|	if (ctxt->recovery == 0)
  ------------------
  |  Branch (289:6): [True: 174, False: 0]
  ------------------
  290|    174|	    ctxt->disableSAX = 1;
  291|    174|    }
  292|    174|}
parser.c:xmlParseStringName:
 3730|   206k|xmlParseStringName(xmlParserCtxtPtr ctxt, const xmlChar** str) {
 3731|   206k|    xmlChar buf[XML_MAX_NAMELEN + 5];
 3732|   206k|    const xmlChar *cur = *str;
 3733|   206k|    int len = 0, l;
 3734|   206k|    int c;
 3735|   206k|    int maxLength = (ctxt->options & XML_PARSE_HUGE) ?
  ------------------
  |  Branch (3735:21): [True: 0, False: 206k]
  ------------------
 3736|      0|                    XML_MAX_TEXT_LENGTH :
  ------------------
  |  |   42|      0|#define XML_MAX_TEXT_LENGTH 10000000
  ------------------
 3737|   206k|                    XML_MAX_NAME_LENGTH;
  ------------------
  |  |   61|   206k|#define XML_MAX_NAME_LENGTH 50000
  ------------------
 3738|       |
 3739|   206k|    c = CUR_SCHAR(cur, l);
  ------------------
  |  | 2292|   206k|#define CUR_SCHAR(s, l) xmlStringCurrentChar(ctxt, s, &l)
  ------------------
 3740|   206k|    if (!xmlIsNameStartChar(ctxt, c)) {
  ------------------
  |  Branch (3740:9): [True: 0, False: 206k]
  ------------------
 3741|      0|	return(NULL);
 3742|      0|    }
 3743|       |
 3744|   206k|    COPY_BUF(buf, len, c);
  ------------------
  |  | 2295|   206k|    if (v < 0x80) b[i++] = v;						\
  |  |  ------------------
  |  |  |  Branch (2295:9): [True: 206k, False: 0]
  |  |  ------------------
  |  | 2296|   206k|    else i += xmlCopyCharMultiByte(&b[i],v)
  ------------------
 3745|   206k|    cur += l;
 3746|   206k|    c = CUR_SCHAR(cur, l);
  ------------------
  |  | 2292|   206k|#define CUR_SCHAR(s, l) xmlStringCurrentChar(ctxt, s, &l)
  ------------------
 3747|  2.05M|    while (xmlIsNameChar(ctxt, c)) {
  ------------------
  |  Branch (3747:12): [True: 1.86M, False: 194k]
  ------------------
 3748|  1.86M|	COPY_BUF(buf, len, c);
  ------------------
  |  | 2295|  1.86M|    if (v < 0x80) b[i++] = v;						\
  |  |  ------------------
  |  |  |  Branch (2295:9): [True: 1.86M, False: 0]
  |  |  ------------------
  |  | 2296|  1.86M|    else i += xmlCopyCharMultiByte(&b[i],v)
  ------------------
 3749|  1.86M|	cur += l;
 3750|  1.86M|	c = CUR_SCHAR(cur, l);
  ------------------
  |  | 2292|  1.86M|#define CUR_SCHAR(s, l) xmlStringCurrentChar(ctxt, s, &l)
  ------------------
 3751|  1.86M|	if (len >= XML_MAX_NAMELEN) { /* test bigentname.xml */
  ------------------
  |  |   89|  1.86M|#define XML_MAX_NAMELEN 100
  ------------------
  |  Branch (3751:6): [True: 11.5k, False: 1.85M]
  ------------------
 3752|       |	    /*
 3753|       |	     * Okay someone managed to make a huge name, so he's ready to pay
 3754|       |	     * for the processing speed.
 3755|       |	     */
 3756|  11.5k|	    xmlChar *buffer;
 3757|  11.5k|	    int max = len * 2;
 3758|       |
 3759|  11.5k|	    buffer = (xmlChar *) xmlMallocAtomic(max);
 3760|  11.5k|	    if (buffer == NULL) {
  ------------------
  |  Branch (3760:10): [True: 0, False: 11.5k]
  ------------------
 3761|      0|	        xmlErrMemory(ctxt, NULL);
 3762|      0|		return(NULL);
 3763|      0|	    }
 3764|  11.5k|	    memcpy(buffer, buf, len);
 3765|  2.64M|	    while (xmlIsNameChar(ctxt, c)) {
  ------------------
  |  Branch (3765:13): [True: 2.63M, False: 11.5k]
  ------------------
 3766|  2.63M|		if (len + 10 > max) {
  ------------------
  |  Branch (3766:7): [True: 11.5k, False: 2.61M]
  ------------------
 3767|  11.5k|		    xmlChar *tmp;
 3768|       |
 3769|  11.5k|		    max *= 2;
 3770|  11.5k|		    tmp = (xmlChar *) xmlRealloc(buffer, max);
 3771|  11.5k|		    if (tmp == NULL) {
  ------------------
  |  Branch (3771:11): [True: 0, False: 11.5k]
  ------------------
 3772|      0|			xmlErrMemory(ctxt, NULL);
 3773|      0|			xmlFree(buffer);
 3774|      0|			return(NULL);
 3775|      0|		    }
 3776|  11.5k|		    buffer = tmp;
 3777|  11.5k|		}
 3778|  2.63M|		COPY_BUF(buffer, len, c);
  ------------------
  |  | 2295|  2.63M|    if (v < 0x80) b[i++] = v;						\
  |  |  ------------------
  |  |  |  Branch (2295:9): [True: 2.63M, False: 0]
  |  |  ------------------
  |  | 2296|  2.63M|    else i += xmlCopyCharMultiByte(&b[i],v)
  ------------------
 3779|  2.63M|		cur += l;
 3780|  2.63M|		c = CUR_SCHAR(cur, l);
  ------------------
  |  | 2292|  2.63M|#define CUR_SCHAR(s, l) xmlStringCurrentChar(ctxt, s, &l)
  ------------------
 3781|  2.63M|                if (len > maxLength) {
  ------------------
  |  Branch (3781:21): [True: 0, False: 2.63M]
  ------------------
 3782|      0|                    xmlFatalErr(ctxt, XML_ERR_NAME_TOO_LONG, "NCName");
 3783|      0|                    xmlFree(buffer);
 3784|      0|                    return(NULL);
 3785|      0|                }
 3786|  2.63M|	    }
 3787|  11.5k|	    buffer[len] = 0;
 3788|  11.5k|	    *str = cur;
 3789|  11.5k|	    return(buffer);
 3790|  11.5k|	}
 3791|  1.86M|    }
 3792|   194k|    if (len > maxLength) {
  ------------------
  |  Branch (3792:9): [True: 0, False: 194k]
  ------------------
 3793|      0|        xmlFatalErr(ctxt, XML_ERR_NAME_TOO_LONG, "NCName");
 3794|      0|        return(NULL);
 3795|      0|    }
 3796|   194k|    *str = cur;
 3797|   194k|    return(xmlStrndup(buf, len));
 3798|   194k|}
parser.c:xmlIsNameStartChar:
 3326|   206k|xmlIsNameStartChar(xmlParserCtxtPtr ctxt, int c) {
 3327|   206k|    if ((ctxt->options & XML_PARSE_OLD10) == 0) {
  ------------------
  |  Branch (3327:9): [True: 206k, False: 0]
  ------------------
 3328|       |        /*
 3329|       |	 * Use the new checks of production [4] [4a] amd [5] of the
 3330|       |	 * Update 5 of XML-1.0
 3331|       |	 */
 3332|   206k|	if ((c != ' ') && (c != '>') && (c != '/') && /* accelerators */
  ------------------
  |  Branch (3332:6): [True: 206k, False: 0]
  |  Branch (3332:20): [True: 206k, False: 0]
  |  Branch (3332:34): [True: 206k, False: 0]
  ------------------
 3333|   206k|	    (((c >= 'a') && (c <= 'z')) ||
  ------------------
  |  Branch (3333:8): [True: 206k, False: 140]
  |  Branch (3333:22): [True: 206k, False: 16]
  ------------------
 3334|   206k|	     ((c >= 'A') && (c <= 'Z')) ||
  ------------------
  |  Branch (3334:8): [True: 108, False: 48]
  |  Branch (3334:22): [True: 92, False: 16]
  ------------------
 3335|   206k|	     (c == '_') || (c == ':') ||
  ------------------
  |  Branch (3335:7): [True: 0, False: 64]
  |  Branch (3335:21): [True: 8, False: 56]
  ------------------
 3336|   206k|	     ((c >= 0xC0) && (c <= 0xD6)) ||
  ------------------
  |  Branch (3336:8): [True: 16, False: 40]
  |  Branch (3336:23): [True: 0, False: 16]
  ------------------
 3337|   206k|	     ((c >= 0xD8) && (c <= 0xF6)) ||
  ------------------
  |  Branch (3337:8): [True: 16, False: 40]
  |  Branch (3337:23): [True: 0, False: 16]
  ------------------
 3338|   206k|	     ((c >= 0xF8) && (c <= 0x2FF)) ||
  ------------------
  |  Branch (3338:8): [True: 16, False: 40]
  |  Branch (3338:23): [True: 8, False: 8]
  ------------------
 3339|   206k|	     ((c >= 0x370) && (c <= 0x37D)) ||
  ------------------
  |  Branch (3339:8): [True: 8, False: 40]
  |  Branch (3339:24): [True: 0, False: 8]
  ------------------
 3340|   206k|	     ((c >= 0x37F) && (c <= 0x1FFF)) ||
  ------------------
  |  Branch (3340:8): [True: 8, False: 40]
  |  Branch (3340:24): [True: 0, False: 8]
  ------------------
 3341|   206k|	     ((c >= 0x200C) && (c <= 0x200D)) ||
  ------------------
  |  Branch (3341:8): [True: 8, False: 40]
  |  Branch (3341:25): [True: 0, False: 8]
  ------------------
 3342|   206k|	     ((c >= 0x2070) && (c <= 0x218F)) ||
  ------------------
  |  Branch (3342:8): [True: 8, False: 40]
  |  Branch (3342:25): [True: 4, False: 4]
  ------------------
 3343|   206k|	     ((c >= 0x2C00) && (c <= 0x2FEF)) ||
  ------------------
  |  Branch (3343:8): [True: 4, False: 40]
  |  Branch (3343:25): [True: 0, False: 4]
  ------------------
 3344|   206k|	     ((c >= 0x3001) && (c <= 0xD7FF)) ||
  ------------------
  |  Branch (3344:8): [True: 4, False: 40]
  |  Branch (3344:25): [True: 4, False: 0]
  ------------------
 3345|   206k|	     ((c >= 0xF900) && (c <= 0xFDCF)) ||
  ------------------
  |  Branch (3345:8): [True: 0, False: 40]
  |  Branch (3345:25): [True: 0, False: 0]
  ------------------
 3346|   206k|	     ((c >= 0xFDF0) && (c <= 0xFFFD)) ||
  ------------------
  |  Branch (3346:8): [True: 0, False: 40]
  |  Branch (3346:25): [True: 0, False: 0]
  ------------------
 3347|   206k|	     ((c >= 0x10000) && (c <= 0xEFFFF))))
  ------------------
  |  Branch (3347:8): [True: 0, False: 40]
  |  Branch (3347:26): [True: 0, False: 0]
  ------------------
 3348|   206k|	    return(1);
 3349|   206k|    } else {
 3350|      0|        if (IS_LETTER(c) || (c == '_') || (c == ':'))
  ------------------
  |  |  240|      0|#define IS_LETTER(c) (IS_BASECHAR(c) || IS_IDEOGRAPHIC(c))
  |  |  ------------------
  |  |  |  |  161|      0|#define IS_BASECHAR(c) xmlIsBaseCharQ(c)
  |  |  |  |  ------------------
  |  |  |  |  |  |   76|      0|#define xmlIsBaseCharQ(c)	(((c) < 0x100) ? \
  |  |  |  |  |  |  ------------------
  |  |  |  |  |  |  |  Branch (76:27): [True: 0, False: 0]
  |  |  |  |  |  |  |  Branch (76:28): [True: 0, False: 0]
  |  |  |  |  |  |  ------------------
  |  |  |  |  |  |   77|      0|				 xmlIsBaseChar_ch((c)) : \
  |  |  |  |  |  |  ------------------
  |  |  |  |  |  |  |  |   64|      0|#define xmlIsBaseChar_ch(c)	(((0x41 <= (c)) && ((c) <= 0x5a)) || \
  |  |  |  |  |  |  |  |  ------------------
  |  |  |  |  |  |  |  |  |  Branch (64:31): [True: 0, False: 0]
  |  |  |  |  |  |  |  |  |  Branch (64:48): [True: 0, False: 0]
  |  |  |  |  |  |  |  |  ------------------
  |  |  |  |  |  |  |  |   65|      0|				 ((0x61 <= (c)) && ((c) <= 0x7a)) || \
  |  |  |  |  |  |  |  |  ------------------
  |  |  |  |  |  |  |  |  |  Branch (65:7): [True: 0, False: 0]
  |  |  |  |  |  |  |  |  |  Branch (65:24): [True: 0, False: 0]
  |  |  |  |  |  |  |  |  ------------------
  |  |  |  |  |  |  |  |   66|      0|				 ((0xc0 <= (c)) && ((c) <= 0xd6)) || \
  |  |  |  |  |  |  |  |  ------------------
  |  |  |  |  |  |  |  |  |  Branch (66:7): [True: 0, False: 0]
  |  |  |  |  |  |  |  |  |  Branch (66:24): [True: 0, False: 0]
  |  |  |  |  |  |  |  |  ------------------
  |  |  |  |  |  |  |  |   67|      0|				 ((0xd8 <= (c)) && ((c) <= 0xf6)) || \
  |  |  |  |  |  |  |  |  ------------------
  |  |  |  |  |  |  |  |  |  Branch (67:7): [True: 0, False: 0]
  |  |  |  |  |  |  |  |  |  Branch (67:24): [True: 0, False: 0]
  |  |  |  |  |  |  |  |  ------------------
  |  |  |  |  |  |  |  |   68|      0|				  (0xf8 <= (c)))
  |  |  |  |  |  |  |  |  ------------------
  |  |  |  |  |  |  |  |  |  Branch (68:7): [True: 0, False: 0]
  |  |  |  |  |  |  |  |  ------------------
  |  |  |  |  |  |  ------------------
  |  |  |  |  |  |   78|      0|				 xmlCharInRange((c), &xmlIsBaseCharGroup))
  |  |  |  |  ------------------
  |  |  ------------------
  |  |               #define IS_LETTER(c) (IS_BASECHAR(c) || IS_IDEOGRAPHIC(c))
  |  |  ------------------
  |  |  |  |  229|      0|#define IS_IDEOGRAPHIC(c) xmlIsIdeographicQ(c)
  |  |  |  |  ------------------
  |  |  |  |  |  |  184|      0|#define xmlIsIdeographicQ(c)	(((c) < 0x100) ? \
  |  |  |  |  |  |  ------------------
  |  |  |  |  |  |  |  Branch (184:30): [True: 0, False: 0]
  |  |  |  |  |  |  |  Branch (184:31): [True: 0, False: 0]
  |  |  |  |  |  |  ------------------
  |  |  |  |  |  |  185|      0|				 0 :\
  |  |  |  |  |  |  186|      0|				(((0x4e00 <= (c)) && ((c) <= 0x9fa5)) || \
  |  |  |  |  |  |  ------------------
  |  |  |  |  |  |  |  Branch (186:7): [True: 0, False: 0]
  |  |  |  |  |  |  |  Branch (186:26): [True: 0, False: 0]
  |  |  |  |  |  |  ------------------
  |  |  |  |  |  |  187|      0|				 ((c) == 0x3007) || \
  |  |  |  |  |  |  ------------------
  |  |  |  |  |  |  |  Branch (187:6): [True: 0, False: 0]
  |  |  |  |  |  |  ------------------
  |  |  |  |  |  |  188|      0|				 ((0x3021 <= (c)) && ((c) <= 0x3029))))
  |  |  |  |  |  |  ------------------
  |  |  |  |  |  |  |  Branch (188:7): [True: 0, False: 0]
  |  |  |  |  |  |  |  Branch (188:26): [True: 0, False: 0]
  |  |  |  |  |  |  ------------------
  |  |  |  |  ------------------
  |  |  ------------------
  ------------------
  |  Branch (3350:29): [True: 0, False: 0]
  |  Branch (3350:43): [True: 0, False: 0]
  ------------------
 3351|      0|	    return(1);
 3352|      0|    }
 3353|     40|    return(0);
 3354|   206k|}
parser.c:xmlParseCharDataInternal:
 4557|  72.3k|xmlParseCharDataInternal(xmlParserCtxtPtr ctxt, int partial) {
 4558|  72.3k|    const xmlChar *in;
 4559|  72.3k|    int nbchar = 0;
 4560|  72.3k|    int line = ctxt->input->line;
 4561|  72.3k|    int col = ctxt->input->col;
 4562|  72.3k|    int ccol;
 4563|       |
 4564|  72.3k|    GROW;
  ------------------
  |  | 2270|  72.3k|#define GROW if (ctxt->input->end - ctxt->input->cur < INPUT_CHUNK)	\
  |  |  ------------------
  |  |  |  |   97|  72.3k|#define INPUT_CHUNK	250
  |  |  ------------------
  |  |  |  Branch (2270:18): [True: 28.5k, False: 43.8k]
  |  |  ------------------
  |  | 2271|  72.3k|	xmlParserGrow(ctxt);
  ------------------
 4565|       |    /*
 4566|       |     * Accelerated common case where input don't need to be
 4567|       |     * modified before passing it to the handler.
 4568|       |     */
 4569|  72.3k|    in = ctxt->input->cur;
 4570|   111k|    do {
 4571|   129k|get_more_space:
 4572|   166k|        while (*in == 0x20) { in++; ctxt->input->col++; }
  ------------------
  |  Branch (4572:16): [True: 36.9k, False: 129k]
  ------------------
 4573|   129k|        if (*in == 0xA) {
  ------------------
  |  Branch (4573:13): [True: 17.8k, False: 111k]
  ------------------
 4574|  18.3k|            do {
 4575|  18.3k|                ctxt->input->line++; ctxt->input->col = 1;
 4576|  18.3k|                in++;
 4577|  18.3k|            } while (*in == 0xA);
  ------------------
  |  Branch (4577:22): [True: 509, False: 17.8k]
  ------------------
 4578|  17.8k|            goto get_more_space;
 4579|  17.8k|        }
 4580|   111k|        if (*in == '<') {
  ------------------
  |  Branch (4580:13): [True: 16.8k, False: 94.4k]
  ------------------
 4581|  16.8k|            nbchar = in - ctxt->input->cur;
 4582|  16.8k|            if (nbchar > 0) {
  ------------------
  |  Branch (4582:17): [True: 16.8k, False: 0]
  ------------------
 4583|  16.8k|                const xmlChar *tmp = ctxt->input->cur;
 4584|  16.8k|                ctxt->input->cur = in;
 4585|       |
 4586|  16.8k|                if ((ctxt->sax != NULL) &&
  ------------------
  |  Branch (4586:21): [True: 16.8k, False: 0]
  ------------------
 4587|  16.8k|                    (ctxt->disableSAX == 0) &&
  ------------------
  |  Branch (4587:21): [True: 16.7k, False: 166]
  ------------------
 4588|  16.8k|                    (ctxt->sax->ignorableWhitespace !=
  ------------------
  |  Branch (4588:21): [True: 0, False: 16.7k]
  ------------------
 4589|  16.7k|                     ctxt->sax->characters)) {
 4590|      0|                    if (areBlanks(ctxt, tmp, nbchar, 1)) {
  ------------------
  |  Branch (4590:25): [True: 0, False: 0]
  ------------------
 4591|      0|                        if (ctxt->sax->ignorableWhitespace != NULL)
  ------------------
  |  Branch (4591:29): [True: 0, False: 0]
  ------------------
 4592|      0|                            ctxt->sax->ignorableWhitespace(ctxt->userData,
 4593|      0|                                                   tmp, nbchar);
 4594|      0|                    } else {
 4595|      0|                        if (ctxt->sax->characters != NULL)
  ------------------
  |  Branch (4595:29): [True: 0, False: 0]
  ------------------
 4596|      0|                            ctxt->sax->characters(ctxt->userData,
 4597|      0|                                                  tmp, nbchar);
 4598|      0|                        if (*ctxt->space == -1)
  ------------------
  |  Branch (4598:29): [True: 0, False: 0]
  ------------------
 4599|      0|                            *ctxt->space = -2;
 4600|      0|                    }
 4601|  16.8k|                } else if ((ctxt->sax != NULL) &&
  ------------------
  |  Branch (4601:28): [True: 16.8k, False: 0]
  ------------------
 4602|  16.8k|                           (ctxt->disableSAX == 0) &&
  ------------------
  |  Branch (4602:28): [True: 16.7k, False: 166]
  ------------------
 4603|  16.8k|                           (ctxt->sax->characters != NULL)) {
  ------------------
  |  Branch (4603:28): [True: 16.7k, False: 0]
  ------------------
 4604|  16.7k|                    ctxt->sax->characters(ctxt->userData,
 4605|  16.7k|                                          tmp, nbchar);
 4606|  16.7k|                }
 4607|  16.8k|            }
 4608|  16.8k|            return;
 4609|  16.8k|        }
 4610|       |
 4611|   113k|get_more:
 4612|   113k|        ccol = ctxt->input->col;
 4613|  1.16M|        while (test_char_data[*in]) {
  ------------------
  |  Branch (4613:16): [True: 1.05M, False: 113k]
  ------------------
 4614|  1.05M|            in++;
 4615|  1.05M|            ccol++;
 4616|  1.05M|        }
 4617|   113k|        ctxt->input->col = ccol;
 4618|   113k|        if (*in == 0xA) {
  ------------------
  |  Branch (4618:13): [True: 17.3k, False: 95.7k]
  ------------------
 4619|  17.3k|            do {
 4620|  17.3k|                ctxt->input->line++; ctxt->input->col = 1;
 4621|  17.3k|                in++;
 4622|  17.3k|            } while (*in == 0xA);
  ------------------
  |  Branch (4622:22): [True: 63, False: 17.3k]
  ------------------
 4623|  17.3k|            goto get_more;
 4624|  17.3k|        }
 4625|  95.7k|        if (*in == ']') {
  ------------------
  |  Branch (4625:13): [True: 1.27k, False: 94.4k]
  ------------------
 4626|  1.27k|            if ((in[1] == ']') && (in[2] == '>')) {
  ------------------
  |  Branch (4626:17): [True: 52, False: 1.22k]
  |  Branch (4626:35): [True: 0, False: 52]
  ------------------
 4627|      0|                xmlFatalErr(ctxt, XML_ERR_MISPLACED_CDATA_END, NULL);
 4628|      0|                if (ctxt->instate != XML_PARSER_EOF)
  ------------------
  |  Branch (4628:21): [True: 0, False: 0]
  ------------------
 4629|      0|                    ctxt->input->cur = in + 1;
 4630|      0|                return;
 4631|      0|            }
 4632|  1.27k|            in++;
 4633|  1.27k|            ctxt->input->col++;
 4634|  1.27k|            goto get_more;
 4635|  1.27k|        }
 4636|  94.4k|        nbchar = in - ctxt->input->cur;
 4637|  94.4k|        if (nbchar > 0) {
  ------------------
  |  Branch (4637:13): [True: 55.5k, False: 38.9k]
  ------------------
 4638|  55.5k|            if ((ctxt->sax != NULL) &&
  ------------------
  |  Branch (4638:17): [True: 55.5k, False: 0]
  ------------------
 4639|  55.5k|                (ctxt->disableSAX == 0) &&
  ------------------
  |  Branch (4639:17): [True: 55.4k, False: 76]
  ------------------
 4640|  55.5k|                (ctxt->sax->ignorableWhitespace !=
  ------------------
  |  Branch (4640:17): [True: 0, False: 55.4k]
  ------------------
 4641|  55.4k|                 ctxt->sax->characters) &&
 4642|  55.5k|                (IS_BLANK_CH(*ctxt->input->cur))) {
  ------------------
  |  |  151|      0|#define IS_BLANK_CH(c)  xmlIsBlank_ch(c)
  |  |  ------------------
  |  |  |  |   88|      0|#define xmlIsBlank_ch(c)	(((c) == 0x20) || \
  |  |  |  |  ------------------
  |  |  |  |  |  Branch (88:27): [True: 0, False: 0]
  |  |  |  |  ------------------
  |  |  |  |   89|      0|				 ((0x9 <= (c)) && ((c) <= 0xa)) || \
  |  |  |  |  ------------------
  |  |  |  |  |  Branch (89:7): [True: 0, False: 0]
  |  |  |  |  |  Branch (89:23): [True: 0, False: 0]
  |  |  |  |  ------------------
  |  |  |  |   90|      0|				 ((c) == 0xd))
  |  |  |  |  ------------------
  |  |  |  |  |  Branch (90:6): [True: 0, False: 0]
  |  |  |  |  ------------------
  |  |  ------------------
  ------------------
 4643|      0|                const xmlChar *tmp = ctxt->input->cur;
 4644|      0|                ctxt->input->cur = in;
 4645|       |
 4646|      0|                if (areBlanks(ctxt, tmp, nbchar, 0)) {
  ------------------
  |  Branch (4646:21): [True: 0, False: 0]
  ------------------
 4647|      0|                    if (ctxt->sax->ignorableWhitespace != NULL)
  ------------------
  |  Branch (4647:25): [True: 0, False: 0]
  ------------------
 4648|      0|                        ctxt->sax->ignorableWhitespace(ctxt->userData,
 4649|      0|                                                       tmp, nbchar);
 4650|      0|                } else {
 4651|      0|                    if (ctxt->sax->characters != NULL)
  ------------------
  |  Branch (4651:25): [True: 0, False: 0]
  ------------------
 4652|      0|                        ctxt->sax->characters(ctxt->userData,
 4653|      0|                                              tmp, nbchar);
 4654|      0|                    if (*ctxt->space == -1)
  ------------------
  |  Branch (4654:25): [True: 0, False: 0]
  ------------------
 4655|      0|                        *ctxt->space = -2;
 4656|      0|                }
 4657|      0|                line = ctxt->input->line;
 4658|      0|                col = ctxt->input->col;
 4659|  55.5k|            } else if ((ctxt->sax != NULL) &&
  ------------------
  |  Branch (4659:24): [True: 55.5k, False: 0]
  ------------------
 4660|  55.5k|                       (ctxt->disableSAX == 0)) {
  ------------------
  |  Branch (4660:24): [True: 55.4k, False: 76]
  ------------------
 4661|  55.4k|                if (ctxt->sax->characters != NULL)
  ------------------
  |  Branch (4661:21): [True: 55.4k, False: 0]
  ------------------
 4662|  55.4k|                    ctxt->sax->characters(ctxt->userData,
 4663|  55.4k|                                          ctxt->input->cur, nbchar);
 4664|  55.4k|                line = ctxt->input->line;
 4665|  55.4k|                col = ctxt->input->col;
 4666|  55.4k|            }
 4667|  55.5k|            if (ctxt->instate == XML_PARSER_EOF)
  ------------------
  |  Branch (4667:17): [True: 0, False: 55.5k]
  ------------------
 4668|      0|                return;
 4669|  55.5k|        }
 4670|  94.4k|        ctxt->input->cur = in;
 4671|  94.4k|        if (*in == 0xD) {
  ------------------
  |  Branch (4671:13): [True: 39.0k, False: 55.3k]
  ------------------
 4672|  39.0k|            in++;
 4673|  39.0k|            if (*in == 0xA) {
  ------------------
  |  Branch (4673:17): [True: 39.0k, False: 4]
  ------------------
 4674|  39.0k|                ctxt->input->cur = in;
 4675|  39.0k|                in++;
 4676|  39.0k|                ctxt->input->line++; ctxt->input->col = 1;
 4677|  39.0k|                continue; /* while */
 4678|  39.0k|            }
 4679|      4|            in--;
 4680|      4|        }
 4681|  55.3k|        if (*in == '<') {
  ------------------
  |  Branch (4681:13): [True: 52.0k, False: 3.32k]
  ------------------
 4682|  52.0k|            return;
 4683|  52.0k|        }
 4684|  3.32k|        if (*in == '&') {
  ------------------
  |  Branch (4684:13): [True: 2.56k, False: 765]
  ------------------
 4685|  2.56k|            return;
 4686|  2.56k|        }
 4687|    765|        SHRINK;
  ------------------
  |  | 2265|    765|    if (((ctxt->progressive == 0) || (ctxt->inputNr > 1)) && \
  |  |  ------------------
  |  |  |  Branch (2265:10): [True: 276, False: 489]
  |  |  |  Branch (2265:38): [True: 0, False: 489]
  |  |  ------------------
  |  | 2266|    765|        (ctxt->input->cur - ctxt->input->base > 2 * INPUT_CHUNK) && \
  |  |  ------------------
  |  |  |  |   97|    276|#define INPUT_CHUNK	250
  |  |  ------------------
  |  |  |  Branch (2266:9): [True: 66, False: 210]
  |  |  ------------------
  |  | 2267|    765|	(ctxt->input->end - ctxt->input->cur < 2 * INPUT_CHUNK)) \
  |  |  ------------------
  |  |  |  |   97|     66|#define INPUT_CHUNK	250
  |  |  ------------------
  |  |  |  Branch (2267:2): [True: 40, False: 26]
  |  |  ------------------
  |  | 2268|    765|	xmlParserShrink(ctxt);
  ------------------
 4688|    765|        GROW;
  ------------------
  |  | 2270|    765|#define GROW if (ctxt->input->end - ctxt->input->cur < INPUT_CHUNK)	\
  |  |  ------------------
  |  |  |  |   97|    765|#define INPUT_CHUNK	250
  |  |  ------------------
  |  |  |  Branch (2270:18): [True: 680, False: 85]
  |  |  ------------------
  |  | 2271|    765|	xmlParserGrow(ctxt);
  ------------------
 4689|    765|        if (ctxt->instate == XML_PARSER_EOF)
  ------------------
  |  Branch (4689:13): [True: 0, False: 765]
  ------------------
 4690|      0|            return;
 4691|    765|        in = ctxt->input->cur;
 4692|  39.8k|    } while (((*in >= 0x20) && (*in <= 0x7F)) ||
  ------------------
  |  Branch (4692:15): [True: 2.13k, False: 37.7k]
  |  Branch (4692:32): [True: 1.97k, False: 158]
  ------------------
 4693|  39.8k|             (*in == 0x09) || (*in == 0x0a));
  ------------------
  |  Branch (4693:14): [True: 37.0k, False: 829]
  |  Branch (4693:31): [True: 0, False: 829]
  ------------------
 4694|    829|    ctxt->input->line = line;
 4695|    829|    ctxt->input->col = col;
 4696|    829|    xmlParseCharDataComplex(ctxt, partial);
 4697|    829|}
parser.c:areBlanks:
 3071|    360|                     int blank_chars) {
 3072|    360|    int i, ret;
 3073|    360|    xmlNodePtr lastChild;
 3074|       |
 3075|       |    /*
 3076|       |     * Don't spend time trying to differentiate them, the same callback is
 3077|       |     * used !
 3078|       |     */
 3079|    360|    if (ctxt->sax->ignorableWhitespace == ctxt->sax->characters)
  ------------------
  |  Branch (3079:9): [True: 360, False: 0]
  ------------------
 3080|    360|	return(0);
 3081|       |
 3082|       |    /*
 3083|       |     * Check for xml:space value.
 3084|       |     */
 3085|      0|    if ((ctxt->space == NULL) || (*(ctxt->space) == 1) ||
  ------------------
  |  Branch (3085:9): [True: 0, False: 0]
  |  Branch (3085:34): [True: 0, False: 0]
  ------------------
 3086|      0|        (*(ctxt->space) == -2))
  ------------------
  |  Branch (3086:9): [True: 0, False: 0]
  ------------------
 3087|      0|	return(0);
 3088|       |
 3089|       |    /*
 3090|       |     * Check that the string is made of blanks
 3091|       |     */
 3092|      0|    if (blank_chars == 0) {
  ------------------
  |  Branch (3092:9): [True: 0, False: 0]
  ------------------
 3093|      0|	for (i = 0;i < len;i++)
  ------------------
  |  Branch (3093:13): [True: 0, False: 0]
  ------------------
 3094|      0|	    if (!(IS_BLANK_CH(str[i]))) return(0);
  ------------------
  |  |  151|      0|#define IS_BLANK_CH(c)  xmlIsBlank_ch(c)
  |  |  ------------------
  |  |  |  |   88|      0|#define xmlIsBlank_ch(c)	(((c) == 0x20) || \
  |  |  |  |  ------------------
  |  |  |  |  |  Branch (88:27): [True: 0, False: 0]
  |  |  |  |  ------------------
  |  |  |  |   89|      0|				 ((0x9 <= (c)) && ((c) <= 0xa)) || \
  |  |  |  |  ------------------
  |  |  |  |  |  Branch (89:7): [True: 0, False: 0]
  |  |  |  |  |  Branch (89:23): [True: 0, False: 0]
  |  |  |  |  ------------------
  |  |  |  |   90|      0|				 ((c) == 0xd))
  |  |  |  |  ------------------
  |  |  |  |  |  Branch (90:6): [True: 0, False: 0]
  |  |  |  |  ------------------
  |  |  ------------------
  ------------------
 3095|      0|    }
 3096|       |
 3097|       |    /*
 3098|       |     * Look if the element is mixed content in the DTD if available
 3099|       |     */
 3100|      0|    if (ctxt->node == NULL) return(0);
  ------------------
  |  Branch (3100:9): [True: 0, False: 0]
  ------------------
 3101|      0|    if (ctxt->myDoc != NULL) {
  ------------------
  |  Branch (3101:9): [True: 0, False: 0]
  ------------------
 3102|      0|	ret = xmlIsMixedElement(ctxt->myDoc, ctxt->node->name);
 3103|      0|        if (ret == 0) return(1);
  ------------------
  |  Branch (3103:13): [True: 0, False: 0]
  ------------------
 3104|      0|        if (ret == 1) return(0);
  ------------------
  |  Branch (3104:13): [True: 0, False: 0]
  ------------------
 3105|      0|    }
 3106|       |
 3107|       |    /*
 3108|       |     * Otherwise, heuristic :-\
 3109|       |     */
 3110|      0|    if ((RAW != '<') && (RAW != 0xD)) return(0);
  ------------------
  |  | 2221|      0|#define RAW (*ctxt->input->cur)
  ------------------
                  if ((RAW != '<') && (RAW != 0xD)) return(0);
  ------------------
  |  | 2221|      0|#define RAW (*ctxt->input->cur)
  ------------------
  |  Branch (3110:9): [True: 0, False: 0]
  |  Branch (3110:25): [True: 0, False: 0]
  ------------------
 3111|      0|    if ((ctxt->node->children == NULL) &&
  ------------------
  |  Branch (3111:9): [True: 0, False: 0]
  ------------------
 3112|      0|	(RAW == '<') && (NXT(1) == '/')) return(0);
  ------------------
  |  | 2221|      0|#define RAW (*ctxt->input->cur)
  ------------------
              	(RAW == '<') && (NXT(1) == '/')) return(0);
  ------------------
  |  | 2223|      0|#define NXT(val) ctxt->input->cur[(val)]
  ------------------
  |  Branch (3112:2): [True: 0, False: 0]
  |  Branch (3112:18): [True: 0, False: 0]
  ------------------
 3113|       |
 3114|      0|    lastChild = xmlGetLastChild(ctxt->node);
 3115|      0|    if (lastChild == NULL) {
  ------------------
  |  Branch (3115:9): [True: 0, False: 0]
  ------------------
 3116|      0|        if ((ctxt->node->type != XML_ELEMENT_NODE) &&
  ------------------
  |  Branch (3116:13): [True: 0, False: 0]
  ------------------
 3117|      0|            (ctxt->node->content != NULL)) return(0);
  ------------------
  |  Branch (3117:13): [True: 0, False: 0]
  ------------------
 3118|      0|    } else if (xmlNodeIsText(lastChild))
  ------------------
  |  Branch (3118:16): [True: 0, False: 0]
  ------------------
 3119|      0|        return(0);
 3120|      0|    else if ((ctxt->node->children != NULL) &&
  ------------------
  |  Branch (3120:14): [True: 0, False: 0]
  ------------------
 3121|      0|             (xmlNodeIsText(ctxt->node->children)))
  ------------------
  |  Branch (3121:14): [True: 0, False: 0]
  ------------------
 3122|      0|        return(0);
 3123|      0|    return(1);
 3124|      0|}
parser.c:xmlParseCharDataComplex:
 4711|    829|xmlParseCharDataComplex(xmlParserCtxtPtr ctxt, int partial) {
 4712|    829|    xmlChar buf[XML_PARSER_BIG_BUFFER_SIZE + 5];
 4713|    829|    int nbchar = 0;
 4714|    829|    int cur, l;
 4715|       |
 4716|    829|    cur = CUR_CHAR(l);
  ------------------
  |  | 2291|    829|#define CUR_CHAR(l) xmlCurrentChar(ctxt, &l)
  ------------------
 4717|  32.0k|    while ((cur != '<') && /* checked */
  ------------------
  |  Branch (4717:12): [True: 31.8k, False: 207]
  ------------------
 4718|  32.0k|           (cur != '&') &&
  ------------------
  |  Branch (4718:12): [True: 31.8k, False: 0]
  ------------------
 4719|  32.0k|	   (IS_CHAR(cur))) {
  ------------------
  |  |  125|  31.8k|#define IS_CHAR(c)   xmlIsCharQ(c)
  |  |  ------------------
  |  |  |  |  118|  31.8k|#define xmlIsCharQ(c)		(((c) < 0x100) ? \
  |  |  |  |  ------------------
  |  |  |  |  |  Branch (118:25): [True: 25.7k, False: 6.01k]
  |  |  |  |  ------------------
  |  |  |  |  119|  31.8k|				 xmlIsChar_ch((c)) :\
  |  |  |  |  ------------------
  |  |  |  |  |  |  108|  25.7k|#define xmlIsChar_ch(c)		(((0x9 <= (c)) && ((c) <= 0xa)) || \
  |  |  |  |  |  |  ------------------
  |  |  |  |  |  |  |  Branch (108:28): [True: 25.1k, False: 622]
  |  |  |  |  |  |  |  Branch (108:44): [True: 623, False: 24.5k]
  |  |  |  |  |  |  ------------------
  |  |  |  |  |  |  109|  25.7k|				 ((c) == 0xd) || \
  |  |  |  |  |  |  ------------------
  |  |  |  |  |  |  |  Branch (109:6): [True: 0, False: 25.1k]
  |  |  |  |  |  |  ------------------
  |  |  |  |  |  |  110|  25.7k|				  (0x20 <= (c)))
  |  |  |  |  |  |  ------------------
  |  |  |  |  |  |  |  Branch (110:7): [True: 24.5k, False: 622]
  |  |  |  |  |  |  ------------------
  |  |  |  |  ------------------
  |  |  |  |  120|  31.8k|				(((0x100 <= (c)) && ((c) <= 0xd7ff)) || \
  |  |  |  |  ------------------
  |  |  |  |  |  Branch (120:7): [True: 6.01k, False: 0]
  |  |  |  |  |  Branch (120:25): [True: 6.01k, False: 4]
  |  |  |  |  ------------------
  |  |  |  |  121|  6.01k|				 ((0xe000 <= (c)) && ((c) <= 0xfffd)) || \
  |  |  |  |  ------------------
  |  |  |  |  |  Branch (121:7): [True: 4, False: 0]
  |  |  |  |  |  Branch (121:26): [True: 4, False: 0]
  |  |  |  |  ------------------
  |  |  |  |  122|  6.01k|				 ((0x10000 <= (c)) && ((c) <= 0x10ffff))))
  |  |  |  |  ------------------
  |  |  |  |  |  Branch (122:7): [True: 0, False: 0]
  |  |  |  |  |  Branch (122:27): [True: 0, False: 0]
  |  |  |  |  ------------------
  |  |  ------------------
  ------------------
  |  Branch (4719:5): [True: 31.1k, False: 622]
  ------------------
 4720|  31.1k|	if ((cur == ']') && (NXT(1) == ']') && (NXT(2) == '>')) {
  ------------------
  |  | 2223|      0|#define NXT(val) ctxt->input->cur[(val)]
  ------------------
              	if ((cur == ']') && (NXT(1) == ']') && (NXT(2) == '>')) {
  ------------------
  |  | 2223|      0|#define NXT(val) ctxt->input->cur[(val)]
  ------------------
  |  Branch (4720:6): [True: 0, False: 31.1k]
  |  Branch (4720:22): [True: 0, False: 0]
  |  Branch (4720:41): [True: 0, False: 0]
  ------------------
 4721|      0|	    xmlFatalErr(ctxt, XML_ERR_MISPLACED_CDATA_END, NULL);
 4722|      0|	}
 4723|  31.1k|	COPY_BUF(buf, nbchar, cur);
  ------------------
  |  | 2295|  31.1k|    if (v < 0x80) b[i++] = v;						\
  |  |  ------------------
  |  |  |  Branch (2295:9): [True: 24.6k, False: 6.55k]
  |  |  ------------------
  |  | 2296|  31.1k|    else i += xmlCopyCharMultiByte(&b[i],v)
  ------------------
 4724|       |	/* move current position before possible calling of ctxt->sax->characters */
 4725|  31.1k|	NEXTL(l);
  ------------------
  |  | 2284|  31.1k|#define NEXTL(l) do {							\
  |  | 2285|  31.1k|    if (*(ctxt->input->cur) == '\n') {					\
  |  |  ------------------
  |  |  |  Branch (2285:9): [True: 515, False: 30.6k]
  |  |  ------------------
  |  | 2286|    515|	ctxt->input->line++; ctxt->input->col = 1;			\
  |  | 2287|  30.6k|    } else ctxt->input->col++;						\
  |  | 2288|  31.1k|    ctxt->input->cur += l;				\
  |  | 2289|  31.1k|  } while (0)
  |  |  ------------------
  |  |  |  Branch (2289:12): [Folded - Ignored]
  |  |  ------------------
  ------------------
 4726|  31.1k|	if (nbchar >= XML_PARSER_BIG_BUFFER_SIZE) {
  ------------------
  |  |  166|  31.1k|#define XML_PARSER_BIG_BUFFER_SIZE 300
  ------------------
  |  Branch (4726:6): [True: 98, False: 31.0k]
  ------------------
 4727|     98|	    buf[nbchar] = 0;
 4728|       |
 4729|       |	    /*
 4730|       |	     * OK the segment is to be consumed as chars.
 4731|       |	     */
 4732|     98|	    if ((ctxt->sax != NULL) && (!ctxt->disableSAX)) {
  ------------------
  |  Branch (4732:10): [True: 98, False: 0]
  |  Branch (4732:33): [True: 98, False: 0]
  ------------------
 4733|     98|		if (areBlanks(ctxt, buf, nbchar, 0)) {
  ------------------
  |  Branch (4733:7): [True: 0, False: 98]
  ------------------
 4734|      0|		    if (ctxt->sax->ignorableWhitespace != NULL)
  ------------------
  |  Branch (4734:11): [True: 0, False: 0]
  ------------------
 4735|      0|			ctxt->sax->ignorableWhitespace(ctxt->userData,
 4736|      0|			                               buf, nbchar);
 4737|     98|		} else {
 4738|     98|		    if (ctxt->sax->characters != NULL)
  ------------------
  |  Branch (4738:11): [True: 98, False: 0]
  ------------------
 4739|     98|			ctxt->sax->characters(ctxt->userData, buf, nbchar);
 4740|     98|		    if ((ctxt->sax->characters !=
  ------------------
  |  Branch (4740:11): [True: 0, False: 98]
  ------------------
 4741|     98|		         ctxt->sax->ignorableWhitespace) &&
 4742|     98|			(*ctxt->space == -1))
  ------------------
  |  Branch (4742:4): [True: 0, False: 0]
  ------------------
 4743|      0|			*ctxt->space = -2;
 4744|     98|		}
 4745|     98|	    }
 4746|     98|	    nbchar = 0;
 4747|       |            /* something really bad happened in the SAX callback */
 4748|     98|            if (ctxt->instate != XML_PARSER_CONTENT)
  ------------------
  |  Branch (4748:17): [True: 0, False: 98]
  ------------------
 4749|      0|                return;
 4750|     98|            SHRINK;
  ------------------
  |  | 2265|     98|    if (((ctxt->progressive == 0) || (ctxt->inputNr > 1)) && \
  |  |  ------------------
  |  |  |  Branch (2265:10): [True: 58, False: 40]
  |  |  |  Branch (2265:38): [True: 0, False: 40]
  |  |  ------------------
  |  | 2266|     98|        (ctxt->input->cur - ctxt->input->base > 2 * INPUT_CHUNK) && \
  |  |  ------------------
  |  |  |  |   97|     58|#define INPUT_CHUNK	250
  |  |  ------------------
  |  |  |  Branch (2266:9): [True: 52, False: 6]
  |  |  ------------------
  |  | 2267|     98|	(ctxt->input->end - ctxt->input->cur < 2 * INPUT_CHUNK)) \
  |  |  ------------------
  |  |  |  |   97|     52|#define INPUT_CHUNK	250
  |  |  ------------------
  |  |  |  Branch (2267:2): [True: 4, False: 48]
  |  |  ------------------
  |  | 2268|     98|	xmlParserShrink(ctxt);
  ------------------
 4751|     98|	}
 4752|  31.1k|	cur = CUR_CHAR(l);
  ------------------
  |  | 2291|  31.1k|#define CUR_CHAR(l) xmlCurrentChar(ctxt, &l)
  ------------------
 4753|  31.1k|    }
 4754|    829|    if (ctxt->instate == XML_PARSER_EOF)
  ------------------
  |  Branch (4754:9): [True: 0, False: 829]
  ------------------
 4755|      0|        return;
 4756|    829|    if (nbchar != 0) {
  ------------------
  |  Branch (4756:9): [True: 266, False: 563]
  ------------------
 4757|    266|        buf[nbchar] = 0;
 4758|       |	/*
 4759|       |	 * OK the segment is to be consumed as chars.
 4760|       |	 */
 4761|    266|	if ((ctxt->sax != NULL) && (!ctxt->disableSAX)) {
  ------------------
  |  Branch (4761:6): [True: 266, False: 0]
  |  Branch (4761:29): [True: 262, False: 4]
  ------------------
 4762|    262|	    if (areBlanks(ctxt, buf, nbchar, 0)) {
  ------------------
  |  Branch (4762:10): [True: 0, False: 262]
  ------------------
 4763|      0|		if (ctxt->sax->ignorableWhitespace != NULL)
  ------------------
  |  Branch (4763:7): [True: 0, False: 0]
  ------------------
 4764|      0|		    ctxt->sax->ignorableWhitespace(ctxt->userData, buf, nbchar);
 4765|    262|	    } else {
 4766|    262|		if (ctxt->sax->characters != NULL)
  ------------------
  |  Branch (4766:7): [True: 262, False: 0]
  ------------------
 4767|    262|		    ctxt->sax->characters(ctxt->userData, buf, nbchar);
 4768|    262|		if ((ctxt->sax->characters != ctxt->sax->ignorableWhitespace) &&
  ------------------
  |  Branch (4768:7): [True: 0, False: 262]
  ------------------
 4769|    262|		    (*ctxt->space == -1))
  ------------------
  |  Branch (4769:7): [True: 0, False: 0]
  ------------------
 4770|      0|		    *ctxt->space = -2;
 4771|    262|	    }
 4772|    262|	}
 4773|    266|    }
 4774|       |    /*
 4775|       |     * cur == 0 can mean
 4776|       |     *
 4777|       |     * - XML_PARSER_EOF or memory error. This is checked above.
 4778|       |     * - An actual 0 character.
 4779|       |     * - End of buffer.
 4780|       |     * - An incomplete UTF-8 sequence. This is allowed if partial is set.
 4781|       |     */
 4782|    829|    if (ctxt->input->cur < ctxt->input->end) {
  ------------------
  |  Branch (4782:9): [True: 211, False: 618]
  ------------------
 4783|    211|        if ((cur == 0) && (CUR != 0)) {
  ------------------
  |  | 2222|      4|#define CUR (*ctxt->input->cur)
  ------------------
  |  Branch (4783:13): [True: 4, False: 207]
  |  Branch (4783:27): [True: 4, False: 0]
  ------------------
 4784|      4|            if (partial == 0) {
  ------------------
  |  Branch (4784:17): [True: 4, False: 0]
  ------------------
 4785|      4|                xmlFatalErrMsgInt(ctxt, XML_ERR_INVALID_CHAR,
 4786|      4|                        "Incomplete UTF-8 sequence starting with %02X\n", CUR);
  ------------------
  |  | 2222|      4|#define CUR (*ctxt->input->cur)
  ------------------
 4787|      4|                NEXTL(1);
  ------------------
  |  | 2284|      4|#define NEXTL(l) do {							\
  |  | 2285|      4|    if (*(ctxt->input->cur) == '\n') {					\
  |  |  ------------------
  |  |  |  Branch (2285:9): [True: 0, False: 4]
  |  |  ------------------
  |  | 2286|      0|	ctxt->input->line++; ctxt->input->col = 1;			\
  |  | 2287|      4|    } else ctxt->input->col++;						\
  |  | 2288|      4|    ctxt->input->cur += l;				\
  |  | 2289|      4|  } while (0)
  |  |  ------------------
  |  |  |  Branch (2289:12): [Folded - Ignored]
  |  |  ------------------
  ------------------
 4788|      4|            }
 4789|    207|        } else if ((cur != '<') && (cur != '&')) {
  ------------------
  |  Branch (4789:20): [True: 0, False: 207]
  |  Branch (4789:36): [True: 0, False: 0]
  ------------------
 4790|       |            /* Generate the error and skip the offending character */
 4791|      0|            xmlFatalErrMsgInt(ctxt, XML_ERR_INVALID_CHAR,
 4792|      0|                              "PCDATA invalid Char value %d\n", cur);
 4793|      0|            NEXTL(l);
  ------------------
  |  | 2284|      0|#define NEXTL(l) do {							\
  |  | 2285|      0|    if (*(ctxt->input->cur) == '\n') {					\
  |  |  ------------------
  |  |  |  Branch (2285:9): [True: 0, False: 0]
  |  |  ------------------
  |  | 2286|      0|	ctxt->input->line++; ctxt->input->col = 1;			\
  |  | 2287|      0|    } else ctxt->input->col++;						\
  |  | 2288|      0|    ctxt->input->cur += l;				\
  |  | 2289|      0|  } while (0)
  |  |  ------------------
  |  |  |  Branch (2289:12): [Folded - Ignored]
  |  |  ------------------
  ------------------
 4794|      0|        }
 4795|    211|    }
 4796|    829|}
parser.c:xmlParseCommentComplex:
 4901|     24|                       size_t len, size_t size) {
 4902|     24|    int q, ql;
 4903|     24|    int r, rl;
 4904|     24|    int cur, l;
 4905|     24|    size_t maxLength = (ctxt->options & XML_PARSE_HUGE) ?
  ------------------
  |  Branch (4905:24): [True: 0, False: 24]
  ------------------
 4906|      0|                       XML_MAX_HUGE_LENGTH :
  ------------------
  |  |   49|      0|#define XML_MAX_HUGE_LENGTH 1000000000
  ------------------
 4907|     24|                       XML_MAX_TEXT_LENGTH;
  ------------------
  |  |   42|     48|#define XML_MAX_TEXT_LENGTH 10000000
  ------------------
 4908|     24|    int inputid;
 4909|       |
 4910|     24|    inputid = ctxt->input->id;
 4911|       |
 4912|     24|    if (buf == NULL) {
  ------------------
  |  Branch (4912:9): [True: 4, False: 20]
  ------------------
 4913|      4|        len = 0;
 4914|      4|	size = XML_PARSER_BUFFER_SIZE;
  ------------------
  |  |  167|      4|#define XML_PARSER_BUFFER_SIZE 100
  ------------------
 4915|      4|	buf = (xmlChar *) xmlMallocAtomic(size);
 4916|      4|	if (buf == NULL) {
  ------------------
  |  Branch (4916:6): [True: 0, False: 4]
  ------------------
 4917|      0|	    xmlErrMemory(ctxt, NULL);
 4918|      0|	    return;
 4919|      0|	}
 4920|      4|    }
 4921|     24|    q = CUR_CHAR(ql);
  ------------------
  |  | 2291|     24|#define CUR_CHAR(l) xmlCurrentChar(ctxt, &l)
  ------------------
 4922|     24|    if (q == 0)
  ------------------
  |  Branch (4922:9): [True: 0, False: 24]
  ------------------
 4923|      0|        goto not_terminated;
 4924|     24|    if (!IS_CHAR(q)) {
  ------------------
  |  |  125|     24|#define IS_CHAR(c)   xmlIsCharQ(c)
  |  |  ------------------
  |  |  |  |  118|     24|#define xmlIsCharQ(c)		(((c) < 0x100) ? \
  |  |  |  |  ------------------
  |  |  |  |  |  Branch (118:25): [True: 24, False: 0]
  |  |  |  |  ------------------
  |  |  |  |  119|     24|				 xmlIsChar_ch((c)) :\
  |  |  |  |  ------------------
  |  |  |  |  |  |  108|     24|#define xmlIsChar_ch(c)		(((0x9 <= (c)) && ((c) <= 0xa)) || \
  |  |  |  |  |  |  ------------------
  |  |  |  |  |  |  |  Branch (108:28): [True: 24, False: 0]
  |  |  |  |  |  |  |  Branch (108:44): [True: 0, False: 24]
  |  |  |  |  |  |  ------------------
  |  |  |  |  |  |  109|     24|				 ((c) == 0xd) || \
  |  |  |  |  |  |  ------------------
  |  |  |  |  |  |  |  Branch (109:6): [True: 0, False: 24]
  |  |  |  |  |  |  ------------------
  |  |  |  |  |  |  110|     24|				  (0x20 <= (c)))
  |  |  |  |  |  |  ------------------
  |  |  |  |  |  |  |  Branch (110:7): [True: 20, False: 4]
  |  |  |  |  |  |  ------------------
  |  |  |  |  ------------------
  |  |  |  |  120|     24|				(((0x100 <= (c)) && ((c) <= 0xd7ff)) || \
  |  |  |  |  ------------------
  |  |  |  |  |  Branch (120:7): [True: 0, False: 0]
  |  |  |  |  |  Branch (120:25): [True: 0, False: 0]
  |  |  |  |  ------------------
  |  |  |  |  121|      0|				 ((0xe000 <= (c)) && ((c) <= 0xfffd)) || \
  |  |  |  |  ------------------
  |  |  |  |  |  Branch (121:7): [True: 0, False: 0]
  |  |  |  |  |  Branch (121:26): [True: 0, False: 0]
  |  |  |  |  ------------------
  |  |  |  |  122|      0|				 ((0x10000 <= (c)) && ((c) <= 0x10ffff))))
  |  |  |  |  ------------------
  |  |  |  |  |  Branch (122:7): [True: 0, False: 0]
  |  |  |  |  |  Branch (122:27): [True: 0, False: 0]
  |  |  |  |  ------------------
  |  |  ------------------
  ------------------
  |  Branch (4924:9): [True: 4, False: 20]
  ------------------
 4925|      4|        xmlFatalErrMsgInt(ctxt, XML_ERR_INVALID_CHAR,
 4926|      4|                          "xmlParseComment: invalid xmlChar value %d\n",
 4927|      4|	                  q);
 4928|      4|	xmlFree (buf);
 4929|      4|	return;
 4930|      4|    }
 4931|     20|    NEXTL(ql);
  ------------------
  |  | 2284|     20|#define NEXTL(l) do {							\
  |  | 2285|     20|    if (*(ctxt->input->cur) == '\n') {					\
  |  |  ------------------
  |  |  |  Branch (2285:9): [True: 0, False: 20]
  |  |  ------------------
  |  | 2286|      0|	ctxt->input->line++; ctxt->input->col = 1;			\
  |  | 2287|     20|    } else ctxt->input->col++;						\
  |  | 2288|     20|    ctxt->input->cur += l;				\
  |  | 2289|     20|  } while (0)
  |  |  ------------------
  |  |  |  Branch (2289:12): [Folded - Ignored]
  |  |  ------------------
  ------------------
 4932|     20|    r = CUR_CHAR(rl);
  ------------------
  |  | 2291|     20|#define CUR_CHAR(l) xmlCurrentChar(ctxt, &l)
  ------------------
 4933|     20|    if (r == 0)
  ------------------
  |  Branch (4933:9): [True: 0, False: 20]
  ------------------
 4934|      0|        goto not_terminated;
 4935|     20|    if (!IS_CHAR(r)) {
  ------------------
  |  |  125|     20|#define IS_CHAR(c)   xmlIsCharQ(c)
  |  |  ------------------
  |  |  |  |  118|     20|#define xmlIsCharQ(c)		(((c) < 0x100) ? \
  |  |  |  |  ------------------
  |  |  |  |  |  Branch (118:25): [True: 20, False: 0]
  |  |  |  |  ------------------
  |  |  |  |  119|     20|				 xmlIsChar_ch((c)) :\
  |  |  |  |  ------------------
  |  |  |  |  |  |  108|     20|#define xmlIsChar_ch(c)		(((0x9 <= (c)) && ((c) <= 0xa)) || \
  |  |  |  |  |  |  ------------------
  |  |  |  |  |  |  |  Branch (108:28): [True: 20, False: 0]
  |  |  |  |  |  |  |  Branch (108:44): [True: 0, False: 20]
  |  |  |  |  |  |  ------------------
  |  |  |  |  |  |  109|     20|				 ((c) == 0xd) || \
  |  |  |  |  |  |  ------------------
  |  |  |  |  |  |  |  Branch (109:6): [True: 0, False: 20]
  |  |  |  |  |  |  ------------------
  |  |  |  |  |  |  110|     20|				  (0x20 <= (c)))
  |  |  |  |  |  |  ------------------
  |  |  |  |  |  |  |  Branch (110:7): [True: 20, False: 0]
  |  |  |  |  |  |  ------------------
  |  |  |  |  ------------------
  |  |  |  |  120|     20|				(((0x100 <= (c)) && ((c) <= 0xd7ff)) || \
  |  |  |  |  ------------------
  |  |  |  |  |  Branch (120:7): [True: 0, False: 0]
  |  |  |  |  |  Branch (120:25): [True: 0, False: 0]
  |  |  |  |  ------------------
  |  |  |  |  121|      0|				 ((0xe000 <= (c)) && ((c) <= 0xfffd)) || \
  |  |  |  |  ------------------
  |  |  |  |  |  Branch (121:7): [True: 0, False: 0]
  |  |  |  |  |  Branch (121:26): [True: 0, False: 0]
  |  |  |  |  ------------------
  |  |  |  |  122|      0|				 ((0x10000 <= (c)) && ((c) <= 0x10ffff))))
  |  |  |  |  ------------------
  |  |  |  |  |  Branch (122:7): [True: 0, False: 0]
  |  |  |  |  |  Branch (122:27): [True: 0, False: 0]
  |  |  |  |  ------------------
  |  |  ------------------
  ------------------
  |  Branch (4935:9): [True: 0, False: 20]
  ------------------
 4936|      0|        xmlFatalErrMsgInt(ctxt, XML_ERR_INVALID_CHAR,
 4937|      0|                          "xmlParseComment: invalid xmlChar value %d\n",
 4938|      0|	                  r);
 4939|      0|	xmlFree (buf);
 4940|      0|	return;
 4941|      0|    }
 4942|     20|    NEXTL(rl);
  ------------------
  |  | 2284|     20|#define NEXTL(l) do {							\
  |  | 2285|     20|    if (*(ctxt->input->cur) == '\n') {					\
  |  |  ------------------
  |  |  |  Branch (2285:9): [True: 0, False: 20]
  |  |  ------------------
  |  | 2286|      0|	ctxt->input->line++; ctxt->input->col = 1;			\
  |  | 2287|     20|    } else ctxt->input->col++;						\
  |  | 2288|     20|    ctxt->input->cur += l;				\
  |  | 2289|     20|  } while (0)
  |  |  ------------------
  |  |  |  Branch (2289:12): [Folded - Ignored]
  |  |  ------------------
  ------------------
 4943|     20|    cur = CUR_CHAR(l);
  ------------------
  |  | 2291|     20|#define CUR_CHAR(l) xmlCurrentChar(ctxt, &l)
  ------------------
 4944|     20|    if (cur == 0)
  ------------------
  |  Branch (4944:9): [True: 0, False: 20]
  ------------------
 4945|      0|        goto not_terminated;
 4946|    152|    while (IS_CHAR(cur) && /* checked */
  ------------------
  |  |  125|    152|#define IS_CHAR(c)   xmlIsCharQ(c)
  |  |  ------------------
  |  |  |  |  118|    304|#define xmlIsCharQ(c)		(((c) < 0x100) ? \
  |  |  |  |  ------------------
  |  |  |  |  |  Branch (118:24): [True: 152, False: 0]
  |  |  |  |  |  Branch (118:25): [True: 152, False: 0]
  |  |  |  |  ------------------
  |  |  |  |  119|    304|				 xmlIsChar_ch((c)) :\
  |  |  |  |  ------------------
  |  |  |  |  |  |  108|    152|#define xmlIsChar_ch(c)		(((0x9 <= (c)) && ((c) <= 0xa)) || \
  |  |  |  |  |  |  ------------------
  |  |  |  |  |  |  |  Branch (108:28): [True: 152, False: 0]
  |  |  |  |  |  |  |  Branch (108:44): [True: 0, False: 152]
  |  |  |  |  |  |  ------------------
  |  |  |  |  |  |  109|    152|				 ((c) == 0xd) || \
  |  |  |  |  |  |  ------------------
  |  |  |  |  |  |  |  Branch (109:6): [True: 0, False: 152]
  |  |  |  |  |  |  ------------------
  |  |  |  |  |  |  110|    152|				  (0x20 <= (c)))
  |  |  |  |  |  |  ------------------
  |  |  |  |  |  |  |  Branch (110:7): [True: 152, False: 0]
  |  |  |  |  |  |  ------------------
  |  |  |  |  ------------------
  |  |  |  |  120|    304|				(((0x100 <= (c)) && ((c) <= 0xd7ff)) || \
  |  |  |  |  ------------------
  |  |  |  |  |  Branch (120:7): [True: 0, False: 0]
  |  |  |  |  |  Branch (120:25): [True: 0, False: 0]
  |  |  |  |  ------------------
  |  |  |  |  121|      0|				 ((0xe000 <= (c)) && ((c) <= 0xfffd)) || \
  |  |  |  |  ------------------
  |  |  |  |  |  Branch (121:7): [True: 0, False: 0]
  |  |  |  |  |  Branch (121:26): [True: 0, False: 0]
  |  |  |  |  ------------------
  |  |  |  |  122|      0|				 ((0x10000 <= (c)) && ((c) <= 0x10ffff))))
  |  |  |  |  ------------------
  |  |  |  |  |  Branch (122:7): [True: 0, False: 0]
  |  |  |  |  |  Branch (122:27): [True: 0, False: 0]
  |  |  |  |  ------------------
  |  |  ------------------
  ------------------
 4947|    152|           ((cur != '>') ||
  ------------------
  |  Branch (4947:13): [True: 124, False: 28]
  ------------------
 4948|    152|	    (r != '-') || (q != '-'))) {
  ------------------
  |  Branch (4948:6): [True: 8, False: 20]
  |  Branch (4948:20): [True: 0, False: 20]
  ------------------
 4949|    132|	if ((r == '-') && (q == '-')) {
  ------------------
  |  Branch (4949:6): [True: 20, False: 112]
  |  Branch (4949:20): [True: 0, False: 20]
  ------------------
 4950|      0|	    xmlFatalErr(ctxt, XML_ERR_HYPHEN_IN_COMMENT, NULL);
 4951|      0|	}
 4952|    132|	if (len + 5 >= size) {
  ------------------
  |  Branch (4952:6): [True: 0, False: 132]
  ------------------
 4953|      0|	    xmlChar *new_buf;
 4954|      0|            size_t new_size;
 4955|       |
 4956|      0|	    new_size = size * 2;
 4957|      0|	    new_buf = (xmlChar *) xmlRealloc(buf, new_size);
 4958|      0|	    if (new_buf == NULL) {
  ------------------
  |  Branch (4958:10): [True: 0, False: 0]
  ------------------
 4959|      0|		xmlFree (buf);
 4960|      0|		xmlErrMemory(ctxt, NULL);
 4961|      0|		return;
 4962|      0|	    }
 4963|      0|	    buf = new_buf;
 4964|      0|            size = new_size;
 4965|      0|	}
 4966|    132|	COPY_BUF(buf, len, q);
  ------------------
  |  | 2295|    132|    if (v < 0x80) b[i++] = v;						\
  |  |  ------------------
  |  |  |  Branch (2295:9): [True: 108, False: 24]
  |  |  ------------------
  |  | 2296|    132|    else i += xmlCopyCharMultiByte(&b[i],v)
  ------------------
 4967|    132|        if (len > maxLength) {
  ------------------
  |  Branch (4967:13): [True: 0, False: 132]
  ------------------
 4968|      0|            xmlFatalErrMsgStr(ctxt, XML_ERR_COMMENT_NOT_FINISHED,
 4969|      0|                         "Comment too big found", NULL);
 4970|      0|            xmlFree (buf);
 4971|      0|            return;
 4972|      0|        }
 4973|       |
 4974|    132|	q = r;
 4975|    132|	ql = rl;
 4976|    132|	r = cur;
 4977|    132|	rl = l;
 4978|       |
 4979|    132|	NEXTL(l);
  ------------------
  |  | 2284|    132|#define NEXTL(l) do {							\
  |  | 2285|    132|    if (*(ctxt->input->cur) == '\n') {					\
  |  |  ------------------
  |  |  |  Branch (2285:9): [True: 0, False: 132]
  |  |  ------------------
  |  | 2286|      0|	ctxt->input->line++; ctxt->input->col = 1;			\
  |  | 2287|    132|    } else ctxt->input->col++;						\
  |  | 2288|    132|    ctxt->input->cur += l;				\
  |  | 2289|    132|  } while (0)
  |  |  ------------------
  |  |  |  Branch (2289:12): [Folded - Ignored]
  |  |  ------------------
  ------------------
 4980|    132|	cur = CUR_CHAR(l);
  ------------------
  |  | 2291|    132|#define CUR_CHAR(l) xmlCurrentChar(ctxt, &l)
  ------------------
 4981|       |
 4982|    132|    }
 4983|     20|    buf[len] = 0;
 4984|     20|    if (ctxt->instate == XML_PARSER_EOF) {
  ------------------
  |  Branch (4984:9): [True: 0, False: 20]
  ------------------
 4985|      0|        xmlFree(buf);
 4986|      0|        return;
 4987|      0|    }
 4988|     20|    if (cur == 0) {
  ------------------
  |  Branch (4988:9): [True: 0, False: 20]
  ------------------
 4989|      0|	xmlFatalErrMsgStr(ctxt, XML_ERR_COMMENT_NOT_FINISHED,
 4990|      0|	                     "Comment not terminated \n<!--%.50s\n", buf);
 4991|     20|    } else if (!IS_CHAR(cur)) {
  ------------------
  |  |  125|     20|#define IS_CHAR(c)   xmlIsCharQ(c)
  |  |  ------------------
  |  |  |  |  118|     20|#define xmlIsCharQ(c)		(((c) < 0x100) ? \
  |  |  |  |  ------------------
  |  |  |  |  |  Branch (118:25): [True: 20, False: 0]
  |  |  |  |  ------------------
  |  |  |  |  119|     20|				 xmlIsChar_ch((c)) :\
  |  |  |  |  ------------------
  |  |  |  |  |  |  108|     20|#define xmlIsChar_ch(c)		(((0x9 <= (c)) && ((c) <= 0xa)) || \
  |  |  |  |  |  |  ------------------
  |  |  |  |  |  |  |  Branch (108:28): [True: 20, False: 0]
  |  |  |  |  |  |  |  Branch (108:44): [True: 0, False: 20]
  |  |  |  |  |  |  ------------------
  |  |  |  |  |  |  109|     20|				 ((c) == 0xd) || \
  |  |  |  |  |  |  ------------------
  |  |  |  |  |  |  |  Branch (109:6): [True: 0, False: 20]
  |  |  |  |  |  |  ------------------
  |  |  |  |  |  |  110|     20|				  (0x20 <= (c)))
  |  |  |  |  |  |  ------------------
  |  |  |  |  |  |  |  Branch (110:7): [True: 20, False: 0]
  |  |  |  |  |  |  ------------------
  |  |  |  |  ------------------
  |  |  |  |  120|     20|				(((0x100 <= (c)) && ((c) <= 0xd7ff)) || \
  |  |  |  |  ------------------
  |  |  |  |  |  Branch (120:7): [True: 0, False: 0]
  |  |  |  |  |  Branch (120:25): [True: 0, False: 0]
  |  |  |  |  ------------------
  |  |  |  |  121|      0|				 ((0xe000 <= (c)) && ((c) <= 0xfffd)) || \
  |  |  |  |  ------------------
  |  |  |  |  |  Branch (121:7): [True: 0, False: 0]
  |  |  |  |  |  Branch (121:26): [True: 0, False: 0]
  |  |  |  |  ------------------
  |  |  |  |  122|      0|				 ((0x10000 <= (c)) && ((c) <= 0x10ffff))))
  |  |  |  |  ------------------
  |  |  |  |  |  Branch (122:7): [True: 0, False: 0]
  |  |  |  |  |  Branch (122:27): [True: 0, False: 0]
  |  |  |  |  ------------------
  |  |  ------------------
  ------------------
  |  Branch (4991:16): [True: 0, False: 20]
  ------------------
 4992|      0|        xmlFatalErrMsgInt(ctxt, XML_ERR_INVALID_CHAR,
 4993|      0|                          "xmlParseComment: invalid xmlChar value %d\n",
 4994|      0|	                  cur);
 4995|     20|    } else {
 4996|     20|	if (inputid != ctxt->input->id) {
  ------------------
  |  Branch (4996:6): [True: 0, False: 20]
  ------------------
 4997|      0|	    xmlFatalErrMsg(ctxt, XML_ERR_ENTITY_BOUNDARY,
 4998|      0|		           "Comment doesn't start and stop in the same"
 4999|      0|                           " entity\n");
 5000|      0|	}
 5001|     20|        NEXT;
  ------------------
  |  | 2275|     20|#define NEXT xmlNextChar(ctxt)
  ------------------
 5002|     20|	if ((ctxt->sax != NULL) && (ctxt->sax->comment != NULL) &&
  ------------------
  |  Branch (5002:6): [True: 20, False: 0]
  |  Branch (5002:29): [True: 20, False: 0]
  ------------------
 5003|     20|	    (!ctxt->disableSAX))
  ------------------
  |  Branch (5003:6): [True: 20, False: 0]
  ------------------
 5004|     20|	    ctxt->sax->comment(ctxt->userData, buf);
 5005|     20|    }
 5006|     20|    xmlFree(buf);
 5007|     20|    return;
 5008|      0|not_terminated:
 5009|      0|    xmlFatalErrMsgStr(ctxt, XML_ERR_COMMENT_NOT_FINISHED,
 5010|      0|			 "Comment not terminated\n", NULL);
 5011|      0|    xmlFree(buf);
 5012|      0|    return;
 5013|     20|}
parser.c:xmlNsErr:
  501|     48|{
  502|     48|    if ((ctxt != NULL) && (ctxt->disableSAX != 0) &&
  ------------------
  |  Branch (502:9): [True: 48, False: 0]
  |  Branch (502:27): [True: 0, False: 48]
  ------------------
  503|     48|        (ctxt->instate == XML_PARSER_EOF))
  ------------------
  |  Branch (503:9): [True: 0, False: 0]
  ------------------
  504|      0|	return;
  505|     48|    if (ctxt != NULL)
  ------------------
  |  Branch (505:9): [True: 48, False: 0]
  ------------------
  506|     48|	ctxt->errNo = error;
  507|     48|    __xmlRaiseError(NULL, NULL, NULL, ctxt, NULL, XML_FROM_NAMESPACE, error,
  508|     48|                    XML_ERR_ERROR, NULL, 0, (const char *) info1,
  509|     48|                    (const char *) info2, (const char *) info3, 0, 0, msg,
  510|     48|                    info1, info2, info3);
  511|     48|    if (ctxt != NULL)
  ------------------
  |  Branch (511:9): [True: 48, False: 0]
  ------------------
  512|     48|	ctxt->nsWellFormed = 0;
  513|     48|}
parser.c:xmlErrMsgStr:
  474|      8|{
  475|      8|    if ((ctxt != NULL) && (ctxt->disableSAX != 0) &&
  ------------------
  |  Branch (475:9): [True: 8, False: 0]
  |  Branch (475:27): [True: 0, False: 8]
  ------------------
  476|      8|        (ctxt->instate == XML_PARSER_EOF))
  ------------------
  |  Branch (476:9): [True: 0, False: 0]
  ------------------
  477|      0|	return;
  478|      8|    if (ctxt != NULL)
  ------------------
  |  Branch (478:9): [True: 8, False: 0]
  ------------------
  479|      8|	ctxt->errNo = error;
  480|      8|    __xmlRaiseError(NULL, NULL, NULL, ctxt, NULL,
  481|      8|                    XML_FROM_PARSER, error, XML_ERR_ERROR,
  482|      8|                    NULL, 0, (const char *) val, NULL, NULL, 0, 0, msg,
  483|      8|                    val);
  484|      8|}
parser.c:xmlAttrNormalizeSpace:
  922|  1.36k|{
  923|  1.36k|    if ((src == NULL) || (dst == NULL))
  ------------------
  |  Branch (923:9): [True: 0, False: 1.36k]
  |  Branch (923:26): [True: 0, False: 1.36k]
  ------------------
  924|      0|        return(NULL);
  925|       |
  926|  1.37k|    while (*src == 0x20) src++;
  ------------------
  |  Branch (926:12): [True: 4, False: 1.36k]
  ------------------
  927|  3.50k|    while (*src != 0) {
  ------------------
  |  Branch (927:12): [True: 2.14k, False: 1.36k]
  ------------------
  928|  2.14k|	if (*src == 0x20) {
  ------------------
  |  Branch (928:6): [True: 60, False: 2.08k]
  ------------------
  929|    192|	    while (*src == 0x20) src++;
  ------------------
  |  Branch (929:13): [True: 132, False: 60]
  ------------------
  930|     60|	    if (*src != 0)
  ------------------
  |  Branch (930:10): [True: 48, False: 12]
  ------------------
  931|     48|		*dst++ = 0x20;
  932|  2.08k|	} else {
  933|  2.08k|	    *dst++ = *src++;
  934|  2.08k|	}
  935|  2.14k|    }
  936|  1.36k|    *dst = 0;
  937|  1.36k|    if (dst == src)
  ------------------
  |  Branch (937:9): [True: 1.34k, False: 24]
  ------------------
  938|  1.34k|       return(NULL);
  939|     24|    return(dst);
  940|  1.36k|}
parser.c:xmlAddDefAttrs:
 1014|  1.64k|               const xmlChar *value) {
 1015|  1.64k|    xmlDefAttrsPtr defaults;
 1016|  1.64k|    xmlDefAttr *attr;
 1017|  1.64k|    int len, expandedSize;
 1018|  1.64k|    xmlHashedString name;
 1019|  1.64k|    xmlHashedString prefix;
 1020|  1.64k|    xmlHashedString hvalue;
 1021|  1.64k|    const xmlChar *localname;
 1022|       |
 1023|       |    /*
 1024|       |     * Allows to detect attribute redefinitions
 1025|       |     */
 1026|  1.64k|    if (ctxt->attsSpecial != NULL) {
  ------------------
  |  Branch (1026:9): [True: 1.58k, False: 60]
  ------------------
 1027|  1.58k|        if (xmlHashLookup2(ctxt->attsSpecial, fullname, fullattr) != NULL)
  ------------------
  |  Branch (1027:13): [True: 4, False: 1.58k]
  ------------------
 1028|      4|	    return;
 1029|  1.58k|    }
 1030|       |
 1031|  1.64k|    if (ctxt->attsDefault == NULL) {
  ------------------
  |  Branch (1031:9): [True: 72, False: 1.56k]
  ------------------
 1032|     72|        ctxt->attsDefault = xmlHashCreateDict(10, ctxt->dict);
 1033|     72|	if (ctxt->attsDefault == NULL)
  ------------------
  |  Branch (1033:6): [True: 0, False: 72]
  ------------------
 1034|      0|	    goto mem_error;
 1035|     72|    }
 1036|       |
 1037|       |    /*
 1038|       |     * split the element name into prefix:localname , the string found
 1039|       |     * are within the DTD and then not associated to namespace names.
 1040|       |     */
 1041|  1.64k|    localname = xmlSplitQName3(fullname, &len);
 1042|  1.64k|    if (localname == NULL) {
  ------------------
  |  Branch (1042:9): [True: 1.61k, False: 24]
  ------------------
 1043|  1.61k|        name = xmlDictLookupHashed(ctxt->dict, fullname, -1);
 1044|  1.61k|	prefix.name = NULL;
 1045|  1.61k|    } else {
 1046|     24|        name = xmlDictLookupHashed(ctxt->dict, localname, -1);
 1047|     24|	prefix = xmlDictLookupHashed(ctxt->dict, fullname, len);
 1048|     24|        if (prefix.name == NULL)
  ------------------
  |  Branch (1048:13): [True: 0, False: 24]
  ------------------
 1049|      0|            goto mem_error;
 1050|     24|    }
 1051|  1.64k|    if (name.name == NULL)
  ------------------
  |  Branch (1051:9): [True: 0, False: 1.64k]
  ------------------
 1052|      0|        goto mem_error;
 1053|       |
 1054|       |    /*
 1055|       |     * make sure there is some storage
 1056|       |     */
 1057|  1.64k|    defaults = xmlHashLookup2(ctxt->attsDefault, name.name, prefix.name);
 1058|  1.64k|    if ((defaults == NULL) ||
  ------------------
  |  Branch (1058:9): [True: 224, False: 1.41k]
  ------------------
 1059|  1.64k|        (defaults->nbAttrs >= defaults->maxAttrs)) {
  ------------------
  |  Branch (1059:9): [True: 32, False: 1.38k]
  ------------------
 1060|    256|        xmlDefAttrsPtr temp;
 1061|    256|        int newSize;
 1062|       |
 1063|    256|        newSize = (defaults != NULL) ? 2 * defaults->maxAttrs : 4;
  ------------------
  |  Branch (1063:19): [True: 32, False: 224]
  ------------------
 1064|    256|        temp = xmlRealloc(defaults,
 1065|    256|                          sizeof(*defaults) + newSize * sizeof(xmlDefAttr));
 1066|    256|	if (temp == NULL)
  ------------------
  |  Branch (1066:6): [True: 0, False: 256]
  ------------------
 1067|      0|	    goto mem_error;
 1068|    256|        if (defaults == NULL)
  ------------------
  |  Branch (1068:13): [True: 224, False: 32]
  ------------------
 1069|    224|            temp->nbAttrs = 0;
 1070|    256|	temp->maxAttrs = newSize;
 1071|    256|        defaults = temp;
 1072|    256|	if (xmlHashUpdateEntry2(ctxt->attsDefault, name.name, prefix.name,
  ------------------
  |  Branch (1072:6): [True: 0, False: 256]
  ------------------
 1073|    256|	                        defaults, NULL) < 0) {
 1074|      0|	    xmlFree(defaults);
 1075|      0|	    goto mem_error;
 1076|      0|	}
 1077|    256|    }
 1078|       |
 1079|       |    /*
 1080|       |     * Split the attribute name into prefix:localname , the string found
 1081|       |     * are within the DTD and hen not associated to namespace names.
 1082|       |     */
 1083|  1.64k|    localname = xmlSplitQName3(fullattr, &len);
 1084|  1.64k|    if (localname == NULL) {
  ------------------
  |  Branch (1084:9): [True: 1.54k, False: 96]
  ------------------
 1085|  1.54k|        name = xmlDictLookupHashed(ctxt->dict, fullattr, -1);
 1086|  1.54k|	prefix.name = NULL;
 1087|  1.54k|    } else {
 1088|     96|        name = xmlDictLookupHashed(ctxt->dict, localname, -1);
 1089|     96|	prefix = xmlDictLookupHashed(ctxt->dict, fullattr, len);
 1090|     96|        if (prefix.name == NULL)
  ------------------
  |  Branch (1090:13): [True: 0, False: 96]
  ------------------
 1091|      0|            goto mem_error;
 1092|     96|    }
 1093|  1.64k|    if (name.name == NULL)
  ------------------
  |  Branch (1093:9): [True: 0, False: 1.64k]
  ------------------
 1094|      0|        goto mem_error;
 1095|       |
 1096|       |    /* intern the string and precompute the end */
 1097|  1.64k|    len = strlen((const char *) value);
 1098|  1.64k|    hvalue = xmlDictLookupHashed(ctxt->dict, value, len);
 1099|  1.64k|    if (hvalue.name == NULL)
  ------------------
  |  Branch (1099:9): [True: 0, False: 1.64k]
  ------------------
 1100|      0|        goto mem_error;
 1101|       |
 1102|  1.64k|    expandedSize = strlen((const char *) name.name);
 1103|  1.64k|    if (prefix.name != NULL)
  ------------------
  |  Branch (1103:9): [True: 96, False: 1.54k]
  ------------------
 1104|     96|        expandedSize += strlen((const char *) prefix.name);
 1105|  1.64k|    expandedSize += len;
 1106|       |
 1107|  1.64k|    attr = &defaults->attrs[defaults->nbAttrs++];
 1108|  1.64k|    attr->name = name;
 1109|  1.64k|    attr->prefix = prefix;
 1110|  1.64k|    attr->value = hvalue;
 1111|  1.64k|    attr->valueEnd = hvalue.name + len;
 1112|  1.64k|    attr->external = ctxt->external;
 1113|  1.64k|    attr->expandedSize = expandedSize;
 1114|       |
 1115|  1.64k|    return;
 1116|       |
 1117|      0|mem_error:
 1118|      0|    xmlErrMemory(ctxt, NULL);
 1119|      0|    return;
 1120|  1.64k|}
parser.c:xmlAddSpecialAttr:
 1136|  7.78k|{
 1137|  7.78k|    if (ctxt->attsSpecial == NULL) {
  ------------------
  |  Branch (1137:9): [True: 160, False: 7.62k]
  ------------------
 1138|    160|        ctxt->attsSpecial = xmlHashCreateDict(10, ctxt->dict);
 1139|    160|	if (ctxt->attsSpecial == NULL)
  ------------------
  |  Branch (1139:6): [True: 0, False: 160]
  ------------------
 1140|      0|	    goto mem_error;
 1141|    160|    }
 1142|       |
 1143|  7.78k|    if (xmlHashLookup2(ctxt->attsSpecial, fullname, fullattr) != NULL)
  ------------------
  |  Branch (1143:9): [True: 4, False: 7.77k]
  ------------------
 1144|      4|        return;
 1145|       |
 1146|  7.77k|    xmlHashAddEntry2(ctxt->attsSpecial, fullname, fullattr,
 1147|  7.77k|                     (void *) (ptrdiff_t) type);
 1148|  7.77k|    return;
 1149|       |
 1150|      0|mem_error:
 1151|      0|    xmlErrMemory(ctxt, NULL);
 1152|      0|    return;
 1153|  7.78k|}
parser.c:xmlParseElementChildrenContentDeclPriv:
 6385|  1.28k|                                       int depth) {
 6386|  1.28k|    xmlElementContentPtr ret = NULL, cur = NULL, last = NULL, op = NULL;
 6387|  1.28k|    const xmlChar *elem;
 6388|  1.28k|    xmlChar type = 0;
 6389|       |
 6390|  1.28k|    if (((depth > 128) && ((ctxt->options & XML_PARSE_HUGE) == 0)) ||
  ------------------
  |  Branch (6390:10): [True: 0, False: 1.28k]
  |  Branch (6390:27): [True: 0, False: 0]
  ------------------
 6391|  1.28k|        (depth >  2048)) {
  ------------------
  |  Branch (6391:9): [True: 0, False: 1.28k]
  ------------------
 6392|      0|        xmlFatalErrMsgInt(ctxt, XML_ERR_ELEMCONTENT_NOT_FINISHED,
 6393|      0|"xmlParseElementChildrenContentDecl : depth %d too deep, use XML_PARSE_HUGE\n",
 6394|      0|                          depth);
 6395|      0|	return(NULL);
 6396|      0|    }
 6397|  1.28k|    SKIP_BLANKS;
  ------------------
  |  | 2273|  1.28k|#define SKIP_BLANKS xmlSkipBlankChars(ctxt)
  ------------------
 6398|  1.28k|    GROW;
  ------------------
  |  | 2270|  1.28k|#define GROW if (ctxt->input->end - ctxt->input->cur < INPUT_CHUNK)	\
  |  |  ------------------
  |  |  |  |   97|  1.28k|#define INPUT_CHUNK	250
  |  |  ------------------
  |  |  |  Branch (2270:18): [True: 382, False: 898]
  |  |  ------------------
  |  | 2271|  1.28k|	xmlParserGrow(ctxt);
  ------------------
 6399|  1.28k|    if (RAW == '(') {
  ------------------
  |  | 2221|  1.28k|#define RAW (*ctxt->input->cur)
  ------------------
  |  Branch (6399:9): [True: 64, False: 1.21k]
  ------------------
 6400|     64|	int inputid = ctxt->input->id;
 6401|       |
 6402|       |        /* Recurse on first child */
 6403|     64|	NEXT;
  ------------------
  |  | 2275|     64|#define NEXT xmlNextChar(ctxt)
  ------------------
 6404|     64|	SKIP_BLANKS;
  ------------------
  |  | 2273|     64|#define SKIP_BLANKS xmlSkipBlankChars(ctxt)
  ------------------
 6405|     64|        cur = ret = xmlParseElementChildrenContentDeclPriv(ctxt, inputid,
 6406|     64|                                                           depth + 1);
 6407|     64|        if (cur == NULL)
  ------------------
  |  Branch (6407:13): [True: 0, False: 64]
  ------------------
 6408|      0|            return(NULL);
 6409|     64|	SKIP_BLANKS;
  ------------------
  |  | 2273|     64|#define SKIP_BLANKS xmlSkipBlankChars(ctxt)
  ------------------
 6410|     64|	GROW;
  ------------------
  |  | 2270|     64|#define GROW if (ctxt->input->end - ctxt->input->cur < INPUT_CHUNK)	\
  |  |  ------------------
  |  |  |  |   97|     64|#define INPUT_CHUNK	250
  |  |  ------------------
  |  |  |  Branch (2270:18): [True: 36, False: 28]
  |  |  ------------------
  |  | 2271|     64|	xmlParserGrow(ctxt);
  ------------------
 6411|  1.21k|    } else {
 6412|  1.21k|	elem = xmlParseName(ctxt);
 6413|  1.21k|	if (elem == NULL) {
  ------------------
  |  Branch (6413:6): [True: 0, False: 1.21k]
  ------------------
 6414|      0|	    xmlFatalErr(ctxt, XML_ERR_ELEMCONTENT_NOT_STARTED, NULL);
 6415|      0|	    return(NULL);
 6416|      0|	}
 6417|  1.21k|        cur = ret = xmlNewDocElementContent(ctxt->myDoc, elem, XML_ELEMENT_CONTENT_ELEMENT);
 6418|  1.21k|	if (cur == NULL) {
  ------------------
  |  Branch (6418:6): [True: 0, False: 1.21k]
  ------------------
 6419|      0|	    xmlErrMemory(ctxt, NULL);
 6420|      0|	    return(NULL);
 6421|      0|	}
 6422|  1.21k|	GROW;
  ------------------
  |  | 2270|  1.21k|#define GROW if (ctxt->input->end - ctxt->input->cur < INPUT_CHUNK)	\
  |  |  ------------------
  |  |  |  |   97|  1.21k|#define INPUT_CHUNK	250
  |  |  ------------------
  |  |  |  Branch (2270:18): [True: 357, False: 859]
  |  |  ------------------
  |  | 2271|  1.21k|	xmlParserGrow(ctxt);
  ------------------
 6423|  1.21k|	if (RAW == '?') {
  ------------------
  |  | 2221|  1.21k|#define RAW (*ctxt->input->cur)
  ------------------
  |  Branch (6423:6): [True: 124, False: 1.09k]
  ------------------
 6424|    124|	    cur->ocur = XML_ELEMENT_CONTENT_OPT;
 6425|    124|	    NEXT;
  ------------------
  |  | 2275|    124|#define NEXT xmlNextChar(ctxt)
  ------------------
 6426|  1.09k|	} else if (RAW == '*') {
  ------------------
  |  | 2221|  1.09k|#define RAW (*ctxt->input->cur)
  ------------------
  |  Branch (6426:13): [True: 132, False: 960]
  ------------------
 6427|    132|	    cur->ocur = XML_ELEMENT_CONTENT_MULT;
 6428|    132|	    NEXT;
  ------------------
  |  | 2275|    132|#define NEXT xmlNextChar(ctxt)
  ------------------
 6429|    960|	} else if (RAW == '+') {
  ------------------
  |  | 2221|    960|#define RAW (*ctxt->input->cur)
  ------------------
  |  Branch (6429:13): [True: 188, False: 772]
  ------------------
 6430|    188|	    cur->ocur = XML_ELEMENT_CONTENT_PLUS;
 6431|    188|	    NEXT;
  ------------------
  |  | 2275|    188|#define NEXT xmlNextChar(ctxt)
  ------------------
 6432|    772|	} else {
 6433|    772|	    cur->ocur = XML_ELEMENT_CONTENT_ONCE;
 6434|    772|	}
 6435|  1.21k|	GROW;
  ------------------
  |  | 2270|  1.21k|#define GROW if (ctxt->input->end - ctxt->input->cur < INPUT_CHUNK)	\
  |  |  ------------------
  |  |  |  |   97|  1.21k|#define INPUT_CHUNK	250
  |  |  ------------------
  |  |  |  Branch (2270:18): [True: 353, False: 863]
  |  |  ------------------
  |  | 2271|  1.21k|	xmlParserGrow(ctxt);
  ------------------
 6436|  1.21k|    }
 6437|  1.28k|    SKIP_BLANKS;
  ------------------
  |  | 2273|  1.28k|#define SKIP_BLANKS xmlSkipBlankChars(ctxt)
  ------------------
 6438|  5.06k|    while ((RAW != ')') && (ctxt->instate != XML_PARSER_EOF)) {
  ------------------
  |  | 2221|  5.06k|#define RAW (*ctxt->input->cur)
  ------------------
  |  Branch (6438:12): [True: 3.78k, False: 1.27k]
  |  Branch (6438:28): [True: 3.78k, False: 0]
  ------------------
 6439|       |        /*
 6440|       |	 * Each loop we parse one separator and one element.
 6441|       |	 */
 6442|  3.78k|        if (RAW == ',') {
  ------------------
  |  | 2221|  3.78k|#define RAW (*ctxt->input->cur)
  ------------------
  |  Branch (6442:13): [True: 1.23k, False: 2.55k]
  ------------------
 6443|  1.23k|	    if (type == 0) type = CUR;
  ------------------
  |  | 2222|    488|#define CUR (*ctxt->input->cur)
  ------------------
  |  Branch (6443:10): [True: 488, False: 744]
  ------------------
 6444|       |
 6445|       |	    /*
 6446|       |	     * Detect "Name | Name , Name" error
 6447|       |	     */
 6448|    744|	    else if (type != CUR) {
  ------------------
  |  | 2222|    744|#define CUR (*ctxt->input->cur)
  ------------------
  |  Branch (6448:15): [True: 0, False: 744]
  ------------------
 6449|      0|		xmlFatalErrMsgInt(ctxt, XML_ERR_SEPARATOR_REQUIRED,
 6450|      0|		    "xmlParseElementChildrenContentDecl : '%c' expected\n",
 6451|      0|		                  type);
 6452|      0|		if ((last != NULL) && (last != ret))
  ------------------
  |  Branch (6452:7): [True: 0, False: 0]
  |  Branch (6452:25): [True: 0, False: 0]
  ------------------
 6453|      0|		    xmlFreeDocElementContent(ctxt->myDoc, last);
 6454|      0|		if (ret != NULL)
  ------------------
  |  Branch (6454:7): [True: 0, False: 0]
  ------------------
 6455|      0|		    xmlFreeDocElementContent(ctxt->myDoc, ret);
 6456|      0|		return(NULL);
 6457|      0|	    }
 6458|  1.23k|	    NEXT;
  ------------------
  |  | 2275|  1.23k|#define NEXT xmlNextChar(ctxt)
  ------------------
 6459|       |
 6460|  1.23k|	    op = xmlNewDocElementContent(ctxt->myDoc, NULL, XML_ELEMENT_CONTENT_SEQ);
 6461|  1.23k|	    if (op == NULL) {
  ------------------
  |  Branch (6461:10): [True: 0, False: 1.23k]
  ------------------
 6462|      0|		if ((last != NULL) && (last != ret))
  ------------------
  |  Branch (6462:7): [True: 0, False: 0]
  |  Branch (6462:25): [True: 0, False: 0]
  ------------------
 6463|      0|		    xmlFreeDocElementContent(ctxt->myDoc, last);
 6464|      0|	        xmlFreeDocElementContent(ctxt->myDoc, ret);
 6465|      0|		return(NULL);
 6466|      0|	    }
 6467|  1.23k|	    if (last == NULL) {
  ------------------
  |  Branch (6467:10): [True: 488, False: 744]
  ------------------
 6468|    488|		op->c1 = ret;
 6469|    488|		if (ret != NULL)
  ------------------
  |  Branch (6469:7): [True: 488, False: 0]
  ------------------
 6470|    488|		    ret->parent = op;
 6471|    488|		ret = cur = op;
 6472|    744|	    } else {
 6473|    744|	        cur->c2 = op;
 6474|    744|		if (op != NULL)
  ------------------
  |  Branch (6474:7): [True: 744, False: 0]
  ------------------
 6475|    744|		    op->parent = cur;
 6476|    744|		op->c1 = last;
 6477|    744|		if (last != NULL)
  ------------------
  |  Branch (6477:7): [True: 744, False: 0]
  ------------------
 6478|    744|		    last->parent = op;
 6479|    744|		cur =op;
 6480|    744|		last = NULL;
 6481|    744|	    }
 6482|  2.55k|	} else if (RAW == '|') {
  ------------------
  |  | 2221|  2.55k|#define RAW (*ctxt->input->cur)
  ------------------
  |  Branch (6482:13): [True: 2.55k, False: 4]
  ------------------
 6483|  2.55k|	    if (type == 0) type = CUR;
  ------------------
  |  | 2222|    388|#define CUR (*ctxt->input->cur)
  ------------------
  |  Branch (6483:10): [True: 388, False: 2.16k]
  ------------------
 6484|       |
 6485|       |	    /*
 6486|       |	     * Detect "Name , Name | Name" error
 6487|       |	     */
 6488|  2.16k|	    else if (type != CUR) {
  ------------------
  |  | 2222|  2.16k|#define CUR (*ctxt->input->cur)
  ------------------
  |  Branch (6488:15): [True: 0, False: 2.16k]
  ------------------
 6489|      0|		xmlFatalErrMsgInt(ctxt, XML_ERR_SEPARATOR_REQUIRED,
 6490|      0|		    "xmlParseElementChildrenContentDecl : '%c' expected\n",
 6491|      0|				  type);
 6492|      0|		if ((last != NULL) && (last != ret))
  ------------------
  |  Branch (6492:7): [True: 0, False: 0]
  |  Branch (6492:25): [True: 0, False: 0]
  ------------------
 6493|      0|		    xmlFreeDocElementContent(ctxt->myDoc, last);
 6494|      0|		if (ret != NULL)
  ------------------
  |  Branch (6494:7): [True: 0, False: 0]
  ------------------
 6495|      0|		    xmlFreeDocElementContent(ctxt->myDoc, ret);
 6496|      0|		return(NULL);
 6497|      0|	    }
 6498|  2.55k|	    NEXT;
  ------------------
  |  | 2275|  2.55k|#define NEXT xmlNextChar(ctxt)
  ------------------
 6499|       |
 6500|  2.55k|	    op = xmlNewDocElementContent(ctxt->myDoc, NULL, XML_ELEMENT_CONTENT_OR);
 6501|  2.55k|	    if (op == NULL) {
  ------------------
  |  Branch (6501:10): [True: 0, False: 2.55k]
  ------------------
 6502|      0|		if ((last != NULL) && (last != ret))
  ------------------
  |  Branch (6502:7): [True: 0, False: 0]
  |  Branch (6502:25): [True: 0, False: 0]
  ------------------
 6503|      0|		    xmlFreeDocElementContent(ctxt->myDoc, last);
 6504|      0|		if (ret != NULL)
  ------------------
  |  Branch (6504:7): [True: 0, False: 0]
  ------------------
 6505|      0|		    xmlFreeDocElementContent(ctxt->myDoc, ret);
 6506|      0|		return(NULL);
 6507|      0|	    }
 6508|  2.55k|	    if (last == NULL) {
  ------------------
  |  Branch (6508:10): [True: 388, False: 2.16k]
  ------------------
 6509|    388|		op->c1 = ret;
 6510|    388|		if (ret != NULL)
  ------------------
  |  Branch (6510:7): [True: 388, False: 0]
  ------------------
 6511|    388|		    ret->parent = op;
 6512|    388|		ret = cur = op;
 6513|  2.16k|	    } else {
 6514|  2.16k|	        cur->c2 = op;
 6515|  2.16k|		if (op != NULL)
  ------------------
  |  Branch (6515:7): [True: 2.16k, False: 0]
  ------------------
 6516|  2.16k|		    op->parent = cur;
 6517|  2.16k|		op->c1 = last;
 6518|  2.16k|		if (last != NULL)
  ------------------
  |  Branch (6518:7): [True: 2.16k, False: 0]
  ------------------
 6519|  2.16k|		    last->parent = op;
 6520|  2.16k|		cur =op;
 6521|  2.16k|		last = NULL;
 6522|  2.16k|	    }
 6523|  2.55k|	} else {
 6524|      4|	    xmlFatalErr(ctxt, XML_ERR_ELEMCONTENT_NOT_FINISHED, NULL);
 6525|      4|	    if ((last != NULL) && (last != ret))
  ------------------
  |  Branch (6525:10): [True: 4, False: 0]
  |  Branch (6525:28): [True: 4, False: 0]
  ------------------
 6526|      4|	        xmlFreeDocElementContent(ctxt->myDoc, last);
 6527|      4|	    if (ret != NULL)
  ------------------
  |  Branch (6527:10): [True: 4, False: 0]
  ------------------
 6528|      4|		xmlFreeDocElementContent(ctxt->myDoc, ret);
 6529|      4|	    return(NULL);
 6530|      4|	}
 6531|  3.78k|	GROW;
  ------------------
  |  | 2270|  3.78k|#define GROW if (ctxt->input->end - ctxt->input->cur < INPUT_CHUNK)	\
  |  |  ------------------
  |  |  |  |   97|  3.78k|#define INPUT_CHUNK	250
  |  |  ------------------
  |  |  |  Branch (2270:18): [True: 2.06k, False: 1.72k]
  |  |  ------------------
  |  | 2271|  3.78k|	xmlParserGrow(ctxt);
  ------------------
 6532|  3.78k|	SKIP_BLANKS;
  ------------------
  |  | 2273|  3.78k|#define SKIP_BLANKS xmlSkipBlankChars(ctxt)
  ------------------
 6533|  3.78k|	GROW;
  ------------------
  |  | 2270|  3.78k|#define GROW if (ctxt->input->end - ctxt->input->cur < INPUT_CHUNK)	\
  |  |  ------------------
  |  |  |  |   97|  3.78k|#define INPUT_CHUNK	250
  |  |  ------------------
  |  |  |  Branch (2270:18): [True: 2.06k, False: 1.71k]
  |  |  ------------------
  |  | 2271|  3.78k|	xmlParserGrow(ctxt);
  ------------------
 6534|  3.78k|	if (RAW == '(') {
  ------------------
  |  | 2221|  3.78k|#define RAW (*ctxt->input->cur)
  ------------------
  |  Branch (6534:6): [True: 180, False: 3.60k]
  ------------------
 6535|    180|	    int inputid = ctxt->input->id;
 6536|       |	    /* Recurse on second child */
 6537|    180|	    NEXT;
  ------------------
  |  | 2275|    180|#define NEXT xmlNextChar(ctxt)
  ------------------
 6538|    180|	    SKIP_BLANKS;
  ------------------
  |  | 2273|    180|#define SKIP_BLANKS xmlSkipBlankChars(ctxt)
  ------------------
 6539|    180|	    last = xmlParseElementChildrenContentDeclPriv(ctxt, inputid,
 6540|    180|                                                          depth + 1);
 6541|    180|            if (last == NULL) {
  ------------------
  |  Branch (6541:17): [True: 0, False: 180]
  ------------------
 6542|      0|		if (ret != NULL)
  ------------------
  |  Branch (6542:7): [True: 0, False: 0]
  ------------------
 6543|      0|		    xmlFreeDocElementContent(ctxt->myDoc, ret);
 6544|      0|		return(NULL);
 6545|      0|            }
 6546|    180|	    SKIP_BLANKS;
  ------------------
  |  | 2273|    180|#define SKIP_BLANKS xmlSkipBlankChars(ctxt)
  ------------------
 6547|  3.60k|	} else {
 6548|  3.60k|	    elem = xmlParseName(ctxt);
 6549|  3.60k|	    if (elem == NULL) {
  ------------------
  |  Branch (6549:10): [True: 0, False: 3.60k]
  ------------------
 6550|      0|		xmlFatalErr(ctxt, XML_ERR_ELEMCONTENT_NOT_STARTED, NULL);
 6551|      0|		if (ret != NULL)
  ------------------
  |  Branch (6551:7): [True: 0, False: 0]
  ------------------
 6552|      0|		    xmlFreeDocElementContent(ctxt->myDoc, ret);
 6553|      0|		return(NULL);
 6554|      0|	    }
 6555|  3.60k|	    last = xmlNewDocElementContent(ctxt->myDoc, elem, XML_ELEMENT_CONTENT_ELEMENT);
 6556|  3.60k|	    if (last == NULL) {
  ------------------
  |  Branch (6556:10): [True: 0, False: 3.60k]
  ------------------
 6557|      0|		if (ret != NULL)
  ------------------
  |  Branch (6557:7): [True: 0, False: 0]
  ------------------
 6558|      0|		    xmlFreeDocElementContent(ctxt->myDoc, ret);
 6559|      0|		return(NULL);
 6560|      0|	    }
 6561|  3.60k|	    if (RAW == '?') {
  ------------------
  |  | 2221|  3.60k|#define RAW (*ctxt->input->cur)
  ------------------
  |  Branch (6561:10): [True: 436, False: 3.16k]
  ------------------
 6562|    436|		last->ocur = XML_ELEMENT_CONTENT_OPT;
 6563|    436|		NEXT;
  ------------------
  |  | 2275|    436|#define NEXT xmlNextChar(ctxt)
  ------------------
 6564|  3.16k|	    } else if (RAW == '*') {
  ------------------
  |  | 2221|  3.16k|#define RAW (*ctxt->input->cur)
  ------------------
  |  Branch (6564:17): [True: 292, False: 2.87k]
  ------------------
 6565|    292|		last->ocur = XML_ELEMENT_CONTENT_MULT;
 6566|    292|		NEXT;
  ------------------
  |  | 2275|    292|#define NEXT xmlNextChar(ctxt)
  ------------------
 6567|  2.87k|	    } else if (RAW == '+') {
  ------------------
  |  | 2221|  2.87k|#define RAW (*ctxt->input->cur)
  ------------------
  |  Branch (6567:17): [True: 108, False: 2.76k]
  ------------------
 6568|    108|		last->ocur = XML_ELEMENT_CONTENT_PLUS;
 6569|    108|		NEXT;
  ------------------
  |  | 2275|    108|#define NEXT xmlNextChar(ctxt)
  ------------------
 6570|  2.76k|	    } else {
 6571|  2.76k|		last->ocur = XML_ELEMENT_CONTENT_ONCE;
 6572|  2.76k|	    }
 6573|  3.60k|	}
 6574|  3.78k|	SKIP_BLANKS;
  ------------------
  |  | 2273|  3.78k|#define SKIP_BLANKS xmlSkipBlankChars(ctxt)
  ------------------
 6575|  3.78k|	GROW;
  ------------------
  |  | 2270|  3.78k|#define GROW if (ctxt->input->end - ctxt->input->cur < INPUT_CHUNK)	\
  |  |  ------------------
  |  |  |  |   97|  3.78k|#define INPUT_CHUNK	250
  |  |  ------------------
  |  |  |  Branch (2270:18): [True: 1.96k, False: 1.82k]
  |  |  ------------------
  |  | 2271|  3.78k|	xmlParserGrow(ctxt);
  ------------------
 6576|  3.78k|    }
 6577|  1.27k|    if ((cur != NULL) && (last != NULL)) {
  ------------------
  |  Branch (6577:9): [True: 1.27k, False: 0]
  |  Branch (6577:26): [True: 872, False: 404]
  ------------------
 6578|    872|        cur->c2 = last;
 6579|    872|	if (last != NULL)
  ------------------
  |  Branch (6579:6): [True: 872, False: 0]
  ------------------
 6580|    872|	    last->parent = cur;
 6581|    872|    }
 6582|  1.27k|    if (ctxt->input->id != inputchk) {
  ------------------
  |  Branch (6582:9): [True: 0, False: 1.27k]
  ------------------
 6583|      0|	xmlFatalErrMsg(ctxt, XML_ERR_ENTITY_BOUNDARY,
 6584|      0|                       "Element content declaration doesn't start and stop in"
 6585|      0|                       " the same entity\n");
 6586|      0|    }
 6587|  1.27k|    NEXT;
  ------------------
  |  | 2275|  1.27k|#define NEXT xmlNextChar(ctxt)
  ------------------
 6588|  1.27k|    if (RAW == '?') {
  ------------------
  |  | 2221|  1.27k|#define RAW (*ctxt->input->cur)
  ------------------
  |  Branch (6588:9): [True: 56, False: 1.22k]
  ------------------
 6589|     56|	if (ret != NULL) {
  ------------------
  |  Branch (6589:6): [True: 56, False: 0]
  ------------------
 6590|     56|	    if ((ret->ocur == XML_ELEMENT_CONTENT_PLUS) ||
  ------------------
  |  Branch (6590:10): [True: 0, False: 56]
  ------------------
 6591|     56|	        (ret->ocur == XML_ELEMENT_CONTENT_MULT))
  ------------------
  |  Branch (6591:10): [True: 0, False: 56]
  ------------------
 6592|      0|	        ret->ocur = XML_ELEMENT_CONTENT_MULT;
 6593|     56|	    else
 6594|     56|	        ret->ocur = XML_ELEMENT_CONTENT_OPT;
 6595|     56|	}
 6596|     56|	NEXT;
  ------------------
  |  | 2275|     56|#define NEXT xmlNextChar(ctxt)
  ------------------
 6597|  1.22k|    } else if (RAW == '*') {
  ------------------
  |  | 2221|  1.22k|#define RAW (*ctxt->input->cur)
  ------------------
  |  Branch (6597:16): [True: 256, False: 964]
  ------------------
 6598|    256|	if (ret != NULL) {
  ------------------
  |  Branch (6598:6): [True: 256, False: 0]
  ------------------
 6599|    256|	    ret->ocur = XML_ELEMENT_CONTENT_MULT;
 6600|    256|	    cur = ret;
 6601|       |	    /*
 6602|       |	     * Some normalization:
 6603|       |	     * (a | b* | c?)* == (a | b | c)*
 6604|       |	     */
 6605|  1.64k|	    while ((cur != NULL) && (cur->type == XML_ELEMENT_CONTENT_OR)) {
  ------------------
  |  Branch (6605:13): [True: 1.64k, False: 0]
  |  Branch (6605:30): [True: 1.38k, False: 256]
  ------------------
 6606|  1.38k|		if ((cur->c1 != NULL) &&
  ------------------
  |  Branch (6606:7): [True: 1.38k, False: 0]
  ------------------
 6607|  1.38k|	            ((cur->c1->ocur == XML_ELEMENT_CONTENT_OPT) ||
  ------------------
  |  Branch (6607:15): [True: 48, False: 1.34k]
  ------------------
 6608|  1.38k|		     (cur->c1->ocur == XML_ELEMENT_CONTENT_MULT)))
  ------------------
  |  Branch (6608:8): [True: 0, False: 1.34k]
  ------------------
 6609|     48|		    cur->c1->ocur = XML_ELEMENT_CONTENT_ONCE;
 6610|  1.38k|		if ((cur->c2 != NULL) &&
  ------------------
  |  Branch (6610:7): [True: 1.38k, False: 0]
  ------------------
 6611|  1.38k|	            ((cur->c2->ocur == XML_ELEMENT_CONTENT_OPT) ||
  ------------------
  |  Branch (6611:15): [True: 8, False: 1.38k]
  ------------------
 6612|  1.38k|		     (cur->c2->ocur == XML_ELEMENT_CONTENT_MULT)))
  ------------------
  |  Branch (6612:8): [True: 0, False: 1.38k]
  ------------------
 6613|      8|		    cur->c2->ocur = XML_ELEMENT_CONTENT_ONCE;
 6614|  1.38k|		cur = cur->c2;
 6615|  1.38k|	    }
 6616|    256|	}
 6617|    256|	NEXT;
  ------------------
  |  | 2275|    256|#define NEXT xmlNextChar(ctxt)
  ------------------
 6618|    964|    } else if (RAW == '+') {
  ------------------
  |  | 2221|    964|#define RAW (*ctxt->input->cur)
  ------------------
  |  Branch (6618:16): [True: 184, False: 780]
  ------------------
 6619|    184|	if (ret != NULL) {
  ------------------
  |  Branch (6619:6): [True: 184, False: 0]
  ------------------
 6620|    184|	    int found = 0;
 6621|       |
 6622|    184|	    if ((ret->ocur == XML_ELEMENT_CONTENT_OPT) ||
  ------------------
  |  Branch (6622:10): [True: 0, False: 184]
  ------------------
 6623|    184|	        (ret->ocur == XML_ELEMENT_CONTENT_MULT))
  ------------------
  |  Branch (6623:10): [True: 0, False: 184]
  ------------------
 6624|      0|	        ret->ocur = XML_ELEMENT_CONTENT_MULT;
 6625|    184|	    else
 6626|    184|	        ret->ocur = XML_ELEMENT_CONTENT_PLUS;
 6627|       |	    /*
 6628|       |	     * Some normalization:
 6629|       |	     * (a | b*)+ == (a | b)*
 6630|       |	     * (a | b?)+ == (a | b)*
 6631|       |	     */
 6632|    300|	    while ((cur != NULL) && (cur->type == XML_ELEMENT_CONTENT_OR)) {
  ------------------
  |  Branch (6632:13): [True: 300, False: 0]
  |  Branch (6632:30): [True: 116, False: 184]
  ------------------
 6633|    116|		if ((cur->c1 != NULL) &&
  ------------------
  |  Branch (6633:7): [True: 116, False: 0]
  ------------------
 6634|    116|	            ((cur->c1->ocur == XML_ELEMENT_CONTENT_OPT) ||
  ------------------
  |  Branch (6634:15): [True: 0, False: 116]
  ------------------
 6635|    116|		     (cur->c1->ocur == XML_ELEMENT_CONTENT_MULT))) {
  ------------------
  |  Branch (6635:8): [True: 0, False: 116]
  ------------------
 6636|      0|		    cur->c1->ocur = XML_ELEMENT_CONTENT_ONCE;
 6637|      0|		    found = 1;
 6638|      0|		}
 6639|    116|		if ((cur->c2 != NULL) &&
  ------------------
  |  Branch (6639:7): [True: 116, False: 0]
  ------------------
 6640|    116|	            ((cur->c2->ocur == XML_ELEMENT_CONTENT_OPT) ||
  ------------------
  |  Branch (6640:15): [True: 0, False: 116]
  ------------------
 6641|    116|		     (cur->c2->ocur == XML_ELEMENT_CONTENT_MULT))) {
  ------------------
  |  Branch (6641:8): [True: 0, False: 116]
  ------------------
 6642|      0|		    cur->c2->ocur = XML_ELEMENT_CONTENT_ONCE;
 6643|      0|		    found = 1;
 6644|      0|		}
 6645|    116|		cur = cur->c2;
 6646|    116|	    }
 6647|    184|	    if (found)
  ------------------
  |  Branch (6647:10): [True: 0, False: 184]
  ------------------
 6648|      0|		ret->ocur = XML_ELEMENT_CONTENT_MULT;
 6649|    184|	}
 6650|    184|	NEXT;
  ------------------
  |  | 2275|    184|#define NEXT xmlNextChar(ctxt)
  ------------------
 6651|    184|    }
 6652|  1.27k|    return(ret);
 6653|  1.28k|}
parser.c:xmlDetectSAX2:
  857|  1.86k|xmlDetectSAX2(xmlParserCtxtPtr ctxt) {
  858|  1.86k|    xmlSAXHandlerPtr sax;
  859|       |
  860|       |    /* Avoid unused variable warning if features are disabled. */
  861|  1.86k|    (void) sax;
  862|       |
  863|  1.86k|    if (ctxt == NULL) return;
  ------------------
  |  Branch (863:9): [True: 0, False: 1.86k]
  ------------------
  864|  1.86k|    sax = ctxt->sax;
  865|  1.86k|#ifdef LIBXML_SAX1_ENABLED
  866|  1.86k|    if ((sax) && (sax->initialized == XML_SAX2_MAGIC))
  ------------------
  |  |  685|  1.86k|#define XML_SAX2_MAGIC 0xDEEDBEAF
  ------------------
  |  Branch (866:9): [True: 1.86k, False: 0]
  |  Branch (866:18): [True: 1.86k, False: 0]
  ------------------
  867|  1.86k|        ctxt->sax2 = 1;
  868|       |#else
  869|       |    ctxt->sax2 = 1;
  870|       |#endif /* LIBXML_SAX1_ENABLED */
  871|       |
  872|  1.86k|    ctxt->str_xml = xmlDictLookup(ctxt->dict, BAD_CAST "xml", 3);
  ------------------
  |  |   35|  1.86k|#define BAD_CAST (xmlChar *)
  ------------------
  873|  1.86k|    ctxt->str_xmlns = xmlDictLookup(ctxt->dict, BAD_CAST "xmlns", 5);
  ------------------
  |  |   35|  1.86k|#define BAD_CAST (xmlChar *)
  ------------------
  874|  1.86k|    ctxt->str_xml_ns = xmlDictLookup(ctxt->dict, XML_XML_NAMESPACE, 36);
  ------------------
  |  |  143|  1.86k|    (const xmlChar *) "http://www.w3.org/XML/1998/namespace"
  ------------------
  875|  1.86k|    if ((ctxt->str_xml==NULL) || (ctxt->str_xmlns==NULL) ||
  ------------------
  |  Branch (875:9): [True: 0, False: 1.86k]
  |  Branch (875:34): [True: 0, False: 1.86k]
  ------------------
  876|  1.86k|		(ctxt->str_xml_ns == NULL)) {
  ------------------
  |  Branch (876:3): [True: 0, False: 1.86k]
  ------------------
  877|      0|        xmlErrMemory(ctxt, NULL);
  878|      0|    }
  879|  1.86k|}
parser.c:xmlParseConditionalSections:
 6868|     12|xmlParseConditionalSections(xmlParserCtxtPtr ctxt) {
 6869|     12|    int *inputIds = NULL;
 6870|     12|    size_t inputIdsSize = 0;
 6871|     12|    size_t depth = 0;
 6872|       |
 6873|    108|    while (ctxt->instate != XML_PARSER_EOF) {
  ------------------
  |  Branch (6873:12): [True: 108, False: 0]
  ------------------
 6874|    108|        if ((RAW == '<') && (NXT(1) == '!') && (NXT(2) == '[')) {
  ------------------
  |  | 2221|    108|#define RAW (*ctxt->input->cur)
  ------------------
                      if ((RAW == '<') && (NXT(1) == '!') && (NXT(2) == '[')) {
  ------------------
  |  | 2223|     60|#define NXT(val) ctxt->input->cur[(val)]
  ------------------
                      if ((RAW == '<') && (NXT(1) == '!') && (NXT(2) == '[')) {
  ------------------
  |  | 2223|     60|#define NXT(val) ctxt->input->cur[(val)]
  ------------------
  |  Branch (6874:13): [True: 60, False: 48]
  |  Branch (6874:29): [True: 60, False: 0]
  |  Branch (6874:48): [True: 52, False: 8]
  ------------------
 6875|     52|            int id = ctxt->input->id;
 6876|       |
 6877|     52|            SKIP(3);
  ------------------
  |  | 2245|     52|#define SKIP(val) do {							\
  |  | 2246|     52|    ctxt->input->cur += (val),ctxt->input->col+=(val);			\
  |  | 2247|     52|    if (*ctxt->input->cur == 0)						\
  |  |  ------------------
  |  |  |  Branch (2247:9): [True: 0, False: 52]
  |  |  ------------------
  |  | 2248|     52|        xmlParserGrow(ctxt);						\
  |  | 2249|     52|  } while (0)
  |  |  ------------------
  |  |  |  Branch (2249:12): [Folded - Ignored]
  |  |  ------------------
  ------------------
 6878|     52|            SKIP_BLANKS;
  ------------------
  |  | 2273|     52|#define SKIP_BLANKS xmlSkipBlankChars(ctxt)
  ------------------
 6879|       |
 6880|     52|            if (CMP7(CUR_PTR, 'I', 'N', 'C', 'L', 'U', 'D', 'E')) {
  ------------------
  |  | 2235|     52|  ( CMP6( s, c1, c2, c3, c4, c5, c6 ) && ((unsigned char *) s)[ 6 ] == c7 )
  |  |  ------------------
  |  |  |  | 2233|    104|  ( CMP5( s, c1, c2, c3, c4, c5 ) && ((unsigned char *) s)[ 5 ] == c6 )
  |  |  |  |  ------------------
  |  |  |  |  |  | 2231|    104|  ( CMP4( s, c1, c2, c3, c4 ) && ((unsigned char *) s)[ 4 ] == c5 )
  |  |  |  |  |  |  ------------------
  |  |  |  |  |  |  |  | 2228|    104|  ( ((unsigned char *) s)[ 0 ] == c1 && ((unsigned char *) s)[ 1 ] == c2 && \
  |  |  |  |  |  |  |  |  ------------------
  |  |  |  |  |  |  |  |  |  Branch (2228:5): [True: 52, False: 0]
  |  |  |  |  |  |  |  |  |  Branch (2228:41): [True: 48, False: 4]
  |  |  |  |  |  |  |  |  ------------------
  |  |  |  |  |  |  |  | 2229|     52|    ((unsigned char *) s)[ 2 ] == c3 && ((unsigned char *) s)[ 3 ] == c4 )
  |  |  |  |  |  |  |  |  ------------------
  |  |  |  |  |  |  |  |  |  Branch (2229:5): [True: 48, False: 0]
  |  |  |  |  |  |  |  |  |  Branch (2229:41): [True: 48, False: 0]
  |  |  |  |  |  |  |  |  ------------------
  |  |  |  |  |  |  ------------------
  |  |  |  |  |  |  |  Branch (2231:34): [True: 48, False: 0]
  |  |  |  |  |  |  ------------------
  |  |  |  |  ------------------
  |  |  |  |  |  Branch (2233:38): [True: 48, False: 0]
  |  |  |  |  ------------------
  |  |  ------------------
  |  |  |  Branch (2235:42): [True: 48, False: 0]
  |  |  ------------------
  ------------------
 6881|     48|                SKIP(7);
  ------------------
  |  | 2245|     48|#define SKIP(val) do {							\
  |  | 2246|     48|    ctxt->input->cur += (val),ctxt->input->col+=(val);			\
  |  | 2247|     48|    if (*ctxt->input->cur == 0)						\
  |  |  ------------------
  |  |  |  Branch (2247:9): [True: 16, False: 32]
  |  |  ------------------
  |  | 2248|     48|        xmlParserGrow(ctxt);						\
  |  | 2249|     48|  } while (0)
  |  |  ------------------
  |  |  |  Branch (2249:12): [Folded - Ignored]
  |  |  ------------------
  ------------------
 6882|     48|                SKIP_BLANKS;
  ------------------
  |  | 2273|     48|#define SKIP_BLANKS xmlSkipBlankChars(ctxt)
  ------------------
 6883|     48|                if (RAW != '[') {
  ------------------
  |  | 2221|     48|#define RAW (*ctxt->input->cur)
  ------------------
  |  Branch (6883:21): [True: 0, False: 48]
  ------------------
 6884|      0|                    xmlFatalErr(ctxt, XML_ERR_CONDSEC_INVALID, NULL);
 6885|      0|                    xmlHaltParser(ctxt);
 6886|      0|                    goto error;
 6887|      0|                }
 6888|     48|                if (ctxt->input->id != id) {
  ------------------
  |  Branch (6888:21): [True: 0, False: 48]
  ------------------
 6889|      0|                    xmlFatalErrMsg(ctxt, XML_ERR_ENTITY_BOUNDARY,
 6890|      0|                                   "All markup of the conditional section is"
 6891|      0|                                   " not in the same entity\n");
 6892|      0|                }
 6893|     48|                NEXT;
  ------------------
  |  | 2275|     48|#define NEXT xmlNextChar(ctxt)
  ------------------
 6894|       |
 6895|     48|                if (inputIdsSize <= depth) {
  ------------------
  |  Branch (6895:21): [True: 12, False: 36]
  ------------------
 6896|     12|                    int *tmp;
 6897|       |
 6898|     12|                    inputIdsSize = (inputIdsSize == 0 ? 4 : inputIdsSize * 2);
  ------------------
  |  Branch (6898:37): [True: 8, False: 4]
  ------------------
 6899|     12|                    tmp = (int *) xmlRealloc(inputIds,
 6900|     12|                            inputIdsSize * sizeof(int));
 6901|     12|                    if (tmp == NULL) {
  ------------------
  |  Branch (6901:25): [True: 0, False: 12]
  ------------------
 6902|      0|                        xmlErrMemory(ctxt, NULL);
 6903|      0|                        goto error;
 6904|      0|                    }
 6905|     12|                    inputIds = tmp;
 6906|     12|                }
 6907|     48|                inputIds[depth] = id;
 6908|     48|                depth++;
 6909|     48|            } else if (CMP6(CUR_PTR, 'I', 'G', 'N', 'O', 'R', 'E')) {
  ------------------
  |  | 2233|      4|  ( CMP5( s, c1, c2, c3, c4, c5 ) && ((unsigned char *) s)[ 5 ] == c6 )
  |  |  ------------------
  |  |  |  | 2231|      8|  ( CMP4( s, c1, c2, c3, c4 ) && ((unsigned char *) s)[ 4 ] == c5 )
  |  |  |  |  ------------------
  |  |  |  |  |  | 2228|      8|  ( ((unsigned char *) s)[ 0 ] == c1 && ((unsigned char *) s)[ 1 ] == c2 && \
  |  |  |  |  |  |  ------------------
  |  |  |  |  |  |  |  Branch (2228:5): [True: 4, False: 0]
  |  |  |  |  |  |  |  Branch (2228:41): [True: 4, False: 0]
  |  |  |  |  |  |  ------------------
  |  |  |  |  |  | 2229|      4|    ((unsigned char *) s)[ 2 ] == c3 && ((unsigned char *) s)[ 3 ] == c4 )
  |  |  |  |  |  |  ------------------
  |  |  |  |  |  |  |  Branch (2229:5): [True: 4, False: 0]
  |  |  |  |  |  |  |  Branch (2229:41): [True: 4, False: 0]
  |  |  |  |  |  |  ------------------
  |  |  |  |  ------------------
  |  |  |  |  |  Branch (2231:34): [True: 4, False: 0]
  |  |  |  |  ------------------
  |  |  ------------------
  |  |  |  Branch (2233:38): [True: 4, False: 0]
  |  |  ------------------
  ------------------
 6910|      4|                size_t ignoreDepth = 0;
 6911|       |
 6912|      4|                SKIP(6);
  ------------------
  |  | 2245|      4|#define SKIP(val) do {							\
  |  | 2246|      4|    ctxt->input->cur += (val),ctxt->input->col+=(val);			\
  |  | 2247|      4|    if (*ctxt->input->cur == 0)						\
  |  |  ------------------
  |  |  |  Branch (2247:9): [True: 4, False: 0]
  |  |  ------------------
  |  | 2248|      4|        xmlParserGrow(ctxt);						\
  |  | 2249|      4|  } while (0)
  |  |  ------------------
  |  |  |  Branch (2249:12): [Folded - Ignored]
  |  |  ------------------
  ------------------
 6913|      4|                SKIP_BLANKS;
  ------------------
  |  | 2273|      4|#define SKIP_BLANKS xmlSkipBlankChars(ctxt)
  ------------------
 6914|      4|                if (RAW != '[') {
  ------------------
  |  | 2221|      4|#define RAW (*ctxt->input->cur)
  ------------------
  |  Branch (6914:21): [True: 0, False: 4]
  ------------------
 6915|      0|                    xmlFatalErr(ctxt, XML_ERR_CONDSEC_INVALID, NULL);
 6916|      0|                    xmlHaltParser(ctxt);
 6917|      0|                    goto error;
 6918|      0|                }
 6919|      4|                if (ctxt->input->id != id) {
  ------------------
  |  Branch (6919:21): [True: 0, False: 4]
  ------------------
 6920|      0|                    xmlFatalErrMsg(ctxt, XML_ERR_ENTITY_BOUNDARY,
 6921|      0|                                   "All markup of the conditional section is"
 6922|      0|                                   " not in the same entity\n");
 6923|      0|                }
 6924|      4|                NEXT;
  ------------------
  |  | 2275|      4|#define NEXT xmlNextChar(ctxt)
  ------------------
 6925|       |
 6926|    660|                while (RAW != 0) {
  ------------------
  |  | 2221|    660|#define RAW (*ctxt->input->cur)
  ------------------
  |  Branch (6926:24): [True: 660, False: 0]
  ------------------
 6927|    660|                    if ((RAW == '<') && (NXT(1) == '!') && (NXT(2) == '[')) {
  ------------------
  |  | 2221|    660|#define RAW (*ctxt->input->cur)
  ------------------
                                  if ((RAW == '<') && (NXT(1) == '!') && (NXT(2) == '[')) {
  ------------------
  |  | 2223|     20|#define NXT(val) ctxt->input->cur[(val)]
  ------------------
                                  if ((RAW == '<') && (NXT(1) == '!') && (NXT(2) == '[')) {
  ------------------
  |  | 2223|     20|#define NXT(val) ctxt->input->cur[(val)]
  ------------------
  |  Branch (6927:25): [True: 20, False: 640]
  |  Branch (6927:41): [True: 20, False: 0]
  |  Branch (6927:60): [True: 12, False: 8]
  ------------------
 6928|     12|                        SKIP(3);
  ------------------
  |  | 2245|     12|#define SKIP(val) do {							\
  |  | 2246|     12|    ctxt->input->cur += (val),ctxt->input->col+=(val);			\
  |  | 2247|     12|    if (*ctxt->input->cur == 0)						\
  |  |  ------------------
  |  |  |  Branch (2247:9): [True: 0, False: 12]
  |  |  ------------------
  |  | 2248|     12|        xmlParserGrow(ctxt);						\
  |  | 2249|     12|  } while (0)
  |  |  ------------------
  |  |  |  Branch (2249:12): [Folded - Ignored]
  |  |  ------------------
  ------------------
 6929|     12|                        ignoreDepth++;
 6930|       |                        /* Check for integer overflow */
 6931|     12|                        if (ignoreDepth == 0) {
  ------------------
  |  Branch (6931:29): [True: 0, False: 12]
  ------------------
 6932|      0|                            xmlErrMemory(ctxt, NULL);
 6933|      0|                            goto error;
 6934|      0|                        }
 6935|    648|                    } else if ((RAW == ']') && (NXT(1) == ']') &&
  ------------------
  |  | 2221|    648|#define RAW (*ctxt->input->cur)
  ------------------
                                  } else if ((RAW == ']') && (NXT(1) == ']') &&
  ------------------
  |  | 2223|     16|#define NXT(val) ctxt->input->cur[(val)]
  ------------------
  |  Branch (6935:32): [True: 16, False: 632]
  |  Branch (6935:48): [True: 16, False: 0]
  ------------------
 6936|    648|                               (NXT(2) == '>')) {
  ------------------
  |  | 2223|     16|#define NXT(val) ctxt->input->cur[(val)]
  ------------------
  |  Branch (6936:32): [True: 16, False: 0]
  ------------------
 6937|     16|                        if (ignoreDepth == 0)
  ------------------
  |  Branch (6937:29): [True: 4, False: 12]
  ------------------
 6938|      4|                            break;
 6939|     12|                        SKIP(3);
  ------------------
  |  | 2245|     12|#define SKIP(val) do {							\
  |  | 2246|     12|    ctxt->input->cur += (val),ctxt->input->col+=(val);			\
  |  | 2247|     12|    if (*ctxt->input->cur == 0)						\
  |  |  ------------------
  |  |  |  Branch (2247:9): [True: 0, False: 12]
  |  |  ------------------
  |  | 2248|     12|        xmlParserGrow(ctxt);						\
  |  | 2249|     12|  } while (0)
  |  |  ------------------
  |  |  |  Branch (2249:12): [Folded - Ignored]
  |  |  ------------------
  ------------------
 6940|     12|                        ignoreDepth--;
 6941|    632|                    } else {
 6942|    632|                        NEXT;
  ------------------
  |  | 2275|    632|#define NEXT xmlNextChar(ctxt)
  ------------------
 6943|    632|                    }
 6944|    660|                }
 6945|       |
 6946|      4|		if (RAW == 0) {
  ------------------
  |  | 2221|      4|#define RAW (*ctxt->input->cur)
  ------------------
  |  Branch (6946:7): [True: 0, False: 4]
  ------------------
 6947|      0|		    xmlFatalErr(ctxt, XML_ERR_CONDSEC_NOT_FINISHED, NULL);
 6948|      0|                    goto error;
 6949|      0|		}
 6950|      4|                if (ctxt->input->id != id) {
  ------------------
  |  Branch (6950:21): [True: 0, False: 4]
  ------------------
 6951|      0|                    xmlFatalErrMsg(ctxt, XML_ERR_ENTITY_BOUNDARY,
 6952|      0|                                   "All markup of the conditional section is"
 6953|      0|                                   " not in the same entity\n");
 6954|      0|                }
 6955|      4|                SKIP(3);
  ------------------
  |  | 2245|      4|#define SKIP(val) do {							\
  |  | 2246|      4|    ctxt->input->cur += (val),ctxt->input->col+=(val);			\
  |  | 2247|      4|    if (*ctxt->input->cur == 0)						\
  |  |  ------------------
  |  |  |  Branch (2247:9): [True: 0, False: 4]
  |  |  ------------------
  |  | 2248|      4|        xmlParserGrow(ctxt);						\
  |  | 2249|      4|  } while (0)
  |  |  ------------------
  |  |  |  Branch (2249:12): [Folded - Ignored]
  |  |  ------------------
  ------------------
 6956|      4|            } else {
 6957|      0|                xmlFatalErr(ctxt, XML_ERR_CONDSEC_INVALID_KEYWORD, NULL);
 6958|      0|                xmlHaltParser(ctxt);
 6959|      0|                goto error;
 6960|      0|            }
 6961|     56|        } else if ((depth > 0) &&
  ------------------
  |  Branch (6961:20): [True: 56, False: 0]
  ------------------
 6962|     56|                   (RAW == ']') && (NXT(1) == ']') && (NXT(2) == '>')) {
  ------------------
  |  | 2221|     56|#define RAW (*ctxt->input->cur)
  ------------------
                                 (RAW == ']') && (NXT(1) == ']') && (NXT(2) == '>')) {
  ------------------
  |  | 2223|     44|#define NXT(val) ctxt->input->cur[(val)]
  ------------------
                                 (RAW == ']') && (NXT(1) == ']') && (NXT(2) == '>')) {
  ------------------
  |  | 2223|     44|#define NXT(val) ctxt->input->cur[(val)]
  ------------------
  |  Branch (6962:20): [True: 44, False: 12]
  |  Branch (6962:36): [True: 44, False: 0]
  |  Branch (6962:55): [True: 44, False: 0]
  ------------------
 6963|     44|            depth--;
 6964|     44|            if (ctxt->input->id != inputIds[depth]) {
  ------------------
  |  Branch (6964:17): [True: 4, False: 40]
  ------------------
 6965|      4|                xmlFatalErrMsg(ctxt, XML_ERR_ENTITY_BOUNDARY,
 6966|      4|                               "All markup of the conditional section is not"
 6967|      4|                               " in the same entity\n");
 6968|      4|            }
 6969|     44|            SKIP(3);
  ------------------
  |  | 2245|     44|#define SKIP(val) do {							\
  |  | 2246|     44|    ctxt->input->cur += (val),ctxt->input->col+=(val);			\
  |  | 2247|     44|    if (*ctxt->input->cur == 0)						\
  |  |  ------------------
  |  |  |  Branch (2247:9): [True: 4, False: 40]
  |  |  ------------------
  |  | 2248|     44|        xmlParserGrow(ctxt);						\
  |  | 2249|     44|  } while (0)
  |  |  ------------------
  |  |  |  Branch (2249:12): [Folded - Ignored]
  |  |  ------------------
  ------------------
 6970|     44|        } else if ((RAW == '<') && ((NXT(1) == '!') || (NXT(1) == '?'))) {
  ------------------
  |  | 2221|     12|#define RAW (*ctxt->input->cur)
  ------------------
                      } else if ((RAW == '<') && ((NXT(1) == '!') || (NXT(1) == '?'))) {
  ------------------
  |  | 2223|      8|#define NXT(val) ctxt->input->cur[(val)]
  ------------------
                      } else if ((RAW == '<') && ((NXT(1) == '!') || (NXT(1) == '?'))) {
  ------------------
  |  | 2223|      0|#define NXT(val) ctxt->input->cur[(val)]
  ------------------
  |  Branch (6970:20): [True: 8, False: 4]
  |  Branch (6970:37): [True: 8, False: 0]
  |  Branch (6970:56): [True: 0, False: 0]
  ------------------
 6971|      8|            xmlParseMarkupDecl(ctxt);
 6972|      8|        } else {
 6973|      4|            xmlFatalErr(ctxt, XML_ERR_EXT_SUBSET_NOT_FINISHED, NULL);
 6974|      4|            xmlHaltParser(ctxt);
 6975|      4|            goto error;
 6976|      4|        }
 6977|       |
 6978|    104|        if (depth == 0)
  ------------------
  |  Branch (6978:13): [True: 8, False: 96]
  ------------------
 6979|      8|            break;
 6980|       |
 6981|     96|        SKIP_BLANKS;
  ------------------
  |  | 2273|     96|#define SKIP_BLANKS xmlSkipBlankChars(ctxt)
  ------------------
 6982|     96|        SHRINK;
  ------------------
  |  | 2265|     96|    if (((ctxt->progressive == 0) || (ctxt->inputNr > 1)) && \
  |  |  ------------------
  |  |  |  Branch (2265:10): [True: 96, False: 0]
  |  |  |  Branch (2265:38): [True: 0, False: 0]
  |  |  ------------------
  |  | 2266|     96|        (ctxt->input->cur - ctxt->input->base > 2 * INPUT_CHUNK) && \
  |  |  ------------------
  |  |  |  |   97|     96|#define INPUT_CHUNK	250
  |  |  ------------------
  |  |  |  Branch (2266:9): [True: 0, False: 96]
  |  |  ------------------
  |  | 2267|     96|	(ctxt->input->end - ctxt->input->cur < 2 * INPUT_CHUNK)) \
  |  |  ------------------
  |  |  |  |   97|      0|#define INPUT_CHUNK	250
  |  |  ------------------
  |  |  |  Branch (2267:2): [True: 0, False: 0]
  |  |  ------------------
  |  | 2268|     96|	xmlParserShrink(ctxt);
  ------------------
 6983|     96|        GROW;
  ------------------
  |  | 2270|     96|#define GROW if (ctxt->input->end - ctxt->input->cur < INPUT_CHUNK)	\
  |  |  ------------------
  |  |  |  |   97|     96|#define INPUT_CHUNK	250
  |  |  ------------------
  |  |  |  Branch (2270:18): [True: 64, False: 32]
  |  |  ------------------
  |  | 2271|     96|	xmlParserGrow(ctxt);
  ------------------
 6984|     96|    }
 6985|       |
 6986|     12|error:
 6987|     12|    xmlFree(inputIds);
 6988|     12|}
parser.c:xmlErrAttributeDup:
  243|     54|{
  244|     54|    if ((ctxt != NULL) && (ctxt->disableSAX != 0) &&
  ------------------
  |  Branch (244:9): [True: 54, False: 0]
  |  Branch (244:27): [True: 38, False: 16]
  ------------------
  245|     54|        (ctxt->instate == XML_PARSER_EOF))
  ------------------
  |  Branch (245:9): [True: 0, False: 38]
  ------------------
  246|      0|	return;
  247|     54|    if (ctxt != NULL)
  ------------------
  |  Branch (247:9): [True: 54, False: 0]
  ------------------
  248|     54|	ctxt->errNo = XML_ERR_ATTRIBUTE_REDEFINED;
  249|       |
  250|     54|    if (prefix == NULL)
  ------------------
  |  Branch (250:9): [True: 24, False: 30]
  ------------------
  251|     24|        __xmlRaiseError(NULL, NULL, NULL, ctxt, NULL, XML_FROM_PARSER,
  252|     24|                        XML_ERR_ATTRIBUTE_REDEFINED, XML_ERR_FATAL, NULL, 0,
  253|     24|                        (const char *) localname, NULL, NULL, 0, 0,
  254|     24|                        "Attribute %s redefined\n", localname);
  255|     30|    else
  256|     30|        __xmlRaiseError(NULL, NULL, NULL, ctxt, NULL, XML_FROM_PARSER,
  257|     30|                        XML_ERR_ATTRIBUTE_REDEFINED, XML_ERR_FATAL, NULL, 0,
  258|     30|                        (const char *) prefix, (const char *) localname,
  259|     30|                        NULL, 0, 0, "Attribute %s:%s redefined\n", prefix,
  260|     30|                        localname);
  261|     54|    if (ctxt != NULL) {
  ------------------
  |  Branch (261:9): [True: 54, False: 0]
  ------------------
  262|     54|	ctxt->wellFormed = 0;
  263|     54|	if (ctxt->recovery == 0)
  ------------------
  |  Branch (263:6): [True: 54, False: 0]
  ------------------
  264|     54|	    ctxt->disableSAX = 1;
  265|     54|    }
  266|     54|}
parser.c:xmlParseNameAndCompare:
 3682|  15.1k|xmlParseNameAndCompare(xmlParserCtxtPtr ctxt, xmlChar const *other) {
 3683|  15.1k|    register const xmlChar *cmp = other;
 3684|  15.1k|    register const xmlChar *in;
 3685|  15.1k|    const xmlChar *ret;
 3686|       |
 3687|  15.1k|    GROW;
  ------------------
  |  | 2270|  15.1k|#define GROW if (ctxt->input->end - ctxt->input->cur < INPUT_CHUNK)	\
  |  |  ------------------
  |  |  |  |   97|  15.1k|#define INPUT_CHUNK	250
  |  |  ------------------
  |  |  |  Branch (2270:18): [True: 6.63k, False: 8.54k]
  |  |  ------------------
  |  | 2271|  15.1k|	xmlParserGrow(ctxt);
  ------------------
 3688|  15.1k|    if (ctxt->instate == XML_PARSER_EOF)
  ------------------
  |  Branch (3688:9): [True: 0, False: 15.1k]
  ------------------
 3689|      0|        return(NULL);
 3690|       |
 3691|  15.1k|    in = ctxt->input->cur;
 3692|  72.1k|    while (*in != 0 && *in == *cmp) {
  ------------------
  |  Branch (3692:12): [True: 72.1k, False: 0]
  |  Branch (3692:24): [True: 56.9k, False: 15.1k]
  ------------------
 3693|  56.9k|	++in;
 3694|  56.9k|	++cmp;
 3695|  56.9k|    }
 3696|  15.1k|    if (*cmp == 0 && (*in == '>' || IS_BLANK_CH (*in))) {
  ------------------
  |  |  151|      0|#define IS_BLANK_CH(c)  xmlIsBlank_ch(c)
  |  |  ------------------
  |  |  |  |   88|      0|#define xmlIsBlank_ch(c)	(((c) == 0x20) || \
  |  |  |  |  ------------------
  |  |  |  |  |  Branch (88:27): [True: 0, False: 0]
  |  |  |  |  ------------------
  |  |  |  |   89|      0|				 ((0x9 <= (c)) && ((c) <= 0xa)) || \
  |  |  |  |  ------------------
  |  |  |  |  |  Branch (89:7): [True: 0, False: 0]
  |  |  |  |  |  Branch (89:23): [True: 0, False: 0]
  |  |  |  |  ------------------
  |  |  |  |   90|      0|				 ((c) == 0xd))
  |  |  |  |  ------------------
  |  |  |  |  |  Branch (90:6): [True: 0, False: 0]
  |  |  |  |  ------------------
  |  |  ------------------
  ------------------
  |  Branch (3696:9): [True: 15.1k, False: 4]
  |  Branch (3696:23): [True: 15.1k, False: 0]
  ------------------
 3697|       |	/* success */
 3698|  15.1k|	ctxt->input->col += in - ctxt->input->cur;
 3699|  15.1k|	ctxt->input->cur = in;
 3700|  15.1k|	return (const xmlChar*) 1;
 3701|  15.1k|    }
 3702|       |    /* failure (or end of input buffer), check with full function */
 3703|      4|    ret = xmlParseName (ctxt);
 3704|       |    /* strings coming from the dictionary direct compare possible */
 3705|      4|    if (ret == other) {
  ------------------
  |  Branch (3705:9): [True: 0, False: 4]
  ------------------
 3706|      0|	return (const xmlChar*) 1;
 3707|      0|    }
 3708|      4|    return ret;
 3709|      4|}
parser.c:spacePop:
 2173|  57.4k|static int spacePop(xmlParserCtxtPtr ctxt) {
 2174|  57.4k|    int ret;
 2175|  57.4k|    if (ctxt->spaceNr <= 0) return(0);
  ------------------
  |  Branch (2175:9): [True: 0, False: 57.4k]
  ------------------
 2176|  57.4k|    ctxt->spaceNr--;
 2177|  57.4k|    if (ctxt->spaceNr > 0)
  ------------------
  |  Branch (2177:9): [True: 57.4k, False: 0]
  ------------------
 2178|  57.4k|	ctxt->space = &ctxt->spaceTab[ctxt->spaceNr - 1];
 2179|      0|    else
 2180|      0|        ctxt->space = &ctxt->spaceTab[0];
 2181|  57.4k|    ret = ctxt->spaceTab[ctxt->spaceNr];
 2182|  57.4k|    ctxt->spaceTab[ctxt->spaceNr] = -1;
 2183|  57.4k|    return(ret);
 2184|  57.4k|}
parser.c:xmlParseAttValueInternal:
 9115|   102k|{
 9116|   102k|    xmlChar limit = 0;
 9117|   102k|    const xmlChar *in = NULL, *start, *end, *last;
 9118|   102k|    xmlChar *ret = NULL;
 9119|   102k|    int line, col;
 9120|   102k|    int maxLength = (ctxt->options & XML_PARSE_HUGE) ?
  ------------------
  |  Branch (9120:21): [True: 0, False: 102k]
  ------------------
 9121|      0|                    XML_MAX_HUGE_LENGTH :
  ------------------
  |  |   49|      0|#define XML_MAX_HUGE_LENGTH 1000000000
  ------------------
 9122|   102k|                    XML_MAX_TEXT_LENGTH;
  ------------------
  |  |   42|   102k|#define XML_MAX_TEXT_LENGTH 10000000
  ------------------
 9123|       |
 9124|   102k|    GROW;
  ------------------
  |  | 2270|   102k|#define GROW if (ctxt->input->end - ctxt->input->cur < INPUT_CHUNK)	\
  |  |  ------------------
  |  |  |  |   97|   102k|#define INPUT_CHUNK	250
  |  |  ------------------
  |  |  |  Branch (2270:18): [True: 31.9k, False: 70.2k]
  |  |  ------------------
  |  | 2271|   102k|	xmlParserGrow(ctxt);
  ------------------
 9125|   102k|    in = (xmlChar *) CUR_PTR;
  ------------------
  |  | 2224|   102k|#define CUR_PTR ctxt->input->cur
  ------------------
 9126|   102k|    line = ctxt->input->line;
 9127|   102k|    col = ctxt->input->col;
 9128|   102k|    if (*in != '"' && *in != '\'') {
  ------------------
  |  Branch (9128:9): [True: 4.62k, False: 97.5k]
  |  Branch (9128:23): [True: 0, False: 4.62k]
  ------------------
 9129|      0|        xmlFatalErr(ctxt, XML_ERR_ATTRIBUTE_NOT_STARTED, NULL);
 9130|      0|        return (NULL);
 9131|      0|    }
 9132|   102k|    ctxt->instate = XML_PARSER_ATTRIBUTE_VALUE;
 9133|       |
 9134|       |    /*
 9135|       |     * try to handle in this routine the most common case where no
 9136|       |     * allocation of a new string is required and where content is
 9137|       |     * pure ASCII.
 9138|       |     */
 9139|   102k|    limit = *in++;
 9140|   102k|    col++;
 9141|   102k|    end = ctxt->input->end;
 9142|   102k|    start = in;
 9143|   102k|    if (in >= end) {
  ------------------
  |  Branch (9143:9): [True: 0, False: 102k]
  ------------------
 9144|      0|        GROW_PARSE_ATT_VALUE_INTERNAL(ctxt, in, start, end)
  ------------------
  |  | 9101|      0|    const xmlChar *oldbase = ctxt->input->base;\
  |  | 9102|      0|    GROW;\
  |  |  ------------------
  |  |  |  | 2270|      0|#define GROW if (ctxt->input->end - ctxt->input->cur < INPUT_CHUNK)	\
  |  |  |  |  ------------------
  |  |  |  |  |  |   97|      0|#define INPUT_CHUNK	250
  |  |  |  |  ------------------
  |  |  |  |  |  Branch (2270:18): [True: 0, False: 0]
  |  |  |  |  ------------------
  |  |  |  | 2271|      0|	xmlParserGrow(ctxt);
  |  |  ------------------
  |  | 9103|      0|    if (ctxt->instate == XML_PARSER_EOF)\
  |  |  ------------------
  |  |  |  Branch (9103:9): [True: 0, False: 0]
  |  |  ------------------
  |  | 9104|      0|        return(NULL);\
  |  | 9105|      0|    if (oldbase != ctxt->input->base) {\
  |  |  ------------------
  |  |  |  Branch (9105:9): [True: 0, False: 0]
  |  |  ------------------
  |  | 9106|      0|        ptrdiff_t delta = ctxt->input->base - oldbase;\
  |  | 9107|      0|        start = start + delta;\
  |  | 9108|      0|        in = in + delta;\
  |  | 9109|      0|    }\
  |  | 9110|      0|    end = ctxt->input->end;
  ------------------
 9145|      0|    }
 9146|   102k|    if (normalize) {
  ------------------
  |  Branch (9146:9): [True: 4.27k, False: 97.8k]
  ------------------
 9147|       |        /*
 9148|       |	 * Skip any leading spaces
 9149|       |	 */
 9150|  4.40k|	while ((in < end) && (*in != limit) &&
  ------------------
  |  Branch (9150:9): [True: 4.40k, False: 0]
  |  Branch (9150:23): [True: 4.39k, False: 4]
  ------------------
 9151|  4.40k|	       ((*in == 0x20) || (*in == 0x9) ||
  ------------------
  |  Branch (9151:10): [True: 84, False: 4.31k]
  |  Branch (9151:27): [True: 0, False: 4.31k]
  ------------------
 9152|  4.39k|	        (*in == 0xA) || (*in == 0xD))) {
  ------------------
  |  Branch (9152:10): [True: 44, False: 4.26k]
  |  Branch (9152:26): [True: 0, False: 4.26k]
  ------------------
 9153|    128|	    if (*in == 0xA) {
  ------------------
  |  Branch (9153:10): [True: 44, False: 84]
  ------------------
 9154|     44|	        line++; col = 1;
 9155|     84|	    } else {
 9156|     84|	        col++;
 9157|     84|	    }
 9158|    128|	    in++;
 9159|    128|	    start = in;
 9160|    128|	    if (in >= end) {
  ------------------
  |  Branch (9160:10): [True: 0, False: 128]
  ------------------
 9161|      0|                GROW_PARSE_ATT_VALUE_INTERNAL(ctxt, in, start, end)
  ------------------
  |  | 9101|      0|    const xmlChar *oldbase = ctxt->input->base;\
  |  | 9102|      0|    GROW;\
  |  |  ------------------
  |  |  |  | 2270|      0|#define GROW if (ctxt->input->end - ctxt->input->cur < INPUT_CHUNK)	\
  |  |  |  |  ------------------
  |  |  |  |  |  |   97|      0|#define INPUT_CHUNK	250
  |  |  |  |  ------------------
  |  |  |  |  |  Branch (2270:18): [True: 0, False: 0]
  |  |  |  |  ------------------
  |  |  |  | 2271|      0|	xmlParserGrow(ctxt);
  |  |  ------------------
  |  | 9103|      0|    if (ctxt->instate == XML_PARSER_EOF)\
  |  |  ------------------
  |  |  |  Branch (9103:9): [True: 0, False: 0]
  |  |  ------------------
  |  | 9104|      0|        return(NULL);\
  |  | 9105|      0|    if (oldbase != ctxt->input->base) {\
  |  |  ------------------
  |  |  |  Branch (9105:9): [True: 0, False: 0]
  |  |  ------------------
  |  | 9106|      0|        ptrdiff_t delta = ctxt->input->base - oldbase;\
  |  | 9107|      0|        start = start + delta;\
  |  | 9108|      0|        in = in + delta;\
  |  | 9109|      0|    }\
  |  | 9110|      0|    end = ctxt->input->end;
  ------------------
 9162|      0|                if ((in - start) > maxLength) {
  ------------------
  |  Branch (9162:21): [True: 0, False: 0]
  ------------------
 9163|      0|                    xmlFatalErrMsg(ctxt, XML_ERR_ATTRIBUTE_NOT_FINISHED,
 9164|      0|                                   "AttValue length too long\n");
 9165|      0|                    return(NULL);
 9166|      0|                }
 9167|      0|	    }
 9168|    128|	}
 9169|  42.8k|	while ((in < end) && (*in != limit) && (*in >= 0x20) &&
  ------------------
  |  Branch (9169:9): [True: 42.8k, False: 0]
  |  Branch (9169:23): [True: 38.6k, False: 4.17k]
  |  Branch (9169:41): [True: 38.6k, False: 28]
  ------------------
 9170|  42.8k|	       (*in <= 0x7f) && (*in != '&') && (*in != '<')) {
  ------------------
  |  Branch (9170:9): [True: 38.6k, False: 0]
  |  Branch (9170:26): [True: 38.5k, False: 64]
  |  Branch (9170:42): [True: 38.5k, False: 0]
  ------------------
 9171|  38.5k|	    col++;
 9172|  38.5k|	    if ((*in++ == 0x20) && (*in == 0x20)) break;
  ------------------
  |  Branch (9172:10): [True: 32, False: 38.5k]
  |  Branch (9172:29): [True: 8, False: 24]
  ------------------
 9173|  38.5k|	    if (in >= end) {
  ------------------
  |  Branch (9173:10): [True: 0, False: 38.5k]
  ------------------
 9174|      0|                GROW_PARSE_ATT_VALUE_INTERNAL(ctxt, in, start, end)
  ------------------
  |  | 9101|      0|    const xmlChar *oldbase = ctxt->input->base;\
  |  | 9102|      0|    GROW;\
  |  |  ------------------
  |  |  |  | 2270|      0|#define GROW if (ctxt->input->end - ctxt->input->cur < INPUT_CHUNK)	\
  |  |  |  |  ------------------
  |  |  |  |  |  |   97|      0|#define INPUT_CHUNK	250
  |  |  |  |  ------------------
  |  |  |  |  |  Branch (2270:18): [True: 0, False: 0]
  |  |  |  |  ------------------
  |  |  |  | 2271|      0|	xmlParserGrow(ctxt);
  |  |  ------------------
  |  | 9103|      0|    if (ctxt->instate == XML_PARSER_EOF)\
  |  |  ------------------
  |  |  |  Branch (9103:9): [True: 0, False: 0]
  |  |  ------------------
  |  | 9104|      0|        return(NULL);\
  |  | 9105|      0|    if (oldbase != ctxt->input->base) {\
  |  |  ------------------
  |  |  |  Branch (9105:9): [True: 0, False: 0]
  |  |  ------------------
  |  | 9106|      0|        ptrdiff_t delta = ctxt->input->base - oldbase;\
  |  | 9107|      0|        start = start + delta;\
  |  | 9108|      0|        in = in + delta;\
  |  | 9109|      0|    }\
  |  | 9110|      0|    end = ctxt->input->end;
  ------------------
 9175|      0|                if ((in - start) > maxLength) {
  ------------------
  |  Branch (9175:21): [True: 0, False: 0]
  ------------------
 9176|      0|                    xmlFatalErrMsg(ctxt, XML_ERR_ATTRIBUTE_NOT_FINISHED,
 9177|      0|                                   "AttValue length too long\n");
 9178|      0|                    return(NULL);
 9179|      0|                }
 9180|      0|	    }
 9181|  38.5k|	}
 9182|  4.27k|	last = in;
 9183|       |	/*
 9184|       |	 * skip the trailing blanks
 9185|       |	 */
 9186|  4.28k|	while ((last[-1] == 0x20) && (last > start)) last--;
  ------------------
  |  Branch (9186:9): [True: 36, False: 4.25k]
  |  Branch (9186:31): [True: 16, False: 20]
  ------------------
 9187|  4.33k|	while ((in < end) && (*in != limit) &&
  ------------------
  |  Branch (9187:9): [True: 4.33k, False: 0]
  |  Branch (9187:23): [True: 144, False: 4.19k]
  ------------------
 9188|  4.33k|	       ((*in == 0x20) || (*in == 0x9) ||
  ------------------
  |  Branch (9188:10): [True: 16, False: 128]
  |  Branch (9188:27): [True: 8, False: 120]
  ------------------
 9189|    144|	        (*in == 0xA) || (*in == 0xD))) {
  ------------------
  |  Branch (9189:10): [True: 40, False: 80]
  |  Branch (9189:26): [True: 0, False: 80]
  ------------------
 9190|     64|	    if (*in == 0xA) {
  ------------------
  |  Branch (9190:10): [True: 40, False: 24]
  ------------------
 9191|     40|	        line++, col = 1;
 9192|     40|	    } else {
 9193|     24|	        col++;
 9194|     24|	    }
 9195|     64|	    in++;
 9196|     64|	    if (in >= end) {
  ------------------
  |  Branch (9196:10): [True: 0, False: 64]
  ------------------
 9197|      0|		const xmlChar *oldbase = ctxt->input->base;
 9198|      0|		GROW;
  ------------------
  |  | 2270|      0|#define GROW if (ctxt->input->end - ctxt->input->cur < INPUT_CHUNK)	\
  |  |  ------------------
  |  |  |  |   97|      0|#define INPUT_CHUNK	250
  |  |  ------------------
  |  |  |  Branch (2270:18): [True: 0, False: 0]
  |  |  ------------------
  |  | 2271|      0|	xmlParserGrow(ctxt);
  ------------------
 9199|      0|                if (ctxt->instate == XML_PARSER_EOF)
  ------------------
  |  Branch (9199:21): [True: 0, False: 0]
  ------------------
 9200|      0|                    return(NULL);
 9201|      0|		if (oldbase != ctxt->input->base) {
  ------------------
  |  Branch (9201:7): [True: 0, False: 0]
  ------------------
 9202|      0|		    ptrdiff_t delta = ctxt->input->base - oldbase;
 9203|      0|		    start = start + delta;
 9204|      0|		    in = in + delta;
 9205|      0|		    last = last + delta;
 9206|      0|		}
 9207|      0|		end = ctxt->input->end;
 9208|      0|                if ((in - start) > maxLength) {
  ------------------
  |  Branch (9208:21): [True: 0, False: 0]
  ------------------
 9209|      0|                    xmlFatalErrMsg(ctxt, XML_ERR_ATTRIBUTE_NOT_FINISHED,
 9210|      0|                                   "AttValue length too long\n");
 9211|      0|                    return(NULL);
 9212|      0|                }
 9213|      0|	    }
 9214|     64|	}
 9215|  4.27k|        if ((in - start) > maxLength) {
  ------------------
  |  Branch (9215:13): [True: 0, False: 4.27k]
  ------------------
 9216|      0|            xmlFatalErrMsg(ctxt, XML_ERR_ATTRIBUTE_NOT_FINISHED,
 9217|      0|                           "AttValue length too long\n");
 9218|      0|            return(NULL);
 9219|      0|        }
 9220|  4.27k|	if (*in != limit) goto need_complex;
  ------------------
  |  Branch (9220:6): [True: 80, False: 4.19k]
  ------------------
 9221|  97.8k|    } else {
 9222|  1.18M|	while ((in < end) && (*in != limit) && (*in >= 0x20) &&
  ------------------
  |  Branch (9222:9): [True: 1.18M, False: 26]
  |  Branch (9222:23): [True: 1.09M, False: 97.4k]
  |  Branch (9222:41): [True: 1.09M, False: 80]
  ------------------
 9223|  1.18M|	       (*in <= 0x7f) && (*in != '&') && (*in != '<')) {
  ------------------
  |  Branch (9223:9): [True: 1.09M, False: 12]
  |  Branch (9223:26): [True: 1.09M, False: 288]
  |  Branch (9223:42): [True: 1.09M, False: 0]
  ------------------
 9224|  1.09M|	    in++;
 9225|  1.09M|	    col++;
 9226|  1.09M|	    if (in >= end) {
  ------------------
  |  Branch (9226:10): [True: 26, False: 1.09M]
  ------------------
 9227|     26|                GROW_PARSE_ATT_VALUE_INTERNAL(ctxt, in, start, end)
  ------------------
  |  | 9101|     26|    const xmlChar *oldbase = ctxt->input->base;\
  |  | 9102|     26|    GROW;\
  |  |  ------------------
  |  |  |  | 2270|     26|#define GROW if (ctxt->input->end - ctxt->input->cur < INPUT_CHUNK)	\
  |  |  |  |  ------------------
  |  |  |  |  |  |   97|     26|#define INPUT_CHUNK	250
  |  |  |  |  ------------------
  |  |  |  |  |  Branch (2270:18): [True: 0, False: 26]
  |  |  |  |  ------------------
  |  |  |  | 2271|     26|	xmlParserGrow(ctxt);
  |  |  ------------------
  |  | 9103|     26|    if (ctxt->instate == XML_PARSER_EOF)\
  |  |  ------------------
  |  |  |  Branch (9103:9): [True: 0, False: 26]
  |  |  ------------------
  |  | 9104|     26|        return(NULL);\
  |  | 9105|     26|    if (oldbase != ctxt->input->base) {\
  |  |  ------------------
  |  |  |  Branch (9105:9): [True: 0, False: 26]
  |  |  ------------------
  |  | 9106|      0|        ptrdiff_t delta = ctxt->input->base - oldbase;\
  |  | 9107|      0|        start = start + delta;\
  |  | 9108|      0|        in = in + delta;\
  |  | 9109|      0|    }\
  |  | 9110|     26|    end = ctxt->input->end;
  ------------------
 9228|     26|                if ((in - start) > maxLength) {
  ------------------
  |  Branch (9228:21): [True: 0, False: 26]
  ------------------
 9229|      0|                    xmlFatalErrMsg(ctxt, XML_ERR_ATTRIBUTE_NOT_FINISHED,
 9230|      0|                                   "AttValue length too long\n");
 9231|      0|                    return(NULL);
 9232|      0|                }
 9233|     26|	    }
 9234|  1.09M|	}
 9235|  97.8k|	last = in;
 9236|  97.8k|        if ((in - start) > maxLength) {
  ------------------
  |  Branch (9236:13): [True: 0, False: 97.8k]
  ------------------
 9237|      0|            xmlFatalErrMsg(ctxt, XML_ERR_ATTRIBUTE_NOT_FINISHED,
 9238|      0|                           "AttValue length too long\n");
 9239|      0|            return(NULL);
 9240|      0|        }
 9241|  97.8k|	if (*in != limit) goto need_complex;
  ------------------
  |  Branch (9241:6): [True: 406, False: 97.4k]
  ------------------
 9242|  97.8k|    }
 9243|   101k|    in++;
 9244|   101k|    col++;
 9245|   101k|    if (len != NULL) {
  ------------------
  |  Branch (9245:9): [True: 99.9k, False: 1.64k]
  ------------------
 9246|  99.9k|        if (alloc) *alloc = 0;
  ------------------
  |  Branch (9246:13): [True: 99.9k, False: 0]
  ------------------
 9247|  99.9k|        *len = last - start;
 9248|  99.9k|        ret = (xmlChar *) start;
 9249|  99.9k|    } else {
 9250|  1.64k|        if (alloc) *alloc = 1;
  ------------------
  |  Branch (9250:13): [True: 0, False: 1.64k]
  ------------------
 9251|  1.64k|        ret = xmlStrndup(start, last - start);
 9252|  1.64k|    }
 9253|   101k|    CUR_PTR = in;
  ------------------
  |  | 2224|   101k|#define CUR_PTR ctxt->input->cur
  ------------------
 9254|   101k|    ctxt->input->line = line;
 9255|   101k|    ctxt->input->col = col;
 9256|   101k|    return ret;
 9257|    486|need_complex:
 9258|    486|    if (alloc) *alloc = 1;
  ------------------
  |  Branch (9258:9): [True: 482, False: 4]
  ------------------
 9259|    486|    return xmlParseAttValueComplex(ctxt, len, normalize);
 9260|   102k|}
parser.c:xmlParseAttValueComplex:
 4056|    486|xmlParseAttValueComplex(xmlParserCtxtPtr ctxt, int *attlen, int normalize) {
 4057|    486|    xmlChar limit = 0;
 4058|    486|    xmlChar *buf = NULL;
 4059|    486|    xmlChar *rep = NULL;
 4060|    486|    size_t len = 0;
 4061|    486|    size_t buf_size = 0;
 4062|    486|    size_t maxLength = (ctxt->options & XML_PARSE_HUGE) ?
  ------------------
  |  Branch (4062:24): [True: 0, False: 486]
  ------------------
 4063|      0|                       XML_MAX_HUGE_LENGTH :
  ------------------
  |  |   49|      0|#define XML_MAX_HUGE_LENGTH 1000000000
  ------------------
 4064|    486|                       XML_MAX_TEXT_LENGTH;
  ------------------
  |  |   42|    972|#define XML_MAX_TEXT_LENGTH 10000000
  ------------------
 4065|    486|    int c, l, in_space = 0;
 4066|    486|    xmlChar *current = NULL;
 4067|    486|    xmlEntityPtr ent;
 4068|       |
 4069|    486|    if (NXT(0) == '"') {
  ------------------
  |  | 2223|    486|#define NXT(val) ctxt->input->cur[(val)]
  ------------------
  |  Branch (4069:9): [True: 214, False: 272]
  ------------------
 4070|    214|	ctxt->instate = XML_PARSER_ATTRIBUTE_VALUE;
 4071|    214|	limit = '"';
 4072|    214|        NEXT;
  ------------------
  |  | 2275|    214|#define NEXT xmlNextChar(ctxt)
  ------------------
 4073|    272|    } else if (NXT(0) == '\'') {
  ------------------
  |  | 2223|    272|#define NXT(val) ctxt->input->cur[(val)]
  ------------------
  |  Branch (4073:16): [True: 272, False: 0]
  ------------------
 4074|    272|	limit = '\'';
 4075|    272|	ctxt->instate = XML_PARSER_ATTRIBUTE_VALUE;
 4076|    272|        NEXT;
  ------------------
  |  | 2275|    272|#define NEXT xmlNextChar(ctxt)
  ------------------
 4077|    272|    } else {
 4078|      0|	xmlFatalErr(ctxt, XML_ERR_ATTRIBUTE_NOT_STARTED, NULL);
 4079|      0|	return(NULL);
 4080|      0|    }
 4081|       |
 4082|       |    /*
 4083|       |     * allocate a translation buffer.
 4084|       |     */
 4085|    486|    buf_size = XML_PARSER_BUFFER_SIZE;
  ------------------
  |  |  167|    486|#define XML_PARSER_BUFFER_SIZE 100
  ------------------
 4086|    486|    buf = (xmlChar *) xmlMallocAtomic(buf_size);
 4087|    486|    if (buf == NULL) goto mem_error;
  ------------------
  |  Branch (4087:9): [True: 0, False: 486]
  ------------------
 4088|       |
 4089|       |    /*
 4090|       |     * OK loop until we reach one of the ending char or a size limit.
 4091|       |     */
 4092|    486|    c = CUR_CHAR(l);
  ------------------
  |  | 2291|    486|#define CUR_CHAR(l) xmlCurrentChar(ctxt, &l)
  ------------------
 4093|   107k|    while (((NXT(0) != limit) && /* checked */
  ------------------
  |  | 2223|   107k|#define NXT(val) ctxt->input->cur[(val)]
  ------------------
  |  Branch (4093:13): [True: 107k, False: 458]
  ------------------
 4094|   107k|            (IS_CHAR(c)) && (c != '<')) &&
  ------------------
  |  |  125|   107k|#define IS_CHAR(c)   xmlIsCharQ(c)
  |  |  ------------------
  |  |  |  |  118|   107k|#define xmlIsCharQ(c)		(((c) < 0x100) ? \
  |  |  |  |  ------------------
  |  |  |  |  |  Branch (118:25): [True: 107k, False: 0]
  |  |  |  |  ------------------
  |  |  |  |  119|   107k|				 xmlIsChar_ch((c)) :\
  |  |  |  |  ------------------
  |  |  |  |  |  |  108|   107k|#define xmlIsChar_ch(c)		(((0x9 <= (c)) && ((c) <= 0xa)) || \
  |  |  |  |  |  |  ------------------
  |  |  |  |  |  |  |  Branch (108:28): [True: 106k, False: 24]
  |  |  |  |  |  |  |  Branch (108:44): [True: 668, False: 106k]
  |  |  |  |  |  |  ------------------
  |  |  |  |  |  |  109|   107k|				 ((c) == 0xd) || \
  |  |  |  |  |  |  ------------------
  |  |  |  |  |  |  |  Branch (109:6): [True: 0, False: 106k]
  |  |  |  |  |  |  ------------------
  |  |  |  |  |  |  110|   107k|				  (0x20 <= (c)))
  |  |  |  |  |  |  ------------------
  |  |  |  |  |  |  |  Branch (110:7): [True: 106k, False: 28]
  |  |  |  |  |  |  ------------------
  |  |  |  |  ------------------
  |  |  |  |  120|   107k|				(((0x100 <= (c)) && ((c) <= 0xd7ff)) || \
  |  |  |  |  ------------------
  |  |  |  |  |  Branch (120:7): [True: 0, False: 0]
  |  |  |  |  |  Branch (120:25): [True: 0, False: 0]
  |  |  |  |  ------------------
  |  |  |  |  121|      0|				 ((0xe000 <= (c)) && ((c) <= 0xfffd)) || \
  |  |  |  |  ------------------
  |  |  |  |  |  Branch (121:7): [True: 0, False: 0]
  |  |  |  |  |  Branch (121:26): [True: 0, False: 0]
  |  |  |  |  ------------------
  |  |  |  |  122|      0|				 ((0x10000 <= (c)) && ((c) <= 0x10ffff))))
  |  |  |  |  ------------------
  |  |  |  |  |  Branch (122:7): [True: 0, False: 0]
  |  |  |  |  |  Branch (122:27): [True: 0, False: 0]
  |  |  |  |  ------------------
  |  |  ------------------
  ------------------
  |  Branch (4094:13): [True: 106k, False: 28]
  |  Branch (4094:29): [True: 106k, False: 0]
  ------------------
 4095|   107k|            (ctxt->instate != XML_PARSER_EOF)) {
  ------------------
  |  Branch (4095:13): [True: 106k, False: 0]
  ------------------
 4096|   106k|	if (c == '&') {
  ------------------
  |  Branch (4096:6): [True: 9.45k, False: 97.5k]
  ------------------
 4097|  9.45k|	    in_space = 0;
 4098|  9.45k|	    if (NXT(1) == '#') {
  ------------------
  |  | 2223|  9.45k|#define NXT(val) ctxt->input->cur[(val)]
  ------------------
  |  Branch (4098:10): [True: 344, False: 9.11k]
  ------------------
 4099|    344|		int val = xmlParseCharRef(ctxt);
 4100|       |
 4101|    344|		if (val == '&') {
  ------------------
  |  Branch (4101:7): [True: 4, False: 340]
  ------------------
 4102|      4|		    if (ctxt->replaceEntities) {
  ------------------
  |  Branch (4102:11): [True: 4, False: 0]
  ------------------
 4103|      4|			if (len + 10 > buf_size) {
  ------------------
  |  Branch (4103:8): [True: 0, False: 4]
  ------------------
 4104|      0|			    growBuffer(buf, 10);
  ------------------
  |  | 2774|      0|#define growBuffer(buffer, n) {						\
  |  | 2775|      0|    xmlChar *tmp;							\
  |  | 2776|      0|    size_t new_size = buffer##_size * 2 + n;                            \
  |  | 2777|      0|    if (new_size < buffer##_size) goto mem_error;                       \
  |  |  ------------------
  |  |  |  Branch (2777:9): [True: 0, False: 0]
  |  |  ------------------
  |  | 2778|      0|    tmp = (xmlChar *) xmlRealloc(buffer, new_size);                     \
  |  | 2779|      0|    if (tmp == NULL) goto mem_error;					\
  |  |  ------------------
  |  |  |  Branch (2779:9): [True: 0, False: 0]
  |  |  ------------------
  |  | 2780|      0|    buffer = tmp;							\
  |  | 2781|      0|    buffer##_size = new_size;                                           \
  |  | 2782|      0|}
  ------------------
 4105|      0|			}
 4106|      4|			buf[len++] = '&';
 4107|      4|		    } else {
 4108|       |			/*
 4109|       |			 * The reparsing will be done in xmlStringGetNodeList()
 4110|       |			 * called by the attribute() function in SAX.c
 4111|       |			 */
 4112|      0|			if (len + 10 > buf_size) {
  ------------------
  |  Branch (4112:8): [True: 0, False: 0]
  ------------------
 4113|      0|			    growBuffer(buf, 10);
  ------------------
  |  | 2774|      0|#define growBuffer(buffer, n) {						\
  |  | 2775|      0|    xmlChar *tmp;							\
  |  | 2776|      0|    size_t new_size = buffer##_size * 2 + n;                            \
  |  | 2777|      0|    if (new_size < buffer##_size) goto mem_error;                       \
  |  |  ------------------
  |  |  |  Branch (2777:9): [True: 0, False: 0]
  |  |  ------------------
  |  | 2778|      0|    tmp = (xmlChar *) xmlRealloc(buffer, new_size);                     \
  |  | 2779|      0|    if (tmp == NULL) goto mem_error;					\
  |  |  ------------------
  |  |  |  Branch (2779:9): [True: 0, False: 0]
  |  |  ------------------
  |  | 2780|      0|    buffer = tmp;							\
  |  | 2781|      0|    buffer##_size = new_size;                                           \
  |  | 2782|      0|}
  ------------------
 4114|      0|			}
 4115|      0|			buf[len++] = '&';
 4116|      0|			buf[len++] = '#';
 4117|      0|			buf[len++] = '3';
 4118|      0|			buf[len++] = '8';
 4119|      0|			buf[len++] = ';';
 4120|      0|		    }
 4121|    340|		} else if (val != 0) {
  ------------------
  |  Branch (4121:14): [True: 340, False: 0]
  ------------------
 4122|    340|		    if (len + 10 > buf_size) {
  ------------------
  |  Branch (4122:11): [True: 4, False: 336]
  ------------------
 4123|      8|			growBuffer(buf, 10);
  ------------------
  |  | 2774|      4|#define growBuffer(buffer, n) {						\
  |  | 2775|      4|    xmlChar *tmp;							\
  |  | 2776|      4|    size_t new_size = buffer##_size * 2 + n;                            \
  |  | 2777|      4|    if (new_size < buffer##_size) goto mem_error;                       \
  |  |  ------------------
  |  |  |  Branch (2777:9): [True: 0, False: 4]
  |  |  ------------------
  |  | 2778|      4|    tmp = (xmlChar *) xmlRealloc(buffer, new_size);                     \
  |  | 2779|      4|    if (tmp == NULL) goto mem_error;					\
  |  |  ------------------
  |  |  |  Branch (2779:9): [True: 0, False: 4]
  |  |  ------------------
  |  | 2780|      4|    buffer = tmp;							\
  |  | 2781|      4|    buffer##_size = new_size;                                           \
  |  | 2782|      4|}
  ------------------
 4124|      8|		    }
 4125|    340|		    len += xmlCopyChar(0, &buf[len], val);
 4126|    340|		}
 4127|  9.11k|	    } else {
 4128|  9.11k|		ent = xmlParseEntityRef(ctxt);
 4129|  9.11k|		if ((ent != NULL) &&
  ------------------
  |  Branch (4129:7): [True: 9.11k, False: 0]
  ------------------
 4130|  9.11k|		    (ent->etype == XML_INTERNAL_PREDEFINED_ENTITY)) {
  ------------------
  |  Branch (4130:7): [True: 96, False: 9.01k]
  ------------------
 4131|     96|		    if (len + 10 > buf_size) {
  ------------------
  |  Branch (4131:11): [True: 0, False: 96]
  ------------------
 4132|      0|			growBuffer(buf, 10);
  ------------------
  |  | 2774|      0|#define growBuffer(buffer, n) {						\
  |  | 2775|      0|    xmlChar *tmp;							\
  |  | 2776|      0|    size_t new_size = buffer##_size * 2 + n;                            \
  |  | 2777|      0|    if (new_size < buffer##_size) goto mem_error;                       \
  |  |  ------------------
  |  |  |  Branch (2777:9): [True: 0, False: 0]
  |  |  ------------------
  |  | 2778|      0|    tmp = (xmlChar *) xmlRealloc(buffer, new_size);                     \
  |  | 2779|      0|    if (tmp == NULL) goto mem_error;					\
  |  |  ------------------
  |  |  |  Branch (2779:9): [True: 0, False: 0]
  |  |  ------------------
  |  | 2780|      0|    buffer = tmp;							\
  |  | 2781|      0|    buffer##_size = new_size;                                           \
  |  | 2782|      0|}
  ------------------
 4133|      0|		    }
 4134|     96|		    if ((ctxt->replaceEntities == 0) &&
  ------------------
  |  Branch (4134:11): [True: 0, False: 96]
  ------------------
 4135|     96|		        (ent->content[0] == '&')) {
  ------------------
  |  Branch (4135:11): [True: 0, False: 0]
  ------------------
 4136|      0|			buf[len++] = '&';
 4137|      0|			buf[len++] = '#';
 4138|      0|			buf[len++] = '3';
 4139|      0|			buf[len++] = '8';
 4140|      0|			buf[len++] = ';';
 4141|     96|		    } else {
 4142|     96|			buf[len++] = ent->content[0];
 4143|     96|		    }
 4144|  9.01k|		} else if ((ent != NULL) &&
  ------------------
  |  Branch (4144:14): [True: 9.01k, False: 0]
  ------------------
 4145|  9.01k|		           (ctxt->replaceEntities != 0)) {
  ------------------
  |  Branch (4145:14): [True: 9.01k, False: 0]
  ------------------
 4146|  9.01k|		    if (ent->etype != XML_INTERNAL_PREDEFINED_ENTITY) {
  ------------------
  |  Branch (4146:11): [True: 9.01k, False: 0]
  ------------------
 4147|  9.01k|                        if (xmlParserEntityCheck(ctxt, ent->length))
  ------------------
  |  Branch (4147:29): [True: 0, False: 9.01k]
  ------------------
 4148|      0|                            goto error;
 4149|       |
 4150|  9.01k|			++ctxt->depth;
 4151|  9.01k|			rep = xmlStringDecodeEntitiesInt(ctxt, ent->content,
 4152|  9.01k|                                ent->length, XML_SUBSTITUTE_REF, 0, 0, 0,
  ------------------
  |  |  521|  9.01k|#define XML_SUBSTITUTE_REF	1
  ------------------
 4153|  9.01k|                                /* check */ 1);
 4154|  9.01k|			--ctxt->depth;
 4155|  9.01k|			if (rep != NULL) {
  ------------------
  |  Branch (4155:8): [True: 9.00k, False: 16]
  ------------------
 4156|  9.00k|			    current = rep;
 4157|  1.89M|			    while (*current != 0) { /* non input consuming */
  ------------------
  |  Branch (4157:15): [True: 1.88M, False: 9.00k]
  ------------------
 4158|  1.88M|                                if ((*current == 0xD) || (*current == 0xA) ||
  ------------------
  |  Branch (4158:37): [True: 24, False: 1.88M]
  |  Branch (4158:58): [True: 24, False: 1.88M]
  ------------------
 4159|  1.88M|                                    (*current == 0x9)) {
  ------------------
  |  Branch (4159:37): [True: 0, False: 1.88M]
  ------------------
 4160|     48|                                    buf[len++] = 0x20;
 4161|     48|                                    current++;
 4162|     48|                                } else
 4163|  1.88M|                                    buf[len++] = *current++;
 4164|  1.88M|				if (len + 10 > buf_size) {
  ------------------
  |  Branch (4164:9): [True: 52, False: 1.88M]
  ------------------
 4165|    104|				    growBuffer(buf, 10);
  ------------------
  |  | 2774|     52|#define growBuffer(buffer, n) {						\
  |  | 2775|     52|    xmlChar *tmp;							\
  |  | 2776|     52|    size_t new_size = buffer##_size * 2 + n;                            \
  |  | 2777|     52|    if (new_size < buffer##_size) goto mem_error;                       \
  |  |  ------------------
  |  |  |  Branch (2777:9): [True: 0, False: 52]
  |  |  ------------------
  |  | 2778|     52|    tmp = (xmlChar *) xmlRealloc(buffer, new_size);                     \
  |  | 2779|     52|    if (tmp == NULL) goto mem_error;					\
  |  |  ------------------
  |  |  |  Branch (2779:9): [True: 0, False: 52]
  |  |  ------------------
  |  | 2780|     52|    buffer = tmp;							\
  |  | 2781|     52|    buffer##_size = new_size;                                           \
  |  | 2782|     52|}
  ------------------
 4166|    104|				}
 4167|  1.88M|			    }
 4168|  9.00k|			    xmlFree(rep);
 4169|  9.00k|			    rep = NULL;
 4170|  9.00k|			}
 4171|  9.01k|		    } else {
 4172|      0|			if (len + 10 > buf_size) {
  ------------------
  |  Branch (4172:8): [True: 0, False: 0]
  ------------------
 4173|      0|			    growBuffer(buf, 10);
  ------------------
  |  | 2774|      0|#define growBuffer(buffer, n) {						\
  |  | 2775|      0|    xmlChar *tmp;							\
  |  | 2776|      0|    size_t new_size = buffer##_size * 2 + n;                            \
  |  | 2777|      0|    if (new_size < buffer##_size) goto mem_error;                       \
  |  |  ------------------
  |  |  |  Branch (2777:9): [True: 0, False: 0]
  |  |  ------------------
  |  | 2778|      0|    tmp = (xmlChar *) xmlRealloc(buffer, new_size);                     \
  |  | 2779|      0|    if (tmp == NULL) goto mem_error;					\
  |  |  ------------------
  |  |  |  Branch (2779:9): [True: 0, False: 0]
  |  |  ------------------
  |  | 2780|      0|    buffer = tmp;							\
  |  | 2781|      0|    buffer##_size = new_size;                                           \
  |  | 2782|      0|}
  ------------------
 4174|      0|			}
 4175|      0|			if (ent->content != NULL)
  ------------------
  |  Branch (4175:8): [True: 0, False: 0]
  ------------------
 4176|      0|			    buf[len++] = ent->content[0];
 4177|      0|		    }
 4178|  9.01k|		} else if (ent != NULL) {
  ------------------
  |  Branch (4178:14): [True: 0, False: 0]
  ------------------
 4179|      0|		    int i = xmlStrlen(ent->name);
 4180|      0|		    const xmlChar *cur = ent->name;
 4181|       |
 4182|       |		    /*
 4183|       |                     * We also check for recursion and amplification
 4184|       |                     * when entities are not substituted. They're
 4185|       |                     * often expanded later.
 4186|       |		     */
 4187|      0|		    if ((ent->etype != XML_INTERNAL_PREDEFINED_ENTITY) &&
  ------------------
  |  Branch (4187:11): [True: 0, False: 0]
  ------------------
 4188|      0|			(ent->content != NULL)) {
  ------------------
  |  Branch (4188:4): [True: 0, False: 0]
  ------------------
 4189|      0|                        if ((ent->flags & XML_ENT_CHECKED) == 0) {
  ------------------
  |  |   15|      0|#define XML_ENT_CHECKED     (1<<1)
  ------------------
  |  Branch (4189:29): [True: 0, False: 0]
  ------------------
 4190|      0|                            unsigned long oldCopy = ctxt->sizeentcopy;
 4191|       |
 4192|      0|                            ctxt->sizeentcopy = ent->length;
 4193|       |
 4194|      0|                            ++ctxt->depth;
 4195|      0|                            rep = xmlStringDecodeEntitiesInt(ctxt,
 4196|      0|                                    ent->content, ent->length,
 4197|      0|                                    XML_SUBSTITUTE_REF, 0, 0, 0,
  ------------------
  |  |  521|      0|#define XML_SUBSTITUTE_REF	1
  ------------------
 4198|      0|                                    /* check */ 1);
 4199|      0|                            --ctxt->depth;
 4200|       |
 4201|       |                            /*
 4202|       |                             * If we're parsing DTD content, the entity
 4203|       |                             * might reference other entities which
 4204|       |                             * weren't defined yet, so the check isn't
 4205|       |                             * reliable.
 4206|       |                             */
 4207|      0|                            if (ctxt->inSubset == 0) {
  ------------------
  |  Branch (4207:33): [True: 0, False: 0]
  ------------------
 4208|      0|                                ent->flags |= XML_ENT_CHECKED;
  ------------------
  |  |   15|      0|#define XML_ENT_CHECKED     (1<<1)
  ------------------
 4209|      0|                                ent->expandedSize = ctxt->sizeentcopy;
 4210|      0|                            }
 4211|       |
 4212|      0|                            if (rep != NULL) {
  ------------------
  |  Branch (4212:33): [True: 0, False: 0]
  ------------------
 4213|      0|                                xmlFree(rep);
 4214|      0|                                rep = NULL;
 4215|      0|                            } else {
 4216|      0|                                ent->content[0] = 0;
 4217|      0|                            }
 4218|       |
 4219|      0|                            if (xmlParserEntityCheck(ctxt, oldCopy))
  ------------------
  |  Branch (4219:33): [True: 0, False: 0]
  ------------------
 4220|      0|                                goto error;
 4221|      0|                        } else {
 4222|      0|                            if (xmlParserEntityCheck(ctxt, ent->expandedSize))
  ------------------
  |  Branch (4222:33): [True: 0, False: 0]
  ------------------
 4223|      0|                                goto error;
 4224|      0|                        }
 4225|      0|		    }
 4226|       |
 4227|       |		    /*
 4228|       |		     * Just output the reference
 4229|       |		     */
 4230|      0|		    buf[len++] = '&';
 4231|      0|		    while (len + i + 10 > buf_size) {
  ------------------
  |  Branch (4231:14): [True: 0, False: 0]
  ------------------
 4232|      0|			growBuffer(buf, i + 10);
  ------------------
  |  | 2774|      0|#define growBuffer(buffer, n) {						\
  |  | 2775|      0|    xmlChar *tmp;							\
  |  | 2776|      0|    size_t new_size = buffer##_size * 2 + n;                            \
  |  | 2777|      0|    if (new_size < buffer##_size) goto mem_error;                       \
  |  |  ------------------
  |  |  |  Branch (2777:9): [True: 0, False: 0]
  |  |  ------------------
  |  | 2778|      0|    tmp = (xmlChar *) xmlRealloc(buffer, new_size);                     \
  |  | 2779|      0|    if (tmp == NULL) goto mem_error;					\
  |  |  ------------------
  |  |  |  Branch (2779:9): [True: 0, False: 0]
  |  |  ------------------
  |  | 2780|      0|    buffer = tmp;							\
  |  | 2781|      0|    buffer##_size = new_size;                                           \
  |  | 2782|      0|}
  ------------------
 4233|      0|		    }
 4234|      0|		    for (;i > 0;i--)
  ------------------
  |  Branch (4234:13): [True: 0, False: 0]
  ------------------
 4235|      0|			buf[len++] = *cur++;
 4236|      0|		    buf[len++] = ';';
 4237|      0|		}
 4238|  9.11k|	    }
 4239|  97.5k|	} else {
 4240|  97.5k|	    if ((c == 0x20) || (c == 0xD) || (c == 0xA) || (c == 0x9)) {
  ------------------
  |  Branch (4240:10): [True: 7.11k, False: 90.4k]
  |  Branch (4240:25): [True: 0, False: 90.4k]
  |  Branch (4240:39): [True: 656, False: 89.7k]
  |  Branch (4240:53): [True: 12, False: 89.7k]
  ------------------
 4241|  7.77k|	        if ((len != 0) || (!normalize)) {
  ------------------
  |  Branch (4241:14): [True: 7.65k, False: 120]
  |  Branch (4241:28): [True: 44, False: 76]
  ------------------
 4242|  7.70k|		    if ((!normalize) || (!in_space)) {
  ------------------
  |  Branch (4242:11): [True: 7.54k, False: 156]
  |  Branch (4242:27): [True: 92, False: 64]
  ------------------
 4243|  7.63k|			COPY_BUF(buf, len, 0x20);
  ------------------
  |  | 2295|  7.63k|    if (v < 0x80) b[i++] = v;						\
  |  |  ------------------
  |  |  |  Branch (2295:9): [Folded - Ignored]
  |  |  ------------------
  |  | 2296|  7.63k|    else i += xmlCopyCharMultiByte(&b[i],v)
  ------------------
 4244|  7.65k|			while (len + 10 > buf_size) {
  ------------------
  |  Branch (4244:11): [True: 18, False: 7.63k]
  ------------------
 4245|     36|			    growBuffer(buf, 10);
  ------------------
  |  | 2774|     18|#define growBuffer(buffer, n) {						\
  |  | 2775|     18|    xmlChar *tmp;							\
  |  | 2776|     18|    size_t new_size = buffer##_size * 2 + n;                            \
  |  | 2777|     18|    if (new_size < buffer##_size) goto mem_error;                       \
  |  |  ------------------
  |  |  |  Branch (2777:9): [True: 0, False: 18]
  |  |  ------------------
  |  | 2778|     18|    tmp = (xmlChar *) xmlRealloc(buffer, new_size);                     \
  |  | 2779|     18|    if (tmp == NULL) goto mem_error;					\
  |  |  ------------------
  |  |  |  Branch (2779:9): [True: 0, False: 18]
  |  |  ------------------
  |  | 2780|     18|    buffer = tmp;							\
  |  | 2781|     18|    buffer##_size = new_size;                                           \
  |  | 2782|     18|}
  ------------------
 4246|     36|			}
 4247|  7.63k|		    }
 4248|  7.70k|		    in_space = 1;
 4249|  7.70k|		}
 4250|  89.7k|	    } else {
 4251|  89.7k|	        in_space = 0;
 4252|  89.7k|		COPY_BUF(buf, len, c);
  ------------------
  |  | 2295|  89.7k|    if (v < 0x80) b[i++] = v;						\
  |  |  ------------------
  |  |  |  Branch (2295:9): [True: 89.7k, False: 20]
  |  |  ------------------
  |  | 2296|  89.7k|    else i += xmlCopyCharMultiByte(&b[i],v)
  ------------------
 4253|  89.7k|		if (len + 10 > buf_size) {
  ------------------
  |  Branch (4253:7): [True: 150, False: 89.6k]
  ------------------
 4254|    300|		    growBuffer(buf, 10);
  ------------------
  |  | 2774|    150|#define growBuffer(buffer, n) {						\
  |  | 2775|    150|    xmlChar *tmp;							\
  |  | 2776|    150|    size_t new_size = buffer##_size * 2 + n;                            \
  |  | 2777|    150|    if (new_size < buffer##_size) goto mem_error;                       \
  |  |  ------------------
  |  |  |  Branch (2777:9): [True: 0, False: 150]
  |  |  ------------------
  |  | 2778|    150|    tmp = (xmlChar *) xmlRealloc(buffer, new_size);                     \
  |  | 2779|    150|    if (tmp == NULL) goto mem_error;					\
  |  |  ------------------
  |  |  |  Branch (2779:9): [True: 0, False: 150]
  |  |  ------------------
  |  | 2780|    150|    buffer = tmp;							\
  |  | 2781|    150|    buffer##_size = new_size;                                           \
  |  | 2782|    150|}
  ------------------
 4255|    300|		}
 4256|  89.7k|	    }
 4257|  97.5k|	    NEXTL(l);
  ------------------
  |  | 2284|  97.5k|#define NEXTL(l) do {							\
  |  | 2285|  97.5k|    if (*(ctxt->input->cur) == '\n') {					\
  |  |  ------------------
  |  |  |  Branch (2285:9): [True: 520, False: 97.0k]
  |  |  ------------------
  |  | 2286|    520|	ctxt->input->line++; ctxt->input->col = 1;			\
  |  | 2287|  97.0k|    } else ctxt->input->col++;						\
  |  | 2288|  97.5k|    ctxt->input->cur += l;				\
  |  | 2289|  97.5k|  } while (0)
  |  |  ------------------
  |  |  |  Branch (2289:12): [Folded - Ignored]
  |  |  ------------------
  ------------------
 4258|  97.5k|	}
 4259|   106k|	GROW;
  ------------------
  |  | 2270|   106k|#define GROW if (ctxt->input->end - ctxt->input->cur < INPUT_CHUNK)	\
  |  |  ------------------
  |  |  |  |   97|   106k|#define INPUT_CHUNK	250
  |  |  ------------------
  |  |  |  Branch (2270:18): [True: 6.31k, False: 100k]
  |  |  ------------------
  |  | 2271|   106k|	xmlParserGrow(ctxt);
  ------------------
 4260|   106k|	c = CUR_CHAR(l);
  ------------------
  |  | 2291|   106k|#define CUR_CHAR(l) xmlCurrentChar(ctxt, &l)
  ------------------
 4261|   106k|        if (len > maxLength) {
  ------------------
  |  Branch (4261:13): [True: 0, False: 106k]
  ------------------
 4262|      0|            xmlFatalErrMsg(ctxt, XML_ERR_ATTRIBUTE_NOT_FINISHED,
 4263|      0|                           "AttValue length too long\n");
 4264|      0|            goto mem_error;
 4265|      0|        }
 4266|   106k|    }
 4267|    486|    if (ctxt->instate == XML_PARSER_EOF)
  ------------------
  |  Branch (4267:9): [True: 16, False: 470]
  ------------------
 4268|     16|        goto error;
 4269|       |
 4270|    470|    if ((in_space) && (normalize)) {
  ------------------
  |  Branch (4270:9): [True: 96, False: 374]
  |  Branch (4270:23): [True: 48, False: 48]
  ------------------
 4271|    100|        while ((len > 0) && (buf[len - 1] == 0x20)) len--;
  ------------------
  |  Branch (4271:16): [True: 100, False: 0]
  |  Branch (4271:29): [True: 52, False: 48]
  ------------------
 4272|     48|    }
 4273|    470|    buf[len] = 0;
 4274|    470|    if (RAW == '<') {
  ------------------
  |  | 2221|    470|#define RAW (*ctxt->input->cur)
  ------------------
  |  Branch (4274:9): [True: 0, False: 470]
  ------------------
 4275|      0|	xmlFatalErr(ctxt, XML_ERR_LT_IN_ATTRIBUTE, NULL);
 4276|    470|    } else if (RAW != limit) {
  ------------------
  |  | 2221|    470|#define RAW (*ctxt->input->cur)
  ------------------
  |  Branch (4276:16): [True: 12, False: 458]
  ------------------
 4277|     12|	if ((c != 0) && (!IS_CHAR(c))) {
  ------------------
  |  |  125|      4|#define IS_CHAR(c)   xmlIsCharQ(c)
  |  |  ------------------
  |  |  |  |  118|      4|#define xmlIsCharQ(c)		(((c) < 0x100) ? \
  |  |  |  |  ------------------
  |  |  |  |  |  Branch (118:25): [True: 4, False: 0]
  |  |  |  |  ------------------
  |  |  |  |  119|      4|				 xmlIsChar_ch((c)) :\
  |  |  |  |  ------------------
  |  |  |  |  |  |  108|      4|#define xmlIsChar_ch(c)		(((0x9 <= (c)) && ((c) <= 0xa)) || \
  |  |  |  |  |  |  ------------------
  |  |  |  |  |  |  |  Branch (108:28): [True: 4, False: 0]
  |  |  |  |  |  |  |  Branch (108:44): [True: 0, False: 4]
  |  |  |  |  |  |  ------------------
  |  |  |  |  |  |  109|      4|				 ((c) == 0xd) || \
  |  |  |  |  |  |  ------------------
  |  |  |  |  |  |  |  Branch (109:6): [True: 0, False: 4]
  |  |  |  |  |  |  ------------------
  |  |  |  |  |  |  110|      4|				  (0x20 <= (c)))
  |  |  |  |  |  |  ------------------
  |  |  |  |  |  |  |  Branch (110:7): [True: 0, False: 4]
  |  |  |  |  |  |  ------------------
  |  |  |  |  ------------------
  |  |  |  |  120|      4|				(((0x100 <= (c)) && ((c) <= 0xd7ff)) || \
  |  |  |  |  ------------------
  |  |  |  |  |  Branch (120:7): [True: 0, False: 0]
  |  |  |  |  |  Branch (120:25): [True: 0, False: 0]
  |  |  |  |  ------------------
  |  |  |  |  121|      0|				 ((0xe000 <= (c)) && ((c) <= 0xfffd)) || \
  |  |  |  |  ------------------
  |  |  |  |  |  Branch (121:7): [True: 0, False: 0]
  |  |  |  |  |  Branch (121:26): [True: 0, False: 0]
  |  |  |  |  ------------------
  |  |  |  |  122|      0|				 ((0x10000 <= (c)) && ((c) <= 0x10ffff))))
  |  |  |  |  ------------------
  |  |  |  |  |  Branch (122:7): [True: 0, False: 0]
  |  |  |  |  |  Branch (122:27): [True: 0, False: 0]
  |  |  |  |  ------------------
  |  |  ------------------
  ------------------
  |  Branch (4277:6): [True: 4, False: 8]
  |  Branch (4277:18): [True: 4, False: 0]
  ------------------
 4278|      4|	    xmlFatalErrMsg(ctxt, XML_ERR_INVALID_CHAR,
 4279|      4|			   "invalid character in attribute value\n");
 4280|      8|	} else {
 4281|      8|	    xmlFatalErrMsg(ctxt, XML_ERR_ATTRIBUTE_NOT_FINISHED,
 4282|      8|			   "AttValue: ' expected\n");
 4283|      8|        }
 4284|     12|    } else
 4285|    458|	NEXT;
  ------------------
  |  | 2275|    458|#define NEXT xmlNextChar(ctxt)
  ------------------
 4286|       |
 4287|    470|    if (attlen != NULL) *attlen = len;
  ------------------
  |  Branch (4287:9): [True: 466, False: 4]
  ------------------
 4288|    470|    return(buf);
 4289|       |
 4290|      0|mem_error:
 4291|      0|    xmlErrMemory(ctxt, NULL);
 4292|     16|error:
 4293|     16|    if (buf != NULL)
  ------------------
  |  Branch (4293:9): [True: 16, False: 0]
  ------------------
 4294|     16|        xmlFree(buf);
 4295|     16|    if (rep != NULL)
  ------------------
  |  Branch (4295:9): [True: 0, False: 16]
  ------------------
 4296|      0|        xmlFree(rep);
 4297|     16|    return(NULL);
 4298|      0|}
parser.c:xmlParseContentInternal:
10210|    928|xmlParseContentInternal(xmlParserCtxtPtr ctxt) {
10211|    928|    int nameNr = ctxt->nameNr;
10212|       |
10213|    928|    GROW;
  ------------------
  |  | 2270|    928|#define GROW if (ctxt->input->end - ctxt->input->cur < INPUT_CHUNK)	\
  |  |  ------------------
  |  |  |  |   97|    928|#define INPUT_CHUNK	250
  |  |  ------------------
  |  |  |  Branch (2270:18): [True: 774, False: 154]
  |  |  ------------------
  |  | 2271|    928|	xmlParserGrow(ctxt);
  ------------------
10214|  80.2k|    while ((ctxt->input->cur < ctxt->input->end) &&
  ------------------
  |  Branch (10214:12): [True: 79.7k, False: 488]
  ------------------
10215|  80.2k|	   (ctxt->instate != XML_PARSER_EOF)) {
  ------------------
  |  Branch (10215:5): [True: 79.7k, False: 0]
  ------------------
10216|  79.7k|	const xmlChar *cur = ctxt->input->cur;
10217|       |
10218|       |	/*
10219|       |	 * First case : a Processing Instruction.
10220|       |	 */
10221|  79.7k|	if ((*cur == '<') && (cur[1] == '?')) {
  ------------------
  |  Branch (10221:6): [True: 37.0k, False: 42.7k]
  |  Branch (10221:23): [True: 16, False: 36.9k]
  ------------------
10222|     16|	    xmlParsePI(ctxt);
10223|     16|	}
10224|       |
10225|       |	/*
10226|       |	 * Second case : a CDSection
10227|       |	 */
10228|       |	/* 2.6.0 test was *cur not RAW */
10229|  79.6k|	else if (CMP9(CUR_PTR, '<', '!', '[', 'C', 'D', 'A', 'T', 'A', '[')) {
  ------------------
  |  | 2239|  79.6k|  ( CMP8( s, c1, c2, c3, c4, c5, c6, c7, c8 ) && \
  |  |  ------------------
  |  |  |  | 2237|   159k|  ( CMP7( s, c1, c2, c3, c4, c5, c6, c7 ) && ((unsigned char *) s)[ 7 ] == c8 )
  |  |  |  |  ------------------
  |  |  |  |  |  | 2235|   159k|  ( CMP6( s, c1, c2, c3, c4, c5, c6 ) && ((unsigned char *) s)[ 6 ] == c7 )
  |  |  |  |  |  |  ------------------
  |  |  |  |  |  |  |  | 2233|   159k|  ( CMP5( s, c1, c2, c3, c4, c5 ) && ((unsigned char *) s)[ 5 ] == c6 )
  |  |  |  |  |  |  |  |  ------------------
  |  |  |  |  |  |  |  |  |  | 2231|   159k|  ( CMP4( s, c1, c2, c3, c4 ) && ((unsigned char *) s)[ 4 ] == c5 )
  |  |  |  |  |  |  |  |  |  |  ------------------
  |  |  |  |  |  |  |  |  |  |  |  | 2228|   159k|  ( ((unsigned char *) s)[ 0 ] == c1 && ((unsigned char *) s)[ 1 ] == c2 && \
  |  |  |  |  |  |  |  |  |  |  |  |  ------------------
  |  |  |  |  |  |  |  |  |  |  |  |  |  Branch (2228:5): [True: 36.9k, False: 42.7k]
  |  |  |  |  |  |  |  |  |  |  |  |  |  Branch (2228:41): [True: 322, False: 36.6k]
  |  |  |  |  |  |  |  |  |  |  |  |  ------------------
  |  |  |  |  |  |  |  |  |  |  |  | 2229|  79.6k|    ((unsigned char *) s)[ 2 ] == c3 && ((unsigned char *) s)[ 3 ] == c4 )
  |  |  |  |  |  |  |  |  |  |  |  |  ------------------
  |  |  |  |  |  |  |  |  |  |  |  |  |  Branch (2229:5): [True: 72, False: 250]
  |  |  |  |  |  |  |  |  |  |  |  |  |  Branch (2229:41): [True: 72, False: 0]
  |  |  |  |  |  |  |  |  |  |  |  |  ------------------
  |  |  |  |  |  |  |  |  |  |  ------------------
  |  |  |  |  |  |  |  |  |  |  |  Branch (2231:34): [True: 72, False: 0]
  |  |  |  |  |  |  |  |  |  |  ------------------
  |  |  |  |  |  |  |  |  ------------------
  |  |  |  |  |  |  |  |  |  Branch (2233:38): [True: 72, False: 0]
  |  |  |  |  |  |  |  |  ------------------
  |  |  |  |  |  |  ------------------
  |  |  |  |  |  |  |  Branch (2235:42): [True: 72, False: 0]
  |  |  |  |  |  |  ------------------
  |  |  |  |  ------------------
  |  |  |  |  |  Branch (2237:46): [True: 72, False: 0]
  |  |  |  |  ------------------
  |  |  ------------------
  |  | 2240|  79.6k|    ((unsigned char *) s)[ 8 ] == c9 )
  |  |  ------------------
  |  |  |  Branch (2240:5): [True: 72, False: 0]
  |  |  ------------------
  ------------------
10230|     72|	    xmlParseCDSect(ctxt);
10231|     72|	}
10232|       |
10233|       |	/*
10234|       |	 * Third case :  a comment
10235|       |	 */
10236|  79.6k|	else if ((*cur == '<') && (NXT(1) == '!') &&
  ------------------
  |  | 2223|  36.9k|#define NXT(val) ctxt->input->cur[(val)]
  ------------------
  |  Branch (10236:11): [True: 36.9k, False: 42.7k]
  |  Branch (10236:28): [True: 250, False: 36.6k]
  ------------------
10237|  79.6k|		 (NXT(2) == '-') && (NXT(3) == '-')) {
  ------------------
  |  | 2223|    250|#define NXT(val) ctxt->input->cur[(val)]
  ------------------
              		 (NXT(2) == '-') && (NXT(3) == '-')) {
  ------------------
  |  | 2223|    248|#define NXT(val) ctxt->input->cur[(val)]
  ------------------
  |  Branch (10237:4): [True: 248, False: 2]
  |  Branch (10237:23): [True: 248, False: 0]
  ------------------
10238|    248|	    xmlParseComment(ctxt);
10239|    248|	    ctxt->instate = XML_PARSER_CONTENT;
10240|    248|	}
10241|       |
10242|       |	/*
10243|       |	 * Fourth case :  a sub-element.
10244|       |	 */
10245|  79.3k|	else if (*cur == '<') {
  ------------------
  |  Branch (10245:11): [True: 36.6k, False: 42.7k]
  ------------------
10246|  36.6k|            if (NXT(1) == '/') {
  ------------------
  |  | 2223|  36.6k|#define NXT(val) ctxt->input->cur[(val)]
  ------------------
  |  Branch (10246:17): [True: 8.36k, False: 28.3k]
  ------------------
10247|  8.36k|                if (ctxt->nameNr <= nameNr)
  ------------------
  |  Branch (10247:21): [True: 440, False: 7.92k]
  ------------------
10248|    440|                    break;
10249|  7.92k|	        xmlParseElementEnd(ctxt);
10250|  28.3k|            } else {
10251|  28.3k|	        xmlParseElementStart(ctxt);
10252|  28.3k|            }
10253|  36.6k|	}
10254|       |
10255|       |	/*
10256|       |	 * Fifth case : a reference. If if has not been resolved,
10257|       |	 *    parsing returns it's Name, create the node
10258|       |	 */
10259|       |
10260|  42.7k|	else if (*cur == '&') {
  ------------------
  |  Branch (10260:11): [True: 6.48k, False: 36.2k]
  ------------------
10261|  6.48k|	    xmlParseReference(ctxt);
10262|  6.48k|	}
10263|       |
10264|       |	/*
10265|       |	 * Last case, text. Note that References are handled directly.
10266|       |	 */
10267|  36.2k|	else {
10268|  36.2k|	    xmlParseCharDataInternal(ctxt, 0);
10269|  36.2k|	}
10270|       |
10271|  79.2k|	SHRINK;
  ------------------
  |  | 2265|  79.2k|    if (((ctxt->progressive == 0) || (ctxt->inputNr > 1)) && \
  |  |  ------------------
  |  |  |  Branch (2265:10): [True: 79.2k, False: 0]
  |  |  |  Branch (2265:38): [True: 0, False: 0]
  |  |  ------------------
  |  | 2266|  79.2k|        (ctxt->input->cur - ctxt->input->base > 2 * INPUT_CHUNK) && \
  |  |  ------------------
  |  |  |  |   97|  79.2k|#define INPUT_CHUNK	250
  |  |  ------------------
  |  |  |  Branch (2266:9): [True: 64.3k, False: 14.8k]
  |  |  ------------------
  |  | 2267|  79.2k|	(ctxt->input->end - ctxt->input->cur < 2 * INPUT_CHUNK)) \
  |  |  ------------------
  |  |  |  |   97|  64.3k|#define INPUT_CHUNK	250
  |  |  ------------------
  |  |  |  Branch (2267:2): [True: 432, False: 63.9k]
  |  |  ------------------
  |  | 2268|  79.2k|	xmlParserShrink(ctxt);
  ------------------
10272|  79.2k|	GROW;
  ------------------
  |  | 2270|  79.2k|#define GROW if (ctxt->input->end - ctxt->input->cur < INPUT_CHUNK)	\
  |  |  ------------------
  |  |  |  |   97|  79.2k|#define INPUT_CHUNK	250
  |  |  ------------------
  |  |  |  Branch (2270:18): [True: 5.08k, False: 74.1k]
  |  |  ------------------
  |  | 2271|  79.2k|	xmlParserGrow(ctxt);
  ------------------
10273|  79.2k|    }
10274|    928|}
parser.c:xmlFatalErrMsgStrIntStr:
  416|     28|{
  417|     28|    if ((ctxt != NULL) && (ctxt->disableSAX != 0) &&
  ------------------
  |  Branch (417:9): [True: 28, False: 0]
  |  Branch (417:27): [True: 18, False: 10]
  ------------------
  418|     28|        (ctxt->instate == XML_PARSER_EOF))
  ------------------
  |  Branch (418:9): [True: 0, False: 18]
  ------------------
  419|      0|	return;
  420|     28|    if (ctxt != NULL)
  ------------------
  |  Branch (420:9): [True: 28, False: 0]
  ------------------
  421|     28|	ctxt->errNo = error;
  422|     28|    __xmlRaiseError(NULL, NULL, NULL,
  423|     28|                    ctxt, NULL, XML_FROM_PARSER, error, XML_ERR_FATAL,
  424|     28|                    NULL, 0, (const char *) str1, (const char *) str2,
  425|     28|		    NULL, val, 0, msg, str1, val, str2);
  426|     28|    if (ctxt != NULL) {
  ------------------
  |  Branch (426:9): [True: 28, False: 0]
  ------------------
  427|     28|	ctxt->wellFormed = 0;
  428|     28|	if (ctxt->recovery == 0)
  ------------------
  |  Branch (428:6): [True: 28, False: 0]
  ------------------
  429|     28|	    ctxt->disableSAX = 1;
  430|     28|    }
  431|     28|}
parser.c:xmlParseElementStart:
10351|  28.9k|xmlParseElementStart(xmlParserCtxtPtr ctxt) {
10352|  28.9k|    const xmlChar *name;
10353|  28.9k|    const xmlChar *prefix = NULL;
10354|  28.9k|    const xmlChar *URI = NULL;
10355|  28.9k|    xmlParserNodeInfo node_info;
10356|  28.9k|    int line;
10357|  28.9k|    xmlNodePtr cur;
10358|  28.9k|    int nbNs = 0;
10359|       |
10360|  28.9k|    if (((unsigned int) ctxt->nameNr > xmlParserMaxDepth) &&
  ------------------
  |  Branch (10360:9): [True: 0, False: 28.9k]
  ------------------
10361|  28.9k|        ((ctxt->options & XML_PARSE_HUGE) == 0)) {
  ------------------
  |  Branch (10361:9): [True: 0, False: 0]
  ------------------
10362|      0|	xmlFatalErrMsgInt(ctxt, XML_ERR_INTERNAL_ERROR,
10363|      0|		 "Excessive depth in document: %d use XML_PARSE_HUGE option\n",
10364|      0|			  xmlParserMaxDepth);
10365|      0|	xmlHaltParser(ctxt);
10366|      0|	return(-1);
10367|      0|    }
10368|       |
10369|       |    /* Capture start position */
10370|  28.9k|    if (ctxt->record_info) {
  ------------------
  |  Branch (10370:9): [True: 0, False: 28.9k]
  ------------------
10371|      0|        node_info.begin_pos = ctxt->input->consumed +
10372|      0|                          (CUR_PTR - ctxt->input->base);
  ------------------
  |  | 2224|      0|#define CUR_PTR ctxt->input->cur
  ------------------
10373|      0|	node_info.begin_line = ctxt->input->line;
10374|      0|    }
10375|       |
10376|  28.9k|    if (ctxt->spaceNr == 0)
  ------------------
  |  Branch (10376:9): [True: 0, False: 28.9k]
  ------------------
10377|      0|	spacePush(ctxt, -1);
10378|  28.9k|    else if (*ctxt->space == -2)
  ------------------
  |  Branch (10378:14): [True: 0, False: 28.9k]
  ------------------
10379|      0|	spacePush(ctxt, -1);
10380|  28.9k|    else
10381|  28.9k|	spacePush(ctxt, *ctxt->space);
10382|       |
10383|  28.9k|    line = ctxt->input->line;
10384|  28.9k|#ifdef LIBXML_SAX1_ENABLED
10385|  28.9k|    if (ctxt->sax2)
  ------------------
  |  Branch (10385:9): [True: 28.9k, False: 0]
  ------------------
10386|  28.9k|#endif /* LIBXML_SAX1_ENABLED */
10387|  28.9k|        name = xmlParseStartTag2(ctxt, &prefix, &URI, &nbNs);
10388|      0|#ifdef LIBXML_SAX1_ENABLED
10389|      0|    else
10390|      0|	name = xmlParseStartTag(ctxt);
10391|  28.9k|#endif /* LIBXML_SAX1_ENABLED */
10392|  28.9k|    if (ctxt->instate == XML_PARSER_EOF)
  ------------------
  |  Branch (10392:9): [True: 10, False: 28.8k]
  ------------------
10393|     10|	return(-1);
10394|  28.8k|    if (name == NULL) {
  ------------------
  |  Branch (10394:9): [True: 20, False: 28.8k]
  ------------------
10395|     20|	spacePop(ctxt);
10396|     20|        return(-1);
10397|     20|    }
10398|  28.8k|    nameNsPush(ctxt, name, prefix, URI, line, nbNs);
10399|  28.8k|    cur = ctxt->node;
10400|       |
10401|  28.8k|#ifdef LIBXML_VALID_ENABLED
10402|       |    /*
10403|       |     * [ VC: Root Element Type ]
10404|       |     * The Name in the document type declaration must match the element
10405|       |     * type of the root element.
10406|       |     */
10407|  28.8k|    if (ctxt->validate && ctxt->wellFormed && ctxt->myDoc &&
  ------------------
  |  Branch (10407:9): [True: 3.50k, False: 25.3k]
  |  Branch (10407:27): [True: 3.47k, False: 36]
  |  Branch (10407:47): [True: 3.47k, False: 0]
  ------------------
10408|  28.8k|        ctxt->node && (ctxt->node == ctxt->myDoc->children))
  ------------------
  |  Branch (10408:9): [True: 3.47k, False: 0]
  |  Branch (10408:23): [True: 0, False: 3.47k]
  ------------------
10409|      0|        ctxt->valid &= xmlValidateRoot(&ctxt->vctxt, ctxt->myDoc);
10410|  28.8k|#endif /* LIBXML_VALID_ENABLED */
10411|       |
10412|       |    /*
10413|       |     * Check for an Empty Element.
10414|       |     */
10415|  28.8k|    if ((RAW == '/') && (NXT(1) == '>')) {
  ------------------
  |  | 2221|  28.8k|#define RAW (*ctxt->input->cur)
  ------------------
                  if ((RAW == '/') && (NXT(1) == '>')) {
  ------------------
  |  | 2223|  20.4k|#define NXT(val) ctxt->input->cur[(val)]
  ------------------
  |  Branch (10415:9): [True: 20.4k, False: 8.40k]
  |  Branch (10415:25): [True: 20.4k, False: 0]
  ------------------
10416|  20.4k|        SKIP(2);
  ------------------
  |  | 2245|  20.4k|#define SKIP(val) do {							\
  |  | 2246|  20.4k|    ctxt->input->cur += (val),ctxt->input->col+=(val);			\
  |  | 2247|  20.4k|    if (*ctxt->input->cur == 0)						\
  |  |  ------------------
  |  |  |  Branch (2247:9): [True: 30, False: 20.4k]
  |  |  ------------------
  |  | 2248|  20.4k|        xmlParserGrow(ctxt);						\
  |  | 2249|  20.4k|  } while (0)
  |  |  ------------------
  |  |  |  Branch (2249:12): [Folded - Ignored]
  |  |  ------------------
  ------------------
10417|  20.4k|	if (ctxt->sax2) {
  ------------------
  |  Branch (10417:6): [True: 20.4k, False: 0]
  ------------------
10418|  20.4k|	    if ((ctxt->sax != NULL) && (ctxt->sax->endElementNs != NULL) &&
  ------------------
  |  Branch (10418:10): [True: 20.4k, False: 0]
  |  Branch (10418:33): [True: 20.4k, False: 0]
  ------------------
10419|  20.4k|		(!ctxt->disableSAX))
  ------------------
  |  Branch (10419:3): [True: 20.3k, False: 104]
  ------------------
10420|  20.3k|		ctxt->sax->endElementNs(ctxt->userData, name, prefix, URI);
10421|  20.4k|#ifdef LIBXML_SAX1_ENABLED
10422|  20.4k|	} else {
10423|      0|	    if ((ctxt->sax != NULL) && (ctxt->sax->endElement != NULL) &&
  ------------------
  |  Branch (10423:10): [True: 0, False: 0]
  |  Branch (10423:33): [True: 0, False: 0]
  ------------------
10424|      0|		(!ctxt->disableSAX))
  ------------------
  |  Branch (10424:3): [True: 0, False: 0]
  ------------------
10425|      0|		ctxt->sax->endElement(ctxt->userData, name);
10426|      0|#endif /* LIBXML_SAX1_ENABLED */
10427|      0|	}
10428|  20.4k|	namePop(ctxt);
10429|  20.4k|	spacePop(ctxt);
10430|  20.4k|	if (nbNs > 0)
  ------------------
  |  Branch (10430:6): [True: 30, False: 20.4k]
  ------------------
10431|     30|	    xmlParserNsPop(ctxt, nbNs);
10432|  20.4k|	if (cur != NULL && ctxt->record_info) {
  ------------------
  |  Branch (10432:6): [True: 20.4k, False: 4]
  |  Branch (10432:21): [True: 0, False: 20.4k]
  ------------------
10433|      0|            node_info.node = cur;
10434|      0|            node_info.end_pos = ctxt->input->consumed +
10435|      0|                                (CUR_PTR - ctxt->input->base);
  ------------------
  |  | 2224|      0|#define CUR_PTR ctxt->input->cur
  ------------------
10436|      0|            node_info.end_line = ctxt->input->line;
10437|      0|            xmlParserAddNodeInfo(ctxt, &node_info);
10438|      0|	}
10439|  20.4k|	return(1);
10440|  20.4k|    }
10441|  8.40k|    if (RAW == '>') {
  ------------------
  |  | 2221|  8.40k|#define RAW (*ctxt->input->cur)
  ------------------
  |  Branch (10441:9): [True: 8.38k, False: 14]
  ------------------
10442|  8.38k|        NEXT1;
  ------------------
  |  | 2277|  8.38k|#define NEXT1 {								\
  |  | 2278|  8.38k|	ctxt->input->col++;						\
  |  | 2279|  8.38k|	ctxt->input->cur++;						\
  |  | 2280|  8.38k|	if (*ctxt->input->cur == 0)					\
  |  |  ------------------
  |  |  |  Branch (2280:6): [True: 2, False: 8.38k]
  |  |  ------------------
  |  | 2281|  8.38k|	    xmlParserGrow(ctxt);						\
  |  | 2282|  8.38k|    }
  ------------------
10443|  8.38k|        if (cur != NULL && ctxt->record_info) {
  ------------------
  |  Branch (10443:13): [True: 8.38k, False: 0]
  |  Branch (10443:28): [True: 0, False: 8.38k]
  ------------------
10444|      0|            node_info.node = cur;
10445|      0|            node_info.end_pos = 0;
10446|      0|            node_info.end_line = 0;
10447|      0|            xmlParserAddNodeInfo(ctxt, &node_info);
10448|      0|        }
10449|  8.38k|    } else {
10450|     14|        xmlFatalErrMsgStrIntStr(ctxt, XML_ERR_GT_REQUIRED,
10451|     14|		     "Couldn't find end of Start Tag %s line %d\n",
10452|     14|		                name, line, NULL);
10453|       |
10454|       |	/*
10455|       |	 * end of parsing of this node.
10456|       |	 */
10457|     14|	nodePop(ctxt);
10458|     14|	namePop(ctxt);
10459|     14|	spacePop(ctxt);
10460|     14|	if (nbNs > 0)
  ------------------
  |  Branch (10460:6): [True: 2, False: 12]
  ------------------
10461|      2|	    xmlParserNsPop(ctxt, nbNs);
10462|     14|	return(-1);
10463|     14|    }
10464|       |
10465|  8.38k|    return(0);
10466|  8.40k|}
parser.c:spacePush:
 2154|  57.5k|static int spacePush(xmlParserCtxtPtr ctxt, int val) {
 2155|  57.5k|    if (ctxt->spaceNr >= ctxt->spaceMax) {
  ------------------
  |  Branch (2155:9): [True: 8, False: 57.5k]
  ------------------
 2156|      8|        int *tmp;
 2157|       |
 2158|      8|	ctxt->spaceMax *= 2;
 2159|      8|        tmp = (int *) xmlRealloc(ctxt->spaceTab,
 2160|      8|	                         ctxt->spaceMax * sizeof(ctxt->spaceTab[0]));
 2161|      8|        if (tmp == NULL) {
  ------------------
  |  Branch (2161:13): [True: 0, False: 8]
  ------------------
 2162|      0|	    xmlErrMemory(ctxt, NULL);
 2163|      0|	    ctxt->spaceMax /=2;
 2164|      0|	    return(-1);
 2165|      0|	}
 2166|      8|	ctxt->spaceTab = tmp;
 2167|      8|    }
 2168|  57.5k|    ctxt->spaceTab[ctxt->spaceNr] = val;
 2169|  57.5k|    ctxt->space = &ctxt->spaceTab[ctxt->spaceNr];
 2170|  57.5k|    return(ctxt->spaceNr++);
 2171|  57.5k|}
parser.c:xmlParseStartTag2:
 9471|  57.5k|                  const xmlChar **URI, int *nbNsPtr) {
 9472|  57.5k|    xmlHashedString hlocalname;
 9473|  57.5k|    xmlHashedString hprefix;
 9474|  57.5k|    xmlHashedString hattname;
 9475|  57.5k|    xmlHashedString haprefix;
 9476|  57.5k|    const xmlChar *localname;
 9477|  57.5k|    const xmlChar *prefix;
 9478|  57.5k|    const xmlChar *attname;
 9479|  57.5k|    const xmlChar *aprefix;
 9480|  57.5k|    const xmlChar *uri;
 9481|  57.5k|    xmlChar *attvalue = NULL;
 9482|  57.5k|    const xmlChar **atts = ctxt->atts;
 9483|  57.5k|    unsigned attrHashSize = 0;
 9484|  57.5k|    int maxatts = ctxt->maxatts;
 9485|  57.5k|    int nratts, nbatts, nbdef, inputid;
 9486|  57.5k|    int i, j, nbNs, nbTotalDef, attval, nsIndex, maxAtts;
 9487|  57.5k|    int alloc = 0;
 9488|       |
 9489|  57.5k|    if (RAW != '<') return(NULL);
  ------------------
  |  | 2221|  57.5k|#define RAW (*ctxt->input->cur)
  ------------------
  |  Branch (9489:9): [True: 0, False: 57.5k]
  ------------------
 9490|  57.5k|    NEXT1;
  ------------------
  |  | 2277|  57.5k|#define NEXT1 {								\
  |  | 2278|  57.5k|	ctxt->input->col++;						\
  |  | 2279|  57.5k|	ctxt->input->cur++;						\
  |  | 2280|  57.5k|	if (*ctxt->input->cur == 0)					\
  |  |  ------------------
  |  |  |  Branch (2280:6): [True: 4, False: 57.5k]
  |  |  ------------------
  |  | 2281|  57.5k|	    xmlParserGrow(ctxt);						\
  |  | 2282|  57.5k|    }
  ------------------
 9491|       |
 9492|  57.5k|    inputid = ctxt->input->id;
 9493|  57.5k|    nbatts = 0;
 9494|  57.5k|    nratts = 0;
 9495|  57.5k|    nbdef = 0;
 9496|  57.5k|    nbNs = 0;
 9497|  57.5k|    nbTotalDef = 0;
 9498|  57.5k|    attval = 0;
 9499|       |
 9500|  57.5k|    if (xmlParserNsStartElement(ctxt->nsdb) < 0) {
  ------------------
  |  Branch (9500:9): [True: 0, False: 57.5k]
  ------------------
 9501|      0|        xmlErrMemory(ctxt, NULL);
 9502|      0|        return(NULL);
 9503|      0|    }
 9504|       |
 9505|  57.5k|    hlocalname = xmlParseQNameHashed(ctxt, &hprefix);
 9506|  57.5k|    if (hlocalname.name == NULL) {
  ------------------
  |  Branch (9506:9): [True: 36, False: 57.5k]
  ------------------
 9507|     36|	xmlFatalErrMsg(ctxt, XML_ERR_NAME_REQUIRED,
 9508|     36|		       "StartTag: invalid element name\n");
 9509|     36|        return(NULL);
 9510|     36|    }
 9511|  57.5k|    localname = hlocalname.name;
 9512|  57.5k|    prefix = hprefix.name;
 9513|       |
 9514|       |    /*
 9515|       |     * Now parse the attributes, it ends up with the ending
 9516|       |     *
 9517|       |     * (S Attribute)* S?
 9518|       |     */
 9519|  57.5k|    SKIP_BLANKS;
  ------------------
  |  | 2273|  57.5k|#define SKIP_BLANKS xmlSkipBlankChars(ctxt)
  ------------------
 9520|  57.5k|    GROW;
  ------------------
  |  | 2270|  57.5k|#define GROW if (ctxt->input->end - ctxt->input->cur < INPUT_CHUNK)	\
  |  |  ------------------
  |  |  |  |   97|  57.5k|#define INPUT_CHUNK	250
  |  |  ------------------
  |  |  |  Branch (2270:18): [True: 21.9k, False: 35.5k]
  |  |  ------------------
  |  | 2271|  57.5k|	xmlParserGrow(ctxt);
  ------------------
 9521|       |
 9522|       |    /*
 9523|       |     * The ctxt->atts array will be ultimately passed to the SAX callback
 9524|       |     * containing five xmlChar pointers for each attribute:
 9525|       |     *
 9526|       |     * [0] attribute name
 9527|       |     * [1] attribute prefix
 9528|       |     * [2] namespace URI
 9529|       |     * [3] attribute value
 9530|       |     * [4] end of attribute value
 9531|       |     *
 9532|       |     * To save memory, we reuse this array temporarily and store integers
 9533|       |     * in these pointer variables.
 9534|       |     *
 9535|       |     * [0] attribute name
 9536|       |     * [1] attribute prefix
 9537|       |     * [2] hash value of attribute prefix, and later namespace index
 9538|       |     * [3] for non-allocated values: ptrdiff_t offset into input buffer
 9539|       |     * [4] for non-allocated values: ptrdiff_t offset into input buffer
 9540|       |     *
 9541|       |     * The ctxt->attallocs array contains an additional unsigned int for
 9542|       |     * each attribute, containing the hash value of the attribute name
 9543|       |     * and the alloc flag in bit 31.
 9544|       |     */
 9545|       |
 9546|   111k|    while (((RAW != '>') &&
  ------------------
  |  | 2221|   111k|#define RAW (*ctxt->input->cur)
  ------------------
  |  Branch (9546:13): [True: 101k, False: 10.1k]
  ------------------
 9547|   111k|	   ((RAW != '/') || (NXT(1) != '>')) &&
  ------------------
  |  | 2221|   101k|#define RAW (*ctxt->input->cur)
  ------------------
              	   ((RAW != '/') || (NXT(1) != '>')) &&
  ------------------
  |  | 2223|  1.05k|#define NXT(val) ctxt->input->cur[(val)]
  ------------------
  |  Branch (9547:6): [True: 100k, False: 1.05k]
  |  Branch (9547:22): [True: 0, False: 1.05k]
  ------------------
 9548|   111k|	   (IS_BYTE_CHAR(RAW))) && (ctxt->instate != XML_PARSER_EOF)) {
  ------------------
  |  |  113|   100k|#define IS_BYTE_CHAR(c)	 xmlIsChar_ch(c)
  |  |  ------------------
  |  |  |  |  108|   100k|#define xmlIsChar_ch(c)		(((0x9 <= (c)) && ((c) <= 0xa)) || \
  |  |  |  |  ------------------
  |  |  |  |  |  Branch (108:28): [True: 100k, False: 10]
  |  |  |  |  |  Branch (108:44): [True: 0, False: 100k]
  |  |  |  |  ------------------
  |  |  |  |  109|   100k|				 ((c) == 0xd) || \
  |  |  |  |  ------------------
  |  |  |  |  |  Branch (109:6): [True: 0, False: 100k]
  |  |  |  |  ------------------
  |  |  |  |  110|   100k|				  (0x20 <= (c)))
  |  |  |  |  ------------------
  |  |  |  |  |  Branch (110:7): [True: 100k, False: 10]
  |  |  |  |  ------------------
  |  |  ------------------
  ------------------
  |  Branch (9548:29): [True: 100k, False: 0]
  ------------------
 9549|   100k|	int len = -1;
 9550|       |
 9551|   100k|	hattname = xmlParseAttribute2(ctxt, prefix, localname,
 9552|   100k|                                          &haprefix, &attvalue, &len,
 9553|   100k|                                          &alloc);
 9554|   100k|        if (hattname.name == NULL) {
  ------------------
  |  Branch (9554:13): [True: 16, False: 100k]
  ------------------
 9555|     16|	    xmlFatalErr(ctxt, XML_ERR_INTERNAL_ERROR,
 9556|     16|	         "xmlParseStartTag: problem parsing attributes\n");
 9557|     16|	    break;
 9558|     16|	}
 9559|   100k|        if (attvalue == NULL)
  ------------------
  |  Branch (9559:13): [True: 4, False: 100k]
  ------------------
 9560|      4|            goto next_attr;
 9561|   100k|        attname = hattname.name;
 9562|   100k|        aprefix = haprefix.name;
 9563|   100k|	if (len < 0) len = xmlStrlen(attvalue);
  ------------------
  |  Branch (9563:6): [True: 0, False: 100k]
  ------------------
 9564|       |
 9565|   100k|        if ((attname == ctxt->str_xmlns) && (aprefix == NULL)) {
  ------------------
  |  Branch (9565:13): [True: 120, False: 100k]
  |  Branch (9565:45): [True: 120, False: 0]
  ------------------
 9566|    120|            xmlHashedString huri;
 9567|    120|            xmlURIPtr parsedUri;
 9568|       |
 9569|    120|            huri = xmlDictLookupHashed(ctxt->dict, attvalue, len);
 9570|    120|            uri = huri.name;
 9571|    120|            if (uri == NULL) {
  ------------------
  |  Branch (9571:17): [True: 0, False: 120]
  ------------------
 9572|      0|                xmlErrMemory(ctxt, NULL);
 9573|      0|                goto next_attr;
 9574|      0|            }
 9575|    120|            if (*uri != 0) {
  ------------------
  |  Branch (9575:17): [True: 120, False: 0]
  ------------------
 9576|    120|                parsedUri = xmlParseURI((const char *) uri);
 9577|    120|                if (parsedUri == NULL) {
  ------------------
  |  Branch (9577:21): [True: 0, False: 120]
  ------------------
 9578|      0|                    xmlNsErr(ctxt, XML_WAR_NS_URI,
 9579|      0|                             "xmlns: '%s' is not a valid URI\n",
 9580|      0|                                       uri, NULL, NULL);
 9581|    120|                } else {
 9582|    120|                    if (parsedUri->scheme == NULL) {
  ------------------
  |  Branch (9582:25): [True: 4, False: 116]
  ------------------
 9583|      4|                        xmlNsWarn(ctxt, XML_WAR_NS_URI_RELATIVE,
 9584|      4|                                  "xmlns: URI %s is not absolute\n",
 9585|      4|                                  uri, NULL, NULL);
 9586|      4|                    }
 9587|    120|                    xmlFreeURI(parsedUri);
 9588|    120|                }
 9589|    120|                if (uri == ctxt->str_xml_ns) {
  ------------------
  |  Branch (9589:21): [True: 0, False: 120]
  ------------------
 9590|      0|                    if (attname != ctxt->str_xml) {
  ------------------
  |  Branch (9590:25): [True: 0, False: 0]
  ------------------
 9591|      0|                        xmlNsErr(ctxt, XML_NS_ERR_XML_NAMESPACE,
 9592|      0|                     "xml namespace URI cannot be the default namespace\n",
 9593|      0|                                 NULL, NULL, NULL);
 9594|      0|                    }
 9595|      0|                    goto next_attr;
 9596|      0|                }
 9597|    120|                if ((len == 29) &&
  ------------------
  |  Branch (9597:21): [True: 0, False: 120]
  ------------------
 9598|    120|                    (xmlStrEqual(uri,
  ------------------
  |  Branch (9598:21): [True: 0, False: 0]
  ------------------
 9599|      0|                             BAD_CAST "http://www.w3.org/2000/xmlns/"))) {
  ------------------
  |  |   35|      0|#define BAD_CAST (xmlChar *)
  ------------------
 9600|      0|                    xmlNsErr(ctxt, XML_NS_ERR_XML_NAMESPACE,
 9601|      0|                         "reuse of the xmlns namespace name is forbidden\n",
 9602|      0|                             NULL, NULL, NULL);
 9603|      0|                    goto next_attr;
 9604|      0|                }
 9605|    120|            }
 9606|       |
 9607|    120|            if (xmlParserNsPush(ctxt, NULL, &huri, NULL, 0) > 0)
  ------------------
  |  Branch (9607:17): [True: 116, False: 4]
  ------------------
 9608|    116|                nbNs++;
 9609|   100k|        } else if (aprefix == ctxt->str_xmlns) {
  ------------------
  |  Branch (9609:20): [True: 292, False: 100k]
  ------------------
 9610|    292|            xmlHashedString huri;
 9611|    292|            xmlURIPtr parsedUri;
 9612|       |
 9613|    292|            huri = xmlDictLookupHashed(ctxt->dict, attvalue, len);
 9614|    292|            uri = huri.name;
 9615|    292|            if (uri == NULL) {
  ------------------
  |  Branch (9615:17): [True: 0, False: 292]
  ------------------
 9616|      0|                xmlErrMemory(ctxt, NULL);
 9617|      0|                goto next_attr;
 9618|      0|            }
 9619|       |
 9620|    292|            if (attname == ctxt->str_xml) {
  ------------------
  |  Branch (9620:17): [True: 4, False: 288]
  ------------------
 9621|      4|                if (uri != ctxt->str_xml_ns) {
  ------------------
  |  Branch (9621:21): [True: 4, False: 0]
  ------------------
 9622|      4|                    xmlNsErr(ctxt, XML_NS_ERR_XML_NAMESPACE,
 9623|      4|                             "xml namespace prefix mapped to wrong URI\n",
 9624|      4|                             NULL, NULL, NULL);
 9625|      4|                }
 9626|       |                /*
 9627|       |                 * Do not keep a namespace definition node
 9628|       |                 */
 9629|      4|                goto next_attr;
 9630|      4|            }
 9631|    288|            if (uri == ctxt->str_xml_ns) {
  ------------------
  |  Branch (9631:17): [True: 0, False: 288]
  ------------------
 9632|      0|                if (attname != ctxt->str_xml) {
  ------------------
  |  Branch (9632:21): [True: 0, False: 0]
  ------------------
 9633|      0|                    xmlNsErr(ctxt, XML_NS_ERR_XML_NAMESPACE,
 9634|      0|                             "xml namespace URI mapped to wrong prefix\n",
 9635|      0|                             NULL, NULL, NULL);
 9636|      0|                }
 9637|      0|                goto next_attr;
 9638|      0|            }
 9639|    288|            if (attname == ctxt->str_xmlns) {
  ------------------
  |  Branch (9639:17): [True: 0, False: 288]
  ------------------
 9640|      0|                xmlNsErr(ctxt, XML_NS_ERR_XML_NAMESPACE,
 9641|      0|                         "redefinition of the xmlns prefix is forbidden\n",
 9642|      0|                         NULL, NULL, NULL);
 9643|      0|                goto next_attr;
 9644|      0|            }
 9645|    288|            if ((len == 29) &&
  ------------------
  |  Branch (9645:17): [True: 8, False: 280]
  ------------------
 9646|    288|                (xmlStrEqual(uri,
  ------------------
  |  Branch (9646:17): [True: 0, False: 8]
  ------------------
 9647|      8|                             BAD_CAST "http://www.w3.org/2000/xmlns/"))) {
  ------------------
  |  |   35|      8|#define BAD_CAST (xmlChar *)
  ------------------
 9648|      0|                xmlNsErr(ctxt, XML_NS_ERR_XML_NAMESPACE,
 9649|      0|                         "reuse of the xmlns namespace name is forbidden\n",
 9650|      0|                         NULL, NULL, NULL);
 9651|      0|                goto next_attr;
 9652|      0|            }
 9653|    288|            if ((uri == NULL) || (uri[0] == 0)) {
  ------------------
  |  Branch (9653:17): [True: 0, False: 288]
  |  Branch (9653:34): [True: 0, False: 288]
  ------------------
 9654|      0|                xmlNsErr(ctxt, XML_NS_ERR_XML_NAMESPACE,
 9655|      0|                         "xmlns:%s: Empty XML namespace is not allowed\n",
 9656|      0|                              attname, NULL, NULL);
 9657|      0|                goto next_attr;
 9658|    288|            } else {
 9659|    288|                parsedUri = xmlParseURI((const char *) uri);
 9660|    288|                if (parsedUri == NULL) {
  ------------------
  |  Branch (9660:21): [True: 0, False: 288]
  ------------------
 9661|      0|                    xmlNsErr(ctxt, XML_WAR_NS_URI,
 9662|      0|                         "xmlns:%s: '%s' is not a valid URI\n",
 9663|      0|                                       attname, uri, NULL);
 9664|    288|                } else {
 9665|    288|                    if ((ctxt->pedantic) && (parsedUri->scheme == NULL)) {
  ------------------
  |  Branch (9665:25): [True: 0, False: 288]
  |  Branch (9665:45): [True: 0, False: 0]
  ------------------
 9666|      0|                        xmlNsWarn(ctxt, XML_WAR_NS_URI_RELATIVE,
 9667|      0|                                  "xmlns:%s: URI %s is not absolute\n",
 9668|      0|                                  attname, uri, NULL);
 9669|      0|                    }
 9670|    288|                    xmlFreeURI(parsedUri);
 9671|    288|                }
 9672|    288|            }
 9673|       |
 9674|    288|            if (xmlParserNsPush(ctxt, &hattname, &huri, NULL, 0) > 0)
  ------------------
  |  Branch (9674:17): [True: 284, False: 4]
  ------------------
 9675|    284|                nbNs++;
 9676|   100k|        } else {
 9677|       |            /*
 9678|       |             * Populate attributes array, see above for repurposing
 9679|       |             * of xmlChar pointers.
 9680|       |             */
 9681|   100k|            if ((atts == NULL) || (nbatts + 5 > maxatts)) {
  ------------------
  |  Branch (9681:17): [True: 488, False: 99.5k]
  |  Branch (9681:35): [True: 16, False: 99.5k]
  ------------------
 9682|    504|                if (xmlCtxtGrowAttrs(ctxt, nbatts + 5) < 0) {
  ------------------
  |  Branch (9682:21): [True: 0, False: 504]
  ------------------
 9683|      0|                    goto next_attr;
 9684|      0|                }
 9685|    504|                maxatts = ctxt->maxatts;
 9686|    504|                atts = ctxt->atts;
 9687|    504|            }
 9688|   100k|            ctxt->attallocs[nratts++] = (hattname.hashValue & 0x7FFFFFFF) |
 9689|   100k|                                        ((unsigned) alloc << 31);
 9690|   100k|            atts[nbatts++] = attname;
 9691|   100k|            atts[nbatts++] = aprefix;
 9692|   100k|            atts[nbatts++] = (const xmlChar *) (size_t) haprefix.hashValue;
 9693|   100k|            if (alloc) {
  ------------------
  |  Branch (9693:17): [True: 466, False: 99.5k]
  ------------------
 9694|    466|                atts[nbatts++] = attvalue;
 9695|    466|                attvalue += len;
 9696|    466|                atts[nbatts++] = attvalue;
 9697|  99.5k|            } else {
 9698|       |                /*
 9699|       |                 * attvalue points into the input buffer which can be
 9700|       |                 * reallocated. Store differences to input->base instead.
 9701|       |                 * The pointers will be reconstructed later.
 9702|       |                 */
 9703|  99.5k|                atts[nbatts++] = (void *) (attvalue - BASE_PTR);
  ------------------
  |  | 2225|  99.5k|#define BASE_PTR ctxt->input->base
  ------------------
 9704|  99.5k|                attvalue += len;
 9705|  99.5k|                atts[nbatts++] = (void *) (attvalue - BASE_PTR);
  ------------------
  |  | 2225|  99.5k|#define BASE_PTR ctxt->input->base
  ------------------
 9706|  99.5k|            }
 9707|       |            /*
 9708|       |             * tag if some deallocation is needed
 9709|       |             */
 9710|   100k|            if (alloc != 0) attval = 1;
  ------------------
  |  Branch (9710:17): [True: 466, False: 99.5k]
  ------------------
 9711|   100k|            attvalue = NULL; /* moved into atts */
 9712|   100k|        }
 9713|       |
 9714|   100k|next_attr:
 9715|   100k|        if ((attvalue != NULL) && (alloc != 0)) {
  ------------------
  |  Branch (9715:13): [True: 412, False: 100k]
  |  Branch (9715:35): [True: 0, False: 412]
  ------------------
 9716|      0|            xmlFree(attvalue);
 9717|      0|            attvalue = NULL;
 9718|      0|        }
 9719|       |
 9720|   100k|	GROW
  ------------------
  |  | 2270|   100k|#define GROW if (ctxt->input->end - ctxt->input->cur < INPUT_CHUNK)	\
  |  |  ------------------
  |  |  |  |   97|   100k|#define INPUT_CHUNK	250
  |  |  ------------------
  |  |  |  Branch (2270:18): [True: 32.5k, False: 67.9k]
  |  |  ------------------
  |  | 2271|   100k|	xmlParserGrow(ctxt);
  ------------------
 9721|   100k|        if (ctxt->instate == XML_PARSER_EOF)
  ------------------
  |  Branch (9721:13): [True: 0, False: 100k]
  ------------------
 9722|      0|            break;
 9723|   100k|	if ((RAW == '>') || (((RAW == '/') && (NXT(1) == '>'))))
  ------------------
  |  | 2221|   100k|#define RAW (*ctxt->input->cur)
  ------------------
              	if ((RAW == '>') || (((RAW == '/') && (NXT(1) == '>'))))
  ------------------
  |  | 2221|  93.9k|#define RAW (*ctxt->input->cur)
  ------------------
              	if ((RAW == '>') || (((RAW == '/') && (NXT(1) == '>'))))
  ------------------
  |  | 2223|  39.7k|#define NXT(val) ctxt->input->cur[(val)]
  ------------------
  |  Branch (9723:6): [True: 6.56k, False: 93.9k]
  |  Branch (9723:24): [True: 39.7k, False: 54.1k]
  |  Branch (9723:40): [True: 39.7k, False: 0]
  ------------------
 9724|  46.3k|	    break;
 9725|  54.1k|	if (SKIP_BLANKS == 0) {
  ------------------
  |  | 2273|  54.1k|#define SKIP_BLANKS xmlSkipBlankChars(ctxt)
  ------------------
  |  Branch (9725:6): [True: 16, False: 54.1k]
  ------------------
 9726|     16|	    xmlFatalErrMsg(ctxt, XML_ERR_SPACE_REQUIRED,
 9727|     16|			   "attributes construct error\n");
 9728|     16|	    break;
 9729|     16|	}
 9730|  54.1k|        GROW;
  ------------------
  |  | 2270|  54.1k|#define GROW if (ctxt->input->end - ctxt->input->cur < INPUT_CHUNK)	\
  |  |  ------------------
  |  |  |  |   97|  54.1k|#define INPUT_CHUNK	250
  |  |  ------------------
  |  |  |  Branch (2270:18): [True: 14.6k, False: 39.4k]
  |  |  ------------------
  |  | 2271|  54.1k|	xmlParserGrow(ctxt);
  ------------------
 9731|  54.1k|    }
 9732|       |
 9733|  57.5k|    if (ctxt->input->id != inputid) {
  ------------------
  |  Branch (9733:9): [True: 0, False: 57.5k]
  ------------------
 9734|      0|        xmlFatalErr(ctxt, XML_ERR_INTERNAL_ERROR,
 9735|      0|                    "Unexpected change of input\n");
 9736|      0|        localname = NULL;
 9737|      0|        goto done;
 9738|      0|    }
 9739|       |
 9740|       |    /*
 9741|       |     * Namespaces from default attributes
 9742|       |     */
 9743|  57.5k|    if (ctxt->attsDefault != NULL) {
  ------------------
  |  Branch (9743:9): [True: 12.2k, False: 45.2k]
  ------------------
 9744|  12.2k|        xmlDefAttrsPtr defaults;
 9745|       |
 9746|  12.2k|	defaults = xmlHashLookup2(ctxt->attsDefault, localname, prefix);
 9747|  12.2k|	if (defaults != NULL) {
  ------------------
  |  Branch (9747:6): [True: 1.48k, False: 10.7k]
  ------------------
 9748|   164k|	    for (i = 0; i < defaults->nbAttrs; i++) {
  ------------------
  |  Branch (9748:18): [True: 163k, False: 1.48k]
  ------------------
 9749|   163k|                xmlDefAttr *attr = &defaults->attrs[i];
 9750|       |
 9751|   163k|	        attname = attr->name.name;
 9752|   163k|		aprefix = attr->prefix.name;
 9753|       |
 9754|   163k|		if ((attname == ctxt->str_xmlns) && (aprefix == NULL)) {
  ------------------
  |  Branch (9754:7): [True: 8, False: 163k]
  |  Branch (9754:39): [True: 8, False: 0]
  ------------------
 9755|      8|                    xmlParserEntityCheck(ctxt, attr->expandedSize);
 9756|       |
 9757|      8|                    if (xmlParserNsPush(ctxt, NULL, &attr->value, NULL, 1) > 0)
  ------------------
  |  Branch (9757:25): [True: 4, False: 4]
  ------------------
 9758|      4|                        nbNs++;
 9759|   163k|		} else if (aprefix == ctxt->str_xmlns) {
  ------------------
  |  Branch (9759:14): [True: 28, False: 162k]
  ------------------
 9760|     28|                    xmlParserEntityCheck(ctxt, attr->expandedSize);
 9761|       |
 9762|     28|                    if (xmlParserNsPush(ctxt, &attr->name, &attr->value,
  ------------------
  |  Branch (9762:25): [True: 16, False: 12]
  ------------------
 9763|     28|                                      NULL, 1) > 0)
 9764|     16|                        nbNs++;
 9765|   162k|		} else {
 9766|   162k|                    nbTotalDef += 1;
 9767|   162k|                }
 9768|   163k|	    }
 9769|  1.48k|	}
 9770|  12.2k|    }
 9771|       |
 9772|       |    /*
 9773|       |     * Resolve attribute namespaces
 9774|       |     */
 9775|   157k|    for (i = 0; i < nbatts; i += 5) {
  ------------------
  |  Branch (9775:17): [True: 100k, False: 57.5k]
  ------------------
 9776|   100k|        attname = atts[i];
 9777|   100k|        aprefix = atts[i+1];
 9778|       |
 9779|       |        /*
 9780|       |	* The default namespace does not apply to attribute names.
 9781|       |	*/
 9782|   100k|	if (aprefix == NULL) {
  ------------------
  |  Branch (9782:6): [True: 88.3k, False: 11.7k]
  ------------------
 9783|  88.3k|            nsIndex = NS_INDEX_EMPTY;
  ------------------
  |  |   77|  88.3k|#define NS_INDEX_EMPTY  INT_MAX
  ------------------
 9784|  88.3k|        } else if (aprefix == ctxt->str_xml) {
  ------------------
  |  Branch (9784:20): [True: 60, False: 11.6k]
  ------------------
 9785|     60|            nsIndex = NS_INDEX_XML;
  ------------------
  |  |   78|     60|#define NS_INDEX_XML    (INT_MAX - 1)
  ------------------
 9786|  11.6k|        } else {
 9787|  11.6k|            haprefix.name = aprefix;
 9788|  11.6k|            haprefix.hashValue = (size_t) atts[i+2];
 9789|  11.6k|            nsIndex = xmlParserNsLookup(ctxt, &haprefix, NULL);
 9790|  11.6k|	    if (nsIndex == INT_MAX) {
  ------------------
  |  Branch (9790:10): [True: 0, False: 11.6k]
  ------------------
 9791|      0|                xmlNsErr(ctxt, XML_NS_ERR_UNDEFINED_NAMESPACE,
 9792|      0|		    "Namespace prefix %s for %s on %s is not defined\n",
 9793|      0|		    aprefix, attname, localname);
 9794|      0|                nsIndex = NS_INDEX_EMPTY;
  ------------------
  |  |   77|      0|#define NS_INDEX_EMPTY  INT_MAX
  ------------------
 9795|      0|            }
 9796|  11.6k|        }
 9797|       |
 9798|   100k|        atts[i+2] = (const xmlChar *) (ptrdiff_t) nsIndex;
 9799|   100k|    }
 9800|       |
 9801|       |    /*
 9802|       |     * Maximum number of attributes including default attributes.
 9803|       |     */
 9804|  57.5k|    maxAtts = nratts + nbTotalDef;
 9805|       |
 9806|       |    /*
 9807|       |     * Verify that attribute names are unique.
 9808|       |     */
 9809|  57.5k|    if (maxAtts > 1) {
  ------------------
  |  Branch (9809:9): [True: 39.4k, False: 18.1k]
  ------------------
 9810|  39.4k|        attrHashSize = 4;
 9811|  45.4k|        while (attrHashSize / 2 < (unsigned) maxAtts)
  ------------------
  |  Branch (9811:16): [True: 6.09k, False: 39.4k]
  ------------------
 9812|  6.09k|            attrHashSize *= 2;
 9813|       |
 9814|  39.4k|        if (attrHashSize > ctxt->attrHashMax) {
  ------------------
  |  Branch (9814:13): [True: 418, False: 38.9k]
  ------------------
 9815|    418|            xmlAttrHashBucket *tmp;
 9816|       |
 9817|    418|            tmp = xmlRealloc(ctxt->attrHash, attrHashSize * sizeof(tmp[0]));
 9818|    418|            if (tmp == NULL) {
  ------------------
  |  Branch (9818:17): [True: 0, False: 418]
  ------------------
 9819|      0|                xmlErrMemory(ctxt, NULL);
 9820|      0|                goto done;
 9821|      0|            }
 9822|       |
 9823|    418|            ctxt->attrHash = tmp;
 9824|    418|            ctxt->attrHashMax = attrHashSize;
 9825|    418|        }
 9826|       |
 9827|  39.4k|        memset(ctxt->attrHash, -1, attrHashSize * sizeof(ctxt->attrHash[0]));
 9828|       |
 9829|   131k|        for (i = 0, j = 0; j < nratts; i += 5, j++) {
  ------------------
  |  Branch (9829:28): [True: 92.4k, False: 39.4k]
  ------------------
 9830|  92.4k|            const xmlChar *nsuri;
 9831|  92.4k|            unsigned hashValue, nameHashValue, uriHashValue;
 9832|  92.4k|            int res;
 9833|       |
 9834|  92.4k|            attname = atts[i];
 9835|  92.4k|            aprefix = atts[i+1];
 9836|  92.4k|            nsIndex = (ptrdiff_t) atts[i+2];
 9837|       |            /* Hash values always have bit 31 set, see dict.c */
 9838|  92.4k|            nameHashValue = ctxt->attallocs[j] | 0x80000000;
 9839|       |
 9840|  92.4k|            if (nsIndex == NS_INDEX_EMPTY) {
  ------------------
  |  |   77|  92.4k|#define NS_INDEX_EMPTY  INT_MAX
  ------------------
  |  Branch (9840:17): [True: 81.0k, False: 11.4k]
  ------------------
 9841|  81.0k|                nsuri = NULL;
 9842|  81.0k|                uriHashValue = URI_HASH_EMPTY;
  ------------------
  |  |   79|  81.0k|#define URI_HASH_EMPTY  0xD943A04E
  ------------------
 9843|  81.0k|            } else if (nsIndex == NS_INDEX_XML) {
  ------------------
  |  |   78|  11.4k|#define NS_INDEX_XML    (INT_MAX - 1)
  ------------------
  |  Branch (9843:24): [True: 28, False: 11.4k]
  ------------------
 9844|     28|                nsuri = ctxt->str_xml_ns;
 9845|     28|                uriHashValue = URI_HASH_XML;
  ------------------
  |  |   80|     28|#define URI_HASH_XML    0xF0451F02
  ------------------
 9846|  11.4k|            } else {
 9847|  11.4k|                nsuri = ctxt->nsTab[nsIndex * 2 + 1];
 9848|  11.4k|                uriHashValue = ctxt->nsdb->extra[nsIndex].uriHashValue;
 9849|  11.4k|            }
 9850|       |
 9851|  92.4k|            hashValue = xmlDictCombineHash(nameHashValue, uriHashValue);
 9852|  92.4k|            res = xmlAttrHashInsert(ctxt, attrHashSize, attname, nsuri,
 9853|  92.4k|                                    hashValue, i);
 9854|  92.4k|            if (res < 0)
  ------------------
  |  Branch (9854:17): [True: 0, False: 92.4k]
  ------------------
 9855|      0|                continue;
 9856|       |
 9857|       |            /*
 9858|       |             * [ WFC: Unique Att Spec ]
 9859|       |             * No attribute name may appear more than once in the same
 9860|       |             * start-tag or empty-element tag.
 9861|       |             * As extended by the Namespace in XML REC.
 9862|       |             */
 9863|  92.4k|            if (res < INT_MAX) {
  ------------------
  |  Branch (9863:17): [True: 50, False: 92.4k]
  ------------------
 9864|     50|                if (aprefix == atts[res+1]) {
  ------------------
  |  Branch (9864:21): [True: 46, False: 4]
  ------------------
 9865|     46|                    xmlErrAttributeDup(ctxt, aprefix, attname);
 9866|     46|                } else {
 9867|      4|                    xmlNsErr(ctxt, XML_NS_ERR_ATTRIBUTE_REDEFINED,
 9868|      4|                             "Namespaced Attribute %s in '%s' redefined\n",
 9869|      4|                             attname, nsuri, NULL);
 9870|      4|                }
 9871|     50|            }
 9872|  92.4k|        }
 9873|  39.4k|    }
 9874|       |
 9875|       |    /*
 9876|       |     * Default attributes
 9877|       |     */
 9878|  57.5k|    if (ctxt->attsDefault != NULL) {
  ------------------
  |  Branch (9878:9): [True: 12.2k, False: 45.2k]
  ------------------
 9879|  12.2k|        xmlDefAttrsPtr defaults;
 9880|       |
 9881|  12.2k|	defaults = xmlHashLookup2(ctxt->attsDefault, localname, prefix);
 9882|  12.2k|	if (defaults != NULL) {
  ------------------
  |  Branch (9882:6): [True: 1.48k, False: 10.7k]
  ------------------
 9883|   164k|	    for (i = 0; i < defaults->nbAttrs; i++) {
  ------------------
  |  Branch (9883:18): [True: 163k, False: 1.48k]
  ------------------
 9884|   163k|                xmlDefAttr *attr = &defaults->attrs[i];
 9885|   163k|                const xmlChar *nsuri;
 9886|   163k|                unsigned hashValue, uriHashValue;
 9887|   163k|                int res;
 9888|       |
 9889|   163k|	        attname = attr->name.name;
 9890|   163k|		aprefix = attr->prefix.name;
 9891|       |
 9892|   163k|		if ((attname == ctxt->str_xmlns) && (aprefix == NULL))
  ------------------
  |  Branch (9892:7): [True: 8, False: 163k]
  |  Branch (9892:39): [True: 8, False: 0]
  ------------------
 9893|      8|                    continue;
 9894|   163k|		if (aprefix == ctxt->str_xmlns)
  ------------------
  |  Branch (9894:7): [True: 28, False: 162k]
  ------------------
 9895|     28|                    continue;
 9896|       |
 9897|   162k|                if (aprefix == NULL) {
  ------------------
  |  Branch (9897:21): [True: 162k, False: 392]
  ------------------
 9898|   162k|                    nsIndex = NS_INDEX_EMPTY;
  ------------------
  |  |   77|   162k|#define NS_INDEX_EMPTY  INT_MAX
  ------------------
 9899|   162k|                    nsuri = NULL;
 9900|   162k|                    uriHashValue = URI_HASH_EMPTY;
  ------------------
  |  |   79|   162k|#define URI_HASH_EMPTY  0xD943A04E
  ------------------
 9901|   162k|                } if (aprefix == ctxt->str_xml) {
  ------------------
  |  Branch (9901:23): [True: 384, False: 162k]
  ------------------
 9902|    384|                    nsIndex = NS_INDEX_XML;
  ------------------
  |  |   78|    384|#define NS_INDEX_XML    (INT_MAX - 1)
  ------------------
 9903|    384|                    nsuri = ctxt->str_xml_ns;
 9904|    384|                    uriHashValue = URI_HASH_XML;
  ------------------
  |  |   80|    384|#define URI_HASH_XML    0xF0451F02
  ------------------
 9905|   162k|                } else if (aprefix != NULL) {
  ------------------
  |  Branch (9905:28): [True: 8, False: 162k]
  ------------------
 9906|      8|                    nsIndex = xmlParserNsLookup(ctxt, &attr->prefix, NULL);
 9907|      8|                    if (nsIndex == INT_MAX) {
  ------------------
  |  Branch (9907:25): [True: 0, False: 8]
  ------------------
 9908|      0|                        xmlNsErr(ctxt, XML_NS_ERR_UNDEFINED_NAMESPACE,
 9909|      0|                                 "Namespace prefix %s for %s on %s is not "
 9910|      0|                                 "defined\n",
 9911|      0|                                 aprefix, attname, localname);
 9912|      0|                        nsIndex = NS_INDEX_EMPTY;
  ------------------
  |  |   77|      0|#define NS_INDEX_EMPTY  INT_MAX
  ------------------
 9913|      0|                        nsuri = NULL;
 9914|      0|                        uriHashValue = URI_HASH_EMPTY;
  ------------------
  |  |   79|      0|#define URI_HASH_EMPTY  0xD943A04E
  ------------------
 9915|      8|                    } else {
 9916|      8|                        nsuri = ctxt->nsTab[nsIndex * 2 + 1];
 9917|      8|                        uriHashValue = ctxt->nsdb->extra[nsIndex].uriHashValue;
 9918|      8|                    }
 9919|      8|                }
 9920|       |
 9921|       |                /*
 9922|       |                 * Check whether the attribute exists
 9923|       |                 */
 9924|   162k|                if (maxAtts > 1) {
  ------------------
  |  Branch (9924:21): [True: 162k, False: 204]
  ------------------
 9925|   162k|                    hashValue = xmlDictCombineHash(attr->name.hashValue,
 9926|   162k|                                                   uriHashValue);
 9927|   162k|                    res = xmlAttrHashInsert(ctxt, attrHashSize, attname, nsuri,
 9928|   162k|                                            hashValue, nbatts);
 9929|   162k|                    if (res < 0)
  ------------------
  |  Branch (9929:25): [True: 0, False: 162k]
  ------------------
 9930|      0|                        continue;
 9931|   162k|                    if (res < INT_MAX) {
  ------------------
  |  Branch (9931:25): [True: 44, False: 162k]
  ------------------
 9932|     44|                        if (aprefix == atts[res+1])
  ------------------
  |  Branch (9932:29): [True: 44, False: 0]
  ------------------
 9933|     44|                            continue;
 9934|      0|                        xmlNsErr(ctxt, XML_NS_ERR_ATTRIBUTE_REDEFINED,
 9935|      0|                                 "Namespaced Attribute %s in '%s' redefined\n",
 9936|      0|                                 attname, nsuri, NULL);
 9937|      0|                    }
 9938|   162k|                }
 9939|       |
 9940|   162k|                xmlParserEntityCheck(ctxt, attr->expandedSize);
 9941|       |
 9942|   162k|                if ((atts == NULL) || (nbatts + 5 > maxatts)) {
  ------------------
  |  Branch (9942:21): [True: 28, False: 162k]
  |  Branch (9942:39): [True: 20, False: 162k]
  ------------------
 9943|     48|                    if (xmlCtxtGrowAttrs(ctxt, nbatts + 5) < 0) {
  ------------------
  |  Branch (9943:25): [True: 0, False: 48]
  ------------------
 9944|      0|                        localname = NULL;
 9945|      0|                        goto done;
 9946|      0|                    }
 9947|     48|                    maxatts = ctxt->maxatts;
 9948|     48|                    atts = ctxt->atts;
 9949|     48|                }
 9950|       |
 9951|   162k|                atts[nbatts++] = attname;
 9952|   162k|                atts[nbatts++] = aprefix;
 9953|   162k|                atts[nbatts++] = (const xmlChar *) (ptrdiff_t) nsIndex;
 9954|   162k|                atts[nbatts++] = attr->value.name;
 9955|   162k|                atts[nbatts++] = attr->valueEnd;
 9956|   162k|                if ((ctxt->standalone == 1) && (attr->external != 0)) {
  ------------------
  |  Branch (9956:21): [True: 0, False: 162k]
  |  Branch (9956:48): [True: 0, False: 0]
  ------------------
 9957|      0|                    xmlValidityError(ctxt, XML_DTD_STANDALONE_DEFAULTED,
 9958|      0|                            "standalone: attribute %s on %s defaulted "
 9959|      0|                            "from external subset\n",
 9960|      0|                            attname, localname);
 9961|      0|                }
 9962|   162k|                nbdef++;
 9963|   162k|	    }
 9964|  1.48k|	}
 9965|  12.2k|    }
 9966|       |
 9967|       |    /*
 9968|       |     * Reconstruct attribute pointers
 9969|       |     */
 9970|   320k|    for (i = 0, j = 0; i < nbatts; i += 5, j++) {
  ------------------
  |  Branch (9970:24): [True: 262k, False: 57.5k]
  ------------------
 9971|       |        /* namespace URI */
 9972|   262k|        nsIndex = (ptrdiff_t) atts[i+2];
 9973|   262k|        if (nsIndex == INT_MAX)
  ------------------
  |  Branch (9973:13): [True: 250k, False: 12.1k]
  ------------------
 9974|   250k|            atts[i+2] = NULL;
 9975|  12.1k|        else if (nsIndex == INT_MAX - 1)
  ------------------
  |  Branch (9975:18): [True: 444, False: 11.6k]
  ------------------
 9976|    444|            atts[i+2] = ctxt->str_xml_ns;
 9977|  11.6k|        else
 9978|  11.6k|            atts[i+2] = ctxt->nsTab[nsIndex * 2 + 1];
 9979|       |
 9980|   262k|        if ((j < nratts) && (ctxt->attallocs[j] & 0x80000000) == 0) {
  ------------------
  |  Branch (9980:13): [True: 100k, False: 162k]
  |  Branch (9980:29): [True: 99.5k, False: 466]
  ------------------
 9981|  99.5k|            atts[i+3] = BASE_PTR + (ptrdiff_t) atts[i+3];  /* value */
  ------------------
  |  | 2225|  99.5k|#define BASE_PTR ctxt->input->base
  ------------------
 9982|  99.5k|            atts[i+4] = BASE_PTR + (ptrdiff_t) atts[i+4];  /* valuend */
  ------------------
  |  | 2225|  99.5k|#define BASE_PTR ctxt->input->base
  ------------------
 9983|  99.5k|        }
 9984|   262k|    }
 9985|       |
 9986|  57.5k|    uri = xmlParserNsLookupUri(ctxt, &hprefix);
 9987|  57.5k|    if ((prefix != NULL) && (uri == NULL)) {
  ------------------
  |  Branch (9987:9): [True: 1.89k, False: 55.6k]
  |  Branch (9987:29): [True: 12, False: 1.88k]
  ------------------
 9988|     12|	xmlNsErr(ctxt, XML_NS_ERR_UNDEFINED_NAMESPACE,
 9989|     12|	         "Namespace prefix %s on %s is not defined\n",
 9990|     12|		 prefix, localname, NULL);
 9991|     12|    }
 9992|  57.5k|    *pref = prefix;
 9993|  57.5k|    *URI = uri;
 9994|       |
 9995|       |    /*
 9996|       |     * SAX callback
 9997|       |     */
 9998|  57.5k|    if ((ctxt->sax != NULL) && (ctxt->sax->startElementNs != NULL) &&
  ------------------
  |  Branch (9998:9): [True: 57.5k, False: 0]
  |  Branch (9998:32): [True: 57.5k, False: 0]
  ------------------
 9999|  57.5k|	(!ctxt->disableSAX)) {
  ------------------
  |  Branch (9999:2): [True: 57.3k, False: 210]
  ------------------
10000|  57.3k|	if (nbNs > 0)
  ------------------
  |  Branch (10000:6): [True: 308, False: 57.0k]
  ------------------
10001|    308|	    ctxt->sax->startElementNs(ctxt->userData, localname, prefix, uri,
10002|    308|                          nbNs, ctxt->nsTab + 2 * (ctxt->nsNr - nbNs),
10003|    308|			  nbatts / 5, nbdef, atts);
10004|  57.0k|	else
10005|  57.0k|	    ctxt->sax->startElementNs(ctxt->userData, localname, prefix, uri,
10006|  57.0k|                          0, NULL, nbatts / 5, nbdef, atts);
10007|  57.3k|    }
10008|       |
10009|  57.5k|done:
10010|       |    /*
10011|       |     * Free allocated attribute values
10012|       |     */
10013|  57.5k|    if (attval != 0) {
  ------------------
  |  Branch (10013:9): [True: 446, False: 57.0k]
  ------------------
10014|  1.07k|	for (i = 0, j = 0; j < nratts; i += 5, j++)
  ------------------
  |  Branch (10014:21): [True: 624, False: 446]
  ------------------
10015|    624|	    if (ctxt->attallocs[j] & 0x80000000)
  ------------------
  |  Branch (10015:10): [True: 466, False: 158]
  ------------------
10016|    466|	        xmlFree((xmlChar *) atts[i+3]);
10017|    446|    }
10018|       |
10019|  57.5k|    *nbNsPtr = nbNs;
10020|  57.5k|    return(localname);
10021|  57.5k|}
parser.c:xmlParserNsStartElement:
 1462|  57.5k|xmlParserNsStartElement(xmlParserNsData *nsdb) {
 1463|  57.5k|    if (nsdb->elementId == UINT_MAX)
  ------------------
  |  Branch (1463:9): [True: 0, False: 57.5k]
  ------------------
 1464|      0|        return(-1);
 1465|  57.5k|    nsdb->elementId++;
 1466|       |
 1467|  57.5k|    return(0);
 1468|  57.5k|}
parser.c:xmlParseQNameHashed:
 8943|   158k|xmlParseQNameHashed(xmlParserCtxtPtr ctxt, xmlHashedString *prefix) {
 8944|   158k|    xmlHashedString l, p;
 8945|   158k|    int start;
 8946|       |
 8947|   158k|    l.name = NULL;
 8948|   158k|    p.name = NULL;
 8949|       |
 8950|   158k|    GROW;
  ------------------
  |  | 2270|   158k|#define GROW if (ctxt->input->end - ctxt->input->cur < INPUT_CHUNK)	\
  |  |  ------------------
  |  |  |  |   97|   158k|#define INPUT_CHUNK	250
  |  |  ------------------
  |  |  |  Branch (2270:18): [True: 53.2k, False: 104k]
  |  |  ------------------
  |  | 2271|   158k|	xmlParserGrow(ctxt);
  ------------------
 8951|   158k|    if (ctxt->instate == XML_PARSER_EOF)
  ------------------
  |  Branch (8951:9): [True: 0, False: 158k]
  ------------------
 8952|      0|        return(l);
 8953|   158k|    start = CUR_PTR - BASE_PTR;
  ------------------
  |  | 2224|   158k|#define CUR_PTR ctxt->input->cur
  ------------------
                  start = CUR_PTR - BASE_PTR;
  ------------------
  |  | 2225|   158k|#define BASE_PTR ctxt->input->base
  ------------------
 8954|       |
 8955|   158k|    l = xmlParseNCName(ctxt);
 8956|   158k|    if ((l.name != NULL) && (CUR == ':')) {
  ------------------
  |  | 2222|   158k|#define CUR (*ctxt->input->cur)
  ------------------
  |  Branch (8956:9): [True: 158k, False: 44]
  |  Branch (8956:29): [True: 13.9k, False: 144k]
  ------------------
 8957|  13.9k|        NEXT;
  ------------------
  |  | 2275|  13.9k|#define NEXT xmlNextChar(ctxt)
  ------------------
 8958|  13.9k|	p = l;
 8959|  13.9k|	l = xmlParseNCName(ctxt);
 8960|  13.9k|    }
 8961|   158k|    if ((l.name == NULL) || (CUR == ':')) {
  ------------------
  |  | 2222|   157k|#define CUR (*ctxt->input->cur)
  ------------------
  |  Branch (8961:9): [True: 52, False: 157k]
  |  Branch (8961:29): [True: 12, False: 157k]
  ------------------
 8962|     64|        xmlChar *tmp;
 8963|       |
 8964|     64|        l.name = NULL;
 8965|     64|        p.name = NULL;
 8966|     64|        if (ctxt->instate == XML_PARSER_EOF)
  ------------------
  |  Branch (8966:13): [True: 0, False: 64]
  ------------------
 8967|      0|            return(l);
 8968|     64|        if ((CUR != ':') && (CUR_PTR <= BASE_PTR + start))
  ------------------
  |  | 2222|     64|#define CUR (*ctxt->input->cur)
  ------------------
                      if ((CUR != ':') && (CUR_PTR <= BASE_PTR + start))
  ------------------
  |  | 2224|     44|#define CUR_PTR ctxt->input->cur
  ------------------
                      if ((CUR != ':') && (CUR_PTR <= BASE_PTR + start))
  ------------------
  |  | 2225|     44|#define BASE_PTR ctxt->input->base
  ------------------
  |  Branch (8968:13): [True: 44, False: 20]
  |  Branch (8968:29): [True: 36, False: 8]
  ------------------
 8969|     36|            return(l);
 8970|     28|        tmp = xmlParseNmtoken(ctxt);
 8971|     28|        if (tmp != NULL)
  ------------------
  |  Branch (8971:13): [True: 20, False: 8]
  ------------------
 8972|     20|            xmlFree(tmp);
 8973|     28|        if (ctxt->instate == XML_PARSER_EOF)
  ------------------
  |  Branch (8973:13): [True: 0, False: 28]
  ------------------
 8974|      0|            return(l);
 8975|     28|        l = xmlDictLookupHashed(ctxt->dict, BASE_PTR + start,
  ------------------
  |  | 2225|     28|#define BASE_PTR ctxt->input->base
  ------------------
 8976|     28|                                CUR_PTR - (BASE_PTR + start));
  ------------------
  |  | 2224|     28|#define CUR_PTR ctxt->input->cur
  ------------------
                                              CUR_PTR - (BASE_PTR + start));
  ------------------
  |  | 2225|     28|#define BASE_PTR ctxt->input->base
  ------------------
 8977|     28|        xmlNsErr(ctxt, XML_NS_ERR_QNAME,
 8978|     28|                 "Failed to parse QName '%s'\n", l.name, NULL, NULL);
 8979|     28|    }
 8980|       |
 8981|   158k|    *prefix = p;
 8982|   158k|    return(l);
 8983|   158k|}
parser.c:xmlParseNCName:
 3624|   171k|xmlParseNCName(xmlParserCtxtPtr ctxt) {
 3625|   171k|    const xmlChar *in, *e;
 3626|   171k|    xmlHashedString ret;
 3627|   171k|    size_t count = 0;
 3628|   171k|    size_t maxLength = (ctxt->options & XML_PARSE_HUGE) ?
  ------------------
  |  Branch (3628:24): [True: 0, False: 171k]
  ------------------
 3629|      0|                       XML_MAX_TEXT_LENGTH :
  ------------------
  |  |   42|      0|#define XML_MAX_TEXT_LENGTH 10000000
  ------------------
 3630|   171k|                       XML_MAX_NAME_LENGTH;
  ------------------
  |  |   61|   343k|#define XML_MAX_NAME_LENGTH 50000
  ------------------
 3631|       |
 3632|   171k|    ret.name = NULL;
 3633|       |
 3634|       |    /*
 3635|       |     * Accelerator for simple ASCII names
 3636|       |     */
 3637|   171k|    in = ctxt->input->cur;
 3638|   171k|    e = ctxt->input->end;
 3639|   171k|    if ((((*in >= 0x61) && (*in <= 0x7A)) ||
  ------------------
  |  Branch (3639:11): [True: 170k, False: 1.89k]
  |  Branch (3639:28): [True: 170k, False: 16]
  ------------------
 3640|   171k|	 ((*in >= 0x41) && (*in <= 0x5A)) ||
  ------------------
  |  Branch (3640:4): [True: 1.86k, False: 52]
  |  Branch (3640:21): [True: 1.84k, False: 16]
  ------------------
 3641|   171k|	 (*in == '_')) && (in < e)) {
  ------------------
  |  Branch (3641:3): [True: 0, False: 68]
  |  Branch (3641:20): [True: 171k, False: 0]
  ------------------
 3642|   171k|	in++;
 3643|   568k|	while ((((*in >= 0x61) && (*in <= 0x7A)) ||
  ------------------
  |  Branch (3643:11): [True: 223k, False: 344k]
  |  Branch (3643:28): [True: 223k, False: 92]
  ------------------
 3644|   568k|	        ((*in >= 0x41) && (*in <= 0x5A)) ||
  ------------------
  |  Branch (3644:11): [True: 1.90k, False: 342k]
  |  Branch (3644:28): [True: 1.67k, False: 228]
  ------------------
 3645|   568k|	        ((*in >= 0x30) && (*in <= 0x39)) ||
  ------------------
  |  Branch (3645:11): [True: 294k, False: 48.4k]
  |  Branch (3645:28): [True: 170k, False: 123k]
  ------------------
 3646|   568k|	        (*in == '_') || (*in == '-') ||
  ------------------
  |  Branch (3646:10): [True: 136, False: 172k]
  |  Branch (3646:26): [True: 136, False: 171k]
  ------------------
 3647|   568k|	        (*in == '.')) && (in < e))
  ------------------
  |  Branch (3647:10): [True: 0, False: 171k]
  |  Branch (3647:27): [True: 396k, False: 0]
  ------------------
 3648|   396k|	    in++;
 3649|   171k|	if (in >= e)
  ------------------
  |  Branch (3649:6): [True: 18, False: 171k]
  ------------------
 3650|     18|	    goto complex;
 3651|   171k|	if ((*in > 0) && (*in < 0x80)) {
  ------------------
  |  Branch (3651:6): [True: 171k, False: 0]
  |  Branch (3651:19): [True: 171k, False: 92]
  ------------------
 3652|   171k|	    count = in - ctxt->input->cur;
 3653|   171k|            if (count > maxLength) {
  ------------------
  |  Branch (3653:17): [True: 0, False: 171k]
  ------------------
 3654|      0|                xmlFatalErr(ctxt, XML_ERR_NAME_TOO_LONG, "NCName");
 3655|      0|                return(ret);
 3656|      0|            }
 3657|   171k|	    ret = xmlDictLookupHashed(ctxt->dict, ctxt->input->cur, count);
 3658|   171k|	    ctxt->input->cur = in;
 3659|   171k|	    ctxt->input->col += count;
 3660|   171k|	    if (ret.name == NULL) {
  ------------------
  |  Branch (3660:10): [True: 0, False: 171k]
  ------------------
 3661|      0|	        xmlErrMemory(ctxt, NULL);
 3662|      0|	    }
 3663|   171k|	    return(ret);
 3664|   171k|	}
 3665|   171k|    }
 3666|    178|complex:
 3667|    178|    return(xmlParseNCNameComplex(ctxt));
 3668|   171k|}
parser.c:xmlParseNCNameComplex:
 3569|    178|xmlParseNCNameComplex(xmlParserCtxtPtr ctxt) {
 3570|    178|    xmlHashedString ret;
 3571|    178|    int len = 0, l;
 3572|    178|    int c;
 3573|    178|    int maxLength = (ctxt->options & XML_PARSE_HUGE) ?
  ------------------
  |  Branch (3573:21): [True: 0, False: 178]
  ------------------
 3574|      0|                    XML_MAX_TEXT_LENGTH :
  ------------------
  |  |   42|      0|#define XML_MAX_TEXT_LENGTH 10000000
  ------------------
 3575|    178|                    XML_MAX_NAME_LENGTH;
  ------------------
  |  |   61|    178|#define XML_MAX_NAME_LENGTH 50000
  ------------------
 3576|    178|    size_t startPosition = 0;
 3577|       |
 3578|    178|    ret.name = NULL;
 3579|    178|    ret.hashValue = 0;
 3580|       |
 3581|       |    /*
 3582|       |     * Handler for more complex cases
 3583|       |     */
 3584|    178|    startPosition = CUR_PTR - BASE_PTR;
  ------------------
  |  | 2224|    178|#define CUR_PTR ctxt->input->cur
  ------------------
                  startPosition = CUR_PTR - BASE_PTR;
  ------------------
  |  | 2225|    178|#define BASE_PTR ctxt->input->base
  ------------------
 3585|    178|    c = CUR_CHAR(l);
  ------------------
  |  | 2291|    178|#define CUR_CHAR(l) xmlCurrentChar(ctxt, &l)
  ------------------
 3586|    178|    if ((c == ' ') || (c == '>') || (c == '/') || /* accelerators */
  ------------------
  |  Branch (3586:9): [True: 4, False: 174]
  |  Branch (3586:23): [True: 0, False: 174]
  |  Branch (3586:37): [True: 0, False: 174]
  ------------------
 3587|    178|	(!xmlIsNameStartChar(ctxt, c) || (c == ':'))) {
  ------------------
  |  Branch (3587:3): [True: 40, False: 134]
  |  Branch (3587:35): [True: 8, False: 126]
  ------------------
 3588|     52|	return(ret);
 3589|     52|    }
 3590|       |
 3591|   168k|    while ((c != ' ') && (c != '>') && (c != '/') && /* test bigname.xml */
  ------------------
  |  Branch (3591:12): [True: 168k, False: 10]
  |  Branch (3591:26): [True: 168k, False: 94]
  |  Branch (3591:40): [True: 168k, False: 2]
  ------------------
 3592|   168k|	   (xmlIsNameChar(ctxt, c) && (c != ':'))) {
  ------------------
  |  Branch (3592:6): [True: 168k, False: 16]
  |  Branch (3592:32): [True: 168k, False: 4]
  ------------------
 3593|   168k|        if (len <= INT_MAX - l)
  ------------------
  |  Branch (3593:13): [True: 168k, False: 0]
  ------------------
 3594|   168k|	    len += l;
 3595|   168k|	NEXTL(l);
  ------------------
  |  | 2284|   168k|#define NEXTL(l) do {							\
  |  | 2285|   168k|    if (*(ctxt->input->cur) == '\n') {					\
  |  |  ------------------
  |  |  |  Branch (2285:9): [True: 0, False: 168k]
  |  |  ------------------
  |  | 2286|      0|	ctxt->input->line++; ctxt->input->col = 1;			\
  |  | 2287|   168k|    } else ctxt->input->col++;						\
  |  | 2288|   168k|    ctxt->input->cur += l;				\
  |  | 2289|   168k|  } while (0)
  |  |  ------------------
  |  |  |  Branch (2289:12): [Folded - Ignored]
  |  |  ------------------
  ------------------
 3596|   168k|	c = CUR_CHAR(l);
  ------------------
  |  | 2291|   168k|#define CUR_CHAR(l) xmlCurrentChar(ctxt, &l)
  ------------------
 3597|   168k|    }
 3598|    126|    if (ctxt->instate == XML_PARSER_EOF)
  ------------------
  |  Branch (3598:9): [True: 0, False: 126]
  ------------------
 3599|      0|        return(ret);
 3600|    126|    if (len > maxLength) {
  ------------------
  |  Branch (3600:9): [True: 0, False: 126]
  ------------------
 3601|      0|        xmlFatalErr(ctxt, XML_ERR_NAME_TOO_LONG, "NCName");
 3602|      0|        return(ret);
 3603|      0|    }
 3604|    126|    ret = xmlDictLookupHashed(ctxt->dict, (BASE_PTR + startPosition), len);
  ------------------
  |  | 2225|    126|#define BASE_PTR ctxt->input->base
  ------------------
 3605|    126|    return(ret);
 3606|    126|}
parser.c:xmlParseAttribute2:
 9282|   100k|{
 9283|   100k|    xmlHashedString hname;
 9284|   100k|    const xmlChar *prefix, *name;
 9285|   100k|    xmlChar *val, *internal_val = NULL;
 9286|   100k|    int normalize = 0;
 9287|       |
 9288|   100k|    *value = NULL;
 9289|   100k|    GROW;
  ------------------
  |  | 2270|   100k|#define GROW if (ctxt->input->end - ctxt->input->cur < INPUT_CHUNK)	\
  |  |  ------------------
  |  |  |  |   97|   100k|#define INPUT_CHUNK	250
  |  |  ------------------
  |  |  |  Branch (2270:18): [True: 31.4k, False: 69.0k]
  |  |  ------------------
  |  | 2271|   100k|	xmlParserGrow(ctxt);
  ------------------
 9290|   100k|    hname = xmlParseQNameHashed(ctxt, hprefix);
 9291|   100k|    if (hname.name == NULL) {
  ------------------
  |  Branch (9291:9): [True: 0, False: 100k]
  ------------------
 9292|      0|        xmlFatalErrMsg(ctxt, XML_ERR_NAME_REQUIRED,
 9293|      0|                       "error parsing attribute name\n");
 9294|      0|        return(hname);
 9295|      0|    }
 9296|   100k|    name = hname.name;
 9297|   100k|    if (hprefix->name != NULL)
  ------------------
  |  Branch (9297:9): [True: 12.0k, False: 88.4k]
  ------------------
 9298|  12.0k|        prefix = hprefix->name;
 9299|  88.4k|    else
 9300|  88.4k|        prefix = NULL;
 9301|       |
 9302|       |    /*
 9303|       |     * get the type if needed
 9304|       |     */
 9305|   100k|    if (ctxt->attsSpecial != NULL) {
  ------------------
  |  Branch (9305:9): [True: 5.83k, False: 94.6k]
  ------------------
 9306|  5.83k|        int type;
 9307|       |
 9308|  5.83k|        type = (int) (ptrdiff_t) xmlHashQLookup2(ctxt->attsSpecial,
 9309|  5.83k|                                                 pref, elem,
 9310|  5.83k|                                                 prefix, name);
 9311|  5.83k|        if (type != 0)
  ------------------
  |  Branch (9311:13): [True: 4.27k, False: 1.56k]
  ------------------
 9312|  4.27k|            normalize = 1;
 9313|  5.83k|    }
 9314|       |
 9315|       |    /*
 9316|       |     * read the value
 9317|       |     */
 9318|   100k|    SKIP_BLANKS;
  ------------------
  |  | 2273|   100k|#define SKIP_BLANKS xmlSkipBlankChars(ctxt)
  ------------------
 9319|   100k|    if (RAW == '=') {
  ------------------
  |  | 2221|   100k|#define RAW (*ctxt->input->cur)
  ------------------
  |  Branch (9319:9): [True: 100k, False: 4]
  ------------------
 9320|   100k|        NEXT;
  ------------------
  |  | 2275|   100k|#define NEXT xmlNextChar(ctxt)
  ------------------
 9321|   100k|        SKIP_BLANKS;
  ------------------
  |  | 2273|   100k|#define SKIP_BLANKS xmlSkipBlankChars(ctxt)
  ------------------
 9322|   100k|        val = xmlParseAttValueInternal(ctxt, len, alloc, normalize);
 9323|   100k|        if (val == NULL) {
  ------------------
  |  Branch (9323:13): [True: 16, False: 100k]
  ------------------
 9324|     16|            hname.name = NULL;
 9325|     16|            return(hname);
 9326|     16|        }
 9327|   100k|	if (normalize) {
  ------------------
  |  Branch (9327:6): [True: 4.27k, False: 96.1k]
  ------------------
 9328|       |	    /*
 9329|       |	     * Sometimes a second normalisation pass for spaces is needed
 9330|       |	     * but that only happens if charrefs or entities references
 9331|       |	     * have been used in the attribute value, i.e. the attribute
 9332|       |	     * value have been extracted in an allocated string already.
 9333|       |	     */
 9334|  4.27k|	    if (*alloc) {
  ------------------
  |  Branch (9334:10): [True: 80, False: 4.19k]
  ------------------
 9335|     80|	        const xmlChar *val2;
 9336|       |
 9337|     80|	        val2 = xmlAttrNormalizeSpace2(ctxt, val, len);
 9338|     80|		if ((val2 != NULL) && (val2 != val)) {
  ------------------
  |  Branch (9338:7): [True: 20, False: 60]
  |  Branch (9338:25): [True: 20, False: 0]
  ------------------
 9339|     20|		    xmlFree(val);
 9340|     20|		    val = (xmlChar *) val2;
 9341|     20|		}
 9342|     80|	    }
 9343|  4.27k|	}
 9344|   100k|        ctxt->instate = XML_PARSER_CONTENT;
 9345|   100k|    } else {
 9346|      4|        xmlFatalErrMsgStr(ctxt, XML_ERR_ATTRIBUTE_WITHOUT_VALUE,
 9347|      4|                          "Specification mandates value for attribute %s\n",
 9348|      4|                          name);
 9349|      4|        return(hname);
 9350|      4|    }
 9351|       |
 9352|   100k|    if (prefix == ctxt->str_xml) {
  ------------------
  |  Branch (9352:9): [True: 60, False: 100k]
  ------------------
 9353|       |        /*
 9354|       |         * Check that xml:lang conforms to the specification
 9355|       |         * No more registered as an error, just generate a warning now
 9356|       |         * since this was deprecated in XML second edition
 9357|       |         */
 9358|     60|        if ((ctxt->pedantic) && (xmlStrEqual(name, BAD_CAST "lang"))) {
  ------------------
  |  |   35|      0|#define BAD_CAST (xmlChar *)
  ------------------
  |  Branch (9358:13): [True: 0, False: 60]
  |  Branch (9358:33): [True: 0, False: 0]
  ------------------
 9359|      0|            internal_val = xmlStrndup(val, *len);
 9360|      0|            if (!xmlCheckLanguageID(internal_val)) {
  ------------------
  |  Branch (9360:17): [True: 0, False: 0]
  ------------------
 9361|      0|                xmlWarningMsg(ctxt, XML_WAR_LANG_VALUE,
 9362|      0|                              "Malformed value for xml:lang : %s\n",
 9363|      0|                              internal_val, NULL);
 9364|      0|            }
 9365|      0|        }
 9366|       |
 9367|       |        /*
 9368|       |         * Check that xml:space conforms to the specification
 9369|       |         */
 9370|     60|        if (xmlStrEqual(name, BAD_CAST "space")) {
  ------------------
  |  |   35|     60|#define BAD_CAST (xmlChar *)
  ------------------
  |  Branch (9370:13): [True: 4, False: 56]
  ------------------
 9371|      4|            internal_val = xmlStrndup(val, *len);
 9372|      4|            if (xmlStrEqual(internal_val, BAD_CAST "default"))
  ------------------
  |  |   35|      4|#define BAD_CAST (xmlChar *)
  ------------------
  |  Branch (9372:17): [True: 0, False: 4]
  ------------------
 9373|      0|                *(ctxt->space) = 0;
 9374|      4|            else if (xmlStrEqual(internal_val, BAD_CAST "preserve"))
  ------------------
  |  |   35|      4|#define BAD_CAST (xmlChar *)
  ------------------
  |  Branch (9374:22): [True: 4, False: 0]
  ------------------
 9375|      4|                *(ctxt->space) = 1;
 9376|      0|            else {
 9377|      0|                xmlWarningMsg(ctxt, XML_WAR_SPACE_VALUE,
 9378|      0|                              "Invalid value \"%s\" for xml:space : \"default\" or \"preserve\" expected\n",
 9379|      0|                              internal_val, NULL);
 9380|      0|            }
 9381|      4|        }
 9382|     60|        if (internal_val) {
  ------------------
  |  Branch (9382:13): [True: 4, False: 56]
  ------------------
 9383|      4|            xmlFree(internal_val);
 9384|      4|        }
 9385|     60|    }
 9386|       |
 9387|   100k|    *value = val;
 9388|   100k|    return (hname);
 9389|   100k|}
parser.c:xmlAttrNormalizeSpace2:
  955|     80|{
  956|     80|    int i;
  957|     80|    int remove_head = 0;
  958|     80|    int need_realloc = 0;
  959|     80|    const xmlChar *cur;
  960|       |
  961|     80|    if ((ctxt == NULL) || (src == NULL) || (len == NULL))
  ------------------
  |  Branch (961:9): [True: 0, False: 80]
  |  Branch (961:27): [True: 0, False: 80]
  |  Branch (961:44): [True: 0, False: 80]
  ------------------
  962|      0|        return(NULL);
  963|     80|    i = *len;
  964|     80|    if (i <= 0)
  ------------------
  |  Branch (964:9): [True: 0, False: 80]
  ------------------
  965|      0|        return(NULL);
  966|       |
  967|     80|    cur = src;
  968|     96|    while (*cur == 0x20) {
  ------------------
  |  Branch (968:12): [True: 16, False: 80]
  ------------------
  969|     16|        cur++;
  970|     16|	remove_head++;
  971|     16|    }
  972|    548|    while (*cur != 0) {
  ------------------
  |  Branch (972:12): [True: 488, False: 60]
  ------------------
  973|    488|	if (*cur == 0x20) {
  ------------------
  |  Branch (973:6): [True: 48, False: 440]
  ------------------
  974|     48|	    cur++;
  975|     48|	    if ((*cur == 0x20) || (*cur == 0)) {
  ------------------
  |  Branch (975:10): [True: 20, False: 28]
  |  Branch (975:28): [True: 0, False: 28]
  ------------------
  976|     20|	        need_realloc = 1;
  977|     20|		break;
  978|     20|	    }
  979|     48|	} else
  980|    440|	    cur++;
  981|    488|    }
  982|     80|    if (need_realloc) {
  ------------------
  |  Branch (982:9): [True: 20, False: 60]
  ------------------
  983|     20|        xmlChar *ret;
  984|       |
  985|     20|	ret = xmlStrndup(src + remove_head, i - remove_head + 1);
  986|     20|	if (ret == NULL) {
  ------------------
  |  Branch (986:6): [True: 0, False: 20]
  ------------------
  987|      0|	    xmlErrMemory(ctxt, NULL);
  988|      0|	    return(NULL);
  989|      0|	}
  990|     20|	xmlAttrNormalizeSpace(ret, ret);
  991|     20|	*len = strlen((const char *)ret);
  992|     20|        return(ret);
  993|     60|    } else if (remove_head) {
  ------------------
  |  Branch (993:16): [True: 0, False: 60]
  ------------------
  994|      0|        *len -= remove_head;
  995|      0|        memmove(src, src + remove_head, 1 + *len);
  996|      0|	return(src);
  997|      0|    }
  998|     60|    return(NULL);
  999|     80|}
parser.c:xmlNsWarn:
  530|      4|{
  531|      4|    if ((ctxt != NULL) && (ctxt->disableSAX != 0) &&
  ------------------
  |  Branch (531:9): [True: 4, False: 0]
  |  Branch (531:27): [True: 0, False: 4]
  ------------------
  532|      4|        (ctxt->instate == XML_PARSER_EOF))
  ------------------
  |  Branch (532:9): [True: 0, False: 0]
  ------------------
  533|      0|	return;
  534|      4|    __xmlRaiseError(NULL, NULL, NULL, ctxt, NULL, XML_FROM_NAMESPACE, error,
  535|      4|                    XML_ERR_WARNING, NULL, 0, (const char *) info1,
  536|      4|                    (const char *) info2, (const char *) info3, 0, 0, msg,
  537|      4|                    info1, info2, info3);
  538|      4|}
parser.c:xmlCtxtGrowAttrs:
 1853|    552|xmlCtxtGrowAttrs(xmlParserCtxtPtr ctxt, int nr) {
 1854|    552|    const xmlChar **atts;
 1855|    552|    unsigned *attallocs;
 1856|    552|    int maxatts;
 1857|       |
 1858|    552|    if (nr + 5 > ctxt->maxatts) {
  ------------------
  |  Branch (1858:9): [True: 552, False: 0]
  ------------------
 1859|    552|	maxatts = ctxt->maxatts == 0 ? 55 : (nr + 5) * 2;
  ------------------
  |  Branch (1859:12): [True: 516, False: 36]
  ------------------
 1860|    552|	atts = (const xmlChar **) xmlMalloc(
 1861|    552|				     maxatts * sizeof(const xmlChar *));
 1862|    552|	if (atts == NULL) goto mem_error;
  ------------------
  |  Branch (1862:6): [True: 0, False: 552]
  ------------------
 1863|    552|	attallocs = xmlRealloc(ctxt->attallocs,
 1864|    552|                               (maxatts / 5) * sizeof(attallocs[0]));
 1865|    552|	if (attallocs == NULL) {
  ------------------
  |  Branch (1865:6): [True: 0, False: 552]
  ------------------
 1866|      0|            xmlFree(atts);
 1867|      0|            goto mem_error;
 1868|      0|        }
 1869|    552|        if (ctxt->maxatts > 0)
  ------------------
  |  Branch (1869:13): [True: 36, False: 516]
  ------------------
 1870|     36|            memcpy(atts, ctxt->atts, ctxt->maxatts * sizeof(const xmlChar *));
 1871|    552|        xmlFree(ctxt->atts);
 1872|    552|	ctxt->atts = atts;
 1873|    552|	ctxt->attallocs = attallocs;
 1874|    552|	ctxt->maxatts = maxatts;
 1875|    552|    }
 1876|    552|    return(ctxt->maxatts);
 1877|      0|mem_error:
 1878|      0|    xmlErrMemory(ctxt, NULL);
 1879|      0|    return(-1);
 1880|    552|}
parser.c:xmlAttrHashInsert:
 9407|   255k|                  const xmlChar *uri, unsigned hashValue, int aindex) {
 9408|   255k|    xmlAttrHashBucket *table = ctxt->attrHash;
 9409|   255k|    xmlAttrHashBucket *bucket;
 9410|   255k|    unsigned hindex;
 9411|       |
 9412|   255k|    hindex = hashValue & (size - 1);
 9413|   255k|    bucket = &table[hindex];
 9414|       |
 9415|   292k|    while (bucket->index >= 0) {
  ------------------
  |  Branch (9415:12): [True: 36.9k, False: 255k]
  ------------------
 9416|  36.9k|        const xmlChar **atts = &ctxt->atts[bucket->index];
 9417|       |
 9418|  36.9k|        if (name == atts[0]) {
  ------------------
  |  Branch (9418:13): [True: 98, False: 36.8k]
  ------------------
 9419|     98|            int nsIndex = (int) (ptrdiff_t) atts[2];
 9420|       |
 9421|     98|            if ((nsIndex == NS_INDEX_EMPTY) ? (uri == NULL) :
  ------------------
  |  |   77|     98|#define NS_INDEX_EMPTY  INT_MAX
  ------------------
  |  Branch (9421:17): [True: 68, False: 30]
  |  Branch (9421:17): [True: 94, False: 4]
  ------------------
 9422|     98|                (nsIndex == NS_INDEX_XML) ? (uri == ctxt->str_xml) :
  ------------------
  |  |   78|     30|#define NS_INDEX_XML    (INT_MAX - 1)
  ------------------
  |  Branch (9422:17): [True: 0, False: 30]
  ------------------
 9423|     30|                (uri == ctxt->nsTab[nsIndex * 2 + 1]))
 9424|     94|                return(bucket->index);
 9425|     98|        }
 9426|       |
 9427|  36.8k|        hindex++;
 9428|  36.8k|        bucket++;
 9429|  36.8k|        if (hindex >= size) {
  ------------------
  |  Branch (9429:13): [True: 410, False: 36.4k]
  ------------------
 9430|    410|            hindex = 0;
 9431|    410|            bucket = table;
 9432|    410|        }
 9433|  36.8k|    }
 9434|       |
 9435|   255k|    bucket->index = aindex;
 9436|       |
 9437|   255k|    return(INT_MAX);
 9438|   255k|}
parser.c:xmlParserNsLookupUri:
 1532|  57.9k|xmlParserNsLookupUri(xmlParserCtxtPtr ctxt, const xmlHashedString *prefix) {
 1533|  57.9k|    const xmlChar *ret;
 1534|  57.9k|    int nsIndex;
 1535|       |
 1536|  57.9k|    if (prefix->name == ctxt->str_xml)
  ------------------
  |  Branch (1536:9): [True: 4, False: 57.9k]
  ------------------
 1537|      4|        return(ctxt->str_xml_ns);
 1538|       |
 1539|  57.9k|    nsIndex = xmlParserNsLookup(ctxt, prefix, NULL);
 1540|  57.9k|    if (nsIndex == INT_MAX)
  ------------------
  |  Branch (1540:9): [True: 55.6k, False: 2.32k]
  ------------------
 1541|  55.6k|        return(NULL);
 1542|       |
 1543|  2.32k|    ret = ctxt->nsTab[nsIndex * 2 + 1];
 1544|  2.32k|    if (ret[0] == 0)
  ------------------
  |  Branch (1544:9): [True: 0, False: 2.32k]
  ------------------
 1545|      0|        ret = NULL;
 1546|  2.32k|    return(ret);
 1547|  57.9k|}
parser.c:nameNsPush:
 2024|  37.1k|{
 2025|  37.1k|    xmlStartTag *tag;
 2026|       |
 2027|  37.1k|    if (ctxt->nameNr >= ctxt->nameMax) {
  ------------------
  |  Branch (2027:9): [True: 4, False: 37.1k]
  ------------------
 2028|      4|        const xmlChar * *tmp;
 2029|      4|        xmlStartTag *tmp2;
 2030|      4|        ctxt->nameMax *= 2;
 2031|      4|        tmp = (const xmlChar * *) xmlRealloc((xmlChar * *)ctxt->nameTab,
 2032|      4|                                    ctxt->nameMax *
 2033|      4|                                    sizeof(ctxt->nameTab[0]));
 2034|      4|        if (tmp == NULL) {
  ------------------
  |  Branch (2034:13): [True: 0, False: 4]
  ------------------
 2035|      0|	    ctxt->nameMax /= 2;
 2036|      0|	    goto mem_error;
 2037|      0|        }
 2038|      4|	ctxt->nameTab = tmp;
 2039|      4|        tmp2 = (xmlStartTag *) xmlRealloc((void * *)ctxt->pushTab,
 2040|      4|                                    ctxt->nameMax *
 2041|      4|                                    sizeof(ctxt->pushTab[0]));
 2042|      4|        if (tmp2 == NULL) {
  ------------------
  |  Branch (2042:13): [True: 0, False: 4]
  ------------------
 2043|      0|	    ctxt->nameMax /= 2;
 2044|      0|	    goto mem_error;
 2045|      0|        }
 2046|      4|	ctxt->pushTab = tmp2;
 2047|  37.1k|    } else if (ctxt->pushTab == NULL) {
  ------------------
  |  Branch (2047:16): [True: 1.09k, False: 36.0k]
  ------------------
 2048|  1.09k|        ctxt->pushTab = (xmlStartTag *) xmlMalloc(ctxt->nameMax *
 2049|  1.09k|                                            sizeof(ctxt->pushTab[0]));
 2050|  1.09k|        if (ctxt->pushTab == NULL)
  ------------------
  |  Branch (2050:13): [True: 0, False: 1.09k]
  ------------------
 2051|      0|            goto mem_error;
 2052|  1.09k|    }
 2053|  37.1k|    ctxt->nameTab[ctxt->nameNr] = value;
 2054|  37.1k|    ctxt->name = value;
 2055|  37.1k|    tag = &ctxt->pushTab[ctxt->nameNr];
 2056|  37.1k|    tag->prefix = prefix;
 2057|  37.1k|    tag->URI = URI;
 2058|  37.1k|    tag->line = line;
 2059|  37.1k|    tag->nsNr = nsNr;
 2060|  37.1k|    return (ctxt->nameNr++);
 2061|      0|mem_error:
 2062|      0|    xmlErrMemory(ctxt, NULL);
 2063|      0|    return (-1);
 2064|  37.1k|}
parser.c:xmlParseElementEnd:
10475|  8.36k|xmlParseElementEnd(xmlParserCtxtPtr ctxt) {
10476|  8.36k|    xmlNodePtr cur = ctxt->node;
10477|       |
10478|  8.36k|    if (ctxt->nameNr <= 0) {
  ------------------
  |  Branch (10478:9): [True: 0, False: 8.36k]
  ------------------
10479|      0|        if ((RAW == '<') && (NXT(1) == '/'))
  ------------------
  |  | 2221|      0|#define RAW (*ctxt->input->cur)
  ------------------
                      if ((RAW == '<') && (NXT(1) == '/'))
  ------------------
  |  | 2223|      0|#define NXT(val) ctxt->input->cur[(val)]
  ------------------
  |  Branch (10479:13): [True: 0, False: 0]
  |  Branch (10479:29): [True: 0, False: 0]
  ------------------
10480|      0|            SKIP(2);
  ------------------
  |  | 2245|      0|#define SKIP(val) do {							\
  |  | 2246|      0|    ctxt->input->cur += (val),ctxt->input->col+=(val);			\
  |  | 2247|      0|    if (*ctxt->input->cur == 0)						\
  |  |  ------------------
  |  |  |  Branch (2247:9): [True: 0, False: 0]
  |  |  ------------------
  |  | 2248|      0|        xmlParserGrow(ctxt);						\
  |  | 2249|      0|  } while (0)
  |  |  ------------------
  |  |  |  Branch (2249:12): [Folded - Ignored]
  |  |  ------------------
  ------------------
10481|      0|        return;
10482|      0|    }
10483|       |
10484|       |    /*
10485|       |     * parse the end of tag: '</' should be here.
10486|       |     */
10487|  8.36k|    if (ctxt->sax2) {
  ------------------
  |  Branch (10487:9): [True: 8.36k, False: 0]
  ------------------
10488|  8.36k|	xmlParseEndTag2(ctxt, &ctxt->pushTab[ctxt->nameNr - 1]);
10489|  8.36k|	namePop(ctxt);
10490|  8.36k|    }
10491|      0|#ifdef LIBXML_SAX1_ENABLED
10492|      0|    else
10493|      0|	xmlParseEndTag1(ctxt, 0);
10494|  8.36k|#endif /* LIBXML_SAX1_ENABLED */
10495|       |
10496|       |    /*
10497|       |     * Capture end position
10498|       |     */
10499|  8.36k|    if (cur != NULL && ctxt->record_info) {
  ------------------
  |  Branch (10499:9): [True: 8.36k, False: 0]
  |  Branch (10499:24): [True: 0, False: 8.36k]
  ------------------
10500|      0|        xmlParserNodeInfoPtr node_info;
10501|       |
10502|      0|        node_info = (xmlParserNodeInfoPtr) xmlParserFindNodeInfo(ctxt, cur);
10503|      0|        if (node_info != NULL) {
  ------------------
  |  Branch (10503:13): [True: 0, False: 0]
  ------------------
10504|      0|            node_info->end_pos = ctxt->input->consumed +
10505|      0|                                 (CUR_PTR - ctxt->input->base);
  ------------------
  |  | 2224|      0|#define CUR_PTR ctxt->input->cur
  ------------------
10506|      0|            node_info->end_line = ctxt->input->line;
10507|      0|        }
10508|      0|    }
10509|  8.36k|}
parser.c:xmlParseEndTag2:
10039|  16.6k|xmlParseEndTag2(xmlParserCtxtPtr ctxt, const xmlStartTag *tag) {
10040|  16.6k|    const xmlChar *name;
10041|       |
10042|  16.6k|    GROW;
  ------------------
  |  | 2270|  16.6k|#define GROW if (ctxt->input->end - ctxt->input->cur < INPUT_CHUNK)	\
  |  |  ------------------
  |  |  |  |   97|  16.6k|#define INPUT_CHUNK	250
  |  |  ------------------
  |  |  |  Branch (2270:18): [True: 7.53k, False: 9.08k]
  |  |  ------------------
  |  | 2271|  16.6k|	xmlParserGrow(ctxt);
  ------------------
10043|  16.6k|    if ((RAW != '<') || (NXT(1) != '/')) {
  ------------------
  |  | 2221|  16.6k|#define RAW (*ctxt->input->cur)
  ------------------
                  if ((RAW != '<') || (NXT(1) != '/')) {
  ------------------
  |  | 2223|  16.6k|#define NXT(val) ctxt->input->cur[(val)]
  ------------------
  |  Branch (10043:9): [True: 0, False: 16.6k]
  |  Branch (10043:25): [True: 0, False: 16.6k]
  ------------------
10044|      0|	xmlFatalErr(ctxt, XML_ERR_LTSLASH_REQUIRED, NULL);
10045|      0|	return;
10046|      0|    }
10047|  16.6k|    SKIP(2);
  ------------------
  |  | 2245|  16.6k|#define SKIP(val) do {							\
  |  | 2246|  16.6k|    ctxt->input->cur += (val),ctxt->input->col+=(val);			\
  |  | 2247|  16.6k|    if (*ctxt->input->cur == 0)						\
  |  |  ------------------
  |  |  |  Branch (2247:9): [True: 0, False: 16.6k]
  |  |  ------------------
  |  | 2248|  16.6k|        xmlParserGrow(ctxt);						\
  |  | 2249|  16.6k|  } while (0)
  |  |  ------------------
  |  |  |  Branch (2249:12): [Folded - Ignored]
  |  |  ------------------
  ------------------
10048|       |
10049|  16.6k|    if (tag->prefix == NULL)
  ------------------
  |  Branch (10049:9): [True: 15.1k, False: 1.43k]
  ------------------
10050|  15.1k|        name = xmlParseNameAndCompare(ctxt, ctxt->name);
10051|  1.43k|    else
10052|  1.43k|        name = xmlParseQNameAndCompare(ctxt, ctxt->name, tag->prefix);
10053|       |
10054|       |    /*
10055|       |     * We should definitely be at the ending "S? '>'" part
10056|       |     */
10057|  16.6k|    GROW;
  ------------------
  |  | 2270|  16.6k|#define GROW if (ctxt->input->end - ctxt->input->cur < INPUT_CHUNK)	\
  |  |  ------------------
  |  |  |  |   97|  16.6k|#define INPUT_CHUNK	250
  |  |  ------------------
  |  |  |  Branch (2270:18): [True: 7.59k, False: 9.01k]
  |  |  ------------------
  |  | 2271|  16.6k|	xmlParserGrow(ctxt);
  ------------------
10058|  16.6k|    if (ctxt->instate == XML_PARSER_EOF)
  ------------------
  |  Branch (10058:9): [True: 0, False: 16.6k]
  ------------------
10059|      0|        return;
10060|  16.6k|    SKIP_BLANKS;
  ------------------
  |  | 2273|  16.6k|#define SKIP_BLANKS xmlSkipBlankChars(ctxt)
  ------------------
10061|  16.6k|    if ((!IS_BYTE_CHAR(RAW)) || (RAW != '>')) {
  ------------------
  |  |  113|  16.6k|#define IS_BYTE_CHAR(c)	 xmlIsChar_ch(c)
  |  |  ------------------
  |  |  |  |  108|  16.6k|#define xmlIsChar_ch(c)		(((0x9 <= (c)) && ((c) <= 0xa)) || \
  |  |  |  |  ------------------
  |  |  |  |  |  Branch (108:28): [True: 16.6k, False: 4]
  |  |  |  |  |  Branch (108:44): [True: 0, False: 16.6k]
  |  |  |  |  ------------------
  |  |  |  |  109|  16.6k|				 ((c) == 0xd) || \
  |  |  |  |  ------------------
  |  |  |  |  |  Branch (109:6): [True: 0, False: 16.6k]
  |  |  |  |  ------------------
  |  |  |  |  110|  16.6k|				  (0x20 <= (c)))
  |  |  |  |  ------------------
  |  |  |  |  |  Branch (110:7): [True: 16.6k, False: 4]
  |  |  |  |  ------------------
  |  |  ------------------
  ------------------
                  if ((!IS_BYTE_CHAR(RAW)) || (RAW != '>')) {
  ------------------
  |  | 2221|  16.6k|#define RAW (*ctxt->input->cur)
  ------------------
  |  Branch (10061:33): [True: 0, False: 16.6k]
  ------------------
10062|      4|	xmlFatalErr(ctxt, XML_ERR_GT_REQUIRED, NULL);
10063|      4|    } else
10064|  16.6k|	NEXT1;
  ------------------
  |  | 2277|  16.6k|#define NEXT1 {								\
  |  | 2278|  16.6k|	ctxt->input->col++;						\
  |  | 2279|  16.6k|	ctxt->input->cur++;						\
  |  | 2280|  16.6k|	if (*ctxt->input->cur == 0)					\
  |  |  ------------------
  |  |  |  Branch (2280:6): [True: 61, False: 16.5k]
  |  |  ------------------
  |  | 2281|  16.6k|	    xmlParserGrow(ctxt);						\
  |  | 2282|  16.6k|    }
  ------------------
10065|       |
10066|       |    /*
10067|       |     * [ WFC: Element Type Match ]
10068|       |     * The Name in an element's end-tag must match the element type in the
10069|       |     * start-tag.
10070|       |     *
10071|       |     */
10072|  16.6k|    if (name != (xmlChar*)1) {
  ------------------
  |  Branch (10072:9): [True: 8, False: 16.6k]
  ------------------
10073|      8|        if (name == NULL) name = BAD_CAST "unparsable";
  ------------------
  |  |   35|      0|#define BAD_CAST (xmlChar *)
  ------------------
  |  Branch (10073:13): [True: 0, False: 8]
  ------------------
10074|      8|        xmlFatalErrMsgStrIntStr(ctxt, XML_ERR_TAG_NAME_MISMATCH,
10075|      8|		     "Opening and ending tag mismatch: %s line %d and %s\n",
10076|      8|		                ctxt->name, tag->line, name);
10077|      8|    }
10078|       |
10079|       |    /*
10080|       |     * SAX: End of Tag
10081|       |     */
10082|  16.6k|    if ((ctxt->sax != NULL) && (ctxt->sax->endElementNs != NULL) &&
  ------------------
  |  Branch (10082:9): [True: 16.6k, False: 0]
  |  Branch (10082:32): [True: 16.6k, False: 0]
  ------------------
10083|  16.6k|	(!ctxt->disableSAX))
  ------------------
  |  Branch (10083:2): [True: 16.5k, False: 86]
  ------------------
10084|  16.5k|	ctxt->sax->endElementNs(ctxt->userData, ctxt->name, tag->prefix,
10085|  16.5k|                                tag->URI);
10086|       |
10087|  16.6k|    spacePop(ctxt);
10088|  16.6k|    if (tag->nsNr != 0)
  ------------------
  |  Branch (10088:9): [True: 248, False: 16.3k]
  ------------------
10089|    248|	xmlParserNsPop(ctxt, tag->nsNr);
10090|  16.6k|}
parser.c:xmlParseQNameAndCompare:
 9025|  1.43k|                        xmlChar const *prefix) {
 9026|  1.43k|    const xmlChar *cmp;
 9027|  1.43k|    const xmlChar *in;
 9028|  1.43k|    const xmlChar *ret;
 9029|  1.43k|    const xmlChar *prefix2;
 9030|       |
 9031|  1.43k|    if (prefix == NULL) return(xmlParseNameAndCompare(ctxt, name));
  ------------------
  |  Branch (9031:9): [True: 0, False: 1.43k]
  ------------------
 9032|       |
 9033|  1.43k|    GROW;
  ------------------
  |  | 2270|  1.43k|#define GROW if (ctxt->input->end - ctxt->input->cur < INPUT_CHUNK)	\
  |  |  ------------------
  |  |  |  |   97|  1.43k|#define INPUT_CHUNK	250
  |  |  ------------------
  |  |  |  Branch (2270:18): [True: 913, False: 519]
  |  |  ------------------
  |  | 2271|  1.43k|	xmlParserGrow(ctxt);
  ------------------
 9034|  1.43k|    in = ctxt->input->cur;
 9035|       |
 9036|  1.43k|    cmp = prefix;
 9037|  4.43k|    while (*in != 0 && *in == *cmp) {
  ------------------
  |  Branch (9037:12): [True: 4.43k, False: 4]
  |  Branch (9037:24): [True: 3.00k, False: 1.42k]
  ------------------
 9038|  3.00k|	++in;
 9039|  3.00k|	++cmp;
 9040|  3.00k|    }
 9041|  1.43k|    if ((*cmp == 0) && (*in == ':')) {
  ------------------
  |  Branch (9041:9): [True: 1.42k, False: 4]
  |  Branch (9041:24): [True: 1.42k, False: 0]
  ------------------
 9042|  1.42k|        in++;
 9043|  1.42k|	cmp = name;
 9044|  11.7k|	while (*in != 0 && *in == *cmp) {
  ------------------
  |  Branch (9044:9): [True: 11.7k, False: 0]
  |  Branch (9044:21): [True: 10.3k, False: 1.42k]
  ------------------
 9045|  10.3k|	    ++in;
 9046|  10.3k|	    ++cmp;
 9047|  10.3k|	}
 9048|  1.42k|	if (*cmp == 0 && (*in == '>' || IS_BLANK_CH (*in))) {
  ------------------
  |  |  151|      0|#define IS_BLANK_CH(c)  xmlIsBlank_ch(c)
  |  |  ------------------
  |  |  |  |   88|      0|#define xmlIsBlank_ch(c)	(((c) == 0x20) || \
  |  |  |  |  ------------------
  |  |  |  |  |  Branch (88:27): [True: 0, False: 0]
  |  |  |  |  ------------------
  |  |  |  |   89|      0|				 ((0x9 <= (c)) && ((c) <= 0xa)) || \
  |  |  |  |  ------------------
  |  |  |  |  |  Branch (89:7): [True: 0, False: 0]
  |  |  |  |  |  Branch (89:23): [True: 0, False: 0]
  |  |  |  |  ------------------
  |  |  |  |   90|      0|				 ((c) == 0xd))
  |  |  |  |  ------------------
  |  |  |  |  |  Branch (90:6): [True: 0, False: 0]
  |  |  |  |  ------------------
  |  |  ------------------
  ------------------
  |  Branch (9048:6): [True: 1.42k, False: 0]
  |  Branch (9048:20): [True: 1.42k, False: 0]
  ------------------
 9049|       |	    /* success */
 9050|  1.42k|            ctxt->input->col += in - ctxt->input->cur;
 9051|  1.42k|	    ctxt->input->cur = in;
 9052|  1.42k|	    return((const xmlChar*) 1);
 9053|  1.42k|	}
 9054|  1.42k|    }
 9055|       |    /*
 9056|       |     * all strings coms from the dictionary, equality can be done directly
 9057|       |     */
 9058|      4|    ret = xmlParseQName (ctxt, &prefix2);
 9059|      4|    if (ret == NULL)
  ------------------
  |  Branch (9059:9): [True: 0, False: 4]
  ------------------
 9060|      0|        return(NULL);
 9061|      4|    if ((ret == name) && (prefix == prefix2))
  ------------------
  |  Branch (9061:9): [True: 4, False: 0]
  |  Branch (9061:26): [True: 0, False: 4]
  ------------------
 9062|      0|	return((const xmlChar*) 1);
 9063|      4|    return ret;
 9064|      4|}
parser.c:xmlParseQName:
 9000|      4|xmlParseQName(xmlParserCtxtPtr ctxt, const xmlChar **prefix) {
 9001|      4|    xmlHashedString n, p;
 9002|       |
 9003|      4|    n = xmlParseQNameHashed(ctxt, &p);
 9004|      4|    if (n.name == NULL)
  ------------------
  |  Branch (9004:9): [True: 0, False: 4]
  ------------------
 9005|      0|        return(NULL);
 9006|      4|    *prefix = p.name;
 9007|      4|    return(n.name);
 9008|      4|}
parser.c:xmlParseInternalSubset:
 8533|    544|xmlParseInternalSubset(xmlParserCtxtPtr ctxt) {
 8534|       |    /*
 8535|       |     * Is there any DTD definition ?
 8536|       |     */
 8537|    544|    if (RAW == '[') {
  ------------------
  |  | 2221|    544|#define RAW (*ctxt->input->cur)
  ------------------
  |  Branch (8537:9): [True: 544, False: 0]
  ------------------
 8538|    544|        int baseInputNr = ctxt->inputNr;
 8539|    544|        ctxt->instate = XML_PARSER_DTD;
 8540|    544|        NEXT;
  ------------------
  |  | 2275|    544|#define NEXT xmlNextChar(ctxt)
  ------------------
 8541|       |	/*
 8542|       |	 * Parse the succession of Markup declarations and
 8543|       |	 * PEReferences.
 8544|       |	 * Subsequence (markupdecl | PEReference | S)*
 8545|       |	 */
 8546|    544|	SKIP_BLANKS;
  ------------------
  |  | 2273|    544|#define SKIP_BLANKS xmlSkipBlankChars(ctxt)
  ------------------
 8547|   645k|	while (((RAW != ']') || (ctxt->inputNr > baseInputNr)) &&
  ------------------
  |  | 2221|   645k|#define RAW (*ctxt->input->cur)
  ------------------
  |  Branch (8547:10): [True: 645k, False: 500]
  |  Branch (8547:26): [True: 0, False: 500]
  ------------------
 8548|   645k|               (ctxt->instate != XML_PARSER_EOF)) {
  ------------------
  |  Branch (8548:16): [True: 645k, False: 12]
  ------------------
 8549|       |
 8550|       |            /*
 8551|       |             * Conditional sections are allowed from external entities included
 8552|       |             * by PE References in the internal subset.
 8553|       |             */
 8554|   645k|            if ((ctxt->inputNr > 1) && (ctxt->input->filename != NULL) &&
  ------------------
  |  Branch (8554:17): [True: 641k, False: 3.67k]
  |  Branch (8554:40): [True: 520k, False: 121k]
  ------------------
 8555|   645k|                (RAW == '<') && (NXT(1) == '!') && (NXT(2) == '[')) {
  ------------------
  |  | 2221|   520k|#define RAW (*ctxt->input->cur)
  ------------------
                              (RAW == '<') && (NXT(1) == '!') && (NXT(2) == '[')) {
  ------------------
  |  | 2223|   520k|#define NXT(val) ctxt->input->cur[(val)]
  ------------------
                              (RAW == '<') && (NXT(1) == '!') && (NXT(2) == '[')) {
  ------------------
  |  | 2223|   520k|#define NXT(val) ctxt->input->cur[(val)]
  ------------------
  |  Branch (8555:17): [True: 520k, False: 0]
  |  Branch (8555:33): [True: 520k, False: 0]
  |  Branch (8555:52): [True: 0, False: 520k]
  ------------------
 8556|      0|                xmlParseConditionalSections(ctxt);
 8557|   645k|            } else if ((RAW == '<') && ((NXT(1) == '!') || (NXT(1) == '?'))) {
  ------------------
  |  | 2221|   645k|#define RAW (*ctxt->input->cur)
  ------------------
                          } else if ((RAW == '<') && ((NXT(1) == '!') || (NXT(1) == '?'))) {
  ------------------
  |  | 2223|   645k|#define NXT(val) ctxt->input->cur[(val)]
  ------------------
                          } else if ((RAW == '<') && ((NXT(1) == '!') || (NXT(1) == '?'))) {
  ------------------
  |  | 2223|      8|#define NXT(val) ctxt->input->cur[(val)]
  ------------------
  |  Branch (8557:24): [True: 645k, False: 96]
  |  Branch (8557:41): [True: 645k, False: 8]
  |  Branch (8557:60): [True: 4, False: 4]
  ------------------
 8558|   645k|	        xmlParseMarkupDecl(ctxt);
 8559|   645k|            } else if (RAW == '%') {
  ------------------
  |  | 2221|    100|#define RAW (*ctxt->input->cur)
  ------------------
  |  Branch (8559:24): [True: 68, False: 32]
  ------------------
 8560|     68|	        xmlParsePEReference(ctxt);
 8561|     68|            } else {
 8562|     32|		xmlFatalErr(ctxt, XML_ERR_INTERNAL_ERROR,
 8563|     32|                        "xmlParseInternalSubset: error detected in"
 8564|     32|                        " Markup declaration\n");
 8565|     32|                xmlHaltParser(ctxt);
 8566|     32|                return;
 8567|     32|            }
 8568|   645k|	    SKIP_BLANKS;
  ------------------
  |  | 2273|   645k|#define SKIP_BLANKS xmlSkipBlankChars(ctxt)
  ------------------
 8569|   645k|            SHRINK;
  ------------------
  |  | 2265|   645k|    if (((ctxt->progressive == 0) || (ctxt->inputNr > 1)) && \
  |  |  ------------------
  |  |  |  Branch (2265:10): [True: 322k, False: 322k]
  |  |  |  Branch (2265:38): [True: 320k, False: 1.82k]
  |  |  ------------------
  |  | 2266|   645k|        (ctxt->input->cur - ctxt->input->base > 2 * INPUT_CHUNK) && \
  |  |  ------------------
  |  |  |  |   97|   643k|#define INPUT_CHUNK	250
  |  |  ------------------
  |  |  |  Branch (2266:9): [True: 2.09k, False: 641k]
  |  |  ------------------
  |  | 2267|   645k|	(ctxt->input->end - ctxt->input->cur < 2 * INPUT_CHUNK)) \
  |  |  ------------------
  |  |  |  |   97|  2.09k|#define INPUT_CHUNK	250
  |  |  ------------------
  |  |  |  Branch (2267:2): [True: 40, False: 2.05k]
  |  |  ------------------
  |  | 2268|   645k|	xmlParserShrink(ctxt);
  ------------------
 8570|   645k|            GROW;
  ------------------
  |  | 2270|   645k|#define GROW if (ctxt->input->end - ctxt->input->cur < INPUT_CHUNK)	\
  |  |  ------------------
  |  |  |  |   97|   645k|#define INPUT_CHUNK	250
  |  |  ------------------
  |  |  |  Branch (2270:18): [True: 576k, False: 68.4k]
  |  |  ------------------
  |  | 2271|   645k|	xmlParserGrow(ctxt);
  ------------------
 8571|   645k|	}
 8572|    512|	if (RAW == ']') {
  ------------------
  |  | 2221|    512|#define RAW (*ctxt->input->cur)
  ------------------
  |  Branch (8572:6): [True: 500, False: 12]
  ------------------
 8573|    500|	    NEXT;
  ------------------
  |  | 2275|    500|#define NEXT xmlNextChar(ctxt)
  ------------------
 8574|    500|	    SKIP_BLANKS;
  ------------------
  |  | 2273|    500|#define SKIP_BLANKS xmlSkipBlankChars(ctxt)
  ------------------
 8575|    500|	}
 8576|    512|    }
 8577|       |
 8578|       |    /*
 8579|       |     * We should be at the end of the DOCTYPE declaration.
 8580|       |     */
 8581|    512|    if (RAW != '>') {
  ------------------
  |  | 2221|    512|#define RAW (*ctxt->input->cur)
  ------------------
  |  Branch (8581:9): [True: 12, False: 500]
  ------------------
 8582|     12|	xmlFatalErr(ctxt, XML_ERR_DOCTYPE_NOT_FINISHED, NULL);
 8583|     12|	return;
 8584|     12|    }
 8585|    500|    NEXT;
  ------------------
  |  | 2275|    500|#define NEXT xmlNextChar(ctxt)
  ------------------
 8586|    500|}
parser.c:xmlCleanSpecialAttr:
 1181|    708|{
 1182|    708|    if (ctxt->attsSpecial == NULL)
  ------------------
  |  Branch (1182:9): [True: 548, False: 160]
  ------------------
 1183|    548|        return;
 1184|       |
 1185|    160|    xmlHashScanFull(ctxt->attsSpecial, xmlCleanSpecialAttrCallback, ctxt);
 1186|       |
 1187|    160|    if (xmlHashSize(ctxt->attsSpecial) == 0) {
  ------------------
  |  Branch (1187:9): [True: 52, False: 108]
  ------------------
 1188|     52|        xmlHashFree(ctxt->attsSpecial, NULL);
 1189|     52|        ctxt->attsSpecial = NULL;
 1190|     52|    }
 1191|    160|    return;
 1192|    708|}
parser.c:xmlCleanSpecialAttrCallback:
 1163|  7.05k|                            const xmlChar *unused ATTRIBUTE_UNUSED) {
 1164|  7.05k|    xmlParserCtxtPtr ctxt = (xmlParserCtxtPtr) data;
 1165|       |
 1166|  7.05k|    if (((ptrdiff_t) payload) == XML_ATTRIBUTE_CDATA) {
  ------------------
  |  Branch (1166:9): [True: 2.60k, False: 4.44k]
  ------------------
 1167|  2.60k|        xmlHashRemoveEntry2(ctxt->attsSpecial, fullname, fullattr, NULL);
 1168|  2.60k|    }
 1169|  7.05k|}
parser.c:xmlParseTryOrFinish:
11585|  12.4k|xmlParseTryOrFinish(xmlParserCtxtPtr ctxt, int terminate) {
11586|  12.4k|    int ret = 0;
11587|  12.4k|    size_t avail;
11588|  12.4k|    xmlChar cur, next;
11589|       |
11590|  12.4k|    if (ctxt->input == NULL)
  ------------------
  |  Branch (11590:9): [True: 0, False: 12.4k]
  ------------------
11591|      0|        return(0);
11592|       |
11593|  12.4k|    if ((ctxt->input != NULL) &&
  ------------------
  |  Branch (11593:9): [True: 12.4k, False: 0]
  ------------------
11594|  12.4k|        (ctxt->input->cur - ctxt->input->base > 4096)) {
  ------------------
  |  Branch (11594:9): [True: 388, False: 12.0k]
  ------------------
11595|    388|        xmlParserShrink(ctxt);
11596|    388|    }
11597|       |
11598|   130k|    while (ctxt->instate != XML_PARSER_EOF) {
  ------------------
  |  Branch (11598:12): [True: 130k, False: 10]
  ------------------
11599|   130k|	if ((ctxt->errNo != XML_ERR_OK) && (ctxt->disableSAX == 1))
  ------------------
  |  Branch (11599:6): [True: 77.8k, False: 52.6k]
  |  Branch (11599:37): [True: 28, False: 77.8k]
  ------------------
11600|     28|	    return(0);
11601|       |
11602|   130k|        avail = ctxt->input->end - ctxt->input->cur;
11603|   130k|        if (avail < 1)
  ------------------
  |  Branch (11603:13): [True: 1.27k, False: 129k]
  ------------------
11604|  1.27k|	    goto done;
11605|   129k|        switch (ctxt->instate) {
11606|      0|            case XML_PARSER_EOF:
  ------------------
  |  Branch (11606:13): [True: 0, False: 129k]
  ------------------
11607|       |	        /*
11608|       |		 * Document parsing is done !
11609|       |		 */
11610|      0|	        goto done;
11611|    670|            case XML_PARSER_START:
  ------------------
  |  Branch (11611:13): [True: 670, False: 128k]
  ------------------
11612|       |                /*
11613|       |                 * Very first chars read from the document flow.
11614|       |                 */
11615|    670|                if ((!terminate) && (avail < 4))
  ------------------
  |  Branch (11615:21): [True: 642, False: 28]
  |  Branch (11615:37): [True: 24, False: 618]
  ------------------
11616|     24|                    goto done;
11617|       |
11618|       |                /*
11619|       |                 * We need more bytes to detect EBCDIC code pages.
11620|       |                 * See xmlDetectEBCDIC.
11621|       |                 */
11622|    646|                if ((CMP4(CUR_PTR, 0x4C, 0x6F, 0xA7, 0x94)) &&
  ------------------
  |  | 2228|    646|  ( ((unsigned char *) s)[ 0 ] == c1 && ((unsigned char *) s)[ 1 ] == c2 && \
  |  |  ------------------
  |  |  |  Branch (2228:5): [True: 4, False: 642]
  |  |  |  Branch (2228:41): [True: 4, False: 0]
  |  |  ------------------
  |  | 2229|    646|    ((unsigned char *) s)[ 2 ] == c3 && ((unsigned char *) s)[ 3 ] == c4 )
  |  |  ------------------
  |  |  |  Branch (2229:5): [True: 4, False: 0]
  |  |  |  Branch (2229:41): [True: 4, False: 0]
  |  |  ------------------
  ------------------
11623|    646|                    (!terminate) && (avail < 200))
  ------------------
  |  Branch (11623:21): [True: 2, False: 2]
  |  Branch (11623:37): [True: 2, False: 0]
  ------------------
11624|      2|                    goto done;
11625|       |
11626|    644|                xmlDetectEncoding(ctxt);
11627|    644|                if (ctxt->instate == XML_PARSER_EOF)
  ------------------
  |  Branch (11627:21): [True: 0, False: 644]
  ------------------
11628|      0|                    goto done;
11629|    644|                ctxt->instate = XML_PARSER_XML_DECL;
11630|    644|		break;
11631|       |
11632|    644|            case XML_PARSER_XML_DECL:
  ------------------
  |  Branch (11632:13): [True: 644, False: 128k]
  ------------------
11633|    644|		if ((!terminate) && (avail < 2))
  ------------------
  |  Branch (11633:7): [True: 616, False: 28]
  |  Branch (11633:23): [True: 0, False: 616]
  ------------------
11634|      0|		    goto done;
11635|    644|		cur = ctxt->input->cur[0];
11636|    644|		next = ctxt->input->cur[1];
11637|    644|	        if ((cur == '<') && (next == '?')) {
  ------------------
  |  Branch (11637:14): [True: 626, False: 18]
  |  Branch (11637:30): [True: 332, False: 294]
  ------------------
11638|       |		    /* PI or XML decl */
11639|    332|		    if ((!terminate) &&
  ------------------
  |  Branch (11639:11): [True: 330, False: 2]
  ------------------
11640|    332|                        (!xmlParseLookupString(ctxt, 2, "?>", 2)))
  ------------------
  |  Branch (11640:25): [True: 0, False: 330]
  ------------------
11641|      0|			goto done;
11642|    332|		    if ((ctxt->input->cur[2] == 'x') &&
  ------------------
  |  Branch (11642:11): [True: 328, False: 4]
  ------------------
11643|    332|			(ctxt->input->cur[3] == 'm') &&
  ------------------
  |  Branch (11643:4): [True: 328, False: 0]
  ------------------
11644|    332|			(ctxt->input->cur[4] == 'l') &&
  ------------------
  |  Branch (11644:4): [True: 326, False: 2]
  ------------------
11645|    332|			(IS_BLANK_CH(ctxt->input->cur[5]))) {
  ------------------
  |  |  151|    326|#define IS_BLANK_CH(c)  xmlIsBlank_ch(c)
  |  |  ------------------
  |  |  |  |   88|    326|#define xmlIsBlank_ch(c)	(((c) == 0x20) || \
  |  |  |  |  ------------------
  |  |  |  |  |  Branch (88:27): [True: 326, False: 0]
  |  |  |  |  ------------------
  |  |  |  |   89|    326|				 ((0x9 <= (c)) && ((c) <= 0xa)) || \
  |  |  |  |  ------------------
  |  |  |  |  |  Branch (89:7): [True: 0, False: 0]
  |  |  |  |  |  Branch (89:23): [True: 0, False: 0]
  |  |  |  |  ------------------
  |  |  |  |   90|    326|				 ((c) == 0xd))
  |  |  |  |  ------------------
  |  |  |  |  |  Branch (90:6): [True: 0, False: 0]
  |  |  |  |  ------------------
  |  |  ------------------
  ------------------
11646|    326|			ret += 5;
11647|    326|			xmlParseXMLDecl(ctxt);
11648|    326|			if (ctxt->errNo == XML_ERR_UNSUPPORTED_ENCODING) {
  ------------------
  |  Branch (11648:8): [True: 0, False: 326]
  ------------------
11649|       |			    /*
11650|       |			     * The XML REC instructs us to stop parsing right
11651|       |			     * here
11652|       |			     */
11653|      0|			    xmlHaltParser(ctxt);
11654|      0|			    return(0);
11655|      0|			}
11656|    326|		    } else {
11657|      6|			ctxt->version = xmlCharStrdup(XML_DEFAULT_VERSION);
  ------------------
  |  |   37|      6|#define XML_DEFAULT_VERSION	"1.0"
  ------------------
11658|      6|		    }
11659|    332|		} else {
11660|    312|		    ctxt->version = xmlCharStrdup(XML_DEFAULT_VERSION);
  ------------------
  |  |   37|    312|#define XML_DEFAULT_VERSION	"1.0"
  ------------------
11661|    312|		    if (ctxt->version == NULL) {
  ------------------
  |  Branch (11661:11): [True: 0, False: 312]
  ------------------
11662|      0|		        xmlErrMemory(ctxt, NULL);
11663|      0|			break;
11664|      0|		    }
11665|    312|		}
11666|    644|                if ((ctxt->sax) && (ctxt->sax->setDocumentLocator))
  ------------------
  |  Branch (11666:21): [True: 644, False: 0]
  |  Branch (11666:36): [True: 644, False: 0]
  ------------------
11667|    644|                    ctxt->sax->setDocumentLocator(ctxt->userData,
11668|    644|                                                  &xmlDefaultSAXLocator);
  ------------------
  |  |  861|    644|  #define xmlDefaultSAXLocator XML_GLOBAL_MACRO(xmlDefaultSAXLocator)
  |  |  ------------------
  |  |  |  |  500|    644|  #define XML_GLOBAL_MACRO(name) (*__##name())
  |  |  ------------------
  ------------------
11669|    644|                if ((ctxt->sax) && (ctxt->sax->startDocument) &&
  ------------------
  |  Branch (11669:21): [True: 644, False: 0]
  |  Branch (11669:36): [True: 644, False: 0]
  ------------------
11670|    644|                    (!ctxt->disableSAX))
  ------------------
  |  Branch (11670:21): [True: 644, False: 0]
  ------------------
11671|    644|                    ctxt->sax->startDocument(ctxt->userData);
11672|    644|                if (ctxt->instate == XML_PARSER_EOF)
  ------------------
  |  Branch (11672:21): [True: 0, False: 644]
  ------------------
11673|      0|                    goto done;
11674|    644|                ctxt->instate = XML_PARSER_MISC;
11675|    644|		break;
11676|  34.4k|            case XML_PARSER_START_TAG: {
  ------------------
  |  Branch (11676:13): [True: 34.4k, False: 94.7k]
  ------------------
11677|  34.4k|	        const xmlChar *name;
11678|  34.4k|		const xmlChar *prefix = NULL;
11679|  34.4k|		const xmlChar *URI = NULL;
11680|  34.4k|                int line = ctxt->input->line;
11681|  34.4k|		int nbNs = 0;
11682|       |
11683|  34.4k|		if ((!terminate) && (avail < 2))
  ------------------
  |  Branch (11683:7): [True: 34.4k, False: 42]
  |  Branch (11683:23): [True: 0, False: 34.4k]
  ------------------
11684|      0|		    goto done;
11685|  34.4k|		cur = ctxt->input->cur[0];
11686|  34.4k|	        if (cur != '<') {
  ------------------
  |  Branch (11686:14): [True: 18, False: 34.4k]
  ------------------
11687|     18|		    xmlFatalErrMsg(ctxt, XML_ERR_DOCUMENT_EMPTY,
11688|     18|                                   "Start tag expected, '<' not found");
11689|     18|		    xmlHaltParser(ctxt);
11690|     18|		    if ((ctxt->sax) && (ctxt->sax->endDocument != NULL))
  ------------------
  |  Branch (11690:11): [True: 18, False: 0]
  |  Branch (11690:26): [True: 18, False: 0]
  ------------------
11691|     18|			ctxt->sax->endDocument(ctxt->userData);
11692|     18|		    goto done;
11693|     18|		}
11694|  34.4k|		if ((!terminate) && (!xmlParseLookupGt(ctxt)))
  ------------------
  |  Branch (11694:7): [True: 34.4k, False: 24]
  |  Branch (11694:23): [True: 5.78k, False: 28.6k]
  ------------------
11695|  5.78k|                    goto done;
11696|  28.6k|		if (ctxt->spaceNr == 0)
  ------------------
  |  Branch (11696:7): [True: 0, False: 28.6k]
  ------------------
11697|      0|		    spacePush(ctxt, -1);
11698|  28.6k|		else if (*ctxt->space == -2)
  ------------------
  |  Branch (11698:12): [True: 0, False: 28.6k]
  ------------------
11699|      0|		    spacePush(ctxt, -1);
11700|  28.6k|		else
11701|  28.6k|		    spacePush(ctxt, *ctxt->space);
11702|  28.6k|#ifdef LIBXML_SAX1_ENABLED
11703|  28.6k|		if (ctxt->sax2)
  ------------------
  |  Branch (11703:7): [True: 28.6k, False: 0]
  ------------------
11704|  28.6k|#endif /* LIBXML_SAX1_ENABLED */
11705|  28.6k|		    name = xmlParseStartTag2(ctxt, &prefix, &URI, &nbNs);
11706|      0|#ifdef LIBXML_SAX1_ENABLED
11707|      0|		else
11708|      0|		    name = xmlParseStartTag(ctxt);
11709|  28.6k|#endif /* LIBXML_SAX1_ENABLED */
11710|  28.6k|		if (ctxt->instate == XML_PARSER_EOF)
  ------------------
  |  Branch (11710:7): [True: 10, False: 28.6k]
  ------------------
11711|     10|		    goto done;
11712|  28.6k|		if (name == NULL) {
  ------------------
  |  Branch (11712:7): [True: 16, False: 28.6k]
  ------------------
11713|     16|		    spacePop(ctxt);
11714|     16|		    xmlHaltParser(ctxt);
11715|     16|		    if ((ctxt->sax) && (ctxt->sax->endDocument != NULL))
  ------------------
  |  Branch (11715:11): [True: 16, False: 0]
  |  Branch (11715:26): [True: 16, False: 0]
  ------------------
11716|     16|			ctxt->sax->endDocument(ctxt->userData);
11717|     16|		    goto done;
11718|     16|		}
11719|  28.6k|#ifdef LIBXML_VALID_ENABLED
11720|       |		/*
11721|       |		 * [ VC: Root Element Type ]
11722|       |		 * The Name in the document type declaration must match
11723|       |		 * the element type of the root element.
11724|       |		 */
11725|  28.6k|		if (ctxt->validate && ctxt->wellFormed && ctxt->myDoc &&
  ------------------
  |  Branch (11725:7): [True: 6.92k, False: 21.7k]
  |  Branch (11725:25): [True: 6.91k, False: 12]
  |  Branch (11725:45): [True: 6.91k, False: 0]
  ------------------
11726|  28.6k|		    ctxt->node && (ctxt->node == ctxt->myDoc->children))
  ------------------
  |  Branch (11726:7): [True: 6.91k, False: 0]
  |  Branch (11726:21): [True: 0, False: 6.91k]
  ------------------
11727|      0|		    ctxt->valid &= xmlValidateRoot(&ctxt->vctxt, ctxt->myDoc);
11728|  28.6k|#endif /* LIBXML_VALID_ENABLED */
11729|       |
11730|       |		/*
11731|       |		 * Check for an Empty Element.
11732|       |		 */
11733|  28.6k|		if ((RAW == '/') && (NXT(1) == '>')) {
  ------------------
  |  | 2221|  28.6k|#define RAW (*ctxt->input->cur)
  ------------------
              		if ((RAW == '/') && (NXT(1) == '>')) {
  ------------------
  |  | 2223|  20.3k|#define NXT(val) ctxt->input->cur[(val)]
  ------------------
  |  Branch (11733:7): [True: 20.3k, False: 8.30k]
  |  Branch (11733:23): [True: 20.3k, False: 0]
  ------------------
11734|  20.3k|		    SKIP(2);
  ------------------
  |  | 2245|  20.3k|#define SKIP(val) do {							\
  |  | 2246|  20.3k|    ctxt->input->cur += (val),ctxt->input->col+=(val);			\
  |  | 2247|  20.3k|    if (*ctxt->input->cur == 0)						\
  |  |  ------------------
  |  |  |  Branch (2247:9): [True: 190, False: 20.1k]
  |  |  ------------------
  |  | 2248|  20.3k|        xmlParserGrow(ctxt);						\
  |  | 2249|  20.3k|  } while (0)
  |  |  ------------------
  |  |  |  Branch (2249:12): [Folded - Ignored]
  |  |  ------------------
  ------------------
11735|       |
11736|  20.3k|		    if (ctxt->sax2) {
  ------------------
  |  Branch (11736:11): [True: 20.3k, False: 0]
  ------------------
11737|  20.3k|			if ((ctxt->sax != NULL) &&
  ------------------
  |  Branch (11737:8): [True: 20.3k, False: 0]
  ------------------
11738|  20.3k|			    (ctxt->sax->endElementNs != NULL) &&
  ------------------
  |  Branch (11738:8): [True: 20.3k, False: 0]
  ------------------
11739|  20.3k|			    (!ctxt->disableSAX))
  ------------------
  |  Branch (11739:8): [True: 20.3k, False: 8]
  ------------------
11740|  20.3k|			    ctxt->sax->endElementNs(ctxt->userData, name,
11741|  20.3k|			                            prefix, URI);
11742|  20.3k|			if (nbNs > 0)
  ------------------
  |  Branch (11742:8): [True: 30, False: 20.3k]
  ------------------
11743|     30|			    xmlParserNsPop(ctxt, nbNs);
11744|  20.3k|#ifdef LIBXML_SAX1_ENABLED
11745|  20.3k|		    } else {
11746|      0|			if ((ctxt->sax != NULL) &&
  ------------------
  |  Branch (11746:8): [True: 0, False: 0]
  ------------------
11747|      0|			    (ctxt->sax->endElement != NULL) &&
  ------------------
  |  Branch (11747:8): [True: 0, False: 0]
  ------------------
11748|      0|			    (!ctxt->disableSAX))
  ------------------
  |  Branch (11748:8): [True: 0, False: 0]
  ------------------
11749|      0|			    ctxt->sax->endElement(ctxt->userData, name);
11750|      0|#endif /* LIBXML_SAX1_ENABLED */
11751|      0|		    }
11752|  20.3k|		    spacePop(ctxt);
11753|  20.3k|		} else if (RAW == '>') {
  ------------------
  |  | 2221|  8.30k|#define RAW (*ctxt->input->cur)
  ------------------
  |  Branch (11753:14): [True: 8.29k, False: 12]
  ------------------
11754|  8.29k|		    NEXT;
  ------------------
  |  | 2275|  8.29k|#define NEXT xmlNextChar(ctxt)
  ------------------
11755|  8.29k|                    nameNsPush(ctxt, name, prefix, URI, line, nbNs);
11756|  8.29k|		} else {
11757|     12|		    xmlFatalErrMsgStr(ctxt, XML_ERR_GT_REQUIRED,
11758|     12|					 "Couldn't find end of Start Tag %s\n",
11759|     12|					 name);
11760|     12|		    nodePop(ctxt);
11761|     12|		    spacePop(ctxt);
11762|     12|                    if (nbNs > 0)
  ------------------
  |  Branch (11762:25): [True: 2, False: 10]
  ------------------
11763|      2|                        xmlParserNsPop(ctxt, nbNs);
11764|     12|		}
11765|       |
11766|  28.6k|                if (ctxt->instate == XML_PARSER_EOF)
  ------------------
  |  Branch (11766:21): [True: 0, False: 28.6k]
  ------------------
11767|      0|                    goto done;
11768|  28.6k|                if (ctxt->nameNr == 0)
  ------------------
  |  Branch (11768:21): [True: 118, False: 28.5k]
  ------------------
11769|    118|                    ctxt->instate = XML_PARSER_EPILOG;
11770|  28.5k|                else
11771|  28.5k|                    ctxt->instate = XML_PARSER_CONTENT;
11772|  28.6k|                break;
11773|  28.6k|	    }
11774|  81.2k|            case XML_PARSER_CONTENT: {
  ------------------
  |  Branch (11774:13): [True: 81.2k, False: 47.9k]
  ------------------
11775|  81.2k|		cur = ctxt->input->cur[0];
11776|       |
11777|  81.2k|		if (cur == '<') {
  ------------------
  |  Branch (11777:7): [True: 36.9k, False: 44.3k]
  ------------------
11778|  36.9k|                    if ((!terminate) && (avail < 2))
  ------------------
  |  Branch (11778:25): [True: 36.9k, False: 0]
  |  Branch (11778:41): [True: 181, False: 36.7k]
  ------------------
11779|    181|                        goto done;
11780|  36.7k|		    next = ctxt->input->cur[1];
11781|       |
11782|  36.7k|                    if (next == '/') {
  ------------------
  |  Branch (11782:25): [True: 8.24k, False: 28.4k]
  ------------------
11783|  8.24k|                        ctxt->instate = XML_PARSER_END_TAG;
11784|  8.24k|                        break;
11785|  28.4k|                    } else if (next == '?') {
  ------------------
  |  Branch (11785:32): [True: 16, False: 28.4k]
  ------------------
11786|     16|                        if ((!terminate) &&
  ------------------
  |  Branch (11786:29): [True: 16, False: 0]
  ------------------
11787|     16|                            (!xmlParseLookupString(ctxt, 2, "?>", 2)))
  ------------------
  |  Branch (11787:29): [True: 0, False: 16]
  ------------------
11788|      0|                            goto done;
11789|     16|                        xmlParsePI(ctxt);
11790|     16|                        if (ctxt->instate == XML_PARSER_EOF)
  ------------------
  |  Branch (11790:29): [True: 0, False: 16]
  ------------------
11791|      0|                            goto done;
11792|     16|                        ctxt->instate = XML_PARSER_CONTENT;
11793|     16|                        break;
11794|  28.4k|                    } else if (next == '!') {
  ------------------
  |  Branch (11794:32): [True: 420, False: 28.0k]
  ------------------
11795|    420|                        if ((!terminate) && (avail < 3))
  ------------------
  |  Branch (11795:29): [True: 420, False: 0]
  |  Branch (11795:45): [True: 3, False: 417]
  ------------------
11796|      3|                            goto done;
11797|    417|                        next = ctxt->input->cur[2];
11798|       |
11799|    417|                        if (next == '-') {
  ------------------
  |  Branch (11799:29): [True: 347, False: 70]
  ------------------
11800|    347|                            if ((!terminate) && (avail < 4))
  ------------------
  |  Branch (11800:33): [True: 347, False: 0]
  |  Branch (11800:49): [True: 2, False: 345]
  ------------------
11801|      2|                                goto done;
11802|    345|                            if (ctxt->input->cur[3] == '-') {
  ------------------
  |  Branch (11802:33): [True: 345, False: 0]
  ------------------
11803|    345|                                if ((!terminate) &&
  ------------------
  |  Branch (11803:37): [True: 345, False: 0]
  ------------------
11804|    345|                                    (!xmlParseLookupString(ctxt, 4, "-->", 3)))
  ------------------
  |  Branch (11804:37): [True: 97, False: 248]
  ------------------
11805|     97|                                    goto done;
11806|    248|                                xmlParseComment(ctxt);
11807|    248|                                if (ctxt->instate == XML_PARSER_EOF)
  ------------------
  |  Branch (11807:37): [True: 0, False: 248]
  ------------------
11808|      0|                                    goto done;
11809|    248|                                ctxt->instate = XML_PARSER_CONTENT;
11810|    248|                                break;
11811|    248|                            }
11812|    345|                        } else if (next == '[') {
  ------------------
  |  Branch (11812:36): [True: 68, False: 2]
  ------------------
11813|     68|                            if ((!terminate) && (avail < 9))
  ------------------
  |  Branch (11813:33): [True: 68, False: 0]
  |  Branch (11813:49): [True: 0, False: 68]
  ------------------
11814|      0|                                goto done;
11815|     68|                            if ((ctxt->input->cur[2] == '[') &&
  ------------------
  |  Branch (11815:33): [True: 68, False: 0]
  ------------------
11816|     68|                                (ctxt->input->cur[3] == 'C') &&
  ------------------
  |  Branch (11816:33): [True: 68, False: 0]
  ------------------
11817|     68|                                (ctxt->input->cur[4] == 'D') &&
  ------------------
  |  Branch (11817:33): [True: 68, False: 0]
  ------------------
11818|     68|                                (ctxt->input->cur[5] == 'A') &&
  ------------------
  |  Branch (11818:33): [True: 68, False: 0]
  ------------------
11819|     68|                                (ctxt->input->cur[6] == 'T') &&
  ------------------
  |  Branch (11819:33): [True: 68, False: 0]
  ------------------
11820|     68|                                (ctxt->input->cur[7] == 'A') &&
  ------------------
  |  Branch (11820:33): [True: 68, False: 0]
  ------------------
11821|     68|                                (ctxt->input->cur[8] == '[')) {
  ------------------
  |  Branch (11821:33): [True: 68, False: 0]
  ------------------
11822|     68|                                SKIP(9);
  ------------------
  |  | 2245|     68|#define SKIP(val) do {							\
  |  | 2246|     68|    ctxt->input->cur += (val),ctxt->input->col+=(val);			\
  |  | 2247|     68|    if (*ctxt->input->cur == 0)						\
  |  |  ------------------
  |  |  |  Branch (2247:9): [True: 0, False: 68]
  |  |  ------------------
  |  | 2248|     68|        xmlParserGrow(ctxt);						\
  |  | 2249|     68|  } while (0)
  |  |  ------------------
  |  |  |  Branch (2249:12): [Folded - Ignored]
  |  |  ------------------
  ------------------
11823|     68|                                ctxt->instate = XML_PARSER_CDATA_SECTION;
11824|     68|                                break;
11825|     68|                            }
11826|     68|                        }
11827|    417|                    }
11828|  44.3k|		} else if (cur == '&') {
  ------------------
  |  Branch (11828:14): [True: 5.70k, False: 38.6k]
  ------------------
11829|  5.70k|		    if ((!terminate) && (!xmlParseLookupChar(ctxt, ';')))
  ------------------
  |  Branch (11829:11): [True: 5.70k, False: 0]
  |  Branch (11829:27): [True: 68, False: 5.63k]
  ------------------
11830|     68|			goto done;
11831|  5.63k|		    xmlParseReference(ctxt);
11832|  5.63k|                    break;
11833|  38.6k|		} else {
11834|       |		    /* TODO Avoid the extra copy, handle directly !!! */
11835|       |		    /*
11836|       |		     * Goal of the following test is:
11837|       |		     *  - minimize calls to the SAX 'character' callback
11838|       |		     *    when they are mergeable
11839|       |		     *  - handle an problem for isBlank when we only parse
11840|       |		     *    a sequence of blank chars and the next one is
11841|       |		     *    not available to check against '<' presence.
11842|       |		     *  - tries to homogenize the differences in SAX
11843|       |		     *    callbacks between the push and pull versions
11844|       |		     *    of the parser.
11845|       |		     */
11846|  38.6k|		    if (avail < XML_PARSER_BIG_BUFFER_SIZE) {
  ------------------
  |  |  166|  38.6k|#define XML_PARSER_BIG_BUFFER_SIZE 300
  ------------------
  |  Branch (11846:11): [True: 30.7k, False: 7.90k]
  ------------------
11847|  30.7k|			if ((!terminate) && (!xmlParseLookupCharData(ctxt)))
  ------------------
  |  Branch (11847:8): [True: 30.7k, False: 2]
  |  Branch (11847:24): [True: 2.49k, False: 28.2k]
  ------------------
11848|  2.49k|			    goto done;
11849|  30.7k|                    }
11850|  36.1k|                    ctxt->checkIndex = 0;
11851|  36.1k|		    xmlParseCharDataInternal(ctxt, !terminate);
11852|  36.1k|                    break;
11853|  38.6k|		}
11854|       |
11855|  28.0k|                ctxt->instate = XML_PARSER_START_TAG;
11856|  28.0k|		break;
11857|  81.2k|	    }
11858|  8.44k|            case XML_PARSER_END_TAG:
  ------------------
  |  Branch (11858:13): [True: 8.44k, False: 120k]
  ------------------
11859|  8.44k|		if ((!terminate) && (!xmlParseLookupChar(ctxt, '>')))
  ------------------
  |  Branch (11859:7): [True: 8.44k, False: 2]
  |  Branch (11859:23): [True: 200, False: 8.24k]
  ------------------
11860|    200|		    goto done;
11861|  8.24k|		if (ctxt->sax2) {
  ------------------
  |  Branch (11861:7): [True: 8.24k, False: 0]
  ------------------
11862|  8.24k|	            xmlParseEndTag2(ctxt, &ctxt->pushTab[ctxt->nameNr - 1]);
11863|  8.24k|		    nameNsPop(ctxt);
11864|  8.24k|		}
11865|      0|#ifdef LIBXML_SAX1_ENABLED
11866|      0|		  else
11867|      0|		    xmlParseEndTag1(ctxt, 0);
11868|  8.24k|#endif /* LIBXML_SAX1_ENABLED */
11869|  8.24k|                if (ctxt->instate == XML_PARSER_EOF)
  ------------------
  |  Branch (11869:21): [True: 0, False: 8.24k]
  ------------------
11870|      0|                    goto done;
11871|  8.24k|		if (ctxt->nameNr == 0) {
  ------------------
  |  Branch (11871:7): [True: 426, False: 7.82k]
  ------------------
11872|    426|		    ctxt->instate = XML_PARSER_EPILOG;
11873|  7.82k|		} else {
11874|  7.82k|		    ctxt->instate = XML_PARSER_CONTENT;
11875|  7.82k|		}
11876|  8.24k|		break;
11877|    247|            case XML_PARSER_CDATA_SECTION: {
  ------------------
  |  Branch (11877:13): [True: 247, False: 128k]
  ------------------
11878|       |	        /*
11879|       |		 * The Push mode need to have the SAX callback for
11880|       |		 * cdataBlock merge back contiguous callbacks.
11881|       |		 */
11882|    247|		const xmlChar *term;
11883|       |
11884|    247|                if (terminate) {
  ------------------
  |  Branch (11884:21): [True: 0, False: 247]
  ------------------
11885|       |                    /*
11886|       |                     * Don't call xmlParseLookupString. If 'terminate'
11887|       |                     * is set, checkIndex is invalid.
11888|       |                     */
11889|      0|                    term = BAD_CAST strstr((const char *) ctxt->input->cur,
  ------------------
  |  |   35|      0|#define BAD_CAST (xmlChar *)
  ------------------
11890|      0|                                           "]]>");
11891|    247|                } else {
11892|    247|		    term = xmlParseLookupString(ctxt, 0, "]]>", 3);
11893|    247|                }
11894|       |
11895|    247|		if (term == NULL) {
  ------------------
  |  Branch (11895:7): [True: 179, False: 68]
  ------------------
11896|    179|		    int tmp, size;
11897|       |
11898|    179|                    if (terminate) {
  ------------------
  |  Branch (11898:25): [True: 0, False: 179]
  ------------------
11899|       |                        /* Unfinished CDATA section */
11900|      0|                        size = ctxt->input->end - ctxt->input->cur;
11901|    179|                    } else {
11902|    179|                        if (avail < XML_PARSER_BIG_BUFFER_SIZE + 2)
  ------------------
  |  |  166|    179|#define XML_PARSER_BIG_BUFFER_SIZE 300
  ------------------
  |  Branch (11902:29): [True: 129, False: 50]
  ------------------
11903|    129|                            goto done;
11904|     50|                        ctxt->checkIndex = 0;
11905|       |                        /* XXX: Why don't we pass the full buffer? */
11906|     50|                        size = XML_PARSER_BIG_BUFFER_SIZE;
  ------------------
  |  |  166|     50|#define XML_PARSER_BIG_BUFFER_SIZE 300
  ------------------
11907|     50|                    }
11908|     50|                    tmp = xmlCheckCdataPush(ctxt->input->cur, size, 0);
11909|     50|                    if (tmp <= 0) {
  ------------------
  |  Branch (11909:25): [True: 0, False: 50]
  ------------------
11910|      0|                        tmp = -tmp;
11911|      0|                        ctxt->input->cur += tmp;
11912|      0|                        goto encoding_error;
11913|      0|                    }
11914|     50|                    if ((ctxt->sax != NULL) && (!ctxt->disableSAX)) {
  ------------------
  |  Branch (11914:25): [True: 50, False: 0]
  |  Branch (11914:48): [True: 50, False: 0]
  ------------------
11915|     50|                        if (ctxt->sax->cdataBlock != NULL)
  ------------------
  |  Branch (11915:29): [True: 50, False: 0]
  ------------------
11916|     50|                            ctxt->sax->cdataBlock(ctxt->userData,
11917|     50|                                                  ctxt->input->cur, tmp);
11918|      0|                        else if (ctxt->sax->characters != NULL)
  ------------------
  |  Branch (11918:34): [True: 0, False: 0]
  ------------------
11919|      0|                            ctxt->sax->characters(ctxt->userData,
11920|      0|                                                  ctxt->input->cur, tmp);
11921|     50|                    }
11922|     50|                    if (ctxt->instate == XML_PARSER_EOF)
  ------------------
  |  Branch (11922:25): [True: 0, False: 50]
  ------------------
11923|      0|                        goto done;
11924|     50|                    SKIPL(tmp);
  ------------------
  |  | 2251|     50|#define SKIPL(val) do {							\
  |  | 2252|     50|    int skipl;								\
  |  | 2253|  15.0k|    for(skipl=0; skipl<val; skipl++) {					\
  |  |  ------------------
  |  |  |  Branch (2253:18): [True: 14.9k, False: 50]
  |  |  ------------------
  |  | 2254|  14.9k|	if (*(ctxt->input->cur) == '\n') {				\
  |  |  ------------------
  |  |  |  Branch (2254:6): [True: 0, False: 14.9k]
  |  |  ------------------
  |  | 2255|      0|	ctxt->input->line++; ctxt->input->col = 1;			\
  |  | 2256|  14.9k|	} else ctxt->input->col++;					\
  |  | 2257|  14.9k|	ctxt->input->cur++;						\
  |  | 2258|  14.9k|    }									\
  |  | 2259|     50|    if (*ctxt->input->cur == 0)						\
  |  |  ------------------
  |  |  |  Branch (2259:9): [True: 0, False: 50]
  |  |  ------------------
  |  | 2260|     50|        xmlParserGrow(ctxt);						\
  |  | 2261|     50|  } while (0)
  |  |  ------------------
  |  |  |  Branch (2261:12): [Folded - Ignored]
  |  |  ------------------
  ------------------
11925|     68|		} else {
11926|     68|                    int base = term - CUR_PTR;
  ------------------
  |  | 2224|     68|#define CUR_PTR ctxt->input->cur
  ------------------
11927|     68|		    int tmp;
11928|       |
11929|     68|		    tmp = xmlCheckCdataPush(ctxt->input->cur, base, 1);
11930|     68|		    if ((tmp < 0) || (tmp != base)) {
  ------------------
  |  Branch (11930:11): [True: 4, False: 64]
  |  Branch (11930:24): [True: 0, False: 64]
  ------------------
11931|      4|			tmp = -tmp;
11932|      4|			ctxt->input->cur += tmp;
11933|      4|			goto encoding_error;
11934|      4|		    }
11935|     64|		    if ((ctxt->sax != NULL) && (base == 0) &&
  ------------------
  |  Branch (11935:11): [True: 64, False: 0]
  |  Branch (11935:34): [True: 2, False: 62]
  ------------------
11936|     64|		        (ctxt->sax->cdataBlock != NULL) &&
  ------------------
  |  Branch (11936:11): [True: 2, False: 0]
  ------------------
11937|     64|		        (!ctxt->disableSAX)) {
  ------------------
  |  Branch (11937:11): [True: 2, False: 0]
  ------------------
11938|       |			/*
11939|       |			 * Special case to provide identical behaviour
11940|       |			 * between pull and push parsers on enpty CDATA
11941|       |			 * sections
11942|       |			 */
11943|      2|			 if ((ctxt->input->cur - ctxt->input->base >= 9) &&
  ------------------
  |  Branch (11943:9): [True: 2, False: 0]
  ------------------
11944|      2|			     (!strncmp((const char *)&ctxt->input->cur[-9],
  ------------------
  |  Branch (11944:9): [True: 2, False: 0]
  ------------------
11945|      2|			               "<![CDATA[", 9)))
11946|      2|			     ctxt->sax->cdataBlock(ctxt->userData,
11947|      2|			                           BAD_CAST "", 0);
  ------------------
  |  |   35|      2|#define BAD_CAST (xmlChar *)
  ------------------
11948|     62|		    } else if ((ctxt->sax != NULL) && (base > 0) &&
  ------------------
  |  Branch (11948:18): [True: 62, False: 0]
  |  Branch (11948:41): [True: 62, False: 0]
  ------------------
11949|     62|			(!ctxt->disableSAX)) {
  ------------------
  |  Branch (11949:4): [True: 62, False: 0]
  ------------------
11950|     62|			if (ctxt->sax->cdataBlock != NULL)
  ------------------
  |  Branch (11950:8): [True: 62, False: 0]
  ------------------
11951|     62|			    ctxt->sax->cdataBlock(ctxt->userData,
11952|     62|						  ctxt->input->cur, base);
11953|      0|			else if (ctxt->sax->characters != NULL)
  ------------------
  |  Branch (11953:13): [True: 0, False: 0]
  ------------------
11954|      0|			    ctxt->sax->characters(ctxt->userData,
11955|      0|						  ctxt->input->cur, base);
11956|     62|		    }
11957|     64|		    if (ctxt->instate == XML_PARSER_EOF)
  ------------------
  |  Branch (11957:11): [True: 0, False: 64]
  ------------------
11958|      0|			goto done;
11959|     64|		    SKIPL(base + 3);
  ------------------
  |  | 2251|     64|#define SKIPL(val) do {							\
  |  | 2252|     64|    int skipl;								\
  |  | 2253|  11.5k|    for(skipl=0; skipl<val; skipl++) {					\
  |  |  ------------------
  |  |  |  Branch (2253:18): [True: 11.4k, False: 64]
  |  |  ------------------
  |  | 2254|  11.4k|	if (*(ctxt->input->cur) == '\n') {				\
  |  |  ------------------
  |  |  |  Branch (2254:6): [True: 120, False: 11.3k]
  |  |  ------------------
  |  | 2255|    120|	ctxt->input->line++; ctxt->input->col = 1;			\
  |  | 2256|  11.3k|	} else ctxt->input->col++;					\
  |  | 2257|  11.4k|	ctxt->input->cur++;						\
  |  | 2258|  11.4k|    }									\
  |  | 2259|     64|    if (*ctxt->input->cur == 0)						\
  |  |  ------------------
  |  |  |  Branch (2259:9): [True: 0, False: 64]
  |  |  ------------------
  |  | 2260|     64|        xmlParserGrow(ctxt);						\
  |  | 2261|     64|  } while (0)
  |  |  ------------------
  |  |  |  Branch (2261:12): [Folded - Ignored]
  |  |  ------------------
  ------------------
11960|     64|		    ctxt->instate = XML_PARSER_CONTENT;
11961|     64|		}
11962|    114|		break;
11963|    247|	    }
11964|    930|            case XML_PARSER_MISC:
  ------------------
  |  Branch (11964:13): [True: 930, False: 128k]
  ------------------
11965|  1.31k|            case XML_PARSER_PROLOG:
  ------------------
  |  Branch (11965:13): [True: 388, False: 128k]
  ------------------
11966|  1.85k|            case XML_PARSER_EPILOG:
  ------------------
  |  Branch (11966:13): [True: 532, False: 128k]
  ------------------
11967|  1.85k|		SKIP_BLANKS;
  ------------------
  |  | 2273|  1.85k|#define SKIP_BLANKS xmlSkipBlankChars(ctxt)
  ------------------
11968|  1.85k|                avail = ctxt->input->end - ctxt->input->cur;
11969|  1.85k|		if (avail < 1)
  ------------------
  |  Branch (11969:7): [True: 517, False: 1.33k]
  ------------------
11970|    517|		    goto done;
11971|  1.33k|		if (ctxt->input->cur[0] == '<') {
  ------------------
  |  Branch (11971:7): [True: 1.31k, False: 20]
  ------------------
11972|  1.31k|                    if ((!terminate) && (avail < 2))
  ------------------
  |  Branch (11972:25): [True: 1.30k, False: 10]
  |  Branch (11972:41): [True: 0, False: 1.30k]
  ------------------
11973|      0|                        goto done;
11974|  1.31k|                    next = ctxt->input->cur[1];
11975|  1.31k|                    if (next == '?') {
  ------------------
  |  Branch (11975:25): [True: 28, False: 1.28k]
  ------------------
11976|     28|                        if ((!terminate) &&
  ------------------
  |  Branch (11976:29): [True: 28, False: 0]
  ------------------
11977|     28|                            (!xmlParseLookupString(ctxt, 2, "?>", 2)))
  ------------------
  |  Branch (11977:29): [True: 2, False: 26]
  ------------------
11978|      2|                            goto done;
11979|     26|                        xmlParsePI(ctxt);
11980|     26|                        if (ctxt->instate == XML_PARSER_EOF)
  ------------------
  |  Branch (11980:29): [True: 0, False: 26]
  ------------------
11981|      0|                            goto done;
11982|     26|                        break;
11983|  1.28k|                    } else if (next == '!') {
  ------------------
  |  Branch (11983:32): [True: 695, False: 590]
  ------------------
11984|    695|                        if ((!terminate) && (avail < 3))
  ------------------
  |  Branch (11984:29): [True: 695, False: 0]
  |  Branch (11984:45): [True: 0, False: 695]
  ------------------
11985|      0|                            goto done;
11986|       |
11987|    695|                        if (ctxt->input->cur[2] == '-') {
  ------------------
  |  Branch (11987:29): [True: 158, False: 537]
  ------------------
11988|    158|                            if ((!terminate) && (avail < 4))
  ------------------
  |  Branch (11988:33): [True: 158, False: 0]
  |  Branch (11988:49): [True: 0, False: 158]
  ------------------
11989|      0|                                goto done;
11990|    158|                            if (ctxt->input->cur[3] == '-') {
  ------------------
  |  Branch (11990:33): [True: 158, False: 0]
  ------------------
11991|    158|                                if ((!terminate) &&
  ------------------
  |  Branch (11991:37): [True: 158, False: 0]
  ------------------
11992|    158|                                    (!xmlParseLookupString(ctxt, 4, "-->", 3)))
  ------------------
  |  Branch (11992:37): [True: 102, False: 56]
  ------------------
11993|    102|                                    goto done;
11994|     56|                                xmlParseComment(ctxt);
11995|     56|                                if (ctxt->instate == XML_PARSER_EOF)
  ------------------
  |  Branch (11995:37): [True: 0, False: 56]
  ------------------
11996|      0|                                    goto done;
11997|     56|                                break;
11998|     56|                            }
11999|    537|                        } else if (ctxt->instate == XML_PARSER_MISC) {
  ------------------
  |  Branch (11999:36): [True: 537, False: 0]
  ------------------
12000|    537|                            if ((!terminate) && (avail < 9))
  ------------------
  |  Branch (12000:33): [True: 537, False: 0]
  |  Branch (12000:49): [True: 0, False: 537]
  ------------------
12001|      0|                                goto done;
12002|    537|                            if ((ctxt->input->cur[2] == 'D') &&
  ------------------
  |  Branch (12002:33): [True: 533, False: 4]
  ------------------
12003|    537|                                (ctxt->input->cur[3] == 'O') &&
  ------------------
  |  Branch (12003:33): [True: 533, False: 0]
  ------------------
12004|    537|                                (ctxt->input->cur[4] == 'C') &&
  ------------------
  |  Branch (12004:33): [True: 533, False: 0]
  ------------------
12005|    537|                                (ctxt->input->cur[5] == 'T') &&
  ------------------
  |  Branch (12005:33): [True: 533, False: 0]
  ------------------
12006|    537|                                (ctxt->input->cur[6] == 'Y') &&
  ------------------
  |  Branch (12006:33): [True: 533, False: 0]
  ------------------
12007|    537|                                (ctxt->input->cur[7] == 'P') &&
  ------------------
  |  Branch (12007:33): [True: 533, False: 0]
  ------------------
12008|    537|                                (ctxt->input->cur[8] == 'E')) {
  ------------------
  |  Branch (12008:33): [True: 533, False: 0]
  ------------------
12009|    533|                                if ((!terminate) && (!xmlParseLookupGt(ctxt)))
  ------------------
  |  Branch (12009:37): [True: 533, False: 0]
  |  Branch (12009:53): [True: 153, False: 380]
  ------------------
12010|    153|                                    goto done;
12011|    380|                                ctxt->inSubset = 1;
12012|    380|                                xmlParseDocTypeDecl(ctxt);
12013|    380|                                if (ctxt->instate == XML_PARSER_EOF)
  ------------------
  |  Branch (12013:37): [True: 0, False: 380]
  ------------------
12014|      0|                                    goto done;
12015|    380|                                if (RAW == '[') {
  ------------------
  |  | 2221|    380|#define RAW (*ctxt->input->cur)
  ------------------
  |  Branch (12015:37): [True: 272, False: 108]
  ------------------
12016|    272|                                    ctxt->instate = XML_PARSER_DTD;
12017|    272|                                } else {
12018|       |                                    /*
12019|       |                                     * Create and update the external subset.
12020|       |                                     */
12021|    108|                                    ctxt->inSubset = 2;
12022|    108|                                    if ((ctxt->sax != NULL) &&
  ------------------
  |  Branch (12022:41): [True: 108, False: 0]
  ------------------
12023|    108|                                        (!ctxt->disableSAX) &&
  ------------------
  |  Branch (12023:41): [True: 108, False: 0]
  ------------------
12024|    108|                                        (ctxt->sax->externalSubset != NULL))
  ------------------
  |  Branch (12024:41): [True: 108, False: 0]
  ------------------
12025|    108|                                        ctxt->sax->externalSubset(
12026|    108|                                                ctxt->userData,
12027|    108|                                                ctxt->intSubName,
12028|    108|                                                ctxt->extSubSystem,
12029|    108|                                                ctxt->extSubURI);
12030|    108|                                    ctxt->inSubset = 0;
12031|    108|                                    xmlCleanSpecialAttr(ctxt);
12032|    108|                                    if (ctxt->instate == XML_PARSER_EOF)
  ------------------
  |  Branch (12032:41): [True: 8, False: 100]
  ------------------
12033|      8|                                        goto done;
12034|    100|                                    ctxt->instate = XML_PARSER_PROLOG;
12035|    100|                                }
12036|    372|                                break;
12037|    380|                            }
12038|    537|                        }
12039|    695|                    }
12040|  1.31k|                }
12041|       |
12042|    614|                if (ctxt->instate == XML_PARSER_EPILOG) {
  ------------------
  |  Branch (12042:21): [True: 2, False: 612]
  ------------------
12043|      2|                    if (ctxt->errNo == XML_ERR_OK)
  ------------------
  |  Branch (12043:25): [True: 0, False: 2]
  ------------------
12044|      0|                        xmlFatalErr(ctxt, XML_ERR_DOCUMENT_END, NULL);
12045|      2|		    ctxt->instate = XML_PARSER_EOF;
12046|      2|                    if ((ctxt->sax) && (ctxt->sax->endDocument != NULL))
  ------------------
  |  Branch (12046:25): [True: 2, False: 0]
  |  Branch (12046:40): [True: 2, False: 0]
  ------------------
12047|      2|                        ctxt->sax->endDocument(ctxt->userData);
12048|    612|                } else {
12049|    612|		    ctxt->instate = XML_PARSER_START_TAG;
12050|    612|		}
12051|    614|		break;
12052|  1.59k|            case XML_PARSER_DTD: {
  ------------------
  |  Branch (12052:13): [True: 1.59k, False: 127k]
  ------------------
12053|  1.59k|                if ((!terminate) && (!xmlParseLookupInternalSubset(ctxt)))
  ------------------
  |  Branch (12053:21): [True: 1.58k, False: 10]
  |  Branch (12053:37): [True: 1.32k, False: 262]
  ------------------
12054|  1.32k|                    goto done;
12055|    272|		xmlParseInternalSubset(ctxt);
12056|    272|		if (ctxt->instate == XML_PARSER_EOF)
  ------------------
  |  Branch (12056:7): [True: 22, False: 250]
  ------------------
12057|     22|		    goto done;
12058|    250|		ctxt->inSubset = 2;
12059|    250|		if ((ctxt->sax != NULL) && (!ctxt->disableSAX) &&
  ------------------
  |  Branch (12059:7): [True: 250, False: 0]
  |  Branch (12059:30): [True: 250, False: 0]
  ------------------
12060|    250|		    (ctxt->sax->externalSubset != NULL))
  ------------------
  |  Branch (12060:7): [True: 250, False: 0]
  ------------------
12061|    250|		    ctxt->sax->externalSubset(ctxt->userData, ctxt->intSubName,
12062|    250|			    ctxt->extSubSystem, ctxt->extSubURI);
12063|    250|		ctxt->inSubset = 0;
12064|    250|		xmlCleanSpecialAttr(ctxt);
12065|    250|		if (ctxt->instate == XML_PARSER_EOF)
  ------------------
  |  Branch (12065:7): [True: 0, False: 250]
  ------------------
12066|      0|		    goto done;
12067|    250|		ctxt->instate = XML_PARSER_PROLOG;
12068|    250|                break;
12069|    250|	    }
12070|      0|            default:
  ------------------
  |  Branch (12070:13): [True: 0, False: 129k]
  ------------------
12071|      0|		xmlGenericError(xmlGenericErrorContext,
  ------------------
  |  |  875|      0|  #define xmlGenericError XML_GLOBAL_MACRO(xmlGenericError)
  |  |  ------------------
  |  |  |  |  500|      0|  #define XML_GLOBAL_MACRO(name) (*__##name())
  |  |  ------------------
  ------------------
              		xmlGenericError(xmlGenericErrorContext,
  ------------------
  |  |  876|      0|  #define xmlGenericErrorContext XML_GLOBAL_MACRO(xmlGenericErrorContext)
  |  |  ------------------
  |  |  |  |  500|      0|  #define XML_GLOBAL_MACRO(name) (*__##name())
  |  |  ------------------
  ------------------
12072|      0|			"PP: internal error\n");
12073|      0|		ctxt->instate = XML_PARSER_EOF;
12074|      0|		break;
12075|   129k|	}
12076|   129k|    }
12077|  12.4k|done:
12078|  12.4k|    return(ret);
12079|      4|encoding_error:
12080|      4|    if (ctxt->input->end - ctxt->input->cur < 4) {
  ------------------
  |  Branch (12080:9): [True: 0, False: 4]
  ------------------
12081|      0|	__xmlErrEncoding(ctxt, XML_ERR_INVALID_CHAR,
12082|      0|		     "Input is not proper UTF-8, indicate encoding !\n",
12083|      0|		     NULL, NULL);
12084|      4|    } else {
12085|      4|        char buffer[150];
12086|       |
12087|      4|	snprintf(buffer, 149, "Bytes: 0x%02X 0x%02X 0x%02X 0x%02X\n",
12088|      4|			ctxt->input->cur[0], ctxt->input->cur[1],
12089|      4|			ctxt->input->cur[2], ctxt->input->cur[3]);
12090|      4|	__xmlErrEncoding(ctxt, XML_ERR_INVALID_CHAR,
12091|      4|		     "Input is not proper UTF-8, indicate encoding !\n%s",
12092|      4|		     BAD_CAST buffer, NULL);
  ------------------
  |  |   35|      4|#define BAD_CAST (xmlChar *)
  ------------------
12093|      4|    }
12094|      4|    return(0);
12095|  12.4k|}
parser.c:xmlParseLookupString:
11292|  1.12k|                     const char *str, size_t strLen) {
11293|  1.12k|    const xmlChar *cur, *term;
11294|       |
11295|  1.12k|    if (ctxt->checkIndex == 0) {
  ------------------
  |  Branch (11295:9): [True: 795, False: 329]
  ------------------
11296|    795|        cur = ctxt->input->cur + startDelta;
11297|    795|    } else {
11298|    329|        cur = ctxt->input->cur + ctxt->checkIndex;
11299|    329|    }
11300|       |
11301|  1.12k|    term = BAD_CAST strstr((const char *) cur, str);
  ------------------
  |  |   35|  1.12k|#define BAD_CAST (xmlChar *)
  ------------------
11302|  1.12k|    if (term == NULL) {
  ------------------
  |  Branch (11302:9): [True: 380, False: 744]
  ------------------
11303|    380|        const xmlChar *end = ctxt->input->end;
11304|    380|        size_t index;
11305|       |
11306|       |        /* Rescan (strLen - 1) characters. */
11307|    380|        if ((size_t) (end - cur) < strLen)
  ------------------
  |  Branch (11307:13): [True: 1, False: 379]
  ------------------
11308|      1|            end = cur;
11309|    379|        else
11310|    379|            end -= strLen - 1;
11311|    380|        index = end - ctxt->input->cur;
11312|    380|        if (index > LONG_MAX) {
  ------------------
  |  Branch (11312:13): [True: 0, False: 380]
  ------------------
11313|      0|            ctxt->checkIndex = 0;
11314|      0|            return(ctxt->input->end - strLen);
11315|      0|        }
11316|    380|        ctxt->checkIndex = index;
11317|    744|    } else {
11318|    744|        ctxt->checkIndex = 0;
11319|    744|    }
11320|       |
11321|  1.12k|    return(term);
11322|  1.12k|}
parser.c:xmlParseLookupGt:
11361|  34.9k|xmlParseLookupGt(xmlParserCtxtPtr ctxt) {
11362|  34.9k|    const xmlChar *cur;
11363|  34.9k|    const xmlChar *end = ctxt->input->end;
11364|  34.9k|    int state = ctxt->endCheckState;
11365|  34.9k|    size_t index;
11366|       |
11367|  34.9k|    if (ctxt->checkIndex == 0)
  ------------------
  |  Branch (11367:9): [True: 29.0k, False: 5.91k]
  ------------------
11368|  29.0k|        cur = ctxt->input->cur + 1;
11369|  5.91k|    else
11370|  5.91k|        cur = ctxt->input->cur + ctxt->checkIndex;
11371|       |
11372|  1.28M|    while (cur < end) {
  ------------------
  |  Branch (11372:12): [True: 1.27M, False: 5.93k]
  ------------------
11373|  1.27M|        if (state) {
  ------------------
  |  Branch (11373:13): [True: 649k, False: 628k]
  ------------------
11374|   649k|            if (*cur == state)
  ------------------
  |  Branch (11374:17): [True: 43.5k, False: 605k]
  ------------------
11375|  43.5k|                state = 0;
11376|   649k|        } else if (*cur == '\'' || *cur == '"') {
  ------------------
  |  Branch (11376:20): [True: 1.71k, False: 626k]
  |  Branch (11376:36): [True: 41.8k, False: 584k]
  ------------------
11377|  43.5k|            state = *cur;
11378|   584k|        } else if (*cur == '>') {
  ------------------
  |  Branch (11378:20): [True: 29.0k, False: 555k]
  ------------------
11379|  29.0k|            ctxt->checkIndex = 0;
11380|  29.0k|            ctxt->endCheckState = 0;
11381|  29.0k|            return(1);
11382|  29.0k|        }
11383|  1.24M|        cur++;
11384|  1.24M|    }
11385|       |
11386|  5.93k|    index = cur - ctxt->input->cur;
11387|  5.93k|    if (index > LONG_MAX) {
  ------------------
  |  Branch (11387:9): [True: 0, False: 5.93k]
  ------------------
11388|      0|        ctxt->checkIndex = 0;
11389|      0|        ctxt->endCheckState = 0;
11390|      0|        return(1);
11391|      0|    }
11392|  5.93k|    ctxt->checkIndex = index;
11393|  5.93k|    ctxt->endCheckState = state;
11394|  5.93k|    return(0);
11395|  5.93k|}
parser.c:xmlParseLookupChar:
11257|  14.1k|xmlParseLookupChar(xmlParserCtxtPtr ctxt, int c) {
11258|  14.1k|    const xmlChar *cur;
11259|       |
11260|  14.1k|    if (ctxt->checkIndex == 0) {
  ------------------
  |  Branch (11260:9): [True: 13.8k, False: 266]
  ------------------
11261|  13.8k|        cur = ctxt->input->cur + 1;
11262|  13.8k|    } else {
11263|    266|        cur = ctxt->input->cur + ctxt->checkIndex;
11264|    266|    }
11265|       |
11266|  14.1k|    if (memchr(cur, c, ctxt->input->end - cur) == NULL) {
  ------------------
  |  Branch (11266:9): [True: 268, False: 13.8k]
  ------------------
11267|    268|        size_t index = ctxt->input->end - ctxt->input->cur;
11268|       |
11269|    268|        if (index > LONG_MAX) {
  ------------------
  |  Branch (11269:13): [True: 0, False: 268]
  ------------------
11270|      0|            ctxt->checkIndex = 0;
11271|      0|            return(1);
11272|      0|        }
11273|    268|        ctxt->checkIndex = index;
11274|    268|        return(0);
11275|  13.8k|    } else {
11276|  13.8k|        ctxt->checkIndex = 0;
11277|  13.8k|        return(1);
11278|  13.8k|    }
11279|  14.1k|}
parser.c:xmlParseLookupCharData:
11331|  30.7k|xmlParseLookupCharData(xmlParserCtxtPtr ctxt) {
11332|  30.7k|    const xmlChar *cur = ctxt->input->cur + ctxt->checkIndex;
11333|  30.7k|    const xmlChar *end = ctxt->input->end;
11334|  30.7k|    size_t index;
11335|       |
11336|   416k|    while (cur < end) {
  ------------------
  |  Branch (11336:12): [True: 414k, False: 2.49k]
  ------------------
11337|   414k|        if ((*cur == '<') || (*cur == '&')) {
  ------------------
  |  Branch (11337:13): [True: 27.2k, False: 386k]
  |  Branch (11337:30): [True: 993, False: 385k]
  ------------------
11338|  28.2k|            ctxt->checkIndex = 0;
11339|  28.2k|            return(1);
11340|  28.2k|        }
11341|   385k|        cur++;
11342|   385k|    }
11343|       |
11344|  2.49k|    index = cur - ctxt->input->cur;
11345|  2.49k|    if (index > LONG_MAX) {
  ------------------
  |  Branch (11345:9): [True: 0, False: 2.49k]
  ------------------
11346|      0|        ctxt->checkIndex = 0;
11347|      0|        return(1);
11348|      0|    }
11349|  2.49k|    ctxt->checkIndex = index;
11350|  2.49k|    return(0);
11351|  2.49k|}
parser.c:nameNsPop:
 2076|  8.24k|{
 2077|  8.24k|    const xmlChar *ret;
 2078|       |
 2079|  8.24k|    if (ctxt->nameNr <= 0)
  ------------------
  |  Branch (2079:9): [True: 0, False: 8.24k]
  ------------------
 2080|      0|        return (NULL);
 2081|  8.24k|    ctxt->nameNr--;
 2082|  8.24k|    if (ctxt->nameNr > 0)
  ------------------
  |  Branch (2082:9): [True: 7.82k, False: 426]
  ------------------
 2083|  7.82k|        ctxt->name = ctxt->nameTab[ctxt->nameNr - 1];
 2084|    426|    else
 2085|    426|        ctxt->name = NULL;
 2086|  8.24k|    ret = ctxt->nameTab[ctxt->nameNr];
 2087|  8.24k|    ctxt->nameTab[ctxt->nameNr] = NULL;
 2088|  8.24k|    return (ret);
 2089|  8.24k|}
parser.c:xmlCheckCdataPush:
11519|    118|xmlCheckCdataPush(const xmlChar *utf, int len, int complete) {
11520|    118|    int ix;
11521|    118|    unsigned char c;
11522|    118|    int codepoint;
11523|       |
11524|    118|    if ((utf == NULL) || (len <= 0))
  ------------------
  |  Branch (11524:9): [True: 0, False: 118]
  |  Branch (11524:26): [True: 2, False: 116]
  ------------------
11525|      2|        return(0);
11526|       |
11527|  11.9k|    for (ix = 0; ix < len;) {      /* string is 0-terminated */
  ------------------
  |  Branch (11527:18): [True: 11.8k, False: 100]
  ------------------
11528|  11.8k|        c = utf[ix];
11529|  11.8k|        if ((c & 0x80) == 0x00) {	/* 1-byte code, starts with 10 */
  ------------------
  |  Branch (11529:13): [True: 4.65k, False: 7.22k]
  ------------------
11530|  4.65k|	    if (c >= 0x20)
  ------------------
  |  Branch (11530:10): [True: 4.52k, False: 128]
  ------------------
11531|  4.52k|		ix++;
11532|    128|	    else if ((c == 0xA) || (c == 0xD) || (c == 0x9))
  ------------------
  |  Branch (11532:15): [True: 120, False: 8]
  |  Branch (11532:29): [True: 8, False: 0]
  |  Branch (11532:43): [True: 0, False: 0]
  ------------------
11533|    128|	        ix++;
11534|      0|	    else
11535|      0|	        return(-ix);
11536|  7.22k|	} else if ((c & 0xe0) == 0xc0) {/* 2-byte code, starts with 110 */
  ------------------
  |  Branch (11536:13): [True: 2.40k, False: 4.81k]
  ------------------
11537|  2.40k|	    if (ix + 2 > len) return(complete ? -ix : ix);
  ------------------
  |  Branch (11537:10): [True: 2, False: 2.40k]
  |  Branch (11537:31): [True: 0, False: 2]
  ------------------
11538|  2.40k|	    if ((utf[ix+1] & 0xc0 ) != 0x80)
  ------------------
  |  Branch (11538:10): [True: 0, False: 2.40k]
  ------------------
11539|      0|	        return(-ix);
11540|  2.40k|	    codepoint = (utf[ix] & 0x1f) << 6;
11541|  2.40k|	    codepoint |= utf[ix+1] & 0x3f;
11542|  2.40k|	    if (!xmlIsCharQ(codepoint))
  ------------------
  |  |  118|  2.40k|#define xmlIsCharQ(c)		(((c) < 0x100) ? \
  |  |  ------------------
  |  |  |  Branch (118:25): [True: 4, False: 2.40k]
  |  |  ------------------
  |  |  119|  2.40k|				 xmlIsChar_ch((c)) :\
  |  |  ------------------
  |  |  |  |  108|      4|#define xmlIsChar_ch(c)		(((0x9 <= (c)) && ((c) <= 0xa)) || \
  |  |  |  |  ------------------
  |  |  |  |  |  Branch (108:28): [True: 4, False: 0]
  |  |  |  |  |  Branch (108:44): [True: 0, False: 4]
  |  |  |  |  ------------------
  |  |  |  |  109|      4|				 ((c) == 0xd) || \
  |  |  |  |  ------------------
  |  |  |  |  |  Branch (109:6): [True: 0, False: 4]
  |  |  |  |  ------------------
  |  |  |  |  110|      4|				  (0x20 <= (c)))
  |  |  |  |  ------------------
  |  |  |  |  |  Branch (110:7): [True: 4, False: 0]
  |  |  |  |  ------------------
  |  |  ------------------
  |  |  120|  2.40k|				(((0x100 <= (c)) && ((c) <= 0xd7ff)) || \
  |  |  ------------------
  |  |  |  Branch (120:7): [True: 2.40k, False: 0]
  |  |  |  Branch (120:25): [True: 2.40k, False: 0]
  |  |  ------------------
  |  |  121|  2.40k|				 ((0xe000 <= (c)) && ((c) <= 0xfffd)) || \
  |  |  ------------------
  |  |  |  Branch (121:7): [True: 0, False: 0]
  |  |  |  Branch (121:26): [True: 0, False: 0]
  |  |  ------------------
  |  |  122|  2.40k|				 ((0x10000 <= (c)) && ((c) <= 0x10ffff))))
  |  |  ------------------
  |  |  |  Branch (122:7): [True: 0, False: 0]
  |  |  |  Branch (122:27): [True: 0, False: 0]
  |  |  ------------------
  ------------------
  |  Branch (11542:10): [True: 0, False: 2.40k]
  ------------------
11543|      0|	        return(-ix);
11544|  2.40k|	    ix += 2;
11545|  4.81k|	} else if ((c & 0xf0) == 0xe0) {/* 3-byte code, starts with 1110 */
  ------------------
  |  Branch (11545:13): [True: 2.40k, False: 2.40k]
  ------------------
11546|  2.40k|	    if (ix + 3 > len) return(complete ? -ix : ix);
  ------------------
  |  Branch (11546:10): [True: 8, False: 2.40k]
  |  Branch (11546:31): [True: 4, False: 4]
  ------------------
11547|  2.40k|	    if (((utf[ix+1] & 0xc0) != 0x80) ||
  ------------------
  |  Branch (11547:10): [True: 0, False: 2.40k]
  ------------------
11548|  2.40k|	        ((utf[ix+2] & 0xc0) != 0x80))
  ------------------
  |  Branch (11548:10): [True: 0, False: 2.40k]
  ------------------
11549|      0|		    return(-ix);
11550|  2.40k|	    codepoint = (utf[ix] & 0xf) << 12;
11551|  2.40k|	    codepoint |= (utf[ix+1] & 0x3f) << 6;
11552|  2.40k|	    codepoint |= utf[ix+2] & 0x3f;
11553|  2.40k|	    if (!xmlIsCharQ(codepoint))
  ------------------
  |  |  118|  2.40k|#define xmlIsCharQ(c)		(((c) < 0x100) ? \
  |  |  ------------------
  |  |  |  Branch (118:25): [True: 0, False: 2.40k]
  |  |  ------------------
  |  |  119|  2.40k|				 xmlIsChar_ch((c)) :\
  |  |  ------------------
  |  |  |  |  108|      0|#define xmlIsChar_ch(c)		(((0x9 <= (c)) && ((c) <= 0xa)) || \
  |  |  |  |  ------------------
  |  |  |  |  |  Branch (108:28): [True: 0, False: 0]
  |  |  |  |  |  Branch (108:44): [True: 0, False: 0]
  |  |  |  |  ------------------
  |  |  |  |  109|      0|				 ((c) == 0xd) || \
  |  |  |  |  ------------------
  |  |  |  |  |  Branch (109:6): [True: 0, False: 0]
  |  |  |  |  ------------------
  |  |  |  |  110|      0|				  (0x20 <= (c)))
  |  |  |  |  ------------------
  |  |  |  |  |  Branch (110:7): [True: 0, False: 0]
  |  |  |  |  ------------------
  |  |  ------------------
  |  |  120|  2.40k|				(((0x100 <= (c)) && ((c) <= 0xd7ff)) || \
  |  |  ------------------
  |  |  |  Branch (120:7): [True: 2.40k, False: 0]
  |  |  |  Branch (120:25): [True: 2.40k, False: 0]
  |  |  ------------------
  |  |  121|  2.40k|				 ((0xe000 <= (c)) && ((c) <= 0xfffd)) || \
  |  |  ------------------
  |  |  |  Branch (121:7): [True: 0, False: 0]
  |  |  |  Branch (121:26): [True: 0, False: 0]
  |  |  ------------------
  |  |  122|  2.40k|				 ((0x10000 <= (c)) && ((c) <= 0x10ffff))))
  |  |  ------------------
  |  |  |  Branch (122:7): [True: 0, False: 0]
  |  |  |  Branch (122:27): [True: 0, False: 0]
  |  |  ------------------
  ------------------
  |  Branch (11553:10): [True: 0, False: 2.40k]
  ------------------
11554|      0|	        return(-ix);
11555|  2.40k|	    ix += 3;
11556|  2.40k|	} else if ((c & 0xf8) == 0xf0) {/* 4-byte code, starts with 11110 */
  ------------------
  |  Branch (11556:13): [True: 2.40k, False: 0]
  ------------------
11557|  2.40k|	    if (ix + 4 > len) return(complete ? -ix : ix);
  ------------------
  |  Branch (11557:10): [True: 6, False: 2.40k]
  |  Branch (11557:31): [True: 0, False: 6]
  ------------------
11558|  2.40k|	    if (((utf[ix+1] & 0xc0) != 0x80) ||
  ------------------
  |  Branch (11558:10): [True: 0, False: 2.40k]
  ------------------
11559|  2.40k|	        ((utf[ix+2] & 0xc0) != 0x80) ||
  ------------------
  |  Branch (11559:10): [True: 0, False: 2.40k]
  ------------------
11560|  2.40k|		((utf[ix+3] & 0xc0) != 0x80))
  ------------------
  |  Branch (11560:3): [True: 0, False: 2.40k]
  ------------------
11561|      0|		    return(-ix);
11562|  2.40k|	    codepoint = (utf[ix] & 0x7) << 18;
11563|  2.40k|	    codepoint |= (utf[ix+1] & 0x3f) << 12;
11564|  2.40k|	    codepoint |= (utf[ix+2] & 0x3f) << 6;
11565|  2.40k|	    codepoint |= utf[ix+3] & 0x3f;
11566|  2.40k|	    if (!xmlIsCharQ(codepoint))
  ------------------
  |  |  118|  2.40k|#define xmlIsCharQ(c)		(((c) < 0x100) ? \
  |  |  ------------------
  |  |  |  Branch (118:25): [True: 0, False: 2.40k]
  |  |  ------------------
  |  |  119|  2.40k|				 xmlIsChar_ch((c)) :\
  |  |  ------------------
  |  |  |  |  108|      0|#define xmlIsChar_ch(c)		(((0x9 <= (c)) && ((c) <= 0xa)) || \
  |  |  |  |  ------------------
  |  |  |  |  |  Branch (108:28): [True: 0, False: 0]
  |  |  |  |  |  Branch (108:44): [True: 0, False: 0]
  |  |  |  |  ------------------
  |  |  |  |  109|      0|				 ((c) == 0xd) || \
  |  |  |  |  ------------------
  |  |  |  |  |  Branch (109:6): [True: 0, False: 0]
  |  |  |  |  ------------------
  |  |  |  |  110|      0|				  (0x20 <= (c)))
  |  |  |  |  ------------------
  |  |  |  |  |  Branch (110:7): [True: 0, False: 0]
  |  |  |  |  ------------------
  |  |  ------------------
  |  |  120|  2.40k|				(((0x100 <= (c)) && ((c) <= 0xd7ff)) || \
  |  |  ------------------
  |  |  |  Branch (120:7): [True: 2.40k, False: 0]
  |  |  |  Branch (120:25): [True: 0, False: 2.40k]
  |  |  ------------------
  |  |  121|  2.40k|				 ((0xe000 <= (c)) && ((c) <= 0xfffd)) || \
  |  |  ------------------
  |  |  |  Branch (121:7): [True: 2.40k, False: 0]
  |  |  |  Branch (121:26): [True: 0, False: 2.40k]
  |  |  ------------------
  |  |  122|  2.40k|				 ((0x10000 <= (c)) && ((c) <= 0x10ffff))))
  |  |  ------------------
  |  |  |  Branch (122:7): [True: 2.40k, False: 0]
  |  |  |  Branch (122:27): [True: 2.40k, False: 0]
  |  |  ------------------
  ------------------
  |  Branch (11566:10): [True: 0, False: 2.40k]
  ------------------
11567|      0|	        return(-ix);
11568|  2.40k|	    ix += 4;
11569|  2.40k|	} else				/* unknown encoding */
11570|      0|	    return(-ix);
11571|  11.8k|      }
11572|    100|      return(ix);
11573|    116|}
parser.c:xmlParseLookupInternalSubset:
11405|  1.58k|xmlParseLookupInternalSubset(xmlParserCtxtPtr ctxt) {
11406|       |    /*
11407|       |     * Sorry, but progressive parsing of the internal subset is not
11408|       |     * supported. We first check that the full content of the internal
11409|       |     * subset is available and parsing is launched only at that point.
11410|       |     * Internal subset ends with "']' S? '>'" in an unescaped section and
11411|       |     * not in a ']]>' sequence which are conditional sections.
11412|       |     */
11413|  1.58k|    const xmlChar *cur, *start;
11414|  1.58k|    const xmlChar *end = ctxt->input->end;
11415|  1.58k|    int state = ctxt->endCheckState;
11416|  1.58k|    size_t index;
11417|       |
11418|  1.58k|    if (ctxt->checkIndex == 0) {
  ------------------
  |  Branch (11418:9): [True: 272, False: 1.31k]
  ------------------
11419|    272|        cur = ctxt->input->cur + 1;
11420|  1.31k|    } else {
11421|  1.31k|        cur = ctxt->input->cur + ctxt->checkIndex;
11422|  1.31k|    }
11423|  1.58k|    start = cur;
11424|       |
11425|   307k|    while (cur < end) {
  ------------------
  |  Branch (11425:12): [True: 306k, False: 1.32k]
  ------------------
11426|   306k|        if (state == '-') {
  ------------------
  |  Branch (11426:13): [True: 28.0k, False: 278k]
  ------------------
11427|  28.0k|            if ((*cur == '-') &&
  ------------------
  |  Branch (11427:17): [True: 496, False: 27.6k]
  ------------------
11428|  28.0k|                (cur[1] == '-') &&
  ------------------
  |  Branch (11428:17): [True: 298, False: 198]
  ------------------
11429|  28.0k|                (cur[2] == '>')) {
  ------------------
  |  Branch (11429:17): [True: 296, False: 2]
  ------------------
11430|    296|                state = 0;
11431|    296|                cur += 3;
11432|    296|                start = cur;
11433|    296|                continue;
11434|    296|            }
11435|  28.0k|        }
11436|   278k|        else if (state == ']') {
  ------------------
  |  Branch (11436:18): [True: 262, False: 278k]
  ------------------
11437|    262|            if (*cur == '>') {
  ------------------
  |  Branch (11437:17): [True: 258, False: 4]
  ------------------
11438|    258|                ctxt->checkIndex = 0;
11439|    258|                ctxt->endCheckState = 0;
11440|    258|                return(1);
11441|    258|            }
11442|      4|            if (IS_BLANK_CH(*cur)) {
  ------------------
  |  |  151|      4|#define IS_BLANK_CH(c)  xmlIsBlank_ch(c)
  |  |  ------------------
  |  |  |  |   88|      4|#define xmlIsBlank_ch(c)	(((c) == 0x20) || \
  |  |  |  |  ------------------
  |  |  |  |  |  Branch (88:27): [True: 4, False: 0]
  |  |  |  |  ------------------
  |  |  |  |   89|      4|				 ((0x9 <= (c)) && ((c) <= 0xa)) || \
  |  |  |  |  ------------------
  |  |  |  |  |  Branch (89:7): [True: 0, False: 0]
  |  |  |  |  |  Branch (89:23): [True: 0, False: 0]
  |  |  |  |  ------------------
  |  |  |  |   90|      4|				 ((c) == 0xd))
  |  |  |  |  ------------------
  |  |  |  |  |  Branch (90:6): [True: 0, False: 0]
  |  |  |  |  ------------------
  |  |  ------------------
  ------------------
11443|      4|                state = ' ';
11444|      4|            } else if (*cur != ']') {
  ------------------
  |  Branch (11444:24): [True: 0, False: 0]
  ------------------
11445|      0|                state = 0;
11446|      0|                start = cur;
11447|      0|                continue;
11448|      0|            }
11449|      4|        }
11450|   278k|        else if (state == ' ') {
  ------------------
  |  Branch (11450:18): [True: 10, False: 278k]
  ------------------
11451|     10|            if (*cur == '>') {
  ------------------
  |  Branch (11451:17): [True: 4, False: 6]
  ------------------
11452|      4|                ctxt->checkIndex = 0;
11453|      4|                ctxt->endCheckState = 0;
11454|      4|                return(1);
11455|      4|            }
11456|      6|            if (!IS_BLANK_CH(*cur)) {
  ------------------
  |  |  151|      6|#define IS_BLANK_CH(c)  xmlIsBlank_ch(c)
  |  |  ------------------
  |  |  |  |   88|      6|#define xmlIsBlank_ch(c)	(((c) == 0x20) || \
  |  |  |  |  ------------------
  |  |  |  |  |  Branch (88:27): [True: 6, False: 0]
  |  |  |  |  ------------------
  |  |  |  |   89|      6|				 ((0x9 <= (c)) && ((c) <= 0xa)) || \
  |  |  |  |  ------------------
  |  |  |  |  |  Branch (89:7): [True: 0, False: 0]
  |  |  |  |  |  Branch (89:23): [True: 0, False: 0]
  |  |  |  |  ------------------
  |  |  |  |   90|      6|				 ((c) == 0xd))
  |  |  |  |  ------------------
  |  |  |  |  |  Branch (90:6): [True: 0, False: 0]
  |  |  |  |  ------------------
  |  |  ------------------
  ------------------
11457|      0|                state = 0;
11458|      0|                start = cur;
11459|      0|                continue;
11460|      0|            }
11461|      6|        }
11462|   278k|        else if (state != 0) {
  ------------------
  |  Branch (11462:18): [True: 202k, False: 75.8k]
  ------------------
11463|   202k|            if (*cur == state) {
  ------------------
  |  Branch (11463:17): [True: 1.46k, False: 201k]
  ------------------
11464|  1.46k|                state = 0;
11465|  1.46k|                start = cur + 1;
11466|  1.46k|            }
11467|   202k|        }
11468|  75.8k|        else if (*cur == '<') {
  ------------------
  |  Branch (11468:18): [True: 1.82k, False: 73.9k]
  ------------------
11469|  1.82k|            if ((cur[1] == '!') &&
  ------------------
  |  Branch (11469:17): [True: 1.81k, False: 11]
  ------------------
11470|  1.82k|                (cur[2] == '-') &&
  ------------------
  |  Branch (11470:17): [True: 299, False: 1.51k]
  ------------------
11471|  1.82k|                (cur[3] == '-')) {
  ------------------
  |  Branch (11471:17): [True: 296, False: 3]
  ------------------
11472|    296|                state = '-';
11473|    296|                cur += 4;
11474|       |                /* Don't treat <!--> as comment */
11475|    296|                start = cur;
11476|    296|                continue;
11477|    296|            }
11478|  1.82k|        }
11479|  73.9k|        else if ((*cur == '"') || (*cur == '\'') || (*cur == ']')) {
  ------------------
  |  Branch (11479:18): [True: 770, False: 73.2k]
  |  Branch (11479:35): [True: 690, False: 72.5k]
  |  Branch (11479:53): [True: 262, False: 72.2k]
  ------------------
11480|  1.72k|            state = *cur;
11481|  1.72k|        }
11482|       |
11483|   305k|        cur++;
11484|   305k|    }
11485|       |
11486|       |    /*
11487|       |     * Rescan the three last characters to detect "<!--" and "-->"
11488|       |     * split across chunks.
11489|       |     */
11490|  1.32k|    if ((state == 0) || (state == '-')) {
  ------------------
  |  Branch (11490:9): [True: 235, False: 1.09k]
  |  Branch (11490:25): [True: 114, False: 976]
  ------------------
11491|    349|        if (cur - start < 3)
  ------------------
  |  Branch (11491:13): [True: 31, False: 318]
  ------------------
11492|     31|            cur = start;
11493|    318|        else
11494|    318|            cur -= 3;
11495|    349|    }
11496|  1.32k|    index = cur - ctxt->input->cur;
11497|  1.32k|    if (index > LONG_MAX) {
  ------------------
  |  Branch (11497:9): [True: 0, False: 1.32k]
  ------------------
11498|      0|        ctxt->checkIndex = 0;
11499|      0|        ctxt->endCheckState = 0;
11500|      0|        return(1);
11501|      0|    }
11502|  1.32k|    ctxt->checkIndex = index;
11503|  1.32k|    ctxt->endCheckState = state;
11504|  1.32k|    return(0);
11505|  1.32k|}
parser.c:xmlParseExternalEntityPrivate:
12653|     40|		      const xmlChar *ID, xmlNodePtr *list) {
12654|     40|    xmlParserCtxtPtr ctxt;
12655|     40|    xmlDocPtr newDoc;
12656|     40|    xmlNodePtr newRoot;
12657|     40|    xmlParserErrors ret = XML_ERR_OK;
12658|       |
12659|     40|    if (((depth > 40) &&
  ------------------
  |  Branch (12659:10): [True: 0, False: 40]
  ------------------
12660|     40|	((oldctxt == NULL) || (oldctxt->options & XML_PARSE_HUGE) == 0)) ||
  ------------------
  |  Branch (12660:3): [True: 0, False: 0]
  |  Branch (12660:24): [True: 0, False: 0]
  ------------------
12661|     40|	(depth > 100)) {
  ------------------
  |  Branch (12661:2): [True: 0, False: 40]
  ------------------
12662|      0|	xmlFatalErrMsg(oldctxt, XML_ERR_ENTITY_LOOP,
12663|      0|                       "Maximum entity nesting depth exceeded");
12664|      0|        return(XML_ERR_ENTITY_LOOP);
12665|      0|    }
12666|       |
12667|     40|    if (list != NULL)
  ------------------
  |  Branch (12667:9): [True: 40, False: 0]
  ------------------
12668|     40|        *list = NULL;
12669|     40|    if ((URL == NULL) && (ID == NULL))
  ------------------
  |  Branch (12669:9): [True: 0, False: 40]
  |  Branch (12669:26): [True: 0, False: 0]
  ------------------
12670|      0|	return(XML_ERR_INTERNAL_ERROR);
12671|     40|    if (doc == NULL)
  ------------------
  |  Branch (12671:9): [True: 0, False: 40]
  ------------------
12672|      0|	return(XML_ERR_INTERNAL_ERROR);
12673|       |
12674|     40|    ctxt = xmlCreateEntityParserCtxtInternal(sax, user_data, URL, ID, NULL,
12675|     40|                                             oldctxt);
12676|     40|    if (ctxt == NULL) return(XML_WAR_UNDECLARED_ENTITY);
  ------------------
  |  Branch (12676:9): [True: 4, False: 36]
  ------------------
12677|     36|    if (oldctxt != NULL) {
  ------------------
  |  Branch (12677:9): [True: 36, False: 0]
  ------------------
12678|     36|        ctxt->nbErrors = oldctxt->nbErrors;
12679|     36|        ctxt->nbWarnings = oldctxt->nbWarnings;
12680|     36|    }
12681|     36|    xmlDetectSAX2(ctxt);
12682|       |
12683|     36|    newDoc = xmlNewDoc(BAD_CAST "1.0");
  ------------------
  |  |   35|     36|#define BAD_CAST (xmlChar *)
  ------------------
12684|     36|    if (newDoc == NULL) {
  ------------------
  |  Branch (12684:9): [True: 0, False: 36]
  ------------------
12685|      0|	xmlFreeParserCtxt(ctxt);
12686|      0|	return(XML_ERR_INTERNAL_ERROR);
12687|      0|    }
12688|     36|    newDoc->properties = XML_DOC_INTERNAL;
12689|     36|    if (doc) {
  ------------------
  |  Branch (12689:9): [True: 36, False: 0]
  ------------------
12690|     36|        newDoc->intSubset = doc->intSubset;
12691|     36|        newDoc->extSubset = doc->extSubset;
12692|     36|        if (doc->dict) {
  ------------------
  |  Branch (12692:13): [True: 36, False: 0]
  ------------------
12693|     36|            newDoc->dict = doc->dict;
12694|     36|            xmlDictReference(newDoc->dict);
12695|     36|        }
12696|     36|        if (doc->URL != NULL) {
  ------------------
  |  Branch (12696:13): [True: 27, False: 9]
  ------------------
12697|     27|            newDoc->URL = xmlStrdup(doc->URL);
12698|     27|        }
12699|     36|    }
12700|     36|    newRoot = xmlNewDocNode(newDoc, NULL, BAD_CAST "pseudoroot", NULL);
  ------------------
  |  |   35|     36|#define BAD_CAST (xmlChar *)
  ------------------
12701|     36|    if (newRoot == NULL) {
  ------------------
  |  Branch (12701:9): [True: 0, False: 36]
  ------------------
12702|      0|	if (sax != NULL)
  ------------------
  |  Branch (12702:6): [True: 0, False: 0]
  ------------------
12703|      0|	xmlFreeParserCtxt(ctxt);
12704|      0|	newDoc->intSubset = NULL;
12705|      0|	newDoc->extSubset = NULL;
12706|      0|        xmlFreeDoc(newDoc);
12707|      0|	return(XML_ERR_INTERNAL_ERROR);
12708|      0|    }
12709|     36|    xmlAddChild((xmlNodePtr) newDoc, newRoot);
12710|     36|    nodePush(ctxt, newDoc->children);
12711|     36|    if (doc == NULL) {
  ------------------
  |  Branch (12711:9): [True: 0, False: 36]
  ------------------
12712|      0|        ctxt->myDoc = newDoc;
12713|     36|    } else {
12714|     36|        ctxt->myDoc = doc;
12715|     36|        newRoot->doc = doc;
12716|     36|    }
12717|       |
12718|     36|    xmlDetectEncoding(ctxt);
12719|       |
12720|       |    /*
12721|       |     * Parse a possible text declaration first
12722|       |     */
12723|     36|    if ((CMP5(CUR_PTR, '<', '?', 'x', 'm', 'l')) && (IS_BLANK_CH(NXT(5)))) {
  ------------------
  |  | 2231|     36|  ( CMP4( s, c1, c2, c3, c4 ) && ((unsigned char *) s)[ 4 ] == c5 )
  |  |  ------------------
  |  |  |  | 2228|     72|  ( ((unsigned char *) s)[ 0 ] == c1 && ((unsigned char *) s)[ 1 ] == c2 && \
  |  |  |  |  ------------------
  |  |  |  |  |  Branch (2228:5): [True: 16, False: 20]
  |  |  |  |  |  Branch (2228:41): [True: 4, False: 12]
  |  |  |  |  ------------------
  |  |  |  | 2229|     36|    ((unsigned char *) s)[ 2 ] == c3 && ((unsigned char *) s)[ 3 ] == c4 )
  |  |  |  |  ------------------
  |  |  |  |  |  Branch (2229:5): [True: 4, False: 0]
  |  |  |  |  |  Branch (2229:41): [True: 4, False: 0]
  |  |  |  |  ------------------
  |  |  ------------------
  |  |  |  Branch (2231:34): [True: 4, False: 0]
  |  |  ------------------
  ------------------
                  if ((CMP5(CUR_PTR, '<', '?', 'x', 'm', 'l')) && (IS_BLANK_CH(NXT(5)))) {
  ------------------
  |  |  151|      4|#define IS_BLANK_CH(c)  xmlIsBlank_ch(c)
  |  |  ------------------
  |  |  |  |   88|      4|#define xmlIsBlank_ch(c)	(((c) == 0x20) || \
  |  |  |  |  ------------------
  |  |  |  |  |  Branch (88:27): [True: 4, False: 0]
  |  |  |  |  ------------------
  |  |  |  |   89|      4|				 ((0x9 <= (c)) && ((c) <= 0xa)) || \
  |  |  |  |  ------------------
  |  |  |  |  |  Branch (89:7): [True: 0, False: 0]
  |  |  |  |  |  Branch (89:23): [True: 0, False: 0]
  |  |  |  |  ------------------
  |  |  |  |   90|      4|				 ((c) == 0xd))
  |  |  |  |  ------------------
  |  |  |  |  |  Branch (90:6): [True: 0, False: 0]
  |  |  |  |  ------------------
  |  |  ------------------
  ------------------
12724|      4|	xmlParseTextDecl(ctxt);
12725|       |        /*
12726|       |         * An XML-1.0 document can't reference an entity not XML-1.0
12727|       |         */
12728|      4|        if ((xmlStrEqual(oldctxt->version, BAD_CAST "1.0")) &&
  ------------------
  |  |   35|      4|#define BAD_CAST (xmlChar *)
  ------------------
  |  Branch (12728:13): [True: 4, False: 0]
  ------------------
12729|      4|            (!xmlStrEqual(ctxt->input->version, BAD_CAST "1.0"))) {
  ------------------
  |  |   35|      4|#define BAD_CAST (xmlChar *)
  ------------------
  |  Branch (12729:13): [True: 0, False: 4]
  ------------------
12730|      0|            xmlFatalErrMsg(ctxt, XML_ERR_VERSION_MISMATCH,
12731|      0|                           "Version mismatch between document and entity\n");
12732|      0|        }
12733|      4|    }
12734|       |
12735|     36|    ctxt->instate = XML_PARSER_CONTENT;
12736|     36|    ctxt->depth = depth;
12737|     36|    if (oldctxt != NULL) {
  ------------------
  |  Branch (12737:9): [True: 36, False: 0]
  ------------------
12738|     36|	ctxt->_private = oldctxt->_private;
12739|     36|	ctxt->loadsubset = oldctxt->loadsubset;
12740|     36|	ctxt->validate = oldctxt->validate;
12741|     36|	ctxt->valid = oldctxt->valid;
12742|     36|	ctxt->replaceEntities = oldctxt->replaceEntities;
12743|     36|        if (oldctxt->validate) {
  ------------------
  |  Branch (12743:13): [True: 27, False: 9]
  ------------------
12744|     27|            ctxt->vctxt.error = oldctxt->vctxt.error;
12745|     27|            ctxt->vctxt.warning = oldctxt->vctxt.warning;
12746|     27|            ctxt->vctxt.userData = oldctxt->vctxt.userData;
12747|     27|            ctxt->vctxt.flags = oldctxt->vctxt.flags;
12748|     27|        }
12749|     36|	ctxt->external = oldctxt->external;
12750|     36|        if (ctxt->dict) xmlDictFree(ctxt->dict);
  ------------------
  |  Branch (12750:13): [True: 36, False: 0]
  ------------------
12751|     36|        ctxt->dict = oldctxt->dict;
12752|     36|        ctxt->str_xml = xmlDictLookup(ctxt->dict, BAD_CAST "xml", 3);
  ------------------
  |  |   35|     36|#define BAD_CAST (xmlChar *)
  ------------------
12753|     36|        ctxt->str_xmlns = xmlDictLookup(ctxt->dict, BAD_CAST "xmlns", 5);
  ------------------
  |  |   35|     36|#define BAD_CAST (xmlChar *)
  ------------------
12754|     36|        ctxt->str_xml_ns = xmlDictLookup(ctxt->dict, XML_XML_NAMESPACE, 36);
  ------------------
  |  |  143|     36|    (const xmlChar *) "http://www.w3.org/XML/1998/namespace"
  ------------------
12755|     36|        ctxt->dictNames = oldctxt->dictNames;
12756|     36|        ctxt->attsDefault = oldctxt->attsDefault;
12757|     36|        ctxt->attsSpecial = oldctxt->attsSpecial;
12758|     36|        ctxt->linenumbers = oldctxt->linenumbers;
12759|     36|	ctxt->record_info = oldctxt->record_info;
12760|     36|	ctxt->node_seq.maximum = oldctxt->node_seq.maximum;
12761|     36|	ctxt->node_seq.length = oldctxt->node_seq.length;
12762|     36|	ctxt->node_seq.buffer = oldctxt->node_seq.buffer;
12763|     36|    } else {
12764|       |	/*
12765|       |	 * Doing validity checking on chunk without context
12766|       |	 * doesn't make sense
12767|       |	 */
12768|      0|	ctxt->_private = NULL;
12769|      0|	ctxt->validate = 0;
12770|      0|	ctxt->external = 2;
12771|      0|	ctxt->loadsubset = 0;
12772|      0|    }
12773|       |
12774|     36|    xmlParseContent(ctxt);
12775|       |
12776|     36|    if ((RAW == '<') && (NXT(1) == '/')) {
  ------------------
  |  | 2221|     36|#define RAW (*ctxt->input->cur)
  ------------------
                  if ((RAW == '<') && (NXT(1) == '/')) {
  ------------------
  |  | 2223|      0|#define NXT(val) ctxt->input->cur[(val)]
  ------------------
  |  Branch (12776:9): [True: 0, False: 36]
  |  Branch (12776:25): [True: 0, False: 0]
  ------------------
12777|      0|	xmlFatalErr(ctxt, XML_ERR_NOT_WELL_BALANCED, NULL);
12778|     36|    } else if (RAW != 0) {
  ------------------
  |  | 2221|     36|#define RAW (*ctxt->input->cur)
  ------------------
  |  Branch (12778:16): [True: 0, False: 36]
  ------------------
12779|      0|	xmlFatalErr(ctxt, XML_ERR_EXTRA_CONTENT, NULL);
12780|      0|    }
12781|     36|    if (ctxt->node != newDoc->children) {
  ------------------
  |  Branch (12781:9): [True: 4, False: 32]
  ------------------
12782|      4|	xmlFatalErr(ctxt, XML_ERR_NOT_WELL_BALANCED, NULL);
12783|      4|    }
12784|       |
12785|     36|    if (!ctxt->wellFormed) {
  ------------------
  |  Branch (12785:9): [True: 16, False: 20]
  ------------------
12786|     16|	ret = (xmlParserErrors)ctxt->errNo;
12787|     16|        if (oldctxt != NULL) {
  ------------------
  |  Branch (12787:13): [True: 16, False: 0]
  ------------------
12788|     16|            oldctxt->errNo = ctxt->errNo;
12789|     16|            oldctxt->wellFormed = 0;
12790|     16|            xmlCopyError(&ctxt->lastError, &oldctxt->lastError);
12791|     16|        }
12792|     20|    } else {
12793|     20|	if (list != NULL) {
  ------------------
  |  Branch (12793:6): [True: 20, False: 0]
  ------------------
12794|     20|	    xmlNodePtr cur;
12795|       |
12796|       |	    /*
12797|       |	     * Return the newly created nodeset after unlinking it from
12798|       |	     * they pseudo parent.
12799|       |	     */
12800|     20|	    cur = newDoc->children->children;
12801|     20|	    *list = cur;
12802|     52|	    while (cur != NULL) {
  ------------------
  |  Branch (12802:13): [True: 32, False: 20]
  ------------------
12803|     32|		cur->parent = NULL;
12804|     32|		cur = cur->next;
12805|     32|	    }
12806|     20|            newDoc->children->children = NULL;
12807|     20|	}
12808|     20|	ret = XML_ERR_OK;
12809|     20|    }
12810|       |
12811|       |    /*
12812|       |     * Also record the size of the entity parsed
12813|       |     */
12814|     36|    if (ctxt->input != NULL && oldctxt != NULL) {
  ------------------
  |  Branch (12814:9): [True: 36, False: 0]
  |  Branch (12814:32): [True: 36, False: 0]
  ------------------
12815|     36|        unsigned long consumed = ctxt->input->consumed;
12816|       |
12817|     36|        xmlSaturatedAddSizeT(&consumed, ctxt->input->cur - ctxt->input->base);
12818|       |
12819|     36|        xmlSaturatedAdd(&oldctxt->sizeentities, consumed);
12820|     36|        xmlSaturatedAdd(&oldctxt->sizeentities, ctxt->sizeentities);
12821|       |
12822|     36|        xmlSaturatedAdd(&oldctxt->sizeentcopy, consumed);
12823|     36|        xmlSaturatedAdd(&oldctxt->sizeentcopy, ctxt->sizeentcopy);
12824|     36|    }
12825|       |
12826|     36|    if (oldctxt != NULL) {
  ------------------
  |  Branch (12826:9): [True: 36, False: 0]
  ------------------
12827|     36|        ctxt->dict = NULL;
12828|     36|        ctxt->attsDefault = NULL;
12829|     36|        ctxt->attsSpecial = NULL;
12830|     36|        oldctxt->nbErrors = ctxt->nbErrors;
12831|     36|        oldctxt->nbWarnings = ctxt->nbWarnings;
12832|     36|        oldctxt->validate = ctxt->validate;
12833|     36|        oldctxt->valid = ctxt->valid;
12834|     36|        oldctxt->node_seq.maximum = ctxt->node_seq.maximum;
12835|     36|        oldctxt->node_seq.length = ctxt->node_seq.length;
12836|     36|        oldctxt->node_seq.buffer = ctxt->node_seq.buffer;
12837|     36|    }
12838|     36|    ctxt->node_seq.maximum = 0;
12839|     36|    ctxt->node_seq.length = 0;
12840|     36|    ctxt->node_seq.buffer = NULL;
12841|     36|    xmlFreeParserCtxt(ctxt);
12842|     36|    newDoc->intSubset = NULL;
12843|     36|    newDoc->extSubset = NULL;
12844|     36|    xmlFreeDoc(newDoc);
12845|       |
12846|     36|    return(ret);
12847|     36|}
parser.c:xmlParseBalancedChunkMemoryInternal:
12928|    436|	const xmlChar *string, void *user_data, xmlNodePtr *lst) {
12929|    436|    xmlParserCtxtPtr ctxt;
12930|    436|    xmlDocPtr newDoc = NULL;
12931|    436|    xmlNodePtr newRoot;
12932|    436|    xmlSAXHandlerPtr oldsax = NULL;
12933|    436|    xmlNodePtr content = NULL;
12934|    436|    xmlNodePtr last = NULL;
12935|    436|    xmlParserErrors ret = XML_ERR_OK;
12936|    436|    xmlHashedString hprefix, huri;
12937|    436|    unsigned i;
12938|       |
12939|    436|    if (((oldctxt->depth > 40) && ((oldctxt->options & XML_PARSE_HUGE) == 0)) ||
  ------------------
  |  Branch (12939:10): [True: 4, False: 432]
  |  Branch (12939:35): [True: 4, False: 0]
  ------------------
12940|    436|        (oldctxt->depth >  100)) {
  ------------------
  |  Branch (12940:9): [True: 0, False: 432]
  ------------------
12941|      4|	xmlFatalErrMsg(oldctxt, XML_ERR_ENTITY_LOOP,
12942|      4|                       "Maximum entity nesting depth exceeded");
12943|      4|	return(XML_ERR_ENTITY_LOOP);
12944|      4|    }
12945|       |
12946|       |
12947|    432|    if (lst != NULL)
  ------------------
  |  Branch (12947:9): [True: 432, False: 0]
  ------------------
12948|    432|        *lst = NULL;
12949|    432|    if (string == NULL)
  ------------------
  |  Branch (12949:9): [True: 0, False: 432]
  ------------------
12950|      0|        return(XML_ERR_INTERNAL_ERROR);
12951|       |
12952|    432|    ctxt = xmlCreateDocParserCtxt(string);
12953|    432|    if (ctxt == NULL) return(XML_WAR_UNDECLARED_ENTITY);
  ------------------
  |  Branch (12953:9): [True: 0, False: 432]
  ------------------
12954|    432|    ctxt->nbErrors = oldctxt->nbErrors;
12955|    432|    ctxt->nbWarnings = oldctxt->nbWarnings;
12956|    432|    if (user_data != NULL)
  ------------------
  |  Branch (12956:9): [True: 0, False: 432]
  ------------------
12957|      0|	ctxt->userData = user_data;
12958|    432|    else
12959|    432|	ctxt->userData = ctxt;
12960|    432|    if (ctxt->dict != NULL) xmlDictFree(ctxt->dict);
  ------------------
  |  Branch (12960:9): [True: 432, False: 0]
  ------------------
12961|    432|    ctxt->dict = oldctxt->dict;
12962|    432|    ctxt->input_id = oldctxt->input_id;
12963|    432|    ctxt->str_xml = xmlDictLookup(ctxt->dict, BAD_CAST "xml", 3);
  ------------------
  |  |   35|    432|#define BAD_CAST (xmlChar *)
  ------------------
12964|    432|    ctxt->str_xmlns = xmlDictLookup(ctxt->dict, BAD_CAST "xmlns", 5);
  ------------------
  |  |   35|    432|#define BAD_CAST (xmlChar *)
  ------------------
12965|    432|    ctxt->str_xml_ns = xmlDictLookup(ctxt->dict, XML_XML_NAMESPACE, 36);
  ------------------
  |  |  143|    432|    (const xmlChar *) "http://www.w3.org/XML/1998/namespace"
  ------------------
12966|       |
12967|       |    /*
12968|       |     * Propagate namespaces down the entity
12969|       |     *
12970|       |     * Making entities and namespaces work correctly requires additional
12971|       |     * changes, see xmlParseReference.
12972|       |     */
12973|       |
12974|       |    /* Default namespace */
12975|    432|    hprefix.name = NULL;
12976|    432|    hprefix.hashValue = 0;
12977|    432|    huri.name = xmlParserNsLookupUri(oldctxt, &hprefix);
12978|    432|    huri.hashValue = 0;
12979|    432|    if (huri.name != NULL)
  ------------------
  |  Branch (12979:9): [True: 4, False: 428]
  ------------------
12980|      4|        xmlParserNsPush(ctxt, NULL, &huri, NULL, 0);
12981|       |
12982|    496|    for (i = 0; i < oldctxt->nsdb->hashSize; i++) {
  ------------------
  |  Branch (12982:17): [True: 64, False: 432]
  ------------------
12983|     64|        xmlParserNsBucket *bucket = &oldctxt->nsdb->hash[i];
12984|     64|        const xmlChar **ns;
12985|     64|        xmlParserNsExtra *extra;
12986|     64|        unsigned nsIndex;
12987|       |
12988|     64|        if ((bucket->hashValue != 0) &&
  ------------------
  |  Branch (12988:13): [True: 4, False: 60]
  ------------------
12989|     64|            (bucket->index != INT_MAX)) {
  ------------------
  |  Branch (12989:13): [True: 4, False: 0]
  ------------------
12990|      4|            nsIndex = bucket->index;
12991|      4|            ns = &oldctxt->nsTab[nsIndex * 2];
12992|      4|            extra = &oldctxt->nsdb->extra[nsIndex];
12993|       |
12994|      4|            hprefix.name = ns[0];
12995|      4|            hprefix.hashValue = bucket->hashValue;
12996|      4|            huri.name = ns[1];
12997|      4|            huri.hashValue = extra->uriHashValue;
12998|       |            /*
12999|       |             * Don't copy SAX data to avoid a use-after-free with XML reader.
13000|       |             * This matches the pre-2.12 behavior.
13001|       |             */
13002|      4|            xmlParserNsPush(ctxt, &hprefix, &huri, NULL, 0);
13003|      4|        }
13004|     64|    }
13005|       |
13006|    432|    oldsax = ctxt->sax;
13007|    432|    ctxt->sax = oldctxt->sax;
13008|    432|    xmlDetectSAX2(ctxt);
13009|    432|    ctxt->replaceEntities = oldctxt->replaceEntities;
13010|    432|    ctxt->options = oldctxt->options;
13011|       |
13012|    432|    ctxt->_private = oldctxt->_private;
13013|    432|    if (oldctxt->myDoc == NULL) {
  ------------------
  |  Branch (13013:9): [True: 0, False: 432]
  ------------------
13014|      0|	newDoc = xmlNewDoc(BAD_CAST "1.0");
  ------------------
  |  |   35|      0|#define BAD_CAST (xmlChar *)
  ------------------
13015|      0|	if (newDoc == NULL) {
  ------------------
  |  Branch (13015:6): [True: 0, False: 0]
  ------------------
13016|      0|            ret = XML_ERR_INTERNAL_ERROR;
13017|      0|            goto error;
13018|      0|	}
13019|      0|	newDoc->properties = XML_DOC_INTERNAL;
13020|      0|	newDoc->dict = ctxt->dict;
13021|      0|	xmlDictReference(newDoc->dict);
13022|      0|	ctxt->myDoc = newDoc;
13023|    432|    } else {
13024|    432|	ctxt->myDoc = oldctxt->myDoc;
13025|    432|        content = ctxt->myDoc->children;
13026|    432|	last = ctxt->myDoc->last;
13027|    432|    }
13028|    432|    newRoot = xmlNewDocNode(ctxt->myDoc, NULL, BAD_CAST "pseudoroot", NULL);
  ------------------
  |  |   35|    432|#define BAD_CAST (xmlChar *)
  ------------------
13029|    432|    if (newRoot == NULL) {
  ------------------
  |  Branch (13029:9): [True: 0, False: 432]
  ------------------
13030|      0|        ret = XML_ERR_INTERNAL_ERROR;
13031|      0|        goto error;
13032|      0|    }
13033|    432|    ctxt->myDoc->children = NULL;
13034|    432|    ctxt->myDoc->last = NULL;
13035|    432|    xmlAddChild((xmlNodePtr) ctxt->myDoc, newRoot);
13036|    432|    nodePush(ctxt, ctxt->myDoc->children);
13037|    432|    ctxt->instate = XML_PARSER_CONTENT;
13038|    432|    ctxt->depth = oldctxt->depth;
13039|       |
13040|    432|    ctxt->validate = 0;
13041|    432|    ctxt->loadsubset = oldctxt->loadsubset;
13042|    432|    if ((oldctxt->validate) || (oldctxt->replaceEntities != 0)) {
  ------------------
  |  Branch (13042:9): [True: 153, False: 279]
  |  Branch (13042:32): [True: 279, False: 0]
  ------------------
13043|       |	/*
13044|       |	 * ID/IDREF registration will be done in xmlValidateElement below
13045|       |	 */
13046|    432|	ctxt->loadsubset |= XML_SKIP_IDS;
  ------------------
  |  |  158|    432|#define XML_SKIP_IDS		8
  ------------------
13047|    432|    }
13048|    432|    ctxt->dictNames = oldctxt->dictNames;
13049|    432|    ctxt->attsDefault = oldctxt->attsDefault;
13050|    432|    ctxt->attsSpecial = oldctxt->attsSpecial;
13051|       |
13052|    432|    xmlParseContent(ctxt);
13053|    432|    if ((RAW == '<') && (NXT(1) == '/')) {
  ------------------
  |  | 2221|    432|#define RAW (*ctxt->input->cur)
  ------------------
                  if ((RAW == '<') && (NXT(1) == '/')) {
  ------------------
  |  | 2223|      0|#define NXT(val) ctxt->input->cur[(val)]
  ------------------
  |  Branch (13053:9): [True: 0, False: 432]
  |  Branch (13053:25): [True: 0, False: 0]
  ------------------
13054|      0|	xmlFatalErr(ctxt, XML_ERR_NOT_WELL_BALANCED, NULL);
13055|    432|    } else if (RAW != 0) {
  ------------------
  |  | 2221|    432|#define RAW (*ctxt->input->cur)
  ------------------
  |  Branch (13055:16): [True: 0, False: 432]
  ------------------
13056|      0|	xmlFatalErr(ctxt, XML_ERR_EXTRA_CONTENT, NULL);
13057|      0|    }
13058|    432|    if (ctxt->node != ctxt->myDoc->children) {
  ------------------
  |  Branch (13058:9): [True: 0, False: 432]
  ------------------
13059|      0|	xmlFatalErr(ctxt, XML_ERR_NOT_WELL_BALANCED, NULL);
13060|      0|    }
13061|       |
13062|    432|    if (!ctxt->wellFormed) {
  ------------------
  |  Branch (13062:9): [True: 172, False: 260]
  ------------------
13063|    172|	ret = (xmlParserErrors)ctxt->errNo;
13064|    172|        oldctxt->errNo = ctxt->errNo;
13065|    172|        oldctxt->wellFormed = 0;
13066|    172|        xmlCopyError(&ctxt->lastError, &oldctxt->lastError);
13067|    260|    } else {
13068|    260|        ret = XML_ERR_OK;
13069|    260|    }
13070|       |
13071|    432|    if ((lst != NULL) && (ret == XML_ERR_OK)) {
  ------------------
  |  Branch (13071:9): [True: 432, False: 0]
  |  Branch (13071:26): [True: 260, False: 172]
  ------------------
13072|    260|	xmlNodePtr cur;
13073|       |
13074|       |	/*
13075|       |	 * Return the newly created nodeset after unlinking it from
13076|       |	 * they pseudo parent.
13077|       |	 */
13078|    260|	cur = ctxt->myDoc->children->children;
13079|    260|	*lst = cur;
13080|    588|	while (cur != NULL) {
  ------------------
  |  Branch (13080:9): [True: 328, False: 260]
  ------------------
13081|    328|#ifdef LIBXML_VALID_ENABLED
13082|    328|	    if ((oldctxt->validate) && (oldctxt->wellFormed) &&
  ------------------
  |  Branch (13082:10): [True: 198, False: 130]
  |  Branch (13082:33): [True: 198, False: 0]
  ------------------
13083|    328|		(oldctxt->myDoc) && (oldctxt->myDoc->intSubset) &&
  ------------------
  |  Branch (13083:3): [True: 198, False: 0]
  |  Branch (13083:23): [True: 198, False: 0]
  ------------------
13084|    328|		(cur->type == XML_ELEMENT_NODE)) {
  ------------------
  |  Branch (13084:3): [True: 51, False: 147]
  ------------------
13085|     51|		oldctxt->valid &= xmlValidateElement(&oldctxt->vctxt,
13086|     51|			oldctxt->myDoc, cur);
13087|     51|	    }
13088|    328|#endif /* LIBXML_VALID_ENABLED */
13089|    328|	    cur->parent = NULL;
13090|    328|	    cur = cur->next;
13091|    328|	}
13092|    260|	ctxt->myDoc->children->children = NULL;
13093|    260|    }
13094|    432|    if (ctxt->myDoc != NULL) {
  ------------------
  |  Branch (13094:9): [True: 432, False: 0]
  ------------------
13095|    432|	xmlFreeNode(ctxt->myDoc->children);
13096|    432|        ctxt->myDoc->children = content;
13097|    432|        ctxt->myDoc->last = last;
13098|    432|    }
13099|       |
13100|       |    /*
13101|       |     * Also record the size of the entity parsed
13102|       |     */
13103|    432|    if (ctxt->input != NULL && oldctxt != NULL) {
  ------------------
  |  Branch (13103:9): [True: 432, False: 0]
  |  Branch (13103:32): [True: 432, False: 0]
  ------------------
13104|    432|        unsigned long consumed = ctxt->input->consumed;
13105|       |
13106|    432|        xmlSaturatedAddSizeT(&consumed, ctxt->input->cur - ctxt->input->base);
13107|       |
13108|    432|        xmlSaturatedAdd(&oldctxt->sizeentcopy, consumed);
13109|    432|        xmlSaturatedAdd(&oldctxt->sizeentcopy, ctxt->sizeentcopy);
13110|    432|    }
13111|       |
13112|    432|    oldctxt->nbErrors = ctxt->nbErrors;
13113|    432|    oldctxt->nbWarnings = ctxt->nbWarnings;
13114|       |
13115|    432|error:
13116|    432|    ctxt->sax = oldsax;
13117|    432|    ctxt->dict = NULL;
13118|    432|    ctxt->attsDefault = NULL;
13119|    432|    ctxt->attsSpecial = NULL;
13120|    432|    xmlFreeParserCtxt(ctxt);
13121|    432|    if (newDoc != NULL) {
  ------------------
  |  Branch (13121:9): [True: 0, False: 432]
  ------------------
13122|      0|	xmlFreeDoc(newDoc);
13123|      0|    }
13124|       |
13125|    432|    return(ret);
13126|    432|}
parser.c:xmlParserNsPush:
 1664|    452|                const xmlHashedString *uri, void *saxData, int defAttr) {
 1665|    452|    xmlParserNsBucket *bucket = NULL;
 1666|    452|    xmlParserNsExtra *extra;
 1667|    452|    const xmlChar **ns;
 1668|    452|    unsigned hashValue, nsIndex, oldIndex;
 1669|       |
 1670|    452|    if ((prefix != NULL) && (prefix->name == ctxt->str_xml))
  ------------------
  |  Branch (1670:9): [True: 320, False: 132]
  |  Branch (1670:29): [True: 0, False: 320]
  ------------------
 1671|      0|        return(0);
 1672|       |
 1673|    452|    if ((ctxt->nsNr >= ctxt->nsMax) && (xmlParserNsGrow(ctxt) < 0)) {
  ------------------
  |  Branch (1673:9): [True: 288, False: 164]
  |  Branch (1673:40): [True: 0, False: 288]
  ------------------
 1674|      0|        xmlErrMemory(ctxt, NULL);
 1675|      0|        return(-1);
 1676|      0|    }
 1677|       |
 1678|       |    /*
 1679|       |     * Default namespace and 'xml' namespace
 1680|       |     */
 1681|    452|    if ((prefix == NULL) || (prefix->name == NULL)) {
  ------------------
  |  Branch (1681:9): [True: 132, False: 320]
  |  Branch (1681:29): [True: 0, False: 320]
  ------------------
 1682|    132|        oldIndex = ctxt->nsdb->defaultNsIndex;
 1683|       |
 1684|    132|        if (oldIndex != INT_MAX) {
  ------------------
  |  Branch (1684:13): [True: 16, False: 116]
  ------------------
 1685|     16|            if (defAttr != 0)
  ------------------
  |  Branch (1685:17): [True: 4, False: 12]
  ------------------
 1686|      4|                return(0);
 1687|       |
 1688|     12|            extra = &ctxt->nsdb->extra[oldIndex];
 1689|       |
 1690|     12|            if (extra->elementId == ctxt->nsdb->elementId) {
  ------------------
  |  Branch (1690:17): [True: 4, False: 8]
  ------------------
 1691|      4|                xmlErrAttributeDup(ctxt, NULL, BAD_CAST "xmlns");
  ------------------
  |  |   35|      4|#define BAD_CAST (xmlChar *)
  ------------------
 1692|      4|                return(0);
 1693|      4|            }
 1694|       |
 1695|      8|            if ((ctxt->options & XML_PARSE_NSCLEAN) &&
  ------------------
  |  Branch (1695:17): [True: 0, False: 8]
  ------------------
 1696|      8|                (uri->name == ctxt->nsTab[oldIndex * 2 + 1]))
  ------------------
  |  Branch (1696:17): [True: 0, False: 0]
  ------------------
 1697|      0|                return(0);
 1698|      8|        }
 1699|       |
 1700|    124|        ctxt->nsdb->defaultNsIndex = ctxt->nsNr;
 1701|    124|        goto populate_entry;
 1702|    132|    }
 1703|       |
 1704|       |    /*
 1705|       |     * Hash table lookup
 1706|       |     */
 1707|    320|    oldIndex = xmlParserNsLookup(ctxt, prefix, &bucket);
 1708|    320|    if (oldIndex != INT_MAX) {
  ------------------
  |  Branch (1708:9): [True: 16, False: 304]
  ------------------
 1709|     16|        extra = &ctxt->nsdb->extra[oldIndex];
 1710|       |
 1711|     16|        if (defAttr != 0)
  ------------------
  |  Branch (1711:13): [True: 12, False: 4]
  ------------------
 1712|     12|            return(0);
 1713|       |
 1714|       |        /*
 1715|       |         * Check for duplicate definitions on the same element.
 1716|       |         */
 1717|      4|        if (extra->elementId == ctxt->nsdb->elementId) {
  ------------------
  |  Branch (1717:13): [True: 4, False: 0]
  ------------------
 1718|      4|            xmlErrAttributeDup(ctxt, BAD_CAST "xmlns", prefix->name);
  ------------------
  |  |   35|      4|#define BAD_CAST (xmlChar *)
  ------------------
 1719|      4|            return(0);
 1720|      4|        }
 1721|       |
 1722|      0|        if ((ctxt->options & XML_PARSE_NSCLEAN) &&
  ------------------
  |  Branch (1722:13): [True: 0, False: 0]
  ------------------
 1723|      0|            (uri->name == ctxt->nsTab[bucket->index * 2 + 1]))
  ------------------
  |  Branch (1723:13): [True: 0, False: 0]
  ------------------
 1724|      0|            return(0);
 1725|       |
 1726|      0|        bucket->index = ctxt->nsNr;
 1727|      0|        goto populate_entry;
 1728|      0|    }
 1729|       |
 1730|       |    /*
 1731|       |     * Insert new bucket
 1732|       |     */
 1733|       |
 1734|    304|    hashValue = prefix->hashValue;
 1735|       |
 1736|       |    /*
 1737|       |     * Grow hash table, 50% fill factor
 1738|       |     */
 1739|    304|    if (ctxt->nsdb->hashElems + 1 > ctxt->nsdb->hashSize / 2) {
  ------------------
  |  Branch (1739:9): [True: 220, False: 84]
  ------------------
 1740|    220|        xmlParserNsBucket *newHash;
 1741|    220|        unsigned newSize, i, index;
 1742|       |
 1743|    220|        if (ctxt->nsdb->hashSize > UINT_MAX / 2) {
  ------------------
  |  Branch (1743:13): [True: 0, False: 220]
  ------------------
 1744|      0|            xmlErrMemory(ctxt, NULL);
 1745|      0|            return(-1);
 1746|      0|        }
 1747|    220|        newSize = ctxt->nsdb->hashSize ? ctxt->nsdb->hashSize * 2 : 16;
  ------------------
  |  Branch (1747:19): [True: 0, False: 220]
  ------------------
 1748|    220|        newHash = xmlMalloc(newSize * sizeof(newHash[0]));
 1749|    220|        if (newHash == NULL) {
  ------------------
  |  Branch (1749:13): [True: 0, False: 220]
  ------------------
 1750|      0|            xmlErrMemory(ctxt, NULL);
 1751|      0|            return(-1);
 1752|      0|        }
 1753|    220|        memset(newHash, 0, newSize * sizeof(newHash[0]));
 1754|       |
 1755|    220|        for (i = 0; i < ctxt->nsdb->hashSize; i++) {
  ------------------
  |  Branch (1755:21): [True: 0, False: 220]
  ------------------
 1756|      0|            unsigned hv = ctxt->nsdb->hash[i].hashValue;
 1757|      0|            unsigned newIndex;
 1758|       |
 1759|      0|            if (hv == 0)
  ------------------
  |  Branch (1759:17): [True: 0, False: 0]
  ------------------
 1760|      0|                continue;
 1761|      0|            newIndex = hv & (newSize - 1);
 1762|       |
 1763|      0|            while (newHash[newIndex].hashValue != 0) {
  ------------------
  |  Branch (1763:20): [True: 0, False: 0]
  ------------------
 1764|      0|                newIndex++;
 1765|      0|                if (newIndex == newSize)
  ------------------
  |  Branch (1765:21): [True: 0, False: 0]
  ------------------
 1766|      0|                    newIndex = 0;
 1767|      0|            }
 1768|       |
 1769|      0|            newHash[newIndex] = ctxt->nsdb->hash[i];
 1770|      0|        }
 1771|       |
 1772|    220|        xmlFree(ctxt->nsdb->hash);
 1773|    220|        ctxt->nsdb->hash = newHash;
 1774|    220|        ctxt->nsdb->hashSize = newSize;
 1775|       |
 1776|       |        /*
 1777|       |         * Relookup
 1778|       |         */
 1779|    220|        index = hashValue & (newSize - 1);
 1780|       |
 1781|    220|        while (newHash[index].hashValue != 0) {
  ------------------
  |  Branch (1781:16): [True: 0, False: 220]
  ------------------
 1782|      0|            index++;
 1783|      0|            if (index == newSize)
  ------------------
  |  Branch (1783:17): [True: 0, False: 0]
  ------------------
 1784|      0|                index = 0;
 1785|      0|        }
 1786|       |
 1787|    220|        bucket = &newHash[index];
 1788|    220|    }
 1789|       |
 1790|    304|    bucket->hashValue = hashValue;
 1791|    304|    bucket->index = ctxt->nsNr;
 1792|    304|    ctxt->nsdb->hashElems++;
 1793|    304|    oldIndex = INT_MAX;
 1794|       |
 1795|    428|populate_entry:
 1796|    428|    nsIndex = ctxt->nsNr;
 1797|       |
 1798|    428|    ns = &ctxt->nsTab[nsIndex * 2];
 1799|    428|    ns[0] = prefix ? prefix->name : NULL;
  ------------------
  |  Branch (1799:13): [True: 304, False: 124]
  ------------------
 1800|    428|    ns[1] = uri->name;
 1801|       |
 1802|    428|    extra = &ctxt->nsdb->extra[nsIndex];
 1803|    428|    extra->saxData = saxData;
 1804|    428|    extra->prefixHashValue = prefix ? prefix->hashValue : 0;
  ------------------
  |  Branch (1804:30): [True: 304, False: 124]
  ------------------
 1805|    428|    extra->uriHashValue = uri->hashValue;
 1806|    428|    extra->elementId = ctxt->nsdb->elementId;
 1807|    428|    extra->oldIndex = oldIndex;
 1808|       |
 1809|    428|    ctxt->nsNr++;
 1810|       |
 1811|    428|    return(1);
 1812|    304|}
parser.c:xmlParserNsGrow:
 1622|    288|xmlParserNsGrow(xmlParserCtxtPtr ctxt) {
 1623|    288|    const xmlChar **table;
 1624|    288|    xmlParserNsExtra *extra;
 1625|    288|    int newSize;
 1626|       |
 1627|    288|    if (ctxt->nsMax > INT_MAX / 2)
  ------------------
  |  Branch (1627:9): [True: 0, False: 288]
  ------------------
 1628|      0|        goto error;
 1629|    288|    newSize = ctxt->nsMax ? ctxt->nsMax * 2 : 16;
  ------------------
  |  Branch (1629:15): [True: 0, False: 288]
  ------------------
 1630|       |
 1631|    288|    table = xmlRealloc(ctxt->nsTab, 2 * newSize * sizeof(table[0]));
 1632|    288|    if (table == NULL)
  ------------------
  |  Branch (1632:9): [True: 0, False: 288]
  ------------------
 1633|      0|        goto error;
 1634|    288|    ctxt->nsTab = table;
 1635|       |
 1636|    288|    extra = xmlRealloc(ctxt->nsdb->extra, newSize * sizeof(extra[0]));
 1637|    288|    if (extra == NULL)
  ------------------
  |  Branch (1637:9): [True: 0, False: 288]
  ------------------
 1638|      0|        goto error;
 1639|    288|    ctxt->nsdb->extra = extra;
 1640|       |
 1641|    288|    ctxt->nsMax = newSize;
 1642|    288|    return(0);
 1643|       |
 1644|      0|error:
 1645|      0|    xmlErrMemory(ctxt, NULL);
 1646|      0|    return(-1);
 1647|    288|}
parser.c:xmlParserNsPop:
 1825|    312|{
 1826|    312|    int i;
 1827|       |
 1828|       |    /* assert(nr <= ctxt->nsNr); */
 1829|       |
 1830|    722|    for (i = ctxt->nsNr - 1; i >= ctxt->nsNr - nr; i--) {
  ------------------
  |  Branch (1830:30): [True: 410, False: 312]
  ------------------
 1831|    410|        const xmlChar *prefix = ctxt->nsTab[i * 2];
 1832|    410|        xmlParserNsExtra *extra = &ctxt->nsdb->extra[i];
 1833|       |
 1834|    410|        if (prefix == NULL) {
  ------------------
  |  Branch (1834:13): [True: 118, False: 292]
  ------------------
 1835|    118|            ctxt->nsdb->defaultNsIndex = extra->oldIndex;
 1836|    292|        } else {
 1837|    292|            xmlHashedString hprefix;
 1838|    292|            xmlParserNsBucket *bucket = NULL;
 1839|       |
 1840|    292|            hprefix.name = prefix;
 1841|    292|            hprefix.hashValue = extra->prefixHashValue;
 1842|    292|            xmlParserNsLookup(ctxt, &hprefix, &bucket);
 1843|       |            /* assert(bucket && bucket->hashValue); */
 1844|    292|            bucket->index = extra->oldIndex;
 1845|    292|        }
 1846|    410|    }
 1847|       |
 1848|    312|    ctxt->nsNr -= nr;
 1849|    312|    return(nr);
 1850|    312|}
parser.c:xmlCreateEntityParserCtxtInternal:
13591|     40|        xmlParserCtxtPtr pctx) {
13592|     40|    xmlParserCtxtPtr ctxt;
13593|     40|    xmlParserInputPtr inputStream;
13594|     40|    char *directory = NULL;
13595|     40|    xmlChar *uri;
13596|       |
13597|     40|    ctxt = xmlNewSAXParserCtxt(sax, userData);
13598|     40|    if (ctxt == NULL) {
  ------------------
  |  Branch (13598:9): [True: 0, False: 40]
  ------------------
13599|      0|	return(NULL);
13600|      0|    }
13601|       |
13602|     40|    if (pctx != NULL) {
  ------------------
  |  Branch (13602:9): [True: 40, False: 0]
  ------------------
13603|     40|        ctxt->options = pctx->options;
13604|     40|        ctxt->_private = pctx->_private;
13605|     40|	ctxt->input_id = pctx->input_id;
13606|     40|    }
13607|       |
13608|       |    /* Don't read from stdin. */
13609|     40|    if (xmlStrcmp(URL, BAD_CAST "-") == 0)
  ------------------
  |  |   35|     40|#define BAD_CAST (xmlChar *)
  ------------------
  |  Branch (13609:9): [True: 0, False: 40]
  ------------------
13610|      0|        URL = BAD_CAST "./-";
  ------------------
  |  |   35|      0|#define BAD_CAST (xmlChar *)
  ------------------
13611|       |
13612|     40|    uri = xmlBuildURI(URL, base);
13613|       |
13614|     40|    if (uri == NULL) {
  ------------------
  |  Branch (13614:9): [True: 0, False: 40]
  ------------------
13615|      0|	inputStream = xmlLoadExternalEntity((char *)URL, (char *)ID, ctxt);
13616|      0|	if (inputStream == NULL) {
  ------------------
  |  Branch (13616:6): [True: 0, False: 0]
  ------------------
13617|      0|	    xmlFreeParserCtxt(ctxt);
13618|      0|	    return(NULL);
13619|      0|	}
13620|       |
13621|      0|	inputPush(ctxt, inputStream);
13622|       |
13623|      0|	if ((ctxt->directory == NULL) && (directory == NULL))
  ------------------
  |  Branch (13623:6): [True: 0, False: 0]
  |  Branch (13623:35): [True: 0, False: 0]
  ------------------
13624|      0|	    directory = xmlParserGetDirectory((char *)URL);
13625|      0|	if ((ctxt->directory == NULL) && (directory != NULL))
  ------------------
  |  Branch (13625:6): [True: 0, False: 0]
  |  Branch (13625:35): [True: 0, False: 0]
  ------------------
13626|      0|	    ctxt->directory = directory;
13627|     40|    } else {
13628|     40|	inputStream = xmlLoadExternalEntity((char *)uri, (char *)ID, ctxt);
13629|     40|	if (inputStream == NULL) {
  ------------------
  |  Branch (13629:6): [True: 4, False: 36]
  ------------------
13630|      4|	    xmlFree(uri);
13631|      4|	    xmlFreeParserCtxt(ctxt);
13632|      4|	    return(NULL);
13633|      4|	}
13634|       |
13635|     36|	inputPush(ctxt, inputStream);
13636|       |
13637|     36|	if ((ctxt->directory == NULL) && (directory == NULL))
  ------------------
  |  Branch (13637:6): [True: 36, False: 0]
  |  Branch (13637:35): [True: 36, False: 0]
  ------------------
13638|     36|	    directory = xmlParserGetDirectory((char *)uri);
13639|     36|	if ((ctxt->directory == NULL) && (directory != NULL))
  ------------------
  |  Branch (13639:6): [True: 36, False: 0]
  |  Branch (13639:35): [True: 36, False: 0]
  ------------------
13640|     36|	    ctxt->directory = directory;
13641|     36|	xmlFree(uri);
13642|     36|    }
13643|     36|    return(ctxt);
13644|     40|}
parser.c:xmlCtxtUseOptionsInternal:
14554|  1.29k|{
14555|  1.29k|    if (ctxt == NULL)
  ------------------
  |  Branch (14555:9): [True: 0, False: 1.29k]
  ------------------
14556|      0|        return(-1);
14557|  1.29k|    if (encoding != NULL) {
  ------------------
  |  Branch (14557:9): [True: 0, False: 1.29k]
  ------------------
14558|      0|        if (ctxt->encoding != NULL)
  ------------------
  |  Branch (14558:13): [True: 0, False: 0]
  ------------------
14559|      0|	    xmlFree((xmlChar *) ctxt->encoding);
14560|      0|        ctxt->encoding = xmlStrdup((const xmlChar *) encoding);
14561|      0|    }
14562|  1.29k|    if (options & XML_PARSE_RECOVER) {
  ------------------
  |  Branch (14562:9): [True: 0, False: 1.29k]
  ------------------
14563|      0|        ctxt->recovery = 1;
14564|      0|        options -= XML_PARSE_RECOVER;
14565|      0|	ctxt->options |= XML_PARSE_RECOVER;
14566|      0|    } else
14567|  1.29k|        ctxt->recovery = 0;
14568|  1.29k|    if (options & XML_PARSE_DTDLOAD) {
  ------------------
  |  Branch (14568:9): [True: 1.29k, False: 0]
  ------------------
14569|  1.29k|        ctxt->loadsubset = XML_DETECT_IDS;
  ------------------
  |  |  141|  1.29k|#define XML_DETECT_IDS		2
  ------------------
14570|  1.29k|        options -= XML_PARSE_DTDLOAD;
14571|  1.29k|	ctxt->options |= XML_PARSE_DTDLOAD;
14572|  1.29k|    } else
14573|      0|        ctxt->loadsubset = 0;
14574|  1.29k|    if (options & XML_PARSE_DTDATTR) {
  ------------------
  |  Branch (14574:9): [True: 0, False: 1.29k]
  ------------------
14575|      0|        ctxt->loadsubset |= XML_COMPLETE_ATTRS;
  ------------------
  |  |  150|      0|#define XML_COMPLETE_ATTRS	4
  ------------------
14576|      0|        options -= XML_PARSE_DTDATTR;
14577|      0|	ctxt->options |= XML_PARSE_DTDATTR;
14578|      0|    }
14579|  1.29k|    if (options & XML_PARSE_NOENT) {
  ------------------
  |  Branch (14579:9): [True: 1.29k, False: 0]
  ------------------
14580|  1.29k|        ctxt->replaceEntities = 1;
14581|       |        /* ctxt->loadsubset |= XML_DETECT_IDS; */
14582|  1.29k|        options -= XML_PARSE_NOENT;
14583|  1.29k|	ctxt->options |= XML_PARSE_NOENT;
14584|  1.29k|    } else
14585|      0|        ctxt->replaceEntities = 0;
14586|  1.29k|    if (options & XML_PARSE_PEDANTIC) {
  ------------------
  |  Branch (14586:9): [True: 0, False: 1.29k]
  ------------------
14587|      0|        ctxt->pedantic = 1;
14588|      0|        options -= XML_PARSE_PEDANTIC;
14589|      0|	ctxt->options |= XML_PARSE_PEDANTIC;
14590|      0|    } else
14591|  1.29k|        ctxt->pedantic = 0;
14592|  1.29k|    if (options & XML_PARSE_NOBLANKS) {
  ------------------
  |  Branch (14592:9): [True: 0, False: 1.29k]
  ------------------
14593|      0|        ctxt->keepBlanks = 0;
14594|      0|        ctxt->sax->ignorableWhitespace = xmlSAX2IgnorableWhitespace;
14595|      0|        options -= XML_PARSE_NOBLANKS;
14596|      0|	ctxt->options |= XML_PARSE_NOBLANKS;
14597|      0|    } else
14598|  1.29k|        ctxt->keepBlanks = 1;
14599|  1.29k|    if (options & XML_PARSE_DTDVALID) {
  ------------------
  |  Branch (14599:9): [True: 968, False: 322]
  ------------------
14600|    968|        ctxt->validate = 1;
14601|    968|        if (options & XML_PARSE_NOWARNING)
  ------------------
  |  Branch (14601:13): [True: 0, False: 968]
  ------------------
14602|      0|            ctxt->vctxt.warning = NULL;
14603|    968|        if (options & XML_PARSE_NOERROR)
  ------------------
  |  Branch (14603:13): [True: 0, False: 968]
  ------------------
14604|      0|            ctxt->vctxt.error = NULL;
14605|    968|        options -= XML_PARSE_DTDVALID;
14606|    968|	ctxt->options |= XML_PARSE_DTDVALID;
14607|    968|    } else
14608|    322|        ctxt->validate = 0;
14609|  1.29k|    if (options & XML_PARSE_NOWARNING) {
  ------------------
  |  Branch (14609:9): [True: 0, False: 1.29k]
  ------------------
14610|      0|        ctxt->sax->warning = NULL;
14611|      0|        options -= XML_PARSE_NOWARNING;
14612|      0|    }
14613|  1.29k|    if (options & XML_PARSE_NOERROR) {
  ------------------
  |  Branch (14613:9): [True: 0, False: 1.29k]
  ------------------
14614|      0|        ctxt->sax->error = NULL;
14615|      0|        ctxt->sax->fatalError = NULL;
14616|      0|        options -= XML_PARSE_NOERROR;
14617|      0|    }
14618|  1.29k|#ifdef LIBXML_SAX1_ENABLED
14619|  1.29k|    if (options & XML_PARSE_SAX1) {
  ------------------
  |  Branch (14619:9): [True: 0, False: 1.29k]
  ------------------
14620|      0|        ctxt->sax->startElementNs = NULL;
14621|      0|        ctxt->sax->endElementNs = NULL;
14622|      0|        ctxt->sax->initialized = 1;
14623|      0|        options -= XML_PARSE_SAX1;
14624|      0|	ctxt->options |= XML_PARSE_SAX1;
14625|      0|    }
14626|  1.29k|#endif /* LIBXML_SAX1_ENABLED */
14627|  1.29k|    if (options & XML_PARSE_NODICT) {
  ------------------
  |  Branch (14627:9): [True: 0, False: 1.29k]
  ------------------
14628|      0|        ctxt->dictNames = 0;
14629|      0|        options -= XML_PARSE_NODICT;
14630|      0|	ctxt->options |= XML_PARSE_NODICT;
14631|  1.29k|    } else {
14632|  1.29k|        ctxt->dictNames = 1;
14633|  1.29k|    }
14634|  1.29k|    if (options & XML_PARSE_NOCDATA) {
  ------------------
  |  Branch (14634:9): [True: 0, False: 1.29k]
  ------------------
14635|      0|        ctxt->sax->cdataBlock = NULL;
14636|      0|        options -= XML_PARSE_NOCDATA;
14637|      0|	ctxt->options |= XML_PARSE_NOCDATA;
14638|      0|    }
14639|  1.29k|    if (options & XML_PARSE_NSCLEAN) {
  ------------------
  |  Branch (14639:9): [True: 0, False: 1.29k]
  ------------------
14640|      0|	ctxt->options |= XML_PARSE_NSCLEAN;
14641|      0|        options -= XML_PARSE_NSCLEAN;
14642|      0|    }
14643|  1.29k|    if (options & XML_PARSE_NONET) {
  ------------------
  |  Branch (14643:9): [True: 0, False: 1.29k]
  ------------------
14644|      0|	ctxt->options |= XML_PARSE_NONET;
14645|      0|        options -= XML_PARSE_NONET;
14646|      0|    }
14647|  1.29k|    if (options & XML_PARSE_COMPACT) {
  ------------------
  |  Branch (14647:9): [True: 323, False: 967]
  ------------------
14648|    323|	ctxt->options |= XML_PARSE_COMPACT;
14649|    323|        options -= XML_PARSE_COMPACT;
14650|    323|    }
14651|  1.29k|    if (options & XML_PARSE_OLD10) {
  ------------------
  |  Branch (14651:9): [True: 0, False: 1.29k]
  ------------------
14652|      0|	ctxt->options |= XML_PARSE_OLD10;
14653|      0|        options -= XML_PARSE_OLD10;
14654|      0|    }
14655|  1.29k|    if (options & XML_PARSE_NOBASEFIX) {
  ------------------
  |  Branch (14655:9): [True: 0, False: 1.29k]
  ------------------
14656|      0|	ctxt->options |= XML_PARSE_NOBASEFIX;
14657|      0|        options -= XML_PARSE_NOBASEFIX;
14658|      0|    }
14659|  1.29k|    if (options & XML_PARSE_HUGE) {
  ------------------
  |  Branch (14659:9): [True: 0, False: 1.29k]
  ------------------
14660|      0|	ctxt->options |= XML_PARSE_HUGE;
14661|      0|        options -= XML_PARSE_HUGE;
14662|      0|        if (ctxt->dict != NULL)
  ------------------
  |  Branch (14662:13): [True: 0, False: 0]
  ------------------
14663|      0|            xmlDictSetLimit(ctxt->dict, 0);
14664|      0|    }
14665|  1.29k|    if (options & XML_PARSE_OLDSAX) {
  ------------------
  |  Branch (14665:9): [True: 0, False: 1.29k]
  ------------------
14666|      0|	ctxt->options |= XML_PARSE_OLDSAX;
14667|      0|        options -= XML_PARSE_OLDSAX;
14668|      0|    }
14669|  1.29k|    if (options & XML_PARSE_IGNORE_ENC) {
  ------------------
  |  Branch (14669:9): [True: 0, False: 1.29k]
  ------------------
14670|      0|	ctxt->options |= XML_PARSE_IGNORE_ENC;
14671|      0|        options -= XML_PARSE_IGNORE_ENC;
14672|      0|    }
14673|  1.29k|    if (options & XML_PARSE_BIG_LINES) {
  ------------------
  |  Branch (14673:9): [True: 0, False: 1.29k]
  ------------------
14674|      0|	ctxt->options |= XML_PARSE_BIG_LINES;
14675|      0|        options -= XML_PARSE_BIG_LINES;
14676|      0|    }
14677|  1.29k|    ctxt->linenumbers = 1;
14678|  1.29k|    return (options);
14679|  1.29k|}
parser.c:xmlDoRead:
14731|    644|{
14732|    644|    xmlDocPtr ret;
14733|       |
14734|    644|    xmlCtxtUseOptionsInternal(ctxt, options, encoding);
14735|    644|    if (encoding != NULL) {
  ------------------
  |  Branch (14735:9): [True: 0, False: 644]
  ------------------
14736|      0|        xmlCharEncodingHandlerPtr hdlr;
14737|       |
14738|       |        /*
14739|       |         * TODO: We should consider to set XML_PARSE_IGNORE_ENC if the
14740|       |         * caller provided an encoding. Otherwise, we might switch to
14741|       |         * the encoding from the XML declaration which is likely to
14742|       |         * break things. Also see xmlSwitchInputEncoding.
14743|       |         */
14744|      0|	hdlr = xmlFindCharEncodingHandler(encoding);
14745|      0|	if (hdlr != NULL)
  ------------------
  |  Branch (14745:6): [True: 0, False: 0]
  ------------------
14746|      0|	    xmlSwitchToEncoding(ctxt, hdlr);
14747|      0|    }
14748|    644|    if ((URL != NULL) && (ctxt->input != NULL) &&
  ------------------
  |  Branch (14748:9): [True: 644, False: 0]
  |  Branch (14748:26): [True: 644, False: 0]
  ------------------
14749|    644|        (ctxt->input->filename == NULL))
  ------------------
  |  Branch (14749:9): [True: 644, False: 0]
  ------------------
14750|    644|        ctxt->input->filename = (char *) xmlStrdup((const xmlChar *) URL);
14751|    644|    xmlParseDocument(ctxt);
14752|    644|    if ((ctxt->wellFormed) || ctxt->recovery)
  ------------------
  |  Branch (14752:9): [True: 527, False: 117]
  |  Branch (14752:31): [True: 0, False: 117]
  ------------------
14753|    527|        ret = ctxt->myDoc;
14754|    117|    else {
14755|    117|        ret = NULL;
14756|    117|	if (ctxt->myDoc != NULL) {
  ------------------
  |  Branch (14756:6): [True: 117, False: 0]
  ------------------
14757|    117|	    xmlFreeDoc(ctxt->myDoc);
14758|    117|	}
14759|    117|    }
14760|    644|    ctxt->myDoc = NULL;
14761|    644|    if (!reuse) {
  ------------------
  |  Branch (14761:9): [True: 644, False: 0]
  ------------------
14762|    644|	xmlFreeParserCtxt(ctxt);
14763|    644|    }
14764|       |
14765|    644|    return (ret);
14766|    644|}

__xmlErrEncoding:
  136|     12|{
  137|     12|    if ((ctxt != NULL) && (ctxt->disableSAX != 0) &&
  ------------------
  |  Branch (137:9): [True: 12, False: 0]
  |  Branch (137:27): [True: 0, False: 12]
  ------------------
  138|     12|        (ctxt->instate == XML_PARSER_EOF))
  ------------------
  |  Branch (138:9): [True: 0, False: 0]
  ------------------
  139|      0|	return;
  140|     12|    if (ctxt != NULL)
  ------------------
  |  Branch (140:9): [True: 12, False: 0]
  ------------------
  141|     12|        ctxt->errNo = xmlerr;
  142|     12|    __xmlRaiseError(NULL, NULL, NULL,
  143|     12|                    ctxt, NULL, XML_FROM_PARSER, xmlerr, XML_ERR_FATAL,
  144|     12|                    NULL, 0, (const char *) str1, (const char *) str2,
  145|     12|                    NULL, 0, 0, msg, str1, str2);
  146|     12|    if (ctxt != NULL) {
  ------------------
  |  Branch (146:9): [True: 12, False: 0]
  ------------------
  147|     12|        ctxt->wellFormed = 0;
  148|     12|        if (ctxt->recovery == 0)
  ------------------
  |  Branch (148:13): [True: 12, False: 0]
  ------------------
  149|     12|            ctxt->disableSAX = 1;
  150|     12|    }
  151|     12|}
xmlFatalErr:
  190|    107|{
  191|    107|    const char *errmsg;
  192|       |
  193|    107|    if ((ctxt != NULL) && (ctxt->disableSAX != 0) &&
  ------------------
  |  Branch (193:9): [True: 107, False: 0]
  |  Branch (193:27): [True: 64, False: 43]
  ------------------
  194|    107|        (ctxt->instate == XML_PARSER_EOF))
  ------------------
  |  Branch (194:9): [True: 32, False: 32]
  ------------------
  195|     32|	return;
  196|     75|    switch (error) {
  197|      0|        case XML_ERR_INVALID_HEX_CHARREF:
  ------------------
  |  Branch (197:9): [True: 0, False: 75]
  ------------------
  198|      0|            errmsg = "CharRef: invalid hexadecimal value";
  199|      0|            break;
  200|      0|        case XML_ERR_INVALID_DEC_CHARREF:
  ------------------
  |  Branch (200:9): [True: 0, False: 75]
  ------------------
  201|      0|            errmsg = "CharRef: invalid decimal value";
  202|      0|            break;
  203|      0|        case XML_ERR_INVALID_CHARREF:
  ------------------
  |  Branch (203:9): [True: 0, False: 75]
  ------------------
  204|      0|            errmsg = "CharRef: invalid value";
  205|      0|            break;
  206|     32|        case XML_ERR_INTERNAL_ERROR:
  ------------------
  |  Branch (206:9): [True: 32, False: 43]
  ------------------
  207|     32|            errmsg = "internal error";
  208|     32|            break;
  209|      0|        case XML_ERR_PEREF_AT_EOF:
  ------------------
  |  Branch (209:9): [True: 0, False: 75]
  ------------------
  210|      0|            errmsg = "PEReference at end of document";
  211|      0|            break;
  212|      0|        case XML_ERR_PEREF_IN_PROLOG:
  ------------------
  |  Branch (212:9): [True: 0, False: 75]
  ------------------
  213|      0|            errmsg = "PEReference in prolog";
  214|      0|            break;
  215|      0|        case XML_ERR_PEREF_IN_EPILOG:
  ------------------
  |  Branch (215:9): [True: 0, False: 75]
  ------------------
  216|      0|            errmsg = "PEReference in epilog";
  217|      0|            break;
  218|      0|        case XML_ERR_PEREF_NO_NAME:
  ------------------
  |  Branch (218:9): [True: 0, False: 75]
  ------------------
  219|      0|            errmsg = "PEReference: no name";
  220|      0|            break;
  221|      4|        case XML_ERR_PEREF_SEMICOL_MISSING:
  ------------------
  |  Branch (221:9): [True: 4, False: 71]
  ------------------
  222|      4|            errmsg = "PEReference: expecting ';'";
  223|      4|            break;
  224|     12|        case XML_ERR_ENTITY_LOOP:
  ------------------
  |  Branch (224:9): [True: 12, False: 63]
  ------------------
  225|     12|            errmsg = "Detected an entity reference loop";
  226|     12|            break;
  227|      0|        case XML_ERR_ENTITY_NOT_STARTED:
  ------------------
  |  Branch (227:9): [True: 0, False: 75]
  ------------------
  228|      0|            errmsg = "EntityValue: \" or ' expected";
  229|      0|            break;
  230|      0|        case XML_ERR_ENTITY_PE_INTERNAL:
  ------------------
  |  Branch (230:9): [True: 0, False: 75]
  ------------------
  231|      0|            errmsg = "PEReferences forbidden in internal subset";
  232|      0|            break;
  233|      0|        case XML_ERR_ENTITY_NOT_FINISHED:
  ------------------
  |  Branch (233:9): [True: 0, False: 75]
  ------------------
  234|      0|            errmsg = "EntityValue: \" or ' expected";
  235|      0|            break;
  236|      0|        case XML_ERR_ATTRIBUTE_NOT_STARTED:
  ------------------
  |  Branch (236:9): [True: 0, False: 75]
  ------------------
  237|      0|            errmsg = "AttValue: \" or ' expected";
  238|      0|            break;
  239|      0|        case XML_ERR_LT_IN_ATTRIBUTE:
  ------------------
  |  Branch (239:9): [True: 0, False: 75]
  ------------------
  240|      0|            errmsg = "Unescaped '<' not allowed in attributes values";
  241|      0|            break;
  242|      0|        case XML_ERR_LITERAL_NOT_STARTED:
  ------------------
  |  Branch (242:9): [True: 0, False: 75]
  ------------------
  243|      0|            errmsg = "SystemLiteral \" or ' expected";
  244|      0|            break;
  245|      0|        case XML_ERR_LITERAL_NOT_FINISHED:
  ------------------
  |  Branch (245:9): [True: 0, False: 75]
  ------------------
  246|      0|            errmsg = "Unfinished System or Public ID \" or ' expected";
  247|      0|            break;
  248|      0|        case XML_ERR_MISPLACED_CDATA_END:
  ------------------
  |  Branch (248:9): [True: 0, False: 75]
  ------------------
  249|      0|            errmsg = "Sequence ']]>' not allowed in content";
  250|      0|            break;
  251|      0|        case XML_ERR_URI_REQUIRED:
  ------------------
  |  Branch (251:9): [True: 0, False: 75]
  ------------------
  252|      0|            errmsg = "SYSTEM or PUBLIC, the URI is missing";
  253|      0|            break;
  254|      0|        case XML_ERR_PUBID_REQUIRED:
  ------------------
  |  Branch (254:9): [True: 0, False: 75]
  ------------------
  255|      0|            errmsg = "PUBLIC, the Public Identifier is missing";
  256|      0|            break;
  257|      0|        case XML_ERR_HYPHEN_IN_COMMENT:
  ------------------
  |  Branch (257:9): [True: 0, False: 75]
  ------------------
  258|      0|            errmsg = "Comment must not contain '--' (double-hyphen)";
  259|      0|            break;
  260|      0|        case XML_ERR_PI_NOT_STARTED:
  ------------------
  |  Branch (260:9): [True: 0, False: 75]
  ------------------
  261|      0|            errmsg = "xmlParsePI : no target name";
  262|      0|            break;
  263|      0|        case XML_ERR_RESERVED_XML_NAME:
  ------------------
  |  Branch (263:9): [True: 0, False: 75]
  ------------------
  264|      0|            errmsg = "Invalid PI name";
  265|      0|            break;
  266|      0|        case XML_ERR_NOTATION_NOT_STARTED:
  ------------------
  |  Branch (266:9): [True: 0, False: 75]
  ------------------
  267|      0|            errmsg = "NOTATION: Name expected here";
  268|      0|            break;
  269|      0|        case XML_ERR_NOTATION_NOT_FINISHED:
  ------------------
  |  Branch (269:9): [True: 0, False: 75]
  ------------------
  270|      0|            errmsg = "'>' required to close NOTATION declaration";
  271|      0|            break;
  272|      4|        case XML_ERR_VALUE_REQUIRED:
  ------------------
  |  Branch (272:9): [True: 4, False: 71]
  ------------------
  273|      4|            errmsg = "Entity value required";
  274|      4|            break;
  275|      0|        case XML_ERR_URI_FRAGMENT:
  ------------------
  |  Branch (275:9): [True: 0, False: 75]
  ------------------
  276|      0|            errmsg = "Fragment not allowed";
  277|      0|            break;
  278|      0|        case XML_ERR_ATTLIST_NOT_STARTED:
  ------------------
  |  Branch (278:9): [True: 0, False: 75]
  ------------------
  279|      0|            errmsg = "'(' required to start ATTLIST enumeration";
  280|      0|            break;
  281|      0|        case XML_ERR_NMTOKEN_REQUIRED:
  ------------------
  |  Branch (281:9): [True: 0, False: 75]
  ------------------
  282|      0|            errmsg = "NmToken expected in ATTLIST enumeration";
  283|      0|            break;
  284|      0|        case XML_ERR_ATTLIST_NOT_FINISHED:
  ------------------
  |  Branch (284:9): [True: 0, False: 75]
  ------------------
  285|      0|            errmsg = "')' required to finish ATTLIST enumeration";
  286|      0|            break;
  287|      0|        case XML_ERR_MIXED_NOT_STARTED:
  ------------------
  |  Branch (287:9): [True: 0, False: 75]
  ------------------
  288|      0|            errmsg = "MixedContentDecl : '|' or ')*' expected";
  289|      0|            break;
  290|      0|        case XML_ERR_PCDATA_REQUIRED:
  ------------------
  |  Branch (290:9): [True: 0, False: 75]
  ------------------
  291|      0|            errmsg = "MixedContentDecl : '#PCDATA' expected";
  292|      0|            break;
  293|      0|        case XML_ERR_ELEMCONTENT_NOT_STARTED:
  ------------------
  |  Branch (293:9): [True: 0, False: 75]
  ------------------
  294|      0|            errmsg = "ContentDecl : Name or '(' expected";
  295|      0|            break;
  296|      4|        case XML_ERR_ELEMCONTENT_NOT_FINISHED:
  ------------------
  |  Branch (296:9): [True: 4, False: 71]
  ------------------
  297|      4|            errmsg = "ContentDecl : ',' '|' or ')' expected";
  298|      4|            break;
  299|      0|        case XML_ERR_PEREF_IN_INT_SUBSET:
  ------------------
  |  Branch (299:9): [True: 0, False: 75]
  ------------------
  300|      0|            errmsg =
  301|      0|                "PEReference: forbidden within markup decl in internal subset";
  302|      0|            break;
  303|      8|        case XML_ERR_GT_REQUIRED:
  ------------------
  |  Branch (303:9): [True: 8, False: 67]
  ------------------
  304|      8|            errmsg = "expected '>'";
  305|      8|            break;
  306|      0|        case XML_ERR_CONDSEC_INVALID:
  ------------------
  |  Branch (306:9): [True: 0, False: 75]
  ------------------
  307|      0|            errmsg = "XML conditional section '[' expected";
  308|      0|            break;
  309|      8|        case XML_ERR_EXT_SUBSET_NOT_FINISHED:
  ------------------
  |  Branch (309:9): [True: 8, False: 67]
  ------------------
  310|      8|            errmsg = "Content error in the external subset";
  311|      8|            break;
  312|      0|        case XML_ERR_CONDSEC_INVALID_KEYWORD:
  ------------------
  |  Branch (312:9): [True: 0, False: 75]
  ------------------
  313|      0|            errmsg =
  314|      0|                "conditional section INCLUDE or IGNORE keyword expected";
  315|      0|            break;
  316|      0|        case XML_ERR_CONDSEC_NOT_FINISHED:
  ------------------
  |  Branch (316:9): [True: 0, False: 75]
  ------------------
  317|      0|            errmsg = "XML conditional section not closed";
  318|      0|            break;
  319|      0|        case XML_ERR_XMLDECL_NOT_STARTED:
  ------------------
  |  Branch (319:9): [True: 0, False: 75]
  ------------------
  320|      0|            errmsg = "Text declaration '<?xml' required";
  321|      0|            break;
  322|      0|        case XML_ERR_XMLDECL_NOT_FINISHED:
  ------------------
  |  Branch (322:9): [True: 0, False: 75]
  ------------------
  323|      0|            errmsg = "parsing XML declaration: '?>' expected";
  324|      0|            break;
  325|      0|        case XML_ERR_EXT_ENTITY_STANDALONE:
  ------------------
  |  Branch (325:9): [True: 0, False: 75]
  ------------------
  326|      0|            errmsg = "external parsed entities cannot be standalone";
  327|      0|            break;
  328|      0|        case XML_ERR_ENTITYREF_SEMICOL_MISSING:
  ------------------
  |  Branch (328:9): [True: 0, False: 75]
  ------------------
  329|      0|            errmsg = "EntityRef: expecting ';'";
  330|      0|            break;
  331|      0|        case XML_ERR_DOCTYPE_NOT_FINISHED:
  ------------------
  |  Branch (331:9): [True: 0, False: 75]
  ------------------
  332|      0|            errmsg = "DOCTYPE improperly terminated";
  333|      0|            break;
  334|      0|        case XML_ERR_LTSLASH_REQUIRED:
  ------------------
  |  Branch (334:9): [True: 0, False: 75]
  ------------------
  335|      0|            errmsg = "EndTag: '</' not found";
  336|      0|            break;
  337|      0|        case XML_ERR_EQUAL_REQUIRED:
  ------------------
  |  Branch (337:9): [True: 0, False: 75]
  ------------------
  338|      0|            errmsg = "expected '='";
  339|      0|            break;
  340|      0|        case XML_ERR_STRING_NOT_CLOSED:
  ------------------
  |  Branch (340:9): [True: 0, False: 75]
  ------------------
  341|      0|            errmsg = "String not closed expecting \" or '";
  342|      0|            break;
  343|      0|        case XML_ERR_STRING_NOT_STARTED:
  ------------------
  |  Branch (343:9): [True: 0, False: 75]
  ------------------
  344|      0|            errmsg = "String not started expecting ' or \"";
  345|      0|            break;
  346|      0|        case XML_ERR_ENCODING_NAME:
  ------------------
  |  Branch (346:9): [True: 0, False: 75]
  ------------------
  347|      0|            errmsg = "Invalid XML encoding name";
  348|      0|            break;
  349|      0|        case XML_ERR_STANDALONE_VALUE:
  ------------------
  |  Branch (349:9): [True: 0, False: 75]
  ------------------
  350|      0|            errmsg = "standalone accepts only 'yes' or 'no'";
  351|      0|            break;
  352|      2|        case XML_ERR_DOCUMENT_EMPTY:
  ------------------
  |  Branch (352:9): [True: 2, False: 73]
  ------------------
  353|      2|            errmsg = "Document is empty";
  354|      2|            break;
  355|      1|        case XML_ERR_DOCUMENT_END:
  ------------------
  |  Branch (355:9): [True: 1, False: 74]
  ------------------
  356|      1|            errmsg = "Extra content at the end of the document";
  357|      1|            break;
  358|      0|        case XML_ERR_NOT_WELL_BALANCED:
  ------------------
  |  Branch (358:9): [True: 0, False: 75]
  ------------------
  359|      0|            errmsg = "chunk is not well balanced";
  360|      0|            break;
  361|      0|        case XML_ERR_EXTRA_CONTENT:
  ------------------
  |  Branch (361:9): [True: 0, False: 75]
  ------------------
  362|      0|            errmsg = "extra content at the end of well balanced chunk";
  363|      0|            break;
  364|      0|        case XML_ERR_VERSION_MISSING:
  ------------------
  |  Branch (364:9): [True: 0, False: 75]
  ------------------
  365|      0|            errmsg = "Malformed declaration expecting version";
  366|      0|            break;
  367|      0|        case XML_ERR_NAME_TOO_LONG:
  ------------------
  |  Branch (367:9): [True: 0, False: 75]
  ------------------
  368|      0|            errmsg = "Name too long";
  369|      0|            break;
  370|      0|        case XML_ERR_INVALID_ENCODING:
  ------------------
  |  Branch (370:9): [True: 0, False: 75]
  ------------------
  371|      0|            errmsg = "Invalid bytes in character encoding";
  372|      0|            break;
  373|      0|        case XML_IO_UNKNOWN:
  ------------------
  |  Branch (373:9): [True: 0, False: 75]
  ------------------
  374|      0|            errmsg = "I/O error";
  375|      0|            break;
  376|       |#if 0
  377|       |        case:
  378|       |            errmsg = "";
  379|       |            break;
  380|       |#endif
  381|      0|        default:
  ------------------
  |  Branch (381:9): [True: 0, False: 75]
  ------------------
  382|      0|            errmsg = "Unregistered error message";
  383|     75|    }
  384|     75|    if (ctxt != NULL)
  ------------------
  |  Branch (384:9): [True: 75, False: 0]
  ------------------
  385|     75|	ctxt->errNo = error;
  386|     75|    if (info == NULL) {
  ------------------
  |  Branch (386:9): [True: 43, False: 32]
  ------------------
  387|     43|        __xmlRaiseError(NULL, NULL, NULL, ctxt, NULL, XML_FROM_PARSER, error,
  388|     43|                        XML_ERR_FATAL, NULL, 0, info, NULL, NULL, 0, 0, "%s\n",
  389|     43|                        errmsg);
  390|     43|    } else {
  391|     32|        __xmlRaiseError(NULL, NULL, NULL, ctxt, NULL, XML_FROM_PARSER, error,
  392|     32|                        XML_ERR_FATAL, NULL, 0, info, NULL, NULL, 0, 0, "%s: %s\n",
  393|     32|                        errmsg, info);
  394|     32|    }
  395|     75|    if (ctxt != NULL) {
  ------------------
  |  Branch (395:9): [True: 75, False: 0]
  ------------------
  396|     75|	ctxt->wellFormed = 0;
  397|     75|	if (ctxt->recovery == 0)
  ------------------
  |  Branch (397:6): [True: 75, False: 0]
  ------------------
  398|     75|	    ctxt->disableSAX = 1;
  399|     75|    }
  400|     75|}
xmlHaltParser:
  461|  1.43k|xmlHaltParser(xmlParserCtxtPtr ctxt) {
  462|  1.43k|    if (ctxt == NULL)
  ------------------
  |  Branch (462:9): [True: 0, False: 1.43k]
  ------------------
  463|      0|        return;
  464|  1.43k|    ctxt->instate = XML_PARSER_EOF;
  465|  1.43k|    ctxt->disableSAX = 1;
  466|  1.57k|    while (ctxt->inputNr > 1)
  ------------------
  |  Branch (466:12): [True: 144, False: 1.43k]
  ------------------
  467|    144|        xmlFreeInputStream(inputPop(ctxt));
  468|  1.43k|    if (ctxt->input != NULL) {
  ------------------
  |  Branch (468:9): [True: 1.43k, False: 0]
  ------------------
  469|       |        /*
  470|       |	 * in case there was a specific allocation deallocate before
  471|       |	 * overriding base
  472|       |	 */
  473|  1.43k|        if (ctxt->input->free != NULL) {
  ------------------
  |  Branch (473:13): [True: 0, False: 1.43k]
  ------------------
  474|      0|	    ctxt->input->free((xmlChar *) ctxt->input->base);
  475|      0|	    ctxt->input->free = NULL;
  476|      0|	}
  477|  1.43k|        if (ctxt->input->buf != NULL) {
  ------------------
  |  Branch (477:13): [True: 600, False: 833]
  ------------------
  478|    600|            xmlFreeParserInputBuffer(ctxt->input->buf);
  479|    600|            ctxt->input->buf = NULL;
  480|    600|        }
  481|  1.43k|	ctxt->input->cur = BAD_CAST"";
  ------------------
  |  |   35|  1.43k|#define BAD_CAST (xmlChar *)
  ------------------
  482|  1.43k|        ctxt->input->length = 0;
  483|  1.43k|	ctxt->input->base = ctxt->input->cur;
  484|  1.43k|        ctxt->input->end = ctxt->input->cur;
  485|  1.43k|    }
  486|  1.43k|}
xmlParserGrow:
  511|  3.64M|xmlParserGrow(xmlParserCtxtPtr ctxt) {
  512|  3.64M|    xmlParserInputPtr in = ctxt->input;
  513|  3.64M|    xmlParserInputBufferPtr buf = in->buf;
  514|  3.64M|    ptrdiff_t curEnd = in->end - in->cur;
  515|  3.64M|    ptrdiff_t curBase = in->cur - in->base;
  516|  3.64M|    int ret;
  517|       |
  518|  3.64M|    if (buf == NULL)
  ------------------
  |  Branch (518:9): [True: 1.31M, False: 2.33M]
  ------------------
  519|  1.31M|        return(0);
  520|       |    /* Don't grow push parser buffer. */
  521|  2.33M|    if ((ctxt->progressive) && (ctxt->inputNr <= 1))
  ------------------
  |  Branch (521:9): [True: 1.29M, False: 1.03M]
  |  Branch (521:32): [True: 330k, False: 964k]
  ------------------
  522|   330k|        return(0);
  523|  2.00M|    if (buf->error != 0)
  ------------------
  |  Branch (523:9): [True: 0, False: 2.00M]
  ------------------
  524|      0|        return(-1);
  525|       |
  526|  2.00M|    if (((curEnd > XML_MAX_LOOKUP_LIMIT) ||
  ------------------
  |  |   81|  2.00M|#define XML_MAX_LOOKUP_LIMIT 10000000
  ------------------
  |  Branch (526:10): [True: 0, False: 2.00M]
  ------------------
  527|  2.00M|         (curBase > XML_MAX_LOOKUP_LIMIT)) &&
  ------------------
  |  |   81|  2.00M|#define XML_MAX_LOOKUP_LIMIT 10000000
  ------------------
  |  Branch (527:10): [True: 0, False: 2.00M]
  ------------------
  528|  2.00M|        ((ctxt->options & XML_PARSE_HUGE) == 0)) {
  ------------------
  |  Branch (528:9): [True: 0, False: 0]
  ------------------
  529|      0|        xmlErrMemory(ctxt, "Huge input lookup");
  530|      0|        xmlHaltParser(ctxt);
  531|      0|	return(-1);
  532|      0|    }
  533|       |
  534|  2.00M|    if (curEnd >= INPUT_CHUNK)
  ------------------
  |  |   97|  2.00M|#define INPUT_CHUNK	250
  ------------------
  |  Branch (534:9): [True: 13.4k, False: 1.98M]
  ------------------
  535|  13.4k|        return(0);
  536|       |
  537|  1.98M|    ret = xmlParserInputBufferGrow(buf, INPUT_CHUNK);
  ------------------
  |  |   97|  1.98M|#define INPUT_CHUNK	250
  ------------------
  538|  1.98M|    xmlBufUpdateInput(buf->buffer, in, curBase);
  539|       |
  540|  1.98M|    if (ret < 0) {
  ------------------
  |  Branch (540:9): [True: 0, False: 1.98M]
  ------------------
  541|      0|        xmlFatalErr(ctxt, buf->error, NULL);
  542|       |        /* Buffer contents may be lost in case of memory errors. */
  543|      0|        if (buf->error == XML_ERR_NO_MEMORY)
  ------------------
  |  Branch (543:13): [True: 0, False: 0]
  ------------------
  544|      0|            xmlHaltParser(ctxt);
  545|      0|    }
  546|       |
  547|  1.98M|    return(ret);
  548|  2.00M|}
xmlParserShrink:
  600|  1.13k|xmlParserShrink(xmlParserCtxtPtr ctxt) {
  601|  1.13k|    xmlParserInputPtr in = ctxt->input;
  602|  1.13k|    xmlParserInputBufferPtr buf = in->buf;
  603|  1.13k|    size_t used;
  604|       |
  605|  1.13k|    if (buf == NULL)
  ------------------
  |  Branch (605:9): [True: 0, False: 1.13k]
  ------------------
  606|      0|        return;
  607|       |
  608|  1.13k|    used = in->cur - in->base;
  609|       |    /*
  610|       |     * Do not shrink on large buffers whose only a tiny fraction
  611|       |     * was consumed
  612|       |     */
  613|  1.13k|    if (used > INPUT_CHUNK) {
  ------------------
  |  |   97|  1.13k|#define INPUT_CHUNK	250
  ------------------
  |  Branch (613:9): [True: 1.13k, False: 0]
  ------------------
  614|  1.13k|	size_t res = xmlBufShrink(buf->buffer, used - LINE_LEN);
  ------------------
  |  |  451|  1.13k|#define LINE_LEN        80
  ------------------
  615|       |
  616|  1.13k|	if (res > 0) {
  ------------------
  |  Branch (616:6): [True: 1.13k, False: 0]
  ------------------
  617|  1.13k|            used -= res;
  618|  1.13k|            if ((res > ULONG_MAX) ||
  ------------------
  |  Branch (618:17): [True: 0, False: 1.13k]
  ------------------
  619|  1.13k|                (in->consumed > ULONG_MAX - (unsigned long)res))
  ------------------
  |  Branch (619:17): [True: 0, False: 1.13k]
  ------------------
  620|      0|                in->consumed = ULONG_MAX;
  621|  1.13k|            else
  622|  1.13k|                in->consumed += res;
  623|  1.13k|	}
  624|  1.13k|    }
  625|       |
  626|  1.13k|    xmlBufUpdateInput(buf->buffer, in, used);
  627|  1.13k|}
xmlNextChar:
  698|   776k|{
  699|   776k|    const unsigned char *cur;
  700|   776k|    size_t avail;
  701|   776k|    int c;
  702|       |
  703|   776k|    if ((ctxt == NULL) || (ctxt->instate == XML_PARSER_EOF) ||
  ------------------
  |  Branch (703:9): [True: 0, False: 776k]
  |  Branch (703:27): [True: 0, False: 776k]
  ------------------
  704|   776k|        (ctxt->input == NULL))
  ------------------
  |  Branch (704:9): [True: 0, False: 776k]
  ------------------
  705|      0|        return;
  706|       |
  707|   776k|    avail = ctxt->input->end - ctxt->input->cur;
  708|       |
  709|   776k|    if (avail < INPUT_CHUNK) {
  ------------------
  |  |   97|   776k|#define INPUT_CHUNK	250
  ------------------
  |  Branch (709:9): [True: 557k, False: 219k]
  ------------------
  710|   557k|        xmlParserGrow(ctxt);
  711|   557k|        if ((ctxt->instate == XML_PARSER_EOF) ||
  ------------------
  |  Branch (711:13): [True: 0, False: 557k]
  ------------------
  712|   557k|            (ctxt->input->cur >= ctxt->input->end))
  ------------------
  |  Branch (712:13): [True: 0, False: 557k]
  ------------------
  713|      0|            return;
  714|   557k|        avail = ctxt->input->end - ctxt->input->cur;
  715|   557k|    }
  716|       |
  717|   776k|    cur = ctxt->input->cur;
  718|   776k|    c = *cur;
  719|       |
  720|   776k|    if (c < 0x80) {
  ------------------
  |  Branch (720:9): [True: 776k, False: 0]
  ------------------
  721|   776k|        if (c == '\n') {
  ------------------
  |  Branch (721:13): [True: 70.6k, False: 705k]
  ------------------
  722|  70.6k|            ctxt->input->cur++;
  723|  70.6k|            ctxt->input->line++;
  724|  70.6k|            ctxt->input->col = 1;
  725|   705k|        } else if (c == '\r') {
  ------------------
  |  Branch (725:20): [True: 7.12k, False: 698k]
  ------------------
  726|       |            /*
  727|       |             *   2.11 End-of-Line Handling
  728|       |             *   the literal two-character sequence "#xD#xA" or a standalone
  729|       |             *   literal #xD, an XML processor must pass to the application
  730|       |             *   the single character #xA.
  731|       |             */
  732|  7.12k|            ctxt->input->cur += ((cur[1] == '\n') ? 2 : 1);
  ------------------
  |  Branch (732:34): [True: 7.12k, False: 0]
  ------------------
  733|  7.12k|            ctxt->input->line++;
  734|  7.12k|            ctxt->input->col = 1;
  735|  7.12k|            return;
  736|   698k|        } else {
  737|   698k|            ctxt->input->cur++;
  738|   698k|            ctxt->input->col++;
  739|   698k|        }
  740|   776k|    } else {
  741|      0|        ctxt->input->col++;
  742|       |
  743|      0|        if ((avail < 2) || (cur[1] & 0xc0) != 0x80)
  ------------------
  |  Branch (743:13): [True: 0, False: 0]
  |  Branch (743:28): [True: 0, False: 0]
  ------------------
  744|      0|            goto encoding_error;
  745|       |
  746|      0|        if (c < 0xe0) {
  ------------------
  |  Branch (746:13): [True: 0, False: 0]
  ------------------
  747|       |            /* 2-byte code */
  748|      0|            if (c < 0xc2)
  ------------------
  |  Branch (748:17): [True: 0, False: 0]
  ------------------
  749|      0|                goto encoding_error;
  750|      0|            ctxt->input->cur += 2;
  751|      0|        } else {
  752|      0|            unsigned int val = (c << 8) | cur[1];
  753|       |
  754|      0|            if ((avail < 3) || (cur[2] & 0xc0) != 0x80)
  ------------------
  |  Branch (754:17): [True: 0, False: 0]
  |  Branch (754:32): [True: 0, False: 0]
  ------------------
  755|      0|                goto encoding_error;
  756|       |
  757|      0|            if (c < 0xf0) {
  ------------------
  |  Branch (757:17): [True: 0, False: 0]
  ------------------
  758|       |                /* 3-byte code */
  759|      0|                if ((val < 0xe0a0) || ((val >= 0xeda0) && (val < 0xee00)))
  ------------------
  |  Branch (759:21): [True: 0, False: 0]
  |  Branch (759:40): [True: 0, False: 0]
  |  Branch (759:59): [True: 0, False: 0]
  ------------------
  760|      0|                    goto encoding_error;
  761|      0|                ctxt->input->cur += 3;
  762|      0|            } else {
  763|      0|                if ((avail < 4) || ((cur[3] & 0xc0) != 0x80))
  ------------------
  |  Branch (763:21): [True: 0, False: 0]
  |  Branch (763:36): [True: 0, False: 0]
  ------------------
  764|      0|                    goto encoding_error;
  765|       |
  766|       |                /* 4-byte code */
  767|      0|                if ((val < 0xf090) || (val >= 0xf490))
  ------------------
  |  Branch (767:21): [True: 0, False: 0]
  |  Branch (767:39): [True: 0, False: 0]
  ------------------
  768|      0|                    goto encoding_error;
  769|      0|                ctxt->input->cur += 4;
  770|      0|            }
  771|      0|        }
  772|      0|    }
  773|       |
  774|   769k|    return;
  775|       |
  776|   769k|encoding_error:
  777|       |    /* Only report the first error */
  778|      0|    if ((ctxt->input->flags & XML_INPUT_ENCODING_ERROR) == 0) {
  ------------------
  |  |   27|      0|#define XML_INPUT_ENCODING_ERROR    (1u << 5)
  ------------------
  |  Branch (778:9): [True: 0, False: 0]
  ------------------
  779|      0|        if ((ctxt == NULL) || (ctxt->input == NULL) ||
  ------------------
  |  Branch (779:13): [True: 0, False: 0]
  |  Branch (779:31): [True: 0, False: 0]
  ------------------
  780|      0|            (ctxt->input->end - ctxt->input->cur < 4)) {
  ------------------
  |  Branch (780:13): [True: 0, False: 0]
  ------------------
  781|      0|            __xmlErrEncoding(ctxt, XML_ERR_INVALID_CHAR,
  782|      0|                         "Input is not proper UTF-8, indicate encoding !\n",
  783|      0|                         NULL, NULL);
  784|      0|        } else {
  785|      0|            char buffer[150];
  786|       |
  787|      0|            snprintf(buffer, 149, "Bytes: 0x%02X 0x%02X 0x%02X 0x%02X\n",
  788|      0|                            ctxt->input->cur[0], ctxt->input->cur[1],
  789|      0|                            ctxt->input->cur[2], ctxt->input->cur[3]);
  790|      0|            __xmlErrEncoding(ctxt, XML_ERR_INVALID_CHAR,
  791|      0|                         "Input is not proper UTF-8, indicate encoding !\n%s",
  792|      0|                         BAD_CAST buffer, NULL);
  ------------------
  |  |   35|      0|#define BAD_CAST (xmlChar *)
  ------------------
  793|      0|        }
  794|      0|        ctxt->input->flags |= XML_INPUT_ENCODING_ERROR;
  ------------------
  |  |   27|      0|#define XML_INPUT_ENCODING_ERROR    (1u << 5)
  ------------------
  795|      0|    }
  796|      0|    ctxt->input->cur++;
  797|      0|    return;
  798|   776k|}
xmlCurrentChar:
  821|   798k|xmlCurrentChar(xmlParserCtxtPtr ctxt, int *len) {
  822|   798k|    const unsigned char *cur;
  823|   798k|    size_t avail;
  824|   798k|    int c;
  825|       |
  826|   798k|    if ((ctxt == NULL) || (len == NULL) || (ctxt->input == NULL)) return(0);
  ------------------
  |  Branch (826:9): [True: 0, False: 798k]
  |  Branch (826:27): [True: 0, False: 798k]
  |  Branch (826:44): [True: 0, False: 798k]
  ------------------
  827|   798k|    if (ctxt->instate == XML_PARSER_EOF)
  ------------------
  |  Branch (827:9): [True: 16, False: 798k]
  ------------------
  828|     16|	return(0);
  829|       |
  830|   798k|    avail = ctxt->input->end - ctxt->input->cur;
  831|       |
  832|   798k|    if (avail < INPUT_CHUNK) {
  ------------------
  |  |   97|   798k|#define INPUT_CHUNK	250
  ------------------
  |  Branch (832:9): [True: 46.8k, False: 751k]
  ------------------
  833|  46.8k|        xmlParserGrow(ctxt);
  834|  46.8k|        if (ctxt->instate == XML_PARSER_EOF)
  ------------------
  |  Branch (834:13): [True: 0, False: 46.8k]
  ------------------
  835|      0|            return(0);
  836|  46.8k|        avail = ctxt->input->end - ctxt->input->cur;
  837|  46.8k|    }
  838|       |
  839|   798k|    cur = ctxt->input->cur;
  840|   798k|    c = *cur;
  841|       |
  842|   798k|    if (c < 0x80) {
  ------------------
  |  Branch (842:9): [True: 781k, False: 16.4k]
  ------------------
  843|       |	/* 1-byte code */
  844|   781k|        if (c < 0x20) {
  ------------------
  |  Branch (844:13): [True: 3.64k, False: 778k]
  ------------------
  845|       |            /*
  846|       |             *   2.11 End-of-Line Handling
  847|       |             *   the literal two-character sequence "#xD#xA" or a standalone
  848|       |             *   literal #xD, an XML processor must pass to the application
  849|       |             *   the single character #xA.
  850|       |             */
  851|  3.64k|            if (c == '\r') {
  ------------------
  |  Branch (851:17): [True: 702, False: 2.94k]
  ------------------
  852|    702|                *len = ((cur[1] == '\n') ? 2 : 1);
  ------------------
  |  Branch (852:25): [True: 686, False: 16]
  ------------------
  853|    702|                c = '\n';
  854|  2.94k|            } else if (c == 0) {
  ------------------
  |  Branch (854:24): [True: 702, False: 2.23k]
  ------------------
  855|    702|                if (ctxt->input->cur >= ctxt->input->end) {
  ------------------
  |  Branch (855:21): [True: 702, False: 0]
  ------------------
  856|    702|                    *len = 0;
  857|    702|                } else {
  858|      0|                    *len = 1;
  859|       |                    /*
  860|       |                     * TODO: Null bytes should be handled by callers,
  861|       |                     * but this can be tricky.
  862|       |                     */
  863|      0|                    xmlErrEncodingInt(ctxt, XML_ERR_INVALID_CHAR,
  864|      0|                            "Char 0x0 out of allowed range\n", c);
  865|      0|                }
  866|  2.23k|            } else {
  867|  2.23k|                *len = 1;
  868|  2.23k|            }
  869|   778k|        } else {
  870|   778k|            *len = 1;
  871|   778k|        }
  872|       |
  873|   781k|        return(c);
  874|   781k|    } else {
  875|  16.4k|        int val;
  876|       |
  877|  16.4k|        if (avail < 2)
  ------------------
  |  Branch (877:13): [True: 4, False: 16.4k]
  ------------------
  878|      4|            goto incomplete_sequence;
  879|  16.4k|        if ((cur[1] & 0xc0) != 0x80)
  ------------------
  |  Branch (879:13): [True: 8, False: 16.4k]
  ------------------
  880|      8|            goto encoding_error;
  881|       |
  882|  16.4k|        if (c < 0xe0) {
  ------------------
  |  Branch (882:13): [True: 9.33k, False: 7.12k]
  ------------------
  883|       |            /* 2-byte code */
  884|  9.33k|            if (c < 0xc2)
  ------------------
  |  Branch (884:17): [True: 0, False: 9.33k]
  ------------------
  885|      0|                goto encoding_error;
  886|  9.33k|            val = (c & 0x1f) << 6;
  887|  9.33k|            val |= cur[1] & 0x3f;
  888|  9.33k|            *len = 2;
  889|  9.33k|        } else {
  890|  7.12k|            if (avail < 3)
  ------------------
  |  Branch (890:17): [True: 0, False: 7.12k]
  ------------------
  891|      0|                goto incomplete_sequence;
  892|  7.12k|            if ((cur[2] & 0xc0) != 0x80)
  ------------------
  |  Branch (892:17): [True: 0, False: 7.12k]
  ------------------
  893|      0|                goto encoding_error;
  894|       |
  895|  7.12k|            if (c < 0xf0) {
  ------------------
  |  Branch (895:17): [True: 4.72k, False: 2.40k]
  ------------------
  896|       |                /* 3-byte code */
  897|  4.72k|                val = (c & 0xf) << 12;
  898|  4.72k|                val |= (cur[1] & 0x3f) << 6;
  899|  4.72k|                val |= cur[2] & 0x3f;
  900|  4.72k|                if ((val < 0x800) || ((val >= 0xd800) && (val < 0xe000)))
  ------------------
  |  Branch (900:21): [True: 0, False: 4.72k]
  |  Branch (900:39): [True: 0, False: 4.72k]
  |  Branch (900:58): [True: 0, False: 0]
  ------------------
  901|      0|                    goto encoding_error;
  902|  4.72k|                *len = 3;
  903|  4.72k|            } else {
  904|  2.40k|                if (avail < 4)
  ------------------
  |  Branch (904:21): [True: 0, False: 2.40k]
  ------------------
  905|      0|                    goto incomplete_sequence;
  906|  2.40k|                if ((cur[3] & 0xc0) != 0x80)
  ------------------
  |  Branch (906:21): [True: 0, False: 2.40k]
  ------------------
  907|      0|                    goto encoding_error;
  908|       |
  909|       |                /* 4-byte code */
  910|  2.40k|                val = (c & 0x0f) << 18;
  911|  2.40k|                val |= (cur[1] & 0x3f) << 12;
  912|  2.40k|                val |= (cur[2] & 0x3f) << 6;
  913|  2.40k|                val |= cur[3] & 0x3f;
  914|  2.40k|                if ((val < 0x10000) || (val >= 0x110000))
  ------------------
  |  Branch (914:21): [True: 0, False: 2.40k]
  |  Branch (914:40): [True: 0, False: 2.40k]
  ------------------
  915|      0|                    goto encoding_error;
  916|  2.40k|                *len = 4;
  917|  2.40k|            }
  918|  7.12k|        }
  919|       |
  920|  16.4k|        return(val);
  921|  16.4k|    }
  922|       |
  923|      8|encoding_error:
  924|       |    /* Only report the first error */
  925|      8|    if ((ctxt->input->flags & XML_INPUT_ENCODING_ERROR) == 0) {
  ------------------
  |  |   27|      8|#define XML_INPUT_ENCODING_ERROR    (1u << 5)
  ------------------
  |  Branch (925:9): [True: 8, False: 0]
  ------------------
  926|      8|        if (ctxt->input->end - ctxt->input->cur < 4) {
  ------------------
  |  Branch (926:13): [True: 4, False: 4]
  ------------------
  927|      4|            __xmlErrEncoding(ctxt, XML_ERR_INVALID_CHAR,
  928|      4|                         "Input is not proper UTF-8, indicate encoding !\n",
  929|      4|                         NULL, NULL);
  930|      4|        } else {
  931|      4|            char buffer[150];
  932|       |
  933|      4|            snprintf(&buffer[0], 149, "Bytes: 0x%02X 0x%02X 0x%02X 0x%02X\n",
  934|      4|                            ctxt->input->cur[0], ctxt->input->cur[1],
  935|      4|                            ctxt->input->cur[2], ctxt->input->cur[3]);
  936|      4|            __xmlErrEncoding(ctxt, XML_ERR_INVALID_CHAR,
  937|      4|                         "Input is not proper UTF-8, indicate encoding !\n%s",
  938|      4|                         BAD_CAST buffer, NULL);
  ------------------
  |  |   35|      4|#define BAD_CAST (xmlChar *)
  ------------------
  939|      4|        }
  940|      8|        ctxt->input->flags |= XML_INPUT_ENCODING_ERROR;
  ------------------
  |  |   27|      8|#define XML_INPUT_ENCODING_ERROR    (1u << 5)
  ------------------
  941|      8|    }
  942|      8|    *len = 1;
  943|      8|    return(0xFFFD); /* U+FFFD Replacement Character */
  944|       |
  945|      4|incomplete_sequence:
  946|       |    /*
  947|       |     * An encoding problem may arise from a truncated input buffer
  948|       |     * splitting a character in the middle. In that case do not raise
  949|       |     * an error but return 0. This should only happen when push parsing
  950|       |     * char data.
  951|       |     */
  952|      4|    *len = 0;
  953|      4|    return(0);
  954|   798k|}
xmlStringCurrentChar:
  972|  17.1M|                     const xmlChar *cur, int *len) {
  973|  17.1M|    int c;
  974|       |
  975|  17.1M|    if ((cur == NULL) || (len == NULL))
  ------------------
  |  Branch (975:9): [True: 0, False: 17.1M]
  |  Branch (975:26): [True: 0, False: 17.1M]
  ------------------
  976|      0|        return(0);
  977|       |
  978|       |    /* cur is zero-terminated, so we can lie about its length. */
  979|  17.1M|    *len = 4;
  980|  17.1M|    c = xmlGetUTF8Char(cur, len);
  981|       |
  982|  17.1M|    return((c < 0) ? 0 : c);
  ------------------
  |  Branch (982:12): [True: 0, False: 17.1M]
  ------------------
  983|  17.1M|}
xmlCopyCharMultiByte:
  995|  14.5k|xmlCopyCharMultiByte(xmlChar *out, int val) {
  996|  14.5k|    if ((out == NULL) || (val < 0)) return(0);
  ------------------
  |  Branch (996:9): [True: 0, False: 14.5k]
  |  Branch (996:26): [True: 0, False: 14.5k]
  ------------------
  997|       |    /*
  998|       |     * We are supposed to handle UTF8, check it's valid
  999|       |     * From rfc2044: encoding of the Unicode values on UTF-8:
 1000|       |     *
 1001|       |     * UCS-4 range (hex.)           UTF-8 octet sequence (binary)
 1002|       |     * 0000 0000-0000 007F   0xxxxxxx
 1003|       |     * 0000 0080-0000 07FF   110xxxxx 10xxxxxx
 1004|       |     * 0000 0800-0000 FFFF   1110xxxx 10xxxxxx 10xxxxxx
 1005|       |     */
 1006|  14.5k|    if  (val >= 0x80) {
  ------------------
  |  Branch (1006:10): [True: 14.5k, False: 0]
  ------------------
 1007|  14.5k|	xmlChar *savedout = out;
 1008|  14.5k|	int bits;
 1009|  14.5k|	if (val <   0x800) { *out++= (val >>  6) | 0xC0;  bits=  0; }
  ------------------
  |  Branch (1009:6): [True: 9.66k, False: 4.85k]
  ------------------
 1010|  4.85k|	else if (val < 0x10000) { *out++= (val >> 12) | 0xE0;  bits=  6;}
  ------------------
  |  Branch (1010:11): [True: 2.45k, False: 2.40k]
  ------------------
 1011|  2.40k|	else if (val < 0x110000)  { *out++= (val >> 18) | 0xF0;  bits=  12; }
  ------------------
  |  Branch (1011:11): [True: 2.40k, False: 0]
  ------------------
 1012|      0|	else {
 1013|      0|	    xmlErrEncodingInt(NULL, XML_ERR_INVALID_CHAR,
 1014|      0|		    "Internal error, xmlCopyCharMultiByte 0x%X out of bound\n",
 1015|      0|			      val);
 1016|      0|	    return(0);
 1017|      0|	}
 1018|  36.2k|	for ( ; bits >= 0; bits-= 6)
  ------------------
  |  Branch (1018:10): [True: 21.7k, False: 14.5k]
  ------------------
 1019|  21.7k|	    *out++= ((val >> bits) & 0x3F) | 0x80 ;
 1020|  14.5k|	return (out - savedout);
 1021|  14.5k|    }
 1022|      0|    *out = val;
 1023|      0|    return 1;
 1024|  14.5k|}
xmlCopyChar:
 1038|    340|xmlCopyChar(int len ATTRIBUTE_UNUSED, xmlChar *out, int val) {
 1039|    340|    if ((out == NULL) || (val < 0)) return(0);
  ------------------
  |  Branch (1039:9): [True: 0, False: 340]
  |  Branch (1039:26): [True: 0, False: 340]
  ------------------
 1040|       |    /* the len parameter is ignored */
 1041|    340|    if  (val >= 0x80) {
  ------------------
  |  Branch (1041:10): [True: 196, False: 144]
  ------------------
 1042|    196|	return(xmlCopyCharMultiByte (out, val));
 1043|    196|    }
 1044|    144|    *out = val;
 1045|    144|    return 1;
 1046|    340|}
xmlSwitchEncoding:
 1128|     16|{
 1129|     16|    xmlCharEncodingHandlerPtr handler = NULL;
 1130|     16|    int check = 1;
 1131|     16|    int ret;
 1132|       |
 1133|     16|    if ((ctxt == NULL) || (ctxt->input == NULL))
  ------------------
  |  Branch (1133:9): [True: 0, False: 16]
  |  Branch (1133:27): [True: 0, False: 16]
  ------------------
 1134|      0|        return(-1);
 1135|       |
 1136|     16|    switch (enc) {
 1137|      0|	case XML_CHAR_ENCODING_NONE:
  ------------------
  |  Branch (1137:2): [True: 0, False: 16]
  ------------------
 1138|     12|	case XML_CHAR_ENCODING_UTF8:
  ------------------
  |  Branch (1138:2): [True: 12, False: 4]
  ------------------
 1139|     12|        case XML_CHAR_ENCODING_ASCII:
  ------------------
  |  Branch (1139:9): [True: 0, False: 16]
  ------------------
 1140|     12|            check = 0;
 1141|     12|            break;
 1142|      4|        case XML_CHAR_ENCODING_EBCDIC:
  ------------------
  |  Branch (1142:9): [True: 4, False: 12]
  ------------------
 1143|      4|            handler = xmlDetectEBCDIC(ctxt->input);
 1144|      4|            break;
 1145|      0|        default:
  ------------------
  |  Branch (1145:9): [True: 0, False: 16]
  ------------------
 1146|      0|            handler = xmlGetCharEncodingHandler(enc);
 1147|      0|            break;
 1148|     16|    }
 1149|       |
 1150|     16|    if ((check) && (handler == NULL)) {
  ------------------
  |  Branch (1150:9): [True: 4, False: 12]
  |  Branch (1150:20): [True: 0, False: 4]
  ------------------
 1151|      0|        const char *name = xmlGetCharEncodingName(enc);
 1152|       |
 1153|      0|        __xmlErrEncoding(ctxt, XML_ERR_UNSUPPORTED_ENCODING,
 1154|      0|                "encoding not supported: %s\n",
 1155|      0|                BAD_CAST (name ? name : "<null>"), NULL);
  ------------------
  |  |   35|      0|#define BAD_CAST (xmlChar *)
  ------------------
  |  Branch (1155:27): [True: 0, False: 0]
  ------------------
 1156|       |        /*
 1157|       |         * TODO: We could recover from errors in external entities
 1158|       |         * if we didn't stop the parser. But most callers of this
 1159|       |         * function don't check the return value.
 1160|       |         */
 1161|      0|        xmlStopParser(ctxt);
 1162|      0|        return(-1);
 1163|      0|    }
 1164|       |
 1165|     16|    ret = xmlSwitchInputEncoding(ctxt, ctxt->input, handler);
 1166|       |
 1167|     16|    if ((ret >= 0) && (enc == XML_CHAR_ENCODING_NONE)) {
  ------------------
  |  Branch (1167:9): [True: 16, False: 0]
  |  Branch (1167:23): [True: 0, False: 16]
  ------------------
 1168|      0|        ctxt->input->flags &= ~XML_INPUT_HAS_ENCODING;
  ------------------
  |  |   20|      0|#define XML_INPUT_HAS_ENCODING      (1u << 0)
  ------------------
 1169|      0|    }
 1170|       |
 1171|     16|    return(ret);
 1172|     16|}
xmlSwitchInputEncoding:
 1189|    164|{
 1190|    164|    int nbchars;
 1191|    164|    xmlParserInputBufferPtr in;
 1192|       |
 1193|    164|    if ((input == NULL) || (input->buf == NULL)) {
  ------------------
  |  Branch (1193:9): [True: 0, False: 164]
  |  Branch (1193:28): [True: 0, False: 164]
  ------------------
 1194|      0|        xmlCharEncCloseFunc(handler);
 1195|      0|	return (-1);
 1196|      0|    }
 1197|    164|    in = input->buf;
 1198|       |
 1199|    164|    input->flags |= XML_INPUT_HAS_ENCODING;
  ------------------
  |  |   20|    164|#define XML_INPUT_HAS_ENCODING      (1u << 0)
  ------------------
 1200|       |
 1201|       |    /*
 1202|       |     * UTF-8 requires no encoding handler.
 1203|       |     */
 1204|    164|    if ((handler != NULL) &&
  ------------------
  |  Branch (1204:9): [True: 152, False: 12]
  ------------------
 1205|    164|        (xmlStrcasecmp(BAD_CAST handler->name, BAD_CAST "UTF-8") == 0)) {
  ------------------
  |  |   35|    152|#define BAD_CAST (xmlChar *)
  ------------------
                      (xmlStrcasecmp(BAD_CAST handler->name, BAD_CAST "UTF-8") == 0)) {
  ------------------
  |  |   35|    152|#define BAD_CAST (xmlChar *)
  ------------------
  |  Branch (1205:9): [True: 80, False: 72]
  ------------------
 1206|     80|        xmlCharEncCloseFunc(handler);
 1207|     80|        handler = NULL;
 1208|     80|    }
 1209|       |
 1210|    164|    if (in->encoder == handler)
  ------------------
  |  Branch (1210:9): [True: 92, False: 72]
  ------------------
 1211|     92|        return (0);
 1212|       |
 1213|     72|    if (in->encoder != NULL) {
  ------------------
  |  Branch (1213:9): [True: 0, False: 72]
  ------------------
 1214|       |        /*
 1215|       |         * Switching encodings during parsing is a really bad idea,
 1216|       |         * but Chromium can switch between ISO-8859-1 and UTF-16 before
 1217|       |         * separate calls to xmlParseChunk.
 1218|       |         *
 1219|       |         * TODO: We should check whether the "raw" input buffer is empty and
 1220|       |         * convert the old content using the old encoder.
 1221|       |         */
 1222|       |
 1223|      0|        xmlCharEncCloseFunc(in->encoder);
 1224|      0|        in->encoder = handler;
 1225|      0|        return (0);
 1226|      0|    }
 1227|       |
 1228|     72|    in->encoder = handler;
 1229|       |
 1230|       |    /*
 1231|       |     * Is there already some content down the pipe to convert ?
 1232|       |     */
 1233|     72|    if (xmlBufIsEmpty(in->buffer) == 0) {
  ------------------
  |  Branch (1233:9): [True: 72, False: 0]
  ------------------
 1234|     72|        size_t processed;
 1235|       |
 1236|       |        /*
 1237|       |         * Shrink the current input buffer.
 1238|       |         * Move it as the raw buffer and create a new input buffer
 1239|       |         */
 1240|     72|        processed = input->cur - input->base;
 1241|     72|        xmlBufShrink(in->buffer, processed);
 1242|     72|        input->consumed += processed;
 1243|     72|        in->raw = in->buffer;
 1244|     72|        in->buffer = xmlBufCreate();
 1245|     72|        in->rawconsumed = processed;
 1246|       |
 1247|     72|        nbchars = xmlCharEncInput(in);
 1248|     72|        xmlBufResetInput(in->buffer, input);
 1249|     72|        if (nbchars < 0) {
  ------------------
  |  Branch (1249:13): [True: 0, False: 72]
  ------------------
 1250|       |            /* TODO: This could be an out of memory or an encoding error. */
 1251|      0|            xmlErrInternal(ctxt,
 1252|      0|                           "switching encoding: encoder error\n",
 1253|      0|                           NULL);
 1254|      0|            xmlHaltParser(ctxt);
 1255|      0|            return (-1);
 1256|      0|        }
 1257|     72|    }
 1258|     72|    return (0);
 1259|     72|}
xmlSwitchToEncoding:
 1275|    148|{
 1276|    148|    if (ctxt == NULL)
  ------------------
  |  Branch (1276:9): [True: 0, False: 148]
  ------------------
 1277|      0|        return(-1);
 1278|    148|    return(xmlSwitchInputEncoding(ctxt, ctxt->input, handler));
 1279|    148|}
xmlDetectEncoding:
 1290|  14.5k|xmlDetectEncoding(xmlParserCtxtPtr ctxt) {
 1291|  14.5k|    const xmlChar *in;
 1292|  14.5k|    xmlCharEncoding enc;
 1293|  14.5k|    int bomSize;
 1294|  14.5k|    int autoFlag = 0;
 1295|       |
 1296|  14.5k|    if (xmlParserGrow(ctxt) < 0)
  ------------------
  |  Branch (1296:9): [True: 0, False: 14.5k]
  ------------------
 1297|      0|        return;
 1298|  14.5k|    in = ctxt->input->cur;
 1299|  14.5k|    if (ctxt->input->end - in < 4)
  ------------------
  |  Branch (1299:9): [True: 52, False: 14.5k]
  ------------------
 1300|     52|        return;
 1301|       |
 1302|  14.5k|    if (ctxt->input->flags & XML_INPUT_HAS_ENCODING) {
  ------------------
  |  |   20|  14.5k|#define XML_INPUT_HAS_ENCODING      (1u << 0)
  ------------------
  |  Branch (1302:9): [True: 0, False: 14.5k]
  ------------------
 1303|       |        /*
 1304|       |         * If the encoding was already set, only skip the BOM which was
 1305|       |         * possibly decoded to UTF-8.
 1306|       |         */
 1307|      0|        if ((in[0] == 0xEF) && (in[1] == 0xBB) && (in[2] == 0xBF)) {
  ------------------
  |  Branch (1307:13): [True: 0, False: 0]
  |  Branch (1307:32): [True: 0, False: 0]
  |  Branch (1307:51): [True: 0, False: 0]
  ------------------
 1308|      0|            ctxt->input->cur += 3;
 1309|      0|        }
 1310|       |
 1311|      0|        return;
 1312|      0|    }
 1313|       |
 1314|  14.5k|    enc = XML_CHAR_ENCODING_NONE;
 1315|  14.5k|    bomSize = 0;
 1316|       |
 1317|  14.5k|    switch (in[0]) {
  ------------------
  |  Branch (1317:13): [True: 212, False: 14.3k]
  ------------------
 1318|      0|        case 0x00:
  ------------------
  |  Branch (1318:9): [True: 0, False: 14.5k]
  ------------------
 1319|      0|            if ((in[1] == 0x00) && (in[2] == 0x00) && (in[3] == 0x3C)) {
  ------------------
  |  Branch (1319:17): [True: 0, False: 0]
  |  Branch (1319:36): [True: 0, False: 0]
  |  Branch (1319:55): [True: 0, False: 0]
  ------------------
 1320|      0|                enc = XML_CHAR_ENCODING_UCS4BE;
 1321|      0|                autoFlag = XML_INPUT_AUTO_OTHER;
  ------------------
  |  |   25|      0|#define XML_INPUT_AUTO_OTHER        (4u << 1)
  ------------------
 1322|      0|            } else if ((in[1] == 0x3C) && (in[2] == 0x00) && (in[3] == 0x3F)) {
  ------------------
  |  Branch (1322:24): [True: 0, False: 0]
  |  Branch (1322:43): [True: 0, False: 0]
  |  Branch (1322:62): [True: 0, False: 0]
  ------------------
 1323|      0|                enc = XML_CHAR_ENCODING_UTF16BE;
 1324|      0|                autoFlag = XML_INPUT_AUTO_UTF16BE;
  ------------------
  |  |   24|      0|#define XML_INPUT_AUTO_UTF16BE      (3u << 1)
  ------------------
 1325|      0|            }
 1326|      0|            break;
 1327|       |
 1328|  14.3k|        case 0x3C:
  ------------------
  |  Branch (1328:9): [True: 14.3k, False: 228]
  ------------------
 1329|  14.3k|            if (in[1] == 0x00) {
  ------------------
  |  Branch (1329:17): [True: 0, False: 14.3k]
  ------------------
 1330|      0|                if ((in[2] == 0x00) && (in[3] == 0x00)) {
  ------------------
  |  Branch (1330:21): [True: 0, False: 0]
  |  Branch (1330:40): [True: 0, False: 0]
  ------------------
 1331|      0|                    enc = XML_CHAR_ENCODING_UCS4LE;
 1332|      0|                    autoFlag = XML_INPUT_AUTO_OTHER;
  ------------------
  |  |   25|      0|#define XML_INPUT_AUTO_OTHER        (4u << 1)
  ------------------
 1333|      0|                } else if ((in[2] == 0x3F) && (in[3] == 0x00)) {
  ------------------
  |  Branch (1333:28): [True: 0, False: 0]
  |  Branch (1333:47): [True: 0, False: 0]
  ------------------
 1334|      0|                    enc = XML_CHAR_ENCODING_UTF16LE;
 1335|      0|                    autoFlag = XML_INPUT_AUTO_UTF16LE;
  ------------------
  |  |   23|      0|#define XML_INPUT_AUTO_UTF16LE      (2u << 1)
  ------------------
 1336|      0|                }
 1337|      0|            }
 1338|  14.3k|            break;
 1339|       |
 1340|      4|        case 0x4C:
  ------------------
  |  Branch (1340:9): [True: 4, False: 14.5k]
  ------------------
 1341|      4|	    if ((in[1] == 0x6F) && (in[2] == 0xA7) && (in[3] == 0x94)) {
  ------------------
  |  Branch (1341:10): [True: 4, False: 0]
  |  Branch (1341:29): [True: 4, False: 0]
  |  Branch (1341:48): [True: 4, False: 0]
  ------------------
 1342|      4|	        enc = XML_CHAR_ENCODING_EBCDIC;
 1343|      4|                autoFlag = XML_INPUT_AUTO_OTHER;
  ------------------
  |  |   25|      4|#define XML_INPUT_AUTO_OTHER        (4u << 1)
  ------------------
 1344|      4|            }
 1345|      4|            break;
 1346|       |
 1347|     12|        case 0xEF:
  ------------------
  |  Branch (1347:9): [True: 12, False: 14.5k]
  ------------------
 1348|     12|            if ((in[1] == 0xBB) && (in[2] == 0xBF)) {
  ------------------
  |  Branch (1348:17): [True: 12, False: 0]
  |  Branch (1348:36): [True: 12, False: 0]
  ------------------
 1349|     12|                enc = XML_CHAR_ENCODING_UTF8;
 1350|     12|                autoFlag = XML_INPUT_AUTO_UTF8;
  ------------------
  |  |   22|     12|#define XML_INPUT_AUTO_UTF8         (1u << 1)
  ------------------
 1351|     12|                bomSize = 3;
 1352|     12|            }
 1353|     12|            break;
 1354|       |
 1355|      0|        case 0xFE:
  ------------------
  |  Branch (1355:9): [True: 0, False: 14.5k]
  ------------------
 1356|      0|            if (in[1] == 0xFF) {
  ------------------
  |  Branch (1356:17): [True: 0, False: 0]
  ------------------
 1357|      0|                enc = XML_CHAR_ENCODING_UTF16BE;
 1358|      0|                autoFlag = XML_INPUT_AUTO_UTF16BE;
  ------------------
  |  |   24|      0|#define XML_INPUT_AUTO_UTF16BE      (3u << 1)
  ------------------
 1359|      0|                bomSize = 2;
 1360|      0|            }
 1361|      0|            break;
 1362|       |
 1363|      0|        case 0xFF:
  ------------------
  |  Branch (1363:9): [True: 0, False: 14.5k]
  ------------------
 1364|      0|            if (in[1] == 0xFE) {
  ------------------
  |  Branch (1364:17): [True: 0, False: 0]
  ------------------
 1365|      0|                enc = XML_CHAR_ENCODING_UTF16LE;
 1366|      0|                autoFlag = XML_INPUT_AUTO_UTF16LE;
  ------------------
  |  |   23|      0|#define XML_INPUT_AUTO_UTF16LE      (2u << 1)
  ------------------
 1367|      0|                bomSize = 2;
 1368|      0|            }
 1369|      0|            break;
 1370|  14.5k|    }
 1371|       |
 1372|  14.5k|    if (bomSize > 0) {
  ------------------
  |  Branch (1372:9): [True: 12, False: 14.5k]
  ------------------
 1373|     12|        ctxt->input->cur += bomSize;
 1374|     12|    }
 1375|       |
 1376|  14.5k|    if (enc != XML_CHAR_ENCODING_NONE) {
  ------------------
  |  Branch (1376:9): [True: 16, False: 14.5k]
  ------------------
 1377|     16|        ctxt->input->flags |= autoFlag;
 1378|     16|        xmlSwitchEncoding(ctxt, enc);
 1379|     16|    }
 1380|  14.5k|}
xmlSetDeclaredEncoding:
 1395|    156|xmlSetDeclaredEncoding(xmlParserCtxtPtr ctxt, xmlChar *encoding) {
 1396|    156|    if (ctxt->encoding != NULL)
  ------------------
  |  Branch (1396:9): [True: 0, False: 156]
  ------------------
 1397|      0|        xmlFree((xmlChar *) ctxt->encoding);
 1398|    156|    ctxt->encoding = encoding;
 1399|       |
 1400|    156|    if (((ctxt->input->flags & XML_INPUT_HAS_ENCODING) == 0) &&
  ------------------
  |  |   20|    156|#define XML_INPUT_HAS_ENCODING      (1u << 0)
  ------------------
  |  Branch (1400:9): [True: 148, False: 8]
  ------------------
 1401|    156|        ((ctxt->options & XML_PARSE_IGNORE_ENC) == 0)) {
  ------------------
  |  Branch (1401:9): [True: 148, False: 0]
  ------------------
 1402|    148|        xmlCharEncodingHandlerPtr handler;
 1403|       |
 1404|    148|        handler = xmlFindCharEncodingHandler((const char *) encoding);
 1405|    148|        if (handler == NULL) {
  ------------------
  |  Branch (1405:13): [True: 0, False: 148]
  ------------------
 1406|      0|            __xmlErrEncoding(ctxt, XML_ERR_UNSUPPORTED_ENCODING,
 1407|      0|                             "Unsupported encoding: %s\n",
 1408|      0|                             encoding, NULL);
 1409|      0|            return;
 1410|      0|        }
 1411|       |
 1412|    148|        xmlSwitchToEncoding(ctxt, handler);
 1413|    148|        ctxt->input->flags |= XML_INPUT_USES_ENC_DECL;
  ------------------
  |  |   26|    148|#define XML_INPUT_USES_ENC_DECL     (1u << 4)
  ------------------
 1414|    148|    } else if (ctxt->input->flags & XML_INPUT_AUTO_ENCODING) {
  ------------------
  |  |   21|      8|#define XML_INPUT_AUTO_ENCODING     (7u << 1)
  ------------------
  |  Branch (1414:16): [True: 8, False: 0]
  ------------------
 1415|      8|        static const char *allowedUTF8[] = {
 1416|      8|            "UTF-8", "UTF8", NULL
 1417|      8|        };
 1418|      8|        static const char *allowedUTF16LE[] = {
 1419|      8|            "UTF-16", "UTF-16LE", "UTF16", NULL
 1420|      8|        };
 1421|      8|        static const char *allowedUTF16BE[] = {
 1422|      8|            "UTF-16", "UTF-16BE", "UTF16", NULL
 1423|      8|        };
 1424|      8|        const char **allowed = NULL;
 1425|      8|        const char *autoEnc = NULL;
 1426|       |
 1427|      8|        switch (ctxt->input->flags & XML_INPUT_AUTO_ENCODING) {
  ------------------
  |  |   21|      8|#define XML_INPUT_AUTO_ENCODING     (7u << 1)
  ------------------
  |  Branch (1427:17): [True: 4, False: 4]
  ------------------
 1428|      4|            case XML_INPUT_AUTO_UTF8:
  ------------------
  |  |   22|      4|#define XML_INPUT_AUTO_UTF8         (1u << 1)
  ------------------
  |  Branch (1428:13): [True: 4, False: 4]
  ------------------
 1429|      4|                allowed = allowedUTF8;
 1430|      4|                autoEnc = "UTF-8";
 1431|      4|                break;
 1432|      0|            case XML_INPUT_AUTO_UTF16LE:
  ------------------
  |  |   23|      0|#define XML_INPUT_AUTO_UTF16LE      (2u << 1)
  ------------------
  |  Branch (1432:13): [True: 0, False: 8]
  ------------------
 1433|      0|                allowed = allowedUTF16LE;
 1434|      0|                autoEnc = "UTF-16LE";
 1435|      0|                break;
 1436|      0|            case XML_INPUT_AUTO_UTF16BE:
  ------------------
  |  |   24|      0|#define XML_INPUT_AUTO_UTF16BE      (3u << 1)
  ------------------
  |  Branch (1436:13): [True: 0, False: 8]
  ------------------
 1437|      0|                allowed = allowedUTF16BE;
 1438|      0|                autoEnc = "UTF-16BE";
 1439|      0|                break;
 1440|      8|        }
 1441|       |
 1442|      8|        if (allowed != NULL) {
  ------------------
  |  Branch (1442:13): [True: 4, False: 4]
  ------------------
 1443|      4|            const char **p;
 1444|      4|            int match = 0;
 1445|       |
 1446|      4|            for (p = allowed; *p != NULL; p++) {
  ------------------
  |  Branch (1446:31): [True: 4, False: 0]
  ------------------
 1447|      4|                if (xmlStrcasecmp(encoding, BAD_CAST *p) == 0) {
  ------------------
  |  |   35|      4|#define BAD_CAST (xmlChar *)
  ------------------
  |  Branch (1447:21): [True: 4, False: 0]
  ------------------
 1448|      4|                    match = 1;
 1449|      4|                    break;
 1450|      4|                }
 1451|      4|            }
 1452|       |
 1453|      4|            if (match == 0) {
  ------------------
  |  Branch (1453:17): [True: 0, False: 4]
  ------------------
 1454|      0|                xmlWarningMsg(ctxt, XML_WAR_ENCODING_MISMATCH,
 1455|      0|                              "Encoding '%s' doesn't match "
 1456|      0|                              "auto-detected '%s'\n",
 1457|      0|                              encoding, BAD_CAST autoEnc);
  ------------------
  |  |   35|      0|#define BAD_CAST (xmlChar *)
  ------------------
 1458|      0|            }
 1459|      4|        }
 1460|      8|    }
 1461|    156|}
xmlFreeInputStream:
 1476|   139k|xmlFreeInputStream(xmlParserInputPtr input) {
 1477|   139k|    if (input == NULL) return;
  ------------------
  |  Branch (1477:9): [True: 0, False: 139k]
  ------------------
 1478|       |
 1479|   139k|    if (input->filename != NULL) xmlFree((char *) input->filename);
  ------------------
  |  Branch (1479:9): [True: 14.2k, False: 124k]
  ------------------
 1480|   139k|    if (input->directory != NULL) xmlFree((char *) input->directory);
  ------------------
  |  Branch (1480:9): [True: 0, False: 139k]
  ------------------
 1481|   139k|    if (input->version != NULL) xmlFree((char *) input->version);
  ------------------
  |  Branch (1481:9): [True: 24, False: 139k]
  ------------------
 1482|   139k|    if ((input->free != NULL) && (input->base != NULL))
  ------------------
  |  Branch (1482:9): [True: 0, False: 139k]
  |  Branch (1482:34): [True: 0, False: 0]
  ------------------
 1483|      0|        input->free((xmlChar *) input->base);
 1484|   139k|    if (input->buf != NULL)
  ------------------
  |  Branch (1484:9): [True: 14.4k, False: 124k]
  ------------------
 1485|  14.4k|        xmlFreeParserInputBuffer(input->buf);
 1486|   139k|    xmlFree(input);
 1487|   139k|}
xmlNewInputStream:
 1498|   139k|xmlNewInputStream(xmlParserCtxtPtr ctxt) {
 1499|   139k|    xmlParserInputPtr input;
 1500|       |
 1501|   139k|    input = (xmlParserInputPtr) xmlMalloc(sizeof(xmlParserInput));
 1502|   139k|    if (input == NULL) {
  ------------------
  |  Branch (1502:9): [True: 0, False: 139k]
  ------------------
 1503|      0|        xmlErrMemory(ctxt,  "couldn't allocate a new input stream\n");
 1504|      0|	return(NULL);
 1505|      0|    }
 1506|   139k|    memset(input, 0, sizeof(xmlParserInput));
 1507|   139k|    input->line = 1;
 1508|   139k|    input->col = 1;
 1509|       |
 1510|       |    /*
 1511|       |     * If the context is NULL the id cannot be initialized, but that
 1512|       |     * should not happen while parsing which is the situation where
 1513|       |     * the id is actually needed.
 1514|       |     */
 1515|   139k|    if (ctxt != NULL) {
  ------------------
  |  Branch (1515:9): [True: 139k, False: 0]
  ------------------
 1516|   139k|        if (input->id >= INT_MAX) {
  ------------------
  |  Branch (1516:13): [True: 0, False: 139k]
  ------------------
 1517|      0|            xmlErrMemory(ctxt, "Input ID overflow\n");
 1518|      0|            return(NULL);
 1519|      0|        }
 1520|   139k|        input->id = ctxt->input_id++;
 1521|   139k|    }
 1522|       |
 1523|   139k|    return(input);
 1524|   139k|}
xmlNewEntityInputStream:
 1572|   137k|xmlNewEntityInputStream(xmlParserCtxtPtr ctxt, xmlEntityPtr entity) {
 1573|   137k|    xmlParserInputPtr input;
 1574|       |
 1575|   137k|    if (entity == NULL) {
  ------------------
  |  Branch (1575:9): [True: 0, False: 137k]
  ------------------
 1576|      0|        xmlErrInternal(ctxt, "xmlNewEntityInputStream entity = NULL\n",
 1577|      0|	               NULL);
 1578|      0|	return(NULL);
 1579|      0|    }
 1580|   137k|    if (xmlParserDebugEntities)
  ------------------
  |  |  870|   137k|  #define xmlParserDebugEntities XML_GLOBAL_MACRO(xmlParserDebugEntities)
  |  |  ------------------
  |  |  |  |  500|   137k|  #define XML_GLOBAL_MACRO(name) (*__##name())
  |  |  |  |  ------------------
  |  |  |  |  |  Branch (500:34): [True: 0, False: 137k]
  |  |  |  |  ------------------
  |  |  ------------------
  ------------------
 1581|      0|	xmlGenericError(xmlGenericErrorContext,
  ------------------
  |  |  875|      0|  #define xmlGenericError XML_GLOBAL_MACRO(xmlGenericError)
  |  |  ------------------
  |  |  |  |  500|      0|  #define XML_GLOBAL_MACRO(name) (*__##name())
  |  |  ------------------
  ------------------
              	xmlGenericError(xmlGenericErrorContext,
  ------------------
  |  |  876|      0|  #define xmlGenericErrorContext XML_GLOBAL_MACRO(xmlGenericErrorContext)
  |  |  ------------------
  |  |  |  |  500|      0|  #define XML_GLOBAL_MACRO(name) (*__##name())
  |  |  ------------------
  ------------------
 1582|      0|		"new input from entity: %s\n", entity->name);
 1583|   137k|    if (entity->content == NULL) {
  ------------------
  |  Branch (1583:9): [True: 13.1k, False: 124k]
  ------------------
 1584|  13.1k|	switch (entity->etype) {
  ------------------
  |  Branch (1584:10): [True: 0, False: 13.1k]
  ------------------
 1585|      0|            case XML_EXTERNAL_GENERAL_UNPARSED_ENTITY:
  ------------------
  |  Branch (1585:13): [True: 0, False: 13.1k]
  ------------------
 1586|      0|	        xmlErrInternal(ctxt, "Cannot parse entity %s\n",
 1587|      0|		               entity->name);
 1588|      0|                break;
 1589|      0|            case XML_EXTERNAL_GENERAL_PARSED_ENTITY:
  ------------------
  |  Branch (1589:13): [True: 0, False: 13.1k]
  ------------------
 1590|  13.1k|            case XML_EXTERNAL_PARAMETER_ENTITY:
  ------------------
  |  Branch (1590:13): [True: 13.1k, False: 0]
  ------------------
 1591|  13.1k|		input = xmlLoadExternalEntity((char *) entity->URI,
 1592|  13.1k|		       (char *) entity->ExternalID, ctxt);
 1593|  13.1k|                if (input != NULL)
  ------------------
  |  Branch (1593:21): [True: 13.1k, False: 0]
  ------------------
 1594|  13.1k|                    input->entity = entity;
 1595|  13.1k|                return(input);
 1596|      0|            case XML_INTERNAL_GENERAL_ENTITY:
  ------------------
  |  Branch (1596:13): [True: 0, False: 13.1k]
  ------------------
 1597|      0|	        xmlErrInternal(ctxt,
 1598|      0|		      "Internal entity %s without content !\n",
 1599|      0|		               entity->name);
 1600|      0|                break;
 1601|      0|            case XML_INTERNAL_PARAMETER_ENTITY:
  ------------------
  |  Branch (1601:13): [True: 0, False: 13.1k]
  ------------------
 1602|      0|	        xmlErrInternal(ctxt,
 1603|      0|		      "Internal parameter entity %s without content !\n",
 1604|      0|		               entity->name);
 1605|      0|                break;
 1606|      0|            case XML_INTERNAL_PREDEFINED_ENTITY:
  ------------------
  |  Branch (1606:13): [True: 0, False: 13.1k]
  ------------------
 1607|      0|	        xmlErrInternal(ctxt,
 1608|      0|		      "Predefined entity %s without content !\n",
 1609|      0|		               entity->name);
 1610|      0|                break;
 1611|  13.1k|	}
 1612|      0|	return(NULL);
 1613|  13.1k|    }
 1614|   124k|    input = xmlNewInputStream(ctxt);
 1615|   124k|    if (input == NULL) {
  ------------------
  |  Branch (1615:9): [True: 0, False: 124k]
  ------------------
 1616|      0|	return(NULL);
 1617|      0|    }
 1618|   124k|    if (entity->URI != NULL)
  ------------------
  |  Branch (1618:9): [True: 0, False: 124k]
  ------------------
 1619|      0|	input->filename = (char *) xmlStrdup((xmlChar *) entity->URI);
 1620|   124k|    input->base = entity->content;
 1621|   124k|    if (entity->length == 0)
  ------------------
  |  Branch (1621:9): [True: 0, False: 124k]
  ------------------
 1622|      0|        entity->length = xmlStrlen(entity->content);
 1623|   124k|    input->cur = entity->content;
 1624|   124k|    input->length = entity->length;
 1625|   124k|    input->end = &entity->content[input->length];
 1626|   124k|    input->entity = entity;
 1627|   124k|    return(input);
 1628|   124k|}
xmlFreeParserCtxt:
 1967|  1.80k|{
 1968|  1.80k|    xmlParserInputPtr input;
 1969|       |
 1970|  1.80k|    if (ctxt == NULL) return;
  ------------------
  |  Branch (1970:9): [True: 0, False: 1.80k]
  ------------------
 1971|       |
 1972|  3.56k|    while ((input = inputPop(ctxt)) != NULL) { /* Non consuming */
  ------------------
  |  Branch (1972:12): [True: 1.75k, False: 1.80k]
  ------------------
 1973|  1.75k|        xmlFreeInputStream(input);
 1974|  1.75k|    }
 1975|  1.80k|    if (ctxt->spaceTab != NULL) xmlFree(ctxt->spaceTab);
  ------------------
  |  Branch (1975:9): [True: 1.80k, False: 0]
  ------------------
 1976|  1.80k|    if (ctxt->nameTab != NULL) xmlFree((xmlChar * *)ctxt->nameTab);
  ------------------
  |  Branch (1976:9): [True: 1.80k, False: 0]
  ------------------
 1977|  1.80k|    if (ctxt->nodeTab != NULL) xmlFree(ctxt->nodeTab);
  ------------------
  |  Branch (1977:9): [True: 1.80k, False: 0]
  ------------------
 1978|  1.80k|    if (ctxt->nodeInfoTab != NULL) xmlFree(ctxt->nodeInfoTab);
  ------------------
  |  Branch (1978:9): [True: 0, False: 1.80k]
  ------------------
 1979|  1.80k|    if (ctxt->inputTab != NULL) xmlFree(ctxt->inputTab);
  ------------------
  |  Branch (1979:9): [True: 1.80k, False: 0]
  ------------------
 1980|  1.80k|    if (ctxt->version != NULL) xmlFree((char *) ctxt->version);
  ------------------
  |  Branch (1980:9): [True: 1.28k, False: 518]
  ------------------
 1981|  1.80k|    if (ctxt->encoding != NULL) xmlFree((char *) ctxt->encoding);
  ------------------
  |  Branch (1981:9): [True: 140, False: 1.66k]
  ------------------
 1982|  1.80k|    if (ctxt->extSubURI != NULL) xmlFree((char *) ctxt->extSubURI);
  ------------------
  |  Branch (1982:9): [True: 268, False: 1.53k]
  ------------------
 1983|  1.80k|    if (ctxt->extSubSystem != NULL) xmlFree((char *) ctxt->extSubSystem);
  ------------------
  |  Branch (1983:9): [True: 160, False: 1.64k]
  ------------------
 1984|  1.80k|#ifdef LIBXML_SAX1_ENABLED
 1985|  1.80k|    if ((ctxt->sax != NULL) &&
  ------------------
  |  Branch (1985:9): [True: 1.80k, False: 0]
  ------------------
 1986|  1.80k|        (ctxt->sax != (xmlSAXHandlerPtr) &xmlDefaultSAXHandler))
  ------------------
  |  |  860|  1.80k|  #define xmlDefaultSAXHandler XML_GLOBAL_MACRO(xmlDefaultSAXHandler)
  |  |  ------------------
  |  |  |  |  500|  1.80k|  #define XML_GLOBAL_MACRO(name) (*__##name())
  |  |  ------------------
  ------------------
  |  Branch (1986:9): [True: 1.80k, False: 0]
  ------------------
 1987|       |#else
 1988|       |    if (ctxt->sax != NULL)
 1989|       |#endif /* LIBXML_SAX1_ENABLED */
 1990|  1.80k|        xmlFree(ctxt->sax);
 1991|  1.80k|    if (ctxt->directory != NULL) xmlFree((char *) ctxt->directory);
  ------------------
  |  Branch (1991:9): [True: 359, False: 1.44k]
  ------------------
 1992|  1.80k|    if (ctxt->vctxt.nodeTab != NULL) xmlFree(ctxt->vctxt.nodeTab);
  ------------------
  |  Branch (1992:9): [True: 0, False: 1.80k]
  ------------------
 1993|  1.80k|    if (ctxt->atts != NULL) xmlFree((xmlChar * *)ctxt->atts);
  ------------------
  |  Branch (1993:9): [True: 516, False: 1.29k]
  ------------------
 1994|  1.80k|    if (ctxt->dict != NULL) xmlDictFree(ctxt->dict);
  ------------------
  |  Branch (1994:9): [True: 1.33k, False: 468]
  ------------------
 1995|  1.80k|    if (ctxt->nsTab != NULL) xmlFree(ctxt->nsTab);
  ------------------
  |  Branch (1995:9): [True: 288, False: 1.51k]
  ------------------
 1996|  1.80k|    if (ctxt->nsdb != NULL) xmlParserNsFree(ctxt->nsdb);
  ------------------
  |  Branch (1996:9): [True: 1.80k, False: 0]
  ------------------
 1997|  1.80k|    if (ctxt->attrHash != NULL) xmlFree(ctxt->attrHash);
  ------------------
  |  Branch (1997:9): [True: 306, False: 1.50k]
  ------------------
 1998|  1.80k|    if (ctxt->pushTab != NULL) xmlFree(ctxt->pushTab);
  ------------------
  |  Branch (1998:9): [True: 1.09k, False: 712]
  ------------------
 1999|  1.80k|    if (ctxt->attallocs != NULL) xmlFree(ctxt->attallocs);
  ------------------
  |  Branch (1999:9): [True: 516, False: 1.29k]
  ------------------
 2000|  1.80k|    if (ctxt->attsDefault != NULL)
  ------------------
  |  Branch (2000:9): [True: 72, False: 1.73k]
  ------------------
 2001|     72|        xmlHashFree(ctxt->attsDefault, xmlHashDefaultDeallocator);
 2002|  1.80k|    if (ctxt->attsSpecial != NULL)
  ------------------
  |  Branch (2002:9): [True: 108, False: 1.69k]
  ------------------
 2003|    108|        xmlHashFree(ctxt->attsSpecial, NULL);
 2004|  1.80k|    if (ctxt->freeElems != NULL) {
  ------------------
  |  Branch (2004:9): [True: 283, False: 1.52k]
  ------------------
 2005|    283|        xmlNodePtr cur, next;
 2006|       |
 2007|    283|	cur = ctxt->freeElems;
 2008|    566|	while (cur != NULL) {
  ------------------
  |  Branch (2008:9): [True: 283, False: 283]
  ------------------
 2009|    283|	    next = cur->next;
 2010|    283|	    xmlFree(cur);
 2011|    283|	    cur = next;
 2012|    283|	}
 2013|    283|    }
 2014|  1.80k|    if (ctxt->freeAttrs != NULL) {
  ------------------
  |  Branch (2014:9): [True: 116, False: 1.69k]
  ------------------
 2015|    116|        xmlAttrPtr cur, next;
 2016|       |
 2017|    116|	cur = ctxt->freeAttrs;
 2018|    232|	while (cur != NULL) {
  ------------------
  |  Branch (2018:9): [True: 116, False: 116]
  ------------------
 2019|    116|	    next = cur->next;
 2020|    116|	    xmlFree(cur);
 2021|    116|	    cur = next;
 2022|    116|	}
 2023|    116|    }
 2024|       |    /*
 2025|       |     * cleanup the error strings
 2026|       |     */
 2027|  1.80k|    if (ctxt->lastError.message != NULL)
  ------------------
  |  Branch (2027:9): [True: 1.03k, False: 776]
  ------------------
 2028|  1.03k|        xmlFree(ctxt->lastError.message);
 2029|  1.80k|    if (ctxt->lastError.file != NULL)
  ------------------
  |  Branch (2029:9): [True: 599, False: 1.20k]
  ------------------
 2030|    599|        xmlFree(ctxt->lastError.file);
 2031|  1.80k|    if (ctxt->lastError.str1 != NULL)
  ------------------
  |  Branch (2031:9): [True: 276, False: 1.53k]
  ------------------
 2032|    276|        xmlFree(ctxt->lastError.str1);
 2033|  1.80k|    if (ctxt->lastError.str2 != NULL)
  ------------------
  |  Branch (2033:9): [True: 77, False: 1.72k]
  ------------------
 2034|     77|        xmlFree(ctxt->lastError.str2);
 2035|  1.80k|    if (ctxt->lastError.str3 != NULL)
  ------------------
  |  Branch (2035:9): [True: 14, False: 1.79k]
  ------------------
 2036|     14|        xmlFree(ctxt->lastError.str3);
 2037|       |
 2038|  1.80k|#ifdef LIBXML_CATALOG_ENABLED
 2039|  1.80k|    if (ctxt->catalogs != NULL)
  ------------------
  |  Branch (2039:9): [True: 0, False: 1.80k]
  ------------------
 2040|      0|	xmlCatalogFreeLocal(ctxt->catalogs);
 2041|  1.80k|#endif
 2042|  1.80k|    xmlFree(ctxt);
 2043|  1.80k|}
xmlNewParserCtxt:
 2055|  1.07k|{
 2056|  1.07k|    return(xmlNewSAXParserCtxt(NULL, NULL));
 2057|  1.07k|}
xmlNewSAXParserCtxt:
 2072|  1.80k|{
 2073|  1.80k|    xmlParserCtxtPtr ctxt;
 2074|       |
 2075|  1.80k|    ctxt = (xmlParserCtxtPtr) xmlMalloc(sizeof(xmlParserCtxt));
 2076|  1.80k|    if (ctxt == NULL) {
  ------------------
  |  Branch (2076:9): [True: 0, False: 1.80k]
  ------------------
 2077|      0|	xmlErrMemory(NULL, "cannot allocate parser context\n");
 2078|      0|	return(NULL);
 2079|      0|    }
 2080|  1.80k|    memset(ctxt, 0, sizeof(xmlParserCtxt));
 2081|  1.80k|    if (xmlInitSAXParserCtxt(ctxt, sax, userData) < 0) {
  ------------------
  |  Branch (2081:9): [True: 0, False: 1.80k]
  ------------------
 2082|      0|        xmlFreeParserCtxt(ctxt);
 2083|      0|	return(NULL);
 2084|      0|    }
 2085|  1.80k|    return(ctxt);
 2086|  1.80k|}
xmlInitNodeInfoSeq:
 2149|  1.80k|{
 2150|  1.80k|    if (seq == NULL)
  ------------------
  |  Branch (2150:9): [True: 0, False: 1.80k]
  ------------------
 2151|      0|        return;
 2152|  1.80k|    seq->length = 0;
 2153|  1.80k|    seq->maximum = 0;
 2154|  1.80k|    seq->buffer = NULL;
 2155|  1.80k|}
parserInternals.c:xmlDetectEBCDIC:
 1055|      4|xmlDetectEBCDIC(xmlParserInputPtr input) {
 1056|      4|    xmlChar out[200];
 1057|      4|    xmlCharEncodingHandlerPtr handler;
 1058|      4|    int inlen, outlen, res, i;
 1059|       |
 1060|       |    /*
 1061|       |     * To detect the EBCDIC code page, we convert the first 200 bytes
 1062|       |     * to EBCDIC-US and try to find the encoding declaration.
 1063|       |     */
 1064|      4|    handler = xmlGetCharEncodingHandler(XML_CHAR_ENCODING_EBCDIC);
 1065|      4|    if (handler == NULL)
  ------------------
  |  Branch (1065:9): [True: 0, False: 4]
  ------------------
 1066|      0|        return(NULL);
 1067|      4|    outlen = sizeof(out) - 1;
 1068|      4|    inlen = input->end - input->cur;
 1069|      4|    res = xmlEncInputChunk(handler, out, &outlen, input->cur, &inlen);
 1070|      4|    if (res < 0)
  ------------------
  |  Branch (1070:9): [True: 0, False: 4]
  ------------------
 1071|      0|        return(handler);
 1072|      4|    out[outlen] = 0;
 1073|       |
 1074|     84|    for (i = 0; i < outlen; i++) {
  ------------------
  |  Branch (1074:17): [True: 84, False: 0]
  ------------------
 1075|     84|        if (out[i] == '>')
  ------------------
  |  Branch (1075:13): [True: 0, False: 84]
  ------------------
 1076|      0|            break;
 1077|     84|        if ((out[i] == 'e') &&
  ------------------
  |  Branch (1077:13): [True: 8, False: 76]
  ------------------
 1078|     84|            (xmlStrncmp(out + i, BAD_CAST "encoding", 8) == 0)) {
  ------------------
  |  |   35|      8|#define BAD_CAST (xmlChar *)
  ------------------
  |  Branch (1078:13): [True: 4, False: 4]
  ------------------
 1079|      4|            int start, cur, quote;
 1080|       |
 1081|      4|            i += 8;
 1082|      4|            while (IS_BLANK_CH(out[i]))
 1083|      0|                i += 1;
 1084|      4|            if (out[i++] != '=')
  ------------------
  |  Branch (1084:17): [True: 0, False: 4]
  ------------------
 1085|      0|                break;
 1086|      4|            while (IS_BLANK_CH(out[i]))
 1087|      0|                i += 1;
 1088|      4|            quote = out[i++];
 1089|      4|            if ((quote != '\'') && (quote != '"'))
  ------------------
  |  Branch (1089:17): [True: 4, False: 0]
  |  Branch (1089:36): [True: 0, False: 4]
  ------------------
 1090|      0|                break;
 1091|      4|            start = i;
 1092|      4|            cur = out[i];
 1093|     36|            while (((cur >= 'a') && (cur <= 'z')) ||
  ------------------
  |  Branch (1093:21): [True: 0, False: 36]
  |  Branch (1093:37): [True: 0, False: 0]
  ------------------
 1094|     36|                   ((cur >= 'A') && (cur <= 'Z')) ||
  ------------------
  |  Branch (1094:21): [True: 12, False: 24]
  |  Branch (1094:37): [True: 12, False: 0]
  ------------------
 1095|     36|                   ((cur >= '0') && (cur <= '9')) ||
  ------------------
  |  Branch (1095:21): [True: 16, False: 8]
  |  Branch (1095:37): [True: 16, False: 0]
  ------------------
 1096|     36|                   (cur == '.') || (cur == '_') ||
  ------------------
  |  Branch (1096:20): [True: 0, False: 8]
  |  Branch (1096:36): [True: 0, False: 8]
  ------------------
 1097|     36|                   (cur == '-'))
  ------------------
  |  Branch (1097:20): [True: 4, False: 4]
  ------------------
 1098|     32|                cur = out[++i];
 1099|      4|            if (cur != quote)
  ------------------
  |  Branch (1099:17): [True: 0, False: 4]
  ------------------
 1100|      0|                break;
 1101|      4|            out[i] = 0;
 1102|      4|            xmlCharEncCloseFunc(handler);
 1103|      4|            return(xmlFindCharEncodingHandler((char *) out + start));
 1104|      4|        }
 1105|     84|    }
 1106|       |
 1107|       |    /*
 1108|       |     * ICU handlers are stateful, so we have to recreate them.
 1109|       |     */
 1110|      0|    xmlCharEncCloseFunc(handler);
 1111|      0|    return(xmlGetCharEncodingHandler(XML_CHAR_ENCODING_EBCDIC));
 1112|      4|}
parserInternals.c:xmlInitSAXParserCtxt:
 1746|  1.80k|{
 1747|  1.80k|    xmlParserInputPtr input;
 1748|       |
 1749|  1.80k|    if(ctxt==NULL) {
  ------------------
  |  Branch (1749:8): [True: 0, False: 1.80k]
  ------------------
 1750|      0|        xmlErrInternal(NULL, "Got NULL parser context\n", NULL);
 1751|      0|        return(-1);
 1752|      0|    }
 1753|       |
 1754|  1.80k|    xmlInitParser();
 1755|       |
 1756|  1.80k|    if (ctxt->dict == NULL)
  ------------------
  |  Branch (1756:9): [True: 1.80k, False: 0]
  ------------------
 1757|  1.80k|	ctxt->dict = xmlDictCreate();
 1758|  1.80k|    if (ctxt->dict == NULL) {
  ------------------
  |  Branch (1758:9): [True: 0, False: 1.80k]
  ------------------
 1759|      0|        xmlErrMemory(NULL, "cannot initialize parser context\n");
 1760|      0|	return(-1);
 1761|      0|    }
 1762|  1.80k|    xmlDictSetLimit(ctxt->dict, XML_MAX_DICTIONARY_LIMIT);
  ------------------
  |  |   71|  1.80k|#define XML_MAX_DICTIONARY_LIMIT 10000000
  ------------------
 1763|       |
 1764|  1.80k|    if (ctxt->sax == NULL)
  ------------------
  |  Branch (1764:9): [True: 1.80k, False: 0]
  ------------------
 1765|  1.80k|	ctxt->sax = (xmlSAXHandler *) xmlMalloc(sizeof(xmlSAXHandler));
 1766|  1.80k|    if (ctxt->sax == NULL) {
  ------------------
  |  Branch (1766:9): [True: 0, False: 1.80k]
  ------------------
 1767|      0|        xmlErrMemory(NULL, "cannot initialize parser context\n");
 1768|      0|	return(-1);
 1769|      0|    }
 1770|  1.80k|    if (sax == NULL) {
  ------------------
  |  Branch (1770:9): [True: 1.44k, False: 363]
  ------------------
 1771|  1.44k|	memset(ctxt->sax, 0, sizeof(xmlSAXHandler));
 1772|  1.44k|        xmlSAXVersion(ctxt->sax, 2);
 1773|  1.44k|        ctxt->userData = ctxt;
 1774|  1.44k|    } else {
 1775|    363|	if (sax->initialized == XML_SAX2_MAGIC) {
  ------------------
  |  |  685|    363|#define XML_SAX2_MAGIC 0xDEEDBEAF
  ------------------
  |  Branch (1775:6): [True: 363, False: 0]
  ------------------
 1776|    363|	    memcpy(ctxt->sax, sax, sizeof(xmlSAXHandler));
 1777|    363|        } else {
 1778|      0|	    memset(ctxt->sax, 0, sizeof(xmlSAXHandler));
 1779|      0|	    memcpy(ctxt->sax, sax, sizeof(xmlSAXHandlerV1));
 1780|      0|        }
 1781|    363|        ctxt->userData = userData ? userData : ctxt;
  ------------------
  |  Branch (1781:26): [True: 0, False: 363]
  ------------------
 1782|    363|    }
 1783|       |
 1784|  1.80k|    ctxt->maxatts = 0;
 1785|  1.80k|    ctxt->atts = NULL;
 1786|       |    /* Allocate the Input stack */
 1787|  1.80k|    if (ctxt->inputTab == NULL) {
  ------------------
  |  Branch (1787:9): [True: 1.80k, False: 0]
  ------------------
 1788|  1.80k|	ctxt->inputTab = (xmlParserInputPtr *)
 1789|  1.80k|		    xmlMalloc(5 * sizeof(xmlParserInputPtr));
 1790|  1.80k|	ctxt->inputMax = 5;
 1791|  1.80k|    }
 1792|  1.80k|    if (ctxt->inputTab == NULL) {
  ------------------
  |  Branch (1792:9): [True: 0, False: 1.80k]
  ------------------
 1793|      0|        xmlErrMemory(NULL, "cannot initialize parser context\n");
 1794|      0|	ctxt->inputNr = 0;
 1795|      0|	ctxt->inputMax = 0;
 1796|      0|	ctxt->input = NULL;
 1797|      0|	return(-1);
 1798|      0|    }
 1799|  1.80k|    while ((input = inputPop(ctxt)) != NULL) { /* Non consuming */
  ------------------
  |  Branch (1799:12): [True: 0, False: 1.80k]
  ------------------
 1800|      0|        xmlFreeInputStream(input);
 1801|      0|    }
 1802|  1.80k|    ctxt->inputNr = 0;
 1803|  1.80k|    ctxt->input = NULL;
 1804|       |
 1805|  1.80k|    ctxt->version = NULL;
 1806|  1.80k|    ctxt->encoding = NULL;
 1807|  1.80k|    ctxt->standalone = -1;
 1808|  1.80k|    ctxt->hasExternalSubset = 0;
 1809|  1.80k|    ctxt->hasPErefs = 0;
 1810|  1.80k|    ctxt->html = 0;
 1811|  1.80k|    ctxt->external = 0;
 1812|  1.80k|    ctxt->instate = XML_PARSER_START;
 1813|  1.80k|    ctxt->token = 0;
 1814|  1.80k|    ctxt->directory = NULL;
 1815|       |
 1816|       |    /* Allocate the Node stack */
 1817|  1.80k|    if (ctxt->nodeTab == NULL) {
  ------------------
  |  Branch (1817:9): [True: 1.80k, False: 0]
  ------------------
 1818|  1.80k|	ctxt->nodeTab = (xmlNodePtr *) xmlMalloc(10 * sizeof(xmlNodePtr));
 1819|  1.80k|	ctxt->nodeMax = 10;
 1820|  1.80k|    }
 1821|  1.80k|    if (ctxt->nodeTab == NULL) {
  ------------------
  |  Branch (1821:9): [True: 0, False: 1.80k]
  ------------------
 1822|      0|        xmlErrMemory(NULL, "cannot initialize parser context\n");
 1823|      0|	ctxt->nodeNr = 0;
 1824|      0|	ctxt->nodeMax = 0;
 1825|      0|	ctxt->node = NULL;
 1826|      0|	ctxt->inputNr = 0;
 1827|      0|	ctxt->inputMax = 0;
 1828|      0|	ctxt->input = NULL;
 1829|      0|	return(-1);
 1830|      0|    }
 1831|  1.80k|    ctxt->nodeNr = 0;
 1832|  1.80k|    ctxt->node = NULL;
 1833|       |
 1834|       |    /* Allocate the Name stack */
 1835|  1.80k|    if (ctxt->nameTab == NULL) {
  ------------------
  |  Branch (1835:9): [True: 1.80k, False: 0]
  ------------------
 1836|  1.80k|	ctxt->nameTab = (const xmlChar **) xmlMalloc(10 * sizeof(xmlChar *));
 1837|  1.80k|	ctxt->nameMax = 10;
 1838|  1.80k|    }
 1839|  1.80k|    if (ctxt->nameTab == NULL) {
  ------------------
  |  Branch (1839:9): [True: 0, False: 1.80k]
  ------------------
 1840|      0|        xmlErrMemory(NULL, "cannot initialize parser context\n");
 1841|      0|	ctxt->nodeNr = 0;
 1842|      0|	ctxt->nodeMax = 0;
 1843|      0|	ctxt->node = NULL;
 1844|      0|	ctxt->inputNr = 0;
 1845|      0|	ctxt->inputMax = 0;
 1846|      0|	ctxt->input = NULL;
 1847|      0|	ctxt->nameNr = 0;
 1848|      0|	ctxt->nameMax = 0;
 1849|      0|	ctxt->name = NULL;
 1850|      0|	return(-1);
 1851|      0|    }
 1852|  1.80k|    ctxt->nameNr = 0;
 1853|  1.80k|    ctxt->name = NULL;
 1854|       |
 1855|       |    /* Allocate the space stack */
 1856|  1.80k|    if (ctxt->spaceTab == NULL) {
  ------------------
  |  Branch (1856:9): [True: 1.80k, False: 0]
  ------------------
 1857|  1.80k|	ctxt->spaceTab = (int *) xmlMalloc(10 * sizeof(int));
 1858|  1.80k|	ctxt->spaceMax = 10;
 1859|  1.80k|    }
 1860|  1.80k|    if (ctxt->spaceTab == NULL) {
  ------------------
  |  Branch (1860:9): [True: 0, False: 1.80k]
  ------------------
 1861|      0|        xmlErrMemory(NULL, "cannot initialize parser context\n");
 1862|      0|	ctxt->nodeNr = 0;
 1863|      0|	ctxt->nodeMax = 0;
 1864|      0|	ctxt->node = NULL;
 1865|      0|	ctxt->inputNr = 0;
 1866|      0|	ctxt->inputMax = 0;
 1867|      0|	ctxt->input = NULL;
 1868|      0|	ctxt->nameNr = 0;
 1869|      0|	ctxt->nameMax = 0;
 1870|      0|	ctxt->name = NULL;
 1871|      0|	ctxt->spaceNr = 0;
 1872|      0|	ctxt->spaceMax = 0;
 1873|      0|	ctxt->space = NULL;
 1874|      0|	return(-1);
 1875|      0|    }
 1876|  1.80k|    ctxt->spaceNr = 1;
 1877|  1.80k|    ctxt->spaceMax = 10;
 1878|  1.80k|    ctxt->spaceTab[0] = -1;
 1879|  1.80k|    ctxt->space = &ctxt->spaceTab[0];
 1880|  1.80k|    ctxt->myDoc = NULL;
 1881|  1.80k|    ctxt->wellFormed = 1;
 1882|  1.80k|    ctxt->nsWellFormed = 1;
 1883|  1.80k|    ctxt->valid = 1;
 1884|  1.80k|    ctxt->loadsubset = xmlLoadExtDtdDefaultValue;
  ------------------
  |  |  869|  1.80k|  #define xmlLoadExtDtdDefaultValue XML_GLOBAL_MACRO(xmlLoadExtDtdDefaultValue)
  |  |  ------------------
  |  |  |  |  500|  1.80k|  #define XML_GLOBAL_MACRO(name) (*__##name())
  |  |  ------------------
  ------------------
 1885|  1.80k|    if (ctxt->loadsubset) {
  ------------------
  |  Branch (1885:9): [True: 0, False: 1.80k]
  ------------------
 1886|      0|        ctxt->options |= XML_PARSE_DTDLOAD;
 1887|      0|    }
 1888|  1.80k|    ctxt->validate = xmlDoValidityCheckingDefaultValue;
  ------------------
  |  |  863|  1.80k|    XML_GLOBAL_MACRO(xmlDoValidityCheckingDefaultValue)
  |  |  ------------------
  |  |  |  |  500|  1.80k|  #define XML_GLOBAL_MACRO(name) (*__##name())
  |  |  ------------------
  ------------------
 1889|  1.80k|    ctxt->pedantic = xmlPedanticParserDefaultValue;
  ------------------
  |  |  872|  1.80k|    XML_GLOBAL_MACRO(xmlPedanticParserDefaultValue)
  |  |  ------------------
  |  |  |  |  500|  1.80k|  #define XML_GLOBAL_MACRO(name) (*__##name())
  |  |  ------------------
  ------------------
 1890|  1.80k|    if (ctxt->pedantic) {
  ------------------
  |  Branch (1890:9): [True: 0, False: 1.80k]
  ------------------
 1891|      0|        ctxt->options |= XML_PARSE_PEDANTIC;
 1892|      0|    }
 1893|  1.80k|    ctxt->linenumbers = xmlLineNumbersDefaultValue;
  ------------------
  |  |  868|  1.80k|    XML_GLOBAL_MACRO(xmlLineNumbersDefaultValue)
  |  |  ------------------
  |  |  |  |  500|  1.80k|  #define XML_GLOBAL_MACRO(name) (*__##name())
  |  |  ------------------
  ------------------
 1894|  1.80k|    ctxt->keepBlanks = xmlKeepBlanksDefaultValue;
  ------------------
  |  |  866|  1.80k|  #define xmlKeepBlanksDefaultValue XML_GLOBAL_MACRO(xmlKeepBlanksDefaultValue)
  |  |  ------------------
  |  |  |  |  500|  1.80k|  #define XML_GLOBAL_MACRO(name) (*__##name())
  |  |  ------------------
  ------------------
 1895|  1.80k|    if (ctxt->keepBlanks == 0) {
  ------------------
  |  Branch (1895:9): [True: 0, False: 1.80k]
  ------------------
 1896|      0|	ctxt->sax->ignorableWhitespace = xmlSAX2IgnorableWhitespace;
 1897|      0|	ctxt->options |= XML_PARSE_NOBLANKS;
 1898|      0|    }
 1899|       |
 1900|  1.80k|    ctxt->vctxt.flags = XML_VCTXT_USE_PCTXT;
  ------------------
  |  |   18|  1.80k|#define XML_VCTXT_USE_PCTXT (1u << 1)
  ------------------
 1901|  1.80k|    ctxt->vctxt.userData = ctxt;
 1902|  1.80k|    ctxt->vctxt.error = xmlParserValidityError;
 1903|  1.80k|    ctxt->vctxt.warning = xmlParserValidityWarning;
 1904|  1.80k|    if (ctxt->validate) {
  ------------------
  |  Branch (1904:9): [True: 0, False: 1.80k]
  ------------------
 1905|      0|	if (xmlGetWarningsDefaultValue == 0)
  ------------------
  |  |  865|      0|    XML_GLOBAL_MACRO(xmlGetWarningsDefaultValue)
  |  |  ------------------
  |  |  |  |  500|      0|  #define XML_GLOBAL_MACRO(name) (*__##name())
  |  |  ------------------
  ------------------
  |  Branch (1905:6): [True: 0, False: 0]
  ------------------
 1906|      0|	    ctxt->vctxt.warning = NULL;
 1907|      0|	else
 1908|      0|	    ctxt->vctxt.warning = xmlParserValidityWarning;
 1909|      0|	ctxt->vctxt.nodeMax = 0;
 1910|      0|        ctxt->options |= XML_PARSE_DTDVALID;
 1911|      0|    }
 1912|  1.80k|    ctxt->replaceEntities = xmlSubstituteEntitiesDefaultValue;
  ------------------
  |  |  874|  1.80k|    XML_GLOBAL_MACRO(xmlSubstituteEntitiesDefaultValue)
  |  |  ------------------
  |  |  |  |  500|  1.80k|  #define XML_GLOBAL_MACRO(name) (*__##name())
  |  |  ------------------
  ------------------
 1913|  1.80k|    if (ctxt->replaceEntities) {
  ------------------
  |  Branch (1913:9): [True: 0, False: 1.80k]
  ------------------
 1914|      0|        ctxt->options |= XML_PARSE_NOENT;
 1915|      0|    }
 1916|  1.80k|    ctxt->record_info = 0;
 1917|  1.80k|    ctxt->checkIndex = 0;
 1918|  1.80k|    ctxt->inSubset = 0;
 1919|  1.80k|    ctxt->errNo = XML_ERR_OK;
 1920|  1.80k|    ctxt->depth = 0;
 1921|  1.80k|    ctxt->catalogs = NULL;
 1922|  1.80k|    ctxt->sizeentities = 0;
 1923|  1.80k|    ctxt->sizeentcopy = 0;
 1924|  1.80k|    ctxt->input_id = 1;
 1925|  1.80k|    ctxt->maxAmpl = XML_MAX_AMPLIFICATION_DEFAULT;
  ------------------
  |  |   52|  1.80k|#define XML_MAX_AMPLIFICATION_DEFAULT 5
  ------------------
 1926|  1.80k|    xmlInitNodeInfoSeq(&ctxt->node_seq);
 1927|       |
 1928|  1.80k|    if (ctxt->nsdb == NULL) {
  ------------------
  |  Branch (1928:9): [True: 1.80k, False: 0]
  ------------------
 1929|  1.80k|        ctxt->nsdb = xmlParserNsCreate();
 1930|  1.80k|        if (ctxt->nsdb == NULL) {
  ------------------
  |  Branch (1930:13): [True: 0, False: 1.80k]
  ------------------
 1931|      0|            xmlErrMemory(ctxt, NULL);
 1932|      0|            return(-1);
 1933|      0|        }
 1934|  1.80k|    }
 1935|       |
 1936|  1.80k|    return(0);
 1937|  1.80k|}

xmlInitMutex:
  129|      8|{
  130|      8|#ifdef HAVE_POSIX_THREADS
  131|      8|    if (XML_IS_NEVER_THREADED() == 0)
  ------------------
  |  |   85|      8|#define XML_IS_NEVER_THREADED() (!libxml_is_threaded)
  ------------------
  |  Branch (131:9): [True: 8, False: 0]
  ------------------
  132|      8|        pthread_mutex_init(&mutex->lock, NULL);
  133|       |#elif defined HAVE_WIN32_THREADS
  134|       |    InitializeCriticalSection(&mutex->cs);
  135|       |#else
  136|       |    (void) mutex;
  137|       |#endif
  138|      8|}
xmlMutexLock:
  202|  7.08k|{
  203|  7.08k|    if (tok == NULL)
  ------------------
  |  Branch (203:9): [True: 0, False: 7.08k]
  ------------------
  204|      0|        return;
  205|  7.08k|#ifdef HAVE_POSIX_THREADS
  206|       |    /*
  207|       |     * This assumes that __libc_single_threaded won't change while the
  208|       |     * lock is held.
  209|       |     */
  210|  7.08k|    if (XML_IS_THREADED() != 0)
  ------------------
  |  |   84|  7.08k|#define XML_IS_THREADED() libxml_is_threaded
  ------------------
  |  Branch (210:9): [True: 7.08k, False: 0]
  ------------------
  211|  7.08k|        pthread_mutex_lock(&tok->lock);
  212|       |#elif defined HAVE_WIN32_THREADS
  213|       |    EnterCriticalSection(&tok->cs);
  214|       |#endif
  215|       |
  216|  7.08k|}
xmlMutexUnlock:
  226|  7.08k|{
  227|  7.08k|    if (tok == NULL)
  ------------------
  |  Branch (227:9): [True: 0, False: 7.08k]
  ------------------
  228|      0|        return;
  229|  7.08k|#ifdef HAVE_POSIX_THREADS
  230|  7.08k|    if (XML_IS_THREADED() != 0)
  ------------------
  |  |   84|  7.08k|#define XML_IS_THREADED() libxml_is_threaded
  ------------------
  |  Branch (230:9): [True: 7.08k, False: 0]
  ------------------
  231|  7.08k|        pthread_mutex_unlock(&tok->lock);
  232|       |#elif defined HAVE_WIN32_THREADS
  233|       |    LeaveCriticalSection(&tok->cs);
  234|       |#endif
  235|  7.08k|}
xmlNewRMutex:
  249|      2|{
  250|      2|    xmlRMutexPtr tok;
  251|       |
  252|      2|    if ((tok = malloc(sizeof(xmlRMutex))) == NULL)
  ------------------
  |  Branch (252:9): [True: 0, False: 2]
  ------------------
  253|      0|        return (NULL);
  254|      2|#ifdef HAVE_POSIX_THREADS
  255|      2|    if (XML_IS_NEVER_THREADED() == 0) {
  ------------------
  |  |   85|      2|#define XML_IS_NEVER_THREADED() (!libxml_is_threaded)
  ------------------
  |  Branch (255:9): [True: 2, False: 0]
  ------------------
  256|      2|        pthread_mutex_init(&tok->lock, NULL);
  257|      2|        tok->held = 0;
  258|      2|        tok->waiters = 0;
  259|      2|        pthread_cond_init(&tok->cv, NULL);
  260|      2|    }
  261|       |#elif defined HAVE_WIN32_THREADS
  262|       |    InitializeCriticalSection(&tok->cs);
  263|       |#endif
  264|      2|    return (tok);
  265|      2|}
xmlRMutexLock:
  298|      2|{
  299|      2|    if (tok == NULL)
  ------------------
  |  Branch (299:9): [True: 0, False: 2]
  ------------------
  300|      0|        return;
  301|      2|#ifdef HAVE_POSIX_THREADS
  302|      2|    if (XML_IS_THREADED() == 0)
  ------------------
  |  |   84|      2|#define XML_IS_THREADED() libxml_is_threaded
  ------------------
  |  Branch (302:9): [True: 0, False: 2]
  ------------------
  303|      0|        return;
  304|       |
  305|      2|    pthread_mutex_lock(&tok->lock);
  306|      2|    if (tok->held) {
  ------------------
  |  Branch (306:9): [True: 0, False: 2]
  ------------------
  307|      0|        if (pthread_equal(tok->tid, pthread_self())) {
  ------------------
  |  Branch (307:13): [True: 0, False: 0]
  ------------------
  308|      0|            tok->held++;
  309|      0|            pthread_mutex_unlock(&tok->lock);
  310|      0|            return;
  311|      0|        } else {
  312|      0|            tok->waiters++;
  313|      0|            while (tok->held)
  ------------------
  |  Branch (313:20): [True: 0, False: 0]
  ------------------
  314|      0|                pthread_cond_wait(&tok->cv, &tok->lock);
  315|      0|            tok->waiters--;
  316|      0|        }
  317|      0|    }
  318|      2|    tok->tid = pthread_self();
  319|      2|    tok->held = 1;
  320|      2|    pthread_mutex_unlock(&tok->lock);
  321|       |#elif defined HAVE_WIN32_THREADS
  322|       |    EnterCriticalSection(&tok->cs);
  323|       |#endif
  324|      2|}
xmlRMutexUnlock:
  334|      2|{
  335|      2|    if (tok == NULL)
  ------------------
  |  Branch (335:9): [True: 0, False: 2]
  ------------------
  336|      0|        return;
  337|      2|#ifdef HAVE_POSIX_THREADS
  338|      2|    if (XML_IS_THREADED() == 0)
  ------------------
  |  |   84|      2|#define XML_IS_THREADED() libxml_is_threaded
  ------------------
  |  Branch (338:9): [True: 0, False: 2]
  ------------------
  339|      0|        return;
  340|       |
  341|      2|    pthread_mutex_lock(&tok->lock);
  342|      2|    tok->held--;
  343|      2|    if (tok->held == 0) {
  ------------------
  |  Branch (343:9): [True: 2, False: 0]
  ------------------
  344|      2|        if (tok->waiters)
  ------------------
  |  Branch (344:13): [True: 0, False: 2]
  ------------------
  345|      0|            pthread_cond_signal(&tok->cv);
  346|      2|        memset(&tok->tid, 0, sizeof(tok->tid));
  347|      2|    }
  348|      2|    pthread_mutex_unlock(&tok->lock);
  349|       |#elif defined HAVE_WIN32_THREADS
  350|       |    LeaveCriticalSection(&tok->cs);
  351|       |#endif
  352|      2|}
xmlInitParser:
  569|  6.54k|xmlInitParser(void) {
  570|       |    /*
  571|       |     * Note that the initialization code must not make memory allocations.
  572|       |     */
  573|  6.54k|    if (xmlParserInitialized != 0)
  ------------------
  |  Branch (573:9): [True: 6.54k, False: 2]
  ------------------
  574|  6.54k|        return;
  575|       |
  576|      2|    xmlGlobalInitMutexLock();
  577|       |
  578|      2|    if (xmlParserInnerInitialized == 0) {
  ------------------
  |  Branch (578:9): [True: 2, False: 0]
  ------------------
  579|       |#if defined(_WIN32) && \
  580|       |    !defined(LIBXML_THREAD_ALLOC_ENABLED) && \
  581|       |    (!defined(LIBXML_STATIC) || defined(LIBXML_STATIC_FOR_DLL))
  582|       |        if (xmlFree == free)
  583|       |            atexit(xmlCleanupParser);
  584|       |#endif
  585|       |
  586|      2|        xmlInitMemoryInternal(); /* Should come second */
  587|      2|        xmlInitGlobalsInternal();
  588|      2|        xmlInitRandom();
  589|      2|        xmlInitDictInternal();
  590|      2|        xmlInitEncodingInternal();
  591|      2|#if defined(LIBXML_XPATH_ENABLED) || defined(LIBXML_SCHEMAS_ENABLED)
  592|      2|        xmlInitXPathInternal();
  593|      2|#endif
  594|       |
  595|      2|        xmlRegisterDefaultInputCallbacks();
  596|      2|#ifdef LIBXML_OUTPUT_ENABLED
  597|      2|        xmlRegisterDefaultOutputCallbacks();
  598|      2|#endif /* LIBXML_OUTPUT_ENABLED */
  599|       |
  600|      2|        xmlParserInnerInitialized = 1;
  601|      2|    }
  602|       |
  603|      2|    xmlGlobalInitMutexUnlock();
  604|       |
  605|      2|    xmlParserInitialized = 1;
  606|      2|}
threads.c:xmlGlobalInitMutexLock:
  462|      2|xmlGlobalInitMutexLock(void) {
  463|      2|#ifdef HAVE_POSIX_THREADS
  464|       |
  465|      2|#ifdef XML_PTHREAD_WEAK
  466|       |    /*
  467|       |     * This is somewhat unreliable since libpthread could be loaded
  468|       |     * later with dlopen() and threads could be created. But it's
  469|       |     * long-standing behavior and hard to work around.
  470|       |     */
  471|      2|    if (libxml_is_threaded == -1)
  ------------------
  |  Branch (471:9): [True: 2, False: 0]
  ------------------
  472|      2|        libxml_is_threaded =
  473|      2|            (pthread_mutex_init != NULL) &&
  ------------------
  |  Branch (473:13): [True: 2, False: 0]
  ------------------
  474|      2|            (pthread_mutex_destroy != NULL) &&
  ------------------
  |  Branch (474:13): [True: 2, False: 0]
  ------------------
  475|      2|            (pthread_mutex_lock != NULL) &&
  ------------------
  |  Branch (475:13): [True: 2, False: 0]
  ------------------
  476|      2|            (pthread_mutex_unlock != NULL) &&
  ------------------
  |  Branch (476:13): [True: 2, False: 0]
  ------------------
  477|      2|            (pthread_cond_init != NULL) &&
  ------------------
  |  Branch (477:13): [True: 2, False: 0]
  ------------------
  478|      2|            (pthread_cond_destroy != NULL) &&
  ------------------
  |  Branch (478:13): [True: 2, False: 0]
  ------------------
  479|      2|            (pthread_cond_wait != NULL) &&
  ------------------
  |  Branch (479:13): [True: 2, False: 0]
  ------------------
  480|       |            /*
  481|       |             * pthread_equal can be inline, resuting in -Waddress warnings.
  482|       |             * Let's assume it's available if all the other functions are.
  483|       |             */
  484|       |            /* (pthread_equal != NULL) && */
  485|      2|            (pthread_self != NULL) &&
  ------------------
  |  Branch (485:13): [True: 2, False: 0]
  ------------------
  486|      2|            (pthread_cond_signal != NULL);
  ------------------
  |  Branch (486:13): [True: 2, False: 0]
  ------------------
  487|      2|#endif
  488|       |
  489|       |    /* The mutex is statically initialized, so we just lock it. */
  490|      2|    if (XML_IS_THREADED() != 0)
  ------------------
  |  |   84|      2|#define XML_IS_THREADED() libxml_is_threaded
  ------------------
  |  Branch (490:9): [True: 2, False: 0]
  ------------------
  491|      2|        pthread_mutex_lock(&global_init_lock);
  492|       |
  493|       |#elif defined HAVE_WIN32_THREADS
  494|       |
  495|       |    LPCRITICAL_SECTION cs;
  496|       |
  497|       |    /* Create a new critical section */
  498|       |    if (global_init_lock == NULL) {
  499|       |        cs = malloc(sizeof(CRITICAL_SECTION));
  500|       |        if (cs == NULL) {
  501|       |            xmlGenericError(xmlGenericErrorContext,
  502|       |                            "xmlGlobalInitMutexLock: out of memory\n");
  503|       |            return;
  504|       |        }
  505|       |        InitializeCriticalSection(cs);
  506|       |
  507|       |        /* Swap it into the global_init_lock */
  508|       |#ifdef InterlockedCompareExchangePointer
  509|       |        InterlockedCompareExchangePointer((void **) &global_init_lock,
  510|       |                                          cs, NULL);
  511|       |#else /* Use older void* version */
  512|       |        InterlockedCompareExchange((void **) &global_init_lock,
  513|       |                                   (void *) cs, NULL);
  514|       |#endif /* InterlockedCompareExchangePointer */
  515|       |
  516|       |        /* If another thread successfully recorded its critical
  517|       |         * section in the global_init_lock then discard the one
  518|       |         * allocated by this thread. */
  519|       |        if (global_init_lock != cs) {
  520|       |            DeleteCriticalSection(cs);
  521|       |            free(cs);
  522|       |        }
  523|       |    }
  524|       |
  525|       |    /* Lock the chosen critical section */
  526|       |    EnterCriticalSection(global_init_lock);
  527|       |
  528|       |#endif
  529|      2|}
threads.c:xmlGlobalInitMutexUnlock:
  532|      2|xmlGlobalInitMutexUnlock(void) {
  533|      2|#ifdef HAVE_POSIX_THREADS
  534|      2|    if (XML_IS_THREADED() != 0)
  ------------------
  |  |   84|      2|#define XML_IS_THREADED() libxml_is_threaded
  ------------------
  |  Branch (534:9): [True: 2, False: 0]
  ------------------
  535|      2|        pthread_mutex_unlock(&global_init_lock);
  536|       |#elif defined HAVE_WIN32_THREADS
  537|       |    if (global_init_lock != NULL)
  538|       |	LeaveCriticalSection(global_init_lock);
  539|       |#endif
  540|      2|}

xmlBuildQName:
  218|  3.40k|	      xmlChar *memory, int len) {
  219|  3.40k|    int lenn, lenp;
  220|  3.40k|    xmlChar *ret;
  221|       |
  222|  3.40k|    if (ncname == NULL) return(NULL);
  ------------------
  |  Branch (222:9): [True: 0, False: 3.40k]
  ------------------
  223|  3.40k|    if (prefix == NULL) return((xmlChar *) ncname);
  ------------------
  |  Branch (223:9): [True: 2.61k, False: 788]
  ------------------
  224|       |
  225|    788|    lenn = strlen((char *) ncname);
  226|    788|    lenp = strlen((char *) prefix);
  227|       |
  228|    788|    if ((memory == NULL) || (len < lenn + lenp + 2)) {
  ------------------
  |  Branch (228:9): [True: 0, False: 788]
  |  Branch (228:29): [True: 4, False: 784]
  ------------------
  229|      4|	ret = (xmlChar *) xmlMallocAtomic(lenn + lenp + 2);
  230|      4|	if (ret == NULL) {
  ------------------
  |  Branch (230:6): [True: 0, False: 4]
  ------------------
  231|      0|	    xmlTreeErrMemory("building QName");
  232|      0|	    return(NULL);
  233|      0|	}
  234|    784|    } else {
  235|    784|	ret = memory;
  236|    784|    }
  237|    788|    memcpy(&ret[0], prefix, lenp);
  238|    788|    ret[lenp] = ':';
  239|    788|    memcpy(&ret[lenp + 1], ncname, lenn);
  240|    788|    ret[lenn + lenp + 1] = 0;
  241|    788|    return(ret);
  242|    788|}
xmlSplitQName2:
  262|  39.8k|xmlSplitQName2(const xmlChar *name, xmlChar **prefix) {
  263|  39.8k|    int len = 0;
  264|  39.8k|    xmlChar *ret = NULL;
  265|       |
  266|  39.8k|    if (prefix == NULL) return(NULL);
  ------------------
  |  Branch (266:9): [True: 0, False: 39.8k]
  ------------------
  267|  39.8k|    *prefix = NULL;
  268|  39.8k|    if (name == NULL) return(NULL);
  ------------------
  |  Branch (268:9): [True: 0, False: 39.8k]
  ------------------
  269|       |
  270|       |#ifndef XML_XML_NAMESPACE
  271|       |    /* xml: prefix is not really a namespace */
  272|       |    if ((name[0] == 'x') && (name[1] == 'm') &&
  273|       |        (name[2] == 'l') && (name[3] == ':'))
  274|       |	return(NULL);
  275|       |#endif
  276|       |
  277|       |    /* nasty but valid */
  278|  39.8k|    if (name[0] == ':')
  ------------------
  |  Branch (278:9): [True: 0, False: 39.8k]
  ------------------
  279|      0|	return(NULL);
  280|       |
  281|       |    /*
  282|       |     * we are not trying to validate but just to cut, and yes it will
  283|       |     * work even if this is as set of UTF-8 encoded chars
  284|       |     */
  285|   228k|    while ((name[len] != 0) && (name[len] != ':'))
  ------------------
  |  Branch (285:12): [True: 188k, False: 39.5k]
  |  Branch (285:32): [True: 188k, False: 296]
  ------------------
  286|   188k|	len++;
  287|       |
  288|  39.8k|    if (name[len] == 0)
  ------------------
  |  Branch (288:9): [True: 39.5k, False: 296]
  ------------------
  289|  39.5k|	return(NULL);
  290|       |
  291|    296|    *prefix = xmlStrndup(name, len);
  292|    296|    if (*prefix == NULL) {
  ------------------
  |  Branch (292:9): [True: 0, False: 296]
  ------------------
  293|      0|	xmlTreeErrMemory("QName split");
  294|      0|	return(NULL);
  295|      0|    }
  296|    296|    ret = xmlStrdup(&name[len + 1]);
  297|    296|    if (ret == NULL) {
  ------------------
  |  Branch (297:9): [True: 0, False: 296]
  ------------------
  298|      0|	xmlTreeErrMemory("QName split");
  299|      0|	if (*prefix != NULL) {
  ------------------
  |  Branch (299:6): [True: 0, False: 0]
  ------------------
  300|      0|	    xmlFree(*prefix);
  301|      0|	    *prefix = NULL;
  302|      0|	}
  303|      0|	return(NULL);
  304|      0|    }
  305|       |
  306|    296|    return(ret);
  307|    296|}
xmlSplitQName3:
  322|  13.5k|xmlSplitQName3(const xmlChar *name, int *len) {
  323|  13.5k|    int l = 0;
  324|       |
  325|  13.5k|    if (name == NULL) return(NULL);
  ------------------
  |  Branch (325:9): [True: 0, False: 13.5k]
  ------------------
  326|  13.5k|    if (len == NULL) return(NULL);
  ------------------
  |  Branch (326:9): [True: 0, False: 13.5k]
  ------------------
  327|       |
  328|       |    /* nasty but valid */
  329|  13.5k|    if (name[0] == ':')
  ------------------
  |  Branch (329:9): [True: 0, False: 13.5k]
  ------------------
  330|      0|	return(NULL);
  331|       |
  332|       |    /*
  333|       |     * we are not trying to validate but just to cut, and yes it will
  334|       |     * work even if this is as set of UTF-8 encoded chars
  335|       |     */
  336|  93.9k|    while ((name[l] != 0) && (name[l] != ':'))
  ------------------
  |  Branch (336:12): [True: 80.6k, False: 13.2k]
  |  Branch (336:30): [True: 80.4k, False: 244]
  ------------------
  337|  80.4k|	l++;
  338|       |
  339|  13.5k|    if (name[l] == 0)
  ------------------
  |  Branch (339:9): [True: 13.2k, False: 244]
  ------------------
  340|  13.2k|	return(NULL);
  341|       |
  342|    244|    *len = l;
  343|       |
  344|    244|    return(&name[l+1]);
  345|  13.5k|}
xmlValidateNCName:
  366|     25|xmlValidateNCName(const xmlChar *value, int space) {
  367|     25|    const xmlChar *cur = value;
  368|     25|    int c,l;
  369|       |
  370|     25|    if (value == NULL)
  ------------------
  |  Branch (370:9): [True: 0, False: 25]
  ------------------
  371|      0|        return(-1);
  372|       |
  373|       |    /*
  374|       |     * First quick algorithm for ASCII range
  375|       |     */
  376|     25|    if (space)
  ------------------
  |  Branch (376:9): [True: 25, False: 0]
  ------------------
  377|     25|	while (IS_BLANK_CH(*cur)) cur++;
  378|     25|    if (((*cur >= 'a') && (*cur <= 'z')) || ((*cur >= 'A') && (*cur <= 'Z')) ||
  ------------------
  |  Branch (378:10): [True: 21, False: 4]
  |  Branch (378:27): [True: 21, False: 0]
  |  Branch (378:46): [True: 0, False: 4]
  |  Branch (378:63): [True: 0, False: 0]
  ------------------
  379|     25|	(*cur == '_'))
  ------------------
  |  Branch (379:2): [True: 0, False: 4]
  ------------------
  380|     21|	cur++;
  381|      4|    else
  382|      4|	goto try_complex;
  383|     63|    while (((*cur >= 'a') && (*cur <= 'z')) ||
  ------------------
  |  Branch (383:13): [True: 42, False: 21]
  |  Branch (383:30): [True: 42, False: 0]
  ------------------
  384|     63|	   ((*cur >= 'A') && (*cur <= 'Z')) ||
  ------------------
  |  Branch (384:6): [True: 0, False: 21]
  |  Branch (384:23): [True: 0, False: 0]
  ------------------
  385|     63|	   ((*cur >= '0') && (*cur <= '9')) ||
  ------------------
  |  Branch (385:6): [True: 0, False: 21]
  |  Branch (385:23): [True: 0, False: 0]
  ------------------
  386|     63|	   (*cur == '_') || (*cur == '-') || (*cur == '.'))
  ------------------
  |  Branch (386:5): [True: 0, False: 21]
  |  Branch (386:22): [True: 0, False: 21]
  |  Branch (386:39): [True: 0, False: 21]
  ------------------
  387|     42|	cur++;
  388|     21|    if (space)
  ------------------
  |  Branch (388:9): [True: 21, False: 0]
  ------------------
  389|     21|	while (IS_BLANK_CH(*cur)) cur++;
  390|     21|    if (*cur == 0)
  ------------------
  |  Branch (390:9): [True: 21, False: 0]
  ------------------
  391|     21|	return(0);
  392|       |
  393|      4|try_complex:
  394|       |    /*
  395|       |     * Second check for chars outside the ASCII range
  396|       |     */
  397|      4|    cur = value;
  398|      4|    c = CUR_SCHAR(cur, l);
  ------------------
  |  |  353|      4|#define CUR_SCHAR(s, l) xmlStringCurrentChar(NULL, s, &l)
  ------------------
  399|      4|    if (space) {
  ------------------
  |  Branch (399:9): [True: 4, False: 0]
  ------------------
  400|      4|	while (IS_BLANK(c)) {
  401|      0|	    cur += l;
  402|      0|	    c = CUR_SCHAR(cur, l);
  ------------------
  |  |  353|      0|#define CUR_SCHAR(s, l) xmlStringCurrentChar(NULL, s, &l)
  ------------------
  403|      0|	}
  404|      4|    }
  405|      4|    if ((!IS_LETTER(c)) && (c != '_'))
  ------------------
  |  |  240|      4|#define IS_LETTER(c) (IS_BASECHAR(c) || IS_IDEOGRAPHIC(c))
  |  |  ------------------
  |  |  |  |  161|      4|#define IS_BASECHAR(c) xmlIsBaseCharQ(c)
  |  |  |  |  ------------------
  |  |  |  |  |  |   76|      8|#define xmlIsBaseCharQ(c)	(((c) < 0x100) ? \
  |  |  |  |  |  |  ------------------
  |  |  |  |  |  |  |  Branch (76:27): [True: 0, False: 4]
  |  |  |  |  |  |  |  Branch (76:28): [True: 4, False: 0]
  |  |  |  |  |  |  ------------------
  |  |  |  |  |  |   77|      8|				 xmlIsBaseChar_ch((c)) : \
  |  |  |  |  |  |  ------------------
  |  |  |  |  |  |  |  |   64|      4|#define xmlIsBaseChar_ch(c)	(((0x41 <= (c)) && ((c) <= 0x5a)) || \
  |  |  |  |  |  |  |  |  ------------------
  |  |  |  |  |  |  |  |  |  Branch (64:31): [True: 0, False: 4]
  |  |  |  |  |  |  |  |  |  Branch (64:48): [True: 0, False: 0]
  |  |  |  |  |  |  |  |  ------------------
  |  |  |  |  |  |  |  |   65|      4|				 ((0x61 <= (c)) && ((c) <= 0x7a)) || \
  |  |  |  |  |  |  |  |  ------------------
  |  |  |  |  |  |  |  |  |  Branch (65:7): [True: 0, False: 4]
  |  |  |  |  |  |  |  |  |  Branch (65:24): [True: 0, False: 0]
  |  |  |  |  |  |  |  |  ------------------
  |  |  |  |  |  |  |  |   66|      4|				 ((0xc0 <= (c)) && ((c) <= 0xd6)) || \
  |  |  |  |  |  |  |  |  ------------------
  |  |  |  |  |  |  |  |  |  Branch (66:7): [True: 0, False: 4]
  |  |  |  |  |  |  |  |  |  Branch (66:24): [True: 0, False: 0]
  |  |  |  |  |  |  |  |  ------------------
  |  |  |  |  |  |  |  |   67|      4|				 ((0xd8 <= (c)) && ((c) <= 0xf6)) || \
  |  |  |  |  |  |  |  |  ------------------
  |  |  |  |  |  |  |  |  |  Branch (67:7): [True: 0, False: 4]
  |  |  |  |  |  |  |  |  |  Branch (67:24): [True: 0, False: 0]
  |  |  |  |  |  |  |  |  ------------------
  |  |  |  |  |  |  |  |   68|      4|				  (0xf8 <= (c)))
  |  |  |  |  |  |  |  |  ------------------
  |  |  |  |  |  |  |  |  |  Branch (68:7): [True: 0, False: 4]
  |  |  |  |  |  |  |  |  ------------------
  |  |  |  |  |  |  ------------------
  |  |  |  |  |  |   78|      8|				 xmlCharInRange((c), &xmlIsBaseCharGroup))
  |  |  |  |  ------------------
  |  |  ------------------
  |  |               #define IS_LETTER(c) (IS_BASECHAR(c) || IS_IDEOGRAPHIC(c))
  |  |  ------------------
  |  |  |  |  229|      4|#define IS_IDEOGRAPHIC(c) xmlIsIdeographicQ(c)
  |  |  |  |  ------------------
  |  |  |  |  |  |  184|      4|#define xmlIsIdeographicQ(c)	(((c) < 0x100) ? \
  |  |  |  |  |  |  ------------------
  |  |  |  |  |  |  |  Branch (184:30): [True: 0, False: 4]
  |  |  |  |  |  |  |  Branch (184:31): [True: 4, False: 0]
  |  |  |  |  |  |  ------------------
  |  |  |  |  |  |  185|      4|				 0 :\
  |  |  |  |  |  |  186|      4|				(((0x4e00 <= (c)) && ((c) <= 0x9fa5)) || \
  |  |  |  |  |  |  ------------------
  |  |  |  |  |  |  |  Branch (186:7): [True: 0, False: 0]
  |  |  |  |  |  |  |  Branch (186:26): [True: 0, False: 0]
  |  |  |  |  |  |  ------------------
  |  |  |  |  |  |  187|      0|				 ((c) == 0x3007) || \
  |  |  |  |  |  |  ------------------
  |  |  |  |  |  |  |  Branch (187:6): [True: 0, False: 0]
  |  |  |  |  |  |  ------------------
  |  |  |  |  |  |  188|      0|				 ((0x3021 <= (c)) && ((c) <= 0x3029))))
  |  |  |  |  |  |  ------------------
  |  |  |  |  |  |  |  Branch (188:7): [True: 0, False: 0]
  |  |  |  |  |  |  |  Branch (188:26): [True: 0, False: 0]
  |  |  |  |  |  |  ------------------
  |  |  |  |  ------------------
  |  |  ------------------
  ------------------
  |  Branch (405:28): [True: 4, False: 0]
  ------------------
  406|      4|	return(1);
  407|      0|    cur += l;
  408|      0|    c = CUR_SCHAR(cur, l);
  ------------------
  |  |  353|      0|#define CUR_SCHAR(s, l) xmlStringCurrentChar(NULL, s, &l)
  ------------------
  409|      0|    while (IS_LETTER(c) || IS_DIGIT(c) || (c == '.') ||
  ------------------
  |  |  240|      0|#define IS_LETTER(c) (IS_BASECHAR(c) || IS_IDEOGRAPHIC(c))
  |  |  ------------------
  |  |  |  |  161|      0|#define IS_BASECHAR(c) xmlIsBaseCharQ(c)
  |  |  |  |  ------------------
  |  |  |  |  |  |   76|      0|#define xmlIsBaseCharQ(c)	(((c) < 0x100) ? \
  |  |  |  |  |  |  ------------------
  |  |  |  |  |  |  |  Branch (76:27): [True: 0, False: 0]
  |  |  |  |  |  |  |  Branch (76:28): [True: 0, False: 0]
  |  |  |  |  |  |  ------------------
  |  |  |  |  |  |   77|      0|				 xmlIsBaseChar_ch((c)) : \
  |  |  |  |  |  |  ------------------
  |  |  |  |  |  |  |  |   64|      0|#define xmlIsBaseChar_ch(c)	(((0x41 <= (c)) && ((c) <= 0x5a)) || \
  |  |  |  |  |  |  |  |  ------------------
  |  |  |  |  |  |  |  |  |  Branch (64:31): [True: 0, False: 0]
  |  |  |  |  |  |  |  |  |  Branch (64:48): [True: 0, False: 0]
  |  |  |  |  |  |  |  |  ------------------
  |  |  |  |  |  |  |  |   65|      0|				 ((0x61 <= (c)) && ((c) <= 0x7a)) || \
  |  |  |  |  |  |  |  |  ------------------
  |  |  |  |  |  |  |  |  |  Branch (65:7): [True: 0, False: 0]
  |  |  |  |  |  |  |  |  |  Branch (65:24): [True: 0, False: 0]
  |  |  |  |  |  |  |  |  ------------------
  |  |  |  |  |  |  |  |   66|      0|				 ((0xc0 <= (c)) && ((c) <= 0xd6)) || \
  |  |  |  |  |  |  |  |  ------------------
  |  |  |  |  |  |  |  |  |  Branch (66:7): [True: 0, False: 0]
  |  |  |  |  |  |  |  |  |  Branch (66:24): [True: 0, False: 0]
  |  |  |  |  |  |  |  |  ------------------
  |  |  |  |  |  |  |  |   67|      0|				 ((0xd8 <= (c)) && ((c) <= 0xf6)) || \
  |  |  |  |  |  |  |  |  ------------------
  |  |  |  |  |  |  |  |  |  Branch (67:7): [True: 0, False: 0]
  |  |  |  |  |  |  |  |  |  Branch (67:24): [True: 0, False: 0]
  |  |  |  |  |  |  |  |  ------------------
  |  |  |  |  |  |  |  |   68|      0|				  (0xf8 <= (c)))
  |  |  |  |  |  |  |  |  ------------------
  |  |  |  |  |  |  |  |  |  Branch (68:7): [True: 0, False: 0]
  |  |  |  |  |  |  |  |  ------------------
  |  |  |  |  |  |  ------------------
  |  |  |  |  |  |   78|      0|				 xmlCharInRange((c), &xmlIsBaseCharGroup))
  |  |  |  |  ------------------
  |  |  ------------------
  |  |               #define IS_LETTER(c) (IS_BASECHAR(c) || IS_IDEOGRAPHIC(c))
  |  |  ------------------
  |  |  |  |  229|      0|#define IS_IDEOGRAPHIC(c) xmlIsIdeographicQ(c)
  |  |  |  |  ------------------
  |  |  |  |  |  |  184|      0|#define xmlIsIdeographicQ(c)	(((c) < 0x100) ? \
  |  |  |  |  |  |  ------------------
  |  |  |  |  |  |  |  Branch (184:30): [True: 0, False: 0]
  |  |  |  |  |  |  |  Branch (184:31): [True: 0, False: 0]
  |  |  |  |  |  |  ------------------
  |  |  |  |  |  |  185|      0|				 0 :\
  |  |  |  |  |  |  186|      0|				(((0x4e00 <= (c)) && ((c) <= 0x9fa5)) || \
  |  |  |  |  |  |  ------------------
  |  |  |  |  |  |  |  Branch (186:7): [True: 0, False: 0]
  |  |  |  |  |  |  |  Branch (186:26): [True: 0, False: 0]
  |  |  |  |  |  |  ------------------
  |  |  |  |  |  |  187|      0|				 ((c) == 0x3007) || \
  |  |  |  |  |  |  ------------------
  |  |  |  |  |  |  |  Branch (187:6): [True: 0, False: 0]
  |  |  |  |  |  |  ------------------
  |  |  |  |  |  |  188|      0|				 ((0x3021 <= (c)) && ((c) <= 0x3029))))
  |  |  |  |  |  |  ------------------
  |  |  |  |  |  |  |  Branch (188:7): [True: 0, False: 0]
  |  |  |  |  |  |  |  Branch (188:26): [True: 0, False: 0]
  |  |  |  |  |  |  ------------------
  |  |  |  |  ------------------
  |  |  ------------------
  ------------------
                  while (IS_LETTER(c) || IS_DIGIT(c) || (c == '.') ||
  ------------------
  |  |  171|      0|#define IS_DIGIT(c) xmlIsDigitQ(c)
  |  |  ------------------
  |  |  |  |  152|      0|#define xmlIsDigitQ(c)		(((c) < 0x100) ? \
  |  |  |  |  ------------------
  |  |  |  |  |  Branch (152:25): [True: 0, False: 0]
  |  |  |  |  |  Branch (152:26): [True: 0, False: 0]
  |  |  |  |  ------------------
  |  |  |  |  153|      0|				 xmlIsDigit_ch((c)) : \
  |  |  |  |  ------------------
  |  |  |  |  |  |  144|      0|#define xmlIsDigit_ch(c)	(((0x30 <= (c)) && ((c) <= 0x39)))
  |  |  |  |  |  |  ------------------
  |  |  |  |  |  |  |  Branch (144:28): [True: 0, False: 0]
  |  |  |  |  |  |  |  Branch (144:45): [True: 0, False: 0]
  |  |  |  |  |  |  ------------------
  |  |  |  |  ------------------
  |  |  |  |  154|      0|				 xmlCharInRange((c), &xmlIsDigitGroup))
  |  |  ------------------
  ------------------
  |  Branch (409:43): [True: 0, False: 0]
  ------------------
  410|      0|	   (c == '-') || (c == '_') || IS_COMBINING(c) ||
  ------------------
  |  |  189|      0|#define IS_COMBINING(c) xmlIsCombiningQ(c)
  |  |  ------------------
  |  |  |  |  132|      0|#define xmlIsCombiningQ(c)	(((c) < 0x100) ? \
  |  |  |  |  ------------------
  |  |  |  |  |  Branch (132:28): [True: 0, False: 0]
  |  |  |  |  |  Branch (132:29): [True: 0, False: 0]
  |  |  |  |  ------------------
  |  |  |  |  133|      0|				 0 : \
  |  |  |  |  134|      0|				 xmlCharInRange((c), &xmlIsCombiningGroup))
  |  |  ------------------
  ------------------
  |  Branch (410:5): [True: 0, False: 0]
  |  Branch (410:19): [True: 0, False: 0]
  ------------------
  411|      0|	   IS_EXTENDER(c)) {
  ------------------
  |  |  210|      0|#define IS_EXTENDER(c) xmlIsExtenderQ(c)
  |  |  ------------------
  |  |  |  |  172|      0|#define xmlIsExtenderQ(c)	(((c) < 0x100) ? \
  |  |  |  |  ------------------
  |  |  |  |  |  Branch (172:27): [True: 0, False: 0]
  |  |  |  |  |  Branch (172:28): [True: 0, False: 0]
  |  |  |  |  ------------------
  |  |  |  |  173|      0|				 xmlIsExtender_ch((c)) : \
  |  |  |  |  ------------------
  |  |  |  |  |  |  164|      0|#define xmlIsExtender_ch(c)	(((c) == 0xb7))
  |  |  |  |  ------------------
  |  |  |  |  174|      0|				 xmlCharInRange((c), &xmlIsExtenderGroup))
  |  |  ------------------
  ------------------
  412|      0|	cur += l;
  413|      0|	c = CUR_SCHAR(cur, l);
  ------------------
  |  |  353|      0|#define CUR_SCHAR(s, l) xmlStringCurrentChar(NULL, s, &l)
  ------------------
  414|      0|    }
  415|      0|    if (space) {
  ------------------
  |  Branch (415:9): [True: 0, False: 0]
  ------------------
  416|      0|	while (IS_BLANK(c)) {
  417|      0|	    cur += l;
  418|      0|	    c = CUR_SCHAR(cur, l);
  ------------------
  |  |  353|      0|#define CUR_SCHAR(s, l) xmlStringCurrentChar(NULL, s, &l)
  ------------------
  419|      0|	}
  420|      0|    }
  421|      0|    if (c != 0)
  ------------------
  |  Branch (421:9): [True: 0, False: 0]
  ------------------
  422|      0|	return(1);
  423|       |
  424|      0|    return(0);
  425|      0|}
xmlNewNs:
  726|    436|xmlNewNs(xmlNodePtr node, const xmlChar *href, const xmlChar *prefix) {
  727|    436|    xmlNsPtr cur;
  728|       |
  729|    436|    if ((node != NULL) && (node->type != XML_ELEMENT_NODE))
  ------------------
  |  Branch (729:9): [True: 8, False: 428]
  |  Branch (729:27): [True: 0, False: 8]
  ------------------
  730|      0|	return(NULL);
  731|       |
  732|    436|    if ((prefix != NULL) && (xmlStrEqual(prefix, BAD_CAST "xml"))) {
  ------------------
  |  |   35|    308|#define BAD_CAST (xmlChar *)
  ------------------
  |  Branch (732:9): [True: 308, False: 128]
  |  Branch (732:29): [True: 0, False: 308]
  ------------------
  733|       |        /* xml namespace is predefined, no need to add it */
  734|      0|        if (xmlStrEqual(href, XML_XML_NAMESPACE))
  ------------------
  |  |  143|      0|    (const xmlChar *) "http://www.w3.org/XML/1998/namespace"
  ------------------
  |  Branch (734:13): [True: 0, False: 0]
  ------------------
  735|      0|            return(NULL);
  736|       |
  737|       |        /*
  738|       |         * Problem, this is an attempt to bind xml prefix to a wrong
  739|       |         * namespace, which breaks
  740|       |         * Namespace constraint: Reserved Prefixes and Namespace Names
  741|       |         * from XML namespace. But documents authors may not care in
  742|       |         * their context so let's proceed.
  743|       |         */
  744|      0|    }
  745|       |
  746|       |    /*
  747|       |     * Allocate a new Namespace and fill the fields.
  748|       |     */
  749|    436|    cur = (xmlNsPtr) xmlMalloc(sizeof(xmlNs));
  750|    436|    if (cur == NULL) {
  ------------------
  |  Branch (750:9): [True: 0, False: 436]
  ------------------
  751|      0|	xmlTreeErrMemory("building namespace");
  752|      0|	return(NULL);
  753|      0|    }
  754|    436|    memset(cur, 0, sizeof(xmlNs));
  755|    436|    cur->type = XML_LOCAL_NAMESPACE;
  ------------------
  |  |  370|    436|#define XML_LOCAL_NAMESPACE XML_NAMESPACE_DECL
  ------------------
  756|       |
  757|    436|    if (href != NULL)
  ------------------
  |  Branch (757:9): [True: 412, False: 24]
  ------------------
  758|    412|	cur->href = xmlStrdup(href);
  759|    436|    if (prefix != NULL)
  ------------------
  |  Branch (759:9): [True: 308, False: 128]
  ------------------
  760|    308|	cur->prefix = xmlStrdup(prefix);
  761|       |
  762|       |    /*
  763|       |     * Add it at the end to preserve parsing order ...
  764|       |     * and checks for existing use of the prefix
  765|       |     */
  766|    436|    if (node != NULL) {
  ------------------
  |  Branch (766:9): [True: 8, False: 428]
  ------------------
  767|      8|	if (node->nsDef == NULL) {
  ------------------
  |  Branch (767:6): [True: 8, False: 0]
  ------------------
  768|      8|	    node->nsDef = cur;
  769|      8|	} else {
  770|      0|	    xmlNsPtr prev = node->nsDef;
  771|       |
  772|      0|	    if (((prev->prefix == NULL) && (cur->prefix == NULL)) ||
  ------------------
  |  Branch (772:11): [True: 0, False: 0]
  |  Branch (772:37): [True: 0, False: 0]
  ------------------
  773|      0|		(xmlStrEqual(prev->prefix, cur->prefix))) {
  ------------------
  |  Branch (773:3): [True: 0, False: 0]
  ------------------
  774|      0|		xmlFreeNs(cur);
  775|      0|		return(NULL);
  776|      0|	    }
  777|      0|	    while (prev->next != NULL) {
  ------------------
  |  Branch (777:13): [True: 0, False: 0]
  ------------------
  778|      0|	        prev = prev->next;
  779|      0|		if (((prev->prefix == NULL) && (cur->prefix == NULL)) ||
  ------------------
  |  Branch (779:8): [True: 0, False: 0]
  |  Branch (779:34): [True: 0, False: 0]
  ------------------
  780|      0|		    (xmlStrEqual(prev->prefix, cur->prefix))) {
  ------------------
  |  Branch (780:7): [True: 0, False: 0]
  ------------------
  781|      0|		    xmlFreeNs(cur);
  782|      0|		    return(NULL);
  783|      0|		}
  784|      0|	    }
  785|      0|	    prev->next = cur;
  786|      0|	}
  787|      8|    }
  788|    436|    return(cur);
  789|    436|}
xmlFreeNs:
  815|    484|xmlFreeNs(xmlNsPtr cur) {
  816|    484|    if (cur == NULL) {
  ------------------
  |  Branch (816:9): [True: 0, False: 484]
  ------------------
  817|      0|	return;
  818|      0|    }
  819|    484|    if (cur->href != NULL) xmlFree((char *) cur->href);
  ------------------
  |  Branch (819:9): [True: 460, False: 24]
  ------------------
  820|    484|    if (cur->prefix != NULL) xmlFree((char *) cur->prefix);
  ------------------
  |  Branch (820:9): [True: 356, False: 128]
  ------------------
  821|    484|    xmlFree(cur);
  822|    484|}
xmlFreeNsList:
  831|    380|xmlFreeNsList(xmlNsPtr cur) {
  832|    380|    xmlNsPtr next;
  833|    380|    if (cur == NULL) {
  ------------------
  |  Branch (833:9): [True: 0, False: 380]
  ------------------
  834|      0|	return;
  835|      0|    }
  836|    864|    while (cur != NULL) {
  ------------------
  |  Branch (836:12): [True: 484, False: 380]
  ------------------
  837|    484|        next = cur->next;
  838|    484|        xmlFreeNs(cur);
  839|    484|	cur = next;
  840|    484|    }
  841|    380|}
xmlNewDtd:
  857|     84|                    const xmlChar *ExternalID, const xmlChar *SystemID) {
  858|     84|    xmlDtdPtr cur;
  859|       |
  860|     84|    if ((doc != NULL) && (doc->extSubset != NULL)) {
  ------------------
  |  Branch (860:9): [True: 84, False: 0]
  |  Branch (860:26): [True: 0, False: 84]
  ------------------
  861|      0|	return(NULL);
  862|      0|    }
  863|       |
  864|       |    /*
  865|       |     * Allocate a new DTD and fill the fields.
  866|       |     */
  867|     84|    cur = (xmlDtdPtr) xmlMalloc(sizeof(xmlDtd));
  868|     84|    if (cur == NULL) {
  ------------------
  |  Branch (868:9): [True: 0, False: 84]
  ------------------
  869|      0|	xmlTreeErrMemory("building DTD");
  870|      0|	return(NULL);
  871|      0|    }
  872|     84|    memset(cur, 0 , sizeof(xmlDtd));
  873|     84|    cur->type = XML_DTD_NODE;
  874|       |
  875|     84|    if (name != NULL)
  ------------------
  |  Branch (875:9): [True: 84, False: 0]
  ------------------
  876|     84|	cur->name = xmlStrdup(name);
  877|     84|    if (ExternalID != NULL)
  ------------------
  |  Branch (877:9): [True: 8, False: 76]
  ------------------
  878|      8|	cur->ExternalID = xmlStrdup(ExternalID);
  879|     84|    if (SystemID != NULL)
  ------------------
  |  Branch (879:9): [True: 84, False: 0]
  ------------------
  880|     84|	cur->SystemID = xmlStrdup(SystemID);
  881|     84|    if (doc != NULL)
  ------------------
  |  Branch (881:9): [True: 84, False: 0]
  ------------------
  882|     84|	doc->extSubset = cur;
  883|     84|    cur->doc = doc;
  884|       |
  885|     84|    if ((__xmlRegisterCallbacks) && (xmlRegisterNodeDefaultValue))
  ------------------
  |  |  682|      0|    XML_GLOBAL_MACRO(xmlRegisterNodeDefaultValue)
  |  |  ------------------
  |  |  |  |  500|      0|  #define XML_GLOBAL_MACRO(name) (*__##name())
  |  |  ------------------
  ------------------
  |  Branch (885:9): [True: 0, False: 84]
  |  Branch (885:37): [True: 0, False: 0]
  ------------------
  886|      0|	xmlRegisterNodeDefaultValue((xmlNodePtr)cur);
  ------------------
  |  |  682|      0|    XML_GLOBAL_MACRO(xmlRegisterNodeDefaultValue)
  |  |  ------------------
  |  |  |  |  500|      0|  #define XML_GLOBAL_MACRO(name) (*__##name())
  |  |  ------------------
  ------------------
  887|     84|    return(cur);
  888|     84|}
xmlGetIntSubset:
  899|  1.52k|xmlGetIntSubset(const xmlDoc *doc) {
  900|  1.52k|    xmlNodePtr cur;
  901|       |
  902|  1.52k|    if (doc == NULL)
  ------------------
  |  Branch (902:9): [True: 0, False: 1.52k]
  ------------------
  903|      0|	return(NULL);
  904|  1.52k|    cur = doc->children;
  905|  1.56k|    while (cur != NULL) {
  ------------------
  |  Branch (905:12): [True: 48, False: 1.52k]
  ------------------
  906|     48|	if (cur->type == XML_DTD_NODE)
  ------------------
  |  Branch (906:6): [True: 0, False: 48]
  ------------------
  907|      0|	    return((xmlDtdPtr) cur);
  908|     48|	cur = cur->next;
  909|     48|    }
  910|  1.52k|    return((xmlDtdPtr) doc->intSubset);
  911|  1.52k|}
xmlCreateIntSubset:
  925|    760|                   const xmlChar *ExternalID, const xmlChar *SystemID) {
  926|    760|    xmlDtdPtr cur;
  927|       |
  928|    760|    if ((doc != NULL) && (xmlGetIntSubset(doc) != NULL)) {
  ------------------
  |  Branch (928:9): [True: 760, False: 0]
  |  Branch (928:26): [True: 0, False: 760]
  ------------------
  929|      0|	return(NULL);
  930|      0|    }
  931|       |
  932|       |    /*
  933|       |     * Allocate a new DTD and fill the fields.
  934|       |     */
  935|    760|    cur = (xmlDtdPtr) xmlMalloc(sizeof(xmlDtd));
  936|    760|    if (cur == NULL) {
  ------------------
  |  Branch (936:9): [True: 0, False: 760]
  ------------------
  937|      0|	xmlTreeErrMemory("building internal subset");
  938|      0|	return(NULL);
  939|      0|    }
  940|    760|    memset(cur, 0, sizeof(xmlDtd));
  941|    760|    cur->type = XML_DTD_NODE;
  942|       |
  943|    760|    if (name != NULL) {
  ------------------
  |  Branch (943:9): [True: 760, False: 0]
  ------------------
  944|    760|	cur->name = xmlStrdup(name);
  945|    760|	if (cur->name == NULL) {
  ------------------
  |  Branch (945:6): [True: 0, False: 760]
  ------------------
  946|      0|	    xmlTreeErrMemory("building internal subset");
  947|      0|	    xmlFree(cur);
  948|      0|	    return(NULL);
  949|      0|	}
  950|    760|    }
  951|    760|    if (ExternalID != NULL) {
  ------------------
  |  Branch (951:9): [True: 160, False: 600]
  ------------------
  952|    160|	cur->ExternalID = xmlStrdup(ExternalID);
  953|    160|	if (cur->ExternalID  == NULL) {
  ------------------
  |  Branch (953:6): [True: 0, False: 160]
  ------------------
  954|      0|	    xmlTreeErrMemory("building internal subset");
  955|      0|	    if (cur->name != NULL)
  ------------------
  |  Branch (955:10): [True: 0, False: 0]
  ------------------
  956|      0|	        xmlFree((char *)cur->name);
  957|      0|	    xmlFree(cur);
  958|      0|	    return(NULL);
  959|      0|	}
  960|    160|    }
  961|    760|    if (SystemID != NULL) {
  ------------------
  |  Branch (961:9): [True: 268, False: 492]
  ------------------
  962|    268|	cur->SystemID = xmlStrdup(SystemID);
  963|    268|	if (cur->SystemID == NULL) {
  ------------------
  |  Branch (963:6): [True: 0, False: 268]
  ------------------
  964|      0|	    xmlTreeErrMemory("building internal subset");
  965|      0|	    if (cur->name != NULL)
  ------------------
  |  Branch (965:10): [True: 0, False: 0]
  ------------------
  966|      0|	        xmlFree((char *)cur->name);
  967|      0|	    if (cur->ExternalID != NULL)
  ------------------
  |  Branch (967:10): [True: 0, False: 0]
  ------------------
  968|      0|	        xmlFree((char *)cur->ExternalID);
  969|      0|	    xmlFree(cur);
  970|      0|	    return(NULL);
  971|      0|	}
  972|    268|    }
  973|    760|    if (doc != NULL) {
  ------------------
  |  Branch (973:9): [True: 760, False: 0]
  ------------------
  974|    760|	doc->intSubset = cur;
  975|    760|	cur->parent = doc;
  976|    760|	cur->doc = doc;
  977|    760|	if (doc->children == NULL) {
  ------------------
  |  Branch (977:6): [True: 736, False: 24]
  ------------------
  978|    736|	    doc->children = (xmlNodePtr) cur;
  979|    736|	    doc->last = (xmlNodePtr) cur;
  980|    736|	} else {
  981|     24|	    if (doc->type == XML_HTML_DOCUMENT_NODE) {
  ------------------
  |  Branch (981:10): [True: 0, False: 24]
  ------------------
  982|      0|		xmlNodePtr prev;
  983|       |
  984|      0|		prev = doc->children;
  985|      0|		prev->prev = (xmlNodePtr) cur;
  986|      0|		cur->next = prev;
  987|      0|		doc->children = (xmlNodePtr) cur;
  988|     24|	    } else {
  989|     24|		xmlNodePtr next;
  990|       |
  991|     24|		next = doc->children;
  992|     48|		while ((next != NULL) && (next->type != XML_ELEMENT_NODE))
  ------------------
  |  Branch (992:10): [True: 24, False: 24]
  |  Branch (992:28): [True: 24, False: 0]
  ------------------
  993|     24|		    next = next->next;
  994|     24|		if (next == NULL) {
  ------------------
  |  Branch (994:7): [True: 24, False: 0]
  ------------------
  995|     24|		    cur->prev = doc->last;
  996|     24|		    cur->prev->next = (xmlNodePtr) cur;
  997|     24|		    cur->next = NULL;
  998|     24|		    doc->last = (xmlNodePtr) cur;
  999|     24|		} else {
 1000|      0|		    cur->next = next;
 1001|      0|		    cur->prev = next->prev;
 1002|      0|		    if (cur->prev == NULL)
  ------------------
  |  Branch (1002:11): [True: 0, False: 0]
  ------------------
 1003|      0|			doc->children = (xmlNodePtr) cur;
 1004|      0|		    else
 1005|      0|			cur->prev->next = (xmlNodePtr) cur;
 1006|      0|		    next->prev = (xmlNodePtr) cur;
 1007|      0|		}
 1008|     24|	    }
 1009|     24|	}
 1010|    760|    }
 1011|       |
 1012|    760|    if ((__xmlRegisterCallbacks) && (xmlRegisterNodeDefaultValue))
  ------------------
  |  |  682|      0|    XML_GLOBAL_MACRO(xmlRegisterNodeDefaultValue)
  |  |  ------------------
  |  |  |  |  500|      0|  #define XML_GLOBAL_MACRO(name) (*__##name())
  |  |  ------------------
  ------------------
  |  Branch (1012:9): [True: 0, False: 760]
  |  Branch (1012:37): [True: 0, False: 0]
  ------------------
 1013|      0|	xmlRegisterNodeDefaultValue((xmlNodePtr)cur);
  ------------------
  |  |  682|      0|    XML_GLOBAL_MACRO(xmlRegisterNodeDefaultValue)
  |  |  ------------------
  |  |  |  |  500|      0|  #define XML_GLOBAL_MACRO(name) (*__##name())
  |  |  ------------------
  ------------------
 1014|    760|    return(cur);
 1015|    760|}
xmlFreeDtd:
 1072|    844|xmlFreeDtd(xmlDtdPtr cur) {
 1073|    844|    xmlDictPtr dict = NULL;
 1074|       |
 1075|    844|    if (cur == NULL) {
  ------------------
  |  Branch (1075:9): [True: 0, False: 844]
  ------------------
 1076|      0|	return;
 1077|      0|    }
 1078|    844|    if (cur->doc != NULL) dict = cur->doc->dict;
  ------------------
  |  Branch (1078:9): [True: 844, False: 0]
  ------------------
 1079|       |
 1080|    844|    if ((__xmlRegisterCallbacks) && (xmlDeregisterNodeDefaultValue))
  ------------------
  |  |  684|      0|    XML_GLOBAL_MACRO(xmlDeregisterNodeDefaultValue)
  |  |  ------------------
  |  |  |  |  500|      0|  #define XML_GLOBAL_MACRO(name) (*__##name())
  |  |  ------------------
  ------------------
  |  Branch (1080:9): [True: 0, False: 844]
  |  Branch (1080:37): [True: 0, False: 0]
  ------------------
 1081|      0|	xmlDeregisterNodeDefaultValue((xmlNodePtr)cur);
  ------------------
  |  |  684|      0|    XML_GLOBAL_MACRO(xmlDeregisterNodeDefaultValue)
  |  |  ------------------
  |  |  |  |  500|      0|  #define XML_GLOBAL_MACRO(name) (*__##name())
  |  |  ------------------
  ------------------
 1082|       |
 1083|    844|    if (cur->children != NULL) {
  ------------------
  |  Branch (1083:9): [True: 620, False: 224]
  ------------------
 1084|    620|	xmlNodePtr next, c = cur->children;
 1085|       |
 1086|       |	/*
 1087|       |	 * Cleanup all nodes which are not part of the specific lists
 1088|       |	 * of notations, elements, attributes and entities.
 1089|       |	 */
 1090|   656k|        while (c != NULL) {
  ------------------
  |  Branch (1090:16): [True: 655k, False: 620]
  ------------------
 1091|   655k|	    next = c->next;
 1092|   655k|	    if ((c->type != XML_NOTATION_NODE) &&
  ------------------
  |  Branch (1092:10): [True: 655k, False: 0]
  ------------------
 1093|   655k|	        (c->type != XML_ELEMENT_DECL) &&
  ------------------
  |  Branch (1093:10): [True: 652k, False: 3.10k]
  ------------------
 1094|   655k|		(c->type != XML_ATTRIBUTE_DECL) &&
  ------------------
  |  Branch (1094:3): [True: 645k, False: 7.77k]
  ------------------
 1095|   655k|		(c->type != XML_ENTITY_DECL)) {
  ------------------
  |  Branch (1095:3): [True: 642k, False: 2.33k]
  ------------------
 1096|   642k|		xmlUnlinkNode(c);
 1097|   642k|		xmlFreeNode(c);
 1098|   642k|	    }
 1099|   655k|	    c = next;
 1100|   655k|	}
 1101|    620|    }
 1102|    844|    DICT_FREE(cur->name)
  ------------------
  |  | 1025|    844|	if ((str) && ((!dict) ||				\
  |  |  ------------------
  |  |  |  Branch (1025:6): [True: 844, False: 0]
  |  |  |  Branch (1025:16): [True: 0, False: 844]
  |  |  ------------------
  |  | 1026|    844|	    (xmlDictOwns(dict, (const xmlChar *)(str)) == 0)))	\
  |  |  ------------------
  |  |  |  Branch (1026:6): [True: 844, False: 0]
  |  |  ------------------
  |  | 1027|    844|	    xmlFree((char *)(str));
  ------------------
 1103|    844|    DICT_FREE(cur->SystemID)
  ------------------
  |  | 1025|    844|	if ((str) && ((!dict) ||				\
  |  |  ------------------
  |  |  |  Branch (1025:6): [True: 352, False: 492]
  |  |  |  Branch (1025:16): [True: 0, False: 352]
  |  |  ------------------
  |  | 1026|    352|	    (xmlDictOwns(dict, (const xmlChar *)(str)) == 0)))	\
  |  |  ------------------
  |  |  |  Branch (1026:6): [True: 352, False: 0]
  |  |  ------------------
  |  | 1027|    844|	    xmlFree((char *)(str));
  ------------------
 1104|    844|    DICT_FREE(cur->ExternalID)
  ------------------
  |  | 1025|    844|	if ((str) && ((!dict) ||				\
  |  |  ------------------
  |  |  |  Branch (1025:6): [True: 168, False: 676]
  |  |  |  Branch (1025:16): [True: 0, False: 168]
  |  |  ------------------
  |  | 1026|    168|	    (xmlDictOwns(dict, (const xmlChar *)(str)) == 0)))	\
  |  |  ------------------
  |  |  |  Branch (1026:6): [True: 168, False: 0]
  |  |  ------------------
  |  | 1027|    844|	    xmlFree((char *)(str));
  ------------------
 1105|       |    /* TODO !!! */
 1106|    844|    if (cur->notations != NULL)
  ------------------
  |  Branch (1106:9): [True: 0, False: 844]
  ------------------
 1107|      0|        xmlFreeNotationTable((xmlNotationTablePtr) cur->notations);
 1108|       |
 1109|    844|    if (cur->elements != NULL)
  ------------------
  |  Branch (1109:9): [True: 472, False: 372]
  ------------------
 1110|    472|        xmlFreeElementTable((xmlElementTablePtr) cur->elements);
 1111|    844|    if (cur->attributes != NULL)
  ------------------
  |  Branch (1111:9): [True: 168, False: 676]
  ------------------
 1112|    168|        xmlFreeAttributeTable((xmlAttributeTablePtr) cur->attributes);
 1113|    844|    if (cur->entities != NULL)
  ------------------
  |  Branch (1113:9): [True: 216, False: 628]
  ------------------
 1114|    216|        xmlFreeEntitiesTable((xmlEntitiesTablePtr) cur->entities);
 1115|    844|    if (cur->pentities != NULL)
  ------------------
  |  Branch (1115:9): [True: 128, False: 716]
  ------------------
 1116|    128|        xmlFreeEntitiesTable((xmlEntitiesTablePtr) cur->pentities);
 1117|       |
 1118|    844|    xmlFree(cur);
 1119|    844|}
xmlNewDoc:
 1130|  1.32k|xmlNewDoc(const xmlChar *version) {
 1131|  1.32k|    xmlDocPtr cur;
 1132|       |
 1133|  1.32k|    if (version == NULL)
  ------------------
  |  Branch (1133:9): [True: 0, False: 1.32k]
  ------------------
 1134|      0|	version = (const xmlChar *) "1.0";
 1135|       |
 1136|       |    /*
 1137|       |     * Allocate a new document and fill the fields.
 1138|       |     */
 1139|  1.32k|    cur = (xmlDocPtr) xmlMalloc(sizeof(xmlDoc));
 1140|  1.32k|    if (cur == NULL) {
  ------------------
  |  Branch (1140:9): [True: 0, False: 1.32k]
  ------------------
 1141|      0|	xmlTreeErrMemory("building doc");
 1142|      0|	return(NULL);
 1143|      0|    }
 1144|  1.32k|    memset(cur, 0, sizeof(xmlDoc));
 1145|  1.32k|    cur->type = XML_DOCUMENT_NODE;
 1146|       |
 1147|  1.32k|    cur->version = xmlStrdup(version);
 1148|  1.32k|    if (cur->version == NULL) {
  ------------------
  |  Branch (1148:9): [True: 0, False: 1.32k]
  ------------------
 1149|      0|	xmlTreeErrMemory("building doc");
 1150|      0|	xmlFree(cur);
 1151|      0|	return(NULL);
 1152|      0|    }
 1153|  1.32k|    cur->standalone = -1;
 1154|  1.32k|    cur->compression = -1; /* not initialized */
 1155|  1.32k|    cur->doc = cur;
 1156|  1.32k|    cur->parseFlags = 0;
 1157|  1.32k|    cur->properties = XML_DOC_USERBUILT;
 1158|       |    /*
 1159|       |     * The in memory encoding is always UTF8
 1160|       |     * This field will never change and would
 1161|       |     * be obsolete if not for binary compatibility.
 1162|       |     */
 1163|  1.32k|    cur->charset = XML_CHAR_ENCODING_UTF8;
 1164|       |
 1165|  1.32k|    if ((__xmlRegisterCallbacks) && (xmlRegisterNodeDefaultValue))
  ------------------
  |  |  682|      0|    XML_GLOBAL_MACRO(xmlRegisterNodeDefaultValue)
  |  |  ------------------
  |  |  |  |  500|      0|  #define XML_GLOBAL_MACRO(name) (*__##name())
  |  |  ------------------
  ------------------
  |  Branch (1165:9): [True: 0, False: 1.32k]
  |  Branch (1165:37): [True: 0, False: 0]
  ------------------
 1166|      0|	xmlRegisterNodeDefaultValue((xmlNodePtr)cur);
  ------------------
  |  |  682|      0|    XML_GLOBAL_MACRO(xmlRegisterNodeDefaultValue)
  |  |  ------------------
  |  |  |  |  500|      0|  #define XML_GLOBAL_MACRO(name) (*__##name())
  |  |  ------------------
  ------------------
 1167|  1.32k|    return(cur);
 1168|  1.32k|}
xmlFreeDoc:
 1177|  1.12k|xmlFreeDoc(xmlDocPtr cur) {
 1178|  1.12k|    xmlDtdPtr extSubset, intSubset;
 1179|  1.12k|    xmlDictPtr dict = NULL;
 1180|       |
 1181|  1.12k|    if (cur == NULL) {
  ------------------
  |  Branch (1181:9): [True: 120, False: 1.00k]
  ------------------
 1182|    120|	return;
 1183|    120|    }
 1184|       |
 1185|  1.00k|    if (cur != NULL) dict = cur->dict;
  ------------------
  |  Branch (1185:9): [True: 1.00k, False: 0]
  ------------------
 1186|       |
 1187|  1.00k|    if ((__xmlRegisterCallbacks) && (xmlDeregisterNodeDefaultValue))
  ------------------
  |  |  684|      0|    XML_GLOBAL_MACRO(xmlDeregisterNodeDefaultValue)
  |  |  ------------------
  |  |  |  |  500|      0|  #define XML_GLOBAL_MACRO(name) (*__##name())
  |  |  ------------------
  ------------------
  |  Branch (1187:9): [True: 0, False: 1.00k]
  |  Branch (1187:37): [True: 0, False: 0]
  ------------------
 1188|      0|	xmlDeregisterNodeDefaultValue((xmlNodePtr)cur);
  ------------------
  |  |  684|      0|    XML_GLOBAL_MACRO(xmlDeregisterNodeDefaultValue)
  |  |  ------------------
  |  |  |  |  500|      0|  #define XML_GLOBAL_MACRO(name) (*__##name())
  |  |  ------------------
  ------------------
 1189|       |
 1190|       |    /*
 1191|       |     * Do this before freeing the children list to avoid ID lookups
 1192|       |     */
 1193|  1.00k|    if (cur->ids != NULL) xmlFreeIDTable((xmlIDTablePtr) cur->ids);
  ------------------
  |  Branch (1193:9): [True: 45, False: 957]
  ------------------
 1194|  1.00k|    cur->ids = NULL;
 1195|  1.00k|    if (cur->refs != NULL) xmlFreeRefTable((xmlRefTablePtr) cur->refs);
  ------------------
  |  Branch (1195:9): [True: 18, False: 984]
  ------------------
 1196|  1.00k|    cur->refs = NULL;
 1197|  1.00k|    extSubset = cur->extSubset;
 1198|  1.00k|    intSubset = cur->intSubset;
 1199|  1.00k|    if (intSubset == extSubset)
  ------------------
  |  Branch (1199:9): [True: 432, False: 570]
  ------------------
 1200|    432|	extSubset = NULL;
 1201|  1.00k|    if (extSubset != NULL) {
  ------------------
  |  Branch (1201:9): [True: 63, False: 939]
  ------------------
 1202|     63|	xmlUnlinkNode((xmlNodePtr) cur->extSubset);
 1203|     63|	cur->extSubset = NULL;
 1204|     63|	xmlFreeDtd(extSubset);
 1205|     63|    }
 1206|  1.00k|    if (intSubset != NULL) {
  ------------------
  |  Branch (1206:9): [True: 570, False: 432]
  ------------------
 1207|    570|	xmlUnlinkNode((xmlNodePtr) cur->intSubset);
 1208|    570|	cur->intSubset = NULL;
 1209|    570|	xmlFreeDtd(intSubset);
 1210|    570|    }
 1211|       |
 1212|  1.00k|    if (cur->children != NULL) xmlFreeNodeList(cur->children);
  ------------------
  |  Branch (1212:9): [True: 894, False: 108]
  ------------------
 1213|  1.00k|    if (cur->oldNs != NULL) xmlFreeNsList(cur->oldNs);
  ------------------
  |  Branch (1213:9): [True: 36, False: 966]
  ------------------
 1214|       |
 1215|  1.00k|    DICT_FREE(cur->version)
  ------------------
  |  | 1025|  1.00k|	if ((str) && ((!dict) ||				\
  |  |  ------------------
  |  |  |  Branch (1025:6): [True: 1.00k, False: 0]
  |  |  |  Branch (1025:16): [True: 0, False: 1.00k]
  |  |  ------------------
  |  | 1026|  1.00k|	    (xmlDictOwns(dict, (const xmlChar *)(str)) == 0)))	\
  |  |  ------------------
  |  |  |  Branch (1026:6): [True: 1.00k, False: 0]
  |  |  ------------------
  |  | 1027|  1.00k|	    xmlFree((char *)(str));
  ------------------
 1216|  1.00k|    DICT_FREE(cur->name)
  ------------------
  |  | 1025|  1.00k|	if ((str) && ((!dict) ||				\
  |  |  ------------------
  |  |  |  Branch (1025:6): [True: 0, False: 1.00k]
  |  |  |  Branch (1025:16): [True: 0, False: 0]
  |  |  ------------------
  |  | 1026|      0|	    (xmlDictOwns(dict, (const xmlChar *)(str)) == 0)))	\
  |  |  ------------------
  |  |  |  Branch (1026:6): [True: 0, False: 0]
  |  |  ------------------
  |  | 1027|  1.00k|	    xmlFree((char *)(str));
  ------------------
 1217|  1.00k|    DICT_FREE(cur->encoding)
  ------------------
  |  | 1025|  1.00k|	if ((str) && ((!dict) ||				\
  |  |  ------------------
  |  |  |  Branch (1025:6): [True: 98, False: 904]
  |  |  |  Branch (1025:16): [True: 0, False: 98]
  |  |  ------------------
  |  | 1026|     98|	    (xmlDictOwns(dict, (const xmlChar *)(str)) == 0)))	\
  |  |  ------------------
  |  |  |  Branch (1026:6): [True: 98, False: 0]
  |  |  ------------------
  |  | 1027|  1.00k|	    xmlFree((char *)(str));
  ------------------
 1218|  1.00k|    DICT_FREE(cur->URL)
  ------------------
  |  | 1025|  1.00k|	if ((str) && ((!dict) ||				\
  |  |  ------------------
  |  |  |  Branch (1025:6): [True: 993, False: 9]
  |  |  |  Branch (1025:16): [True: 0, False: 993]
  |  |  ------------------
  |  | 1026|    993|	    (xmlDictOwns(dict, (const xmlChar *)(str)) == 0)))	\
  |  |  ------------------
  |  |  |  Branch (1026:6): [True: 993, False: 0]
  |  |  ------------------
  |  | 1027|  1.00k|	    xmlFree((char *)(str));
  ------------------
 1219|  1.00k|    xmlFree(cur);
 1220|  1.00k|    if (dict) xmlDictFree(dict);
  ------------------
  |  Branch (1220:9): [True: 1.00k, False: 0]
  ------------------
 1221|  1.00k|}
xmlNodeListGetString:
 1673|  1.47k|{
 1674|  1.47k|    const xmlNode *node = list;
 1675|  1.47k|    xmlChar *ret = NULL;
 1676|  1.47k|    xmlEntityPtr ent;
 1677|  1.47k|    int attr;
 1678|       |
 1679|  1.47k|    if (list == NULL)
  ------------------
  |  Branch (1679:9): [True: 0, False: 1.47k]
  ------------------
 1680|      0|        return (NULL);
 1681|  1.47k|    if ((list->parent != NULL) && (list->parent->type == XML_ATTRIBUTE_NODE))
  ------------------
  |  Branch (1681:9): [True: 1.47k, False: 0]
  |  Branch (1681:35): [True: 1.47k, False: 0]
  ------------------
 1682|  1.47k|        attr = 1;
 1683|      0|    else
 1684|      0|        attr = 0;
 1685|       |
 1686|  2.95k|    while (node != NULL) {
  ------------------
  |  Branch (1686:12): [True: 1.47k, False: 1.47k]
  ------------------
 1687|  1.47k|        if ((node->type == XML_TEXT_NODE) ||
  ------------------
  |  Branch (1687:13): [True: 1.47k, False: 0]
  ------------------
 1688|  1.47k|            (node->type == XML_CDATA_SECTION_NODE)) {
  ------------------
  |  Branch (1688:13): [True: 0, False: 0]
  ------------------
 1689|  1.47k|            if (inLine) {
  ------------------
  |  Branch (1689:17): [True: 11, False: 1.46k]
  ------------------
 1690|     11|                ret = xmlStrcat(ret, node->content);
 1691|  1.46k|            } else {
 1692|  1.46k|                xmlChar *buffer;
 1693|       |
 1694|  1.46k|		if (attr)
  ------------------
  |  Branch (1694:7): [True: 1.46k, False: 0]
  ------------------
 1695|  1.46k|		    buffer = xmlEncodeAttributeEntities(doc, node->content);
 1696|      0|		else
 1697|      0|		    buffer = xmlEncodeEntitiesReentrant(doc, node->content);
 1698|  1.46k|                if (buffer != NULL) {
  ------------------
  |  Branch (1698:21): [True: 1.46k, False: 0]
  ------------------
 1699|  1.46k|                    ret = xmlStrcat(ret, buffer);
 1700|  1.46k|                    xmlFree(buffer);
 1701|  1.46k|                }
 1702|  1.46k|            }
 1703|  1.47k|        } else if (node->type == XML_ENTITY_REF_NODE) {
  ------------------
  |  Branch (1703:20): [True: 0, False: 0]
  ------------------
 1704|      0|            if (inLine) {
  ------------------
  |  Branch (1704:17): [True: 0, False: 0]
  ------------------
 1705|      0|                ent = xmlGetDocEntity(doc, node->name);
 1706|      0|                if (ent != NULL) {
  ------------------
  |  Branch (1706:21): [True: 0, False: 0]
  ------------------
 1707|      0|                    xmlChar *buffer;
 1708|       |
 1709|       |                    /* an entity content can be any "well balanced chunk",
 1710|       |                     * i.e. the result of the content [43] production:
 1711|       |                     * http://www.w3.org/TR/REC-xml#NT-content.
 1712|       |                     * So it can contain text, CDATA section or nested
 1713|       |                     * entity reference nodes (among others).
 1714|       |                     * -> we recursive  call xmlNodeListGetString()
 1715|       |                     * which handles these types */
 1716|      0|                    buffer = xmlNodeListGetString(doc, ent->children, 1);
 1717|      0|                    if (buffer != NULL) {
  ------------------
  |  Branch (1717:25): [True: 0, False: 0]
  ------------------
 1718|      0|                        ret = xmlStrcat(ret, buffer);
 1719|      0|                        xmlFree(buffer);
 1720|      0|                    }
 1721|      0|                } else {
 1722|      0|                    ret = xmlStrcat(ret, node->content);
 1723|      0|                }
 1724|      0|            } else {
 1725|      0|                xmlChar buf[2];
 1726|       |
 1727|      0|                buf[0] = '&';
 1728|      0|                buf[1] = 0;
 1729|      0|                ret = xmlStrncat(ret, buf, 1);
 1730|      0|                ret = xmlStrcat(ret, node->name);
 1731|      0|                buf[0] = ';';
 1732|      0|                buf[1] = 0;
 1733|      0|                ret = xmlStrncat(ret, buf, 1);
 1734|      0|            }
 1735|      0|        }
 1736|       |#if 0
 1737|       |        else {
 1738|       |            xmlGenericError(xmlGenericErrorContext,
 1739|       |                            "xmlGetNodeListString : invalid node type %d\n",
 1740|       |                            node->type);
 1741|       |        }
 1742|       |#endif
 1743|  1.47k|        node = node->next;
 1744|  1.47k|    }
 1745|  1.47k|    return (ret);
 1746|  1.47k|}
xmlNewDocProp:
 1997|     12|xmlNewDocProp(xmlDocPtr doc, const xmlChar *name, const xmlChar *value) {
 1998|     12|    xmlAttrPtr cur;
 1999|       |
 2000|     12|    if (name == NULL) {
  ------------------
  |  Branch (2000:9): [True: 0, False: 12]
  ------------------
 2001|      0|	return(NULL);
 2002|      0|    }
 2003|       |
 2004|       |    /*
 2005|       |     * Allocate a new property and fill the fields.
 2006|       |     */
 2007|     12|    cur = (xmlAttrPtr) xmlMalloc(sizeof(xmlAttr));
 2008|     12|    if (cur == NULL) {
  ------------------
  |  Branch (2008:9): [True: 0, False: 12]
  ------------------
 2009|      0|	xmlTreeErrMemory("building attribute");
 2010|      0|	return(NULL);
 2011|      0|    }
 2012|     12|    memset(cur, 0, sizeof(xmlAttr));
 2013|     12|    cur->type = XML_ATTRIBUTE_NODE;
 2014|       |
 2015|     12|    if ((doc != NULL) && (doc->dict != NULL))
  ------------------
  |  Branch (2015:9): [True: 12, False: 0]
  |  Branch (2015:26): [True: 12, False: 0]
  ------------------
 2016|     12|	cur->name = xmlDictLookup(doc->dict, name, -1);
 2017|      0|    else
 2018|      0|	cur->name = xmlStrdup(name);
 2019|     12|    cur->doc = doc;
 2020|     12|    if (value != NULL) {
  ------------------
  |  Branch (2020:9): [True: 0, False: 12]
  ------------------
 2021|      0|	xmlNodePtr tmp;
 2022|       |
 2023|      0|	cur->children = xmlStringGetNodeList(doc, value);
 2024|      0|	cur->last = NULL;
 2025|       |
 2026|      0|	tmp = cur->children;
 2027|      0|	while (tmp != NULL) {
  ------------------
  |  Branch (2027:9): [True: 0, False: 0]
  ------------------
 2028|      0|	    tmp->parent = (xmlNodePtr) cur;
 2029|      0|	    if (tmp->next == NULL)
  ------------------
  |  Branch (2029:10): [True: 0, False: 0]
  ------------------
 2030|      0|		cur->last = tmp;
 2031|      0|	    tmp = tmp->next;
 2032|      0|	}
 2033|      0|    }
 2034|       |
 2035|     12|    if ((__xmlRegisterCallbacks) && (xmlRegisterNodeDefaultValue))
  ------------------
  |  |  682|      0|    XML_GLOBAL_MACRO(xmlRegisterNodeDefaultValue)
  |  |  ------------------
  |  |  |  |  500|      0|  #define XML_GLOBAL_MACRO(name) (*__##name())
  |  |  ------------------
  ------------------
  |  Branch (2035:9): [True: 0, False: 12]
  |  Branch (2035:37): [True: 0, False: 0]
  ------------------
 2036|      0|	xmlRegisterNodeDefaultValue((xmlNodePtr)cur);
  ------------------
  |  |  682|      0|    XML_GLOBAL_MACRO(xmlRegisterNodeDefaultValue)
  |  |  ------------------
  |  |  |  |  500|      0|  #define XML_GLOBAL_MACRO(name) (*__##name())
  |  |  ------------------
  ------------------
 2037|     12|    return(cur);
 2038|     12|}
xmlFreePropList:
 2047|  34.6k|xmlFreePropList(xmlAttrPtr cur) {
 2048|  34.6k|    xmlAttrPtr next;
 2049|  34.6k|    if (cur == NULL) return;
  ------------------
  |  Branch (2049:9): [True: 0, False: 34.6k]
  ------------------
 2050|  98.7k|    while (cur != NULL) {
  ------------------
  |  Branch (2050:12): [True: 64.0k, False: 34.6k]
  ------------------
 2051|  64.0k|        next = cur->next;
 2052|  64.0k|        xmlFreeProp(cur);
 2053|  64.0k|	cur = next;
 2054|  64.0k|    }
 2055|  34.6k|}
xmlFreeProp:
 2064|  64.0k|xmlFreeProp(xmlAttrPtr cur) {
 2065|  64.0k|    xmlDictPtr dict = NULL;
 2066|  64.0k|    if (cur == NULL) return;
  ------------------
  |  Branch (2066:9): [True: 0, False: 64.0k]
  ------------------
 2067|       |
 2068|  64.0k|    if (cur->doc != NULL) dict = cur->doc->dict;
  ------------------
  |  Branch (2068:9): [True: 64.0k, False: 0]
  ------------------
 2069|       |
 2070|  64.0k|    if ((__xmlRegisterCallbacks) && (xmlDeregisterNodeDefaultValue))
  ------------------
  |  |  684|      0|    XML_GLOBAL_MACRO(xmlDeregisterNodeDefaultValue)
  |  |  ------------------
  |  |  |  |  500|      0|  #define XML_GLOBAL_MACRO(name) (*__##name())
  |  |  ------------------
  ------------------
  |  Branch (2070:9): [True: 0, False: 64.0k]
  |  Branch (2070:37): [True: 0, False: 0]
  ------------------
 2071|      0|	xmlDeregisterNodeDefaultValue((xmlNodePtr)cur);
  ------------------
  |  |  684|      0|    XML_GLOBAL_MACRO(xmlDeregisterNodeDefaultValue)
  |  |  ------------------
  |  |  |  |  500|      0|  #define XML_GLOBAL_MACRO(name) (*__##name())
  |  |  ------------------
  ------------------
 2072|       |
 2073|       |    /* Check for ID removal -> leading to invalid references ! */
 2074|  64.0k|    if ((cur->doc != NULL) && (cur->atype == XML_ATTRIBUTE_ID)) {
  ------------------
  |  Branch (2074:9): [True: 64.0k, False: 0]
  |  Branch (2074:31): [True: 993, False: 63.0k]
  ------------------
 2075|    993|	    xmlRemoveID(cur->doc, cur);
 2076|    993|    }
 2077|  64.0k|    if (cur->children != NULL) xmlFreeNodeList(cur->children);
  ------------------
  |  Branch (2077:9): [True: 64.0k, False: 0]
  ------------------
 2078|  64.0k|    DICT_FREE(cur->name)
  ------------------
  |  | 1025|  64.0k|	if ((str) && ((!dict) ||				\
  |  |  ------------------
  |  |  |  Branch (1025:6): [True: 64.0k, False: 0]
  |  |  |  Branch (1025:16): [True: 0, False: 64.0k]
  |  |  ------------------
  |  | 1026|  64.0k|	    (xmlDictOwns(dict, (const xmlChar *)(str)) == 0)))	\
  |  |  ------------------
  |  |  |  Branch (1026:6): [True: 0, False: 64.0k]
  |  |  ------------------
  |  | 1027|  64.0k|	    xmlFree((char *)(str));
  ------------------
 2079|  64.0k|    xmlFree(cur);
 2080|  64.0k|}
xmlNewDocPI:
 2131|     84|xmlNewDocPI(xmlDocPtr doc, const xmlChar *name, const xmlChar *content) {
 2132|     84|    xmlNodePtr cur;
 2133|       |
 2134|     84|    if (name == NULL) {
  ------------------
  |  Branch (2134:9): [True: 0, False: 84]
  ------------------
 2135|      0|	return(NULL);
 2136|      0|    }
 2137|       |
 2138|       |    /*
 2139|       |     * Allocate a new node and fill the fields.
 2140|       |     */
 2141|     84|    cur = (xmlNodePtr) xmlMalloc(sizeof(xmlNode));
 2142|     84|    if (cur == NULL) {
  ------------------
  |  Branch (2142:9): [True: 0, False: 84]
  ------------------
 2143|      0|	xmlTreeErrMemory("building PI");
 2144|      0|	return(NULL);
 2145|      0|    }
 2146|     84|    memset(cur, 0, sizeof(xmlNode));
 2147|     84|    cur->type = XML_PI_NODE;
 2148|       |
 2149|     84|    if ((doc != NULL) && (doc->dict != NULL))
  ------------------
  |  Branch (2149:9): [True: 84, False: 0]
  |  Branch (2149:26): [True: 84, False: 0]
  ------------------
 2150|     84|        cur->name = xmlDictLookup(doc->dict, name, -1);
 2151|      0|    else
 2152|      0|	cur->name = xmlStrdup(name);
 2153|     84|    if (content != NULL) {
  ------------------
  |  Branch (2153:9): [True: 80, False: 4]
  ------------------
 2154|     80|	cur->content = xmlStrdup(content);
 2155|     80|    }
 2156|     84|    cur->doc = doc;
 2157|       |
 2158|     84|    if ((__xmlRegisterCallbacks) && (xmlRegisterNodeDefaultValue))
  ------------------
  |  |  682|      0|    XML_GLOBAL_MACRO(xmlRegisterNodeDefaultValue)
  |  |  ------------------
  |  |  |  |  500|      0|  #define XML_GLOBAL_MACRO(name) (*__##name())
  |  |  ------------------
  ------------------
  |  Branch (2158:9): [True: 0, False: 84]
  |  Branch (2158:37): [True: 0, False: 0]
  ------------------
 2159|      0|	xmlRegisterNodeDefaultValue((xmlNodePtr)cur);
  ------------------
  |  |  682|      0|    XML_GLOBAL_MACRO(xmlRegisterNodeDefaultValue)
  |  |  ------------------
  |  |  |  |  500|      0|  #define XML_GLOBAL_MACRO(name) (*__##name())
  |  |  ------------------
  ------------------
 2160|     84|    return(cur);
 2161|     84|}
xmlNewNodeEatName:
 2232|  56.9k|xmlNewNodeEatName(xmlNsPtr ns, xmlChar *name) {
 2233|  56.9k|    xmlNodePtr cur;
 2234|       |
 2235|  56.9k|    if (name == NULL) {
  ------------------
  |  Branch (2235:9): [True: 0, False: 56.9k]
  ------------------
 2236|      0|	return(NULL);
 2237|      0|    }
 2238|       |
 2239|       |    /*
 2240|       |     * Allocate a new node and fill the fields.
 2241|       |     */
 2242|  56.9k|    cur = (xmlNodePtr) xmlMalloc(sizeof(xmlNode));
 2243|  56.9k|    if (cur == NULL) {
  ------------------
  |  Branch (2243:9): [True: 0, False: 56.9k]
  ------------------
 2244|      0|	xmlTreeErrMemory("building node");
 2245|       |	/* we can't check here that name comes from the doc dictionary */
 2246|      0|	return(NULL);
 2247|      0|    }
 2248|  56.9k|    memset(cur, 0, sizeof(xmlNode));
 2249|  56.9k|    cur->type = XML_ELEMENT_NODE;
 2250|       |
 2251|  56.9k|    cur->name = name;
 2252|  56.9k|    cur->ns = ns;
 2253|       |
 2254|  56.9k|    if ((__xmlRegisterCallbacks) && (xmlRegisterNodeDefaultValue))
  ------------------
  |  |  682|      0|    XML_GLOBAL_MACRO(xmlRegisterNodeDefaultValue)
  |  |  ------------------
  |  |  |  |  500|      0|  #define XML_GLOBAL_MACRO(name) (*__##name())
  |  |  ------------------
  ------------------
  |  Branch (2254:9): [True: 0, False: 56.9k]
  |  Branch (2254:37): [True: 0, False: 0]
  ------------------
 2255|      0|	xmlRegisterNodeDefaultValue((xmlNodePtr)cur);
  ------------------
  |  |  682|      0|    XML_GLOBAL_MACRO(xmlRegisterNodeDefaultValue)
  |  |  ------------------
  |  |  |  |  500|      0|  #define XML_GLOBAL_MACRO(name) (*__##name())
  |  |  ------------------
  ------------------
 2256|  56.9k|    return(cur);
 2257|  56.9k|}
xmlNewDocNode:
 2277|    468|              const xmlChar *name, const xmlChar *content) {
 2278|    468|    xmlNodePtr cur;
 2279|       |
 2280|    468|    if ((doc != NULL) && (doc->dict != NULL))
  ------------------
  |  Branch (2280:9): [True: 468, False: 0]
  |  Branch (2280:26): [True: 468, False: 0]
  ------------------
 2281|    468|        cur = xmlNewNodeEatName(ns, (xmlChar *)
 2282|    468|	                        xmlDictLookup(doc->dict, name, -1));
 2283|      0|    else
 2284|      0|	cur = xmlNewNode(ns, name);
 2285|    468|    if (cur != NULL) {
  ------------------
  |  Branch (2285:9): [True: 468, False: 0]
  ------------------
 2286|    468|        cur->doc = doc;
 2287|    468|	if (content != NULL) {
  ------------------
  |  Branch (2287:6): [True: 0, False: 468]
  ------------------
 2288|      0|	    cur->children = xmlStringGetNodeList(doc, content);
 2289|      0|	    UPDATE_LAST_CHILD_AND_PARENT(cur)
  ------------------
  |  |  127|      0|#define UPDATE_LAST_CHILD_AND_PARENT(n) if ((n) != NULL) {		\
  |  |  ------------------
  |  |  |  Branch (127:45): [True: 0, False: 0]
  |  |  ------------------
  |  |  128|      0|    xmlNodePtr ulccur = (n)->children;					\
  |  |  129|      0|    if (ulccur == NULL) {						\
  |  |  ------------------
  |  |  |  Branch (129:9): [True: 0, False: 0]
  |  |  ------------------
  |  |  130|      0|        (n)->last = NULL;						\
  |  |  131|      0|    } else {								\
  |  |  132|      0|        while (ulccur->next != NULL) {					\
  |  |  ------------------
  |  |  |  Branch (132:16): [True: 0, False: 0]
  |  |  ------------------
  |  |  133|      0|		ulccur->parent = (n);					\
  |  |  134|      0|		ulccur = ulccur->next;					\
  |  |  135|      0|	}								\
  |  |  136|      0|	ulccur->parent = (n);						\
  |  |  137|      0|	(n)->last = ulccur;						\
  |  |  138|      0|}}
  ------------------
 2290|      0|	}
 2291|    468|    }
 2292|       |
 2293|    468|    return(cur);
 2294|    468|}
xmlNewDocNodeEatName:
 2314|  56.4k|              xmlChar *name, const xmlChar *content) {
 2315|  56.4k|    xmlNodePtr cur;
 2316|       |
 2317|  56.4k|    cur = xmlNewNodeEatName(ns, name);
 2318|  56.4k|    if (cur != NULL) {
  ------------------
  |  Branch (2318:9): [True: 56.4k, False: 0]
  ------------------
 2319|  56.4k|        cur->doc = doc;
 2320|  56.4k|	if (content != NULL) {
  ------------------
  |  Branch (2320:6): [True: 0, False: 56.4k]
  ------------------
 2321|      0|	    cur->children = xmlStringGetNodeList(doc, content);
 2322|      0|	    UPDATE_LAST_CHILD_AND_PARENT(cur)
  ------------------
  |  |  127|      0|#define UPDATE_LAST_CHILD_AND_PARENT(n) if ((n) != NULL) {		\
  |  |  ------------------
  |  |  |  Branch (127:45): [True: 0, False: 0]
  |  |  ------------------
  |  |  128|      0|    xmlNodePtr ulccur = (n)->children;					\
  |  |  129|      0|    if (ulccur == NULL) {						\
  |  |  ------------------
  |  |  |  Branch (129:9): [True: 0, False: 0]
  |  |  ------------------
  |  |  130|      0|        (n)->last = NULL;						\
  |  |  131|      0|    } else {								\
  |  |  132|      0|        while (ulccur->next != NULL) {					\
  |  |  ------------------
  |  |  |  Branch (132:16): [True: 0, False: 0]
  |  |  ------------------
  |  |  133|      0|		ulccur->parent = (n);					\
  |  |  134|      0|		ulccur = ulccur->next;					\
  |  |  135|      0|	}								\
  |  |  136|      0|	ulccur->parent = (n);						\
  |  |  137|      0|	(n)->last = ulccur;						\
  |  |  138|      0|}}
  ------------------
 2323|      0|	}
 2324|  56.4k|    } else {
 2325|       |        /* if name don't come from the doc dictionary free it here */
 2326|      0|        if ((name != NULL) &&
  ------------------
  |  Branch (2326:13): [True: 0, False: 0]
  ------------------
 2327|      0|            ((doc == NULL) || (doc->dict == NULL) ||
  ------------------
  |  Branch (2327:14): [True: 0, False: 0]
  |  Branch (2327:31): [True: 0, False: 0]
  ------------------
 2328|      0|	     (!(xmlDictOwns(doc->dict, name)))))
  ------------------
  |  Branch (2328:7): [True: 0, False: 0]
  ------------------
 2329|      0|	    xmlFree(name);
 2330|      0|    }
 2331|  56.4k|    return(cur);
 2332|  56.4k|}
xmlNewText:
 2404|     66|xmlNewText(const xmlChar *content) {
 2405|     66|    xmlNodePtr cur;
 2406|       |
 2407|       |    /*
 2408|       |     * Allocate a new node and fill the fields.
 2409|       |     */
 2410|     66|    cur = (xmlNodePtr) xmlMalloc(sizeof(xmlNode));
 2411|     66|    if (cur == NULL) {
  ------------------
  |  Branch (2411:9): [True: 0, False: 66]
  ------------------
 2412|      0|	xmlTreeErrMemory("building text");
 2413|      0|	return(NULL);
 2414|      0|    }
 2415|     66|    memset(cur, 0, sizeof(xmlNode));
 2416|     66|    cur->type = XML_TEXT_NODE;
 2417|       |
 2418|     66|    cur->name = xmlStringText;
 2419|     66|    if (content != NULL) {
  ------------------
  |  Branch (2419:9): [True: 66, False: 0]
  ------------------
 2420|     66|	cur->content = xmlStrdup(content);
 2421|     66|    }
 2422|       |
 2423|     66|    if ((__xmlRegisterCallbacks) && (xmlRegisterNodeDefaultValue))
  ------------------
  |  |  682|      0|    XML_GLOBAL_MACRO(xmlRegisterNodeDefaultValue)
  |  |  ------------------
  |  |  |  |  500|      0|  #define XML_GLOBAL_MACRO(name) (*__##name())
  |  |  ------------------
  ------------------
  |  Branch (2423:9): [True: 0, False: 66]
  |  Branch (2423:37): [True: 0, False: 0]
  ------------------
 2424|      0|	xmlRegisterNodeDefaultValue(cur);
  ------------------
  |  |  682|      0|    XML_GLOBAL_MACRO(xmlRegisterNodeDefaultValue)
  |  |  ------------------
  |  |  |  |  500|      0|  #define XML_GLOBAL_MACRO(name) (*__##name())
  |  |  ------------------
  ------------------
 2425|     66|    return(cur);
 2426|     66|}
xmlNewReference:
 2554|      4|xmlNewReference(const xmlDoc *doc, const xmlChar *name) {
 2555|      4|    xmlNodePtr cur;
 2556|      4|    xmlEntityPtr ent;
 2557|       |
 2558|      4|    if (name == NULL)
  ------------------
  |  Branch (2558:9): [True: 0, False: 4]
  ------------------
 2559|      0|        return(NULL);
 2560|       |
 2561|       |    /*
 2562|       |     * Allocate a new node and fill the fields.
 2563|       |     */
 2564|      4|    cur = (xmlNodePtr) xmlMalloc(sizeof(xmlNode));
 2565|      4|    if (cur == NULL) {
  ------------------
  |  Branch (2565:9): [True: 0, False: 4]
  ------------------
 2566|      0|	xmlTreeErrMemory("building reference");
 2567|      0|	return(NULL);
 2568|      0|    }
 2569|      4|    memset(cur, 0, sizeof(xmlNode));
 2570|      4|    cur->type = XML_ENTITY_REF_NODE;
 2571|       |
 2572|      4|    cur->doc = (xmlDoc *)doc;
 2573|      4|    if (name[0] == '&') {
  ------------------
  |  Branch (2573:9): [True: 0, False: 4]
  ------------------
 2574|      0|        int len;
 2575|      0|        name++;
 2576|      0|	len = xmlStrlen(name);
 2577|      0|	if (name[len - 1] == ';')
  ------------------
  |  Branch (2577:6): [True: 0, False: 0]
  ------------------
 2578|      0|	    cur->name = xmlStrndup(name, len - 1);
 2579|      0|	else
 2580|      0|	    cur->name = xmlStrndup(name, len);
 2581|      0|    } else
 2582|      4|	cur->name = xmlStrdup(name);
 2583|       |
 2584|      4|    ent = xmlGetDocEntity(doc, cur->name);
 2585|      4|    if (ent != NULL) {
  ------------------
  |  Branch (2585:9): [True: 0, False: 4]
  ------------------
 2586|      0|	cur->content = ent->content;
 2587|       |	/*
 2588|       |	 * The parent pointer in entity is a DTD pointer and thus is NOT
 2589|       |	 * updated.  Not sure if this is 100% correct.
 2590|       |	 *  -George
 2591|       |	 */
 2592|      0|	cur->children = (xmlNodePtr) ent;
 2593|      0|	cur->last = (xmlNodePtr) ent;
 2594|      0|    }
 2595|       |
 2596|      4|    if ((__xmlRegisterCallbacks) && (xmlRegisterNodeDefaultValue))
  ------------------
  |  |  682|      0|    XML_GLOBAL_MACRO(xmlRegisterNodeDefaultValue)
  |  |  ------------------
  |  |  |  |  500|      0|  #define XML_GLOBAL_MACRO(name) (*__##name())
  |  |  ------------------
  ------------------
  |  Branch (2596:9): [True: 0, False: 4]
  |  Branch (2596:37): [True: 0, False: 0]
  ------------------
 2597|      0|	xmlRegisterNodeDefaultValue(cur);
  ------------------
  |  |  682|      0|    XML_GLOBAL_MACRO(xmlRegisterNodeDefaultValue)
  |  |  ------------------
  |  |  |  |  500|      0|  #define XML_GLOBAL_MACRO(name) (*__##name())
  |  |  ------------------
  ------------------
 2598|      4|    return(cur);
 2599|      4|}
xmlNewDocText:
 2610|     66|xmlNewDocText(const xmlDoc *doc, const xmlChar *content) {
 2611|     66|    xmlNodePtr cur;
 2612|       |
 2613|     66|    cur = xmlNewText(content);
 2614|     66|    if (cur != NULL) cur->doc = (xmlDoc *)doc;
  ------------------
  |  Branch (2614:9): [True: 66, False: 0]
  ------------------
 2615|     66|    return(cur);
 2616|     66|}
xmlNewComment:
 2682|   643k|xmlNewComment(const xmlChar *content) {
 2683|   643k|    xmlNodePtr cur;
 2684|       |
 2685|       |    /*
 2686|       |     * Allocate a new node and fill the fields.
 2687|       |     */
 2688|   643k|    cur = (xmlNodePtr) xmlMalloc(sizeof(xmlNode));
 2689|   643k|    if (cur == NULL) {
  ------------------
  |  Branch (2689:9): [True: 0, False: 643k]
  ------------------
 2690|      0|	xmlTreeErrMemory("building comment");
 2691|      0|	return(NULL);
 2692|      0|    }
 2693|   643k|    memset(cur, 0, sizeof(xmlNode));
 2694|   643k|    cur->type = XML_COMMENT_NODE;
 2695|       |
 2696|   643k|    cur->name = xmlStringComment;
 2697|   643k|    if (content != NULL) {
  ------------------
  |  Branch (2697:9): [True: 643k, False: 0]
  ------------------
 2698|   643k|	cur->content = xmlStrdup(content);
 2699|   643k|    }
 2700|       |
 2701|   643k|    if ((__xmlRegisterCallbacks) && (xmlRegisterNodeDefaultValue))
  ------------------
  |  |  682|      0|    XML_GLOBAL_MACRO(xmlRegisterNodeDefaultValue)
  |  |  ------------------
  |  |  |  |  500|      0|  #define XML_GLOBAL_MACRO(name) (*__##name())
  |  |  ------------------
  ------------------
  |  Branch (2701:9): [True: 0, False: 643k]
  |  Branch (2701:37): [True: 0, False: 0]
  ------------------
 2702|      0|	xmlRegisterNodeDefaultValue(cur);
  ------------------
  |  |  682|      0|    XML_GLOBAL_MACRO(xmlRegisterNodeDefaultValue)
  |  |  ------------------
  |  |  |  |  500|      0|  #define XML_GLOBAL_MACRO(name) (*__##name())
  |  |  ------------------
  ------------------
 2703|   643k|    return(cur);
 2704|   643k|}
xmlNewCDataBlock:
 2716|    132|xmlNewCDataBlock(xmlDocPtr doc, const xmlChar *content, int len) {
 2717|    132|    xmlNodePtr cur;
 2718|       |
 2719|       |    /*
 2720|       |     * Allocate a new node and fill the fields.
 2721|       |     */
 2722|    132|    cur = (xmlNodePtr) xmlMalloc(sizeof(xmlNode));
 2723|    132|    if (cur == NULL) {
  ------------------
  |  Branch (2723:9): [True: 0, False: 132]
  ------------------
 2724|      0|	xmlTreeErrMemory("building CDATA");
 2725|      0|	return(NULL);
 2726|      0|    }
 2727|    132|    memset(cur, 0, sizeof(xmlNode));
 2728|    132|    cur->type = XML_CDATA_SECTION_NODE;
 2729|    132|    cur->doc = doc;
 2730|       |
 2731|    132|    if (content != NULL) {
  ------------------
  |  Branch (2731:9): [True: 132, False: 0]
  ------------------
 2732|    132|	cur->content = xmlStrndup(content, len);
 2733|    132|    }
 2734|       |
 2735|    132|    if ((__xmlRegisterCallbacks) && (xmlRegisterNodeDefaultValue))
  ------------------
  |  |  682|      0|    XML_GLOBAL_MACRO(xmlRegisterNodeDefaultValue)
  |  |  ------------------
  |  |  |  |  500|      0|  #define XML_GLOBAL_MACRO(name) (*__##name())
  |  |  ------------------
  ------------------
  |  Branch (2735:9): [True: 0, False: 132]
  |  Branch (2735:37): [True: 0, False: 0]
  ------------------
 2736|      0|	xmlRegisterNodeDefaultValue(cur);
  ------------------
  |  |  682|      0|    XML_GLOBAL_MACRO(xmlRegisterNodeDefaultValue)
  |  |  ------------------
  |  |  |  |  500|      0|  #define XML_GLOBAL_MACRO(name) (*__##name())
  |  |  ------------------
  ------------------
 2737|    132|    return(cur);
 2738|    132|}
xmlNewDocComment:
 2749|   643k|xmlNewDocComment(xmlDocPtr doc, const xmlChar *content) {
 2750|   643k|    xmlNodePtr cur;
 2751|       |
 2752|   643k|    cur = xmlNewComment(content);
 2753|   643k|    if (cur != NULL) cur->doc = doc;
  ------------------
  |  Branch (2753:9): [True: 643k, False: 0]
  ------------------
 2754|   643k|    return(cur);
 2755|   643k|}
xmlAddChild:
 3279|   775k|xmlAddChild(xmlNodePtr parent, xmlNodePtr cur) {
 3280|   775k|    xmlNodePtr prev;
 3281|       |
 3282|   775k|    if ((parent == NULL) || (parent->type == XML_NAMESPACE_DECL)) {
  ------------------
  |  Branch (3282:9): [True: 0, False: 775k]
  |  Branch (3282:29): [True: 0, False: 775k]
  ------------------
 3283|      0|	return(NULL);
 3284|      0|    }
 3285|       |
 3286|   775k|    if ((cur == NULL) || (cur->type == XML_NAMESPACE_DECL)) {
  ------------------
  |  Branch (3286:9): [True: 0, False: 775k]
  |  Branch (3286:26): [True: 0, False: 775k]
  ------------------
 3287|      0|	return(NULL);
 3288|      0|    }
 3289|       |
 3290|   775k|    if (parent == cur) {
  ------------------
  |  Branch (3290:9): [True: 0, False: 775k]
  ------------------
 3291|      0|	return(NULL);
 3292|      0|    }
 3293|       |    /*
 3294|       |     * If cur is a TEXT node, merge its content with adjacent TEXT nodes
 3295|       |     * cur is then freed.
 3296|       |     */
 3297|   775k|    if (cur->type == XML_TEXT_NODE) {
  ------------------
  |  Branch (3297:9): [True: 74.2k, False: 701k]
  ------------------
 3298|  74.2k|	if ((parent->type == XML_TEXT_NODE) &&
  ------------------
  |  Branch (3298:6): [True: 0, False: 74.2k]
  ------------------
 3299|  74.2k|	    (parent->content != NULL) &&
  ------------------
  |  Branch (3299:6): [True: 0, False: 0]
  ------------------
 3300|  74.2k|	    (parent->name == cur->name)) {
  ------------------
  |  Branch (3300:6): [True: 0, False: 0]
  ------------------
 3301|      0|	    xmlNodeAddContent(parent, cur->content);
 3302|      0|	    xmlFreeNode(cur);
 3303|      0|	    return(parent);
 3304|      0|	}
 3305|  74.2k|	if ((parent->last != NULL) && (parent->last->type == XML_TEXT_NODE) &&
  ------------------
  |  Branch (3305:6): [True: 65.6k, False: 8.64k]
  |  Branch (3305:32): [True: 10.8k, False: 54.8k]
  ------------------
 3306|  74.2k|	    (parent->last->name == cur->name) &&
  ------------------
  |  Branch (3306:6): [True: 10.8k, False: 0]
  ------------------
 3307|  74.2k|	    (parent->last != cur)) {
  ------------------
  |  Branch (3307:6): [True: 10.8k, False: 0]
  ------------------
 3308|  10.8k|	    xmlNodeAddContent(parent->last, cur->content);
 3309|  10.8k|	    xmlFreeNode(cur);
 3310|  10.8k|	    return(parent->last);
 3311|  10.8k|	}
 3312|  74.2k|    }
 3313|       |
 3314|       |    /*
 3315|       |     * add the new element at the end of the children list.
 3316|       |     */
 3317|   765k|    prev = cur->parent;
 3318|   765k|    cur->parent = parent;
 3319|   765k|    if (cur->doc != parent->doc) {
  ------------------
  |  Branch (3319:9): [True: 0, False: 765k]
  ------------------
 3320|      0|	xmlSetTreeDoc(cur, parent->doc);
 3321|      0|    }
 3322|       |    /* this check prevents a loop on tree-traversions if a developer
 3323|       |     * tries to add a node to its parent multiple times
 3324|       |     */
 3325|   765k|    if (prev == parent)
  ------------------
  |  Branch (3325:9): [True: 124, False: 764k]
  ------------------
 3326|    124|	return(cur);
 3327|       |
 3328|       |    /*
 3329|       |     * Coalescing
 3330|       |     */
 3331|   764k|    if ((parent->type == XML_TEXT_NODE) &&
  ------------------
  |  Branch (3331:9): [True: 0, False: 764k]
  ------------------
 3332|   764k|	(parent->content != NULL) &&
  ------------------
  |  Branch (3332:2): [True: 0, False: 0]
  ------------------
 3333|   764k|	(parent != cur)) {
  ------------------
  |  Branch (3333:2): [True: 0, False: 0]
  ------------------
 3334|      0|	xmlNodeAddContent(parent, cur->content);
 3335|      0|	xmlFreeNode(cur);
 3336|      0|	return(parent);
 3337|      0|    }
 3338|   764k|    if (cur->type == XML_ATTRIBUTE_NODE) {
  ------------------
  |  Branch (3338:9): [True: 0, False: 764k]
  ------------------
 3339|      0|		if (parent->type != XML_ELEMENT_NODE)
  ------------------
  |  Branch (3339:7): [True: 0, False: 0]
  ------------------
 3340|      0|			return(NULL);
 3341|      0|	if (parent->properties != NULL) {
  ------------------
  |  Branch (3341:6): [True: 0, False: 0]
  ------------------
 3342|       |	    /* check if an attribute with the same name exists */
 3343|      0|	    xmlAttrPtr lastattr;
 3344|       |
 3345|      0|	    if (cur->ns == NULL)
  ------------------
  |  Branch (3345:10): [True: 0, False: 0]
  ------------------
 3346|      0|		lastattr = xmlHasNsProp(parent, cur->name, NULL);
 3347|      0|	    else
 3348|      0|		lastattr = xmlHasNsProp(parent, cur->name, cur->ns->href);
 3349|      0|	    if ((lastattr != NULL) && (lastattr != (xmlAttrPtr) cur) && (lastattr->type != XML_ATTRIBUTE_DECL)) {
  ------------------
  |  Branch (3349:10): [True: 0, False: 0]
  |  Branch (3349:32): [True: 0, False: 0]
  |  Branch (3349:66): [True: 0, False: 0]
  ------------------
 3350|       |		/* different instance, destroy it (attributes must be unique) */
 3351|      0|			xmlUnlinkNode((xmlNodePtr) lastattr);
 3352|      0|		xmlFreeProp(lastattr);
 3353|      0|	    }
 3354|      0|		if (lastattr == (xmlAttrPtr) cur)
  ------------------
  |  Branch (3354:7): [True: 0, False: 0]
  ------------------
 3355|      0|			return(cur);
 3356|       |
 3357|      0|	}
 3358|      0|	if (parent->properties == NULL) {
  ------------------
  |  Branch (3358:6): [True: 0, False: 0]
  ------------------
 3359|      0|	    parent->properties = (xmlAttrPtr) cur;
 3360|      0|	} else {
 3361|       |	    /* find the end */
 3362|      0|	    xmlAttrPtr lastattr = parent->properties;
 3363|      0|	    while (lastattr->next != NULL) {
  ------------------
  |  Branch (3363:13): [True: 0, False: 0]
  ------------------
 3364|      0|		lastattr = lastattr->next;
 3365|      0|	    }
 3366|      0|	    lastattr->next = (xmlAttrPtr) cur;
 3367|      0|	    ((xmlAttrPtr) cur)->prev = lastattr;
 3368|      0|	}
 3369|   764k|    } else {
 3370|   764k|	if (parent->children == NULL) {
  ------------------
  |  Branch (3370:6): [True: 11.4k, False: 753k]
  ------------------
 3371|  11.4k|	    parent->children = cur;
 3372|  11.4k|	    parent->last = cur;
 3373|   753k|	} else {
 3374|   753k|	    prev = parent->last;
 3375|   753k|	    prev->next = cur;
 3376|   753k|	    cur->prev = prev;
 3377|   753k|	    parent->last = cur;
 3378|   753k|	}
 3379|   764k|    }
 3380|   764k|    return(cur);
 3381|   764k|}
xmlFreeNodeList:
 3602|  65.4k|xmlFreeNodeList(xmlNodePtr cur) {
 3603|  65.4k|    xmlNodePtr next;
 3604|  65.4k|    xmlNodePtr parent;
 3605|  65.4k|    xmlDictPtr dict = NULL;
 3606|  65.4k|    size_t depth = 0;
 3607|       |
 3608|  65.4k|    if (cur == NULL) return;
  ------------------
  |  Branch (3608:9): [True: 188, False: 65.2k]
  ------------------
 3609|  65.2k|    if (cur->type == XML_NAMESPACE_DECL) {
  ------------------
  |  Branch (3609:9): [True: 0, False: 65.2k]
  ------------------
 3610|      0|	xmlFreeNsList((xmlNsPtr) cur);
 3611|      0|	return;
 3612|      0|    }
 3613|  65.2k|    if (cur->doc != NULL) dict = cur->doc->dict;
  ------------------
  |  Branch (3613:9): [True: 65.2k, False: 0]
  ------------------
 3614|   160k|    while (1) {
  ------------------
  |  Branch (3614:12): [Folded - Ignored]
  ------------------
 3615|   172k|        while ((cur->children != NULL) &&
  ------------------
  |  Branch (3615:16): [True: 12.4k, False: 160k]
  ------------------
 3616|   172k|               (cur->type != XML_DOCUMENT_NODE) &&
  ------------------
  |  Branch (3616:16): [True: 12.4k, False: 0]
  ------------------
 3617|   172k|               (cur->type != XML_HTML_DOCUMENT_NODE) &&
  ------------------
  |  Branch (3617:16): [True: 12.4k, False: 0]
  ------------------
 3618|   172k|               (cur->type != XML_DTD_NODE) &&
  ------------------
  |  Branch (3618:16): [True: 12.4k, False: 0]
  ------------------
 3619|   172k|               (cur->type != XML_ENTITY_REF_NODE)) {
  ------------------
  |  Branch (3619:16): [True: 12.4k, False: 0]
  ------------------
 3620|  12.4k|            cur = cur->children;
 3621|  12.4k|            depth += 1;
 3622|  12.4k|        }
 3623|       |
 3624|   160k|        next = cur->next;
 3625|   160k|        parent = cur->parent;
 3626|   160k|	if ((cur->type == XML_DOCUMENT_NODE) ||
  ------------------
  |  Branch (3626:6): [True: 0, False: 160k]
  ------------------
 3627|   160k|            (cur->type == XML_HTML_DOCUMENT_NODE)) {
  ------------------
  |  Branch (3627:13): [True: 0, False: 160k]
  ------------------
 3628|      0|            xmlFreeDoc((xmlDocPtr) cur);
 3629|   160k|        } else if (cur->type != XML_DTD_NODE) {
  ------------------
  |  Branch (3629:20): [True: 160k, False: 0]
  ------------------
 3630|       |
 3631|   160k|	    if ((__xmlRegisterCallbacks) && (xmlDeregisterNodeDefaultValue))
  ------------------
  |  |  684|      0|    XML_GLOBAL_MACRO(xmlDeregisterNodeDefaultValue)
  |  |  ------------------
  |  |  |  |  500|      0|  #define XML_GLOBAL_MACRO(name) (*__##name())
  |  |  ------------------
  ------------------
  |  Branch (3631:10): [True: 0, False: 160k]
  |  Branch (3631:38): [True: 0, False: 0]
  ------------------
 3632|      0|		xmlDeregisterNodeDefaultValue(cur);
  ------------------
  |  |  684|      0|    XML_GLOBAL_MACRO(xmlDeregisterNodeDefaultValue)
  |  |  ------------------
  |  |  |  |  500|      0|  #define XML_GLOBAL_MACRO(name) (*__##name())
  |  |  ------------------
  ------------------
 3633|       |
 3634|   160k|	    if (((cur->type == XML_ELEMENT_NODE) ||
  ------------------
  |  Branch (3634:11): [True: 43.1k, False: 117k]
  ------------------
 3635|   160k|		 (cur->type == XML_XINCLUDE_START) ||
  ------------------
  |  Branch (3635:4): [True: 0, False: 117k]
  ------------------
 3636|   160k|		 (cur->type == XML_XINCLUDE_END)) &&
  ------------------
  |  Branch (3636:4): [True: 0, False: 117k]
  ------------------
 3637|   160k|		(cur->properties != NULL))
  ------------------
  |  Branch (3637:3): [True: 34.6k, False: 8.51k]
  ------------------
 3638|  34.6k|		xmlFreePropList(cur->properties);
 3639|   160k|	    if ((cur->type != XML_ELEMENT_NODE) &&
  ------------------
  |  Branch (3639:10): [True: 117k, False: 43.1k]
  ------------------
 3640|   160k|		(cur->type != XML_XINCLUDE_START) &&
  ------------------
  |  Branch (3640:3): [True: 117k, False: 0]
  ------------------
 3641|   160k|		(cur->type != XML_XINCLUDE_END) &&
  ------------------
  |  Branch (3641:3): [True: 117k, False: 0]
  ------------------
 3642|   160k|		(cur->type != XML_ENTITY_REF_NODE) &&
  ------------------
  |  Branch (3642:3): [True: 117k, False: 3]
  ------------------
 3643|   160k|		(cur->content != (xmlChar *) &(cur->properties))) {
  ------------------
  |  Branch (3643:3): [True: 116k, False: 47]
  ------------------
 3644|   116k|		DICT_FREE(cur->content)
  ------------------
  |  | 1025|   116k|	if ((str) && ((!dict) ||				\
  |  |  ------------------
  |  |  |  Branch (1025:6): [True: 116k, False: 3]
  |  |  |  Branch (1025:16): [True: 0, False: 116k]
  |  |  ------------------
  |  | 1026|   116k|	    (xmlDictOwns(dict, (const xmlChar *)(str)) == 0)))	\
  |  |  ------------------
  |  |  |  Branch (1026:6): [True: 60.5k, False: 56.4k]
  |  |  ------------------
  |  | 1027|   116k|	    xmlFree((char *)(str));
  ------------------
 3645|   116k|	    }
 3646|   160k|	    if (((cur->type == XML_ELEMENT_NODE) ||
  ------------------
  |  Branch (3646:11): [True: 43.1k, False: 117k]
  ------------------
 3647|   160k|	         (cur->type == XML_XINCLUDE_START) ||
  ------------------
  |  Branch (3647:11): [True: 0, False: 117k]
  ------------------
 3648|   160k|		 (cur->type == XML_XINCLUDE_END)) &&
  ------------------
  |  Branch (3648:4): [True: 0, False: 117k]
  ------------------
 3649|   160k|		(cur->nsDef != NULL))
  ------------------
  |  Branch (3649:3): [True: 251, False: 42.9k]
  ------------------
 3650|    251|		xmlFreeNsList(cur->nsDef);
 3651|       |
 3652|       |	    /*
 3653|       |	     * When a node is a text node or a comment, it uses a global static
 3654|       |	     * variable for the name of the node.
 3655|       |	     * Otherwise the node name might come from the document's
 3656|       |	     * dictionary
 3657|       |	     */
 3658|   160k|	    if ((cur->name != NULL) &&
  ------------------
  |  Branch (3658:10): [True: 160k, False: 103]
  ------------------
 3659|   160k|		(cur->type != XML_TEXT_NODE) &&
  ------------------
  |  Branch (3659:3): [True: 43.7k, False: 116k]
  ------------------
 3660|   160k|		(cur->type != XML_COMMENT_NODE))
  ------------------
  |  Branch (3660:3): [True: 43.2k, False: 453]
  ------------------
 3661|  43.2k|		DICT_FREE(cur->name)
  ------------------
  |  | 1025|  43.2k|	if ((str) && ((!dict) ||				\
  |  |  ------------------
  |  |  |  Branch (1025:6): [True: 43.2k, False: 0]
  |  |  |  Branch (1025:16): [True: 0, False: 43.2k]
  |  |  ------------------
  |  | 1026|  43.2k|	    (xmlDictOwns(dict, (const xmlChar *)(str)) == 0)))	\
  |  |  ------------------
  |  |  |  Branch (1026:6): [True: 3, False: 43.2k]
  |  |  ------------------
  |  | 1027|  43.2k|	    xmlFree((char *)(str));
  ------------------
 3662|   160k|	    xmlFree(cur);
 3663|   160k|	}
 3664|       |
 3665|   160k|        if (next != NULL) {
  ------------------
  |  Branch (3665:13): [True: 82.4k, False: 77.7k]
  ------------------
 3666|  82.4k|	    cur = next;
 3667|  82.4k|        } else {
 3668|  77.7k|            if ((depth == 0) || (parent == NULL))
  ------------------
  |  Branch (3668:17): [True: 65.2k, False: 12.4k]
  |  Branch (3668:33): [True: 0, False: 12.4k]
  ------------------
 3669|  65.2k|                break;
 3670|  12.4k|            depth -= 1;
 3671|  12.4k|            cur = parent;
 3672|  12.4k|            cur->children = NULL;
 3673|  12.4k|        }
 3674|   160k|    }
 3675|  65.2k|}
xmlFreeNode:
 3685|   654k|xmlFreeNode(xmlNodePtr cur) {
 3686|   654k|    xmlDictPtr dict = NULL;
 3687|       |
 3688|   654k|    if (cur == NULL) return;
  ------------------
  |  Branch (3688:9): [True: 0, False: 654k]
  ------------------
 3689|       |
 3690|       |    /* use xmlFreeDtd for DTD nodes */
 3691|   654k|    if (cur->type == XML_DTD_NODE) {
  ------------------
  |  Branch (3691:9): [True: 0, False: 654k]
  ------------------
 3692|      0|	xmlFreeDtd((xmlDtdPtr) cur);
 3693|      0|	return;
 3694|      0|    }
 3695|   654k|    if (cur->type == XML_NAMESPACE_DECL) {
  ------------------
  |  Branch (3695:9): [True: 0, False: 654k]
  ------------------
 3696|      0|	xmlFreeNs((xmlNsPtr) cur);
 3697|      0|        return;
 3698|      0|    }
 3699|   654k|    if (cur->type == XML_ATTRIBUTE_NODE) {
  ------------------
  |  Branch (3699:9): [True: 0, False: 654k]
  ------------------
 3700|      0|	xmlFreeProp((xmlAttrPtr) cur);
 3701|      0|	return;
 3702|      0|    }
 3703|       |
 3704|   654k|    if ((__xmlRegisterCallbacks) && (xmlDeregisterNodeDefaultValue))
  ------------------
  |  |  684|      0|    XML_GLOBAL_MACRO(xmlDeregisterNodeDefaultValue)
  |  |  ------------------
  |  |  |  |  500|      0|  #define XML_GLOBAL_MACRO(name) (*__##name())
  |  |  ------------------
  ------------------
  |  Branch (3704:9): [True: 0, False: 654k]
  |  Branch (3704:37): [True: 0, False: 0]
  ------------------
 3705|      0|	xmlDeregisterNodeDefaultValue(cur);
  ------------------
  |  |  684|      0|    XML_GLOBAL_MACRO(xmlDeregisterNodeDefaultValue)
  |  |  ------------------
  |  |  |  |  500|      0|  #define XML_GLOBAL_MACRO(name) (*__##name())
  |  |  ------------------
  ------------------
 3706|       |
 3707|   654k|    if (cur->doc != NULL) dict = cur->doc->dict;
  ------------------
  |  Branch (3707:9): [True: 654k, False: 0]
  ------------------
 3708|       |
 3709|   654k|    if (cur->type == XML_ENTITY_DECL) {
  ------------------
  |  Branch (3709:9): [True: 0, False: 654k]
  ------------------
 3710|      0|        xmlEntityPtr ent = (xmlEntityPtr) cur;
 3711|      0|	DICT_FREE(ent->SystemID);
  ------------------
  |  | 1025|      0|	if ((str) && ((!dict) ||				\
  |  |  ------------------
  |  |  |  Branch (1025:6): [True: 0, False: 0]
  |  |  |  Branch (1025:16): [True: 0, False: 0]
  |  |  ------------------
  |  | 1026|      0|	    (xmlDictOwns(dict, (const xmlChar *)(str)) == 0)))	\
  |  |  ------------------
  |  |  |  Branch (1026:6): [True: 0, False: 0]
  |  |  ------------------
  |  | 1027|      0|	    xmlFree((char *)(str));
  ------------------
 3712|      0|	DICT_FREE(ent->ExternalID);
  ------------------
  |  | 1025|      0|	if ((str) && ((!dict) ||				\
  |  |  ------------------
  |  |  |  Branch (1025:6): [True: 0, False: 0]
  |  |  |  Branch (1025:16): [True: 0, False: 0]
  |  |  ------------------
  |  | 1026|      0|	    (xmlDictOwns(dict, (const xmlChar *)(str)) == 0)))	\
  |  |  ------------------
  |  |  |  Branch (1026:6): [True: 0, False: 0]
  |  |  ------------------
  |  | 1027|      0|	    xmlFree((char *)(str));
  ------------------
 3713|      0|    }
 3714|   654k|    if ((cur->children != NULL) &&
  ------------------
  |  Branch (3714:9): [True: 4, False: 654k]
  ------------------
 3715|   654k|	(cur->type != XML_ENTITY_REF_NODE))
  ------------------
  |  Branch (3715:2): [True: 4, False: 0]
  ------------------
 3716|      4|	xmlFreeNodeList(cur->children);
 3717|       |
 3718|   654k|    if ((cur->type == XML_ELEMENT_NODE) ||
  ------------------
  |  Branch (3718:9): [True: 432, False: 653k]
  ------------------
 3719|   654k|        (cur->type == XML_XINCLUDE_START) ||
  ------------------
  |  Branch (3719:9): [True: 0, False: 653k]
  ------------------
 3720|   654k|        (cur->type == XML_XINCLUDE_END)) {
  ------------------
  |  Branch (3720:9): [True: 0, False: 653k]
  ------------------
 3721|    432|        if (cur->properties != NULL)
  ------------------
  |  Branch (3721:13): [True: 0, False: 432]
  ------------------
 3722|      0|            xmlFreePropList(cur->properties);
 3723|    432|        if (cur->nsDef != NULL)
  ------------------
  |  Branch (3723:13): [True: 0, False: 432]
  ------------------
 3724|      0|            xmlFreeNsList(cur->nsDef);
 3725|   653k|    } else if ((cur->content != NULL) &&
  ------------------
  |  Branch (3725:16): [True: 653k, False: 1]
  ------------------
 3726|   653k|               (cur->type != XML_ENTITY_REF_NODE) &&
  ------------------
  |  Branch (3726:16): [True: 653k, False: 0]
  ------------------
 3727|   653k|               (cur->content != (xmlChar *) &(cur->properties))) {
  ------------------
  |  Branch (3727:16): [True: 653k, False: 2]
  ------------------
 3728|   653k|        DICT_FREE(cur->content)
  ------------------
  |  | 1025|   653k|	if ((str) && ((!dict) ||				\
  |  |  ------------------
  |  |  |  Branch (1025:6): [True: 653k, False: 0]
  |  |  |  Branch (1025:16): [True: 0, False: 653k]
  |  |  ------------------
  |  | 1026|   653k|	    (xmlDictOwns(dict, (const xmlChar *)(str)) == 0)))	\
  |  |  ------------------
  |  |  |  Branch (1026:6): [True: 653k, False: 6]
  |  |  ------------------
  |  | 1027|   653k|	    xmlFree((char *)(str));
  ------------------
 3729|   653k|    }
 3730|       |
 3731|       |    /*
 3732|       |     * When a node is a text node or a comment, it uses a global static
 3733|       |     * variable for the name of the node.
 3734|       |     * Otherwise the node name might come from the document's dictionary
 3735|       |     */
 3736|   654k|    if ((cur->name != NULL) &&
  ------------------
  |  Branch (3736:9): [True: 654k, False: 0]
  ------------------
 3737|   654k|        (cur->type != XML_TEXT_NODE) &&
  ------------------
  |  Branch (3737:9): [True: 643k, False: 10.8k]
  ------------------
 3738|   654k|        (cur->type != XML_COMMENT_NODE))
  ------------------
  |  Branch (3738:9): [True: 432, False: 642k]
  ------------------
 3739|    432|	DICT_FREE(cur->name)
  ------------------
  |  | 1025|    432|	if ((str) && ((!dict) ||				\
  |  |  ------------------
  |  |  |  Branch (1025:6): [True: 432, False: 0]
  |  |  |  Branch (1025:16): [True: 0, False: 432]
  |  |  ------------------
  |  | 1026|    432|	    (xmlDictOwns(dict, (const xmlChar *)(str)) == 0)))	\
  |  |  ------------------
  |  |  |  Branch (1026:6): [True: 0, False: 432]
  |  |  ------------------
  |  | 1027|    432|	    xmlFree((char *)(str));
  ------------------
 3740|       |
 3741|   654k|    xmlFree(cur);
 3742|   654k|}
xmlUnlinkNode:
 3755|   686k|xmlUnlinkNode(xmlNodePtr cur) {
 3756|   686k|    if (cur == NULL) {
  ------------------
  |  Branch (3756:9): [True: 0, False: 686k]
  ------------------
 3757|      0|	return;
 3758|      0|    }
 3759|   686k|    if (cur->type == XML_NAMESPACE_DECL)
  ------------------
  |  Branch (3759:9): [True: 0, False: 686k]
  ------------------
 3760|      0|        return;
 3761|   686k|    if (cur->type == XML_DTD_NODE) {
  ------------------
  |  Branch (3761:9): [True: 844, False: 685k]
  ------------------
 3762|    844|	xmlDocPtr doc;
 3763|    844|	doc = cur->doc;
 3764|    844|	if (doc != NULL) {
  ------------------
  |  Branch (3764:6): [True: 844, False: 0]
  ------------------
 3765|    844|	    if (doc->intSubset == (xmlDtdPtr) cur)
  ------------------
  |  Branch (3765:10): [True: 760, False: 84]
  ------------------
 3766|    760|		doc->intSubset = NULL;
 3767|    844|	    if (doc->extSubset == (xmlDtdPtr) cur)
  ------------------
  |  Branch (3767:10): [True: 84, False: 760]
  ------------------
 3768|     84|		doc->extSubset = NULL;
 3769|    844|	}
 3770|    844|    }
 3771|   686k|    if (cur->type == XML_ENTITY_DECL) {
  ------------------
  |  Branch (3771:9): [True: 0, False: 686k]
  ------------------
 3772|      0|        xmlDocPtr doc;
 3773|      0|	doc = cur->doc;
 3774|      0|	if (doc != NULL) {
  ------------------
  |  Branch (3774:6): [True: 0, False: 0]
  ------------------
 3775|      0|	    if (doc->intSubset != NULL) {
  ------------------
  |  Branch (3775:10): [True: 0, False: 0]
  ------------------
 3776|      0|	        if (xmlHashLookup(doc->intSubset->entities, cur->name) == cur)
  ------------------
  |  Branch (3776:14): [True: 0, False: 0]
  ------------------
 3777|      0|		    xmlHashRemoveEntry(doc->intSubset->entities, cur->name,
 3778|      0|		                       NULL);
 3779|      0|	        if (xmlHashLookup(doc->intSubset->pentities, cur->name) == cur)
  ------------------
  |  Branch (3779:14): [True: 0, False: 0]
  ------------------
 3780|      0|		    xmlHashRemoveEntry(doc->intSubset->pentities, cur->name,
 3781|      0|		                       NULL);
 3782|      0|	    }
 3783|      0|	    if (doc->extSubset != NULL) {
  ------------------
  |  Branch (3783:10): [True: 0, False: 0]
  ------------------
 3784|      0|	        if (xmlHashLookup(doc->extSubset->entities, cur->name) == cur)
  ------------------
  |  Branch (3784:14): [True: 0, False: 0]
  ------------------
 3785|      0|		    xmlHashRemoveEntry(doc->extSubset->entities, cur->name,
 3786|      0|		                       NULL);
 3787|      0|	        if (xmlHashLookup(doc->extSubset->pentities, cur->name) == cur)
  ------------------
  |  Branch (3787:14): [True: 0, False: 0]
  ------------------
 3788|      0|		    xmlHashRemoveEntry(doc->extSubset->pentities, cur->name,
 3789|      0|		                       NULL);
 3790|      0|	    }
 3791|      0|	}
 3792|      0|    }
 3793|   686k|    if (cur->parent != NULL) {
  ------------------
  |  Branch (3793:9): [True: 686k, False: 116]
  ------------------
 3794|   686k|	xmlNodePtr parent;
 3795|   686k|	parent = cur->parent;
 3796|   686k|	if (cur->type == XML_ATTRIBUTE_NODE) {
  ------------------
  |  Branch (3796:6): [True: 0, False: 686k]
  ------------------
 3797|      0|	    if (parent->properties == (xmlAttrPtr) cur)
  ------------------
  |  Branch (3797:10): [True: 0, False: 0]
  ------------------
 3798|      0|		parent->properties = ((xmlAttrPtr) cur)->next;
 3799|   686k|	} else {
 3800|   686k|	    if (parent->children == cur)
  ------------------
  |  Branch (3800:10): [True: 33.3k, False: 652k]
  ------------------
 3801|  33.3k|		parent->children = cur->next;
 3802|   686k|	    if (parent->last == cur)
  ------------------
  |  Branch (3802:10): [True: 5.35k, False: 680k]
  ------------------
 3803|  5.35k|		parent->last = cur->prev;
 3804|   686k|	}
 3805|   686k|	cur->parent = NULL;
 3806|   686k|    }
 3807|   686k|    if (cur->next != NULL)
  ------------------
  |  Branch (3807:9): [True: 680k, False: 5.47k]
  ------------------
 3808|   680k|        cur->next->prev = cur->prev;
 3809|   686k|    if (cur->prev != NULL)
  ------------------
  |  Branch (3809:9): [True: 652k, False: 33.4k]
  ------------------
 3810|   652k|        cur->prev->next = cur->next;
 3811|   686k|    cur->next = cur->prev = NULL;
 3812|   686k|}
xmlCopyNamespace:
 3889|     16|xmlCopyNamespace(xmlNsPtr cur) {
 3890|     16|    xmlNsPtr ret;
 3891|       |
 3892|     16|    if (cur == NULL) return(NULL);
  ------------------
  |  Branch (3892:9): [True: 0, False: 16]
  ------------------
 3893|     16|    switch (cur->type) {
 3894|     16|	case XML_LOCAL_NAMESPACE:
  ------------------
  |  |  370|     16|#define XML_LOCAL_NAMESPACE XML_NAMESPACE_DECL
  ------------------
  |  Branch (3894:2): [True: 16, False: 0]
  ------------------
 3895|     16|	    ret = xmlNewNs(NULL, cur->href, cur->prefix);
 3896|     16|	    break;
 3897|      0|	default:
  ------------------
  |  Branch (3897:2): [True: 0, False: 16]
  ------------------
 3898|      0|	    return(NULL);
 3899|     16|    }
 3900|     16|    return(ret);
 3901|     16|}
xmlCopyNamespaceList:
 3912|     16|xmlCopyNamespaceList(xmlNsPtr cur) {
 3913|     16|    xmlNsPtr ret = NULL;
 3914|     16|    xmlNsPtr p = NULL,q;
 3915|       |
 3916|     32|    while (cur != NULL) {
  ------------------
  |  Branch (3916:12): [True: 16, False: 16]
  ------------------
 3917|     16|        q = xmlCopyNamespace(cur);
 3918|     16|        if (q == NULL) {
  ------------------
  |  Branch (3918:13): [True: 0, False: 16]
  ------------------
 3919|      0|            xmlFreeNsList(ret);
 3920|      0|            return(NULL);
 3921|      0|        }
 3922|     16|	if (p == NULL) {
  ------------------
  |  Branch (3922:6): [True: 16, False: 0]
  ------------------
 3923|     16|	    ret = p = q;
 3924|     16|	} else {
 3925|      0|	    p->next = q;
 3926|      0|	    p = q;
 3927|      0|	}
 3928|     16|	cur = cur->next;
 3929|     16|    }
 3930|     16|    return(ret);
 3931|     16|}
xmlCopyProp:
 4041|     12|xmlCopyProp(xmlNodePtr target, xmlAttrPtr cur) {
 4042|     12|	return xmlCopyPropInternal(NULL, target, cur);
 4043|     12|}
xmlCopyPropList:
 4055|     12|xmlCopyPropList(xmlNodePtr target, xmlAttrPtr cur) {
 4056|     12|    xmlAttrPtr ret = NULL;
 4057|     12|    xmlAttrPtr p = NULL,q;
 4058|       |
 4059|     12|    if ((target != NULL) && (target->type != XML_ELEMENT_NODE))
  ------------------
  |  Branch (4059:9): [True: 12, False: 0]
  |  Branch (4059:29): [True: 0, False: 12]
  ------------------
 4060|      0|        return(NULL);
 4061|     24|    while (cur != NULL) {
  ------------------
  |  Branch (4061:12): [True: 12, False: 12]
  ------------------
 4062|     12|        q = xmlCopyProp(target, cur);
 4063|     12|	if (q == NULL) {
  ------------------
  |  Branch (4063:6): [True: 0, False: 12]
  ------------------
 4064|      0|            xmlFreePropList(ret);
 4065|      0|	    return(NULL);
 4066|      0|        }
 4067|     12|	if (p == NULL) {
  ------------------
  |  Branch (4067:6): [True: 12, False: 0]
  ------------------
 4068|     12|	    ret = p = q;
 4069|     12|	} else {
 4070|      0|	    p->next = q;
 4071|      0|	    q->prev = p;
 4072|      0|	    p = q;
 4073|      0|	}
 4074|     12|	cur = cur->next;
 4075|     12|    }
 4076|     12|    return(ret);
 4077|     12|}
xmlStaticCopyNode:
 4100|  11.3k|                  int extended) {
 4101|  11.3k|    xmlNodePtr ret;
 4102|       |
 4103|  11.3k|    if (node == NULL) return(NULL);
  ------------------
  |  Branch (4103:9): [True: 0, False: 11.3k]
  ------------------
 4104|  11.3k|    switch (node->type) {
  ------------------
  |  Branch (4104:13): [True: 0, False: 11.3k]
  ------------------
 4105|  11.1k|        case XML_TEXT_NODE:
  ------------------
  |  Branch (4105:9): [True: 11.1k, False: 200]
  ------------------
 4106|  11.1k|        case XML_CDATA_SECTION_NODE:
  ------------------
  |  Branch (4106:9): [True: 4, False: 11.3k]
  ------------------
 4107|  11.3k|        case XML_ELEMENT_NODE:
  ------------------
  |  Branch (4107:9): [True: 196, False: 11.1k]
  ------------------
 4108|  11.3k|        case XML_DOCUMENT_FRAG_NODE:
  ------------------
  |  Branch (4108:9): [True: 0, False: 11.3k]
  ------------------
 4109|  11.3k|        case XML_ENTITY_REF_NODE:
  ------------------
  |  Branch (4109:9): [True: 0, False: 11.3k]
  ------------------
 4110|  11.3k|        case XML_ENTITY_NODE:
  ------------------
  |  Branch (4110:9): [True: 0, False: 11.3k]
  ------------------
 4111|  11.3k|        case XML_PI_NODE:
  ------------------
  |  Branch (4111:9): [True: 0, False: 11.3k]
  ------------------
 4112|  11.3k|        case XML_COMMENT_NODE:
  ------------------
  |  Branch (4112:9): [True: 0, False: 11.3k]
  ------------------
 4113|  11.3k|        case XML_XINCLUDE_START:
  ------------------
  |  Branch (4113:9): [True: 0, False: 11.3k]
  ------------------
 4114|  11.3k|        case XML_XINCLUDE_END:
  ------------------
  |  Branch (4114:9): [True: 0, False: 11.3k]
  ------------------
 4115|  11.3k|	    break;
 4116|      0|        case XML_ATTRIBUTE_NODE:
  ------------------
  |  Branch (4116:9): [True: 0, False: 11.3k]
  ------------------
 4117|      0|		return((xmlNodePtr) xmlCopyPropInternal(doc, parent, (xmlAttrPtr) node));
 4118|      0|        case XML_NAMESPACE_DECL:
  ------------------
  |  Branch (4118:9): [True: 0, False: 11.3k]
  ------------------
 4119|      0|	    return((xmlNodePtr) xmlCopyNamespaceList((xmlNsPtr) node));
 4120|       |
 4121|      0|        case XML_DOCUMENT_NODE:
  ------------------
  |  Branch (4121:9): [True: 0, False: 11.3k]
  ------------------
 4122|      0|        case XML_HTML_DOCUMENT_NODE:
  ------------------
  |  Branch (4122:9): [True: 0, False: 11.3k]
  ------------------
 4123|      0|#ifdef LIBXML_TREE_ENABLED
 4124|      0|	    return((xmlNodePtr) xmlCopyDoc((xmlDocPtr) node, extended));
 4125|      0|#endif /* LIBXML_TREE_ENABLED */
 4126|      0|        case XML_DOCUMENT_TYPE_NODE:
  ------------------
  |  Branch (4126:9): [True: 0, False: 11.3k]
  ------------------
 4127|      0|        case XML_NOTATION_NODE:
  ------------------
  |  Branch (4127:9): [True: 0, False: 11.3k]
  ------------------
 4128|      0|        case XML_DTD_NODE:
  ------------------
  |  Branch (4128:9): [True: 0, False: 11.3k]
  ------------------
 4129|      0|        case XML_ELEMENT_DECL:
  ------------------
  |  Branch (4129:9): [True: 0, False: 11.3k]
  ------------------
 4130|      0|        case XML_ATTRIBUTE_DECL:
  ------------------
  |  Branch (4130:9): [True: 0, False: 11.3k]
  ------------------
 4131|      0|        case XML_ENTITY_DECL:
  ------------------
  |  Branch (4131:9): [True: 0, False: 11.3k]
  ------------------
 4132|      0|            return(NULL);
 4133|  11.3k|    }
 4134|       |
 4135|       |    /*
 4136|       |     * Allocate a new node and fill the fields.
 4137|       |     */
 4138|  11.3k|    ret = (xmlNodePtr) xmlMalloc(sizeof(xmlNode));
 4139|  11.3k|    if (ret == NULL) {
  ------------------
  |  Branch (4139:9): [True: 0, False: 11.3k]
  ------------------
 4140|      0|	xmlTreeErrMemory("copying node");
 4141|      0|	return(NULL);
 4142|      0|    }
 4143|  11.3k|    memset(ret, 0, sizeof(xmlNode));
 4144|  11.3k|    ret->type = node->type;
 4145|       |
 4146|  11.3k|    ret->doc = doc;
 4147|  11.3k|    ret->parent = parent;
 4148|  11.3k|    if (node->name == xmlStringText)
  ------------------
  |  Branch (4148:9): [True: 11.1k, False: 200]
  ------------------
 4149|  11.1k|	ret->name = xmlStringText;
 4150|    200|    else if (node->name == xmlStringTextNoenc)
  ------------------
  |  Branch (4150:14): [True: 0, False: 200]
  ------------------
 4151|      0|	ret->name = xmlStringTextNoenc;
 4152|    200|    else if (node->name == xmlStringComment)
  ------------------
  |  Branch (4152:14): [True: 0, False: 200]
  ------------------
 4153|      0|	ret->name = xmlStringComment;
 4154|    200|    else if (node->name != NULL) {
  ------------------
  |  Branch (4154:14): [True: 196, False: 4]
  ------------------
 4155|    196|        if ((doc != NULL) && (doc->dict != NULL))
  ------------------
  |  Branch (4155:13): [True: 196, False: 0]
  |  Branch (4155:30): [True: 196, False: 0]
  ------------------
 4156|    196|	    ret->name = xmlDictLookup(doc->dict, node->name, -1);
 4157|      0|	else
 4158|      0|	    ret->name = xmlStrdup(node->name);
 4159|    196|    }
 4160|  11.3k|    if ((node->type != XML_ELEMENT_NODE) &&
  ------------------
  |  Branch (4160:9): [True: 11.1k, False: 196]
  ------------------
 4161|  11.3k|	(node->content != NULL) &&
  ------------------
  |  Branch (4161:2): [True: 11.1k, False: 0]
  ------------------
 4162|  11.3k|	(node->type != XML_ENTITY_REF_NODE) &&
  ------------------
  |  Branch (4162:2): [True: 11.1k, False: 0]
  ------------------
 4163|  11.3k|	(node->type != XML_XINCLUDE_END) &&
  ------------------
  |  Branch (4163:2): [True: 11.1k, False: 0]
  ------------------
 4164|  11.3k|	(node->type != XML_XINCLUDE_START)) {
  ------------------
  |  Branch (4164:2): [True: 11.1k, False: 0]
  ------------------
 4165|  11.1k|	ret->content = xmlStrdup(node->content);
 4166|  11.1k|    }else{
 4167|    196|      if (node->type == XML_ELEMENT_NODE)
  ------------------
  |  Branch (4167:11): [True: 196, False: 0]
  ------------------
 4168|    196|        ret->line = node->line;
 4169|    196|    }
 4170|  11.3k|    if (parent != NULL) {
  ------------------
  |  Branch (4170:9): [True: 124, False: 11.2k]
  ------------------
 4171|    124|	xmlNodePtr tmp;
 4172|       |
 4173|       |	/*
 4174|       |	 * this is a tricky part for the node register thing:
 4175|       |	 * in case ret does get coalesced in xmlAddChild
 4176|       |	 * the deregister-node callback is called; so we register ret now already
 4177|       |	 */
 4178|    124|	if ((__xmlRegisterCallbacks) && (xmlRegisterNodeDefaultValue))
  ------------------
  |  |  682|      0|    XML_GLOBAL_MACRO(xmlRegisterNodeDefaultValue)
  |  |  ------------------
  |  |  |  |  500|      0|  #define XML_GLOBAL_MACRO(name) (*__##name())
  |  |  ------------------
  ------------------
  |  Branch (4178:6): [True: 0, False: 124]
  |  Branch (4178:34): [True: 0, False: 0]
  ------------------
 4179|      0|	    xmlRegisterNodeDefaultValue((xmlNodePtr)ret);
  ------------------
  |  |  682|      0|    XML_GLOBAL_MACRO(xmlRegisterNodeDefaultValue)
  |  |  ------------------
  |  |  |  |  500|      0|  #define XML_GLOBAL_MACRO(name) (*__##name())
  |  |  ------------------
  ------------------
 4180|       |
 4181|       |        /*
 4182|       |         * Note that since ret->parent is already set, xmlAddChild will
 4183|       |         * return early and not actually insert the node. It will only
 4184|       |         * coalesce text nodes and unnecessarily call xmlSetTreeDoc.
 4185|       |         * Assuming that the subtree to be copied always has its text
 4186|       |         * nodes coalesced, the somewhat confusing call to xmlAddChild
 4187|       |         * could be removed.
 4188|       |         */
 4189|    124|        tmp = xmlAddChild(parent, ret);
 4190|       |	/* node could have coalesced */
 4191|    124|	if (tmp != ret)
  ------------------
  |  Branch (4191:6): [True: 0, False: 124]
  ------------------
 4192|      0|	    return(tmp);
 4193|    124|    }
 4194|       |
 4195|  11.3k|    if (!extended)
  ------------------
  |  Branch (4195:9): [True: 0, False: 11.3k]
  ------------------
 4196|      0|	goto out;
 4197|  11.3k|    if (((node->type == XML_ELEMENT_NODE) ||
  ------------------
  |  Branch (4197:10): [True: 196, False: 11.1k]
  ------------------
 4198|  11.3k|         (node->type == XML_XINCLUDE_START)) && (node->nsDef != NULL))
  ------------------
  |  Branch (4198:10): [True: 0, False: 11.1k]
  |  Branch (4198:49): [True: 16, False: 180]
  ------------------
 4199|     16|        ret->nsDef = xmlCopyNamespaceList(node->nsDef);
 4200|       |
 4201|  11.3k|    if (node->ns != NULL) {
  ------------------
  |  Branch (4201:9): [True: 0, False: 11.3k]
  ------------------
 4202|      0|        xmlNsPtr ns;
 4203|       |
 4204|      0|	ns = xmlSearchNs(doc, ret, node->ns->prefix);
 4205|      0|	if (ns == NULL) {
  ------------------
  |  Branch (4205:6): [True: 0, False: 0]
  ------------------
 4206|       |	    /*
 4207|       |	     * Humm, we are copying an element whose namespace is defined
 4208|       |	     * out of the new tree scope. Search it in the original tree
 4209|       |	     * and add it at the top of the new tree.
 4210|       |             *
 4211|       |             * TODO: Searching the original tree seems unnecessary. We
 4212|       |             * already have a namespace URI.
 4213|       |	     */
 4214|      0|	    ns = xmlSearchNs(node->doc, node, node->ns->prefix);
 4215|      0|	    if (ns != NULL) {
  ------------------
  |  Branch (4215:10): [True: 0, False: 0]
  ------------------
 4216|      0|	        xmlNodePtr root = ret;
 4217|       |
 4218|      0|		while (root->parent != NULL) root = root->parent;
  ------------------
  |  Branch (4218:10): [True: 0, False: 0]
  ------------------
 4219|      0|		ret->ns = xmlNewNs(root, ns->href, ns->prefix);
 4220|      0|            } else {
 4221|      0|                ret->ns = xmlNewReconciledNs(doc, ret, node->ns);
 4222|      0|	    }
 4223|      0|	} else {
 4224|       |	    /*
 4225|       |	     * reference the existing namespace definition in our own tree.
 4226|       |	     */
 4227|      0|	    ret->ns = ns;
 4228|      0|	}
 4229|      0|    }
 4230|  11.3k|    if (((node->type == XML_ELEMENT_NODE) ||
  ------------------
  |  Branch (4230:10): [True: 196, False: 11.1k]
  ------------------
 4231|  11.3k|         (node->type == XML_XINCLUDE_START)) && (node->properties != NULL))
  ------------------
  |  Branch (4231:10): [True: 0, False: 11.1k]
  |  Branch (4231:49): [True: 12, False: 184]
  ------------------
 4232|     12|        ret->properties = xmlCopyPropList(ret, node->properties);
 4233|  11.3k|    if (node->type == XML_ENTITY_REF_NODE) {
  ------------------
  |  Branch (4233:9): [True: 0, False: 11.3k]
  ------------------
 4234|      0|	if ((doc == NULL) || (node->doc != doc)) {
  ------------------
  |  Branch (4234:6): [True: 0, False: 0]
  |  Branch (4234:23): [True: 0, False: 0]
  ------------------
 4235|       |	    /*
 4236|       |	     * The copied node will go into a separate document, so
 4237|       |	     * to avoid dangling references to the ENTITY_DECL node
 4238|       |	     * we cannot keep the reference. Try to find it in the
 4239|       |	     * target document.
 4240|       |	     */
 4241|      0|	    ret->children = (xmlNodePtr) xmlGetDocEntity(doc, ret->name);
 4242|      0|	} else {
 4243|      0|            ret->children = node->children;
 4244|      0|	}
 4245|      0|	ret->last = ret->children;
 4246|  11.3k|    } else if ((node->children != NULL) && (extended != 2)) {
  ------------------
  |  Branch (4246:16): [True: 112, False: 11.2k]
  |  Branch (4246:44): [True: 112, False: 0]
  ------------------
 4247|    112|        xmlNodePtr cur, insert;
 4248|       |
 4249|    112|        cur = node->children;
 4250|    112|        insert = ret;
 4251|    224|        while (cur != NULL) {
  ------------------
  |  Branch (4251:16): [True: 112, False: 112]
  ------------------
 4252|    112|            xmlNodePtr copy = xmlStaticCopyNode(cur, doc, insert, 2);
 4253|    112|            if (copy == NULL) {
  ------------------
  |  Branch (4253:17): [True: 0, False: 112]
  ------------------
 4254|      0|                xmlFreeNode(ret);
 4255|      0|                return(NULL);
 4256|      0|            }
 4257|       |
 4258|       |            /* Check for coalesced text nodes */
 4259|    112|            if (insert->last != copy) {
  ------------------
  |  Branch (4259:17): [True: 112, False: 0]
  ------------------
 4260|    112|                if (insert->last == NULL) {
  ------------------
  |  Branch (4260:21): [True: 112, False: 0]
  ------------------
 4261|    112|                    insert->children = copy;
 4262|    112|                } else {
 4263|      0|                    copy->prev = insert->last;
 4264|      0|                    insert->last->next = copy;
 4265|      0|                }
 4266|    112|                insert->last = copy;
 4267|    112|            }
 4268|       |
 4269|    112|            if ((cur->type != XML_ENTITY_REF_NODE) &&
  ------------------
  |  Branch (4269:17): [True: 112, False: 0]
  ------------------
 4270|    112|                (cur->children != NULL)) {
  ------------------
  |  Branch (4270:17): [True: 0, False: 112]
  ------------------
 4271|      0|                cur = cur->children;
 4272|      0|                insert = copy;
 4273|      0|                continue;
 4274|      0|            }
 4275|       |
 4276|    112|            while (1) {
  ------------------
  |  Branch (4276:20): [Folded - Ignored]
  ------------------
 4277|    112|                if (cur->next != NULL) {
  ------------------
  |  Branch (4277:21): [True: 0, False: 112]
  ------------------
 4278|      0|                    cur = cur->next;
 4279|      0|                    break;
 4280|      0|                }
 4281|       |
 4282|    112|                cur = cur->parent;
 4283|    112|                insert = insert->parent;
 4284|    112|                if (cur == node) {
  ------------------
  |  Branch (4284:21): [True: 112, False: 0]
  ------------------
 4285|    112|                    cur = NULL;
 4286|    112|                    break;
 4287|    112|                }
 4288|    112|            }
 4289|    112|        }
 4290|    112|    }
 4291|       |
 4292|  11.3k|out:
 4293|       |    /* if parent != NULL we already registered the node above */
 4294|  11.3k|    if ((parent == NULL) &&
  ------------------
  |  Branch (4294:9): [True: 11.2k, False: 124]
  ------------------
 4295|  11.3k|        ((__xmlRegisterCallbacks) && (xmlRegisterNodeDefaultValue)))
  ------------------
  |  |  682|      0|    XML_GLOBAL_MACRO(xmlRegisterNodeDefaultValue)
  |  |  ------------------
  |  |  |  |  500|      0|  #define XML_GLOBAL_MACRO(name) (*__##name())
  |  |  ------------------
  ------------------
  |  Branch (4295:10): [True: 0, False: 11.2k]
  |  Branch (4295:38): [True: 0, False: 0]
  ------------------
 4296|      0|	xmlRegisterNodeDefaultValue((xmlNodePtr)ret);
  ------------------
  |  |  682|      0|    XML_GLOBAL_MACRO(xmlRegisterNodeDefaultValue)
  |  |  ------------------
  |  |  |  |  500|      0|  #define XML_GLOBAL_MACRO(name) (*__##name())
  |  |  ------------------
  ------------------
 4297|  11.3k|    return(ret);
 4298|  11.3k|}
xmlStaticCopyNodeList:
 4301|     12|xmlStaticCopyNodeList(xmlNodePtr node, xmlDocPtr doc, xmlNodePtr parent) {
 4302|     12|    xmlNodePtr ret = NULL;
 4303|     12|    xmlNodePtr p = NULL,q;
 4304|     12|    xmlDtdPtr newSubset = NULL;
 4305|       |
 4306|     24|    while (node != NULL) {
  ------------------
  |  Branch (4306:12): [True: 12, False: 12]
  ------------------
 4307|     12|	if (node->type == XML_DTD_NODE ) {
  ------------------
  |  Branch (4307:6): [True: 0, False: 12]
  ------------------
 4308|      0|#ifdef LIBXML_TREE_ENABLED
 4309|      0|	    if ((doc == NULL) || (doc->intSubset != NULL)) {
  ------------------
  |  Branch (4309:10): [True: 0, False: 0]
  |  Branch (4309:27): [True: 0, False: 0]
  ------------------
 4310|      0|		node = node->next;
 4311|      0|		continue;
 4312|      0|	    }
 4313|      0|            q = (xmlNodePtr) xmlCopyDtd( (xmlDtdPtr) node );
 4314|      0|            if (q == NULL) goto error;
  ------------------
  |  Branch (4314:17): [True: 0, False: 0]
  ------------------
 4315|      0|            q->doc = doc;
 4316|      0|            q->parent = parent;
 4317|      0|            newSubset = (xmlDtdPtr) q;
 4318|       |#else
 4319|       |            node = node->next;
 4320|       |            continue;
 4321|       |#endif /* LIBXML_TREE_ENABLED */
 4322|     12|	} else {
 4323|     12|	    q = xmlStaticCopyNode(node, doc, parent, 1);
 4324|     12|	    if (q == NULL) goto error;
  ------------------
  |  Branch (4324:10): [True: 0, False: 12]
  ------------------
 4325|     12|        }
 4326|     12|	if (ret == NULL) {
  ------------------
  |  Branch (4326:6): [True: 12, False: 0]
  ------------------
 4327|     12|	    q->prev = NULL;
 4328|     12|	    ret = p = q;
 4329|     12|	} else if (p != q) {
  ------------------
  |  Branch (4329:13): [True: 0, False: 0]
  ------------------
 4330|       |	/* the test is required if xmlStaticCopyNode coalesced 2 text nodes */
 4331|      0|	    p->next = q;
 4332|      0|	    q->prev = p;
 4333|      0|	    p = q;
 4334|      0|	}
 4335|     12|	node = node->next;
 4336|     12|    }
 4337|     12|    if (newSubset != NULL)
  ------------------
  |  Branch (4337:9): [True: 0, False: 12]
  ------------------
 4338|      0|        doc->intSubset = newSubset;
 4339|     12|    return(ret);
 4340|      0|error:
 4341|      0|    xmlFreeNodeList(ret);
 4342|      0|    return(NULL);
 4343|     12|}
xmlDocCopyNode:
 4377|  11.2k|xmlDocCopyNode(xmlNodePtr node, xmlDocPtr doc, int extended) {
 4378|  11.2k|    xmlNodePtr ret;
 4379|       |
 4380|  11.2k|    ret = xmlStaticCopyNode(node, doc, NULL, extended);
 4381|  11.2k|    return(ret);
 4382|  11.2k|}
xmlGetLineNo:
 4629|  4.99k|{
 4630|  4.99k|    return(xmlGetLineNoInternal(node, 0));
 4631|  4.99k|}
xmlDocGetRootElement:
 4892|    620|xmlDocGetRootElement(const xmlDoc *doc) {
 4893|    620|    xmlNodePtr ret;
 4894|       |
 4895|    620|    if (doc == NULL) return(NULL);
  ------------------
  |  Branch (4895:9): [True: 0, False: 620]
  ------------------
 4896|    620|    ret = doc->children;
 4897|  1.30k|    while (ret != NULL) {
  ------------------
  |  Branch (4897:12): [True: 1.30k, False: 0]
  ------------------
 4898|  1.30k|	if (ret->type == XML_ELEMENT_NODE)
  ------------------
  |  Branch (4898:6): [True: 620, False: 686]
  ------------------
 4899|    620|	    return(ret);
 4900|    686|        ret = ret->next;
 4901|    686|    }
 4902|      0|    return(ret);
 4903|    620|}
xmlNodeGetSpacePreserve:
 5081|  13.7k|xmlNodeGetSpacePreserve(const xmlNode *cur) {
 5082|  13.7k|    xmlChar *space;
 5083|       |
 5084|  13.7k|    if ((cur == NULL) || (cur->type != XML_ELEMENT_NODE))
  ------------------
  |  Branch (5084:9): [True: 0, False: 13.7k]
  |  Branch (5084:26): [True: 13.7k, False: 0]
  ------------------
 5085|  13.7k|        return(-1);
 5086|      0|    while (cur != NULL) {
  ------------------
  |  Branch (5086:12): [True: 0, False: 0]
  ------------------
 5087|      0|	space = xmlGetNsProp(cur, BAD_CAST "space", XML_XML_NAMESPACE);
  ------------------
  |  |   35|      0|#define BAD_CAST (xmlChar *)
  ------------------
              	space = xmlGetNsProp(cur, BAD_CAST "space", XML_XML_NAMESPACE);
  ------------------
  |  |  143|      0|    (const xmlChar *) "http://www.w3.org/XML/1998/namespace"
  ------------------
 5088|      0|	if (space != NULL) {
  ------------------
  |  Branch (5088:6): [True: 0, False: 0]
  ------------------
 5089|      0|	    if (xmlStrEqual(space, BAD_CAST "preserve")) {
  ------------------
  |  |   35|      0|#define BAD_CAST (xmlChar *)
  ------------------
  |  Branch (5089:10): [True: 0, False: 0]
  ------------------
 5090|      0|		xmlFree(space);
 5091|      0|		return(1);
 5092|      0|	    }
 5093|      0|	    if (xmlStrEqual(space, BAD_CAST "default")) {
  ------------------
  |  |   35|      0|#define BAD_CAST (xmlChar *)
  ------------------
  |  Branch (5093:10): [True: 0, False: 0]
  ------------------
 5094|      0|		xmlFree(space);
 5095|      0|		return(0);
 5096|      0|	    }
 5097|      0|	    xmlFree(space);
 5098|      0|	}
 5099|      0|	cur = cur->parent;
 5100|      0|    }
 5101|      0|    return(-1);
 5102|      0|}
xmlNodeAddContentLen:
 5736|  10.8k|xmlNodeAddContentLen(xmlNodePtr cur, const xmlChar *content, int len) {
 5737|  10.8k|    if (cur == NULL) {
  ------------------
  |  Branch (5737:9): [True: 0, False: 10.8k]
  ------------------
 5738|      0|	return;
 5739|      0|    }
 5740|  10.8k|    if (len <= 0) return;
  ------------------
  |  Branch (5740:9): [True: 0, False: 10.8k]
  ------------------
 5741|  10.8k|    switch (cur->type) {
  ------------------
  |  Branch (5741:13): [True: 0, False: 10.8k]
  ------------------
 5742|      0|        case XML_DOCUMENT_FRAG_NODE:
  ------------------
  |  Branch (5742:9): [True: 0, False: 10.8k]
  ------------------
 5743|      0|        case XML_ELEMENT_NODE: {
  ------------------
  |  Branch (5743:9): [True: 0, False: 10.8k]
  ------------------
 5744|      0|	    xmlNodePtr last, newNode, tmp;
 5745|       |
 5746|      0|	    last = cur->last;
 5747|      0|	    newNode = xmlNewDocTextLen(cur->doc, content, len);
 5748|      0|	    if (newNode != NULL) {
  ------------------
  |  Branch (5748:10): [True: 0, False: 0]
  ------------------
 5749|      0|		tmp = xmlAddChild(cur, newNode);
 5750|      0|		if (tmp != newNode)
  ------------------
  |  Branch (5750:7): [True: 0, False: 0]
  ------------------
 5751|      0|		    return;
 5752|      0|	        if ((last != NULL) && (last->next == newNode)) {
  ------------------
  |  Branch (5752:14): [True: 0, False: 0]
  |  Branch (5752:32): [True: 0, False: 0]
  ------------------
 5753|      0|		    xmlTextMerge(last, newNode);
 5754|      0|		}
 5755|      0|	    }
 5756|      0|	    break;
 5757|      0|	}
 5758|      0|        case XML_ATTRIBUTE_NODE:
  ------------------
  |  Branch (5758:9): [True: 0, False: 10.8k]
  ------------------
 5759|      0|	    break;
 5760|  10.8k|        case XML_TEXT_NODE:
  ------------------
  |  Branch (5760:9): [True: 10.8k, False: 0]
  ------------------
 5761|  10.8k|        case XML_CDATA_SECTION_NODE:
  ------------------
  |  Branch (5761:9): [True: 0, False: 10.8k]
  ------------------
 5762|  10.8k|        case XML_ENTITY_REF_NODE:
  ------------------
  |  Branch (5762:9): [True: 0, False: 10.8k]
  ------------------
 5763|  10.8k|        case XML_ENTITY_NODE:
  ------------------
  |  Branch (5763:9): [True: 0, False: 10.8k]
  ------------------
 5764|  10.8k|        case XML_PI_NODE:
  ------------------
  |  Branch (5764:9): [True: 0, False: 10.8k]
  ------------------
 5765|  10.8k|        case XML_COMMENT_NODE:
  ------------------
  |  Branch (5765:9): [True: 0, False: 10.8k]
  ------------------
 5766|  10.8k|        case XML_NOTATION_NODE:
  ------------------
  |  Branch (5766:9): [True: 0, False: 10.8k]
  ------------------
 5767|  10.8k|	    if (content != NULL) {
  ------------------
  |  Branch (5767:10): [True: 10.8k, False: 0]
  ------------------
 5768|  10.8k|	        if ((cur->content == (xmlChar *) &(cur->properties)) ||
  ------------------
  |  Branch (5768:14): [True: 21, False: 10.7k]
  ------------------
 5769|  10.8k|		    ((cur->doc != NULL) && (cur->doc->dict != NULL) &&
  ------------------
  |  Branch (5769:8): [True: 10.7k, False: 0]
  |  Branch (5769:30): [True: 10.7k, False: 0]
  ------------------
 5770|  10.7k|			    xmlDictOwns(cur->doc->dict, cur->content))) {
  ------------------
  |  Branch (5770:8): [True: 0, False: 10.7k]
  ------------------
 5771|     21|		    cur->content = xmlStrncatNew(cur->content, content, len);
 5772|     21|		    cur->properties = NULL;
 5773|  10.7k|		} else {
 5774|  10.7k|		    cur->content = xmlStrncat(cur->content, content, len);
 5775|  10.7k|                }
 5776|  10.8k|            }
 5777|  10.8k|	    break;
 5778|      0|        case XML_DOCUMENT_NODE:
  ------------------
  |  Branch (5778:9): [True: 0, False: 10.8k]
  ------------------
 5779|      0|        case XML_DTD_NODE:
  ------------------
  |  Branch (5779:9): [True: 0, False: 10.8k]
  ------------------
 5780|      0|        case XML_HTML_DOCUMENT_NODE:
  ------------------
  |  Branch (5780:9): [True: 0, False: 10.8k]
  ------------------
 5781|      0|        case XML_DOCUMENT_TYPE_NODE:
  ------------------
  |  Branch (5781:9): [True: 0, False: 10.8k]
  ------------------
 5782|      0|	case XML_NAMESPACE_DECL:
  ------------------
  |  Branch (5782:2): [True: 0, False: 10.8k]
  ------------------
 5783|      0|	case XML_XINCLUDE_START:
  ------------------
  |  Branch (5783:2): [True: 0, False: 10.8k]
  ------------------
 5784|      0|	case XML_XINCLUDE_END:
  ------------------
  |  Branch (5784:2): [True: 0, False: 10.8k]
  ------------------
 5785|      0|	    break;
 5786|      0|        case XML_ELEMENT_DECL:
  ------------------
  |  Branch (5786:9): [True: 0, False: 10.8k]
  ------------------
 5787|      0|        case XML_ATTRIBUTE_DECL:
  ------------------
  |  Branch (5787:9): [True: 0, False: 10.8k]
  ------------------
 5788|      0|        case XML_ENTITY_DECL:
  ------------------
  |  Branch (5788:9): [True: 0, False: 10.8k]
  ------------------
 5789|      0|	    break;
 5790|  10.8k|    }
 5791|  10.8k|}
xmlNodeAddContent:
 5804|  10.8k|xmlNodeAddContent(xmlNodePtr cur, const xmlChar *content) {
 5805|  10.8k|    int len;
 5806|       |
 5807|  10.8k|    if (cur == NULL) {
  ------------------
  |  Branch (5807:9): [True: 0, False: 10.8k]
  ------------------
 5808|      0|	return;
 5809|      0|    }
 5810|  10.8k|    if (content == NULL) return;
  ------------------
  |  Branch (5810:9): [True: 0, False: 10.8k]
  ------------------
 5811|  10.8k|    len = xmlStrlen(content);
 5812|  10.8k|    xmlNodeAddContentLen(cur, content, len);
 5813|  10.8k|}
xmlSearchNs:
 5946|     64|xmlSearchNs(xmlDocPtr doc, xmlNodePtr node, const xmlChar *nameSpace) {
 5947|       |
 5948|     64|    xmlNsPtr cur;
 5949|     64|    const xmlNode *orig = node;
 5950|       |
 5951|     64|    if ((node == NULL) || (node->type == XML_NAMESPACE_DECL)) return(NULL);
  ------------------
  |  Branch (5951:9): [True: 0, False: 64]
  |  Branch (5951:27): [True: 0, False: 64]
  ------------------
 5952|     64|    if ((nameSpace != NULL) &&
  ------------------
  |  Branch (5952:9): [True: 64, False: 0]
  ------------------
 5953|     64|	(xmlStrEqual(nameSpace, (const xmlChar *)"xml"))) {
  ------------------
  |  Branch (5953:2): [True: 64, False: 0]
  ------------------
 5954|     64|	if ((doc == NULL) && (node->type == XML_ELEMENT_NODE)) {
  ------------------
  |  Branch (5954:6): [True: 0, False: 64]
  |  Branch (5954:23): [True: 0, False: 0]
  ------------------
 5955|       |	    /*
 5956|       |	     * The XML-1.0 namespace is normally held on the root
 5957|       |	     * element. In this case exceptionally create it on the
 5958|       |	     * node element.
 5959|       |	     */
 5960|      0|	    cur = (xmlNsPtr) xmlMalloc(sizeof(xmlNs));
 5961|      0|	    if (cur == NULL) {
  ------------------
  |  Branch (5961:10): [True: 0, False: 0]
  ------------------
 5962|      0|		xmlTreeErrMemory("searching namespace");
 5963|      0|		return(NULL);
 5964|      0|	    }
 5965|      0|	    memset(cur, 0, sizeof(xmlNs));
 5966|      0|	    cur->type = XML_LOCAL_NAMESPACE;
  ------------------
  |  |  370|      0|#define XML_LOCAL_NAMESPACE XML_NAMESPACE_DECL
  ------------------
 5967|      0|	    cur->href = xmlStrdup(XML_XML_NAMESPACE);
  ------------------
  |  |  143|      0|    (const xmlChar *) "http://www.w3.org/XML/1998/namespace"
  ------------------
 5968|      0|	    cur->prefix = xmlStrdup((const xmlChar *)"xml");
 5969|      0|	    cur->next = node->nsDef;
 5970|      0|	    node->nsDef = cur;
 5971|      0|	    return(cur);
 5972|      0|	}
 5973|     64|	if (doc == NULL) {
  ------------------
  |  Branch (5973:6): [True: 0, False: 64]
  ------------------
 5974|      0|	    doc = node->doc;
 5975|      0|	    if (doc == NULL)
  ------------------
  |  Branch (5975:10): [True: 0, False: 0]
  ------------------
 5976|      0|		return(NULL);
 5977|      0|	}
 5978|       |	/*
 5979|       |	* Return the XML namespace declaration held by the doc.
 5980|       |	*/
 5981|     64|	if (doc->oldNs == NULL)
  ------------------
  |  Branch (5981:6): [True: 48, False: 16]
  ------------------
 5982|     48|	    return(xmlTreeEnsureXMLDecl(doc));
 5983|     16|	else
 5984|     16|	    return(doc->oldNs);
 5985|     64|    }
 5986|      0|    while (node != NULL) {
  ------------------
  |  Branch (5986:12): [True: 0, False: 0]
  ------------------
 5987|      0|	if ((node->type == XML_ENTITY_REF_NODE) ||
  ------------------
  |  Branch (5987:6): [True: 0, False: 0]
  ------------------
 5988|      0|	    (node->type == XML_ENTITY_NODE) ||
  ------------------
  |  Branch (5988:6): [True: 0, False: 0]
  ------------------
 5989|      0|	    (node->type == XML_ENTITY_DECL))
  ------------------
  |  Branch (5989:6): [True: 0, False: 0]
  ------------------
 5990|      0|	    return(NULL);
 5991|      0|	if (node->type == XML_ELEMENT_NODE) {
  ------------------
  |  Branch (5991:6): [True: 0, False: 0]
  ------------------
 5992|      0|	    cur = node->nsDef;
 5993|      0|	    while (cur != NULL) {
  ------------------
  |  Branch (5993:13): [True: 0, False: 0]
  ------------------
 5994|      0|		if ((cur->prefix == NULL) && (nameSpace == NULL) &&
  ------------------
  |  Branch (5994:7): [True: 0, False: 0]
  |  Branch (5994:32): [True: 0, False: 0]
  ------------------
 5995|      0|		    (cur->href != NULL))
  ------------------
  |  Branch (5995:7): [True: 0, False: 0]
  ------------------
 5996|      0|		    return(cur);
 5997|      0|		if ((cur->prefix != NULL) && (nameSpace != NULL) &&
  ------------------
  |  Branch (5997:7): [True: 0, False: 0]
  |  Branch (5997:32): [True: 0, False: 0]
  ------------------
 5998|      0|		    (cur->href != NULL) &&
  ------------------
  |  Branch (5998:7): [True: 0, False: 0]
  ------------------
 5999|      0|		    (xmlStrEqual(cur->prefix, nameSpace)))
  ------------------
  |  Branch (5999:7): [True: 0, False: 0]
  ------------------
 6000|      0|		    return(cur);
 6001|      0|		cur = cur->next;
 6002|      0|	    }
 6003|      0|	    if (orig != node) {
  ------------------
  |  Branch (6003:10): [True: 0, False: 0]
  ------------------
 6004|      0|	        cur = node->ns;
 6005|      0|	        if (cur != NULL) {
  ------------------
  |  Branch (6005:14): [True: 0, False: 0]
  ------------------
 6006|      0|		    if ((cur->prefix == NULL) && (nameSpace == NULL) &&
  ------------------
  |  Branch (6006:11): [True: 0, False: 0]
  |  Branch (6006:36): [True: 0, False: 0]
  ------------------
 6007|      0|		        (cur->href != NULL))
  ------------------
  |  Branch (6007:11): [True: 0, False: 0]
  ------------------
 6008|      0|		        return(cur);
 6009|      0|		    if ((cur->prefix != NULL) && (nameSpace != NULL) &&
  ------------------
  |  Branch (6009:11): [True: 0, False: 0]
  |  Branch (6009:36): [True: 0, False: 0]
  ------------------
 6010|      0|		        (cur->href != NULL) &&
  ------------------
  |  Branch (6010:11): [True: 0, False: 0]
  ------------------
 6011|      0|		        (xmlStrEqual(cur->prefix, nameSpace)))
  ------------------
  |  Branch (6011:11): [True: 0, False: 0]
  ------------------
 6012|      0|		        return(cur);
 6013|      0|	        }
 6014|      0|	    }
 6015|      0|	}
 6016|      0|	node = node->parent;
 6017|      0|    }
 6018|      0|    return(NULL);
 6019|      0|}
xmlIsBlankNode:
 6886|  23.4k|xmlIsBlankNode(const xmlNode *node) {
 6887|  23.4k|    const xmlChar *cur;
 6888|  23.4k|    if (node == NULL) return(0);
  ------------------
  |  Branch (6888:9): [True: 0, False: 23.4k]
  ------------------
 6889|       |
 6890|  23.4k|    if ((node->type != XML_TEXT_NODE) &&
  ------------------
  |  Branch (6890:9): [True: 0, False: 23.4k]
  ------------------
 6891|  23.4k|        (node->type != XML_CDATA_SECTION_NODE))
  ------------------
  |  Branch (6891:9): [True: 0, False: 0]
  ------------------
 6892|      0|	return(0);
 6893|  23.4k|    if (node->content == NULL) return(1);
  ------------------
  |  Branch (6893:9): [True: 0, False: 23.4k]
  ------------------
 6894|  23.4k|    cur = node->content;
 6895|   107k|    while (*cur != 0) {
  ------------------
  |  Branch (6895:12): [True: 88.0k, False: 19.8k]
  ------------------
 6896|  88.0k|	if (!IS_BLANK_CH(*cur)) return(0);
  ------------------
  |  |  151|  88.0k|#define IS_BLANK_CH(c)  xmlIsBlank_ch(c)
  |  |  ------------------
  |  |  |  |   88|  88.0k|#define xmlIsBlank_ch(c)	(((c) == 0x20) || \
  |  |  |  |  ------------------
  |  |  |  |  |  Branch (88:27): [True: 14.7k, False: 73.3k]
  |  |  |  |  ------------------
  |  |  |  |   89|  88.0k|				 ((0x9 <= (c)) && ((c) <= 0xa)) || \
  |  |  |  |  ------------------
  |  |  |  |  |  Branch (89:7): [True: 73.3k, False: 0]
  |  |  |  |  |  Branch (89:23): [True: 69.7k, False: 3.59k]
  |  |  |  |  ------------------
  |  |  |  |   90|  88.0k|				 ((c) == 0xd))
  |  |  |  |  ------------------
  |  |  |  |  |  Branch (90:6): [True: 0, False: 3.59k]
  |  |  |  |  ------------------
  |  |  ------------------
  ------------------
 6897|  84.5k|	cur++;
 6898|  84.5k|    }
 6899|       |
 6900|  19.8k|    return(1);
 6901|  23.4k|}
xmlTextConcat:
 6915|  1.88k|xmlTextConcat(xmlNodePtr node, const xmlChar *content, int len) {
 6916|  1.88k|    if (node == NULL) return(-1);
  ------------------
  |  Branch (6916:9): [True: 0, False: 1.88k]
  ------------------
 6917|       |
 6918|  1.88k|    if ((node->type != XML_TEXT_NODE) &&
  ------------------
  |  Branch (6918:9): [True: 0, False: 1.88k]
  ------------------
 6919|  1.88k|        (node->type != XML_CDATA_SECTION_NODE) &&
  ------------------
  |  Branch (6919:9): [True: 0, False: 0]
  ------------------
 6920|  1.88k|	(node->type != XML_COMMENT_NODE) &&
  ------------------
  |  Branch (6920:2): [True: 0, False: 0]
  ------------------
 6921|  1.88k|	(node->type != XML_PI_NODE)) {
  ------------------
  |  Branch (6921:2): [True: 0, False: 0]
  ------------------
 6922|      0|        return(-1);
 6923|      0|    }
 6924|       |    /* need to check if content is currently in the dictionary */
 6925|  1.88k|    if ((node->content == (xmlChar *) &(node->properties)) ||
  ------------------
  |  Branch (6925:9): [True: 0, False: 1.88k]
  ------------------
 6926|  1.88k|        ((node->doc != NULL) && (node->doc->dict != NULL) &&
  ------------------
  |  Branch (6926:10): [True: 1.88k, False: 0]
  |  Branch (6926:33): [True: 1.88k, False: 0]
  ------------------
 6927|  1.88k|		xmlDictOwns(node->doc->dict, node->content))) {
  ------------------
  |  Branch (6927:3): [True: 0, False: 1.88k]
  ------------------
 6928|      0|	node->content = xmlStrncatNew(node->content, content, len);
 6929|  1.88k|    } else {
 6930|  1.88k|        node->content = xmlStrncat(node->content, content, len);
 6931|  1.88k|    }
 6932|  1.88k|    node->properties = NULL;
 6933|  1.88k|    if (node->content == NULL)
  ------------------
  |  Branch (6933:9): [True: 0, False: 1.88k]
  ------------------
 6934|      0|        return(-1);
 6935|  1.88k|    return(0);
 6936|  1.88k|}
tree.c:xmlCopyPropInternal:
 3934|     12|xmlCopyPropInternal(xmlDocPtr doc, xmlNodePtr target, xmlAttrPtr cur) {
 3935|     12|    xmlAttrPtr ret;
 3936|       |
 3937|     12|    if (cur == NULL) return(NULL);
  ------------------
  |  Branch (3937:9): [True: 0, False: 12]
  ------------------
 3938|     12|    if ((target != NULL) && (target->type != XML_ELEMENT_NODE))
  ------------------
  |  Branch (3938:9): [True: 12, False: 0]
  |  Branch (3938:29): [True: 0, False: 12]
  ------------------
 3939|      0|        return(NULL);
 3940|     12|    if (target != NULL)
  ------------------
  |  Branch (3940:9): [True: 12, False: 0]
  ------------------
 3941|     12|	ret = xmlNewDocProp(target->doc, cur->name, NULL);
 3942|      0|    else if (doc != NULL)
  ------------------
  |  Branch (3942:14): [True: 0, False: 0]
  ------------------
 3943|      0|	ret = xmlNewDocProp(doc, cur->name, NULL);
 3944|      0|    else if (cur->parent != NULL)
  ------------------
  |  Branch (3944:14): [True: 0, False: 0]
  ------------------
 3945|      0|	ret = xmlNewDocProp(cur->parent->doc, cur->name, NULL);
 3946|      0|    else if (cur->children != NULL)
  ------------------
  |  Branch (3946:14): [True: 0, False: 0]
  ------------------
 3947|      0|	ret = xmlNewDocProp(cur->children->doc, cur->name, NULL);
 3948|      0|    else
 3949|      0|	ret = xmlNewDocProp(NULL, cur->name, NULL);
 3950|     12|    if (ret == NULL) return(NULL);
  ------------------
  |  Branch (3950:9): [True: 0, False: 12]
  ------------------
 3951|     12|    ret->parent = target;
 3952|       |
 3953|     12|    if ((cur->ns != NULL) && (target != NULL)) {
  ------------------
  |  Branch (3953:9): [True: 0, False: 12]
  |  Branch (3953:30): [True: 0, False: 0]
  ------------------
 3954|      0|      xmlNsPtr ns;
 3955|       |
 3956|      0|      ns = xmlSearchNs(target->doc, target, cur->ns->prefix);
 3957|      0|      if (ns == NULL) {
  ------------------
  |  Branch (3957:11): [True: 0, False: 0]
  ------------------
 3958|       |        /*
 3959|       |         * Humm, we are copying an element whose namespace is defined
 3960|       |         * out of the new tree scope. Search it in the original tree
 3961|       |         * and add it at the top of the new tree
 3962|       |         */
 3963|      0|        ns = xmlSearchNs(cur->doc, cur->parent, cur->ns->prefix);
 3964|      0|        if (ns != NULL) {
  ------------------
  |  Branch (3964:13): [True: 0, False: 0]
  ------------------
 3965|      0|          xmlNodePtr root = target;
 3966|      0|          xmlNodePtr pred = NULL;
 3967|       |
 3968|      0|          while (root->parent != NULL) {
  ------------------
  |  Branch (3968:18): [True: 0, False: 0]
  ------------------
 3969|      0|            pred = root;
 3970|      0|            root = root->parent;
 3971|      0|          }
 3972|      0|          if (root == (xmlNodePtr) target->doc) {
  ------------------
  |  Branch (3972:15): [True: 0, False: 0]
  ------------------
 3973|       |            /* correct possibly cycling above the document elt */
 3974|      0|            root = pred;
 3975|      0|          }
 3976|      0|          ret->ns = xmlNewNs(root, ns->href, ns->prefix);
 3977|      0|        }
 3978|      0|      } else {
 3979|       |        /*
 3980|       |         * we have to find something appropriate here since
 3981|       |         * we can't be sure, that the namespace we found is identified
 3982|       |         * by the prefix
 3983|       |         */
 3984|      0|        if (xmlStrEqual(ns->href, cur->ns->href)) {
  ------------------
  |  Branch (3984:13): [True: 0, False: 0]
  ------------------
 3985|       |          /* this is the nice case */
 3986|      0|          ret->ns = ns;
 3987|      0|        } else {
 3988|       |          /*
 3989|       |           * we are in trouble: we need a new reconciled namespace.
 3990|       |           * This is expensive
 3991|       |           */
 3992|      0|          ret->ns = xmlNewReconciledNs(target->doc, target, cur->ns);
 3993|      0|        }
 3994|      0|      }
 3995|       |
 3996|      0|    } else
 3997|     12|        ret->ns = NULL;
 3998|       |
 3999|     12|    if (cur->children != NULL) {
  ------------------
  |  Branch (3999:9): [True: 12, False: 0]
  ------------------
 4000|     12|	xmlNodePtr tmp;
 4001|       |
 4002|     12|	ret->children = xmlStaticCopyNodeList(cur->children, ret->doc, (xmlNodePtr) ret);
 4003|     12|	ret->last = NULL;
 4004|     12|	tmp = ret->children;
 4005|     24|	while (tmp != NULL) {
  ------------------
  |  Branch (4005:9): [True: 12, False: 12]
  ------------------
 4006|       |	    /* tmp->parent = (xmlNodePtr)ret; */
 4007|     12|	    if (tmp->next == NULL)
  ------------------
  |  Branch (4007:10): [True: 12, False: 0]
  ------------------
 4008|     12|	        ret->last = tmp;
 4009|     12|	    tmp = tmp->next;
 4010|     12|	}
 4011|     12|    }
 4012|       |    /*
 4013|       |     * Try to handle IDs
 4014|       |     */
 4015|     12|    if ((target!= NULL) && (cur!= NULL) &&
  ------------------
  |  Branch (4015:9): [True: 12, False: 0]
  |  Branch (4015:28): [True: 12, False: 0]
  ------------------
 4016|     12|	(target->doc != NULL) && (cur->doc != NULL) &&
  ------------------
  |  Branch (4016:2): [True: 12, False: 0]
  |  Branch (4016:27): [True: 12, False: 0]
  ------------------
 4017|     12|	(cur->doc->ids != NULL) && (cur->parent != NULL)) {
  ------------------
  |  Branch (4017:2): [True: 11, False: 1]
  |  Branch (4017:29): [True: 11, False: 0]
  ------------------
 4018|     11|	if (xmlIsID(cur->doc, cur->parent, cur)) {
  ------------------
  |  Branch (4018:6): [True: 11, False: 0]
  ------------------
 4019|     11|	    xmlChar *id;
 4020|       |
 4021|     11|	    id = xmlNodeListGetString(cur->doc, cur->children, 1);
 4022|     11|	    if (id != NULL) {
  ------------------
  |  Branch (4022:10): [True: 11, False: 0]
  ------------------
 4023|     11|		xmlAddID(NULL, target->doc, id, ret);
 4024|     11|		xmlFree(id);
 4025|     11|	    }
 4026|     11|	}
 4027|     11|    }
 4028|     12|    return(ret);
 4029|     12|}
tree.c:xmlGetLineNoInternal:
 4579|  4.99k|{
 4580|  4.99k|    long result = -1;
 4581|       |
 4582|  4.99k|    if (depth >= 5)
  ------------------
  |  Branch (4582:9): [True: 0, False: 4.99k]
  ------------------
 4583|      0|        return(-1);
 4584|       |
 4585|  4.99k|    if (!node)
  ------------------
  |  Branch (4585:9): [True: 1, False: 4.99k]
  ------------------
 4586|      1|        return result;
 4587|  4.99k|    if ((node->type == XML_ELEMENT_NODE) ||
  ------------------
  |  Branch (4587:9): [True: 4.99k, False: 0]
  ------------------
 4588|  4.99k|        (node->type == XML_TEXT_NODE) ||
  ------------------
  |  Branch (4588:9): [True: 0, False: 0]
  ------------------
 4589|  4.99k|	(node->type == XML_COMMENT_NODE) ||
  ------------------
  |  Branch (4589:2): [True: 0, False: 0]
  ------------------
 4590|  4.99k|	(node->type == XML_PI_NODE)) {
  ------------------
  |  Branch (4590:2): [True: 0, False: 0]
  ------------------
 4591|  4.99k|	if (node->line == 65535) {
  ------------------
  |  Branch (4591:6): [True: 0, False: 4.99k]
  ------------------
 4592|      0|	    if ((node->type == XML_TEXT_NODE) && (node->psvi != NULL))
  ------------------
  |  Branch (4592:10): [True: 0, False: 0]
  |  Branch (4592:43): [True: 0, False: 0]
  ------------------
 4593|      0|	        result = (long) (ptrdiff_t) node->psvi;
 4594|      0|	    else if ((node->type == XML_ELEMENT_NODE) &&
  ------------------
  |  Branch (4594:15): [True: 0, False: 0]
  ------------------
 4595|      0|	             (node->children != NULL))
  ------------------
  |  Branch (4595:15): [True: 0, False: 0]
  ------------------
 4596|      0|	        result = xmlGetLineNoInternal(node->children, depth + 1);
 4597|      0|	    else if (node->next != NULL)
  ------------------
  |  Branch (4597:15): [True: 0, False: 0]
  ------------------
 4598|      0|	        result = xmlGetLineNoInternal(node->next, depth + 1);
 4599|      0|	    else if (node->prev != NULL)
  ------------------
  |  Branch (4599:15): [True: 0, False: 0]
  ------------------
 4600|      0|	        result = xmlGetLineNoInternal(node->prev, depth + 1);
 4601|      0|	}
 4602|  4.99k|	if ((result == -1) || (result == 65535))
  ------------------
  |  Branch (4602:6): [True: 4.99k, False: 0]
  |  Branch (4602:24): [True: 0, False: 0]
  ------------------
 4603|  4.99k|	    result = (long) node->line;
 4604|  4.99k|    } else if ((node->prev != NULL) &&
  ------------------
  |  Branch (4604:16): [True: 0, False: 0]
  ------------------
 4605|      0|             ((node->prev->type == XML_ELEMENT_NODE) ||
  ------------------
  |  Branch (4605:15): [True: 0, False: 0]
  ------------------
 4606|      0|	      (node->prev->type == XML_TEXT_NODE) ||
  ------------------
  |  Branch (4606:8): [True: 0, False: 0]
  ------------------
 4607|      0|	      (node->prev->type == XML_COMMENT_NODE) ||
  ------------------
  |  Branch (4607:8): [True: 0, False: 0]
  ------------------
 4608|      0|	      (node->prev->type == XML_PI_NODE)))
  ------------------
  |  Branch (4608:8): [True: 0, False: 0]
  ------------------
 4609|      0|        result = xmlGetLineNoInternal(node->prev, depth + 1);
 4610|      0|    else if ((node->parent != NULL) &&
  ------------------
  |  Branch (4610:14): [True: 0, False: 0]
  ------------------
 4611|      0|             (node->parent->type == XML_ELEMENT_NODE))
  ------------------
  |  Branch (4611:14): [True: 0, False: 0]
  ------------------
 4612|      0|        result = xmlGetLineNoInternal(node->parent, depth + 1);
 4613|       |
 4614|  4.99k|    return result;
 4615|  4.99k|}
tree.c:xmlTreeEnsureXMLDecl:
 5907|     48|{
 5908|     48|    if (doc == NULL)
  ------------------
  |  Branch (5908:9): [True: 0, False: 48]
  ------------------
 5909|      0|	return (NULL);
 5910|     48|    if (doc->oldNs != NULL)
  ------------------
  |  Branch (5910:9): [True: 0, False: 48]
  ------------------
 5911|      0|	return (doc->oldNs);
 5912|     48|    {
 5913|     48|	xmlNsPtr ns;
 5914|     48|	ns = (xmlNsPtr) xmlMalloc(sizeof(xmlNs));
 5915|     48|	if (ns == NULL) {
  ------------------
  |  Branch (5915:6): [True: 0, False: 48]
  ------------------
 5916|      0|	    xmlTreeErrMemory(
 5917|      0|		"allocating the XML namespace");
 5918|      0|	    return (NULL);
 5919|      0|	}
 5920|     48|	memset(ns, 0, sizeof(xmlNs));
 5921|     48|	ns->type = XML_LOCAL_NAMESPACE;
  ------------------
  |  |  370|     48|#define XML_LOCAL_NAMESPACE XML_NAMESPACE_DECL
  ------------------
 5922|     48|	ns->href = xmlStrdup(XML_XML_NAMESPACE);
  ------------------
  |  |  143|     48|    (const xmlChar *) "http://www.w3.org/XML/1998/namespace"
  ------------------
 5923|     48|	ns->prefix = xmlStrdup((const xmlChar *)"xml");
 5924|     48|	doc->oldNs = ns;
 5925|     48|	return (ns);
 5926|     48|    }
 5927|     48|}

xmlParseURI:
  947|  15.3k|xmlParseURI(const char *str) {
  948|  15.3k|    xmlURIPtr uri;
  949|  15.3k|    int ret;
  950|       |
  951|  15.3k|    if (str == NULL)
  ------------------
  |  Branch (951:9): [True: 0, False: 15.3k]
  ------------------
  952|      0|	return(NULL);
  953|  15.3k|    uri = xmlCreateURI();
  954|  15.3k|    if (uri != NULL) {
  ------------------
  |  Branch (954:9): [True: 15.3k, False: 0]
  ------------------
  955|  15.3k|	ret = xmlParse3986URIReference(uri, str);
  956|  15.3k|        if (ret) {
  ------------------
  |  Branch (956:13): [True: 0, False: 15.3k]
  ------------------
  957|      0|	    xmlFreeURI(uri);
  958|      0|	    return(NULL);
  959|      0|	}
  960|  15.3k|    }
  961|  15.3k|    return(uri);
  962|  15.3k|}
xmlParseURIReference:
  977|    634|xmlParseURIReference(xmlURIPtr uri, const char *str) {
  978|    634|    return(xmlParse3986URIReference(uri, str));
  979|    634|}
xmlCreateURI:
 1027|  16.1k|xmlCreateURI(void) {
 1028|  16.1k|    xmlURIPtr ret;
 1029|       |
 1030|  16.1k|    ret = (xmlURIPtr) xmlMalloc(sizeof(xmlURI));
 1031|  16.1k|    if (ret == NULL) {
  ------------------
  |  Branch (1031:9): [True: 0, False: 16.1k]
  ------------------
 1032|      0|        xmlURIErrMemory("creating URI structure\n");
 1033|      0|	return(NULL);
 1034|      0|    }
 1035|  16.1k|    memset(ret, 0, sizeof(xmlURI));
 1036|  16.1k|    ret->port = PORT_EMPTY;
  ------------------
  |  |   37|  16.1k|#define PORT_EMPTY           0
  ------------------
 1037|  16.1k|    return(ret);
 1038|  16.1k|}
xmlSaveUri:
 1074|    246|xmlSaveUri(xmlURIPtr uri) {
 1075|    246|    xmlChar *ret = NULL;
 1076|    246|    xmlChar *temp;
 1077|    246|    const char *p;
 1078|    246|    int len;
 1079|    246|    int max;
 1080|       |
 1081|    246|    if (uri == NULL) return(NULL);
  ------------------
  |  Branch (1081:9): [True: 0, False: 246]
  ------------------
 1082|       |
 1083|       |
 1084|    246|    max = 80;
 1085|    246|    ret = (xmlChar *) xmlMallocAtomic(max + 1);
 1086|    246|    if (ret == NULL) {
  ------------------
  |  Branch (1086:9): [True: 0, False: 246]
  ------------------
 1087|      0|        xmlURIErrMemory("saving URI\n");
 1088|      0|	return(NULL);
 1089|      0|    }
 1090|    246|    len = 0;
 1091|       |
 1092|    246|    if (uri->scheme != NULL) {
  ------------------
  |  Branch (1092:9): [True: 0, False: 246]
  ------------------
 1093|      0|	p = uri->scheme;
 1094|      0|	while (*p != 0) {
  ------------------
  |  Branch (1094:9): [True: 0, False: 0]
  ------------------
 1095|      0|	    if (len >= max) {
  ------------------
  |  Branch (1095:10): [True: 0, False: 0]
  ------------------
 1096|      0|                temp = xmlSaveUriRealloc(ret, &max);
 1097|      0|                if (temp == NULL) goto mem_error;
  ------------------
  |  Branch (1097:21): [True: 0, False: 0]
  ------------------
 1098|      0|		ret = temp;
 1099|      0|	    }
 1100|      0|	    ret[len++] = *p++;
 1101|      0|	}
 1102|      0|	if (len >= max) {
  ------------------
  |  Branch (1102:6): [True: 0, False: 0]
  ------------------
 1103|      0|            temp = xmlSaveUriRealloc(ret, &max);
 1104|      0|            if (temp == NULL) goto mem_error;
  ------------------
  |  Branch (1104:17): [True: 0, False: 0]
  ------------------
 1105|      0|            ret = temp;
 1106|      0|	}
 1107|      0|	ret[len++] = ':';
 1108|      0|    }
 1109|    246|    if (uri->opaque != NULL) {
  ------------------
  |  Branch (1109:9): [True: 0, False: 246]
  ------------------
 1110|      0|	p = uri->opaque;
 1111|      0|	while (*p != 0) {
  ------------------
  |  Branch (1111:9): [True: 0, False: 0]
  ------------------
 1112|      0|	    if (len + 3 >= max) {
  ------------------
  |  Branch (1112:10): [True: 0, False: 0]
  ------------------
 1113|      0|                temp = xmlSaveUriRealloc(ret, &max);
 1114|      0|                if (temp == NULL) goto mem_error;
  ------------------
  |  Branch (1114:21): [True: 0, False: 0]
  ------------------
 1115|      0|                ret = temp;
 1116|      0|	    }
 1117|      0|	    if (IS_RESERVED(*(p)) || IS_UNRESERVED(*(p)))
  ------------------
  |  |  116|      0|#define IS_RESERVED(x) (((x) == ';') || ((x) == '/') || ((x) == '?') || \
  |  |  ------------------
  |  |  |  Branch (116:25): [True: 0, False: 0]
  |  |  |  Branch (116:41): [True: 0, False: 0]
  |  |  |  Branch (116:57): [True: 0, False: 0]
  |  |  ------------------
  |  |  117|      0|        ((x) == ':') || ((x) == '@') || ((x) == '&') || ((x) == '=') || \
  |  |  ------------------
  |  |  |  Branch (117:9): [True: 0, False: 0]
  |  |  |  Branch (117:25): [True: 0, False: 0]
  |  |  |  Branch (117:41): [True: 0, False: 0]
  |  |  |  Branch (117:57): [True: 0, False: 0]
  |  |  ------------------
  |  |  118|      0|        ((x) == '+') || ((x) == '$') || ((x) == ',') || ((x) == '[') || \
  |  |  ------------------
  |  |  |  Branch (118:9): [True: 0, False: 0]
  |  |  |  Branch (118:25): [True: 0, False: 0]
  |  |  |  Branch (118:41): [True: 0, False: 0]
  |  |  |  Branch (118:57): [True: 0, False: 0]
  |  |  ------------------
  |  |  119|      0|        ((x) == ']'))
  |  |  ------------------
  |  |  |  Branch (119:9): [True: 0, False: 0]
  |  |  ------------------
  ------------------
              	    if (IS_RESERVED(*(p)) || IS_UNRESERVED(*(p)))
  ------------------
  |  |  125|      0|#define IS_UNRESERVED(x) (IS_ALPHANUM(x) || IS_MARK(x))
  |  |  ------------------
  |  |  |  |   93|      0|#define IS_ALPHANUM(x) (IS_ALPHA(x) || IS_DIGIT(x))
  |  |  |  |  ------------------
  |  |  |  |  |  |   63|      0|#define IS_ALPHA(x) (IS_LOWALPHA(x) || IS_UPALPHA(x))
  |  |  |  |  |  |  ------------------
  |  |  |  |  |  |  |  |   72|      0|#define IS_LOWALPHA(x) (((x) >= 'a') && ((x) <= 'z'))
  |  |  |  |  |  |  |  |  ------------------
  |  |  |  |  |  |  |  |  |  Branch (72:25): [True: 0, False: 0]
  |  |  |  |  |  |  |  |  |  Branch (72:41): [True: 0, False: 0]
  |  |  |  |  |  |  |  |  ------------------
  |  |  |  |  |  |  ------------------
  |  |  |  |  |  |               #define IS_ALPHA(x) (IS_LOWALPHA(x) || IS_UPALPHA(x))
  |  |  |  |  |  |  ------------------
  |  |  |  |  |  |  |  |   79|      0|#define IS_UPALPHA(x) (((x) >= 'A') && ((x) <= 'Z'))
  |  |  |  |  |  |  |  |  ------------------
  |  |  |  |  |  |  |  |  |  Branch (79:24): [True: 0, False: 0]
  |  |  |  |  |  |  |  |  |  Branch (79:40): [True: 0, False: 0]
  |  |  |  |  |  |  |  |  ------------------
  |  |  |  |  |  |  ------------------
  |  |  |  |  ------------------
  |  |  |  |               #define IS_ALPHANUM(x) (IS_ALPHA(x) || IS_DIGIT(x))
  |  |  |  |  ------------------
  |  |  |  |  |  |   87|      0|#define IS_DIGIT(x) (((x) >= '0') && ((x) <= '9'))
  |  |  |  |  |  |  ------------------
  |  |  |  |  |  |  |  Branch (87:22): [True: 0, False: 0]
  |  |  |  |  |  |  |  Branch (87:38): [True: 0, False: 0]
  |  |  |  |  |  |  ------------------
  |  |  |  |  ------------------
  |  |  ------------------
  |  |               #define IS_UNRESERVED(x) (IS_ALPHANUM(x) || IS_MARK(x))
  |  |  ------------------
  |  |  |  |   99|      0|#define IS_MARK(x) (((x) == '-') || ((x) == '_') || ((x) == '.') ||     \
  |  |  |  |  ------------------
  |  |  |  |  |  Branch (99:21): [True: 0, False: 0]
  |  |  |  |  |  Branch (99:37): [True: 0, False: 0]
  |  |  |  |  |  Branch (99:53): [True: 0, False: 0]
  |  |  |  |  ------------------
  |  |  |  |  100|      0|    ((x) == '!') || ((x) == '~') || ((x) == '*') || ((x) == '\'') ||    \
  |  |  |  |  ------------------
  |  |  |  |  |  Branch (100:5): [True: 0, False: 0]
  |  |  |  |  |  Branch (100:21): [True: 0, False: 0]
  |  |  |  |  |  Branch (100:37): [True: 0, False: 0]
  |  |  |  |  |  Branch (100:53): [True: 0, False: 0]
  |  |  |  |  ------------------
  |  |  |  |  101|      0|    ((x) == '(') || ((x) == ')'))
  |  |  |  |  ------------------
  |  |  |  |  |  Branch (101:5): [True: 0, False: 0]
  |  |  |  |  |  Branch (101:21): [True: 0, False: 0]
  |  |  |  |  ------------------
  |  |  ------------------
  ------------------
 1118|      0|		ret[len++] = *p++;
 1119|      0|	    else {
 1120|      0|		int val = *(unsigned char *)p++;
 1121|      0|		int hi = val / 0x10, lo = val % 0x10;
 1122|      0|		ret[len++] = '%';
 1123|      0|		ret[len++] = hi + (hi > 9? 'A'-10 : '0');
  ------------------
  |  Branch (1123:22): [True: 0, False: 0]
  ------------------
 1124|      0|		ret[len++] = lo + (lo > 9? 'A'-10 : '0');
  ------------------
  |  Branch (1124:22): [True: 0, False: 0]
  ------------------
 1125|      0|	    }
 1126|      0|	}
 1127|    246|    } else {
 1128|    246|	if ((uri->server != NULL) || (uri->port != PORT_EMPTY)) {
  ------------------
  |  |   37|    246|#define PORT_EMPTY           0
  ------------------
  |  Branch (1128:6): [True: 0, False: 246]
  |  Branch (1128:31): [True: 0, False: 246]
  ------------------
 1129|      0|	    if (len + 3 >= max) {
  ------------------
  |  Branch (1129:10): [True: 0, False: 0]
  ------------------
 1130|      0|                temp = xmlSaveUriRealloc(ret, &max);
 1131|      0|                if (temp == NULL) goto mem_error;
  ------------------
  |  Branch (1131:21): [True: 0, False: 0]
  ------------------
 1132|      0|                ret = temp;
 1133|      0|	    }
 1134|      0|	    ret[len++] = '/';
 1135|      0|	    ret[len++] = '/';
 1136|      0|	    if (uri->user != NULL) {
  ------------------
  |  Branch (1136:10): [True: 0, False: 0]
  ------------------
 1137|      0|		p = uri->user;
 1138|      0|		while (*p != 0) {
  ------------------
  |  Branch (1138:10): [True: 0, False: 0]
  ------------------
 1139|      0|		    if (len + 3 >= max) {
  ------------------
  |  Branch (1139:11): [True: 0, False: 0]
  ------------------
 1140|      0|                        temp = xmlSaveUriRealloc(ret, &max);
 1141|      0|                        if (temp == NULL) goto mem_error;
  ------------------
  |  Branch (1141:29): [True: 0, False: 0]
  ------------------
 1142|      0|                        ret = temp;
 1143|      0|		    }
 1144|      0|		    if ((IS_UNRESERVED(*(p))) ||
  ------------------
  |  |  125|      0|#define IS_UNRESERVED(x) (IS_ALPHANUM(x) || IS_MARK(x))
  |  |  ------------------
  |  |  |  |   93|      0|#define IS_ALPHANUM(x) (IS_ALPHA(x) || IS_DIGIT(x))
  |  |  |  |  ------------------
  |  |  |  |  |  |   63|      0|#define IS_ALPHA(x) (IS_LOWALPHA(x) || IS_UPALPHA(x))
  |  |  |  |  |  |  ------------------
  |  |  |  |  |  |  |  |   72|      0|#define IS_LOWALPHA(x) (((x) >= 'a') && ((x) <= 'z'))
  |  |  |  |  |  |  |  |  ------------------
  |  |  |  |  |  |  |  |  |  Branch (72:25): [True: 0, False: 0]
  |  |  |  |  |  |  |  |  |  Branch (72:41): [True: 0, False: 0]
  |  |  |  |  |  |  |  |  ------------------
  |  |  |  |  |  |  ------------------
  |  |  |  |  |  |               #define IS_ALPHA(x) (IS_LOWALPHA(x) || IS_UPALPHA(x))
  |  |  |  |  |  |  ------------------
  |  |  |  |  |  |  |  |   79|      0|#define IS_UPALPHA(x) (((x) >= 'A') && ((x) <= 'Z'))
  |  |  |  |  |  |  |  |  ------------------
  |  |  |  |  |  |  |  |  |  Branch (79:24): [True: 0, False: 0]
  |  |  |  |  |  |  |  |  |  Branch (79:40): [True: 0, False: 0]
  |  |  |  |  |  |  |  |  ------------------
  |  |  |  |  |  |  ------------------
  |  |  |  |  ------------------
  |  |  |  |               #define IS_ALPHANUM(x) (IS_ALPHA(x) || IS_DIGIT(x))
  |  |  |  |  ------------------
  |  |  |  |  |  |   87|      0|#define IS_DIGIT(x) (((x) >= '0') && ((x) <= '9'))
  |  |  |  |  |  |  ------------------
  |  |  |  |  |  |  |  Branch (87:22): [True: 0, False: 0]
  |  |  |  |  |  |  |  Branch (87:38): [True: 0, False: 0]
  |  |  |  |  |  |  ------------------
  |  |  |  |  ------------------
  |  |  ------------------
  |  |               #define IS_UNRESERVED(x) (IS_ALPHANUM(x) || IS_MARK(x))
  |  |  ------------------
  |  |  |  |   99|      0|#define IS_MARK(x) (((x) == '-') || ((x) == '_') || ((x) == '.') ||     \
  |  |  |  |  ------------------
  |  |  |  |  |  Branch (99:21): [True: 0, False: 0]
  |  |  |  |  |  Branch (99:37): [True: 0, False: 0]
  |  |  |  |  |  Branch (99:53): [True: 0, False: 0]
  |  |  |  |  ------------------
  |  |  |  |  100|      0|    ((x) == '!') || ((x) == '~') || ((x) == '*') || ((x) == '\'') ||    \
  |  |  |  |  ------------------
  |  |  |  |  |  Branch (100:5): [True: 0, False: 0]
  |  |  |  |  |  Branch (100:21): [True: 0, False: 0]
  |  |  |  |  |  Branch (100:37): [True: 0, False: 0]
  |  |  |  |  |  Branch (100:53): [True: 0, False: 0]
  |  |  |  |  ------------------
  |  |  |  |  101|      0|    ((x) == '(') || ((x) == ')'))
  |  |  |  |  ------------------
  |  |  |  |  |  Branch (101:5): [True: 0, False: 0]
  |  |  |  |  |  Branch (101:21): [True: 0, False: 0]
  |  |  |  |  ------------------
  |  |  ------------------
  ------------------
 1145|      0|			((*(p) == ';')) || ((*(p) == ':')) ||
  ------------------
  |  Branch (1145:4): [True: 0, False: 0]
  |  Branch (1145:23): [True: 0, False: 0]
  ------------------
 1146|      0|			((*(p) == '&')) || ((*(p) == '=')) ||
  ------------------
  |  Branch (1146:4): [True: 0, False: 0]
  |  Branch (1146:23): [True: 0, False: 0]
  ------------------
 1147|      0|			((*(p) == '+')) || ((*(p) == '$')) ||
  ------------------
  |  Branch (1147:4): [True: 0, False: 0]
  |  Branch (1147:23): [True: 0, False: 0]
  ------------------
 1148|      0|			((*(p) == ',')))
  ------------------
  |  Branch (1148:4): [True: 0, False: 0]
  ------------------
 1149|      0|			ret[len++] = *p++;
 1150|      0|		    else {
 1151|      0|			int val = *(unsigned char *)p++;
 1152|      0|			int hi = val / 0x10, lo = val % 0x10;
 1153|      0|			ret[len++] = '%';
 1154|      0|			ret[len++] = hi + (hi > 9? 'A'-10 : '0');
  ------------------
  |  Branch (1154:23): [True: 0, False: 0]
  ------------------
 1155|      0|			ret[len++] = lo + (lo > 9? 'A'-10 : '0');
  ------------------
  |  Branch (1155:23): [True: 0, False: 0]
  ------------------
 1156|      0|		    }
 1157|      0|		}
 1158|      0|		if (len + 3 >= max) {
  ------------------
  |  Branch (1158:7): [True: 0, False: 0]
  ------------------
 1159|      0|                    temp = xmlSaveUriRealloc(ret, &max);
 1160|      0|                    if (temp == NULL) goto mem_error;
  ------------------
  |  Branch (1160:25): [True: 0, False: 0]
  ------------------
 1161|      0|                    ret = temp;
 1162|      0|		}
 1163|      0|		ret[len++] = '@';
 1164|      0|	    }
 1165|      0|	    if (uri->server != NULL) {
  ------------------
  |  Branch (1165:10): [True: 0, False: 0]
  ------------------
 1166|      0|		p = uri->server;
 1167|      0|		while (*p != 0) {
  ------------------
  |  Branch (1167:10): [True: 0, False: 0]
  ------------------
 1168|      0|		    if (len >= max) {
  ------------------
  |  Branch (1168:11): [True: 0, False: 0]
  ------------------
 1169|      0|			temp = xmlSaveUriRealloc(ret, &max);
 1170|      0|			if (temp == NULL) goto mem_error;
  ------------------
  |  Branch (1170:8): [True: 0, False: 0]
  ------------------
 1171|      0|			ret = temp;
 1172|      0|		    }
 1173|       |                    /* TODO: escaping? */
 1174|      0|		    ret[len++] = (xmlChar) *p++;
 1175|      0|		}
 1176|      0|	    }
 1177|      0|            if (uri->port > 0) {
  ------------------
  |  Branch (1177:17): [True: 0, False: 0]
  ------------------
 1178|      0|                if (len + 10 >= max) {
  ------------------
  |  Branch (1178:21): [True: 0, False: 0]
  ------------------
 1179|      0|                    temp = xmlSaveUriRealloc(ret, &max);
 1180|      0|                    if (temp == NULL) goto mem_error;
  ------------------
  |  Branch (1180:25): [True: 0, False: 0]
  ------------------
 1181|      0|                    ret = temp;
 1182|      0|                }
 1183|      0|                len += snprintf((char *) &ret[len], max - len, ":%d", uri->port);
 1184|      0|            }
 1185|    246|	} else if (uri->authority != NULL) {
  ------------------
  |  Branch (1185:13): [True: 0, False: 246]
  ------------------
 1186|      0|	    if (len + 3 >= max) {
  ------------------
  |  Branch (1186:10): [True: 0, False: 0]
  ------------------
 1187|      0|                temp = xmlSaveUriRealloc(ret, &max);
 1188|      0|                if (temp == NULL) goto mem_error;
  ------------------
  |  Branch (1188:21): [True: 0, False: 0]
  ------------------
 1189|      0|                ret = temp;
 1190|      0|	    }
 1191|      0|	    ret[len++] = '/';
 1192|      0|	    ret[len++] = '/';
 1193|      0|	    p = uri->authority;
 1194|      0|	    while (*p != 0) {
  ------------------
  |  Branch (1194:13): [True: 0, False: 0]
  ------------------
 1195|      0|		if (len + 3 >= max) {
  ------------------
  |  Branch (1195:7): [True: 0, False: 0]
  ------------------
 1196|      0|                    temp = xmlSaveUriRealloc(ret, &max);
 1197|      0|                    if (temp == NULL) goto mem_error;
  ------------------
  |  Branch (1197:25): [True: 0, False: 0]
  ------------------
 1198|      0|                    ret = temp;
 1199|      0|		}
 1200|      0|		if ((IS_UNRESERVED(*(p))) ||
  ------------------
  |  |  125|      0|#define IS_UNRESERVED(x) (IS_ALPHANUM(x) || IS_MARK(x))
  |  |  ------------------
  |  |  |  |   93|      0|#define IS_ALPHANUM(x) (IS_ALPHA(x) || IS_DIGIT(x))
  |  |  |  |  ------------------
  |  |  |  |  |  |   63|      0|#define IS_ALPHA(x) (IS_LOWALPHA(x) || IS_UPALPHA(x))
  |  |  |  |  |  |  ------------------
  |  |  |  |  |  |  |  |   72|      0|#define IS_LOWALPHA(x) (((x) >= 'a') && ((x) <= 'z'))
  |  |  |  |  |  |  |  |  ------------------
  |  |  |  |  |  |  |  |  |  Branch (72:25): [True: 0, False: 0]
  |  |  |  |  |  |  |  |  |  Branch (72:41): [True: 0, False: 0]
  |  |  |  |  |  |  |  |  ------------------
  |  |  |  |  |  |  ------------------
  |  |  |  |  |  |               #define IS_ALPHA(x) (IS_LOWALPHA(x) || IS_UPALPHA(x))
  |  |  |  |  |  |  ------------------
  |  |  |  |  |  |  |  |   79|      0|#define IS_UPALPHA(x) (((x) >= 'A') && ((x) <= 'Z'))
  |  |  |  |  |  |  |  |  ------------------
  |  |  |  |  |  |  |  |  |  Branch (79:24): [True: 0, False: 0]
  |  |  |  |  |  |  |  |  |  Branch (79:40): [True: 0, False: 0]
  |  |  |  |  |  |  |  |  ------------------
  |  |  |  |  |  |  ------------------
  |  |  |  |  ------------------
  |  |  |  |               #define IS_ALPHANUM(x) (IS_ALPHA(x) || IS_DIGIT(x))
  |  |  |  |  ------------------
  |  |  |  |  |  |   87|      0|#define IS_DIGIT(x) (((x) >= '0') && ((x) <= '9'))
  |  |  |  |  |  |  ------------------
  |  |  |  |  |  |  |  Branch (87:22): [True: 0, False: 0]
  |  |  |  |  |  |  |  Branch (87:38): [True: 0, False: 0]
  |  |  |  |  |  |  ------------------
  |  |  |  |  ------------------
  |  |  ------------------
  |  |               #define IS_UNRESERVED(x) (IS_ALPHANUM(x) || IS_MARK(x))
  |  |  ------------------
  |  |  |  |   99|      0|#define IS_MARK(x) (((x) == '-') || ((x) == '_') || ((x) == '.') ||     \
  |  |  |  |  ------------------
  |  |  |  |  |  Branch (99:21): [True: 0, False: 0]
  |  |  |  |  |  Branch (99:37): [True: 0, False: 0]
  |  |  |  |  |  Branch (99:53): [True: 0, False: 0]
  |  |  |  |  ------------------
  |  |  |  |  100|      0|    ((x) == '!') || ((x) == '~') || ((x) == '*') || ((x) == '\'') ||    \
  |  |  |  |  ------------------
  |  |  |  |  |  Branch (100:5): [True: 0, False: 0]
  |  |  |  |  |  Branch (100:21): [True: 0, False: 0]
  |  |  |  |  |  Branch (100:37): [True: 0, False: 0]
  |  |  |  |  |  Branch (100:53): [True: 0, False: 0]
  |  |  |  |  ------------------
  |  |  |  |  101|      0|    ((x) == '(') || ((x) == ')'))
  |  |  |  |  ------------------
  |  |  |  |  |  Branch (101:5): [True: 0, False: 0]
  |  |  |  |  |  Branch (101:21): [True: 0, False: 0]
  |  |  |  |  ------------------
  |  |  ------------------
  ------------------
 1201|      0|                    ((*(p) == '$')) || ((*(p) == ',')) || ((*(p) == ';')) ||
  ------------------
  |  Branch (1201:21): [True: 0, False: 0]
  |  Branch (1201:40): [True: 0, False: 0]
  |  Branch (1201:59): [True: 0, False: 0]
  ------------------
 1202|      0|                    ((*(p) == ':')) || ((*(p) == '@')) || ((*(p) == '&')) ||
  ------------------
  |  Branch (1202:21): [True: 0, False: 0]
  |  Branch (1202:40): [True: 0, False: 0]
  |  Branch (1202:59): [True: 0, False: 0]
  ------------------
 1203|      0|                    ((*(p) == '=')) || ((*(p) == '+')))
  ------------------
  |  Branch (1203:21): [True: 0, False: 0]
  |  Branch (1203:40): [True: 0, False: 0]
  ------------------
 1204|      0|		    ret[len++] = *p++;
 1205|      0|		else {
 1206|      0|		    int val = *(unsigned char *)p++;
 1207|      0|		    int hi = val / 0x10, lo = val % 0x10;
 1208|      0|		    ret[len++] = '%';
 1209|      0|		    ret[len++] = hi + (hi > 9? 'A'-10 : '0');
  ------------------
  |  Branch (1209:26): [True: 0, False: 0]
  ------------------
 1210|      0|		    ret[len++] = lo + (lo > 9? 'A'-10 : '0');
  ------------------
  |  Branch (1210:26): [True: 0, False: 0]
  ------------------
 1211|      0|		}
 1212|      0|	    }
 1213|    246|	} else if (uri->scheme != NULL) {
  ------------------
  |  Branch (1213:13): [True: 0, False: 246]
  ------------------
 1214|      0|	    if (len + 3 >= max) {
  ------------------
  |  Branch (1214:10): [True: 0, False: 0]
  ------------------
 1215|      0|                temp = xmlSaveUriRealloc(ret, &max);
 1216|      0|                if (temp == NULL) goto mem_error;
  ------------------
  |  Branch (1216:21): [True: 0, False: 0]
  ------------------
 1217|      0|                ret = temp;
 1218|      0|	    }
 1219|      0|	}
 1220|    246|	if (uri->path != NULL) {
  ------------------
  |  Branch (1220:6): [True: 246, False: 0]
  ------------------
 1221|    246|	    p = uri->path;
 1222|       |	    /*
 1223|       |	     * the colon in file:///d: should not be escaped or
 1224|       |	     * Windows accesses fail later.
 1225|       |	     */
 1226|    246|	    if ((uri->scheme != NULL) &&
  ------------------
  |  Branch (1226:10): [True: 0, False: 246]
  ------------------
 1227|    246|		(p[0] == '/') &&
  ------------------
  |  Branch (1227:3): [True: 0, False: 0]
  ------------------
 1228|    246|		(((p[1] >= 'a') && (p[1] <= 'z')) ||
  ------------------
  |  Branch (1228:5): [True: 0, False: 0]
  |  Branch (1228:22): [True: 0, False: 0]
  ------------------
 1229|      0|		 ((p[1] >= 'A') && (p[1] <= 'Z'))) &&
  ------------------
  |  Branch (1229:5): [True: 0, False: 0]
  |  Branch (1229:22): [True: 0, False: 0]
  ------------------
 1230|    246|		(p[2] == ':') &&
  ------------------
  |  Branch (1230:3): [True: 0, False: 0]
  ------------------
 1231|    246|	        (xmlStrEqual(BAD_CAST uri->scheme, BAD_CAST "file"))) {
  ------------------
  |  |   35|      0|#define BAD_CAST (xmlChar *)
  ------------------
              	        (xmlStrEqual(BAD_CAST uri->scheme, BAD_CAST "file"))) {
  ------------------
  |  |   35|      0|#define BAD_CAST (xmlChar *)
  ------------------
  |  Branch (1231:10): [True: 0, False: 0]
  ------------------
 1232|      0|		if (len + 3 >= max) {
  ------------------
  |  Branch (1232:7): [True: 0, False: 0]
  ------------------
 1233|      0|                    temp = xmlSaveUriRealloc(ret, &max);
 1234|      0|                    if (temp == NULL) goto mem_error;
  ------------------
  |  Branch (1234:25): [True: 0, False: 0]
  ------------------
 1235|      0|                    ret = temp;
 1236|      0|		}
 1237|      0|		ret[len++] = *p++;
 1238|      0|		ret[len++] = *p++;
 1239|      0|		ret[len++] = *p++;
 1240|      0|	    }
 1241|  3.25k|	    while (*p != 0) {
  ------------------
  |  Branch (1241:13): [True: 3.00k, False: 246]
  ------------------
 1242|  3.00k|		if (len + 3 >= max) {
  ------------------
  |  Branch (1242:7): [True: 0, False: 3.00k]
  ------------------
 1243|      0|                    temp = xmlSaveUriRealloc(ret, &max);
 1244|      0|                    if (temp == NULL) goto mem_error;
  ------------------
  |  Branch (1244:25): [True: 0, False: 0]
  ------------------
 1245|      0|                    ret = temp;
 1246|      0|		}
 1247|  3.00k|		if ((IS_UNRESERVED(*(p))) || ((*(p) == '/')) ||
  ------------------
  |  |  125|  3.00k|#define IS_UNRESERVED(x) (IS_ALPHANUM(x) || IS_MARK(x))
  |  |  ------------------
  |  |  |  |   93|  6.01k|#define IS_ALPHANUM(x) (IS_ALPHA(x) || IS_DIGIT(x))
  |  |  |  |  ------------------
  |  |  |  |  |  |   63|  6.01k|#define IS_ALPHA(x) (IS_LOWALPHA(x) || IS_UPALPHA(x))
  |  |  |  |  |  |  ------------------
  |  |  |  |  |  |  |  |   72|  6.01k|#define IS_LOWALPHA(x) (((x) >= 'a') && ((x) <= 'z'))
  |  |  |  |  |  |  |  |  ------------------
  |  |  |  |  |  |  |  |  |  Branch (72:25): [True: 2.30k, False: 700]
  |  |  |  |  |  |  |  |  |  Branch (72:41): [True: 2.30k, False: 0]
  |  |  |  |  |  |  |  |  ------------------
  |  |  |  |  |  |  ------------------
  |  |  |  |  |  |               #define IS_ALPHA(x) (IS_LOWALPHA(x) || IS_UPALPHA(x))
  |  |  |  |  |  |  ------------------
  |  |  |  |  |  |  |  |   79|    700|#define IS_UPALPHA(x) (((x) >= 'A') && ((x) <= 'Z'))
  |  |  |  |  |  |  |  |  ------------------
  |  |  |  |  |  |  |  |  |  Branch (79:24): [True: 54, False: 646]
  |  |  |  |  |  |  |  |  |  Branch (79:40): [True: 16, False: 38]
  |  |  |  |  |  |  |  |  ------------------
  |  |  |  |  |  |  ------------------
  |  |  |  |  ------------------
  |  |  |  |               #define IS_ALPHANUM(x) (IS_ALPHA(x) || IS_DIGIT(x))
  |  |  |  |  ------------------
  |  |  |  |  |  |   87|    684|#define IS_DIGIT(x) (((x) >= '0') && ((x) <= '9'))
  |  |  |  |  |  |  ------------------
  |  |  |  |  |  |  |  Branch (87:22): [True: 282, False: 402]
  |  |  |  |  |  |  |  Branch (87:38): [True: 244, False: 38]
  |  |  |  |  |  |  ------------------
  |  |  |  |  ------------------
  |  |  ------------------
  |  |               #define IS_UNRESERVED(x) (IS_ALPHANUM(x) || IS_MARK(x))
  |  |  ------------------
  |  |  |  |   99|    440|#define IS_MARK(x) (((x) == '-') || ((x) == '_') || ((x) == '.') ||     \
  |  |  |  |  ------------------
  |  |  |  |  |  Branch (99:21): [True: 32, False: 408]
  |  |  |  |  |  Branch (99:37): [True: 38, False: 370]
  |  |  |  |  |  Branch (99:53): [True: 238, False: 132]
  |  |  |  |  ------------------
  |  |  |  |  100|    440|    ((x) == '!') || ((x) == '~') || ((x) == '*') || ((x) == '\'') ||    \
  |  |  |  |  ------------------
  |  |  |  |  |  Branch (100:5): [True: 0, False: 132]
  |  |  |  |  |  Branch (100:21): [True: 0, False: 132]
  |  |  |  |  |  Branch (100:37): [True: 0, False: 132]
  |  |  |  |  |  Branch (100:53): [True: 0, False: 132]
  |  |  |  |  ------------------
  |  |  |  |  101|    440|    ((x) == '(') || ((x) == ')'))
  |  |  |  |  ------------------
  |  |  |  |  |  Branch (101:5): [True: 0, False: 132]
  |  |  |  |  |  Branch (101:21): [True: 0, False: 132]
  |  |  |  |  ------------------
  |  |  ------------------
  ------------------
  |  Branch (1247:32): [True: 132, False: 0]
  ------------------
 1248|  3.00k|                    ((*(p) == ';')) || ((*(p) == '@')) || ((*(p) == '&')) ||
  ------------------
  |  Branch (1248:21): [True: 0, False: 0]
  |  Branch (1248:40): [True: 0, False: 0]
  |  Branch (1248:59): [True: 0, False: 0]
  ------------------
 1249|  3.00k|	            ((*(p) == '=')) || ((*(p) == '+')) || ((*(p) == '$')) ||
  ------------------
  |  Branch (1249:14): [True: 0, False: 0]
  |  Branch (1249:33): [True: 0, False: 0]
  |  Branch (1249:52): [True: 0, False: 0]
  ------------------
 1250|  3.00k|	            ((*(p) == ',')))
  ------------------
  |  Branch (1250:14): [True: 0, False: 0]
  ------------------
 1251|  3.00k|		    ret[len++] = *p++;
 1252|      0|		else {
 1253|      0|		    int val = *(unsigned char *)p++;
 1254|      0|		    int hi = val / 0x10, lo = val % 0x10;
 1255|      0|		    ret[len++] = '%';
 1256|      0|		    ret[len++] = hi + (hi > 9? 'A'-10 : '0');
  ------------------
  |  Branch (1256:26): [True: 0, False: 0]
  ------------------
 1257|      0|		    ret[len++] = lo + (lo > 9? 'A'-10 : '0');
  ------------------
  |  Branch (1257:26): [True: 0, False: 0]
  ------------------
 1258|      0|		}
 1259|  3.00k|	    }
 1260|    246|	}
 1261|    246|	if (uri->query_raw != NULL) {
  ------------------
  |  Branch (1261:6): [True: 0, False: 246]
  ------------------
 1262|      0|	    if (len + 1 >= max) {
  ------------------
  |  Branch (1262:10): [True: 0, False: 0]
  ------------------
 1263|      0|                temp = xmlSaveUriRealloc(ret, &max);
 1264|      0|                if (temp == NULL) goto mem_error;
  ------------------
  |  Branch (1264:21): [True: 0, False: 0]
  ------------------
 1265|      0|                ret = temp;
 1266|      0|	    }
 1267|      0|	    ret[len++] = '?';
 1268|      0|	    p = uri->query_raw;
 1269|      0|	    while (*p != 0) {
  ------------------
  |  Branch (1269:13): [True: 0, False: 0]
  ------------------
 1270|      0|		if (len + 1 >= max) {
  ------------------
  |  Branch (1270:7): [True: 0, False: 0]
  ------------------
 1271|      0|                    temp = xmlSaveUriRealloc(ret, &max);
 1272|      0|                    if (temp == NULL) goto mem_error;
  ------------------
  |  Branch (1272:25): [True: 0, False: 0]
  ------------------
 1273|      0|                    ret = temp;
 1274|      0|		}
 1275|      0|		ret[len++] = *p++;
 1276|      0|	    }
 1277|    246|	} else if (uri->query != NULL) {
  ------------------
  |  Branch (1277:13): [True: 0, False: 246]
  ------------------
 1278|      0|	    if (len + 3 >= max) {
  ------------------
  |  Branch (1278:10): [True: 0, False: 0]
  ------------------
 1279|      0|                temp = xmlSaveUriRealloc(ret, &max);
 1280|      0|                if (temp == NULL) goto mem_error;
  ------------------
  |  Branch (1280:21): [True: 0, False: 0]
  ------------------
 1281|      0|                ret = temp;
 1282|      0|	    }
 1283|      0|	    ret[len++] = '?';
 1284|      0|	    p = uri->query;
 1285|      0|	    while (*p != 0) {
  ------------------
  |  Branch (1285:13): [True: 0, False: 0]
  ------------------
 1286|      0|		if (len + 3 >= max) {
  ------------------
  |  Branch (1286:7): [True: 0, False: 0]
  ------------------
 1287|      0|                    temp = xmlSaveUriRealloc(ret, &max);
 1288|      0|                    if (temp == NULL) goto mem_error;
  ------------------
  |  Branch (1288:25): [True: 0, False: 0]
  ------------------
 1289|      0|                    ret = temp;
 1290|      0|		}
 1291|      0|		if ((IS_UNRESERVED(*(p))) || (IS_RESERVED(*(p))))
  ------------------
  |  |  125|      0|#define IS_UNRESERVED(x) (IS_ALPHANUM(x) || IS_MARK(x))
  |  |  ------------------
  |  |  |  |   93|      0|#define IS_ALPHANUM(x) (IS_ALPHA(x) || IS_DIGIT(x))
  |  |  |  |  ------------------
  |  |  |  |  |  |   63|      0|#define IS_ALPHA(x) (IS_LOWALPHA(x) || IS_UPALPHA(x))
  |  |  |  |  |  |  ------------------
  |  |  |  |  |  |  |  |   72|      0|#define IS_LOWALPHA(x) (((x) >= 'a') && ((x) <= 'z'))
  |  |  |  |  |  |  |  |  ------------------
  |  |  |  |  |  |  |  |  |  Branch (72:25): [True: 0, False: 0]
  |  |  |  |  |  |  |  |  |  Branch (72:41): [True: 0, False: 0]
  |  |  |  |  |  |  |  |  ------------------
  |  |  |  |  |  |  ------------------
  |  |  |  |  |  |               #define IS_ALPHA(x) (IS_LOWALPHA(x) || IS_UPALPHA(x))
  |  |  |  |  |  |  ------------------
  |  |  |  |  |  |  |  |   79|      0|#define IS_UPALPHA(x) (((x) >= 'A') && ((x) <= 'Z'))
  |  |  |  |  |  |  |  |  ------------------
  |  |  |  |  |  |  |  |  |  Branch (79:24): [True: 0, False: 0]
  |  |  |  |  |  |  |  |  |  Branch (79:40): [True: 0, False: 0]
  |  |  |  |  |  |  |  |  ------------------
  |  |  |  |  |  |  ------------------
  |  |  |  |  ------------------
  |  |  |  |               #define IS_ALPHANUM(x) (IS_ALPHA(x) || IS_DIGIT(x))
  |  |  |  |  ------------------
  |  |  |  |  |  |   87|      0|#define IS_DIGIT(x) (((x) >= '0') && ((x) <= '9'))
  |  |  |  |  |  |  ------------------
  |  |  |  |  |  |  |  Branch (87:22): [True: 0, False: 0]
  |  |  |  |  |  |  |  Branch (87:38): [True: 0, False: 0]
  |  |  |  |  |  |  ------------------
  |  |  |  |  ------------------
  |  |  ------------------
  |  |               #define IS_UNRESERVED(x) (IS_ALPHANUM(x) || IS_MARK(x))
  |  |  ------------------
  |  |  |  |   99|      0|#define IS_MARK(x) (((x) == '-') || ((x) == '_') || ((x) == '.') ||     \
  |  |  |  |  ------------------
  |  |  |  |  |  Branch (99:21): [True: 0, False: 0]
  |  |  |  |  |  Branch (99:37): [True: 0, False: 0]
  |  |  |  |  |  Branch (99:53): [True: 0, False: 0]
  |  |  |  |  ------------------
  |  |  |  |  100|      0|    ((x) == '!') || ((x) == '~') || ((x) == '*') || ((x) == '\'') ||    \
  |  |  |  |  ------------------
  |  |  |  |  |  Branch (100:5): [True: 0, False: 0]
  |  |  |  |  |  Branch (100:21): [True: 0, False: 0]
  |  |  |  |  |  Branch (100:37): [True: 0, False: 0]
  |  |  |  |  |  Branch (100:53): [True: 0, False: 0]
  |  |  |  |  ------------------
  |  |  |  |  101|      0|    ((x) == '(') || ((x) == ')'))
  |  |  |  |  ------------------
  |  |  |  |  |  Branch (101:5): [True: 0, False: 0]
  |  |  |  |  |  Branch (101:21): [True: 0, False: 0]
  |  |  |  |  ------------------
  |  |  ------------------
  ------------------
              		if ((IS_UNRESERVED(*(p))) || (IS_RESERVED(*(p))))
  ------------------
  |  |  116|      0|#define IS_RESERVED(x) (((x) == ';') || ((x) == '/') || ((x) == '?') || \
  |  |  ------------------
  |  |  |  Branch (116:25): [True: 0, False: 0]
  |  |  |  Branch (116:41): [True: 0, False: 0]
  |  |  |  Branch (116:57): [True: 0, False: 0]
  |  |  ------------------
  |  |  117|      0|        ((x) == ':') || ((x) == '@') || ((x) == '&') || ((x) == '=') || \
  |  |  ------------------
  |  |  |  Branch (117:9): [True: 0, False: 0]
  |  |  |  Branch (117:25): [True: 0, False: 0]
  |  |  |  Branch (117:41): [True: 0, False: 0]
  |  |  |  Branch (117:57): [True: 0, False: 0]
  |  |  ------------------
  |  |  118|      0|        ((x) == '+') || ((x) == '$') || ((x) == ',') || ((x) == '[') || \
  |  |  ------------------
  |  |  |  Branch (118:9): [True: 0, False: 0]
  |  |  |  Branch (118:25): [True: 0, False: 0]
  |  |  |  Branch (118:41): [True: 0, False: 0]
  |  |  |  Branch (118:57): [True: 0, False: 0]
  |  |  ------------------
  |  |  119|      0|        ((x) == ']'))
  |  |  ------------------
  |  |  |  Branch (119:9): [True: 0, False: 0]
  |  |  ------------------
  ------------------
 1292|      0|		    ret[len++] = *p++;
 1293|      0|		else {
 1294|      0|		    int val = *(unsigned char *)p++;
 1295|      0|		    int hi = val / 0x10, lo = val % 0x10;
 1296|      0|		    ret[len++] = '%';
 1297|      0|		    ret[len++] = hi + (hi > 9? 'A'-10 : '0');
  ------------------
  |  Branch (1297:26): [True: 0, False: 0]
  ------------------
 1298|      0|		    ret[len++] = lo + (lo > 9? 'A'-10 : '0');
  ------------------
  |  Branch (1298:26): [True: 0, False: 0]
  ------------------
 1299|      0|		}
 1300|      0|	    }
 1301|      0|	}
 1302|    246|    }
 1303|    246|    if (uri->fragment != NULL) {
  ------------------
  |  Branch (1303:9): [True: 0, False: 246]
  ------------------
 1304|      0|	if (len + 3 >= max) {
  ------------------
  |  Branch (1304:6): [True: 0, False: 0]
  ------------------
 1305|      0|            temp = xmlSaveUriRealloc(ret, &max);
 1306|      0|            if (temp == NULL) goto mem_error;
  ------------------
  |  Branch (1306:17): [True: 0, False: 0]
  ------------------
 1307|      0|            ret = temp;
 1308|      0|	}
 1309|      0|	ret[len++] = '#';
 1310|      0|	p = uri->fragment;
 1311|      0|	while (*p != 0) {
  ------------------
  |  Branch (1311:9): [True: 0, False: 0]
  ------------------
 1312|      0|	    if (len + 3 >= max) {
  ------------------
  |  Branch (1312:10): [True: 0, False: 0]
  ------------------
 1313|      0|                temp = xmlSaveUriRealloc(ret, &max);
 1314|      0|                if (temp == NULL) goto mem_error;
  ------------------
  |  Branch (1314:21): [True: 0, False: 0]
  ------------------
 1315|      0|                ret = temp;
 1316|      0|	    }
 1317|      0|	    if ((IS_UNRESERVED(*(p))) || (IS_RESERVED(*(p))))
  ------------------
  |  |  125|      0|#define IS_UNRESERVED(x) (IS_ALPHANUM(x) || IS_MARK(x))
  |  |  ------------------
  |  |  |  |   93|      0|#define IS_ALPHANUM(x) (IS_ALPHA(x) || IS_DIGIT(x))
  |  |  |  |  ------------------
  |  |  |  |  |  |   63|      0|#define IS_ALPHA(x) (IS_LOWALPHA(x) || IS_UPALPHA(x))
  |  |  |  |  |  |  ------------------
  |  |  |  |  |  |  |  |   72|      0|#define IS_LOWALPHA(x) (((x) >= 'a') && ((x) <= 'z'))
  |  |  |  |  |  |  |  |  ------------------
  |  |  |  |  |  |  |  |  |  Branch (72:25): [True: 0, False: 0]
  |  |  |  |  |  |  |  |  |  Branch (72:41): [True: 0, False: 0]
  |  |  |  |  |  |  |  |  ------------------
  |  |  |  |  |  |  ------------------
  |  |  |  |  |  |               #define IS_ALPHA(x) (IS_LOWALPHA(x) || IS_UPALPHA(x))
  |  |  |  |  |  |  ------------------
  |  |  |  |  |  |  |  |   79|      0|#define IS_UPALPHA(x) (((x) >= 'A') && ((x) <= 'Z'))
  |  |  |  |  |  |  |  |  ------------------
  |  |  |  |  |  |  |  |  |  Branch (79:24): [True: 0, False: 0]
  |  |  |  |  |  |  |  |  |  Branch (79:40): [True: 0, False: 0]
  |  |  |  |  |  |  |  |  ------------------
  |  |  |  |  |  |  ------------------
  |  |  |  |  ------------------
  |  |  |  |               #define IS_ALPHANUM(x) (IS_ALPHA(x) || IS_DIGIT(x))
  |  |  |  |  ------------------
  |  |  |  |  |  |   87|      0|#define IS_DIGIT(x) (((x) >= '0') && ((x) <= '9'))
  |  |  |  |  |  |  ------------------
  |  |  |  |  |  |  |  Branch (87:22): [True: 0, False: 0]
  |  |  |  |  |  |  |  Branch (87:38): [True: 0, False: 0]
  |  |  |  |  |  |  ------------------
  |  |  |  |  ------------------
  |  |  ------------------
  |  |               #define IS_UNRESERVED(x) (IS_ALPHANUM(x) || IS_MARK(x))
  |  |  ------------------
  |  |  |  |   99|      0|#define IS_MARK(x) (((x) == '-') || ((x) == '_') || ((x) == '.') ||     \
  |  |  |  |  ------------------
  |  |  |  |  |  Branch (99:21): [True: 0, False: 0]
  |  |  |  |  |  Branch (99:37): [True: 0, False: 0]
  |  |  |  |  |  Branch (99:53): [True: 0, False: 0]
  |  |  |  |  ------------------
  |  |  |  |  100|      0|    ((x) == '!') || ((x) == '~') || ((x) == '*') || ((x) == '\'') ||    \
  |  |  |  |  ------------------
  |  |  |  |  |  Branch (100:5): [True: 0, False: 0]
  |  |  |  |  |  Branch (100:21): [True: 0, False: 0]
  |  |  |  |  |  Branch (100:37): [True: 0, False: 0]
  |  |  |  |  |  Branch (100:53): [True: 0, False: 0]
  |  |  |  |  ------------------
  |  |  |  |  101|      0|    ((x) == '(') || ((x) == ')'))
  |  |  |  |  ------------------
  |  |  |  |  |  Branch (101:5): [True: 0, False: 0]
  |  |  |  |  |  Branch (101:21): [True: 0, False: 0]
  |  |  |  |  ------------------
  |  |  ------------------
  ------------------
              	    if ((IS_UNRESERVED(*(p))) || (IS_RESERVED(*(p))))
  ------------------
  |  |  116|      0|#define IS_RESERVED(x) (((x) == ';') || ((x) == '/') || ((x) == '?') || \
  |  |  ------------------
  |  |  |  Branch (116:25): [True: 0, False: 0]
  |  |  |  Branch (116:41): [True: 0, False: 0]
  |  |  |  Branch (116:57): [True: 0, False: 0]
  |  |  ------------------
  |  |  117|      0|        ((x) == ':') || ((x) == '@') || ((x) == '&') || ((x) == '=') || \
  |  |  ------------------
  |  |  |  Branch (117:9): [True: 0, False: 0]
  |  |  |  Branch (117:25): [True: 0, False: 0]
  |  |  |  Branch (117:41): [True: 0, False: 0]
  |  |  |  Branch (117:57): [True: 0, False: 0]
  |  |  ------------------
  |  |  118|      0|        ((x) == '+') || ((x) == '$') || ((x) == ',') || ((x) == '[') || \
  |  |  ------------------
  |  |  |  Branch (118:9): [True: 0, False: 0]
  |  |  |  Branch (118:25): [True: 0, False: 0]
  |  |  |  Branch (118:41): [True: 0, False: 0]
  |  |  |  Branch (118:57): [True: 0, False: 0]
  |  |  ------------------
  |  |  119|      0|        ((x) == ']'))
  |  |  ------------------
  |  |  |  Branch (119:9): [True: 0, False: 0]
  |  |  ------------------
  ------------------
 1318|      0|		ret[len++] = *p++;
 1319|      0|	    else {
 1320|      0|		int val = *(unsigned char *)p++;
 1321|      0|		int hi = val / 0x10, lo = val % 0x10;
 1322|      0|		ret[len++] = '%';
 1323|      0|		ret[len++] = hi + (hi > 9? 'A'-10 : '0');
  ------------------
  |  Branch (1323:22): [True: 0, False: 0]
  ------------------
 1324|      0|		ret[len++] = lo + (lo > 9? 'A'-10 : '0');
  ------------------
  |  Branch (1324:22): [True: 0, False: 0]
  ------------------
 1325|      0|	    }
 1326|      0|	}
 1327|      0|    }
 1328|    246|    if (len >= max) {
  ------------------
  |  Branch (1328:9): [True: 0, False: 246]
  ------------------
 1329|      0|        temp = xmlSaveUriRealloc(ret, &max);
 1330|      0|        if (temp == NULL) goto mem_error;
  ------------------
  |  Branch (1330:13): [True: 0, False: 0]
  ------------------
 1331|      0|        ret = temp;
 1332|      0|    }
 1333|    246|    ret[len] = 0;
 1334|    246|    return(ret);
 1335|       |
 1336|      0|mem_error:
 1337|      0|    xmlFree(ret);
 1338|      0|    return(NULL);
 1339|    246|}
xmlFreeURI:
 1396|  16.1k|xmlFreeURI(xmlURIPtr uri) {
 1397|  16.1k|    if (uri == NULL) return;
  ------------------
  |  Branch (1397:9): [True: 0, False: 16.1k]
  ------------------
 1398|       |
 1399|  16.1k|    if (uri->scheme != NULL) xmlFree(uri->scheme);
  ------------------
  |  Branch (1399:9): [True: 872, False: 15.2k]
  ------------------
 1400|  16.1k|    if (uri->server != NULL) xmlFree(uri->server);
  ------------------
  |  Branch (1400:9): [True: 808, False: 15.3k]
  ------------------
 1401|  16.1k|    if (uri->user != NULL) xmlFree(uri->user);
  ------------------
  |  Branch (1401:9): [True: 0, False: 16.1k]
  ------------------
 1402|  16.1k|    if (uri->path != NULL) xmlFree(uri->path);
  ------------------
  |  Branch (1402:9): [True: 16.1k, False: 16]
  ------------------
 1403|  16.1k|    if (uri->fragment != NULL) xmlFree(uri->fragment);
  ------------------
  |  Branch (1403:9): [True: 20, False: 16.1k]
  ------------------
 1404|  16.1k|    if (uri->opaque != NULL) xmlFree(uri->opaque);
  ------------------
  |  Branch (1404:9): [True: 0, False: 16.1k]
  ------------------
 1405|  16.1k|    if (uri->authority != NULL) xmlFree(uri->authority);
  ------------------
  |  Branch (1405:9): [True: 0, False: 16.1k]
  ------------------
 1406|  16.1k|    if (uri->query != NULL) xmlFree(uri->query);
  ------------------
  |  Branch (1406:9): [True: 0, False: 16.1k]
  ------------------
 1407|  16.1k|    if (uri->query_raw != NULL) xmlFree(uri->query_raw);
  ------------------
  |  Branch (1407:9): [True: 0, False: 16.1k]
  ------------------
 1408|  16.1k|    xmlFree(uri);
 1409|  16.1k|}
xmlNormalizeURIPath:
 1429|    151|xmlNormalizeURIPath(char *path) {
 1430|    151|    char *cur, *out;
 1431|       |
 1432|    151|    if (path == NULL)
  ------------------
  |  Branch (1432:9): [True: 0, False: 151]
  ------------------
 1433|      0|	return(-1);
 1434|       |
 1435|       |    /* Skip all initial "/" chars.  We want to get to the beginning of the
 1436|       |     * first non-empty segment.
 1437|       |     */
 1438|    151|    cur = path;
 1439|    151|    while (cur[0] == '/')
  ------------------
  |  Branch (1439:12): [True: 0, False: 151]
  ------------------
 1440|      0|      ++cur;
 1441|    151|    if (cur[0] == '\0')
  ------------------
  |  Branch (1441:9): [True: 0, False: 151]
  ------------------
 1442|      0|      return(0);
 1443|       |
 1444|       |    /* Keep everything we've seen so far.  */
 1445|    151|    out = cur;
 1446|       |
 1447|       |    /*
 1448|       |     * Analyze each segment in sequence for cases (c) and (d).
 1449|       |     */
 1450|    231|    while (cur[0] != '\0') {
  ------------------
  |  Branch (1450:12): [True: 231, False: 0]
  ------------------
 1451|       |	/*
 1452|       |	 * c) All occurrences of "./", where "." is a complete path segment,
 1453|       |	 *    are removed from the buffer string.
 1454|       |	 */
 1455|    231|	if ((cur[0] == '.') && (cur[1] == '/')) {
  ------------------
  |  Branch (1455:6): [True: 0, False: 231]
  |  Branch (1455:25): [True: 0, False: 0]
  ------------------
 1456|      0|	    cur += 2;
 1457|       |	    /* '//' normalization should be done at this point too */
 1458|      0|	    while (cur[0] == '/')
  ------------------
  |  Branch (1458:13): [True: 0, False: 0]
  ------------------
 1459|      0|		cur++;
 1460|      0|	    continue;
 1461|      0|	}
 1462|       |
 1463|       |	/*
 1464|       |	 * d) If the buffer string ends with "." as a complete path segment,
 1465|       |	 *    that "." is removed.
 1466|       |	 */
 1467|    231|	if ((cur[0] == '.') && (cur[1] == '\0'))
  ------------------
  |  Branch (1467:6): [True: 0, False: 231]
  |  Branch (1467:25): [True: 0, False: 0]
  ------------------
 1468|      0|	    break;
 1469|       |
 1470|       |	/* Otherwise keep the segment.  */
 1471|  2.04k|	while (cur[0] != '/') {
  ------------------
  |  Branch (1471:9): [True: 1.96k, False: 80]
  ------------------
 1472|  1.96k|            if (cur[0] == '\0')
  ------------------
  |  Branch (1472:17): [True: 151, False: 1.81k]
  ------------------
 1473|    151|              goto done_cd;
 1474|  1.81k|	    (out++)[0] = (cur++)[0];
 1475|  1.81k|	}
 1476|       |	/* normalize // */
 1477|     80|	while ((cur[0] == '/') && (cur[1] == '/'))
  ------------------
  |  Branch (1477:9): [True: 80, False: 0]
  |  Branch (1477:28): [True: 0, False: 80]
  ------------------
 1478|      0|	    cur++;
 1479|       |
 1480|     80|        (out++)[0] = (cur++)[0];
 1481|     80|    }
 1482|    151| done_cd:
 1483|    151|    out[0] = '\0';
 1484|       |
 1485|       |    /* Reset to the beginning of the first segment for the next sequence.  */
 1486|    151|    cur = path;
 1487|    151|    while (cur[0] == '/')
  ------------------
  |  Branch (1487:12): [True: 0, False: 151]
  ------------------
 1488|      0|      ++cur;
 1489|    151|    if (cur[0] == '\0')
  ------------------
  |  Branch (1489:9): [True: 0, False: 151]
  ------------------
 1490|      0|	return(0);
 1491|       |
 1492|       |    /*
 1493|       |     * Analyze each segment in sequence for cases (e) and (f).
 1494|       |     *
 1495|       |     * e) All occurrences of "<segment>/../", where <segment> is a
 1496|       |     *    complete path segment not equal to "..", are removed from the
 1497|       |     *    buffer string.  Removal of these path segments is performed
 1498|       |     *    iteratively, removing the leftmost matching pattern on each
 1499|       |     *    iteration, until no matching pattern remains.
 1500|       |     *
 1501|       |     * f) If the buffer string ends with "<segment>/..", where <segment>
 1502|       |     *    is a complete path segment not equal to "..", that
 1503|       |     *    "<segment>/.." is removed.
 1504|       |     *
 1505|       |     * To satisfy the "iterative" clause in (e), we need to collapse the
 1506|       |     * string every time we find something that needs to be removed.  Thus,
 1507|       |     * we don't need to keep two pointers into the string: we only need a
 1508|       |     * "current position" pointer.
 1509|       |     */
 1510|    231|    while (1) {
  ------------------
  |  Branch (1510:12): [Folded - Ignored]
  ------------------
 1511|    231|        char *segp, *tmp;
 1512|       |
 1513|       |        /* At the beginning of each iteration of this loop, "cur" points to
 1514|       |         * the first character of the segment we want to examine.
 1515|       |         */
 1516|       |
 1517|       |        /* Find the end of the current segment.  */
 1518|    231|        segp = cur;
 1519|  2.04k|        while ((segp[0] != '/') && (segp[0] != '\0'))
  ------------------
  |  Branch (1519:16): [True: 1.96k, False: 80]
  |  Branch (1519:36): [True: 1.81k, False: 151]
  ------------------
 1520|  1.81k|          ++segp;
 1521|       |
 1522|       |        /* If this is the last segment, we're done (we need at least two
 1523|       |         * segments to meet the criteria for the (e) and (f) cases).
 1524|       |         */
 1525|    231|        if (segp[0] == '\0')
  ------------------
  |  Branch (1525:13): [True: 151, False: 80]
  ------------------
 1526|    151|          break;
 1527|       |
 1528|       |        /* If the first segment is "..", or if the next segment _isn't_ "..",
 1529|       |         * keep this segment and try the next one.
 1530|       |         */
 1531|     80|        ++segp;
 1532|     80|        if (((cur[0] == '.') && (cur[1] == '.') && (segp == cur+3))
  ------------------
  |  Branch (1532:14): [True: 0, False: 80]
  |  Branch (1532:33): [True: 0, False: 0]
  |  Branch (1532:52): [True: 0, False: 0]
  ------------------
 1533|     80|            || ((segp[0] != '.') || (segp[1] != '.')
  ------------------
  |  Branch (1533:17): [True: 80, False: 0]
  |  Branch (1533:37): [True: 0, False: 0]
  ------------------
 1534|     80|                || ((segp[2] != '/') && (segp[2] != '\0')))) {
  ------------------
  |  Branch (1534:21): [True: 0, False: 0]
  |  Branch (1534:41): [True: 0, False: 0]
  ------------------
 1535|     80|          cur = segp;
 1536|     80|          continue;
 1537|     80|        }
 1538|       |
 1539|       |        /* If we get here, remove this segment and the next one and back up
 1540|       |         * to the previous segment (if there is one), to implement the
 1541|       |         * "iteratively" clause.  It's pretty much impossible to back up
 1542|       |         * while maintaining two pointers into the buffer, so just compact
 1543|       |         * the whole buffer now.
 1544|       |         */
 1545|       |
 1546|       |        /* If this is the end of the buffer, we're done.  */
 1547|      0|        if (segp[2] == '\0') {
  ------------------
  |  Branch (1547:13): [True: 0, False: 0]
  ------------------
 1548|      0|          cur[0] = '\0';
 1549|      0|          break;
 1550|      0|        }
 1551|       |        /* Valgrind complained, strcpy(cur, segp + 3); */
 1552|       |        /* string will overlap, do not use strcpy */
 1553|      0|        tmp = cur;
 1554|      0|        segp += 3;
 1555|      0|        while ((*tmp++ = *segp++) != 0)
  ------------------
  |  Branch (1555:16): [True: 0, False: 0]
  ------------------
 1556|      0|          ;
 1557|       |
 1558|       |        /* If there are no previous segments, then keep going from here.  */
 1559|      0|        segp = cur;
 1560|      0|        while ((segp > path) && ((--segp)[0] == '/'))
  ------------------
  |  Branch (1560:16): [True: 0, False: 0]
  |  Branch (1560:33): [True: 0, False: 0]
  ------------------
 1561|      0|          ;
 1562|      0|        if (segp == path)
  ------------------
  |  Branch (1562:13): [True: 0, False: 0]
  ------------------
 1563|      0|          continue;
 1564|       |
 1565|       |        /* "segp" is pointing to the end of a previous segment; find it's
 1566|       |         * start.  We need to back up to the previous segment and start
 1567|       |         * over with that to handle things like "foo/bar/../..".  If we
 1568|       |         * don't do this, then on the first pass we'll remove the "bar/..",
 1569|       |         * but be pointing at the second ".." so we won't realize we can also
 1570|       |         * remove the "foo/..".
 1571|       |         */
 1572|      0|        cur = segp;
 1573|      0|        while ((cur > path) && (cur[-1] != '/'))
  ------------------
  |  Branch (1573:16): [True: 0, False: 0]
  |  Branch (1573:32): [True: 0, False: 0]
  ------------------
 1574|      0|          --cur;
 1575|      0|    }
 1576|    151|    out[0] = '\0';
 1577|       |
 1578|       |    /*
 1579|       |     * g) If the resulting buffer string still begins with one or more
 1580|       |     *    complete path segments of "..", then the reference is
 1581|       |     *    considered to be in error. Implementations may handle this
 1582|       |     *    error by retaining these components in the resolved path (i.e.,
 1583|       |     *    treating them as part of the final URI), by removing them from
 1584|       |     *    the resolved path (i.e., discarding relative levels above the
 1585|       |     *    root), or by avoiding traversal of the reference.
 1586|       |     *
 1587|       |     * We discard them from the final path.
 1588|       |     */
 1589|    151|    if (path[0] == '/') {
  ------------------
  |  Branch (1589:9): [True: 0, False: 151]
  ------------------
 1590|      0|      cur = path;
 1591|      0|      while ((cur[0] == '/') && (cur[1] == '.') && (cur[2] == '.')
  ------------------
  |  Branch (1591:14): [True: 0, False: 0]
  |  Branch (1591:33): [True: 0, False: 0]
  |  Branch (1591:52): [True: 0, False: 0]
  ------------------
 1592|      0|             && ((cur[3] == '/') || (cur[3] == '\0')))
  ------------------
  |  Branch (1592:18): [True: 0, False: 0]
  |  Branch (1592:37): [True: 0, False: 0]
  ------------------
 1593|      0|	cur += 3;
 1594|       |
 1595|      0|      if (cur != path) {
  ------------------
  |  Branch (1595:11): [True: 0, False: 0]
  ------------------
 1596|      0|	out = path;
 1597|      0|	while (cur[0] != '\0')
  ------------------
  |  Branch (1597:9): [True: 0, False: 0]
  ------------------
 1598|      0|          (out++)[0] = (cur++)[0];
 1599|      0|	out[0] = 0;
 1600|      0|      }
 1601|      0|    }
 1602|       |
 1603|    151|    return(0);
 1604|    151|}
xmlURIUnescapeString:
 1629|  16.8k|xmlURIUnescapeString(const char *str, int len, char *target) {
 1630|  16.8k|    char *ret, *out;
 1631|  16.8k|    const char *in;
 1632|       |
 1633|  16.8k|    if (str == NULL)
  ------------------
  |  Branch (1633:9): [True: 0, False: 16.8k]
  ------------------
 1634|      0|	return(NULL);
 1635|  16.8k|    if (len <= 0) len = strlen(str);
  ------------------
  |  Branch (1635:9): [True: 16, False: 16.7k]
  ------------------
 1636|  16.8k|    if (len < 0) return(NULL);
  ------------------
  |  Branch (1636:9): [True: 0, False: 16.8k]
  ------------------
 1637|       |
 1638|  16.8k|    if (target == NULL) {
  ------------------
  |  Branch (1638:9): [True: 16.8k, False: 0]
  ------------------
 1639|  16.8k|	ret = (char *) xmlMallocAtomic(len + 1);
 1640|  16.8k|	if (ret == NULL) {
  ------------------
  |  Branch (1640:6): [True: 0, False: 16.8k]
  ------------------
 1641|      0|            xmlURIErrMemory("unescaping URI value\n");
 1642|      0|	    return(NULL);
 1643|      0|	}
 1644|  16.8k|    } else
 1645|      0|	ret = target;
 1646|  16.8k|    in = str;
 1647|  16.8k|    out = ret;
 1648|   148k|    while(len > 0) {
  ------------------
  |  Branch (1648:11): [True: 131k, False: 16.8k]
  ------------------
 1649|   131k|	if ((len > 2) && (*in == '%') && (is_hex(in[1])) && (is_hex(in[2]))) {
  ------------------
  |  Branch (1649:6): [True: 97.7k, False: 33.5k]
  |  Branch (1649:19): [True: 0, False: 97.7k]
  |  Branch (1649:35): [True: 0, False: 0]
  |  Branch (1649:54): [True: 0, False: 0]
  ------------------
 1650|      0|            int c = 0;
 1651|      0|	    in++;
 1652|      0|	    if ((*in >= '0') && (*in <= '9'))
  ------------------
  |  Branch (1652:10): [True: 0, False: 0]
  |  Branch (1652:26): [True: 0, False: 0]
  ------------------
 1653|      0|	        c = (*in - '0');
 1654|      0|	    else if ((*in >= 'a') && (*in <= 'f'))
  ------------------
  |  Branch (1654:15): [True: 0, False: 0]
  |  Branch (1654:31): [True: 0, False: 0]
  ------------------
 1655|      0|	        c = (*in - 'a') + 10;
 1656|      0|	    else if ((*in >= 'A') && (*in <= 'F'))
  ------------------
  |  Branch (1656:15): [True: 0, False: 0]
  |  Branch (1656:31): [True: 0, False: 0]
  ------------------
 1657|      0|	        c = (*in - 'A') + 10;
 1658|      0|	    in++;
 1659|      0|	    if ((*in >= '0') && (*in <= '9'))
  ------------------
  |  Branch (1659:10): [True: 0, False: 0]
  |  Branch (1659:26): [True: 0, False: 0]
  ------------------
 1660|      0|	        c = c * 16 + (*in - '0');
 1661|      0|	    else if ((*in >= 'a') && (*in <= 'f'))
  ------------------
  |  Branch (1661:15): [True: 0, False: 0]
  |  Branch (1661:31): [True: 0, False: 0]
  ------------------
 1662|      0|	        c = c * 16 + (*in - 'a') + 10;
 1663|      0|	    else if ((*in >= 'A') && (*in <= 'F'))
  ------------------
  |  Branch (1663:15): [True: 0, False: 0]
  |  Branch (1663:31): [True: 0, False: 0]
  ------------------
 1664|      0|	        c = c * 16 + (*in - 'A') + 10;
 1665|      0|	    in++;
 1666|      0|	    len -= 3;
 1667|       |            /* Explicit sign change */
 1668|      0|	    *out++ = (char) c;
 1669|   131k|	} else {
 1670|   131k|	    *out++ = *in++;
 1671|   131k|	    len--;
 1672|   131k|	}
 1673|   131k|    }
 1674|  16.8k|    *out = 0;
 1675|  16.8k|    return(ret);
 1676|  16.8k|}
xmlBuildURI:
 1902|    480|xmlBuildURI(const xmlChar *URI, const xmlChar *base) {
 1903|    480|    xmlChar *val = NULL;
 1904|    480|    int ret, len, indx, cur, out;
 1905|    480|    xmlURIPtr ref = NULL;
 1906|    480|    xmlURIPtr bas = NULL;
 1907|    480|    xmlURIPtr res = NULL;
 1908|       |
 1909|       |    /*
 1910|       |     * 1) The URI reference is parsed into the potential four components and
 1911|       |     *    fragment identifier, as described in Section 4.3.
 1912|       |     *
 1913|       |     *    NOTE that a completely empty URI is treated by modern browsers
 1914|       |     *    as a reference to "." rather than as a synonym for the current
 1915|       |     *    URI.  Should we do that here?
 1916|       |     */
 1917|    480|    if (URI == NULL)
  ------------------
  |  Branch (1917:9): [True: 0, False: 480]
  ------------------
 1918|      0|	ret = -1;
 1919|    480|    else {
 1920|    480|	if (*URI) {
  ------------------
  |  Branch (1920:6): [True: 480, False: 0]
  ------------------
 1921|    480|	    ref = xmlCreateURI();
 1922|    480|	    if (ref == NULL)
  ------------------
  |  Branch (1922:10): [True: 0, False: 480]
  ------------------
 1923|      0|		goto done;
 1924|    480|	    ret = xmlParseURIReference(ref, (const char *) URI);
 1925|    480|	}
 1926|      0|	else
 1927|      0|	    ret = 0;
 1928|    480|    }
 1929|    480|    if (ret != 0)
  ------------------
  |  Branch (1929:9): [True: 0, False: 480]
  ------------------
 1930|      0|	goto done;
 1931|    480|    if ((ref != NULL) && (ref->scheme != NULL)) {
  ------------------
  |  Branch (1931:9): [True: 480, False: 0]
  |  Branch (1931:26): [True: 234, False: 246]
  ------------------
 1932|       |	/*
 1933|       |	 * The URI is absolute don't modify.
 1934|       |	 */
 1935|    234|	val = xmlStrdup(URI);
 1936|    234|	goto done;
 1937|    234|    }
 1938|    246|    if (base == NULL)
  ------------------
  |  Branch (1938:9): [True: 92, False: 154]
  ------------------
 1939|     92|	ret = -1;
 1940|    154|    else {
 1941|    154|	bas = xmlCreateURI();
 1942|    154|	if (bas == NULL)
  ------------------
  |  Branch (1942:6): [True: 0, False: 154]
  ------------------
 1943|      0|	    goto done;
 1944|    154|	ret = xmlParseURIReference(bas, (const char *) base);
 1945|    154|    }
 1946|    246|    if (ret != 0) {
  ------------------
  |  Branch (1946:9): [True: 92, False: 154]
  ------------------
 1947|     92|	if (ref)
  ------------------
  |  Branch (1947:6): [True: 92, False: 0]
  ------------------
 1948|     92|	    val = xmlSaveUri(ref);
 1949|     92|	goto done;
 1950|     92|    }
 1951|    154|    if (ref == NULL) {
  ------------------
  |  Branch (1951:9): [True: 0, False: 154]
  ------------------
 1952|       |	/*
 1953|       |	 * the base fragment must be ignored
 1954|       |	 */
 1955|      0|	if (bas->fragment != NULL) {
  ------------------
  |  Branch (1955:6): [True: 0, False: 0]
  ------------------
 1956|      0|	    xmlFree(bas->fragment);
 1957|      0|	    bas->fragment = NULL;
 1958|      0|	}
 1959|      0|	val = xmlSaveUri(bas);
 1960|      0|	goto done;
 1961|      0|    }
 1962|       |
 1963|       |    /*
 1964|       |     * 2) If the path component is empty and the scheme, authority, and
 1965|       |     *    query components are undefined, then it is a reference to the
 1966|       |     *    current document and we are done.  Otherwise, the reference URI's
 1967|       |     *    query and fragment components are defined as found (or not found)
 1968|       |     *    within the URI reference and not inherited from the base URI.
 1969|       |     *
 1970|       |     *    NOTE that in modern browsers, the parsing differs from the above
 1971|       |     *    in the following aspect:  the query component is allowed to be
 1972|       |     *    defined while still treating this as a reference to the current
 1973|       |     *    document.
 1974|       |     */
 1975|    154|    res = xmlCreateURI();
 1976|    154|    if (res == NULL)
  ------------------
  |  Branch (1976:9): [True: 0, False: 154]
  ------------------
 1977|      0|	goto done;
 1978|    154|    if ((ref->scheme == NULL) && (ref->path == NULL) &&
  ------------------
  |  Branch (1978:9): [True: 154, False: 0]
  |  Branch (1978:34): [True: 0, False: 154]
  ------------------
 1979|    154|	((ref->authority == NULL) && (ref->server == NULL) &&
  ------------------
  |  Branch (1979:3): [True: 0, False: 0]
  |  Branch (1979:31): [True: 0, False: 0]
  ------------------
 1980|      0|         (ref->port == PORT_EMPTY))) {
  ------------------
  |  |   37|      0|#define PORT_EMPTY           0
  ------------------
  |  Branch (1980:10): [True: 0, False: 0]
  ------------------
 1981|      0|	if (bas->scheme != NULL)
  ------------------
  |  Branch (1981:6): [True: 0, False: 0]
  ------------------
 1982|      0|	    res->scheme = xmlMemStrdup(bas->scheme);
 1983|      0|	if (bas->authority != NULL)
  ------------------
  |  Branch (1983:6): [True: 0, False: 0]
  ------------------
 1984|      0|	    res->authority = xmlMemStrdup(bas->authority);
 1985|      0|	else {
 1986|      0|	    if (bas->server != NULL)
  ------------------
  |  Branch (1986:10): [True: 0, False: 0]
  ------------------
 1987|      0|		res->server = xmlMemStrdup(bas->server);
 1988|      0|	    if (bas->user != NULL)
  ------------------
  |  Branch (1988:10): [True: 0, False: 0]
  ------------------
 1989|      0|		res->user = xmlMemStrdup(bas->user);
 1990|      0|	    res->port = bas->port;
 1991|      0|	}
 1992|      0|	if (bas->path != NULL)
  ------------------
  |  Branch (1992:6): [True: 0, False: 0]
  ------------------
 1993|      0|	    res->path = xmlMemStrdup(bas->path);
 1994|      0|	if (ref->query_raw != NULL)
  ------------------
  |  Branch (1994:6): [True: 0, False: 0]
  ------------------
 1995|      0|	    res->query_raw = xmlMemStrdup (ref->query_raw);
 1996|      0|	else if (ref->query != NULL)
  ------------------
  |  Branch (1996:11): [True: 0, False: 0]
  ------------------
 1997|      0|	    res->query = xmlMemStrdup(ref->query);
 1998|      0|	else if (bas->query_raw != NULL)
  ------------------
  |  Branch (1998:11): [True: 0, False: 0]
  ------------------
 1999|      0|	    res->query_raw = xmlMemStrdup(bas->query_raw);
 2000|      0|	else if (bas->query != NULL)
  ------------------
  |  Branch (2000:11): [True: 0, False: 0]
  ------------------
 2001|      0|	    res->query = xmlMemStrdup(bas->query);
 2002|      0|	if (ref->fragment != NULL)
  ------------------
  |  Branch (2002:6): [True: 0, False: 0]
  ------------------
 2003|      0|	    res->fragment = xmlMemStrdup(ref->fragment);
 2004|      0|	goto step_7;
 2005|      0|    }
 2006|       |
 2007|       |    /*
 2008|       |     * 3) If the scheme component is defined, indicating that the reference
 2009|       |     *    starts with a scheme name, then the reference is interpreted as an
 2010|       |     *    absolute URI and we are done.  Otherwise, the reference URI's
 2011|       |     *    scheme is inherited from the base URI's scheme component.
 2012|       |     */
 2013|    154|    if (ref->scheme != NULL) {
  ------------------
  |  Branch (2013:9): [True: 0, False: 154]
  ------------------
 2014|      0|	val = xmlSaveUri(ref);
 2015|      0|	goto done;
 2016|      0|    }
 2017|    154|    if (bas->scheme != NULL)
  ------------------
  |  Branch (2017:9): [True: 0, False: 154]
  ------------------
 2018|      0|	res->scheme = xmlMemStrdup(bas->scheme);
 2019|       |
 2020|    154|    if (ref->query_raw != NULL)
  ------------------
  |  Branch (2020:9): [True: 0, False: 154]
  ------------------
 2021|      0|	res->query_raw = xmlMemStrdup(ref->query_raw);
 2022|    154|    else if (ref->query != NULL)
  ------------------
  |  Branch (2022:14): [True: 0, False: 154]
  ------------------
 2023|      0|	res->query = xmlMemStrdup(ref->query);
 2024|    154|    if (ref->fragment != NULL)
  ------------------
  |  Branch (2024:9): [True: 0, False: 154]
  ------------------
 2025|      0|	res->fragment = xmlMemStrdup(ref->fragment);
 2026|       |
 2027|       |    /*
 2028|       |     * 4) If the authority component is defined, then the reference is a
 2029|       |     *    network-path and we skip to step 7.  Otherwise, the reference
 2030|       |     *    URI's authority is inherited from the base URI's authority
 2031|       |     *    component, which will also be undefined if the URI scheme does not
 2032|       |     *    use an authority component.
 2033|       |     */
 2034|    154|    if ((ref->authority != NULL) || (ref->server != NULL) ||
  ------------------
  |  Branch (2034:9): [True: 0, False: 154]
  |  Branch (2034:37): [True: 0, False: 154]
  ------------------
 2035|    154|         (ref->port != PORT_EMPTY)) {
  ------------------
  |  |   37|    154|#define PORT_EMPTY           0
  ------------------
  |  Branch (2035:10): [True: 0, False: 154]
  ------------------
 2036|      0|	if (ref->authority != NULL)
  ------------------
  |  Branch (2036:6): [True: 0, False: 0]
  ------------------
 2037|      0|	    res->authority = xmlMemStrdup(ref->authority);
 2038|      0|	else {
 2039|      0|            if (ref->server != NULL)
  ------------------
  |  Branch (2039:17): [True: 0, False: 0]
  ------------------
 2040|      0|                res->server = xmlMemStrdup(ref->server);
 2041|      0|	    if (ref->user != NULL)
  ------------------
  |  Branch (2041:10): [True: 0, False: 0]
  ------------------
 2042|      0|		res->user = xmlMemStrdup(ref->user);
 2043|      0|            res->port = ref->port;
 2044|      0|	}
 2045|      0|	if (ref->path != NULL)
  ------------------
  |  Branch (2045:6): [True: 0, False: 0]
  ------------------
 2046|      0|	    res->path = xmlMemStrdup(ref->path);
 2047|      0|	goto step_7;
 2048|      0|    }
 2049|    154|    if (bas->authority != NULL)
  ------------------
  |  Branch (2049:9): [True: 0, False: 154]
  ------------------
 2050|      0|	res->authority = xmlMemStrdup(bas->authority);
 2051|    154|    else if ((bas->server != NULL) || (bas->port != PORT_EMPTY)) {
  ------------------
  |  |   37|    154|#define PORT_EMPTY           0
  ------------------
  |  Branch (2051:14): [True: 0, False: 154]
  |  Branch (2051:39): [True: 0, False: 154]
  ------------------
 2052|      0|	if (bas->server != NULL)
  ------------------
  |  Branch (2052:6): [True: 0, False: 0]
  ------------------
 2053|      0|	    res->server = xmlMemStrdup(bas->server);
 2054|      0|	if (bas->user != NULL)
  ------------------
  |  Branch (2054:6): [True: 0, False: 0]
  ------------------
 2055|      0|	    res->user = xmlMemStrdup(bas->user);
 2056|      0|	res->port = bas->port;
 2057|      0|    }
 2058|       |
 2059|       |    /*
 2060|       |     * 5) If the path component begins with a slash character ("/"), then
 2061|       |     *    the reference is an absolute-path and we skip to step 7.
 2062|       |     */
 2063|    154|    if ((ref->path != NULL) && (ref->path[0] == '/')) {
  ------------------
  |  Branch (2063:9): [True: 154, False: 0]
  |  Branch (2063:32): [True: 3, False: 151]
  ------------------
 2064|      3|	res->path = xmlMemStrdup(ref->path);
 2065|      3|	goto step_7;
 2066|      3|    }
 2067|       |
 2068|       |
 2069|       |    /*
 2070|       |     * 6) If this step is reached, then we are resolving a relative-path
 2071|       |     *    reference.  The relative path needs to be merged with the base
 2072|       |     *    URI's path.  Although there are many ways to do this, we will
 2073|       |     *    describe a simple method using a separate string buffer.
 2074|       |     *
 2075|       |     * Allocate a buffer large enough for the result string.
 2076|       |     */
 2077|    151|    len = 2; /* extra / and 0 */
 2078|    151|    if (ref->path != NULL)
  ------------------
  |  Branch (2078:9): [True: 151, False: 0]
  ------------------
 2079|    151|	len += strlen(ref->path);
 2080|    151|    if (bas->path != NULL)
  ------------------
  |  Branch (2080:9): [True: 151, False: 0]
  ------------------
 2081|    151|	len += strlen(bas->path);
 2082|    151|    res->path = (char *) xmlMallocAtomic(len);
 2083|    151|    if (res->path == NULL) {
  ------------------
  |  Branch (2083:9): [True: 0, False: 151]
  ------------------
 2084|      0|        xmlURIErrMemory("resolving URI against base\n");
 2085|      0|	goto done;
 2086|      0|    }
 2087|    151|    res->path[0] = 0;
 2088|       |
 2089|       |    /*
 2090|       |     * a) All but the last segment of the base URI's path component is
 2091|       |     *    copied to the buffer.  In other words, any characters after the
 2092|       |     *    last (right-most) slash character, if any, are excluded.
 2093|       |     */
 2094|    151|    cur = 0;
 2095|    151|    out = 0;
 2096|    151|    if (bas->path != NULL) {
  ------------------
  |  Branch (2096:9): [True: 151, False: 0]
  ------------------
 2097|    159|	while (bas->path[cur] != 0) {
  ------------------
  |  Branch (2097:9): [True: 159, False: 0]
  ------------------
 2098|  1.79k|	    while ((bas->path[cur] != 0) && (bas->path[cur] != '/'))
  ------------------
  |  Branch (2098:13): [True: 1.63k, False: 151]
  |  Branch (2098:38): [True: 1.63k, False: 8]
  ------------------
 2099|  1.63k|		cur++;
 2100|    159|	    if (bas->path[cur] == 0)
  ------------------
  |  Branch (2100:10): [True: 151, False: 8]
  ------------------
 2101|    151|		break;
 2102|       |
 2103|      8|	    cur++;
 2104|     48|	    while (out < cur) {
  ------------------
  |  Branch (2104:13): [True: 40, False: 8]
  ------------------
 2105|     40|		res->path[out] = bas->path[out];
 2106|     40|		out++;
 2107|     40|	    }
 2108|      8|	}
 2109|    151|    }
 2110|    151|    res->path[out] = 0;
 2111|       |
 2112|       |    /*
 2113|       |     * b) The reference's path component is appended to the buffer
 2114|       |     *    string.
 2115|       |     */
 2116|    151|    if (ref->path != NULL && ref->path[0] != 0) {
  ------------------
  |  Branch (2116:9): [True: 151, False: 0]
  |  Branch (2116:30): [True: 151, False: 0]
  ------------------
 2117|    151|	indx = 0;
 2118|       |	/*
 2119|       |	 * Ensure the path includes a '/'
 2120|       |	 */
 2121|    151|	if ((out == 0) && ((bas->server != NULL) || bas->port != PORT_EMPTY))
  ------------------
  |  |   37|    143|#define PORT_EMPTY           0
  ------------------
  |  Branch (2121:6): [True: 143, False: 8]
  |  Branch (2121:21): [True: 0, False: 143]
  |  Branch (2121:46): [True: 0, False: 143]
  ------------------
 2122|      0|	    res->path[out++] = '/';
 2123|  2.00k|	while (ref->path[indx] != 0) {
  ------------------
  |  Branch (2123:9): [True: 1.85k, False: 151]
  ------------------
 2124|  1.85k|	    res->path[out++] = ref->path[indx++];
 2125|  1.85k|	}
 2126|    151|    }
 2127|    151|    res->path[out] = 0;
 2128|       |
 2129|       |    /*
 2130|       |     * Steps c) to h) are really path normalization steps
 2131|       |     */
 2132|    151|    xmlNormalizeURIPath(res->path);
 2133|       |
 2134|    154|step_7:
 2135|       |
 2136|       |    /*
 2137|       |     * 7) The resulting URI components, including any inherited from the
 2138|       |     *    base URI, are recombined to give the absolute form of the URI
 2139|       |     *    reference.
 2140|       |     */
 2141|    154|    val = xmlSaveUri(res);
 2142|       |
 2143|    480|done:
 2144|    480|    if (ref != NULL)
  ------------------
  |  Branch (2144:9): [True: 480, False: 0]
  ------------------
 2145|    480|	xmlFreeURI(ref);
 2146|    480|    if (bas != NULL)
  ------------------
  |  Branch (2146:9): [True: 154, False: 326]
  ------------------
 2147|    154|	xmlFreeURI(bas);
 2148|    480|    if (res != NULL)
  ------------------
  |  Branch (2148:9): [True: 154, False: 326]
  ------------------
 2149|    154|	xmlFreeURI(res);
 2150|    480|    return(val);
 2151|    154|}
xmlCanonicPath:
 2395|  13.9k|{
 2396|       |/*
 2397|       | * For Windows implementations, additional work needs to be done to
 2398|       | * replace backslashes in pathnames with "forward slashes"
 2399|       | */
 2400|       |#if defined(_WIN32)
 2401|       |    int len = 0;
 2402|       |    char *p = NULL;
 2403|       |#endif
 2404|  13.9k|    xmlURIPtr uri;
 2405|  13.9k|    xmlChar *ret;
 2406|  13.9k|    const xmlChar *absuri;
 2407|       |
 2408|  13.9k|    if (path == NULL)
  ------------------
  |  Branch (2408:9): [True: 0, False: 13.9k]
  ------------------
 2409|      0|	return(NULL);
 2410|       |
 2411|       |#if defined(_WIN32)
 2412|       |    /*
 2413|       |     * We must not change the backslashes to slashes if the the path
 2414|       |     * starts with \\?\
 2415|       |     * Those paths can be up to 32k characters long.
 2416|       |     * Was added specifically for OpenOffice, those paths can't be converted
 2417|       |     * to URIs anyway.
 2418|       |     */
 2419|       |    if ((path[0] == '\\') && (path[1] == '\\') && (path[2] == '?') &&
 2420|       |        (path[3] == '\\') )
 2421|       |	return xmlStrdup((const xmlChar *) path);
 2422|       |#endif
 2423|       |
 2424|       |	/* sanitize filename starting with // so it can be used as URI */
 2425|  13.9k|    if ((path[0] == '/') && (path[1] == '/') && (path[2] != '/'))
  ------------------
  |  Branch (2425:9): [True: 4, False: 13.9k]
  |  Branch (2425:29): [True: 0, False: 4]
  |  Branch (2425:49): [True: 0, False: 0]
  ------------------
 2426|      0|        path++;
 2427|       |
 2428|  13.9k|    if ((uri = xmlParseURI((const char *) path)) != NULL) {
  ------------------
  |  Branch (2428:9): [True: 13.9k, False: 0]
  ------------------
 2429|  13.9k|	xmlFreeURI(uri);
 2430|  13.9k|	return xmlStrdup(path);
 2431|  13.9k|    }
 2432|       |
 2433|       |    /* Check if this is an "absolute uri" */
 2434|      0|    absuri = xmlStrstr(path, BAD_CAST "://");
  ------------------
  |  |   35|      0|#define BAD_CAST (xmlChar *)
  ------------------
 2435|      0|    if (absuri != NULL) {
  ------------------
  |  Branch (2435:9): [True: 0, False: 0]
  ------------------
 2436|      0|        int l, j;
 2437|      0|	unsigned char c;
 2438|      0|	xmlChar *escURI;
 2439|       |
 2440|       |        /*
 2441|       |	 * this looks like an URI where some parts have not been
 2442|       |	 * escaped leading to a parsing problem.  Check that the first
 2443|       |	 * part matches a protocol.
 2444|       |	 */
 2445|      0|	l = absuri - path;
 2446|       |	/* Bypass if first part (part before the '://') is > 20 chars */
 2447|      0|	if ((l <= 0) || (l > 20))
  ------------------
  |  Branch (2447:6): [True: 0, False: 0]
  |  Branch (2447:18): [True: 0, False: 0]
  ------------------
 2448|      0|	    goto path_processing;
 2449|       |	/* Bypass if any non-alpha characters are present in first part */
 2450|      0|	for (j = 0;j < l;j++) {
  ------------------
  |  Branch (2450:13): [True: 0, False: 0]
  ------------------
 2451|      0|	    c = path[j];
 2452|      0|	    if (!(((c >= 'a') && (c <= 'z')) || ((c >= 'A') && (c <= 'Z'))))
  ------------------
  |  Branch (2452:13): [True: 0, False: 0]
  |  Branch (2452:27): [True: 0, False: 0]
  |  Branch (2452:43): [True: 0, False: 0]
  |  Branch (2452:57): [True: 0, False: 0]
  ------------------
 2453|      0|	        goto path_processing;
 2454|      0|	}
 2455|       |
 2456|       |	/* Escape all except the characters specified in the supplied path */
 2457|      0|        escURI = xmlURIEscapeStr(path, BAD_CAST ":/?_.#&;=");
  ------------------
  |  |   35|      0|#define BAD_CAST (xmlChar *)
  ------------------
 2458|      0|	if (escURI != NULL) {
  ------------------
  |  Branch (2458:6): [True: 0, False: 0]
  ------------------
 2459|       |	    /* Try parsing the escaped path */
 2460|      0|	    uri = xmlParseURI((const char *) escURI);
 2461|       |	    /* If successful, return the escaped string */
 2462|      0|	    if (uri != NULL) {
  ------------------
  |  Branch (2462:10): [True: 0, False: 0]
  ------------------
 2463|      0|	        xmlFreeURI(uri);
 2464|      0|		return escURI;
 2465|      0|	    }
 2466|      0|            xmlFree(escURI);
 2467|      0|	}
 2468|      0|    }
 2469|       |
 2470|      0|path_processing:
 2471|       |/* For Windows implementations, replace backslashes with 'forward slashes' */
 2472|       |#if defined(_WIN32)
 2473|       |    /*
 2474|       |     * Create a URI structure
 2475|       |     */
 2476|       |    uri = xmlCreateURI();
 2477|       |    if (uri == NULL) {		/* Guard against 'out of memory' */
 2478|       |        return(NULL);
 2479|       |    }
 2480|       |
 2481|       |    len = xmlStrlen(path);
 2482|       |    if ((len > 2) && IS_WINDOWS_PATH(path)) {
 2483|       |        /* make the scheme 'file' */
 2484|       |	uri->scheme = (char *) xmlStrdup(BAD_CAST "file");
 2485|       |	/* allocate space for leading '/' + path + string terminator */
 2486|       |	uri->path = xmlMallocAtomic(len + 2);
 2487|       |	if (uri->path == NULL) {
 2488|       |	    xmlFreeURI(uri);	/* Guard against 'out of memory' */
 2489|       |	    return(NULL);
 2490|       |	}
 2491|       |	/* Put in leading '/' plus path */
 2492|       |	uri->path[0] = '/';
 2493|       |	p = uri->path + 1;
 2494|       |	strncpy(p, (char *) path, len + 1);
 2495|       |    } else {
 2496|       |	uri->path = (char *) xmlStrdup(path);
 2497|       |	if (uri->path == NULL) {
 2498|       |	    xmlFreeURI(uri);
 2499|       |	    return(NULL);
 2500|       |	}
 2501|       |	p = uri->path;
 2502|       |    }
 2503|       |    /* Now change all occurrences of '\' to '/' */
 2504|       |    while (*p != '\0') {
 2505|       |	if (*p == '\\')
 2506|       |	    *p = '/';
 2507|       |	p++;
 2508|       |    }
 2509|       |
 2510|       |    if (uri->scheme == NULL) {
 2511|       |	ret = xmlStrdup((const xmlChar *) uri->path);
 2512|       |    } else {
 2513|       |	ret = xmlSaveUri(uri);
 2514|       |    }
 2515|       |
 2516|       |    xmlFreeURI(uri);
 2517|       |#else
 2518|      0|    ret = xmlStrdup((const xmlChar *) path);
 2519|      0|#endif
 2520|      0|    return(ret);
 2521|      0|}
xmlPathToURI:
 2536|    966|{
 2537|    966|    xmlURIPtr uri;
 2538|    966|    xmlURI temp;
 2539|    966|    xmlChar *ret, *cal;
 2540|       |
 2541|    966|    if (path == NULL)
  ------------------
  |  Branch (2541:9): [True: 0, False: 966]
  ------------------
 2542|      0|        return(NULL);
 2543|       |
 2544|    966|    if ((uri = xmlParseURI((const char *) path)) != NULL) {
  ------------------
  |  Branch (2544:9): [True: 966, False: 0]
  ------------------
 2545|    966|	xmlFreeURI(uri);
 2546|    966|	return xmlStrdup(path);
 2547|    966|    }
 2548|      0|    cal = xmlCanonicPath(path);
 2549|      0|    if (cal == NULL)
  ------------------
  |  Branch (2549:9): [True: 0, False: 0]
  ------------------
 2550|      0|        return(NULL);
 2551|       |#if defined(_WIN32)
 2552|       |    /* xmlCanonicPath can return an URI on Windows (is that the intended behaviour?)
 2553|       |       If 'cal' is a valid URI already then we are done here, as continuing would make
 2554|       |       it invalid. */
 2555|       |    if ((uri = xmlParseURI((const char *) cal)) != NULL) {
 2556|       |	xmlFreeURI(uri);
 2557|       |	return cal;
 2558|       |    }
 2559|       |    /* 'cal' can contain a relative path with backslashes. If that is processed
 2560|       |       by xmlSaveURI, they will be escaped and the external entity loader machinery
 2561|       |       will fail. So convert them to slashes. Misuse 'ret' for walking. */
 2562|       |    ret = cal;
 2563|       |    while (*ret != '\0') {
 2564|       |	if (*ret == '\\')
 2565|       |	    *ret = '/';
 2566|       |	ret++;
 2567|       |    }
 2568|       |#endif
 2569|      0|    memset(&temp, 0, sizeof(temp));
 2570|      0|    temp.path = (char *) cal;
 2571|      0|    ret = xmlSaveUri(&temp);
 2572|      0|    xmlFree(cal);
 2573|      0|    return(ret);
 2574|      0|}
uri.c:xmlParse3986URIReference:
  913|  15.9k|xmlParse3986URIReference(xmlURIPtr uri, const char *str) {
  914|  15.9k|    int ret;
  915|       |
  916|  15.9k|    if (str == NULL)
  ------------------
  |  Branch (916:9): [True: 0, False: 15.9k]
  ------------------
  917|      0|	return(-1);
  918|  15.9k|    xmlCleanURI(uri);
  919|       |
  920|       |    /*
  921|       |     * Try first to parse absolute refs, then fallback to relative if
  922|       |     * it fails.
  923|       |     */
  924|  15.9k|    ret = xmlParse3986URI(uri, str);
  925|  15.9k|    if (ret != 0) {
  ------------------
  |  Branch (925:9): [True: 15.1k, False: 872]
  ------------------
  926|  15.1k|	xmlCleanURI(uri);
  927|  15.1k|        ret = xmlParse3986RelativeRef(uri, str);
  928|  15.1k|	if (ret != 0) {
  ------------------
  |  Branch (928:6): [True: 0, False: 15.1k]
  ------------------
  929|      0|	    xmlCleanURI(uri);
  930|      0|	    return(ret);
  931|      0|	}
  932|  15.1k|    }
  933|  15.9k|    return(0);
  934|  15.9k|}
uri.c:xmlCleanURI:
 1366|  31.1k|xmlCleanURI(xmlURIPtr uri) {
 1367|  31.1k|    if (uri == NULL) return;
  ------------------
  |  Branch (1367:9): [True: 0, False: 31.1k]
  ------------------
 1368|       |
 1369|  31.1k|    if (uri->scheme != NULL) xmlFree(uri->scheme);
  ------------------
  |  Branch (1369:9): [True: 15.0k, False: 16.1k]
  ------------------
 1370|  31.1k|    uri->scheme = NULL;
 1371|  31.1k|    if (uri->server != NULL) xmlFree(uri->server);
  ------------------
  |  Branch (1371:9): [True: 0, False: 31.1k]
  ------------------
 1372|  31.1k|    uri->server = NULL;
 1373|  31.1k|    if (uri->user != NULL) xmlFree(uri->user);
  ------------------
  |  Branch (1373:9): [True: 0, False: 31.1k]
  ------------------
 1374|  31.1k|    uri->user = NULL;
 1375|  31.1k|    if (uri->path != NULL) xmlFree(uri->path);
  ------------------
  |  Branch (1375:9): [True: 0, False: 31.1k]
  ------------------
 1376|  31.1k|    uri->path = NULL;
 1377|  31.1k|    if (uri->fragment != NULL) xmlFree(uri->fragment);
  ------------------
  |  Branch (1377:9): [True: 0, False: 31.1k]
  ------------------
 1378|  31.1k|    uri->fragment = NULL;
 1379|  31.1k|    if (uri->opaque != NULL) xmlFree(uri->opaque);
  ------------------
  |  Branch (1379:9): [True: 0, False: 31.1k]
  ------------------
 1380|  31.1k|    uri->opaque = NULL;
 1381|  31.1k|    if (uri->authority != NULL) xmlFree(uri->authority);
  ------------------
  |  Branch (1381:9): [True: 0, False: 31.1k]
  ------------------
 1382|  31.1k|    uri->authority = NULL;
 1383|  31.1k|    if (uri->query != NULL) xmlFree(uri->query);
  ------------------
  |  Branch (1383:9): [True: 0, False: 31.1k]
  ------------------
 1384|  31.1k|    uri->query = NULL;
 1385|  31.1k|    if (uri->query_raw != NULL) xmlFree(uri->query_raw);
  ------------------
  |  Branch (1385:9): [True: 0, False: 31.1k]
  ------------------
 1386|  31.1k|    uri->query_raw = NULL;
 1387|  31.1k|}
uri.c:xmlParse3986URI:
  872|  15.9k|xmlParse3986URI(xmlURIPtr uri, const char *str) {
  873|  15.9k|    int ret;
  874|       |
  875|  15.9k|    ret = xmlParse3986Scheme(uri, &str);
  876|  15.9k|    if (ret != 0) return(ret);
  ------------------
  |  Branch (876:9): [True: 103, False: 15.8k]
  ------------------
  877|  15.8k|    if (*str != ':') {
  ------------------
  |  Branch (877:9): [True: 15.0k, False: 872]
  ------------------
  878|  15.0k|	return(1);
  879|  15.0k|    }
  880|    872|    str++;
  881|    872|    ret = xmlParse3986HierPart(uri, &str);
  882|    872|    if (ret != 0) return(ret);
  ------------------
  |  Branch (882:9): [True: 0, False: 872]
  ------------------
  883|    872|    if (*str == '?') {
  ------------------
  |  Branch (883:9): [True: 0, False: 872]
  ------------------
  884|      0|	str++;
  885|      0|	ret = xmlParse3986Query(uri, &str);
  886|      0|	if (ret != 0) return(ret);
  ------------------
  |  Branch (886:6): [True: 0, False: 0]
  ------------------
  887|      0|    }
  888|    872|    if (*str == '#') {
  ------------------
  |  Branch (888:9): [True: 20, False: 852]
  ------------------
  889|     20|	str++;
  890|     20|	ret = xmlParse3986Fragment(uri, &str);
  891|     20|	if (ret != 0) return(ret);
  ------------------
  |  Branch (891:6): [True: 0, False: 20]
  ------------------
  892|     20|    }
  893|    872|    if (*str != 0) {
  ------------------
  |  Branch (893:9): [True: 0, False: 872]
  ------------------
  894|      0|	xmlCleanURI(uri);
  895|      0|	return(1);
  896|      0|    }
  897|    872|    return(0);
  898|    872|}
uri.c:xmlParse3986Scheme:
  213|  15.9k|xmlParse3986Scheme(xmlURIPtr uri, const char **str) {
  214|  15.9k|    const char *cur;
  215|       |
  216|  15.9k|    if (str == NULL)
  ------------------
  |  Branch (216:9): [True: 0, False: 15.9k]
  ------------------
  217|      0|	return(-1);
  218|       |
  219|  15.9k|    cur = *str;
  220|  15.9k|    if (!ISA_ALPHA(cur))
  ------------------
  |  |  152|  15.9k|#define ISA_ALPHA(p) (((*(p) >= 'a') && (*(p) <= 'z')) ||		\
  |  |  ------------------
  |  |  |  Branch (152:24): [True: 15.7k, False: 226]
  |  |  |  Branch (152:41): [True: 15.7k, False: 0]
  |  |  ------------------
  |  |  153|  15.9k|                      ((*(p) >= 'A') && (*(p) <= 'Z')))
  |  |  ------------------
  |  |  |  Branch (153:24): [True: 123, False: 103]
  |  |  |  Branch (153:41): [True: 123, False: 0]
  |  |  ------------------
  ------------------
  221|    103|	return(2);
  222|  15.8k|    cur++;
  223|  96.6k|    while (ISA_ALPHA(cur) || ISA_DIGIT(cur) ||
  ------------------
  |  |  152|   193k|#define ISA_ALPHA(p) (((*(p) >= 'a') && (*(p) <= 'z')) ||		\
  |  |  ------------------
  |  |  |  Branch (152:24): [True: 51.6k, False: 45.0k]
  |  |  |  Branch (152:41): [True: 51.6k, False: 0]
  |  |  ------------------
  |  |  153|   193k|                      ((*(p) >= 'A') && (*(p) <= 'Z')))
  |  |  ------------------
  |  |  |  Branch (153:24): [True: 549, False: 44.4k]
  |  |  |  Branch (153:41): [True: 303, False: 246]
  |  |  ------------------
  ------------------
                  while (ISA_ALPHA(cur) || ISA_DIGIT(cur) ||
  ------------------
  |  |  151|   141k|#define ISA_DIGIT(p) ((*(p) >= '0') && (*(p) <= '9'))
  |  |  ------------------
  |  |  |  Branch (151:23): [True: 15.5k, False: 29.1k]
  |  |  |  Branch (151:40): [True: 14.4k, False: 1.11k]
  |  |  ------------------
  ------------------
  224|  96.6k|           (*cur == '+') || (*cur == '-') || (*cur == '.')) cur++;
  ------------------
  |  Branch (224:12): [True: 0, False: 30.2k]
  |  Branch (224:29): [True: 310, False: 29.9k]
  |  Branch (224:46): [True: 14.0k, False: 15.8k]
  ------------------
  225|  15.8k|    if (uri != NULL) {
  ------------------
  |  Branch (225:9): [True: 15.8k, False: 0]
  ------------------
  226|  15.8k|	if (uri->scheme != NULL) xmlFree(uri->scheme);
  ------------------
  |  Branch (226:6): [True: 0, False: 15.8k]
  ------------------
  227|  15.8k|	uri->scheme = STRNDUP(*str, cur - *str);
  ------------------
  |  |  143|  15.8k|#define STRNDUP(s, n) (char *) xmlStrndup((const xmlChar *)(s), (n))
  ------------------
  228|  15.8k|    }
  229|  15.8k|    *str = cur;
  230|  15.8k|    return(0);
  231|  15.9k|}
uri.c:xmlParse3986HierPart:
  765|    872|{
  766|    872|    const char *cur;
  767|    872|    int ret;
  768|       |
  769|    872|    cur = *str;
  770|       |
  771|    872|    if ((*cur == '/') && (*(cur + 1) == '/')) {
  ------------------
  |  Branch (771:9): [True: 808, False: 64]
  |  Branch (771:26): [True: 808, False: 0]
  ------------------
  772|    808|        cur += 2;
  773|    808|	ret = xmlParse3986Authority(uri, &cur);
  774|    808|	if (ret != 0) return(ret);
  ------------------
  |  Branch (774:6): [True: 0, False: 808]
  ------------------
  775|       |        /*
  776|       |         * An empty server is marked with a special URI value.
  777|       |         */
  778|    808|	if ((uri->server == NULL) && (uri->port == PORT_EMPTY))
  ------------------
  |  |   37|      0|#define PORT_EMPTY           0
  ------------------
  |  Branch (778:6): [True: 0, False: 808]
  |  Branch (778:31): [True: 0, False: 0]
  ------------------
  779|      0|	    uri->port = PORT_EMPTY_SERVER;
  ------------------
  |  |   38|      0|#define PORT_EMPTY_SERVER   -1
  ------------------
  780|    808|	ret = xmlParse3986PathAbEmpty(uri, &cur);
  781|    808|	if (ret != 0) return(ret);
  ------------------
  |  Branch (781:6): [True: 0, False: 808]
  ------------------
  782|    808|	*str = cur;
  783|    808|	return(0);
  784|    808|    } else if (*cur == '/') {
  ------------------
  |  Branch (784:16): [True: 0, False: 64]
  ------------------
  785|      0|        ret = xmlParse3986PathAbsolute(uri, &cur);
  786|      0|	if (ret != 0) return(ret);
  ------------------
  |  Branch (786:6): [True: 0, False: 0]
  ------------------
  787|     64|    } else if (ISA_PCHAR(cur)) {
  ------------------
  |  |  198|     64|     (ISA_UNRESERVED(p) || ISA_PCT_ENCODED(p) || ISA_SUB_DELIM(p) ||	\
  |  |  ------------------
  |  |  |  |  185|    128|      ((ISA_ALPHA(p)) || (ISA_DIGIT(p)) || ((*(p) == '-')) ||		\
  |  |  |  |  ------------------
  |  |  |  |  |  |  152|     64|#define ISA_ALPHA(p) (((*(p) >= 'a') && (*(p) <= 'z')) ||		\
  |  |  |  |  |  |  ------------------
  |  |  |  |  |  |  |  Branch (152:24): [True: 64, False: 0]
  |  |  |  |  |  |  |  Branch (152:41): [True: 64, False: 0]
  |  |  |  |  |  |  ------------------
  |  |  |  |  |  |  153|     64|                      ((*(p) >= 'A') && (*(p) <= 'Z')))
  |  |  |  |  |  |  ------------------
  |  |  |  |  |  |  |  Branch (153:24): [True: 0, False: 0]
  |  |  |  |  |  |  |  Branch (153:41): [True: 0, False: 0]
  |  |  |  |  |  |  ------------------
  |  |  |  |  ------------------
  |  |  |  |                     ((ISA_ALPHA(p)) || (ISA_DIGIT(p)) || ((*(p) == '-')) ||		\
  |  |  |  |  ------------------
  |  |  |  |  |  |  151|      0|#define ISA_DIGIT(p) ((*(p) >= '0') && (*(p) <= '9'))
  |  |  |  |  |  |  ------------------
  |  |  |  |  |  |  |  Branch (151:23): [True: 0, False: 0]
  |  |  |  |  |  |  |  Branch (151:40): [True: 0, False: 0]
  |  |  |  |  |  |  ------------------
  |  |  |  |  ------------------
  |  |  |  |  |  Branch (185:44): [True: 0, False: 0]
  |  |  |  |  ------------------
  |  |  |  |  186|     64|       ((*(p) == '.')) || ((*(p) == '_')) || ((*(p) == '~')))
  |  |  |  |  ------------------
  |  |  |  |  |  Branch (186:8): [True: 0, False: 0]
  |  |  |  |  |  Branch (186:27): [True: 0, False: 0]
  |  |  |  |  |  Branch (186:46): [True: 0, False: 0]
  |  |  |  |  ------------------
  |  |  ------------------
  |  |                    (ISA_UNRESERVED(p) || ISA_PCT_ENCODED(p) || ISA_SUB_DELIM(p) ||	\
  |  |  ------------------
  |  |  |  |  192|     64|     ((*(p) == '%') && (ISA_HEXDIG(p + 1)) && (ISA_HEXDIG(p + 2)))
  |  |  |  |  ------------------
  |  |  |  |  |  |  155|      0|       (ISA_DIGIT(p) || ((*(p) >= 'a') && (*(p) <= 'f')) ||		\
  |  |  |  |  |  |  ------------------
  |  |  |  |  |  |  |  |  151|      0|#define ISA_DIGIT(p) ((*(p) >= '0') && (*(p) <= '9'))
  |  |  |  |  |  |  |  |  ------------------
  |  |  |  |  |  |  |  |  |  Branch (151:23): [True: 0, False: 0]
  |  |  |  |  |  |  |  |  |  Branch (151:40): [True: 0, False: 0]
  |  |  |  |  |  |  |  |  ------------------
  |  |  |  |  |  |  ------------------
  |  |  |  |  |  |  |  Branch (155:26): [True: 0, False: 0]
  |  |  |  |  |  |  |  Branch (155:43): [True: 0, False: 0]
  |  |  |  |  |  |  ------------------
  |  |  |  |  |  |  156|      0|        ((*(p) >= 'A') && (*(p) <= 'F')))
  |  |  |  |  |  |  ------------------
  |  |  |  |  |  |  |  Branch (156:10): [True: 0, False: 0]
  |  |  |  |  |  |  |  Branch (156:27): [True: 0, False: 0]
  |  |  |  |  |  |  ------------------
  |  |  |  |  ------------------
  |  |  |  |                    ((*(p) == '%') && (ISA_HEXDIG(p + 1)) && (ISA_HEXDIG(p + 2)))
  |  |  |  |  ------------------
  |  |  |  |  |  |  155|      0|       (ISA_DIGIT(p) || ((*(p) >= 'a') && (*(p) <= 'f')) ||		\
  |  |  |  |  |  |  ------------------
  |  |  |  |  |  |  |  |  151|      0|#define ISA_DIGIT(p) ((*(p) >= '0') && (*(p) <= '9'))
  |  |  |  |  |  |  |  |  ------------------
  |  |  |  |  |  |  |  |  |  Branch (151:23): [True: 0, False: 0]
  |  |  |  |  |  |  |  |  |  Branch (151:40): [True: 0, False: 0]
  |  |  |  |  |  |  |  |  ------------------
  |  |  |  |  |  |  ------------------
  |  |  |  |  |  |  |  Branch (155:26): [True: 0, False: 0]
  |  |  |  |  |  |  |  Branch (155:43): [True: 0, False: 0]
  |  |  |  |  |  |  ------------------
  |  |  |  |  |  |  156|      0|        ((*(p) >= 'A') && (*(p) <= 'F')))
  |  |  |  |  |  |  ------------------
  |  |  |  |  |  |  |  Branch (156:10): [True: 0, False: 0]
  |  |  |  |  |  |  |  Branch (156:27): [True: 0, False: 0]
  |  |  |  |  |  |  ------------------
  |  |  |  |  ------------------
  |  |  |  |  |  Branch (192:7): [True: 0, False: 0]
  |  |  |  |  ------------------
  |  |  ------------------
  |  |                    (ISA_UNRESERVED(p) || ISA_PCT_ENCODED(p) || ISA_SUB_DELIM(p) ||	\
  |  |  ------------------
  |  |  |  |  163|     64|      (((*(p) == '!')) || ((*(p) == '$')) || ((*(p) == '&')) ||		\
  |  |  |  |  ------------------
  |  |  |  |  |  Branch (163:8): [True: 0, False: 0]
  |  |  |  |  |  Branch (163:27): [True: 0, False: 0]
  |  |  |  |  |  Branch (163:46): [True: 0, False: 0]
  |  |  |  |  ------------------
  |  |  |  |  164|      0|       ((*(p) == '(')) || ((*(p) == ')')) || ((*(p) == '*')) ||		\
  |  |  |  |  ------------------
  |  |  |  |  |  Branch (164:8): [True: 0, False: 0]
  |  |  |  |  |  Branch (164:27): [True: 0, False: 0]
  |  |  |  |  |  Branch (164:46): [True: 0, False: 0]
  |  |  |  |  ------------------
  |  |  |  |  165|      0|       ((*(p) == '+')) || ((*(p) == ',')) || ((*(p) == ';')) ||		\
  |  |  |  |  ------------------
  |  |  |  |  |  Branch (165:8): [True: 0, False: 0]
  |  |  |  |  |  Branch (165:27): [True: 0, False: 0]
  |  |  |  |  |  Branch (165:46): [True: 0, False: 0]
  |  |  |  |  ------------------
  |  |  |  |  166|      0|       ((*(p) == '=')) || ((*(p) == '\'')))
  |  |  |  |  ------------------
  |  |  |  |  |  Branch (166:8): [True: 0, False: 0]
  |  |  |  |  |  Branch (166:27): [True: 0, False: 0]
  |  |  |  |  ------------------
  |  |  ------------------
  |  |  199|     64|      ((*(p) == ':')) || ((*(p) == '@')))
  |  |  ------------------
  |  |  |  Branch (199:7): [True: 0, False: 0]
  |  |  |  Branch (199:26): [True: 0, False: 0]
  |  |  ------------------
  ------------------
  788|     64|        ret = xmlParse3986PathRootless(uri, &cur);
  789|     64|	if (ret != 0) return(ret);
  ------------------
  |  Branch (789:6): [True: 0, False: 64]
  ------------------
  790|     64|    } else {
  791|       |	/* path-empty is effectively empty */
  792|      0|	if (uri != NULL) {
  ------------------
  |  Branch (792:6): [True: 0, False: 0]
  ------------------
  793|      0|	    if (uri->path != NULL) xmlFree(uri->path);
  ------------------
  |  Branch (793:10): [True: 0, False: 0]
  ------------------
  794|      0|	    uri->path = NULL;
  795|      0|	}
  796|      0|    }
  797|     64|    *str = cur;
  798|     64|    return (0);
  799|    872|}
uri.c:xmlParse3986Authority:
  521|    808|{
  522|    808|    const char *cur;
  523|    808|    int ret;
  524|       |
  525|    808|    cur = *str;
  526|       |    /*
  527|       |     * try to parse an userinfo and check for the trailing @
  528|       |     */
  529|    808|    ret = xmlParse3986Userinfo(uri, &cur);
  530|    808|    if ((ret != 0) || (*cur != '@'))
  ------------------
  |  Branch (530:9): [True: 808, False: 0]
  |  Branch (530:23): [True: 0, False: 0]
  ------------------
  531|    808|        cur = *str;
  532|      0|    else
  533|      0|        cur++;
  534|    808|    ret = xmlParse3986Host(uri, &cur);
  535|    808|    if (ret != 0) return(ret);
  ------------------
  |  Branch (535:9): [True: 0, False: 808]
  ------------------
  536|    808|    if (*cur == ':') {
  ------------------
  |  Branch (536:9): [True: 0, False: 808]
  ------------------
  537|      0|        cur++;
  538|      0|        ret = xmlParse3986Port(uri, &cur);
  539|      0|	if (ret != 0) return(ret);
  ------------------
  |  Branch (539:6): [True: 0, False: 0]
  ------------------
  540|      0|    }
  541|    808|    *str = cur;
  542|    808|    return(0);
  543|    808|}
uri.c:xmlParse3986Userinfo:
  370|    808|{
  371|    808|    const char *cur;
  372|       |
  373|    808|    cur = *str;
  374|  9.74k|    while (ISA_UNRESERVED(cur) || ISA_PCT_ENCODED(cur) ||
  ------------------
  |  |  185|  19.4k|      ((ISA_ALPHA(p)) || (ISA_DIGIT(p)) || ((*(p) == '-')) ||		\
  |  |  ------------------
  |  |  |  |  152|  9.74k|#define ISA_ALPHA(p) (((*(p) >= 'a') && (*(p) <= 'z')) ||		\
  |  |  |  |  ------------------
  |  |  |  |  |  Branch (152:24): [True: 6.87k, False: 2.87k]
  |  |  |  |  |  Branch (152:41): [True: 6.87k, False: 0]
  |  |  |  |  ------------------
  |  |  |  |  153|  9.74k|                      ((*(p) >= 'A') && (*(p) <= 'Z')))
  |  |  |  |  ------------------
  |  |  |  |  |  Branch (153:24): [True: 0, False: 2.87k]
  |  |  |  |  |  Branch (153:41): [True: 0, False: 0]
  |  |  |  |  ------------------
  |  |  ------------------
  |  |                     ((ISA_ALPHA(p)) || (ISA_DIGIT(p)) || ((*(p) == '-')) ||		\
  |  |  ------------------
  |  |  |  |  151|  2.87k|#define ISA_DIGIT(p) ((*(p) >= '0') && (*(p) <= '9'))
  |  |  |  |  ------------------
  |  |  |  |  |  Branch (151:23): [True: 524, False: 2.35k]
  |  |  |  |  |  Branch (151:40): [True: 524, False: 0]
  |  |  |  |  ------------------
  |  |  ------------------
  |  |  |  Branch (185:44): [True: 0, False: 2.35k]
  |  |  ------------------
  |  |  186|  9.74k|       ((*(p) == '.')) || ((*(p) == '_')) || ((*(p) == '~')))
  |  |  ------------------
  |  |  |  Branch (186:8): [True: 1.54k, False: 808]
  |  |  |  Branch (186:27): [True: 0, False: 808]
  |  |  |  Branch (186:46): [True: 0, False: 808]
  |  |  ------------------
  ------------------
                  while (ISA_UNRESERVED(cur) || ISA_PCT_ENCODED(cur) ||
  ------------------
  |  |  192|  10.5k|     ((*(p) == '%') && (ISA_HEXDIG(p + 1)) && (ISA_HEXDIG(p + 2)))
  |  |  ------------------
  |  |  |  |  155|      0|       (ISA_DIGIT(p) || ((*(p) >= 'a') && (*(p) <= 'f')) ||		\
  |  |  |  |  ------------------
  |  |  |  |  |  |  151|      0|#define ISA_DIGIT(p) ((*(p) >= '0') && (*(p) <= '9'))
  |  |  |  |  |  |  ------------------
  |  |  |  |  |  |  |  Branch (151:23): [True: 0, False: 0]
  |  |  |  |  |  |  |  Branch (151:40): [True: 0, False: 0]
  |  |  |  |  |  |  ------------------
  |  |  |  |  ------------------
  |  |  |  |  |  Branch (155:26): [True: 0, False: 0]
  |  |  |  |  |  Branch (155:43): [True: 0, False: 0]
  |  |  |  |  ------------------
  |  |  |  |  156|      0|        ((*(p) >= 'A') && (*(p) <= 'F')))
  |  |  |  |  ------------------
  |  |  |  |  |  Branch (156:10): [True: 0, False: 0]
  |  |  |  |  |  Branch (156:27): [True: 0, False: 0]
  |  |  |  |  ------------------
  |  |  ------------------
  |  |                    ((*(p) == '%') && (ISA_HEXDIG(p + 1)) && (ISA_HEXDIG(p + 2)))
  |  |  ------------------
  |  |  |  |  155|      0|       (ISA_DIGIT(p) || ((*(p) >= 'a') && (*(p) <= 'f')) ||		\
  |  |  |  |  ------------------
  |  |  |  |  |  |  151|      0|#define ISA_DIGIT(p) ((*(p) >= '0') && (*(p) <= '9'))
  |  |  |  |  |  |  ------------------
  |  |  |  |  |  |  |  Branch (151:23): [True: 0, False: 0]
  |  |  |  |  |  |  |  Branch (151:40): [True: 0, False: 0]
  |  |  |  |  |  |  ------------------
  |  |  |  |  ------------------
  |  |  |  |  |  Branch (155:26): [True: 0, False: 0]
  |  |  |  |  |  Branch (155:43): [True: 0, False: 0]
  |  |  |  |  ------------------
  |  |  |  |  156|      0|        ((*(p) >= 'A') && (*(p) <= 'F')))
  |  |  |  |  ------------------
  |  |  |  |  |  Branch (156:10): [True: 0, False: 0]
  |  |  |  |  |  Branch (156:27): [True: 0, False: 0]
  |  |  |  |  ------------------
  |  |  ------------------
  |  |  |  Branch (192:7): [True: 0, False: 808]
  |  |  ------------------
  ------------------
  375|  9.74k|           ISA_SUB_DELIM(cur) || (*cur == ':'))
  ------------------
  |  |  163|  10.5k|      (((*(p) == '!')) || ((*(p) == '$')) || ((*(p) == '&')) ||		\
  |  |  ------------------
  |  |  |  Branch (163:8): [True: 0, False: 808]
  |  |  |  Branch (163:27): [True: 0, False: 808]
  |  |  |  Branch (163:46): [True: 0, False: 808]
  |  |  ------------------
  |  |  164|    808|       ((*(p) == '(')) || ((*(p) == ')')) || ((*(p) == '*')) ||		\
  |  |  ------------------
  |  |  |  Branch (164:8): [True: 0, False: 808]
  |  |  |  Branch (164:27): [True: 0, False: 808]
  |  |  |  Branch (164:46): [True: 0, False: 808]
  |  |  ------------------
  |  |  165|    808|       ((*(p) == '+')) || ((*(p) == ',')) || ((*(p) == ';')) ||		\
  |  |  ------------------
  |  |  |  Branch (165:8): [True: 0, False: 808]
  |  |  |  Branch (165:27): [True: 0, False: 808]
  |  |  |  Branch (165:46): [True: 0, False: 808]
  |  |  ------------------
  |  |  166|    808|       ((*(p) == '=')) || ((*(p) == '\'')))
  |  |  ------------------
  |  |  |  Branch (166:8): [True: 0, False: 808]
  |  |  |  Branch (166:27): [True: 0, False: 808]
  |  |  ------------------
  ------------------
  |  Branch (375:34): [True: 0, False: 808]
  ------------------
  376|  8.94k|	NEXT(cur);
  ------------------
  |  |  131|  8.94k|#define NEXT(p) ((*p == '%')? p += 3 : p++)
  |  |  ------------------
  |  |  |  Branch (131:18): [True: 0, False: 8.94k]
  |  |  ------------------
  ------------------
  377|    808|    if (*cur == '@') {
  ------------------
  |  Branch (377:9): [True: 0, False: 808]
  ------------------
  378|      0|	if (uri != NULL) {
  ------------------
  |  Branch (378:6): [True: 0, False: 0]
  ------------------
  379|      0|	    if (uri->user != NULL) xmlFree(uri->user);
  ------------------
  |  Branch (379:10): [True: 0, False: 0]
  ------------------
  380|      0|	    if (uri->cleanup & 2)
  ------------------
  |  Branch (380:10): [True: 0, False: 0]
  ------------------
  381|      0|		uri->user = STRNDUP(*str, cur - *str);
  ------------------
  |  |  143|      0|#define STRNDUP(s, n) (char *) xmlStrndup((const xmlChar *)(s), (n))
  ------------------
  382|      0|	    else
  383|      0|		uri->user = xmlURIUnescapeString(*str, cur - *str, NULL);
  384|      0|	}
  385|      0|	*str = cur;
  386|      0|	return(0);
  387|      0|    }
  388|    808|    return(1);
  389|    808|}
uri.c:xmlParse3986Host:
  445|    808|{
  446|    808|    const char *cur = *str;
  447|    808|    const char *host;
  448|       |
  449|    808|    host = cur;
  450|       |    /*
  451|       |     * IPv6 and future addressing scheme are enclosed between brackets
  452|       |     */
  453|    808|    if (*cur == '[') {
  ------------------
  |  Branch (453:9): [True: 0, False: 808]
  ------------------
  454|      0|        cur++;
  455|      0|	while ((*cur != ']') && (*cur != 0))
  ------------------
  |  Branch (455:9): [True: 0, False: 0]
  |  Branch (455:26): [True: 0, False: 0]
  ------------------
  456|      0|	    cur++;
  457|      0|	if (*cur != ']')
  ------------------
  |  Branch (457:6): [True: 0, False: 0]
  ------------------
  458|      0|	    return(1);
  459|      0|	cur++;
  460|      0|	goto found;
  461|      0|    }
  462|       |    /*
  463|       |     * try to parse an IPv4
  464|       |     */
  465|    808|    if (ISA_DIGIT(cur)) {
  ------------------
  |  |  151|    808|#define ISA_DIGIT(p) ((*(p) >= '0') && (*(p) <= '9'))
  |  |  ------------------
  |  |  |  Branch (151:23): [True: 808, False: 0]
  |  |  |  Branch (151:40): [True: 0, False: 808]
  |  |  ------------------
  ------------------
  466|      0|        if (xmlParse3986DecOctet(&cur) != 0)
  ------------------
  |  Branch (466:13): [True: 0, False: 0]
  ------------------
  467|      0|	    goto not_ipv4;
  468|      0|	if (*cur != '.')
  ------------------
  |  Branch (468:6): [True: 0, False: 0]
  ------------------
  469|      0|	    goto not_ipv4;
  470|      0|	cur++;
  471|      0|        if (xmlParse3986DecOctet(&cur) != 0)
  ------------------
  |  Branch (471:13): [True: 0, False: 0]
  ------------------
  472|      0|	    goto not_ipv4;
  473|      0|	if (*cur != '.')
  ------------------
  |  Branch (473:6): [True: 0, False: 0]
  ------------------
  474|      0|	    goto not_ipv4;
  475|      0|        if (xmlParse3986DecOctet(&cur) != 0)
  ------------------
  |  Branch (475:13): [True: 0, False: 0]
  ------------------
  476|      0|	    goto not_ipv4;
  477|      0|	if (*cur != '.')
  ------------------
  |  Branch (477:6): [True: 0, False: 0]
  ------------------
  478|      0|	    goto not_ipv4;
  479|      0|        if (xmlParse3986DecOctet(&cur) != 0)
  ------------------
  |  Branch (479:13): [True: 0, False: 0]
  ------------------
  480|      0|	    goto not_ipv4;
  481|      0|	goto found;
  482|      0|not_ipv4:
  483|      0|        cur = *str;
  484|      0|    }
  485|       |    /*
  486|       |     * then this should be a hostname which can be empty
  487|       |     */
  488|  9.74k|    while (ISA_UNRESERVED(cur) || ISA_PCT_ENCODED(cur) || ISA_SUB_DELIM(cur))
  ------------------
  |  |  185|  19.4k|      ((ISA_ALPHA(p)) || (ISA_DIGIT(p)) || ((*(p) == '-')) ||		\
  |  |  ------------------
  |  |  |  |  152|  9.74k|#define ISA_ALPHA(p) (((*(p) >= 'a') && (*(p) <= 'z')) ||		\
  |  |  |  |  ------------------
  |  |  |  |  |  Branch (152:24): [True: 6.87k, False: 2.87k]
  |  |  |  |  |  Branch (152:41): [True: 6.87k, False: 0]
  |  |  |  |  ------------------
  |  |  |  |  153|  9.74k|                      ((*(p) >= 'A') && (*(p) <= 'Z')))
  |  |  |  |  ------------------
  |  |  |  |  |  Branch (153:24): [True: 0, False: 2.87k]
  |  |  |  |  |  Branch (153:41): [True: 0, False: 0]
  |  |  |  |  ------------------
  |  |  ------------------
  |  |                     ((ISA_ALPHA(p)) || (ISA_DIGIT(p)) || ((*(p) == '-')) ||		\
  |  |  ------------------
  |  |  |  |  151|  2.87k|#define ISA_DIGIT(p) ((*(p) >= '0') && (*(p) <= '9'))
  |  |  |  |  ------------------
  |  |  |  |  |  Branch (151:23): [True: 524, False: 2.35k]
  |  |  |  |  |  Branch (151:40): [True: 524, False: 0]
  |  |  |  |  ------------------
  |  |  ------------------
  |  |  |  Branch (185:44): [True: 0, False: 2.35k]
  |  |  ------------------
  |  |  186|  9.74k|       ((*(p) == '.')) || ((*(p) == '_')) || ((*(p) == '~')))
  |  |  ------------------
  |  |  |  Branch (186:8): [True: 1.54k, False: 808]
  |  |  |  Branch (186:27): [True: 0, False: 808]
  |  |  |  Branch (186:46): [True: 0, False: 808]
  |  |  ------------------
  ------------------
                  while (ISA_UNRESERVED(cur) || ISA_PCT_ENCODED(cur) || ISA_SUB_DELIM(cur))
  ------------------
  |  |  192|  10.5k|     ((*(p) == '%') && (ISA_HEXDIG(p + 1)) && (ISA_HEXDIG(p + 2)))
  |  |  ------------------
  |  |  |  |  155|      0|       (ISA_DIGIT(p) || ((*(p) >= 'a') && (*(p) <= 'f')) ||		\
  |  |  |  |  ------------------
  |  |  |  |  |  |  151|      0|#define ISA_DIGIT(p) ((*(p) >= '0') && (*(p) <= '9'))
  |  |  |  |  |  |  ------------------
  |  |  |  |  |  |  |  Branch (151:23): [True: 0, False: 0]
  |  |  |  |  |  |  |  Branch (151:40): [True: 0, False: 0]
  |  |  |  |  |  |  ------------------
  |  |  |  |  ------------------
  |  |  |  |  |  Branch (155:26): [True: 0, False: 0]
  |  |  |  |  |  Branch (155:43): [True: 0, False: 0]
  |  |  |  |  ------------------
  |  |  |  |  156|      0|        ((*(p) >= 'A') && (*(p) <= 'F')))
  |  |  |  |  ------------------
  |  |  |  |  |  Branch (156:10): [True: 0, False: 0]
  |  |  |  |  |  Branch (156:27): [True: 0, False: 0]
  |  |  |  |  ------------------
  |  |  ------------------
  |  |                    ((*(p) == '%') && (ISA_HEXDIG(p + 1)) && (ISA_HEXDIG(p + 2)))
  |  |  ------------------
  |  |  |  |  155|      0|       (ISA_DIGIT(p) || ((*(p) >= 'a') && (*(p) <= 'f')) ||		\
  |  |  |  |  ------------------
  |  |  |  |  |  |  151|      0|#define ISA_DIGIT(p) ((*(p) >= '0') && (*(p) <= '9'))
  |  |  |  |  |  |  ------------------
  |  |  |  |  |  |  |  Branch (151:23): [True: 0, False: 0]
  |  |  |  |  |  |  |  Branch (151:40): [True: 0, False: 0]
  |  |  |  |  |  |  ------------------
  |  |  |  |  ------------------
  |  |  |  |  |  Branch (155:26): [True: 0, False: 0]
  |  |  |  |  |  Branch (155:43): [True: 0, False: 0]
  |  |  |  |  ------------------
  |  |  |  |  156|      0|        ((*(p) >= 'A') && (*(p) <= 'F')))
  |  |  |  |  ------------------
  |  |  |  |  |  Branch (156:10): [True: 0, False: 0]
  |  |  |  |  |  Branch (156:27): [True: 0, False: 0]
  |  |  |  |  ------------------
  |  |  ------------------
  |  |  |  Branch (192:7): [True: 0, False: 808]
  |  |  ------------------
  ------------------
                  while (ISA_UNRESERVED(cur) || ISA_PCT_ENCODED(cur) || ISA_SUB_DELIM(cur))
  ------------------
  |  |  163|    808|      (((*(p) == '!')) || ((*(p) == '$')) || ((*(p) == '&')) ||		\
  |  |  ------------------
  |  |  |  Branch (163:8): [True: 0, False: 808]
  |  |  |  Branch (163:27): [True: 0, False: 808]
  |  |  |  Branch (163:46): [True: 0, False: 808]
  |  |  ------------------
  |  |  164|    808|       ((*(p) == '(')) || ((*(p) == ')')) || ((*(p) == '*')) ||		\
  |  |  ------------------
  |  |  |  Branch (164:8): [True: 0, False: 808]
  |  |  |  Branch (164:27): [True: 0, False: 808]
  |  |  |  Branch (164:46): [True: 0, False: 808]
  |  |  ------------------
  |  |  165|    808|       ((*(p) == '+')) || ((*(p) == ',')) || ((*(p) == ';')) ||		\
  |  |  ------------------
  |  |  |  Branch (165:8): [True: 0, False: 808]
  |  |  |  Branch (165:27): [True: 0, False: 808]
  |  |  |  Branch (165:46): [True: 0, False: 808]
  |  |  ------------------
  |  |  166|    808|       ((*(p) == '=')) || ((*(p) == '\'')))
  |  |  ------------------
  |  |  |  Branch (166:8): [True: 0, False: 808]
  |  |  |  Branch (166:27): [True: 0, False: 808]
  |  |  ------------------
  ------------------
  489|  8.94k|        NEXT(cur);
  ------------------
  |  |  131|  9.74k|#define NEXT(p) ((*p == '%')? p += 3 : p++)
  |  |  ------------------
  |  |  |  Branch (131:18): [True: 0, False: 8.94k]
  |  |  ------------------
  ------------------
  490|    808|found:
  491|    808|    if (uri != NULL) {
  ------------------
  |  Branch (491:9): [True: 808, False: 0]
  ------------------
  492|    808|	if (uri->authority != NULL) xmlFree(uri->authority);
  ------------------
  |  Branch (492:6): [True: 0, False: 808]
  ------------------
  493|    808|	uri->authority = NULL;
  494|    808|	if (uri->server != NULL) xmlFree(uri->server);
  ------------------
  |  Branch (494:6): [True: 0, False: 808]
  ------------------
  495|    808|	if (cur != host) {
  ------------------
  |  Branch (495:6): [True: 808, False: 0]
  ------------------
  496|    808|	    if (uri->cleanup & 2)
  ------------------
  |  Branch (496:10): [True: 0, False: 808]
  ------------------
  497|      0|		uri->server = STRNDUP(host, cur - host);
  ------------------
  |  |  143|      0|#define STRNDUP(s, n) (char *) xmlStrndup((const xmlChar *)(s), (n))
  ------------------
  498|    808|	    else
  499|    808|		uri->server = xmlURIUnescapeString(host, cur - host, NULL);
  500|    808|	} else
  501|      0|	    uri->server = NULL;
  502|    808|    }
  503|    808|    *str = cur;
  504|    808|    return(0);
  505|    808|}
uri.c:xmlParse3986PathAbEmpty:
  592|    808|{
  593|    808|    const char *cur;
  594|    808|    int ret;
  595|       |
  596|    808|    cur = *str;
  597|       |
  598|  3.02k|    while (*cur == '/') {
  ------------------
  |  Branch (598:12): [True: 2.21k, False: 808]
  ------------------
  599|  2.21k|        cur++;
  600|  2.21k|	ret = xmlParse3986Segment(&cur, 0, 1);
  601|  2.21k|	if (ret != 0) return(ret);
  ------------------
  |  Branch (601:6): [True: 0, False: 2.21k]
  ------------------
  602|  2.21k|    }
  603|    808|    if (uri != NULL) {
  ------------------
  |  Branch (603:9): [True: 808, False: 0]
  ------------------
  604|    808|	if (uri->path != NULL) xmlFree(uri->path);
  ------------------
  |  Branch (604:6): [True: 0, False: 808]
  ------------------
  605|    808|        if (*str != cur) {
  ------------------
  |  Branch (605:13): [True: 792, False: 16]
  ------------------
  606|    792|            if (uri->cleanup & 2)
  ------------------
  |  Branch (606:17): [True: 0, False: 792]
  ------------------
  607|      0|                uri->path = STRNDUP(*str, cur - *str);
  ------------------
  |  |  143|      0|#define STRNDUP(s, n) (char *) xmlStrndup((const xmlChar *)(s), (n))
  ------------------
  608|    792|            else
  609|    792|                uri->path = xmlURIUnescapeString(*str, cur - *str, NULL);
  610|    792|        } else {
  611|     16|            uri->path = NULL;
  612|     16|        }
  613|    808|    }
  614|    808|    *str = cur;
  615|    808|    return (0);
  616|    808|}
uri.c:xmlParse3986Segment:
  563|  17.6k|{
  564|  17.6k|    const char *cur;
  565|       |
  566|  17.6k|    cur = *str;
  567|  17.6k|    if (!ISA_PCHAR(cur)) {
  ------------------
  |  |  198|  17.6k|     (ISA_UNRESERVED(p) || ISA_PCT_ENCODED(p) || ISA_SUB_DELIM(p) ||	\
  |  |  ------------------
  |  |  |  |  185|  35.3k|      ((ISA_ALPHA(p)) || (ISA_DIGIT(p)) || ((*(p) == '-')) ||		\
  |  |  |  |  ------------------
  |  |  |  |  |  |  152|  17.6k|#define ISA_ALPHA(p) (((*(p) >= 'a') && (*(p) <= 'z')) ||		\
  |  |  |  |  |  |  ------------------
  |  |  |  |  |  |  |  Branch (152:24): [True: 16.1k, False: 1.52k]
  |  |  |  |  |  |  |  Branch (152:41): [True: 16.1k, False: 24]
  |  |  |  |  |  |  ------------------
  |  |  |  |  |  |  153|  17.6k|                      ((*(p) >= 'A') && (*(p) <= 'Z')))
  |  |  |  |  |  |  ------------------
  |  |  |  |  |  |  |  Branch (153:24): [True: 1.19k, False: 355]
  |  |  |  |  |  |  |  Branch (153:41): [True: 1.16k, False: 24]
  |  |  |  |  |  |  ------------------
  |  |  |  |  ------------------
  |  |  |  |                     ((ISA_ALPHA(p)) || (ISA_DIGIT(p)) || ((*(p) == '-')) ||		\
  |  |  |  |  ------------------
  |  |  |  |  |  |  151|    379|#define ISA_DIGIT(p) ((*(p) >= '0') && (*(p) <= '9'))
  |  |  |  |  |  |  ------------------
  |  |  |  |  |  |  |  Branch (151:23): [True: 203, False: 176]
  |  |  |  |  |  |  |  Branch (151:40): [True: 179, False: 24]
  |  |  |  |  |  |  ------------------
  |  |  |  |  ------------------
  |  |  |  |  |  Branch (185:44): [True: 0, False: 200]
  |  |  |  |  ------------------
  |  |  |  |  186|  17.6k|       ((*(p) == '.')) || ((*(p) == '_')) || ((*(p) == '~')))
  |  |  |  |  ------------------
  |  |  |  |  |  Branch (186:8): [True: 0, False: 200]
  |  |  |  |  |  Branch (186:27): [True: 0, False: 200]
  |  |  |  |  |  Branch (186:46): [True: 24, False: 176]
  |  |  |  |  ------------------
  |  |  ------------------
  |  |                    (ISA_UNRESERVED(p) || ISA_PCT_ENCODED(p) || ISA_SUB_DELIM(p) ||	\
  |  |  ------------------
  |  |  |  |  192|  17.8k|     ((*(p) == '%') && (ISA_HEXDIG(p + 1)) && (ISA_HEXDIG(p + 2)))
  |  |  |  |  ------------------
  |  |  |  |  |  |  155|      0|       (ISA_DIGIT(p) || ((*(p) >= 'a') && (*(p) <= 'f')) ||		\
  |  |  |  |  |  |  ------------------
  |  |  |  |  |  |  |  |  151|      0|#define ISA_DIGIT(p) ((*(p) >= '0') && (*(p) <= '9'))
  |  |  |  |  |  |  |  |  ------------------
  |  |  |  |  |  |  |  |  |  Branch (151:23): [True: 0, False: 0]
  |  |  |  |  |  |  |  |  |  Branch (151:40): [True: 0, False: 0]
  |  |  |  |  |  |  |  |  ------------------
  |  |  |  |  |  |  ------------------
  |  |  |  |  |  |  |  Branch (155:26): [True: 0, False: 0]
  |  |  |  |  |  |  |  Branch (155:43): [True: 0, False: 0]
  |  |  |  |  |  |  ------------------
  |  |  |  |  |  |  156|      0|        ((*(p) >= 'A') && (*(p) <= 'F')))
  |  |  |  |  |  |  ------------------
  |  |  |  |  |  |  |  Branch (156:10): [True: 0, False: 0]
  |  |  |  |  |  |  |  Branch (156:27): [True: 0, False: 0]
  |  |  |  |  |  |  ------------------
  |  |  |  |  ------------------
  |  |  |  |                    ((*(p) == '%') && (ISA_HEXDIG(p + 1)) && (ISA_HEXDIG(p + 2)))
  |  |  |  |  ------------------
  |  |  |  |  |  |  155|      0|       (ISA_DIGIT(p) || ((*(p) >= 'a') && (*(p) <= 'f')) ||		\
  |  |  |  |  |  |  ------------------
  |  |  |  |  |  |  |  |  151|      0|#define ISA_DIGIT(p) ((*(p) >= '0') && (*(p) <= '9'))
  |  |  |  |  |  |  |  |  ------------------
  |  |  |  |  |  |  |  |  |  Branch (151:23): [True: 0, False: 0]
  |  |  |  |  |  |  |  |  |  Branch (151:40): [True: 0, False: 0]
  |  |  |  |  |  |  |  |  ------------------
  |  |  |  |  |  |  ------------------
  |  |  |  |  |  |  |  Branch (155:26): [True: 0, False: 0]
  |  |  |  |  |  |  |  Branch (155:43): [True: 0, False: 0]
  |  |  |  |  |  |  ------------------
  |  |  |  |  |  |  156|      0|        ((*(p) >= 'A') && (*(p) <= 'F')))
  |  |  |  |  |  |  ------------------
  |  |  |  |  |  |  |  Branch (156:10): [True: 0, False: 0]
  |  |  |  |  |  |  |  Branch (156:27): [True: 0, False: 0]
  |  |  |  |  |  |  ------------------
  |  |  |  |  ------------------
  |  |  |  |  |  Branch (192:7): [True: 0, False: 176]
  |  |  |  |  ------------------
  |  |  ------------------
  |  |                    (ISA_UNRESERVED(p) || ISA_PCT_ENCODED(p) || ISA_SUB_DELIM(p) ||	\
  |  |  ------------------
  |  |  |  |  163|  17.8k|      (((*(p) == '!')) || ((*(p) == '$')) || ((*(p) == '&')) ||		\
  |  |  |  |  ------------------
  |  |  |  |  |  Branch (163:8): [True: 0, False: 176]
  |  |  |  |  |  Branch (163:27): [True: 0, False: 176]
  |  |  |  |  |  Branch (163:46): [True: 0, False: 176]
  |  |  |  |  ------------------
  |  |  |  |  164|    176|       ((*(p) == '(')) || ((*(p) == ')')) || ((*(p) == '*')) ||		\
  |  |  |  |  ------------------
  |  |  |  |  |  Branch (164:8): [True: 0, False: 176]
  |  |  |  |  |  Branch (164:27): [True: 0, False: 176]
  |  |  |  |  |  Branch (164:46): [True: 0, False: 176]
  |  |  |  |  ------------------
  |  |  |  |  165|    176|       ((*(p) == '+')) || ((*(p) == ',')) || ((*(p) == ';')) ||		\
  |  |  |  |  ------------------
  |  |  |  |  |  Branch (165:8): [True: 0, False: 176]
  |  |  |  |  |  Branch (165:27): [True: 0, False: 176]
  |  |  |  |  |  Branch (165:46): [True: 0, False: 176]
  |  |  |  |  ------------------
  |  |  |  |  166|    176|       ((*(p) == '=')) || ((*(p) == '\'')))
  |  |  |  |  ------------------
  |  |  |  |  |  Branch (166:8): [True: 0, False: 176]
  |  |  |  |  |  Branch (166:27): [True: 0, False: 176]
  |  |  |  |  ------------------
  |  |  ------------------
  |  |  199|  17.6k|      ((*(p) == ':')) || ((*(p) == '@')))
  |  |  ------------------
  |  |  |  Branch (199:7): [True: 0, False: 176]
  |  |  |  Branch (199:26): [True: 0, False: 176]
  |  |  ------------------
  ------------------
  568|    176|        if (empty)
  ------------------
  |  Branch (568:13): [True: 176, False: 0]
  ------------------
  569|    176|	    return(0);
  570|      0|	return(1);
  571|    176|    }
  572|   137k|    while (ISA_PCHAR(cur) && (*cur != forbid))
  ------------------
  |  |  198|   274k|     (ISA_UNRESERVED(p) || ISA_PCT_ENCODED(p) || ISA_SUB_DELIM(p) ||	\
  |  |  ------------------
  |  |  |  |  185|   274k|      ((ISA_ALPHA(p)) || (ISA_DIGIT(p)) || ((*(p) == '-')) ||		\
  |  |  |  |  ------------------
  |  |  |  |  |  |  152|   137k|#define ISA_ALPHA(p) (((*(p) >= 'a') && (*(p) <= 'z')) ||		\
  |  |  |  |  |  |  ------------------
  |  |  |  |  |  |  |  Branch (152:24): [True: 77.8k, False: 59.4k]
  |  |  |  |  |  |  |  Branch (152:41): [True: 77.8k, False: 24]
  |  |  |  |  |  |  ------------------
  |  |  |  |  |  |  153|   137k|                      ((*(p) >= 'A') && (*(p) <= 'Z')))
  |  |  |  |  |  |  ------------------
  |  |  |  |  |  |  |  Branch (153:24): [True: 2.97k, False: 56.5k]
  |  |  |  |  |  |  |  Branch (153:41): [True: 2.61k, False: 362]
  |  |  |  |  |  |  ------------------
  |  |  |  |  ------------------
  |  |  |  |                     ((ISA_ALPHA(p)) || (ISA_DIGIT(p)) || ((*(p) == '-')) ||		\
  |  |  |  |  ------------------
  |  |  |  |  |  |  151|  56.9k|#define ISA_DIGIT(p) ((*(p) >= '0') && (*(p) <= '9'))
  |  |  |  |  |  |  ------------------
  |  |  |  |  |  |  |  Branch (151:23): [True: 23.1k, False: 33.7k]
  |  |  |  |  |  |  |  Branch (151:40): [True: 22.7k, False: 458]
  |  |  |  |  |  |  ------------------
  |  |  |  |  ------------------
  |  |  |  |  |  Branch (185:44): [True: 950, False: 33.2k]
  |  |  |  |  ------------------
  |  |  |  |  186|   137k|       ((*(p) == '.')) || ((*(p) == '_')) || ((*(p) == '~')))
  |  |  |  |  ------------------
  |  |  |  |  |  Branch (186:8): [True: 15.2k, False: 17.9k]
  |  |  |  |  |  Branch (186:27): [True: 338, False: 17.6k]
  |  |  |  |  |  Branch (186:46): [True: 24, False: 17.5k]
  |  |  |  |  ------------------
  |  |  ------------------
  |  |                    (ISA_UNRESERVED(p) || ISA_PCT_ENCODED(p) || ISA_SUB_DELIM(p) ||	\
  |  |  ------------------
  |  |  |  |  192|   154k|     ((*(p) == '%') && (ISA_HEXDIG(p + 1)) && (ISA_HEXDIG(p + 2)))
  |  |  |  |  ------------------
  |  |  |  |  |  |  155|      0|       (ISA_DIGIT(p) || ((*(p) >= 'a') && (*(p) <= 'f')) ||		\
  |  |  |  |  |  |  ------------------
  |  |  |  |  |  |  |  |  151|      0|#define ISA_DIGIT(p) ((*(p) >= '0') && (*(p) <= '9'))
  |  |  |  |  |  |  |  |  ------------------
  |  |  |  |  |  |  |  |  |  Branch (151:23): [True: 0, False: 0]
  |  |  |  |  |  |  |  |  |  Branch (151:40): [True: 0, False: 0]
  |  |  |  |  |  |  |  |  ------------------
  |  |  |  |  |  |  ------------------
  |  |  |  |  |  |  |  Branch (155:26): [True: 0, False: 0]
  |  |  |  |  |  |  |  Branch (155:43): [True: 0, False: 0]
  |  |  |  |  |  |  ------------------
  |  |  |  |  |  |  156|      0|        ((*(p) >= 'A') && (*(p) <= 'F')))
  |  |  |  |  |  |  ------------------
  |  |  |  |  |  |  |  Branch (156:10): [True: 0, False: 0]
  |  |  |  |  |  |  |  Branch (156:27): [True: 0, False: 0]
  |  |  |  |  |  |  ------------------
  |  |  |  |  ------------------
  |  |  |  |                    ((*(p) == '%') && (ISA_HEXDIG(p + 1)) && (ISA_HEXDIG(p + 2)))
  |  |  |  |  ------------------
  |  |  |  |  |  |  155|      0|       (ISA_DIGIT(p) || ((*(p) >= 'a') && (*(p) <= 'f')) ||		\
  |  |  |  |  |  |  ------------------
  |  |  |  |  |  |  |  |  151|      0|#define ISA_DIGIT(p) ((*(p) >= '0') && (*(p) <= '9'))
  |  |  |  |  |  |  |  |  ------------------
  |  |  |  |  |  |  |  |  |  Branch (151:23): [True: 0, False: 0]
  |  |  |  |  |  |  |  |  |  Branch (151:40): [True: 0, False: 0]
  |  |  |  |  |  |  |  |  ------------------
  |  |  |  |  |  |  ------------------
  |  |  |  |  |  |  |  Branch (155:26): [True: 0, False: 0]
  |  |  |  |  |  |  |  Branch (155:43): [True: 0, False: 0]
  |  |  |  |  |  |  ------------------
  |  |  |  |  |  |  156|      0|        ((*(p) >= 'A') && (*(p) <= 'F')))
  |  |  |  |  |  |  ------------------
  |  |  |  |  |  |  |  Branch (156:10): [True: 0, False: 0]
  |  |  |  |  |  |  |  Branch (156:27): [True: 0, False: 0]
  |  |  |  |  |  |  ------------------
  |  |  |  |  ------------------
  |  |  |  |  |  Branch (192:7): [True: 0, False: 17.5k]
  |  |  |  |  ------------------
  |  |  ------------------
  |  |                    (ISA_UNRESERVED(p) || ISA_PCT_ENCODED(p) || ISA_SUB_DELIM(p) ||	\
  |  |  ------------------
  |  |  |  |  163|   154k|      (((*(p) == '!')) || ((*(p) == '$')) || ((*(p) == '&')) ||		\
  |  |  |  |  ------------------
  |  |  |  |  |  Branch (163:8): [True: 0, False: 17.5k]
  |  |  |  |  |  Branch (163:27): [True: 0, False: 17.5k]
  |  |  |  |  |  Branch (163:46): [True: 0, False: 17.5k]
  |  |  |  |  ------------------
  |  |  |  |  164|  17.5k|       ((*(p) == '(')) || ((*(p) == ')')) || ((*(p) == '*')) ||		\
  |  |  |  |  ------------------
  |  |  |  |  |  Branch (164:8): [True: 0, False: 17.5k]
  |  |  |  |  |  Branch (164:27): [True: 0, False: 17.5k]
  |  |  |  |  |  Branch (164:46): [True: 0, False: 17.5k]
  |  |  |  |  ------------------
  |  |  |  |  165|  17.5k|       ((*(p) == '+')) || ((*(p) == ',')) || ((*(p) == ';')) ||		\
  |  |  |  |  ------------------
  |  |  |  |  |  Branch (165:8): [True: 0, False: 17.5k]
  |  |  |  |  |  Branch (165:27): [True: 0, False: 17.5k]
  |  |  |  |  |  Branch (165:46): [True: 0, False: 17.5k]
  |  |  |  |  ------------------
  |  |  |  |  166|  17.5k|       ((*(p) == '=')) || ((*(p) == '\'')))
  |  |  |  |  ------------------
  |  |  |  |  |  Branch (166:8): [True: 0, False: 17.5k]
  |  |  |  |  |  Branch (166:27): [True: 0, False: 17.5k]
  |  |  |  |  ------------------
  |  |  ------------------
  |  |  199|   137k|      ((*(p) == ':')) || ((*(p) == '@')))
  |  |  ------------------
  |  |  |  Branch (199:7): [True: 96, False: 17.4k]
  |  |  |  Branch (199:26): [True: 0, False: 17.4k]
  |  |  ------------------
  ------------------
  |  Branch (572:30): [True: 119k, False: 0]
  ------------------
  573|   119k|        NEXT(cur);
  ------------------
  |  |  131|   137k|#define NEXT(p) ((*p == '%')? p += 3 : p++)
  |  |  ------------------
  |  |  |  Branch (131:18): [True: 0, False: 119k]
  |  |  ------------------
  ------------------
  574|  17.4k|    *str = cur;
  575|  17.4k|    return (0);
  576|  17.6k|}
uri.c:xmlParse3986PathAbsolute:
  632|     16|{
  633|     16|    const char *cur;
  634|     16|    int ret;
  635|       |
  636|     16|    cur = *str;
  637|       |
  638|     16|    if (*cur != '/')
  ------------------
  |  Branch (638:9): [True: 0, False: 16]
  ------------------
  639|      0|        return(1);
  640|     16|    cur++;
  641|     16|    ret = xmlParse3986Segment(&cur, 0, 0);
  642|     16|    if (ret == 0) {
  ------------------
  |  Branch (642:9): [True: 16, False: 0]
  ------------------
  643|     32|	while (*cur == '/') {
  ------------------
  |  Branch (643:9): [True: 16, False: 16]
  ------------------
  644|     16|	    cur++;
  645|     16|	    ret = xmlParse3986Segment(&cur, 0, 1);
  646|     16|	    if (ret != 0) return(ret);
  ------------------
  |  Branch (646:10): [True: 0, False: 16]
  ------------------
  647|     16|	}
  648|     16|    }
  649|     16|    if (uri != NULL) {
  ------------------
  |  Branch (649:9): [True: 16, False: 0]
  ------------------
  650|     16|	if (uri->path != NULL) xmlFree(uri->path);
  ------------------
  |  Branch (650:6): [True: 0, False: 16]
  ------------------
  651|     16|        if (cur != *str) {
  ------------------
  |  Branch (651:13): [True: 16, False: 0]
  ------------------
  652|     16|            if (uri->cleanup & 2)
  ------------------
  |  Branch (652:17): [True: 0, False: 16]
  ------------------
  653|      0|                uri->path = STRNDUP(*str, cur - *str);
  ------------------
  |  |  143|      0|#define STRNDUP(s, n) (char *) xmlStrndup((const xmlChar *)(s), (n))
  ------------------
  654|     16|            else
  655|     16|                uri->path = xmlURIUnescapeString(*str, cur - *str, NULL);
  656|     16|        } else {
  657|      0|            uri->path = NULL;
  658|      0|        }
  659|     16|    }
  660|     16|    *str = cur;
  661|     16|    return (0);
  662|     16|}
uri.c:xmlParse3986PathRootless:
  678|     64|{
  679|     64|    const char *cur;
  680|     64|    int ret;
  681|       |
  682|     64|    cur = *str;
  683|       |
  684|     64|    ret = xmlParse3986Segment(&cur, 0, 0);
  685|     64|    if (ret != 0) return(ret);
  ------------------
  |  Branch (685:9): [True: 0, False: 64]
  ------------------
  686|     64|    while (*cur == '/') {
  ------------------
  |  Branch (686:12): [True: 0, False: 64]
  ------------------
  687|      0|        cur++;
  688|      0|	ret = xmlParse3986Segment(&cur, 0, 1);
  689|      0|	if (ret != 0) return(ret);
  ------------------
  |  Branch (689:6): [True: 0, False: 0]
  ------------------
  690|      0|    }
  691|     64|    if (uri != NULL) {
  ------------------
  |  Branch (691:9): [True: 64, False: 0]
  ------------------
  692|     64|	if (uri->path != NULL) xmlFree(uri->path);
  ------------------
  |  Branch (692:6): [True: 0, False: 64]
  ------------------
  693|     64|        if (cur != *str) {
  ------------------
  |  Branch (693:13): [True: 64, False: 0]
  ------------------
  694|     64|            if (uri->cleanup & 2)
  ------------------
  |  Branch (694:17): [True: 0, False: 64]
  ------------------
  695|      0|                uri->path = STRNDUP(*str, cur - *str);
  ------------------
  |  |  143|      0|#define STRNDUP(s, n) (char *) xmlStrndup((const xmlChar *)(s), (n))
  ------------------
  696|     64|            else
  697|     64|                uri->path = xmlURIUnescapeString(*str, cur - *str, NULL);
  698|     64|        } else {
  699|      0|            uri->path = NULL;
  700|      0|        }
  701|     64|    }
  702|     64|    *str = cur;
  703|     64|    return (0);
  704|     64|}
uri.c:xmlParse3986Fragment:
  250|     20|{
  251|     20|    const char *cur;
  252|       |
  253|     20|    if (str == NULL)
  ------------------
  |  Branch (253:9): [True: 0, False: 20]
  ------------------
  254|      0|        return (-1);
  255|       |
  256|     20|    cur = *str;
  257|       |
  258|     68|    while ((ISA_PCHAR(cur)) || (*cur == '/') || (*cur == '?') ||
  ------------------
  |  |  198|     68|     (ISA_UNRESERVED(p) || ISA_PCT_ENCODED(p) || ISA_SUB_DELIM(p) ||	\
  |  |  ------------------
  |  |  |  |  185|    136|      ((ISA_ALPHA(p)) || (ISA_DIGIT(p)) || ((*(p) == '-')) ||		\
  |  |  |  |  ------------------
  |  |  |  |  |  |  152|     68|#define ISA_ALPHA(p) (((*(p) >= 'a') && (*(p) <= 'z')) ||		\
  |  |  |  |  |  |  ------------------
  |  |  |  |  |  |  |  Branch (152:24): [True: 32, False: 36]
  |  |  |  |  |  |  |  Branch (152:41): [True: 32, False: 0]
  |  |  |  |  |  |  ------------------
  |  |  |  |  |  |  153|     68|                      ((*(p) >= 'A') && (*(p) <= 'Z')))
  |  |  |  |  |  |  ------------------
  |  |  |  |  |  |  |  Branch (153:24): [True: 12, False: 24]
  |  |  |  |  |  |  |  Branch (153:41): [True: 12, False: 0]
  |  |  |  |  |  |  ------------------
  |  |  |  |  ------------------
  |  |  |  |                     ((ISA_ALPHA(p)) || (ISA_DIGIT(p)) || ((*(p) == '-')) ||		\
  |  |  |  |  ------------------
  |  |  |  |  |  |  151|     24|#define ISA_DIGIT(p) ((*(p) >= '0') && (*(p) <= '9'))
  |  |  |  |  |  |  ------------------
  |  |  |  |  |  |  |  Branch (151:23): [True: 0, False: 24]
  |  |  |  |  |  |  |  Branch (151:40): [True: 0, False: 0]
  |  |  |  |  |  |  ------------------
  |  |  |  |  ------------------
  |  |  |  |  |  Branch (185:44): [True: 0, False: 24]
  |  |  |  |  ------------------
  |  |  |  |  186|     68|       ((*(p) == '.')) || ((*(p) == '_')) || ((*(p) == '~')))
  |  |  |  |  ------------------
  |  |  |  |  |  Branch (186:8): [True: 4, False: 20]
  |  |  |  |  |  Branch (186:27): [True: 0, False: 20]
  |  |  |  |  |  Branch (186:46): [True: 0, False: 20]
  |  |  |  |  ------------------
  |  |  ------------------
  |  |                    (ISA_UNRESERVED(p) || ISA_PCT_ENCODED(p) || ISA_SUB_DELIM(p) ||	\
  |  |  ------------------
  |  |  |  |  192|     88|     ((*(p) == '%') && (ISA_HEXDIG(p + 1)) && (ISA_HEXDIG(p + 2)))
  |  |  |  |  ------------------
  |  |  |  |  |  |  155|      0|       (ISA_DIGIT(p) || ((*(p) >= 'a') && (*(p) <= 'f')) ||		\
  |  |  |  |  |  |  ------------------
  |  |  |  |  |  |  |  |  151|      0|#define ISA_DIGIT(p) ((*(p) >= '0') && (*(p) <= '9'))
  |  |  |  |  |  |  |  |  ------------------
  |  |  |  |  |  |  |  |  |  Branch (151:23): [True: 0, False: 0]
  |  |  |  |  |  |  |  |  |  Branch (151:40): [True: 0, False: 0]
  |  |  |  |  |  |  |  |  ------------------
  |  |  |  |  |  |  ------------------
  |  |  |  |  |  |  |  Branch (155:26): [True: 0, False: 0]
  |  |  |  |  |  |  |  Branch (155:43): [True: 0, False: 0]
  |  |  |  |  |  |  ------------------
  |  |  |  |  |  |  156|      0|        ((*(p) >= 'A') && (*(p) <= 'F')))
  |  |  |  |  |  |  ------------------
  |  |  |  |  |  |  |  Branch (156:10): [True: 0, False: 0]
  |  |  |  |  |  |  |  Branch (156:27): [True: 0, False: 0]
  |  |  |  |  |  |  ------------------
  |  |  |  |  ------------------
  |  |  |  |                    ((*(p) == '%') && (ISA_HEXDIG(p + 1)) && (ISA_HEXDIG(p + 2)))
  |  |  |  |  ------------------
  |  |  |  |  |  |  155|      0|       (ISA_DIGIT(p) || ((*(p) >= 'a') && (*(p) <= 'f')) ||		\
  |  |  |  |  |  |  ------------------
  |  |  |  |  |  |  |  |  151|      0|#define ISA_DIGIT(p) ((*(p) >= '0') && (*(p) <= '9'))
  |  |  |  |  |  |  |  |  ------------------
  |  |  |  |  |  |  |  |  |  Branch (151:23): [True: 0, False: 0]
  |  |  |  |  |  |  |  |  |  Branch (151:40): [True: 0, False: 0]
  |  |  |  |  |  |  |  |  ------------------
  |  |  |  |  |  |  ------------------
  |  |  |  |  |  |  |  Branch (155:26): [True: 0, False: 0]
  |  |  |  |  |  |  |  Branch (155:43): [True: 0, False: 0]
  |  |  |  |  |  |  ------------------
  |  |  |  |  |  |  156|      0|        ((*(p) >= 'A') && (*(p) <= 'F')))
  |  |  |  |  |  |  ------------------
  |  |  |  |  |  |  |  Branch (156:10): [True: 0, False: 0]
  |  |  |  |  |  |  |  Branch (156:27): [True: 0, False: 0]
  |  |  |  |  |  |  ------------------
  |  |  |  |  ------------------
  |  |  |  |  |  Branch (192:7): [True: 0, False: 20]
  |  |  |  |  ------------------
  |  |  ------------------
  |  |                    (ISA_UNRESERVED(p) || ISA_PCT_ENCODED(p) || ISA_SUB_DELIM(p) ||	\
  |  |  ------------------
  |  |  |  |  163|     88|      (((*(p) == '!')) || ((*(p) == '$')) || ((*(p) == '&')) ||		\
  |  |  |  |  ------------------
  |  |  |  |  |  Branch (163:8): [True: 0, False: 20]
  |  |  |  |  |  Branch (163:27): [True: 0, False: 20]
  |  |  |  |  |  Branch (163:46): [True: 0, False: 20]
  |  |  |  |  ------------------
  |  |  |  |  164|     20|       ((*(p) == '(')) || ((*(p) == ')')) || ((*(p) == '*')) ||		\
  |  |  |  |  ------------------
  |  |  |  |  |  Branch (164:8): [True: 0, False: 20]
  |  |  |  |  |  Branch (164:27): [True: 0, False: 20]
  |  |  |  |  |  Branch (164:46): [True: 0, False: 20]
  |  |  |  |  ------------------
  |  |  |  |  165|     20|       ((*(p) == '+')) || ((*(p) == ',')) || ((*(p) == ';')) ||		\
  |  |  |  |  ------------------
  |  |  |  |  |  Branch (165:8): [True: 0, False: 20]
  |  |  |  |  |  Branch (165:27): [True: 0, False: 20]
  |  |  |  |  |  Branch (165:46): [True: 0, False: 20]
  |  |  |  |  ------------------
  |  |  |  |  166|     20|       ((*(p) == '=')) || ((*(p) == '\'')))
  |  |  |  |  ------------------
  |  |  |  |  |  Branch (166:8): [True: 0, False: 20]
  |  |  |  |  |  Branch (166:27): [True: 0, False: 20]
  |  |  |  |  ------------------
  |  |  ------------------
  |  |  199|     68|      ((*(p) == ':')) || ((*(p) == '@')))
  |  |  ------------------
  |  |  |  Branch (199:7): [True: 0, False: 20]
  |  |  |  Branch (199:26): [True: 0, False: 20]
  |  |  ------------------
  ------------------
  |  Branch (258:32): [True: 0, False: 20]
  |  Branch (258:49): [True: 0, False: 20]
  ------------------
  259|     68|           (*cur == '[') || (*cur == ']') ||
  ------------------
  |  Branch (259:12): [True: 0, False: 20]
  |  Branch (259:29): [True: 0, False: 20]
  ------------------
  260|     68|           ((uri != NULL) && (uri->cleanup & 1) && (IS_UNWISE(cur))))
  ------------------
  |  |  108|      0|      (((*(p) == '{')) || ((*(p) == '}')) || ((*(p) == '|')) ||         \
  |  |  ------------------
  |  |  |  Branch (108:8): [True: 0, False: 0]
  |  |  |  Branch (108:27): [True: 0, False: 0]
  |  |  |  Branch (108:46): [True: 0, False: 0]
  |  |  ------------------
  |  |  109|      0|       ((*(p) == '\\')) || ((*(p) == '^')) || ((*(p) == '[')) ||        \
  |  |  ------------------
  |  |  |  Branch (109:8): [True: 0, False: 0]
  |  |  |  Branch (109:28): [True: 0, False: 0]
  |  |  |  Branch (109:47): [True: 0, False: 0]
  |  |  ------------------
  |  |  110|      0|       ((*(p) == ']')) || ((*(p) == '`')))
  |  |  ------------------
  |  |  |  Branch (110:8): [True: 0, False: 0]
  |  |  |  Branch (110:27): [True: 0, False: 0]
  |  |  ------------------
  ------------------
  |  Branch (260:13): [True: 20, False: 0]
  |  Branch (260:30): [True: 0, False: 20]
  ------------------
  261|     48|        NEXT(cur);
  ------------------
  |  |  131|     68|#define NEXT(p) ((*p == '%')? p += 3 : p++)
  |  |  ------------------
  |  |  |  Branch (131:18): [True: 0, False: 48]
  |  |  ------------------
  ------------------
  262|     20|    if (uri != NULL) {
  ------------------
  |  Branch (262:9): [True: 20, False: 0]
  ------------------
  263|     20|        if (uri->fragment != NULL)
  ------------------
  |  Branch (263:13): [True: 0, False: 20]
  ------------------
  264|      0|            xmlFree(uri->fragment);
  265|     20|	if (uri->cleanup & 2)
  ------------------
  |  Branch (265:6): [True: 0, False: 20]
  ------------------
  266|      0|	    uri->fragment = STRNDUP(*str, cur - *str);
  ------------------
  |  |  143|      0|#define STRNDUP(s, n) (char *) xmlStrndup((const xmlChar *)(s), (n))
  ------------------
  267|     20|	else
  268|     20|	    uri->fragment = xmlURIUnescapeString(*str, cur - *str, NULL);
  269|     20|    }
  270|     20|    *str = cur;
  271|     20|    return (0);
  272|     20|}
uri.c:xmlParse3986RelativeRef:
  818|  15.1k|xmlParse3986RelativeRef(xmlURIPtr uri, const char *str) {
  819|  15.1k|    int ret;
  820|       |
  821|  15.1k|    if ((*str == '/') && (*(str + 1) == '/')) {
  ------------------
  |  Branch (821:9): [True: 16, False: 15.1k]
  |  Branch (821:26): [True: 0, False: 16]
  ------------------
  822|      0|        str += 2;
  823|      0|	ret = xmlParse3986Authority(uri, &str);
  824|      0|	if (ret != 0) return(ret);
  ------------------
  |  Branch (824:6): [True: 0, False: 0]
  ------------------
  825|      0|	ret = xmlParse3986PathAbEmpty(uri, &str);
  826|      0|	if (ret != 0) return(ret);
  ------------------
  |  Branch (826:6): [True: 0, False: 0]
  ------------------
  827|  15.1k|    } else if (*str == '/') {
  ------------------
  |  Branch (827:16): [True: 16, False: 15.1k]
  ------------------
  828|     16|	ret = xmlParse3986PathAbsolute(uri, &str);
  829|     16|	if (ret != 0) return(ret);
  ------------------
  |  Branch (829:6): [True: 0, False: 16]
  ------------------
  830|  15.1k|    } else if (ISA_PCHAR(str)) {
  ------------------
  |  |  198|  15.1k|     (ISA_UNRESERVED(p) || ISA_PCT_ENCODED(p) || ISA_SUB_DELIM(p) ||	\
  |  |  ------------------
  |  |  |  |  185|  30.2k|      ((ISA_ALPHA(p)) || (ISA_DIGIT(p)) || ((*(p) == '-')) ||		\
  |  |  |  |  ------------------
  |  |  |  |  |  |  152|  15.1k|#define ISA_ALPHA(p) (((*(p) >= 'a') && (*(p) <= 'z')) ||		\
  |  |  |  |  |  |  ------------------
  |  |  |  |  |  |  |  Branch (152:24): [True: 14.9k, False: 210]
  |  |  |  |  |  |  |  Branch (152:41): [True: 14.9k, False: 0]
  |  |  |  |  |  |  ------------------
  |  |  |  |  |  |  153|  15.1k|                      ((*(p) >= 'A') && (*(p) <= 'Z')))
  |  |  |  |  |  |  ------------------
  |  |  |  |  |  |  |  Branch (153:24): [True: 123, False: 87]
  |  |  |  |  |  |  |  Branch (153:41): [True: 123, False: 0]
  |  |  |  |  |  |  ------------------
  |  |  |  |  ------------------
  |  |  |  |                     ((ISA_ALPHA(p)) || (ISA_DIGIT(p)) || ((*(p) == '-')) ||		\
  |  |  |  |  ------------------
  |  |  |  |  |  |  151|     87|#define ISA_DIGIT(p) ((*(p) >= '0') && (*(p) <= '9'))
  |  |  |  |  |  |  ------------------
  |  |  |  |  |  |  |  Branch (151:23): [True: 87, False: 0]
  |  |  |  |  |  |  |  Branch (151:40): [True: 87, False: 0]
  |  |  |  |  |  |  ------------------
  |  |  |  |  ------------------
  |  |  |  |  |  Branch (185:44): [True: 0, False: 0]
  |  |  |  |  ------------------
  |  |  |  |  186|  15.1k|       ((*(p) == '.')) || ((*(p) == '_')) || ((*(p) == '~')))
  |  |  |  |  ------------------
  |  |  |  |  |  Branch (186:8): [True: 0, False: 0]
  |  |  |  |  |  Branch (186:27): [True: 0, False: 0]
  |  |  |  |  |  Branch (186:46): [True: 0, False: 0]
  |  |  |  |  ------------------
  |  |  ------------------
  |  |                    (ISA_UNRESERVED(p) || ISA_PCT_ENCODED(p) || ISA_SUB_DELIM(p) ||	\
  |  |  ------------------
  |  |  |  |  192|  15.1k|     ((*(p) == '%') && (ISA_HEXDIG(p + 1)) && (ISA_HEXDIG(p + 2)))
  |  |  |  |  ------------------
  |  |  |  |  |  |  155|      0|       (ISA_DIGIT(p) || ((*(p) >= 'a') && (*(p) <= 'f')) ||		\
  |  |  |  |  |  |  ------------------
  |  |  |  |  |  |  |  |  151|      0|#define ISA_DIGIT(p) ((*(p) >= '0') && (*(p) <= '9'))
  |  |  |  |  |  |  |  |  ------------------
  |  |  |  |  |  |  |  |  |  Branch (151:23): [True: 0, False: 0]
  |  |  |  |  |  |  |  |  |  Branch (151:40): [True: 0, False: 0]
  |  |  |  |  |  |  |  |  ------------------
  |  |  |  |  |  |  ------------------
  |  |  |  |  |  |  |  Branch (155:26): [True: 0, False: 0]
  |  |  |  |  |  |  |  Branch (155:43): [True: 0, False: 0]
  |  |  |  |  |  |  ------------------
  |  |  |  |  |  |  156|      0|        ((*(p) >= 'A') && (*(p) <= 'F')))
  |  |  |  |  |  |  ------------------
  |  |  |  |  |  |  |  Branch (156:10): [True: 0, False: 0]
  |  |  |  |  |  |  |  Branch (156:27): [True: 0, False: 0]
  |  |  |  |  |  |  ------------------
  |  |  |  |  ------------------
  |  |  |  |                    ((*(p) == '%') && (ISA_HEXDIG(p + 1)) && (ISA_HEXDIG(p + 2)))
  |  |  |  |  ------------------
  |  |  |  |  |  |  155|      0|       (ISA_DIGIT(p) || ((*(p) >= 'a') && (*(p) <= 'f')) ||		\
  |  |  |  |  |  |  ------------------
  |  |  |  |  |  |  |  |  151|      0|#define ISA_DIGIT(p) ((*(p) >= '0') && (*(p) <= '9'))
  |  |  |  |  |  |  |  |  ------------------
  |  |  |  |  |  |  |  |  |  Branch (151:23): [True: 0, False: 0]
  |  |  |  |  |  |  |  |  |  Branch (151:40): [True: 0, False: 0]
  |  |  |  |  |  |  |  |  ------------------
  |  |  |  |  |  |  ------------------
  |  |  |  |  |  |  |  Branch (155:26): [True: 0, False: 0]
  |  |  |  |  |  |  |  Branch (155:43): [True: 0, False: 0]
  |  |  |  |  |  |  ------------------
  |  |  |  |  |  |  156|      0|        ((*(p) >= 'A') && (*(p) <= 'F')))
  |  |  |  |  |  |  ------------------
  |  |  |  |  |  |  |  Branch (156:10): [True: 0, False: 0]
  |  |  |  |  |  |  |  Branch (156:27): [True: 0, False: 0]
  |  |  |  |  |  |  ------------------
  |  |  |  |  ------------------
  |  |  |  |  |  Branch (192:7): [True: 0, False: 0]
  |  |  |  |  ------------------
  |  |  ------------------
  |  |                    (ISA_UNRESERVED(p) || ISA_PCT_ENCODED(p) || ISA_SUB_DELIM(p) ||	\
  |  |  ------------------
  |  |  |  |  163|  15.1k|      (((*(p) == '!')) || ((*(p) == '$')) || ((*(p) == '&')) ||		\
  |  |  |  |  ------------------
  |  |  |  |  |  Branch (163:8): [True: 0, False: 0]
  |  |  |  |  |  Branch (163:27): [True: 0, False: 0]
  |  |  |  |  |  Branch (163:46): [True: 0, False: 0]
  |  |  |  |  ------------------
  |  |  |  |  164|      0|       ((*(p) == '(')) || ((*(p) == ')')) || ((*(p) == '*')) ||		\
  |  |  |  |  ------------------
  |  |  |  |  |  Branch (164:8): [True: 0, False: 0]
  |  |  |  |  |  Branch (164:27): [True: 0, False: 0]
  |  |  |  |  |  Branch (164:46): [True: 0, False: 0]
  |  |  |  |  ------------------
  |  |  |  |  165|      0|       ((*(p) == '+')) || ((*(p) == ',')) || ((*(p) == ';')) ||		\
  |  |  |  |  ------------------
  |  |  |  |  |  Branch (165:8): [True: 0, False: 0]
  |  |  |  |  |  Branch (165:27): [True: 0, False: 0]
  |  |  |  |  |  Branch (165:46): [True: 0, False: 0]
  |  |  |  |  ------------------
  |  |  |  |  166|      0|       ((*(p) == '=')) || ((*(p) == '\'')))
  |  |  |  |  ------------------
  |  |  |  |  |  Branch (166:8): [True: 0, False: 0]
  |  |  |  |  |  Branch (166:27): [True: 0, False: 0]
  |  |  |  |  ------------------
  |  |  ------------------
  |  |  199|  15.1k|      ((*(p) == ':')) || ((*(p) == '@')))
  |  |  ------------------
  |  |  |  Branch (199:7): [True: 0, False: 0]
  |  |  |  Branch (199:26): [True: 0, False: 0]
  |  |  ------------------
  ------------------
  831|  15.1k|        ret = xmlParse3986PathNoScheme(uri, &str);
  832|  15.1k|	if (ret != 0) return(ret);
  ------------------
  |  Branch (832:6): [True: 0, False: 15.1k]
  ------------------
  833|  15.1k|    } else {
  834|       |	/* path-empty is effectively empty */
  835|      0|	if (uri != NULL) {
  ------------------
  |  Branch (835:6): [True: 0, False: 0]
  ------------------
  836|      0|	    if (uri->path != NULL) xmlFree(uri->path);
  ------------------
  |  Branch (836:10): [True: 0, False: 0]
  ------------------
  837|      0|	    uri->path = NULL;
  838|      0|	}
  839|      0|    }
  840|       |
  841|  15.1k|    if (*str == '?') {
  ------------------
  |  Branch (841:9): [True: 0, False: 15.1k]
  ------------------
  842|      0|	str++;
  843|      0|	ret = xmlParse3986Query(uri, &str);
  844|      0|	if (ret != 0) return(ret);
  ------------------
  |  Branch (844:6): [True: 0, False: 0]
  ------------------
  845|      0|    }
  846|  15.1k|    if (*str == '#') {
  ------------------
  |  Branch (846:9): [True: 0, False: 15.1k]
  ------------------
  847|      0|	str++;
  848|      0|	ret = xmlParse3986Fragment(uri, &str);
  849|      0|	if (ret != 0) return(ret);
  ------------------
  |  Branch (849:6): [True: 0, False: 0]
  ------------------
  850|      0|    }
  851|  15.1k|    if (*str != 0) {
  ------------------
  |  Branch (851:9): [True: 0, False: 15.1k]
  ------------------
  852|      0|	xmlCleanURI(uri);
  853|      0|	return(1);
  854|      0|    }
  855|  15.1k|    return(0);
  856|  15.1k|}
uri.c:xmlParse3986PathNoScheme:
  720|  15.1k|{
  721|  15.1k|    const char *cur;
  722|  15.1k|    int ret;
  723|       |
  724|  15.1k|    cur = *str;
  725|       |
  726|  15.1k|    ret = xmlParse3986Segment(&cur, ':', 0);
  727|  15.1k|    if (ret != 0) return(ret);
  ------------------
  |  Branch (727:9): [True: 0, False: 15.1k]
  ------------------
  728|  15.3k|    while (*cur == '/') {
  ------------------
  |  Branch (728:12): [True: 244, False: 15.1k]
  ------------------
  729|    244|        cur++;
  730|    244|	ret = xmlParse3986Segment(&cur, 0, 1);
  731|    244|	if (ret != 0) return(ret);
  ------------------
  |  Branch (731:6): [True: 0, False: 244]
  ------------------
  732|    244|    }
  733|  15.1k|    if (uri != NULL) {
  ------------------
  |  Branch (733:9): [True: 15.1k, False: 0]
  ------------------
  734|  15.1k|	if (uri->path != NULL) xmlFree(uri->path);
  ------------------
  |  Branch (734:6): [True: 0, False: 15.1k]
  ------------------
  735|  15.1k|        if (cur != *str) {
  ------------------
  |  Branch (735:13): [True: 15.1k, False: 0]
  ------------------
  736|  15.1k|            if (uri->cleanup & 2)
  ------------------
  |  Branch (736:17): [True: 0, False: 15.1k]
  ------------------
  737|      0|                uri->path = STRNDUP(*str, cur - *str);
  ------------------
  |  |  143|      0|#define STRNDUP(s, n) (char *) xmlStrndup((const xmlChar *)(s), (n))
  ------------------
  738|  15.1k|            else
  739|  15.1k|                uri->path = xmlURIUnescapeString(*str, cur - *str, NULL);
  740|  15.1k|        } else {
  741|      0|            uri->path = NULL;
  742|      0|        }
  743|  15.1k|    }
  744|  15.1k|    *str = cur;
  745|  15.1k|    return (0);
  746|  15.1k|}

xmlValidBuildContentModel:
  646|    593|xmlValidBuildContentModel(xmlValidCtxtPtr ctxt, xmlElementPtr elem) {
  647|       |
  648|    593|    if ((ctxt == NULL) || (elem == NULL))
  ------------------
  |  Branch (648:9): [True: 0, False: 593]
  |  Branch (648:27): [True: 0, False: 593]
  ------------------
  649|      0|	return(0);
  650|    593|    if (elem->type != XML_ELEMENT_DECL)
  ------------------
  |  Branch (650:9): [True: 0, False: 593]
  ------------------
  651|      0|	return(0);
  652|    593|    if (elem->etype != XML_ELEMENT_TYPE_ELEMENT)
  ------------------
  |  Branch (652:9): [True: 0, False: 593]
  ------------------
  653|      0|	return(1);
  654|       |    /* TODO: should we rebuild in this case ? */
  655|    593|    if (elem->contModel != NULL) {
  ------------------
  |  Branch (655:9): [True: 0, False: 593]
  ------------------
  656|      0|	if (!xmlRegexpIsDeterminist(elem->contModel)) {
  ------------------
  |  Branch (656:6): [True: 0, False: 0]
  ------------------
  657|      0|	    ctxt->valid = 0;
  658|      0|	    return(0);
  659|      0|	}
  660|      0|	return(1);
  661|      0|    }
  662|       |
  663|    593|    ctxt->am = xmlNewAutomata();
  664|    593|    if (ctxt->am == NULL) {
  ------------------
  |  Branch (664:9): [True: 0, False: 593]
  ------------------
  665|      0|	xmlErrValidNode(ctxt, (xmlNodePtr) elem,
  666|      0|	                XML_ERR_INTERNAL_ERROR,
  667|      0|	                "Cannot create automata for element %s\n",
  668|      0|		        elem->name, NULL, NULL);
  669|      0|	return(0);
  670|      0|    }
  671|    593|    ctxt->state = xmlAutomataGetInitState(ctxt->am);
  672|    593|    xmlValidBuildAContentModel(elem->content, ctxt, elem->name);
  673|    593|    xmlAutomataSetFinalState(ctxt->am, ctxt->state);
  674|    593|    elem->contModel = xmlAutomataCompile(ctxt->am);
  675|    593|    if (xmlRegexpIsDeterminist(elem->contModel) != 1) {
  ------------------
  |  Branch (675:9): [True: 4, False: 589]
  ------------------
  676|      4|	char expr[5000];
  677|      4|	expr[0] = 0;
  678|      4|	xmlSnprintfElementContent(expr, 5000, elem->content, 1);
  679|      4|	xmlErrValidNode(ctxt, (xmlNodePtr) elem,
  680|      4|	                XML_DTD_CONTENT_NOT_DETERMINIST,
  681|      4|	       "Content model of %s is not deterministic: %s\n",
  682|      4|	       elem->name, BAD_CAST expr, NULL);
  ------------------
  |  |   35|      4|#define BAD_CAST (xmlChar *)
  ------------------
  683|      4|        ctxt->valid = 0;
  684|      4|	ctxt->state = NULL;
  685|      4|	xmlFreeAutomata(ctxt->am);
  686|      4|	ctxt->am = NULL;
  687|      4|	return(0);
  688|      4|    }
  689|    589|    ctxt->state = NULL;
  690|    589|    xmlFreeAutomata(ctxt->am);
  691|    589|    ctxt->am = NULL;
  692|    589|    return(1);
  693|    593|}
xmlNewValidCtxt:
  710|    323|xmlValidCtxtPtr xmlNewValidCtxt(void) {
  711|    323|    xmlValidCtxtPtr ret;
  712|       |
  713|    323|    if ((ret = xmlMalloc(sizeof (xmlValidCtxt))) == NULL) {
  ------------------
  |  Branch (713:9): [True: 0, False: 323]
  ------------------
  714|      0|	xmlVErrMemory(NULL, "malloc failed");
  715|      0|	return (NULL);
  716|      0|    }
  717|       |
  718|    323|    (void) memset(ret, 0, sizeof (xmlValidCtxt));
  719|       |
  720|    323|    return (ret);
  721|    323|}
xmlFreeValidCtxt:
  730|    323|xmlFreeValidCtxt(xmlValidCtxtPtr cur) {
  731|    323|    if (cur == NULL)
  ------------------
  |  Branch (731:9): [True: 0, False: 323]
  ------------------
  732|      0|        return;
  733|    323|    if (cur->vstateTab != NULL)
  ------------------
  |  Branch (733:9): [True: 0, False: 323]
  ------------------
  734|      0|        xmlFree(cur->vstateTab);
  735|    323|    if (cur->nodeTab != NULL)
  ------------------
  |  Branch (735:9): [True: 0, False: 323]
  ------------------
  736|      0|        xmlFree(cur->nodeTab);
  737|    323|    xmlFree(cur);
  738|    323|}
xmlNewDocElementContent:
  754|  18.2k|                        xmlElementContentType type) {
  755|  18.2k|    xmlElementContentPtr ret;
  756|  18.2k|    xmlDictPtr dict = NULL;
  757|       |
  758|  18.2k|    if (doc != NULL)
  ------------------
  |  Branch (758:9): [True: 18.2k, False: 0]
  ------------------
  759|  18.2k|        dict = doc->dict;
  760|       |
  761|  18.2k|    switch(type) {
  762|  8.94k|	case XML_ELEMENT_CONTENT_ELEMENT:
  ------------------
  |  Branch (762:2): [True: 8.94k, False: 9.27k]
  ------------------
  763|  8.94k|	    if (name == NULL) {
  ------------------
  |  Branch (763:10): [True: 0, False: 8.94k]
  ------------------
  764|      0|	        xmlErrValid(NULL, XML_ERR_INTERNAL_ERROR,
  765|      0|			"xmlNewElementContent : name == NULL !\n",
  766|      0|			NULL);
  767|      0|	    }
  768|  8.94k|	    break;
  769|  1.36k|        case XML_ELEMENT_CONTENT_PCDATA:
  ------------------
  |  Branch (769:9): [True: 1.36k, False: 16.8k]
  ------------------
  770|  2.60k|	case XML_ELEMENT_CONTENT_SEQ:
  ------------------
  |  Branch (770:2): [True: 1.23k, False: 16.9k]
  ------------------
  771|  9.27k|	case XML_ELEMENT_CONTENT_OR:
  ------------------
  |  Branch (771:2): [True: 6.67k, False: 11.5k]
  ------------------
  772|  9.27k|	    if (name != NULL) {
  ------------------
  |  Branch (772:10): [True: 0, False: 9.27k]
  ------------------
  773|      0|	        xmlErrValid(NULL, XML_ERR_INTERNAL_ERROR,
  774|      0|			"xmlNewElementContent : name != NULL !\n",
  775|      0|			NULL);
  776|      0|	    }
  777|  9.27k|	    break;
  778|      0|	default:
  ------------------
  |  Branch (778:2): [True: 0, False: 18.2k]
  ------------------
  779|      0|	    xmlErrValid(NULL, XML_ERR_INTERNAL_ERROR,
  780|      0|		    "Internal: ELEMENT content corrupted invalid type\n",
  781|      0|		    NULL);
  782|      0|	    return(NULL);
  783|  18.2k|    }
  784|  18.2k|    ret = (xmlElementContentPtr) xmlMalloc(sizeof(xmlElementContent));
  785|  18.2k|    if (ret == NULL) {
  ------------------
  |  Branch (785:9): [True: 0, False: 18.2k]
  ------------------
  786|      0|	xmlVErrMemory(NULL, "malloc failed");
  787|      0|	return(NULL);
  788|      0|    }
  789|  18.2k|    memset(ret, 0, sizeof(xmlElementContent));
  790|  18.2k|    ret->type = type;
  791|  18.2k|    ret->ocur = XML_ELEMENT_CONTENT_ONCE;
  792|  18.2k|    if (name != NULL) {
  ------------------
  |  Branch (792:9): [True: 8.94k, False: 9.27k]
  ------------------
  793|  8.94k|        int l;
  794|  8.94k|	const xmlChar *tmp;
  795|       |
  796|  8.94k|	tmp = xmlSplitQName3(name, &l);
  797|  8.94k|	if (tmp == NULL) {
  ------------------
  |  Branch (797:6): [True: 8.82k, False: 116]
  ------------------
  798|  8.82k|	    if (dict == NULL)
  ------------------
  |  Branch (798:10): [True: 0, False: 8.82k]
  ------------------
  799|      0|		ret->name = xmlStrdup(name);
  800|  8.82k|	    else
  801|  8.82k|	        ret->name = xmlDictLookup(dict, name, -1);
  802|  8.82k|	} else {
  803|    116|	    if (dict == NULL) {
  ------------------
  |  Branch (803:10): [True: 0, False: 116]
  ------------------
  804|      0|		ret->prefix = xmlStrndup(name, l);
  805|      0|		ret->name = xmlStrdup(tmp);
  806|    116|	    } else {
  807|    116|	        ret->prefix = xmlDictLookup(dict, name, l);
  808|    116|		ret->name = xmlDictLookup(dict, tmp, -1);
  809|    116|	    }
  810|    116|	}
  811|  8.94k|    }
  812|  18.2k|    return(ret);
  813|  18.2k|}
xmlFreeDocElementContent:
  934|  3.14k|xmlFreeDocElementContent(xmlDocPtr doc, xmlElementContentPtr cur) {
  935|  3.14k|    xmlDictPtr dict = NULL;
  936|  3.14k|    size_t depth = 0;
  937|       |
  938|  3.14k|    if (cur == NULL)
  ------------------
  |  Branch (938:9): [True: 740, False: 2.40k]
  ------------------
  939|    740|        return;
  940|  2.40k|    if (doc != NULL)
  ------------------
  |  Branch (940:9): [True: 2.40k, False: 0]
  ------------------
  941|  2.40k|        dict = doc->dict;
  942|       |
  943|  18.2k|    while (1) {
  ------------------
  |  Branch (943:12): [Folded - Ignored]
  ------------------
  944|  18.2k|        xmlElementContentPtr parent;
  945|       |
  946|  26.1k|        while ((cur->c1 != NULL) || (cur->c2 != NULL)) {
  ------------------
  |  Branch (946:16): [True: 7.90k, False: 18.2k]
  |  Branch (946:37): [True: 0, False: 18.2k]
  ------------------
  947|  7.90k|            cur = (cur->c1 != NULL) ? cur->c1 : cur->c2;
  ------------------
  |  Branch (947:19): [True: 7.90k, False: 0]
  ------------------
  948|  7.90k|            depth += 1;
  949|  7.90k|        }
  950|       |
  951|  18.2k|	switch (cur->type) {
  952|  1.36k|	    case XML_ELEMENT_CONTENT_PCDATA:
  ------------------
  |  Branch (952:6): [True: 1.36k, False: 16.8k]
  ------------------
  953|  10.3k|	    case XML_ELEMENT_CONTENT_ELEMENT:
  ------------------
  |  Branch (953:6): [True: 8.94k, False: 9.27k]
  ------------------
  954|  11.5k|	    case XML_ELEMENT_CONTENT_SEQ:
  ------------------
  |  Branch (954:6): [True: 1.23k, False: 16.9k]
  ------------------
  955|  18.2k|	    case XML_ELEMENT_CONTENT_OR:
  ------------------
  |  Branch (955:6): [True: 6.67k, False: 11.5k]
  ------------------
  956|  18.2k|		break;
  957|      0|	    default:
  ------------------
  |  Branch (957:6): [True: 0, False: 18.2k]
  ------------------
  958|      0|		xmlErrValid(NULL, XML_ERR_INTERNAL_ERROR,
  959|      0|			"Internal: ELEMENT content corrupted invalid type\n",
  960|      0|			NULL);
  961|      0|		return;
  962|  18.2k|	}
  963|  18.2k|	if (dict) {
  ------------------
  |  Branch (963:6): [True: 18.2k, False: 0]
  ------------------
  964|  18.2k|	    if ((cur->name != NULL) && (!xmlDictOwns(dict, cur->name)))
  ------------------
  |  Branch (964:10): [True: 8.94k, False: 9.27k]
  |  Branch (964:33): [True: 0, False: 8.94k]
  ------------------
  965|      0|	        xmlFree((xmlChar *) cur->name);
  966|  18.2k|	    if ((cur->prefix != NULL) && (!xmlDictOwns(dict, cur->prefix)))
  ------------------
  |  Branch (966:10): [True: 116, False: 18.1k]
  |  Branch (966:35): [True: 0, False: 116]
  ------------------
  967|      0|	        xmlFree((xmlChar *) cur->prefix);
  968|  18.2k|	} else {
  969|      0|	    if (cur->name != NULL) xmlFree((xmlChar *) cur->name);
  ------------------
  |  Branch (969:10): [True: 0, False: 0]
  ------------------
  970|      0|	    if (cur->prefix != NULL) xmlFree((xmlChar *) cur->prefix);
  ------------------
  |  Branch (970:10): [True: 0, False: 0]
  ------------------
  971|      0|	}
  972|  18.2k|        parent = cur->parent;
  973|  18.2k|        if ((depth == 0) || (parent == NULL)) {
  ------------------
  |  Branch (973:13): [True: 2.40k, False: 15.8k]
  |  Branch (973:29): [True: 0, False: 15.8k]
  ------------------
  974|  2.40k|            xmlFree(cur);
  975|  2.40k|            break;
  976|  2.40k|        }
  977|  15.8k|        if (cur == parent->c1)
  ------------------
  |  Branch (977:13): [True: 7.90k, False: 7.90k]
  ------------------
  978|  7.90k|            parent->c1 = NULL;
  979|  7.90k|        else
  980|  7.90k|            parent->c2 = NULL;
  981|  15.8k|	xmlFree(cur);
  982|       |
  983|  15.8k|        if (parent->c2 != NULL) {
  ------------------
  |  Branch (983:13): [True: 7.90k, False: 7.90k]
  ------------------
  984|  7.90k|	    cur = parent->c2;
  985|  7.90k|        } else {
  986|  7.90k|            depth -= 1;
  987|  7.90k|            cur = parent;
  988|  7.90k|        }
  989|  15.8k|    }
  990|  2.40k|}
xmlSnprintfElementContent:
 1130|    136|xmlSnprintfElementContent(char *buf, int size, xmlElementContentPtr content, int englob) {
 1131|    136|    int len;
 1132|       |
 1133|    136|    if (content == NULL) return;
  ------------------
  |  Branch (1133:9): [True: 0, False: 136]
  ------------------
 1134|    136|    len = strlen(buf);
 1135|    136|    if (size - len < 50) {
  ------------------
  |  Branch (1135:9): [True: 0, False: 136]
  ------------------
 1136|      0|	if ((size - len > 4) && (buf[len - 1] != '.'))
  ------------------
  |  Branch (1136:6): [True: 0, False: 0]
  |  Branch (1136:26): [True: 0, False: 0]
  ------------------
 1137|      0|	    strcat(buf, " ...");
 1138|      0|	return;
 1139|      0|    }
 1140|    136|    if (englob) strcat(buf, "(");
  ------------------
  |  Branch (1140:9): [True: 36, False: 100]
  ------------------
 1141|    136|    switch (content->type) {
  ------------------
  |  Branch (1141:13): [True: 0, False: 136]
  ------------------
 1142|      0|        case XML_ELEMENT_CONTENT_PCDATA:
  ------------------
  |  Branch (1142:9): [True: 0, False: 136]
  ------------------
 1143|      0|            strcat(buf, "#PCDATA");
 1144|      0|	    break;
 1145|     80|	case XML_ELEMENT_CONTENT_ELEMENT: {
  ------------------
  |  Branch (1145:2): [True: 80, False: 56]
  ------------------
 1146|     80|            int qnameLen = xmlStrlen(content->name);
 1147|       |
 1148|     80|	    if (content->prefix != NULL)
  ------------------
  |  Branch (1148:10): [True: 4, False: 76]
  ------------------
 1149|      4|                qnameLen += xmlStrlen(content->prefix) + 1;
 1150|     80|	    if (size - len < qnameLen + 10) {
  ------------------
  |  Branch (1150:10): [True: 4, False: 76]
  ------------------
 1151|      4|		strcat(buf, " ...");
 1152|      4|		return;
 1153|      4|	    }
 1154|     76|	    if (content->prefix != NULL) {
  ------------------
  |  Branch (1154:10): [True: 0, False: 76]
  ------------------
 1155|      0|		strcat(buf, (char *) content->prefix);
 1156|      0|		strcat(buf, ":");
 1157|      0|	    }
 1158|     76|	    if (content->name != NULL)
  ------------------
  |  Branch (1158:10): [True: 76, False: 0]
  ------------------
 1159|     76|		strcat(buf, (char *) content->name);
 1160|     76|	    break;
 1161|     80|        }
 1162|     48|	case XML_ELEMENT_CONTENT_SEQ:
  ------------------
  |  Branch (1162:2): [True: 48, False: 88]
  ------------------
 1163|     48|	    if ((content->c1->type == XML_ELEMENT_CONTENT_OR) ||
  ------------------
  |  Branch (1163:10): [True: 4, False: 44]
  ------------------
 1164|     48|	        (content->c1->type == XML_ELEMENT_CONTENT_SEQ))
  ------------------
  |  Branch (1164:10): [True: 0, False: 44]
  ------------------
 1165|      4|		xmlSnprintfElementContent(buf, size, content->c1, 1);
 1166|     44|	    else
 1167|     44|		xmlSnprintfElementContent(buf, size, content->c1, 0);
 1168|     48|	    len = strlen(buf);
 1169|     48|	    if (size - len < 50) {
  ------------------
  |  Branch (1169:10): [True: 0, False: 48]
  ------------------
 1170|      0|		if ((size - len > 4) && (buf[len - 1] != '.'))
  ------------------
  |  Branch (1170:7): [True: 0, False: 0]
  |  Branch (1170:27): [True: 0, False: 0]
  ------------------
 1171|      0|		    strcat(buf, " ...");
 1172|      0|		return;
 1173|      0|	    }
 1174|     48|            strcat(buf, " , ");
 1175|     48|	    if (((content->c2->type == XML_ELEMENT_CONTENT_OR) ||
  ------------------
  |  Branch (1175:11): [True: 0, False: 48]
  ------------------
 1176|     48|		 (content->c2->ocur != XML_ELEMENT_CONTENT_ONCE)) &&
  ------------------
  |  Branch (1176:4): [True: 16, False: 32]
  ------------------
 1177|     48|		(content->c2->type != XML_ELEMENT_CONTENT_ELEMENT))
  ------------------
  |  Branch (1177:3): [True: 0, False: 16]
  ------------------
 1178|      0|		xmlSnprintfElementContent(buf, size, content->c2, 1);
 1179|     48|	    else
 1180|     48|		xmlSnprintfElementContent(buf, size, content->c2, 0);
 1181|     48|	    break;
 1182|      8|	case XML_ELEMENT_CONTENT_OR:
  ------------------
  |  Branch (1182:2): [True: 8, False: 128]
  ------------------
 1183|      8|	    if ((content->c1->type == XML_ELEMENT_CONTENT_OR) ||
  ------------------
  |  Branch (1183:10): [True: 0, False: 8]
  ------------------
 1184|      8|	        (content->c1->type == XML_ELEMENT_CONTENT_SEQ))
  ------------------
  |  Branch (1184:10): [True: 4, False: 4]
  ------------------
 1185|      4|		xmlSnprintfElementContent(buf, size, content->c1, 1);
 1186|      4|	    else
 1187|      4|		xmlSnprintfElementContent(buf, size, content->c1, 0);
 1188|      8|	    len = strlen(buf);
 1189|      8|	    if (size - len < 50) {
  ------------------
  |  Branch (1189:10): [True: 0, False: 8]
  ------------------
 1190|      0|		if ((size - len > 4) && (buf[len - 1] != '.'))
  ------------------
  |  Branch (1190:7): [True: 0, False: 0]
  |  Branch (1190:27): [True: 0, False: 0]
  ------------------
 1191|      0|		    strcat(buf, " ...");
 1192|      0|		return;
 1193|      0|	    }
 1194|      8|            strcat(buf, " | ");
 1195|      8|	    if (((content->c2->type == XML_ELEMENT_CONTENT_SEQ) ||
  ------------------
  |  Branch (1195:11): [True: 4, False: 4]
  ------------------
 1196|      8|		 (content->c2->ocur != XML_ELEMENT_CONTENT_ONCE)) &&
  ------------------
  |  Branch (1196:4): [True: 0, False: 4]
  ------------------
 1197|      8|		(content->c2->type != XML_ELEMENT_CONTENT_ELEMENT))
  ------------------
  |  Branch (1197:3): [True: 4, False: 0]
  ------------------
 1198|      4|		xmlSnprintfElementContent(buf, size, content->c2, 1);
 1199|      4|	    else
 1200|      4|		xmlSnprintfElementContent(buf, size, content->c2, 0);
 1201|      8|	    break;
 1202|    136|    }
 1203|    132|    if (size - strlen(buf) <= 2) return;
  ------------------
  |  Branch (1203:9): [True: 0, False: 132]
  ------------------
 1204|    132|    if (englob)
  ------------------
  |  Branch (1204:9): [True: 32, False: 100]
  ------------------
 1205|     32|        strcat(buf, ")");
 1206|    132|    switch (content->ocur) {
  ------------------
  |  Branch (1206:13): [True: 0, False: 132]
  ------------------
 1207|     92|        case XML_ELEMENT_CONTENT_ONCE:
  ------------------
  |  Branch (1207:9): [True: 92, False: 40]
  ------------------
 1208|     92|	    break;
 1209|     16|        case XML_ELEMENT_CONTENT_OPT:
  ------------------
  |  Branch (1209:9): [True: 16, False: 116]
  ------------------
 1210|     16|	    strcat(buf, "?");
 1211|     16|	    break;
 1212|     12|        case XML_ELEMENT_CONTENT_MULT:
  ------------------
  |  Branch (1212:9): [True: 12, False: 120]
  ------------------
 1213|     12|	    strcat(buf, "*");
 1214|     12|	    break;
 1215|     12|        case XML_ELEMENT_CONTENT_PLUS:
  ------------------
  |  Branch (1215:9): [True: 12, False: 120]
  ------------------
 1216|     12|	    strcat(buf, "+");
 1217|     12|	    break;
 1218|    132|    }
 1219|    132|}
xmlAddElementDecl:
 1266|  3.11k|		  xmlElementContentPtr content) {
 1267|  3.11k|    xmlElementPtr ret;
 1268|  3.11k|    xmlElementTablePtr table;
 1269|  3.11k|    xmlAttributePtr oldAttributes = NULL;
 1270|  3.11k|    xmlChar *ns, *uqname;
 1271|       |
 1272|  3.11k|    if (dtd == NULL) {
  ------------------
  |  Branch (1272:9): [True: 0, False: 3.11k]
  ------------------
 1273|      0|	return(NULL);
 1274|      0|    }
 1275|  3.11k|    if (name == NULL) {
  ------------------
  |  Branch (1275:9): [True: 0, False: 3.11k]
  ------------------
 1276|      0|	return(NULL);
 1277|      0|    }
 1278|       |
 1279|  3.11k|    switch (type) {
 1280|    676|        case XML_ELEMENT_TYPE_EMPTY:
  ------------------
  |  Branch (1280:9): [True: 676, False: 2.43k]
  ------------------
 1281|    676|	    if (content != NULL) {
  ------------------
  |  Branch (1281:10): [True: 0, False: 676]
  ------------------
 1282|      0|		xmlErrValid(ctxt, XML_ERR_INTERNAL_ERROR,
 1283|      0|		        "xmlAddElementDecl: content != NULL for EMPTY\n",
 1284|      0|			NULL);
 1285|      0|		return(NULL);
 1286|      0|	    }
 1287|    676|	    break;
 1288|    676|	case XML_ELEMENT_TYPE_ANY:
  ------------------
  |  Branch (1288:2): [True: 36, False: 3.07k]
  ------------------
 1289|     36|	    if (content != NULL) {
  ------------------
  |  Branch (1289:10): [True: 0, False: 36]
  ------------------
 1290|      0|		xmlErrValid(ctxt, XML_ERR_INTERNAL_ERROR,
 1291|      0|		        "xmlAddElementDecl: content != NULL for ANY\n",
 1292|      0|			NULL);
 1293|      0|		return(NULL);
 1294|      0|	    }
 1295|     36|	    break;
 1296|  1.36k|	case XML_ELEMENT_TYPE_MIXED:
  ------------------
  |  Branch (1296:2): [True: 1.36k, False: 1.74k]
  ------------------
 1297|  1.36k|	    if (content == NULL) {
  ------------------
  |  Branch (1297:10): [True: 0, False: 1.36k]
  ------------------
 1298|      0|		xmlErrValid(ctxt, XML_ERR_INTERNAL_ERROR,
 1299|      0|		        "xmlAddElementDecl: content == NULL for MIXED\n",
 1300|      0|			NULL);
 1301|      0|		return(NULL);
 1302|      0|	    }
 1303|  1.36k|	    break;
 1304|  1.36k|	case XML_ELEMENT_TYPE_ELEMENT:
  ------------------
  |  Branch (1304:2): [True: 1.03k, False: 2.08k]
  ------------------
 1305|  1.03k|	    if (content == NULL) {
  ------------------
  |  Branch (1305:10): [True: 0, False: 1.03k]
  ------------------
 1306|      0|		xmlErrValid(ctxt, XML_ERR_INTERNAL_ERROR,
 1307|      0|		        "xmlAddElementDecl: content == NULL for ELEMENT\n",
 1308|      0|			NULL);
 1309|      0|		return(NULL);
 1310|      0|	    }
 1311|  1.03k|	    break;
 1312|  1.03k|	default:
  ------------------
  |  Branch (1312:2): [True: 0, False: 3.11k]
  ------------------
 1313|      0|	    xmlErrValid(ctxt, XML_ERR_INTERNAL_ERROR,
 1314|      0|		    "Internal: ELEMENT decl corrupted invalid type\n",
 1315|      0|		    NULL);
 1316|      0|	    return(NULL);
 1317|  3.11k|    }
 1318|       |
 1319|       |    /*
 1320|       |     * check if name is a QName
 1321|       |     */
 1322|  3.11k|    uqname = xmlSplitQName2(name, &ns);
 1323|  3.11k|    if (uqname != NULL)
  ------------------
  |  Branch (1323:9): [True: 108, False: 3.00k]
  ------------------
 1324|    108|	name = uqname;
 1325|       |
 1326|       |    /*
 1327|       |     * Create the Element table if needed.
 1328|       |     */
 1329|  3.11k|    table = (xmlElementTablePtr) dtd->elements;
 1330|  3.11k|    if (table == NULL) {
  ------------------
  |  Branch (1330:9): [True: 452, False: 2.66k]
  ------------------
 1331|    452|	xmlDictPtr dict = NULL;
 1332|       |
 1333|    452|	if (dtd->doc != NULL)
  ------------------
  |  Branch (1333:6): [True: 452, False: 0]
  ------------------
 1334|    452|	    dict = dtd->doc->dict;
 1335|    452|        table = xmlHashCreateDict(0, dict);
 1336|    452|	dtd->elements = (void *) table;
 1337|    452|    }
 1338|  3.11k|    if (table == NULL) {
  ------------------
  |  Branch (1338:9): [True: 0, False: 3.11k]
  ------------------
 1339|      0|	xmlVErrMemory(ctxt,
 1340|      0|            "xmlAddElementDecl: Table creation failed!\n");
 1341|      0|	if (uqname != NULL)
  ------------------
  |  Branch (1341:6): [True: 0, False: 0]
  ------------------
 1342|      0|	    xmlFree(uqname);
 1343|      0|	if (ns != NULL)
  ------------------
  |  Branch (1343:6): [True: 0, False: 0]
  ------------------
 1344|      0|	    xmlFree(ns);
 1345|      0|        return(NULL);
 1346|      0|    }
 1347|       |
 1348|       |    /*
 1349|       |     * lookup old attributes inserted on an undefined element in the
 1350|       |     * internal subset.
 1351|       |     */
 1352|  3.11k|    if ((dtd->doc != NULL) && (dtd->doc->intSubset != NULL)) {
  ------------------
  |  Branch (1352:9): [True: 3.11k, False: 0]
  |  Branch (1352:31): [True: 3.11k, False: 0]
  ------------------
 1353|  3.11k|	ret = xmlHashLookup2(dtd->doc->intSubset->elements, name, ns);
 1354|  3.11k|	if ((ret != NULL) && (ret->etype == XML_ELEMENT_TYPE_UNDEFINED)) {
  ------------------
  |  Branch (1354:6): [True: 20, False: 3.09k]
  |  Branch (1354:23): [True: 12, False: 8]
  ------------------
 1355|     12|	    oldAttributes = ret->attributes;
 1356|     12|	    ret->attributes = NULL;
 1357|     12|	    xmlHashRemoveEntry2(dtd->doc->intSubset->elements, name, ns, NULL);
 1358|     12|	    xmlFreeElement(ret);
 1359|     12|	}
 1360|  3.11k|    }
 1361|       |
 1362|       |    /*
 1363|       |     * The element may already be present if one of its attribute
 1364|       |     * was registered first
 1365|       |     */
 1366|  3.11k|    ret = xmlHashLookup2(table, name, ns);
 1367|  3.11k|    if (ret != NULL) {
  ------------------
  |  Branch (1367:9): [True: 4, False: 3.10k]
  ------------------
 1368|      4|	if (ret->etype != XML_ELEMENT_TYPE_UNDEFINED) {
  ------------------
  |  Branch (1368:6): [True: 4, False: 0]
  ------------------
 1369|      4|#ifdef LIBXML_VALID_ENABLED
 1370|       |	    /*
 1371|       |	     * The element is already defined in this DTD.
 1372|       |	     */
 1373|      4|	    xmlErrValidNode(ctxt, (xmlNodePtr) dtd, XML_DTD_ELEM_REDEFINED,
 1374|      4|	                    "Redefinition of element %s\n",
 1375|      4|			    name, NULL, NULL);
 1376|      4|#endif /* LIBXML_VALID_ENABLED */
 1377|      4|	    if (uqname != NULL)
  ------------------
  |  Branch (1377:10): [True: 0, False: 4]
  ------------------
 1378|      0|		xmlFree(uqname);
 1379|      4|            if (ns != NULL)
  ------------------
  |  Branch (1379:17): [True: 0, False: 4]
  ------------------
 1380|      0|	        xmlFree(ns);
 1381|      4|	    return(NULL);
 1382|      4|	}
 1383|      0|	if (ns != NULL) {
  ------------------
  |  Branch (1383:6): [True: 0, False: 0]
  ------------------
 1384|      0|	    xmlFree(ns);
 1385|      0|	    ns = NULL;
 1386|      0|	}
 1387|  3.10k|    } else {
 1388|  3.10k|	ret = (xmlElementPtr) xmlMalloc(sizeof(xmlElement));
 1389|  3.10k|	if (ret == NULL) {
  ------------------
  |  Branch (1389:6): [True: 0, False: 3.10k]
  ------------------
 1390|      0|	    xmlVErrMemory(ctxt, "malloc failed");
 1391|      0|	    if (uqname != NULL)
  ------------------
  |  Branch (1391:10): [True: 0, False: 0]
  ------------------
 1392|      0|		xmlFree(uqname);
 1393|      0|            if (ns != NULL)
  ------------------
  |  Branch (1393:17): [True: 0, False: 0]
  ------------------
 1394|      0|	        xmlFree(ns);
 1395|      0|	    return(NULL);
 1396|      0|	}
 1397|  3.10k|	memset(ret, 0, sizeof(xmlElement));
 1398|  3.10k|	ret->type = XML_ELEMENT_DECL;
 1399|       |
 1400|       |	/*
 1401|       |	 * fill the structure.
 1402|       |	 */
 1403|  3.10k|	ret->name = xmlStrdup(name);
 1404|  3.10k|	if (ret->name == NULL) {
  ------------------
  |  Branch (1404:6): [True: 0, False: 3.10k]
  ------------------
 1405|      0|	    xmlVErrMemory(ctxt, "malloc failed");
 1406|      0|	    if (uqname != NULL)
  ------------------
  |  Branch (1406:10): [True: 0, False: 0]
  ------------------
 1407|      0|		xmlFree(uqname);
 1408|      0|            if (ns != NULL)
  ------------------
  |  Branch (1408:17): [True: 0, False: 0]
  ------------------
 1409|      0|	        xmlFree(ns);
 1410|      0|	    xmlFree(ret);
 1411|      0|	    return(NULL);
 1412|      0|	}
 1413|  3.10k|	ret->prefix = ns;
 1414|       |
 1415|       |	/*
 1416|       |	 * Validity Check:
 1417|       |	 * Insertion must not fail
 1418|       |	 */
 1419|  3.10k|	if (xmlHashAddEntry2(table, name, ns, ret)) {
  ------------------
  |  Branch (1419:6): [True: 0, False: 3.10k]
  ------------------
 1420|      0|#ifdef LIBXML_VALID_ENABLED
 1421|       |	    /*
 1422|       |	     * The element is already defined in this DTD.
 1423|       |	     */
 1424|      0|	    xmlErrValidNode(ctxt, (xmlNodePtr) dtd, XML_DTD_ELEM_REDEFINED,
 1425|      0|	                    "Redefinition of element %s\n",
 1426|      0|			    name, NULL, NULL);
 1427|      0|#endif /* LIBXML_VALID_ENABLED */
 1428|      0|	    xmlFreeElement(ret);
 1429|      0|	    if (uqname != NULL)
  ------------------
  |  Branch (1429:10): [True: 0, False: 0]
  ------------------
 1430|      0|		xmlFree(uqname);
 1431|      0|	    return(NULL);
 1432|      0|	}
 1433|       |	/*
 1434|       |	 * For new element, may have attributes from earlier
 1435|       |	 * definition in internal subset
 1436|       |	 */
 1437|  3.10k|	ret->attributes = oldAttributes;
 1438|  3.10k|    }
 1439|       |
 1440|       |    /*
 1441|       |     * Finish to fill the structure.
 1442|       |     */
 1443|  3.10k|    ret->etype = type;
 1444|       |    /*
 1445|       |     * Avoid a stupid copy when called by the parser
 1446|       |     * and flag it by setting a special parent value
 1447|       |     * so the parser doesn't unallocate it.
 1448|       |     */
 1449|  3.10k|    if ((ctxt != NULL) && (ctxt->flags & XML_VCTXT_USE_PCTXT)) {
  ------------------
  |  |   18|  3.10k|#define XML_VCTXT_USE_PCTXT (1u << 1)
  ------------------
  |  Branch (1449:9): [True: 3.10k, False: 0]
  |  Branch (1449:27): [True: 3.10k, False: 0]
  ------------------
 1450|  3.10k|	ret->content = content;
 1451|  3.10k|	if (content != NULL)
  ------------------
  |  Branch (1451:6): [True: 2.39k, False: 712]
  ------------------
 1452|  2.39k|	    content->parent = (xmlElementContentPtr) 1;
 1453|  3.10k|    } else {
 1454|      0|	ret->content = xmlCopyDocElementContent(dtd->doc, content);
 1455|      0|    }
 1456|       |
 1457|       |    /*
 1458|       |     * Link it to the DTD
 1459|       |     */
 1460|  3.10k|    ret->parent = dtd;
 1461|  3.10k|    ret->doc = dtd->doc;
 1462|  3.10k|    if (dtd->last == NULL) {
  ------------------
  |  Branch (1462:9): [True: 392, False: 2.71k]
  ------------------
 1463|    392|	dtd->children = dtd->last = (xmlNodePtr) ret;
 1464|  2.71k|    } else {
 1465|  2.71k|        dtd->last->next = (xmlNodePtr) ret;
 1466|  2.71k|	ret->prev = dtd->last;
 1467|  2.71k|	dtd->last = (xmlNodePtr) ret;
 1468|  2.71k|    }
 1469|  3.10k|    if (uqname != NULL)
  ------------------
  |  Branch (1469:9): [True: 108, False: 3.00k]
  ------------------
 1470|    108|	xmlFree(uqname);
 1471|  3.10k|    return(ret);
 1472|  3.11k|}
xmlFreeElementTable:
 1486|    472|xmlFreeElementTable(xmlElementTablePtr table) {
 1487|    472|    xmlHashFree(table, xmlFreeElementTableEntry);
 1488|    472|}
xmlCreateEnumeration:
 1640|  2.73k|xmlCreateEnumeration(const xmlChar *name) {
 1641|  2.73k|    xmlEnumerationPtr ret;
 1642|       |
 1643|  2.73k|    ret = (xmlEnumerationPtr) xmlMalloc(sizeof(xmlEnumeration));
 1644|  2.73k|    if (ret == NULL) {
  ------------------
  |  Branch (1644:9): [True: 0, False: 2.73k]
  ------------------
 1645|      0|	xmlVErrMemory(NULL, "malloc failed");
 1646|      0|        return(NULL);
 1647|      0|    }
 1648|  2.73k|    memset(ret, 0, sizeof(xmlEnumeration));
 1649|       |
 1650|  2.73k|    if (name != NULL)
  ------------------
  |  Branch (1650:9): [True: 2.73k, False: 0]
  ------------------
 1651|  2.73k|        ret->name = xmlStrdup(name);
 1652|  2.73k|    return(ret);
 1653|  2.73k|}
xmlFreeEnumeration:
 1662|  2.73k|xmlFreeEnumeration(xmlEnumerationPtr cur) {
 1663|  2.73k|    if (cur == NULL) return;
  ------------------
  |  Branch (1663:9): [True: 0, False: 2.73k]
  ------------------
 1664|       |
 1665|  2.73k|    if (cur->next != NULL) xmlFreeEnumeration(cur->next);
  ------------------
  |  Branch (1665:9): [True: 1.04k, False: 1.68k]
  ------------------
 1666|       |
 1667|  2.73k|    if (cur->name != NULL) xmlFree((xmlChar *) cur->name);
  ------------------
  |  Branch (1667:9): [True: 2.73k, False: 0]
  ------------------
 1668|  2.73k|    xmlFree(cur);
 1669|  2.73k|}
xmlAddAttributeDecl:
 1816|  7.78k|		    const xmlChar *defaultValue, xmlEnumerationPtr tree) {
 1817|  7.78k|    xmlAttributePtr ret;
 1818|  7.78k|    xmlAttributeTablePtr table;
 1819|  7.78k|    xmlElementPtr elemDef;
 1820|  7.78k|    xmlDictPtr dict = NULL;
 1821|       |
 1822|  7.78k|    if (dtd == NULL) {
  ------------------
  |  Branch (1822:9): [True: 0, False: 7.78k]
  ------------------
 1823|      0|	xmlFreeEnumeration(tree);
 1824|      0|	return(NULL);
 1825|      0|    }
 1826|  7.78k|    if (name == NULL) {
  ------------------
  |  Branch (1826:9): [True: 0, False: 7.78k]
  ------------------
 1827|      0|	xmlFreeEnumeration(tree);
 1828|      0|	return(NULL);
 1829|      0|    }
 1830|  7.78k|    if (elem == NULL) {
  ------------------
  |  Branch (1830:9): [True: 0, False: 7.78k]
  ------------------
 1831|      0|	xmlFreeEnumeration(tree);
 1832|      0|	return(NULL);
 1833|      0|    }
 1834|  7.78k|    if (dtd->doc != NULL)
  ------------------
  |  Branch (1834:9): [True: 7.78k, False: 0]
  ------------------
 1835|  7.78k|	dict = dtd->doc->dict;
 1836|       |
 1837|  7.78k|#ifdef LIBXML_VALID_ENABLED
 1838|       |    /*
 1839|       |     * Check the type and possibly the default value.
 1840|       |     */
 1841|  7.78k|    switch (type) {
 1842|  3.00k|        case XML_ATTRIBUTE_CDATA:
  ------------------
  |  Branch (1842:9): [True: 3.00k, False: 4.77k]
  ------------------
 1843|  3.00k|	    break;
 1844|  1.72k|        case XML_ATTRIBUTE_ID:
  ------------------
  |  Branch (1844:9): [True: 1.72k, False: 6.05k]
  ------------------
 1845|  1.72k|	    break;
 1846|     88|        case XML_ATTRIBUTE_IDREF:
  ------------------
  |  Branch (1846:9): [True: 88, False: 7.69k]
  ------------------
 1847|     88|	    break;
 1848|     16|        case XML_ATTRIBUTE_IDREFS:
  ------------------
  |  Branch (1848:9): [True: 16, False: 7.76k]
  ------------------
 1849|     16|	    break;
 1850|     12|        case XML_ATTRIBUTE_ENTITY:
  ------------------
  |  Branch (1850:9): [True: 12, False: 7.76k]
  ------------------
 1851|     12|	    break;
 1852|      0|        case XML_ATTRIBUTE_ENTITIES:
  ------------------
  |  Branch (1852:9): [True: 0, False: 7.78k]
  ------------------
 1853|      0|	    break;
 1854|  1.05k|        case XML_ATTRIBUTE_NMTOKEN:
  ------------------
  |  Branch (1854:9): [True: 1.05k, False: 6.72k]
  ------------------
 1855|  1.05k|	    break;
 1856|    196|        case XML_ATTRIBUTE_NMTOKENS:
  ------------------
  |  Branch (1856:9): [True: 196, False: 7.58k]
  ------------------
 1857|    196|	    break;
 1858|  1.68k|        case XML_ATTRIBUTE_ENUMERATION:
  ------------------
  |  Branch (1858:9): [True: 1.68k, False: 6.09k]
  ------------------
 1859|  1.68k|	    break;
 1860|      0|        case XML_ATTRIBUTE_NOTATION:
  ------------------
  |  Branch (1860:9): [True: 0, False: 7.78k]
  ------------------
 1861|      0|	    break;
 1862|      0|	default:
  ------------------
  |  Branch (1862:2): [True: 0, False: 7.78k]
  ------------------
 1863|      0|	    xmlErrValid(ctxt, XML_ERR_INTERNAL_ERROR,
 1864|      0|		    "Internal: ATTRIBUTE struct corrupted invalid type\n",
 1865|      0|		    NULL);
 1866|      0|	    xmlFreeEnumeration(tree);
 1867|      0|	    return(NULL);
 1868|  7.78k|    }
 1869|  7.78k|    if ((defaultValue != NULL) &&
  ------------------
  |  Branch (1869:9): [True: 1.64k, False: 6.13k]
  ------------------
 1870|  7.78k|        (!xmlValidateAttributeValueInternal(dtd->doc, type, defaultValue))) {
  ------------------
  |  Branch (1870:9): [True: 12, False: 1.63k]
  ------------------
 1871|     12|	xmlErrValidNode(ctxt, (xmlNodePtr) dtd, XML_DTD_ATTRIBUTE_DEFAULT,
 1872|     12|	                "Attribute %s of %s: invalid default value\n",
 1873|     12|	                elem, name, defaultValue);
 1874|     12|	defaultValue = NULL;
 1875|     12|	if (ctxt != NULL)
  ------------------
  |  Branch (1875:6): [True: 12, False: 0]
  ------------------
 1876|     12|	    ctxt->valid = 0;
 1877|     12|    }
 1878|  7.78k|#endif /* LIBXML_VALID_ENABLED */
 1879|       |
 1880|       |    /*
 1881|       |     * Check first that an attribute defined in the external subset wasn't
 1882|       |     * already defined in the internal subset
 1883|       |     */
 1884|  7.78k|    if ((dtd->doc != NULL) && (dtd->doc->extSubset == dtd) &&
  ------------------
  |  Branch (1884:9): [True: 7.78k, False: 0]
  |  Branch (1884:31): [True: 4.19k, False: 3.58k]
  ------------------
 1885|  7.78k|	(dtd->doc->intSubset != NULL) &&
  ------------------
  |  Branch (1885:2): [True: 4.19k, False: 0]
  ------------------
 1886|  7.78k|	(dtd->doc->intSubset->attributes != NULL)) {
  ------------------
  |  Branch (1886:2): [True: 1.99k, False: 2.19k]
  ------------------
 1887|  1.99k|        ret = xmlHashLookup3(dtd->doc->intSubset->attributes, name, ns, elem);
 1888|  1.99k|	if (ret != NULL) {
  ------------------
  |  Branch (1888:6): [True: 0, False: 1.99k]
  ------------------
 1889|      0|	    xmlFreeEnumeration(tree);
 1890|      0|	    return(NULL);
 1891|      0|	}
 1892|  1.99k|    }
 1893|       |
 1894|       |    /*
 1895|       |     * Create the Attribute table if needed.
 1896|       |     */
 1897|  7.78k|    table = (xmlAttributeTablePtr) dtd->attributes;
 1898|  7.78k|    if (table == NULL) {
  ------------------
  |  Branch (1898:9): [True: 168, False: 7.61k]
  ------------------
 1899|    168|        table = xmlHashCreateDict(0, dict);
 1900|    168|	dtd->attributes = (void *) table;
 1901|    168|    }
 1902|  7.78k|    if (table == NULL) {
  ------------------
  |  Branch (1902:9): [True: 0, False: 7.78k]
  ------------------
 1903|      0|	xmlVErrMemory(ctxt,
 1904|      0|            "xmlAddAttributeDecl: Table creation failed!\n");
 1905|      0|	xmlFreeEnumeration(tree);
 1906|      0|        return(NULL);
 1907|      0|    }
 1908|       |
 1909|       |
 1910|  7.78k|    ret = (xmlAttributePtr) xmlMalloc(sizeof(xmlAttribute));
 1911|  7.78k|    if (ret == NULL) {
  ------------------
  |  Branch (1911:9): [True: 0, False: 7.78k]
  ------------------
 1912|      0|	xmlVErrMemory(ctxt, "malloc failed");
 1913|      0|	xmlFreeEnumeration(tree);
 1914|      0|	return(NULL);
 1915|      0|    }
 1916|  7.78k|    memset(ret, 0, sizeof(xmlAttribute));
 1917|  7.78k|    ret->type = XML_ATTRIBUTE_DECL;
 1918|       |
 1919|       |    /*
 1920|       |     * fill the structure.
 1921|       |     */
 1922|  7.78k|    ret->atype = type;
 1923|       |    /*
 1924|       |     * doc must be set before possible error causes call
 1925|       |     * to xmlFreeAttribute (because it's used to check on
 1926|       |     * dict use)
 1927|       |     */
 1928|  7.78k|    ret->doc = dtd->doc;
 1929|  7.78k|    if (dict) {
  ------------------
  |  Branch (1929:9): [True: 7.78k, False: 0]
  ------------------
 1930|  7.78k|	ret->name = xmlDictLookup(dict, name, -1);
 1931|  7.78k|	ret->prefix = xmlDictLookup(dict, ns, -1);
 1932|  7.78k|	ret->elem = xmlDictLookup(dict, elem, -1);
 1933|  7.78k|    } else {
 1934|      0|	ret->name = xmlStrdup(name);
 1935|      0|	ret->prefix = xmlStrdup(ns);
 1936|      0|	ret->elem = xmlStrdup(elem);
 1937|      0|    }
 1938|  7.78k|    ret->def = def;
 1939|  7.78k|    ret->tree = tree;
 1940|  7.78k|    if (defaultValue != NULL) {
  ------------------
  |  Branch (1940:9): [True: 1.63k, False: 6.14k]
  ------------------
 1941|  1.63k|        if (dict)
  ------------------
  |  Branch (1941:13): [True: 1.63k, False: 0]
  ------------------
 1942|  1.63k|	    ret->defaultValue = xmlDictLookup(dict, defaultValue, -1);
 1943|      0|	else
 1944|      0|	    ret->defaultValue = xmlStrdup(defaultValue);
 1945|  1.63k|    }
 1946|       |
 1947|       |    /*
 1948|       |     * Validity Check:
 1949|       |     * Search the DTD for previous declarations of the ATTLIST
 1950|       |     */
 1951|  7.78k|    if (xmlHashAddEntry3(table, ret->name, ret->prefix, ret->elem, ret) < 0) {
  ------------------
  |  Branch (1951:9): [True: 4, False: 7.77k]
  ------------------
 1952|      4|#ifdef LIBXML_VALID_ENABLED
 1953|       |	/*
 1954|       |	 * The attribute is already defined in this DTD.
 1955|       |	 */
 1956|      4|	xmlErrValidWarning(ctxt, (xmlNodePtr) dtd, XML_DTD_ATTRIBUTE_REDEFINED,
 1957|      4|		 "Attribute %s of element %s: already defined\n",
 1958|      4|		 name, elem, NULL);
 1959|      4|#endif /* LIBXML_VALID_ENABLED */
 1960|      4|	xmlFreeAttribute(ret);
 1961|      4|	return(NULL);
 1962|      4|    }
 1963|       |
 1964|       |    /*
 1965|       |     * Validity Check:
 1966|       |     * Multiple ID per element
 1967|       |     */
 1968|  7.77k|    elemDef = xmlGetDtdElementDesc2(ctxt, dtd, elem, 1);
 1969|  7.77k|    if (elemDef != NULL) {
  ------------------
  |  Branch (1969:9): [True: 7.77k, False: 0]
  ------------------
 1970|       |
 1971|  7.77k|#ifdef LIBXML_VALID_ENABLED
 1972|  7.77k|        if ((type == XML_ATTRIBUTE_ID) &&
  ------------------
  |  Branch (1972:13): [True: 1.72k, False: 6.05k]
  ------------------
 1973|  7.77k|	    (xmlScanIDAttributeDecl(NULL, elemDef, 1) != 0)) {
  ------------------
  |  Branch (1973:6): [True: 12, False: 1.71k]
  ------------------
 1974|     12|	    xmlErrValidNode(ctxt, (xmlNodePtr) dtd, XML_DTD_MULTIPLE_ID,
 1975|     12|	   "Element %s has too may ID attributes defined : %s\n",
 1976|     12|		   elem, name, NULL);
 1977|     12|	    if (ctxt != NULL)
  ------------------
  |  Branch (1977:10): [True: 12, False: 0]
  ------------------
 1978|     12|		ctxt->valid = 0;
 1979|     12|	}
 1980|  7.77k|#endif /* LIBXML_VALID_ENABLED */
 1981|       |
 1982|       |	/*
 1983|       |	 * Insert namespace default def first they need to be
 1984|       |	 * processed first.
 1985|       |	 */
 1986|  7.77k|	if ((xmlStrEqual(ret->name, BAD_CAST "xmlns")) ||
  ------------------
  |  |   35|  7.77k|#define BAD_CAST (xmlChar *)
  ------------------
  |  Branch (1986:6): [True: 8, False: 7.76k]
  ------------------
 1987|  7.77k|	    ((ret->prefix != NULL &&
  ------------------
  |  Branch (1987:8): [True: 312, False: 7.45k]
  ------------------
 1988|  7.76k|	     (xmlStrEqual(ret->prefix, BAD_CAST "xmlns"))))) {
  ------------------
  |  |   35|    312|#define BAD_CAST (xmlChar *)
  ------------------
  |  Branch (1988:7): [True: 56, False: 256]
  ------------------
 1989|     64|	    ret->nexth = elemDef->attributes;
 1990|     64|	    elemDef->attributes = ret;
 1991|  7.71k|	} else {
 1992|  7.71k|	    xmlAttributePtr tmp = elemDef->attributes;
 1993|       |
 1994|  7.71k|	    while ((tmp != NULL) &&
  ------------------
  |  Branch (1994:13): [True: 5.80k, False: 1.90k]
  ------------------
 1995|  7.71k|		   ((xmlStrEqual(tmp->name, BAD_CAST "xmlns")) ||
  ------------------
  |  |   35|  5.80k|#define BAD_CAST (xmlChar *)
  ------------------
  |  Branch (1995:7): [True: 0, False: 5.80k]
  ------------------
 1996|  5.80k|		    ((ret->prefix != NULL &&
  ------------------
  |  Branch (1996:9): [True: 192, False: 5.61k]
  ------------------
 1997|  5.80k|		     (xmlStrEqual(ret->prefix, BAD_CAST "xmlns")))))) {
  ------------------
  |  |   35|    192|#define BAD_CAST (xmlChar *)
  ------------------
  |  Branch (1997:8): [True: 0, False: 192]
  ------------------
 1998|      0|		if (tmp->nexth == NULL)
  ------------------
  |  Branch (1998:7): [True: 0, False: 0]
  ------------------
 1999|      0|		    break;
 2000|      0|		tmp = tmp->nexth;
 2001|      0|	    }
 2002|  7.71k|	    if (tmp != NULL) {
  ------------------
  |  Branch (2002:10): [True: 5.80k, False: 1.90k]
  ------------------
 2003|  5.80k|		ret->nexth = tmp->nexth;
 2004|  5.80k|	        tmp->nexth = ret;
 2005|  5.80k|	    } else {
 2006|  1.90k|		ret->nexth = elemDef->attributes;
 2007|  1.90k|		elemDef->attributes = ret;
 2008|  1.90k|	    }
 2009|  7.71k|	}
 2010|  7.77k|    }
 2011|       |
 2012|       |    /*
 2013|       |     * Link it to the DTD
 2014|       |     */
 2015|  7.77k|    ret->parent = dtd;
 2016|  7.77k|    if (dtd->last == NULL) {
  ------------------
  |  Branch (2016:9): [True: 16, False: 7.76k]
  ------------------
 2017|     16|	dtd->children = dtd->last = (xmlNodePtr) ret;
 2018|  7.76k|    } else {
 2019|  7.76k|        dtd->last->next = (xmlNodePtr) ret;
 2020|  7.76k|	ret->prev = dtd->last;
 2021|  7.76k|	dtd->last = (xmlNodePtr) ret;
 2022|  7.76k|    }
 2023|  7.77k|    return(ret);
 2024|  7.78k|}
xmlFreeAttributeTable:
 2038|    168|xmlFreeAttributeTable(xmlAttributeTablePtr table) {
 2039|    168|    xmlHashFree(table, xmlFreeAttributeTableEntry);
 2040|    168|}
xmlAddID:
 2518|  1.66k|         xmlAttrPtr attr) {
 2519|  1.66k|    xmlIDPtr ret;
 2520|  1.66k|    xmlIDTablePtr table;
 2521|       |
 2522|  1.66k|    if (doc == NULL) {
  ------------------
  |  Branch (2522:9): [True: 0, False: 1.66k]
  ------------------
 2523|      0|	return(NULL);
 2524|      0|    }
 2525|  1.66k|    if ((value == NULL) || (value[0] == 0)) {
  ------------------
  |  Branch (2525:9): [True: 0, False: 1.66k]
  |  Branch (2525:28): [True: 0, False: 1.66k]
  ------------------
 2526|      0|	return(NULL);
 2527|      0|    }
 2528|  1.66k|    if (attr == NULL) {
  ------------------
  |  Branch (2528:9): [True: 0, False: 1.66k]
  ------------------
 2529|      0|	return(NULL);
 2530|      0|    }
 2531|       |
 2532|       |    /*
 2533|       |     * Create the ID table if needed.
 2534|       |     */
 2535|  1.66k|    table = (xmlIDTablePtr) doc->ids;
 2536|  1.66k|    if (table == NULL)  {
  ------------------
  |  Branch (2536:9): [True: 70, False: 1.59k]
  ------------------
 2537|     70|        doc->ids = table = xmlHashCreateDict(0, doc->dict);
 2538|     70|    }
 2539|  1.66k|    if (table == NULL) {
  ------------------
  |  Branch (2539:9): [True: 0, False: 1.66k]
  ------------------
 2540|      0|	xmlVErrMemory(ctxt,
 2541|      0|		"xmlAddID: Table creation failed!\n");
 2542|      0|        return(NULL);
 2543|      0|    }
 2544|       |
 2545|  1.66k|    ret = (xmlIDPtr) xmlMalloc(sizeof(xmlID));
 2546|  1.66k|    if (ret == NULL) {
  ------------------
  |  Branch (2546:9): [True: 0, False: 1.66k]
  ------------------
 2547|      0|	xmlVErrMemory(ctxt, "malloc failed");
 2548|      0|	return(NULL);
 2549|      0|    }
 2550|       |
 2551|       |    /*
 2552|       |     * fill the structure.
 2553|       |     */
 2554|  1.66k|    ret->value = xmlStrdup(value);
 2555|  1.66k|    ret->doc = doc;
 2556|  1.66k|    if (xmlIsStreaming(ctxt)) {
  ------------------
  |  Branch (2556:9): [True: 331, False: 1.32k]
  ------------------
 2557|       |	/*
 2558|       |	 * Operating in streaming mode, attr is gonna disappear
 2559|       |	 */
 2560|    331|	if (doc->dict != NULL)
  ------------------
  |  Branch (2560:6): [True: 331, False: 0]
  ------------------
 2561|    331|	    ret->name = xmlDictLookup(doc->dict, attr->name, -1);
 2562|      0|	else
 2563|      0|	    ret->name = xmlStrdup(attr->name);
 2564|    331|	ret->attr = NULL;
 2565|  1.32k|    } else {
 2566|  1.32k|	ret->attr = attr;
 2567|  1.32k|	ret->name = NULL;
 2568|  1.32k|    }
 2569|  1.66k|    ret->lineno = xmlGetLineNo(attr->parent);
 2570|       |
 2571|  1.66k|    if (xmlHashAddEntry(table, value, ret) < 0) {
  ------------------
  |  Branch (2571:9): [True: 20, False: 1.64k]
  ------------------
 2572|     20|#ifdef LIBXML_VALID_ENABLED
 2573|       |	/*
 2574|       |	 * The id is already defined in this DTD.
 2575|       |	 */
 2576|     20|	if (ctxt != NULL) {
  ------------------
  |  Branch (2576:6): [True: 9, False: 11]
  ------------------
 2577|      9|	    xmlErrValidNode(ctxt, attr->parent, XML_DTD_ID_REDEFINED,
 2578|      9|			    "ID %s already defined\n", value, NULL, NULL);
 2579|      9|	}
 2580|     20|#endif /* LIBXML_VALID_ENABLED */
 2581|     20|	xmlFreeID(ret);
 2582|     20|	return(NULL);
 2583|     20|    }
 2584|  1.64k|    if (attr != NULL)
  ------------------
  |  Branch (2584:9): [True: 1.64k, False: 0]
  ------------------
 2585|  1.64k|	attr->atype = XML_ATTRIBUTE_ID;
 2586|  1.64k|    return(ret);
 2587|  1.66k|}
xmlFreeIDTable:
 2601|     70|xmlFreeIDTable(xmlIDTablePtr table) {
 2602|     70|    xmlHashFree(table, xmlFreeIDTableEntry);
 2603|     70|}
xmlIsID:
 2619|  80.9k|xmlIsID(xmlDocPtr doc, xmlNodePtr elem, xmlAttrPtr attr) {
 2620|  80.9k|    if ((attr == NULL) || (attr->name == NULL)) return(0);
  ------------------
  |  Branch (2620:9): [True: 0, False: 80.9k]
  |  Branch (2620:27): [True: 0, False: 80.9k]
  ------------------
 2621|  80.9k|    if ((attr->ns != NULL) && (attr->ns->prefix != NULL) &&
  ------------------
  |  Branch (2621:9): [True: 557, False: 80.3k]
  |  Branch (2621:31): [True: 557, False: 0]
  ------------------
 2622|  80.9k|        (!strcmp((char *) attr->name, "id")) &&
  ------------------
  |  Branch (2622:9): [True: 7, False: 550]
  ------------------
 2623|  80.9k|        (!strcmp((char *) attr->ns->prefix, "xml")))
  ------------------
  |  Branch (2623:9): [True: 0, False: 7]
  ------------------
 2624|      0|	return(1);
 2625|  80.9k|    if (doc == NULL) return(0);
  ------------------
  |  Branch (2625:9): [True: 0, False: 80.9k]
  ------------------
 2626|  80.9k|    if ((doc->intSubset == NULL) && (doc->extSubset == NULL) &&
  ------------------
  |  Branch (2626:9): [True: 77.5k, False: 3.44k]
  |  Branch (2626:37): [True: 77.5k, False: 0]
  ------------------
 2627|  80.9k|        (doc->type != XML_HTML_DOCUMENT_NODE)) {
  ------------------
  |  Branch (2627:9): [True: 77.5k, False: 0]
  ------------------
 2628|  77.5k|	return(0);
 2629|  77.5k|    } else if (doc->type == XML_HTML_DOCUMENT_NODE) {
  ------------------
  |  Branch (2629:16): [True: 0, False: 3.44k]
  ------------------
 2630|      0|        if ((xmlStrEqual(BAD_CAST "id", attr->name)) ||
  ------------------
  |  |   35|      0|#define BAD_CAST (xmlChar *)
  ------------------
  |  Branch (2630:13): [True: 0, False: 0]
  ------------------
 2631|      0|	    ((xmlStrEqual(BAD_CAST "name", attr->name)) &&
  ------------------
  |  |   35|      0|#define BAD_CAST (xmlChar *)
  ------------------
  |  Branch (2631:7): [True: 0, False: 0]
  ------------------
 2632|      0|	    ((elem == NULL) || (xmlStrEqual(elem->name, BAD_CAST "a")))))
  ------------------
  |  |   35|      0|#define BAD_CAST (xmlChar *)
  ------------------
  |  Branch (2632:7): [True: 0, False: 0]
  |  Branch (2632:25): [True: 0, False: 0]
  ------------------
 2633|      0|	    return(1);
 2634|      0|	return(0);
 2635|  3.44k|    } else if (elem == NULL) {
  ------------------
  |  Branch (2635:16): [True: 0, False: 3.44k]
  ------------------
 2636|      0|	return(0);
 2637|  3.44k|    } else {
 2638|  3.44k|	xmlAttributePtr attrDecl = NULL;
 2639|       |
 2640|  3.44k|	xmlChar felem[50], fattr[50];
 2641|  3.44k|	xmlChar *fullelemname, *fullattrname;
 2642|       |
 2643|  3.44k|	fullelemname = (elem->ns != NULL && elem->ns->prefix != NULL) ?
  ------------------
  |  Branch (2643:18): [True: 72, False: 3.37k]
  |  Branch (2643:38): [True: 71, False: 1]
  ------------------
 2644|     71|	    xmlBuildQName(elem->name, elem->ns->prefix, felem, 50) :
 2645|  3.44k|	    (xmlChar *)elem->name;
 2646|       |
 2647|  3.44k|	fullattrname = (attr->ns != NULL && attr->ns->prefix != NULL) ?
  ------------------
  |  Branch (2647:18): [True: 81, False: 3.36k]
  |  Branch (2647:38): [True: 81, False: 0]
  ------------------
 2648|     81|	    xmlBuildQName(attr->name, attr->ns->prefix, fattr, 50) :
 2649|  3.44k|	    (xmlChar *)attr->name;
 2650|       |
 2651|  3.44k|	if (fullelemname != NULL && fullattrname != NULL) {
  ------------------
  |  Branch (2651:6): [True: 3.44k, False: 0]
  |  Branch (2651:30): [True: 3.44k, False: 0]
  ------------------
 2652|  3.44k|	    attrDecl = xmlGetDtdAttrDesc(doc->intSubset, fullelemname,
 2653|  3.44k|		                         fullattrname);
 2654|  3.44k|	    if ((attrDecl == NULL) && (doc->extSubset != NULL))
  ------------------
  |  Branch (2654:10): [True: 3.31k, False: 130]
  |  Branch (2654:32): [True: 1.31k, False: 1.99k]
  ------------------
 2655|  1.31k|		attrDecl = xmlGetDtdAttrDesc(doc->extSubset, fullelemname,
 2656|  1.31k|					     fullattrname);
 2657|  3.44k|	}
 2658|       |
 2659|  3.44k|	if ((fullattrname != fattr) && (fullattrname != attr->name))
  ------------------
  |  Branch (2659:6): [True: 3.36k, False: 81]
  |  Branch (2659:33): [True: 0, False: 3.36k]
  ------------------
 2660|      0|	    xmlFree(fullattrname);
 2661|  3.44k|	if ((fullelemname != felem) && (fullelemname != elem->name))
  ------------------
  |  Branch (2661:6): [True: 3.37k, False: 71]
  |  Branch (2661:33): [True: 0, False: 3.37k]
  ------------------
 2662|      0|	    xmlFree(fullelemname);
 2663|       |
 2664|  3.44k|        if ((attrDecl != NULL) && (attrDecl->atype == XML_ATTRIBUTE_ID))
  ------------------
  |  Branch (2664:13): [True: 1.44k, False: 1.99k]
  |  Branch (2664:35): [True: 335, False: 1.11k]
  ------------------
 2665|    335|	    return(1);
 2666|  3.44k|    }
 2667|  3.11k|    return(0);
 2668|  80.9k|}
xmlRemoveID:
 2680|    993|xmlRemoveID(xmlDocPtr doc, xmlAttrPtr attr) {
 2681|    993|    xmlIDTablePtr table;
 2682|    993|    xmlIDPtr id;
 2683|    993|    xmlChar *ID;
 2684|       |
 2685|    993|    if (doc == NULL) return(-1);
  ------------------
  |  Branch (2685:9): [True: 0, False: 993]
  ------------------
 2686|    993|    if (attr == NULL) return(-1);
  ------------------
  |  Branch (2686:9): [True: 0, False: 993]
  ------------------
 2687|       |
 2688|    993|    table = (xmlIDTablePtr) doc->ids;
 2689|    993|    if (table == NULL)
  ------------------
  |  Branch (2689:9): [True: 993, False: 0]
  ------------------
 2690|    993|        return(-1);
 2691|       |
 2692|      0|    ID = xmlNodeListGetString(doc, attr->children, 1);
 2693|      0|    if (ID == NULL)
  ------------------
  |  Branch (2693:9): [True: 0, False: 0]
  ------------------
 2694|      0|        return(-1);
 2695|      0|    xmlValidNormalizeString(ID);
 2696|       |
 2697|      0|    id = xmlHashLookup(table, ID);
 2698|      0|    if (id == NULL || id->attr != attr) {
  ------------------
  |  Branch (2698:9): [True: 0, False: 0]
  |  Branch (2698:23): [True: 0, False: 0]
  ------------------
 2699|      0|        xmlFree(ID);
 2700|      0|        return(-1);
 2701|      0|    }
 2702|       |
 2703|      0|    xmlHashRemoveEntry(table, ID, xmlFreeIDTableEntry);
 2704|      0|    xmlFree(ID);
 2705|      0|    attr->atype = 0;
 2706|      0|    return(0);
 2707|      0|}
xmlGetID:
 2719|  2.65k|xmlGetID(xmlDocPtr doc, const xmlChar *ID) {
 2720|  2.65k|    xmlIDTablePtr table;
 2721|  2.65k|    xmlIDPtr id;
 2722|       |
 2723|  2.65k|    if (doc == NULL) {
  ------------------
  |  Branch (2723:9): [True: 0, False: 2.65k]
  ------------------
 2724|      0|	return(NULL);
 2725|      0|    }
 2726|       |
 2727|  2.65k|    if (ID == NULL) {
  ------------------
  |  Branch (2727:9): [True: 0, False: 2.65k]
  ------------------
 2728|      0|	return(NULL);
 2729|      0|    }
 2730|       |
 2731|  2.65k|    table = (xmlIDTablePtr) doc->ids;
 2732|  2.65k|    if (table == NULL)
  ------------------
  |  Branch (2732:9): [True: 0, False: 2.65k]
  ------------------
 2733|      0|        return(NULL);
 2734|       |
 2735|  2.65k|    id = xmlHashLookup(table, ID);
 2736|  2.65k|    if (id == NULL)
  ------------------
  |  Branch (2736:9): [True: 4, False: 2.65k]
  ------------------
 2737|      4|	return(NULL);
 2738|  2.65k|    if (id->attr == NULL) {
  ------------------
  |  Branch (2738:9): [True: 663, False: 1.98k]
  ------------------
 2739|       |	/*
 2740|       |	 * We are operating on a stream, return a well known reference
 2741|       |	 * since the attribute node doesn't exist anymore
 2742|       |	 */
 2743|    663|	return((xmlAttrPtr) doc);
 2744|    663|    }
 2745|  1.98k|    return(id->attr);
 2746|  2.65k|}
xmlAddRef:
 2849|  3.31k|    xmlAttrPtr attr) {
 2850|  3.31k|    xmlRefPtr ret;
 2851|  3.31k|    xmlRefTablePtr table;
 2852|  3.31k|    xmlListPtr ref_list;
 2853|       |
 2854|  3.31k|    if (doc == NULL) {
  ------------------
  |  Branch (2854:9): [True: 0, False: 3.31k]
  ------------------
 2855|      0|        return(NULL);
 2856|      0|    }
 2857|  3.31k|    if (value == NULL) {
  ------------------
  |  Branch (2857:9): [True: 0, False: 3.31k]
  ------------------
 2858|      0|        return(NULL);
 2859|      0|    }
 2860|  3.31k|    if (attr == NULL) {
  ------------------
  |  Branch (2860:9): [True: 0, False: 3.31k]
  ------------------
 2861|      0|        return(NULL);
 2862|      0|    }
 2863|       |
 2864|       |    /*
 2865|       |     * Create the Ref table if needed.
 2866|       |     */
 2867|  3.31k|    table = (xmlRefTablePtr) doc->refs;
 2868|  3.31k|    if (table == NULL) {
  ------------------
  |  Branch (2868:9): [True: 29, False: 3.29k]
  ------------------
 2869|     29|        doc->refs = table = xmlHashCreateDict(0, doc->dict);
 2870|     29|    }
 2871|  3.31k|    if (table == NULL) {
  ------------------
  |  Branch (2871:9): [True: 0, False: 3.31k]
  ------------------
 2872|      0|	xmlVErrMemory(ctxt,
 2873|      0|            "xmlAddRef: Table creation failed!\n");
 2874|      0|        return(NULL);
 2875|      0|    }
 2876|       |
 2877|  3.31k|    ret = (xmlRefPtr) xmlMalloc(sizeof(xmlRef));
 2878|  3.31k|    if (ret == NULL) {
  ------------------
  |  Branch (2878:9): [True: 0, False: 3.31k]
  ------------------
 2879|      0|	xmlVErrMemory(ctxt, "malloc failed");
 2880|      0|        return(NULL);
 2881|      0|    }
 2882|       |
 2883|       |    /*
 2884|       |     * fill the structure.
 2885|       |     */
 2886|  3.31k|    ret->value = xmlStrdup(value);
 2887|  3.31k|    if (xmlIsStreaming(ctxt)) {
  ------------------
  |  Branch (2887:9): [True: 664, False: 2.65k]
  ------------------
 2888|       |	/*
 2889|       |	 * Operating in streaming mode, attr is gonna disappear
 2890|       |	 */
 2891|    664|	ret->name = xmlStrdup(attr->name);
 2892|    664|	ret->attr = NULL;
 2893|  2.65k|    } else {
 2894|  2.65k|	ret->name = NULL;
 2895|  2.65k|	ret->attr = attr;
 2896|  2.65k|    }
 2897|  3.31k|    ret->lineno = xmlGetLineNo(attr->parent);
 2898|       |
 2899|       |    /* To add a reference :-
 2900|       |     * References are maintained as a list of references,
 2901|       |     * Lookup the entry, if no entry create new nodelist
 2902|       |     * Add the owning node to the NodeList
 2903|       |     * Return the ref
 2904|       |     */
 2905|       |
 2906|  3.31k|    if (NULL == (ref_list = xmlHashLookup(table, value))) {
  ------------------
  |  Branch (2906:9): [True: 1.09k, False: 2.22k]
  ------------------
 2907|  1.09k|        if (NULL == (ref_list = xmlListCreate(xmlFreeRef, xmlDummyCompare))) {
  ------------------
  |  Branch (2907:13): [True: 0, False: 1.09k]
  ------------------
 2908|      0|	    xmlErrValid(NULL, XML_ERR_INTERNAL_ERROR,
 2909|      0|		    "xmlAddRef: Reference list creation failed!\n",
 2910|      0|		    NULL);
 2911|      0|	    goto failed;
 2912|      0|        }
 2913|  1.09k|        if (xmlHashAddEntry(table, value, ref_list) < 0) {
  ------------------
  |  Branch (2913:13): [True: 0, False: 1.09k]
  ------------------
 2914|      0|            xmlListDelete(ref_list);
 2915|      0|	    xmlErrValid(NULL, XML_ERR_INTERNAL_ERROR,
 2916|      0|		    "xmlAddRef: Reference list insertion failed!\n",
 2917|      0|		    NULL);
 2918|      0|	    goto failed;
 2919|      0|        }
 2920|  1.09k|    }
 2921|  3.31k|    if (xmlListAppend(ref_list, ret) != 0) {
  ------------------
  |  Branch (2921:9): [True: 0, False: 3.31k]
  ------------------
 2922|      0|	xmlErrValid(NULL, XML_ERR_INTERNAL_ERROR,
 2923|      0|		    "xmlAddRef: Reference list insertion failed!\n",
 2924|      0|		    NULL);
 2925|      0|        goto failed;
 2926|      0|    }
 2927|  3.31k|    return(ret);
 2928|      0|failed:
 2929|      0|    if (ret != NULL) {
  ------------------
  |  Branch (2929:9): [True: 0, False: 0]
  ------------------
 2930|      0|        if (ret->value != NULL)
  ------------------
  |  Branch (2930:13): [True: 0, False: 0]
  ------------------
 2931|      0|	    xmlFree((char *)ret->value);
 2932|      0|        if (ret->name != NULL)
  ------------------
  |  Branch (2932:13): [True: 0, False: 0]
  ------------------
 2933|      0|	    xmlFree((char *)ret->name);
 2934|      0|        xmlFree(ret);
 2935|      0|    }
 2936|      0|    return(NULL);
 2937|  3.31k|}
xmlFreeRefTable:
 2948|     29|xmlFreeRefTable(xmlRefTablePtr table) {
 2949|     29|    xmlHashFree(table, xmlFreeRefTableEntry);
 2950|     29|}
xmlIsRef:
 2967|  80.6k|xmlIsRef(xmlDocPtr doc, xmlNodePtr elem, xmlAttrPtr attr) {
 2968|  80.6k|    if (attr == NULL)
  ------------------
  |  Branch (2968:9): [True: 0, False: 80.6k]
  ------------------
 2969|      0|        return(0);
 2970|  80.6k|    if (doc == NULL) {
  ------------------
  |  Branch (2970:9): [True: 0, False: 80.6k]
  ------------------
 2971|      0|        doc = attr->doc;
 2972|      0|	if (doc == NULL) return(0);
  ------------------
  |  Branch (2972:6): [True: 0, False: 0]
  ------------------
 2973|      0|    }
 2974|       |
 2975|  80.6k|    if ((doc->intSubset == NULL) && (doc->extSubset == NULL)) {
  ------------------
  |  Branch (2975:9): [True: 77.5k, False: 3.11k]
  |  Branch (2975:37): [True: 77.5k, False: 0]
  ------------------
 2976|  77.5k|        return(0);
 2977|  77.5k|    } else if (doc->type == XML_HTML_DOCUMENT_NODE) {
  ------------------
  |  Branch (2977:16): [True: 0, False: 3.11k]
  ------------------
 2978|       |        /* TODO @@@ */
 2979|      0|        return(0);
 2980|  3.11k|    } else {
 2981|  3.11k|        xmlAttributePtr attrDecl;
 2982|       |
 2983|  3.11k|        if (elem == NULL) return(0);
  ------------------
  |  Branch (2983:13): [True: 0, False: 3.11k]
  ------------------
 2984|  3.11k|        attrDecl = xmlGetDtdAttrDesc(doc->intSubset, elem->name, attr->name);
 2985|  3.11k|        if ((attrDecl == NULL) && (doc->extSubset != NULL))
  ------------------
  |  Branch (2985:13): [True: 3.06k, False: 44]
  |  Branch (2985:35): [True: 1.00k, False: 2.06k]
  ------------------
 2986|  1.00k|            attrDecl = xmlGetDtdAttrDesc(doc->extSubset,
 2987|  1.00k|		                         elem->name, attr->name);
 2988|       |
 2989|  3.11k|	if ((attrDecl != NULL) &&
  ------------------
  |  Branch (2989:6): [True: 1.04k, False: 2.06k]
  ------------------
 2990|  3.11k|	    (attrDecl->atype == XML_ATTRIBUTE_IDREF ||
  ------------------
  |  Branch (2990:7): [True: 663, False: 382]
  ------------------
 2991|  1.04k|	     attrDecl->atype == XML_ATTRIBUTE_IDREFS))
  ------------------
  |  Branch (2991:7): [True: 0, False: 382]
  ------------------
 2992|    663|	return(1);
 2993|  3.11k|    }
 2994|  2.44k|    return(0);
 2995|  80.6k|}
xmlGetDtdElementDesc:
 3102|  38.1k|xmlGetDtdElementDesc(xmlDtdPtr dtd, const xmlChar *name) {
 3103|  38.1k|    xmlElementTablePtr table;
 3104|  38.1k|    xmlElementPtr cur;
 3105|  38.1k|    xmlChar *uqname = NULL, *prefix = NULL;
 3106|       |
 3107|  38.1k|    if ((dtd == NULL) || (name == NULL)) return(NULL);
  ------------------
  |  Branch (3107:9): [True: 1.21k, False: 36.8k]
  |  Branch (3107:26): [True: 0, False: 36.8k]
  ------------------
 3108|  36.8k|    if (dtd->elements == NULL)
  ------------------
  |  Branch (3108:9): [True: 16.1k, False: 20.7k]
  ------------------
 3109|  16.1k|	return(NULL);
 3110|  20.7k|    table = (xmlElementTablePtr) dtd->elements;
 3111|       |
 3112|  20.7k|    uqname = xmlSplitQName2(name, &prefix);
 3113|  20.7k|    if (uqname != NULL)
  ------------------
  |  Branch (3113:9): [True: 3, False: 20.7k]
  ------------------
 3114|      3|        name = uqname;
 3115|  20.7k|    cur = xmlHashLookup2(table, name, prefix);
 3116|  20.7k|    if (prefix != NULL) xmlFree(prefix);
  ------------------
  |  Branch (3116:9): [True: 3, False: 20.7k]
  ------------------
 3117|  20.7k|    if (uqname != NULL) xmlFree(uqname);
  ------------------
  |  Branch (3117:9): [True: 3, False: 20.7k]
  ------------------
 3118|  20.7k|    return(cur);
 3119|  36.8k|}
xmlGetDtdQElementDesc:
 3207|    395|	              const xmlChar *prefix) {
 3208|    395|    xmlElementTablePtr table;
 3209|       |
 3210|    395|    if (dtd == NULL) return(NULL);
  ------------------
  |  Branch (3210:9): [True: 0, False: 395]
  ------------------
 3211|    395|    if (dtd->elements == NULL) return(NULL);
  ------------------
  |  Branch (3211:9): [True: 10, False: 385]
  ------------------
 3212|    385|    table = (xmlElementTablePtr) dtd->elements;
 3213|       |
 3214|    385|    return(xmlHashLookup2(table, name, prefix));
 3215|    395|}
xmlGetDtdAttrDesc:
 3230|  19.7k|xmlGetDtdAttrDesc(xmlDtdPtr dtd, const xmlChar *elem, const xmlChar *name) {
 3231|  19.7k|    xmlAttributeTablePtr table;
 3232|  19.7k|    xmlAttributePtr cur;
 3233|  19.7k|    xmlChar *uqname = NULL, *prefix = NULL;
 3234|       |
 3235|  19.7k|    if (dtd == NULL) return(NULL);
  ------------------
  |  Branch (3235:9): [True: 0, False: 19.7k]
  ------------------
 3236|  19.7k|    if (dtd->attributes == NULL) return(NULL);
  ------------------
  |  Branch (3236:9): [True: 11.5k, False: 8.26k]
  ------------------
 3237|       |
 3238|  8.26k|    table = (xmlAttributeTablePtr) dtd->attributes;
 3239|  8.26k|    if (table == NULL)
  ------------------
  |  Branch (3239:9): [True: 0, False: 8.26k]
  ------------------
 3240|      0|	return(NULL);
 3241|       |
 3242|  8.26k|    uqname = xmlSplitQName2(name, &prefix);
 3243|       |
 3244|  8.26k|    if (uqname != NULL) {
  ------------------
  |  Branch (3244:9): [True: 73, False: 8.18k]
  ------------------
 3245|     73|	cur = xmlHashLookup3(table, uqname, prefix, elem);
 3246|     73|	if (prefix != NULL) xmlFree(prefix);
  ------------------
  |  Branch (3246:6): [True: 73, False: 0]
  ------------------
 3247|     73|	if (uqname != NULL) xmlFree(uqname);
  ------------------
  |  Branch (3247:6): [True: 73, False: 0]
  ------------------
 3248|     73|    } else
 3249|  8.18k|	cur = xmlHashLookup3(table, name, NULL, elem);
 3250|  8.26k|    return(cur);
 3251|  8.26k|}
xmlGetDtdQAttrDesc:
 3268|    376|	          const xmlChar *prefix) {
 3269|    376|    xmlAttributeTablePtr table;
 3270|       |
 3271|    376|    if (dtd == NULL) return(NULL);
  ------------------
  |  Branch (3271:9): [True: 0, False: 376]
  ------------------
 3272|    376|    if (dtd->attributes == NULL) return(NULL);
  ------------------
  |  Branch (3272:9): [True: 24, False: 352]
  ------------------
 3273|    352|    table = (xmlAttributeTablePtr) dtd->attributes;
 3274|       |
 3275|    352|    return(xmlHashLookup3(table, name, prefix, elem));
 3276|    376|}
xmlGetDtdNotationDesc:
 3289|      3|xmlGetDtdNotationDesc(xmlDtdPtr dtd, const xmlChar *name) {
 3290|      3|    xmlNotationTablePtr table;
 3291|       |
 3292|      3|    if (dtd == NULL) return(NULL);
  ------------------
  |  Branch (3292:9): [True: 0, False: 3]
  ------------------
 3293|      3|    if (dtd->notations == NULL) return(NULL);
  ------------------
  |  Branch (3293:9): [True: 3, False: 0]
  ------------------
 3294|      0|    table = (xmlNotationTablePtr) dtd->notations;
 3295|       |
 3296|      0|    return(xmlHashLookup(table, name));
 3297|      3|}
xmlValidateNotationUse:
 3314|      3|                       const xmlChar *notationName) {
 3315|      3|    xmlNotationPtr notaDecl;
 3316|      3|    if ((doc == NULL) || (doc->intSubset == NULL) ||
  ------------------
  |  Branch (3316:9): [True: 0, False: 3]
  |  Branch (3316:26): [True: 0, False: 3]
  ------------------
 3317|      3|        (notationName == NULL)) return(-1);
  ------------------
  |  Branch (3317:9): [True: 0, False: 3]
  ------------------
 3318|       |
 3319|      3|    notaDecl = xmlGetDtdNotationDesc(doc->intSubset, notationName);
 3320|      3|    if ((notaDecl == NULL) && (doc->extSubset != NULL))
  ------------------
  |  Branch (3320:9): [True: 3, False: 0]
  |  Branch (3320:31): [True: 0, False: 3]
  ------------------
 3321|      0|	notaDecl = xmlGetDtdNotationDesc(doc->extSubset, notationName);
 3322|       |
 3323|      3|    if ((notaDecl == NULL) && (ctxt != NULL)) {
  ------------------
  |  Branch (3323:9): [True: 3, False: 0]
  |  Branch (3323:31): [True: 3, False: 0]
  ------------------
 3324|      3|	xmlErrValidNode(ctxt, (xmlNodePtr) doc, XML_DTD_UNKNOWN_NOTATION,
 3325|      3|	                "NOTATION %s is not declared\n",
 3326|      3|		        notationName, NULL, NULL);
 3327|      3|	return(0);
 3328|      3|    }
 3329|      0|    return(1);
 3330|      3|}
xmlValidateAttributeDecl:
 4055|  5.83k|                         xmlAttributePtr attr) {
 4056|  5.83k|    int ret = 1;
 4057|  5.83k|    int val;
 4058|  5.83k|    CHECK_DTD;
  ------------------
  |  |  469|  5.83k|   if (doc == NULL) return(0);					\
  |  |  ------------------
  |  |  |  Branch (469:8): [True: 0, False: 5.83k]
  |  |  ------------------
  |  |  470|  5.83k|   else if ((doc->intSubset == NULL) &&				\
  |  |  ------------------
  |  |  |  Branch (470:13): [True: 0, False: 5.83k]
  |  |  ------------------
  |  |  471|  5.83k|	    (doc->extSubset == NULL)) return(0)
  |  |  ------------------
  |  |  |  Branch (471:6): [True: 0, False: 0]
  |  |  ------------------
  ------------------
 4059|  5.83k|    if(attr == NULL) return(1);
  ------------------
  |  Branch (4059:8): [True: 0, False: 5.83k]
  ------------------
 4060|       |
 4061|       |    /* Attribute Default Legal */
 4062|       |    /* Enumeration */
 4063|  5.83k|    if (attr->defaultValue != NULL) {
  ------------------
  |  Branch (4063:9): [True: 1.22k, False: 4.61k]
  ------------------
 4064|  1.22k|	val = xmlValidateAttributeValueInternal(doc, attr->atype,
 4065|  1.22k|	                                        attr->defaultValue);
 4066|  1.22k|	if (val == 0) {
  ------------------
  |  Branch (4066:6): [True: 0, False: 1.22k]
  ------------------
 4067|      0|	    xmlErrValidNode(ctxt, (xmlNodePtr) attr, XML_DTD_ATTRIBUTE_DEFAULT,
 4068|      0|	       "Syntax of default value for attribute %s of %s is not valid\n",
 4069|      0|	           attr->name, attr->elem, NULL);
 4070|      0|	}
 4071|  1.22k|        ret &= val;
 4072|  1.22k|    }
 4073|       |
 4074|       |    /* ID Attribute Default */
 4075|  5.83k|    if ((attr->atype == XML_ATTRIBUTE_ID)&&
  ------------------
  |  Branch (4075:9): [True: 1.29k, False: 4.53k]
  ------------------
 4076|  5.83k|        (attr->def != XML_ATTRIBUTE_IMPLIED) &&
  ------------------
  |  Branch (4076:9): [True: 33, False: 1.26k]
  ------------------
 4077|  5.83k|	(attr->def != XML_ATTRIBUTE_REQUIRED)) {
  ------------------
  |  Branch (4077:2): [True: 0, False: 33]
  ------------------
 4078|      0|	xmlErrValidNode(ctxt, (xmlNodePtr) attr, XML_DTD_ID_FIXED,
 4079|      0|          "ID attribute %s of %s is not valid must be #IMPLIED or #REQUIRED\n",
 4080|      0|	       attr->name, attr->elem, NULL);
 4081|      0|	ret = 0;
 4082|      0|    }
 4083|       |
 4084|       |    /* One ID per Element Type */
 4085|  5.83k|    if (attr->atype == XML_ATTRIBUTE_ID) {
  ------------------
  |  Branch (4085:9): [True: 1.29k, False: 4.53k]
  ------------------
 4086|  1.29k|        int nbId;
 4087|       |
 4088|       |	/* the trick is that we parse DtD as their own internal subset */
 4089|  1.29k|        xmlElementPtr elem = xmlGetDtdElementDesc(doc->intSubset,
 4090|  1.29k|	                                          attr->elem);
 4091|  1.29k|	if (elem != NULL) {
  ------------------
  |  Branch (4091:6): [True: 399, False: 894]
  ------------------
 4092|    399|	    nbId = xmlScanIDAttributeDecl(NULL, elem, 0);
 4093|    894|	} else {
 4094|    894|	    xmlAttributeTablePtr table;
 4095|       |
 4096|       |	    /*
 4097|       |	     * The attribute may be declared in the internal subset and the
 4098|       |	     * element in the external subset.
 4099|       |	     */
 4100|    894|	    nbId = 0;
 4101|    894|	    if (doc->intSubset != NULL) {
  ------------------
  |  Branch (4101:10): [True: 894, False: 0]
  ------------------
 4102|    894|		table = (xmlAttributeTablePtr) doc->intSubset->attributes;
 4103|    894|		xmlHashScan3(table, NULL, NULL, attr->elem,
 4104|    894|			     xmlValidateAttributeIdCallback, &nbId);
 4105|    894|	    }
 4106|    894|	}
 4107|  1.29k|	if (nbId > 1) {
  ------------------
  |  Branch (4107:6): [True: 6, False: 1.28k]
  ------------------
 4108|       |
 4109|      6|	    xmlErrValidNodeNr(ctxt, (xmlNodePtr) attr, XML_DTD_ID_SUBSET,
 4110|      6|       "Element %s has %d ID attribute defined in the internal subset : %s\n",
 4111|      6|		   attr->elem, nbId, attr->name);
 4112|  1.28k|	} else if (doc->extSubset != NULL) {
  ------------------
  |  Branch (4112:13): [True: 894, False: 393]
  ------------------
 4113|    894|	    int extId = 0;
 4114|    894|	    elem = xmlGetDtdElementDesc(doc->extSubset, attr->elem);
 4115|    894|	    if (elem != NULL) {
  ------------------
  |  Branch (4115:10): [True: 894, False: 0]
  ------------------
 4116|    894|		extId = xmlScanIDAttributeDecl(NULL, elem, 0);
 4117|    894|	    }
 4118|    894|	    if (extId > 1) {
  ------------------
  |  Branch (4118:10): [True: 3, False: 891]
  ------------------
 4119|      3|		xmlErrValidNodeNr(ctxt, (xmlNodePtr) attr, XML_DTD_ID_SUBSET,
 4120|      3|       "Element %s has %d ID attribute defined in the external subset : %s\n",
 4121|      3|		       attr->elem, extId, attr->name);
 4122|    891|	    } else if (extId + nbId > 1) {
  ------------------
  |  Branch (4122:17): [True: 0, False: 891]
  ------------------
 4123|      0|		xmlErrValidNode(ctxt, (xmlNodePtr) attr, XML_DTD_ID_SUBSET,
 4124|      0|"Element %s has ID attributes defined in the internal and external subset : %s\n",
 4125|      0|		       attr->elem, attr->name, NULL);
 4126|      0|	    }
 4127|    894|	}
 4128|  1.29k|    }
 4129|       |
 4130|       |    /* Validity Constraint: Enumeration */
 4131|  5.83k|    if ((attr->defaultValue != NULL) && (attr->tree != NULL)) {
  ------------------
  |  Branch (4131:9): [True: 1.22k, False: 4.61k]
  |  Branch (4131:41): [True: 942, False: 279]
  ------------------
 4132|    942|        xmlEnumerationPtr tree = attr->tree;
 4133|    969|	while (tree != NULL) {
  ------------------
  |  Branch (4133:9): [True: 969, False: 0]
  ------------------
 4134|    969|	    if (xmlStrEqual(tree->name, attr->defaultValue)) break;
  ------------------
  |  Branch (4134:10): [True: 942, False: 27]
  ------------------
 4135|     27|	    tree = tree->next;
 4136|     27|	}
 4137|    942|	if (tree == NULL) {
  ------------------
  |  Branch (4137:6): [True: 0, False: 942]
  ------------------
 4138|      0|	    xmlErrValidNode(ctxt, (xmlNodePtr) attr, XML_DTD_ATTRIBUTE_VALUE,
 4139|      0|"Default value \"%s\" for attribute %s of %s is not among the enumerated set\n",
 4140|      0|		   attr->defaultValue, attr->name, attr->elem);
 4141|      0|	    ret = 0;
 4142|      0|	}
 4143|    942|    }
 4144|       |
 4145|  5.83k|    return(ret);
 4146|  5.83k|}
xmlValidateElementDecl:
 4166|  2.33k|                       xmlElementPtr elem) {
 4167|  2.33k|    int ret = 1;
 4168|  2.33k|    xmlElementPtr tst;
 4169|       |
 4170|  2.33k|    CHECK_DTD;
  ------------------
  |  |  469|  2.33k|   if (doc == NULL) return(0);					\
  |  |  ------------------
  |  |  |  Branch (469:8): [True: 0, False: 2.33k]
  |  |  ------------------
  |  |  470|  2.33k|   else if ((doc->intSubset == NULL) &&				\
  |  |  ------------------
  |  |  |  Branch (470:13): [True: 0, False: 2.33k]
  |  |  ------------------
  |  |  471|  2.33k|	    (doc->extSubset == NULL)) return(0)
  |  |  ------------------
  |  |  |  Branch (471:6): [True: 0, False: 0]
  |  |  ------------------
  ------------------
 4171|       |
 4172|  2.33k|    if (elem == NULL) return(1);
  ------------------
  |  Branch (4172:9): [True: 3, False: 2.33k]
  ------------------
 4173|       |
 4174|       |#if 0
 4175|       |#ifdef LIBXML_REGEXP_ENABLED
 4176|       |    /* Build the regexp associated to the content model */
 4177|       |    ret = xmlValidBuildContentModel(ctxt, elem);
 4178|       |#endif
 4179|       |#endif
 4180|       |
 4181|       |    /* No Duplicate Types */
 4182|  2.33k|    if (elem->etype == XML_ELEMENT_TYPE_MIXED) {
  ------------------
  |  Branch (4182:9): [True: 1.02k, False: 1.30k]
  ------------------
 4183|  1.02k|	xmlElementContentPtr cur, next;
 4184|  1.02k|        const xmlChar *name;
 4185|       |
 4186|  1.02k|	cur = elem->content;
 4187|  4.11k|	while (cur != NULL) {
  ------------------
  |  Branch (4187:9): [True: 4.11k, False: 0]
  ------------------
 4188|  4.11k|	    if (cur->type != XML_ELEMENT_CONTENT_OR) break;
  ------------------
  |  Branch (4188:10): [True: 1.02k, False: 3.08k]
  ------------------
 4189|  3.08k|	    if (cur->c1 == NULL) break;
  ------------------
  |  Branch (4189:10): [True: 0, False: 3.08k]
  ------------------
 4190|  3.08k|	    if (cur->c1->type == XML_ELEMENT_CONTENT_ELEMENT) {
  ------------------
  |  Branch (4190:10): [True: 2.73k, False: 351]
  ------------------
 4191|  2.73k|		name = cur->c1->name;
 4192|  2.73k|		next = cur->c2;
 4193|  27.3k|		while (next != NULL) {
  ------------------
  |  Branch (4193:10): [True: 27.3k, False: 0]
  ------------------
 4194|  27.3k|		    if (next->type == XML_ELEMENT_CONTENT_ELEMENT) {
  ------------------
  |  Branch (4194:11): [True: 2.73k, False: 24.6k]
  ------------------
 4195|  2.73k|		        if ((xmlStrEqual(next->name, name)) &&
  ------------------
  |  Branch (4195:15): [True: 9, False: 2.72k]
  ------------------
 4196|  2.73k|			    (xmlStrEqual(next->prefix, cur->c1->prefix))) {
  ------------------
  |  Branch (4196:8): [True: 3, False: 6]
  ------------------
 4197|      3|			    if (cur->c1->prefix == NULL) {
  ------------------
  |  Branch (4197:12): [True: 3, False: 0]
  ------------------
 4198|      3|				xmlErrValidNode(ctxt, (xmlNodePtr) elem, XML_DTD_CONTENT_ERROR,
 4199|      3|		   "Definition of %s has duplicate references of %s\n",
 4200|      3|				       elem->name, name, NULL);
 4201|      3|			    } else {
 4202|      0|				xmlErrValidNode(ctxt, (xmlNodePtr) elem, XML_DTD_CONTENT_ERROR,
 4203|      0|		   "Definition of %s has duplicate references of %s:%s\n",
 4204|      0|				       elem->name, cur->c1->prefix, name);
 4205|      0|			    }
 4206|      3|			    ret = 0;
 4207|      3|			}
 4208|  2.73k|			break;
 4209|  2.73k|		    }
 4210|  24.6k|		    if (next->c1 == NULL) break;
  ------------------
  |  Branch (4210:11): [True: 0, False: 24.6k]
  ------------------
 4211|  24.6k|		    if (next->c1->type != XML_ELEMENT_CONTENT_ELEMENT) break;
  ------------------
  |  Branch (4211:11): [True: 0, False: 24.6k]
  ------------------
 4212|  24.6k|		    if ((xmlStrEqual(next->c1->name, name)) &&
  ------------------
  |  Branch (4212:11): [True: 0, False: 24.6k]
  ------------------
 4213|  24.6k|		        (xmlStrEqual(next->c1->prefix, cur->c1->prefix))) {
  ------------------
  |  Branch (4213:11): [True: 0, False: 0]
  ------------------
 4214|      0|			if (cur->c1->prefix == NULL) {
  ------------------
  |  Branch (4214:8): [True: 0, False: 0]
  ------------------
 4215|      0|			    xmlErrValidNode(ctxt, (xmlNodePtr) elem, XML_DTD_CONTENT_ERROR,
 4216|      0|	       "Definition of %s has duplicate references to %s\n",
 4217|      0|				   elem->name, name, NULL);
 4218|      0|			} else {
 4219|      0|			    xmlErrValidNode(ctxt, (xmlNodePtr) elem, XML_DTD_CONTENT_ERROR,
 4220|      0|	       "Definition of %s has duplicate references to %s:%s\n",
 4221|      0|				   elem->name, cur->c1->prefix, name);
 4222|      0|			}
 4223|      0|			ret = 0;
 4224|      0|		    }
 4225|  24.6k|		    next = next->c2;
 4226|  24.6k|		}
 4227|  2.73k|	    }
 4228|  3.08k|	    cur = cur->c2;
 4229|  3.08k|	}
 4230|  1.02k|    }
 4231|       |
 4232|       |    /* VC: Unique Element Type Declaration */
 4233|  2.33k|    tst = xmlGetDtdElementDesc(doc->intSubset, elem->name);
 4234|  2.33k|    if ((tst != NULL ) && (tst != elem) &&
  ------------------
  |  Branch (4234:9): [True: 1.14k, False: 1.18k]
  |  Branch (4234:27): [True: 6, False: 1.14k]
  ------------------
 4235|  2.33k|	((tst->prefix == elem->prefix) ||
  ------------------
  |  Branch (4235:3): [True: 3, False: 3]
  ------------------
 4236|      6|	 (xmlStrEqual(tst->prefix, elem->prefix))) &&
  ------------------
  |  Branch (4236:3): [True: 0, False: 3]
  ------------------
 4237|  2.33k|	(tst->etype != XML_ELEMENT_TYPE_UNDEFINED)) {
  ------------------
  |  Branch (4237:2): [True: 3, False: 0]
  ------------------
 4238|      3|	xmlErrValidNode(ctxt, (xmlNodePtr) elem, XML_DTD_ELEM_REDEFINED,
 4239|      3|	                "Redefinition of element %s\n",
 4240|      3|		       elem->name, NULL, NULL);
 4241|      3|	ret = 0;
 4242|      3|    }
 4243|  2.33k|    tst = xmlGetDtdElementDesc(doc->extSubset, elem->name);
 4244|  2.33k|    if ((tst != NULL ) && (tst != elem) &&
  ------------------
  |  Branch (4244:9): [True: 1.11k, False: 1.21k]
  |  Branch (4244:27): [True: 3, False: 1.11k]
  ------------------
 4245|  2.33k|	((tst->prefix == elem->prefix) ||
  ------------------
  |  Branch (4245:3): [True: 0, False: 3]
  ------------------
 4246|      3|	 (xmlStrEqual(tst->prefix, elem->prefix))) &&
  ------------------
  |  Branch (4246:3): [True: 0, False: 3]
  ------------------
 4247|  2.33k|	(tst->etype != XML_ELEMENT_TYPE_UNDEFINED)) {
  ------------------
  |  Branch (4247:2): [True: 0, False: 0]
  ------------------
 4248|      0|	xmlErrValidNode(ctxt, (xmlNodePtr) elem, XML_DTD_ELEM_REDEFINED,
 4249|      0|	                "Redefinition of element %s\n",
 4250|      0|		       elem->name, NULL, NULL);
 4251|      0|	ret = 0;
 4252|      0|    }
 4253|       |    /* One ID per Element Type
 4254|       |     * already done when registering the attribute
 4255|       |    if (xmlScanIDAttributeDecl(ctxt, elem) > 1) {
 4256|       |	ret = 0;
 4257|       |    } */
 4258|  2.33k|    return(ret);
 4259|  2.33k|}
xmlValidateOneAttribute:
 4289|  5.92k|{
 4290|  5.92k|    xmlAttributePtr attrDecl =  NULL;
 4291|  5.92k|    int val;
 4292|  5.92k|    int ret = 1;
 4293|       |
 4294|  5.92k|    CHECK_DTD;
  ------------------
  |  |  469|  5.92k|   if (doc == NULL) return(0);					\
  |  |  ------------------
  |  |  |  Branch (469:8): [True: 0, False: 5.92k]
  |  |  ------------------
  |  |  470|  5.92k|   else if ((doc->intSubset == NULL) &&				\
  |  |  ------------------
  |  |  |  Branch (470:13): [True: 0, False: 5.92k]
  |  |  ------------------
  |  |  471|  5.92k|	    (doc->extSubset == NULL)) return(0)
  |  |  ------------------
  |  |  |  Branch (471:6): [True: 0, False: 0]
  |  |  ------------------
  ------------------
 4295|  5.92k|    if ((elem == NULL) || (elem->name == NULL)) return(0);
  ------------------
  |  Branch (4295:9): [True: 0, False: 5.92k]
  |  Branch (4295:27): [True: 0, False: 5.92k]
  ------------------
 4296|  5.92k|    if ((attr == NULL) || (attr->name == NULL)) return(0);
  ------------------
  |  Branch (4296:9): [True: 0, False: 5.92k]
  |  Branch (4296:27): [True: 0, False: 5.92k]
  ------------------
 4297|       |
 4298|  5.92k|    if ((elem->ns != NULL) && (elem->ns->prefix != NULL)) {
  ------------------
  |  Branch (4298:9): [True: 288, False: 5.63k]
  |  Branch (4298:31): [True: 284, False: 4]
  ------------------
 4299|    284|	xmlChar fn[50];
 4300|    284|	xmlChar *fullname;
 4301|       |
 4302|    284|	fullname = xmlBuildQName(elem->name, elem->ns->prefix, fn, 50);
 4303|    284|	if (fullname == NULL)
  ------------------
  |  Branch (4303:6): [True: 0, False: 284]
  ------------------
 4304|      0|	    return(0);
 4305|    284|	if (attr->ns != NULL) {
  ------------------
  |  Branch (4305:6): [True: 284, False: 0]
  ------------------
 4306|    284|	    attrDecl = xmlGetDtdQAttrDesc(doc->intSubset, fullname,
 4307|    284|		                          attr->name, attr->ns->prefix);
 4308|    284|	    if ((attrDecl == NULL) && (doc->extSubset != NULL))
  ------------------
  |  Branch (4308:10): [True: 4, False: 280]
  |  Branch (4308:32): [True: 0, False: 4]
  ------------------
 4309|      0|		attrDecl = xmlGetDtdQAttrDesc(doc->extSubset, fullname,
 4310|      0|					      attr->name, attr->ns->prefix);
 4311|    284|	} else {
 4312|      0|	    attrDecl = xmlGetDtdAttrDesc(doc->intSubset, fullname, attr->name);
 4313|      0|	    if ((attrDecl == NULL) && (doc->extSubset != NULL))
  ------------------
  |  Branch (4313:10): [True: 0, False: 0]
  |  Branch (4313:32): [True: 0, False: 0]
  ------------------
 4314|      0|		attrDecl = xmlGetDtdAttrDesc(doc->extSubset,
 4315|      0|					     fullname, attr->name);
 4316|      0|	}
 4317|    284|	if ((fullname != fn) && (fullname != elem->name))
  ------------------
  |  Branch (4317:6): [True: 0, False: 284]
  |  Branch (4317:26): [True: 0, False: 0]
  ------------------
 4318|      0|	    xmlFree(fullname);
 4319|    284|    }
 4320|  5.92k|    if (attrDecl == NULL) {
  ------------------
  |  Branch (4320:9): [True: 5.64k, False: 280]
  ------------------
 4321|  5.64k|	if (attr->ns != NULL) {
  ------------------
  |  Branch (4321:6): [True: 16, False: 5.62k]
  ------------------
 4322|     16|	    attrDecl = xmlGetDtdQAttrDesc(doc->intSubset, elem->name,
 4323|     16|		                          attr->name, attr->ns->prefix);
 4324|     16|	    if ((attrDecl == NULL) && (doc->extSubset != NULL))
  ------------------
  |  Branch (4324:10): [True: 8, False: 8]
  |  Branch (4324:32): [True: 4, False: 4]
  ------------------
 4325|      4|		attrDecl = xmlGetDtdQAttrDesc(doc->extSubset, elem->name,
 4326|      4|					      attr->name, attr->ns->prefix);
 4327|  5.62k|	} else {
 4328|  5.62k|	    attrDecl = xmlGetDtdAttrDesc(doc->intSubset,
 4329|  5.62k|		                         elem->name, attr->name);
 4330|  5.62k|	    if ((attrDecl == NULL) && (doc->extSubset != NULL))
  ------------------
  |  Branch (4330:10): [True: 5.42k, False: 196]
  |  Branch (4330:32): [True: 5.26k, False: 161]
  ------------------
 4331|  5.26k|		attrDecl = xmlGetDtdAttrDesc(doc->extSubset,
 4332|  5.26k|					     elem->name, attr->name);
 4333|  5.62k|	}
 4334|  5.64k|    }
 4335|       |
 4336|       |
 4337|       |    /* Validity Constraint: Attribute Value Type */
 4338|  5.92k|    if (attrDecl == NULL) {
  ------------------
  |  Branch (4338:9): [True: 165, False: 5.75k]
  ------------------
 4339|    165|	xmlErrValidNode(ctxt, elem, XML_DTD_UNKNOWN_ATTRIBUTE,
 4340|    165|	       "No declaration for attribute %s of element %s\n",
 4341|    165|	       attr->name, elem->name, NULL);
 4342|    165|	return(0);
 4343|    165|    }
 4344|  5.75k|    attr->atype = attrDecl->atype;
 4345|       |
 4346|  5.75k|    val = xmlValidateAttributeValueInternal(doc, attrDecl->atype, value);
 4347|  5.75k|    if (val == 0) {
  ------------------
  |  Branch (4347:9): [True: 64, False: 5.69k]
  ------------------
 4348|     64|	    xmlErrValidNode(ctxt, elem, XML_DTD_ATTRIBUTE_VALUE,
 4349|     64|	   "Syntax of value for attribute %s of %s is not valid\n",
 4350|     64|	       attr->name, elem->name, NULL);
 4351|     64|        ret = 0;
 4352|     64|    }
 4353|       |
 4354|       |    /* Validity constraint: Fixed Attribute Default */
 4355|  5.75k|    if (attrDecl->def == XML_ATTRIBUTE_FIXED) {
  ------------------
  |  Branch (4355:9): [True: 16, False: 5.74k]
  ------------------
 4356|     16|	if (!xmlStrEqual(value, attrDecl->defaultValue)) {
  ------------------
  |  Branch (4356:6): [True: 0, False: 16]
  ------------------
 4357|      0|	    xmlErrValidNode(ctxt, elem, XML_DTD_ATTRIBUTE_DEFAULT,
 4358|      0|	   "Value for attribute %s of %s is different from default \"%s\"\n",
 4359|      0|		   attr->name, elem->name, attrDecl->defaultValue);
 4360|      0|	    ret = 0;
 4361|      0|	}
 4362|     16|    }
 4363|       |
 4364|       |    /* Validity Constraint: ID uniqueness */
 4365|  5.75k|    if (attrDecl->atype == XML_ATTRIBUTE_ID) {
  ------------------
  |  Branch (4365:9): [True: 1.30k, False: 4.45k]
  ------------------
 4366|  1.30k|        if (xmlAddID(ctxt, doc, value, attr) == NULL)
  ------------------
  |  Branch (4366:13): [True: 4, False: 1.29k]
  ------------------
 4367|      4|	    ret = 0;
 4368|  1.30k|    }
 4369|       |
 4370|  5.75k|    if ((attrDecl->atype == XML_ATTRIBUTE_IDREF) ||
  ------------------
  |  Branch (4370:9): [True: 2.65k, False: 3.10k]
  ------------------
 4371|  5.75k|	(attrDecl->atype == XML_ATTRIBUTE_IDREFS)) {
  ------------------
  |  Branch (4371:2): [True: 0, False: 3.10k]
  ------------------
 4372|  2.65k|        if (xmlAddRef(ctxt, doc, value, attr) == NULL)
  ------------------
  |  Branch (4372:13): [True: 0, False: 2.65k]
  ------------------
 4373|      0|	    ret = 0;
 4374|  2.65k|    }
 4375|       |
 4376|       |    /* Validity Constraint: Notation Attributes */
 4377|  5.75k|    if (attrDecl->atype == XML_ATTRIBUTE_NOTATION) {
  ------------------
  |  Branch (4377:9): [True: 0, False: 5.75k]
  ------------------
 4378|      0|        xmlEnumerationPtr tree = attrDecl->tree;
 4379|      0|        xmlNotationPtr nota;
 4380|       |
 4381|       |        /* First check that the given NOTATION was declared */
 4382|      0|	nota = xmlGetDtdNotationDesc(doc->intSubset, value);
 4383|      0|	if (nota == NULL)
  ------------------
  |  Branch (4383:6): [True: 0, False: 0]
  ------------------
 4384|      0|	    nota = xmlGetDtdNotationDesc(doc->extSubset, value);
 4385|       |
 4386|      0|	if (nota == NULL) {
  ------------------
  |  Branch (4386:6): [True: 0, False: 0]
  ------------------
 4387|      0|	    xmlErrValidNode(ctxt, elem, XML_DTD_UNKNOWN_NOTATION,
 4388|      0|       "Value \"%s\" for attribute %s of %s is not a declared Notation\n",
 4389|      0|		   value, attr->name, elem->name);
 4390|      0|	    ret = 0;
 4391|      0|        }
 4392|       |
 4393|       |	/* Second, verify that it's among the list */
 4394|      0|	while (tree != NULL) {
  ------------------
  |  Branch (4394:9): [True: 0, False: 0]
  ------------------
 4395|      0|	    if (xmlStrEqual(tree->name, value)) break;
  ------------------
  |  Branch (4395:10): [True: 0, False: 0]
  ------------------
 4396|      0|	    tree = tree->next;
 4397|      0|	}
 4398|      0|	if (tree == NULL) {
  ------------------
  |  Branch (4398:6): [True: 0, False: 0]
  ------------------
 4399|      0|	    xmlErrValidNode(ctxt, elem, XML_DTD_NOTATION_VALUE,
 4400|      0|"Value \"%s\" for attribute %s of %s is not among the enumerated notations\n",
 4401|      0|		   value, attr->name, elem->name);
 4402|      0|	    ret = 0;
 4403|      0|	}
 4404|      0|    }
 4405|       |
 4406|       |    /* Validity Constraint: Enumeration */
 4407|  5.75k|    if (attrDecl->atype == XML_ATTRIBUTE_ENUMERATION) {
  ------------------
  |  Branch (4407:9): [True: 104, False: 5.65k]
  ------------------
 4408|    104|        xmlEnumerationPtr tree = attrDecl->tree;
 4409|    236|	while (tree != NULL) {
  ------------------
  |  Branch (4409:9): [True: 232, False: 4]
  ------------------
 4410|    232|	    if (xmlStrEqual(tree->name, value)) break;
  ------------------
  |  Branch (4410:10): [True: 100, False: 132]
  ------------------
 4411|    132|	    tree = tree->next;
 4412|    132|	}
 4413|    104|	if (tree == NULL) {
  ------------------
  |  Branch (4413:6): [True: 4, False: 100]
  ------------------
 4414|      4|	    xmlErrValidNode(ctxt, elem, XML_DTD_ATTRIBUTE_VALUE,
 4415|      4|       "Value \"%s\" for attribute %s of %s is not among the enumerated set\n",
 4416|      4|		   value, attr->name, elem->name);
 4417|      4|	    ret = 0;
 4418|      4|	}
 4419|    104|    }
 4420|       |
 4421|       |    /* Fixed Attribute Default */
 4422|  5.75k|    if ((attrDecl->def == XML_ATTRIBUTE_FIXED) &&
  ------------------
  |  Branch (4422:9): [True: 16, False: 5.74k]
  ------------------
 4423|  5.75k|        (!xmlStrEqual(attrDecl->defaultValue, value))) {
  ------------------
  |  Branch (4423:9): [True: 0, False: 16]
  ------------------
 4424|      0|	xmlErrValidNode(ctxt, elem, XML_DTD_ATTRIBUTE_VALUE,
 4425|      0|	   "Value for attribute %s of %s must be \"%s\"\n",
 4426|      0|	       attr->name, elem->name, attrDecl->defaultValue);
 4427|      0|        ret = 0;
 4428|      0|    }
 4429|       |
 4430|       |    /* Extra check for the attribute value */
 4431|  5.75k|    ret &= xmlValidateAttributeValue2(ctxt, doc, attr->name,
 4432|  5.75k|				      attrDecl->atype, value);
 4433|       |
 4434|  5.75k|    return(ret);
 4435|  5.92k|}
xmlValidateOneNamespace:
 4465|     78|xmlNodePtr elem, const xmlChar *prefix, xmlNsPtr ns, const xmlChar *value) {
 4466|       |    /* xmlElementPtr elemDecl; */
 4467|     78|    xmlAttributePtr attrDecl =  NULL;
 4468|     78|    int val;
 4469|     78|    int ret = 1;
 4470|       |
 4471|     78|    CHECK_DTD;
  ------------------
  |  |  469|     78|   if (doc == NULL) return(0);					\
  |  |  ------------------
  |  |  |  Branch (469:8): [True: 0, False: 78]
  |  |  ------------------
  |  |  470|     78|   else if ((doc->intSubset == NULL) &&				\
  |  |  ------------------
  |  |  |  Branch (470:13): [True: 0, False: 78]
  |  |  ------------------
  |  |  471|     78|	    (doc->extSubset == NULL)) return(0)
  |  |  ------------------
  |  |  |  Branch (471:6): [True: 0, False: 0]
  |  |  ------------------
  ------------------
 4472|     78|    if ((elem == NULL) || (elem->name == NULL)) return(0);
  ------------------
  |  Branch (4472:9): [True: 0, False: 78]
  |  Branch (4472:27): [True: 0, False: 78]
  ------------------
 4473|     78|    if ((ns == NULL) || (ns->href == NULL)) return(0);
  ------------------
  |  Branch (4473:9): [True: 0, False: 78]
  |  Branch (4473:25): [True: 10, False: 68]
  ------------------
 4474|       |
 4475|     68|    if (prefix != NULL) {
  ------------------
  |  Branch (4475:9): [True: 28, False: 40]
  ------------------
 4476|     28|	xmlChar fn[50];
 4477|     28|	xmlChar *fullname;
 4478|       |
 4479|     28|	fullname = xmlBuildQName(elem->name, prefix, fn, 50);
 4480|     28|	if (fullname == NULL) {
  ------------------
  |  Branch (4480:6): [True: 0, False: 28]
  ------------------
 4481|      0|	    xmlVErrMemory(ctxt, "Validating namespace");
 4482|      0|	    return(0);
 4483|      0|	}
 4484|     28|	if (ns->prefix != NULL) {
  ------------------
  |  Branch (4484:6): [True: 28, False: 0]
  ------------------
 4485|     28|	    attrDecl = xmlGetDtdQAttrDesc(doc->intSubset, fullname,
 4486|     28|		                          ns->prefix, BAD_CAST "xmlns");
  ------------------
  |  |   35|     28|#define BAD_CAST (xmlChar *)
  ------------------
 4487|     28|	    if ((attrDecl == NULL) && (doc->extSubset != NULL))
  ------------------
  |  Branch (4487:10): [True: 8, False: 20]
  |  Branch (4487:32): [True: 4, False: 4]
  ------------------
 4488|      4|		attrDecl = xmlGetDtdQAttrDesc(doc->extSubset, fullname,
 4489|      4|					  ns->prefix, BAD_CAST "xmlns");
  ------------------
  |  |   35|      4|#define BAD_CAST (xmlChar *)
  ------------------
 4490|     28|	} else {
 4491|      0|	    attrDecl = xmlGetDtdAttrDesc(doc->intSubset, fullname,
 4492|      0|		                         BAD_CAST "xmlns");
  ------------------
  |  |   35|      0|#define BAD_CAST (xmlChar *)
  ------------------
 4493|      0|	    if ((attrDecl == NULL) && (doc->extSubset != NULL))
  ------------------
  |  Branch (4493:10): [True: 0, False: 0]
  |  Branch (4493:32): [True: 0, False: 0]
  ------------------
 4494|      0|		attrDecl = xmlGetDtdAttrDesc(doc->extSubset, fullname,
 4495|      0|			                 BAD_CAST "xmlns");
  ------------------
  |  |   35|      0|#define BAD_CAST (xmlChar *)
  ------------------
 4496|      0|	}
 4497|     28|	if ((fullname != fn) && (fullname != elem->name))
  ------------------
  |  Branch (4497:6): [True: 0, False: 28]
  |  Branch (4497:26): [True: 0, False: 0]
  ------------------
 4498|      0|	    xmlFree(fullname);
 4499|     28|    }
 4500|     68|    if (attrDecl == NULL) {
  ------------------
  |  Branch (4500:9): [True: 48, False: 20]
  ------------------
 4501|     48|	if (ns->prefix != NULL) {
  ------------------
  |  Branch (4501:6): [True: 32, False: 16]
  ------------------
 4502|     32|	    attrDecl = xmlGetDtdQAttrDesc(doc->intSubset, elem->name,
 4503|     32|		                          ns->prefix, BAD_CAST "xmlns");
  ------------------
  |  |   35|     32|#define BAD_CAST (xmlChar *)
  ------------------
 4504|     32|	    if ((attrDecl == NULL) && (doc->extSubset != NULL))
  ------------------
  |  Branch (4504:10): [True: 16, False: 16]
  |  Branch (4504:32): [True: 8, False: 8]
  ------------------
 4505|      8|		attrDecl = xmlGetDtdQAttrDesc(doc->extSubset, elem->name,
 4506|      8|					      ns->prefix, BAD_CAST "xmlns");
  ------------------
  |  |   35|      8|#define BAD_CAST (xmlChar *)
  ------------------
 4507|     32|	} else {
 4508|     16|	    attrDecl = xmlGetDtdAttrDesc(doc->intSubset,
 4509|     16|		                         elem->name, BAD_CAST "xmlns");
  ------------------
  |  |   35|     16|#define BAD_CAST (xmlChar *)
  ------------------
 4510|     16|	    if ((attrDecl == NULL) && (doc->extSubset != NULL))
  ------------------
  |  Branch (4510:10): [True: 8, False: 8]
  |  Branch (4510:32): [True: 0, False: 8]
  ------------------
 4511|      0|		attrDecl = xmlGetDtdAttrDesc(doc->extSubset,
 4512|      0|					     elem->name, BAD_CAST "xmlns");
  ------------------
  |  |   35|      0|#define BAD_CAST (xmlChar *)
  ------------------
 4513|     16|	}
 4514|     48|    }
 4515|       |
 4516|       |
 4517|       |    /* Validity Constraint: Attribute Value Type */
 4518|     68|    if (attrDecl == NULL) {
  ------------------
  |  Branch (4518:9): [True: 16, False: 52]
  ------------------
 4519|     16|	if (ns->prefix != NULL) {
  ------------------
  |  Branch (4519:6): [True: 8, False: 8]
  ------------------
 4520|      8|	    xmlErrValidNode(ctxt, elem, XML_DTD_UNKNOWN_ATTRIBUTE,
 4521|      8|		   "No declaration for attribute xmlns:%s of element %s\n",
 4522|      8|		   ns->prefix, elem->name, NULL);
 4523|      8|	} else {
 4524|      8|	    xmlErrValidNode(ctxt, elem, XML_DTD_UNKNOWN_ATTRIBUTE,
 4525|      8|		   "No declaration for attribute xmlns of element %s\n",
 4526|      8|		   elem->name, NULL, NULL);
 4527|      8|	}
 4528|     16|	return(0);
 4529|     16|    }
 4530|       |
 4531|     52|    val = xmlValidateAttributeValueInternal(doc, attrDecl->atype, value);
 4532|     52|    if (val == 0) {
  ------------------
  |  Branch (4532:9): [True: 0, False: 52]
  ------------------
 4533|      0|	if (ns->prefix != NULL) {
  ------------------
  |  Branch (4533:6): [True: 0, False: 0]
  ------------------
 4534|      0|	    xmlErrValidNode(ctxt, elem, XML_DTD_INVALID_DEFAULT,
 4535|      0|	       "Syntax of value for attribute xmlns:%s of %s is not valid\n",
 4536|      0|		   ns->prefix, elem->name, NULL);
 4537|      0|	} else {
 4538|      0|	    xmlErrValidNode(ctxt, elem, XML_DTD_INVALID_DEFAULT,
 4539|      0|	       "Syntax of value for attribute xmlns of %s is not valid\n",
 4540|      0|		   elem->name, NULL, NULL);
 4541|      0|	}
 4542|      0|        ret = 0;
 4543|      0|    }
 4544|       |
 4545|       |    /* Validity constraint: Fixed Attribute Default */
 4546|     52|    if (attrDecl->def == XML_ATTRIBUTE_FIXED) {
  ------------------
  |  Branch (4546:9): [True: 36, False: 16]
  ------------------
 4547|     36|	if (!xmlStrEqual(value, attrDecl->defaultValue)) {
  ------------------
  |  Branch (4547:6): [True: 4, False: 32]
  ------------------
 4548|      4|	    if (ns->prefix != NULL) {
  ------------------
  |  Branch (4548:10): [True: 0, False: 4]
  ------------------
 4549|      0|		xmlErrValidNode(ctxt, elem, XML_DTD_ATTRIBUTE_DEFAULT,
 4550|      0|       "Value for attribute xmlns:%s of %s is different from default \"%s\"\n",
 4551|      0|		       ns->prefix, elem->name, attrDecl->defaultValue);
 4552|      4|	    } else {
 4553|      4|		xmlErrValidNode(ctxt, elem, XML_DTD_ATTRIBUTE_DEFAULT,
 4554|      4|       "Value for attribute xmlns of %s is different from default \"%s\"\n",
 4555|      4|		       elem->name, attrDecl->defaultValue, NULL);
 4556|      4|	    }
 4557|      4|	    ret = 0;
 4558|      4|	}
 4559|     36|    }
 4560|       |
 4561|       |    /*
 4562|       |     * Casting ns to xmlAttrPtr is wrong. We'd need separate functions
 4563|       |     * xmlAddID and xmlAddRef for namespace declarations, but it makes
 4564|       |     * no practical sense to use ID types anyway.
 4565|       |     */
 4566|       |#if 0
 4567|       |    /* Validity Constraint: ID uniqueness */
 4568|       |    if (attrDecl->atype == XML_ATTRIBUTE_ID) {
 4569|       |        if (xmlAddID(ctxt, doc, value, (xmlAttrPtr) ns) == NULL)
 4570|       |	    ret = 0;
 4571|       |    }
 4572|       |
 4573|       |    if ((attrDecl->atype == XML_ATTRIBUTE_IDREF) ||
 4574|       |	(attrDecl->atype == XML_ATTRIBUTE_IDREFS)) {
 4575|       |        if (xmlAddRef(ctxt, doc, value, (xmlAttrPtr) ns) == NULL)
 4576|       |	    ret = 0;
 4577|       |    }
 4578|       |#endif
 4579|       |
 4580|       |    /* Validity Constraint: Notation Attributes */
 4581|     52|    if (attrDecl->atype == XML_ATTRIBUTE_NOTATION) {
  ------------------
  |  Branch (4581:9): [True: 0, False: 52]
  ------------------
 4582|      0|        xmlEnumerationPtr tree = attrDecl->tree;
 4583|      0|        xmlNotationPtr nota;
 4584|       |
 4585|       |        /* First check that the given NOTATION was declared */
 4586|      0|	nota = xmlGetDtdNotationDesc(doc->intSubset, value);
 4587|      0|	if (nota == NULL)
  ------------------
  |  Branch (4587:6): [True: 0, False: 0]
  ------------------
 4588|      0|	    nota = xmlGetDtdNotationDesc(doc->extSubset, value);
 4589|       |
 4590|      0|	if (nota == NULL) {
  ------------------
  |  Branch (4590:6): [True: 0, False: 0]
  ------------------
 4591|      0|	    if (ns->prefix != NULL) {
  ------------------
  |  Branch (4591:10): [True: 0, False: 0]
  ------------------
 4592|      0|		xmlErrValidNode(ctxt, elem, XML_DTD_UNKNOWN_NOTATION,
 4593|      0|       "Value \"%s\" for attribute xmlns:%s of %s is not a declared Notation\n",
 4594|      0|		       value, ns->prefix, elem->name);
 4595|      0|	    } else {
 4596|      0|		xmlErrValidNode(ctxt, elem, XML_DTD_UNKNOWN_NOTATION,
 4597|      0|       "Value \"%s\" for attribute xmlns of %s is not a declared Notation\n",
 4598|      0|		       value, elem->name, NULL);
 4599|      0|	    }
 4600|      0|	    ret = 0;
 4601|      0|        }
 4602|       |
 4603|       |	/* Second, verify that it's among the list */
 4604|      0|	while (tree != NULL) {
  ------------------
  |  Branch (4604:9): [True: 0, False: 0]
  ------------------
 4605|      0|	    if (xmlStrEqual(tree->name, value)) break;
  ------------------
  |  Branch (4605:10): [True: 0, False: 0]
  ------------------
 4606|      0|	    tree = tree->next;
 4607|      0|	}
 4608|      0|	if (tree == NULL) {
  ------------------
  |  Branch (4608:6): [True: 0, False: 0]
  ------------------
 4609|      0|	    if (ns->prefix != NULL) {
  ------------------
  |  Branch (4609:10): [True: 0, False: 0]
  ------------------
 4610|      0|		xmlErrValidNode(ctxt, elem, XML_DTD_NOTATION_VALUE,
 4611|      0|"Value \"%s\" for attribute xmlns:%s of %s is not among the enumerated notations\n",
 4612|      0|		       value, ns->prefix, elem->name);
 4613|      0|	    } else {
 4614|      0|		xmlErrValidNode(ctxt, elem, XML_DTD_NOTATION_VALUE,
 4615|      0|"Value \"%s\" for attribute xmlns of %s is not among the enumerated notations\n",
 4616|      0|		       value, elem->name, NULL);
 4617|      0|	    }
 4618|      0|	    ret = 0;
 4619|      0|	}
 4620|      0|    }
 4621|       |
 4622|       |    /* Validity Constraint: Enumeration */
 4623|     52|    if (attrDecl->atype == XML_ATTRIBUTE_ENUMERATION) {
  ------------------
  |  Branch (4623:9): [True: 0, False: 52]
  ------------------
 4624|      0|        xmlEnumerationPtr tree = attrDecl->tree;
 4625|      0|	while (tree != NULL) {
  ------------------
  |  Branch (4625:9): [True: 0, False: 0]
  ------------------
 4626|      0|	    if (xmlStrEqual(tree->name, value)) break;
  ------------------
  |  Branch (4626:10): [True: 0, False: 0]
  ------------------
 4627|      0|	    tree = tree->next;
 4628|      0|	}
 4629|      0|	if (tree == NULL) {
  ------------------
  |  Branch (4629:6): [True: 0, False: 0]
  ------------------
 4630|      0|	    if (ns->prefix != NULL) {
  ------------------
  |  Branch (4630:10): [True: 0, False: 0]
  ------------------
 4631|      0|		xmlErrValidNode(ctxt, elem, XML_DTD_ATTRIBUTE_VALUE,
 4632|      0|"Value \"%s\" for attribute xmlns:%s of %s is not among the enumerated set\n",
 4633|      0|		       value, ns->prefix, elem->name);
 4634|      0|	    } else {
 4635|      0|		xmlErrValidNode(ctxt, elem, XML_DTD_ATTRIBUTE_VALUE,
 4636|      0|"Value \"%s\" for attribute xmlns of %s is not among the enumerated set\n",
 4637|      0|		       value, elem->name, NULL);
 4638|      0|	    }
 4639|      0|	    ret = 0;
 4640|      0|	}
 4641|      0|    }
 4642|       |
 4643|       |    /* Fixed Attribute Default */
 4644|     52|    if ((attrDecl->def == XML_ATTRIBUTE_FIXED) &&
  ------------------
  |  Branch (4644:9): [True: 36, False: 16]
  ------------------
 4645|     52|        (!xmlStrEqual(attrDecl->defaultValue, value))) {
  ------------------
  |  Branch (4645:9): [True: 4, False: 32]
  ------------------
 4646|      4|	if (ns->prefix != NULL) {
  ------------------
  |  Branch (4646:6): [True: 0, False: 4]
  ------------------
 4647|      0|	    xmlErrValidNode(ctxt, elem, XML_DTD_ELEM_NAMESPACE,
 4648|      0|		   "Value for attribute xmlns:%s of %s must be \"%s\"\n",
 4649|      0|		   ns->prefix, elem->name, attrDecl->defaultValue);
 4650|      4|	} else {
 4651|      4|	    xmlErrValidNode(ctxt, elem, XML_DTD_ELEM_NAMESPACE,
 4652|      4|		   "Value for attribute xmlns of %s must be \"%s\"\n",
 4653|      4|		   elem->name, attrDecl->defaultValue, NULL);
 4654|      4|	}
 4655|      4|        ret = 0;
 4656|      4|    }
 4657|       |
 4658|       |    /* Extra check for the attribute value */
 4659|     52|    if (ns->prefix != NULL) {
  ------------------
  |  Branch (4659:9): [True: 44, False: 8]
  ------------------
 4660|     44|	ret &= xmlValidateAttributeValue2(ctxt, doc, ns->prefix,
 4661|     44|					  attrDecl->atype, value);
 4662|     44|    } else {
 4663|      8|	ret &= xmlValidateAttributeValue2(ctxt, doc, BAD_CAST "xmlns",
  ------------------
  |  |   35|      8|#define BAD_CAST (xmlChar *)
  ------------------
 4664|      8|					  attrDecl->atype, value);
 4665|      8|    }
 4666|       |
 4667|     52|    return(ret);
 4668|     68|}
xmlValidatePushElement:
 5620|  3.40k|                       xmlNodePtr elem, const xmlChar *qname) {
 5621|  3.40k|    int ret = 1;
 5622|  3.40k|    xmlElementPtr eDecl;
 5623|  3.40k|    int extsubset = 0;
 5624|       |
 5625|  3.40k|    if (ctxt == NULL)
  ------------------
  |  Branch (5625:9): [True: 0, False: 3.40k]
  ------------------
 5626|      0|        return(0);
 5627|       |/* printf("PushElem %s\n", qname); */
 5628|  3.40k|    if ((ctxt->vstateNr > 0) && (ctxt->vstate != NULL)) {
  ------------------
  |  Branch (5628:9): [True: 3.28k, False: 124]
  |  Branch (5628:33): [True: 3.28k, False: 0]
  ------------------
 5629|  3.28k|	xmlValidStatePtr state = ctxt->vstate;
 5630|  3.28k|	xmlElementPtr elemDecl;
 5631|       |
 5632|       |	/*
 5633|       |	 * Check the new element against the content model of the new elem.
 5634|       |	 */
 5635|  3.28k|	if (state->elemDecl != NULL) {
  ------------------
  |  Branch (5635:6): [True: 3.11k, False: 173]
  ------------------
 5636|  3.11k|	    elemDecl = state->elemDecl;
 5637|       |
 5638|  3.11k|	    switch(elemDecl->etype) {
  ------------------
  |  Branch (5638:13): [True: 0, False: 3.11k]
  ------------------
 5639|      0|		case XML_ELEMENT_TYPE_UNDEFINED:
  ------------------
  |  Branch (5639:3): [True: 0, False: 3.11k]
  ------------------
 5640|      0|		    ret = 0;
 5641|      0|		    break;
 5642|      0|		case XML_ELEMENT_TYPE_EMPTY:
  ------------------
  |  Branch (5642:3): [True: 0, False: 3.11k]
  ------------------
 5643|      0|		    xmlErrValidNode(ctxt, state->node,
 5644|      0|				    XML_DTD_NOT_EMPTY,
 5645|      0|	       "Element %s was declared EMPTY this one has content\n",
 5646|      0|			   state->node->name, NULL, NULL);
 5647|      0|		    ret = 0;
 5648|      0|		    break;
 5649|      0|		case XML_ELEMENT_TYPE_ANY:
  ------------------
  |  Branch (5649:3): [True: 0, False: 3.11k]
  ------------------
 5650|       |		    /* I don't think anything is required then */
 5651|      0|		    break;
 5652|  1.28k|		case XML_ELEMENT_TYPE_MIXED:
  ------------------
  |  Branch (5652:3): [True: 1.28k, False: 1.82k]
  ------------------
 5653|       |		    /* simple case of declared as #PCDATA */
 5654|  1.28k|		    if ((elemDecl->content != NULL) &&
  ------------------
  |  Branch (5654:11): [True: 1.28k, False: 0]
  ------------------
 5655|  1.28k|			(elemDecl->content->type ==
  ------------------
  |  Branch (5655:4): [True: 0, False: 1.28k]
  ------------------
 5656|  1.28k|			 XML_ELEMENT_CONTENT_PCDATA)) {
 5657|      0|			xmlErrValidNode(ctxt, state->node,
 5658|      0|					XML_DTD_NOT_PCDATA,
 5659|      0|	       "Element %s was declared #PCDATA but contains non text nodes\n",
 5660|      0|				state->node->name, NULL, NULL);
 5661|      0|			ret = 0;
 5662|  1.28k|		    } else {
 5663|  1.28k|			ret = xmlValidateCheckMixed(ctxt, elemDecl->content,
 5664|  1.28k|				                    qname);
 5665|  1.28k|			if (ret != 1) {
  ------------------
  |  Branch (5665:8): [True: 1, False: 1.28k]
  ------------------
 5666|      1|			    xmlErrValidNode(ctxt, state->node,
 5667|      1|					    XML_DTD_INVALID_CHILD,
 5668|      1|	       "Element %s is not declared in %s list of possible children\n",
 5669|      1|				    qname, state->node->name, NULL);
 5670|      1|			}
 5671|  1.28k|		    }
 5672|  1.28k|		    break;
 5673|  1.82k|		case XML_ELEMENT_TYPE_ELEMENT:
  ------------------
  |  Branch (5673:3): [True: 1.82k, False: 1.28k]
  ------------------
 5674|       |		    /*
 5675|       |		     * TODO:
 5676|       |		     * VC: Standalone Document Declaration
 5677|       |		     *     - element types with element content, if white space
 5678|       |		     *       occurs directly within any instance of those types.
 5679|       |		     */
 5680|  1.82k|		    if (state->exec != NULL) {
  ------------------
  |  Branch (5680:11): [True: 1.82k, False: 0]
  ------------------
 5681|  1.82k|			ret = xmlRegExecPushString(state->exec, qname, NULL);
 5682|  1.82k|			if (ret < 0) {
  ------------------
  |  Branch (5682:8): [True: 1, False: 1.82k]
  ------------------
 5683|      1|			    xmlErrValidNode(ctxt, state->node,
 5684|      1|					    XML_DTD_CONTENT_MODEL,
 5685|      1|	       "Element %s content does not follow the DTD, Misplaced %s\n",
 5686|      1|				   state->node->name, qname, NULL);
 5687|      1|			    ret = 0;
 5688|  1.82k|			} else {
 5689|  1.82k|			    ret = 1;
 5690|  1.82k|			}
 5691|  1.82k|		    }
 5692|  1.82k|		    break;
 5693|  3.11k|	    }
 5694|  3.11k|	}
 5695|  3.28k|    }
 5696|  3.40k|    eDecl = xmlValidGetElemDecl(ctxt, doc, elem, &extsubset);
 5697|  3.40k|    vstateVPush(ctxt, eDecl, elem);
 5698|  3.40k|    return(ret);
 5699|  3.40k|}
xmlValidatePushCData:
 5712|  5.58k|xmlValidatePushCData(xmlValidCtxtPtr ctxt, const xmlChar *data, int len) {
 5713|  5.58k|    int ret = 1;
 5714|       |
 5715|       |/* printf("CDATA %s %d\n", data, len); */
 5716|  5.58k|    if (ctxt == NULL)
  ------------------
  |  Branch (5716:9): [True: 0, False: 5.58k]
  ------------------
 5717|      0|        return(0);
 5718|  5.58k|    if (len <= 0)
  ------------------
  |  Branch (5718:9): [True: 0, False: 5.58k]
  ------------------
 5719|      0|	return(ret);
 5720|  5.58k|    if ((ctxt->vstateNr > 0) && (ctxt->vstate != NULL)) {
  ------------------
  |  Branch (5720:9): [True: 5.58k, False: 0]
  |  Branch (5720:33): [True: 5.58k, False: 0]
  ------------------
 5721|  5.58k|	xmlValidStatePtr state = ctxt->vstate;
 5722|  5.58k|	xmlElementPtr elemDecl;
 5723|       |
 5724|       |	/*
 5725|       |	 * Check the new element against the content model of the new elem.
 5726|       |	 */
 5727|  5.58k|	if (state->elemDecl != NULL) {
  ------------------
  |  Branch (5727:6): [True: 5.29k, False: 295]
  ------------------
 5728|  5.29k|	    elemDecl = state->elemDecl;
 5729|       |
 5730|  5.29k|	    switch(elemDecl->etype) {
  ------------------
  |  Branch (5730:13): [True: 0, False: 5.29k]
  ------------------
 5731|      0|		case XML_ELEMENT_TYPE_UNDEFINED:
  ------------------
  |  Branch (5731:3): [True: 0, False: 5.29k]
  ------------------
 5732|      0|		    ret = 0;
 5733|      0|		    break;
 5734|      1|		case XML_ELEMENT_TYPE_EMPTY:
  ------------------
  |  Branch (5734:3): [True: 1, False: 5.28k]
  ------------------
 5735|      1|		    xmlErrValidNode(ctxt, state->node,
 5736|      1|				    XML_DTD_NOT_EMPTY,
 5737|      1|	       "Element %s was declared EMPTY this one has content\n",
 5738|      1|			   state->node->name, NULL, NULL);
 5739|      1|		    ret = 0;
 5740|      1|		    break;
 5741|      1|		case XML_ELEMENT_TYPE_ANY:
  ------------------
  |  Branch (5741:3): [True: 1, False: 5.28k]
  ------------------
 5742|      1|		    break;
 5743|  3.28k|		case XML_ELEMENT_TYPE_MIXED:
  ------------------
  |  Branch (5743:3): [True: 3.28k, False: 2.00k]
  ------------------
 5744|  3.28k|		    break;
 5745|  2.00k|		case XML_ELEMENT_TYPE_ELEMENT: {
  ------------------
  |  Branch (5745:3): [True: 2.00k, False: 3.28k]
  ------------------
 5746|  2.00k|                    int i;
 5747|       |
 5748|  6.65k|                    for (i = 0;i < len;i++) {
  ------------------
  |  Branch (5748:32): [True: 4.64k, False: 2.00k]
  ------------------
 5749|  4.64k|                        if (!IS_BLANK_CH(data[i])) {
  ------------------
  |  |  151|  4.64k|#define IS_BLANK_CH(c)  xmlIsBlank_ch(c)
  |  |  ------------------
  |  |  |  |   88|  4.64k|#define xmlIsBlank_ch(c)	(((c) == 0x20) || \
  |  |  |  |  ------------------
  |  |  |  |  |  Branch (88:27): [True: 1.79k, False: 2.85k]
  |  |  |  |  ------------------
  |  |  |  |   89|  4.64k|				 ((0x9 <= (c)) && ((c) <= 0xa)) || \
  |  |  |  |  ------------------
  |  |  |  |  |  Branch (89:7): [True: 2.85k, False: 0]
  |  |  |  |  |  Branch (89:23): [True: 2.85k, False: 0]
  |  |  |  |  ------------------
  |  |  |  |   90|  4.64k|				 ((c) == 0xd))
  |  |  |  |  ------------------
  |  |  |  |  |  Branch (90:6): [True: 0, False: 0]
  |  |  |  |  ------------------
  |  |  ------------------
  ------------------
 5750|      0|                            xmlErrValidNode(ctxt, state->node,
 5751|      0|                                            XML_DTD_CONTENT_MODEL,
 5752|      0|       "Element %s content does not follow the DTD, Text not allowed\n",
 5753|      0|                                   state->node->name, NULL, NULL);
 5754|      0|                            ret = 0;
 5755|      0|                            goto done;
 5756|      0|                        }
 5757|  4.64k|                    }
 5758|       |                    /*
 5759|       |                     * TODO:
 5760|       |                     * VC: Standalone Document Declaration
 5761|       |                     *  element types with element content, if white space
 5762|       |                     *  occurs directly within any instance of those types.
 5763|       |                     */
 5764|  2.00k|                    break;
 5765|  2.00k|                }
 5766|  5.29k|	    }
 5767|  5.29k|	}
 5768|  5.58k|    }
 5769|  5.58k|done:
 5770|  5.58k|    return(ret);
 5771|  5.58k|}
xmlValidatePopElement:
 5787|  3.40k|		      const xmlChar *qname ATTRIBUTE_UNUSED) {
 5788|  3.40k|    int ret = 1;
 5789|       |
 5790|  3.40k|    if (ctxt == NULL)
  ------------------
  |  Branch (5790:9): [True: 0, False: 3.40k]
  ------------------
 5791|      0|        return(0);
 5792|       |/* printf("PopElem %s\n", qname); */
 5793|  3.40k|    if ((ctxt->vstateNr > 0) && (ctxt->vstate != NULL)) {
  ------------------
  |  Branch (5793:9): [True: 3.40k, False: 0]
  |  Branch (5793:33): [True: 3.40k, False: 0]
  ------------------
 5794|  3.40k|	xmlValidStatePtr state = ctxt->vstate;
 5795|  3.40k|	xmlElementPtr elemDecl;
 5796|       |
 5797|       |	/*
 5798|       |	 * Check the new element against the content model of the new elem.
 5799|       |	 */
 5800|  3.40k|	if (state->elemDecl != NULL) {
  ------------------
  |  Branch (5800:6): [True: 3.22k, False: 182]
  ------------------
 5801|  3.22k|	    elemDecl = state->elemDecl;
 5802|       |
 5803|  3.22k|	    if (elemDecl->etype == XML_ELEMENT_TYPE_ELEMENT) {
  ------------------
  |  Branch (5803:10): [True: 690, False: 2.53k]
  ------------------
 5804|    690|		if (state->exec != NULL) {
  ------------------
  |  Branch (5804:7): [True: 690, False: 0]
  ------------------
 5805|    690|		    ret = xmlRegExecPushString(state->exec, NULL, NULL);
 5806|    690|		    if (ret <= 0) {
  ------------------
  |  Branch (5806:11): [True: 5, False: 685]
  ------------------
 5807|      5|			xmlErrValidNode(ctxt, state->node,
 5808|      5|			                XML_DTD_CONTENT_MODEL,
 5809|      5|	   "Element %s content does not follow the DTD, Expecting more children\n",
 5810|      5|			       state->node->name, NULL,NULL);
 5811|      5|			ret = 0;
 5812|    685|		    } else {
 5813|       |			/*
 5814|       |			 * previous validation errors should not generate
 5815|       |			 * a new one here
 5816|       |			 */
 5817|    685|			ret = 1;
 5818|    685|		    }
 5819|    690|		}
 5820|    690|	    }
 5821|  3.22k|	}
 5822|  3.40k|	vstateVPop(ctxt);
 5823|  3.40k|    }
 5824|  3.40k|    return(ret);
 5825|  3.40k|}
xmlValidateOneElement:
 5848|  19.2k|                      xmlNodePtr elem) {
 5849|  19.2k|    xmlElementPtr elemDecl = NULL;
 5850|  19.2k|    xmlElementContentPtr cont;
 5851|  19.2k|    xmlAttributePtr attr;
 5852|  19.2k|    xmlNodePtr child;
 5853|  19.2k|    int ret = 1, tmp;
 5854|  19.2k|    const xmlChar *name;
 5855|  19.2k|    int extsubset = 0;
 5856|       |
 5857|  19.2k|    CHECK_DTD;
  ------------------
  |  |  469|  19.2k|   if (doc == NULL) return(0);					\
  |  |  ------------------
  |  |  |  Branch (469:8): [True: 0, False: 19.2k]
  |  |  ------------------
  |  |  470|  19.2k|   else if ((doc->intSubset == NULL) &&				\
  |  |  ------------------
  |  |  |  Branch (470:13): [True: 0, False: 19.2k]
  |  |  ------------------
  |  |  471|  19.2k|	    (doc->extSubset == NULL)) return(0)
  |  |  ------------------
  |  |  |  Branch (471:6): [True: 0, False: 0]
  |  |  ------------------
  ------------------
 5858|       |
 5859|  19.2k|    if (elem == NULL) return(0);
  ------------------
  |  Branch (5859:9): [True: 0, False: 19.2k]
  ------------------
 5860|  19.2k|    switch (elem->type) {
 5861|      0|        case XML_ATTRIBUTE_NODE:
  ------------------
  |  Branch (5861:9): [True: 0, False: 19.2k]
  ------------------
 5862|      0|	    xmlErrValidNode(ctxt, elem, XML_ERR_INTERNAL_ERROR,
 5863|      0|		   "Attribute element not expected\n", NULL, NULL ,NULL);
 5864|      0|	    return(0);
 5865|  5.47k|        case XML_TEXT_NODE:
  ------------------
  |  Branch (5865:9): [True: 5.47k, False: 13.7k]
  ------------------
 5866|  5.47k|	    if (elem->children != NULL) {
  ------------------
  |  Branch (5866:10): [True: 0, False: 5.47k]
  ------------------
 5867|      0|		xmlErrValidNode(ctxt, elem, XML_ERR_INTERNAL_ERROR,
 5868|      0|		                "Text element has children !\n",
 5869|      0|				NULL,NULL,NULL);
 5870|      0|		return(0);
 5871|      0|	    }
 5872|  5.47k|	    if (elem->ns != NULL) {
  ------------------
  |  Branch (5872:10): [True: 0, False: 5.47k]
  ------------------
 5873|      0|		xmlErrValidNode(ctxt, elem, XML_ERR_INTERNAL_ERROR,
 5874|      0|		                "Text element has namespace !\n",
 5875|      0|				NULL,NULL,NULL);
 5876|      0|		return(0);
 5877|      0|	    }
 5878|  5.47k|	    if (elem->content == NULL) {
  ------------------
  |  Branch (5878:10): [True: 0, False: 5.47k]
  ------------------
 5879|      0|		xmlErrValidNode(ctxt, elem, XML_ERR_INTERNAL_ERROR,
 5880|      0|		                "Text element has no content !\n",
 5881|      0|				NULL,NULL,NULL);
 5882|      0|		return(0);
 5883|      0|	    }
 5884|  5.47k|	    return(1);
 5885|      0|        case XML_XINCLUDE_START:
  ------------------
  |  Branch (5885:9): [True: 0, False: 19.2k]
  ------------------
 5886|      0|        case XML_XINCLUDE_END:
  ------------------
  |  Branch (5886:9): [True: 0, False: 19.2k]
  ------------------
 5887|      0|            return(1);
 5888|     17|        case XML_CDATA_SECTION_NODE:
  ------------------
  |  Branch (5888:9): [True: 17, False: 19.2k]
  ------------------
 5889|     17|        case XML_ENTITY_REF_NODE:
  ------------------
  |  Branch (5889:9): [True: 0, False: 19.2k]
  ------------------
 5890|     23|        case XML_PI_NODE:
  ------------------
  |  Branch (5890:9): [True: 6, False: 19.2k]
  ------------------
 5891|     84|        case XML_COMMENT_NODE:
  ------------------
  |  Branch (5891:9): [True: 61, False: 19.1k]
  ------------------
 5892|     84|	    return(1);
 5893|      0|        case XML_ENTITY_NODE:
  ------------------
  |  Branch (5893:9): [True: 0, False: 19.2k]
  ------------------
 5894|      0|	    xmlErrValidNode(ctxt, elem, XML_ERR_INTERNAL_ERROR,
 5895|      0|		   "Entity element not expected\n", NULL, NULL ,NULL);
 5896|      0|	    return(0);
 5897|      0|        case XML_NOTATION_NODE:
  ------------------
  |  Branch (5897:9): [True: 0, False: 19.2k]
  ------------------
 5898|      0|	    xmlErrValidNode(ctxt, elem, XML_ERR_INTERNAL_ERROR,
 5899|      0|		   "Notation element not expected\n", NULL, NULL ,NULL);
 5900|      0|	    return(0);
 5901|      0|        case XML_DOCUMENT_NODE:
  ------------------
  |  Branch (5901:9): [True: 0, False: 19.2k]
  ------------------
 5902|      0|        case XML_DOCUMENT_TYPE_NODE:
  ------------------
  |  Branch (5902:9): [True: 0, False: 19.2k]
  ------------------
 5903|      0|        case XML_DOCUMENT_FRAG_NODE:
  ------------------
  |  Branch (5903:9): [True: 0, False: 19.2k]
  ------------------
 5904|      0|	    xmlErrValidNode(ctxt, elem, XML_ERR_INTERNAL_ERROR,
 5905|      0|		   "Document element not expected\n", NULL, NULL ,NULL);
 5906|      0|	    return(0);
 5907|      0|        case XML_HTML_DOCUMENT_NODE:
  ------------------
  |  Branch (5907:9): [True: 0, False: 19.2k]
  ------------------
 5908|      0|	    xmlErrValidNode(ctxt, elem, XML_ERR_INTERNAL_ERROR,
 5909|      0|		   "HTML Document not expected\n", NULL, NULL ,NULL);
 5910|      0|	    return(0);
 5911|  13.6k|        case XML_ELEMENT_NODE:
  ------------------
  |  Branch (5911:9): [True: 13.6k, False: 5.55k]
  ------------------
 5912|  13.6k|	    break;
 5913|      0|	default:
  ------------------
  |  Branch (5913:2): [True: 0, False: 19.2k]
  ------------------
 5914|      0|	    xmlErrValidNode(ctxt, elem, XML_ERR_INTERNAL_ERROR,
 5915|      0|		   "unknown element type\n", NULL, NULL ,NULL);
 5916|      0|	    return(0);
 5917|  19.2k|    }
 5918|       |
 5919|       |    /*
 5920|       |     * Fetch the declaration
 5921|       |     */
 5922|  13.6k|    elemDecl = xmlValidGetElemDecl(ctxt, doc, elem, &extsubset);
 5923|  13.6k|    if (elemDecl == NULL)
  ------------------
  |  Branch (5923:9): [True: 622, False: 13.0k]
  ------------------
 5924|    622|	return(0);
 5925|       |
 5926|       |    /*
 5927|       |     * If vstateNr is not zero that means continuous validation is
 5928|       |     * activated, do not try to check the content model at that level.
 5929|       |     */
 5930|  13.0k|    if (ctxt->vstateNr == 0) {
  ------------------
  |  Branch (5930:9): [True: 10.0k, False: 3.03k]
  ------------------
 5931|       |    /* Check that the element content matches the definition */
 5932|  10.0k|    switch (elemDecl->etype) {
  ------------------
  |  Branch (5932:13): [True: 0, False: 10.0k]
  ------------------
 5933|     48|        case XML_ELEMENT_TYPE_UNDEFINED:
  ------------------
  |  Branch (5933:9): [True: 48, False: 9.99k]
  ------------------
 5934|     48|	    xmlErrValidNode(ctxt, elem, XML_DTD_UNKNOWN_ELEM,
 5935|     48|	                    "No declaration for element %s\n",
 5936|     48|		   elem->name, NULL, NULL);
 5937|     48|	    return(0);
 5938|    909|        case XML_ELEMENT_TYPE_EMPTY:
  ------------------
  |  Branch (5938:9): [True: 909, False: 9.12k]
  ------------------
 5939|    909|	    if (elem->children != NULL) {
  ------------------
  |  Branch (5939:10): [True: 4, False: 905]
  ------------------
 5940|      4|		xmlErrValidNode(ctxt, elem, XML_DTD_NOT_EMPTY,
 5941|      4|	       "Element %s was declared EMPTY this one has content\n",
 5942|      4|	               elem->name, NULL, NULL);
 5943|      4|		ret = 0;
 5944|      4|	    }
 5945|    909|	    break;
 5946|      8|        case XML_ELEMENT_TYPE_ANY:
  ------------------
  |  Branch (5946:9): [True: 8, False: 10.0k]
  ------------------
 5947|       |	    /* I don't think anything is required then */
 5948|      8|	    break;
 5949|  6.94k|        case XML_ELEMENT_TYPE_MIXED:
  ------------------
  |  Branch (5949:9): [True: 6.94k, False: 3.09k]
  ------------------
 5950|       |
 5951|       |	    /* simple case of declared as #PCDATA */
 5952|  6.94k|	    if ((elemDecl->content != NULL) &&
  ------------------
  |  Branch (5952:10): [True: 6.94k, False: 0]
  ------------------
 5953|  6.94k|		(elemDecl->content->type == XML_ELEMENT_CONTENT_PCDATA)) {
  ------------------
  |  Branch (5953:3): [True: 3.08k, False: 3.85k]
  ------------------
 5954|  3.08k|		ret = xmlValidateOneCdataElement(ctxt, doc, elem);
 5955|  3.08k|		if (!ret) {
  ------------------
  |  Branch (5955:7): [True: 0, False: 3.08k]
  ------------------
 5956|      0|		    xmlErrValidNode(ctxt, elem, XML_DTD_NOT_PCDATA,
 5957|      0|	       "Element %s was declared #PCDATA but contains non text nodes\n",
 5958|      0|			   elem->name, NULL, NULL);
 5959|      0|		}
 5960|  3.08k|		break;
 5961|  3.08k|	    }
 5962|  3.85k|	    child = elem->children;
 5963|       |	    /* Hum, this start to get messy */
 5964|  14.6k|	    while (child != NULL) {
  ------------------
  |  Branch (5964:13): [True: 10.7k, False: 3.85k]
  ------------------
 5965|  10.7k|	        if (child->type == XML_ELEMENT_NODE) {
  ------------------
  |  Branch (5965:14): [True: 3.87k, False: 6.91k]
  ------------------
 5966|  3.87k|		    name = child->name;
 5967|  3.87k|		    if ((child->ns != NULL) && (child->ns->prefix != NULL)) {
  ------------------
  |  Branch (5967:11): [True: 32, False: 3.84k]
  |  Branch (5967:34): [True: 32, False: 0]
  ------------------
 5968|     32|			xmlChar fn[50];
 5969|     32|			xmlChar *fullname;
 5970|       |
 5971|     32|			fullname = xmlBuildQName(child->name, child->ns->prefix,
 5972|     32|				                 fn, 50);
 5973|     32|			if (fullname == NULL)
  ------------------
  |  Branch (5973:8): [True: 0, False: 32]
  ------------------
 5974|      0|			    return(0);
 5975|     32|			cont = elemDecl->content;
 5976|    128|			while (cont != NULL) {
  ------------------
  |  Branch (5976:11): [True: 96, False: 32]
  ------------------
 5977|     96|			    if (cont->type == XML_ELEMENT_CONTENT_ELEMENT) {
  ------------------
  |  Branch (5977:12): [True: 32, False: 64]
  ------------------
 5978|     32|				if (xmlStrEqual(cont->name, fullname))
  ------------------
  |  Branch (5978:9): [True: 0, False: 32]
  ------------------
 5979|      0|				    break;
 5980|     64|			    } else if ((cont->type == XML_ELEMENT_CONTENT_OR) &&
  ------------------
  |  Branch (5980:19): [True: 64, False: 0]
  ------------------
 5981|     64|			       (cont->c1 != NULL) &&
  ------------------
  |  Branch (5981:11): [True: 64, False: 0]
  ------------------
 5982|     64|			       (cont->c1->type == XML_ELEMENT_CONTENT_ELEMENT)){
  ------------------
  |  Branch (5982:11): [True: 32, False: 32]
  ------------------
 5983|     32|				if (xmlStrEqual(cont->c1->name, fullname))
  ------------------
  |  Branch (5983:9): [True: 0, False: 32]
  ------------------
 5984|      0|				    break;
 5985|     32|			    } else if ((cont->type != XML_ELEMENT_CONTENT_OR) ||
  ------------------
  |  Branch (5985:19): [True: 0, False: 32]
  ------------------
 5986|     32|				(cont->c1 == NULL) ||
  ------------------
  |  Branch (5986:5): [True: 0, False: 32]
  ------------------
 5987|     32|				(cont->c1->type != XML_ELEMENT_CONTENT_PCDATA)){
  ------------------
  |  Branch (5987:5): [True: 0, False: 32]
  ------------------
 5988|      0|				xmlErrValid(NULL, XML_DTD_MIXED_CORRUPT,
 5989|      0|					"Internal: MIXED struct corrupted\n",
 5990|      0|					NULL);
 5991|      0|				break;
 5992|      0|			    }
 5993|     96|			    cont = cont->c2;
 5994|     96|			}
 5995|     32|			if ((fullname != fn) && (fullname != child->name))
  ------------------
  |  Branch (5995:8): [True: 0, False: 32]
  |  Branch (5995:28): [True: 0, False: 0]
  ------------------
 5996|      0|			    xmlFree(fullname);
 5997|     32|			if (cont != NULL)
  ------------------
  |  Branch (5997:8): [True: 0, False: 32]
  ------------------
 5998|      0|			    goto child_ok;
 5999|     32|		    }
 6000|  3.87k|		    cont = elemDecl->content;
 6001|  37.8k|		    while (cont != NULL) {
  ------------------
  |  Branch (6001:14): [True: 37.8k, False: 4]
  ------------------
 6002|  37.8k|		        if (cont->type == XML_ELEMENT_CONTENT_ELEMENT) {
  ------------------
  |  Branch (6002:15): [True: 28, False: 37.8k]
  ------------------
 6003|     28|			    if (xmlStrEqual(cont->name, name)) break;
  ------------------
  |  Branch (6003:12): [True: 24, False: 4]
  ------------------
 6004|  37.8k|			} else if ((cont->type == XML_ELEMENT_CONTENT_OR) &&
  ------------------
  |  Branch (6004:15): [True: 37.8k, False: 0]
  ------------------
 6005|  37.8k|			   (cont->c1 != NULL) &&
  ------------------
  |  Branch (6005:7): [True: 37.8k, False: 0]
  ------------------
 6006|  37.8k|			   (cont->c1->type == XML_ELEMENT_CONTENT_ELEMENT)) {
  ------------------
  |  Branch (6006:7): [True: 33.9k, False: 3.87k]
  ------------------
 6007|  33.9k|			    if (xmlStrEqual(cont->c1->name, name)) break;
  ------------------
  |  Branch (6007:12): [True: 3.84k, False: 30.0k]
  ------------------
 6008|  33.9k|			} else if ((cont->type != XML_ELEMENT_CONTENT_OR) ||
  ------------------
  |  Branch (6008:15): [True: 0, False: 3.87k]
  ------------------
 6009|  3.87k|			    (cont->c1 == NULL) ||
  ------------------
  |  Branch (6009:8): [True: 0, False: 3.87k]
  ------------------
 6010|  3.87k|			    (cont->c1->type != XML_ELEMENT_CONTENT_PCDATA)) {
  ------------------
  |  Branch (6010:8): [True: 0, False: 3.87k]
  ------------------
 6011|      0|			    xmlErrValid(ctxt, XML_DTD_MIXED_CORRUPT,
 6012|      0|				    "Internal: MIXED struct corrupted\n",
 6013|      0|				    NULL);
 6014|      0|			    break;
 6015|      0|			}
 6016|  33.9k|			cont = cont->c2;
 6017|  33.9k|		    }
 6018|  3.87k|		    if (cont == NULL) {
  ------------------
  |  Branch (6018:11): [True: 4, False: 3.86k]
  ------------------
 6019|      4|			xmlErrValidNode(ctxt, elem, XML_DTD_INVALID_CHILD,
 6020|      4|	       "Element %s is not declared in %s list of possible children\n",
 6021|      4|			       name, elem->name, NULL);
 6022|      4|			ret = 0;
 6023|      4|		    }
 6024|  3.87k|		}
 6025|  10.7k|child_ok:
 6026|  10.7k|	        child = child->next;
 6027|  10.7k|	    }
 6028|  3.85k|	    break;
 6029|  3.85k|        case XML_ELEMENT_TYPE_ELEMENT:
  ------------------
  |  Branch (6029:9): [True: 2.12k, False: 7.91k]
  ------------------
 6030|  2.12k|	    if ((doc->standalone == 1) && (extsubset == 1)) {
  ------------------
  |  Branch (6030:10): [True: 4, False: 2.12k]
  |  Branch (6030:36): [True: 0, False: 4]
  ------------------
 6031|       |		/*
 6032|       |		 * VC: Standalone Document Declaration
 6033|       |		 *     - element types with element content, if white space
 6034|       |		 *       occurs directly within any instance of those types.
 6035|       |		 */
 6036|      0|		child = elem->children;
 6037|      0|		while (child != NULL) {
  ------------------
  |  Branch (6037:10): [True: 0, False: 0]
  ------------------
 6038|      0|		    if (child->type == XML_TEXT_NODE) {
  ------------------
  |  Branch (6038:11): [True: 0, False: 0]
  ------------------
 6039|      0|			const xmlChar *content = child->content;
 6040|       |
 6041|      0|			while (IS_BLANK_CH(*content))
 6042|      0|			    content++;
 6043|      0|			if (*content == 0) {
  ------------------
  |  Branch (6043:8): [True: 0, False: 0]
  ------------------
 6044|      0|			    xmlErrValidNode(ctxt, elem,
 6045|      0|			                    XML_DTD_STANDALONE_WHITE_SPACE,
 6046|      0|"standalone: %s declared in the external subset contains white spaces nodes\n",
 6047|      0|				   elem->name, NULL, NULL);
 6048|      0|			    ret = 0;
 6049|      0|			    break;
 6050|      0|			}
 6051|      0|		    }
 6052|      0|		    child =child->next;
 6053|      0|		}
 6054|      0|	    }
 6055|  2.12k|	    child = elem->children;
 6056|  2.12k|	    cont = elemDecl->content;
 6057|  2.12k|	    tmp = xmlValidateElementContent(ctxt, child, elemDecl, 1, elem);
 6058|  2.12k|	    if (tmp <= 0)
  ------------------
  |  Branch (6058:10): [True: 24, False: 2.10k]
  ------------------
 6059|     24|		ret = tmp;
 6060|  2.12k|	    break;
 6061|  10.0k|    }
 6062|  10.0k|    } /* not continuous */
 6063|       |
 6064|       |    /* [ VC: Required Attribute ] */
 6065|  13.0k|    attr = elemDecl->attributes;
 6066|   163k|    while (attr != NULL) {
  ------------------
  |  Branch (6066:12): [True: 150k, False: 13.0k]
  ------------------
 6067|   150k|	if (attr->def == XML_ATTRIBUTE_REQUIRED) {
  ------------------
  |  Branch (6067:6): [True: 4.16k, False: 145k]
  ------------------
 6068|  4.16k|	    int qualified = -1;
 6069|       |
 6070|  4.16k|	    if ((attr->prefix == NULL) &&
  ------------------
  |  Branch (6070:10): [True: 3.89k, False: 276]
  ------------------
 6071|  4.16k|		(xmlStrEqual(attr->name, BAD_CAST "xmlns"))) {
  ------------------
  |  |   35|  3.89k|#define BAD_CAST (xmlChar *)
  ------------------
  |  Branch (6071:3): [True: 0, False: 3.89k]
  ------------------
 6072|      0|		xmlNsPtr ns;
 6073|       |
 6074|      0|		ns = elem->nsDef;
 6075|      0|		while (ns != NULL) {
  ------------------
  |  Branch (6075:10): [True: 0, False: 0]
  ------------------
 6076|      0|		    if (ns->prefix == NULL)
  ------------------
  |  Branch (6076:11): [True: 0, False: 0]
  ------------------
 6077|      0|			goto found;
 6078|      0|		    ns = ns->next;
 6079|      0|		}
 6080|  4.16k|	    } else if (xmlStrEqual(attr->prefix, BAD_CAST "xmlns")) {
  ------------------
  |  |   35|  4.16k|#define BAD_CAST (xmlChar *)
  ------------------
  |  Branch (6080:17): [True: 4, False: 4.16k]
  ------------------
 6081|      4|		xmlNsPtr ns;
 6082|       |
 6083|      4|		ns = elem->nsDef;
 6084|      8|		while (ns != NULL) {
  ------------------
  |  Branch (6084:10): [True: 8, False: 0]
  ------------------
 6085|      8|		    if (xmlStrEqual(attr->name, ns->prefix))
  ------------------
  |  Branch (6085:11): [True: 4, False: 4]
  ------------------
 6086|      4|			goto found;
 6087|      4|		    ns = ns->next;
 6088|      4|		}
 6089|  4.16k|	    } else {
 6090|  4.16k|		xmlAttrPtr attrib;
 6091|       |
 6092|  4.16k|		attrib = elem->properties;
 6093|  4.55k|		while (attrib != NULL) {
  ------------------
  |  Branch (6093:10): [True: 4.55k, False: 4]
  ------------------
 6094|  4.55k|		    if (xmlStrEqual(attrib->name, attr->name)) {
  ------------------
  |  Branch (6094:11): [True: 4.16k, False: 392]
  ------------------
 6095|  4.16k|			if (attr->prefix != NULL) {
  ------------------
  |  Branch (6095:8): [True: 272, False: 3.88k]
  ------------------
 6096|    272|			    xmlNsPtr nameSpace = attrib->ns;
 6097|       |
 6098|    272|			    if (nameSpace == NULL)
  ------------------
  |  Branch (6098:12): [True: 0, False: 272]
  ------------------
 6099|      0|				nameSpace = elem->ns;
 6100|       |			    /*
 6101|       |			     * qualified names handling is problematic, having a
 6102|       |			     * different prefix should be possible but DTDs don't
 6103|       |			     * allow to define the URI instead of the prefix :-(
 6104|       |			     */
 6105|    272|			    if (nameSpace == NULL) {
  ------------------
  |  Branch (6105:12): [True: 0, False: 272]
  ------------------
 6106|      0|				if (qualified < 0)
  ------------------
  |  Branch (6106:9): [True: 0, False: 0]
  ------------------
 6107|      0|				    qualified = 0;
 6108|    272|			    } else if (!xmlStrEqual(nameSpace->prefix,
  ------------------
  |  Branch (6108:19): [True: 0, False: 272]
  ------------------
 6109|    272|						    attr->prefix)) {
 6110|      0|				if (qualified < 1)
  ------------------
  |  Branch (6110:9): [True: 0, False: 0]
  ------------------
 6111|      0|				    qualified = 1;
 6112|      0|			    } else
 6113|    272|				goto found;
 6114|  3.88k|			} else {
 6115|       |			    /*
 6116|       |			     * We should allow applications to define namespaces
 6117|       |			     * for their application even if the DTD doesn't
 6118|       |			     * carry one, otherwise, basically we would always
 6119|       |			     * break.
 6120|       |			     */
 6121|  3.88k|			    goto found;
 6122|  3.88k|			}
 6123|  4.16k|		    }
 6124|    392|		    attrib = attrib->next;
 6125|    392|		}
 6126|  4.16k|	    }
 6127|      4|	    if (qualified == -1) {
  ------------------
  |  Branch (6127:10): [True: 4, False: 0]
  ------------------
 6128|      4|		if (attr->prefix == NULL) {
  ------------------
  |  Branch (6128:7): [True: 4, False: 0]
  ------------------
 6129|      4|		    xmlErrValidNode(ctxt, elem, XML_DTD_MISSING_ATTRIBUTE,
 6130|      4|		       "Element %s does not carry attribute %s\n",
 6131|      4|			   elem->name, attr->name, NULL);
 6132|      4|		    ret = 0;
 6133|      4|	        } else {
 6134|      0|		    xmlErrValidNode(ctxt, elem, XML_DTD_MISSING_ATTRIBUTE,
 6135|      0|		       "Element %s does not carry attribute %s:%s\n",
 6136|      0|			   elem->name, attr->prefix,attr->name);
 6137|      0|		    ret = 0;
 6138|      0|		}
 6139|      4|	    } else if (qualified == 0) {
  ------------------
  |  Branch (6139:17): [True: 0, False: 0]
  ------------------
 6140|      0|		xmlErrValidWarning(ctxt, elem, XML_DTD_NO_PREFIX,
 6141|      0|		   "Element %s required attribute %s:%s has no prefix\n",
 6142|      0|		       elem->name, attr->prefix, attr->name);
 6143|      0|	    } else if (qualified == 1) {
  ------------------
  |  Branch (6143:17): [True: 0, False: 0]
  ------------------
 6144|      0|		xmlErrValidWarning(ctxt, elem, XML_DTD_DIFFERENT_PREFIX,
 6145|      0|		   "Element %s required attribute %s:%s has different prefix\n",
 6146|      0|		       elem->name, attr->prefix, attr->name);
 6147|      0|	    }
 6148|   145k|	} else if (attr->def == XML_ATTRIBUTE_FIXED) {
  ------------------
  |  Branch (6148:13): [True: 1.75k, False: 144k]
  ------------------
 6149|       |	    /*
 6150|       |	     * Special tests checking #FIXED namespace declarations
 6151|       |	     * have the right value since this is not done as an
 6152|       |	     * attribute checking
 6153|       |	     */
 6154|  1.75k|	    if ((attr->prefix == NULL) &&
  ------------------
  |  Branch (6154:10): [True: 1.33k, False: 416]
  ------------------
 6155|  1.75k|		(xmlStrEqual(attr->name, BAD_CAST "xmlns"))) {
  ------------------
  |  |   35|  1.33k|#define BAD_CAST (xmlChar *)
  ------------------
  |  Branch (6155:3): [True: 8, False: 1.32k]
  ------------------
 6156|      8|		xmlNsPtr ns;
 6157|       |
 6158|      8|		ns = elem->nsDef;
 6159|      8|		while (ns != NULL) {
  ------------------
  |  Branch (6159:10): [True: 8, False: 0]
  ------------------
 6160|      8|		    if (ns->prefix == NULL) {
  ------------------
  |  Branch (6160:11): [True: 8, False: 0]
  ------------------
 6161|      8|			if (!xmlStrEqual(attr->defaultValue, ns->href)) {
  ------------------
  |  Branch (6161:8): [True: 4, False: 4]
  ------------------
 6162|      4|			    xmlErrValidNode(ctxt, elem,
 6163|      4|			           XML_DTD_ELEM_DEFAULT_NAMESPACE,
 6164|      4|   "Element %s namespace name for default namespace does not match the DTD\n",
 6165|      4|				   elem->name, NULL, NULL);
 6166|      4|			    ret = 0;
 6167|      4|			}
 6168|      8|			goto found;
 6169|      8|		    }
 6170|      0|		    ns = ns->next;
 6171|      0|		}
 6172|  1.74k|	    } else if (xmlStrEqual(attr->prefix, BAD_CAST "xmlns")) {
  ------------------
  |  |   35|  1.74k|#define BAD_CAST (xmlChar *)
  ------------------
  |  Branch (6172:17): [True: 28, False: 1.71k]
  ------------------
 6173|     28|		xmlNsPtr ns;
 6174|       |
 6175|     28|		ns = elem->nsDef;
 6176|     32|		while (ns != NULL) {
  ------------------
  |  Branch (6176:10): [True: 28, False: 4]
  ------------------
 6177|     28|		    if (xmlStrEqual(attr->name, ns->prefix)) {
  ------------------
  |  Branch (6177:11): [True: 24, False: 4]
  ------------------
 6178|     24|			if (!xmlStrEqual(attr->defaultValue, ns->href)) {
  ------------------
  |  Branch (6178:8): [True: 0, False: 24]
  ------------------
 6179|      0|			    xmlErrValidNode(ctxt, elem, XML_DTD_ELEM_NAMESPACE,
 6180|      0|		   "Element %s namespace name for %s does not match the DTD\n",
 6181|      0|				   elem->name, ns->prefix, NULL);
 6182|      0|			    ret = 0;
 6183|      0|			}
 6184|     24|			goto found;
 6185|     24|		    }
 6186|      4|		    ns = ns->next;
 6187|      4|		}
 6188|     28|	    }
 6189|  1.75k|	}
 6190|   150k|found:
 6191|   150k|        attr = attr->nexth;
 6192|   150k|    }
 6193|  13.0k|    return(ret);
 6194|  13.0k|}
xmlValidateRoot:
 6211|    503|xmlValidateRoot(xmlValidCtxtPtr ctxt, xmlDocPtr doc) {
 6212|    503|    xmlNodePtr root;
 6213|    503|    int ret;
 6214|       |
 6215|    503|    if (doc == NULL) return(0);
  ------------------
  |  Branch (6215:9): [True: 0, False: 503]
  ------------------
 6216|       |
 6217|    503|    root = xmlDocGetRootElement(doc);
 6218|    503|    if ((root == NULL) || (root->name == NULL)) {
  ------------------
  |  Branch (6218:9): [True: 0, False: 503]
  |  Branch (6218:27): [True: 0, False: 503]
  ------------------
 6219|      0|	xmlErrValid(ctxt, XML_DTD_NO_ROOT,
 6220|      0|	            "no root element\n", NULL);
 6221|      0|        return(0);
 6222|      0|    }
 6223|       |
 6224|       |    /*
 6225|       |     * When doing post validation against a separate DTD, those may
 6226|       |     * no internal subset has been generated
 6227|       |     */
 6228|    503|    if ((doc->intSubset != NULL) &&
  ------------------
  |  Branch (6228:9): [True: 503, False: 0]
  ------------------
 6229|    503|	(doc->intSubset->name != NULL)) {
  ------------------
  |  Branch (6229:2): [True: 503, False: 0]
  ------------------
 6230|       |	/*
 6231|       |	 * Check first the document root against the NQName
 6232|       |	 */
 6233|    503|	if (!xmlStrEqual(doc->intSubset->name, root->name)) {
  ------------------
  |  Branch (6233:6): [True: 24, False: 479]
  ------------------
 6234|     24|	    if ((root->ns != NULL) && (root->ns->prefix != NULL)) {
  ------------------
  |  Branch (6234:10): [True: 16, False: 8]
  |  Branch (6234:32): [True: 16, False: 0]
  ------------------
 6235|     16|		xmlChar fn[50];
 6236|     16|		xmlChar *fullname;
 6237|       |
 6238|     16|		fullname = xmlBuildQName(root->name, root->ns->prefix, fn, 50);
 6239|     16|		if (fullname == NULL) {
  ------------------
  |  Branch (6239:7): [True: 0, False: 16]
  ------------------
 6240|      0|		    xmlVErrMemory(ctxt, NULL);
 6241|      0|		    return(0);
 6242|      0|		}
 6243|     16|		ret = xmlStrEqual(doc->intSubset->name, fullname);
 6244|     16|		if ((fullname != fn) && (fullname != root->name))
  ------------------
  |  Branch (6244:7): [True: 0, False: 16]
  |  Branch (6244:27): [True: 0, False: 0]
  ------------------
 6245|      0|		    xmlFree(fullname);
 6246|     16|		if (ret == 1)
  ------------------
  |  Branch (6246:7): [True: 16, False: 0]
  ------------------
 6247|     16|		    goto name_ok;
 6248|     16|	    }
 6249|      8|	    if ((xmlStrEqual(doc->intSubset->name, BAD_CAST "HTML")) &&
  ------------------
  |  |   35|      8|#define BAD_CAST (xmlChar *)
  ------------------
  |  Branch (6249:10): [True: 0, False: 8]
  ------------------
 6250|      8|		(xmlStrEqual(root->name, BAD_CAST "html")))
  ------------------
  |  |   35|      0|#define BAD_CAST (xmlChar *)
  ------------------
  |  Branch (6250:3): [True: 0, False: 0]
  ------------------
 6251|      0|		goto name_ok;
 6252|      8|	    xmlErrValidNode(ctxt, root, XML_DTD_ROOT_NAME,
 6253|      8|		   "root and DTD name do not match '%s' and '%s'\n",
 6254|      8|		   root->name, doc->intSubset->name, NULL);
 6255|      8|	    return(0);
 6256|      8|	}
 6257|    503|    }
 6258|    495|name_ok:
 6259|    495|    return(1);
 6260|    503|}
xmlValidateElement:
 6275|    168|xmlValidateElement(xmlValidCtxtPtr ctxt, xmlDocPtr doc, xmlNodePtr root) {
 6276|    168|    xmlNodePtr elem;
 6277|    168|    xmlAttrPtr attr;
 6278|    168|    xmlNsPtr ns;
 6279|    168|    const xmlChar *value;
 6280|    168|    int ret = 1;
 6281|       |
 6282|    168|    if (root == NULL) return(0);
  ------------------
  |  Branch (6282:9): [True: 0, False: 168]
  ------------------
 6283|       |
 6284|    168|    CHECK_DTD;
  ------------------
  |  |  469|    168|   if (doc == NULL) return(0);					\
  |  |  ------------------
  |  |  |  Branch (469:8): [True: 0, False: 168]
  |  |  ------------------
  |  |  470|    168|   else if ((doc->intSubset == NULL) &&				\
  |  |  ------------------
  |  |  |  Branch (470:13): [True: 0, False: 168]
  |  |  ------------------
  |  |  471|    168|	    (doc->extSubset == NULL)) return(0)
  |  |  ------------------
  |  |  |  Branch (471:6): [True: 0, False: 0]
  |  |  ------------------
  ------------------
 6285|       |
 6286|    168|    elem = root;
 6287|  8.90k|    while (1) {
  ------------------
  |  Branch (6287:12): [Folded - Ignored]
  ------------------
 6288|  8.90k|        ret &= xmlValidateOneElement(ctxt, doc, elem);
 6289|       |
 6290|  8.90k|        if (elem->type == XML_ELEMENT_NODE) {
  ------------------
  |  Branch (6290:13): [True: 3.34k, False: 5.55k]
  ------------------
 6291|  3.34k|            attr = elem->properties;
 6292|  4.81k|            while (attr != NULL) {
  ------------------
  |  Branch (6292:20): [True: 1.46k, False: 3.34k]
  ------------------
 6293|  1.46k|                value = xmlNodeListGetString(doc, attr->children, 0);
 6294|  1.46k|                ret &= xmlValidateOneAttribute(ctxt, doc, elem, attr, value);
 6295|  1.46k|                if (value != NULL)
  ------------------
  |  Branch (6295:21): [True: 1.46k, False: 0]
  ------------------
 6296|  1.46k|                    xmlFree((char *)value);
 6297|  1.46k|                attr= attr->next;
 6298|  1.46k|            }
 6299|       |
 6300|  3.34k|            ns = elem->nsDef;
 6301|  3.37k|            while (ns != NULL) {
  ------------------
  |  Branch (6301:20): [True: 27, False: 3.34k]
  ------------------
 6302|     27|                if (elem->ns == NULL)
  ------------------
  |  Branch (6302:21): [True: 15, False: 12]
  ------------------
 6303|     15|                    ret &= xmlValidateOneNamespace(ctxt, doc, elem, NULL,
 6304|     15|                                                   ns, ns->href);
 6305|     12|                else
 6306|     12|                    ret &= xmlValidateOneNamespace(ctxt, doc, elem,
 6307|     12|                                                   elem->ns->prefix, ns,
 6308|     12|                                                   ns->href);
 6309|     27|                ns = ns->next;
 6310|     27|            }
 6311|       |
 6312|  3.34k|            if (elem->children != NULL) {
  ------------------
  |  Branch (6312:17): [True: 3.04k, False: 300]
  ------------------
 6313|  3.04k|                elem = elem->children;
 6314|  3.04k|                continue;
 6315|  3.04k|            }
 6316|  3.34k|        }
 6317|       |
 6318|  8.90k|        while (1) {
  ------------------
  |  Branch (6318:16): [Folded - Ignored]
  ------------------
 6319|  8.90k|            if (elem == root)
  ------------------
  |  Branch (6319:17): [True: 168, False: 8.73k]
  ------------------
 6320|    168|                goto done;
 6321|  8.73k|            if (elem->next != NULL)
  ------------------
  |  Branch (6321:17): [True: 5.68k, False: 3.04k]
  ------------------
 6322|  5.68k|                break;
 6323|  3.04k|            elem = elem->parent;
 6324|  3.04k|        }
 6325|  5.68k|        elem = elem->next;
 6326|  5.68k|    }
 6327|       |
 6328|    168|done:
 6329|    168|    return(ret);
 6330|    168|}
xmlValidateDocumentFinal:
 6469|    480|xmlValidateDocumentFinal(xmlValidCtxtPtr ctxt, xmlDocPtr doc) {
 6470|    480|    xmlRefTablePtr table;
 6471|    480|    unsigned int save;
 6472|       |
 6473|    480|    if (ctxt == NULL)
  ------------------
  |  Branch (6473:9): [True: 0, False: 480]
  ------------------
 6474|      0|        return(0);
 6475|    480|    if (doc == NULL) {
  ------------------
  |  Branch (6475:9): [True: 0, False: 480]
  ------------------
 6476|      0|        xmlErrValid(ctxt, XML_DTD_NO_DOC,
 6477|      0|		"xmlValidateDocumentFinal: doc == NULL\n", NULL);
 6478|      0|	return(0);
 6479|      0|    }
 6480|       |
 6481|       |    /* trick to get correct line id report */
 6482|    480|    save = ctxt->flags;
 6483|    480|    ctxt->flags &= ~XML_VCTXT_USE_PCTXT;
  ------------------
  |  |   18|    480|#define XML_VCTXT_USE_PCTXT (1u << 1)
  ------------------
 6484|       |
 6485|       |    /*
 6486|       |     * Check all the NOTATION/NOTATIONS attributes
 6487|       |     */
 6488|       |    /*
 6489|       |     * Check all the ENTITY/ENTITIES attributes definition for validity
 6490|       |     */
 6491|       |    /*
 6492|       |     * Check all the IDREF/IDREFS attributes definition for validity
 6493|       |     */
 6494|    480|    table = (xmlRefTablePtr) doc->refs;
 6495|    480|    ctxt->doc = doc;
 6496|    480|    ctxt->valid = 1;
 6497|    480|    xmlHashScan(table, xmlValidateCheckRefCallback, ctxt);
 6498|       |
 6499|    480|    ctxt->flags = save;
 6500|    480|    return(ctxt->valid);
 6501|    480|}
xmlValidateDtdFinal:
 6664|    503|xmlValidateDtdFinal(xmlValidCtxtPtr ctxt, xmlDocPtr doc) {
 6665|    503|    xmlDtdPtr dtd;
 6666|    503|    xmlAttributeTablePtr table;
 6667|    503|    xmlEntitiesTablePtr entities;
 6668|       |
 6669|    503|    if ((doc == NULL) || (ctxt == NULL)) return(0);
  ------------------
  |  Branch (6669:9): [True: 0, False: 503]
  |  Branch (6669:26): [True: 0, False: 503]
  ------------------
 6670|    503|    if ((doc->intSubset == NULL) && (doc->extSubset == NULL))
  ------------------
  |  Branch (6670:9): [True: 0, False: 503]
  |  Branch (6670:37): [True: 0, False: 0]
  ------------------
 6671|      0|	return(0);
 6672|    503|    ctxt->doc = doc;
 6673|    503|    ctxt->valid = 1;
 6674|    503|    dtd = doc->intSubset;
 6675|    503|    if ((dtd != NULL) && (dtd->attributes != NULL)) {
  ------------------
  |  Branch (6675:9): [True: 503, False: 0]
  |  Branch (6675:26): [True: 131, False: 372]
  ------------------
 6676|    131|	table = (xmlAttributeTablePtr) dtd->attributes;
 6677|    131|	xmlHashScan(table, xmlValidateAttributeCallback, ctxt);
 6678|    131|    }
 6679|    503|    if ((dtd != NULL) && (dtd->entities != NULL)) {
  ------------------
  |  Branch (6679:9): [True: 503, False: 0]
  |  Branch (6679:26): [True: 154, False: 349]
  ------------------
 6680|    154|	entities = (xmlEntitiesTablePtr) dtd->entities;
 6681|    154|	xmlHashScan(entities, xmlValidateNotationCallback, ctxt);
 6682|    154|    }
 6683|    503|    dtd = doc->extSubset;
 6684|    503|    if ((dtd != NULL) && (dtd->attributes != NULL)) {
  ------------------
  |  Branch (6684:9): [True: 68, False: 435]
  |  Branch (6684:26): [True: 32, False: 36]
  ------------------
 6685|     32|	table = (xmlAttributeTablePtr) dtd->attributes;
 6686|     32|	xmlHashScan(table, xmlValidateAttributeCallback, ctxt);
 6687|     32|    }
 6688|    503|    if ((dtd != NULL) && (dtd->entities != NULL)) {
  ------------------
  |  Branch (6688:9): [True: 68, False: 435]
  |  Branch (6688:26): [True: 36, False: 32]
  ------------------
 6689|     36|	entities = (xmlEntitiesTablePtr) dtd->entities;
 6690|     36|	xmlHashScan(entities, xmlValidateNotationCallback, ctxt);
 6691|     36|    }
 6692|    503|    return(ctxt->valid);
 6693|    503|}
xmlValidateDocument:
 6710|    323|xmlValidateDocument(xmlValidCtxtPtr ctxt, xmlDocPtr doc) {
 6711|    323|    int ret;
 6712|    323|    xmlNodePtr root;
 6713|       |
 6714|    323|    if (doc == NULL)
  ------------------
  |  Branch (6714:9): [True: 61, False: 262]
  ------------------
 6715|     61|        return(0);
 6716|    262|    if ((doc->intSubset == NULL) && (doc->extSubset == NULL)) {
  ------------------
  |  Branch (6716:9): [True: 99, False: 163]
  |  Branch (6716:37): [True: 99, False: 0]
  ------------------
 6717|     99|        xmlErrValid(ctxt, XML_DTD_NO_DTD,
 6718|     99|	            "no DTD found!\n", NULL);
 6719|     99|	return(0);
 6720|     99|    }
 6721|    163|    if ((doc->intSubset != NULL) && ((doc->intSubset->SystemID != NULL) ||
  ------------------
  |  Branch (6721:9): [True: 163, False: 0]
  |  Branch (6721:38): [True: 61, False: 102]
  ------------------
 6722|    163|	(doc->intSubset->ExternalID != NULL)) && (doc->extSubset == NULL)) {
  ------------------
  |  Branch (6722:2): [True: 0, False: 102]
  |  Branch (6722:43): [True: 44, False: 17]
  ------------------
 6723|     44|	xmlChar *sysID;
 6724|     44|	if (doc->intSubset->SystemID != NULL) {
  ------------------
  |  Branch (6724:6): [True: 44, False: 0]
  ------------------
 6725|     44|	    sysID = xmlBuildURI(doc->intSubset->SystemID,
 6726|     44|			doc->URL);
 6727|     44|	    if (sysID == NULL) {
  ------------------
  |  Branch (6727:10): [True: 0, False: 44]
  ------------------
 6728|      0|	        xmlErrValid(ctxt, XML_DTD_LOAD_ERROR,
 6729|      0|			"Could not build URI for external subset \"%s\"\n",
 6730|      0|			(const char *) doc->intSubset->SystemID);
 6731|      0|		return 0;
 6732|      0|	    }
 6733|     44|	} else
 6734|      0|	    sysID = NULL;
 6735|     44|        doc->extSubset = xmlParseDTD(doc->intSubset->ExternalID,
 6736|     44|			(const xmlChar *)sysID);
 6737|     44|	if (sysID != NULL)
  ------------------
  |  Branch (6737:6): [True: 44, False: 0]
  ------------------
 6738|     44|	    xmlFree(sysID);
 6739|     44|        if (doc->extSubset == NULL) {
  ------------------
  |  Branch (6739:13): [True: 44, False: 0]
  ------------------
 6740|     44|	    if (doc->intSubset->SystemID != NULL) {
  ------------------
  |  Branch (6740:10): [True: 44, False: 0]
  ------------------
 6741|     44|		xmlErrValid(ctxt, XML_DTD_LOAD_ERROR,
 6742|     44|		       "Could not load the external subset \"%s\"\n",
 6743|     44|		       (const char *) doc->intSubset->SystemID);
 6744|     44|	    } else {
 6745|      0|		xmlErrValid(ctxt, XML_DTD_LOAD_ERROR,
 6746|      0|		       "Could not load the external subset \"%s\"\n",
 6747|      0|		       (const char *) doc->intSubset->ExternalID);
 6748|      0|	    }
 6749|     44|	    return(0);
 6750|     44|	}
 6751|     44|    }
 6752|       |
 6753|    119|    if (doc->ids != NULL) {
  ------------------
  |  Branch (6753:9): [True: 10, False: 109]
  ------------------
 6754|     10|          xmlFreeIDTable(doc->ids);
 6755|     10|          doc->ids = NULL;
 6756|     10|    }
 6757|    119|    if (doc->refs != NULL) {
  ------------------
  |  Branch (6757:9): [True: 5, False: 114]
  ------------------
 6758|      5|          xmlFreeRefTable(doc->refs);
 6759|      5|          doc->refs = NULL;
 6760|      5|    }
 6761|    119|    ret = xmlValidateDtdFinal(ctxt, doc);
 6762|    119|    if (!xmlValidateRoot(ctxt, doc)) return(0);
  ------------------
  |  Branch (6762:9): [True: 2, False: 117]
  ------------------
 6763|       |
 6764|    117|    root = xmlDocGetRootElement(doc);
 6765|    117|    ret &= xmlValidateElement(ctxt, doc, root);
 6766|    117|    ret &= xmlValidateDocumentFinal(ctxt, doc);
 6767|    117|    return(ret);
 6768|    119|}
valid.c:xmlErrValidNode:
  137|  1.21k|{
  138|  1.21k|    xmlStructuredErrorFunc schannel = NULL;
  139|  1.21k|    xmlGenericErrorFunc channel = NULL;
  140|  1.21k|    xmlParserCtxtPtr pctxt = NULL;
  141|  1.21k|    void *data = NULL;
  142|       |
  143|  1.21k|    if (ctxt != NULL) {
  ------------------
  |  Branch (143:9): [True: 1.21k, False: 0]
  ------------------
  144|  1.21k|        channel = ctxt->error;
  145|  1.21k|        data = ctxt->userData;
  146|       |	/* Look up flag to detect if it is part of a parsing
  147|       |	   context */
  148|  1.21k|	if (ctxt->flags & XML_VCTXT_USE_PCTXT) {
  ------------------
  |  |   18|  1.21k|#define XML_VCTXT_USE_PCTXT (1u << 1)
  ------------------
  |  Branch (148:6): [True: 1.02k, False: 191]
  ------------------
  149|  1.02k|	    pctxt = ctxt->userData;
  150|  1.02k|	}
  151|  1.21k|    }
  152|  1.21k|    __xmlRaiseError(schannel, channel, data, pctxt, node, XML_FROM_VALID, error,
  153|  1.21k|                    XML_ERR_ERROR, NULL, 0,
  154|  1.21k|                    (const char *) str1,
  155|  1.21k|                    (const char *) str2,
  156|  1.21k|                    (const char *) str3, 0, 0, msg, str1, str2, str3);
  157|  1.21k|}
valid.c:xmlValidBuildAContentModel:
  494|  3.21k|		           const xmlChar *name) {
  495|  3.21k|    if (content == NULL) {
  ------------------
  |  Branch (495:9): [True: 0, False: 3.21k]
  ------------------
  496|      0|	xmlErrValidNode(ctxt, NULL, XML_ERR_INTERNAL_ERROR,
  497|      0|			"Found NULL content in content model of %s\n",
  498|      0|			name, NULL, NULL);
  499|      0|	return(0);
  500|      0|    }
  501|  3.21k|    switch (content->type) {
  502|      0|	case XML_ELEMENT_CONTENT_PCDATA:
  ------------------
  |  Branch (502:2): [True: 0, False: 3.21k]
  ------------------
  503|      0|	    xmlErrValidNode(ctxt, NULL, XML_ERR_INTERNAL_ERROR,
  504|      0|			    "Found PCDATA in content model of %s\n",
  505|      0|		            name, NULL, NULL);
  506|      0|	    return(0);
  507|      0|	    break;
  508|  2.69k|	case XML_ELEMENT_CONTENT_ELEMENT: {
  ------------------
  |  Branch (508:2): [True: 2.69k, False: 516]
  ------------------
  509|  2.69k|	    xmlAutomataStatePtr oldstate = ctxt->state;
  510|  2.69k|	    xmlChar fn[50];
  511|  2.69k|	    xmlChar *fullname;
  512|       |
  513|  2.69k|	    fullname = xmlBuildQName(content->name, content->prefix, fn, 50);
  514|  2.69k|	    if (fullname == NULL) {
  ------------------
  |  Branch (514:10): [True: 0, False: 2.69k]
  ------------------
  515|      0|	        xmlVErrMemory(ctxt, "Building content model");
  516|      0|		return(0);
  517|      0|	    }
  518|       |
  519|  2.69k|	    switch (content->ocur) {
  ------------------
  |  Branch (519:14): [True: 0, False: 2.69k]
  ------------------
  520|  2.00k|		case XML_ELEMENT_CONTENT_ONCE:
  ------------------
  |  Branch (520:3): [True: 2.00k, False: 689]
  ------------------
  521|  2.00k|		    ctxt->state = xmlAutomataNewTransition(ctxt->am,
  522|  2.00k|			    ctxt->state, NULL, fullname, NULL);
  523|  2.00k|		    break;
  524|    252|		case XML_ELEMENT_CONTENT_OPT:
  ------------------
  |  Branch (524:3): [True: 252, False: 2.44k]
  ------------------
  525|    252|		    ctxt->state = xmlAutomataNewTransition(ctxt->am,
  526|    252|			    ctxt->state, NULL, fullname, NULL);
  527|    252|		    xmlAutomataNewEpsilon(ctxt->am, oldstate, ctxt->state);
  528|    252|		    break;
  529|    204|		case XML_ELEMENT_CONTENT_PLUS:
  ------------------
  |  Branch (529:3): [True: 204, False: 2.49k]
  ------------------
  530|    204|		    ctxt->state = xmlAutomataNewTransition(ctxt->am,
  531|    204|			    ctxt->state, NULL, fullname, NULL);
  532|    204|		    xmlAutomataNewTransition(ctxt->am, ctxt->state,
  533|    204|			                     ctxt->state, fullname, NULL);
  534|    204|		    break;
  535|    233|		case XML_ELEMENT_CONTENT_MULT:
  ------------------
  |  Branch (535:3): [True: 233, False: 2.46k]
  ------------------
  536|    233|		    ctxt->state = xmlAutomataNewEpsilon(ctxt->am,
  537|    233|					    ctxt->state, NULL);
  538|    233|		    xmlAutomataNewTransition(ctxt->am,
  539|    233|			    ctxt->state, ctxt->state, fullname, NULL);
  540|    233|		    break;
  541|  2.69k|	    }
  542|  2.69k|	    if ((fullname != fn) && (fullname != content->name))
  ------------------
  |  Branch (542:10): [True: 2.61k, False: 80]
  |  Branch (542:30): [True: 4, False: 2.61k]
  ------------------
  543|      4|		xmlFree(fullname);
  544|  2.69k|	    break;
  545|  2.69k|	}
  546|    276|	case XML_ELEMENT_CONTENT_SEQ: {
  ------------------
  |  Branch (546:2): [True: 276, False: 2.93k]
  ------------------
  547|    276|	    xmlAutomataStatePtr oldstate, oldend;
  548|    276|	    xmlElementContentOccur ocur;
  549|       |
  550|       |	    /*
  551|       |	     * Simply iterate over the content
  552|       |	     */
  553|    276|	    oldstate = ctxt->state;
  554|    276|	    ocur = content->ocur;
  555|    276|	    if (ocur != XML_ELEMENT_CONTENT_ONCE) {
  ------------------
  |  Branch (555:10): [True: 44, False: 232]
  ------------------
  556|     44|		ctxt->state = xmlAutomataNewEpsilon(ctxt->am, oldstate, NULL);
  557|     44|		oldstate = ctxt->state;
  558|     44|	    }
  559|    756|	    do {
  560|    756|		xmlValidBuildAContentModel(content->c1, ctxt, name);
  561|    756|		content = content->c2;
  562|    756|	    } while ((content->type == XML_ELEMENT_CONTENT_SEQ) &&
  ------------------
  |  Branch (562:15): [True: 492, False: 264]
  ------------------
  563|    756|		     (content->ocur == XML_ELEMENT_CONTENT_ONCE));
  ------------------
  |  Branch (563:8): [True: 480, False: 12]
  ------------------
  564|    276|	    xmlValidBuildAContentModel(content, ctxt, name);
  565|    276|	    oldend = ctxt->state;
  566|    276|	    ctxt->state = xmlAutomataNewEpsilon(ctxt->am, oldend, NULL);
  567|    276|	    switch (ocur) {
  ------------------
  |  Branch (567:14): [True: 0, False: 276]
  ------------------
  568|    232|		case XML_ELEMENT_CONTENT_ONCE:
  ------------------
  |  Branch (568:3): [True: 232, False: 44]
  ------------------
  569|    232|		    break;
  570|     20|		case XML_ELEMENT_CONTENT_OPT:
  ------------------
  |  Branch (570:3): [True: 20, False: 256]
  ------------------
  571|     20|		    xmlAutomataNewEpsilon(ctxt->am, oldstate, ctxt->state);
  572|     20|		    break;
  573|      8|		case XML_ELEMENT_CONTENT_MULT:
  ------------------
  |  Branch (573:3): [True: 8, False: 268]
  ------------------
  574|      8|		    xmlAutomataNewEpsilon(ctxt->am, oldstate, ctxt->state);
  575|      8|		    xmlAutomataNewEpsilon(ctxt->am, oldend, oldstate);
  576|      8|		    break;
  577|     16|		case XML_ELEMENT_CONTENT_PLUS:
  ------------------
  |  Branch (577:3): [True: 16, False: 260]
  ------------------
  578|     16|		    xmlAutomataNewEpsilon(ctxt->am, oldend, oldstate);
  579|     16|		    break;
  580|    276|	    }
  581|    276|	    break;
  582|    276|	}
  583|    276|	case XML_ELEMENT_CONTENT_OR: {
  ------------------
  |  Branch (583:2): [True: 240, False: 2.97k]
  ------------------
  584|    240|	    xmlAutomataStatePtr oldstate, oldend;
  585|    240|	    xmlElementContentOccur ocur;
  586|       |
  587|    240|	    ocur = content->ocur;
  588|    240|	    if ((ocur == XML_ELEMENT_CONTENT_PLUS) ||
  ------------------
  |  Branch (588:10): [True: 68, False: 172]
  ------------------
  589|    240|		(ocur == XML_ELEMENT_CONTENT_MULT)) {
  ------------------
  |  Branch (589:3): [True: 104, False: 68]
  ------------------
  590|    172|		ctxt->state = xmlAutomataNewEpsilon(ctxt->am,
  591|    172|			ctxt->state, NULL);
  592|    172|	    }
  593|    240|	    oldstate = ctxt->state;
  594|    240|	    oldend = xmlAutomataNewState(ctxt->am);
  595|       |
  596|       |	    /*
  597|       |	     * iterate over the subtypes and remerge the end with an
  598|       |	     * epsilon transition
  599|       |	     */
  600|  1.34k|	    do {
  601|  1.34k|		ctxt->state = oldstate;
  602|  1.34k|		xmlValidBuildAContentModel(content->c1, ctxt, name);
  603|  1.34k|		xmlAutomataNewEpsilon(ctxt->am, ctxt->state, oldend);
  604|  1.34k|		content = content->c2;
  605|  1.34k|	    } while ((content->type == XML_ELEMENT_CONTENT_OR) &&
  ------------------
  |  Branch (605:15): [True: 1.10k, False: 240]
  ------------------
  606|  1.34k|		     (content->ocur == XML_ELEMENT_CONTENT_ONCE));
  ------------------
  |  Branch (606:8): [True: 1.10k, False: 0]
  ------------------
  607|    240|	    ctxt->state = oldstate;
  608|    240|	    xmlValidBuildAContentModel(content, ctxt, name);
  609|    240|	    xmlAutomataNewEpsilon(ctxt->am, ctxt->state, oldend);
  610|    240|	    ctxt->state = xmlAutomataNewEpsilon(ctxt->am, oldend, NULL);
  611|    240|	    switch (ocur) {
  ------------------
  |  Branch (611:14): [True: 0, False: 240]
  ------------------
  612|     56|		case XML_ELEMENT_CONTENT_ONCE:
  ------------------
  |  Branch (612:3): [True: 56, False: 184]
  ------------------
  613|     56|		    break;
  614|     12|		case XML_ELEMENT_CONTENT_OPT:
  ------------------
  |  Branch (614:3): [True: 12, False: 228]
  ------------------
  615|     12|		    xmlAutomataNewEpsilon(ctxt->am, oldstate, ctxt->state);
  616|     12|		    break;
  617|    104|		case XML_ELEMENT_CONTENT_MULT:
  ------------------
  |  Branch (617:3): [True: 104, False: 136]
  ------------------
  618|    104|		    xmlAutomataNewEpsilon(ctxt->am, oldstate, ctxt->state);
  619|    104|		    xmlAutomataNewEpsilon(ctxt->am, oldend, oldstate);
  620|    104|		    break;
  621|     68|		case XML_ELEMENT_CONTENT_PLUS:
  ------------------
  |  Branch (621:3): [True: 68, False: 172]
  ------------------
  622|     68|		    xmlAutomataNewEpsilon(ctxt->am, oldend, oldstate);
  623|     68|		    break;
  624|    240|	    }
  625|    240|	    break;
  626|    240|	}
  627|    240|	default:
  ------------------
  |  Branch (627:2): [True: 0, False: 3.21k]
  ------------------
  628|      0|	    xmlErrValid(ctxt, XML_ERR_INTERNAL_ERROR,
  629|      0|	                "ContentModel broken for element %s\n",
  630|      0|			(const char *) name);
  631|      0|	    return(0);
  632|  3.21k|    }
  633|  3.21k|    return(1);
  634|  3.21k|}
valid.c:xmlErrValid:
   94|    143|{
   95|    143|    xmlGenericErrorFunc channel = NULL;
   96|    143|    xmlParserCtxtPtr pctxt = NULL;
   97|    143|    void *data = NULL;
   98|       |
   99|    143|    if (ctxt != NULL) {
  ------------------
  |  Branch (99:9): [True: 143, False: 0]
  ------------------
  100|    143|        channel = ctxt->error;
  101|    143|        data = ctxt->userData;
  102|       |	/* Look up flag to detect if it is part of a parsing
  103|       |	   context */
  104|    143|	if (ctxt->flags & XML_VCTXT_USE_PCTXT) {
  ------------------
  |  |   18|    143|#define XML_VCTXT_USE_PCTXT (1u << 1)
  ------------------
  |  Branch (104:6): [True: 0, False: 143]
  ------------------
  105|      0|	    pctxt = ctxt->userData;
  106|      0|	}
  107|    143|    }
  108|    143|    if (extra)
  ------------------
  |  Branch (108:9): [True: 44, False: 99]
  ------------------
  109|     44|        __xmlRaiseError(NULL, channel, data,
  110|     44|                        pctxt, NULL, XML_FROM_VALID, error,
  111|     44|                        XML_ERR_ERROR, NULL, 0, extra, NULL, NULL, 0, 0,
  112|     44|                        msg, extra);
  113|     99|    else
  114|     99|        __xmlRaiseError(NULL, channel, data,
  115|     99|                        pctxt, NULL, XML_FROM_VALID, error,
  116|     99|                        XML_ERR_ERROR, NULL, 0, NULL, NULL, NULL, 0, 0,
  117|     99|                        "%s", msg);
  118|    143|}
valid.c:xmlFreeElement:
 1234|  3.13k|xmlFreeElement(xmlElementPtr elem) {
 1235|  3.13k|    if (elem == NULL) return;
  ------------------
  |  Branch (1235:9): [True: 0, False: 3.13k]
  ------------------
 1236|  3.13k|    xmlUnlinkNode((xmlNodePtr) elem);
 1237|  3.13k|    xmlFreeDocElementContent(elem->doc, elem->content);
 1238|  3.13k|    if (elem->name != NULL)
  ------------------
  |  Branch (1238:9): [True: 3.13k, False: 0]
  ------------------
 1239|  3.13k|	xmlFree((xmlChar *) elem->name);
 1240|  3.13k|    if (elem->prefix != NULL)
  ------------------
  |  Branch (1240:9): [True: 108, False: 3.02k]
  ------------------
 1241|    108|	xmlFree((xmlChar *) elem->prefix);
 1242|  3.13k|#ifdef LIBXML_REGEXP_ENABLED
 1243|  3.13k|    if (elem->contModel != NULL)
  ------------------
  |  Branch (1243:9): [True: 593, False: 2.54k]
  ------------------
 1244|    593|	xmlRegFreeRegexp(elem->contModel);
 1245|  3.13k|#endif
 1246|  3.13k|    xmlFree(elem);
 1247|  3.13k|}
valid.c:xmlFreeElementTableEntry:
 1475|  3.12k|xmlFreeElementTableEntry(void *elem, const xmlChar *name ATTRIBUTE_UNUSED) {
 1476|  3.12k|    xmlFreeElement((xmlElementPtr) elem);
 1477|  3.12k|}
valid.c:xmlErrValidWarning:
  215|      4|{
  216|      4|    xmlStructuredErrorFunc schannel = NULL;
  217|      4|    xmlGenericErrorFunc channel = NULL;
  218|      4|    xmlParserCtxtPtr pctxt = NULL;
  219|      4|    void *data = NULL;
  220|       |
  221|      4|    if (ctxt != NULL) {
  ------------------
  |  Branch (221:9): [True: 4, False: 0]
  ------------------
  222|      4|        channel = ctxt->warning;
  223|      4|        data = ctxt->userData;
  224|       |	/* Look up flag to detect if it is part of a parsing
  225|       |	   context */
  226|      4|	if (ctxt->flags & XML_VCTXT_USE_PCTXT) {
  ------------------
  |  |   18|      4|#define XML_VCTXT_USE_PCTXT (1u << 1)
  ------------------
  |  Branch (226:6): [True: 4, False: 0]
  ------------------
  227|      4|	    pctxt = ctxt->userData;
  228|      4|	}
  229|      4|    }
  230|      4|    __xmlRaiseError(schannel, channel, data, pctxt, node, XML_FROM_VALID, error,
  231|      4|                    XML_ERR_WARNING, NULL, 0,
  232|      4|                    (const char *) str1,
  233|      4|                    (const char *) str2,
  234|      4|                    (const char *) str3, 0, 0, msg, str1, str2, str3);
  235|      4|}
valid.c:xmlFreeAttribute:
 1759|  7.78k|xmlFreeAttribute(xmlAttributePtr attr) {
 1760|  7.78k|    xmlDictPtr dict;
 1761|       |
 1762|  7.78k|    if (attr == NULL) return;
  ------------------
  |  Branch (1762:9): [True: 0, False: 7.78k]
  ------------------
 1763|  7.78k|    if (attr->doc != NULL)
  ------------------
  |  Branch (1763:9): [True: 7.78k, False: 0]
  ------------------
 1764|  7.78k|	dict = attr->doc->dict;
 1765|      0|    else
 1766|      0|	dict = NULL;
 1767|  7.78k|    xmlUnlinkNode((xmlNodePtr) attr);
 1768|  7.78k|    if (attr->tree != NULL)
  ------------------
  |  Branch (1768:9): [True: 1.68k, False: 6.09k]
  ------------------
 1769|  1.68k|        xmlFreeEnumeration(attr->tree);
 1770|  7.78k|    if (dict) {
  ------------------
  |  Branch (1770:9): [True: 7.78k, False: 0]
  ------------------
 1771|  7.78k|        if ((attr->elem != NULL) && (!xmlDictOwns(dict, attr->elem)))
  ------------------
  |  Branch (1771:13): [True: 7.78k, False: 0]
  |  Branch (1771:37): [True: 0, False: 7.78k]
  ------------------
 1772|      0|	    xmlFree((xmlChar *) attr->elem);
 1773|  7.78k|        if ((attr->name != NULL) && (!xmlDictOwns(dict, attr->name)))
  ------------------
  |  Branch (1773:13): [True: 7.78k, False: 0]
  |  Branch (1773:37): [True: 0, False: 7.78k]
  ------------------
 1774|      0|	    xmlFree((xmlChar *) attr->name);
 1775|  7.78k|        if ((attr->prefix != NULL) && (!xmlDictOwns(dict, attr->prefix)))
  ------------------
  |  Branch (1775:13): [True: 312, False: 7.46k]
  |  Branch (1775:39): [True: 0, False: 312]
  ------------------
 1776|      0|	    xmlFree((xmlChar *) attr->prefix);
 1777|  7.78k|        if ((attr->defaultValue != NULL) &&
  ------------------
  |  Branch (1777:13): [True: 1.63k, False: 6.14k]
  ------------------
 1778|  7.78k|	    (!xmlDictOwns(dict, attr->defaultValue)))
  ------------------
  |  Branch (1778:6): [True: 0, False: 1.63k]
  ------------------
 1779|      0|	    xmlFree((xmlChar *) attr->defaultValue);
 1780|  7.78k|    } else {
 1781|      0|	if (attr->elem != NULL)
  ------------------
  |  Branch (1781:6): [True: 0, False: 0]
  ------------------
 1782|      0|	    xmlFree((xmlChar *) attr->elem);
 1783|      0|	if (attr->name != NULL)
  ------------------
  |  Branch (1783:6): [True: 0, False: 0]
  ------------------
 1784|      0|	    xmlFree((xmlChar *) attr->name);
 1785|      0|	if (attr->defaultValue != NULL)
  ------------------
  |  Branch (1785:6): [True: 0, False: 0]
  ------------------
 1786|      0|	    xmlFree((xmlChar *) attr->defaultValue);
 1787|      0|	if (attr->prefix != NULL)
  ------------------
  |  Branch (1787:6): [True: 0, False: 0]
  ------------------
 1788|      0|	    xmlFree((xmlChar *) attr->prefix);
 1789|      0|    }
 1790|  7.78k|    xmlFree(attr);
 1791|  7.78k|}
valid.c:xmlScanIDAttributeDecl:
 1732|  3.01k|xmlScanIDAttributeDecl(xmlValidCtxtPtr ctxt, xmlElementPtr elem, int err) {
 1733|  3.01k|    xmlAttributePtr cur;
 1734|  3.01k|    int ret = 0;
 1735|       |
 1736|  3.01k|    if (elem == NULL) return(0);
  ------------------
  |  Branch (1736:9): [True: 0, False: 3.01k]
  ------------------
 1737|  3.01k|    cur = elem->attributes;
 1738|  4.38k|    while (cur != NULL) {
  ------------------
  |  Branch (1738:12): [True: 1.36k, False: 3.01k]
  ------------------
 1739|  1.36k|        if (cur->atype == XML_ATTRIBUTE_ID) {
  ------------------
  |  Branch (1739:13): [True: 1.31k, False: 49]
  ------------------
 1740|  1.31k|	    ret ++;
 1741|  1.31k|	    if ((ret > 1) && (err))
  ------------------
  |  Branch (1741:10): [True: 9, False: 1.30k]
  |  Branch (1741:23): [True: 0, False: 9]
  ------------------
 1742|      0|		xmlErrValidNode(ctxt, (xmlNodePtr) elem, XML_DTD_MULTIPLE_ID,
 1743|      0|	       "Element %s has too many ID attributes defined : %s\n",
 1744|      0|		       elem->name, cur->name, NULL);
 1745|  1.31k|	}
 1746|  1.36k|	cur = cur->nexth;
 1747|  1.36k|    }
 1748|  3.01k|    return(ret);
 1749|  3.01k|}
valid.c:xmlFreeAttributeTableEntry:
 2027|  7.77k|xmlFreeAttributeTableEntry(void *attr, const xmlChar *name ATTRIBUTE_UNUSED) {
 2028|  7.77k|    xmlFreeAttribute((xmlAttributePtr) attr);
 2029|  7.77k|}
valid.c:xmlIsStreaming:
 2471|  4.97k|xmlIsStreaming(xmlValidCtxtPtr ctxt) {
 2472|  4.97k|    xmlParserCtxtPtr pctxt;
 2473|       |
 2474|  4.97k|    if (ctxt == NULL)
  ------------------
  |  Branch (2474:9): [True: 11, False: 4.96k]
  ------------------
 2475|     11|        return(0);
 2476|  4.96k|    if ((ctxt->flags & XML_VCTXT_USE_PCTXT) == 0)
  ------------------
  |  |   18|  4.96k|#define XML_VCTXT_USE_PCTXT (1u << 1)
  ------------------
  |  Branch (2476:9): [True: 989, False: 3.97k]
  ------------------
 2477|    989|        return(0);
 2478|  3.97k|    pctxt = ctxt->userData;
 2479|  3.97k|    return(pctxt->parseMode == XML_PARSE_READER);
 2480|  4.96k|}
valid.c:xmlFreeID:
 2489|  1.66k|xmlFreeID(xmlIDPtr id) {
 2490|  1.66k|    xmlDictPtr dict = NULL;
 2491|       |
 2492|  1.66k|    if (id == NULL) return;
  ------------------
  |  Branch (2492:9): [True: 0, False: 1.66k]
  ------------------
 2493|       |
 2494|  1.66k|    if (id->doc != NULL)
  ------------------
  |  Branch (2494:9): [True: 1.66k, False: 0]
  ------------------
 2495|  1.66k|        dict = id->doc->dict;
 2496|       |
 2497|  1.66k|    if (id->value != NULL)
  ------------------
  |  Branch (2497:9): [True: 1.66k, False: 0]
  ------------------
 2498|  1.66k|	DICT_FREE(id->value)
  ------------------
  |  | 2437|  1.66k|	if ((str) && ((!dict) ||				\
  |  |  ------------------
  |  |  |  Branch (2437:6): [True: 1.66k, False: 0]
  |  |  |  Branch (2437:16): [True: 0, False: 1.66k]
  |  |  ------------------
  |  | 2438|  1.66k|	    (xmlDictOwns(dict, (const xmlChar *)(str)) == 0)))	\
  |  |  ------------------
  |  |  |  Branch (2438:6): [True: 1.66k, False: 0]
  |  |  ------------------
  |  | 2439|  1.66k|	    xmlFree((char *)(str));
  ------------------
 2499|  1.66k|    if (id->name != NULL)
  ------------------
  |  Branch (2499:9): [True: 331, False: 1.32k]
  ------------------
 2500|    331|	DICT_FREE(id->name)
  ------------------
  |  | 2437|    331|	if ((str) && ((!dict) ||				\
  |  |  ------------------
  |  |  |  Branch (2437:6): [True: 331, False: 0]
  |  |  |  Branch (2437:16): [True: 0, False: 331]
  |  |  ------------------
  |  | 2438|    331|	    (xmlDictOwns(dict, (const xmlChar *)(str)) == 0)))	\
  |  |  ------------------
  |  |  |  Branch (2438:6): [True: 0, False: 331]
  |  |  ------------------
  |  | 2439|    331|	    xmlFree((char *)(str));
  ------------------
 2501|  1.66k|    xmlFree(id);
 2502|  1.66k|}
valid.c:xmlFreeIDTableEntry:
 2590|  1.64k|xmlFreeIDTableEntry(void *id, const xmlChar *name ATTRIBUTE_UNUSED) {
 2591|  1.64k|    xmlFreeID((xmlIDPtr) id);
 2592|  1.64k|}
valid.c:xmlFreeRef:
 2776|  3.31k|xmlFreeRef(xmlLinkPtr lk) {
 2777|  3.31k|    xmlRefPtr ref = (xmlRefPtr)xmlLinkGetData(lk);
 2778|  3.31k|    if (ref == NULL) return;
  ------------------
  |  Branch (2778:9): [True: 0, False: 3.31k]
  ------------------
 2779|  3.31k|    if (ref->value != NULL)
  ------------------
  |  Branch (2779:9): [True: 3.31k, False: 0]
  ------------------
 2780|  3.31k|        xmlFree((xmlChar *)ref->value);
 2781|  3.31k|    if (ref->name != NULL)
  ------------------
  |  Branch (2781:9): [True: 664, False: 2.65k]
  ------------------
 2782|    664|        xmlFree((xmlChar *)ref->name);
 2783|  3.31k|    xmlFree(ref);
 2784|  3.31k|}
valid.c:xmlDummyCompare:
 2830|  2.22k|{
 2831|  2.22k|    return (0);
 2832|  2.22k|}
valid.c:xmlFreeRefTableEntry:
 2793|  1.09k|xmlFreeRefTableEntry(void *payload, const xmlChar *name ATTRIBUTE_UNUSED) {
 2794|  1.09k|    xmlListPtr list_ref = (xmlListPtr) payload;
 2795|  1.09k|    if (list_ref == NULL) return;
  ------------------
  |  Branch (2795:9): [True: 0, False: 1.09k]
  ------------------
 2796|  1.09k|    xmlListDelete(list_ref);
 2797|  1.09k|}
valid.c:xmlGetDtdElementDesc2:
 3133|  7.77k|                      int create) {
 3134|  7.77k|    xmlElementTablePtr table;
 3135|  7.77k|    xmlElementPtr cur;
 3136|  7.77k|    xmlChar *uqname = NULL, *prefix = NULL;
 3137|       |
 3138|  7.77k|    if (dtd == NULL) return(NULL);
  ------------------
  |  Branch (3138:9): [True: 0, False: 7.77k]
  ------------------
 3139|  7.77k|    if (dtd->elements == NULL) {
  ------------------
  |  Branch (3139:9): [True: 20, False: 7.75k]
  ------------------
 3140|     20|	xmlDictPtr dict = NULL;
 3141|       |
 3142|     20|	if (dtd->doc != NULL)
  ------------------
  |  Branch (3142:6): [True: 20, False: 0]
  ------------------
 3143|     20|	    dict = dtd->doc->dict;
 3144|       |
 3145|     20|	if (!create)
  ------------------
  |  Branch (3145:6): [True: 0, False: 20]
  ------------------
 3146|      0|	    return(NULL);
 3147|       |	/*
 3148|       |	 * Create the Element table if needed.
 3149|       |	 */
 3150|     20|	table = (xmlElementTablePtr) dtd->elements;
 3151|     20|	if (table == NULL) {
  ------------------
  |  Branch (3151:6): [True: 20, False: 0]
  ------------------
 3152|     20|	    table = xmlHashCreateDict(0, dict);
 3153|     20|	    dtd->elements = (void *) table;
 3154|     20|	}
 3155|     20|	if (table == NULL) {
  ------------------
  |  Branch (3155:6): [True: 0, False: 20]
  ------------------
 3156|      0|	    xmlVErrMemory(ctxt, "element table allocation failed");
 3157|      0|	    return(NULL);
 3158|      0|	}
 3159|     20|    }
 3160|  7.77k|    table = (xmlElementTablePtr) dtd->elements;
 3161|       |
 3162|  7.77k|    uqname = xmlSplitQName2(name, &prefix);
 3163|  7.77k|    if (uqname != NULL)
  ------------------
  |  Branch (3163:9): [True: 112, False: 7.66k]
  ------------------
 3164|    112|        name = uqname;
 3165|  7.77k|    cur = xmlHashLookup2(table, name, prefix);
 3166|  7.77k|    if ((cur == NULL) && (create)) {
  ------------------
  |  Branch (3166:9): [True: 28, False: 7.74k]
  |  Branch (3166:26): [True: 28, False: 0]
  ------------------
 3167|     28|	cur = (xmlElementPtr) xmlMalloc(sizeof(xmlElement));
 3168|     28|	if (cur == NULL) {
  ------------------
  |  Branch (3168:6): [True: 0, False: 28]
  ------------------
 3169|      0|	    xmlVErrMemory(ctxt, "malloc failed");
 3170|      0|	    goto error;
 3171|      0|	}
 3172|     28|	memset(cur, 0, sizeof(xmlElement));
 3173|     28|	cur->type = XML_ELEMENT_DECL;
 3174|       |
 3175|       |	/*
 3176|       |	 * fill the structure.
 3177|       |	 */
 3178|     28|	cur->name = xmlStrdup(name);
 3179|     28|	cur->prefix = xmlStrdup(prefix);
 3180|     28|	cur->etype = XML_ELEMENT_TYPE_UNDEFINED;
 3181|       |
 3182|     28|	if (xmlHashAddEntry2(table, name, prefix, cur) < 0) {
  ------------------
  |  Branch (3182:6): [True: 0, False: 28]
  ------------------
 3183|      0|	    xmlVErrMemory(ctxt, "adding entry failed");
 3184|      0|            xmlFreeElement(cur);
 3185|      0|            cur = NULL;
 3186|      0|        }
 3187|     28|    }
 3188|  7.77k|error:
 3189|  7.77k|    if (prefix != NULL) xmlFree(prefix);
  ------------------
  |  Branch (3189:9): [True: 112, False: 7.66k]
  ------------------
 3190|  7.77k|    if (uqname != NULL) xmlFree(uqname);
  ------------------
  |  Branch (3190:9): [True: 112, False: 7.66k]
  ------------------
 3191|  7.77k|    return(cur);
 3192|  7.77k|}
valid.c:xmlValidateNameValueInternal:
 3452|  3.96k|xmlValidateNameValueInternal(xmlDocPtr doc, const xmlChar *value) {
 3453|  3.96k|    const xmlChar *cur;
 3454|  3.96k|    int val, len;
 3455|       |
 3456|  3.96k|    if (value == NULL) return(0);
  ------------------
  |  Branch (3456:9): [True: 0, False: 3.96k]
  ------------------
 3457|  3.96k|    cur = value;
 3458|  3.96k|    val = xmlStringCurrentChar(NULL, cur, &len);
 3459|  3.96k|    cur += len;
 3460|  3.96k|    if (!xmlIsDocNameStartChar(doc, val))
  ------------------
  |  Branch (3460:9): [True: 4, False: 3.96k]
  ------------------
 3461|      4|	return(0);
 3462|       |
 3463|  3.96k|    val = xmlStringCurrentChar(NULL, cur, &len);
 3464|  3.96k|    cur += len;
 3465|  37.3k|    while (xmlIsDocNameChar(doc, val)) {
  ------------------
  |  Branch (3465:12): [True: 33.3k, False: 3.96k]
  ------------------
 3466|  33.3k|	val = xmlStringCurrentChar(NULL, cur, &len);
 3467|  33.3k|	cur += len;
 3468|  33.3k|    }
 3469|       |
 3470|  3.96k|    if (val != 0) return(0);
  ------------------
  |  Branch (3470:9): [True: 0, False: 3.96k]
  ------------------
 3471|       |
 3472|  3.96k|    return(1);
 3473|  3.96k|}
valid.c:xmlIsDocNameStartChar:
 3374|  3.98k|xmlIsDocNameStartChar(xmlDocPtr doc, int c) {
 3375|  3.98k|    if ((doc == NULL) || (doc->properties & XML_DOC_OLD10) == 0) {
  ------------------
  |  Branch (3375:9): [True: 0, False: 3.98k]
  |  Branch (3375:26): [True: 3.98k, False: 0]
  ------------------
 3376|       |        /*
 3377|       |	 * Use the new checks of production [4] [4a] amd [5] of the
 3378|       |	 * Update 5 of XML-1.0
 3379|       |	 */
 3380|  3.98k|	if (((c >= 'a') && (c <= 'z')) ||
  ------------------
  |  Branch (3380:7): [True: 2.16k, False: 1.82k]
  |  Branch (3380:21): [True: 2.16k, False: 0]
  ------------------
 3381|  3.98k|	    ((c >= 'A') && (c <= 'Z')) ||
  ------------------
  |  Branch (3381:7): [True: 1.81k, False: 8]
  |  Branch (3381:21): [True: 1.81k, False: 0]
  ------------------
 3382|  3.98k|	    (c == '_') || (c == ':') ||
  ------------------
  |  Branch (3382:6): [True: 0, False: 8]
  |  Branch (3382:20): [True: 0, False: 8]
  ------------------
 3383|  3.98k|	    ((c >= 0xC0) && (c <= 0xD6)) ||
  ------------------
  |  Branch (3383:7): [True: 0, False: 8]
  |  Branch (3383:22): [True: 0, False: 0]
  ------------------
 3384|  3.98k|	    ((c >= 0xD8) && (c <= 0xF6)) ||
  ------------------
  |  Branch (3384:7): [True: 0, False: 8]
  |  Branch (3384:22): [True: 0, False: 0]
  ------------------
 3385|  3.98k|	    ((c >= 0xF8) && (c <= 0x2FF)) ||
  ------------------
  |  Branch (3385:7): [True: 0, False: 8]
  |  Branch (3385:22): [True: 0, False: 0]
  ------------------
 3386|  3.98k|	    ((c >= 0x370) && (c <= 0x37D)) ||
  ------------------
  |  Branch (3386:7): [True: 0, False: 8]
  |  Branch (3386:23): [True: 0, False: 0]
  ------------------
 3387|  3.98k|	    ((c >= 0x37F) && (c <= 0x1FFF)) ||
  ------------------
  |  Branch (3387:7): [True: 0, False: 8]
  |  Branch (3387:23): [True: 0, False: 0]
  ------------------
 3388|  3.98k|	    ((c >= 0x200C) && (c <= 0x200D)) ||
  ------------------
  |  Branch (3388:7): [True: 0, False: 8]
  |  Branch (3388:24): [True: 0, False: 0]
  ------------------
 3389|  3.98k|	    ((c >= 0x2070) && (c <= 0x218F)) ||
  ------------------
  |  Branch (3389:7): [True: 0, False: 8]
  |  Branch (3389:24): [True: 0, False: 0]
  ------------------
 3390|  3.98k|	    ((c >= 0x2C00) && (c <= 0x2FEF)) ||
  ------------------
  |  Branch (3390:7): [True: 0, False: 8]
  |  Branch (3390:24): [True: 0, False: 0]
  ------------------
 3391|  3.98k|	    ((c >= 0x3001) && (c <= 0xD7FF)) ||
  ------------------
  |  Branch (3391:7): [True: 0, False: 8]
  |  Branch (3391:24): [True: 0, False: 0]
  ------------------
 3392|  3.98k|	    ((c >= 0xF900) && (c <= 0xFDCF)) ||
  ------------------
  |  Branch (3392:7): [True: 0, False: 8]
  |  Branch (3392:24): [True: 0, False: 0]
  ------------------
 3393|  3.98k|	    ((c >= 0xFDF0) && (c <= 0xFFFD)) ||
  ------------------
  |  Branch (3393:7): [True: 0, False: 8]
  |  Branch (3393:24): [True: 0, False: 0]
  ------------------
 3394|  3.98k|	    ((c >= 0x10000) && (c <= 0xEFFFF)))
  ------------------
  |  Branch (3394:7): [True: 0, False: 8]
  |  Branch (3394:25): [True: 0, False: 0]
  ------------------
 3395|  3.98k|	    return(1);
 3396|  3.98k|    } else {
 3397|      0|        if (IS_LETTER(c) || (c == '_') || (c == ':'))
  ------------------
  |  |  240|      0|#define IS_LETTER(c) (IS_BASECHAR(c) || IS_IDEOGRAPHIC(c))
  |  |  ------------------
  |  |  |  |  161|      0|#define IS_BASECHAR(c) xmlIsBaseCharQ(c)
  |  |  |  |  ------------------
  |  |  |  |  |  |   76|      0|#define xmlIsBaseCharQ(c)	(((c) < 0x100) ? \
  |  |  |  |  |  |  ------------------
  |  |  |  |  |  |  |  Branch (76:27): [True: 0, False: 0]
  |  |  |  |  |  |  |  Branch (76:28): [True: 0, False: 0]
  |  |  |  |  |  |  ------------------
  |  |  |  |  |  |   77|      0|				 xmlIsBaseChar_ch((c)) : \
  |  |  |  |  |  |  ------------------
  |  |  |  |  |  |  |  |   64|      0|#define xmlIsBaseChar_ch(c)	(((0x41 <= (c)) && ((c) <= 0x5a)) || \
  |  |  |  |  |  |  |  |  ------------------
  |  |  |  |  |  |  |  |  |  Branch (64:31): [True: 0, False: 0]
  |  |  |  |  |  |  |  |  |  Branch (64:48): [True: 0, False: 0]
  |  |  |  |  |  |  |  |  ------------------
  |  |  |  |  |  |  |  |   65|      0|				 ((0x61 <= (c)) && ((c) <= 0x7a)) || \
  |  |  |  |  |  |  |  |  ------------------
  |  |  |  |  |  |  |  |  |  Branch (65:7): [True: 0, False: 0]
  |  |  |  |  |  |  |  |  |  Branch (65:24): [True: 0, False: 0]
  |  |  |  |  |  |  |  |  ------------------
  |  |  |  |  |  |  |  |   66|      0|				 ((0xc0 <= (c)) && ((c) <= 0xd6)) || \
  |  |  |  |  |  |  |  |  ------------------
  |  |  |  |  |  |  |  |  |  Branch (66:7): [True: 0, False: 0]
  |  |  |  |  |  |  |  |  |  Branch (66:24): [True: 0, False: 0]
  |  |  |  |  |  |  |  |  ------------------
  |  |  |  |  |  |  |  |   67|      0|				 ((0xd8 <= (c)) && ((c) <= 0xf6)) || \
  |  |  |  |  |  |  |  |  ------------------
  |  |  |  |  |  |  |  |  |  Branch (67:7): [True: 0, False: 0]
  |  |  |  |  |  |  |  |  |  Branch (67:24): [True: 0, False: 0]
  |  |  |  |  |  |  |  |  ------------------
  |  |  |  |  |  |  |  |   68|      0|				  (0xf8 <= (c)))
  |  |  |  |  |  |  |  |  ------------------
  |  |  |  |  |  |  |  |  |  Branch (68:7): [True: 0, False: 0]
  |  |  |  |  |  |  |  |  ------------------
  |  |  |  |  |  |  ------------------
  |  |  |  |  |  |   78|      0|				 xmlCharInRange((c), &xmlIsBaseCharGroup))
  |  |  |  |  ------------------
  |  |  ------------------
  |  |               #define IS_LETTER(c) (IS_BASECHAR(c) || IS_IDEOGRAPHIC(c))
  |  |  ------------------
  |  |  |  |  229|      0|#define IS_IDEOGRAPHIC(c) xmlIsIdeographicQ(c)
  |  |  |  |  ------------------
  |  |  |  |  |  |  184|      0|#define xmlIsIdeographicQ(c)	(((c) < 0x100) ? \
  |  |  |  |  |  |  ------------------
  |  |  |  |  |  |  |  Branch (184:30): [True: 0, False: 0]
  |  |  |  |  |  |  |  Branch (184:31): [True: 0, False: 0]
  |  |  |  |  |  |  ------------------
  |  |  |  |  |  |  185|      0|				 0 :\
  |  |  |  |  |  |  186|      0|				(((0x4e00 <= (c)) && ((c) <= 0x9fa5)) || \
  |  |  |  |  |  |  ------------------
  |  |  |  |  |  |  |  Branch (186:7): [True: 0, False: 0]
  |  |  |  |  |  |  |  Branch (186:26): [True: 0, False: 0]
  |  |  |  |  |  |  ------------------
  |  |  |  |  |  |  187|      0|				 ((c) == 0x3007) || \
  |  |  |  |  |  |  ------------------
  |  |  |  |  |  |  |  Branch (187:6): [True: 0, False: 0]
  |  |  |  |  |  |  ------------------
  |  |  |  |  |  |  188|      0|				 ((0x3021 <= (c)) && ((c) <= 0x3029))))
  |  |  |  |  |  |  ------------------
  |  |  |  |  |  |  |  Branch (188:7): [True: 0, False: 0]
  |  |  |  |  |  |  |  Branch (188:26): [True: 0, False: 0]
  |  |  |  |  |  |  ------------------
  |  |  |  |  ------------------
  |  |  ------------------
  ------------------
  |  Branch (3397:29): [True: 0, False: 0]
  |  Branch (3397:43): [True: 0, False: 0]
  ------------------
 3398|      0|	    return(1);
 3399|      0|    }
 3400|      8|    return(0);
 3401|  3.98k|}
valid.c:xmlIsDocNameChar:
 3404|  46.3k|xmlIsDocNameChar(xmlDocPtr doc, int c) {
 3405|  46.3k|    if ((doc == NULL) || (doc->properties & XML_DOC_OLD10) == 0) {
  ------------------
  |  Branch (3405:9): [True: 0, False: 46.3k]
  |  Branch (3405:26): [True: 46.3k, False: 0]
  ------------------
 3406|       |        /*
 3407|       |	 * Use the new checks of production [4] [4a] amd [5] of the
 3408|       |	 * Update 5 of XML-1.0
 3409|       |	 */
 3410|  46.3k|	if (((c >= 'a') && (c <= 'z')) ||
  ------------------
  |  Branch (3410:7): [True: 26.9k, False: 19.4k]
  |  Branch (3410:21): [True: 26.9k, False: 0]
  ------------------
 3411|  46.3k|	    ((c >= 'A') && (c <= 'Z')) ||
  ------------------
  |  Branch (3411:7): [True: 4.47k, False: 14.9k]
  |  Branch (3411:21): [True: 4.45k, False: 21]
  ------------------
 3412|  46.3k|	    ((c >= '0') && (c <= '9')) || /* !start */
  ------------------
  |  Branch (3412:7): [True: 4.89k, False: 10.1k]
  |  Branch (3412:21): [True: 4.84k, False: 47]
  ------------------
 3413|  46.3k|	    (c == '_') || (c == ':') ||
  ------------------
  |  Branch (3413:6): [True: 21, False: 10.1k]
  |  Branch (3413:20): [True: 11, False: 10.1k]
  ------------------
 3414|  46.3k|	    (c == '-') || (c == '.') || (c == 0xB7) || /* !start */
  ------------------
  |  Branch (3414:6): [True: 3.50k, False: 6.63k]
  |  Branch (3414:20): [True: 0, False: 6.63k]
  |  Branch (3414:34): [True: 0, False: 6.63k]
  ------------------
 3415|  46.3k|	    ((c >= 0xC0) && (c <= 0xD6)) ||
  ------------------
  |  Branch (3415:7): [True: 0, False: 6.63k]
  |  Branch (3415:22): [True: 0, False: 0]
  ------------------
 3416|  46.3k|	    ((c >= 0xD8) && (c <= 0xF6)) ||
  ------------------
  |  Branch (3416:7): [True: 0, False: 6.63k]
  |  Branch (3416:22): [True: 0, False: 0]
  ------------------
 3417|  46.3k|	    ((c >= 0xF8) && (c <= 0x2FF)) ||
  ------------------
  |  Branch (3417:7): [True: 0, False: 6.63k]
  |  Branch (3417:22): [True: 0, False: 0]
  ------------------
 3418|  46.3k|	    ((c >= 0x300) && (c <= 0x36F)) || /* !start */
  ------------------
  |  Branch (3418:7): [True: 0, False: 6.63k]
  |  Branch (3418:23): [True: 0, False: 0]
  ------------------
 3419|  46.3k|	    ((c >= 0x370) && (c <= 0x37D)) ||
  ------------------
  |  Branch (3419:7): [True: 0, False: 6.63k]
  |  Branch (3419:23): [True: 0, False: 0]
  ------------------
 3420|  46.3k|	    ((c >= 0x37F) && (c <= 0x1FFF)) ||
  ------------------
  |  Branch (3420:7): [True: 0, False: 6.63k]
  |  Branch (3420:23): [True: 0, False: 0]
  ------------------
 3421|  46.3k|	    ((c >= 0x200C) && (c <= 0x200D)) ||
  ------------------
  |  Branch (3421:7): [True: 0, False: 6.63k]
  |  Branch (3421:24): [True: 0, False: 0]
  ------------------
 3422|  46.3k|	    ((c >= 0x203F) && (c <= 0x2040)) || /* !start */
  ------------------
  |  Branch (3422:7): [True: 0, False: 6.63k]
  |  Branch (3422:24): [True: 0, False: 0]
  ------------------
 3423|  46.3k|	    ((c >= 0x2070) && (c <= 0x218F)) ||
  ------------------
  |  Branch (3423:7): [True: 0, False: 6.63k]
  |  Branch (3423:24): [True: 0, False: 0]
  ------------------
 3424|  46.3k|	    ((c >= 0x2C00) && (c <= 0x2FEF)) ||
  ------------------
  |  Branch (3424:7): [True: 0, False: 6.63k]
  |  Branch (3424:24): [True: 0, False: 0]
  ------------------
 3425|  46.3k|	    ((c >= 0x3001) && (c <= 0xD7FF)) ||
  ------------------
  |  Branch (3425:7): [True: 0, False: 6.63k]
  |  Branch (3425:24): [True: 0, False: 0]
  ------------------
 3426|  46.3k|	    ((c >= 0xF900) && (c <= 0xFDCF)) ||
  ------------------
  |  Branch (3426:7): [True: 0, False: 6.63k]
  |  Branch (3426:24): [True: 0, False: 0]
  ------------------
 3427|  46.3k|	    ((c >= 0xFDF0) && (c <= 0xFFFD)) ||
  ------------------
  |  Branch (3427:7): [True: 0, False: 6.63k]
  |  Branch (3427:24): [True: 0, False: 0]
  ------------------
 3428|  46.3k|	    ((c >= 0x10000) && (c <= 0xEFFFF)))
  ------------------
  |  Branch (3428:7): [True: 0, False: 6.63k]
  |  Branch (3428:25): [True: 0, False: 0]
  ------------------
 3429|  39.7k|	     return(1);
 3430|  46.3k|    } else {
 3431|      0|        if ((IS_LETTER(c)) || (IS_DIGIT(c)) ||
  ------------------
  |  |  240|      0|#define IS_LETTER(c) (IS_BASECHAR(c) || IS_IDEOGRAPHIC(c))
  |  |  ------------------
  |  |  |  |  161|      0|#define IS_BASECHAR(c) xmlIsBaseCharQ(c)
  |  |  |  |  ------------------
  |  |  |  |  |  |   76|      0|#define xmlIsBaseCharQ(c)	(((c) < 0x100) ? \
  |  |  |  |  |  |  ------------------
  |  |  |  |  |  |  |  Branch (76:27): [True: 0, False: 0]
  |  |  |  |  |  |  |  Branch (76:28): [True: 0, False: 0]
  |  |  |  |  |  |  ------------------
  |  |  |  |  |  |   77|      0|				 xmlIsBaseChar_ch((c)) : \
  |  |  |  |  |  |  ------------------
  |  |  |  |  |  |  |  |   64|      0|#define xmlIsBaseChar_ch(c)	(((0x41 <= (c)) && ((c) <= 0x5a)) || \
  |  |  |  |  |  |  |  |  ------------------
  |  |  |  |  |  |  |  |  |  Branch (64:31): [True: 0, False: 0]
  |  |  |  |  |  |  |  |  |  Branch (64:48): [True: 0, False: 0]
  |  |  |  |  |  |  |  |  ------------------
  |  |  |  |  |  |  |  |   65|      0|				 ((0x61 <= (c)) && ((c) <= 0x7a)) || \
  |  |  |  |  |  |  |  |  ------------------
  |  |  |  |  |  |  |  |  |  Branch (65:7): [True: 0, False: 0]
  |  |  |  |  |  |  |  |  |  Branch (65:24): [True: 0, False: 0]
  |  |  |  |  |  |  |  |  ------------------
  |  |  |  |  |  |  |  |   66|      0|				 ((0xc0 <= (c)) && ((c) <= 0xd6)) || \
  |  |  |  |  |  |  |  |  ------------------
  |  |  |  |  |  |  |  |  |  Branch (66:7): [True: 0, False: 0]
  |  |  |  |  |  |  |  |  |  Branch (66:24): [True: 0, False: 0]
  |  |  |  |  |  |  |  |  ------------------
  |  |  |  |  |  |  |  |   67|      0|				 ((0xd8 <= (c)) && ((c) <= 0xf6)) || \
  |  |  |  |  |  |  |  |  ------------------
  |  |  |  |  |  |  |  |  |  Branch (67:7): [True: 0, False: 0]
  |  |  |  |  |  |  |  |  |  Branch (67:24): [True: 0, False: 0]
  |  |  |  |  |  |  |  |  ------------------
  |  |  |  |  |  |  |  |   68|      0|				  (0xf8 <= (c)))
  |  |  |  |  |  |  |  |  ------------------
  |  |  |  |  |  |  |  |  |  Branch (68:7): [True: 0, False: 0]
  |  |  |  |  |  |  |  |  ------------------
  |  |  |  |  |  |  ------------------
  |  |  |  |  |  |   78|      0|				 xmlCharInRange((c), &xmlIsBaseCharGroup))
  |  |  |  |  ------------------
  |  |  ------------------
  |  |               #define IS_LETTER(c) (IS_BASECHAR(c) || IS_IDEOGRAPHIC(c))
  |  |  ------------------
  |  |  |  |  229|      0|#define IS_IDEOGRAPHIC(c) xmlIsIdeographicQ(c)
  |  |  |  |  ------------------
  |  |  |  |  |  |  184|      0|#define xmlIsIdeographicQ(c)	(((c) < 0x100) ? \
  |  |  |  |  |  |  ------------------
  |  |  |  |  |  |  |  Branch (184:30): [True: 0, False: 0]
  |  |  |  |  |  |  |  Branch (184:31): [True: 0, False: 0]
  |  |  |  |  |  |  ------------------
  |  |  |  |  |  |  185|      0|				 0 :\
  |  |  |  |  |  |  186|      0|				(((0x4e00 <= (c)) && ((c) <= 0x9fa5)) || \
  |  |  |  |  |  |  ------------------
  |  |  |  |  |  |  |  Branch (186:7): [True: 0, False: 0]
  |  |  |  |  |  |  |  Branch (186:26): [True: 0, False: 0]
  |  |  |  |  |  |  ------------------
  |  |  |  |  |  |  187|      0|				 ((c) == 0x3007) || \
  |  |  |  |  |  |  ------------------
  |  |  |  |  |  |  |  Branch (187:6): [True: 0, False: 0]
  |  |  |  |  |  |  ------------------
  |  |  |  |  |  |  188|      0|				 ((0x3021 <= (c)) && ((c) <= 0x3029))))
  |  |  |  |  |  |  ------------------
  |  |  |  |  |  |  |  Branch (188:7): [True: 0, False: 0]
  |  |  |  |  |  |  |  Branch (188:26): [True: 0, False: 0]
  |  |  |  |  |  |  ------------------
  |  |  |  |  ------------------
  |  |  ------------------
  ------------------
                      if ((IS_LETTER(c)) || (IS_DIGIT(c)) ||
  ------------------
  |  |  171|      0|#define IS_DIGIT(c) xmlIsDigitQ(c)
  |  |  ------------------
  |  |  |  |  152|      0|#define xmlIsDigitQ(c)		(((c) < 0x100) ? \
  |  |  |  |  ------------------
  |  |  |  |  |  Branch (152:26): [True: 0, False: 0]
  |  |  |  |  ------------------
  |  |  |  |  153|      0|				 xmlIsDigit_ch((c)) : \
  |  |  |  |  ------------------
  |  |  |  |  |  |  144|      0|#define xmlIsDigit_ch(c)	(((0x30 <= (c)) && ((c) <= 0x39)))
  |  |  |  |  |  |  ------------------
  |  |  |  |  |  |  |  Branch (144:28): [True: 0, False: 0]
  |  |  |  |  |  |  |  Branch (144:45): [True: 0, False: 0]
  |  |  |  |  |  |  ------------------
  |  |  |  |  ------------------
  |  |  |  |  154|      0|				 xmlCharInRange((c), &xmlIsDigitGroup))
  |  |  ------------------
  ------------------
  |  Branch (3431:31): [True: 0, False: 0]
  ------------------
 3432|      0|            (c == '.') || (c == '-') ||
  ------------------
  |  Branch (3432:13): [True: 0, False: 0]
  |  Branch (3432:27): [True: 0, False: 0]
  ------------------
 3433|      0|	    (c == '_') || (c == ':') ||
  ------------------
  |  Branch (3433:6): [True: 0, False: 0]
  |  Branch (3433:20): [True: 0, False: 0]
  ------------------
 3434|      0|	    (IS_COMBINING(c)) ||
  ------------------
  |  |  189|      0|#define IS_COMBINING(c) xmlIsCombiningQ(c)
  |  |  ------------------
  |  |  |  |  132|      0|#define xmlIsCombiningQ(c)	(((c) < 0x100) ? \
  |  |  |  |  ------------------
  |  |  |  |  |  Branch (132:29): [True: 0, False: 0]
  |  |  |  |  ------------------
  |  |  |  |  133|      0|				 0 : \
  |  |  |  |  134|      0|				 xmlCharInRange((c), &xmlIsCombiningGroup))
  |  |  ------------------
  ------------------
  |  Branch (3434:6): [True: 0, False: 0]
  ------------------
 3435|      0|	    (IS_EXTENDER(c)))
  ------------------
  |  |  210|      0|#define IS_EXTENDER(c) xmlIsExtenderQ(c)
  |  |  ------------------
  |  |  |  |  172|      0|#define xmlIsExtenderQ(c)	(((c) < 0x100) ? \
  |  |  |  |  ------------------
  |  |  |  |  |  Branch (172:28): [True: 0, False: 0]
  |  |  |  |  ------------------
  |  |  |  |  173|      0|				 xmlIsExtender_ch((c)) : \
  |  |  |  |  ------------------
  |  |  |  |  |  |  164|      0|#define xmlIsExtender_ch(c)	(((c) == 0xb7))
  |  |  |  |  ------------------
  |  |  |  |  174|      0|				 xmlCharInRange((c), &xmlIsExtenderGroup))
  |  |  ------------------
  ------------------
  |  Branch (3435:6): [True: 0, False: 0]
  ------------------
 3436|      0|	    return(1);
 3437|      0|    }
 3438|  6.63k|    return(0);
 3439|  46.3k|}
valid.c:xmlValidateNamesValueInternal:
 3500|     11|xmlValidateNamesValueInternal(xmlDocPtr doc, const xmlChar *value) {
 3501|     11|    const xmlChar *cur;
 3502|     11|    int val, len;
 3503|       |
 3504|     11|    if (value == NULL) return(0);
  ------------------
  |  Branch (3504:9): [True: 0, False: 11]
  ------------------
 3505|     11|    cur = value;
 3506|     11|    val = xmlStringCurrentChar(NULL, cur, &len);
 3507|     11|    cur += len;
 3508|       |
 3509|     11|    if (!xmlIsDocNameStartChar(doc, val))
  ------------------
  |  Branch (3509:9): [True: 0, False: 11]
  ------------------
 3510|      0|	return(0);
 3511|       |
 3512|     11|    val = xmlStringCurrentChar(NULL, cur, &len);
 3513|     11|    cur += len;
 3514|     55|    while (xmlIsDocNameChar(doc, val)) {
  ------------------
  |  Branch (3514:12): [True: 44, False: 11]
  ------------------
 3515|     44|	val = xmlStringCurrentChar(NULL, cur, &len);
 3516|     44|	cur += len;
 3517|     44|    }
 3518|       |
 3519|       |    /* Should not test IS_BLANK(val) here -- see erratum E20*/
 3520|     18|    while (val == 0x20) {
  ------------------
  |  Branch (3520:12): [True: 11, False: 7]
  ------------------
 3521|     22|	while (val == 0x20) {
  ------------------
  |  Branch (3521:9): [True: 11, False: 11]
  ------------------
 3522|     11|	    val = xmlStringCurrentChar(NULL, cur, &len);
 3523|     11|	    cur += len;
 3524|     11|	}
 3525|       |
 3526|     11|	if (!xmlIsDocNameStartChar(doc, val))
  ------------------
  |  Branch (3526:6): [True: 4, False: 7]
  ------------------
 3527|      4|	    return(0);
 3528|       |
 3529|      7|	val = xmlStringCurrentChar(NULL, cur, &len);
 3530|      7|	cur += len;
 3531|       |
 3532|     42|	while (xmlIsDocNameChar(doc, val)) {
  ------------------
  |  Branch (3532:9): [True: 35, False: 7]
  ------------------
 3533|     35|	    val = xmlStringCurrentChar(NULL, cur, &len);
 3534|     35|	    cur += len;
 3535|     35|	}
 3536|      7|    }
 3537|       |
 3538|      7|    if (val != 0) return(0);
  ------------------
  |  Branch (3538:9): [True: 0, False: 7]
  ------------------
 3539|       |
 3540|      7|    return(1);
 3541|      7|}
valid.c:xmlValidateNmtokenValueInternal:
 3570|    153|xmlValidateNmtokenValueInternal(xmlDocPtr doc, const xmlChar *value) {
 3571|    153|    const xmlChar *cur;
 3572|    153|    int val, len;
 3573|       |
 3574|    153|    if (value == NULL) return(0);
  ------------------
  |  Branch (3574:9): [True: 0, False: 153]
  ------------------
 3575|    153|    cur = value;
 3576|    153|    val = xmlStringCurrentChar(NULL, cur, &len);
 3577|    153|    cur += len;
 3578|       |
 3579|    153|    if (!xmlIsDocNameChar(doc, val))
  ------------------
  |  Branch (3579:9): [True: 4, False: 149]
  ------------------
 3580|      4|	return(0);
 3581|       |
 3582|    149|    val = xmlStringCurrentChar(NULL, cur, &len);
 3583|    149|    cur += len;
 3584|    240|    while (xmlIsDocNameChar(doc, val)) {
  ------------------
  |  Branch (3584:12): [True: 91, False: 149]
  ------------------
 3585|     91|	val = xmlStringCurrentChar(NULL, cur, &len);
 3586|     91|	cur += len;
 3587|     91|    }
 3588|       |
 3589|    149|    if (val != 0) return(0);
  ------------------
  |  Branch (3589:9): [True: 4, False: 145]
  ------------------
 3590|       |
 3591|    145|    return(1);
 3592|    149|}
valid.c:xmlValidateNmtokensValueInternal:
 3623|  2.43k|xmlValidateNmtokensValueInternal(xmlDocPtr doc, const xmlChar *value) {
 3624|  2.43k|    const xmlChar *cur;
 3625|  2.43k|    int val, len;
 3626|       |
 3627|  2.43k|    if (value == NULL) return(0);
  ------------------
  |  Branch (3627:9): [True: 0, False: 2.43k]
  ------------------
 3628|  2.43k|    cur = value;
 3629|  2.43k|    val = xmlStringCurrentChar(NULL, cur, &len);
 3630|  2.43k|    cur += len;
 3631|       |
 3632|  2.43k|    while (IS_BLANK(val)) {
 3633|     15|	val = xmlStringCurrentChar(NULL, cur, &len);
 3634|     15|	cur += len;
 3635|     15|    }
 3636|       |
 3637|  2.43k|    if (!xmlIsDocNameChar(doc, val))
  ------------------
  |  Branch (3637:9): [True: 25, False: 2.41k]
  ------------------
 3638|     25|	return(0);
 3639|       |
 3640|  5.87k|    while (xmlIsDocNameChar(doc, val)) {
  ------------------
  |  Branch (3640:12): [True: 3.46k, False: 2.41k]
  ------------------
 3641|  3.46k|	val = xmlStringCurrentChar(NULL, cur, &len);
 3642|  3.46k|	cur += len;
 3643|  3.46k|    }
 3644|       |
 3645|       |    /* Should not test IS_BLANK(val) here -- see erratum E20*/
 3646|  2.46k|    while (val == 0x20) {
  ------------------
  |  Branch (3646:12): [True: 65, False: 2.40k]
  ------------------
 3647|    130|	while (val == 0x20) {
  ------------------
  |  Branch (3647:9): [True: 65, False: 65]
  ------------------
 3648|     65|	    val = xmlStringCurrentChar(NULL, cur, &len);
 3649|     65|	    cur += len;
 3650|     65|	}
 3651|     65|	if (val == 0) return(1);
  ------------------
  |  Branch (3651:6): [True: 0, False: 65]
  ------------------
 3652|       |
 3653|     65|	if (!xmlIsDocNameChar(doc, val))
  ------------------
  |  Branch (3653:6): [True: 8, False: 57]
  ------------------
 3654|      8|	    return(0);
 3655|       |
 3656|     57|	val = xmlStringCurrentChar(NULL, cur, &len);
 3657|     57|	cur += len;
 3658|       |
 3659|    167|	while (xmlIsDocNameChar(doc, val)) {
  ------------------
  |  Branch (3659:9): [True: 110, False: 57]
  ------------------
 3660|    110|	    val = xmlStringCurrentChar(NULL, cur, &len);
 3661|    110|	    cur += len;
 3662|    110|	}
 3663|     57|    }
 3664|       |
 3665|  2.40k|    if (val != 0) return(0);
  ------------------
  |  Branch (3665:9): [True: 27, False: 2.37k]
  ------------------
 3666|       |
 3667|  2.37k|    return(1);
 3668|  2.40k|}
valid.c:xmlValidateAttributeValueInternal:
 3722|  8.67k|                                  const xmlChar *value) {
 3723|  8.67k|    switch (type) {
  ------------------
  |  Branch (3723:13): [True: 0, False: 8.67k]
  ------------------
 3724|      0|	case XML_ATTRIBUTE_ENTITIES:
  ------------------
  |  Branch (3724:2): [True: 0, False: 8.67k]
  ------------------
 3725|     11|	case XML_ATTRIBUTE_IDREFS:
  ------------------
  |  Branch (3725:2): [True: 11, False: 8.66k]
  ------------------
 3726|     11|	    return(xmlValidateNamesValueInternal(doc, value));
 3727|      0|	case XML_ATTRIBUTE_ENTITY:
  ------------------
  |  Branch (3727:2): [True: 0, False: 8.67k]
  ------------------
 3728|  2.66k|	case XML_ATTRIBUTE_IDREF:
  ------------------
  |  Branch (3728:2): [True: 2.66k, False: 6.00k]
  ------------------
 3729|  3.96k|	case XML_ATTRIBUTE_ID:
  ------------------
  |  Branch (3729:2): [True: 1.30k, False: 7.37k]
  ------------------
 3730|  3.96k|	case XML_ATTRIBUTE_NOTATION:
  ------------------
  |  Branch (3730:2): [True: 0, False: 8.67k]
  ------------------
 3731|  3.96k|	    return(xmlValidateNameValueInternal(doc, value));
 3732|    133|	case XML_ATTRIBUTE_NMTOKENS:
  ------------------
  |  Branch (3732:2): [True: 133, False: 8.54k]
  ------------------
 3733|  2.43k|	case XML_ATTRIBUTE_ENUMERATION:
  ------------------
  |  Branch (3733:2): [True: 2.30k, False: 6.37k]
  ------------------
 3734|  2.43k|	    return(xmlValidateNmtokensValueInternal(doc, value));
 3735|    153|	case XML_ATTRIBUTE_NMTOKEN:
  ------------------
  |  Branch (3735:2): [True: 153, False: 8.52k]
  ------------------
 3736|    153|	    return(xmlValidateNmtokenValueInternal(doc, value));
 3737|  2.10k|        case XML_ATTRIBUTE_CDATA:
  ------------------
  |  Branch (3737:9): [True: 2.10k, False: 6.56k]
  ------------------
 3738|  2.10k|	    break;
 3739|  8.67k|    }
 3740|  2.10k|    return(1);
 3741|  8.67k|}
valid.c:xmlValidateAttributeIdCallback:
 4029|      3|	                       const xmlChar *name ATTRIBUTE_UNUSED) {
 4030|      3|    xmlAttributePtr attr = (xmlAttributePtr) payload;
 4031|      3|    int *count = (int *) data;
 4032|      3|    if (attr->atype == XML_ATTRIBUTE_ID) (*count)++;
  ------------------
  |  Branch (4032:9): [True: 3, False: 0]
  ------------------
 4033|      3|}
valid.c:xmlErrValidNodeNr:
  177|     10|{
  178|     10|    xmlStructuredErrorFunc schannel = NULL;
  179|     10|    xmlGenericErrorFunc channel = NULL;
  180|     10|    xmlParserCtxtPtr pctxt = NULL;
  181|     10|    void *data = NULL;
  182|       |
  183|     10|    if (ctxt != NULL) {
  ------------------
  |  Branch (183:9): [True: 10, False: 0]
  ------------------
  184|     10|        channel = ctxt->error;
  185|     10|        data = ctxt->userData;
  186|       |	/* Look up flag to detect if it is part of a parsing
  187|       |	   context */
  188|     10|	if (ctxt->flags & XML_VCTXT_USE_PCTXT) {
  ------------------
  |  |   18|     10|#define XML_VCTXT_USE_PCTXT (1u << 1)
  ------------------
  |  Branch (188:6): [True: 9, False: 1]
  ------------------
  189|      9|	    pctxt = ctxt->userData;
  190|      9|	}
  191|     10|    }
  192|     10|    __xmlRaiseError(schannel, channel, data, pctxt, node, XML_FROM_VALID, error,
  193|     10|                    XML_ERR_ERROR, NULL, 0,
  194|     10|                    (const char *) str1,
  195|     10|                    (const char *) str3,
  196|     10|                    NULL, int2, 0, msg, str1, int2, str3);
  197|     10|}
valid.c:xmlValidateAttributeValue2:
 3803|  5.80k|      const xmlChar *name, xmlAttributeType type, const xmlChar *value) {
 3804|  5.80k|    int ret = 1;
 3805|  5.80k|    switch (type) {
  ------------------
  |  Branch (3805:13): [True: 0, False: 5.80k]
  ------------------
 3806|      0|	case XML_ATTRIBUTE_IDREFS:
  ------------------
  |  Branch (3806:2): [True: 0, False: 5.80k]
  ------------------
 3807|  2.65k|	case XML_ATTRIBUTE_IDREF:
  ------------------
  |  Branch (3807:2): [True: 2.65k, False: 3.15k]
  ------------------
 3808|  3.95k|	case XML_ATTRIBUTE_ID:
  ------------------
  |  Branch (3808:2): [True: 1.30k, False: 4.50k]
  ------------------
 3809|  4.06k|	case XML_ATTRIBUTE_NMTOKENS:
  ------------------
  |  Branch (3809:2): [True: 112, False: 5.69k]
  ------------------
 3810|  4.17k|	case XML_ATTRIBUTE_ENUMERATION:
  ------------------
  |  Branch (3810:2): [True: 104, False: 5.70k]
  ------------------
 3811|  4.21k|	case XML_ATTRIBUTE_NMTOKEN:
  ------------------
  |  Branch (3811:2): [True: 44, False: 5.76k]
  ------------------
 3812|  5.80k|        case XML_ATTRIBUTE_CDATA:
  ------------------
  |  Branch (3812:9): [True: 1.59k, False: 4.21k]
  ------------------
 3813|  5.80k|	    break;
 3814|      0|	case XML_ATTRIBUTE_ENTITY: {
  ------------------
  |  Branch (3814:2): [True: 0, False: 5.80k]
  ------------------
 3815|      0|	    xmlEntityPtr ent;
 3816|       |
 3817|      0|	    ent = xmlGetDocEntity(doc, value);
 3818|       |	    /* yeah it's a bit messy... */
 3819|      0|	    if ((ent == NULL) && (doc->standalone == 1)) {
  ------------------
  |  Branch (3819:10): [True: 0, False: 0]
  |  Branch (3819:27): [True: 0, False: 0]
  ------------------
 3820|      0|		doc->standalone = 0;
 3821|      0|		ent = xmlGetDocEntity(doc, value);
 3822|      0|	    }
 3823|      0|	    if (ent == NULL) {
  ------------------
  |  Branch (3823:10): [True: 0, False: 0]
  ------------------
 3824|      0|		xmlErrValidNode(ctxt, (xmlNodePtr) doc,
 3825|      0|				XML_DTD_UNKNOWN_ENTITY,
 3826|      0|   "ENTITY attribute %s reference an unknown entity \"%s\"\n",
 3827|      0|		       name, value, NULL);
 3828|      0|		ret = 0;
 3829|      0|	    } else if (ent->etype != XML_EXTERNAL_GENERAL_UNPARSED_ENTITY) {
  ------------------
  |  Branch (3829:17): [True: 0, False: 0]
  ------------------
 3830|      0|		xmlErrValidNode(ctxt, (xmlNodePtr) doc,
 3831|      0|				XML_DTD_ENTITY_TYPE,
 3832|      0|   "ENTITY attribute %s reference an entity \"%s\" of wrong type\n",
 3833|      0|		       name, value, NULL);
 3834|      0|		ret = 0;
 3835|      0|	    }
 3836|      0|	    break;
 3837|  4.21k|        }
 3838|      0|	case XML_ATTRIBUTE_ENTITIES: {
  ------------------
  |  Branch (3838:2): [True: 0, False: 5.80k]
  ------------------
 3839|      0|	    xmlChar *dup, *nam = NULL, *cur, save;
 3840|      0|	    xmlEntityPtr ent;
 3841|       |
 3842|      0|	    dup = xmlStrdup(value);
 3843|      0|	    if (dup == NULL)
  ------------------
  |  Branch (3843:10): [True: 0, False: 0]
  ------------------
 3844|      0|		return(0);
 3845|      0|	    cur = dup;
 3846|      0|	    while (*cur != 0) {
  ------------------
  |  Branch (3846:13): [True: 0, False: 0]
  ------------------
 3847|      0|		nam = cur;
 3848|      0|		while ((*cur != 0) && (!IS_BLANK_CH(*cur))) cur++;
  ------------------
  |  |  151|      0|#define IS_BLANK_CH(c)  xmlIsBlank_ch(c)
  |  |  ------------------
  |  |  |  |   88|      0|#define xmlIsBlank_ch(c)	(((c) == 0x20) || \
  |  |  |  |  ------------------
  |  |  |  |  |  Branch (88:27): [True: 0, False: 0]
  |  |  |  |  ------------------
  |  |  |  |   89|      0|				 ((0x9 <= (c)) && ((c) <= 0xa)) || \
  |  |  |  |  ------------------
  |  |  |  |  |  Branch (89:7): [True: 0, False: 0]
  |  |  |  |  |  Branch (89:23): [True: 0, False: 0]
  |  |  |  |  ------------------
  |  |  |  |   90|      0|				 ((c) == 0xd))
  |  |  |  |  ------------------
  |  |  |  |  |  Branch (90:6): [True: 0, False: 0]
  |  |  |  |  ------------------
  |  |  ------------------
  ------------------
  |  Branch (3848:10): [True: 0, False: 0]
  ------------------
 3849|      0|		save = *cur;
 3850|      0|		*cur = 0;
 3851|      0|		ent = xmlGetDocEntity(doc, nam);
 3852|      0|		if (ent == NULL) {
  ------------------
  |  Branch (3852:7): [True: 0, False: 0]
  ------------------
 3853|      0|		    xmlErrValidNode(ctxt, (xmlNodePtr) doc,
 3854|      0|				    XML_DTD_UNKNOWN_ENTITY,
 3855|      0|       "ENTITIES attribute %s reference an unknown entity \"%s\"\n",
 3856|      0|			   name, nam, NULL);
 3857|      0|		    ret = 0;
 3858|      0|		} else if (ent->etype != XML_EXTERNAL_GENERAL_UNPARSED_ENTITY) {
  ------------------
  |  Branch (3858:14): [True: 0, False: 0]
  ------------------
 3859|      0|		    xmlErrValidNode(ctxt, (xmlNodePtr) doc,
 3860|      0|				    XML_DTD_ENTITY_TYPE,
 3861|      0|       "ENTITIES attribute %s reference an entity \"%s\" of wrong type\n",
 3862|      0|			   name, nam, NULL);
 3863|      0|		    ret = 0;
 3864|      0|		}
 3865|      0|		if (save == 0)
  ------------------
  |  Branch (3865:7): [True: 0, False: 0]
  ------------------
 3866|      0|		    break;
 3867|      0|		*cur = save;
 3868|      0|		while (IS_BLANK_CH(*cur)) cur++;
 3869|      0|	    }
 3870|      0|	    xmlFree(dup);
 3871|      0|	    break;
 3872|      0|	}
 3873|      0|	case XML_ATTRIBUTE_NOTATION: {
  ------------------
  |  Branch (3873:2): [True: 0, False: 5.80k]
  ------------------
 3874|      0|	    xmlNotationPtr nota;
 3875|       |
 3876|      0|	    nota = xmlGetDtdNotationDesc(doc->intSubset, value);
 3877|      0|	    if ((nota == NULL) && (doc->extSubset != NULL))
  ------------------
  |  Branch (3877:10): [True: 0, False: 0]
  |  Branch (3877:28): [True: 0, False: 0]
  ------------------
 3878|      0|		nota = xmlGetDtdNotationDesc(doc->extSubset, value);
 3879|       |
 3880|      0|	    if (nota == NULL) {
  ------------------
  |  Branch (3880:10): [True: 0, False: 0]
  ------------------
 3881|      0|		xmlErrValidNode(ctxt, (xmlNodePtr) doc,
 3882|      0|		                XML_DTD_UNKNOWN_NOTATION,
 3883|      0|       "NOTATION attribute %s reference an unknown notation \"%s\"\n",
 3884|      0|		       name, value, NULL);
 3885|      0|		ret = 0;
 3886|      0|	    }
 3887|      0|	    break;
 3888|      0|        }
 3889|  5.80k|    }
 3890|  5.80k|    return(ret);
 3891|  5.80k|}
valid.c:xmlValidateCheckMixed:
 5488|  1.28k|	              xmlElementContentPtr cont, const xmlChar *qname) {
 5489|  1.28k|    const xmlChar *name;
 5490|  1.28k|    int plen;
 5491|  1.28k|    name = xmlSplitQName3(qname, &plen);
 5492|       |
 5493|  1.28k|    if (name == NULL) {
  ------------------
  |  Branch (5493:9): [True: 1.27k, False: 8]
  ------------------
 5494|  12.5k|	while (cont != NULL) {
  ------------------
  |  Branch (5494:9): [True: 12.5k, False: 1]
  ------------------
 5495|  12.5k|	    if (cont->type == XML_ELEMENT_CONTENT_ELEMENT) {
  ------------------
  |  Branch (5495:10): [True: 4, False: 12.5k]
  ------------------
 5496|      4|		if ((cont->prefix == NULL) && (xmlStrEqual(cont->name, qname)))
  ------------------
  |  Branch (5496:7): [True: 4, False: 0]
  |  Branch (5496:33): [True: 3, False: 1]
  ------------------
 5497|      3|		    return(1);
 5498|  12.5k|	    } else if ((cont->type == XML_ELEMENT_CONTENT_OR) &&
  ------------------
  |  Branch (5498:17): [True: 12.5k, False: 0]
  ------------------
 5499|  12.5k|	       (cont->c1 != NULL) &&
  ------------------
  |  Branch (5499:9): [True: 12.5k, False: 0]
  ------------------
 5500|  12.5k|	       (cont->c1->type == XML_ELEMENT_CONTENT_ELEMENT)){
  ------------------
  |  Branch (5500:9): [True: 11.2k, False: 1.27k]
  ------------------
 5501|  11.2k|		if ((cont->c1->prefix == NULL) &&
  ------------------
  |  Branch (5501:7): [True: 11.2k, False: 1]
  ------------------
 5502|  11.2k|		    (xmlStrEqual(cont->c1->name, qname)))
  ------------------
  |  Branch (5502:7): [True: 1.27k, False: 10.0k]
  ------------------
 5503|  1.27k|		    return(1);
 5504|  11.2k|	    } else if ((cont->type != XML_ELEMENT_CONTENT_OR) ||
  ------------------
  |  Branch (5504:17): [True: 0, False: 1.27k]
  ------------------
 5505|  1.27k|		(cont->c1 == NULL) ||
  ------------------
  |  Branch (5505:3): [True: 0, False: 1.27k]
  ------------------
 5506|  1.27k|		(cont->c1->type != XML_ELEMENT_CONTENT_PCDATA)){
  ------------------
  |  Branch (5506:3): [True: 0, False: 1.27k]
  ------------------
 5507|      0|		xmlErrValid(NULL, XML_DTD_MIXED_CORRUPT,
 5508|      0|			"Internal: MIXED struct corrupted\n",
 5509|      0|			NULL);
 5510|      0|		break;
 5511|      0|	    }
 5512|  11.3k|	    cont = cont->c2;
 5513|  11.3k|	}
 5514|  1.27k|    } else {
 5515|     21|	while (cont != NULL) {
  ------------------
  |  Branch (5515:9): [True: 21, False: 0]
  ------------------
 5516|     21|	    if (cont->type == XML_ELEMENT_CONTENT_ELEMENT) {
  ------------------
  |  Branch (5516:10): [True: 5, False: 16]
  ------------------
 5517|      5|		if ((cont->prefix != NULL) &&
  ------------------
  |  Branch (5517:7): [True: 5, False: 0]
  ------------------
 5518|      5|		    (xmlStrncmp(cont->prefix, qname, plen) == 0) &&
  ------------------
  |  Branch (5518:7): [True: 5, False: 0]
  ------------------
 5519|      5|		    (xmlStrEqual(cont->name, name)))
  ------------------
  |  Branch (5519:7): [True: 5, False: 0]
  ------------------
 5520|      5|		    return(1);
 5521|     16|	    } else if ((cont->type == XML_ELEMENT_CONTENT_OR) &&
  ------------------
  |  Branch (5521:17): [True: 16, False: 0]
  ------------------
 5522|     16|	       (cont->c1 != NULL) &&
  ------------------
  |  Branch (5522:9): [True: 16, False: 0]
  ------------------
 5523|     16|	       (cont->c1->type == XML_ELEMENT_CONTENT_ELEMENT)){
  ------------------
  |  Branch (5523:9): [True: 8, False: 8]
  ------------------
 5524|      8|		if ((cont->c1->prefix != NULL) &&
  ------------------
  |  Branch (5524:7): [True: 7, False: 1]
  ------------------
 5525|      8|		    (xmlStrncmp(cont->c1->prefix, qname, plen) == 0) &&
  ------------------
  |  Branch (5525:7): [True: 7, False: 0]
  ------------------
 5526|      8|		    (xmlStrEqual(cont->c1->name, name)))
  ------------------
  |  Branch (5526:7): [True: 3, False: 4]
  ------------------
 5527|      3|		    return(1);
 5528|      8|	    } else if ((cont->type != XML_ELEMENT_CONTENT_OR) ||
  ------------------
  |  Branch (5528:17): [True: 0, False: 8]
  ------------------
 5529|      8|		(cont->c1 == NULL) ||
  ------------------
  |  Branch (5529:3): [True: 0, False: 8]
  ------------------
 5530|      8|		(cont->c1->type != XML_ELEMENT_CONTENT_PCDATA)){
  ------------------
  |  Branch (5530:3): [True: 0, False: 8]
  ------------------
 5531|      0|		xmlErrValid(ctxt, XML_DTD_MIXED_CORRUPT,
 5532|      0|			"Internal: MIXED struct corrupted\n",
 5533|      0|			NULL);
 5534|      0|		break;
 5535|      0|	    }
 5536|     13|	    cont = cont->c2;
 5537|     13|	}
 5538|      8|    }
 5539|      1|    return(0);
 5540|  1.28k|}
valid.c:xmlValidGetElemDecl:
 5557|  17.1k|	            xmlNodePtr elem, int *extsubset) {
 5558|  17.1k|    xmlElementPtr elemDecl = NULL;
 5559|  17.1k|    const xmlChar *prefix = NULL;
 5560|       |
 5561|  17.1k|    if ((ctxt == NULL) || (doc == NULL) ||
  ------------------
  |  Branch (5561:9): [True: 0, False: 17.1k]
  |  Branch (5561:27): [True: 0, False: 17.1k]
  ------------------
 5562|  17.1k|        (elem == NULL) || (elem->name == NULL))
  ------------------
  |  Branch (5562:9): [True: 0, False: 17.1k]
  |  Branch (5562:27): [True: 0, False: 17.1k]
  ------------------
 5563|      0|        return(NULL);
 5564|  17.1k|    if (extsubset != NULL)
  ------------------
  |  Branch (5564:9): [True: 17.1k, False: 0]
  ------------------
 5565|  17.1k|	*extsubset = 0;
 5566|       |
 5567|       |    /*
 5568|       |     * Fetch the declaration for the qualified name
 5569|       |     */
 5570|  17.1k|    if ((elem->ns != NULL) && (elem->ns->prefix != NULL))
  ------------------
  |  Branch (5570:9): [True: 405, False: 16.7k]
  |  Branch (5570:31): [True: 385, False: 20]
  ------------------
 5571|    385|	prefix = elem->ns->prefix;
 5572|       |
 5573|  17.1k|    if (prefix != NULL) {
  ------------------
  |  Branch (5573:9): [True: 385, False: 16.7k]
  ------------------
 5574|    385|	elemDecl = xmlGetDtdQElementDesc(doc->intSubset,
 5575|    385|		                         elem->name, prefix);
 5576|    385|	if ((elemDecl == NULL) && (doc->extSubset != NULL)) {
  ------------------
  |  Branch (5576:6): [True: 30, False: 355]
  |  Branch (5576:28): [True: 10, False: 20]
  ------------------
 5577|     10|	    elemDecl = xmlGetDtdQElementDesc(doc->extSubset,
 5578|     10|		                             elem->name, prefix);
 5579|     10|	    if ((elemDecl != NULL) && (extsubset != NULL))
  ------------------
  |  Branch (5579:10): [True: 10, False: 0]
  |  Branch (5579:32): [True: 10, False: 0]
  ------------------
 5580|     10|		*extsubset = 1;
 5581|     10|	}
 5582|    385|    }
 5583|       |
 5584|       |    /*
 5585|       |     * Fetch the declaration for the non qualified name
 5586|       |     * This is "non-strict" validation should be done on the
 5587|       |     * full QName but in that case being flexible makes sense.
 5588|       |     */
 5589|  17.1k|    if (elemDecl == NULL) {
  ------------------
  |  Branch (5589:9): [True: 16.7k, False: 365]
  ------------------
 5590|  16.7k|	elemDecl = xmlGetDtdElementDesc(doc->intSubset, elem->name);
 5591|  16.7k|	if ((elemDecl == NULL) && (doc->extSubset != NULL)) {
  ------------------
  |  Branch (5591:6): [True: 15.3k, False: 1.42k]
  |  Branch (5591:28): [True: 14.5k, False: 799]
  ------------------
 5592|  14.5k|	    elemDecl = xmlGetDtdElementDesc(doc->extSubset, elem->name);
 5593|  14.5k|	    if ((elemDecl != NULL) && (extsubset != NULL))
  ------------------
  |  Branch (5593:10): [True: 14.5k, False: 5]
  |  Branch (5593:32): [True: 14.5k, False: 0]
  ------------------
 5594|  14.5k|		*extsubset = 1;
 5595|  14.5k|	}
 5596|  16.7k|    }
 5597|  17.1k|    if (elemDecl == NULL) {
  ------------------
  |  Branch (5597:9): [True: 804, False: 16.3k]
  ------------------
 5598|    804|	xmlErrValidNode(ctxt, elem,
 5599|    804|			XML_DTD_UNKNOWN_ELEM,
 5600|    804|	       "No declaration for element %s\n",
 5601|    804|	       elem->name, NULL, NULL);
 5602|    804|    }
 5603|  17.1k|    return(elemDecl);
 5604|  17.1k|}
valid.c:vstateVPush:
  257|  3.40k|vstateVPush(xmlValidCtxtPtr ctxt, xmlElementPtr elemDecl, xmlNodePtr node) {
  258|  3.40k|    if ((ctxt->vstateMax == 0) || (ctxt->vstateTab == NULL)) {
  ------------------
  |  Branch (258:9): [True: 123, False: 3.28k]
  |  Branch (258:35): [True: 0, False: 3.28k]
  ------------------
  259|    123|	ctxt->vstateMax = 10;
  260|    123|	ctxt->vstateTab = (xmlValidState *) xmlMalloc(ctxt->vstateMax *
  261|    123|		              sizeof(ctxt->vstateTab[0]));
  262|    123|        if (ctxt->vstateTab == NULL) {
  ------------------
  |  Branch (262:13): [True: 0, False: 123]
  ------------------
  263|      0|	    xmlVErrMemory(ctxt, "malloc failed");
  264|      0|	    return(-1);
  265|      0|	}
  266|    123|    }
  267|       |
  268|  3.40k|    if (ctxt->vstateNr >= ctxt->vstateMax) {
  ------------------
  |  Branch (268:9): [True: 1, False: 3.40k]
  ------------------
  269|      1|        xmlValidState *tmp;
  270|       |
  271|      1|	tmp = (xmlValidState *) xmlRealloc(ctxt->vstateTab,
  272|      1|	             2 * ctxt->vstateMax * sizeof(ctxt->vstateTab[0]));
  273|      1|        if (tmp == NULL) {
  ------------------
  |  Branch (273:13): [True: 0, False: 1]
  ------------------
  274|      0|	    xmlVErrMemory(ctxt, "realloc failed");
  275|      0|	    return(-1);
  276|      0|	}
  277|      1|	ctxt->vstateMax *= 2;
  278|      1|	ctxt->vstateTab = tmp;
  279|      1|    }
  280|  3.40k|    ctxt->vstate = &ctxt->vstateTab[ctxt->vstateNr];
  281|  3.40k|    ctxt->vstateTab[ctxt->vstateNr].elemDecl = elemDecl;
  282|  3.40k|    ctxt->vstateTab[ctxt->vstateNr].node = node;
  283|  3.40k|    if ((elemDecl != NULL) && (elemDecl->etype == XML_ELEMENT_TYPE_ELEMENT)) {
  ------------------
  |  Branch (283:9): [True: 3.22k, False: 182]
  |  Branch (283:31): [True: 690, False: 2.53k]
  ------------------
  284|    690|	if (elemDecl->contModel == NULL)
  ------------------
  |  Branch (284:6): [True: 89, False: 601]
  ------------------
  285|     89|	    xmlValidBuildContentModel(ctxt, elemDecl);
  286|    690|	if (elemDecl->contModel != NULL) {
  ------------------
  |  Branch (286:6): [True: 690, False: 0]
  ------------------
  287|    690|	    ctxt->vstateTab[ctxt->vstateNr].exec =
  288|    690|		xmlRegNewExecCtxt(elemDecl->contModel, NULL, NULL);
  289|    690|	} else {
  290|      0|	    ctxt->vstateTab[ctxt->vstateNr].exec = NULL;
  291|      0|	    xmlErrValidNode(ctxt, (xmlNodePtr) elemDecl,
  292|      0|	                    XML_ERR_INTERNAL_ERROR,
  293|      0|			    "Failed to build content model regexp for %s\n",
  294|      0|			    node->name, NULL, NULL);
  295|      0|	}
  296|    690|    }
  297|  3.40k|    return(ctxt->vstateNr++);
  298|  3.40k|}
valid.c:vstateVPop:
  301|  3.40k|vstateVPop(xmlValidCtxtPtr ctxt) {
  302|  3.40k|    xmlElementPtr elemDecl;
  303|       |
  304|  3.40k|    if (ctxt->vstateNr < 1) return(-1);
  ------------------
  |  Branch (304:9): [True: 0, False: 3.40k]
  ------------------
  305|  3.40k|    ctxt->vstateNr--;
  306|  3.40k|    elemDecl = ctxt->vstateTab[ctxt->vstateNr].elemDecl;
  307|  3.40k|    ctxt->vstateTab[ctxt->vstateNr].elemDecl = NULL;
  308|  3.40k|    ctxt->vstateTab[ctxt->vstateNr].node = NULL;
  309|  3.40k|    if ((elemDecl != NULL) && (elemDecl->etype == XML_ELEMENT_TYPE_ELEMENT)) {
  ------------------
  |  Branch (309:9): [True: 3.22k, False: 182]
  |  Branch (309:31): [True: 690, False: 2.53k]
  ------------------
  310|    690|	xmlRegFreeExecCtxt(ctxt->vstateTab[ctxt->vstateNr].exec);
  311|    690|    }
  312|  3.40k|    ctxt->vstateTab[ctxt->vstateNr].exec = NULL;
  313|  3.40k|    if (ctxt->vstateNr >= 1)
  ------------------
  |  Branch (313:9): [True: 3.28k, False: 124]
  ------------------
  314|  3.28k|	ctxt->vstate = &ctxt->vstateTab[ctxt->vstateNr - 1];
  315|    124|    else
  316|    124|	ctxt->vstate = NULL;
  317|  3.40k|    return(ctxt->vstateNr);
  318|  3.40k|}
valid.c:xmlValidateOneCdataElement:
 5420|  3.08k|                           xmlNodePtr elem) {
 5421|  3.08k|    int ret = 1;
 5422|  3.08k|    xmlNodePtr cur, child;
 5423|       |
 5424|  3.08k|    if ((ctxt == NULL) || (doc == NULL) || (elem == NULL) ||
  ------------------
  |  Branch (5424:9): [True: 0, False: 3.08k]
  |  Branch (5424:27): [True: 0, False: 3.08k]
  |  Branch (5424:44): [True: 0, False: 3.08k]
  ------------------
 5425|  3.08k|        (elem->type != XML_ELEMENT_NODE))
  ------------------
  |  Branch (5425:9): [True: 0, False: 3.08k]
  ------------------
 5426|      0|	return(0);
 5427|       |
 5428|  3.08k|    child = elem->children;
 5429|       |
 5430|  3.08k|    cur = child;
 5431|  6.12k|    while (cur != NULL) {
  ------------------
  |  Branch (5431:12): [True: 3.03k, False: 3.08k]
  ------------------
 5432|  3.03k|	switch (cur->type) {
 5433|      0|	    case XML_ENTITY_REF_NODE:
  ------------------
  |  Branch (5433:6): [True: 0, False: 3.03k]
  ------------------
 5434|       |		/*
 5435|       |		 * Push the current node to be able to roll back
 5436|       |		 * and process within the entity
 5437|       |		 */
 5438|      0|		if ((cur->children != NULL) &&
  ------------------
  |  Branch (5438:7): [True: 0, False: 0]
  ------------------
 5439|      0|		    (cur->children->children != NULL)) {
  ------------------
  |  Branch (5439:7): [True: 0, False: 0]
  ------------------
 5440|      0|		    nodeVPush(ctxt, cur);
 5441|      0|		    cur = cur->children->children;
 5442|      0|		    continue;
 5443|      0|		}
 5444|      0|		break;
 5445|      7|	    case XML_COMMENT_NODE:
  ------------------
  |  Branch (5445:6): [True: 7, False: 3.02k]
  ------------------
 5446|     11|	    case XML_PI_NODE:
  ------------------
  |  Branch (5446:6): [True: 4, False: 3.02k]
  ------------------
 5447|  3.02k|	    case XML_TEXT_NODE:
  ------------------
  |  Branch (5447:6): [True: 3.01k, False: 15]
  ------------------
 5448|  3.03k|	    case XML_CDATA_SECTION_NODE:
  ------------------
  |  Branch (5448:6): [True: 4, False: 3.02k]
  ------------------
 5449|  3.03k|		break;
 5450|      0|	    default:
  ------------------
  |  Branch (5450:6): [True: 0, False: 3.03k]
  ------------------
 5451|      0|		ret = 0;
 5452|      0|		goto done;
 5453|  3.03k|	}
 5454|       |	/*
 5455|       |	 * Switch to next element
 5456|       |	 */
 5457|  3.03k|	cur = cur->next;
 5458|  3.03k|	while (cur == NULL) {
  ------------------
  |  Branch (5458:9): [True: 3.01k, False: 19]
  ------------------
 5459|  3.01k|	    cur = nodeVPop(ctxt);
 5460|  3.01k|	    if (cur == NULL)
  ------------------
  |  Branch (5460:10): [True: 3.01k, False: 0]
  ------------------
 5461|  3.01k|		break;
 5462|      0|	    cur = cur->next;
 5463|      0|	}
 5464|  3.03k|    }
 5465|  3.08k|done:
 5466|  3.08k|    ctxt->nodeMax = 0;
 5467|  3.08k|    ctxt->nodeNr = 0;
 5468|  3.08k|    if (ctxt->nodeTab != NULL) {
  ------------------
  |  Branch (5468:9): [True: 0, False: 3.08k]
  ------------------
 5469|      0|	xmlFree(ctxt->nodeTab);
 5470|      0|	ctxt->nodeTab = NULL;
 5471|      0|    }
 5472|  3.08k|    return(ret);
 5473|  3.08k|}
valid.c:nodeVPop:
  450|  5.07k|{
  451|  5.07k|    xmlNodePtr ret;
  452|       |
  453|  5.07k|    if (ctxt->nodeNr <= 0)
  ------------------
  |  Branch (453:9): [True: 5.07k, False: 0]
  ------------------
  454|  5.07k|        return (NULL);
  455|      0|    ctxt->nodeNr--;
  456|      0|    if (ctxt->nodeNr > 0)
  ------------------
  |  Branch (456:9): [True: 0, False: 0]
  ------------------
  457|      0|        ctxt->node = ctxt->nodeTab[ctxt->nodeNr - 1];
  458|      0|    else
  459|      0|        ctxt->node = NULL;
  460|      0|    ret = ctxt->nodeTab[ctxt->nodeNr];
  461|      0|    ctxt->nodeTab[ctxt->nodeNr] = NULL;
  462|      0|    return (ret);
  463|  5.07k|}
valid.c:xmlValidateElementContent:
 5131|  2.12k|       xmlElementPtr elemDecl, int warn, xmlNodePtr parent) {
 5132|  2.12k|    int ret = 1;
 5133|       |#ifndef  LIBXML_REGEXP_ENABLED
 5134|       |    xmlNodePtr repl = NULL, last = NULL, tmp;
 5135|       |#endif
 5136|  2.12k|    xmlNodePtr cur;
 5137|  2.12k|    xmlElementContentPtr cont;
 5138|  2.12k|    const xmlChar *name;
 5139|       |
 5140|  2.12k|    if ((elemDecl == NULL) || (parent == NULL) || (ctxt == NULL))
  ------------------
  |  Branch (5140:9): [True: 0, False: 2.12k]
  |  Branch (5140:31): [True: 0, False: 2.12k]
  |  Branch (5140:51): [True: 0, False: 2.12k]
  ------------------
 5141|      0|	return(-1);
 5142|  2.12k|    cont = elemDecl->content;
 5143|  2.12k|    name = elemDecl->name;
 5144|       |
 5145|  2.12k|#ifdef LIBXML_REGEXP_ENABLED
 5146|       |    /* Build the regexp associated to the content model */
 5147|  2.12k|    if (elemDecl->contModel == NULL)
  ------------------
  |  Branch (5147:9): [True: 504, False: 1.62k]
  ------------------
 5148|    504|	ret = xmlValidBuildContentModel(ctxt, elemDecl);
 5149|  2.12k|    if (elemDecl->contModel == NULL) {
  ------------------
  |  Branch (5149:9): [True: 0, False: 2.12k]
  ------------------
 5150|      0|	return(-1);
 5151|  2.12k|    } else {
 5152|  2.12k|	xmlRegExecCtxtPtr exec;
 5153|       |
 5154|  2.12k|	if (!xmlRegexpIsDeterminist(elemDecl->contModel)) {
  ------------------
  |  Branch (5154:6): [True: 4, False: 2.12k]
  ------------------
 5155|      4|	    return(-1);
 5156|      4|	}
 5157|  2.12k|	ctxt->nodeMax = 0;
 5158|  2.12k|	ctxt->nodeNr = 0;
 5159|  2.12k|	ctxt->nodeTab = NULL;
 5160|  2.12k|	exec = xmlRegNewExecCtxt(elemDecl->contModel, NULL, NULL);
 5161|  2.12k|	if (exec != NULL) {
  ------------------
  |  Branch (5161:6): [True: 2.12k, False: 0]
  ------------------
 5162|  2.12k|	    cur = child;
 5163|  13.8k|	    while (cur != NULL) {
  ------------------
  |  Branch (5163:13): [True: 11.6k, False: 2.12k]
  ------------------
 5164|  11.6k|		switch (cur->type) {
 5165|      0|		    case XML_ENTITY_REF_NODE:
  ------------------
  |  Branch (5165:7): [True: 0, False: 11.6k]
  ------------------
 5166|       |			/*
 5167|       |			 * Push the current node to be able to roll back
 5168|       |			 * and process within the entity
 5169|       |			 */
 5170|      0|			if ((cur->children != NULL) &&
  ------------------
  |  Branch (5170:8): [True: 0, False: 0]
  ------------------
 5171|      0|			    (cur->children->children != NULL)) {
  ------------------
  |  Branch (5171:8): [True: 0, False: 0]
  ------------------
 5172|      0|			    nodeVPush(ctxt, cur);
 5173|      0|			    cur = cur->children->children;
 5174|      0|			    continue;
 5175|      0|			}
 5176|      0|			break;
 5177|  6.10k|		    case XML_TEXT_NODE:
  ------------------
  |  Branch (5177:7): [True: 6.10k, False: 5.58k]
  ------------------
 5178|  6.10k|			if (xmlIsBlankNode(cur))
  ------------------
  |  Branch (5178:8): [True: 6.10k, False: 0]
  ------------------
 5179|  6.10k|			    break;
 5180|      0|			ret = 0;
 5181|      0|			goto fail;
 5182|      0|		    case XML_CDATA_SECTION_NODE:
  ------------------
  |  Branch (5182:7): [True: 0, False: 11.6k]
  ------------------
 5183|       |			/* TODO */
 5184|      0|			ret = 0;
 5185|      0|			goto fail;
 5186|  5.45k|		    case XML_ELEMENT_NODE:
  ------------------
  |  Branch (5186:7): [True: 5.45k, False: 6.23k]
  ------------------
 5187|  5.45k|			if ((cur->ns != NULL) && (cur->ns->prefix != NULL)) {
  ------------------
  |  Branch (5187:8): [True: 192, False: 5.26k]
  |  Branch (5187:29): [True: 192, False: 0]
  ------------------
 5188|    192|			    xmlChar fn[50];
 5189|    192|			    xmlChar *fullname;
 5190|       |
 5191|    192|			    fullname = xmlBuildQName(cur->name,
 5192|    192|				                     cur->ns->prefix, fn, 50);
 5193|    192|			    if (fullname == NULL) {
  ------------------
  |  Branch (5193:12): [True: 0, False: 192]
  ------------------
 5194|      0|				ret = -1;
 5195|      0|				goto fail;
 5196|      0|			    }
 5197|    192|                            ret = xmlRegExecPushString(exec, fullname, NULL);
 5198|    192|			    if ((fullname != fn) && (fullname != cur->name))
  ------------------
  |  Branch (5198:12): [True: 0, False: 192]
  |  Branch (5198:32): [True: 0, False: 0]
  ------------------
 5199|      0|				xmlFree(fullname);
 5200|  5.26k|			} else {
 5201|  5.26k|			    ret = xmlRegExecPushString(exec, cur->name, NULL);
 5202|  5.26k|			}
 5203|  5.45k|			break;
 5204|  5.45k|		    default:
  ------------------
  |  Branch (5204:7): [True: 129, False: 11.5k]
  ------------------
 5205|    129|			break;
 5206|  11.6k|		}
 5207|       |		/*
 5208|       |		 * Switch to next element
 5209|       |		 */
 5210|  11.6k|		cur = cur->next;
 5211|  11.6k|		while (cur == NULL) {
  ------------------
  |  Branch (5211:10): [True: 2.06k, False: 9.63k]
  ------------------
 5212|  2.06k|		    cur = nodeVPop(ctxt);
 5213|  2.06k|		    if (cur == NULL)
  ------------------
  |  Branch (5213:11): [True: 2.06k, False: 0]
  ------------------
 5214|  2.06k|			break;
 5215|      0|		    cur = cur->next;
 5216|      0|		}
 5217|  11.6k|	    }
 5218|  2.12k|	    ret = xmlRegExecPushString(exec, NULL, NULL);
 5219|  2.12k|fail:
 5220|  2.12k|	    xmlRegFreeExecCtxt(exec);
 5221|  2.12k|	}
 5222|  2.12k|    }
 5223|       |#else  /* LIBXML_REGEXP_ENABLED */
 5224|       |    /*
 5225|       |     * Allocate the stack
 5226|       |     */
 5227|       |    ctxt->vstateMax = 8;
 5228|       |    ctxt->vstateTab = (xmlValidState *) xmlMalloc(
 5229|       |		 ctxt->vstateMax * sizeof(ctxt->vstateTab[0]));
 5230|       |    if (ctxt->vstateTab == NULL) {
 5231|       |	xmlVErrMemory(ctxt, "malloc failed");
 5232|       |	return(-1);
 5233|       |    }
 5234|       |    /*
 5235|       |     * The first entry in the stack is reserved to the current state
 5236|       |     */
 5237|       |    ctxt->nodeMax = 0;
 5238|       |    ctxt->nodeNr = 0;
 5239|       |    ctxt->nodeTab = NULL;
 5240|       |    ctxt->vstate = &ctxt->vstateTab[0];
 5241|       |    ctxt->vstateNr = 1;
 5242|       |    CONT = cont;
 5243|       |    NODE = child;
 5244|       |    DEPTH = 0;
 5245|       |    OCCURS = 0;
 5246|       |    STATE = 0;
 5247|       |    ret = xmlValidateElementType(ctxt);
 5248|       |    if ((ret == -3) && (warn)) {
 5249|       |	char expr[5000];
 5250|       |	expr[0] = 0;
 5251|       |	xmlSnprintfElementContent(expr, 5000, elemDecl->content, 1);
 5252|       |	xmlErrValidNode(ctxt, (xmlNodePtr) elemDecl,
 5253|       |                XML_DTD_CONTENT_NOT_DETERMINIST,
 5254|       |	        "Content model of %s is not deterministic: %s\n",
 5255|       |	        name, BAD_CAST expr, NULL);
 5256|       |    } else if (ret == -2) {
 5257|       |	/*
 5258|       |	 * An entities reference appeared at this level.
 5259|       |	 * Build a minimal representation of this node content
 5260|       |	 * sufficient to run the validation process on it
 5261|       |	 */
 5262|       |	cur = child;
 5263|       |	while (cur != NULL) {
 5264|       |	    switch (cur->type) {
 5265|       |		case XML_ENTITY_REF_NODE:
 5266|       |		    /*
 5267|       |		     * Push the current node to be able to roll back
 5268|       |		     * and process within the entity
 5269|       |		     */
 5270|       |		    if ((cur->children != NULL) &&
 5271|       |			(cur->children->children != NULL)) {
 5272|       |			nodeVPush(ctxt, cur);
 5273|       |			cur = cur->children->children;
 5274|       |			continue;
 5275|       |		    }
 5276|       |		    break;
 5277|       |		case XML_TEXT_NODE:
 5278|       |		    if (xmlIsBlankNode(cur))
 5279|       |			break;
 5280|       |		    /* no break on purpose */
 5281|       |		case XML_CDATA_SECTION_NODE:
 5282|       |		    /* no break on purpose */
 5283|       |		case XML_ELEMENT_NODE:
 5284|       |		    /*
 5285|       |		     * Allocate a new node and minimally fills in
 5286|       |		     * what's required
 5287|       |		     */
 5288|       |		    tmp = (xmlNodePtr) xmlMalloc(sizeof(xmlNode));
 5289|       |		    if (tmp == NULL) {
 5290|       |			xmlVErrMemory(ctxt, "malloc failed");
 5291|       |			xmlFreeNodeList(repl);
 5292|       |			ret = -1;
 5293|       |			goto done;
 5294|       |		    }
 5295|       |		    tmp->type = cur->type;
 5296|       |		    tmp->name = cur->name;
 5297|       |		    tmp->ns = cur->ns;
 5298|       |		    tmp->next = NULL;
 5299|       |		    tmp->content = NULL;
 5300|       |		    if (repl == NULL)
 5301|       |			repl = last = tmp;
 5302|       |		    else {
 5303|       |			last->next = tmp;
 5304|       |			last = tmp;
 5305|       |		    }
 5306|       |		    if (cur->type == XML_CDATA_SECTION_NODE) {
 5307|       |			/*
 5308|       |			 * E59 spaces in CDATA does not match the
 5309|       |			 * nonterminal S
 5310|       |			 */
 5311|       |			tmp->content = xmlStrdup(BAD_CAST "CDATA");
 5312|       |		    }
 5313|       |		    break;
 5314|       |		default:
 5315|       |		    break;
 5316|       |	    }
 5317|       |	    /*
 5318|       |	     * Switch to next element
 5319|       |	     */
 5320|       |	    cur = cur->next;
 5321|       |	    while (cur == NULL) {
 5322|       |		cur = nodeVPop(ctxt);
 5323|       |		if (cur == NULL)
 5324|       |		    break;
 5325|       |		cur = cur->next;
 5326|       |	    }
 5327|       |	}
 5328|       |
 5329|       |	/*
 5330|       |	 * Relaunch the validation
 5331|       |	 */
 5332|       |	ctxt->vstate = &ctxt->vstateTab[0];
 5333|       |	ctxt->vstateNr = 1;
 5334|       |	CONT = cont;
 5335|       |	NODE = repl;
 5336|       |	DEPTH = 0;
 5337|       |	OCCURS = 0;
 5338|       |	STATE = 0;
 5339|       |	ret = xmlValidateElementType(ctxt);
 5340|       |    }
 5341|       |#endif /* LIBXML_REGEXP_ENABLED */
 5342|  2.12k|    if ((warn) && ((ret != 1) && (ret != -3))) {
  ------------------
  |  Branch (5342:9): [True: 2.12k, False: 0]
  |  Branch (5342:20): [True: 20, False: 2.10k]
  |  Branch (5342:34): [True: 20, False: 0]
  ------------------
 5343|     20|	if (ctxt != NULL) {
  ------------------
  |  Branch (5343:6): [True: 20, False: 0]
  ------------------
 5344|     20|	    char expr[5000];
 5345|     20|	    char list[5000];
 5346|       |
 5347|     20|	    expr[0] = 0;
 5348|     20|	    xmlSnprintfElementContent(&expr[0], 5000, cont, 1);
 5349|     20|	    list[0] = 0;
 5350|       |#ifndef LIBXML_REGEXP_ENABLED
 5351|       |	    if (repl != NULL)
 5352|       |		xmlSnprintfElements(&list[0], 5000, repl, 1);
 5353|       |	    else
 5354|       |#endif /* LIBXML_REGEXP_ENABLED */
 5355|     20|		xmlSnprintfElements(&list[0], 5000, child, 1);
 5356|       |
 5357|     20|	    if (name != NULL) {
  ------------------
  |  Branch (5357:10): [True: 20, False: 0]
  ------------------
 5358|     20|		xmlErrValidNode(ctxt, parent, XML_DTD_CONTENT_MODEL,
 5359|     20|	   "Element %s content does not follow the DTD, expecting %s, got %s\n",
 5360|     20|		       name, BAD_CAST expr, BAD_CAST list);
  ------------------
  |  |   35|     20|#define BAD_CAST (xmlChar *)
  ------------------
              		       name, BAD_CAST expr, BAD_CAST list);
  ------------------
  |  |   35|     20|#define BAD_CAST (xmlChar *)
  ------------------
 5361|     20|	    } else {
 5362|      0|		xmlErrValidNode(ctxt, parent, XML_DTD_CONTENT_MODEL,
 5363|      0|	   "Element content does not follow the DTD, expecting %s, got %s\n",
 5364|      0|		       BAD_CAST expr, BAD_CAST list, NULL);
  ------------------
  |  |   35|      0|#define BAD_CAST (xmlChar *)
  ------------------
              		       BAD_CAST expr, BAD_CAST list, NULL);
  ------------------
  |  |   35|      0|#define BAD_CAST (xmlChar *)
  ------------------
 5365|      0|	    }
 5366|     20|	} else {
 5367|      0|	    if (name != NULL) {
  ------------------
  |  Branch (5367:10): [True: 0, False: 0]
  ------------------
 5368|      0|		xmlErrValidNode(ctxt, parent, XML_DTD_CONTENT_MODEL,
 5369|      0|		       "Element %s content does not follow the DTD\n",
 5370|      0|		       name, NULL, NULL);
 5371|      0|	    } else {
 5372|      0|		xmlErrValidNode(ctxt, parent, XML_DTD_CONTENT_MODEL,
 5373|      0|		       "Element content does not follow the DTD\n",
 5374|      0|		                NULL, NULL, NULL);
 5375|      0|	    }
 5376|      0|	}
 5377|     20|	ret = 0;
 5378|     20|    }
 5379|  2.12k|    if (ret == -3)
  ------------------
  |  Branch (5379:9): [True: 0, False: 2.12k]
  ------------------
 5380|      0|	ret = 1;
 5381|       |
 5382|       |#ifndef  LIBXML_REGEXP_ENABLED
 5383|       |done:
 5384|       |    /*
 5385|       |     * Deallocate the copy if done, and free up the validation stack
 5386|       |     */
 5387|       |    while (repl != NULL) {
 5388|       |	tmp = repl->next;
 5389|       |	xmlFree(repl);
 5390|       |	repl = tmp;
 5391|       |    }
 5392|       |    ctxt->vstateMax = 0;
 5393|       |    if (ctxt->vstateTab != NULL) {
 5394|       |	xmlFree(ctxt->vstateTab);
 5395|       |	ctxt->vstateTab = NULL;
 5396|       |    }
 5397|       |#endif
 5398|  2.12k|    ctxt->nodeMax = 0;
 5399|  2.12k|    ctxt->nodeNr = 0;
 5400|  2.12k|    if (ctxt->nodeTab != NULL) {
  ------------------
  |  Branch (5400:9): [True: 0, False: 2.12k]
  ------------------
 5401|      0|	xmlFree(ctxt->nodeTab);
 5402|      0|	ctxt->nodeTab = NULL;
 5403|      0|    }
 5404|  2.12k|    return(ret);
 5405|       |
 5406|  2.12k|}
valid.c:xmlSnprintfElements:
 5045|     20|xmlSnprintfElements(char *buf, int size, xmlNodePtr node, int glob) {
 5046|     20|    xmlNodePtr cur;
 5047|     20|    int len;
 5048|       |
 5049|     20|    if (node == NULL) return;
  ------------------
  |  Branch (5049:9): [True: 4, False: 16]
  ------------------
 5050|     16|    if (glob) strcat(buf, "(");
  ------------------
  |  Branch (5050:9): [True: 16, False: 0]
  ------------------
 5051|     16|    cur = node;
 5052|     68|    while (cur != NULL) {
  ------------------
  |  Branch (5052:12): [True: 52, False: 16]
  ------------------
 5053|     52|	len = strlen(buf);
 5054|     52|	if (size - len < 50) {
  ------------------
  |  Branch (5054:6): [True: 0, False: 52]
  ------------------
 5055|      0|	    if ((size - len > 4) && (buf[len - 1] != '.'))
  ------------------
  |  Branch (5055:10): [True: 0, False: 0]
  |  Branch (5055:30): [True: 0, False: 0]
  ------------------
 5056|      0|		strcat(buf, " ...");
 5057|      0|	    return;
 5058|      0|	}
 5059|     52|        switch (cur->type) {
  ------------------
  |  Branch (5059:17): [True: 0, False: 52]
  ------------------
 5060|     48|            case XML_ELEMENT_NODE:
  ------------------
  |  Branch (5060:13): [True: 48, False: 4]
  ------------------
 5061|     48|		if ((cur->ns != NULL) && (cur->ns->prefix != NULL)) {
  ------------------
  |  Branch (5061:7): [True: 0, False: 48]
  |  Branch (5061:28): [True: 0, False: 0]
  ------------------
 5062|      0|		    if (size - len < xmlStrlen(cur->ns->prefix) + 10) {
  ------------------
  |  Branch (5062:11): [True: 0, False: 0]
  ------------------
 5063|      0|			if ((size - len > 4) && (buf[len - 1] != '.'))
  ------------------
  |  Branch (5063:8): [True: 0, False: 0]
  |  Branch (5063:28): [True: 0, False: 0]
  ------------------
 5064|      0|			    strcat(buf, " ...");
 5065|      0|			return;
 5066|      0|		    }
 5067|      0|		    strcat(buf, (char *) cur->ns->prefix);
 5068|      0|		    strcat(buf, ":");
 5069|      0|		}
 5070|     48|                if (size - len < xmlStrlen(cur->name) + 10) {
  ------------------
  |  Branch (5070:21): [True: 0, False: 48]
  ------------------
 5071|      0|		    if ((size - len > 4) && (buf[len - 1] != '.'))
  ------------------
  |  Branch (5071:11): [True: 0, False: 0]
  |  Branch (5071:31): [True: 0, False: 0]
  ------------------
 5072|      0|			strcat(buf, " ...");
 5073|      0|		    return;
 5074|      0|		}
 5075|     48|	        strcat(buf, (char *) cur->name);
 5076|     48|		if (cur->next != NULL)
  ------------------
  |  Branch (5076:7): [True: 36, False: 12]
  ------------------
 5077|     36|		    strcat(buf, " ");
 5078|     48|		break;
 5079|      4|            case XML_TEXT_NODE:
  ------------------
  |  Branch (5079:13): [True: 4, False: 48]
  ------------------
 5080|      4|		if (xmlIsBlankNode(cur))
  ------------------
  |  Branch (5080:7): [True: 4, False: 0]
  ------------------
 5081|      4|		    break;
 5082|       |                /* Falls through. */
 5083|      0|            case XML_CDATA_SECTION_NODE:
  ------------------
  |  Branch (5083:13): [True: 0, False: 52]
  ------------------
 5084|      0|            case XML_ENTITY_REF_NODE:
  ------------------
  |  Branch (5084:13): [True: 0, False: 52]
  ------------------
 5085|      0|	        strcat(buf, "CDATA");
 5086|      0|		if (cur->next != NULL)
  ------------------
  |  Branch (5086:7): [True: 0, False: 0]
  ------------------
 5087|      0|		    strcat(buf, " ");
 5088|      0|		break;
 5089|      0|            case XML_ATTRIBUTE_NODE:
  ------------------
  |  Branch (5089:13): [True: 0, False: 52]
  ------------------
 5090|      0|            case XML_DOCUMENT_NODE:
  ------------------
  |  Branch (5090:13): [True: 0, False: 52]
  ------------------
 5091|      0|	    case XML_HTML_DOCUMENT_NODE:
  ------------------
  |  Branch (5091:6): [True: 0, False: 52]
  ------------------
 5092|      0|            case XML_DOCUMENT_TYPE_NODE:
  ------------------
  |  Branch (5092:13): [True: 0, False: 52]
  ------------------
 5093|      0|            case XML_DOCUMENT_FRAG_NODE:
  ------------------
  |  Branch (5093:13): [True: 0, False: 52]
  ------------------
 5094|      0|            case XML_NOTATION_NODE:
  ------------------
  |  Branch (5094:13): [True: 0, False: 52]
  ------------------
 5095|      0|	    case XML_NAMESPACE_DECL:
  ------------------
  |  Branch (5095:6): [True: 0, False: 52]
  ------------------
 5096|      0|	        strcat(buf, "???");
 5097|      0|		if (cur->next != NULL)
  ------------------
  |  Branch (5097:7): [True: 0, False: 0]
  ------------------
 5098|      0|		    strcat(buf, " ");
 5099|      0|		break;
 5100|      0|            case XML_ENTITY_NODE:
  ------------------
  |  Branch (5100:13): [True: 0, False: 52]
  ------------------
 5101|      0|            case XML_PI_NODE:
  ------------------
  |  Branch (5101:13): [True: 0, False: 52]
  ------------------
 5102|      0|            case XML_DTD_NODE:
  ------------------
  |  Branch (5102:13): [True: 0, False: 52]
  ------------------
 5103|      0|            case XML_COMMENT_NODE:
  ------------------
  |  Branch (5103:13): [True: 0, False: 52]
  ------------------
 5104|      0|	    case XML_ELEMENT_DECL:
  ------------------
  |  Branch (5104:6): [True: 0, False: 52]
  ------------------
 5105|      0|	    case XML_ATTRIBUTE_DECL:
  ------------------
  |  Branch (5105:6): [True: 0, False: 52]
  ------------------
 5106|      0|	    case XML_ENTITY_DECL:
  ------------------
  |  Branch (5106:6): [True: 0, False: 52]
  ------------------
 5107|      0|	    case XML_XINCLUDE_START:
  ------------------
  |  Branch (5107:6): [True: 0, False: 52]
  ------------------
 5108|      0|	    case XML_XINCLUDE_END:
  ------------------
  |  Branch (5108:6): [True: 0, False: 52]
  ------------------
 5109|      0|		break;
 5110|     52|	}
 5111|     52|	cur = cur->next;
 5112|     52|    }
 5113|     16|    if (glob) strcat(buf, ")");
  ------------------
  |  Branch (5113:9): [True: 16, False: 0]
  ------------------
 5114|     16|}
valid.c:xmlValidateCheckRefCallback:
 6439|    880|xmlValidateCheckRefCallback(void *payload, void *data, const xmlChar *name) {
 6440|    880|    xmlListPtr ref_list = (xmlListPtr) payload;
 6441|    880|    xmlValidCtxtPtr ctxt = (xmlValidCtxtPtr) data;
 6442|    880|    xmlValidateMemo memo;
 6443|       |
 6444|    880|    if (ref_list == NULL)
  ------------------
  |  Branch (6444:9): [True: 0, False: 880]
  ------------------
 6445|      0|	return;
 6446|    880|    memo.ctxt = ctxt;
 6447|    880|    memo.name = name;
 6448|       |
 6449|    880|    xmlListWalk(ref_list, xmlWalkValidateList, &memo);
 6450|       |
 6451|    880|}
valid.c:xmlWalkValidateList:
 6425|  2.65k|{
 6426|  2.65k|	xmlValidateMemoPtr memo = (xmlValidateMemoPtr)user;
 6427|  2.65k|	xmlValidateRef((xmlRefPtr)data, memo->ctxt, memo->name);
 6428|  2.65k|	return 1;
 6429|  2.65k|}
valid.c:xmlValidateRef:
 6341|  2.65k|	                   const xmlChar *name) {
 6342|  2.65k|    xmlAttrPtr id;
 6343|  2.65k|    xmlAttrPtr attr;
 6344|       |
 6345|  2.65k|    if (ref == NULL)
  ------------------
  |  Branch (6345:9): [True: 0, False: 2.65k]
  ------------------
 6346|      0|	return;
 6347|  2.65k|    if ((ref->attr == NULL) && (ref->name == NULL))
  ------------------
  |  Branch (6347:9): [True: 664, False: 1.99k]
  |  Branch (6347:32): [True: 0, False: 664]
  ------------------
 6348|      0|	return;
 6349|  2.65k|    attr = ref->attr;
 6350|  2.65k|    if (attr == NULL) {
  ------------------
  |  Branch (6350:9): [True: 664, False: 1.99k]
  ------------------
 6351|    664|	xmlChar *dup, *str = NULL, *cur, save;
 6352|       |
 6353|    664|	dup = xmlStrdup(name);
 6354|    664|	if (dup == NULL) {
  ------------------
  |  Branch (6354:6): [True: 0, False: 664]
  ------------------
 6355|      0|	    ctxt->valid = 0;
 6356|      0|	    return;
 6357|      0|	}
 6358|    664|	cur = dup;
 6359|    664|	while (*cur != 0) {
  ------------------
  |  Branch (6359:9): [True: 664, False: 0]
  ------------------
 6360|    664|	    str = cur;
 6361|  6.61k|	    while ((*cur != 0) && (!IS_BLANK_CH(*cur))) cur++;
  ------------------
  |  |  151|  5.95k|#define IS_BLANK_CH(c)  xmlIsBlank_ch(c)
  |  |  ------------------
  |  |  |  |   88|  5.95k|#define xmlIsBlank_ch(c)	(((c) == 0x20) || \
  |  |  |  |  ------------------
  |  |  |  |  |  Branch (88:27): [True: 0, False: 5.95k]
  |  |  |  |  ------------------
  |  |  |  |   89|  5.95k|				 ((0x9 <= (c)) && ((c) <= 0xa)) || \
  |  |  |  |  ------------------
  |  |  |  |  |  Branch (89:7): [True: 5.95k, False: 0]
  |  |  |  |  |  Branch (89:23): [True: 0, False: 5.95k]
  |  |  |  |  ------------------
  |  |  |  |   90|  5.95k|				 ((c) == 0xd))
  |  |  |  |  ------------------
  |  |  |  |  |  Branch (90:6): [True: 0, False: 5.95k]
  |  |  |  |  ------------------
  |  |  ------------------
  ------------------
  |  Branch (6361:13): [True: 5.95k, False: 664]
  ------------------
 6362|    664|	    save = *cur;
 6363|    664|	    *cur = 0;
 6364|    664|	    id = xmlGetID(ctxt->doc, str);
 6365|    664|	    if (id == NULL) {
  ------------------
  |  Branch (6365:10): [True: 1, False: 663]
  ------------------
 6366|      1|		xmlErrValidNodeNr(ctxt, NULL, XML_DTD_UNKNOWN_ID,
 6367|      1|	   "attribute %s line %d references an unknown ID \"%s\"\n",
 6368|      1|		       ref->name, ref->lineno, str);
 6369|      1|		ctxt->valid = 0;
 6370|      1|	    }
 6371|    664|	    if (save == 0)
  ------------------
  |  Branch (6371:10): [True: 664, False: 0]
  ------------------
 6372|    664|		break;
 6373|      0|	    *cur = save;
 6374|      0|	    while (IS_BLANK_CH(*cur)) cur++;
 6375|      0|	}
 6376|    664|	xmlFree(dup);
 6377|  1.99k|    } else if (attr->atype == XML_ATTRIBUTE_IDREF) {
  ------------------
  |  Branch (6377:16): [True: 1.99k, False: 0]
  ------------------
 6378|  1.99k|	id = xmlGetID(ctxt->doc, name);
 6379|  1.99k|	if (id == NULL) {
  ------------------
  |  Branch (6379:6): [True: 3, False: 1.98k]
  ------------------
 6380|      3|	    xmlErrValidNode(ctxt, attr->parent, XML_DTD_UNKNOWN_ID,
 6381|      3|	   "IDREF attribute %s references an unknown ID \"%s\"\n",
 6382|      3|		   attr->name, name, NULL);
 6383|      3|	    ctxt->valid = 0;
 6384|      3|	}
 6385|  1.99k|    } else if (attr->atype == XML_ATTRIBUTE_IDREFS) {
  ------------------
  |  Branch (6385:16): [True: 0, False: 0]
  ------------------
 6386|      0|	xmlChar *dup, *str = NULL, *cur, save;
 6387|       |
 6388|      0|	dup = xmlStrdup(name);
 6389|      0|	if (dup == NULL) {
  ------------------
  |  Branch (6389:6): [True: 0, False: 0]
  ------------------
 6390|      0|	    xmlVErrMemory(ctxt, "IDREFS split");
 6391|      0|	    ctxt->valid = 0;
 6392|      0|	    return;
 6393|      0|	}
 6394|      0|	cur = dup;
 6395|      0|	while (*cur != 0) {
  ------------------
  |  Branch (6395:9): [True: 0, False: 0]
  ------------------
 6396|      0|	    str = cur;
 6397|      0|	    while ((*cur != 0) && (!IS_BLANK_CH(*cur))) cur++;
  ------------------
  |  |  151|      0|#define IS_BLANK_CH(c)  xmlIsBlank_ch(c)
  |  |  ------------------
  |  |  |  |   88|      0|#define xmlIsBlank_ch(c)	(((c) == 0x20) || \
  |  |  |  |  ------------------
  |  |  |  |  |  Branch (88:27): [True: 0, False: 0]
  |  |  |  |  ------------------
  |  |  |  |   89|      0|				 ((0x9 <= (c)) && ((c) <= 0xa)) || \
  |  |  |  |  ------------------
  |  |  |  |  |  Branch (89:7): [True: 0, False: 0]
  |  |  |  |  |  Branch (89:23): [True: 0, False: 0]
  |  |  |  |  ------------------
  |  |  |  |   90|      0|				 ((c) == 0xd))
  |  |  |  |  ------------------
  |  |  |  |  |  Branch (90:6): [True: 0, False: 0]
  |  |  |  |  ------------------
  |  |  ------------------
  ------------------
  |  Branch (6397:13): [True: 0, False: 0]
  ------------------
 6398|      0|	    save = *cur;
 6399|      0|	    *cur = 0;
 6400|      0|	    id = xmlGetID(ctxt->doc, str);
 6401|      0|	    if (id == NULL) {
  ------------------
  |  Branch (6401:10): [True: 0, False: 0]
  ------------------
 6402|      0|		xmlErrValidNode(ctxt, attr->parent, XML_DTD_UNKNOWN_ID,
 6403|      0|	   "IDREFS attribute %s references an unknown ID \"%s\"\n",
 6404|      0|			     attr->name, str, NULL);
 6405|      0|		ctxt->valid = 0;
 6406|      0|	    }
 6407|      0|	    if (save == 0)
  ------------------
  |  Branch (6407:10): [True: 0, False: 0]
  ------------------
 6408|      0|		break;
 6409|      0|	    *cur = save;
 6410|      0|	    while (IS_BLANK_CH(*cur)) cur++;
 6411|      0|	}
 6412|      0|	xmlFree(dup);
 6413|      0|    }
 6414|  2.65k|}
valid.c:xmlValidateAttributeCallback:
 6576|  7.47k|	                     const xmlChar *name ATTRIBUTE_UNUSED) {
 6577|  7.47k|    xmlAttributePtr cur = (xmlAttributePtr) payload;
 6578|  7.47k|    xmlValidCtxtPtr ctxt = (xmlValidCtxtPtr) data;
 6579|  7.47k|    int ret;
 6580|  7.47k|    xmlDocPtr doc;
 6581|  7.47k|    xmlElementPtr elem = NULL;
 6582|       |
 6583|  7.47k|    if (cur == NULL)
  ------------------
  |  Branch (6583:9): [True: 0, False: 7.47k]
  ------------------
 6584|      0|	return;
 6585|  7.47k|    switch (cur->atype) {
  ------------------
  |  Branch (6585:13): [True: 0, False: 7.47k]
  ------------------
 6586|  2.99k|	case XML_ATTRIBUTE_CDATA:
  ------------------
  |  Branch (6586:2): [True: 2.99k, False: 4.47k]
  ------------------
 6587|  4.72k|	case XML_ATTRIBUTE_ID:
  ------------------
  |  Branch (6587:2): [True: 1.72k, False: 5.74k]
  ------------------
 6588|  4.80k|	case XML_ATTRIBUTE_IDREF	:
  ------------------
  |  Branch (6588:2): [True: 88, False: 7.38k]
  ------------------
 6589|  4.82k|	case XML_ATTRIBUTE_IDREFS:
  ------------------
  |  Branch (6589:2): [True: 16, False: 7.45k]
  ------------------
 6590|  5.87k|	case XML_ATTRIBUTE_NMTOKEN:
  ------------------
  |  Branch (6590:2): [True: 1.05k, False: 6.42k]
  ------------------
 6591|  6.07k|	case XML_ATTRIBUTE_NMTOKENS:
  ------------------
  |  Branch (6591:2): [True: 196, False: 7.27k]
  ------------------
 6592|  7.46k|	case XML_ATTRIBUTE_ENUMERATION:
  ------------------
  |  Branch (6592:2): [True: 1.38k, False: 6.08k]
  ------------------
 6593|  7.46k|	    break;
 6594|     12|	case XML_ATTRIBUTE_ENTITY:
  ------------------
  |  Branch (6594:2): [True: 12, False: 7.46k]
  ------------------
 6595|     12|	case XML_ATTRIBUTE_ENTITIES:
  ------------------
  |  Branch (6595:2): [True: 0, False: 7.47k]
  ------------------
 6596|     12|	case XML_ATTRIBUTE_NOTATION:
  ------------------
  |  Branch (6596:2): [True: 0, False: 7.47k]
  ------------------
 6597|     12|	    if (cur->defaultValue != NULL) {
  ------------------
  |  Branch (6597:10): [True: 0, False: 12]
  ------------------
 6598|       |
 6599|      0|		ret = xmlValidateAttributeValue2(ctxt, ctxt->doc, cur->name,
 6600|      0|			                         cur->atype, cur->defaultValue);
 6601|      0|		if ((ret == 0) && (ctxt->valid == 1))
  ------------------
  |  Branch (6601:7): [True: 0, False: 0]
  |  Branch (6601:21): [True: 0, False: 0]
  ------------------
 6602|      0|		    ctxt->valid = 0;
 6603|      0|	    }
 6604|     12|	    if (cur->tree != NULL) {
  ------------------
  |  Branch (6604:10): [True: 0, False: 12]
  ------------------
 6605|      0|		xmlEnumerationPtr tree = cur->tree;
 6606|      0|		while (tree != NULL) {
  ------------------
  |  Branch (6606:10): [True: 0, False: 0]
  ------------------
 6607|      0|		    ret = xmlValidateAttributeValue2(ctxt, ctxt->doc,
 6608|      0|				    cur->name, cur->atype, tree->name);
 6609|      0|		    if ((ret == 0) && (ctxt->valid == 1))
  ------------------
  |  Branch (6609:11): [True: 0, False: 0]
  |  Branch (6609:25): [True: 0, False: 0]
  ------------------
 6610|      0|			ctxt->valid = 0;
 6611|      0|		    tree = tree->next;
 6612|      0|		}
 6613|      0|	    }
 6614|  7.47k|    }
 6615|  7.47k|    if (cur->atype == XML_ATTRIBUTE_NOTATION) {
  ------------------
  |  Branch (6615:9): [True: 0, False: 7.47k]
  ------------------
 6616|      0|	doc = cur->doc;
 6617|      0|	if (cur->elem == NULL) {
  ------------------
  |  Branch (6617:6): [True: 0, False: 0]
  ------------------
 6618|      0|	    xmlErrValid(ctxt, XML_ERR_INTERNAL_ERROR,
 6619|      0|		   "xmlValidateAttributeCallback(%s): internal error\n",
 6620|      0|		   (const char *) cur->name);
 6621|      0|	    return;
 6622|      0|	}
 6623|       |
 6624|      0|	if (doc != NULL)
  ------------------
  |  Branch (6624:6): [True: 0, False: 0]
  ------------------
 6625|      0|	    elem = xmlGetDtdElementDesc(doc->intSubset, cur->elem);
 6626|      0|	if ((elem == NULL) && (doc != NULL))
  ------------------
  |  Branch (6626:6): [True: 0, False: 0]
  |  Branch (6626:24): [True: 0, False: 0]
  ------------------
 6627|      0|	    elem = xmlGetDtdElementDesc(doc->extSubset, cur->elem);
 6628|      0|	if ((elem == NULL) && (cur->parent != NULL) &&
  ------------------
  |  Branch (6628:6): [True: 0, False: 0]
  |  Branch (6628:24): [True: 0, False: 0]
  ------------------
 6629|      0|	    (cur->parent->type == XML_DTD_NODE))
  ------------------
  |  Branch (6629:6): [True: 0, False: 0]
  ------------------
 6630|      0|	    elem = xmlGetDtdElementDesc((xmlDtdPtr) cur->parent, cur->elem);
 6631|      0|	if (elem == NULL) {
  ------------------
  |  Branch (6631:6): [True: 0, False: 0]
  ------------------
 6632|      0|	    xmlErrValidNode(ctxt, NULL, XML_DTD_UNKNOWN_ELEM,
 6633|      0|		   "attribute %s: could not find decl for element %s\n",
 6634|      0|		   cur->name, cur->elem, NULL);
 6635|      0|	    return;
 6636|      0|	}
 6637|      0|	if (elem->etype == XML_ELEMENT_TYPE_EMPTY) {
  ------------------
  |  Branch (6637:6): [True: 0, False: 0]
  ------------------
 6638|      0|	    xmlErrValidNode(ctxt, NULL, XML_DTD_EMPTY_NOTATION,
 6639|      0|		   "NOTATION attribute %s declared for EMPTY element %s\n",
 6640|      0|		   cur->name, cur->elem, NULL);
 6641|      0|	    ctxt->valid = 0;
 6642|      0|	}
 6643|      0|    }
 6644|  7.47k|}
valid.c:xmlValidateNotationCallback:
 6555|  1.07k|	                    const xmlChar *name ATTRIBUTE_UNUSED) {
 6556|  1.07k|    xmlEntityPtr cur = (xmlEntityPtr) payload;
 6557|  1.07k|    xmlValidCtxtPtr ctxt = (xmlValidCtxtPtr) data;
 6558|  1.07k|    if (cur == NULL)
  ------------------
  |  Branch (6558:9): [True: 0, False: 1.07k]
  ------------------
 6559|      0|	return;
 6560|  1.07k|    if (cur->etype == XML_EXTERNAL_GENERAL_UNPARSED_ENTITY) {
  ------------------
  |  Branch (6560:9): [True: 3, False: 1.06k]
  ------------------
 6561|      3|	xmlChar *notation = cur->content;
 6562|       |
 6563|      3|	if (notation != NULL) {
  ------------------
  |  Branch (6563:6): [True: 3, False: 0]
  ------------------
 6564|      3|	    int ret;
 6565|       |
 6566|      3|	    ret = xmlValidateNotationUse(ctxt, cur->doc, notation);
 6567|      3|	    if (ret != 1) {
  ------------------
  |  Branch (6567:10): [True: 3, False: 0]
  ------------------
 6568|      3|		ctxt->valid = 0;
 6569|      3|	    }
 6570|      3|	}
 6571|      3|    }
 6572|  1.07k|}

xmlCheckFilename:
  679|  13.5k|{
  680|  13.5k|#ifdef HAVE_STAT
  681|       |#if defined(_WIN32)
  682|       |    struct _stat stat_buffer;
  683|       |#else
  684|  13.5k|    struct stat stat_buffer;
  685|  13.5k|#endif
  686|  13.5k|#endif
  687|  13.5k|    if (path == NULL)
  ------------------
  |  Branch (687:9): [True: 0, False: 13.5k]
  ------------------
  688|      0|	return(0);
  689|       |
  690|  13.5k|#ifdef HAVE_STAT
  691|       |#if defined(_WIN32)
  692|       |    /*
  693|       |     * On Windows stat and wstat do not work with long pathname,
  694|       |     * which start with '\\?\'
  695|       |     */
  696|       |    if ((path[0] == '\\') && (path[1] == '\\') && (path[2] == '?') &&
  697|       |	(path[3] == '\\') )
  698|       |	    return 1;
  699|       |
  700|       |    if (xmlWrapStatUtf8(path, &stat_buffer) == -1)
  701|       |        return 0;
  702|       |#else
  703|  13.5k|    if (stat(path, &stat_buffer) == -1)
  ------------------
  |  Branch (703:9): [True: 13.5k, False: 0]
  ------------------
  704|  13.5k|        return 0;
  705|      0|#endif
  706|      0|#ifdef S_ISDIR
  707|      0|    if (S_ISDIR(stat_buffer.st_mode))
  708|      0|        return 2;
  709|      0|#endif
  710|      0|#endif /* HAVE_STAT */
  711|      0|    return 1;
  712|      0|}
xmlRegisterInputCallbacks:
 2102|      6|	xmlInputCloseCallback closeFunc) {
 2103|      6|    if (xmlInputCallbackNr >= MAX_INPUT_CALLBACK) {
  ------------------
  |  |   85|      6|#define MAX_INPUT_CALLBACK 15
  ------------------
  |  Branch (2103:9): [True: 0, False: 6]
  ------------------
 2104|      0|	return(-1);
 2105|      0|    }
 2106|      6|    xmlInputCallbackTable[xmlInputCallbackNr].matchcallback = matchFunc;
 2107|      6|    xmlInputCallbackTable[xmlInputCallbackNr].opencallback = openFunc;
 2108|      6|    xmlInputCallbackTable[xmlInputCallbackNr].readcallback = readFunc;
 2109|      6|    xmlInputCallbackTable[xmlInputCallbackNr].closecallback = closeFunc;
 2110|      6|    xmlInputCallbackInitialized = 1;
 2111|      6|    return(xmlInputCallbackNr++);
 2112|      6|}
xmlRegisterOutputCallbacks:
 2129|      2|	xmlOutputCloseCallback closeFunc) {
 2130|      2|    if (xmlOutputCallbackNr >= MAX_OUTPUT_CALLBACK) {
  ------------------
  |  |  102|      2|#define MAX_OUTPUT_CALLBACK 15
  ------------------
  |  Branch (2130:9): [True: 0, False: 2]
  ------------------
 2131|      0|	return(-1);
 2132|      0|    }
 2133|      2|    xmlOutputCallbackTable[xmlOutputCallbackNr].matchcallback = matchFunc;
 2134|      2|    xmlOutputCallbackTable[xmlOutputCallbackNr].opencallback = openFunc;
 2135|      2|    xmlOutputCallbackTable[xmlOutputCallbackNr].writecallback = writeFunc;
 2136|      2|    xmlOutputCallbackTable[xmlOutputCallbackNr].closecallback = closeFunc;
 2137|      2|    xmlOutputCallbackInitialized = 1;
 2138|      2|    return(xmlOutputCallbackNr++);
 2139|      2|}
xmlRegisterDefaultInputCallbacks:
 2148|      2|xmlRegisterDefaultInputCallbacks(void) {
 2149|      2|    if (xmlInputCallbackInitialized)
  ------------------
  |  Branch (2149:9): [True: 0, False: 2]
  ------------------
 2150|      0|	return;
 2151|       |
 2152|      2|    xmlRegisterInputCallbacks(xmlFileMatch, xmlFileOpen,
 2153|      2|	                      xmlFileRead, xmlFileClose);
 2154|      2|#ifdef LIBXML_ZLIB_ENABLED
 2155|      2|    xmlRegisterInputCallbacks(xmlGzfileMatch, xmlGzfileOpen,
 2156|      2|	                      xmlGzfileRead, xmlGzfileClose);
 2157|      2|#endif /* LIBXML_ZLIB_ENABLED */
 2158|      2|#ifdef LIBXML_LZMA_ENABLED
 2159|      2|    xmlRegisterInputCallbacks(xmlXzfileMatch, xmlXzfileOpen,
 2160|      2|	                      xmlXzfileRead, xmlXzfileClose);
 2161|      2|#endif /* LIBXML_LZMA_ENABLED */
 2162|       |
 2163|       |#ifdef LIBXML_HTTP_ENABLED
 2164|       |    xmlRegisterInputCallbacks(xmlIOHTTPMatch, xmlIOHTTPOpen,
 2165|       |	                      xmlIOHTTPRead, xmlIOHTTPClose);
 2166|       |#endif /* LIBXML_HTTP_ENABLED */
 2167|       |
 2168|       |#ifdef LIBXML_FTP_ENABLED
 2169|       |    xmlRegisterInputCallbacks(xmlIOFTPMatch, xmlIOFTPOpen,
 2170|       |	                      xmlIOFTPRead, xmlIOFTPClose);
 2171|       |#endif /* LIBXML_FTP_ENABLED */
 2172|      2|    xmlInputCallbackInitialized = 1;
 2173|      2|}
xmlRegisterDefaultOutputCallbacks:
 2182|      2|xmlRegisterDefaultOutputCallbacks (void) {
 2183|      2|    if (xmlOutputCallbackInitialized)
  ------------------
  |  Branch (2183:9): [True: 0, False: 2]
  ------------------
 2184|      0|	return;
 2185|       |
 2186|      2|    xmlRegisterOutputCallbacks(xmlFileMatch, xmlFileOpenW,
 2187|      2|	                      xmlFileWrite, xmlFileClose);
 2188|       |
 2189|       |#ifdef LIBXML_HTTP_ENABLED
 2190|       |    xmlRegisterOutputCallbacks(xmlIOHTTPMatch, xmlIOHTTPDfltOpenW,
 2191|       |	                       xmlIOHTTPWrite, xmlIOHTTPClosePut);
 2192|       |#endif
 2193|       |
 2194|       |/*********************************
 2195|       | No way a-priori to distinguish between gzipped files from
 2196|       | uncompressed ones except opening if existing then closing
 2197|       | and saving with same compression ratio ... a pain.
 2198|       |
 2199|       |#ifdef LIBXML_ZLIB_ENABLED
 2200|       |    xmlRegisterOutputCallbacks(xmlGzfileMatch, xmlGzfileOpen,
 2201|       |	                       xmlGzfileWrite, xmlGzfileClose);
 2202|       |#endif
 2203|       |
 2204|       | Nor FTP PUT ....
 2205|       |#ifdef LIBXML_FTP_ENABLED
 2206|       |    xmlRegisterOutputCallbacks(xmlIOFTPMatch, xmlIOFTPOpen,
 2207|       |	                       xmlIOFTPWrite, xmlIOFTPClose);
 2208|       |#endif
 2209|       | **********************************/
 2210|      2|    xmlOutputCallbackInitialized = 1;
 2211|      2|}
xmlAllocParserInputBuffer:
 2246|  15.3k|xmlAllocParserInputBuffer(xmlCharEncoding enc) {
 2247|  15.3k|    xmlParserInputBufferPtr ret;
 2248|       |
 2249|  15.3k|    ret = (xmlParserInputBufferPtr) xmlMalloc(sizeof(xmlParserInputBuffer));
 2250|  15.3k|    if (ret == NULL) {
  ------------------
  |  Branch (2250:9): [True: 0, False: 15.3k]
  ------------------
 2251|      0|	return(NULL);
 2252|      0|    }
 2253|  15.3k|    memset(ret, 0, sizeof(xmlParserInputBuffer));
 2254|  15.3k|    ret->buffer = xmlBufCreateSize(2 * xmlDefaultBufferSize);
  ------------------
  |  |  680|  15.3k|  #define xmlDefaultBufferSize XML_GLOBAL_MACRO(xmlDefaultBufferSize)
  |  |  ------------------
  |  |  |  |  500|  15.3k|  #define XML_GLOBAL_MACRO(name) (*__##name())
  |  |  ------------------
  ------------------
 2255|  15.3k|    if (ret->buffer == NULL) {
  ------------------
  |  Branch (2255:9): [True: 0, False: 15.3k]
  ------------------
 2256|      0|        xmlFree(ret);
 2257|      0|	return(NULL);
 2258|      0|    }
 2259|  15.3k|    xmlBufSetAllocationScheme(ret->buffer, XML_BUFFER_ALLOC_DOUBLEIT);
 2260|  15.3k|    ret->encoder = xmlGetCharEncodingHandler(enc);
 2261|  15.3k|    if (ret->encoder != NULL)
  ------------------
  |  Branch (2261:9): [True: 0, False: 15.3k]
  ------------------
 2262|      0|        ret->raw = xmlBufCreateSize(2 * xmlDefaultBufferSize);
  ------------------
  |  |  680|      0|  #define xmlDefaultBufferSize XML_GLOBAL_MACRO(xmlDefaultBufferSize)
  |  |  ------------------
  |  |  |  |  500|      0|  #define XML_GLOBAL_MACRO(name) (*__##name())
  |  |  ------------------
  ------------------
 2263|  15.3k|    else
 2264|  15.3k|        ret->raw = NULL;
 2265|  15.3k|    ret->readcallback = NULL;
 2266|  15.3k|    ret->closecallback = NULL;
 2267|  15.3k|    ret->context = NULL;
 2268|  15.3k|    ret->compressed = -1;
 2269|  15.3k|    ret->rawconsumed = 0;
 2270|       |
 2271|  15.3k|    return(ret);
 2272|  15.3k|}
xmlFreeParserInputBuffer:
 2383|  15.3k|xmlFreeParserInputBuffer(xmlParserInputBufferPtr in) {
 2384|  15.3k|    if (in == NULL) return;
  ------------------
  |  Branch (2384:9): [True: 0, False: 15.3k]
  ------------------
 2385|       |
 2386|  15.3k|    if (in->raw) {
  ------------------
  |  Branch (2386:9): [True: 72, False: 15.2k]
  ------------------
 2387|     72|        xmlBufFree(in->raw);
 2388|     72|	in->raw = NULL;
 2389|     72|    }
 2390|  15.3k|    if (in->encoder != NULL) {
  ------------------
  |  Branch (2390:9): [True: 72, False: 15.2k]
  ------------------
 2391|     72|        xmlCharEncCloseFunc(in->encoder);
 2392|     72|    }
 2393|  15.3k|    if (in->closecallback != NULL) {
  ------------------
  |  Branch (2393:9): [True: 14.7k, False: 646]
  ------------------
 2394|  14.7k|	in->closecallback(in->context);
 2395|  14.7k|    }
 2396|  15.3k|    if (in->buffer != NULL) {
  ------------------
  |  Branch (2396:9): [True: 15.3k, False: 0]
  ------------------
 2397|  15.3k|        xmlBufFree(in->buffer);
 2398|  15.3k|	in->buffer = NULL;
 2399|  15.3k|    }
 2400|       |
 2401|  15.3k|    xmlFree(in);
 2402|  15.3k|}
xmlParserInputBufferCreateMem:
 2870|  14.2k|xmlParserInputBufferCreateMem(const char *mem, int size, xmlCharEncoding enc) {
 2871|  14.2k|    xmlParserInputBufferPtr ret;
 2872|  14.2k|    xmlMemIOCtxt *ctxt;
 2873|       |
 2874|  14.2k|    if (size < 0) return(NULL);
  ------------------
  |  Branch (2874:9): [True: 0, False: 14.2k]
  ------------------
 2875|  14.2k|    if (mem == NULL) return(NULL);
  ------------------
  |  Branch (2875:9): [True: 0, False: 14.2k]
  ------------------
 2876|       |
 2877|  14.2k|    ret = xmlAllocParserInputBuffer(enc);
 2878|  14.2k|    if (ret == NULL)
  ------------------
  |  Branch (2878:9): [True: 0, False: 14.2k]
  ------------------
 2879|      0|        return(NULL);
 2880|       |
 2881|  14.2k|    ctxt = xmlMalloc(sizeof(*ctxt));
 2882|  14.2k|    if (ctxt == NULL) {
  ------------------
  |  Branch (2882:9): [True: 0, False: 14.2k]
  ------------------
 2883|      0|        xmlFreeParserInputBuffer(ret);
 2884|      0|        return(NULL);
 2885|      0|    }
 2886|  14.2k|    ctxt->mem = mem;
 2887|  14.2k|    ctxt->size = size;
 2888|       |
 2889|  14.2k|    ret->context = ctxt;
 2890|  14.2k|    ret->readcallback = xmlMemRead;
 2891|  14.2k|    ret->closecallback = xmlMemClose;
 2892|       |
 2893|  14.2k|    return(ret);
 2894|  14.2k|}
xmlParserInputBufferCreateString:
 2947|    432|xmlParserInputBufferCreateString(const xmlChar *str) {
 2948|    432|    xmlParserInputBufferPtr ret;
 2949|    432|    xmlStringIOCtxt *ctxt;
 2950|       |
 2951|    432|    if (str == NULL) return(NULL);
  ------------------
  |  Branch (2951:9): [True: 0, False: 432]
  ------------------
 2952|       |
 2953|    432|    ret = xmlAllocParserInputBuffer(XML_CHAR_ENCODING_NONE);
 2954|    432|    if (ret == NULL)
  ------------------
  |  Branch (2954:9): [True: 0, False: 432]
  ------------------
 2955|      0|        return(NULL);
 2956|       |
 2957|    432|    ctxt = xmlMalloc(sizeof(*ctxt));
 2958|    432|    if (ctxt == NULL) {
  ------------------
  |  Branch (2958:9): [True: 0, False: 432]
  ------------------
 2959|      0|        xmlFreeParserInputBuffer(ret);
 2960|      0|        return(NULL);
 2961|      0|    }
 2962|    432|    ctxt->str = str;
 2963|       |
 2964|    432|    ret->context = ctxt;
 2965|    432|    ret->readcallback = xmlStringRead;
 2966|    432|    ret->closecallback = xmlStringClose;
 2967|       |
 2968|    432|    return(ret);
 2969|    432|}
xmlParserInputBufferPush:
 3116|  12.2k|	                 int len, const char *buf) {
 3117|  12.2k|    int nbchars = 0;
 3118|  12.2k|    int ret;
 3119|       |
 3120|  12.2k|    if (len < 0) return(0);
  ------------------
  |  Branch (3120:9): [True: 0, False: 12.2k]
  ------------------
 3121|  12.2k|    if ((in == NULL) || (in->error)) return(-1);
  ------------------
  |  Branch (3121:9): [True: 0, False: 12.2k]
  |  Branch (3121:25): [True: 0, False: 12.2k]
  ------------------
 3122|  12.2k|    if (in->encoder != NULL) {
  ------------------
  |  Branch (3122:9): [True: 1.92k, False: 10.3k]
  ------------------
 3123|       |        /*
 3124|       |	 * Store the data in the incoming raw buffer
 3125|       |	 */
 3126|  1.92k|        if (in->raw == NULL) {
  ------------------
  |  Branch (3126:13): [True: 0, False: 1.92k]
  ------------------
 3127|      0|	    in->raw = xmlBufCreate();
 3128|      0|            if (in->raw == NULL) {
  ------------------
  |  Branch (3128:17): [True: 0, False: 0]
  ------------------
 3129|      0|                in->error = XML_ERR_NO_MEMORY;
 3130|      0|                return(-1);
 3131|      0|            }
 3132|      0|	}
 3133|  1.92k|	ret = xmlBufAdd(in->raw, (const xmlChar *) buf, len);
 3134|  1.92k|	if (ret != 0) {
  ------------------
  |  Branch (3134:6): [True: 0, False: 1.92k]
  ------------------
 3135|      0|            in->error = XML_ERR_NO_MEMORY;
 3136|      0|	    return(-1);
 3137|      0|        }
 3138|       |
 3139|       |	/*
 3140|       |	 * convert as much as possible to the parser reading buffer.
 3141|       |	 */
 3142|  1.92k|	nbchars = xmlCharEncInput(in);
 3143|  1.92k|	if (nbchars < 0)
  ------------------
  |  Branch (3143:6): [True: 0, False: 1.92k]
  ------------------
 3144|      0|	    return(-1);
 3145|  10.3k|    } else {
 3146|  10.3k|	nbchars = len;
 3147|  10.3k|        ret = xmlBufAdd(in->buffer, (xmlChar *) buf, nbchars);
 3148|  10.3k|	if (ret != 0) {
  ------------------
  |  Branch (3148:6): [True: 0, False: 10.3k]
  ------------------
 3149|      0|            in->error = XML_ERR_NO_MEMORY;
 3150|      0|	    return(-1);
 3151|      0|        }
 3152|  10.3k|    }
 3153|  12.2k|    return(nbchars);
 3154|  12.2k|}
xmlParserInputBufferGrow:
 3185|  1.99M|xmlParserInputBufferGrow(xmlParserInputBufferPtr in, int len) {
 3186|  1.99M|    xmlBufPtr buf;
 3187|  1.99M|    int res = 0;
 3188|       |
 3189|  1.99M|    if ((in == NULL) || (in->error)) return(-1);
  ------------------
  |  Branch (3189:9): [True: 0, False: 1.99M]
  |  Branch (3189:25): [True: 0, False: 1.99M]
  ------------------
 3190|  1.99M|    if ((len <= MINLEN) && (len != 4))
  ------------------
  |  |   73|  1.99M|#define MINLEN 4000
  ------------------
  |  Branch (3190:9): [True: 1.98M, False: 947]
  |  Branch (3190:28): [True: 1.98M, False: 323]
  ------------------
 3191|  1.98M|        len = MINLEN;
  ------------------
  |  |   73|  1.98M|#define MINLEN 4000
  ------------------
 3192|       |
 3193|  1.99M|    if (in->encoder == NULL) {
  ------------------
  |  Branch (3193:9): [True: 1.98M, False: 2.54k]
  ------------------
 3194|  1.98M|        if (in->readcallback == NULL)
  ------------------
  |  Branch (3194:13): [True: 0, False: 1.98M]
  ------------------
 3195|      0|            return(0);
 3196|  1.98M|        buf = in->buffer;
 3197|  1.98M|    } else {
 3198|  2.54k|        if (in->raw == NULL) {
  ------------------
  |  Branch (3198:13): [True: 0, False: 2.54k]
  ------------------
 3199|      0|	    in->raw = xmlBufCreate();
 3200|      0|	}
 3201|  2.54k|        buf = in->raw;
 3202|  2.54k|    }
 3203|       |
 3204|       |    /*
 3205|       |     * Call the read method for this I/O type.
 3206|       |     */
 3207|  1.99M|    if (in->readcallback != NULL) {
  ------------------
  |  Branch (3207:9): [True: 1.99M, False: 0]
  ------------------
 3208|  1.99M|        if (xmlBufGrow(buf, len + 1) < 0) {
  ------------------
  |  Branch (3208:13): [True: 0, False: 1.99M]
  ------------------
 3209|      0|            in->error = XML_ERR_NO_MEMORY;
 3210|      0|            return(-1);
 3211|      0|        }
 3212|       |
 3213|  1.99M|	res = in->readcallback(in->context, (char *)xmlBufEnd(buf), len);
 3214|  1.99M|	if (res <= 0)
  ------------------
  |  Branch (3214:6): [True: 1.97M, False: 15.9k]
  ------------------
 3215|  1.97M|	    in->readcallback = endOfInput;
 3216|  1.99M|        if (res < 0) {
  ------------------
  |  Branch (3216:13): [True: 0, False: 1.99M]
  ------------------
 3217|      0|            in->error = XML_IO_UNKNOWN;
 3218|      0|            return(-1);
 3219|      0|        }
 3220|       |
 3221|  1.99M|        if (xmlBufAddLen(buf, res) < 0) {
  ------------------
  |  Branch (3221:13): [True: 0, False: 1.99M]
  ------------------
 3222|      0|            in->error = XML_ERR_NO_MEMORY;
 3223|      0|            return(-1);
 3224|      0|        }
 3225|  1.99M|    }
 3226|       |
 3227|       |    /*
 3228|       |     * try to establish compressed status of input if not done already
 3229|       |     */
 3230|  1.99M|    if (in->compressed == -1) {
  ------------------
  |  Branch (3230:9): [True: 1.99M, False: 0]
  ------------------
 3231|  1.99M|#ifdef LIBXML_LZMA_ENABLED
 3232|  1.99M|	if (in->readcallback == xmlXzfileRead)
  ------------------
  |  Branch (3232:6): [True: 0, False: 1.99M]
  ------------------
 3233|      0|            in->compressed = __libxml2_xzcompressed(in->context);
 3234|  1.99M|#endif
 3235|  1.99M|    }
 3236|       |
 3237|  1.99M|    if (in->encoder != NULL) {
  ------------------
  |  Branch (3237:9): [True: 2.54k, False: 1.98M]
  ------------------
 3238|  2.54k|	res = xmlCharEncInput(in);
 3239|  2.54k|	if (res < 0)
  ------------------
  |  Branch (3239:6): [True: 0, False: 2.54k]
  ------------------
 3240|      0|	    return(-1);
 3241|  2.54k|    }
 3242|  1.99M|    return(res);
 3243|  1.99M|}
xmlParserInputBufferRead:
 3258|  1.26k|xmlParserInputBufferRead(xmlParserInputBufferPtr in, int len) {
 3259|  1.26k|    return(xmlParserInputBufferGrow(in, len));
 3260|  1.26k|}
xmlParserGetDirectory:
 3663|    359|xmlParserGetDirectory(const char *filename) {
 3664|    359|    char *ret = NULL;
 3665|    359|    char dir[1024];
 3666|    359|    char *cur;
 3667|       |
 3668|    359|    if (xmlInputCallbackInitialized == 0)
  ------------------
  |  Branch (3668:9): [True: 0, False: 359]
  ------------------
 3669|      0|	xmlRegisterDefaultInputCallbacks();
 3670|       |
 3671|    359|    if (filename == NULL) return(NULL);
  ------------------
  |  Branch (3671:9): [True: 0, False: 359]
  ------------------
 3672|       |
 3673|       |#if defined(_WIN32)
 3674|       |#   define IS_XMLPGD_SEP(ch) ((ch=='/')||(ch=='\\'))
 3675|       |#else
 3676|    359|#   define IS_XMLPGD_SEP(ch) (ch=='/')
 3677|    359|#endif
 3678|       |
 3679|    359|    strncpy(dir, filename, 1023);
 3680|    359|    dir[1023] = 0;
 3681|    359|    cur = &dir[strlen(dir)];
 3682|  3.83k|    while (cur > dir) {
  ------------------
  |  Branch (3682:12): [True: 3.48k, False: 347]
  ------------------
 3683|  3.48k|         if (IS_XMLPGD_SEP(*cur)) break;
  ------------------
  |  | 3676|  3.48k|#   define IS_XMLPGD_SEP(ch) (ch=='/')
  |  |  ------------------
  |  |  |  Branch (3676:30): [True: 12, False: 3.47k]
  |  |  ------------------
  ------------------
 3684|  3.47k|	 cur --;
 3685|  3.47k|    }
 3686|    359|    if (IS_XMLPGD_SEP(*cur)) {
  ------------------
  |  | 3676|    359|#   define IS_XMLPGD_SEP(ch) (ch=='/')
  |  |  ------------------
  |  |  |  Branch (3676:30): [True: 12, False: 347]
  |  |  ------------------
  ------------------
 3687|     12|        if (cur == dir) dir[1] = 0;
  ------------------
  |  Branch (3687:13): [True: 0, False: 12]
  ------------------
 3688|     12|	else *cur = 0;
 3689|     12|	ret = xmlMemStrdup(dir);
 3690|    347|    } else {
 3691|    347|        if (getcwd(dir, 1024) != NULL) {
  ------------------
  |  Branch (3691:13): [True: 347, False: 0]
  ------------------
 3692|    347|	    dir[1023] = 0;
 3693|    347|	    ret = xmlMemStrdup(dir);
 3694|    347|	}
 3695|    347|    }
 3696|    359|    return(ret);
 3697|    359|#undef IS_XMLPGD_SEP
 3698|    359|}
xmlSetExternalEntityLoader:
 3937|      2|xmlSetExternalEntityLoader(xmlExternalEntityLoader f) {
 3938|      2|    xmlCurrentExternalEntityLoader = f;
 3939|      2|}
xmlLoadExternalEntity:
 3966|  13.5k|                      xmlParserCtxtPtr ctxt) {
 3967|  13.5k|    if ((URL != NULL) && (xmlNoNetExists(URL) == 0)) {
  ------------------
  |  Branch (3967:9): [True: 13.5k, False: 0]
  |  Branch (3967:26): [True: 13.5k, False: 0]
  ------------------
 3968|  13.5k|	char *canonicFilename;
 3969|  13.5k|	xmlParserInputPtr ret;
 3970|       |
 3971|  13.5k|	canonicFilename = (char *) xmlCanonicPath((const xmlChar *) URL);
 3972|  13.5k|	if (canonicFilename == NULL) {
  ------------------
  |  Branch (3972:6): [True: 0, False: 13.5k]
  ------------------
 3973|      0|            xmlErrMemory(ctxt, "building canonical path\n");
 3974|      0|	    return(NULL);
 3975|      0|	}
 3976|       |
 3977|  13.5k|	ret = xmlCurrentExternalEntityLoader(canonicFilename, ID, ctxt);
 3978|  13.5k|	xmlFree(canonicFilename);
 3979|  13.5k|	return(ret);
 3980|  13.5k|    }
 3981|      0|    return(xmlCurrentExternalEntityLoader(URL, ID, ctxt));
 3982|  13.5k|}
xmlIO.c:xmlMemRead:
 2839|  29.7k|xmlMemRead(void *vctxt, char *buf, int size) {
 2840|  29.7k|    xmlMemIOCtxt *ctxt = vctxt;
 2841|       |
 2842|  29.7k|    if ((size_t) size > ctxt->size)
  ------------------
  |  Branch (2842:9): [True: 28.4k, False: 1.26k]
  ------------------
 2843|  28.4k|        size = ctxt->size;
 2844|       |
 2845|  29.7k|    memcpy(buf, ctxt->mem, size);
 2846|  29.7k|    ctxt->mem += size;
 2847|  29.7k|    ctxt->size -= size;
 2848|       |
 2849|  29.7k|    return size;
 2850|  29.7k|}
xmlIO.c:xmlMemClose:
 2853|  14.2k|xmlMemClose(void *vctxt) {
 2854|  14.2k|    xmlFree(vctxt);
 2855|  14.2k|    return(0);
 2856|  14.2k|}
xmlIO.c:xmlStringRead:
 2917|    856|xmlStringRead(void *vctxt, char *buf, int size) {
 2918|    856|    xmlStringIOCtxt *ctxt = vctxt;
 2919|    856|    const xmlChar *zero;
 2920|    856|    size_t len;
 2921|       |
 2922|    856|    zero = memchr(ctxt->str, 0, size);
 2923|    856|    len = zero ? zero - ctxt->str : size;
  ------------------
  |  Branch (2923:11): [True: 856, False: 0]
  ------------------
 2924|       |
 2925|    856|    memcpy(buf, ctxt->str, len);
 2926|    856|    ctxt->str += len;
 2927|       |
 2928|    856|    return(len);
 2929|    856|}
xmlIO.c:xmlStringClose:
 2932|    432|xmlStringClose(void *vctxt) {
 2933|    432|    xmlFree(vctxt);
 2934|    432|    return(0);
 2935|    432|}
xmlIO.c:endOfInput:
 3165|  1.95M|	    int len ATTRIBUTE_UNUSED) {
 3166|  1.95M|    return(0);
 3167|  1.95M|}
xmlIO.c:xmlNoNetExists:
 3781|  13.5k|static int xmlNoNetExists(const char *URL) {
 3782|  13.5k|    const char *path;
 3783|       |
 3784|  13.5k|    if (URL == NULL)
  ------------------
  |  Branch (3784:9): [True: 0, False: 13.5k]
  ------------------
 3785|      0|	return(0);
 3786|       |
 3787|  13.5k|    if (!xmlStrncasecmp(BAD_CAST URL, BAD_CAST "file://localhost/", 17))
  ------------------
  |  |   35|  13.5k|#define BAD_CAST (xmlChar *)
  ------------------
                  if (!xmlStrncasecmp(BAD_CAST URL, BAD_CAST "file://localhost/", 17))
  ------------------
  |  |   35|  13.5k|#define BAD_CAST (xmlChar *)
  ------------------
  |  Branch (3787:9): [True: 0, False: 13.5k]
  ------------------
 3788|       |#if defined (_WIN32)
 3789|       |	path = &URL[17];
 3790|       |#else
 3791|      0|	path = &URL[16];
 3792|  13.5k|#endif
 3793|  13.5k|    else if (!xmlStrncasecmp(BAD_CAST URL, BAD_CAST "file:///", 8)) {
  ------------------
  |  |   35|  13.5k|#define BAD_CAST (xmlChar *)
  ------------------
                  else if (!xmlStrncasecmp(BAD_CAST URL, BAD_CAST "file:///", 8)) {
  ------------------
  |  |   35|  13.5k|#define BAD_CAST (xmlChar *)
  ------------------
  |  Branch (3793:14): [True: 0, False: 13.5k]
  ------------------
 3794|       |#if defined (_WIN32)
 3795|       |	path = &URL[8];
 3796|       |#else
 3797|      0|	path = &URL[7];
 3798|      0|#endif
 3799|      0|    } else
 3800|  13.5k|	path = URL;
 3801|       |
 3802|  13.5k|    return xmlCheckFilename(path);
 3803|  13.5k|}

xmlInitMemoryInternal:
  846|      2|xmlInitMemoryInternal(void) {
  847|      2|     char *breakpoint;
  848|      2|     xmlInitMutex(&xmlMemMutex);
  849|       |
  850|      2|     breakpoint = getenv("XML_MEM_BREAKPOINT");
  851|      2|     if (breakpoint != NULL) {
  ------------------
  |  Branch (851:10): [True: 0, False: 2]
  ------------------
  852|      0|         sscanf(breakpoint, "%ud", &xmlMemStopAtBlock);
  853|      0|     }
  854|      2|     breakpoint = getenv("XML_MEM_TRACE");
  855|      2|     if (breakpoint != NULL) {
  ------------------
  |  Branch (855:10): [True: 0, False: 2]
  ------------------
  856|      0|         sscanf(breakpoint, "%p", &xmlMemTraceBlockAt);
  857|      0|     }
  858|       |
  859|      2|}
xmlMemSetup:
  910|      2|            xmlReallocFunc reallocFunc, xmlStrdupFunc strdupFunc) {
  911|      2|    if (freeFunc == NULL)
  ------------------
  |  Branch (911:9): [True: 0, False: 2]
  ------------------
  912|      0|	return(-1);
  913|      2|    if (mallocFunc == NULL)
  ------------------
  |  Branch (913:9): [True: 0, False: 2]
  ------------------
  914|      0|	return(-1);
  915|      2|    if (reallocFunc == NULL)
  ------------------
  |  Branch (915:9): [True: 0, False: 2]
  ------------------
  916|      0|	return(-1);
  917|      2|    if (strdupFunc == NULL)
  ------------------
  |  Branch (917:9): [True: 0, False: 2]
  ------------------
  918|      0|	return(-1);
  919|      2|    xmlFree = freeFunc;
  920|      2|    xmlMalloc = mallocFunc;
  921|      2|    xmlMallocAtomic = mallocFunc;
  922|      2|    xmlRealloc = reallocFunc;
  923|      2|    xmlMemStrdup = strdupFunc;
  924|      2|    return(0);
  925|      2|}

xmlTextReaderRead:
 1160|  39.6k|xmlTextReaderRead(xmlTextReaderPtr reader) {
 1161|  39.6k|    int val, olddepth = 0;
 1162|  39.6k|    xmlTextReaderState oldstate = XML_TEXTREADER_START;
 1163|  39.6k|    xmlNodePtr oldnode = NULL;
 1164|       |
 1165|       |
 1166|  39.6k|    if (reader == NULL)
  ------------------
  |  Branch (1166:9): [True: 0, False: 39.6k]
  ------------------
 1167|      0|	return(-1);
 1168|  39.6k|    reader->curnode = NULL;
 1169|  39.6k|    if (reader->doc != NULL)
  ------------------
  |  Branch (1169:9): [True: 0, False: 39.6k]
  ------------------
 1170|      0|        return(xmlTextReaderReadTree(reader));
 1171|  39.6k|    if (reader->ctxt == NULL)
  ------------------
  |  Branch (1171:9): [True: 0, False: 39.6k]
  ------------------
 1172|      0|	return(-1);
 1173|       |
 1174|  39.6k|    if (reader->mode == XML_TEXTREADER_MODE_INITIAL) {
  ------------------
  |  Branch (1174:9): [True: 323, False: 39.3k]
  ------------------
 1175|    323|	reader->mode = XML_TEXTREADER_MODE_INTERACTIVE;
 1176|       |	/*
 1177|       |	 * Initial state
 1178|       |	 */
 1179|    552|	do {
 1180|    552|	    val = xmlTextReaderPushData(reader);
 1181|    552|		if (val < 0){
  ------------------
  |  Branch (1181:7): [True: 55, False: 497]
  ------------------
 1182|     55|			reader->mode = XML_TEXTREADER_MODE_ERROR;
 1183|     55|			reader->state = XML_TEXTREADER_ERROR;
 1184|     55|		return(-1);
 1185|     55|		}
 1186|    552|	} while ((reader->ctxt->node == NULL) &&
  ------------------
  |  Branch (1186:11): [True: 437, False: 60]
  ------------------
 1187|    497|		 ((reader->mode != XML_TEXTREADER_MODE_EOF) &&
  ------------------
  |  Branch (1187:5): [True: 229, False: 208]
  ------------------
 1188|    437|		  (reader->state != XML_TEXTREADER_DONE)));
  ------------------
  |  Branch (1188:5): [True: 229, False: 0]
  ------------------
 1189|    268|	if (reader->ctxt->node == NULL) {
  ------------------
  |  Branch (1189:6): [True: 208, False: 60]
  ------------------
 1190|    208|	    if (reader->ctxt->myDoc != NULL) {
  ------------------
  |  Branch (1190:10): [True: 208, False: 0]
  ------------------
 1191|    208|		reader->node = reader->ctxt->myDoc->children;
 1192|    208|	    }
 1193|    208|	    if (reader->node == NULL){
  ------------------
  |  Branch (1193:10): [True: 0, False: 208]
  ------------------
 1194|      0|			reader->mode = XML_TEXTREADER_MODE_ERROR;
 1195|      0|			reader->state = XML_TEXTREADER_ERROR;
 1196|      0|		return(-1);
 1197|      0|		}
 1198|    208|	    reader->state = XML_TEXTREADER_ELEMENT;
 1199|    208|	} else {
 1200|     60|	    if (reader->ctxt->myDoc != NULL) {
  ------------------
  |  Branch (1200:10): [True: 60, False: 0]
  ------------------
 1201|     60|		reader->node = reader->ctxt->myDoc->children;
 1202|     60|	    }
 1203|     60|	    if (reader->node == NULL)
  ------------------
  |  Branch (1203:10): [True: 0, False: 60]
  ------------------
 1204|      0|		reader->node = reader->ctxt->nodeTab[0];
 1205|     60|	    reader->state = XML_TEXTREADER_ELEMENT;
 1206|     60|	}
 1207|    268|	reader->depth = 0;
 1208|    268|	reader->ctxt->parseMode = XML_PARSE_READER;
 1209|    268|	goto node_found;
 1210|    268|    }
 1211|  39.3k|    oldstate = reader->state;
 1212|  39.3k|    olddepth = reader->ctxt->nodeNr;
 1213|  39.3k|    oldnode = reader->node;
 1214|       |
 1215|  39.3k|get_next_node:
 1216|  39.3k|    if (reader->node == NULL) {
  ------------------
  |  Branch (1216:9): [True: 3.17k, False: 36.1k]
  ------------------
 1217|  3.17k|	if (reader->mode == XML_TEXTREADER_MODE_EOF)
  ------------------
  |  Branch (1217:6): [True: 2.62k, False: 550]
  ------------------
 1218|  2.62k|	    return(0);
 1219|    550|	else
 1220|    550|	    return(-1);
 1221|  3.17k|    }
 1222|       |
 1223|       |    /*
 1224|       |     * If we are not backtracking on ancestors or examined nodes,
 1225|       |     * that the parser didn't finished or that we aren't at the end
 1226|       |     * of stream, continue processing.
 1227|       |     */
 1228|  36.8k|    while ((reader->node != NULL) && (reader->node->next == NULL) &&
  ------------------
  |  Branch (1228:12): [True: 36.8k, False: 0]
  |  Branch (1228:38): [True: 6.33k, False: 30.5k]
  ------------------
 1229|  36.8k|	   (reader->ctxt->nodeNr == olddepth) &&
  ------------------
  |  Branch (1229:5): [True: 6.29k, False: 38]
  ------------------
 1230|  36.8k|           ((oldstate == XML_TEXTREADER_BACKTRACK) ||
  ------------------
  |  Branch (1230:13): [True: 559, False: 5.73k]
  ------------------
 1231|  6.29k|            (reader->node->children == NULL) ||
  ------------------
  |  Branch (1231:13): [True: 4.27k, False: 1.46k]
  ------------------
 1232|  6.29k|	    (reader->node->type == XML_ENTITY_REF_NODE) ||
  ------------------
  |  Branch (1232:6): [True: 0, False: 1.46k]
  ------------------
 1233|  6.29k|	    ((reader->node->children != NULL) &&
  ------------------
  |  Branch (1233:7): [True: 1.46k, False: 0]
  ------------------
 1234|  1.46k|	     (reader->node->children->type == XML_TEXT_NODE) &&
  ------------------
  |  Branch (1234:7): [True: 1.26k, False: 203]
  ------------------
 1235|  1.46k|	     (reader->node->children->next == NULL)) ||
  ------------------
  |  Branch (1235:7): [True: 538, False: 723]
  ------------------
 1236|  6.29k|	    (reader->node->type == XML_DTD_NODE) ||
  ------------------
  |  Branch (1236:6): [True: 0, False: 926]
  ------------------
 1237|  6.29k|	    (reader->node->type == XML_DOCUMENT_NODE) ||
  ------------------
  |  Branch (1237:6): [True: 7, False: 919]
  ------------------
 1238|  6.29k|	    (reader->node->type == XML_HTML_DOCUMENT_NODE)) &&
  ------------------
  |  Branch (1238:6): [True: 0, False: 919]
  ------------------
 1239|  36.8k|	   ((reader->ctxt->node == NULL) ||
  ------------------
  |  Branch (1239:6): [True: 945, False: 4.43k]
  ------------------
 1240|  5.37k|	    (reader->ctxt->node == reader->node) ||
  ------------------
  |  Branch (1240:6): [True: 397, False: 4.03k]
  ------------------
 1241|  5.37k|	    (reader->ctxt->node == reader->node->parent)) &&
  ------------------
  |  Branch (1241:6): [True: 296, False: 3.73k]
  ------------------
 1242|  36.8k|	   (reader->ctxt->instate != XML_PARSER_EOF)) {
  ------------------
  |  Branch (1242:5): [True: 731, False: 907]
  ------------------
 1243|    731|	val = xmlTextReaderPushData(reader);
 1244|    731|	if (val < 0){
  ------------------
  |  Branch (1244:6): [True: 25, False: 706]
  ------------------
 1245|     25|		reader->mode = XML_TEXTREADER_MODE_ERROR;
 1246|     25|		reader->state = XML_TEXTREADER_ERROR;
 1247|     25|	    return(-1);
 1248|     25|	}
 1249|    706|	if (reader->node == NULL)
  ------------------
  |  Branch (1249:6): [True: 0, False: 706]
  ------------------
 1250|      0|	    goto node_end;
 1251|    706|    }
 1252|  36.1k|    if (oldstate != XML_TEXTREADER_BACKTRACK) {
  ------------------
  |  Branch (1252:9): [True: 31.9k, False: 4.14k]
  ------------------
 1253|  31.9k|	if ((reader->node->children != NULL) &&
  ------------------
  |  Branch (1253:6): [True: 4.26k, False: 27.7k]
  ------------------
 1254|  31.9k|	    (reader->node->type != XML_ENTITY_REF_NODE) &&
  ------------------
  |  Branch (1254:6): [True: 4.26k, False: 0]
  ------------------
 1255|  31.9k|	    (reader->node->type != XML_XINCLUDE_START) &&
  ------------------
  |  Branch (1255:6): [True: 4.26k, False: 0]
  ------------------
 1256|  31.9k|	    (reader->node->type != XML_DTD_NODE)) {
  ------------------
  |  Branch (1256:6): [True: 4.15k, False: 114]
  ------------------
 1257|  4.15k|	    reader->node = reader->node->children;
 1258|  4.15k|	    reader->depth++;
 1259|  4.15k|	    reader->state = XML_TEXTREADER_ELEMENT;
 1260|  4.15k|	    goto node_found;
 1261|  4.15k|	}
 1262|  31.9k|    }
 1263|  31.9k|    if (reader->node->next != NULL) {
  ------------------
  |  Branch (1263:9): [True: 27.5k, False: 4.42k]
  ------------------
 1264|  27.5k|	if ((oldstate == XML_TEXTREADER_ELEMENT) &&
  ------------------
  |  Branch (1264:6): [True: 23.9k, False: 3.62k]
  ------------------
 1265|  27.5k|            (reader->node->type == XML_ELEMENT_NODE) &&
  ------------------
  |  Branch (1265:13): [True: 10.0k, False: 13.9k]
  ------------------
 1266|  27.5k|	    (reader->node->children == NULL) &&
  ------------------
  |  Branch (1266:6): [True: 10.0k, False: 0]
  ------------------
 1267|  27.5k|	    ((reader->node->extra & NODE_IS_EMPTY) == 0)
  ------------------
  |  |  186|  10.0k|#define NODE_IS_EMPTY		0x1
  ------------------
  |  Branch (1267:6): [True: 13, False: 9.99k]
  ------------------
 1268|  27.5k|#ifdef LIBXML_XINCLUDE_ENABLED
 1269|  27.5k|	    && (reader->in_xinclude <= 0)
  ------------------
  |  Branch (1269:9): [True: 13, False: 0]
  ------------------
 1270|  27.5k|#endif
 1271|  27.5k|	    ) {
 1272|     13|	    reader->state = XML_TEXTREADER_END;
 1273|     13|	    goto node_found;
 1274|     13|	}
 1275|  27.5k|#ifdef LIBXML_REGEXP_ENABLED
 1276|  27.5k|	if ((reader->validate) &&
  ------------------
  |  Branch (1276:6): [True: 27.5k, False: 0]
  ------------------
 1277|  27.5k|	    (reader->node->type == XML_ELEMENT_NODE))
  ------------------
  |  Branch (1277:6): [True: 13.6k, False: 13.9k]
  ------------------
 1278|  13.6k|	    xmlTextReaderValidatePop(reader);
 1279|  27.5k|#endif /* LIBXML_REGEXP_ENABLED */
 1280|  27.5k|        if ((reader->preserves > 0) &&
  ------------------
  |  Branch (1280:13): [True: 0, False: 27.5k]
  ------------------
 1281|  27.5k|	    (reader->node->extra & NODE_IS_SPRESERVED))
  ------------------
  |  |  188|      0|#define NODE_IS_SPRESERVED	0x4
  ------------------
  |  Branch (1281:6): [True: 0, False: 0]
  ------------------
 1282|      0|	    reader->preserves--;
 1283|  27.5k|	reader->node = reader->node->next;
 1284|  27.5k|	reader->state = XML_TEXTREADER_ELEMENT;
 1285|       |
 1286|       |	/*
 1287|       |	 * Cleanup of the old node
 1288|       |	 */
 1289|  27.5k|	if ((reader->preserves == 0) &&
  ------------------
  |  Branch (1289:6): [True: 27.5k, False: 0]
  ------------------
 1290|  27.5k|#ifdef LIBXML_XINCLUDE_ENABLED
 1291|  27.5k|	    (reader->in_xinclude == 0) &&
  ------------------
  |  Branch (1291:6): [True: 27.5k, False: 0]
  ------------------
 1292|  27.5k|#endif
 1293|  27.5k|	    (reader->entNr == 0) &&
  ------------------
  |  Branch (1293:6): [True: 27.5k, False: 0]
  ------------------
 1294|  27.5k|	    (reader->node->prev != NULL) &&
  ------------------
  |  Branch (1294:6): [True: 27.5k, False: 0]
  ------------------
 1295|  27.5k|            (reader->node->prev->type != XML_DTD_NODE)) {
  ------------------
  |  Branch (1295:13): [True: 27.3k, False: 166]
  ------------------
 1296|  27.3k|	    xmlNodePtr tmp = reader->node->prev;
 1297|  27.3k|	    if ((tmp->extra & NODE_IS_PRESERVED) == 0) {
  ------------------
  |  |  187|  27.3k|#define NODE_IS_PRESERVED	0x2
  ------------------
  |  Branch (1297:10): [True: 27.3k, False: 0]
  ------------------
 1298|  27.3k|                if (oldnode == tmp)
  ------------------
  |  Branch (1298:21): [True: 27.3k, False: 0]
  ------------------
 1299|  27.3k|                    oldnode = NULL;
 1300|  27.3k|		xmlUnlinkNode(tmp);
 1301|  27.3k|		xmlTextReaderFreeNode(reader, tmp);
 1302|  27.3k|	    }
 1303|  27.3k|	}
 1304|       |
 1305|  27.5k|	goto node_found;
 1306|  27.5k|    }
 1307|  4.42k|    if ((oldstate == XML_TEXTREADER_ELEMENT) &&
  ------------------
  |  Branch (1307:9): [True: 3.87k, False: 551]
  ------------------
 1308|  4.42k|	(reader->node->type == XML_ELEMENT_NODE) &&
  ------------------
  |  Branch (1308:2): [True: 90, False: 3.78k]
  ------------------
 1309|  4.42k|	(reader->node->children == NULL) &&
  ------------------
  |  Branch (1309:2): [True: 90, False: 0]
  ------------------
 1310|  4.42k|	((reader->node->extra & NODE_IS_EMPTY) == 0)) {;
  ------------------
  |  |  186|     90|#define NODE_IS_EMPTY		0x1
  ------------------
  |  Branch (1310:2): [True: 14, False: 76]
  ------------------
 1311|     14|	reader->state = XML_TEXTREADER_END;
 1312|     14|	goto node_found;
 1313|     14|    }
 1314|  4.41k|#ifdef LIBXML_REGEXP_ENABLED
 1315|  4.41k|    if ((reader->validate != XML_TEXTREADER_NOT_VALIDATE) && (reader->node->type == XML_ELEMENT_NODE))
  ------------------
  |  Branch (1315:9): [True: 4.41k, False: 0]
  |  Branch (1315:62): [True: 627, False: 3.78k]
  ------------------
 1316|    627|	xmlTextReaderValidatePop(reader);
 1317|  4.41k|#endif /* LIBXML_REGEXP_ENABLED */
 1318|  4.41k|    if ((reader->preserves > 0) &&
  ------------------
  |  Branch (1318:9): [True: 0, False: 4.41k]
  ------------------
 1319|  4.41k|	(reader->node->extra & NODE_IS_SPRESERVED))
  ------------------
  |  |  188|      0|#define NODE_IS_SPRESERVED	0x4
  ------------------
  |  Branch (1319:2): [True: 0, False: 0]
  ------------------
 1320|      0|	reader->preserves--;
 1321|  4.41k|    reader->node = reader->node->parent;
 1322|  4.41k|    if ((reader->node == NULL) ||
  ------------------
  |  Branch (1322:9): [True: 0, False: 4.41k]
  ------------------
 1323|  4.41k|	(reader->node->type == XML_DOCUMENT_NODE) ||
  ------------------
  |  Branch (1323:2): [True: 269, False: 4.14k]
  ------------------
 1324|  4.41k|	(reader->node->type == XML_HTML_DOCUMENT_NODE)) {
  ------------------
  |  Branch (1324:2): [True: 0, False: 4.14k]
  ------------------
 1325|    269|	if (reader->mode != XML_TEXTREADER_MODE_EOF) {
  ------------------
  |  Branch (1325:6): [True: 7, False: 262]
  ------------------
 1326|      7|	    val = xmlParseChunk(reader->ctxt, "", 0, 1);
 1327|      7|	    reader->state = XML_TEXTREADER_DONE;
 1328|      7|	    if (val != 0)
  ------------------
  |  Branch (1328:10): [True: 7, False: 0]
  ------------------
 1329|      7|	        return(-1);
 1330|      7|	}
 1331|    262|	reader->node = NULL;
 1332|    262|	reader->depth = -1;
 1333|       |
 1334|       |	/*
 1335|       |	 * Cleanup of the old node
 1336|       |	 */
 1337|    262|	if ((oldnode != NULL) && (reader->preserves == 0) &&
  ------------------
  |  Branch (1337:6): [True: 262, False: 0]
  |  Branch (1337:27): [True: 262, False: 0]
  ------------------
 1338|    262|#ifdef LIBXML_XINCLUDE_ENABLED
 1339|    262|	    (reader->in_xinclude == 0) &&
  ------------------
  |  Branch (1339:6): [True: 262, False: 0]
  ------------------
 1340|    262|#endif
 1341|    262|	    (reader->entNr == 0) &&
  ------------------
  |  Branch (1341:6): [True: 262, False: 0]
  ------------------
 1342|    262|	    (oldnode->type != XML_DTD_NODE) &&
  ------------------
  |  Branch (1342:6): [True: 262, False: 0]
  ------------------
 1343|    262|	    ((oldnode->extra & NODE_IS_PRESERVED) == 0)) {
  ------------------
  |  |  187|    262|#define NODE_IS_PRESERVED	0x2
  ------------------
  |  Branch (1343:6): [True: 262, False: 0]
  ------------------
 1344|    262|	    xmlUnlinkNode(oldnode);
 1345|    262|	    xmlTextReaderFreeNode(reader, oldnode);
 1346|    262|	}
 1347|       |
 1348|    262|	goto node_end;
 1349|    269|    }
 1350|  4.14k|    if ((reader->preserves == 0) &&
  ------------------
  |  Branch (1350:9): [True: 4.14k, False: 0]
  ------------------
 1351|  4.14k|#ifdef LIBXML_XINCLUDE_ENABLED
 1352|  4.14k|        (reader->in_xinclude == 0) &&
  ------------------
  |  Branch (1352:9): [True: 4.14k, False: 0]
  ------------------
 1353|  4.14k|#endif
 1354|  4.14k|	(reader->entNr == 0) &&
  ------------------
  |  Branch (1354:2): [True: 4.14k, False: 0]
  ------------------
 1355|  4.14k|        (reader->node->last != NULL) &&
  ------------------
  |  Branch (1355:9): [True: 4.14k, False: 0]
  ------------------
 1356|  4.14k|        ((reader->node->last->extra & NODE_IS_PRESERVED) == 0)) {
  ------------------
  |  |  187|  4.14k|#define NODE_IS_PRESERVED	0x2
  ------------------
  |  Branch (1356:9): [True: 4.14k, False: 0]
  ------------------
 1357|  4.14k|	xmlNodePtr tmp = reader->node->last;
 1358|  4.14k|	xmlUnlinkNode(tmp);
 1359|  4.14k|	xmlTextReaderFreeNode(reader, tmp);
 1360|  4.14k|    }
 1361|  4.14k|    reader->depth--;
 1362|  4.14k|    reader->state = XML_TEXTREADER_BACKTRACK;
 1363|       |
 1364|  36.1k|node_found:
 1365|       |    /*
 1366|       |     * If we are in the middle of a piece of CDATA make sure it's finished
 1367|       |     */
 1368|  36.1k|    if ((reader->node != NULL) &&
  ------------------
  |  Branch (1368:9): [True: 36.1k, False: 0]
  ------------------
 1369|  36.1k|        (reader->node->next == NULL) &&
  ------------------
  |  Branch (1369:9): [True: 6.86k, False: 29.2k]
  ------------------
 1370|  36.1k|        ((reader->node->type == XML_TEXT_NODE) ||
  ------------------
  |  Branch (1370:10): [True: 4.42k, False: 2.43k]
  ------------------
 1371|  6.86k|	 (reader->node->type == XML_CDATA_SECTION_NODE))) {
  ------------------
  |  Branch (1371:3): [True: 27, False: 2.41k]
  ------------------
 1372|  4.45k|            if (xmlTextReaderExpand(reader) == NULL)
  ------------------
  |  Branch (1372:17): [True: 1, False: 4.45k]
  ------------------
 1373|      1|	        return -1;
 1374|  4.45k|    }
 1375|       |
 1376|  36.1k|#ifdef LIBXML_XINCLUDE_ENABLED
 1377|       |    /*
 1378|       |     * Handle XInclude if asked for
 1379|       |     */
 1380|  36.1k|    if ((reader->xinclude) && (reader->in_xinclude == 0) &&
  ------------------
  |  Branch (1380:9): [True: 0, False: 36.1k]
  |  Branch (1380:31): [True: 0, False: 0]
  ------------------
 1381|  36.1k|        (reader->node != NULL) &&
  ------------------
  |  Branch (1381:9): [True: 0, False: 0]
  ------------------
 1382|  36.1k|	(reader->node->type == XML_ELEMENT_NODE) &&
  ------------------
  |  Branch (1382:2): [True: 0, False: 0]
  ------------------
 1383|  36.1k|	(reader->node->ns != NULL) &&
  ------------------
  |  Branch (1383:2): [True: 0, False: 0]
  ------------------
 1384|  36.1k|	((xmlStrEqual(reader->node->ns->href, XINCLUDE_NS)) ||
  ------------------
  |  |   30|      0|#define XINCLUDE_NS (const xmlChar *) "http://www.w3.org/2003/XInclude"
  ------------------
  |  Branch (1384:3): [True: 0, False: 0]
  ------------------
 1385|      0|	 (xmlStrEqual(reader->node->ns->href, XINCLUDE_OLD_NS)))) {
  ------------------
  |  |   36|      0|#define XINCLUDE_OLD_NS (const xmlChar *) "http://www.w3.org/2001/XInclude"
  ------------------
  |  Branch (1385:3): [True: 0, False: 0]
  ------------------
 1386|      0|	if (reader->xincctxt == NULL) {
  ------------------
  |  Branch (1386:6): [True: 0, False: 0]
  ------------------
 1387|      0|	    reader->xincctxt = xmlXIncludeNewContext(reader->ctxt->myDoc);
 1388|      0|	    xmlXIncludeSetFlags(reader->xincctxt,
 1389|      0|	                        reader->parserFlags & (~XML_PARSE_NOXINCNODE));
 1390|      0|            xmlXIncludeSetStreamingMode(reader->xincctxt, 1);
 1391|      0|	}
 1392|       |	/*
 1393|       |	 * expand that node and process it
 1394|       |	 */
 1395|      0|	if (xmlTextReaderExpand(reader) == NULL)
  ------------------
  |  Branch (1395:6): [True: 0, False: 0]
  ------------------
 1396|      0|	    return -1;
 1397|      0|	xmlXIncludeProcessNode(reader->xincctxt, reader->node);
 1398|      0|    }
 1399|  36.1k|    if ((reader->node != NULL) && (reader->node->type == XML_XINCLUDE_START)) {
  ------------------
  |  Branch (1399:9): [True: 36.1k, False: 0]
  |  Branch (1399:35): [True: 0, False: 36.1k]
  ------------------
 1400|      0|        reader->in_xinclude++;
 1401|      0|	goto get_next_node;
 1402|      0|    }
 1403|  36.1k|    if ((reader->node != NULL) && (reader->node->type == XML_XINCLUDE_END)) {
  ------------------
  |  Branch (1403:9): [True: 36.1k, False: 0]
  |  Branch (1403:35): [True: 0, False: 36.1k]
  ------------------
 1404|      0|        reader->in_xinclude--;
 1405|      0|	goto get_next_node;
 1406|      0|    }
 1407|  36.1k|#endif
 1408|       |    /*
 1409|       |     * Handle entities enter and exit when in entity replacement mode
 1410|       |     */
 1411|  36.1k|    if ((reader->node != NULL) &&
  ------------------
  |  Branch (1411:9): [True: 36.1k, False: 0]
  ------------------
 1412|  36.1k|	(reader->node->type == XML_ENTITY_REF_NODE) &&
  ------------------
  |  Branch (1412:2): [True: 1, False: 36.1k]
  ------------------
 1413|  36.1k|	(reader->ctxt != NULL) && (reader->ctxt->replaceEntities == 1)) {
  ------------------
  |  Branch (1413:2): [True: 1, False: 0]
  |  Branch (1413:28): [True: 1, False: 0]
  ------------------
 1414|      1|	if ((reader->node->children != NULL) &&
  ------------------
  |  Branch (1414:6): [True: 0, False: 1]
  ------------------
 1415|      1|	    (reader->node->children->type == XML_ENTITY_DECL) &&
  ------------------
  |  Branch (1415:6): [True: 0, False: 0]
  ------------------
 1416|      1|	    (reader->node->children->children != NULL)) {
  ------------------
  |  Branch (1416:6): [True: 0, False: 0]
  ------------------
 1417|      0|	    if (xmlTextReaderEntPush(reader, reader->node) < 0)
  ------------------
  |  Branch (1417:10): [True: 0, False: 0]
  ------------------
 1418|      0|                goto get_next_node;
 1419|      0|	    reader->node = reader->node->children->children;
 1420|      0|	}
 1421|      1|#ifdef LIBXML_REGEXP_ENABLED
 1422|  36.1k|    } else if ((reader->node != NULL) &&
  ------------------
  |  Branch (1422:16): [True: 36.1k, False: 0]
  ------------------
 1423|  36.1k|	       (reader->node->type == XML_ENTITY_REF_NODE) &&
  ------------------
  |  Branch (1423:9): [True: 0, False: 36.1k]
  ------------------
 1424|  36.1k|	       (reader->ctxt != NULL) && (reader->validate)) {
  ------------------
  |  Branch (1424:9): [True: 0, False: 0]
  |  Branch (1424:35): [True: 0, False: 0]
  ------------------
 1425|      0|	xmlTextReaderValidateEntity(reader);
 1426|      0|#endif /* LIBXML_REGEXP_ENABLED */
 1427|      0|    }
 1428|  36.1k|    if ((reader->node != NULL) &&
  ------------------
  |  Branch (1428:9): [True: 36.1k, False: 0]
  ------------------
 1429|  36.1k|	(reader->node->type == XML_ENTITY_DECL) &&
  ------------------
  |  Branch (1429:2): [True: 0, False: 36.1k]
  ------------------
 1430|  36.1k|	(reader->ent != NULL) && (reader->ent->children == reader->node)) {
  ------------------
  |  Branch (1430:2): [True: 0, False: 0]
  |  Branch (1430:27): [True: 0, False: 0]
  ------------------
 1431|      0|	reader->node = xmlTextReaderEntPop(reader);
 1432|      0|	reader->depth++;
 1433|      0|        goto get_next_node;
 1434|      0|    }
 1435|  36.1k|#ifdef LIBXML_REGEXP_ENABLED
 1436|  36.1k|    if ((reader->validate != XML_TEXTREADER_NOT_VALIDATE) && (reader->node != NULL)) {
  ------------------
  |  Branch (1436:9): [True: 36.1k, False: 0]
  |  Branch (1436:62): [True: 36.1k, False: 0]
  ------------------
 1437|  36.1k|	xmlNodePtr node = reader->node;
 1438|       |
 1439|  36.1k|	if ((node->type == XML_ELEMENT_NODE) &&
  ------------------
  |  Branch (1439:6): [True: 18.4k, False: 17.6k]
  ------------------
 1440|  36.1k|            ((reader->state != XML_TEXTREADER_END) &&
  ------------------
  |  Branch (1440:14): [True: 18.3k, False: 27]
  ------------------
 1441|  18.4k|	     (reader->state != XML_TEXTREADER_BACKTRACK))) {
  ------------------
  |  Branch (1441:7): [True: 14.2k, False: 4.14k]
  ------------------
 1442|  14.2k|	    xmlTextReaderValidatePush(reader);
 1443|  21.8k|	} else if ((node->type == XML_TEXT_NODE) ||
  ------------------
  |  Branch (1443:13): [True: 17.3k, False: 4.53k]
  ------------------
 1444|  21.8k|		   (node->type == XML_CDATA_SECTION_NODE)) {
  ------------------
  |  Branch (1444:6): [True: 33, False: 4.50k]
  ------------------
 1445|  17.3k|            xmlTextReaderValidateCData(reader, node->content,
 1446|  17.3k|	                               xmlStrlen(node->content));
 1447|  17.3k|	}
 1448|  36.1k|    }
 1449|  36.1k|#endif /* LIBXML_REGEXP_ENABLED */
 1450|  36.1k|#ifdef LIBXML_PATTERN_ENABLED
 1451|  36.1k|    if ((reader->patternNr > 0) && (reader->state != XML_TEXTREADER_END) &&
  ------------------
  |  Branch (1451:9): [True: 0, False: 36.1k]
  |  Branch (1451:36): [True: 0, False: 0]
  ------------------
 1452|  36.1k|        (reader->state != XML_TEXTREADER_BACKTRACK)) {
  ------------------
  |  Branch (1452:9): [True: 0, False: 0]
  ------------------
 1453|      0|        int i;
 1454|      0|	for (i = 0;i < reader->patternNr;i++) {
  ------------------
  |  Branch (1454:13): [True: 0, False: 0]
  ------------------
 1455|      0|	     if (xmlPatternMatch(reader->patternTab[i], reader->node) == 1) {
  ------------------
  |  Branch (1455:11): [True: 0, False: 0]
  ------------------
 1456|      0|	         xmlTextReaderPreserve(reader);
 1457|      0|		 break;
 1458|      0|             }
 1459|      0|	}
 1460|      0|    }
 1461|  36.1k|#endif /* LIBXML_PATTERN_ENABLED */
 1462|  36.1k|#ifdef LIBXML_SCHEMAS_ENABLED
 1463|  36.1k|    if ((reader->validate == XML_TEXTREADER_VALIDATE_XSD) &&
  ------------------
  |  Branch (1463:9): [True: 0, False: 36.1k]
  ------------------
 1464|  36.1k|        (reader->xsdValidErrors == 0) &&
  ------------------
  |  Branch (1464:9): [True: 0, False: 0]
  ------------------
 1465|  36.1k|	(reader->xsdValidCtxt != NULL)) {
  ------------------
  |  Branch (1465:2): [True: 0, False: 0]
  ------------------
 1466|      0|	reader->xsdValidErrors = !xmlSchemaIsValid(reader->xsdValidCtxt);
 1467|      0|    }
 1468|  36.1k|#endif /* LIBXML_PATTERN_ENABLED */
 1469|  36.1k|    return(1);
 1470|    262|node_end:
 1471|    262|    reader->state = XML_TEXTREADER_DONE;
 1472|    262|    return(0);
 1473|  36.1k|}
xmlTextReaderExpand:
 1501|  4.45k|xmlTextReaderExpand(xmlTextReaderPtr reader) {
 1502|  4.45k|    if ((reader == NULL) || (reader->node == NULL))
  ------------------
  |  Branch (1502:9): [True: 0, False: 4.45k]
  |  Branch (1502:29): [True: 0, False: 4.45k]
  ------------------
 1503|      0|        return(NULL);
 1504|  4.45k|    if (reader->doc != NULL)
  ------------------
  |  Branch (1504:9): [True: 0, False: 4.45k]
  ------------------
 1505|      0|        return(reader->node);
 1506|  4.45k|    if (reader->ctxt == NULL)
  ------------------
  |  Branch (1506:9): [True: 0, False: 4.45k]
  ------------------
 1507|      0|        return(NULL);
 1508|  4.45k|    if (xmlTextReaderDoExpand(reader) < 0)
  ------------------
  |  Branch (1508:9): [True: 1, False: 4.45k]
  ------------------
 1509|      1|        return(NULL);
 1510|  4.45k|    return(reader->node);
 1511|  4.45k|}
xmlNewTextReader:
 1935|    323|xmlNewTextReader(xmlParserInputBufferPtr input, const char *URI) {
 1936|    323|    xmlTextReaderPtr ret;
 1937|       |
 1938|    323|    if (input == NULL)
  ------------------
  |  Branch (1938:9): [True: 0, False: 323]
  ------------------
 1939|      0|	return(NULL);
 1940|    323|    ret = xmlMalloc(sizeof(xmlTextReader));
 1941|    323|    if (ret == NULL) {
  ------------------
  |  Branch (1941:9): [True: 0, False: 323]
  ------------------
 1942|      0|        xmlGenericError(xmlGenericErrorContext,
  ------------------
  |  |  875|      0|  #define xmlGenericError XML_GLOBAL_MACRO(xmlGenericError)
  |  |  ------------------
  |  |  |  |  500|      0|  #define XML_GLOBAL_MACRO(name) (*__##name())
  |  |  ------------------
  ------------------
                      xmlGenericError(xmlGenericErrorContext,
  ------------------
  |  |  876|      0|  #define xmlGenericErrorContext XML_GLOBAL_MACRO(xmlGenericErrorContext)
  |  |  ------------------
  |  |  |  |  500|      0|  #define XML_GLOBAL_MACRO(name) (*__##name())
  |  |  ------------------
  ------------------
 1943|      0|		"xmlNewTextReader : malloc failed\n");
 1944|      0|	return(NULL);
 1945|      0|    }
 1946|    323|    memset(ret, 0, sizeof(xmlTextReader));
 1947|    323|    ret->doc = NULL;
 1948|    323|    ret->entTab = NULL;
 1949|    323|    ret->entMax = 0;
 1950|    323|    ret->entNr = 0;
 1951|    323|    ret->input = input;
 1952|    323|    ret->buffer = xmlBufCreateSize(100);
 1953|    323|    if (ret->buffer == NULL) {
  ------------------
  |  Branch (1953:9): [True: 0, False: 323]
  ------------------
 1954|      0|        xmlFree(ret);
 1955|      0|        xmlGenericError(xmlGenericErrorContext,
  ------------------
  |  |  875|      0|  #define xmlGenericError XML_GLOBAL_MACRO(xmlGenericError)
  |  |  ------------------
  |  |  |  |  500|      0|  #define XML_GLOBAL_MACRO(name) (*__##name())
  |  |  ------------------
  ------------------
                      xmlGenericError(xmlGenericErrorContext,
  ------------------
  |  |  876|      0|  #define xmlGenericErrorContext XML_GLOBAL_MACRO(xmlGenericErrorContext)
  |  |  ------------------
  |  |  |  |  500|      0|  #define XML_GLOBAL_MACRO(name) (*__##name())
  |  |  ------------------
  ------------------
 1956|      0|		"xmlNewTextReader : malloc failed\n");
 1957|      0|	return(NULL);
 1958|      0|    }
 1959|       |    /* no operation on a reader should require a huge buffer */
 1960|    323|    xmlBufSetAllocationScheme(ret->buffer,
 1961|    323|			      XML_BUFFER_ALLOC_DOUBLEIT);
 1962|    323|    ret->sax = (xmlSAXHandler *) xmlMalloc(sizeof(xmlSAXHandler));
 1963|    323|    if (ret->sax == NULL) {
  ------------------
  |  Branch (1963:9): [True: 0, False: 323]
  ------------------
 1964|      0|	xmlBufFree(ret->buffer);
 1965|      0|	xmlFree(ret);
 1966|      0|        xmlGenericError(xmlGenericErrorContext,
  ------------------
  |  |  875|      0|  #define xmlGenericError XML_GLOBAL_MACRO(xmlGenericError)
  |  |  ------------------
  |  |  |  |  500|      0|  #define XML_GLOBAL_MACRO(name) (*__##name())
  |  |  ------------------
  ------------------
                      xmlGenericError(xmlGenericErrorContext,
  ------------------
  |  |  876|      0|  #define xmlGenericErrorContext XML_GLOBAL_MACRO(xmlGenericErrorContext)
  |  |  ------------------
  |  |  |  |  500|      0|  #define XML_GLOBAL_MACRO(name) (*__##name())
  |  |  ------------------
  ------------------
 1967|      0|		"xmlNewTextReader : malloc failed\n");
 1968|      0|	return(NULL);
 1969|      0|    }
 1970|    323|    xmlSAXVersion(ret->sax, 2);
 1971|    323|    ret->startElement = ret->sax->startElement;
 1972|    323|    ret->sax->startElement = xmlTextReaderStartElement;
 1973|    323|    ret->endElement = ret->sax->endElement;
 1974|    323|    ret->sax->endElement = xmlTextReaderEndElement;
 1975|    323|#ifdef LIBXML_SAX1_ENABLED
 1976|    323|    if (ret->sax->initialized == XML_SAX2_MAGIC) {
  ------------------
  |  |  685|    323|#define XML_SAX2_MAGIC 0xDEEDBEAF
  ------------------
  |  Branch (1976:9): [True: 323, False: 0]
  ------------------
 1977|    323|#endif /* LIBXML_SAX1_ENABLED */
 1978|    323|	ret->startElementNs = ret->sax->startElementNs;
 1979|    323|	ret->sax->startElementNs = xmlTextReaderStartElementNs;
 1980|    323|	ret->endElementNs = ret->sax->endElementNs;
 1981|    323|	ret->sax->endElementNs = xmlTextReaderEndElementNs;
 1982|    323|#ifdef LIBXML_SAX1_ENABLED
 1983|    323|    } else {
 1984|      0|	ret->startElementNs = NULL;
 1985|      0|	ret->endElementNs = NULL;
 1986|      0|    }
 1987|    323|#endif /* LIBXML_SAX1_ENABLED */
 1988|    323|    ret->characters = ret->sax->characters;
 1989|    323|    ret->sax->characters = xmlTextReaderCharacters;
 1990|    323|    ret->sax->ignorableWhitespace = xmlTextReaderCharacters;
 1991|    323|    ret->cdataBlock = ret->sax->cdataBlock;
 1992|    323|    ret->sax->cdataBlock = xmlTextReaderCDataBlock;
 1993|       |
 1994|    323|    ret->mode = XML_TEXTREADER_MODE_INITIAL;
 1995|    323|    ret->node = NULL;
 1996|    323|    ret->curnode = NULL;
 1997|    323|    if (xmlBufUse(ret->input->buffer) < 4) {
  ------------------
  |  Branch (1997:9): [True: 323, False: 0]
  ------------------
 1998|    323|	xmlParserInputBufferRead(input, 4);
 1999|    323|    }
 2000|    323|    if (xmlBufUse(ret->input->buffer) >= 4) {
  ------------------
  |  Branch (2000:9): [True: 310, False: 13]
  ------------------
 2001|    310|	ret->ctxt = xmlCreatePushParserCtxt(ret->sax, NULL,
 2002|    310|			     (const char *) xmlBufContent(ret->input->buffer),
 2003|    310|                                            4, URI);
 2004|    310|	ret->base = 0;
 2005|    310|	ret->cur = 4;
 2006|    310|    } else {
 2007|     13|	ret->ctxt = xmlCreatePushParserCtxt(ret->sax, NULL, NULL, 0, URI);
 2008|     13|	ret->base = 0;
 2009|     13|	ret->cur = 0;
 2010|     13|    }
 2011|       |
 2012|    323|    if (ret->ctxt == NULL) {
  ------------------
  |  Branch (2012:9): [True: 0, False: 323]
  ------------------
 2013|      0|        xmlGenericError(xmlGenericErrorContext,
  ------------------
  |  |  875|      0|  #define xmlGenericError XML_GLOBAL_MACRO(xmlGenericError)
  |  |  ------------------
  |  |  |  |  500|      0|  #define XML_GLOBAL_MACRO(name) (*__##name())
  |  |  ------------------
  ------------------
                      xmlGenericError(xmlGenericErrorContext,
  ------------------
  |  |  876|      0|  #define xmlGenericErrorContext XML_GLOBAL_MACRO(xmlGenericErrorContext)
  |  |  ------------------
  |  |  |  |  500|      0|  #define XML_GLOBAL_MACRO(name) (*__##name())
  |  |  ------------------
  ------------------
 2014|      0|		"xmlNewTextReader : malloc failed\n");
 2015|      0|	xmlBufFree(ret->buffer);
 2016|      0|	xmlFree(ret->sax);
 2017|      0|	xmlFree(ret);
 2018|      0|	return(NULL);
 2019|      0|    }
 2020|    323|    ret->ctxt->parseMode = XML_PARSE_READER;
 2021|    323|    ret->ctxt->_private = ret;
 2022|    323|    ret->ctxt->linenumbers = 1;
 2023|    323|    ret->ctxt->dictNames = 1;
 2024|    323|    ret->allocs = XML_TEXTREADER_CTXT;
  ------------------
  |  |   99|    323|#define XML_TEXTREADER_CTXT	2
  ------------------
 2025|       |    /*
 2026|       |     * use the parser dictionary to allocate all elements and attributes names
 2027|       |     */
 2028|    323|    ret->ctxt->docdict = 1;
 2029|    323|    ret->dict = ret->ctxt->dict;
 2030|    323|#ifdef LIBXML_XINCLUDE_ENABLED
 2031|    323|    ret->xinclude = 0;
 2032|    323|#endif
 2033|    323|#ifdef LIBXML_PATTERN_ENABLED
 2034|    323|    ret->patternMax = 0;
 2035|    323|    ret->patternTab = NULL;
 2036|    323|#endif
 2037|    323|    return(ret);
 2038|    323|}
xmlFreeTextReader:
 2079|    323|xmlFreeTextReader(xmlTextReaderPtr reader) {
 2080|    323|    if (reader == NULL)
  ------------------
  |  Branch (2080:9): [True: 0, False: 323]
  ------------------
 2081|      0|	return;
 2082|    323|#ifdef LIBXML_SCHEMAS_ENABLED
 2083|    323|    if (reader->rngSchemas != NULL) {
  ------------------
  |  Branch (2083:9): [True: 0, False: 323]
  ------------------
 2084|      0|	xmlRelaxNGFree(reader->rngSchemas);
 2085|      0|	reader->rngSchemas = NULL;
 2086|      0|    }
 2087|    323|    if (reader->rngValidCtxt != NULL) {
  ------------------
  |  Branch (2087:9): [True: 0, False: 323]
  ------------------
 2088|      0|	if (! reader->rngPreserveCtxt)
  ------------------
  |  Branch (2088:6): [True: 0, False: 0]
  ------------------
 2089|      0|	    xmlRelaxNGFreeValidCtxt(reader->rngValidCtxt);
 2090|      0|	reader->rngValidCtxt = NULL;
 2091|      0|    }
 2092|    323|    if (reader->xsdPlug != NULL) {
  ------------------
  |  Branch (2092:9): [True: 0, False: 323]
  ------------------
 2093|      0|	xmlSchemaSAXUnplug(reader->xsdPlug);
 2094|      0|	reader->xsdPlug = NULL;
 2095|      0|    }
 2096|    323|    if (reader->xsdValidCtxt != NULL) {
  ------------------
  |  Branch (2096:9): [True: 0, False: 323]
  ------------------
 2097|      0|	if (! reader->xsdPreserveCtxt)
  ------------------
  |  Branch (2097:6): [True: 0, False: 0]
  ------------------
 2098|      0|	    xmlSchemaFreeValidCtxt(reader->xsdValidCtxt);
 2099|      0|	reader->xsdValidCtxt = NULL;
 2100|      0|    }
 2101|    323|    if (reader->xsdSchemas != NULL) {
  ------------------
  |  Branch (2101:9): [True: 0, False: 323]
  ------------------
 2102|      0|	xmlSchemaFree(reader->xsdSchemas);
 2103|      0|	reader->xsdSchemas = NULL;
 2104|      0|    }
 2105|    323|#endif
 2106|    323|#ifdef LIBXML_XINCLUDE_ENABLED
 2107|    323|    if (reader->xincctxt != NULL)
  ------------------
  |  Branch (2107:9): [True: 0, False: 323]
  ------------------
 2108|      0|	xmlXIncludeFreeContext(reader->xincctxt);
 2109|    323|#endif
 2110|    323|#ifdef LIBXML_PATTERN_ENABLED
 2111|    323|    if (reader->patternTab != NULL) {
  ------------------
  |  Branch (2111:9): [True: 0, False: 323]
  ------------------
 2112|      0|        int i;
 2113|      0|	for (i = 0;i < reader->patternNr;i++) {
  ------------------
  |  Branch (2113:13): [True: 0, False: 0]
  ------------------
 2114|      0|	    if (reader->patternTab[i] != NULL)
  ------------------
  |  Branch (2114:10): [True: 0, False: 0]
  ------------------
 2115|      0|	        xmlFreePattern(reader->patternTab[i]);
 2116|      0|	}
 2117|      0|	xmlFree(reader->patternTab);
 2118|      0|    }
 2119|    323|#endif
 2120|    323|    if (reader->mode != XML_TEXTREADER_MODE_CLOSED)
  ------------------
  |  Branch (2120:9): [True: 323, False: 0]
  ------------------
 2121|    323|        xmlTextReaderClose(reader);
 2122|    323|    if (reader->ctxt != NULL) {
  ------------------
  |  Branch (2122:9): [True: 323, False: 0]
  ------------------
 2123|    323|        if (reader->dict == reader->ctxt->dict)
  ------------------
  |  Branch (2123:13): [True: 323, False: 0]
  ------------------
 2124|    323|	    reader->dict = NULL;
 2125|    323|	if (reader->allocs & XML_TEXTREADER_CTXT)
  ------------------
  |  |   99|    323|#define XML_TEXTREADER_CTXT	2
  ------------------
  |  Branch (2125:6): [True: 323, False: 0]
  ------------------
 2126|    323|	    xmlFreeParserCtxt(reader->ctxt);
 2127|    323|    }
 2128|    323|    if (reader->sax != NULL)
  ------------------
  |  Branch (2128:9): [True: 323, False: 0]
  ------------------
 2129|    323|	xmlFree(reader->sax);
 2130|    323|    if (reader->buffer != NULL)
  ------------------
  |  Branch (2130:9): [True: 323, False: 0]
  ------------------
 2131|    323|        xmlBufFree(reader->buffer);
 2132|    323|    if (reader->entTab != NULL)
  ------------------
  |  Branch (2132:9): [True: 0, False: 323]
  ------------------
 2133|      0|	xmlFree(reader->entTab);
 2134|    323|    if (reader->dict != NULL)
  ------------------
  |  Branch (2134:9): [True: 0, False: 323]
  ------------------
 2135|      0|        xmlDictFree(reader->dict);
 2136|    323|    xmlFree(reader);
 2137|    323|}
xmlTextReaderClose:
 2154|    323|xmlTextReaderClose(xmlTextReaderPtr reader) {
 2155|    323|    if (reader == NULL)
  ------------------
  |  Branch (2155:9): [True: 0, False: 323]
  ------------------
 2156|      0|	return(-1);
 2157|    323|    reader->node = NULL;
 2158|    323|    reader->curnode = NULL;
 2159|    323|    reader->mode = XML_TEXTREADER_MODE_CLOSED;
 2160|    323|    if (reader->faketext != NULL) {
  ------------------
  |  Branch (2160:9): [True: 66, False: 257]
  ------------------
 2161|     66|        xmlFreeNode(reader->faketext);
 2162|     66|        reader->faketext = NULL;
 2163|     66|    }
 2164|    323|    if (reader->ctxt != NULL) {
  ------------------
  |  Branch (2164:9): [True: 323, False: 0]
  ------------------
 2165|    323|#ifdef LIBXML_VALID_ENABLED
 2166|    323|	if ((reader->ctxt->vctxt.vstateTab != NULL) &&
  ------------------
  |  Branch (2166:6): [True: 123, False: 200]
  ------------------
 2167|    323|	    (reader->ctxt->vctxt.vstateMax > 0)){
  ------------------
  |  Branch (2167:6): [True: 123, False: 0]
  ------------------
 2168|    123|#ifdef LIBXML_REGEXP_ENABLED
 2169|    126|            while (reader->ctxt->vctxt.vstateNr > 0)
  ------------------
  |  Branch (2169:20): [True: 3, False: 123]
  ------------------
 2170|      3|                xmlValidatePopElement(&reader->ctxt->vctxt, NULL, NULL, NULL);
 2171|    123|#endif /* LIBXML_REGEXP_ENABLED */
 2172|    123|	    xmlFree(reader->ctxt->vctxt.vstateTab);
 2173|    123|	    reader->ctxt->vctxt.vstateTab = NULL;
 2174|    123|	    reader->ctxt->vctxt.vstateMax = 0;
 2175|    123|	}
 2176|    323|#endif /* LIBXML_VALID_ENABLED */
 2177|    323|	xmlStopParser(reader->ctxt);
 2178|    323|	if (reader->ctxt->myDoc != NULL) {
  ------------------
  |  Branch (2178:6): [True: 322, False: 1]
  ------------------
 2179|    322|	    if (reader->preserve == 0)
  ------------------
  |  Branch (2179:10): [True: 322, False: 0]
  ------------------
 2180|    322|		xmlTextReaderFreeDoc(reader, reader->ctxt->myDoc);
 2181|    322|	    reader->ctxt->myDoc = NULL;
 2182|    322|	}
 2183|    323|    }
 2184|    323|    if ((reader->input != NULL)  && (reader->allocs & XML_TEXTREADER_INPUT)) {
  ------------------
  |  |   98|    323|#define XML_TEXTREADER_INPUT	1
  ------------------
  |  Branch (2184:9): [True: 323, False: 0]
  |  Branch (2184:37): [True: 323, False: 0]
  ------------------
 2185|    323|	xmlFreeParserInputBuffer(reader->input);
 2186|    323|	reader->allocs -= XML_TEXTREADER_INPUT;
  ------------------
  |  |   98|    323|#define XML_TEXTREADER_INPUT	1
  ------------------
 2187|    323|    }
 2188|    323|    return(0);
 2189|    323|}
xmlTextReaderMoveToAttributeNo:
 2448|  21.4k|xmlTextReaderMoveToAttributeNo(xmlTextReaderPtr reader, int no) {
 2449|  21.4k|    int i;
 2450|  21.4k|    xmlAttrPtr cur;
 2451|  21.4k|    xmlNsPtr ns;
 2452|       |
 2453|  21.4k|    if (reader == NULL)
  ------------------
  |  Branch (2453:9): [True: 0, False: 21.4k]
  ------------------
 2454|      0|	return(-1);
 2455|  21.4k|    if (reader->node == NULL)
  ------------------
  |  Branch (2455:9): [True: 0, False: 21.4k]
  ------------------
 2456|      0|	return(-1);
 2457|       |    /* TODO: handle the xmlDecl */
 2458|  21.4k|    if (reader->node->type != XML_ELEMENT_NODE)
  ------------------
  |  Branch (2458:9): [True: 0, False: 21.4k]
  ------------------
 2459|      0|	return(-1);
 2460|       |
 2461|  21.4k|    reader->curnode = NULL;
 2462|       |
 2463|  21.4k|    ns = reader->node->nsDef;
 2464|  21.5k|    for (i = 0;(i < no) && (ns != NULL);i++) {
  ------------------
  |  Branch (2464:16): [True: 9.87k, False: 11.6k]
  |  Branch (2464:28): [True: 78, False: 9.80k]
  ------------------
 2465|     78|	ns = ns->next;
 2466|     78|    }
 2467|  21.4k|    if (ns != NULL) {
  ------------------
  |  Branch (2467:9): [True: 105, False: 21.3k]
  ------------------
 2468|    105|	reader->curnode = (xmlNodePtr) ns;
 2469|    105|	return(1);
 2470|    105|    }
 2471|       |
 2472|  21.3k|    cur = reader->node->properties;
 2473|  21.3k|    if (cur == NULL)
  ------------------
  |  Branch (2473:9): [True: 0, False: 21.3k]
  ------------------
 2474|      0|	return(0);
 2475|  41.8k|    for (;i < no;i++) {
  ------------------
  |  Branch (2475:11): [True: 20.4k, False: 21.3k]
  ------------------
 2476|  20.4k|	cur = cur->next;
 2477|  20.4k|	if (cur == NULL)
  ------------------
  |  Branch (2477:6): [True: 0, False: 20.4k]
  ------------------
 2478|      0|	    return(0);
 2479|  20.4k|    }
 2480|       |    /* TODO walk the DTD if present */
 2481|       |
 2482|  21.3k|    reader->curnode = (xmlNodePtr) cur;
 2483|  21.3k|    return(1);
 2484|  21.3k|}
xmlTextReaderReadAttributeValue:
 2753|  42.9k|xmlTextReaderReadAttributeValue(xmlTextReaderPtr reader) {
 2754|  42.9k|    if (reader == NULL)
  ------------------
  |  Branch (2754:9): [True: 0, False: 42.9k]
  ------------------
 2755|      0|	return(-1);
 2756|  42.9k|    if (reader->node == NULL)
  ------------------
  |  Branch (2756:9): [True: 0, False: 42.9k]
  ------------------
 2757|      0|	return(-1);
 2758|  42.9k|    if (reader->curnode == NULL)
  ------------------
  |  Branch (2758:9): [True: 0, False: 42.9k]
  ------------------
 2759|      0|	return(0);
 2760|  42.9k|    if (reader->curnode->type == XML_ATTRIBUTE_NODE) {
  ------------------
  |  Branch (2760:9): [True: 21.3k, False: 21.5k]
  ------------------
 2761|  21.3k|	if (reader->curnode->children == NULL)
  ------------------
  |  Branch (2761:6): [True: 0, False: 21.3k]
  ------------------
 2762|      0|	    return(0);
 2763|  21.3k|	reader->curnode = reader->curnode->children;
 2764|  21.5k|    } else if (reader->curnode->type == XML_NAMESPACE_DECL) {
  ------------------
  |  Branch (2764:16): [True: 105, False: 21.4k]
  ------------------
 2765|    105|	xmlNsPtr ns = (xmlNsPtr) reader->curnode;
 2766|       |
 2767|    105|	if (reader->faketext == NULL) {
  ------------------
  |  Branch (2767:6): [True: 66, False: 39]
  ------------------
 2768|     66|	    reader->faketext = xmlNewDocText(reader->node->doc,
 2769|     66|		                             ns->href);
 2770|     66|	} else {
 2771|     39|            if ((reader->faketext->content != NULL) &&
  ------------------
  |  Branch (2771:17): [True: 36, False: 3]
  ------------------
 2772|     39|	        (reader->faketext->content !=
  ------------------
  |  Branch (2772:10): [True: 36, False: 0]
  ------------------
 2773|     36|		 (xmlChar *) &(reader->faketext->properties)))
 2774|     36|		xmlFree(reader->faketext->content);
 2775|     39|	    reader->faketext->content = xmlStrdup(ns->href);
 2776|     39|	}
 2777|    105|	reader->curnode = reader->faketext;
 2778|  21.4k|    } else {
 2779|  21.4k|	if (reader->curnode->next == NULL)
  ------------------
  |  Branch (2779:6): [True: 21.4k, False: 0]
  ------------------
 2780|  21.4k|	    return(0);
 2781|      0|	reader->curnode = reader->curnode->next;
 2782|      0|    }
 2783|  21.4k|    return(1);
 2784|  42.9k|}
xmlTextReaderAttributeCount:
 2828|  14.2k|xmlTextReaderAttributeCount(xmlTextReaderPtr reader) {
 2829|  14.2k|    int ret;
 2830|  14.2k|    xmlAttrPtr attr;
 2831|  14.2k|    xmlNsPtr ns;
 2832|  14.2k|    xmlNodePtr node;
 2833|       |
 2834|  14.2k|    if (reader == NULL)
  ------------------
  |  Branch (2834:9): [True: 0, False: 14.2k]
  ------------------
 2835|      0|	return(-1);
 2836|  14.2k|    if (reader->node == NULL)
  ------------------
  |  Branch (2836:9): [True: 0, False: 14.2k]
  ------------------
 2837|      0|	return(0);
 2838|       |
 2839|  14.2k|    if (reader->curnode != NULL)
  ------------------
  |  Branch (2839:9): [True: 0, False: 14.2k]
  ------------------
 2840|      0|	node = reader->curnode;
 2841|  14.2k|    else
 2842|  14.2k|	node = reader->node;
 2843|       |
 2844|  14.2k|    if (node->type != XML_ELEMENT_NODE)
  ------------------
  |  Branch (2844:9): [True: 0, False: 14.2k]
  ------------------
 2845|      0|	return(0);
 2846|  14.2k|    if ((reader->state == XML_TEXTREADER_END) ||
  ------------------
  |  Branch (2846:9): [True: 0, False: 14.2k]
  ------------------
 2847|  14.2k|	(reader->state == XML_TEXTREADER_BACKTRACK))
  ------------------
  |  Branch (2847:2): [True: 0, False: 14.2k]
  ------------------
 2848|      0|	return(0);
 2849|  14.2k|    ret = 0;
 2850|  14.2k|    attr = node->properties;
 2851|  35.5k|    while (attr != NULL) {
  ------------------
  |  Branch (2851:12): [True: 21.3k, False: 14.2k]
  ------------------
 2852|  21.3k|	ret++;
 2853|  21.3k|	attr = attr->next;
 2854|  21.3k|    }
 2855|  14.2k|    ns = node->nsDef;
 2856|  14.3k|    while (ns != NULL) {
  ------------------
  |  Branch (2856:12): [True: 105, False: 14.2k]
  ------------------
 2857|    105|	ret++;
 2858|    105|	ns = ns->next;
 2859|    105|    }
 2860|  14.2k|    return(ret);
 2861|  14.2k|}
xmlTextReaderNodeType:
 2874|  36.0k|xmlTextReaderNodeType(xmlTextReaderPtr reader) {
 2875|  36.0k|    xmlNodePtr node;
 2876|       |
 2877|  36.0k|    if (reader == NULL)
  ------------------
  |  Branch (2877:9): [True: 0, False: 36.0k]
  ------------------
 2878|      0|	return(-1);
 2879|  36.0k|    if (reader->node == NULL)
  ------------------
  |  Branch (2879:9): [True: 0, False: 36.0k]
  ------------------
 2880|      0|	return(XML_READER_TYPE_NONE);
 2881|  36.0k|    if (reader->curnode != NULL)
  ------------------
  |  Branch (2881:9): [True: 0, False: 36.0k]
  ------------------
 2882|      0|	node = reader->curnode;
 2883|  36.0k|    else
 2884|  36.0k|	node = reader->node;
 2885|  36.0k|    switch (node->type) {
  ------------------
  |  Branch (2885:13): [True: 0, False: 36.0k]
  ------------------
 2886|  18.3k|        case XML_ELEMENT_NODE:
  ------------------
  |  Branch (2886:9): [True: 18.3k, False: 17.6k]
  ------------------
 2887|  18.3k|	    if ((reader->state == XML_TEXTREADER_END) ||
  ------------------
  |  Branch (2887:10): [True: 22, False: 18.3k]
  ------------------
 2888|  18.3k|		(reader->state == XML_TEXTREADER_BACKTRACK))
  ------------------
  |  Branch (2888:3): [True: 4.13k, False: 14.2k]
  ------------------
 2889|  4.16k|		return(XML_READER_TYPE_END_ELEMENT);
 2890|  14.2k|	    return(XML_READER_TYPE_ELEMENT);
 2891|      0|        case XML_NAMESPACE_DECL:
  ------------------
  |  Branch (2891:9): [True: 0, False: 36.0k]
  ------------------
 2892|      0|        case XML_ATTRIBUTE_NODE:
  ------------------
  |  Branch (2892:9): [True: 0, False: 36.0k]
  ------------------
 2893|      0|	    return(XML_READER_TYPE_ATTRIBUTE);
 2894|  17.3k|        case XML_TEXT_NODE:
  ------------------
  |  Branch (2894:9): [True: 17.3k, False: 18.7k]
  ------------------
 2895|  17.3k|	    if (xmlIsBlankNode(reader->node)) {
  ------------------
  |  Branch (2895:10): [True: 13.7k, False: 3.59k]
  ------------------
 2896|  13.7k|		if (xmlNodeGetSpacePreserve(reader->node))
  ------------------
  |  Branch (2896:7): [True: 13.7k, False: 0]
  ------------------
 2897|  13.7k|		    return(XML_READER_TYPE_SIGNIFICANT_WHITESPACE);
 2898|      0|		else
 2899|      0|		    return(XML_READER_TYPE_WHITESPACE);
 2900|  13.7k|	    } else {
 2901|  3.59k|		return(XML_READER_TYPE_TEXT);
 2902|  3.59k|	    }
 2903|     33|        case XML_CDATA_SECTION_NODE:
  ------------------
  |  Branch (2903:9): [True: 33, False: 36.0k]
  ------------------
 2904|     33|	    return(XML_READER_TYPE_CDATA);
 2905|      1|        case XML_ENTITY_REF_NODE:
  ------------------
  |  Branch (2905:9): [True: 1, False: 36.0k]
  ------------------
 2906|      1|	    return(XML_READER_TYPE_ENTITY_REFERENCE);
 2907|      0|        case XML_ENTITY_NODE:
  ------------------
  |  Branch (2907:9): [True: 0, False: 36.0k]
  ------------------
 2908|      0|	    return(XML_READER_TYPE_ENTITY);
 2909|     18|        case XML_PI_NODE:
  ------------------
  |  Branch (2909:9): [True: 18, False: 36.0k]
  ------------------
 2910|     18|	    return(XML_READER_TYPE_PROCESSING_INSTRUCTION);
 2911|    149|        case XML_COMMENT_NODE:
  ------------------
  |  Branch (2911:9): [True: 149, False: 35.9k]
  ------------------
 2912|    149|	    return(XML_READER_TYPE_COMMENT);
 2913|      0|        case XML_DOCUMENT_NODE:
  ------------------
  |  Branch (2913:9): [True: 0, False: 36.0k]
  ------------------
 2914|      0|        case XML_HTML_DOCUMENT_NODE:
  ------------------
  |  Branch (2914:9): [True: 0, False: 36.0k]
  ------------------
 2915|      0|	    return(XML_READER_TYPE_DOCUMENT);
 2916|      0|        case XML_DOCUMENT_FRAG_NODE:
  ------------------
  |  Branch (2916:9): [True: 0, False: 36.0k]
  ------------------
 2917|      0|	    return(XML_READER_TYPE_DOCUMENT_FRAGMENT);
 2918|      0|        case XML_NOTATION_NODE:
  ------------------
  |  Branch (2918:9): [True: 0, False: 36.0k]
  ------------------
 2919|      0|	    return(XML_READER_TYPE_NOTATION);
 2920|      0|        case XML_DOCUMENT_TYPE_NODE:
  ------------------
  |  Branch (2920:9): [True: 0, False: 36.0k]
  ------------------
 2921|    165|        case XML_DTD_NODE:
  ------------------
  |  Branch (2921:9): [True: 165, False: 35.9k]
  ------------------
 2922|    165|	    return(XML_READER_TYPE_DOCUMENT_TYPE);
 2923|       |
 2924|      0|        case XML_ELEMENT_DECL:
  ------------------
  |  Branch (2924:9): [True: 0, False: 36.0k]
  ------------------
 2925|      0|        case XML_ATTRIBUTE_DECL:
  ------------------
  |  Branch (2925:9): [True: 0, False: 36.0k]
  ------------------
 2926|      0|        case XML_ENTITY_DECL:
  ------------------
  |  Branch (2926:9): [True: 0, False: 36.0k]
  ------------------
 2927|      0|        case XML_XINCLUDE_START:
  ------------------
  |  Branch (2927:9): [True: 0, False: 36.0k]
  ------------------
 2928|      0|        case XML_XINCLUDE_END:
  ------------------
  |  Branch (2928:9): [True: 0, False: 36.0k]
  ------------------
 2929|      0|	    return(XML_READER_TYPE_NONE);
 2930|  36.0k|    }
 2931|      0|    return(-1);
 2932|  36.0k|}
xmlTextReaderSetup:
 4983|    323|{
 4984|    323|    if (reader == NULL) {
  ------------------
  |  Branch (4984:9): [True: 0, False: 323]
  ------------------
 4985|      0|        if (input != NULL)
  ------------------
  |  Branch (4985:13): [True: 0, False: 0]
  ------------------
 4986|      0|	    xmlFreeParserInputBuffer(input);
 4987|      0|        return (-1);
 4988|      0|    }
 4989|       |
 4990|       |    /*
 4991|       |     * we force the generation of compact text nodes on the reader
 4992|       |     * since usr applications should never modify the tree
 4993|       |     */
 4994|    323|    options |= XML_PARSE_COMPACT;
 4995|       |
 4996|    323|    reader->doc = NULL;
 4997|    323|    reader->entNr = 0;
 4998|    323|    reader->parserFlags = options;
 4999|    323|    reader->validate = XML_TEXTREADER_NOT_VALIDATE;
 5000|    323|    if ((input != NULL) && (reader->input != NULL) &&
  ------------------
  |  Branch (5000:9): [True: 0, False: 323]
  |  Branch (5000:28): [True: 0, False: 0]
  ------------------
 5001|    323|        (reader->allocs & XML_TEXTREADER_INPUT)) {
  ------------------
  |  |   98|      0|#define XML_TEXTREADER_INPUT	1
  ------------------
  |  Branch (5001:9): [True: 0, False: 0]
  ------------------
 5002|      0|	xmlFreeParserInputBuffer(reader->input);
 5003|      0|	reader->input = NULL;
 5004|      0|	reader->allocs -= XML_TEXTREADER_INPUT;
  ------------------
  |  |   98|      0|#define XML_TEXTREADER_INPUT	1
  ------------------
 5005|      0|    }
 5006|    323|    if (input != NULL) {
  ------------------
  |  Branch (5006:9): [True: 0, False: 323]
  ------------------
 5007|      0|	reader->input = input;
 5008|      0|	reader->allocs |= XML_TEXTREADER_INPUT;
  ------------------
  |  |   98|      0|#define XML_TEXTREADER_INPUT	1
  ------------------
 5009|      0|    }
 5010|    323|    if (reader->buffer == NULL)
  ------------------
  |  Branch (5010:9): [True: 0, False: 323]
  ------------------
 5011|      0|        reader->buffer = xmlBufCreateSize(100);
 5012|    323|    if (reader->buffer == NULL) {
  ------------------
  |  Branch (5012:9): [True: 0, False: 323]
  ------------------
 5013|      0|        xmlGenericError(xmlGenericErrorContext,
  ------------------
  |  |  875|      0|  #define xmlGenericError XML_GLOBAL_MACRO(xmlGenericError)
  |  |  ------------------
  |  |  |  |  500|      0|  #define XML_GLOBAL_MACRO(name) (*__##name())
  |  |  ------------------
  ------------------
                      xmlGenericError(xmlGenericErrorContext,
  ------------------
  |  |  876|      0|  #define xmlGenericErrorContext XML_GLOBAL_MACRO(xmlGenericErrorContext)
  |  |  ------------------
  |  |  |  |  500|      0|  #define XML_GLOBAL_MACRO(name) (*__##name())
  |  |  ------------------
  ------------------
 5014|      0|                        "xmlTextReaderSetup : malloc failed\n");
 5015|      0|        return (-1);
 5016|      0|    }
 5017|       |    /* no operation on a reader should require a huge buffer */
 5018|    323|    xmlBufSetAllocationScheme(reader->buffer,
 5019|    323|			      XML_BUFFER_ALLOC_DOUBLEIT);
 5020|    323|    if (reader->sax == NULL)
  ------------------
  |  Branch (5020:9): [True: 0, False: 323]
  ------------------
 5021|      0|	reader->sax = (xmlSAXHandler *) xmlMalloc(sizeof(xmlSAXHandler));
 5022|    323|    if (reader->sax == NULL) {
  ------------------
  |  Branch (5022:9): [True: 0, False: 323]
  ------------------
 5023|      0|        xmlGenericError(xmlGenericErrorContext,
  ------------------
  |  |  875|      0|  #define xmlGenericError XML_GLOBAL_MACRO(xmlGenericError)
  |  |  ------------------
  |  |  |  |  500|      0|  #define XML_GLOBAL_MACRO(name) (*__##name())
  |  |  ------------------
  ------------------
                      xmlGenericError(xmlGenericErrorContext,
  ------------------
  |  |  876|      0|  #define xmlGenericErrorContext XML_GLOBAL_MACRO(xmlGenericErrorContext)
  |  |  ------------------
  |  |  |  |  500|      0|  #define XML_GLOBAL_MACRO(name) (*__##name())
  |  |  ------------------
  ------------------
 5024|      0|                        "xmlTextReaderSetup : malloc failed\n");
 5025|      0|        return (-1);
 5026|      0|    }
 5027|    323|    xmlSAXVersion(reader->sax, 2);
 5028|    323|    reader->startElement = reader->sax->startElement;
 5029|    323|    reader->sax->startElement = xmlTextReaderStartElement;
 5030|    323|    reader->endElement = reader->sax->endElement;
 5031|    323|    reader->sax->endElement = xmlTextReaderEndElement;
 5032|    323|#ifdef LIBXML_SAX1_ENABLED
 5033|    323|    if (reader->sax->initialized == XML_SAX2_MAGIC) {
  ------------------
  |  |  685|    323|#define XML_SAX2_MAGIC 0xDEEDBEAF
  ------------------
  |  Branch (5033:9): [True: 323, False: 0]
  ------------------
 5034|    323|#endif /* LIBXML_SAX1_ENABLED */
 5035|    323|        reader->startElementNs = reader->sax->startElementNs;
 5036|    323|        reader->sax->startElementNs = xmlTextReaderStartElementNs;
 5037|    323|        reader->endElementNs = reader->sax->endElementNs;
 5038|    323|        reader->sax->endElementNs = xmlTextReaderEndElementNs;
 5039|    323|#ifdef LIBXML_SAX1_ENABLED
 5040|    323|    } else {
 5041|      0|        reader->startElementNs = NULL;
 5042|      0|        reader->endElementNs = NULL;
 5043|      0|    }
 5044|    323|#endif /* LIBXML_SAX1_ENABLED */
 5045|    323|    reader->characters = reader->sax->characters;
 5046|    323|    reader->sax->characters = xmlTextReaderCharacters;
 5047|    323|    reader->sax->ignorableWhitespace = xmlTextReaderCharacters;
 5048|    323|    reader->cdataBlock = reader->sax->cdataBlock;
 5049|    323|    reader->sax->cdataBlock = xmlTextReaderCDataBlock;
 5050|       |
 5051|    323|    reader->mode = XML_TEXTREADER_MODE_INITIAL;
 5052|    323|    reader->node = NULL;
 5053|    323|    reader->curnode = NULL;
 5054|    323|    if (input != NULL) {
  ------------------
  |  Branch (5054:9): [True: 0, False: 323]
  ------------------
 5055|      0|        if (xmlBufUse(reader->input->buffer) < 4) {
  ------------------
  |  Branch (5055:13): [True: 0, False: 0]
  ------------------
 5056|      0|            xmlParserInputBufferRead(input, 4);
 5057|      0|        }
 5058|      0|        if (reader->ctxt == NULL) {
  ------------------
  |  Branch (5058:13): [True: 0, False: 0]
  ------------------
 5059|      0|            if (xmlBufUse(reader->input->buffer) >= 4) {
  ------------------
  |  Branch (5059:17): [True: 0, False: 0]
  ------------------
 5060|      0|                reader->ctxt = xmlCreatePushParserCtxt(reader->sax, NULL,
 5061|      0|		       (const char *) xmlBufContent(reader->input->buffer),
 5062|      0|                                      4, URL);
 5063|      0|                reader->base = 0;
 5064|      0|                reader->cur = 4;
 5065|      0|            } else {
 5066|      0|                reader->ctxt =
 5067|      0|                    xmlCreatePushParserCtxt(reader->sax, NULL, NULL, 0, URL);
 5068|      0|                reader->base = 0;
 5069|      0|                reader->cur = 0;
 5070|      0|            }
 5071|      0|        } else {
 5072|      0|	    xmlParserInputPtr inputStream;
 5073|      0|	    xmlParserInputBufferPtr buf;
 5074|      0|	    xmlCharEncoding enc = XML_CHAR_ENCODING_NONE;
 5075|       |
 5076|      0|	    xmlCtxtReset(reader->ctxt);
 5077|      0|	    buf = xmlAllocParserInputBuffer(enc);
 5078|      0|	    if (buf == NULL) return(-1);
  ------------------
  |  Branch (5078:10): [True: 0, False: 0]
  ------------------
 5079|      0|	    inputStream = xmlNewInputStream(reader->ctxt);
 5080|      0|	    if (inputStream == NULL) {
  ------------------
  |  Branch (5080:10): [True: 0, False: 0]
  ------------------
 5081|      0|		xmlFreeParserInputBuffer(buf);
 5082|      0|		return(-1);
 5083|      0|	    }
 5084|       |
 5085|      0|	    if (URL == NULL)
  ------------------
  |  Branch (5085:10): [True: 0, False: 0]
  ------------------
 5086|      0|		inputStream->filename = NULL;
 5087|      0|	    else
 5088|      0|		inputStream->filename = (char *)
 5089|      0|		    xmlCanonicPath((const xmlChar *) URL);
 5090|      0|	    inputStream->buf = buf;
 5091|      0|            xmlBufResetInput(buf->buffer, inputStream);
 5092|       |
 5093|      0|	    inputPush(reader->ctxt, inputStream);
 5094|      0|	    reader->cur = 0;
 5095|      0|	}
 5096|      0|        if (reader->ctxt == NULL) {
  ------------------
  |  Branch (5096:13): [True: 0, False: 0]
  ------------------
 5097|      0|            xmlGenericError(xmlGenericErrorContext,
  ------------------
  |  |  875|      0|  #define xmlGenericError XML_GLOBAL_MACRO(xmlGenericError)
  |  |  ------------------
  |  |  |  |  500|      0|  #define XML_GLOBAL_MACRO(name) (*__##name())
  |  |  ------------------
  ------------------
                          xmlGenericError(xmlGenericErrorContext,
  ------------------
  |  |  876|      0|  #define xmlGenericErrorContext XML_GLOBAL_MACRO(xmlGenericErrorContext)
  |  |  ------------------
  |  |  |  |  500|      0|  #define XML_GLOBAL_MACRO(name) (*__##name())
  |  |  ------------------
  ------------------
 5098|      0|                            "xmlTextReaderSetup : malloc failed\n");
 5099|      0|            return (-1);
 5100|      0|        }
 5101|      0|    }
 5102|    323|    if (reader->dict != NULL) {
  ------------------
  |  Branch (5102:9): [True: 323, False: 0]
  ------------------
 5103|    323|        if (reader->ctxt->dict != NULL) {
  ------------------
  |  Branch (5103:13): [True: 323, False: 0]
  ------------------
 5104|    323|	    if (reader->dict != reader->ctxt->dict) {
  ------------------
  |  Branch (5104:10): [True: 0, False: 323]
  ------------------
 5105|      0|		xmlDictFree(reader->dict);
 5106|      0|		reader->dict = reader->ctxt->dict;
 5107|      0|	    }
 5108|    323|	} else {
 5109|      0|	    reader->ctxt->dict = reader->dict;
 5110|      0|	}
 5111|    323|    } else {
 5112|      0|	if (reader->ctxt->dict == NULL)
  ------------------
  |  Branch (5112:6): [True: 0, False: 0]
  ------------------
 5113|      0|	    reader->ctxt->dict = xmlDictCreate();
 5114|      0|        reader->dict = reader->ctxt->dict;
 5115|      0|    }
 5116|    323|    reader->ctxt->_private = reader;
 5117|    323|    reader->ctxt->linenumbers = 1;
 5118|    323|    reader->ctxt->dictNames = 1;
 5119|       |    /*
 5120|       |     * use the parser dictionary to allocate all elements and attributes names
 5121|       |     */
 5122|    323|    reader->ctxt->docdict = 1;
 5123|    323|    reader->ctxt->parseMode = XML_PARSE_READER;
 5124|       |
 5125|    323|#ifdef LIBXML_XINCLUDE_ENABLED
 5126|    323|    if (reader->xincctxt != NULL) {
  ------------------
  |  Branch (5126:9): [True: 0, False: 323]
  ------------------
 5127|      0|	xmlXIncludeFreeContext(reader->xincctxt);
 5128|      0|	reader->xincctxt = NULL;
 5129|      0|    }
 5130|    323|    if (options & XML_PARSE_XINCLUDE) {
  ------------------
  |  Branch (5130:9): [True: 0, False: 323]
  ------------------
 5131|      0|        reader->xinclude = 1;
 5132|      0|	reader->xinclude_name = xmlDictLookup(reader->dict, XINCLUDE_NODE, -1);
  ------------------
  |  |   42|      0|#define XINCLUDE_NODE (const xmlChar *) "include"
  ------------------
 5133|      0|	options -= XML_PARSE_XINCLUDE;
 5134|      0|    } else
 5135|    323|        reader->xinclude = 0;
 5136|    323|    reader->in_xinclude = 0;
 5137|    323|#endif
 5138|    323|#ifdef LIBXML_PATTERN_ENABLED
 5139|    323|    if (reader->patternTab == NULL) {
  ------------------
  |  Branch (5139:9): [True: 323, False: 0]
  ------------------
 5140|    323|        reader->patternNr = 0;
 5141|    323|	reader->patternMax = 0;
 5142|    323|    }
 5143|    323|    while (reader->patternNr > 0) {
  ------------------
  |  Branch (5143:12): [True: 0, False: 323]
  ------------------
 5144|      0|        reader->patternNr--;
 5145|      0|	if (reader->patternTab[reader->patternNr] != NULL) {
  ------------------
  |  Branch (5145:6): [True: 0, False: 0]
  ------------------
 5146|      0|	    xmlFreePattern(reader->patternTab[reader->patternNr]);
 5147|      0|            reader->patternTab[reader->patternNr] = NULL;
 5148|      0|	}
 5149|      0|    }
 5150|    323|#endif
 5151|       |
 5152|    323|    if (options & XML_PARSE_DTDVALID)
  ------------------
  |  Branch (5152:9): [True: 323, False: 0]
  ------------------
 5153|    323|        reader->validate = XML_TEXTREADER_VALIDATE_DTD;
 5154|       |
 5155|    323|    xmlCtxtUseOptions(reader->ctxt, options);
 5156|    323|    if (encoding != NULL) {
  ------------------
  |  Branch (5156:9): [True: 0, False: 323]
  ------------------
 5157|      0|        xmlCharEncodingHandlerPtr hdlr;
 5158|       |
 5159|      0|        hdlr = xmlFindCharEncodingHandler(encoding);
 5160|      0|        if (hdlr != NULL)
  ------------------
  |  Branch (5160:13): [True: 0, False: 0]
  ------------------
 5161|      0|            xmlSwitchToEncoding(reader->ctxt, hdlr);
 5162|      0|    }
 5163|    323|    if ((URL != NULL) && (reader->ctxt->input != NULL) &&
  ------------------
  |  Branch (5163:9): [True: 0, False: 323]
  |  Branch (5163:26): [True: 0, False: 0]
  ------------------
 5164|    323|        (reader->ctxt->input->filename == NULL))
  ------------------
  |  Branch (5164:9): [True: 0, False: 0]
  ------------------
 5165|      0|        reader->ctxt->input->filename = (char *)
 5166|      0|            xmlStrdup((const xmlChar *) URL);
 5167|       |
 5168|    323|    reader->doc = NULL;
 5169|       |
 5170|    323|    return (0);
 5171|    323|}
xmlReaderForMemory:
 5309|    323|{
 5310|    323|    xmlTextReaderPtr reader;
 5311|    323|    xmlParserInputBufferPtr buf;
 5312|       |
 5313|    323|    buf = xmlParserInputBufferCreateMem(buffer, size, XML_CHAR_ENCODING_NONE);
 5314|    323|    if (buf == NULL) {
  ------------------
  |  Branch (5314:9): [True: 0, False: 323]
  ------------------
 5315|      0|        return (NULL);
 5316|      0|    }
 5317|    323|    reader = xmlNewTextReader(buf, URL);
 5318|    323|    if (reader == NULL) {
  ------------------
  |  Branch (5318:9): [True: 0, False: 323]
  ------------------
 5319|      0|        xmlFreeParserInputBuffer(buf);
 5320|      0|        return (NULL);
 5321|      0|    }
 5322|    323|    reader->allocs |= XML_TEXTREADER_INPUT;
  ------------------
  |  |   98|    323|#define XML_TEXTREADER_INPUT	1
  ------------------
 5323|    323|    xmlTextReaderSetup(reader, NULL, URL, encoding, options);
 5324|    323|    return (reader);
 5325|    323|}
xmlreader.c:xmlTextReaderPushData:
  711|  1.98k|xmlTextReaderPushData(xmlTextReaderPtr reader) {
  712|  1.98k|    xmlBufPtr inbuf;
  713|  1.98k|    int val, s;
  714|  1.98k|    xmlTextReaderState oldstate;
  715|       |
  716|  1.98k|    if ((reader->input == NULL) || (reader->input->buffer == NULL))
  ------------------
  |  Branch (716:9): [True: 0, False: 1.98k]
  |  Branch (716:36): [True: 0, False: 1.98k]
  ------------------
  717|      0|	return(-1);
  718|       |
  719|  1.98k|    oldstate = reader->state;
  720|  1.98k|    reader->state = XML_TEXTREADER_NONE;
  721|  1.98k|    inbuf = reader->input->buffer;
  722|       |
  723|  4.18k|    while (reader->state == XML_TEXTREADER_NONE) {
  ------------------
  |  Branch (723:12): [True: 2.82k, False: 1.35k]
  ------------------
  724|  2.82k|	if (xmlBufUse(inbuf) < reader->cur + CHUNK_SIZE) {
  ------------------
  |  |   90|  2.82k|#define CHUNK_SIZE 512
  ------------------
  |  Branch (724:6): [True: 939, False: 1.88k]
  ------------------
  725|       |	    /*
  726|       |	     * Refill the buffer unless we are at the end of the stream
  727|       |	     */
  728|    939|	    if (reader->mode != XML_TEXTREADER_MODE_EOF) {
  ------------------
  |  Branch (728:10): [True: 939, False: 0]
  ------------------
  729|    939|		val = xmlParserInputBufferRead(reader->input, 4096);
  730|    939|		if (val == 0) {
  ------------------
  |  Branch (730:7): [True: 381, False: 558]
  ------------------
  731|    381|		    if (xmlBufUse(inbuf) == reader->cur) {
  ------------------
  |  Branch (731:11): [True: 299, False: 82]
  ------------------
  732|    299|			reader->mode = XML_TEXTREADER_MODE_EOF;
  733|    299|                        break;
  734|    299|		    }
  735|    558|		} else if (val < 0) {
  ------------------
  |  Branch (735:14): [True: 0, False: 558]
  ------------------
  736|      0|                    xmlGenericError(xmlGenericErrorContext,
  ------------------
  |  |  875|      0|  #define xmlGenericError XML_GLOBAL_MACRO(xmlGenericError)
  |  |  ------------------
  |  |  |  |  500|      0|  #define XML_GLOBAL_MACRO(name) (*__##name())
  |  |  ------------------
  ------------------
                                  xmlGenericError(xmlGenericErrorContext,
  ------------------
  |  |  876|      0|  #define xmlGenericErrorContext XML_GLOBAL_MACRO(xmlGenericErrorContext)
  |  |  ------------------
  |  |  |  |  500|      0|  #define XML_GLOBAL_MACRO(name) (*__##name())
  |  |  ------------------
  ------------------
  737|      0|                                    "xmlParserInputBufferRead failed\n");
  738|      0|		    reader->mode = XML_TEXTREADER_MODE_EOF;
  739|      0|		    reader->state = oldstate;
  740|      0|		    return(val);
  741|      0|		}
  742|       |
  743|    939|	    } else
  744|      0|		break;
  745|    939|	}
  746|       |	/*
  747|       |	 * parse by block of CHUNK_SIZE bytes, various tests show that
  748|       |	 * it's the best tradeoff at least on a 1.2GH Duron
  749|       |	 */
  750|  2.52k|	if (xmlBufUse(inbuf) >= reader->cur + CHUNK_SIZE) {
  ------------------
  |  |   90|  2.52k|#define CHUNK_SIZE 512
  ------------------
  |  Branch (750:6): [True: 2.20k, False: 317]
  ------------------
  751|  2.20k|	    val = xmlParseChunk(reader->ctxt,
  752|  2.20k|                 (const char *) xmlBufContent(inbuf) + reader->cur,
  753|  2.20k|                                CHUNK_SIZE, 0);
  ------------------
  |  |   90|  2.20k|#define CHUNK_SIZE 512
  ------------------
  754|  2.20k|	    reader->cur += CHUNK_SIZE;
  ------------------
  |  |   90|  2.20k|#define CHUNK_SIZE 512
  ------------------
  755|  2.20k|	    if (val != 0)
  ------------------
  |  Branch (755:10): [True: 13, False: 2.19k]
  ------------------
  756|     13|		reader->ctxt->wellFormed = 0;
  757|  2.20k|	    if (reader->ctxt->wellFormed == 0)
  ------------------
  |  Branch (757:10): [True: 13, False: 2.19k]
  ------------------
  758|     13|		break;
  759|  2.20k|	} else {
  760|    317|	    s = xmlBufUse(inbuf) - reader->cur;
  761|    317|	    val = xmlParseChunk(reader->ctxt,
  762|    317|		 (const char *) xmlBufContent(inbuf) + reader->cur,
  763|    317|			        s, 0);
  764|    317|	    reader->cur += s;
  765|    317|	    if (val != 0)
  ------------------
  |  Branch (765:10): [True: 31, False: 286]
  ------------------
  766|     31|		reader->ctxt->wellFormed = 0;
  767|    317|	    break;
  768|    317|	}
  769|  2.52k|    }
  770|  1.98k|    reader->state = oldstate;
  771|       |
  772|       |    /*
  773|       |     * Discard the consumed input when needed and possible
  774|       |     */
  775|  1.98k|    if (reader->mode == XML_TEXTREADER_MODE_INTERACTIVE) {
  ------------------
  |  Branch (775:9): [True: 1.67k, False: 309]
  ------------------
  776|  1.67k|        if (reader->input->readcallback != NULL) {
  ------------------
  |  Branch (776:13): [True: 1.67k, False: 0]
  ------------------
  777|  1.67k|	    if ((reader->cur >= 4096) &&
  ------------------
  |  Branch (777:10): [True: 212, False: 1.46k]
  ------------------
  778|  1.67k|		(xmlBufUse(inbuf) - reader->cur <= CHUNK_SIZE)) {
  ------------------
  |  |   90|    212|#define CHUNK_SIZE 512
  ------------------
  |  Branch (778:3): [True: 180, False: 32]
  ------------------
  779|    180|		val = xmlBufShrink(inbuf, reader->cur);
  780|    180|		if (val >= 0) {
  ------------------
  |  Branch (780:7): [True: 180, False: 0]
  ------------------
  781|    180|		    reader->cur -= val;
  782|    180|		}
  783|    180|	    }
  784|  1.67k|	}
  785|  1.67k|    }
  786|       |
  787|       |    /*
  788|       |     * At the end of the stream signal that the work is done to the Push
  789|       |     * parser.
  790|       |     */
  791|    309|    else if (reader->mode == XML_TEXTREADER_MODE_EOF) {
  ------------------
  |  Branch (791:14): [True: 299, False: 10]
  ------------------
  792|    299|	if (reader->state != XML_TEXTREADER_DONE) {
  ------------------
  |  Branch (792:6): [True: 299, False: 0]
  ------------------
  793|    299|	    s = xmlBufUse(inbuf) - reader->cur;
  794|    299|	    val = xmlParseChunk(reader->ctxt,
  795|    299|		 (const char *) xmlBufContent(inbuf) + reader->cur,
  796|    299|			        s, 1);
  797|    299|	    reader->cur = xmlBufUse(inbuf);
  798|    299|	    reader->state  = XML_TEXTREADER_DONE;
  799|    299|	    if (val != 0) {
  ------------------
  |  Branch (799:10): [True: 37, False: 262]
  ------------------
  800|     37|	        if (reader->ctxt->wellFormed)
  ------------------
  |  Branch (800:14): [True: 0, False: 37]
  ------------------
  801|      0|		    reader->ctxt->wellFormed = 0;
  802|     37|		else
  803|     37|		    return(-1);
  804|     37|	    }
  805|    299|	}
  806|    299|    }
  807|  1.95k|    if (reader->ctxt->wellFormed == 0) {
  ------------------
  |  Branch (807:9): [True: 44, False: 1.90k]
  ------------------
  808|     44|	reader->mode = XML_TEXTREADER_MODE_EOF;
  809|     44|        return(-1);
  810|     44|    }
  811|       |
  812|  1.90k|    return(0);
  813|  1.95k|}
xmlreader.c:xmlTextReaderValidatePop:
  913|  14.2k|xmlTextReaderValidatePop(xmlTextReaderPtr reader) {
  914|  14.2k|    xmlNodePtr node = reader->node;
  915|       |
  916|  14.2k|#ifdef LIBXML_VALID_ENABLED
  917|  14.2k|    if ((reader->validate == XML_TEXTREADER_VALIDATE_DTD) &&
  ------------------
  |  Branch (917:9): [True: 14.2k, False: 0]
  ------------------
  918|  14.2k|        (reader->ctxt != NULL) && (reader->ctxt->validate == 1)) {
  ------------------
  |  Branch (918:9): [True: 14.2k, False: 0]
  |  Branch (918:35): [True: 3.40k, False: 10.8k]
  ------------------
  919|  3.40k|	if ((node->ns == NULL) || (node->ns->prefix == NULL)) {
  ------------------
  |  Branch (919:6): [True: 3.32k, False: 81]
  |  Branch (919:28): [True: 4, False: 77]
  ------------------
  920|  3.32k|	    reader->ctxt->valid &= xmlValidatePopElement(&reader->ctxt->vctxt,
  921|  3.32k|				    reader->ctxt->myDoc, node, node->name);
  922|  3.32k|	} else {
  923|       |	    /* TODO use the BuildQName interface */
  924|     77|	    xmlChar *qname;
  925|       |
  926|     77|	    qname = xmlStrdup(node->ns->prefix);
  927|     77|	    qname = xmlStrcat(qname, BAD_CAST ":");
  ------------------
  |  |   35|     77|#define BAD_CAST (xmlChar *)
  ------------------
  928|     77|	    qname = xmlStrcat(qname, node->name);
  929|     77|	    reader->ctxt->valid &= xmlValidatePopElement(&reader->ctxt->vctxt,
  930|     77|				    reader->ctxt->myDoc, node, qname);
  931|     77|	    if (qname != NULL)
  ------------------
  |  Branch (931:10): [True: 77, False: 0]
  ------------------
  932|     77|		xmlFree(qname);
  933|     77|	}
  934|  3.40k|    }
  935|  14.2k|#endif /* LIBXML_VALID_ENABLED */
  936|  14.2k|#ifdef LIBXML_SCHEMAS_ENABLED
  937|  14.2k|    if ((reader->validate == XML_TEXTREADER_VALIDATE_RNG) &&
  ------------------
  |  Branch (937:9): [True: 0, False: 14.2k]
  ------------------
  938|  14.2k|               (reader->rngValidCtxt != NULL)) {
  ------------------
  |  Branch (938:16): [True: 0, False: 0]
  ------------------
  939|      0|	int ret;
  940|       |
  941|      0|	if (reader->rngFullNode != NULL) {
  ------------------
  |  Branch (941:6): [True: 0, False: 0]
  ------------------
  942|      0|	    if (node == reader->rngFullNode)
  ------------------
  |  Branch (942:10): [True: 0, False: 0]
  ------------------
  943|      0|	        reader->rngFullNode = NULL;
  944|      0|	    return;
  945|      0|	}
  946|      0|	ret = xmlRelaxNGValidatePopElement(reader->rngValidCtxt,
  947|      0|	                                   reader->ctxt->myDoc,
  948|      0|					   node);
  949|      0|	if (ret != 1)
  ------------------
  |  Branch (949:6): [True: 0, False: 0]
  ------------------
  950|      0|	    reader->rngValidErrors++;
  951|      0|    }
  952|  14.2k|#endif
  953|  14.2k|}
xmlreader.c:xmlTextReaderFreeNode:
  377|  31.7k|xmlTextReaderFreeNode(xmlTextReaderPtr reader, xmlNodePtr cur) {
  378|  31.7k|    xmlDictPtr dict;
  379|       |
  380|  31.7k|    if ((reader != NULL) && (reader->ctxt != NULL))
  ------------------
  |  Branch (380:9): [True: 31.7k, False: 0]
  |  Branch (380:29): [True: 31.7k, False: 0]
  ------------------
  381|  31.7k|	dict = reader->ctxt->dict;
  382|      0|    else
  383|      0|        dict = NULL;
  384|  31.7k|    if (cur->type == XML_DTD_NODE) {
  ------------------
  |  Branch (384:9): [True: 0, False: 31.7k]
  ------------------
  385|      0|	xmlFreeDtd((xmlDtdPtr) cur);
  386|      0|	return;
  387|      0|    }
  388|  31.7k|    if (cur->type == XML_NAMESPACE_DECL) {
  ------------------
  |  Branch (388:9): [True: 0, False: 31.7k]
  ------------------
  389|      0|	xmlFreeNs((xmlNsPtr) cur);
  390|      0|        return;
  391|      0|    }
  392|  31.7k|    if (cur->type == XML_ATTRIBUTE_NODE) {
  ------------------
  |  Branch (392:9): [True: 0, False: 31.7k]
  ------------------
  393|      0|	xmlTextReaderFreeProp(reader, (xmlAttrPtr) cur);
  394|      0|	return;
  395|      0|    }
  396|       |
  397|  31.7k|    if ((cur->children != NULL) &&
  ------------------
  |  Branch (397:9): [True: 0, False: 31.7k]
  ------------------
  398|  31.7k|	(cur->type != XML_ENTITY_REF_NODE)) {
  ------------------
  |  Branch (398:2): [True: 0, False: 0]
  ------------------
  399|      0|	if (cur->children->parent == cur)
  ------------------
  |  Branch (399:6): [True: 0, False: 0]
  ------------------
  400|      0|	    xmlTextReaderFreeNodeList(reader, cur->children);
  401|      0|	cur->children = NULL;
  402|      0|    }
  403|       |
  404|  31.7k|    if ((__xmlRegisterCallbacks) && (xmlDeregisterNodeDefaultValue))
  ------------------
  |  |  684|      0|    XML_GLOBAL_MACRO(xmlDeregisterNodeDefaultValue)
  |  |  ------------------
  |  |  |  |  500|      0|  #define XML_GLOBAL_MACRO(name) (*__##name())
  |  |  ------------------
  ------------------
  |  Branch (404:9): [True: 0, False: 31.7k]
  |  Branch (404:37): [True: 0, False: 0]
  ------------------
  405|      0|	xmlDeregisterNodeDefaultValue(cur);
  ------------------
  |  |  684|      0|    XML_GLOBAL_MACRO(xmlDeregisterNodeDefaultValue)
  |  |  ------------------
  |  |  |  |  500|      0|  #define XML_GLOBAL_MACRO(name) (*__##name())
  |  |  ------------------
  ------------------
  406|       |
  407|  31.7k|    if (((cur->type == XML_ELEMENT_NODE) ||
  ------------------
  |  Branch (407:10): [True: 14.2k, False: 17.5k]
  ------------------
  408|  31.7k|	 (cur->type == XML_XINCLUDE_START) ||
  ------------------
  |  Branch (408:3): [True: 0, False: 17.5k]
  ------------------
  409|  31.7k|	 (cur->type == XML_XINCLUDE_END)) &&
  ------------------
  |  Branch (409:3): [True: 0, False: 17.5k]
  ------------------
  410|  31.7k|	(cur->properties != NULL))
  ------------------
  |  Branch (410:2): [True: 11.5k, False: 2.68k]
  ------------------
  411|  11.5k|	xmlTextReaderFreePropList(reader, cur->properties);
  412|  31.7k|    if ((cur->content != (xmlChar *) &(cur->properties)) &&
  ------------------
  |  Branch (412:9): [True: 16.2k, False: 15.4k]
  ------------------
  413|  31.7k|        (cur->type != XML_ELEMENT_NODE) &&
  ------------------
  |  Branch (413:9): [True: 2.03k, False: 14.2k]
  ------------------
  414|  31.7k|	(cur->type != XML_XINCLUDE_START) &&
  ------------------
  |  Branch (414:2): [True: 2.03k, False: 0]
  ------------------
  415|  31.7k|	(cur->type != XML_XINCLUDE_END) &&
  ------------------
  |  Branch (415:2): [True: 2.03k, False: 0]
  ------------------
  416|  31.7k|	(cur->type != XML_ENTITY_REF_NODE)) {
  ------------------
  |  Branch (416:2): [True: 2.03k, False: 1]
  ------------------
  417|  2.03k|	DICT_FREE(cur->content);
  ------------------
  |  |  214|  2.03k|	if ((str) && ((!dict) ||				\
  |  |  ------------------
  |  |  |  Branch (214:6): [True: 2.03k, False: 0]
  |  |  |  Branch (214:16): [True: 0, False: 2.03k]
  |  |  ------------------
  |  |  215|  2.03k|	    (xmlDictOwns(dict, (const xmlChar *)(str)) == 0)))	\
  |  |  ------------------
  |  |  |  Branch (215:6): [True: 2.03k, False: 0]
  |  |  ------------------
  |  |  216|  2.03k|	    xmlFree((char *)(str));
  ------------------
  418|  2.03k|    }
  419|  31.7k|    if (((cur->type == XML_ELEMENT_NODE) ||
  ------------------
  |  Branch (419:10): [True: 14.2k, False: 17.5k]
  ------------------
  420|  31.7k|	 (cur->type == XML_XINCLUDE_START) ||
  ------------------
  |  Branch (420:3): [True: 0, False: 17.5k]
  ------------------
  421|  31.7k|	 (cur->type == XML_XINCLUDE_END)) &&
  ------------------
  |  Branch (421:3): [True: 0, False: 17.5k]
  ------------------
  422|  31.7k|	(cur->nsDef != NULL))
  ------------------
  |  Branch (422:2): [True: 78, False: 14.1k]
  ------------------
  423|     78|	xmlFreeNsList(cur->nsDef);
  424|       |
  425|       |    /*
  426|       |     * we don't free names here they are interned now
  427|       |     */
  428|  31.7k|    if ((cur->type != XML_TEXT_NODE) &&
  ------------------
  |  Branch (428:9): [True: 14.4k, False: 17.3k]
  ------------------
  429|  31.7k|        (cur->type != XML_COMMENT_NODE))
  ------------------
  |  Branch (429:9): [True: 14.2k, False: 149]
  ------------------
  430|  14.2k|	DICT_FREE(cur->name);
  ------------------
  |  |  214|  14.2k|	if ((str) && ((!dict) ||				\
  |  |  ------------------
  |  |  |  Branch (214:6): [True: 14.2k, False: 33]
  |  |  |  Branch (214:16): [True: 0, False: 14.2k]
  |  |  ------------------
  |  |  215|  14.2k|	    (xmlDictOwns(dict, (const xmlChar *)(str)) == 0)))	\
  |  |  ------------------
  |  |  |  Branch (215:6): [True: 1, False: 14.2k]
  |  |  ------------------
  |  |  216|  14.2k|	    xmlFree((char *)(str));
  ------------------
  431|       |
  432|  31.7k|    if (((cur->type == XML_ELEMENT_NODE) ||
  ------------------
  |  Branch (432:10): [True: 14.2k, False: 17.5k]
  ------------------
  433|  31.7k|	 (cur->type == XML_TEXT_NODE)) &&
  ------------------
  |  Branch (433:3): [True: 17.3k, False: 201]
  ------------------
  434|  31.7k|	(reader != NULL) && (reader->ctxt != NULL) &&
  ------------------
  |  Branch (434:2): [True: 31.5k, False: 0]
  |  Branch (434:22): [True: 31.5k, False: 0]
  ------------------
  435|  31.7k|	(reader->ctxt->freeElemsNr < MAX_FREE_NODES)) {
  ------------------
  |  |   52|  31.5k|#define MAX_FREE_NODES 1
  ------------------
  |  Branch (435:2): [True: 1.43k, False: 30.1k]
  ------------------
  436|  1.43k|	cur->next = reader->ctxt->freeElems;
  437|  1.43k|	reader->ctxt->freeElems = cur;
  438|  1.43k|	reader->ctxt->freeElemsNr++;
  439|  30.3k|    } else {
  440|  30.3k|	xmlFree(cur);
  441|  30.3k|    }
  442|  31.7k|}
xmlreader.c:xmlTextReaderFreeProp:
  229|  21.3k|xmlTextReaderFreeProp(xmlTextReaderPtr reader, xmlAttrPtr cur) {
  230|  21.3k|    xmlDictPtr dict;
  231|       |
  232|  21.3k|    if ((reader != NULL) && (reader->ctxt != NULL))
  ------------------
  |  Branch (232:9): [True: 21.3k, False: 0]
  |  Branch (232:29): [True: 21.3k, False: 0]
  ------------------
  233|  21.3k|	dict = reader->ctxt->dict;
  234|      0|    else
  235|      0|        dict = NULL;
  236|  21.3k|    if (cur == NULL) return;
  ------------------
  |  Branch (236:9): [True: 0, False: 21.3k]
  ------------------
  237|       |
  238|  21.3k|    if ((__xmlRegisterCallbacks) && (xmlDeregisterNodeDefaultValue))
  ------------------
  |  |  684|      0|    XML_GLOBAL_MACRO(xmlDeregisterNodeDefaultValue)
  |  |  ------------------
  |  |  |  |  500|      0|  #define XML_GLOBAL_MACRO(name) (*__##name())
  |  |  ------------------
  ------------------
  |  Branch (238:9): [True: 0, False: 21.3k]
  |  Branch (238:37): [True: 0, False: 0]
  ------------------
  239|      0|	xmlDeregisterNodeDefaultValue((xmlNodePtr) cur);
  ------------------
  |  |  684|      0|    XML_GLOBAL_MACRO(xmlDeregisterNodeDefaultValue)
  |  |  ------------------
  |  |  |  |  500|      0|  #define XML_GLOBAL_MACRO(name) (*__##name())
  |  |  ------------------
  ------------------
  240|       |
  241|  21.3k|    if (cur->children != NULL)
  ------------------
  |  Branch (241:9): [True: 21.3k, False: 0]
  ------------------
  242|  21.3k|        xmlTextReaderFreeNodeList(reader, cur->children);
  243|       |
  244|  21.3k|    DICT_FREE(cur->name);
  ------------------
  |  |  214|  21.3k|	if ((str) && ((!dict) ||				\
  |  |  ------------------
  |  |  |  Branch (214:6): [True: 21.3k, False: 0]
  |  |  |  Branch (214:16): [True: 0, False: 21.3k]
  |  |  ------------------
  |  |  215|  21.3k|	    (xmlDictOwns(dict, (const xmlChar *)(str)) == 0)))	\
  |  |  ------------------
  |  |  |  Branch (215:6): [True: 0, False: 21.3k]
  |  |  ------------------
  |  |  216|  21.3k|	    xmlFree((char *)(str));
  ------------------
  245|  21.3k|    if ((reader != NULL) && (reader->ctxt != NULL) &&
  ------------------
  |  Branch (245:9): [True: 21.3k, False: 0]
  |  Branch (245:29): [True: 21.3k, False: 0]
  ------------------
  246|  21.3k|        (reader->ctxt->freeAttrsNr < MAX_FREE_NODES)) {
  ------------------
  |  |   52|  21.3k|#define MAX_FREE_NODES 1
  ------------------
  |  Branch (246:9): [True: 1.30k, False: 20.0k]
  ------------------
  247|  1.30k|        cur->next = reader->ctxt->freeAttrs;
  248|  1.30k|	reader->ctxt->freeAttrs = cur;
  249|  1.30k|	reader->ctxt->freeAttrsNr++;
  250|  20.0k|    } else {
  251|  20.0k|	xmlFree(cur);
  252|  20.0k|    }
  253|  21.3k|}
xmlreader.c:xmlTextReaderFreeNodeList:
  282|  21.3k|xmlTextReaderFreeNodeList(xmlTextReaderPtr reader, xmlNodePtr cur) {
  283|  21.3k|    xmlNodePtr next;
  284|  21.3k|    xmlNodePtr parent;
  285|  21.3k|    xmlDictPtr dict;
  286|  21.3k|    size_t depth = 0;
  287|       |
  288|  21.3k|    if ((reader != NULL) && (reader->ctxt != NULL))
  ------------------
  |  Branch (288:9): [True: 21.3k, False: 0]
  |  Branch (288:29): [True: 21.3k, False: 0]
  ------------------
  289|  21.3k|	dict = reader->ctxt->dict;
  290|      0|    else
  291|      0|        dict = NULL;
  292|  21.3k|    if (cur == NULL) return;
  ------------------
  |  Branch (292:9): [True: 0, False: 21.3k]
  ------------------
  293|  21.3k|    if (cur->type == XML_NAMESPACE_DECL) {
  ------------------
  |  Branch (293:9): [True: 0, False: 21.3k]
  ------------------
  294|      0|	xmlFreeNsList((xmlNsPtr) cur);
  295|      0|	return;
  296|      0|    }
  297|  21.3k|    if ((cur->type == XML_DOCUMENT_NODE) ||
  ------------------
  |  Branch (297:9): [True: 0, False: 21.3k]
  ------------------
  298|  21.3k|	(cur->type == XML_HTML_DOCUMENT_NODE)) {
  ------------------
  |  Branch (298:2): [True: 0, False: 21.3k]
  ------------------
  299|      0|	xmlFreeDoc((xmlDocPtr) cur);
  300|      0|	return;
  301|      0|    }
  302|  21.4k|    while (1) {
  ------------------
  |  Branch (302:12): [Folded - Ignored]
  ------------------
  303|  21.4k|        while ((cur->type != XML_DTD_NODE) &&
  ------------------
  |  Branch (303:16): [True: 21.4k, False: 0]
  ------------------
  304|  21.4k|               (cur->type != XML_ENTITY_REF_NODE) &&
  ------------------
  |  Branch (304:16): [True: 21.4k, False: 0]
  ------------------
  305|  21.4k|               (cur->children != NULL) &&
  ------------------
  |  Branch (305:16): [True: 6, False: 21.4k]
  ------------------
  306|  21.4k|               (cur->children->parent == cur)) {
  ------------------
  |  Branch (306:16): [True: 6, False: 0]
  ------------------
  307|      6|            cur = cur->children;
  308|      6|            depth += 1;
  309|      6|        }
  310|       |
  311|  21.4k|        next = cur->next;
  312|  21.4k|        parent = cur->parent;
  313|       |
  314|       |	/* unroll to speed up freeing the document */
  315|  21.4k|	if (cur->type != XML_DTD_NODE) {
  ------------------
  |  Branch (315:6): [True: 21.4k, False: 0]
  ------------------
  316|       |
  317|  21.4k|	    if ((__xmlRegisterCallbacks) && (xmlDeregisterNodeDefaultValue))
  ------------------
  |  |  684|      0|    XML_GLOBAL_MACRO(xmlDeregisterNodeDefaultValue)
  |  |  ------------------
  |  |  |  |  500|      0|  #define XML_GLOBAL_MACRO(name) (*__##name())
  |  |  ------------------
  ------------------
  |  Branch (317:10): [True: 0, False: 21.4k]
  |  Branch (317:38): [True: 0, False: 0]
  ------------------
  318|      0|		xmlDeregisterNodeDefaultValue(cur);
  ------------------
  |  |  684|      0|    XML_GLOBAL_MACRO(xmlDeregisterNodeDefaultValue)
  |  |  ------------------
  |  |  |  |  500|      0|  #define XML_GLOBAL_MACRO(name) (*__##name())
  |  |  ------------------
  ------------------
  319|       |
  320|  21.4k|	    if (((cur->type == XML_ELEMENT_NODE) ||
  ------------------
  |  Branch (320:11): [True: 117, False: 21.3k]
  ------------------
  321|  21.4k|		 (cur->type == XML_XINCLUDE_START) ||
  ------------------
  |  Branch (321:4): [True: 0, False: 21.3k]
  ------------------
  322|  21.4k|		 (cur->type == XML_XINCLUDE_END)) &&
  ------------------
  |  Branch (322:4): [True: 0, False: 21.3k]
  ------------------
  323|  21.4k|		(cur->properties != NULL))
  ------------------
  |  Branch (323:3): [True: 1, False: 116]
  ------------------
  324|      1|		xmlTextReaderFreePropList(reader, cur->properties);
  325|  21.4k|	    if ((cur->content != (xmlChar *) &(cur->properties)) &&
  ------------------
  |  Branch (325:10): [True: 1.02k, False: 20.4k]
  ------------------
  326|  21.4k|	        (cur->type != XML_ELEMENT_NODE) &&
  ------------------
  |  Branch (326:10): [True: 908, False: 117]
  ------------------
  327|  21.4k|		(cur->type != XML_XINCLUDE_START) &&
  ------------------
  |  Branch (327:3): [True: 908, False: 0]
  ------------------
  328|  21.4k|		(cur->type != XML_XINCLUDE_END) &&
  ------------------
  |  Branch (328:3): [True: 908, False: 0]
  ------------------
  329|  21.4k|		(cur->type != XML_ENTITY_REF_NODE)) {
  ------------------
  |  Branch (329:3): [True: 908, False: 0]
  ------------------
  330|    908|		DICT_FREE(cur->content);
  ------------------
  |  |  214|    908|	if ((str) && ((!dict) ||				\
  |  |  ------------------
  |  |  |  Branch (214:6): [True: 907, False: 1]
  |  |  |  Branch (214:16): [True: 0, False: 907]
  |  |  ------------------
  |  |  215|    907|	    (xmlDictOwns(dict, (const xmlChar *)(str)) == 0)))	\
  |  |  ------------------
  |  |  |  Branch (215:6): [True: 907, False: 0]
  |  |  ------------------
  |  |  216|    908|	    xmlFree((char *)(str));
  ------------------
  331|    908|	    }
  332|  21.4k|	    if (((cur->type == XML_ELEMENT_NODE) ||
  ------------------
  |  Branch (332:11): [True: 117, False: 21.3k]
  ------------------
  333|  21.4k|	         (cur->type == XML_XINCLUDE_START) ||
  ------------------
  |  Branch (333:11): [True: 0, False: 21.3k]
  ------------------
  334|  21.4k|		 (cur->type == XML_XINCLUDE_END)) &&
  ------------------
  |  Branch (334:4): [True: 0, False: 21.3k]
  ------------------
  335|  21.4k|		(cur->nsDef != NULL))
  ------------------
  |  Branch (335:3): [True: 3, False: 114]
  ------------------
  336|      3|		xmlFreeNsList(cur->nsDef);
  337|       |
  338|       |	    /*
  339|       |	     * we don't free element names here they are interned now
  340|       |	     */
  341|  21.4k|	    if ((cur->type != XML_TEXT_NODE) &&
  ------------------
  |  Branch (341:10): [True: 122, False: 21.3k]
  ------------------
  342|  21.4k|		(cur->type != XML_COMMENT_NODE))
  ------------------
  |  Branch (342:3): [True: 120, False: 2]
  ------------------
  343|    120|		DICT_FREE(cur->name);
  ------------------
  |  |  214|    120|	if ((str) && ((!dict) ||				\
  |  |  ------------------
  |  |  |  Branch (214:6): [True: 120, False: 0]
  |  |  |  Branch (214:16): [True: 0, False: 120]
  |  |  ------------------
  |  |  215|    120|	    (xmlDictOwns(dict, (const xmlChar *)(str)) == 0)))	\
  |  |  ------------------
  |  |  |  Branch (215:6): [True: 0, False: 120]
  |  |  ------------------
  |  |  216|    120|	    xmlFree((char *)(str));
  ------------------
  344|  21.4k|	    if (((cur->type == XML_ELEMENT_NODE) ||
  ------------------
  |  Branch (344:11): [True: 117, False: 21.3k]
  ------------------
  345|  21.4k|		 (cur->type == XML_TEXT_NODE)) &&
  ------------------
  |  Branch (345:4): [True: 21.3k, False: 5]
  ------------------
  346|  21.4k|	        (reader != NULL) && (reader->ctxt != NULL) &&
  ------------------
  |  Branch (346:10): [True: 21.4k, False: 0]
  |  Branch (346:30): [True: 21.4k, False: 0]
  ------------------
  347|  21.4k|		(reader->ctxt->freeElemsNr < MAX_FREE_NODES)) {
  ------------------
  |  |   52|  21.4k|#define MAX_FREE_NODES 1
  ------------------
  |  Branch (347:3): [True: 198, False: 21.2k]
  ------------------
  348|    198|	        cur->next = reader->ctxt->freeElems;
  349|    198|		reader->ctxt->freeElems = cur;
  350|    198|		reader->ctxt->freeElemsNr++;
  351|  21.2k|	    } else {
  352|  21.2k|		xmlFree(cur);
  353|  21.2k|	    }
  354|  21.4k|	}
  355|       |
  356|  21.4k|        if (next != NULL) {
  ------------------
  |  Branch (356:13): [True: 104, False: 21.3k]
  ------------------
  357|    104|	    cur = next;
  358|  21.3k|        } else {
  359|  21.3k|            if ((depth == 0) || (parent == NULL))
  ------------------
  |  Branch (359:17): [True: 21.3k, False: 6]
  |  Branch (359:33): [True: 0, False: 6]
  ------------------
  360|  21.3k|                break;
  361|      6|            depth -= 1;
  362|      6|            cur = parent;
  363|      6|            cur->children = NULL;
  364|      6|        }
  365|  21.4k|    }
  366|  21.3k|}
xmlreader.c:xmlTextReaderFreePropList:
  263|  11.5k|xmlTextReaderFreePropList(xmlTextReaderPtr reader, xmlAttrPtr cur) {
  264|  11.5k|    xmlAttrPtr next;
  265|       |
  266|  32.9k|    while (cur != NULL) {
  ------------------
  |  Branch (266:12): [True: 21.3k, False: 11.5k]
  ------------------
  267|  21.3k|        next = cur->next;
  268|  21.3k|        xmlTextReaderFreeProp(reader, cur);
  269|  21.3k|	cur = next;
  270|  21.3k|    }
  271|  11.5k|}
xmlreader.c:xmlTextReaderValidatePush:
  823|  14.2k|xmlTextReaderValidatePush(xmlTextReaderPtr reader ATTRIBUTE_UNUSED) {
  824|  14.2k|    xmlNodePtr node = reader->node;
  825|       |
  826|  14.2k|#ifdef LIBXML_VALID_ENABLED
  827|  14.2k|    if ((reader->validate == XML_TEXTREADER_VALIDATE_DTD) &&
  ------------------
  |  Branch (827:9): [True: 14.2k, False: 0]
  ------------------
  828|  14.2k|        (reader->ctxt != NULL) && (reader->ctxt->validate == 1)) {
  ------------------
  |  Branch (828:9): [True: 14.2k, False: 0]
  |  Branch (828:35): [True: 3.40k, False: 10.8k]
  ------------------
  829|  3.40k|	if ((node->ns == NULL) || (node->ns->prefix == NULL)) {
  ------------------
  |  Branch (829:6): [True: 3.32k, False: 81]
  |  Branch (829:28): [True: 4, False: 77]
  ------------------
  830|  3.33k|	    reader->ctxt->valid &= xmlValidatePushElement(&reader->ctxt->vctxt,
  831|  3.33k|				    reader->ctxt->myDoc, node, node->name);
  832|  3.33k|	} else {
  833|       |	    /* TODO use the BuildQName interface */
  834|     77|	    xmlChar *qname;
  835|       |
  836|     77|	    qname = xmlStrdup(node->ns->prefix);
  837|     77|	    qname = xmlStrcat(qname, BAD_CAST ":");
  ------------------
  |  |   35|     77|#define BAD_CAST (xmlChar *)
  ------------------
  838|     77|	    qname = xmlStrcat(qname, node->name);
  839|     77|	    reader->ctxt->valid &= xmlValidatePushElement(&reader->ctxt->vctxt,
  840|     77|				    reader->ctxt->myDoc, node, qname);
  841|     77|	    if (qname != NULL)
  ------------------
  |  Branch (841:10): [True: 77, False: 0]
  ------------------
  842|     77|		xmlFree(qname);
  843|     77|	}
  844|  3.40k|    }
  845|  14.2k|#endif /* LIBXML_VALID_ENABLED */
  846|  14.2k|#ifdef LIBXML_SCHEMAS_ENABLED
  847|  14.2k|    if ((reader->validate == XML_TEXTREADER_VALIDATE_RNG) &&
  ------------------
  |  Branch (847:9): [True: 0, False: 14.2k]
  ------------------
  848|  14.2k|               (reader->rngValidCtxt != NULL)) {
  ------------------
  |  Branch (848:16): [True: 0, False: 0]
  ------------------
  849|      0|	int ret;
  850|       |
  851|      0|	if (reader->rngFullNode != NULL) return;
  ------------------
  |  Branch (851:6): [True: 0, False: 0]
  ------------------
  852|      0|	ret = xmlRelaxNGValidatePushElement(reader->rngValidCtxt,
  853|      0|	                                    reader->ctxt->myDoc,
  854|      0|					    node);
  855|      0|	if (ret == 0) {
  ------------------
  |  Branch (855:6): [True: 0, False: 0]
  ------------------
  856|       |	    /*
  857|       |	     * this element requires a full tree
  858|       |	     */
  859|      0|	    node = xmlTextReaderExpand(reader);
  860|      0|	    if (node == NULL) {
  ------------------
  |  Branch (860:10): [True: 0, False: 0]
  ------------------
  861|      0|	        ret = -1;
  862|      0|	    } else {
  863|      0|		ret = xmlRelaxNGValidateFullElement(reader->rngValidCtxt,
  864|      0|						    reader->ctxt->myDoc,
  865|      0|						    node);
  866|      0|		reader->rngFullNode = node;
  867|      0|	    }
  868|      0|	}
  869|      0|	if (ret != 1)
  ------------------
  |  Branch (869:6): [True: 0, False: 0]
  ------------------
  870|      0|	    reader->rngValidErrors++;
  871|      0|    }
  872|  14.2k|#endif
  873|  14.2k|}
xmlreader.c:xmlTextReaderValidateCData:
  885|  17.3k|                           const xmlChar *data, int len) {
  886|  17.3k|#ifdef LIBXML_VALID_ENABLED
  887|  17.3k|    if ((reader->validate == XML_TEXTREADER_VALIDATE_DTD) &&
  ------------------
  |  Branch (887:9): [True: 17.3k, False: 0]
  ------------------
  888|  17.3k|        (reader->ctxt != NULL) && (reader->ctxt->validate == 1)) {
  ------------------
  |  Branch (888:9): [True: 17.3k, False: 0]
  |  Branch (888:35): [True: 5.58k, False: 11.7k]
  ------------------
  889|  5.58k|	reader->ctxt->valid &= xmlValidatePushCData(&reader->ctxt->vctxt,
  890|  5.58k|	                                            data, len);
  891|  5.58k|    }
  892|  17.3k|#endif /* LIBXML_VALID_ENABLED */
  893|  17.3k|#ifdef LIBXML_SCHEMAS_ENABLED
  894|  17.3k|    if ((reader->validate == XML_TEXTREADER_VALIDATE_RNG) &&
  ------------------
  |  Branch (894:9): [True: 0, False: 17.3k]
  ------------------
  895|  17.3k|               (reader->rngValidCtxt != NULL)) {
  ------------------
  |  Branch (895:16): [True: 0, False: 0]
  ------------------
  896|      0|	int ret;
  897|       |
  898|      0|	if (reader->rngFullNode != NULL) return;
  ------------------
  |  Branch (898:6): [True: 0, False: 0]
  ------------------
  899|      0|	ret = xmlRelaxNGValidatePushCData(reader->rngValidCtxt, data, len);
  900|      0|	if (ret != 1)
  ------------------
  |  Branch (900:6): [True: 0, False: 0]
  ------------------
  901|      0|	    reader->rngValidErrors++;
  902|      0|    }
  903|  17.3k|#endif
  904|  17.3k|}
xmlreader.c:xmlTextReaderDoExpand:
 1078|  4.45k|xmlTextReaderDoExpand(xmlTextReaderPtr reader) {
 1079|  4.45k|    int val;
 1080|       |
 1081|  4.45k|    if ((reader == NULL) || (reader->node == NULL) || (reader->ctxt == NULL))
  ------------------
  |  Branch (1081:9): [True: 0, False: 4.45k]
  |  Branch (1081:29): [True: 0, False: 4.45k]
  |  Branch (1081:55): [True: 0, False: 4.45k]
  ------------------
 1082|      0|        return(-1);
 1083|  5.15k|    do {
 1084|  5.15k|	if (reader->ctxt->instate == XML_PARSER_EOF) return(1);
  ------------------
  |  Branch (1084:6): [True: 460, False: 4.69k]
  ------------------
 1085|       |
 1086|  4.69k|        if (xmlTextReaderGetSuccessor(reader->node) != NULL)
  ------------------
  |  Branch (1086:13): [True: 3.96k, False: 733]
  ------------------
 1087|  3.96k|	    return(1);
 1088|    733|	if (reader->ctxt->nodeNr < reader->depth)
  ------------------
  |  Branch (1088:6): [True: 29, False: 704]
  ------------------
 1089|     29|	    return(1);
 1090|    704|	if (reader->mode == XML_TEXTREADER_MODE_EOF)
  ------------------
  |  Branch (1090:6): [True: 0, False: 704]
  ------------------
 1091|      0|	    return(1);
 1092|    704|	val = xmlTextReaderPushData(reader);
 1093|    704|	if (val < 0){
  ------------------
  |  Branch (1093:6): [True: 1, False: 703]
  ------------------
 1094|      1|	    reader->mode = XML_TEXTREADER_MODE_ERROR;
 1095|      1|	    return(-1);
 1096|      1|	}
 1097|    704|    } while(reader->mode != XML_TEXTREADER_MODE_EOF);
  ------------------
  |  Branch (1097:13): [True: 703, False: 0]
  ------------------
 1098|      0|    return(1);
 1099|  4.45k|}
xmlreader.c:xmlTextReaderGetSuccessor:
 1055|  4.69k|xmlTextReaderGetSuccessor(xmlNodePtr cur) {
 1056|  4.69k|    if (cur == NULL) return(NULL) ; /* ERROR */
  ------------------
  |  Branch (1056:9): [True: 0, False: 4.69k]
  ------------------
 1057|  4.69k|    if (cur->next != NULL) return(cur->next) ;
  ------------------
  |  Branch (1057:9): [True: 677, False: 4.02k]
  ------------------
 1058|  8.49k|    do {
 1059|  8.49k|        cur = cur->parent;
 1060|  8.49k|        if (cur == NULL) break;
  ------------------
  |  Branch (1060:13): [True: 733, False: 7.76k]
  ------------------
 1061|  7.76k|        if (cur->next != NULL) return(cur->next);
  ------------------
  |  Branch (1061:13): [True: 3.28k, False: 4.47k]
  ------------------
 1062|  7.76k|    } while (cur != NULL);
  ------------------
  |  Branch (1062:14): [True: 4.47k, False: 0]
  ------------------
 1063|    733|    return(cur);
 1064|  4.02k|}
xmlreader.c:xmlTextReaderStartElementNs:
  622|  14.3k|{
  623|  14.3k|    xmlParserCtxtPtr ctxt = (xmlParserCtxtPtr) ctx;
  624|  14.3k|    xmlTextReaderPtr reader = ctxt->_private;
  625|       |
  626|  14.3k|    if ((reader != NULL) && (reader->startElementNs != NULL)) {
  ------------------
  |  Branch (626:9): [True: 14.3k, False: 0]
  |  Branch (626:29): [True: 14.3k, False: 0]
  ------------------
  627|  14.3k|	reader->startElementNs(ctx, localname, prefix, URI, nb_namespaces,
  628|  14.3k|	                       namespaces, nb_attributes, nb_defaulted,
  629|  14.3k|			       attributes);
  630|  14.3k|	if ((ctxt->node != NULL) && (ctxt->input != NULL) &&
  ------------------
  |  Branch (630:6): [True: 14.3k, False: 0]
  |  Branch (630:30): [True: 14.3k, False: 0]
  ------------------
  631|  14.3k|	    (ctxt->input->cur != NULL) && (ctxt->input->cur[0] == '/') &&
  ------------------
  |  Branch (631:6): [True: 14.3k, False: 0]
  |  Branch (631:36): [True: 10.1k, False: 4.15k]
  ------------------
  632|  14.3k|	    (ctxt->input->cur[1] == '>'))
  ------------------
  |  Branch (632:6): [True: 10.1k, False: 0]
  ------------------
  633|  10.1k|	    ctxt->node->extra = NODE_IS_EMPTY;
  ------------------
  |  |  186|  10.1k|#define NODE_IS_EMPTY		0x1
  ------------------
  634|  14.3k|    }
  635|  14.3k|    if (reader != NULL)
  ------------------
  |  Branch (635:9): [True: 14.3k, False: 0]
  ------------------
  636|  14.3k|	reader->state = XML_TEXTREADER_ELEMENT;
  637|  14.3k|}
xmlreader.c:xmlTextReaderEndElementNs:
  653|  14.3k|{
  654|  14.3k|    xmlParserCtxtPtr ctxt = (xmlParserCtxtPtr) ctx;
  655|  14.3k|    xmlTextReaderPtr reader = ctxt->_private;
  656|       |
  657|  14.3k|    if ((reader != NULL) && (reader->endElementNs != NULL)) {
  ------------------
  |  Branch (657:9): [True: 14.3k, False: 0]
  |  Branch (657:29): [True: 14.3k, False: 0]
  ------------------
  658|  14.3k|	reader->endElementNs(ctx, localname, prefix, URI);
  659|  14.3k|    }
  660|  14.3k|}
xmlreader.c:xmlTextReaderCharacters:
  673|  18.4k|{
  674|  18.4k|    xmlParserCtxtPtr ctxt = (xmlParserCtxtPtr) ctx;
  675|  18.4k|    xmlTextReaderPtr reader = ctxt->_private;
  676|       |
  677|  18.4k|    if ((reader != NULL) && (reader->characters != NULL)) {
  ------------------
  |  Branch (677:9): [True: 18.4k, False: 0]
  |  Branch (677:29): [True: 18.4k, False: 0]
  ------------------
  678|  18.4k|	reader->characters(ctx, ch, len);
  679|  18.4k|    }
  680|  18.4k|}
xmlreader.c:xmlTextReaderCDataBlock:
  692|     56|{
  693|     56|    xmlParserCtxtPtr ctxt = (xmlParserCtxtPtr) ctx;
  694|     56|    xmlTextReaderPtr reader = ctxt->_private;
  695|       |
  696|     56|    if ((reader != NULL) && (reader->cdataBlock != NULL)) {
  ------------------
  |  Branch (696:9): [True: 56, False: 0]
  |  Branch (696:29): [True: 56, False: 0]
  ------------------
  697|     56|	reader->cdataBlock(ctx, ch, len);
  698|     56|    }
  699|     56|}
xmlreader.c:xmlTextReaderFreeDoc:
  452|    322|xmlTextReaderFreeDoc(xmlTextReaderPtr reader, xmlDocPtr cur) {
  453|    322|    xmlDtdPtr extSubset, intSubset;
  454|       |
  455|    322|    if (cur == NULL) return;
  ------------------
  |  Branch (455:9): [True: 0, False: 322]
  ------------------
  456|       |
  457|    322|    if ((__xmlRegisterCallbacks) && (xmlDeregisterNodeDefaultValue))
  ------------------
  |  |  684|      0|    XML_GLOBAL_MACRO(xmlDeregisterNodeDefaultValue)
  |  |  ------------------
  |  |  |  |  500|      0|  #define XML_GLOBAL_MACRO(name) (*__##name())
  |  |  ------------------
  ------------------
  |  Branch (457:9): [True: 0, False: 322]
  |  Branch (457:37): [True: 0, False: 0]
  ------------------
  458|      0|	xmlDeregisterNodeDefaultValue((xmlNodePtr) cur);
  ------------------
  |  |  684|      0|    XML_GLOBAL_MACRO(xmlDeregisterNodeDefaultValue)
  |  |  ------------------
  |  |  |  |  500|      0|  #define XML_GLOBAL_MACRO(name) (*__##name())
  |  |  ------------------
  ------------------
  459|       |
  460|       |    /*
  461|       |     * Do this before freeing the children list to avoid ID lookups
  462|       |     */
  463|    322|    if (cur->ids != NULL) xmlFreeIDTable((xmlIDTablePtr) cur->ids);
  ------------------
  |  Branch (463:9): [True: 15, False: 307]
  ------------------
  464|    322|    cur->ids = NULL;
  465|    322|    if (cur->refs != NULL) xmlFreeRefTable((xmlRefTablePtr) cur->refs);
  ------------------
  |  Branch (465:9): [True: 6, False: 316]
  ------------------
  466|    322|    cur->refs = NULL;
  467|    322|    extSubset = cur->extSubset;
  468|    322|    intSubset = cur->intSubset;
  469|    322|    if (intSubset == extSubset)
  ------------------
  |  Branch (469:9): [True: 132, False: 190]
  ------------------
  470|    132|	extSubset = NULL;
  471|    322|    if (extSubset != NULL) {
  ------------------
  |  Branch (471:9): [True: 21, False: 301]
  ------------------
  472|     21|	xmlUnlinkNode((xmlNodePtr) cur->extSubset);
  473|     21|	cur->extSubset = NULL;
  474|     21|	xmlFreeDtd(extSubset);
  475|     21|    }
  476|    322|    if (intSubset != NULL) {
  ------------------
  |  Branch (476:9): [True: 190, False: 132]
  ------------------
  477|    190|	xmlUnlinkNode((xmlNodePtr) cur->intSubset);
  478|    190|	cur->intSubset = NULL;
  479|    190|	xmlFreeDtd(intSubset);
  480|    190|    }
  481|       |
  482|    322|    if (cur->children != NULL) xmlTextReaderFreeNodeList(reader, cur->children);
  ------------------
  |  Branch (482:9): [True: 24, False: 298]
  ------------------
  483|       |
  484|    322|    if (cur->version != NULL) xmlFree((char *) cur->version);
  ------------------
  |  Branch (484:9): [True: 322, False: 0]
  ------------------
  485|    322|    if (cur->name != NULL) xmlFree((char *) cur->name);
  ------------------
  |  Branch (485:9): [True: 0, False: 322]
  ------------------
  486|    322|    if (cur->encoding != NULL) xmlFree((char *) cur->encoding);
  ------------------
  |  Branch (486:9): [True: 32, False: 290]
  ------------------
  487|    322|    if (cur->oldNs != NULL) xmlFreeNsList(cur->oldNs);
  ------------------
  |  Branch (487:9): [True: 12, False: 310]
  ------------------
  488|    322|    if (cur->URL != NULL) xmlFree((char *) cur->URL);
  ------------------
  |  Branch (488:9): [True: 0, False: 322]
  ------------------
  489|    322|    if (cur->dict != NULL) xmlDictFree(cur->dict);
  ------------------
  |  Branch (489:9): [True: 322, False: 0]
  ------------------
  490|       |
  491|    322|    xmlFree(cur);
  492|    322|}

xmlRegNewExecCtxt:
 3435|  2.81k|xmlRegNewExecCtxt(xmlRegexpPtr comp, xmlRegExecCallbacks callback, void *data) {
 3436|  2.81k|    xmlRegExecCtxtPtr exec;
 3437|       |
 3438|  2.81k|    if (comp == NULL)
  ------------------
  |  Branch (3438:9): [True: 0, False: 2.81k]
  ------------------
 3439|      0|	return(NULL);
 3440|  2.81k|    if ((comp->compact == NULL) && (comp->states == NULL))
  ------------------
  |  Branch (3440:9): [True: 1, False: 2.81k]
  |  Branch (3440:36): [True: 0, False: 1]
  ------------------
 3441|      0|        return(NULL);
 3442|  2.81k|    exec = (xmlRegExecCtxtPtr) xmlMalloc(sizeof(xmlRegExecCtxt));
 3443|  2.81k|    if (exec == NULL) {
  ------------------
  |  Branch (3443:9): [True: 0, False: 2.81k]
  ------------------
 3444|      0|	xmlRegexpErrMemory(NULL, "creating execution context");
 3445|      0|	return(NULL);
 3446|      0|    }
 3447|  2.81k|    memset(exec, 0, sizeof(xmlRegExecCtxt));
 3448|  2.81k|    exec->inputString = NULL;
 3449|  2.81k|    exec->index = 0;
 3450|  2.81k|    exec->determinist = 1;
 3451|  2.81k|    exec->maxRollbacks = 0;
 3452|  2.81k|    exec->nbRollbacks = 0;
 3453|  2.81k|    exec->rollbacks = NULL;
 3454|  2.81k|    exec->status = XML_REGEXP_OK;
  ------------------
  |  |   44|  2.81k|#define XML_REGEXP_OK               0
  ------------------
 3455|  2.81k|    exec->comp = comp;
 3456|  2.81k|    if (comp->compact == NULL)
  ------------------
  |  Branch (3456:9): [True: 1, False: 2.81k]
  ------------------
 3457|      1|	exec->state = comp->states[0];
 3458|  2.81k|    exec->transno = 0;
 3459|  2.81k|    exec->transcount = 0;
 3460|  2.81k|    exec->callback = callback;
 3461|  2.81k|    exec->data = data;
 3462|  2.81k|    if (comp->nbCounters > 0) {
  ------------------
  |  Branch (3462:9): [True: 0, False: 2.81k]
  ------------------
 3463|       |        /*
 3464|       |	 * For error handling, exec->counts is allocated twice the size
 3465|       |	 * the second half is used to store the data in case of rollback
 3466|       |	 */
 3467|      0|	exec->counts = (int *) xmlMalloc(comp->nbCounters * sizeof(int)
 3468|      0|	                                 * 2);
 3469|      0|	if (exec->counts == NULL) {
  ------------------
  |  Branch (3469:6): [True: 0, False: 0]
  ------------------
 3470|      0|	    xmlRegexpErrMemory(NULL, "creating execution context");
 3471|      0|	    xmlFree(exec);
 3472|      0|	    return(NULL);
 3473|      0|	}
 3474|      0|        memset(exec->counts, 0, comp->nbCounters * sizeof(int) * 2);
 3475|      0|	exec->errCounts = &exec->counts[comp->nbCounters];
 3476|  2.81k|    } else {
 3477|  2.81k|	exec->counts = NULL;
 3478|  2.81k|	exec->errCounts = NULL;
 3479|  2.81k|    }
 3480|  2.81k|    exec->inputStackMax = 0;
 3481|  2.81k|    exec->inputStackNr = 0;
 3482|  2.81k|    exec->inputStack = NULL;
 3483|  2.81k|    exec->errStateNo = -1;
 3484|  2.81k|    exec->errString = NULL;
 3485|  2.81k|    exec->nbPush = 0;
 3486|  2.81k|    return(exec);
 3487|  2.81k|}
xmlRegFreeExecCtxt:
 3496|  2.81k|xmlRegFreeExecCtxt(xmlRegExecCtxtPtr exec) {
 3497|  2.81k|    if (exec == NULL)
  ------------------
  |  Branch (3497:9): [True: 0, False: 2.81k]
  ------------------
 3498|      0|	return;
 3499|       |
 3500|  2.81k|    if (exec->rollbacks != NULL) {
  ------------------
  |  Branch (3500:9): [True: 1, False: 2.81k]
  ------------------
 3501|      1|	if (exec->counts != NULL) {
  ------------------
  |  Branch (3501:6): [True: 0, False: 1]
  ------------------
 3502|      0|	    int i;
 3503|       |
 3504|      0|	    for (i = 0;i < exec->maxRollbacks;i++)
  ------------------
  |  Branch (3504:17): [True: 0, False: 0]
  ------------------
 3505|      0|		if (exec->rollbacks[i].counts != NULL)
  ------------------
  |  Branch (3505:7): [True: 0, False: 0]
  ------------------
 3506|      0|		    xmlFree(exec->rollbacks[i].counts);
 3507|      0|	}
 3508|      1|	xmlFree(exec->rollbacks);
 3509|      1|    }
 3510|  2.81k|    if (exec->counts != NULL)
  ------------------
  |  Branch (3510:9): [True: 0, False: 2.81k]
  ------------------
 3511|      0|	xmlFree(exec->counts);
 3512|  2.81k|    if (exec->inputStack != NULL) {
  ------------------
  |  Branch (3512:9): [True: 1, False: 2.81k]
  ------------------
 3513|      1|	int i;
 3514|       |
 3515|      3|	for (i = 0;i < exec->inputStackNr;i++) {
  ------------------
  |  Branch (3515:13): [True: 2, False: 1]
  ------------------
 3516|      2|	    if (exec->inputStack[i].value != NULL)
  ------------------
  |  Branch (3516:10): [True: 2, False: 0]
  ------------------
 3517|      2|		xmlFree(exec->inputStack[i].value);
 3518|      2|	}
 3519|      1|	xmlFree(exec->inputStack);
 3520|      1|    }
 3521|  2.81k|    if (exec->errString != NULL)
  ------------------
  |  Branch (3521:9): [True: 6, False: 2.80k]
  ------------------
 3522|      6|        xmlFree(exec->errString);
 3523|  2.81k|    xmlFree(exec);
 3524|  2.81k|}
xmlRegExecPushString:
 4007|  10.0k|	             void *data) {
 4008|  10.0k|    return(xmlRegExecPushStringInternal(exec, value, data, 0));
 4009|  10.0k|}
xmlRegexpIsDeterminist:
 5484|  3.31k|xmlRegexpIsDeterminist(xmlRegexpPtr comp) {
 5485|  3.31k|    xmlAutomataPtr am;
 5486|  3.31k|    int ret;
 5487|       |
 5488|  3.31k|    if (comp == NULL)
  ------------------
  |  Branch (5488:9): [True: 0, False: 3.31k]
  ------------------
 5489|      0|	return(-1);
 5490|  3.31k|    if (comp->determinist != -1)
  ------------------
  |  Branch (5490:9): [True: 2.72k, False: 593]
  ------------------
 5491|  2.72k|	return(comp->determinist);
 5492|       |
 5493|    593|    am = xmlNewAutomata();
 5494|    593|    if (am == NULL)
  ------------------
  |  Branch (5494:9): [True: 0, False: 593]
  ------------------
 5495|      0|        return(-1);
 5496|    593|    if (am->states != NULL) {
  ------------------
  |  Branch (5496:9): [True: 593, False: 0]
  ------------------
 5497|    593|	int i;
 5498|       |
 5499|  1.18k|	for (i = 0;i < am->nbStates;i++)
  ------------------
  |  Branch (5499:13): [True: 593, False: 593]
  ------------------
 5500|    593|	    xmlRegFreeState(am->states[i]);
 5501|    593|	xmlFree(am->states);
 5502|    593|    }
 5503|    593|    am->nbAtoms = comp->nbAtoms;
 5504|    593|    am->atoms = comp->atoms;
 5505|    593|    am->nbStates = comp->nbStates;
 5506|    593|    am->states = comp->states;
 5507|    593|    am->determinist = -1;
 5508|    593|    am->flags = comp->flags;
 5509|    593|    ret = xmlFAComputesDeterminism(am);
 5510|    593|    am->atoms = NULL;
 5511|    593|    am->states = NULL;
 5512|    593|    xmlFreeAutomata(am);
 5513|    593|    comp->determinist = ret;
 5514|    593|    return(ret);
 5515|    593|}
xmlRegFreeRegexp:
 5524|    593|xmlRegFreeRegexp(xmlRegexpPtr regexp) {
 5525|    593|    int i;
 5526|    593|    if (regexp == NULL)
  ------------------
  |  Branch (5526:9): [True: 0, False: 593]
  ------------------
 5527|      0|	return;
 5528|       |
 5529|    593|    if (regexp->string != NULL)
  ------------------
  |  Branch (5529:9): [True: 0, False: 593]
  ------------------
 5530|      0|	xmlFree(regexp->string);
 5531|    593|    if (regexp->states != NULL) {
  ------------------
  |  Branch (5531:9): [True: 4, False: 589]
  ------------------
 5532|     40|	for (i = 0;i < regexp->nbStates;i++)
  ------------------
  |  Branch (5532:13): [True: 36, False: 4]
  ------------------
 5533|     36|	    xmlRegFreeState(regexp->states[i]);
 5534|      4|	xmlFree(regexp->states);
 5535|      4|    }
 5536|    593|    if (regexp->atoms != NULL) {
  ------------------
  |  Branch (5536:9): [True: 4, False: 589]
  ------------------
 5537|     20|	for (i = 0;i < regexp->nbAtoms;i++)
  ------------------
  |  Branch (5537:13): [True: 16, False: 4]
  ------------------
 5538|     16|	    xmlRegFreeAtom(regexp->atoms[i]);
 5539|      4|	xmlFree(regexp->atoms);
 5540|      4|    }
 5541|    593|    if (regexp->counters != NULL)
  ------------------
  |  Branch (5541:9): [True: 0, False: 593]
  ------------------
 5542|      0|	xmlFree(regexp->counters);
 5543|    593|    if (regexp->compact != NULL)
  ------------------
  |  Branch (5543:9): [True: 589, False: 4]
  ------------------
 5544|    589|	xmlFree(regexp->compact);
 5545|    593|    if (regexp->transdata != NULL)
  ------------------
  |  Branch (5545:9): [True: 0, False: 593]
  ------------------
 5546|      0|	xmlFree(regexp->transdata);
 5547|    593|    if (regexp->stringMap != NULL) {
  ------------------
  |  Branch (5547:9): [True: 589, False: 4]
  ------------------
 5548|  3.22k|	for (i = 0; i < regexp->nbstrings;i++)
  ------------------
  |  Branch (5548:14): [True: 2.63k, False: 589]
  ------------------
 5549|  2.63k|	    xmlFree(regexp->stringMap[i]);
 5550|    589|	xmlFree(regexp->stringMap);
 5551|    589|    }
 5552|       |
 5553|    593|    xmlFree(regexp);
 5554|    593|}
xmlNewAutomata:
 5571|  1.18k|xmlNewAutomata(void) {
 5572|  1.18k|    xmlAutomataPtr ctxt;
 5573|       |
 5574|  1.18k|    ctxt = xmlRegNewParserCtxt(NULL);
 5575|  1.18k|    if (ctxt == NULL)
  ------------------
  |  Branch (5575:9): [True: 0, False: 1.18k]
  ------------------
 5576|      0|	return(NULL);
 5577|       |
 5578|       |    /* initialize the parser */
 5579|  1.18k|    ctxt->state = xmlRegStatePush(ctxt);
 5580|  1.18k|    if (ctxt->state == NULL) {
  ------------------
  |  Branch (5580:9): [True: 0, False: 1.18k]
  ------------------
 5581|      0|	xmlFreeAutomata(ctxt);
 5582|      0|	return(NULL);
 5583|      0|    }
 5584|  1.18k|    ctxt->start = ctxt->state;
 5585|  1.18k|    ctxt->end = NULL;
 5586|       |
 5587|  1.18k|    ctxt->start->type = XML_REGEXP_START_STATE;
 5588|  1.18k|    ctxt->flags = 0;
 5589|       |
 5590|  1.18k|    return(ctxt);
 5591|  1.18k|}
xmlFreeAutomata:
 5600|  1.18k|xmlFreeAutomata(xmlAutomataPtr am) {
 5601|  1.18k|    if (am == NULL)
  ------------------
  |  Branch (5601:9): [True: 0, False: 1.18k]
  ------------------
 5602|      0|	return;
 5603|  1.18k|    xmlRegFreeParserCtxt(am);
 5604|  1.18k|}
xmlAutomataGetInitState:
 5629|    593|xmlAutomataGetInitState(xmlAutomataPtr am) {
 5630|    593|    if (am == NULL)
  ------------------
  |  Branch (5630:9): [True: 0, False: 593]
  ------------------
 5631|      0|	return(NULL);
 5632|    593|    return(am->start);
 5633|    593|}
xmlAutomataSetFinalState:
 5645|    593|xmlAutomataSetFinalState(xmlAutomataPtr am, xmlAutomataStatePtr state) {
 5646|    593|    if ((am == NULL) || (state == NULL))
  ------------------
  |  Branch (5646:9): [True: 0, False: 593]
  |  Branch (5646:25): [True: 0, False: 593]
  ------------------
 5647|      0|	return(-1);
 5648|    593|    state->type = XML_REGEXP_FINAL_STATE;
 5649|    593|    return(0);
 5650|    593|}
xmlAutomataNewTransition:
 5669|  2.90k|			 void *data) {
 5670|  2.90k|    xmlRegAtomPtr atom;
 5671|       |
 5672|  2.90k|    if ((am == NULL) || (from == NULL) || (token == NULL))
  ------------------
  |  Branch (5672:9): [True: 0, False: 2.90k]
  |  Branch (5672:25): [True: 0, False: 2.90k]
  |  Branch (5672:43): [True: 0, False: 2.90k]
  ------------------
 5673|      0|	return(NULL);
 5674|  2.90k|    atom = xmlRegNewAtom(am, XML_REGEXP_STRING);
 5675|  2.90k|    if (atom == NULL)
  ------------------
  |  Branch (5675:9): [True: 0, False: 2.90k]
  ------------------
 5676|      0|        return(NULL);
 5677|  2.90k|    atom->data = data;
 5678|  2.90k|    atom->valuep = xmlStrdup(token);
 5679|       |
 5680|  2.90k|    if (xmlFAGenerateTransitions(am, from, to, atom) < 0) {
  ------------------
  |  Branch (5680:9): [True: 0, False: 2.90k]
  ------------------
 5681|      0|        xmlRegFreeAtom(atom);
 5682|      0|	return(NULL);
 5683|      0|    }
 5684|  2.90k|    if (to == NULL)
  ------------------
  |  Branch (5684:9): [True: 2.46k, False: 437]
  ------------------
 5685|  2.46k|	return(am->state);
 5686|    437|    return(to);
 5687|  2.90k|}
xmlAutomataNewState:
 6148|    240|xmlAutomataNewState(xmlAutomataPtr am) {
 6149|    240|    if (am == NULL)
  ------------------
  |  Branch (6149:9): [True: 0, False: 240]
  ------------------
 6150|      0|	return(NULL);
 6151|    240|    return(xmlRegStatePush(am));
 6152|    240|}
xmlAutomataNewEpsilon:
 6168|  3.14k|		      xmlAutomataStatePtr to) {
 6169|  3.14k|    if ((am == NULL) || (from == NULL))
  ------------------
  |  Branch (6169:9): [True: 0, False: 3.14k]
  |  Branch (6169:25): [True: 0, False: 3.14k]
  ------------------
 6170|      0|	return(NULL);
 6171|  3.14k|    xmlFAGenerateEpsilonTransition(am, from, to);
 6172|  3.14k|    if (to == NULL)
  ------------------
  |  Branch (6172:9): [True: 965, False: 2.18k]
  ------------------
 6173|    965|	return(am->state);
 6174|  2.18k|    return(to);
 6175|  3.14k|}
xmlAutomataCompile:
 6285|    593|xmlAutomataCompile(xmlAutomataPtr am) {
 6286|    593|    xmlRegexpPtr ret;
 6287|       |
 6288|    593|    if ((am == NULL) || (am->error != 0)) return(NULL);
  ------------------
  |  Branch (6288:9): [True: 0, False: 593]
  |  Branch (6288:25): [True: 0, False: 593]
  ------------------
 6289|    593|    xmlFAEliminateEpsilonTransitions(am);
 6290|       |    /* xmlFAComputesDeterminism(am); */
 6291|    593|    ret = xmlRegEpxFromParse(am);
 6292|       |
 6293|    593|    return(ret);
 6294|    593|}
xmlregexp.c:xmlRegExecPushStringInternal:
 3692|  10.0k|	                     void *data, int compound) {
 3693|  10.0k|    xmlRegTransPtr trans;
 3694|  10.0k|    xmlRegAtomPtr atom;
 3695|  10.0k|    int ret;
 3696|  10.0k|    int final = 0;
 3697|  10.0k|    int progress = 1;
 3698|       |
 3699|  10.0k|    if (exec == NULL)
  ------------------
  |  Branch (3699:9): [True: 0, False: 10.0k]
  ------------------
 3700|      0|	return(-1);
 3701|  10.0k|    if (exec->comp == NULL)
  ------------------
  |  Branch (3701:9): [True: 0, False: 10.0k]
  ------------------
 3702|      0|	return(-1);
 3703|  10.0k|    if (exec->status != XML_REGEXP_OK)
  ------------------
  |  |   44|  10.0k|#define XML_REGEXP_OK               0
  ------------------
  |  Branch (3703:9): [True: 5, False: 10.0k]
  ------------------
 3704|      5|	return(exec->status);
 3705|       |
 3706|  10.0k|    if (exec->comp->compact != NULL)
  ------------------
  |  Branch (3706:9): [True: 10.0k, False: 3]
  ------------------
 3707|  10.0k|	return(xmlRegCompactPushString(exec, exec->comp, value, data));
 3708|       |
 3709|      3|    if (value == NULL) {
  ------------------
  |  Branch (3709:9): [True: 1, False: 2]
  ------------------
 3710|      1|        if (exec->state->type == XML_REGEXP_FINAL_STATE)
  ------------------
  |  Branch (3710:13): [True: 1, False: 0]
  ------------------
 3711|      1|	    return(1);
 3712|      0|	final = 1;
 3713|      0|    }
 3714|       |
 3715|       |    /*
 3716|       |     * If we have an active rollback stack push the new value there
 3717|       |     * and get back to where we were left
 3718|       |     */
 3719|      2|    if ((value != NULL) && (exec->inputStackNr > 0)) {
  ------------------
  |  Branch (3719:9): [True: 2, False: 0]
  |  Branch (3719:28): [True: 1, False: 1]
  ------------------
 3720|      1|	xmlFARegExecSaveInputString(exec, value, data);
 3721|      1|	value = exec->inputStack[exec->index].value;
 3722|      1|	data = exec->inputStack[exec->index].data;
 3723|      1|    }
 3724|       |
 3725|      6|    while ((exec->status == XML_REGEXP_OK) &&
  ------------------
  |  |   44|      6|#define XML_REGEXP_OK               0
  ------------------
  |  Branch (3725:12): [True: 6, False: 0]
  ------------------
 3726|      6|	   ((value != NULL) ||
  ------------------
  |  Branch (3726:6): [True: 4, False: 2]
  ------------------
 3727|      6|	    ((final == 1) &&
  ------------------
  |  Branch (3727:7): [True: 0, False: 2]
  ------------------
 3728|      4|	     (exec->state->type != XML_REGEXP_FINAL_STATE)))) {
  ------------------
  |  Branch (3728:7): [True: 0, False: 0]
  ------------------
 3729|       |
 3730|       |	/*
 3731|       |	 * End of input on non-terminal state, rollback, however we may
 3732|       |	 * still have epsilon like transition for counted transitions
 3733|       |	 * on counters, in that case don't break too early.
 3734|       |	 */
 3735|      4|	if ((value == NULL) && (exec->counts == NULL))
  ------------------
  |  Branch (3735:6): [True: 0, False: 4]
  |  Branch (3735:25): [True: 0, False: 0]
  ------------------
 3736|      0|	    goto rollback;
 3737|       |
 3738|      4|	exec->transcount = 0;
 3739|      7|	for (;exec->transno < exec->state->nbTrans;exec->transno++) {
  ------------------
  |  Branch (3739:8): [True: 6, False: 1]
  ------------------
 3740|      6|	    trans = &exec->state->trans[exec->transno];
 3741|      6|	    if (trans->to < 0)
  ------------------
  |  Branch (3741:10): [True: 2, False: 4]
  ------------------
 3742|      2|		continue;
 3743|      4|	    atom = trans->atom;
 3744|      4|	    ret = 0;
 3745|      4|	    if (trans->count == REGEXP_ALL_LAX_COUNTER) {
  ------------------
  |  |  359|      4|#define REGEXP_ALL_LAX_COUNTER	0x123457
  ------------------
  |  Branch (3745:10): [True: 0, False: 4]
  ------------------
 3746|      0|		int i;
 3747|      0|		int count;
 3748|      0|		xmlRegTransPtr t;
 3749|      0|		xmlRegCounterPtr counter;
 3750|       |
 3751|      0|		ret = 0;
 3752|       |
 3753|       |		/*
 3754|       |		 * Check all counted transitions from the current state
 3755|       |		 */
 3756|      0|		if ((value == NULL) && (final)) {
  ------------------
  |  Branch (3756:7): [True: 0, False: 0]
  |  Branch (3756:26): [True: 0, False: 0]
  ------------------
 3757|      0|		    ret = 1;
 3758|      0|		} else if (value != NULL) {
  ------------------
  |  Branch (3758:14): [True: 0, False: 0]
  ------------------
 3759|      0|		    for (i = 0;i < exec->state->nbTrans;i++) {
  ------------------
  |  Branch (3759:18): [True: 0, False: 0]
  ------------------
 3760|      0|			t = &exec->state->trans[i];
 3761|      0|			if ((t->counter < 0) || (t == trans))
  ------------------
  |  Branch (3761:8): [True: 0, False: 0]
  |  Branch (3761:28): [True: 0, False: 0]
  ------------------
 3762|      0|			    continue;
 3763|      0|			counter = &exec->comp->counters[t->counter];
 3764|      0|			count = exec->counts[t->counter];
 3765|      0|			if ((count < counter->max) &&
  ------------------
  |  Branch (3765:8): [True: 0, False: 0]
  ------------------
 3766|      0|		            (t->atom != NULL) &&
  ------------------
  |  Branch (3766:15): [True: 0, False: 0]
  ------------------
 3767|      0|			    (xmlStrEqual(value, t->atom->valuep))) {
  ------------------
  |  Branch (3767:8): [True: 0, False: 0]
  ------------------
 3768|      0|			    ret = 0;
 3769|      0|			    break;
 3770|      0|			}
 3771|      0|			if ((count >= counter->min) &&
  ------------------
  |  Branch (3771:8): [True: 0, False: 0]
  ------------------
 3772|      0|			    (count < counter->max) &&
  ------------------
  |  Branch (3772:8): [True: 0, False: 0]
  ------------------
 3773|      0|			    (t->atom != NULL) &&
  ------------------
  |  Branch (3773:8): [True: 0, False: 0]
  ------------------
 3774|      0|			    (xmlStrEqual(value, t->atom->valuep))) {
  ------------------
  |  Branch (3774:8): [True: 0, False: 0]
  ------------------
 3775|      0|			    ret = 1;
 3776|      0|			    break;
 3777|      0|			}
 3778|      0|		    }
 3779|      0|		}
 3780|      4|	    } else if (trans->count == REGEXP_ALL_COUNTER) {
  ------------------
  |  |  358|      4|#define REGEXP_ALL_COUNTER	0x123456
  ------------------
  |  Branch (3780:17): [True: 0, False: 4]
  ------------------
 3781|      0|		int i;
 3782|      0|		int count;
 3783|      0|		xmlRegTransPtr t;
 3784|      0|		xmlRegCounterPtr counter;
 3785|       |
 3786|      0|		ret = 1;
 3787|       |
 3788|       |		/*
 3789|       |		 * Check all counted transitions from the current state
 3790|       |		 */
 3791|      0|		for (i = 0;i < exec->state->nbTrans;i++) {
  ------------------
  |  Branch (3791:14): [True: 0, False: 0]
  ------------------
 3792|      0|                    t = &exec->state->trans[i];
 3793|      0|		    if ((t->counter < 0) || (t == trans))
  ------------------
  |  Branch (3793:11): [True: 0, False: 0]
  |  Branch (3793:31): [True: 0, False: 0]
  ------------------
 3794|      0|			continue;
 3795|      0|                    counter = &exec->comp->counters[t->counter];
 3796|      0|		    count = exec->counts[t->counter];
 3797|      0|		    if ((count < counter->min) || (count > counter->max)) {
  ------------------
  |  Branch (3797:11): [True: 0, False: 0]
  |  Branch (3797:37): [True: 0, False: 0]
  ------------------
 3798|      0|			ret = 0;
 3799|      0|			break;
 3800|      0|		    }
 3801|      0|		}
 3802|      4|	    } else if (trans->count >= 0) {
  ------------------
  |  Branch (3802:17): [True: 0, False: 4]
  ------------------
 3803|      0|		int count;
 3804|      0|		xmlRegCounterPtr counter;
 3805|       |
 3806|       |		/*
 3807|       |		 * A counted transition.
 3808|       |		 */
 3809|       |
 3810|      0|		count = exec->counts[trans->count];
 3811|      0|		counter = &exec->comp->counters[trans->count];
 3812|      0|		ret = ((count >= counter->min) && (count <= counter->max));
  ------------------
  |  Branch (3812:10): [True: 0, False: 0]
  |  Branch (3812:37): [True: 0, False: 0]
  ------------------
 3813|      4|	    } else if (atom == NULL) {
  ------------------
  |  Branch (3813:17): [True: 0, False: 4]
  ------------------
 3814|      0|		fprintf(stderr, "epsilon transition left at runtime\n");
 3815|      0|		exec->status = XML_REGEXP_INTERNAL_ERROR;
  ------------------
  |  |   46|      0|#define XML_REGEXP_INTERNAL_ERROR   (-4)
  ------------------
 3816|      0|		break;
 3817|      4|	    } else if (value != NULL) {
  ------------------
  |  Branch (3817:17): [True: 4, False: 0]
  ------------------
 3818|      4|		ret = xmlRegStrEqualWildcard(atom->valuep, value);
 3819|      4|		if (atom->neg) {
  ------------------
  |  Branch (3819:7): [True: 0, False: 4]
  ------------------
 3820|      0|		    ret = !ret;
 3821|      0|		    if (!compound)
  ------------------
  |  Branch (3821:11): [True: 0, False: 0]
  ------------------
 3822|      0|		        ret = 0;
 3823|      0|		}
 3824|      4|		if ((ret == 1) && (trans->counter >= 0)) {
  ------------------
  |  Branch (3824:7): [True: 3, False: 1]
  |  Branch (3824:21): [True: 0, False: 3]
  ------------------
 3825|      0|		    xmlRegCounterPtr counter;
 3826|      0|		    int count;
 3827|       |
 3828|      0|		    count = exec->counts[trans->counter];
 3829|      0|		    counter = &exec->comp->counters[trans->counter];
 3830|      0|		    if (count >= counter->max)
  ------------------
  |  Branch (3830:11): [True: 0, False: 0]
  ------------------
 3831|      0|			ret = 0;
 3832|      0|		}
 3833|       |
 3834|      4|		if ((ret == 1) && (atom->min > 0) && (atom->max > 0)) {
  ------------------
  |  Branch (3834:7): [True: 3, False: 1]
  |  Branch (3834:21): [True: 0, False: 3]
  |  Branch (3834:40): [True: 0, False: 0]
  ------------------
 3835|      0|		    xmlRegStatePtr to = exec->comp->states[trans->to];
 3836|       |
 3837|       |		    /*
 3838|       |		     * this is a multiple input sequence
 3839|       |		     */
 3840|      0|		    if (exec->state->nbTrans > exec->transno + 1) {
  ------------------
  |  Branch (3840:11): [True: 0, False: 0]
  ------------------
 3841|      0|			if (exec->inputStackNr <= 0) {
  ------------------
  |  Branch (3841:8): [True: 0, False: 0]
  ------------------
 3842|      0|			    xmlFARegExecSaveInputString(exec, value, data);
 3843|      0|			}
 3844|      0|			xmlFARegExecSave(exec);
 3845|      0|		    }
 3846|      0|		    exec->transcount = 1;
 3847|      0|		    do {
 3848|       |			/*
 3849|       |			 * Try to progress as much as possible on the input
 3850|       |			 */
 3851|      0|			if (exec->transcount == atom->max) {
  ------------------
  |  Branch (3851:8): [True: 0, False: 0]
  ------------------
 3852|      0|			    break;
 3853|      0|			}
 3854|      0|			exec->index++;
 3855|      0|			value = exec->inputStack[exec->index].value;
 3856|      0|			data = exec->inputStack[exec->index].data;
 3857|       |
 3858|       |			/*
 3859|       |			 * End of input: stop here
 3860|       |			 */
 3861|      0|			if (value == NULL) {
  ------------------
  |  Branch (3861:8): [True: 0, False: 0]
  ------------------
 3862|      0|			    exec->index --;
 3863|      0|			    break;
 3864|      0|			}
 3865|      0|			if (exec->transcount >= atom->min) {
  ------------------
  |  Branch (3865:8): [True: 0, False: 0]
  ------------------
 3866|      0|			    int transno = exec->transno;
 3867|      0|			    xmlRegStatePtr state = exec->state;
 3868|       |
 3869|       |			    /*
 3870|       |			     * The transition is acceptable save it
 3871|       |			     */
 3872|      0|			    exec->transno = -1; /* trick */
 3873|      0|			    exec->state = to;
 3874|      0|			    if (exec->inputStackNr <= 0) {
  ------------------
  |  Branch (3874:12): [True: 0, False: 0]
  ------------------
 3875|      0|				xmlFARegExecSaveInputString(exec, value, data);
 3876|      0|			    }
 3877|      0|			    xmlFARegExecSave(exec);
 3878|      0|			    exec->transno = transno;
 3879|      0|			    exec->state = state;
 3880|      0|			}
 3881|      0|			ret = xmlStrEqual(value, atom->valuep);
 3882|      0|			exec->transcount++;
 3883|      0|		    } while (ret == 1);
  ------------------
  |  Branch (3883:16): [True: 0, False: 0]
  ------------------
 3884|      0|		    if (exec->transcount < atom->min)
  ------------------
  |  Branch (3884:11): [True: 0, False: 0]
  ------------------
 3885|      0|			ret = 0;
 3886|       |
 3887|       |		    /*
 3888|       |		     * If the last check failed but one transition was found
 3889|       |		     * possible, rollback
 3890|       |		     */
 3891|      0|		    if (ret < 0)
  ------------------
  |  Branch (3891:11): [True: 0, False: 0]
  ------------------
 3892|      0|			ret = 0;
 3893|      0|		    if (ret == 0) {
  ------------------
  |  Branch (3893:11): [True: 0, False: 0]
  ------------------
 3894|      0|			goto rollback;
 3895|      0|		    }
 3896|      0|		}
 3897|      4|	    }
 3898|      4|	    if (ret == 1) {
  ------------------
  |  Branch (3898:10): [True: 3, False: 1]
  ------------------
 3899|      3|		if ((exec->callback != NULL) && (atom != NULL) &&
  ------------------
  |  Branch (3899:7): [True: 0, False: 3]
  |  Branch (3899:35): [True: 0, False: 0]
  ------------------
 3900|      3|			(data != NULL)) {
  ------------------
  |  Branch (3900:4): [True: 0, False: 0]
  ------------------
 3901|      0|		    exec->callback(exec->data, atom->valuep,
 3902|      0|			           atom->data, data);
 3903|      0|		}
 3904|      3|		if (exec->state->nbTrans > exec->transno + 1) {
  ------------------
  |  Branch (3904:7): [True: 1, False: 2]
  ------------------
 3905|      1|		    if (exec->inputStackNr <= 0) {
  ------------------
  |  Branch (3905:11): [True: 1, False: 0]
  ------------------
 3906|      1|			xmlFARegExecSaveInputString(exec, value, data);
 3907|      1|		    }
 3908|      1|		    xmlFARegExecSave(exec);
 3909|      1|		}
 3910|      3|		if (trans->counter >= 0) {
  ------------------
  |  Branch (3910:7): [True: 0, False: 3]
  ------------------
 3911|      0|		    exec->counts[trans->counter]++;
 3912|      0|		}
 3913|      3|		if ((trans->count >= 0) &&
  ------------------
  |  Branch (3913:7): [True: 0, False: 3]
  ------------------
 3914|      3|		    (trans->count < REGEXP_ALL_COUNTER)) {
  ------------------
  |  |  358|      0|#define REGEXP_ALL_COUNTER	0x123456
  ------------------
  |  Branch (3914:7): [True: 0, False: 0]
  ------------------
 3915|      0|		    exec->counts[trans->count] = 0;
 3916|      0|		}
 3917|      3|                if ((exec->comp->states[trans->to] != NULL) &&
  ------------------
  |  Branch (3917:21): [True: 3, False: 0]
  ------------------
 3918|      3|		    (exec->comp->states[trans->to]->type ==
  ------------------
  |  Branch (3918:7): [True: 0, False: 3]
  ------------------
 3919|      3|		     XML_REGEXP_SINK_STATE)) {
 3920|       |		    /*
 3921|       |		     * entering a sink state, save the current state as error
 3922|       |		     * state.
 3923|       |		     */
 3924|      0|		    if (exec->errString != NULL)
  ------------------
  |  Branch (3924:11): [True: 0, False: 0]
  ------------------
 3925|      0|			xmlFree(exec->errString);
 3926|      0|		    exec->errString = xmlStrdup(value);
 3927|      0|		    exec->errState = exec->state;
 3928|      0|		    memcpy(exec->errCounts, exec->counts,
 3929|      0|			   exec->comp->nbCounters * sizeof(int));
 3930|      0|		}
 3931|      3|		exec->state = exec->comp->states[trans->to];
 3932|      3|		exec->transno = 0;
 3933|      3|		if (trans->atom != NULL) {
  ------------------
  |  Branch (3933:7): [True: 3, False: 0]
  ------------------
 3934|      3|		    if (exec->inputStack != NULL) {
  ------------------
  |  Branch (3934:11): [True: 3, False: 0]
  ------------------
 3935|      3|			exec->index++;
 3936|      3|			if (exec->index < exec->inputStackNr) {
  ------------------
  |  Branch (3936:8): [True: 1, False: 2]
  ------------------
 3937|      1|			    value = exec->inputStack[exec->index].value;
 3938|      1|			    data = exec->inputStack[exec->index].data;
 3939|      2|			} else {
 3940|      2|			    value = NULL;
 3941|      2|			    data = NULL;
 3942|      2|			}
 3943|      3|		    } else {
 3944|      0|			value = NULL;
 3945|      0|			data = NULL;
 3946|      0|		    }
 3947|      3|		}
 3948|      3|		goto progress;
 3949|      3|	    } else if (ret < 0) {
  ------------------
  |  Branch (3949:17): [True: 0, False: 1]
  ------------------
 3950|      0|		exec->status = XML_REGEXP_INTERNAL_ERROR;
  ------------------
  |  |   46|      0|#define XML_REGEXP_INTERNAL_ERROR   (-4)
  ------------------
 3951|      0|		break;
 3952|      0|	    }
 3953|      4|	}
 3954|      1|	if ((exec->transno != 0) || (exec->state->nbTrans == 0)) {
  ------------------
  |  Branch (3954:6): [True: 1, False: 0]
  |  Branch (3954:30): [True: 0, False: 0]
  ------------------
 3955|      1|rollback:
 3956|       |            /*
 3957|       |	     * if we didn't yet rollback on the current input
 3958|       |	     * store the current state as the error state.
 3959|       |	     */
 3960|      1|	    if ((progress) && (exec->state != NULL) &&
  ------------------
  |  Branch (3960:10): [True: 1, False: 0]
  |  Branch (3960:24): [True: 1, False: 0]
  ------------------
 3961|      1|	        (exec->state->type != XML_REGEXP_SINK_STATE)) {
  ------------------
  |  Branch (3961:10): [True: 1, False: 0]
  ------------------
 3962|      1|	        progress = 0;
 3963|      1|		if (exec->errString != NULL)
  ------------------
  |  Branch (3963:7): [True: 0, False: 1]
  ------------------
 3964|      0|		    xmlFree(exec->errString);
 3965|      1|		exec->errString = xmlStrdup(value);
 3966|      1|		exec->errState = exec->state;
 3967|      1|                if (exec->comp->nbCounters)
  ------------------
  |  Branch (3967:21): [True: 0, False: 1]
  ------------------
 3968|      0|                    memcpy(exec->errCounts, exec->counts,
 3969|      0|                           exec->comp->nbCounters * sizeof(int));
 3970|      1|	    }
 3971|       |
 3972|       |	    /*
 3973|       |	     * Failed to find a way out
 3974|       |	     */
 3975|      1|	    exec->determinist = 0;
 3976|      1|	    xmlFARegExecRollBack(exec);
 3977|      1|	    if ((exec->inputStack != NULL ) &&
  ------------------
  |  Branch (3977:10): [True: 1, False: 0]
  ------------------
 3978|      1|                (exec->status == XML_REGEXP_OK)) {
  ------------------
  |  |   44|      1|#define XML_REGEXP_OK               0
  ------------------
  |  Branch (3978:17): [True: 1, False: 0]
  ------------------
 3979|      1|		value = exec->inputStack[exec->index].value;
 3980|      1|		data = exec->inputStack[exec->index].data;
 3981|      1|	    }
 3982|      1|	}
 3983|      1|	continue;
 3984|      3|progress:
 3985|      3|        progress = 1;
 3986|      3|	continue;
 3987|      1|    }
 3988|      2|    if (exec->status == XML_REGEXP_OK) {
  ------------------
  |  |   44|      2|#define XML_REGEXP_OK               0
  ------------------
  |  Branch (3988:9): [True: 2, False: 0]
  ------------------
 3989|      2|        return(exec->state->type == XML_REGEXP_FINAL_STATE);
 3990|      2|    }
 3991|      0|    return(exec->status);
 3992|      2|}
xmlregexp.c:xmlFARegExecSaveInputString:
 3528|      2|	                    void *data) {
 3529|      2|    if (exec->inputStackMax == 0) {
  ------------------
  |  Branch (3529:9): [True: 1, False: 1]
  ------------------
 3530|      1|	exec->inputStackMax = 4;
 3531|      1|	exec->inputStack = (xmlRegInputTokenPtr)
 3532|      1|	    xmlMalloc(exec->inputStackMax * sizeof(xmlRegInputToken));
 3533|      1|	if (exec->inputStack == NULL) {
  ------------------
  |  Branch (3533:6): [True: 0, False: 1]
  ------------------
 3534|      0|	    xmlRegexpErrMemory(NULL, "pushing input string");
 3535|      0|	    exec->inputStackMax = 0;
 3536|      0|	    return;
 3537|      0|	}
 3538|      1|    } else if (exec->inputStackNr + 1 >= exec->inputStackMax) {
  ------------------
  |  Branch (3538:16): [True: 0, False: 1]
  ------------------
 3539|      0|	xmlRegInputTokenPtr tmp;
 3540|       |
 3541|      0|	exec->inputStackMax *= 2;
 3542|      0|	tmp = (xmlRegInputTokenPtr) xmlRealloc(exec->inputStack,
 3543|      0|			exec->inputStackMax * sizeof(xmlRegInputToken));
 3544|      0|	if (tmp == NULL) {
  ------------------
  |  Branch (3544:6): [True: 0, False: 0]
  ------------------
 3545|      0|	    xmlRegexpErrMemory(NULL, "pushing input string");
 3546|      0|	    exec->inputStackMax /= 2;
 3547|      0|	    return;
 3548|      0|	}
 3549|      0|	exec->inputStack = tmp;
 3550|      0|    }
 3551|      2|    exec->inputStack[exec->inputStackNr].value = xmlStrdup(value);
 3552|      2|    exec->inputStack[exec->inputStackNr].data = data;
 3553|      2|    exec->inputStackNr++;
 3554|      2|    exec->inputStack[exec->inputStackNr].value = NULL;
 3555|      2|    exec->inputStack[exec->inputStackNr].data = NULL;
 3556|      2|}
xmlregexp.c:xmlRegStrEqualWildcard:
 3572|  32.7k|xmlRegStrEqualWildcard(const xmlChar *expStr, const xmlChar *valStr) {
 3573|  32.7k|    if (expStr == valStr) return(1);
  ------------------
  |  Branch (3573:9): [True: 0, False: 32.7k]
  ------------------
 3574|  32.7k|    if (expStr == NULL) return(0);
  ------------------
  |  Branch (3574:9): [True: 0, False: 32.7k]
  ------------------
 3575|  32.7k|    if (valStr == NULL) return(0);
  ------------------
  |  Branch (3575:9): [True: 0, False: 32.7k]
  ------------------
 3576|  59.6k|    do {
 3577|       |	/*
 3578|       |	* Eval if we have a wildcard for the current item.
 3579|       |	*/
 3580|  59.6k|        if (*expStr != *valStr) {
  ------------------
  |  Branch (3580:13): [True: 25.3k, False: 34.2k]
  ------------------
 3581|       |	    /* if one of them starts with a wildcard make valStr be it */
 3582|  25.3k|	    if (*valStr == '*') {
  ------------------
  |  Branch (3582:10): [True: 0, False: 25.3k]
  ------------------
 3583|      0|	        const xmlChar *tmp;
 3584|       |
 3585|      0|		tmp = valStr;
 3586|      0|		valStr = expStr;
 3587|      0|		expStr = tmp;
 3588|      0|	    }
 3589|  25.3k|	    if ((*valStr != 0) && (*expStr != 0) && (*expStr++ == '*')) {
  ------------------
  |  Branch (3589:10): [True: 25.3k, False: 0]
  |  Branch (3589:28): [True: 25.3k, False: 60]
  |  Branch (3589:46): [True: 0, False: 25.3k]
  ------------------
 3590|      0|		do {
 3591|      0|		    if (*valStr == XML_REG_STRING_SEPARATOR)
  ------------------
  |  |   62|      0|#define XML_REG_STRING_SEPARATOR '|'
  ------------------
  |  Branch (3591:11): [True: 0, False: 0]
  ------------------
 3592|      0|			break;
 3593|      0|		    valStr++;
 3594|      0|		} while (*valStr != 0);
  ------------------
  |  Branch (3594:12): [True: 0, False: 0]
  ------------------
 3595|      0|		continue;
 3596|      0|	    } else
 3597|  25.3k|		return(0);
 3598|  25.3k|	}
 3599|  34.2k|	expStr++;
 3600|  34.2k|	valStr++;
 3601|  34.2k|    } while (*valStr != 0);
  ------------------
  |  Branch (3601:14): [True: 26.8k, False: 7.39k]
  ------------------
 3602|  7.39k|    if (*expStr != 0)
  ------------------
  |  Branch (3602:9): [True: 112, False: 7.28k]
  ------------------
 3603|    112|	return (0);
 3604|  7.28k|    else
 3605|  7.28k|	return (1);
 3606|  7.39k|}
xmlregexp.c:xmlFARegExecSave:
 3049|      1|xmlFARegExecSave(xmlRegExecCtxtPtr exec) {
 3050|      1|#ifdef MAX_PUSH
 3051|      1|    if (exec->nbPush > MAX_PUSH) {
  ------------------
  |  |   39|      1|#define MAX_PUSH 10000000
  ------------------
  |  Branch (3051:9): [True: 0, False: 1]
  ------------------
 3052|      0|        exec->status = XML_REGEXP_INTERNAL_LIMIT;
  ------------------
  |  |   48|      0|#define XML_REGEXP_INTERNAL_LIMIT   (-6)
  ------------------
 3053|      0|        return;
 3054|      0|    }
 3055|      1|    exec->nbPush++;
 3056|      1|#endif
 3057|       |
 3058|      1|    if (exec->maxRollbacks == 0) {
  ------------------
  |  Branch (3058:9): [True: 1, False: 0]
  ------------------
 3059|      1|	exec->maxRollbacks = 4;
 3060|      1|	exec->rollbacks = (xmlRegExecRollback *) xmlMalloc(exec->maxRollbacks *
 3061|      1|		                             sizeof(xmlRegExecRollback));
 3062|      1|	if (exec->rollbacks == NULL) {
  ------------------
  |  Branch (3062:6): [True: 0, False: 1]
  ------------------
 3063|      0|	    xmlRegexpErrMemory(NULL, "saving regexp");
 3064|      0|	    exec->maxRollbacks = 0;
 3065|      0|            exec->status = XML_REGEXP_OUT_OF_MEMORY;
  ------------------
  |  |   47|      0|#define XML_REGEXP_OUT_OF_MEMORY    (-5)
  ------------------
 3066|      0|	    return;
 3067|      0|	}
 3068|      1|	memset(exec->rollbacks, 0,
 3069|      1|	       exec->maxRollbacks * sizeof(xmlRegExecRollback));
 3070|      1|    } else if (exec->nbRollbacks >= exec->maxRollbacks) {
  ------------------
  |  Branch (3070:16): [True: 0, False: 0]
  ------------------
 3071|      0|	xmlRegExecRollback *tmp;
 3072|      0|	int len = exec->maxRollbacks;
 3073|       |
 3074|      0|	exec->maxRollbacks *= 2;
 3075|      0|	tmp = (xmlRegExecRollback *) xmlRealloc(exec->rollbacks,
 3076|      0|			exec->maxRollbacks * sizeof(xmlRegExecRollback));
 3077|      0|	if (tmp == NULL) {
  ------------------
  |  Branch (3077:6): [True: 0, False: 0]
  ------------------
 3078|      0|	    xmlRegexpErrMemory(NULL, "saving regexp");
 3079|      0|	    exec->maxRollbacks /= 2;
 3080|      0|            exec->status = XML_REGEXP_OUT_OF_MEMORY;
  ------------------
  |  |   47|      0|#define XML_REGEXP_OUT_OF_MEMORY    (-5)
  ------------------
 3081|      0|	    return;
 3082|      0|	}
 3083|      0|	exec->rollbacks = tmp;
 3084|      0|	tmp = &exec->rollbacks[len];
 3085|      0|	memset(tmp, 0, (exec->maxRollbacks - len) * sizeof(xmlRegExecRollback));
 3086|      0|    }
 3087|      1|    exec->rollbacks[exec->nbRollbacks].state = exec->state;
 3088|      1|    exec->rollbacks[exec->nbRollbacks].index = exec->index;
 3089|      1|    exec->rollbacks[exec->nbRollbacks].nextbranch = exec->transno + 1;
 3090|      1|    if (exec->comp->nbCounters > 0) {
  ------------------
  |  Branch (3090:9): [True: 0, False: 1]
  ------------------
 3091|      0|	if (exec->rollbacks[exec->nbRollbacks].counts == NULL) {
  ------------------
  |  Branch (3091:6): [True: 0, False: 0]
  ------------------
 3092|      0|	    exec->rollbacks[exec->nbRollbacks].counts = (int *)
 3093|      0|		xmlMalloc(exec->comp->nbCounters * sizeof(int));
 3094|      0|	    if (exec->rollbacks[exec->nbRollbacks].counts == NULL) {
  ------------------
  |  Branch (3094:10): [True: 0, False: 0]
  ------------------
 3095|      0|		xmlRegexpErrMemory(NULL, "saving regexp");
 3096|      0|		exec->status = XML_REGEXP_OUT_OF_MEMORY;
  ------------------
  |  |   47|      0|#define XML_REGEXP_OUT_OF_MEMORY    (-5)
  ------------------
 3097|      0|		return;
 3098|      0|	    }
 3099|      0|	}
 3100|      0|	memcpy(exec->rollbacks[exec->nbRollbacks].counts, exec->counts,
 3101|      0|	       exec->comp->nbCounters * sizeof(int));
 3102|      0|    }
 3103|      1|    exec->nbRollbacks++;
 3104|      1|}
xmlregexp.c:xmlFARegExecRollBack:
 3107|      1|xmlFARegExecRollBack(xmlRegExecCtxtPtr exec) {
 3108|      1|    if (exec->status != XML_REGEXP_OK)
  ------------------
  |  |   44|      1|#define XML_REGEXP_OK               0
  ------------------
  |  Branch (3108:9): [True: 0, False: 1]
  ------------------
 3109|      0|        return;
 3110|      1|    if (exec->nbRollbacks <= 0) {
  ------------------
  |  Branch (3110:9): [True: 0, False: 1]
  ------------------
 3111|      0|	exec->status = XML_REGEXP_NOT_FOUND;
  ------------------
  |  |   45|      0|#define XML_REGEXP_NOT_FOUND        (-1)
  ------------------
 3112|      0|	return;
 3113|      0|    }
 3114|      1|    exec->nbRollbacks--;
 3115|      1|    exec->state = exec->rollbacks[exec->nbRollbacks].state;
 3116|      1|    exec->index = exec->rollbacks[exec->nbRollbacks].index;
 3117|      1|    exec->transno = exec->rollbacks[exec->nbRollbacks].nextbranch;
 3118|      1|    if (exec->comp->nbCounters > 0) {
  ------------------
  |  Branch (3118:9): [True: 0, False: 1]
  ------------------
 3119|      0|	if (exec->rollbacks[exec->nbRollbacks].counts == NULL) {
  ------------------
  |  Branch (3119:6): [True: 0, False: 0]
  ------------------
 3120|      0|	    fprintf(stderr, "exec save: allocation failed");
 3121|      0|	    exec->status = XML_REGEXP_INTERNAL_ERROR;
  ------------------
  |  |   46|      0|#define XML_REGEXP_INTERNAL_ERROR   (-4)
  ------------------
 3122|      0|	    return;
 3123|      0|	}
 3124|      0|	if (exec->counts) {
  ------------------
  |  Branch (3124:6): [True: 0, False: 0]
  ------------------
 3125|      0|	    memcpy(exec->counts, exec->rollbacks[exec->nbRollbacks].counts,
 3126|      0|	       exec->comp->nbCounters * sizeof(int));
 3127|      0|	}
 3128|      0|    }
 3129|      1|}
xmlregexp.c:xmlRegCompactPushString:
 3624|  10.0k|	                void *data) {
 3625|  10.0k|    int state = exec->index;
 3626|  10.0k|    int i, target;
 3627|       |
 3628|  10.0k|    if ((comp == NULL) || (comp->compact == NULL) || (comp->stringMap == NULL))
  ------------------
  |  Branch (3628:9): [True: 0, False: 10.0k]
  |  Branch (3628:27): [True: 0, False: 10.0k]
  |  Branch (3628:54): [True: 0, False: 10.0k]
  ------------------
 3629|      0|	return(-1);
 3630|       |
 3631|  10.0k|    if (value == NULL) {
  ------------------
  |  Branch (3631:9): [True: 2.80k, False: 7.28k]
  ------------------
 3632|       |	/*
 3633|       |	 * are we at a final state ?
 3634|       |	 */
 3635|  2.80k|	if (comp->compact[state * (comp->nbstrings + 1)] ==
  ------------------
  |  Branch (3635:6): [True: 2.78k, False: 20]
  ------------------
 3636|  2.80k|            XML_REGEXP_FINAL_STATE)
 3637|  2.78k|	    return(1);
 3638|     20|	return(0);
 3639|  2.80k|    }
 3640|       |
 3641|       |    /*
 3642|       |     * Examine all outside transitions from current state
 3643|       |     */
 3644|  19.3k|    for (i = 0;i < comp->nbstrings;i++) {
  ------------------
  |  Branch (3644:16): [True: 19.3k, False: 5]
  ------------------
 3645|  19.3k|	target = comp->compact[state * (comp->nbstrings + 1) + i + 1];
 3646|  19.3k|	if ((target > 0) && (target <= comp->nbstates)) {
  ------------------
  |  Branch (3646:6): [True: 11.4k, False: 7.88k]
  |  Branch (3646:22): [True: 11.4k, False: 0]
  ------------------
 3647|  11.4k|	    target--; /* to avoid 0 */
 3648|  11.4k|	    if (xmlRegStrEqualWildcard(comp->stringMap[i], value)) {
  ------------------
  |  Branch (3648:10): [True: 7.27k, False: 4.19k]
  ------------------
 3649|  7.27k|		exec->index = target;
 3650|  7.27k|		if ((exec->callback != NULL) && (comp->transdata != NULL)) {
  ------------------
  |  Branch (3650:7): [True: 0, False: 7.27k]
  |  Branch (3650:35): [True: 0, False: 0]
  ------------------
 3651|      0|		    exec->callback(exec->data, value,
 3652|      0|			  comp->transdata[state * comp->nbstrings + i], data);
 3653|      0|		}
 3654|  7.27k|		if (comp->compact[target * (comp->nbstrings + 1)] ==
  ------------------
  |  Branch (3654:7): [True: 0, False: 7.27k]
  ------------------
 3655|  7.27k|		    XML_REGEXP_SINK_STATE)
 3656|      0|		    goto error;
 3657|       |
 3658|  7.27k|		if (comp->compact[target * (comp->nbstrings + 1)] ==
  ------------------
  |  Branch (3658:7): [True: 6.06k, False: 1.21k]
  ------------------
 3659|  7.27k|		    XML_REGEXP_FINAL_STATE)
 3660|  6.06k|		    return(1);
 3661|  1.21k|		return(0);
 3662|  7.27k|	    }
 3663|  11.4k|	}
 3664|  19.3k|    }
 3665|       |    /*
 3666|       |     * Failed to find an exit transition out from current state for the
 3667|       |     * current token
 3668|       |     */
 3669|      5|error:
 3670|      5|    if (exec->errString != NULL)
  ------------------
  |  Branch (3670:9): [True: 0, False: 5]
  ------------------
 3671|      0|        xmlFree(exec->errString);
 3672|      5|    exec->errString = xmlStrdup(value);
 3673|      5|    exec->errStateNo = state;
 3674|      5|    exec->status = XML_REGEXP_NOT_FOUND;
  ------------------
  |  |   45|      5|#define XML_REGEXP_NOT_FOUND        (-1)
  ------------------
 3675|      5|    return(XML_REGEXP_NOT_FOUND);
  ------------------
  |  |   45|      5|#define XML_REGEXP_NOT_FOUND        (-1)
  ------------------
 3676|  7.28k|}
xmlregexp.c:xmlRegNewParserCtxt:
  694|  1.18k|xmlRegNewParserCtxt(const xmlChar *string) {
  695|  1.18k|    xmlRegParserCtxtPtr ret;
  696|       |
  697|  1.18k|    ret = (xmlRegParserCtxtPtr) xmlMalloc(sizeof(xmlRegParserCtxt));
  698|  1.18k|    if (ret == NULL)
  ------------------
  |  Branch (698:9): [True: 0, False: 1.18k]
  ------------------
  699|      0|	return(NULL);
  700|  1.18k|    memset(ret, 0, sizeof(xmlRegParserCtxt));
  701|  1.18k|    if (string != NULL)
  ------------------
  |  Branch (701:9): [True: 0, False: 1.18k]
  ------------------
  702|      0|	ret->string = xmlStrdup(string);
  703|  1.18k|    ret->cur = ret->string;
  704|  1.18k|    ret->neg = 0;
  705|  1.18k|    ret->negs = 0;
  706|  1.18k|    ret->error = 0;
  707|  1.18k|    ret->determinist = -1;
  708|  1.18k|    return(ret);
  709|  1.18k|}
xmlregexp.c:xmlRegStatePush:
 1369|  4.85k|xmlRegStatePush(xmlRegParserCtxtPtr ctxt) {
 1370|  4.85k|    xmlRegStatePtr state;
 1371|       |
 1372|  4.85k|    if (ctxt->nbStates >= ctxt->maxStates) {
  ------------------
  |  Branch (1372:9): [True: 1.78k, False: 3.07k]
  ------------------
 1373|  1.78k|        size_t newSize = ctxt->maxStates ? ctxt->maxStates * 2 : 4;
  ------------------
  |  Branch (1373:26): [True: 596, False: 1.18k]
  ------------------
 1374|  1.78k|	xmlRegStatePtr *tmp;
 1375|       |
 1376|  1.78k|	tmp = xmlRealloc(ctxt->states, newSize * sizeof(tmp[0]));
 1377|  1.78k|	if (tmp == NULL) {
  ------------------
  |  Branch (1377:6): [True: 0, False: 1.78k]
  ------------------
 1378|      0|	    xmlRegexpErrMemory(ctxt, "adding state");
 1379|      0|	    return(NULL);
 1380|      0|	}
 1381|  1.78k|	ctxt->states = tmp;
 1382|  1.78k|	ctxt->maxStates = newSize;
 1383|  1.78k|    }
 1384|       |
 1385|  4.85k|    state = xmlRegNewState(ctxt);
 1386|  4.85k|    if (state == NULL)
  ------------------
  |  Branch (1386:9): [True: 0, False: 4.85k]
  ------------------
 1387|      0|        return(NULL);
 1388|       |
 1389|  4.85k|    state->no = ctxt->nbStates;
 1390|  4.85k|    ctxt->states[ctxt->nbStates++] = state;
 1391|       |
 1392|  4.85k|    return(state);
 1393|  4.85k|}
xmlregexp.c:xmlRegNewState:
  885|  4.85k|xmlRegNewState(xmlRegParserCtxtPtr ctxt) {
  886|  4.85k|    xmlRegStatePtr ret;
  887|       |
  888|  4.85k|    ret = (xmlRegStatePtr) xmlMalloc(sizeof(xmlRegState));
  889|  4.85k|    if (ret == NULL) {
  ------------------
  |  Branch (889:9): [True: 0, False: 4.85k]
  ------------------
  890|      0|	xmlRegexpErrMemory(ctxt, "allocating state");
  891|      0|	return(NULL);
  892|      0|    }
  893|  4.85k|    memset(ret, 0, sizeof(xmlRegState));
  894|  4.85k|    ret->type = XML_REGEXP_TRANS_STATE;
  895|  4.85k|    ret->mark = XML_REGEXP_MARK_NORMAL;
  896|  4.85k|    return(ret);
  897|  4.85k|}
xmlregexp.c:xmlFAEliminateEpsilonTransitions:
 1877|    593|xmlFAEliminateEpsilonTransitions(xmlRegParserCtxtPtr ctxt) {
 1878|    593|    int statenr, transnr;
 1879|    593|    xmlRegStatePtr state;
 1880|    593|    int has_epsilon;
 1881|       |
 1882|    593|    if (ctxt->states == NULL) return;
  ------------------
  |  Branch (1882:9): [True: 0, False: 593]
  ------------------
 1883|       |
 1884|       |    /*
 1885|       |     * Eliminate simple epsilon transition and the associated unreachable
 1886|       |     * states.
 1887|       |     */
 1888|    593|    xmlFAEliminateSimpleEpsilonTransitions(ctxt);
 1889|  4.85k|    for (statenr = 0;statenr < ctxt->nbStates;statenr++) {
  ------------------
  |  Branch (1889:22): [True: 4.26k, False: 593]
  ------------------
 1890|  4.26k|	state = ctxt->states[statenr];
 1891|  4.26k|	if ((state != NULL) && (state->type == XML_REGEXP_UNREACH_STATE)) {
  ------------------
  |  Branch (1891:6): [True: 4.26k, False: 0]
  |  Branch (1891:25): [True: 1.82k, False: 2.43k]
  ------------------
 1892|  1.82k|	    xmlRegFreeState(state);
 1893|  1.82k|	    ctxt->states[statenr] = NULL;
 1894|  1.82k|	}
 1895|  4.26k|    }
 1896|       |
 1897|    593|    has_epsilon = 0;
 1898|       |
 1899|       |    /*
 1900|       |     * Build the completed transitions bypassing the epsilons
 1901|       |     * Use a marking algorithm to avoid loops
 1902|       |     * Mark sink states too.
 1903|       |     * Process from the latest states backward to the start when
 1904|       |     * there is long cascading epsilon chains this minimize the
 1905|       |     * recursions and transition compares when adding the new ones
 1906|       |     */
 1907|  4.85k|    for (statenr = ctxt->nbStates - 1;statenr >= 0;statenr--) {
  ------------------
  |  Branch (1907:39): [True: 4.26k, False: 593]
  ------------------
 1908|  4.26k|	state = ctxt->states[statenr];
 1909|  4.26k|	if (state == NULL)
  ------------------
  |  Branch (1909:6): [True: 1.82k, False: 2.43k]
  ------------------
 1910|  1.82k|	    continue;
 1911|  2.43k|	if ((state->nbTrans == 0) &&
  ------------------
  |  Branch (1911:6): [True: 416, False: 2.02k]
  ------------------
 1912|  2.43k|	    (state->type != XML_REGEXP_FINAL_STATE)) {
  ------------------
  |  Branch (1912:6): [True: 0, False: 416]
  ------------------
 1913|      0|	    state->type = XML_REGEXP_SINK_STATE;
 1914|      0|	}
 1915|  12.3k|	for (transnr = 0;transnr < state->nbTrans;transnr++) {
  ------------------
  |  Branch (1915:19): [True: 9.95k, False: 2.43k]
  ------------------
 1916|  9.95k|	    if ((state->trans[transnr].atom == NULL) &&
  ------------------
  |  Branch (1916:10): [True: 1.74k, False: 8.21k]
  ------------------
 1917|  9.95k|		(state->trans[transnr].to >= 0)) {
  ------------------
  |  Branch (1917:3): [True: 1.32k, False: 420]
  ------------------
 1918|  1.32k|		if (state->trans[transnr].to == statenr) {
  ------------------
  |  Branch (1918:7): [True: 0, False: 1.32k]
  ------------------
 1919|      0|		    state->trans[transnr].to = -1;
 1920|  1.32k|		} else if (state->trans[transnr].count < 0) {
  ------------------
  |  Branch (1920:14): [True: 1.32k, False: 0]
  ------------------
 1921|  1.32k|		    int newto = state->trans[transnr].to;
 1922|       |
 1923|  1.32k|		    has_epsilon = 1;
 1924|  1.32k|		    state->trans[transnr].to = -2;
 1925|  1.32k|		    state->mark = XML_REGEXP_MARK_START;
 1926|  1.32k|		    xmlFAReduceEpsilonTransitions(ctxt, statenr,
 1927|  1.32k|				      newto, state->trans[transnr].counter);
 1928|  1.32k|		    xmlFAFinishReduceEpsilonTransitions(ctxt, newto);
 1929|  1.32k|		    state->mark = XML_REGEXP_MARK_NORMAL;
 1930|  1.32k|	        }
 1931|  1.32k|	    }
 1932|  9.95k|	}
 1933|  2.43k|    }
 1934|       |    /*
 1935|       |     * Eliminate the epsilon transitions
 1936|       |     */
 1937|    593|    if (has_epsilon) {
  ------------------
  |  Branch (1937:9): [True: 393, False: 200]
  ------------------
 1938|  4.15k|	for (statenr = 0;statenr < ctxt->nbStates;statenr++) {
  ------------------
  |  Branch (1938:19): [True: 3.76k, False: 393]
  ------------------
 1939|  3.76k|	    state = ctxt->states[statenr];
 1940|  3.76k|	    if (state == NULL)
  ------------------
  |  Branch (1940:10): [True: 1.79k, False: 1.96k]
  ------------------
 1941|  1.79k|		continue;
 1942|  11.4k|	    for (transnr = 0;transnr < state->nbTrans;transnr++) {
  ------------------
  |  Branch (1942:23): [True: 9.52k, False: 1.96k]
  ------------------
 1943|  9.52k|		xmlRegTransPtr trans = &(state->trans[transnr]);
 1944|  9.52k|		if ((trans->atom == NULL) &&
  ------------------
  |  Branch (1944:7): [True: 1.74k, False: 7.78k]
  ------------------
 1945|  9.52k|		    (trans->count < 0) &&
  ------------------
  |  Branch (1945:7): [True: 1.74k, False: 0]
  ------------------
 1946|  9.52k|		    (trans->to >= 0)) {
  ------------------
  |  Branch (1946:7): [True: 0, False: 1.74k]
  ------------------
 1947|      0|		    trans->to = -1;
 1948|      0|		}
 1949|  9.52k|	    }
 1950|  1.96k|	}
 1951|    393|    }
 1952|       |
 1953|       |    /*
 1954|       |     * Use this pass to detect unreachable states too
 1955|       |     */
 1956|  4.85k|    for (statenr = 0;statenr < ctxt->nbStates;statenr++) {
  ------------------
  |  Branch (1956:22): [True: 4.26k, False: 593]
  ------------------
 1957|  4.26k|	state = ctxt->states[statenr];
 1958|  4.26k|	if (state != NULL)
  ------------------
  |  Branch (1958:6): [True: 2.43k, False: 1.82k]
  ------------------
 1959|  2.43k|	    state->reached = XML_REGEXP_MARK_NORMAL;
 1960|  4.26k|    }
 1961|    593|    state = ctxt->states[0];
 1962|    593|    if (state != NULL)
  ------------------
  |  Branch (1962:9): [True: 593, False: 0]
  ------------------
 1963|    593|	state->reached = XML_REGEXP_MARK_START;
 1964|  2.56k|    while (state != NULL) {
  ------------------
  |  Branch (1964:12): [True: 1.97k, False: 593]
  ------------------
 1965|  1.97k|	xmlRegStatePtr target = NULL;
 1966|  1.97k|	state->reached = XML_REGEXP_MARK_VISITED;
 1967|       |	/*
 1968|       |	 * Mark all states reachable from the current reachable state
 1969|       |	 */
 1970|  9.89k|	for (transnr = 0;transnr < state->nbTrans;transnr++) {
  ------------------
  |  Branch (1970:19): [True: 7.91k, False: 1.97k]
  ------------------
 1971|  7.91k|	    if ((state->trans[transnr].to >= 0) &&
  ------------------
  |  Branch (1971:10): [True: 5.53k, False: 2.38k]
  ------------------
 1972|  7.91k|		((state->trans[transnr].atom != NULL) ||
  ------------------
  |  Branch (1972:4): [True: 5.53k, False: 0]
  ------------------
 1973|  5.53k|		 (state->trans[transnr].count >= 0))) {
  ------------------
  |  Branch (1973:4): [True: 0, False: 0]
  ------------------
 1974|  5.53k|		int newto = state->trans[transnr].to;
 1975|       |
 1976|  5.53k|		if (ctxt->states[newto] == NULL)
  ------------------
  |  Branch (1976:7): [True: 0, False: 5.53k]
  ------------------
 1977|      0|		    continue;
 1978|  5.53k|		if (ctxt->states[newto]->reached == XML_REGEXP_MARK_NORMAL) {
  ------------------
  |  Branch (1978:7): [True: 1.38k, False: 4.15k]
  ------------------
 1979|  1.38k|		    ctxt->states[newto]->reached = XML_REGEXP_MARK_START;
 1980|  1.38k|		    target = ctxt->states[newto];
 1981|  1.38k|		}
 1982|  5.53k|	    }
 1983|  7.91k|	}
 1984|       |
 1985|       |	/*
 1986|       |	 * find the next accessible state not explored
 1987|       |	 */
 1988|  1.97k|	if (target == NULL) {
  ------------------
  |  Branch (1988:6): [True: 965, False: 1.00k]
  ------------------
 1989|  6.17k|	    for (statenr = 1;statenr < ctxt->nbStates;statenr++) {
  ------------------
  |  Branch (1989:23): [True: 5.57k, False: 593]
  ------------------
 1990|  5.57k|		state = ctxt->states[statenr];
 1991|  5.57k|		if ((state != NULL) && (state->reached ==
  ------------------
  |  Branch (1991:7): [True: 3.27k, False: 2.30k]
  |  Branch (1991:26): [True: 372, False: 2.90k]
  ------------------
 1992|  3.27k|			XML_REGEXP_MARK_START)) {
 1993|    372|		    target = state;
 1994|    372|		    break;
 1995|    372|		}
 1996|  5.57k|	    }
 1997|    965|	}
 1998|  1.97k|	state = target;
 1999|  1.97k|    }
 2000|  4.85k|    for (statenr = 0;statenr < ctxt->nbStates;statenr++) {
  ------------------
  |  Branch (2000:22): [True: 4.26k, False: 593]
  ------------------
 2001|  4.26k|	state = ctxt->states[statenr];
 2002|  4.26k|	if ((state != NULL) && (state->reached == XML_REGEXP_MARK_NORMAL)) {
  ------------------
  |  Branch (2002:6): [True: 2.43k, False: 1.82k]
  |  Branch (2002:25): [True: 464, False: 1.97k]
  ------------------
 2003|    464|	    xmlRegFreeState(state);
 2004|    464|	    ctxt->states[statenr] = NULL;
 2005|    464|	}
 2006|  4.26k|    }
 2007|       |
 2008|    593|}
xmlregexp.c:xmlFAEliminateSimpleEpsilonTransitions:
 1824|    593|xmlFAEliminateSimpleEpsilonTransitions(xmlRegParserCtxtPtr ctxt) {
 1825|    593|    int statenr, i, j, newto;
 1826|    593|    xmlRegStatePtr state, tmp;
 1827|       |
 1828|  4.85k|    for (statenr = 0;statenr < ctxt->nbStates;statenr++) {
  ------------------
  |  Branch (1828:22): [True: 4.26k, False: 593]
  ------------------
 1829|  4.26k|	state = ctxt->states[statenr];
 1830|  4.26k|	if (state == NULL)
  ------------------
  |  Branch (1830:6): [True: 0, False: 4.26k]
  ------------------
 1831|      0|	    continue;
 1832|  4.26k|	if (state->nbTrans != 1)
  ------------------
  |  Branch (1832:6): [True: 1.44k, False: 2.81k]
  ------------------
 1833|  1.44k|	    continue;
 1834|  2.81k|       if (state->type == XML_REGEXP_UNREACH_STATE ||
  ------------------
  |  Branch (1834:12): [True: 0, False: 2.81k]
  ------------------
 1835|  2.81k|           state->type == XML_REGEXP_FINAL_STATE)
  ------------------
  |  Branch (1835:12): [True: 177, False: 2.64k]
  ------------------
 1836|    177|	    continue;
 1837|       |	/* is the only transition out a basic transition */
 1838|  2.64k|	if ((state->trans[0].atom == NULL) &&
  ------------------
  |  Branch (1838:6): [True: 2.03k, False: 604]
  ------------------
 1839|  2.64k|	    (state->trans[0].to >= 0) &&
  ------------------
  |  Branch (1839:6): [True: 2.03k, False: 0]
  ------------------
 1840|  2.64k|	    (state->trans[0].to != statenr) &&
  ------------------
  |  Branch (1840:6): [True: 2.03k, False: 0]
  ------------------
 1841|  2.64k|	    (state->trans[0].counter < 0) &&
  ------------------
  |  Branch (1841:6): [True: 2.03k, False: 0]
  ------------------
 1842|  2.64k|	    (state->trans[0].count < 0)) {
  ------------------
  |  Branch (1842:6): [True: 2.03k, False: 0]
  ------------------
 1843|  2.03k|	    newto = state->trans[0].to;
 1844|       |
 1845|  2.03k|            if (state->type == XML_REGEXP_START_STATE) {
  ------------------
  |  Branch (1845:17): [True: 213, False: 1.82k]
  ------------------
 1846|  1.82k|            } else {
 1847|  3.94k|	        for (i = 0;i < state->nbTransTo;i++) {
  ------------------
  |  Branch (1847:21): [True: 2.12k, False: 1.82k]
  ------------------
 1848|  2.12k|		    tmp = ctxt->states[state->transTo[i]];
 1849|  32.8k|		    for (j = 0;j < tmp->nbTrans;j++) {
  ------------------
  |  Branch (1849:18): [True: 30.7k, False: 2.12k]
  ------------------
 1850|  30.7k|			if (tmp->trans[j].to == statenr) {
  ------------------
  |  Branch (1850:8): [True: 2.10k, False: 28.6k]
  ------------------
 1851|  2.10k|			    tmp->trans[j].to = -1;
 1852|  2.10k|			    xmlRegStateAddTrans(ctxt, tmp, tmp->trans[j].atom,
 1853|  2.10k|						ctxt->states[newto],
 1854|  2.10k|					        tmp->trans[j].counter,
 1855|  2.10k|						tmp->trans[j].count);
 1856|  2.10k|			}
 1857|  30.7k|		    }
 1858|  2.12k|		}
 1859|  1.82k|		if (state->type == XML_REGEXP_FINAL_STATE)
  ------------------
  |  Branch (1859:7): [True: 0, False: 1.82k]
  ------------------
 1860|      0|		    ctxt->states[newto]->type = XML_REGEXP_FINAL_STATE;
 1861|       |		/* eliminate the transition completely */
 1862|  1.82k|		state->nbTrans = 0;
 1863|       |
 1864|  1.82k|                state->type = XML_REGEXP_UNREACH_STATE;
 1865|       |
 1866|  1.82k|	    }
 1867|       |
 1868|  2.03k|	}
 1869|  2.64k|    }
 1870|    593|}
xmlregexp.c:xmlFAReduceEpsilonTransitions:
 1722|  1.47k|	                      int tonr, int counter) {
 1723|  1.47k|    int transnr;
 1724|  1.47k|    xmlRegStatePtr from;
 1725|  1.47k|    xmlRegStatePtr to;
 1726|       |
 1727|  1.47k|    from = ctxt->states[fromnr];
 1728|  1.47k|    if (from == NULL)
  ------------------
  |  Branch (1728:9): [True: 0, False: 1.47k]
  ------------------
 1729|      0|	return;
 1730|  1.47k|    to = ctxt->states[tonr];
 1731|  1.47k|    if (to == NULL)
  ------------------
  |  Branch (1731:9): [True: 0, False: 1.47k]
  ------------------
 1732|      0|	return;
 1733|  1.47k|    if ((to->mark == XML_REGEXP_MARK_START) ||
  ------------------
  |  Branch (1733:9): [True: 0, False: 1.47k]
  ------------------
 1734|  1.47k|	(to->mark == XML_REGEXP_MARK_VISITED))
  ------------------
  |  Branch (1734:2): [True: 12, False: 1.46k]
  ------------------
 1735|     12|	return;
 1736|       |
 1737|  1.46k|    to->mark = XML_REGEXP_MARK_VISITED;
 1738|  1.46k|    if (to->type == XML_REGEXP_FINAL_STATE) {
  ------------------
  |  Branch (1738:9): [True: 969, False: 492]
  ------------------
 1739|    969|	from->type = XML_REGEXP_FINAL_STATE;
 1740|    969|    }
 1741|  8.51k|    for (transnr = 0;transnr < to->nbTrans;transnr++) {
  ------------------
  |  Branch (1741:22): [True: 7.05k, False: 1.46k]
  ------------------
 1742|  7.05k|        xmlRegTransPtr t1 = &to->trans[transnr];
 1743|  7.05k|        int tcounter;
 1744|       |
 1745|  7.05k|        if (t1->to < 0)
  ------------------
  |  Branch (1745:13): [True: 3.21k, False: 3.83k]
  ------------------
 1746|  3.21k|	    continue;
 1747|  3.83k|        if (t1->counter >= 0) {
  ------------------
  |  Branch (1747:13): [True: 0, False: 3.83k]
  ------------------
 1748|       |            /* assert(counter < 0); */
 1749|      0|            tcounter = t1->counter;
 1750|  3.83k|        } else {
 1751|  3.83k|            tcounter = counter;
 1752|  3.83k|        }
 1753|  3.83k|	if (t1->atom == NULL) {
  ------------------
  |  Branch (1753:6): [True: 152, False: 3.68k]
  ------------------
 1754|       |	    /*
 1755|       |	     * Don't remove counted transitions
 1756|       |	     * Don't loop either
 1757|       |	     */
 1758|    152|	    if (t1->to != fromnr) {
  ------------------
  |  Branch (1758:10): [True: 152, False: 0]
  ------------------
 1759|    152|		if (t1->count >= 0) {
  ------------------
  |  Branch (1759:7): [True: 0, False: 152]
  ------------------
 1760|      0|		    xmlRegStateAddTrans(ctxt, from, NULL, ctxt->states[t1->to],
 1761|      0|					-1, t1->count);
 1762|    152|		} else {
 1763|    152|                    xmlFAReduceEpsilonTransitions(ctxt, fromnr, t1->to,
 1764|    152|                                                  tcounter);
 1765|    152|		}
 1766|    152|	    }
 1767|  3.68k|	} else {
 1768|  3.68k|            xmlRegStateAddTrans(ctxt, from, t1->atom,
 1769|  3.68k|                                ctxt->states[t1->to], tcounter, -1);
 1770|  3.68k|	}
 1771|  3.83k|    }
 1772|  1.46k|}
xmlregexp.c:xmlFAFinishReduceEpsilonTransitions:
 1783|  1.47k|xmlFAFinishReduceEpsilonTransitions(xmlRegParserCtxtPtr ctxt, int tonr) {
 1784|  1.47k|    int transnr;
 1785|  1.47k|    xmlRegStatePtr to;
 1786|       |
 1787|  1.47k|    to = ctxt->states[tonr];
 1788|  1.47k|    if (to == NULL)
  ------------------
  |  Branch (1788:9): [True: 0, False: 1.47k]
  ------------------
 1789|      0|	return;
 1790|  1.47k|    if ((to->mark == XML_REGEXP_MARK_START) ||
  ------------------
  |  Branch (1790:9): [True: 0, False: 1.47k]
  ------------------
 1791|  1.47k|	(to->mark == XML_REGEXP_MARK_NORMAL))
  ------------------
  |  Branch (1791:2): [True: 12, False: 1.46k]
  ------------------
 1792|     12|	return;
 1793|       |
 1794|  1.46k|    to->mark = XML_REGEXP_MARK_NORMAL;
 1795|  8.51k|    for (transnr = 0;transnr < to->nbTrans;transnr++) {
  ------------------
  |  Branch (1795:22): [True: 7.05k, False: 1.46k]
  ------------------
 1796|  7.05k|	xmlRegTransPtr t1 = &to->trans[transnr];
 1797|  7.05k|	if ((t1->to >= 0) && (t1->atom == NULL))
  ------------------
  |  Branch (1797:6): [True: 3.83k, False: 3.21k]
  |  Branch (1797:23): [True: 152, False: 3.68k]
  ------------------
 1798|    152|            xmlFAFinishReduceEpsilonTransitions(ctxt, t1->to);
 1799|  7.05k|    }
 1800|  1.46k|}
xmlregexp.c:xmlRegEpxFromParse:
  460|    593|xmlRegEpxFromParse(xmlRegParserCtxtPtr ctxt) {
  461|    593|    xmlRegexpPtr ret;
  462|       |
  463|    593|    ret = (xmlRegexpPtr) xmlMalloc(sizeof(xmlRegexp));
  464|    593|    if (ret == NULL) {
  ------------------
  |  Branch (464:9): [True: 0, False: 593]
  ------------------
  465|      0|	xmlRegexpErrMemory(ctxt, "compiling regexp");
  466|      0|	return(NULL);
  467|      0|    }
  468|    593|    memset(ret, 0, sizeof(xmlRegexp));
  469|    593|    ret->string = ctxt->string;
  470|    593|    ret->nbStates = ctxt->nbStates;
  471|    593|    ret->states = ctxt->states;
  472|    593|    ret->nbAtoms = ctxt->nbAtoms;
  473|    593|    ret->atoms = ctxt->atoms;
  474|    593|    ret->nbCounters = ctxt->nbCounters;
  475|    593|    ret->counters = ctxt->counters;
  476|    593|    ret->determinist = ctxt->determinist;
  477|    593|    ret->flags = ctxt->flags;
  478|    593|    if (ret->determinist == -1) {
  ------------------
  |  Branch (478:9): [True: 593, False: 0]
  ------------------
  479|    593|        if (xmlRegexpIsDeterminist(ret) < 0) {
  ------------------
  |  Branch (479:13): [True: 0, False: 593]
  ------------------
  480|      0|            xmlRegexpErrMemory(ctxt, "checking determinism");
  481|      0|            xmlFree(ret);
  482|      0|            return(NULL);
  483|      0|        }
  484|    593|    }
  485|       |
  486|    593|    if ((ret->determinist != 0) &&
  ------------------
  |  Branch (486:9): [True: 589, False: 4]
  ------------------
  487|    593|	(ret->nbCounters == 0) &&
  ------------------
  |  Branch (487:2): [True: 589, False: 0]
  ------------------
  488|    593|	(ctxt->negs == 0) &&
  ------------------
  |  Branch (488:2): [True: 589, False: 0]
  ------------------
  489|    593|	(ret->atoms != NULL) &&
  ------------------
  |  Branch (489:2): [True: 589, False: 0]
  ------------------
  490|    593|	(ret->atoms[0] != NULL) &&
  ------------------
  |  Branch (490:2): [True: 589, False: 0]
  ------------------
  491|    593|	(ret->atoms[0]->type == XML_REGEXP_STRING)) {
  ------------------
  |  Branch (491:2): [True: 589, False: 0]
  ------------------
  492|    589|	int i, j, nbstates = 0, nbatoms = 0;
  493|    589|	int *stateRemap;
  494|    589|	int *stringRemap;
  495|    589|	int *transitions;
  496|    589|	void **transdata;
  497|    589|	xmlChar **stringMap;
  498|    589|        xmlChar *value;
  499|       |
  500|       |	/*
  501|       |	 * Switch to a compact representation
  502|       |	 * 1/ counting the effective number of states left
  503|       |	 * 2/ counting the unique number of atoms, and check that
  504|       |	 *    they are all of the string type
  505|       |	 * 3/ build a table state x atom for the transitions
  506|       |	 */
  507|       |
  508|    589|	stateRemap = xmlMalloc(ret->nbStates * sizeof(int));
  509|    589|	if (stateRemap == NULL) {
  ------------------
  |  Branch (509:6): [True: 0, False: 589]
  ------------------
  510|      0|	    xmlRegexpErrMemory(ctxt, "compiling regexp");
  511|      0|	    xmlFree(ret);
  512|      0|	    return(NULL);
  513|      0|	}
  514|  4.81k|	for (i = 0;i < ret->nbStates;i++) {
  ------------------
  |  Branch (514:13): [True: 4.22k, False: 589]
  ------------------
  515|  4.22k|	    if (ret->states[i] != NULL) {
  ------------------
  |  Branch (515:10): [True: 1.95k, False: 2.27k]
  ------------------
  516|  1.95k|		stateRemap[i] = nbstates;
  517|  1.95k|		nbstates++;
  518|  2.27k|	    } else {
  519|  2.27k|		stateRemap[i] = -1;
  520|  2.27k|	    }
  521|  4.22k|	}
  522|    589|	stringMap = xmlMalloc(ret->nbAtoms * sizeof(char *));
  523|    589|	if (stringMap == NULL) {
  ------------------
  |  Branch (523:6): [True: 0, False: 589]
  ------------------
  524|      0|	    xmlRegexpErrMemory(ctxt, "compiling regexp");
  525|      0|	    xmlFree(stateRemap);
  526|      0|	    xmlFree(ret);
  527|      0|	    return(NULL);
  528|      0|	}
  529|    589|	stringRemap = xmlMalloc(ret->nbAtoms * sizeof(int));
  530|    589|	if (stringRemap == NULL) {
  ------------------
  |  Branch (530:6): [True: 0, False: 589]
  ------------------
  531|      0|	    xmlRegexpErrMemory(ctxt, "compiling regexp");
  532|      0|	    xmlFree(stringMap);
  533|      0|	    xmlFree(stateRemap);
  534|      0|	    xmlFree(ret);
  535|      0|	    return(NULL);
  536|      0|	}
  537|  3.47k|	for (i = 0;i < ret->nbAtoms;i++) {
  ------------------
  |  Branch (537:13): [True: 2.88k, False: 589]
  ------------------
  538|  2.88k|	    if ((ret->atoms[i]->type == XML_REGEXP_STRING) &&
  ------------------
  |  Branch (538:10): [True: 2.88k, False: 0]
  ------------------
  539|  2.88k|		(ret->atoms[i]->quant == XML_REGEXP_QUANT_ONCE)) {
  ------------------
  |  Branch (539:3): [True: 2.88k, False: 0]
  ------------------
  540|  2.88k|		value = ret->atoms[i]->valuep;
  541|  15.3k|                for (j = 0;j < nbatoms;j++) {
  ------------------
  |  Branch (541:28): [True: 12.7k, False: 2.63k]
  ------------------
  542|  12.7k|		    if (xmlStrEqual(stringMap[j], value)) {
  ------------------
  |  Branch (542:11): [True: 252, False: 12.4k]
  ------------------
  543|    252|			stringRemap[i] = j;
  544|    252|			break;
  545|    252|		    }
  546|  12.7k|		}
  547|  2.88k|		if (j >= nbatoms) {
  ------------------
  |  Branch (547:7): [True: 2.63k, False: 252]
  ------------------
  548|  2.63k|		    stringRemap[i] = nbatoms;
  549|  2.63k|		    stringMap[nbatoms] = xmlStrdup(value);
  550|  2.63k|		    if (stringMap[nbatoms] == NULL) {
  ------------------
  |  Branch (550:11): [True: 0, False: 2.63k]
  ------------------
  551|      0|			for (i = 0;i < nbatoms;i++)
  ------------------
  |  Branch (551:15): [True: 0, False: 0]
  ------------------
  552|      0|			    xmlFree(stringMap[i]);
  553|      0|			xmlFree(stringRemap);
  554|      0|			xmlFree(stringMap);
  555|      0|			xmlFree(stateRemap);
  556|      0|			xmlFree(ret);
  557|      0|			return(NULL);
  558|      0|		    }
  559|  2.63k|		    nbatoms++;
  560|  2.63k|		}
  561|  2.88k|	    } else {
  562|      0|		xmlFree(stateRemap);
  563|      0|		xmlFree(stringRemap);
  564|      0|		for (i = 0;i < nbatoms;i++)
  ------------------
  |  Branch (564:14): [True: 0, False: 0]
  ------------------
  565|      0|		    xmlFree(stringMap[i]);
  566|      0|		xmlFree(stringMap);
  567|      0|		xmlFree(ret);
  568|      0|		return(NULL);
  569|      0|	    }
  570|  2.88k|	}
  571|    589|	transitions = (int *) xmlRegCalloc2(nbstates + 1, nbatoms + 1,
  572|    589|                                            sizeof(int));
  573|    589|	if (transitions == NULL) {
  ------------------
  |  Branch (573:6): [True: 0, False: 589]
  ------------------
  574|      0|	    xmlFree(stateRemap);
  575|      0|	    xmlFree(stringRemap);
  576|      0|            for (i = 0;i < nbatoms;i++)
  ------------------
  |  Branch (576:24): [True: 0, False: 0]
  ------------------
  577|      0|		xmlFree(stringMap[i]);
  578|      0|	    xmlFree(stringMap);
  579|      0|	    xmlFree(ret);
  580|      0|	    return(NULL);
  581|      0|	}
  582|       |
  583|       |	/*
  584|       |	 * Allocate the transition table. The first entry for each
  585|       |	 * state corresponds to the state type.
  586|       |	 */
  587|    589|	transdata = NULL;
  588|       |
  589|  4.81k|	for (i = 0;i < ret->nbStates;i++) {
  ------------------
  |  Branch (589:13): [True: 4.22k, False: 589]
  ------------------
  590|  4.22k|	    int stateno, atomno, targetno, prev;
  591|  4.22k|	    xmlRegStatePtr state;
  592|  4.22k|	    xmlRegTransPtr trans;
  593|       |
  594|  4.22k|	    stateno = stateRemap[i];
  595|  4.22k|	    if (stateno == -1)
  ------------------
  |  Branch (595:10): [True: 2.27k, False: 1.95k]
  ------------------
  596|  2.27k|		continue;
  597|  1.95k|	    state = ret->states[i];
  598|       |
  599|  1.95k|	    transitions[stateno * (nbatoms + 1)] = state->type;
  600|       |
  601|  9.83k|	    for (j = 0;j < state->nbTrans;j++) {
  ------------------
  |  Branch (601:17): [True: 7.87k, False: 1.95k]
  ------------------
  602|  7.87k|		trans = &(state->trans[j]);
  603|  7.87k|		if ((trans->to < 0) || (trans->atom == NULL))
  ------------------
  |  Branch (603:7): [True: 2.36k, False: 5.51k]
  |  Branch (603:26): [True: 0, False: 5.51k]
  ------------------
  604|  2.36k|		    continue;
  605|  5.51k|                atomno = stringRemap[trans->atom->no];
  606|  5.51k|		if ((trans->atom->data != NULL) && (transdata == NULL)) {
  ------------------
  |  Branch (606:7): [True: 0, False: 5.51k]
  |  Branch (606:38): [True: 0, False: 0]
  ------------------
  607|      0|		    transdata = (void **) xmlRegCalloc2(nbstates, nbatoms,
  608|      0|			                                sizeof(void *));
  609|      0|		    if (transdata == NULL) {
  ------------------
  |  Branch (609:11): [True: 0, False: 0]
  ------------------
  610|      0|			xmlRegexpErrMemory(ctxt, "compiling regexp");
  611|      0|			break;
  612|      0|		    }
  613|      0|		}
  614|  5.51k|		targetno = stateRemap[trans->to];
  615|       |		/*
  616|       |		 * if the same atom can generate transitions to 2 different
  617|       |		 * states then it means the automata is not deterministic and
  618|       |		 * the compact form can't be used !
  619|       |		 */
  620|  5.51k|		prev = transitions[stateno * (nbatoms + 1) + atomno + 1];
  621|  5.51k|		if (prev != 0) {
  ------------------
  |  Branch (621:7): [True: 0, False: 5.51k]
  ------------------
  622|      0|		    if (prev != targetno + 1) {
  ------------------
  |  Branch (622:11): [True: 0, False: 0]
  ------------------
  623|      0|			ret->determinist = 0;
  624|      0|			if (transdata != NULL)
  ------------------
  |  Branch (624:8): [True: 0, False: 0]
  ------------------
  625|      0|			    xmlFree(transdata);
  626|      0|			xmlFree(transitions);
  627|      0|			xmlFree(stateRemap);
  628|      0|			xmlFree(stringRemap);
  629|      0|			for (i = 0;i < nbatoms;i++)
  ------------------
  |  Branch (629:15): [True: 0, False: 0]
  ------------------
  630|      0|			    xmlFree(stringMap[i]);
  631|      0|			xmlFree(stringMap);
  632|      0|			goto not_determ;
  633|      0|		    }
  634|  5.51k|		} else {
  635|       |#if 0
  636|       |		    printf("State %d trans %d: atom %d to %d : %d to %d\n",
  637|       |			   i, j, trans->atom->no, trans->to, atomno, targetno);
  638|       |#endif
  639|  5.51k|		    transitions[stateno * (nbatoms + 1) + atomno + 1] =
  640|  5.51k|			targetno + 1; /* to avoid 0 */
  641|  5.51k|		    if (transdata != NULL)
  ------------------
  |  Branch (641:11): [True: 0, False: 5.51k]
  ------------------
  642|      0|			transdata[stateno * nbatoms + atomno] =
  643|      0|			    trans->atom->data;
  644|  5.51k|		}
  645|  5.51k|	    }
  646|  1.95k|	}
  647|    589|	ret->determinist = 1;
  648|       |	/*
  649|       |	 * Cleanup of the old data
  650|       |	 */
  651|    589|	if (ret->states != NULL) {
  ------------------
  |  Branch (651:6): [True: 589, False: 0]
  ------------------
  652|  4.81k|	    for (i = 0;i < ret->nbStates;i++)
  ------------------
  |  Branch (652:17): [True: 4.22k, False: 589]
  ------------------
  653|  4.22k|		xmlRegFreeState(ret->states[i]);
  654|    589|	    xmlFree(ret->states);
  655|    589|	}
  656|    589|	ret->states = NULL;
  657|    589|	ret->nbStates = 0;
  658|    589|	if (ret->atoms != NULL) {
  ------------------
  |  Branch (658:6): [True: 589, False: 0]
  ------------------
  659|  3.47k|	    for (i = 0;i < ret->nbAtoms;i++)
  ------------------
  |  Branch (659:17): [True: 2.88k, False: 589]
  ------------------
  660|  2.88k|		xmlRegFreeAtom(ret->atoms[i]);
  661|    589|	    xmlFree(ret->atoms);
  662|    589|	}
  663|    589|	ret->atoms = NULL;
  664|    589|	ret->nbAtoms = 0;
  665|       |
  666|    589|	ret->compact = transitions;
  667|    589|	ret->transdata = transdata;
  668|    589|	ret->stringMap = stringMap;
  669|    589|	ret->nbstrings = nbatoms;
  670|    589|	ret->nbstates = nbstates;
  671|    589|	xmlFree(stateRemap);
  672|    589|	xmlFree(stringRemap);
  673|    589|    }
  674|    593|not_determ:
  675|    593|    ctxt->string = NULL;
  676|    593|    ctxt->nbStates = 0;
  677|    593|    ctxt->states = NULL;
  678|    593|    ctxt->nbAtoms = 0;
  679|    593|    ctxt->atoms = NULL;
  680|    593|    ctxt->nbCounters = 0;
  681|    593|    ctxt->counters = NULL;
  682|    593|    return(ret);
  683|    593|}
xmlregexp.c:xmlRegCalloc2:
  436|    589|xmlRegCalloc2(size_t dim1, size_t dim2, size_t elemSize) {
  437|    589|    size_t totalSize;
  438|    589|    void *ret;
  439|       |
  440|       |    /* Check for overflow */
  441|    589|    if ((dim2 == 0) || (elemSize == 0) ||
  ------------------
  |  Branch (441:9): [True: 0, False: 589]
  |  Branch (441:24): [True: 0, False: 589]
  ------------------
  442|    589|        (dim1 > SIZE_MAX / dim2 / elemSize))
  ------------------
  |  |   36|    589|#define SIZE_MAX ((size_t) -1)
  ------------------
  |  Branch (442:9): [True: 0, False: 589]
  ------------------
  443|      0|        return (NULL);
  444|    589|    totalSize = dim1 * dim2 * elemSize;
  445|    589|    ret = xmlMalloc(totalSize);
  446|    589|    if (ret != NULL)
  ------------------
  |  Branch (446:9): [True: 589, False: 0]
  ------------------
  447|    589|        memset(ret, 0, totalSize);
  448|    589|    return (ret);
  449|    589|}
xmlregexp.c:xmlRegFreeParserCtxt:
  924|  1.18k|xmlRegFreeParserCtxt(xmlRegParserCtxtPtr ctxt) {
  925|  1.18k|    int i;
  926|  1.18k|    if (ctxt == NULL)
  ------------------
  |  Branch (926:9): [True: 0, False: 1.18k]
  ------------------
  927|      0|	return;
  928|       |
  929|  1.18k|    if (ctxt->string != NULL)
  ------------------
  |  Branch (929:9): [True: 0, False: 1.18k]
  ------------------
  930|      0|	xmlFree(ctxt->string);
  931|  1.18k|    if (ctxt->states != NULL) {
  ------------------
  |  Branch (931:9): [True: 0, False: 1.18k]
  ------------------
  932|      0|	for (i = 0;i < ctxt->nbStates;i++)
  ------------------
  |  Branch (932:13): [True: 0, False: 0]
  ------------------
  933|      0|	    xmlRegFreeState(ctxt->states[i]);
  934|      0|	xmlFree(ctxt->states);
  935|      0|    }
  936|  1.18k|    if (ctxt->atoms != NULL) {
  ------------------
  |  Branch (936:9): [True: 0, False: 1.18k]
  ------------------
  937|      0|	for (i = 0;i < ctxt->nbAtoms;i++)
  ------------------
  |  Branch (937:13): [True: 0, False: 0]
  ------------------
  938|      0|	    xmlRegFreeAtom(ctxt->atoms[i]);
  939|      0|	xmlFree(ctxt->atoms);
  940|      0|    }
  941|  1.18k|    if (ctxt->counters != NULL)
  ------------------
  |  Branch (941:9): [True: 0, False: 1.18k]
  ------------------
  942|      0|	xmlFree(ctxt->counters);
  943|  1.18k|    xmlFree(ctxt);
  944|  1.18k|}
xmlregexp.c:xmlRegFreeState:
  906|  7.14k|xmlRegFreeState(xmlRegStatePtr state) {
  907|  7.14k|    if (state == NULL)
  ------------------
  |  Branch (907:9): [True: 2.28k, False: 4.85k]
  ------------------
  908|  2.28k|	return;
  909|       |
  910|  4.85k|    if (state->trans != NULL)
  ------------------
  |  Branch (910:9): [True: 3.84k, False: 1.00k]
  ------------------
  911|  3.84k|	xmlFree(state->trans);
  912|  4.85k|    if (state->transTo != NULL)
  ------------------
  |  Branch (912:9): [True: 3.66k, False: 1.18k]
  ------------------
  913|  3.66k|	xmlFree(state->transTo);
  914|  4.85k|    xmlFree(state);
  915|  4.85k|}
xmlregexp.c:xmlFAComputesDeterminism:
 2610|    593|xmlFAComputesDeterminism(xmlRegParserCtxtPtr ctxt) {
 2611|    593|    int statenr, transnr;
 2612|    593|    xmlRegStatePtr state;
 2613|    593|    xmlRegTransPtr t1, t2, last;
 2614|    593|    int i;
 2615|    593|    int ret = 1;
 2616|    593|    int deep = 1;
 2617|       |
 2618|    593|    if (ctxt->determinist != -1)
  ------------------
  |  Branch (2618:9): [True: 0, False: 593]
  ------------------
 2619|      0|	return(ctxt->determinist);
 2620|       |
 2621|    593|    if (ctxt->flags & AM_AUTOMATA_RNG)
  ------------------
  |  |  243|    593|#define AM_AUTOMATA_RNG 1
  ------------------
  |  Branch (2621:9): [True: 0, False: 593]
  ------------------
 2622|      0|        deep = 0;
 2623|       |
 2624|       |    /*
 2625|       |     * First cleanup the automata removing cancelled transitions
 2626|       |     */
 2627|  4.85k|    for (statenr = 0;statenr < ctxt->nbStates;statenr++) {
  ------------------
  |  Branch (2627:22): [True: 4.26k, False: 593]
  ------------------
 2628|  4.26k|	state = ctxt->states[statenr];
 2629|  4.26k|	if (state == NULL)
  ------------------
  |  Branch (2629:6): [True: 2.28k, False: 1.97k]
  ------------------
 2630|  2.28k|	    continue;
 2631|  1.97k|	if (state->nbTrans < 2)
  ------------------
  |  Branch (2631:6): [True: 773, False: 1.20k]
  ------------------
 2632|    773|	    continue;
 2633|  8.50k|	for (transnr = 0;transnr < state->nbTrans;transnr++) {
  ------------------
  |  Branch (2633:19): [True: 7.30k, False: 1.20k]
  ------------------
 2634|  7.30k|	    t1 = &(state->trans[transnr]);
 2635|       |	    /*
 2636|       |	     * Determinism checks in case of counted or all transitions
 2637|       |	     * will have to be handled separately
 2638|       |	     */
 2639|  7.30k|	    if (t1->atom == NULL) {
  ------------------
  |  Branch (2639:10): [True: 1.59k, False: 5.70k]
  ------------------
 2640|       |		/* t1->nd = 1; */
 2641|  1.59k|		continue;
 2642|  1.59k|	    }
 2643|  5.70k|	    if (t1->to < 0) /* eliminated */
  ------------------
  |  Branch (2643:10): [True: 788, False: 4.92k]
  ------------------
 2644|    788|		continue;
 2645|  41.8k|	    for (i = 0;i < transnr;i++) {
  ------------------
  |  Branch (2645:17): [True: 36.9k, False: 4.92k]
  ------------------
 2646|  36.9k|		t2 = &(state->trans[i]);
 2647|  36.9k|		if (t2->to < 0) /* eliminated */
  ------------------
  |  Branch (2647:7): [True: 15.5k, False: 21.3k]
  ------------------
 2648|  15.5k|		    continue;
 2649|  21.3k|		if (t2->atom != NULL) {
  ------------------
  |  Branch (2649:7): [True: 21.3k, False: 0]
  ------------------
 2650|  21.3k|		    if (t1->to == t2->to) {
  ------------------
  |  Branch (2650:11): [True: 16.7k, False: 4.51k]
  ------------------
 2651|       |                        /*
 2652|       |                         * Here we use deep because we want to keep the
 2653|       |                         * transitions which indicate a conflict
 2654|       |                         */
 2655|  16.7k|			if (xmlFAEqualAtoms(t1->atom, t2->atom, deep) &&
  ------------------
  |  Branch (2655:8): [True: 4, False: 16.7k]
  ------------------
 2656|  16.7k|                            (t1->counter == t2->counter) &&
  ------------------
  |  Branch (2656:29): [True: 4, False: 0]
  ------------------
 2657|  16.7k|                            (t1->count == t2->count))
  ------------------
  |  Branch (2657:29): [True: 4, False: 0]
  ------------------
 2658|      4|			    t2->to = -1; /* eliminated */
 2659|  16.7k|		    }
 2660|  21.3k|		}
 2661|  21.3k|	    }
 2662|  4.92k|	}
 2663|  1.20k|    }
 2664|       |
 2665|       |    /*
 2666|       |     * Check for all states that there aren't 2 transitions
 2667|       |     * with the same atom and a different target.
 2668|       |     */
 2669|  4.85k|    for (statenr = 0;statenr < ctxt->nbStates;statenr++) {
  ------------------
  |  Branch (2669:22): [True: 4.26k, False: 593]
  ------------------
 2670|  4.26k|	state = ctxt->states[statenr];
 2671|  4.26k|	if (state == NULL)
  ------------------
  |  Branch (2671:6): [True: 2.28k, False: 1.97k]
  ------------------
 2672|  2.28k|	    continue;
 2673|  1.97k|	if (state->nbTrans < 2)
  ------------------
  |  Branch (2673:6): [True: 773, False: 1.20k]
  ------------------
 2674|    773|	    continue;
 2675|  1.20k|	last = NULL;
 2676|  8.50k|	for (transnr = 0;transnr < state->nbTrans;transnr++) {
  ------------------
  |  Branch (2676:19): [True: 7.30k, False: 1.20k]
  ------------------
 2677|  7.30k|	    t1 = &(state->trans[transnr]);
 2678|       |	    /*
 2679|       |	     * Determinism checks in case of counted or all transitions
 2680|       |	     * will have to be handled separately
 2681|       |	     */
 2682|  7.30k|	    if (t1->atom == NULL) {
  ------------------
  |  Branch (2682:10): [True: 1.59k, False: 5.70k]
  ------------------
 2683|  1.59k|		continue;
 2684|  1.59k|	    }
 2685|  5.70k|	    if (t1->to < 0) /* eliminated */
  ------------------
  |  Branch (2685:10): [True: 792, False: 4.91k]
  ------------------
 2686|    792|		continue;
 2687|  41.8k|	    for (i = 0;i < transnr;i++) {
  ------------------
  |  Branch (2687:17): [True: 36.9k, False: 4.91k]
  ------------------
 2688|  36.9k|		t2 = &(state->trans[i]);
 2689|  36.9k|		if (t2->to < 0) /* eliminated */
  ------------------
  |  Branch (2689:7): [True: 15.5k, False: 21.3k]
  ------------------
 2690|  15.5k|		    continue;
 2691|  21.3k|		if (t2->atom != NULL) {
  ------------------
  |  Branch (2691:7): [True: 21.3k, False: 0]
  ------------------
 2692|       |                    /*
 2693|       |                     * But here we don't use deep because we want to
 2694|       |                     * find transitions which indicate a conflict
 2695|       |                     */
 2696|  21.3k|		    if (xmlFACompareAtoms(t1->atom, t2->atom, 1)) {
  ------------------
  |  Branch (2696:11): [True: 4, False: 21.3k]
  ------------------
 2697|       |                        /*
 2698|       |                         * Treat equal counter transitions that couldn't be
 2699|       |                         * eliminated as deterministic.
 2700|       |                         */
 2701|      4|                        if ((t1->to != t2->to) ||
  ------------------
  |  Branch (2701:29): [True: 4, False: 0]
  ------------------
 2702|      4|                            (t1->counter == t2->counter) ||
  ------------------
  |  Branch (2702:29): [True: 0, False: 0]
  ------------------
 2703|      4|                            (!xmlFAEqualAtoms(t1->atom, t2->atom, deep)))
  ------------------
  |  Branch (2703:29): [True: 0, False: 0]
  ------------------
 2704|      4|                            ret = 0;
 2705|       |			/* mark the transitions as non-deterministic ones */
 2706|      4|			t1->nd = 1;
 2707|      4|			t2->nd = 1;
 2708|      4|			last = t1;
 2709|      4|		    }
 2710|  21.3k|		} else {
 2711|      0|                    int res;
 2712|       |
 2713|       |		    /*
 2714|       |		     * do the closure in case of remaining specific
 2715|       |		     * epsilon transitions like choices or all
 2716|       |		     */
 2717|      0|		    res = xmlFARecurseDeterminism(ctxt, ctxt->states[t2->to],
 2718|      0|						  statenr, t1->to, t1->atom);
 2719|      0|                    xmlFAFinishRecurseDeterminism(ctxt, ctxt->states[t2->to]);
 2720|       |		    /* don't shortcut the computation so all non deterministic
 2721|       |		       transition get marked down
 2722|       |		    if (ret == 0)
 2723|       |			return(0);
 2724|       |		     */
 2725|      0|		    if (res == 0) {
  ------------------
  |  Branch (2725:11): [True: 0, False: 0]
  ------------------
 2726|      0|			t1->nd = 1;
 2727|       |			/* t2->nd = 1; */
 2728|      0|			last = t1;
 2729|      0|                        ret = 0;
 2730|      0|		    }
 2731|      0|		}
 2732|  21.3k|	    }
 2733|       |	    /* don't shortcut the computation so all non deterministic
 2734|       |	       transition get marked down
 2735|       |	    if (ret == 0)
 2736|       |		break; */
 2737|  4.91k|	}
 2738|       |
 2739|       |	/*
 2740|       |	 * mark specifically the last non-deterministic transition
 2741|       |	 * from a state since there is no need to set-up rollback
 2742|       |	 * from it
 2743|       |	 */
 2744|  1.20k|	if (last != NULL) {
  ------------------
  |  Branch (2744:6): [True: 4, False: 1.19k]
  ------------------
 2745|      4|	    last->nd = 2;
 2746|      4|	}
 2747|       |
 2748|       |	/* don't shortcut the computation so all non deterministic
 2749|       |	   transition get marked down
 2750|       |	if (ret == 0)
 2751|       |	    break; */
 2752|  1.20k|    }
 2753|       |
 2754|    593|    ctxt->determinist = ret;
 2755|    593|    return(ret);
 2756|    593|}
xmlregexp.c:xmlFAEqualAtoms:
 2386|  16.7k|xmlFAEqualAtoms(xmlRegAtomPtr atom1, xmlRegAtomPtr atom2, int deep) {
 2387|  16.7k|    int ret = 0;
 2388|       |
 2389|  16.7k|    if (atom1 == atom2)
  ------------------
  |  Branch (2389:9): [True: 0, False: 16.7k]
  ------------------
 2390|      0|	return(1);
 2391|  16.7k|    if ((atom1 == NULL) || (atom2 == NULL))
  ------------------
  |  Branch (2391:9): [True: 0, False: 16.7k]
  |  Branch (2391:28): [True: 0, False: 16.7k]
  ------------------
 2392|      0|	return(0);
 2393|       |
 2394|  16.7k|    if (atom1->type != atom2->type)
  ------------------
  |  Branch (2394:9): [True: 0, False: 16.7k]
  ------------------
 2395|      0|        return(0);
 2396|  16.7k|    switch (atom1->type) {
 2397|      0|        case XML_REGEXP_EPSILON:
  ------------------
  |  Branch (2397:9): [True: 0, False: 16.7k]
  ------------------
 2398|      0|	    ret = 0;
 2399|      0|	    break;
 2400|  16.7k|        case XML_REGEXP_STRING:
  ------------------
  |  Branch (2400:9): [True: 16.7k, False: 0]
  ------------------
 2401|  16.7k|            if (!deep)
  ------------------
  |  Branch (2401:17): [True: 0, False: 16.7k]
  ------------------
 2402|      0|                ret = (atom1->valuep == atom2->valuep);
 2403|  16.7k|            else
 2404|  16.7k|                ret = xmlStrEqual((xmlChar *)atom1->valuep,
 2405|  16.7k|                                  (xmlChar *)atom2->valuep);
 2406|  16.7k|	    break;
 2407|      0|        case XML_REGEXP_CHARVAL:
  ------------------
  |  Branch (2407:9): [True: 0, False: 16.7k]
  ------------------
 2408|      0|	    ret = (atom1->codepoint == atom2->codepoint);
 2409|      0|	    break;
 2410|      0|	case XML_REGEXP_RANGES:
  ------------------
  |  Branch (2410:2): [True: 0, False: 16.7k]
  ------------------
 2411|       |	    /* too hard to do in the general case */
 2412|      0|	    ret = 0;
 2413|      0|	default:
  ------------------
  |  Branch (2413:2): [True: 0, False: 16.7k]
  ------------------
 2414|      0|	    break;
 2415|  16.7k|    }
 2416|  16.7k|    return(ret);
 2417|  16.7k|}
xmlregexp.c:xmlFACompareAtoms:
 2431|  21.3k|xmlFACompareAtoms(xmlRegAtomPtr atom1, xmlRegAtomPtr atom2, int deep) {
 2432|  21.3k|    int ret = 1;
 2433|       |
 2434|  21.3k|    if (atom1 == atom2)
  ------------------
  |  Branch (2434:9): [True: 0, False: 21.3k]
  ------------------
 2435|      0|	return(1);
 2436|  21.3k|    if ((atom1 == NULL) || (atom2 == NULL))
  ------------------
  |  Branch (2436:9): [True: 0, False: 21.3k]
  |  Branch (2436:28): [True: 0, False: 21.3k]
  ------------------
 2437|      0|	return(0);
 2438|       |
 2439|  21.3k|    if ((atom1->type == XML_REGEXP_ANYCHAR) ||
  ------------------
  |  Branch (2439:9): [True: 0, False: 21.3k]
  ------------------
 2440|  21.3k|        (atom2->type == XML_REGEXP_ANYCHAR))
  ------------------
  |  Branch (2440:9): [True: 0, False: 21.3k]
  ------------------
 2441|      0|	return(1);
 2442|       |
 2443|  21.3k|    if (atom1->type > atom2->type) {
  ------------------
  |  Branch (2443:9): [True: 0, False: 21.3k]
  ------------------
 2444|      0|	xmlRegAtomPtr tmp;
 2445|      0|	tmp = atom1;
 2446|      0|	atom1 = atom2;
 2447|      0|	atom2 = tmp;
 2448|      0|    }
 2449|  21.3k|    if (atom1->type != atom2->type) {
  ------------------
  |  Branch (2449:9): [True: 0, False: 21.3k]
  ------------------
 2450|      0|        ret = xmlFACompareAtomTypes(atom1->type, atom2->type);
 2451|       |	/* if they can't intersect at the type level break now */
 2452|      0|	if (ret == 0)
  ------------------
  |  Branch (2452:6): [True: 0, False: 0]
  ------------------
 2453|      0|	    return(0);
 2454|      0|    }
 2455|  21.3k|    switch (atom1->type) {
 2456|  21.3k|        case XML_REGEXP_STRING:
  ------------------
  |  Branch (2456:9): [True: 21.3k, False: 0]
  ------------------
 2457|  21.3k|            if (!deep)
  ------------------
  |  Branch (2457:17): [True: 0, False: 21.3k]
  ------------------
 2458|      0|                ret = (atom1->valuep != atom2->valuep);
 2459|  21.3k|            else {
 2460|  21.3k|                xmlChar *val1 = (xmlChar *)atom1->valuep;
 2461|  21.3k|                xmlChar *val2 = (xmlChar *)atom2->valuep;
 2462|  21.3k|                int compound1 = (xmlStrchr(val1, '|') != NULL);
 2463|  21.3k|                int compound2 = (xmlStrchr(val2, '|') != NULL);
 2464|       |
 2465|       |                /* Ignore negative match flag for ##other namespaces */
 2466|  21.3k|                if (compound1 != compound2)
  ------------------
  |  Branch (2466:21): [True: 0, False: 21.3k]
  ------------------
 2467|      0|                    return(0);
 2468|       |
 2469|  21.3k|                ret = xmlRegStrEqualWildcard(val1, val2);
 2470|  21.3k|            }
 2471|  21.3k|	    break;
 2472|  21.3k|        case XML_REGEXP_EPSILON:
  ------------------
  |  Branch (2472:9): [True: 0, False: 21.3k]
  ------------------
 2473|      0|	    goto not_determinist;
 2474|      0|        case XML_REGEXP_CHARVAL:
  ------------------
  |  Branch (2474:9): [True: 0, False: 21.3k]
  ------------------
 2475|      0|	    if (atom2->type == XML_REGEXP_CHARVAL) {
  ------------------
  |  Branch (2475:10): [True: 0, False: 0]
  ------------------
 2476|      0|		ret = (atom1->codepoint == atom2->codepoint);
 2477|      0|	    } else {
 2478|      0|	        ret = xmlRegCheckCharacter(atom2, atom1->codepoint);
 2479|      0|		if (ret < 0)
  ------------------
  |  Branch (2479:7): [True: 0, False: 0]
  ------------------
 2480|      0|		    ret = 1;
 2481|      0|	    }
 2482|      0|	    break;
 2483|      0|        case XML_REGEXP_RANGES:
  ------------------
  |  Branch (2483:9): [True: 0, False: 21.3k]
  ------------------
 2484|      0|	    if (atom2->type == XML_REGEXP_RANGES) {
  ------------------
  |  Branch (2484:10): [True: 0, False: 0]
  ------------------
 2485|      0|	        int i, j, res;
 2486|      0|		xmlRegRangePtr r1, r2;
 2487|       |
 2488|       |		/*
 2489|       |		 * need to check that none of the ranges eventually matches
 2490|       |		 */
 2491|      0|		for (i = 0;i < atom1->nbRanges;i++) {
  ------------------
  |  Branch (2491:14): [True: 0, False: 0]
  ------------------
 2492|      0|		    for (j = 0;j < atom2->nbRanges;j++) {
  ------------------
  |  Branch (2492:18): [True: 0, False: 0]
  ------------------
 2493|      0|			r1 = atom1->ranges[i];
 2494|      0|			r2 = atom2->ranges[j];
 2495|      0|			res = xmlFACompareRanges(r1, r2);
 2496|      0|			if (res == 1) {
  ------------------
  |  Branch (2496:8): [True: 0, False: 0]
  ------------------
 2497|      0|			    ret = 1;
 2498|      0|			    goto done;
 2499|      0|			}
 2500|      0|		    }
 2501|      0|		}
 2502|      0|		ret = 0;
 2503|      0|	    }
 2504|      0|	    break;
 2505|      0|	default:
  ------------------
  |  Branch (2505:2): [True: 0, False: 21.3k]
  ------------------
 2506|      0|	    goto not_determinist;
 2507|  21.3k|    }
 2508|  21.3k|done:
 2509|  21.3k|    if (atom1->neg != atom2->neg) {
  ------------------
  |  Branch (2509:9): [True: 0, False: 21.3k]
  ------------------
 2510|      0|        ret = !ret;
 2511|      0|    }
 2512|  21.3k|    if (ret == 0)
  ------------------
  |  Branch (2512:9): [True: 21.3k, False: 4]
  ------------------
 2513|  21.3k|        return(0);
 2514|      4|not_determinist:
 2515|      4|    return(1);
 2516|  21.3k|}
xmlregexp.c:xmlRegFreeAtom:
  819|  2.90k|xmlRegFreeAtom(xmlRegAtomPtr atom) {
  820|  2.90k|    int i;
  821|       |
  822|  2.90k|    if (atom == NULL)
  ------------------
  |  Branch (822:9): [True: 0, False: 2.90k]
  ------------------
  823|      0|	return;
  824|       |
  825|  2.90k|    for (i = 0;i < atom->nbRanges;i++)
  ------------------
  |  Branch (825:16): [True: 0, False: 2.90k]
  ------------------
  826|      0|	xmlRegFreeRange(atom->ranges[i]);
  827|  2.90k|    if (atom->ranges != NULL)
  ------------------
  |  Branch (827:9): [True: 0, False: 2.90k]
  ------------------
  828|      0|	xmlFree(atom->ranges);
  829|  2.90k|    if ((atom->type == XML_REGEXP_STRING) && (atom->valuep != NULL))
  ------------------
  |  Branch (829:9): [True: 2.90k, False: 0]
  |  Branch (829:46): [True: 2.90k, False: 0]
  ------------------
  830|  2.90k|	xmlFree(atom->valuep);
  831|  2.90k|    if ((atom->type == XML_REGEXP_STRING) && (atom->valuep2 != NULL))
  ------------------
  |  Branch (831:9): [True: 2.90k, False: 0]
  |  Branch (831:46): [True: 0, False: 2.90k]
  ------------------
  832|      0|	xmlFree(atom->valuep2);
  833|  2.90k|    if ((atom->type == XML_REGEXP_BLOCK_NAME) && (atom->valuep != NULL))
  ------------------
  |  Branch (833:9): [True: 0, False: 2.90k]
  |  Branch (833:50): [True: 0, False: 0]
  ------------------
  834|      0|	xmlFree(atom->valuep);
  835|  2.90k|    xmlFree(atom);
  836|  2.90k|}
xmlregexp.c:xmlRegNewAtom:
  796|  2.90k|xmlRegNewAtom(xmlRegParserCtxtPtr ctxt, xmlRegAtomType type) {
  797|  2.90k|    xmlRegAtomPtr ret;
  798|       |
  799|  2.90k|    ret = (xmlRegAtomPtr) xmlMalloc(sizeof(xmlRegAtom));
  800|  2.90k|    if (ret == NULL) {
  ------------------
  |  Branch (800:9): [True: 0, False: 2.90k]
  ------------------
  801|      0|	xmlRegexpErrMemory(ctxt, "allocating atom");
  802|      0|	return(NULL);
  803|      0|    }
  804|  2.90k|    memset(ret, 0, sizeof(xmlRegAtom));
  805|  2.90k|    ret->type = type;
  806|  2.90k|    ret->quant = XML_REGEXP_QUANT_ONCE;
  807|  2.90k|    ret->min = 0;
  808|  2.90k|    ret->max = 0;
  809|  2.90k|    return(ret);
  810|  2.90k|}
xmlregexp.c:xmlFAGenerateTransitions:
 1493|  2.90k|	                 xmlRegStatePtr to, xmlRegAtomPtr atom) {
 1494|  2.90k|    xmlRegStatePtr end;
 1495|  2.90k|    int nullable = 0;
 1496|       |
 1497|  2.90k|    if (atom == NULL) {
  ------------------
  |  Branch (1497:9): [True: 0, False: 2.90k]
  ------------------
 1498|      0|	ERROR("generate transition: atom == NULL");
  ------------------
  |  |   55|      0|    ctxt->error = XML_REGEXP_COMPILE_ERROR;				\
  |  |   56|      0|    xmlRegexpErrCompile(ctxt, str);
  ------------------
 1499|      0|	return(-1);
 1500|      0|    }
 1501|  2.90k|    if (atom->type == XML_REGEXP_SUBREG) {
  ------------------
  |  Branch (1501:9): [True: 0, False: 2.90k]
  ------------------
 1502|       |	/*
 1503|       |	 * this is a subexpression handling one should not need to
 1504|       |	 * create a new node except for XML_REGEXP_QUANT_RANGE.
 1505|       |	 */
 1506|      0|	if ((to != NULL) && (atom->stop != to) &&
  ------------------
  |  Branch (1506:6): [True: 0, False: 0]
  |  Branch (1506:22): [True: 0, False: 0]
  ------------------
 1507|      0|	    (atom->quant != XML_REGEXP_QUANT_RANGE)) {
  ------------------
  |  Branch (1507:6): [True: 0, False: 0]
  ------------------
 1508|       |	    /*
 1509|       |	     * Generate an epsilon transition to link to the target
 1510|       |	     */
 1511|      0|	    xmlFAGenerateEpsilonTransition(ctxt, atom->stop, to);
 1512|       |#ifdef DV
 1513|       |	} else if ((to == NULL) && (atom->quant != XML_REGEXP_QUANT_RANGE) &&
 1514|       |		   (atom->quant != XML_REGEXP_QUANT_ONCE)) {
 1515|       |	    to = xmlRegStatePush(ctxt, to);
 1516|       |            if (to == NULL)
 1517|       |                return(-1);
 1518|       |	    ctxt->state = to;
 1519|       |	    xmlFAGenerateEpsilonTransition(ctxt, atom->stop, to);
 1520|       |#endif
 1521|      0|	}
 1522|      0|	switch (atom->quant) {
 1523|      0|	    case XML_REGEXP_QUANT_OPT:
  ------------------
  |  Branch (1523:6): [True: 0, False: 0]
  ------------------
 1524|      0|		atom->quant = XML_REGEXP_QUANT_ONCE;
 1525|       |		/*
 1526|       |		 * transition done to the state after end of atom.
 1527|       |		 *      1. set transition from atom start to new state
 1528|       |		 *      2. set transition from atom end to this state.
 1529|       |		 */
 1530|      0|                if (to == NULL) {
  ------------------
  |  Branch (1530:21): [True: 0, False: 0]
  ------------------
 1531|      0|                    xmlFAGenerateEpsilonTransition(ctxt, atom->start, 0);
 1532|      0|                    xmlFAGenerateEpsilonTransition(ctxt, atom->stop,
 1533|      0|                                                   ctxt->state);
 1534|      0|                } else {
 1535|      0|                    xmlFAGenerateEpsilonTransition(ctxt, atom->start, to);
 1536|      0|                }
 1537|      0|		break;
 1538|      0|	    case XML_REGEXP_QUANT_MULT:
  ------------------
  |  Branch (1538:6): [True: 0, False: 0]
  ------------------
 1539|      0|		atom->quant = XML_REGEXP_QUANT_ONCE;
 1540|      0|		xmlFAGenerateEpsilonTransition(ctxt, atom->start, atom->stop);
 1541|      0|		xmlFAGenerateEpsilonTransition(ctxt, atom->stop, atom->start);
 1542|      0|		break;
 1543|      0|	    case XML_REGEXP_QUANT_PLUS:
  ------------------
  |  Branch (1543:6): [True: 0, False: 0]
  ------------------
 1544|      0|		atom->quant = XML_REGEXP_QUANT_ONCE;
 1545|      0|		xmlFAGenerateEpsilonTransition(ctxt, atom->stop, atom->start);
 1546|      0|		break;
 1547|      0|	    case XML_REGEXP_QUANT_RANGE: {
  ------------------
  |  Branch (1547:6): [True: 0, False: 0]
  ------------------
 1548|      0|		int counter;
 1549|      0|		xmlRegStatePtr inter, newstate;
 1550|       |
 1551|       |		/*
 1552|       |		 * create the final state now if needed
 1553|       |		 */
 1554|      0|		if (to != NULL) {
  ------------------
  |  Branch (1554:7): [True: 0, False: 0]
  ------------------
 1555|      0|		    newstate = to;
 1556|      0|		} else {
 1557|      0|		    newstate = xmlRegStatePush(ctxt);
 1558|      0|                    if (newstate == NULL)
  ------------------
  |  Branch (1558:25): [True: 0, False: 0]
  ------------------
 1559|      0|                        return(-1);
 1560|      0|		}
 1561|       |
 1562|       |		/*
 1563|       |		 * The principle here is to use counted transition
 1564|       |		 * to avoid explosion in the number of states in the
 1565|       |		 * graph. This is clearly more complex but should not
 1566|       |		 * be exploitable at runtime.
 1567|       |		 */
 1568|      0|		if ((atom->min == 0) && (atom->start0 == NULL)) {
  ------------------
  |  Branch (1568:7): [True: 0, False: 0]
  |  Branch (1568:27): [True: 0, False: 0]
  ------------------
 1569|      0|		    xmlRegAtomPtr copy;
 1570|       |		    /*
 1571|       |		     * duplicate a transition based on atom to count next
 1572|       |		     * occurrences after 1. We cannot loop to atom->start
 1573|       |		     * directly because we need an epsilon transition to
 1574|       |		     * newstate.
 1575|       |		     */
 1576|       |		     /* ???? For some reason it seems we never reach that
 1577|       |		        case, I suppose this got optimized out before when
 1578|       |			building the automata */
 1579|      0|		    copy = xmlRegCopyAtom(ctxt, atom);
 1580|      0|		    if (copy == NULL)
  ------------------
  |  Branch (1580:11): [True: 0, False: 0]
  ------------------
 1581|      0|		        return(-1);
 1582|      0|		    copy->quant = XML_REGEXP_QUANT_ONCE;
 1583|      0|		    copy->min = 0;
 1584|      0|		    copy->max = 0;
 1585|       |
 1586|      0|		    if (xmlFAGenerateTransitions(ctxt, atom->start, NULL, copy)
  ------------------
  |  Branch (1586:11): [True: 0, False: 0]
  ------------------
 1587|      0|		        < 0) {
 1588|      0|                        xmlRegFreeAtom(copy);
 1589|      0|			return(-1);
 1590|      0|                    }
 1591|      0|		    inter = ctxt->state;
 1592|      0|		    counter = xmlRegGetCounter(ctxt);
 1593|      0|                    if (counter < 0)
  ------------------
  |  Branch (1593:25): [True: 0, False: 0]
  ------------------
 1594|      0|                        return(-1);
 1595|      0|		    ctxt->counters[counter].min = atom->min - 1;
 1596|      0|		    ctxt->counters[counter].max = atom->max - 1;
 1597|       |		    /* count the number of times we see it again */
 1598|      0|		    xmlFAGenerateCountedEpsilonTransition(ctxt, inter,
 1599|      0|						   atom->stop, counter);
 1600|       |		    /* allow a way out based on the count */
 1601|      0|		    xmlFAGenerateCountedTransition(ctxt, inter,
 1602|      0|			                           newstate, counter);
 1603|       |		    /* and also allow a direct exit for 0 */
 1604|      0|		    xmlFAGenerateEpsilonTransition(ctxt, atom->start,
 1605|      0|		                                   newstate);
 1606|      0|		} else {
 1607|       |		    /*
 1608|       |		     * either we need the atom at least once or there
 1609|       |		     * is an atom->start0 allowing to easily plug the
 1610|       |		     * epsilon transition.
 1611|       |		     */
 1612|      0|		    counter = xmlRegGetCounter(ctxt);
 1613|      0|                    if (counter < 0)
  ------------------
  |  Branch (1613:25): [True: 0, False: 0]
  ------------------
 1614|      0|                        return(-1);
 1615|      0|		    ctxt->counters[counter].min = atom->min - 1;
 1616|      0|		    ctxt->counters[counter].max = atom->max - 1;
 1617|       |		    /* allow a way out based on the count */
 1618|      0|		    xmlFAGenerateCountedTransition(ctxt, atom->stop,
 1619|      0|			                           newstate, counter);
 1620|       |		    /* count the number of times we see it again */
 1621|      0|		    xmlFAGenerateCountedEpsilonTransition(ctxt, atom->stop,
 1622|      0|						   atom->start, counter);
 1623|       |		    /* and if needed allow a direct exit for 0 */
 1624|      0|		    if (atom->min == 0)
  ------------------
  |  Branch (1624:11): [True: 0, False: 0]
  ------------------
 1625|      0|			xmlFAGenerateEpsilonTransition(ctxt, atom->start0,
 1626|      0|						       newstate);
 1627|       |
 1628|      0|		}
 1629|      0|		atom->min = 0;
 1630|      0|		atom->max = 0;
 1631|      0|		atom->quant = XML_REGEXP_QUANT_ONCE;
 1632|      0|		ctxt->state = newstate;
 1633|      0|	    }
 1634|      0|	    default:
  ------------------
  |  Branch (1634:6): [True: 0, False: 0]
  ------------------
 1635|      0|		break;
 1636|      0|	}
 1637|      0|	if (xmlRegAtomPush(ctxt, atom) < 0)
  ------------------
  |  Branch (1637:6): [True: 0, False: 0]
  ------------------
 1638|      0|	    return(-1);
 1639|      0|	return(0);
 1640|      0|    }
 1641|  2.90k|    if ((atom->min == 0) && (atom->max == 0) &&
  ------------------
  |  Branch (1641:9): [True: 2.90k, False: 0]
  |  Branch (1641:29): [True: 2.90k, False: 0]
  ------------------
 1642|  2.90k|               (atom->quant == XML_REGEXP_QUANT_RANGE)) {
  ------------------
  |  Branch (1642:16): [True: 0, False: 2.90k]
  ------------------
 1643|       |        /*
 1644|       |	 * we can discard the atom and generate an epsilon transition instead
 1645|       |	 */
 1646|      0|	if (to == NULL) {
  ------------------
  |  Branch (1646:6): [True: 0, False: 0]
  ------------------
 1647|      0|	    to = xmlRegStatePush(ctxt);
 1648|      0|	    if (to == NULL)
  ------------------
  |  Branch (1648:10): [True: 0, False: 0]
  ------------------
 1649|      0|		return(-1);
 1650|      0|	}
 1651|      0|	xmlFAGenerateEpsilonTransition(ctxt, from, to);
 1652|      0|	ctxt->state = to;
 1653|      0|	xmlRegFreeAtom(atom);
 1654|      0|	return(0);
 1655|      0|    }
 1656|  2.90k|    if (to == NULL) {
  ------------------
  |  Branch (1656:9): [True: 2.46k, False: 437]
  ------------------
 1657|  2.46k|	to = xmlRegStatePush(ctxt);
 1658|  2.46k|	if (to == NULL)
  ------------------
  |  Branch (1658:6): [True: 0, False: 2.46k]
  ------------------
 1659|      0|	    return(-1);
 1660|  2.46k|    }
 1661|  2.90k|    end = to;
 1662|  2.90k|    if ((atom->quant == XML_REGEXP_QUANT_MULT) ||
  ------------------
  |  Branch (1662:9): [True: 0, False: 2.90k]
  ------------------
 1663|  2.90k|        (atom->quant == XML_REGEXP_QUANT_PLUS)) {
  ------------------
  |  Branch (1663:9): [True: 0, False: 2.90k]
  ------------------
 1664|       |	/*
 1665|       |	 * Do not pollute the target state by adding transitions from
 1666|       |	 * it as it is likely to be the shared target of multiple branches.
 1667|       |	 * So isolate with an epsilon transition.
 1668|       |	 */
 1669|      0|        xmlRegStatePtr tmp;
 1670|       |
 1671|      0|	tmp = xmlRegStatePush(ctxt);
 1672|      0|        if (tmp == NULL)
  ------------------
  |  Branch (1672:13): [True: 0, False: 0]
  ------------------
 1673|      0|	    return(-1);
 1674|      0|	xmlFAGenerateEpsilonTransition(ctxt, tmp, to);
 1675|      0|	to = tmp;
 1676|      0|    }
 1677|  2.90k|    if ((atom->quant == XML_REGEXP_QUANT_RANGE) &&
  ------------------
  |  Branch (1677:9): [True: 0, False: 2.90k]
  ------------------
 1678|  2.90k|        (atom->min == 0) && (atom->max > 0)) {
  ------------------
  |  Branch (1678:9): [True: 0, False: 0]
  |  Branch (1678:29): [True: 0, False: 0]
  ------------------
 1679|      0|	nullable = 1;
 1680|      0|	atom->min = 1;
 1681|      0|        if (atom->max == 1)
  ------------------
  |  Branch (1681:13): [True: 0, False: 0]
  ------------------
 1682|      0|	    atom->quant = XML_REGEXP_QUANT_OPT;
 1683|      0|    }
 1684|  2.90k|    xmlRegStateAddTrans(ctxt, from, atom, to, -1, -1);
 1685|  2.90k|    ctxt->state = end;
 1686|  2.90k|    switch (atom->quant) {
 1687|      0|	case XML_REGEXP_QUANT_OPT:
  ------------------
  |  Branch (1687:2): [True: 0, False: 2.90k]
  ------------------
 1688|      0|	    atom->quant = XML_REGEXP_QUANT_ONCE;
 1689|      0|	    xmlFAGenerateEpsilonTransition(ctxt, from, to);
 1690|      0|	    break;
 1691|      0|	case XML_REGEXP_QUANT_MULT:
  ------------------
  |  Branch (1691:2): [True: 0, False: 2.90k]
  ------------------
 1692|      0|	    atom->quant = XML_REGEXP_QUANT_ONCE;
 1693|      0|	    xmlFAGenerateEpsilonTransition(ctxt, from, to);
 1694|      0|	    xmlRegStateAddTrans(ctxt, to, atom, to, -1, -1);
 1695|      0|	    break;
 1696|      0|	case XML_REGEXP_QUANT_PLUS:
  ------------------
  |  Branch (1696:2): [True: 0, False: 2.90k]
  ------------------
 1697|      0|	    atom->quant = XML_REGEXP_QUANT_ONCE;
 1698|      0|	    xmlRegStateAddTrans(ctxt, to, atom, to, -1, -1);
 1699|      0|	    break;
 1700|      0|	case XML_REGEXP_QUANT_RANGE:
  ------------------
  |  Branch (1700:2): [True: 0, False: 2.90k]
  ------------------
 1701|      0|	    if (nullable)
  ------------------
  |  Branch (1701:10): [True: 0, False: 0]
  ------------------
 1702|      0|		xmlFAGenerateEpsilonTransition(ctxt, from, to);
 1703|      0|	    break;
 1704|  2.90k|	default:
  ------------------
  |  Branch (1704:2): [True: 2.90k, False: 0]
  ------------------
 1705|  2.90k|	    break;
 1706|  2.90k|    }
 1707|  2.90k|    if (xmlRegAtomPush(ctxt, atom) < 0)
  ------------------
  |  Branch (1707:9): [True: 0, False: 2.90k]
  ------------------
 1708|      0|	return(-1);
 1709|  2.90k|    return(0);
 1710|  2.90k|}
xmlregexp.c:xmlRegStateAddTrans:
 1309|  11.8k|		    int counter, int count) {
 1310|       |
 1311|  11.8k|    int nrtrans;
 1312|       |
 1313|  11.8k|    if (state == NULL) {
  ------------------
  |  Branch (1313:9): [True: 0, False: 11.8k]
  ------------------
 1314|      0|	ERROR("add state: state is NULL");
  ------------------
  |  |   55|      0|    ctxt->error = XML_REGEXP_COMPILE_ERROR;				\
  |  |   56|      0|    xmlRegexpErrCompile(ctxt, str);
  ------------------
 1315|      0|	return;
 1316|      0|    }
 1317|  11.8k|    if (target == NULL) {
  ------------------
  |  Branch (1317:9): [True: 0, False: 11.8k]
  ------------------
 1318|      0|	ERROR("add state: target is NULL");
  ------------------
  |  |   55|      0|    ctxt->error = XML_REGEXP_COMPILE_ERROR;				\
  |  |   56|      0|    xmlRegexpErrCompile(ctxt, str);
  ------------------
 1319|      0|	return;
 1320|      0|    }
 1321|       |    /*
 1322|       |     * Other routines follow the philosophy 'When in doubt, add a transition'
 1323|       |     * so we check here whether such a transition is already present and, if
 1324|       |     * so, silently ignore this request.
 1325|       |     */
 1326|       |
 1327|  74.7k|    for (nrtrans = state->nbTrans - 1; nrtrans >= 0; nrtrans--) {
  ------------------
  |  Branch (1327:40): [True: 63.0k, False: 11.7k]
  ------------------
 1328|  63.0k|	xmlRegTransPtr trans = &(state->trans[nrtrans]);
 1329|  63.0k|	if ((trans->atom == atom) &&
  ------------------
  |  Branch (1329:6): [True: 2.48k, False: 60.5k]
  ------------------
 1330|  63.0k|	    (trans->to == target->no) &&
  ------------------
  |  Branch (1330:6): [True: 56, False: 2.43k]
  ------------------
 1331|  63.0k|	    (trans->counter == counter) &&
  ------------------
  |  Branch (1331:6): [True: 56, False: 0]
  ------------------
 1332|  63.0k|	    (trans->count == count)) {
  ------------------
  |  Branch (1332:6): [True: 56, False: 0]
  ------------------
 1333|     56|	    return;
 1334|     56|	}
 1335|  63.0k|    }
 1336|       |
 1337|  11.7k|    if (state->maxTrans == 0) {
  ------------------
  |  Branch (1337:9): [True: 3.84k, False: 7.92k]
  ------------------
 1338|  3.84k|	state->maxTrans = 8;
 1339|  3.84k|	state->trans = (xmlRegTrans *) xmlMalloc(state->maxTrans *
 1340|  3.84k|		                             sizeof(xmlRegTrans));
 1341|  3.84k|	if (state->trans == NULL) {
  ------------------
  |  Branch (1341:6): [True: 0, False: 3.84k]
  ------------------
 1342|      0|	    xmlRegexpErrMemory(ctxt, "adding transition");
 1343|      0|	    state->maxTrans = 0;
 1344|      0|	    return;
 1345|      0|	}
 1346|  7.92k|    } else if (state->nbTrans >= state->maxTrans) {
  ------------------
  |  Branch (1346:16): [True: 476, False: 7.45k]
  ------------------
 1347|    476|	xmlRegTrans *tmp;
 1348|    476|	state->maxTrans *= 2;
 1349|    476|	tmp = (xmlRegTrans *) xmlRealloc(state->trans, state->maxTrans *
 1350|    476|		                             sizeof(xmlRegTrans));
 1351|    476|	if (tmp == NULL) {
  ------------------
  |  Branch (1351:6): [True: 0, False: 476]
  ------------------
 1352|      0|	    xmlRegexpErrMemory(ctxt, "adding transition");
 1353|      0|	    state->maxTrans /= 2;
 1354|      0|	    return;
 1355|      0|	}
 1356|    476|	state->trans = tmp;
 1357|    476|    }
 1358|       |
 1359|  11.7k|    state->trans[state->nbTrans].atom = atom;
 1360|  11.7k|    state->trans[state->nbTrans].to = target->no;
 1361|  11.7k|    state->trans[state->nbTrans].counter = counter;
 1362|  11.7k|    state->trans[state->nbTrans].count = count;
 1363|  11.7k|    state->trans[state->nbTrans].nd = 0;
 1364|  11.7k|    state->nbTrans++;
 1365|  11.7k|    xmlRegStateAddTransTo(ctxt, target, state->no);
 1366|  11.7k|}
xmlregexp.c:xmlRegStateAddTransTo:
 1280|  11.7k|                      int from) {
 1281|  11.7k|    if (target->maxTransTo == 0) {
  ------------------
  |  Branch (1281:9): [True: 3.66k, False: 8.10k]
  ------------------
 1282|  3.66k|	target->maxTransTo = 8;
 1283|  3.66k|	target->transTo = (int *) xmlMalloc(target->maxTransTo *
 1284|  3.66k|		                             sizeof(int));
 1285|  3.66k|	if (target->transTo == NULL) {
  ------------------
  |  Branch (1285:6): [True: 0, False: 3.66k]
  ------------------
 1286|      0|	    xmlRegexpErrMemory(ctxt, "adding transition");
 1287|      0|	    target->maxTransTo = 0;
 1288|      0|	    return;
 1289|      0|	}
 1290|  8.10k|    } else if (target->nbTransTo >= target->maxTransTo) {
  ------------------
  |  Branch (1290:16): [True: 376, False: 7.73k]
  ------------------
 1291|    376|	int *tmp;
 1292|    376|	target->maxTransTo *= 2;
 1293|    376|	tmp = (int *) xmlRealloc(target->transTo, target->maxTransTo *
 1294|    376|		                             sizeof(int));
 1295|    376|	if (tmp == NULL) {
  ------------------
  |  Branch (1295:6): [True: 0, False: 376]
  ------------------
 1296|      0|	    xmlRegexpErrMemory(ctxt, "adding transition");
 1297|      0|	    target->maxTransTo /= 2;
 1298|      0|	    return;
 1299|      0|	}
 1300|    376|	target->transTo = tmp;
 1301|    376|    }
 1302|  11.7k|    target->transTo[target->nbTransTo] = from;
 1303|  11.7k|    target->nbTransTo++;
 1304|  11.7k|}
xmlregexp.c:xmlRegAtomPush:
 1256|  2.90k|xmlRegAtomPush(xmlRegParserCtxtPtr ctxt, xmlRegAtomPtr atom) {
 1257|  2.90k|    if (atom == NULL) {
  ------------------
  |  Branch (1257:9): [True: 0, False: 2.90k]
  ------------------
 1258|      0|	ERROR("atom push: atom is NULL");
  ------------------
  |  |   55|      0|    ctxt->error = XML_REGEXP_COMPILE_ERROR;				\
  |  |   56|      0|    xmlRegexpErrCompile(ctxt, str);
  ------------------
 1259|      0|	return(-1);
 1260|      0|    }
 1261|  2.90k|    if (ctxt->nbAtoms >= ctxt->maxAtoms) {
  ------------------
  |  Branch (1261:9): [True: 929, False: 1.97k]
  ------------------
 1262|    929|        size_t newSize = ctxt->maxAtoms ? ctxt->maxAtoms * 2 : 4;
  ------------------
  |  Branch (1262:26): [True: 336, False: 593]
  ------------------
 1263|    929|	xmlRegAtomPtr *tmp;
 1264|       |
 1265|    929|	tmp = xmlRealloc(ctxt->atoms, newSize * sizeof(xmlRegAtomPtr));
 1266|    929|	if (tmp == NULL) {
  ------------------
  |  Branch (1266:6): [True: 0, False: 929]
  ------------------
 1267|      0|	    xmlRegexpErrMemory(ctxt, "allocating counter");
 1268|      0|	    return(-1);
 1269|      0|	}
 1270|    929|	ctxt->atoms = tmp;
 1271|    929|        ctxt->maxAtoms = newSize;
 1272|    929|    }
 1273|  2.90k|    atom->no = ctxt->nbAtoms;
 1274|  2.90k|    ctxt->atoms[ctxt->nbAtoms++] = atom;
 1275|  2.90k|    return(0);
 1276|  2.90k|}
xmlregexp.c:xmlFAGenerateEpsilonTransition:
 1429|  3.14k|			       xmlRegStatePtr from, xmlRegStatePtr to) {
 1430|  3.14k|    if (to == NULL) {
  ------------------
  |  Branch (1430:9): [True: 965, False: 2.18k]
  ------------------
 1431|    965|	to = xmlRegStatePush(ctxt);
 1432|    965|        if (to == NULL)
  ------------------
  |  Branch (1432:13): [True: 0, False: 965]
  ------------------
 1433|      0|            return(-1);
 1434|    965|	ctxt->state = to;
 1435|    965|    }
 1436|  3.14k|    xmlRegStateAddTrans(ctxt, from, NULL, to, -1, -1);
 1437|  3.14k|    return(0);
 1438|  3.14k|}

xmlStrndup:
   45|   994k|xmlStrndup(const xmlChar *cur, int len) {
   46|   994k|    xmlChar *ret;
   47|       |
   48|   994k|    if ((cur == NULL) || (len < 0)) return(NULL);
  ------------------
  |  Branch (48:9): [True: 0, False: 994k]
  |  Branch (48:26): [True: 0, False: 994k]
  ------------------
   49|   994k|    ret = (xmlChar *) xmlMallocAtomic((size_t) len + 1);
   50|   994k|    if (ret == NULL) {
  ------------------
  |  Branch (50:9): [True: 0, False: 994k]
  ------------------
   51|      0|        return(NULL);
   52|      0|    }
   53|   994k|    memcpy(ret, cur, len);
   54|   994k|    ret[len] = 0;
   55|   994k|    return(ret);
   56|   994k|}
xmlStrdup:
   69|   712k|xmlStrdup(const xmlChar *cur) {
   70|   712k|    const xmlChar *p = cur;
   71|       |
   72|   712k|    if (cur == NULL) return(NULL);
  ------------------
  |  Branch (72:9): [True: 10.1k, False: 702k]
  ------------------
   73|  7.07M|    while (*p != 0) p++; /* non input consuming */
  ------------------
  |  Branch (73:12): [True: 6.37M, False: 702k]
  ------------------
   74|   702k|    return(xmlStrndup(cur, p - cur));
   75|   712k|}
xmlCharStrndup:
   88|  14.3k|xmlCharStrndup(const char *cur, int len) {
   89|  14.3k|    int i;
   90|  14.3k|    xmlChar *ret;
   91|       |
   92|  14.3k|    if ((cur == NULL) || (len < 0)) return(NULL);
  ------------------
  |  Branch (92:9): [True: 0, False: 14.3k]
  |  Branch (92:26): [True: 0, False: 14.3k]
  ------------------
   93|  14.3k|    ret = (xmlChar *) xmlMallocAtomic((size_t) len + 1);
   94|  14.3k|    if (ret == NULL) {
  ------------------
  |  Branch (94:9): [True: 0, False: 14.3k]
  ------------------
   95|      0|        return(NULL);
   96|      0|    }
   97|  98.7k|    for (i = 0;i < len;i++) {
  ------------------
  |  Branch (97:16): [True: 84.4k, False: 14.3k]
  ------------------
   98|       |        /* Explicit sign change */
   99|  84.4k|        ret[i] = (xmlChar) cur[i];
  100|  84.4k|        if (ret[i] == 0) return(ret);
  ------------------
  |  Branch (100:13): [True: 0, False: 84.4k]
  ------------------
  101|  84.4k|    }
  102|  14.3k|    ret[len] = 0;
  103|  14.3k|    return(ret);
  104|  14.3k|}
xmlCharStrdup:
  116|  14.3k|xmlCharStrdup(const char *cur) {
  117|  14.3k|    const char *p = cur;
  118|       |
  119|  14.3k|    if (cur == NULL) return(NULL);
  ------------------
  |  Branch (119:9): [True: 0, False: 14.3k]
  ------------------
  120|  98.7k|    while (*p != '\0') p++; /* non input consuming */
  ------------------
  |  Branch (120:12): [True: 84.4k, False: 14.3k]
  ------------------
  121|  14.3k|    return(xmlCharStrndup(cur, p - cur));
  122|  14.3k|}
xmlStrcmp:
  135|     40|xmlStrcmp(const xmlChar *str1, const xmlChar *str2) {
  136|     40|    if (str1 == str2) return(0);
  ------------------
  |  Branch (136:9): [True: 0, False: 40]
  ------------------
  137|     40|    if (str1 == NULL) return(-1);
  ------------------
  |  Branch (137:9): [True: 0, False: 40]
  ------------------
  138|     40|    if (str2 == NULL) return(1);
  ------------------
  |  Branch (138:9): [True: 0, False: 40]
  ------------------
  139|     40|#ifdef FUZZING_BUILD_MODE_UNSAFE_FOR_PRODUCTION
  140|     40|    return(strcmp((const char *)str1, (const char *)str2));
  141|       |#else
  142|       |    do {
  143|       |        int tmp = *str1++ - *str2;
  144|       |        if (tmp != 0) return(tmp);
  145|       |    } while (*str2++ != 0);
  146|       |    return 0;
  147|       |#endif
  148|     40|}
xmlStrEqual:
  162|   461k|xmlStrEqual(const xmlChar *str1, const xmlChar *str2) {
  163|   461k|    if (str1 == str2) return(1);
  ------------------
  |  Branch (163:9): [True: 21.9k, False: 439k]
  ------------------
  164|   439k|    if (str1 == NULL) return(0);
  ------------------
  |  Branch (164:9): [True: 5.23k, False: 434k]
  ------------------
  165|   434k|    if (str2 == NULL) return(0);
  ------------------
  |  Branch (165:9): [True: 7, False: 434k]
  ------------------
  166|   434k|#ifdef FUZZING_BUILD_MODE_UNSAFE_FOR_PRODUCTION
  167|   434k|    return(strcmp((const char *)str1, (const char *)str2) == 0);
  168|       |#else
  169|       |    do {
  170|       |        if (*str1++ != *str2) return(0);
  171|       |    } while (*str2++);
  172|       |    return(1);
  173|       |#endif
  174|   434k|}
xmlStrQEqual:
  188|  12.8k|xmlStrQEqual(const xmlChar *pref, const xmlChar *name, const xmlChar *str) {
  189|  12.8k|    if (pref == NULL) return(xmlStrEqual(name, str));
  ------------------
  |  Branch (189:9): [True: 12.5k, False: 220]
  ------------------
  190|    220|    if (name == NULL) return(0);
  ------------------
  |  Branch (190:9): [True: 0, False: 220]
  ------------------
  191|    220|    if (str == NULL) return(0);
  ------------------
  |  Branch (191:9): [True: 0, False: 220]
  ------------------
  192|       |
  193|    660|    do {
  194|    660|        if (*pref++ != *str) return(0);
  ------------------
  |  Branch (194:13): [True: 0, False: 660]
  ------------------
  195|    660|    } while ((*str++) && (*pref));
  ------------------
  |  Branch (195:14): [True: 660, False: 0]
  |  Branch (195:26): [True: 440, False: 220]
  ------------------
  196|    220|    if (*str++ != ':') return(0);
  ------------------
  |  Branch (196:9): [True: 0, False: 220]
  ------------------
  197|  1.23k|    do {
  198|  1.23k|        if (*name++ != *str) return(0);
  ------------------
  |  Branch (198:13): [True: 0, False: 1.23k]
  ------------------
  199|  1.23k|    } while (*str++);
  ------------------
  |  Branch (199:14): [True: 1.01k, False: 220]
  ------------------
  200|    220|    return(1);
  201|    220|}
xmlStrncmp:
  215|     20|xmlStrncmp(const xmlChar *str1, const xmlChar *str2, int len) {
  216|     20|    if (len <= 0) return(0);
  ------------------
  |  Branch (216:9): [True: 0, False: 20]
  ------------------
  217|     20|    if (str1 == str2) return(0);
  ------------------
  |  Branch (217:9): [True: 0, False: 20]
  ------------------
  218|     20|    if (str1 == NULL) return(-1);
  ------------------
  |  Branch (218:9): [True: 0, False: 20]
  ------------------
  219|     20|    if (str2 == NULL) return(1);
  ------------------
  |  Branch (219:9): [True: 0, False: 20]
  ------------------
  220|     20|#ifdef FUZZING_BUILD_MODE_UNSAFE_FOR_PRODUCTION
  221|     20|    return(strncmp((const char *)str1, (const char *)str2, len));
  222|       |#else
  223|       |    do {
  224|       |        int tmp = *str1++ - *str2;
  225|       |        if (tmp != 0 || --len == 0) return(tmp);
  226|       |    } while (*str2++ != 0);
  227|       |    return 0;
  228|       |#endif
  229|     20|}
xmlStrcasecmp:
  277|    176|xmlStrcasecmp(const xmlChar *str1, const xmlChar *str2) {
  278|    176|    register int tmp;
  279|       |
  280|    176|    if (str1 == str2) return(0);
  ------------------
  |  Branch (280:9): [True: 80, False: 96]
  ------------------
  281|     96|    if (str1 == NULL) return(-1);
  ------------------
  |  Branch (281:9): [True: 0, False: 96]
  ------------------
  282|     96|    if (str2 == NULL) return(1);
  ------------------
  |  Branch (282:9): [True: 0, False: 96]
  ------------------
  283|    180|    do {
  284|    180|        tmp = casemap[*str1++] - casemap[*str2];
  285|    180|        if (tmp != 0) return(tmp);
  ------------------
  |  Branch (285:13): [True: 72, False: 108]
  ------------------
  286|    180|    } while (*str2++ != 0);
  ------------------
  |  Branch (286:14): [True: 84, False: 24]
  ------------------
  287|     24|    return 0;
  288|     96|}
xmlStrncasecmp:
  302|  27.0k|xmlStrncasecmp(const xmlChar *str1, const xmlChar *str2, int len) {
  303|  27.0k|    register int tmp;
  304|       |
  305|  27.0k|    if (len <= 0) return(0);
  ------------------
  |  Branch (305:9): [True: 0, False: 27.0k]
  ------------------
  306|  27.0k|    if (str1 == str2) return(0);
  ------------------
  |  Branch (306:9): [True: 0, False: 27.0k]
  ------------------
  307|  27.0k|    if (str1 == NULL) return(-1);
  ------------------
  |  Branch (307:9): [True: 0, False: 27.0k]
  ------------------
  308|  27.0k|    if (str2 == NULL) return(1);
  ------------------
  |  Branch (308:9): [True: 0, False: 27.0k]
  ------------------
  309|  27.0k|    do {
  310|  27.0k|        tmp = casemap[*str1++] - casemap[*str2];
  311|  27.0k|        if (tmp != 0 || --len == 0) return(tmp);
  ------------------
  |  Branch (311:13): [True: 27.0k, False: 0]
  |  Branch (311:25): [True: 0, False: 0]
  ------------------
  312|  27.0k|    } while (*str2++ != 0);
  ------------------
  |  Branch (312:14): [True: 0, False: 0]
  ------------------
  313|      0|    return 0;
  314|  27.0k|}
xmlStrchr:
  327|  45.3k|xmlStrchr(const xmlChar *str, xmlChar val) {
  328|  45.3k|    if (str == NULL) return(NULL);
  ------------------
  |  Branch (328:9): [True: 0, False: 45.3k]
  ------------------
  329|   716k|    while (*str != 0) { /* non input consuming */
  ------------------
  |  Branch (329:12): [True: 671k, False: 45.3k]
  ------------------
  330|   671k|        if (*str == val) return((xmlChar *) str);
  ------------------
  |  Branch (330:13): [True: 0, False: 671k]
  ------------------
  331|   671k|        str++;
  332|   671k|    }
  333|  45.3k|    return(NULL);
  334|  45.3k|}
xmlStrlen:
  428|  48.1k|xmlStrlen(const xmlChar *str) {
  429|  48.1k|    size_t len = str ? strlen((const char *)str) : 0;
  ------------------
  |  Branch (429:18): [True: 48.1k, False: 0]
  ------------------
  430|  48.1k|    return(len > INT_MAX ? 0 : len);
  ------------------
  |  Branch (430:12): [True: 0, False: 48.1k]
  ------------------
  431|  48.1k|}
xmlStrncat:
  448|  12.9k|xmlStrncat(xmlChar *cur, const xmlChar *add, int len) {
  449|  12.9k|    int size;
  450|  12.9k|    xmlChar *ret;
  451|       |
  452|  12.9k|    if ((add == NULL) || (len == 0))
  ------------------
  |  Branch (452:9): [True: 0, False: 12.9k]
  |  Branch (452:26): [True: 0, False: 12.9k]
  ------------------
  453|      0|        return(cur);
  454|  12.9k|    if (len < 0)
  ------------------
  |  Branch (454:9): [True: 0, False: 12.9k]
  ------------------
  455|      0|	return(NULL);
  456|  12.9k|    if (cur == NULL)
  ------------------
  |  Branch (456:9): [True: 0, False: 12.9k]
  ------------------
  457|      0|        return(xmlStrndup(add, len));
  458|       |
  459|  12.9k|    size = xmlStrlen(cur);
  460|  12.9k|    if ((size < 0) || (size > INT_MAX - len))
  ------------------
  |  Branch (460:9): [True: 0, False: 12.9k]
  |  Branch (460:23): [True: 0, False: 12.9k]
  ------------------
  461|      0|        return(NULL);
  462|  12.9k|    ret = (xmlChar *) xmlRealloc(cur, (size_t) size + len + 1);
  463|  12.9k|    if (ret == NULL) {
  ------------------
  |  Branch (463:9): [True: 0, False: 12.9k]
  ------------------
  464|      0|        return(cur);
  465|      0|    }
  466|  12.9k|    memcpy(&ret[size], add, len);
  467|  12.9k|    ret[size + len] = 0;
  468|  12.9k|    return(ret);
  469|  12.9k|}
xmlStrncatNew:
  484|     21|xmlStrncatNew(const xmlChar *str1, const xmlChar *str2, int len) {
  485|     21|    int size;
  486|     21|    xmlChar *ret;
  487|       |
  488|     21|    if (len < 0) {
  ------------------
  |  Branch (488:9): [True: 0, False: 21]
  ------------------
  489|      0|        len = xmlStrlen(str2);
  490|      0|        if (len < 0)
  ------------------
  |  Branch (490:13): [True: 0, False: 0]
  ------------------
  491|      0|            return(NULL);
  492|      0|    }
  493|     21|    if ((str2 == NULL) || (len == 0))
  ------------------
  |  Branch (493:9): [True: 0, False: 21]
  |  Branch (493:27): [True: 0, False: 21]
  ------------------
  494|      0|        return(xmlStrdup(str1));
  495|     21|    if (str1 == NULL)
  ------------------
  |  Branch (495:9): [True: 0, False: 21]
  ------------------
  496|      0|        return(xmlStrndup(str2, len));
  497|       |
  498|     21|    size = xmlStrlen(str1);
  499|     21|    if ((size < 0) || (size > INT_MAX - len))
  ------------------
  |  Branch (499:9): [True: 0, False: 21]
  |  Branch (499:23): [True: 0, False: 21]
  ------------------
  500|      0|        return(NULL);
  501|     21|    ret = (xmlChar *) xmlMalloc((size_t) size + len + 1);
  502|     21|    if (ret == NULL) {
  ------------------
  |  Branch (502:9): [True: 0, False: 21]
  ------------------
  503|      0|        return(xmlStrndup(str1, size));
  504|      0|    }
  505|     21|    memcpy(ret, str1, size);
  506|     21|    memcpy(&ret[size], str2, len);
  507|     21|    ret[size + len] = 0;
  508|     21|    return(ret);
  509|     21|}
xmlStrcat:
  524|  1.78k|xmlStrcat(xmlChar *cur, const xmlChar *add) {
  525|  1.78k|    const xmlChar *p = add;
  526|       |
  527|  1.78k|    if (add == NULL) return(cur);
  ------------------
  |  Branch (527:9): [True: 0, False: 1.78k]
  ------------------
  528|  1.78k|    if (cur == NULL)
  ------------------
  |  Branch (528:9): [True: 1.47k, False: 308]
  ------------------
  529|  1.47k|        return(xmlStrdup(add));
  530|       |
  531|  1.43k|    while (*p != 0) p++; /* non input consuming */
  ------------------
  |  Branch (531:12): [True: 1.13k, False: 308]
  ------------------
  532|    308|    return(xmlStrncat(cur, add, p - add));
  533|  1.78k|}
xmlGetUTF8Char:
  708|  17.2M|xmlGetUTF8Char(const unsigned char *utf, int *len) {
  709|  17.2M|    unsigned int c;
  710|       |
  711|  17.2M|    if (utf == NULL)
  ------------------
  |  Branch (711:9): [True: 0, False: 17.2M]
  ------------------
  712|      0|        goto error;
  713|  17.2M|    if (len == NULL)
  ------------------
  |  Branch (713:9): [True: 0, False: 17.2M]
  ------------------
  714|      0|        goto error;
  715|       |
  716|  17.2M|    c = utf[0];
  717|  17.2M|    if (c < 0x80) {
  ------------------
  |  Branch (717:9): [True: 17.2M, False: 333]
  ------------------
  718|  17.2M|        if (*len < 1)
  ------------------
  |  Branch (718:13): [True: 0, False: 17.2M]
  ------------------
  719|      0|            goto error;
  720|       |        /* 1-byte code */
  721|  17.2M|        *len = 1;
  722|  17.2M|    } else {
  723|    333|        if ((*len < 2) || ((utf[1] & 0xc0) != 0x80))
  ------------------
  |  Branch (723:13): [True: 0, False: 333]
  |  Branch (723:27): [True: 58, False: 275]
  ------------------
  724|     58|            goto error;
  725|    275|        if (c < 0xe0) {
  ------------------
  |  Branch (725:13): [True: 77, False: 198]
  ------------------
  726|     77|            if (c < 0xc2)
  ------------------
  |  Branch (726:17): [True: 0, False: 77]
  ------------------
  727|      0|                goto error;
  728|       |            /* 2-byte code */
  729|     77|            *len = 2;
  730|     77|            c = (c & 0x1f) << 6;
  731|     77|            c |= utf[1] & 0x3f;
  732|    198|        } else {
  733|    198|            if ((*len < 3) || ((utf[2] & 0xc0) != 0x80))
  ------------------
  |  Branch (733:17): [True: 0, False: 198]
  |  Branch (733:31): [True: 0, False: 198]
  ------------------
  734|      0|                goto error;
  735|    198|            if (c < 0xf0) {
  ------------------
  |  Branch (735:17): [True: 198, False: 0]
  ------------------
  736|       |                /* 3-byte code */
  737|    198|                *len = 3;
  738|    198|                c = (c & 0xf) << 12;
  739|    198|                c |= (utf[1] & 0x3f) << 6;
  740|    198|                c |= utf[2] & 0x3f;
  741|    198|                if ((c < 0x800) || ((c >= 0xd800) && (c < 0xe000)))
  ------------------
  |  Branch (741:21): [True: 0, False: 198]
  |  Branch (741:37): [True: 3, False: 195]
  |  Branch (741:54): [True: 0, False: 3]
  ------------------
  742|      0|                    goto error;
  743|    198|            } else {
  744|      0|                if ((*len < 4) || ((utf[3] & 0xc0) != 0x80))
  ------------------
  |  Branch (744:21): [True: 0, False: 0]
  |  Branch (744:35): [True: 0, False: 0]
  ------------------
  745|      0|                    goto error;
  746|      0|                *len = 4;
  747|       |                /* 4-byte code */
  748|      0|                c = (c & 0x7) << 18;
  749|      0|                c |= (utf[1] & 0x3f) << 12;
  750|      0|                c |= (utf[2] & 0x3f) << 6;
  751|      0|                c |= utf[3] & 0x3f;
  752|      0|                if ((c < 0x10000) || (c >= 0x110000))
  ------------------
  |  Branch (752:21): [True: 0, False: 0]
  |  Branch (752:38): [True: 0, False: 0]
  ------------------
  753|      0|                    goto error;
  754|      0|            }
  755|    198|        }
  756|    275|    }
  757|  17.2M|    return(c);
  758|       |
  759|     58|error:
  760|     58|    if (len != NULL)
  ------------------
  |  Branch (760:9): [True: 58, False: 0]
  ------------------
  761|     58|	*len = 0;
  762|     58|    return(-1);
  763|  17.2M|}

xmlInitXPathInternal:
  168|      2|xmlInitXPathInternal(void) {
  169|      2|#if defined(NAN) && defined(INFINITY)
  170|      2|    xmlXPathNAN = NAN;
  171|      2|    xmlXPathPINF = INFINITY;
  172|      2|    xmlXPathNINF = -INFINITY;
  173|       |#else
  174|       |    /* MSVC doesn't allow division by zero in constant expressions. */
  175|       |    double zero = 0.0;
  176|       |    xmlXPathNAN = 0.0 / zero;
  177|       |    xmlXPathPINF = 1.0 / zero;
  178|       |    xmlXPathNINF = -xmlXPathPINF;
  179|       |#endif
  180|      2|}

