xmlSAX2InternalSubset:
  326|      8|{
  327|      8|    xmlParserCtxtPtr ctxt = (xmlParserCtxtPtr) ctx;
  328|      8|    xmlDtdPtr dtd;
  329|      8|    if (ctx == NULL) return;
  ------------------
  |  Branch (329:9): [True: 0, False: 8]
  ------------------
  330|       |
  331|      8|    if (ctxt->myDoc == NULL)
  ------------------
  |  Branch (331:9): [True: 0, False: 8]
  ------------------
  332|      0|	return;
  333|      8|    dtd = xmlGetIntSubset(ctxt->myDoc);
  334|      8|    if (dtd != NULL) {
  ------------------
  |  Branch (334:9): [True: 0, False: 8]
  ------------------
  335|      0|	if (ctxt->html)
  ------------------
  |  Branch (335:6): [True: 0, False: 0]
  ------------------
  336|      0|	    return;
  337|      0|	xmlUnlinkNode((xmlNodePtr) dtd);
  338|      0|	xmlFreeDtd(dtd);
  339|      0|	ctxt->myDoc->intSubset = NULL;
  340|      0|    }
  341|      8|    ctxt->myDoc->intSubset =
  342|      8|	xmlCreateIntSubset(ctxt->myDoc, name, ExternalID, SystemID);
  343|      8|    if (ctxt->myDoc->intSubset == NULL)
  ------------------
  |  Branch (343:9): [True: 0, False: 8]
  ------------------
  344|      0|        xmlSAX2ErrMemory(ctxt, "xmlSAX2InternalSubset");
  345|      8|}
xmlSAX2ExternalSubset:
  359|      8|{
  360|      8|    xmlParserCtxtPtr ctxt = (xmlParserCtxtPtr) ctx;
  361|      8|    if (ctx == NULL) return;
  ------------------
  |  Branch (361:9): [True: 0, False: 8]
  ------------------
  362|      8|    if (((ExternalID != NULL) || (SystemID != NULL)) &&
  ------------------
  |  Branch (362:10): [True: 0, False: 8]
  |  Branch (362:34): [True: 0, False: 8]
  ------------------
  363|      8|        (((ctxt->validate) || (ctxt->loadsubset != 0)) &&
  ------------------
  |  Branch (363:11): [True: 0, False: 0]
  |  Branch (363:31): [True: 0, False: 0]
  ------------------
  364|      0|	 (ctxt->wellFormed && ctxt->myDoc))) {
  ------------------
  |  Branch (364:4): [True: 0, False: 0]
  |  Branch (364:24): [True: 0, False: 0]
  ------------------
  365|       |	/*
  366|       |	 * Try to fetch and parse the external subset.
  367|       |	 */
  368|      0|	xmlParserInputPtr oldinput;
  369|      0|	int oldinputNr;
  370|      0|	int oldinputMax;
  371|      0|	xmlParserInputPtr *oldinputTab;
  372|      0|	xmlParserInputPtr input = NULL;
  373|      0|	const xmlChar *oldencoding;
  374|      0|	int oldprogressive;
  375|      0|        unsigned long consumed;
  376|      0|        size_t buffered;
  377|       |
  378|       |	/*
  379|       |	 * Ask the Entity resolver to load the damn thing
  380|       |	 */
  381|      0|	if ((ctxt->sax != NULL) && (ctxt->sax->resolveEntity != NULL))
  ------------------
  |  Branch (381:6): [True: 0, False: 0]
  |  Branch (381:29): [True: 0, False: 0]
  ------------------
  382|      0|	    input = ctxt->sax->resolveEntity(ctxt->userData, ExternalID,
  383|      0|	                                        SystemID);
  384|      0|	if (input == NULL) {
  ------------------
  |  Branch (384:6): [True: 0, False: 0]
  ------------------
  385|      0|	    return;
  386|      0|	}
  387|       |
  388|      0|	xmlNewDtd(ctxt->myDoc, name, ExternalID, SystemID);
  389|       |
  390|       |	/*
  391|       |	 * make sure we won't destroy the main document context
  392|       |	 */
  393|      0|	oldinput = ctxt->input;
  394|      0|	oldinputNr = ctxt->inputNr;
  395|      0|	oldinputMax = ctxt->inputMax;
  396|      0|	oldinputTab = ctxt->inputTab;
  397|      0|	oldencoding = ctxt->encoding;
  398|      0|        oldprogressive = ctxt->progressive;
  399|      0|	ctxt->encoding = NULL;
  400|      0|        ctxt->progressive = 0;
  401|       |
  402|      0|	ctxt->inputTab = (xmlParserInputPtr *)
  403|      0|	                 xmlMalloc(5 * sizeof(xmlParserInputPtr));
  404|      0|	if (ctxt->inputTab == NULL) {
  ------------------
  |  Branch (404:6): [True: 0, False: 0]
  ------------------
  405|      0|	    xmlSAX2ErrMemory(ctxt, "xmlSAX2ExternalSubset");
  406|      0|            xmlFreeInputStream(input);
  407|      0|	    ctxt->input = oldinput;
  408|      0|	    ctxt->inputNr = oldinputNr;
  409|      0|	    ctxt->inputMax = oldinputMax;
  410|      0|	    ctxt->inputTab = oldinputTab;
  411|      0|	    ctxt->encoding = oldencoding;
  412|      0|            ctxt->progressive = oldprogressive;
  413|      0|	    return;
  414|      0|	}
  415|      0|	ctxt->inputNr = 0;
  416|      0|	ctxt->inputMax = 5;
  417|      0|	ctxt->input = NULL;
  418|      0|	xmlPushInput(ctxt, input);
  419|       |
  420|      0|	if (input->filename == NULL)
  ------------------
  |  Branch (420:6): [True: 0, False: 0]
  ------------------
  421|      0|	    input->filename = (char *) xmlCanonicPath(SystemID);
  422|      0|	input->line = 1;
  423|      0|	input->col = 1;
  424|      0|	input->base = ctxt->input->cur;
  425|      0|	input->cur = ctxt->input->cur;
  426|      0|	input->free = NULL;
  427|       |
  428|       |	/*
  429|       |	 * let's parse that entity knowing it's an external subset.
  430|       |	 */
  431|      0|	xmlParseExternalSubset(ctxt, ExternalID, SystemID);
  432|       |
  433|       |        /*
  434|       |	 * Free up the external entities
  435|       |	 */
  436|       |
  437|      0|	while (ctxt->inputNr > 1)
  ------------------
  |  Branch (437:9): [True: 0, False: 0]
  ------------------
  438|      0|	    xmlPopInput(ctxt);
  439|       |
  440|      0|        consumed = ctxt->input->consumed;
  441|      0|        buffered = ctxt->input->cur - ctxt->input->base;
  442|      0|        if (buffered > ULONG_MAX - consumed)
  ------------------
  |  Branch (442:13): [True: 0, False: 0]
  ------------------
  443|      0|            consumed = ULONG_MAX;
  444|      0|        else
  445|      0|            consumed += buffered;
  446|      0|        if (consumed > ULONG_MAX - ctxt->sizeentities)
  ------------------
  |  Branch (446:13): [True: 0, False: 0]
  ------------------
  447|      0|            ctxt->sizeentities = ULONG_MAX;
  448|      0|        else
  449|      0|            ctxt->sizeentities += consumed;
  450|       |
  451|      0|	xmlFreeInputStream(ctxt->input);
  452|      0|        xmlFree(ctxt->inputTab);
  453|       |
  454|       |	/*
  455|       |	 * Restore the parsing context of the main entity
  456|       |	 */
  457|      0|	ctxt->input = oldinput;
  458|      0|	ctxt->inputNr = oldinputNr;
  459|      0|	ctxt->inputMax = oldinputMax;
  460|      0|	ctxt->inputTab = oldinputTab;
  461|      0|	if ((ctxt->encoding != NULL) &&
  ------------------
  |  Branch (461:6): [True: 0, False: 0]
  ------------------
  462|      0|	    ((ctxt->dict == NULL) ||
  ------------------
  |  Branch (462:7): [True: 0, False: 0]
  ------------------
  463|      0|	     (!xmlDictOwns(ctxt->dict, ctxt->encoding))))
  ------------------
  |  Branch (463:7): [True: 0, False: 0]
  ------------------
  464|      0|	    xmlFree((xmlChar *) ctxt->encoding);
  465|      0|	ctxt->encoding = oldencoding;
  466|      0|        ctxt->progressive = oldprogressive;
  467|       |	/* ctxt->wellFormed = oldwellFormed; */
  468|      0|    }
  469|      8|}
xmlSAX2GetEntity:
  519|      4|{
  520|      4|    xmlParserCtxtPtr ctxt = (xmlParserCtxtPtr) ctx;
  521|      4|    xmlEntityPtr ret = NULL;
  522|       |
  523|      4|    if (ctx == NULL) return(NULL);
  ------------------
  |  Branch (523:9): [True: 0, False: 4]
  ------------------
  524|       |
  525|      4|    if (ctxt->inSubset == 0) {
  ------------------
  |  Branch (525:9): [True: 4, False: 0]
  ------------------
  526|      4|	ret = xmlGetPredefinedEntity(name);
  527|      4|	if (ret != NULL)
  ------------------
  |  Branch (527:6): [True: 0, False: 4]
  ------------------
  528|      0|	    return(ret);
  529|      4|    }
  530|      4|    if ((ctxt->myDoc != NULL) && (ctxt->myDoc->standalone == 1)) {
  ------------------
  |  Branch (530:9): [True: 4, False: 0]
  |  Branch (530:34): [True: 0, False: 4]
  ------------------
  531|      0|	if (ctxt->inSubset == 2) {
  ------------------
  |  Branch (531:6): [True: 0, False: 0]
  ------------------
  532|      0|	    ctxt->myDoc->standalone = 0;
  533|      0|	    ret = xmlGetDocEntity(ctxt->myDoc, name);
  534|      0|	    ctxt->myDoc->standalone = 1;
  535|      0|	} else {
  536|      0|	    ret = xmlGetDocEntity(ctxt->myDoc, name);
  537|      0|	    if (ret == NULL) {
  ------------------
  |  Branch (537:10): [True: 0, False: 0]
  ------------------
  538|      0|		ctxt->myDoc->standalone = 0;
  539|      0|		ret = xmlGetDocEntity(ctxt->myDoc, name);
  540|      0|		if (ret != NULL) {
  ------------------
  |  Branch (540:7): [True: 0, False: 0]
  ------------------
  541|      0|		    xmlFatalErrMsg(ctxt, XML_ERR_NOT_STANDALONE,
  542|      0|	 "Entity(%s) document marked standalone but requires external subset\n",
  543|      0|				   name, NULL);
  544|      0|		}
  545|      0|		ctxt->myDoc->standalone = 1;
  546|      0|	    }
  547|      0|	}
  548|      4|    } else {
  549|      4|	ret = xmlGetDocEntity(ctxt->myDoc, name);
  550|      4|    }
  551|      4|    return(ret);
  552|      4|}
xmlSAX2AttributeDecl:
  656|      8|{
  657|      8|    xmlParserCtxtPtr ctxt = (xmlParserCtxtPtr) ctx;
  658|      8|    xmlAttributePtr attr;
  659|      8|    xmlChar *name = NULL, *prefix = NULL;
  660|       |
  661|       |    /* Avoid unused variable warning if features are disabled. */
  662|      8|    (void) attr;
  663|       |
  664|      8|    if ((ctxt == NULL) || (ctxt->myDoc == NULL))
  ------------------
  |  Branch (664:9): [True: 0, False: 8]
  |  Branch (664:27): [True: 0, False: 8]
  ------------------
  665|      0|        return;
  666|       |
  667|      8|    if ((xmlStrEqual(fullname, BAD_CAST "xml:id")) &&
  ------------------
  |  |   35|      8|#define BAD_CAST (xmlChar *)
  ------------------
  |  Branch (667:9): [True: 0, False: 8]
  ------------------
  668|      8|        (type != XML_ATTRIBUTE_ID)) {
  ------------------
  |  Branch (668:9): [True: 0, False: 0]
  ------------------
  669|       |	/*
  670|       |	 * Raise the error but keep the validity flag
  671|       |	 */
  672|      0|	int tmp = ctxt->valid;
  673|      0|	xmlErrValid(ctxt, XML_DTD_XMLID_TYPE,
  674|      0|	      "xml:id : attribute type should be ID\n", NULL, NULL);
  675|      0|	ctxt->valid = tmp;
  676|      0|    }
  677|       |    /* TODO: optimize name/prefix allocation */
  678|      8|    name = xmlSplitQName(ctxt, fullname, &prefix);
  679|      8|    ctxt->vctxt.valid = 1;
  680|      8|    if (ctxt->inSubset == 1)
  ------------------
  |  Branch (680:9): [True: 8, False: 0]
  ------------------
  681|      8|	attr = xmlAddAttributeDecl(&ctxt->vctxt, ctxt->myDoc->intSubset, elem,
  682|      8|	       name, prefix, (xmlAttributeType) type,
  683|      8|	       (xmlAttributeDefault) def, defaultValue, tree);
  684|      0|    else if (ctxt->inSubset == 2)
  ------------------
  |  Branch (684:14): [True: 0, False: 0]
  ------------------
  685|      0|	attr = xmlAddAttributeDecl(&ctxt->vctxt, ctxt->myDoc->extSubset, elem,
  686|      0|	   name, prefix, (xmlAttributeType) type,
  687|      0|	   (xmlAttributeDefault) def, defaultValue, tree);
  688|      0|    else {
  689|      0|        xmlFatalErrMsg(ctxt, XML_ERR_INTERNAL_ERROR,
  690|      0|	     "SAX.xmlSAX2AttributeDecl(%s) called while not in subset\n",
  691|      0|	               name, NULL);
  692|      0|	xmlFree(name);
  693|      0|	xmlFreeEnumeration(tree);
  694|      0|	return;
  695|      0|    }
  696|      8|#ifdef LIBXML_VALID_ENABLED
  697|      8|    if (ctxt->vctxt.valid == 0)
  ------------------
  |  Branch (697:9): [True: 0, False: 8]
  ------------------
  698|      0|	ctxt->valid = 0;
  699|      8|    if ((attr != NULL) && (ctxt->validate) && (ctxt->wellFormed) &&
  ------------------
  |  Branch (699:9): [True: 8, False: 0]
  |  Branch (699:27): [True: 0, False: 8]
  |  Branch (699:47): [True: 0, False: 0]
  ------------------
  700|      8|        (ctxt->myDoc->intSubset != NULL))
  ------------------
  |  Branch (700:9): [True: 0, False: 0]
  ------------------
  701|      0|	ctxt->valid &= xmlValidateAttributeDecl(&ctxt->vctxt, ctxt->myDoc,
  702|      0|	                                        attr);
  703|      8|#endif /* LIBXML_VALID_ENABLED */
  704|      8|    if (prefix != NULL)
  ------------------
  |  Branch (704:9): [True: 0, False: 8]
  ------------------
  705|      0|	xmlFree(prefix);
  706|      8|    if (name != NULL)
  ------------------
  |  Branch (706:9): [True: 8, False: 0]
  ------------------
  707|      8|	xmlFree(name);
  708|      8|}
xmlSAX2ElementDecl:
  722|     22|{
  723|     22|    xmlParserCtxtPtr ctxt = (xmlParserCtxtPtr) ctx;
  724|     22|    xmlElementPtr elem = NULL;
  725|       |
  726|       |    /* Avoid unused variable warning if features are disabled. */
  727|     22|    (void) elem;
  728|       |
  729|     22|    if ((ctxt == NULL) || (ctxt->myDoc == NULL))
  ------------------
  |  Branch (729:9): [True: 0, False: 22]
  |  Branch (729:27): [True: 0, False: 22]
  ------------------
  730|      0|        return;
  731|       |
  732|     22|    if (ctxt->inSubset == 1)
  ------------------
  |  Branch (732:9): [True: 22, False: 0]
  ------------------
  733|     22|        elem = xmlAddElementDecl(&ctxt->vctxt, ctxt->myDoc->intSubset,
  734|     22|                                 name, (xmlElementTypeVal) type, content);
  735|      0|    else if (ctxt->inSubset == 2)
  ------------------
  |  Branch (735:14): [True: 0, False: 0]
  ------------------
  736|      0|        elem = xmlAddElementDecl(&ctxt->vctxt, ctxt->myDoc->extSubset,
  737|      0|                                 name, (xmlElementTypeVal) type, content);
  738|      0|    else {
  739|      0|        xmlFatalErrMsg(ctxt, XML_ERR_INTERNAL_ERROR,
  740|      0|	     "SAX.xmlSAX2ElementDecl(%s) called while not in subset\n",
  741|      0|	               name, NULL);
  742|      0|        return;
  743|      0|    }
  744|     22|#ifdef LIBXML_VALID_ENABLED
  745|     22|    if (elem == NULL)
  ------------------
  |  Branch (745:9): [True: 0, False: 22]
  ------------------
  746|      0|        ctxt->valid = 0;
  747|     22|    if (ctxt->validate && ctxt->wellFormed &&
  ------------------
  |  Branch (747:9): [True: 0, False: 22]
  |  Branch (747:27): [True: 0, False: 0]
  ------------------
  748|     22|        ctxt->myDoc && ctxt->myDoc->intSubset)
  ------------------
  |  Branch (748:9): [True: 0, False: 0]
  |  Branch (748:24): [True: 0, False: 0]
  ------------------
  749|      0|        ctxt->valid &=
  750|      0|            xmlValidateElementDecl(&ctxt->vctxt, ctxt->myDoc, elem);
  751|     22|#endif /* LIBXML_VALID_ENABLED */
  752|     22|}
xmlSAX2SetDocumentLocator:
  877|    363|{
  878|    363|}
xmlSAX2StartDocument:
  888|    349|{
  889|    349|    xmlParserCtxtPtr ctxt = (xmlParserCtxtPtr) ctx;
  890|    349|    xmlDocPtr doc;
  891|       |
  892|    349|    if (ctx == NULL) return;
  ------------------
  |  Branch (892:9): [True: 0, False: 349]
  ------------------
  893|       |
  894|    349|    if (ctxt->html) {
  ------------------
  |  Branch (894:9): [True: 0, False: 349]
  ------------------
  895|      0|#ifdef LIBXML_HTML_ENABLED
  896|      0|	if (ctxt->myDoc == NULL)
  ------------------
  |  Branch (896:6): [True: 0, False: 0]
  ------------------
  897|      0|	    ctxt->myDoc = htmlNewDocNoDtD(NULL, NULL);
  898|      0|	if (ctxt->myDoc == NULL) {
  ------------------
  |  Branch (898:6): [True: 0, False: 0]
  ------------------
  899|      0|	    xmlSAX2ErrMemory(ctxt, "xmlSAX2StartDocument");
  900|      0|	    return;
  901|      0|	}
  902|      0|	ctxt->myDoc->properties = XML_DOC_HTML;
  903|      0|	ctxt->myDoc->parseFlags = ctxt->options;
  904|       |#else
  905|       |        xmlGenericError(xmlGenericErrorContext,
  906|       |		"libxml2 built without HTML support\n");
  907|       |	ctxt->errNo = XML_ERR_INTERNAL_ERROR;
  908|       |	ctxt->instate = XML_PARSER_EOF;
  909|       |	ctxt->disableSAX = 1;
  910|       |	return;
  911|       |#endif
  912|    349|    } else {
  913|    349|	doc = ctxt->myDoc = xmlNewDoc(ctxt->version);
  914|    349|	if (doc != NULL) {
  ------------------
  |  Branch (914:6): [True: 349, False: 0]
  ------------------
  915|    349|	    doc->properties = 0;
  916|    349|	    if (ctxt->options & XML_PARSE_OLD10)
  ------------------
  |  Branch (916:10): [True: 3, False: 346]
  ------------------
  917|      3|	        doc->properties |= XML_DOC_OLD10;
  918|    349|	    doc->parseFlags = ctxt->options;
  919|    349|	    doc->standalone = ctxt->standalone;
  920|    349|	} else {
  921|      0|	    xmlSAX2ErrMemory(ctxt, "xmlSAX2StartDocument");
  922|      0|	    return;
  923|      0|	}
  924|    349|	if ((ctxt->dictNames) && (doc != NULL)) {
  ------------------
  |  Branch (924:6): [True: 346, False: 3]
  |  Branch (924:27): [True: 346, False: 0]
  ------------------
  925|    346|	    doc->dict = ctxt->dict;
  926|    346|	    xmlDictReference(doc->dict);
  927|    346|	}
  928|    349|    }
  929|    349|    if ((ctxt->myDoc != NULL) && (ctxt->myDoc->URL == NULL) &&
  ------------------
  |  Branch (929:9): [True: 349, False: 0]
  |  Branch (929:34): [True: 349, False: 0]
  ------------------
  930|    349|	(ctxt->input != NULL) && (ctxt->input->filename != NULL)) {
  ------------------
  |  Branch (930:2): [True: 349, False: 0]
  |  Branch (930:27): [True: 189, False: 160]
  ------------------
  931|    189|	ctxt->myDoc->URL = xmlPathToURI((const xmlChar *)ctxt->input->filename);
  932|    189|	if (ctxt->myDoc->URL == NULL)
  ------------------
  |  Branch (932:6): [True: 0, False: 189]
  ------------------
  933|      0|	    xmlSAX2ErrMemory(ctxt, "xmlSAX2StartDocument");
  934|    189|    }
  935|    349|}
xmlSAX2EndDocument:
  945|    262|{
  946|    262|    xmlParserCtxtPtr ctxt = (xmlParserCtxtPtr) ctx;
  947|    262|    xmlDocPtr doc;
  948|       |
  949|    262|    if (ctx == NULL) return;
  ------------------
  |  Branch (949:9): [True: 0, False: 262]
  ------------------
  950|    262|#ifdef LIBXML_VALID_ENABLED
  951|    262|    if (ctxt->validate && ctxt->wellFormed &&
  ------------------
  |  Branch (951:9): [True: 0, False: 262]
  |  Branch (951:27): [True: 0, False: 0]
  ------------------
  952|    262|        ctxt->myDoc && ctxt->myDoc->intSubset)
  ------------------
  |  Branch (952:9): [True: 0, False: 0]
  |  Branch (952:24): [True: 0, False: 0]
  ------------------
  953|      0|	ctxt->valid &= xmlValidateDocumentFinal(&ctxt->vctxt, ctxt->myDoc);
  954|    262|#endif /* LIBXML_VALID_ENABLED */
  955|       |
  956|    262|    doc = ctxt->myDoc;
  957|    262|    if ((doc != NULL) && (doc->encoding == NULL)) {
  ------------------
  |  Branch (957:9): [True: 255, False: 7]
  |  Branch (957:26): [True: 255, False: 0]
  ------------------
  958|    255|        const xmlChar *encoding = NULL;
  959|       |
  960|    255|        if ((ctxt->input->flags & XML_INPUT_USES_ENC_DECL) ||
  ------------------
  |  |   26|    255|#define XML_INPUT_USES_ENC_DECL     (1u << 4)
  ------------------
  |  Branch (960:13): [True: 21, False: 234]
  ------------------
  961|    255|            (ctxt->input->flags & XML_INPUT_AUTO_ENCODING)) {
  ------------------
  |  |   21|    234|#define XML_INPUT_AUTO_ENCODING     (7u << 1)
  ------------------
  |  Branch (961:13): [True: 0, False: 234]
  ------------------
  962|       |            /* Preserve encoding exactly */
  963|     21|            encoding = ctxt->encoding;
  964|    234|        } else if ((ctxt->input->buf) && (ctxt->input->buf->encoder)) {
  ------------------
  |  Branch (964:20): [True: 208, False: 26]
  |  Branch (964:42): [True: 0, False: 208]
  ------------------
  965|      0|            encoding = BAD_CAST ctxt->input->buf->encoder->name;
  ------------------
  |  |   35|      0|#define BAD_CAST (xmlChar *)
  ------------------
  966|    234|        } else if (ctxt->input->flags & XML_INPUT_HAS_ENCODING) {
  ------------------
  |  |   20|    234|#define XML_INPUT_HAS_ENCODING      (1u << 0)
  ------------------
  |  Branch (966:20): [True: 0, False: 234]
  ------------------
  967|      0|            encoding = BAD_CAST "UTF-8";
  ------------------
  |  |   35|      0|#define BAD_CAST (xmlChar *)
  ------------------
  968|      0|        }
  969|       |
  970|    255|        if (encoding != NULL) {
  ------------------
  |  Branch (970:13): [True: 21, False: 234]
  ------------------
  971|     21|            doc->encoding = xmlStrdup(encoding);
  972|     21|            if (doc->encoding == NULL)
  ------------------
  |  Branch (972:17): [True: 0, False: 21]
  ------------------
  973|      0|                xmlSAX2ErrMemory(ctxt, "xmlSAX2EndDocument");
  974|     21|        }
  975|    255|    }
  976|    262|}
xmlSAX2StartElement:
 1525|      5|{
 1526|      5|    xmlParserCtxtPtr ctxt = (xmlParserCtxtPtr) ctx;
 1527|      5|    xmlNodePtr ret;
 1528|      5|    xmlNodePtr parent;
 1529|      5|    xmlNsPtr ns;
 1530|      5|    xmlChar *name;
 1531|      5|    xmlChar *prefix;
 1532|      5|    const xmlChar *att;
 1533|      5|    const xmlChar *value;
 1534|      5|    int i;
 1535|       |
 1536|      5|    if ((ctx == NULL) || (fullname == NULL) || (ctxt->myDoc == NULL)) return;
  ------------------
  |  Branch (1536:9): [True: 0, False: 5]
  |  Branch (1536:26): [True: 0, False: 5]
  |  Branch (1536:48): [True: 0, False: 5]
  ------------------
 1537|       |
 1538|       |    /*
 1539|       |     * First check on validity:
 1540|       |     */
 1541|      5|    if (ctxt->validate && (ctxt->myDoc->extSubset == NULL) &&
  ------------------
  |  Branch (1541:9): [True: 0, False: 5]
  |  Branch (1541:27): [True: 0, False: 0]
  ------------------
 1542|      5|        ((ctxt->myDoc->intSubset == NULL) ||
  ------------------
  |  Branch (1542:10): [True: 0, False: 0]
  ------------------
 1543|      0|	 ((ctxt->myDoc->intSubset->notations == NULL) &&
  ------------------
  |  Branch (1543:4): [True: 0, False: 0]
  ------------------
 1544|      0|	  (ctxt->myDoc->intSubset->elements == NULL) &&
  ------------------
  |  Branch (1544:4): [True: 0, False: 0]
  ------------------
 1545|      0|	  (ctxt->myDoc->intSubset->attributes == NULL) &&
  ------------------
  |  Branch (1545:4): [True: 0, False: 0]
  ------------------
 1546|      0|	  (ctxt->myDoc->intSubset->entities == NULL)))) {
  ------------------
  |  Branch (1546:4): [True: 0, False: 0]
  ------------------
 1547|      0|	xmlErrValid(ctxt, XML_ERR_NO_DTD,
 1548|      0|	  "Validation failed: no DTD found !", NULL, NULL);
 1549|      0|	ctxt->validate = 0;
 1550|      0|    }
 1551|       |
 1552|      5|    if (ctxt->html) {
  ------------------
  |  Branch (1552:9): [True: 0, False: 5]
  ------------------
 1553|      0|        prefix = NULL;
 1554|      0|        name = xmlStrdup(fullname);
 1555|      5|    } else {
 1556|       |        /*
 1557|       |         * Split the full name into a namespace prefix and the tag name
 1558|       |         */
 1559|      5|        name = xmlSplitQName(ctxt, fullname, &prefix);
 1560|      5|    }
 1561|       |
 1562|       |    /*
 1563|       |     * Note : the namespace resolution is deferred until the end of the
 1564|       |     *        attributes parsing, since local namespace can be defined as
 1565|       |     *        an attribute at this level.
 1566|       |     */
 1567|      5|    ret = xmlNewDocNodeEatName(ctxt->myDoc, NULL, name, NULL);
 1568|      5|    if (ret == NULL) {
  ------------------
  |  Branch (1568:9): [True: 0, False: 5]
  ------------------
 1569|      0|        if (prefix != NULL)
  ------------------
  |  Branch (1569:13): [True: 0, False: 0]
  ------------------
 1570|      0|	    xmlFree(prefix);
 1571|      0|	xmlSAX2ErrMemory(ctxt, "xmlSAX2StartElement");
 1572|      0|        return;
 1573|      0|    }
 1574|      5|    ctxt->nodemem = -1;
 1575|      5|    if (ctxt->linenumbers) {
  ------------------
  |  Branch (1575:9): [True: 5, False: 0]
  ------------------
 1576|      5|	if (ctxt->input != NULL) {
  ------------------
  |  Branch (1576:6): [True: 5, False: 0]
  ------------------
 1577|      5|	    if ((unsigned) ctxt->input->line < (unsigned) USHRT_MAX)
  ------------------
  |  Branch (1577:10): [True: 5, False: 0]
  ------------------
 1578|      5|		ret->line = ctxt->input->line;
 1579|      0|	    else
 1580|      0|	        ret->line = USHRT_MAX;
 1581|      5|	}
 1582|      5|    }
 1583|       |
 1584|       |    /* Initialize parent before pushing node */
 1585|      5|    parent = ctxt->node;
 1586|      5|    if (parent == NULL)
  ------------------
  |  Branch (1586:9): [True: 3, False: 2]
  ------------------
 1587|      3|        parent = (xmlNodePtr) ctxt->myDoc;
 1588|       |
 1589|       |    /*
 1590|       |     * We are parsing a new node.
 1591|       |     */
 1592|      5|    if (nodePush(ctxt, ret) < 0) {
  ------------------
  |  Branch (1592:9): [True: 0, False: 5]
  ------------------
 1593|      0|        xmlUnlinkNode(ret);
 1594|      0|        xmlFreeNode(ret);
 1595|      0|        if (prefix != NULL)
  ------------------
  |  Branch (1595:13): [True: 0, False: 0]
  ------------------
 1596|      0|            xmlFree(prefix);
 1597|      0|        return;
 1598|      0|    }
 1599|       |
 1600|       |    /*
 1601|       |     * Link the child element
 1602|       |     */
 1603|      5|    xmlAddChild(parent, ret);
 1604|       |
 1605|      5|    if (!ctxt->html) {
  ------------------
  |  Branch (1605:9): [True: 5, False: 0]
  ------------------
 1606|       |        /*
 1607|       |         * Insert all the defaulted attributes from the DTD especially
 1608|       |         * namespaces
 1609|       |         */
 1610|      5|        if ((ctxt->myDoc->intSubset != NULL) ||
  ------------------
  |  Branch (1610:13): [True: 0, False: 5]
  ------------------
 1611|      5|            (ctxt->myDoc->extSubset != NULL)) {
  ------------------
  |  Branch (1611:13): [True: 0, False: 5]
  ------------------
 1612|      0|            xmlCheckDefaultedAttributes(ctxt, name, prefix, atts);
 1613|      0|        }
 1614|       |
 1615|       |        /*
 1616|       |         * process all the attributes whose name start with "xmlns"
 1617|       |         */
 1618|      5|        if (atts != NULL) {
  ------------------
  |  Branch (1618:13): [True: 4, False: 1]
  ------------------
 1619|      4|            i = 0;
 1620|      4|            att = atts[i++];
 1621|      4|            value = atts[i++];
 1622|      8|	    while ((att != NULL) && (value != NULL)) {
  ------------------
  |  Branch (1622:13): [True: 4, False: 4]
  |  Branch (1622:30): [True: 4, False: 0]
  ------------------
 1623|      4|		if ((att[0] == 'x') && (att[1] == 'm') && (att[2] == 'l') &&
  ------------------
  |  Branch (1623:7): [True: 2, False: 2]
  |  Branch (1623:26): [True: 2, False: 0]
  |  Branch (1623:45): [True: 2, False: 0]
  ------------------
 1624|      4|		    (att[3] == 'n') && (att[4] == 's'))
  ------------------
  |  Branch (1624:7): [True: 2, False: 0]
  |  Branch (1624:26): [True: 2, False: 0]
  ------------------
 1625|      2|		    xmlSAX2AttributeInternal(ctxt, att, value, prefix);
 1626|       |
 1627|      4|		att = atts[i++];
 1628|      4|		value = atts[i++];
 1629|      4|	    }
 1630|      4|        }
 1631|       |
 1632|       |        /*
 1633|       |         * Search the namespace, note that since the attributes have been
 1634|       |         * processed, the local namespaces are available.
 1635|       |         */
 1636|      5|        ns = xmlSearchNs(ctxt->myDoc, ret, prefix);
 1637|      5|        if ((ns == NULL) && (parent != NULL))
  ------------------
  |  Branch (1637:13): [True: 3, False: 2]
  |  Branch (1637:29): [True: 3, False: 0]
  ------------------
 1638|      3|            ns = xmlSearchNs(ctxt->myDoc, parent, prefix);
 1639|      5|        if ((prefix != NULL) && (ns == NULL)) {
  ------------------
  |  Branch (1639:13): [True: 2, False: 3]
  |  Branch (1639:33): [True: 0, False: 2]
  ------------------
 1640|      0|            ns = xmlNewNs(ret, NULL, prefix);
 1641|      0|            xmlNsWarnMsg(ctxt, XML_NS_ERR_UNDEFINED_NAMESPACE,
 1642|      0|                         "Namespace prefix %s is not defined\n",
 1643|      0|                         prefix, NULL);
 1644|      0|        }
 1645|       |
 1646|       |        /*
 1647|       |         * set the namespace node, making sure that if the default namespace
 1648|       |         * is unbound on a parent we simply keep it NULL
 1649|       |         */
 1650|      5|        if ((ns != NULL) && (ns->href != NULL) &&
  ------------------
  |  Branch (1650:13): [True: 2, False: 3]
  |  Branch (1650:29): [True: 2, False: 0]
  ------------------
 1651|      5|            ((ns->href[0] != 0) || (ns->prefix != NULL)))
  ------------------
  |  Branch (1651:14): [True: 2, False: 0]
  |  Branch (1651:36): [True: 0, False: 0]
  ------------------
 1652|      2|            xmlSetNs(ret, ns);
 1653|      5|    }
 1654|       |
 1655|       |    /*
 1656|       |     * process all the other attributes
 1657|       |     */
 1658|      5|    if (atts != NULL) {
  ------------------
  |  Branch (1658:9): [True: 4, False: 1]
  ------------------
 1659|      4|        i = 0;
 1660|      4|	att = atts[i++];
 1661|      4|	value = atts[i++];
 1662|      4|	if (ctxt->html) {
  ------------------
  |  Branch (1662:6): [True: 0, False: 4]
  ------------------
 1663|      0|	    while (att != NULL) {
  ------------------
  |  Branch (1663:13): [True: 0, False: 0]
  ------------------
 1664|      0|		xmlSAX2AttributeInternal(ctxt, att, value, NULL);
 1665|      0|		att = atts[i++];
 1666|      0|		value = atts[i++];
 1667|      0|	    }
 1668|      4|	} else {
 1669|      8|	    while ((att != NULL) && (value != NULL)) {
  ------------------
  |  Branch (1669:13): [True: 4, False: 4]
  |  Branch (1669:30): [True: 4, False: 0]
  ------------------
 1670|      4|		if ((att[0] != 'x') || (att[1] != 'm') || (att[2] != 'l') ||
  ------------------
  |  Branch (1670:7): [True: 2, False: 2]
  |  Branch (1670:26): [True: 0, False: 2]
  |  Branch (1670:45): [True: 0, False: 2]
  ------------------
 1671|      4|		    (att[3] != 'n') || (att[4] != 's'))
  ------------------
  |  Branch (1671:7): [True: 0, False: 2]
  |  Branch (1671:26): [True: 0, False: 2]
  ------------------
 1672|      2|		    xmlSAX2AttributeInternal(ctxt, att, value, NULL);
 1673|       |
 1674|       |		/*
 1675|       |		 * Next ones
 1676|       |		 */
 1677|      4|		att = atts[i++];
 1678|      4|		value = atts[i++];
 1679|      4|	    }
 1680|      4|	}
 1681|      4|    }
 1682|       |
 1683|      5|#ifdef LIBXML_VALID_ENABLED
 1684|       |    /*
 1685|       |     * If it's the Document root, finish the DTD validation and
 1686|       |     * check the document root element for validity
 1687|       |     */
 1688|      5|    if ((ctxt->validate) &&
  ------------------
  |  Branch (1688:9): [True: 0, False: 5]
  ------------------
 1689|      5|        ((ctxt->vctxt.flags & XML_VCTXT_DTD_VALIDATED) == 0)) {
  ------------------
  |  |   12|      0|#define XML_VCTXT_DTD_VALIDATED (1u << 0)
  ------------------
  |  Branch (1689:9): [True: 0, False: 0]
  ------------------
 1690|      0|	int chk;
 1691|       |
 1692|      0|	chk = xmlValidateDtdFinal(&ctxt->vctxt, ctxt->myDoc);
 1693|      0|	if (chk <= 0)
  ------------------
  |  Branch (1693:6): [True: 0, False: 0]
  ------------------
 1694|      0|	    ctxt->valid = 0;
 1695|      0|	if (chk < 0)
  ------------------
  |  Branch (1695:6): [True: 0, False: 0]
  ------------------
 1696|      0|	    ctxt->wellFormed = 0;
 1697|      0|	ctxt->valid &= xmlValidateRoot(&ctxt->vctxt, ctxt->myDoc);
 1698|      0|	ctxt->vctxt.flags |= XML_VCTXT_DTD_VALIDATED;
  ------------------
  |  |   12|      0|#define XML_VCTXT_DTD_VALIDATED (1u << 0)
  ------------------
 1699|      0|    }
 1700|      5|#endif /* LIBXML_VALID_ENABLED */
 1701|       |
 1702|      5|    if (prefix != NULL)
  ------------------
  |  Branch (1702:9): [True: 2, False: 3]
  ------------------
 1703|      2|	xmlFree(prefix);
 1704|       |
 1705|      5|}
xmlSAX2EndElement:
 1716|      4|{
 1717|      4|    xmlParserCtxtPtr ctxt = (xmlParserCtxtPtr) ctx;
 1718|       |
 1719|      4|    if (ctx == NULL) return;
  ------------------
  |  Branch (1719:9): [True: 0, False: 4]
  ------------------
 1720|       |
 1721|      4|    ctxt->nodemem = -1;
 1722|       |
 1723|      4|#ifdef LIBXML_VALID_ENABLED
 1724|      4|    if (ctxt->validate && ctxt->wellFormed &&
  ------------------
  |  Branch (1724:9): [True: 0, False: 4]
  |  Branch (1724:27): [True: 0, False: 0]
  ------------------
 1725|      4|        ctxt->myDoc && ctxt->myDoc->intSubset)
  ------------------
  |  Branch (1725:9): [True: 0, False: 0]
  |  Branch (1725:24): [True: 0, False: 0]
  ------------------
 1726|      0|        ctxt->valid &= xmlValidateOneElement(&ctxt->vctxt, ctxt->myDoc,
 1727|      0|					     ctxt->node);
 1728|      4|#endif /* LIBXML_VALID_ENABLED */
 1729|       |
 1730|       |
 1731|       |    /*
 1732|       |     * end of parsing of this node.
 1733|       |     */
 1734|      4|    nodePop(ctxt);
 1735|      4|}
xmlSAX2StartElementNs:
 2087|  2.20k|{
 2088|  2.20k|    xmlParserCtxtPtr ctxt = (xmlParserCtxtPtr) ctx;
 2089|  2.20k|    xmlNodePtr ret;
 2090|  2.20k|    xmlNodePtr parent;
 2091|  2.20k|    xmlNsPtr last = NULL, ns;
 2092|  2.20k|    const xmlChar *uri, *pref;
 2093|  2.20k|    xmlChar *lname = NULL;
 2094|  2.20k|    int i, j;
 2095|       |
 2096|  2.20k|    if (ctx == NULL) return;
  ------------------
  |  Branch (2096:9): [True: 0, False: 2.20k]
  ------------------
 2097|       |    /*
 2098|       |     * First check on validity:
 2099|       |     */
 2100|  2.20k|    if (ctxt->validate && (ctxt->myDoc->extSubset == NULL) &&
  ------------------
  |  Branch (2100:9): [True: 0, False: 2.20k]
  |  Branch (2100:27): [True: 0, False: 0]
  ------------------
 2101|  2.20k|        ((ctxt->myDoc->intSubset == NULL) ||
  ------------------
  |  Branch (2101:10): [True: 0, False: 0]
  ------------------
 2102|      0|	 ((ctxt->myDoc->intSubset->notations == NULL) &&
  ------------------
  |  Branch (2102:4): [True: 0, False: 0]
  ------------------
 2103|      0|	  (ctxt->myDoc->intSubset->elements == NULL) &&
  ------------------
  |  Branch (2103:4): [True: 0, False: 0]
  ------------------
 2104|      0|	  (ctxt->myDoc->intSubset->attributes == NULL) &&
  ------------------
  |  Branch (2104:4): [True: 0, False: 0]
  ------------------
 2105|      0|	  (ctxt->myDoc->intSubset->entities == NULL)))) {
  ------------------
  |  Branch (2105:4): [True: 0, False: 0]
  ------------------
 2106|      0|	xmlErrValid(ctxt, XML_DTD_NO_DTD,
 2107|      0|	  "Validation failed: no DTD found !", NULL, NULL);
 2108|      0|	ctxt->validate = 0;
 2109|      0|    }
 2110|       |
 2111|       |    /*
 2112|       |     * Take care of the rare case of an undefined namespace prefix
 2113|       |     */
 2114|  2.20k|    if ((prefix != NULL) && (URI == NULL)) {
  ------------------
  |  Branch (2114:9): [True: 1.02k, False: 1.17k]
  |  Branch (2114:29): [True: 2, False: 1.02k]
  ------------------
 2115|      2|        if (ctxt->dictNames) {
  ------------------
  |  Branch (2115:13): [True: 2, False: 0]
  ------------------
 2116|      2|	    const xmlChar *fullname;
 2117|       |
 2118|      2|	    fullname = xmlDictQLookup(ctxt->dict, prefix, localname);
 2119|      2|	    if (fullname != NULL)
  ------------------
  |  Branch (2119:10): [True: 2, False: 0]
  ------------------
 2120|      2|	        localname = fullname;
 2121|      2|	} else {
 2122|      0|	    lname = xmlBuildQName(localname, prefix, NULL, 0);
 2123|      0|	}
 2124|      2|    }
 2125|       |    /*
 2126|       |     * allocate the node
 2127|       |     */
 2128|  2.20k|    if (ctxt->freeElems != NULL) {
  ------------------
  |  Branch (2128:9): [True: 26, False: 2.17k]
  ------------------
 2129|     26|        ret = ctxt->freeElems;
 2130|     26|	ctxt->freeElems = ret->next;
 2131|     26|	ctxt->freeElemsNr--;
 2132|     26|	memset(ret, 0, sizeof(xmlNode));
 2133|     26|        ret->doc = ctxt->myDoc;
 2134|     26|	ret->type = XML_ELEMENT_NODE;
 2135|       |
 2136|     26|	if (ctxt->dictNames)
  ------------------
  |  Branch (2136:6): [True: 26, False: 0]
  ------------------
 2137|     26|	    ret->name = localname;
 2138|      0|	else {
 2139|      0|	    if (lname == NULL)
  ------------------
  |  Branch (2139:10): [True: 0, False: 0]
  ------------------
 2140|      0|		ret->name = xmlStrdup(localname);
 2141|      0|	    else
 2142|      0|	        ret->name = lname;
 2143|      0|	    if (ret->name == NULL) {
  ------------------
  |  Branch (2143:10): [True: 0, False: 0]
  ------------------
 2144|      0|	        xmlSAX2ErrMemory(ctxt, "xmlSAX2StartElementNs");
 2145|      0|                xmlFree(ret);
 2146|      0|		return;
 2147|      0|	    }
 2148|      0|	}
 2149|     26|	if ((__xmlRegisterCallbacks) && (xmlRegisterNodeDefaultValue))
  ------------------
  |  |  682|      0|    XML_GLOBAL_MACRO(xmlRegisterNodeDefaultValue)
  |  |  ------------------
  |  |  |  |  500|      0|  #define XML_GLOBAL_MACRO(name) (*__##name())
  |  |  ------------------
  ------------------
  |  Branch (2149:6): [True: 0, False: 26]
  |  Branch (2149:34): [True: 0, False: 0]
  ------------------
 2150|      0|	    xmlRegisterNodeDefaultValue(ret);
  ------------------
  |  |  682|      0|    XML_GLOBAL_MACRO(xmlRegisterNodeDefaultValue)
  |  |  ------------------
  |  |  |  |  500|      0|  #define XML_GLOBAL_MACRO(name) (*__##name())
  |  |  ------------------
  ------------------
 2151|  2.17k|    } else {
 2152|  2.17k|	if (ctxt->dictNames)
  ------------------
  |  Branch (2152:6): [True: 2.17k, False: 0]
  ------------------
 2153|  2.17k|	    ret = xmlNewDocNodeEatName(ctxt->myDoc, NULL,
 2154|  2.17k|	                               (xmlChar *) localname, NULL);
 2155|      0|	else if (lname == NULL)
  ------------------
  |  Branch (2155:11): [True: 0, False: 0]
  ------------------
 2156|      0|	    ret = xmlNewDocNode(ctxt->myDoc, NULL, localname, NULL);
 2157|      0|	else
 2158|      0|	    ret = xmlNewDocNodeEatName(ctxt->myDoc, NULL,
 2159|      0|	                               (xmlChar *) lname, NULL);
 2160|  2.17k|	if (ret == NULL) {
  ------------------
  |  Branch (2160:6): [True: 0, False: 2.17k]
  ------------------
 2161|      0|	    xmlSAX2ErrMemory(ctxt, "xmlSAX2StartElementNs");
 2162|      0|	    return;
 2163|      0|	}
 2164|  2.17k|    }
 2165|  2.20k|    if (ctxt->linenumbers) {
  ------------------
  |  Branch (2165:9): [True: 2.20k, False: 0]
  ------------------
 2166|  2.20k|	if (ctxt->input != NULL) {
  ------------------
  |  Branch (2166:6): [True: 2.20k, False: 0]
  ------------------
 2167|  2.20k|	    if ((unsigned) ctxt->input->line < (unsigned) USHRT_MAX)
  ------------------
  |  Branch (2167:10): [True: 2.20k, False: 0]
  ------------------
 2168|  2.20k|		ret->line = ctxt->input->line;
 2169|      0|	    else
 2170|      0|	        ret->line = USHRT_MAX;
 2171|  2.20k|	}
 2172|  2.20k|    }
 2173|       |
 2174|       |    /*
 2175|       |     * Build the namespace list
 2176|       |     */
 2177|  2.46k|    for (i = 0,j = 0;j < nb_namespaces;j++) {
  ------------------
  |  Branch (2177:22): [True: 264, False: 2.20k]
  ------------------
 2178|    264|        pref = namespaces[i++];
 2179|    264|	uri = namespaces[i++];
 2180|    264|	ns = xmlNewNs(NULL, uri, pref);
 2181|    264|	if (ns != NULL) {
  ------------------
  |  Branch (2181:6): [True: 264, False: 0]
  ------------------
 2182|    264|	    if (last == NULL) {
  ------------------
  |  Branch (2182:10): [True: 260, False: 4]
  ------------------
 2183|    260|	        ret->nsDef = last = ns;
 2184|    260|	    } else {
 2185|      4|	        last->next = ns;
 2186|      4|		last = ns;
 2187|      4|	    }
 2188|    264|	    if ((URI != NULL) && (prefix == pref))
  ------------------
  |  Branch (2188:10): [True: 56, False: 208]
  |  Branch (2188:27): [True: 52, False: 4]
  ------------------
 2189|     52|		ret->ns = ns;
 2190|    264|	} else {
 2191|       |            /*
 2192|       |             * any out of memory error would already have been raised
 2193|       |             * but we can't be guaranteed it's the actual error due to the
 2194|       |             * API, best is to skip in this case
 2195|       |             */
 2196|      0|	    continue;
 2197|      0|	}
 2198|       |
 2199|    264|        xmlParserNsUpdateSax(ctxt, pref, ns);
 2200|       |
 2201|    264|#ifdef LIBXML_VALID_ENABLED
 2202|    264|	if ((!ctxt->html) && ctxt->validate && ctxt->wellFormed &&
  ------------------
  |  Branch (2202:6): [True: 264, False: 0]
  |  Branch (2202:23): [True: 0, False: 264]
  |  Branch (2202:41): [True: 0, False: 0]
  ------------------
 2203|    264|	    ctxt->myDoc && ctxt->myDoc->intSubset) {
  ------------------
  |  Branch (2203:6): [True: 0, False: 0]
  |  Branch (2203:21): [True: 0, False: 0]
  ------------------
 2204|      0|	    ctxt->valid &= xmlValidateOneNamespace(&ctxt->vctxt, ctxt->myDoc,
 2205|      0|	                                           ret, prefix, ns, uri);
 2206|      0|	}
 2207|    264|#endif /* LIBXML_VALID_ENABLED */
 2208|    264|    }
 2209|  2.20k|    ctxt->nodemem = -1;
 2210|       |
 2211|       |    /* Initialize parent before pushing node */
 2212|  2.20k|    parent = ctxt->node;
 2213|  2.20k|    if (parent == NULL)
  ------------------
  |  Branch (2213:9): [True: 272, False: 1.93k]
  ------------------
 2214|    272|        parent = (xmlNodePtr) ctxt->myDoc;
 2215|       |
 2216|       |    /*
 2217|       |     * We are parsing a new node.
 2218|       |     */
 2219|  2.20k|    if (nodePush(ctxt, ret) < 0) {
  ------------------
  |  Branch (2219:9): [True: 0, False: 2.20k]
  ------------------
 2220|      0|        xmlUnlinkNode(ret);
 2221|      0|        xmlFreeNode(ret);
 2222|      0|        return;
 2223|      0|    }
 2224|       |
 2225|       |    /*
 2226|       |     * Link the child element
 2227|       |     */
 2228|  2.20k|    xmlAddChild(parent, ret);
 2229|       |
 2230|       |    /*
 2231|       |     * Insert the defaulted attributes from the DTD only if requested:
 2232|       |     */
 2233|  2.20k|    if ((nb_defaulted != 0) &&
  ------------------
  |  Branch (2233:9): [True: 0, False: 2.20k]
  ------------------
 2234|  2.20k|        ((ctxt->loadsubset & XML_COMPLETE_ATTRS) == 0))
  ------------------
  |  |  150|      0|#define XML_COMPLETE_ATTRS	4
  ------------------
  |  Branch (2234:9): [True: 0, False: 0]
  ------------------
 2235|      0|	nb_attributes -= nb_defaulted;
 2236|       |
 2237|       |    /*
 2238|       |     * Search the namespace if it wasn't already found
 2239|       |     * Note that, if prefix is NULL, this searches for the default Ns
 2240|       |     */
 2241|  2.20k|    if ((URI != NULL) && (ret->ns == NULL)) {
  ------------------
  |  Branch (2241:9): [True: 1.02k, False: 1.17k]
  |  Branch (2241:26): [True: 974, False: 52]
  ------------------
 2242|    974|        ret->ns = xmlParserNsLookupSax(ctxt, prefix);
 2243|    974|	if ((ret->ns == NULL) && (xmlStrEqual(prefix, BAD_CAST "xml"))) {
  ------------------
  |  |   35|      0|#define BAD_CAST (xmlChar *)
  ------------------
  |  Branch (2243:6): [True: 0, False: 974]
  |  Branch (2243:27): [True: 0, False: 0]
  ------------------
 2244|      0|	    ret->ns = xmlSearchNs(ctxt->myDoc, ret, prefix);
 2245|      0|	}
 2246|    974|	if (ret->ns == NULL) {
  ------------------
  |  Branch (2246:6): [True: 0, False: 974]
  ------------------
 2247|      0|	    ns = xmlNewNs(ret, NULL, prefix);
 2248|      0|	    if (ns == NULL) {
  ------------------
  |  Branch (2248:10): [True: 0, False: 0]
  ------------------
 2249|       |
 2250|      0|	        xmlSAX2ErrMemory(ctxt, "xmlSAX2StartElementNs");
 2251|      0|		return;
 2252|      0|	    }
 2253|      0|            if (prefix != NULL)
  ------------------
  |  Branch (2253:17): [True: 0, False: 0]
  ------------------
 2254|      0|                xmlNsWarnMsg(ctxt, XML_NS_ERR_UNDEFINED_NAMESPACE,
 2255|      0|                             "Namespace prefix %s was not found\n",
 2256|      0|                             prefix, NULL);
 2257|      0|            else
 2258|      0|                xmlNsWarnMsg(ctxt, XML_NS_ERR_UNDEFINED_NAMESPACE,
 2259|      0|                             "Namespace default prefix was not found\n",
 2260|      0|                             NULL, NULL);
 2261|      0|	}
 2262|    974|    }
 2263|       |
 2264|       |    /*
 2265|       |     * process all the other attributes
 2266|       |     */
 2267|  2.20k|    if (nb_attributes > 0) {
  ------------------
  |  Branch (2267:9): [True: 916, False: 1.28k]
  ------------------
 2268|    916|        xmlAttrPtr prev = NULL;
 2269|       |
 2270|  1.85k|        for (j = 0,i = 0;i < nb_attributes;i++,j+=5) {
  ------------------
  |  Branch (2270:26): [True: 940, False: 916]
  ------------------
 2271|    940|            xmlAttrPtr attr = NULL;
 2272|       |
 2273|       |	    /*
 2274|       |	     * Handle the rare case of an undefined attribute prefix
 2275|       |	     */
 2276|    940|	    if ((attributes[j+1] != NULL) && (attributes[j+2] == NULL)) {
  ------------------
  |  Branch (2276:10): [True: 12, False: 928]
  |  Branch (2276:39): [True: 0, False: 12]
  ------------------
 2277|      0|		if (ctxt->dictNames) {
  ------------------
  |  Branch (2277:7): [True: 0, False: 0]
  ------------------
 2278|      0|		    const xmlChar *fullname;
 2279|       |
 2280|      0|		    fullname = xmlDictQLookup(ctxt->dict, attributes[j+1],
 2281|      0|		                              attributes[j]);
 2282|      0|		    if (fullname != NULL) {
  ------------------
  |  Branch (2282:11): [True: 0, False: 0]
  ------------------
 2283|      0|                        attr = xmlSAX2AttributeNs(ctxt, fullname, NULL,
 2284|      0|                                                  attributes[j+3],
 2285|      0|                                                  attributes[j+4]);
 2286|      0|                        goto have_attr;
 2287|      0|		    }
 2288|      0|		} else {
 2289|      0|		    lname = xmlBuildQName(attributes[j], attributes[j+1],
 2290|      0|		                          NULL, 0);
 2291|      0|		    if (lname != NULL) {
  ------------------
  |  Branch (2291:11): [True: 0, False: 0]
  ------------------
 2292|      0|                        attr = xmlSAX2AttributeNs(ctxt, lname, NULL,
 2293|      0|                                                  attributes[j+3],
 2294|      0|                                                  attributes[j+4]);
 2295|      0|			xmlFree(lname);
 2296|      0|                        goto have_attr;
 2297|      0|		    }
 2298|      0|		}
 2299|      0|	    }
 2300|    940|            attr = xmlSAX2AttributeNs(ctxt, attributes[j], attributes[j+1],
 2301|    940|                                      attributes[j+3], attributes[j+4]);
 2302|    940|have_attr:
 2303|    940|            if (attr == NULL)
  ------------------
  |  Branch (2303:17): [True: 0, False: 940]
  ------------------
 2304|      0|                continue;
 2305|       |
 2306|       |            /* link at the end to preserve order */
 2307|    940|            if (prev == NULL) {
  ------------------
  |  Branch (2307:17): [True: 916, False: 24]
  ------------------
 2308|    916|                ctxt->node->properties = attr;
 2309|    916|            } else {
 2310|     24|                prev->next = attr;
 2311|     24|                attr->prev = prev;
 2312|     24|            }
 2313|       |
 2314|    940|            prev = attr;
 2315|    940|	}
 2316|    916|    }
 2317|       |
 2318|  2.20k|#ifdef LIBXML_VALID_ENABLED
 2319|       |    /*
 2320|       |     * If it's the Document root, finish the DTD validation and
 2321|       |     * check the document root element for validity
 2322|       |     */
 2323|  2.20k|    if ((ctxt->validate) &&
  ------------------
  |  Branch (2323:9): [True: 0, False: 2.20k]
  ------------------
 2324|  2.20k|        ((ctxt->vctxt.flags & XML_VCTXT_DTD_VALIDATED) == 0)) {
  ------------------
  |  |   12|      0|#define XML_VCTXT_DTD_VALIDATED (1u << 0)
  ------------------
  |  Branch (2324:9): [True: 0, False: 0]
  ------------------
 2325|      0|	int chk;
 2326|       |
 2327|      0|	chk = xmlValidateDtdFinal(&ctxt->vctxt, ctxt->myDoc);
 2328|      0|	if (chk <= 0)
  ------------------
  |  Branch (2328:6): [True: 0, False: 0]
  ------------------
 2329|      0|	    ctxt->valid = 0;
 2330|      0|	if (chk < 0)
  ------------------
  |  Branch (2330:6): [True: 0, False: 0]
  ------------------
 2331|      0|	    ctxt->wellFormed = 0;
 2332|      0|	ctxt->valid &= xmlValidateRoot(&ctxt->vctxt, ctxt->myDoc);
 2333|      0|	ctxt->vctxt.flags |= XML_VCTXT_DTD_VALIDATED;
  ------------------
  |  |   12|      0|#define XML_VCTXT_DTD_VALIDATED (1u << 0)
  ------------------
 2334|      0|    }
 2335|  2.20k|#endif /* LIBXML_VALID_ENABLED */
 2336|  2.20k|}
xmlSAX2EndElementNs:
 2353|  1.88k|{
 2354|  1.88k|    xmlParserCtxtPtr ctxt = (xmlParserCtxtPtr) ctx;
 2355|       |
 2356|  1.88k|    if (ctx == NULL) return;
  ------------------
  |  Branch (2356:9): [True: 0, False: 1.88k]
  ------------------
 2357|  1.88k|    ctxt->nodemem = -1;
 2358|       |
 2359|  1.88k|#ifdef LIBXML_VALID_ENABLED
 2360|  1.88k|    if (ctxt->validate && ctxt->wellFormed &&
  ------------------
  |  Branch (2360:9): [True: 0, False: 1.88k]
  |  Branch (2360:27): [True: 0, False: 0]
  ------------------
 2361|  1.88k|        ctxt->myDoc && ctxt->myDoc->intSubset)
  ------------------
  |  Branch (2361:9): [True: 0, False: 0]
  |  Branch (2361:24): [True: 0, False: 0]
  ------------------
 2362|      0|        ctxt->valid &= xmlValidateOneElement(&ctxt->vctxt, ctxt->myDoc,
 2363|      0|                                             ctxt->node);
 2364|  1.88k|#endif /* LIBXML_VALID_ENABLED */
 2365|       |
 2366|       |    /*
 2367|       |     * end of parsing of this node.
 2368|       |     */
 2369|  1.88k|    nodePop(ctxt);
 2370|  1.88k|}
xmlSAX2Characters:
 2541|  1.86k|{
 2542|  1.86k|    xmlSAX2Text((xmlParserCtxtPtr) ctx, ch, len, XML_TEXT_NODE);
 2543|  1.86k|}
xmlSAX2IgnorableWhitespace:
 2556|      8|{
 2557|      8|}
xmlSAX2ProcessingInstruction:
 2570|      2|{
 2571|      2|    xmlParserCtxtPtr ctxt = (xmlParserCtxtPtr) ctx;
 2572|      2|    xmlNodePtr ret;
 2573|      2|    xmlNodePtr parent;
 2574|       |
 2575|      2|    if (ctx == NULL) return;
  ------------------
  |  Branch (2575:9): [True: 0, False: 2]
  ------------------
 2576|      2|    parent = ctxt->node;
 2577|       |
 2578|      2|    ret = xmlNewDocPI(ctxt->myDoc, target, data);
 2579|      2|    if (ret == NULL) return;
  ------------------
  |  Branch (2579:9): [True: 0, False: 2]
  ------------------
 2580|       |
 2581|      2|    if (ctxt->linenumbers) {
  ------------------
  |  Branch (2581:9): [True: 2, False: 0]
  ------------------
 2582|      2|	if (ctxt->input != NULL) {
  ------------------
  |  Branch (2582:6): [True: 2, False: 0]
  ------------------
 2583|      2|	    if ((unsigned) ctxt->input->line < (unsigned) USHRT_MAX)
  ------------------
  |  Branch (2583:10): [True: 2, False: 0]
  ------------------
 2584|      2|		ret->line = ctxt->input->line;
 2585|      0|	    else
 2586|      0|	        ret->line = USHRT_MAX;
 2587|      2|	}
 2588|      2|    }
 2589|      2|    if (ctxt->inSubset == 1) {
  ------------------
  |  Branch (2589:9): [True: 0, False: 2]
  ------------------
 2590|      0|	xmlAddChild((xmlNodePtr) ctxt->myDoc->intSubset, ret);
 2591|      0|	return;
 2592|      2|    } else if (ctxt->inSubset == 2) {
  ------------------
  |  Branch (2592:16): [True: 0, False: 2]
  ------------------
 2593|      0|	xmlAddChild((xmlNodePtr) ctxt->myDoc->extSubset, ret);
 2594|      0|	return;
 2595|      0|    }
 2596|      2|    if (parent == NULL) {
  ------------------
  |  Branch (2596:9): [True: 2, False: 0]
  ------------------
 2597|      2|        xmlAddChild((xmlNodePtr) ctxt->myDoc, (xmlNodePtr) ret);
 2598|      2|	return;
 2599|      2|    }
 2600|      0|    if (parent->type == XML_ELEMENT_NODE) {
  ------------------
  |  Branch (2600:9): [True: 0, False: 0]
  ------------------
 2601|      0|	xmlAddChild(parent, ret);
 2602|      0|    } else {
 2603|      0|	xmlAddSibling(parent, ret);
 2604|      0|    }
 2605|      0|}
xmlSAX2Comment:
 2616|     38|{
 2617|     38|    xmlParserCtxtPtr ctxt = (xmlParserCtxtPtr) ctx;
 2618|     38|    xmlNodePtr ret;
 2619|     38|    xmlNodePtr parent;
 2620|       |
 2621|     38|    if (ctx == NULL) return;
  ------------------
  |  Branch (2621:9): [True: 0, False: 38]
  ------------------
 2622|     38|    parent = ctxt->node;
 2623|     38|    ret = xmlNewDocComment(ctxt->myDoc, value);
 2624|     38|    if (ret == NULL) return;
  ------------------
  |  Branch (2624:9): [True: 0, False: 38]
  ------------------
 2625|     38|    if (ctxt->linenumbers) {
  ------------------
  |  Branch (2625:9): [True: 38, False: 0]
  ------------------
 2626|     38|	if (ctxt->input != NULL) {
  ------------------
  |  Branch (2626:6): [True: 38, False: 0]
  ------------------
 2627|     38|	    if ((unsigned) ctxt->input->line < (unsigned) USHRT_MAX)
  ------------------
  |  Branch (2627:10): [True: 38, False: 0]
  ------------------
 2628|     38|		ret->line = ctxt->input->line;
 2629|      0|	    else
 2630|      0|	        ret->line = USHRT_MAX;
 2631|     38|	}
 2632|     38|    }
 2633|       |
 2634|     38|    if (ctxt->inSubset == 1) {
  ------------------
  |  Branch (2634:9): [True: 0, False: 38]
  ------------------
 2635|      0|	xmlAddChild((xmlNodePtr) ctxt->myDoc->intSubset, ret);
 2636|      0|	return;
 2637|     38|    } else if (ctxt->inSubset == 2) {
  ------------------
  |  Branch (2637:16): [True: 0, False: 38]
  ------------------
 2638|      0|	xmlAddChild((xmlNodePtr) ctxt->myDoc->extSubset, ret);
 2639|      0|	return;
 2640|      0|    }
 2641|     38|    if (parent == NULL) {
  ------------------
  |  Branch (2641:9): [True: 0, False: 38]
  ------------------
 2642|      0|        xmlAddChild((xmlNodePtr) ctxt->myDoc, (xmlNodePtr) ret);
 2643|      0|	return;
 2644|      0|    }
 2645|     38|    if (parent->type == XML_ELEMENT_NODE) {
  ------------------
  |  Branch (2645:9): [True: 38, False: 0]
  ------------------
 2646|     38|	xmlAddChild(parent, ret);
 2647|     38|    } else {
 2648|      0|	xmlAddSibling(parent, ret);
 2649|      0|    }
 2650|     38|}
xmlSAXVersion:
 2706|    621|{
 2707|    621|    if (hdlr == NULL) return(-1);
  ------------------
  |  Branch (2707:9): [True: 0, False: 621]
  ------------------
 2708|    621|    if (version == 2) {
  ------------------
  |  Branch (2708:9): [True: 621, False: 0]
  ------------------
 2709|    621|	hdlr->startElementNs = xmlSAX2StartElementNs;
 2710|    621|	hdlr->endElementNs = xmlSAX2EndElementNs;
 2711|    621|	hdlr->serror = NULL;
 2712|    621|	hdlr->initialized = XML_SAX2_MAGIC;
  ------------------
  |  |  685|    621|#define XML_SAX2_MAGIC 0xDEEDBEAF
  ------------------
 2713|    621|#ifdef LIBXML_SAX1_ENABLED
 2714|    621|    } else if (version == 1) {
  ------------------
  |  Branch (2714:16): [True: 0, False: 0]
  ------------------
 2715|      0|	hdlr->initialized = 1;
 2716|      0|#endif /* LIBXML_SAX1_ENABLED */
 2717|      0|    } else
 2718|      0|        return(-1);
 2719|    621|#ifdef LIBXML_SAX1_ENABLED
 2720|    621|    hdlr->startElement = xmlSAX2StartElement;
 2721|    621|    hdlr->endElement = xmlSAX2EndElement;
 2722|       |#else
 2723|       |    hdlr->startElement = NULL;
 2724|       |    hdlr->endElement = NULL;
 2725|       |#endif /* LIBXML_SAX1_ENABLED */
 2726|    621|    hdlr->internalSubset = xmlSAX2InternalSubset;
 2727|    621|    hdlr->externalSubset = xmlSAX2ExternalSubset;
 2728|    621|    hdlr->isStandalone = xmlSAX2IsStandalone;
 2729|    621|    hdlr->hasInternalSubset = xmlSAX2HasInternalSubset;
 2730|    621|    hdlr->hasExternalSubset = xmlSAX2HasExternalSubset;
 2731|    621|    hdlr->resolveEntity = xmlSAX2ResolveEntity;
 2732|    621|    hdlr->getEntity = xmlSAX2GetEntity;
 2733|    621|    hdlr->getParameterEntity = xmlSAX2GetParameterEntity;
 2734|    621|    hdlr->entityDecl = xmlSAX2EntityDecl;
 2735|    621|    hdlr->attributeDecl = xmlSAX2AttributeDecl;
 2736|    621|    hdlr->elementDecl = xmlSAX2ElementDecl;
 2737|    621|    hdlr->notationDecl = xmlSAX2NotationDecl;
 2738|    621|    hdlr->unparsedEntityDecl = xmlSAX2UnparsedEntityDecl;
 2739|    621|    hdlr->setDocumentLocator = xmlSAX2SetDocumentLocator;
 2740|    621|    hdlr->startDocument = xmlSAX2StartDocument;
 2741|    621|    hdlr->endDocument = xmlSAX2EndDocument;
 2742|    621|    hdlr->reference = xmlSAX2Reference;
 2743|    621|    hdlr->characters = xmlSAX2Characters;
 2744|    621|    hdlr->cdataBlock = xmlSAX2CDataBlock;
 2745|    621|    hdlr->ignorableWhitespace = xmlSAX2Characters;
 2746|    621|    hdlr->processingInstruction = xmlSAX2ProcessingInstruction;
 2747|    621|    hdlr->comment = xmlSAX2Comment;
 2748|    621|    hdlr->warning = xmlParserWarning;
 2749|    621|    hdlr->error = xmlParserError;
 2750|    621|    hdlr->fatalError = xmlParserError;
 2751|       |
 2752|    621|    return(0);
 2753|    621|}
SAX2.c:xmlSAX2AttributeInternal:
 1019|      4|{
 1020|      4|    xmlParserCtxtPtr ctxt = (xmlParserCtxtPtr) ctx;
 1021|      4|    xmlAttrPtr ret;
 1022|      4|    xmlChar *name;
 1023|      4|    xmlChar *ns;
 1024|      4|    xmlChar *nval;
 1025|      4|    xmlNsPtr namespace;
 1026|       |
 1027|      4|    if (ctxt->html) {
  ------------------
  |  Branch (1027:9): [True: 0, False: 4]
  ------------------
 1028|      0|	name = xmlStrdup(fullname);
 1029|      0|	ns = NULL;
 1030|      0|	namespace = NULL;
 1031|      4|    } else {
 1032|       |	/*
 1033|       |	 * Split the full name into a namespace prefix and the tag name
 1034|       |	 */
 1035|      4|	name = xmlSplitQName(ctxt, fullname, &ns);
 1036|      4|	if ((name != NULL) && (name[0] == 0)) {
  ------------------
  |  Branch (1036:6): [True: 4, False: 0]
  |  Branch (1036:24): [True: 0, False: 4]
  ------------------
 1037|      0|	    if (xmlStrEqual(ns, BAD_CAST "xmlns")) {
  ------------------
  |  |   35|      0|#define BAD_CAST (xmlChar *)
  ------------------
  |  Branch (1037:10): [True: 0, False: 0]
  ------------------
 1038|      0|		xmlNsErrMsg(ctxt, XML_ERR_NS_DECL_ERROR,
 1039|      0|			    "invalid namespace declaration '%s'\n",
 1040|      0|			    fullname, NULL);
 1041|      0|	    } else {
 1042|      0|		xmlNsWarnMsg(ctxt, XML_WAR_NS_COLUMN,
 1043|      0|			     "Avoid attribute ending with ':' like '%s'\n",
 1044|      0|			     fullname, NULL);
 1045|      0|	    }
 1046|      0|	    if (ns != NULL)
  ------------------
  |  Branch (1046:10): [True: 0, False: 0]
  ------------------
 1047|      0|		xmlFree(ns);
 1048|      0|	    ns = NULL;
 1049|      0|	    xmlFree(name);
 1050|      0|	    name = xmlStrdup(fullname);
 1051|      0|	}
 1052|      4|    }
 1053|      4|    if (name == NULL) {
  ------------------
  |  Branch (1053:9): [True: 0, False: 4]
  ------------------
 1054|      0|        xmlSAX2ErrMemory(ctxt, "xmlSAX2StartElement");
 1055|      0|	if (ns != NULL)
  ------------------
  |  Branch (1055:6): [True: 0, False: 0]
  ------------------
 1056|      0|	    xmlFree(ns);
 1057|      0|	return;
 1058|      0|    }
 1059|       |
 1060|      4|#ifdef LIBXML_HTML_ENABLED
 1061|      4|    if ((ctxt->html) &&
  ------------------
  |  Branch (1061:9): [True: 0, False: 4]
  ------------------
 1062|      4|        (value == NULL) && (htmlIsBooleanAttr(fullname))) {
  ------------------
  |  Branch (1062:9): [True: 0, False: 0]
  |  Branch (1062:28): [True: 0, False: 0]
  ------------------
 1063|      0|            nval = xmlStrdup(fullname);
 1064|      0|            value = (const xmlChar *) nval;
 1065|      0|    } else
 1066|      4|#endif
 1067|      4|    {
 1068|      4|#ifdef LIBXML_VALID_ENABLED
 1069|       |        /*
 1070|       |         * Do the last stage of the attribute normalization
 1071|       |         * Needed for HTML too:
 1072|       |         *   http://www.w3.org/TR/html4/types.html#h-6.2
 1073|       |         */
 1074|      4|        ctxt->vctxt.valid = 1;
 1075|      4|        nval = xmlValidCtxtNormalizeAttributeValue(&ctxt->vctxt,
 1076|      4|                                               ctxt->myDoc, ctxt->node,
 1077|      4|                                               fullname, value);
 1078|      4|        if (ctxt->vctxt.valid != 1) {
  ------------------
  |  Branch (1078:13): [True: 0, False: 4]
  ------------------
 1079|      0|            ctxt->valid = 0;
 1080|      0|        }
 1081|      4|        if (nval != NULL)
  ------------------
  |  Branch (1081:13): [True: 0, False: 4]
  ------------------
 1082|      0|            value = nval;
 1083|       |#else
 1084|       |        nval = NULL;
 1085|       |#endif /* LIBXML_VALID_ENABLED */
 1086|      4|    }
 1087|       |
 1088|       |    /*
 1089|       |     * Check whether it's a namespace definition
 1090|       |     */
 1091|      4|    if ((!ctxt->html) && (ns == NULL) &&
  ------------------
  |  Branch (1091:9): [True: 4, False: 0]
  |  Branch (1091:26): [True: 2, False: 2]
  ------------------
 1092|      4|        (name[0] == 'x') && (name[1] == 'm') && (name[2] == 'l') &&
  ------------------
  |  Branch (1092:9): [True: 0, False: 2]
  |  Branch (1092:29): [True: 0, False: 0]
  |  Branch (1092:49): [True: 0, False: 0]
  ------------------
 1093|      4|        (name[3] == 'n') && (name[4] == 's') && (name[5] == 0)) {
  ------------------
  |  Branch (1093:9): [True: 0, False: 0]
  |  Branch (1093:29): [True: 0, False: 0]
  |  Branch (1093:49): [True: 0, False: 0]
  ------------------
 1094|      0|	xmlNsPtr nsret;
 1095|      0|	xmlChar *val;
 1096|       |
 1097|       |        /* Avoid unused variable warning if features are disabled. */
 1098|      0|        (void) nsret;
 1099|       |
 1100|      0|        if (!ctxt->replaceEntities) {
  ------------------
  |  Branch (1100:13): [True: 0, False: 0]
  ------------------
 1101|      0|	    ctxt->depth++;
 1102|      0|	    val = xmlStringDecodeEntities(ctxt, value, XML_SUBSTITUTE_REF,
  ------------------
  |  |  521|      0|#define XML_SUBSTITUTE_REF	1
  ------------------
 1103|      0|		                          0,0,0);
 1104|      0|	    ctxt->depth--;
 1105|      0|	    if (val == NULL) {
  ------------------
  |  Branch (1105:10): [True: 0, False: 0]
  ------------------
 1106|      0|	        xmlSAX2ErrMemory(ctxt, "xmlSAX2StartElement");
 1107|      0|		if (name != NULL)
  ------------------
  |  Branch (1107:7): [True: 0, False: 0]
  ------------------
 1108|      0|		    xmlFree(name);
 1109|      0|                if (nval != NULL)
  ------------------
  |  Branch (1109:21): [True: 0, False: 0]
  ------------------
 1110|      0|                    xmlFree(nval);
 1111|      0|		return;
 1112|      0|	    }
 1113|      0|	} else {
 1114|      0|	    val = (xmlChar *) value;
 1115|      0|	}
 1116|       |
 1117|      0|	if (val[0] != 0) {
  ------------------
  |  Branch (1117:6): [True: 0, False: 0]
  ------------------
 1118|      0|	    xmlURIPtr uri;
 1119|       |
 1120|      0|	    uri = xmlParseURI((const char *)val);
 1121|      0|	    if (uri == NULL) {
  ------------------
  |  Branch (1121:10): [True: 0, False: 0]
  ------------------
 1122|      0|		if ((ctxt->sax != NULL) && (ctxt->sax->warning != NULL))
  ------------------
  |  Branch (1122:7): [True: 0, False: 0]
  |  Branch (1122:30): [True: 0, False: 0]
  ------------------
 1123|      0|		    ctxt->sax->warning(ctxt->userData,
 1124|      0|			 "xmlns: %s not a valid URI\n", val);
 1125|      0|	    } else {
 1126|      0|		if (uri->scheme == NULL) {
  ------------------
  |  Branch (1126:7): [True: 0, False: 0]
  ------------------
 1127|      0|		    if ((ctxt->sax != NULL) && (ctxt->sax->warning != NULL))
  ------------------
  |  Branch (1127:11): [True: 0, False: 0]
  |  Branch (1127:34): [True: 0, False: 0]
  ------------------
 1128|      0|			ctxt->sax->warning(ctxt->userData,
 1129|      0|			     "xmlns: URI %s is not absolute\n", val);
 1130|      0|		}
 1131|      0|		xmlFreeURI(uri);
 1132|      0|	    }
 1133|      0|	}
 1134|       |
 1135|       |	/* a default namespace definition */
 1136|      0|	nsret = xmlNewNs(ctxt->node, val, NULL);
 1137|       |
 1138|      0|#ifdef LIBXML_VALID_ENABLED
 1139|       |	/*
 1140|       |	 * Validate also for namespace decls, they are attributes from
 1141|       |	 * an XML-1.0 perspective
 1142|       |	 */
 1143|      0|        if (nsret != NULL && ctxt->validate && ctxt->wellFormed &&
  ------------------
  |  Branch (1143:13): [True: 0, False: 0]
  |  Branch (1143:30): [True: 0, False: 0]
  |  Branch (1143:48): [True: 0, False: 0]
  ------------------
 1144|      0|	    ctxt->myDoc && ctxt->myDoc->intSubset)
  ------------------
  |  Branch (1144:6): [True: 0, False: 0]
  |  Branch (1144:21): [True: 0, False: 0]
  ------------------
 1145|      0|	    ctxt->valid &= xmlValidateOneNamespace(&ctxt->vctxt, ctxt->myDoc,
 1146|      0|					   ctxt->node, prefix, nsret, val);
 1147|      0|#endif /* LIBXML_VALID_ENABLED */
 1148|      0|	if (name != NULL)
  ------------------
  |  Branch (1148:6): [True: 0, False: 0]
  ------------------
 1149|      0|	    xmlFree(name);
 1150|      0|	if (nval != NULL)
  ------------------
  |  Branch (1150:6): [True: 0, False: 0]
  ------------------
 1151|      0|	    xmlFree(nval);
 1152|      0|	if (val != value)
  ------------------
  |  Branch (1152:6): [True: 0, False: 0]
  ------------------
 1153|      0|	    xmlFree(val);
 1154|      0|	return;
 1155|      0|    }
 1156|      4|    if ((!ctxt->html) &&
  ------------------
  |  Branch (1156:9): [True: 4, False: 0]
  ------------------
 1157|      4|	(ns != NULL) && (ns[0] == 'x') && (ns[1] == 'm') && (ns[2] == 'l') &&
  ------------------
  |  Branch (1157:2): [True: 2, False: 2]
  |  Branch (1157:18): [True: 2, False: 0]
  |  Branch (1157:36): [True: 2, False: 0]
  |  Branch (1157:54): [True: 2, False: 0]
  ------------------
 1158|      4|        (ns[3] == 'n') && (ns[4] == 's') && (ns[5] == 0)) {
  ------------------
  |  Branch (1158:9): [True: 2, False: 0]
  |  Branch (1158:27): [True: 2, False: 0]
  |  Branch (1158:45): [True: 2, False: 0]
  ------------------
 1159|      2|	xmlNsPtr nsret;
 1160|      2|	xmlChar *val;
 1161|       |
 1162|       |        /* Avoid unused variable warning if features are disabled. */
 1163|      2|        (void) nsret;
 1164|       |
 1165|      2|        if (!ctxt->replaceEntities) {
  ------------------
  |  Branch (1165:13): [True: 2, False: 0]
  ------------------
 1166|      2|	    ctxt->depth++;
 1167|      2|	    val = xmlStringDecodeEntities(ctxt, value, XML_SUBSTITUTE_REF,
  ------------------
  |  |  521|      2|#define XML_SUBSTITUTE_REF	1
  ------------------
 1168|      2|		                          0,0,0);
 1169|      2|	    ctxt->depth--;
 1170|      2|	    if (val == NULL) {
  ------------------
  |  Branch (1170:10): [True: 0, False: 2]
  ------------------
 1171|      0|	        xmlSAX2ErrMemory(ctxt, "xmlSAX2StartElement");
 1172|      0|	        xmlFree(ns);
 1173|      0|		if (name != NULL)
  ------------------
  |  Branch (1173:7): [True: 0, False: 0]
  ------------------
 1174|      0|		    xmlFree(name);
 1175|      0|                if (nval != NULL)
  ------------------
  |  Branch (1175:21): [True: 0, False: 0]
  ------------------
 1176|      0|                    xmlFree(nval);
 1177|      0|		return;
 1178|      0|	    }
 1179|      2|	} else {
 1180|      0|	    val = (xmlChar *) value;
 1181|      0|	}
 1182|       |
 1183|      2|	if (val[0] == 0) {
  ------------------
  |  Branch (1183:6): [True: 0, False: 2]
  ------------------
 1184|      0|	    xmlNsErrMsg(ctxt, XML_NS_ERR_EMPTY,
 1185|      0|		        "Empty namespace name for prefix %s\n", name, NULL);
 1186|      0|	}
 1187|      2|	if ((ctxt->pedantic != 0) && (val[0] != 0)) {
  ------------------
  |  Branch (1187:6): [True: 0, False: 2]
  |  Branch (1187:31): [True: 0, False: 0]
  ------------------
 1188|      0|	    xmlURIPtr uri;
 1189|       |
 1190|      0|	    uri = xmlParseURI((const char *)val);
 1191|      0|	    if (uri == NULL) {
  ------------------
  |  Branch (1191:10): [True: 0, False: 0]
  ------------------
 1192|      0|	        xmlNsWarnMsg(ctxt, XML_WAR_NS_URI,
 1193|      0|			 "xmlns:%s: %s not a valid URI\n", name, value);
 1194|      0|	    } else {
 1195|      0|		if (uri->scheme == NULL) {
  ------------------
  |  Branch (1195:7): [True: 0, False: 0]
  ------------------
 1196|      0|		    xmlNsWarnMsg(ctxt, XML_WAR_NS_URI_RELATIVE,
 1197|      0|			   "xmlns:%s: URI %s is not absolute\n", name, value);
 1198|      0|		}
 1199|      0|		xmlFreeURI(uri);
 1200|      0|	    }
 1201|      0|	}
 1202|       |
 1203|       |	/* a standard namespace definition */
 1204|      2|	nsret = xmlNewNs(ctxt->node, val, name);
 1205|      2|	xmlFree(ns);
 1206|      2|#ifdef LIBXML_VALID_ENABLED
 1207|       |	/*
 1208|       |	 * Validate also for namespace decls, they are attributes from
 1209|       |	 * an XML-1.0 perspective
 1210|       |	 */
 1211|      2|        if (nsret != NULL && ctxt->validate && ctxt->wellFormed &&
  ------------------
  |  Branch (1211:13): [True: 2, False: 0]
  |  Branch (1211:30): [True: 0, False: 2]
  |  Branch (1211:48): [True: 0, False: 0]
  ------------------
 1212|      2|	    ctxt->myDoc && ctxt->myDoc->intSubset)
  ------------------
  |  Branch (1212:6): [True: 0, False: 0]
  |  Branch (1212:21): [True: 0, False: 0]
  ------------------
 1213|      0|	    ctxt->valid &= xmlValidateOneNamespace(&ctxt->vctxt, ctxt->myDoc,
 1214|      0|					   ctxt->node, prefix, nsret, value);
 1215|      2|#endif /* LIBXML_VALID_ENABLED */
 1216|      2|	if (name != NULL)
  ------------------
  |  Branch (1216:6): [True: 2, False: 0]
  ------------------
 1217|      2|	    xmlFree(name);
 1218|      2|	if (nval != NULL)
  ------------------
  |  Branch (1218:6): [True: 0, False: 2]
  ------------------
 1219|      0|	    xmlFree(nval);
 1220|      2|	if (val != value)
  ------------------
  |  Branch (1220:6): [True: 2, False: 0]
  ------------------
 1221|      2|	    xmlFree(val);
 1222|      2|	return;
 1223|      2|    }
 1224|       |
 1225|      2|    if (ns != NULL) {
  ------------------
  |  Branch (1225:9): [True: 0, False: 2]
  ------------------
 1226|      0|	namespace = xmlSearchNs(ctxt->myDoc, ctxt->node, ns);
 1227|       |
 1228|      0|	if (namespace == NULL) {
  ------------------
  |  Branch (1228:6): [True: 0, False: 0]
  ------------------
 1229|      0|	    xmlNsErrMsg(ctxt, XML_NS_ERR_UNDEFINED_NAMESPACE,
 1230|      0|		    "Namespace prefix %s of attribute %s is not defined\n",
 1231|      0|		             ns, name);
 1232|      0|	} else {
 1233|      0|            xmlAttrPtr prop;
 1234|       |
 1235|      0|            prop = ctxt->node->properties;
 1236|      0|            while (prop != NULL) {
  ------------------
  |  Branch (1236:20): [True: 0, False: 0]
  ------------------
 1237|      0|                if (prop->ns != NULL) {
  ------------------
  |  Branch (1237:21): [True: 0, False: 0]
  ------------------
 1238|      0|                    if ((xmlStrEqual(name, prop->name)) &&
  ------------------
  |  Branch (1238:25): [True: 0, False: 0]
  ------------------
 1239|      0|                        ((namespace == prop->ns) ||
  ------------------
  |  Branch (1239:26): [True: 0, False: 0]
  ------------------
 1240|      0|                         (xmlStrEqual(namespace->href, prop->ns->href)))) {
  ------------------
  |  Branch (1240:26): [True: 0, False: 0]
  ------------------
 1241|      0|                            xmlNsErrMsg(ctxt, XML_ERR_ATTRIBUTE_REDEFINED,
 1242|      0|                                    "Attribute %s in %s redefined\n",
 1243|      0|                                             name, namespace->href);
 1244|      0|                        ctxt->wellFormed = 0;
 1245|      0|                        if (ctxt->recovery == 0) ctxt->disableSAX = 1;
  ------------------
  |  Branch (1245:29): [True: 0, False: 0]
  ------------------
 1246|      0|                        if (name != NULL)
  ------------------
  |  Branch (1246:29): [True: 0, False: 0]
  ------------------
 1247|      0|                            xmlFree(name);
 1248|      0|                        goto error;
 1249|      0|                    }
 1250|      0|                }
 1251|      0|                prop = prop->next;
 1252|      0|            }
 1253|      0|        }
 1254|      2|    } else {
 1255|      2|	namespace = NULL;
 1256|      2|    }
 1257|       |
 1258|       |    /* !!!!!! <a toto:arg="" xmlns:toto="http://toto.com"> */
 1259|      2|    ret = xmlNewNsPropEatName(ctxt->node, namespace, name, NULL);
 1260|      2|    if (ret == NULL)
  ------------------
  |  Branch (1260:9): [True: 0, False: 2]
  ------------------
 1261|      0|        goto error;
 1262|       |
 1263|      2|    if ((ctxt->replaceEntities == 0) && (!ctxt->html)) {
  ------------------
  |  Branch (1263:9): [True: 2, False: 0]
  |  Branch (1263:41): [True: 2, False: 0]
  ------------------
 1264|      2|        xmlNodePtr tmp;
 1265|       |
 1266|      2|        ret->children = xmlStringGetNodeList(ctxt->myDoc, value);
 1267|      2|        tmp = ret->children;
 1268|      4|        while (tmp != NULL) {
  ------------------
  |  Branch (1268:16): [True: 2, False: 2]
  ------------------
 1269|      2|            tmp->parent = (xmlNodePtr) ret;
 1270|      2|            if (tmp->next == NULL)
  ------------------
  |  Branch (1270:17): [True: 2, False: 0]
  ------------------
 1271|      2|                ret->last = tmp;
 1272|      2|            tmp = tmp->next;
 1273|      2|        }
 1274|      2|    } else if (value != NULL) {
  ------------------
  |  Branch (1274:16): [True: 0, False: 0]
  ------------------
 1275|      0|        ret->children = xmlNewDocText(ctxt->myDoc, value);
 1276|      0|        ret->last = ret->children;
 1277|      0|        if (ret->children != NULL)
  ------------------
  |  Branch (1277:13): [True: 0, False: 0]
  ------------------
 1278|      0|            ret->children->parent = (xmlNodePtr) ret;
 1279|      0|    }
 1280|       |
 1281|      2|#ifdef LIBXML_VALID_ENABLED
 1282|      2|    if ((!ctxt->html) && ctxt->validate && ctxt->wellFormed &&
  ------------------
  |  Branch (1282:9): [True: 2, False: 0]
  |  Branch (1282:26): [True: 0, False: 2]
  |  Branch (1282:44): [True: 0, False: 0]
  ------------------
 1283|      2|        ctxt->myDoc && ctxt->myDoc->intSubset) {
  ------------------
  |  Branch (1283:9): [True: 0, False: 0]
  |  Branch (1283:24): [True: 0, False: 0]
  ------------------
 1284|       |
 1285|       |	/*
 1286|       |	 * If we don't substitute entities, the validation should be
 1287|       |	 * done on a value with replaced entities anyway.
 1288|       |	 */
 1289|      0|        if (!ctxt->replaceEntities) {
  ------------------
  |  Branch (1289:13): [True: 0, False: 0]
  ------------------
 1290|      0|	    xmlChar *val;
 1291|       |
 1292|      0|	    ctxt->depth++;
 1293|      0|	    val = xmlStringDecodeEntities(ctxt, value, XML_SUBSTITUTE_REF,
  ------------------
  |  |  521|      0|#define XML_SUBSTITUTE_REF	1
  ------------------
 1294|      0|		                          0,0,0);
 1295|      0|	    ctxt->depth--;
 1296|       |
 1297|      0|	    if (val == NULL)
  ------------------
  |  Branch (1297:10): [True: 0, False: 0]
  ------------------
 1298|      0|		ctxt->valid &= xmlValidateOneAttribute(&ctxt->vctxt,
 1299|      0|				ctxt->myDoc, ctxt->node, ret, value);
 1300|      0|	    else {
 1301|      0|		xmlChar *nvalnorm;
 1302|       |
 1303|       |		/*
 1304|       |		 * Do the last stage of the attribute normalization
 1305|       |		 * It need to be done twice ... it's an extra burden related
 1306|       |		 * to the ability to keep xmlSAX2References in attributes
 1307|       |		 */
 1308|      0|		nvalnorm = xmlValidNormalizeAttributeValue(ctxt->myDoc,
 1309|      0|					    ctxt->node, fullname, val);
 1310|      0|		if (nvalnorm != NULL) {
  ------------------
  |  Branch (1310:7): [True: 0, False: 0]
  ------------------
 1311|      0|		    xmlFree(val);
 1312|      0|		    val = nvalnorm;
 1313|      0|		}
 1314|       |
 1315|      0|		ctxt->valid &= xmlValidateOneAttribute(&ctxt->vctxt,
 1316|      0|			        ctxt->myDoc, ctxt->node, ret, val);
 1317|      0|                xmlFree(val);
 1318|      0|	    }
 1319|      0|	} else {
 1320|      0|	    ctxt->valid &= xmlValidateOneAttribute(&ctxt->vctxt, ctxt->myDoc,
 1321|      0|					       ctxt->node, ret, value);
 1322|      0|	}
 1323|      0|    } else
 1324|      2|#endif /* LIBXML_VALID_ENABLED */
 1325|      2|           if (((ctxt->loadsubset & XML_SKIP_IDS) == 0) &&
  ------------------
  |  |  158|      2|#define XML_SKIP_IDS		8
  ------------------
  |  Branch (1325:16): [True: 2, False: 0]
  ------------------
 1326|      2|	       (((ctxt->replaceEntities == 0) && (ctxt->external != 2)) ||
  ------------------
  |  Branch (1326:11): [True: 2, False: 0]
  |  Branch (1326:43): [True: 2, False: 0]
  ------------------
 1327|      2|	        ((ctxt->replaceEntities != 0) && (ctxt->inSubset == 0))) &&
  ------------------
  |  Branch (1327:11): [True: 0, False: 0]
  |  Branch (1327:43): [True: 0, False: 0]
  ------------------
 1328|       |               /* Don't create IDs containing entity references */
 1329|      2|               (ret->children != NULL) &&
  ------------------
  |  Branch (1329:16): [True: 2, False: 0]
  ------------------
 1330|      2|               (ret->children->type == XML_TEXT_NODE) &&
  ------------------
  |  Branch (1330:16): [True: 2, False: 0]
  ------------------
 1331|      2|               (ret->children->next == NULL)) {
  ------------------
  |  Branch (1331:16): [True: 2, False: 0]
  ------------------
 1332|      2|        xmlChar *content = ret->children->content;
 1333|       |        /*
 1334|       |	 * when validating, the ID registration is done at the attribute
 1335|       |	 * validation level. Otherwise we have to do specific handling here.
 1336|       |	 */
 1337|      2|	if (xmlStrEqual(fullname, BAD_CAST "xml:id")) {
  ------------------
  |  |   35|      2|#define BAD_CAST (xmlChar *)
  ------------------
  |  Branch (1337:6): [True: 0, False: 2]
  ------------------
 1338|       |	    /*
 1339|       |	     * Add the xml:id value
 1340|       |	     *
 1341|       |	     * Open issue: normalization of the value.
 1342|       |	     */
 1343|      0|	    if (xmlValidateNCName(content, 1) != 0) {
  ------------------
  |  Branch (1343:10): [True: 0, False: 0]
  ------------------
 1344|      0|	        xmlErrValid(ctxt, XML_DTD_XMLID_VALUE,
 1345|      0|		      "xml:id : attribute value %s is not an NCName\n",
 1346|      0|			    (const char *) content, NULL);
 1347|      0|	    }
 1348|      0|	    xmlAddID(&ctxt->vctxt, ctxt->myDoc, content, ret);
 1349|      2|	} else if (xmlIsID(ctxt->myDoc, ctxt->node, ret))
  ------------------
  |  Branch (1349:13): [True: 0, False: 2]
  ------------------
 1350|      0|	    xmlAddID(&ctxt->vctxt, ctxt->myDoc, content, ret);
 1351|      2|	else if (xmlIsRef(ctxt->myDoc, ctxt->node, ret))
  ------------------
  |  Branch (1351:11): [True: 0, False: 2]
  ------------------
 1352|      0|	    xmlAddRef(&ctxt->vctxt, ctxt->myDoc, content, ret);
 1353|      2|    }
 1354|       |
 1355|      2|error:
 1356|      2|    if (nval != NULL)
  ------------------
  |  Branch (1356:9): [True: 0, False: 2]
  ------------------
 1357|      0|	xmlFree(nval);
 1358|      2|    if (ns != NULL)
  ------------------
  |  Branch (1358:9): [True: 0, False: 2]
  ------------------
 1359|      0|	xmlFree(ns);
 1360|      2|}
SAX2.c:xmlSAX2AttributeNs:
 1867|    940|{
 1868|    940|    xmlAttrPtr ret;
 1869|    940|    xmlNsPtr namespace = NULL;
 1870|    940|    xmlChar *dup = NULL;
 1871|       |
 1872|       |    /*
 1873|       |     * Note: if prefix == NULL, the attribute is not in the default namespace
 1874|       |     */
 1875|    940|    if (prefix != NULL) {
  ------------------
  |  Branch (1875:9): [True: 12, False: 928]
  ------------------
 1876|     12|	namespace = xmlParserNsLookupSax(ctxt, prefix);
 1877|     12|	if ((namespace == NULL) && (xmlStrEqual(prefix, BAD_CAST "xml"))) {
  ------------------
  |  |   35|     12|#define BAD_CAST (xmlChar *)
  ------------------
  |  Branch (1877:6): [True: 12, False: 0]
  |  Branch (1877:29): [True: 12, False: 0]
  ------------------
 1878|     12|	    namespace = xmlSearchNs(ctxt->myDoc, ctxt->node, prefix);
 1879|     12|	}
 1880|     12|    }
 1881|       |
 1882|       |    /*
 1883|       |     * allocate the node
 1884|       |     */
 1885|    940|    if (ctxt->freeAttrs != NULL) {
  ------------------
  |  Branch (1885:9): [True: 30, False: 910]
  ------------------
 1886|     30|        ret = ctxt->freeAttrs;
 1887|     30|	ctxt->freeAttrs = ret->next;
 1888|     30|	ctxt->freeAttrsNr--;
 1889|    910|    } else {
 1890|    910|        ret = xmlMalloc(sizeof(*ret));
 1891|    910|        if (ret == NULL) {
  ------------------
  |  Branch (1891:13): [True: 0, False: 910]
  ------------------
 1892|      0|            xmlSAX2ErrMemory(ctxt, NULL);
 1893|      0|            return(NULL);
 1894|      0|        }
 1895|    910|    }
 1896|       |
 1897|    940|    memset(ret, 0, sizeof(xmlAttr));
 1898|    940|    ret->type = XML_ATTRIBUTE_NODE;
 1899|       |
 1900|    940|    ret->parent = ctxt->node;
 1901|    940|    ret->doc = ctxt->myDoc;
 1902|    940|    ret->ns = namespace;
 1903|       |
 1904|    940|    if (ctxt->dictNames)
  ------------------
  |  Branch (1904:9): [True: 940, False: 0]
  ------------------
 1905|    940|        ret->name = localname;
 1906|      0|    else
 1907|      0|        ret->name = xmlStrdup(localname);
 1908|       |
 1909|    940|    if ((__xmlRegisterCallbacks) && (xmlRegisterNodeDefaultValue))
  ------------------
  |  |  682|      0|    XML_GLOBAL_MACRO(xmlRegisterNodeDefaultValue)
  |  |  ------------------
  |  |  |  |  500|      0|  #define XML_GLOBAL_MACRO(name) (*__##name())
  |  |  ------------------
  ------------------
  |  Branch (1909:9): [True: 0, False: 940]
  |  Branch (1909:37): [True: 0, False: 0]
  ------------------
 1910|      0|        xmlRegisterNodeDefaultValue((xmlNodePtr)ret);
  ------------------
  |  |  682|      0|    XML_GLOBAL_MACRO(xmlRegisterNodeDefaultValue)
  |  |  ------------------
  |  |  |  |  500|      0|  #define XML_GLOBAL_MACRO(name) (*__##name())
  |  |  ------------------
  ------------------
 1911|       |
 1912|    940|    if ((ctxt->replaceEntities == 0) && (!ctxt->html)) {
  ------------------
  |  Branch (1912:9): [True: 4, False: 936]
  |  Branch (1912:41): [True: 4, False: 0]
  ------------------
 1913|      4|	xmlNodePtr tmp;
 1914|       |
 1915|       |	/*
 1916|       |	 * We know that if there is an entity reference, then
 1917|       |	 * the string has been dup'ed and terminates with 0
 1918|       |	 * otherwise with ' or "
 1919|       |	 */
 1920|      4|	if (*valueend != 0) {
  ------------------
  |  Branch (1920:6): [True: 4, False: 0]
  ------------------
 1921|      4|	    tmp = xmlSAX2TextNode(ctxt, value, valueend - value);
 1922|      4|	    ret->children = tmp;
 1923|      4|	    ret->last = tmp;
 1924|      4|	    if (tmp != NULL) {
  ------------------
  |  Branch (1924:10): [True: 4, False: 0]
  ------------------
 1925|      4|		tmp->doc = ret->doc;
 1926|      4|		tmp->parent = (xmlNodePtr) ret;
 1927|      4|	    }
 1928|      4|	} else {
 1929|      0|	    ret->children = xmlStringLenGetNodeList(ctxt->myDoc, value,
 1930|      0|						    valueend - value);
 1931|      0|	    tmp = ret->children;
 1932|      0|	    while (tmp != NULL) {
  ------------------
  |  Branch (1932:13): [True: 0, False: 0]
  ------------------
 1933|      0|	        tmp->doc = ret->doc;
 1934|      0|		tmp->parent = (xmlNodePtr) ret;
 1935|      0|		if (tmp->next == NULL)
  ------------------
  |  Branch (1935:7): [True: 0, False: 0]
  ------------------
 1936|      0|		    ret->last = tmp;
 1937|      0|		tmp = tmp->next;
 1938|      0|	    }
 1939|      0|	}
 1940|    936|    } else if (value != NULL) {
  ------------------
  |  Branch (1940:16): [True: 936, False: 0]
  ------------------
 1941|    936|	xmlNodePtr tmp;
 1942|       |
 1943|    936|	tmp = xmlSAX2TextNode(ctxt, value, valueend - value);
 1944|    936|	ret->children = tmp;
 1945|    936|	ret->last = tmp;
 1946|    936|	if (tmp != NULL) {
  ------------------
  |  Branch (1946:6): [True: 936, False: 0]
  ------------------
 1947|    936|	    tmp->doc = ret->doc;
 1948|    936|	    tmp->parent = (xmlNodePtr) ret;
 1949|    936|	}
 1950|    936|    }
 1951|       |
 1952|    940|#ifdef LIBXML_VALID_ENABLED
 1953|    940|    if ((!ctxt->html) && ctxt->validate && ctxt->wellFormed &&
  ------------------
  |  Branch (1953:9): [True: 940, False: 0]
  |  Branch (1953:26): [True: 0, False: 940]
  |  Branch (1953:44): [True: 0, False: 0]
  ------------------
 1954|    940|        ctxt->myDoc && ctxt->myDoc->intSubset) {
  ------------------
  |  Branch (1954:9): [True: 0, False: 0]
  |  Branch (1954:24): [True: 0, False: 0]
  ------------------
 1955|       |	/*
 1956|       |	 * If we don't substitute entities, the validation should be
 1957|       |	 * done on a value with replaced entities anyway.
 1958|       |	 */
 1959|      0|        if (!ctxt->replaceEntities) {
  ------------------
  |  Branch (1959:13): [True: 0, False: 0]
  ------------------
 1960|      0|	    dup = xmlSAX2DecodeAttrEntities(ctxt, value, valueend);
 1961|      0|	    if (dup == NULL) {
  ------------------
  |  Branch (1961:10): [True: 0, False: 0]
  ------------------
 1962|      0|	        if (*valueend == 0) {
  ------------------
  |  Branch (1962:14): [True: 0, False: 0]
  ------------------
 1963|      0|		    ctxt->valid &= xmlValidateOneAttribute(&ctxt->vctxt,
 1964|      0|				    ctxt->myDoc, ctxt->node, ret, value);
 1965|      0|		} else {
 1966|       |		    /*
 1967|       |		     * That should already be normalized.
 1968|       |		     * cheaper to finally allocate here than duplicate
 1969|       |		     * entry points in the full validation code
 1970|       |		     */
 1971|      0|		    dup = xmlStrndup(value, valueend - value);
 1972|       |
 1973|      0|		    ctxt->valid &= xmlValidateOneAttribute(&ctxt->vctxt,
 1974|      0|				    ctxt->myDoc, ctxt->node, ret, dup);
 1975|      0|		}
 1976|      0|	    } else {
 1977|       |	        /*
 1978|       |		 * dup now contains a string of the flattened attribute
 1979|       |		 * content with entities substituted. Check if we need to
 1980|       |		 * apply an extra layer of normalization.
 1981|       |		 * It need to be done twice ... it's an extra burden related
 1982|       |		 * to the ability to keep references in attributes
 1983|       |		 */
 1984|      0|		if (ctxt->attsSpecial != NULL) {
  ------------------
  |  Branch (1984:7): [True: 0, False: 0]
  ------------------
 1985|      0|		    xmlChar *nvalnorm;
 1986|      0|		    xmlChar fn[50];
 1987|      0|		    xmlChar *fullname;
 1988|       |
 1989|      0|		    fullname = xmlBuildQName(localname, prefix, fn, 50);
 1990|      0|		    if (fullname != NULL) {
  ------------------
  |  Branch (1990:11): [True: 0, False: 0]
  ------------------
 1991|      0|			ctxt->vctxt.valid = 1;
 1992|      0|		        nvalnorm = xmlValidCtxtNormalizeAttributeValue(
 1993|      0|			                 &ctxt->vctxt, ctxt->myDoc,
 1994|      0|					 ctxt->node, fullname, dup);
 1995|      0|			if (ctxt->vctxt.valid != 1)
  ------------------
  |  Branch (1995:8): [True: 0, False: 0]
  ------------------
 1996|      0|			    ctxt->valid = 0;
 1997|       |
 1998|      0|			if ((fullname != fn) && (fullname != localname))
  ------------------
  |  Branch (1998:8): [True: 0, False: 0]
  |  Branch (1998:28): [True: 0, False: 0]
  ------------------
 1999|      0|			    xmlFree(fullname);
 2000|      0|			if (nvalnorm != NULL) {
  ------------------
  |  Branch (2000:8): [True: 0, False: 0]
  ------------------
 2001|      0|			    xmlFree(dup);
 2002|      0|			    dup = nvalnorm;
 2003|      0|			}
 2004|      0|		    }
 2005|      0|		}
 2006|       |
 2007|      0|		ctxt->valid &= xmlValidateOneAttribute(&ctxt->vctxt,
 2008|      0|			        ctxt->myDoc, ctxt->node, ret, dup);
 2009|      0|	    }
 2010|      0|	} else {
 2011|       |	    /*
 2012|       |	     * if entities already have been substituted, then
 2013|       |	     * the attribute as passed is already normalized
 2014|       |	     */
 2015|      0|	    dup = xmlStrndup(value, valueend - value);
 2016|       |
 2017|      0|	    ctxt->valid &= xmlValidateOneAttribute(&ctxt->vctxt,
 2018|      0|	                             ctxt->myDoc, ctxt->node, ret, dup);
 2019|      0|	}
 2020|      0|    } else
 2021|    940|#endif /* LIBXML_VALID_ENABLED */
 2022|    940|           if (((ctxt->loadsubset & XML_SKIP_IDS) == 0) &&
  ------------------
  |  |  158|    940|#define XML_SKIP_IDS		8
  ------------------
  |  Branch (2022:16): [True: 940, False: 0]
  ------------------
 2023|    940|	       (((ctxt->replaceEntities == 0) && (ctxt->external != 2)) ||
  ------------------
  |  Branch (2023:11): [True: 4, False: 936]
  |  Branch (2023:43): [True: 4, False: 0]
  ------------------
 2024|    940|	        ((ctxt->replaceEntities != 0) && (ctxt->inSubset == 0))) &&
  ------------------
  |  Branch (2024:11): [True: 936, False: 0]
  |  Branch (2024:43): [True: 936, False: 0]
  ------------------
 2025|       |               /* Don't create IDs containing entity references */
 2026|    940|               (ret->children != NULL) &&
  ------------------
  |  Branch (2026:16): [True: 940, False: 0]
  ------------------
 2027|    940|               (ret->children->type == XML_TEXT_NODE) &&
  ------------------
  |  Branch (2027:16): [True: 940, False: 0]
  ------------------
 2028|    940|               (ret->children->next == NULL)) {
  ------------------
  |  Branch (2028:16): [True: 940, False: 0]
  ------------------
 2029|    940|        xmlChar *content = ret->children->content;
 2030|       |        /*
 2031|       |	 * when validating, the ID registration is done at the attribute
 2032|       |	 * validation level. Otherwise we have to do specific handling here.
 2033|       |	 */
 2034|    940|        if ((prefix == ctxt->str_xml) &&
  ------------------
  |  Branch (2034:13): [True: 12, False: 928]
  ------------------
 2035|    940|	           (localname[0] == 'i') && (localname[1] == 'd') &&
  ------------------
  |  Branch (2035:13): [True: 12, False: 0]
  |  Branch (2035:38): [True: 12, False: 0]
  ------------------
 2036|    940|		   (localname[2] == 0)) {
  ------------------
  |  Branch (2036:6): [True: 12, False: 0]
  ------------------
 2037|       |	    /*
 2038|       |	     * Add the xml:id value
 2039|       |	     *
 2040|       |	     * Open issue: normalization of the value.
 2041|       |	     */
 2042|     12|	    if (xmlValidateNCName(content, 1) != 0) {
  ------------------
  |  Branch (2042:10): [True: 0, False: 12]
  ------------------
 2043|      0|	        xmlErrValid(ctxt, XML_DTD_XMLID_VALUE,
 2044|      0|		      "xml:id : attribute value %s is not an NCName\n",
 2045|      0|			    (const char *) content, NULL);
 2046|      0|	    }
 2047|     12|	    xmlAddID(&ctxt->vctxt, ctxt->myDoc, content, ret);
 2048|    928|	} else if (xmlIsID(ctxt->myDoc, ctxt->node, ret)) {
  ------------------
  |  Branch (2048:13): [True: 18, False: 910]
  ------------------
 2049|     18|	    xmlAddID(&ctxt->vctxt, ctxt->myDoc, content, ret);
 2050|    910|	} else if (xmlIsRef(ctxt->myDoc, ctxt->node, ret)) {
  ------------------
  |  Branch (2050:13): [True: 0, False: 910]
  ------------------
 2051|      0|	    xmlAddRef(&ctxt->vctxt, ctxt->myDoc, content, ret);
 2052|      0|	}
 2053|    940|    }
 2054|    940|    if (dup != NULL)
  ------------------
  |  Branch (2054:9): [True: 0, False: 940]
  ------------------
 2055|      0|	xmlFree(dup);
 2056|       |
 2057|    940|    return(ret);
 2058|    940|}
SAX2.c:xmlSAX2TextNode:
 1749|  2.80k|xmlSAX2TextNode(xmlParserCtxtPtr ctxt, const xmlChar *str, int len) {
 1750|  2.80k|    xmlNodePtr ret;
 1751|  2.80k|    const xmlChar *intern = NULL;
 1752|       |
 1753|       |    /*
 1754|       |     * Allocate
 1755|       |     */
 1756|  2.80k|    if (ctxt->freeElems != NULL) {
  ------------------
  |  Branch (1756:9): [True: 10, False: 2.79k]
  ------------------
 1757|     10|	ret = ctxt->freeElems;
 1758|     10|	ctxt->freeElems = ret->next;
 1759|     10|	ctxt->freeElemsNr--;
 1760|  2.79k|    } else {
 1761|  2.79k|	ret = (xmlNodePtr) xmlMalloc(sizeof(xmlNode));
 1762|  2.79k|    }
 1763|  2.80k|    if (ret == NULL) {
  ------------------
  |  Branch (1763:9): [True: 0, False: 2.80k]
  ------------------
 1764|      0|        xmlErrMemory(ctxt, "xmlSAX2Characters");
 1765|      0|	return(NULL);
 1766|      0|    }
 1767|  2.80k|    memset(ret, 0, sizeof(xmlNode));
 1768|       |    /*
 1769|       |     * intern the formatting blanks found between tags, or the
 1770|       |     * very short strings
 1771|       |     */
 1772|  2.80k|    if (ctxt->dictNames) {
  ------------------
  |  Branch (1772:9): [True: 2.79k, False: 6]
  ------------------
 1773|  2.79k|        xmlChar cur = str[len];
 1774|       |
 1775|  2.79k|	if ((len < (int) (2 * sizeof(void *))) &&
  ------------------
  |  Branch (1775:6): [True: 2.51k, False: 284]
  ------------------
 1776|  2.79k|	    (ctxt->options & XML_PARSE_COMPACT)) {
  ------------------
  |  Branch (1776:6): [True: 1.25k, False: 1.25k]
  ------------------
 1777|       |	    /* store the string in the node overriding properties and nsDef */
 1778|  1.25k|	    xmlChar *tmp = (xmlChar *) &(ret->properties);
 1779|  1.25k|	    memcpy(tmp, str, len);
 1780|  1.25k|	    tmp[len] = 0;
 1781|  1.25k|	    intern = tmp;
 1782|  1.54k|	} else if ((len <= 3) && ((cur == '"') || (cur == '\'') ||
  ------------------
  |  Branch (1782:13): [True: 438, False: 1.10k]
  |  Branch (1782:28): [True: 19, False: 419]
  |  Branch (1782:44): [True: 0, False: 419]
  ------------------
 1783|    438|	    ((cur == '<') && (str[len + 1] != '!')))) {
  ------------------
  |  Branch (1783:7): [True: 411, False: 8]
  |  Branch (1783:23): [True: 409, False: 2]
  ------------------
 1784|    428|	    intern = xmlDictLookup(ctxt->dict, str, len);
 1785|  1.11k|	} else if (IS_BLANK_CH(*str) && (len < 60) && (cur == '<') &&
  ------------------
  |  |  151|  1.11k|#define IS_BLANK_CH(c)  xmlIsBlank_ch(c)
  |  |  ------------------
  |  |  |  |   88|  2.22k|#define xmlIsBlank_ch(c)	(((c) == 0x20) || \
  |  |  |  |  ------------------
  |  |  |  |  |  Branch (88:27): [True: 0, False: 1.11k]
  |  |  |  |  ------------------
  |  |  |  |   89|  1.11k|				 ((0x9 <= (c)) && ((c) <= 0xa)) || \
  |  |  |  |  ------------------
  |  |  |  |  |  Branch (89:7): [True: 1.11k, False: 0]
  |  |  |  |  |  Branch (89:23): [True: 544, False: 568]
  |  |  |  |  ------------------
  |  |  |  |   90|  2.22k|				 ((c) == 0xd))
  |  |  |  |  ------------------
  |  |  |  |  |  Branch (90:6): [True: 0, False: 568]
  |  |  |  |  ------------------
  |  |  ------------------
  ------------------
  |  Branch (1785:34): [True: 542, False: 2]
  |  Branch (1785:48): [True: 530, False: 12]
  ------------------
 1786|  1.11k|	           (str[len + 1] != '!')) {
  ------------------
  |  Branch (1786:13): [True: 501, False: 29]
  ------------------
 1787|    501|	    int i;
 1788|       |
 1789|  6.55k|	    for (i = 1;i < len;i++) {
  ------------------
  |  Branch (1789:17): [True: 6.05k, False: 497]
  ------------------
 1790|  6.05k|		if (!IS_BLANK_CH(str[i])) goto skip;
  ------------------
  |  |  151|  6.05k|#define IS_BLANK_CH(c)  xmlIsBlank_ch(c)
  |  |  ------------------
  |  |  |  |   88|  6.05k|#define xmlIsBlank_ch(c)	(((c) == 0x20) || \
  |  |  |  |  ------------------
  |  |  |  |  |  Branch (88:27): [True: 6.05k, False: 4]
  |  |  |  |  ------------------
  |  |  |  |   89|  6.05k|				 ((0x9 <= (c)) && ((c) <= 0xa)) || \
  |  |  |  |  ------------------
  |  |  |  |  |  Branch (89:7): [True: 4, False: 0]
  |  |  |  |  |  Branch (89:23): [True: 0, False: 4]
  |  |  |  |  ------------------
  |  |  |  |   90|  6.05k|				 ((c) == 0xd))
  |  |  |  |  ------------------
  |  |  |  |  |  Branch (90:6): [True: 0, False: 4]
  |  |  |  |  ------------------
  |  |  ------------------
  ------------------
 1791|  6.05k|	    }
 1792|    497|	    intern = xmlDictLookup(ctxt->dict, str, len);
 1793|    497|	}
 1794|  2.79k|    }
 1795|  2.80k|skip:
 1796|  2.80k|    ret->type = XML_TEXT_NODE;
 1797|       |
 1798|  2.80k|    ret->name = xmlStringText;
 1799|  2.80k|    if (intern == NULL) {
  ------------------
  |  Branch (1799:9): [True: 621, False: 2.18k]
  ------------------
 1800|    621|	ret->content = xmlStrndup(str, len);
 1801|    621|	if (ret->content == NULL) {
  ------------------
  |  Branch (1801:6): [True: 0, False: 621]
  ------------------
 1802|      0|	    xmlSAX2ErrMemory(ctxt, "xmlSAX2TextNode");
 1803|      0|	    xmlFree(ret);
 1804|      0|	    return(NULL);
 1805|      0|	}
 1806|    621|    } else
 1807|  2.18k|	ret->content = (xmlChar *) intern;
 1808|       |
 1809|  2.80k|    if ((__xmlRegisterCallbacks) && (xmlRegisterNodeDefaultValue))
  ------------------
  |  |  682|      0|    XML_GLOBAL_MACRO(xmlRegisterNodeDefaultValue)
  |  |  ------------------
  |  |  |  |  500|      0|  #define XML_GLOBAL_MACRO(name) (*__##name())
  |  |  ------------------
  ------------------
  |  Branch (1809:9): [True: 0, False: 2.80k]
  |  Branch (1809:37): [True: 0, False: 0]
  ------------------
 1810|      0|	xmlRegisterNodeDefaultValue(ret);
  ------------------
  |  |  682|      0|    XML_GLOBAL_MACRO(xmlRegisterNodeDefaultValue)
  |  |  ------------------
  |  |  |  |  500|      0|  #define XML_GLOBAL_MACRO(name) (*__##name())
  |  |  ------------------
  ------------------
 1811|  2.80k|    return(ret);
 1812|  2.80k|}
SAX2.c:xmlSAX2Text:
 2404|  1.86k|{
 2405|  1.86k|    xmlNodePtr lastChild;
 2406|       |
 2407|  1.86k|    if (ctxt == NULL) return;
  ------------------
  |  Branch (2407:9): [True: 0, False: 1.86k]
  ------------------
 2408|       |    /*
 2409|       |     * Handle the data if any. If there is no child
 2410|       |     * add it as content, otherwise if the last child is text,
 2411|       |     * concatenate it, else create a new node of type text.
 2412|       |     */
 2413|       |
 2414|  1.86k|    if (ctxt->node == NULL) {
  ------------------
  |  Branch (2414:9): [True: 0, False: 1.86k]
  ------------------
 2415|      0|        return;
 2416|      0|    }
 2417|  1.86k|    lastChild = ctxt->node->last;
 2418|       |
 2419|       |    /*
 2420|       |     * Here we needed an accelerator mechanism in case of very large
 2421|       |     * elements. Use an attribute in the structure !!!
 2422|       |     */
 2423|  1.86k|    if (lastChild == NULL) {
  ------------------
  |  Branch (2423:9): [True: 688, False: 1.17k]
  ------------------
 2424|    688|        if (type == XML_TEXT_NODE)
  ------------------
  |  Branch (2424:13): [True: 688, False: 0]
  ------------------
 2425|    688|            lastChild = xmlSAX2TextNode(ctxt, ch, len);
 2426|      0|        else
 2427|      0|            lastChild = xmlNewCDataBlock(ctxt->myDoc, ch, len);
 2428|    688|	if (lastChild != NULL) {
  ------------------
  |  Branch (2428:6): [True: 688, False: 0]
  ------------------
 2429|    688|	    ctxt->node->children = lastChild;
 2430|    688|	    ctxt->node->last = lastChild;
 2431|    688|	    lastChild->parent = ctxt->node;
 2432|    688|	    lastChild->doc = ctxt->node->doc;
 2433|    688|	    ctxt->nodelen = len;
 2434|    688|	    ctxt->nodemem = len + 1;
 2435|    688|	} else {
 2436|      0|	    xmlSAX2ErrMemory(ctxt, "xmlSAX2Characters");
 2437|      0|	    return;
 2438|      0|	}
 2439|  1.17k|    } else {
 2440|  1.17k|	int coalesceText = (lastChild != NULL) &&
  ------------------
  |  Branch (2440:21): [True: 1.17k, False: 0]
  ------------------
 2441|  1.17k|	    (lastChild->type == type) &&
  ------------------
  |  Branch (2441:6): [True: 4, False: 1.17k]
  ------------------
 2442|  1.17k|	    ((type != XML_TEXT_NODE) ||
  ------------------
  |  Branch (2442:7): [True: 0, False: 4]
  ------------------
 2443|      4|             (lastChild->name == xmlStringText));
  ------------------
  |  Branch (2443:14): [True: 4, False: 0]
  ------------------
 2444|  1.17k|	if ((coalesceText) && (ctxt->nodemem != 0)) {
  ------------------
  |  Branch (2444:6): [True: 4, False: 1.17k]
  |  Branch (2444:24): [True: 4, False: 0]
  ------------------
 2445|       |	    /*
 2446|       |	     * The whole point of maintaining nodelen and nodemem,
 2447|       |	     * xmlTextConcat is too costly, i.e. compute length,
 2448|       |	     * reallocate a new buffer, move data, append ch. Here
 2449|       |	     * We try to minimize realloc() uses and avoid copying
 2450|       |	     * and recomputing length over and over.
 2451|       |	     */
 2452|      4|	    if (lastChild->content == (xmlChar *)&(lastChild->properties)) {
  ------------------
  |  Branch (2452:10): [True: 0, False: 4]
  ------------------
 2453|      0|		lastChild->content = xmlStrdup(lastChild->content);
 2454|      0|		lastChild->properties = NULL;
 2455|      4|	    } else if ((ctxt->nodemem == ctxt->nodelen + 1) &&
  ------------------
  |  Branch (2455:17): [True: 2, False: 2]
  ------------------
 2456|      4|	               (xmlDictOwns(ctxt->dict, lastChild->content))) {
  ------------------
  |  Branch (2456:17): [True: 0, False: 2]
  ------------------
 2457|      0|		lastChild->content = xmlStrdup(lastChild->content);
 2458|      0|	    }
 2459|      4|	    if (lastChild->content == NULL) {
  ------------------
  |  Branch (2459:10): [True: 0, False: 4]
  ------------------
 2460|      0|		xmlSAX2ErrMemory(ctxt, "xmlSAX2Characters: xmlStrdup returned NULL");
 2461|      0|		return;
 2462|      0| 	    }
 2463|      4|	    if (ctxt->nodelen > INT_MAX - len) {
  ------------------
  |  Branch (2463:10): [True: 0, False: 4]
  ------------------
 2464|      0|                xmlSAX2ErrMemory(ctxt, "xmlSAX2Characters overflow prevented");
 2465|      0|                return;
 2466|      0|	    }
 2467|      4|            if ((ctxt->nodelen + len > XML_MAX_TEXT_LENGTH) &&
  ------------------
  |  |   42|      4|#define XML_MAX_TEXT_LENGTH 10000000
  ------------------
  |  Branch (2467:17): [True: 0, False: 4]
  ------------------
 2468|      4|                ((ctxt->options & XML_PARSE_HUGE) == 0)) {
  ------------------
  |  Branch (2468:17): [True: 0, False: 0]
  ------------------
 2469|      0|                xmlSAX2ErrMemory(ctxt, "xmlSAX2Characters: huge text node");
 2470|      0|                return;
 2471|      0|            }
 2472|      4|	    if (ctxt->nodelen + len >= ctxt->nodemem) {
  ------------------
  |  Branch (2472:10): [True: 2, False: 2]
  ------------------
 2473|      2|		xmlChar *newbuf;
 2474|      2|		int size;
 2475|       |
 2476|      2|		size = ctxt->nodemem > INT_MAX - len ?
  ------------------
  |  Branch (2476:10): [True: 0, False: 2]
  ------------------
 2477|      0|                       INT_MAX :
 2478|      2|                       ctxt->nodemem + len;
 2479|      2|		size = size > INT_MAX / 2 ? INT_MAX : size * 2;
  ------------------
  |  Branch (2479:10): [True: 0, False: 2]
  ------------------
 2480|      2|                newbuf = (xmlChar *) xmlRealloc(lastChild->content,size);
 2481|      2|		if (newbuf == NULL) {
  ------------------
  |  Branch (2481:7): [True: 0, False: 2]
  ------------------
 2482|      0|		    xmlSAX2ErrMemory(ctxt, "xmlSAX2Characters");
 2483|      0|		    return;
 2484|      0|		}
 2485|      2|		ctxt->nodemem = size;
 2486|      2|		lastChild->content = newbuf;
 2487|      2|	    }
 2488|      4|	    memcpy(&lastChild->content[ctxt->nodelen], ch, len);
 2489|      4|	    ctxt->nodelen += len;
 2490|      4|	    lastChild->content[ctxt->nodelen] = 0;
 2491|  1.17k|	} else if (coalesceText) {
  ------------------
  |  Branch (2491:13): [True: 0, False: 1.17k]
  ------------------
 2492|      0|	    if (xmlTextConcat(lastChild, ch, len)) {
  ------------------
  |  Branch (2492:10): [True: 0, False: 0]
  ------------------
 2493|      0|		xmlSAX2ErrMemory(ctxt, "xmlSAX2Characters");
 2494|      0|	    }
 2495|      0|	    if (ctxt->node->children != NULL) {
  ------------------
  |  Branch (2495:10): [True: 0, False: 0]
  ------------------
 2496|      0|		ctxt->nodelen = xmlStrlen(lastChild->content);
 2497|      0|		ctxt->nodemem = ctxt->nodelen + 1;
 2498|      0|	    }
 2499|  1.17k|	} else {
 2500|       |	    /* Mixed content, first time */
 2501|  1.17k|            if (type == XML_TEXT_NODE) {
  ------------------
  |  Branch (2501:17): [True: 1.17k, False: 0]
  ------------------
 2502|  1.17k|                lastChild = xmlSAX2TextNode(ctxt, ch, len);
 2503|  1.17k|                if (lastChild != NULL)
  ------------------
  |  Branch (2503:21): [True: 1.17k, False: 0]
  ------------------
 2504|  1.17k|                    lastChild->doc = ctxt->myDoc;
 2505|  1.17k|            } else
 2506|      0|                lastChild = xmlNewCDataBlock(ctxt->myDoc, ch, len);
 2507|  1.17k|	    if (lastChild != NULL) {
  ------------------
  |  Branch (2507:10): [True: 1.17k, False: 0]
  ------------------
 2508|  1.17k|		xmlAddChild(ctxt->node, lastChild);
 2509|  1.17k|		if (ctxt->node->children != NULL) {
  ------------------
  |  Branch (2509:7): [True: 1.17k, False: 0]
  ------------------
 2510|  1.17k|		    ctxt->nodelen = len;
 2511|  1.17k|		    ctxt->nodemem = len + 1;
 2512|  1.17k|		}
 2513|  1.17k|	    }
 2514|  1.17k|	}
 2515|  1.17k|    }
 2516|       |
 2517|  1.86k|    if ((lastChild != NULL) &&
  ------------------
  |  Branch (2517:9): [True: 1.86k, False: 0]
  ------------------
 2518|  1.86k|        (type == XML_TEXT_NODE) &&
  ------------------
  |  Branch (2518:9): [True: 1.86k, False: 0]
  ------------------
 2519|  1.86k|        (ctxt->linenumbers) &&
  ------------------
  |  Branch (2519:9): [True: 1.86k, False: 0]
  ------------------
 2520|  1.86k|        (ctxt->input != NULL)) {
  ------------------
  |  Branch (2520:9): [True: 1.86k, False: 0]
  ------------------
 2521|  1.86k|        if ((unsigned) ctxt->input->line < (unsigned) USHRT_MAX)
  ------------------
  |  Branch (2521:13): [True: 1.86k, False: 0]
  ------------------
 2522|  1.86k|            lastChild->line = ctxt->input->line;
 2523|      0|        else {
 2524|      0|            lastChild->line = USHRT_MAX;
 2525|      0|            if (ctxt->options & XML_PARSE_BIG_LINES)
  ------------------
  |  Branch (2525:17): [True: 0, False: 0]
  ------------------
 2526|      0|                lastChild->psvi = (void *) (ptrdiff_t) ctxt->input->line;
 2527|      0|        }
 2528|  1.86k|    }
 2529|  1.86k|}

xmlBufCreate:
  122|     18|xmlBufCreate(void) {
  123|     18|    xmlBufPtr ret;
  124|       |
  125|     18|    ret = (xmlBufPtr) xmlMalloc(sizeof(xmlBuf));
  126|     18|    if (ret == NULL) {
  ------------------
  |  Branch (126:9): [True: 0, False: 18]
  ------------------
  127|      0|	xmlBufMemoryError(NULL, "creating buffer");
  128|      0|        return(NULL);
  129|      0|    }
  130|     18|    ret->use = 0;
  131|     18|    ret->error = 0;
  132|     18|    ret->buffer = NULL;
  133|     18|    ret->size = xmlDefaultBufferSize;
  ------------------
  |  |  680|     18|  #define xmlDefaultBufferSize XML_GLOBAL_MACRO(xmlDefaultBufferSize)
  |  |  ------------------
  |  |  |  |  500|     18|  #define XML_GLOBAL_MACRO(name) (*__##name())
  |  |  ------------------
  ------------------
  134|     18|    UPDATE_COMPAT(ret);
  ------------------
  |  |   61|     18|     if (buf->size < INT_MAX) buf->compat_size = buf->size; \
  |  |  ------------------
  |  |  |  Branch (61:10): [True: 18, False: 0]
  |  |  ------------------
  |  |   62|     18|     else buf->compat_size = INT_MAX;			    \
  |  |   63|     18|     if (buf->use < INT_MAX) buf->compat_use = buf->use; \
  |  |  ------------------
  |  |  |  Branch (63:10): [True: 18, False: 0]
  |  |  ------------------
  |  |   64|     18|     else buf->compat_use = INT_MAX;
  ------------------
  135|     18|    ret->alloc = xmlBufferAllocScheme;
  ------------------
  |  |  679|     18|  #define xmlBufferAllocScheme XML_GLOBAL_MACRO(xmlBufferAllocScheme)
  |  |  ------------------
  |  |  |  |  500|     18|  #define XML_GLOBAL_MACRO(name) (*__##name())
  |  |  ------------------
  ------------------
  136|     18|    ret->content = (xmlChar *) xmlMallocAtomic(ret->size);
  137|     18|    if (ret->content == NULL) {
  ------------------
  |  Branch (137:9): [True: 0, False: 18]
  ------------------
  138|      0|	xmlBufMemoryError(ret, "creating buffer");
  139|      0|	xmlFree(ret);
  140|      0|        return(NULL);
  141|      0|    }
  142|     18|    ret->content[0] = 0;
  143|     18|    ret->contentIO = NULL;
  144|     18|    return(ret);
  145|     18|}
xmlBufCreateSize:
  155|    709|xmlBufCreateSize(size_t size) {
  156|    709|    xmlBufPtr ret;
  157|       |
  158|    709|    if (size == SIZE_MAX)
  ------------------
  |  |   30|    709|#define SIZE_MAX ((size_t) -1)
  ------------------
  |  Branch (158:9): [True: 0, False: 709]
  ------------------
  159|      0|        return(NULL);
  160|    709|    ret = (xmlBufPtr) xmlMalloc(sizeof(xmlBuf));
  161|    709|    if (ret == NULL) {
  ------------------
  |  Branch (161:9): [True: 0, False: 709]
  ------------------
  162|      0|	xmlBufMemoryError(NULL, "creating buffer");
  163|      0|        return(NULL);
  164|      0|    }
  165|    709|    ret->use = 0;
  166|    709|    ret->error = 0;
  167|    709|    ret->buffer = NULL;
  168|    709|    ret->alloc = xmlBufferAllocScheme;
  ------------------
  |  |  679|    709|  #define xmlBufferAllocScheme XML_GLOBAL_MACRO(xmlBufferAllocScheme)
  |  |  ------------------
  |  |  |  |  500|    709|  #define XML_GLOBAL_MACRO(name) (*__##name())
  |  |  ------------------
  ------------------
  169|    709|    ret->size = (size ? size + 1 : 0);         /* +1 for ending null */
  ------------------
  |  Branch (169:18): [True: 707, False: 2]
  ------------------
  170|    709|    UPDATE_COMPAT(ret);
  ------------------
  |  |   61|    709|     if (buf->size < INT_MAX) buf->compat_size = buf->size; \
  |  |  ------------------
  |  |  |  Branch (61:10): [True: 709, False: 0]
  |  |  ------------------
  |  |   62|    709|     else buf->compat_size = INT_MAX;			    \
  |  |   63|    709|     if (buf->use < INT_MAX) buf->compat_use = buf->use; \
  |  |  ------------------
  |  |  |  Branch (63:10): [True: 709, False: 0]
  |  |  ------------------
  |  |   64|    709|     else buf->compat_use = INT_MAX;
  ------------------
  171|    709|    if (ret->size){
  ------------------
  |  Branch (171:9): [True: 707, False: 2]
  ------------------
  172|    707|        ret->content = (xmlChar *) xmlMallocAtomic(ret->size);
  173|    707|        if (ret->content == NULL) {
  ------------------
  |  Branch (173:13): [True: 0, False: 707]
  ------------------
  174|      0|	    xmlBufMemoryError(ret, "creating buffer");
  175|      0|            xmlFree(ret);
  176|      0|            return(NULL);
  177|      0|        }
  178|    707|        ret->content[0] = 0;
  179|    707|    } else
  180|      2|	ret->content = NULL;
  181|    709|    ret->contentIO = NULL;
  182|    709|    return(ret);
  183|    709|}
xmlBufDetach:
  196|      2|xmlBufDetach(xmlBufPtr buf) {
  197|      2|    xmlChar *ret;
  198|       |
  199|      2|    if (buf == NULL)
  ------------------
  |  Branch (199:9): [True: 0, False: 2]
  ------------------
  200|      0|        return(NULL);
  201|      2|    if (buf->buffer != NULL)
  ------------------
  |  Branch (201:9): [True: 0, False: 2]
  ------------------
  202|      0|        return(NULL);
  203|      2|    if (buf->error)
  ------------------
  |  Branch (203:9): [True: 0, False: 2]
  ------------------
  204|      0|        return(NULL);
  205|       |
  206|      2|    ret = buf->content;
  207|      2|    buf->content = NULL;
  208|      2|    buf->size = 0;
  209|      2|    buf->use = 0;
  210|      2|    UPDATE_COMPAT(buf);
  ------------------
  |  |   61|      2|     if (buf->size < INT_MAX) buf->compat_size = buf->size; \
  |  |  ------------------
  |  |  |  Branch (61:10): [True: 2, False: 0]
  |  |  ------------------
  |  |   62|      2|     else buf->compat_size = INT_MAX;			    \
  |  |   63|      2|     if (buf->use < INT_MAX) buf->compat_use = buf->use; \
  |  |  ------------------
  |  |  |  Branch (63:10): [True: 2, False: 0]
  |  |  ------------------
  |  |   64|      2|     else buf->compat_use = INT_MAX;
  ------------------
  211|       |
  212|      2|    return ret;
  213|      2|}
xmlBufSetAllocationScheme:
  242|    876|                          xmlBufferAllocationScheme scheme) {
  243|    876|    if ((buf == NULL) || (buf->error != 0)) {
  ------------------
  |  Branch (243:9): [True: 0, False: 876]
  |  Branch (243:26): [True: 0, False: 876]
  ------------------
  244|      0|        return(-1);
  245|      0|    }
  246|    876|    if (buf->alloc == XML_BUFFER_ALLOC_IO)
  ------------------
  |  Branch (246:9): [True: 0, False: 876]
  ------------------
  247|      0|        return(-1);
  248|    876|    if ((scheme == XML_BUFFER_ALLOC_DOUBLEIT) ||
  ------------------
  |  Branch (248:9): [True: 876, False: 0]
  ------------------
  249|    876|        (scheme == XML_BUFFER_ALLOC_EXACT) ||
  ------------------
  |  Branch (249:9): [True: 0, False: 0]
  ------------------
  250|    876|        (scheme == XML_BUFFER_ALLOC_HYBRID) ||
  ------------------
  |  Branch (250:9): [True: 0, False: 0]
  ------------------
  251|    876|	(scheme == XML_BUFFER_ALLOC_BOUNDED)) {
  ------------------
  |  Branch (251:2): [True: 0, False: 0]
  ------------------
  252|    876|	buf->alloc = scheme;
  253|    876|        if (buf->buffer)
  ------------------
  |  Branch (253:13): [True: 0, False: 876]
  ------------------
  254|      0|            buf->buffer->alloc = scheme;
  255|    876|        return(0);
  256|    876|    }
  257|       |    /*
  258|       |     * Switching a buffer ALLOC_IO has the side effect of initializing
  259|       |     * the contentIO field with the current content
  260|       |     */
  261|      0|    if (scheme == XML_BUFFER_ALLOC_IO) {
  ------------------
  |  Branch (261:9): [True: 0, False: 0]
  ------------------
  262|      0|        buf->alloc = XML_BUFFER_ALLOC_IO;
  263|      0|        buf->contentIO = buf->content;
  264|      0|    }
  265|      0|    return(-1);
  266|    876|}
xmlBufFree:
  276|    727|xmlBufFree(xmlBufPtr buf) {
  277|    727|    if (buf == NULL) {
  ------------------
  |  Branch (277:9): [True: 0, False: 727]
  ------------------
  278|      0|	return;
  279|      0|    }
  280|       |
  281|    727|    if ((buf->alloc == XML_BUFFER_ALLOC_IO) &&
  ------------------
  |  Branch (281:9): [True: 0, False: 727]
  ------------------
  282|    727|        (buf->contentIO != NULL)) {
  ------------------
  |  Branch (282:9): [True: 0, False: 0]
  ------------------
  283|      0|        xmlFree(buf->contentIO);
  284|    727|    } else if (buf->content != NULL) {
  ------------------
  |  Branch (284:16): [True: 725, False: 2]
  ------------------
  285|    725|        xmlFree(buf->content);
  286|    725|    }
  287|    727|    xmlFree(buf);
  288|    727|}
xmlBufShrink:
  328|     56|xmlBufShrink(xmlBufPtr buf, size_t len) {
  329|     56|    if ((buf == NULL) || (buf->error != 0)) return(0);
  ------------------
  |  Branch (329:9): [True: 0, False: 56]
  |  Branch (329:26): [True: 0, False: 56]
  ------------------
  330|     56|    CHECK_COMPAT(buf)
  ------------------
  |  |   72|     56|     if (buf->size != (size_t) buf->compat_size)	    \
  |  |  ------------------
  |  |  |  Branch (72:10): [True: 0, False: 56]
  |  |  ------------------
  |  |   73|     56|         if (buf->compat_size < INT_MAX)		    \
  |  |  ------------------
  |  |  |  Branch (73:14): [True: 0, False: 0]
  |  |  ------------------
  |  |   74|      0|	     buf->size = buf->compat_size;		    \
  |  |   75|     56|     if (buf->use != (size_t) buf->compat_use)		    \
  |  |  ------------------
  |  |  |  Branch (75:10): [True: 0, False: 56]
  |  |  ------------------
  |  |   76|     56|         if (buf->compat_use < INT_MAX)			    \
  |  |  ------------------
  |  |  |  Branch (76:14): [True: 0, False: 0]
  |  |  ------------------
  |  |   77|      0|	     buf->use = buf->compat_use;
  ------------------
  331|     56|    if (len == 0) return(0);
  ------------------
  |  Branch (331:9): [True: 0, False: 56]
  ------------------
  332|     56|    if (len > buf->use) return(0);
  ------------------
  |  Branch (332:9): [True: 0, False: 56]
  ------------------
  333|       |
  334|     56|    buf->use -= len;
  335|     56|    if ((buf->alloc == XML_BUFFER_ALLOC_IO) && (buf->contentIO != NULL)) {
  ------------------
  |  Branch (335:9): [True: 0, False: 56]
  |  Branch (335:48): [True: 0, False: 0]
  ------------------
  336|       |	/*
  337|       |	 * we just move the content pointer, but also make sure
  338|       |	 * the perceived buffer size has shrunk accordingly
  339|       |	 */
  340|      0|        buf->content += len;
  341|      0|	buf->size -= len;
  342|       |
  343|       |        /*
  344|       |	 * sometimes though it maybe be better to really shrink
  345|       |	 * on IO buffers
  346|       |	 */
  347|      0|	if ((buf->alloc == XML_BUFFER_ALLOC_IO) && (buf->contentIO != NULL)) {
  ------------------
  |  Branch (347:6): [True: 0, False: 0]
  |  Branch (347:45): [True: 0, False: 0]
  ------------------
  348|      0|	    size_t start_buf = buf->content - buf->contentIO;
  349|      0|	    if (start_buf >= buf->size) {
  ------------------
  |  Branch (349:10): [True: 0, False: 0]
  ------------------
  350|      0|		memmove(buf->contentIO, &buf->content[0], buf->use);
  351|      0|		buf->content = buf->contentIO;
  352|      0|		buf->content[buf->use] = 0;
  353|      0|		buf->size += start_buf;
  354|      0|	    }
  355|      0|	}
  356|     56|    } else {
  357|     56|	memmove(buf->content, &buf->content[len], buf->use);
  358|     56|	buf->content[buf->use] = 0;
  359|     56|    }
  360|     56|    UPDATE_COMPAT(buf)
  ------------------
  |  |   61|     56|     if (buf->size < INT_MAX) buf->compat_size = buf->size; \
  |  |  ------------------
  |  |  |  Branch (61:10): [True: 56, False: 0]
  |  |  ------------------
  |  |   62|     56|     else buf->compat_size = INT_MAX;			    \
  |  |   63|     56|     if (buf->use < INT_MAX) buf->compat_use = buf->use; \
  |  |  ------------------
  |  |  |  Branch (63:10): [True: 56, False: 0]
  |  |  ------------------
  |  |   64|     56|     else buf->compat_use = INT_MAX;
  ------------------
  361|     56|    return(len);
  362|     56|}
xmlBufGrow:
  443|  14.5k|xmlBufGrow(xmlBufPtr buf, int len) {
  444|  14.5k|    size_t ret;
  445|       |
  446|  14.5k|    if ((buf == NULL) || (len < 0)) return(-1);
  ------------------
  |  Branch (446:9): [True: 0, False: 14.5k]
  |  Branch (446:26): [True: 0, False: 14.5k]
  ------------------
  447|  14.5k|    if (len == 0)
  ------------------
  |  Branch (447:9): [True: 0, False: 14.5k]
  ------------------
  448|      0|        return(0);
  449|  14.5k|    ret = xmlBufGrowInternal(buf, len);
  450|  14.5k|    if (buf->error != 0)
  ------------------
  |  Branch (450:9): [True: 0, False: 14.5k]
  ------------------
  451|      0|        return(-1);
  452|  14.5k|    return(ret > INT_MAX ? INT_MAX : ret);
  ------------------
  |  Branch (452:12): [True: 0, False: 14.5k]
  ------------------
  453|  14.5k|}
xmlBufContent:
  491|    739|{
  492|    739|    if ((!buf) || (buf->error))
  ------------------
  |  Branch (492:9): [True: 0, False: 739]
  |  Branch (492:19): [True: 0, False: 739]
  ------------------
  493|      0|        return NULL;
  494|       |
  495|    739|    return(buf->content);
  496|    739|}
xmlBufEnd:
  509|  14.5k|{
  510|  14.5k|    if ((!buf) || (buf->error))
  ------------------
  |  Branch (510:9): [True: 0, False: 14.5k]
  |  Branch (510:19): [True: 0, False: 14.5k]
  ------------------
  511|      0|        return NULL;
  512|  14.5k|    CHECK_COMPAT(buf)
  ------------------
  |  |   72|  14.5k|     if (buf->size != (size_t) buf->compat_size)	    \
  |  |  ------------------
  |  |  |  Branch (72:10): [True: 0, False: 14.5k]
  |  |  ------------------
  |  |   73|  14.5k|         if (buf->compat_size < INT_MAX)		    \
  |  |  ------------------
  |  |  |  Branch (73:14): [True: 0, False: 0]
  |  |  ------------------
  |  |   74|      0|	     buf->size = buf->compat_size;		    \
  |  |   75|  14.5k|     if (buf->use != (size_t) buf->compat_use)		    \
  |  |  ------------------
  |  |  |  Branch (75:10): [True: 0, False: 14.5k]
  |  |  ------------------
  |  |   76|  14.5k|         if (buf->compat_use < INT_MAX)			    \
  |  |  ------------------
  |  |  |  Branch (76:14): [True: 0, False: 0]
  |  |  ------------------
  |  |   77|      0|	     buf->use = buf->compat_use;
  ------------------
  513|       |
  514|  14.5k|    return(&buf->content[buf->use]);
  515|  14.5k|}
xmlBufAddLen:
  529|  14.5k|xmlBufAddLen(xmlBufPtr buf, size_t len) {
  530|  14.5k|    if ((buf == NULL) || (buf->error))
  ------------------
  |  Branch (530:9): [True: 0, False: 14.5k]
  |  Branch (530:26): [True: 0, False: 14.5k]
  ------------------
  531|      0|        return(-1);
  532|  14.5k|    CHECK_COMPAT(buf)
  ------------------
  |  |   72|  14.5k|     if (buf->size != (size_t) buf->compat_size)	    \
  |  |  ------------------
  |  |  |  Branch (72:10): [True: 0, False: 14.5k]
  |  |  ------------------
  |  |   73|  14.5k|         if (buf->compat_size < INT_MAX)		    \
  |  |  ------------------
  |  |  |  Branch (73:14): [True: 0, False: 0]
  |  |  ------------------
  |  |   74|      0|	     buf->size = buf->compat_size;		    \
  |  |   75|  14.5k|     if (buf->use != (size_t) buf->compat_use)		    \
  |  |  ------------------
  |  |  |  Branch (75:10): [True: 0, False: 14.5k]
  |  |  ------------------
  |  |   76|  14.5k|         if (buf->compat_use < INT_MAX)			    \
  |  |  ------------------
  |  |  |  Branch (76:14): [True: 0, False: 0]
  |  |  ------------------
  |  |   77|      0|	     buf->use = buf->compat_use;
  ------------------
  533|  14.5k|    if (len >= (buf->size - buf->use))
  ------------------
  |  Branch (533:9): [True: 0, False: 14.5k]
  ------------------
  534|      0|        return(-1);
  535|  14.5k|    buf->use += len;
  536|  14.5k|    buf->content[buf->use] = 0;
  537|  14.5k|    UPDATE_COMPAT(buf)
  ------------------
  |  |   61|  14.5k|     if (buf->size < INT_MAX) buf->compat_size = buf->size; \
  |  |  ------------------
  |  |  |  Branch (61:10): [True: 14.5k, False: 0]
  |  |  ------------------
  |  |   62|  14.5k|     else buf->compat_size = INT_MAX;			    \
  |  |   63|  14.5k|     if (buf->use < INT_MAX) buf->compat_use = buf->use; \
  |  |  ------------------
  |  |  |  Branch (63:10): [True: 14.5k, False: 0]
  |  |  ------------------
  |  |   64|  14.5k|     else buf->compat_use = INT_MAX;
  ------------------
  538|  14.5k|    return(0);
  539|  14.5k|}
xmlBufLength:
  552|     10|{
  553|     10|    if ((!buf) || (buf->error))
  ------------------
  |  Branch (553:9): [True: 0, False: 10]
  |  Branch (553:19): [True: 0, False: 10]
  ------------------
  554|      0|        return 0;
  555|     10|    CHECK_COMPAT(buf)
  ------------------
  |  |   72|     10|     if (buf->size != (size_t) buf->compat_size)	    \
  |  |  ------------------
  |  |  |  Branch (72:10): [True: 0, False: 10]
  |  |  ------------------
  |  |   73|     10|         if (buf->compat_size < INT_MAX)		    \
  |  |  ------------------
  |  |  |  Branch (73:14): [True: 0, False: 0]
  |  |  ------------------
  |  |   74|      0|	     buf->size = buf->compat_size;		    \
  |  |   75|     10|     if (buf->use != (size_t) buf->compat_use)		    \
  |  |  ------------------
  |  |  |  Branch (75:10): [True: 0, False: 10]
  |  |  ------------------
  |  |   76|     10|         if (buf->compat_use < INT_MAX)			    \
  |  |  ------------------
  |  |  |  Branch (76:14): [True: 0, False: 0]
  |  |  ------------------
  |  |   77|      0|	     buf->use = buf->compat_use;
  ------------------
  556|       |
  557|     10|    return(buf->use);
  558|     10|}
xmlBufUse:
  571|  2.61k|{
  572|  2.61k|    if ((!buf) || (buf->error))
  ------------------
  |  Branch (572:9): [True: 0, False: 2.61k]
  |  Branch (572:19): [True: 0, False: 2.61k]
  ------------------
  573|      0|        return 0;
  574|  2.61k|    CHECK_COMPAT(buf)
  ------------------
  |  |   72|  2.61k|     if (buf->size != (size_t) buf->compat_size)	    \
  |  |  ------------------
  |  |  |  Branch (72:10): [True: 0, False: 2.61k]
  |  |  ------------------
  |  |   73|  2.61k|         if (buf->compat_size < INT_MAX)		    \
  |  |  ------------------
  |  |  |  Branch (73:14): [True: 0, False: 0]
  |  |  ------------------
  |  |   74|      0|	     buf->size = buf->compat_size;		    \
  |  |   75|  2.61k|     if (buf->use != (size_t) buf->compat_use)		    \
  |  |  ------------------
  |  |  |  Branch (75:10): [True: 0, False: 2.61k]
  |  |  ------------------
  |  |   76|  2.61k|         if (buf->compat_use < INT_MAX)			    \
  |  |  ------------------
  |  |  |  Branch (76:14): [True: 0, False: 0]
  |  |  ------------------
  |  |   77|      0|	     buf->use = buf->compat_use;
  ------------------
  575|       |
  576|  2.61k|    return(buf->use);
  577|  2.61k|}
xmlBufAvail:
  593|     32|{
  594|     32|    if ((!buf) || (buf->error))
  ------------------
  |  Branch (594:9): [True: 0, False: 32]
  |  Branch (594:19): [True: 0, False: 32]
  ------------------
  595|      0|        return 0;
  596|     32|    CHECK_COMPAT(buf)
  ------------------
  |  |   72|     32|     if (buf->size != (size_t) buf->compat_size)	    \
  |  |  ------------------
  |  |  |  Branch (72:10): [True: 0, False: 32]
  |  |  ------------------
  |  |   73|     32|         if (buf->compat_size < INT_MAX)		    \
  |  |  ------------------
  |  |  |  Branch (73:14): [True: 0, False: 0]
  |  |  ------------------
  |  |   74|      0|	     buf->size = buf->compat_size;		    \
  |  |   75|     32|     if (buf->use != (size_t) buf->compat_use)		    \
  |  |  ------------------
  |  |  |  Branch (75:10): [True: 0, False: 32]
  |  |  ------------------
  |  |   76|     32|         if (buf->compat_use < INT_MAX)			    \
  |  |  ------------------
  |  |  |  Branch (76:14): [True: 0, False: 0]
  |  |  ------------------
  |  |   77|      0|	     buf->use = buf->compat_use;
  ------------------
  597|       |
  598|     32|    return((buf->size > buf->use) ? (buf->size - buf->use - 1) : 0);
  ------------------
  |  Branch (598:12): [True: 32, False: 0]
  ------------------
  599|     32|}
xmlBufIsEmpty:
  611|     23|{
  612|     23|    if ((!buf) || (buf->error))
  ------------------
  |  Branch (612:9): [True: 0, False: 23]
  |  Branch (612:19): [True: 0, False: 23]
  ------------------
  613|      0|        return(-1);
  614|     23|    CHECK_COMPAT(buf)
  ------------------
  |  |   72|     23|     if (buf->size != (size_t) buf->compat_size)	    \
  |  |  ------------------
  |  |  |  Branch (72:10): [True: 0, False: 23]
  |  |  ------------------
  |  |   73|     23|         if (buf->compat_size < INT_MAX)		    \
  |  |  ------------------
  |  |  |  Branch (73:14): [True: 0, False: 0]
  |  |  ------------------
  |  |   74|      0|	     buf->size = buf->compat_size;		    \
  |  |   75|     23|     if (buf->use != (size_t) buf->compat_use)		    \
  |  |  ------------------
  |  |  |  Branch (75:10): [True: 0, False: 23]
  |  |  ------------------
  |  |   76|     23|         if (buf->compat_use < INT_MAX)			    \
  |  |  ------------------
  |  |  |  Branch (76:14): [True: 0, False: 0]
  |  |  ------------------
  |  |   77|      0|	     buf->use = buf->compat_use;
  ------------------
  615|       |
  616|     23|    return(buf->use == 0);
  617|     23|}
xmlBufResize:
  630|      2|{
  631|      2|    size_t newSize;
  632|      2|    xmlChar* rebuf = NULL;
  633|      2|    size_t start_buf;
  634|       |
  635|      2|    if ((buf == NULL) || (buf->error))
  ------------------
  |  Branch (635:9): [True: 0, False: 2]
  |  Branch (635:26): [True: 0, False: 2]
  ------------------
  636|      0|        return(0);
  637|      2|    CHECK_COMPAT(buf)
  ------------------
  |  |   72|      2|     if (buf->size != (size_t) buf->compat_size)	    \
  |  |  ------------------
  |  |  |  Branch (72:10): [True: 0, False: 2]
  |  |  ------------------
  |  |   73|      2|         if (buf->compat_size < INT_MAX)		    \
  |  |  ------------------
  |  |  |  Branch (73:14): [True: 0, False: 0]
  |  |  ------------------
  |  |   74|      0|	     buf->size = buf->compat_size;		    \
  |  |   75|      2|     if (buf->use != (size_t) buf->compat_use)		    \
  |  |  ------------------
  |  |  |  Branch (75:10): [True: 0, False: 2]
  |  |  ------------------
  |  |   76|      2|         if (buf->compat_use < INT_MAX)			    \
  |  |  ------------------
  |  |  |  Branch (76:14): [True: 0, False: 0]
  |  |  ------------------
  |  |   77|      0|	     buf->use = buf->compat_use;
  ------------------
  638|       |
  639|      2|    if (buf->alloc == XML_BUFFER_ALLOC_BOUNDED) {
  ------------------
  |  Branch (639:9): [True: 0, False: 2]
  ------------------
  640|       |        /*
  641|       |	 * Used to provide parsing limits
  642|       |	 */
  643|      0|        if (size >= XML_MAX_TEXT_LENGTH) {
  ------------------
  |  |   42|      0|#define XML_MAX_TEXT_LENGTH 10000000
  ------------------
  |  Branch (643:13): [True: 0, False: 0]
  ------------------
  644|      0|	    xmlBufMemoryError(buf, "buffer error: text too long\n");
  645|      0|	    return(0);
  646|      0|	}
  647|      0|    }
  648|       |
  649|       |    /* Don't resize if we don't have to */
  650|      2|    if (size < buf->size)
  ------------------
  |  Branch (650:9): [True: 0, False: 2]
  ------------------
  651|      0|        return 1;
  652|       |
  653|       |    /* figure out new size */
  654|      2|    switch (buf->alloc){
  655|      0|	case XML_BUFFER_ALLOC_IO:
  ------------------
  |  Branch (655:2): [True: 0, False: 2]
  ------------------
  656|      2|	case XML_BUFFER_ALLOC_DOUBLEIT:
  ------------------
  |  Branch (656:2): [True: 2, False: 0]
  ------------------
  657|       |	    /*take care of empty case*/
  658|      2|            if (buf->size == 0) {
  ------------------
  |  Branch (658:17): [True: 2, False: 0]
  ------------------
  659|      2|                newSize = (size > SIZE_MAX - 10 ? SIZE_MAX : size + 10);
  ------------------
  |  |   30|      2|#define SIZE_MAX ((size_t) -1)
  ------------------
                              newSize = (size > SIZE_MAX - 10 ? SIZE_MAX : size + 10);
  ------------------
  |  |   30|      0|#define SIZE_MAX ((size_t) -1)
  ------------------
  |  Branch (659:28): [True: 0, False: 2]
  ------------------
  660|      2|            } else {
  661|      0|                newSize = buf->size;
  662|      0|            }
  663|      2|	    while (size > newSize) {
  ------------------
  |  Branch (663:13): [True: 0, False: 2]
  ------------------
  664|      0|	        if (newSize > SIZE_MAX / 2) {
  ------------------
  |  |   30|      0|#define SIZE_MAX ((size_t) -1)
  ------------------
  |  Branch (664:14): [True: 0, False: 0]
  ------------------
  665|      0|	            xmlBufMemoryError(buf, "growing buffer");
  666|      0|	            return 0;
  667|      0|	        }
  668|      0|	        newSize *= 2;
  669|      0|	    }
  670|      2|	    break;
  671|      2|	case XML_BUFFER_ALLOC_EXACT:
  ------------------
  |  Branch (671:2): [True: 0, False: 2]
  ------------------
  672|      0|            newSize = (size > SIZE_MAX - 10 ? SIZE_MAX : size + 10);
  ------------------
  |  |   30|      0|#define SIZE_MAX ((size_t) -1)
  ------------------
                          newSize = (size > SIZE_MAX - 10 ? SIZE_MAX : size + 10);
  ------------------
  |  |   30|      0|#define SIZE_MAX ((size_t) -1)
  ------------------
  |  Branch (672:24): [True: 0, False: 0]
  ------------------
  673|      0|	    break;
  674|      0|        case XML_BUFFER_ALLOC_HYBRID:
  ------------------
  |  Branch (674:9): [True: 0, False: 2]
  ------------------
  675|      0|            if (buf->use < BASE_BUFFER_SIZE)
  ------------------
  |  |   58|      0|#define BASE_BUFFER_SIZE 4096
  ------------------
  |  Branch (675:17): [True: 0, False: 0]
  ------------------
  676|      0|                newSize = size;
  677|      0|            else {
  678|      0|                newSize = buf->size;
  679|      0|                while (size > newSize) {
  ------------------
  |  Branch (679:24): [True: 0, False: 0]
  ------------------
  680|      0|                    if (newSize > SIZE_MAX / 2) {
  ------------------
  |  |   30|      0|#define SIZE_MAX ((size_t) -1)
  ------------------
  |  Branch (680:25): [True: 0, False: 0]
  ------------------
  681|      0|                        xmlBufMemoryError(buf, "growing buffer");
  682|      0|                        return 0;
  683|      0|                    }
  684|      0|                    newSize *= 2;
  685|      0|                }
  686|      0|            }
  687|      0|            break;
  688|       |
  689|      0|	default:
  ------------------
  |  Branch (689:2): [True: 0, False: 2]
  ------------------
  690|      0|            newSize = (size > SIZE_MAX - 10 ? SIZE_MAX : size + 10);
  ------------------
  |  |   30|      0|#define SIZE_MAX ((size_t) -1)
  ------------------
                          newSize = (size > SIZE_MAX - 10 ? SIZE_MAX : size + 10);
  ------------------
  |  |   30|      0|#define SIZE_MAX ((size_t) -1)
  ------------------
  |  Branch (690:24): [True: 0, False: 0]
  ------------------
  691|      0|	    break;
  692|      2|    }
  693|       |
  694|      2|    if ((buf->alloc == XML_BUFFER_ALLOC_IO) && (buf->contentIO != NULL)) {
  ------------------
  |  Branch (694:9): [True: 0, False: 2]
  |  Branch (694:48): [True: 0, False: 0]
  ------------------
  695|      0|        start_buf = buf->content - buf->contentIO;
  696|       |
  697|      0|        if (start_buf > newSize) {
  ------------------
  |  Branch (697:13): [True: 0, False: 0]
  ------------------
  698|       |	    /* move data back to start */
  699|      0|	    memmove(buf->contentIO, buf->content, buf->use);
  700|      0|	    buf->content = buf->contentIO;
  701|      0|	    buf->content[buf->use] = 0;
  702|      0|	    buf->size += start_buf;
  703|      0|	} else {
  704|      0|	    rebuf = (xmlChar *) xmlRealloc(buf->contentIO, start_buf + newSize);
  705|      0|	    if (rebuf == NULL) {
  ------------------
  |  Branch (705:10): [True: 0, False: 0]
  ------------------
  706|      0|		xmlBufMemoryError(buf, "growing buffer");
  707|      0|		return 0;
  708|      0|	    }
  709|      0|	    buf->contentIO = rebuf;
  710|      0|	    buf->content = rebuf + start_buf;
  711|      0|	}
  712|      2|    } else {
  713|      2|	if (buf->content == NULL) {
  ------------------
  |  Branch (713:6): [True: 2, False: 0]
  ------------------
  714|      2|	    rebuf = (xmlChar *) xmlMallocAtomic(newSize);
  715|      2|	    buf->use = 0;
  716|      2|            if (rebuf != NULL)
  ------------------
  |  Branch (716:17): [True: 2, False: 0]
  ------------------
  717|      2|	        rebuf[buf->use] = 0;
  718|      2|	} else if (buf->size - buf->use < 100) {
  ------------------
  |  Branch (718:13): [True: 0, False: 0]
  ------------------
  719|      0|	    rebuf = (xmlChar *) xmlRealloc(buf->content, newSize);
  720|      0|        } else {
  721|       |	    /*
  722|       |	     * if we are reallocating a buffer far from being full, it's
  723|       |	     * better to make a new allocation and copy only the used range
  724|       |	     * and free the old one.
  725|       |	     */
  726|      0|	    rebuf = (xmlChar *) xmlMallocAtomic(newSize);
  727|      0|	    if (rebuf != NULL) {
  ------------------
  |  Branch (727:10): [True: 0, False: 0]
  ------------------
  728|      0|		memcpy(rebuf, buf->content, buf->use);
  729|      0|		xmlFree(buf->content);
  730|      0|		rebuf[buf->use] = 0;
  731|      0|	    }
  732|      0|	}
  733|      2|	if (rebuf == NULL) {
  ------------------
  |  Branch (733:6): [True: 0, False: 2]
  ------------------
  734|      0|	    xmlBufMemoryError(buf, "growing buffer");
  735|      0|	    return 0;
  736|      0|	}
  737|      2|	buf->content = rebuf;
  738|      2|    }
  739|      2|    buf->size = newSize;
  740|      2|    UPDATE_COMPAT(buf)
  ------------------
  |  |   61|      2|     if (buf->size < INT_MAX) buf->compat_size = buf->size; \
  |  |  ------------------
  |  |  |  Branch (61:10): [True: 2, False: 0]
  |  |  ------------------
  |  |   62|      2|     else buf->compat_size = INT_MAX;			    \
  |  |   63|      2|     if (buf->use < INT_MAX) buf->compat_use = buf->use; \
  |  |  ------------------
  |  |  |  Branch (63:10): [True: 2, False: 0]
  |  |  ------------------
  |  |   64|      2|     else buf->compat_use = INT_MAX;
  ------------------
  741|       |
  742|      2|    return 1;
  743|      2|}
xmlBufAdd:
  758|    376|xmlBufAdd(xmlBufPtr buf, const xmlChar *str, int len) {
  759|    376|    size_t needSize;
  760|       |
  761|    376|    if ((str == NULL) || (buf == NULL) || (buf->error))
  ------------------
  |  Branch (761:9): [True: 0, False: 376]
  |  Branch (761:26): [True: 0, False: 376]
  |  Branch (761:43): [True: 0, False: 376]
  ------------------
  762|      0|	return -1;
  763|    376|    CHECK_COMPAT(buf)
  ------------------
  |  |   72|    376|     if (buf->size != (size_t) buf->compat_size)	    \
  |  |  ------------------
  |  |  |  Branch (72:10): [True: 0, False: 376]
  |  |  ------------------
  |  |   73|    376|         if (buf->compat_size < INT_MAX)		    \
  |  |  ------------------
  |  |  |  Branch (73:14): [True: 0, False: 0]
  |  |  ------------------
  |  |   74|      0|	     buf->size = buf->compat_size;		    \
  |  |   75|    376|     if (buf->use != (size_t) buf->compat_use)		    \
  |  |  ------------------
  |  |  |  Branch (75:10): [True: 0, False: 376]
  |  |  ------------------
  |  |   76|    376|         if (buf->compat_use < INT_MAX)			    \
  |  |  ------------------
  |  |  |  Branch (76:14): [True: 0, False: 0]
  |  |  ------------------
  |  |   77|      0|	     buf->use = buf->compat_use;
  ------------------
  764|       |
  765|    376|    if (len < -1) {
  ------------------
  |  Branch (765:9): [True: 0, False: 376]
  ------------------
  766|      0|	return -1;
  767|      0|    }
  768|    376|    if (len == 0) return 0;
  ------------------
  |  Branch (768:9): [True: 0, False: 376]
  ------------------
  769|       |
  770|    376|    if (len < 0)
  ------------------
  |  Branch (770:9): [True: 0, False: 376]
  ------------------
  771|      0|        len = xmlStrlen(str);
  772|       |
  773|    376|    if (len < 0) return -1;
  ------------------
  |  Branch (773:9): [True: 0, False: 376]
  ------------------
  774|    376|    if (len == 0) return 0;
  ------------------
  |  Branch (774:9): [True: 0, False: 376]
  ------------------
  775|       |
  776|       |    /* Note that both buf->size and buf->use can be zero here. */
  777|    376|    if ((size_t) len >= buf->size - buf->use) {
  ------------------
  |  Branch (777:9): [True: 2, False: 374]
  ------------------
  778|      2|        if ((size_t) len >= SIZE_MAX - buf->use) {
  ------------------
  |  |   30|      2|#define SIZE_MAX ((size_t) -1)
  ------------------
  |  Branch (778:13): [True: 0, False: 2]
  ------------------
  779|      0|            xmlBufMemoryError(buf, "growing buffer past SIZE_MAX");
  780|      0|            return(-1);
  781|      0|        }
  782|      2|        needSize = buf->use + len + 1;
  783|      2|	if (buf->alloc == XML_BUFFER_ALLOC_BOUNDED) {
  ------------------
  |  Branch (783:6): [True: 0, False: 2]
  ------------------
  784|       |	    /*
  785|       |	     * Used to provide parsing limits
  786|       |	     */
  787|      0|	    if (needSize >= XML_MAX_TEXT_LENGTH) {
  ------------------
  |  |   42|      0|#define XML_MAX_TEXT_LENGTH 10000000
  ------------------
  |  Branch (787:10): [True: 0, False: 0]
  ------------------
  788|      0|		xmlBufMemoryError(buf, "buffer error: text too long\n");
  789|      0|		return(-1);
  790|      0|	    }
  791|      0|	}
  792|      2|        if (!xmlBufResize(buf, needSize)){
  ------------------
  |  Branch (792:13): [True: 0, False: 2]
  ------------------
  793|      0|	    xmlBufMemoryError(buf, "growing buffer");
  794|      0|            return XML_ERR_NO_MEMORY;
  795|      0|        }
  796|      2|    }
  797|       |
  798|    376|    memmove(&buf->content[buf->use], str, len);
  799|    376|    buf->use += len;
  800|    376|    buf->content[buf->use] = 0;
  801|    376|    UPDATE_COMPAT(buf)
  ------------------
  |  |   61|    376|     if (buf->size < INT_MAX) buf->compat_size = buf->size; \
  |  |  ------------------
  |  |  |  Branch (61:10): [True: 376, False: 0]
  |  |  ------------------
  |  |   62|    376|     else buf->compat_size = INT_MAX;			    \
  |  |   63|    376|     if (buf->use < INT_MAX) buf->compat_use = buf->use; \
  |  |  ------------------
  |  |  |  Branch (63:10): [True: 376, False: 0]
  |  |  ------------------
  |  |   64|    376|     else buf->compat_use = INT_MAX;
  ------------------
  802|    376|    return 0;
  803|    376|}
xmlBufResetInput:
 1019|    348|xmlBufResetInput(xmlBufPtr buf, xmlParserInputPtr input) {
 1020|    348|    if (input == NULL)
  ------------------
  |  Branch (1020:9): [True: 0, False: 348]
  ------------------
 1021|      0|        return(-1);
 1022|    348|    if ((buf == NULL) || (buf->error)) {
  ------------------
  |  Branch (1022:9): [True: 0, False: 348]
  |  Branch (1022:26): [True: 0, False: 348]
  ------------------
 1023|      0|        input->base = input->cur = input->end = BAD_CAST "";
  ------------------
  |  |   35|      0|#define BAD_CAST (xmlChar *)
  ------------------
 1024|      0|        return(-1);
 1025|      0|    }
 1026|    348|    CHECK_COMPAT(buf)
  ------------------
  |  |   72|    348|     if (buf->size != (size_t) buf->compat_size)	    \
  |  |  ------------------
  |  |  |  Branch (72:10): [True: 0, False: 348]
  |  |  ------------------
  |  |   73|    348|         if (buf->compat_size < INT_MAX)		    \
  |  |  ------------------
  |  |  |  Branch (73:14): [True: 0, False: 0]
  |  |  ------------------
  |  |   74|      0|	     buf->size = buf->compat_size;		    \
  |  |   75|    348|     if (buf->use != (size_t) buf->compat_use)		    \
  |  |  ------------------
  |  |  |  Branch (75:10): [True: 0, False: 348]
  |  |  ------------------
  |  |   76|    348|         if (buf->compat_use < INT_MAX)			    \
  |  |  ------------------
  |  |  |  Branch (76:14): [True: 0, False: 0]
  |  |  ------------------
  |  |   77|      0|	     buf->use = buf->compat_use;
  ------------------
 1027|    348|    input->base = input->cur = buf->content;
 1028|    348|    input->end = &buf->content[buf->use];
 1029|    348|    return(0);
 1030|    348|}
xmlBufUpdateInput:
 1044|  14.2k|xmlBufUpdateInput(xmlBufPtr buf, xmlParserInputPtr input, size_t pos) {
 1045|  14.2k|    if (input == NULL)
  ------------------
  |  Branch (1045:9): [True: 0, False: 14.2k]
  ------------------
 1046|      0|        return(-1);
 1047|       |    /*
 1048|       |     * TODO: It might be safer to keep using the buffer content if there
 1049|       |     * was an error.
 1050|       |     */
 1051|  14.2k|    if ((buf == NULL) || (buf->error)) {
  ------------------
  |  Branch (1051:9): [True: 0, False: 14.2k]
  |  Branch (1051:26): [True: 0, False: 14.2k]
  ------------------
 1052|      0|        input->base = input->cur = input->end = BAD_CAST "";
  ------------------
  |  |   35|      0|#define BAD_CAST (xmlChar *)
  ------------------
 1053|      0|        return(-1);
 1054|      0|    }
 1055|  14.2k|    CHECK_COMPAT(buf)
  ------------------
  |  |   72|  14.2k|     if (buf->size != (size_t) buf->compat_size)	    \
  |  |  ------------------
  |  |  |  Branch (72:10): [True: 0, False: 14.2k]
  |  |  ------------------
  |  |   73|  14.2k|         if (buf->compat_size < INT_MAX)		    \
  |  |  ------------------
  |  |  |  Branch (73:14): [True: 0, False: 0]
  |  |  ------------------
  |  |   74|      0|	     buf->size = buf->compat_size;		    \
  |  |   75|  14.2k|     if (buf->use != (size_t) buf->compat_use)		    \
  |  |  ------------------
  |  |  |  Branch (75:10): [True: 0, False: 14.2k]
  |  |  ------------------
  |  |   76|  14.2k|         if (buf->compat_use < INT_MAX)			    \
  |  |  ------------------
  |  |  |  Branch (76:14): [True: 0, False: 0]
  |  |  ------------------
  |  |   77|      0|	     buf->use = buf->compat_use;
  ------------------
 1056|  14.2k|    input->base = buf->content;
 1057|  14.2k|    input->cur = input->base + pos;
 1058|  14.2k|    input->end = &buf->content[buf->use];
 1059|  14.2k|    return(0);
 1060|  14.2k|}
buf.c:xmlBufGrowInternal:
  376|  14.5k|xmlBufGrowInternal(xmlBufPtr buf, size_t len) {
  377|  14.5k|    size_t size;
  378|  14.5k|    xmlChar *newbuf;
  379|       |
  380|  14.5k|    if ((buf == NULL) || (buf->error != 0)) return(0);
  ------------------
  |  Branch (380:9): [True: 0, False: 14.5k]
  |  Branch (380:26): [True: 0, False: 14.5k]
  ------------------
  381|  14.5k|    CHECK_COMPAT(buf)
  ------------------
  |  |   72|  14.5k|     if (buf->size != (size_t) buf->compat_size)	    \
  |  |  ------------------
  |  |  |  Branch (72:10): [True: 0, False: 14.5k]
  |  |  ------------------
  |  |   73|  14.5k|         if (buf->compat_size < INT_MAX)		    \
  |  |  ------------------
  |  |  |  Branch (73:14): [True: 0, False: 0]
  |  |  ------------------
  |  |   74|      0|	     buf->size = buf->compat_size;		    \
  |  |   75|  14.5k|     if (buf->use != (size_t) buf->compat_use)		    \
  |  |  ------------------
  |  |  |  Branch (75:10): [True: 0, False: 14.5k]
  |  |  ------------------
  |  |   76|  14.5k|         if (buf->compat_use < INT_MAX)			    \
  |  |  ------------------
  |  |  |  Branch (76:14): [True: 0, False: 0]
  |  |  ------------------
  |  |   77|      0|	     buf->use = buf->compat_use;
  ------------------
  382|       |
  383|  14.5k|    if (len < buf->size - buf->use)
  ------------------
  |  Branch (383:9): [True: 14.5k, False: 18]
  ------------------
  384|  14.5k|        return(buf->size - buf->use - 1);
  385|     18|    if (len >= SIZE_MAX - buf->use) {
  ------------------
  |  |   30|     18|#define SIZE_MAX ((size_t) -1)
  ------------------
  |  Branch (385:9): [True: 0, False: 18]
  ------------------
  386|      0|        xmlBufMemoryError(buf, "growing buffer past SIZE_MAX");
  387|      0|        return(0);
  388|      0|    }
  389|       |
  390|     18|    if (buf->size > (size_t) len) {
  ------------------
  |  Branch (390:9): [True: 0, False: 18]
  ------------------
  391|      0|        size = buf->size > SIZE_MAX / 2 ? SIZE_MAX : buf->size * 2;
  ------------------
  |  |   30|      0|#define SIZE_MAX ((size_t) -1)
  ------------------
                      size = buf->size > SIZE_MAX / 2 ? SIZE_MAX : buf->size * 2;
  ------------------
  |  |   30|      0|#define SIZE_MAX ((size_t) -1)
  ------------------
  |  Branch (391:16): [True: 0, False: 0]
  ------------------
  392|     18|    } else {
  393|     18|        size = buf->use + len;
  394|     18|        size = size > SIZE_MAX - 100 ? SIZE_MAX : size + 100;
  ------------------
  |  |   30|     18|#define SIZE_MAX ((size_t) -1)
  ------------------
                      size = size > SIZE_MAX - 100 ? SIZE_MAX : size + 100;
  ------------------
  |  |   30|      0|#define SIZE_MAX ((size_t) -1)
  ------------------
  |  Branch (394:16): [True: 0, False: 18]
  ------------------
  395|     18|    }
  396|       |
  397|     18|    if (buf->alloc == XML_BUFFER_ALLOC_BOUNDED) {
  ------------------
  |  Branch (397:9): [True: 0, False: 18]
  ------------------
  398|       |        /*
  399|       |	 * Used to provide parsing limits
  400|       |	 */
  401|      0|        if ((buf->use + len + 1 >= XML_MAX_TEXT_LENGTH) ||
  ------------------
  |  |   42|      0|#define XML_MAX_TEXT_LENGTH 10000000
  ------------------
  |  Branch (401:13): [True: 0, False: 0]
  ------------------
  402|      0|	    (buf->size >= XML_MAX_TEXT_LENGTH)) {
  ------------------
  |  |   42|      0|#define XML_MAX_TEXT_LENGTH 10000000
  ------------------
  |  Branch (402:6): [True: 0, False: 0]
  ------------------
  403|      0|	    xmlBufMemoryError(buf, "buffer error: text too long\n");
  404|      0|	    return(0);
  405|      0|	}
  406|      0|	if (size >= XML_MAX_TEXT_LENGTH)
  ------------------
  |  |   42|      0|#define XML_MAX_TEXT_LENGTH 10000000
  ------------------
  |  Branch (406:6): [True: 0, False: 0]
  ------------------
  407|      0|	    size = XML_MAX_TEXT_LENGTH;
  ------------------
  |  |   42|      0|#define XML_MAX_TEXT_LENGTH 10000000
  ------------------
  408|      0|    }
  409|     18|    if ((buf->alloc == XML_BUFFER_ALLOC_IO) && (buf->contentIO != NULL)) {
  ------------------
  |  Branch (409:9): [True: 0, False: 18]
  |  Branch (409:48): [True: 0, False: 0]
  ------------------
  410|      0|        size_t start_buf = buf->content - buf->contentIO;
  411|       |
  412|      0|	newbuf = (xmlChar *) xmlRealloc(buf->contentIO, start_buf + size);
  413|      0|	if (newbuf == NULL) {
  ------------------
  |  Branch (413:6): [True: 0, False: 0]
  ------------------
  414|      0|	    xmlBufMemoryError(buf, "growing buffer");
  415|      0|	    return(0);
  416|      0|	}
  417|      0|	buf->contentIO = newbuf;
  418|      0|	buf->content = newbuf + start_buf;
  419|     18|    } else {
  420|     18|	newbuf = (xmlChar *) xmlRealloc(buf->content, size);
  421|     18|	if (newbuf == NULL) {
  ------------------
  |  Branch (421:6): [True: 0, False: 18]
  ------------------
  422|      0|	    xmlBufMemoryError(buf, "growing buffer");
  423|      0|	    return(0);
  424|      0|	}
  425|     18|	buf->content = newbuf;
  426|     18|    }
  427|     18|    buf->size = size;
  428|     18|    UPDATE_COMPAT(buf)
  ------------------
  |  |   61|     18|     if (buf->size < INT_MAX) buf->compat_size = buf->size; \
  |  |  ------------------
  |  |  |  Branch (61:10): [True: 18, False: 0]
  |  |  ------------------
  |  |   62|     18|     else buf->compat_size = INT_MAX;			    \
  |  |   63|     18|     if (buf->use < INT_MAX) buf->compat_use = buf->use; \
  |  |  ------------------
  |  |  |  Branch (63:10): [True: 18, False: 0]
  |  |  ------------------
  |  |   64|     18|     else buf->compat_use = INT_MAX;
  ------------------
  429|     18|    return(buf->size - buf->use - 1);
  430|     18|}

xmlInitializeCatalog:
 3096|      2|xmlInitializeCatalog(void) {
 3097|      2|    if (xmlCatalogInitialized != 0)
  ------------------
  |  Branch (3097:9): [True: 0, False: 2]
  ------------------
 3098|      0|	return;
 3099|       |
 3100|      2|    xmlInitializeCatalogData();
 3101|      2|    xmlRMutexLock(xmlCatalogMutex);
 3102|       |
 3103|      2|    if (getenv("XML_DEBUG_CATALOG"))
  ------------------
  |  Branch (3103:9): [True: 0, False: 2]
  ------------------
 3104|      0|	xmlDebugCatalogs = 1;
 3105|       |
 3106|      2|    if (xmlDefaultCatalog == NULL) {
  ------------------
  |  Branch (3106:9): [True: 2, False: 0]
  ------------------
 3107|      2|	const char *catalogs;
 3108|      2|	char *path;
 3109|      2|	const char *cur, *paths;
 3110|      2|	xmlCatalogPtr catal;
 3111|      2|	xmlCatalogEntryPtr *nextent;
 3112|       |
 3113|      2|	catalogs = (const char *) getenv("XML_CATALOG_FILES");
 3114|      2|	if (catalogs == NULL)
  ------------------
  |  Branch (3114:6): [True: 2, False: 0]
  ------------------
 3115|       |#if defined(_WIN32) && defined(_MSC_VER)
 3116|       |    {
 3117|       |		void* hmodule;
 3118|       |		hmodule = GetModuleHandleA("libxml2.dll");
 3119|       |		if (hmodule == NULL)
 3120|       |			hmodule = GetModuleHandleA(NULL);
 3121|       |		if (hmodule != NULL) {
 3122|       |			char buf[256];
 3123|       |			unsigned long len = GetModuleFileNameA(hmodule, buf, 255);
 3124|       |			if (len != 0) {
 3125|       |				char* p = &(buf[len]);
 3126|       |				while (*p != '\\' && p > buf)
 3127|       |					p--;
 3128|       |				if (p != buf) {
 3129|       |					xmlChar* uri;
 3130|       |					strncpy(p, "\\..\\etc\\catalog", 255 - (p - buf));
 3131|       |					uri = xmlCanonicPath((const xmlChar*)buf);
 3132|       |					if (uri != NULL) {
 3133|       |						strncpy(XML_XML_DEFAULT_CATALOG, (char* )uri, 255);
 3134|       |						xmlFree(uri);
 3135|       |					}
 3136|       |				}
 3137|       |			}
 3138|       |		}
 3139|       |		catalogs = XML_XML_DEFAULT_CATALOG;
 3140|       |    }
 3141|       |#else
 3142|      2|	    catalogs = XML_XML_DEFAULT_CATALOG;
  ------------------
  |  |   70|      2|#define XML_XML_DEFAULT_CATALOG "file://" SYSCONFDIR "/xml/catalog"
  ------------------
 3143|      2|#endif
 3144|       |
 3145|      2|	catal = xmlCreateNewCatalog(XML_XML_CATALOG_TYPE,
 3146|      2|		xmlCatalogDefaultPrefer);
 3147|      2|	if (catal != NULL) {
  ------------------
  |  Branch (3147:6): [True: 2, False: 0]
  ------------------
 3148|       |	    /* the XML_CATALOG_FILES envvar is allowed to contain a
 3149|       |	       space-separated list of entries. */
 3150|      2|	    cur = catalogs;
 3151|      2|	    nextent = &catal->xml;
 3152|      4|	    while (*cur != '\0') {
  ------------------
  |  Branch (3152:13): [True: 2, False: 2]
  ------------------
 3153|      2|		while (xmlIsBlank_ch(*cur))
  ------------------
  |  |   88|      2|#define xmlIsBlank_ch(c)	(((c) == 0x20) || \
  |  |  ------------------
  |  |  |  Branch (88:27): [True: 0, False: 2]
  |  |  ------------------
  |  |   89|      2|				 ((0x9 <= (c)) && ((c) <= 0xa)) || \
  |  |  ------------------
  |  |  |  Branch (89:7): [True: 2, False: 0]
  |  |  |  Branch (89:23): [True: 0, False: 2]
  |  |  ------------------
  |  |   90|      2|				 ((c) == 0xd))
  |  |  ------------------
  |  |  |  Branch (90:6): [True: 0, False: 2]
  |  |  ------------------
  ------------------
 3154|      0|		    cur++;
 3155|      2|		if (*cur != 0) {
  ------------------
  |  Branch (3155:7): [True: 2, False: 0]
  ------------------
 3156|      2|		    paths = cur;
 3157|     68|		    while ((*cur != 0) && (!xmlIsBlank_ch(*cur)))
  ------------------
  |  |   88|     66|#define xmlIsBlank_ch(c)	(((c) == 0x20) || \
  |  |  ------------------
  |  |  |  Branch (88:27): [True: 0, False: 66]
  |  |  ------------------
  |  |   89|     66|				 ((0x9 <= (c)) && ((c) <= 0xa)) || \
  |  |  ------------------
  |  |  |  Branch (89:7): [True: 66, False: 0]
  |  |  |  Branch (89:23): [True: 0, False: 66]
  |  |  ------------------
  |  |   90|     66|				 ((c) == 0xd))
  |  |  ------------------
  |  |  |  Branch (90:6): [True: 0, False: 66]
  |  |  ------------------
  ------------------
  |  Branch (3157:14): [True: 66, False: 2]
  ------------------
 3158|     66|			cur++;
 3159|      2|		    path = (char *) xmlStrndup((const xmlChar *)paths, cur - paths);
 3160|      2|		    if (path != NULL) {
  ------------------
  |  Branch (3160:11): [True: 2, False: 0]
  ------------------
 3161|      2|			*nextent = xmlNewCatalogEntry(XML_CATA_CATALOG, NULL,
 3162|      2|				NULL, BAD_CAST path, xmlCatalogDefaultPrefer, NULL);
  ------------------
  |  |   35|      2|#define BAD_CAST (xmlChar *)
  ------------------
 3163|      2|			if (*nextent != NULL)
  ------------------
  |  Branch (3163:8): [True: 2, False: 0]
  ------------------
 3164|      2|			    nextent = &((*nextent)->next);
 3165|      2|			xmlFree(path);
 3166|      2|		    }
 3167|      2|		}
 3168|      2|	    }
 3169|      2|	    xmlDefaultCatalog = catal;
 3170|      2|	}
 3171|      2|    }
 3172|       |
 3173|      2|    xmlRMutexUnlock(xmlCatalogMutex);
 3174|      2|}
catalog.c:xmlCreateNewCatalog:
  406|      2|xmlCreateNewCatalog(xmlCatalogType type, xmlCatalogPrefer prefer) {
  407|      2|    xmlCatalogPtr ret;
  408|       |
  409|      2|    ret = (xmlCatalogPtr) xmlMalloc(sizeof(xmlCatalog));
  410|      2|    if (ret == NULL) {
  ------------------
  |  Branch (410:9): [True: 0, False: 2]
  ------------------
  411|      0|        xmlCatalogErrMemory("allocating catalog");
  412|      0|	return(NULL);
  413|      0|    }
  414|      2|    memset(ret, 0, sizeof(xmlCatalog));
  415|      2|    ret->type = type;
  416|      2|    ret->catalNr = 0;
  417|      2|    ret->catalMax = XML_MAX_SGML_CATA_DEPTH;
  ------------------
  |  |  144|      2|#define XML_MAX_SGML_CATA_DEPTH 10
  ------------------
  418|      2|    ret->prefer = prefer;
  419|      2|    if (ret->type == XML_SGML_CATALOG_TYPE)
  ------------------
  |  Branch (419:9): [True: 0, False: 2]
  ------------------
  420|      0|	ret->sgml = xmlHashCreate(10);
  421|      2|    return(ret);
  422|      2|}
catalog.c:xmlNewCatalogEntry:
  267|      2|	   xmlCatalogEntryPtr group) {
  268|      2|    xmlCatalogEntryPtr ret;
  269|      2|    xmlChar *normid = NULL;
  270|       |
  271|      2|    ret = (xmlCatalogEntryPtr) xmlMalloc(sizeof(xmlCatalogEntry));
  272|      2|    if (ret == NULL) {
  ------------------
  |  Branch (272:9): [True: 0, False: 2]
  ------------------
  273|      0|        xmlCatalogErrMemory("allocating catalog entry");
  274|      0|	return(NULL);
  275|      0|    }
  276|      2|    ret->next = NULL;
  277|      2|    ret->parent = NULL;
  278|      2|    ret->children = NULL;
  279|      2|    ret->type = type;
  280|      2|    if (type == XML_CATA_PUBLIC || type == XML_CATA_DELEGATE_PUBLIC) {
  ------------------
  |  Branch (280:9): [True: 0, False: 2]
  |  Branch (280:36): [True: 0, False: 2]
  ------------------
  281|      0|        normid = xmlCatalogNormalizePublic(name);
  282|      0|        if (normid != NULL)
  ------------------
  |  Branch (282:13): [True: 0, False: 0]
  ------------------
  283|      0|            name = (*normid != 0 ? normid : NULL);
  ------------------
  |  Branch (283:21): [True: 0, False: 0]
  ------------------
  284|      0|    }
  285|      2|    if (name != NULL)
  ------------------
  |  Branch (285:9): [True: 0, False: 2]
  ------------------
  286|      0|	ret->name = xmlStrdup(name);
  287|      2|    else
  288|      2|	ret->name = NULL;
  289|      2|    if (normid != NULL)
  ------------------
  |  Branch (289:9): [True: 0, False: 2]
  ------------------
  290|      0|        xmlFree(normid);
  291|      2|    if (value != NULL)
  ------------------
  |  Branch (291:9): [True: 0, False: 2]
  ------------------
  292|      0|	ret->value = xmlStrdup(value);
  293|      2|    else
  294|      2|	ret->value = NULL;
  295|      2|    if (URL == NULL)
  ------------------
  |  Branch (295:9): [True: 0, False: 2]
  ------------------
  296|      0|	URL = value;
  297|      2|    if (URL != NULL)
  ------------------
  |  Branch (297:9): [True: 2, False: 0]
  ------------------
  298|      2|	ret->URL = xmlStrdup(URL);
  299|      0|    else
  300|      0|	ret->URL = NULL;
  301|      2|    ret->prefer = prefer;
  302|      2|    ret->dealloc = 0;
  303|      2|    ret->depth = 0;
  304|      2|    ret->group = group;
  305|      2|    return(ret);
  306|      2|}
catalog.c:xmlInitializeCatalogData:
 3078|      2|xmlInitializeCatalogData(void) {
 3079|      2|    if (xmlCatalogInitialized != 0)
  ------------------
  |  Branch (3079:9): [True: 0, False: 2]
  ------------------
 3080|      0|	return;
 3081|       |
 3082|      2|    if (getenv("XML_DEBUG_CATALOG"))
  ------------------
  |  Branch (3082:9): [True: 0, False: 2]
  ------------------
 3083|      0|	xmlDebugCatalogs = 1;
 3084|      2|    xmlCatalogMutex = xmlNewRMutex();
 3085|       |
 3086|      2|    xmlCatalogInitialized = 1;
 3087|      2|}

xmlInitDictInternal:
   99|      2|xmlInitDictInternal(void) {
  100|      2|    xmlInitMutex(&xmlDictMutex);
  101|      2|}
xmlDictCreate:
  262|    454|xmlDictCreate(void) {
  263|    454|    xmlDictPtr dict;
  264|       |
  265|    454|    xmlInitParser();
  266|       |
  267|    454|    dict = xmlMalloc(sizeof(xmlDict));
  268|    454|    if (dict == NULL)
  ------------------
  |  Branch (268:9): [True: 0, False: 454]
  ------------------
  269|      0|        return(NULL);
  270|    454|    dict->ref_counter = 1;
  271|    454|    dict->limit = 0;
  272|       |
  273|    454|    dict->size = 0;
  274|    454|    dict->nbElems = 0;
  275|    454|    dict->table = NULL;
  276|    454|    dict->strings = NULL;
  277|    454|    dict->subdict = NULL;
  278|    454|    dict->seed = xmlRandom();
  279|    454|#ifdef FUZZING_BUILD_MODE_UNSAFE_FOR_PRODUCTION
  280|    454|    dict->seed = 0;
  281|    454|#endif
  282|    454|    return(dict);
  283|    454|}
xmlDictReference:
  317|    499|xmlDictReference(xmlDictPtr dict) {
  318|    499|    if (dict == NULL) return -1;
  ------------------
  |  Branch (318:9): [True: 0, False: 499]
  ------------------
  319|    499|    xmlMutexLock(&xmlDictMutex);
  320|    499|    dict->ref_counter++;
  321|    499|    xmlMutexUnlock(&xmlDictMutex);
  322|    499|    return(0);
  323|    499|}
xmlDictFree:
  333|    953|xmlDictFree(xmlDictPtr dict) {
  334|    953|    xmlDictStringsPtr pool, nextp;
  335|       |
  336|    953|    if (dict == NULL)
  ------------------
  |  Branch (336:9): [True: 0, False: 953]
  ------------------
  337|      0|	return;
  338|       |
  339|       |    /* decrement the counter, it may be shared by a parser and docs */
  340|    953|    xmlMutexLock(&xmlDictMutex);
  341|    953|    dict->ref_counter--;
  342|    953|    if (dict->ref_counter > 0) {
  ------------------
  |  Branch (342:9): [True: 499, False: 454]
  ------------------
  343|    499|        xmlMutexUnlock(&xmlDictMutex);
  344|    499|        return;
  345|    499|    }
  346|       |
  347|    454|    xmlMutexUnlock(&xmlDictMutex);
  348|       |
  349|    454|    if (dict->subdict != NULL) {
  ------------------
  |  Branch (349:9): [True: 0, False: 454]
  ------------------
  350|      0|        xmlDictFree(dict->subdict);
  351|      0|    }
  352|       |
  353|    454|    if (dict->table) {
  ------------------
  |  Branch (353:9): [True: 335, False: 119]
  ------------------
  354|    335|	xmlFree(dict->table);
  355|    335|    }
  356|    454|    pool = dict->strings;
  357|    789|    while (pool != NULL) {
  ------------------
  |  Branch (357:12): [True: 335, False: 454]
  ------------------
  358|    335|        nextp = pool->next;
  359|    335|	xmlFree(pool);
  360|    335|	pool = nextp;
  361|    335|    }
  362|    454|    xmlFree(dict);
  363|    454|}
xmlDictOwns:
  376|  7.67k|xmlDictOwns(xmlDictPtr dict, const xmlChar *str) {
  377|  7.67k|    xmlDictStringsPtr pool;
  378|       |
  379|  7.67k|    if ((dict == NULL) || (str == NULL))
  ------------------
  |  Branch (379:9): [True: 0, False: 7.67k]
  |  Branch (379:27): [True: 8, False: 7.66k]
  ------------------
  380|      8|	return(-1);
  381|  7.66k|    pool = dict->strings;
  382|  10.0k|    while (pool != NULL) {
  ------------------
  |  Branch (382:12): [True: 7.66k, False: 2.36k]
  ------------------
  383|  7.66k|        if ((str >= &pool->array[0]) && (str <= pool->free))
  ------------------
  |  Branch (383:13): [True: 6.66k, False: 998]
  |  Branch (383:41): [True: 5.30k, False: 1.36k]
  ------------------
  384|  5.30k|	    return(1);
  385|  2.36k|	pool = pool->next;
  386|  2.36k|    }
  387|  2.36k|    if (dict->subdict)
  ------------------
  |  Branch (387:9): [True: 0, False: 2.36k]
  ------------------
  388|      0|        return(xmlDictOwns(dict->subdict, str));
  389|  2.36k|    return(0);
  390|  2.36k|}
xmlDictSetLimit:
  421|    457|xmlDictSetLimit(xmlDictPtr dict, size_t limit) {
  422|    457|    size_t ret;
  423|       |
  424|    457|    if (dict == NULL)
  ------------------
  |  Branch (424:9): [True: 0, False: 457]
  ------------------
  425|      0|	return(0);
  426|    457|    ret = dict->limit;
  427|    457|    dict->limit = limit;
  428|    457|    return(ret);
  429|    457|}
xmlDictComputeHash:
  512|  1.23k|xmlDictComputeHash(const xmlDict *dict, const xmlChar *string) {
  513|  1.23k|    size_t len;
  514|  1.23k|    return(xmlDictHashName(dict->seed, string, SIZE_MAX, &len));
  ------------------
  |  |   35|  1.23k|  #define SIZE_MAX ((size_t) -1)
  ------------------
  515|  1.23k|}
xmlDictCombineHash:
  521|     55|xmlDictCombineHash(unsigned v1, unsigned v2) {
  522|       |    /*
  523|       |     * The upper bit of hash values is always set, so we have to operate on
  524|       |     * 31-bit hashes here.
  525|       |     */
  526|     55|    v1 ^= v2;
  527|     55|    v1 += HASH_ROL31(v2, 5);
  ------------------
  |  |  517|     55|#define HASH_ROL31(x,n) ((x) << (n) | ((x) & 0x7FFFFFFF) >> (31 - (n)))
  ------------------
  528|       |
  529|     55|    return((v1 & 0xFFFFFFFF) | 0x80000000);
  530|     55|}
xmlDictLookup:
  824|  3.49k|xmlDictLookup(xmlDictPtr dict, const xmlChar *name, int len) {
  825|  3.49k|    const xmlDictEntry *entry;
  826|       |
  827|  3.49k|    entry = xmlDictLookupInternal(dict, NULL, name, len, 1);
  828|  3.49k|    if (entry == NULL)
  ------------------
  |  Branch (828:9): [True: 8, False: 3.48k]
  ------------------
  829|      8|        return(NULL);
  830|  3.48k|    return(entry->name);
  831|  3.49k|}
xmlDictLookupHashed:
  845|  6.24k|xmlDictLookupHashed(xmlDictPtr dict, const xmlChar *name, int len) {
  846|  6.24k|    const xmlDictEntry *entry;
  847|  6.24k|    xmlHashedString ret;
  848|       |
  849|  6.24k|    entry = xmlDictLookupInternal(dict, NULL, name, len, 1);
  850|       |
  851|  6.24k|    if (entry == NULL) {
  ------------------
  |  Branch (851:9): [True: 0, False: 6.24k]
  ------------------
  852|      0|        ret.name = NULL;
  853|      0|        ret.hashValue = 0;
  854|  6.24k|    } else {
  855|  6.24k|        ret = *entry;
  856|  6.24k|    }
  857|       |
  858|  6.24k|    return(ret);
  859|  6.24k|}
xmlDictQLookup:
  894|      2|xmlDictQLookup(xmlDictPtr dict, const xmlChar *prefix, const xmlChar *name) {
  895|      2|    const xmlDictEntry *entry;
  896|       |
  897|      2|    entry = xmlDictLookupInternal(dict, prefix, name, -1, 1);
  898|      2|    if (entry == NULL)
  ------------------
  |  Branch (898:9): [True: 0, False: 2]
  ------------------
  899|      0|        return(NULL);
  900|      2|    return(entry->name);
  901|      2|}
xmlInitRandom:
  918|      2|xmlInitRandom(void) {
  919|      2|    int var;
  920|       |
  921|      2|    xmlInitMutex(&xmlRngMutex);
  922|       |
  923|       |    /* TODO: Get seed values from system PRNG */
  924|       |
  925|      2|    globalRngState[0] = (unsigned) time(NULL) ^
  926|      2|                        HASH_ROL((unsigned) (size_t) &xmlInitRandom, 8);
  ------------------
  |  |   12|      2|#define HASH_ROL(x,n) ((x) << (n) | ((x) & 0xFFFFFFFF) >> (32 - (n)))
  ------------------
  927|      2|    globalRngState[1] = HASH_ROL((unsigned) (size_t) &xmlRngMutex, 16) ^
  ------------------
  |  |   12|      2|#define HASH_ROL(x,n) ((x) << (n) | ((x) & 0xFFFFFFFF) >> (32 - (n)))
  ------------------
  928|      2|                        HASH_ROL((unsigned) (size_t) &var, 24);
  ------------------
  |  |   12|      2|#define HASH_ROL(x,n) ((x) << (n) | ((x) & 0xFFFFFFFF) >> (32 - (n)))
  ------------------
  929|      2|}
xmlRandom:
  951|    750|xmlRandom(void) {
  952|    750|#ifdef XML_THREAD_LOCAL
  953|    750|    if (!localRngInitialized) {
  ------------------
  |  Branch (953:9): [True: 1, False: 749]
  ------------------
  954|      1|        xmlMutexLock(&xmlRngMutex);
  955|      1|        localRngState[0] = xoroshiro64ss(globalRngState);
  956|      1|        localRngState[1] = xoroshiro64ss(globalRngState);
  957|      1|        localRngInitialized = 1;
  958|      1|        xmlMutexUnlock(&xmlRngMutex);
  959|      1|    }
  960|       |
  961|    750|    return(xoroshiro64ss(localRngState));
  962|       |#else
  963|       |    unsigned ret;
  964|       |
  965|       |    xmlMutexLock(&xmlRngMutex);
  966|       |    ret = xoroshiro64ss(globalRngState);
  967|       |    xmlMutexUnlock(&xmlRngMutex);
  968|       |
  969|       |    return(ret);
  970|       |#endif
  971|    750|}
dict.c:xmlDictHashName:
  465|  10.9k|                size_t *plen) {
  466|  10.9k|    unsigned h1, h2;
  467|  10.9k|    size_t i;
  468|       |
  469|  10.9k|    HASH_INIT(h1, h2, seed);
  ------------------
  |  |   23|  10.9k|    do { \
  |  |   24|  10.9k|        h1 = seed ^ 0x3b00; \
  |  |   25|  10.9k|        h2 = HASH_ROL(seed, 15); \
  |  |  ------------------
  |  |  |  |   12|  10.9k|#define HASH_ROL(x,n) ((x) << (n) | ((x) & 0xFFFFFFFF) >> (32 - (n)))
  |  |  ------------------
  |  |   26|  10.9k|    } while (0)
  |  |  ------------------
  |  |  |  Branch (26:14): [Folded - Ignored]
  |  |  ------------------
  ------------------
  470|       |
  471|  81.1k|    for (i = 0; i < maxLen && data[i]; i++) {
  ------------------
  |  Branch (471:17): [True: 72.7k, False: 8.37k]
  |  Branch (471:31): [True: 70.1k, False: 2.59k]
  ------------------
  472|  70.1k|        HASH_UPDATE(h1, h2, data[i]);
  ------------------
  |  |   29|  70.1k|    do { \
  |  |   30|  70.1k|        h1 += ch; \
  |  |   31|  70.1k|        h1 += h1 << 3; \
  |  |   32|  70.1k|        h2 += h1; \
  |  |   33|  70.1k|        h2 = HASH_ROL(h2, 7); \
  |  |  ------------------
  |  |  |  |   12|  70.1k|#define HASH_ROL(x,n) ((x) << (n) | ((x) & 0xFFFFFFFF) >> (32 - (n)))
  |  |  ------------------
  |  |   34|  70.1k|        h2 += h2 << 2; \
  |  |   35|  70.1k|    } while (0)
  |  |  ------------------
  |  |  |  Branch (35:14): [Folded - Ignored]
  |  |  ------------------
  ------------------
  473|  70.1k|    }
  474|       |
  475|  10.9k|    HASH_FINISH(h1, h2);
  ------------------
  |  |   39|  10.9k|    do { \
  |  |   40|  10.9k|        h1 ^= h2; \
  |  |   41|  10.9k|        h1 += HASH_ROL(h2, 14); \
  |  |  ------------------
  |  |  |  |   12|  10.9k|#define HASH_ROL(x,n) ((x) << (n) | ((x) & 0xFFFFFFFF) >> (32 - (n)))
  |  |  ------------------
  |  |   42|  10.9k|        h2 ^= h1; h2 += HASH_ROR(h1, 6); \
  |  |  ------------------
  |  |  |  |   13|  10.9k|#define HASH_ROR(x,n) (((x) & 0xFFFFFFFF) >> (n) | (x) << (32 - (n)))
  |  |  ------------------
  |  |   43|  10.9k|        h1 ^= h2; h1 += HASH_ROL(h2, 5); \
  |  |  ------------------
  |  |  |  |   12|  10.9k|#define HASH_ROL(x,n) ((x) << (n) | ((x) & 0xFFFFFFFF) >> (32 - (n)))
  |  |  ------------------
  |  |   44|  10.9k|        h2 ^= h1; h2 += HASH_ROR(h1, 8); \
  |  |  ------------------
  |  |  |  |   13|  10.9k|#define HASH_ROR(x,n) (((x) & 0xFFFFFFFF) >> (n) | (x) << (32 - (n)))
  |  |  ------------------
  |  |   45|  10.9k|        h2 &= 0xFFFFFFFF; \
  |  |   46|  10.9k|    } while (0)
  |  |  ------------------
  |  |  |  Branch (46:14): [Folded - Ignored]
  |  |  ------------------
  ------------------
  476|       |
  477|  10.9k|    *plen = i;
  478|  10.9k|    return(h2 | MAX_HASH_SIZE);
  ------------------
  |  |   41|  10.9k|#define MAX_HASH_SIZE (1u << 31)
  ------------------
  479|  10.9k|}
dict.c:xmlDictLookupInternal:
  679|  9.74k|                      const xmlChar *name, int maybeLen, int update) {
  680|  9.74k|    xmlDictEntry *entry = NULL;
  681|  9.74k|    const xmlChar *ret;
  682|  9.74k|    unsigned hashValue;
  683|  9.74k|    size_t maxLen, len, plen, klen;
  684|  9.74k|    int found = 0;
  685|       |
  686|  9.74k|    if ((dict == NULL) || (name == NULL))
  ------------------
  |  Branch (686:9): [True: 0, False: 9.74k]
  |  Branch (686:27): [True: 8, False: 9.73k]
  ------------------
  687|      8|	return(NULL);
  688|       |
  689|  9.73k|    maxLen = (maybeLen < 0) ? SIZE_MAX : (size_t) maybeLen;
  ------------------
  |  |   35|  1.36k|  #define SIZE_MAX ((size_t) -1)
  ------------------
  |  Branch (689:14): [True: 1.36k, False: 8.37k]
  ------------------
  690|       |
  691|  9.73k|    if (prefix == NULL) {
  ------------------
  |  Branch (691:9): [True: 9.73k, False: 2]
  ------------------
  692|  9.73k|        hashValue = xmlDictHashName(dict->seed, name, maxLen, &len);
  693|  9.73k|        if (len > INT_MAX / 2)
  ------------------
  |  Branch (693:13): [True: 0, False: 9.73k]
  ------------------
  694|      0|            return(NULL);
  695|  9.73k|        klen = len;
  696|  9.73k|    } else {
  697|      2|        hashValue = xmlDictHashQName(dict->seed, prefix, name, &plen, &len);
  698|      2|        if ((len > INT_MAX / 2) || (plen >= INT_MAX / 2 - len))
  ------------------
  |  Branch (698:13): [True: 0, False: 2]
  |  Branch (698:36): [True: 0, False: 2]
  ------------------
  699|      0|            return(NULL);
  700|      2|        klen = plen + 1 + len;
  701|      2|    }
  702|       |
  703|  9.73k|    if ((dict->limit > 0) && (klen >= dict->limit))
  ------------------
  |  Branch (703:9): [True: 9.71k, False: 18]
  |  Branch (703:30): [True: 0, False: 9.71k]
  ------------------
  704|      0|        return(NULL);
  705|       |
  706|       |    /*
  707|       |     * Check for an existing entry
  708|       |     */
  709|  9.73k|    if (dict->size > 0)
  ------------------
  |  Branch (709:9): [True: 9.39k, False: 335]
  ------------------
  710|  9.39k|        entry = xmlDictFindEntry(dict, prefix, name, klen, hashValue, &found);
  711|  9.73k|    if (found)
  ------------------
  |  Branch (711:9): [True: 5.73k, False: 4.00k]
  ------------------
  712|  5.73k|        return(entry);
  713|       |
  714|  4.00k|    if ((dict->subdict != NULL) && (dict->subdict->size > 0)) {
  ------------------
  |  Branch (714:9): [True: 0, False: 4.00k]
  |  Branch (714:36): [True: 0, False: 0]
  ------------------
  715|      0|        xmlDictEntry *subEntry;
  716|      0|        unsigned subHashValue;
  717|       |
  718|      0|        if (prefix == NULL)
  ------------------
  |  Branch (718:13): [True: 0, False: 0]
  ------------------
  719|      0|            subHashValue = xmlDictHashName(dict->subdict->seed, name, len,
  720|      0|                                           &len);
  721|      0|        else
  722|      0|            subHashValue = xmlDictHashQName(dict->subdict->seed, prefix, name,
  723|      0|                                            &plen, &len);
  724|      0|        subEntry = xmlDictFindEntry(dict->subdict, prefix, name, klen,
  725|      0|                                    subHashValue, &found);
  726|      0|        if (found)
  ------------------
  |  Branch (726:13): [True: 0, False: 0]
  ------------------
  727|      0|            return(subEntry);
  728|      0|    }
  729|       |
  730|  4.00k|    if (!update)
  ------------------
  |  Branch (730:9): [True: 0, False: 4.00k]
  ------------------
  731|      0|        return(NULL);
  732|       |
  733|       |    /*
  734|       |     * Grow the hash table if needed
  735|       |     */
  736|  4.00k|    if (dict->nbElems + 1 > dict->size / MAX_FILL_DENOM * MAX_FILL_NUM) {
  ------------------
  |  |   39|  4.00k|#define MAX_FILL_DENOM 8
  ------------------
                  if (dict->nbElems + 1 > dict->size / MAX_FILL_DENOM * MAX_FILL_NUM) {
  ------------------
  |  |   38|  4.00k|#define MAX_FILL_NUM 7
  ------------------
  |  Branch (736:9): [True: 625, False: 3.37k]
  ------------------
  737|    625|        unsigned newSize, mask, displ, pos;
  738|       |
  739|    625|        if (dict->size == 0) {
  ------------------
  |  Branch (739:13): [True: 335, False: 290]
  ------------------
  740|    335|            newSize = MIN_HASH_SIZE;
  ------------------
  |  |   40|    335|#define MIN_HASH_SIZE 8
  ------------------
  741|    335|        } else {
  742|    290|            if (dict->size >= MAX_HASH_SIZE)
  ------------------
  |  |   41|    290|#define MAX_HASH_SIZE (1u << 31)
  ------------------
  |  Branch (742:17): [True: 0, False: 290]
  ------------------
  743|      0|                return(NULL);
  744|    290|            newSize = dict->size * 2;
  745|    290|        }
  746|    625|        if (xmlDictGrow(dict, newSize) != 0)
  ------------------
  |  Branch (746:13): [True: 0, False: 625]
  ------------------
  747|      0|            return(NULL);
  748|       |
  749|       |        /*
  750|       |         * Find new entry
  751|       |         */
  752|    625|        mask = dict->size - 1;
  753|    625|        displ = 0;
  754|    625|        pos = hashValue & mask;
  755|    625|        entry = &dict->table[pos];
  756|       |
  757|    691|        while ((entry->hashValue != 0) &&
  ------------------
  |  Branch (757:16): [True: 100, False: 591]
  ------------------
  758|    691|               ((pos - entry->hashValue) & mask) >= displ) {
  ------------------
  |  Branch (758:16): [True: 66, False: 34]
  ------------------
  759|     66|            displ++;
  760|     66|            pos++;
  761|     66|            entry++;
  762|     66|            if ((pos & mask) == 0)
  ------------------
  |  Branch (762:17): [True: 5, False: 61]
  ------------------
  763|      5|                entry = dict->table;
  764|     66|        }
  765|    625|    }
  766|       |
  767|  4.00k|    if (prefix == NULL)
  ------------------
  |  Branch (767:9): [True: 3.99k, False: 2]
  ------------------
  768|  3.99k|        ret = xmlDictAddString(dict, name, len);
  769|      2|    else
  770|      2|        ret = xmlDictAddQString(dict, prefix, plen, name, len);
  771|  4.00k|    if (ret == NULL)
  ------------------
  |  Branch (771:9): [True: 0, False: 4.00k]
  ------------------
  772|      0|        return(NULL);
  773|       |
  774|       |    /*
  775|       |     * Shift the remainder of the probe sequence to the right
  776|       |     */
  777|  4.00k|    if (entry->hashValue != 0) {
  ------------------
  |  Branch (777:9): [True: 889, False: 3.11k]
  ------------------
  778|    889|        const xmlDictEntry *end = &dict->table[dict->size];
  779|    889|        const xmlDictEntry *cur = entry;
  780|       |
  781|  3.72k|        do {
  782|  3.72k|            cur++;
  783|  3.72k|            if (cur >= end)
  ------------------
  |  Branch (783:17): [True: 331, False: 3.38k]
  ------------------
  784|    331|                cur = dict->table;
  785|  3.72k|        } while (cur->hashValue != 0);
  ------------------
  |  Branch (785:18): [True: 2.83k, False: 889]
  ------------------
  786|       |
  787|    889|        if (cur < entry) {
  ------------------
  |  Branch (787:13): [True: 331, False: 558]
  ------------------
  788|       |            /*
  789|       |             * If we traversed the end of the buffer, handle the part
  790|       |             * at the start of the buffer.
  791|       |             */
  792|    331|            memmove(&dict->table[1], dict->table,
  793|    331|                    (char *) cur - (char *) dict->table);
  794|    331|            cur = end - 1;
  795|    331|            dict->table[0] = *cur;
  796|    331|        }
  797|       |
  798|    889|        memmove(&entry[1], entry, (char *) cur - (char *) entry);
  799|    889|    }
  800|       |
  801|       |    /*
  802|       |     * Populate entry
  803|       |     */
  804|  4.00k|    entry->hashValue = hashValue;
  805|  4.00k|    entry->name = ret;
  806|       |
  807|  4.00k|    dict->nbElems++;
  808|       |
  809|  4.00k|    return(entry);
  810|  4.00k|}
dict.c:xmlDictHashQName:
  484|      2|                 size_t *pplen, size_t *plen) {
  485|      2|    unsigned h1, h2;
  486|      2|    size_t i;
  487|       |
  488|      2|    HASH_INIT(h1, h2, seed);
  ------------------
  |  |   23|      2|    do { \
  |  |   24|      2|        h1 = seed ^ 0x3b00; \
  |  |   25|      2|        h2 = HASH_ROL(seed, 15); \
  |  |  ------------------
  |  |  |  |   12|      2|#define HASH_ROL(x,n) ((x) << (n) | ((x) & 0xFFFFFFFF) >> (32 - (n)))
  |  |  ------------------
  |  |   26|      2|    } while (0)
  |  |  ------------------
  |  |  |  Branch (26:14): [Folded - Ignored]
  |  |  ------------------
  ------------------
  489|       |
  490|      6|    for (i = 0; prefix[i] != 0; i++) {
  ------------------
  |  Branch (490:17): [True: 4, False: 2]
  ------------------
  491|      4|        HASH_UPDATE(h1, h2, prefix[i]);
  ------------------
  |  |   29|      4|    do { \
  |  |   30|      4|        h1 += ch; \
  |  |   31|      4|        h1 += h1 << 3; \
  |  |   32|      4|        h2 += h1; \
  |  |   33|      4|        h2 = HASH_ROL(h2, 7); \
  |  |  ------------------
  |  |  |  |   12|      4|#define HASH_ROL(x,n) ((x) << (n) | ((x) & 0xFFFFFFFF) >> (32 - (n)))
  |  |  ------------------
  |  |   34|      4|        h2 += h2 << 2; \
  |  |   35|      4|    } while (0)
  |  |  ------------------
  |  |  |  Branch (35:14): [Folded - Ignored]
  |  |  ------------------
  ------------------
  492|      4|    }
  493|      2|    *pplen = i;
  494|       |
  495|      2|    HASH_UPDATE(h1, h2, ':');
  ------------------
  |  |   29|      2|    do { \
  |  |   30|      2|        h1 += ch; \
  |  |   31|      2|        h1 += h1 << 3; \
  |  |   32|      2|        h2 += h1; \
  |  |   33|      2|        h2 = HASH_ROL(h2, 7); \
  |  |  ------------------
  |  |  |  |   12|      2|#define HASH_ROL(x,n) ((x) << (n) | ((x) & 0xFFFFFFFF) >> (32 - (n)))
  |  |  ------------------
  |  |   34|      2|        h2 += h2 << 2; \
  |  |   35|      2|    } while (0)
  |  |  ------------------
  |  |  |  Branch (35:14): [Folded - Ignored]
  |  |  ------------------
  ------------------
  496|       |
  497|     12|    for (i = 0; name[i] != 0; i++) {
  ------------------
  |  Branch (497:17): [True: 10, False: 2]
  ------------------
  498|     10|        HASH_UPDATE(h1, h2, name[i]);
  ------------------
  |  |   29|     10|    do { \
  |  |   30|     10|        h1 += ch; \
  |  |   31|     10|        h1 += h1 << 3; \
  |  |   32|     10|        h2 += h1; \
  |  |   33|     10|        h2 = HASH_ROL(h2, 7); \
  |  |  ------------------
  |  |  |  |   12|     10|#define HASH_ROL(x,n) ((x) << (n) | ((x) & 0xFFFFFFFF) >> (32 - (n)))
  |  |  ------------------
  |  |   34|     10|        h2 += h2 << 2; \
  |  |   35|     10|    } while (0)
  |  |  ------------------
  |  |  |  Branch (35:14): [Folded - Ignored]
  |  |  ------------------
  ------------------
  499|     10|    }
  500|      2|    *plen = i;
  501|       |
  502|      2|    HASH_FINISH(h1, h2);
  ------------------
  |  |   39|      2|    do { \
  |  |   40|      2|        h1 ^= h2; \
  |  |   41|      2|        h1 += HASH_ROL(h2, 14); \
  |  |  ------------------
  |  |  |  |   12|      2|#define HASH_ROL(x,n) ((x) << (n) | ((x) & 0xFFFFFFFF) >> (32 - (n)))
  |  |  ------------------
  |  |   42|      2|        h2 ^= h1; h2 += HASH_ROR(h1, 6); \
  |  |  ------------------
  |  |  |  |   13|      2|#define HASH_ROR(x,n) (((x) & 0xFFFFFFFF) >> (n) | (x) << (32 - (n)))
  |  |  ------------------
  |  |   43|      2|        h1 ^= h2; h1 += HASH_ROL(h2, 5); \
  |  |  ------------------
  |  |  |  |   12|      2|#define HASH_ROL(x,n) ((x) << (n) | ((x) & 0xFFFFFFFF) >> (32 - (n)))
  |  |  ------------------
  |  |   44|      2|        h2 ^= h1; h2 += HASH_ROR(h1, 8); \
  |  |  ------------------
  |  |  |  |   13|      2|#define HASH_ROR(x,n) (((x) & 0xFFFFFFFF) >> (n) | (x) << (32 - (n)))
  |  |  ------------------
  |  |   45|      2|        h2 &= 0xFFFFFFFF; \
  |  |   46|      2|    } while (0)
  |  |  ------------------
  |  |  |  Branch (46:14): [Folded - Ignored]
  |  |  ------------------
  ------------------
  503|       |
  504|       |    /*
  505|       |     * Always set the upper bit of hash values since 0 means an unoccupied
  506|       |     * bucket.
  507|       |     */
  508|      2|    return(h2 | MAX_HASH_SIZE);
  ------------------
  |  |   41|      2|#define MAX_HASH_SIZE (1u << 31)
  ------------------
  509|      2|}
dict.c:xmlDictFindEntry:
  549|  9.39k|                 int *pfound) {
  550|  9.39k|    xmlDictEntry *entry;
  551|  9.39k|    unsigned mask, pos, displ;
  552|  9.39k|    int found = 0;
  553|       |
  554|  9.39k|    mask = dict->size - 1;
  555|  9.39k|    pos = hashValue & mask;
  556|  9.39k|    entry = &dict->table[pos];
  557|       |
  558|  9.39k|    if (entry->hashValue != 0) {
  ------------------
  |  Branch (558:9): [True: 7.49k, False: 1.90k]
  ------------------
  559|       |        /*
  560|       |         * Robin hood hashing: abort if the displacement of the entry
  561|       |         * is smaller than the displacement of the key we look for.
  562|       |         * This also stops at the correct position when inserting.
  563|       |         */
  564|  7.49k|        displ = 0;
  565|       |
  566|  12.6k|        do {
  567|  12.6k|            if (entry->hashValue == hashValue) {
  ------------------
  |  Branch (567:17): [True: 5.73k, False: 6.92k]
  ------------------
  568|  5.73k|                if (prefix == NULL) {
  ------------------
  |  Branch (568:21): [True: 5.73k, False: 0]
  ------------------
  569|       |                    /*
  570|       |                     * name is not necessarily null-terminated.
  571|       |                     */
  572|  5.73k|                    if ((strncmp((const char *) entry->name,
  ------------------
  |  Branch (572:25): [True: 5.73k, False: 0]
  ------------------
  573|  5.73k|                                 (const char *) name, len) == 0) &&
  574|  5.73k|                        (entry->name[len] == 0)) {
  ------------------
  |  Branch (574:25): [True: 5.73k, False: 0]
  ------------------
  575|  5.73k|                        found = 1;
  576|  5.73k|                        break;
  577|  5.73k|                    }
  578|  5.73k|                } else {
  579|      0|                    if (xmlStrQEqual(prefix, name, entry->name)) {
  ------------------
  |  Branch (579:25): [True: 0, False: 0]
  ------------------
  580|      0|                        found = 1;
  581|      0|                        break;
  582|      0|                    }
  583|      0|                }
  584|  5.73k|            }
  585|       |
  586|  6.92k|            displ++;
  587|  6.92k|            pos++;
  588|  6.92k|            entry++;
  589|  6.92k|            if ((pos & mask) == 0)
  ------------------
  |  Branch (589:17): [True: 150, False: 6.77k]
  ------------------
  590|    150|                entry = dict->table;
  591|  6.92k|        } while ((entry->hashValue != 0) &&
  ------------------
  |  Branch (591:18): [True: 6.12k, False: 797]
  ------------------
  592|  6.92k|                 (((pos - entry->hashValue) & mask) >= displ));
  ------------------
  |  Branch (592:18): [True: 5.16k, False: 963]
  ------------------
  593|  7.49k|    }
  594|       |
  595|      0|    *pfound = found;
  596|  9.39k|    return(entry);
  597|  9.39k|}
dict.c:xmlDictGrow:
  609|    625|xmlDictGrow(xmlDictPtr dict, unsigned size) {
  610|    625|    const xmlDictEntry *oldentry, *oldend, *end;
  611|    625|    xmlDictEntry *table;
  612|    625|    unsigned oldsize, i;
  613|       |
  614|       |    /* Add 0 to avoid spurious -Wtype-limits warning on 64-bit GCC */
  615|    625|    if ((size_t) size + 0 > SIZE_MAX / sizeof(table[0]))
  ------------------
  |  |   35|    625|  #define SIZE_MAX ((size_t) -1)
  ------------------
  |  Branch (615:9): [True: 0, False: 625]
  ------------------
  616|      0|        return(-1);
  617|    625|    table = xmlMalloc(size * sizeof(table[0]));
  618|    625|    if (table == NULL)
  ------------------
  |  Branch (618:9): [True: 0, False: 625]
  ------------------
  619|      0|        return(-1);
  620|    625|    memset(table, 0, size * sizeof(table[0]));
  621|       |
  622|    625|    oldsize = dict->size;
  623|    625|    if (oldsize == 0)
  ------------------
  |  Branch (623:9): [True: 335, False: 290]
  ------------------
  624|    335|        goto done;
  625|       |
  626|    290|    oldend = &dict->table[oldsize];
  627|    290|    end = &table[size];
  628|       |
  629|       |    /*
  630|       |     * Robin Hood sorting order is maintained if we
  631|       |     *
  632|       |     * - compute dict indices with modulo
  633|       |     * - resize by an integer factor
  634|       |     * - start to copy from the beginning of a probe sequence
  635|       |     */
  636|    290|    oldentry = dict->table;
  637|  1.52k|    while (oldentry->hashValue != 0) {
  ------------------
  |  Branch (637:12): [True: 1.23k, False: 290]
  ------------------
  638|  1.23k|        if (++oldentry >= oldend)
  ------------------
  |  Branch (638:13): [True: 0, False: 1.23k]
  ------------------
  639|      0|            oldentry = dict->table;
  640|  1.23k|    }
  641|       |
  642|  3.61k|    for (i = 0; i < oldsize; i++) {
  ------------------
  |  Branch (642:17): [True: 3.32k, False: 290]
  ------------------
  643|  3.32k|        if (oldentry->hashValue != 0) {
  ------------------
  |  Branch (643:13): [True: 2.91k, False: 416]
  ------------------
  644|  2.91k|            xmlDictEntry *entry = &table[oldentry->hashValue & (size - 1)];
  645|       |
  646|  3.48k|            while (entry->hashValue != 0) {
  ------------------
  |  Branch (646:20): [True: 574, False: 2.91k]
  ------------------
  647|    574|                if (++entry >= end)
  ------------------
  |  Branch (647:21): [True: 85, False: 489]
  ------------------
  648|     85|                    entry = table;
  649|    574|            }
  650|  2.91k|            *entry = *oldentry;
  651|  2.91k|        }
  652|       |
  653|  3.32k|        if (++oldentry >= oldend)
  ------------------
  |  Branch (653:13): [True: 290, False: 3.03k]
  ------------------
  654|    290|            oldentry = dict->table;
  655|  3.32k|    }
  656|       |
  657|    290|    xmlFree(dict->table);
  658|       |
  659|    625|done:
  660|    625|    dict->table = table;
  661|    625|    dict->size = size;
  662|       |
  663|    625|    return(0);
  664|    290|}
dict.c:xmlDictAddString:
  136|  3.99k|xmlDictAddString(xmlDictPtr dict, const xmlChar *name, unsigned int namelen) {
  137|  3.99k|    xmlDictStringsPtr pool;
  138|  3.99k|    const xmlChar *ret;
  139|  3.99k|    size_t size = 0; /* + sizeof(_xmlDictStrings) == 1024 */
  140|  3.99k|    size_t limit = 0;
  141|       |
  142|  3.99k|    pool = dict->strings;
  143|  3.99k|    while (pool != NULL) {
  ------------------
  |  Branch (143:12): [True: 3.66k, False: 335]
  ------------------
  144|  3.66k|	if ((size_t)(pool->end - pool->free) > namelen)
  ------------------
  |  Branch (144:6): [True: 3.66k, False: 0]
  ------------------
  145|  3.66k|	    goto found_pool;
  146|      0|	if (pool->size > size) size = pool->size;
  ------------------
  |  Branch (146:6): [True: 0, False: 0]
  ------------------
  147|      0|        limit += pool->size;
  148|      0|	pool = pool->next;
  149|      0|    }
  150|       |    /*
  151|       |     * Not found, need to allocate
  152|       |     */
  153|    335|    if (pool == NULL) {
  ------------------
  |  Branch (153:9): [True: 335, False: 0]
  ------------------
  154|    335|        if ((dict->limit > 0) && (limit > dict->limit)) {
  ------------------
  |  Branch (154:13): [True: 333, False: 2]
  |  Branch (154:34): [True: 0, False: 333]
  ------------------
  155|      0|            return(NULL);
  156|      0|        }
  157|       |
  158|    335|        if (size == 0) {
  ------------------
  |  Branch (158:13): [True: 335, False: 0]
  ------------------
  159|    335|            size = 1000;
  160|    335|        } else {
  161|      0|            if (size < (SIZE_MAX - sizeof(xmlDictStrings)) / 4)
  ------------------
  |  |   35|      0|  #define SIZE_MAX ((size_t) -1)
  ------------------
  |  Branch (161:17): [True: 0, False: 0]
  ------------------
  162|      0|                size *= 4; /* exponential growth */
  163|      0|            else
  164|      0|                size = SIZE_MAX - sizeof(xmlDictStrings);
  ------------------
  |  |   35|      0|  #define SIZE_MAX ((size_t) -1)
  ------------------
  165|      0|        }
  166|    335|        if (size / 4 < namelen) {
  ------------------
  |  Branch (166:13): [True: 0, False: 335]
  ------------------
  167|      0|            if ((size_t) namelen + 0 < (SIZE_MAX - sizeof(xmlDictStrings)) / 4)
  ------------------
  |  |   35|      0|  #define SIZE_MAX ((size_t) -1)
  ------------------
  |  Branch (167:17): [True: 0, False: 0]
  ------------------
  168|      0|                size = 4 * (size_t) namelen; /* just in case ! */
  169|      0|            else
  170|      0|                return(NULL);
  171|      0|        }
  172|    335|	pool = (xmlDictStringsPtr) xmlMalloc(sizeof(xmlDictStrings) + size);
  173|    335|	if (pool == NULL)
  ------------------
  |  Branch (173:6): [True: 0, False: 335]
  ------------------
  174|      0|	    return(NULL);
  175|    335|	pool->size = size;
  176|    335|	pool->nbStrings = 0;
  177|    335|	pool->free = &pool->array[0];
  178|    335|	pool->end = &pool->array[size];
  179|    335|	pool->next = dict->strings;
  180|    335|	dict->strings = pool;
  181|    335|    }
  182|  3.99k|found_pool:
  183|  3.99k|    ret = pool->free;
  184|  3.99k|    memcpy(pool->free, name, namelen);
  185|  3.99k|    pool->free += namelen;
  186|  3.99k|    *(pool->free++) = 0;
  187|  3.99k|    pool->nbStrings++;
  188|  3.99k|    return(ret);
  189|    335|}
dict.c:xmlDictAddQString:
  206|      2|{
  207|      2|    xmlDictStringsPtr pool;
  208|      2|    const xmlChar *ret;
  209|      2|    size_t size = 0; /* + sizeof(_xmlDictStrings) == 1024 */
  210|      2|    size_t limit = 0;
  211|       |
  212|      2|    pool = dict->strings;
  213|      2|    while (pool != NULL) {
  ------------------
  |  Branch (213:12): [True: 2, False: 0]
  ------------------
  214|      2|	if ((size_t)(pool->end - pool->free) > namelen + plen + 1)
  ------------------
  |  Branch (214:6): [True: 2, False: 0]
  ------------------
  215|      2|	    goto found_pool;
  216|      0|	if (pool->size > size) size = pool->size;
  ------------------
  |  Branch (216:6): [True: 0, False: 0]
  ------------------
  217|      0|        limit += pool->size;
  218|      0|	pool = pool->next;
  219|      0|    }
  220|       |    /*
  221|       |     * Not found, need to allocate
  222|       |     */
  223|      0|    if (pool == NULL) {
  ------------------
  |  Branch (223:9): [True: 0, False: 0]
  ------------------
  224|      0|        if ((dict->limit > 0) && (limit > dict->limit)) {
  ------------------
  |  Branch (224:13): [True: 0, False: 0]
  |  Branch (224:34): [True: 0, False: 0]
  ------------------
  225|      0|            return(NULL);
  226|      0|        }
  227|       |
  228|      0|        if (size == 0) size = 1000;
  ------------------
  |  Branch (228:13): [True: 0, False: 0]
  ------------------
  229|      0|	else size *= 4; /* exponential growth */
  230|      0|        if (size < 4 * (namelen + plen + 1))
  ------------------
  |  Branch (230:13): [True: 0, False: 0]
  ------------------
  231|      0|	    size = 4 * (namelen + plen + 1); /* just in case ! */
  232|      0|	pool = (xmlDictStringsPtr) xmlMalloc(sizeof(xmlDictStrings) + size);
  233|      0|	if (pool == NULL)
  ------------------
  |  Branch (233:6): [True: 0, False: 0]
  ------------------
  234|      0|	    return(NULL);
  235|      0|	pool->size = size;
  236|      0|	pool->nbStrings = 0;
  237|      0|	pool->free = &pool->array[0];
  238|      0|	pool->end = &pool->array[size];
  239|      0|	pool->next = dict->strings;
  240|      0|	dict->strings = pool;
  241|      0|    }
  242|      2|found_pool:
  243|      2|    ret = pool->free;
  244|      2|    memcpy(pool->free, prefix, plen);
  245|      2|    pool->free += plen;
  246|      2|    *(pool->free++) = ':';
  247|      2|    memcpy(pool->free, name, namelen);
  248|      2|    pool->free += namelen;
  249|      2|    *(pool->free++) = 0;
  250|      2|    pool->nbStrings++;
  251|      2|    return(ret);
  252|      0|}
dict.c:xoroshiro64ss:
  938|    752|xoroshiro64ss(unsigned *s) {
  939|    752|    unsigned s0 = s[0];
  940|    752|    unsigned s1 = s[1];
  941|    752|    unsigned result = HASH_ROL(s0 * 0x9E3779BB, 5) * 5;
  ------------------
  |  |   12|    752|#define HASH_ROL(x,n) ((x) << (n) | ((x) & 0xFFFFFFFF) >> (32 - (n)))
  ------------------
  942|       |
  943|    752|    s1 ^= s0;
  944|    752|    s[0] = HASH_ROL(s0, 26) ^ s1 ^ (s1 << 9);
  ------------------
  |  |   12|    752|#define HASH_ROL(x,n) ((x) << (n) | ((x) & 0xFFFFFFFF) >> (32 - (n)))
  ------------------
  945|    752|    s[1] = HASH_ROL(s1, 13);
  ------------------
  |  |   12|    752|#define HASH_ROL(x,n) ((x) << (n) | ((x) & 0xFFFFFFFF) >> (32 - (n)))
  ------------------
  946|       |
  947|    752|    return(result & 0xFFFFFFFF);
  948|    752|}

isolat1ToUTF8:
  284|     18|              const unsigned char* in, int *inlen) {
  285|     18|    unsigned char* outstart = out;
  286|     18|    const unsigned char* base = in;
  287|     18|    unsigned char* outend;
  288|     18|    const unsigned char* inend;
  289|     18|    const unsigned char* instop;
  290|       |
  291|     18|    if ((out == NULL) || (in == NULL) || (outlen == NULL) || (inlen == NULL))
  ------------------
  |  Branch (291:9): [True: 0, False: 18]
  |  Branch (291:26): [True: 0, False: 18]
  |  Branch (291:42): [True: 0, False: 18]
  |  Branch (291:62): [True: 0, False: 18]
  ------------------
  292|      0|	return(XML_ENC_ERR_INTERNAL);
  293|       |
  294|     18|    outend = out + *outlen;
  295|     18|    inend = in + (*inlen);
  296|     18|    instop = inend;
  297|       |
  298|    700|    while ((in < inend) && (out < outend - 1)) {
  ------------------
  |  Branch (298:12): [True: 682, False: 18]
  |  Branch (298:28): [True: 682, False: 0]
  ------------------
  299|    682|	if (*in >= 0x80) {
  ------------------
  |  Branch (299:6): [True: 664, False: 18]
  ------------------
  300|    664|	    *out++ = (((*in) >>  6) & 0x1F) | 0xC0;
  301|    664|            *out++ = ((*in) & 0x3F) | 0x80;
  302|    664|	    ++in;
  303|    664|	}
  304|    682|	if ((instop - in) > (outend - out)) instop = in + (outend - out);
  ------------------
  |  Branch (304:6): [True: 0, False: 682]
  ------------------
  305|  3.71k|	while ((in < instop) && (*in < 0x80)) {
  ------------------
  |  Branch (305:9): [True: 3.69k, False: 18]
  |  Branch (305:26): [True: 3.03k, False: 664]
  ------------------
  306|  3.03k|	    *out++ = *in++;
  307|  3.03k|	}
  308|    682|    }
  309|     18|    if ((in < inend) && (out < outend) && (*in < 0x80)) {
  ------------------
  |  Branch (309:9): [True: 0, False: 18]
  |  Branch (309:25): [True: 0, False: 0]
  |  Branch (309:43): [True: 0, False: 0]
  ------------------
  310|      0|        *out++ = *in++;
  311|      0|    }
  312|     18|    *outlen = out - outstart;
  313|     18|    *inlen = in - base;
  314|     18|    return(*outlen);
  315|     18|}
xmlGetEncodingAlias:
 1003|     36|xmlGetEncodingAlias(const char *alias) {
 1004|     36|    int i;
 1005|     36|    char upper[100];
 1006|       |
 1007|     36|    if (alias == NULL)
  ------------------
  |  Branch (1007:9): [True: 0, False: 36]
  ------------------
 1008|      0|	return(NULL);
 1009|       |
 1010|     36|    if (xmlCharEncodingAliases == NULL)
  ------------------
  |  Branch (1010:9): [True: 36, False: 0]
  ------------------
 1011|     36|	return(NULL);
 1012|       |
 1013|      0|    for (i = 0;i < 99;i++) {
  ------------------
  |  Branch (1013:16): [True: 0, False: 0]
  ------------------
 1014|      0|        upper[i] = (char) toupper((unsigned char) alias[i]);
 1015|      0|	if (upper[i] == 0) break;
  ------------------
  |  Branch (1015:6): [True: 0, False: 0]
  ------------------
 1016|      0|    }
 1017|      0|    upper[i] = 0;
 1018|       |
 1019|       |    /*
 1020|       |     * Walk down the list looking for a definition of the alias
 1021|       |     */
 1022|      0|    for (i = 0;i < xmlCharEncodingAliasesNb;i++) {
  ------------------
  |  Branch (1022:16): [True: 0, False: 0]
  ------------------
 1023|      0|	if (!strcmp(xmlCharEncodingAliases[i].alias, upper)) {
  ------------------
  |  Branch (1023:6): [True: 0, False: 0]
  ------------------
 1024|      0|	    return(xmlCharEncodingAliases[i].name);
 1025|      0|	}
 1026|      0|    }
 1027|      0|    return(NULL);
 1028|      0|}
xmlParseCharEncoding:
 1149|      4|{
 1150|      4|    const char *alias;
 1151|      4|    char upper[500];
 1152|      4|    int i;
 1153|       |
 1154|      4|    if (name == NULL)
  ------------------
  |  Branch (1154:9): [True: 0, False: 4]
  ------------------
 1155|      0|	return(XML_CHAR_ENCODING_NONE);
 1156|       |
 1157|       |    /*
 1158|       |     * Do the alias resolution
 1159|       |     */
 1160|      4|    alias = xmlGetEncodingAlias(name);
 1161|      4|    if (alias != NULL)
  ------------------
  |  Branch (1161:9): [True: 0, False: 4]
  ------------------
 1162|      0|	name = alias;
 1163|       |
 1164|     44|    for (i = 0;i < 499;i++) {
  ------------------
  |  Branch (1164:16): [True: 44, False: 0]
  ------------------
 1165|     44|        upper[i] = (char) toupper((unsigned char) name[i]);
 1166|     44|	if (upper[i] == 0) break;
  ------------------
  |  Branch (1166:6): [True: 4, False: 40]
  ------------------
 1167|     44|    }
 1168|      4|    upper[i] = 0;
 1169|       |
 1170|      4|    if (!strcmp(upper, "")) return(XML_CHAR_ENCODING_NONE);
  ------------------
  |  Branch (1170:9): [True: 0, False: 4]
  ------------------
 1171|      4|    if (!strcmp(upper, "UTF-8")) return(XML_CHAR_ENCODING_UTF8);
  ------------------
  |  Branch (1171:9): [True: 0, False: 4]
  ------------------
 1172|      4|    if (!strcmp(upper, "UTF8")) return(XML_CHAR_ENCODING_UTF8);
  ------------------
  |  Branch (1172:9): [True: 0, False: 4]
  ------------------
 1173|       |
 1174|       |    /*
 1175|       |     * NOTE: if we were able to parse this, the endianness of UTF16 is
 1176|       |     *       already found and in use
 1177|       |     */
 1178|      4|    if (!strcmp(upper, "UTF-16")) return(XML_CHAR_ENCODING_UTF16LE);
  ------------------
  |  Branch (1178:9): [True: 0, False: 4]
  ------------------
 1179|      4|    if (!strcmp(upper, "UTF16")) return(XML_CHAR_ENCODING_UTF16LE);
  ------------------
  |  Branch (1179:9): [True: 0, False: 4]
  ------------------
 1180|       |
 1181|      4|    if (!strcmp(upper, "ISO-10646-UCS-2")) return(XML_CHAR_ENCODING_UCS2);
  ------------------
  |  Branch (1181:9): [True: 0, False: 4]
  ------------------
 1182|      4|    if (!strcmp(upper, "UCS-2")) return(XML_CHAR_ENCODING_UCS2);
  ------------------
  |  Branch (1182:9): [True: 0, False: 4]
  ------------------
 1183|      4|    if (!strcmp(upper, "UCS2")) return(XML_CHAR_ENCODING_UCS2);
  ------------------
  |  Branch (1183:9): [True: 0, False: 4]
  ------------------
 1184|       |
 1185|       |    /*
 1186|       |     * NOTE: if we were able to parse this, the endianness of UCS4 is
 1187|       |     *       already found and in use
 1188|       |     */
 1189|      4|    if (!strcmp(upper, "ISO-10646-UCS-4")) return(XML_CHAR_ENCODING_UCS4LE);
  ------------------
  |  Branch (1189:9): [True: 0, False: 4]
  ------------------
 1190|      4|    if (!strcmp(upper, "UCS-4")) return(XML_CHAR_ENCODING_UCS4LE);
  ------------------
  |  Branch (1190:9): [True: 0, False: 4]
  ------------------
 1191|      4|    if (!strcmp(upper, "UCS4")) return(XML_CHAR_ENCODING_UCS4LE);
  ------------------
  |  Branch (1191:9): [True: 0, False: 4]
  ------------------
 1192|       |
 1193|       |
 1194|      4|    if (!strcmp(upper,  "ISO-8859-1")) return(XML_CHAR_ENCODING_8859_1);
  ------------------
  |  Branch (1194:9): [True: 4, False: 0]
  ------------------
 1195|      0|    if (!strcmp(upper,  "ISO-LATIN-1")) return(XML_CHAR_ENCODING_8859_1);
  ------------------
  |  Branch (1195:9): [True: 0, False: 0]
  ------------------
 1196|      0|    if (!strcmp(upper,  "ISO LATIN 1")) return(XML_CHAR_ENCODING_8859_1);
  ------------------
  |  Branch (1196:9): [True: 0, False: 0]
  ------------------
 1197|       |
 1198|      0|    if (!strcmp(upper,  "ISO-8859-2")) return(XML_CHAR_ENCODING_8859_2);
  ------------------
  |  Branch (1198:9): [True: 0, False: 0]
  ------------------
 1199|      0|    if (!strcmp(upper,  "ISO-LATIN-2")) return(XML_CHAR_ENCODING_8859_2);
  ------------------
  |  Branch (1199:9): [True: 0, False: 0]
  ------------------
 1200|      0|    if (!strcmp(upper,  "ISO LATIN 2")) return(XML_CHAR_ENCODING_8859_2);
  ------------------
  |  Branch (1200:9): [True: 0, False: 0]
  ------------------
 1201|       |
 1202|      0|    if (!strcmp(upper,  "ISO-8859-3")) return(XML_CHAR_ENCODING_8859_3);
  ------------------
  |  Branch (1202:9): [True: 0, False: 0]
  ------------------
 1203|      0|    if (!strcmp(upper,  "ISO-8859-4")) return(XML_CHAR_ENCODING_8859_4);
  ------------------
  |  Branch (1203:9): [True: 0, False: 0]
  ------------------
 1204|      0|    if (!strcmp(upper,  "ISO-8859-5")) return(XML_CHAR_ENCODING_8859_5);
  ------------------
  |  Branch (1204:9): [True: 0, False: 0]
  ------------------
 1205|      0|    if (!strcmp(upper,  "ISO-8859-6")) return(XML_CHAR_ENCODING_8859_6);
  ------------------
  |  Branch (1205:9): [True: 0, False: 0]
  ------------------
 1206|      0|    if (!strcmp(upper,  "ISO-8859-7")) return(XML_CHAR_ENCODING_8859_7);
  ------------------
  |  Branch (1206:9): [True: 0, False: 0]
  ------------------
 1207|      0|    if (!strcmp(upper,  "ISO-8859-8")) return(XML_CHAR_ENCODING_8859_8);
  ------------------
  |  Branch (1207:9): [True: 0, False: 0]
  ------------------
 1208|      0|    if (!strcmp(upper,  "ISO-8859-9")) return(XML_CHAR_ENCODING_8859_9);
  ------------------
  |  Branch (1208:9): [True: 0, False: 0]
  ------------------
 1209|       |
 1210|      0|    if (!strcmp(upper, "ISO-2022-JP")) return(XML_CHAR_ENCODING_2022_JP);
  ------------------
  |  Branch (1210:9): [True: 0, False: 0]
  ------------------
 1211|      0|    if (!strcmp(upper, "SHIFT_JIS")) return(XML_CHAR_ENCODING_SHIFT_JIS);
  ------------------
  |  Branch (1211:9): [True: 0, False: 0]
  ------------------
 1212|      0|    if (!strcmp(upper, "EUC-JP")) return(XML_CHAR_ENCODING_EUC_JP);
  ------------------
  |  Branch (1212:9): [True: 0, False: 0]
  ------------------
 1213|       |
 1214|      0|    return(XML_CHAR_ENCODING_ERROR);
 1215|      0|}
xmlInitEncodingInternal:
 1470|      2|xmlInitEncodingInternal(void) {
 1471|      2|    unsigned short int tst = 0x1234;
 1472|      2|    unsigned char *ptr = (unsigned char *) &tst;
 1473|       |
 1474|      2|    if (*ptr == 0x12) xmlLittleEndian = 0;
  ------------------
  |  Branch (1474:9): [True: 0, False: 2]
  ------------------
 1475|      2|    else xmlLittleEndian = 1;
 1476|      2|}
xmlGetCharEncodingHandler:
 1547|    550|xmlGetCharEncodingHandler(xmlCharEncoding enc) {
 1548|    550|    xmlCharEncodingHandlerPtr handler;
 1549|       |
 1550|    550|    switch (enc) {
 1551|      0|        case XML_CHAR_ENCODING_ERROR:
  ------------------
  |  Branch (1551:9): [True: 0, False: 550]
  ------------------
 1552|      0|	    return(NULL);
 1553|    546|        case XML_CHAR_ENCODING_NONE:
  ------------------
  |  Branch (1553:9): [True: 546, False: 4]
  ------------------
 1554|    546|	    return(NULL);
 1555|      0|        case XML_CHAR_ENCODING_UTF8:
  ------------------
  |  Branch (1555:9): [True: 0, False: 550]
  ------------------
 1556|      0|	    return(NULL);
 1557|      0|        case XML_CHAR_ENCODING_UTF16LE:
  ------------------
  |  Branch (1557:9): [True: 0, False: 550]
  ------------------
 1558|      0|	    return((xmlCharEncodingHandlerPtr) xmlUTF16LEHandler);
 1559|      0|        case XML_CHAR_ENCODING_UTF16BE:
  ------------------
  |  Branch (1559:9): [True: 0, False: 550]
  ------------------
 1560|      0|	    return((xmlCharEncodingHandlerPtr) xmlUTF16BEHandler);
 1561|      0|        case XML_CHAR_ENCODING_EBCDIC:
  ------------------
  |  Branch (1561:9): [True: 0, False: 550]
  ------------------
 1562|      0|            handler = xmlFindCharEncodingHandler("EBCDIC");
 1563|      0|            if (handler != NULL) return(handler);
  ------------------
  |  Branch (1563:17): [True: 0, False: 0]
  ------------------
 1564|      0|            handler = xmlFindCharEncodingHandler("ebcdic");
 1565|      0|            if (handler != NULL) return(handler);
  ------------------
  |  Branch (1565:17): [True: 0, False: 0]
  ------------------
 1566|      0|            handler = xmlFindCharEncodingHandler("EBCDIC-US");
 1567|      0|            if (handler != NULL) return(handler);
  ------------------
  |  Branch (1567:17): [True: 0, False: 0]
  ------------------
 1568|      0|            handler = xmlFindCharEncodingHandler("IBM-037");
 1569|      0|            if (handler != NULL) return(handler);
  ------------------
  |  Branch (1569:17): [True: 0, False: 0]
  ------------------
 1570|      0|	    break;
 1571|      0|        case XML_CHAR_ENCODING_UCS4BE:
  ------------------
  |  Branch (1571:9): [True: 0, False: 550]
  ------------------
 1572|      0|            handler = xmlFindCharEncodingHandler("ISO-10646-UCS-4");
 1573|      0|            if (handler != NULL) return(handler);
  ------------------
  |  Branch (1573:17): [True: 0, False: 0]
  ------------------
 1574|      0|            handler = xmlFindCharEncodingHandler("UCS-4");
 1575|      0|            if (handler != NULL) return(handler);
  ------------------
  |  Branch (1575:17): [True: 0, False: 0]
  ------------------
 1576|      0|            handler = xmlFindCharEncodingHandler("UCS4");
 1577|      0|            if (handler != NULL) return(handler);
  ------------------
  |  Branch (1577:17): [True: 0, False: 0]
  ------------------
 1578|      0|	    break;
 1579|      0|        case XML_CHAR_ENCODING_UCS4LE:
  ------------------
  |  Branch (1579:9): [True: 0, False: 550]
  ------------------
 1580|      0|            handler = xmlFindCharEncodingHandler("ISO-10646-UCS-4");
 1581|      0|            if (handler != NULL) return(handler);
  ------------------
  |  Branch (1581:17): [True: 0, False: 0]
  ------------------
 1582|      0|            handler = xmlFindCharEncodingHandler("UCS-4");
 1583|      0|            if (handler != NULL) return(handler);
  ------------------
  |  Branch (1583:17): [True: 0, False: 0]
  ------------------
 1584|      0|            handler = xmlFindCharEncodingHandler("UCS4");
 1585|      0|            if (handler != NULL) return(handler);
  ------------------
  |  Branch (1585:17): [True: 0, False: 0]
  ------------------
 1586|      0|	    break;
 1587|      0|        case XML_CHAR_ENCODING_UCS4_2143:
  ------------------
  |  Branch (1587:9): [True: 0, False: 550]
  ------------------
 1588|      0|	    break;
 1589|      0|        case XML_CHAR_ENCODING_UCS4_3412:
  ------------------
  |  Branch (1589:9): [True: 0, False: 550]
  ------------------
 1590|      0|	    break;
 1591|      0|        case XML_CHAR_ENCODING_UCS2:
  ------------------
  |  Branch (1591:9): [True: 0, False: 550]
  ------------------
 1592|      0|            handler = xmlFindCharEncodingHandler("ISO-10646-UCS-2");
 1593|      0|            if (handler != NULL) return(handler);
  ------------------
  |  Branch (1593:17): [True: 0, False: 0]
  ------------------
 1594|      0|            handler = xmlFindCharEncodingHandler("UCS-2");
 1595|      0|            if (handler != NULL) return(handler);
  ------------------
  |  Branch (1595:17): [True: 0, False: 0]
  ------------------
 1596|      0|            handler = xmlFindCharEncodingHandler("UCS2");
 1597|      0|            if (handler != NULL) return(handler);
  ------------------
  |  Branch (1597:17): [True: 0, False: 0]
  ------------------
 1598|      0|	    break;
 1599|       |
 1600|       |	    /*
 1601|       |	     * We used to keep ISO Latin encodings native in the
 1602|       |	     * generated data. This led to so many problems that
 1603|       |	     * this has been removed. One can still change this
 1604|       |	     * back by registering no-ops encoders for those
 1605|       |	     */
 1606|      4|        case XML_CHAR_ENCODING_8859_1:
  ------------------
  |  Branch (1606:9): [True: 4, False: 546]
  ------------------
 1607|      4|	    handler = xmlFindCharEncodingHandler("ISO-8859-1");
 1608|      4|	    if (handler != NULL) return(handler);
  ------------------
  |  Branch (1608:10): [True: 4, False: 0]
  ------------------
 1609|      0|	    break;
 1610|      0|        case XML_CHAR_ENCODING_8859_2:
  ------------------
  |  Branch (1610:9): [True: 0, False: 550]
  ------------------
 1611|      0|	    handler = xmlFindCharEncodingHandler("ISO-8859-2");
 1612|      0|	    if (handler != NULL) return(handler);
  ------------------
  |  Branch (1612:10): [True: 0, False: 0]
  ------------------
 1613|      0|	    break;
 1614|      0|        case XML_CHAR_ENCODING_8859_3:
  ------------------
  |  Branch (1614:9): [True: 0, False: 550]
  ------------------
 1615|      0|	    handler = xmlFindCharEncodingHandler("ISO-8859-3");
 1616|      0|	    if (handler != NULL) return(handler);
  ------------------
  |  Branch (1616:10): [True: 0, False: 0]
  ------------------
 1617|      0|	    break;
 1618|      0|        case XML_CHAR_ENCODING_8859_4:
  ------------------
  |  Branch (1618:9): [True: 0, False: 550]
  ------------------
 1619|      0|	    handler = xmlFindCharEncodingHandler("ISO-8859-4");
 1620|      0|	    if (handler != NULL) return(handler);
  ------------------
  |  Branch (1620:10): [True: 0, False: 0]
  ------------------
 1621|      0|	    break;
 1622|      0|        case XML_CHAR_ENCODING_8859_5:
  ------------------
  |  Branch (1622:9): [True: 0, False: 550]
  ------------------
 1623|      0|	    handler = xmlFindCharEncodingHandler("ISO-8859-5");
 1624|      0|	    if (handler != NULL) return(handler);
  ------------------
  |  Branch (1624:10): [True: 0, False: 0]
  ------------------
 1625|      0|	    break;
 1626|      0|        case XML_CHAR_ENCODING_8859_6:
  ------------------
  |  Branch (1626:9): [True: 0, False: 550]
  ------------------
 1627|      0|	    handler = xmlFindCharEncodingHandler("ISO-8859-6");
 1628|      0|	    if (handler != NULL) return(handler);
  ------------------
  |  Branch (1628:10): [True: 0, False: 0]
  ------------------
 1629|      0|	    break;
 1630|      0|        case XML_CHAR_ENCODING_8859_7:
  ------------------
  |  Branch (1630:9): [True: 0, False: 550]
  ------------------
 1631|      0|	    handler = xmlFindCharEncodingHandler("ISO-8859-7");
 1632|      0|	    if (handler != NULL) return(handler);
  ------------------
  |  Branch (1632:10): [True: 0, False: 0]
  ------------------
 1633|      0|	    break;
 1634|      0|        case XML_CHAR_ENCODING_8859_8:
  ------------------
  |  Branch (1634:9): [True: 0, False: 550]
  ------------------
 1635|      0|	    handler = xmlFindCharEncodingHandler("ISO-8859-8");
 1636|      0|	    if (handler != NULL) return(handler);
  ------------------
  |  Branch (1636:10): [True: 0, False: 0]
  ------------------
 1637|      0|	    break;
 1638|      0|        case XML_CHAR_ENCODING_8859_9:
  ------------------
  |  Branch (1638:9): [True: 0, False: 550]
  ------------------
 1639|      0|	    handler = xmlFindCharEncodingHandler("ISO-8859-9");
 1640|      0|	    if (handler != NULL) return(handler);
  ------------------
  |  Branch (1640:10): [True: 0, False: 0]
  ------------------
 1641|      0|	    break;
 1642|       |
 1643|       |
 1644|      0|        case XML_CHAR_ENCODING_2022_JP:
  ------------------
  |  Branch (1644:9): [True: 0, False: 550]
  ------------------
 1645|      0|            handler = xmlFindCharEncodingHandler("ISO-2022-JP");
 1646|      0|            if (handler != NULL) return(handler);
  ------------------
  |  Branch (1646:17): [True: 0, False: 0]
  ------------------
 1647|      0|	    break;
 1648|      0|        case XML_CHAR_ENCODING_SHIFT_JIS:
  ------------------
  |  Branch (1648:9): [True: 0, False: 550]
  ------------------
 1649|      0|            handler = xmlFindCharEncodingHandler("SHIFT-JIS");
 1650|      0|            if (handler != NULL) return(handler);
  ------------------
  |  Branch (1650:17): [True: 0, False: 0]
  ------------------
 1651|      0|            handler = xmlFindCharEncodingHandler("SHIFT_JIS");
 1652|      0|            if (handler != NULL) return(handler);
  ------------------
  |  Branch (1652:17): [True: 0, False: 0]
  ------------------
 1653|      0|            handler = xmlFindCharEncodingHandler("Shift_JIS");
 1654|      0|            if (handler != NULL) return(handler);
  ------------------
  |  Branch (1654:17): [True: 0, False: 0]
  ------------------
 1655|      0|	    break;
 1656|      0|        case XML_CHAR_ENCODING_EUC_JP:
  ------------------
  |  Branch (1656:9): [True: 0, False: 550]
  ------------------
 1657|      0|            handler = xmlFindCharEncodingHandler("EUC-JP");
 1658|      0|            if (handler != NULL) return(handler);
  ------------------
  |  Branch (1658:17): [True: 0, False: 0]
  ------------------
 1659|      0|	    break;
 1660|      0|	default:
  ------------------
  |  Branch (1660:2): [True: 0, False: 550]
  ------------------
 1661|      0|	    break;
 1662|    550|    }
 1663|       |
 1664|      0|    return(NULL);
 1665|    550|}
xmlFindCharEncodingHandler:
 1677|     32|xmlFindCharEncodingHandler(const char *name) {
 1678|     32|    const char *nalias;
 1679|     32|    const char *norig;
 1680|     32|    xmlCharEncoding alias;
 1681|     32|#ifdef LIBXML_ICONV_ENABLED
 1682|     32|    xmlCharEncodingHandlerPtr enc;
 1683|     32|    iconv_t icv_in, icv_out;
 1684|     32|#endif /* LIBXML_ICONV_ENABLED */
 1685|       |#ifdef LIBXML_ICU_ENABLED
 1686|       |    xmlCharEncodingHandlerPtr encu;
 1687|       |    uconv_t *ucv_in, *ucv_out;
 1688|       |#endif /* LIBXML_ICU_ENABLED */
 1689|     32|    char upper[100];
 1690|     32|    int i;
 1691|       |
 1692|     32|    if (name == NULL) return(NULL);
  ------------------
  |  Branch (1692:9): [True: 0, False: 32]
  ------------------
 1693|     32|    if (name[0] == 0) return(NULL);
  ------------------
  |  Branch (1693:9): [True: 0, False: 32]
  ------------------
 1694|       |
 1695|       |    /*
 1696|       |     * Do the alias resolution
 1697|       |     */
 1698|     32|    norig = name;
 1699|     32|    nalias = xmlGetEncodingAlias(name);
 1700|     32|    if (nalias != NULL)
  ------------------
  |  Branch (1700:9): [True: 0, False: 32]
  ------------------
 1701|      0|	name = nalias;
 1702|       |
 1703|       |    /*
 1704|       |     * Check first for directly registered encoding names
 1705|       |     */
 1706|    282|    for (i = 0;i < 99;i++) {
  ------------------
  |  Branch (1706:16): [True: 282, False: 0]
  ------------------
 1707|    282|        upper[i] = (char) toupper((unsigned char) name[i]);
 1708|    282|	if (upper[i] == 0) break;
  ------------------
  |  Branch (1708:6): [True: 32, False: 250]
  ------------------
 1709|    282|    }
 1710|     32|    upper[i] = 0;
 1711|       |
 1712|    104|    for (i = 0; i < (int) NUM_DEFAULT_HANDLERS; i++) {
  ------------------
  |  | 1373|    104|    (sizeof(defaultHandlers) / sizeof(defaultHandlers[0]))
  ------------------
  |  Branch (1712:17): [True: 104, False: 0]
  ------------------
 1713|    104|        if (strcmp(upper, defaultHandlers[i].name) == 0)
  ------------------
  |  Branch (1713:13): [True: 32, False: 72]
  ------------------
 1714|     32|            return((xmlCharEncodingHandlerPtr) &defaultHandlers[i]);
 1715|    104|    }
 1716|       |
 1717|      0|    if (handlers != NULL) {
  ------------------
  |  Branch (1717:9): [True: 0, False: 0]
  ------------------
 1718|      0|        for (i = 0;i < nbCharEncodingHandler; i++) {
  ------------------
  |  Branch (1718:20): [True: 0, False: 0]
  ------------------
 1719|      0|            if (!strcmp(upper, handlers[i]->name)) {
  ------------------
  |  Branch (1719:17): [True: 0, False: 0]
  ------------------
 1720|      0|                return(handlers[i]);
 1721|      0|            }
 1722|      0|        }
 1723|      0|    }
 1724|       |
 1725|      0|#ifdef LIBXML_ICONV_ENABLED
 1726|       |    /* check whether iconv can handle this */
 1727|      0|    icv_in = iconv_open("UTF-8", name);
 1728|      0|    icv_out = iconv_open(name, "UTF-8");
 1729|      0|    if (icv_in == (iconv_t) -1) {
  ------------------
  |  Branch (1729:9): [True: 0, False: 0]
  ------------------
 1730|      0|        icv_in = iconv_open("UTF-8", upper);
 1731|      0|    }
 1732|      0|    if (icv_out == (iconv_t) -1) {
  ------------------
  |  Branch (1732:9): [True: 0, False: 0]
  ------------------
 1733|      0|	icv_out = iconv_open(upper, "UTF-8");
 1734|      0|    }
 1735|      0|    if ((icv_in != (iconv_t) -1) && (icv_out != (iconv_t) -1)) {
  ------------------
  |  Branch (1735:9): [True: 0, False: 0]
  |  Branch (1735:37): [True: 0, False: 0]
  ------------------
 1736|      0|	    enc = (xmlCharEncodingHandlerPtr)
 1737|      0|	          xmlMalloc(sizeof(xmlCharEncodingHandler));
 1738|      0|	    if (enc == NULL) {
  ------------------
  |  Branch (1738:10): [True: 0, False: 0]
  ------------------
 1739|      0|	        iconv_close(icv_in);
 1740|      0|	        iconv_close(icv_out);
 1741|      0|		return(NULL);
 1742|      0|	    }
 1743|      0|            memset(enc, 0, sizeof(xmlCharEncodingHandler));
 1744|      0|	    enc->name = xmlMemStrdup(name);
 1745|      0|            if (enc->name == NULL) {
  ------------------
  |  Branch (1745:17): [True: 0, False: 0]
  ------------------
 1746|      0|                xmlFree(enc);
 1747|      0|                iconv_close(icv_in);
 1748|      0|                iconv_close(icv_out);
 1749|      0|                return(NULL);
 1750|      0|            }
 1751|      0|	    enc->input = NULL;
 1752|      0|	    enc->output = NULL;
 1753|      0|	    enc->iconv_in = icv_in;
 1754|      0|	    enc->iconv_out = icv_out;
 1755|      0|	    return enc;
 1756|      0|    } else if ((icv_in != (iconv_t) -1) || icv_out != (iconv_t) -1) {
  ------------------
  |  Branch (1756:16): [True: 0, False: 0]
  |  Branch (1756:44): [True: 0, False: 0]
  ------------------
 1757|      0|	    if (icv_in != (iconv_t) -1)
  ------------------
  |  Branch (1757:10): [True: 0, False: 0]
  ------------------
 1758|      0|		iconv_close(icv_in);
 1759|      0|	    else
 1760|      0|		iconv_close(icv_out);
 1761|      0|    }
 1762|      0|#endif /* LIBXML_ICONV_ENABLED */
 1763|       |#ifdef LIBXML_ICU_ENABLED
 1764|       |    /* check whether icu can handle this */
 1765|       |    ucv_in = openIcuConverter(name, 1);
 1766|       |    ucv_out = openIcuConverter(name, 0);
 1767|       |    if (ucv_in != NULL && ucv_out != NULL) {
 1768|       |	    encu = (xmlCharEncodingHandlerPtr)
 1769|       |	           xmlMalloc(sizeof(xmlCharEncodingHandler));
 1770|       |	    if (encu == NULL) {
 1771|       |                closeIcuConverter(ucv_in);
 1772|       |                closeIcuConverter(ucv_out);
 1773|       |		return(NULL);
 1774|       |	    }
 1775|       |            memset(encu, 0, sizeof(xmlCharEncodingHandler));
 1776|       |	    encu->name = xmlMemStrdup(name);
 1777|       |            if (encu->name == NULL) {
 1778|       |                xmlFree(encu);
 1779|       |                closeIcuConverter(ucv_in);
 1780|       |                closeIcuConverter(ucv_out);
 1781|       |                return(NULL);
 1782|       |            }
 1783|       |	    encu->input = NULL;
 1784|       |	    encu->output = NULL;
 1785|       |	    encu->uconv_in = ucv_in;
 1786|       |	    encu->uconv_out = ucv_out;
 1787|       |	    return encu;
 1788|       |    } else if (ucv_in != NULL || ucv_out != NULL) {
 1789|       |            closeIcuConverter(ucv_in);
 1790|       |            closeIcuConverter(ucv_out);
 1791|       |    }
 1792|       |#endif /* LIBXML_ICU_ENABLED */
 1793|       |
 1794|       |    /*
 1795|       |     * Fallback using the canonical names
 1796|       |     */
 1797|      0|    alias = xmlParseCharEncoding(norig);
 1798|      0|    if (alias != XML_CHAR_ENCODING_ERROR) {
  ------------------
  |  Branch (1798:9): [True: 0, False: 0]
  ------------------
 1799|      0|        const char* canon;
 1800|      0|        canon = xmlGetCharEncodingName(alias);
 1801|      0|        if ((canon != NULL) && (strcmp(name, canon))) {
  ------------------
  |  Branch (1801:13): [True: 0, False: 0]
  |  Branch (1801:32): [True: 0, False: 0]
  ------------------
 1802|      0|	    return(xmlFindCharEncodingHandler(canon));
 1803|      0|        }
 1804|      0|    }
 1805|       |
 1806|       |    /* If "none of the above", give up */
 1807|      0|    return(NULL);
 1808|      0|}
xmlEncInputChunk:
 1988|     18|                 int *outlen, const unsigned char *in, int *inlen) {
 1989|     18|    int ret;
 1990|       |
 1991|     18|    if (handler->input != NULL) {
  ------------------
  |  Branch (1991:9): [True: 18, False: 0]
  ------------------
 1992|     18|        int oldinlen = *inlen;
 1993|       |
 1994|     18|        ret = handler->input(out, outlen, in, inlen);
 1995|     18|        if (ret >= 0) {
  ------------------
  |  Branch (1995:13): [True: 18, False: 0]
  ------------------
 1996|       |            /*
 1997|       |             * The built-in converters don't signal XML_ENC_ERR_SPACE.
 1998|       |             */
 1999|     18|            if (*inlen < oldinlen) {
  ------------------
  |  Branch (1999:17): [True: 0, False: 18]
  ------------------
 2000|      0|                if (*outlen > 0)
  ------------------
  |  Branch (2000:21): [True: 0, False: 0]
  ------------------
 2001|      0|                    ret = XML_ENC_ERR_SPACE;
 2002|      0|                else
 2003|      0|                    ret = XML_ENC_ERR_PARTIAL;
 2004|     18|            } else {
 2005|     18|                ret = XML_ENC_ERR_SUCCESS;
 2006|     18|            }
 2007|     18|        }
 2008|     18|    }
 2009|      0|#ifdef LIBXML_ICONV_ENABLED
 2010|      0|    else if (handler->iconv_in != NULL) {
  ------------------
  |  Branch (2010:14): [True: 0, False: 0]
  ------------------
 2011|      0|        ret = xmlIconvWrapper(handler->iconv_in, out, outlen, in, inlen);
 2012|      0|    }
 2013|      0|#endif /* LIBXML_ICONV_ENABLED */
 2014|       |#ifdef LIBXML_ICU_ENABLED
 2015|       |    else if (handler->uconv_in != NULL) {
 2016|       |        ret = xmlUconvWrapper(handler->uconv_in, 1, out, outlen, in, inlen);
 2017|       |    }
 2018|       |#endif /* LIBXML_ICU_ENABLED */
 2019|      0|    else {
 2020|      0|        *outlen = 0;
 2021|      0|        *inlen = 0;
 2022|      0|        ret = XML_ENC_ERR_INTERNAL;
 2023|      0|    }
 2024|       |
 2025|       |    /* Ignore partial errors when reading. */
 2026|     18|    if (ret == XML_ENC_ERR_PARTIAL)
  ------------------
  |  Branch (2026:9): [True: 0, False: 18]
  ------------------
 2027|      0|        ret = XML_ENC_ERR_SUCCESS;
 2028|       |
 2029|     18|    return(ret);
 2030|     18|}
xmlCharEncInput:
 2118|    446|{
 2119|    446|    int ret;
 2120|    446|    size_t avail;
 2121|    446|    size_t toconv;
 2122|    446|    int c_in;
 2123|    446|    int c_out;
 2124|    446|    xmlBufPtr in;
 2125|    446|    xmlBufPtr out;
 2126|    446|    const xmlChar *inData;
 2127|    446|    size_t inTotal = 0;
 2128|       |
 2129|    446|    if ((input == NULL) || (input->encoder == NULL) ||
  ------------------
  |  Branch (2129:9): [True: 0, False: 446]
  |  Branch (2129:28): [True: 0, False: 446]
  ------------------
 2130|    446|        (input->buffer == NULL) || (input->raw == NULL))
  ------------------
  |  Branch (2130:9): [True: 0, False: 446]
  |  Branch (2130:36): [True: 0, False: 446]
  ------------------
 2131|      0|        return(XML_ENC_ERR_INTERNAL);
 2132|    446|    out = input->buffer;
 2133|    446|    in = input->raw;
 2134|       |
 2135|    446|    toconv = xmlBufUse(in);
 2136|    446|    if (toconv == 0)
  ------------------
  |  Branch (2136:9): [True: 428, False: 18]
  ------------------
 2137|    428|        return (0);
 2138|     18|    inData = xmlBufContent(in);
 2139|     18|    inTotal = 0;
 2140|       |
 2141|     18|    do {
 2142|     18|        c_in = toconv > INT_MAX / 2 ? INT_MAX / 2 : toconv;
  ------------------
  |  Branch (2142:16): [True: 0, False: 18]
  ------------------
 2143|       |
 2144|     18|        avail = xmlBufAvail(out);
 2145|     18|        if (avail > INT_MAX)
  ------------------
  |  Branch (2145:13): [True: 0, False: 18]
  ------------------
 2146|      0|            avail = INT_MAX;
 2147|     18|        if (avail < 4096) {
  ------------------
  |  Branch (2147:13): [True: 14, False: 4]
  ------------------
 2148|     14|            if (xmlBufGrow(out, 4096) < 0) {
  ------------------
  |  Branch (2148:17): [True: 0, False: 14]
  ------------------
 2149|      0|                input->error = XML_ERR_NO_MEMORY;
 2150|      0|                return(XML_ENC_ERR_MEMORY);
 2151|      0|            }
 2152|     14|            avail = xmlBufAvail(out);
 2153|     14|        }
 2154|       |
 2155|     18|        c_in = toconv;
 2156|     18|        c_out = avail;
 2157|     18|        ret = xmlEncInputChunk(input->encoder, xmlBufEnd(out), &c_out,
 2158|     18|                               inData, &c_in);
 2159|     18|        inTotal += c_in;
 2160|     18|        inData += c_in;
 2161|     18|        toconv -= c_in;
 2162|     18|        xmlBufAddLen(out, c_out);
 2163|     18|    } while (ret == XML_ENC_ERR_SPACE);
  ------------------
  |  Branch (2163:14): [True: 0, False: 18]
  ------------------
 2164|       |
 2165|     18|    xmlBufShrink(in, inTotal);
 2166|       |
 2167|     18|    if (input->rawconsumed > ULONG_MAX - (unsigned long)c_in)
  ------------------
  |  Branch (2167:9): [True: 0, False: 18]
  ------------------
 2168|      0|        input->rawconsumed = ULONG_MAX;
 2169|     18|    else
 2170|     18|        input->rawconsumed += c_in;
 2171|       |
 2172|     18|    if ((c_out == 0) && (ret != 0)) {
  ------------------
  |  Branch (2172:9): [True: 0, False: 18]
  |  Branch (2172:25): [True: 0, False: 0]
  ------------------
 2173|      0|        if (input->error == 0)
  ------------------
  |  Branch (2173:13): [True: 0, False: 0]
  ------------------
 2174|      0|            input->error = xmlEncConvertError(ret);
 2175|      0|        return(ret);
 2176|      0|    }
 2177|       |
 2178|     18|    return (c_out);
 2179|     18|}
xmlCharEncCloseFunc:
 2454|     32|xmlCharEncCloseFunc(xmlCharEncodingHandler *handler) {
 2455|     32|    int ret = 0;
 2456|     32|    int tofree = 0;
 2457|     32|    int i = 0;
 2458|       |
 2459|     32|    if (handler == NULL) return(-1);
  ------------------
  |  Branch (2459:9): [True: 0, False: 32]
  ------------------
 2460|       |
 2461|    104|    for (i = 0; i < (int) NUM_DEFAULT_HANDLERS; i++) {
  ------------------
  |  | 1373|    104|    (sizeof(defaultHandlers) / sizeof(defaultHandlers[0]))
  ------------------
  |  Branch (2461:17): [True: 104, False: 0]
  ------------------
 2462|    104|        if (handler == &defaultHandlers[i])
  ------------------
  |  Branch (2462:13): [True: 32, False: 72]
  ------------------
 2463|     32|            return(0);
 2464|    104|    }
 2465|       |
 2466|      0|    if (handlers != NULL) {
  ------------------
  |  Branch (2466:9): [True: 0, False: 0]
  ------------------
 2467|      0|        for (i = 0;i < nbCharEncodingHandler; i++) {
  ------------------
  |  Branch (2467:20): [True: 0, False: 0]
  ------------------
 2468|      0|            if (handler == handlers[i])
  ------------------
  |  Branch (2468:17): [True: 0, False: 0]
  ------------------
 2469|      0|                return(0);
 2470|      0|	}
 2471|      0|    }
 2472|      0|#ifdef LIBXML_ICONV_ENABLED
 2473|       |    /*
 2474|       |     * Iconv handlers can be used only once, free the whole block.
 2475|       |     * and the associated icon resources.
 2476|       |     */
 2477|      0|    if ((handler->iconv_out != NULL) || (handler->iconv_in != NULL)) {
  ------------------
  |  Branch (2477:9): [True: 0, False: 0]
  |  Branch (2477:41): [True: 0, False: 0]
  ------------------
 2478|      0|        tofree = 1;
 2479|      0|	if (handler->iconv_out != NULL) {
  ------------------
  |  Branch (2479:6): [True: 0, False: 0]
  ------------------
 2480|      0|	    if (iconv_close(handler->iconv_out))
  ------------------
  |  Branch (2480:10): [True: 0, False: 0]
  ------------------
 2481|      0|		ret = -1;
 2482|      0|	    handler->iconv_out = NULL;
 2483|      0|	}
 2484|      0|	if (handler->iconv_in != NULL) {
  ------------------
  |  Branch (2484:6): [True: 0, False: 0]
  ------------------
 2485|      0|	    if (iconv_close(handler->iconv_in))
  ------------------
  |  Branch (2485:10): [True: 0, False: 0]
  ------------------
 2486|      0|		ret = -1;
 2487|      0|	    handler->iconv_in = NULL;
 2488|      0|	}
 2489|      0|    }
 2490|      0|#endif /* LIBXML_ICONV_ENABLED */
 2491|       |#ifdef LIBXML_ICU_ENABLED
 2492|       |    if ((handler->uconv_out != NULL) || (handler->uconv_in != NULL)) {
 2493|       |        tofree = 1;
 2494|       |	if (handler->uconv_out != NULL) {
 2495|       |	    closeIcuConverter(handler->uconv_out);
 2496|       |	    handler->uconv_out = NULL;
 2497|       |	}
 2498|       |	if (handler->uconv_in != NULL) {
 2499|       |	    closeIcuConverter(handler->uconv_in);
 2500|       |	    handler->uconv_in = NULL;
 2501|       |	}
 2502|       |    }
 2503|       |#endif
 2504|      0|    if (tofree) {
  ------------------
  |  Branch (2504:9): [True: 0, False: 0]
  ------------------
 2505|       |        /* free up only dynamic handlers iconv/uconv */
 2506|      0|        if (handler->name != NULL)
  ------------------
  |  Branch (2506:13): [True: 0, False: 0]
  ------------------
 2507|      0|            xmlFree(handler->name);
 2508|      0|        handler->name = NULL;
 2509|      0|        xmlFree(handler);
 2510|      0|    }
 2511|       |
 2512|      0|    return(ret);
 2513|      0|}

xmlGetPredefinedEntity:
  295|     10|xmlGetPredefinedEntity(const xmlChar *name) {
  296|     10|    if (name == NULL) return(NULL);
  ------------------
  |  Branch (296:9): [True: 0, False: 10]
  ------------------
  297|     10|    switch (name[0]) {
  298|      0|        case 'l':
  ------------------
  |  Branch (298:9): [True: 0, False: 10]
  ------------------
  299|      0|	    if (xmlStrEqual(name, BAD_CAST "lt"))
  ------------------
  |  |   35|      0|#define BAD_CAST (xmlChar *)
  ------------------
  |  Branch (299:10): [True: 0, False: 0]
  ------------------
  300|      0|	        return(&xmlEntityLt);
  301|      0|	    break;
  302|      0|        case 'g':
  ------------------
  |  Branch (302:9): [True: 0, False: 10]
  ------------------
  303|      0|	    if (xmlStrEqual(name, BAD_CAST "gt"))
  ------------------
  |  |   35|      0|#define BAD_CAST (xmlChar *)
  ------------------
  |  Branch (303:10): [True: 0, False: 0]
  ------------------
  304|      0|	        return(&xmlEntityGt);
  305|      0|	    break;
  306|     10|        case 'a':
  ------------------
  |  Branch (306:9): [True: 10, False: 0]
  ------------------
  307|     10|	    if (xmlStrEqual(name, BAD_CAST "amp"))
  ------------------
  |  |   35|     10|#define BAD_CAST (xmlChar *)
  ------------------
  |  Branch (307:10): [True: 0, False: 10]
  ------------------
  308|      0|	        return(&xmlEntityAmp);
  309|     10|	    if (xmlStrEqual(name, BAD_CAST "apos"))
  ------------------
  |  |   35|     10|#define BAD_CAST (xmlChar *)
  ------------------
  |  Branch (309:10): [True: 0, False: 10]
  ------------------
  310|      0|	        return(&xmlEntityApos);
  311|     10|	    break;
  312|     10|        case 'q':
  ------------------
  |  Branch (312:9): [True: 0, False: 10]
  ------------------
  313|      0|	    if (xmlStrEqual(name, BAD_CAST "quot"))
  ------------------
  |  |   35|      0|#define BAD_CAST (xmlChar *)
  ------------------
  |  Branch (313:10): [True: 0, False: 0]
  ------------------
  314|      0|	        return(&xmlEntityQuot);
  315|      0|	    break;
  316|      0|	default:
  ------------------
  |  Branch (316:2): [True: 0, False: 10]
  ------------------
  317|      0|	    break;
  318|     10|    }
  319|     10|    return(NULL);
  320|     10|}
xmlGetDocEntity:
  540|      4|xmlGetDocEntity(const xmlDoc *doc, const xmlChar *name) {
  541|      4|    xmlEntityPtr cur;
  542|      4|    xmlEntitiesTablePtr table;
  543|       |
  544|      4|    if (doc != NULL) {
  ------------------
  |  Branch (544:9): [True: 4, False: 0]
  ------------------
  545|      4|	if ((doc->intSubset != NULL) && (doc->intSubset->entities != NULL)) {
  ------------------
  |  Branch (545:6): [True: 0, False: 4]
  |  Branch (545:34): [True: 0, False: 0]
  ------------------
  546|      0|	    table = (xmlEntitiesTablePtr) doc->intSubset->entities;
  547|      0|	    cur = xmlGetEntityFromTable(table, name);
  548|      0|	    if (cur != NULL)
  ------------------
  |  Branch (548:10): [True: 0, False: 0]
  ------------------
  549|      0|		return(cur);
  550|      0|	}
  551|      4|	if (doc->standalone != 1) {
  ------------------
  |  Branch (551:6): [True: 4, False: 0]
  ------------------
  552|      4|	    if ((doc->extSubset != NULL) &&
  ------------------
  |  Branch (552:10): [True: 0, False: 4]
  ------------------
  553|      4|		(doc->extSubset->entities != NULL)) {
  ------------------
  |  Branch (553:3): [True: 0, False: 0]
  ------------------
  554|      0|		table = (xmlEntitiesTablePtr) doc->extSubset->entities;
  555|      0|		cur = xmlGetEntityFromTable(table, name);
  556|      0|		if (cur != NULL)
  ------------------
  |  Branch (556:7): [True: 0, False: 0]
  ------------------
  557|      0|		    return(cur);
  558|      0|	    }
  559|      4|	}
  560|      4|    }
  561|      4|    return(xmlGetPredefinedEntity(name));
  562|      4|}

xmlSetGenericErrorFunc:
  114|      2|xmlSetGenericErrorFunc(void *ctx, xmlGenericErrorFunc handler) {
  115|      2|    xmlGenericErrorContext = ctx;
  ------------------
  |  |  876|      2|  #define xmlGenericErrorContext XML_GLOBAL_MACRO(xmlGenericErrorContext)
  |  |  ------------------
  |  |  |  |  500|      2|  #define XML_GLOBAL_MACRO(name) (*__##name())
  |  |  ------------------
  ------------------
  116|      2|    if (handler != NULL)
  ------------------
  |  Branch (116:9): [True: 2, False: 0]
  ------------------
  117|      2|	xmlGenericError = handler;
  ------------------
  |  |  875|      2|  #define xmlGenericError XML_GLOBAL_MACRO(xmlGenericError)
  |  |  ------------------
  |  |  |  |  500|      2|  #define XML_GLOBAL_MACRO(name) (*__##name())
  |  |  ------------------
  ------------------
  118|      0|    else
  119|      0|	xmlGenericError = xmlGenericErrorDefaultFunc;
  ------------------
  |  |  875|      0|  #define xmlGenericError XML_GLOBAL_MACRO(xmlGenericError)
  |  |  ------------------
  |  |  |  |  500|      0|  #define XML_GLOBAL_MACRO(name) (*__##name())
  |  |  ------------------
  ------------------
  120|      2|}
__xmlRaiseError:
  475|  2.26k|{
  476|  2.26k|    xmlParserCtxtPtr ctxt = NULL;
  477|  2.26k|    xmlNodePtr node = (xmlNodePtr) nod;
  478|  2.26k|    char *str = NULL;
  479|  2.26k|    xmlParserInputPtr input = NULL;
  480|  2.26k|    xmlErrorPtr to = &xmlLastError;
  ------------------
  |  |  874|  2.26k|  #define xmlLastError XML_GLOBAL_MACRO(xmlLastError)
  |  |  ------------------
  |  |  |  |  500|  2.26k|  #define XML_GLOBAL_MACRO(name) (*__##name())
  |  |  ------------------
  ------------------
  481|  2.26k|    xmlNodePtr baseptr = NULL;
  482|       |
  483|  2.26k|    if (code == XML_ERR_OK)
  ------------------
  |  Branch (483:9): [True: 0, False: 2.26k]
  ------------------
  484|      0|        return;
  485|  2.26k|    if ((xmlGetWarningsDefaultValue == 0) && (level == XML_ERR_WARNING))
  ------------------
  |  |  865|  2.26k|    XML_GLOBAL_MACRO(xmlGetWarningsDefaultValue)
  |  |  ------------------
  |  |  |  |  500|  2.26k|  #define XML_GLOBAL_MACRO(name) (*__##name())
  |  |  ------------------
  ------------------
  |  Branch (485:9): [True: 0, False: 2.26k]
  |  Branch (485:46): [True: 0, False: 0]
  ------------------
  486|      0|        return;
  487|  2.26k|    if ((domain == XML_FROM_PARSER) || (domain == XML_FROM_HTML) ||
  ------------------
  |  Branch (487:9): [True: 2.09k, False: 166]
  |  Branch (487:40): [True: 0, False: 166]
  ------------------
  488|  2.26k|        (domain == XML_FROM_DTD) || (domain == XML_FROM_NAMESPACE) ||
  ------------------
  |  Branch (488:9): [True: 0, False: 166]
  |  Branch (488:37): [True: 52, False: 114]
  ------------------
  489|  2.26k|	(domain == XML_FROM_IO) || (domain == XML_FROM_VALID)) {
  ------------------
  |  Branch (489:2): [True: 0, False: 114]
  |  Branch (489:29): [True: 0, False: 114]
  ------------------
  490|  2.14k|	ctxt = (xmlParserCtxtPtr) ctx;
  491|       |
  492|  2.14k|        if (ctxt != NULL) {
  ------------------
  |  Branch (492:13): [True: 2.14k, False: 0]
  ------------------
  493|  2.14k|            if (level == XML_ERR_WARNING) {
  ------------------
  |  Branch (493:17): [True: 0, False: 2.14k]
  ------------------
  494|      0|                if (ctxt->nbWarnings >= XML_MAX_ERRORS)
  ------------------
  |  |   20|      0|#define XML_MAX_ERRORS 100
  ------------------
  |  Branch (494:21): [True: 0, False: 0]
  ------------------
  495|      0|                    return;
  496|      0|                ctxt->nbWarnings += 1;
  497|  2.14k|            } else {
  498|  2.14k|                if (ctxt->nbErrors >= XML_MAX_ERRORS)
  ------------------
  |  |   20|  2.14k|#define XML_MAX_ERRORS 100
  ------------------
  |  Branch (498:21): [True: 238, False: 1.91k]
  ------------------
  499|    238|                    return;
  500|  1.91k|                ctxt->nbErrors += 1;
  501|  1.91k|            }
  502|       |
  503|  1.91k|            if ((schannel == NULL) && (ctxt->sax != NULL) &&
  ------------------
  |  Branch (503:17): [True: 1.91k, False: 0]
  |  Branch (503:39): [True: 1.91k, False: 0]
  ------------------
  504|  1.91k|                (ctxt->sax->initialized == XML_SAX2_MAGIC) &&
  ------------------
  |  |  685|  1.91k|#define XML_SAX2_MAGIC 0xDEEDBEAF
  ------------------
  |  Branch (504:17): [True: 1.70k, False: 203]
  ------------------
  505|  1.91k|                (ctxt->sax->serror != NULL)) {
  ------------------
  |  Branch (505:17): [True: 0, False: 1.70k]
  ------------------
  506|      0|                schannel = ctxt->sax->serror;
  507|      0|                data = ctxt->userData;
  508|      0|            }
  509|  1.91k|        }
  510|  2.14k|    }
  511|       |    /*
  512|       |     * Check if structured error handler set
  513|       |     */
  514|  2.02k|    if (schannel == NULL) {
  ------------------
  |  Branch (514:9): [True: 2.02k, False: 0]
  ------------------
  515|  2.02k|	schannel = xmlStructuredError;
  ------------------
  |  |  877|  2.02k|  #define xmlStructuredError XML_GLOBAL_MACRO(xmlStructuredError)
  |  |  ------------------
  |  |  |  |  500|  2.02k|  #define XML_GLOBAL_MACRO(name) (*__##name())
  |  |  ------------------
  ------------------
  516|       |	/*
  517|       |	 * if user has defined handler, change data ptr to user's choice
  518|       |	 */
  519|  2.02k|	if (schannel != NULL)
  ------------------
  |  Branch (519:6): [True: 0, False: 2.02k]
  ------------------
  520|      0|	    data = xmlStructuredErrorContext;
  ------------------
  |  |  878|      0|  #define xmlStructuredErrorContext XML_GLOBAL_MACRO(xmlStructuredErrorContext)
  |  |  ------------------
  |  |  |  |  500|      0|  #define XML_GLOBAL_MACRO(name) (*__##name())
  |  |  ------------------
  ------------------
  521|  2.02k|    }
  522|       |    /*
  523|       |     * Formatting the message
  524|       |     */
  525|  2.02k|    if (msg == NULL) {
  ------------------
  |  Branch (525:9): [True: 0, False: 2.02k]
  ------------------
  526|      0|        str = (char *) xmlStrdup(BAD_CAST "No error message provided");
  ------------------
  |  |   35|      0|#define BAD_CAST (xmlChar *)
  ------------------
  527|  2.02k|    } else {
  528|  2.02k|        XML_GET_VAR_STR(msg, str);
  ------------------
  |  |   22|  2.02k|#define XML_GET_VAR_STR(msg, str) {				\
  |  |   23|  2.02k|    int       size, prev_size = -1;				\
  |  |   24|  2.02k|    int       chars;						\
  |  |   25|  2.02k|    char      *larger;						\
  |  |   26|  2.02k|    va_list   ap;						\
  |  |   27|  2.02k|								\
  |  |   28|  2.02k|    str = (char *) xmlMalloc(150);				\
  |  |   29|  2.02k|    if (str != NULL) {						\
  |  |  ------------------
  |  |  |  Branch (29:9): [True: 2.02k, False: 4]
  |  |  ------------------
  |  |   30|  2.02k|								\
  |  |   31|  2.02k|    size = 150;							\
  |  |   32|  2.02k|								\
  |  |   33|  4.04k|    while (size < 64000) {					\
  |  |  ------------------
  |  |  |  Branch (33:12): [True: 4.04k, False: 0]
  |  |  ------------------
  |  |   34|  4.04k|	va_start(ap, msg);					\
  |  |   35|  4.04k|	chars = vsnprintf(str, size, msg, ap);			\
  |  |   36|  4.04k|	va_end(ap);						\
  |  |   37|  4.04k|	if ((chars > -1) && (chars < size)) {			\
  |  |  ------------------
  |  |  |  Branch (37:6): [True: 4.04k, False: 0]
  |  |  |  Branch (37:22): [True: 4.04k, False: 0]
  |  |  ------------------
  |  |   38|  4.04k|	    if (prev_size == chars) {				\
  |  |  ------------------
  |  |  |  Branch (38:10): [True: 2.02k, False: 2.02k]
  |  |  ------------------
  |  |   39|  2.02k|		break;						\
  |  |   40|  2.02k|	    } else {						\
  |  |   41|  2.02k|		prev_size = chars;				\
  |  |   42|  2.02k|	    }							\
  |  |   43|  4.04k|	}							\
  |  |   44|  4.04k|	if (chars > -1)						\
  |  |  ------------------
  |  |  |  Branch (44:6): [True: 2.02k, False: 0]
  |  |  ------------------
  |  |   45|  2.02k|	    size += chars + 1;					\
  |  |   46|  2.02k|	else							\
  |  |   47|  2.02k|	    size += 100;					\
  |  |   48|  2.02k|	if ((larger = (char *) xmlRealloc(str, size)) == NULL) {\
  |  |  ------------------
  |  |  |  Branch (48:6): [True: 0, False: 2.02k]
  |  |  ------------------
  |  |   49|      0|	    break;						\
  |  |   50|      0|	}							\
  |  |   51|  2.02k|	str = larger;						\
  |  |   52|  2.02k|    }}								\
  |  |   53|  2.02k|}
  ------------------
  529|  2.02k|    }
  530|       |
  531|       |    /*
  532|       |     * specific processing if a parser context is provided
  533|       |     */
  534|  2.02k|    if (ctxt != NULL) {
  ------------------
  |  Branch (534:9): [True: 1.91k, False: 114]
  ------------------
  535|  1.91k|        if (file == NULL) {
  ------------------
  |  Branch (535:13): [True: 1.91k, False: 0]
  ------------------
  536|  1.91k|            input = ctxt->input;
  537|  1.91k|            if ((input != NULL) && (input->filename == NULL) &&
  ------------------
  |  Branch (537:17): [True: 1.91k, False: 0]
  |  Branch (537:36): [True: 355, False: 1.55k]
  ------------------
  538|  1.91k|                (ctxt->inputNr > 1)) {
  ------------------
  |  Branch (538:17): [True: 0, False: 355]
  ------------------
  539|      0|                input = ctxt->inputTab[ctxt->inputNr - 2];
  540|      0|            }
  541|  1.91k|            if (input != NULL) {
  ------------------
  |  Branch (541:17): [True: 1.91k, False: 0]
  ------------------
  542|  1.91k|                file = input->filename;
  543|  1.91k|                line = input->line;
  544|  1.91k|                col = input->col;
  545|  1.91k|            }
  546|  1.91k|        }
  547|  1.91k|        to = &ctxt->lastError;
  548|  1.91k|    } else if ((node != NULL) && (file == NULL)) {
  ------------------
  |  Branch (548:16): [True: 112, False: 2]
  |  Branch (548:34): [True: 112, False: 0]
  ------------------
  549|    112|	int i;
  550|       |
  551|    112|	if ((node->doc != NULL) && (node->doc->URL != NULL)) {
  ------------------
  |  Branch (551:6): [True: 112, False: 0]
  |  Branch (551:29): [True: 13, False: 99]
  ------------------
  552|     13|	    baseptr = node;
  553|       |/*	    file = (const char *) node->doc->URL; */
  554|     13|	}
  555|    112|	for (i = 0;
  556|    112|	     ((i < 10) && (node != NULL) && (node->type != XML_ELEMENT_NODE));
  ------------------
  |  Branch (556:8): [True: 112, False: 0]
  |  Branch (556:20): [True: 112, False: 0]
  |  Branch (556:38): [True: 0, False: 112]
  ------------------
  557|    112|	     i++)
  558|      0|	     node = node->parent;
  559|    112|        if ((baseptr == NULL) && (node != NULL) &&
  ------------------
  |  Branch (559:13): [True: 99, False: 13]
  |  Branch (559:34): [True: 99, False: 0]
  ------------------
  560|    112|	    (node->doc != NULL) && (node->doc->URL != NULL))
  ------------------
  |  Branch (560:6): [True: 99, False: 0]
  |  Branch (560:29): [True: 0, False: 99]
  ------------------
  561|      0|	    baseptr = node;
  562|       |
  563|    112|	if ((node != NULL) && (node->type == XML_ELEMENT_NODE))
  ------------------
  |  Branch (563:6): [True: 112, False: 0]
  |  Branch (563:24): [True: 112, False: 0]
  ------------------
  564|    112|	    line = node->line;
  565|    112|	if ((line == 0) || (line == 65535))
  ------------------
  |  Branch (565:6): [True: 0, False: 112]
  |  Branch (565:21): [True: 0, False: 112]
  ------------------
  566|      0|	    line = xmlGetLineNo(node);
  567|    112|    }
  568|       |
  569|       |    /*
  570|       |     * Save the information about the error
  571|       |     */
  572|  2.02k|    xmlResetError(to);
  573|  2.02k|    to->domain = domain;
  574|  2.02k|    to->code = code;
  575|  2.02k|    to->message = str;
  576|  2.02k|    to->level = level;
  577|  2.02k|    if (file != NULL)
  ------------------
  |  Branch (577:9): [True: 1.55k, False: 469]
  ------------------
  578|  1.55k|        to->file = (char *) xmlStrdup((const xmlChar *) file);
  579|    469|    else if (baseptr != NULL) {
  ------------------
  |  Branch (579:14): [True: 13, False: 456]
  ------------------
  580|     13|#ifdef LIBXML_XINCLUDE_ENABLED
  581|       |	/*
  582|       |	 * We check if the error is within an XInclude section and,
  583|       |	 * if so, attempt to print out the href of the XInclude instead
  584|       |	 * of the usual "base" (doc->URL) for the node (bug 152623).
  585|       |	 */
  586|     13|        xmlNodePtr prev = baseptr;
  587|     13|        char *href = NULL;
  588|     13|	int inclcount = 0;
  589|     82|	while (prev != NULL) {
  ------------------
  |  Branch (589:9): [True: 69, False: 13]
  ------------------
  590|     69|	    if (prev->prev == NULL)
  ------------------
  |  Branch (590:10): [True: 44, False: 25]
  ------------------
  591|     44|	        prev = prev->parent;
  592|     25|	    else {
  593|     25|	        prev = prev->prev;
  594|     25|		if (prev->type == XML_XINCLUDE_START) {
  ------------------
  |  Branch (594:7): [True: 0, False: 25]
  ------------------
  595|      0|		    if (inclcount > 0) {
  ------------------
  |  Branch (595:11): [True: 0, False: 0]
  ------------------
  596|      0|                        --inclcount;
  597|      0|                    } else {
  598|      0|                        href = (char *) xmlGetProp(prev, BAD_CAST "href");
  ------------------
  |  |   35|      0|#define BAD_CAST (xmlChar *)
  ------------------
  599|      0|                        if (href != NULL)
  ------------------
  |  Branch (599:29): [True: 0, False: 0]
  ------------------
  600|      0|		            break;
  601|      0|                    }
  602|     25|		} else if (prev->type == XML_XINCLUDE_END)
  ------------------
  |  Branch (602:14): [True: 0, False: 25]
  ------------------
  603|      0|		    inclcount++;
  604|     25|	    }
  605|     69|	}
  606|     13|        if (href != NULL)
  ------------------
  |  Branch (606:13): [True: 0, False: 13]
  ------------------
  607|      0|            to->file = href;
  608|     13|	else
  609|     13|#endif
  610|     13|	    to->file = (char *) xmlStrdup(baseptr->doc->URL);
  611|     13|	if ((to->file == NULL) && (node != NULL) && (node->doc != NULL)) {
  ------------------
  |  Branch (611:6): [True: 2, False: 11]
  |  Branch (611:28): [True: 2, False: 0]
  |  Branch (611:46): [True: 2, False: 0]
  ------------------
  612|      2|	    to->file = (char *) xmlStrdup(node->doc->URL);
  613|      2|	}
  614|     13|    }
  615|  2.02k|    to->line = line;
  616|  2.02k|    if (str1 != NULL)
  ------------------
  |  Branch (616:9): [True: 378, False: 1.64k]
  ------------------
  617|    378|        to->str1 = (char *) xmlStrdup((const xmlChar *) str1);
  618|  2.02k|    if (str2 != NULL)
  ------------------
  |  Branch (618:9): [True: 121, False: 1.90k]
  ------------------
  619|    121|        to->str2 = (char *) xmlStrdup((const xmlChar *) str2);
  620|  2.02k|    if (str3 != NULL)
  ------------------
  |  Branch (620:9): [True: 2, False: 2.02k]
  ------------------
  621|      2|        to->str3 = (char *) xmlStrdup((const xmlChar *) str3);
  622|  2.02k|    to->int1 = int1;
  623|  2.02k|    to->int2 = col;
  624|  2.02k|    to->node = node;
  625|  2.02k|    to->ctxt = ctx;
  626|       |
  627|  2.02k|    if (to != &xmlLastError)
  ------------------
  |  |  874|  2.02k|  #define xmlLastError XML_GLOBAL_MACRO(xmlLastError)
  |  |  ------------------
  |  |  |  |  500|  2.02k|  #define XML_GLOBAL_MACRO(name) (*__##name())
  |  |  ------------------
  ------------------
  |  Branch (627:9): [True: 1.91k, False: 114]
  ------------------
  628|  1.91k|        xmlCopyError(to,&xmlLastError);
  ------------------
  |  |  874|  1.91k|  #define xmlLastError XML_GLOBAL_MACRO(xmlLastError)
  |  |  ------------------
  |  |  |  |  500|  1.91k|  #define XML_GLOBAL_MACRO(name) (*__##name())
  |  |  ------------------
  ------------------
  629|       |
  630|  2.02k|    if (schannel != NULL) {
  ------------------
  |  Branch (630:9): [True: 0, False: 2.02k]
  ------------------
  631|      0|	schannel(data, to);
  632|      0|	return;
  633|      0|    }
  634|       |
  635|       |    /*
  636|       |     * Find the callback channel if channel param is NULL
  637|       |     */
  638|  2.02k|    if ((ctxt != NULL) && (channel == NULL) &&
  ------------------
  |  Branch (638:9): [True: 1.91k, False: 114]
  |  Branch (638:27): [True: 1.91k, False: 0]
  ------------------
  639|  2.02k|        (xmlStructuredError == NULL) && (ctxt->sax != NULL)) {
  ------------------
  |  |  877|  1.91k|  #define xmlStructuredError XML_GLOBAL_MACRO(xmlStructuredError)
  |  |  ------------------
  |  |  |  |  500|  1.91k|  #define XML_GLOBAL_MACRO(name) (*__##name())
  |  |  ------------------
  ------------------
  |  Branch (639:9): [True: 1.91k, False: 0]
  |  Branch (639:41): [True: 1.91k, False: 0]
  ------------------
  640|  1.91k|        if (level == XML_ERR_WARNING)
  ------------------
  |  Branch (640:13): [True: 0, False: 1.91k]
  ------------------
  641|      0|	    channel = ctxt->sax->warning;
  642|  1.91k|        else
  643|  1.91k|	    channel = ctxt->sax->error;
  644|  1.91k|	data = ctxt->userData;
  645|  1.91k|    } else if (channel == NULL) {
  ------------------
  |  Branch (645:16): [True: 114, False: 0]
  ------------------
  646|    114|	channel = xmlGenericError;
  ------------------
  |  |  875|    114|  #define xmlGenericError XML_GLOBAL_MACRO(xmlGenericError)
  |  |  ------------------
  |  |  |  |  500|    114|  #define XML_GLOBAL_MACRO(name) (*__##name())
  |  |  ------------------
  ------------------
  647|    114|	if (ctxt != NULL) {
  ------------------
  |  Branch (647:6): [True: 0, False: 114]
  ------------------
  648|      0|	    data = ctxt;
  649|    114|	} else {
  650|    114|	    data = xmlGenericErrorContext;
  ------------------
  |  |  876|    114|  #define xmlGenericErrorContext XML_GLOBAL_MACRO(xmlGenericErrorContext)
  |  |  ------------------
  |  |  |  |  500|    114|  #define XML_GLOBAL_MACRO(name) (*__##name())
  |  |  ------------------
  ------------------
  651|    114|	}
  652|    114|    }
  653|  2.02k|    if (channel == NULL)
  ------------------
  |  Branch (653:9): [True: 0, False: 2.02k]
  ------------------
  654|      0|        return;
  655|       |
  656|  2.02k|    if ((channel == xmlParserError) ||
  ------------------
  |  Branch (656:9): [True: 1.91k, False: 114]
  ------------------
  657|  2.02k|        (channel == xmlParserWarning) ||
  ------------------
  |  Branch (657:9): [True: 0, False: 114]
  ------------------
  658|  2.02k|	(channel == xmlParserValidityError) ||
  ------------------
  |  Branch (658:2): [True: 0, False: 114]
  ------------------
  659|  2.02k|	(channel == xmlParserValidityWarning))
  ------------------
  |  Branch (659:2): [True: 0, False: 114]
  ------------------
  660|  1.91k|	xmlReportError(to, ctxt, str, NULL, NULL);
  661|    114|    else if (((void(*)(void)) channel == (void(*)(void)) fprintf) ||
  ------------------
  |  Branch (661:14): [True: 0, False: 114]
  ------------------
  662|    114|             (channel == xmlGenericErrorDefaultFunc))
  ------------------
  |  Branch (662:14): [True: 0, False: 114]
  ------------------
  663|      0|	xmlReportError(to, ctxt, str, channel, data);
  664|    114|    else
  665|    114|	channel(data, "%s", str);
  666|  2.02k|}
xmlResetError:
  901|  2.25k|{
  902|  2.25k|    if (err == NULL)
  ------------------
  |  Branch (902:9): [True: 0, False: 2.25k]
  ------------------
  903|      0|        return;
  904|  2.25k|    if (err->code == XML_ERR_OK)
  ------------------
  |  Branch (904:9): [True: 362, False: 1.89k]
  ------------------
  905|    362|        return;
  906|  1.89k|    if (err->message != NULL)
  ------------------
  |  Branch (906:9): [True: 1.88k, False: 4]
  ------------------
  907|  1.88k|        xmlFree(err->message);
  908|  1.89k|    if (err->file != NULL)
  ------------------
  |  Branch (908:9): [True: 1.43k, False: 454]
  ------------------
  909|  1.43k|        xmlFree(err->file);
  910|  1.89k|    if (err->str1 != NULL)
  ------------------
  |  Branch (910:9): [True: 281, False: 1.61k]
  ------------------
  911|    281|        xmlFree(err->str1);
  912|  1.89k|    if (err->str2 != NULL)
  ------------------
  |  Branch (912:9): [True: 80, False: 1.81k]
  ------------------
  913|     80|        xmlFree(err->str2);
  914|  1.89k|    if (err->str3 != NULL)
  ------------------
  |  Branch (914:9): [True: 2, False: 1.88k]
  ------------------
  915|      2|        xmlFree(err->str3);
  916|  1.89k|    memset(err, 0, sizeof(xmlError));
  917|  1.89k|    err->code = XML_ERR_OK;
  918|  1.89k|}
xmlResetLastError:
  928|    168|{
  929|    168|    if (xmlLastError.code == XML_ERR_OK)
  ------------------
  |  |  874|    168|  #define xmlLastError XML_GLOBAL_MACRO(xmlLastError)
  |  |  ------------------
  |  |  |  |  500|    168|  #define XML_GLOBAL_MACRO(name) (*__##name())
  |  |  ------------------
  ------------------
  |  Branch (929:9): [True: 23, False: 145]
  ------------------
  930|     23|        return;
  931|    145|    xmlResetError(&xmlLastError);
  ------------------
  |  |  874|    145|  #define xmlLastError XML_GLOBAL_MACRO(xmlLastError)
  |  |  ------------------
  |  |  |  |  500|    145|  #define XML_GLOBAL_MACRO(name) (*__##name())
  |  |  ------------------
  ------------------
  932|    145|}
xmlCopyError:
  984|  1.91k|xmlCopyError(const xmlError *from, xmlErrorPtr to) {
  985|  1.91k|    char *message, *file, *str1, *str2, *str3;
  986|       |
  987|  1.91k|    if ((from == NULL) || (to == NULL))
  ------------------
  |  Branch (987:9): [True: 0, False: 1.91k]
  |  Branch (987:27): [True: 0, False: 1.91k]
  ------------------
  988|      0|        return(-1);
  989|       |
  990|  1.91k|    message = (char *) xmlStrdup((xmlChar *) from->message);
  991|  1.91k|    file = (char *) xmlStrdup ((xmlChar *) from->file);
  992|  1.91k|    str1 = (char *) xmlStrdup ((xmlChar *) from->str1);
  993|  1.91k|    str2 = (char *) xmlStrdup ((xmlChar *) from->str2);
  994|  1.91k|    str3 = (char *) xmlStrdup ((xmlChar *) from->str3);
  995|       |
  996|  1.91k|    if (to->message != NULL)
  ------------------
  |  Branch (996:9): [True: 1.77k, False: 132]
  ------------------
  997|  1.77k|        xmlFree(to->message);
  998|  1.91k|    if (to->file != NULL)
  ------------------
  |  Branch (998:9): [True: 1.54k, False: 364]
  ------------------
  999|  1.54k|        xmlFree(to->file);
 1000|  1.91k|    if (to->str1 != NULL)
  ------------------
  |  Branch (1000:9): [True: 270, False: 1.64k]
  ------------------
 1001|    270|        xmlFree(to->str1);
 1002|  1.91k|    if (to->str2 != NULL)
  ------------------
  |  Branch (1002:9): [True: 94, False: 1.81k]
  ------------------
 1003|     94|        xmlFree(to->str2);
 1004|  1.91k|    if (to->str3 != NULL)
  ------------------
  |  Branch (1004:9): [True: 2, False: 1.90k]
  ------------------
 1005|      2|        xmlFree(to->str3);
 1006|  1.91k|    to->domain = from->domain;
 1007|  1.91k|    to->code = from->code;
 1008|  1.91k|    to->level = from->level;
 1009|  1.91k|    to->line = from->line;
 1010|  1.91k|    to->node = from->node;
 1011|  1.91k|    to->int1 = from->int1;
 1012|  1.91k|    to->int2 = from->int2;
 1013|  1.91k|    to->node = from->node;
 1014|  1.91k|    to->ctxt = from->ctxt;
 1015|  1.91k|    to->message = message;
 1016|  1.91k|    to->file = file;
 1017|  1.91k|    to->str1 = str1;
 1018|  1.91k|    to->str2 = str2;
 1019|  1.91k|    to->str3 = str3;
 1020|       |
 1021|  1.91k|    return 0;
 1022|  1.91k|}
error.c:xmlParserPrintFileContextInternal:
  175|  1.91k|		xmlGenericErrorFunc channel, void *data ) {
  176|  1.91k|    const xmlChar *cur, *base, *start;
  177|  1.91k|    unsigned int n, col;	/* GCC warns if signed, because compared with sizeof() */
  178|  1.91k|    xmlChar  content[81]; /* space for 80 chars + line terminator */
  179|  1.91k|    xmlChar *ctnt;
  180|       |
  181|  1.91k|    if ((input == NULL) || (input->cur == NULL))
  ------------------
  |  Branch (181:9): [True: 0, False: 1.91k]
  |  Branch (181:28): [True: 0, False: 1.91k]
  ------------------
  182|      0|        return;
  183|       |
  184|  1.91k|    cur = input->cur;
  185|  1.91k|    base = input->base;
  186|       |    /* skip backwards over any end-of-lines */
  187|  1.96k|    while ((cur > base) && ((*(cur) == '\n') || (*(cur) == '\r'))) {
  ------------------
  |  Branch (187:12): [True: 1.94k, False: 16]
  |  Branch (187:29): [True: 50, False: 1.89k]
  |  Branch (187:49): [True: 0, False: 1.89k]
  ------------------
  188|     50|	cur--;
  189|     50|    }
  190|  1.91k|    n = 0;
  191|       |    /* search backwards for beginning-of-line (to max buff size) */
  192|  49.6k|    while ((n < sizeof(content) - 1) && (cur > base) &&
  ------------------
  |  Branch (192:12): [True: 49.6k, False: 0]
  |  Branch (192:41): [True: 49.4k, False: 184]
  ------------------
  193|  49.6k|	   (*cur != '\n') && (*cur != '\r')) {
  ------------------
  |  Branch (193:5): [True: 47.6k, False: 1.72k]
  |  Branch (193:23): [True: 47.6k, False: 0]
  ------------------
  194|  47.6k|        cur--;
  195|  47.6k|        n++;
  196|  47.6k|    }
  197|  1.91k|    if ((n > 0) && ((*cur == '\n') || (*cur == '\r'))) {
  ------------------
  |  Branch (197:9): [True: 1.89k, False: 16]
  |  Branch (197:21): [True: 1.72k, False: 168]
  |  Branch (197:39): [True: 0, False: 168]
  ------------------
  198|  1.72k|        cur++;
  199|  1.72k|    } else {
  200|       |        /* skip over continuation bytes */
  201|    184|        while ((cur < input->cur) && ((*cur & 0xC0) == 0x80))
  ------------------
  |  Branch (201:16): [True: 168, False: 16]
  |  Branch (201:38): [True: 0, False: 168]
  ------------------
  202|      0|            cur++;
  203|    184|    }
  204|       |    /* calculate the error position in terms of the current position */
  205|  1.91k|    col = input->cur - cur;
  206|       |    /* search forward for end-of-line (to max buff size) */
  207|  1.91k|    n = 0;
  208|  1.91k|    start = cur;
  209|       |    /* copy selected text to our buffer */
  210|  35.3k|    while ((*cur != 0) && (*(cur) != '\n') && (*(cur) != '\r')) {
  ------------------
  |  Branch (210:12): [True: 34.0k, False: 1.25k]
  |  Branch (210:27): [True: 33.5k, False: 470]
  |  Branch (210:47): [True: 33.5k, False: 0]
  ------------------
  211|  33.5k|        int len = input->end - cur;
  212|  33.5k|        int c = xmlGetUTF8Char(cur, &len);
  213|       |
  214|  33.5k|        if ((c < 0) || (n + len > sizeof(content)-1))
  ------------------
  |  Branch (214:13): [True: 139, False: 33.4k]
  |  Branch (214:24): [True: 43, False: 33.3k]
  ------------------
  215|    182|            break;
  216|  33.3k|        cur += len;
  217|  33.3k|	n += len;
  218|  33.3k|    }
  219|  1.91k|    memcpy(content, start, n);
  220|  1.91k|    content[n] = 0;
  221|       |    /* print out the selected text */
  222|  1.91k|    channel(data ,"%s\n", content);
  223|       |    /* create blank line with problem pointer */
  224|  1.91k|    n = 0;
  225|  1.91k|    ctnt = content;
  226|       |    /* (leave buffer space for pointer + line terminator) */
  227|  23.1k|    while ((n<col) && (n++ < sizeof(content)-2) && (*ctnt != 0)) {
  ------------------
  |  Branch (227:12): [True: 22.3k, False: 789]
  |  Branch (227:23): [True: 22.3k, False: 0]
  |  Branch (227:52): [True: 21.2k, False: 1.12k]
  ------------------
  228|  21.2k|	if (*(ctnt) != '\t')
  ------------------
  |  Branch (228:6): [True: 21.2k, False: 0]
  ------------------
  229|  21.2k|	    *(ctnt) = ' ';
  230|  21.2k|	ctnt++;
  231|  21.2k|    }
  232|  1.91k|    *ctnt++ = '^';
  233|  1.91k|    *ctnt = 0;
  234|  1.91k|    channel(data ,"%s\n", content);
  235|  1.91k|}
error.c:xmlReportError:
  261|  1.91k|{
  262|  1.91k|    char *file = NULL;
  263|  1.91k|    int line = 0;
  264|  1.91k|    int code = -1;
  265|  1.91k|    int domain;
  266|  1.91k|    const xmlChar *name = NULL;
  267|  1.91k|    xmlNodePtr node;
  268|  1.91k|    xmlErrorLevel level;
  269|  1.91k|    xmlParserInputPtr input = NULL;
  270|  1.91k|    xmlParserInputPtr cur = NULL;
  271|       |
  272|  1.91k|    if (err == NULL)
  ------------------
  |  Branch (272:9): [True: 0, False: 1.91k]
  ------------------
  273|      0|        return;
  274|       |
  275|  1.91k|    if (channel == NULL) {
  ------------------
  |  Branch (275:9): [True: 1.91k, False: 0]
  ------------------
  276|  1.91k|	channel = xmlGenericError;
  ------------------
  |  |  875|  1.91k|  #define xmlGenericError XML_GLOBAL_MACRO(xmlGenericError)
  |  |  ------------------
  |  |  |  |  500|  1.91k|  #define XML_GLOBAL_MACRO(name) (*__##name())
  |  |  ------------------
  ------------------
  277|  1.91k|	data = xmlGenericErrorContext;
  ------------------
  |  |  876|  1.91k|  #define xmlGenericErrorContext XML_GLOBAL_MACRO(xmlGenericErrorContext)
  |  |  ------------------
  |  |  |  |  500|  1.91k|  #define XML_GLOBAL_MACRO(name) (*__##name())
  |  |  ------------------
  ------------------
  278|  1.91k|    }
  279|  1.91k|    file = err->file;
  280|  1.91k|    line = err->line;
  281|  1.91k|    code = err->code;
  282|  1.91k|    domain = err->domain;
  283|  1.91k|    level = err->level;
  284|  1.91k|    node = err->node;
  285|       |
  286|  1.91k|    if (code == XML_ERR_OK)
  ------------------
  |  Branch (286:9): [True: 0, False: 1.91k]
  ------------------
  287|      0|        return;
  288|       |
  289|  1.91k|    if ((node != NULL) && (node->type == XML_ELEMENT_NODE))
  ------------------
  |  Branch (289:9): [True: 0, False: 1.91k]
  |  Branch (289:27): [True: 0, False: 0]
  ------------------
  290|      0|        name = node->name;
  291|       |
  292|       |    /*
  293|       |     * Maintain the compatibility with the legacy error handling
  294|       |     */
  295|  1.91k|    if (ctxt != NULL) {
  ------------------
  |  Branch (295:9): [True: 1.91k, False: 0]
  ------------------
  296|  1.91k|        input = ctxt->input;
  297|  1.91k|        if ((input != NULL) && (input->filename == NULL) &&
  ------------------
  |  Branch (297:13): [True: 1.91k, False: 0]
  |  Branch (297:32): [True: 355, False: 1.55k]
  ------------------
  298|  1.91k|            (ctxt->inputNr > 1)) {
  ------------------
  |  Branch (298:13): [True: 0, False: 355]
  ------------------
  299|      0|            cur = input;
  300|      0|            input = ctxt->inputTab[ctxt->inputNr - 2];
  301|      0|        }
  302|  1.91k|        if (input != NULL) {
  ------------------
  |  Branch (302:13): [True: 1.91k, False: 0]
  ------------------
  303|  1.91k|            if (input->filename)
  ------------------
  |  Branch (303:17): [True: 1.55k, False: 355]
  ------------------
  304|  1.55k|                channel(data, "%s:%d: ", input->filename, input->line);
  305|    355|            else if ((line != 0) && (domain == XML_FROM_PARSER))
  ------------------
  |  Branch (305:22): [True: 355, False: 0]
  |  Branch (305:37): [True: 337, False: 18]
  ------------------
  306|    337|                channel(data, "Entity: line %d: ", input->line);
  307|  1.91k|        }
  308|  1.91k|    } else {
  309|      0|        if (file != NULL)
  ------------------
  |  Branch (309:13): [True: 0, False: 0]
  ------------------
  310|      0|            channel(data, "%s:%d: ", file, line);
  311|      0|        else if ((line != 0) &&
  ------------------
  |  Branch (311:18): [True: 0, False: 0]
  ------------------
  312|      0|	         ((domain == XML_FROM_PARSER) || (domain == XML_FROM_SCHEMASV)||
  ------------------
  |  Branch (312:12): [True: 0, False: 0]
  |  Branch (312:43): [True: 0, False: 0]
  ------------------
  313|      0|		  (domain == XML_FROM_SCHEMASP)||(domain == XML_FROM_DTD) ||
  ------------------
  |  Branch (313:5): [True: 0, False: 0]
  |  Branch (313:36): [True: 0, False: 0]
  ------------------
  314|      0|		  (domain == XML_FROM_RELAXNGP)||(domain == XML_FROM_RELAXNGV)))
  ------------------
  |  Branch (314:5): [True: 0, False: 0]
  |  Branch (314:36): [True: 0, False: 0]
  ------------------
  315|      0|            channel(data, "Entity: line %d: ", line);
  316|      0|    }
  317|  1.91k|    if (name != NULL) {
  ------------------
  |  Branch (317:9): [True: 0, False: 1.91k]
  ------------------
  318|      0|        channel(data, "element %s: ", name);
  319|      0|    }
  320|  1.91k|    switch (domain) {
  321|  1.85k|        case XML_FROM_PARSER:
  ------------------
  |  Branch (321:9): [True: 1.85k, False: 51]
  ------------------
  322|  1.85k|            channel(data, "parser ");
  323|  1.85k|            break;
  324|     51|        case XML_FROM_NAMESPACE:
  ------------------
  |  Branch (324:9): [True: 51, False: 1.85k]
  ------------------
  325|     51|            channel(data, "namespace ");
  326|     51|            break;
  327|      0|        case XML_FROM_DTD:
  ------------------
  |  Branch (327:9): [True: 0, False: 1.91k]
  ------------------
  328|      0|        case XML_FROM_VALID:
  ------------------
  |  Branch (328:9): [True: 0, False: 1.91k]
  ------------------
  329|      0|            channel(data, "validity ");
  330|      0|            break;
  331|      0|        case XML_FROM_HTML:
  ------------------
  |  Branch (331:9): [True: 0, False: 1.91k]
  ------------------
  332|      0|            channel(data, "HTML parser ");
  333|      0|            break;
  334|      0|        case XML_FROM_MEMORY:
  ------------------
  |  Branch (334:9): [True: 0, False: 1.91k]
  ------------------
  335|      0|            channel(data, "memory ");
  336|      0|            break;
  337|      0|        case XML_FROM_OUTPUT:
  ------------------
  |  Branch (337:9): [True: 0, False: 1.91k]
  ------------------
  338|      0|            channel(data, "output ");
  339|      0|            break;
  340|      0|        case XML_FROM_IO:
  ------------------
  |  Branch (340:9): [True: 0, False: 1.91k]
  ------------------
  341|      0|            channel(data, "I/O ");
  342|      0|            break;
  343|      0|        case XML_FROM_XINCLUDE:
  ------------------
  |  Branch (343:9): [True: 0, False: 1.91k]
  ------------------
  344|      0|            channel(data, "XInclude ");
  345|      0|            break;
  346|      0|        case XML_FROM_XPATH:
  ------------------
  |  Branch (346:9): [True: 0, False: 1.91k]
  ------------------
  347|      0|            channel(data, "XPath ");
  348|      0|            break;
  349|      0|        case XML_FROM_XPOINTER:
  ------------------
  |  Branch (349:9): [True: 0, False: 1.91k]
  ------------------
  350|      0|            channel(data, "parser ");
  351|      0|            break;
  352|      0|        case XML_FROM_REGEXP:
  ------------------
  |  Branch (352:9): [True: 0, False: 1.91k]
  ------------------
  353|      0|            channel(data, "regexp ");
  354|      0|            break;
  355|      0|        case XML_FROM_MODULE:
  ------------------
  |  Branch (355:9): [True: 0, False: 1.91k]
  ------------------
  356|      0|            channel(data, "module ");
  357|      0|            break;
  358|      0|        case XML_FROM_SCHEMASV:
  ------------------
  |  Branch (358:9): [True: 0, False: 1.91k]
  ------------------
  359|      0|            channel(data, "Schemas validity ");
  360|      0|            break;
  361|      0|        case XML_FROM_SCHEMASP:
  ------------------
  |  Branch (361:9): [True: 0, False: 1.91k]
  ------------------
  362|      0|            channel(data, "Schemas parser ");
  363|      0|            break;
  364|      0|        case XML_FROM_RELAXNGP:
  ------------------
  |  Branch (364:9): [True: 0, False: 1.91k]
  ------------------
  365|      0|            channel(data, "Relax-NG parser ");
  366|      0|            break;
  367|      0|        case XML_FROM_RELAXNGV:
  ------------------
  |  Branch (367:9): [True: 0, False: 1.91k]
  ------------------
  368|      0|            channel(data, "Relax-NG validity ");
  369|      0|            break;
  370|      0|        case XML_FROM_CATALOG:
  ------------------
  |  Branch (370:9): [True: 0, False: 1.91k]
  ------------------
  371|      0|            channel(data, "Catalog ");
  372|      0|            break;
  373|      0|        case XML_FROM_C14N:
  ------------------
  |  Branch (373:9): [True: 0, False: 1.91k]
  ------------------
  374|      0|            channel(data, "C14N ");
  375|      0|            break;
  376|      0|        case XML_FROM_XSLT:
  ------------------
  |  Branch (376:9): [True: 0, False: 1.91k]
  ------------------
  377|      0|            channel(data, "XSLT ");
  378|      0|            break;
  379|      0|        case XML_FROM_I18N:
  ------------------
  |  Branch (379:9): [True: 0, False: 1.91k]
  ------------------
  380|      0|            channel(data, "encoding ");
  381|      0|            break;
  382|      0|        case XML_FROM_SCHEMATRONV:
  ------------------
  |  Branch (382:9): [True: 0, False: 1.91k]
  ------------------
  383|      0|            channel(data, "schematron ");
  384|      0|            break;
  385|      0|        case XML_FROM_BUFFER:
  ------------------
  |  Branch (385:9): [True: 0, False: 1.91k]
  ------------------
  386|      0|            channel(data, "internal buffer ");
  387|      0|            break;
  388|      0|        case XML_FROM_URI:
  ------------------
  |  Branch (388:9): [True: 0, False: 1.91k]
  ------------------
  389|      0|            channel(data, "URI ");
  390|      0|            break;
  391|      0|        default:
  ------------------
  |  Branch (391:9): [True: 0, False: 1.91k]
  ------------------
  392|      0|            break;
  393|  1.91k|    }
  394|  1.91k|    switch (level) {
  ------------------
  |  Branch (394:13): [True: 0, False: 1.91k]
  ------------------
  395|      0|        case XML_ERR_NONE:
  ------------------
  |  Branch (395:9): [True: 0, False: 1.91k]
  ------------------
  396|      0|            channel(data, ": ");
  397|      0|            break;
  398|      0|        case XML_ERR_WARNING:
  ------------------
  |  Branch (398:9): [True: 0, False: 1.91k]
  ------------------
  399|      0|            channel(data, "warning : ");
  400|      0|            break;
  401|     51|        case XML_ERR_ERROR:
  ------------------
  |  Branch (401:9): [True: 51, False: 1.85k]
  ------------------
  402|     51|            channel(data, "error : ");
  403|     51|            break;
  404|  1.85k|        case XML_ERR_FATAL:
  ------------------
  |  Branch (404:9): [True: 1.85k, False: 51]
  ------------------
  405|  1.85k|            channel(data, "error : ");
  406|  1.85k|            break;
  407|  1.91k|    }
  408|  1.91k|    if (str != NULL) {
  ------------------
  |  Branch (408:9): [True: 1.91k, False: 0]
  ------------------
  409|  1.91k|        int len;
  410|  1.91k|	len = xmlStrlen((const xmlChar *)str);
  411|  1.91k|	if ((len > 0) && (str[len - 1] != '\n'))
  ------------------
  |  Branch (411:6): [True: 1.91k, False: 0]
  |  Branch (411:19): [True: 8, False: 1.90k]
  ------------------
  412|      8|	    channel(data, "%s\n", str);
  413|  1.90k|	else
  414|  1.90k|	    channel(data, "%s", str);
  415|  1.91k|    } else {
  416|      0|        channel(data, "%s\n", "out of memory error");
  417|      0|    }
  418|       |
  419|  1.91k|    if (ctxt != NULL) {
  ------------------
  |  Branch (419:9): [True: 1.91k, False: 0]
  ------------------
  420|  1.91k|        xmlParserPrintFileContextInternal(input, channel, data);
  421|  1.91k|        if (cur != NULL) {
  ------------------
  |  Branch (421:13): [True: 0, False: 1.91k]
  ------------------
  422|      0|            if (cur->filename)
  ------------------
  |  Branch (422:17): [True: 0, False: 0]
  ------------------
  423|      0|                channel(data, "%s:%d: \n", cur->filename, cur->line);
  424|      0|            else if ((line != 0) && (domain == XML_FROM_PARSER))
  ------------------
  |  Branch (424:22): [True: 0, False: 0]
  |  Branch (424:37): [True: 0, False: 0]
  ------------------
  425|      0|                channel(data, "Entity: line %d: \n", cur->line);
  426|      0|            xmlParserPrintFileContextInternal(cur, channel, data);
  427|      0|        }
  428|  1.91k|    }
  429|  1.91k|    if ((domain == XML_FROM_XPATH) && (err->str1 != NULL) &&
  ------------------
  |  Branch (429:9): [True: 0, False: 1.91k]
  |  Branch (429:39): [True: 0, False: 0]
  ------------------
  430|  1.91k|        (err->int1 < 100) &&
  ------------------
  |  Branch (430:9): [True: 0, False: 0]
  ------------------
  431|  1.91k|	(err->int1 < xmlStrlen((const xmlChar *)err->str1))) {
  ------------------
  |  Branch (431:2): [True: 0, False: 0]
  ------------------
  432|      0|	xmlChar buf[150];
  433|      0|	int i;
  434|       |
  435|      0|	channel(data, "%s\n", err->str1);
  436|      0|	for (i=0;i < err->int1;i++)
  ------------------
  |  Branch (436:11): [True: 0, False: 0]
  ------------------
  437|      0|	     buf[i] = ' ';
  438|      0|	buf[i++] = '^';
  439|      0|	buf[i] = 0;
  440|      0|	channel(data, "%s\n", buf);
  441|      0|    }
  442|  1.91k|}

xmlFuzzErrorFunc:
   56|  11.5k|                 ...) {
   57|  11.5k|}
xmlFuzzMemSetup:
  103|      2|xmlFuzzMemSetup(void) {
  104|      2|    xmlMemSetup(free, xmlFuzzMalloc, xmlFuzzRealloc, xmlMemStrdup);
  105|      2|}
xmlFuzzMemSetLimit:
  108|    502|xmlFuzzMemSetLimit(size_t limit) {
  109|    502|    fuzzNumAllocs = 0;
  110|    502|    fuzzMaxAllocs = limit ? limit + XML_FUZZ_MALLOC_OFFSET : 0;
  ------------------
  |  |   69|      6|#define XML_FUZZ_MALLOC_OFFSET  0
  ------------------
  |  Branch (110:21): [True: 6, False: 496]
  ------------------
  111|    502|    fuzzAllocFailed = 0;
  112|    502|}
xmlFuzzDataInit:
  125|    168|xmlFuzzDataInit(const char *data, size_t size) {
  126|    168|    fuzzData.data = data;
  127|    168|    fuzzData.size = size;
  128|    168|    fuzzData.ptr = data;
  129|    168|    fuzzData.remaining = size;
  130|       |
  131|    168|    fuzzData.outBuf = xmlMalloc(size + 1);
  132|    168|    fuzzData.outPtr = fuzzData.outBuf;
  133|       |
  134|    168|    fuzzData.entities = xmlHashCreate(8);
  135|    168|    fuzzData.mainUrl = NULL;
  136|    168|    fuzzData.mainEntity = NULL;
  137|    168|}
xmlFuzzDataCleanup:
  145|    168|xmlFuzzDataCleanup(void) {
  146|    168|    xmlFree(fuzzData.outBuf);
  147|    168|    xmlHashFree(fuzzData.entities, xmlHashDefaultDeallocator);
  148|    168|}
xmlFuzzReadInt:
  181|    336|xmlFuzzReadInt(int size) {
  182|    336|    size_t ret = 0;
  183|       |
  184|  1.68k|    while ((size > 0) && (fuzzData.remaining > 0)) {
  ------------------
  |  Branch (184:12): [True: 1.34k, False: 336]
  |  Branch (184:26): [True: 1.34k, False: 0]
  ------------------
  185|  1.34k|        unsigned char c = (unsigned char) *fuzzData.ptr++;
  186|  1.34k|        fuzzData.remaining--;
  187|  1.34k|        ret = (ret << 8) | c;
  188|  1.34k|        size--;
  189|  1.34k|    }
  190|       |
  191|    336|    return ret;
  192|    336|}
xmlFuzzReadString:
  245|    694|xmlFuzzReadString(size_t *size) {
  246|    694|    const char *out = fuzzData.outPtr;
  247|       |
  248|  81.7k|    while (fuzzData.remaining > 0) {
  ------------------
  |  Branch (248:12): [True: 81.5k, False: 173]
  ------------------
  249|  81.5k|        int c = *fuzzData.ptr++;
  250|  81.5k|        fuzzData.remaining--;
  251|       |
  252|  81.5k|        if ((c == '\\') && (fuzzData.remaining > 0)) {
  ------------------
  |  Branch (252:13): [True: 527, False: 81.0k]
  |  Branch (252:28): [True: 527, False: 0]
  ------------------
  253|    527|            int c2 = *fuzzData.ptr;
  254|       |
  255|    527|            if (c2 == '\n') {
  ------------------
  |  Branch (255:17): [True: 521, False: 6]
  ------------------
  256|    521|                fuzzData.ptr++;
  257|    521|                fuzzData.remaining--;
  258|    521|                if (size != NULL)
  ------------------
  |  Branch (258:21): [True: 252, False: 269]
  ------------------
  259|    252|                    *size = fuzzData.outPtr - out;
  260|    521|                *fuzzData.outPtr++ = '\0';
  261|    521|                return(out);
  262|    521|            }
  263|      6|            if (c2 == '\\') {
  ------------------
  |  Branch (263:17): [True: 0, False: 6]
  ------------------
  264|      0|                fuzzData.ptr++;
  265|      0|                fuzzData.remaining--;
  266|      0|            }
  267|      6|        }
  268|       |
  269|  81.0k|        *fuzzData.outPtr++ = c;
  270|  81.0k|    }
  271|       |
  272|    173|    if (fuzzData.outPtr > out) {
  ------------------
  |  Branch (272:9): [True: 5, False: 168]
  ------------------
  273|      5|        if (size != NULL)
  ------------------
  |  Branch (273:13): [True: 2, False: 3]
  ------------------
  274|      2|            *size = fuzzData.outPtr - out;
  275|      5|        *fuzzData.outPtr++ = '\0';
  276|      5|        return(out);
  277|      5|    }
  278|       |
  279|    168|    if (size != NULL)
  ------------------
  |  Branch (279:9): [True: 18, False: 150]
  ------------------
  280|     18|        *size = 0;
  281|    168|    return(NULL);
  282|    173|}
xmlFuzzReadEntities:
  291|    168|xmlFuzzReadEntities(void) {
  292|    168|    size_t num = 0;
  293|       |
  294|    422|    while (1) {
  ------------------
  |  Branch (294:12): [Folded - Ignored]
  ------------------
  295|    422|        const char *url, *entity;
  296|    422|        size_t entitySize;
  297|    422|        xmlFuzzEntityInfo *entityInfo;
  298|       |
  299|    422|        url = xmlFuzzReadString(NULL);
  300|    422|        if (url == NULL) break;
  ------------------
  |  Branch (300:13): [True: 150, False: 272]
  ------------------
  301|       |
  302|    272|        entity = xmlFuzzReadString(&entitySize);
  303|    272|        if (entity == NULL) break;
  ------------------
  |  Branch (303:13): [True: 18, False: 254]
  ------------------
  304|       |
  305|    254|        if (xmlHashLookup(fuzzData.entities, (xmlChar *)url) == NULL) {
  ------------------
  |  Branch (305:13): [True: 252, False: 2]
  ------------------
  306|    252|            entityInfo = xmlMalloc(sizeof(xmlFuzzEntityInfo));
  307|    252|            if (entityInfo == NULL)
  ------------------
  |  Branch (307:17): [True: 0, False: 252]
  ------------------
  308|      0|                break;
  309|    252|            entityInfo->data = entity;
  310|    252|            entityInfo->size = entitySize;
  311|       |
  312|    252|            xmlHashAddEntry(fuzzData.entities, (xmlChar *)url, entityInfo);
  313|       |
  314|    252|            if (num == 0) {
  ------------------
  |  Branch (314:17): [True: 167, False: 85]
  ------------------
  315|    167|                fuzzData.mainUrl = url;
  316|    167|                fuzzData.mainEntity = entityInfo;
  317|    167|            }
  318|       |
  319|    252|            num++;
  320|    252|        }
  321|    254|    }
  322|    168|}
xmlFuzzMainUrl:
  330|    168|xmlFuzzMainUrl(void) {
  331|    168|    return(fuzzData.mainUrl);
  332|    168|}
xmlFuzzMainEntity:
  341|    168|xmlFuzzMainEntity(size_t *size) {
  342|    168|    if (fuzzData.mainEntity == NULL)
  ------------------
  |  Branch (342:9): [True: 1, False: 167]
  ------------------
  343|      1|        return(NULL);
  344|    167|    *size = fuzzData.mainEntity->size;
  345|    167|    return(fuzzData.mainEntity->data);
  346|    168|}
xmlFuzzEntityLoader:
  355|    120|                    xmlParserCtxtPtr ctxt) {
  356|    120|    xmlParserInputPtr input;
  357|    120|    xmlFuzzEntityInfo *entity;
  358|       |
  359|    120|    if (URL == NULL)
  ------------------
  |  Branch (359:9): [True: 0, False: 120]
  ------------------
  360|      0|        return(NULL);
  361|    120|    entity = xmlHashLookup(fuzzData.entities, (xmlChar *) URL);
  362|    120|    if (entity == NULL)
  ------------------
  |  Branch (362:9): [True: 81, False: 39]
  ------------------
  363|     81|        return(NULL);
  364|       |
  365|     39|    input = xmlNewInputStream(ctxt);
  366|     39|    if (input == NULL)
  ------------------
  |  Branch (366:9): [True: 0, False: 39]
  ------------------
  367|      0|        return(NULL);
  368|     39|    input->filename = (char *) xmlCharStrdup(URL);
  369|     39|    input->buf = xmlParserInputBufferCreateMem(entity->data, entity->size,
  370|     39|                                               XML_CHAR_ENCODING_NONE);
  371|     39|    if (input->buf == NULL) {
  ------------------
  |  Branch (371:9): [True: 0, False: 39]
  ------------------
  372|      0|        xmlFreeInputStream(input);
  373|      0|        return(NULL);
  374|      0|    }
  375|     39|    input->base = input->cur = xmlBufContent(input->buf->buffer);
  376|     39|    input->end = input->base + xmlBufUse(input->buf->buffer);
  377|       |
  378|     39|    return input;
  379|     39|}
fuzz.c:xmlFuzzMalloc:
   73|  43.2k|xmlFuzzMalloc(size_t size) {
   74|  43.2k|    if (fuzzMaxAllocs > 0) {
  ------------------
  |  Branch (74:9): [True: 330, False: 42.9k]
  ------------------
   75|    330|        if (fuzzNumAllocs >= fuzzMaxAllocs - 1) {
  ------------------
  |  Branch (75:13): [True: 15, False: 315]
  ------------------
   76|       |#if XML_FUZZ_MALLOC_ABORT
   77|       |            abort();
   78|       |#endif
   79|     15|            fuzzAllocFailed = 1;
   80|     15|            return(NULL);
   81|     15|        }
   82|    315|        fuzzNumAllocs += 1;
   83|    315|    }
   84|  43.2k|    return malloc(size);
   85|  43.2k|}
fuzz.c:xmlFuzzRealloc:
   88|  3.22k|xmlFuzzRealloc(void *ptr, size_t size) {
   89|  3.22k|    if (fuzzMaxAllocs > 0) {
  ------------------
  |  Branch (89:9): [True: 23, False: 3.20k]
  ------------------
   90|     23|        if (fuzzNumAllocs >= fuzzMaxAllocs - 1) {
  ------------------
  |  Branch (90:13): [True: 0, False: 23]
  ------------------
   91|       |#if XML_FUZZ_MALLOC_ABORT
   92|       |            abort();
   93|       |#endif
   94|      0|            fuzzAllocFailed = 1;
   95|      0|            return(NULL);
   96|      0|        }
   97|     23|        fuzzNumAllocs += 1;
   98|     23|    }
   99|  3.22k|    return realloc(ptr, size);
  100|  3.22k|}

LLVMFuzzerInitialize:
   17|      2|                     char ***argv ATTRIBUTE_UNUSED) {
   18|      2|    xmlFuzzMemSetup();
   19|      2|    xmlInitParser();
   20|      2|#ifdef LIBXML_CATALOG_ENABLED
   21|      2|    xmlInitializeCatalog();
   22|      2|#endif
   23|      2|    xmlSetGenericErrorFunc(NULL, xmlFuzzErrorFunc);
   24|      2|    xmlSetExternalEntityLoader(xmlFuzzEntityLoader);
   25|       |
   26|      2|    return 0;
   27|      2|}
LLVMFuzzerTestOneInput:
   30|    168|LLVMFuzzerTestOneInput(const char *data, size_t size) {
   31|    168|    xmlDocPtr doc;
   32|    168|    const char *docBuffer, *docUrl;
   33|    168|    size_t maxAlloc, docSize;
   34|    168|    int opts;
   35|       |
   36|    168|    xmlFuzzDataInit(data, size);
   37|    168|    opts = (int) xmlFuzzReadInt(4);
   38|    168|    opts |= XML_PARSE_XINCLUDE;
   39|    168|    maxAlloc = xmlFuzzReadInt(4) % (size + 1);
   40|       |
   41|    168|    xmlFuzzReadEntities();
   42|    168|    docBuffer = xmlFuzzMainEntity(&docSize);
   43|    168|    docUrl = xmlFuzzMainUrl();
   44|    168|    if (docBuffer == NULL)
  ------------------
  |  Branch (44:9): [True: 1, False: 167]
  ------------------
   45|      1|        goto exit;
   46|       |
   47|       |    /* Pull parser */
   48|       |
   49|    167|    xmlFuzzMemSetLimit(maxAlloc);
   50|    167|    doc = xmlReadMemory(docBuffer, docSize, docUrl, NULL, opts);
   51|    167|    xmlXIncludeProcessFlags(doc, opts);
   52|    167|    xmlFreeDoc(doc);
   53|       |
   54|       |    /* Reader */
   55|       |
   56|    167|#ifdef LIBXML_READER_ENABLED
   57|    167|    {
   58|    167|        xmlTextReaderPtr reader;
   59|    167|        int j;
   60|       |
   61|    167|        xmlFuzzMemSetLimit(maxAlloc);
   62|    167|        reader = xmlReaderForMemory(docBuffer, docSize, NULL, NULL, opts);
   63|    167|        if (reader == NULL)
  ------------------
  |  Branch (63:13): [True: 0, False: 167]
  ------------------
   64|      0|            goto exit;
   65|  1.96k|        while (xmlTextReaderRead(reader) == 1) {
  ------------------
  |  Branch (65:16): [True: 1.80k, False: 167]
  ------------------
   66|  1.80k|            if (xmlTextReaderNodeType(reader) == XML_ELEMENT_NODE) {
  ------------------
  |  Branch (66:17): [True: 800, False: 1.00k]
  ------------------
   67|    800|                int i, n = xmlTextReaderAttributeCount(reader);
   68|  1.22k|                for (i=0; i<n; i++) {
  ------------------
  |  Branch (68:27): [True: 425, False: 800]
  ------------------
   69|    425|                    xmlTextReaderMoveToAttributeNo(reader, i);
   70|    850|                    while (xmlTextReaderReadAttributeValue(reader) == 1);
  ------------------
  |  Branch (70:28): [True: 425, False: 425]
  ------------------
   71|    425|                }
   72|    800|            }
   73|  1.80k|        }
   74|  1.83k|        for (j = 0; j < 10; j++)
  ------------------
  |  Branch (74:21): [True: 1.67k, False: 167]
  ------------------
   75|  1.67k|            xmlTextReaderRead(reader);
   76|    167|        xmlFreeTextReader(reader);
   77|    167|    }
   78|      0|#endif
   79|       |
   80|    168|exit:
   81|    168|    xmlFuzzMemSetLimit(0);
   82|    168|    xmlFuzzDataCleanup();
   83|    168|    xmlResetLastError();
   84|    168|    return(0);
   85|    167|}

xmlInitGlobalsInternal:
  566|      2|void xmlInitGlobalsInternal(void) {
  567|      2|    xmlInitMutex(&xmlThrDefMutex);
  568|       |
  569|      2|#ifdef HAVE_POSIX_THREADS
  570|      2|#ifdef XML_PTHREAD_WEAK
  571|      2|    if (libxml_is_threaded == -1)
  ------------------
  |  Branch (571:9): [True: 2, False: 0]
  ------------------
  572|      2|        libxml_is_threaded =
  573|      2|            (pthread_getspecific != NULL) &&
  ------------------
  |  Branch (573:13): [True: 2, False: 0]
  ------------------
  574|      2|            (pthread_setspecific != NULL) &&
  ------------------
  |  Branch (574:13): [True: 2, False: 0]
  ------------------
  575|      2|            (pthread_key_create != NULL) &&
  ------------------
  |  Branch (575:13): [True: 2, False: 0]
  ------------------
  576|      2|            (pthread_key_delete != NULL) &&
  ------------------
  |  Branch (576:13): [True: 2, False: 0]
  ------------------
  577|       |            /*
  578|       |             * pthread_equal can be inline, resuting in -Waddress warnings.
  579|       |             * Let's assume it's available if all the other functions are.
  580|       |             */
  581|       |            /* (pthread_equal != NULL) && */
  582|      2|            (pthread_self != NULL);
  ------------------
  |  Branch (582:13): [True: 2, False: 0]
  ------------------
  583|      2|    if (libxml_is_threaded == 0)
  ------------------
  |  Branch (583:9): [True: 0, False: 2]
  ------------------
  584|      0|        return;
  585|      2|#endif /* XML_PTHREAD_WEAK */
  586|      2|    pthread_key_create(&globalkey, xmlFreeGlobalState);
  587|      2|    mainthread = pthread_self();
  588|       |#elif defined(HAVE_WIN32_THREADS)
  589|       |#ifndef USE_TLS
  590|       |    globalkey = TlsAlloc();
  591|       |#endif
  592|       |    mainthread = GetCurrentThreadId();
  593|       |#endif
  594|      2|}
__xmlLastError:
  892|  6.50k|    type *__##name(void) { \
  893|  6.50k|        if (IS_MAIN_THREAD) \
  ------------------
  |  |   62|  6.50k|#define IS_MAIN_THREAD (xmlIsMainThreadInternal())
  |  |  ------------------
  |  |  |  Branch (62:24): [True: 6.50k, False: 0]
  |  |  ------------------
  ------------------
  894|  6.50k|            return (&name); \
  895|  6.50k|        else \
  896|  6.50k|            return (&xmlGetThreadLocalStorage(0)->gs_##name); \
  897|  6.50k|    }
__xmlGenericError:
  892|  2.02k|    type *__##name(void) { \
  893|  2.02k|        if (IS_MAIN_THREAD) \
  ------------------
  |  |   62|  2.02k|#define IS_MAIN_THREAD (xmlIsMainThreadInternal())
  |  |  ------------------
  |  |  |  Branch (62:24): [True: 2.02k, False: 0]
  |  |  ------------------
  ------------------
  894|  2.02k|            return (&name); \
  895|  2.02k|        else \
  896|  2.02k|            return (&xmlGetThreadLocalStorage(0)->gs_##name); \
  897|  2.02k|    }
__xmlGenericErrorContext:
  892|  2.02k|    type *__##name(void) { \
  893|  2.02k|        if (IS_MAIN_THREAD) \
  ------------------
  |  |   62|  2.02k|#define IS_MAIN_THREAD (xmlIsMainThreadInternal())
  |  |  ------------------
  |  |  |  Branch (62:24): [True: 2.02k, False: 0]
  |  |  ------------------
  ------------------
  894|  2.02k|            return (&name); \
  895|  2.02k|        else \
  896|  2.02k|            return (&xmlGetThreadLocalStorage(0)->gs_##name); \
  897|  2.02k|    }
__xmlStructuredError:
  892|  3.93k|    type *__##name(void) { \
  893|  3.93k|        if (IS_MAIN_THREAD) \
  ------------------
  |  |   62|  3.93k|#define IS_MAIN_THREAD (xmlIsMainThreadInternal())
  |  |  ------------------
  |  |  |  Branch (62:24): [True: 3.93k, False: 0]
  |  |  ------------------
  ------------------
  894|  3.93k|            return (&name); \
  895|  3.93k|        else \
  896|  3.93k|            return (&xmlGetThreadLocalStorage(0)->gs_##name); \
  897|  3.93k|    }
__xmlDefaultSAXLocator:
  892|    363|    type *__##name(void) { \
  893|    363|        if (IS_MAIN_THREAD) \
  ------------------
  |  |   62|    363|#define IS_MAIN_THREAD (xmlIsMainThreadInternal())
  |  |  ------------------
  |  |  |  Branch (62:24): [True: 363, False: 0]
  |  |  ------------------
  ------------------
  894|    363|            return (&name); \
  895|    363|        else \
  896|    363|            return (&xmlGetThreadLocalStorage(0)->gs_##name); \
  897|    363|    }
__xmlDoValidityCheckingDefaultValue:
  892|    454|    type *__##name(void) { \
  893|    454|        if (IS_MAIN_THREAD) \
  ------------------
  |  |   62|    454|#define IS_MAIN_THREAD (xmlIsMainThreadInternal())
  |  |  ------------------
  |  |  |  Branch (62:24): [True: 454, False: 0]
  |  |  ------------------
  ------------------
  894|    454|            return (&name); \
  895|    454|        else \
  896|    454|            return (&xmlGetThreadLocalStorage(0)->gs_##name); \
  897|    454|    }
__xmlGetWarningsDefaultValue:
  892|  2.26k|    type *__##name(void) { \
  893|  2.26k|        if (IS_MAIN_THREAD) \
  ------------------
  |  |   62|  2.26k|#define IS_MAIN_THREAD (xmlIsMainThreadInternal())
  |  |  ------------------
  |  |  |  Branch (62:24): [True: 2.26k, False: 0]
  |  |  ------------------
  ------------------
  894|  2.26k|            return (&name); \
  895|  2.26k|        else \
  896|  2.26k|            return (&xmlGetThreadLocalStorage(0)->gs_##name); \
  897|  2.26k|    }
__xmlKeepBlanksDefaultValue:
  892|    454|    type *__##name(void) { \
  893|    454|        if (IS_MAIN_THREAD) \
  ------------------
  |  |   62|    454|#define IS_MAIN_THREAD (xmlIsMainThreadInternal())
  |  |  ------------------
  |  |  |  Branch (62:24): [True: 454, False: 0]
  |  |  ------------------
  ------------------
  894|    454|            return (&name); \
  895|    454|        else \
  896|    454|            return (&xmlGetThreadLocalStorage(0)->gs_##name); \
  897|    454|    }
__xmlLineNumbersDefaultValue:
  892|    454|    type *__##name(void) { \
  893|    454|        if (IS_MAIN_THREAD) \
  ------------------
  |  |   62|    454|#define IS_MAIN_THREAD (xmlIsMainThreadInternal())
  |  |  ------------------
  |  |  |  Branch (62:24): [True: 454, False: 0]
  |  |  ------------------
  ------------------
  894|    454|            return (&name); \
  895|    454|        else \
  896|    454|            return (&xmlGetThreadLocalStorage(0)->gs_##name); \
  897|    454|    }
__xmlLoadExtDtdDefaultValue:
  892|    454|    type *__##name(void) { \
  893|    454|        if (IS_MAIN_THREAD) \
  ------------------
  |  |   62|    454|#define IS_MAIN_THREAD (xmlIsMainThreadInternal())
  |  |  ------------------
  |  |  |  Branch (62:24): [True: 454, False: 0]
  |  |  ------------------
  ------------------
  894|    454|            return (&name); \
  895|    454|        else \
  896|    454|            return (&xmlGetThreadLocalStorage(0)->gs_##name); \
  897|    454|    }
__xmlPedanticParserDefaultValue:
  892|    454|    type *__##name(void) { \
  893|    454|        if (IS_MAIN_THREAD) \
  ------------------
  |  |   62|    454|#define IS_MAIN_THREAD (xmlIsMainThreadInternal())
  |  |  ------------------
  |  |  |  Branch (62:24): [True: 454, False: 0]
  |  |  ------------------
  ------------------
  894|    454|            return (&name); \
  895|    454|        else \
  896|    454|            return (&xmlGetThreadLocalStorage(0)->gs_##name); \
  897|    454|    }
__xmlSubstituteEntitiesDefaultValue:
  892|    454|    type *__##name(void) { \
  893|    454|        if (IS_MAIN_THREAD) \
  ------------------
  |  |   62|    454|#define IS_MAIN_THREAD (xmlIsMainThreadInternal())
  |  |  ------------------
  |  |  |  Branch (62:24): [True: 454, False: 0]
  |  |  ------------------
  ------------------
  894|    454|            return (&name); \
  895|    454|        else \
  896|    454|            return (&xmlGetThreadLocalStorage(0)->gs_##name); \
  897|    454|    }
__xmlDefaultSAXHandler:
  892|    454|    type *__##name(void) { \
  893|    454|        if (IS_MAIN_THREAD) \
  ------------------
  |  |   62|    454|#define IS_MAIN_THREAD (xmlIsMainThreadInternal())
  |  |  ------------------
  |  |  |  Branch (62:24): [True: 454, False: 0]
  |  |  ------------------
  ------------------
  894|    454|            return (&name); \
  895|    454|        else \
  896|    454|            return (&xmlGetThreadLocalStorage(0)->gs_##name); \
  897|    454|    }
__xmlBufferAllocScheme:
  892|    727|    type *__##name(void) { \
  893|    727|        if (IS_MAIN_THREAD) \
  ------------------
  |  |   62|    727|#define IS_MAIN_THREAD (xmlIsMainThreadInternal())
  |  |  ------------------
  |  |  |  Branch (62:24): [True: 727, False: 0]
  |  |  ------------------
  ------------------
  894|    727|            return (&name); \
  895|    727|        else \
  896|    727|            return (&xmlGetThreadLocalStorage(0)->gs_##name); \
  897|    727|    }
__xmlDefaultBufferSize:
  892|    558|    type *__##name(void) { \
  893|    558|        if (IS_MAIN_THREAD) \
  ------------------
  |  |   62|    558|#define IS_MAIN_THREAD (xmlIsMainThreadInternal())
  |  |  ------------------
  |  |  |  Branch (62:24): [True: 558, False: 0]
  |  |  ------------------
  ------------------
  894|    558|            return (&name); \
  895|    558|        else \
  896|    558|            return (&xmlGetThreadLocalStorage(0)->gs_##name); \
  897|    558|    }
globals.c:xmlPosixStrdup:
  219|     56|xmlPosixStrdup(const char *cur) {
  220|     56|    return((char*) xmlCharStrdup(cur));
  221|     56|}
globals.c:xmlIsMainThreadInternal:
  660|  21.5k|xmlIsMainThreadInternal(void) {
  661|  21.5k|    if (parserInitialized == 0) {
  ------------------
  |  Branch (661:9): [True: 2, False: 21.5k]
  ------------------
  662|      2|        xmlInitParser();
  663|      2|        parserInitialized = 1;
  664|      2|    }
  665|       |
  666|  21.5k|#ifdef HAVE_POSIX_THREADS
  667|  21.5k|#ifdef XML_PTHREAD_WEAK
  668|  21.5k|    if (libxml_is_threaded == 0)
  ------------------
  |  Branch (668:9): [True: 0, False: 21.5k]
  ------------------
  669|      0|        return (1);
  670|  21.5k|#endif
  671|  21.5k|    return (pthread_equal(mainthread, pthread_self()));
  672|       |#elif defined HAVE_WIN32_THREADS
  673|       |    return (mainthread == GetCurrentThreadId());
  674|       |#else
  675|       |    return (1);
  676|       |#endif
  677|  21.5k|}

xmlHashCreate:
  160|    296|xmlHashCreate(int size) {
  161|    296|    xmlHashTablePtr hash;
  162|       |
  163|    296|    xmlInitParser();
  164|       |
  165|    296|    hash = xmlMalloc(sizeof(*hash));
  166|    296|    if (hash == NULL)
  ------------------
  |  Branch (166:9): [True: 0, False: 296]
  ------------------
  167|      0|        return(NULL);
  168|    296|    hash->dict = NULL;
  169|    296|    hash->size = 0;
  170|    296|    hash->table = NULL;
  171|    296|    hash->nbElems = 0;
  172|    296|    hash->randomSeed = xmlRandom();
  173|    296|#ifdef FUZZING_BUILD_MODE_UNSAFE_FOR_PRODUCTION
  174|    296|    hash->randomSeed = 0;
  175|    296|#endif
  176|       |
  177|       |    /*
  178|       |     * Unless a larger size is passed, the backing table is created
  179|       |     * lazily with MIN_HASH_SIZE capacity. In practice, there are many
  180|       |     * hash tables which are never filled.
  181|       |     */
  182|    296|    if (size > MIN_HASH_SIZE) {
  ------------------
  |  |   30|    296|#define MIN_HASH_SIZE 8
  ------------------
  |  Branch (182:9): [True: 8, False: 288]
  ------------------
  183|      8|        unsigned newSize = MIN_HASH_SIZE * 2;
  ------------------
  |  |   30|      8|#define MIN_HASH_SIZE 8
  ------------------
  184|       |
  185|      8|        while ((newSize < (unsigned) size) && (newSize < MAX_HASH_SIZE))
  ------------------
  |  |   31|      0|#define MAX_HASH_SIZE (1u << 31)
  ------------------
  |  Branch (185:16): [True: 0, False: 8]
  |  Branch (185:47): [True: 0, False: 0]
  ------------------
  186|      0|            newSize *= 2;
  187|       |
  188|      8|        if (xmlHashGrow(hash, newSize) != 0) {
  ------------------
  |  Branch (188:13): [True: 0, False: 8]
  ------------------
  189|      0|            xmlFree(hash);
  190|      0|            return(NULL);
  191|      0|        }
  192|      8|    }
  193|       |
  194|    296|    return(hash);
  195|    296|}
xmlHashCreateDict:
  209|     44|xmlHashCreateDict(int size, xmlDictPtr dict) {
  210|     44|    xmlHashTablePtr hash;
  211|       |
  212|     44|    hash = xmlHashCreate(size);
  213|     44|    if (hash != NULL) {
  ------------------
  |  Branch (213:9): [True: 44, False: 0]
  ------------------
  214|     44|        hash->dict = dict;
  215|     44|        xmlDictReference(dict);
  216|     44|    }
  217|     44|    return(hash);
  218|     44|}
xmlHashFree:
  229|    464|xmlHashFree(xmlHashTablePtr hash, xmlHashDeallocator dealloc) {
  230|    464|    if (hash == NULL)
  ------------------
  |  Branch (230:9): [True: 168, False: 296]
  ------------------
  231|    168|        return;
  232|       |
  233|    296|    if (hash->table) {
  ------------------
  |  Branch (233:9): [True: 295, False: 1]
  ------------------
  234|    295|        const xmlHashEntry *end = &hash->table[hash->size];
  235|    295|        const xmlHashEntry *entry;
  236|       |
  237|  4.73k|        for (entry = hash->table; entry < end; entry++) {
  ------------------
  |  Branch (237:35): [True: 4.44k, False: 295]
  ------------------
  238|  4.44k|            if (entry->hashValue == 0)
  ------------------
  |  Branch (238:17): [True: 1.76k, False: 2.67k]
  ------------------
  239|  1.76k|                continue;
  240|  2.67k|            if ((dealloc != NULL) && (entry->payload != NULL))
  ------------------
  |  Branch (240:17): [True: 316, False: 2.36k]
  |  Branch (240:38): [True: 316, False: 0]
  ------------------
  241|    316|                dealloc(entry->payload, entry->key);
  242|  2.67k|            if (hash->dict == NULL) {
  ------------------
  |  Branch (242:17): [True: 2.60k, False: 72]
  ------------------
  243|  2.60k|                if (entry->key)
  ------------------
  |  Branch (243:21): [True: 2.60k, False: 0]
  ------------------
  244|  2.60k|                    xmlFree(entry->key);
  245|  2.60k|                if (entry->key2)
  ------------------
  |  Branch (245:21): [True: 84, False: 2.52k]
  ------------------
  246|     84|                    xmlFree(entry->key2);
  247|  2.60k|                if (entry->key3)
  ------------------
  |  Branch (247:21): [True: 0, False: 2.60k]
  ------------------
  248|      0|                    xmlFree(entry->key3);
  249|  2.60k|            }
  250|  2.67k|        }
  251|       |
  252|    295|        xmlFree(hash->table);
  253|    295|    }
  254|       |
  255|    296|    if (hash->dict)
  ------------------
  |  Branch (255:9): [True: 44, False: 252]
  ------------------
  256|     44|        xmlDictFree(hash->dict);
  257|       |
  258|    296|    xmlFree(hash);
  259|    296|}
xmlHashDefaultDeallocator:
  603|    252|xmlHashDefaultDeallocator(void *entry, const xmlChar *key ATTRIBUTE_UNUSED) {
  604|    252|    xmlFree(entry);
  605|    252|}
xmlHashAddEntry:
  621|    290|xmlHashAddEntry(xmlHashTablePtr hash, const xmlChar *key, void *payload) {
  622|    290|    return(xmlHashUpdateInternal(hash, key, NULL, NULL, payload, NULL, 0));
  623|    290|}
xmlHashAddEntry2:
  640|  2.38k|                 const xmlChar *key2, void *payload) {
  641|  2.38k|    return(xmlHashUpdateInternal(hash, key, key2, NULL, payload, NULL, 0));
  642|  2.38k|}
xmlHashAddEntry3:
  661|      8|                 void *payload) {
  662|      8|    return(xmlHashUpdateInternal(hash, key, key2, key3, payload, NULL, 0));
  663|      8|}
xmlHashLookup:
  739|    376|xmlHashLookup(xmlHashTablePtr hash, const xmlChar *key) {
  740|    376|    return(xmlHashLookup3(hash, key, NULL, NULL));
  741|    376|}
xmlHashLookup2:
  755|     68|              const xmlChar *key2) {
  756|     68|    return(xmlHashLookup3(hash, key, key2, NULL));
  757|     68|}
xmlHashQLookup2:
  790|     22|                const xmlChar *name2) {
  791|     22|    return(xmlHashQLookup3(hash, prefix, name, prefix2, name2, NULL, NULL));
  792|     22|}
xmlHashLookup3:
  807|    492|               const xmlChar *key2, const xmlChar *key3) {
  808|    492|    const xmlHashEntry *entry;
  809|    492|    unsigned hashValue;
  810|    492|    int found;
  811|       |
  812|    492|    if ((hash == NULL) || (hash->size == 0) || (key == NULL))
  ------------------
  |  Branch (812:9): [True: 0, False: 492]
  |  Branch (812:27): [True: 183, False: 309]
  |  Branch (812:48): [True: 0, False: 309]
  ------------------
  813|    183|        return(NULL);
  814|    309|    hashValue = xmlHashValue(hash->randomSeed, key, key2, key3, NULL);
  815|    309|    entry = xmlHashFindEntry(hash, key, key2, key3, hashValue, &found);
  816|    309|    if (found)
  ------------------
  |  Branch (816:9): [True: 83, False: 226]
  ------------------
  817|     83|        return(entry->payload);
  818|    226|    return(NULL);
  819|    309|}
xmlHashQLookup3:
  840|     22|                const xmlChar *prefix3, const xmlChar *name3) {
  841|     22|    const xmlHashEntry *entry;
  842|     22|    unsigned hashValue, mask, pos, displ;
  843|       |
  844|     22|    if ((hash == NULL) || (hash->size == 0) || (name == NULL))
  ------------------
  |  Branch (844:9): [True: 0, False: 22]
  |  Branch (844:27): [True: 0, False: 22]
  |  Branch (844:48): [True: 0, False: 22]
  ------------------
  845|      0|        return(NULL);
  846|       |
  847|     22|    hashValue = xmlHashQNameValue(hash->randomSeed, prefix, name, prefix2,
  848|     22|                                  name2, prefix3, name3);
  849|     22|    mask = hash->size - 1;
  850|     22|    pos = hashValue & mask;
  851|     22|    entry = &hash->table[pos];
  852|       |
  853|     22|    if (entry->hashValue != 0) {
  ------------------
  |  Branch (853:9): [True: 18, False: 4]
  ------------------
  854|     18|        displ = 0;
  855|     18|        hashValue |= MAX_HASH_SIZE;
  ------------------
  |  |   31|     18|#define MAX_HASH_SIZE (1u << 31)
  ------------------
  856|       |
  857|     18|        do {
  858|     18|            if ((hashValue == entry->hashValue) &&
  ------------------
  |  Branch (858:17): [True: 18, False: 0]
  ------------------
  859|     18|                (xmlStrQEqual(prefix, name, entry->key)) &&
  ------------------
  |  Branch (859:17): [True: 18, False: 0]
  ------------------
  860|     18|                (xmlStrQEqual(prefix2, name2, entry->key2)) &&
  ------------------
  |  Branch (860:17): [True: 18, False: 0]
  ------------------
  861|     18|                (xmlStrQEqual(prefix3, name3, entry->key3)))
  ------------------
  |  Branch (861:17): [True: 18, False: 0]
  ------------------
  862|     18|                return(entry->payload);
  863|       |
  864|      0|            displ++;
  865|      0|            pos++;
  866|      0|            entry++;
  867|      0|            if ((pos & mask) == 0)
  ------------------
  |  Branch (867:17): [True: 0, False: 0]
  ------------------
  868|      0|                entry = hash->table;
  869|      0|        } while ((entry->hashValue != 0) &&
  ------------------
  |  Branch (869:18): [True: 0, False: 0]
  ------------------
  870|      0|                 (((pos - entry->hashValue) & mask) >= displ));
  ------------------
  |  Branch (870:18): [True: 0, False: 0]
  ------------------
  871|     18|    }
  872|       |
  873|      4|    return(NULL);
  874|     22|}
xmlHashScanFull:
  914|      8|xmlHashScanFull(xmlHashTablePtr hash, xmlHashScannerFull scan, void *data) {
  915|      8|    const xmlHashEntry *entry, *end;
  916|       |
  917|      8|    if ((hash == NULL) || (hash->size == 0) || (scan == NULL))
  ------------------
  |  Branch (917:9): [True: 0, False: 8]
  |  Branch (917:27): [True: 0, False: 8]
  |  Branch (917:48): [True: 0, False: 8]
  ------------------
  918|      0|        return;
  919|       |
  920|      8|    end = &hash->table[hash->size];
  921|       |
  922|    136|    for (entry = hash->table; entry < end; entry++) {
  ------------------
  |  Branch (922:31): [True: 128, False: 8]
  ------------------
  923|    128|        if ((entry->hashValue != 0) && (entry->payload != NULL))
  ------------------
  |  Branch (923:13): [True: 8, False: 120]
  |  Branch (923:40): [True: 8, False: 0]
  ------------------
  924|      8|            scan(entry->payload, data, entry->key, entry->key2, entry->key3);
  925|    128|    }
  926|      8|}
xmlHashSize:
 1033|      8|xmlHashSize(xmlHashTablePtr hash) {
 1034|      8|    if (hash == NULL)
  ------------------
  |  Branch (1034:9): [True: 0, False: 8]
  ------------------
 1035|      0|        return(-1);
 1036|      8|    return(hash->nbElems);
 1037|      8|}
hash.c:xmlHashGrow:
  354|    463|xmlHashGrow(xmlHashTablePtr hash, unsigned size) {
  355|    463|    const xmlHashEntry *oldentry, *oldend, *end;
  356|    463|    xmlHashEntry *table;
  357|    463|    unsigned oldsize, i;
  358|       |
  359|       |    /* Add 0 to avoid spurious -Wtype-limits warning on 64-bit GCC */
  360|    463|    if ((size_t) size + 0 > SIZE_MAX / sizeof(table[0]))
  ------------------
  |  |   25|    463|  #define SIZE_MAX ((size_t) -1)
  ------------------
  |  Branch (360:9): [True: 0, False: 463]
  ------------------
  361|      0|        return(-1);
  362|    463|    table = xmlMalloc(size * sizeof(table[0]));
  363|    463|    if (table == NULL)
  ------------------
  |  Branch (363:9): [True: 0, False: 463]
  ------------------
  364|      0|        return(-1);
  365|    463|    memset(table, 0, size * sizeof(table[0]));
  366|       |
  367|    463|    oldsize = hash->size;
  368|    463|    if (oldsize == 0)
  ------------------
  |  Branch (368:9): [True: 295, False: 168]
  ------------------
  369|    295|        goto done;
  370|       |
  371|    168|    oldend = &hash->table[oldsize];
  372|    168|    end = &table[size];
  373|       |
  374|       |    /*
  375|       |     * Robin Hood sorting order is maintained if we
  376|       |     *
  377|       |     * - compute hash indices with modulo
  378|       |     * - resize by an integer factor
  379|       |     * - start to copy from the beginning of a probe sequence
  380|       |     */
  381|    168|    oldentry = hash->table;
  382|    672|    while (oldentry->hashValue != 0) {
  ------------------
  |  Branch (382:12): [True: 504, False: 168]
  ------------------
  383|    504|        if (++oldentry >= oldend)
  ------------------
  |  Branch (383:13): [True: 0, False: 504]
  ------------------
  384|      0|            oldentry = hash->table;
  385|    504|    }
  386|       |
  387|  2.18k|    for (i = 0; i < oldsize; i++) {
  ------------------
  |  Branch (387:17): [True: 2.01k, False: 168]
  ------------------
  388|  2.01k|        if (oldentry->hashValue != 0) {
  ------------------
  |  Branch (388:13): [True: 1.76k, False: 252]
  ------------------
  389|  1.76k|            xmlHashEntry *entry = &table[oldentry->hashValue & (size - 1)];
  390|       |
  391|  2.35k|            while (entry->hashValue != 0) {
  ------------------
  |  Branch (391:20): [True: 588, False: 1.76k]
  ------------------
  392|    588|                if (++entry >= end)
  ------------------
  |  Branch (392:21): [True: 0, False: 588]
  ------------------
  393|      0|                    entry = table;
  394|    588|            }
  395|  1.76k|            *entry = *oldentry;
  396|  1.76k|        }
  397|       |
  398|  2.01k|        if (++oldentry >= oldend)
  ------------------
  |  Branch (398:13): [True: 168, False: 1.84k]
  ------------------
  399|    168|            oldentry = hash->table;
  400|  2.01k|    }
  401|       |
  402|    168|    xmlFree(hash->table);
  403|       |
  404|    463|done:
  405|    463|    hash->table = table;
  406|    463|    hash->size = size;
  407|       |
  408|    463|    return(0);
  409|    168|}
hash.c:xmlHashUpdateInternal:
  427|  2.68k|                      void *payload, xmlHashDeallocator dealloc, int update) {
  428|  2.68k|    xmlChar *copy, *copy2, *copy3;
  429|  2.68k|    xmlHashEntry *entry = NULL;
  430|  2.68k|    size_t lengths[3];
  431|  2.68k|    unsigned hashValue;
  432|  2.68k|    int found = 0;
  433|       |
  434|  2.68k|    if ((hash == NULL) || (key == NULL))
  ------------------
  |  Branch (434:9): [True: 0, False: 2.68k]
  |  Branch (434:27): [True: 0, False: 2.68k]
  ------------------
  435|      0|        return(-1);
  436|       |
  437|       |    /*
  438|       |     * Check for an existing entry
  439|       |     */
  440|  2.68k|    hashValue = xmlHashValue(hash->randomSeed, key, key2, key3, lengths);
  441|  2.68k|    if (hash->size > 0)
  ------------------
  |  Branch (441:9): [True: 2.39k, False: 287]
  ------------------
  442|  2.39k|        entry = xmlHashFindEntry(hash, key, key2, key3, hashValue, &found);
  443|  2.68k|    if (found) {
  ------------------
  |  Branch (443:9): [True: 4, False: 2.67k]
  ------------------
  444|      4|        if (update) {
  ------------------
  |  Branch (444:13): [True: 0, False: 4]
  ------------------
  445|      0|            if (dealloc)
  ------------------
  |  Branch (445:17): [True: 0, False: 0]
  ------------------
  446|      0|                dealloc(entry->payload, entry->key);
  447|      0|            entry->payload = payload;
  448|      0|            return(0);
  449|      4|        } else {
  450|       |            /*
  451|       |             * xmlHashAddEntry found an existing entry.
  452|       |             *
  453|       |             * TODO: We should return a different error code here to
  454|       |             * distinguish from malloc failures.
  455|       |             */
  456|      4|            return(-1);
  457|      4|        }
  458|      4|    }
  459|       |
  460|       |    /*
  461|       |     * Grow the hash table if needed
  462|       |     */
  463|  2.67k|    if (hash->nbElems + 1 > hash->size / MAX_FILL_DENOM * MAX_FILL_NUM) {
  ------------------
  |  |   29|  2.67k|#define MAX_FILL_DENOM 8
  ------------------
                  if (hash->nbElems + 1 > hash->size / MAX_FILL_DENOM * MAX_FILL_NUM) {
  ------------------
  |  |   28|  2.67k|#define MAX_FILL_NUM 7
  ------------------
  |  Branch (463:9): [True: 455, False: 2.22k]
  ------------------
  464|    455|        unsigned newSize, mask, displ, pos;
  465|       |
  466|    455|        if (hash->size == 0) {
  ------------------
  |  Branch (466:13): [True: 287, False: 168]
  ------------------
  467|    287|            newSize = MIN_HASH_SIZE;
  ------------------
  |  |   30|    287|#define MIN_HASH_SIZE 8
  ------------------
  468|    287|        } else {
  469|       |            /* This guarantees that nbElems < INT_MAX */
  470|    168|            if (hash->size >= MAX_HASH_SIZE)
  ------------------
  |  |   31|    168|#define MAX_HASH_SIZE (1u << 31)
  ------------------
  |  Branch (470:17): [True: 0, False: 168]
  ------------------
  471|      0|                return(-1);
  472|    168|            newSize = hash->size * 2;
  473|    168|        }
  474|    455|        if (xmlHashGrow(hash, newSize) != 0)
  ------------------
  |  Branch (474:13): [True: 0, False: 455]
  ------------------
  475|      0|            return(-1);
  476|       |
  477|       |        /*
  478|       |         * Find new entry
  479|       |         */
  480|    455|        mask = hash->size - 1;
  481|    455|        displ = 0;
  482|    455|        pos = hashValue & mask;
  483|    455|        entry = &hash->table[pos];
  484|       |
  485|    455|        if (entry->hashValue != 0) {
  ------------------
  |  Branch (485:13): [True: 84, False: 371]
  ------------------
  486|    168|            do {
  487|    168|                displ++;
  488|    168|                pos++;
  489|    168|                entry++;
  490|    168|                if ((pos & mask) == 0)
  ------------------
  |  Branch (490:21): [True: 0, False: 168]
  ------------------
  491|      0|                    entry = hash->table;
  492|    168|            } while ((entry->hashValue != 0) &&
  ------------------
  |  Branch (492:22): [True: 168, False: 0]
  ------------------
  493|    168|                     ((pos - entry->hashValue) & mask) >= displ);
  ------------------
  |  Branch (493:22): [True: 84, False: 84]
  ------------------
  494|     84|        }
  495|    455|    }
  496|       |
  497|       |    /*
  498|       |     * Copy keys
  499|       |     */
  500|  2.67k|    if (hash->dict != NULL) {
  ------------------
  |  Branch (500:9): [True: 72, False: 2.60k]
  ------------------
  501|     72|        if (xmlDictOwns(hash->dict, key)) {
  ------------------
  |  Branch (501:13): [True: 48, False: 24]
  ------------------
  502|     48|            copy = (xmlChar *) key;
  503|     48|        } else {
  504|     24|            copy = (xmlChar *) xmlDictLookup(hash->dict, key, -1);
  505|     24|            if (copy == NULL)
  ------------------
  |  Branch (505:17): [True: 0, False: 24]
  ------------------
  506|      0|                return(-1);
  507|     24|        }
  508|       |
  509|     72|        if ((key2 == NULL) || (xmlDictOwns(hash->dict, key2))) {
  ------------------
  |  Branch (509:13): [True: 64, False: 8]
  |  Branch (509:31): [True: 8, False: 0]
  ------------------
  510|     72|            copy2 = (xmlChar *) key2;
  511|     72|        } else {
  512|      0|            copy2 = (xmlChar *) xmlDictLookup(hash->dict, key2, -1);
  513|      0|            if (copy2 == NULL)
  ------------------
  |  Branch (513:17): [True: 0, False: 0]
  ------------------
  514|      0|                return(-1);
  515|      0|        }
  516|     72|        if ((key3 == NULL) || (xmlDictOwns(hash->dict, key3))) {
  ------------------
  |  Branch (516:13): [True: 64, False: 8]
  |  Branch (516:31): [True: 8, False: 0]
  ------------------
  517|     72|            copy3 = (xmlChar *) key3;
  518|     72|        } else {
  519|      0|            copy3 = (xmlChar *) xmlDictLookup(hash->dict, key3, -1);
  520|      0|            if (copy3 == NULL)
  ------------------
  |  Branch (520:17): [True: 0, False: 0]
  ------------------
  521|      0|                return(-1);
  522|      0|        }
  523|  2.60k|    } else {
  524|  2.60k|        copy = xmlMalloc(lengths[0] + 1);
  525|  2.60k|        if (copy == NULL)
  ------------------
  |  Branch (525:13): [True: 0, False: 2.60k]
  ------------------
  526|      0|            return(-1);
  527|  2.60k|        memcpy(copy, key, lengths[0] + 1);
  528|       |
  529|  2.60k|        if (key2 != NULL) {
  ------------------
  |  Branch (529:13): [True: 84, False: 2.52k]
  ------------------
  530|     84|            copy2 = xmlMalloc(lengths[1] + 1);
  531|     84|            if (copy2 == NULL) {
  ------------------
  |  Branch (531:17): [True: 0, False: 84]
  ------------------
  532|      0|                xmlFree(copy);
  533|      0|                return(-1);
  534|      0|            }
  535|     84|            memcpy(copy2, key2, lengths[1] + 1);
  536|  2.52k|        } else {
  537|  2.52k|            copy2 = NULL;
  538|  2.52k|        }
  539|       |
  540|  2.60k|        if (key3 != NULL) {
  ------------------
  |  Branch (540:13): [True: 0, False: 2.60k]
  ------------------
  541|      0|            copy3 = xmlMalloc(lengths[2] + 1);
  542|      0|            if (copy3 == NULL) {
  ------------------
  |  Branch (542:17): [True: 0, False: 0]
  ------------------
  543|      0|                xmlFree(copy);
  544|      0|                xmlFree(copy2);
  545|      0|                return(-1);
  546|      0|            }
  547|      0|            memcpy(copy3, key3, lengths[2] + 1);
  548|  2.60k|        } else {
  549|  2.60k|            copy3 = NULL;
  550|  2.60k|        }
  551|  2.60k|    }
  552|       |
  553|       |    /*
  554|       |     * Shift the remainder of the probe sequence to the right
  555|       |     */
  556|  2.67k|    if (entry->hashValue != 0) {
  ------------------
  |  Branch (556:9): [True: 924, False: 1.75k]
  ------------------
  557|    924|        const xmlHashEntry *end = &hash->table[hash->size];
  558|    924|        const xmlHashEntry *cur = entry;
  559|       |
  560|  3.10k|        do {
  561|  3.10k|            cur++;
  562|  3.10k|            if (cur >= end)
  ------------------
  |  Branch (562:17): [True: 252, False: 2.85k]
  ------------------
  563|    252|                cur = hash->table;
  564|  3.10k|        } while (cur->hashValue != 0);
  ------------------
  |  Branch (564:18): [True: 2.18k, False: 924]
  ------------------
  565|       |
  566|    924|        if (cur < entry) {
  ------------------
  |  Branch (566:13): [True: 252, False: 672]
  ------------------
  567|       |            /*
  568|       |             * If we traversed the end of the buffer, handle the part
  569|       |             * at the start of the buffer.
  570|       |             */
  571|    252|            memmove(&hash->table[1], hash->table,
  572|    252|                    (char *) cur - (char *) hash->table);
  573|    252|            cur = end - 1;
  574|    252|            hash->table[0] = *cur;
  575|    252|        }
  576|       |
  577|    924|        memmove(&entry[1], entry, (char *) cur - (char *) entry);
  578|    924|    }
  579|       |
  580|       |    /*
  581|       |     * Populate entry
  582|       |     */
  583|  2.67k|    entry->key = copy;
  584|  2.67k|    entry->key2 = copy2;
  585|  2.67k|    entry->key3 = copy3;
  586|  2.67k|    entry->payload = payload;
  587|       |    /* OR with MAX_HASH_SIZE to make sure that the value is non-zero */
  588|  2.67k|    entry->hashValue = hashValue | MAX_HASH_SIZE;
  ------------------
  |  |   31|  2.67k|#define MAX_HASH_SIZE (1u << 31)
  ------------------
  589|       |
  590|  2.67k|    hash->nbElems++;
  591|       |
  592|  2.67k|    return(0);
  593|  2.67k|}
hash.c:xmlHashValue:
   62|  2.98k|             const xmlChar *key3, size_t *lengths) {
   63|  2.98k|    unsigned h1, h2;
   64|  2.98k|    size_t i;
   65|       |
   66|  2.98k|    HASH_INIT(h1, h2, seed);
  ------------------
  |  |   23|  2.98k|    do { \
  |  |   24|  2.98k|        h1 = seed ^ 0x3b00; \
  |  |   25|  2.98k|        h2 = HASH_ROL(seed, 15); \
  |  |  ------------------
  |  |  |  |   12|  2.98k|#define HASH_ROL(x,n) ((x) << (n) | ((x) & 0xFFFFFFFF) >> (32 - (n)))
  |  |  ------------------
  |  |   26|  2.98k|    } while (0)
  |  |  ------------------
  |  |  |  Branch (26:14): [Folded - Ignored]
  |  |  ------------------
  ------------------
   67|       |
   68|  34.3k|    for (i = 0; key[i] != 0; i++) {
  ------------------
  |  Branch (68:17): [True: 31.3k, False: 2.98k]
  ------------------
   69|  31.3k|        HASH_UPDATE(h1, h2, key[i]);
  ------------------
  |  |   29|  31.3k|    do { \
  |  |   30|  31.3k|        h1 += ch; \
  |  |   31|  31.3k|        h1 += h1 << 3; \
  |  |   32|  31.3k|        h2 += h1; \
  |  |   33|  31.3k|        h2 = HASH_ROL(h2, 7); \
  |  |  ------------------
  |  |  |  |   12|  31.3k|#define HASH_ROL(x,n) ((x) << (n) | ((x) & 0xFFFFFFFF) >> (32 - (n)))
  |  |  ------------------
  |  |   34|  31.3k|        h2 += h2 << 2; \
  |  |   35|  31.3k|    } while (0)
  |  |  ------------------
  |  |  |  Branch (35:14): [Folded - Ignored]
  |  |  ------------------
  ------------------
   70|  31.3k|    }
   71|  2.98k|    if (lengths)
  ------------------
  |  Branch (71:9): [True: 2.68k, False: 309]
  ------------------
   72|  2.68k|        lengths[0] = i;
   73|       |
   74|  2.98k|    HASH_UPDATE(h1, h2, 0);
  ------------------
  |  |   29|  2.98k|    do { \
  |  |   30|  2.98k|        h1 += ch; \
  |  |   31|  2.98k|        h1 += h1 << 3; \
  |  |   32|  2.98k|        h2 += h1; \
  |  |   33|  2.98k|        h2 = HASH_ROL(h2, 7); \
  |  |  ------------------
  |  |  |  |   12|  2.98k|#define HASH_ROL(x,n) ((x) << (n) | ((x) & 0xFFFFFFFF) >> (32 - (n)))
  |  |  ------------------
  |  |   34|  2.98k|        h2 += h2 << 2; \
  |  |   35|  2.98k|    } while (0)
  |  |  ------------------
  |  |  |  Branch (35:14): [Folded - Ignored]
  |  |  ------------------
  ------------------
   75|       |
   76|  2.98k|    if (key2 != NULL) {
  ------------------
  |  Branch (76:9): [True: 114, False: 2.87k]
  ------------------
   77|  3.74k|        for (i = 0; key2[i] != 0; i++) {
  ------------------
  |  Branch (77:21): [True: 3.63k, False: 114]
  ------------------
   78|  3.63k|            HASH_UPDATE(h1, h2, key2[i]);
  ------------------
  |  |   29|  3.63k|    do { \
  |  |   30|  3.63k|        h1 += ch; \
  |  |   31|  3.63k|        h1 += h1 << 3; \
  |  |   32|  3.63k|        h2 += h1; \
  |  |   33|  3.63k|        h2 = HASH_ROL(h2, 7); \
  |  |  ------------------
  |  |  |  |   12|  3.63k|#define HASH_ROL(x,n) ((x) << (n) | ((x) & 0xFFFFFFFF) >> (32 - (n)))
  |  |  ------------------
  |  |   34|  3.63k|        h2 += h2 << 2; \
  |  |   35|  3.63k|    } while (0)
  |  |  ------------------
  |  |  |  Branch (35:14): [Folded - Ignored]
  |  |  ------------------
  ------------------
   79|  3.63k|        }
   80|    114|        if (lengths)
  ------------------
  |  Branch (80:13): [True: 92, False: 22]
  ------------------
   81|     92|            lengths[1] = i;
   82|    114|    }
   83|       |
   84|  2.98k|    HASH_UPDATE(h1, h2, 0);
  ------------------
  |  |   29|  2.98k|    do { \
  |  |   30|  2.98k|        h1 += ch; \
  |  |   31|  2.98k|        h1 += h1 << 3; \
  |  |   32|  2.98k|        h2 += h1; \
  |  |   33|  2.98k|        h2 = HASH_ROL(h2, 7); \
  |  |  ------------------
  |  |  |  |   12|  2.98k|#define HASH_ROL(x,n) ((x) << (n) | ((x) & 0xFFFFFFFF) >> (32 - (n)))
  |  |  ------------------
  |  |   34|  2.98k|        h2 += h2 << 2; \
  |  |   35|  2.98k|    } while (0)
  |  |  ------------------
  |  |  |  Branch (35:14): [Folded - Ignored]
  |  |  ------------------
  ------------------
   85|       |
   86|  2.98k|    if (key3 != NULL) {
  ------------------
  |  Branch (86:9): [True: 56, False: 2.93k]
  ------------------
   87|    396|        for (i = 0; key3[i] != 0; i++) {
  ------------------
  |  Branch (87:21): [True: 340, False: 56]
  ------------------
   88|    340|            HASH_UPDATE(h1, h2, key3[i]);
  ------------------
  |  |   29|    340|    do { \
  |  |   30|    340|        h1 += ch; \
  |  |   31|    340|        h1 += h1 << 3; \
  |  |   32|    340|        h2 += h1; \
  |  |   33|    340|        h2 = HASH_ROL(h2, 7); \
  |  |  ------------------
  |  |  |  |   12|    340|#define HASH_ROL(x,n) ((x) << (n) | ((x) & 0xFFFFFFFF) >> (32 - (n)))
  |  |  ------------------
  |  |   34|    340|        h2 += h2 << 2; \
  |  |   35|    340|    } while (0)
  |  |  ------------------
  |  |  |  Branch (35:14): [Folded - Ignored]
  |  |  ------------------
  ------------------
   89|    340|        }
   90|     56|        if (lengths)
  ------------------
  |  Branch (90:13): [True: 8, False: 48]
  ------------------
   91|      8|            lengths[2] = i;
   92|     56|    }
   93|       |
   94|  2.98k|    HASH_FINISH(h1, h2);
  ------------------
  |  |   39|  2.98k|    do { \
  |  |   40|  2.98k|        h1 ^= h2; \
  |  |   41|  2.98k|        h1 += HASH_ROL(h2, 14); \
  |  |  ------------------
  |  |  |  |   12|  2.98k|#define HASH_ROL(x,n) ((x) << (n) | ((x) & 0xFFFFFFFF) >> (32 - (n)))
  |  |  ------------------
  |  |   42|  2.98k|        h2 ^= h1; h2 += HASH_ROR(h1, 6); \
  |  |  ------------------
  |  |  |  |   13|  2.98k|#define HASH_ROR(x,n) (((x) & 0xFFFFFFFF) >> (n) | (x) << (32 - (n)))
  |  |  ------------------
  |  |   43|  2.98k|        h1 ^= h2; h1 += HASH_ROL(h2, 5); \
  |  |  ------------------
  |  |  |  |   12|  2.98k|#define HASH_ROL(x,n) ((x) << (n) | ((x) & 0xFFFFFFFF) >> (32 - (n)))
  |  |  ------------------
  |  |   44|  2.98k|        h2 ^= h1; h2 += HASH_ROR(h1, 8); \
  |  |  ------------------
  |  |  |  |   13|  2.98k|#define HASH_ROR(x,n) (((x) & 0xFFFFFFFF) >> (n) | (x) << (32 - (n)))
  |  |  ------------------
  |  |   45|  2.98k|        h2 &= 0xFFFFFFFF; \
  |  |   46|  2.98k|    } while (0)
  |  |  ------------------
  |  |  |  Branch (46:14): [Folded - Ignored]
  |  |  ------------------
  ------------------
   95|       |
   96|  2.98k|    return(h2);
   97|  2.98k|}
hash.c:xmlHashFindEntry:
  294|  2.70k|                 unsigned hashValue, int *pfound) {
  295|  2.70k|    xmlHashEntry *entry;
  296|  2.70k|    unsigned mask, pos, displ;
  297|  2.70k|    int found = 0;
  298|       |
  299|  2.70k|    mask = hash->size - 1;
  300|  2.70k|    pos = hashValue & mask;
  301|  2.70k|    entry = &hash->table[pos];
  302|       |
  303|  2.70k|    if (entry->hashValue != 0) {
  ------------------
  |  Branch (303:9): [True: 1.59k, False: 1.10k]
  ------------------
  304|       |        /*
  305|       |         * Robin hood hashing: abort if the displacement of the entry
  306|       |         * is smaller than the displacement of the key we look for.
  307|       |         * This also stops at the correct position when inserting.
  308|       |         */
  309|  1.59k|        displ = 0;
  310|  1.59k|        hashValue |= MAX_HASH_SIZE;
  ------------------
  |  |   31|  1.59k|#define MAX_HASH_SIZE (1u << 31)
  ------------------
  311|       |
  312|  3.29k|        do {
  313|  3.29k|            if (entry->hashValue == hashValue) {
  ------------------
  |  Branch (313:17): [True: 87, False: 3.20k]
  ------------------
  314|     87|                if (hash->dict) {
  ------------------
  |  Branch (314:21): [True: 46, False: 41]
  ------------------
  315|     46|                    if ((entry->key == key) &&
  ------------------
  |  Branch (315:25): [True: 40, False: 6]
  ------------------
  316|     46|                        (entry->key2 == key2) &&
  ------------------
  |  Branch (316:25): [True: 40, False: 0]
  ------------------
  317|     46|                        (entry->key3 == key3)) {
  ------------------
  |  Branch (317:25): [True: 40, False: 0]
  ------------------
  318|     40|                        found = 1;
  319|     40|                        break;
  320|     40|                    }
  321|     46|                }
  322|     47|                if ((strcmp((const char *) entry->key,
  ------------------
  |  Branch (322:21): [True: 47, False: 0]
  ------------------
  323|     47|                            (const char *) key) == 0) &&
  324|     47|                    (xmlFastStrEqual(entry->key2, key2)) &&
  ------------------
  |  Branch (324:21): [True: 47, False: 0]
  ------------------
  325|     47|                    (xmlFastStrEqual(entry->key3, key3))) {
  ------------------
  |  Branch (325:21): [True: 47, False: 0]
  ------------------
  326|     47|                    found = 1;
  327|     47|                    break;
  328|     47|                }
  329|     47|            }
  330|       |
  331|  3.20k|            displ++;
  332|  3.20k|            pos++;
  333|  3.20k|            entry++;
  334|  3.20k|            if ((pos & mask) == 0)
  ------------------
  |  Branch (334:17): [True: 344, False: 2.86k]
  ------------------
  335|    344|                entry = hash->table;
  336|  3.20k|        } while ((entry->hashValue != 0) &&
  ------------------
  |  Branch (336:18): [True: 2.70k, False: 501]
  ------------------
  337|  3.20k|                 (((pos - entry->hashValue) & mask) >= displ));
  ------------------
  |  Branch (337:18): [True: 1.69k, False: 1.00k]
  ------------------
  338|  1.59k|    }
  339|       |
  340|      0|    *pfound = found;
  341|  2.70k|    return(entry);
  342|  2.70k|}
hash.c:xmlHashQNameValue:
  104|     22|                  const xmlChar *prefix3, const xmlChar *name3) {
  105|     22|    unsigned h1, h2, ch;
  106|       |
  107|     22|    HASH_INIT(h1, h2, seed);
  ------------------
  |  |   23|     22|    do { \
  |  |   24|     22|        h1 = seed ^ 0x3b00; \
  |  |   25|     22|        h2 = HASH_ROL(seed, 15); \
  |  |  ------------------
  |  |  |  |   12|     22|#define HASH_ROL(x,n) ((x) << (n) | ((x) & 0xFFFFFFFF) >> (32 - (n)))
  |  |  ------------------
  |  |   26|     22|    } while (0)
  |  |  ------------------
  |  |  |  Branch (26:14): [Folded - Ignored]
  |  |  ------------------
  ------------------
  108|       |
  109|     22|    if (prefix != NULL) {
  ------------------
  |  Branch (109:9): [True: 4, False: 18]
  ------------------
  110|     36|        while ((ch = *prefix++) != 0) {
  ------------------
  |  Branch (110:16): [True: 32, False: 4]
  ------------------
  111|     32|            HASH_UPDATE(h1, h2, ch);
  ------------------
  |  |   29|     32|    do { \
  |  |   30|     32|        h1 += ch; \
  |  |   31|     32|        h1 += h1 << 3; \
  |  |   32|     32|        h2 += h1; \
  |  |   33|     32|        h2 = HASH_ROL(h2, 7); \
  |  |  ------------------
  |  |  |  |   12|     32|#define HASH_ROL(x,n) ((x) << (n) | ((x) & 0xFFFFFFFF) >> (32 - (n)))
  |  |  ------------------
  |  |   34|     32|        h2 += h2 << 2; \
  |  |   35|     32|    } while (0)
  |  |  ------------------
  |  |  |  Branch (35:14): [Folded - Ignored]
  |  |  ------------------
  ------------------
  112|     32|        }
  113|      4|        HASH_UPDATE(h1, h2, ':');
  ------------------
  |  |   29|      4|    do { \
  |  |   30|      4|        h1 += ch; \
  |  |   31|      4|        h1 += h1 << 3; \
  |  |   32|      4|        h2 += h1; \
  |  |   33|      4|        h2 = HASH_ROL(h2, 7); \
  |  |  ------------------
  |  |  |  |   12|      4|#define HASH_ROL(x,n) ((x) << (n) | ((x) & 0xFFFFFFFF) >> (32 - (n)))
  |  |  ------------------
  |  |   34|      4|        h2 += h2 << 2; \
  |  |   35|      4|    } while (0)
  |  |  ------------------
  |  |  |  Branch (35:14): [Folded - Ignored]
  |  |  ------------------
  ------------------
  114|      4|    }
  115|     22|    if (name != NULL) {
  ------------------
  |  Branch (115:9): [True: 22, False: 0]
  ------------------
  116|    122|        while ((ch = *name++) != 0) {
  ------------------
  |  Branch (116:16): [True: 100, False: 22]
  ------------------
  117|    100|            HASH_UPDATE(h1, h2, ch);
  ------------------
  |  |   29|    100|    do { \
  |  |   30|    100|        h1 += ch; \
  |  |   31|    100|        h1 += h1 << 3; \
  |  |   32|    100|        h2 += h1; \
  |  |   33|    100|        h2 = HASH_ROL(h2, 7); \
  |  |  ------------------
  |  |  |  |   12|    100|#define HASH_ROL(x,n) ((x) << (n) | ((x) & 0xFFFFFFFF) >> (32 - (n)))
  |  |  ------------------
  |  |   34|    100|        h2 += h2 << 2; \
  |  |   35|    100|    } while (0)
  |  |  ------------------
  |  |  |  Branch (35:14): [Folded - Ignored]
  |  |  ------------------
  ------------------
  118|    100|        }
  119|     22|    }
  120|     22|    HASH_UPDATE(h1, h2, 0);
  ------------------
  |  |   29|     22|    do { \
  |  |   30|     22|        h1 += ch; \
  |  |   31|     22|        h1 += h1 << 3; \
  |  |   32|     22|        h2 += h1; \
  |  |   33|     22|        h2 = HASH_ROL(h2, 7); \
  |  |  ------------------
  |  |  |  |   12|     22|#define HASH_ROL(x,n) ((x) << (n) | ((x) & 0xFFFFFFFF) >> (32 - (n)))
  |  |  ------------------
  |  |   34|     22|        h2 += h2 << 2; \
  |  |   35|     22|    } while (0)
  |  |  ------------------
  |  |  |  Branch (35:14): [Folded - Ignored]
  |  |  ------------------
  ------------------
  121|     22|    if (prefix2 != NULL) {
  ------------------
  |  Branch (121:9): [True: 2, False: 20]
  ------------------
  122|     12|        while ((ch = *prefix2++) != 0) {
  ------------------
  |  Branch (122:16): [True: 10, False: 2]
  ------------------
  123|     10|            HASH_UPDATE(h1, h2, ch);
  ------------------
  |  |   29|     10|    do { \
  |  |   30|     10|        h1 += ch; \
  |  |   31|     10|        h1 += h1 << 3; \
  |  |   32|     10|        h2 += h1; \
  |  |   33|     10|        h2 = HASH_ROL(h2, 7); \
  |  |  ------------------
  |  |  |  |   12|     10|#define HASH_ROL(x,n) ((x) << (n) | ((x) & 0xFFFFFFFF) >> (32 - (n)))
  |  |  ------------------
  |  |   34|     10|        h2 += h2 << 2; \
  |  |   35|     10|    } while (0)
  |  |  ------------------
  |  |  |  Branch (35:14): [Folded - Ignored]
  |  |  ------------------
  ------------------
  124|     10|        }
  125|      2|        HASH_UPDATE(h1, h2, ':');
  ------------------
  |  |   29|      2|    do { \
  |  |   30|      2|        h1 += ch; \
  |  |   31|      2|        h1 += h1 << 3; \
  |  |   32|      2|        h2 += h1; \
  |  |   33|      2|        h2 = HASH_ROL(h2, 7); \
  |  |  ------------------
  |  |  |  |   12|      2|#define HASH_ROL(x,n) ((x) << (n) | ((x) & 0xFFFFFFFF) >> (32 - (n)))
  |  |  ------------------
  |  |   34|      2|        h2 += h2 << 2; \
  |  |   35|      2|    } while (0)
  |  |  ------------------
  |  |  |  Branch (35:14): [Folded - Ignored]
  |  |  ------------------
  ------------------
  126|      2|    }
  127|     22|    if (name2 != NULL) {
  ------------------
  |  Branch (127:9): [True: 22, False: 0]
  ------------------
  128|    118|        while ((ch = *name2++) != 0) {
  ------------------
  |  Branch (128:16): [True: 96, False: 22]
  ------------------
  129|     96|            HASH_UPDATE(h1, h2, ch);
  ------------------
  |  |   29|     96|    do { \
  |  |   30|     96|        h1 += ch; \
  |  |   31|     96|        h1 += h1 << 3; \
  |  |   32|     96|        h2 += h1; \
  |  |   33|     96|        h2 = HASH_ROL(h2, 7); \
  |  |  ------------------
  |  |  |  |   12|     96|#define HASH_ROL(x,n) ((x) << (n) | ((x) & 0xFFFFFFFF) >> (32 - (n)))
  |  |  ------------------
  |  |   34|     96|        h2 += h2 << 2; \
  |  |   35|     96|    } while (0)
  |  |  ------------------
  |  |  |  Branch (35:14): [Folded - Ignored]
  |  |  ------------------
  ------------------
  130|     96|        }
  131|     22|    }
  132|     22|    HASH_UPDATE(h1, h2, 0);
  ------------------
  |  |   29|     22|    do { \
  |  |   30|     22|        h1 += ch; \
  |  |   31|     22|        h1 += h1 << 3; \
  |  |   32|     22|        h2 += h1; \
  |  |   33|     22|        h2 = HASH_ROL(h2, 7); \
  |  |  ------------------
  |  |  |  |   12|     22|#define HASH_ROL(x,n) ((x) << (n) | ((x) & 0xFFFFFFFF) >> (32 - (n)))
  |  |  ------------------
  |  |   34|     22|        h2 += h2 << 2; \
  |  |   35|     22|    } while (0)
  |  |  ------------------
  |  |  |  Branch (35:14): [Folded - Ignored]
  |  |  ------------------
  ------------------
  133|     22|    if (prefix3 != NULL) {
  ------------------
  |  Branch (133:9): [True: 0, False: 22]
  ------------------
  134|      0|        while ((ch = *prefix3++) != 0) {
  ------------------
  |  Branch (134:16): [True: 0, False: 0]
  ------------------
  135|      0|            HASH_UPDATE(h1, h2, ch);
  ------------------
  |  |   29|      0|    do { \
  |  |   30|      0|        h1 += ch; \
  |  |   31|      0|        h1 += h1 << 3; \
  |  |   32|      0|        h2 += h1; \
  |  |   33|      0|        h2 = HASH_ROL(h2, 7); \
  |  |  ------------------
  |  |  |  |   12|      0|#define HASH_ROL(x,n) ((x) << (n) | ((x) & 0xFFFFFFFF) >> (32 - (n)))
  |  |  ------------------
  |  |   34|      0|        h2 += h2 << 2; \
  |  |   35|      0|    } while (0)
  |  |  ------------------
  |  |  |  Branch (35:14): [Folded - Ignored]
  |  |  ------------------
  ------------------
  136|      0|        }
  137|      0|        HASH_UPDATE(h1, h2, ':');
  ------------------
  |  |   29|      0|    do { \
  |  |   30|      0|        h1 += ch; \
  |  |   31|      0|        h1 += h1 << 3; \
  |  |   32|      0|        h2 += h1; \
  |  |   33|      0|        h2 = HASH_ROL(h2, 7); \
  |  |  ------------------
  |  |  |  |   12|      0|#define HASH_ROL(x,n) ((x) << (n) | ((x) & 0xFFFFFFFF) >> (32 - (n)))
  |  |  ------------------
  |  |   34|      0|        h2 += h2 << 2; \
  |  |   35|      0|    } while (0)
  |  |  ------------------
  |  |  |  Branch (35:14): [Folded - Ignored]
  |  |  ------------------
  ------------------
  138|      0|    }
  139|     22|    if (name3 != NULL) {
  ------------------
  |  Branch (139:9): [True: 0, False: 22]
  ------------------
  140|      0|        while ((ch = *name3++) != 0) {
  ------------------
  |  Branch (140:16): [True: 0, False: 0]
  ------------------
  141|      0|            HASH_UPDATE(h1, h2, ch);
  ------------------
  |  |   29|      0|    do { \
  |  |   30|      0|        h1 += ch; \
  |  |   31|      0|        h1 += h1 << 3; \
  |  |   32|      0|        h2 += h1; \
  |  |   33|      0|        h2 = HASH_ROL(h2, 7); \
  |  |  ------------------
  |  |  |  |   12|      0|#define HASH_ROL(x,n) ((x) << (n) | ((x) & 0xFFFFFFFF) >> (32 - (n)))
  |  |  ------------------
  |  |   34|      0|        h2 += h2 << 2; \
  |  |   35|      0|    } while (0)
  |  |  ------------------
  |  |  |  Branch (35:14): [Folded - Ignored]
  |  |  ------------------
  ------------------
  142|      0|        }
  143|      0|    }
  144|       |
  145|     22|    HASH_FINISH(h1, h2);
  ------------------
  |  |   39|     22|    do { \
  |  |   40|     22|        h1 ^= h2; \
  |  |   41|     22|        h1 += HASH_ROL(h2, 14); \
  |  |  ------------------
  |  |  |  |   12|     22|#define HASH_ROL(x,n) ((x) << (n) | ((x) & 0xFFFFFFFF) >> (32 - (n)))
  |  |  ------------------
  |  |   42|     22|        h2 ^= h1; h2 += HASH_ROR(h1, 6); \
  |  |  ------------------
  |  |  |  |   13|     22|#define HASH_ROR(x,n) (((x) & 0xFFFFFFFF) >> (n) | (x) << (32 - (n)))
  |  |  ------------------
  |  |   43|     22|        h1 ^= h2; h1 += HASH_ROL(h2, 5); \
  |  |  ------------------
  |  |  |  |   12|     22|#define HASH_ROL(x,n) ((x) << (n) | ((x) & 0xFFFFFFFF) >> (32 - (n)))
  |  |  ------------------
  |  |   44|     22|        h2 ^= h1; h2 += HASH_ROR(h1, 8); \
  |  |  ------------------
  |  |  |  |   13|     22|#define HASH_ROR(x,n) (((x) & 0xFFFFFFFF) >> (n) | (x) << (32 - (n)))
  |  |  ------------------
  |  |   45|     22|        h2 &= 0xFFFFFFFF; \
  |  |   46|     22|    } while (0)
  |  |  ------------------
  |  |  |  Branch (46:14): [Folded - Ignored]
  |  |  ------------------
  ------------------
  146|       |
  147|     22|    return(h2);
  148|     22|}
hash.c:xmlFastStrEqual:
  269|     94|xmlFastStrEqual(const xmlChar *s1, const xmlChar *s2) {
  270|     94|    if (s1 == NULL)
  ------------------
  |  Branch (270:9): [True: 94, False: 0]
  ------------------
  271|     94|        return(s2 == NULL);
  272|      0|    else
  273|      0|        return((s2 != NULL) &&
  ------------------
  |  Branch (273:16): [True: 0, False: 0]
  ------------------
  274|      0|               (strcmp((const char *) s1, (const char *) s2) == 0));
  ------------------
  |  Branch (274:16): [True: 0, False: 0]
  ------------------
  275|     94|}

xmlParserNsCreate:
 1407|    454|xmlParserNsCreate(void) {
 1408|    454|    xmlParserNsData *nsdb = xmlMalloc(sizeof(*nsdb));
 1409|       |
 1410|    454|    if (nsdb == NULL)
  ------------------
  |  Branch (1410:9): [True: 0, False: 454]
  ------------------
 1411|      0|        return(NULL);
 1412|    454|    memset(nsdb, 0, sizeof(*nsdb));
 1413|    454|    nsdb->defaultNsIndex = INT_MAX;
 1414|       |
 1415|    454|    return(nsdb);
 1416|    454|}
xmlParserNsFree:
 1425|    454|xmlParserNsFree(xmlParserNsData *nsdb) {
 1426|    454|    if (nsdb == NULL)
  ------------------
  |  Branch (1426:9): [True: 0, False: 454]
  ------------------
 1427|      0|        return;
 1428|       |
 1429|    454|    xmlFree(nsdb->extra);
 1430|    454|    xmlFree(nsdb->hash);
 1431|    454|    xmlFree(nsdb);
 1432|    454|}
xmlParserNsLookupSax:
 1560|    986|xmlParserNsLookupSax(xmlParserCtxtPtr ctxt, const xmlChar *prefix) {
 1561|    986|    xmlHashedString hprefix;
 1562|    986|    int nsIndex;
 1563|       |
 1564|    986|    if (prefix == ctxt->str_xml)
  ------------------
  |  Branch (1564:9): [True: 12, False: 974]
  ------------------
 1565|     12|        return(NULL);
 1566|       |
 1567|    974|    hprefix.name = prefix;
 1568|    974|    if (prefix != NULL)
  ------------------
  |  Branch (1568:9): [True: 974, False: 0]
  ------------------
 1569|    974|        hprefix.hashValue = xmlDictComputeHash(ctxt->dict, prefix);
 1570|      0|    else
 1571|      0|        hprefix.hashValue = 0;
 1572|    974|    nsIndex = xmlParserNsLookup(ctxt, &hprefix, NULL);
 1573|    974|    if (nsIndex == INT_MAX)
  ------------------
  |  Branch (1573:9): [True: 0, False: 974]
  ------------------
 1574|      0|        return(NULL);
 1575|       |
 1576|    974|    return(ctxt->nsdb->extra[nsIndex].saxData);
 1577|    974|}
xmlParserNsUpdateSax:
 1593|    264|                     void *saxData) {
 1594|    264|    xmlHashedString hprefix;
 1595|    264|    int nsIndex;
 1596|       |
 1597|    264|    if (prefix == ctxt->str_xml)
  ------------------
  |  Branch (1597:9): [True: 0, False: 264]
  ------------------
 1598|      0|        return(-1);
 1599|       |
 1600|    264|    hprefix.name = prefix;
 1601|    264|    if (prefix != NULL)
  ------------------
  |  Branch (1601:9): [True: 264, False: 0]
  ------------------
 1602|    264|        hprefix.hashValue = xmlDictComputeHash(ctxt->dict, prefix);
 1603|      0|    else
 1604|      0|        hprefix.hashValue = 0;
 1605|    264|    nsIndex = xmlParserNsLookup(ctxt, &hprefix, NULL);
 1606|    264|    if (nsIndex == INT_MAX)
  ------------------
  |  Branch (1606:9): [True: 0, False: 264]
  ------------------
 1607|      0|        return(-1);
 1608|       |
 1609|    264|    ctxt->nsdb->extra[nsIndex].saxData = saxData;
 1610|    264|    return(0);
 1611|    264|}
inputPush:
 1893|    363|{
 1894|    363|    if ((ctxt == NULL) || (value == NULL))
  ------------------
  |  Branch (1894:9): [True: 0, False: 363]
  |  Branch (1894:27): [True: 0, False: 363]
  ------------------
 1895|      0|        return(-1);
 1896|    363|    if (ctxt->inputNr >= ctxt->inputMax) {
  ------------------
  |  Branch (1896:9): [True: 0, False: 363]
  ------------------
 1897|      0|        size_t newSize = ctxt->inputMax * 2;
 1898|      0|        xmlParserInputPtr *tmp;
 1899|       |
 1900|      0|        tmp = (xmlParserInputPtr *) xmlRealloc(ctxt->inputTab,
 1901|      0|                                               newSize * sizeof(*tmp));
 1902|      0|        if (tmp == NULL) {
  ------------------
  |  Branch (1902:13): [True: 0, False: 0]
  ------------------
 1903|      0|            xmlErrMemory(ctxt, NULL);
 1904|      0|            return (-1);
 1905|      0|        }
 1906|      0|        ctxt->inputTab = tmp;
 1907|      0|        ctxt->inputMax = newSize;
 1908|      0|    }
 1909|    363|    ctxt->inputTab[ctxt->inputNr] = value;
 1910|    363|    ctxt->input = value;
 1911|    363|    return (ctxt->inputNr++);
 1912|    363|}
inputPop:
 1923|  1.27k|{
 1924|  1.27k|    xmlParserInputPtr ret;
 1925|       |
 1926|  1.27k|    if (ctxt == NULL)
  ------------------
  |  Branch (1926:9): [True: 0, False: 1.27k]
  ------------------
 1927|      0|        return(NULL);
 1928|  1.27k|    if (ctxt->inputNr <= 0)
  ------------------
  |  Branch (1928:9): [True: 908, False: 363]
  ------------------
 1929|    908|        return (NULL);
 1930|    363|    ctxt->inputNr--;
 1931|    363|    if (ctxt->inputNr > 0)
  ------------------
  |  Branch (1931:9): [True: 0, False: 363]
  ------------------
 1932|      0|        ctxt->input = ctxt->inputTab[ctxt->inputNr - 1];
 1933|    363|    else
 1934|    363|        ctxt->input = NULL;
 1935|    363|    ret = ctxt->inputTab[ctxt->inputNr];
 1936|    363|    ctxt->inputTab[ctxt->inputNr] = NULL;
 1937|    363|    return (ret);
 1938|  1.27k|}
nodePush:
 1952|  2.20k|{
 1953|  2.20k|    if (ctxt == NULL) return(0);
  ------------------
  |  Branch (1953:9): [True: 0, False: 2.20k]
  ------------------
 1954|  2.20k|    if (ctxt->nodeNr >= ctxt->nodeMax) {
  ------------------
  |  Branch (1954:9): [True: 12, False: 2.19k]
  ------------------
 1955|     12|        xmlNodePtr *tmp;
 1956|       |
 1957|     12|	tmp = (xmlNodePtr *) xmlRealloc(ctxt->nodeTab,
 1958|     12|                                      ctxt->nodeMax * 2 *
 1959|     12|                                      sizeof(ctxt->nodeTab[0]));
 1960|     12|        if (tmp == NULL) {
  ------------------
  |  Branch (1960:13): [True: 0, False: 12]
  ------------------
 1961|      0|            xmlErrMemory(ctxt, NULL);
 1962|      0|            return (-1);
 1963|      0|        }
 1964|     12|        ctxt->nodeTab = tmp;
 1965|     12|	ctxt->nodeMax *= 2;
 1966|     12|    }
 1967|  2.20k|    if ((((unsigned int) ctxt->nodeNr) > xmlParserMaxDepth) &&
  ------------------
  |  Branch (1967:9): [True: 0, False: 2.20k]
  ------------------
 1968|  2.20k|        ((ctxt->options & XML_PARSE_HUGE) == 0)) {
  ------------------
  |  Branch (1968:9): [True: 0, False: 0]
  ------------------
 1969|      0|	xmlFatalErrMsgInt(ctxt, XML_ERR_INTERNAL_ERROR,
 1970|      0|		 "Excessive depth in document: %d use XML_PARSE_HUGE option\n",
 1971|      0|			  xmlParserMaxDepth);
 1972|      0|	xmlHaltParser(ctxt);
 1973|      0|	return(-1);
 1974|      0|    }
 1975|  2.20k|    ctxt->nodeTab[ctxt->nodeNr] = value;
 1976|  2.20k|    ctxt->node = value;
 1977|  2.20k|    return (ctxt->nodeNr++);
 1978|  2.20k|}
nodePop:
 1992|  2.00k|{
 1993|  2.00k|    xmlNodePtr ret;
 1994|       |
 1995|  2.00k|    if (ctxt == NULL) return(NULL);
  ------------------
  |  Branch (1995:9): [True: 0, False: 2.00k]
  ------------------
 1996|  2.00k|    if (ctxt->nodeNr <= 0)
  ------------------
  |  Branch (1996:9): [True: 47, False: 1.96k]
  ------------------
 1997|     47|        return (NULL);
 1998|  1.96k|    ctxt->nodeNr--;
 1999|  1.96k|    if (ctxt->nodeNr > 0)
  ------------------
  |  Branch (1999:9): [True: 1.81k, False: 142]
  ------------------
 2000|  1.81k|        ctxt->node = ctxt->nodeTab[ctxt->nodeNr - 1];
 2001|    142|    else
 2002|    142|        ctxt->node = NULL;
 2003|  1.96k|    ret = ctxt->nodeTab[ctxt->nodeNr];
 2004|  1.96k|    ctxt->nodeTab[ctxt->nodeNr] = NULL;
 2005|  1.96k|    return (ret);
 2006|  2.00k|}
namePop:
 2139|  1.51k|{
 2140|  1.51k|    const xmlChar *ret;
 2141|       |
 2142|  1.51k|    if ((ctxt == NULL) || (ctxt->nameNr <= 0))
  ------------------
  |  Branch (2142:9): [True: 0, False: 1.51k]
  |  Branch (2142:27): [True: 0, False: 1.51k]
  ------------------
 2143|      0|        return (NULL);
 2144|  1.51k|    ctxt->nameNr--;
 2145|  1.51k|    if (ctxt->nameNr > 0)
  ------------------
  |  Branch (2145:9): [True: 1.36k, False: 146]
  ------------------
 2146|  1.36k|        ctxt->name = ctxt->nameTab[ctxt->nameNr - 1];
 2147|    146|    else
 2148|    146|        ctxt->name = NULL;
 2149|  1.51k|    ret = ctxt->nameTab[ctxt->nameNr];
 2150|  1.51k|    ctxt->nameTab[ctxt->nameNr] = NULL;
 2151|  1.51k|    return (ret);
 2152|  1.51k|}
xmlSkipBlankChars:
 2311|  8.45k|xmlSkipBlankChars(xmlParserCtxtPtr ctxt) {
 2312|  8.45k|    int res = 0;
 2313|       |
 2314|       |    /*
 2315|       |     * It's Okay to use CUR/NEXT here since all the blanks are on
 2316|       |     * the ASCII range.
 2317|       |     */
 2318|  8.45k|    if (((ctxt->inputNr == 1) && (ctxt->instate != XML_PARSER_DTD)) ||
  ------------------
  |  Branch (2318:10): [True: 8.45k, False: 0]
  |  Branch (2318:34): [True: 8.25k, False: 200]
  ------------------
 2319|  8.45k|        (ctxt->instate == XML_PARSER_START)) {
  ------------------
  |  Branch (2319:9): [True: 0, False: 200]
  ------------------
 2320|  8.25k|	const xmlChar *cur;
 2321|       |	/*
 2322|       |	 * if we are in the document content, go really fast
 2323|       |	 */
 2324|  8.25k|	cur = ctxt->input->cur;
 2325|  8.25k|	while (IS_BLANK_CH(*cur)) {
 2326|  2.03k|	    if (*cur == '\n') {
  ------------------
  |  Branch (2326:10): [True: 257, False: 1.78k]
  ------------------
 2327|    257|		ctxt->input->line++; ctxt->input->col = 1;
 2328|  1.78k|	    } else {
 2329|  1.78k|		ctxt->input->col++;
 2330|  1.78k|	    }
 2331|  2.03k|	    cur++;
 2332|  2.03k|	    if (res < INT_MAX)
  ------------------
  |  Branch (2332:10): [True: 2.03k, False: 0]
  ------------------
 2333|  2.03k|		res++;
 2334|  2.03k|	    if (*cur == 0) {
  ------------------
  |  Branch (2334:10): [True: 143, False: 1.89k]
  ------------------
 2335|    143|		ctxt->input->cur = cur;
 2336|    143|		xmlParserGrow(ctxt);
 2337|    143|		cur = ctxt->input->cur;
 2338|    143|	    }
 2339|  2.03k|	}
 2340|  8.25k|	ctxt->input->cur = cur;
 2341|  8.25k|    } else {
 2342|    200|        int expandPE = ((ctxt->external != 0) || (ctxt->inputNr != 1));
  ------------------
  |  Branch (2342:25): [True: 0, False: 200]
  |  Branch (2342:50): [True: 0, False: 200]
  ------------------
 2343|       |
 2344|    314|	while (ctxt->instate != XML_PARSER_EOF) {
  ------------------
  |  Branch (2344:9): [True: 314, False: 0]
  ------------------
 2345|    314|            if (IS_BLANK_CH(CUR)) { /* CHECKED tstblanks.xml */
  ------------------
  |  |  151|    314|#define IS_BLANK_CH(c)  xmlIsBlank_ch(c)
  |  |  ------------------
  |  |  |  |   88|    314|#define xmlIsBlank_ch(c)	(((c) == 0x20) || \
  |  |  |  |  ------------------
  |  |  |  |  |  Branch (88:27): [True: 76, False: 238]
  |  |  |  |  ------------------
  |  |  |  |   89|    314|				 ((0x9 <= (c)) && ((c) <= 0xa)) || \
  |  |  |  |  ------------------
  |  |  |  |  |  Branch (89:7): [True: 238, False: 0]
  |  |  |  |  |  Branch (89:23): [True: 38, False: 200]
  |  |  |  |  ------------------
  |  |  |  |   90|    314|				 ((c) == 0xd))
  |  |  |  |  ------------------
  |  |  |  |  |  Branch (90:6): [True: 0, False: 200]
  |  |  |  |  ------------------
  |  |  ------------------
  ------------------
 2346|    114|		NEXT;
  ------------------
  |  | 2275|    114|#define NEXT xmlNextChar(ctxt)
  ------------------
 2347|    200|	    } else if (CUR == '%') {
  ------------------
  |  | 2222|    200|#define CUR (*ctxt->input->cur)
  ------------------
  |  Branch (2347:17): [True: 0, False: 200]
  ------------------
 2348|       |                /*
 2349|       |                 * Need to handle support of entities branching here
 2350|       |                 */
 2351|      0|	        if ((expandPE == 0) || (IS_BLANK_CH(NXT(1))) || (NXT(1) == 0))
  ------------------
  |  |  151|      0|#define IS_BLANK_CH(c)  xmlIsBlank_ch(c)
  |  |  ------------------
  |  |  |  |   88|      0|#define xmlIsBlank_ch(c)	(((c) == 0x20) || \
  |  |  |  |  ------------------
  |  |  |  |  |  Branch (88:27): [True: 0, False: 0]
  |  |  |  |  ------------------
  |  |  |  |   89|      0|				 ((0x9 <= (c)) && ((c) <= 0xa)) || \
  |  |  |  |  ------------------
  |  |  |  |  |  Branch (89:7): [True: 0, False: 0]
  |  |  |  |  |  Branch (89:23): [True: 0, False: 0]
  |  |  |  |  ------------------
  |  |  |  |   90|      0|				 ((c) == 0xd))
  |  |  |  |  ------------------
  |  |  |  |  |  Branch (90:6): [True: 0, False: 0]
  |  |  |  |  ------------------
  |  |  ------------------
  ------------------
              	        if ((expandPE == 0) || (IS_BLANK_CH(NXT(1))) || (NXT(1) == 0))
  ------------------
  |  | 2223|      0|#define NXT(val) ctxt->input->cur[(val)]
  ------------------
  |  Branch (2351:14): [True: 0, False: 0]
  |  Branch (2351:58): [True: 0, False: 0]
  ------------------
 2352|      0|                    break;
 2353|      0|	        xmlParsePEReference(ctxt);
 2354|    200|            } else if (CUR == 0) {
  ------------------
  |  | 2222|    200|#define CUR (*ctxt->input->cur)
  ------------------
  |  Branch (2354:24): [True: 0, False: 200]
  ------------------
 2355|      0|                unsigned long consumed;
 2356|      0|                xmlEntityPtr ent;
 2357|       |
 2358|      0|                if (ctxt->inputNr <= 1)
  ------------------
  |  Branch (2358:21): [True: 0, False: 0]
  ------------------
 2359|      0|                    break;
 2360|       |
 2361|      0|                consumed = ctxt->input->consumed;
 2362|      0|                xmlSaturatedAddSizeT(&consumed,
 2363|      0|                                     ctxt->input->cur - ctxt->input->base);
 2364|       |
 2365|       |                /*
 2366|       |                 * Add to sizeentities when parsing an external entity
 2367|       |                 * for the first time.
 2368|       |                 */
 2369|      0|                ent = ctxt->input->entity;
 2370|      0|                if ((ent->etype == XML_EXTERNAL_PARAMETER_ENTITY) &&
  ------------------
  |  Branch (2370:21): [True: 0, False: 0]
  ------------------
 2371|      0|                    ((ent->flags & XML_ENT_PARSED) == 0)) {
  ------------------
  |  |   14|      0|#define XML_ENT_PARSED      (1<<0)
  ------------------
  |  Branch (2371:21): [True: 0, False: 0]
  ------------------
 2372|      0|                    ent->flags |= XML_ENT_PARSED;
  ------------------
  |  |   14|      0|#define XML_ENT_PARSED      (1<<0)
  ------------------
 2373|       |
 2374|      0|                    xmlSaturatedAdd(&ctxt->sizeentities, consumed);
 2375|      0|                }
 2376|       |
 2377|      0|                xmlParserEntityCheck(ctxt, consumed);
 2378|       |
 2379|      0|                xmlPopInput(ctxt);
 2380|    200|            } else {
 2381|    200|                break;
 2382|    200|            }
 2383|       |
 2384|       |            /*
 2385|       |             * Also increase the counter when entering or exiting a PERef.
 2386|       |             * The spec says: "When a parameter-entity reference is recognized
 2387|       |             * in the DTD and included, its replacement text MUST be enlarged
 2388|       |             * by the attachment of one leading and one following space (#x20)
 2389|       |             * character."
 2390|       |             */
 2391|    114|	    if (res < INT_MAX)
  ------------------
  |  Branch (2391:10): [True: 114, False: 0]
  ------------------
 2392|    114|		res++;
 2393|    114|        }
 2394|    200|    }
 2395|  8.45k|    return(res);
 2396|  8.45k|}
xmlStringDecodeEntities:
 3046|      2|		        xmlChar end, xmlChar  end2, xmlChar end3) {
 3047|      2|    if ((ctxt == NULL) || (str == NULL)) return(NULL);
  ------------------
  |  Branch (3047:9): [True: 0, False: 2]
  |  Branch (3047:27): [True: 0, False: 2]
  ------------------
 3048|      2|    return(xmlStringDecodeEntitiesInt(ctxt, str, xmlStrlen(str), what,
 3049|      2|                                      end, end2, end3, 0));
 3050|      2|}
xmlSplitQName:
 3152|     17|xmlSplitQName(xmlParserCtxtPtr ctxt, const xmlChar *name, xmlChar **prefix) {
 3153|     17|    xmlChar buf[XML_MAX_NAMELEN + 5];
 3154|     17|    xmlChar *buffer = NULL;
 3155|     17|    int len = 0;
 3156|     17|    int max = XML_MAX_NAMELEN;
  ------------------
  |  |   89|     17|#define XML_MAX_NAMELEN 100
  ------------------
 3157|     17|    xmlChar *ret = NULL;
 3158|     17|    const xmlChar *cur = name;
 3159|     17|    int c;
 3160|       |
 3161|     17|    if (prefix == NULL) return(NULL);
  ------------------
  |  Branch (3161:9): [True: 0, False: 17]
  ------------------
 3162|     17|    *prefix = NULL;
 3163|       |
 3164|     17|    if (cur == NULL) return(NULL);
  ------------------
  |  Branch (3164:9): [True: 0, False: 17]
  ------------------
 3165|       |
 3166|       |#ifndef XML_XML_NAMESPACE
 3167|       |    /* xml: prefix is not really a namespace */
 3168|       |    if ((cur[0] == 'x') && (cur[1] == 'm') &&
 3169|       |        (cur[2] == 'l') && (cur[3] == ':'))
 3170|       |	return(xmlStrdup(name));
 3171|       |#endif
 3172|       |
 3173|       |    /* nasty but well=formed */
 3174|     17|    if (cur[0] == ':')
  ------------------
  |  Branch (3174:9): [True: 0, False: 17]
  ------------------
 3175|      0|	return(xmlStrdup(name));
 3176|       |
 3177|     17|    c = *cur++;
 3178|     88|    while ((c != 0) && (c != ':') && (len < max)) { /* tested bigname.xml */
  ------------------
  |  Branch (3178:12): [True: 75, False: 13]
  |  Branch (3178:24): [True: 71, False: 4]
  |  Branch (3178:38): [True: 71, False: 0]
  ------------------
 3179|     71|	buf[len++] = c;
 3180|     71|	c = *cur++;
 3181|     71|    }
 3182|     17|    if (len >= max) {
  ------------------
  |  Branch (3182:9): [True: 0, False: 17]
  ------------------
 3183|       |	/*
 3184|       |	 * Okay someone managed to make a huge name, so he's ready to pay
 3185|       |	 * for the processing speed.
 3186|       |	 */
 3187|      0|	max = len * 2;
 3188|       |
 3189|      0|	buffer = (xmlChar *) xmlMallocAtomic(max);
 3190|      0|	if (buffer == NULL) {
  ------------------
  |  Branch (3190:6): [True: 0, False: 0]
  ------------------
 3191|      0|	    xmlErrMemory(ctxt, NULL);
 3192|      0|	    return(NULL);
 3193|      0|	}
 3194|      0|	memcpy(buffer, buf, len);
 3195|      0|	while ((c != 0) && (c != ':')) { /* tested bigname.xml */
  ------------------
  |  Branch (3195:9): [True: 0, False: 0]
  |  Branch (3195:21): [True: 0, False: 0]
  ------------------
 3196|      0|	    if (len + 10 > max) {
  ------------------
  |  Branch (3196:10): [True: 0, False: 0]
  ------------------
 3197|      0|	        xmlChar *tmp;
 3198|       |
 3199|      0|		max *= 2;
 3200|      0|		tmp = (xmlChar *) xmlRealloc(buffer, max);
 3201|      0|		if (tmp == NULL) {
  ------------------
  |  Branch (3201:7): [True: 0, False: 0]
  ------------------
 3202|      0|		    xmlFree(buffer);
 3203|      0|		    xmlErrMemory(ctxt, NULL);
 3204|      0|		    return(NULL);
 3205|      0|		}
 3206|      0|		buffer = tmp;
 3207|      0|	    }
 3208|      0|	    buffer[len++] = c;
 3209|      0|	    c = *cur++;
 3210|      0|	}
 3211|      0|	buffer[len] = 0;
 3212|      0|    }
 3213|       |
 3214|     17|    if ((c == ':') && (*cur == 0)) {
  ------------------
  |  Branch (3214:9): [True: 4, False: 13]
  |  Branch (3214:23): [True: 0, False: 4]
  ------------------
 3215|      0|        if (buffer != NULL)
  ------------------
  |  Branch (3215:13): [True: 0, False: 0]
  ------------------
 3216|      0|	    xmlFree(buffer);
 3217|      0|	*prefix = NULL;
 3218|      0|	return(xmlStrdup(name));
 3219|      0|    }
 3220|       |
 3221|     17|    if (buffer == NULL)
  ------------------
  |  Branch (3221:9): [True: 17, False: 0]
  ------------------
 3222|     17|	ret = xmlStrndup(buf, len);
 3223|      0|    else {
 3224|      0|	ret = buffer;
 3225|      0|	buffer = NULL;
 3226|      0|	max = XML_MAX_NAMELEN;
  ------------------
  |  |   89|      0|#define XML_MAX_NAMELEN 100
  ------------------
 3227|      0|    }
 3228|       |
 3229|       |
 3230|     17|    if (c == ':') {
  ------------------
  |  Branch (3230:9): [True: 4, False: 13]
  ------------------
 3231|      4|	c = *cur;
 3232|      4|        *prefix = ret;
 3233|      4|	if (c == 0) {
  ------------------
  |  Branch (3233:6): [True: 0, False: 4]
  ------------------
 3234|      0|	    return(xmlStrndup(BAD_CAST "", 0));
  ------------------
  |  |   35|      0|#define BAD_CAST (xmlChar *)
  ------------------
 3235|      0|	}
 3236|      4|	len = 0;
 3237|       |
 3238|       |	/*
 3239|       |	 * Check that the first character is proper to start
 3240|       |	 * a new name
 3241|       |	 */
 3242|      4|	if (!(((c >= 0x61) && (c <= 0x7A)) ||
  ------------------
  |  Branch (3242:9): [True: 4, False: 0]
  |  Branch (3242:24): [True: 4, False: 0]
  ------------------
 3243|      4|	      ((c >= 0x41) && (c <= 0x5A)) ||
  ------------------
  |  Branch (3243:9): [True: 0, False: 0]
  |  Branch (3243:24): [True: 0, False: 0]
  ------------------
 3244|      4|	      (c == '_') || (c == ':'))) {
  ------------------
  |  Branch (3244:8): [True: 0, False: 0]
  |  Branch (3244:22): [True: 0, False: 0]
  ------------------
 3245|      0|	    int l;
 3246|      0|	    int first = CUR_SCHAR(cur, l);
  ------------------
  |  | 2292|      0|#define CUR_SCHAR(s, l) xmlStringCurrentChar(ctxt, s, &l)
  ------------------
 3247|       |
 3248|      0|	    if (!IS_LETTER(first) && (first != '_')) {
  ------------------
  |  |  240|      0|#define IS_LETTER(c) (IS_BASECHAR(c) || IS_IDEOGRAPHIC(c))
  |  |  ------------------
  |  |  |  |  161|      0|#define IS_BASECHAR(c) xmlIsBaseCharQ(c)
  |  |  |  |  ------------------
  |  |  |  |  |  |   76|      0|#define xmlIsBaseCharQ(c)	(((c) < 0x100) ? \
  |  |  |  |  |  |  ------------------
  |  |  |  |  |  |  |  Branch (76:27): [True: 0, False: 0]
  |  |  |  |  |  |  |  Branch (76:28): [True: 0, False: 0]
  |  |  |  |  |  |  ------------------
  |  |  |  |  |  |   77|      0|				 xmlIsBaseChar_ch((c)) : \
  |  |  |  |  |  |  ------------------
  |  |  |  |  |  |  |  |   64|      0|#define xmlIsBaseChar_ch(c)	(((0x41 <= (c)) && ((c) <= 0x5a)) || \
  |  |  |  |  |  |  |  |  ------------------
  |  |  |  |  |  |  |  |  |  Branch (64:31): [True: 0, False: 0]
  |  |  |  |  |  |  |  |  |  Branch (64:48): [True: 0, False: 0]
  |  |  |  |  |  |  |  |  ------------------
  |  |  |  |  |  |  |  |   65|      0|				 ((0x61 <= (c)) && ((c) <= 0x7a)) || \
  |  |  |  |  |  |  |  |  ------------------
  |  |  |  |  |  |  |  |  |  Branch (65:7): [True: 0, False: 0]
  |  |  |  |  |  |  |  |  |  Branch (65:24): [True: 0, False: 0]
  |  |  |  |  |  |  |  |  ------------------
  |  |  |  |  |  |  |  |   66|      0|				 ((0xc0 <= (c)) && ((c) <= 0xd6)) || \
  |  |  |  |  |  |  |  |  ------------------
  |  |  |  |  |  |  |  |  |  Branch (66:7): [True: 0, False: 0]
  |  |  |  |  |  |  |  |  |  Branch (66:24): [True: 0, False: 0]
  |  |  |  |  |  |  |  |  ------------------
  |  |  |  |  |  |  |  |   67|      0|				 ((0xd8 <= (c)) && ((c) <= 0xf6)) || \
  |  |  |  |  |  |  |  |  ------------------
  |  |  |  |  |  |  |  |  |  Branch (67:7): [True: 0, False: 0]
  |  |  |  |  |  |  |  |  |  Branch (67:24): [True: 0, False: 0]
  |  |  |  |  |  |  |  |  ------------------
  |  |  |  |  |  |  |  |   68|      0|				  (0xf8 <= (c)))
  |  |  |  |  |  |  |  |  ------------------
  |  |  |  |  |  |  |  |  |  Branch (68:7): [True: 0, False: 0]
  |  |  |  |  |  |  |  |  ------------------
  |  |  |  |  |  |  ------------------
  |  |  |  |  |  |   78|      0|				 xmlCharInRange((c), &xmlIsBaseCharGroup))
  |  |  |  |  ------------------
  |  |  ------------------
  |  |               #define IS_LETTER(c) (IS_BASECHAR(c) || IS_IDEOGRAPHIC(c))
  |  |  ------------------
  |  |  |  |  229|      0|#define IS_IDEOGRAPHIC(c) xmlIsIdeographicQ(c)
  |  |  |  |  ------------------
  |  |  |  |  |  |  184|      0|#define xmlIsIdeographicQ(c)	(((c) < 0x100) ? \
  |  |  |  |  |  |  ------------------
  |  |  |  |  |  |  |  Branch (184:30): [True: 0, False: 0]
  |  |  |  |  |  |  |  Branch (184:31): [True: 0, False: 0]
  |  |  |  |  |  |  ------------------
  |  |  |  |  |  |  185|      0|				 0 :\
  |  |  |  |  |  |  186|      0|				(((0x4e00 <= (c)) && ((c) <= 0x9fa5)) || \
  |  |  |  |  |  |  ------------------
  |  |  |  |  |  |  |  Branch (186:7): [True: 0, False: 0]
  |  |  |  |  |  |  |  Branch (186:26): [True: 0, False: 0]
  |  |  |  |  |  |  ------------------
  |  |  |  |  |  |  187|      0|				 ((c) == 0x3007) || \
  |  |  |  |  |  |  ------------------
  |  |  |  |  |  |  |  Branch (187:6): [True: 0, False: 0]
  |  |  |  |  |  |  ------------------
  |  |  |  |  |  |  188|      0|				 ((0x3021 <= (c)) && ((c) <= 0x3029))))
  |  |  |  |  |  |  ------------------
  |  |  |  |  |  |  |  Branch (188:7): [True: 0, False: 0]
  |  |  |  |  |  |  |  Branch (188:26): [True: 0, False: 0]
  |  |  |  |  |  |  ------------------
  |  |  |  |  ------------------
  |  |  ------------------
  ------------------
  |  Branch (3248:31): [True: 0, False: 0]
  ------------------
 3249|      0|		xmlFatalErrMsgStr(ctxt, XML_NS_ERR_QNAME,
 3250|      0|			    "Name %s is not XML Namespace compliant\n",
 3251|      0|				  name);
 3252|      0|	    }
 3253|      0|	}
 3254|      4|	cur++;
 3255|       |
 3256|     34|	while ((c != 0) && (len < max)) { /* tested bigname2.xml */
  ------------------
  |  Branch (3256:9): [True: 30, False: 4]
  |  Branch (3256:21): [True: 30, False: 0]
  ------------------
 3257|     30|	    buf[len++] = c;
 3258|     30|	    c = *cur++;
 3259|     30|	}
 3260|      4|	if (len >= max) {
  ------------------
  |  Branch (3260:6): [True: 0, False: 4]
  ------------------
 3261|       |	    /*
 3262|       |	     * Okay someone managed to make a huge name, so he's ready to pay
 3263|       |	     * for the processing speed.
 3264|       |	     */
 3265|      0|	    max = len * 2;
 3266|       |
 3267|      0|	    buffer = (xmlChar *) xmlMallocAtomic(max);
 3268|      0|	    if (buffer == NULL) {
  ------------------
  |  Branch (3268:10): [True: 0, False: 0]
  ------------------
 3269|      0|	        xmlErrMemory(ctxt, NULL);
 3270|      0|		return(NULL);
 3271|      0|	    }
 3272|      0|	    memcpy(buffer, buf, len);
 3273|      0|	    while (c != 0) { /* tested bigname2.xml */
  ------------------
  |  Branch (3273:13): [True: 0, False: 0]
  ------------------
 3274|      0|		if (len + 10 > max) {
  ------------------
  |  Branch (3274:7): [True: 0, False: 0]
  ------------------
 3275|      0|		    xmlChar *tmp;
 3276|       |
 3277|      0|		    max *= 2;
 3278|      0|		    tmp = (xmlChar *) xmlRealloc(buffer, max);
 3279|      0|		    if (tmp == NULL) {
  ------------------
  |  Branch (3279:11): [True: 0, False: 0]
  ------------------
 3280|      0|			xmlErrMemory(ctxt, NULL);
 3281|      0|			xmlFree(buffer);
 3282|      0|			return(NULL);
 3283|      0|		    }
 3284|      0|		    buffer = tmp;
 3285|      0|		}
 3286|      0|		buffer[len++] = c;
 3287|      0|		c = *cur++;
 3288|      0|	    }
 3289|      0|	    buffer[len] = 0;
 3290|      0|	}
 3291|       |
 3292|      4|	if (buffer == NULL)
  ------------------
  |  Branch (3292:6): [True: 4, False: 0]
  ------------------
 3293|      4|	    ret = xmlStrndup(buf, len);
 3294|      0|	else {
 3295|      0|	    ret = buffer;
 3296|      0|	}
 3297|      4|    }
 3298|       |
 3299|     17|    return(ret);
 3300|     17|}
xmlParseName:
 3524|    124|xmlParseName(xmlParserCtxtPtr ctxt) {
 3525|    124|    const xmlChar *in;
 3526|    124|    const xmlChar *ret;
 3527|    124|    size_t count = 0;
 3528|    124|    size_t maxLength = (ctxt->options & XML_PARSE_HUGE) ?
  ------------------
  |  Branch (3528:24): [True: 10, False: 114]
  ------------------
 3529|     10|                       XML_MAX_TEXT_LENGTH :
  ------------------
  |  |   42|     10|#define XML_MAX_TEXT_LENGTH 10000000
  ------------------
 3530|    124|                       XML_MAX_NAME_LENGTH;
  ------------------
  |  |   61|    238|#define XML_MAX_NAME_LENGTH 50000
  ------------------
 3531|       |
 3532|    124|    GROW;
  ------------------
  |  | 2270|    124|#define GROW if (ctxt->input->end - ctxt->input->cur < INPUT_CHUNK)	\
  |  |  ------------------
  |  |  |  |   97|    124|#define INPUT_CHUNK	250
  |  |  ------------------
  |  |  |  Branch (2270:18): [True: 105, False: 19]
  |  |  ------------------
  |  | 2271|    124|	xmlParserGrow(ctxt);
  ------------------
 3533|    124|    if (ctxt->instate == XML_PARSER_EOF)
  ------------------
  |  Branch (3533:9): [True: 0, False: 124]
  ------------------
 3534|      0|        return(NULL);
 3535|       |
 3536|       |    /*
 3537|       |     * Accelerator for simple ASCII names
 3538|       |     */
 3539|    124|    in = ctxt->input->cur;
 3540|    124|    if (((*in >= 0x61) && (*in <= 0x7A)) ||
  ------------------
  |  Branch (3540:10): [True: 111, False: 13]
  |  Branch (3540:27): [True: 111, False: 0]
  ------------------
 3541|    124|	((*in >= 0x41) && (*in <= 0x5A)) ||
  ------------------
  |  Branch (3541:3): [True: 0, False: 13]
  |  Branch (3541:20): [True: 0, False: 0]
  ------------------
 3542|    124|	(*in == '_') || (*in == ':')) {
  ------------------
  |  Branch (3542:2): [True: 0, False: 13]
  |  Branch (3542:18): [True: 0, False: 13]
  ------------------
 3543|    111|	in++;
 3544|    468|	while (((*in >= 0x61) && (*in <= 0x7A)) ||
  ------------------
  |  Branch (3544:10): [True: 344, False: 124]
  |  Branch (3544:27): [True: 342, False: 2]
  ------------------
 3545|    468|	       ((*in >= 0x41) && (*in <= 0x5A)) ||
  ------------------
  |  Branch (3545:10): [True: 2, False: 124]
  |  Branch (3545:27): [True: 0, False: 2]
  ------------------
 3546|    468|	       ((*in >= 0x30) && (*in <= 0x39)) ||
  ------------------
  |  Branch (3546:10): [True: 54, False: 72]
  |  Branch (3546:27): [True: 0, False: 54]
  ------------------
 3547|    468|	       (*in == '_') || (*in == '-') ||
  ------------------
  |  Branch (3547:9): [True: 0, False: 126]
  |  Branch (3547:25): [True: 0, False: 126]
  ------------------
 3548|    468|	       (*in == ':') || (*in == '.'))
  ------------------
  |  Branch (3548:9): [True: 15, False: 111]
  |  Branch (3548:25): [True: 0, False: 111]
  ------------------
 3549|    357|	    in++;
 3550|    111|	if ((*in > 0) && (*in < 0x80)) {
  ------------------
  |  Branch (3550:6): [True: 107, False: 4]
  |  Branch (3550:19): [True: 107, False: 0]
  ------------------
 3551|    107|	    count = in - ctxt->input->cur;
 3552|    107|            if (count > maxLength) {
  ------------------
  |  Branch (3552:17): [True: 0, False: 107]
  ------------------
 3553|      0|                xmlFatalErr(ctxt, XML_ERR_NAME_TOO_LONG, "Name");
 3554|      0|                return(NULL);
 3555|      0|            }
 3556|    107|	    ret = xmlDictLookup(ctxt->dict, ctxt->input->cur, count);
 3557|    107|	    ctxt->input->cur = in;
 3558|    107|	    ctxt->input->col += count;
 3559|    107|	    if (ret == NULL)
  ------------------
  |  Branch (3559:10): [True: 0, False: 107]
  ------------------
 3560|      0|	        xmlErrMemory(ctxt, NULL);
 3561|    107|	    return(ret);
 3562|    107|	}
 3563|    111|    }
 3564|       |    /* accelerator for special cases */
 3565|     17|    return(xmlParseNameComplex(ctxt));
 3566|    124|}
xmlParseNmtoken:
 3816|      8|xmlParseNmtoken(xmlParserCtxtPtr ctxt) {
 3817|      8|    xmlChar buf[XML_MAX_NAMELEN + 5];
 3818|      8|    int len = 0, l;
 3819|      8|    int c;
 3820|      8|    int maxLength = (ctxt->options & XML_PARSE_HUGE) ?
  ------------------
  |  Branch (3820:21): [True: 0, False: 8]
  ------------------
 3821|      0|                    XML_MAX_TEXT_LENGTH :
  ------------------
  |  |   42|      0|#define XML_MAX_TEXT_LENGTH 10000000
  ------------------
 3822|      8|                    XML_MAX_NAME_LENGTH;
  ------------------
  |  |   61|      8|#define XML_MAX_NAME_LENGTH 50000
  ------------------
 3823|       |
 3824|      8|    c = CUR_CHAR(l);
  ------------------
  |  | 2291|      8|#define CUR_CHAR(l) xmlCurrentChar(ctxt, &l)
  ------------------
 3825|       |
 3826|     40|    while (xmlIsNameChar(ctxt, c)) {
  ------------------
  |  Branch (3826:12): [True: 32, False: 8]
  ------------------
 3827|     32|	COPY_BUF(buf, len, c);
  ------------------
  |  | 2295|     32|    if (v < 0x80) b[i++] = v;						\
  |  |  ------------------
  |  |  |  Branch (2295:9): [True: 32, False: 0]
  |  |  ------------------
  |  | 2296|     32|    else i += xmlCopyCharMultiByte(&b[i],v)
  ------------------
 3828|     32|	NEXTL(l);
  ------------------
  |  | 2284|     32|#define NEXTL(l) do {							\
  |  | 2285|     32|    if (*(ctxt->input->cur) == '\n') {					\
  |  |  ------------------
  |  |  |  Branch (2285:9): [True: 0, False: 32]
  |  |  ------------------
  |  | 2286|      0|	ctxt->input->line++; ctxt->input->col = 1;			\
  |  | 2287|     32|    } else ctxt->input->col++;						\
  |  | 2288|     32|    ctxt->input->cur += l;				\
  |  | 2289|     32|  } while (0)
  |  |  ------------------
  |  |  |  Branch (2289:12): [Folded - Ignored]
  |  |  ------------------
  ------------------
 3829|     32|	c = CUR_CHAR(l);
  ------------------
  |  | 2291|     32|#define CUR_CHAR(l) xmlCurrentChar(ctxt, &l)
  ------------------
 3830|     32|	if (len >= XML_MAX_NAMELEN) {
  ------------------
  |  |   89|     32|#define XML_MAX_NAMELEN 100
  ------------------
  |  Branch (3830:6): [True: 0, False: 32]
  ------------------
 3831|       |	    /*
 3832|       |	     * Okay someone managed to make a huge token, so he's ready to pay
 3833|       |	     * for the processing speed.
 3834|       |	     */
 3835|      0|	    xmlChar *buffer;
 3836|      0|	    int max = len * 2;
 3837|       |
 3838|      0|	    buffer = (xmlChar *) xmlMallocAtomic(max);
 3839|      0|	    if (buffer == NULL) {
  ------------------
  |  Branch (3839:10): [True: 0, False: 0]
  ------------------
 3840|      0|	        xmlErrMemory(ctxt, NULL);
 3841|      0|		return(NULL);
 3842|      0|	    }
 3843|      0|	    memcpy(buffer, buf, len);
 3844|      0|	    while (xmlIsNameChar(ctxt, c)) {
  ------------------
  |  Branch (3844:13): [True: 0, False: 0]
  ------------------
 3845|      0|		if (len + 10 > max) {
  ------------------
  |  Branch (3845:7): [True: 0, False: 0]
  ------------------
 3846|      0|		    xmlChar *tmp;
 3847|       |
 3848|      0|		    max *= 2;
 3849|      0|		    tmp = (xmlChar *) xmlRealloc(buffer, max);
 3850|      0|		    if (tmp == NULL) {
  ------------------
  |  Branch (3850:11): [True: 0, False: 0]
  ------------------
 3851|      0|			xmlErrMemory(ctxt, NULL);
 3852|      0|			xmlFree(buffer);
 3853|      0|			return(NULL);
 3854|      0|		    }
 3855|      0|		    buffer = tmp;
 3856|      0|		}
 3857|      0|		COPY_BUF(buffer, len, c);
  ------------------
  |  | 2295|      0|    if (v < 0x80) b[i++] = v;						\
  |  |  ------------------
  |  |  |  Branch (2295:9): [True: 0, False: 0]
  |  |  ------------------
  |  | 2296|      0|    else i += xmlCopyCharMultiByte(&b[i],v)
  ------------------
 3858|      0|                if (len > maxLength) {
  ------------------
  |  Branch (3858:21): [True: 0, False: 0]
  ------------------
 3859|      0|                    xmlFatalErr(ctxt, XML_ERR_NAME_TOO_LONG, "NmToken");
 3860|      0|                    xmlFree(buffer);
 3861|      0|                    return(NULL);
 3862|      0|                }
 3863|      0|		NEXTL(l);
  ------------------
  |  | 2284|      0|#define NEXTL(l) do {							\
  |  | 2285|      0|    if (*(ctxt->input->cur) == '\n') {					\
  |  |  ------------------
  |  |  |  Branch (2285:9): [True: 0, False: 0]
  |  |  ------------------
  |  | 2286|      0|	ctxt->input->line++; ctxt->input->col = 1;			\
  |  | 2287|      0|    } else ctxt->input->col++;						\
  |  | 2288|      0|    ctxt->input->cur += l;				\
  |  | 2289|      0|  } while (0)
  |  |  ------------------
  |  |  |  Branch (2289:12): [Folded - Ignored]
  |  |  ------------------
  ------------------
 3864|      0|		c = CUR_CHAR(l);
  ------------------
  |  | 2291|      0|#define CUR_CHAR(l) xmlCurrentChar(ctxt, &l)
  ------------------
 3865|      0|	    }
 3866|      0|	    buffer[len] = 0;
 3867|      0|            if (ctxt->instate == XML_PARSER_EOF) {
  ------------------
  |  Branch (3867:17): [True: 0, False: 0]
  ------------------
 3868|      0|                xmlFree(buffer);
 3869|      0|                return(NULL);
 3870|      0|            }
 3871|      0|	    return(buffer);
 3872|      0|	}
 3873|     32|    }
 3874|      8|    if (ctxt->instate == XML_PARSER_EOF)
  ------------------
  |  Branch (3874:9): [True: 0, False: 8]
  ------------------
 3875|      0|        return(NULL);
 3876|      8|    if (len == 0)
  ------------------
  |  Branch (3876:9): [True: 4, False: 4]
  ------------------
 3877|      4|        return(NULL);
 3878|      4|    if (len > maxLength) {
  ------------------
  |  Branch (3878:9): [True: 0, False: 4]
  ------------------
 3879|      0|        xmlFatalErr(ctxt, XML_ERR_NAME_TOO_LONG, "NmToken");
 3880|      0|        return(NULL);
 3881|      0|    }
 3882|      4|    return(xmlStrndup(buf, len));
 3883|      4|}
xmlParseAttValue:
 4337|      4|xmlParseAttValue(xmlParserCtxtPtr ctxt) {
 4338|      4|    if ((ctxt == NULL) || (ctxt->input == NULL)) return(NULL);
  ------------------
  |  Branch (4338:9): [True: 0, False: 4]
  |  Branch (4338:27): [True: 0, False: 4]
  ------------------
 4339|      4|    return(xmlParseAttValueInternal(ctxt, NULL, NULL, 0));
 4340|      4|}
xmlParseExternalID:
 4835|      8|xmlParseExternalID(xmlParserCtxtPtr ctxt, xmlChar **publicID, int strict) {
 4836|      8|    xmlChar *URI = NULL;
 4837|       |
 4838|      8|    *publicID = NULL;
 4839|      8|    if (CMP6(CUR_PTR, 'S', 'Y', 'S', 'T', 'E', 'M')) {
  ------------------
  |  | 2233|      8|  ( CMP5( s, c1, c2, c3, c4, c5 ) && ((unsigned char *) s)[ 5 ] == c6 )
  |  |  ------------------
  |  |  |  | 2231|     16|  ( CMP4( s, c1, c2, c3, c4 ) && ((unsigned char *) s)[ 4 ] == c5 )
  |  |  |  |  ------------------
  |  |  |  |  |  | 2228|     16|  ( ((unsigned char *) s)[ 0 ] == c1 && ((unsigned char *) s)[ 1 ] == c2 && \
  |  |  |  |  |  |  ------------------
  |  |  |  |  |  |  |  Branch (2228:5): [True: 0, False: 8]
  |  |  |  |  |  |  |  Branch (2228:41): [True: 0, False: 0]
  |  |  |  |  |  |  ------------------
  |  |  |  |  |  | 2229|      8|    ((unsigned char *) s)[ 2 ] == c3 && ((unsigned char *) s)[ 3 ] == c4 )
  |  |  |  |  |  |  ------------------
  |  |  |  |  |  |  |  Branch (2229:5): [True: 0, False: 0]
  |  |  |  |  |  |  |  Branch (2229:41): [True: 0, False: 0]
  |  |  |  |  |  |  ------------------
  |  |  |  |  ------------------
  |  |  |  |  |  Branch (2231:34): [True: 0, False: 0]
  |  |  |  |  ------------------
  |  |  ------------------
  |  |  |  Branch (2233:38): [True: 0, False: 0]
  |  |  ------------------
  ------------------
 4840|      0|        SKIP(6);
  ------------------
  |  | 2245|      0|#define SKIP(val) do {							\
  |  | 2246|      0|    ctxt->input->cur += (val),ctxt->input->col+=(val);			\
  |  | 2247|      0|    if (*ctxt->input->cur == 0)						\
  |  |  ------------------
  |  |  |  Branch (2247:9): [True: 0, False: 0]
  |  |  ------------------
  |  | 2248|      0|        xmlParserGrow(ctxt);						\
  |  | 2249|      0|  } while (0)
  |  |  ------------------
  |  |  |  Branch (2249:12): [Folded - Ignored]
  |  |  ------------------
  ------------------
 4841|      0|	if (SKIP_BLANKS == 0) {
  ------------------
  |  | 2273|      0|#define SKIP_BLANKS xmlSkipBlankChars(ctxt)
  ------------------
  |  Branch (4841:6): [True: 0, False: 0]
  ------------------
 4842|      0|	    xmlFatalErrMsg(ctxt, XML_ERR_SPACE_REQUIRED,
 4843|      0|	                   "Space required after 'SYSTEM'\n");
 4844|      0|	}
 4845|      0|	URI = xmlParseSystemLiteral(ctxt);
 4846|      0|	if (URI == NULL) {
  ------------------
  |  Branch (4846:6): [True: 0, False: 0]
  ------------------
 4847|      0|	    xmlFatalErr(ctxt, XML_ERR_URI_REQUIRED, NULL);
 4848|      0|        }
 4849|      8|    } else if (CMP6(CUR_PTR, 'P', 'U', 'B', 'L', 'I', 'C')) {
  ------------------
  |  | 2233|      8|  ( CMP5( s, c1, c2, c3, c4, c5 ) && ((unsigned char *) s)[ 5 ] == c6 )
  |  |  ------------------
  |  |  |  | 2231|     16|  ( CMP4( s, c1, c2, c3, c4 ) && ((unsigned char *) s)[ 4 ] == c5 )
  |  |  |  |  ------------------
  |  |  |  |  |  | 2228|     16|  ( ((unsigned char *) s)[ 0 ] == c1 && ((unsigned char *) s)[ 1 ] == c2 && \
  |  |  |  |  |  |  ------------------
  |  |  |  |  |  |  |  Branch (2228:5): [True: 0, False: 8]
  |  |  |  |  |  |  |  Branch (2228:41): [True: 0, False: 0]
  |  |  |  |  |  |  ------------------
  |  |  |  |  |  | 2229|      8|    ((unsigned char *) s)[ 2 ] == c3 && ((unsigned char *) s)[ 3 ] == c4 )
  |  |  |  |  |  |  ------------------
  |  |  |  |  |  |  |  Branch (2229:5): [True: 0, False: 0]
  |  |  |  |  |  |  |  Branch (2229:41): [True: 0, False: 0]
  |  |  |  |  |  |  ------------------
  |  |  |  |  ------------------
  |  |  |  |  |  Branch (2231:34): [True: 0, False: 0]
  |  |  |  |  ------------------
  |  |  ------------------
  |  |  |  Branch (2233:38): [True: 0, False: 0]
  |  |  ------------------
  ------------------
 4850|      0|        SKIP(6);
  ------------------
  |  | 2245|      0|#define SKIP(val) do {							\
  |  | 2246|      0|    ctxt->input->cur += (val),ctxt->input->col+=(val);			\
  |  | 2247|      0|    if (*ctxt->input->cur == 0)						\
  |  |  ------------------
  |  |  |  Branch (2247:9): [True: 0, False: 0]
  |  |  ------------------
  |  | 2248|      0|        xmlParserGrow(ctxt);						\
  |  | 2249|      0|  } while (0)
  |  |  ------------------
  |  |  |  Branch (2249:12): [Folded - Ignored]
  |  |  ------------------
  ------------------
 4851|      0|	if (SKIP_BLANKS == 0) {
  ------------------
  |  | 2273|      0|#define SKIP_BLANKS xmlSkipBlankChars(ctxt)
  ------------------
  |  Branch (4851:6): [True: 0, False: 0]
  ------------------
 4852|      0|	    xmlFatalErrMsg(ctxt, XML_ERR_SPACE_REQUIRED,
 4853|      0|		    "Space required after 'PUBLIC'\n");
 4854|      0|	}
 4855|      0|	*publicID = xmlParsePubidLiteral(ctxt);
 4856|      0|	if (*publicID == NULL) {
  ------------------
  |  Branch (4856:6): [True: 0, False: 0]
  ------------------
 4857|      0|	    xmlFatalErr(ctxt, XML_ERR_PUBID_REQUIRED, NULL);
 4858|      0|	}
 4859|      0|	if (strict) {
  ------------------
  |  Branch (4859:6): [True: 0, False: 0]
  ------------------
 4860|       |	    /*
 4861|       |	     * We don't handle [83] so "S SystemLiteral" is required.
 4862|       |	     */
 4863|      0|	    if (SKIP_BLANKS == 0) {
  ------------------
  |  | 2273|      0|#define SKIP_BLANKS xmlSkipBlankChars(ctxt)
  ------------------
  |  Branch (4863:10): [True: 0, False: 0]
  ------------------
 4864|      0|		xmlFatalErrMsg(ctxt, XML_ERR_SPACE_REQUIRED,
 4865|      0|			"Space required after the Public Identifier\n");
 4866|      0|	    }
 4867|      0|	} else {
 4868|       |	    /*
 4869|       |	     * We handle [83] so we return immediately, if
 4870|       |	     * "S SystemLiteral" is not detected. We skip blanks if no
 4871|       |             * system literal was found, but this is harmless since we must
 4872|       |             * be at the end of a NotationDecl.
 4873|       |	     */
 4874|      0|	    if (SKIP_BLANKS == 0) return(NULL);
  ------------------
  |  | 2273|      0|#define SKIP_BLANKS xmlSkipBlankChars(ctxt)
  ------------------
  |  Branch (4874:10): [True: 0, False: 0]
  ------------------
 4875|      0|	    if ((CUR != '\'') && (CUR != '"')) return(NULL);
  ------------------
  |  | 2222|      0|#define CUR (*ctxt->input->cur)
  ------------------
              	    if ((CUR != '\'') && (CUR != '"')) return(NULL);
  ------------------
  |  | 2222|      0|#define CUR (*ctxt->input->cur)
  ------------------
  |  Branch (4875:10): [True: 0, False: 0]
  |  Branch (4875:27): [True: 0, False: 0]
  ------------------
 4876|      0|	}
 4877|      0|	URI = xmlParseSystemLiteral(ctxt);
 4878|      0|	if (URI == NULL) {
  ------------------
  |  Branch (4878:6): [True: 0, False: 0]
  ------------------
 4879|      0|	    xmlFatalErr(ctxt, XML_ERR_URI_REQUIRED, NULL);
 4880|      0|        }
 4881|      0|    }
 4882|      8|    return(URI);
 4883|      8|}
xmlParseComment:
 5029|     59|xmlParseComment(xmlParserCtxtPtr ctxt) {
 5030|     59|    xmlChar *buf = NULL;
 5031|     59|    size_t size = XML_PARSER_BUFFER_SIZE;
  ------------------
  |  |  167|     59|#define XML_PARSER_BUFFER_SIZE 100
  ------------------
 5032|     59|    size_t len = 0;
 5033|     59|    size_t maxLength = (ctxt->options & XML_PARSE_HUGE) ?
  ------------------
  |  Branch (5033:24): [True: 2, False: 57]
  ------------------
 5034|      2|                       XML_MAX_HUGE_LENGTH :
  ------------------
  |  |   49|      2|#define XML_MAX_HUGE_LENGTH 1000000000
  ------------------
 5035|     59|                       XML_MAX_TEXT_LENGTH;
  ------------------
  |  |   42|    116|#define XML_MAX_TEXT_LENGTH 10000000
  ------------------
 5036|     59|    xmlParserInputState state;
 5037|     59|    const xmlChar *in;
 5038|     59|    size_t nbchar = 0;
 5039|     59|    int ccol;
 5040|     59|    int inputid;
 5041|       |
 5042|       |    /*
 5043|       |     * Check that there is a comment right here.
 5044|       |     */
 5045|     59|    if ((RAW != '<') || (NXT(1) != '!'))
  ------------------
  |  | 2221|     59|#define RAW (*ctxt->input->cur)
  ------------------
                  if ((RAW != '<') || (NXT(1) != '!'))
  ------------------
  |  | 2223|     59|#define NXT(val) ctxt->input->cur[(val)]
  ------------------
  |  Branch (5045:9): [True: 0, False: 59]
  |  Branch (5045:25): [True: 0, False: 59]
  ------------------
 5046|      0|        return;
 5047|     59|    SKIP(2);
  ------------------
  |  | 2245|     59|#define SKIP(val) do {							\
  |  | 2246|     59|    ctxt->input->cur += (val),ctxt->input->col+=(val);			\
  |  | 2247|     59|    if (*ctxt->input->cur == 0)						\
  |  |  ------------------
  |  |  |  Branch (2247:9): [True: 0, False: 59]
  |  |  ------------------
  |  | 2248|     59|        xmlParserGrow(ctxt);						\
  |  | 2249|     59|  } while (0)
  |  |  ------------------
  |  |  |  Branch (2249:12): [Folded - Ignored]
  |  |  ------------------
  ------------------
 5048|     59|    if ((RAW != '-') || (NXT(1) != '-'))
  ------------------
  |  | 2221|     59|#define RAW (*ctxt->input->cur)
  ------------------
                  if ((RAW != '-') || (NXT(1) != '-'))
  ------------------
  |  | 2223|     59|#define NXT(val) ctxt->input->cur[(val)]
  ------------------
  |  Branch (5048:9): [True: 0, False: 59]
  |  Branch (5048:25): [True: 0, False: 59]
  ------------------
 5049|      0|        return;
 5050|     59|    state = ctxt->instate;
 5051|     59|    ctxt->instate = XML_PARSER_COMMENT;
 5052|     59|    inputid = ctxt->input->id;
 5053|     59|    SKIP(2);
  ------------------
  |  | 2245|     59|#define SKIP(val) do {							\
  |  | 2246|     59|    ctxt->input->cur += (val),ctxt->input->col+=(val);			\
  |  | 2247|     59|    if (*ctxt->input->cur == 0)						\
  |  |  ------------------
  |  |  |  Branch (2247:9): [True: 0, False: 59]
  |  |  ------------------
  |  | 2248|     59|        xmlParserGrow(ctxt);						\
  |  | 2249|     59|  } while (0)
  |  |  ------------------
  |  |  |  Branch (2249:12): [Folded - Ignored]
  |  |  ------------------
  ------------------
 5054|     59|    GROW;
  ------------------
  |  | 2270|     59|#define GROW if (ctxt->input->end - ctxt->input->cur < INPUT_CHUNK)	\
  |  |  ------------------
  |  |  |  |   97|     59|#define INPUT_CHUNK	250
  |  |  ------------------
  |  |  |  Branch (2270:18): [True: 55, False: 4]
  |  |  ------------------
  |  | 2271|     59|	xmlParserGrow(ctxt);
  ------------------
 5055|       |
 5056|       |    /*
 5057|       |     * Accelerated common case where input don't need to be
 5058|       |     * modified before passing it to the handler.
 5059|       |     */
 5060|     59|    in = ctxt->input->cur;
 5061|     59|    do {
 5062|     59|	if (*in == 0xA) {
  ------------------
  |  Branch (5062:6): [True: 0, False: 59]
  ------------------
 5063|      0|	    do {
 5064|      0|		ctxt->input->line++; ctxt->input->col = 1;
 5065|      0|		in++;
 5066|      0|	    } while (*in == 0xA);
  ------------------
  |  Branch (5066:15): [True: 0, False: 0]
  ------------------
 5067|      0|	}
 5068|     85|get_more:
 5069|     85|        ccol = ctxt->input->col;
 5070|  2.84k|	while (((*in > '-') && (*in <= 0x7F)) ||
  ------------------
  |  Branch (5070:10): [True: 2.27k, False: 570]
  |  Branch (5070:25): [True: 2.26k, False: 8]
  ------------------
 5071|  2.84k|	       ((*in >= 0x20) && (*in < '-')) ||
  ------------------
  |  Branch (5071:10): [True: 540, False: 38]
  |  Branch (5071:27): [True: 493, False: 47]
  ------------------
 5072|  2.84k|	       (*in == 0x09)) {
  ------------------
  |  Branch (5072:9): [True: 0, False: 85]
  ------------------
 5073|  2.75k|		    in++;
 5074|  2.75k|		    ccol++;
 5075|  2.75k|	}
 5076|     85|	ctxt->input->col = ccol;
 5077|     85|	if (*in == 0xA) {
  ------------------
  |  Branch (5077:6): [True: 26, False: 59]
  ------------------
 5078|     26|	    do {
 5079|     26|		ctxt->input->line++; ctxt->input->col = 1;
 5080|     26|		in++;
 5081|     26|	    } while (*in == 0xA);
  ------------------
  |  Branch (5081:15): [True: 0, False: 26]
  ------------------
 5082|     26|	    goto get_more;
 5083|     26|	}
 5084|     59|	nbchar = in - ctxt->input->cur;
 5085|       |	/*
 5086|       |	 * save current set of data
 5087|       |	 */
 5088|     59|	if (nbchar > 0) {
  ------------------
  |  Branch (5088:6): [True: 59, False: 0]
  ------------------
 5089|     59|            if (buf == NULL) {
  ------------------
  |  Branch (5089:17): [True: 59, False: 0]
  ------------------
 5090|     59|                if ((*in == '-') && (in[1] == '-'))
  ------------------
  |  Branch (5090:21): [True: 39, False: 20]
  |  Branch (5090:37): [True: 39, False: 0]
  ------------------
 5091|     39|                    size = nbchar + 1;
 5092|     20|                else
 5093|     20|                    size = XML_PARSER_BUFFER_SIZE + nbchar;
  ------------------
  |  |  167|     20|#define XML_PARSER_BUFFER_SIZE 100
  ------------------
 5094|     59|                buf = (xmlChar *) xmlMallocAtomic(size);
 5095|     59|                if (buf == NULL) {
  ------------------
  |  Branch (5095:21): [True: 0, False: 59]
  ------------------
 5096|      0|                    xmlErrMemory(ctxt, NULL);
 5097|      0|                    ctxt->instate = state;
 5098|      0|                    return;
 5099|      0|                }
 5100|     59|                len = 0;
 5101|     59|            } else if (len + nbchar + 1 >= size) {
  ------------------
  |  Branch (5101:24): [True: 0, False: 0]
  ------------------
 5102|      0|                xmlChar *new_buf;
 5103|      0|                size  += len + nbchar + XML_PARSER_BUFFER_SIZE;
  ------------------
  |  |  167|      0|#define XML_PARSER_BUFFER_SIZE 100
  ------------------
 5104|      0|                new_buf = (xmlChar *) xmlRealloc(buf, size);
 5105|      0|                if (new_buf == NULL) {
  ------------------
  |  Branch (5105:21): [True: 0, False: 0]
  ------------------
 5106|      0|                    xmlFree (buf);
 5107|      0|                    xmlErrMemory(ctxt, NULL);
 5108|      0|                    ctxt->instate = state;
 5109|      0|                    return;
 5110|      0|                }
 5111|      0|                buf = new_buf;
 5112|      0|            }
 5113|     59|            memcpy(&buf[len], ctxt->input->cur, nbchar);
 5114|     59|            len += nbchar;
 5115|     59|            buf[len] = 0;
 5116|     59|	}
 5117|     59|        if (len > maxLength) {
  ------------------
  |  Branch (5117:13): [True: 0, False: 59]
  ------------------
 5118|      0|            xmlFatalErrMsgStr(ctxt, XML_ERR_COMMENT_NOT_FINISHED,
 5119|      0|                         "Comment too big found", NULL);
 5120|      0|            xmlFree (buf);
 5121|      0|            return;
 5122|      0|        }
 5123|     59|	ctxt->input->cur = in;
 5124|     59|	if (*in == 0xA) {
  ------------------
  |  Branch (5124:6): [True: 0, False: 59]
  ------------------
 5125|      0|	    in++;
 5126|      0|	    ctxt->input->line++; ctxt->input->col = 1;
 5127|      0|	}
 5128|     59|	if (*in == 0xD) {
  ------------------
  |  Branch (5128:6): [True: 0, False: 59]
  ------------------
 5129|      0|	    in++;
 5130|      0|	    if (*in == 0xA) {
  ------------------
  |  Branch (5130:10): [True: 0, False: 0]
  ------------------
 5131|      0|		ctxt->input->cur = in;
 5132|      0|		in++;
 5133|      0|		ctxt->input->line++; ctxt->input->col = 1;
 5134|      0|		goto get_more;
 5135|      0|	    }
 5136|      0|	    in--;
 5137|      0|	}
 5138|     59|	SHRINK;
  ------------------
  |  | 2265|     59|    if (((ctxt->progressive == 0) || (ctxt->inputNr > 1)) && \
  |  |  ------------------
  |  |  |  Branch (2265:10): [True: 32, False: 27]
  |  |  |  Branch (2265:38): [True: 0, False: 27]
  |  |  ------------------
  |  | 2266|     59|        (ctxt->input->cur - ctxt->input->base > 2 * INPUT_CHUNK) && \
  |  |  ------------------
  |  |  |  |   97|     32|#define INPUT_CHUNK	250
  |  |  ------------------
  |  |  |  Branch (2266:9): [True: 0, False: 32]
  |  |  ------------------
  |  | 2267|     59|	(ctxt->input->end - ctxt->input->cur < 2 * INPUT_CHUNK)) \
  |  |  ------------------
  |  |  |  |   97|      0|#define INPUT_CHUNK	250
  |  |  ------------------
  |  |  |  Branch (2267:2): [True: 0, False: 0]
  |  |  ------------------
  |  | 2268|     59|	xmlParserShrink(ctxt);
  ------------------
 5139|     59|	GROW;
  ------------------
  |  | 2270|     59|#define GROW if (ctxt->input->end - ctxt->input->cur < INPUT_CHUNK)	\
  |  |  ------------------
  |  |  |  |   97|     59|#define INPUT_CHUNK	250
  |  |  ------------------
  |  |  |  Branch (2270:18): [True: 55, False: 4]
  |  |  ------------------
  |  | 2271|     59|	xmlParserGrow(ctxt);
  ------------------
 5140|     59|        if (ctxt->instate == XML_PARSER_EOF) {
  ------------------
  |  Branch (5140:13): [True: 0, False: 59]
  ------------------
 5141|      0|            xmlFree(buf);
 5142|      0|            return;
 5143|      0|        }
 5144|     59|	in = ctxt->input->cur;
 5145|     59|	if (*in == '-') {
  ------------------
  |  Branch (5145:6): [True: 39, False: 20]
  ------------------
 5146|     39|	    if (in[1] == '-') {
  ------------------
  |  Branch (5146:10): [True: 39, False: 0]
  ------------------
 5147|     39|	        if (in[2] == '>') {
  ------------------
  |  Branch (5147:14): [True: 39, False: 0]
  ------------------
 5148|     39|		    if (ctxt->input->id != inputid) {
  ------------------
  |  Branch (5148:11): [True: 0, False: 39]
  ------------------
 5149|      0|			xmlFatalErrMsg(ctxt, XML_ERR_ENTITY_BOUNDARY,
 5150|      0|			               "comment doesn't start and stop in the"
 5151|      0|                                       " same entity\n");
 5152|      0|		    }
 5153|     39|		    SKIP(3);
  ------------------
  |  | 2245|     39|#define SKIP(val) do {							\
  |  | 2246|     39|    ctxt->input->cur += (val),ctxt->input->col+=(val);			\
  |  | 2247|     39|    if (*ctxt->input->cur == 0)						\
  |  |  ------------------
  |  |  |  Branch (2247:9): [True: 0, False: 39]
  |  |  ------------------
  |  | 2248|     39|        xmlParserGrow(ctxt);						\
  |  | 2249|     39|  } while (0)
  |  |  ------------------
  |  |  |  Branch (2249:12): [Folded - Ignored]
  |  |  ------------------
  ------------------
 5154|     39|		    if ((ctxt->sax != NULL) && (ctxt->sax->comment != NULL) &&
  ------------------
  |  Branch (5154:11): [True: 39, False: 0]
  |  Branch (5154:34): [True: 39, False: 0]
  ------------------
 5155|     39|		        (!ctxt->disableSAX)) {
  ------------------
  |  Branch (5155:11): [True: 34, False: 5]
  ------------------
 5156|     34|			if (buf != NULL)
  ------------------
  |  Branch (5156:8): [True: 34, False: 0]
  ------------------
 5157|     34|			    ctxt->sax->comment(ctxt->userData, buf);
 5158|      0|			else
 5159|      0|			    ctxt->sax->comment(ctxt->userData, BAD_CAST "");
  ------------------
  |  |   35|      0|#define BAD_CAST (xmlChar *)
  ------------------
 5160|     34|		    }
 5161|     39|		    if (buf != NULL)
  ------------------
  |  Branch (5161:11): [True: 39, False: 0]
  ------------------
 5162|     39|		        xmlFree(buf);
 5163|     39|		    if (ctxt->instate != XML_PARSER_EOF)
  ------------------
  |  Branch (5163:11): [True: 39, False: 0]
  ------------------
 5164|     39|			ctxt->instate = state;
 5165|     39|		    return;
 5166|     39|		}
 5167|      0|		if (buf != NULL) {
  ------------------
  |  Branch (5167:7): [True: 0, False: 0]
  ------------------
 5168|      0|		    xmlFatalErrMsgStr(ctxt, XML_ERR_HYPHEN_IN_COMMENT,
 5169|      0|		                      "Double hyphen within comment: "
 5170|      0|                                      "<!--%.50s\n",
 5171|      0|				      buf);
 5172|      0|		} else
 5173|      0|		    xmlFatalErrMsgStr(ctxt, XML_ERR_HYPHEN_IN_COMMENT,
 5174|      0|		                      "Double hyphen within comment\n", NULL);
 5175|      0|                if (ctxt->instate == XML_PARSER_EOF) {
  ------------------
  |  Branch (5175:21): [True: 0, False: 0]
  ------------------
 5176|      0|                    xmlFree(buf);
 5177|      0|                    return;
 5178|      0|                }
 5179|      0|		in++;
 5180|      0|		ctxt->input->col++;
 5181|      0|	    }
 5182|      0|	    in++;
 5183|      0|	    ctxt->input->col++;
 5184|      0|	    goto get_more;
 5185|     39|	}
 5186|     59|    } while (((*in >= 0x20) && (*in <= 0x7F)) || (*in == 0x09) || (*in == 0x0a));
  ------------------
  |  Branch (5186:15): [True: 8, False: 12]
  |  Branch (5186:32): [True: 0, False: 8]
  |  Branch (5186:50): [True: 0, False: 20]
  |  Branch (5186:67): [True: 0, False: 20]
  ------------------
 5187|     20|    xmlParseCommentComplex(ctxt, buf, len, size);
 5188|     20|    ctxt->instate = state;
 5189|     20|    return;
 5190|     59|}
xmlParsePITarget:
 5207|      3|xmlParsePITarget(xmlParserCtxtPtr ctxt) {
 5208|      3|    const xmlChar *name;
 5209|       |
 5210|      3|    name = xmlParseName(ctxt);
 5211|      3|    if ((name != NULL) &&
  ------------------
  |  Branch (5211:9): [True: 3, False: 0]
  ------------------
 5212|      3|        ((name[0] == 'x') || (name[0] == 'X')) &&
  ------------------
  |  Branch (5212:10): [True: 3, False: 0]
  |  Branch (5212:30): [True: 0, False: 0]
  ------------------
 5213|      3|        ((name[1] == 'm') || (name[1] == 'M')) &&
  ------------------
  |  Branch (5213:10): [True: 1, False: 2]
  |  Branch (5213:30): [True: 0, False: 2]
  ------------------
 5214|      3|        ((name[2] == 'l') || (name[2] == 'L'))) {
  ------------------
  |  Branch (5214:10): [True: 1, False: 0]
  |  Branch (5214:30): [True: 0, False: 0]
  ------------------
 5215|      1|	int i;
 5216|      1|	if ((name[0] == 'x') && (name[1] == 'm') &&
  ------------------
  |  Branch (5216:6): [True: 1, False: 0]
  |  Branch (5216:26): [True: 1, False: 0]
  ------------------
 5217|      1|	    (name[2] == 'l') && (name[3] == 0)) {
  ------------------
  |  Branch (5217:6): [True: 1, False: 0]
  |  Branch (5217:26): [True: 1, False: 0]
  ------------------
 5218|      1|	    xmlFatalErrMsg(ctxt, XML_ERR_RESERVED_XML_NAME,
 5219|      1|		 "XML declaration allowed only at the start of the document\n");
 5220|      1|	    return(name);
 5221|      1|	} else if (name[3] == 0) {
  ------------------
  |  Branch (5221:13): [True: 0, False: 0]
  ------------------
 5222|      0|	    xmlFatalErr(ctxt, XML_ERR_RESERVED_XML_NAME, NULL);
 5223|      0|	    return(name);
 5224|      0|	}
 5225|      0|	for (i = 0;;i++) {
 5226|      0|	    if (xmlW3CPIs[i] == NULL) break;
  ------------------
  |  Branch (5226:10): [True: 0, False: 0]
  ------------------
 5227|      0|	    if (xmlStrEqual(name, (const xmlChar *)xmlW3CPIs[i]))
  ------------------
  |  Branch (5227:10): [True: 0, False: 0]
  ------------------
 5228|      0|	        return(name);
 5229|      0|	}
 5230|      0|	xmlWarningMsg(ctxt, XML_ERR_RESERVED_XML_NAME,
 5231|      0|		      "xmlParsePITarget: invalid name prefix 'xml'\n",
 5232|      0|		      NULL, NULL);
 5233|      0|    }
 5234|      2|    if ((name != NULL) && (xmlStrchr(name, ':') != NULL)) {
  ------------------
  |  Branch (5234:9): [True: 2, False: 0]
  |  Branch (5234:27): [True: 0, False: 2]
  ------------------
 5235|      0|	xmlNsErr(ctxt, XML_NS_ERR_COLON,
 5236|      0|		 "colons are forbidden from PI names '%s'\n", name, NULL, NULL);
 5237|      0|    }
 5238|      2|    return(name);
 5239|      3|}
xmlParsePI:
 5317|      3|xmlParsePI(xmlParserCtxtPtr ctxt) {
 5318|      3|    xmlChar *buf = NULL;
 5319|      3|    size_t len = 0;
 5320|      3|    size_t size = XML_PARSER_BUFFER_SIZE;
  ------------------
  |  |  167|      3|#define XML_PARSER_BUFFER_SIZE 100
  ------------------
 5321|      3|    size_t maxLength = (ctxt->options & XML_PARSE_HUGE) ?
  ------------------
  |  Branch (5321:24): [True: 0, False: 3]
  ------------------
 5322|      0|                       XML_MAX_HUGE_LENGTH :
  ------------------
  |  |   49|      0|#define XML_MAX_HUGE_LENGTH 1000000000
  ------------------
 5323|      3|                       XML_MAX_TEXT_LENGTH;
  ------------------
  |  |   42|      6|#define XML_MAX_TEXT_LENGTH 10000000
  ------------------
 5324|      3|    int cur, l;
 5325|      3|    const xmlChar *target;
 5326|      3|    xmlParserInputState state;
 5327|       |
 5328|      3|    if ((RAW == '<') && (NXT(1) == '?')) {
  ------------------
  |  | 2221|      3|#define RAW (*ctxt->input->cur)
  ------------------
                  if ((RAW == '<') && (NXT(1) == '?')) {
  ------------------
  |  | 2223|      3|#define NXT(val) ctxt->input->cur[(val)]
  ------------------
  |  Branch (5328:9): [True: 3, False: 0]
  |  Branch (5328:25): [True: 3, False: 0]
  ------------------
 5329|      3|	int inputid = ctxt->input->id;
 5330|      3|	state = ctxt->instate;
 5331|      3|        ctxt->instate = XML_PARSER_PI;
 5332|       |	/*
 5333|       |	 * this is a Processing Instruction.
 5334|       |	 */
 5335|      3|	SKIP(2);
  ------------------
  |  | 2245|      3|#define SKIP(val) do {							\
  |  | 2246|      3|    ctxt->input->cur += (val),ctxt->input->col+=(val);			\
  |  | 2247|      3|    if (*ctxt->input->cur == 0)						\
  |  |  ------------------
  |  |  |  Branch (2247:9): [True: 0, False: 3]
  |  |  ------------------
  |  | 2248|      3|        xmlParserGrow(ctxt);						\
  |  | 2249|      3|  } while (0)
  |  |  ------------------
  |  |  |  Branch (2249:12): [Folded - Ignored]
  |  |  ------------------
  ------------------
 5336|       |
 5337|       |	/*
 5338|       |	 * Parse the target name and check for special support like
 5339|       |	 * namespace.
 5340|       |	 */
 5341|      3|        target = xmlParsePITarget(ctxt);
 5342|      3|	if (target != NULL) {
  ------------------
  |  Branch (5342:6): [True: 3, False: 0]
  ------------------
 5343|      3|	    if ((RAW == '?') && (NXT(1) == '>')) {
  ------------------
  |  | 2221|      3|#define RAW (*ctxt->input->cur)
  ------------------
              	    if ((RAW == '?') && (NXT(1) == '>')) {
  ------------------
  |  | 2223|      0|#define NXT(val) ctxt->input->cur[(val)]
  ------------------
  |  Branch (5343:10): [True: 0, False: 3]
  |  Branch (5343:26): [True: 0, False: 0]
  ------------------
 5344|      0|		if (inputid != ctxt->input->id) {
  ------------------
  |  Branch (5344:7): [True: 0, False: 0]
  ------------------
 5345|      0|		    xmlFatalErrMsg(ctxt, XML_ERR_ENTITY_BOUNDARY,
 5346|      0|	                           "PI declaration doesn't start and stop in"
 5347|      0|                                   " the same entity\n");
 5348|      0|		}
 5349|      0|		SKIP(2);
  ------------------
  |  | 2245|      0|#define SKIP(val) do {							\
  |  | 2246|      0|    ctxt->input->cur += (val),ctxt->input->col+=(val);			\
  |  | 2247|      0|    if (*ctxt->input->cur == 0)						\
  |  |  ------------------
  |  |  |  Branch (2247:9): [True: 0, False: 0]
  |  |  ------------------
  |  | 2248|      0|        xmlParserGrow(ctxt);						\
  |  | 2249|      0|  } while (0)
  |  |  ------------------
  |  |  |  Branch (2249:12): [Folded - Ignored]
  |  |  ------------------
  ------------------
 5350|       |
 5351|       |		/*
 5352|       |		 * SAX: PI detected.
 5353|       |		 */
 5354|      0|		if ((ctxt->sax) && (!ctxt->disableSAX) &&
  ------------------
  |  Branch (5354:7): [True: 0, False: 0]
  |  Branch (5354:22): [True: 0, False: 0]
  ------------------
 5355|      0|		    (ctxt->sax->processingInstruction != NULL))
  ------------------
  |  Branch (5355:7): [True: 0, False: 0]
  ------------------
 5356|      0|		    ctxt->sax->processingInstruction(ctxt->userData,
 5357|      0|		                                     target, NULL);
 5358|      0|		if (ctxt->instate != XML_PARSER_EOF)
  ------------------
  |  Branch (5358:7): [True: 0, False: 0]
  ------------------
 5359|      0|		    ctxt->instate = state;
 5360|      0|		return;
 5361|      0|	    }
 5362|      3|	    buf = (xmlChar *) xmlMallocAtomic(size);
 5363|      3|	    if (buf == NULL) {
  ------------------
  |  Branch (5363:10): [True: 0, False: 3]
  ------------------
 5364|      0|		xmlErrMemory(ctxt, NULL);
 5365|      0|		ctxt->instate = state;
 5366|      0|		return;
 5367|      0|	    }
 5368|      3|	    if (SKIP_BLANKS == 0) {
  ------------------
  |  | 2273|      3|#define SKIP_BLANKS xmlSkipBlankChars(ctxt)
  ------------------
  |  Branch (5368:10): [True: 0, False: 3]
  ------------------
 5369|      0|		xmlFatalErrMsgStr(ctxt, XML_ERR_SPACE_REQUIRED,
 5370|      0|			  "ParsePI: PI %s space expected\n", target);
 5371|      0|	    }
 5372|      3|	    cur = CUR_CHAR(l);
  ------------------
  |  | 2291|      3|#define CUR_CHAR(l) xmlCurrentChar(ctxt, &l)
  ------------------
 5373|     86|	    while (IS_CHAR(cur) && /* checked */
  ------------------
  |  |  125|     86|#define IS_CHAR(c)   xmlIsCharQ(c)
  |  |  ------------------
  |  |  |  |  118|    172|#define xmlIsCharQ(c)		(((c) < 0x100) ? \
  |  |  |  |  ------------------
  |  |  |  |  |  Branch (118:24): [True: 86, False: 0]
  |  |  |  |  |  Branch (118:25): [True: 86, False: 0]
  |  |  |  |  ------------------
  |  |  |  |  119|    172|				 xmlIsChar_ch((c)) :\
  |  |  |  |  ------------------
  |  |  |  |  |  |  108|     86|#define xmlIsChar_ch(c)		(((0x9 <= (c)) && ((c) <= 0xa)) || \
  |  |  |  |  |  |  ------------------
  |  |  |  |  |  |  |  Branch (108:28): [True: 86, False: 0]
  |  |  |  |  |  |  |  Branch (108:44): [True: 0, False: 86]
  |  |  |  |  |  |  ------------------
  |  |  |  |  |  |  109|     86|				 ((c) == 0xd) || \
  |  |  |  |  |  |  ------------------
  |  |  |  |  |  |  |  Branch (109:6): [True: 0, False: 86]
  |  |  |  |  |  |  ------------------
  |  |  |  |  |  |  110|     86|				  (0x20 <= (c)))
  |  |  |  |  |  |  ------------------
  |  |  |  |  |  |  |  Branch (110:7): [True: 86, False: 0]
  |  |  |  |  |  |  ------------------
  |  |  |  |  ------------------
  |  |  |  |  120|    172|				(((0x100 <= (c)) && ((c) <= 0xd7ff)) || \
  |  |  |  |  ------------------
  |  |  |  |  |  Branch (120:7): [True: 0, False: 0]
  |  |  |  |  |  Branch (120:25): [True: 0, False: 0]
  |  |  |  |  ------------------
  |  |  |  |  121|      0|				 ((0xe000 <= (c)) && ((c) <= 0xfffd)) || \
  |  |  |  |  ------------------
  |  |  |  |  |  Branch (121:7): [True: 0, False: 0]
  |  |  |  |  |  Branch (121:26): [True: 0, False: 0]
  |  |  |  |  ------------------
  |  |  |  |  122|      0|				 ((0x10000 <= (c)) && ((c) <= 0x10ffff))))
  |  |  |  |  ------------------
  |  |  |  |  |  Branch (122:7): [True: 0, False: 0]
  |  |  |  |  |  Branch (122:27): [True: 0, False: 0]
  |  |  |  |  ------------------
  |  |  ------------------
  ------------------
 5374|     86|		   ((cur != '?') || (NXT(1) != '>'))) {
  ------------------
  |  | 2223|      3|#define NXT(val) ctxt->input->cur[(val)]
  ------------------
  |  Branch (5374:7): [True: 83, False: 3]
  |  Branch (5374:23): [True: 0, False: 3]
  ------------------
 5375|     83|		if (len + 5 >= size) {
  ------------------
  |  Branch (5375:7): [True: 0, False: 83]
  ------------------
 5376|      0|		    xmlChar *tmp;
 5377|      0|                    size_t new_size = size * 2;
 5378|      0|		    tmp = (xmlChar *) xmlRealloc(buf, new_size);
 5379|      0|		    if (tmp == NULL) {
  ------------------
  |  Branch (5379:11): [True: 0, False: 0]
  ------------------
 5380|      0|			xmlErrMemory(ctxt, NULL);
 5381|      0|			xmlFree(buf);
 5382|      0|			ctxt->instate = state;
 5383|      0|			return;
 5384|      0|		    }
 5385|      0|		    buf = tmp;
 5386|      0|                    size = new_size;
 5387|      0|		}
 5388|     83|		COPY_BUF(buf, len, cur);
  ------------------
  |  | 2295|     83|    if (v < 0x80) b[i++] = v;						\
  |  |  ------------------
  |  |  |  Branch (2295:9): [True: 83, False: 0]
  |  |  ------------------
  |  | 2296|     83|    else i += xmlCopyCharMultiByte(&b[i],v)
  ------------------
 5389|     83|                if (len > maxLength) {
  ------------------
  |  Branch (5389:21): [True: 0, False: 83]
  ------------------
 5390|      0|                    xmlFatalErrMsgStr(ctxt, XML_ERR_PI_NOT_FINISHED,
 5391|      0|                                      "PI %s too big found", target);
 5392|      0|                    xmlFree(buf);
 5393|      0|                    ctxt->instate = state;
 5394|      0|                    return;
 5395|      0|                }
 5396|     83|		NEXTL(l);
  ------------------
  |  | 2284|     83|#define NEXTL(l) do {							\
  |  | 2285|     83|    if (*(ctxt->input->cur) == '\n') {					\
  |  |  ------------------
  |  |  |  Branch (2285:9): [True: 0, False: 83]
  |  |  ------------------
  |  | 2286|      0|	ctxt->input->line++; ctxt->input->col = 1;			\
  |  | 2287|     83|    } else ctxt->input->col++;						\
  |  | 2288|     83|    ctxt->input->cur += l;				\
  |  | 2289|     83|  } while (0)
  |  |  ------------------
  |  |  |  Branch (2289:12): [Folded - Ignored]
  |  |  ------------------
  ------------------
 5397|     83|		cur = CUR_CHAR(l);
  ------------------
  |  | 2291|     83|#define CUR_CHAR(l) xmlCurrentChar(ctxt, &l)
  ------------------
 5398|     83|	    }
 5399|      3|	    buf[len] = 0;
 5400|      3|            if (ctxt->instate == XML_PARSER_EOF) {
  ------------------
  |  Branch (5400:17): [True: 0, False: 3]
  ------------------
 5401|      0|                xmlFree(buf);
 5402|      0|                return;
 5403|      0|            }
 5404|      3|	    if (cur != '?') {
  ------------------
  |  Branch (5404:10): [True: 0, False: 3]
  ------------------
 5405|      0|		xmlFatalErrMsgStr(ctxt, XML_ERR_PI_NOT_FINISHED,
 5406|      0|		      "ParsePI: PI %s never end ...\n", target);
 5407|      3|	    } else {
 5408|      3|		if (inputid != ctxt->input->id) {
  ------------------
  |  Branch (5408:7): [True: 0, False: 3]
  ------------------
 5409|      0|		    xmlFatalErrMsg(ctxt, XML_ERR_ENTITY_BOUNDARY,
 5410|      0|	                           "PI declaration doesn't start and stop in"
 5411|      0|                                   " the same entity\n");
 5412|      0|		}
 5413|      3|		SKIP(2);
  ------------------
  |  | 2245|      3|#define SKIP(val) do {							\
  |  | 2246|      3|    ctxt->input->cur += (val),ctxt->input->col+=(val);			\
  |  | 2247|      3|    if (*ctxt->input->cur == 0)						\
  |  |  ------------------
  |  |  |  Branch (2247:9): [True: 0, False: 3]
  |  |  ------------------
  |  | 2248|      3|        xmlParserGrow(ctxt);						\
  |  | 2249|      3|  } while (0)
  |  |  ------------------
  |  |  |  Branch (2249:12): [Folded - Ignored]
  |  |  ------------------
  ------------------
 5414|       |
 5415|      3|#ifdef LIBXML_CATALOG_ENABLED
 5416|      3|		if (((state == XML_PARSER_MISC) ||
  ------------------
  |  Branch (5416:8): [True: 1, False: 2]
  ------------------
 5417|      3|	             (state == XML_PARSER_START)) &&
  ------------------
  |  Branch (5417:15): [True: 1, False: 1]
  ------------------
 5418|      3|		    (xmlStrEqual(target, XML_CATALOG_PI))) {
  ------------------
  |  |   45|      2|    (const xmlChar *) "oasis-xml-catalog"
  ------------------
  |  Branch (5418:7): [True: 0, False: 2]
  ------------------
 5419|      0|		    xmlCatalogAllow allow = xmlCatalogGetDefaults();
 5420|      0|		    if ((allow == XML_CATA_ALLOW_DOCUMENT) ||
  ------------------
  |  Branch (5420:11): [True: 0, False: 0]
  ------------------
 5421|      0|			(allow == XML_CATA_ALLOW_ALL))
  ------------------
  |  Branch (5421:4): [True: 0, False: 0]
  ------------------
 5422|      0|			xmlParseCatalogPI(ctxt, buf);
 5423|      0|		}
 5424|      3|#endif
 5425|       |
 5426|       |
 5427|       |		/*
 5428|       |		 * SAX: PI detected.
 5429|       |		 */
 5430|      3|		if ((ctxt->sax) && (!ctxt->disableSAX) &&
  ------------------
  |  Branch (5430:7): [True: 3, False: 0]
  |  Branch (5430:22): [True: 2, False: 1]
  ------------------
 5431|      3|		    (ctxt->sax->processingInstruction != NULL))
  ------------------
  |  Branch (5431:7): [True: 2, False: 0]
  ------------------
 5432|      2|		    ctxt->sax->processingInstruction(ctxt->userData,
 5433|      2|		                                     target, buf);
 5434|      3|	    }
 5435|      3|	    xmlFree(buf);
 5436|      3|	} else {
 5437|      0|	    xmlFatalErr(ctxt, XML_ERR_PI_NOT_STARTED, NULL);
 5438|      0|	}
 5439|      3|	if (ctxt->instate != XML_PARSER_EOF)
  ------------------
  |  Branch (5439:6): [True: 3, False: 0]
  ------------------
 5440|      3|	    ctxt->instate = state;
 5441|      3|    }
 5442|      3|}
xmlParseDefaultDecl:
 5824|      8|xmlParseDefaultDecl(xmlParserCtxtPtr ctxt, xmlChar **value) {
 5825|      8|    int val;
 5826|      8|    xmlChar *ret;
 5827|       |
 5828|      8|    *value = NULL;
 5829|      8|    if (CMP9(CUR_PTR, '#', 'R', 'E', 'Q', 'U', 'I', 'R', 'E', 'D')) {
  ------------------
  |  | 2239|      8|  ( CMP8( s, c1, c2, c3, c4, c5, c6, c7, c8 ) && \
  |  |  ------------------
  |  |  |  | 2237|     16|  ( CMP7( s, c1, c2, c3, c4, c5, c6, c7 ) && ((unsigned char *) s)[ 7 ] == c8 )
  |  |  |  |  ------------------
  |  |  |  |  |  | 2235|     16|  ( CMP6( s, c1, c2, c3, c4, c5, c6 ) && ((unsigned char *) s)[ 6 ] == c7 )
  |  |  |  |  |  |  ------------------
  |  |  |  |  |  |  |  | 2233|     16|  ( CMP5( s, c1, c2, c3, c4, c5 ) && ((unsigned char *) s)[ 5 ] == c6 )
  |  |  |  |  |  |  |  |  ------------------
  |  |  |  |  |  |  |  |  |  | 2231|     16|  ( CMP4( s, c1, c2, c3, c4 ) && ((unsigned char *) s)[ 4 ] == c5 )
  |  |  |  |  |  |  |  |  |  |  ------------------
  |  |  |  |  |  |  |  |  |  |  |  | 2228|     16|  ( ((unsigned char *) s)[ 0 ] == c1 && ((unsigned char *) s)[ 1 ] == c2 && \
  |  |  |  |  |  |  |  |  |  |  |  |  ------------------
  |  |  |  |  |  |  |  |  |  |  |  |  |  Branch (2228:5): [True: 8, False: 0]
  |  |  |  |  |  |  |  |  |  |  |  |  |  Branch (2228:41): [True: 0, False: 8]
  |  |  |  |  |  |  |  |  |  |  |  |  ------------------
  |  |  |  |  |  |  |  |  |  |  |  | 2229|      8|    ((unsigned char *) s)[ 2 ] == c3 && ((unsigned char *) s)[ 3 ] == c4 )
  |  |  |  |  |  |  |  |  |  |  |  |  ------------------
  |  |  |  |  |  |  |  |  |  |  |  |  |  Branch (2229:5): [True: 0, False: 0]
  |  |  |  |  |  |  |  |  |  |  |  |  |  Branch (2229:41): [True: 0, False: 0]
  |  |  |  |  |  |  |  |  |  |  |  |  ------------------
  |  |  |  |  |  |  |  |  |  |  ------------------
  |  |  |  |  |  |  |  |  |  |  |  Branch (2231:34): [True: 0, False: 0]
  |  |  |  |  |  |  |  |  |  |  ------------------
  |  |  |  |  |  |  |  |  ------------------
  |  |  |  |  |  |  |  |  |  Branch (2233:38): [True: 0, False: 0]
  |  |  |  |  |  |  |  |  ------------------
  |  |  |  |  |  |  ------------------
  |  |  |  |  |  |  |  Branch (2235:42): [True: 0, False: 0]
  |  |  |  |  |  |  ------------------
  |  |  |  |  ------------------
  |  |  |  |  |  Branch (2237:46): [True: 0, False: 0]
  |  |  |  |  ------------------
  |  |  ------------------
  |  | 2240|      8|    ((unsigned char *) s)[ 8 ] == c9 )
  |  |  ------------------
  |  |  |  Branch (2240:5): [True: 0, False: 0]
  |  |  ------------------
  ------------------
 5830|      0|	SKIP(9);
  ------------------
  |  | 2245|      0|#define SKIP(val) do {							\
  |  | 2246|      0|    ctxt->input->cur += (val),ctxt->input->col+=(val);			\
  |  | 2247|      0|    if (*ctxt->input->cur == 0)						\
  |  |  ------------------
  |  |  |  Branch (2247:9): [True: 0, False: 0]
  |  |  ------------------
  |  | 2248|      0|        xmlParserGrow(ctxt);						\
  |  | 2249|      0|  } while (0)
  |  |  ------------------
  |  |  |  Branch (2249:12): [Folded - Ignored]
  |  |  ------------------
  ------------------
 5831|      0|	return(XML_ATTRIBUTE_REQUIRED);
 5832|      0|    }
 5833|      8|    if (CMP8(CUR_PTR, '#', 'I', 'M', 'P', 'L', 'I', 'E', 'D')) {
  ------------------
  |  | 2237|      8|  ( CMP7( s, c1, c2, c3, c4, c5, c6, c7 ) && ((unsigned char *) s)[ 7 ] == c8 )
  |  |  ------------------
  |  |  |  | 2235|     16|  ( CMP6( s, c1, c2, c3, c4, c5, c6 ) && ((unsigned char *) s)[ 6 ] == c7 )
  |  |  |  |  ------------------
  |  |  |  |  |  | 2233|     16|  ( CMP5( s, c1, c2, c3, c4, c5 ) && ((unsigned char *) s)[ 5 ] == c6 )
  |  |  |  |  |  |  ------------------
  |  |  |  |  |  |  |  | 2231|     16|  ( CMP4( s, c1, c2, c3, c4 ) && ((unsigned char *) s)[ 4 ] == c5 )
  |  |  |  |  |  |  |  |  ------------------
  |  |  |  |  |  |  |  |  |  | 2228|     16|  ( ((unsigned char *) s)[ 0 ] == c1 && ((unsigned char *) s)[ 1 ] == c2 && \
  |  |  |  |  |  |  |  |  |  |  ------------------
  |  |  |  |  |  |  |  |  |  |  |  Branch (2228:5): [True: 8, False: 0]
  |  |  |  |  |  |  |  |  |  |  |  Branch (2228:41): [True: 8, False: 0]
  |  |  |  |  |  |  |  |  |  |  ------------------
  |  |  |  |  |  |  |  |  |  | 2229|      8|    ((unsigned char *) s)[ 2 ] == c3 && ((unsigned char *) s)[ 3 ] == c4 )
  |  |  |  |  |  |  |  |  |  |  ------------------
  |  |  |  |  |  |  |  |  |  |  |  Branch (2229:5): [True: 8, False: 0]
  |  |  |  |  |  |  |  |  |  |  |  Branch (2229:41): [True: 8, False: 0]
  |  |  |  |  |  |  |  |  |  |  ------------------
  |  |  |  |  |  |  |  |  ------------------
  |  |  |  |  |  |  |  |  |  Branch (2231:34): [True: 8, False: 0]
  |  |  |  |  |  |  |  |  ------------------
  |  |  |  |  |  |  ------------------
  |  |  |  |  |  |  |  Branch (2233:38): [True: 8, False: 0]
  |  |  |  |  |  |  ------------------
  |  |  |  |  ------------------
  |  |  |  |  |  Branch (2235:42): [True: 8, False: 0]
  |  |  |  |  ------------------
  |  |  ------------------
  |  |  |  Branch (2237:46): [True: 8, False: 0]
  |  |  ------------------
  ------------------
 5834|      8|	SKIP(8);
  ------------------
  |  | 2245|      8|#define SKIP(val) do {							\
  |  | 2246|      8|    ctxt->input->cur += (val),ctxt->input->col+=(val);			\
  |  | 2247|      8|    if (*ctxt->input->cur == 0)						\
  |  |  ------------------
  |  |  |  Branch (2247:9): [True: 0, False: 8]
  |  |  ------------------
  |  | 2248|      8|        xmlParserGrow(ctxt);						\
  |  | 2249|      8|  } while (0)
  |  |  ------------------
  |  |  |  Branch (2249:12): [Folded - Ignored]
  |  |  ------------------
  ------------------
 5835|      8|	return(XML_ATTRIBUTE_IMPLIED);
 5836|      8|    }
 5837|      0|    val = XML_ATTRIBUTE_NONE;
 5838|      0|    if (CMP6(CUR_PTR, '#', 'F', 'I', 'X', 'E', 'D')) {
  ------------------
  |  | 2233|      0|  ( CMP5( s, c1, c2, c3, c4, c5 ) && ((unsigned char *) s)[ 5 ] == c6 )
  |  |  ------------------
  |  |  |  | 2231|      0|  ( CMP4( s, c1, c2, c3, c4 ) && ((unsigned char *) s)[ 4 ] == c5 )
  |  |  |  |  ------------------
  |  |  |  |  |  | 2228|      0|  ( ((unsigned char *) s)[ 0 ] == c1 && ((unsigned char *) s)[ 1 ] == c2 && \
  |  |  |  |  |  |  ------------------
  |  |  |  |  |  |  |  Branch (2228:5): [True: 0, False: 0]
  |  |  |  |  |  |  |  Branch (2228:41): [True: 0, False: 0]
  |  |  |  |  |  |  ------------------
  |  |  |  |  |  | 2229|      0|    ((unsigned char *) s)[ 2 ] == c3 && ((unsigned char *) s)[ 3 ] == c4 )
  |  |  |  |  |  |  ------------------
  |  |  |  |  |  |  |  Branch (2229:5): [True: 0, False: 0]
  |  |  |  |  |  |  |  Branch (2229:41): [True: 0, False: 0]
  |  |  |  |  |  |  ------------------
  |  |  |  |  ------------------
  |  |  |  |  |  Branch (2231:34): [True: 0, False: 0]
  |  |  |  |  ------------------
  |  |  ------------------
  |  |  |  Branch (2233:38): [True: 0, False: 0]
  |  |  ------------------
  ------------------
 5839|      0|	SKIP(6);
  ------------------
  |  | 2245|      0|#define SKIP(val) do {							\
  |  | 2246|      0|    ctxt->input->cur += (val),ctxt->input->col+=(val);			\
  |  | 2247|      0|    if (*ctxt->input->cur == 0)						\
  |  |  ------------------
  |  |  |  Branch (2247:9): [True: 0, False: 0]
  |  |  ------------------
  |  | 2248|      0|        xmlParserGrow(ctxt);						\
  |  | 2249|      0|  } while (0)
  |  |  ------------------
  |  |  |  Branch (2249:12): [Folded - Ignored]
  |  |  ------------------
  ------------------
 5840|      0|	val = XML_ATTRIBUTE_FIXED;
 5841|      0|	if (SKIP_BLANKS == 0) {
  ------------------
  |  | 2273|      0|#define SKIP_BLANKS xmlSkipBlankChars(ctxt)
  ------------------
  |  Branch (5841:6): [True: 0, False: 0]
  ------------------
 5842|      0|	    xmlFatalErrMsg(ctxt, XML_ERR_SPACE_REQUIRED,
 5843|      0|			   "Space required after '#FIXED'\n");
 5844|      0|	}
 5845|      0|    }
 5846|      0|    ret = xmlParseAttValue(ctxt);
 5847|      0|    ctxt->instate = XML_PARSER_DTD;
 5848|      0|    if (ret == NULL) {
  ------------------
  |  Branch (5848:9): [True: 0, False: 0]
  ------------------
 5849|      0|	xmlFatalErrMsg(ctxt, (xmlParserErrors)ctxt->errNo,
 5850|      0|		       "Attribute default value declaration error\n");
 5851|      0|    } else
 5852|      0|        *value = ret;
 5853|      0|    return(val);
 5854|      8|}
xmlParseAttributeType:
 6082|      8|xmlParseAttributeType(xmlParserCtxtPtr ctxt, xmlEnumerationPtr *tree) {
 6083|      8|    if (CMP5(CUR_PTR, 'C', 'D', 'A', 'T', 'A')) {
  ------------------
  |  | 2231|      8|  ( CMP4( s, c1, c2, c3, c4 ) && ((unsigned char *) s)[ 4 ] == c5 )
  |  |  ------------------
  |  |  |  | 2228|     16|  ( ((unsigned char *) s)[ 0 ] == c1 && ((unsigned char *) s)[ 1 ] == c2 && \
  |  |  |  |  ------------------
  |  |  |  |  |  Branch (2228:5): [True: 0, False: 8]
  |  |  |  |  |  Branch (2228:41): [True: 0, False: 0]
  |  |  |  |  ------------------
  |  |  |  | 2229|      8|    ((unsigned char *) s)[ 2 ] == c3 && ((unsigned char *) s)[ 3 ] == c4 )
  |  |  |  |  ------------------
  |  |  |  |  |  Branch (2229:5): [True: 0, False: 0]
  |  |  |  |  |  Branch (2229:41): [True: 0, False: 0]
  |  |  |  |  ------------------
  |  |  ------------------
  |  |  |  Branch (2231:34): [True: 0, False: 0]
  |  |  ------------------
  ------------------
 6084|      0|	SKIP(5);
  ------------------
  |  | 2245|      0|#define SKIP(val) do {							\
  |  | 2246|      0|    ctxt->input->cur += (val),ctxt->input->col+=(val);			\
  |  | 2247|      0|    if (*ctxt->input->cur == 0)						\
  |  |  ------------------
  |  |  |  Branch (2247:9): [True: 0, False: 0]
  |  |  ------------------
  |  | 2248|      0|        xmlParserGrow(ctxt);						\
  |  | 2249|      0|  } while (0)
  |  |  ------------------
  |  |  |  Branch (2249:12): [Folded - Ignored]
  |  |  ------------------
  ------------------
 6085|      0|	return(XML_ATTRIBUTE_CDATA);
 6086|      8|     } else if (CMP6(CUR_PTR, 'I', 'D', 'R', 'E', 'F', 'S')) {
  ------------------
  |  | 2233|      8|  ( CMP5( s, c1, c2, c3, c4, c5 ) && ((unsigned char *) s)[ 5 ] == c6 )
  |  |  ------------------
  |  |  |  | 2231|     16|  ( CMP4( s, c1, c2, c3, c4 ) && ((unsigned char *) s)[ 4 ] == c5 )
  |  |  |  |  ------------------
  |  |  |  |  |  | 2228|     16|  ( ((unsigned char *) s)[ 0 ] == c1 && ((unsigned char *) s)[ 1 ] == c2 && \
  |  |  |  |  |  |  ------------------
  |  |  |  |  |  |  |  Branch (2228:5): [True: 8, False: 0]
  |  |  |  |  |  |  |  Branch (2228:41): [True: 8, False: 0]
  |  |  |  |  |  |  ------------------
  |  |  |  |  |  | 2229|      8|    ((unsigned char *) s)[ 2 ] == c3 && ((unsigned char *) s)[ 3 ] == c4 )
  |  |  |  |  |  |  ------------------
  |  |  |  |  |  |  |  Branch (2229:5): [True: 0, False: 8]
  |  |  |  |  |  |  |  Branch (2229:41): [True: 0, False: 0]
  |  |  |  |  |  |  ------------------
  |  |  |  |  ------------------
  |  |  |  |  |  Branch (2231:34): [True: 0, False: 0]
  |  |  |  |  ------------------
  |  |  ------------------
  |  |  |  Branch (2233:38): [True: 0, False: 0]
  |  |  ------------------
  ------------------
 6087|      0|	SKIP(6);
  ------------------
  |  | 2245|      0|#define SKIP(val) do {							\
  |  | 2246|      0|    ctxt->input->cur += (val),ctxt->input->col+=(val);			\
  |  | 2247|      0|    if (*ctxt->input->cur == 0)						\
  |  |  ------------------
  |  |  |  Branch (2247:9): [True: 0, False: 0]
  |  |  ------------------
  |  | 2248|      0|        xmlParserGrow(ctxt);						\
  |  | 2249|      0|  } while (0)
  |  |  ------------------
  |  |  |  Branch (2249:12): [Folded - Ignored]
  |  |  ------------------
  ------------------
 6088|      0|	return(XML_ATTRIBUTE_IDREFS);
 6089|      8|     } else if (CMP5(CUR_PTR, 'I', 'D', 'R', 'E', 'F')) {
  ------------------
  |  | 2231|      8|  ( CMP4( s, c1, c2, c3, c4 ) && ((unsigned char *) s)[ 4 ] == c5 )
  |  |  ------------------
  |  |  |  | 2228|     16|  ( ((unsigned char *) s)[ 0 ] == c1 && ((unsigned char *) s)[ 1 ] == c2 && \
  |  |  |  |  ------------------
  |  |  |  |  |  Branch (2228:5): [True: 8, False: 0]
  |  |  |  |  |  Branch (2228:41): [True: 8, False: 0]
  |  |  |  |  ------------------
  |  |  |  | 2229|      8|    ((unsigned char *) s)[ 2 ] == c3 && ((unsigned char *) s)[ 3 ] == c4 )
  |  |  |  |  ------------------
  |  |  |  |  |  Branch (2229:5): [True: 0, False: 8]
  |  |  |  |  |  Branch (2229:41): [True: 0, False: 0]
  |  |  |  |  ------------------
  |  |  ------------------
  |  |  |  Branch (2231:34): [True: 0, False: 0]
  |  |  ------------------
  ------------------
 6090|      0|	SKIP(5);
  ------------------
  |  | 2245|      0|#define SKIP(val) do {							\
  |  | 2246|      0|    ctxt->input->cur += (val),ctxt->input->col+=(val);			\
  |  | 2247|      0|    if (*ctxt->input->cur == 0)						\
  |  |  ------------------
  |  |  |  Branch (2247:9): [True: 0, False: 0]
  |  |  ------------------
  |  | 2248|      0|        xmlParserGrow(ctxt);						\
  |  | 2249|      0|  } while (0)
  |  |  ------------------
  |  |  |  Branch (2249:12): [Folded - Ignored]
  |  |  ------------------
  ------------------
 6091|      0|	return(XML_ATTRIBUTE_IDREF);
 6092|      8|     } else if ((RAW == 'I') && (NXT(1) == 'D')) {
  ------------------
  |  | 2221|      8|#define RAW (*ctxt->input->cur)
  ------------------
                   } else if ((RAW == 'I') && (NXT(1) == 'D')) {
  ------------------
  |  | 2223|      8|#define NXT(val) ctxt->input->cur[(val)]
  ------------------
  |  Branch (6092:17): [True: 8, False: 0]
  |  Branch (6092:33): [True: 8, False: 0]
  ------------------
 6093|      8|        SKIP(2);
  ------------------
  |  | 2245|      8|#define SKIP(val) do {							\
  |  | 2246|      8|    ctxt->input->cur += (val),ctxt->input->col+=(val);			\
  |  | 2247|      8|    if (*ctxt->input->cur == 0)						\
  |  |  ------------------
  |  |  |  Branch (2247:9): [True: 0, False: 8]
  |  |  ------------------
  |  | 2248|      8|        xmlParserGrow(ctxt);						\
  |  | 2249|      8|  } while (0)
  |  |  ------------------
  |  |  |  Branch (2249:12): [Folded - Ignored]
  |  |  ------------------
  ------------------
 6094|      8|	return(XML_ATTRIBUTE_ID);
 6095|      8|     } else if (CMP6(CUR_PTR, 'E', 'N', 'T', 'I', 'T', 'Y')) {
  ------------------
  |  | 2233|      0|  ( CMP5( s, c1, c2, c3, c4, c5 ) && ((unsigned char *) s)[ 5 ] == c6 )
  |  |  ------------------
  |  |  |  | 2231|      0|  ( CMP4( s, c1, c2, c3, c4 ) && ((unsigned char *) s)[ 4 ] == c5 )
  |  |  |  |  ------------------
  |  |  |  |  |  | 2228|      0|  ( ((unsigned char *) s)[ 0 ] == c1 && ((unsigned char *) s)[ 1 ] == c2 && \
  |  |  |  |  |  |  ------------------
  |  |  |  |  |  |  |  Branch (2228:5): [True: 0, False: 0]
  |  |  |  |  |  |  |  Branch (2228:41): [True: 0, False: 0]
  |  |  |  |  |  |  ------------------
  |  |  |  |  |  | 2229|      0|    ((unsigned char *) s)[ 2 ] == c3 && ((unsigned char *) s)[ 3 ] == c4 )
  |  |  |  |  |  |  ------------------
  |  |  |  |  |  |  |  Branch (2229:5): [True: 0, False: 0]
  |  |  |  |  |  |  |  Branch (2229:41): [True: 0, False: 0]
  |  |  |  |  |  |  ------------------
  |  |  |  |  ------------------
  |  |  |  |  |  Branch (2231:34): [True: 0, False: 0]
  |  |  |  |  ------------------
  |  |  ------------------
  |  |  |  Branch (2233:38): [True: 0, False: 0]
  |  |  ------------------
  ------------------
 6096|      0|	SKIP(6);
  ------------------
  |  | 2245|      0|#define SKIP(val) do {							\
  |  | 2246|      0|    ctxt->input->cur += (val),ctxt->input->col+=(val);			\
  |  | 2247|      0|    if (*ctxt->input->cur == 0)						\
  |  |  ------------------
  |  |  |  Branch (2247:9): [True: 0, False: 0]
  |  |  ------------------
  |  | 2248|      0|        xmlParserGrow(ctxt);						\
  |  | 2249|      0|  } while (0)
  |  |  ------------------
  |  |  |  Branch (2249:12): [Folded - Ignored]
  |  |  ------------------
  ------------------
 6097|      0|	return(XML_ATTRIBUTE_ENTITY);
 6098|      0|     } else if (CMP8(CUR_PTR, 'E', 'N', 'T', 'I', 'T', 'I', 'E', 'S')) {
  ------------------
  |  | 2237|      0|  ( CMP7( s, c1, c2, c3, c4, c5, c6, c7 ) && ((unsigned char *) s)[ 7 ] == c8 )
  |  |  ------------------
  |  |  |  | 2235|      0|  ( CMP6( s, c1, c2, c3, c4, c5, c6 ) && ((unsigned char *) s)[ 6 ] == c7 )
  |  |  |  |  ------------------
  |  |  |  |  |  | 2233|      0|  ( CMP5( s, c1, c2, c3, c4, c5 ) && ((unsigned char *) s)[ 5 ] == c6 )
  |  |  |  |  |  |  ------------------
  |  |  |  |  |  |  |  | 2231|      0|  ( CMP4( s, c1, c2, c3, c4 ) && ((unsigned char *) s)[ 4 ] == c5 )
  |  |  |  |  |  |  |  |  ------------------
  |  |  |  |  |  |  |  |  |  | 2228|      0|  ( ((unsigned char *) s)[ 0 ] == c1 && ((unsigned char *) s)[ 1 ] == c2 && \
  |  |  |  |  |  |  |  |  |  |  ------------------
  |  |  |  |  |  |  |  |  |  |  |  Branch (2228:5): [True: 0, False: 0]
  |  |  |  |  |  |  |  |  |  |  |  Branch (2228:41): [True: 0, False: 0]
  |  |  |  |  |  |  |  |  |  |  ------------------
  |  |  |  |  |  |  |  |  |  | 2229|      0|    ((unsigned char *) s)[ 2 ] == c3 && ((unsigned char *) s)[ 3 ] == c4 )
  |  |  |  |  |  |  |  |  |  |  ------------------
  |  |  |  |  |  |  |  |  |  |  |  Branch (2229:5): [True: 0, False: 0]
  |  |  |  |  |  |  |  |  |  |  |  Branch (2229:41): [True: 0, False: 0]
  |  |  |  |  |  |  |  |  |  |  ------------------
  |  |  |  |  |  |  |  |  ------------------
  |  |  |  |  |  |  |  |  |  Branch (2231:34): [True: 0, False: 0]
  |  |  |  |  |  |  |  |  ------------------
  |  |  |  |  |  |  ------------------
  |  |  |  |  |  |  |  Branch (2233:38): [True: 0, False: 0]
  |  |  |  |  |  |  ------------------
  |  |  |  |  ------------------
  |  |  |  |  |  Branch (2235:42): [True: 0, False: 0]
  |  |  |  |  ------------------
  |  |  ------------------
  |  |  |  Branch (2237:46): [True: 0, False: 0]
  |  |  ------------------
  ------------------
 6099|      0|	SKIP(8);
  ------------------
  |  | 2245|      0|#define SKIP(val) do {							\
  |  | 2246|      0|    ctxt->input->cur += (val),ctxt->input->col+=(val);			\
  |  | 2247|      0|    if (*ctxt->input->cur == 0)						\
  |  |  ------------------
  |  |  |  Branch (2247:9): [True: 0, False: 0]
  |  |  ------------------
  |  | 2248|      0|        xmlParserGrow(ctxt);						\
  |  | 2249|      0|  } while (0)
  |  |  ------------------
  |  |  |  Branch (2249:12): [Folded - Ignored]
  |  |  ------------------
  ------------------
 6100|      0|	return(XML_ATTRIBUTE_ENTITIES);
 6101|      0|     } else if (CMP8(CUR_PTR, 'N', 'M', 'T', 'O', 'K', 'E', 'N', 'S')) {
  ------------------
  |  | 2237|      0|  ( CMP7( s, c1, c2, c3, c4, c5, c6, c7 ) && ((unsigned char *) s)[ 7 ] == c8 )
  |  |  ------------------
  |  |  |  | 2235|      0|  ( CMP6( s, c1, c2, c3, c4, c5, c6 ) && ((unsigned char *) s)[ 6 ] == c7 )
  |  |  |  |  ------------------
  |  |  |  |  |  | 2233|      0|  ( CMP5( s, c1, c2, c3, c4, c5 ) && ((unsigned char *) s)[ 5 ] == c6 )
  |  |  |  |  |  |  ------------------
  |  |  |  |  |  |  |  | 2231|      0|  ( CMP4( s, c1, c2, c3, c4 ) && ((unsigned char *) s)[ 4 ] == c5 )
  |  |  |  |  |  |  |  |  ------------------
  |  |  |  |  |  |  |  |  |  | 2228|      0|  ( ((unsigned char *) s)[ 0 ] == c1 && ((unsigned char *) s)[ 1 ] == c2 && \
  |  |  |  |  |  |  |  |  |  |  ------------------
  |  |  |  |  |  |  |  |  |  |  |  Branch (2228:5): [True: 0, False: 0]
  |  |  |  |  |  |  |  |  |  |  |  Branch (2228:41): [True: 0, False: 0]
  |  |  |  |  |  |  |  |  |  |  ------------------
  |  |  |  |  |  |  |  |  |  | 2229|      0|    ((unsigned char *) s)[ 2 ] == c3 && ((unsigned char *) s)[ 3 ] == c4 )
  |  |  |  |  |  |  |  |  |  |  ------------------
  |  |  |  |  |  |  |  |  |  |  |  Branch (2229:5): [True: 0, False: 0]
  |  |  |  |  |  |  |  |  |  |  |  Branch (2229:41): [True: 0, False: 0]
  |  |  |  |  |  |  |  |  |  |  ------------------
  |  |  |  |  |  |  |  |  ------------------
  |  |  |  |  |  |  |  |  |  Branch (2231:34): [True: 0, False: 0]
  |  |  |  |  |  |  |  |  ------------------
  |  |  |  |  |  |  ------------------
  |  |  |  |  |  |  |  Branch (2233:38): [True: 0, False: 0]
  |  |  |  |  |  |  ------------------
  |  |  |  |  ------------------
  |  |  |  |  |  Branch (2235:42): [True: 0, False: 0]
  |  |  |  |  ------------------
  |  |  ------------------
  |  |  |  Branch (2237:46): [True: 0, False: 0]
  |  |  ------------------
  ------------------
 6102|      0|	SKIP(8);
  ------------------
  |  | 2245|      0|#define SKIP(val) do {							\
  |  | 2246|      0|    ctxt->input->cur += (val),ctxt->input->col+=(val);			\
  |  | 2247|      0|    if (*ctxt->input->cur == 0)						\
  |  |  ------------------
  |  |  |  Branch (2247:9): [True: 0, False: 0]
  |  |  ------------------
  |  | 2248|      0|        xmlParserGrow(ctxt);						\
  |  | 2249|      0|  } while (0)
  |  |  ------------------
  |  |  |  Branch (2249:12): [Folded - Ignored]
  |  |  ------------------
  ------------------
 6103|      0|	return(XML_ATTRIBUTE_NMTOKENS);
 6104|      0|     } else if (CMP7(CUR_PTR, 'N', 'M', 'T', 'O', 'K', 'E', 'N')) {
  ------------------
  |  | 2235|      0|  ( CMP6( s, c1, c2, c3, c4, c5, c6 ) && ((unsigned char *) s)[ 6 ] == c7 )
  |  |  ------------------
  |  |  |  | 2233|      0|  ( CMP5( s, c1, c2, c3, c4, c5 ) && ((unsigned char *) s)[ 5 ] == c6 )
  |  |  |  |  ------------------
  |  |  |  |  |  | 2231|      0|  ( CMP4( s, c1, c2, c3, c4 ) && ((unsigned char *) s)[ 4 ] == c5 )
  |  |  |  |  |  |  ------------------
  |  |  |  |  |  |  |  | 2228|      0|  ( ((unsigned char *) s)[ 0 ] == c1 && ((unsigned char *) s)[ 1 ] == c2 && \
  |  |  |  |  |  |  |  |  ------------------
  |  |  |  |  |  |  |  |  |  Branch (2228:5): [True: 0, False: 0]
  |  |  |  |  |  |  |  |  |  Branch (2228:41): [True: 0, False: 0]
  |  |  |  |  |  |  |  |  ------------------
  |  |  |  |  |  |  |  | 2229|      0|    ((unsigned char *) s)[ 2 ] == c3 && ((unsigned char *) s)[ 3 ] == c4 )
  |  |  |  |  |  |  |  |  ------------------
  |  |  |  |  |  |  |  |  |  Branch (2229:5): [True: 0, False: 0]
  |  |  |  |  |  |  |  |  |  Branch (2229:41): [True: 0, False: 0]
  |  |  |  |  |  |  |  |  ------------------
  |  |  |  |  |  |  ------------------
  |  |  |  |  |  |  |  Branch (2231:34): [True: 0, False: 0]
  |  |  |  |  |  |  ------------------
  |  |  |  |  ------------------
  |  |  |  |  |  Branch (2233:38): [True: 0, False: 0]
  |  |  |  |  ------------------
  |  |  ------------------
  |  |  |  Branch (2235:42): [True: 0, False: 0]
  |  |  ------------------
  ------------------
 6105|      0|	SKIP(7);
  ------------------
  |  | 2245|      0|#define SKIP(val) do {							\
  |  | 2246|      0|    ctxt->input->cur += (val),ctxt->input->col+=(val);			\
  |  | 2247|      0|    if (*ctxt->input->cur == 0)						\
  |  |  ------------------
  |  |  |  Branch (2247:9): [True: 0, False: 0]
  |  |  ------------------
  |  | 2248|      0|        xmlParserGrow(ctxt);						\
  |  | 2249|      0|  } while (0)
  |  |  ------------------
  |  |  |  Branch (2249:12): [Folded - Ignored]
  |  |  ------------------
  ------------------
 6106|      0|	return(XML_ATTRIBUTE_NMTOKEN);
 6107|      0|     }
 6108|      0|     return(xmlParseEnumeratedType(ctxt, tree));
 6109|      8|}
xmlParseAttributeListDecl:
 6125|      8|xmlParseAttributeListDecl(xmlParserCtxtPtr ctxt) {
 6126|      8|    const xmlChar *elemName;
 6127|      8|    const xmlChar *attrName;
 6128|      8|    xmlEnumerationPtr tree;
 6129|       |
 6130|      8|    if ((CUR != '<') || (NXT(1) != '!'))
  ------------------
  |  | 2222|      8|#define CUR (*ctxt->input->cur)
  ------------------
                  if ((CUR != '<') || (NXT(1) != '!'))
  ------------------
  |  | 2223|      8|#define NXT(val) ctxt->input->cur[(val)]
  ------------------
  |  Branch (6130:9): [True: 0, False: 8]
  |  Branch (6130:25): [True: 0, False: 8]
  ------------------
 6131|      0|        return;
 6132|      8|    SKIP(2);
  ------------------
  |  | 2245|      8|#define SKIP(val) do {							\
  |  | 2246|      8|    ctxt->input->cur += (val),ctxt->input->col+=(val);			\
  |  | 2247|      8|    if (*ctxt->input->cur == 0)						\
  |  |  ------------------
  |  |  |  Branch (2247:9): [True: 0, False: 8]
  |  |  ------------------
  |  | 2248|      8|        xmlParserGrow(ctxt);						\
  |  | 2249|      8|  } while (0)
  |  |  ------------------
  |  |  |  Branch (2249:12): [Folded - Ignored]
  |  |  ------------------
  ------------------
 6133|       |
 6134|      8|    if (CMP7(CUR_PTR, 'A', 'T', 'T', 'L', 'I', 'S', 'T')) {
  ------------------
  |  | 2235|      8|  ( CMP6( s, c1, c2, c3, c4, c5, c6 ) && ((unsigned char *) s)[ 6 ] == c7 )
  |  |  ------------------
  |  |  |  | 2233|     16|  ( CMP5( s, c1, c2, c3, c4, c5 ) && ((unsigned char *) s)[ 5 ] == c6 )
  |  |  |  |  ------------------
  |  |  |  |  |  | 2231|     16|  ( CMP4( s, c1, c2, c3, c4 ) && ((unsigned char *) s)[ 4 ] == c5 )
  |  |  |  |  |  |  ------------------
  |  |  |  |  |  |  |  | 2228|     16|  ( ((unsigned char *) s)[ 0 ] == c1 && ((unsigned char *) s)[ 1 ] == c2 && \
  |  |  |  |  |  |  |  |  ------------------
  |  |  |  |  |  |  |  |  |  Branch (2228:5): [True: 8, False: 0]
  |  |  |  |  |  |  |  |  |  Branch (2228:41): [True: 8, False: 0]
  |  |  |  |  |  |  |  |  ------------------
  |  |  |  |  |  |  |  | 2229|      8|    ((unsigned char *) s)[ 2 ] == c3 && ((unsigned char *) s)[ 3 ] == c4 )
  |  |  |  |  |  |  |  |  ------------------
  |  |  |  |  |  |  |  |  |  Branch (2229:5): [True: 8, False: 0]
  |  |  |  |  |  |  |  |  |  Branch (2229:41): [True: 8, False: 0]
  |  |  |  |  |  |  |  |  ------------------
  |  |  |  |  |  |  ------------------
  |  |  |  |  |  |  |  Branch (2231:34): [True: 8, False: 0]
  |  |  |  |  |  |  ------------------
  |  |  |  |  ------------------
  |  |  |  |  |  Branch (2233:38): [True: 8, False: 0]
  |  |  |  |  ------------------
  |  |  ------------------
  |  |  |  Branch (2235:42): [True: 8, False: 0]
  |  |  ------------------
  ------------------
 6135|      8|	int inputid = ctxt->input->id;
 6136|       |
 6137|      8|	SKIP(7);
  ------------------
  |  | 2245|      8|#define SKIP(val) do {							\
  |  | 2246|      8|    ctxt->input->cur += (val),ctxt->input->col+=(val);			\
  |  | 2247|      8|    if (*ctxt->input->cur == 0)						\
  |  |  ------------------
  |  |  |  Branch (2247:9): [True: 0, False: 8]
  |  |  ------------------
  |  | 2248|      8|        xmlParserGrow(ctxt);						\
  |  | 2249|      8|  } while (0)
  |  |  ------------------
  |  |  |  Branch (2249:12): [Folded - Ignored]
  |  |  ------------------
  ------------------
 6138|      8|	if (SKIP_BLANKS == 0) {
  ------------------
  |  | 2273|      8|#define SKIP_BLANKS xmlSkipBlankChars(ctxt)
  ------------------
  |  Branch (6138:6): [True: 0, False: 8]
  ------------------
 6139|      0|	    xmlFatalErrMsg(ctxt, XML_ERR_SPACE_REQUIRED,
 6140|      0|		                 "Space required after '<!ATTLIST'\n");
 6141|      0|	}
 6142|      8|        elemName = xmlParseName(ctxt);
 6143|      8|	if (elemName == NULL) {
  ------------------
  |  Branch (6143:6): [True: 0, False: 8]
  ------------------
 6144|      0|	    xmlFatalErrMsg(ctxt, XML_ERR_NAME_REQUIRED,
 6145|      0|			   "ATTLIST: no name for Element\n");
 6146|      0|	    return;
 6147|      0|	}
 6148|      8|	SKIP_BLANKS;
  ------------------
  |  | 2273|      8|#define SKIP_BLANKS xmlSkipBlankChars(ctxt)
  ------------------
 6149|      8|	GROW;
  ------------------
  |  | 2270|      8|#define GROW if (ctxt->input->end - ctxt->input->cur < INPUT_CHUNK)	\
  |  |  ------------------
  |  |  |  |   97|      8|#define INPUT_CHUNK	250
  |  |  ------------------
  |  |  |  Branch (2270:18): [True: 8, False: 0]
  |  |  ------------------
  |  | 2271|      8|	xmlParserGrow(ctxt);
  ------------------
 6150|     16|	while ((RAW != '>') && (ctxt->instate != XML_PARSER_EOF)) {
  ------------------
  |  | 2221|     16|#define RAW (*ctxt->input->cur)
  ------------------
  |  Branch (6150:9): [True: 8, False: 8]
  |  Branch (6150:25): [True: 8, False: 0]
  ------------------
 6151|      8|	    int type;
 6152|      8|	    int def;
 6153|      8|	    xmlChar *defaultValue = NULL;
 6154|       |
 6155|      8|	    GROW;
  ------------------
  |  | 2270|      8|#define GROW if (ctxt->input->end - ctxt->input->cur < INPUT_CHUNK)	\
  |  |  ------------------
  |  |  |  |   97|      8|#define INPUT_CHUNK	250
  |  |  ------------------
  |  |  |  Branch (2270:18): [True: 8, False: 0]
  |  |  ------------------
  |  | 2271|      8|	xmlParserGrow(ctxt);
  ------------------
 6156|      8|            tree = NULL;
 6157|      8|	    attrName = xmlParseName(ctxt);
 6158|      8|	    if (attrName == NULL) {
  ------------------
  |  Branch (6158:10): [True: 0, False: 8]
  ------------------
 6159|      0|		xmlFatalErrMsg(ctxt, XML_ERR_NAME_REQUIRED,
 6160|      0|			       "ATTLIST: no name for Attribute\n");
 6161|      0|		break;
 6162|      0|	    }
 6163|      8|	    GROW;
  ------------------
  |  | 2270|      8|#define GROW if (ctxt->input->end - ctxt->input->cur < INPUT_CHUNK)	\
  |  |  ------------------
  |  |  |  |   97|      8|#define INPUT_CHUNK	250
  |  |  ------------------
  |  |  |  Branch (2270:18): [True: 8, False: 0]
  |  |  ------------------
  |  | 2271|      8|	xmlParserGrow(ctxt);
  ------------------
 6164|      8|	    if (SKIP_BLANKS == 0) {
  ------------------
  |  | 2273|      8|#define SKIP_BLANKS xmlSkipBlankChars(ctxt)
  ------------------
  |  Branch (6164:10): [True: 0, False: 8]
  ------------------
 6165|      0|		xmlFatalErrMsg(ctxt, XML_ERR_SPACE_REQUIRED,
 6166|      0|		        "Space required after the attribute name\n");
 6167|      0|		break;
 6168|      0|	    }
 6169|       |
 6170|      8|	    type = xmlParseAttributeType(ctxt, &tree);
 6171|      8|	    if (type <= 0) {
  ------------------
  |  Branch (6171:10): [True: 0, False: 8]
  ------------------
 6172|      0|	        break;
 6173|      0|	    }
 6174|       |
 6175|      8|	    GROW;
  ------------------
  |  | 2270|      8|#define GROW if (ctxt->input->end - ctxt->input->cur < INPUT_CHUNK)	\
  |  |  ------------------
  |  |  |  |   97|      8|#define INPUT_CHUNK	250
  |  |  ------------------
  |  |  |  Branch (2270:18): [True: 8, False: 0]
  |  |  ------------------
  |  | 2271|      8|	xmlParserGrow(ctxt);
  ------------------
 6176|      8|	    if (SKIP_BLANKS == 0) {
  ------------------
  |  | 2273|      8|#define SKIP_BLANKS xmlSkipBlankChars(ctxt)
  ------------------
  |  Branch (6176:10): [True: 0, False: 8]
  ------------------
 6177|      0|		xmlFatalErrMsg(ctxt, XML_ERR_SPACE_REQUIRED,
 6178|      0|			       "Space required after the attribute type\n");
 6179|      0|	        if (tree != NULL)
  ------------------
  |  Branch (6179:14): [True: 0, False: 0]
  ------------------
 6180|      0|		    xmlFreeEnumeration(tree);
 6181|      0|		break;
 6182|      0|	    }
 6183|       |
 6184|      8|	    def = xmlParseDefaultDecl(ctxt, &defaultValue);
 6185|      8|	    if (def <= 0) {
  ------------------
  |  Branch (6185:10): [True: 0, False: 8]
  ------------------
 6186|      0|                if (defaultValue != NULL)
  ------------------
  |  Branch (6186:21): [True: 0, False: 0]
  ------------------
 6187|      0|		    xmlFree(defaultValue);
 6188|      0|	        if (tree != NULL)
  ------------------
  |  Branch (6188:14): [True: 0, False: 0]
  ------------------
 6189|      0|		    xmlFreeEnumeration(tree);
 6190|      0|	        break;
 6191|      0|	    }
 6192|      8|	    if ((type != XML_ATTRIBUTE_CDATA) && (defaultValue != NULL))
  ------------------
  |  Branch (6192:10): [True: 8, False: 0]
  |  Branch (6192:43): [True: 0, False: 8]
  ------------------
 6193|      0|	        xmlAttrNormalizeSpace(defaultValue, defaultValue);
 6194|       |
 6195|      8|	    GROW;
  ------------------
  |  | 2270|      8|#define GROW if (ctxt->input->end - ctxt->input->cur < INPUT_CHUNK)	\
  |  |  ------------------
  |  |  |  |   97|      8|#define INPUT_CHUNK	250
  |  |  ------------------
  |  |  |  Branch (2270:18): [True: 8, False: 0]
  |  |  ------------------
  |  | 2271|      8|	xmlParserGrow(ctxt);
  ------------------
 6196|      8|            if (RAW != '>') {
  ------------------
  |  | 2221|      8|#define RAW (*ctxt->input->cur)
  ------------------
  |  Branch (6196:17): [True: 0, False: 8]
  ------------------
 6197|      0|		if (SKIP_BLANKS == 0) {
  ------------------
  |  | 2273|      0|#define SKIP_BLANKS xmlSkipBlankChars(ctxt)
  ------------------
  |  Branch (6197:7): [True: 0, False: 0]
  ------------------
 6198|      0|		    xmlFatalErrMsg(ctxt, XML_ERR_SPACE_REQUIRED,
 6199|      0|			"Space required after the attribute default value\n");
 6200|      0|		    if (defaultValue != NULL)
  ------------------
  |  Branch (6200:11): [True: 0, False: 0]
  ------------------
 6201|      0|			xmlFree(defaultValue);
 6202|      0|		    if (tree != NULL)
  ------------------
  |  Branch (6202:11): [True: 0, False: 0]
  ------------------
 6203|      0|			xmlFreeEnumeration(tree);
 6204|      0|		    break;
 6205|      0|		}
 6206|      0|	    }
 6207|      8|	    if ((ctxt->sax != NULL) && (!ctxt->disableSAX) &&
  ------------------
  |  Branch (6207:10): [True: 8, False: 0]
  |  Branch (6207:33): [True: 8, False: 0]
  ------------------
 6208|      8|		(ctxt->sax->attributeDecl != NULL))
  ------------------
  |  Branch (6208:3): [True: 8, False: 0]
  ------------------
 6209|      8|		ctxt->sax->attributeDecl(ctxt->userData, elemName, attrName,
 6210|      8|	                        type, def, defaultValue, tree);
 6211|      0|	    else if (tree != NULL)
  ------------------
  |  Branch (6211:15): [True: 0, False: 0]
  ------------------
 6212|      0|		xmlFreeEnumeration(tree);
 6213|       |
 6214|      8|	    if ((ctxt->sax2) && (defaultValue != NULL) &&
  ------------------
  |  Branch (6214:10): [True: 8, False: 0]
  |  Branch (6214:26): [True: 0, False: 8]
  ------------------
 6215|      8|	        (def != XML_ATTRIBUTE_IMPLIED) &&
  ------------------
  |  Branch (6215:10): [True: 0, False: 0]
  ------------------
 6216|      8|		(def != XML_ATTRIBUTE_REQUIRED)) {
  ------------------
  |  Branch (6216:3): [True: 0, False: 0]
  ------------------
 6217|      0|		xmlAddDefAttrs(ctxt, elemName, attrName, defaultValue);
 6218|      0|	    }
 6219|      8|	    if (ctxt->sax2) {
  ------------------
  |  Branch (6219:10): [True: 8, False: 0]
  ------------------
 6220|      8|		xmlAddSpecialAttr(ctxt, elemName, attrName, type);
 6221|      8|	    }
 6222|      8|	    if (defaultValue != NULL)
  ------------------
  |  Branch (6222:10): [True: 0, False: 8]
  ------------------
 6223|      0|	        xmlFree(defaultValue);
 6224|      8|	    GROW;
  ------------------
  |  | 2270|      8|#define GROW if (ctxt->input->end - ctxt->input->cur < INPUT_CHUNK)	\
  |  |  ------------------
  |  |  |  |   97|      8|#define INPUT_CHUNK	250
  |  |  ------------------
  |  |  |  Branch (2270:18): [True: 8, False: 0]
  |  |  ------------------
  |  | 2271|      8|	xmlParserGrow(ctxt);
  ------------------
 6225|      8|	}
 6226|      8|	if (RAW == '>') {
  ------------------
  |  | 2221|      8|#define RAW (*ctxt->input->cur)
  ------------------
  |  Branch (6226:6): [True: 8, False: 0]
  ------------------
 6227|      8|	    if (inputid != ctxt->input->id) {
  ------------------
  |  Branch (6227:10): [True: 0, False: 8]
  ------------------
 6228|      0|		xmlFatalErrMsg(ctxt, XML_ERR_ENTITY_BOUNDARY,
 6229|      0|                               "Attribute list declaration doesn't start and"
 6230|      0|                               " stop in the same entity\n");
 6231|      0|	    }
 6232|      8|	    NEXT;
  ------------------
  |  | 2275|      8|#define NEXT xmlNextChar(ctxt)
  ------------------
 6233|      8|	}
 6234|      8|    }
 6235|      8|}
xmlParseElementContentDecl:
 6711|     14|                           xmlElementContentPtr *result) {
 6712|       |
 6713|     14|    xmlElementContentPtr tree = NULL;
 6714|     14|    int inputid = ctxt->input->id;
 6715|     14|    int res;
 6716|       |
 6717|     14|    *result = NULL;
 6718|       |
 6719|     14|    if (RAW != '(') {
  ------------------
  |  | 2221|     14|#define RAW (*ctxt->input->cur)
  ------------------
  |  Branch (6719:9): [True: 0, False: 14]
  ------------------
 6720|      0|	xmlFatalErrMsgStr(ctxt, XML_ERR_ELEMCONTENT_NOT_STARTED,
 6721|      0|		"xmlParseElementContentDecl : %s '(' expected\n", name);
 6722|      0|	return(-1);
 6723|      0|    }
 6724|     14|    NEXT;
  ------------------
  |  | 2275|     14|#define NEXT xmlNextChar(ctxt)
  ------------------
 6725|     14|    GROW;
  ------------------
  |  | 2270|     14|#define GROW if (ctxt->input->end - ctxt->input->cur < INPUT_CHUNK)	\
  |  |  ------------------
  |  |  |  |   97|     14|#define INPUT_CHUNK	250
  |  |  ------------------
  |  |  |  Branch (2270:18): [True: 10, False: 4]
  |  |  ------------------
  |  | 2271|     14|	xmlParserGrow(ctxt);
  ------------------
 6726|     14|    if (ctxt->instate == XML_PARSER_EOF)
  ------------------
  |  Branch (6726:9): [True: 0, False: 14]
  ------------------
 6727|      0|        return(-1);
 6728|     14|    SKIP_BLANKS;
  ------------------
  |  | 2273|     14|#define SKIP_BLANKS xmlSkipBlankChars(ctxt)
  ------------------
 6729|     14|    if (CMP7(CUR_PTR, '#', 'P', 'C', 'D', 'A', 'T', 'A')) {
  ------------------
  |  | 2235|     14|  ( CMP6( s, c1, c2, c3, c4, c5, c6 ) && ((unsigned char *) s)[ 6 ] == c7 )
  |  |  ------------------
  |  |  |  | 2233|     28|  ( CMP5( s, c1, c2, c3, c4, c5 ) && ((unsigned char *) s)[ 5 ] == c6 )
  |  |  |  |  ------------------
  |  |  |  |  |  | 2231|     28|  ( CMP4( s, c1, c2, c3, c4 ) && ((unsigned char *) s)[ 4 ] == c5 )
  |  |  |  |  |  |  ------------------
  |  |  |  |  |  |  |  | 2228|     28|  ( ((unsigned char *) s)[ 0 ] == c1 && ((unsigned char *) s)[ 1 ] == c2 && \
  |  |  |  |  |  |  |  |  ------------------
  |  |  |  |  |  |  |  |  |  Branch (2228:5): [True: 0, False: 14]
  |  |  |  |  |  |  |  |  |  Branch (2228:41): [True: 0, False: 0]
  |  |  |  |  |  |  |  |  ------------------
  |  |  |  |  |  |  |  | 2229|     14|    ((unsigned char *) s)[ 2 ] == c3 && ((unsigned char *) s)[ 3 ] == c4 )
  |  |  |  |  |  |  |  |  ------------------
  |  |  |  |  |  |  |  |  |  Branch (2229:5): [True: 0, False: 0]
  |  |  |  |  |  |  |  |  |  Branch (2229:41): [True: 0, False: 0]
  |  |  |  |  |  |  |  |  ------------------
  |  |  |  |  |  |  ------------------
  |  |  |  |  |  |  |  Branch (2231:34): [True: 0, False: 0]
  |  |  |  |  |  |  ------------------
  |  |  |  |  ------------------
  |  |  |  |  |  Branch (2233:38): [True: 0, False: 0]
  |  |  |  |  ------------------
  |  |  ------------------
  |  |  |  Branch (2235:42): [True: 0, False: 0]
  |  |  ------------------
  ------------------
 6730|      0|        tree = xmlParseElementMixedContentDecl(ctxt, inputid);
 6731|      0|	res = XML_ELEMENT_TYPE_MIXED;
 6732|     14|    } else {
 6733|     14|        tree = xmlParseElementChildrenContentDeclPriv(ctxt, inputid, 1);
 6734|     14|	res = XML_ELEMENT_TYPE_ELEMENT;
 6735|     14|    }
 6736|     14|    SKIP_BLANKS;
  ------------------
  |  | 2273|     14|#define SKIP_BLANKS xmlSkipBlankChars(ctxt)
  ------------------
 6737|     14|    *result = tree;
 6738|     14|    return(res);
 6739|     14|}
xmlParseElementDecl:
 6757|     22|xmlParseElementDecl(xmlParserCtxtPtr ctxt) {
 6758|     22|    const xmlChar *name;
 6759|     22|    int ret = -1;
 6760|     22|    xmlElementContentPtr content  = NULL;
 6761|       |
 6762|     22|    if ((CUR != '<') || (NXT(1) != '!'))
  ------------------
  |  | 2222|     22|#define CUR (*ctxt->input->cur)
  ------------------
                  if ((CUR != '<') || (NXT(1) != '!'))
  ------------------
  |  | 2223|     22|#define NXT(val) ctxt->input->cur[(val)]
  ------------------
  |  Branch (6762:9): [True: 0, False: 22]
  |  Branch (6762:25): [True: 0, False: 22]
  ------------------
 6763|      0|        return(ret);
 6764|     22|    SKIP(2);
  ------------------
  |  | 2245|     22|#define SKIP(val) do {							\
  |  | 2246|     22|    ctxt->input->cur += (val),ctxt->input->col+=(val);			\
  |  | 2247|     22|    if (*ctxt->input->cur == 0)						\
  |  |  ------------------
  |  |  |  Branch (2247:9): [True: 0, False: 22]
  |  |  ------------------
  |  | 2248|     22|        xmlParserGrow(ctxt);						\
  |  | 2249|     22|  } while (0)
  |  |  ------------------
  |  |  |  Branch (2249:12): [Folded - Ignored]
  |  |  ------------------
  ------------------
 6765|       |
 6766|       |    /* GROW; done in the caller */
 6767|     22|    if (CMP7(CUR_PTR, 'E', 'L', 'E', 'M', 'E', 'N', 'T')) {
  ------------------
  |  | 2235|     22|  ( CMP6( s, c1, c2, c3, c4, c5, c6 ) && ((unsigned char *) s)[ 6 ] == c7 )
  |  |  ------------------
  |  |  |  | 2233|     44|  ( CMP5( s, c1, c2, c3, c4, c5 ) && ((unsigned char *) s)[ 5 ] == c6 )
  |  |  |  |  ------------------
  |  |  |  |  |  | 2231|     44|  ( CMP4( s, c1, c2, c3, c4 ) && ((unsigned char *) s)[ 4 ] == c5 )
  |  |  |  |  |  |  ------------------
  |  |  |  |  |  |  |  | 2228|     44|  ( ((unsigned char *) s)[ 0 ] == c1 && ((unsigned char *) s)[ 1 ] == c2 && \
  |  |  |  |  |  |  |  |  ------------------
  |  |  |  |  |  |  |  |  |  Branch (2228:5): [True: 22, False: 0]
  |  |  |  |  |  |  |  |  |  Branch (2228:41): [True: 22, False: 0]
  |  |  |  |  |  |  |  |  ------------------
  |  |  |  |  |  |  |  | 2229|     22|    ((unsigned char *) s)[ 2 ] == c3 && ((unsigned char *) s)[ 3 ] == c4 )
  |  |  |  |  |  |  |  |  ------------------
  |  |  |  |  |  |  |  |  |  Branch (2229:5): [True: 22, False: 0]
  |  |  |  |  |  |  |  |  |  Branch (2229:41): [True: 22, False: 0]
  |  |  |  |  |  |  |  |  ------------------
  |  |  |  |  |  |  ------------------
  |  |  |  |  |  |  |  Branch (2231:34): [True: 22, False: 0]
  |  |  |  |  |  |  ------------------
  |  |  |  |  ------------------
  |  |  |  |  |  Branch (2233:38): [True: 22, False: 0]
  |  |  |  |  ------------------
  |  |  ------------------
  |  |  |  Branch (2235:42): [True: 22, False: 0]
  |  |  ------------------
  ------------------
 6768|     22|	int inputid = ctxt->input->id;
 6769|       |
 6770|     22|	SKIP(7);
  ------------------
  |  | 2245|     22|#define SKIP(val) do {							\
  |  | 2246|     22|    ctxt->input->cur += (val),ctxt->input->col+=(val);			\
  |  | 2247|     22|    if (*ctxt->input->cur == 0)						\
  |  |  ------------------
  |  |  |  Branch (2247:9): [True: 0, False: 22]
  |  |  ------------------
  |  | 2248|     22|        xmlParserGrow(ctxt);						\
  |  | 2249|     22|  } while (0)
  |  |  ------------------
  |  |  |  Branch (2249:12): [Folded - Ignored]
  |  |  ------------------
  ------------------
 6771|     22|	if (SKIP_BLANKS == 0) {
  ------------------
  |  | 2273|     22|#define SKIP_BLANKS xmlSkipBlankChars(ctxt)
  ------------------
  |  Branch (6771:6): [True: 0, False: 22]
  ------------------
 6772|      0|	    xmlFatalErrMsg(ctxt, XML_ERR_SPACE_REQUIRED,
 6773|      0|		           "Space required after 'ELEMENT'\n");
 6774|      0|	    return(-1);
 6775|      0|	}
 6776|     22|        name = xmlParseName(ctxt);
 6777|     22|	if (name == NULL) {
  ------------------
  |  Branch (6777:6): [True: 0, False: 22]
  ------------------
 6778|      0|	    xmlFatalErrMsg(ctxt, XML_ERR_NAME_REQUIRED,
 6779|      0|			   "xmlParseElementDecl: no name for Element\n");
 6780|      0|	    return(-1);
 6781|      0|	}
 6782|     22|	if (SKIP_BLANKS == 0) {
  ------------------
  |  | 2273|     22|#define SKIP_BLANKS xmlSkipBlankChars(ctxt)
  ------------------
  |  Branch (6782:6): [True: 0, False: 22]
  ------------------
 6783|      0|	    xmlFatalErrMsg(ctxt, XML_ERR_SPACE_REQUIRED,
 6784|      0|			   "Space required after the element name\n");
 6785|      0|	}
 6786|     22|	if (CMP5(CUR_PTR, 'E', 'M', 'P', 'T', 'Y')) {
  ------------------
  |  | 2231|     22|  ( CMP4( s, c1, c2, c3, c4 ) && ((unsigned char *) s)[ 4 ] == c5 )
  |  |  ------------------
  |  |  |  | 2228|     44|  ( ((unsigned char *) s)[ 0 ] == c1 && ((unsigned char *) s)[ 1 ] == c2 && \
  |  |  |  |  ------------------
  |  |  |  |  |  Branch (2228:5): [True: 8, False: 14]
  |  |  |  |  |  Branch (2228:41): [True: 8, False: 0]
  |  |  |  |  ------------------
  |  |  |  | 2229|     22|    ((unsigned char *) s)[ 2 ] == c3 && ((unsigned char *) s)[ 3 ] == c4 )
  |  |  |  |  ------------------
  |  |  |  |  |  Branch (2229:5): [True: 8, False: 0]
  |  |  |  |  |  Branch (2229:41): [True: 8, False: 0]
  |  |  |  |  ------------------
  |  |  ------------------
  |  |  |  Branch (2231:34): [True: 8, False: 0]
  |  |  ------------------
  ------------------
 6787|      8|	    SKIP(5);
  ------------------
  |  | 2245|      8|#define SKIP(val) do {							\
  |  | 2246|      8|    ctxt->input->cur += (val),ctxt->input->col+=(val);			\
  |  | 2247|      8|    if (*ctxt->input->cur == 0)						\
  |  |  ------------------
  |  |  |  Branch (2247:9): [True: 0, False: 8]
  |  |  ------------------
  |  | 2248|      8|        xmlParserGrow(ctxt);						\
  |  | 2249|      8|  } while (0)
  |  |  ------------------
  |  |  |  Branch (2249:12): [Folded - Ignored]
  |  |  ------------------
  ------------------
 6788|       |	    /*
 6789|       |	     * Element must always be empty.
 6790|       |	     */
 6791|      8|	    ret = XML_ELEMENT_TYPE_EMPTY;
 6792|     14|	} else if ((RAW == 'A') && (NXT(1) == 'N') &&
  ------------------
  |  | 2221|     14|#define RAW (*ctxt->input->cur)
  ------------------
              	} else if ((RAW == 'A') && (NXT(1) == 'N') &&
  ------------------
  |  | 2223|      0|#define NXT(val) ctxt->input->cur[(val)]
  ------------------
  |  Branch (6792:13): [True: 0, False: 14]
  |  Branch (6792:29): [True: 0, False: 0]
  ------------------
 6793|     14|	           (NXT(2) == 'Y')) {
  ------------------
  |  | 2223|      0|#define NXT(val) ctxt->input->cur[(val)]
  ------------------
  |  Branch (6793:13): [True: 0, False: 0]
  ------------------
 6794|      0|	    SKIP(3);
  ------------------
  |  | 2245|      0|#define SKIP(val) do {							\
  |  | 2246|      0|    ctxt->input->cur += (val),ctxt->input->col+=(val);			\
  |  | 2247|      0|    if (*ctxt->input->cur == 0)						\
  |  |  ------------------
  |  |  |  Branch (2247:9): [True: 0, False: 0]
  |  |  ------------------
  |  | 2248|      0|        xmlParserGrow(ctxt);						\
  |  | 2249|      0|  } while (0)
  |  |  ------------------
  |  |  |  Branch (2249:12): [Folded - Ignored]
  |  |  ------------------
  ------------------
 6795|       |	    /*
 6796|       |	     * Element is a generic container.
 6797|       |	     */
 6798|      0|	    ret = XML_ELEMENT_TYPE_ANY;
 6799|     14|	} else if (RAW == '(') {
  ------------------
  |  | 2221|     14|#define RAW (*ctxt->input->cur)
  ------------------
  |  Branch (6799:13): [True: 14, False: 0]
  ------------------
 6800|     14|	    ret = xmlParseElementContentDecl(ctxt, name, &content);
 6801|     14|	} else {
 6802|       |	    /*
 6803|       |	     * [ WFC: PEs in Internal Subset ] error handling.
 6804|       |	     */
 6805|      0|	    if ((RAW == '%') && (ctxt->external == 0) &&
  ------------------
  |  | 2221|      0|#define RAW (*ctxt->input->cur)
  ------------------
  |  Branch (6805:10): [True: 0, False: 0]
  |  Branch (6805:26): [True: 0, False: 0]
  ------------------
 6806|      0|	        (ctxt->inputNr == 1)) {
  ------------------
  |  Branch (6806:10): [True: 0, False: 0]
  ------------------
 6807|      0|		xmlFatalErrMsg(ctxt, XML_ERR_PEREF_IN_INT_SUBSET,
 6808|      0|	  "PEReference: forbidden within markup decl in internal subset\n");
 6809|      0|	    } else {
 6810|      0|		xmlFatalErrMsg(ctxt, XML_ERR_ELEMCONTENT_NOT_STARTED,
 6811|      0|		      "xmlParseElementDecl: 'EMPTY', 'ANY' or '(' expected\n");
 6812|      0|            }
 6813|      0|	    return(-1);
 6814|      0|	}
 6815|       |
 6816|     22|	SKIP_BLANKS;
  ------------------
  |  | 2273|     22|#define SKIP_BLANKS xmlSkipBlankChars(ctxt)
  ------------------
 6817|       |
 6818|     22|	if (RAW != '>') {
  ------------------
  |  | 2221|     22|#define RAW (*ctxt->input->cur)
  ------------------
  |  Branch (6818:6): [True: 0, False: 22]
  ------------------
 6819|      0|	    xmlFatalErr(ctxt, XML_ERR_GT_REQUIRED, NULL);
 6820|      0|	    if (content != NULL) {
  ------------------
  |  Branch (6820:10): [True: 0, False: 0]
  ------------------
 6821|      0|		xmlFreeDocElementContent(ctxt->myDoc, content);
 6822|      0|	    }
 6823|     22|	} else {
 6824|     22|	    if (inputid != ctxt->input->id) {
  ------------------
  |  Branch (6824:10): [True: 0, False: 22]
  ------------------
 6825|      0|		xmlFatalErrMsg(ctxt, XML_ERR_ENTITY_BOUNDARY,
 6826|      0|                               "Element declaration doesn't start and stop in"
 6827|      0|                               " the same entity\n");
 6828|      0|	    }
 6829|       |
 6830|     22|	    NEXT;
  ------------------
  |  | 2275|     22|#define NEXT xmlNextChar(ctxt)
  ------------------
 6831|     22|	    if ((ctxt->sax != NULL) && (!ctxt->disableSAX) &&
  ------------------
  |  Branch (6831:10): [True: 22, False: 0]
  |  Branch (6831:33): [True: 22, False: 0]
  ------------------
 6832|     22|		(ctxt->sax->elementDecl != NULL)) {
  ------------------
  |  Branch (6832:3): [True: 22, False: 0]
  ------------------
 6833|     22|		if (content != NULL)
  ------------------
  |  Branch (6833:7): [True: 14, False: 8]
  ------------------
 6834|     14|		    content->parent = NULL;
 6835|     22|	        ctxt->sax->elementDecl(ctxt->userData, name, ret,
 6836|     22|		                       content);
 6837|     22|		if ((content != NULL) && (content->parent == NULL)) {
  ------------------
  |  Branch (6837:7): [True: 14, False: 8]
  |  Branch (6837:28): [True: 0, False: 14]
  ------------------
 6838|       |		    /*
 6839|       |		     * this is a trick: if xmlAddElementDecl is called,
 6840|       |		     * instead of copying the full tree it is plugged directly
 6841|       |		     * if called from the parser. Avoid duplicating the
 6842|       |		     * interfaces or change the API/ABI
 6843|       |		     */
 6844|      0|		    xmlFreeDocElementContent(ctxt->myDoc, content);
 6845|      0|		}
 6846|     22|	    } else if (content != NULL) {
  ------------------
  |  Branch (6846:17): [True: 0, False: 0]
  ------------------
 6847|      0|		xmlFreeDocElementContent(ctxt->myDoc, content);
 6848|      0|	    }
 6849|     22|	}
 6850|     22|    }
 6851|     22|    return(ret);
 6852|     22|}
xmlParseMarkupDecl:
 7015|     30|xmlParseMarkupDecl(xmlParserCtxtPtr ctxt) {
 7016|     30|    GROW;
  ------------------
  |  | 2270|     30|#define GROW if (ctxt->input->end - ctxt->input->cur < INPUT_CHUNK)	\
  |  |  ------------------
  |  |  |  |   97|     30|#define INPUT_CHUNK	250
  |  |  ------------------
  |  |  |  Branch (2270:18): [True: 24, False: 6]
  |  |  ------------------
  |  | 2271|     30|	xmlParserGrow(ctxt);
  ------------------
 7017|     30|    if (CUR == '<') {
  ------------------
  |  | 2222|     30|#define CUR (*ctxt->input->cur)
  ------------------
  |  Branch (7017:9): [True: 30, False: 0]
  ------------------
 7018|     30|        if (NXT(1) == '!') {
  ------------------
  |  | 2223|     30|#define NXT(val) ctxt->input->cur[(val)]
  ------------------
  |  Branch (7018:13): [True: 30, False: 0]
  ------------------
 7019|     30|	    switch (NXT(2)) {
  ------------------
  |  | 2223|     30|#define NXT(val) ctxt->input->cur[(val)]
  ------------------
 7020|     22|	        case 'E':
  ------------------
  |  Branch (7020:10): [True: 22, False: 8]
  ------------------
 7021|     22|		    if (NXT(3) == 'L')
  ------------------
  |  | 2223|     22|#define NXT(val) ctxt->input->cur[(val)]
  ------------------
  |  Branch (7021:11): [True: 22, False: 0]
  ------------------
 7022|     22|			xmlParseElementDecl(ctxt);
 7023|      0|		    else if (NXT(3) == 'N')
  ------------------
  |  | 2223|      0|#define NXT(val) ctxt->input->cur[(val)]
  ------------------
  |  Branch (7023:16): [True: 0, False: 0]
  ------------------
 7024|      0|			xmlParseEntityDecl(ctxt);
 7025|      0|                    else
 7026|      0|                        SKIP(2);
  ------------------
  |  | 2245|      0|#define SKIP(val) do {							\
  |  | 2246|      0|    ctxt->input->cur += (val),ctxt->input->col+=(val);			\
  |  | 2247|      0|    if (*ctxt->input->cur == 0)						\
  |  |  ------------------
  |  |  |  Branch (2247:9): [True: 0, False: 0]
  |  |  ------------------
  |  | 2248|      0|        xmlParserGrow(ctxt);						\
  |  | 2249|      0|  } while (0)
  |  |  ------------------
  |  |  |  Branch (2249:12): [Folded - Ignored]
  |  |  ------------------
  ------------------
 7027|     22|		    break;
 7028|      8|	        case 'A':
  ------------------
  |  Branch (7028:10): [True: 8, False: 22]
  ------------------
 7029|      8|		    xmlParseAttributeListDecl(ctxt);
 7030|      8|		    break;
 7031|      0|	        case 'N':
  ------------------
  |  Branch (7031:10): [True: 0, False: 30]
  ------------------
 7032|      0|		    xmlParseNotationDecl(ctxt);
 7033|      0|		    break;
 7034|      0|	        case '-':
  ------------------
  |  Branch (7034:10): [True: 0, False: 30]
  ------------------
 7035|      0|		    xmlParseComment(ctxt);
 7036|      0|		    break;
 7037|      0|		default:
  ------------------
  |  Branch (7037:3): [True: 0, False: 30]
  ------------------
 7038|       |		    /* there is an error but it will be detected later */
 7039|      0|                    SKIP(2);
  ------------------
  |  | 2245|      0|#define SKIP(val) do {							\
  |  | 2246|      0|    ctxt->input->cur += (val),ctxt->input->col+=(val);			\
  |  | 2247|      0|    if (*ctxt->input->cur == 0)						\
  |  |  ------------------
  |  |  |  Branch (2247:9): [True: 0, False: 0]
  |  |  ------------------
  |  | 2248|      0|        xmlParserGrow(ctxt);						\
  |  | 2249|      0|  } while (0)
  |  |  ------------------
  |  |  |  Branch (2249:12): [Folded - Ignored]
  |  |  ------------------
  ------------------
 7040|      0|		    break;
 7041|     30|	    }
 7042|     30|	} else if (NXT(1) == '?') {
  ------------------
  |  | 2223|      0|#define NXT(val) ctxt->input->cur[(val)]
  ------------------
  |  Branch (7042:13): [True: 0, False: 0]
  ------------------
 7043|      0|	    xmlParsePI(ctxt);
 7044|      0|	}
 7045|     30|    }
 7046|       |
 7047|       |    /*
 7048|       |     * detect requirement to exit there and act accordingly
 7049|       |     * and avoid having instate overridden later on
 7050|       |     */
 7051|     30|    if (ctxt->instate == XML_PARSER_EOF)
  ------------------
  |  Branch (7051:9): [True: 0, False: 30]
  ------------------
 7052|      0|        return;
 7053|       |
 7054|     30|    ctxt->instate = XML_PARSER_DTD;
 7055|     30|}
xmlParseReference:
 7222|      2|xmlParseReference(xmlParserCtxtPtr ctxt) {
 7223|      2|    xmlEntityPtr ent;
 7224|      2|    xmlChar *val;
 7225|      2|    int was_checked;
 7226|      2|    xmlNodePtr list = NULL;
 7227|      2|    xmlParserErrors ret = XML_ERR_OK;
 7228|       |
 7229|       |
 7230|      2|    if (RAW != '&')
  ------------------
  |  | 2221|      2|#define RAW (*ctxt->input->cur)
  ------------------
  |  Branch (7230:9): [True: 0, False: 2]
  ------------------
 7231|      0|        return;
 7232|       |
 7233|       |    /*
 7234|       |     * Simple case of a CharRef
 7235|       |     */
 7236|      2|    if (NXT(1) == '#') {
  ------------------
  |  | 2223|      2|#define NXT(val) ctxt->input->cur[(val)]
  ------------------
  |  Branch (7236:9): [True: 0, False: 2]
  ------------------
 7237|      0|	int i = 0;
 7238|      0|	xmlChar out[16];
 7239|      0|	int value = xmlParseCharRef(ctxt);
 7240|       |
 7241|      0|	if (value == 0)
  ------------------
  |  Branch (7241:6): [True: 0, False: 0]
  ------------------
 7242|      0|	    return;
 7243|       |
 7244|       |        /*
 7245|       |         * Just encode the value in UTF-8
 7246|       |         */
 7247|      0|        COPY_BUF(out, i, value);
  ------------------
  |  | 2295|      0|    if (v < 0x80) b[i++] = v;						\
  |  |  ------------------
  |  |  |  Branch (2295:9): [True: 0, False: 0]
  |  |  ------------------
  |  | 2296|      0|    else i += xmlCopyCharMultiByte(&b[i],v)
  ------------------
 7248|      0|        out[i] = 0;
 7249|      0|        if ((ctxt->sax != NULL) && (ctxt->sax->characters != NULL) &&
  ------------------
  |  Branch (7249:13): [True: 0, False: 0]
  |  Branch (7249:36): [True: 0, False: 0]
  ------------------
 7250|      0|            (!ctxt->disableSAX))
  ------------------
  |  Branch (7250:13): [True: 0, False: 0]
  ------------------
 7251|      0|            ctxt->sax->characters(ctxt->userData, out, i);
 7252|      0|	return;
 7253|      0|    }
 7254|       |
 7255|       |    /*
 7256|       |     * We are seeing an entity reference
 7257|       |     */
 7258|      2|    ent = xmlParseEntityRef(ctxt);
 7259|      2|    if (ent == NULL) return;
  ------------------
  |  Branch (7259:9): [True: 2, False: 0]
  ------------------
 7260|      0|    if (!ctxt->wellFormed)
  ------------------
  |  Branch (7260:9): [True: 0, False: 0]
  ------------------
 7261|      0|	return;
 7262|      0|    was_checked = ent->flags & XML_ENT_PARSED;
  ------------------
  |  |   14|      0|#define XML_ENT_PARSED      (1<<0)
  ------------------
 7263|       |
 7264|       |    /* special case of predefined entities */
 7265|      0|    if ((ent->name == NULL) ||
  ------------------
  |  Branch (7265:9): [True: 0, False: 0]
  ------------------
 7266|      0|        (ent->etype == XML_INTERNAL_PREDEFINED_ENTITY)) {
  ------------------
  |  Branch (7266:9): [True: 0, False: 0]
  ------------------
 7267|      0|	val = ent->content;
 7268|      0|	if (val == NULL) return;
  ------------------
  |  Branch (7268:6): [True: 0, False: 0]
  ------------------
 7269|       |	/*
 7270|       |	 * inline the entity.
 7271|       |	 */
 7272|      0|	if ((ctxt->sax != NULL) && (ctxt->sax->characters != NULL) &&
  ------------------
  |  Branch (7272:6): [True: 0, False: 0]
  |  Branch (7272:29): [True: 0, False: 0]
  ------------------
 7273|      0|	    (!ctxt->disableSAX))
  ------------------
  |  Branch (7273:6): [True: 0, False: 0]
  ------------------
 7274|      0|	    ctxt->sax->characters(ctxt->userData, val, xmlStrlen(val));
 7275|      0|	return;
 7276|      0|    }
 7277|       |
 7278|       |    /*
 7279|       |     * The first reference to the entity trigger a parsing phase
 7280|       |     * where the ent->children is filled with the result from
 7281|       |     * the parsing.
 7282|       |     * Note: external parsed entities will not be loaded, it is not
 7283|       |     * required for a non-validating parser, unless the parsing option
 7284|       |     * of validating, or substituting entities were given. Doing so is
 7285|       |     * far more secure as the parser will only process data coming from
 7286|       |     * the document entity by default.
 7287|       |     *
 7288|       |     * FIXME: This doesn't work correctly since entities can be
 7289|       |     * expanded with different namespace declarations in scope.
 7290|       |     * For example:
 7291|       |     *
 7292|       |     * <!DOCTYPE doc [
 7293|       |     *   <!ENTITY ent "<ns:elem/>">
 7294|       |     * ]>
 7295|       |     * <doc>
 7296|       |     *   <decl1 xmlns:ns="urn:ns1">
 7297|       |     *     &ent;
 7298|       |     *   </decl1>
 7299|       |     *   <decl2 xmlns:ns="urn:ns2">
 7300|       |     *     &ent;
 7301|       |     *   </decl2>
 7302|       |     * </doc>
 7303|       |     *
 7304|       |     * Proposed fix:
 7305|       |     *
 7306|       |     * - Remove the ent->owner optimization which tries to avoid the
 7307|       |     *   initial copy of the entity. Always make entities own the
 7308|       |     *   subtree.
 7309|       |     * - Ignore current namespace declarations when parsing the
 7310|       |     *   entity. If a prefix can't be resolved, don't report an error
 7311|       |     *   but mark it as unresolved.
 7312|       |     * - Try to resolve these prefixes when expanding the entity.
 7313|       |     *   This will require a specialized version of xmlStaticCopyNode
 7314|       |     *   which can also make use of the namespace hash table to avoid
 7315|       |     *   quadratic behavior.
 7316|       |     *
 7317|       |     * Alternatively, we could simply reparse the entity on each
 7318|       |     * expansion like we already do with custom SAX callbacks.
 7319|       |     * External entity content should be cached in this case.
 7320|       |     */
 7321|      0|    if (((ent->flags & XML_ENT_PARSED) == 0) &&
  ------------------
  |  |   14|      0|#define XML_ENT_PARSED      (1<<0)
  ------------------
  |  Branch (7321:9): [True: 0, False: 0]
  ------------------
 7322|      0|        ((ent->etype != XML_EXTERNAL_GENERAL_PARSED_ENTITY) ||
  ------------------
  |  Branch (7322:10): [True: 0, False: 0]
  ------------------
 7323|      0|         (ctxt->options & (XML_PARSE_NOENT | XML_PARSE_DTDVALID)))) {
  ------------------
  |  Branch (7323:10): [True: 0, False: 0]
  ------------------
 7324|      0|	unsigned long oldsizeentcopy = ctxt->sizeentcopy;
 7325|       |
 7326|       |	/*
 7327|       |	 * This is a bit hackish but this seems the best
 7328|       |	 * way to make sure both SAX and DOM entity support
 7329|       |	 * behaves okay.
 7330|       |	 */
 7331|      0|	void *user_data;
 7332|      0|	if (ctxt->userData == ctxt)
  ------------------
  |  Branch (7332:6): [True: 0, False: 0]
  ------------------
 7333|      0|	    user_data = NULL;
 7334|      0|	else
 7335|      0|	    user_data = ctxt->userData;
 7336|       |
 7337|       |        /* Avoid overflow as much as possible */
 7338|      0|        ctxt->sizeentcopy = 0;
 7339|       |
 7340|      0|        if (ent->flags & XML_ENT_EXPANDING) {
  ------------------
  |  |   16|      0|#define XML_ENT_EXPANDING   (1<<2)
  ------------------
  |  Branch (7340:13): [True: 0, False: 0]
  ------------------
 7341|      0|            xmlFatalErr(ctxt, XML_ERR_ENTITY_LOOP, NULL);
 7342|      0|            xmlHaltParser(ctxt);
 7343|      0|            return;
 7344|      0|        }
 7345|       |
 7346|      0|        ent->flags |= XML_ENT_EXPANDING;
  ------------------
  |  |   16|      0|#define XML_ENT_EXPANDING   (1<<2)
  ------------------
 7347|       |
 7348|       |	/*
 7349|       |	 * Check that this entity is well formed
 7350|       |	 * 4.3.2: An internal general parsed entity is well-formed
 7351|       |	 * if its replacement text matches the production labeled
 7352|       |	 * content.
 7353|       |	 */
 7354|      0|	if (ent->etype == XML_INTERNAL_GENERAL_ENTITY) {
  ------------------
  |  Branch (7354:6): [True: 0, False: 0]
  ------------------
 7355|      0|	    ctxt->depth++;
 7356|      0|	    ret = xmlParseBalancedChunkMemoryInternal(ctxt, ent->content,
 7357|      0|	                                              user_data, &list);
 7358|      0|	    ctxt->depth--;
 7359|       |
 7360|      0|	} else if (ent->etype == XML_EXTERNAL_GENERAL_PARSED_ENTITY) {
  ------------------
  |  Branch (7360:13): [True: 0, False: 0]
  ------------------
 7361|      0|	    ctxt->depth++;
 7362|      0|	    ret = xmlParseExternalEntityPrivate(ctxt->myDoc, ctxt, ctxt->sax,
 7363|      0|	                                   user_data, ctxt->depth, ent->URI,
 7364|      0|					   ent->ExternalID, &list);
 7365|      0|	    ctxt->depth--;
 7366|      0|	} else {
 7367|      0|	    ret = XML_ERR_ENTITY_PE_INTERNAL;
 7368|      0|	    xmlErrMsgStr(ctxt, XML_ERR_INTERNAL_ERROR,
 7369|      0|			 "invalid entity type found\n", NULL);
 7370|      0|	}
 7371|       |
 7372|      0|        ent->flags &= ~XML_ENT_EXPANDING;
  ------------------
  |  |   16|      0|#define XML_ENT_EXPANDING   (1<<2)
  ------------------
 7373|      0|        ent->flags |= XML_ENT_PARSED | XML_ENT_CHECKED;
  ------------------
  |  |   14|      0|#define XML_ENT_PARSED      (1<<0)
  ------------------
                      ent->flags |= XML_ENT_PARSED | XML_ENT_CHECKED;
  ------------------
  |  |   15|      0|#define XML_ENT_CHECKED     (1<<1)
  ------------------
 7374|      0|        ent->expandedSize = ctxt->sizeentcopy;
 7375|      0|	if (ret == XML_ERR_ENTITY_LOOP) {
  ------------------
  |  Branch (7375:6): [True: 0, False: 0]
  ------------------
 7376|      0|            xmlHaltParser(ctxt);
 7377|      0|	    xmlFreeNodeList(list);
 7378|      0|	    return;
 7379|      0|	}
 7380|      0|	if (xmlParserEntityCheck(ctxt, oldsizeentcopy)) {
  ------------------
  |  Branch (7380:6): [True: 0, False: 0]
  ------------------
 7381|      0|	    xmlFreeNodeList(list);
 7382|      0|	    return;
 7383|      0|	}
 7384|       |
 7385|      0|	if ((ret == XML_ERR_OK) && (list != NULL)) {
  ------------------
  |  Branch (7385:6): [True: 0, False: 0]
  |  Branch (7385:29): [True: 0, False: 0]
  ------------------
 7386|      0|            ent->children = list;
 7387|       |            /*
 7388|       |             * Prune it directly in the generated document
 7389|       |             * except for single text nodes.
 7390|       |             */
 7391|      0|            if ((ctxt->replaceEntities == 0) ||
  ------------------
  |  Branch (7391:17): [True: 0, False: 0]
  ------------------
 7392|      0|                (ctxt->parseMode == XML_PARSE_READER) ||
  ------------------
  |  Branch (7392:17): [True: 0, False: 0]
  ------------------
 7393|      0|                ((list->type == XML_TEXT_NODE) &&
  ------------------
  |  Branch (7393:18): [True: 0, False: 0]
  ------------------
 7394|      0|                 (list->next == NULL))) {
  ------------------
  |  Branch (7394:18): [True: 0, False: 0]
  ------------------
 7395|      0|                ent->owner = 1;
 7396|      0|                while (list != NULL) {
  ------------------
  |  Branch (7396:24): [True: 0, False: 0]
  ------------------
 7397|      0|                    list->parent = (xmlNodePtr) ent;
 7398|      0|                    if (list->doc != ent->doc)
  ------------------
  |  Branch (7398:25): [True: 0, False: 0]
  ------------------
 7399|      0|                        xmlSetTreeDoc(list, ent->doc);
 7400|      0|                    if (list->next == NULL)
  ------------------
  |  Branch (7400:25): [True: 0, False: 0]
  ------------------
 7401|      0|                        ent->last = list;
 7402|      0|                    list = list->next;
 7403|      0|                }
 7404|      0|                list = NULL;
 7405|      0|            } else {
 7406|      0|                ent->owner = 0;
 7407|      0|                while (list != NULL) {
  ------------------
  |  Branch (7407:24): [True: 0, False: 0]
  ------------------
 7408|      0|                    list->parent = (xmlNodePtr) ctxt->node;
 7409|      0|                    list->doc = ctxt->myDoc;
 7410|      0|                    if (list->next == NULL)
  ------------------
  |  Branch (7410:25): [True: 0, False: 0]
  ------------------
 7411|      0|                        ent->last = list;
 7412|      0|                    list = list->next;
 7413|      0|                }
 7414|      0|                list = ent->children;
 7415|       |#ifdef LIBXML_LEGACY_ENABLED
 7416|       |                if (ent->etype == XML_EXTERNAL_GENERAL_PARSED_ENTITY)
 7417|       |                    xmlAddEntityReference(ent, list, NULL);
 7418|       |#endif /* LIBXML_LEGACY_ENABLED */
 7419|      0|            }
 7420|      0|	} else if ((ret != XML_ERR_OK) &&
  ------------------
  |  Branch (7420:13): [True: 0, False: 0]
  ------------------
 7421|      0|		   (ret != XML_WAR_UNDECLARED_ENTITY)) {
  ------------------
  |  Branch (7421:6): [True: 0, False: 0]
  ------------------
 7422|      0|	    xmlFatalErrMsgStr(ctxt, XML_ERR_UNDECLARED_ENTITY,
 7423|      0|		     "Entity '%s' failed to parse\n", ent->name);
 7424|      0|            if (ent->content != NULL)
  ------------------
  |  Branch (7424:17): [True: 0, False: 0]
  ------------------
 7425|      0|                ent->content[0] = 0;
 7426|      0|	} else if (list != NULL) {
  ------------------
  |  Branch (7426:13): [True: 0, False: 0]
  ------------------
 7427|      0|	    xmlFreeNodeList(list);
 7428|      0|	    list = NULL;
 7429|      0|	}
 7430|       |
 7431|       |        /* Prevent entity from being parsed and expanded twice (Bug 760367). */
 7432|      0|        was_checked = 0;
 7433|      0|    }
 7434|       |
 7435|       |    /*
 7436|       |     * Now that the entity content has been gathered
 7437|       |     * provide it to the application, this can take different forms based
 7438|       |     * on the parsing modes.
 7439|       |     */
 7440|      0|    if (ent->children == NULL) {
  ------------------
  |  Branch (7440:9): [True: 0, False: 0]
  ------------------
 7441|       |	/*
 7442|       |	 * Probably running in SAX mode and the callbacks don't
 7443|       |	 * build the entity content. So unless we already went
 7444|       |	 * though parsing for first checking go though the entity
 7445|       |	 * content to generate callbacks associated to the entity
 7446|       |	 */
 7447|      0|	if (was_checked != 0) {
  ------------------
  |  Branch (7447:6): [True: 0, False: 0]
  ------------------
 7448|      0|	    void *user_data;
 7449|       |	    /*
 7450|       |	     * This is a bit hackish but this seems the best
 7451|       |	     * way to make sure both SAX and DOM entity support
 7452|       |	     * behaves okay.
 7453|       |	     */
 7454|      0|	    if (ctxt->userData == ctxt)
  ------------------
  |  Branch (7454:10): [True: 0, False: 0]
  ------------------
 7455|      0|		user_data = NULL;
 7456|      0|	    else
 7457|      0|		user_data = ctxt->userData;
 7458|       |
 7459|      0|	    if (ent->etype == XML_INTERNAL_GENERAL_ENTITY) {
  ------------------
  |  Branch (7459:10): [True: 0, False: 0]
  ------------------
 7460|      0|		ctxt->depth++;
 7461|      0|		ret = xmlParseBalancedChunkMemoryInternal(ctxt,
 7462|      0|				   ent->content, user_data, NULL);
 7463|      0|		ctxt->depth--;
 7464|      0|	    } else if (ent->etype ==
  ------------------
  |  Branch (7464:17): [True: 0, False: 0]
  ------------------
 7465|      0|		       XML_EXTERNAL_GENERAL_PARSED_ENTITY) {
 7466|      0|	        unsigned long oldsizeentities = ctxt->sizeentities;
 7467|       |
 7468|      0|		ctxt->depth++;
 7469|      0|		ret = xmlParseExternalEntityPrivate(ctxt->myDoc, ctxt,
 7470|      0|			   ctxt->sax, user_data, ctxt->depth,
 7471|      0|			   ent->URI, ent->ExternalID, NULL);
 7472|      0|		ctxt->depth--;
 7473|       |
 7474|       |                /* Undo the change to sizeentities */
 7475|      0|                ctxt->sizeentities = oldsizeentities;
 7476|      0|	    } else {
 7477|      0|		ret = XML_ERR_ENTITY_PE_INTERNAL;
 7478|      0|		xmlErrMsgStr(ctxt, XML_ERR_INTERNAL_ERROR,
 7479|      0|			     "invalid entity type found\n", NULL);
 7480|      0|	    }
 7481|      0|	    if (ret == XML_ERR_ENTITY_LOOP) {
  ------------------
  |  Branch (7481:10): [True: 0, False: 0]
  ------------------
 7482|      0|		xmlFatalErr(ctxt, XML_ERR_ENTITY_LOOP, NULL);
 7483|      0|		return;
 7484|      0|	    }
 7485|      0|            if (xmlParserEntityCheck(ctxt, 0))
  ------------------
  |  Branch (7485:17): [True: 0, False: 0]
  ------------------
 7486|      0|                return;
 7487|      0|	}
 7488|      0|	if ((ctxt->sax != NULL) && (ctxt->sax->reference != NULL) &&
  ------------------
  |  Branch (7488:6): [True: 0, False: 0]
  |  Branch (7488:29): [True: 0, False: 0]
  ------------------
 7489|      0|	    (ctxt->replaceEntities == 0) && (!ctxt->disableSAX)) {
  ------------------
  |  Branch (7489:6): [True: 0, False: 0]
  |  Branch (7489:38): [True: 0, False: 0]
  ------------------
 7490|       |	    /*
 7491|       |	     * Entity reference callback comes second, it's somewhat
 7492|       |	     * superfluous but a compatibility to historical behaviour
 7493|       |	     */
 7494|      0|	    ctxt->sax->reference(ctxt->userData, ent->name);
 7495|      0|	}
 7496|      0|	return;
 7497|      0|    }
 7498|       |
 7499|       |    /*
 7500|       |     * We also check for amplification if entities aren't substituted.
 7501|       |     * They might be expanded later.
 7502|       |     */
 7503|      0|    if ((was_checked != 0) &&
  ------------------
  |  Branch (7503:9): [True: 0, False: 0]
  ------------------
 7504|      0|        (xmlParserEntityCheck(ctxt, ent->expandedSize)))
  ------------------
  |  Branch (7504:9): [True: 0, False: 0]
  ------------------
 7505|      0|        return;
 7506|       |
 7507|       |    /*
 7508|       |     * If we didn't get any children for the entity being built
 7509|       |     */
 7510|      0|    if ((ctxt->sax != NULL) && (ctxt->sax->reference != NULL) &&
  ------------------
  |  Branch (7510:9): [True: 0, False: 0]
  |  Branch (7510:32): [True: 0, False: 0]
  ------------------
 7511|      0|	(ctxt->replaceEntities == 0) && (!ctxt->disableSAX)) {
  ------------------
  |  Branch (7511:2): [True: 0, False: 0]
  |  Branch (7511:34): [True: 0, False: 0]
  ------------------
 7512|       |	/*
 7513|       |	 * Create a node.
 7514|       |	 */
 7515|      0|	ctxt->sax->reference(ctxt->userData, ent->name);
 7516|      0|	return;
 7517|      0|    }
 7518|       |
 7519|      0|    if (ctxt->replaceEntities)  {
  ------------------
  |  Branch (7519:9): [True: 0, False: 0]
  ------------------
 7520|       |	/*
 7521|       |	 * There is a problem on the handling of _private for entities
 7522|       |	 * (bug 155816): Should we copy the content of the field from
 7523|       |	 * the entity (possibly overwriting some value set by the user
 7524|       |	 * when a copy is created), should we leave it alone, or should
 7525|       |	 * we try to take care of different situations?  The problem
 7526|       |	 * is exacerbated by the usage of this field by the xmlReader.
 7527|       |	 * To fix this bug, we look at _private on the created node
 7528|       |	 * and, if it's NULL, we copy in whatever was in the entity.
 7529|       |	 * If it's not NULL we leave it alone.  This is somewhat of a
 7530|       |	 * hack - maybe we should have further tests to determine
 7531|       |	 * what to do.
 7532|       |	 */
 7533|      0|	if (ctxt->node != NULL) {
  ------------------
  |  Branch (7533:6): [True: 0, False: 0]
  ------------------
 7534|       |	    /*
 7535|       |	     * Seems we are generating the DOM content, do
 7536|       |	     * a simple tree copy for all references except the first
 7537|       |	     * In the first occurrence list contains the replacement.
 7538|       |	     */
 7539|      0|	    if (((list == NULL) && (ent->owner == 0)) ||
  ------------------
  |  Branch (7539:11): [True: 0, False: 0]
  |  Branch (7539:29): [True: 0, False: 0]
  ------------------
 7540|      0|		(ctxt->parseMode == XML_PARSE_READER)) {
  ------------------
  |  Branch (7540:3): [True: 0, False: 0]
  ------------------
 7541|      0|		xmlNodePtr nw = NULL, cur, firstChild = NULL;
 7542|       |
 7543|       |		/*
 7544|       |		 * when operating on a reader, the entities definitions
 7545|       |		 * are always owning the entities subtree.
 7546|       |		if (ctxt->parseMode == XML_PARSE_READER)
 7547|       |		    ent->owner = 1;
 7548|       |		 */
 7549|       |
 7550|      0|		cur = ent->children;
 7551|      0|		while (cur != NULL) {
  ------------------
  |  Branch (7551:10): [True: 0, False: 0]
  ------------------
 7552|      0|		    nw = xmlDocCopyNode(cur, ctxt->myDoc, 1);
 7553|      0|		    if (nw != NULL) {
  ------------------
  |  Branch (7553:11): [True: 0, False: 0]
  ------------------
 7554|      0|			if (nw->_private == NULL)
  ------------------
  |  Branch (7554:8): [True: 0, False: 0]
  ------------------
 7555|      0|			    nw->_private = cur->_private;
 7556|      0|			if (firstChild == NULL){
  ------------------
  |  Branch (7556:8): [True: 0, False: 0]
  ------------------
 7557|      0|			    firstChild = nw;
 7558|      0|			}
 7559|      0|			nw = xmlAddChild(ctxt->node, nw);
 7560|      0|		    }
 7561|      0|		    if (cur == ent->last) {
  ------------------
  |  Branch (7561:11): [True: 0, False: 0]
  ------------------
 7562|       |			/*
 7563|       |			 * needed to detect some strange empty
 7564|       |			 * node cases in the reader tests
 7565|       |			 */
 7566|      0|			if ((ctxt->parseMode == XML_PARSE_READER) &&
  ------------------
  |  Branch (7566:8): [True: 0, False: 0]
  ------------------
 7567|      0|			    (nw != NULL) &&
  ------------------
  |  Branch (7567:8): [True: 0, False: 0]
  ------------------
 7568|      0|			    (nw->type == XML_ELEMENT_NODE) &&
  ------------------
  |  Branch (7568:8): [True: 0, False: 0]
  ------------------
 7569|      0|			    (nw->children == NULL))
  ------------------
  |  Branch (7569:8): [True: 0, False: 0]
  ------------------
 7570|      0|			    nw->extra = 1;
 7571|       |
 7572|      0|			break;
 7573|      0|		    }
 7574|      0|		    cur = cur->next;
 7575|      0|		}
 7576|       |#ifdef LIBXML_LEGACY_ENABLED
 7577|       |		if (ent->etype == XML_EXTERNAL_GENERAL_PARSED_ENTITY)
 7578|       |		  xmlAddEntityReference(ent, firstChild, nw);
 7579|       |#endif /* LIBXML_LEGACY_ENABLED */
 7580|      0|	    } else if ((list == NULL) || (ctxt->inputNr > 0)) {
  ------------------
  |  Branch (7580:17): [True: 0, False: 0]
  |  Branch (7580:35): [True: 0, False: 0]
  ------------------
 7581|      0|		xmlNodePtr nw = NULL, cur, next, last,
 7582|      0|			   firstChild = NULL;
 7583|       |
 7584|       |		/*
 7585|       |		 * Copy the entity child list and make it the new
 7586|       |		 * entity child list. The goal is to make sure any
 7587|       |		 * ID or REF referenced will be the one from the
 7588|       |		 * document content and not the entity copy.
 7589|       |		 */
 7590|      0|		cur = ent->children;
 7591|      0|		ent->children = NULL;
 7592|      0|		last = ent->last;
 7593|      0|		ent->last = NULL;
 7594|      0|		while (cur != NULL) {
  ------------------
  |  Branch (7594:10): [True: 0, False: 0]
  ------------------
 7595|      0|		    next = cur->next;
 7596|      0|		    cur->next = NULL;
 7597|      0|		    cur->parent = NULL;
 7598|      0|		    nw = xmlDocCopyNode(cur, ctxt->myDoc, 1);
 7599|      0|		    if (nw != NULL) {
  ------------------
  |  Branch (7599:11): [True: 0, False: 0]
  ------------------
 7600|      0|			if (nw->_private == NULL)
  ------------------
  |  Branch (7600:8): [True: 0, False: 0]
  ------------------
 7601|      0|			    nw->_private = cur->_private;
 7602|      0|			if (firstChild == NULL){
  ------------------
  |  Branch (7602:8): [True: 0, False: 0]
  ------------------
 7603|      0|			    firstChild = cur;
 7604|      0|			}
 7605|      0|			xmlAddChild((xmlNodePtr) ent, nw);
 7606|      0|		    }
 7607|      0|		    xmlAddChild(ctxt->node, cur);
 7608|      0|		    if (cur == last)
  ------------------
  |  Branch (7608:11): [True: 0, False: 0]
  ------------------
 7609|      0|			break;
 7610|      0|		    cur = next;
 7611|      0|		}
 7612|      0|		if (ent->owner == 0)
  ------------------
  |  Branch (7612:7): [True: 0, False: 0]
  ------------------
 7613|      0|		    ent->owner = 1;
 7614|       |#ifdef LIBXML_LEGACY_ENABLED
 7615|       |		if (ent->etype == XML_EXTERNAL_GENERAL_PARSED_ENTITY)
 7616|       |		  xmlAddEntityReference(ent, firstChild, nw);
 7617|       |#endif /* LIBXML_LEGACY_ENABLED */
 7618|      0|	    } else {
 7619|      0|		const xmlChar *nbktext;
 7620|       |
 7621|       |		/*
 7622|       |		 * the name change is to avoid coalescing of the
 7623|       |		 * node with a possible previous text one which
 7624|       |		 * would make ent->children a dangling pointer
 7625|       |		 */
 7626|      0|		nbktext = xmlDictLookup(ctxt->dict, BAD_CAST "nbktext",
  ------------------
  |  |   35|      0|#define BAD_CAST (xmlChar *)
  ------------------
 7627|      0|					-1);
 7628|      0|		if (ent->children->type == XML_TEXT_NODE)
  ------------------
  |  Branch (7628:7): [True: 0, False: 0]
  ------------------
 7629|      0|		    ent->children->name = nbktext;
 7630|      0|		if ((ent->last != ent->children) &&
  ------------------
  |  Branch (7630:7): [True: 0, False: 0]
  ------------------
 7631|      0|		    (ent->last->type == XML_TEXT_NODE))
  ------------------
  |  Branch (7631:7): [True: 0, False: 0]
  ------------------
 7632|      0|		    ent->last->name = nbktext;
 7633|      0|		xmlAddChildList(ctxt->node, ent->children);
 7634|      0|	    }
 7635|       |
 7636|       |	    /*
 7637|       |	     * This is to avoid a nasty side effect, see
 7638|       |	     * characters() in SAX.c
 7639|       |	     */
 7640|      0|	    ctxt->nodemem = 0;
 7641|      0|	    ctxt->nodelen = 0;
 7642|      0|	    return;
 7643|      0|	}
 7644|      0|    }
 7645|      0|}
xmlParseEntityRef:
 7678|      2|xmlParseEntityRef(xmlParserCtxtPtr ctxt) {
 7679|      2|    const xmlChar *name;
 7680|      2|    xmlEntityPtr ent = NULL;
 7681|       |
 7682|      2|    GROW;
  ------------------
  |  | 2270|      2|#define GROW if (ctxt->input->end - ctxt->input->cur < INPUT_CHUNK)	\
  |  |  ------------------
  |  |  |  |   97|      2|#define INPUT_CHUNK	250
  |  |  ------------------
  |  |  |  Branch (2270:18): [True: 2, False: 0]
  |  |  ------------------
  |  | 2271|      2|	xmlParserGrow(ctxt);
  ------------------
 7683|      2|    if (ctxt->instate == XML_PARSER_EOF)
  ------------------
  |  Branch (7683:9): [True: 0, False: 2]
  ------------------
 7684|      0|        return(NULL);
 7685|       |
 7686|      2|    if (RAW != '&')
  ------------------
  |  | 2221|      2|#define RAW (*ctxt->input->cur)
  ------------------
  |  Branch (7686:9): [True: 0, False: 2]
  ------------------
 7687|      0|        return(NULL);
 7688|      2|    NEXT;
  ------------------
  |  | 2275|      2|#define NEXT xmlNextChar(ctxt)
  ------------------
 7689|      2|    name = xmlParseName(ctxt);
 7690|      2|    if (name == NULL) {
  ------------------
  |  Branch (7690:9): [True: 0, False: 2]
  ------------------
 7691|      0|	xmlFatalErrMsg(ctxt, XML_ERR_NAME_REQUIRED,
 7692|      0|		       "xmlParseEntityRef: no name\n");
 7693|      0|        return(NULL);
 7694|      0|    }
 7695|      2|    if (RAW != ';') {
  ------------------
  |  | 2221|      2|#define RAW (*ctxt->input->cur)
  ------------------
  |  Branch (7695:9): [True: 0, False: 2]
  ------------------
 7696|      0|	xmlFatalErr(ctxt, XML_ERR_ENTITYREF_SEMICOL_MISSING, NULL);
 7697|      0|	return(NULL);
 7698|      0|    }
 7699|      2|    NEXT;
  ------------------
  |  | 2275|      2|#define NEXT xmlNextChar(ctxt)
  ------------------
 7700|       |
 7701|       |    /*
 7702|       |     * Predefined entities override any extra definition
 7703|       |     */
 7704|      2|    if ((ctxt->options & XML_PARSE_OLDSAX) == 0) {
  ------------------
  |  Branch (7704:9): [True: 2, False: 0]
  ------------------
 7705|      2|        ent = xmlGetPredefinedEntity(name);
 7706|      2|        if (ent != NULL)
  ------------------
  |  Branch (7706:13): [True: 0, False: 2]
  ------------------
 7707|      0|            return(ent);
 7708|      2|    }
 7709|       |
 7710|       |    /*
 7711|       |     * Ask first SAX for entity resolution, otherwise try the
 7712|       |     * entities which may have stored in the parser context.
 7713|       |     */
 7714|      2|    if (ctxt->sax != NULL) {
  ------------------
  |  Branch (7714:9): [True: 2, False: 0]
  ------------------
 7715|      2|	if (ctxt->sax->getEntity != NULL)
  ------------------
  |  Branch (7715:6): [True: 2, False: 0]
  ------------------
 7716|      2|	    ent = ctxt->sax->getEntity(ctxt->userData, name);
 7717|      2|	if ((ctxt->wellFormed == 1 ) && (ent == NULL) &&
  ------------------
  |  Branch (7717:6): [True: 2, False: 0]
  |  Branch (7717:34): [True: 2, False: 0]
  ------------------
 7718|      2|	    (ctxt->options & XML_PARSE_OLDSAX))
  ------------------
  |  Branch (7718:6): [True: 0, False: 2]
  ------------------
 7719|      0|	    ent = xmlGetPredefinedEntity(name);
 7720|      2|	if ((ctxt->wellFormed == 1 ) && (ent == NULL) &&
  ------------------
  |  Branch (7720:6): [True: 2, False: 0]
  |  Branch (7720:34): [True: 2, False: 0]
  ------------------
 7721|      2|	    (ctxt->userData==ctxt)) {
  ------------------
  |  Branch (7721:6): [True: 2, False: 0]
  ------------------
 7722|      2|	    ent = xmlSAX2GetEntity(ctxt, name);
 7723|      2|	}
 7724|      2|    }
 7725|      2|    if (ctxt->instate == XML_PARSER_EOF)
  ------------------
  |  Branch (7725:9): [True: 0, False: 2]
  ------------------
 7726|      0|	return(NULL);
 7727|       |    /*
 7728|       |     * [ WFC: Entity Declared ]
 7729|       |     * In a document without any DTD, a document with only an
 7730|       |     * internal DTD subset which contains no parameter entity
 7731|       |     * references, or a document with "standalone='yes'", the
 7732|       |     * Name given in the entity reference must match that in an
 7733|       |     * entity declaration, except that well-formed documents
 7734|       |     * need not declare any of the following entities: amp, lt,
 7735|       |     * gt, apos, quot.
 7736|       |     * The declaration of a parameter entity must precede any
 7737|       |     * reference to it.
 7738|       |     * Similarly, the declaration of a general entity must
 7739|       |     * precede any reference to it which appears in a default
 7740|       |     * value in an attribute-list declaration. Note that if
 7741|       |     * entities are declared in the external subset or in
 7742|       |     * external parameter entities, a non-validating processor
 7743|       |     * is not obligated to read and process their declarations;
 7744|       |     * for such documents, the rule that an entity must be
 7745|       |     * declared is a well-formedness constraint only if
 7746|       |     * standalone='yes'.
 7747|       |     */
 7748|      2|    if (ent == NULL) {
  ------------------
  |  Branch (7748:9): [True: 2, False: 0]
  ------------------
 7749|      2|	if ((ctxt->standalone == 1) ||
  ------------------
  |  Branch (7749:6): [True: 0, False: 2]
  ------------------
 7750|      2|	    ((ctxt->hasExternalSubset == 0) &&
  ------------------
  |  Branch (7750:7): [True: 2, False: 0]
  ------------------
 7751|      2|	     (ctxt->hasPErefs == 0))) {
  ------------------
  |  Branch (7751:7): [True: 2, False: 0]
  ------------------
 7752|      2|	    xmlFatalErrMsgStr(ctxt, XML_ERR_UNDECLARED_ENTITY,
 7753|      2|		     "Entity '%s' not defined\n", name);
 7754|      2|	} else {
 7755|      0|	    xmlErrMsgStr(ctxt, XML_WAR_UNDECLARED_ENTITY,
 7756|      0|		     "Entity '%s' not defined\n", name);
 7757|      0|	    if ((ctxt->inSubset == 0) &&
  ------------------
  |  Branch (7757:10): [True: 0, False: 0]
  ------------------
 7758|      0|		(ctxt->sax != NULL) &&
  ------------------
  |  Branch (7758:3): [True: 0, False: 0]
  ------------------
 7759|      0|                (ctxt->disableSAX == 0) &&
  ------------------
  |  Branch (7759:17): [True: 0, False: 0]
  ------------------
 7760|      0|		(ctxt->sax->reference != NULL)) {
  ------------------
  |  Branch (7760:3): [True: 0, False: 0]
  ------------------
 7761|      0|		ctxt->sax->reference(ctxt->userData, name);
 7762|      0|	    }
 7763|      0|	}
 7764|      2|	ctxt->valid = 0;
 7765|      2|    }
 7766|       |
 7767|       |    /*
 7768|       |     * [ WFC: Parsed Entity ]
 7769|       |     * An entity reference must not contain the name of an
 7770|       |     * unparsed entity
 7771|       |     */
 7772|      0|    else if (ent->etype == XML_EXTERNAL_GENERAL_UNPARSED_ENTITY) {
  ------------------
  |  Branch (7772:14): [True: 0, False: 0]
  ------------------
 7773|      0|	xmlFatalErrMsgStr(ctxt, XML_ERR_UNPARSED_ENTITY,
 7774|      0|		 "Entity reference to unparsed entity %s\n", name);
 7775|      0|    }
 7776|       |
 7777|       |    /*
 7778|       |     * [ WFC: No External Entity References ]
 7779|       |     * Attribute values cannot contain direct or indirect
 7780|       |     * entity references to external entities.
 7781|       |     */
 7782|      0|    else if ((ctxt->instate == XML_PARSER_ATTRIBUTE_VALUE) &&
  ------------------
  |  Branch (7782:14): [True: 0, False: 0]
  ------------------
 7783|      0|	     (ent->etype == XML_EXTERNAL_GENERAL_PARSED_ENTITY)) {
  ------------------
  |  Branch (7783:7): [True: 0, False: 0]
  ------------------
 7784|      0|	xmlFatalErrMsgStr(ctxt, XML_ERR_ENTITY_IS_EXTERNAL,
 7785|      0|	     "Attribute references external entity '%s'\n", name);
 7786|      0|    }
 7787|       |    /*
 7788|       |     * [ WFC: No < in Attribute Values ]
 7789|       |     * The replacement text of any entity referred to directly or
 7790|       |     * indirectly in an attribute value (other than "&lt;") must
 7791|       |     * not contain a <.
 7792|       |     */
 7793|      0|    else if ((ctxt->instate == XML_PARSER_ATTRIBUTE_VALUE) &&
  ------------------
  |  Branch (7793:14): [True: 0, False: 0]
  ------------------
 7794|      0|	     (ent->etype != XML_INTERNAL_PREDEFINED_ENTITY)) {
  ------------------
  |  Branch (7794:7): [True: 0, False: 0]
  ------------------
 7795|      0|	if ((ent->flags & XML_ENT_CHECKED_LT) == 0) {
  ------------------
  |  |   17|      0|#define XML_ENT_CHECKED_LT  (1<<3)
  ------------------
  |  Branch (7795:6): [True: 0, False: 0]
  ------------------
 7796|      0|            if ((ent->content != NULL) && (xmlStrchr(ent->content, '<')))
  ------------------
  |  Branch (7796:17): [True: 0, False: 0]
  |  Branch (7796:43): [True: 0, False: 0]
  ------------------
 7797|      0|                ent->flags |= XML_ENT_CONTAINS_LT;
  ------------------
  |  |   18|      0|#define XML_ENT_CONTAINS_LT (1<<4)
  ------------------
 7798|      0|            ent->flags |= XML_ENT_CHECKED_LT;
  ------------------
  |  |   17|      0|#define XML_ENT_CHECKED_LT  (1<<3)
  ------------------
 7799|      0|        }
 7800|      0|        if (ent->flags & XML_ENT_CONTAINS_LT)
  ------------------
  |  |   18|      0|#define XML_ENT_CONTAINS_LT (1<<4)
  ------------------
  |  Branch (7800:13): [True: 0, False: 0]
  ------------------
 7801|      0|            xmlFatalErrMsgStr(ctxt, XML_ERR_LT_IN_ATTRIBUTE,
 7802|      0|                    "'<' in entity '%s' is not allowed in attributes "
 7803|      0|                    "values\n", name);
 7804|      0|    }
 7805|       |
 7806|       |    /*
 7807|       |     * Internal check, no parameter entities here ...
 7808|       |     */
 7809|      0|    else {
 7810|      0|	switch (ent->etype) {
 7811|      0|	    case XML_INTERNAL_PARAMETER_ENTITY:
  ------------------
  |  Branch (7811:6): [True: 0, False: 0]
  ------------------
 7812|      0|	    case XML_EXTERNAL_PARAMETER_ENTITY:
  ------------------
  |  Branch (7812:6): [True: 0, False: 0]
  ------------------
 7813|      0|	    xmlFatalErrMsgStr(ctxt, XML_ERR_ENTITY_IS_PARAMETER,
 7814|      0|	     "Attempt to reference the parameter entity '%s'\n",
 7815|      0|			      name);
 7816|      0|	    break;
 7817|      0|	    default:
  ------------------
  |  Branch (7817:6): [True: 0, False: 0]
  ------------------
 7818|      0|	    break;
 7819|      0|	}
 7820|      0|    }
 7821|       |
 7822|       |    /*
 7823|       |     * [ WFC: No Recursion ]
 7824|       |     * A parsed entity must not contain a recursive reference
 7825|       |     * to itself, either directly or indirectly.
 7826|       |     * Done somewhere else
 7827|       |     */
 7828|      2|    return(ent);
 7829|      2|}
xmlParseDocTypeDecl:
 8461|      8|xmlParseDocTypeDecl(xmlParserCtxtPtr ctxt) {
 8462|      8|    const xmlChar *name = NULL;
 8463|      8|    xmlChar *ExternalID = NULL;
 8464|      8|    xmlChar *URI = NULL;
 8465|       |
 8466|       |    /*
 8467|       |     * We know that '<!DOCTYPE' has been detected.
 8468|       |     */
 8469|      8|    SKIP(9);
  ------------------
  |  | 2245|      8|#define SKIP(val) do {							\
  |  | 2246|      8|    ctxt->input->cur += (val),ctxt->input->col+=(val);			\
  |  | 2247|      8|    if (*ctxt->input->cur == 0)						\
  |  |  ------------------
  |  |  |  Branch (2247:9): [True: 0, False: 8]
  |  |  ------------------
  |  | 2248|      8|        xmlParserGrow(ctxt);						\
  |  | 2249|      8|  } while (0)
  |  |  ------------------
  |  |  |  Branch (2249:12): [Folded - Ignored]
  |  |  ------------------
  ------------------
 8470|       |
 8471|      8|    SKIP_BLANKS;
  ------------------
  |  | 2273|      8|#define SKIP_BLANKS xmlSkipBlankChars(ctxt)
  ------------------
 8472|       |
 8473|       |    /*
 8474|       |     * Parse the DOCTYPE name.
 8475|       |     */
 8476|      8|    name = xmlParseName(ctxt);
 8477|      8|    if (name == NULL) {
  ------------------
  |  Branch (8477:9): [True: 0, False: 8]
  ------------------
 8478|      0|	xmlFatalErrMsg(ctxt, XML_ERR_NAME_REQUIRED,
 8479|      0|		       "xmlParseDocTypeDecl : no DOCTYPE name !\n");
 8480|      0|    }
 8481|      8|    ctxt->intSubName = name;
 8482|       |
 8483|      8|    SKIP_BLANKS;
  ------------------
  |  | 2273|      8|#define SKIP_BLANKS xmlSkipBlankChars(ctxt)
  ------------------
 8484|       |
 8485|       |    /*
 8486|       |     * Check for SystemID and ExternalID
 8487|       |     */
 8488|      8|    URI = xmlParseExternalID(ctxt, &ExternalID, 1);
 8489|       |
 8490|      8|    if ((URI != NULL) || (ExternalID != NULL)) {
  ------------------
  |  Branch (8490:9): [True: 0, False: 8]
  |  Branch (8490:26): [True: 0, False: 8]
  ------------------
 8491|      0|        ctxt->hasExternalSubset = 1;
 8492|      0|    }
 8493|      8|    ctxt->extSubURI = URI;
 8494|      8|    ctxt->extSubSystem = ExternalID;
 8495|       |
 8496|      8|    SKIP_BLANKS;
  ------------------
  |  | 2273|      8|#define SKIP_BLANKS xmlSkipBlankChars(ctxt)
  ------------------
 8497|       |
 8498|       |    /*
 8499|       |     * Create and update the internal subset.
 8500|       |     */
 8501|      8|    if ((ctxt->sax != NULL) && (ctxt->sax->internalSubset != NULL) &&
  ------------------
  |  Branch (8501:9): [True: 8, False: 0]
  |  Branch (8501:32): [True: 8, False: 0]
  ------------------
 8502|      8|	(!ctxt->disableSAX))
  ------------------
  |  Branch (8502:2): [True: 8, False: 0]
  ------------------
 8503|      8|	ctxt->sax->internalSubset(ctxt->userData, name, ExternalID, URI);
 8504|      8|    if (ctxt->instate == XML_PARSER_EOF)
  ------------------
  |  Branch (8504:9): [True: 0, False: 8]
  ------------------
 8505|      0|	return;
 8506|       |
 8507|       |    /*
 8508|       |     * Is there any internal subset declarations ?
 8509|       |     * they are handled separately in xmlParseInternalSubset()
 8510|       |     */
 8511|      8|    if (RAW == '[')
  ------------------
  |  | 2221|      8|#define RAW (*ctxt->input->cur)
  ------------------
  |  Branch (8511:9): [True: 8, False: 0]
  ------------------
 8512|      8|	return;
 8513|       |
 8514|       |    /*
 8515|       |     * We should be at the end of the DOCTYPE declaration.
 8516|       |     */
 8517|      0|    if (RAW != '>') {
  ------------------
  |  | 2221|      0|#define RAW (*ctxt->input->cur)
  ------------------
  |  Branch (8517:9): [True: 0, False: 0]
  ------------------
 8518|      0|	xmlFatalErr(ctxt, XML_ERR_DOCTYPE_NOT_FINISHED, NULL);
 8519|      0|    }
 8520|      0|    NEXT;
  ------------------
  |  | 2275|      0|#define NEXT xmlNextChar(ctxt)
  ------------------
 8521|      0|}
xmlParseAttribute:
 8625|      5|xmlParseAttribute(xmlParserCtxtPtr ctxt, xmlChar **value) {
 8626|      5|    const xmlChar *name;
 8627|      5|    xmlChar *val;
 8628|       |
 8629|      5|    *value = NULL;
 8630|      5|    GROW;
  ------------------
  |  | 2270|      5|#define GROW if (ctxt->input->end - ctxt->input->cur < INPUT_CHUNK)	\
  |  |  ------------------
  |  |  |  |   97|      5|#define INPUT_CHUNK	250
  |  |  ------------------
  |  |  |  Branch (2270:18): [True: 3, False: 2]
  |  |  ------------------
  |  | 2271|      5|	xmlParserGrow(ctxt);
  ------------------
 8631|      5|    name = xmlParseName(ctxt);
 8632|      5|    if (name == NULL) {
  ------------------
  |  Branch (8632:9): [True: 1, False: 4]
  ------------------
 8633|      1|	xmlFatalErrMsg(ctxt, XML_ERR_NAME_REQUIRED,
 8634|      1|	               "error parsing attribute name\n");
 8635|      1|        return(NULL);
 8636|      1|    }
 8637|       |
 8638|       |    /*
 8639|       |     * read the value
 8640|       |     */
 8641|      4|    SKIP_BLANKS;
  ------------------
  |  | 2273|      4|#define SKIP_BLANKS xmlSkipBlankChars(ctxt)
  ------------------
 8642|      4|    if (RAW == '=') {
  ------------------
  |  | 2221|      4|#define RAW (*ctxt->input->cur)
  ------------------
  |  Branch (8642:9): [True: 4, False: 0]
  ------------------
 8643|      4|        NEXT;
  ------------------
  |  | 2275|      4|#define NEXT xmlNextChar(ctxt)
  ------------------
 8644|      4|	SKIP_BLANKS;
  ------------------
  |  | 2273|      4|#define SKIP_BLANKS xmlSkipBlankChars(ctxt)
  ------------------
 8645|      4|	val = xmlParseAttValue(ctxt);
 8646|      4|	ctxt->instate = XML_PARSER_CONTENT;
 8647|      4|    } else {
 8648|      0|	xmlFatalErrMsgStr(ctxt, XML_ERR_ATTRIBUTE_WITHOUT_VALUE,
 8649|      0|	       "Specification mandates value for attribute %s\n", name);
 8650|      0|	return(name);
 8651|      0|    }
 8652|       |
 8653|       |    /*
 8654|       |     * Check that xml:lang conforms to the specification
 8655|       |     * No more registered as an error, just generate a warning now
 8656|       |     * since this was deprecated in XML second edition
 8657|       |     */
 8658|      4|    if ((ctxt->pedantic) && (xmlStrEqual(name, BAD_CAST "xml:lang"))) {
  ------------------
  |  |   35|      0|#define BAD_CAST (xmlChar *)
  ------------------
  |  Branch (8658:9): [True: 0, False: 4]
  |  Branch (8658:29): [True: 0, False: 0]
  ------------------
 8659|      0|	if (!xmlCheckLanguageID(val)) {
  ------------------
  |  Branch (8659:6): [True: 0, False: 0]
  ------------------
 8660|      0|	    xmlWarningMsg(ctxt, XML_WAR_LANG_VALUE,
 8661|      0|		          "Malformed value for xml:lang : %s\n",
 8662|      0|			  val, NULL);
 8663|      0|	}
 8664|      0|    }
 8665|       |
 8666|       |    /*
 8667|       |     * Check that xml:space conforms to the specification
 8668|       |     */
 8669|      4|    if (xmlStrEqual(name, BAD_CAST "xml:space")) {
  ------------------
  |  |   35|      4|#define BAD_CAST (xmlChar *)
  ------------------
  |  Branch (8669:9): [True: 0, False: 4]
  ------------------
 8670|      0|	if (xmlStrEqual(val, BAD_CAST "default"))
  ------------------
  |  |   35|      0|#define BAD_CAST (xmlChar *)
  ------------------
  |  Branch (8670:6): [True: 0, False: 0]
  ------------------
 8671|      0|	    *(ctxt->space) = 0;
 8672|      0|	else if (xmlStrEqual(val, BAD_CAST "preserve"))
  ------------------
  |  |   35|      0|#define BAD_CAST (xmlChar *)
  ------------------
  |  Branch (8672:11): [True: 0, False: 0]
  ------------------
 8673|      0|	    *(ctxt->space) = 1;
 8674|      0|	else {
 8675|      0|		xmlWarningMsg(ctxt, XML_WAR_SPACE_VALUE,
 8676|      0|"Invalid value \"%s\" for xml:space : \"default\" or \"preserve\" expected\n",
 8677|      0|                                 val, NULL);
 8678|      0|	}
 8679|      0|    }
 8680|       |
 8681|      4|    *value = val;
 8682|      4|    return(name);
 8683|      4|}
xmlParseStartTag:
 8715|      5|xmlParseStartTag(xmlParserCtxtPtr ctxt) {
 8716|      5|    const xmlChar *name;
 8717|      5|    const xmlChar *attname;
 8718|      5|    xmlChar *attvalue;
 8719|      5|    const xmlChar **atts = ctxt->atts;
 8720|      5|    int nbatts = 0;
 8721|      5|    int maxatts = ctxt->maxatts;
 8722|      5|    int i;
 8723|       |
 8724|      5|    if (RAW != '<') return(NULL);
  ------------------
  |  | 2221|      5|#define RAW (*ctxt->input->cur)
  ------------------
  |  Branch (8724:9): [True: 0, False: 5]
  ------------------
 8725|      5|    NEXT1;
  ------------------
  |  | 2277|      5|#define NEXT1 {								\
  |  | 2278|      5|	ctxt->input->col++;						\
  |  | 2279|      5|	ctxt->input->cur++;						\
  |  | 2280|      5|	if (*ctxt->input->cur == 0)					\
  |  |  ------------------
  |  |  |  Branch (2280:6): [True: 0, False: 5]
  |  |  ------------------
  |  | 2281|      5|	    xmlParserGrow(ctxt);						\
  |  | 2282|      5|    }
  ------------------
 8726|       |
 8727|      5|    name = xmlParseName(ctxt);
 8728|      5|    if (name == NULL) {
  ------------------
  |  Branch (8728:9): [True: 0, False: 5]
  ------------------
 8729|      0|	xmlFatalErrMsg(ctxt, XML_ERR_NAME_REQUIRED,
 8730|      0|	     "xmlParseStartTag: invalid element name\n");
 8731|      0|        return(NULL);
 8732|      0|    }
 8733|       |
 8734|       |    /*
 8735|       |     * Now parse the attributes, it ends up with the ending
 8736|       |     *
 8737|       |     * (S Attribute)* S?
 8738|       |     */
 8739|      5|    SKIP_BLANKS;
  ------------------
  |  | 2273|      5|#define SKIP_BLANKS xmlSkipBlankChars(ctxt)
  ------------------
 8740|      5|    GROW;
  ------------------
  |  | 2270|      5|#define GROW if (ctxt->input->end - ctxt->input->cur < INPUT_CHUNK)	\
  |  |  ------------------
  |  |  |  |   97|      5|#define INPUT_CHUNK	250
  |  |  ------------------
  |  |  |  Branch (2270:18): [True: 3, False: 2]
  |  |  ------------------
  |  | 2271|      5|	xmlParserGrow(ctxt);
  ------------------
 8741|       |
 8742|      5|    while (((RAW != '>') &&
  ------------------
  |  | 2221|      5|#define RAW (*ctxt->input->cur)
  ------------------
  |  Branch (8742:13): [True: 5, False: 0]
  ------------------
 8743|      5|	   ((RAW != '/') || (NXT(1) != '>')) &&
  ------------------
  |  | 2221|      5|#define RAW (*ctxt->input->cur)
  ------------------
              	   ((RAW != '/') || (NXT(1) != '>')) &&
  ------------------
  |  | 2223|      0|#define NXT(val) ctxt->input->cur[(val)]
  ------------------
  |  Branch (8743:6): [True: 5, False: 0]
  |  Branch (8743:22): [True: 0, False: 0]
  ------------------
 8744|      5|	   (IS_BYTE_CHAR(RAW))) && (ctxt->instate != XML_PARSER_EOF)) {
  ------------------
  |  |  113|      5|#define IS_BYTE_CHAR(c)	 xmlIsChar_ch(c)
  |  |  ------------------
  |  |  |  |  108|      5|#define xmlIsChar_ch(c)		(((0x9 <= (c)) && ((c) <= 0xa)) || \
  |  |  |  |  ------------------
  |  |  |  |  |  Branch (108:28): [True: 5, False: 0]
  |  |  |  |  |  Branch (108:44): [True: 0, False: 5]
  |  |  |  |  ------------------
  |  |  |  |  109|      5|				 ((c) == 0xd) || \
  |  |  |  |  ------------------
  |  |  |  |  |  Branch (109:6): [True: 0, False: 5]
  |  |  |  |  ------------------
  |  |  |  |  110|      5|				  (0x20 <= (c)))
  |  |  |  |  ------------------
  |  |  |  |  |  Branch (110:7): [True: 5, False: 0]
  |  |  |  |  ------------------
  |  |  ------------------
  ------------------
  |  Branch (8744:29): [True: 5, False: 0]
  ------------------
 8745|      5|	attname = xmlParseAttribute(ctxt, &attvalue);
 8746|      5|        if (attname == NULL) {
  ------------------
  |  Branch (8746:13): [True: 1, False: 4]
  ------------------
 8747|      1|	    xmlFatalErrMsg(ctxt, XML_ERR_INTERNAL_ERROR,
 8748|      1|			   "xmlParseStartTag: problem parsing attributes\n");
 8749|      1|	    break;
 8750|      1|	}
 8751|      4|        if (attvalue != NULL) {
  ------------------
  |  Branch (8751:13): [True: 4, False: 0]
  ------------------
 8752|       |	    /*
 8753|       |	     * [ WFC: Unique Att Spec ]
 8754|       |	     * No attribute name may appear more than once in the same
 8755|       |	     * start-tag or empty-element tag.
 8756|       |	     */
 8757|      4|	    for (i = 0; i < nbatts;i += 2) {
  ------------------
  |  Branch (8757:18): [True: 0, False: 4]
  ------------------
 8758|      0|	        if (xmlStrEqual(atts[i], attname)) {
  ------------------
  |  Branch (8758:14): [True: 0, False: 0]
  ------------------
 8759|      0|		    xmlErrAttributeDup(ctxt, NULL, attname);
 8760|      0|		    xmlFree(attvalue);
 8761|      0|		    goto failed;
 8762|      0|		}
 8763|      0|	    }
 8764|       |	    /*
 8765|       |	     * Add the pair to atts
 8766|       |	     */
 8767|      4|	    if (atts == NULL) {
  ------------------
  |  Branch (8767:10): [True: 2, False: 2]
  ------------------
 8768|      2|	        maxatts = 22; /* allow for 10 attrs by default */
 8769|      2|	        atts = (const xmlChar **)
 8770|      2|		       xmlMalloc(maxatts * sizeof(xmlChar *));
 8771|      2|		if (atts == NULL) {
  ------------------
  |  Branch (8771:7): [True: 0, False: 2]
  ------------------
 8772|      0|		    xmlErrMemory(ctxt, NULL);
 8773|      0|		    if (attvalue != NULL)
  ------------------
  |  Branch (8773:11): [True: 0, False: 0]
  ------------------
 8774|      0|			xmlFree(attvalue);
 8775|      0|		    goto failed;
 8776|      0|		}
 8777|      2|		ctxt->atts = atts;
 8778|      2|		ctxt->maxatts = maxatts;
 8779|      2|	    } else if (nbatts + 4 > maxatts) {
  ------------------
  |  Branch (8779:17): [True: 0, False: 2]
  ------------------
 8780|      0|	        const xmlChar **n;
 8781|       |
 8782|      0|	        maxatts *= 2;
 8783|      0|	        n = (const xmlChar **) xmlRealloc((void *) atts,
 8784|      0|					     maxatts * sizeof(const xmlChar *));
 8785|      0|		if (n == NULL) {
  ------------------
  |  Branch (8785:7): [True: 0, False: 0]
  ------------------
 8786|      0|		    xmlErrMemory(ctxt, NULL);
 8787|      0|		    if (attvalue != NULL)
  ------------------
  |  Branch (8787:11): [True: 0, False: 0]
  ------------------
 8788|      0|			xmlFree(attvalue);
 8789|      0|		    goto failed;
 8790|      0|		}
 8791|      0|		atts = n;
 8792|      0|		ctxt->atts = atts;
 8793|      0|		ctxt->maxatts = maxatts;
 8794|      0|	    }
 8795|      4|	    atts[nbatts++] = attname;
 8796|      4|	    atts[nbatts++] = attvalue;
 8797|      4|	    atts[nbatts] = NULL;
 8798|      4|	    atts[nbatts + 1] = NULL;
 8799|      4|	} else {
 8800|      0|	    if (attvalue != NULL)
  ------------------
  |  Branch (8800:10): [True: 0, False: 0]
  ------------------
 8801|      0|		xmlFree(attvalue);
 8802|      0|	}
 8803|       |
 8804|      4|failed:
 8805|       |
 8806|      4|	GROW
  ------------------
  |  | 2270|      4|#define GROW if (ctxt->input->end - ctxt->input->cur < INPUT_CHUNK)	\
  |  |  ------------------
  |  |  |  |   97|      4|#define INPUT_CHUNK	250
  |  |  ------------------
  |  |  |  Branch (2270:18): [True: 4, False: 0]
  |  |  ------------------
  |  | 2271|      4|	xmlParserGrow(ctxt);
  ------------------
 8807|      4|	if ((RAW == '>') || (((RAW == '/') && (NXT(1) == '>'))))
  ------------------
  |  | 2221|      4|#define RAW (*ctxt->input->cur)
  ------------------
              	if ((RAW == '>') || (((RAW == '/') && (NXT(1) == '>'))))
  ------------------
  |  | 2221|      2|#define RAW (*ctxt->input->cur)
  ------------------
              	if ((RAW == '>') || (((RAW == '/') && (NXT(1) == '>'))))
  ------------------
  |  | 2223|      2|#define NXT(val) ctxt->input->cur[(val)]
  ------------------
  |  Branch (8807:6): [True: 2, False: 2]
  |  Branch (8807:24): [True: 2, False: 0]
  |  Branch (8807:40): [True: 2, False: 0]
  ------------------
 8808|      4|	    break;
 8809|      0|	if (SKIP_BLANKS == 0) {
  ------------------
  |  | 2273|      0|#define SKIP_BLANKS xmlSkipBlankChars(ctxt)
  ------------------
  |  Branch (8809:6): [True: 0, False: 0]
  ------------------
 8810|      0|	    xmlFatalErrMsg(ctxt, XML_ERR_SPACE_REQUIRED,
 8811|      0|			   "attributes construct error\n");
 8812|      0|	}
 8813|      0|	SHRINK;
  ------------------
  |  | 2265|      0|    if (((ctxt->progressive == 0) || (ctxt->inputNr > 1)) && \
  |  |  ------------------
  |  |  |  Branch (2265:10): [True: 0, False: 0]
  |  |  |  Branch (2265:38): [True: 0, False: 0]
  |  |  ------------------
  |  | 2266|      0|        (ctxt->input->cur - ctxt->input->base > 2 * INPUT_CHUNK) && \
  |  |  ------------------
  |  |  |  |   97|      0|#define INPUT_CHUNK	250
  |  |  ------------------
  |  |  |  Branch (2266:9): [True: 0, False: 0]
  |  |  ------------------
  |  | 2267|      0|	(ctxt->input->end - ctxt->input->cur < 2 * INPUT_CHUNK)) \
  |  |  ------------------
  |  |  |  |   97|      0|#define INPUT_CHUNK	250
  |  |  ------------------
  |  |  |  Branch (2267:2): [True: 0, False: 0]
  |  |  ------------------
  |  | 2268|      0|	xmlParserShrink(ctxt);
  ------------------
 8814|      0|        GROW;
  ------------------
  |  | 2270|      0|#define GROW if (ctxt->input->end - ctxt->input->cur < INPUT_CHUNK)	\
  |  |  ------------------
  |  |  |  |   97|      0|#define INPUT_CHUNK	250
  |  |  ------------------
  |  |  |  Branch (2270:18): [True: 0, False: 0]
  |  |  ------------------
  |  | 2271|      0|	xmlParserGrow(ctxt);
  ------------------
 8815|      0|    }
 8816|       |
 8817|       |    /*
 8818|       |     * SAX: Start of Element !
 8819|       |     */
 8820|      5|    if ((ctxt->sax != NULL) && (ctxt->sax->startElement != NULL) &&
  ------------------
  |  Branch (8820:9): [True: 5, False: 0]
  |  Branch (8820:32): [True: 5, False: 0]
  ------------------
 8821|      5|	(!ctxt->disableSAX)) {
  ------------------
  |  Branch (8821:2): [True: 5, False: 0]
  ------------------
 8822|      5|	if (nbatts > 0)
  ------------------
  |  Branch (8822:6): [True: 4, False: 1]
  ------------------
 8823|      4|	    ctxt->sax->startElement(ctxt->userData, name, atts);
 8824|      1|	else
 8825|      1|	    ctxt->sax->startElement(ctxt->userData, name, NULL);
 8826|      5|    }
 8827|       |
 8828|      5|    if (atts != NULL) {
  ------------------
  |  Branch (8828:9): [True: 4, False: 1]
  ------------------
 8829|       |        /* Free only the content strings */
 8830|      8|        for (i = 1;i < nbatts;i+=2)
  ------------------
  |  Branch (8830:20): [True: 4, False: 4]
  ------------------
 8831|      4|	    if (atts[i] != NULL)
  ------------------
  |  Branch (8831:10): [True: 4, False: 0]
  ------------------
 8832|      4|	       xmlFree((xmlChar *) atts[i]);
 8833|      4|    }
 8834|      5|    return(name);
 8835|      5|}
xmlParseElement:
10319|    184|xmlParseElement(xmlParserCtxtPtr ctxt) {
10320|    184|    if (xmlParseElementStart(ctxt) != 0)
  ------------------
  |  Branch (10320:9): [True: 27, False: 157]
  ------------------
10321|     27|        return;
10322|       |
10323|    157|    xmlParseContentInternal(ctxt);
10324|    157|    if (ctxt->instate == XML_PARSER_EOF)
  ------------------
  |  Branch (10324:9): [True: 0, False: 157]
  ------------------
10325|      0|	return;
10326|       |
10327|    157|    if (ctxt->input->cur >= ctxt->input->end) {
  ------------------
  |  Branch (10327:9): [True: 37, False: 120]
  ------------------
10328|     37|        if (ctxt->errNo == XML_ERR_OK) {
  ------------------
  |  Branch (10328:13): [True: 0, False: 37]
  ------------------
10329|      0|            const xmlChar *name = ctxt->nameTab[ctxt->nameNr - 1];
10330|      0|            int line = ctxt->pushTab[ctxt->nameNr - 1].line;
10331|      0|            xmlFatalErrMsgStrIntStr(ctxt, XML_ERR_TAG_NOT_FINISHED,
10332|      0|                    "Premature end of data in tag %s line %d\n",
10333|      0|                    name, line, NULL);
10334|      0|        }
10335|     37|        return;
10336|     37|    }
10337|       |
10338|    120|    xmlParseElementEnd(ctxt);
10339|    120|}
xmlParseVersionNum:
10526|     68|xmlParseVersionNum(xmlParserCtxtPtr ctxt) {
10527|     68|    xmlChar *buf = NULL;
10528|     68|    int len = 0;
10529|     68|    int size = 10;
10530|     68|    xmlChar cur;
10531|       |
10532|     68|    buf = (xmlChar *) xmlMallocAtomic(size);
10533|     68|    if (buf == NULL) {
  ------------------
  |  Branch (10533:9): [True: 0, False: 68]
  ------------------
10534|      0|	xmlErrMemory(ctxt, NULL);
10535|      0|	return(NULL);
10536|      0|    }
10537|     68|    cur = CUR;
  ------------------
  |  | 2222|     68|#define CUR (*ctxt->input->cur)
  ------------------
10538|     68|    if (!((cur >= '0') && (cur <= '9'))) {
  ------------------
  |  Branch (10538:11): [True: 68, False: 0]
  |  Branch (10538:27): [True: 68, False: 0]
  ------------------
10539|      0|	xmlFree(buf);
10540|      0|	return(NULL);
10541|      0|    }
10542|     68|    buf[len++] = cur;
10543|     68|    NEXT;
  ------------------
  |  | 2275|     68|#define NEXT xmlNextChar(ctxt)
  ------------------
10544|     68|    cur=CUR;
  ------------------
  |  | 2222|     68|#define CUR (*ctxt->input->cur)
  ------------------
10545|     68|    if (cur != '.') {
  ------------------
  |  Branch (10545:9): [True: 0, False: 68]
  ------------------
10546|      0|	xmlFree(buf);
10547|      0|	return(NULL);
10548|      0|    }
10549|     68|    buf[len++] = cur;
10550|     68|    NEXT;
  ------------------
  |  | 2275|     68|#define NEXT xmlNextChar(ctxt)
  ------------------
10551|     68|    cur=CUR;
  ------------------
  |  | 2222|     68|#define CUR (*ctxt->input->cur)
  ------------------
10552|    136|    while ((cur >= '0') && (cur <= '9')) {
  ------------------
  |  Branch (10552:12): [True: 68, False: 68]
  |  Branch (10552:28): [True: 68, False: 0]
  ------------------
10553|     68|	if (len + 1 >= size) {
  ------------------
  |  Branch (10553:6): [True: 0, False: 68]
  ------------------
10554|      0|	    xmlChar *tmp;
10555|       |
10556|      0|	    size *= 2;
10557|      0|	    tmp = (xmlChar *) xmlRealloc(buf, size);
10558|      0|	    if (tmp == NULL) {
  ------------------
  |  Branch (10558:10): [True: 0, False: 0]
  ------------------
10559|      0|	        xmlFree(buf);
10560|      0|		xmlErrMemory(ctxt, NULL);
10561|      0|		return(NULL);
10562|      0|	    }
10563|      0|	    buf = tmp;
10564|      0|	}
10565|     68|	buf[len++] = cur;
10566|     68|	NEXT;
  ------------------
  |  | 2275|     68|#define NEXT xmlNextChar(ctxt)
  ------------------
10567|     68|	cur=CUR;
  ------------------
  |  | 2222|     68|#define CUR (*ctxt->input->cur)
  ------------------
10568|     68|    }
10569|     68|    buf[len] = 0;
10570|     68|    return(buf);
10571|     68|}
xmlParseVersionInfo:
10589|     72|xmlParseVersionInfo(xmlParserCtxtPtr ctxt) {
10590|     72|    xmlChar *version = NULL;
10591|       |
10592|     72|    if (CMP7(CUR_PTR, 'v', 'e', 'r', 's', 'i', 'o', 'n')) {
  ------------------
  |  | 2235|     72|  ( CMP6( s, c1, c2, c3, c4, c5, c6 ) && ((unsigned char *) s)[ 6 ] == c7 )
  |  |  ------------------
  |  |  |  | 2233|    144|  ( CMP5( s, c1, c2, c3, c4, c5 ) && ((unsigned char *) s)[ 5 ] == c6 )
  |  |  |  |  ------------------
  |  |  |  |  |  | 2231|    144|  ( CMP4( s, c1, c2, c3, c4 ) && ((unsigned char *) s)[ 4 ] == c5 )
  |  |  |  |  |  |  ------------------
  |  |  |  |  |  |  |  | 2228|    144|  ( ((unsigned char *) s)[ 0 ] == c1 && ((unsigned char *) s)[ 1 ] == c2 && \
  |  |  |  |  |  |  |  |  ------------------
  |  |  |  |  |  |  |  |  |  Branch (2228:5): [True: 72, False: 0]
  |  |  |  |  |  |  |  |  |  Branch (2228:41): [True: 72, False: 0]
  |  |  |  |  |  |  |  |  ------------------
  |  |  |  |  |  |  |  | 2229|     72|    ((unsigned char *) s)[ 2 ] == c3 && ((unsigned char *) s)[ 3 ] == c4 )
  |  |  |  |  |  |  |  |  ------------------
  |  |  |  |  |  |  |  |  |  Branch (2229:5): [True: 72, False: 0]
  |  |  |  |  |  |  |  |  |  Branch (2229:41): [True: 68, False: 4]
  |  |  |  |  |  |  |  |  ------------------
  |  |  |  |  |  |  ------------------
  |  |  |  |  |  |  |  Branch (2231:34): [True: 68, False: 0]
  |  |  |  |  |  |  ------------------
  |  |  |  |  ------------------
  |  |  |  |  |  Branch (2233:38): [True: 68, False: 0]
  |  |  |  |  ------------------
  |  |  ------------------
  |  |  |  Branch (2235:42): [True: 68, False: 0]
  |  |  ------------------
  ------------------
10593|     68|	SKIP(7);
  ------------------
  |  | 2245|     68|#define SKIP(val) do {							\
  |  | 2246|     68|    ctxt->input->cur += (val),ctxt->input->col+=(val);			\
  |  | 2247|     68|    if (*ctxt->input->cur == 0)						\
  |  |  ------------------
  |  |  |  Branch (2247:9): [True: 0, False: 68]
  |  |  ------------------
  |  | 2248|     68|        xmlParserGrow(ctxt);						\
  |  | 2249|     68|  } while (0)
  |  |  ------------------
  |  |  |  Branch (2249:12): [Folded - Ignored]
  |  |  ------------------
  ------------------
10594|     68|	SKIP_BLANKS;
  ------------------
  |  | 2273|     68|#define SKIP_BLANKS xmlSkipBlankChars(ctxt)
  ------------------
10595|     68|	if (RAW != '=') {
  ------------------
  |  | 2221|     68|#define RAW (*ctxt->input->cur)
  ------------------
  |  Branch (10595:6): [True: 0, False: 68]
  ------------------
10596|      0|	    xmlFatalErr(ctxt, XML_ERR_EQUAL_REQUIRED, NULL);
10597|      0|	    return(NULL);
10598|      0|        }
10599|     68|	NEXT;
  ------------------
  |  | 2275|     68|#define NEXT xmlNextChar(ctxt)
  ------------------
10600|     68|	SKIP_BLANKS;
  ------------------
  |  | 2273|     68|#define SKIP_BLANKS xmlSkipBlankChars(ctxt)
  ------------------
10601|     68|	if (RAW == '"') {
  ------------------
  |  | 2221|     68|#define RAW (*ctxt->input->cur)
  ------------------
  |  Branch (10601:6): [True: 68, False: 0]
  ------------------
10602|     68|	    NEXT;
  ------------------
  |  | 2275|     68|#define NEXT xmlNextChar(ctxt)
  ------------------
10603|     68|	    version = xmlParseVersionNum(ctxt);
10604|     68|	    if (RAW != '"') {
  ------------------
  |  | 2221|     68|#define RAW (*ctxt->input->cur)
  ------------------
  |  Branch (10604:10): [True: 0, False: 68]
  ------------------
10605|      0|		xmlFatalErr(ctxt, XML_ERR_STRING_NOT_CLOSED, NULL);
10606|      0|	    } else
10607|     68|	        NEXT;
  ------------------
  |  | 2275|     68|#define NEXT xmlNextChar(ctxt)
  ------------------
10608|     68|	} else if (RAW == '\''){
  ------------------
  |  | 2221|      0|#define RAW (*ctxt->input->cur)
  ------------------
  |  Branch (10608:13): [True: 0, False: 0]
  ------------------
10609|      0|	    NEXT;
  ------------------
  |  | 2275|      0|#define NEXT xmlNextChar(ctxt)
  ------------------
10610|      0|	    version = xmlParseVersionNum(ctxt);
10611|      0|	    if (RAW != '\'') {
  ------------------
  |  | 2221|      0|#define RAW (*ctxt->input->cur)
  ------------------
  |  Branch (10611:10): [True: 0, False: 0]
  ------------------
10612|      0|		xmlFatalErr(ctxt, XML_ERR_STRING_NOT_CLOSED, NULL);
10613|      0|	    } else
10614|      0|	        NEXT;
  ------------------
  |  | 2275|      0|#define NEXT xmlNextChar(ctxt)
  ------------------
10615|      0|	} else {
10616|      0|	    xmlFatalErr(ctxt, XML_ERR_STRING_NOT_STARTED, NULL);
10617|      0|	}
10618|     68|    }
10619|     72|    return(version);
10620|     72|}
xmlParseEncName:
10635|     28|xmlParseEncName(xmlParserCtxtPtr ctxt) {
10636|     28|    xmlChar *buf = NULL;
10637|     28|    int len = 0;
10638|     28|    int size = 10;
10639|     28|    int maxLength = (ctxt->options & XML_PARSE_HUGE) ?
  ------------------
  |  Branch (10639:21): [True: 0, False: 28]
  ------------------
10640|      0|                    XML_MAX_TEXT_LENGTH :
  ------------------
  |  |   42|      0|#define XML_MAX_TEXT_LENGTH 10000000
  ------------------
10641|     28|                    XML_MAX_NAME_LENGTH;
  ------------------
  |  |   61|     28|#define XML_MAX_NAME_LENGTH 50000
  ------------------
10642|     28|    xmlChar cur;
10643|       |
10644|     28|    cur = CUR;
  ------------------
  |  | 2222|     28|#define CUR (*ctxt->input->cur)
  ------------------
10645|     28|    if (((cur >= 'a') && (cur <= 'z')) ||
  ------------------
  |  Branch (10645:10): [True: 0, False: 28]
  |  Branch (10645:26): [True: 0, False: 0]
  ------------------
10646|     28|        ((cur >= 'A') && (cur <= 'Z'))) {
  ------------------
  |  Branch (10646:10): [True: 28, False: 0]
  |  Branch (10646:26): [True: 28, False: 0]
  ------------------
10647|     28|	buf = (xmlChar *) xmlMallocAtomic(size);
10648|     28|	if (buf == NULL) {
  ------------------
  |  Branch (10648:6): [True: 0, False: 28]
  ------------------
10649|      0|	    xmlErrMemory(ctxt, NULL);
10650|      0|	    return(NULL);
10651|      0|	}
10652|       |
10653|     28|	buf[len++] = cur;
10654|     28|	NEXT;
  ------------------
  |  | 2275|     28|#define NEXT xmlNextChar(ctxt)
  ------------------
10655|     28|	cur = CUR;
  ------------------
  |  | 2222|     28|#define CUR (*ctxt->input->cur)
  ------------------
10656|    210|	while (((cur >= 'a') && (cur <= 'z')) ||
  ------------------
  |  Branch (10656:10): [True: 0, False: 210]
  |  Branch (10656:26): [True: 0, False: 0]
  ------------------
10657|    210|	       ((cur >= 'A') && (cur <= 'Z')) ||
  ------------------
  |  Branch (10657:10): [True: 56, False: 154]
  |  Branch (10657:26): [True: 56, False: 0]
  ------------------
10658|    210|	       ((cur >= '0') && (cur <= '9')) ||
  ------------------
  |  Branch (10658:10): [True: 84, False: 70]
  |  Branch (10658:26): [True: 84, False: 0]
  ------------------
10659|    210|	       (cur == '.') || (cur == '_') ||
  ------------------
  |  Branch (10659:9): [True: 0, False: 70]
  |  Branch (10659:25): [True: 0, False: 70]
  ------------------
10660|    210|	       (cur == '-')) {
  ------------------
  |  Branch (10660:9): [True: 42, False: 28]
  ------------------
10661|    182|	    if (len + 1 >= size) {
  ------------------
  |  Branch (10661:10): [True: 14, False: 168]
  ------------------
10662|     14|	        xmlChar *tmp;
10663|       |
10664|     14|		size *= 2;
10665|     14|		tmp = (xmlChar *) xmlRealloc(buf, size);
10666|     14|		if (tmp == NULL) {
  ------------------
  |  Branch (10666:7): [True: 0, False: 14]
  ------------------
10667|      0|		    xmlErrMemory(ctxt, NULL);
10668|      0|		    xmlFree(buf);
10669|      0|		    return(NULL);
10670|      0|		}
10671|     14|		buf = tmp;
10672|     14|	    }
10673|    182|	    buf[len++] = cur;
10674|    182|            if (len > maxLength) {
  ------------------
  |  Branch (10674:17): [True: 0, False: 182]
  ------------------
10675|      0|                xmlFatalErr(ctxt, XML_ERR_NAME_TOO_LONG, "EncName");
10676|      0|                xmlFree(buf);
10677|      0|                return(NULL);
10678|      0|            }
10679|    182|	    NEXT;
  ------------------
  |  | 2275|    182|#define NEXT xmlNextChar(ctxt)
  ------------------
10680|    182|	    cur = CUR;
  ------------------
  |  | 2222|    182|#define CUR (*ctxt->input->cur)
  ------------------
10681|    182|        }
10682|     28|	buf[len] = 0;
10683|     28|    } else {
10684|      0|	xmlFatalErr(ctxt, XML_ERR_ENCODING_NAME, NULL);
10685|      0|    }
10686|     28|    return(buf);
10687|     28|}
xmlParseEncodingDecl:
10705|     42|xmlParseEncodingDecl(xmlParserCtxtPtr ctxt) {
10706|     42|    xmlChar *encoding = NULL;
10707|       |
10708|     42|    SKIP_BLANKS;
  ------------------
  |  | 2273|     42|#define SKIP_BLANKS xmlSkipBlankChars(ctxt)
  ------------------
10709|     42|    if (CMP8(CUR_PTR, 'e', 'n', 'c', 'o', 'd', 'i', 'n', 'g') == 0)
  ------------------
  |  | 2237|     42|  ( CMP7( s, c1, c2, c3, c4, c5, c6, c7 ) && ((unsigned char *) s)[ 7 ] == c8 )
  |  |  ------------------
  |  |  |  | 2235|     84|  ( CMP6( s, c1, c2, c3, c4, c5, c6 ) && ((unsigned char *) s)[ 6 ] == c7 )
  |  |  |  |  ------------------
  |  |  |  |  |  | 2233|     84|  ( CMP5( s, c1, c2, c3, c4, c5 ) && ((unsigned char *) s)[ 5 ] == c6 )
  |  |  |  |  |  |  ------------------
  |  |  |  |  |  |  |  | 2231|     84|  ( CMP4( s, c1, c2, c3, c4 ) && ((unsigned char *) s)[ 4 ] == c5 )
  |  |  |  |  |  |  |  |  ------------------
  |  |  |  |  |  |  |  |  |  | 2228|     84|  ( ((unsigned char *) s)[ 0 ] == c1 && ((unsigned char *) s)[ 1 ] == c2 && \
  |  |  |  |  |  |  |  |  |  |  ------------------
  |  |  |  |  |  |  |  |  |  |  |  Branch (2228:5): [True: 38, False: 4]
  |  |  |  |  |  |  |  |  |  |  |  Branch (2228:41): [True: 38, False: 0]
  |  |  |  |  |  |  |  |  |  |  ------------------
  |  |  |  |  |  |  |  |  |  | 2229|     42|    ((unsigned char *) s)[ 2 ] == c3 && ((unsigned char *) s)[ 3 ] == c4 )
  |  |  |  |  |  |  |  |  |  |  ------------------
  |  |  |  |  |  |  |  |  |  |  |  Branch (2229:5): [True: 38, False: 0]
  |  |  |  |  |  |  |  |  |  |  |  Branch (2229:41): [True: 38, False: 0]
  |  |  |  |  |  |  |  |  |  |  ------------------
  |  |  |  |  |  |  |  |  ------------------
  |  |  |  |  |  |  |  |  |  Branch (2231:34): [True: 38, False: 0]
  |  |  |  |  |  |  |  |  ------------------
  |  |  |  |  |  |  ------------------
  |  |  |  |  |  |  |  Branch (2233:38): [True: 38, False: 0]
  |  |  |  |  |  |  ------------------
  |  |  |  |  ------------------
  |  |  |  |  |  Branch (2235:42): [True: 38, False: 0]
  |  |  |  |  ------------------
  |  |  ------------------
  |  |  |  Branch (2237:46): [True: 38, False: 0]
  |  |  ------------------
  ------------------
  |  Branch (10709:9): [True: 4, False: 38]
  ------------------
10710|      4|        return(NULL);
10711|       |
10712|     38|    SKIP(8);
  ------------------
  |  | 2245|     38|#define SKIP(val) do {							\
  |  | 2246|     38|    ctxt->input->cur += (val),ctxt->input->col+=(val);			\
  |  | 2247|     38|    if (*ctxt->input->cur == 0)						\
  |  |  ------------------
  |  |  |  Branch (2247:9): [True: 0, False: 38]
  |  |  ------------------
  |  | 2248|     38|        xmlParserGrow(ctxt);						\
  |  | 2249|     38|  } while (0)
  |  |  ------------------
  |  |  |  Branch (2249:12): [Folded - Ignored]
  |  |  ------------------
  ------------------
10713|     38|    SKIP_BLANKS;
  ------------------
  |  | 2273|     38|#define SKIP_BLANKS xmlSkipBlankChars(ctxt)
  ------------------
10714|     38|    if (RAW != '=') {
  ------------------
  |  | 2221|     38|#define RAW (*ctxt->input->cur)
  ------------------
  |  Branch (10714:9): [True: 2, False: 36]
  ------------------
10715|      2|        xmlFatalErr(ctxt, XML_ERR_EQUAL_REQUIRED, NULL);
10716|      2|        return(NULL);
10717|      2|    }
10718|     36|    NEXT;
  ------------------
  |  | 2275|     36|#define NEXT xmlNextChar(ctxt)
  ------------------
10719|     36|    SKIP_BLANKS;
  ------------------
  |  | 2273|     36|#define SKIP_BLANKS xmlSkipBlankChars(ctxt)
  ------------------
10720|     36|    if (RAW == '"') {
  ------------------
  |  | 2221|     36|#define RAW (*ctxt->input->cur)
  ------------------
  |  Branch (10720:9): [True: 28, False: 8]
  ------------------
10721|     28|        NEXT;
  ------------------
  |  | 2275|     28|#define NEXT xmlNextChar(ctxt)
  ------------------
10722|     28|        encoding = xmlParseEncName(ctxt);
10723|     28|        if (RAW != '"') {
  ------------------
  |  | 2221|     28|#define RAW (*ctxt->input->cur)
  ------------------
  |  Branch (10723:13): [True: 0, False: 28]
  ------------------
10724|      0|            xmlFatalErr(ctxt, XML_ERR_STRING_NOT_CLOSED, NULL);
10725|      0|            xmlFree((xmlChar *) encoding);
10726|      0|            return(NULL);
10727|      0|        } else
10728|     28|            NEXT;
  ------------------
  |  | 2275|     28|#define NEXT xmlNextChar(ctxt)
  ------------------
10729|     28|    } else if (RAW == '\''){
  ------------------
  |  | 2221|      8|#define RAW (*ctxt->input->cur)
  ------------------
  |  Branch (10729:16): [True: 0, False: 8]
  ------------------
10730|      0|        NEXT;
  ------------------
  |  | 2275|      0|#define NEXT xmlNextChar(ctxt)
  ------------------
10731|      0|        encoding = xmlParseEncName(ctxt);
10732|      0|        if (RAW != '\'') {
  ------------------
  |  | 2221|      0|#define RAW (*ctxt->input->cur)
  ------------------
  |  Branch (10732:13): [True: 0, False: 0]
  ------------------
10733|      0|            xmlFatalErr(ctxt, XML_ERR_STRING_NOT_CLOSED, NULL);
10734|      0|            xmlFree((xmlChar *) encoding);
10735|      0|            return(NULL);
10736|      0|        } else
10737|      0|            NEXT;
  ------------------
  |  | 2275|      0|#define NEXT xmlNextChar(ctxt)
  ------------------
10738|      8|    } else {
10739|      8|        xmlFatalErr(ctxt, XML_ERR_STRING_NOT_STARTED, NULL);
10740|      8|    }
10741|       |
10742|     36|    if (encoding == NULL)
  ------------------
  |  Branch (10742:9): [True: 8, False: 28]
  ------------------
10743|      8|        return(NULL);
10744|       |
10745|     28|    xmlSetDeclaredEncoding(ctxt, encoding);
10746|       |
10747|     28|    return(ctxt->encoding);
10748|     36|}
xmlParseSDDecl:
10784|     14|xmlParseSDDecl(xmlParserCtxtPtr ctxt) {
10785|     14|    int standalone = -2;
10786|       |
10787|     14|    SKIP_BLANKS;
  ------------------
  |  | 2273|     14|#define SKIP_BLANKS xmlSkipBlankChars(ctxt)
  ------------------
10788|     14|    if (CMP10(CUR_PTR, 's', 't', 'a', 'n', 'd', 'a', 'l', 'o', 'n', 'e')) {
  ------------------
  |  | 2242|     14|  ( CMP9( s, c1, c2, c3, c4, c5, c6, c7, c8, c9 ) && \
  |  |  ------------------
  |  |  |  | 2239|     28|  ( CMP8( s, c1, c2, c3, c4, c5, c6, c7, c8 ) && \
  |  |  |  |  ------------------
  |  |  |  |  |  | 2237|     28|  ( CMP7( s, c1, c2, c3, c4, c5, c6, c7 ) && ((unsigned char *) s)[ 7 ] == c8 )
  |  |  |  |  |  |  ------------------
  |  |  |  |  |  |  |  | 2235|     28|  ( CMP6( s, c1, c2, c3, c4, c5, c6 ) && ((unsigned char *) s)[ 6 ] == c7 )
  |  |  |  |  |  |  |  |  ------------------
  |  |  |  |  |  |  |  |  |  | 2233|     28|  ( CMP5( s, c1, c2, c3, c4, c5 ) && ((unsigned char *) s)[ 5 ] == c6 )
  |  |  |  |  |  |  |  |  |  |  ------------------
  |  |  |  |  |  |  |  |  |  |  |  | 2231|     28|  ( CMP4( s, c1, c2, c3, c4 ) && ((unsigned char *) s)[ 4 ] == c5 )
  |  |  |  |  |  |  |  |  |  |  |  |  ------------------
  |  |  |  |  |  |  |  |  |  |  |  |  |  | 2228|     28|  ( ((unsigned char *) s)[ 0 ] == c1 && ((unsigned char *) s)[ 1 ] == c2 && \
  |  |  |  |  |  |  |  |  |  |  |  |  |  |  ------------------
  |  |  |  |  |  |  |  |  |  |  |  |  |  |  |  Branch (2228:5): [True: 0, False: 14]
  |  |  |  |  |  |  |  |  |  |  |  |  |  |  |  Branch (2228:41): [True: 0, False: 0]
  |  |  |  |  |  |  |  |  |  |  |  |  |  |  ------------------
  |  |  |  |  |  |  |  |  |  |  |  |  |  | 2229|     14|    ((unsigned char *) s)[ 2 ] == c3 && ((unsigned char *) s)[ 3 ] == c4 )
  |  |  |  |  |  |  |  |  |  |  |  |  |  |  ------------------
  |  |  |  |  |  |  |  |  |  |  |  |  |  |  |  Branch (2229:5): [True: 0, False: 0]
  |  |  |  |  |  |  |  |  |  |  |  |  |  |  |  Branch (2229:41): [True: 0, False: 0]
  |  |  |  |  |  |  |  |  |  |  |  |  |  |  ------------------
  |  |  |  |  |  |  |  |  |  |  |  |  ------------------
  |  |  |  |  |  |  |  |  |  |  |  |  |  Branch (2231:34): [True: 0, False: 0]
  |  |  |  |  |  |  |  |  |  |  |  |  ------------------
  |  |  |  |  |  |  |  |  |  |  ------------------
  |  |  |  |  |  |  |  |  |  |  |  Branch (2233:38): [True: 0, False: 0]
  |  |  |  |  |  |  |  |  |  |  ------------------
  |  |  |  |  |  |  |  |  ------------------
  |  |  |  |  |  |  |  |  |  Branch (2235:42): [True: 0, False: 0]
  |  |  |  |  |  |  |  |  ------------------
  |  |  |  |  |  |  ------------------
  |  |  |  |  |  |  |  Branch (2237:46): [True: 0, False: 0]
  |  |  |  |  |  |  ------------------
  |  |  |  |  ------------------
  |  |  |  | 2240|     28|    ((unsigned char *) s)[ 8 ] == c9 )
  |  |  |  |  ------------------
  |  |  |  |  |  Branch (2240:5): [True: 0, False: 0]
  |  |  |  |  ------------------
  |  |  ------------------
  |  | 2243|     14|    ((unsigned char *) s)[ 9 ] == c10 )
  |  |  ------------------
  |  |  |  Branch (2243:5): [True: 0, False: 0]
  |  |  ------------------
  ------------------
10789|      0|	SKIP(10);
  ------------------
  |  | 2245|      0|#define SKIP(val) do {							\
  |  | 2246|      0|    ctxt->input->cur += (val),ctxt->input->col+=(val);			\
  |  | 2247|      0|    if (*ctxt->input->cur == 0)						\
  |  |  ------------------
  |  |  |  Branch (2247:9): [True: 0, False: 0]
  |  |  ------------------
  |  | 2248|      0|        xmlParserGrow(ctxt);						\
  |  | 2249|      0|  } while (0)
  |  |  ------------------
  |  |  |  Branch (2249:12): [Folded - Ignored]
  |  |  ------------------
  ------------------
10790|      0|        SKIP_BLANKS;
  ------------------
  |  | 2273|      0|#define SKIP_BLANKS xmlSkipBlankChars(ctxt)
  ------------------
10791|      0|	if (RAW != '=') {
  ------------------
  |  | 2221|      0|#define RAW (*ctxt->input->cur)
  ------------------
  |  Branch (10791:6): [True: 0, False: 0]
  ------------------
10792|      0|	    xmlFatalErr(ctxt, XML_ERR_EQUAL_REQUIRED, NULL);
10793|      0|	    return(standalone);
10794|      0|        }
10795|      0|	NEXT;
  ------------------
  |  | 2275|      0|#define NEXT xmlNextChar(ctxt)
  ------------------
10796|      0|	SKIP_BLANKS;
  ------------------
  |  | 2273|      0|#define SKIP_BLANKS xmlSkipBlankChars(ctxt)
  ------------------
10797|      0|        if (RAW == '\''){
  ------------------
  |  | 2221|      0|#define RAW (*ctxt->input->cur)
  ------------------
  |  Branch (10797:13): [True: 0, False: 0]
  ------------------
10798|      0|	    NEXT;
  ------------------
  |  | 2275|      0|#define NEXT xmlNextChar(ctxt)
  ------------------
10799|      0|	    if ((RAW == 'n') && (NXT(1) == 'o')) {
  ------------------
  |  | 2221|      0|#define RAW (*ctxt->input->cur)
  ------------------
              	    if ((RAW == 'n') && (NXT(1) == 'o')) {
  ------------------
  |  | 2223|      0|#define NXT(val) ctxt->input->cur[(val)]
  ------------------
  |  Branch (10799:10): [True: 0, False: 0]
  |  Branch (10799:26): [True: 0, False: 0]
  ------------------
10800|      0|	        standalone = 0;
10801|      0|                SKIP(2);
  ------------------
  |  | 2245|      0|#define SKIP(val) do {							\
  |  | 2246|      0|    ctxt->input->cur += (val),ctxt->input->col+=(val);			\
  |  | 2247|      0|    if (*ctxt->input->cur == 0)						\
  |  |  ------------------
  |  |  |  Branch (2247:9): [True: 0, False: 0]
  |  |  ------------------
  |  | 2248|      0|        xmlParserGrow(ctxt);						\
  |  | 2249|      0|  } while (0)
  |  |  ------------------
  |  |  |  Branch (2249:12): [Folded - Ignored]
  |  |  ------------------
  ------------------
10802|      0|	    } else if ((RAW == 'y') && (NXT(1) == 'e') &&
  ------------------
  |  | 2221|      0|#define RAW (*ctxt->input->cur)
  ------------------
              	    } else if ((RAW == 'y') && (NXT(1) == 'e') &&
  ------------------
  |  | 2223|      0|#define NXT(val) ctxt->input->cur[(val)]
  ------------------
  |  Branch (10802:17): [True: 0, False: 0]
  |  Branch (10802:33): [True: 0, False: 0]
  ------------------
10803|      0|	               (NXT(2) == 's')) {
  ------------------
  |  | 2223|      0|#define NXT(val) ctxt->input->cur[(val)]
  ------------------
  |  Branch (10803:17): [True: 0, False: 0]
  ------------------
10804|      0|	        standalone = 1;
10805|      0|		SKIP(3);
  ------------------
  |  | 2245|      0|#define SKIP(val) do {							\
  |  | 2246|      0|    ctxt->input->cur += (val),ctxt->input->col+=(val);			\
  |  | 2247|      0|    if (*ctxt->input->cur == 0)						\
  |  |  ------------------
  |  |  |  Branch (2247:9): [True: 0, False: 0]
  |  |  ------------------
  |  | 2248|      0|        xmlParserGrow(ctxt);						\
  |  | 2249|      0|  } while (0)
  |  |  ------------------
  |  |  |  Branch (2249:12): [Folded - Ignored]
  |  |  ------------------
  ------------------
10806|      0|            } else {
10807|      0|		xmlFatalErr(ctxt, XML_ERR_STANDALONE_VALUE, NULL);
10808|      0|	    }
10809|      0|	    if (RAW != '\'') {
  ------------------
  |  | 2221|      0|#define RAW (*ctxt->input->cur)
  ------------------
  |  Branch (10809:10): [True: 0, False: 0]
  ------------------
10810|      0|		xmlFatalErr(ctxt, XML_ERR_STRING_NOT_CLOSED, NULL);
10811|      0|	    } else
10812|      0|	        NEXT;
  ------------------
  |  | 2275|      0|#define NEXT xmlNextChar(ctxt)
  ------------------
10813|      0|	} else if (RAW == '"'){
  ------------------
  |  | 2221|      0|#define RAW (*ctxt->input->cur)
  ------------------
  |  Branch (10813:13): [True: 0, False: 0]
  ------------------
10814|      0|	    NEXT;
  ------------------
  |  | 2275|      0|#define NEXT xmlNextChar(ctxt)
  ------------------
10815|      0|	    if ((RAW == 'n') && (NXT(1) == 'o')) {
  ------------------
  |  | 2221|      0|#define RAW (*ctxt->input->cur)
  ------------------
              	    if ((RAW == 'n') && (NXT(1) == 'o')) {
  ------------------
  |  | 2223|      0|#define NXT(val) ctxt->input->cur[(val)]
  ------------------
  |  Branch (10815:10): [True: 0, False: 0]
  |  Branch (10815:26): [True: 0, False: 0]
  ------------------
10816|      0|	        standalone = 0;
10817|      0|		SKIP(2);
  ------------------
  |  | 2245|      0|#define SKIP(val) do {							\
  |  | 2246|      0|    ctxt->input->cur += (val),ctxt->input->col+=(val);			\
  |  | 2247|      0|    if (*ctxt->input->cur == 0)						\
  |  |  ------------------
  |  |  |  Branch (2247:9): [True: 0, False: 0]
  |  |  ------------------
  |  | 2248|      0|        xmlParserGrow(ctxt);						\
  |  | 2249|      0|  } while (0)
  |  |  ------------------
  |  |  |  Branch (2249:12): [Folded - Ignored]
  |  |  ------------------
  ------------------
10818|      0|	    } else if ((RAW == 'y') && (NXT(1) == 'e') &&
  ------------------
  |  | 2221|      0|#define RAW (*ctxt->input->cur)
  ------------------
              	    } else if ((RAW == 'y') && (NXT(1) == 'e') &&
  ------------------
  |  | 2223|      0|#define NXT(val) ctxt->input->cur[(val)]
  ------------------
  |  Branch (10818:17): [True: 0, False: 0]
  |  Branch (10818:33): [True: 0, False: 0]
  ------------------
10819|      0|	               (NXT(2) == 's')) {
  ------------------
  |  | 2223|      0|#define NXT(val) ctxt->input->cur[(val)]
  ------------------
  |  Branch (10819:17): [True: 0, False: 0]
  ------------------
10820|      0|	        standalone = 1;
10821|      0|                SKIP(3);
  ------------------
  |  | 2245|      0|#define SKIP(val) do {							\
  |  | 2246|      0|    ctxt->input->cur += (val),ctxt->input->col+=(val);			\
  |  | 2247|      0|    if (*ctxt->input->cur == 0)						\
  |  |  ------------------
  |  |  |  Branch (2247:9): [True: 0, False: 0]
  |  |  ------------------
  |  | 2248|      0|        xmlParserGrow(ctxt);						\
  |  | 2249|      0|  } while (0)
  |  |  ------------------
  |  |  |  Branch (2249:12): [Folded - Ignored]
  |  |  ------------------
  ------------------
10822|      0|            } else {
10823|      0|		xmlFatalErr(ctxt, XML_ERR_STANDALONE_VALUE, NULL);
10824|      0|	    }
10825|      0|	    if (RAW != '"') {
  ------------------
  |  | 2221|      0|#define RAW (*ctxt->input->cur)
  ------------------
  |  Branch (10825:10): [True: 0, False: 0]
  ------------------
10826|      0|		xmlFatalErr(ctxt, XML_ERR_STRING_NOT_CLOSED, NULL);
10827|      0|	    } else
10828|      0|	        NEXT;
  ------------------
  |  | 2275|      0|#define NEXT xmlNextChar(ctxt)
  ------------------
10829|      0|	} else {
10830|      0|	    xmlFatalErr(ctxt, XML_ERR_STRING_NOT_STARTED, NULL);
10831|      0|        }
10832|      0|    }
10833|     14|    return(standalone);
10834|     14|}
xmlParseXMLDecl:
10848|     72|xmlParseXMLDecl(xmlParserCtxtPtr ctxt) {
10849|     72|    xmlChar *version;
10850|       |
10851|       |    /*
10852|       |     * This value for standalone indicates that the document has an
10853|       |     * XML declaration but it does not have a standalone attribute.
10854|       |     * It will be overwritten later if a standalone attribute is found.
10855|       |     */
10856|       |
10857|     72|    ctxt->standalone = -2;
10858|       |
10859|       |    /*
10860|       |     * We know that '<?xml' is here.
10861|       |     */
10862|     72|    SKIP(5);
  ------------------
  |  | 2245|     72|#define SKIP(val) do {							\
  |  | 2246|     72|    ctxt->input->cur += (val),ctxt->input->col+=(val);			\
  |  | 2247|     72|    if (*ctxt->input->cur == 0)						\
  |  |  ------------------
  |  |  |  Branch (2247:9): [True: 0, False: 72]
  |  |  ------------------
  |  | 2248|     72|        xmlParserGrow(ctxt);						\
  |  | 2249|     72|  } while (0)
  |  |  ------------------
  |  |  |  Branch (2249:12): [Folded - Ignored]
  |  |  ------------------
  ------------------
10863|       |
10864|     72|    if (!IS_BLANK_CH(RAW)) {
  ------------------
  |  |  151|     72|#define IS_BLANK_CH(c)  xmlIsBlank_ch(c)
  |  |  ------------------
  |  |  |  |   88|     72|#define xmlIsBlank_ch(c)	(((c) == 0x20) || \
  |  |  |  |  ------------------
  |  |  |  |  |  Branch (88:27): [True: 72, False: 0]
  |  |  |  |  ------------------
  |  |  |  |   89|     72|				 ((0x9 <= (c)) && ((c) <= 0xa)) || \
  |  |  |  |  ------------------
  |  |  |  |  |  Branch (89:7): [True: 0, False: 0]
  |  |  |  |  |  Branch (89:23): [True: 0, False: 0]
  |  |  |  |  ------------------
  |  |  |  |   90|     72|				 ((c) == 0xd))
  |  |  |  |  ------------------
  |  |  |  |  |  Branch (90:6): [True: 0, False: 0]
  |  |  |  |  ------------------
  |  |  ------------------
  ------------------
10865|      0|	xmlFatalErrMsg(ctxt, XML_ERR_SPACE_REQUIRED,
10866|      0|	               "Blank needed after '<?xml'\n");
10867|      0|    }
10868|     72|    SKIP_BLANKS;
  ------------------
  |  | 2273|     72|#define SKIP_BLANKS xmlSkipBlankChars(ctxt)
  ------------------
10869|       |
10870|       |    /*
10871|       |     * We must have the VersionInfo here.
10872|       |     */
10873|     72|    version = xmlParseVersionInfo(ctxt);
10874|     72|    if (version == NULL) {
  ------------------
  |  Branch (10874:9): [True: 4, False: 68]
  ------------------
10875|      4|	xmlFatalErr(ctxt, XML_ERR_VERSION_MISSING, NULL);
10876|     68|    } else {
10877|     68|	if (!xmlStrEqual(version, (const xmlChar *) XML_DEFAULT_VERSION)) {
  ------------------
  |  |   37|     68|#define XML_DEFAULT_VERSION	"1.0"
  ------------------
  |  Branch (10877:6): [True: 0, False: 68]
  ------------------
10878|       |	    /*
10879|       |	     * Changed here for XML-1.0 5th edition
10880|       |	     */
10881|      0|	    if (ctxt->options & XML_PARSE_OLD10) {
  ------------------
  |  Branch (10881:10): [True: 0, False: 0]
  ------------------
10882|      0|		xmlFatalErrMsgStr(ctxt, XML_ERR_UNKNOWN_VERSION,
10883|      0|			          "Unsupported version '%s'\n",
10884|      0|			          version);
10885|      0|	    } else {
10886|      0|	        if ((version[0] == '1') && ((version[1] == '.'))) {
  ------------------
  |  Branch (10886:14): [True: 0, False: 0]
  |  Branch (10886:37): [True: 0, False: 0]
  ------------------
10887|      0|		    xmlWarningMsg(ctxt, XML_WAR_UNKNOWN_VERSION,
10888|      0|		                  "Unsupported version '%s'\n",
10889|      0|				  version, NULL);
10890|      0|		} else {
10891|      0|		    xmlFatalErrMsgStr(ctxt, XML_ERR_UNKNOWN_VERSION,
10892|      0|				      "Unsupported version '%s'\n",
10893|      0|				      version);
10894|      0|		}
10895|      0|	    }
10896|      0|	}
10897|     68|	if (ctxt->version != NULL)
  ------------------
  |  Branch (10897:6): [True: 0, False: 68]
  ------------------
10898|      0|	    xmlFree((void *) ctxt->version);
10899|     68|	ctxt->version = version;
10900|     68|    }
10901|       |
10902|       |    /*
10903|       |     * We may have the encoding declaration
10904|       |     */
10905|     72|    if (!IS_BLANK_CH(RAW)) {
  ------------------
  |  |  151|     72|#define IS_BLANK_CH(c)  xmlIsBlank_ch(c)
  |  |  ------------------
  |  |  |  |   88|     72|#define xmlIsBlank_ch(c)	(((c) == 0x20) || \
  |  |  |  |  ------------------
  |  |  |  |  |  Branch (88:27): [True: 38, False: 34]
  |  |  |  |  ------------------
  |  |  |  |   89|     72|				 ((0x9 <= (c)) && ((c) <= 0xa)) || \
  |  |  |  |  ------------------
  |  |  |  |  |  Branch (89:7): [True: 34, False: 0]
  |  |  |  |  |  Branch (89:23): [True: 0, False: 34]
  |  |  |  |  ------------------
  |  |  |  |   90|     72|				 ((c) == 0xd))
  |  |  |  |  ------------------
  |  |  |  |  |  Branch (90:6): [True: 0, False: 34]
  |  |  |  |  ------------------
  |  |  ------------------
  ------------------
10906|     34|        if ((RAW == '?') && (NXT(1) == '>')) {
  ------------------
  |  | 2221|     34|#define RAW (*ctxt->input->cur)
  ------------------
                      if ((RAW == '?') && (NXT(1) == '>')) {
  ------------------
  |  | 2223|     30|#define NXT(val) ctxt->input->cur[(val)]
  ------------------
  |  Branch (10906:13): [True: 30, False: 4]
  |  Branch (10906:29): [True: 30, False: 0]
  ------------------
10907|     30|	    SKIP(2);
  ------------------
  |  | 2245|     30|#define SKIP(val) do {							\
  |  | 2246|     30|    ctxt->input->cur += (val),ctxt->input->col+=(val);			\
  |  | 2247|     30|    if (*ctxt->input->cur == 0)						\
  |  |  ------------------
  |  |  |  Branch (2247:9): [True: 0, False: 30]
  |  |  ------------------
  |  | 2248|     30|        xmlParserGrow(ctxt);						\
  |  | 2249|     30|  } while (0)
  |  |  ------------------
  |  |  |  Branch (2249:12): [Folded - Ignored]
  |  |  ------------------
  ------------------
10908|     30|	    return;
10909|     30|	}
10910|      4|	xmlFatalErrMsg(ctxt, XML_ERR_SPACE_REQUIRED, "Blank needed here\n");
10911|      4|    }
10912|     42|    xmlParseEncodingDecl(ctxt);
10913|     42|    if ((ctxt->errNo == XML_ERR_UNSUPPORTED_ENCODING) ||
  ------------------
  |  Branch (10913:9): [True: 0, False: 42]
  ------------------
10914|     42|         (ctxt->instate == XML_PARSER_EOF)) {
  ------------------
  |  Branch (10914:10): [True: 0, False: 42]
  ------------------
10915|       |	/*
10916|       |	 * The XML REC instructs us to stop parsing right here
10917|       |	 */
10918|      0|        return;
10919|      0|    }
10920|       |
10921|       |    /*
10922|       |     * We may have the standalone status.
10923|       |     */
10924|     42|    if ((ctxt->encoding != NULL) && (!IS_BLANK_CH(RAW))) {
  ------------------
  |  |  151|     28|#define IS_BLANK_CH(c)  xmlIsBlank_ch(c)
  |  |  ------------------
  |  |  |  |   88|     28|#define xmlIsBlank_ch(c)	(((c) == 0x20) || \
  |  |  |  |  ------------------
  |  |  |  |  |  Branch (88:27): [True: 0, False: 28]
  |  |  |  |  ------------------
  |  |  |  |   89|     28|				 ((0x9 <= (c)) && ((c) <= 0xa)) || \
  |  |  |  |  ------------------
  |  |  |  |  |  Branch (89:7): [True: 28, False: 0]
  |  |  |  |  |  Branch (89:23): [True: 0, False: 28]
  |  |  |  |  ------------------
  |  |  |  |   90|     28|				 ((c) == 0xd))
  |  |  |  |  ------------------
  |  |  |  |  |  Branch (90:6): [True: 0, False: 28]
  |  |  |  |  ------------------
  |  |  ------------------
  ------------------
  |  Branch (10924:9): [True: 28, False: 14]
  ------------------
10925|     28|        if ((RAW == '?') && (NXT(1) == '>')) {
  ------------------
  |  | 2221|     28|#define RAW (*ctxt->input->cur)
  ------------------
                      if ((RAW == '?') && (NXT(1) == '>')) {
  ------------------
  |  | 2223|     28|#define NXT(val) ctxt->input->cur[(val)]
  ------------------
  |  Branch (10925:13): [True: 28, False: 0]
  |  Branch (10925:29): [True: 28, False: 0]
  ------------------
10926|     28|	    SKIP(2);
  ------------------
  |  | 2245|     28|#define SKIP(val) do {							\
  |  | 2246|     28|    ctxt->input->cur += (val),ctxt->input->col+=(val);			\
  |  | 2247|     28|    if (*ctxt->input->cur == 0)						\
  |  |  ------------------
  |  |  |  Branch (2247:9): [True: 0, False: 28]
  |  |  ------------------
  |  | 2248|     28|        xmlParserGrow(ctxt);						\
  |  | 2249|     28|  } while (0)
  |  |  ------------------
  |  |  |  Branch (2249:12): [Folded - Ignored]
  |  |  ------------------
  ------------------
10927|     28|	    return;
10928|     28|	}
10929|      0|	xmlFatalErrMsg(ctxt, XML_ERR_SPACE_REQUIRED, "Blank needed here\n");
10930|      0|    }
10931|       |
10932|       |    /*
10933|       |     * We can grow the input buffer freely at that point
10934|       |     */
10935|     14|    GROW;
  ------------------
  |  | 2270|     14|#define GROW if (ctxt->input->end - ctxt->input->cur < INPUT_CHUNK)	\
  |  |  ------------------
  |  |  |  |   97|     14|#define INPUT_CHUNK	250
  |  |  ------------------
  |  |  |  Branch (2270:18): [True: 6, False: 8]
  |  |  ------------------
  |  | 2271|     14|	xmlParserGrow(ctxt);
  ------------------
10936|       |
10937|     14|    SKIP_BLANKS;
  ------------------
  |  | 2273|     14|#define SKIP_BLANKS xmlSkipBlankChars(ctxt)
  ------------------
10938|     14|    ctxt->standalone = xmlParseSDDecl(ctxt);
10939|       |
10940|     14|    SKIP_BLANKS;
  ------------------
  |  | 2273|     14|#define SKIP_BLANKS xmlSkipBlankChars(ctxt)
  ------------------
10941|     14|    if ((RAW == '?') && (NXT(1) == '>')) {
  ------------------
  |  | 2221|     14|#define RAW (*ctxt->input->cur)
  ------------------
                  if ((RAW == '?') && (NXT(1) == '>')) {
  ------------------
  |  | 2223|      0|#define NXT(val) ctxt->input->cur[(val)]
  ------------------
  |  Branch (10941:9): [True: 0, False: 14]
  |  Branch (10941:25): [True: 0, False: 0]
  ------------------
10942|      0|        SKIP(2);
  ------------------
  |  | 2245|      0|#define SKIP(val) do {							\
  |  | 2246|      0|    ctxt->input->cur += (val),ctxt->input->col+=(val);			\
  |  | 2247|      0|    if (*ctxt->input->cur == 0)						\
  |  |  ------------------
  |  |  |  Branch (2247:9): [True: 0, False: 0]
  |  |  ------------------
  |  | 2248|      0|        xmlParserGrow(ctxt);						\
  |  | 2249|      0|  } while (0)
  |  |  ------------------
  |  |  |  Branch (2249:12): [Folded - Ignored]
  |  |  ------------------
  ------------------
10943|     14|    } else if (RAW == '>') {
  ------------------
  |  | 2221|     14|#define RAW (*ctxt->input->cur)
  ------------------
  |  Branch (10943:16): [True: 0, False: 14]
  ------------------
10944|       |        /* Deprecated old WD ... */
10945|      0|	xmlFatalErr(ctxt, XML_ERR_XMLDECL_NOT_FINISHED, NULL);
10946|      0|	NEXT;
  ------------------
  |  | 2275|      0|#define NEXT xmlNextChar(ctxt)
  ------------------
10947|     14|    } else {
10948|     14|        int c;
10949|       |
10950|     14|	xmlFatalErr(ctxt, XML_ERR_XMLDECL_NOT_FINISHED, NULL);
10951|     64|        while ((c = CUR) != 0) {
  ------------------
  |  | 2222|     64|#define CUR (*ctxt->input->cur)
  ------------------
  |  Branch (10951:16): [True: 56, False: 8]
  ------------------
10952|     56|            NEXT;
  ------------------
  |  | 2275|     56|#define NEXT xmlNextChar(ctxt)
  ------------------
10953|     56|            if (c == '>')
  ------------------
  |  Branch (10953:17): [True: 6, False: 50]
  ------------------
10954|      6|                break;
10955|     56|        }
10956|     14|    }
10957|     14|}
xmlParseMisc:
10971|    385|xmlParseMisc(xmlParserCtxtPtr ctxt) {
10972|    387|    while (ctxt->instate != XML_PARSER_EOF) {
  ------------------
  |  Branch (10972:12): [True: 387, False: 0]
  ------------------
10973|    387|        SKIP_BLANKS;
  ------------------
  |  | 2273|    387|#define SKIP_BLANKS xmlSkipBlankChars(ctxt)
  ------------------
10974|    387|        GROW;
  ------------------
  |  | 2270|    387|#define GROW if (ctxt->input->end - ctxt->input->cur < INPUT_CHUNK)	\
  |  |  ------------------
  |  |  |  |   97|    387|#define INPUT_CHUNK	250
  |  |  ------------------
  |  |  |  Branch (2270:18): [True: 316, False: 71]
  |  |  ------------------
  |  | 2271|    387|	xmlParserGrow(ctxt);
  ------------------
10975|    387|        if ((RAW == '<') && (NXT(1) == '?')) {
  ------------------
  |  | 2221|    387|#define RAW (*ctxt->input->cur)
  ------------------
                      if ((RAW == '<') && (NXT(1) == '?')) {
  ------------------
  |  | 2223|    215|#define NXT(val) ctxt->input->cur[(val)]
  ------------------
  |  Branch (10975:13): [True: 215, False: 172]
  |  Branch (10975:29): [True: 2, False: 213]
  ------------------
10976|      2|	    xmlParsePI(ctxt);
10977|    385|        } else if (CMP4(CUR_PTR, '<', '!', '-', '-')) {
  ------------------
  |  | 2228|    385|  ( ((unsigned char *) s)[ 0 ] == c1 && ((unsigned char *) s)[ 1 ] == c2 && \
  |  |  ------------------
  |  |  |  Branch (2228:5): [True: 213, False: 172]
  |  |  |  Branch (2228:41): [True: 11, False: 202]
  |  |  ------------------
  |  | 2229|    385|    ((unsigned char *) s)[ 2 ] == c3 && ((unsigned char *) s)[ 3 ] == c4 )
  |  |  ------------------
  |  |  |  Branch (2229:5): [True: 0, False: 11]
  |  |  |  Branch (2229:41): [True: 0, False: 0]
  |  |  ------------------
  ------------------
10978|      0|	    xmlParseComment(ctxt);
10979|    385|        } else {
10980|    385|            break;
10981|    385|        }
10982|    387|    }
10983|    385|}
xmlParseDocument:
11001|    196|xmlParseDocument(xmlParserCtxtPtr ctxt) {
11002|    196|    xmlInitParser();
11003|       |
11004|    196|    if ((ctxt == NULL) || (ctxt->input == NULL))
  ------------------
  |  Branch (11004:9): [True: 0, False: 196]
  |  Branch (11004:27): [True: 0, False: 196]
  ------------------
11005|      0|        return(-1);
11006|       |
11007|    196|    GROW;
  ------------------
  |  | 2270|    196|#define GROW if (ctxt->input->end - ctxt->input->cur < INPUT_CHUNK)	\
  |  |  ------------------
  |  |  |  |   97|    196|#define INPUT_CHUNK	250
  |  |  ------------------
  |  |  |  Branch (2270:18): [True: 196, False: 0]
  |  |  ------------------
  |  | 2271|    196|	xmlParserGrow(ctxt);
  ------------------
11008|       |
11009|       |    /*
11010|       |     * SAX: detecting the level.
11011|       |     */
11012|    196|    xmlDetectSAX2(ctxt);
11013|       |
11014|       |    /*
11015|       |     * SAX: beginning of the document processing.
11016|       |     */
11017|    196|    if ((ctxt->sax) && (ctxt->sax->setDocumentLocator))
  ------------------
  |  Branch (11017:9): [True: 196, False: 0]
  |  Branch (11017:24): [True: 196, False: 0]
  ------------------
11018|    196|        ctxt->sax->setDocumentLocator(ctxt->userData, &xmlDefaultSAXLocator);
  ------------------
  |  |  861|    196|  #define xmlDefaultSAXLocator XML_GLOBAL_MACRO(xmlDefaultSAXLocator)
  |  |  ------------------
  |  |  |  |  500|    196|  #define XML_GLOBAL_MACRO(name) (*__##name())
  |  |  ------------------
  ------------------
11019|    196|    if (ctxt->instate == XML_PARSER_EOF)
  ------------------
  |  Branch (11019:9): [True: 0, False: 196]
  ------------------
11020|      0|	return(-1);
11021|       |
11022|    196|    xmlDetectEncoding(ctxt);
11023|       |
11024|    196|    if (CUR == 0) {
  ------------------
  |  | 2222|    196|#define CUR (*ctxt->input->cur)
  ------------------
  |  Branch (11024:9): [True: 0, False: 196]
  ------------------
11025|      0|	xmlFatalErr(ctxt, XML_ERR_DOCUMENT_EMPTY, NULL);
11026|      0|	return(-1);
11027|      0|    }
11028|       |
11029|    196|    GROW;
  ------------------
  |  | 2270|    196|#define GROW if (ctxt->input->end - ctxt->input->cur < INPUT_CHUNK)	\
  |  |  ------------------
  |  |  |  |   97|    196|#define INPUT_CHUNK	250
  |  |  ------------------
  |  |  |  Branch (2270:18): [True: 131, False: 65]
  |  |  ------------------
  |  | 2271|    196|	xmlParserGrow(ctxt);
  ------------------
11030|    196|    if ((CMP5(CUR_PTR, '<', '?', 'x', 'm', 'l')) && (IS_BLANK_CH(NXT(5)))) {
  ------------------
  |  | 2231|    196|  ( CMP4( s, c1, c2, c3, c4 ) && ((unsigned char *) s)[ 4 ] == c5 )
  |  |  ------------------
  |  |  |  | 2228|    392|  ( ((unsigned char *) s)[ 0 ] == c1 && ((unsigned char *) s)[ 1 ] == c2 && \
  |  |  |  |  ------------------
  |  |  |  |  |  Branch (2228:5): [True: 188, False: 8]
  |  |  |  |  |  Branch (2228:41): [True: 37, False: 151]
  |  |  |  |  ------------------
  |  |  |  | 2229|    196|    ((unsigned char *) s)[ 2 ] == c3 && ((unsigned char *) s)[ 3 ] == c4 )
  |  |  |  |  ------------------
  |  |  |  |  |  Branch (2229:5): [True: 37, False: 0]
  |  |  |  |  |  Branch (2229:41): [True: 36, False: 1]
  |  |  |  |  ------------------
  |  |  ------------------
  |  |  |  Branch (2231:34): [True: 36, False: 0]
  |  |  ------------------
  ------------------
                  if ((CMP5(CUR_PTR, '<', '?', 'x', 'm', 'l')) && (IS_BLANK_CH(NXT(5)))) {
  ------------------
  |  |  151|     36|#define IS_BLANK_CH(c)  xmlIsBlank_ch(c)
  |  |  ------------------
  |  |  |  |   88|     36|#define xmlIsBlank_ch(c)	(((c) == 0x20) || \
  |  |  |  |  ------------------
  |  |  |  |  |  Branch (88:27): [True: 36, False: 0]
  |  |  |  |  ------------------
  |  |  |  |   89|     36|				 ((0x9 <= (c)) && ((c) <= 0xa)) || \
  |  |  |  |  ------------------
  |  |  |  |  |  Branch (89:7): [True: 0, False: 0]
  |  |  |  |  |  Branch (89:23): [True: 0, False: 0]
  |  |  |  |  ------------------
  |  |  |  |   90|     36|				 ((c) == 0xd))
  |  |  |  |  ------------------
  |  |  |  |  |  Branch (90:6): [True: 0, False: 0]
  |  |  |  |  ------------------
  |  |  ------------------
  ------------------
11031|       |
11032|       |	/*
11033|       |	 * Note that we will switch encoding on the fly.
11034|       |	 */
11035|     36|	xmlParseXMLDecl(ctxt);
11036|     36|	if ((ctxt->errNo == XML_ERR_UNSUPPORTED_ENCODING) ||
  ------------------
  |  Branch (11036:6): [True: 0, False: 36]
  ------------------
11037|     36|	    (ctxt->instate == XML_PARSER_EOF)) {
  ------------------
  |  Branch (11037:6): [True: 0, False: 36]
  ------------------
11038|       |	    /*
11039|       |	     * The XML REC instructs us to stop parsing right here
11040|       |	     */
11041|      0|	    return(-1);
11042|      0|	}
11043|     36|	SKIP_BLANKS;
  ------------------
  |  | 2273|     36|#define SKIP_BLANKS xmlSkipBlankChars(ctxt)
  ------------------
11044|    160|    } else {
11045|    160|	ctxt->version = xmlCharStrdup(XML_DEFAULT_VERSION);
  ------------------
  |  |   37|    160|#define XML_DEFAULT_VERSION	"1.0"
  ------------------
11046|    160|    }
11047|    196|    if ((ctxt->sax) && (ctxt->sax->startDocument) && (!ctxt->disableSAX))
  ------------------
  |  Branch (11047:9): [True: 196, False: 0]
  |  Branch (11047:24): [True: 196, False: 0]
  |  Branch (11047:54): [True: 189, False: 7]
  ------------------
11048|    189|        ctxt->sax->startDocument(ctxt->userData);
11049|    196|    if (ctxt->instate == XML_PARSER_EOF)
  ------------------
  |  Branch (11049:9): [True: 0, False: 196]
  ------------------
11050|      0|	return(-1);
11051|    196|    if ((ctxt->myDoc != NULL) && (ctxt->input != NULL) &&
  ------------------
  |  Branch (11051:9): [True: 189, False: 7]
  |  Branch (11051:34): [True: 189, False: 0]
  ------------------
11052|    196|        (ctxt->input->buf != NULL) && (ctxt->input->buf->compressed >= 0)) {
  ------------------
  |  Branch (11052:9): [True: 189, False: 0]
  |  Branch (11052:39): [True: 0, False: 189]
  ------------------
11053|      0|	ctxt->myDoc->compression = ctxt->input->buf->compressed;
11054|      0|    }
11055|       |
11056|       |    /*
11057|       |     * The Misc part of the Prolog
11058|       |     */
11059|    196|    xmlParseMisc(ctxt);
11060|       |
11061|       |    /*
11062|       |     * Then possibly doc type declaration(s) and more Misc
11063|       |     * (doctypedecl Misc*)?
11064|       |     */
11065|    196|    GROW;
  ------------------
  |  | 2270|    196|#define GROW if (ctxt->input->end - ctxt->input->cur < INPUT_CHUNK)	\
  |  |  ------------------
  |  |  |  |   97|    196|#define INPUT_CHUNK	250
  |  |  ------------------
  |  |  |  Branch (2270:18): [True: 132, False: 64]
  |  |  ------------------
  |  | 2271|    196|	xmlParserGrow(ctxt);
  ------------------
11066|    196|    if (CMP9(CUR_PTR, '<', '!', 'D', 'O', 'C', 'T', 'Y', 'P', 'E')) {
  ------------------
  |  | 2239|    196|  ( CMP8( s, c1, c2, c3, c4, c5, c6, c7, c8 ) && \
  |  |  ------------------
  |  |  |  | 2237|    392|  ( CMP7( s, c1, c2, c3, c4, c5, c6, c7 ) && ((unsigned char *) s)[ 7 ] == c8 )
  |  |  |  |  ------------------
  |  |  |  |  |  | 2235|    392|  ( CMP6( s, c1, c2, c3, c4, c5, c6 ) && ((unsigned char *) s)[ 6 ] == c7 )
  |  |  |  |  |  |  ------------------
  |  |  |  |  |  |  |  | 2233|    392|  ( CMP5( s, c1, c2, c3, c4, c5 ) && ((unsigned char *) s)[ 5 ] == c6 )
  |  |  |  |  |  |  |  |  ------------------
  |  |  |  |  |  |  |  |  |  | 2231|    392|  ( CMP4( s, c1, c2, c3, c4 ) && ((unsigned char *) s)[ 4 ] == c5 )
  |  |  |  |  |  |  |  |  |  |  ------------------
  |  |  |  |  |  |  |  |  |  |  |  | 2228|    392|  ( ((unsigned char *) s)[ 0 ] == c1 && ((unsigned char *) s)[ 1 ] == c2 && \
  |  |  |  |  |  |  |  |  |  |  |  |  ------------------
  |  |  |  |  |  |  |  |  |  |  |  |  |  Branch (2228:5): [True: 184, False: 12]
  |  |  |  |  |  |  |  |  |  |  |  |  |  Branch (2228:41): [True: 5, False: 179]
  |  |  |  |  |  |  |  |  |  |  |  |  ------------------
  |  |  |  |  |  |  |  |  |  |  |  | 2229|    196|    ((unsigned char *) s)[ 2 ] == c3 && ((unsigned char *) s)[ 3 ] == c4 )
  |  |  |  |  |  |  |  |  |  |  |  |  ------------------
  |  |  |  |  |  |  |  |  |  |  |  |  |  Branch (2229:5): [True: 5, False: 0]
  |  |  |  |  |  |  |  |  |  |  |  |  |  Branch (2229:41): [True: 5, False: 0]
  |  |  |  |  |  |  |  |  |  |  |  |  ------------------
  |  |  |  |  |  |  |  |  |  |  ------------------
  |  |  |  |  |  |  |  |  |  |  |  Branch (2231:34): [True: 5, False: 0]
  |  |  |  |  |  |  |  |  |  |  ------------------
  |  |  |  |  |  |  |  |  ------------------
  |  |  |  |  |  |  |  |  |  Branch (2233:38): [True: 5, False: 0]
  |  |  |  |  |  |  |  |  ------------------
  |  |  |  |  |  |  ------------------
  |  |  |  |  |  |  |  Branch (2235:42): [True: 5, False: 0]
  |  |  |  |  |  |  ------------------
  |  |  |  |  ------------------
  |  |  |  |  |  Branch (2237:46): [True: 5, False: 0]
  |  |  |  |  ------------------
  |  |  ------------------
  |  | 2240|    196|    ((unsigned char *) s)[ 8 ] == c9 )
  |  |  ------------------
  |  |  |  Branch (2240:5): [True: 5, False: 0]
  |  |  ------------------
  ------------------
11067|       |
11068|      5|	ctxt->inSubset = 1;
11069|      5|	xmlParseDocTypeDecl(ctxt);
11070|      5|	if (RAW == '[') {
  ------------------
  |  | 2221|      5|#define RAW (*ctxt->input->cur)
  ------------------
  |  Branch (11070:6): [True: 5, False: 0]
  ------------------
11071|      5|	    ctxt->instate = XML_PARSER_DTD;
11072|      5|	    xmlParseInternalSubset(ctxt);
11073|      5|	    if (ctxt->instate == XML_PARSER_EOF)
  ------------------
  |  Branch (11073:10): [True: 0, False: 5]
  ------------------
11074|      0|		return(-1);
11075|      5|	}
11076|       |
11077|       |	/*
11078|       |	 * Create and update the external subset.
11079|       |	 */
11080|      5|	ctxt->inSubset = 2;
11081|      5|	if ((ctxt->sax != NULL) && (ctxt->sax->externalSubset != NULL) &&
  ------------------
  |  Branch (11081:6): [True: 5, False: 0]
  |  Branch (11081:29): [True: 5, False: 0]
  ------------------
11082|      5|	    (!ctxt->disableSAX))
  ------------------
  |  Branch (11082:6): [True: 5, False: 0]
  ------------------
11083|      5|	    ctxt->sax->externalSubset(ctxt->userData, ctxt->intSubName,
11084|      5|	                              ctxt->extSubSystem, ctxt->extSubURI);
11085|      5|	if (ctxt->instate == XML_PARSER_EOF)
  ------------------
  |  Branch (11085:6): [True: 0, False: 5]
  ------------------
11086|      0|	    return(-1);
11087|      5|	ctxt->inSubset = 0;
11088|       |
11089|      5|        xmlCleanSpecialAttr(ctxt);
11090|       |
11091|      5|	ctxt->instate = XML_PARSER_PROLOG;
11092|      5|	xmlParseMisc(ctxt);
11093|      5|    }
11094|       |
11095|       |    /*
11096|       |     * Time to start parsing the tree itself
11097|       |     */
11098|    196|    GROW;
  ------------------
  |  | 2270|    196|#define GROW if (ctxt->input->end - ctxt->input->cur < INPUT_CHUNK)	\
  |  |  ------------------
  |  |  |  |   97|    196|#define INPUT_CHUNK	250
  |  |  ------------------
  |  |  |  Branch (2270:18): [True: 133, False: 63]
  |  |  ------------------
  |  | 2271|    196|	xmlParserGrow(ctxt);
  ------------------
11099|    196|    if (RAW != '<') {
  ------------------
  |  | 2221|    196|#define RAW (*ctxt->input->cur)
  ------------------
  |  Branch (11099:9): [True: 12, False: 184]
  ------------------
11100|     12|	xmlFatalErrMsg(ctxt, XML_ERR_DOCUMENT_EMPTY,
11101|     12|		       "Start tag expected, '<' not found\n");
11102|    184|    } else {
11103|    184|	ctxt->instate = XML_PARSER_CONTENT;
11104|    184|	xmlParseElement(ctxt);
11105|    184|	ctxt->instate = XML_PARSER_EPILOG;
11106|       |
11107|       |
11108|       |	/*
11109|       |	 * The Misc part at the end
11110|       |	 */
11111|    184|	xmlParseMisc(ctxt);
11112|       |
11113|    184|        if (ctxt->input->cur < ctxt->input->end) {
  ------------------
  |  Branch (11113:13): [True: 47, False: 137]
  ------------------
11114|     47|            if (ctxt->errNo == XML_ERR_OK)
  ------------------
  |  Branch (11114:17): [True: 0, False: 47]
  ------------------
11115|      0|	        xmlFatalErr(ctxt, XML_ERR_DOCUMENT_END, NULL);
11116|    137|        } else if ((ctxt->input->buf != NULL) &&
  ------------------
  |  Branch (11116:20): [True: 137, False: 0]
  ------------------
11117|    137|                   (ctxt->input->buf->encoder != NULL) &&
  ------------------
  |  Branch (11117:20): [True: 5, False: 132]
  ------------------
11118|    137|                   (!xmlBufIsEmpty(ctxt->input->buf->raw))) {
  ------------------
  |  Branch (11118:20): [True: 0, False: 5]
  ------------------
11119|      0|            xmlFatalErrMsg(ctxt, XML_ERR_INVALID_CHAR,
11120|      0|                           "Truncated multi-byte sequence at EOF\n");
11121|      0|        }
11122|    184|	ctxt->instate = XML_PARSER_EOF;
11123|    184|    }
11124|       |
11125|       |    /*
11126|       |     * SAX: end of the document processing.
11127|       |     */
11128|    196|    if ((ctxt->sax) && (ctxt->sax->endDocument != NULL))
  ------------------
  |  Branch (11128:9): [True: 196, False: 0]
  |  Branch (11128:24): [True: 196, False: 0]
  ------------------
11129|    196|        ctxt->sax->endDocument(ctxt->userData);
11130|       |
11131|       |    /*
11132|       |     * Remove locally kept entity definitions if the tree was not built
11133|       |     */
11134|    196|    if ((ctxt->myDoc != NULL) &&
  ------------------
  |  Branch (11134:9): [True: 189, False: 7]
  ------------------
11135|    196|	(xmlStrEqual(ctxt->myDoc->version, SAX_COMPAT_MODE))) {
  ------------------
  |  |  168|    189|#define SAX_COMPAT_MODE BAD_CAST "SAX compatibility mode document"
  |  |  ------------------
  |  |  |  |   35|    189|#define BAD_CAST (xmlChar *)
  |  |  ------------------
  ------------------
  |  Branch (11135:2): [True: 0, False: 189]
  ------------------
11136|      0|	xmlFreeDoc(ctxt->myDoc);
11137|      0|	ctxt->myDoc = NULL;
11138|      0|    }
11139|       |
11140|    196|    if ((ctxt->wellFormed) && (ctxt->myDoc != NULL)) {
  ------------------
  |  Branch (11140:9): [True: 58, False: 138]
  |  Branch (11140:31): [True: 58, False: 0]
  ------------------
11141|     58|        ctxt->myDoc->properties |= XML_DOC_WELLFORMED;
11142|     58|	if (ctxt->valid)
  ------------------
  |  Branch (11142:6): [True: 58, False: 0]
  ------------------
11143|     58|	    ctxt->myDoc->properties |= XML_DOC_DTDVALID;
11144|     58|	if (ctxt->nsWellFormed)
  ------------------
  |  Branch (11144:6): [True: 58, False: 0]
  ------------------
11145|     58|	    ctxt->myDoc->properties |= XML_DOC_NSVALID;
11146|     58|	if (ctxt->options & XML_PARSE_OLD10)
  ------------------
  |  Branch (11146:6): [True: 0, False: 58]
  ------------------
11147|      0|	    ctxt->myDoc->properties |= XML_DOC_OLD10;
11148|     58|    }
11149|    196|    if (! ctxt->wellFormed) {
  ------------------
  |  Branch (11149:9): [True: 138, False: 58]
  ------------------
11150|    138|	ctxt->valid = 0;
11151|    138|	return(-1);
11152|    138|    }
11153|     58|    return(0);
11154|    196|}
xmlParseChunk:
12110|    505|              int terminate) {
12111|    505|    int end_in_lf = 0;
12112|       |
12113|    505|    if (ctxt == NULL)
  ------------------
  |  Branch (12113:9): [True: 0, False: 505]
  ------------------
12114|      0|        return(XML_ERR_INTERNAL_ERROR);
12115|    505|    if ((ctxt->errNo != XML_ERR_OK) && (ctxt->disableSAX == 1))
  ------------------
  |  Branch (12115:9): [True: 217, False: 288]
  |  Branch (12115:40): [True: 217, False: 0]
  ------------------
12116|    217|        return(ctxt->errNo);
12117|    288|    if (ctxt->instate == XML_PARSER_EOF)
  ------------------
  |  Branch (12117:9): [True: 0, False: 288]
  ------------------
12118|      0|        return(-1);
12119|    288|    if (ctxt->input == NULL)
  ------------------
  |  Branch (12119:9): [True: 0, False: 288]
  ------------------
12120|      0|        return(-1);
12121|       |
12122|    288|    ctxt->progressive = 1;
12123|    288|    if (ctxt->instate == XML_PARSER_START)
  ------------------
  |  Branch (12123:9): [True: 167, False: 121]
  ------------------
12124|    167|        xmlDetectSAX2(ctxt);
12125|    288|    if ((size > 0) && (chunk != NULL) && (!terminate) &&
  ------------------
  |  Branch (12125:9): [True: 207, False: 81]
  |  Branch (12125:23): [True: 207, False: 0]
  |  Branch (12125:42): [True: 207, False: 0]
  ------------------
12126|    288|        (chunk[size - 1] == '\r')) {
  ------------------
  |  Branch (12126:9): [True: 0, False: 207]
  ------------------
12127|      0|	end_in_lf = 1;
12128|      0|	size--;
12129|      0|    }
12130|       |
12131|    288|    if ((size > 0) && (chunk != NULL) && (ctxt->input != NULL) &&
  ------------------
  |  Branch (12131:9): [True: 207, False: 81]
  |  Branch (12131:23): [True: 207, False: 0]
  |  Branch (12131:42): [True: 207, False: 0]
  ------------------
12132|    288|        (ctxt->input->buf != NULL) && (ctxt->instate != XML_PARSER_EOF))  {
  ------------------
  |  Branch (12132:9): [True: 207, False: 0]
  |  Branch (12132:39): [True: 207, False: 0]
  ------------------
12133|    207|	size_t pos = ctxt->input->cur - ctxt->input->base;
12134|    207|	int res;
12135|       |
12136|    207|	res = xmlParserInputBufferPush(ctxt->input->buf, size, chunk);
12137|    207|        xmlBufUpdateInput(ctxt->input->buf->buffer, ctxt->input, pos);
12138|    207|	if (res < 0) {
  ------------------
  |  Branch (12138:6): [True: 0, False: 207]
  ------------------
12139|      0|            xmlFatalErr(ctxt, ctxt->input->buf->error, NULL);
12140|      0|	    xmlHaltParser(ctxt);
12141|      0|	    return(ctxt->errNo);
12142|      0|	}
12143|    207|    }
12144|       |
12145|    288|    xmlParseTryOrFinish(ctxt, terminate);
12146|    288|    if (ctxt->instate == XML_PARSER_EOF)
  ------------------
  |  Branch (12146:9): [True: 26, False: 262]
  ------------------
12147|     26|        return(ctxt->errNo);
12148|       |
12149|    262|    if ((ctxt->input != NULL) &&
  ------------------
  |  Branch (12149:9): [True: 262, False: 0]
  ------------------
12150|    262|         (((ctxt->input->end - ctxt->input->cur) > XML_MAX_LOOKUP_LIMIT) ||
  ------------------
  |  |   81|    262|#define XML_MAX_LOOKUP_LIMIT 10000000
  ------------------
  |  Branch (12150:11): [True: 0, False: 262]
  ------------------
12151|    262|         ((ctxt->input->cur - ctxt->input->base) > XML_MAX_LOOKUP_LIMIT)) &&
  ------------------
  |  |   81|    262|#define XML_MAX_LOOKUP_LIMIT 10000000
  ------------------
  |  Branch (12151:10): [True: 0, False: 262]
  ------------------
12152|    262|        ((ctxt->options & XML_PARSE_HUGE) == 0)) {
  ------------------
  |  Branch (12152:9): [True: 0, False: 0]
  ------------------
12153|      0|        xmlFatalErr(ctxt, XML_ERR_INTERNAL_ERROR, "Huge input lookup");
12154|      0|        xmlHaltParser(ctxt);
12155|      0|    }
12156|    262|    if ((ctxt->errNo != XML_ERR_OK) && (ctxt->disableSAX == 1))
  ------------------
  |  Branch (12156:9): [True: 101, False: 161]
  |  Branch (12156:40): [True: 100, False: 1]
  ------------------
12157|    100|        return(ctxt->errNo);
12158|       |
12159|    162|    if ((end_in_lf == 1) && (ctxt->input != NULL) &&
  ------------------
  |  Branch (12159:9): [True: 0, False: 162]
  |  Branch (12159:29): [True: 0, False: 0]
  ------------------
12160|    162|        (ctxt->input->buf != NULL)) {
  ------------------
  |  Branch (12160:9): [True: 0, False: 0]
  ------------------
12161|      0|	size_t pos = ctxt->input->cur - ctxt->input->base;
12162|      0|        int res;
12163|       |
12164|      0|	res = xmlParserInputBufferPush(ctxt->input->buf, 1, "\r");
12165|      0|	xmlBufUpdateInput(ctxt->input->buf->buffer, ctxt->input, pos);
12166|      0|        if (res < 0) {
  ------------------
  |  Branch (12166:13): [True: 0, False: 0]
  ------------------
12167|      0|            xmlFatalErr(ctxt, ctxt->input->buf->error, NULL);
12168|      0|            xmlHaltParser(ctxt);
12169|      0|            return(ctxt->errNo);
12170|      0|        }
12171|      0|    }
12172|    162|    if (terminate) {
  ------------------
  |  Branch (12172:9): [True: 40, False: 122]
  ------------------
12173|       |	/*
12174|       |	 * Check for termination
12175|       |	 */
12176|     40|        if ((ctxt->instate != XML_PARSER_EOF) &&
  ------------------
  |  Branch (12176:13): [True: 40, False: 0]
  ------------------
12177|     40|            (ctxt->instate != XML_PARSER_EPILOG)) {
  ------------------
  |  Branch (12177:13): [True: 0, False: 40]
  ------------------
12178|      0|            if (ctxt->nameNr > 0) {
  ------------------
  |  Branch (12178:17): [True: 0, False: 0]
  ------------------
12179|      0|                const xmlChar *name = ctxt->nameTab[ctxt->nameNr - 1];
12180|      0|                int line = ctxt->pushTab[ctxt->nameNr - 1].line;
12181|      0|                xmlFatalErrMsgStrIntStr(ctxt, XML_ERR_TAG_NOT_FINISHED,
12182|      0|                        "Premature end of data in tag %s line %d\n",
12183|      0|                        name, line, NULL);
12184|      0|            } else if (ctxt->instate == XML_PARSER_START) {
  ------------------
  |  Branch (12184:24): [True: 0, False: 0]
  ------------------
12185|      0|                xmlFatalErr(ctxt, XML_ERR_DOCUMENT_EMPTY, NULL);
12186|      0|            } else {
12187|      0|                xmlFatalErrMsg(ctxt, XML_ERR_DOCUMENT_EMPTY,
12188|      0|                               "Start tag expected, '<' not found\n");
12189|      0|            }
12190|     40|        } else if ((ctxt->input->buf != NULL) &&
  ------------------
  |  Branch (12190:20): [True: 40, False: 0]
  ------------------
12191|     40|                   (ctxt->input->buf->encoder != NULL) &&
  ------------------
  |  Branch (12191:20): [True: 2, False: 38]
  ------------------
12192|     40|                   (!xmlBufIsEmpty(ctxt->input->buf->raw))) {
  ------------------
  |  Branch (12192:20): [True: 0, False: 2]
  ------------------
12193|      0|            xmlFatalErrMsg(ctxt, XML_ERR_INVALID_CHAR,
12194|      0|                           "Truncated multi-byte sequence at EOF\n");
12195|      0|        }
12196|     40|	if (ctxt->instate != XML_PARSER_EOF) {
  ------------------
  |  Branch (12196:6): [True: 40, False: 0]
  ------------------
12197|     40|	    if ((ctxt->sax) && (ctxt->sax->endDocument != NULL))
  ------------------
  |  Branch (12197:10): [True: 40, False: 0]
  |  Branch (12197:25): [True: 40, False: 0]
  ------------------
12198|     40|		ctxt->sax->endDocument(ctxt->userData);
12199|     40|	}
12200|     40|	ctxt->instate = XML_PARSER_EOF;
12201|     40|    }
12202|    162|    if (ctxt->wellFormed == 0)
  ------------------
  |  Branch (12202:9): [True: 1, False: 161]
  ------------------
12203|      1|	return((xmlParserErrors) ctxt->errNo);
12204|    161|    else
12205|    161|        return(0);
12206|    162|}
xmlCreatePushParserCtxt:
12235|    167|                        const char *chunk, int size, const char *filename) {
12236|    167|    xmlParserCtxtPtr ctxt;
12237|    167|    xmlParserInputPtr inputStream;
12238|    167|    xmlParserInputBufferPtr buf;
12239|       |
12240|    167|    buf = xmlAllocParserInputBuffer(XML_CHAR_ENCODING_NONE);
12241|    167|    if (buf == NULL) return(NULL);
  ------------------
  |  Branch (12241:9): [True: 0, False: 167]
  ------------------
12242|       |
12243|    167|    ctxt = xmlNewSAXParserCtxt(sax, user_data);
12244|    167|    if (ctxt == NULL) {
  ------------------
  |  Branch (12244:9): [True: 0, False: 167]
  ------------------
12245|      0|        xmlErrMemory(NULL, "creating parser: out of memory\n");
12246|      0|	xmlFreeParserInputBuffer(buf);
12247|      0|	return(NULL);
12248|      0|    }
12249|    167|    ctxt->dictNames = 1;
12250|    167|    if (filename == NULL) {
  ------------------
  |  Branch (12250:9): [True: 167, False: 0]
  ------------------
12251|    167|	ctxt->directory = NULL;
12252|    167|    } else {
12253|      0|        ctxt->directory = xmlParserGetDirectory(filename);
12254|      0|    }
12255|       |
12256|    167|    inputStream = xmlNewInputStream(ctxt);
12257|    167|    if (inputStream == NULL) {
  ------------------
  |  Branch (12257:9): [True: 0, False: 167]
  ------------------
12258|      0|	xmlFreeParserCtxt(ctxt);
12259|      0|	xmlFreeParserInputBuffer(buf);
12260|      0|	return(NULL);
12261|      0|    }
12262|       |
12263|    167|    if (filename == NULL)
  ------------------
  |  Branch (12263:9): [True: 167, False: 0]
  ------------------
12264|    167|	inputStream->filename = NULL;
12265|      0|    else {
12266|      0|	inputStream->filename = (char *)
12267|      0|	    xmlCanonicPath((const xmlChar *) filename);
12268|      0|	if (inputStream->filename == NULL) {
  ------------------
  |  Branch (12268:6): [True: 0, False: 0]
  ------------------
12269|      0|            xmlFreeInputStream(inputStream);
12270|      0|	    xmlFreeParserCtxt(ctxt);
12271|      0|	    xmlFreeParserInputBuffer(buf);
12272|      0|	    return(NULL);
12273|      0|	}
12274|      0|    }
12275|    167|    inputStream->buf = buf;
12276|    167|    xmlBufResetInput(inputStream->buf->buffer, inputStream);
12277|    167|    inputPush(ctxt, inputStream);
12278|       |
12279|    167|    if ((size != 0) && (chunk != NULL) &&
  ------------------
  |  Branch (12279:9): [True: 167, False: 0]
  |  Branch (12279:24): [True: 167, False: 0]
  ------------------
12280|    167|        (ctxt->input != NULL) && (ctxt->input->buf != NULL)) {
  ------------------
  |  Branch (12280:9): [True: 167, False: 0]
  |  Branch (12280:34): [True: 167, False: 0]
  ------------------
12281|    167|	size_t pos = ctxt->input->cur - ctxt->input->base;
12282|    167|        int res;
12283|       |
12284|    167|	res = xmlParserInputBufferPush(ctxt->input->buf, size, chunk);
12285|    167|        xmlBufUpdateInput(ctxt->input->buf->buffer, ctxt->input, pos);
12286|    167|        if (res < 0) {
  ------------------
  |  Branch (12286:13): [True: 0, False: 167]
  ------------------
12287|      0|            xmlFatalErr(ctxt, ctxt->input->buf->error, NULL);
12288|      0|            xmlHaltParser(ctxt);
12289|      0|        }
12290|    167|    }
12291|       |
12292|    167|    return(ctxt);
12293|    167|}
xmlStopParser:
12303|    167|xmlStopParser(xmlParserCtxtPtr ctxt) {
12304|    167|    if (ctxt == NULL)
  ------------------
  |  Branch (12304:9): [True: 0, False: 167]
  ------------------
12305|      0|        return;
12306|    167|    xmlHaltParser(ctxt);
12307|    167|    ctxt->errNo = XML_ERR_USER_STOP;
12308|    167|}
xmlCreateMemoryParserCtxt:
13985|    167|xmlCreateMemoryParserCtxt(const char *buffer, int size) {
13986|    167|    xmlParserCtxtPtr ctxt;
13987|    167|    xmlParserInputPtr input;
13988|    167|    xmlParserInputBufferPtr buf;
13989|       |
13990|    167|    if (buffer == NULL)
  ------------------
  |  Branch (13990:9): [True: 0, False: 167]
  ------------------
13991|      0|	return(NULL);
13992|    167|    if (size <= 0)
  ------------------
  |  Branch (13992:9): [True: 0, False: 167]
  ------------------
13993|      0|	return(NULL);
13994|       |
13995|    167|    ctxt = xmlNewParserCtxt();
13996|    167|    if (ctxt == NULL)
  ------------------
  |  Branch (13996:9): [True: 0, False: 167]
  ------------------
13997|      0|	return(NULL);
13998|       |
13999|    167|    buf = xmlParserInputBufferCreateMem(buffer, size, XML_CHAR_ENCODING_NONE);
14000|    167|    if (buf == NULL) {
  ------------------
  |  Branch (14000:9): [True: 0, False: 167]
  ------------------
14001|      0|	xmlFreeParserCtxt(ctxt);
14002|      0|	return(NULL);
14003|      0|    }
14004|       |
14005|    167|    input = xmlNewInputStream(ctxt);
14006|    167|    if (input == NULL) {
  ------------------
  |  Branch (14006:9): [True: 0, False: 167]
  ------------------
14007|      0|	xmlFreeParserInputBuffer(buf);
14008|      0|	xmlFreeParserCtxt(ctxt);
14009|      0|	return(NULL);
14010|      0|    }
14011|       |
14012|    167|    input->filename = NULL;
14013|    167|    input->buf = buf;
14014|    167|    xmlBufResetInput(input->buf->buffer, input);
14015|       |
14016|    167|    inputPush(ctxt, input);
14017|    167|    return(ctxt);
14018|    167|}
xmlCtxtUseOptions:
14693|    277|{
14694|    277|   return(xmlCtxtUseOptionsInternal(ctxt, options, NULL));
14695|    277|}
xmlReadMemory:
14830|    167|{
14831|    167|    xmlParserCtxtPtr ctxt;
14832|       |
14833|    167|    xmlInitParser();
14834|    167|    ctxt = xmlCreateMemoryParserCtxt(buffer, size);
14835|    167|    if (ctxt == NULL)
  ------------------
  |  Branch (14835:9): [True: 0, False: 167]
  ------------------
14836|      0|        return (NULL);
14837|    167|    return (xmlDoRead(ctxt, URL, encoding, options, 0));
14838|    167|}
parser.c:xmlParserNsLookup:
 1485|  4.45k|                  xmlParserNsBucket **bucketPtr) {
 1486|  4.45k|    xmlParserNsBucket *bucket;
 1487|  4.45k|    unsigned index, hashValue;
 1488|       |
 1489|  4.45k|    if (prefix->name == NULL)
  ------------------
  |  Branch (1489:9): [True: 1.38k, False: 3.07k]
  ------------------
 1490|  1.38k|        return(ctxt->nsdb->defaultNsIndex);
 1491|       |
 1492|  3.07k|    if (ctxt->nsdb->hashSize == 0)
  ------------------
  |  Branch (1492:9): [True: 302, False: 2.76k]
  ------------------
 1493|    302|        return(INT_MAX);
 1494|       |
 1495|  2.76k|    hashValue = prefix->hashValue;
 1496|  2.76k|    index = hashValue & (ctxt->nsdb->hashSize - 1);
 1497|  2.76k|    bucket = &ctxt->nsdb->hash[index];
 1498|       |
 1499|  2.84k|    while (bucket->hashValue) {
  ------------------
  |  Branch (1499:12): [True: 2.80k, False: 37]
  ------------------
 1500|  2.80k|        if ((bucket->hashValue == hashValue) &&
  ------------------
  |  Branch (1500:13): [True: 2.78k, False: 22]
  ------------------
 1501|  2.80k|            (bucket->index != INT_MAX)) {
  ------------------
  |  Branch (1501:13): [True: 2.73k, False: 52]
  ------------------
 1502|  2.73k|            if (ctxt->nsTab[bucket->index * 2] == prefix->name) {
  ------------------
  |  Branch (1502:17): [True: 2.73k, False: 0]
  ------------------
 1503|  2.73k|                if (bucketPtr != NULL)
  ------------------
  |  Branch (1503:21): [True: 203, False: 2.52k]
  ------------------
 1504|    203|                    *bucketPtr = bucket;
 1505|  2.73k|                return(bucket->index);
 1506|  2.73k|            }
 1507|  2.73k|        }
 1508|       |
 1509|     74|        index++;
 1510|     74|        bucket++;
 1511|     74|        if (index == ctxt->nsdb->hashSize) {
  ------------------
  |  Branch (1511:13): [True: 0, False: 74]
  ------------------
 1512|      0|            index = 0;
 1513|      0|            bucket = ctxt->nsdb->hash;
 1514|      0|        }
 1515|     74|    }
 1516|       |
 1517|     37|    if (bucketPtr != NULL)
  ------------------
  |  Branch (1517:9): [True: 26, False: 11]
  ------------------
 1518|     26|        *bucketPtr = bucket;
 1519|     37|    return(INT_MAX);
 1520|  2.76k|}
parser.c:xmlFatalErrMsgInt:
  385|    838|{
  386|    838|    if ((ctxt != NULL) && (ctxt->disableSAX != 0) &&
  ------------------
  |  Branch (386:9): [True: 838, False: 0]
  |  Branch (386:27): [True: 700, False: 138]
  ------------------
  387|    838|        (ctxt->instate == XML_PARSER_EOF))
  ------------------
  |  Branch (387:9): [True: 0, False: 700]
  ------------------
  388|      0|	return;
  389|    838|    if (ctxt != NULL)
  ------------------
  |  Branch (389:9): [True: 838, False: 0]
  ------------------
  390|    838|	ctxt->errNo = error;
  391|    838|    __xmlRaiseError(NULL, NULL, NULL,
  392|    838|                    ctxt, NULL, XML_FROM_PARSER, error, XML_ERR_FATAL,
  393|    838|                    NULL, 0, NULL, NULL, NULL, val, 0, msg, val);
  394|    838|    if (ctxt != NULL) {
  ------------------
  |  Branch (394:9): [True: 838, False: 0]
  ------------------
  395|    838|	ctxt->wellFormed = 0;
  396|    838|	if (ctxt->recovery == 0)
  ------------------
  |  Branch (396:6): [True: 708, False: 130]
  ------------------
  397|    708|	    ctxt->disableSAX = 1;
  398|    838|    }
  399|    838|}
parser.c:xmlStringDecodeEntitiesInt:
 2798|      2|                           int check) {
 2799|      2|    xmlChar *buffer = NULL;
 2800|      2|    size_t buffer_size = 0;
 2801|      2|    size_t nbchars = 0;
 2802|       |
 2803|      2|    xmlChar *current = NULL;
 2804|      2|    xmlChar *rep = NULL;
 2805|      2|    const xmlChar *last;
 2806|      2|    xmlEntityPtr ent;
 2807|      2|    int c,l;
 2808|       |
 2809|      2|    if (str == NULL)
  ------------------
  |  Branch (2809:9): [True: 0, False: 2]
  ------------------
 2810|      0|        return(NULL);
 2811|      2|    last = str + len;
 2812|       |
 2813|      2|    if (((ctxt->depth > 40) &&
  ------------------
  |  Branch (2813:10): [True: 0, False: 2]
  ------------------
 2814|      2|         ((ctxt->options & XML_PARSE_HUGE) == 0)) ||
  ------------------
  |  Branch (2814:10): [True: 0, False: 0]
  ------------------
 2815|      2|	(ctxt->depth > 100)) {
  ------------------
  |  Branch (2815:2): [True: 0, False: 2]
  ------------------
 2816|      0|	xmlFatalErrMsg(ctxt, XML_ERR_ENTITY_LOOP,
 2817|      0|                       "Maximum entity nesting depth exceeded");
 2818|      0|	return(NULL);
 2819|      0|    }
 2820|       |
 2821|       |    /*
 2822|       |     * allocate a translation buffer.
 2823|       |     */
 2824|      2|    buffer_size = XML_PARSER_BIG_BUFFER_SIZE;
  ------------------
  |  |  166|      2|#define XML_PARSER_BIG_BUFFER_SIZE 300
  ------------------
 2825|      2|    buffer = (xmlChar *) xmlMallocAtomic(buffer_size);
 2826|      2|    if (buffer == NULL) goto mem_error;
  ------------------
  |  Branch (2826:9): [True: 0, False: 2]
  ------------------
 2827|       |
 2828|       |    /*
 2829|       |     * OK loop until we reach one of the ending char or a size limit.
 2830|       |     * we are operating on already parsed values.
 2831|       |     */
 2832|      2|    if (str < last)
  ------------------
  |  Branch (2832:9): [True: 2, False: 0]
  ------------------
 2833|      2|	c = CUR_SCHAR(str, l);
  ------------------
  |  | 2292|      2|#define CUR_SCHAR(s, l) xmlStringCurrentChar(ctxt, s, &l)
  ------------------
 2834|      0|    else
 2835|      0|        c = 0;
 2836|     64|    while ((c != 0) && (c != end) && /* non input consuming loop */
  ------------------
  |  Branch (2836:12): [True: 62, False: 2]
  |  Branch (2836:24): [True: 62, False: 0]
  ------------------
 2837|     64|           (c != end2) && (c != end3) &&
  ------------------
  |  Branch (2837:12): [True: 62, False: 0]
  |  Branch (2837:27): [True: 62, False: 0]
  ------------------
 2838|     64|           (ctxt->instate != XML_PARSER_EOF)) {
  ------------------
  |  Branch (2838:12): [True: 62, False: 0]
  ------------------
 2839|       |
 2840|     62|	if (c == 0) break;
  ------------------
  |  Branch (2840:6): [True: 0, False: 62]
  ------------------
 2841|     62|        if ((c == '&') && (str[1] == '#')) {
  ------------------
  |  Branch (2841:13): [True: 0, False: 62]
  |  Branch (2841:27): [True: 0, False: 0]
  ------------------
 2842|      0|	    int val = xmlParseStringCharRef(ctxt, &str);
 2843|      0|	    if (val == 0)
  ------------------
  |  Branch (2843:10): [True: 0, False: 0]
  ------------------
 2844|      0|                goto int_error;
 2845|      0|	    COPY_BUF(buffer, nbchars, val);
  ------------------
  |  | 2295|      0|    if (v < 0x80) b[i++] = v;						\
  |  |  ------------------
  |  |  |  Branch (2295:9): [True: 0, False: 0]
  |  |  ------------------
  |  | 2296|      0|    else i += xmlCopyCharMultiByte(&b[i],v)
  ------------------
 2846|      0|	    if (nbchars + XML_PARSER_BUFFER_SIZE > buffer_size) {
  ------------------
  |  |  167|      0|#define XML_PARSER_BUFFER_SIZE 100
  ------------------
  |  Branch (2846:10): [True: 0, False: 0]
  ------------------
 2847|      0|	        growBuffer(buffer, XML_PARSER_BUFFER_SIZE);
  ------------------
  |  | 2774|      0|#define growBuffer(buffer, n) {						\
  |  | 2775|      0|    xmlChar *tmp;							\
  |  | 2776|      0|    size_t new_size = buffer##_size * 2 + n;                            \
  |  | 2777|      0|    if (new_size < buffer##_size) goto mem_error;                       \
  |  |  ------------------
  |  |  |  Branch (2777:9): [True: 0, False: 0]
  |  |  ------------------
  |  | 2778|      0|    tmp = (xmlChar *) xmlRealloc(buffer, new_size);                     \
  |  | 2779|      0|    if (tmp == NULL) goto mem_error;					\
  |  |  ------------------
  |  |  |  Branch (2779:9): [True: 0, False: 0]
  |  |  ------------------
  |  | 2780|      0|    buffer = tmp;							\
  |  | 2781|      0|    buffer##_size = new_size;                                           \
  |  | 2782|      0|}
  ------------------
 2848|      0|	    }
 2849|     62|	} else if ((c == '&') && (what & XML_SUBSTITUTE_REF)) {
  ------------------
  |  |  521|      0|#define XML_SUBSTITUTE_REF	1
  ------------------
  |  Branch (2849:13): [True: 0, False: 62]
  |  Branch (2849:27): [True: 0, False: 0]
  ------------------
 2850|      0|	    if (xmlParserDebugEntities)
  ------------------
  |  |  870|      0|  #define xmlParserDebugEntities XML_GLOBAL_MACRO(xmlParserDebugEntities)
  |  |  ------------------
  |  |  |  |  500|      0|  #define XML_GLOBAL_MACRO(name) (*__##name())
  |  |  |  |  ------------------
  |  |  |  |  |  Branch (500:34): [True: 0, False: 0]
  |  |  |  |  ------------------
  |  |  ------------------
  ------------------
 2851|      0|		xmlGenericError(xmlGenericErrorContext,
  ------------------
  |  |  875|      0|  #define xmlGenericError XML_GLOBAL_MACRO(xmlGenericError)
  |  |  ------------------
  |  |  |  |  500|      0|  #define XML_GLOBAL_MACRO(name) (*__##name())
  |  |  ------------------
  ------------------
              		xmlGenericError(xmlGenericErrorContext,
  ------------------
  |  |  876|      0|  #define xmlGenericErrorContext XML_GLOBAL_MACRO(xmlGenericErrorContext)
  |  |  ------------------
  |  |  |  |  500|      0|  #define XML_GLOBAL_MACRO(name) (*__##name())
  |  |  ------------------
  ------------------
 2852|      0|			"String decoding Entity Reference: %.30s\n",
 2853|      0|			str);
 2854|      0|	    ent = xmlParseStringEntityRef(ctxt, &str);
 2855|      0|	    if ((ent != NULL) &&
  ------------------
  |  Branch (2855:10): [True: 0, False: 0]
  ------------------
 2856|      0|		(ent->etype == XML_INTERNAL_PREDEFINED_ENTITY)) {
  ------------------
  |  Branch (2856:3): [True: 0, False: 0]
  ------------------
 2857|      0|		if (ent->content != NULL) {
  ------------------
  |  Branch (2857:7): [True: 0, False: 0]
  ------------------
 2858|      0|		    COPY_BUF(buffer, nbchars, ent->content[0]);
  ------------------
  |  | 2295|      0|    if (v < 0x80) b[i++] = v;						\
  |  |  ------------------
  |  |  |  Branch (2295:9): [True: 0, False: 0]
  |  |  ------------------
  |  | 2296|      0|    else i += xmlCopyCharMultiByte(&b[i],v)
  ------------------
 2859|      0|		    if (nbchars + XML_PARSER_BUFFER_SIZE > buffer_size) {
  ------------------
  |  |  167|      0|#define XML_PARSER_BUFFER_SIZE 100
  ------------------
  |  Branch (2859:11): [True: 0, False: 0]
  ------------------
 2860|      0|			growBuffer(buffer, XML_PARSER_BUFFER_SIZE);
  ------------------
  |  | 2774|      0|#define growBuffer(buffer, n) {						\
  |  | 2775|      0|    xmlChar *tmp;							\
  |  | 2776|      0|    size_t new_size = buffer##_size * 2 + n;                            \
  |  | 2777|      0|    if (new_size < buffer##_size) goto mem_error;                       \
  |  |  ------------------
  |  |  |  Branch (2777:9): [True: 0, False: 0]
  |  |  ------------------
  |  | 2778|      0|    tmp = (xmlChar *) xmlRealloc(buffer, new_size);                     \
  |  | 2779|      0|    if (tmp == NULL) goto mem_error;					\
  |  |  ------------------
  |  |  |  Branch (2779:9): [True: 0, False: 0]
  |  |  ------------------
  |  | 2780|      0|    buffer = tmp;							\
  |  | 2781|      0|    buffer##_size = new_size;                                           \
  |  | 2782|      0|}
  ------------------
 2861|      0|		    }
 2862|      0|		} else {
 2863|      0|		    xmlFatalErrMsg(ctxt, XML_ERR_INTERNAL_ERROR,
 2864|      0|			    "predefined entity has no content\n");
 2865|      0|                    goto int_error;
 2866|      0|		}
 2867|      0|	    } else if ((ent != NULL) && (ent->content != NULL)) {
  ------------------
  |  Branch (2867:17): [True: 0, False: 0]
  |  Branch (2867:34): [True: 0, False: 0]
  ------------------
 2868|      0|	        if ((check) && (xmlParserEntityCheck(ctxt, ent->length)))
  ------------------
  |  Branch (2868:14): [True: 0, False: 0]
  |  Branch (2868:25): [True: 0, False: 0]
  ------------------
 2869|      0|                    goto int_error;
 2870|       |
 2871|      0|                if (ent->flags & XML_ENT_EXPANDING) {
  ------------------
  |  |   16|      0|#define XML_ENT_EXPANDING   (1<<2)
  ------------------
  |  Branch (2871:21): [True: 0, False: 0]
  ------------------
 2872|      0|	            xmlFatalErr(ctxt, XML_ERR_ENTITY_LOOP, NULL);
 2873|      0|                    xmlHaltParser(ctxt);
 2874|      0|                    ent->content[0] = 0;
 2875|      0|                    goto int_error;
 2876|      0|                }
 2877|       |
 2878|      0|                ent->flags |= XML_ENT_EXPANDING;
  ------------------
  |  |   16|      0|#define XML_ENT_EXPANDING   (1<<2)
  ------------------
 2879|      0|		ctxt->depth++;
 2880|      0|		rep = xmlStringDecodeEntitiesInt(ctxt, ent->content,
 2881|      0|                        ent->length, what, 0, 0, 0, check);
 2882|      0|		ctxt->depth--;
 2883|      0|                ent->flags &= ~XML_ENT_EXPANDING;
  ------------------
  |  |   16|      0|#define XML_ENT_EXPANDING   (1<<2)
  ------------------
 2884|       |
 2885|      0|		if (rep == NULL) {
  ------------------
  |  Branch (2885:7): [True: 0, False: 0]
  ------------------
 2886|      0|                    ent->content[0] = 0;
 2887|      0|                    goto int_error;
 2888|      0|                }
 2889|       |
 2890|      0|                current = rep;
 2891|      0|                while (*current != 0) { /* non input consuming loop */
  ------------------
  |  Branch (2891:24): [True: 0, False: 0]
  ------------------
 2892|      0|                    buffer[nbchars++] = *current++;
 2893|      0|                    if (nbchars + XML_PARSER_BUFFER_SIZE > buffer_size) {
  ------------------
  |  |  167|      0|#define XML_PARSER_BUFFER_SIZE 100
  ------------------
  |  Branch (2893:25): [True: 0, False: 0]
  ------------------
 2894|      0|                        growBuffer(buffer, XML_PARSER_BUFFER_SIZE);
  ------------------
  |  | 2774|      0|#define growBuffer(buffer, n) {						\
  |  | 2775|      0|    xmlChar *tmp;							\
  |  | 2776|      0|    size_t new_size = buffer##_size * 2 + n;                            \
  |  | 2777|      0|    if (new_size < buffer##_size) goto mem_error;                       \
  |  |  ------------------
  |  |  |  Branch (2777:9): [True: 0, False: 0]
  |  |  ------------------
  |  | 2778|      0|    tmp = (xmlChar *) xmlRealloc(buffer, new_size);                     \
  |  | 2779|      0|    if (tmp == NULL) goto mem_error;					\
  |  |  ------------------
  |  |  |  Branch (2779:9): [True: 0, False: 0]
  |  |  ------------------
  |  | 2780|      0|    buffer = tmp;							\
  |  | 2781|      0|    buffer##_size = new_size;                                           \
  |  | 2782|      0|}
  ------------------
 2895|      0|                    }
 2896|      0|                }
 2897|      0|                xmlFree(rep);
 2898|      0|                rep = NULL;
 2899|      0|	    } else if (ent != NULL) {
  ------------------
  |  Branch (2899:17): [True: 0, False: 0]
  ------------------
 2900|      0|		int i = xmlStrlen(ent->name);
 2901|      0|		const xmlChar *cur = ent->name;
 2902|       |
 2903|      0|		buffer[nbchars++] = '&';
 2904|      0|		if (nbchars + i + XML_PARSER_BUFFER_SIZE > buffer_size) {
  ------------------
  |  |  167|      0|#define XML_PARSER_BUFFER_SIZE 100
  ------------------
  |  Branch (2904:7): [True: 0, False: 0]
  ------------------
 2905|      0|		    growBuffer(buffer, i + XML_PARSER_BUFFER_SIZE);
  ------------------
  |  | 2774|      0|#define growBuffer(buffer, n) {						\
  |  | 2775|      0|    xmlChar *tmp;							\
  |  | 2776|      0|    size_t new_size = buffer##_size * 2 + n;                            \
  |  | 2777|      0|    if (new_size < buffer##_size) goto mem_error;                       \
  |  |  ------------------
  |  |  |  Branch (2777:9): [True: 0, False: 0]
  |  |  ------------------
  |  | 2778|      0|    tmp = (xmlChar *) xmlRealloc(buffer, new_size);                     \
  |  | 2779|      0|    if (tmp == NULL) goto mem_error;					\
  |  |  ------------------
  |  |  |  Branch (2779:9): [True: 0, False: 0]
  |  |  ------------------
  |  | 2780|      0|    buffer = tmp;							\
  |  | 2781|      0|    buffer##_size = new_size;                                           \
  |  | 2782|      0|}
  ------------------
 2906|      0|		}
 2907|      0|		for (;i > 0;i--)
  ------------------
  |  Branch (2907:9): [True: 0, False: 0]
  ------------------
 2908|      0|		    buffer[nbchars++] = *cur++;
 2909|      0|		buffer[nbchars++] = ';';
 2910|      0|	    }
 2911|     62|	} else if (c == '%' && (what & XML_SUBSTITUTE_PEREF)) {
  ------------------
  |  |  527|      0|#define XML_SUBSTITUTE_PEREF	2
  ------------------
  |  Branch (2911:13): [True: 0, False: 62]
  |  Branch (2911:25): [True: 0, False: 0]
  ------------------
 2912|      0|	    if (xmlParserDebugEntities)
  ------------------
  |  |  870|      0|  #define xmlParserDebugEntities XML_GLOBAL_MACRO(xmlParserDebugEntities)
  |  |  ------------------
  |  |  |  |  500|      0|  #define XML_GLOBAL_MACRO(name) (*__##name())
  |  |  |  |  ------------------
  |  |  |  |  |  Branch (500:34): [True: 0, False: 0]
  |  |  |  |  ------------------
  |  |  ------------------
  ------------------
 2913|      0|		xmlGenericError(xmlGenericErrorContext,
  ------------------
  |  |  875|      0|  #define xmlGenericError XML_GLOBAL_MACRO(xmlGenericError)
  |  |  ------------------
  |  |  |  |  500|      0|  #define XML_GLOBAL_MACRO(name) (*__##name())
  |  |  ------------------
  ------------------
              		xmlGenericError(xmlGenericErrorContext,
  ------------------
  |  |  876|      0|  #define xmlGenericErrorContext XML_GLOBAL_MACRO(xmlGenericErrorContext)
  |  |  ------------------
  |  |  |  |  500|      0|  #define XML_GLOBAL_MACRO(name) (*__##name())
  |  |  ------------------
  ------------------
 2914|      0|			"String decoding PE Reference: %.30s\n", str);
 2915|      0|	    ent = xmlParseStringPEReference(ctxt, &str);
 2916|      0|	    if (ent != NULL) {
  ------------------
  |  Branch (2916:10): [True: 0, False: 0]
  ------------------
 2917|      0|                if (ent->content == NULL) {
  ------------------
  |  Branch (2917:21): [True: 0, False: 0]
  ------------------
 2918|       |		    /*
 2919|       |		     * Note: external parsed entities will not be loaded,
 2920|       |		     * it is not required for a non-validating parser to
 2921|       |		     * complete external PEReferences coming from the
 2922|       |		     * internal subset
 2923|       |		     */
 2924|      0|		    if (((ctxt->options & XML_PARSE_NOENT) != 0) ||
  ------------------
  |  Branch (2924:11): [True: 0, False: 0]
  ------------------
 2925|      0|			((ctxt->options & XML_PARSE_DTDVALID) != 0) ||
  ------------------
  |  Branch (2925:4): [True: 0, False: 0]
  ------------------
 2926|      0|			(ctxt->validate != 0)) {
  ------------------
  |  Branch (2926:4): [True: 0, False: 0]
  ------------------
 2927|      0|			xmlLoadEntityContent(ctxt, ent);
 2928|      0|		    } else {
 2929|      0|			xmlWarningMsg(ctxt, XML_ERR_ENTITY_PROCESSING,
 2930|      0|		  "not validating will not read content for PE entity %s\n",
 2931|      0|		                      ent->name, NULL);
 2932|      0|		    }
 2933|      0|		}
 2934|       |
 2935|      0|	        if ((check) && (xmlParserEntityCheck(ctxt, ent->length)))
  ------------------
  |  Branch (2935:14): [True: 0, False: 0]
  |  Branch (2935:25): [True: 0, False: 0]
  ------------------
 2936|      0|                    goto int_error;
 2937|       |
 2938|      0|                if (ent->flags & XML_ENT_EXPANDING) {
  ------------------
  |  |   16|      0|#define XML_ENT_EXPANDING   (1<<2)
  ------------------
  |  Branch (2938:21): [True: 0, False: 0]
  ------------------
 2939|      0|	            xmlFatalErr(ctxt, XML_ERR_ENTITY_LOOP, NULL);
 2940|      0|                    xmlHaltParser(ctxt);
 2941|      0|                    if (ent->content != NULL)
  ------------------
  |  Branch (2941:25): [True: 0, False: 0]
  ------------------
 2942|      0|                        ent->content[0] = 0;
 2943|      0|                    goto int_error;
 2944|      0|                }
 2945|       |
 2946|      0|                ent->flags |= XML_ENT_EXPANDING;
  ------------------
  |  |   16|      0|#define XML_ENT_EXPANDING   (1<<2)
  ------------------
 2947|      0|		ctxt->depth++;
 2948|      0|		rep = xmlStringDecodeEntitiesInt(ctxt, ent->content,
 2949|      0|                        ent->length, what, 0, 0, 0, check);
 2950|      0|		ctxt->depth--;
 2951|      0|                ent->flags &= ~XML_ENT_EXPANDING;
  ------------------
  |  |   16|      0|#define XML_ENT_EXPANDING   (1<<2)
  ------------------
 2952|       |
 2953|      0|		if (rep == NULL) {
  ------------------
  |  Branch (2953:7): [True: 0, False: 0]
  ------------------
 2954|      0|                    if (ent->content != NULL)
  ------------------
  |  Branch (2954:25): [True: 0, False: 0]
  ------------------
 2955|      0|                        ent->content[0] = 0;
 2956|      0|                    goto int_error;
 2957|      0|                }
 2958|      0|                current = rep;
 2959|      0|                while (*current != 0) { /* non input consuming loop */
  ------------------
  |  Branch (2959:24): [True: 0, False: 0]
  ------------------
 2960|      0|                    buffer[nbchars++] = *current++;
 2961|      0|                    if (nbchars + XML_PARSER_BUFFER_SIZE > buffer_size) {
  ------------------
  |  |  167|      0|#define XML_PARSER_BUFFER_SIZE 100
  ------------------
  |  Branch (2961:25): [True: 0, False: 0]
  ------------------
 2962|      0|                        growBuffer(buffer, XML_PARSER_BUFFER_SIZE);
  ------------------
  |  | 2774|      0|#define growBuffer(buffer, n) {						\
  |  | 2775|      0|    xmlChar *tmp;							\
  |  | 2776|      0|    size_t new_size = buffer##_size * 2 + n;                            \
  |  | 2777|      0|    if (new_size < buffer##_size) goto mem_error;                       \
  |  |  ------------------
  |  |  |  Branch (2777:9): [True: 0, False: 0]
  |  |  ------------------
  |  | 2778|      0|    tmp = (xmlChar *) xmlRealloc(buffer, new_size);                     \
  |  | 2779|      0|    if (tmp == NULL) goto mem_error;					\
  |  |  ------------------
  |  |  |  Branch (2779:9): [True: 0, False: 0]
  |  |  ------------------
  |  | 2780|      0|    buffer = tmp;							\
  |  | 2781|      0|    buffer##_size = new_size;                                           \
  |  | 2782|      0|}
  ------------------
 2963|      0|                    }
 2964|      0|                }
 2965|      0|                xmlFree(rep);
 2966|      0|                rep = NULL;
 2967|      0|	    }
 2968|     62|	} else {
 2969|     62|	    COPY_BUF(buffer, nbchars, c);
  ------------------
  |  | 2295|     62|    if (v < 0x80) b[i++] = v;						\
  |  |  ------------------
  |  |  |  Branch (2295:9): [True: 62, False: 0]
  |  |  ------------------
  |  | 2296|     62|    else i += xmlCopyCharMultiByte(&b[i],v)
  ------------------
 2970|     62|	    str += l;
 2971|     62|	    if (nbchars + XML_PARSER_BUFFER_SIZE > buffer_size) {
  ------------------
  |  |  167|     62|#define XML_PARSER_BUFFER_SIZE 100
  ------------------
  |  Branch (2971:10): [True: 0, False: 62]
  ------------------
 2972|      0|	        growBuffer(buffer, XML_PARSER_BUFFER_SIZE);
  ------------------
  |  | 2774|      0|#define growBuffer(buffer, n) {						\
  |  | 2775|      0|    xmlChar *tmp;							\
  |  | 2776|      0|    size_t new_size = buffer##_size * 2 + n;                            \
  |  | 2777|      0|    if (new_size < buffer##_size) goto mem_error;                       \
  |  |  ------------------
  |  |  |  Branch (2777:9): [True: 0, False: 0]
  |  |  ------------------
  |  | 2778|      0|    tmp = (xmlChar *) xmlRealloc(buffer, new_size);                     \
  |  | 2779|      0|    if (tmp == NULL) goto mem_error;					\
  |  |  ------------------
  |  |  |  Branch (2779:9): [True: 0, False: 0]
  |  |  ------------------
  |  | 2780|      0|    buffer = tmp;							\
  |  | 2781|      0|    buffer##_size = new_size;                                           \
  |  | 2782|      0|}
  ------------------
 2973|      0|	    }
 2974|     62|	}
 2975|     62|	if (str < last)
  ------------------
  |  Branch (2975:6): [True: 60, False: 2]
  ------------------
 2976|     60|	    c = CUR_SCHAR(str, l);
  ------------------
  |  | 2292|     60|#define CUR_SCHAR(s, l) xmlStringCurrentChar(ctxt, s, &l)
  ------------------
 2977|      2|	else
 2978|      2|	    c = 0;
 2979|     62|    }
 2980|      2|    buffer[nbchars] = 0;
 2981|      2|    return(buffer);
 2982|       |
 2983|      0|mem_error:
 2984|      0|    xmlErrMemory(ctxt, NULL);
 2985|      0|int_error:
 2986|      0|    if (rep != NULL)
  ------------------
  |  Branch (2986:9): [True: 0, False: 0]
  ------------------
 2987|      0|        xmlFree(rep);
 2988|      0|    if (buffer != NULL)
  ------------------
  |  Branch (2988:9): [True: 0, False: 0]
  ------------------
 2989|      0|        xmlFree(buffer);
 2990|      0|    return(NULL);
 2991|      0|}
parser.c:xmlFatalErrMsgStr:
  445|     83|{
  446|     83|    if ((ctxt != NULL) && (ctxt->disableSAX != 0) &&
  ------------------
  |  Branch (446:9): [True: 83, False: 0]
  |  Branch (446:27): [True: 50, False: 33]
  ------------------
  447|     83|        (ctxt->instate == XML_PARSER_EOF))
  ------------------
  |  Branch (447:9): [True: 0, False: 50]
  ------------------
  448|      0|	return;
  449|     83|    if (ctxt != NULL)
  ------------------
  |  Branch (449:9): [True: 83, False: 0]
  ------------------
  450|     83|	ctxt->errNo = error;
  451|     83|    __xmlRaiseError(NULL, NULL, NULL, ctxt, NULL,
  452|     83|                    XML_FROM_PARSER, error, XML_ERR_FATAL,
  453|     83|                    NULL, 0, (const char *) val, NULL, NULL, 0, 0, msg,
  454|     83|                    val);
  455|     83|    if (ctxt != NULL) {
  ------------------
  |  Branch (455:9): [True: 83, False: 0]
  ------------------
  456|     83|	ctxt->wellFormed = 0;
  457|     83|	if (ctxt->recovery == 0)
  ------------------
  |  Branch (457:6): [True: 83, False: 0]
  ------------------
  458|     83|	    ctxt->disableSAX = 1;
  459|     83|    }
  460|     83|}
parser.c:xmlParseNameComplex:
 3399|     17|xmlParseNameComplex(xmlParserCtxtPtr ctxt) {
 3400|     17|    int len = 0, l;
 3401|     17|    int c;
 3402|     17|    int maxLength = (ctxt->options & XML_PARSE_HUGE) ?
  ------------------
  |  Branch (3402:21): [True: 1, False: 16]
  ------------------
 3403|      1|                    XML_MAX_TEXT_LENGTH :
  ------------------
  |  |   42|      1|#define XML_MAX_TEXT_LENGTH 10000000
  ------------------
 3404|     17|                    XML_MAX_NAME_LENGTH;
  ------------------
  |  |   61|     16|#define XML_MAX_NAME_LENGTH 50000
  ------------------
 3405|       |
 3406|       |    /*
 3407|       |     * Handler for more complex cases
 3408|       |     */
 3409|     17|    c = CUR_CHAR(l);
  ------------------
  |  | 2291|     17|#define CUR_CHAR(l) xmlCurrentChar(ctxt, &l)
  ------------------
 3410|     17|    if ((ctxt->options & XML_PARSE_OLD10) == 0) {
  ------------------
  |  Branch (3410:9): [True: 16, False: 1]
  ------------------
 3411|       |        /*
 3412|       |	 * Use the new checks of production [4] [4a] amd [5] of the
 3413|       |	 * Update 5 of XML-1.0
 3414|       |	 */
 3415|     16|	if ((c == ' ') || (c == '>') || (c == '/') || /* accelerators */
  ------------------
  |  Branch (3415:6): [True: 0, False: 16]
  |  Branch (3415:20): [True: 0, False: 16]
  |  Branch (3415:34): [True: 0, False: 16]
  ------------------
 3416|     16|	    (!(((c >= 'a') && (c <= 'z')) ||
  ------------------
  |  Branch (3416:10): [True: 4, False: 12]
  |  Branch (3416:24): [True: 4, False: 0]
  ------------------
 3417|     16|	       ((c >= 'A') && (c <= 'Z')) ||
  ------------------
  |  Branch (3417:10): [True: 0, False: 12]
  |  Branch (3417:24): [True: 0, False: 0]
  ------------------
 3418|     16|	       (c == '_') || (c == ':') ||
  ------------------
  |  Branch (3418:9): [True: 0, False: 12]
  |  Branch (3418:23): [True: 0, False: 12]
  ------------------
 3419|     16|	       ((c >= 0xC0) && (c <= 0xD6)) ||
  ------------------
  |  Branch (3419:10): [True: 0, False: 12]
  |  Branch (3419:25): [True: 0, False: 0]
  ------------------
 3420|     16|	       ((c >= 0xD8) && (c <= 0xF6)) ||
  ------------------
  |  Branch (3420:10): [True: 0, False: 12]
  |  Branch (3420:25): [True: 0, False: 0]
  ------------------
 3421|     16|	       ((c >= 0xF8) && (c <= 0x2FF)) ||
  ------------------
  |  Branch (3421:10): [True: 0, False: 12]
  |  Branch (3421:25): [True: 0, False: 0]
  ------------------
 3422|     16|	       ((c >= 0x370) && (c <= 0x37D)) ||
  ------------------
  |  Branch (3422:10): [True: 0, False: 12]
  |  Branch (3422:26): [True: 0, False: 0]
  ------------------
 3423|     16|	       ((c >= 0x37F) && (c <= 0x1FFF)) ||
  ------------------
  |  Branch (3423:10): [True: 0, False: 12]
  |  Branch (3423:26): [True: 0, False: 0]
  ------------------
 3424|     16|	       ((c >= 0x200C) && (c <= 0x200D)) ||
  ------------------
  |  Branch (3424:10): [True: 0, False: 12]
  |  Branch (3424:27): [True: 0, False: 0]
  ------------------
 3425|     16|	       ((c >= 0x2070) && (c <= 0x218F)) ||
  ------------------
  |  Branch (3425:10): [True: 0, False: 12]
  |  Branch (3425:27): [True: 0, False: 0]
  ------------------
 3426|     16|	       ((c >= 0x2C00) && (c <= 0x2FEF)) ||
  ------------------
  |  Branch (3426:10): [True: 0, False: 12]
  |  Branch (3426:27): [True: 0, False: 0]
  ------------------
 3427|     16|	       ((c >= 0x3001) && (c <= 0xD7FF)) ||
  ------------------
  |  Branch (3427:10): [True: 0, False: 12]
  |  Branch (3427:27): [True: 0, False: 0]
  ------------------
 3428|     16|	       ((c >= 0xF900) && (c <= 0xFDCF)) ||
  ------------------
  |  Branch (3428:10): [True: 0, False: 12]
  |  Branch (3428:27): [True: 0, False: 0]
  ------------------
 3429|     16|	       ((c >= 0xFDF0) && (c <= 0xFFFD)) ||
  ------------------
  |  Branch (3429:10): [True: 0, False: 12]
  |  Branch (3429:27): [True: 0, False: 0]
  ------------------
 3430|     16|	       ((c >= 0x10000) && (c <= 0xEFFFF))))) {
  ------------------
  |  Branch (3430:10): [True: 0, False: 12]
  |  Branch (3430:28): [True: 0, False: 0]
  ------------------
 3431|     12|	    return(NULL);
 3432|     12|	}
 3433|      4|	len += l;
 3434|      4|	NEXTL(l);
  ------------------
  |  | 2284|      4|#define NEXTL(l) do {							\
  |  | 2285|      4|    if (*(ctxt->input->cur) == '\n') {					\
  |  |  ------------------
  |  |  |  Branch (2285:9): [True: 0, False: 4]
  |  |  ------------------
  |  | 2286|      0|	ctxt->input->line++; ctxt->input->col = 1;			\
  |  | 2287|      4|    } else ctxt->input->col++;						\
  |  | 2288|      4|    ctxt->input->cur += l;				\
  |  | 2289|      4|  } while (0)
  |  |  ------------------
  |  |  |  Branch (2289:12): [Folded - Ignored]
  |  |  ------------------
  ------------------
 3435|      4|	c = CUR_CHAR(l);
  ------------------
  |  | 2291|      4|#define CUR_CHAR(l) xmlCurrentChar(ctxt, &l)
  ------------------
 3436|     12|	while ((c != ' ') && (c != '>') && (c != '/') && /* accelerators */
  ------------------
  |  Branch (3436:9): [True: 12, False: 0]
  |  Branch (3436:23): [True: 12, False: 0]
  |  Branch (3436:37): [True: 12, False: 0]
  ------------------
 3437|     12|	       (((c >= 'a') && (c <= 'z')) ||
  ------------------
  |  Branch (3437:11): [True: 8, False: 4]
  |  Branch (3437:25): [True: 8, False: 0]
  ------------------
 3438|     12|	        ((c >= 'A') && (c <= 'Z')) ||
  ------------------
  |  Branch (3438:11): [True: 0, False: 4]
  |  Branch (3438:25): [True: 0, False: 0]
  ------------------
 3439|     12|	        ((c >= '0') && (c <= '9')) || /* !start */
  ------------------
  |  Branch (3439:11): [True: 0, False: 4]
  |  Branch (3439:25): [True: 0, False: 0]
  ------------------
 3440|     12|	        (c == '_') || (c == ':') ||
  ------------------
  |  Branch (3440:10): [True: 0, False: 4]
  |  Branch (3440:24): [True: 0, False: 4]
  ------------------
 3441|     12|	        (c == '-') || (c == '.') || (c == 0xB7) || /* !start */
  ------------------
  |  Branch (3441:10): [True: 0, False: 4]
  |  Branch (3441:24): [True: 0, False: 4]
  |  Branch (3441:38): [True: 0, False: 4]
  ------------------
 3442|     12|	        ((c >= 0xC0) && (c <= 0xD6)) ||
  ------------------
  |  Branch (3442:11): [True: 0, False: 4]
  |  Branch (3442:26): [True: 0, False: 0]
  ------------------
 3443|     12|	        ((c >= 0xD8) && (c <= 0xF6)) ||
  ------------------
  |  Branch (3443:11): [True: 0, False: 4]
  |  Branch (3443:26): [True: 0, False: 0]
  ------------------
 3444|     12|	        ((c >= 0xF8) && (c <= 0x2FF)) ||
  ------------------
  |  Branch (3444:11): [True: 0, False: 4]
  |  Branch (3444:26): [True: 0, False: 0]
  ------------------
 3445|     12|	        ((c >= 0x300) && (c <= 0x36F)) || /* !start */
  ------------------
  |  Branch (3445:11): [True: 0, False: 4]
  |  Branch (3445:27): [True: 0, False: 0]
  ------------------
 3446|     12|	        ((c >= 0x370) && (c <= 0x37D)) ||
  ------------------
  |  Branch (3446:11): [True: 0, False: 4]
  |  Branch (3446:27): [True: 0, False: 0]
  ------------------
 3447|     12|	        ((c >= 0x37F) && (c <= 0x1FFF)) ||
  ------------------
  |  Branch (3447:11): [True: 0, False: 4]
  |  Branch (3447:27): [True: 0, False: 0]
  ------------------
 3448|     12|	        ((c >= 0x200C) && (c <= 0x200D)) ||
  ------------------
  |  Branch (3448:11): [True: 0, False: 4]
  |  Branch (3448:28): [True: 0, False: 0]
  ------------------
 3449|     12|	        ((c >= 0x203F) && (c <= 0x2040)) || /* !start */
  ------------------
  |  Branch (3449:11): [True: 0, False: 4]
  |  Branch (3449:28): [True: 0, False: 0]
  ------------------
 3450|     12|	        ((c >= 0x2070) && (c <= 0x218F)) ||
  ------------------
  |  Branch (3450:11): [True: 0, False: 4]
  |  Branch (3450:28): [True: 0, False: 0]
  ------------------
 3451|     12|	        ((c >= 0x2C00) && (c <= 0x2FEF)) ||
  ------------------
  |  Branch (3451:11): [True: 0, False: 4]
  |  Branch (3451:28): [True: 0, False: 0]
  ------------------
 3452|     12|	        ((c >= 0x3001) && (c <= 0xD7FF)) ||
  ------------------
  |  Branch (3452:11): [True: 0, False: 4]
  |  Branch (3452:28): [True: 0, False: 0]
  ------------------
 3453|     12|	        ((c >= 0xF900) && (c <= 0xFDCF)) ||
  ------------------
  |  Branch (3453:11): [True: 0, False: 4]
  |  Branch (3453:28): [True: 0, False: 0]
  ------------------
 3454|     12|	        ((c >= 0xFDF0) && (c <= 0xFFFD)) ||
  ------------------
  |  Branch (3454:11): [True: 0, False: 4]
  |  Branch (3454:28): [True: 0, False: 0]
  ------------------
 3455|     12|	        ((c >= 0x10000) && (c <= 0xEFFFF))
  ------------------
  |  Branch (3455:11): [True: 0, False: 4]
  |  Branch (3455:29): [True: 0, False: 0]
  ------------------
 3456|     12|		)) {
 3457|      8|            if (len <= INT_MAX - l)
  ------------------
  |  Branch (3457:17): [True: 8, False: 0]
  ------------------
 3458|      8|	        len += l;
 3459|      8|	    NEXTL(l);
  ------------------
  |  | 2284|      8|#define NEXTL(l) do {							\
  |  | 2285|      8|    if (*(ctxt->input->cur) == '\n') {					\
  |  |  ------------------
  |  |  |  Branch (2285:9): [True: 0, False: 8]
  |  |  ------------------
  |  | 2286|      0|	ctxt->input->line++; ctxt->input->col = 1;			\
  |  | 2287|      8|    } else ctxt->input->col++;						\
  |  | 2288|      8|    ctxt->input->cur += l;				\
  |  | 2289|      8|  } while (0)
  |  |  ------------------
  |  |  |  Branch (2289:12): [Folded - Ignored]
  |  |  ------------------
  ------------------
 3460|      8|	    c = CUR_CHAR(l);
  ------------------
  |  | 2291|      8|#define CUR_CHAR(l) xmlCurrentChar(ctxt, &l)
  ------------------
 3461|      8|	}
 3462|      4|    } else {
 3463|      1|	if ((c == ' ') || (c == '>') || (c == '/') || /* accelerators */
  ------------------
  |  Branch (3463:6): [True: 0, False: 1]
  |  Branch (3463:20): [True: 0, False: 1]
  |  Branch (3463:34): [True: 0, False: 1]
  ------------------
 3464|      1|	    (!IS_LETTER(c) && (c != '_') &&
  ------------------
  |  |  240|      2|#define IS_LETTER(c) (IS_BASECHAR(c) || IS_IDEOGRAPHIC(c))
  |  |  ------------------
  |  |  |  |  161|      1|#define IS_BASECHAR(c) xmlIsBaseCharQ(c)
  |  |  |  |  ------------------
  |  |  |  |  |  |   76|      2|#define xmlIsBaseCharQ(c)	(((c) < 0x100) ? \
  |  |  |  |  |  |  ------------------
  |  |  |  |  |  |  |  Branch (76:27): [True: 0, False: 1]
  |  |  |  |  |  |  |  Branch (76:28): [True: 1, False: 0]
  |  |  |  |  |  |  ------------------
  |  |  |  |  |  |   77|      2|				 xmlIsBaseChar_ch((c)) : \
  |  |  |  |  |  |  ------------------
  |  |  |  |  |  |  |  |   64|      1|#define xmlIsBaseChar_ch(c)	(((0x41 <= (c)) && ((c) <= 0x5a)) || \
  |  |  |  |  |  |  |  |  ------------------
  |  |  |  |  |  |  |  |  |  Branch (64:31): [True: 0, False: 1]
  |  |  |  |  |  |  |  |  |  Branch (64:48): [True: 0, False: 0]
  |  |  |  |  |  |  |  |  ------------------
  |  |  |  |  |  |  |  |   65|      1|				 ((0x61 <= (c)) && ((c) <= 0x7a)) || \
  |  |  |  |  |  |  |  |  ------------------
  |  |  |  |  |  |  |  |  |  Branch (65:7): [True: 0, False: 1]
  |  |  |  |  |  |  |  |  |  Branch (65:24): [True: 0, False: 0]
  |  |  |  |  |  |  |  |  ------------------
  |  |  |  |  |  |  |  |   66|      1|				 ((0xc0 <= (c)) && ((c) <= 0xd6)) || \
  |  |  |  |  |  |  |  |  ------------------
  |  |  |  |  |  |  |  |  |  Branch (66:7): [True: 0, False: 1]
  |  |  |  |  |  |  |  |  |  Branch (66:24): [True: 0, False: 0]
  |  |  |  |  |  |  |  |  ------------------
  |  |  |  |  |  |  |  |   67|      1|				 ((0xd8 <= (c)) && ((c) <= 0xf6)) || \
  |  |  |  |  |  |  |  |  ------------------
  |  |  |  |  |  |  |  |  |  Branch (67:7): [True: 0, False: 1]
  |  |  |  |  |  |  |  |  |  Branch (67:24): [True: 0, False: 0]
  |  |  |  |  |  |  |  |  ------------------
  |  |  |  |  |  |  |  |   68|      1|				  (0xf8 <= (c)))
  |  |  |  |  |  |  |  |  ------------------
  |  |  |  |  |  |  |  |  |  Branch (68:7): [True: 0, False: 1]
  |  |  |  |  |  |  |  |  ------------------
  |  |  |  |  |  |  ------------------
  |  |  |  |  |  |   78|      2|				 xmlCharInRange((c), &xmlIsBaseCharGroup))
  |  |  |  |  ------------------
  |  |  ------------------
  |  |               #define IS_LETTER(c) (IS_BASECHAR(c) || IS_IDEOGRAPHIC(c))
  |  |  ------------------
  |  |  |  |  229|      1|#define IS_IDEOGRAPHIC(c) xmlIsIdeographicQ(c)
  |  |  |  |  ------------------
  |  |  |  |  |  |  184|      1|#define xmlIsIdeographicQ(c)	(((c) < 0x100) ? \
  |  |  |  |  |  |  ------------------
  |  |  |  |  |  |  |  Branch (184:30): [True: 0, False: 1]
  |  |  |  |  |  |  |  Branch (184:31): [True: 1, False: 0]
  |  |  |  |  |  |  ------------------
  |  |  |  |  |  |  185|      1|				 0 :\
  |  |  |  |  |  |  186|      1|				(((0x4e00 <= (c)) && ((c) <= 0x9fa5)) || \
  |  |  |  |  |  |  ------------------
  |  |  |  |  |  |  |  Branch (186:7): [True: 0, False: 0]
  |  |  |  |  |  |  |  Branch (186:26): [True: 0, False: 0]
  |  |  |  |  |  |  ------------------
  |  |  |  |  |  |  187|      0|				 ((c) == 0x3007) || \
  |  |  |  |  |  |  ------------------
  |  |  |  |  |  |  |  Branch (187:6): [True: 0, False: 0]
  |  |  |  |  |  |  ------------------
  |  |  |  |  |  |  188|      0|				 ((0x3021 <= (c)) && ((c) <= 0x3029))))
  |  |  |  |  |  |  ------------------
  |  |  |  |  |  |  |  Branch (188:7): [True: 0, False: 0]
  |  |  |  |  |  |  |  Branch (188:26): [True: 0, False: 0]
  |  |  |  |  |  |  ------------------
  |  |  |  |  ------------------
  |  |  ------------------
  ------------------
  |  Branch (3464:24): [True: 1, False: 0]
  ------------------
 3465|      1|	     (c != ':'))) {
  ------------------
  |  Branch (3465:7): [True: 1, False: 0]
  ------------------
 3466|      1|	    return(NULL);
 3467|      1|	}
 3468|      0|	len += l;
 3469|      0|	NEXTL(l);
  ------------------
  |  | 2284|      0|#define NEXTL(l) do {							\
  |  | 2285|      0|    if (*(ctxt->input->cur) == '\n') {					\
  |  |  ------------------
  |  |  |  Branch (2285:9): [True: 0, False: 0]
  |  |  ------------------
  |  | 2286|      0|	ctxt->input->line++; ctxt->input->col = 1;			\
  |  | 2287|      0|    } else ctxt->input->col++;						\
  |  | 2288|      0|    ctxt->input->cur += l;				\
  |  | 2289|      0|  } while (0)
  |  |  ------------------
  |  |  |  Branch (2289:12): [Folded - Ignored]
  |  |  ------------------
  ------------------
 3470|      0|	c = CUR_CHAR(l);
  ------------------
  |  | 2291|      0|#define CUR_CHAR(l) xmlCurrentChar(ctxt, &l)
  ------------------
 3471|       |
 3472|      0|	while ((c != ' ') && (c != '>') && (c != '/') && /* test bigname.xml */
  ------------------
  |  Branch (3472:9): [True: 0, False: 0]
  |  Branch (3472:23): [True: 0, False: 0]
  |  Branch (3472:37): [True: 0, False: 0]
  ------------------
 3473|      0|	       ((IS_LETTER(c)) || (IS_DIGIT(c)) ||
  ------------------
  |  |  240|      0|#define IS_LETTER(c) (IS_BASECHAR(c) || IS_IDEOGRAPHIC(c))
  |  |  ------------------
  |  |  |  |  161|      0|#define IS_BASECHAR(c) xmlIsBaseCharQ(c)
  |  |  |  |  ------------------
  |  |  |  |  |  |   76|      0|#define xmlIsBaseCharQ(c)	(((c) < 0x100) ? \
  |  |  |  |  |  |  ------------------
  |  |  |  |  |  |  |  Branch (76:27): [True: 0, False: 0]
  |  |  |  |  |  |  |  Branch (76:28): [True: 0, False: 0]
  |  |  |  |  |  |  ------------------
  |  |  |  |  |  |   77|      0|				 xmlIsBaseChar_ch((c)) : \
  |  |  |  |  |  |  ------------------
  |  |  |  |  |  |  |  |   64|      0|#define xmlIsBaseChar_ch(c)	(((0x41 <= (c)) && ((c) <= 0x5a)) || \
  |  |  |  |  |  |  |  |  ------------------
  |  |  |  |  |  |  |  |  |  Branch (64:31): [True: 0, False: 0]
  |  |  |  |  |  |  |  |  |  Branch (64:48): [True: 0, False: 0]
  |  |  |  |  |  |  |  |  ------------------
  |  |  |  |  |  |  |  |   65|      0|				 ((0x61 <= (c)) && ((c) <= 0x7a)) || \
  |  |  |  |  |  |  |  |  ------------------
  |  |  |  |  |  |  |  |  |  Branch (65:7): [True: 0, False: 0]
  |  |  |  |  |  |  |  |  |  Branch (65:24): [True: 0, False: 0]
  |  |  |  |  |  |  |  |  ------------------
  |  |  |  |  |  |  |  |   66|      0|				 ((0xc0 <= (c)) && ((c) <= 0xd6)) || \
  |  |  |  |  |  |  |  |  ------------------
  |  |  |  |  |  |  |  |  |  Branch (66:7): [True: 0, False: 0]
  |  |  |  |  |  |  |  |  |  Branch (66:24): [True: 0, False: 0]
  |  |  |  |  |  |  |  |  ------------------
  |  |  |  |  |  |  |  |   67|      0|				 ((0xd8 <= (c)) && ((c) <= 0xf6)) || \
  |  |  |  |  |  |  |  |  ------------------
  |  |  |  |  |  |  |  |  |  Branch (67:7): [True: 0, False: 0]
  |  |  |  |  |  |  |  |  |  Branch (67:24): [True: 0, False: 0]
  |  |  |  |  |  |  |  |  ------------------
  |  |  |  |  |  |  |  |   68|      0|				  (0xf8 <= (c)))
  |  |  |  |  |  |  |  |  ------------------
  |  |  |  |  |  |  |  |  |  Branch (68:7): [True: 0, False: 0]
  |  |  |  |  |  |  |  |  ------------------
  |  |  |  |  |  |  ------------------
  |  |  |  |  |  |   78|      0|				 xmlCharInRange((c), &xmlIsBaseCharGroup))
  |  |  |  |  ------------------
  |  |  ------------------
  |  |               #define IS_LETTER(c) (IS_BASECHAR(c) || IS_IDEOGRAPHIC(c))
  |  |  ------------------
  |  |  |  |  229|      0|#define IS_IDEOGRAPHIC(c) xmlIsIdeographicQ(c)
  |  |  |  |  ------------------
  |  |  |  |  |  |  184|      0|#define xmlIsIdeographicQ(c)	(((c) < 0x100) ? \
  |  |  |  |  |  |  ------------------
  |  |  |  |  |  |  |  Branch (184:30): [True: 0, False: 0]
  |  |  |  |  |  |  |  Branch (184:31): [True: 0, False: 0]
  |  |  |  |  |  |  ------------------
  |  |  |  |  |  |  185|      0|				 0 :\
  |  |  |  |  |  |  186|      0|				(((0x4e00 <= (c)) && ((c) <= 0x9fa5)) || \
  |  |  |  |  |  |  ------------------
  |  |  |  |  |  |  |  Branch (186:7): [True: 0, False: 0]
  |  |  |  |  |  |  |  Branch (186:26): [True: 0, False: 0]
  |  |  |  |  |  |  ------------------
  |  |  |  |  |  |  187|      0|				 ((c) == 0x3007) || \
  |  |  |  |  |  |  ------------------
  |  |  |  |  |  |  |  Branch (187:6): [True: 0, False: 0]
  |  |  |  |  |  |  ------------------
  |  |  |  |  |  |  188|      0|				 ((0x3021 <= (c)) && ((c) <= 0x3029))))
  |  |  |  |  |  |  ------------------
  |  |  |  |  |  |  |  Branch (188:7): [True: 0, False: 0]
  |  |  |  |  |  |  |  Branch (188:26): [True: 0, False: 0]
  |  |  |  |  |  |  ------------------
  |  |  |  |  ------------------
  |  |  ------------------
  ------------------
              	       ((IS_LETTER(c)) || (IS_DIGIT(c)) ||
  ------------------
  |  |  171|      0|#define IS_DIGIT(c) xmlIsDigitQ(c)
  |  |  ------------------
  |  |  |  |  152|      0|#define xmlIsDigitQ(c)		(((c) < 0x100) ? \
  |  |  |  |  ------------------
  |  |  |  |  |  Branch (152:26): [True: 0, False: 0]
  |  |  |  |  ------------------
  |  |  |  |  153|      0|				 xmlIsDigit_ch((c)) : \
  |  |  |  |  ------------------
  |  |  |  |  |  |  144|      0|#define xmlIsDigit_ch(c)	(((0x30 <= (c)) && ((c) <= 0x39)))
  |  |  |  |  |  |  ------------------
  |  |  |  |  |  |  |  Branch (144:28): [True: 0, False: 0]
  |  |  |  |  |  |  |  Branch (144:45): [True: 0, False: 0]
  |  |  |  |  |  |  ------------------
  |  |  |  |  ------------------
  |  |  |  |  154|      0|				 xmlCharInRange((c), &xmlIsDigitGroup))
  |  |  ------------------
  ------------------
  |  Branch (3473:28): [True: 0, False: 0]
  ------------------
 3474|      0|		(c == '.') || (c == '-') ||
  ------------------
  |  Branch (3474:3): [True: 0, False: 0]
  |  Branch (3474:17): [True: 0, False: 0]
  ------------------
 3475|      0|		(c == '_') || (c == ':') ||
  ------------------
  |  Branch (3475:3): [True: 0, False: 0]
  |  Branch (3475:17): [True: 0, False: 0]
  ------------------
 3476|      0|		(IS_COMBINING(c)) ||
  ------------------
  |  |  189|      0|#define IS_COMBINING(c) xmlIsCombiningQ(c)
  |  |  ------------------
  |  |  |  |  132|      0|#define xmlIsCombiningQ(c)	(((c) < 0x100) ? \
  |  |  |  |  ------------------
  |  |  |  |  |  Branch (132:29): [True: 0, False: 0]
  |  |  |  |  ------------------
  |  |  |  |  133|      0|				 0 : \
  |  |  |  |  134|      0|				 xmlCharInRange((c), &xmlIsCombiningGroup))
  |  |  ------------------
  ------------------
  |  Branch (3476:3): [True: 0, False: 0]
  ------------------
 3477|      0|		(IS_EXTENDER(c)))) {
  ------------------
  |  |  210|      0|#define IS_EXTENDER(c) xmlIsExtenderQ(c)
  |  |  ------------------
  |  |  |  |  172|      0|#define xmlIsExtenderQ(c)	(((c) < 0x100) ? \
  |  |  |  |  ------------------
  |  |  |  |  |  Branch (172:28): [True: 0, False: 0]
  |  |  |  |  ------------------
  |  |  |  |  173|      0|				 xmlIsExtender_ch((c)) : \
  |  |  |  |  ------------------
  |  |  |  |  |  |  164|      0|#define xmlIsExtender_ch(c)	(((c) == 0xb7))
  |  |  |  |  ------------------
  |  |  |  |  174|      0|				 xmlCharInRange((c), &xmlIsExtenderGroup))
  |  |  ------------------
  ------------------
  |  Branch (3477:3): [True: 0, False: 0]
  ------------------
 3478|      0|            if (len <= INT_MAX - l)
  ------------------
  |  Branch (3478:17): [True: 0, False: 0]
  ------------------
 3479|      0|	        len += l;
 3480|      0|	    NEXTL(l);
  ------------------
  |  | 2284|      0|#define NEXTL(l) do {							\
  |  | 2285|      0|    if (*(ctxt->input->cur) == '\n') {					\
  |  |  ------------------
  |  |  |  Branch (2285:9): [True: 0, False: 0]
  |  |  ------------------
  |  | 2286|      0|	ctxt->input->line++; ctxt->input->col = 1;			\
  |  | 2287|      0|    } else ctxt->input->col++;						\
  |  | 2288|      0|    ctxt->input->cur += l;				\
  |  | 2289|      0|  } while (0)
  |  |  ------------------
  |  |  |  Branch (2289:12): [Folded - Ignored]
  |  |  ------------------
  ------------------
 3481|      0|	    c = CUR_CHAR(l);
  ------------------
  |  | 2291|      0|#define CUR_CHAR(l) xmlCurrentChar(ctxt, &l)
  ------------------
 3482|      0|	}
 3483|      0|    }
 3484|      4|    if (ctxt->instate == XML_PARSER_EOF)
  ------------------
  |  Branch (3484:9): [True: 0, False: 4]
  ------------------
 3485|      0|        return(NULL);
 3486|      4|    if (len > maxLength) {
  ------------------
  |  Branch (3486:9): [True: 0, False: 4]
  ------------------
 3487|      0|        xmlFatalErr(ctxt, XML_ERR_NAME_TOO_LONG, "Name");
 3488|      0|        return(NULL);
 3489|      0|    }
 3490|      4|    if (ctxt->input->cur - ctxt->input->base < len) {
  ------------------
  |  Branch (3490:9): [True: 0, False: 4]
  ------------------
 3491|       |        /*
 3492|       |         * There were a couple of bugs where PERefs lead to to a change
 3493|       |         * of the buffer. Check the buffer size to avoid passing an invalid
 3494|       |         * pointer to xmlDictLookup.
 3495|       |         */
 3496|      0|        xmlFatalErr(ctxt, XML_ERR_INTERNAL_ERROR,
 3497|      0|                    "unexpected change of input buffer");
 3498|      0|        return (NULL);
 3499|      0|    }
 3500|      4|    if ((*ctxt->input->cur == '\n') && (ctxt->input->cur[-1] == '\r'))
  ------------------
  |  Branch (3500:9): [True: 0, False: 4]
  |  Branch (3500:40): [True: 0, False: 0]
  ------------------
 3501|      0|        return(xmlDictLookup(ctxt->dict, ctxt->input->cur - (len + 1), len));
 3502|      4|    return(xmlDictLookup(ctxt->dict, ctxt->input->cur - len, len));
 3503|      4|}
parser.c:xmlIsNameChar:
 3357|    280|xmlIsNameChar(xmlParserCtxtPtr ctxt, int c) {
 3358|    280|    if ((ctxt->options & XML_PARSE_OLD10) == 0) {
  ------------------
  |  Branch (3358:9): [True: 280, False: 0]
  ------------------
 3359|       |        /*
 3360|       |	 * Use the new checks of production [4] [4a] amd [5] of the
 3361|       |	 * Update 5 of XML-1.0
 3362|       |	 */
 3363|    280|	if ((c != ' ') && (c != '>') && (c != '/') && /* accelerators */
  ------------------
  |  Branch (3363:6): [True: 276, False: 4]
  |  Branch (3363:20): [True: 276, False: 0]
  |  Branch (3363:34): [True: 276, False: 0]
  ------------------
 3364|    280|	    (((c >= 'a') && (c <= 'z')) ||
  ------------------
  |  Branch (3364:8): [True: 241, False: 35]
  |  Branch (3364:22): [True: 128, False: 113]
  ------------------
 3365|    276|	     ((c >= 'A') && (c <= 'Z')) ||
  ------------------
  |  Branch (3365:8): [True: 113, False: 35]
  |  Branch (3365:22): [True: 0, False: 113]
  ------------------
 3366|    276|	     ((c >= '0') && (c <= '9')) || /* !start */
  ------------------
  |  Branch (3366:8): [True: 129, False: 19]
  |  Branch (3366:22): [True: 8, False: 121]
  ------------------
 3367|    276|	     (c == '_') || (c == ':') ||
  ------------------
  |  Branch (3367:7): [True: 0, False: 140]
  |  Branch (3367:21): [True: 4, False: 136]
  ------------------
 3368|    276|	     (c == '-') || (c == '.') || (c == 0xB7) || /* !start */
  ------------------
  |  Branch (3368:7): [True: 2, False: 134]
  |  Branch (3368:21): [True: 2, False: 132]
  |  Branch (3368:35): [True: 0, False: 132]
  ------------------
 3369|    276|	     ((c >= 0xC0) && (c <= 0xD6)) ||
  ------------------
  |  Branch (3369:8): [True: 113, False: 19]
  |  Branch (3369:23): [True: 0, False: 113]
  ------------------
 3370|    276|	     ((c >= 0xD8) && (c <= 0xF6)) ||
  ------------------
  |  Branch (3370:8): [True: 113, False: 19]
  |  Branch (3370:23): [True: 0, False: 113]
  ------------------
 3371|    276|	     ((c >= 0xF8) && (c <= 0x2FF)) ||
  ------------------
  |  Branch (3371:8): [True: 113, False: 19]
  |  Branch (3371:23): [True: 3, False: 110]
  ------------------
 3372|    276|	     ((c >= 0x300) && (c <= 0x36F)) || /* !start */
  ------------------
  |  Branch (3372:8): [True: 110, False: 19]
  |  Branch (3372:24): [True: 0, False: 110]
  ------------------
 3373|    276|	     ((c >= 0x370) && (c <= 0x37D)) ||
  ------------------
  |  Branch (3373:8): [True: 110, False: 19]
  |  Branch (3373:24): [True: 0, False: 110]
  ------------------
 3374|    276|	     ((c >= 0x37F) && (c <= 0x1FFF)) ||
  ------------------
  |  Branch (3374:8): [True: 110, False: 19]
  |  Branch (3374:24): [True: 0, False: 110]
  ------------------
 3375|    276|	     ((c >= 0x200C) && (c <= 0x200D)) ||
  ------------------
  |  Branch (3375:8): [True: 110, False: 19]
  |  Branch (3375:25): [True: 0, False: 110]
  ------------------
 3376|    276|	     ((c >= 0x203F) && (c <= 0x2040)) || /* !start */
  ------------------
  |  Branch (3376:8): [True: 110, False: 19]
  |  Branch (3376:25): [True: 0, False: 110]
  ------------------
 3377|    276|	     ((c >= 0x2070) && (c <= 0x218F)) ||
  ------------------
  |  Branch (3377:8): [True: 110, False: 19]
  |  Branch (3377:25): [True: 0, False: 110]
  ------------------
 3378|    276|	     ((c >= 0x2C00) && (c <= 0x2FEF)) ||
  ------------------
  |  Branch (3378:8): [True: 110, False: 19]
  |  Branch (3378:25): [True: 0, False: 110]
  ------------------
 3379|    276|	     ((c >= 0x3001) && (c <= 0xD7FF)) ||
  ------------------
  |  Branch (3379:8): [True: 110, False: 19]
  |  Branch (3379:25): [True: 0, False: 110]
  ------------------
 3380|    276|	     ((c >= 0xF900) && (c <= 0xFDCF)) ||
  ------------------
  |  Branch (3380:8): [True: 110, False: 19]
  |  Branch (3380:25): [True: 0, False: 110]
  ------------------
 3381|    276|	     ((c >= 0xFDF0) && (c <= 0xFFFD)) ||
  ------------------
  |  Branch (3381:8): [True: 110, False: 19]
  |  Branch (3381:25): [True: 110, False: 0]
  ------------------
 3382|    276|	     ((c >= 0x10000) && (c <= 0xEFFFF))))
  ------------------
  |  Branch (3382:8): [True: 0, False: 19]
  |  Branch (3382:26): [True: 0, False: 0]
  ------------------
 3383|    257|	     return(1);
 3384|    280|    } else {
 3385|      0|        if ((IS_LETTER(c)) || (IS_DIGIT(c)) ||
  ------------------
  |  |  240|      0|#define IS_LETTER(c) (IS_BASECHAR(c) || IS_IDEOGRAPHIC(c))
  |  |  ------------------
  |  |  |  |  161|      0|#define IS_BASECHAR(c) xmlIsBaseCharQ(c)
  |  |  |  |  ------------------
  |  |  |  |  |  |   76|      0|#define xmlIsBaseCharQ(c)	(((c) < 0x100) ? \
  |  |  |  |  |  |  ------------------
  |  |  |  |  |  |  |  Branch (76:27): [True: 0, False: 0]
  |  |  |  |  |  |  |  Branch (76:28): [True: 0, False: 0]
  |  |  |  |  |  |  ------------------
  |  |  |  |  |  |   77|      0|				 xmlIsBaseChar_ch((c)) : \
  |  |  |  |  |  |  ------------------
  |  |  |  |  |  |  |  |   64|      0|#define xmlIsBaseChar_ch(c)	(((0x41 <= (c)) && ((c) <= 0x5a)) || \
  |  |  |  |  |  |  |  |  ------------------
  |  |  |  |  |  |  |  |  |  Branch (64:31): [True: 0, False: 0]
  |  |  |  |  |  |  |  |  |  Branch (64:48): [True: 0, False: 0]
  |  |  |  |  |  |  |  |  ------------------
  |  |  |  |  |  |  |  |   65|      0|				 ((0x61 <= (c)) && ((c) <= 0x7a)) || \
  |  |  |  |  |  |  |  |  ------------------
  |  |  |  |  |  |  |  |  |  Branch (65:7): [True: 0, False: 0]
  |  |  |  |  |  |  |  |  |  Branch (65:24): [True: 0, False: 0]
  |  |  |  |  |  |  |  |  ------------------
  |  |  |  |  |  |  |  |   66|      0|				 ((0xc0 <= (c)) && ((c) <= 0xd6)) || \
  |  |  |  |  |  |  |  |  ------------------
  |  |  |  |  |  |  |  |  |  Branch (66:7): [True: 0, False: 0]
  |  |  |  |  |  |  |  |  |  Branch (66:24): [True: 0, False: 0]
  |  |  |  |  |  |  |  |  ------------------
  |  |  |  |  |  |  |  |   67|      0|				 ((0xd8 <= (c)) && ((c) <= 0xf6)) || \
  |  |  |  |  |  |  |  |  ------------------
  |  |  |  |  |  |  |  |  |  Branch (67:7): [True: 0, False: 0]
  |  |  |  |  |  |  |  |  |  Branch (67:24): [True: 0, False: 0]
  |  |  |  |  |  |  |  |  ------------------
  |  |  |  |  |  |  |  |   68|      0|				  (0xf8 <= (c)))
  |  |  |  |  |  |  |  |  ------------------
  |  |  |  |  |  |  |  |  |  Branch (68:7): [True: 0, False: 0]
  |  |  |  |  |  |  |  |  ------------------
  |  |  |  |  |  |  ------------------
  |  |  |  |  |  |   78|      0|				 xmlCharInRange((c), &xmlIsBaseCharGroup))
  |  |  |  |  ------------------
  |  |  ------------------
  |  |               #define IS_LETTER(c) (IS_BASECHAR(c) || IS_IDEOGRAPHIC(c))
  |  |  ------------------
  |  |  |  |  229|      0|#define IS_IDEOGRAPHIC(c) xmlIsIdeographicQ(c)
  |  |  |  |  ------------------
  |  |  |  |  |  |  184|      0|#define xmlIsIdeographicQ(c)	(((c) < 0x100) ? \
  |  |  |  |  |  |  ------------------
  |  |  |  |  |  |  |  Branch (184:30): [True: 0, False: 0]
  |  |  |  |  |  |  |  Branch (184:31): [True: 0, False: 0]
  |  |  |  |  |  |  ------------------
  |  |  |  |  |  |  185|      0|				 0 :\
  |  |  |  |  |  |  186|      0|				(((0x4e00 <= (c)) && ((c) <= 0x9fa5)) || \
  |  |  |  |  |  |  ------------------
  |  |  |  |  |  |  |  Branch (186:7): [True: 0, False: 0]
  |  |  |  |  |  |  |  Branch (186:26): [True: 0, False: 0]
  |  |  |  |  |  |  ------------------
  |  |  |  |  |  |  187|      0|				 ((c) == 0x3007) || \
  |  |  |  |  |  |  ------------------
  |  |  |  |  |  |  |  Branch (187:6): [True: 0, False: 0]
  |  |  |  |  |  |  ------------------
  |  |  |  |  |  |  188|      0|				 ((0x3021 <= (c)) && ((c) <= 0x3029))))
  |  |  |  |  |  |  ------------------
  |  |  |  |  |  |  |  Branch (188:7): [True: 0, False: 0]
  |  |  |  |  |  |  |  Branch (188:26): [True: 0, False: 0]
  |  |  |  |  |  |  ------------------
  |  |  |  |  ------------------
  |  |  ------------------
  ------------------
                      if ((IS_LETTER(c)) || (IS_DIGIT(c)) ||
  ------------------
  |  |  171|      0|#define IS_DIGIT(c) xmlIsDigitQ(c)
  |  |  ------------------
  |  |  |  |  152|      0|#define xmlIsDigitQ(c)		(((c) < 0x100) ? \
  |  |  |  |  ------------------
  |  |  |  |  |  Branch (152:26): [True: 0, False: 0]
  |  |  |  |  ------------------
  |  |  |  |  153|      0|				 xmlIsDigit_ch((c)) : \
  |  |  |  |  ------------------
  |  |  |  |  |  |  144|      0|#define xmlIsDigit_ch(c)	(((0x30 <= (c)) && ((c) <= 0x39)))
  |  |  |  |  |  |  ------------------
  |  |  |  |  |  |  |  Branch (144:28): [True: 0, False: 0]
  |  |  |  |  |  |  |  Branch (144:45): [True: 0, False: 0]
  |  |  |  |  |  |  ------------------
  |  |  |  |  ------------------
  |  |  |  |  154|      0|				 xmlCharInRange((c), &xmlIsDigitGroup))
  |  |  ------------------
  ------------------
  |  Branch (3385:31): [True: 0, False: 0]
  ------------------
 3386|      0|            (c == '.') || (c == '-') ||
  ------------------
  |  Branch (3386:13): [True: 0, False: 0]
  |  Branch (3386:27): [True: 0, False: 0]
  ------------------
 3387|      0|	    (c == '_') || (c == ':') ||
  ------------------
  |  Branch (3387:6): [True: 0, False: 0]
  |  Branch (3387:20): [True: 0, False: 0]
  ------------------
 3388|      0|	    (IS_COMBINING(c)) ||
  ------------------
  |  |  189|      0|#define IS_COMBINING(c) xmlIsCombiningQ(c)
  |  |  ------------------
  |  |  |  |  132|      0|#define xmlIsCombiningQ(c)	(((c) < 0x100) ? \
  |  |  |  |  ------------------
  |  |  |  |  |  Branch (132:29): [True: 0, False: 0]
  |  |  |  |  ------------------
  |  |  |  |  133|      0|				 0 : \
  |  |  |  |  134|      0|				 xmlCharInRange((c), &xmlIsCombiningGroup))
  |  |  ------------------
  ------------------
  |  Branch (3388:6): [True: 0, False: 0]
  ------------------
 3389|      0|	    (IS_EXTENDER(c)))
  ------------------
  |  |  210|      0|#define IS_EXTENDER(c) xmlIsExtenderQ(c)
  |  |  ------------------
  |  |  |  |  172|      0|#define xmlIsExtenderQ(c)	(((c) < 0x100) ? \
  |  |  |  |  ------------------
  |  |  |  |  |  Branch (172:28): [True: 0, False: 0]
  |  |  |  |  ------------------
  |  |  |  |  173|      0|				 xmlIsExtender_ch((c)) : \
  |  |  |  |  ------------------
  |  |  |  |  |  |  164|      0|#define xmlIsExtender_ch(c)	(((c) == 0xb7))
  |  |  |  |  ------------------
  |  |  |  |  174|      0|				 xmlCharInRange((c), &xmlIsExtenderGroup))
  |  |  ------------------
  ------------------
  |  Branch (3389:6): [True: 0, False: 0]
  ------------------
 3390|      0|	    return(1);
 3391|      0|    }
 3392|     23|    return(0);
 3393|    280|}
parser.c:xmlFatalErrMsg:
  279|    177|{
  280|    177|    if ((ctxt != NULL) && (ctxt->disableSAX != 0) &&
  ------------------
  |  Branch (280:9): [True: 177, False: 0]
  |  Branch (280:27): [True: 83, False: 94]
  ------------------
  281|    177|        (ctxt->instate == XML_PARSER_EOF))
  ------------------
  |  Branch (281:9): [True: 0, False: 83]
  ------------------
  282|      0|	return;
  283|    177|    if (ctxt != NULL)
  ------------------
  |  Branch (283:9): [True: 177, False: 0]
  ------------------
  284|    177|	ctxt->errNo = error;
  285|    177|    __xmlRaiseError(NULL, NULL, NULL, ctxt, NULL, XML_FROM_PARSER, error,
  286|    177|                    XML_ERR_FATAL, NULL, 0, NULL, NULL, NULL, 0, 0, "%s", msg);
  287|    177|    if (ctxt != NULL) {
  ------------------
  |  Branch (287:9): [True: 177, False: 0]
  ------------------
  288|    177|	ctxt->wellFormed = 0;
  289|    177|	if (ctxt->recovery == 0)
  ------------------
  |  Branch (289:6): [True: 175, False: 2]
  ------------------
  290|    175|	    ctxt->disableSAX = 1;
  291|    177|    }
  292|    177|}
parser.c:xmlIsNameStartChar:
 3326|     79|xmlIsNameStartChar(xmlParserCtxtPtr ctxt, int c) {
 3327|     79|    if ((ctxt->options & XML_PARSE_OLD10) == 0) {
  ------------------
  |  Branch (3327:9): [True: 79, False: 0]
  ------------------
 3328|       |        /*
 3329|       |	 * Use the new checks of production [4] [4a] amd [5] of the
 3330|       |	 * Update 5 of XML-1.0
 3331|       |	 */
 3332|     79|	if ((c != ' ') && (c != '>') && (c != '/') && /* accelerators */
  ------------------
  |  Branch (3332:6): [True: 79, False: 0]
  |  Branch (3332:20): [True: 79, False: 0]
  |  Branch (3332:34): [True: 79, False: 0]
  ------------------
 3333|     79|	    (((c >= 'a') && (c <= 'z')) ||
  ------------------
  |  Branch (3333:8): [True: 22, False: 57]
  |  Branch (3333:22): [True: 17, False: 5]
  ------------------
 3334|     79|	     ((c >= 'A') && (c <= 'Z')) ||
  ------------------
  |  Branch (3334:8): [True: 5, False: 57]
  |  Branch (3334:22): [True: 0, False: 5]
  ------------------
 3335|     79|	     (c == '_') || (c == ':') ||
  ------------------
  |  Branch (3335:7): [True: 0, False: 62]
  |  Branch (3335:21): [True: 0, False: 62]
  ------------------
 3336|     79|	     ((c >= 0xC0) && (c <= 0xD6)) ||
  ------------------
  |  Branch (3336:8): [True: 2, False: 60]
  |  Branch (3336:23): [True: 0, False: 2]
  ------------------
 3337|     79|	     ((c >= 0xD8) && (c <= 0xF6)) ||
  ------------------
  |  Branch (3337:8): [True: 2, False: 60]
  |  Branch (3337:23): [True: 0, False: 2]
  ------------------
 3338|     79|	     ((c >= 0xF8) && (c <= 0x2FF)) ||
  ------------------
  |  Branch (3338:8): [True: 2, False: 60]
  |  Branch (3338:23): [True: 0, False: 2]
  ------------------
 3339|     79|	     ((c >= 0x370) && (c <= 0x37D)) ||
  ------------------
  |  Branch (3339:8): [True: 2, False: 60]
  |  Branch (3339:24): [True: 0, False: 2]
  ------------------
 3340|     79|	     ((c >= 0x37F) && (c <= 0x1FFF)) ||
  ------------------
  |  Branch (3340:8): [True: 2, False: 60]
  |  Branch (3340:24): [True: 0, False: 2]
  ------------------
 3341|     79|	     ((c >= 0x200C) && (c <= 0x200D)) ||
  ------------------
  |  Branch (3341:8): [True: 2, False: 60]
  |  Branch (3341:25): [True: 0, False: 2]
  ------------------
 3342|     79|	     ((c >= 0x2070) && (c <= 0x218F)) ||
  ------------------
  |  Branch (3342:8): [True: 2, False: 60]
  |  Branch (3342:25): [True: 0, False: 2]
  ------------------
 3343|     79|	     ((c >= 0x2C00) && (c <= 0x2FEF)) ||
  ------------------
  |  Branch (3343:8): [True: 2, False: 60]
  |  Branch (3343:25): [True: 0, False: 2]
  ------------------
 3344|     79|	     ((c >= 0x3001) && (c <= 0xD7FF)) ||
  ------------------
  |  Branch (3344:8): [True: 2, False: 60]
  |  Branch (3344:25): [True: 0, False: 2]
  ------------------
 3345|     79|	     ((c >= 0xF900) && (c <= 0xFDCF)) ||
  ------------------
  |  Branch (3345:8): [True: 2, False: 60]
  |  Branch (3345:25): [True: 0, False: 2]
  ------------------
 3346|     79|	     ((c >= 0xFDF0) && (c <= 0xFFFD)) ||
  ------------------
  |  Branch (3346:8): [True: 2, False: 60]
  |  Branch (3346:25): [True: 2, False: 0]
  ------------------
 3347|     79|	     ((c >= 0x10000) && (c <= 0xEFFFF))))
  ------------------
  |  Branch (3347:8): [True: 0, False: 60]
  |  Branch (3347:26): [True: 0, False: 0]
  ------------------
 3348|     19|	    return(1);
 3349|     79|    } else {
 3350|      0|        if (IS_LETTER(c) || (c == '_') || (c == ':'))
  ------------------
  |  |  240|      0|#define IS_LETTER(c) (IS_BASECHAR(c) || IS_IDEOGRAPHIC(c))
  |  |  ------------------
  |  |  |  |  161|      0|#define IS_BASECHAR(c) xmlIsBaseCharQ(c)
  |  |  |  |  ------------------
  |  |  |  |  |  |   76|      0|#define xmlIsBaseCharQ(c)	(((c) < 0x100) ? \
  |  |  |  |  |  |  ------------------
  |  |  |  |  |  |  |  Branch (76:27): [True: 0, False: 0]
  |  |  |  |  |  |  |  Branch (76:28): [True: 0, False: 0]
  |  |  |  |  |  |  ------------------
  |  |  |  |  |  |   77|      0|				 xmlIsBaseChar_ch((c)) : \
  |  |  |  |  |  |  ------------------
  |  |  |  |  |  |  |  |   64|      0|#define xmlIsBaseChar_ch(c)	(((0x41 <= (c)) && ((c) <= 0x5a)) || \
  |  |  |  |  |  |  |  |  ------------------
  |  |  |  |  |  |  |  |  |  Branch (64:31): [True: 0, False: 0]
  |  |  |  |  |  |  |  |  |  Branch (64:48): [True: 0, False: 0]
  |  |  |  |  |  |  |  |  ------------------
  |  |  |  |  |  |  |  |   65|      0|				 ((0x61 <= (c)) && ((c) <= 0x7a)) || \
  |  |  |  |  |  |  |  |  ------------------
  |  |  |  |  |  |  |  |  |  Branch (65:7): [True: 0, False: 0]
  |  |  |  |  |  |  |  |  |  Branch (65:24): [True: 0, False: 0]
  |  |  |  |  |  |  |  |  ------------------
  |  |  |  |  |  |  |  |   66|      0|				 ((0xc0 <= (c)) && ((c) <= 0xd6)) || \
  |  |  |  |  |  |  |  |  ------------------
  |  |  |  |  |  |  |  |  |  Branch (66:7): [True: 0, False: 0]
  |  |  |  |  |  |  |  |  |  Branch (66:24): [True: 0, False: 0]
  |  |  |  |  |  |  |  |  ------------------
  |  |  |  |  |  |  |  |   67|      0|				 ((0xd8 <= (c)) && ((c) <= 0xf6)) || \
  |  |  |  |  |  |  |  |  ------------------
  |  |  |  |  |  |  |  |  |  Branch (67:7): [True: 0, False: 0]
  |  |  |  |  |  |  |  |  |  Branch (67:24): [True: 0, False: 0]
  |  |  |  |  |  |  |  |  ------------------
  |  |  |  |  |  |  |  |   68|      0|				  (0xf8 <= (c)))
  |  |  |  |  |  |  |  |  ------------------
  |  |  |  |  |  |  |  |  |  Branch (68:7): [True: 0, False: 0]
  |  |  |  |  |  |  |  |  ------------------
  |  |  |  |  |  |  ------------------
  |  |  |  |  |  |   78|      0|				 xmlCharInRange((c), &xmlIsBaseCharGroup))
  |  |  |  |  ------------------
  |  |  ------------------
  |  |               #define IS_LETTER(c) (IS_BASECHAR(c) || IS_IDEOGRAPHIC(c))
  |  |  ------------------
  |  |  |  |  229|      0|#define IS_IDEOGRAPHIC(c) xmlIsIdeographicQ(c)
  |  |  |  |  ------------------
  |  |  |  |  |  |  184|      0|#define xmlIsIdeographicQ(c)	(((c) < 0x100) ? \
  |  |  |  |  |  |  ------------------
  |  |  |  |  |  |  |  Branch (184:30): [True: 0, False: 0]
  |  |  |  |  |  |  |  Branch (184:31): [True: 0, False: 0]
  |  |  |  |  |  |  ------------------
  |  |  |  |  |  |  185|      0|				 0 :\
  |  |  |  |  |  |  186|      0|				(((0x4e00 <= (c)) && ((c) <= 0x9fa5)) || \
  |  |  |  |  |  |  ------------------
  |  |  |  |  |  |  |  Branch (186:7): [True: 0, False: 0]
  |  |  |  |  |  |  |  Branch (186:26): [True: 0, False: 0]
  |  |  |  |  |  |  ------------------
  |  |  |  |  |  |  187|      0|				 ((c) == 0x3007) || \
  |  |  |  |  |  |  ------------------
  |  |  |  |  |  |  |  Branch (187:6): [True: 0, False: 0]
  |  |  |  |  |  |  ------------------
  |  |  |  |  |  |  188|      0|				 ((0x3021 <= (c)) && ((c) <= 0x3029))))
  |  |  |  |  |  |  ------------------
  |  |  |  |  |  |  |  Branch (188:7): [True: 0, False: 0]
  |  |  |  |  |  |  |  Branch (188:26): [True: 0, False: 0]
  |  |  |  |  |  |  ------------------
  |  |  |  |  ------------------
  |  |  ------------------
  ------------------
  |  Branch (3350:29): [True: 0, False: 0]
  |  Branch (3350:43): [True: 0, False: 0]
  ------------------
 3351|      0|	    return(1);
 3352|      0|    }
 3353|     60|    return(0);
 3354|     79|}
parser.c:xmlParseCharDataInternal:
 4557|  3.14k|xmlParseCharDataInternal(xmlParserCtxtPtr ctxt, int partial) {
 4558|  3.14k|    const xmlChar *in;
 4559|  3.14k|    int nbchar = 0;
 4560|  3.14k|    int line = ctxt->input->line;
 4561|  3.14k|    int col = ctxt->input->col;
 4562|  3.14k|    int ccol;
 4563|       |
 4564|  3.14k|    GROW;
  ------------------
  |  | 2270|  3.14k|#define GROW if (ctxt->input->end - ctxt->input->cur < INPUT_CHUNK)	\
  |  |  ------------------
  |  |  |  |   97|  3.14k|#define INPUT_CHUNK	250
  |  |  ------------------
  |  |  |  Branch (2270:18): [True: 2.15k, False: 987]
  |  |  ------------------
  |  | 2271|  3.14k|	xmlParserGrow(ctxt);
  ------------------
 4565|       |    /*
 4566|       |     * Accelerated common case where input don't need to be
 4567|       |     * modified before passing it to the handler.
 4568|       |     */
 4569|  3.14k|    in = ctxt->input->cur;
 4570|  3.14k|    do {
 4571|  5.22k|get_more_space:
 4572|  15.5k|        while (*in == 0x20) { in++; ctxt->input->col++; }
  ------------------
  |  Branch (4572:16): [True: 10.3k, False: 5.22k]
  ------------------
 4573|  5.22k|        if (*in == 0xA) {
  ------------------
  |  Branch (4573:13): [True: 2.08k, False: 3.14k]
  ------------------
 4574|  2.08k|            do {
 4575|  2.08k|                ctxt->input->line++; ctxt->input->col = 1;
 4576|  2.08k|                in++;
 4577|  2.08k|            } while (*in == 0xA);
  ------------------
  |  Branch (4577:22): [True: 0, False: 2.08k]
  ------------------
 4578|  2.08k|            goto get_more_space;
 4579|  2.08k|        }
 4580|  3.14k|        if (*in == '<') {
  ------------------
  |  Branch (4580:13): [True: 2.03k, False: 1.10k]
  ------------------
 4581|  2.03k|            nbchar = in - ctxt->input->cur;
 4582|  2.03k|            if (nbchar > 0) {
  ------------------
  |  Branch (4582:17): [True: 2.03k, False: 0]
  ------------------
 4583|  2.03k|                const xmlChar *tmp = ctxt->input->cur;
 4584|  2.03k|                ctxt->input->cur = in;
 4585|       |
 4586|  2.03k|                if ((ctxt->sax != NULL) &&
  ------------------
  |  Branch (4586:21): [True: 2.03k, False: 0]
  ------------------
 4587|  2.03k|                    (ctxt->disableSAX == 0) &&
  ------------------
  |  Branch (4587:21): [True: 1.69k, False: 345]
  ------------------
 4588|  2.03k|                    (ctxt->sax->ignorableWhitespace !=
  ------------------
  |  Branch (4588:21): [True: 14, False: 1.67k]
  ------------------
 4589|  1.69k|                     ctxt->sax->characters)) {
 4590|     14|                    if (areBlanks(ctxt, tmp, nbchar, 1)) {
  ------------------
  |  Branch (4590:25): [True: 8, False: 6]
  ------------------
 4591|      8|                        if (ctxt->sax->ignorableWhitespace != NULL)
  ------------------
  |  Branch (4591:29): [True: 8, False: 0]
  ------------------
 4592|      8|                            ctxt->sax->ignorableWhitespace(ctxt->userData,
 4593|      8|                                                   tmp, nbchar);
 4594|      8|                    } else {
 4595|      6|                        if (ctxt->sax->characters != NULL)
  ------------------
  |  Branch (4595:29): [True: 6, False: 0]
  ------------------
 4596|      6|                            ctxt->sax->characters(ctxt->userData,
 4597|      6|                                                  tmp, nbchar);
 4598|      6|                        if (*ctxt->space == -1)
  ------------------
  |  Branch (4598:29): [True: 0, False: 6]
  ------------------
 4599|      0|                            *ctxt->space = -2;
 4600|      6|                    }
 4601|  2.02k|                } else if ((ctxt->sax != NULL) &&
  ------------------
  |  Branch (4601:28): [True: 2.02k, False: 0]
  ------------------
 4602|  2.02k|                           (ctxt->disableSAX == 0) &&
  ------------------
  |  Branch (4602:28): [True: 1.67k, False: 345]
  ------------------
 4603|  2.02k|                           (ctxt->sax->characters != NULL)) {
  ------------------
  |  Branch (4603:28): [True: 1.67k, False: 0]
  ------------------
 4604|  1.67k|                    ctxt->sax->characters(ctxt->userData,
 4605|  1.67k|                                          tmp, nbchar);
 4606|  1.67k|                }
 4607|  2.03k|            }
 4608|  2.03k|            return;
 4609|  2.03k|        }
 4610|       |
 4611|  1.18k|get_more:
 4612|  1.18k|        ccol = ctxt->input->col;
 4613|  4.61k|        while (test_char_data[*in]) {
  ------------------
  |  Branch (4613:16): [True: 3.43k, False: 1.18k]
  ------------------
 4614|  3.43k|            in++;
 4615|  3.43k|            ccol++;
 4616|  3.43k|        }
 4617|  1.18k|        ctxt->input->col = ccol;
 4618|  1.18k|        if (*in == 0xA) {
  ------------------
  |  Branch (4618:13): [True: 79, False: 1.10k]
  ------------------
 4619|     79|            do {
 4620|     79|                ctxt->input->line++; ctxt->input->col = 1;
 4621|     79|                in++;
 4622|     79|            } while (*in == 0xA);
  ------------------
  |  Branch (4622:22): [True: 0, False: 79]
  ------------------
 4623|     79|            goto get_more;
 4624|     79|        }
 4625|  1.10k|        if (*in == ']') {
  ------------------
  |  Branch (4625:13): [True: 0, False: 1.10k]
  ------------------
 4626|      0|            if ((in[1] == ']') && (in[2] == '>')) {
  ------------------
  |  Branch (4626:17): [True: 0, False: 0]
  |  Branch (4626:35): [True: 0, False: 0]
  ------------------
 4627|      0|                xmlFatalErr(ctxt, XML_ERR_MISPLACED_CDATA_END, NULL);
 4628|      0|                if (ctxt->instate != XML_PARSER_EOF)
  ------------------
  |  Branch (4628:21): [True: 0, False: 0]
  ------------------
 4629|      0|                    ctxt->input->cur = in + 1;
 4630|      0|                return;
 4631|      0|            }
 4632|      0|            in++;
 4633|      0|            ctxt->input->col++;
 4634|      0|            goto get_more;
 4635|      0|        }
 4636|  1.10k|        nbchar = in - ctxt->input->cur;
 4637|  1.10k|        if (nbchar > 0) {
  ------------------
  |  Branch (4637:13): [True: 296, False: 807]
  ------------------
 4638|    296|            if ((ctxt->sax != NULL) &&
  ------------------
  |  Branch (4638:17): [True: 296, False: 0]
  ------------------
 4639|    296|                (ctxt->disableSAX == 0) &&
  ------------------
  |  Branch (4639:17): [True: 182, False: 114]
  ------------------
 4640|    296|                (ctxt->sax->ignorableWhitespace !=
  ------------------
  |  Branch (4640:17): [True: 4, False: 178]
  ------------------
 4641|    182|                 ctxt->sax->characters) &&
 4642|    296|                (IS_BLANK_CH(*ctxt->input->cur))) {
  ------------------
  |  |  151|      4|#define IS_BLANK_CH(c)  xmlIsBlank_ch(c)
  |  |  ------------------
  |  |  |  |   88|      4|#define xmlIsBlank_ch(c)	(((c) == 0x20) || \
  |  |  |  |  ------------------
  |  |  |  |  |  Branch (88:27): [True: 0, False: 4]
  |  |  |  |  ------------------
  |  |  |  |   89|      4|				 ((0x9 <= (c)) && ((c) <= 0xa)) || \
  |  |  |  |  ------------------
  |  |  |  |  |  Branch (89:7): [True: 4, False: 0]
  |  |  |  |  |  Branch (89:23): [True: 2, False: 2]
  |  |  |  |  ------------------
  |  |  |  |   90|      4|				 ((c) == 0xd))
  |  |  |  |  ------------------
  |  |  |  |  |  Branch (90:6): [True: 0, False: 2]
  |  |  |  |  ------------------
  |  |  ------------------
  ------------------
 4643|      2|                const xmlChar *tmp = ctxt->input->cur;
 4644|      2|                ctxt->input->cur = in;
 4645|       |
 4646|      2|                if (areBlanks(ctxt, tmp, nbchar, 0)) {
  ------------------
  |  Branch (4646:21): [True: 0, False: 2]
  ------------------
 4647|      0|                    if (ctxt->sax->ignorableWhitespace != NULL)
  ------------------
  |  Branch (4647:25): [True: 0, False: 0]
  ------------------
 4648|      0|                        ctxt->sax->ignorableWhitespace(ctxt->userData,
 4649|      0|                                                       tmp, nbchar);
 4650|      2|                } else {
 4651|      2|                    if (ctxt->sax->characters != NULL)
  ------------------
  |  Branch (4651:25): [True: 2, False: 0]
  ------------------
 4652|      2|                        ctxt->sax->characters(ctxt->userData,
 4653|      2|                                              tmp, nbchar);
 4654|      2|                    if (*ctxt->space == -1)
  ------------------
  |  Branch (4654:25): [True: 2, False: 0]
  ------------------
 4655|      2|                        *ctxt->space = -2;
 4656|      2|                }
 4657|      2|                line = ctxt->input->line;
 4658|      2|                col = ctxt->input->col;
 4659|    294|            } else if ((ctxt->sax != NULL) &&
  ------------------
  |  Branch (4659:24): [True: 294, False: 0]
  ------------------
 4660|    294|                       (ctxt->disableSAX == 0)) {
  ------------------
  |  Branch (4660:24): [True: 180, False: 114]
  ------------------
 4661|    180|                if (ctxt->sax->characters != NULL)
  ------------------
  |  Branch (4661:21): [True: 180, False: 0]
  ------------------
 4662|    180|                    ctxt->sax->characters(ctxt->userData,
 4663|    180|                                          ctxt->input->cur, nbchar);
 4664|    180|                line = ctxt->input->line;
 4665|    180|                col = ctxt->input->col;
 4666|    180|            }
 4667|    296|            if (ctxt->instate == XML_PARSER_EOF)
  ------------------
  |  Branch (4667:17): [True: 0, False: 296]
  ------------------
 4668|      0|                return;
 4669|    296|        }
 4670|  1.10k|        ctxt->input->cur = in;
 4671|  1.10k|        if (*in == 0xD) {
  ------------------
  |  Branch (4671:13): [True: 0, False: 1.10k]
  ------------------
 4672|      0|            in++;
 4673|      0|            if (*in == 0xA) {
  ------------------
  |  Branch (4673:17): [True: 0, False: 0]
  ------------------
 4674|      0|                ctxt->input->cur = in;
 4675|      0|                in++;
 4676|      0|                ctxt->input->line++; ctxt->input->col = 1;
 4677|      0|                continue; /* while */
 4678|      0|            }
 4679|      0|            in--;
 4680|      0|        }
 4681|  1.10k|        if (*in == '<') {
  ------------------
  |  Branch (4681:13): [True: 230, False: 873]
  ------------------
 4682|    230|            return;
 4683|    230|        }
 4684|    873|        if (*in == '&') {
  ------------------
  |  Branch (4684:13): [True: 2, False: 871]
  ------------------
 4685|      2|            return;
 4686|      2|        }
 4687|    871|        SHRINK;
  ------------------
  |  | 2265|    871|    if (((ctxt->progressive == 0) || (ctxt->inputNr > 1)) && \
  |  |  ------------------
  |  |  |  Branch (2265:10): [True: 795, False: 76]
  |  |  |  Branch (2265:38): [True: 0, False: 76]
  |  |  ------------------
  |  | 2266|    871|        (ctxt->input->cur - ctxt->input->base > 2 * INPUT_CHUNK) && \
  |  |  ------------------
  |  |  |  |   97|    795|#define INPUT_CHUNK	250
  |  |  ------------------
  |  |  |  Branch (2266:9): [True: 0, False: 795]
  |  |  ------------------
  |  | 2267|    871|	(ctxt->input->end - ctxt->input->cur < 2 * INPUT_CHUNK)) \
  |  |  ------------------
  |  |  |  |   97|      0|#define INPUT_CHUNK	250
  |  |  ------------------
  |  |  |  Branch (2267:2): [True: 0, False: 0]
  |  |  ------------------
  |  | 2268|    871|	xmlParserShrink(ctxt);
  ------------------
 4688|    871|        GROW;
  ------------------
  |  | 2270|    871|#define GROW if (ctxt->input->end - ctxt->input->cur < INPUT_CHUNK)	\
  |  |  ------------------
  |  |  |  |   97|    871|#define INPUT_CHUNK	250
  |  |  ------------------
  |  |  |  Branch (2270:18): [True: 847, False: 24]
  |  |  ------------------
  |  | 2271|    871|	xmlParserGrow(ctxt);
  ------------------
 4689|    871|        if (ctxt->instate == XML_PARSER_EOF)
  ------------------
  |  Branch (4689:13): [True: 0, False: 871]
  ------------------
 4690|      0|            return;
 4691|    871|        in = ctxt->input->cur;
 4692|    871|    } while (((*in >= 0x20) && (*in <= 0x7F)) ||
  ------------------
  |  Branch (4692:15): [True: 9, False: 862]
  |  Branch (4692:32): [True: 0, False: 9]
  ------------------
 4693|    871|             (*in == 0x09) || (*in == 0x0a));
  ------------------
  |  Branch (4693:14): [True: 0, False: 871]
  |  Branch (4693:31): [True: 0, False: 871]
  ------------------
 4694|    871|    ctxt->input->line = line;
 4695|    871|    ctxt->input->col = col;
 4696|    871|    xmlParseCharDataComplex(ctxt, partial);
 4697|    871|}
parser.c:areBlanks:
 3071|     16|                     int blank_chars) {
 3072|     16|    int i, ret;
 3073|     16|    xmlNodePtr lastChild;
 3074|       |
 3075|       |    /*
 3076|       |     * Don't spend time trying to differentiate them, the same callback is
 3077|       |     * used !
 3078|       |     */
 3079|     16|    if (ctxt->sax->ignorableWhitespace == ctxt->sax->characters)
  ------------------
  |  Branch (3079:9): [True: 0, False: 16]
  ------------------
 3080|      0|	return(0);
 3081|       |
 3082|       |    /*
 3083|       |     * Check for xml:space value.
 3084|       |     */
 3085|     16|    if ((ctxt->space == NULL) || (*(ctxt->space) == 1) ||
  ------------------
  |  Branch (3085:9): [True: 0, False: 16]
  |  Branch (3085:34): [True: 0, False: 16]
  ------------------
 3086|     16|        (*(ctxt->space) == -2))
  ------------------
  |  Branch (3086:9): [True: 6, False: 10]
  ------------------
 3087|      6|	return(0);
 3088|       |
 3089|       |    /*
 3090|       |     * Check that the string is made of blanks
 3091|       |     */
 3092|     10|    if (blank_chars == 0) {
  ------------------
  |  Branch (3092:9): [True: 2, False: 8]
  ------------------
 3093|      6|	for (i = 0;i < len;i++)
  ------------------
  |  Branch (3093:13): [True: 4, False: 2]
  ------------------
 3094|      4|	    if (!(IS_BLANK_CH(str[i]))) return(0);
  ------------------
  |  |  151|      4|#define IS_BLANK_CH(c)  xmlIsBlank_ch(c)
  |  |  ------------------
  |  |  |  |   88|      4|#define xmlIsBlank_ch(c)	(((c) == 0x20) || \
  |  |  |  |  ------------------
  |  |  |  |  |  Branch (88:27): [True: 2, False: 2]
  |  |  |  |  ------------------
  |  |  |  |   89|      4|				 ((0x9 <= (c)) && ((c) <= 0xa)) || \
  |  |  |  |  ------------------
  |  |  |  |  |  Branch (89:7): [True: 2, False: 0]
  |  |  |  |  |  Branch (89:23): [True: 2, False: 0]
  |  |  |  |  ------------------
  |  |  |  |   90|      4|				 ((c) == 0xd))
  |  |  |  |  ------------------
  |  |  |  |  |  Branch (90:6): [True: 0, False: 0]
  |  |  |  |  ------------------
  |  |  ------------------
  ------------------
 3095|      2|    }
 3096|       |
 3097|       |    /*
 3098|       |     * Look if the element is mixed content in the DTD if available
 3099|       |     */
 3100|     10|    if (ctxt->node == NULL) return(0);
  ------------------
  |  Branch (3100:9): [True: 0, False: 10]
  ------------------
 3101|     10|    if (ctxt->myDoc != NULL) {
  ------------------
  |  Branch (3101:9): [True: 10, False: 0]
  ------------------
 3102|     10|	ret = xmlIsMixedElement(ctxt->myDoc, ctxt->node->name);
 3103|     10|        if (ret == 0) return(1);
  ------------------
  |  Branch (3103:13): [True: 8, False: 2]
  ------------------
 3104|      2|        if (ret == 1) return(0);
  ------------------
  |  Branch (3104:13): [True: 0, False: 2]
  ------------------
 3105|      2|    }
 3106|       |
 3107|       |    /*
 3108|       |     * Otherwise, heuristic :-\
 3109|       |     */
 3110|      2|    if ((RAW != '<') && (RAW != 0xD)) return(0);
  ------------------
  |  | 2221|      2|#define RAW (*ctxt->input->cur)
  ------------------
                  if ((RAW != '<') && (RAW != 0xD)) return(0);
  ------------------
  |  | 2221|      2|#define RAW (*ctxt->input->cur)
  ------------------
  |  Branch (3110:9): [True: 2, False: 0]
  |  Branch (3110:25): [True: 2, False: 0]
  ------------------
 3111|      0|    if ((ctxt->node->children == NULL) &&
  ------------------
  |  Branch (3111:9): [True: 0, False: 0]
  ------------------
 3112|      0|	(RAW == '<') && (NXT(1) == '/')) return(0);
  ------------------
  |  | 2221|      0|#define RAW (*ctxt->input->cur)
  ------------------
              	(RAW == '<') && (NXT(1) == '/')) return(0);
  ------------------
  |  | 2223|      0|#define NXT(val) ctxt->input->cur[(val)]
  ------------------
  |  Branch (3112:2): [True: 0, False: 0]
  |  Branch (3112:18): [True: 0, False: 0]
  ------------------
 3113|       |
 3114|      0|    lastChild = xmlGetLastChild(ctxt->node);
 3115|      0|    if (lastChild == NULL) {
  ------------------
  |  Branch (3115:9): [True: 0, False: 0]
  ------------------
 3116|      0|        if ((ctxt->node->type != XML_ELEMENT_NODE) &&
  ------------------
  |  Branch (3116:13): [True: 0, False: 0]
  ------------------
 3117|      0|            (ctxt->node->content != NULL)) return(0);
  ------------------
  |  Branch (3117:13): [True: 0, False: 0]
  ------------------
 3118|      0|    } else if (xmlNodeIsText(lastChild))
  ------------------
  |  Branch (3118:16): [True: 0, False: 0]
  ------------------
 3119|      0|        return(0);
 3120|      0|    else if ((ctxt->node->children != NULL) &&
  ------------------
  |  Branch (3120:14): [True: 0, False: 0]
  ------------------
 3121|      0|             (xmlNodeIsText(ctxt->node->children)))
  ------------------
  |  Branch (3121:14): [True: 0, False: 0]
  ------------------
 3122|      0|        return(0);
 3123|      0|    return(1);
 3124|      0|}
parser.c:xmlParseCharDataComplex:
 4711|    871|xmlParseCharDataComplex(xmlParserCtxtPtr ctxt, int partial) {
 4712|    871|    xmlChar buf[XML_PARSER_BIG_BUFFER_SIZE + 5];
 4713|    871|    int nbchar = 0;
 4714|    871|    int cur, l;
 4715|       |
 4716|    871|    cur = CUR_CHAR(l);
  ------------------
  |  | 2291|    871|#define CUR_CHAR(l) xmlCurrentChar(ctxt, &l)
  ------------------
 4717|  1.32k|    while ((cur != '<') && /* checked */
  ------------------
  |  Branch (4717:12): [True: 1.31k, False: 8]
  ------------------
 4718|  1.32k|           (cur != '&') &&
  ------------------
  |  Branch (4718:12): [True: 1.31k, False: 0]
  ------------------
 4719|  1.32k|	   (IS_CHAR(cur))) {
  ------------------
  |  |  125|  1.31k|#define IS_CHAR(c)   xmlIsCharQ(c)
  |  |  ------------------
  |  |  |  |  118|  1.31k|#define xmlIsCharQ(c)		(((c) < 0x100) ? \
  |  |  |  |  ------------------
  |  |  |  |  |  Branch (118:25): [True: 1.12k, False: 193]
  |  |  |  |  ------------------
  |  |  |  |  119|  1.31k|				 xmlIsChar_ch((c)) :\
  |  |  |  |  ------------------
  |  |  |  |  |  |  108|  1.12k|#define xmlIsChar_ch(c)		(((0x9 <= (c)) && ((c) <= 0xa)) || \
  |  |  |  |  |  |  ------------------
  |  |  |  |  |  |  |  Branch (108:28): [True: 405, False: 717]
  |  |  |  |  |  |  |  Branch (108:44): [True: 5, False: 400]
  |  |  |  |  |  |  ------------------
  |  |  |  |  |  |  109|  1.12k|				 ((c) == 0xd) || \
  |  |  |  |  |  |  ------------------
  |  |  |  |  |  |  |  Branch (109:6): [True: 0, False: 1.11k]
  |  |  |  |  |  |  ------------------
  |  |  |  |  |  |  110|  1.12k|				  (0x20 <= (c)))
  |  |  |  |  |  |  ------------------
  |  |  |  |  |  |  |  Branch (110:7): [True: 254, False: 863]
  |  |  |  |  |  |  ------------------
  |  |  |  |  ------------------
  |  |  |  |  120|  1.31k|				(((0x100 <= (c)) && ((c) <= 0xd7ff)) || \
  |  |  |  |  ------------------
  |  |  |  |  |  Branch (120:7): [True: 193, False: 0]
  |  |  |  |  |  Branch (120:25): [True: 0, False: 193]
  |  |  |  |  ------------------
  |  |  |  |  121|    193|				 ((0xe000 <= (c)) && ((c) <= 0xfffd)) || \
  |  |  |  |  ------------------
  |  |  |  |  |  Branch (121:7): [True: 193, False: 0]
  |  |  |  |  |  Branch (121:26): [True: 193, False: 0]
  |  |  |  |  ------------------
  |  |  |  |  122|    193|				 ((0x10000 <= (c)) && ((c) <= 0x10ffff))))
  |  |  |  |  ------------------
  |  |  |  |  |  Branch (122:7): [True: 0, False: 0]
  |  |  |  |  |  Branch (122:27): [True: 0, False: 0]
  |  |  |  |  ------------------
  |  |  ------------------
  ------------------
  |  Branch (4719:5): [True: 452, False: 863]
  ------------------
 4720|    452|	if ((cur == ']') && (NXT(1) == ']') && (NXT(2) == '>')) {
  ------------------
  |  | 2223|      0|#define NXT(val) ctxt->input->cur[(val)]
  ------------------
              	if ((cur == ']') && (NXT(1) == ']') && (NXT(2) == '>')) {
  ------------------
  |  | 2223|      0|#define NXT(val) ctxt->input->cur[(val)]
  ------------------
  |  Branch (4720:6): [True: 0, False: 452]
  |  Branch (4720:22): [True: 0, False: 0]
  |  Branch (4720:41): [True: 0, False: 0]
  ------------------
 4721|      0|	    xmlFatalErr(ctxt, XML_ERR_MISPLACED_CDATA_END, NULL);
 4722|      0|	}
 4723|    452|	COPY_BUF(buf, nbchar, cur);
  ------------------
  |  | 2295|    452|    if (v < 0x80) b[i++] = v;						\
  |  |  ------------------
  |  |  |  Branch (2295:9): [True: 259, False: 193]
  |  |  ------------------
  |  | 2296|    452|    else i += xmlCopyCharMultiByte(&b[i],v)
  ------------------
 4724|       |	/* move current position before possible calling of ctxt->sax->characters */
 4725|    452|	NEXTL(l);
  ------------------
  |  | 2284|    452|#define NEXTL(l) do {							\
  |  | 2285|    452|    if (*(ctxt->input->cur) == '\n') {					\
  |  |  ------------------
  |  |  |  Branch (2285:9): [True: 5, False: 447]
  |  |  ------------------
  |  | 2286|      5|	ctxt->input->line++; ctxt->input->col = 1;			\
  |  | 2287|    447|    } else ctxt->input->col++;						\
  |  | 2288|    452|    ctxt->input->cur += l;				\
  |  | 2289|    452|  } while (0)
  |  |  ------------------
  |  |  |  Branch (2289:12): [Folded - Ignored]
  |  |  ------------------
  ------------------
 4726|    452|	if (nbchar >= XML_PARSER_BIG_BUFFER_SIZE) {
  ------------------
  |  |  166|    452|#define XML_PARSER_BIG_BUFFER_SIZE 300
  ------------------
  |  Branch (4726:6): [True: 0, False: 452]
  ------------------
 4727|      0|	    buf[nbchar] = 0;
 4728|       |
 4729|       |	    /*
 4730|       |	     * OK the segment is to be consumed as chars.
 4731|       |	     */
 4732|      0|	    if ((ctxt->sax != NULL) && (!ctxt->disableSAX)) {
  ------------------
  |  Branch (4732:10): [True: 0, False: 0]
  |  Branch (4732:33): [True: 0, False: 0]
  ------------------
 4733|      0|		if (areBlanks(ctxt, buf, nbchar, 0)) {
  ------------------
  |  Branch (4733:7): [True: 0, False: 0]
  ------------------
 4734|      0|		    if (ctxt->sax->ignorableWhitespace != NULL)
  ------------------
  |  Branch (4734:11): [True: 0, False: 0]
  ------------------
 4735|      0|			ctxt->sax->ignorableWhitespace(ctxt->userData,
 4736|      0|			                               buf, nbchar);
 4737|      0|		} else {
 4738|      0|		    if (ctxt->sax->characters != NULL)
  ------------------
  |  Branch (4738:11): [True: 0, False: 0]
  ------------------
 4739|      0|			ctxt->sax->characters(ctxt->userData, buf, nbchar);
 4740|      0|		    if ((ctxt->sax->characters !=
  ------------------
  |  Branch (4740:11): [True: 0, False: 0]
  ------------------
 4741|      0|		         ctxt->sax->ignorableWhitespace) &&
 4742|      0|			(*ctxt->space == -1))
  ------------------
  |  Branch (4742:4): [True: 0, False: 0]
  ------------------
 4743|      0|			*ctxt->space = -2;
 4744|      0|		}
 4745|      0|	    }
 4746|      0|	    nbchar = 0;
 4747|       |            /* something really bad happened in the SAX callback */
 4748|      0|            if (ctxt->instate != XML_PARSER_CONTENT)
  ------------------
  |  Branch (4748:17): [True: 0, False: 0]
  ------------------
 4749|      0|                return;
 4750|      0|            SHRINK;
  ------------------
  |  | 2265|      0|    if (((ctxt->progressive == 0) || (ctxt->inputNr > 1)) && \
  |  |  ------------------
  |  |  |  Branch (2265:10): [True: 0, False: 0]
  |  |  |  Branch (2265:38): [True: 0, False: 0]
  |  |  ------------------
  |  | 2266|      0|        (ctxt->input->cur - ctxt->input->base > 2 * INPUT_CHUNK) && \
  |  |  ------------------
  |  |  |  |   97|      0|#define INPUT_CHUNK	250
  |  |  ------------------
  |  |  |  Branch (2266:9): [True: 0, False: 0]
  |  |  ------------------
  |  | 2267|      0|	(ctxt->input->end - ctxt->input->cur < 2 * INPUT_CHUNK)) \
  |  |  ------------------
  |  |  |  |   97|      0|#define INPUT_CHUNK	250
  |  |  ------------------
  |  |  |  Branch (2267:2): [True: 0, False: 0]
  |  |  ------------------
  |  | 2268|      0|	xmlParserShrink(ctxt);
  ------------------
 4751|      0|	}
 4752|    452|	cur = CUR_CHAR(l);
  ------------------
  |  | 2291|    452|#define CUR_CHAR(l) xmlCurrentChar(ctxt, &l)
  ------------------
 4753|    452|    }
 4754|    871|    if (ctxt->instate == XML_PARSER_EOF)
  ------------------
  |  Branch (4754:9): [True: 0, False: 871]
  ------------------
 4755|      0|        return;
 4756|    871|    if (nbchar != 0) {
  ------------------
  |  Branch (4756:9): [True: 9, False: 862]
  ------------------
 4757|      9|        buf[nbchar] = 0;
 4758|       |	/*
 4759|       |	 * OK the segment is to be consumed as chars.
 4760|       |	 */
 4761|      9|	if ((ctxt->sax != NULL) && (!ctxt->disableSAX)) {
  ------------------
  |  Branch (4761:6): [True: 9, False: 0]
  |  Branch (4761:29): [True: 0, False: 9]
  ------------------
 4762|      0|	    if (areBlanks(ctxt, buf, nbchar, 0)) {
  ------------------
  |  Branch (4762:10): [True: 0, False: 0]
  ------------------
 4763|      0|		if (ctxt->sax->ignorableWhitespace != NULL)
  ------------------
  |  Branch (4763:7): [True: 0, False: 0]
  ------------------
 4764|      0|		    ctxt->sax->ignorableWhitespace(ctxt->userData, buf, nbchar);
 4765|      0|	    } else {
 4766|      0|		if (ctxt->sax->characters != NULL)
  ------------------
  |  Branch (4766:7): [True: 0, False: 0]
  ------------------
 4767|      0|		    ctxt->sax->characters(ctxt->userData, buf, nbchar);
 4768|      0|		if ((ctxt->sax->characters != ctxt->sax->ignorableWhitespace) &&
  ------------------
  |  Branch (4768:7): [True: 0, False: 0]
  ------------------
 4769|      0|		    (*ctxt->space == -1))
  ------------------
  |  Branch (4769:7): [True: 0, False: 0]
  ------------------
 4770|      0|		    *ctxt->space = -2;
 4771|      0|	    }
 4772|      0|	}
 4773|      9|    }
 4774|       |    /*
 4775|       |     * cur == 0 can mean
 4776|       |     *
 4777|       |     * - XML_PARSER_EOF or memory error. This is checked above.
 4778|       |     * - An actual 0 character.
 4779|       |     * - End of buffer.
 4780|       |     * - An incomplete UTF-8 sequence. This is allowed if partial is set.
 4781|       |     */
 4782|    871|    if (ctxt->input->cur < ctxt->input->end) {
  ------------------
  |  Branch (4782:9): [True: 842, False: 29]
  ------------------
 4783|    842|        if ((cur == 0) && (CUR != 0)) {
  ------------------
  |  | 2222|    677|#define CUR (*ctxt->input->cur)
  ------------------
  |  Branch (4783:13): [True: 677, False: 165]
  |  Branch (4783:27): [True: 0, False: 677]
  ------------------
 4784|      0|            if (partial == 0) {
  ------------------
  |  Branch (4784:17): [True: 0, False: 0]
  ------------------
 4785|      0|                xmlFatalErrMsgInt(ctxt, XML_ERR_INVALID_CHAR,
 4786|      0|                        "Incomplete UTF-8 sequence starting with %02X\n", CUR);
  ------------------
  |  | 2222|      0|#define CUR (*ctxt->input->cur)
  ------------------
 4787|      0|                NEXTL(1);
  ------------------
  |  | 2284|      0|#define NEXTL(l) do {							\
  |  | 2285|      0|    if (*(ctxt->input->cur) == '\n') {					\
  |  |  ------------------
  |  |  |  Branch (2285:9): [True: 0, False: 0]
  |  |  ------------------
  |  | 2286|      0|	ctxt->input->line++; ctxt->input->col = 1;			\
  |  | 2287|      0|    } else ctxt->input->col++;						\
  |  | 2288|      0|    ctxt->input->cur += l;				\
  |  | 2289|      0|  } while (0)
  |  |  ------------------
  |  |  |  Branch (2289:12): [Folded - Ignored]
  |  |  ------------------
  ------------------
 4788|      0|            }
 4789|    842|        } else if ((cur != '<') && (cur != '&')) {
  ------------------
  |  Branch (4789:20): [True: 834, False: 8]
  |  Branch (4789:36): [True: 834, False: 0]
  ------------------
 4790|       |            /* Generate the error and skip the offending character */
 4791|    834|            xmlFatalErrMsgInt(ctxt, XML_ERR_INVALID_CHAR,
 4792|    834|                              "PCDATA invalid Char value %d\n", cur);
 4793|    834|            NEXTL(l);
  ------------------
  |  | 2284|    834|#define NEXTL(l) do {							\
  |  | 2285|    834|    if (*(ctxt->input->cur) == '\n') {					\
  |  |  ------------------
  |  |  |  Branch (2285:9): [True: 0, False: 834]
  |  |  ------------------
  |  | 2286|      0|	ctxt->input->line++; ctxt->input->col = 1;			\
  |  | 2287|    834|    } else ctxt->input->col++;						\
  |  | 2288|    834|    ctxt->input->cur += l;				\
  |  | 2289|    834|  } while (0)
  |  |  ------------------
  |  |  |  Branch (2289:12): [Folded - Ignored]
  |  |  ------------------
  ------------------
 4794|    834|        }
 4795|    842|    }
 4796|    871|}
parser.c:xmlParseCommentComplex:
 4901|     20|                       size_t len, size_t size) {
 4902|     20|    int q, ql;
 4903|     20|    int r, rl;
 4904|     20|    int cur, l;
 4905|     20|    size_t maxLength = (ctxt->options & XML_PARSE_HUGE) ?
  ------------------
  |  Branch (4905:24): [True: 0, False: 20]
  ------------------
 4906|      0|                       XML_MAX_HUGE_LENGTH :
  ------------------
  |  |   49|      0|#define XML_MAX_HUGE_LENGTH 1000000000
  ------------------
 4907|     20|                       XML_MAX_TEXT_LENGTH;
  ------------------
  |  |   42|     40|#define XML_MAX_TEXT_LENGTH 10000000
  ------------------
 4908|     20|    int inputid;
 4909|       |
 4910|     20|    inputid = ctxt->input->id;
 4911|       |
 4912|     20|    if (buf == NULL) {
  ------------------
  |  Branch (4912:9): [True: 0, False: 20]
  ------------------
 4913|      0|        len = 0;
 4914|      0|	size = XML_PARSER_BUFFER_SIZE;
  ------------------
  |  |  167|      0|#define XML_PARSER_BUFFER_SIZE 100
  ------------------
 4915|      0|	buf = (xmlChar *) xmlMallocAtomic(size);
 4916|      0|	if (buf == NULL) {
  ------------------
  |  Branch (4916:6): [True: 0, False: 0]
  ------------------
 4917|      0|	    xmlErrMemory(ctxt, NULL);
 4918|      0|	    return;
 4919|      0|	}
 4920|      0|    }
 4921|     20|    q = CUR_CHAR(ql);
  ------------------
  |  | 2291|     20|#define CUR_CHAR(l) xmlCurrentChar(ctxt, &l)
  ------------------
 4922|     20|    if (q == 0)
  ------------------
  |  Branch (4922:9): [True: 8, False: 12]
  ------------------
 4923|      8|        goto not_terminated;
 4924|     12|    if (!IS_CHAR(q)) {
  ------------------
  |  |  125|     12|#define IS_CHAR(c)   xmlIsCharQ(c)
  |  |  ------------------
  |  |  |  |  118|     12|#define xmlIsCharQ(c)		(((c) < 0x100) ? \
  |  |  |  |  ------------------
  |  |  |  |  |  Branch (118:25): [True: 8, False: 4]
  |  |  |  |  ------------------
  |  |  |  |  119|     12|				 xmlIsChar_ch((c)) :\
  |  |  |  |  ------------------
  |  |  |  |  |  |  108|      8|#define xmlIsChar_ch(c)		(((0x9 <= (c)) && ((c) <= 0xa)) || \
  |  |  |  |  |  |  ------------------
  |  |  |  |  |  |  |  Branch (108:28): [True: 4, False: 4]
  |  |  |  |  |  |  |  Branch (108:44): [True: 0, False: 4]
  |  |  |  |  |  |  ------------------
  |  |  |  |  |  |  109|      8|				 ((c) == 0xd) || \
  |  |  |  |  |  |  ------------------
  |  |  |  |  |  |  |  Branch (109:6): [True: 0, False: 8]
  |  |  |  |  |  |  ------------------
  |  |  |  |  |  |  110|      8|				  (0x20 <= (c)))
  |  |  |  |  |  |  ------------------
  |  |  |  |  |  |  |  Branch (110:7): [True: 4, False: 4]
  |  |  |  |  |  |  ------------------
  |  |  |  |  ------------------
  |  |  |  |  120|     12|				(((0x100 <= (c)) && ((c) <= 0xd7ff)) || \
  |  |  |  |  ------------------
  |  |  |  |  |  Branch (120:7): [True: 4, False: 0]
  |  |  |  |  |  Branch (120:25): [True: 0, False: 4]
  |  |  |  |  ------------------
  |  |  |  |  121|      4|				 ((0xe000 <= (c)) && ((c) <= 0xfffd)) || \
  |  |  |  |  ------------------
  |  |  |  |  |  Branch (121:7): [True: 4, False: 0]
  |  |  |  |  |  Branch (121:26): [True: 4, False: 0]
  |  |  |  |  ------------------
  |  |  |  |  122|      4|				 ((0x10000 <= (c)) && ((c) <= 0x10ffff))))
  |  |  |  |  ------------------
  |  |  |  |  |  Branch (122:7): [True: 0, False: 0]
  |  |  |  |  |  Branch (122:27): [True: 0, False: 0]
  |  |  |  |  ------------------
  |  |  ------------------
  ------------------
  |  Branch (4924:9): [True: 4, False: 8]
  ------------------
 4925|      4|        xmlFatalErrMsgInt(ctxt, XML_ERR_INVALID_CHAR,
 4926|      4|                          "xmlParseComment: invalid xmlChar value %d\n",
 4927|      4|	                  q);
 4928|      4|	xmlFree (buf);
 4929|      4|	return;
 4930|      4|    }
 4931|      8|    NEXTL(ql);
  ------------------
  |  | 2284|      8|#define NEXTL(l) do {							\
  |  | 2285|      8|    if (*(ctxt->input->cur) == '\n') {					\
  |  |  ------------------
  |  |  |  Branch (2285:9): [True: 0, False: 8]
  |  |  ------------------
  |  | 2286|      0|	ctxt->input->line++; ctxt->input->col = 1;			\
  |  | 2287|      8|    } else ctxt->input->col++;						\
  |  | 2288|      8|    ctxt->input->cur += l;				\
  |  | 2289|      8|  } while (0)
  |  |  ------------------
  |  |  |  Branch (2289:12): [Folded - Ignored]
  |  |  ------------------
  ------------------
 4932|      8|    r = CUR_CHAR(rl);
  ------------------
  |  | 2291|      8|#define CUR_CHAR(l) xmlCurrentChar(ctxt, &l)
  ------------------
 4933|      8|    if (r == 0)
  ------------------
  |  Branch (4933:9): [True: 0, False: 8]
  ------------------
 4934|      0|        goto not_terminated;
 4935|      8|    if (!IS_CHAR(r)) {
  ------------------
  |  |  125|      8|#define IS_CHAR(c)   xmlIsCharQ(c)
  |  |  ------------------
  |  |  |  |  118|      8|#define xmlIsCharQ(c)		(((c) < 0x100) ? \
  |  |  |  |  ------------------
  |  |  |  |  |  Branch (118:25): [True: 4, False: 4]
  |  |  |  |  ------------------
  |  |  |  |  119|      8|				 xmlIsChar_ch((c)) :\
  |  |  |  |  ------------------
  |  |  |  |  |  |  108|      4|#define xmlIsChar_ch(c)		(((0x9 <= (c)) && ((c) <= 0xa)) || \
  |  |  |  |  |  |  ------------------
  |  |  |  |  |  |  |  Branch (108:28): [True: 4, False: 0]
  |  |  |  |  |  |  |  Branch (108:44): [True: 0, False: 4]
  |  |  |  |  |  |  ------------------
  |  |  |  |  |  |  109|      4|				 ((c) == 0xd) || \
  |  |  |  |  |  |  ------------------
  |  |  |  |  |  |  |  Branch (109:6): [True: 0, False: 4]
  |  |  |  |  |  |  ------------------
  |  |  |  |  |  |  110|      4|				  (0x20 <= (c)))
  |  |  |  |  |  |  ------------------
  |  |  |  |  |  |  |  Branch (110:7): [True: 4, False: 0]
  |  |  |  |  |  |  ------------------
  |  |  |  |  ------------------
  |  |  |  |  120|      8|				(((0x100 <= (c)) && ((c) <= 0xd7ff)) || \
  |  |  |  |  ------------------
  |  |  |  |  |  Branch (120:7): [True: 4, False: 0]
  |  |  |  |  |  Branch (120:25): [True: 0, False: 4]
  |  |  |  |  ------------------
  |  |  |  |  121|      4|				 ((0xe000 <= (c)) && ((c) <= 0xfffd)) || \
  |  |  |  |  ------------------
  |  |  |  |  |  Branch (121:7): [True: 4, False: 0]
  |  |  |  |  |  Branch (121:26): [True: 4, False: 0]
  |  |  |  |  ------------------
  |  |  |  |  122|      4|				 ((0x10000 <= (c)) && ((c) <= 0x10ffff))))
  |  |  |  |  ------------------
  |  |  |  |  |  Branch (122:7): [True: 0, False: 0]
  |  |  |  |  |  Branch (122:27): [True: 0, False: 0]
  |  |  |  |  ------------------
  |  |  ------------------
  ------------------
  |  Branch (4935:9): [True: 0, False: 8]
  ------------------
 4936|      0|        xmlFatalErrMsgInt(ctxt, XML_ERR_INVALID_CHAR,
 4937|      0|                          "xmlParseComment: invalid xmlChar value %d\n",
 4938|      0|	                  r);
 4939|      0|	xmlFree (buf);
 4940|      0|	return;
 4941|      0|    }
 4942|      8|    NEXTL(rl);
  ------------------
  |  | 2284|      8|#define NEXTL(l) do {							\
  |  | 2285|      8|    if (*(ctxt->input->cur) == '\n') {					\
  |  |  ------------------
  |  |  |  Branch (2285:9): [True: 0, False: 8]
  |  |  ------------------
  |  | 2286|      0|	ctxt->input->line++; ctxt->input->col = 1;			\
  |  | 2287|      8|    } else ctxt->input->col++;						\
  |  | 2288|      8|    ctxt->input->cur += l;				\
  |  | 2289|      8|  } while (0)
  |  |  ------------------
  |  |  |  Branch (2289:12): [Folded - Ignored]
  |  |  ------------------
  ------------------
 4943|      8|    cur = CUR_CHAR(l);
  ------------------
  |  | 2291|      8|#define CUR_CHAR(l) xmlCurrentChar(ctxt, &l)
  ------------------
 4944|      8|    if (cur == 0)
  ------------------
  |  Branch (4944:9): [True: 0, False: 8]
  ------------------
 4945|      0|        goto not_terminated;
 4946|  1.20k|    while (IS_CHAR(cur) && /* checked */
  ------------------
  |  |  125|  1.20k|#define IS_CHAR(c)   xmlIsCharQ(c)
  |  |  ------------------
  |  |  |  |  118|  2.40k|#define xmlIsCharQ(c)		(((c) < 0x100) ? \
  |  |  |  |  ------------------
  |  |  |  |  |  Branch (118:24): [True: 1.20k, False: 0]
  |  |  |  |  |  Branch (118:25): [True: 832, False: 368]
  |  |  |  |  ------------------
  |  |  |  |  119|  2.40k|				 xmlIsChar_ch((c)) :\
  |  |  |  |  ------------------
  |  |  |  |  |  |  108|    832|#define xmlIsChar_ch(c)		(((0x9 <= (c)) && ((c) <= 0xa)) || \
  |  |  |  |  |  |  ------------------
  |  |  |  |  |  |  |  Branch (108:28): [True: 832, False: 0]
  |  |  |  |  |  |  |  Branch (108:44): [True: 0, False: 832]
  |  |  |  |  |  |  ------------------
  |  |  |  |  |  |  109|    832|				 ((c) == 0xd) || \
  |  |  |  |  |  |  ------------------
  |  |  |  |  |  |  |  Branch (109:6): [True: 0, False: 832]
  |  |  |  |  |  |  ------------------
  |  |  |  |  |  |  110|    832|				  (0x20 <= (c)))
  |  |  |  |  |  |  ------------------
  |  |  |  |  |  |  |  Branch (110:7): [True: 832, False: 0]
  |  |  |  |  |  |  ------------------
  |  |  |  |  ------------------
  |  |  |  |  120|  2.40k|				(((0x100 <= (c)) && ((c) <= 0xd7ff)) || \
  |  |  |  |  ------------------
  |  |  |  |  |  Branch (120:7): [True: 368, False: 0]
  |  |  |  |  |  Branch (120:25): [True: 0, False: 368]
  |  |  |  |  ------------------
  |  |  |  |  121|    368|				 ((0xe000 <= (c)) && ((c) <= 0xfffd)) || \
  |  |  |  |  ------------------
  |  |  |  |  |  Branch (121:7): [True: 368, False: 0]
  |  |  |  |  |  Branch (121:26): [True: 368, False: 0]
  |  |  |  |  ------------------
  |  |  |  |  122|    368|				 ((0x10000 <= (c)) && ((c) <= 0x10ffff))))
  |  |  |  |  ------------------
  |  |  |  |  |  Branch (122:7): [True: 0, False: 0]
  |  |  |  |  |  Branch (122:27): [True: 0, False: 0]
  |  |  |  |  ------------------
  |  |  ------------------
  ------------------
 4947|  1.20k|           ((cur != '>') ||
  ------------------
  |  Branch (4947:13): [True: 1.19k, False: 8]
  ------------------
 4948|  1.20k|	    (r != '-') || (q != '-'))) {
  ------------------
  |  Branch (4948:6): [True: 0, False: 8]
  |  Branch (4948:20): [True: 0, False: 8]
  ------------------
 4949|  1.19k|	if ((r == '-') && (q == '-')) {
  ------------------
  |  Branch (4949:6): [True: 8, False: 1.18k]
  |  Branch (4949:20): [True: 0, False: 8]
  ------------------
 4950|      0|	    xmlFatalErr(ctxt, XML_ERR_HYPHEN_IN_COMMENT, NULL);
 4951|      0|	}
 4952|  1.19k|	if (len + 5 >= size) {
  ------------------
  |  Branch (4952:6): [True: 16, False: 1.17k]
  ------------------
 4953|     16|	    xmlChar *new_buf;
 4954|     16|            size_t new_size;
 4955|       |
 4956|     16|	    new_size = size * 2;
 4957|     16|	    new_buf = (xmlChar *) xmlRealloc(buf, new_size);
 4958|     16|	    if (new_buf == NULL) {
  ------------------
  |  Branch (4958:10): [True: 0, False: 16]
  ------------------
 4959|      0|		xmlFree (buf);
 4960|      0|		xmlErrMemory(ctxt, NULL);
 4961|      0|		return;
 4962|      0|	    }
 4963|     16|	    buf = new_buf;
 4964|     16|            size = new_size;
 4965|     16|	}
 4966|  1.19k|	COPY_BUF(buf, len, q);
  ------------------
  |  | 2295|  1.19k|    if (v < 0x80) b[i++] = v;						\
  |  |  ------------------
  |  |  |  Branch (2295:9): [True: 388, False: 804]
  |  |  ------------------
  |  | 2296|  1.19k|    else i += xmlCopyCharMultiByte(&b[i],v)
  ------------------
 4967|  1.19k|        if (len > maxLength) {
  ------------------
  |  Branch (4967:13): [True: 0, False: 1.19k]
  ------------------
 4968|      0|            xmlFatalErrMsgStr(ctxt, XML_ERR_COMMENT_NOT_FINISHED,
 4969|      0|                         "Comment too big found", NULL);
 4970|      0|            xmlFree (buf);
 4971|      0|            return;
 4972|      0|        }
 4973|       |
 4974|  1.19k|	q = r;
 4975|  1.19k|	ql = rl;
 4976|  1.19k|	r = cur;
 4977|  1.19k|	rl = l;
 4978|       |
 4979|  1.19k|	NEXTL(l);
  ------------------
  |  | 2284|  1.19k|#define NEXTL(l) do {							\
  |  | 2285|  1.19k|    if (*(ctxt->input->cur) == '\n') {					\
  |  |  ------------------
  |  |  |  Branch (2285:9): [True: 0, False: 1.19k]
  |  |  ------------------
  |  | 2286|      0|	ctxt->input->line++; ctxt->input->col = 1;			\
  |  | 2287|  1.19k|    } else ctxt->input->col++;						\
  |  | 2288|  1.19k|    ctxt->input->cur += l;				\
  |  | 2289|  1.19k|  } while (0)
  |  |  ------------------
  |  |  |  Branch (2289:12): [Folded - Ignored]
  |  |  ------------------
  ------------------
 4980|  1.19k|	cur = CUR_CHAR(l);
  ------------------
  |  | 2291|  1.19k|#define CUR_CHAR(l) xmlCurrentChar(ctxt, &l)
  ------------------
 4981|       |
 4982|  1.19k|    }
 4983|      8|    buf[len] = 0;
 4984|      8|    if (ctxt->instate == XML_PARSER_EOF) {
  ------------------
  |  Branch (4984:9): [True: 0, False: 8]
  ------------------
 4985|      0|        xmlFree(buf);
 4986|      0|        return;
 4987|      0|    }
 4988|      8|    if (cur == 0) {
  ------------------
  |  Branch (4988:9): [True: 0, False: 8]
  ------------------
 4989|      0|	xmlFatalErrMsgStr(ctxt, XML_ERR_COMMENT_NOT_FINISHED,
 4990|      0|	                     "Comment not terminated \n<!--%.50s\n", buf);
 4991|      8|    } else if (!IS_CHAR(cur)) {
  ------------------
  |  |  125|      8|#define IS_CHAR(c)   xmlIsCharQ(c)
  |  |  ------------------
  |  |  |  |  118|      8|#define xmlIsCharQ(c)		(((c) < 0x100) ? \
  |  |  |  |  ------------------
  |  |  |  |  |  Branch (118:25): [True: 8, False: 0]
  |  |  |  |  ------------------
  |  |  |  |  119|      8|				 xmlIsChar_ch((c)) :\
  |  |  |  |  ------------------
  |  |  |  |  |  |  108|      8|#define xmlIsChar_ch(c)		(((0x9 <= (c)) && ((c) <= 0xa)) || \
  |  |  |  |  |  |  ------------------
  |  |  |  |  |  |  |  Branch (108:28): [True: 8, False: 0]
  |  |  |  |  |  |  |  Branch (108:44): [True: 0, False: 8]
  |  |  |  |  |  |  ------------------
  |  |  |  |  |  |  109|      8|				 ((c) == 0xd) || \
  |  |  |  |  |  |  ------------------
  |  |  |  |  |  |  |  Branch (109:6): [True: 0, False: 8]
  |  |  |  |  |  |  ------------------
  |  |  |  |  |  |  110|      8|				  (0x20 <= (c)))
  |  |  |  |  |  |  ------------------
  |  |  |  |  |  |  |  Branch (110:7): [True: 8, False: 0]
  |  |  |  |  |  |  ------------------
  |  |  |  |  ------------------
  |  |  |  |  120|      8|				(((0x100 <= (c)) && ((c) <= 0xd7ff)) || \
  |  |  |  |  ------------------
  |  |  |  |  |  Branch (120:7): [True: 0, False: 0]
  |  |  |  |  |  Branch (120:25): [True: 0, False: 0]
  |  |  |  |  ------------------
  |  |  |  |  121|      0|				 ((0xe000 <= (c)) && ((c) <= 0xfffd)) || \
  |  |  |  |  ------------------
  |  |  |  |  |  Branch (121:7): [True: 0, False: 0]
  |  |  |  |  |  Branch (121:26): [True: 0, False: 0]
  |  |  |  |  ------------------
  |  |  |  |  122|      0|				 ((0x10000 <= (c)) && ((c) <= 0x10ffff))))
  |  |  |  |  ------------------
  |  |  |  |  |  Branch (122:7): [True: 0, False: 0]
  |  |  |  |  |  Branch (122:27): [True: 0, False: 0]
  |  |  |  |  ------------------
  |  |  ------------------
  ------------------
  |  Branch (4991:16): [True: 0, False: 8]
  ------------------
 4992|      0|        xmlFatalErrMsgInt(ctxt, XML_ERR_INVALID_CHAR,
 4993|      0|                          "xmlParseComment: invalid xmlChar value %d\n",
 4994|      0|	                  cur);
 4995|      8|    } else {
 4996|      8|	if (inputid != ctxt->input->id) {
  ------------------
  |  Branch (4996:6): [True: 0, False: 8]
  ------------------
 4997|      0|	    xmlFatalErrMsg(ctxt, XML_ERR_ENTITY_BOUNDARY,
 4998|      0|		           "Comment doesn't start and stop in the same"
 4999|      0|                           " entity\n");
 5000|      0|	}
 5001|      8|        NEXT;
  ------------------
  |  | 2275|      8|#define NEXT xmlNextChar(ctxt)
  ------------------
 5002|      8|	if ((ctxt->sax != NULL) && (ctxt->sax->comment != NULL) &&
  ------------------
  |  Branch (5002:6): [True: 8, False: 0]
  |  Branch (5002:29): [True: 8, False: 0]
  ------------------
 5003|      8|	    (!ctxt->disableSAX))
  ------------------
  |  Branch (5003:6): [True: 4, False: 4]
  ------------------
 5004|      4|	    ctxt->sax->comment(ctxt->userData, buf);
 5005|      8|    }
 5006|      8|    xmlFree(buf);
 5007|      8|    return;
 5008|      8|not_terminated:
 5009|      8|    xmlFatalErrMsgStr(ctxt, XML_ERR_COMMENT_NOT_FINISHED,
 5010|      8|			 "Comment not terminated\n", NULL);
 5011|      8|    xmlFree(buf);
 5012|      8|    return;
 5013|      8|}
parser.c:xmlNsErr:
  501|     52|{
  502|     52|    if ((ctxt != NULL) && (ctxt->disableSAX != 0) &&
  ------------------
  |  Branch (502:9): [True: 52, False: 0]
  |  Branch (502:27): [True: 44, False: 8]
  ------------------
  503|     52|        (ctxt->instate == XML_PARSER_EOF))
  ------------------
  |  Branch (503:9): [True: 0, False: 44]
  ------------------
  504|      0|	return;
  505|     52|    if (ctxt != NULL)
  ------------------
  |  Branch (505:9): [True: 52, False: 0]
  ------------------
  506|     52|	ctxt->errNo = error;
  507|     52|    __xmlRaiseError(NULL, NULL, NULL, ctxt, NULL, XML_FROM_NAMESPACE, error,
  508|     52|                    XML_ERR_ERROR, NULL, 0, (const char *) info1,
  509|     52|                    (const char *) info2, (const char *) info3, 0, 0, msg,
  510|     52|                    info1, info2, info3);
  511|     52|    if (ctxt != NULL)
  ------------------
  |  Branch (511:9): [True: 52, False: 0]
  ------------------
  512|     52|	ctxt->nsWellFormed = 0;
  513|     52|}
parser.c:xmlAddSpecialAttr:
 1136|      8|{
 1137|      8|    if (ctxt->attsSpecial == NULL) {
  ------------------
  |  Branch (1137:9): [True: 8, False: 0]
  ------------------
 1138|      8|        ctxt->attsSpecial = xmlHashCreateDict(10, ctxt->dict);
 1139|      8|	if (ctxt->attsSpecial == NULL)
  ------------------
  |  Branch (1139:6): [True: 0, False: 8]
  ------------------
 1140|      0|	    goto mem_error;
 1141|      8|    }
 1142|       |
 1143|      8|    if (xmlHashLookup2(ctxt->attsSpecial, fullname, fullattr) != NULL)
  ------------------
  |  Branch (1143:9): [True: 0, False: 8]
  ------------------
 1144|      0|        return;
 1145|       |
 1146|      8|    xmlHashAddEntry2(ctxt->attsSpecial, fullname, fullattr,
 1147|      8|                     (void *) (ptrdiff_t) type);
 1148|      8|    return;
 1149|       |
 1150|      0|mem_error:
 1151|      0|    xmlErrMemory(ctxt, NULL);
 1152|      0|    return;
 1153|      8|}
parser.c:xmlParseElementChildrenContentDeclPriv:
 6385|     14|                                       int depth) {
 6386|     14|    xmlElementContentPtr ret = NULL, cur = NULL, last = NULL, op = NULL;
 6387|     14|    const xmlChar *elem;
 6388|     14|    xmlChar type = 0;
 6389|       |
 6390|     14|    if (((depth > 128) && ((ctxt->options & XML_PARSE_HUGE) == 0)) ||
  ------------------
  |  Branch (6390:10): [True: 0, False: 14]
  |  Branch (6390:27): [True: 0, False: 0]
  ------------------
 6391|     14|        (depth >  2048)) {
  ------------------
  |  Branch (6391:9): [True: 0, False: 14]
  ------------------
 6392|      0|        xmlFatalErrMsgInt(ctxt, XML_ERR_ELEMCONTENT_NOT_FINISHED,
 6393|      0|"xmlParseElementChildrenContentDecl : depth %d too deep, use XML_PARSE_HUGE\n",
 6394|      0|                          depth);
 6395|      0|	return(NULL);
 6396|      0|    }
 6397|     14|    SKIP_BLANKS;
  ------------------
  |  | 2273|     14|#define SKIP_BLANKS xmlSkipBlankChars(ctxt)
  ------------------
 6398|     14|    GROW;
  ------------------
  |  | 2270|     14|#define GROW if (ctxt->input->end - ctxt->input->cur < INPUT_CHUNK)	\
  |  |  ------------------
  |  |  |  |   97|     14|#define INPUT_CHUNK	250
  |  |  ------------------
  |  |  |  Branch (2270:18): [True: 10, False: 4]
  |  |  ------------------
  |  | 2271|     14|	xmlParserGrow(ctxt);
  ------------------
 6399|     14|    if (RAW == '(') {
  ------------------
  |  | 2221|     14|#define RAW (*ctxt->input->cur)
  ------------------
  |  Branch (6399:9): [True: 0, False: 14]
  ------------------
 6400|      0|	int inputid = ctxt->input->id;
 6401|       |
 6402|       |        /* Recurse on first child */
 6403|      0|	NEXT;
  ------------------
  |  | 2275|      0|#define NEXT xmlNextChar(ctxt)
  ------------------
 6404|      0|	SKIP_BLANKS;
  ------------------
  |  | 2273|      0|#define SKIP_BLANKS xmlSkipBlankChars(ctxt)
  ------------------
 6405|      0|        cur = ret = xmlParseElementChildrenContentDeclPriv(ctxt, inputid,
 6406|      0|                                                           depth + 1);
 6407|      0|        if (cur == NULL)
  ------------------
  |  Branch (6407:13): [True: 0, False: 0]
  ------------------
 6408|      0|            return(NULL);
 6409|      0|	SKIP_BLANKS;
  ------------------
  |  | 2273|      0|#define SKIP_BLANKS xmlSkipBlankChars(ctxt)
  ------------------
 6410|      0|	GROW;
  ------------------
  |  | 2270|      0|#define GROW if (ctxt->input->end - ctxt->input->cur < INPUT_CHUNK)	\
  |  |  ------------------
  |  |  |  |   97|      0|#define INPUT_CHUNK	250
  |  |  ------------------
  |  |  |  Branch (2270:18): [True: 0, False: 0]
  |  |  ------------------
  |  | 2271|      0|	xmlParserGrow(ctxt);
  ------------------
 6411|     14|    } else {
 6412|     14|	elem = xmlParseName(ctxt);
 6413|     14|	if (elem == NULL) {
  ------------------
  |  Branch (6413:6): [True: 0, False: 14]
  ------------------
 6414|      0|	    xmlFatalErr(ctxt, XML_ERR_ELEMCONTENT_NOT_STARTED, NULL);
 6415|      0|	    return(NULL);
 6416|      0|	}
 6417|     14|        cur = ret = xmlNewDocElementContent(ctxt->myDoc, elem, XML_ELEMENT_CONTENT_ELEMENT);
 6418|     14|	if (cur == NULL) {
  ------------------
  |  Branch (6418:6): [True: 0, False: 14]
  ------------------
 6419|      0|	    xmlErrMemory(ctxt, NULL);
 6420|      0|	    return(NULL);
 6421|      0|	}
 6422|     14|	GROW;
  ------------------
  |  | 2270|     14|#define GROW if (ctxt->input->end - ctxt->input->cur < INPUT_CHUNK)	\
  |  |  ------------------
  |  |  |  |   97|     14|#define INPUT_CHUNK	250
  |  |  ------------------
  |  |  |  Branch (2270:18): [True: 10, False: 4]
  |  |  ------------------
  |  | 2271|     14|	xmlParserGrow(ctxt);
  ------------------
 6423|     14|	if (RAW == '?') {
  ------------------
  |  | 2221|     14|#define RAW (*ctxt->input->cur)
  ------------------
  |  Branch (6423:6): [True: 0, False: 14]
  ------------------
 6424|      0|	    cur->ocur = XML_ELEMENT_CONTENT_OPT;
 6425|      0|	    NEXT;
  ------------------
  |  | 2275|      0|#define NEXT xmlNextChar(ctxt)
  ------------------
 6426|     14|	} else if (RAW == '*') {
  ------------------
  |  | 2221|     14|#define RAW (*ctxt->input->cur)
  ------------------
  |  Branch (6426:13): [True: 14, False: 0]
  ------------------
 6427|     14|	    cur->ocur = XML_ELEMENT_CONTENT_MULT;
 6428|     14|	    NEXT;
  ------------------
  |  | 2275|     14|#define NEXT xmlNextChar(ctxt)
  ------------------
 6429|     14|	} else if (RAW == '+') {
  ------------------
  |  | 2221|      0|#define RAW (*ctxt->input->cur)
  ------------------
  |  Branch (6429:13): [True: 0, False: 0]
  ------------------
 6430|      0|	    cur->ocur = XML_ELEMENT_CONTENT_PLUS;
 6431|      0|	    NEXT;
  ------------------
  |  | 2275|      0|#define NEXT xmlNextChar(ctxt)
  ------------------
 6432|      0|	} else {
 6433|      0|	    cur->ocur = XML_ELEMENT_CONTENT_ONCE;
 6434|      0|	}
 6435|     14|	GROW;
  ------------------
  |  | 2270|     14|#define GROW if (ctxt->input->end - ctxt->input->cur < INPUT_CHUNK)	\
  |  |  ------------------
  |  |  |  |   97|     14|#define INPUT_CHUNK	250
  |  |  ------------------
  |  |  |  Branch (2270:18): [True: 10, False: 4]
  |  |  ------------------
  |  | 2271|     14|	xmlParserGrow(ctxt);
  ------------------
 6436|     14|    }
 6437|     14|    SKIP_BLANKS;
  ------------------
  |  | 2273|     14|#define SKIP_BLANKS xmlSkipBlankChars(ctxt)
  ------------------
 6438|     14|    while ((RAW != ')') && (ctxt->instate != XML_PARSER_EOF)) {
  ------------------
  |  | 2221|     14|#define RAW (*ctxt->input->cur)
  ------------------
  |  Branch (6438:12): [True: 0, False: 14]
  |  Branch (6438:28): [True: 0, False: 0]
  ------------------
 6439|       |        /*
 6440|       |	 * Each loop we parse one separator and one element.
 6441|       |	 */
 6442|      0|        if (RAW == ',') {
  ------------------
  |  | 2221|      0|#define RAW (*ctxt->input->cur)
  ------------------
  |  Branch (6442:13): [True: 0, False: 0]
  ------------------
 6443|      0|	    if (type == 0) type = CUR;
  ------------------
  |  | 2222|      0|#define CUR (*ctxt->input->cur)
  ------------------
  |  Branch (6443:10): [True: 0, False: 0]
  ------------------
 6444|       |
 6445|       |	    /*
 6446|       |	     * Detect "Name | Name , Name" error
 6447|       |	     */
 6448|      0|	    else if (type != CUR) {
  ------------------
  |  | 2222|      0|#define CUR (*ctxt->input->cur)
  ------------------
  |  Branch (6448:15): [True: 0, False: 0]
  ------------------
 6449|      0|		xmlFatalErrMsgInt(ctxt, XML_ERR_SEPARATOR_REQUIRED,
 6450|      0|		    "xmlParseElementChildrenContentDecl : '%c' expected\n",
 6451|      0|		                  type);
 6452|      0|		if ((last != NULL) && (last != ret))
  ------------------
  |  Branch (6452:7): [True: 0, False: 0]
  |  Branch (6452:25): [True: 0, False: 0]
  ------------------
 6453|      0|		    xmlFreeDocElementContent(ctxt->myDoc, last);
 6454|      0|		if (ret != NULL)
  ------------------
  |  Branch (6454:7): [True: 0, False: 0]
  ------------------
 6455|      0|		    xmlFreeDocElementContent(ctxt->myDoc, ret);
 6456|      0|		return(NULL);
 6457|      0|	    }
 6458|      0|	    NEXT;
  ------------------
  |  | 2275|      0|#define NEXT xmlNextChar(ctxt)
  ------------------
 6459|       |
 6460|      0|	    op = xmlNewDocElementContent(ctxt->myDoc, NULL, XML_ELEMENT_CONTENT_SEQ);
 6461|      0|	    if (op == NULL) {
  ------------------
  |  Branch (6461:10): [True: 0, False: 0]
  ------------------
 6462|      0|		if ((last != NULL) && (last != ret))
  ------------------
  |  Branch (6462:7): [True: 0, False: 0]
  |  Branch (6462:25): [True: 0, False: 0]
  ------------------
 6463|      0|		    xmlFreeDocElementContent(ctxt->myDoc, last);
 6464|      0|	        xmlFreeDocElementContent(ctxt->myDoc, ret);
 6465|      0|		return(NULL);
 6466|      0|	    }
 6467|      0|	    if (last == NULL) {
  ------------------
  |  Branch (6467:10): [True: 0, False: 0]
  ------------------
 6468|      0|		op->c1 = ret;
 6469|      0|		if (ret != NULL)
  ------------------
  |  Branch (6469:7): [True: 0, False: 0]
  ------------------
 6470|      0|		    ret->parent = op;
 6471|      0|		ret = cur = op;
 6472|      0|	    } else {
 6473|      0|	        cur->c2 = op;
 6474|      0|		if (op != NULL)
  ------------------
  |  Branch (6474:7): [True: 0, False: 0]
  ------------------
 6475|      0|		    op->parent = cur;
 6476|      0|		op->c1 = last;
 6477|      0|		if (last != NULL)
  ------------------
  |  Branch (6477:7): [True: 0, False: 0]
  ------------------
 6478|      0|		    last->parent = op;
 6479|      0|		cur =op;
 6480|      0|		last = NULL;
 6481|      0|	    }
 6482|      0|	} else if (RAW == '|') {
  ------------------
  |  | 2221|      0|#define RAW (*ctxt->input->cur)
  ------------------
  |  Branch (6482:13): [True: 0, False: 0]
  ------------------
 6483|      0|	    if (type == 0) type = CUR;
  ------------------
  |  | 2222|      0|#define CUR (*ctxt->input->cur)
  ------------------
  |  Branch (6483:10): [True: 0, False: 0]
  ------------------
 6484|       |
 6485|       |	    /*
 6486|       |	     * Detect "Name , Name | Name" error
 6487|       |	     */
 6488|      0|	    else if (type != CUR) {
  ------------------
  |  | 2222|      0|#define CUR (*ctxt->input->cur)
  ------------------
  |  Branch (6488:15): [True: 0, False: 0]
  ------------------
 6489|      0|		xmlFatalErrMsgInt(ctxt, XML_ERR_SEPARATOR_REQUIRED,
 6490|      0|		    "xmlParseElementChildrenContentDecl : '%c' expected\n",
 6491|      0|				  type);
 6492|      0|		if ((last != NULL) && (last != ret))
  ------------------
  |  Branch (6492:7): [True: 0, False: 0]
  |  Branch (6492:25): [True: 0, False: 0]
  ------------------
 6493|      0|		    xmlFreeDocElementContent(ctxt->myDoc, last);
 6494|      0|		if (ret != NULL)
  ------------------
  |  Branch (6494:7): [True: 0, False: 0]
  ------------------
 6495|      0|		    xmlFreeDocElementContent(ctxt->myDoc, ret);
 6496|      0|		return(NULL);
 6497|      0|	    }
 6498|      0|	    NEXT;
  ------------------
  |  | 2275|      0|#define NEXT xmlNextChar(ctxt)
  ------------------
 6499|       |
 6500|      0|	    op = xmlNewDocElementContent(ctxt->myDoc, NULL, XML_ELEMENT_CONTENT_OR);
 6501|      0|	    if (op == NULL) {
  ------------------
  |  Branch (6501:10): [True: 0, False: 0]
  ------------------
 6502|      0|		if ((last != NULL) && (last != ret))
  ------------------
  |  Branch (6502:7): [True: 0, False: 0]
  |  Branch (6502:25): [True: 0, False: 0]
  ------------------
 6503|      0|		    xmlFreeDocElementContent(ctxt->myDoc, last);
 6504|      0|		if (ret != NULL)
  ------------------
  |  Branch (6504:7): [True: 0, False: 0]
  ------------------
 6505|      0|		    xmlFreeDocElementContent(ctxt->myDoc, ret);
 6506|      0|		return(NULL);
 6507|      0|	    }
 6508|      0|	    if (last == NULL) {
  ------------------
  |  Branch (6508:10): [True: 0, False: 0]
  ------------------
 6509|      0|		op->c1 = ret;
 6510|      0|		if (ret != NULL)
  ------------------
  |  Branch (6510:7): [True: 0, False: 0]
  ------------------
 6511|      0|		    ret->parent = op;
 6512|      0|		ret = cur = op;
 6513|      0|	    } else {
 6514|      0|	        cur->c2 = op;
 6515|      0|		if (op != NULL)
  ------------------
  |  Branch (6515:7): [True: 0, False: 0]
  ------------------
 6516|      0|		    op->parent = cur;
 6517|      0|		op->c1 = last;
 6518|      0|		if (last != NULL)
  ------------------
  |  Branch (6518:7): [True: 0, False: 0]
  ------------------
 6519|      0|		    last->parent = op;
 6520|      0|		cur =op;
 6521|      0|		last = NULL;
 6522|      0|	    }
 6523|      0|	} else {
 6524|      0|	    xmlFatalErr(ctxt, XML_ERR_ELEMCONTENT_NOT_FINISHED, NULL);
 6525|      0|	    if ((last != NULL) && (last != ret))
  ------------------
  |  Branch (6525:10): [True: 0, False: 0]
  |  Branch (6525:28): [True: 0, False: 0]
  ------------------
 6526|      0|	        xmlFreeDocElementContent(ctxt->myDoc, last);
 6527|      0|	    if (ret != NULL)
  ------------------
  |  Branch (6527:10): [True: 0, False: 0]
  ------------------
 6528|      0|		xmlFreeDocElementContent(ctxt->myDoc, ret);
 6529|      0|	    return(NULL);
 6530|      0|	}
 6531|      0|	GROW;
  ------------------
  |  | 2270|      0|#define GROW if (ctxt->input->end - ctxt->input->cur < INPUT_CHUNK)	\
  |  |  ------------------
  |  |  |  |   97|      0|#define INPUT_CHUNK	250
  |  |  ------------------
  |  |  |  Branch (2270:18): [True: 0, False: 0]
  |  |  ------------------
  |  | 2271|      0|	xmlParserGrow(ctxt);
  ------------------
 6532|      0|	SKIP_BLANKS;
  ------------------
  |  | 2273|      0|#define SKIP_BLANKS xmlSkipBlankChars(ctxt)
  ------------------
 6533|      0|	GROW;
  ------------------
  |  | 2270|      0|#define GROW if (ctxt->input->end - ctxt->input->cur < INPUT_CHUNK)	\
  |  |  ------------------
  |  |  |  |   97|      0|#define INPUT_CHUNK	250
  |  |  ------------------
  |  |  |  Branch (2270:18): [True: 0, False: 0]
  |  |  ------------------
  |  | 2271|      0|	xmlParserGrow(ctxt);
  ------------------
 6534|      0|	if (RAW == '(') {
  ------------------
  |  | 2221|      0|#define RAW (*ctxt->input->cur)
  ------------------
  |  Branch (6534:6): [True: 0, False: 0]
  ------------------
 6535|      0|	    int inputid = ctxt->input->id;
 6536|       |	    /* Recurse on second child */
 6537|      0|	    NEXT;
  ------------------
  |  | 2275|      0|#define NEXT xmlNextChar(ctxt)
  ------------------
 6538|      0|	    SKIP_BLANKS;
  ------------------
  |  | 2273|      0|#define SKIP_BLANKS xmlSkipBlankChars(ctxt)
  ------------------
 6539|      0|	    last = xmlParseElementChildrenContentDeclPriv(ctxt, inputid,
 6540|      0|                                                          depth + 1);
 6541|      0|            if (last == NULL) {
  ------------------
  |  Branch (6541:17): [True: 0, False: 0]
  ------------------
 6542|      0|		if (ret != NULL)
  ------------------
  |  Branch (6542:7): [True: 0, False: 0]
  ------------------
 6543|      0|		    xmlFreeDocElementContent(ctxt->myDoc, ret);
 6544|      0|		return(NULL);
 6545|      0|            }
 6546|      0|	    SKIP_BLANKS;
  ------------------
  |  | 2273|      0|#define SKIP_BLANKS xmlSkipBlankChars(ctxt)
  ------------------
 6547|      0|	} else {
 6548|      0|	    elem = xmlParseName(ctxt);
 6549|      0|	    if (elem == NULL) {
  ------------------
  |  Branch (6549:10): [True: 0, False: 0]
  ------------------
 6550|      0|		xmlFatalErr(ctxt, XML_ERR_ELEMCONTENT_NOT_STARTED, NULL);
 6551|      0|		if (ret != NULL)
  ------------------
  |  Branch (6551:7): [True: 0, False: 0]
  ------------------
 6552|      0|		    xmlFreeDocElementContent(ctxt->myDoc, ret);
 6553|      0|		return(NULL);
 6554|      0|	    }
 6555|      0|	    last = xmlNewDocElementContent(ctxt->myDoc, elem, XML_ELEMENT_CONTENT_ELEMENT);
 6556|      0|	    if (last == NULL) {
  ------------------
  |  Branch (6556:10): [True: 0, False: 0]
  ------------------
 6557|      0|		if (ret != NULL)
  ------------------
  |  Branch (6557:7): [True: 0, False: 0]
  ------------------
 6558|      0|		    xmlFreeDocElementContent(ctxt->myDoc, ret);
 6559|      0|		return(NULL);
 6560|      0|	    }
 6561|      0|	    if (RAW == '?') {
  ------------------
  |  | 2221|      0|#define RAW (*ctxt->input->cur)
  ------------------
  |  Branch (6561:10): [True: 0, False: 0]
  ------------------
 6562|      0|		last->ocur = XML_ELEMENT_CONTENT_OPT;
 6563|      0|		NEXT;
  ------------------
  |  | 2275|      0|#define NEXT xmlNextChar(ctxt)
  ------------------
 6564|      0|	    } else if (RAW == '*') {
  ------------------
  |  | 2221|      0|#define RAW (*ctxt->input->cur)
  ------------------
  |  Branch (6564:17): [True: 0, False: 0]
  ------------------
 6565|      0|		last->ocur = XML_ELEMENT_CONTENT_MULT;
 6566|      0|		NEXT;
  ------------------
  |  | 2275|      0|#define NEXT xmlNextChar(ctxt)
  ------------------
 6567|      0|	    } else if (RAW == '+') {
  ------------------
  |  | 2221|      0|#define RAW (*ctxt->input->cur)
  ------------------
  |  Branch (6567:17): [True: 0, False: 0]
  ------------------
 6568|      0|		last->ocur = XML_ELEMENT_CONTENT_PLUS;
 6569|      0|		NEXT;
  ------------------
  |  | 2275|      0|#define NEXT xmlNextChar(ctxt)
  ------------------
 6570|      0|	    } else {
 6571|      0|		last->ocur = XML_ELEMENT_CONTENT_ONCE;
 6572|      0|	    }
 6573|      0|	}
 6574|      0|	SKIP_BLANKS;
  ------------------
  |  | 2273|      0|#define SKIP_BLANKS xmlSkipBlankChars(ctxt)
  ------------------
 6575|      0|	GROW;
  ------------------
  |  | 2270|      0|#define GROW if (ctxt->input->end - ctxt->input->cur < INPUT_CHUNK)	\
  |  |  ------------------
  |  |  |  |   97|      0|#define INPUT_CHUNK	250
  |  |  ------------------
  |  |  |  Branch (2270:18): [True: 0, False: 0]
  |  |  ------------------
  |  | 2271|      0|	xmlParserGrow(ctxt);
  ------------------
 6576|      0|    }
 6577|     14|    if ((cur != NULL) && (last != NULL)) {
  ------------------
  |  Branch (6577:9): [True: 14, False: 0]
  |  Branch (6577:26): [True: 0, False: 14]
  ------------------
 6578|      0|        cur->c2 = last;
 6579|      0|	if (last != NULL)
  ------------------
  |  Branch (6579:6): [True: 0, False: 0]
  ------------------
 6580|      0|	    last->parent = cur;
 6581|      0|    }
 6582|     14|    if (ctxt->input->id != inputchk) {
  ------------------
  |  Branch (6582:9): [True: 0, False: 14]
  ------------------
 6583|      0|	xmlFatalErrMsg(ctxt, XML_ERR_ENTITY_BOUNDARY,
 6584|      0|                       "Element content declaration doesn't start and stop in"
 6585|      0|                       " the same entity\n");
 6586|      0|    }
 6587|     14|    NEXT;
  ------------------
  |  | 2275|     14|#define NEXT xmlNextChar(ctxt)
  ------------------
 6588|     14|    if (RAW == '?') {
  ------------------
  |  | 2221|     14|#define RAW (*ctxt->input->cur)
  ------------------
  |  Branch (6588:9): [True: 0, False: 14]
  ------------------
 6589|      0|	if (ret != NULL) {
  ------------------
  |  Branch (6589:6): [True: 0, False: 0]
  ------------------
 6590|      0|	    if ((ret->ocur == XML_ELEMENT_CONTENT_PLUS) ||
  ------------------
  |  Branch (6590:10): [True: 0, False: 0]
  ------------------
 6591|      0|	        (ret->ocur == XML_ELEMENT_CONTENT_MULT))
  ------------------
  |  Branch (6591:10): [True: 0, False: 0]
  ------------------
 6592|      0|	        ret->ocur = XML_ELEMENT_CONTENT_MULT;
 6593|      0|	    else
 6594|      0|	        ret->ocur = XML_ELEMENT_CONTENT_OPT;
 6595|      0|	}
 6596|      0|	NEXT;
  ------------------
  |  | 2275|      0|#define NEXT xmlNextChar(ctxt)
  ------------------
 6597|     14|    } else if (RAW == '*') {
  ------------------
  |  | 2221|     14|#define RAW (*ctxt->input->cur)
  ------------------
  |  Branch (6597:16): [True: 0, False: 14]
  ------------------
 6598|      0|	if (ret != NULL) {
  ------------------
  |  Branch (6598:6): [True: 0, False: 0]
  ------------------
 6599|      0|	    ret->ocur = XML_ELEMENT_CONTENT_MULT;
 6600|      0|	    cur = ret;
 6601|       |	    /*
 6602|       |	     * Some normalization:
 6603|       |	     * (a | b* | c?)* == (a | b | c)*
 6604|       |	     */
 6605|      0|	    while ((cur != NULL) && (cur->type == XML_ELEMENT_CONTENT_OR)) {
  ------------------
  |  Branch (6605:13): [True: 0, False: 0]
  |  Branch (6605:30): [True: 0, False: 0]
  ------------------
 6606|      0|		if ((cur->c1 != NULL) &&
  ------------------
  |  Branch (6606:7): [True: 0, False: 0]
  ------------------
 6607|      0|	            ((cur->c1->ocur == XML_ELEMENT_CONTENT_OPT) ||
  ------------------
  |  Branch (6607:15): [True: 0, False: 0]
  ------------------
 6608|      0|		     (cur->c1->ocur == XML_ELEMENT_CONTENT_MULT)))
  ------------------
  |  Branch (6608:8): [True: 0, False: 0]
  ------------------
 6609|      0|		    cur->c1->ocur = XML_ELEMENT_CONTENT_ONCE;
 6610|      0|		if ((cur->c2 != NULL) &&
  ------------------
  |  Branch (6610:7): [True: 0, False: 0]
  ------------------
 6611|      0|	            ((cur->c2->ocur == XML_ELEMENT_CONTENT_OPT) ||
  ------------------
  |  Branch (6611:15): [True: 0, False: 0]
  ------------------
 6612|      0|		     (cur->c2->ocur == XML_ELEMENT_CONTENT_MULT)))
  ------------------
  |  Branch (6612:8): [True: 0, False: 0]
  ------------------
 6613|      0|		    cur->c2->ocur = XML_ELEMENT_CONTENT_ONCE;
 6614|      0|		cur = cur->c2;
 6615|      0|	    }
 6616|      0|	}
 6617|      0|	NEXT;
  ------------------
  |  | 2275|      0|#define NEXT xmlNextChar(ctxt)
  ------------------
 6618|     14|    } else if (RAW == '+') {
  ------------------
  |  | 2221|     14|#define RAW (*ctxt->input->cur)
  ------------------
  |  Branch (6618:16): [True: 0, False: 14]
  ------------------
 6619|      0|	if (ret != NULL) {
  ------------------
  |  Branch (6619:6): [True: 0, False: 0]
  ------------------
 6620|      0|	    int found = 0;
 6621|       |
 6622|      0|	    if ((ret->ocur == XML_ELEMENT_CONTENT_OPT) ||
  ------------------
  |  Branch (6622:10): [True: 0, False: 0]
  ------------------
 6623|      0|	        (ret->ocur == XML_ELEMENT_CONTENT_MULT))
  ------------------
  |  Branch (6623:10): [True: 0, False: 0]
  ------------------
 6624|      0|	        ret->ocur = XML_ELEMENT_CONTENT_MULT;
 6625|      0|	    else
 6626|      0|	        ret->ocur = XML_ELEMENT_CONTENT_PLUS;
 6627|       |	    /*
 6628|       |	     * Some normalization:
 6629|       |	     * (a | b*)+ == (a | b)*
 6630|       |	     * (a | b?)+ == (a | b)*
 6631|       |	     */
 6632|      0|	    while ((cur != NULL) && (cur->type == XML_ELEMENT_CONTENT_OR)) {
  ------------------
  |  Branch (6632:13): [True: 0, False: 0]
  |  Branch (6632:30): [True: 0, False: 0]
  ------------------
 6633|      0|		if ((cur->c1 != NULL) &&
  ------------------
  |  Branch (6633:7): [True: 0, False: 0]
  ------------------
 6634|      0|	            ((cur->c1->ocur == XML_ELEMENT_CONTENT_OPT) ||
  ------------------
  |  Branch (6634:15): [True: 0, False: 0]
  ------------------
 6635|      0|		     (cur->c1->ocur == XML_ELEMENT_CONTENT_MULT))) {
  ------------------
  |  Branch (6635:8): [True: 0, False: 0]
  ------------------
 6636|      0|		    cur->c1->ocur = XML_ELEMENT_CONTENT_ONCE;
 6637|      0|		    found = 1;
 6638|      0|		}
 6639|      0|		if ((cur->c2 != NULL) &&
  ------------------
  |  Branch (6639:7): [True: 0, False: 0]
  ------------------
 6640|      0|	            ((cur->c2->ocur == XML_ELEMENT_CONTENT_OPT) ||
  ------------------
  |  Branch (6640:15): [True: 0, False: 0]
  ------------------
 6641|      0|		     (cur->c2->ocur == XML_ELEMENT_CONTENT_MULT))) {
  ------------------
  |  Branch (6641:8): [True: 0, False: 0]
  ------------------
 6642|      0|		    cur->c2->ocur = XML_ELEMENT_CONTENT_ONCE;
 6643|      0|		    found = 1;
 6644|      0|		}
 6645|      0|		cur = cur->c2;
 6646|      0|	    }
 6647|      0|	    if (found)
  ------------------
  |  Branch (6647:10): [True: 0, False: 0]
  ------------------
 6648|      0|		ret->ocur = XML_ELEMENT_CONTENT_MULT;
 6649|      0|	}
 6650|      0|	NEXT;
  ------------------
  |  | 2275|      0|#define NEXT xmlNextChar(ctxt)
  ------------------
 6651|      0|    }
 6652|     14|    return(ret);
 6653|     14|}
parser.c:xmlDetectSAX2:
  857|    363|xmlDetectSAX2(xmlParserCtxtPtr ctxt) {
  858|    363|    xmlSAXHandlerPtr sax;
  859|       |
  860|       |    /* Avoid unused variable warning if features are disabled. */
  861|    363|    (void) sax;
  862|       |
  863|    363|    if (ctxt == NULL) return;
  ------------------
  |  Branch (863:9): [True: 0, False: 363]
  ------------------
  864|    363|    sax = ctxt->sax;
  865|    363|#ifdef LIBXML_SAX1_ENABLED
  866|    363|    if ((sax) && (sax->initialized == XML_SAX2_MAGIC))
  ------------------
  |  |  685|    363|#define XML_SAX2_MAGIC 0xDEEDBEAF
  ------------------
  |  Branch (866:9): [True: 363, False: 0]
  |  Branch (866:18): [True: 360, False: 3]
  ------------------
  867|    360|        ctxt->sax2 = 1;
  868|       |#else
  869|       |    ctxt->sax2 = 1;
  870|       |#endif /* LIBXML_SAX1_ENABLED */
  871|       |
  872|    363|    ctxt->str_xml = xmlDictLookup(ctxt->dict, BAD_CAST "xml", 3);
  ------------------
  |  |   35|    363|#define BAD_CAST (xmlChar *)
  ------------------
  873|    363|    ctxt->str_xmlns = xmlDictLookup(ctxt->dict, BAD_CAST "xmlns", 5);
  ------------------
  |  |   35|    363|#define BAD_CAST (xmlChar *)
  ------------------
  874|    363|    ctxt->str_xml_ns = xmlDictLookup(ctxt->dict, XML_XML_NAMESPACE, 36);
  ------------------
  |  |  143|    363|    (const xmlChar *) "http://www.w3.org/XML/1998/namespace"
  ------------------
  875|    363|    if ((ctxt->str_xml==NULL) || (ctxt->str_xmlns==NULL) ||
  ------------------
  |  Branch (875:9): [True: 0, False: 363]
  |  Branch (875:34): [True: 0, False: 363]
  ------------------
  876|    363|		(ctxt->str_xml_ns == NULL)) {
  ------------------
  |  Branch (876:3): [True: 0, False: 363]
  ------------------
  877|      0|        xmlErrMemory(ctxt, NULL);
  878|      0|    }
  879|    363|}
parser.c:xmlParseEndTag1:
 8853|      2|xmlParseEndTag1(xmlParserCtxtPtr ctxt, int line) {
 8854|      2|    const xmlChar *name;
 8855|       |
 8856|      2|    GROW;
  ------------------
  |  | 2270|      2|#define GROW if (ctxt->input->end - ctxt->input->cur < INPUT_CHUNK)	\
  |  |  ------------------
  |  |  |  |   97|      2|#define INPUT_CHUNK	250
  |  |  ------------------
  |  |  |  Branch (2270:18): [True: 2, False: 0]
  |  |  ------------------
  |  | 2271|      2|	xmlParserGrow(ctxt);
  ------------------
 8857|      2|    if ((RAW != '<') || (NXT(1) != '/')) {
  ------------------
  |  | 2221|      2|#define RAW (*ctxt->input->cur)
  ------------------
                  if ((RAW != '<') || (NXT(1) != '/')) {
  ------------------
  |  | 2223|      2|#define NXT(val) ctxt->input->cur[(val)]
  ------------------
  |  Branch (8857:9): [True: 0, False: 2]
  |  Branch (8857:25): [True: 0, False: 2]
  ------------------
 8858|      0|	xmlFatalErrMsg(ctxt, XML_ERR_LTSLASH_REQUIRED,
 8859|      0|		       "xmlParseEndTag: '</' not found\n");
 8860|      0|	return;
 8861|      0|    }
 8862|      2|    SKIP(2);
  ------------------
  |  | 2245|      2|#define SKIP(val) do {							\
  |  | 2246|      2|    ctxt->input->cur += (val),ctxt->input->col+=(val);			\
  |  | 2247|      2|    if (*ctxt->input->cur == 0)						\
  |  |  ------------------
  |  |  |  Branch (2247:9): [True: 0, False: 2]
  |  |  ------------------
  |  | 2248|      2|        xmlParserGrow(ctxt);						\
  |  | 2249|      2|  } while (0)
  |  |  ------------------
  |  |  |  Branch (2249:12): [Folded - Ignored]
  |  |  ------------------
  ------------------
 8863|       |
 8864|      2|    name = xmlParseNameAndCompare(ctxt,ctxt->name);
 8865|       |
 8866|       |    /*
 8867|       |     * We should definitely be at the ending "S? '>'" part
 8868|       |     */
 8869|      2|    GROW;
  ------------------
  |  | 2270|      2|#define GROW if (ctxt->input->end - ctxt->input->cur < INPUT_CHUNK)	\
  |  |  ------------------
  |  |  |  |   97|      2|#define INPUT_CHUNK	250
  |  |  ------------------
  |  |  |  Branch (2270:18): [True: 2, False: 0]
  |  |  ------------------
  |  | 2271|      2|	xmlParserGrow(ctxt);
  ------------------
 8870|      2|    SKIP_BLANKS;
  ------------------
  |  | 2273|      2|#define SKIP_BLANKS xmlSkipBlankChars(ctxt)
  ------------------
 8871|      2|    if ((!IS_BYTE_CHAR(RAW)) || (RAW != '>')) {
  ------------------
  |  |  113|      2|#define IS_BYTE_CHAR(c)	 xmlIsChar_ch(c)
  |  |  ------------------
  |  |  |  |  108|      2|#define xmlIsChar_ch(c)		(((0x9 <= (c)) && ((c) <= 0xa)) || \
  |  |  |  |  ------------------
  |  |  |  |  |  Branch (108:28): [True: 2, False: 0]
  |  |  |  |  |  Branch (108:44): [True: 0, False: 2]
  |  |  |  |  ------------------
  |  |  |  |  109|      2|				 ((c) == 0xd) || \
  |  |  |  |  ------------------
  |  |  |  |  |  Branch (109:6): [True: 0, False: 2]
  |  |  |  |  ------------------
  |  |  |  |  110|      2|				  (0x20 <= (c)))
  |  |  |  |  ------------------
  |  |  |  |  |  Branch (110:7): [True: 2, False: 0]
  |  |  |  |  ------------------
  |  |  ------------------
  ------------------
                  if ((!IS_BYTE_CHAR(RAW)) || (RAW != '>')) {
  ------------------
  |  | 2221|      2|#define RAW (*ctxt->input->cur)
  ------------------
  |  Branch (8871:33): [True: 0, False: 2]
  ------------------
 8872|      0|	xmlFatalErr(ctxt, XML_ERR_GT_REQUIRED, NULL);
 8873|      0|    } else
 8874|      2|	NEXT1;
  ------------------
  |  | 2277|      2|#define NEXT1 {								\
  |  | 2278|      2|	ctxt->input->col++;						\
  |  | 2279|      2|	ctxt->input->cur++;						\
  |  | 2280|      2|	if (*ctxt->input->cur == 0)					\
  |  |  ------------------
  |  |  |  Branch (2280:6): [True: 0, False: 2]
  |  |  ------------------
  |  | 2281|      2|	    xmlParserGrow(ctxt);						\
  |  | 2282|      2|    }
  ------------------
 8875|       |
 8876|       |    /*
 8877|       |     * [ WFC: Element Type Match ]
 8878|       |     * The Name in an element's end-tag must match the element type in the
 8879|       |     * start-tag.
 8880|       |     *
 8881|       |     */
 8882|      2|    if (name != (xmlChar*)1) {
  ------------------
  |  Branch (8882:9): [True: 0, False: 2]
  ------------------
 8883|      0|        if (name == NULL) name = BAD_CAST "unparsable";
  ------------------
  |  |   35|      0|#define BAD_CAST (xmlChar *)
  ------------------
  |  Branch (8883:13): [True: 0, False: 0]
  ------------------
 8884|      0|        xmlFatalErrMsgStrIntStr(ctxt, XML_ERR_TAG_NAME_MISMATCH,
 8885|      0|		     "Opening and ending tag mismatch: %s line %d and %s\n",
 8886|      0|		                ctxt->name, line, name);
 8887|      0|    }
 8888|       |
 8889|       |    /*
 8890|       |     * SAX: End of Tag
 8891|       |     */
 8892|      2|    if ((ctxt->sax != NULL) && (ctxt->sax->endElement != NULL) &&
  ------------------
  |  Branch (8892:9): [True: 2, False: 0]
  |  Branch (8892:32): [True: 2, False: 0]
  ------------------
 8893|      2|	(!ctxt->disableSAX))
  ------------------
  |  Branch (8893:2): [True: 2, False: 0]
  ------------------
 8894|      2|        ctxt->sax->endElement(ctxt->userData, ctxt->name);
 8895|       |
 8896|      2|    namePop(ctxt);
 8897|      2|    spacePop(ctxt);
 8898|      2|    return;
 8899|      2|}
parser.c:xmlParseNameAndCompare:
 3682|  1.05k|xmlParseNameAndCompare(xmlParserCtxtPtr ctxt, xmlChar const *other) {
 3683|  1.05k|    register const xmlChar *cmp = other;
 3684|  1.05k|    register const xmlChar *in;
 3685|  1.05k|    const xmlChar *ret;
 3686|       |
 3687|  1.05k|    GROW;
  ------------------
  |  | 2270|  1.05k|#define GROW if (ctxt->input->end - ctxt->input->cur < INPUT_CHUNK)	\
  |  |  ------------------
  |  |  |  |   97|  1.05k|#define INPUT_CHUNK	250
  |  |  ------------------
  |  |  |  Branch (2270:18): [True: 506, False: 552]
  |  |  ------------------
  |  | 2271|  1.05k|	xmlParserGrow(ctxt);
  ------------------
 3688|  1.05k|    if (ctxt->instate == XML_PARSER_EOF)
  ------------------
  |  Branch (3688:9): [True: 0, False: 1.05k]
  ------------------
 3689|      0|        return(NULL);
 3690|       |
 3691|  1.05k|    in = ctxt->input->cur;
 3692|  3.74k|    while (*in != 0 && *in == *cmp) {
  ------------------
  |  Branch (3692:12): [True: 3.73k, False: 4]
  |  Branch (3692:24): [True: 2.68k, False: 1.05k]
  ------------------
 3693|  2.68k|	++in;
 3694|  2.68k|	++cmp;
 3695|  2.68k|    }
 3696|  1.05k|    if (*cmp == 0 && (*in == '>' || IS_BLANK_CH (*in))) {
  ------------------
  |  |  151|      5|#define IS_BLANK_CH(c)  xmlIsBlank_ch(c)
  |  |  ------------------
  |  |  |  |   88|      5|#define xmlIsBlank_ch(c)	(((c) == 0x20) || \
  |  |  |  |  ------------------
  |  |  |  |  |  Branch (88:27): [True: 0, False: 5]
  |  |  |  |  ------------------
  |  |  |  |   89|      5|				 ((0x9 <= (c)) && ((c) <= 0xa)) || \
  |  |  |  |  ------------------
  |  |  |  |  |  Branch (89:7): [True: 1, False: 4]
  |  |  |  |  |  Branch (89:23): [True: 0, False: 1]
  |  |  |  |  ------------------
  |  |  |  |   90|      5|				 ((c) == 0xd))
  |  |  |  |  ------------------
  |  |  |  |  |  Branch (90:6): [True: 0, False: 5]
  |  |  |  |  ------------------
  |  |  ------------------
  ------------------
  |  Branch (3696:9): [True: 1.01k, False: 44]
  |  Branch (3696:23): [True: 1.00k, False: 5]
  ------------------
 3697|       |	/* success */
 3698|  1.00k|	ctxt->input->col += in - ctxt->input->cur;
 3699|  1.00k|	ctxt->input->cur = in;
 3700|  1.00k|	return (const xmlChar*) 1;
 3701|  1.00k|    }
 3702|       |    /* failure (or end of input buffer), check with full function */
 3703|     49|    ret = xmlParseName (ctxt);
 3704|       |    /* strings coming from the dictionary direct compare possible */
 3705|     49|    if (ret == other) {
  ------------------
  |  Branch (3705:9): [True: 4, False: 45]
  ------------------
 3706|      4|	return (const xmlChar*) 1;
 3707|      4|    }
 3708|     45|    return ret;
 3709|     49|}
parser.c:spacePop:
 2173|  2.52k|static int spacePop(xmlParserCtxtPtr ctxt) {
 2174|  2.52k|    int ret;
 2175|  2.52k|    if (ctxt->spaceNr <= 0) return(0);
  ------------------
  |  Branch (2175:9): [True: 0, False: 2.52k]
  ------------------
 2176|  2.52k|    ctxt->spaceNr--;
 2177|  2.52k|    if (ctxt->spaceNr > 0)
  ------------------
  |  Branch (2177:9): [True: 2.52k, False: 0]
  ------------------
 2178|  2.52k|	ctxt->space = &ctxt->spaceTab[ctxt->spaceNr - 1];
 2179|      0|    else
 2180|      0|        ctxt->space = &ctxt->spaceTab[0];
 2181|  2.52k|    ret = ctxt->spaceTab[ctxt->spaceNr];
 2182|  2.52k|    ctxt->spaceTab[ctxt->spaceNr] = -1;
 2183|  2.52k|    return(ret);
 2184|  2.52k|}
parser.c:xmlParseAttValueInternal:
 9115|  1.48k|{
 9116|  1.48k|    xmlChar limit = 0;
 9117|  1.48k|    const xmlChar *in = NULL, *start, *end, *last;
 9118|  1.48k|    xmlChar *ret = NULL;
 9119|  1.48k|    int line, col;
 9120|  1.48k|    int maxLength = (ctxt->options & XML_PARSE_HUGE) ?
  ------------------
  |  Branch (9120:21): [True: 4, False: 1.48k]
  ------------------
 9121|      4|                    XML_MAX_HUGE_LENGTH :
  ------------------
  |  |   49|      4|#define XML_MAX_HUGE_LENGTH 1000000000
  ------------------
 9122|  1.48k|                    XML_MAX_TEXT_LENGTH;
  ------------------
  |  |   42|  1.48k|#define XML_MAX_TEXT_LENGTH 10000000
  ------------------
 9123|       |
 9124|  1.48k|    GROW;
  ------------------
  |  | 2270|  1.48k|#define GROW if (ctxt->input->end - ctxt->input->cur < INPUT_CHUNK)	\
  |  |  ------------------
  |  |  |  |   97|  1.48k|#define INPUT_CHUNK	250
  |  |  ------------------
  |  |  |  Branch (2270:18): [True: 758, False: 731]
  |  |  ------------------
  |  | 2271|  1.48k|	xmlParserGrow(ctxt);
  ------------------
 9125|  1.48k|    in = (xmlChar *) CUR_PTR;
  ------------------
  |  | 2224|  1.48k|#define CUR_PTR ctxt->input->cur
  ------------------
 9126|  1.48k|    line = ctxt->input->line;
 9127|  1.48k|    col = ctxt->input->col;
 9128|  1.48k|    if (*in != '"' && *in != '\'') {
  ------------------
  |  Branch (9128:9): [True: 9, False: 1.48k]
  |  Branch (9128:23): [True: 9, False: 0]
  ------------------
 9129|      9|        xmlFatalErr(ctxt, XML_ERR_ATTRIBUTE_NOT_STARTED, NULL);
 9130|      9|        return (NULL);
 9131|      9|    }
 9132|  1.48k|    ctxt->instate = XML_PARSER_ATTRIBUTE_VALUE;
 9133|       |
 9134|       |    /*
 9135|       |     * try to handle in this routine the most common case where no
 9136|       |     * allocation of a new string is required and where content is
 9137|       |     * pure ASCII.
 9138|       |     */
 9139|  1.48k|    limit = *in++;
 9140|  1.48k|    col++;
 9141|  1.48k|    end = ctxt->input->end;
 9142|  1.48k|    start = in;
 9143|  1.48k|    if (in >= end) {
  ------------------
  |  Branch (9143:9): [True: 0, False: 1.48k]
  ------------------
 9144|      0|        GROW_PARSE_ATT_VALUE_INTERNAL(ctxt, in, start, end)
  ------------------
  |  | 9101|      0|    const xmlChar *oldbase = ctxt->input->base;\
  |  | 9102|      0|    GROW;\
  |  |  ------------------
  |  |  |  | 2270|      0|#define GROW if (ctxt->input->end - ctxt->input->cur < INPUT_CHUNK)	\
  |  |  |  |  ------------------
  |  |  |  |  |  |   97|      0|#define INPUT_CHUNK	250
  |  |  |  |  ------------------
  |  |  |  |  |  Branch (2270:18): [True: 0, False: 0]
  |  |  |  |  ------------------
  |  |  |  | 2271|      0|	xmlParserGrow(ctxt);
  |  |  ------------------
  |  | 9103|      0|    if (ctxt->instate == XML_PARSER_EOF)\
  |  |  ------------------
  |  |  |  Branch (9103:9): [True: 0, False: 0]
  |  |  ------------------
  |  | 9104|      0|        return(NULL);\
  |  | 9105|      0|    if (oldbase != ctxt->input->base) {\
  |  |  ------------------
  |  |  |  Branch (9105:9): [True: 0, False: 0]
  |  |  ------------------
  |  | 9106|      0|        ptrdiff_t delta = ctxt->input->base - oldbase;\
  |  | 9107|      0|        start = start + delta;\
  |  | 9108|      0|        in = in + delta;\
  |  | 9109|      0|    }\
  |  | 9110|      0|    end = ctxt->input->end;
  ------------------
 9145|      0|    }
 9146|  1.48k|    if (normalize) {
  ------------------
  |  Branch (9146:9): [True: 18, False: 1.46k]
  ------------------
 9147|       |        /*
 9148|       |	 * Skip any leading spaces
 9149|       |	 */
 9150|     18|	while ((in < end) && (*in != limit) &&
  ------------------
  |  Branch (9150:9): [True: 18, False: 0]
  |  Branch (9150:23): [True: 18, False: 0]
  ------------------
 9151|     18|	       ((*in == 0x20) || (*in == 0x9) ||
  ------------------
  |  Branch (9151:10): [True: 0, False: 18]
  |  Branch (9151:27): [True: 0, False: 18]
  ------------------
 9152|     18|	        (*in == 0xA) || (*in == 0xD))) {
  ------------------
  |  Branch (9152:10): [True: 0, False: 18]
  |  Branch (9152:26): [True: 0, False: 18]
  ------------------
 9153|      0|	    if (*in == 0xA) {
  ------------------
  |  Branch (9153:10): [True: 0, False: 0]
  ------------------
 9154|      0|	        line++; col = 1;
 9155|      0|	    } else {
 9156|      0|	        col++;
 9157|      0|	    }
 9158|      0|	    in++;
 9159|      0|	    start = in;
 9160|      0|	    if (in >= end) {
  ------------------
  |  Branch (9160:10): [True: 0, False: 0]
  ------------------
 9161|      0|                GROW_PARSE_ATT_VALUE_INTERNAL(ctxt, in, start, end)
  ------------------
  |  | 9101|      0|    const xmlChar *oldbase = ctxt->input->base;\
  |  | 9102|      0|    GROW;\
  |  |  ------------------
  |  |  |  | 2270|      0|#define GROW if (ctxt->input->end - ctxt->input->cur < INPUT_CHUNK)	\
  |  |  |  |  ------------------
  |  |  |  |  |  |   97|      0|#define INPUT_CHUNK	250
  |  |  |  |  ------------------
  |  |  |  |  |  Branch (2270:18): [True: 0, False: 0]
  |  |  |  |  ------------------
  |  |  |  | 2271|      0|	xmlParserGrow(ctxt);
  |  |  ------------------
  |  | 9103|      0|    if (ctxt->instate == XML_PARSER_EOF)\
  |  |  ------------------
  |  |  |  Branch (9103:9): [True: 0, False: 0]
  |  |  ------------------
  |  | 9104|      0|        return(NULL);\
  |  | 9105|      0|    if (oldbase != ctxt->input->base) {\
  |  |  ------------------
  |  |  |  Branch (9105:9): [True: 0, False: 0]
  |  |  ------------------
  |  | 9106|      0|        ptrdiff_t delta = ctxt->input->base - oldbase;\
  |  | 9107|      0|        start = start + delta;\
  |  | 9108|      0|        in = in + delta;\
  |  | 9109|      0|    }\
  |  | 9110|      0|    end = ctxt->input->end;
  ------------------
 9162|      0|                if ((in - start) > maxLength) {
  ------------------
  |  Branch (9162:21): [True: 0, False: 0]
  ------------------
 9163|      0|                    xmlFatalErrMsg(ctxt, XML_ERR_ATTRIBUTE_NOT_FINISHED,
 9164|      0|                                   "AttValue length too long\n");
 9165|      0|                    return(NULL);
 9166|      0|                }
 9167|      0|	    }
 9168|      0|	}
 9169|     78|	while ((in < end) && (*in != limit) && (*in >= 0x20) &&
  ------------------
  |  Branch (9169:9): [True: 78, False: 0]
  |  Branch (9169:23): [True: 60, False: 18]
  |  Branch (9169:41): [True: 60, False: 0]
  ------------------
 9170|     78|	       (*in <= 0x7f) && (*in != '&') && (*in != '<')) {
  ------------------
  |  Branch (9170:9): [True: 60, False: 0]
  |  Branch (9170:26): [True: 60, False: 0]
  |  Branch (9170:42): [True: 60, False: 0]
  ------------------
 9171|     60|	    col++;
 9172|     60|	    if ((*in++ == 0x20) && (*in == 0x20)) break;
  ------------------
  |  Branch (9172:10): [True: 0, False: 60]
  |  Branch (9172:29): [True: 0, False: 0]
  ------------------
 9173|     60|	    if (in >= end) {
  ------------------
  |  Branch (9173:10): [True: 0, False: 60]
  ------------------
 9174|      0|                GROW_PARSE_ATT_VALUE_INTERNAL(ctxt, in, start, end)
  ------------------
  |  | 9101|      0|    const xmlChar *oldbase = ctxt->input->base;\
  |  | 9102|      0|    GROW;\
  |  |  ------------------
  |  |  |  | 2270|      0|#define GROW if (ctxt->input->end - ctxt->input->cur < INPUT_CHUNK)	\
  |  |  |  |  ------------------
  |  |  |  |  |  |   97|      0|#define INPUT_CHUNK	250
  |  |  |  |  ------------------
  |  |  |  |  |  Branch (2270:18): [True: 0, False: 0]
  |  |  |  |  ------------------
  |  |  |  | 2271|      0|	xmlParserGrow(ctxt);
  |  |  ------------------
  |  | 9103|      0|    if (ctxt->instate == XML_PARSER_EOF)\
  |  |  ------------------
  |  |  |  Branch (9103:9): [True: 0, False: 0]
  |  |  ------------------
  |  | 9104|      0|        return(NULL);\
  |  | 9105|      0|    if (oldbase != ctxt->input->base) {\
  |  |  ------------------
  |  |  |  Branch (9105:9): [True: 0, False: 0]
  |  |  ------------------
  |  | 9106|      0|        ptrdiff_t delta = ctxt->input->base - oldbase;\
  |  | 9107|      0|        start = start + delta;\
  |  | 9108|      0|        in = in + delta;\
  |  | 9109|      0|    }\
  |  | 9110|      0|    end = ctxt->input->end;
  ------------------
 9175|      0|                if ((in - start) > maxLength) {
  ------------------
  |  Branch (9175:21): [True: 0, False: 0]
  ------------------
 9176|      0|                    xmlFatalErrMsg(ctxt, XML_ERR_ATTRIBUTE_NOT_FINISHED,
 9177|      0|                                   "AttValue length too long\n");
 9178|      0|                    return(NULL);
 9179|      0|                }
 9180|      0|	    }
 9181|     60|	}
 9182|     18|	last = in;
 9183|       |	/*
 9184|       |	 * skip the trailing blanks
 9185|       |	 */
 9186|     18|	while ((last[-1] == 0x20) && (last > start)) last--;
  ------------------
  |  Branch (9186:9): [True: 0, False: 18]
  |  Branch (9186:31): [True: 0, False: 0]
  ------------------
 9187|     18|	while ((in < end) && (*in != limit) &&
  ------------------
  |  Branch (9187:9): [True: 18, False: 0]
  |  Branch (9187:23): [True: 0, False: 18]
  ------------------
 9188|     18|	       ((*in == 0x20) || (*in == 0x9) ||
  ------------------
  |  Branch (9188:10): [True: 0, False: 0]
  |  Branch (9188:27): [True: 0, False: 0]
  ------------------
 9189|      0|	        (*in == 0xA) || (*in == 0xD))) {
  ------------------
  |  Branch (9189:10): [True: 0, False: 0]
  |  Branch (9189:26): [True: 0, False: 0]
  ------------------
 9190|      0|	    if (*in == 0xA) {
  ------------------
  |  Branch (9190:10): [True: 0, False: 0]
  ------------------
 9191|      0|	        line++, col = 1;
 9192|      0|	    } else {
 9193|      0|	        col++;
 9194|      0|	    }
 9195|      0|	    in++;
 9196|      0|	    if (in >= end) {
  ------------------
  |  Branch (9196:10): [True: 0, False: 0]
  ------------------
 9197|      0|		const xmlChar *oldbase = ctxt->input->base;
 9198|      0|		GROW;
  ------------------
  |  | 2270|      0|#define GROW if (ctxt->input->end - ctxt->input->cur < INPUT_CHUNK)	\
  |  |  ------------------
  |  |  |  |   97|      0|#define INPUT_CHUNK	250
  |  |  ------------------
  |  |  |  Branch (2270:18): [True: 0, False: 0]
  |  |  ------------------
  |  | 2271|      0|	xmlParserGrow(ctxt);
  ------------------
 9199|      0|                if (ctxt->instate == XML_PARSER_EOF)
  ------------------
  |  Branch (9199:21): [True: 0, False: 0]
  ------------------
 9200|      0|                    return(NULL);
 9201|      0|		if (oldbase != ctxt->input->base) {
  ------------------
  |  Branch (9201:7): [True: 0, False: 0]
  ------------------
 9202|      0|		    ptrdiff_t delta = ctxt->input->base - oldbase;
 9203|      0|		    start = start + delta;
 9204|      0|		    in = in + delta;
 9205|      0|		    last = last + delta;
 9206|      0|		}
 9207|      0|		end = ctxt->input->end;
 9208|      0|                if ((in - start) > maxLength) {
  ------------------
  |  Branch (9208:21): [True: 0, False: 0]
  ------------------
 9209|      0|                    xmlFatalErrMsg(ctxt, XML_ERR_ATTRIBUTE_NOT_FINISHED,
 9210|      0|                                   "AttValue length too long\n");
 9211|      0|                    return(NULL);
 9212|      0|                }
 9213|      0|	    }
 9214|      0|	}
 9215|     18|        if ((in - start) > maxLength) {
  ------------------
  |  Branch (9215:13): [True: 0, False: 18]
  ------------------
 9216|      0|            xmlFatalErrMsg(ctxt, XML_ERR_ATTRIBUTE_NOT_FINISHED,
 9217|      0|                           "AttValue length too long\n");
 9218|      0|            return(NULL);
 9219|      0|        }
 9220|     18|	if (*in != limit) goto need_complex;
  ------------------
  |  Branch (9220:6): [True: 0, False: 18]
  ------------------
 9221|  1.46k|    } else {
 9222|  25.6k|	while ((in < end) && (*in != limit) && (*in >= 0x20) &&
  ------------------
  |  Branch (9222:9): [True: 25.6k, False: 0]
  |  Branch (9222:23): [True: 24.2k, False: 1.41k]
  |  Branch (9222:41): [True: 24.2k, False: 13]
  ------------------
 9223|  25.6k|	       (*in <= 0x7f) && (*in != '&') && (*in != '<')) {
  ------------------
  |  Branch (9223:9): [True: 24.2k, False: 19]
  |  Branch (9223:26): [True: 24.2k, False: 0]
  |  Branch (9223:42): [True: 24.2k, False: 15]
  ------------------
 9224|  24.2k|	    in++;
 9225|  24.2k|	    col++;
 9226|  24.2k|	    if (in >= end) {
  ------------------
  |  Branch (9226:10): [True: 0, False: 24.2k]
  ------------------
 9227|      0|                GROW_PARSE_ATT_VALUE_INTERNAL(ctxt, in, start, end)
  ------------------
  |  | 9101|      0|    const xmlChar *oldbase = ctxt->input->base;\
  |  | 9102|      0|    GROW;\
  |  |  ------------------
  |  |  |  | 2270|      0|#define GROW if (ctxt->input->end - ctxt->input->cur < INPUT_CHUNK)	\
  |  |  |  |  ------------------
  |  |  |  |  |  |   97|      0|#define INPUT_CHUNK	250
  |  |  |  |  ------------------
  |  |  |  |  |  Branch (2270:18): [True: 0, False: 0]
  |  |  |  |  ------------------
  |  |  |  | 2271|      0|	xmlParserGrow(ctxt);
  |  |  ------------------
  |  | 9103|      0|    if (ctxt->instate == XML_PARSER_EOF)\
  |  |  ------------------
  |  |  |  Branch (9103:9): [True: 0, False: 0]
  |  |  ------------------
  |  | 9104|      0|        return(NULL);\
  |  | 9105|      0|    if (oldbase != ctxt->input->base) {\
  |  |  ------------------
  |  |  |  Branch (9105:9): [True: 0, False: 0]
  |  |  ------------------
  |  | 9106|      0|        ptrdiff_t delta = ctxt->input->base - oldbase;\
  |  | 9107|      0|        start = start + delta;\
  |  | 9108|      0|        in = in + delta;\
  |  | 9109|      0|    }\
  |  | 9110|      0|    end = ctxt->input->end;
  ------------------
 9228|      0|                if ((in - start) > maxLength) {
  ------------------
  |  Branch (9228:21): [True: 0, False: 0]
  ------------------
 9229|      0|                    xmlFatalErrMsg(ctxt, XML_ERR_ATTRIBUTE_NOT_FINISHED,
 9230|      0|                                   "AttValue length too long\n");
 9231|      0|                    return(NULL);
 9232|      0|                }
 9233|      0|	    }
 9234|  24.2k|	}
 9235|  1.46k|	last = in;
 9236|  1.46k|        if ((in - start) > maxLength) {
  ------------------
  |  Branch (9236:13): [True: 0, False: 1.46k]
  ------------------
 9237|      0|            xmlFatalErrMsg(ctxt, XML_ERR_ATTRIBUTE_NOT_FINISHED,
 9238|      0|                           "AttValue length too long\n");
 9239|      0|            return(NULL);
 9240|      0|        }
 9241|  1.46k|	if (*in != limit) goto need_complex;
  ------------------
  |  Branch (9241:6): [True: 47, False: 1.41k]
  ------------------
 9242|  1.46k|    }
 9243|  1.43k|    in++;
 9244|  1.43k|    col++;
 9245|  1.43k|    if (len != NULL) {
  ------------------
  |  Branch (9245:9): [True: 1.42k, False: 4]
  ------------------
 9246|  1.42k|        if (alloc) *alloc = 0;
  ------------------
  |  Branch (9246:13): [True: 1.42k, False: 0]
  ------------------
 9247|  1.42k|        *len = last - start;
 9248|  1.42k|        ret = (xmlChar *) start;
 9249|  1.42k|    } else {
 9250|      4|        if (alloc) *alloc = 1;
  ------------------
  |  Branch (9250:13): [True: 0, False: 4]
  ------------------
 9251|      4|        ret = xmlStrndup(start, last - start);
 9252|      4|    }
 9253|  1.43k|    CUR_PTR = in;
  ------------------
  |  | 2224|  1.43k|#define CUR_PTR ctxt->input->cur
  ------------------
 9254|  1.43k|    ctxt->input->line = line;
 9255|  1.43k|    ctxt->input->col = col;
 9256|  1.43k|    return ret;
 9257|     47|need_complex:
 9258|     47|    if (alloc) *alloc = 1;
  ------------------
  |  Branch (9258:9): [True: 47, False: 0]
  ------------------
 9259|     47|    return xmlParseAttValueComplex(ctxt, len, normalize);
 9260|  1.48k|}
parser.c:xmlParseAttValueComplex:
 4056|     47|xmlParseAttValueComplex(xmlParserCtxtPtr ctxt, int *attlen, int normalize) {
 4057|     47|    xmlChar limit = 0;
 4058|     47|    xmlChar *buf = NULL;
 4059|     47|    xmlChar *rep = NULL;
 4060|     47|    size_t len = 0;
 4061|     47|    size_t buf_size = 0;
 4062|     47|    size_t maxLength = (ctxt->options & XML_PARSE_HUGE) ?
  ------------------
  |  Branch (4062:24): [True: 0, False: 47]
  ------------------
 4063|      0|                       XML_MAX_HUGE_LENGTH :
  ------------------
  |  |   49|      0|#define XML_MAX_HUGE_LENGTH 1000000000
  ------------------
 4064|     47|                       XML_MAX_TEXT_LENGTH;
  ------------------
  |  |   42|     94|#define XML_MAX_TEXT_LENGTH 10000000
  ------------------
 4065|     47|    int c, l, in_space = 0;
 4066|     47|    xmlChar *current = NULL;
 4067|     47|    xmlEntityPtr ent;
 4068|       |
 4069|     47|    if (NXT(0) == '"') {
  ------------------
  |  | 2223|     47|#define NXT(val) ctxt->input->cur[(val)]
  ------------------
  |  Branch (4069:9): [True: 47, False: 0]
  ------------------
 4070|     47|	ctxt->instate = XML_PARSER_ATTRIBUTE_VALUE;
 4071|     47|	limit = '"';
 4072|     47|        NEXT;
  ------------------
  |  | 2275|     47|#define NEXT xmlNextChar(ctxt)
  ------------------
 4073|     47|    } else if (NXT(0) == '\'') {
  ------------------
  |  | 2223|      0|#define NXT(val) ctxt->input->cur[(val)]
  ------------------
  |  Branch (4073:16): [True: 0, False: 0]
  ------------------
 4074|      0|	limit = '\'';
 4075|      0|	ctxt->instate = XML_PARSER_ATTRIBUTE_VALUE;
 4076|      0|        NEXT;
  ------------------
  |  | 2275|      0|#define NEXT xmlNextChar(ctxt)
  ------------------
 4077|      0|    } else {
 4078|      0|	xmlFatalErr(ctxt, XML_ERR_ATTRIBUTE_NOT_STARTED, NULL);
 4079|      0|	return(NULL);
 4080|      0|    }
 4081|       |
 4082|       |    /*
 4083|       |     * allocate a translation buffer.
 4084|       |     */
 4085|     47|    buf_size = XML_PARSER_BUFFER_SIZE;
  ------------------
  |  |  167|     47|#define XML_PARSER_BUFFER_SIZE 100
  ------------------
 4086|     47|    buf = (xmlChar *) xmlMallocAtomic(buf_size);
 4087|     47|    if (buf == NULL) goto mem_error;
  ------------------
  |  Branch (4087:9): [True: 0, False: 47]
  ------------------
 4088|       |
 4089|       |    /*
 4090|       |     * OK loop until we reach one of the ending char or a size limit.
 4091|       |     */
 4092|     47|    c = CUR_CHAR(l);
  ------------------
  |  | 2291|     47|#define CUR_CHAR(l) xmlCurrentChar(ctxt, &l)
  ------------------
 4093|  1.05k|    while (((NXT(0) != limit) && /* checked */
  ------------------
  |  | 2223|  1.05k|#define NXT(val) ctxt->input->cur[(val)]
  ------------------
  |  Branch (4093:13): [True: 1.04k, False: 17]
  ------------------
 4094|  1.05k|            (IS_CHAR(c)) && (c != '<')) &&
  ------------------
  |  |  125|  1.04k|#define IS_CHAR(c)   xmlIsCharQ(c)
  |  |  ------------------
  |  |  |  |  118|  1.04k|#define xmlIsCharQ(c)		(((c) < 0x100) ? \
  |  |  |  |  ------------------
  |  |  |  |  |  Branch (118:25): [True: 878, False: 163]
  |  |  |  |  ------------------
  |  |  |  |  119|  1.04k|				 xmlIsChar_ch((c)) :\
  |  |  |  |  ------------------
  |  |  |  |  |  |  108|    878|#define xmlIsChar_ch(c)		(((0x9 <= (c)) && ((c) <= 0xa)) || \
  |  |  |  |  |  |  ------------------
  |  |  |  |  |  |  |  Branch (108:28): [True: 876, False: 2]
  |  |  |  |  |  |  |  Branch (108:44): [True: 3, False: 873]
  |  |  |  |  |  |  ------------------
  |  |  |  |  |  |  109|    878|				 ((c) == 0xd) || \
  |  |  |  |  |  |  ------------------
  |  |  |  |  |  |  |  Branch (109:6): [True: 0, False: 875]
  |  |  |  |  |  |  ------------------
  |  |  |  |  |  |  110|    878|				  (0x20 <= (c)))
  |  |  |  |  |  |  ------------------
  |  |  |  |  |  |  |  Branch (110:7): [True: 863, False: 12]
  |  |  |  |  |  |  ------------------
  |  |  |  |  ------------------
  |  |  |  |  120|  1.04k|				(((0x100 <= (c)) && ((c) <= 0xd7ff)) || \
  |  |  |  |  ------------------
  |  |  |  |  |  Branch (120:7): [True: 163, False: 0]
  |  |  |  |  |  Branch (120:25): [True: 0, False: 163]
  |  |  |  |  ------------------
  |  |  |  |  121|    163|				 ((0xe000 <= (c)) && ((c) <= 0xfffd)) || \
  |  |  |  |  ------------------
  |  |  |  |  |  Branch (121:7): [True: 163, False: 0]
  |  |  |  |  |  Branch (121:26): [True: 163, False: 0]
  |  |  |  |  ------------------
  |  |  |  |  122|    163|				 ((0x10000 <= (c)) && ((c) <= 0x10ffff))))
  |  |  |  |  ------------------
  |  |  |  |  |  Branch (122:7): [True: 0, False: 0]
  |  |  |  |  |  Branch (122:27): [True: 0, False: 0]
  |  |  |  |  ------------------
  |  |  ------------------
  ------------------
  |  Branch (4094:13): [True: 1.02k, False: 12]
  |  Branch (4094:29): [True: 1.01k, False: 18]
  ------------------
 4095|  1.05k|            (ctxt->instate != XML_PARSER_EOF)) {
  ------------------
  |  Branch (4095:13): [True: 1.01k, False: 0]
  ------------------
 4096|  1.01k|	if (c == '&') {
  ------------------
  |  Branch (4096:6): [True: 0, False: 1.01k]
  ------------------
 4097|      0|	    in_space = 0;
 4098|      0|	    if (NXT(1) == '#') {
  ------------------
  |  | 2223|      0|#define NXT(val) ctxt->input->cur[(val)]
  ------------------
  |  Branch (4098:10): [True: 0, False: 0]
  ------------------
 4099|      0|		int val = xmlParseCharRef(ctxt);
 4100|       |
 4101|      0|		if (val == '&') {
  ------------------
  |  Branch (4101:7): [True: 0, False: 0]
  ------------------
 4102|      0|		    if (ctxt->replaceEntities) {
  ------------------
  |  Branch (4102:11): [True: 0, False: 0]
  ------------------
 4103|      0|			if (len + 10 > buf_size) {
  ------------------
  |  Branch (4103:8): [True: 0, False: 0]
  ------------------
 4104|      0|			    growBuffer(buf, 10);
  ------------------
  |  | 2774|      0|#define growBuffer(buffer, n) {						\
  |  | 2775|      0|    xmlChar *tmp;							\
  |  | 2776|      0|    size_t new_size = buffer##_size * 2 + n;                            \
  |  | 2777|      0|    if (new_size < buffer##_size) goto mem_error;                       \
  |  |  ------------------
  |  |  |  Branch (2777:9): [True: 0, False: 0]
  |  |  ------------------
  |  | 2778|      0|    tmp = (xmlChar *) xmlRealloc(buffer, new_size);                     \
  |  | 2779|      0|    if (tmp == NULL) goto mem_error;					\
  |  |  ------------------
  |  |  |  Branch (2779:9): [True: 0, False: 0]
  |  |  ------------------
  |  | 2780|      0|    buffer = tmp;							\
  |  | 2781|      0|    buffer##_size = new_size;                                           \
  |  | 2782|      0|}
  ------------------
 4105|      0|			}
 4106|      0|			buf[len++] = '&';
 4107|      0|		    } else {
 4108|       |			/*
 4109|       |			 * The reparsing will be done in xmlStringGetNodeList()
 4110|       |			 * called by the attribute() function in SAX.c
 4111|       |			 */
 4112|      0|			if (len + 10 > buf_size) {
  ------------------
  |  Branch (4112:8): [True: 0, False: 0]
  ------------------
 4113|      0|			    growBuffer(buf, 10);
  ------------------
  |  | 2774|      0|#define growBuffer(buffer, n) {						\
  |  | 2775|      0|    xmlChar *tmp;							\
  |  | 2776|      0|    size_t new_size = buffer##_size * 2 + n;                            \
  |  | 2777|      0|    if (new_size < buffer##_size) goto mem_error;                       \
  |  |  ------------------
  |  |  |  Branch (2777:9): [True: 0, False: 0]
  |  |  ------------------
  |  | 2778|      0|    tmp = (xmlChar *) xmlRealloc(buffer, new_size);                     \
  |  | 2779|      0|    if (tmp == NULL) goto mem_error;					\
  |  |  ------------------
  |  |  |  Branch (2779:9): [True: 0, False: 0]
  |  |  ------------------
  |  | 2780|      0|    buffer = tmp;							\
  |  | 2781|      0|    buffer##_size = new_size;                                           \
  |  | 2782|      0|}
  ------------------
 4114|      0|			}
 4115|      0|			buf[len++] = '&';
 4116|      0|			buf[len++] = '#';
 4117|      0|			buf[len++] = '3';
 4118|      0|			buf[len++] = '8';
 4119|      0|			buf[len++] = ';';
 4120|      0|		    }
 4121|      0|		} else if (val != 0) {
  ------------------
  |  Branch (4121:14): [True: 0, False: 0]
  ------------------
 4122|      0|		    if (len + 10 > buf_size) {
  ------------------
  |  Branch (4122:11): [True: 0, False: 0]
  ------------------
 4123|      0|			growBuffer(buf, 10);
  ------------------
  |  | 2774|      0|#define growBuffer(buffer, n) {						\
  |  | 2775|      0|    xmlChar *tmp;							\
  |  | 2776|      0|    size_t new_size = buffer##_size * 2 + n;                            \
  |  | 2777|      0|    if (new_size < buffer##_size) goto mem_error;                       \
  |  |  ------------------
  |  |  |  Branch (2777:9): [True: 0, False: 0]
  |  |  ------------------
  |  | 2778|      0|    tmp = (xmlChar *) xmlRealloc(buffer, new_size);                     \
  |  | 2779|      0|    if (tmp == NULL) goto mem_error;					\
  |  |  ------------------
  |  |  |  Branch (2779:9): [True: 0, False: 0]
  |  |  ------------------
  |  | 2780|      0|    buffer = tmp;							\
  |  | 2781|      0|    buffer##_size = new_size;                                           \
  |  | 2782|      0|}
  ------------------
 4124|      0|		    }
 4125|      0|		    len += xmlCopyChar(0, &buf[len], val);
 4126|      0|		}
 4127|      0|	    } else {
 4128|      0|		ent = xmlParseEntityRef(ctxt);
 4129|      0|		if ((ent != NULL) &&
  ------------------
  |  Branch (4129:7): [True: 0, False: 0]
  ------------------
 4130|      0|		    (ent->etype == XML_INTERNAL_PREDEFINED_ENTITY)) {
  ------------------
  |  Branch (4130:7): [True: 0, False: 0]
  ------------------
 4131|      0|		    if (len + 10 > buf_size) {
  ------------------
  |  Branch (4131:11): [True: 0, False: 0]
  ------------------
 4132|      0|			growBuffer(buf, 10);
  ------------------
  |  | 2774|      0|#define growBuffer(buffer, n) {						\
  |  | 2775|      0|    xmlChar *tmp;							\
  |  | 2776|      0|    size_t new_size = buffer##_size * 2 + n;                            \
  |  | 2777|      0|    if (new_size < buffer##_size) goto mem_error;                       \
  |  |  ------------------
  |  |  |  Branch (2777:9): [True: 0, False: 0]
  |  |  ------------------
  |  | 2778|      0|    tmp = (xmlChar *) xmlRealloc(buffer, new_size);                     \
  |  | 2779|      0|    if (tmp == NULL) goto mem_error;					\
  |  |  ------------------
  |  |  |  Branch (2779:9): [True: 0, False: 0]
  |  |  ------------------
  |  | 2780|      0|    buffer = tmp;							\
  |  | 2781|      0|    buffer##_size = new_size;                                           \
  |  | 2782|      0|}
  ------------------
 4133|      0|		    }
 4134|      0|		    if ((ctxt->replaceEntities == 0) &&
  ------------------
  |  Branch (4134:11): [True: 0, False: 0]
  ------------------
 4135|      0|		        (ent->content[0] == '&')) {
  ------------------
  |  Branch (4135:11): [True: 0, False: 0]
  ------------------
 4136|      0|			buf[len++] = '&';
 4137|      0|			buf[len++] = '#';
 4138|      0|			buf[len++] = '3';
 4139|      0|			buf[len++] = '8';
 4140|      0|			buf[len++] = ';';
 4141|      0|		    } else {
 4142|      0|			buf[len++] = ent->content[0];
 4143|      0|		    }
 4144|      0|		} else if ((ent != NULL) &&
  ------------------
  |  Branch (4144:14): [True: 0, False: 0]
  ------------------
 4145|      0|		           (ctxt->replaceEntities != 0)) {
  ------------------
  |  Branch (4145:14): [True: 0, False: 0]
  ------------------
 4146|      0|		    if (ent->etype != XML_INTERNAL_PREDEFINED_ENTITY) {
  ------------------
  |  Branch (4146:11): [True: 0, False: 0]
  ------------------
 4147|      0|                        if (xmlParserEntityCheck(ctxt, ent->length))
  ------------------
  |  Branch (4147:29): [True: 0, False: 0]
  ------------------
 4148|      0|                            goto error;
 4149|       |
 4150|      0|			++ctxt->depth;
 4151|      0|			rep = xmlStringDecodeEntitiesInt(ctxt, ent->content,
 4152|      0|                                ent->length, XML_SUBSTITUTE_REF, 0, 0, 0,
  ------------------
  |  |  521|      0|#define XML_SUBSTITUTE_REF	1
  ------------------
 4153|      0|                                /* check */ 1);
 4154|      0|			--ctxt->depth;
 4155|      0|			if (rep != NULL) {
  ------------------
  |  Branch (4155:8): [True: 0, False: 0]
  ------------------
 4156|      0|			    current = rep;
 4157|      0|			    while (*current != 0) { /* non input consuming */
  ------------------
  |  Branch (4157:15): [True: 0, False: 0]
  ------------------
 4158|      0|                                if ((*current == 0xD) || (*current == 0xA) ||
  ------------------
  |  Branch (4158:37): [True: 0, False: 0]
  |  Branch (4158:58): [True: 0, False: 0]
  ------------------
 4159|      0|                                    (*current == 0x9)) {
  ------------------
  |  Branch (4159:37): [True: 0, False: 0]
  ------------------
 4160|      0|                                    buf[len++] = 0x20;
 4161|      0|                                    current++;
 4162|      0|                                } else
 4163|      0|                                    buf[len++] = *current++;
 4164|      0|				if (len + 10 > buf_size) {
  ------------------
  |  Branch (4164:9): [True: 0, False: 0]
  ------------------
 4165|      0|				    growBuffer(buf, 10);
  ------------------
  |  | 2774|      0|#define growBuffer(buffer, n) {						\
  |  | 2775|      0|    xmlChar *tmp;							\
  |  | 2776|      0|    size_t new_size = buffer##_size * 2 + n;                            \
  |  | 2777|      0|    if (new_size < buffer##_size) goto mem_error;                       \
  |  |  ------------------
  |  |  |  Branch (2777:9): [True: 0, False: 0]
  |  |  ------------------
  |  | 2778|      0|    tmp = (xmlChar *) xmlRealloc(buffer, new_size);                     \
  |  | 2779|      0|    if (tmp == NULL) goto mem_error;					\
  |  |  ------------------
  |  |  |  Branch (2779:9): [True: 0, False: 0]
  |  |  ------------------
  |  | 2780|      0|    buffer = tmp;							\
  |  | 2781|      0|    buffer##_size = new_size;                                           \
  |  | 2782|      0|}
  ------------------
 4166|      0|				}
 4167|      0|			    }
 4168|      0|			    xmlFree(rep);
 4169|      0|			    rep = NULL;
 4170|      0|			}
 4171|      0|		    } else {
 4172|      0|			if (len + 10 > buf_size) {
  ------------------
  |  Branch (4172:8): [True: 0, False: 0]
  ------------------
 4173|      0|			    growBuffer(buf, 10);
  ------------------
  |  | 2774|      0|#define growBuffer(buffer, n) {						\
  |  | 2775|      0|    xmlChar *tmp;							\
  |  | 2776|      0|    size_t new_size = buffer##_size * 2 + n;                            \
  |  | 2777|      0|    if (new_size < buffer##_size) goto mem_error;                       \
  |  |  ------------------
  |  |  |  Branch (2777:9): [True: 0, False: 0]
  |  |  ------------------
  |  | 2778|      0|    tmp = (xmlChar *) xmlRealloc(buffer, new_size);                     \
  |  | 2779|      0|    if (tmp == NULL) goto mem_error;					\
  |  |  ------------------
  |  |  |  Branch (2779:9): [True: 0, False: 0]
  |  |  ------------------
  |  | 2780|      0|    buffer = tmp;							\
  |  | 2781|      0|    buffer##_size = new_size;                                           \
  |  | 2782|      0|}
  ------------------
 4174|      0|			}
 4175|      0|			if (ent->content != NULL)
  ------------------
  |  Branch (4175:8): [True: 0, False: 0]
  ------------------
 4176|      0|			    buf[len++] = ent->content[0];
 4177|      0|		    }
 4178|      0|		} else if (ent != NULL) {
  ------------------
  |  Branch (4178:14): [True: 0, False: 0]
  ------------------
 4179|      0|		    int i = xmlStrlen(ent->name);
 4180|      0|		    const xmlChar *cur = ent->name;
 4181|       |
 4182|       |		    /*
 4183|       |                     * We also check for recursion and amplification
 4184|       |                     * when entities are not substituted. They're
 4185|       |                     * often expanded later.
 4186|       |		     */
 4187|      0|		    if ((ent->etype != XML_INTERNAL_PREDEFINED_ENTITY) &&
  ------------------
  |  Branch (4187:11): [True: 0, False: 0]
  ------------------
 4188|      0|			(ent->content != NULL)) {
  ------------------
  |  Branch (4188:4): [True: 0, False: 0]
  ------------------
 4189|      0|                        if ((ent->flags & XML_ENT_CHECKED) == 0) {
  ------------------
  |  |   15|      0|#define XML_ENT_CHECKED     (1<<1)
  ------------------
  |  Branch (4189:29): [True: 0, False: 0]
  ------------------
 4190|      0|                            unsigned long oldCopy = ctxt->sizeentcopy;
 4191|       |
 4192|      0|                            ctxt->sizeentcopy = ent->length;
 4193|       |
 4194|      0|                            ++ctxt->depth;
 4195|      0|                            rep = xmlStringDecodeEntitiesInt(ctxt,
 4196|      0|                                    ent->content, ent->length,
 4197|      0|                                    XML_SUBSTITUTE_REF, 0, 0, 0,
  ------------------
  |  |  521|      0|#define XML_SUBSTITUTE_REF	1
  ------------------
 4198|      0|                                    /* check */ 1);
 4199|      0|                            --ctxt->depth;
 4200|       |
 4201|       |                            /*
 4202|       |                             * If we're parsing DTD content, the entity
 4203|       |                             * might reference other entities which
 4204|       |                             * weren't defined yet, so the check isn't
 4205|       |                             * reliable.
 4206|       |                             */
 4207|      0|                            if (ctxt->inSubset == 0) {
  ------------------
  |  Branch (4207:33): [True: 0, False: 0]
  ------------------
 4208|      0|                                ent->flags |= XML_ENT_CHECKED;
  ------------------
  |  |   15|      0|#define XML_ENT_CHECKED     (1<<1)
  ------------------
 4209|      0|                                ent->expandedSize = ctxt->sizeentcopy;
 4210|      0|                            }
 4211|       |
 4212|      0|                            if (rep != NULL) {
  ------------------
  |  Branch (4212:33): [True: 0, False: 0]
  ------------------
 4213|      0|                                xmlFree(rep);
 4214|      0|                                rep = NULL;
 4215|      0|                            } else {
 4216|      0|                                ent->content[0] = 0;
 4217|      0|                            }
 4218|       |
 4219|      0|                            if (xmlParserEntityCheck(ctxt, oldCopy))
  ------------------
  |  Branch (4219:33): [True: 0, False: 0]
  ------------------
 4220|      0|                                goto error;
 4221|      0|                        } else {
 4222|      0|                            if (xmlParserEntityCheck(ctxt, ent->expandedSize))
  ------------------
  |  Branch (4222:33): [True: 0, False: 0]
  ------------------
 4223|      0|                                goto error;
 4224|      0|                        }
 4225|      0|		    }
 4226|       |
 4227|       |		    /*
 4228|       |		     * Just output the reference
 4229|       |		     */
 4230|      0|		    buf[len++] = '&';
 4231|      0|		    while (len + i + 10 > buf_size) {
  ------------------
  |  Branch (4231:14): [True: 0, False: 0]
  ------------------
 4232|      0|			growBuffer(buf, i + 10);
  ------------------
  |  | 2774|      0|#define growBuffer(buffer, n) {						\
  |  | 2775|      0|    xmlChar *tmp;							\
  |  | 2776|      0|    size_t new_size = buffer##_size * 2 + n;                            \
  |  | 2777|      0|    if (new_size < buffer##_size) goto mem_error;                       \
  |  |  ------------------
  |  |  |  Branch (2777:9): [True: 0, False: 0]
  |  |  ------------------
  |  | 2778|      0|    tmp = (xmlChar *) xmlRealloc(buffer, new_size);                     \
  |  | 2779|      0|    if (tmp == NULL) goto mem_error;					\
  |  |  ------------------
  |  |  |  Branch (2779:9): [True: 0, False: 0]
  |  |  ------------------
  |  | 2780|      0|    buffer = tmp;							\
  |  | 2781|      0|    buffer##_size = new_size;                                           \
  |  | 2782|      0|}
  ------------------
 4233|      0|		    }
 4234|      0|		    for (;i > 0;i--)
  ------------------
  |  Branch (4234:13): [True: 0, False: 0]
  ------------------
 4235|      0|			buf[len++] = *cur++;
 4236|      0|		    buf[len++] = ';';
 4237|      0|		}
 4238|      0|	    }
 4239|  1.01k|	} else {
 4240|  1.01k|	    if ((c == 0x20) || (c == 0xD) || (c == 0xA) || (c == 0x9)) {
  ------------------
  |  Branch (4240:10): [True: 14, False: 997]
  |  Branch (4240:25): [True: 0, False: 997]
  |  Branch (4240:39): [True: 3, False: 994]
  |  Branch (4240:53): [True: 0, False: 994]
  ------------------
 4241|     17|	        if ((len != 0) || (!normalize)) {
  ------------------
  |  Branch (4241:14): [True: 17, False: 0]
  |  Branch (4241:28): [True: 0, False: 0]
  ------------------
 4242|     17|		    if ((!normalize) || (!in_space)) {
  ------------------
  |  Branch (4242:11): [True: 17, False: 0]
  |  Branch (4242:27): [True: 0, False: 0]
  ------------------
 4243|     17|			COPY_BUF(buf, len, 0x20);
  ------------------
  |  | 2295|     17|    if (v < 0x80) b[i++] = v;						\
  |  |  ------------------
  |  |  |  Branch (2295:9): [Folded - Ignored]
  |  |  ------------------
  |  | 2296|     17|    else i += xmlCopyCharMultiByte(&b[i],v)
  ------------------
 4244|     17|			while (len + 10 > buf_size) {
  ------------------
  |  Branch (4244:11): [True: 0, False: 17]
  ------------------
 4245|      0|			    growBuffer(buf, 10);
  ------------------
  |  | 2774|      0|#define growBuffer(buffer, n) {						\
  |  | 2775|      0|    xmlChar *tmp;							\
  |  | 2776|      0|    size_t new_size = buffer##_size * 2 + n;                            \
  |  | 2777|      0|    if (new_size < buffer##_size) goto mem_error;                       \
  |  |  ------------------
  |  |  |  Branch (2777:9): [True: 0, False: 0]
  |  |  ------------------
  |  | 2778|      0|    tmp = (xmlChar *) xmlRealloc(buffer, new_size);                     \
  |  | 2779|      0|    if (tmp == NULL) goto mem_error;					\
  |  |  ------------------
  |  |  |  Branch (2779:9): [True: 0, False: 0]
  |  |  ------------------
  |  | 2780|      0|    buffer = tmp;							\
  |  | 2781|      0|    buffer##_size = new_size;                                           \
  |  | 2782|      0|}
  ------------------
 4246|      0|			}
 4247|     17|		    }
 4248|     17|		    in_space = 1;
 4249|     17|		}
 4250|    994|	    } else {
 4251|    994|	        in_space = 0;
 4252|    994|		COPY_BUF(buf, len, c);
  ------------------
  |  | 2295|    994|    if (v < 0x80) b[i++] = v;						\
  |  |  ------------------
  |  |  |  Branch (2295:9): [True: 831, False: 163]
  |  |  ------------------
  |  | 2296|    994|    else i += xmlCopyCharMultiByte(&b[i],v)
  ------------------
 4253|    994|		if (len + 10 > buf_size) {
  ------------------
  |  Branch (4253:7): [True: 0, False: 994]
  ------------------
 4254|      0|		    growBuffer(buf, 10);
  ------------------
  |  | 2774|      0|#define growBuffer(buffer, n) {						\
  |  | 2775|      0|    xmlChar *tmp;							\
  |  | 2776|      0|    size_t new_size = buffer##_size * 2 + n;                            \
  |  | 2777|      0|    if (new_size < buffer##_size) goto mem_error;                       \
  |  |  ------------------
  |  |  |  Branch (2777:9): [True: 0, False: 0]
  |  |  ------------------
  |  | 2778|      0|    tmp = (xmlChar *) xmlRealloc(buffer, new_size);                     \
  |  | 2779|      0|    if (tmp == NULL) goto mem_error;					\
  |  |  ------------------
  |  |  |  Branch (2779:9): [True: 0, False: 0]
  |  |  ------------------
  |  | 2780|      0|    buffer = tmp;							\
  |  | 2781|      0|    buffer##_size = new_size;                                           \
  |  | 2782|      0|}
  ------------------
 4255|      0|		}
 4256|    994|	    }
 4257|  1.01k|	    NEXTL(l);
  ------------------
  |  | 2284|  1.01k|#define NEXTL(l) do {							\
  |  | 2285|  1.01k|    if (*(ctxt->input->cur) == '\n') {					\
  |  |  ------------------
  |  |  |  Branch (2285:9): [True: 3, False: 1.00k]
  |  |  ------------------
  |  | 2286|      3|	ctxt->input->line++; ctxt->input->col = 1;			\
  |  | 2287|  1.00k|    } else ctxt->input->col++;						\
  |  | 2288|  1.01k|    ctxt->input->cur += l;				\
  |  | 2289|  1.01k|  } while (0)
  |  |  ------------------
  |  |  |  Branch (2289:12): [Folded - Ignored]
  |  |  ------------------
  ------------------
 4258|  1.01k|	}
 4259|  1.01k|	GROW;
  ------------------
  |  | 2270|  1.01k|#define GROW if (ctxt->input->end - ctxt->input->cur < INPUT_CHUNK)	\
  |  |  ------------------
  |  |  |  |   97|  1.01k|#define INPUT_CHUNK	250
  |  |  ------------------
  |  |  |  Branch (2270:18): [True: 949, False: 62]
  |  |  ------------------
  |  | 2271|  1.01k|	xmlParserGrow(ctxt);
  ------------------
 4260|  1.01k|	c = CUR_CHAR(l);
  ------------------
  |  | 2291|  1.01k|#define CUR_CHAR(l) xmlCurrentChar(ctxt, &l)
  ------------------
 4261|  1.01k|        if (len > maxLength) {
  ------------------
  |  Branch (4261:13): [True: 0, False: 1.01k]
  ------------------
 4262|      0|            xmlFatalErrMsg(ctxt, XML_ERR_ATTRIBUTE_NOT_FINISHED,
 4263|      0|                           "AttValue length too long\n");
 4264|      0|            goto mem_error;
 4265|      0|        }
 4266|  1.01k|    }
 4267|     47|    if (ctxt->instate == XML_PARSER_EOF)
  ------------------
  |  Branch (4267:9): [True: 0, False: 47]
  ------------------
 4268|      0|        goto error;
 4269|       |
 4270|     47|    if ((in_space) && (normalize)) {
  ------------------
  |  Branch (4270:9): [True: 6, False: 41]
  |  Branch (4270:23): [True: 0, False: 6]
  ------------------
 4271|      0|        while ((len > 0) && (buf[len - 1] == 0x20)) len--;
  ------------------
  |  Branch (4271:16): [True: 0, False: 0]
  |  Branch (4271:29): [True: 0, False: 0]
  ------------------
 4272|      0|    }
 4273|     47|    buf[len] = 0;
 4274|     47|    if (RAW == '<') {
  ------------------
  |  | 2221|     47|#define RAW (*ctxt->input->cur)
  ------------------
  |  Branch (4274:9): [True: 18, False: 29]
  ------------------
 4275|     18|	xmlFatalErr(ctxt, XML_ERR_LT_IN_ATTRIBUTE, NULL);
 4276|     29|    } else if (RAW != limit) {
  ------------------
  |  | 2221|     29|#define RAW (*ctxt->input->cur)
  ------------------
  |  Branch (4276:16): [True: 12, False: 17]
  ------------------
 4277|     12|	if ((c != 0) && (!IS_CHAR(c))) {
  ------------------
  |  |  125|     10|#define IS_CHAR(c)   xmlIsCharQ(c)
  |  |  ------------------
  |  |  |  |  118|     10|#define xmlIsCharQ(c)		(((c) < 0x100) ? \
  |  |  |  |  ------------------
  |  |  |  |  |  Branch (118:25): [True: 10, False: 0]
  |  |  |  |  ------------------
  |  |  |  |  119|     10|				 xmlIsChar_ch((c)) :\
  |  |  |  |  ------------------
  |  |  |  |  |  |  108|     10|#define xmlIsChar_ch(c)		(((0x9 <= (c)) && ((c) <= 0xa)) || \
  |  |  |  |  |  |  ------------------
  |  |  |  |  |  |  |  Branch (108:28): [True: 10, False: 0]
  |  |  |  |  |  |  |  Branch (108:44): [True: 0, False: 10]
  |  |  |  |  |  |  ------------------
  |  |  |  |  |  |  109|     10|				 ((c) == 0xd) || \
  |  |  |  |  |  |  ------------------
  |  |  |  |  |  |  |  Branch (109:6): [True: 0, False: 10]
  |  |  |  |  |  |  ------------------
  |  |  |  |  |  |  110|     10|				  (0x20 <= (c)))
  |  |  |  |  |  |  ------------------
  |  |  |  |  |  |  |  Branch (110:7): [True: 0, False: 10]
  |  |  |  |  |  |  ------------------
  |  |  |  |  ------------------
  |  |  |  |  120|     10|				(((0x100 <= (c)) && ((c) <= 0xd7ff)) || \
  |  |  |  |  ------------------
  |  |  |  |  |  Branch (120:7): [True: 0, False: 0]
  |  |  |  |  |  Branch (120:25): [True: 0, False: 0]
  |  |  |  |  ------------------
  |  |  |  |  121|      0|				 ((0xe000 <= (c)) && ((c) <= 0xfffd)) || \
  |  |  |  |  ------------------
  |  |  |  |  |  Branch (121:7): [True: 0, False: 0]
  |  |  |  |  |  Branch (121:26): [True: 0, False: 0]
  |  |  |  |  ------------------
  |  |  |  |  122|      0|				 ((0x10000 <= (c)) && ((c) <= 0x10ffff))))
  |  |  |  |  ------------------
  |  |  |  |  |  Branch (122:7): [True: 0, False: 0]
  |  |  |  |  |  Branch (122:27): [True: 0, False: 0]
  |  |  |  |  ------------------
  |  |  ------------------
  ------------------
  |  Branch (4277:6): [True: 10, False: 2]
  |  Branch (4277:18): [True: 10, False: 0]
  ------------------
 4278|     10|	    xmlFatalErrMsg(ctxt, XML_ERR_INVALID_CHAR,
 4279|     10|			   "invalid character in attribute value\n");
 4280|     10|	} else {
 4281|      2|	    xmlFatalErrMsg(ctxt, XML_ERR_ATTRIBUTE_NOT_FINISHED,
 4282|      2|			   "AttValue: ' expected\n");
 4283|      2|        }
 4284|     12|    } else
 4285|     17|	NEXT;
  ------------------
  |  | 2275|     17|#define NEXT xmlNextChar(ctxt)
  ------------------
 4286|       |
 4287|     47|    if (attlen != NULL) *attlen = len;
  ------------------
  |  Branch (4287:9): [True: 47, False: 0]
  ------------------
 4288|     47|    return(buf);
 4289|       |
 4290|      0|mem_error:
 4291|      0|    xmlErrMemory(ctxt, NULL);
 4292|      0|error:
 4293|      0|    if (buf != NULL)
  ------------------
  |  Branch (4293:9): [True: 0, False: 0]
  ------------------
 4294|      0|        xmlFree(buf);
 4295|      0|    if (rep != NULL)
  ------------------
  |  Branch (4295:9): [True: 0, False: 0]
  ------------------
 4296|      0|        xmlFree(rep);
 4297|      0|    return(NULL);
 4298|      0|}
parser.c:xmlParseContentInternal:
10210|    157|xmlParseContentInternal(xmlParserCtxtPtr ctxt) {
10211|    157|    int nameNr = ctxt->nameNr;
10212|       |
10213|    157|    GROW;
  ------------------
  |  | 2270|    157|#define GROW if (ctxt->input->end - ctxt->input->cur < INPUT_CHUNK)	\
  |  |  ------------------
  |  |  |  |   97|    157|#define INPUT_CHUNK	250
  |  |  ------------------
  |  |  |  Branch (2270:18): [True: 120, False: 37]
  |  |  ------------------
  |  | 2271|    157|	xmlParserGrow(ctxt);
  ------------------
10214|  4.52k|    while ((ctxt->input->cur < ctxt->input->end) &&
  ------------------
  |  Branch (10214:12): [True: 4.48k, False: 37]
  ------------------
10215|  4.52k|	   (ctxt->instate != XML_PARSER_EOF)) {
  ------------------
  |  Branch (10215:5): [True: 4.48k, False: 0]
  ------------------
10216|  4.48k|	const xmlChar *cur = ctxt->input->cur;
10217|       |
10218|       |	/*
10219|       |	 * First case : a Processing Instruction.
10220|       |	 */
10221|  4.48k|	if ((*cur == '<') && (cur[1] == '?')) {
  ------------------
  |  Branch (10221:6): [True: 2.29k, False: 2.19k]
  |  Branch (10221:23): [True: 0, False: 2.29k]
  ------------------
10222|      0|	    xmlParsePI(ctxt);
10223|      0|	}
10224|       |
10225|       |	/*
10226|       |	 * Second case : a CDSection
10227|       |	 */
10228|       |	/* 2.6.0 test was *cur not RAW */
10229|  4.48k|	else if (CMP9(CUR_PTR, '<', '!', '[', 'C', 'D', 'A', 'T', 'A', '[')) {
  ------------------
  |  | 2239|  4.48k|  ( CMP8( s, c1, c2, c3, c4, c5, c6, c7, c8 ) && \
  |  |  ------------------
  |  |  |  | 2237|  8.97k|  ( CMP7( s, c1, c2, c3, c4, c5, c6, c7 ) && ((unsigned char *) s)[ 7 ] == c8 )
  |  |  |  |  ------------------
  |  |  |  |  |  | 2235|  8.97k|  ( CMP6( s, c1, c2, c3, c4, c5, c6 ) && ((unsigned char *) s)[ 6 ] == c7 )
  |  |  |  |  |  |  ------------------
  |  |  |  |  |  |  |  | 2233|  8.97k|  ( CMP5( s, c1, c2, c3, c4, c5 ) && ((unsigned char *) s)[ 5 ] == c6 )
  |  |  |  |  |  |  |  |  ------------------
  |  |  |  |  |  |  |  |  |  | 2231|  8.97k|  ( CMP4( s, c1, c2, c3, c4 ) && ((unsigned char *) s)[ 4 ] == c5 )
  |  |  |  |  |  |  |  |  |  |  ------------------
  |  |  |  |  |  |  |  |  |  |  |  | 2228|  8.97k|  ( ((unsigned char *) s)[ 0 ] == c1 && ((unsigned char *) s)[ 1 ] == c2 && \
  |  |  |  |  |  |  |  |  |  |  |  |  ------------------
  |  |  |  |  |  |  |  |  |  |  |  |  |  Branch (2228:5): [True: 2.29k, False: 2.19k]
  |  |  |  |  |  |  |  |  |  |  |  |  |  Branch (2228:41): [True: 37, False: 2.25k]
  |  |  |  |  |  |  |  |  |  |  |  |  ------------------
  |  |  |  |  |  |  |  |  |  |  |  | 2229|  4.48k|    ((unsigned char *) s)[ 2 ] == c3 && ((unsigned char *) s)[ 3 ] == c4 )
  |  |  |  |  |  |  |  |  |  |  |  |  ------------------
  |  |  |  |  |  |  |  |  |  |  |  |  |  Branch (2229:5): [True: 0, False: 37]
  |  |  |  |  |  |  |  |  |  |  |  |  |  Branch (2229:41): [True: 0, False: 0]
  |  |  |  |  |  |  |  |  |  |  |  |  ------------------
  |  |  |  |  |  |  |  |  |  |  ------------------
  |  |  |  |  |  |  |  |  |  |  |  Branch (2231:34): [True: 0, False: 0]
  |  |  |  |  |  |  |  |  |  |  ------------------
  |  |  |  |  |  |  |  |  ------------------
  |  |  |  |  |  |  |  |  |  Branch (2233:38): [True: 0, False: 0]
  |  |  |  |  |  |  |  |  ------------------
  |  |  |  |  |  |  ------------------
  |  |  |  |  |  |  |  Branch (2235:42): [True: 0, False: 0]
  |  |  |  |  |  |  ------------------
  |  |  |  |  ------------------
  |  |  |  |  |  Branch (2237:46): [True: 0, False: 0]
  |  |  |  |  ------------------
  |  |  ------------------
  |  | 2240|  4.48k|    ((unsigned char *) s)[ 8 ] == c9 )
  |  |  ------------------
  |  |  |  Branch (2240:5): [True: 0, False: 0]
  |  |  ------------------
  ------------------
10230|      0|	    xmlParseCDSect(ctxt);
10231|      0|	}
10232|       |
10233|       |	/*
10234|       |	 * Third case :  a comment
10235|       |	 */
10236|  4.48k|	else if ((*cur == '<') && (NXT(1) == '!') &&
  ------------------
  |  | 2223|  2.29k|#define NXT(val) ctxt->input->cur[(val)]
  ------------------
  |  Branch (10236:11): [True: 2.29k, False: 2.19k]
  |  Branch (10236:28): [True: 37, False: 2.25k]
  ------------------
10237|  4.48k|		 (NXT(2) == '-') && (NXT(3) == '-')) {
  ------------------
  |  | 2223|     37|#define NXT(val) ctxt->input->cur[(val)]
  ------------------
              		 (NXT(2) == '-') && (NXT(3) == '-')) {
  ------------------
  |  | 2223|     35|#define NXT(val) ctxt->input->cur[(val)]
  ------------------
  |  Branch (10237:4): [True: 35, False: 2]
  |  Branch (10237:23): [True: 32, False: 3]
  ------------------
10238|     32|	    xmlParseComment(ctxt);
10239|     32|	    ctxt->instate = XML_PARSER_CONTENT;
10240|     32|	}
10241|       |
10242|       |	/*
10243|       |	 * Fourth case :  a sub-element.
10244|       |	 */
10245|  4.45k|	else if (*cur == '<') {
  ------------------
  |  Branch (10245:11): [True: 2.25k, False: 2.19k]
  ------------------
10246|  2.25k|            if (NXT(1) == '/') {
  ------------------
  |  | 2223|  2.25k|#define NXT(val) ctxt->input->cur[(val)]
  ------------------
  |  Branch (10246:17): [True: 841, False: 1.41k]
  ------------------
10247|    841|                if (ctxt->nameNr <= nameNr)
  ------------------
  |  Branch (10247:21): [True: 120, False: 721]
  ------------------
10248|    120|                    break;
10249|    721|	        xmlParseElementEnd(ctxt);
10250|  1.41k|            } else {
10251|  1.41k|	        xmlParseElementStart(ctxt);
10252|  1.41k|            }
10253|  2.25k|	}
10254|       |
10255|       |	/*
10256|       |	 * Fifth case : a reference. If if has not been resolved,
10257|       |	 *    parsing returns it's Name, create the node
10258|       |	 */
10259|       |
10260|  2.19k|	else if (*cur == '&') {
  ------------------
  |  Branch (10260:11): [True: 1, False: 2.19k]
  ------------------
10261|      1|	    xmlParseReference(ctxt);
10262|      1|	}
10263|       |
10264|       |	/*
10265|       |	 * Last case, text. Note that References are handled directly.
10266|       |	 */
10267|  2.19k|	else {
10268|  2.19k|	    xmlParseCharDataInternal(ctxt, 0);
10269|  2.19k|	}
10270|       |
10271|  4.36k|	SHRINK;
  ------------------
  |  | 2265|  4.36k|    if (((ctxt->progressive == 0) || (ctxt->inputNr > 1)) && \
  |  |  ------------------
  |  |  |  Branch (2265:10): [True: 4.36k, False: 0]
  |  |  |  Branch (2265:38): [True: 0, False: 0]
  |  |  ------------------
  |  | 2266|  4.36k|        (ctxt->input->cur - ctxt->input->base > 2 * INPUT_CHUNK) && \
  |  |  ------------------
  |  |  |  |   97|  4.36k|#define INPUT_CHUNK	250
  |  |  ------------------
  |  |  |  Branch (2266:9): [True: 1.42k, False: 2.94k]
  |  |  ------------------
  |  | 2267|  4.36k|	(ctxt->input->end - ctxt->input->cur < 2 * INPUT_CHUNK)) \
  |  |  ------------------
  |  |  |  |   97|  1.42k|#define INPUT_CHUNK	250
  |  |  ------------------
  |  |  |  Branch (2267:2): [True: 18, False: 1.40k]
  |  |  ------------------
  |  | 2268|  4.36k|	xmlParserShrink(ctxt);
  ------------------
10272|  4.36k|	GROW;
  ------------------
  |  | 2270|  4.36k|#define GROW if (ctxt->input->end - ctxt->input->cur < INPUT_CHUNK)	\
  |  |  ------------------
  |  |  |  |   97|  4.36k|#define INPUT_CHUNK	250
  |  |  ------------------
  |  |  |  Branch (2270:18): [True: 2.29k, False: 2.06k]
  |  |  ------------------
  |  | 2271|  4.36k|	xmlParserGrow(ctxt);
  ------------------
10273|  4.36k|    }
10274|    157|}
parser.c:xmlFatalErrMsgStrIntStr:
  416|    148|{
  417|    148|    if ((ctxt != NULL) && (ctxt->disableSAX != 0) &&
  ------------------
  |  Branch (417:9): [True: 148, False: 0]
  |  Branch (417:27): [True: 130, False: 18]
  ------------------
  418|    148|        (ctxt->instate == XML_PARSER_EOF))
  ------------------
  |  Branch (418:9): [True: 0, False: 130]
  ------------------
  419|      0|	return;
  420|    148|    if (ctxt != NULL)
  ------------------
  |  Branch (420:9): [True: 148, False: 0]
  ------------------
  421|    148|	ctxt->errNo = error;
  422|    148|    __xmlRaiseError(NULL, NULL, NULL,
  423|    148|                    ctxt, NULL, XML_FROM_PARSER, error, XML_ERR_FATAL,
  424|    148|                    NULL, 0, (const char *) str1, (const char *) str2,
  425|    148|		    NULL, val, 0, msg, str1, val, str2);
  426|    148|    if (ctxt != NULL) {
  ------------------
  |  Branch (426:9): [True: 148, False: 0]
  ------------------
  427|    148|	ctxt->wellFormed = 0;
  428|    148|	if (ctxt->recovery == 0)
  ------------------
  |  Branch (428:6): [True: 147, False: 1]
  ------------------
  429|    147|	    ctxt->disableSAX = 1;
  430|    148|    }
  431|    148|}
parser.c:xmlParseElementStart:
10351|  1.60k|xmlParseElementStart(xmlParserCtxtPtr ctxt) {
10352|  1.60k|    const xmlChar *name;
10353|  1.60k|    const xmlChar *prefix = NULL;
10354|  1.60k|    const xmlChar *URI = NULL;
10355|  1.60k|    xmlParserNodeInfo node_info;
10356|  1.60k|    int line;
10357|  1.60k|    xmlNodePtr cur;
10358|  1.60k|    int nbNs = 0;
10359|       |
10360|  1.60k|    if (((unsigned int) ctxt->nameNr > xmlParserMaxDepth) &&
  ------------------
  |  Branch (10360:9): [True: 0, False: 1.60k]
  ------------------
10361|  1.60k|        ((ctxt->options & XML_PARSE_HUGE) == 0)) {
  ------------------
  |  Branch (10361:9): [True: 0, False: 0]
  ------------------
10362|      0|	xmlFatalErrMsgInt(ctxt, XML_ERR_INTERNAL_ERROR,
10363|      0|		 "Excessive depth in document: %d use XML_PARSE_HUGE option\n",
10364|      0|			  xmlParserMaxDepth);
10365|      0|	xmlHaltParser(ctxt);
10366|      0|	return(-1);
10367|      0|    }
10368|       |
10369|       |    /* Capture start position */
10370|  1.60k|    if (ctxt->record_info) {
  ------------------
  |  Branch (10370:9): [True: 0, False: 1.60k]
  ------------------
10371|      0|        node_info.begin_pos = ctxt->input->consumed +
10372|      0|                          (CUR_PTR - ctxt->input->base);
  ------------------
  |  | 2224|      0|#define CUR_PTR ctxt->input->cur
  ------------------
10373|      0|	node_info.begin_line = ctxt->input->line;
10374|      0|    }
10375|       |
10376|  1.60k|    if (ctxt->spaceNr == 0)
  ------------------
  |  Branch (10376:9): [True: 0, False: 1.60k]
  ------------------
10377|      0|	spacePush(ctxt, -1);
10378|  1.60k|    else if (*ctxt->space == -2)
  ------------------
  |  Branch (10378:14): [True: 1, False: 1.60k]
  ------------------
10379|      1|	spacePush(ctxt, -1);
10380|  1.60k|    else
10381|  1.60k|	spacePush(ctxt, *ctxt->space);
10382|       |
10383|  1.60k|    line = ctxt->input->line;
10384|  1.60k|#ifdef LIBXML_SAX1_ENABLED
10385|  1.60k|    if (ctxt->sax2)
  ------------------
  |  Branch (10385:9): [True: 1.59k, False: 3]
  ------------------
10386|  1.59k|#endif /* LIBXML_SAX1_ENABLED */
10387|  1.59k|        name = xmlParseStartTag2(ctxt, &prefix, &URI, &nbNs);
10388|      3|#ifdef LIBXML_SAX1_ENABLED
10389|      3|    else
10390|      3|	name = xmlParseStartTag(ctxt);
10391|  1.60k|#endif /* LIBXML_SAX1_ENABLED */
10392|  1.60k|    if (ctxt->instate == XML_PARSER_EOF)
  ------------------
  |  Branch (10392:9): [True: 0, False: 1.60k]
  ------------------
10393|      0|	return(-1);
10394|  1.60k|    if (name == NULL) {
  ------------------
  |  Branch (10394:9): [True: 23, False: 1.57k]
  ------------------
10395|     23|	spacePop(ctxt);
10396|     23|        return(-1);
10397|     23|    }
10398|  1.57k|    nameNsPush(ctxt, name, prefix, URI, line, nbNs);
10399|  1.57k|    cur = ctxt->node;
10400|       |
10401|  1.57k|#ifdef LIBXML_VALID_ENABLED
10402|       |    /*
10403|       |     * [ VC: Root Element Type ]
10404|       |     * The Name in the document type declaration must match the element
10405|       |     * type of the root element.
10406|       |     */
10407|  1.57k|    if (ctxt->validate && ctxt->wellFormed && ctxt->myDoc &&
  ------------------
  |  Branch (10407:9): [True: 0, False: 1.57k]
  |  Branch (10407:27): [True: 0, False: 0]
  |  Branch (10407:47): [True: 0, False: 0]
  ------------------
10408|  1.57k|        ctxt->node && (ctxt->node == ctxt->myDoc->children))
  ------------------
  |  Branch (10408:9): [True: 0, False: 0]
  |  Branch (10408:23): [True: 0, False: 0]
  ------------------
10409|      0|        ctxt->valid &= xmlValidateRoot(&ctxt->vctxt, ctxt->myDoc);
10410|  1.57k|#endif /* LIBXML_VALID_ENABLED */
10411|       |
10412|       |    /*
10413|       |     * Check for an Empty Element.
10414|       |     */
10415|  1.57k|    if ((RAW == '/') && (NXT(1) == '>')) {
  ------------------
  |  | 2221|  1.57k|#define RAW (*ctxt->input->cur)
  ------------------
                  if ((RAW == '/') && (NXT(1) == '>')) {
  ------------------
  |  | 2223|    605|#define NXT(val) ctxt->input->cur[(val)]
  ------------------
  |  Branch (10415:9): [True: 605, False: 974]
  |  Branch (10415:25): [True: 599, False: 6]
  ------------------
10416|    599|        SKIP(2);
  ------------------
  |  | 2245|    599|#define SKIP(val) do {							\
  |  | 2246|    599|    ctxt->input->cur += (val),ctxt->input->col+=(val);			\
  |  | 2247|    599|    if (*ctxt->input->cur == 0)						\
  |  |  ------------------
  |  |  |  Branch (2247:9): [True: 0, False: 599]
  |  |  ------------------
  |  | 2248|    599|        xmlParserGrow(ctxt);						\
  |  | 2249|    599|  } while (0)
  |  |  ------------------
  |  |  |  Branch (2249:12): [Folded - Ignored]
  |  |  ------------------
  ------------------
10417|    599|	if (ctxt->sax2) {
  ------------------
  |  Branch (10417:6): [True: 598, False: 1]
  ------------------
10418|    598|	    if ((ctxt->sax != NULL) && (ctxt->sax->endElementNs != NULL) &&
  ------------------
  |  Branch (10418:10): [True: 598, False: 0]
  |  Branch (10418:33): [True: 598, False: 0]
  ------------------
10419|    598|		(!ctxt->disableSAX))
  ------------------
  |  Branch (10419:3): [True: 429, False: 169]
  ------------------
10420|    429|		ctxt->sax->endElementNs(ctxt->userData, name, prefix, URI);
10421|    598|#ifdef LIBXML_SAX1_ENABLED
10422|    598|	} else {
10423|      1|	    if ((ctxt->sax != NULL) && (ctxt->sax->endElement != NULL) &&
  ------------------
  |  Branch (10423:10): [True: 1, False: 0]
  |  Branch (10423:33): [True: 1, False: 0]
  ------------------
10424|      1|		(!ctxt->disableSAX))
  ------------------
  |  Branch (10424:3): [True: 1, False: 0]
  ------------------
10425|      1|		ctxt->sax->endElement(ctxt->userData, name);
10426|      1|#endif /* LIBXML_SAX1_ENABLED */
10427|      1|	}
10428|    599|	namePop(ctxt);
10429|    599|	spacePop(ctxt);
10430|    599|	if (nbNs > 0)
  ------------------
  |  Branch (10430:6): [True: 5, False: 594]
  ------------------
10431|      5|	    xmlParserNsPop(ctxt, nbNs);
10432|    599|	if (cur != NULL && ctxt->record_info) {
  ------------------
  |  Branch (10432:6): [True: 588, False: 11]
  |  Branch (10432:21): [True: 0, False: 588]
  ------------------
10433|      0|            node_info.node = cur;
10434|      0|            node_info.end_pos = ctxt->input->consumed +
10435|      0|                                (CUR_PTR - ctxt->input->base);
  ------------------
  |  | 2224|      0|#define CUR_PTR ctxt->input->cur
  ------------------
10436|      0|            node_info.end_line = ctxt->input->line;
10437|      0|            xmlParserAddNodeInfo(ctxt, &node_info);
10438|      0|	}
10439|    599|	return(1);
10440|    599|    }
10441|    980|    if (RAW == '>') {
  ------------------
  |  | 2221|    980|#define RAW (*ctxt->input->cur)
  ------------------
  |  Branch (10441:9): [True: 910, False: 70]
  ------------------
10442|    910|        NEXT1;
  ------------------
  |  | 2277|    910|#define NEXT1 {								\
  |  | 2278|    910|	ctxt->input->col++;						\
  |  | 2279|    910|	ctxt->input->cur++;						\
  |  | 2280|    910|	if (*ctxt->input->cur == 0)					\
  |  |  ------------------
  |  |  |  Branch (2280:6): [True: 0, False: 910]
  |  |  ------------------
  |  | 2281|    910|	    xmlParserGrow(ctxt);						\
  |  | 2282|    910|    }
  ------------------
10443|    910|        if (cur != NULL && ctxt->record_info) {
  ------------------
  |  Branch (10443:13): [True: 879, False: 31]
  |  Branch (10443:28): [True: 0, False: 879]
  ------------------
10444|      0|            node_info.node = cur;
10445|      0|            node_info.end_pos = 0;
10446|      0|            node_info.end_line = 0;
10447|      0|            xmlParserAddNodeInfo(ctxt, &node_info);
10448|      0|        }
10449|    910|    } else {
10450|     70|        xmlFatalErrMsgStrIntStr(ctxt, XML_ERR_GT_REQUIRED,
10451|     70|		     "Couldn't find end of Start Tag %s line %d\n",
10452|     70|		                name, line, NULL);
10453|       |
10454|       |	/*
10455|       |	 * end of parsing of this node.
10456|       |	 */
10457|     70|	nodePop(ctxt);
10458|     70|	namePop(ctxt);
10459|     70|	spacePop(ctxt);
10460|     70|	if (nbNs > 0)
  ------------------
  |  Branch (10460:6): [True: 17, False: 53]
  ------------------
10461|     17|	    xmlParserNsPop(ctxt, nbNs);
10462|     70|	return(-1);
10463|     70|    }
10464|       |
10465|    910|    return(0);
10466|    980|}
parser.c:spacePush:
 2154|  2.73k|static int spacePush(xmlParserCtxtPtr ctxt, int val) {
 2155|  2.73k|    if (ctxt->spaceNr >= ctxt->spaceMax) {
  ------------------
  |  Branch (2155:9): [True: 13, False: 2.72k]
  ------------------
 2156|     13|        int *tmp;
 2157|       |
 2158|     13|	ctxt->spaceMax *= 2;
 2159|     13|        tmp = (int *) xmlRealloc(ctxt->spaceTab,
 2160|     13|	                         ctxt->spaceMax * sizeof(ctxt->spaceTab[0]));
 2161|     13|        if (tmp == NULL) {
  ------------------
  |  Branch (2161:13): [True: 0, False: 13]
  ------------------
 2162|      0|	    xmlErrMemory(ctxt, NULL);
 2163|      0|	    ctxt->spaceMax /=2;
 2164|      0|	    return(-1);
 2165|      0|	}
 2166|     13|	ctxt->spaceTab = tmp;
 2167|     13|    }
 2168|  2.73k|    ctxt->spaceTab[ctxt->spaceNr] = val;
 2169|  2.73k|    ctxt->space = &ctxt->spaceTab[ctxt->spaceNr];
 2170|  2.73k|    return(ctxt->spaceNr++);
 2171|  2.73k|}
parser.c:xmlParseStartTag2:
 9471|  2.73k|                  const xmlChar **URI, int *nbNsPtr) {
 9472|  2.73k|    xmlHashedString hlocalname;
 9473|  2.73k|    xmlHashedString hprefix;
 9474|  2.73k|    xmlHashedString hattname;
 9475|  2.73k|    xmlHashedString haprefix;
 9476|  2.73k|    const xmlChar *localname;
 9477|  2.73k|    const xmlChar *prefix;
 9478|  2.73k|    const xmlChar *attname;
 9479|  2.73k|    const xmlChar *aprefix;
 9480|  2.73k|    const xmlChar *uri;
 9481|  2.73k|    xmlChar *attvalue = NULL;
 9482|  2.73k|    const xmlChar **atts = ctxt->atts;
 9483|  2.73k|    unsigned attrHashSize = 0;
 9484|  2.73k|    int maxatts = ctxt->maxatts;
 9485|  2.73k|    int nratts, nbatts, nbdef, inputid;
 9486|  2.73k|    int i, j, nbNs, nbTotalDef, attval, nsIndex, maxAtts;
 9487|  2.73k|    int alloc = 0;
 9488|       |
 9489|  2.73k|    if (RAW != '<') return(NULL);
  ------------------
  |  | 2221|  2.73k|#define RAW (*ctxt->input->cur)
  ------------------
  |  Branch (9489:9): [True: 0, False: 2.73k]
  ------------------
 9490|  2.73k|    NEXT1;
  ------------------
  |  | 2277|  2.73k|#define NEXT1 {								\
  |  | 2278|  2.73k|	ctxt->input->col++;						\
  |  | 2279|  2.73k|	ctxt->input->cur++;						\
  |  | 2280|  2.73k|	if (*ctxt->input->cur == 0)					\
  |  |  ------------------
  |  |  |  Branch (2280:6): [True: 0, False: 2.73k]
  |  |  ------------------
  |  | 2281|  2.73k|	    xmlParserGrow(ctxt);						\
  |  | 2282|  2.73k|    }
  ------------------
 9491|       |
 9492|  2.73k|    inputid = ctxt->input->id;
 9493|  2.73k|    nbatts = 0;
 9494|  2.73k|    nratts = 0;
 9495|  2.73k|    nbdef = 0;
 9496|  2.73k|    nbNs = 0;
 9497|  2.73k|    nbTotalDef = 0;
 9498|  2.73k|    attval = 0;
 9499|       |
 9500|  2.73k|    if (xmlParserNsStartElement(ctxt->nsdb) < 0) {
  ------------------
  |  Branch (9500:9): [True: 0, False: 2.73k]
  ------------------
 9501|      0|        xmlErrMemory(ctxt, NULL);
 9502|      0|        return(NULL);
 9503|      0|    }
 9504|       |
 9505|  2.73k|    hlocalname = xmlParseQNameHashed(ctxt, &hprefix);
 9506|  2.73k|    if (hlocalname.name == NULL) {
  ------------------
  |  Branch (9506:9): [True: 41, False: 2.69k]
  ------------------
 9507|     41|	xmlFatalErrMsg(ctxt, XML_ERR_NAME_REQUIRED,
 9508|     41|		       "StartTag: invalid element name\n");
 9509|     41|        return(NULL);
 9510|     41|    }
 9511|  2.69k|    localname = hlocalname.name;
 9512|  2.69k|    prefix = hprefix.name;
 9513|       |
 9514|       |    /*
 9515|       |     * Now parse the attributes, it ends up with the ending
 9516|       |     *
 9517|       |     * (S Attribute)* S?
 9518|       |     */
 9519|  2.69k|    SKIP_BLANKS;
  ------------------
  |  | 2273|  2.69k|#define SKIP_BLANKS xmlSkipBlankChars(ctxt)
  ------------------
 9520|  2.69k|    GROW;
  ------------------
  |  | 2270|  2.69k|#define GROW if (ctxt->input->end - ctxt->input->cur < INPUT_CHUNK)	\
  |  |  ------------------
  |  |  |  |   97|  2.69k|#define INPUT_CHUNK	250
  |  |  ------------------
  |  |  |  Branch (2270:18): [True: 1.21k, False: 1.47k]
  |  |  ------------------
  |  | 2271|  2.69k|	xmlParserGrow(ctxt);
  ------------------
 9521|       |
 9522|       |    /*
 9523|       |     * The ctxt->atts array will be ultimately passed to the SAX callback
 9524|       |     * containing five xmlChar pointers for each attribute:
 9525|       |     *
 9526|       |     * [0] attribute name
 9527|       |     * [1] attribute prefix
 9528|       |     * [2] namespace URI
 9529|       |     * [3] attribute value
 9530|       |     * [4] end of attribute value
 9531|       |     *
 9532|       |     * To save memory, we reuse this array temporarily and store integers
 9533|       |     * in these pointer variables.
 9534|       |     *
 9535|       |     * [0] attribute name
 9536|       |     * [1] attribute prefix
 9537|       |     * [2] hash value of attribute prefix, and later namespace index
 9538|       |     * [3] for non-allocated values: ptrdiff_t offset into input buffer
 9539|       |     * [4] for non-allocated values: ptrdiff_t offset into input buffer
 9540|       |     *
 9541|       |     * The ctxt->attallocs array contains an additional unsigned int for
 9542|       |     * each attribute, containing the hash value of the attribute name
 9543|       |     * and the alloc flag in bit 31.
 9544|       |     */
 9545|       |
 9546|  2.80k|    while (((RAW != '>') &&
  ------------------
  |  | 2221|  2.80k|#define RAW (*ctxt->input->cur)
  ------------------
  |  Branch (9546:13): [True: 1.64k, False: 1.15k]
  ------------------
 9547|  2.80k|	   ((RAW != '/') || (NXT(1) != '>')) &&
  ------------------
  |  | 2221|  1.64k|#define RAW (*ctxt->input->cur)
  ------------------
              	   ((RAW != '/') || (NXT(1) != '>')) &&
  ------------------
  |  | 2223|    107|#define NXT(val) ctxt->input->cur[(val)]
  ------------------
  |  Branch (9547:6): [True: 1.54k, False: 107]
  |  Branch (9547:22): [True: 6, False: 101]
  ------------------
 9548|  2.80k|	   (IS_BYTE_CHAR(RAW))) && (ctxt->instate != XML_PARSER_EOF)) {
  ------------------
  |  |  113|  1.54k|#define IS_BYTE_CHAR(c)	 xmlIsChar_ch(c)
  |  |  ------------------
  |  |  |  |  108|  1.54k|#define xmlIsChar_ch(c)		(((0x9 <= (c)) && ((c) <= 0xa)) || \
  |  |  |  |  ------------------
  |  |  |  |  |  Branch (108:28): [True: 1.53k, False: 8]
  |  |  |  |  |  Branch (108:44): [True: 0, False: 1.53k]
  |  |  |  |  ------------------
  |  |  |  |  109|  1.54k|				 ((c) == 0xd) || \
  |  |  |  |  ------------------
  |  |  |  |  |  Branch (109:6): [True: 0, False: 1.54k]
  |  |  |  |  ------------------
  |  |  |  |  110|  1.54k|				  (0x20 <= (c)))
  |  |  |  |  ------------------
  |  |  |  |  |  Branch (110:7): [True: 1.53k, False: 10]
  |  |  |  |  ------------------
  |  |  ------------------
  ------------------
  |  Branch (9548:29): [True: 1.53k, False: 0]
  ------------------
 9549|  1.53k|	int len = -1;
 9550|       |
 9551|  1.53k|	hattname = xmlParseAttribute2(ctxt, prefix, localname,
 9552|  1.53k|                                          &haprefix, &attvalue, &len,
 9553|  1.53k|                                          &alloc);
 9554|  1.53k|        if (hattname.name == NULL) {
  ------------------
  |  Branch (9554:13): [True: 35, False: 1.50k]
  ------------------
 9555|     35|	    xmlFatalErr(ctxt, XML_ERR_INTERNAL_ERROR,
 9556|     35|	         "xmlParseStartTag: problem parsing attributes\n");
 9557|     35|	    break;
 9558|     35|	}
 9559|  1.50k|        if (attvalue == NULL)
  ------------------
  |  Branch (9559:13): [True: 26, False: 1.47k]
  ------------------
 9560|     26|            goto next_attr;
 9561|  1.47k|        attname = hattname.name;
 9562|  1.47k|        aprefix = haprefix.name;
 9563|  1.47k|	if (len < 0) len = xmlStrlen(attvalue);
  ------------------
  |  Branch (9563:6): [True: 0, False: 1.47k]
  ------------------
 9564|       |
 9565|  1.47k|        if ((attname == ctxt->str_xmlns) && (aprefix == NULL)) {
  ------------------
  |  Branch (9565:13): [True: 0, False: 1.47k]
  |  Branch (9565:45): [True: 0, False: 0]
  ------------------
 9566|      0|            xmlHashedString huri;
 9567|      0|            xmlURIPtr parsedUri;
 9568|       |
 9569|      0|            huri = xmlDictLookupHashed(ctxt->dict, attvalue, len);
 9570|      0|            uri = huri.name;
 9571|      0|            if (uri == NULL) {
  ------------------
  |  Branch (9571:17): [True: 0, False: 0]
  ------------------
 9572|      0|                xmlErrMemory(ctxt, NULL);
 9573|      0|                goto next_attr;
 9574|      0|            }
 9575|      0|            if (*uri != 0) {
  ------------------
  |  Branch (9575:17): [True: 0, False: 0]
  ------------------
 9576|      0|                parsedUri = xmlParseURI((const char *) uri);
 9577|      0|                if (parsedUri == NULL) {
  ------------------
  |  Branch (9577:21): [True: 0, False: 0]
  ------------------
 9578|      0|                    xmlNsErr(ctxt, XML_WAR_NS_URI,
 9579|      0|                             "xmlns: '%s' is not a valid URI\n",
 9580|      0|                                       uri, NULL, NULL);
 9581|      0|                } else {
 9582|      0|                    if (parsedUri->scheme == NULL) {
  ------------------
  |  Branch (9582:25): [True: 0, False: 0]
  ------------------
 9583|      0|                        xmlNsWarn(ctxt, XML_WAR_NS_URI_RELATIVE,
 9584|      0|                                  "xmlns: URI %s is not absolute\n",
 9585|      0|                                  uri, NULL, NULL);
 9586|      0|                    }
 9587|      0|                    xmlFreeURI(parsedUri);
 9588|      0|                }
 9589|      0|                if (uri == ctxt->str_xml_ns) {
  ------------------
  |  Branch (9589:21): [True: 0, False: 0]
  ------------------
 9590|      0|                    if (attname != ctxt->str_xml) {
  ------------------
  |  Branch (9590:25): [True: 0, False: 0]
  ------------------
 9591|      0|                        xmlNsErr(ctxt, XML_NS_ERR_XML_NAMESPACE,
 9592|      0|                     "xml namespace URI cannot be the default namespace\n",
 9593|      0|                                 NULL, NULL, NULL);
 9594|      0|                    }
 9595|      0|                    goto next_attr;
 9596|      0|                }
 9597|      0|                if ((len == 29) &&
  ------------------
  |  Branch (9597:21): [True: 0, False: 0]
  ------------------
 9598|      0|                    (xmlStrEqual(uri,
  ------------------
  |  Branch (9598:21): [True: 0, False: 0]
  ------------------
 9599|      0|                             BAD_CAST "http://www.w3.org/2000/xmlns/"))) {
  ------------------
  |  |   35|      0|#define BAD_CAST (xmlChar *)
  ------------------
 9600|      0|                    xmlNsErr(ctxt, XML_NS_ERR_XML_NAMESPACE,
 9601|      0|                         "reuse of the xmlns namespace name is forbidden\n",
 9602|      0|                             NULL, NULL, NULL);
 9603|      0|                    goto next_attr;
 9604|      0|                }
 9605|      0|            }
 9606|       |
 9607|      0|            if (xmlParserNsPush(ctxt, NULL, &huri, NULL, 0) > 0)
  ------------------
  |  Branch (9607:17): [True: 0, False: 0]
  ------------------
 9608|      0|                nbNs++;
 9609|  1.47k|        } else if (aprefix == ctxt->str_xmlns) {
  ------------------
  |  Branch (9609:20): [True: 316, False: 1.16k]
  ------------------
 9610|    316|            xmlHashedString huri;
 9611|    316|            xmlURIPtr parsedUri;
 9612|       |
 9613|    316|            huri = xmlDictLookupHashed(ctxt->dict, attvalue, len);
 9614|    316|            uri = huri.name;
 9615|    316|            if (uri == NULL) {
  ------------------
  |  Branch (9615:17): [True: 0, False: 316]
  ------------------
 9616|      0|                xmlErrMemory(ctxt, NULL);
 9617|      0|                goto next_attr;
 9618|      0|            }
 9619|       |
 9620|    316|            if (attname == ctxt->str_xml) {
  ------------------
  |  Branch (9620:17): [True: 0, False: 316]
  ------------------
 9621|      0|                if (uri != ctxt->str_xml_ns) {
  ------------------
  |  Branch (9621:21): [True: 0, False: 0]
  ------------------
 9622|      0|                    xmlNsErr(ctxt, XML_NS_ERR_XML_NAMESPACE,
 9623|      0|                             "xml namespace prefix mapped to wrong URI\n",
 9624|      0|                             NULL, NULL, NULL);
 9625|      0|                }
 9626|       |                /*
 9627|       |                 * Do not keep a namespace definition node
 9628|       |                 */
 9629|      0|                goto next_attr;
 9630|      0|            }
 9631|    316|            if (uri == ctxt->str_xml_ns) {
  ------------------
  |  Branch (9631:17): [True: 0, False: 316]
  ------------------
 9632|      0|                if (attname != ctxt->str_xml) {
  ------------------
  |  Branch (9632:21): [True: 0, False: 0]
  ------------------
 9633|      0|                    xmlNsErr(ctxt, XML_NS_ERR_XML_NAMESPACE,
 9634|      0|                             "xml namespace URI mapped to wrong prefix\n",
 9635|      0|                             NULL, NULL, NULL);
 9636|      0|                }
 9637|      0|                goto next_attr;
 9638|      0|            }
 9639|    316|            if (attname == ctxt->str_xmlns) {
  ------------------
  |  Branch (9639:17): [True: 0, False: 316]
  ------------------
 9640|      0|                xmlNsErr(ctxt, XML_NS_ERR_XML_NAMESPACE,
 9641|      0|                         "redefinition of the xmlns prefix is forbidden\n",
 9642|      0|                         NULL, NULL, NULL);
 9643|      0|                goto next_attr;
 9644|      0|            }
 9645|    316|            if ((len == 29) &&
  ------------------
  |  Branch (9645:17): [True: 0, False: 316]
  ------------------
 9646|    316|                (xmlStrEqual(uri,
  ------------------
  |  Branch (9646:17): [True: 0, False: 0]
  ------------------
 9647|      0|                             BAD_CAST "http://www.w3.org/2000/xmlns/"))) {
  ------------------
  |  |   35|      0|#define BAD_CAST (xmlChar *)
  ------------------
 9648|      0|                xmlNsErr(ctxt, XML_NS_ERR_XML_NAMESPACE,
 9649|      0|                         "reuse of the xmlns namespace name is forbidden\n",
 9650|      0|                         NULL, NULL, NULL);
 9651|      0|                goto next_attr;
 9652|      0|            }
 9653|    316|            if ((uri == NULL) || (uri[0] == 0)) {
  ------------------
  |  Branch (9653:17): [True: 0, False: 316]
  |  Branch (9653:34): [True: 0, False: 316]
  ------------------
 9654|      0|                xmlNsErr(ctxt, XML_NS_ERR_XML_NAMESPACE,
 9655|      0|                         "xmlns:%s: Empty XML namespace is not allowed\n",
 9656|      0|                              attname, NULL, NULL);
 9657|      0|                goto next_attr;
 9658|    316|            } else {
 9659|    316|                parsedUri = xmlParseURI((const char *) uri);
 9660|    316|                if (parsedUri == NULL) {
  ------------------
  |  Branch (9660:21): [True: 20, False: 296]
  ------------------
 9661|     20|                    xmlNsErr(ctxt, XML_WAR_NS_URI,
 9662|     20|                         "xmlns:%s: '%s' is not a valid URI\n",
 9663|     20|                                       attname, uri, NULL);
 9664|    296|                } else {
 9665|    296|                    if ((ctxt->pedantic) && (parsedUri->scheme == NULL)) {
  ------------------
  |  Branch (9665:25): [True: 0, False: 296]
  |  Branch (9665:45): [True: 0, False: 0]
  ------------------
 9666|      0|                        xmlNsWarn(ctxt, XML_WAR_NS_URI_RELATIVE,
 9667|      0|                                  "xmlns:%s: URI %s is not absolute\n",
 9668|      0|                                  attname, uri, NULL);
 9669|      0|                    }
 9670|    296|                    xmlFreeURI(parsedUri);
 9671|    296|                }
 9672|    316|            }
 9673|       |
 9674|    316|            if (xmlParserNsPush(ctxt, &hattname, &huri, NULL, 0) > 0)
  ------------------
  |  Branch (9674:17): [True: 316, False: 0]
  ------------------
 9675|    316|                nbNs++;
 9676|  1.16k|        } else {
 9677|       |            /*
 9678|       |             * Populate attributes array, see above for repurposing
 9679|       |             * of xmlChar pointers.
 9680|       |             */
 9681|  1.16k|            if ((atts == NULL) || (nbatts + 5 > maxatts)) {
  ------------------
  |  Branch (9681:17): [True: 207, False: 953]
  |  Branch (9681:35): [True: 0, False: 953]
  ------------------
 9682|    207|                if (xmlCtxtGrowAttrs(ctxt, nbatts + 5) < 0) {
  ------------------
  |  Branch (9682:21): [True: 0, False: 207]
  ------------------
 9683|      0|                    goto next_attr;
 9684|      0|                }
 9685|    207|                maxatts = ctxt->maxatts;
 9686|    207|                atts = ctxt->atts;
 9687|    207|            }
 9688|  1.16k|            ctxt->attallocs[nratts++] = (hattname.hashValue & 0x7FFFFFFF) |
 9689|  1.16k|                                        ((unsigned) alloc << 31);
 9690|  1.16k|            atts[nbatts++] = attname;
 9691|  1.16k|            atts[nbatts++] = aprefix;
 9692|  1.16k|            atts[nbatts++] = (const xmlChar *) (size_t) haprefix.hashValue;
 9693|  1.16k|            if (alloc) {
  ------------------
  |  Branch (9693:17): [True: 7, False: 1.15k]
  ------------------
 9694|      7|                atts[nbatts++] = attvalue;
 9695|      7|                attvalue += len;
 9696|      7|                atts[nbatts++] = attvalue;
 9697|  1.15k|            } else {
 9698|       |                /*
 9699|       |                 * attvalue points into the input buffer which can be
 9700|       |                 * reallocated. Store differences to input->base instead.
 9701|       |                 * The pointers will be reconstructed later.
 9702|       |                 */
 9703|  1.15k|                atts[nbatts++] = (void *) (attvalue - BASE_PTR);
  ------------------
  |  | 2225|  1.15k|#define BASE_PTR ctxt->input->base
  ------------------
 9704|  1.15k|                attvalue += len;
 9705|  1.15k|                atts[nbatts++] = (void *) (attvalue - BASE_PTR);
  ------------------
  |  | 2225|  1.15k|#define BASE_PTR ctxt->input->base
  ------------------
 9706|  1.15k|            }
 9707|       |            /*
 9708|       |             * tag if some deallocation is needed
 9709|       |             */
 9710|  1.16k|            if (alloc != 0) attval = 1;
  ------------------
  |  Branch (9710:17): [True: 7, False: 1.15k]
  ------------------
 9711|  1.16k|            attvalue = NULL; /* moved into atts */
 9712|  1.16k|        }
 9713|       |
 9714|  1.50k|next_attr:
 9715|  1.50k|        if ((attvalue != NULL) && (alloc != 0)) {
  ------------------
  |  Branch (9715:13): [True: 316, False: 1.18k]
  |  Branch (9715:35): [True: 40, False: 276]
  ------------------
 9716|     40|            xmlFree(attvalue);
 9717|     40|            attvalue = NULL;
 9718|     40|        }
 9719|       |
 9720|  1.50k|	GROW
  ------------------
  |  | 2270|  1.50k|#define GROW if (ctxt->input->end - ctxt->input->cur < INPUT_CHUNK)	\
  |  |  ------------------
  |  |  |  |   97|  1.50k|#define INPUT_CHUNK	250
  |  |  ------------------
  |  |  |  Branch (2270:18): [True: 806, False: 696]
  |  |  ------------------
  |  | 2271|  1.50k|	xmlParserGrow(ctxt);
  ------------------
 9721|  1.50k|        if (ctxt->instate == XML_PARSER_EOF)
  ------------------
  |  Branch (9721:13): [True: 0, False: 1.50k]
  ------------------
 9722|      0|            break;
 9723|  1.50k|	if ((RAW == '>') || (((RAW == '/') && (NXT(1) == '>'))))
  ------------------
  |  | 2221|  1.50k|#define RAW (*ctxt->input->cur)
  ------------------
              	if ((RAW == '>') || (((RAW == '/') && (NXT(1) == '>'))))
  ------------------
  |  | 2221|  1.09k|#define RAW (*ctxt->input->cur)
  ------------------
              	if ((RAW == '>') || (((RAW == '/') && (NXT(1) == '>'))))
  ------------------
  |  | 2223|    918|#define NXT(val) ctxt->input->cur[(val)]
  ------------------
  |  Branch (9723:6): [True: 409, False: 1.09k]
  |  Branch (9723:24): [True: 918, False: 175]
  |  Branch (9723:40): [True: 915, False: 3]
  ------------------
 9724|  1.32k|	    break;
 9725|    178|	if (SKIP_BLANKS == 0) {
  ------------------
  |  | 2273|    178|#define SKIP_BLANKS xmlSkipBlankChars(ctxt)
  ------------------
  |  Branch (9725:6): [True: 71, False: 107]
  ------------------
 9726|     71|	    xmlFatalErrMsg(ctxt, XML_ERR_SPACE_REQUIRED,
 9727|     71|			   "attributes construct error\n");
 9728|     71|	    break;
 9729|     71|	}
 9730|    107|        GROW;
  ------------------
  |  | 2270|    107|#define GROW if (ctxt->input->end - ctxt->input->cur < INPUT_CHUNK)	\
  |  |  ------------------
  |  |  |  |   97|    107|#define INPUT_CHUNK	250
  |  |  ------------------
  |  |  |  Branch (2270:18): [True: 91, False: 16]
  |  |  ------------------
  |  | 2271|    107|	xmlParserGrow(ctxt);
  ------------------
 9731|    107|    }
 9732|       |
 9733|  2.69k|    if (ctxt->input->id != inputid) {
  ------------------
  |  Branch (9733:9): [True: 0, False: 2.69k]
  ------------------
 9734|      0|        xmlFatalErr(ctxt, XML_ERR_INTERNAL_ERROR,
 9735|      0|                    "Unexpected change of input\n");
 9736|      0|        localname = NULL;
 9737|      0|        goto done;
 9738|      0|    }
 9739|       |
 9740|       |    /*
 9741|       |     * Namespaces from default attributes
 9742|       |     */
 9743|  2.69k|    if (ctxt->attsDefault != NULL) {
  ------------------
  |  Branch (9743:9): [True: 0, False: 2.69k]
  ------------------
 9744|      0|        xmlDefAttrsPtr defaults;
 9745|       |
 9746|      0|	defaults = xmlHashLookup2(ctxt->attsDefault, localname, prefix);
 9747|      0|	if (defaults != NULL) {
  ------------------
  |  Branch (9747:6): [True: 0, False: 0]
  ------------------
 9748|      0|	    for (i = 0; i < defaults->nbAttrs; i++) {
  ------------------
  |  Branch (9748:18): [True: 0, False: 0]
  ------------------
 9749|      0|                xmlDefAttr *attr = &defaults->attrs[i];
 9750|       |
 9751|      0|	        attname = attr->name.name;
 9752|      0|		aprefix = attr->prefix.name;
 9753|       |
 9754|      0|		if ((attname == ctxt->str_xmlns) && (aprefix == NULL)) {
  ------------------
  |  Branch (9754:7): [True: 0, False: 0]
  |  Branch (9754:39): [True: 0, False: 0]
  ------------------
 9755|      0|                    xmlParserEntityCheck(ctxt, attr->expandedSize);
 9756|       |
 9757|      0|                    if (xmlParserNsPush(ctxt, NULL, &attr->value, NULL, 1) > 0)
  ------------------
  |  Branch (9757:25): [True: 0, False: 0]
  ------------------
 9758|      0|                        nbNs++;
 9759|      0|		} else if (aprefix == ctxt->str_xmlns) {
  ------------------
  |  Branch (9759:14): [True: 0, False: 0]
  ------------------
 9760|      0|                    xmlParserEntityCheck(ctxt, attr->expandedSize);
 9761|       |
 9762|      0|                    if (xmlParserNsPush(ctxt, &attr->name, &attr->value,
  ------------------
  |  Branch (9762:25): [True: 0, False: 0]
  ------------------
 9763|      0|                                      NULL, 1) > 0)
 9764|      0|                        nbNs++;
 9765|      0|		} else {
 9766|      0|                    nbTotalDef += 1;
 9767|      0|                }
 9768|      0|	    }
 9769|      0|	}
 9770|      0|    }
 9771|       |
 9772|       |    /*
 9773|       |     * Resolve attribute namespaces
 9774|       |     */
 9775|  3.85k|    for (i = 0; i < nbatts; i += 5) {
  ------------------
  |  Branch (9775:17): [True: 1.16k, False: 2.69k]
  ------------------
 9776|  1.16k|        attname = atts[i];
 9777|  1.16k|        aprefix = atts[i+1];
 9778|       |
 9779|       |        /*
 9780|       |	* The default namespace does not apply to attribute names.
 9781|       |	*/
 9782|  1.16k|	if (aprefix == NULL) {
  ------------------
  |  Branch (9782:6): [True: 1.14k, False: 16]
  ------------------
 9783|  1.14k|            nsIndex = NS_INDEX_EMPTY;
  ------------------
  |  |   77|  1.14k|#define NS_INDEX_EMPTY  INT_MAX
  ------------------
 9784|  1.14k|        } else if (aprefix == ctxt->str_xml) {
  ------------------
  |  Branch (9784:20): [True: 14, False: 2]
  ------------------
 9785|     14|            nsIndex = NS_INDEX_XML;
  ------------------
  |  |   78|     14|#define NS_INDEX_XML    (INT_MAX - 1)
  ------------------
 9786|     14|        } else {
 9787|      2|            haprefix.name = aprefix;
 9788|      2|            haprefix.hashValue = (size_t) atts[i+2];
 9789|      2|            nsIndex = xmlParserNsLookup(ctxt, &haprefix, NULL);
 9790|      2|	    if (nsIndex == INT_MAX) {
  ------------------
  |  Branch (9790:10): [True: 2, False: 0]
  ------------------
 9791|      2|                xmlNsErr(ctxt, XML_NS_ERR_UNDEFINED_NAMESPACE,
 9792|      2|		    "Namespace prefix %s for %s on %s is not defined\n",
 9793|      2|		    aprefix, attname, localname);
 9794|      2|                nsIndex = NS_INDEX_EMPTY;
  ------------------
  |  |   77|      2|#define NS_INDEX_EMPTY  INT_MAX
  ------------------
 9795|      2|            }
 9796|      2|        }
 9797|       |
 9798|  1.16k|        atts[i+2] = (const xmlChar *) (ptrdiff_t) nsIndex;
 9799|  1.16k|    }
 9800|       |
 9801|       |    /*
 9802|       |     * Maximum number of attributes including default attributes.
 9803|       |     */
 9804|  2.69k|    maxAtts = nratts + nbTotalDef;
 9805|       |
 9806|       |    /*
 9807|       |     * Verify that attribute names are unique.
 9808|       |     */
 9809|  2.69k|    if (maxAtts > 1) {
  ------------------
  |  Branch (9809:9): [True: 23, False: 2.67k]
  ------------------
 9810|     23|        attrHashSize = 4;
 9811|     32|        while (attrHashSize / 2 < (unsigned) maxAtts)
  ------------------
  |  Branch (9811:16): [True: 9, False: 23]
  ------------------
 9812|      9|            attrHashSize *= 2;
 9813|       |
 9814|     23|        if (attrHashSize > ctxt->attrHashMax) {
  ------------------
  |  Branch (9814:13): [True: 23, False: 0]
  ------------------
 9815|     23|            xmlAttrHashBucket *tmp;
 9816|       |
 9817|     23|            tmp = xmlRealloc(ctxt->attrHash, attrHashSize * sizeof(tmp[0]));
 9818|     23|            if (tmp == NULL) {
  ------------------
  |  Branch (9818:17): [True: 0, False: 23]
  ------------------
 9819|      0|                xmlErrMemory(ctxt, NULL);
 9820|      0|                goto done;
 9821|      0|            }
 9822|       |
 9823|     23|            ctxt->attrHash = tmp;
 9824|     23|            ctxt->attrHashMax = attrHashSize;
 9825|     23|        }
 9826|       |
 9827|     23|        memset(ctxt->attrHash, -1, attrHashSize * sizeof(ctxt->attrHash[0]));
 9828|       |
 9829|     78|        for (i = 0, j = 0; j < nratts; i += 5, j++) {
  ------------------
  |  Branch (9829:28): [True: 55, False: 23]
  ------------------
 9830|     55|            const xmlChar *nsuri;
 9831|     55|            unsigned hashValue, nameHashValue, uriHashValue;
 9832|     55|            int res;
 9833|       |
 9834|     55|            attname = atts[i];
 9835|     55|            aprefix = atts[i+1];
 9836|     55|            nsIndex = (ptrdiff_t) atts[i+2];
 9837|       |            /* Hash values always have bit 31 set, see dict.c */
 9838|     55|            nameHashValue = ctxt->attallocs[j] | 0x80000000;
 9839|       |
 9840|     55|            if (nsIndex == NS_INDEX_EMPTY) {
  ------------------
  |  |   77|     55|#define NS_INDEX_EMPTY  INT_MAX
  ------------------
  |  Branch (9840:17): [True: 55, False: 0]
  ------------------
 9841|     55|                nsuri = NULL;
 9842|     55|                uriHashValue = URI_HASH_EMPTY;
  ------------------
  |  |   79|     55|#define URI_HASH_EMPTY  0xD943A04E
  ------------------
 9843|     55|            } else if (nsIndex == NS_INDEX_XML) {
  ------------------
  |  |   78|      0|#define NS_INDEX_XML    (INT_MAX - 1)
  ------------------
  |  Branch (9843:24): [True: 0, False: 0]
  ------------------
 9844|      0|                nsuri = ctxt->str_xml_ns;
 9845|      0|                uriHashValue = URI_HASH_XML;
  ------------------
  |  |   80|      0|#define URI_HASH_XML    0xF0451F02
  ------------------
 9846|      0|            } else {
 9847|      0|                nsuri = ctxt->nsTab[nsIndex * 2 + 1];
 9848|      0|                uriHashValue = ctxt->nsdb->extra[nsIndex].uriHashValue;
 9849|      0|            }
 9850|       |
 9851|     55|            hashValue = xmlDictCombineHash(nameHashValue, uriHashValue);
 9852|     55|            res = xmlAttrHashInsert(ctxt, attrHashSize, attname, nsuri,
 9853|     55|                                    hashValue, i);
 9854|     55|            if (res < 0)
  ------------------
  |  Branch (9854:17): [True: 0, False: 55]
  ------------------
 9855|      0|                continue;
 9856|       |
 9857|       |            /*
 9858|       |             * [ WFC: Unique Att Spec ]
 9859|       |             * No attribute name may appear more than once in the same
 9860|       |             * start-tag or empty-element tag.
 9861|       |             * As extended by the Namespace in XML REC.
 9862|       |             */
 9863|     55|            if (res < INT_MAX) {
  ------------------
  |  Branch (9863:17): [True: 0, False: 55]
  ------------------
 9864|      0|                if (aprefix == atts[res+1]) {
  ------------------
  |  Branch (9864:21): [True: 0, False: 0]
  ------------------
 9865|      0|                    xmlErrAttributeDup(ctxt, aprefix, attname);
 9866|      0|                } else {
 9867|      0|                    xmlNsErr(ctxt, XML_NS_ERR_ATTRIBUTE_REDEFINED,
 9868|      0|                             "Namespaced Attribute %s in '%s' redefined\n",
 9869|      0|                             attname, nsuri, NULL);
 9870|      0|                }
 9871|      0|            }
 9872|     55|        }
 9873|     23|    }
 9874|       |
 9875|       |    /*
 9876|       |     * Default attributes
 9877|       |     */
 9878|  2.69k|    if (ctxt->attsDefault != NULL) {
  ------------------
  |  Branch (9878:9): [True: 0, False: 2.69k]
  ------------------
 9879|      0|        xmlDefAttrsPtr defaults;
 9880|       |
 9881|      0|	defaults = xmlHashLookup2(ctxt->attsDefault, localname, prefix);
 9882|      0|	if (defaults != NULL) {
  ------------------
  |  Branch (9882:6): [True: 0, False: 0]
  ------------------
 9883|      0|	    for (i = 0; i < defaults->nbAttrs; i++) {
  ------------------
  |  Branch (9883:18): [True: 0, False: 0]
  ------------------
 9884|      0|                xmlDefAttr *attr = &defaults->attrs[i];
 9885|      0|                const xmlChar *nsuri;
 9886|      0|                unsigned hashValue, uriHashValue;
 9887|      0|                int res;
 9888|       |
 9889|      0|	        attname = attr->name.name;
 9890|      0|		aprefix = attr->prefix.name;
 9891|       |
 9892|      0|		if ((attname == ctxt->str_xmlns) && (aprefix == NULL))
  ------------------
  |  Branch (9892:7): [True: 0, False: 0]
  |  Branch (9892:39): [True: 0, False: 0]
  ------------------
 9893|      0|                    continue;
 9894|      0|		if (aprefix == ctxt->str_xmlns)
  ------------------
  |  Branch (9894:7): [True: 0, False: 0]
  ------------------
 9895|      0|                    continue;
 9896|       |
 9897|      0|                if (aprefix == NULL) {
  ------------------
  |  Branch (9897:21): [True: 0, False: 0]
  ------------------
 9898|      0|                    nsIndex = NS_INDEX_EMPTY;
  ------------------
  |  |   77|      0|#define NS_INDEX_EMPTY  INT_MAX
  ------------------
 9899|      0|                    nsuri = NULL;
 9900|      0|                    uriHashValue = URI_HASH_EMPTY;
  ------------------
  |  |   79|      0|#define URI_HASH_EMPTY  0xD943A04E
  ------------------
 9901|      0|                } if (aprefix == ctxt->str_xml) {
  ------------------
  |  Branch (9901:23): [True: 0, False: 0]
  ------------------
 9902|      0|                    nsIndex = NS_INDEX_XML;
  ------------------
  |  |   78|      0|#define NS_INDEX_XML    (INT_MAX - 1)
  ------------------
 9903|      0|                    nsuri = ctxt->str_xml_ns;
 9904|      0|                    uriHashValue = URI_HASH_XML;
  ------------------
  |  |   80|      0|#define URI_HASH_XML    0xF0451F02
  ------------------
 9905|      0|                } else if (aprefix != NULL) {
  ------------------
  |  Branch (9905:28): [True: 0, False: 0]
  ------------------
 9906|      0|                    nsIndex = xmlParserNsLookup(ctxt, &attr->prefix, NULL);
 9907|      0|                    if (nsIndex == INT_MAX) {
  ------------------
  |  Branch (9907:25): [True: 0, False: 0]
  ------------------
 9908|      0|                        xmlNsErr(ctxt, XML_NS_ERR_UNDEFINED_NAMESPACE,
 9909|      0|                                 "Namespace prefix %s for %s on %s is not "
 9910|      0|                                 "defined\n",
 9911|      0|                                 aprefix, attname, localname);
 9912|      0|                        nsIndex = NS_INDEX_EMPTY;
  ------------------
  |  |   77|      0|#define NS_INDEX_EMPTY  INT_MAX
  ------------------
 9913|      0|                        nsuri = NULL;
 9914|      0|                        uriHashValue = URI_HASH_EMPTY;
  ------------------
  |  |   79|      0|#define URI_HASH_EMPTY  0xD943A04E
  ------------------
 9915|      0|                    } else {
 9916|      0|                        nsuri = ctxt->nsTab[nsIndex * 2 + 1];
 9917|      0|                        uriHashValue = ctxt->nsdb->extra[nsIndex].uriHashValue;
 9918|      0|                    }
 9919|      0|                }
 9920|       |
 9921|       |                /*
 9922|       |                 * Check whether the attribute exists
 9923|       |                 */
 9924|      0|                if (maxAtts > 1) {
  ------------------
  |  Branch (9924:21): [True: 0, False: 0]
  ------------------
 9925|      0|                    hashValue = xmlDictCombineHash(attr->name.hashValue,
 9926|      0|                                                   uriHashValue);
 9927|      0|                    res = xmlAttrHashInsert(ctxt, attrHashSize, attname, nsuri,
 9928|      0|                                            hashValue, nbatts);
 9929|      0|                    if (res < 0)
  ------------------
  |  Branch (9929:25): [True: 0, False: 0]
  ------------------
 9930|      0|                        continue;
 9931|      0|                    if (res < INT_MAX) {
  ------------------
  |  Branch (9931:25): [True: 0, False: 0]
  ------------------
 9932|      0|                        if (aprefix == atts[res+1])
  ------------------
  |  Branch (9932:29): [True: 0, False: 0]
  ------------------
 9933|      0|                            continue;
 9934|      0|                        xmlNsErr(ctxt, XML_NS_ERR_ATTRIBUTE_REDEFINED,
 9935|      0|                                 "Namespaced Attribute %s in '%s' redefined\n",
 9936|      0|                                 attname, nsuri, NULL);
 9937|      0|                    }
 9938|      0|                }
 9939|       |
 9940|      0|                xmlParserEntityCheck(ctxt, attr->expandedSize);
 9941|       |
 9942|      0|                if ((atts == NULL) || (nbatts + 5 > maxatts)) {
  ------------------
  |  Branch (9942:21): [True: 0, False: 0]
  |  Branch (9942:39): [True: 0, False: 0]
  ------------------
 9943|      0|                    if (xmlCtxtGrowAttrs(ctxt, nbatts + 5) < 0) {
  ------------------
  |  Branch (9943:25): [True: 0, False: 0]
  ------------------
 9944|      0|                        localname = NULL;
 9945|      0|                        goto done;
 9946|      0|                    }
 9947|      0|                    maxatts = ctxt->maxatts;
 9948|      0|                    atts = ctxt->atts;
 9949|      0|                }
 9950|       |
 9951|      0|                atts[nbatts++] = attname;
 9952|      0|                atts[nbatts++] = aprefix;
 9953|      0|                atts[nbatts++] = (const xmlChar *) (ptrdiff_t) nsIndex;
 9954|      0|                atts[nbatts++] = attr->value.name;
 9955|      0|                atts[nbatts++] = attr->valueEnd;
 9956|      0|                if ((ctxt->standalone == 1) && (attr->external != 0)) {
  ------------------
  |  Branch (9956:21): [True: 0, False: 0]
  |  Branch (9956:48): [True: 0, False: 0]
  ------------------
 9957|      0|                    xmlValidityError(ctxt, XML_DTD_STANDALONE_DEFAULTED,
 9958|      0|                            "standalone: attribute %s on %s defaulted "
 9959|      0|                            "from external subset\n",
 9960|      0|                            attname, localname);
 9961|      0|                }
 9962|      0|                nbdef++;
 9963|      0|	    }
 9964|      0|	}
 9965|      0|    }
 9966|       |
 9967|       |    /*
 9968|       |     * Reconstruct attribute pointers
 9969|       |     */
 9970|  3.85k|    for (i = 0, j = 0; i < nbatts; i += 5, j++) {
  ------------------
  |  Branch (9970:24): [True: 1.16k, False: 2.69k]
  ------------------
 9971|       |        /* namespace URI */
 9972|  1.16k|        nsIndex = (ptrdiff_t) atts[i+2];
 9973|  1.16k|        if (nsIndex == INT_MAX)
  ------------------
  |  Branch (9973:13): [True: 1.14k, False: 14]
  ------------------
 9974|  1.14k|            atts[i+2] = NULL;
 9975|     14|        else if (nsIndex == INT_MAX - 1)
  ------------------
  |  Branch (9975:18): [True: 14, False: 0]
  ------------------
 9976|     14|            atts[i+2] = ctxt->str_xml_ns;
 9977|      0|        else
 9978|      0|            atts[i+2] = ctxt->nsTab[nsIndex * 2 + 1];
 9979|       |
 9980|  1.16k|        if ((j < nratts) && (ctxt->attallocs[j] & 0x80000000) == 0) {
  ------------------
  |  Branch (9980:13): [True: 1.16k, False: 0]
  |  Branch (9980:29): [True: 1.15k, False: 7]
  ------------------
 9981|  1.15k|            atts[i+3] = BASE_PTR + (ptrdiff_t) atts[i+3];  /* value */
  ------------------
  |  | 2225|  1.15k|#define BASE_PTR ctxt->input->base
  ------------------
 9982|  1.15k|            atts[i+4] = BASE_PTR + (ptrdiff_t) atts[i+4];  /* valuend */
  ------------------
  |  | 2225|  1.15k|#define BASE_PTR ctxt->input->base
  ------------------
 9983|  1.15k|        }
 9984|  1.16k|    }
 9985|       |
 9986|  2.69k|    uri = xmlParserNsLookupUri(ctxt, &hprefix);
 9987|  2.69k|    if ((prefix != NULL) && (uri == NULL)) {
  ------------------
  |  Branch (9987:9): [True: 1.31k, False: 1.38k]
  |  Branch (9987:29): [True: 22, False: 1.29k]
  ------------------
 9988|     22|	xmlNsErr(ctxt, XML_NS_ERR_UNDEFINED_NAMESPACE,
 9989|     22|	         "Namespace prefix %s on %s is not defined\n",
 9990|     22|		 prefix, localname, NULL);
 9991|     22|    }
 9992|  2.69k|    *pref = prefix;
 9993|  2.69k|    *URI = uri;
 9994|       |
 9995|       |    /*
 9996|       |     * SAX callback
 9997|       |     */
 9998|  2.69k|    if ((ctxt->sax != NULL) && (ctxt->sax->startElementNs != NULL) &&
  ------------------
  |  Branch (9998:9): [True: 2.69k, False: 0]
  |  Branch (9998:32): [True: 2.69k, False: 0]
  ------------------
 9999|  2.69k|	(!ctxt->disableSAX)) {
  ------------------
  |  Branch (9999:2): [True: 2.20k, False: 491]
  ------------------
10000|  2.20k|	if (nbNs > 0)
  ------------------
  |  Branch (10000:6): [True: 260, False: 1.94k]
  ------------------
10001|    260|	    ctxt->sax->startElementNs(ctxt->userData, localname, prefix, uri,
10002|    260|                          nbNs, ctxt->nsTab + 2 * (ctxt->nsNr - nbNs),
10003|    260|			  nbatts / 5, nbdef, atts);
10004|  1.94k|	else
10005|  1.94k|	    ctxt->sax->startElementNs(ctxt->userData, localname, prefix, uri,
10006|  1.94k|                          0, NULL, nbatts / 5, nbdef, atts);
10007|  2.20k|    }
10008|       |
10009|  2.69k|done:
10010|       |    /*
10011|       |     * Free allocated attribute values
10012|       |     */
10013|  2.69k|    if (attval != 0) {
  ------------------
  |  Branch (10013:9): [True: 7, False: 2.68k]
  ------------------
10014|     18|	for (i = 0, j = 0; j < nratts; i += 5, j++)
  ------------------
  |  Branch (10014:21): [True: 11, False: 7]
  ------------------
10015|     11|	    if (ctxt->attallocs[j] & 0x80000000)
  ------------------
  |  Branch (10015:10): [True: 7, False: 4]
  ------------------
10016|      7|	        xmlFree((xmlChar *) atts[i+3]);
10017|      7|    }
10018|       |
10019|  2.69k|    *nbNsPtr = nbNs;
10020|  2.69k|    return(localname);
10021|  2.69k|}
parser.c:xmlParserNsStartElement:
 1462|  2.73k|xmlParserNsStartElement(xmlParserNsData *nsdb) {
 1463|  2.73k|    if (nsdb->elementId == UINT_MAX)
  ------------------
  |  Branch (1463:9): [True: 0, False: 2.73k]
  ------------------
 1464|      0|        return(-1);
 1465|  2.73k|    nsdb->elementId++;
 1466|       |
 1467|  2.73k|    return(0);
 1468|  2.73k|}
parser.c:xmlParseQNameHashed:
 8943|  4.30k|xmlParseQNameHashed(xmlParserCtxtPtr ctxt, xmlHashedString *prefix) {
 8944|  4.30k|    xmlHashedString l, p;
 8945|  4.30k|    int start;
 8946|       |
 8947|  4.30k|    l.name = NULL;
 8948|  4.30k|    p.name = NULL;
 8949|       |
 8950|  4.30k|    GROW;
  ------------------
  |  | 2270|  4.30k|#define GROW if (ctxt->input->end - ctxt->input->cur < INPUT_CHUNK)	\
  |  |  ------------------
  |  |  |  |   97|  4.30k|#define INPUT_CHUNK	250
  |  |  ------------------
  |  |  |  Branch (2270:18): [True: 2.01k, False: 2.28k]
  |  |  ------------------
  |  | 2271|  4.30k|	xmlParserGrow(ctxt);
  ------------------
 8951|  4.30k|    if (ctxt->instate == XML_PARSER_EOF)
  ------------------
  |  Branch (8951:9): [True: 0, False: 4.30k]
  ------------------
 8952|      0|        return(l);
 8953|  4.30k|    start = CUR_PTR - BASE_PTR;
  ------------------
  |  | 2224|  4.30k|#define CUR_PTR ctxt->input->cur
  ------------------
                  start = CUR_PTR - BASE_PTR;
  ------------------
  |  | 2225|  4.30k|#define BASE_PTR ctxt->input->base
  ------------------
 8954|       |
 8955|  4.30k|    l = xmlParseNCName(ctxt);
 8956|  4.30k|    if ((l.name != NULL) && (CUR == ':')) {
  ------------------
  |  | 2222|  4.23k|#define CUR (*ctxt->input->cur)
  ------------------
  |  Branch (8956:9): [True: 4.23k, False: 67]
  |  Branch (8956:29): [True: 1.68k, False: 2.55k]
  ------------------
 8957|  1.68k|        NEXT;
  ------------------
  |  | 2275|  1.68k|#define NEXT xmlNextChar(ctxt)
  ------------------
 8958|  1.68k|	p = l;
 8959|  1.68k|	l = xmlParseNCName(ctxt);
 8960|  1.68k|    }
 8961|  4.30k|    if ((l.name == NULL) || (CUR == ':')) {
  ------------------
  |  | 2222|  4.23k|#define CUR (*ctxt->input->cur)
  ------------------
  |  Branch (8961:9): [True: 71, False: 4.23k]
  |  Branch (8961:29): [True: 4, False: 4.23k]
  ------------------
 8962|     75|        xmlChar *tmp;
 8963|       |
 8964|     75|        l.name = NULL;
 8965|     75|        p.name = NULL;
 8966|     75|        if (ctxt->instate == XML_PARSER_EOF)
  ------------------
  |  Branch (8966:13): [True: 0, False: 75]
  ------------------
 8967|      0|            return(l);
 8968|     75|        if ((CUR != ':') && (CUR_PTR <= BASE_PTR + start))
  ------------------
  |  | 2222|     75|#define CUR (*ctxt->input->cur)
  ------------------
                      if ((CUR != ':') && (CUR_PTR <= BASE_PTR + start))
  ------------------
  |  | 2224|     71|#define CUR_PTR ctxt->input->cur
  ------------------
                      if ((CUR != ':') && (CUR_PTR <= BASE_PTR + start))
  ------------------
  |  | 2225|     71|#define BASE_PTR ctxt->input->base
  ------------------
  |  Branch (8968:13): [True: 71, False: 4]
  |  Branch (8968:29): [True: 67, False: 4]
  ------------------
 8969|     67|            return(l);
 8970|      8|        tmp = xmlParseNmtoken(ctxt);
 8971|      8|        if (tmp != NULL)
  ------------------
  |  Branch (8971:13): [True: 4, False: 4]
  ------------------
 8972|      4|            xmlFree(tmp);
 8973|      8|        if (ctxt->instate == XML_PARSER_EOF)
  ------------------
  |  Branch (8973:13): [True: 0, False: 8]
  ------------------
 8974|      0|            return(l);
 8975|      8|        l = xmlDictLookupHashed(ctxt->dict, BASE_PTR + start,
  ------------------
  |  | 2225|      8|#define BASE_PTR ctxt->input->base
  ------------------
 8976|      8|                                CUR_PTR - (BASE_PTR + start));
  ------------------
  |  | 2224|      8|#define CUR_PTR ctxt->input->cur
  ------------------
                                              CUR_PTR - (BASE_PTR + start));
  ------------------
  |  | 2225|      8|#define BASE_PTR ctxt->input->base
  ------------------
 8977|      8|        xmlNsErr(ctxt, XML_NS_ERR_QNAME,
 8978|      8|                 "Failed to parse QName '%s'\n", l.name, NULL, NULL);
 8979|      8|    }
 8980|       |
 8981|  4.23k|    *prefix = p;
 8982|  4.23k|    return(l);
 8983|  4.30k|}
parser.c:xmlParseNCName:
 3624|  5.99k|xmlParseNCName(xmlParserCtxtPtr ctxt) {
 3625|  5.99k|    const xmlChar *in, *e;
 3626|  5.99k|    xmlHashedString ret;
 3627|  5.99k|    size_t count = 0;
 3628|  5.99k|    size_t maxLength = (ctxt->options & XML_PARSE_HUGE) ?
  ------------------
  |  Branch (3628:24): [True: 0, False: 5.99k]
  ------------------
 3629|      0|                       XML_MAX_TEXT_LENGTH :
  ------------------
  |  |   42|      0|#define XML_MAX_TEXT_LENGTH 10000000
  ------------------
 3630|  5.99k|                       XML_MAX_NAME_LENGTH;
  ------------------
  |  |   61|  11.9k|#define XML_MAX_NAME_LENGTH 50000
  ------------------
 3631|       |
 3632|  5.99k|    ret.name = NULL;
 3633|       |
 3634|       |    /*
 3635|       |     * Accelerator for simple ASCII names
 3636|       |     */
 3637|  5.99k|    in = ctxt->input->cur;
 3638|  5.99k|    e = ctxt->input->end;
 3639|  5.99k|    if ((((*in >= 0x61) && (*in <= 0x7A)) ||
  ------------------
  |  Branch (3639:11): [True: 5.92k, False: 68]
  |  Branch (3639:28): [True: 5.92k, False: 5]
  ------------------
 3640|  5.99k|	 ((*in >= 0x41) && (*in <= 0x5A)) ||
  ------------------
  |  Branch (3640:4): [True: 5, False: 68]
  |  Branch (3640:21): [True: 0, False: 5]
  ------------------
 3641|  5.99k|	 (*in == '_')) && (in < e)) {
  ------------------
  |  Branch (3641:3): [True: 0, False: 73]
  |  Branch (3641:20): [True: 5.92k, False: 0]
  ------------------
 3642|  5.92k|	in++;
 3643|  28.1k|	while ((((*in >= 0x61) && (*in <= 0x7A)) ||
  ------------------
  |  Branch (3643:11): [True: 20.7k, False: 7.42k]
  |  Branch (3643:28): [True: 20.7k, False: 14]
  ------------------
 3644|  28.1k|	        ((*in >= 0x41) && (*in <= 0x5A)) ||
  ------------------
  |  Branch (3644:11): [True: 24, False: 7.41k]
  |  Branch (3644:28): [True: 8, False: 16]
  ------------------
 3645|  28.1k|	        ((*in >= 0x30) && (*in <= 0x39)) ||
  ------------------
  |  Branch (3645:11): [True: 5.86k, False: 1.56k]
  |  Branch (3645:28): [True: 1.49k, False: 4.37k]
  ------------------
 3646|  28.1k|	        (*in == '_') || (*in == '-') ||
  ------------------
  |  Branch (3646:10): [True: 1, False: 5.93k]
  |  Branch (3646:26): [True: 10, False: 5.92k]
  ------------------
 3647|  28.1k|	        (*in == '.')) && (in < e))
  ------------------
  |  Branch (3647:10): [True: 6, False: 5.92k]
  |  Branch (3647:27): [True: 22.2k, False: 0]
  ------------------
 3648|  22.2k|	    in++;
 3649|  5.92k|	if (in >= e)
  ------------------
  |  Branch (3649:6): [True: 4, False: 5.91k]
  ------------------
 3650|      4|	    goto complex;
 3651|  5.91k|	if ((*in > 0) && (*in < 0x80)) {
  ------------------
  |  Branch (3651:6): [True: 5.91k, False: 2]
  |  Branch (3651:19): [True: 5.90k, False: 11]
  ------------------
 3652|  5.90k|	    count = in - ctxt->input->cur;
 3653|  5.90k|            if (count > maxLength) {
  ------------------
  |  Branch (3653:17): [True: 0, False: 5.90k]
  ------------------
 3654|      0|                xmlFatalErr(ctxt, XML_ERR_NAME_TOO_LONG, "NCName");
 3655|      0|                return(ret);
 3656|      0|            }
 3657|  5.90k|	    ret = xmlDictLookupHashed(ctxt->dict, ctxt->input->cur, count);
 3658|  5.90k|	    ctxt->input->cur = in;
 3659|  5.90k|	    ctxt->input->col += count;
 3660|  5.90k|	    if (ret.name == NULL) {
  ------------------
  |  Branch (3660:10): [True: 0, False: 5.90k]
  ------------------
 3661|      0|	        xmlErrMemory(ctxt, NULL);
 3662|      0|	    }
 3663|  5.90k|	    return(ret);
 3664|  5.90k|	}
 3665|  5.91k|    }
 3666|     90|complex:
 3667|     90|    return(xmlParseNCNameComplex(ctxt));
 3668|  5.99k|}
parser.c:xmlParseNCNameComplex:
 3569|     90|xmlParseNCNameComplex(xmlParserCtxtPtr ctxt) {
 3570|     90|    xmlHashedString ret;
 3571|     90|    int len = 0, l;
 3572|     90|    int c;
 3573|     90|    int maxLength = (ctxt->options & XML_PARSE_HUGE) ?
  ------------------
  |  Branch (3573:21): [True: 0, False: 90]
  ------------------
 3574|      0|                    XML_MAX_TEXT_LENGTH :
  ------------------
  |  |   42|      0|#define XML_MAX_TEXT_LENGTH 10000000
  ------------------
 3575|     90|                    XML_MAX_NAME_LENGTH;
  ------------------
  |  |   61|     90|#define XML_MAX_NAME_LENGTH 50000
  ------------------
 3576|     90|    size_t startPosition = 0;
 3577|       |
 3578|     90|    ret.name = NULL;
 3579|     90|    ret.hashValue = 0;
 3580|       |
 3581|       |    /*
 3582|       |     * Handler for more complex cases
 3583|       |     */
 3584|     90|    startPosition = CUR_PTR - BASE_PTR;
  ------------------
  |  | 2224|     90|#define CUR_PTR ctxt->input->cur
  ------------------
                  startPosition = CUR_PTR - BASE_PTR;
  ------------------
  |  | 2225|     90|#define BASE_PTR ctxt->input->base
  ------------------
 3585|     90|    c = CUR_CHAR(l);
  ------------------
  |  | 2291|     90|#define CUR_CHAR(l) xmlCurrentChar(ctxt, &l)
  ------------------
 3586|     90|    if ((c == ' ') || (c == '>') || (c == '/') || /* accelerators */
  ------------------
  |  Branch (3586:9): [True: 4, False: 86]
  |  Branch (3586:23): [True: 0, False: 86]
  |  Branch (3586:37): [True: 7, False: 79]
  ------------------
 3587|     90|	(!xmlIsNameStartChar(ctxt, c) || (c == ':'))) {
  ------------------
  |  Branch (3587:3): [True: 60, False: 19]
  |  Branch (3587:35): [True: 0, False: 19]
  ------------------
 3588|     71|	return(ret);
 3589|     71|    }
 3590|       |
 3591|    244|    while ((c != ' ') && (c != '>') && (c != '/') && /* test bigname.xml */
  ------------------
  |  Branch (3591:12): [True: 242, False: 2]
  |  Branch (3591:26): [True: 240, False: 2]
  |  Branch (3591:40): [True: 240, False: 0]
  ------------------
 3592|    244|	   (xmlIsNameChar(ctxt, c) && (c != ':'))) {
  ------------------
  |  Branch (3592:6): [True: 225, False: 15]
  |  Branch (3592:32): [True: 225, False: 0]
  ------------------
 3593|    225|        if (len <= INT_MAX - l)
  ------------------
  |  Branch (3593:13): [True: 225, False: 0]
  ------------------
 3594|    225|	    len += l;
 3595|    225|	NEXTL(l);
  ------------------
  |  | 2284|    225|#define NEXTL(l) do {							\
  |  | 2285|    225|    if (*(ctxt->input->cur) == '\n') {					\
  |  |  ------------------
  |  |  |  Branch (2285:9): [True: 0, False: 225]
  |  |  ------------------
  |  | 2286|      0|	ctxt->input->line++; ctxt->input->col = 1;			\
  |  | 2287|    225|    } else ctxt->input->col++;						\
  |  | 2288|    225|    ctxt->input->cur += l;				\
  |  | 2289|    225|  } while (0)
  |  |  ------------------
  |  |  |  Branch (2289:12): [Folded - Ignored]
  |  |  ------------------
  ------------------
 3596|    225|	c = CUR_CHAR(l);
  ------------------
  |  | 2291|    225|#define CUR_CHAR(l) xmlCurrentChar(ctxt, &l)
  ------------------
 3597|    225|    }
 3598|     19|    if (ctxt->instate == XML_PARSER_EOF)
  ------------------
  |  Branch (3598:9): [True: 0, False: 19]
  ------------------
 3599|      0|        return(ret);
 3600|     19|    if (len > maxLength) {
  ------------------
  |  Branch (3600:9): [True: 0, False: 19]
  ------------------
 3601|      0|        xmlFatalErr(ctxt, XML_ERR_NAME_TOO_LONG, "NCName");
 3602|      0|        return(ret);
 3603|      0|    }
 3604|     19|    ret = xmlDictLookupHashed(ctxt->dict, (BASE_PTR + startPosition), len);
  ------------------
  |  | 2225|     19|#define BASE_PTR ctxt->input->base
  ------------------
 3605|     19|    return(ret);
 3606|     19|}
parser.c:xmlParseAttribute2:
 9282|  1.53k|{
 9283|  1.53k|    xmlHashedString hname;
 9284|  1.53k|    const xmlChar *prefix, *name;
 9285|  1.53k|    xmlChar *val, *internal_val = NULL;
 9286|  1.53k|    int normalize = 0;
 9287|       |
 9288|  1.53k|    *value = NULL;
 9289|  1.53k|    GROW;
  ------------------
  |  | 2270|  1.53k|#define GROW if (ctxt->input->end - ctxt->input->cur < INPUT_CHUNK)	\
  |  |  ------------------
  |  |  |  |   97|  1.53k|#define INPUT_CHUNK	250
  |  |  ------------------
  |  |  |  Branch (2270:18): [True: 771, False: 766]
  |  |  ------------------
  |  | 2271|  1.53k|	xmlParserGrow(ctxt);
  ------------------
 9290|  1.53k|    hname = xmlParseQNameHashed(ctxt, hprefix);
 9291|  1.53k|    if (hname.name == NULL) {
  ------------------
  |  Branch (9291:9): [True: 26, False: 1.51k]
  ------------------
 9292|     26|        xmlFatalErrMsg(ctxt, XML_ERR_NAME_REQUIRED,
 9293|     26|                       "error parsing attribute name\n");
 9294|     26|        return(hname);
 9295|     26|    }
 9296|  1.51k|    name = hname.name;
 9297|  1.51k|    if (hprefix->name != NULL)
  ------------------
  |  Branch (9297:9): [True: 338, False: 1.17k]
  ------------------
 9298|    338|        prefix = hprefix->name;
 9299|  1.17k|    else
 9300|  1.17k|        prefix = NULL;
 9301|       |
 9302|       |    /*
 9303|       |     * get the type if needed
 9304|       |     */
 9305|  1.51k|    if (ctxt->attsSpecial != NULL) {
  ------------------
  |  Branch (9305:9): [True: 22, False: 1.48k]
  ------------------
 9306|     22|        int type;
 9307|       |
 9308|     22|        type = (int) (ptrdiff_t) xmlHashQLookup2(ctxt->attsSpecial,
 9309|     22|                                                 pref, elem,
 9310|     22|                                                 prefix, name);
 9311|     22|        if (type != 0)
  ------------------
  |  Branch (9311:13): [True: 18, False: 4]
  ------------------
 9312|     18|            normalize = 1;
 9313|     22|    }
 9314|       |
 9315|       |    /*
 9316|       |     * read the value
 9317|       |     */
 9318|  1.51k|    SKIP_BLANKS;
  ------------------
  |  | 2273|  1.51k|#define SKIP_BLANKS xmlSkipBlankChars(ctxt)
  ------------------
 9319|  1.51k|    if (RAW == '=') {
  ------------------
  |  | 2221|  1.51k|#define RAW (*ctxt->input->cur)
  ------------------
  |  Branch (9319:9): [True: 1.48k, False: 26]
  ------------------
 9320|  1.48k|        NEXT;
  ------------------
  |  | 2275|  1.48k|#define NEXT xmlNextChar(ctxt)
  ------------------
 9321|  1.48k|        SKIP_BLANKS;
  ------------------
  |  | 2273|  1.48k|#define SKIP_BLANKS xmlSkipBlankChars(ctxt)
  ------------------
 9322|  1.48k|        val = xmlParseAttValueInternal(ctxt, len, alloc, normalize);
 9323|  1.48k|        if (val == NULL) {
  ------------------
  |  Branch (9323:13): [True: 9, False: 1.47k]
  ------------------
 9324|      9|            hname.name = NULL;
 9325|      9|            return(hname);
 9326|      9|        }
 9327|  1.47k|	if (normalize) {
  ------------------
  |  Branch (9327:6): [True: 18, False: 1.45k]
  ------------------
 9328|       |	    /*
 9329|       |	     * Sometimes a second normalisation pass for spaces is needed
 9330|       |	     * but that only happens if charrefs or entities references
 9331|       |	     * have been used in the attribute value, i.e. the attribute
 9332|       |	     * value have been extracted in an allocated string already.
 9333|       |	     */
 9334|     18|	    if (*alloc) {
  ------------------
  |  Branch (9334:10): [True: 0, False: 18]
  ------------------
 9335|      0|	        const xmlChar *val2;
 9336|       |
 9337|      0|	        val2 = xmlAttrNormalizeSpace2(ctxt, val, len);
 9338|      0|		if ((val2 != NULL) && (val2 != val)) {
  ------------------
  |  Branch (9338:7): [True: 0, False: 0]
  |  Branch (9338:25): [True: 0, False: 0]
  ------------------
 9339|      0|		    xmlFree(val);
 9340|      0|		    val = (xmlChar *) val2;
 9341|      0|		}
 9342|      0|	    }
 9343|     18|	}
 9344|  1.47k|        ctxt->instate = XML_PARSER_CONTENT;
 9345|  1.47k|    } else {
 9346|     26|        xmlFatalErrMsgStr(ctxt, XML_ERR_ATTRIBUTE_WITHOUT_VALUE,
 9347|     26|                          "Specification mandates value for attribute %s\n",
 9348|     26|                          name);
 9349|     26|        return(hname);
 9350|     26|    }
 9351|       |
 9352|  1.47k|    if (prefix == ctxt->str_xml) {
  ------------------
  |  Branch (9352:9): [True: 14, False: 1.46k]
  ------------------
 9353|       |        /*
 9354|       |         * Check that xml:lang conforms to the specification
 9355|       |         * No more registered as an error, just generate a warning now
 9356|       |         * since this was deprecated in XML second edition
 9357|       |         */
 9358|     14|        if ((ctxt->pedantic) && (xmlStrEqual(name, BAD_CAST "lang"))) {
  ------------------
  |  |   35|      0|#define BAD_CAST (xmlChar *)
  ------------------
  |  Branch (9358:13): [True: 0, False: 14]
  |  Branch (9358:33): [True: 0, False: 0]
  ------------------
 9359|      0|            internal_val = xmlStrndup(val, *len);
 9360|      0|            if (!xmlCheckLanguageID(internal_val)) {
  ------------------
  |  Branch (9360:17): [True: 0, False: 0]
  ------------------
 9361|      0|                xmlWarningMsg(ctxt, XML_WAR_LANG_VALUE,
 9362|      0|                              "Malformed value for xml:lang : %s\n",
 9363|      0|                              internal_val, NULL);
 9364|      0|            }
 9365|      0|        }
 9366|       |
 9367|       |        /*
 9368|       |         * Check that xml:space conforms to the specification
 9369|       |         */
 9370|     14|        if (xmlStrEqual(name, BAD_CAST "space")) {
  ------------------
  |  |   35|     14|#define BAD_CAST (xmlChar *)
  ------------------
  |  Branch (9370:13): [True: 0, False: 14]
  ------------------
 9371|      0|            internal_val = xmlStrndup(val, *len);
 9372|      0|            if (xmlStrEqual(internal_val, BAD_CAST "default"))
  ------------------
  |  |   35|      0|#define BAD_CAST (xmlChar *)
  ------------------
  |  Branch (9372:17): [True: 0, False: 0]
  ------------------
 9373|      0|                *(ctxt->space) = 0;
 9374|      0|            else if (xmlStrEqual(internal_val, BAD_CAST "preserve"))
  ------------------
  |  |   35|      0|#define BAD_CAST (xmlChar *)
  ------------------
  |  Branch (9374:22): [True: 0, False: 0]
  ------------------
 9375|      0|                *(ctxt->space) = 1;
 9376|      0|            else {
 9377|      0|                xmlWarningMsg(ctxt, XML_WAR_SPACE_VALUE,
 9378|      0|                              "Invalid value \"%s\" for xml:space : \"default\" or \"preserve\" expected\n",
 9379|      0|                              internal_val, NULL);
 9380|      0|            }
 9381|      0|        }
 9382|     14|        if (internal_val) {
  ------------------
  |  Branch (9382:13): [True: 0, False: 14]
  ------------------
 9383|      0|            xmlFree(internal_val);
 9384|      0|        }
 9385|     14|    }
 9386|       |
 9387|  1.47k|    *value = val;
 9388|  1.47k|    return (hname);
 9389|  1.51k|}
parser.c:xmlCtxtGrowAttrs:
 1853|    207|xmlCtxtGrowAttrs(xmlParserCtxtPtr ctxt, int nr) {
 1854|    207|    const xmlChar **atts;
 1855|    207|    unsigned *attallocs;
 1856|    207|    int maxatts;
 1857|       |
 1858|    207|    if (nr + 5 > ctxt->maxatts) {
  ------------------
  |  Branch (1858:9): [True: 207, False: 0]
  ------------------
 1859|    207|	maxatts = ctxt->maxatts == 0 ? 55 : (nr + 5) * 2;
  ------------------
  |  Branch (1859:12): [True: 207, False: 0]
  ------------------
 1860|    207|	atts = (const xmlChar **) xmlMalloc(
 1861|    207|				     maxatts * sizeof(const xmlChar *));
 1862|    207|	if (atts == NULL) goto mem_error;
  ------------------
  |  Branch (1862:6): [True: 0, False: 207]
  ------------------
 1863|    207|	attallocs = xmlRealloc(ctxt->attallocs,
 1864|    207|                               (maxatts / 5) * sizeof(attallocs[0]));
 1865|    207|	if (attallocs == NULL) {
  ------------------
  |  Branch (1865:6): [True: 0, False: 207]
  ------------------
 1866|      0|            xmlFree(atts);
 1867|      0|            goto mem_error;
 1868|      0|        }
 1869|    207|        if (ctxt->maxatts > 0)
  ------------------
  |  Branch (1869:13): [True: 0, False: 207]
  ------------------
 1870|      0|            memcpy(atts, ctxt->atts, ctxt->maxatts * sizeof(const xmlChar *));
 1871|    207|        xmlFree(ctxt->atts);
 1872|    207|	ctxt->atts = atts;
 1873|    207|	ctxt->attallocs = attallocs;
 1874|    207|	ctxt->maxatts = maxatts;
 1875|    207|    }
 1876|    207|    return(ctxt->maxatts);
 1877|      0|mem_error:
 1878|      0|    xmlErrMemory(ctxt, NULL);
 1879|      0|    return(-1);
 1880|    207|}
parser.c:xmlAttrHashInsert:
 9407|     55|                  const xmlChar *uri, unsigned hashValue, int aindex) {
 9408|     55|    xmlAttrHashBucket *table = ctxt->attrHash;
 9409|     55|    xmlAttrHashBucket *bucket;
 9410|     55|    unsigned hindex;
 9411|       |
 9412|     55|    hindex = hashValue & (size - 1);
 9413|     55|    bucket = &table[hindex];
 9414|       |
 9415|     55|    while (bucket->index >= 0) {
  ------------------
  |  Branch (9415:12): [True: 0, False: 55]
  ------------------
 9416|      0|        const xmlChar **atts = &ctxt->atts[bucket->index];
 9417|       |
 9418|      0|        if (name == atts[0]) {
  ------------------
  |  Branch (9418:13): [True: 0, False: 0]
  ------------------
 9419|      0|            int nsIndex = (int) (ptrdiff_t) atts[2];
 9420|       |
 9421|      0|            if ((nsIndex == NS_INDEX_EMPTY) ? (uri == NULL) :
  ------------------
  |  |   77|      0|#define NS_INDEX_EMPTY  INT_MAX
  ------------------
  |  Branch (9421:17): [True: 0, False: 0]
  |  Branch (9421:17): [True: 0, False: 0]
  ------------------
 9422|      0|                (nsIndex == NS_INDEX_XML) ? (uri == ctxt->str_xml) :
  ------------------
  |  |   78|      0|#define NS_INDEX_XML    (INT_MAX - 1)
  ------------------
  |  Branch (9422:17): [True: 0, False: 0]
  ------------------
 9423|      0|                (uri == ctxt->nsTab[nsIndex * 2 + 1]))
 9424|      0|                return(bucket->index);
 9425|      0|        }
 9426|       |
 9427|      0|        hindex++;
 9428|      0|        bucket++;
 9429|      0|        if (hindex >= size) {
  ------------------
  |  Branch (9429:13): [True: 0, False: 0]
  ------------------
 9430|      0|            hindex = 0;
 9431|      0|            bucket = table;
 9432|      0|        }
 9433|      0|    }
 9434|       |
 9435|     55|    bucket->index = aindex;
 9436|       |
 9437|     55|    return(INT_MAX);
 9438|     55|}
parser.c:xmlParserNsLookupUri:
 1532|  2.69k|xmlParserNsLookupUri(xmlParserCtxtPtr ctxt, const xmlHashedString *prefix) {
 1533|  2.69k|    const xmlChar *ret;
 1534|  2.69k|    int nsIndex;
 1535|       |
 1536|  2.69k|    if (prefix->name == ctxt->str_xml)
  ------------------
  |  Branch (1536:9): [True: 0, False: 2.69k]
  ------------------
 1537|      0|        return(ctxt->str_xml_ns);
 1538|       |
 1539|  2.69k|    nsIndex = xmlParserNsLookup(ctxt, prefix, NULL);
 1540|  2.69k|    if (nsIndex == INT_MAX)
  ------------------
  |  Branch (1540:9): [True: 1.40k, False: 1.29k]
  ------------------
 1541|  1.40k|        return(NULL);
 1542|       |
 1543|  1.29k|    ret = ctxt->nsTab[nsIndex * 2 + 1];
 1544|  1.29k|    if (ret[0] == 0)
  ------------------
  |  Branch (1544:9): [True: 0, False: 1.29k]
  ------------------
 1545|      0|        ret = NULL;
 1546|  1.29k|    return(ret);
 1547|  2.69k|}
parser.c:nameNsPush:
 2024|  2.23k|{
 2025|  2.23k|    xmlStartTag *tag;
 2026|       |
 2027|  2.23k|    if (ctxt->nameNr >= ctxt->nameMax) {
  ------------------
  |  Branch (2027:9): [True: 13, False: 2.21k]
  ------------------
 2028|     13|        const xmlChar * *tmp;
 2029|     13|        xmlStartTag *tmp2;
 2030|     13|        ctxt->nameMax *= 2;
 2031|     13|        tmp = (const xmlChar * *) xmlRealloc((xmlChar * *)ctxt->nameTab,
 2032|     13|                                    ctxt->nameMax *
 2033|     13|                                    sizeof(ctxt->nameTab[0]));
 2034|     13|        if (tmp == NULL) {
  ------------------
  |  Branch (2034:13): [True: 0, False: 13]
  ------------------
 2035|      0|	    ctxt->nameMax /= 2;
 2036|      0|	    goto mem_error;
 2037|      0|        }
 2038|     13|	ctxt->nameTab = tmp;
 2039|     13|        tmp2 = (xmlStartTag *) xmlRealloc((void * *)ctxt->pushTab,
 2040|     13|                                    ctxt->nameMax *
 2041|     13|                                    sizeof(ctxt->pushTab[0]));
 2042|     13|        if (tmp2 == NULL) {
  ------------------
  |  Branch (2042:13): [True: 0, False: 13]
  ------------------
 2043|      0|	    ctxt->nameMax /= 2;
 2044|      0|	    goto mem_error;
 2045|      0|        }
 2046|     13|	ctxt->pushTab = tmp2;
 2047|  2.21k|    } else if (ctxt->pushTab == NULL) {
  ------------------
  |  Branch (2047:16): [True: 313, False: 1.90k]
  ------------------
 2048|    313|        ctxt->pushTab = (xmlStartTag *) xmlMalloc(ctxt->nameMax *
 2049|    313|                                            sizeof(ctxt->pushTab[0]));
 2050|    313|        if (ctxt->pushTab == NULL)
  ------------------
  |  Branch (2050:13): [True: 0, False: 313]
  ------------------
 2051|      0|            goto mem_error;
 2052|    313|    }
 2053|  2.23k|    ctxt->nameTab[ctxt->nameNr] = value;
 2054|  2.23k|    ctxt->name = value;
 2055|  2.23k|    tag = &ctxt->pushTab[ctxt->nameNr];
 2056|  2.23k|    tag->prefix = prefix;
 2057|  2.23k|    tag->URI = URI;
 2058|  2.23k|    tag->line = line;
 2059|  2.23k|    tag->nsNr = nsNr;
 2060|  2.23k|    return (ctxt->nameNr++);
 2061|      0|mem_error:
 2062|      0|    xmlErrMemory(ctxt, NULL);
 2063|      0|    return (-1);
 2064|  2.23k|}
parser.c:xmlParseElementEnd:
10475|    841|xmlParseElementEnd(xmlParserCtxtPtr ctxt) {
10476|    841|    xmlNodePtr cur = ctxt->node;
10477|       |
10478|    841|    if (ctxt->nameNr <= 0) {
  ------------------
  |  Branch (10478:9): [True: 0, False: 841]
  ------------------
10479|      0|        if ((RAW == '<') && (NXT(1) == '/'))
  ------------------
  |  | 2221|      0|#define RAW (*ctxt->input->cur)
  ------------------
                      if ((RAW == '<') && (NXT(1) == '/'))
  ------------------
  |  | 2223|      0|#define NXT(val) ctxt->input->cur[(val)]
  ------------------
  |  Branch (10479:13): [True: 0, False: 0]
  |  Branch (10479:29): [True: 0, False: 0]
  ------------------
10480|      0|            SKIP(2);
  ------------------
  |  | 2245|      0|#define SKIP(val) do {							\
  |  | 2246|      0|    ctxt->input->cur += (val),ctxt->input->col+=(val);			\
  |  | 2247|      0|    if (*ctxt->input->cur == 0)						\
  |  |  ------------------
  |  |  |  Branch (2247:9): [True: 0, False: 0]
  |  |  ------------------
  |  | 2248|      0|        xmlParserGrow(ctxt);						\
  |  | 2249|      0|  } while (0)
  |  |  ------------------
  |  |  |  Branch (2249:12): [Folded - Ignored]
  |  |  ------------------
  ------------------
10481|      0|        return;
10482|      0|    }
10483|       |
10484|       |    /*
10485|       |     * parse the end of tag: '</' should be here.
10486|       |     */
10487|    841|    if (ctxt->sax2) {
  ------------------
  |  Branch (10487:9): [True: 840, False: 1]
  ------------------
10488|    840|	xmlParseEndTag2(ctxt, &ctxt->pushTab[ctxt->nameNr - 1]);
10489|    840|	namePop(ctxt);
10490|    840|    }
10491|      1|#ifdef LIBXML_SAX1_ENABLED
10492|      1|    else
10493|      1|	xmlParseEndTag1(ctxt, 0);
10494|    841|#endif /* LIBXML_SAX1_ENABLED */
10495|       |
10496|       |    /*
10497|       |     * Capture end position
10498|       |     */
10499|    841|    if (cur != NULL && ctxt->record_info) {
  ------------------
  |  Branch (10499:9): [True: 793, False: 48]
  |  Branch (10499:24): [True: 0, False: 793]
  ------------------
10500|      0|        xmlParserNodeInfoPtr node_info;
10501|       |
10502|      0|        node_info = (xmlParserNodeInfoPtr) xmlParserFindNodeInfo(ctxt, cur);
10503|      0|        if (node_info != NULL) {
  ------------------
  |  Branch (10503:13): [True: 0, False: 0]
  ------------------
10504|      0|            node_info->end_pos = ctxt->input->consumed +
10505|      0|                                 (CUR_PTR - ctxt->input->base);
  ------------------
  |  | 2224|      0|#define CUR_PTR ctxt->input->cur
  ------------------
10506|      0|            node_info->end_line = ctxt->input->line;
10507|      0|        }
10508|      0|    }
10509|    841|}
parser.c:xmlParseEndTag2:
10039|  1.34k|xmlParseEndTag2(xmlParserCtxtPtr ctxt, const xmlStartTag *tag) {
10040|  1.34k|    const xmlChar *name;
10041|       |
10042|  1.34k|    GROW;
  ------------------
  |  | 2270|  1.34k|#define GROW if (ctxt->input->end - ctxt->input->cur < INPUT_CHUNK)	\
  |  |  ------------------
  |  |  |  |   97|  1.34k|#define INPUT_CHUNK	250
  |  |  ------------------
  |  |  |  Branch (2270:18): [True: 713, False: 635]
  |  |  ------------------
  |  | 2271|  1.34k|	xmlParserGrow(ctxt);
  ------------------
10043|  1.34k|    if ((RAW != '<') || (NXT(1) != '/')) {
  ------------------
  |  | 2221|  1.34k|#define RAW (*ctxt->input->cur)
  ------------------
                  if ((RAW != '<') || (NXT(1) != '/')) {
  ------------------
  |  | 2223|  1.34k|#define NXT(val) ctxt->input->cur[(val)]
  ------------------
  |  Branch (10043:9): [True: 0, False: 1.34k]
  |  Branch (10043:25): [True: 0, False: 1.34k]
  ------------------
10044|      0|	xmlFatalErr(ctxt, XML_ERR_LTSLASH_REQUIRED, NULL);
10045|      0|	return;
10046|      0|    }
10047|  1.34k|    SKIP(2);
  ------------------
  |  | 2245|  1.34k|#define SKIP(val) do {							\
  |  | 2246|  1.34k|    ctxt->input->cur += (val),ctxt->input->col+=(val);			\
  |  | 2247|  1.34k|    if (*ctxt->input->cur == 0)						\
  |  |  ------------------
  |  |  |  Branch (2247:9): [True: 0, False: 1.34k]
  |  |  ------------------
  |  | 2248|  1.34k|        xmlParserGrow(ctxt);						\
  |  | 2249|  1.34k|  } while (0)
  |  |  ------------------
  |  |  |  Branch (2249:12): [Folded - Ignored]
  |  |  ------------------
  ------------------
10048|       |
10049|  1.34k|    if (tag->prefix == NULL)
  ------------------
  |  Branch (10049:9): [True: 1.05k, False: 292]
  ------------------
10050|  1.05k|        name = xmlParseNameAndCompare(ctxt, ctxt->name);
10051|    292|    else
10052|    292|        name = xmlParseQNameAndCompare(ctxt, ctxt->name, tag->prefix);
10053|       |
10054|       |    /*
10055|       |     * We should definitely be at the ending "S? '>'" part
10056|       |     */
10057|  1.34k|    GROW;
  ------------------
  |  | 2270|  1.34k|#define GROW if (ctxt->input->end - ctxt->input->cur < INPUT_CHUNK)	\
  |  |  ------------------
  |  |  |  |   97|  1.34k|#define INPUT_CHUNK	250
  |  |  ------------------
  |  |  |  Branch (2270:18): [True: 717, False: 631]
  |  |  ------------------
  |  | 2271|  1.34k|	xmlParserGrow(ctxt);
  ------------------
10058|  1.34k|    if (ctxt->instate == XML_PARSER_EOF)
  ------------------
  |  Branch (10058:9): [True: 0, False: 1.34k]
  ------------------
10059|      0|        return;
10060|  1.34k|    SKIP_BLANKS;
  ------------------
  |  | 2273|  1.34k|#define SKIP_BLANKS xmlSkipBlankChars(ctxt)
  ------------------
10061|  1.34k|    if ((!IS_BYTE_CHAR(RAW)) || (RAW != '>')) {
  ------------------
  |  |  113|  1.34k|#define IS_BYTE_CHAR(c)	 xmlIsChar_ch(c)
  |  |  ------------------
  |  |  |  |  108|  1.34k|#define xmlIsChar_ch(c)		(((0x9 <= (c)) && ((c) <= 0xa)) || \
  |  |  |  |  ------------------
  |  |  |  |  |  Branch (108:28): [True: 1.34k, False: 4]
  |  |  |  |  |  Branch (108:44): [True: 0, False: 1.34k]
  |  |  |  |  ------------------
  |  |  |  |  109|  1.34k|				 ((c) == 0xd) || \
  |  |  |  |  ------------------
  |  |  |  |  |  Branch (109:6): [True: 0, False: 1.34k]
  |  |  |  |  ------------------
  |  |  |  |  110|  1.34k|				  (0x20 <= (c)))
  |  |  |  |  ------------------
  |  |  |  |  |  Branch (110:7): [True: 1.33k, False: 16]
  |  |  |  |  ------------------
  |  |  ------------------
  ------------------
                  if ((!IS_BYTE_CHAR(RAW)) || (RAW != '>')) {
  ------------------
  |  | 2221|  1.33k|#define RAW (*ctxt->input->cur)
  ------------------
  |  Branch (10061:33): [True: 13, False: 1.31k]
  ------------------
10062|     29|	xmlFatalErr(ctxt, XML_ERR_GT_REQUIRED, NULL);
10063|     29|    } else
10064|  1.31k|	NEXT1;
  ------------------
  |  | 2277|  1.31k|#define NEXT1 {								\
  |  | 2278|  1.31k|	ctxt->input->col++;						\
  |  | 2279|  1.31k|	ctxt->input->cur++;						\
  |  | 2280|  1.31k|	if (*ctxt->input->cur == 0)					\
  |  |  ------------------
  |  |  |  Branch (2280:6): [True: 0, False: 1.31k]
  |  |  ------------------
  |  | 2281|  1.31k|	    xmlParserGrow(ctxt);						\
  |  | 2282|  1.31k|    }
  ------------------
10065|       |
10066|       |    /*
10067|       |     * [ WFC: Element Type Match ]
10068|       |     * The Name in an element's end-tag must match the element type in the
10069|       |     * start-tag.
10070|       |     *
10071|       |     */
10072|  1.34k|    if (name != (xmlChar*)1) {
  ------------------
  |  Branch (10072:9): [True: 78, False: 1.27k]
  ------------------
10073|     78|        if (name == NULL) name = BAD_CAST "unparsable";
  ------------------
  |  |   35|     12|#define BAD_CAST (xmlChar *)
  ------------------
  |  Branch (10073:13): [True: 12, False: 66]
  ------------------
10074|     78|        xmlFatalErrMsgStrIntStr(ctxt, XML_ERR_TAG_NAME_MISMATCH,
10075|     78|		     "Opening and ending tag mismatch: %s line %d and %s\n",
10076|     78|		                ctxt->name, tag->line, name);
10077|     78|    }
10078|       |
10079|       |    /*
10080|       |     * SAX: End of Tag
10081|       |     */
10082|  1.34k|    if ((ctxt->sax != NULL) && (ctxt->sax->endElementNs != NULL) &&
  ------------------
  |  Branch (10082:9): [True: 1.34k, False: 0]
  |  Branch (10082:32): [True: 1.34k, False: 0]
  ------------------
10083|  1.34k|	(!ctxt->disableSAX))
  ------------------
  |  Branch (10083:2): [True: 1.04k, False: 308]
  ------------------
10084|  1.04k|	ctxt->sax->endElementNs(ctxt->userData, ctxt->name, tag->prefix,
10085|  1.04k|                                tag->URI);
10086|       |
10087|  1.34k|    spacePop(ctxt);
10088|  1.34k|    if (tag->nsNr != 0)
  ------------------
  |  Branch (10088:9): [True: 158, False: 1.19k]
  ------------------
10089|    158|	xmlParserNsPop(ctxt, tag->nsNr);
10090|  1.34k|}
parser.c:xmlParseQNameAndCompare:
 9025|    292|                        xmlChar const *prefix) {
 9026|    292|    const xmlChar *cmp;
 9027|    292|    const xmlChar *in;
 9028|    292|    const xmlChar *ret;
 9029|    292|    const xmlChar *prefix2;
 9030|       |
 9031|    292|    if (prefix == NULL) return(xmlParseNameAndCompare(ctxt, name));
  ------------------
  |  Branch (9031:9): [True: 0, False: 292]
  ------------------
 9032|       |
 9033|    292|    GROW;
  ------------------
  |  | 2270|    292|#define GROW if (ctxt->input->end - ctxt->input->cur < INPUT_CHUNK)	\
  |  |  ------------------
  |  |  |  |   97|    292|#define INPUT_CHUNK	250
  |  |  ------------------
  |  |  |  Branch (2270:18): [True: 209, False: 83]
  |  |  ------------------
  |  | 2271|    292|	xmlParserGrow(ctxt);
  ------------------
 9034|    292|    in = ctxt->input->cur;
 9035|       |
 9036|    292|    cmp = prefix;
 9037|    904|    while (*in != 0 && *in == *cmp) {
  ------------------
  |  Branch (9037:12): [True: 904, False: 0]
  |  Branch (9037:24): [True: 612, False: 292]
  ------------------
 9038|    612|	++in;
 9039|    612|	++cmp;
 9040|    612|    }
 9041|    292|    if ((*cmp == 0) && (*in == ':')) {
  ------------------
  |  Branch (9041:9): [True: 286, False: 6]
  |  Branch (9041:24): [True: 283, False: 3]
  ------------------
 9042|    283|        in++;
 9043|    283|	cmp = name;
 9044|  2.27k|	while (*in != 0 && *in == *cmp) {
  ------------------
  |  Branch (9044:9): [True: 2.27k, False: 0]
  |  Branch (9044:21): [True: 1.98k, False: 283]
  ------------------
 9045|  1.98k|	    ++in;
 9046|  1.98k|	    ++cmp;
 9047|  1.98k|	}
 9048|    283|	if (*cmp == 0 && (*in == '>' || IS_BLANK_CH (*in))) {
  ------------------
  |  |  151|      2|#define IS_BLANK_CH(c)  xmlIsBlank_ch(c)
  |  |  ------------------
  |  |  |  |   88|      2|#define xmlIsBlank_ch(c)	(((c) == 0x20) || \
  |  |  |  |  ------------------
  |  |  |  |  |  Branch (88:27): [True: 0, False: 2]
  |  |  |  |  ------------------
  |  |  |  |   89|      2|				 ((0x9 <= (c)) && ((c) <= 0xa)) || \
  |  |  |  |  ------------------
  |  |  |  |  |  Branch (89:7): [True: 2, False: 0]
  |  |  |  |  |  Branch (89:23): [True: 0, False: 2]
  |  |  |  |  ------------------
  |  |  |  |   90|      2|				 ((c) == 0xd))
  |  |  |  |  ------------------
  |  |  |  |  |  Branch (90:6): [True: 0, False: 2]
  |  |  |  |  ------------------
  |  |  ------------------
  ------------------
  |  Branch (9048:6): [True: 259, False: 24]
  |  Branch (9048:20): [True: 257, False: 2]
  ------------------
 9049|       |	    /* success */
 9050|    257|            ctxt->input->col += in - ctxt->input->cur;
 9051|    257|	    ctxt->input->cur = in;
 9052|    257|	    return((const xmlChar*) 1);
 9053|    257|	}
 9054|    283|    }
 9055|       |    /*
 9056|       |     * all strings coms from the dictionary, equality can be done directly
 9057|       |     */
 9058|     35|    ret = xmlParseQName (ctxt, &prefix2);
 9059|     35|    if (ret == NULL)
  ------------------
  |  Branch (9059:9): [True: 0, False: 35]
  ------------------
 9060|      0|        return(NULL);
 9061|     35|    if ((ret == name) && (prefix == prefix2))
  ------------------
  |  Branch (9061:9): [True: 4, False: 31]
  |  Branch (9061:26): [True: 2, False: 2]
  ------------------
 9062|      2|	return((const xmlChar*) 1);
 9063|     33|    return ret;
 9064|     35|}
parser.c:xmlParseQName:
 9000|     35|xmlParseQName(xmlParserCtxtPtr ctxt, const xmlChar **prefix) {
 9001|     35|    xmlHashedString n, p;
 9002|       |
 9003|     35|    n = xmlParseQNameHashed(ctxt, &p);
 9004|     35|    if (n.name == NULL)
  ------------------
  |  Branch (9004:9): [True: 0, False: 35]
  ------------------
 9005|      0|        return(NULL);
 9006|     35|    *prefix = p.name;
 9007|     35|    return(n.name);
 9008|     35|}
parser.c:xmlParseInternalSubset:
 8533|      8|xmlParseInternalSubset(xmlParserCtxtPtr ctxt) {
 8534|       |    /*
 8535|       |     * Is there any DTD definition ?
 8536|       |     */
 8537|      8|    if (RAW == '[') {
  ------------------
  |  | 2221|      8|#define RAW (*ctxt->input->cur)
  ------------------
  |  Branch (8537:9): [True: 8, False: 0]
  ------------------
 8538|      8|        int baseInputNr = ctxt->inputNr;
 8539|      8|        ctxt->instate = XML_PARSER_DTD;
 8540|      8|        NEXT;
  ------------------
  |  | 2275|      8|#define NEXT xmlNextChar(ctxt)
  ------------------
 8541|       |	/*
 8542|       |	 * Parse the succession of Markup declarations and
 8543|       |	 * PEReferences.
 8544|       |	 * Subsequence (markupdecl | PEReference | S)*
 8545|       |	 */
 8546|      8|	SKIP_BLANKS;
  ------------------
  |  | 2273|      8|#define SKIP_BLANKS xmlSkipBlankChars(ctxt)
  ------------------
 8547|     38|	while (((RAW != ']') || (ctxt->inputNr > baseInputNr)) &&
  ------------------
  |  | 2221|     38|#define RAW (*ctxt->input->cur)
  ------------------
  |  Branch (8547:10): [True: 30, False: 8]
  |  Branch (8547:26): [True: 0, False: 8]
  ------------------
 8548|     38|               (ctxt->instate != XML_PARSER_EOF)) {
  ------------------
  |  Branch (8548:16): [True: 30, False: 0]
  ------------------
 8549|       |
 8550|       |            /*
 8551|       |             * Conditional sections are allowed from external entities included
 8552|       |             * by PE References in the internal subset.
 8553|       |             */
 8554|     30|            if ((ctxt->inputNr > 1) && (ctxt->input->filename != NULL) &&
  ------------------
  |  Branch (8554:17): [True: 0, False: 30]
  |  Branch (8554:40): [True: 0, False: 0]
  ------------------
 8555|     30|                (RAW == '<') && (NXT(1) == '!') && (NXT(2) == '[')) {
  ------------------
  |  | 2221|      0|#define RAW (*ctxt->input->cur)
  ------------------
                              (RAW == '<') && (NXT(1) == '!') && (NXT(2) == '[')) {
  ------------------
  |  | 2223|      0|#define NXT(val) ctxt->input->cur[(val)]
  ------------------
                              (RAW == '<') && (NXT(1) == '!') && (NXT(2) == '[')) {
  ------------------
  |  | 2223|      0|#define NXT(val) ctxt->input->cur[(val)]
  ------------------
  |  Branch (8555:17): [True: 0, False: 0]
  |  Branch (8555:33): [True: 0, False: 0]
  |  Branch (8555:52): [True: 0, False: 0]
  ------------------
 8556|      0|                xmlParseConditionalSections(ctxt);
 8557|     30|            } else if ((RAW == '<') && ((NXT(1) == '!') || (NXT(1) == '?'))) {
  ------------------
  |  | 2221|     30|#define RAW (*ctxt->input->cur)
  ------------------
                          } else if ((RAW == '<') && ((NXT(1) == '!') || (NXT(1) == '?'))) {
  ------------------
  |  | 2223|     30|#define NXT(val) ctxt->input->cur[(val)]
  ------------------
                          } else if ((RAW == '<') && ((NXT(1) == '!') || (NXT(1) == '?'))) {
  ------------------
  |  | 2223|      0|#define NXT(val) ctxt->input->cur[(val)]
  ------------------
  |  Branch (8557:24): [True: 30, False: 0]
  |  Branch (8557:41): [True: 30, False: 0]
  |  Branch (8557:60): [True: 0, False: 0]
  ------------------
 8558|     30|	        xmlParseMarkupDecl(ctxt);
 8559|     30|            } else if (RAW == '%') {
  ------------------
  |  | 2221|      0|#define RAW (*ctxt->input->cur)
  ------------------
  |  Branch (8559:24): [True: 0, False: 0]
  ------------------
 8560|      0|	        xmlParsePEReference(ctxt);
 8561|      0|            } else {
 8562|      0|		xmlFatalErr(ctxt, XML_ERR_INTERNAL_ERROR,
 8563|      0|                        "xmlParseInternalSubset: error detected in"
 8564|      0|                        " Markup declaration\n");
 8565|      0|                xmlHaltParser(ctxt);
 8566|      0|                return;
 8567|      0|            }
 8568|     30|	    SKIP_BLANKS;
  ------------------
  |  | 2273|     30|#define SKIP_BLANKS xmlSkipBlankChars(ctxt)
  ------------------
 8569|     30|            SHRINK;
  ------------------
  |  | 2265|     30|    if (((ctxt->progressive == 0) || (ctxt->inputNr > 1)) && \
  |  |  ------------------
  |  |  |  Branch (2265:10): [True: 18, False: 12]
  |  |  |  Branch (2265:38): [True: 0, False: 12]
  |  |  ------------------
  |  | 2266|     30|        (ctxt->input->cur - ctxt->input->base > 2 * INPUT_CHUNK) && \
  |  |  ------------------
  |  |  |  |   97|     18|#define INPUT_CHUNK	250
  |  |  ------------------
  |  |  |  Branch (2266:9): [True: 0, False: 18]
  |  |  ------------------
  |  | 2267|     30|	(ctxt->input->end - ctxt->input->cur < 2 * INPUT_CHUNK)) \
  |  |  ------------------
  |  |  |  |   97|      0|#define INPUT_CHUNK	250
  |  |  ------------------
  |  |  |  Branch (2267:2): [True: 0, False: 0]
  |  |  ------------------
  |  | 2268|     30|	xmlParserShrink(ctxt);
  ------------------
 8570|     30|            GROW;
  ------------------
  |  | 2270|     30|#define GROW if (ctxt->input->end - ctxt->input->cur < INPUT_CHUNK)	\
  |  |  ------------------
  |  |  |  |   97|     30|#define INPUT_CHUNK	250
  |  |  ------------------
  |  |  |  Branch (2270:18): [True: 26, False: 4]
  |  |  ------------------
  |  | 2271|     30|	xmlParserGrow(ctxt);
  ------------------
 8571|     30|	}
 8572|      8|	if (RAW == ']') {
  ------------------
  |  | 2221|      8|#define RAW (*ctxt->input->cur)
  ------------------
  |  Branch (8572:6): [True: 8, False: 0]
  ------------------
 8573|      8|	    NEXT;
  ------------------
  |  | 2275|      8|#define NEXT xmlNextChar(ctxt)
  ------------------
 8574|      8|	    SKIP_BLANKS;
  ------------------
  |  | 2273|      8|#define SKIP_BLANKS xmlSkipBlankChars(ctxt)
  ------------------
 8575|      8|	}
 8576|      8|    }
 8577|       |
 8578|       |    /*
 8579|       |     * We should be at the end of the DOCTYPE declaration.
 8580|       |     */
 8581|      8|    if (RAW != '>') {
  ------------------
  |  | 2221|      8|#define RAW (*ctxt->input->cur)
  ------------------
  |  Branch (8581:9): [True: 0, False: 8]
  ------------------
 8582|      0|	xmlFatalErr(ctxt, XML_ERR_DOCTYPE_NOT_FINISHED, NULL);
 8583|      0|	return;
 8584|      0|    }
 8585|      8|    NEXT;
  ------------------
  |  | 2275|      8|#define NEXT xmlNextChar(ctxt)
  ------------------
 8586|      8|}
parser.c:xmlCleanSpecialAttr:
 1181|      8|{
 1182|      8|    if (ctxt->attsSpecial == NULL)
  ------------------
  |  Branch (1182:9): [True: 0, False: 8]
  ------------------
 1183|      0|        return;
 1184|       |
 1185|      8|    xmlHashScanFull(ctxt->attsSpecial, xmlCleanSpecialAttrCallback, ctxt);
 1186|       |
 1187|      8|    if (xmlHashSize(ctxt->attsSpecial) == 0) {
  ------------------
  |  Branch (1187:9): [True: 0, False: 8]
  ------------------
 1188|      0|        xmlHashFree(ctxt->attsSpecial, NULL);
 1189|      0|        ctxt->attsSpecial = NULL;
 1190|      0|    }
 1191|      8|    return;
 1192|      8|}
parser.c:xmlCleanSpecialAttrCallback:
 1163|      8|                            const xmlChar *unused ATTRIBUTE_UNUSED) {
 1164|      8|    xmlParserCtxtPtr ctxt = (xmlParserCtxtPtr) data;
 1165|       |
 1166|      8|    if (((ptrdiff_t) payload) == XML_ATTRIBUTE_CDATA) {
  ------------------
  |  Branch (1166:9): [True: 0, False: 8]
  ------------------
 1167|      0|        xmlHashRemoveEntry2(ctxt->attsSpecial, fullname, fullattr, NULL);
 1168|      0|    }
 1169|      8|}
parser.c:xmlParseTryOrFinish:
11585|    288|xmlParseTryOrFinish(xmlParserCtxtPtr ctxt, int terminate) {
11586|    288|    int ret = 0;
11587|    288|    size_t avail;
11588|    288|    xmlChar cur, next;
11589|       |
11590|    288|    if (ctxt->input == NULL)
  ------------------
  |  Branch (11590:9): [True: 0, False: 288]
  ------------------
11591|      0|        return(0);
11592|       |
11593|    288|    if ((ctxt->input != NULL) &&
  ------------------
  |  Branch (11593:9): [True: 288, False: 0]
  ------------------
11594|    288|        (ctxt->input->cur - ctxt->input->base > 4096)) {
  ------------------
  |  Branch (11594:9): [True: 3, False: 285]
  ------------------
11595|      3|        xmlParserShrink(ctxt);
11596|      3|    }
11597|       |
11598|  4.88k|    while (ctxt->instate != XML_PARSER_EOF) {
  ------------------
  |  Branch (11598:12): [True: 4.88k, False: 0]
  ------------------
11599|  4.88k|	if ((ctxt->errNo != XML_ERR_OK) && (ctxt->disableSAX == 1))
  ------------------
  |  Branch (11599:6): [True: 176, False: 4.70k]
  |  Branch (11599:37): [True: 100, False: 76]
  ------------------
11600|    100|	    return(0);
11601|       |
11602|  4.78k|        avail = ctxt->input->end - ctxt->input->cur;
11603|  4.78k|        if (avail < 1)
  ------------------
  |  Branch (11603:13): [True: 46, False: 4.73k]
  ------------------
11604|     46|	    goto done;
11605|  4.73k|        switch (ctxt->instate) {
11606|      0|            case XML_PARSER_EOF:
  ------------------
  |  Branch (11606:13): [True: 0, False: 4.73k]
  ------------------
11607|       |	        /*
11608|       |		 * Document parsing is done !
11609|       |		 */
11610|      0|	        goto done;
11611|    167|            case XML_PARSER_START:
  ------------------
  |  Branch (11611:13): [True: 167, False: 4.57k]
  ------------------
11612|       |                /*
11613|       |                 * Very first chars read from the document flow.
11614|       |                 */
11615|    167|                if ((!terminate) && (avail < 4))
  ------------------
  |  Branch (11615:21): [True: 167, False: 0]
  |  Branch (11615:37): [True: 0, False: 167]
  ------------------
11616|      0|                    goto done;
11617|       |
11618|       |                /*
11619|       |                 * We need more bytes to detect EBCDIC code pages.
11620|       |                 * See xmlDetectEBCDIC.
11621|       |                 */
11622|    167|                if ((CMP4(CUR_PTR, 0x4C, 0x6F, 0xA7, 0x94)) &&
  ------------------
  |  | 2228|    167|  ( ((unsigned char *) s)[ 0 ] == c1 && ((unsigned char *) s)[ 1 ] == c2 && \
  |  |  ------------------
  |  |  |  Branch (2228:5): [True: 0, False: 167]
  |  |  |  Branch (2228:41): [True: 0, False: 0]
  |  |  ------------------
  |  | 2229|    167|    ((unsigned char *) s)[ 2 ] == c3 && ((unsigned char *) s)[ 3 ] == c4 )
  |  |  ------------------
  |  |  |  Branch (2229:5): [True: 0, False: 0]
  |  |  |  Branch (2229:41): [True: 0, False: 0]
  |  |  ------------------
  ------------------
11623|    167|                    (!terminate) && (avail < 200))
  ------------------
  |  Branch (11623:21): [True: 0, False: 0]
  |  Branch (11623:37): [True: 0, False: 0]
  ------------------
11624|      0|                    goto done;
11625|       |
11626|    167|                xmlDetectEncoding(ctxt);
11627|    167|                if (ctxt->instate == XML_PARSER_EOF)
  ------------------
  |  Branch (11627:21): [True: 0, False: 167]
  ------------------
11628|      0|                    goto done;
11629|    167|                ctxt->instate = XML_PARSER_XML_DECL;
11630|    167|		break;
11631|       |
11632|    174|            case XML_PARSER_XML_DECL:
  ------------------
  |  Branch (11632:13): [True: 174, False: 4.56k]
  ------------------
11633|    174|		if ((!terminate) && (avail < 2))
  ------------------
  |  Branch (11633:7): [True: 168, False: 6]
  |  Branch (11633:23): [True: 0, False: 168]
  ------------------
11634|      0|		    goto done;
11635|    174|		cur = ctxt->input->cur[0];
11636|    174|		next = ctxt->input->cur[1];
11637|    174|	        if ((cur == '<') && (next == '?')) {
  ------------------
  |  Branch (11637:14): [True: 166, False: 8]
  |  Branch (11637:30): [True: 44, False: 122]
  ------------------
11638|       |		    /* PI or XML decl */
11639|     44|		    if ((!terminate) &&
  ------------------
  |  Branch (11639:11): [True: 38, False: 6]
  ------------------
11640|     44|                        (!xmlParseLookupString(ctxt, 2, "?>", 2)))
  ------------------
  |  Branch (11640:25): [True: 7, False: 31]
  ------------------
11641|      7|			goto done;
11642|     37|		    if ((ctxt->input->cur[2] == 'x') &&
  ------------------
  |  Branch (11642:11): [True: 37, False: 0]
  ------------------
11643|     37|			(ctxt->input->cur[3] == 'm') &&
  ------------------
  |  Branch (11643:4): [True: 36, False: 1]
  ------------------
11644|     37|			(ctxt->input->cur[4] == 'l') &&
  ------------------
  |  Branch (11644:4): [True: 36, False: 0]
  ------------------
11645|     37|			(IS_BLANK_CH(ctxt->input->cur[5]))) {
  ------------------
  |  |  151|     36|#define IS_BLANK_CH(c)  xmlIsBlank_ch(c)
  |  |  ------------------
  |  |  |  |   88|     36|#define xmlIsBlank_ch(c)	(((c) == 0x20) || \
  |  |  |  |  ------------------
  |  |  |  |  |  Branch (88:27): [True: 36, False: 0]
  |  |  |  |  ------------------
  |  |  |  |   89|     36|				 ((0x9 <= (c)) && ((c) <= 0xa)) || \
  |  |  |  |  ------------------
  |  |  |  |  |  Branch (89:7): [True: 0, False: 0]
  |  |  |  |  |  Branch (89:23): [True: 0, False: 0]
  |  |  |  |  ------------------
  |  |  |  |   90|     36|				 ((c) == 0xd))
  |  |  |  |  ------------------
  |  |  |  |  |  Branch (90:6): [True: 0, False: 0]
  |  |  |  |  ------------------
  |  |  ------------------
  ------------------
11646|     36|			ret += 5;
11647|     36|			xmlParseXMLDecl(ctxt);
11648|     36|			if (ctxt->errNo == XML_ERR_UNSUPPORTED_ENCODING) {
  ------------------
  |  Branch (11648:8): [True: 0, False: 36]
  ------------------
11649|       |			    /*
11650|       |			     * The XML REC instructs us to stop parsing right
11651|       |			     * here
11652|       |			     */
11653|      0|			    xmlHaltParser(ctxt);
11654|      0|			    return(0);
11655|      0|			}
11656|     36|		    } else {
11657|      1|			ctxt->version = xmlCharStrdup(XML_DEFAULT_VERSION);
  ------------------
  |  |   37|      1|#define XML_DEFAULT_VERSION	"1.0"
  ------------------
11658|      1|		    }
11659|    130|		} else {
11660|    130|		    ctxt->version = xmlCharStrdup(XML_DEFAULT_VERSION);
  ------------------
  |  |   37|    130|#define XML_DEFAULT_VERSION	"1.0"
  ------------------
11661|    130|		    if (ctxt->version == NULL) {
  ------------------
  |  Branch (11661:11): [True: 0, False: 130]
  ------------------
11662|      0|		        xmlErrMemory(ctxt, NULL);
11663|      0|			break;
11664|      0|		    }
11665|    130|		}
11666|    167|                if ((ctxt->sax) && (ctxt->sax->setDocumentLocator))
  ------------------
  |  Branch (11666:21): [True: 167, False: 0]
  |  Branch (11666:36): [True: 167, False: 0]
  ------------------
11667|    167|                    ctxt->sax->setDocumentLocator(ctxt->userData,
11668|    167|                                                  &xmlDefaultSAXLocator);
  ------------------
  |  |  861|    167|  #define xmlDefaultSAXLocator XML_GLOBAL_MACRO(xmlDefaultSAXLocator)
  |  |  ------------------
  |  |  |  |  500|    167|  #define XML_GLOBAL_MACRO(name) (*__##name())
  |  |  ------------------
  ------------------
11669|    167|                if ((ctxt->sax) && (ctxt->sax->startDocument) &&
  ------------------
  |  Branch (11669:21): [True: 167, False: 0]
  |  Branch (11669:36): [True: 167, False: 0]
  ------------------
11670|    167|                    (!ctxt->disableSAX))
  ------------------
  |  Branch (11670:21): [True: 160, False: 7]
  ------------------
11671|    160|                    ctxt->sax->startDocument(ctxt->userData);
11672|    167|                if (ctxt->instate == XML_PARSER_EOF)
  ------------------
  |  Branch (11672:21): [True: 0, False: 167]
  ------------------
11673|      0|                    goto done;
11674|    167|                ctxt->instate = XML_PARSER_MISC;
11675|    167|		break;
11676|  1.18k|            case XML_PARSER_START_TAG: {
  ------------------
  |  Branch (11676:13): [True: 1.18k, False: 3.55k]
  ------------------
11677|  1.18k|	        const xmlChar *name;
11678|  1.18k|		const xmlChar *prefix = NULL;
11679|  1.18k|		const xmlChar *URI = NULL;
11680|  1.18k|                int line = ctxt->input->line;
11681|  1.18k|		int nbNs = 0;
11682|       |
11683|  1.18k|		if ((!terminate) && (avail < 2))
  ------------------
  |  Branch (11683:7): [True: 1.16k, False: 24]
  |  Branch (11683:23): [True: 0, False: 1.16k]
  ------------------
11684|      0|		    goto done;
11685|  1.18k|		cur = ctxt->input->cur[0];
11686|  1.18k|	        if (cur != '<') {
  ------------------
  |  Branch (11686:14): [True: 8, False: 1.18k]
  ------------------
11687|      8|		    xmlFatalErrMsg(ctxt, XML_ERR_DOCUMENT_EMPTY,
11688|      8|                                   "Start tag expected, '<' not found");
11689|      8|		    xmlHaltParser(ctxt);
11690|      8|		    if ((ctxt->sax) && (ctxt->sax->endDocument != NULL))
  ------------------
  |  Branch (11690:11): [True: 8, False: 0]
  |  Branch (11690:26): [True: 8, False: 0]
  ------------------
11691|      8|			ctxt->sax->endDocument(ctxt->userData);
11692|      8|		    goto done;
11693|      8|		}
11694|  1.18k|		if ((!terminate) && (!xmlParseLookupGt(ctxt)))
  ------------------
  |  Branch (11694:7): [True: 1.15k, False: 24]
  |  Branch (11694:23): [True: 43, False: 1.11k]
  ------------------
11695|     43|                    goto done;
11696|  1.13k|		if (ctxt->spaceNr == 0)
  ------------------
  |  Branch (11696:7): [True: 0, False: 1.13k]
  ------------------
11697|      0|		    spacePush(ctxt, -1);
11698|  1.13k|		else if (*ctxt->space == -2)
  ------------------
  |  Branch (11698:12): [True: 1, False: 1.13k]
  ------------------
11699|      1|		    spacePush(ctxt, -1);
11700|  1.13k|		else
11701|  1.13k|		    spacePush(ctxt, *ctxt->space);
11702|  1.13k|#ifdef LIBXML_SAX1_ENABLED
11703|  1.13k|		if (ctxt->sax2)
  ------------------
  |  Branch (11703:7): [True: 1.13k, False: 2]
  ------------------
11704|  1.13k|#endif /* LIBXML_SAX1_ENABLED */
11705|  1.13k|		    name = xmlParseStartTag2(ctxt, &prefix, &URI, &nbNs);
11706|      2|#ifdef LIBXML_SAX1_ENABLED
11707|      2|		else
11708|      2|		    name = xmlParseStartTag(ctxt);
11709|  1.13k|#endif /* LIBXML_SAX1_ENABLED */
11710|  1.13k|		if (ctxt->instate == XML_PARSER_EOF)
  ------------------
  |  Branch (11710:7): [True: 0, False: 1.13k]
  ------------------
11711|      0|		    goto done;
11712|  1.13k|		if (name == NULL) {
  ------------------
  |  Branch (11712:7): [True: 18, False: 1.11k]
  ------------------
11713|     18|		    spacePop(ctxt);
11714|     18|		    xmlHaltParser(ctxt);
11715|     18|		    if ((ctxt->sax) && (ctxt->sax->endDocument != NULL))
  ------------------
  |  Branch (11715:11): [True: 18, False: 0]
  |  Branch (11715:26): [True: 18, False: 0]
  ------------------
11716|     18|			ctxt->sax->endDocument(ctxt->userData);
11717|     18|		    goto done;
11718|     18|		}
11719|  1.11k|#ifdef LIBXML_VALID_ENABLED
11720|       |		/*
11721|       |		 * [ VC: Root Element Type ]
11722|       |		 * The Name in the document type declaration must match
11723|       |		 * the element type of the root element.
11724|       |		 */
11725|  1.11k|		if (ctxt->validate && ctxt->wellFormed && ctxt->myDoc &&
  ------------------
  |  Branch (11725:7): [True: 0, False: 1.11k]
  |  Branch (11725:25): [True: 0, False: 0]
  |  Branch (11725:45): [True: 0, False: 0]
  ------------------
11726|  1.11k|		    ctxt->node && (ctxt->node == ctxt->myDoc->children))
  ------------------
  |  Branch (11726:7): [True: 0, False: 0]
  |  Branch (11726:21): [True: 0, False: 0]
  ------------------
11727|      0|		    ctxt->valid &= xmlValidateRoot(&ctxt->vctxt, ctxt->myDoc);
11728|  1.11k|#endif /* LIBXML_VALID_ENABLED */
11729|       |
11730|       |		/*
11731|       |		 * Check for an Empty Element.
11732|       |		 */
11733|  1.11k|		if ((RAW == '/') && (NXT(1) == '>')) {
  ------------------
  |  | 2221|  1.11k|#define RAW (*ctxt->input->cur)
  ------------------
              		if ((RAW == '/') && (NXT(1) == '>')) {
  ------------------
  |  | 2223|    422|#define NXT(val) ctxt->input->cur[(val)]
  ------------------
  |  Branch (11733:7): [True: 422, False: 697]
  |  Branch (11733:23): [True: 419, False: 3]
  ------------------
11734|    419|		    SKIP(2);
  ------------------
  |  | 2245|    419|#define SKIP(val) do {							\
  |  | 2246|    419|    ctxt->input->cur += (val),ctxt->input->col+=(val);			\
  |  | 2247|    419|    if (*ctxt->input->cur == 0)						\
  |  |  ------------------
  |  |  |  Branch (2247:9): [True: 3, False: 416]
  |  |  ------------------
  |  | 2248|    419|        xmlParserGrow(ctxt);						\
  |  | 2249|    419|  } while (0)
  |  |  ------------------
  |  |  |  Branch (2249:12): [Folded - Ignored]
  |  |  ------------------
  ------------------
11735|       |
11736|    419|		    if (ctxt->sax2) {
  ------------------
  |  Branch (11736:11): [True: 418, False: 1]
  ------------------
11737|    418|			if ((ctxt->sax != NULL) &&
  ------------------
  |  Branch (11737:8): [True: 418, False: 0]
  ------------------
11738|    418|			    (ctxt->sax->endElementNs != NULL) &&
  ------------------
  |  Branch (11738:8): [True: 418, False: 0]
  ------------------
11739|    418|			    (!ctxt->disableSAX))
  ------------------
  |  Branch (11739:8): [True: 417, False: 1]
  ------------------
11740|    417|			    ctxt->sax->endElementNs(ctxt->userData, name,
11741|    417|			                            prefix, URI);
11742|    418|			if (nbNs > 0)
  ------------------
  |  Branch (11742:8): [True: 3, False: 415]
  ------------------
11743|      3|			    xmlParserNsPop(ctxt, nbNs);
11744|    418|#ifdef LIBXML_SAX1_ENABLED
11745|    418|		    } else {
11746|      1|			if ((ctxt->sax != NULL) &&
  ------------------
  |  Branch (11746:8): [True: 1, False: 0]
  ------------------
11747|      1|			    (ctxt->sax->endElement != NULL) &&
  ------------------
  |  Branch (11747:8): [True: 1, False: 0]
  ------------------
11748|      1|			    (!ctxt->disableSAX))
  ------------------
  |  Branch (11748:8): [True: 1, False: 0]
  ------------------
11749|      1|			    ctxt->sax->endElement(ctxt->userData, name);
11750|      1|#endif /* LIBXML_SAX1_ENABLED */
11751|      1|		    }
11752|    419|		    spacePop(ctxt);
11753|    700|		} else if (RAW == '>') {
  ------------------
  |  | 2221|    700|#define RAW (*ctxt->input->cur)
  ------------------
  |  Branch (11753:14): [True: 653, False: 47]
  ------------------
11754|    653|		    NEXT;
  ------------------
  |  | 2275|    653|#define NEXT xmlNextChar(ctxt)
  ------------------
11755|    653|                    nameNsPush(ctxt, name, prefix, URI, line, nbNs);
11756|    653|		} else {
11757|     47|		    xmlFatalErrMsgStr(ctxt, XML_ERR_GT_REQUIRED,
11758|     47|					 "Couldn't find end of Start Tag %s\n",
11759|     47|					 name);
11760|     47|		    nodePop(ctxt);
11761|     47|		    spacePop(ctxt);
11762|     47|                    if (nbNs > 0)
  ------------------
  |  Branch (11762:25): [True: 15, False: 32]
  ------------------
11763|     15|                        xmlParserNsPop(ctxt, nbNs);
11764|     47|		}
11765|       |
11766|  1.11k|                if (ctxt->instate == XML_PARSER_EOF)
  ------------------
  |  Branch (11766:21): [True: 0, False: 1.11k]
  ------------------
11767|      0|                    goto done;
11768|  1.11k|                if (ctxt->nameNr == 0)
  ------------------
  |  Branch (11768:21): [True: 20, False: 1.09k]
  ------------------
11769|     20|                    ctxt->instate = XML_PARSER_EPILOG;
11770|  1.09k|                else
11771|  1.09k|                    ctxt->instate = XML_PARSER_CONTENT;
11772|  1.11k|                break;
11773|  1.11k|	    }
11774|  2.48k|            case XML_PARSER_CONTENT: {
  ------------------
  |  Branch (11774:13): [True: 2.48k, False: 2.25k]
  ------------------
11775|  2.48k|		cur = ctxt->input->cur[0];
11776|       |
11777|  2.48k|		if (cur == '<') {
  ------------------
  |  Branch (11777:7): [True: 1.53k, False: 955]
  ------------------
11778|  1.53k|                    if ((!terminate) && (avail < 2))
  ------------------
  |  Branch (11778:25): [True: 1.52k, False: 6]
  |  Branch (11778:41): [True: 3, False: 1.52k]
  ------------------
11779|      3|                        goto done;
11780|  1.52k|		    next = ctxt->input->cur[1];
11781|       |
11782|  1.52k|                    if (next == '/') {
  ------------------
  |  Branch (11782:25): [True: 509, False: 1.01k]
  ------------------
11783|    509|                        ctxt->instate = XML_PARSER_END_TAG;
11784|    509|                        break;
11785|  1.01k|                    } else if (next == '?') {
  ------------------
  |  Branch (11785:32): [True: 0, False: 1.01k]
  ------------------
11786|      0|                        if ((!terminate) &&
  ------------------
  |  Branch (11786:29): [True: 0, False: 0]
  ------------------
11787|      0|                            (!xmlParseLookupString(ctxt, 2, "?>", 2)))
  ------------------
  |  Branch (11787:29): [True: 0, False: 0]
  ------------------
11788|      0|                            goto done;
11789|      0|                        xmlParsePI(ctxt);
11790|      0|                        if (ctxt->instate == XML_PARSER_EOF)
  ------------------
  |  Branch (11790:29): [True: 0, False: 0]
  ------------------
11791|      0|                            goto done;
11792|      0|                        ctxt->instate = XML_PARSER_CONTENT;
11793|      0|                        break;
11794|  1.01k|                    } else if (next == '!') {
  ------------------
  |  Branch (11794:32): [True: 36, False: 982]
  ------------------
11795|     36|                        if ((!terminate) && (avail < 3))
  ------------------
  |  Branch (11795:29): [True: 30, False: 6]
  |  Branch (11795:45): [True: 0, False: 30]
  ------------------
11796|      0|                            goto done;
11797|     36|                        next = ctxt->input->cur[2];
11798|       |
11799|     36|                        if (next == '-') {
  ------------------
  |  Branch (11799:29): [True: 35, False: 1]
  ------------------
11800|     35|                            if ((!terminate) && (avail < 4))
  ------------------
  |  Branch (11800:33): [True: 29, False: 6]
  |  Branch (11800:49): [True: 0, False: 29]
  ------------------
11801|      0|                                goto done;
11802|     35|                            if (ctxt->input->cur[3] == '-') {
  ------------------
  |  Branch (11802:33): [True: 33, False: 2]
  ------------------
11803|     33|                                if ((!terminate) &&
  ------------------
  |  Branch (11803:37): [True: 27, False: 6]
  ------------------
11804|     33|                                    (!xmlParseLookupString(ctxt, 4, "-->", 3)))
  ------------------
  |  Branch (11804:37): [True: 6, False: 21]
  ------------------
11805|      6|                                    goto done;
11806|     27|                                xmlParseComment(ctxt);
11807|     27|                                if (ctxt->instate == XML_PARSER_EOF)
  ------------------
  |  Branch (11807:37): [True: 0, False: 27]
  ------------------
11808|      0|                                    goto done;
11809|     27|                                ctxt->instate = XML_PARSER_CONTENT;
11810|     27|                                break;
11811|     27|                            }
11812|     35|                        } else if (next == '[') {
  ------------------
  |  Branch (11812:36): [True: 0, False: 1]
  ------------------
11813|      0|                            if ((!terminate) && (avail < 9))
  ------------------
  |  Branch (11813:33): [True: 0, False: 0]
  |  Branch (11813:49): [True: 0, False: 0]
  ------------------
11814|      0|                                goto done;
11815|      0|                            if ((ctxt->input->cur[2] == '[') &&
  ------------------
  |  Branch (11815:33): [True: 0, False: 0]
  ------------------
11816|      0|                                (ctxt->input->cur[3] == 'C') &&
  ------------------
  |  Branch (11816:33): [True: 0, False: 0]
  ------------------
11817|      0|                                (ctxt->input->cur[4] == 'D') &&
  ------------------
  |  Branch (11817:33): [True: 0, False: 0]
  ------------------
11818|      0|                                (ctxt->input->cur[5] == 'A') &&
  ------------------
  |  Branch (11818:33): [True: 0, False: 0]
  ------------------
11819|      0|                                (ctxt->input->cur[6] == 'T') &&
  ------------------
  |  Branch (11819:33): [True: 0, False: 0]
  ------------------
11820|      0|                                (ctxt->input->cur[7] == 'A') &&
  ------------------
  |  Branch (11820:33): [True: 0, False: 0]
  ------------------
11821|      0|                                (ctxt->input->cur[8] == '[')) {
  ------------------
  |  Branch (11821:33): [True: 0, False: 0]
  ------------------
11822|      0|                                SKIP(9);
  ------------------
  |  | 2245|      0|#define SKIP(val) do {							\
  |  | 2246|      0|    ctxt->input->cur += (val),ctxt->input->col+=(val);			\
  |  | 2247|      0|    if (*ctxt->input->cur == 0)						\
  |  |  ------------------
  |  |  |  Branch (2247:9): [True: 0, False: 0]
  |  |  ------------------
  |  | 2248|      0|        xmlParserGrow(ctxt);						\
  |  | 2249|      0|  } while (0)
  |  |  ------------------
  |  |  |  Branch (2249:12): [Folded - Ignored]
  |  |  ------------------
  ------------------
11823|      0|                                ctxt->instate = XML_PARSER_CDATA_SECTION;
11824|      0|                                break;
11825|      0|                            }
11826|      0|                        }
11827|     36|                    }
11828|  1.52k|		} else if (cur == '&') {
  ------------------
  |  Branch (11828:14): [True: 1, False: 954]
  ------------------
11829|      1|		    if ((!terminate) && (!xmlParseLookupChar(ctxt, ';')))
  ------------------
  |  Branch (11829:11): [True: 1, False: 0]
  |  Branch (11829:27): [True: 0, False: 1]
  ------------------
11830|      0|			goto done;
11831|      1|		    xmlParseReference(ctxt);
11832|      1|                    break;
11833|    954|		} else {
11834|       |		    /* TODO Avoid the extra copy, handle directly !!! */
11835|       |		    /*
11836|       |		     * Goal of the following test is:
11837|       |		     *  - minimize calls to the SAX 'character' callback
11838|       |		     *    when they are mergeable
11839|       |		     *  - handle an problem for isBlank when we only parse
11840|       |		     *    a sequence of blank chars and the next one is
11841|       |		     *    not available to check against '<' presence.
11842|       |		     *  - tries to homogenize the differences in SAX
11843|       |		     *    callbacks between the push and pull versions
11844|       |		     *    of the parser.
11845|       |		     */
11846|    954|		    if (avail < XML_PARSER_BIG_BUFFER_SIZE) {
  ------------------
  |  |  166|    954|#define XML_PARSER_BIG_BUFFER_SIZE 300
  ------------------
  |  Branch (11846:11): [True: 717, False: 237]
  ------------------
11847|    717|			if ((!terminate) && (!xmlParseLookupCharData(ctxt)))
  ------------------
  |  Branch (11847:8): [True: 715, False: 2]
  |  Branch (11847:24): [True: 9, False: 706]
  ------------------
11848|      9|			    goto done;
11849|    717|                    }
11850|    945|                    ctxt->checkIndex = 0;
11851|    945|		    xmlParseCharDataInternal(ctxt, !terminate);
11852|    945|                    break;
11853|    954|		}
11854|       |
11855|    985|                ctxt->instate = XML_PARSER_START_TAG;
11856|    985|		break;
11857|  2.48k|	    }
11858|    516|            case XML_PARSER_END_TAG:
  ------------------
  |  Branch (11858:13): [True: 516, False: 4.22k]
  ------------------
11859|    516|		if ((!terminate) && (!xmlParseLookupChar(ctxt, '>')))
  ------------------
  |  Branch (11859:7): [True: 513, False: 3]
  |  Branch (11859:23): [True: 7, False: 506]
  ------------------
11860|      7|		    goto done;
11861|    509|		if (ctxt->sax2) {
  ------------------
  |  Branch (11861:7): [True: 508, False: 1]
  ------------------
11862|    508|	            xmlParseEndTag2(ctxt, &ctxt->pushTab[ctxt->nameNr - 1]);
11863|    508|		    nameNsPop(ctxt);
11864|    508|		}
11865|      1|#ifdef LIBXML_SAX1_ENABLED
11866|      1|		  else
11867|      1|		    xmlParseEndTag1(ctxt, 0);
11868|    509|#endif /* LIBXML_SAX1_ENABLED */
11869|    509|                if (ctxt->instate == XML_PARSER_EOF)
  ------------------
  |  Branch (11869:21): [True: 0, False: 509]
  ------------------
11870|      0|                    goto done;
11871|    509|		if (ctxt->nameNr == 0) {
  ------------------
  |  Branch (11871:7): [True: 44, False: 465]
  ------------------
11872|     44|		    ctxt->instate = XML_PARSER_EPILOG;
11873|    465|		} else {
11874|    465|		    ctxt->instate = XML_PARSER_CONTENT;
11875|    465|		}
11876|    509|		break;
11877|      0|            case XML_PARSER_CDATA_SECTION: {
  ------------------
  |  Branch (11877:13): [True: 0, False: 4.73k]
  ------------------
11878|       |	        /*
11879|       |		 * The Push mode need to have the SAX callback for
11880|       |		 * cdataBlock merge back contiguous callbacks.
11881|       |		 */
11882|      0|		const xmlChar *term;
11883|       |
11884|      0|                if (terminate) {
  ------------------
  |  Branch (11884:21): [True: 0, False: 0]
  ------------------
11885|       |                    /*
11886|       |                     * Don't call xmlParseLookupString. If 'terminate'
11887|       |                     * is set, checkIndex is invalid.
11888|       |                     */
11889|      0|                    term = BAD_CAST strstr((const char *) ctxt->input->cur,
  ------------------
  |  |   35|      0|#define BAD_CAST (xmlChar *)
  ------------------
11890|      0|                                           "]]>");
11891|      0|                } else {
11892|      0|		    term = xmlParseLookupString(ctxt, 0, "]]>", 3);
11893|      0|                }
11894|       |
11895|      0|		if (term == NULL) {
  ------------------
  |  Branch (11895:7): [True: 0, False: 0]
  ------------------
11896|      0|		    int tmp, size;
11897|       |
11898|      0|                    if (terminate) {
  ------------------
  |  Branch (11898:25): [True: 0, False: 0]
  ------------------
11899|       |                        /* Unfinished CDATA section */
11900|      0|                        size = ctxt->input->end - ctxt->input->cur;
11901|      0|                    } else {
11902|      0|                        if (avail < XML_PARSER_BIG_BUFFER_SIZE + 2)
  ------------------
  |  |  166|      0|#define XML_PARSER_BIG_BUFFER_SIZE 300
  ------------------
  |  Branch (11902:29): [True: 0, False: 0]
  ------------------
11903|      0|                            goto done;
11904|      0|                        ctxt->checkIndex = 0;
11905|       |                        /* XXX: Why don't we pass the full buffer? */
11906|      0|                        size = XML_PARSER_BIG_BUFFER_SIZE;
  ------------------
  |  |  166|      0|#define XML_PARSER_BIG_BUFFER_SIZE 300
  ------------------
11907|      0|                    }
11908|      0|                    tmp = xmlCheckCdataPush(ctxt->input->cur, size, 0);
11909|      0|                    if (tmp <= 0) {
  ------------------
  |  Branch (11909:25): [True: 0, False: 0]
  ------------------
11910|      0|                        tmp = -tmp;
11911|      0|                        ctxt->input->cur += tmp;
11912|      0|                        goto encoding_error;
11913|      0|                    }
11914|      0|                    if ((ctxt->sax != NULL) && (!ctxt->disableSAX)) {
  ------------------
  |  Branch (11914:25): [True: 0, False: 0]
  |  Branch (11914:48): [True: 0, False: 0]
  ------------------
11915|      0|                        if (ctxt->sax->cdataBlock != NULL)
  ------------------
  |  Branch (11915:29): [True: 0, False: 0]
  ------------------
11916|      0|                            ctxt->sax->cdataBlock(ctxt->userData,
11917|      0|                                                  ctxt->input->cur, tmp);
11918|      0|                        else if (ctxt->sax->characters != NULL)
  ------------------
  |  Branch (11918:34): [True: 0, False: 0]
  ------------------
11919|      0|                            ctxt->sax->characters(ctxt->userData,
11920|      0|                                                  ctxt->input->cur, tmp);
11921|      0|                    }
11922|      0|                    if (ctxt->instate == XML_PARSER_EOF)
  ------------------
  |  Branch (11922:25): [True: 0, False: 0]
  ------------------
11923|      0|                        goto done;
11924|      0|                    SKIPL(tmp);
  ------------------
  |  | 2251|      0|#define SKIPL(val) do {							\
  |  | 2252|      0|    int skipl;								\
  |  | 2253|      0|    for(skipl=0; skipl<val; skipl++) {					\
  |  |  ------------------
  |  |  |  Branch (2253:18): [True: 0, False: 0]
  |  |  ------------------
  |  | 2254|      0|	if (*(ctxt->input->cur) == '\n') {				\
  |  |  ------------------
  |  |  |  Branch (2254:6): [True: 0, False: 0]
  |  |  ------------------
  |  | 2255|      0|	ctxt->input->line++; ctxt->input->col = 1;			\
  |  | 2256|      0|	} else ctxt->input->col++;					\
  |  | 2257|      0|	ctxt->input->cur++;						\
  |  | 2258|      0|    }									\
  |  | 2259|      0|    if (*ctxt->input->cur == 0)						\
  |  |  ------------------
  |  |  |  Branch (2259:9): [True: 0, False: 0]
  |  |  ------------------
  |  | 2260|      0|        xmlParserGrow(ctxt);						\
  |  | 2261|      0|  } while (0)
  |  |  ------------------
  |  |  |  Branch (2261:12): [Folded - Ignored]
  |  |  ------------------
  ------------------
11925|      0|		} else {
11926|      0|                    int base = term - CUR_PTR;
  ------------------
  |  | 2224|      0|#define CUR_PTR ctxt->input->cur
  ------------------
11927|      0|		    int tmp;
11928|       |
11929|      0|		    tmp = xmlCheckCdataPush(ctxt->input->cur, base, 1);
11930|      0|		    if ((tmp < 0) || (tmp != base)) {
  ------------------
  |  Branch (11930:11): [True: 0, False: 0]
  |  Branch (11930:24): [True: 0, False: 0]
  ------------------
11931|      0|			tmp = -tmp;
11932|      0|			ctxt->input->cur += tmp;
11933|      0|			goto encoding_error;
11934|      0|		    }
11935|      0|		    if ((ctxt->sax != NULL) && (base == 0) &&
  ------------------
  |  Branch (11935:11): [True: 0, False: 0]
  |  Branch (11935:34): [True: 0, False: 0]
  ------------------
11936|      0|		        (ctxt->sax->cdataBlock != NULL) &&
  ------------------
  |  Branch (11936:11): [True: 0, False: 0]
  ------------------
11937|      0|		        (!ctxt->disableSAX)) {
  ------------------
  |  Branch (11937:11): [True: 0, False: 0]
  ------------------
11938|       |			/*
11939|       |			 * Special case to provide identical behaviour
11940|       |			 * between pull and push parsers on enpty CDATA
11941|       |			 * sections
11942|       |			 */
11943|      0|			 if ((ctxt->input->cur - ctxt->input->base >= 9) &&
  ------------------
  |  Branch (11943:9): [True: 0, False: 0]
  ------------------
11944|      0|			     (!strncmp((const char *)&ctxt->input->cur[-9],
  ------------------
  |  Branch (11944:9): [True: 0, False: 0]
  ------------------
11945|      0|			               "<![CDATA[", 9)))
11946|      0|			     ctxt->sax->cdataBlock(ctxt->userData,
11947|      0|			                           BAD_CAST "", 0);
  ------------------
  |  |   35|      0|#define BAD_CAST (xmlChar *)
  ------------------
11948|      0|		    } else if ((ctxt->sax != NULL) && (base > 0) &&
  ------------------
  |  Branch (11948:18): [True: 0, False: 0]
  |  Branch (11948:41): [True: 0, False: 0]
  ------------------
11949|      0|			(!ctxt->disableSAX)) {
  ------------------
  |  Branch (11949:4): [True: 0, False: 0]
  ------------------
11950|      0|			if (ctxt->sax->cdataBlock != NULL)
  ------------------
  |  Branch (11950:8): [True: 0, False: 0]
  ------------------
11951|      0|			    ctxt->sax->cdataBlock(ctxt->userData,
11952|      0|						  ctxt->input->cur, base);
11953|      0|			else if (ctxt->sax->characters != NULL)
  ------------------
  |  Branch (11953:13): [True: 0, False: 0]
  ------------------
11954|      0|			    ctxt->sax->characters(ctxt->userData,
11955|      0|						  ctxt->input->cur, base);
11956|      0|		    }
11957|      0|		    if (ctxt->instate == XML_PARSER_EOF)
  ------------------
  |  Branch (11957:11): [True: 0, False: 0]
  ------------------
11958|      0|			goto done;
11959|      0|		    SKIPL(base + 3);
  ------------------
  |  | 2251|      0|#define SKIPL(val) do {							\
  |  | 2252|      0|    int skipl;								\
  |  | 2253|      0|    for(skipl=0; skipl<val; skipl++) {					\
  |  |  ------------------
  |  |  |  Branch (2253:18): [True: 0, False: 0]
  |  |  ------------------
  |  | 2254|      0|	if (*(ctxt->input->cur) == '\n') {				\
  |  |  ------------------
  |  |  |  Branch (2254:6): [True: 0, False: 0]
  |  |  ------------------
  |  | 2255|      0|	ctxt->input->line++; ctxt->input->col = 1;			\
  |  | 2256|      0|	} else ctxt->input->col++;					\
  |  | 2257|      0|	ctxt->input->cur++;						\
  |  | 2258|      0|    }									\
  |  | 2259|      0|    if (*ctxt->input->cur == 0)						\
  |  |  ------------------
  |  |  |  Branch (2259:9): [True: 0, False: 0]
  |  |  ------------------
  |  | 2260|      0|        xmlParserGrow(ctxt);						\
  |  | 2261|      0|  } while (0)
  |  |  ------------------
  |  |  |  Branch (2261:12): [Folded - Ignored]
  |  |  ------------------
  ------------------
11960|      0|		    ctxt->instate = XML_PARSER_CONTENT;
11961|      0|		}
11962|      0|		break;
11963|      0|	    }
11964|    161|            case XML_PARSER_MISC:
  ------------------
  |  Branch (11964:13): [True: 161, False: 4.57k]
  ------------------
11965|    164|            case XML_PARSER_PROLOG:
  ------------------
  |  Branch (11965:13): [True: 3, False: 4.73k]
  ------------------
11966|    205|            case XML_PARSER_EPILOG:
  ------------------
  |  Branch (11966:13): [True: 41, False: 4.69k]
  ------------------
11967|    205|		SKIP_BLANKS;
  ------------------
  |  | 2273|    205|#define SKIP_BLANKS xmlSkipBlankChars(ctxt)
  ------------------
11968|    205|                avail = ctxt->input->end - ctxt->input->cur;
11969|    205|		if (avail < 1)
  ------------------
  |  Branch (11969:7): [True: 41, False: 164]
  ------------------
11970|     41|		    goto done;
11971|    164|		if (ctxt->input->cur[0] == '<') {
  ------------------
  |  Branch (11971:7): [True: 156, False: 8]
  ------------------
11972|    156|                    if ((!terminate) && (avail < 2))
  ------------------
  |  Branch (11972:25): [True: 156, False: 0]
  |  Branch (11972:41): [True: 0, False: 156]
  ------------------
11973|      0|                        goto done;
11974|    156|                    next = ctxt->input->cur[1];
11975|    156|                    if (next == '?') {
  ------------------
  |  Branch (11975:25): [True: 1, False: 155]
  ------------------
11976|      1|                        if ((!terminate) &&
  ------------------
  |  Branch (11976:29): [True: 1, False: 0]
  ------------------
11977|      1|                            (!xmlParseLookupString(ctxt, 2, "?>", 2)))
  ------------------
  |  Branch (11977:29): [True: 0, False: 1]
  ------------------
11978|      0|                            goto done;
11979|      1|                        xmlParsePI(ctxt);
11980|      1|                        if (ctxt->instate == XML_PARSER_EOF)
  ------------------
  |  Branch (11980:29): [True: 0, False: 1]
  ------------------
11981|      0|                            goto done;
11982|      1|                        break;
11983|    155|                    } else if (next == '!') {
  ------------------
  |  Branch (11983:32): [True: 3, False: 152]
  ------------------
11984|      3|                        if ((!terminate) && (avail < 3))
  ------------------
  |  Branch (11984:29): [True: 3, False: 0]
  |  Branch (11984:45): [True: 0, False: 3]
  ------------------
11985|      0|                            goto done;
11986|       |
11987|      3|                        if (ctxt->input->cur[2] == '-') {
  ------------------
  |  Branch (11987:29): [True: 0, False: 3]
  ------------------
11988|      0|                            if ((!terminate) && (avail < 4))
  ------------------
  |  Branch (11988:33): [True: 0, False: 0]
  |  Branch (11988:49): [True: 0, False: 0]
  ------------------
11989|      0|                                goto done;
11990|      0|                            if (ctxt->input->cur[3] == '-') {
  ------------------
  |  Branch (11990:33): [True: 0, False: 0]
  ------------------
11991|      0|                                if ((!terminate) &&
  ------------------
  |  Branch (11991:37): [True: 0, False: 0]
  ------------------
11992|      0|                                    (!xmlParseLookupString(ctxt, 4, "-->", 3)))
  ------------------
  |  Branch (11992:37): [True: 0, False: 0]
  ------------------
11993|      0|                                    goto done;
11994|      0|                                xmlParseComment(ctxt);
11995|      0|                                if (ctxt->instate == XML_PARSER_EOF)
  ------------------
  |  Branch (11995:37): [True: 0, False: 0]
  ------------------
11996|      0|                                    goto done;
11997|      0|                                break;
11998|      0|                            }
11999|      3|                        } else if (ctxt->instate == XML_PARSER_MISC) {
  ------------------
  |  Branch (11999:36): [True: 3, False: 0]
  ------------------
12000|      3|                            if ((!terminate) && (avail < 9))
  ------------------
  |  Branch (12000:33): [True: 3, False: 0]
  |  Branch (12000:49): [True: 0, False: 3]
  ------------------
12001|      0|                                goto done;
12002|      3|                            if ((ctxt->input->cur[2] == 'D') &&
  ------------------
  |  Branch (12002:33): [True: 3, False: 0]
  ------------------
12003|      3|                                (ctxt->input->cur[3] == 'O') &&
  ------------------
  |  Branch (12003:33): [True: 3, False: 0]
  ------------------
12004|      3|                                (ctxt->input->cur[4] == 'C') &&
  ------------------
  |  Branch (12004:33): [True: 3, False: 0]
  ------------------
12005|      3|                                (ctxt->input->cur[5] == 'T') &&
  ------------------
  |  Branch (12005:33): [True: 3, False: 0]
  ------------------
12006|      3|                                (ctxt->input->cur[6] == 'Y') &&
  ------------------
  |  Branch (12006:33): [True: 3, False: 0]
  ------------------
12007|      3|                                (ctxt->input->cur[7] == 'P') &&
  ------------------
  |  Branch (12007:33): [True: 3, False: 0]
  ------------------
12008|      3|                                (ctxt->input->cur[8] == 'E')) {
  ------------------
  |  Branch (12008:33): [True: 3, False: 0]
  ------------------
12009|      3|                                if ((!terminate) && (!xmlParseLookupGt(ctxt)))
  ------------------
  |  Branch (12009:37): [True: 3, False: 0]
  |  Branch (12009:53): [True: 0, False: 3]
  ------------------
12010|      0|                                    goto done;
12011|      3|                                ctxt->inSubset = 1;
12012|      3|                                xmlParseDocTypeDecl(ctxt);
12013|      3|                                if (ctxt->instate == XML_PARSER_EOF)
  ------------------
  |  Branch (12013:37): [True: 0, False: 3]
  ------------------
12014|      0|                                    goto done;
12015|      3|                                if (RAW == '[') {
  ------------------
  |  | 2221|      3|#define RAW (*ctxt->input->cur)
  ------------------
  |  Branch (12015:37): [True: 3, False: 0]
  ------------------
12016|      3|                                    ctxt->instate = XML_PARSER_DTD;
12017|      3|                                } else {
12018|       |                                    /*
12019|       |                                     * Create and update the external subset.
12020|       |                                     */
12021|      0|                                    ctxt->inSubset = 2;
12022|      0|                                    if ((ctxt->sax != NULL) &&
  ------------------
  |  Branch (12022:41): [True: 0, False: 0]
  ------------------
12023|      0|                                        (!ctxt->disableSAX) &&
  ------------------
  |  Branch (12023:41): [True: 0, False: 0]
  ------------------
12024|      0|                                        (ctxt->sax->externalSubset != NULL))
  ------------------
  |  Branch (12024:41): [True: 0, False: 0]
  ------------------
12025|      0|                                        ctxt->sax->externalSubset(
12026|      0|                                                ctxt->userData,
12027|      0|                                                ctxt->intSubName,
12028|      0|                                                ctxt->extSubSystem,
12029|      0|                                                ctxt->extSubURI);
12030|      0|                                    ctxt->inSubset = 0;
12031|      0|                                    xmlCleanSpecialAttr(ctxt);
12032|      0|                                    if (ctxt->instate == XML_PARSER_EOF)
  ------------------
  |  Branch (12032:41): [True: 0, False: 0]
  ------------------
12033|      0|                                        goto done;
12034|      0|                                    ctxt->instate = XML_PARSER_PROLOG;
12035|      0|                                }
12036|      3|                                break;
12037|      3|                            }
12038|      3|                        }
12039|      3|                    }
12040|    156|                }
12041|       |
12042|    160|                if (ctxt->instate == XML_PARSER_EPILOG) {
  ------------------
  |  Branch (12042:21): [True: 0, False: 160]
  ------------------
12043|      0|                    if (ctxt->errNo == XML_ERR_OK)
  ------------------
  |  Branch (12043:25): [True: 0, False: 0]
  ------------------
12044|      0|                        xmlFatalErr(ctxt, XML_ERR_DOCUMENT_END, NULL);
12045|      0|		    ctxt->instate = XML_PARSER_EOF;
12046|      0|                    if ((ctxt->sax) && (ctxt->sax->endDocument != NULL))
  ------------------
  |  Branch (12046:25): [True: 0, False: 0]
  |  Branch (12046:40): [True: 0, False: 0]
  ------------------
12047|      0|                        ctxt->sax->endDocument(ctxt->userData);
12048|    160|                } else {
12049|    160|		    ctxt->instate = XML_PARSER_START_TAG;
12050|    160|		}
12051|    160|		break;
12052|      3|            case XML_PARSER_DTD: {
  ------------------
  |  Branch (12052:13): [True: 3, False: 4.73k]
  ------------------
12053|      3|                if ((!terminate) && (!xmlParseLookupInternalSubset(ctxt)))
  ------------------
  |  Branch (12053:21): [True: 3, False: 0]
  |  Branch (12053:37): [True: 0, False: 3]
  ------------------
12054|      0|                    goto done;
12055|      3|		xmlParseInternalSubset(ctxt);
12056|      3|		if (ctxt->instate == XML_PARSER_EOF)
  ------------------
  |  Branch (12056:7): [True: 0, False: 3]
  ------------------
12057|      0|		    goto done;
12058|      3|		ctxt->inSubset = 2;
12059|      3|		if ((ctxt->sax != NULL) && (!ctxt->disableSAX) &&
  ------------------
  |  Branch (12059:7): [True: 3, False: 0]
  |  Branch (12059:30): [True: 3, False: 0]
  ------------------
12060|      3|		    (ctxt->sax->externalSubset != NULL))
  ------------------
  |  Branch (12060:7): [True: 3, False: 0]
  ------------------
12061|      3|		    ctxt->sax->externalSubset(ctxt->userData, ctxt->intSubName,
12062|      3|			    ctxt->extSubSystem, ctxt->extSubURI);
12063|      3|		ctxt->inSubset = 0;
12064|      3|		xmlCleanSpecialAttr(ctxt);
12065|      3|		if (ctxt->instate == XML_PARSER_EOF)
  ------------------
  |  Branch (12065:7): [True: 0, False: 3]
  ------------------
12066|      0|		    goto done;
12067|      3|		ctxt->instate = XML_PARSER_PROLOG;
12068|      3|                break;
12069|      3|	    }
12070|      0|            default:
  ------------------
  |  Branch (12070:13): [True: 0, False: 4.73k]
  ------------------
12071|      0|		xmlGenericError(xmlGenericErrorContext,
  ------------------
  |  |  875|      0|  #define xmlGenericError XML_GLOBAL_MACRO(xmlGenericError)
  |  |  ------------------
  |  |  |  |  500|      0|  #define XML_GLOBAL_MACRO(name) (*__##name())
  |  |  ------------------
  ------------------
              		xmlGenericError(xmlGenericErrorContext,
  ------------------
  |  |  876|      0|  #define xmlGenericErrorContext XML_GLOBAL_MACRO(xmlGenericErrorContext)
  |  |  ------------------
  |  |  |  |  500|      0|  #define XML_GLOBAL_MACRO(name) (*__##name())
  |  |  ------------------
  ------------------
12072|      0|			"PP: internal error\n");
12073|      0|		ctxt->instate = XML_PARSER_EOF;
12074|      0|		break;
12075|  4.73k|	}
12076|  4.73k|    }
12077|    188|done:
12078|    188|    return(ret);
12079|      0|encoding_error:
12080|      0|    if (ctxt->input->end - ctxt->input->cur < 4) {
  ------------------
  |  Branch (12080:9): [True: 0, False: 0]
  ------------------
12081|      0|	__xmlErrEncoding(ctxt, XML_ERR_INVALID_CHAR,
12082|      0|		     "Input is not proper UTF-8, indicate encoding !\n",
12083|      0|		     NULL, NULL);
12084|      0|    } else {
12085|      0|        char buffer[150];
12086|       |
12087|      0|	snprintf(buffer, 149, "Bytes: 0x%02X 0x%02X 0x%02X 0x%02X\n",
12088|      0|			ctxt->input->cur[0], ctxt->input->cur[1],
12089|      0|			ctxt->input->cur[2], ctxt->input->cur[3]);
12090|      0|	__xmlErrEncoding(ctxt, XML_ERR_INVALID_CHAR,
12091|      0|		     "Input is not proper UTF-8, indicate encoding !\n%s",
12092|      0|		     BAD_CAST buffer, NULL);
  ------------------
  |  |   35|      0|#define BAD_CAST (xmlChar *)
  ------------------
12093|      0|    }
12094|      0|    return(0);
12095|    288|}
parser.c:xmlParseLookupString:
11292|     66|                     const char *str, size_t strLen) {
11293|     66|    const xmlChar *cur, *term;
11294|       |
11295|     66|    if (ctxt->checkIndex == 0) {
  ------------------
  |  Branch (11295:9): [True: 65, False: 1]
  ------------------
11296|     65|        cur = ctxt->input->cur + startDelta;
11297|     65|    } else {
11298|      1|        cur = ctxt->input->cur + ctxt->checkIndex;
11299|      1|    }
11300|       |
11301|     66|    term = BAD_CAST strstr((const char *) cur, str);
  ------------------
  |  |   35|     66|#define BAD_CAST (xmlChar *)
  ------------------
11302|     66|    if (term == NULL) {
  ------------------
  |  Branch (11302:9): [True: 13, False: 53]
  ------------------
11303|     13|        const xmlChar *end = ctxt->input->end;
11304|     13|        size_t index;
11305|       |
11306|       |        /* Rescan (strLen - 1) characters. */
11307|     13|        if ((size_t) (end - cur) < strLen)
  ------------------
  |  Branch (11307:13): [True: 0, False: 13]
  ------------------
11308|      0|            end = cur;
11309|     13|        else
11310|     13|            end -= strLen - 1;
11311|     13|        index = end - ctxt->input->cur;
11312|     13|        if (index > LONG_MAX) {
  ------------------
  |  Branch (11312:13): [True: 0, False: 13]
  ------------------
11313|      0|            ctxt->checkIndex = 0;
11314|      0|            return(ctxt->input->end - strLen);
11315|      0|        }
11316|     13|        ctxt->checkIndex = index;
11317|     53|    } else {
11318|     53|        ctxt->checkIndex = 0;
11319|     53|    }
11320|       |
11321|     66|    return(term);
11322|     66|}
parser.c:xmlParseLookupGt:
11361|  1.15k|xmlParseLookupGt(xmlParserCtxtPtr ctxt) {
11362|  1.15k|    const xmlChar *cur;
11363|  1.15k|    const xmlChar *end = ctxt->input->end;
11364|  1.15k|    int state = ctxt->endCheckState;
11365|  1.15k|    size_t index;
11366|       |
11367|  1.15k|    if (ctxt->checkIndex == 0)
  ------------------
  |  Branch (11367:9): [True: 1.14k, False: 19]
  ------------------
11368|  1.14k|        cur = ctxt->input->cur + 1;
11369|     19|    else
11370|     19|        cur = ctxt->input->cur + ctxt->checkIndex;
11371|       |
11372|  31.4k|    while (cur < end) {
  ------------------
  |  Branch (11372:12): [True: 31.3k, False: 43]
  ------------------
11373|  31.3k|        if (state) {
  ------------------
  |  Branch (11373:13): [True: 13.7k, False: 17.6k]
  ------------------
11374|  13.7k|            if (*cur == state)
  ------------------
  |  Branch (11374:17): [True: 662, False: 13.0k]
  ------------------
11375|    662|                state = 0;
11376|  17.6k|        } else if (*cur == '\'' || *cur == '"') {
  ------------------
  |  Branch (11376:20): [True: 2, False: 17.6k]
  |  Branch (11376:36): [True: 677, False: 16.9k]
  ------------------
11377|    679|            state = *cur;
11378|  16.9k|        } else if (*cur == '>') {
  ------------------
  |  Branch (11378:20): [True: 1.11k, False: 15.8k]
  ------------------
11379|  1.11k|            ctxt->checkIndex = 0;
11380|  1.11k|            ctxt->endCheckState = 0;
11381|  1.11k|            return(1);
11382|  1.11k|        }
11383|  30.2k|        cur++;
11384|  30.2k|    }
11385|       |
11386|     43|    index = cur - ctxt->input->cur;
11387|     43|    if (index > LONG_MAX) {
  ------------------
  |  Branch (11387:9): [True: 0, False: 43]
  ------------------
11388|      0|        ctxt->checkIndex = 0;
11389|      0|        ctxt->endCheckState = 0;
11390|      0|        return(1);
11391|      0|    }
11392|     43|    ctxt->checkIndex = index;
11393|     43|    ctxt->endCheckState = state;
11394|     43|    return(0);
11395|     43|}
parser.c:xmlParseLookupChar:
11257|    514|xmlParseLookupChar(xmlParserCtxtPtr ctxt, int c) {
11258|    514|    const xmlChar *cur;
11259|       |
11260|    514|    if (ctxt->checkIndex == 0) {
  ------------------
  |  Branch (11260:9): [True: 510, False: 4]
  ------------------
11261|    510|        cur = ctxt->input->cur + 1;
11262|    510|    } else {
11263|      4|        cur = ctxt->input->cur + ctxt->checkIndex;
11264|      4|    }
11265|       |
11266|    514|    if (memchr(cur, c, ctxt->input->end - cur) == NULL) {
  ------------------
  |  Branch (11266:9): [True: 7, False: 507]
  ------------------
11267|      7|        size_t index = ctxt->input->end - ctxt->input->cur;
11268|       |
11269|      7|        if (index > LONG_MAX) {
  ------------------
  |  Branch (11269:13): [True: 0, False: 7]
  ------------------
11270|      0|            ctxt->checkIndex = 0;
11271|      0|            return(1);
11272|      0|        }
11273|      7|        ctxt->checkIndex = index;
11274|      7|        return(0);
11275|    507|    } else {
11276|    507|        ctxt->checkIndex = 0;
11277|    507|        return(1);
11278|    507|    }
11279|    514|}
parser.c:xmlParseLookupCharData:
11331|    715|xmlParseLookupCharData(xmlParserCtxtPtr ctxt) {
11332|    715|    const xmlChar *cur = ctxt->input->cur + ctxt->checkIndex;
11333|    715|    const xmlChar *end = ctxt->input->end;
11334|    715|    size_t index;
11335|       |
11336|  7.57k|    while (cur < end) {
  ------------------
  |  Branch (11336:12): [True: 7.56k, False: 9]
  ------------------
11337|  7.56k|        if ((*cur == '<') || (*cur == '&')) {
  ------------------
  |  Branch (11337:13): [True: 705, False: 6.85k]
  |  Branch (11337:30): [True: 1, False: 6.85k]
  ------------------
11338|    706|            ctxt->checkIndex = 0;
11339|    706|            return(1);
11340|    706|        }
11341|  6.85k|        cur++;
11342|  6.85k|    }
11343|       |
11344|      9|    index = cur - ctxt->input->cur;
11345|      9|    if (index > LONG_MAX) {
  ------------------
  |  Branch (11345:9): [True: 0, False: 9]
  ------------------
11346|      0|        ctxt->checkIndex = 0;
11347|      0|        return(1);
11348|      0|    }
11349|      9|    ctxt->checkIndex = index;
11350|      9|    return(0);
11351|      9|}
parser.c:nameNsPop:
 2076|    508|{
 2077|    508|    const xmlChar *ret;
 2078|       |
 2079|    508|    if (ctxt->nameNr <= 0)
  ------------------
  |  Branch (2079:9): [True: 0, False: 508]
  ------------------
 2080|      0|        return (NULL);
 2081|    508|    ctxt->nameNr--;
 2082|    508|    if (ctxt->nameNr > 0)
  ------------------
  |  Branch (2082:9): [True: 465, False: 43]
  ------------------
 2083|    465|        ctxt->name = ctxt->nameTab[ctxt->nameNr - 1];
 2084|     43|    else
 2085|     43|        ctxt->name = NULL;
 2086|    508|    ret = ctxt->nameTab[ctxt->nameNr];
 2087|    508|    ctxt->nameTab[ctxt->nameNr] = NULL;
 2088|    508|    return (ret);
 2089|    508|}
parser.c:xmlParseLookupInternalSubset:
11405|      3|xmlParseLookupInternalSubset(xmlParserCtxtPtr ctxt) {
11406|       |    /*
11407|       |     * Sorry, but progressive parsing of the internal subset is not
11408|       |     * supported. We first check that the full content of the internal
11409|       |     * subset is available and parsing is launched only at that point.
11410|       |     * Internal subset ends with "']' S? '>'" in an unescaped section and
11411|       |     * not in a ']]>' sequence which are conditional sections.
11412|       |     */
11413|      3|    const xmlChar *cur, *start;
11414|      3|    const xmlChar *end = ctxt->input->end;
11415|      3|    int state = ctxt->endCheckState;
11416|      3|    size_t index;
11417|       |
11418|      3|    if (ctxt->checkIndex == 0) {
  ------------------
  |  Branch (11418:9): [True: 3, False: 0]
  ------------------
11419|      3|        cur = ctxt->input->cur + 1;
11420|      3|    } else {
11421|      0|        cur = ctxt->input->cur + ctxt->checkIndex;
11422|      0|    }
11423|      3|    start = cur;
11424|       |
11425|    312|    while (cur < end) {
  ------------------
  |  Branch (11425:12): [True: 312, False: 0]
  ------------------
11426|    312|        if (state == '-') {
  ------------------
  |  Branch (11426:13): [True: 0, False: 312]
  ------------------
11427|      0|            if ((*cur == '-') &&
  ------------------
  |  Branch (11427:17): [True: 0, False: 0]
  ------------------
11428|      0|                (cur[1] == '-') &&
  ------------------
  |  Branch (11428:17): [True: 0, False: 0]
  ------------------
11429|      0|                (cur[2] == '>')) {
  ------------------
  |  Branch (11429:17): [True: 0, False: 0]
  ------------------
11430|      0|                state = 0;
11431|      0|                cur += 3;
11432|      0|                start = cur;
11433|      0|                continue;
11434|      0|            }
11435|      0|        }
11436|    312|        else if (state == ']') {
  ------------------
  |  Branch (11436:18): [True: 3, False: 309]
  ------------------
11437|      3|            if (*cur == '>') {
  ------------------
  |  Branch (11437:17): [True: 3, False: 0]
  ------------------
11438|      3|                ctxt->checkIndex = 0;
11439|      3|                ctxt->endCheckState = 0;
11440|      3|                return(1);
11441|      3|            }
11442|      0|            if (IS_BLANK_CH(*cur)) {
  ------------------
  |  |  151|      0|#define IS_BLANK_CH(c)  xmlIsBlank_ch(c)
  |  |  ------------------
  |  |  |  |   88|      0|#define xmlIsBlank_ch(c)	(((c) == 0x20) || \
  |  |  |  |  ------------------
  |  |  |  |  |  Branch (88:27): [True: 0, False: 0]
  |  |  |  |  ------------------
  |  |  |  |   89|      0|				 ((0x9 <= (c)) && ((c) <= 0xa)) || \
  |  |  |  |  ------------------
  |  |  |  |  |  Branch (89:7): [True: 0, False: 0]
  |  |  |  |  |  Branch (89:23): [True: 0, False: 0]
  |  |  |  |  ------------------
  |  |  |  |   90|      0|				 ((c) == 0xd))
  |  |  |  |  ------------------
  |  |  |  |  |  Branch (90:6): [True: 0, False: 0]
  |  |  |  |  ------------------
  |  |  ------------------
  ------------------
11443|      0|                state = ' ';
11444|      0|            } else if (*cur != ']') {
  ------------------
  |  Branch (11444:24): [True: 0, False: 0]
  ------------------
11445|      0|                state = 0;
11446|      0|                start = cur;
11447|      0|                continue;
11448|      0|            }
11449|      0|        }
11450|    309|        else if (state == ' ') {
  ------------------
  |  Branch (11450:18): [True: 0, False: 309]
  ------------------
11451|      0|            if (*cur == '>') {
  ------------------
  |  Branch (11451:17): [True: 0, False: 0]
  ------------------
11452|      0|                ctxt->checkIndex = 0;
11453|      0|                ctxt->endCheckState = 0;
11454|      0|                return(1);
11455|      0|            }
11456|      0|            if (!IS_BLANK_CH(*cur)) {
  ------------------
  |  |  151|      0|#define IS_BLANK_CH(c)  xmlIsBlank_ch(c)
  |  |  ------------------
  |  |  |  |   88|      0|#define xmlIsBlank_ch(c)	(((c) == 0x20) || \
  |  |  |  |  ------------------
  |  |  |  |  |  Branch (88:27): [True: 0, False: 0]
  |  |  |  |  ------------------
  |  |  |  |   89|      0|				 ((0x9 <= (c)) && ((c) <= 0xa)) || \
  |  |  |  |  ------------------
  |  |  |  |  |  Branch (89:7): [True: 0, False: 0]
  |  |  |  |  |  Branch (89:23): [True: 0, False: 0]
  |  |  |  |  ------------------
  |  |  |  |   90|      0|				 ((c) == 0xd))
  |  |  |  |  ------------------
  |  |  |  |  |  Branch (90:6): [True: 0, False: 0]
  |  |  |  |  ------------------
  |  |  ------------------
  ------------------
11457|      0|                state = 0;
11458|      0|                start = cur;
11459|      0|                continue;
11460|      0|            }
11461|      0|        }
11462|    309|        else if (state != 0) {
  ------------------
  |  Branch (11462:18): [True: 0, False: 309]
  ------------------
11463|      0|            if (*cur == state) {
  ------------------
  |  Branch (11463:17): [True: 0, False: 0]
  ------------------
11464|      0|                state = 0;
11465|      0|                start = cur + 1;
11466|      0|            }
11467|      0|        }
11468|    309|        else if (*cur == '<') {
  ------------------
  |  Branch (11468:18): [True: 12, False: 297]
  ------------------
11469|     12|            if ((cur[1] == '!') &&
  ------------------
  |  Branch (11469:17): [True: 12, False: 0]
  ------------------
11470|     12|                (cur[2] == '-') &&
  ------------------
  |  Branch (11470:17): [True: 0, False: 12]
  ------------------
11471|     12|                (cur[3] == '-')) {
  ------------------
  |  Branch (11471:17): [True: 0, False: 0]
  ------------------
11472|      0|                state = '-';
11473|      0|                cur += 4;
11474|       |                /* Don't treat <!--> as comment */
11475|      0|                start = cur;
11476|      0|                continue;
11477|      0|            }
11478|     12|        }
11479|    297|        else if ((*cur == '"') || (*cur == '\'') || (*cur == ']')) {
  ------------------
  |  Branch (11479:18): [True: 0, False: 297]
  |  Branch (11479:35): [True: 0, False: 297]
  |  Branch (11479:53): [True: 3, False: 294]
  ------------------
11480|      3|            state = *cur;
11481|      3|        }
11482|       |
11483|    309|        cur++;
11484|    309|    }
11485|       |
11486|       |    /*
11487|       |     * Rescan the three last characters to detect "<!--" and "-->"
11488|       |     * split across chunks.
11489|       |     */
11490|      0|    if ((state == 0) || (state == '-')) {
  ------------------
  |  Branch (11490:9): [True: 0, False: 0]
  |  Branch (11490:25): [True: 0, False: 0]
  ------------------
11491|      0|        if (cur - start < 3)
  ------------------
  |  Branch (11491:13): [True: 0, False: 0]
  ------------------
11492|      0|            cur = start;
11493|      0|        else
11494|      0|            cur -= 3;
11495|      0|    }
11496|      0|    index = cur - ctxt->input->cur;
11497|      0|    if (index > LONG_MAX) {
  ------------------
  |  Branch (11497:9): [True: 0, False: 0]
  ------------------
11498|      0|        ctxt->checkIndex = 0;
11499|      0|        ctxt->endCheckState = 0;
11500|      0|        return(1);
11501|      0|    }
11502|      0|    ctxt->checkIndex = index;
11503|      0|    ctxt->endCheckState = state;
11504|      0|    return(0);
11505|      0|}
parser.c:xmlParserNsPush:
 1664|    316|                const xmlHashedString *uri, void *saxData, int defAttr) {
 1665|    316|    xmlParserNsBucket *bucket = NULL;
 1666|    316|    xmlParserNsExtra *extra;
 1667|    316|    const xmlChar **ns;
 1668|    316|    unsigned hashValue, nsIndex, oldIndex;
 1669|       |
 1670|    316|    if ((prefix != NULL) && (prefix->name == ctxt->str_xml))
  ------------------
  |  Branch (1670:9): [True: 316, False: 0]
  |  Branch (1670:29): [True: 0, False: 316]
  ------------------
 1671|      0|        return(0);
 1672|       |
 1673|    316|    if ((ctxt->nsNr >= ctxt->nsMax) && (xmlParserNsGrow(ctxt) < 0)) {
  ------------------
  |  Branch (1673:9): [True: 289, False: 27]
  |  Branch (1673:40): [True: 0, False: 289]
  ------------------
 1674|      0|        xmlErrMemory(ctxt, NULL);
 1675|      0|        return(-1);
 1676|      0|    }
 1677|       |
 1678|       |    /*
 1679|       |     * Default namespace and 'xml' namespace
 1680|       |     */
 1681|    316|    if ((prefix == NULL) || (prefix->name == NULL)) {
  ------------------
  |  Branch (1681:9): [True: 0, False: 316]
  |  Branch (1681:29): [True: 0, False: 316]
  ------------------
 1682|      0|        oldIndex = ctxt->nsdb->defaultNsIndex;
 1683|       |
 1684|      0|        if (oldIndex != INT_MAX) {
  ------------------
  |  Branch (1684:13): [True: 0, False: 0]
  ------------------
 1685|      0|            if (defAttr != 0)
  ------------------
  |  Branch (1685:17): [True: 0, False: 0]
  ------------------
 1686|      0|                return(0);
 1687|       |
 1688|      0|            extra = &ctxt->nsdb->extra[oldIndex];
 1689|       |
 1690|      0|            if (extra->elementId == ctxt->nsdb->elementId) {
  ------------------
  |  Branch (1690:17): [True: 0, False: 0]
  ------------------
 1691|      0|                xmlErrAttributeDup(ctxt, NULL, BAD_CAST "xmlns");
  ------------------
  |  |   35|      0|#define BAD_CAST (xmlChar *)
  ------------------
 1692|      0|                return(0);
 1693|      0|            }
 1694|       |
 1695|      0|            if ((ctxt->options & XML_PARSE_NSCLEAN) &&
  ------------------
  |  Branch (1695:17): [True: 0, False: 0]
  ------------------
 1696|      0|                (uri->name == ctxt->nsTab[oldIndex * 2 + 1]))
  ------------------
  |  Branch (1696:17): [True: 0, False: 0]
  ------------------
 1697|      0|                return(0);
 1698|      0|        }
 1699|       |
 1700|      0|        ctxt->nsdb->defaultNsIndex = ctxt->nsNr;
 1701|      0|        goto populate_entry;
 1702|      0|    }
 1703|       |
 1704|       |    /*
 1705|       |     * Hash table lookup
 1706|       |     */
 1707|    316|    oldIndex = xmlParserNsLookup(ctxt, prefix, &bucket);
 1708|    316|    if (oldIndex != INT_MAX) {
  ------------------
  |  Branch (1708:9): [True: 1, False: 315]
  ------------------
 1709|      1|        extra = &ctxt->nsdb->extra[oldIndex];
 1710|       |
 1711|      1|        if (defAttr != 0)
  ------------------
  |  Branch (1711:13): [True: 0, False: 1]
  ------------------
 1712|      0|            return(0);
 1713|       |
 1714|       |        /*
 1715|       |         * Check for duplicate definitions on the same element.
 1716|       |         */
 1717|      1|        if (extra->elementId == ctxt->nsdb->elementId) {
  ------------------
  |  Branch (1717:13): [True: 0, False: 1]
  ------------------
 1718|      0|            xmlErrAttributeDup(ctxt, BAD_CAST "xmlns", prefix->name);
  ------------------
  |  |   35|      0|#define BAD_CAST (xmlChar *)
  ------------------
 1719|      0|            return(0);
 1720|      0|        }
 1721|       |
 1722|      1|        if ((ctxt->options & XML_PARSE_NSCLEAN) &&
  ------------------
  |  Branch (1722:13): [True: 0, False: 1]
  ------------------
 1723|      1|            (uri->name == ctxt->nsTab[bucket->index * 2 + 1]))
  ------------------
  |  Branch (1723:13): [True: 0, False: 0]
  ------------------
 1724|      0|            return(0);
 1725|       |
 1726|      1|        bucket->index = ctxt->nsNr;
 1727|      1|        goto populate_entry;
 1728|      1|    }
 1729|       |
 1730|       |    /*
 1731|       |     * Insert new bucket
 1732|       |     */
 1733|       |
 1734|    315|    hashValue = prefix->hashValue;
 1735|       |
 1736|       |    /*
 1737|       |     * Grow hash table, 50% fill factor
 1738|       |     */
 1739|    315|    if (ctxt->nsdb->hashElems + 1 > ctxt->nsdb->hashSize / 2) {
  ------------------
  |  Branch (1739:9): [True: 289, False: 26]
  ------------------
 1740|    289|        xmlParserNsBucket *newHash;
 1741|    289|        unsigned newSize, i, index;
 1742|       |
 1743|    289|        if (ctxt->nsdb->hashSize > UINT_MAX / 2) {
  ------------------
  |  Branch (1743:13): [True: 0, False: 289]
  ------------------
 1744|      0|            xmlErrMemory(ctxt, NULL);
 1745|      0|            return(-1);
 1746|      0|        }
 1747|    289|        newSize = ctxt->nsdb->hashSize ? ctxt->nsdb->hashSize * 2 : 16;
  ------------------
  |  Branch (1747:19): [True: 0, False: 289]
  ------------------
 1748|    289|        newHash = xmlMalloc(newSize * sizeof(newHash[0]));
 1749|    289|        if (newHash == NULL) {
  ------------------
  |  Branch (1749:13): [True: 0, False: 289]
  ------------------
 1750|      0|            xmlErrMemory(ctxt, NULL);
 1751|      0|            return(-1);
 1752|      0|        }
 1753|    289|        memset(newHash, 0, newSize * sizeof(newHash[0]));
 1754|       |
 1755|    289|        for (i = 0; i < ctxt->nsdb->hashSize; i++) {
  ------------------
  |  Branch (1755:21): [True: 0, False: 289]
  ------------------
 1756|      0|            unsigned hv = ctxt->nsdb->hash[i].hashValue;
 1757|      0|            unsigned newIndex;
 1758|       |
 1759|      0|            if (hv == 0)
  ------------------
  |  Branch (1759:17): [True: 0, False: 0]
  ------------------
 1760|      0|                continue;
 1761|      0|            newIndex = hv & (newSize - 1);
 1762|       |
 1763|      0|            while (newHash[newIndex].hashValue != 0) {
  ------------------
  |  Branch (1763:20): [True: 0, False: 0]
  ------------------
 1764|      0|                newIndex++;
 1765|      0|                if (newIndex == newSize)
  ------------------
  |  Branch (1765:21): [True: 0, False: 0]
  ------------------
 1766|      0|                    newIndex = 0;
 1767|      0|            }
 1768|       |
 1769|      0|            newHash[newIndex] = ctxt->nsdb->hash[i];
 1770|      0|        }
 1771|       |
 1772|    289|        xmlFree(ctxt->nsdb->hash);
 1773|    289|        ctxt->nsdb->hash = newHash;
 1774|    289|        ctxt->nsdb->hashSize = newSize;
 1775|       |
 1776|       |        /*
 1777|       |         * Relookup
 1778|       |         */
 1779|    289|        index = hashValue & (newSize - 1);
 1780|       |
 1781|    289|        while (newHash[index].hashValue != 0) {
  ------------------
  |  Branch (1781:16): [True: 0, False: 289]
  ------------------
 1782|      0|            index++;
 1783|      0|            if (index == newSize)
  ------------------
  |  Branch (1783:17): [True: 0, False: 0]
  ------------------
 1784|      0|                index = 0;
 1785|      0|        }
 1786|       |
 1787|    289|        bucket = &newHash[index];
 1788|    289|    }
 1789|       |
 1790|    315|    bucket->hashValue = hashValue;
 1791|    315|    bucket->index = ctxt->nsNr;
 1792|    315|    ctxt->nsdb->hashElems++;
 1793|    315|    oldIndex = INT_MAX;
 1794|       |
 1795|    316|populate_entry:
 1796|    316|    nsIndex = ctxt->nsNr;
 1797|       |
 1798|    316|    ns = &ctxt->nsTab[nsIndex * 2];
 1799|    316|    ns[0] = prefix ? prefix->name : NULL;
  ------------------
  |  Branch (1799:13): [True: 316, False: 0]
  ------------------
 1800|    316|    ns[1] = uri->name;
 1801|       |
 1802|    316|    extra = &ctxt->nsdb->extra[nsIndex];
 1803|    316|    extra->saxData = saxData;
 1804|    316|    extra->prefixHashValue = prefix ? prefix->hashValue : 0;
  ------------------
  |  Branch (1804:30): [True: 316, False: 0]
  ------------------
 1805|    316|    extra->uriHashValue = uri->hashValue;
 1806|    316|    extra->elementId = ctxt->nsdb->elementId;
 1807|    316|    extra->oldIndex = oldIndex;
 1808|       |
 1809|    316|    ctxt->nsNr++;
 1810|       |
 1811|    316|    return(1);
 1812|    315|}
parser.c:xmlParserNsGrow:
 1622|    289|xmlParserNsGrow(xmlParserCtxtPtr ctxt) {
 1623|    289|    const xmlChar **table;
 1624|    289|    xmlParserNsExtra *extra;
 1625|    289|    int newSize;
 1626|       |
 1627|    289|    if (ctxt->nsMax > INT_MAX / 2)
  ------------------
  |  Branch (1627:9): [True: 0, False: 289]
  ------------------
 1628|      0|        goto error;
 1629|    289|    newSize = ctxt->nsMax ? ctxt->nsMax * 2 : 16;
  ------------------
  |  Branch (1629:15): [True: 0, False: 289]
  ------------------
 1630|       |
 1631|    289|    table = xmlRealloc(ctxt->nsTab, 2 * newSize * sizeof(table[0]));
 1632|    289|    if (table == NULL)
  ------------------
  |  Branch (1632:9): [True: 0, False: 289]
  ------------------
 1633|      0|        goto error;
 1634|    289|    ctxt->nsTab = table;
 1635|       |
 1636|    289|    extra = xmlRealloc(ctxt->nsdb->extra, newSize * sizeof(extra[0]));
 1637|    289|    if (extra == NULL)
  ------------------
  |  Branch (1637:9): [True: 0, False: 289]
  ------------------
 1638|      0|        goto error;
 1639|    289|    ctxt->nsdb->extra = extra;
 1640|       |
 1641|    289|    ctxt->nsMax = newSize;
 1642|    289|    return(0);
 1643|       |
 1644|      0|error:
 1645|      0|    xmlErrMemory(ctxt, NULL);
 1646|      0|    return(-1);
 1647|    289|}
parser.c:xmlParserNsPop:
 1825|    198|{
 1826|    198|    int i;
 1827|       |
 1828|       |    /* assert(nr <= ctxt->nsNr); */
 1829|       |
 1830|    400|    for (i = ctxt->nsNr - 1; i >= ctxt->nsNr - nr; i--) {
  ------------------
  |  Branch (1830:30): [True: 202, False: 198]
  ------------------
 1831|    202|        const xmlChar *prefix = ctxt->nsTab[i * 2];
 1832|    202|        xmlParserNsExtra *extra = &ctxt->nsdb->extra[i];
 1833|       |
 1834|    202|        if (prefix == NULL) {
  ------------------
  |  Branch (1834:13): [True: 0, False: 202]
  ------------------
 1835|      0|            ctxt->nsdb->defaultNsIndex = extra->oldIndex;
 1836|    202|        } else {
 1837|    202|            xmlHashedString hprefix;
 1838|    202|            xmlParserNsBucket *bucket = NULL;
 1839|       |
 1840|    202|            hprefix.name = prefix;
 1841|    202|            hprefix.hashValue = extra->prefixHashValue;
 1842|    202|            xmlParserNsLookup(ctxt, &hprefix, &bucket);
 1843|       |            /* assert(bucket && bucket->hashValue); */
 1844|    202|            bucket->index = extra->oldIndex;
 1845|    202|        }
 1846|    202|    }
 1847|       |
 1848|    198|    ctxt->nsNr -= nr;
 1849|    198|    return(nr);
 1850|    198|}
parser.c:xmlCtxtUseOptionsInternal:
14554|    444|{
14555|    444|    if (ctxt == NULL)
  ------------------
  |  Branch (14555:9): [True: 0, False: 444]
  ------------------
14556|      0|        return(-1);
14557|    444|    if (encoding != NULL) {
  ------------------
  |  Branch (14557:9): [True: 0, False: 444]
  ------------------
14558|      0|        if (ctxt->encoding != NULL)
  ------------------
  |  Branch (14558:13): [True: 0, False: 0]
  ------------------
14559|      0|	    xmlFree((xmlChar *) ctxt->encoding);
14560|      0|        ctxt->encoding = xmlStrdup((const xmlChar *) encoding);
14561|      0|    }
14562|    444|    if (options & XML_PARSE_RECOVER) {
  ------------------
  |  Branch (14562:9): [True: 3, False: 441]
  ------------------
14563|      3|        ctxt->recovery = 1;
14564|      3|        options -= XML_PARSE_RECOVER;
14565|      3|	ctxt->options |= XML_PARSE_RECOVER;
14566|      3|    } else
14567|    441|        ctxt->recovery = 0;
14568|    444|    if (options & XML_PARSE_DTDLOAD) {
  ------------------
  |  Branch (14568:9): [True: 442, False: 2]
  ------------------
14569|    442|        ctxt->loadsubset = XML_DETECT_IDS;
  ------------------
  |  |  141|    442|#define XML_DETECT_IDS		2
  ------------------
14570|    442|        options -= XML_PARSE_DTDLOAD;
14571|    442|	ctxt->options |= XML_PARSE_DTDLOAD;
14572|    442|    } else
14573|      2|        ctxt->loadsubset = 0;
14574|    444|    if (options & XML_PARSE_DTDATTR) {
  ------------------
  |  Branch (14574:9): [True: 0, False: 444]
  ------------------
14575|      0|        ctxt->loadsubset |= XML_COMPLETE_ATTRS;
  ------------------
  |  |  150|      0|#define XML_COMPLETE_ATTRS	4
  ------------------
14576|      0|        options -= XML_PARSE_DTDATTR;
14577|      0|	ctxt->options |= XML_PARSE_DTDATTR;
14578|      0|    }
14579|    444|    if (options & XML_PARSE_NOENT) {
  ------------------
  |  Branch (14579:9): [True: 440, False: 4]
  ------------------
14580|    440|        ctxt->replaceEntities = 1;
14581|       |        /* ctxt->loadsubset |= XML_DETECT_IDS; */
14582|    440|        options -= XML_PARSE_NOENT;
14583|    440|	ctxt->options |= XML_PARSE_NOENT;
14584|    440|    } else
14585|      4|        ctxt->replaceEntities = 0;
14586|    444|    if (options & XML_PARSE_PEDANTIC) {
  ------------------
  |  Branch (14586:9): [True: 0, False: 444]
  ------------------
14587|      0|        ctxt->pedantic = 1;
14588|      0|        options -= XML_PARSE_PEDANTIC;
14589|      0|	ctxt->options |= XML_PARSE_PEDANTIC;
14590|      0|    } else
14591|    444|        ctxt->pedantic = 0;
14592|    444|    if (options & XML_PARSE_NOBLANKS) {
  ------------------
  |  Branch (14592:9): [True: 5, False: 439]
  ------------------
14593|      5|        ctxt->keepBlanks = 0;
14594|      5|        ctxt->sax->ignorableWhitespace = xmlSAX2IgnorableWhitespace;
14595|      5|        options -= XML_PARSE_NOBLANKS;
14596|      5|	ctxt->options |= XML_PARSE_NOBLANKS;
14597|      5|    } else
14598|    439|        ctxt->keepBlanks = 1;
14599|    444|    if (options & XML_PARSE_DTDVALID) {
  ------------------
  |  Branch (14599:9): [True: 0, False: 444]
  ------------------
14600|      0|        ctxt->validate = 1;
14601|      0|        if (options & XML_PARSE_NOWARNING)
  ------------------
  |  Branch (14601:13): [True: 0, False: 0]
  ------------------
14602|      0|            ctxt->vctxt.warning = NULL;
14603|      0|        if (options & XML_PARSE_NOERROR)
  ------------------
  |  Branch (14603:13): [True: 0, False: 0]
  ------------------
14604|      0|            ctxt->vctxt.error = NULL;
14605|      0|        options -= XML_PARSE_DTDVALID;
14606|      0|	ctxt->options |= XML_PARSE_DTDVALID;
14607|      0|    } else
14608|    444|        ctxt->validate = 0;
14609|    444|    if (options & XML_PARSE_NOWARNING) {
  ------------------
  |  Branch (14609:9): [True: 0, False: 444]
  ------------------
14610|      0|        ctxt->sax->warning = NULL;
14611|      0|        options -= XML_PARSE_NOWARNING;
14612|      0|    }
14613|    444|    if (options & XML_PARSE_NOERROR) {
  ------------------
  |  Branch (14613:9): [True: 0, False: 444]
  ------------------
14614|      0|        ctxt->sax->error = NULL;
14615|      0|        ctxt->sax->fatalError = NULL;
14616|      0|        options -= XML_PARSE_NOERROR;
14617|      0|    }
14618|    444|#ifdef LIBXML_SAX1_ENABLED
14619|    444|    if (options & XML_PARSE_SAX1) {
  ------------------
  |  Branch (14619:9): [True: 3, False: 441]
  ------------------
14620|      3|        ctxt->sax->startElementNs = NULL;
14621|      3|        ctxt->sax->endElementNs = NULL;
14622|      3|        ctxt->sax->initialized = 1;
14623|      3|        options -= XML_PARSE_SAX1;
14624|      3|	ctxt->options |= XML_PARSE_SAX1;
14625|      3|    }
14626|    444|#endif /* LIBXML_SAX1_ENABLED */
14627|    444|    if (options & XML_PARSE_NODICT) {
  ------------------
  |  Branch (14627:9): [True: 3, False: 441]
  ------------------
14628|      3|        ctxt->dictNames = 0;
14629|      3|        options -= XML_PARSE_NODICT;
14630|      3|	ctxt->options |= XML_PARSE_NODICT;
14631|    441|    } else {
14632|    441|        ctxt->dictNames = 1;
14633|    441|    }
14634|    444|    if (options & XML_PARSE_NOCDATA) {
  ------------------
  |  Branch (14634:9): [True: 3, False: 441]
  ------------------
14635|      3|        ctxt->sax->cdataBlock = NULL;
14636|      3|        options -= XML_PARSE_NOCDATA;
14637|      3|	ctxt->options |= XML_PARSE_NOCDATA;
14638|      3|    }
14639|    444|    if (options & XML_PARSE_NSCLEAN) {
  ------------------
  |  Branch (14639:9): [True: 5, False: 439]
  ------------------
14640|      5|	ctxt->options |= XML_PARSE_NSCLEAN;
14641|      5|        options -= XML_PARSE_NSCLEAN;
14642|      5|    }
14643|    444|    if (options & XML_PARSE_NONET) {
  ------------------
  |  Branch (14643:9): [True: 5, False: 439]
  ------------------
14644|      5|	ctxt->options |= XML_PARSE_NONET;
14645|      5|        options -= XML_PARSE_NONET;
14646|      5|    }
14647|    444|    if (options & XML_PARSE_COMPACT) {
  ------------------
  |  Branch (14647:9): [True: 233, False: 211]
  ------------------
14648|    233|	ctxt->options |= XML_PARSE_COMPACT;
14649|    233|        options -= XML_PARSE_COMPACT;
14650|    233|    }
14651|    444|    if (options & XML_PARSE_OLD10) {
  ------------------
  |  Branch (14651:9): [True: 3, False: 441]
  ------------------
14652|      3|	ctxt->options |= XML_PARSE_OLD10;
14653|      3|        options -= XML_PARSE_OLD10;
14654|      3|    }
14655|    444|    if (options & XML_PARSE_NOBASEFIX) {
  ------------------
  |  Branch (14655:9): [True: 3, False: 441]
  ------------------
14656|      3|	ctxt->options |= XML_PARSE_NOBASEFIX;
14657|      3|        options -= XML_PARSE_NOBASEFIX;
14658|      3|    }
14659|    444|    if (options & XML_PARSE_HUGE) {
  ------------------
  |  Branch (14659:9): [True: 3, False: 441]
  ------------------
14660|      3|	ctxt->options |= XML_PARSE_HUGE;
14661|      3|        options -= XML_PARSE_HUGE;
14662|      3|        if (ctxt->dict != NULL)
  ------------------
  |  Branch (14662:13): [True: 3, False: 0]
  ------------------
14663|      3|            xmlDictSetLimit(ctxt->dict, 0);
14664|      3|    }
14665|    444|    if (options & XML_PARSE_OLDSAX) {
  ------------------
  |  Branch (14665:9): [True: 3, False: 441]
  ------------------
14666|      3|	ctxt->options |= XML_PARSE_OLDSAX;
14667|      3|        options -= XML_PARSE_OLDSAX;
14668|      3|    }
14669|    444|    if (options & XML_PARSE_IGNORE_ENC) {
  ------------------
  |  Branch (14669:9): [True: 3, False: 441]
  ------------------
14670|      3|	ctxt->options |= XML_PARSE_IGNORE_ENC;
14671|      3|        options -= XML_PARSE_IGNORE_ENC;
14672|      3|    }
14673|    444|    if (options & XML_PARSE_BIG_LINES) {
  ------------------
  |  Branch (14673:9): [True: 3, False: 441]
  ------------------
14674|      3|	ctxt->options |= XML_PARSE_BIG_LINES;
14675|      3|        options -= XML_PARSE_BIG_LINES;
14676|      3|    }
14677|    444|    ctxt->linenumbers = 1;
14678|    444|    return (options);
14679|    444|}
parser.c:xmlDoRead:
14731|    167|{
14732|    167|    xmlDocPtr ret;
14733|       |
14734|    167|    xmlCtxtUseOptionsInternal(ctxt, options, encoding);
14735|    167|    if (encoding != NULL) {
  ------------------
  |  Branch (14735:9): [True: 0, False: 167]
  ------------------
14736|      0|        xmlCharEncodingHandlerPtr hdlr;
14737|       |
14738|       |        /*
14739|       |         * TODO: We should consider to set XML_PARSE_IGNORE_ENC if the
14740|       |         * caller provided an encoding. Otherwise, we might switch to
14741|       |         * the encoding from the XML declaration which is likely to
14742|       |         * break things. Also see xmlSwitchInputEncoding.
14743|       |         */
14744|      0|	hdlr = xmlFindCharEncodingHandler(encoding);
14745|      0|	if (hdlr != NULL)
  ------------------
  |  Branch (14745:6): [True: 0, False: 0]
  ------------------
14746|      0|	    xmlSwitchToEncoding(ctxt, hdlr);
14747|      0|    }
14748|    167|    if ((URL != NULL) && (ctxt->input != NULL) &&
  ------------------
  |  Branch (14748:9): [True: 167, False: 0]
  |  Branch (14748:26): [True: 167, False: 0]
  ------------------
14749|    167|        (ctxt->input->filename == NULL))
  ------------------
  |  Branch (14749:9): [True: 167, False: 0]
  ------------------
14750|    167|        ctxt->input->filename = (char *) xmlStrdup((const xmlChar *) URL);
14751|    167|    xmlParseDocument(ctxt);
14752|    167|    if ((ctxt->wellFormed) || ctxt->recovery)
  ------------------
  |  Branch (14752:9): [True: 40, False: 127]
  |  Branch (14752:31): [True: 1, False: 126]
  ------------------
14753|     41|        ret = ctxt->myDoc;
14754|    126|    else {
14755|    126|        ret = NULL;
14756|    126|	if (ctxt->myDoc != NULL) {
  ------------------
  |  Branch (14756:6): [True: 119, False: 7]
  ------------------
14757|    119|	    xmlFreeDoc(ctxt->myDoc);
14758|    119|	}
14759|    126|    }
14760|    167|    ctxt->myDoc = NULL;
14761|    167|    if (!reuse) {
  ------------------
  |  Branch (14761:9): [True: 167, False: 0]
  ------------------
14762|    167|	xmlFreeParserCtxt(ctxt);
14763|    167|    }
14764|       |
14765|    167|    return (ret);
14766|    167|}

__xmlErrEncoding:
  136|     42|{
  137|     42|    if ((ctxt != NULL) && (ctxt->disableSAX != 0) &&
  ------------------
  |  Branch (137:9): [True: 42, False: 0]
  |  Branch (137:27): [True: 8, False: 34]
  ------------------
  138|     42|        (ctxt->instate == XML_PARSER_EOF))
  ------------------
  |  Branch (138:9): [True: 0, False: 8]
  ------------------
  139|      0|	return;
  140|     42|    if (ctxt != NULL)
  ------------------
  |  Branch (140:9): [True: 42, False: 0]
  ------------------
  141|     42|        ctxt->errNo = xmlerr;
  142|     42|    __xmlRaiseError(NULL, NULL, NULL,
  143|     42|                    ctxt, NULL, XML_FROM_PARSER, xmlerr, XML_ERR_FATAL,
  144|     42|                    NULL, 0, (const char *) str1, (const char *) str2,
  145|     42|                    NULL, 0, 0, msg, str1, str2);
  146|     42|    if (ctxt != NULL) {
  ------------------
  |  Branch (146:9): [True: 42, False: 0]
  ------------------
  147|     42|        ctxt->wellFormed = 0;
  148|     42|        if (ctxt->recovery == 0)
  ------------------
  |  Branch (148:13): [True: 42, False: 0]
  ------------------
  149|     42|            ctxt->disableSAX = 1;
  150|     42|    }
  151|     42|}
xmlFatalErr:
  190|    119|{
  191|    119|    const char *errmsg;
  192|       |
  193|    119|    if ((ctxt != NULL) && (ctxt->disableSAX != 0) &&
  ------------------
  |  Branch (193:9): [True: 119, False: 0]
  |  Branch (193:27): [True: 67, False: 52]
  ------------------
  194|    119|        (ctxt->instate == XML_PARSER_EOF))
  ------------------
  |  Branch (194:9): [True: 0, False: 67]
  ------------------
  195|      0|	return;
  196|    119|    switch (error) {
  197|      0|        case XML_ERR_INVALID_HEX_CHARREF:
  ------------------
  |  Branch (197:9): [True: 0, False: 119]
  ------------------
  198|      0|            errmsg = "CharRef: invalid hexadecimal value";
  199|      0|            break;
  200|      0|        case XML_ERR_INVALID_DEC_CHARREF:
  ------------------
  |  Branch (200:9): [True: 0, False: 119]
  ------------------
  201|      0|            errmsg = "CharRef: invalid decimal value";
  202|      0|            break;
  203|      0|        case XML_ERR_INVALID_CHARREF:
  ------------------
  |  Branch (203:9): [True: 0, False: 119]
  ------------------
  204|      0|            errmsg = "CharRef: invalid value";
  205|      0|            break;
  206|     35|        case XML_ERR_INTERNAL_ERROR:
  ------------------
  |  Branch (206:9): [True: 35, False: 84]
  ------------------
  207|     35|            errmsg = "internal error";
  208|     35|            break;
  209|      0|        case XML_ERR_PEREF_AT_EOF:
  ------------------
  |  Branch (209:9): [True: 0, False: 119]
  ------------------
  210|      0|            errmsg = "PEReference at end of document";
  211|      0|            break;
  212|      0|        case XML_ERR_PEREF_IN_PROLOG:
  ------------------
  |  Branch (212:9): [True: 0, False: 119]
  ------------------
  213|      0|            errmsg = "PEReference in prolog";
  214|      0|            break;
  215|      0|        case XML_ERR_PEREF_IN_EPILOG:
  ------------------
  |  Branch (215:9): [True: 0, False: 119]
  ------------------
  216|      0|            errmsg = "PEReference in epilog";
  217|      0|            break;
  218|      0|        case XML_ERR_PEREF_NO_NAME:
  ------------------
  |  Branch (218:9): [True: 0, False: 119]
  ------------------
  219|      0|            errmsg = "PEReference: no name";
  220|      0|            break;
  221|      0|        case XML_ERR_PEREF_SEMICOL_MISSING:
  ------------------
  |  Branch (221:9): [True: 0, False: 119]
  ------------------
  222|      0|            errmsg = "PEReference: expecting ';'";
  223|      0|            break;
  224|      0|        case XML_ERR_ENTITY_LOOP:
  ------------------
  |  Branch (224:9): [True: 0, False: 119]
  ------------------
  225|      0|            errmsg = "Detected an entity reference loop";
  226|      0|            break;
  227|      0|        case XML_ERR_ENTITY_NOT_STARTED:
  ------------------
  |  Branch (227:9): [True: 0, False: 119]
  ------------------
  228|      0|            errmsg = "EntityValue: \" or ' expected";
  229|      0|            break;
  230|      0|        case XML_ERR_ENTITY_PE_INTERNAL:
  ------------------
  |  Branch (230:9): [True: 0, False: 119]
  ------------------
  231|      0|            errmsg = "PEReferences forbidden in internal subset";
  232|      0|            break;
  233|      0|        case XML_ERR_ENTITY_NOT_FINISHED:
  ------------------
  |  Branch (233:9): [True: 0, False: 119]
  ------------------
  234|      0|            errmsg = "EntityValue: \" or ' expected";
  235|      0|            break;
  236|      9|        case XML_ERR_ATTRIBUTE_NOT_STARTED:
  ------------------
  |  Branch (236:9): [True: 9, False: 110]
  ------------------
  237|      9|            errmsg = "AttValue: \" or ' expected";
  238|      9|            break;
  239|     18|        case XML_ERR_LT_IN_ATTRIBUTE:
  ------------------
  |  Branch (239:9): [True: 18, False: 101]
  ------------------
  240|     18|            errmsg = "Unescaped '<' not allowed in attributes values";
  241|     18|            break;
  242|      0|        case XML_ERR_LITERAL_NOT_STARTED:
  ------------------
  |  Branch (242:9): [True: 0, False: 119]
  ------------------
  243|      0|            errmsg = "SystemLiteral \" or ' expected";
  244|      0|            break;
  245|      0|        case XML_ERR_LITERAL_NOT_FINISHED:
  ------------------
  |  Branch (245:9): [True: 0, False: 119]
  ------------------
  246|      0|            errmsg = "Unfinished System or Public ID \" or ' expected";
  247|      0|            break;
  248|      0|        case XML_ERR_MISPLACED_CDATA_END:
  ------------------
  |  Branch (248:9): [True: 0, False: 119]
  ------------------
  249|      0|            errmsg = "Sequence ']]>' not allowed in content";
  250|      0|            break;
  251|      0|        case XML_ERR_URI_REQUIRED:
  ------------------
  |  Branch (251:9): [True: 0, False: 119]
  ------------------
  252|      0|            errmsg = "SYSTEM or PUBLIC, the URI is missing";
  253|      0|            break;
  254|      0|        case XML_ERR_PUBID_REQUIRED:
  ------------------
  |  Branch (254:9): [True: 0, False: 119]
  ------------------
  255|      0|            errmsg = "PUBLIC, the Public Identifier is missing";
  256|      0|            break;
  257|      0|        case XML_ERR_HYPHEN_IN_COMMENT:
  ------------------
  |  Branch (257:9): [True: 0, False: 119]
  ------------------
  258|      0|            errmsg = "Comment must not contain '--' (double-hyphen)";
  259|      0|            break;
  260|      0|        case XML_ERR_PI_NOT_STARTED:
  ------------------
  |  Branch (260:9): [True: 0, False: 119]
  ------------------
  261|      0|            errmsg = "xmlParsePI : no target name";
  262|      0|            break;
  263|      0|        case XML_ERR_RESERVED_XML_NAME:
  ------------------
  |  Branch (263:9): [True: 0, False: 119]
  ------------------
  264|      0|            errmsg = "Invalid PI name";
  265|      0|            break;
  266|      0|        case XML_ERR_NOTATION_NOT_STARTED:
  ------------------
  |  Branch (266:9): [True: 0, False: 119]
  ------------------
  267|      0|            errmsg = "NOTATION: Name expected here";
  268|      0|            break;
  269|      0|        case XML_ERR_NOTATION_NOT_FINISHED:
  ------------------
  |  Branch (269:9): [True: 0, False: 119]
  ------------------
  270|      0|            errmsg = "'>' required to close NOTATION declaration";
  271|      0|            break;
  272|      0|        case XML_ERR_VALUE_REQUIRED:
  ------------------
  |  Branch (272:9): [True: 0, False: 119]
  ------------------
  273|      0|            errmsg = "Entity value required";
  274|      0|            break;
  275|      0|        case XML_ERR_URI_FRAGMENT:
  ------------------
  |  Branch (275:9): [True: 0, False: 119]
  ------------------
  276|      0|            errmsg = "Fragment not allowed";
  277|      0|            break;
  278|      0|        case XML_ERR_ATTLIST_NOT_STARTED:
  ------------------
  |  Branch (278:9): [True: 0, False: 119]
  ------------------
  279|      0|            errmsg = "'(' required to start ATTLIST enumeration";
  280|      0|            break;
  281|      0|        case XML_ERR_NMTOKEN_REQUIRED:
  ------------------
  |  Branch (281:9): [True: 0, False: 119]
  ------------------
  282|      0|            errmsg = "NmToken expected in ATTLIST enumeration";
  283|      0|            break;
  284|      0|        case XML_ERR_ATTLIST_NOT_FINISHED:
  ------------------
  |  Branch (284:9): [True: 0, False: 119]
  ------------------
  285|      0|            errmsg = "')' required to finish ATTLIST enumeration";
  286|      0|            break;
  287|      0|        case XML_ERR_MIXED_NOT_STARTED:
  ------------------
  |  Branch (287:9): [True: 0, False: 119]
  ------------------
  288|      0|            errmsg = "MixedContentDecl : '|' or ')*' expected";
  289|      0|            break;
  290|      0|        case XML_ERR_PCDATA_REQUIRED:
  ------------------
  |  Branch (290:9): [True: 0, False: 119]
  ------------------
  291|      0|            errmsg = "MixedContentDecl : '#PCDATA' expected";
  292|      0|            break;
  293|      0|        case XML_ERR_ELEMCONTENT_NOT_STARTED:
  ------------------
  |  Branch (293:9): [True: 0, False: 119]
  ------------------
  294|      0|            errmsg = "ContentDecl : Name or '(' expected";
  295|      0|            break;
  296|      0|        case XML_ERR_ELEMCONTENT_NOT_FINISHED:
  ------------------
  |  Branch (296:9): [True: 0, False: 119]
  ------------------
  297|      0|            errmsg = "ContentDecl : ',' '|' or ')' expected";
  298|      0|            break;
  299|      0|        case XML_ERR_PEREF_IN_INT_SUBSET:
  ------------------
  |  Branch (299:9): [True: 0, False: 119]
  ------------------
  300|      0|            errmsg =
  301|      0|                "PEReference: forbidden within markup decl in internal subset";
  302|      0|            break;
  303|     29|        case XML_ERR_GT_REQUIRED:
  ------------------
  |  Branch (303:9): [True: 29, False: 90]
  ------------------
  304|     29|            errmsg = "expected '>'";
  305|     29|            break;
  306|      0|        case XML_ERR_CONDSEC_INVALID:
  ------------------
  |  Branch (306:9): [True: 0, False: 119]
  ------------------
  307|      0|            errmsg = "XML conditional section '[' expected";
  308|      0|            break;
  309|      0|        case XML_ERR_EXT_SUBSET_NOT_FINISHED:
  ------------------
  |  Branch (309:9): [True: 0, False: 119]
  ------------------
  310|      0|            errmsg = "Content error in the external subset";
  311|      0|            break;
  312|      0|        case XML_ERR_CONDSEC_INVALID_KEYWORD:
  ------------------
  |  Branch (312:9): [True: 0, False: 119]
  ------------------
  313|      0|            errmsg =
  314|      0|                "conditional section INCLUDE or IGNORE keyword expected";
  315|      0|            break;
  316|      0|        case XML_ERR_CONDSEC_NOT_FINISHED:
  ------------------
  |  Branch (316:9): [True: 0, False: 119]
  ------------------
  317|      0|            errmsg = "XML conditional section not closed";
  318|      0|            break;
  319|      0|        case XML_ERR_XMLDECL_NOT_STARTED:
  ------------------
  |  Branch (319:9): [True: 0, False: 119]
  ------------------
  320|      0|            errmsg = "Text declaration '<?xml' required";
  321|      0|            break;
  322|     14|        case XML_ERR_XMLDECL_NOT_FINISHED:
  ------------------
  |  Branch (322:9): [True: 14, False: 105]
  ------------------
  323|     14|            errmsg = "parsing XML declaration: '?>' expected";
  324|     14|            break;
  325|      0|        case XML_ERR_EXT_ENTITY_STANDALONE:
  ------------------
  |  Branch (325:9): [True: 0, False: 119]
  ------------------
  326|      0|            errmsg = "external parsed entities cannot be standalone";
  327|      0|            break;
  328|      0|        case XML_ERR_ENTITYREF_SEMICOL_MISSING:
  ------------------
  |  Branch (328:9): [True: 0, False: 119]
  ------------------
  329|      0|            errmsg = "EntityRef: expecting ';'";
  330|      0|            break;
  331|      0|        case XML_ERR_DOCTYPE_NOT_FINISHED:
  ------------------
  |  Branch (331:9): [True: 0, False: 119]
  ------------------
  332|      0|            errmsg = "DOCTYPE improperly terminated";
  333|      0|            break;
  334|      0|        case XML_ERR_LTSLASH_REQUIRED:
  ------------------
  |  Branch (334:9): [True: 0, False: 119]
  ------------------
  335|      0|            errmsg = "EndTag: '</' not found";
  336|      0|            break;
  337|      2|        case XML_ERR_EQUAL_REQUIRED:
  ------------------
  |  Branch (337:9): [True: 2, False: 117]
  ------------------
  338|      2|            errmsg = "expected '='";
  339|      2|            break;
  340|      0|        case XML_ERR_STRING_NOT_CLOSED:
  ------------------
  |  Branch (340:9): [True: 0, False: 119]
  ------------------
  341|      0|            errmsg = "String not closed expecting \" or '";
  342|      0|            break;
  343|      8|        case XML_ERR_STRING_NOT_STARTED:
  ------------------
  |  Branch (343:9): [True: 8, False: 111]
  ------------------
  344|      8|            errmsg = "String not started expecting ' or \"";
  345|      8|            break;
  346|      0|        case XML_ERR_ENCODING_NAME:
  ------------------
  |  Branch (346:9): [True: 0, False: 119]
  ------------------
  347|      0|            errmsg = "Invalid XML encoding name";
  348|      0|            break;
  349|      0|        case XML_ERR_STANDALONE_VALUE:
  ------------------
  |  Branch (349:9): [True: 0, False: 119]
  ------------------
  350|      0|            errmsg = "standalone accepts only 'yes' or 'no'";
  351|      0|            break;
  352|      0|        case XML_ERR_DOCUMENT_EMPTY:
  ------------------
  |  Branch (352:9): [True: 0, False: 119]
  ------------------
  353|      0|            errmsg = "Document is empty";
  354|      0|            break;
  355|      0|        case XML_ERR_DOCUMENT_END:
  ------------------
  |  Branch (355:9): [True: 0, False: 119]
  ------------------
  356|      0|            errmsg = "Extra content at the end of the document";
  357|      0|            break;
  358|      0|        case XML_ERR_NOT_WELL_BALANCED:
  ------------------
  |  Branch (358:9): [True: 0, False: 119]
  ------------------
  359|      0|            errmsg = "chunk is not well balanced";
  360|      0|            break;
  361|      0|        case XML_ERR_EXTRA_CONTENT:
  ------------------
  |  Branch (361:9): [True: 0, False: 119]
  ------------------
  362|      0|            errmsg = "extra content at the end of well balanced chunk";
  363|      0|            break;
  364|      4|        case XML_ERR_VERSION_MISSING:
  ------------------
  |  Branch (364:9): [True: 4, False: 115]
  ------------------
  365|      4|            errmsg = "Malformed declaration expecting version";
  366|      4|            break;
  367|      0|        case XML_ERR_NAME_TOO_LONG:
  ------------------
  |  Branch (367:9): [True: 0, False: 119]
  ------------------
  368|      0|            errmsg = "Name too long";
  369|      0|            break;
  370|      0|        case XML_ERR_INVALID_ENCODING:
  ------------------
  |  Branch (370:9): [True: 0, False: 119]
  ------------------
  371|      0|            errmsg = "Invalid bytes in character encoding";
  372|      0|            break;
  373|      0|        case XML_IO_UNKNOWN:
  ------------------
  |  Branch (373:9): [True: 0, False: 119]
  ------------------
  374|      0|            errmsg = "I/O error";
  375|      0|            break;
  376|       |#if 0
  377|       |        case:
  378|       |            errmsg = "";
  379|       |            break;
  380|       |#endif
  381|      0|        default:
  ------------------
  |  Branch (381:9): [True: 0, False: 119]
  ------------------
  382|      0|            errmsg = "Unregistered error message";
  383|    119|    }
  384|    119|    if (ctxt != NULL)
  ------------------
  |  Branch (384:9): [True: 119, False: 0]
  ------------------
  385|    119|	ctxt->errNo = error;
  386|    119|    if (info == NULL) {
  ------------------
  |  Branch (386:9): [True: 84, False: 35]
  ------------------
  387|     84|        __xmlRaiseError(NULL, NULL, NULL, ctxt, NULL, XML_FROM_PARSER, error,
  388|     84|                        XML_ERR_FATAL, NULL, 0, info, NULL, NULL, 0, 0, "%s\n",
  389|     84|                        errmsg);
  390|     84|    } else {
  391|     35|        __xmlRaiseError(NULL, NULL, NULL, ctxt, NULL, XML_FROM_PARSER, error,
  392|     35|                        XML_ERR_FATAL, NULL, 0, info, NULL, NULL, 0, 0, "%s: %s\n",
  393|     35|                        errmsg, info);
  394|     35|    }
  395|    119|    if (ctxt != NULL) {
  ------------------
  |  Branch (395:9): [True: 119, False: 0]
  ------------------
  396|    119|	ctxt->wellFormed = 0;
  397|    119|	if (ctxt->recovery == 0)
  ------------------
  |  Branch (397:6): [True: 119, False: 0]
  ------------------
  398|    119|	    ctxt->disableSAX = 1;
  399|    119|    }
  400|    119|}
xmlHaltParser:
  461|    193|xmlHaltParser(xmlParserCtxtPtr ctxt) {
  462|    193|    if (ctxt == NULL)
  ------------------
  |  Branch (462:9): [True: 0, False: 193]
  ------------------
  463|      0|        return;
  464|    193|    ctxt->instate = XML_PARSER_EOF;
  465|    193|    ctxt->disableSAX = 1;
  466|    193|    while (ctxt->inputNr > 1)
  ------------------
  |  Branch (466:12): [True: 0, False: 193]
  ------------------
  467|      0|        xmlFreeInputStream(inputPop(ctxt));
  468|    193|    if (ctxt->input != NULL) {
  ------------------
  |  Branch (468:9): [True: 193, False: 0]
  ------------------
  469|       |        /*
  470|       |	 * in case there was a specific allocation deallocate before
  471|       |	 * overriding base
  472|       |	 */
  473|    193|        if (ctxt->input->free != NULL) {
  ------------------
  |  Branch (473:13): [True: 0, False: 193]
  ------------------
  474|      0|	    ctxt->input->free((xmlChar *) ctxt->input->base);
  475|      0|	    ctxt->input->free = NULL;
  476|      0|	}
  477|    193|        if (ctxt->input->buf != NULL) {
  ------------------
  |  Branch (477:13): [True: 167, False: 26]
  ------------------
  478|    167|            xmlFreeParserInputBuffer(ctxt->input->buf);
  479|    167|            ctxt->input->buf = NULL;
  480|    167|        }
  481|    193|	ctxt->input->cur = BAD_CAST"";
  ------------------
  |  |   35|    193|#define BAD_CAST (xmlChar *)
  ------------------
  482|    193|        ctxt->input->length = 0;
  483|    193|	ctxt->input->base = ctxt->input->cur;
  484|    193|        ctxt->input->end = ctxt->input->cur;
  485|    193|    }
  486|    193|}
xmlParserGrow:
  511|  22.2k|xmlParserGrow(xmlParserCtxtPtr ctxt) {
  512|  22.2k|    xmlParserInputPtr in = ctxt->input;
  513|  22.2k|    xmlParserInputBufferPtr buf = in->buf;
  514|  22.2k|    ptrdiff_t curEnd = in->end - in->cur;
  515|  22.2k|    ptrdiff_t curBase = in->cur - in->base;
  516|  22.2k|    int ret;
  517|       |
  518|  22.2k|    if (buf == NULL)
  ------------------
  |  Branch (518:9): [True: 0, False: 22.2k]
  ------------------
  519|      0|        return(0);
  520|       |    /* Don't grow push parser buffer. */
  521|  22.2k|    if ((ctxt->progressive) && (ctxt->inputNr <= 1))
  ------------------
  |  Branch (521:9): [True: 8.30k, False: 13.9k]
  |  Branch (521:32): [True: 8.30k, False: 0]
  ------------------
  522|  8.30k|        return(0);
  523|  13.9k|    if (buf->error != 0)
  ------------------
  |  Branch (523:9): [True: 0, False: 13.9k]
  ------------------
  524|      0|        return(-1);
  525|       |
  526|  13.9k|    if (((curEnd > XML_MAX_LOOKUP_LIMIT) ||
  ------------------
  |  |   81|  13.9k|#define XML_MAX_LOOKUP_LIMIT 10000000
  ------------------
  |  Branch (526:10): [True: 0, False: 13.9k]
  ------------------
  527|  13.9k|         (curBase > XML_MAX_LOOKUP_LIMIT)) &&
  ------------------
  |  |   81|  13.9k|#define XML_MAX_LOOKUP_LIMIT 10000000
  ------------------
  |  Branch (527:10): [True: 0, False: 13.9k]
  ------------------
  528|  13.9k|        ((ctxt->options & XML_PARSE_HUGE) == 0)) {
  ------------------
  |  Branch (528:9): [True: 0, False: 0]
  ------------------
  529|      0|        xmlErrMemory(ctxt, "Huge input lookup");
  530|      0|        xmlHaltParser(ctxt);
  531|      0|	return(-1);
  532|      0|    }
  533|       |
  534|  13.9k|    if (curEnd >= INPUT_CHUNK)
  ------------------
  |  |   97|  13.9k|#define INPUT_CHUNK	250
  ------------------
  |  Branch (534:9): [True: 65, False: 13.8k]
  ------------------
  535|     65|        return(0);
  536|       |
  537|  13.8k|    ret = xmlParserInputBufferGrow(buf, INPUT_CHUNK);
  ------------------
  |  |   97|  13.8k|#define INPUT_CHUNK	250
  ------------------
  538|  13.8k|    xmlBufUpdateInput(buf->buffer, in, curBase);
  539|       |
  540|  13.8k|    if (ret < 0) {
  ------------------
  |  Branch (540:9): [True: 0, False: 13.8k]
  ------------------
  541|      0|        xmlFatalErr(ctxt, buf->error, NULL);
  542|       |        /* Buffer contents may be lost in case of memory errors. */
  543|      0|        if (buf->error == XML_ERR_NO_MEMORY)
  ------------------
  |  Branch (543:13): [True: 0, False: 0]
  ------------------
  544|      0|            xmlHaltParser(ctxt);
  545|      0|    }
  546|       |
  547|  13.8k|    return(ret);
  548|  13.9k|}
xmlParserShrink:
  600|     21|xmlParserShrink(xmlParserCtxtPtr ctxt) {
  601|     21|    xmlParserInputPtr in = ctxt->input;
  602|     21|    xmlParserInputBufferPtr buf = in->buf;
  603|     21|    size_t used;
  604|       |
  605|     21|    if (buf == NULL)
  ------------------
  |  Branch (605:9): [True: 0, False: 21]
  ------------------
  606|      0|        return;
  607|       |
  608|     21|    used = in->cur - in->base;
  609|       |    /*
  610|       |     * Do not shrink on large buffers whose only a tiny fraction
  611|       |     * was consumed
  612|       |     */
  613|     21|    if (used > INPUT_CHUNK) {
  ------------------
  |  |   97|     21|#define INPUT_CHUNK	250
  ------------------
  |  Branch (613:9): [True: 21, False: 0]
  ------------------
  614|     21|	size_t res = xmlBufShrink(buf->buffer, used - LINE_LEN);
  ------------------
  |  |  451|     21|#define LINE_LEN        80
  ------------------
  615|       |
  616|     21|	if (res > 0) {
  ------------------
  |  Branch (616:6): [True: 21, False: 0]
  ------------------
  617|     21|            used -= res;
  618|     21|            if ((res > ULONG_MAX) ||
  ------------------
  |  Branch (618:17): [True: 0, False: 21]
  ------------------
  619|     21|                (in->consumed > ULONG_MAX - (unsigned long)res))
  ------------------
  |  Branch (619:17): [True: 0, False: 21]
  ------------------
  620|      0|                in->consumed = ULONG_MAX;
  621|     21|            else
  622|     21|                in->consumed += res;
  623|     21|	}
  624|     21|    }
  625|       |
  626|     21|    xmlBufUpdateInput(buf->buffer, in, used);
  627|     21|}
xmlNextChar:
  698|  4.88k|{
  699|  4.88k|    const unsigned char *cur;
  700|  4.88k|    size_t avail;
  701|  4.88k|    int c;
  702|       |
  703|  4.88k|    if ((ctxt == NULL) || (ctxt->instate == XML_PARSER_EOF) ||
  ------------------
  |  Branch (703:9): [True: 0, False: 4.88k]
  |  Branch (703:27): [True: 0, False: 4.88k]
  ------------------
  704|  4.88k|        (ctxt->input == NULL))
  ------------------
  |  Branch (704:9): [True: 0, False: 4.88k]
  ------------------
  705|      0|        return;
  706|       |
  707|  4.88k|    avail = ctxt->input->end - ctxt->input->cur;
  708|       |
  709|  4.88k|    if (avail < INPUT_CHUNK) {
  ------------------
  |  |   97|  4.88k|#define INPUT_CHUNK	250
  ------------------
  |  Branch (709:9): [True: 2.69k, False: 2.19k]
  ------------------
  710|  2.69k|        xmlParserGrow(ctxt);
  711|  2.69k|        if ((ctxt->instate == XML_PARSER_EOF) ||
  ------------------
  |  Branch (711:13): [True: 0, False: 2.69k]
  ------------------
  712|  2.69k|            (ctxt->input->cur >= ctxt->input->end))
  ------------------
  |  Branch (712:13): [True: 0, False: 2.69k]
  ------------------
  713|      0|            return;
  714|  2.69k|        avail = ctxt->input->end - ctxt->input->cur;
  715|  2.69k|    }
  716|       |
  717|  4.88k|    cur = ctxt->input->cur;
  718|  4.88k|    c = *cur;
  719|       |
  720|  4.88k|    if (c < 0x80) {
  ------------------
  |  Branch (720:9): [True: 4.88k, False: 0]
  ------------------
  721|  4.88k|        if (c == '\n') {
  ------------------
  |  Branch (721:13): [True: 38, False: 4.84k]
  ------------------
  722|     38|            ctxt->input->cur++;
  723|     38|            ctxt->input->line++;
  724|     38|            ctxt->input->col = 1;
  725|  4.84k|        } else if (c == '\r') {
  ------------------
  |  Branch (725:20): [True: 0, False: 4.84k]
  ------------------
  726|       |            /*
  727|       |             *   2.11 End-of-Line Handling
  728|       |             *   the literal two-character sequence "#xD#xA" or a standalone
  729|       |             *   literal #xD, an XML processor must pass to the application
  730|       |             *   the single character #xA.
  731|       |             */
  732|      0|            ctxt->input->cur += ((cur[1] == '\n') ? 2 : 1);
  ------------------
  |  Branch (732:34): [True: 0, False: 0]
  ------------------
  733|      0|            ctxt->input->line++;
  734|      0|            ctxt->input->col = 1;
  735|      0|            return;
  736|  4.84k|        } else {
  737|  4.84k|            ctxt->input->cur++;
  738|  4.84k|            ctxt->input->col++;
  739|  4.84k|        }
  740|  4.88k|    } else {
  741|      0|        ctxt->input->col++;
  742|       |
  743|      0|        if ((avail < 2) || (cur[1] & 0xc0) != 0x80)
  ------------------
  |  Branch (743:13): [True: 0, False: 0]
  |  Branch (743:28): [True: 0, False: 0]
  ------------------
  744|      0|            goto encoding_error;
  745|       |
  746|      0|        if (c < 0xe0) {
  ------------------
  |  Branch (746:13): [True: 0, False: 0]
  ------------------
  747|       |            /* 2-byte code */
  748|      0|            if (c < 0xc2)
  ------------------
  |  Branch (748:17): [True: 0, False: 0]
  ------------------
  749|      0|                goto encoding_error;
  750|      0|            ctxt->input->cur += 2;
  751|      0|        } else {
  752|      0|            unsigned int val = (c << 8) | cur[1];
  753|       |
  754|      0|            if ((avail < 3) || (cur[2] & 0xc0) != 0x80)
  ------------------
  |  Branch (754:17): [True: 0, False: 0]
  |  Branch (754:32): [True: 0, False: 0]
  ------------------
  755|      0|                goto encoding_error;
  756|       |
  757|      0|            if (c < 0xf0) {
  ------------------
  |  Branch (757:17): [True: 0, False: 0]
  ------------------
  758|       |                /* 3-byte code */
  759|      0|                if ((val < 0xe0a0) || ((val >= 0xeda0) && (val < 0xee00)))
  ------------------
  |  Branch (759:21): [True: 0, False: 0]
  |  Branch (759:40): [True: 0, False: 0]
  |  Branch (759:59): [True: 0, False: 0]
  ------------------
  760|      0|                    goto encoding_error;
  761|      0|                ctxt->input->cur += 3;
  762|      0|            } else {
  763|      0|                if ((avail < 4) || ((cur[3] & 0xc0) != 0x80))
  ------------------
  |  Branch (763:21): [True: 0, False: 0]
  |  Branch (763:36): [True: 0, False: 0]
  ------------------
  764|      0|                    goto encoding_error;
  765|       |
  766|       |                /* 4-byte code */
  767|      0|                if ((val < 0xf090) || (val >= 0xf490))
  ------------------
  |  Branch (767:21): [True: 0, False: 0]
  |  Branch (767:39): [True: 0, False: 0]
  ------------------
  768|      0|                    goto encoding_error;
  769|      0|                ctxt->input->cur += 4;
  770|      0|            }
  771|      0|        }
  772|      0|    }
  773|       |
  774|  4.88k|    return;
  775|       |
  776|  4.88k|encoding_error:
  777|       |    /* Only report the first error */
  778|      0|    if ((ctxt->input->flags & XML_INPUT_ENCODING_ERROR) == 0) {
  ------------------
  |  |   27|      0|#define XML_INPUT_ENCODING_ERROR    (1u << 5)
  ------------------
  |  Branch (778:9): [True: 0, False: 0]
  ------------------
  779|      0|        if ((ctxt == NULL) || (ctxt->input == NULL) ||
  ------------------
  |  Branch (779:13): [True: 0, False: 0]
  |  Branch (779:31): [True: 0, False: 0]
  ------------------
  780|      0|            (ctxt->input->end - ctxt->input->cur < 4)) {
  ------------------
  |  Branch (780:13): [True: 0, False: 0]
  ------------------
  781|      0|            __xmlErrEncoding(ctxt, XML_ERR_INVALID_CHAR,
  782|      0|                         "Input is not proper UTF-8, indicate encoding !\n",
  783|      0|                         NULL, NULL);
  784|      0|        } else {
  785|      0|            char buffer[150];
  786|       |
  787|      0|            snprintf(buffer, 149, "Bytes: 0x%02X 0x%02X 0x%02X 0x%02X\n",
  788|      0|                            ctxt->input->cur[0], ctxt->input->cur[1],
  789|      0|                            ctxt->input->cur[2], ctxt->input->cur[3]);
  790|      0|            __xmlErrEncoding(ctxt, XML_ERR_INVALID_CHAR,
  791|      0|                         "Input is not proper UTF-8, indicate encoding !\n%s",
  792|      0|                         BAD_CAST buffer, NULL);
  ------------------
  |  |   35|      0|#define BAD_CAST (xmlChar *)
  ------------------
  793|      0|        }
  794|      0|        ctxt->input->flags |= XML_INPUT_ENCODING_ERROR;
  ------------------
  |  |   27|      0|#define XML_INPUT_ENCODING_ERROR    (1u << 5)
  ------------------
  795|      0|    }
  796|      0|    ctxt->input->cur++;
  797|      0|    return;
  798|  4.88k|}
xmlCurrentChar:
  821|  4.07k|xmlCurrentChar(xmlParserCtxtPtr ctxt, int *len) {
  822|  4.07k|    const unsigned char *cur;
  823|  4.07k|    size_t avail;
  824|  4.07k|    int c;
  825|       |
  826|  4.07k|    if ((ctxt == NULL) || (len == NULL) || (ctxt->input == NULL)) return(0);
  ------------------
  |  Branch (826:9): [True: 0, False: 4.07k]
  |  Branch (826:27): [True: 0, False: 4.07k]
  |  Branch (826:44): [True: 0, False: 4.07k]
  ------------------
  827|  4.07k|    if (ctxt->instate == XML_PARSER_EOF)
  ------------------
  |  Branch (827:9): [True: 0, False: 4.07k]
  ------------------
  828|      0|	return(0);
  829|       |
  830|  4.07k|    avail = ctxt->input->end - ctxt->input->cur;
  831|       |
  832|  4.07k|    if (avail < INPUT_CHUNK) {
  ------------------
  |  |   97|  4.07k|#define INPUT_CHUNK	250
  ------------------
  |  Branch (832:9): [True: 3.61k, False: 465]
  ------------------
  833|  3.61k|        xmlParserGrow(ctxt);
  834|  3.61k|        if (ctxt->instate == XML_PARSER_EOF)
  ------------------
  |  Branch (834:13): [True: 0, False: 3.61k]
  ------------------
  835|      0|            return(0);
  836|  3.61k|        avail = ctxt->input->end - ctxt->input->cur;
  837|  3.61k|    }
  838|       |
  839|  4.07k|    cur = ctxt->input->cur;
  840|  4.07k|    c = *cur;
  841|       |
  842|  4.07k|    if (c < 0x80) {
  ------------------
  |  Branch (842:9): [True: 2.80k, False: 1.27k]
  ------------------
  843|       |	/* 1-byte code */
  844|  2.80k|        if (c < 0x20) {
  ------------------
  |  Branch (844:13): [True: 925, False: 1.88k]
  ------------------
  845|       |            /*
  846|       |             *   2.11 End-of-Line Handling
  847|       |             *   the literal two-character sequence "#xD#xA" or a standalone
  848|       |             *   literal #xD, an XML processor must pass to the application
  849|       |             *   the single character #xA.
  850|       |             */
  851|    925|            if (c == '\r') {
  ------------------
  |  Branch (851:17): [True: 0, False: 925]
  ------------------
  852|      0|                *len = ((cur[1] == '\n') ? 2 : 1);
  ------------------
  |  Branch (852:25): [True: 0, False: 0]
  ------------------
  853|      0|                c = '\n';
  854|    925|            } else if (c == 0) {
  ------------------
  |  Branch (854:24): [True: 730, False: 195]
  ------------------
  855|    730|                if (ctxt->input->cur >= ctxt->input->end) {
  ------------------
  |  Branch (855:21): [True: 41, False: 689]
  ------------------
  856|     41|                    *len = 0;
  857|    689|                } else {
  858|    689|                    *len = 1;
  859|       |                    /*
  860|       |                     * TODO: Null bytes should be handled by callers,
  861|       |                     * but this can be tricky.
  862|       |                     */
  863|    689|                    xmlErrEncodingInt(ctxt, XML_ERR_INVALID_CHAR,
  864|    689|                            "Char 0x0 out of allowed range\n", c);
  865|    689|                }
  866|    730|            } else {
  867|    195|                *len = 1;
  868|    195|            }
  869|  1.88k|        } else {
  870|  1.88k|            *len = 1;
  871|  1.88k|        }
  872|       |
  873|  2.80k|        return(c);
  874|  2.80k|    } else {
  875|  1.27k|        int val;
  876|       |
  877|  1.27k|        if (avail < 2)
  ------------------
  |  Branch (877:13): [True: 0, False: 1.27k]
  ------------------
  878|      0|            goto incomplete_sequence;
  879|  1.27k|        if ((cur[1] & 0xc0) != 0x80)
  ------------------
  |  Branch (879:13): [True: 741, False: 532]
  ------------------
  880|    741|            goto encoding_error;
  881|       |
  882|    532|        if (c < 0xe0) {
  ------------------
  |  Branch (882:13): [True: 532, False: 0]
  ------------------
  883|       |            /* 2-byte code */
  884|    532|            if (c < 0xc2)
  ------------------
  |  Branch (884:17): [True: 101, False: 431]
  ------------------
  885|    101|                goto encoding_error;
  886|    431|            val = (c & 0x1f) << 6;
  887|    431|            val |= cur[1] & 0x3f;
  888|    431|            *len = 2;
  889|    431|        } else {
  890|      0|            if (avail < 3)
  ------------------
  |  Branch (890:17): [True: 0, False: 0]
  ------------------
  891|      0|                goto incomplete_sequence;
  892|      0|            if ((cur[2] & 0xc0) != 0x80)
  ------------------
  |  Branch (892:17): [True: 0, False: 0]
  ------------------
  893|      0|                goto encoding_error;
  894|       |
  895|      0|            if (c < 0xf0) {
  ------------------
  |  Branch (895:17): [True: 0, False: 0]
  ------------------
  896|       |                /* 3-byte code */
  897|      0|                val = (c & 0xf) << 12;
  898|      0|                val |= (cur[1] & 0x3f) << 6;
  899|      0|                val |= cur[2] & 0x3f;
  900|      0|                if ((val < 0x800) || ((val >= 0xd800) && (val < 0xe000)))
  ------------------
  |  Branch (900:21): [True: 0, False: 0]
  |  Branch (900:39): [True: 0, False: 0]
  |  Branch (900:58): [True: 0, False: 0]
  ------------------
  901|      0|                    goto encoding_error;
  902|      0|                *len = 3;
  903|      0|            } else {
  904|      0|                if (avail < 4)
  ------------------
  |  Branch (904:21): [True: 0, False: 0]
  ------------------
  905|      0|                    goto incomplete_sequence;
  906|      0|                if ((cur[3] & 0xc0) != 0x80)
  ------------------
  |  Branch (906:21): [True: 0, False: 0]
  ------------------
  907|      0|                    goto encoding_error;
  908|       |
  909|       |                /* 4-byte code */
  910|      0|                val = (c & 0x0f) << 18;
  911|      0|                val |= (cur[1] & 0x3f) << 12;
  912|      0|                val |= (cur[2] & 0x3f) << 6;
  913|      0|                val |= cur[3] & 0x3f;
  914|      0|                if ((val < 0x10000) || (val >= 0x110000))
  ------------------
  |  Branch (914:21): [True: 0, False: 0]
  |  Branch (914:40): [True: 0, False: 0]
  ------------------
  915|      0|                    goto encoding_error;
  916|      0|                *len = 4;
  917|      0|            }
  918|      0|        }
  919|       |
  920|    431|        return(val);
  921|    532|    }
  922|       |
  923|    842|encoding_error:
  924|       |    /* Only report the first error */
  925|    842|    if ((ctxt->input->flags & XML_INPUT_ENCODING_ERROR) == 0) {
  ------------------
  |  |   27|    842|#define XML_INPUT_ENCODING_ERROR    (1u << 5)
  ------------------
  |  Branch (925:9): [True: 42, False: 800]
  ------------------
  926|     42|        if (ctxt->input->end - ctxt->input->cur < 4) {
  ------------------
  |  Branch (926:13): [True: 0, False: 42]
  ------------------
  927|      0|            __xmlErrEncoding(ctxt, XML_ERR_INVALID_CHAR,
  928|      0|                         "Input is not proper UTF-8, indicate encoding !\n",
  929|      0|                         NULL, NULL);
  930|     42|        } else {
  931|     42|            char buffer[150];
  932|       |
  933|     42|            snprintf(&buffer[0], 149, "Bytes: 0x%02X 0x%02X 0x%02X 0x%02X\n",
  934|     42|                            ctxt->input->cur[0], ctxt->input->cur[1],
  935|     42|                            ctxt->input->cur[2], ctxt->input->cur[3]);
  936|     42|            __xmlErrEncoding(ctxt, XML_ERR_INVALID_CHAR,
  937|     42|                         "Input is not proper UTF-8, indicate encoding !\n%s",
  938|     42|                         BAD_CAST buffer, NULL);
  ------------------
  |  |   35|     42|#define BAD_CAST (xmlChar *)
  ------------------
  939|     42|        }
  940|     42|        ctxt->input->flags |= XML_INPUT_ENCODING_ERROR;
  ------------------
  |  |   27|     42|#define XML_INPUT_ENCODING_ERROR    (1u << 5)
  ------------------
  941|     42|    }
  942|    842|    *len = 1;
  943|    842|    return(0xFFFD); /* U+FFFD Replacement Character */
  944|       |
  945|      0|incomplete_sequence:
  946|       |    /*
  947|       |     * An encoding problem may arise from a truncated input buffer
  948|       |     * splitting a character in the middle. In that case do not raise
  949|       |     * an error but return 0. This should only happen when push parsing
  950|       |     * char data.
  951|       |     */
  952|      0|    *len = 0;
  953|      0|    return(0);
  954|  4.07k|}
xmlStringCurrentChar:
  972|    346|                     const xmlChar *cur, int *len) {
  973|    346|    int c;
  974|       |
  975|    346|    if ((cur == NULL) || (len == NULL))
  ------------------
  |  Branch (975:9): [True: 0, False: 346]
  |  Branch (975:26): [True: 0, False: 346]
  ------------------
  976|      0|        return(0);
  977|       |
  978|       |    /* cur is zero-terminated, so we can lie about its length. */
  979|    346|    *len = 4;
  980|    346|    c = xmlGetUTF8Char(cur, len);
  981|       |
  982|    346|    return((c < 0) ? 0 : c);
  ------------------
  |  Branch (982:12): [True: 0, False: 346]
  ------------------
  983|    346|}
xmlCopyCharMultiByte:
  995|  1.16k|xmlCopyCharMultiByte(xmlChar *out, int val) {
  996|  1.16k|    if ((out == NULL) || (val < 0)) return(0);
  ------------------
  |  Branch (996:9): [True: 0, False: 1.16k]
  |  Branch (996:26): [True: 0, False: 1.16k]
  ------------------
  997|       |    /*
  998|       |     * We are supposed to handle UTF8, check it's valid
  999|       |     * From rfc2044: encoding of the Unicode values on UTF-8:
 1000|       |     *
 1001|       |     * UCS-4 range (hex.)           UTF-8 octet sequence (binary)
 1002|       |     * 0000 0000-0000 007F   0xxxxxxx
 1003|       |     * 0000 0080-0000 07FF   110xxxxx 10xxxxxx
 1004|       |     * 0000 0800-0000 FFFF   1110xxxx 10xxxxxx 10xxxxxx
 1005|       |     */
 1006|  1.16k|    if  (val >= 0x80) {
  ------------------
  |  Branch (1006:10): [True: 1.16k, False: 0]
  ------------------
 1007|  1.16k|	xmlChar *savedout = out;
 1008|  1.16k|	int bits;
 1009|  1.16k|	if (val <   0x800) { *out++= (val >>  6) | 0xC0;  bits=  0; }
  ------------------
  |  Branch (1009:6): [True: 428, False: 732]
  ------------------
 1010|    732|	else if (val < 0x10000) { *out++= (val >> 12) | 0xE0;  bits=  6;}
  ------------------
  |  Branch (1010:11): [True: 732, False: 0]
  ------------------
 1011|      0|	else if (val < 0x110000)  { *out++= (val >> 18) | 0xF0;  bits=  12; }
  ------------------
  |  Branch (1011:11): [True: 0, False: 0]
  ------------------
 1012|      0|	else {
 1013|      0|	    xmlErrEncodingInt(NULL, XML_ERR_INVALID_CHAR,
 1014|      0|		    "Internal error, xmlCopyCharMultiByte 0x%X out of bound\n",
 1015|      0|			      val);
 1016|      0|	    return(0);
 1017|      0|	}
 1018|  3.05k|	for ( ; bits >= 0; bits-= 6)
  ------------------
  |  Branch (1018:10): [True: 1.89k, False: 1.16k]
  ------------------
 1019|  1.89k|	    *out++= ((val >> bits) & 0x3F) | 0x80 ;
 1020|  1.16k|	return (out - savedout);
 1021|  1.16k|    }
 1022|      0|    *out = val;
 1023|      0|    return 1;
 1024|  1.16k|}
xmlSwitchInputEncoding:
 1189|     28|{
 1190|     28|    int nbchars;
 1191|     28|    xmlParserInputBufferPtr in;
 1192|       |
 1193|     28|    if ((input == NULL) || (input->buf == NULL)) {
  ------------------
  |  Branch (1193:9): [True: 0, False: 28]
  |  Branch (1193:28): [True: 0, False: 28]
  ------------------
 1194|      0|        xmlCharEncCloseFunc(handler);
 1195|      0|	return (-1);
 1196|      0|    }
 1197|     28|    in = input->buf;
 1198|       |
 1199|     28|    input->flags |= XML_INPUT_HAS_ENCODING;
  ------------------
  |  |   20|     28|#define XML_INPUT_HAS_ENCODING      (1u << 0)
  ------------------
 1200|       |
 1201|       |    /*
 1202|       |     * UTF-8 requires no encoding handler.
 1203|       |     */
 1204|     28|    if ((handler != NULL) &&
  ------------------
  |  Branch (1204:9): [True: 28, False: 0]
  ------------------
 1205|     28|        (xmlStrcasecmp(BAD_CAST handler->name, BAD_CAST "UTF-8") == 0)) {
  ------------------
  |  |   35|     28|#define BAD_CAST (xmlChar *)
  ------------------
                      (xmlStrcasecmp(BAD_CAST handler->name, BAD_CAST "UTF-8") == 0)) {
  ------------------
  |  |   35|     28|#define BAD_CAST (xmlChar *)
  ------------------
  |  Branch (1205:9): [True: 14, False: 14]
  ------------------
 1206|     14|        xmlCharEncCloseFunc(handler);
 1207|     14|        handler = NULL;
 1208|     14|    }
 1209|       |
 1210|     28|    if (in->encoder == handler)
  ------------------
  |  Branch (1210:9): [True: 14, False: 14]
  ------------------
 1211|     14|        return (0);
 1212|       |
 1213|     14|    if (in->encoder != NULL) {
  ------------------
  |  Branch (1213:9): [True: 0, False: 14]
  ------------------
 1214|       |        /*
 1215|       |         * Switching encodings during parsing is a really bad idea,
 1216|       |         * but Chromium can switch between ISO-8859-1 and UTF-16 before
 1217|       |         * separate calls to xmlParseChunk.
 1218|       |         *
 1219|       |         * TODO: We should check whether the "raw" input buffer is empty and
 1220|       |         * convert the old content using the old encoder.
 1221|       |         */
 1222|       |
 1223|      0|        xmlCharEncCloseFunc(in->encoder);
 1224|      0|        in->encoder = handler;
 1225|      0|        return (0);
 1226|      0|    }
 1227|       |
 1228|     14|    in->encoder = handler;
 1229|       |
 1230|       |    /*
 1231|       |     * Is there already some content down the pipe to convert ?
 1232|       |     */
 1233|     14|    if (xmlBufIsEmpty(in->buffer) == 0) {
  ------------------
  |  Branch (1233:9): [True: 14, False: 0]
  ------------------
 1234|     14|        size_t processed;
 1235|       |
 1236|       |        /*
 1237|       |         * Shrink the current input buffer.
 1238|       |         * Move it as the raw buffer and create a new input buffer
 1239|       |         */
 1240|     14|        processed = input->cur - input->base;
 1241|     14|        xmlBufShrink(in->buffer, processed);
 1242|     14|        input->consumed += processed;
 1243|     14|        in->raw = in->buffer;
 1244|     14|        in->buffer = xmlBufCreate();
 1245|     14|        in->rawconsumed = processed;
 1246|       |
 1247|     14|        nbchars = xmlCharEncInput(in);
 1248|     14|        xmlBufResetInput(in->buffer, input);
 1249|     14|        if (nbchars < 0) {
  ------------------
  |  Branch (1249:13): [True: 0, False: 14]
  ------------------
 1250|       |            /* TODO: This could be an out of memory or an encoding error. */
 1251|      0|            xmlErrInternal(ctxt,
 1252|      0|                           "switching encoding: encoder error\n",
 1253|      0|                           NULL);
 1254|      0|            xmlHaltParser(ctxt);
 1255|      0|            return (-1);
 1256|      0|        }
 1257|     14|    }
 1258|     14|    return (0);
 1259|     14|}
xmlSwitchToEncoding:
 1275|     28|{
 1276|     28|    if (ctxt == NULL)
  ------------------
  |  Branch (1276:9): [True: 0, False: 28]
  ------------------
 1277|      0|        return(-1);
 1278|     28|    return(xmlSwitchInputEncoding(ctxt, ctxt->input, handler));
 1279|     28|}
xmlDetectEncoding:
 1290|    363|xmlDetectEncoding(xmlParserCtxtPtr ctxt) {
 1291|    363|    const xmlChar *in;
 1292|    363|    xmlCharEncoding enc;
 1293|    363|    int bomSize;
 1294|    363|    int autoFlag = 0;
 1295|       |
 1296|    363|    if (xmlParserGrow(ctxt) < 0)
  ------------------
  |  Branch (1296:9): [True: 0, False: 363]
  ------------------
 1297|      0|        return;
 1298|    363|    in = ctxt->input->cur;
 1299|    363|    if (ctxt->input->end - in < 4)
  ------------------
  |  Branch (1299:9): [True: 0, False: 363]
  ------------------
 1300|      0|        return;
 1301|       |
 1302|    363|    if (ctxt->input->flags & XML_INPUT_HAS_ENCODING) {
  ------------------
  |  |   20|    363|#define XML_INPUT_HAS_ENCODING      (1u << 0)
  ------------------
  |  Branch (1302:9): [True: 0, False: 363]
  ------------------
 1303|       |        /*
 1304|       |         * If the encoding was already set, only skip the BOM which was
 1305|       |         * possibly decoded to UTF-8.
 1306|       |         */
 1307|      0|        if ((in[0] == 0xEF) && (in[1] == 0xBB) && (in[2] == 0xBF)) {
  ------------------
  |  Branch (1307:13): [True: 0, False: 0]
  |  Branch (1307:32): [True: 0, False: 0]
  |  Branch (1307:51): [True: 0, False: 0]
  ------------------
 1308|      0|            ctxt->input->cur += 3;
 1309|      0|        }
 1310|       |
 1311|      0|        return;
 1312|      0|    }
 1313|       |
 1314|    363|    enc = XML_CHAR_ENCODING_NONE;
 1315|    363|    bomSize = 0;
 1316|       |
 1317|    363|    switch (in[0]) {
  ------------------
  |  Branch (1317:13): [True: 16, False: 347]
  ------------------
 1318|      0|        case 0x00:
  ------------------
  |  Branch (1318:9): [True: 0, False: 363]
  ------------------
 1319|      0|            if ((in[1] == 0x00) && (in[2] == 0x00) && (in[3] == 0x3C)) {
  ------------------
  |  Branch (1319:17): [True: 0, False: 0]
  |  Branch (1319:36): [True: 0, False: 0]
  |  Branch (1319:55): [True: 0, False: 0]
  ------------------
 1320|      0|                enc = XML_CHAR_ENCODING_UCS4BE;
 1321|      0|                autoFlag = XML_INPUT_AUTO_OTHER;
  ------------------
  |  |   25|      0|#define XML_INPUT_AUTO_OTHER        (4u << 1)
  ------------------
 1322|      0|            } else if ((in[1] == 0x3C) && (in[2] == 0x00) && (in[3] == 0x3F)) {
  ------------------
  |  Branch (1322:24): [True: 0, False: 0]
  |  Branch (1322:43): [True: 0, False: 0]
  |  Branch (1322:62): [True: 0, False: 0]
  ------------------
 1323|      0|                enc = XML_CHAR_ENCODING_UTF16BE;
 1324|      0|                autoFlag = XML_INPUT_AUTO_UTF16BE;
  ------------------
  |  |   24|      0|#define XML_INPUT_AUTO_UTF16BE      (3u << 1)
  ------------------
 1325|      0|            }
 1326|      0|            break;
 1327|       |
 1328|    347|        case 0x3C:
  ------------------
  |  Branch (1328:9): [True: 347, False: 16]
  ------------------
 1329|    347|            if (in[1] == 0x00) {
  ------------------
  |  Branch (1329:17): [True: 0, False: 347]
  ------------------
 1330|      0|                if ((in[2] == 0x00) && (in[3] == 0x00)) {
  ------------------
  |  Branch (1330:21): [True: 0, False: 0]
  |  Branch (1330:40): [True: 0, False: 0]
  ------------------
 1331|      0|                    enc = XML_CHAR_ENCODING_UCS4LE;
 1332|      0|                    autoFlag = XML_INPUT_AUTO_OTHER;
  ------------------
  |  |   25|      0|#define XML_INPUT_AUTO_OTHER        (4u << 1)
  ------------------
 1333|      0|                } else if ((in[2] == 0x3F) && (in[3] == 0x00)) {
  ------------------
  |  Branch (1333:28): [True: 0, False: 0]
  |  Branch (1333:47): [True: 0, False: 0]
  ------------------
 1334|      0|                    enc = XML_CHAR_ENCODING_UTF16LE;
 1335|      0|                    autoFlag = XML_INPUT_AUTO_UTF16LE;
  ------------------
  |  |   23|      0|#define XML_INPUT_AUTO_UTF16LE      (2u << 1)
  ------------------
 1336|      0|                }
 1337|      0|            }
 1338|    347|            break;
 1339|       |
 1340|      0|        case 0x4C:
  ------------------
  |  Branch (1340:9): [True: 0, False: 363]
  ------------------
 1341|      0|	    if ((in[1] == 0x6F) && (in[2] == 0xA7) && (in[3] == 0x94)) {
  ------------------
  |  Branch (1341:10): [True: 0, False: 0]
  |  Branch (1341:29): [True: 0, False: 0]
  |  Branch (1341:48): [True: 0, False: 0]
  ------------------
 1342|      0|	        enc = XML_CHAR_ENCODING_EBCDIC;
 1343|      0|                autoFlag = XML_INPUT_AUTO_OTHER;
  ------------------
  |  |   25|      0|#define XML_INPUT_AUTO_OTHER        (4u << 1)
  ------------------
 1344|      0|            }
 1345|      0|            break;
 1346|       |
 1347|      0|        case 0xEF:
  ------------------
  |  Branch (1347:9): [True: 0, False: 363]
  ------------------
 1348|      0|            if ((in[1] == 0xBB) && (in[2] == 0xBF)) {
  ------------------
  |  Branch (1348:17): [True: 0, False: 0]
  |  Branch (1348:36): [True: 0, False: 0]
  ------------------
 1349|      0|                enc = XML_CHAR_ENCODING_UTF8;
 1350|      0|                autoFlag = XML_INPUT_AUTO_UTF8;
  ------------------
  |  |   22|      0|#define XML_INPUT_AUTO_UTF8         (1u << 1)
  ------------------
 1351|      0|                bomSize = 3;
 1352|      0|            }
 1353|      0|            break;
 1354|       |
 1355|      0|        case 0xFE:
  ------------------
  |  Branch (1355:9): [True: 0, False: 363]
  ------------------
 1356|      0|            if (in[1] == 0xFF) {
  ------------------
  |  Branch (1356:17): [True: 0, False: 0]
  ------------------
 1357|      0|                enc = XML_CHAR_ENCODING_UTF16BE;
 1358|      0|                autoFlag = XML_INPUT_AUTO_UTF16BE;
  ------------------
  |  |   24|      0|#define XML_INPUT_AUTO_UTF16BE      (3u << 1)
  ------------------
 1359|      0|                bomSize = 2;
 1360|      0|            }
 1361|      0|            break;
 1362|       |
 1363|      0|        case 0xFF:
  ------------------
  |  Branch (1363:9): [True: 0, False: 363]
  ------------------
 1364|      0|            if (in[1] == 0xFE) {
  ------------------
  |  Branch (1364:17): [True: 0, False: 0]
  ------------------
 1365|      0|                enc = XML_CHAR_ENCODING_UTF16LE;
 1366|      0|                autoFlag = XML_INPUT_AUTO_UTF16LE;
  ------------------
  |  |   23|      0|#define XML_INPUT_AUTO_UTF16LE      (2u << 1)
  ------------------
 1367|      0|                bomSize = 2;
 1368|      0|            }
 1369|      0|            break;
 1370|    363|    }
 1371|       |
 1372|    363|    if (bomSize > 0) {
  ------------------
  |  Branch (1372:9): [True: 0, False: 363]
  ------------------
 1373|      0|        ctxt->input->cur += bomSize;
 1374|      0|    }
 1375|       |
 1376|    363|    if (enc != XML_CHAR_ENCODING_NONE) {
  ------------------
  |  Branch (1376:9): [True: 0, False: 363]
  ------------------
 1377|      0|        ctxt->input->flags |= autoFlag;
 1378|      0|        xmlSwitchEncoding(ctxt, enc);
 1379|      0|    }
 1380|    363|}
xmlSetDeclaredEncoding:
 1395|     28|xmlSetDeclaredEncoding(xmlParserCtxtPtr ctxt, xmlChar *encoding) {
 1396|     28|    if (ctxt->encoding != NULL)
  ------------------
  |  Branch (1396:9): [True: 0, False: 28]
  ------------------
 1397|      0|        xmlFree((xmlChar *) ctxt->encoding);
 1398|     28|    ctxt->encoding = encoding;
 1399|       |
 1400|     28|    if (((ctxt->input->flags & XML_INPUT_HAS_ENCODING) == 0) &&
  ------------------
  |  |   20|     28|#define XML_INPUT_HAS_ENCODING      (1u << 0)
  ------------------
  |  Branch (1400:9): [True: 28, False: 0]
  ------------------
 1401|     28|        ((ctxt->options & XML_PARSE_IGNORE_ENC) == 0)) {
  ------------------
  |  Branch (1401:9): [True: 28, False: 0]
  ------------------
 1402|     28|        xmlCharEncodingHandlerPtr handler;
 1403|       |
 1404|     28|        handler = xmlFindCharEncodingHandler((const char *) encoding);
 1405|     28|        if (handler == NULL) {
  ------------------
  |  Branch (1405:13): [True: 0, False: 28]
  ------------------
 1406|      0|            __xmlErrEncoding(ctxt, XML_ERR_UNSUPPORTED_ENCODING,
 1407|      0|                             "Unsupported encoding: %s\n",
 1408|      0|                             encoding, NULL);
 1409|      0|            return;
 1410|      0|        }
 1411|       |
 1412|     28|        xmlSwitchToEncoding(ctxt, handler);
 1413|     28|        ctxt->input->flags |= XML_INPUT_USES_ENC_DECL;
  ------------------
  |  |   26|     28|#define XML_INPUT_USES_ENC_DECL     (1u << 4)
  ------------------
 1414|     28|    } else if (ctxt->input->flags & XML_INPUT_AUTO_ENCODING) {
  ------------------
  |  |   21|      0|#define XML_INPUT_AUTO_ENCODING     (7u << 1)
  ------------------
  |  Branch (1414:16): [True: 0, False: 0]
  ------------------
 1415|      0|        static const char *allowedUTF8[] = {
 1416|      0|            "UTF-8", "UTF8", NULL
 1417|      0|        };
 1418|      0|        static const char *allowedUTF16LE[] = {
 1419|      0|            "UTF-16", "UTF-16LE", "UTF16", NULL
 1420|      0|        };
 1421|      0|        static const char *allowedUTF16BE[] = {
 1422|      0|            "UTF-16", "UTF-16BE", "UTF16", NULL
 1423|      0|        };
 1424|      0|        const char **allowed = NULL;
 1425|      0|        const char *autoEnc = NULL;
 1426|       |
 1427|      0|        switch (ctxt->input->flags & XML_INPUT_AUTO_ENCODING) {
  ------------------
  |  |   21|      0|#define XML_INPUT_AUTO_ENCODING     (7u << 1)
  ------------------
  |  Branch (1427:17): [True: 0, False: 0]
  ------------------
 1428|      0|            case XML_INPUT_AUTO_UTF8:
  ------------------
  |  |   22|      0|#define XML_INPUT_AUTO_UTF8         (1u << 1)
  ------------------
  |  Branch (1428:13): [True: 0, False: 0]
  ------------------
 1429|      0|                allowed = allowedUTF8;
 1430|      0|                autoEnc = "UTF-8";
 1431|      0|                break;
 1432|      0|            case XML_INPUT_AUTO_UTF16LE:
  ------------------
  |  |   23|      0|#define XML_INPUT_AUTO_UTF16LE      (2u << 1)
  ------------------
  |  Branch (1432:13): [True: 0, False: 0]
  ------------------
 1433|      0|                allowed = allowedUTF16LE;
 1434|      0|                autoEnc = "UTF-16LE";
 1435|      0|                break;
 1436|      0|            case XML_INPUT_AUTO_UTF16BE:
  ------------------
  |  |   24|      0|#define XML_INPUT_AUTO_UTF16BE      (3u << 1)
  ------------------
  |  Branch (1436:13): [True: 0, False: 0]
  ------------------
 1437|      0|                allowed = allowedUTF16BE;
 1438|      0|                autoEnc = "UTF-16BE";
 1439|      0|                break;
 1440|      0|        }
 1441|       |
 1442|      0|        if (allowed != NULL) {
  ------------------
  |  Branch (1442:13): [True: 0, False: 0]
  ------------------
 1443|      0|            const char **p;
 1444|      0|            int match = 0;
 1445|       |
 1446|      0|            for (p = allowed; *p != NULL; p++) {
  ------------------
  |  Branch (1446:31): [True: 0, False: 0]
  ------------------
 1447|      0|                if (xmlStrcasecmp(encoding, BAD_CAST *p) == 0) {
  ------------------
  |  |   35|      0|#define BAD_CAST (xmlChar *)
  ------------------
  |  Branch (1447:21): [True: 0, False: 0]
  ------------------
 1448|      0|                    match = 1;
 1449|      0|                    break;
 1450|      0|                }
 1451|      0|            }
 1452|       |
 1453|      0|            if (match == 0) {
  ------------------
  |  Branch (1453:17): [True: 0, False: 0]
  ------------------
 1454|      0|                xmlWarningMsg(ctxt, XML_WAR_ENCODING_MISMATCH,
 1455|      0|                              "Encoding '%s' doesn't match "
 1456|      0|                              "auto-detected '%s'\n",
 1457|      0|                              encoding, BAD_CAST autoEnc);
  ------------------
  |  |   35|      0|#define BAD_CAST (xmlChar *)
  ------------------
 1458|      0|            }
 1459|      0|        }
 1460|      0|    }
 1461|     28|}
xmlFreeInputStream:
 1476|    373|xmlFreeInputStream(xmlParserInputPtr input) {
 1477|    373|    if (input == NULL) return;
  ------------------
  |  Branch (1477:9): [True: 0, False: 373]
  ------------------
 1478|       |
 1479|    373|    if (input->filename != NULL) xmlFree((char *) input->filename);
  ------------------
  |  Branch (1479:9): [True: 206, False: 167]
  ------------------
 1480|    373|    if (input->directory != NULL) xmlFree((char *) input->directory);
  ------------------
  |  Branch (1480:9): [True: 0, False: 373]
  ------------------
 1481|    373|    if (input->version != NULL) xmlFree((char *) input->version);
  ------------------
  |  Branch (1481:9): [True: 0, False: 373]
  ------------------
 1482|    373|    if ((input->free != NULL) && (input->base != NULL))
  ------------------
  |  Branch (1482:9): [True: 0, False: 373]
  |  Branch (1482:34): [True: 0, False: 0]
  ------------------
 1483|      0|        input->free((xmlChar *) input->base);
 1484|    373|    if (input->buf != NULL)
  ------------------
  |  Branch (1484:9): [True: 206, False: 167]
  ------------------
 1485|    206|        xmlFreeParserInputBuffer(input->buf);
 1486|    373|    xmlFree(input);
 1487|    373|}
xmlNewInputStream:
 1498|    373|xmlNewInputStream(xmlParserCtxtPtr ctxt) {
 1499|    373|    xmlParserInputPtr input;
 1500|       |
 1501|    373|    input = (xmlParserInputPtr) xmlMalloc(sizeof(xmlParserInput));
 1502|    373|    if (input == NULL) {
  ------------------
  |  Branch (1502:9): [True: 0, False: 373]
  ------------------
 1503|      0|        xmlErrMemory(ctxt,  "couldn't allocate a new input stream\n");
 1504|      0|	return(NULL);
 1505|      0|    }
 1506|    373|    memset(input, 0, sizeof(xmlParserInput));
 1507|    373|    input->line = 1;
 1508|    373|    input->col = 1;
 1509|       |
 1510|       |    /*
 1511|       |     * If the context is NULL the id cannot be initialized, but that
 1512|       |     * should not happen while parsing which is the situation where
 1513|       |     * the id is actually needed.
 1514|       |     */
 1515|    373|    if (ctxt != NULL) {
  ------------------
  |  Branch (1515:9): [True: 373, False: 0]
  ------------------
 1516|    373|        if (input->id >= INT_MAX) {
  ------------------
  |  Branch (1516:13): [True: 0, False: 373]
  ------------------
 1517|      0|            xmlErrMemory(ctxt, "Input ID overflow\n");
 1518|      0|            return(NULL);
 1519|      0|        }
 1520|    373|        input->id = ctxt->input_id++;
 1521|    373|    }
 1522|       |
 1523|    373|    return(input);
 1524|    373|}
xmlFreeParserCtxt:
 1967|    454|{
 1968|    454|    xmlParserInputPtr input;
 1969|       |
 1970|    454|    if (ctxt == NULL) return;
  ------------------
  |  Branch (1970:9): [True: 0, False: 454]
  ------------------
 1971|       |
 1972|    817|    while ((input = inputPop(ctxt)) != NULL) { /* Non consuming */
  ------------------
  |  Branch (1972:12): [True: 363, False: 454]
  ------------------
 1973|    363|        xmlFreeInputStream(input);
 1974|    363|    }
 1975|    454|    if (ctxt->spaceTab != NULL) xmlFree(ctxt->spaceTab);
  ------------------
  |  Branch (1975:9): [True: 454, False: 0]
  ------------------
 1976|    454|    if (ctxt->nameTab != NULL) xmlFree((xmlChar * *)ctxt->nameTab);
  ------------------
  |  Branch (1976:9): [True: 454, False: 0]
  ------------------
 1977|    454|    if (ctxt->nodeTab != NULL) xmlFree(ctxt->nodeTab);
  ------------------
  |  Branch (1977:9): [True: 454, False: 0]
  ------------------
 1978|    454|    if (ctxt->nodeInfoTab != NULL) xmlFree(ctxt->nodeInfoTab);
  ------------------
  |  Branch (1978:9): [True: 0, False: 454]
  ------------------
 1979|    454|    if (ctxt->inputTab != NULL) xmlFree(ctxt->inputTab);
  ------------------
  |  Branch (1979:9): [True: 454, False: 0]
  ------------------
 1980|    454|    if (ctxt->version != NULL) xmlFree((char *) ctxt->version);
  ------------------
  |  Branch (1980:9): [True: 359, False: 95]
  ------------------
 1981|    454|    if (ctxt->encoding != NULL) xmlFree((char *) ctxt->encoding);
  ------------------
  |  Branch (1981:9): [True: 28, False: 426]
  ------------------
 1982|    454|    if (ctxt->extSubURI != NULL) xmlFree((char *) ctxt->extSubURI);
  ------------------
  |  Branch (1982:9): [True: 0, False: 454]
  ------------------
 1983|    454|    if (ctxt->extSubSystem != NULL) xmlFree((char *) ctxt->extSubSystem);
  ------------------
  |  Branch (1983:9): [True: 0, False: 454]
  ------------------
 1984|    454|#ifdef LIBXML_SAX1_ENABLED
 1985|    454|    if ((ctxt->sax != NULL) &&
  ------------------
  |  Branch (1985:9): [True: 454, False: 0]
  ------------------
 1986|    454|        (ctxt->sax != (xmlSAXHandlerPtr) &xmlDefaultSAXHandler))
  ------------------
  |  |  860|    454|  #define xmlDefaultSAXHandler XML_GLOBAL_MACRO(xmlDefaultSAXHandler)
  |  |  ------------------
  |  |  |  |  500|    454|  #define XML_GLOBAL_MACRO(name) (*__##name())
  |  |  ------------------
  ------------------
  |  Branch (1986:9): [True: 454, False: 0]
  ------------------
 1987|       |#else
 1988|       |    if (ctxt->sax != NULL)
 1989|       |#endif /* LIBXML_SAX1_ENABLED */
 1990|    454|        xmlFree(ctxt->sax);
 1991|    454|    if (ctxt->directory != NULL) xmlFree((char *) ctxt->directory);
  ------------------
  |  Branch (1991:9): [True: 29, False: 425]
  ------------------
 1992|    454|    if (ctxt->vctxt.nodeTab != NULL) xmlFree(ctxt->vctxt.nodeTab);
  ------------------
  |  Branch (1992:9): [True: 0, False: 454]
  ------------------
 1993|    454|    if (ctxt->atts != NULL) xmlFree((xmlChar * *)ctxt->atts);
  ------------------
  |  Branch (1993:9): [True: 209, False: 245]
  ------------------
 1994|    454|    if (ctxt->dict != NULL) xmlDictFree(ctxt->dict);
  ------------------
  |  Branch (1994:9): [True: 454, False: 0]
  ------------------
 1995|    454|    if (ctxt->nsTab != NULL) xmlFree(ctxt->nsTab);
  ------------------
  |  Branch (1995:9): [True: 289, False: 165]
  ------------------
 1996|    454|    if (ctxt->nsdb != NULL) xmlParserNsFree(ctxt->nsdb);
  ------------------
  |  Branch (1996:9): [True: 454, False: 0]
  ------------------
 1997|    454|    if (ctxt->attrHash != NULL) xmlFree(ctxt->attrHash);
  ------------------
  |  Branch (1997:9): [True: 23, False: 431]
  ------------------
 1998|    454|    if (ctxt->pushTab != NULL) xmlFree(ctxt->pushTab);
  ------------------
  |  Branch (1998:9): [True: 313, False: 141]
  ------------------
 1999|    454|    if (ctxt->attallocs != NULL) xmlFree(ctxt->attallocs);
  ------------------
  |  Branch (1999:9): [True: 207, False: 247]
  ------------------
 2000|    454|    if (ctxt->attsDefault != NULL)
  ------------------
  |  Branch (2000:9): [True: 0, False: 454]
  ------------------
 2001|      0|        xmlHashFree(ctxt->attsDefault, xmlHashDefaultDeallocator);
 2002|    454|    if (ctxt->attsSpecial != NULL)
  ------------------
  |  Branch (2002:9): [True: 8, False: 446]
  ------------------
 2003|      8|        xmlHashFree(ctxt->attsSpecial, NULL);
 2004|    454|    if (ctxt->freeElems != NULL) {
  ------------------
  |  Branch (2004:9): [True: 124, False: 330]
  ------------------
 2005|    124|        xmlNodePtr cur, next;
 2006|       |
 2007|    124|	cur = ctxt->freeElems;
 2008|    248|	while (cur != NULL) {
  ------------------
  |  Branch (2008:9): [True: 124, False: 124]
  ------------------
 2009|    124|	    next = cur->next;
 2010|    124|	    xmlFree(cur);
 2011|    124|	    cur = next;
 2012|    124|	}
 2013|    124|    }
 2014|    454|    if (ctxt->freeAttrs != NULL) {
  ------------------
  |  Branch (2014:9): [True: 69, False: 385]
  ------------------
 2015|     69|        xmlAttrPtr cur, next;
 2016|       |
 2017|     69|	cur = ctxt->freeAttrs;
 2018|    138|	while (cur != NULL) {
  ------------------
  |  Branch (2018:9): [True: 69, False: 69]
  ------------------
 2019|     69|	    next = cur->next;
 2020|     69|	    xmlFree(cur);
 2021|     69|	    cur = next;
 2022|     69|	}
 2023|     69|    }
 2024|       |    /*
 2025|       |     * cleanup the error strings
 2026|       |     */
 2027|    454|    if (ctxt->lastError.message != NULL)
  ------------------
  |  Branch (2027:9): [True: 265, False: 189]
  ------------------
 2028|    265|        xmlFree(ctxt->lastError.message);
 2029|    454|    if (ctxt->lastError.file != NULL)
  ------------------
  |  Branch (2029:9): [True: 138, False: 316]
  ------------------
 2030|    138|        xmlFree(ctxt->lastError.file);
 2031|    454|    if (ctxt->lastError.str1 != NULL)
  ------------------
  |  Branch (2031:9): [True: 173, False: 281]
  ------------------
 2032|    173|        xmlFree(ctxt->lastError.str1);
 2033|    454|    if (ctxt->lastError.str2 != NULL)
  ------------------
  |  Branch (2033:9): [True: 68, False: 386]
  ------------------
 2034|     68|        xmlFree(ctxt->lastError.str2);
 2035|    454|    if (ctxt->lastError.str3 != NULL)
  ------------------
  |  Branch (2035:9): [True: 0, False: 454]
  ------------------
 2036|      0|        xmlFree(ctxt->lastError.str3);
 2037|       |
 2038|    454|#ifdef LIBXML_CATALOG_ENABLED
 2039|    454|    if (ctxt->catalogs != NULL)
  ------------------
  |  Branch (2039:9): [True: 0, False: 454]
  ------------------
 2040|      0|	xmlCatalogFreeLocal(ctxt->catalogs);
 2041|    454|#endif
 2042|    454|    xmlFree(ctxt);
 2043|    454|}
xmlNewParserCtxt:
 2055|    287|{
 2056|    287|    return(xmlNewSAXParserCtxt(NULL, NULL));
 2057|    287|}
xmlNewSAXParserCtxt:
 2072|    454|{
 2073|    454|    xmlParserCtxtPtr ctxt;
 2074|       |
 2075|    454|    ctxt = (xmlParserCtxtPtr) xmlMalloc(sizeof(xmlParserCtxt));
 2076|    454|    if (ctxt == NULL) {
  ------------------
  |  Branch (2076:9): [True: 0, False: 454]
  ------------------
 2077|      0|	xmlErrMemory(NULL, "cannot allocate parser context\n");
 2078|      0|	return(NULL);
 2079|      0|    }
 2080|    454|    memset(ctxt, 0, sizeof(xmlParserCtxt));
 2081|    454|    if (xmlInitSAXParserCtxt(ctxt, sax, userData) < 0) {
  ------------------
  |  Branch (2081:9): [True: 0, False: 454]
  ------------------
 2082|      0|        xmlFreeParserCtxt(ctxt);
 2083|      0|	return(NULL);
 2084|      0|    }
 2085|    454|    return(ctxt);
 2086|    454|}
xmlInitNodeInfoSeq:
 2149|    454|{
 2150|    454|    if (seq == NULL)
  ------------------
  |  Branch (2150:9): [True: 0, False: 454]
  ------------------
 2151|      0|        return;
 2152|    454|    seq->length = 0;
 2153|    454|    seq->maximum = 0;
 2154|    454|    seq->buffer = NULL;
 2155|    454|}
parserInternals.c:xmlErrEncodingInt:
  414|    689|{
  415|    689|    if ((ctxt != NULL) && (ctxt->disableSAX != 0) &&
  ------------------
  |  Branch (415:9): [True: 689, False: 0]
  |  Branch (415:27): [True: 533, False: 156]
  ------------------
  416|    689|        (ctxt->instate == XML_PARSER_EOF))
  ------------------
  |  Branch (416:9): [True: 0, False: 533]
  ------------------
  417|      0|	return;
  418|    689|    if (ctxt != NULL)
  ------------------
  |  Branch (418:9): [True: 689, False: 0]
  ------------------
  419|    689|        ctxt->errNo = error;
  420|    689|    __xmlRaiseError(NULL, NULL, NULL,
  421|    689|                    ctxt, NULL, XML_FROM_PARSER, error, XML_ERR_FATAL,
  422|    689|                    NULL, 0, NULL, NULL, NULL, val, 0, msg, val);
  423|    689|    if (ctxt != NULL) {
  ------------------
  |  Branch (423:9): [True: 689, False: 0]
  ------------------
  424|    689|        ctxt->wellFormed = 0;
  425|    689|        if (ctxt->recovery == 0)
  ------------------
  |  Branch (425:13): [True: 559, False: 130]
  ------------------
  426|    559|            ctxt->disableSAX = 1;
  427|    689|    }
  428|    689|}
parserInternals.c:xmlInitSAXParserCtxt:
 1746|    454|{
 1747|    454|    xmlParserInputPtr input;
 1748|       |
 1749|    454|    if(ctxt==NULL) {
  ------------------
  |  Branch (1749:8): [True: 0, False: 454]
  ------------------
 1750|      0|        xmlErrInternal(NULL, "Got NULL parser context\n", NULL);
 1751|      0|        return(-1);
 1752|      0|    }
 1753|       |
 1754|    454|    xmlInitParser();
 1755|       |
 1756|    454|    if (ctxt->dict == NULL)
  ------------------
  |  Branch (1756:9): [True: 454, False: 0]
  ------------------
 1757|    454|	ctxt->dict = xmlDictCreate();
 1758|    454|    if (ctxt->dict == NULL) {
  ------------------
  |  Branch (1758:9): [True: 0, False: 454]
  ------------------
 1759|      0|        xmlErrMemory(NULL, "cannot initialize parser context\n");
 1760|      0|	return(-1);
 1761|      0|    }
 1762|    454|    xmlDictSetLimit(ctxt->dict, XML_MAX_DICTIONARY_LIMIT);
  ------------------
  |  |   71|    454|#define XML_MAX_DICTIONARY_LIMIT 10000000
  ------------------
 1763|       |
 1764|    454|    if (ctxt->sax == NULL)
  ------------------
  |  Branch (1764:9): [True: 454, False: 0]
  ------------------
 1765|    454|	ctxt->sax = (xmlSAXHandler *) xmlMalloc(sizeof(xmlSAXHandler));
 1766|    454|    if (ctxt->sax == NULL) {
  ------------------
  |  Branch (1766:9): [True: 0, False: 454]
  ------------------
 1767|      0|        xmlErrMemory(NULL, "cannot initialize parser context\n");
 1768|      0|	return(-1);
 1769|      0|    }
 1770|    454|    if (sax == NULL) {
  ------------------
  |  Branch (1770:9): [True: 287, False: 167]
  ------------------
 1771|    287|	memset(ctxt->sax, 0, sizeof(xmlSAXHandler));
 1772|    287|        xmlSAXVersion(ctxt->sax, 2);
 1773|    287|        ctxt->userData = ctxt;
 1774|    287|    } else {
 1775|    167|	if (sax->initialized == XML_SAX2_MAGIC) {
  ------------------
  |  |  685|    167|#define XML_SAX2_MAGIC 0xDEEDBEAF
  ------------------
  |  Branch (1775:6): [True: 167, False: 0]
  ------------------
 1776|    167|	    memcpy(ctxt->sax, sax, sizeof(xmlSAXHandler));
 1777|    167|        } else {
 1778|      0|	    memset(ctxt->sax, 0, sizeof(xmlSAXHandler));
 1779|      0|	    memcpy(ctxt->sax, sax, sizeof(xmlSAXHandlerV1));
 1780|      0|        }
 1781|    167|        ctxt->userData = userData ? userData : ctxt;
  ------------------
  |  Branch (1781:26): [True: 0, False: 167]
  ------------------
 1782|    167|    }
 1783|       |
 1784|    454|    ctxt->maxatts = 0;
 1785|    454|    ctxt->atts = NULL;
 1786|       |    /* Allocate the Input stack */
 1787|    454|    if (ctxt->inputTab == NULL) {
  ------------------
  |  Branch (1787:9): [True: 454, False: 0]
  ------------------
 1788|    454|	ctxt->inputTab = (xmlParserInputPtr *)
 1789|    454|		    xmlMalloc(5 * sizeof(xmlParserInputPtr));
 1790|    454|	ctxt->inputMax = 5;
 1791|    454|    }
 1792|    454|    if (ctxt->inputTab == NULL) {
  ------------------
  |  Branch (1792:9): [True: 0, False: 454]
  ------------------
 1793|      0|        xmlErrMemory(NULL, "cannot initialize parser context\n");
 1794|      0|	ctxt->inputNr = 0;
 1795|      0|	ctxt->inputMax = 0;
 1796|      0|	ctxt->input = NULL;
 1797|      0|	return(-1);
 1798|      0|    }
 1799|    454|    while ((input = inputPop(ctxt)) != NULL) { /* Non consuming */
  ------------------
  |  Branch (1799:12): [True: 0, False: 454]
  ------------------
 1800|      0|        xmlFreeInputStream(input);
 1801|      0|    }
 1802|    454|    ctxt->inputNr = 0;
 1803|    454|    ctxt->input = NULL;
 1804|       |
 1805|    454|    ctxt->version = NULL;
 1806|    454|    ctxt->encoding = NULL;
 1807|    454|    ctxt->standalone = -1;
 1808|    454|    ctxt->hasExternalSubset = 0;
 1809|    454|    ctxt->hasPErefs = 0;
 1810|    454|    ctxt->html = 0;
 1811|    454|    ctxt->external = 0;
 1812|    454|    ctxt->instate = XML_PARSER_START;
 1813|    454|    ctxt->token = 0;
 1814|    454|    ctxt->directory = NULL;
 1815|       |
 1816|       |    /* Allocate the Node stack */
 1817|    454|    if (ctxt->nodeTab == NULL) {
  ------------------
  |  Branch (1817:9): [True: 454, False: 0]
  ------------------
 1818|    454|	ctxt->nodeTab = (xmlNodePtr *) xmlMalloc(10 * sizeof(xmlNodePtr));
 1819|    454|	ctxt->nodeMax = 10;
 1820|    454|    }
 1821|    454|    if (ctxt->nodeTab == NULL) {
  ------------------
  |  Branch (1821:9): [True: 0, False: 454]
  ------------------
 1822|      0|        xmlErrMemory(NULL, "cannot initialize parser context\n");
 1823|      0|	ctxt->nodeNr = 0;
 1824|      0|	ctxt->nodeMax = 0;
 1825|      0|	ctxt->node = NULL;
 1826|      0|	ctxt->inputNr = 0;
 1827|      0|	ctxt->inputMax = 0;
 1828|      0|	ctxt->input = NULL;
 1829|      0|	return(-1);
 1830|      0|    }
 1831|    454|    ctxt->nodeNr = 0;
 1832|    454|    ctxt->node = NULL;
 1833|       |
 1834|       |    /* Allocate the Name stack */
 1835|    454|    if (ctxt->nameTab == NULL) {
  ------------------
  |  Branch (1835:9): [True: 454, False: 0]
  ------------------
 1836|    454|	ctxt->nameTab = (const xmlChar **) xmlMalloc(10 * sizeof(xmlChar *));
 1837|    454|	ctxt->nameMax = 10;
 1838|    454|    }
 1839|    454|    if (ctxt->nameTab == NULL) {
  ------------------
  |  Branch (1839:9): [True: 0, False: 454]
  ------------------
 1840|      0|        xmlErrMemory(NULL, "cannot initialize parser context\n");
 1841|      0|	ctxt->nodeNr = 0;
 1842|      0|	ctxt->nodeMax = 0;
 1843|      0|	ctxt->node = NULL;
 1844|      0|	ctxt->inputNr = 0;
 1845|      0|	ctxt->inputMax = 0;
 1846|      0|	ctxt->input = NULL;
 1847|      0|	ctxt->nameNr = 0;
 1848|      0|	ctxt->nameMax = 0;
 1849|      0|	ctxt->name = NULL;
 1850|      0|	return(-1);
 1851|      0|    }
 1852|    454|    ctxt->nameNr = 0;
 1853|    454|    ctxt->name = NULL;
 1854|       |
 1855|       |    /* Allocate the space stack */
 1856|    454|    if (ctxt->spaceTab == NULL) {
  ------------------
  |  Branch (1856:9): [True: 454, False: 0]
  ------------------
 1857|    454|	ctxt->spaceTab = (int *) xmlMalloc(10 * sizeof(int));
 1858|    454|	ctxt->spaceMax = 10;
 1859|    454|    }
 1860|    454|    if (ctxt->spaceTab == NULL) {
  ------------------
  |  Branch (1860:9): [True: 0, False: 454]
  ------------------
 1861|      0|        xmlErrMemory(NULL, "cannot initialize parser context\n");
 1862|      0|	ctxt->nodeNr = 0;
 1863|      0|	ctxt->nodeMax = 0;
 1864|      0|	ctxt->node = NULL;
 1865|      0|	ctxt->inputNr = 0;
 1866|      0|	ctxt->inputMax = 0;
 1867|      0|	ctxt->input = NULL;
 1868|      0|	ctxt->nameNr = 0;
 1869|      0|	ctxt->nameMax = 0;
 1870|      0|	ctxt->name = NULL;
 1871|      0|	ctxt->spaceNr = 0;
 1872|      0|	ctxt->spaceMax = 0;
 1873|      0|	ctxt->space = NULL;
 1874|      0|	return(-1);
 1875|      0|    }
 1876|    454|    ctxt->spaceNr = 1;
 1877|    454|    ctxt->spaceMax = 10;
 1878|    454|    ctxt->spaceTab[0] = -1;
 1879|    454|    ctxt->space = &ctxt->spaceTab[0];
 1880|    454|    ctxt->myDoc = NULL;
 1881|    454|    ctxt->wellFormed = 1;
 1882|    454|    ctxt->nsWellFormed = 1;
 1883|    454|    ctxt->valid = 1;
 1884|    454|    ctxt->loadsubset = xmlLoadExtDtdDefaultValue;
  ------------------
  |  |  869|    454|  #define xmlLoadExtDtdDefaultValue XML_GLOBAL_MACRO(xmlLoadExtDtdDefaultValue)
  |  |  ------------------
  |  |  |  |  500|    454|  #define XML_GLOBAL_MACRO(name) (*__##name())
  |  |  ------------------
  ------------------
 1885|    454|    if (ctxt->loadsubset) {
  ------------------
  |  Branch (1885:9): [True: 0, False: 454]
  ------------------
 1886|      0|        ctxt->options |= XML_PARSE_DTDLOAD;
 1887|      0|    }
 1888|    454|    ctxt->validate = xmlDoValidityCheckingDefaultValue;
  ------------------
  |  |  863|    454|    XML_GLOBAL_MACRO(xmlDoValidityCheckingDefaultValue)
  |  |  ------------------
  |  |  |  |  500|    454|  #define XML_GLOBAL_MACRO(name) (*__##name())
  |  |  ------------------
  ------------------
 1889|    454|    ctxt->pedantic = xmlPedanticParserDefaultValue;
  ------------------
  |  |  872|    454|    XML_GLOBAL_MACRO(xmlPedanticParserDefaultValue)
  |  |  ------------------
  |  |  |  |  500|    454|  #define XML_GLOBAL_MACRO(name) (*__##name())
  |  |  ------------------
  ------------------
 1890|    454|    if (ctxt->pedantic) {
  ------------------
  |  Branch (1890:9): [True: 0, False: 454]
  ------------------
 1891|      0|        ctxt->options |= XML_PARSE_PEDANTIC;
 1892|      0|    }
 1893|    454|    ctxt->linenumbers = xmlLineNumbersDefaultValue;
  ------------------
  |  |  868|    454|    XML_GLOBAL_MACRO(xmlLineNumbersDefaultValue)
  |  |  ------------------
  |  |  |  |  500|    454|  #define XML_GLOBAL_MACRO(name) (*__##name())
  |  |  ------------------
  ------------------
 1894|    454|    ctxt->keepBlanks = xmlKeepBlanksDefaultValue;
  ------------------
  |  |  866|    454|  #define xmlKeepBlanksDefaultValue XML_GLOBAL_MACRO(xmlKeepBlanksDefaultValue)
  |  |  ------------------
  |  |  |  |  500|    454|  #define XML_GLOBAL_MACRO(name) (*__##name())
  |  |  ------------------
  ------------------
 1895|    454|    if (ctxt->keepBlanks == 0) {
  ------------------
  |  Branch (1895:9): [True: 0, False: 454]
  ------------------
 1896|      0|	ctxt->sax->ignorableWhitespace = xmlSAX2IgnorableWhitespace;
 1897|      0|	ctxt->options |= XML_PARSE_NOBLANKS;
 1898|      0|    }
 1899|       |
 1900|    454|    ctxt->vctxt.flags = XML_VCTXT_USE_PCTXT;
  ------------------
  |  |   18|    454|#define XML_VCTXT_USE_PCTXT (1u << 1)
  ------------------
 1901|    454|    ctxt->vctxt.userData = ctxt;
 1902|    454|    ctxt->vctxt.error = xmlParserValidityError;
 1903|    454|    ctxt->vctxt.warning = xmlParserValidityWarning;
 1904|    454|    if (ctxt->validate) {
  ------------------
  |  Branch (1904:9): [True: 0, False: 454]
  ------------------
 1905|      0|	if (xmlGetWarningsDefaultValue == 0)
  ------------------
  |  |  865|      0|    XML_GLOBAL_MACRO(xmlGetWarningsDefaultValue)
  |  |  ------------------
  |  |  |  |  500|      0|  #define XML_GLOBAL_MACRO(name) (*__##name())
  |  |  ------------------
  ------------------
  |  Branch (1905:6): [True: 0, False: 0]
  ------------------
 1906|      0|	    ctxt->vctxt.warning = NULL;
 1907|      0|	else
 1908|      0|	    ctxt->vctxt.warning = xmlParserValidityWarning;
 1909|      0|	ctxt->vctxt.nodeMax = 0;
 1910|      0|        ctxt->options |= XML_PARSE_DTDVALID;
 1911|      0|    }
 1912|    454|    ctxt->replaceEntities = xmlSubstituteEntitiesDefaultValue;
  ------------------
  |  |  874|    454|    XML_GLOBAL_MACRO(xmlSubstituteEntitiesDefaultValue)
  |  |  ------------------
  |  |  |  |  500|    454|  #define XML_GLOBAL_MACRO(name) (*__##name())
  |  |  ------------------
  ------------------
 1913|    454|    if (ctxt->replaceEntities) {
  ------------------
  |  Branch (1913:9): [True: 0, False: 454]
  ------------------
 1914|      0|        ctxt->options |= XML_PARSE_NOENT;
 1915|      0|    }
 1916|    454|    ctxt->record_info = 0;
 1917|    454|    ctxt->checkIndex = 0;
 1918|    454|    ctxt->inSubset = 0;
 1919|    454|    ctxt->errNo = XML_ERR_OK;
 1920|    454|    ctxt->depth = 0;
 1921|    454|    ctxt->catalogs = NULL;
 1922|    454|    ctxt->sizeentities = 0;
 1923|    454|    ctxt->sizeentcopy = 0;
 1924|    454|    ctxt->input_id = 1;
 1925|    454|    ctxt->maxAmpl = XML_MAX_AMPLIFICATION_DEFAULT;
  ------------------
  |  |   52|    454|#define XML_MAX_AMPLIFICATION_DEFAULT 5
  ------------------
 1926|    454|    xmlInitNodeInfoSeq(&ctxt->node_seq);
 1927|       |
 1928|    454|    if (ctxt->nsdb == NULL) {
  ------------------
  |  Branch (1928:9): [True: 454, False: 0]
  ------------------
 1929|    454|        ctxt->nsdb = xmlParserNsCreate();
 1930|    454|        if (ctxt->nsdb == NULL) {
  ------------------
  |  Branch (1930:13): [True: 0, False: 454]
  ------------------
 1931|      0|            xmlErrMemory(ctxt, NULL);
 1932|      0|            return(-1);
 1933|      0|        }
 1934|    454|    }
 1935|       |
 1936|    454|    return(0);
 1937|    454|}

xmlFreePatternList:
  269|     80|xmlFreePatternList(xmlPatternPtr comp) {
  270|     80|    xmlPatternPtr cur;
  271|       |
  272|    160|    while (comp != NULL) {
  ------------------
  |  Branch (272:12): [True: 80, False: 80]
  ------------------
  273|     80|	cur = comp;
  274|     80|	comp = comp->next;
  275|     80|	cur->next = NULL;
  276|     80|	xmlFreePatternInternal(cur);
  277|     80|    }
  278|     80|}
xmlFreeStreamCtxt:
 1722|     80|xmlFreeStreamCtxt(xmlStreamCtxtPtr stream) {
 1723|     80|    xmlStreamCtxtPtr next;
 1724|       |
 1725|    160|    while (stream != NULL) {
  ------------------
  |  Branch (1725:12): [True: 80, False: 80]
  ------------------
 1726|     80|        next = stream->next;
 1727|     80|        if (stream->states != NULL)
  ------------------
  |  Branch (1727:13): [True: 80, False: 0]
  ------------------
 1728|     80|	    xmlFree(stream->states);
 1729|     80|        xmlFree(stream);
 1730|     80|	stream = next;
 1731|     80|    }
 1732|     80|}
xmlStreamPush:
 2132|  12.4k|              const xmlChar *name, const xmlChar *ns) {
 2133|  12.4k|    return (xmlStreamPushInternal(stream, name, ns, XML_ELEMENT_NODE));
 2134|  12.4k|}
xmlStreamPop:
 2195|  12.3k|xmlStreamPop(xmlStreamCtxtPtr stream) {
 2196|  12.3k|    int i, lev;
 2197|       |
 2198|  12.3k|    if (stream == NULL)
  ------------------
  |  Branch (2198:9): [True: 0, False: 12.3k]
  ------------------
 2199|      0|        return(-1);
 2200|  24.6k|    while (stream != NULL) {
  ------------------
  |  Branch (2200:12): [True: 12.3k, False: 12.3k]
  ------------------
 2201|       |	/*
 2202|       |	* Reset block-level.
 2203|       |	*/
 2204|  12.3k|	if (stream->blockLevel == stream->level)
  ------------------
  |  Branch (2204:6): [True: 4, False: 12.3k]
  ------------------
 2205|      4|	    stream->blockLevel = -1;
 2206|       |
 2207|       |	/*
 2208|       |	 *  stream->level can be zero when XML_FINAL_IS_ANY_NODE is set
 2209|       |	 *  (see the thread at
 2210|       |	 *  http://mail.gnome.org/archives/xslt/2008-July/msg00027.html)
 2211|       |	 */
 2212|  12.3k|	if (stream->level)
  ------------------
  |  Branch (2212:6): [True: 12.3k, False: 0]
  ------------------
 2213|  12.3k|	    stream->level--;
 2214|       |	/*
 2215|       |	 * Check evolution of existing states
 2216|       |	 */
 2217|  12.3k|	for (i = stream->nbState -1; i >= 0; i--) {
  ------------------
  |  Branch (2217:31): [True: 4, False: 12.3k]
  ------------------
 2218|       |	    /* discard obsoleted states */
 2219|      4|	    lev = stream->states[(2 * i) + 1];
 2220|      4|	    if (lev > stream->level)
  ------------------
  |  Branch (2220:10): [True: 0, False: 4]
  ------------------
 2221|      0|		stream->nbState--;
 2222|      4|	    if (lev <= stream->level)
  ------------------
  |  Branch (2222:10): [True: 4, False: 0]
  ------------------
 2223|      4|		break;
 2224|      4|	}
 2225|  12.3k|	stream = stream->next;
 2226|  12.3k|    }
 2227|  12.3k|    return(0);
 2228|  12.3k|}
xmlStreamWantsAnyNode:
 2244|     80|{
 2245|     80|    if (streamCtxt == NULL)
  ------------------
  |  Branch (2245:9): [True: 0, False: 80]
  ------------------
 2246|      0|	return(-1);
 2247|    160|    while (streamCtxt != NULL) {
  ------------------
  |  Branch (2247:12): [True: 80, False: 80]
  ------------------
 2248|     80|	if (streamCtxt->comp->flags & XML_STREAM_FINAL_IS_ANY_NODE)
  ------------------
  |  |   58|     80|#define XML_STREAM_FINAL_IS_ANY_NODE 1<<14
  ------------------
  |  Branch (2248:6): [True: 0, False: 80]
  ------------------
 2249|      0|	    return(1);
 2250|     80|	streamCtxt = streamCtxt->next;
 2251|     80|    }
 2252|     80|    return(0);
 2253|     80|}
xmlPatterncompile:
 2274|     80|                  const xmlChar **namespaces) {
 2275|     80|    xmlPatternPtr ret = NULL, cur;
 2276|     80|    xmlPatParserContextPtr ctxt = NULL;
 2277|     80|    const xmlChar *or, *start;
 2278|     80|    xmlChar *tmp = NULL;
 2279|     80|    int type = 0;
 2280|     80|    int streamable = 1;
 2281|       |
 2282|     80|    if (pattern == NULL)
  ------------------
  |  Branch (2282:9): [True: 0, False: 80]
  ------------------
 2283|      0|        return(NULL);
 2284|       |
 2285|     80|    start = pattern;
 2286|     80|    or = start;
 2287|    160|    while (*or != 0) {
  ------------------
  |  Branch (2287:12): [True: 80, False: 80]
  ------------------
 2288|     80|	tmp = NULL;
 2289|    440|	while ((*or != 0) && (*or != '|')) or++;
  ------------------
  |  Branch (2289:9): [True: 360, False: 80]
  |  Branch (2289:23): [True: 360, False: 0]
  ------------------
 2290|     80|        if (*or == 0)
  ------------------
  |  Branch (2290:13): [True: 80, False: 0]
  ------------------
 2291|     80|	    ctxt = xmlNewPatParserContext(start, dict, namespaces);
 2292|      0|	else {
 2293|      0|	    tmp = xmlStrndup(start, or - start);
 2294|      0|	    if (tmp != NULL) {
  ------------------
  |  Branch (2294:10): [True: 0, False: 0]
  ------------------
 2295|      0|		ctxt = xmlNewPatParserContext(tmp, dict, namespaces);
 2296|      0|	    }
 2297|      0|	    or++;
 2298|      0|	}
 2299|     80|	if (ctxt == NULL) goto error;
  ------------------
  |  Branch (2299:6): [True: 0, False: 80]
  ------------------
 2300|     80|	cur = xmlNewPattern();
 2301|     80|	if (cur == NULL) goto error;
  ------------------
  |  Branch (2301:6): [True: 0, False: 80]
  ------------------
 2302|       |	/*
 2303|       |	* Assign string dict.
 2304|       |	*/
 2305|     80|	if (dict) {
  ------------------
  |  Branch (2305:6): [True: 0, False: 80]
  ------------------
 2306|      0|	    cur->dict = dict;
 2307|      0|	    xmlDictReference(dict);
 2308|      0|	}
 2309|     80|	if (ret == NULL)
  ------------------
  |  Branch (2309:6): [True: 80, False: 0]
  ------------------
 2310|     80|	    ret = cur;
 2311|      0|	else {
 2312|      0|	    cur->next = ret->next;
 2313|      0|	    ret->next = cur;
 2314|      0|	}
 2315|     80|	cur->flags = flags;
 2316|     80|	ctxt->comp = cur;
 2317|       |
 2318|     80|	if (XML_STREAM_XS_IDC(cur))
  ------------------
  |  |   72|     80|#define XML_STREAM_XS_IDC(c) ((c)->flags & \
  |  |  ------------------
  |  |  |  Branch (72:30): [True: 0, False: 80]
  |  |  ------------------
  |  |   73|     80|    (XML_PATTERN_XSSEL | XML_PATTERN_XSFIELD))
  ------------------
 2319|      0|	    xmlCompileIDCXPathPath(ctxt);
 2320|     80|	else
 2321|     80|	    xmlCompilePathPattern(ctxt);
 2322|     80|	if (ctxt->error != 0)
  ------------------
  |  Branch (2322:6): [True: 0, False: 80]
  ------------------
 2323|      0|	    goto error;
 2324|     80|	xmlFreePatParserContext(ctxt);
 2325|     80|	ctxt = NULL;
 2326|       |
 2327|       |
 2328|     80|        if (streamable) {
  ------------------
  |  Branch (2328:13): [True: 80, False: 0]
  ------------------
 2329|     80|	    if (type == 0) {
  ------------------
  |  Branch (2329:10): [True: 80, False: 0]
  ------------------
 2330|     80|	        type = cur->flags & (PAT_FROM_ROOT | PAT_FROM_CUR);
  ------------------
  |  |  158|     80|#define PAT_FROM_ROOT	(1<<8)
  ------------------
              	        type = cur->flags & (PAT_FROM_ROOT | PAT_FROM_CUR);
  ------------------
  |  |  159|     80|#define PAT_FROM_CUR	(1<<9)
  ------------------
 2331|     80|	    } else if (type == PAT_FROM_ROOT) {
  ------------------
  |  |  158|      0|#define PAT_FROM_ROOT	(1<<8)
  ------------------
  |  Branch (2331:17): [True: 0, False: 0]
  ------------------
 2332|      0|	        if (cur->flags & PAT_FROM_CUR)
  ------------------
  |  |  159|      0|#define PAT_FROM_CUR	(1<<9)
  ------------------
  |  Branch (2332:14): [True: 0, False: 0]
  ------------------
 2333|      0|		    streamable = 0;
 2334|      0|	    } else if (type == PAT_FROM_CUR) {
  ------------------
  |  |  159|      0|#define PAT_FROM_CUR	(1<<9)
  ------------------
  |  Branch (2334:17): [True: 0, False: 0]
  ------------------
 2335|      0|	        if (cur->flags & PAT_FROM_ROOT)
  ------------------
  |  |  158|      0|#define PAT_FROM_ROOT	(1<<8)
  ------------------
  |  Branch (2335:14): [True: 0, False: 0]
  ------------------
 2336|      0|		    streamable = 0;
 2337|      0|	    }
 2338|     80|	}
 2339|     80|	if (streamable)
  ------------------
  |  Branch (2339:6): [True: 80, False: 0]
  ------------------
 2340|     80|	    xmlStreamCompile(cur);
 2341|     80|	if (xmlReversePattern(cur) < 0)
  ------------------
  |  Branch (2341:6): [True: 0, False: 80]
  ------------------
 2342|      0|	    goto error;
 2343|     80|	if (tmp != NULL) {
  ------------------
  |  Branch (2343:6): [True: 0, False: 80]
  ------------------
 2344|      0|	    xmlFree(tmp);
 2345|      0|	    tmp = NULL;
 2346|      0|	}
 2347|     80|	start = or;
 2348|     80|    }
 2349|     80|    if (streamable == 0) {
  ------------------
  |  Branch (2349:9): [True: 0, False: 80]
  ------------------
 2350|      0|        cur = ret;
 2351|      0|	while (cur != NULL) {
  ------------------
  |  Branch (2351:9): [True: 0, False: 0]
  ------------------
 2352|      0|	    if (cur->stream != NULL) {
  ------------------
  |  Branch (2352:10): [True: 0, False: 0]
  ------------------
 2353|      0|		xmlFreeStreamComp(cur->stream);
 2354|      0|		cur->stream = NULL;
 2355|      0|	    }
 2356|      0|	    cur = cur->next;
 2357|      0|	}
 2358|      0|    }
 2359|       |
 2360|     80|    return(ret);
 2361|      0|error:
 2362|      0|    if (ctxt != NULL) xmlFreePatParserContext(ctxt);
  ------------------
  |  Branch (2362:9): [True: 0, False: 0]
  ------------------
 2363|      0|    if (ret != NULL) xmlFreePattern(ret);
  ------------------
  |  Branch (2363:9): [True: 0, False: 0]
  ------------------
 2364|      0|    if (tmp != NULL) xmlFree(tmp);
  ------------------
  |  Branch (2364:9): [True: 0, False: 0]
  ------------------
 2365|      0|    return(NULL);
 2366|     80|}
xmlPatternGetStreamCtxt:
 2405|     80|{
 2406|     80|    xmlStreamCtxtPtr ret = NULL, cur;
 2407|       |
 2408|     80|    if ((comp == NULL) || (comp->stream == NULL))
  ------------------
  |  Branch (2408:9): [True: 0, False: 80]
  |  Branch (2408:27): [True: 0, False: 80]
  ------------------
 2409|      0|        return(NULL);
 2410|       |
 2411|    160|    while (comp != NULL) {
  ------------------
  |  Branch (2411:12): [True: 80, False: 80]
  ------------------
 2412|     80|        if (comp->stream == NULL)
  ------------------
  |  Branch (2412:13): [True: 0, False: 80]
  ------------------
 2413|      0|	    goto failed;
 2414|     80|	cur = xmlNewStreamCtxt(comp->stream);
 2415|     80|	if (cur == NULL)
  ------------------
  |  Branch (2415:6): [True: 0, False: 80]
  ------------------
 2416|      0|	    goto failed;
 2417|     80|	if (ret == NULL)
  ------------------
  |  Branch (2417:6): [True: 80, False: 0]
  ------------------
 2418|     80|	    ret = cur;
 2419|      0|	else {
 2420|      0|	    cur->next = ret->next;
 2421|      0|	    ret->next = cur;
 2422|      0|	}
 2423|     80|	cur->flags = comp->flags;
 2424|     80|	comp = comp->next;
 2425|     80|    }
 2426|     80|    return(ret);
 2427|      0|failed:
 2428|      0|    xmlFreeStreamCtxt(ret);
 2429|      0|    return(NULL);
 2430|     80|}
xmlPatternStreamable:
 2442|     80|xmlPatternStreamable(xmlPatternPtr comp) {
 2443|     80|    if (comp == NULL)
  ------------------
  |  Branch (2443:9): [True: 0, False: 80]
  ------------------
 2444|      0|        return(-1);
 2445|    160|    while (comp != NULL) {
  ------------------
  |  Branch (2445:12): [True: 80, False: 80]
  ------------------
 2446|     80|        if (comp->stream == NULL)
  ------------------
  |  Branch (2446:13): [True: 0, False: 80]
  ------------------
 2447|      0|	    return(0);
 2448|     80|	comp = comp->next;
 2449|     80|    }
 2450|     80|    return(1);
 2451|     80|}
xmlPatternMaxDepth:
 2463|     80|xmlPatternMaxDepth(xmlPatternPtr comp) {
 2464|     80|    int ret = 0, i;
 2465|     80|    if (comp == NULL)
  ------------------
  |  Branch (2465:9): [True: 0, False: 80]
  ------------------
 2466|      0|        return(-1);
 2467|     84|    while (comp != NULL) {
  ------------------
  |  Branch (2467:12): [True: 80, False: 4]
  ------------------
 2468|     80|        if (comp->stream == NULL)
  ------------------
  |  Branch (2468:13): [True: 0, False: 80]
  ------------------
 2469|      0|	    return(-1);
 2470|     84|	for (i = 0;i < comp->stream->nbStep;i++)
  ------------------
  |  Branch (2470:13): [True: 80, False: 4]
  ------------------
 2471|     80|	    if (comp->stream->steps[i].flags & XML_STREAM_STEP_DESC)
  ------------------
  |  |   45|     80|#define XML_STREAM_STEP_DESC	1
  ------------------
  |  Branch (2471:10): [True: 76, False: 4]
  ------------------
 2472|     76|	        return(-2);
 2473|      4|	if (comp->stream->nbStep > ret)
  ------------------
  |  Branch (2473:6): [True: 4, False: 0]
  ------------------
 2474|      4|	    ret = comp->stream->nbStep;
 2475|      4|	comp = comp->next;
 2476|      4|    }
 2477|      4|    return(ret);
 2478|     80|}
xmlPatternMinDepth:
 2491|     80|xmlPatternMinDepth(xmlPatternPtr comp) {
 2492|     80|    int ret = 12345678;
 2493|     80|    if (comp == NULL)
  ------------------
  |  Branch (2493:9): [True: 0, False: 80]
  ------------------
 2494|      0|        return(-1);
 2495|    160|    while (comp != NULL) {
  ------------------
  |  Branch (2495:12): [True: 80, False: 80]
  ------------------
 2496|     80|        if (comp->stream == NULL)
  ------------------
  |  Branch (2496:13): [True: 0, False: 80]
  ------------------
 2497|      0|	    return(-1);
 2498|     80|	if (comp->stream->nbStep < ret)
  ------------------
  |  Branch (2498:6): [True: 80, False: 0]
  ------------------
 2499|     80|	    ret = comp->stream->nbStep;
 2500|     80|	if (ret == 0)
  ------------------
  |  Branch (2500:6): [True: 0, False: 80]
  ------------------
 2501|      0|	    return(0);
 2502|     80|	comp = comp->next;
 2503|     80|    }
 2504|     80|    return(ret);
 2505|     80|}
xmlPatternFromRoot:
 2516|     80|xmlPatternFromRoot(xmlPatternPtr comp) {
 2517|     80|    if (comp == NULL)
  ------------------
  |  Branch (2517:9): [True: 0, False: 80]
  ------------------
 2518|      0|        return(-1);
 2519|     80|    while (comp != NULL) {
  ------------------
  |  Branch (2519:12): [True: 80, False: 0]
  ------------------
 2520|     80|        if (comp->stream == NULL)
  ------------------
  |  Branch (2520:13): [True: 0, False: 80]
  ------------------
 2521|      0|	    return(-1);
 2522|     80|	if (comp->flags & PAT_FROM_ROOT)
  ------------------
  |  |  158|     80|#define PAT_FROM_ROOT	(1<<8)
  ------------------
  |  Branch (2522:6): [True: 80, False: 0]
  ------------------
 2523|     80|	    return(1);
 2524|      0|	comp = comp->next;
 2525|      0|    }
 2526|      0|    return(0);
 2527|       |
 2528|     80|}
pattern.c:xmlFreePatternInternal:
  233|     80|xmlFreePatternInternal(xmlPatternPtr comp) {
  234|     80|    xmlStepOpPtr op;
  235|     80|    int i;
  236|       |
  237|     80|    if (comp == NULL)
  ------------------
  |  Branch (237:9): [True: 0, False: 80]
  ------------------
  238|      0|	return;
  239|     80|    if (comp->stream != NULL)
  ------------------
  |  Branch (239:9): [True: 80, False: 0]
  ------------------
  240|     80|        xmlFreeStreamComp(comp->stream);
  241|     80|    if (comp->pattern != NULL)
  ------------------
  |  Branch (241:9): [True: 0, False: 80]
  ------------------
  242|      0|	xmlFree((xmlChar *)comp->pattern);
  243|     80|    if (comp->steps != NULL) {
  ------------------
  |  Branch (243:9): [True: 80, False: 0]
  ------------------
  244|     80|        if (comp->dict == NULL) {
  ------------------
  |  Branch (244:13): [True: 80, False: 0]
  ------------------
  245|    244|	    for (i = 0;i < comp->nbStep;i++) {
  ------------------
  |  Branch (245:17): [True: 164, False: 80]
  ------------------
  246|    164|		op = &comp->steps[i];
  247|    164|		if (op->value != NULL)
  ------------------
  |  Branch (247:7): [True: 80, False: 84]
  ------------------
  248|     80|		    xmlFree((xmlChar *) op->value);
  249|    164|		if (op->value2 != NULL)
  ------------------
  |  Branch (249:7): [True: 0, False: 164]
  ------------------
  250|      0|		    xmlFree((xmlChar *) op->value2);
  251|    164|	    }
  252|     80|	}
  253|     80|	xmlFree(comp->steps);
  254|     80|    }
  255|     80|    if (comp->dict != NULL)
  ------------------
  |  Branch (255:9): [True: 0, False: 80]
  ------------------
  256|      0|        xmlDictFree(comp->dict);
  257|       |
  258|     80|    memset(comp, -1, sizeof(xmlPattern));
  259|     80|    xmlFree(comp);
  260|     80|}
pattern.c:xmlStreamPushInternal:
 1790|  12.4k|		      int nodeType) {
 1791|  12.4k|    int ret = 0, err = 0, final = 0, tmp, i, m, match, stepNr, desc;
 1792|  12.4k|    xmlStreamCompPtr comp;
 1793|  12.4k|    xmlStreamStep step;
 1794|       |
 1795|  12.4k|    if ((stream == NULL) || (stream->nbState < 0))
  ------------------
  |  Branch (1795:9): [True: 0, False: 12.4k]
  |  Branch (1795:29): [True: 0, False: 12.4k]
  ------------------
 1796|      0|        return(-1);
 1797|       |
 1798|  24.8k|    while (stream != NULL) {
  ------------------
  |  Branch (1798:12): [True: 12.4k, False: 12.4k]
  ------------------
 1799|  12.4k|	comp = stream->comp;
 1800|       |
 1801|  12.4k|	if ((nodeType == XML_ELEMENT_NODE) &&
  ------------------
  |  Branch (1801:6): [True: 12.4k, False: 0]
  ------------------
 1802|  12.4k|	    (name == NULL) && (ns == NULL)) {
  ------------------
  |  Branch (1802:6): [True: 80, False: 12.3k]
  |  Branch (1802:24): [True: 80, False: 0]
  ------------------
 1803|       |	    /* We have a document node here (or a reset). */
 1804|     80|	    stream->nbState = 0;
 1805|     80|	    stream->level = 0;
 1806|     80|	    stream->blockLevel = -1;
 1807|     80|	    if (comp->flags & XML_STREAM_FROM_ROOT) {
  ------------------
  |  |   59|     80|#define XML_STREAM_FROM_ROOT 1<<15
  ------------------
  |  Branch (1807:10): [True: 80, False: 0]
  ------------------
 1808|     80|		if (comp->nbStep == 0) {
  ------------------
  |  Branch (1808:7): [True: 0, False: 80]
  ------------------
 1809|       |		    /* TODO: We have a "/." here? */
 1810|      0|		    ret = 1;
 1811|     80|		} else {
 1812|     80|		    if ((comp->nbStep == 1) &&
  ------------------
  |  Branch (1812:11): [True: 80, False: 0]
  ------------------
 1813|     80|			(comp->steps[0].nodeType == XML_STREAM_ANY_NODE) &&
  ------------------
  |  |   66|     80|#define XML_STREAM_ANY_NODE 100
  ------------------
  |  Branch (1813:4): [True: 0, False: 80]
  ------------------
 1814|     80|			(comp->steps[0].flags & XML_STREAM_STEP_DESC))
  ------------------
  |  |   45|      0|#define XML_STREAM_STEP_DESC	1
  ------------------
  |  Branch (1814:4): [True: 0, False: 0]
  ------------------
 1815|      0|		    {
 1816|       |			/*
 1817|       |			* In the case of "//." the document node will match
 1818|       |			* as well.
 1819|       |			*/
 1820|      0|			ret = 1;
 1821|     80|		    } else if (comp->steps[0].flags & XML_STREAM_STEP_ROOT) {
  ------------------
  |  |   47|     80|#define XML_STREAM_STEP_ROOT	4
  ------------------
  |  Branch (1821:18): [True: 4, False: 76]
  ------------------
 1822|       |			/* TODO: Do we need this ? */
 1823|      4|			tmp = xmlStreamCtxtAddState(stream, 0, 0);
 1824|      4|			if (tmp < 0)
  ------------------
  |  Branch (1824:8): [True: 0, False: 4]
  ------------------
 1825|      0|			    err++;
 1826|      4|		    }
 1827|     80|		}
 1828|     80|	    }
 1829|     80|	    stream = stream->next;
 1830|     80|	    continue; /* while */
 1831|     80|	}
 1832|       |
 1833|       |	/*
 1834|       |	* Fast check for ".".
 1835|       |	*/
 1836|  12.3k|	if (comp->nbStep == 0) {
  ------------------
  |  Branch (1836:6): [True: 0, False: 12.3k]
  ------------------
 1837|       |	    /*
 1838|       |	     * / and . are handled at the XPath node set creation
 1839|       |	     * level by checking min depth
 1840|       |	     */
 1841|      0|	    if (stream->flags & XML_PATTERN_XPATH) {
  ------------------
  |  Branch (1841:10): [True: 0, False: 0]
  ------------------
 1842|      0|		stream = stream->next;
 1843|      0|		continue; /* while */
 1844|      0|	    }
 1845|       |	    /*
 1846|       |	    * For non-pattern like evaluation like XML Schema IDCs
 1847|       |	    * or traditional XPath expressions, this will match if
 1848|       |	    * we are at the first level only, otherwise on every level.
 1849|       |	    */
 1850|      0|	    if ((nodeType != XML_ATTRIBUTE_NODE) &&
  ------------------
  |  Branch (1850:10): [True: 0, False: 0]
  ------------------
 1851|      0|		(((stream->flags & XML_PATTERN_NOTPATTERN) == 0) ||
  ------------------
  |  |   68|      0|#define XML_PATTERN_NOTPATTERN  (XML_PATTERN_XPATH | \
  |  |   69|      0|				 XML_PATTERN_XSSEL | \
  |  |   70|      0|				 XML_PATTERN_XSFIELD)
  ------------------
  |  Branch (1851:4): [True: 0, False: 0]
  ------------------
 1852|      0|		(stream->level == 0))) {
  ------------------
  |  Branch (1852:3): [True: 0, False: 0]
  ------------------
 1853|      0|		    ret = 1;
 1854|      0|	    }
 1855|      0|	    stream->level++;
 1856|      0|	    goto stream_next;
 1857|      0|	}
 1858|  12.3k|	if (stream->blockLevel != -1) {
  ------------------
  |  Branch (1858:6): [True: 0, False: 12.3k]
  ------------------
 1859|       |	    /*
 1860|       |	    * Skip blocked expressions.
 1861|       |	    */
 1862|      0|	    stream->level++;
 1863|      0|	    goto stream_next;
 1864|      0|	}
 1865|       |
 1866|  12.3k|	if ((nodeType != XML_ELEMENT_NODE) &&
  ------------------
  |  Branch (1866:6): [True: 0, False: 12.3k]
  ------------------
 1867|  12.3k|	    (nodeType != XML_ATTRIBUTE_NODE) &&
  ------------------
  |  Branch (1867:6): [True: 0, False: 0]
  ------------------
 1868|  12.3k|	    ((comp->flags & XML_STREAM_FINAL_IS_ANY_NODE) == 0)) {
  ------------------
  |  |   58|      0|#define XML_STREAM_FINAL_IS_ANY_NODE 1<<14
  ------------------
  |  Branch (1868:6): [True: 0, False: 0]
  ------------------
 1869|       |	    /*
 1870|       |	    * No need to process nodes of other types if we don't
 1871|       |	    * resolve to those types.
 1872|       |	    * TODO: Do we need to block the context here?
 1873|       |	    */
 1874|      0|	    stream->level++;
 1875|      0|	    goto stream_next;
 1876|      0|	}
 1877|       |
 1878|       |	/*
 1879|       |	 * Check evolution of existing states
 1880|       |	 */
 1881|  12.3k|	i = 0;
 1882|  12.3k|	m = stream->nbState;
 1883|  12.3k|	while (i < m) {
  ------------------
  |  Branch (1883:9): [True: 4, False: 12.3k]
  ------------------
 1884|      4|	    if ((comp->flags & XML_STREAM_DESC) == 0) {
  ------------------
  |  |   60|      4|#define XML_STREAM_DESC 1<<16
  ------------------
  |  Branch (1884:10): [True: 4, False: 0]
  ------------------
 1885|       |		/*
 1886|       |		* If there is no "//", then only the last
 1887|       |		* added state is of interest.
 1888|       |		*/
 1889|      4|		stepNr = stream->states[2 * (stream->nbState -1)];
 1890|       |		/*
 1891|       |		* TODO: Security check, should not happen, remove it.
 1892|       |		*/
 1893|      4|		if (stream->states[(2 * (stream->nbState -1)) + 1] <
  ------------------
  |  Branch (1893:7): [True: 0, False: 4]
  ------------------
 1894|      4|		    stream->level) {
 1895|      0|		    return (-1);
 1896|      0|		}
 1897|      4|		desc = 0;
 1898|       |		/* loop-stopper */
 1899|      4|		i = m;
 1900|      4|	    } else {
 1901|       |		/*
 1902|       |		* If there are "//", then we need to process every "//"
 1903|       |		* occurring in the states, plus any other state for this
 1904|       |		* level.
 1905|       |		*/
 1906|      0|		stepNr = stream->states[2 * i];
 1907|       |
 1908|       |		/* TODO: should not happen anymore: dead states */
 1909|      0|		if (stepNr < 0)
  ------------------
  |  Branch (1909:7): [True: 0, False: 0]
  ------------------
 1910|      0|		    goto next_state;
 1911|       |
 1912|      0|		tmp = stream->states[(2 * i) + 1];
 1913|       |
 1914|       |		/* skip new states just added */
 1915|      0|		if (tmp > stream->level)
  ------------------
  |  Branch (1915:7): [True: 0, False: 0]
  ------------------
 1916|      0|		    goto next_state;
 1917|       |
 1918|       |		/* skip states at ancestor levels, except if "//" */
 1919|      0|		desc = comp->steps[stepNr].flags & XML_STREAM_STEP_DESC;
  ------------------
  |  |   45|      0|#define XML_STREAM_STEP_DESC	1
  ------------------
 1920|      0|		if ((tmp < stream->level) && (!desc))
  ------------------
  |  Branch (1920:7): [True: 0, False: 0]
  |  Branch (1920:32): [True: 0, False: 0]
  ------------------
 1921|      0|		    goto next_state;
 1922|      0|	    }
 1923|       |	    /*
 1924|       |	    * Check for correct node-type.
 1925|       |	    */
 1926|      4|	    step = comp->steps[stepNr];
 1927|      4|	    if (step.nodeType != nodeType) {
  ------------------
  |  Branch (1927:10): [True: 0, False: 4]
  ------------------
 1928|      0|		if (step.nodeType == XML_ATTRIBUTE_NODE) {
  ------------------
  |  Branch (1928:7): [True: 0, False: 0]
  ------------------
 1929|       |		    /*
 1930|       |		    * Block this expression for deeper evaluation.
 1931|       |		    */
 1932|      0|		    if ((comp->flags & XML_STREAM_DESC) == 0)
  ------------------
  |  |   60|      0|#define XML_STREAM_DESC 1<<16
  ------------------
  |  Branch (1932:11): [True: 0, False: 0]
  ------------------
 1933|      0|			stream->blockLevel = stream->level +1;
 1934|      0|		    goto next_state;
 1935|      0|		} else if (step.nodeType != XML_STREAM_ANY_NODE)
  ------------------
  |  |   66|      0|#define XML_STREAM_ANY_NODE 100
  ------------------
  |  Branch (1935:14): [True: 0, False: 0]
  ------------------
 1936|      0|		    goto next_state;
 1937|      0|	    }
 1938|       |	    /*
 1939|       |	    * Compare local/namespace-name.
 1940|       |	    */
 1941|      4|	    match = 0;
 1942|      4|	    if (step.nodeType == XML_STREAM_ANY_NODE) {
  ------------------
  |  |   66|      4|#define XML_STREAM_ANY_NODE 100
  ------------------
  |  Branch (1942:10): [True: 0, False: 4]
  ------------------
 1943|      0|		match = 1;
 1944|      4|	    } else if (step.name == NULL) {
  ------------------
  |  Branch (1944:17): [True: 0, False: 4]
  ------------------
 1945|      0|		if (step.ns == NULL) {
  ------------------
  |  Branch (1945:7): [True: 0, False: 0]
  ------------------
 1946|       |		    /*
 1947|       |		    * This lets through all elements/attributes.
 1948|       |		    */
 1949|      0|		    match = 1;
 1950|      0|		} else if (ns != NULL)
  ------------------
  |  Branch (1950:14): [True: 0, False: 0]
  ------------------
 1951|      0|		    match = xmlStrEqual(step.ns, ns);
 1952|      4|	    } else if (((step.ns != NULL) == (ns != NULL)) &&
  ------------------
  |  Branch (1952:17): [True: 4, False: 0]
  ------------------
 1953|      4|		(name != NULL) &&
  ------------------
  |  Branch (1953:3): [True: 4, False: 0]
  ------------------
 1954|      4|		(step.name[0] == name[0]) &&
  ------------------
  |  Branch (1954:3): [True: 4, False: 0]
  ------------------
 1955|      4|		xmlStrEqual(step.name, name) &&
  ------------------
  |  Branch (1955:3): [True: 4, False: 0]
  ------------------
 1956|      4|		((step.ns == ns) || xmlStrEqual(step.ns, ns)))
  ------------------
  |  Branch (1956:4): [True: 4, False: 0]
  |  Branch (1956:23): [True: 0, False: 0]
  ------------------
 1957|      4|	    {
 1958|      4|		match = 1;
 1959|      4|	    }
 1960|       |#if 0
 1961|       |/*
 1962|       |* TODO: Pointer comparison won't work, since not guaranteed that the given
 1963|       |*  values are in the same dict; especially if it's the namespace name,
 1964|       |*  normally coming from ns->href. We need a namespace dict mechanism !
 1965|       |*/
 1966|       |	    } else if (comp->dict) {
 1967|       |		if (step.name == NULL) {
 1968|       |		    if (step.ns == NULL)
 1969|       |			match = 1;
 1970|       |		    else
 1971|       |			match = (step.ns == ns);
 1972|       |		} else {
 1973|       |		    match = ((step.name == name) && (step.ns == ns));
 1974|       |		}
 1975|       |#endif /* if 0 ------------------------------------------------------- */
 1976|      4|	    if (match) {
  ------------------
  |  Branch (1976:10): [True: 4, False: 0]
  ------------------
 1977|      4|		final = step.flags & XML_STREAM_STEP_FINAL;
  ------------------
  |  |   46|      4|#define XML_STREAM_STEP_FINAL	2
  ------------------
 1978|      4|                if (final) {
  ------------------
  |  Branch (1978:21): [True: 4, False: 0]
  ------------------
 1979|      4|                    ret = 1;
 1980|      4|                } else {
 1981|      0|                    xmlStreamCtxtAddState(stream, stepNr + 1,
 1982|      0|                                          stream->level + 1);
 1983|      0|                }
 1984|      4|		if ((ret != 1) && (step.flags & XML_STREAM_STEP_IN_SET)) {
  ------------------
  |  |   50|      0|#define XML_STREAM_STEP_IN_SET	32
  ------------------
  |  Branch (1984:7): [True: 0, False: 4]
  |  Branch (1984:21): [True: 0, False: 0]
  ------------------
 1985|       |		    /*
 1986|       |		    * Check if we have a special case like "foo/bar//.", where
 1987|       |		    * "foo" is selected as well.
 1988|       |		    */
 1989|      0|		    ret = 1;
 1990|      0|		}
 1991|      4|	    }
 1992|      4|	    if (((comp->flags & XML_STREAM_DESC) == 0) &&
  ------------------
  |  |   60|      4|#define XML_STREAM_DESC 1<<16
  ------------------
  |  Branch (1992:10): [True: 4, False: 0]
  ------------------
 1993|      4|		((! match) || final))  {
  ------------------
  |  Branch (1993:4): [True: 0, False: 4]
  |  Branch (1993:17): [True: 4, False: 0]
  ------------------
 1994|       |		/*
 1995|       |		* Mark this expression as blocked for any evaluation at
 1996|       |		* deeper levels. Note that this includes "/foo"
 1997|       |		* expressions if the *pattern* behaviour is used.
 1998|       |		*/
 1999|      4|		stream->blockLevel = stream->level +1;
 2000|      4|	    }
 2001|      4|next_state:
 2002|      4|	    i++;
 2003|      4|	}
 2004|       |
 2005|  12.3k|	stream->level++;
 2006|       |
 2007|       |	/*
 2008|       |	* Re/enter the expression.
 2009|       |	* Don't reenter if it's an absolute expression like "/foo",
 2010|       |	*   except "//foo".
 2011|       |	*/
 2012|  12.3k|	step = comp->steps[0];
 2013|  12.3k|	if (step.flags & XML_STREAM_STEP_ROOT)
  ------------------
  |  |   47|  12.3k|#define XML_STREAM_STEP_ROOT	4
  ------------------
  |  Branch (2013:6): [True: 4, False: 12.3k]
  ------------------
 2014|      4|	    goto stream_next;
 2015|       |
 2016|  12.3k|	desc = step.flags & XML_STREAM_STEP_DESC;
  ------------------
  |  |   45|  12.3k|#define XML_STREAM_STEP_DESC	1
  ------------------
 2017|  12.3k|	if (stream->flags & XML_PATTERN_NOTPATTERN) {
  ------------------
  |  |   68|  12.3k|#define XML_PATTERN_NOTPATTERN  (XML_PATTERN_XPATH | \
  |  |   69|  12.3k|				 XML_PATTERN_XSSEL | \
  |  |   70|  12.3k|				 XML_PATTERN_XSFIELD)
  ------------------
  |  Branch (2017:6): [True: 12.3k, False: 0]
  ------------------
 2018|       |	    /*
 2019|       |	    * Re/enter the expression if it is a "descendant" one,
 2020|       |	    * or if we are at the 1st level of evaluation.
 2021|       |	    */
 2022|       |
 2023|  12.3k|	    if (stream->level == 1) {
  ------------------
  |  Branch (2023:10): [True: 76, False: 12.2k]
  ------------------
 2024|     76|		if (XML_STREAM_XS_IDC(stream)) {
  ------------------
  |  |   72|     76|#define XML_STREAM_XS_IDC(c) ((c)->flags & \
  |  |  ------------------
  |  |  |  Branch (72:30): [True: 0, False: 76]
  |  |  ------------------
  |  |   73|     76|    (XML_PATTERN_XSSEL | XML_PATTERN_XSFIELD))
  ------------------
 2025|       |		    /*
 2026|       |		    * XS-IDC: The missing "self::node()" will always
 2027|       |		    * match the first given node.
 2028|       |		    */
 2029|      0|		    goto stream_next;
 2030|      0|		} else
 2031|     76|		    goto compare;
 2032|     76|	    }
 2033|       |	    /*
 2034|       |	    * A "//" is always reentrant.
 2035|       |	    */
 2036|  12.2k|	    if (desc)
  ------------------
  |  Branch (2036:10): [True: 12.2k, False: 0]
  ------------------
 2037|  12.2k|		goto compare;
 2038|       |
 2039|       |	    /*
 2040|       |	    * XS-IDC: Process the 2nd level, since the missing
 2041|       |	    * "self::node()" is responsible for the 2nd level being
 2042|       |	    * the real start level.
 2043|       |	    */
 2044|      0|	    if ((stream->level == 2) && XML_STREAM_XS_IDC(stream))
  ------------------
  |  |   72|      0|#define XML_STREAM_XS_IDC(c) ((c)->flags & \
  |  |  ------------------
  |  |  |  Branch (72:30): [True: 0, False: 0]
  |  |  ------------------
  |  |   73|      0|    (XML_PATTERN_XSSEL | XML_PATTERN_XSFIELD))
  ------------------
  |  Branch (2044:10): [True: 0, False: 0]
  ------------------
 2045|      0|		goto compare;
 2046|       |
 2047|      0|	    goto stream_next;
 2048|      0|	}
 2049|       |
 2050|  12.3k|compare:
 2051|       |	/*
 2052|       |	* Check expected node-type.
 2053|       |	*/
 2054|  12.3k|	if (step.nodeType != nodeType) {
  ------------------
  |  Branch (2054:6): [True: 0, False: 12.3k]
  ------------------
 2055|      0|	    if (nodeType == XML_ATTRIBUTE_NODE)
  ------------------
  |  Branch (2055:10): [True: 0, False: 0]
  ------------------
 2056|      0|		goto stream_next;
 2057|      0|	    else if (step.nodeType != XML_STREAM_ANY_NODE)
  ------------------
  |  |   66|      0|#define XML_STREAM_ANY_NODE 100
  ------------------
  |  Branch (2057:15): [True: 0, False: 0]
  ------------------
 2058|      0|		goto stream_next;
 2059|      0|	}
 2060|       |	/*
 2061|       |	* Compare local/namespace-name.
 2062|       |	*/
 2063|  12.3k|	match = 0;
 2064|  12.3k|	if (step.nodeType == XML_STREAM_ANY_NODE) {
  ------------------
  |  |   66|  12.3k|#define XML_STREAM_ANY_NODE 100
  ------------------
  |  Branch (2064:6): [True: 0, False: 12.3k]
  ------------------
 2065|      0|	    match = 1;
 2066|  12.3k|	} else if (step.name == NULL) {
  ------------------
  |  Branch (2066:13): [True: 0, False: 12.3k]
  ------------------
 2067|      0|	    if (step.ns == NULL) {
  ------------------
  |  Branch (2067:10): [True: 0, False: 0]
  ------------------
 2068|       |		/*
 2069|       |		* This lets through all elements/attributes.
 2070|       |		*/
 2071|      0|		match = 1;
 2072|      0|	    } else if (ns != NULL)
  ------------------
  |  Branch (2072:17): [True: 0, False: 0]
  ------------------
 2073|      0|		match = xmlStrEqual(step.ns, ns);
 2074|  12.3k|	} else if (((step.ns != NULL) == (ns != NULL)) &&
  ------------------
  |  Branch (2074:13): [True: 6.25k, False: 6.07k]
  ------------------
 2075|  12.3k|	    (name != NULL) &&
  ------------------
  |  Branch (2075:6): [True: 6.25k, False: 0]
  ------------------
 2076|  12.3k|	    (step.name[0] == name[0]) &&
  ------------------
  |  Branch (2076:6): [True: 6.14k, False: 108]
  ------------------
 2077|  12.3k|	    xmlStrEqual(step.name, name) &&
  ------------------
  |  Branch (2077:6): [True: 84, False: 6.06k]
  ------------------
 2078|  12.3k|	    ((step.ns == ns) || xmlStrEqual(step.ns, ns)))
  ------------------
  |  Branch (2078:7): [True: 84, False: 0]
  |  Branch (2078:26): [True: 0, False: 0]
  ------------------
 2079|     84|	{
 2080|     84|	    match = 1;
 2081|     84|	}
 2082|  12.3k|	final = step.flags & XML_STREAM_STEP_FINAL;
  ------------------
  |  |   46|  12.3k|#define XML_STREAM_STEP_FINAL	2
  ------------------
 2083|  12.3k|	if (match) {
  ------------------
  |  Branch (2083:6): [True: 84, False: 12.2k]
  ------------------
 2084|     84|	    if (final)
  ------------------
  |  Branch (2084:10): [True: 84, False: 0]
  ------------------
 2085|     84|		ret = 1;
 2086|      0|	    else
 2087|      0|		xmlStreamCtxtAddState(stream, 1, stream->level);
 2088|     84|	    if ((ret != 1) && (step.flags & XML_STREAM_STEP_IN_SET)) {
  ------------------
  |  |   50|      0|#define XML_STREAM_STEP_IN_SET	32
  ------------------
  |  Branch (2088:10): [True: 0, False: 84]
  |  Branch (2088:24): [True: 0, False: 0]
  ------------------
 2089|       |		/*
 2090|       |		* Check if we have a special case like "foo//.", where
 2091|       |		* "foo" is selected as well.
 2092|       |		*/
 2093|      0|		ret = 1;
 2094|      0|	    }
 2095|     84|	}
 2096|  12.3k|	if (((comp->flags & XML_STREAM_DESC) == 0) &&
  ------------------
  |  |   60|  12.3k|#define XML_STREAM_DESC 1<<16
  ------------------
  |  Branch (2096:6): [True: 0, False: 12.3k]
  ------------------
 2097|  12.3k|	    ((! match) || final))  {
  ------------------
  |  Branch (2097:7): [True: 0, False: 0]
  |  Branch (2097:20): [True: 0, False: 0]
  ------------------
 2098|       |	    /*
 2099|       |	    * Mark this expression as blocked for any evaluation at
 2100|       |	    * deeper levels.
 2101|       |	    */
 2102|      0|	    stream->blockLevel = stream->level;
 2103|      0|	}
 2104|       |
 2105|  12.3k|stream_next:
 2106|  12.3k|        stream = stream->next;
 2107|  12.3k|    } /* while stream != NULL */
 2108|       |
 2109|  12.4k|    if (err > 0)
  ------------------
  |  Branch (2109:9): [True: 0, False: 12.4k]
  ------------------
 2110|      0|        ret = -1;
 2111|  12.4k|    return(ret);
 2112|  12.4k|}
pattern.c:xmlStreamCtxtAddState:
 1744|      4|xmlStreamCtxtAddState(xmlStreamCtxtPtr comp, int idx, int level) {
 1745|      4|    int i;
 1746|      4|    for (i = 0;i < comp->nbState;i++) {
  ------------------
  |  Branch (1746:16): [True: 0, False: 4]
  ------------------
 1747|      0|        if (comp->states[2 * i] < 0) {
  ------------------
  |  Branch (1747:13): [True: 0, False: 0]
  ------------------
 1748|      0|	    comp->states[2 * i] = idx;
 1749|      0|	    comp->states[2 * i + 1] = level;
 1750|      0|	    return(i);
 1751|      0|	}
 1752|      0|    }
 1753|      4|    if (comp->nbState >= comp->maxState) {
  ------------------
  |  Branch (1753:9): [True: 0, False: 4]
  ------------------
 1754|      0|        int *cur;
 1755|       |
 1756|      0|	cur = (int *) xmlRealloc(comp->states,
 1757|      0|				 comp->maxState * 4 * sizeof(int));
 1758|      0|	if (cur == NULL) {
  ------------------
  |  Branch (1758:6): [True: 0, False: 0]
  ------------------
 1759|      0|	    ERROR(NULL, NULL, NULL,
 1760|      0|		  "xmlNewStreamCtxt: malloc failed\n");
 1761|      0|	    return(-1);
 1762|      0|	}
 1763|      0|	comp->states = cur;
 1764|      0|        comp->maxState *= 2;
 1765|      0|    }
 1766|      4|    comp->states[2 * comp->nbState] = idx;
 1767|      4|    comp->states[2 * comp->nbState++ + 1] = level;
 1768|      4|    return(comp->nbState - 1);
 1769|      4|}
pattern.c:xmlNewPatParserContext:
  293|     80|                       const xmlChar **namespaces) {
  294|     80|    xmlPatParserContextPtr cur;
  295|       |
  296|     80|    if (pattern == NULL)
  ------------------
  |  Branch (296:9): [True: 0, False: 80]
  ------------------
  297|      0|        return(NULL);
  298|       |
  299|     80|    cur = (xmlPatParserContextPtr) xmlMalloc(sizeof(xmlPatParserContext));
  300|     80|    if (cur == NULL) {
  ------------------
  |  Branch (300:9): [True: 0, False: 80]
  ------------------
  301|      0|	ERROR(NULL, NULL, NULL,
  302|      0|		"xmlNewPatParserContext : malloc failed\n");
  303|      0|	return(NULL);
  304|      0|    }
  305|     80|    memset(cur, 0, sizeof(xmlPatParserContext));
  306|     80|    cur->dict = dict;
  307|     80|    cur->cur = pattern;
  308|     80|    cur->base = pattern;
  309|     80|    if (namespaces != NULL) {
  ------------------
  |  Branch (309:9): [True: 0, False: 80]
  ------------------
  310|      0|        int i;
  311|      0|        for (i = 0;namespaces[2 * i] != NULL;i++)
  ------------------
  |  Branch (311:20): [True: 0, False: 0]
  ------------------
  312|      0|            ;
  313|      0|        cur->nb_namespaces = i;
  314|     80|    } else {
  315|     80|        cur->nb_namespaces = 0;
  316|     80|    }
  317|     80|    cur->namespaces = namespaces;
  318|     80|    return(cur);
  319|     80|}
pattern.c:xmlNewPattern:
  200|     80|xmlNewPattern(void) {
  201|     80|    xmlPatternPtr cur;
  202|       |
  203|     80|    cur = (xmlPatternPtr) xmlMalloc(sizeof(xmlPattern));
  204|     80|    if (cur == NULL) {
  ------------------
  |  Branch (204:9): [True: 0, False: 80]
  ------------------
  205|      0|	ERROR(NULL, NULL, NULL,
  206|      0|		"xmlNewPattern : malloc failed\n");
  207|      0|	return(NULL);
  208|      0|    }
  209|     80|    memset(cur, 0, sizeof(xmlPattern));
  210|     80|    cur->maxStep = 10;
  211|     80|    cur->steps = (xmlStepOpPtr) xmlMalloc(cur->maxStep * sizeof(xmlStepOp));
  212|     80|    if (cur->steps == NULL) {
  ------------------
  |  Branch (212:9): [True: 0, False: 80]
  ------------------
  213|      0|        xmlFree(cur);
  214|      0|	ERROR(NULL, NULL, NULL,
  215|      0|		"xmlNewPattern : malloc failed\n");
  216|      0|	return(NULL);
  217|      0|    }
  218|     80|    return(cur);
  219|     80|}
pattern.c:xmlPatternAdd:
  350|    160|{
  351|    160|    if (comp->nbStep >= comp->maxStep) {
  ------------------
  |  Branch (351:9): [True: 0, False: 160]
  ------------------
  352|      0|        xmlStepOpPtr temp;
  353|      0|	temp = (xmlStepOpPtr) xmlRealloc(comp->steps, comp->maxStep * 2 *
  354|      0|	                                 sizeof(xmlStepOp));
  355|      0|        if (temp == NULL) {
  ------------------
  |  Branch (355:13): [True: 0, False: 0]
  ------------------
  356|      0|	    ERROR(ctxt, NULL, NULL,
  357|      0|			     "xmlPatternAdd: realloc failed\n");
  358|      0|	    return (-1);
  359|      0|	}
  360|      0|	comp->steps = temp;
  361|      0|	comp->maxStep *= 2;
  362|      0|    }
  363|    160|    comp->steps[comp->nbStep].op = op;
  364|    160|    comp->steps[comp->nbStep].value = value;
  365|    160|    comp->steps[comp->nbStep].value2 = value2;
  366|    160|    comp->nbStep++;
  367|    160|    return (0);
  368|    160|}
pattern.c:xmlCompileStepPattern:
 1003|     80|xmlCompileStepPattern(xmlPatParserContextPtr ctxt) {
 1004|     80|    xmlChar *token = NULL;
 1005|     80|    xmlChar *name = NULL;
 1006|     80|    xmlChar *URL = NULL;
 1007|     80|    int hasBlanks = 0;
 1008|       |
 1009|     80|    SKIP_BLANKS;
  ------------------
  |  |  711|     80|    while (IS_BLANK_CH(CUR)) NEXT
  |  |  ------------------
  |  |  |  |  714|      0|#define NEXT ((*ctxt->cur) ?  ctxt->cur++: ctxt->cur)
  |  |  |  |  ------------------
  |  |  |  |  |  Branch (714:15): [True: 0, False: 0]
  |  |  |  |  ------------------
  |  |  ------------------
  ------------------
 1010|     80|    if (CUR == '.') {
  ------------------
  |  |  704|     80|#define CUR (*ctxt->cur)
  ------------------
  |  Branch (1010:9): [True: 0, False: 80]
  ------------------
 1011|       |	/*
 1012|       |	* Context node.
 1013|       |	*/
 1014|      0|	NEXT;
  ------------------
  |  |  714|      0|#define NEXT ((*ctxt->cur) ?  ctxt->cur++: ctxt->cur)
  |  |  ------------------
  |  |  |  Branch (714:15): [True: 0, False: 0]
  |  |  ------------------
  ------------------
 1015|      0|	PUSH(XML_OP_ELEM, NULL, NULL);
  ------------------
  |  |  718|      0|    if (xmlPatternAdd(ctxt, ctxt->comp, (op), (val), (val2))) goto error;
  |  |  ------------------
  |  |  |  Branch (718:9): [True: 0, False: 0]
  |  |  ------------------
  ------------------
 1016|      0|	return;
 1017|      0|    }
 1018|     80|    if (CUR == '@') {
  ------------------
  |  |  704|     80|#define CUR (*ctxt->cur)
  ------------------
  |  Branch (1018:9): [True: 0, False: 80]
  ------------------
 1019|       |	/*
 1020|       |	* Attribute test.
 1021|       |	*/
 1022|      0|	if (XML_STREAM_XS_IDC_SEL(ctxt->comp)) {
  ------------------
  |  |   75|      0|#define XML_STREAM_XS_IDC_SEL(c) ((c)->flags & XML_PATTERN_XSSEL)
  |  |  ------------------
  |  |  |  Branch (75:34): [True: 0, False: 0]
  |  |  ------------------
  ------------------
 1023|      0|	    ERROR5(NULL, NULL, NULL,
 1024|      0|		"Unexpected attribute axis in '%s'.\n", ctxt->base);
 1025|      0|	    ctxt->error = 1;
 1026|      0|	    return;
 1027|      0|	}
 1028|      0|	NEXT;
  ------------------
  |  |  714|      0|#define NEXT ((*ctxt->cur) ?  ctxt->cur++: ctxt->cur)
  |  |  ------------------
  |  |  |  Branch (714:15): [True: 0, False: 0]
  |  |  ------------------
  ------------------
 1029|      0|	xmlCompileAttributeTest(ctxt);
 1030|      0|	if (ctxt->error != 0)
  ------------------
  |  Branch (1030:6): [True: 0, False: 0]
  ------------------
 1031|      0|	    goto error;
 1032|      0|	return;
 1033|      0|    }
 1034|     80|    name = xmlPatScanNCName(ctxt);
 1035|     80|    if (name == NULL) {
  ------------------
  |  Branch (1035:9): [True: 0, False: 80]
  ------------------
 1036|      0|	if (CUR == '*') {
  ------------------
  |  |  704|      0|#define CUR (*ctxt->cur)
  ------------------
  |  Branch (1036:6): [True: 0, False: 0]
  ------------------
 1037|      0|	    NEXT;
  ------------------
  |  |  714|      0|#define NEXT ((*ctxt->cur) ?  ctxt->cur++: ctxt->cur)
  |  |  ------------------
  |  |  |  Branch (714:15): [True: 0, False: 0]
  |  |  ------------------
  ------------------
 1038|      0|	    PUSH(XML_OP_ALL, NULL, NULL);
  ------------------
  |  |  718|      0|    if (xmlPatternAdd(ctxt, ctxt->comp, (op), (val), (val2))) goto error;
  |  |  ------------------
  |  |  |  Branch (718:9): [True: 0, False: 0]
  |  |  ------------------
  ------------------
 1039|      0|	    return;
 1040|      0|	} else {
 1041|      0|	    ERROR(NULL, NULL, NULL,
 1042|      0|		    "xmlCompileStepPattern : Name expected\n");
 1043|      0|	    ctxt->error = 1;
 1044|      0|	    return;
 1045|      0|	}
 1046|      0|    }
 1047|     80|    if (IS_BLANK_CH(CUR)) {
  ------------------
  |  |  151|     80|#define IS_BLANK_CH(c)  xmlIsBlank_ch(c)
  |  |  ------------------
  |  |  |  |   88|     80|#define xmlIsBlank_ch(c)	(((c) == 0x20) || \
  |  |  |  |  ------------------
  |  |  |  |  |  Branch (88:27): [True: 0, False: 80]
  |  |  |  |  ------------------
  |  |  |  |   89|     80|				 ((0x9 <= (c)) && ((c) <= 0xa)) || \
  |  |  |  |  ------------------
  |  |  |  |  |  Branch (89:7): [True: 0, False: 80]
  |  |  |  |  |  Branch (89:23): [True: 0, False: 0]
  |  |  |  |  ------------------
  |  |  |  |   90|     80|				 ((c) == 0xd))
  |  |  |  |  ------------------
  |  |  |  |  |  Branch (90:6): [True: 0, False: 80]
  |  |  |  |  ------------------
  |  |  ------------------
  ------------------
 1048|      0|	hasBlanks = 1;
 1049|      0|	SKIP_BLANKS;
  ------------------
  |  |  711|      0|    while (IS_BLANK_CH(CUR)) NEXT
  |  |  ------------------
  |  |  |  |  714|      0|#define NEXT ((*ctxt->cur) ?  ctxt->cur++: ctxt->cur)
  |  |  |  |  ------------------
  |  |  |  |  |  Branch (714:15): [True: 0, False: 0]
  |  |  |  |  ------------------
  |  |  ------------------
  ------------------
 1050|      0|    }
 1051|     80|    if (CUR == ':') {
  ------------------
  |  |  704|     80|#define CUR (*ctxt->cur)
  ------------------
  |  Branch (1051:9): [True: 0, False: 80]
  ------------------
 1052|      0|	NEXT;
  ------------------
  |  |  714|      0|#define NEXT ((*ctxt->cur) ?  ctxt->cur++: ctxt->cur)
  |  |  ------------------
  |  |  |  Branch (714:15): [True: 0, False: 0]
  |  |  ------------------
  ------------------
 1053|      0|	if (CUR != ':') {
  ------------------
  |  |  704|      0|#define CUR (*ctxt->cur)
  ------------------
  |  Branch (1053:6): [True: 0, False: 0]
  ------------------
 1054|      0|	    xmlChar *prefix = name;
 1055|      0|	    int i;
 1056|       |
 1057|      0|	    if (hasBlanks || IS_BLANK_CH(CUR)) {
  ------------------
  |  |  151|      0|#define IS_BLANK_CH(c)  xmlIsBlank_ch(c)
  |  |  ------------------
  |  |  |  |   88|      0|#define xmlIsBlank_ch(c)	(((c) == 0x20) || \
  |  |  |  |  ------------------
  |  |  |  |  |  Branch (88:27): [True: 0, False: 0]
  |  |  |  |  ------------------
  |  |  |  |   89|      0|				 ((0x9 <= (c)) && ((c) <= 0xa)) || \
  |  |  |  |  ------------------
  |  |  |  |  |  Branch (89:7): [True: 0, False: 0]
  |  |  |  |  |  Branch (89:23): [True: 0, False: 0]
  |  |  |  |  ------------------
  |  |  |  |   90|      0|				 ((c) == 0xd))
  |  |  |  |  ------------------
  |  |  |  |  |  Branch (90:6): [True: 0, False: 0]
  |  |  |  |  ------------------
  |  |  ------------------
  ------------------
  |  Branch (1057:10): [True: 0, False: 0]
  ------------------
 1058|      0|		ERROR5(NULL, NULL, NULL, "Invalid QName.\n", NULL);
 1059|      0|		ctxt->error = 1;
 1060|      0|		goto error;
 1061|      0|	    }
 1062|       |	    /*
 1063|       |	     * This is a namespace match
 1064|       |	     */
 1065|      0|	    token = xmlPatScanName(ctxt);
 1066|      0|	    if ((prefix[0] == 'x') &&
  ------------------
  |  Branch (1066:10): [True: 0, False: 0]
  ------------------
 1067|      0|		(prefix[1] == 'm') &&
  ------------------
  |  Branch (1067:3): [True: 0, False: 0]
  ------------------
 1068|      0|		(prefix[2] == 'l') &&
  ------------------
  |  Branch (1068:3): [True: 0, False: 0]
  ------------------
 1069|      0|		(prefix[3] == 0))
  ------------------
  |  Branch (1069:3): [True: 0, False: 0]
  ------------------
 1070|      0|	    {
 1071|      0|		XML_PAT_COPY_NSNAME(ctxt, URL, XML_XML_NAMESPACE)
  ------------------
  |  |   80|      0|    if ((c)->comp->dict) \
  |  |  ------------------
  |  |  |  Branch (80:9): [True: 0, False: 0]
  |  |  ------------------
  |  |   81|      0|	r = (xmlChar *) xmlDictLookup((c)->comp->dict, BAD_CAST nsname, -1); \
  |  |  ------------------
  |  |  |  |   35|      0|#define BAD_CAST (xmlChar *)
  |  |  ------------------
  |  |   82|      0|    else r = xmlStrdup(BAD_CAST nsname);
  |  |  ------------------
  |  |  |  |   35|      0|#define BAD_CAST (xmlChar *)
  |  |  ------------------
  ------------------
 1072|      0|	    } else {
 1073|      0|		for (i = 0;i < ctxt->nb_namespaces;i++) {
  ------------------
  |  Branch (1073:14): [True: 0, False: 0]
  ------------------
 1074|      0|		    if (xmlStrEqual(ctxt->namespaces[2 * i + 1], prefix)) {
  ------------------
  |  Branch (1074:11): [True: 0, False: 0]
  ------------------
 1075|      0|			XML_PAT_COPY_NSNAME(ctxt, URL, ctxt->namespaces[2 * i])
  ------------------
  |  |   80|      0|    if ((c)->comp->dict) \
  |  |  ------------------
  |  |  |  Branch (80:9): [True: 0, False: 0]
  |  |  ------------------
  |  |   81|      0|	r = (xmlChar *) xmlDictLookup((c)->comp->dict, BAD_CAST nsname, -1); \
  |  |  ------------------
  |  |  |  |   35|      0|#define BAD_CAST (xmlChar *)
  |  |  ------------------
  |  |   82|      0|    else r = xmlStrdup(BAD_CAST nsname);
  |  |  ------------------
  |  |  |  |   35|      0|#define BAD_CAST (xmlChar *)
  |  |  ------------------
  ------------------
 1076|      0|			break;
 1077|      0|		    }
 1078|      0|		}
 1079|      0|		if (i >= ctxt->nb_namespaces) {
  ------------------
  |  Branch (1079:7): [True: 0, False: 0]
  ------------------
 1080|      0|		    ERROR5(NULL, NULL, NULL,
 1081|      0|			"xmlCompileStepPattern : no namespace bound to prefix %s\n",
 1082|      0|			prefix);
 1083|      0|		    ctxt->error = 1;
 1084|      0|		    goto error;
 1085|      0|		}
 1086|      0|	    }
 1087|      0|	    XML_PAT_FREE_STRING(ctxt, prefix);
  ------------------
  |  |   84|      0|#define XML_PAT_FREE_STRING(c, r) if ((c)->comp->dict == NULL) xmlFree(r);
  |  |  ------------------
  |  |  |  Branch (84:39): [True: 0, False: 0]
  |  |  ------------------
  ------------------
 1088|      0|	    name = NULL;
 1089|      0|	    if (token == NULL) {
  ------------------
  |  Branch (1089:10): [True: 0, False: 0]
  ------------------
 1090|      0|		if (CUR == '*') {
  ------------------
  |  |  704|      0|#define CUR (*ctxt->cur)
  ------------------
  |  Branch (1090:7): [True: 0, False: 0]
  ------------------
 1091|      0|		    NEXT;
  ------------------
  |  |  714|      0|#define NEXT ((*ctxt->cur) ?  ctxt->cur++: ctxt->cur)
  |  |  ------------------
  |  |  |  Branch (714:15): [True: 0, False: 0]
  |  |  ------------------
  ------------------
 1092|      0|		    PUSH(XML_OP_NS, URL, NULL);
  ------------------
  |  |  718|      0|    if (xmlPatternAdd(ctxt, ctxt->comp, (op), (val), (val2))) goto error;
  |  |  ------------------
  |  |  |  Branch (718:9): [True: 0, False: 0]
  |  |  ------------------
  ------------------
 1093|      0|		} else {
 1094|      0|		    ERROR(NULL, NULL, NULL,
 1095|      0|			    "xmlCompileStepPattern : Name expected\n");
 1096|      0|		    ctxt->error = 1;
 1097|      0|		    goto error;
 1098|      0|		}
 1099|      0|	    } else {
 1100|      0|		PUSH(XML_OP_ELEM, token, URL);
  ------------------
  |  |  718|      0|    if (xmlPatternAdd(ctxt, ctxt->comp, (op), (val), (val2))) goto error;
  |  |  ------------------
  |  |  |  Branch (718:9): [True: 0, False: 0]
  |  |  ------------------
  ------------------
 1101|      0|	    }
 1102|      0|	} else {
 1103|      0|	    NEXT;
  ------------------
  |  |  714|      0|#define NEXT ((*ctxt->cur) ?  ctxt->cur++: ctxt->cur)
  |  |  ------------------
  |  |  |  Branch (714:15): [True: 0, False: 0]
  |  |  ------------------
  ------------------
 1104|      0|	    if (xmlStrEqual(name, (const xmlChar *) "child")) {
  ------------------
  |  Branch (1104:10): [True: 0, False: 0]
  ------------------
 1105|      0|		XML_PAT_FREE_STRING(ctxt, name);
  ------------------
  |  |   84|      0|#define XML_PAT_FREE_STRING(c, r) if ((c)->comp->dict == NULL) xmlFree(r);
  |  |  ------------------
  |  |  |  Branch (84:39): [True: 0, False: 0]
  |  |  ------------------
  ------------------
 1106|      0|		name = xmlPatScanName(ctxt);
 1107|      0|		if (name == NULL) {
  ------------------
  |  Branch (1107:7): [True: 0, False: 0]
  ------------------
 1108|      0|		    if (CUR == '*') {
  ------------------
  |  |  704|      0|#define CUR (*ctxt->cur)
  ------------------
  |  Branch (1108:11): [True: 0, False: 0]
  ------------------
 1109|      0|			NEXT;
  ------------------
  |  |  714|      0|#define NEXT ((*ctxt->cur) ?  ctxt->cur++: ctxt->cur)
  |  |  ------------------
  |  |  |  Branch (714:15): [True: 0, False: 0]
  |  |  ------------------
  ------------------
 1110|      0|			PUSH(XML_OP_ALL, NULL, NULL);
  ------------------
  |  |  718|      0|    if (xmlPatternAdd(ctxt, ctxt->comp, (op), (val), (val2))) goto error;
  |  |  ------------------
  |  |  |  Branch (718:9): [True: 0, False: 0]
  |  |  ------------------
  ------------------
 1111|      0|			return;
 1112|      0|		    } else {
 1113|      0|			ERROR(NULL, NULL, NULL,
 1114|      0|			    "xmlCompileStepPattern : QName expected\n");
 1115|      0|			ctxt->error = 1;
 1116|      0|			goto error;
 1117|      0|		    }
 1118|      0|		}
 1119|      0|		if (CUR == ':') {
  ------------------
  |  |  704|      0|#define CUR (*ctxt->cur)
  ------------------
  |  Branch (1119:7): [True: 0, False: 0]
  ------------------
 1120|      0|		    xmlChar *prefix = name;
 1121|      0|		    int i;
 1122|       |
 1123|      0|		    NEXT;
  ------------------
  |  |  714|      0|#define NEXT ((*ctxt->cur) ?  ctxt->cur++: ctxt->cur)
  |  |  ------------------
  |  |  |  Branch (714:15): [True: 0, False: 0]
  |  |  ------------------
  ------------------
 1124|      0|		    if (IS_BLANK_CH(CUR)) {
  ------------------
  |  |  151|      0|#define IS_BLANK_CH(c)  xmlIsBlank_ch(c)
  |  |  ------------------
  |  |  |  |   88|      0|#define xmlIsBlank_ch(c)	(((c) == 0x20) || \
  |  |  |  |  ------------------
  |  |  |  |  |  Branch (88:27): [True: 0, False: 0]
  |  |  |  |  ------------------
  |  |  |  |   89|      0|				 ((0x9 <= (c)) && ((c) <= 0xa)) || \
  |  |  |  |  ------------------
  |  |  |  |  |  Branch (89:7): [True: 0, False: 0]
  |  |  |  |  |  Branch (89:23): [True: 0, False: 0]
  |  |  |  |  ------------------
  |  |  |  |   90|      0|				 ((c) == 0xd))
  |  |  |  |  ------------------
  |  |  |  |  |  Branch (90:6): [True: 0, False: 0]
  |  |  |  |  ------------------
  |  |  ------------------
  ------------------
 1125|      0|			ERROR5(NULL, NULL, NULL, "Invalid QName.\n", NULL);
 1126|      0|			ctxt->error = 1;
 1127|      0|			goto error;
 1128|      0|		    }
 1129|       |		    /*
 1130|       |		    * This is a namespace match
 1131|       |		    */
 1132|      0|		    token = xmlPatScanName(ctxt);
 1133|      0|		    if ((prefix[0] == 'x') &&
  ------------------
  |  Branch (1133:11): [True: 0, False: 0]
  ------------------
 1134|      0|			(prefix[1] == 'm') &&
  ------------------
  |  Branch (1134:4): [True: 0, False: 0]
  ------------------
 1135|      0|			(prefix[2] == 'l') &&
  ------------------
  |  Branch (1135:4): [True: 0, False: 0]
  ------------------
 1136|      0|			(prefix[3] == 0))
  ------------------
  |  Branch (1136:4): [True: 0, False: 0]
  ------------------
 1137|      0|		    {
 1138|      0|			XML_PAT_COPY_NSNAME(ctxt, URL, XML_XML_NAMESPACE)
  ------------------
  |  |   80|      0|    if ((c)->comp->dict) \
  |  |  ------------------
  |  |  |  Branch (80:9): [True: 0, False: 0]
  |  |  ------------------
  |  |   81|      0|	r = (xmlChar *) xmlDictLookup((c)->comp->dict, BAD_CAST nsname, -1); \
  |  |  ------------------
  |  |  |  |   35|      0|#define BAD_CAST (xmlChar *)
  |  |  ------------------
  |  |   82|      0|    else r = xmlStrdup(BAD_CAST nsname);
  |  |  ------------------
  |  |  |  |   35|      0|#define BAD_CAST (xmlChar *)
  |  |  ------------------
  ------------------
 1139|      0|		    } else {
 1140|      0|			for (i = 0;i < ctxt->nb_namespaces;i++) {
  ------------------
  |  Branch (1140:15): [True: 0, False: 0]
  ------------------
 1141|      0|			    if (xmlStrEqual(ctxt->namespaces[2 * i + 1], prefix)) {
  ------------------
  |  Branch (1141:12): [True: 0, False: 0]
  ------------------
 1142|      0|				XML_PAT_COPY_NSNAME(ctxt, URL, ctxt->namespaces[2 * i])
  ------------------
  |  |   80|      0|    if ((c)->comp->dict) \
  |  |  ------------------
  |  |  |  Branch (80:9): [True: 0, False: 0]
  |  |  ------------------
  |  |   81|      0|	r = (xmlChar *) xmlDictLookup((c)->comp->dict, BAD_CAST nsname, -1); \
  |  |  ------------------
  |  |  |  |   35|      0|#define BAD_CAST (xmlChar *)
  |  |  ------------------
  |  |   82|      0|    else r = xmlStrdup(BAD_CAST nsname);
  |  |  ------------------
  |  |  |  |   35|      0|#define BAD_CAST (xmlChar *)
  |  |  ------------------
  ------------------
 1143|      0|				break;
 1144|      0|			    }
 1145|      0|			}
 1146|      0|			if (i >= ctxt->nb_namespaces) {
  ------------------
  |  Branch (1146:8): [True: 0, False: 0]
  ------------------
 1147|      0|			    ERROR5(NULL, NULL, NULL,
 1148|      0|				"xmlCompileStepPattern : no namespace bound "
 1149|      0|				"to prefix %s\n", prefix);
 1150|      0|			    ctxt->error = 1;
 1151|      0|			    goto error;
 1152|      0|			}
 1153|      0|		    }
 1154|      0|		    XML_PAT_FREE_STRING(ctxt, prefix);
  ------------------
  |  |   84|      0|#define XML_PAT_FREE_STRING(c, r) if ((c)->comp->dict == NULL) xmlFree(r);
  |  |  ------------------
  |  |  |  Branch (84:39): [True: 0, False: 0]
  |  |  ------------------
  ------------------
 1155|      0|		    name = NULL;
 1156|      0|		    if (token == NULL) {
  ------------------
  |  Branch (1156:11): [True: 0, False: 0]
  ------------------
 1157|      0|			if (CUR == '*') {
  ------------------
  |  |  704|      0|#define CUR (*ctxt->cur)
  ------------------
  |  Branch (1157:8): [True: 0, False: 0]
  ------------------
 1158|      0|			    NEXT;
  ------------------
  |  |  714|      0|#define NEXT ((*ctxt->cur) ?  ctxt->cur++: ctxt->cur)
  |  |  ------------------
  |  |  |  Branch (714:15): [True: 0, False: 0]
  |  |  ------------------
  ------------------
 1159|      0|			    PUSH(XML_OP_NS, URL, NULL);
  ------------------
  |  |  718|      0|    if (xmlPatternAdd(ctxt, ctxt->comp, (op), (val), (val2))) goto error;
  |  |  ------------------
  |  |  |  Branch (718:9): [True: 0, False: 0]
  |  |  ------------------
  ------------------
 1160|      0|			} else {
 1161|      0|			    ERROR(NULL, NULL, NULL,
 1162|      0|				"xmlCompileStepPattern : Name expected\n");
 1163|      0|			    ctxt->error = 1;
 1164|      0|			    goto error;
 1165|      0|			}
 1166|      0|		    } else {
 1167|      0|			PUSH(XML_OP_CHILD, token, URL);
  ------------------
  |  |  718|      0|    if (xmlPatternAdd(ctxt, ctxt->comp, (op), (val), (val2))) goto error;
  |  |  ------------------
  |  |  |  Branch (718:9): [True: 0, False: 0]
  |  |  ------------------
  ------------------
 1168|      0|		    }
 1169|      0|		} else
 1170|      0|		    PUSH(XML_OP_CHILD, name, NULL);
  ------------------
  |  |  718|      0|    if (xmlPatternAdd(ctxt, ctxt->comp, (op), (val), (val2))) goto error;
  |  |  ------------------
  |  |  |  Branch (718:9): [True: 0, False: 0]
  |  |  ------------------
  ------------------
 1171|      0|		return;
 1172|      0|	    } else if (xmlStrEqual(name, (const xmlChar *) "attribute")) {
  ------------------
  |  Branch (1172:17): [True: 0, False: 0]
  ------------------
 1173|      0|		XML_PAT_FREE_STRING(ctxt, name)
  ------------------
  |  |   84|      0|#define XML_PAT_FREE_STRING(c, r) if ((c)->comp->dict == NULL) xmlFree(r);
  |  |  ------------------
  |  |  |  Branch (84:39): [True: 0, False: 0]
  |  |  ------------------
  ------------------
 1174|      0|		name = NULL;
 1175|      0|		if (XML_STREAM_XS_IDC_SEL(ctxt->comp)) {
  ------------------
  |  |   75|      0|#define XML_STREAM_XS_IDC_SEL(c) ((c)->flags & XML_PATTERN_XSSEL)
  |  |  ------------------
  |  |  |  Branch (75:34): [True: 0, False: 0]
  |  |  ------------------
  ------------------
 1176|      0|		    ERROR5(NULL, NULL, NULL,
 1177|      0|			"Unexpected attribute axis in '%s'.\n", ctxt->base);
 1178|      0|		    ctxt->error = 1;
 1179|      0|		    goto error;
 1180|      0|		}
 1181|      0|		xmlCompileAttributeTest(ctxt);
 1182|      0|		if (ctxt->error != 0)
  ------------------
  |  Branch (1182:7): [True: 0, False: 0]
  ------------------
 1183|      0|		    goto error;
 1184|      0|		return;
 1185|      0|	    } else {
 1186|      0|		ERROR5(NULL, NULL, NULL,
 1187|      0|		    "The 'element' or 'attribute' axis is expected.\n", NULL);
 1188|      0|		ctxt->error = 1;
 1189|      0|		goto error;
 1190|      0|	    }
 1191|      0|	}
 1192|     80|    } else if (CUR == '*') {
  ------------------
  |  |  704|     80|#define CUR (*ctxt->cur)
  ------------------
  |  Branch (1192:16): [True: 0, False: 80]
  ------------------
 1193|      0|        if (name != NULL) {
  ------------------
  |  Branch (1193:13): [True: 0, False: 0]
  ------------------
 1194|      0|	    ctxt->error = 1;
 1195|      0|	    goto error;
 1196|      0|	}
 1197|      0|	NEXT;
  ------------------
  |  |  714|      0|#define NEXT ((*ctxt->cur) ?  ctxt->cur++: ctxt->cur)
  |  |  ------------------
  |  |  |  Branch (714:15): [True: 0, False: 0]
  |  |  ------------------
  ------------------
 1198|      0|	PUSH(XML_OP_ALL, token, NULL);
  ------------------
  |  |  718|      0|    if (xmlPatternAdd(ctxt, ctxt->comp, (op), (val), (val2))) goto error;
  |  |  ------------------
  |  |  |  Branch (718:9): [True: 0, False: 0]
  |  |  ------------------
  ------------------
 1199|     80|    } else {
 1200|     80|	PUSH(XML_OP_ELEM, name, NULL);
  ------------------
  |  |  718|     80|    if (xmlPatternAdd(ctxt, ctxt->comp, (op), (val), (val2))) goto error;
  |  |  ------------------
  |  |  |  Branch (718:9): [True: 0, False: 80]
  |  |  ------------------
  ------------------
 1201|     80|    }
 1202|     80|    return;
 1203|     80|error:
 1204|      0|    if (URL != NULL)
  ------------------
  |  Branch (1204:9): [True: 0, False: 0]
  ------------------
 1205|      0|	XML_PAT_FREE_STRING(ctxt, URL)
  ------------------
  |  |   84|      0|#define XML_PAT_FREE_STRING(c, r) if ((c)->comp->dict == NULL) xmlFree(r);
  |  |  ------------------
  |  |  |  Branch (84:39): [True: 0, False: 0]
  |  |  ------------------
  ------------------
 1206|      0|    if (token != NULL)
  ------------------
  |  Branch (1206:9): [True: 0, False: 0]
  ------------------
 1207|      0|	XML_PAT_FREE_STRING(ctxt, token)
  ------------------
  |  |   84|      0|#define XML_PAT_FREE_STRING(c, r) if ((c)->comp->dict == NULL) xmlFree(r);
  |  |  ------------------
  |  |  |  Branch (84:39): [True: 0, False: 0]
  |  |  ------------------
  ------------------
 1208|      0|    if (name != NULL)
  ------------------
  |  Branch (1208:9): [True: 0, False: 0]
  ------------------
 1209|      0|	XML_PAT_FREE_STRING(ctxt, name)
  ------------------
  |  |   84|      0|#define XML_PAT_FREE_STRING(c, r) if ((c)->comp->dict == NULL) xmlFree(r);
  |  |  ------------------
  |  |  |  Branch (84:39): [True: 0, False: 0]
  |  |  ------------------
  ------------------
 1210|      0|}
pattern.c:xmlPatScanNCName:
  848|     80|xmlPatScanNCName(xmlPatParserContextPtr ctxt) {
  849|     80|    const xmlChar *q, *cur;
  850|     80|    xmlChar *ret = NULL;
  851|     80|    int val, len;
  852|       |
  853|     80|    SKIP_BLANKS;
  ------------------
  |  |  711|     80|    while (IS_BLANK_CH(CUR)) NEXT
  |  |  ------------------
  |  |  |  |  714|      0|#define NEXT ((*ctxt->cur) ?  ctxt->cur++: ctxt->cur)
  |  |  |  |  ------------------
  |  |  |  |  |  Branch (714:15): [True: 0, False: 0]
  |  |  |  |  ------------------
  |  |  ------------------
  ------------------
  854|       |
  855|     80|    cur = q = CUR_PTR;
  ------------------
  |  |  708|     80|#define CUR_PTR ctxt->cur
  ------------------
  856|     80|    val = xmlStringCurrentChar(NULL, cur, &len);
  857|     80|    if (!IS_LETTER(val) && (val != '_'))
  ------------------
  |  |  240|    160|#define IS_LETTER(c) (IS_BASECHAR(c) || IS_IDEOGRAPHIC(c))
  |  |  ------------------
  |  |  |  |  161|     80|#define IS_BASECHAR(c) xmlIsBaseCharQ(c)
  |  |  |  |  ------------------
  |  |  |  |  |  |   76|    160|#define xmlIsBaseCharQ(c)	(((c) < 0x100) ? \
  |  |  |  |  |  |  ------------------
  |  |  |  |  |  |  |  Branch (76:27): [True: 80, False: 0]
  |  |  |  |  |  |  |  Branch (76:28): [True: 80, False: 0]
  |  |  |  |  |  |  ------------------
  |  |  |  |  |  |   77|    160|				 xmlIsBaseChar_ch((c)) : \
  |  |  |  |  |  |  ------------------
  |  |  |  |  |  |  |  |   64|     80|#define xmlIsBaseChar_ch(c)	(((0x41 <= (c)) && ((c) <= 0x5a)) || \
  |  |  |  |  |  |  |  |  ------------------
  |  |  |  |  |  |  |  |  |  Branch (64:31): [True: 80, False: 0]
  |  |  |  |  |  |  |  |  |  Branch (64:48): [True: 0, False: 80]
  |  |  |  |  |  |  |  |  ------------------
  |  |  |  |  |  |  |  |   65|     80|				 ((0x61 <= (c)) && ((c) <= 0x7a)) || \
  |  |  |  |  |  |  |  |  ------------------
  |  |  |  |  |  |  |  |  |  Branch (65:7): [True: 80, False: 0]
  |  |  |  |  |  |  |  |  |  Branch (65:24): [True: 80, False: 0]
  |  |  |  |  |  |  |  |  ------------------
  |  |  |  |  |  |  |  |   66|     80|				 ((0xc0 <= (c)) && ((c) <= 0xd6)) || \
  |  |  |  |  |  |  |  |  ------------------
  |  |  |  |  |  |  |  |  |  Branch (66:7): [True: 0, False: 0]
  |  |  |  |  |  |  |  |  |  Branch (66:24): [True: 0, False: 0]
  |  |  |  |  |  |  |  |  ------------------
  |  |  |  |  |  |  |  |   67|     80|				 ((0xd8 <= (c)) && ((c) <= 0xf6)) || \
  |  |  |  |  |  |  |  |  ------------------
  |  |  |  |  |  |  |  |  |  Branch (67:7): [True: 0, False: 0]
  |  |  |  |  |  |  |  |  |  Branch (67:24): [True: 0, False: 0]
  |  |  |  |  |  |  |  |  ------------------
  |  |  |  |  |  |  |  |   68|     80|				  (0xf8 <= (c)))
  |  |  |  |  |  |  |  |  ------------------
  |  |  |  |  |  |  |  |  |  Branch (68:7): [True: 0, False: 0]
  |  |  |  |  |  |  |  |  ------------------
  |  |  |  |  |  |  ------------------
  |  |  |  |  |  |   78|    160|				 xmlCharInRange((c), &xmlIsBaseCharGroup))
  |  |  |  |  ------------------
  |  |  ------------------
  |  |               #define IS_LETTER(c) (IS_BASECHAR(c) || IS_IDEOGRAPHIC(c))
  |  |  ------------------
  |  |  |  |  229|      0|#define IS_IDEOGRAPHIC(c) xmlIsIdeographicQ(c)
  |  |  |  |  ------------------
  |  |  |  |  |  |  184|      0|#define xmlIsIdeographicQ(c)	(((c) < 0x100) ? \
  |  |  |  |  |  |  ------------------
  |  |  |  |  |  |  |  Branch (184:30): [True: 0, False: 0]
  |  |  |  |  |  |  |  Branch (184:31): [True: 0, False: 0]
  |  |  |  |  |  |  ------------------
  |  |  |  |  |  |  185|      0|				 0 :\
  |  |  |  |  |  |  186|      0|				(((0x4e00 <= (c)) && ((c) <= 0x9fa5)) || \
  |  |  |  |  |  |  ------------------
  |  |  |  |  |  |  |  Branch (186:7): [True: 0, False: 0]
  |  |  |  |  |  |  |  Branch (186:26): [True: 0, False: 0]
  |  |  |  |  |  |  ------------------
  |  |  |  |  |  |  187|      0|				 ((c) == 0x3007) || \
  |  |  |  |  |  |  ------------------
  |  |  |  |  |  |  |  Branch (187:6): [True: 0, False: 0]
  |  |  |  |  |  |  ------------------
  |  |  |  |  |  |  188|      0|				 ((0x3021 <= (c)) && ((c) <= 0x3029))))
  |  |  |  |  |  |  ------------------
  |  |  |  |  |  |  |  Branch (188:7): [True: 0, False: 0]
  |  |  |  |  |  |  |  Branch (188:26): [True: 0, False: 0]
  |  |  |  |  |  |  ------------------
  |  |  |  |  ------------------
  |  |  ------------------
  ------------------
  |  Branch (857:28): [True: 0, False: 0]
  ------------------
  858|      0|	return(NULL);
  859|       |
  860|    284|    while ((IS_LETTER(val)) || (IS_DIGIT(val)) ||
  ------------------
  |  |  240|    284|#define IS_LETTER(c) (IS_BASECHAR(c) || IS_IDEOGRAPHIC(c))
  |  |  ------------------
  |  |  |  |  161|    284|#define IS_BASECHAR(c) xmlIsBaseCharQ(c)
  |  |  |  |  ------------------
  |  |  |  |  |  |   76|    568|#define xmlIsBaseCharQ(c)	(((c) < 0x100) ? \
  |  |  |  |  |  |  ------------------
  |  |  |  |  |  |  |  Branch (76:27): [True: 80, False: 204]
  |  |  |  |  |  |  |  Branch (76:28): [True: 284, False: 0]
  |  |  |  |  |  |  ------------------
  |  |  |  |  |  |   77|    568|				 xmlIsBaseChar_ch((c)) : \
  |  |  |  |  |  |  ------------------
  |  |  |  |  |  |  |  |   64|    284|#define xmlIsBaseChar_ch(c)	(((0x41 <= (c)) && ((c) <= 0x5a)) || \
  |  |  |  |  |  |  |  |  ------------------
  |  |  |  |  |  |  |  |  |  Branch (64:31): [True: 80, False: 204]
  |  |  |  |  |  |  |  |  |  Branch (64:48): [True: 0, False: 80]
  |  |  |  |  |  |  |  |  ------------------
  |  |  |  |  |  |  |  |   65|    284|				 ((0x61 <= (c)) && ((c) <= 0x7a)) || \
  |  |  |  |  |  |  |  |  ------------------
  |  |  |  |  |  |  |  |  |  Branch (65:7): [True: 80, False: 204]
  |  |  |  |  |  |  |  |  |  Branch (65:24): [True: 80, False: 0]
  |  |  |  |  |  |  |  |  ------------------
  |  |  |  |  |  |  |  |   66|    284|				 ((0xc0 <= (c)) && ((c) <= 0xd6)) || \
  |  |  |  |  |  |  |  |  ------------------
  |  |  |  |  |  |  |  |  |  Branch (66:7): [True: 0, False: 204]
  |  |  |  |  |  |  |  |  |  Branch (66:24): [True: 0, False: 0]
  |  |  |  |  |  |  |  |  ------------------
  |  |  |  |  |  |  |  |   67|    284|				 ((0xd8 <= (c)) && ((c) <= 0xf6)) || \
  |  |  |  |  |  |  |  |  ------------------
  |  |  |  |  |  |  |  |  |  Branch (67:7): [True: 0, False: 204]
  |  |  |  |  |  |  |  |  |  Branch (67:24): [True: 0, False: 0]
  |  |  |  |  |  |  |  |  ------------------
  |  |  |  |  |  |  |  |   68|    284|				  (0xf8 <= (c)))
  |  |  |  |  |  |  |  |  ------------------
  |  |  |  |  |  |  |  |  |  Branch (68:7): [True: 0, False: 204]
  |  |  |  |  |  |  |  |  ------------------
  |  |  |  |  |  |  ------------------
  |  |  |  |  |  |   78|    568|				 xmlCharInRange((c), &xmlIsBaseCharGroup))
  |  |  |  |  ------------------
  |  |  ------------------
  |  |               #define IS_LETTER(c) (IS_BASECHAR(c) || IS_IDEOGRAPHIC(c))
  |  |  ------------------
  |  |  |  |  229|    204|#define IS_IDEOGRAPHIC(c) xmlIsIdeographicQ(c)
  |  |  |  |  ------------------
  |  |  |  |  |  |  184|    204|#define xmlIsIdeographicQ(c)	(((c) < 0x100) ? \
  |  |  |  |  |  |  ------------------
  |  |  |  |  |  |  |  Branch (184:30): [True: 0, False: 204]
  |  |  |  |  |  |  |  Branch (184:31): [True: 204, False: 0]
  |  |  |  |  |  |  ------------------
  |  |  |  |  |  |  185|    204|				 0 :\
  |  |  |  |  |  |  186|    204|				(((0x4e00 <= (c)) && ((c) <= 0x9fa5)) || \
  |  |  |  |  |  |  ------------------
  |  |  |  |  |  |  |  Branch (186:7): [True: 0, False: 0]
  |  |  |  |  |  |  |  Branch (186:26): [True: 0, False: 0]
  |  |  |  |  |  |  ------------------
  |  |  |  |  |  |  187|      0|				 ((c) == 0x3007) || \
  |  |  |  |  |  |  ------------------
  |  |  |  |  |  |  |  Branch (187:6): [True: 0, False: 0]
  |  |  |  |  |  |  ------------------
  |  |  |  |  |  |  188|      0|				 ((0x3021 <= (c)) && ((c) <= 0x3029))))
  |  |  |  |  |  |  ------------------
  |  |  |  |  |  |  |  Branch (188:7): [True: 0, False: 0]
  |  |  |  |  |  |  |  Branch (188:26): [True: 0, False: 0]
  |  |  |  |  |  |  ------------------
  |  |  |  |  ------------------
  |  |  ------------------
  ------------------
                  while ((IS_LETTER(val)) || (IS_DIGIT(val)) ||
  ------------------
  |  |  171|    204|#define IS_DIGIT(c) xmlIsDigitQ(c)
  |  |  ------------------
  |  |  |  |  152|    204|#define xmlIsDigitQ(c)		(((c) < 0x100) ? \
  |  |  |  |  ------------------
  |  |  |  |  |  Branch (152:26): [True: 204, False: 0]
  |  |  |  |  ------------------
  |  |  |  |  153|    204|				 xmlIsDigit_ch((c)) : \
  |  |  |  |  ------------------
  |  |  |  |  |  |  144|    204|#define xmlIsDigit_ch(c)	(((0x30 <= (c)) && ((c) <= 0x39)))
  |  |  |  |  |  |  ------------------
  |  |  |  |  |  |  |  Branch (144:28): [True: 124, False: 80]
  |  |  |  |  |  |  |  Branch (144:45): [True: 124, False: 0]
  |  |  |  |  |  |  ------------------
  |  |  |  |  ------------------
  |  |  |  |  154|    204|				 xmlCharInRange((c), &xmlIsDigitGroup))
  |  |  ------------------
  ------------------
  |  Branch (860:32): [True: 124, False: 80]
  ------------------
  861|    284|           (val == '.') || (val == '-') ||
  ------------------
  |  Branch (861:12): [True: 0, False: 80]
  |  Branch (861:28): [True: 0, False: 80]
  ------------------
  862|    284|	   (val == '_') ||
  ------------------
  |  Branch (862:5): [True: 0, False: 80]
  ------------------
  863|    284|	   (IS_COMBINING(val)) ||
  ------------------
  |  |  189|     80|#define IS_COMBINING(c) xmlIsCombiningQ(c)
  |  |  ------------------
  |  |  |  |  132|     80|#define xmlIsCombiningQ(c)	(((c) < 0x100) ? \
  |  |  |  |  ------------------
  |  |  |  |  |  Branch (132:29): [True: 80, False: 0]
  |  |  |  |  ------------------
  |  |  |  |  133|     80|				 0 : \
  |  |  |  |  134|     80|				 xmlCharInRange((c), &xmlIsCombiningGroup))
  |  |  ------------------
  ------------------
  |  Branch (863:5): [True: 0, False: 80]
  ------------------
  864|    284|	   (IS_EXTENDER(val))) {
  ------------------
  |  |  210|     80|#define IS_EXTENDER(c) xmlIsExtenderQ(c)
  |  |  ------------------
  |  |  |  |  172|     80|#define xmlIsExtenderQ(c)	(((c) < 0x100) ? \
  |  |  |  |  ------------------
  |  |  |  |  |  Branch (172:28): [True: 80, False: 0]
  |  |  |  |  ------------------
  |  |  |  |  173|     80|				 xmlIsExtender_ch((c)) : \
  |  |  |  |  ------------------
  |  |  |  |  |  |  164|     80|#define xmlIsExtender_ch(c)	(((c) == 0xb7))
  |  |  |  |  ------------------
  |  |  |  |  174|     80|				 xmlCharInRange((c), &xmlIsExtenderGroup))
  |  |  ------------------
  ------------------
  |  Branch (864:5): [True: 0, False: 80]
  ------------------
  865|    204|	cur += len;
  866|    204|	val = xmlStringCurrentChar(NULL, cur, &len);
  867|    204|    }
  868|     80|    if (ctxt->dict)
  ------------------
  |  Branch (868:9): [True: 0, False: 80]
  ------------------
  869|      0|	ret = (xmlChar *) xmlDictLookup(ctxt->dict, q, cur - q);
  870|     80|    else
  871|     80|	ret = xmlStrndup(q, cur - q);
  872|     80|    CUR_PTR = cur;
  ------------------
  |  |  708|     80|#define CUR_PTR ctxt->cur
  ------------------
  873|     80|    return(ret);
  874|     80|}
pattern.c:xmlCompilePathPattern:
 1222|     80|xmlCompilePathPattern(xmlPatParserContextPtr ctxt) {
 1223|     80|    SKIP_BLANKS;
  ------------------
  |  |  711|     80|    while (IS_BLANK_CH(CUR)) NEXT
  |  |  ------------------
  |  |  |  |  714|      0|#define NEXT ((*ctxt->cur) ?  ctxt->cur++: ctxt->cur)
  |  |  |  |  ------------------
  |  |  |  |  |  Branch (714:15): [True: 0, False: 0]
  |  |  |  |  ------------------
  |  |  ------------------
  ------------------
 1224|     80|    if (CUR == '/') {
  ------------------
  |  |  704|     80|#define CUR (*ctxt->cur)
  ------------------
  |  Branch (1224:9): [True: 80, False: 0]
  ------------------
 1225|     80|        ctxt->comp->flags |= PAT_FROM_ROOT;
  ------------------
  |  |  158|     80|#define PAT_FROM_ROOT	(1<<8)
  ------------------
 1226|     80|    } else if ((CUR == '.') || (ctxt->comp->flags & XML_PATTERN_NOTPATTERN)) {
  ------------------
  |  |  704|      0|#define CUR (*ctxt->cur)
  ------------------
                  } else if ((CUR == '.') || (ctxt->comp->flags & XML_PATTERN_NOTPATTERN)) {
  ------------------
  |  |   68|      0|#define XML_PATTERN_NOTPATTERN  (XML_PATTERN_XPATH | \
  |  |   69|      0|				 XML_PATTERN_XSSEL | \
  |  |   70|      0|				 XML_PATTERN_XSFIELD)
  ------------------
  |  Branch (1226:16): [True: 0, False: 0]
  |  Branch (1226:32): [True: 0, False: 0]
  ------------------
 1227|      0|        ctxt->comp->flags |= PAT_FROM_CUR;
  ------------------
  |  |  159|      0|#define PAT_FROM_CUR	(1<<9)
  ------------------
 1228|      0|    }
 1229|       |
 1230|     80|    if ((CUR == '/') && (NXT(1) == '/')) {
  ------------------
  |  |  704|     80|#define CUR (*ctxt->cur)
  ------------------
                  if ((CUR == '/') && (NXT(1) == '/')) {
  ------------------
  |  |  706|     80|#define NXT(val) ctxt->cur[(val)]
  ------------------
  |  Branch (1230:9): [True: 80, False: 0]
  |  Branch (1230:25): [True: 76, False: 4]
  ------------------
 1231|     76|	PUSH(XML_OP_ANCESTOR, NULL, NULL);
  ------------------
  |  |  718|     76|    if (xmlPatternAdd(ctxt, ctxt->comp, (op), (val), (val2))) goto error;
  |  |  ------------------
  |  |  |  Branch (718:9): [True: 0, False: 76]
  |  |  ------------------
  ------------------
 1232|     76|	NEXT;
  ------------------
  |  |  714|     76|#define NEXT ((*ctxt->cur) ?  ctxt->cur++: ctxt->cur)
  |  |  ------------------
  |  |  |  Branch (714:15): [True: 76, False: 0]
  |  |  ------------------
  ------------------
 1233|     76|	NEXT;
  ------------------
  |  |  714|     76|#define NEXT ((*ctxt->cur) ?  ctxt->cur++: ctxt->cur)
  |  |  ------------------
  |  |  |  Branch (714:15): [True: 76, False: 0]
  |  |  ------------------
  ------------------
 1234|     76|    } else if ((CUR == '.') && (NXT(1) == '/') && (NXT(2) == '/')) {
  ------------------
  |  |  704|      4|#define CUR (*ctxt->cur)
  ------------------
                  } else if ((CUR == '.') && (NXT(1) == '/') && (NXT(2) == '/')) {
  ------------------
  |  |  706|      0|#define NXT(val) ctxt->cur[(val)]
  ------------------
                  } else if ((CUR == '.') && (NXT(1) == '/') && (NXT(2) == '/')) {
  ------------------
  |  |  706|      0|#define NXT(val) ctxt->cur[(val)]
  ------------------
  |  Branch (1234:16): [True: 0, False: 4]
  |  Branch (1234:32): [True: 0, False: 0]
  |  Branch (1234:51): [True: 0, False: 0]
  ------------------
 1235|      0|	PUSH(XML_OP_ANCESTOR, NULL, NULL);
  ------------------
  |  |  718|      0|    if (xmlPatternAdd(ctxt, ctxt->comp, (op), (val), (val2))) goto error;
  |  |  ------------------
  |  |  |  Branch (718:9): [True: 0, False: 0]
  |  |  ------------------
  ------------------
 1236|      0|	NEXT;
  ------------------
  |  |  714|      0|#define NEXT ((*ctxt->cur) ?  ctxt->cur++: ctxt->cur)
  |  |  ------------------
  |  |  |  Branch (714:15): [True: 0, False: 0]
  |  |  ------------------
  ------------------
 1237|      0|	NEXT;
  ------------------
  |  |  714|      0|#define NEXT ((*ctxt->cur) ?  ctxt->cur++: ctxt->cur)
  |  |  ------------------
  |  |  |  Branch (714:15): [True: 0, False: 0]
  |  |  ------------------
  ------------------
 1238|      0|	NEXT;
  ------------------
  |  |  714|      0|#define NEXT ((*ctxt->cur) ?  ctxt->cur++: ctxt->cur)
  |  |  ------------------
  |  |  |  Branch (714:15): [True: 0, False: 0]
  |  |  ------------------
  ------------------
 1239|       |	/* Check for incompleteness. */
 1240|      0|	SKIP_BLANKS;
  ------------------
  |  |  711|      0|    while (IS_BLANK_CH(CUR)) NEXT
  |  |  ------------------
  |  |  |  |  714|      0|#define NEXT ((*ctxt->cur) ?  ctxt->cur++: ctxt->cur)
  |  |  |  |  ------------------
  |  |  |  |  |  Branch (714:15): [True: 0, False: 0]
  |  |  |  |  ------------------
  |  |  ------------------
  ------------------
 1241|      0|	if (CUR == 0) {
  ------------------
  |  |  704|      0|#define CUR (*ctxt->cur)
  ------------------
  |  Branch (1241:6): [True: 0, False: 0]
  ------------------
 1242|      0|	    ERROR5(NULL, NULL, NULL,
 1243|      0|	       "Incomplete expression '%s'.\n", ctxt->base);
 1244|      0|	    ctxt->error = 1;
 1245|      0|	    goto error;
 1246|      0|	}
 1247|      0|    }
 1248|     80|    if (CUR == '@') {
  ------------------
  |  |  704|     80|#define CUR (*ctxt->cur)
  ------------------
  |  Branch (1248:9): [True: 0, False: 80]
  ------------------
 1249|      0|	NEXT;
  ------------------
  |  |  714|      0|#define NEXT ((*ctxt->cur) ?  ctxt->cur++: ctxt->cur)
  |  |  ------------------
  |  |  |  Branch (714:15): [True: 0, False: 0]
  |  |  ------------------
  ------------------
 1250|      0|	xmlCompileAttributeTest(ctxt);
 1251|      0|	SKIP_BLANKS;
  ------------------
  |  |  711|      0|    while (IS_BLANK_CH(CUR)) NEXT
  |  |  ------------------
  |  |  |  |  714|      0|#define NEXT ((*ctxt->cur) ?  ctxt->cur++: ctxt->cur)
  |  |  |  |  ------------------
  |  |  |  |  |  Branch (714:15): [True: 0, False: 0]
  |  |  |  |  ------------------
  |  |  ------------------
  ------------------
 1252|       |	/* TODO: check for incompleteness */
 1253|      0|	if (CUR != 0) {
  ------------------
  |  |  704|      0|#define CUR (*ctxt->cur)
  ------------------
  |  Branch (1253:6): [True: 0, False: 0]
  ------------------
 1254|      0|	    xmlCompileStepPattern(ctxt);
 1255|      0|	    if (ctxt->error != 0)
  ------------------
  |  Branch (1255:10): [True: 0, False: 0]
  ------------------
 1256|      0|		goto error;
 1257|      0|	}
 1258|     80|    } else {
 1259|     80|        if (CUR == '/') {
  ------------------
  |  |  704|     80|#define CUR (*ctxt->cur)
  ------------------
  |  Branch (1259:13): [True: 4, False: 76]
  ------------------
 1260|      4|	    PUSH(XML_OP_ROOT, NULL, NULL);
  ------------------
  |  |  718|      4|    if (xmlPatternAdd(ctxt, ctxt->comp, (op), (val), (val2))) goto error;
  |  |  ------------------
  |  |  |  Branch (718:9): [True: 0, False: 4]
  |  |  ------------------
  ------------------
 1261|      4|	    NEXT;
  ------------------
  |  |  714|      4|#define NEXT ((*ctxt->cur) ?  ctxt->cur++: ctxt->cur)
  |  |  ------------------
  |  |  |  Branch (714:15): [True: 4, False: 0]
  |  |  ------------------
  ------------------
 1262|       |	    /* Check for incompleteness. */
 1263|      4|	    SKIP_BLANKS;
  ------------------
  |  |  711|      4|    while (IS_BLANK_CH(CUR)) NEXT
  |  |  ------------------
  |  |  |  |  714|      4|#define NEXT ((*ctxt->cur) ?  ctxt->cur++: ctxt->cur)
  |  |  |  |  ------------------
  |  |  |  |  |  Branch (714:15): [True: 0, False: 0]
  |  |  |  |  ------------------
  |  |  ------------------
  ------------------
 1264|      4|	    if (CUR == 0) {
  ------------------
  |  |  704|      4|#define CUR (*ctxt->cur)
  ------------------
  |  Branch (1264:10): [True: 0, False: 4]
  ------------------
 1265|      0|		ERROR5(NULL, NULL, NULL,
 1266|      0|		    "Incomplete expression '%s'.\n", ctxt->base);
 1267|      0|		ctxt->error = 1;
 1268|      0|		goto error;
 1269|      0|	    }
 1270|      4|	}
 1271|     80|	xmlCompileStepPattern(ctxt);
 1272|     80|	if (ctxt->error != 0)
  ------------------
  |  Branch (1272:6): [True: 0, False: 80]
  ------------------
 1273|      0|	    goto error;
 1274|     80|	SKIP_BLANKS;
  ------------------
  |  |  711|     80|    while (IS_BLANK_CH(CUR)) NEXT
  |  |  ------------------
  |  |  |  |  714|     80|#define NEXT ((*ctxt->cur) ?  ctxt->cur++: ctxt->cur)
  |  |  |  |  ------------------
  |  |  |  |  |  Branch (714:15): [True: 0, False: 0]
  |  |  |  |  ------------------
  |  |  ------------------
  ------------------
 1275|     80|	while (CUR == '/') {
  ------------------
  |  |  704|     80|#define CUR (*ctxt->cur)
  ------------------
  |  Branch (1275:9): [True: 0, False: 80]
  ------------------
 1276|      0|	    if (NXT(1) == '/') {
  ------------------
  |  |  706|      0|#define NXT(val) ctxt->cur[(val)]
  ------------------
  |  Branch (1276:10): [True: 0, False: 0]
  ------------------
 1277|      0|	        PUSH(XML_OP_ANCESTOR, NULL, NULL);
  ------------------
  |  |  718|      0|    if (xmlPatternAdd(ctxt, ctxt->comp, (op), (val), (val2))) goto error;
  |  |  ------------------
  |  |  |  Branch (718:9): [True: 0, False: 0]
  |  |  ------------------
  ------------------
 1278|      0|		NEXT;
  ------------------
  |  |  714|      0|#define NEXT ((*ctxt->cur) ?  ctxt->cur++: ctxt->cur)
  |  |  ------------------
  |  |  |  Branch (714:15): [True: 0, False: 0]
  |  |  ------------------
  ------------------
 1279|      0|		NEXT;
  ------------------
  |  |  714|      0|#define NEXT ((*ctxt->cur) ?  ctxt->cur++: ctxt->cur)
  |  |  ------------------
  |  |  |  Branch (714:15): [True: 0, False: 0]
  |  |  ------------------
  ------------------
 1280|      0|		SKIP_BLANKS;
  ------------------
  |  |  711|      0|    while (IS_BLANK_CH(CUR)) NEXT
  |  |  ------------------
  |  |  |  |  714|      0|#define NEXT ((*ctxt->cur) ?  ctxt->cur++: ctxt->cur)
  |  |  |  |  ------------------
  |  |  |  |  |  Branch (714:15): [True: 0, False: 0]
  |  |  |  |  ------------------
  |  |  ------------------
  ------------------
 1281|      0|		xmlCompileStepPattern(ctxt);
 1282|      0|		if (ctxt->error != 0)
  ------------------
  |  Branch (1282:7): [True: 0, False: 0]
  ------------------
 1283|      0|		    goto error;
 1284|      0|	    } else {
 1285|      0|	        PUSH(XML_OP_PARENT, NULL, NULL);
  ------------------
  |  |  718|      0|    if (xmlPatternAdd(ctxt, ctxt->comp, (op), (val), (val2))) goto error;
  |  |  ------------------
  |  |  |  Branch (718:9): [True: 0, False: 0]
  |  |  ------------------
  ------------------
 1286|      0|		NEXT;
  ------------------
  |  |  714|      0|#define NEXT ((*ctxt->cur) ?  ctxt->cur++: ctxt->cur)
  |  |  ------------------
  |  |  |  Branch (714:15): [True: 0, False: 0]
  |  |  ------------------
  ------------------
 1287|      0|		SKIP_BLANKS;
  ------------------
  |  |  711|      0|    while (IS_BLANK_CH(CUR)) NEXT
  |  |  ------------------
  |  |  |  |  714|      0|#define NEXT ((*ctxt->cur) ?  ctxt->cur++: ctxt->cur)
  |  |  |  |  ------------------
  |  |  |  |  |  Branch (714:15): [True: 0, False: 0]
  |  |  |  |  ------------------
  |  |  ------------------
  ------------------
 1288|      0|		if (CUR == 0) {
  ------------------
  |  |  704|      0|#define CUR (*ctxt->cur)
  ------------------
  |  Branch (1288:7): [True: 0, False: 0]
  ------------------
 1289|      0|		    ERROR5(NULL, NULL, NULL,
 1290|      0|		    "Incomplete expression '%s'.\n", ctxt->base);
 1291|      0|		    ctxt->error = 1;
 1292|      0|		    goto error;
 1293|      0|		}
 1294|      0|		xmlCompileStepPattern(ctxt);
 1295|      0|		if (ctxt->error != 0)
  ------------------
  |  Branch (1295:7): [True: 0, False: 0]
  ------------------
 1296|      0|		    goto error;
 1297|      0|	    }
 1298|      0|	}
 1299|     80|    }
 1300|     80|    if (CUR != 0) {
  ------------------
  |  |  704|     80|#define CUR (*ctxt->cur)
  ------------------
  |  Branch (1300:9): [True: 0, False: 80]
  ------------------
 1301|      0|	ERROR5(NULL, NULL, NULL,
 1302|      0|	       "Failed to compile pattern %s\n", ctxt->base);
 1303|      0|	ctxt->error = 1;
 1304|      0|    }
 1305|     80|error:
 1306|     80|    return;
 1307|     80|}
pattern.c:xmlFreePatParserContext:
  328|     80|xmlFreePatParserContext(xmlPatParserContextPtr ctxt) {
  329|     80|    if (ctxt == NULL)
  ------------------
  |  Branch (329:9): [True: 0, False: 80]
  ------------------
  330|      0|	return;
  331|     80|    memset(ctxt, -1, sizeof(xmlPatParserContext));
  332|     80|    xmlFree(ctxt);
  333|     80|}
pattern.c:xmlStreamCompile:
 1511|     80|xmlStreamCompile(xmlPatternPtr comp) {
 1512|     80|    xmlStreamCompPtr stream;
 1513|     80|    int i, s = 0, root = 0, flags = 0, prevs = -1;
 1514|     80|    xmlStepOp step;
 1515|       |
 1516|     80|    if ((comp == NULL) || (comp->steps == NULL))
  ------------------
  |  Branch (1516:9): [True: 0, False: 80]
  |  Branch (1516:27): [True: 0, False: 80]
  ------------------
 1517|      0|        return(-1);
 1518|       |    /*
 1519|       |     * special case for .
 1520|       |     */
 1521|     80|    if ((comp->nbStep == 1) &&
  ------------------
  |  Branch (1521:9): [True: 0, False: 80]
  ------------------
 1522|     80|        (comp->steps[0].op == XML_OP_ELEM) &&
  ------------------
  |  Branch (1522:9): [True: 0, False: 0]
  ------------------
 1523|     80|	(comp->steps[0].value == NULL) &&
  ------------------
  |  Branch (1523:2): [True: 0, False: 0]
  ------------------
 1524|     80|	(comp->steps[0].value2 == NULL)) {
  ------------------
  |  Branch (1524:2): [True: 0, False: 0]
  ------------------
 1525|      0|	stream = xmlNewStreamComp(0);
 1526|      0|	if (stream == NULL)
  ------------------
  |  Branch (1526:6): [True: 0, False: 0]
  ------------------
 1527|      0|	    return(-1);
 1528|       |	/* Note that the stream will have no steps in this case. */
 1529|      0|	stream->flags |= XML_STREAM_FINAL_IS_ANY_NODE;
  ------------------
  |  |   58|      0|#define XML_STREAM_FINAL_IS_ANY_NODE 1<<14
  ------------------
 1530|      0|	comp->stream = stream;
 1531|      0|	return(0);
 1532|      0|    }
 1533|       |
 1534|     80|    stream = xmlNewStreamComp((comp->nbStep / 2) + 1);
 1535|     80|    if (stream == NULL)
  ------------------
  |  Branch (1535:9): [True: 0, False: 80]
  ------------------
 1536|      0|        return(-1);
 1537|     80|    if (comp->dict != NULL) {
  ------------------
  |  Branch (1537:9): [True: 0, False: 80]
  ------------------
 1538|      0|        stream->dict = comp->dict;
 1539|      0|	xmlDictReference(stream->dict);
 1540|      0|    }
 1541|       |
 1542|     80|    i = 0;
 1543|     80|    if (comp->flags & PAT_FROM_ROOT)
  ------------------
  |  |  158|     80|#define PAT_FROM_ROOT	(1<<8)
  ------------------
  |  Branch (1543:9): [True: 80, False: 0]
  ------------------
 1544|     80|	stream->flags |= XML_STREAM_FROM_ROOT;
  ------------------
  |  |   59|     80|#define XML_STREAM_FROM_ROOT 1<<15
  ------------------
 1545|       |
 1546|    240|    for (;i < comp->nbStep;i++) {
  ------------------
  |  Branch (1546:11): [True: 160, False: 80]
  ------------------
 1547|    160|	step = comp->steps[i];
 1548|    160|        switch (step.op) {
  ------------------
  |  Branch (1548:17): [True: 0, False: 160]
  ------------------
 1549|      0|	    case XML_OP_END:
  ------------------
  |  Branch (1549:6): [True: 0, False: 160]
  ------------------
 1550|      0|	        break;
 1551|      4|	    case XML_OP_ROOT:
  ------------------
  |  Branch (1551:6): [True: 4, False: 156]
  ------------------
 1552|      4|	        if (i != 0)
  ------------------
  |  Branch (1552:14): [True: 0, False: 4]
  ------------------
 1553|      0|		    goto error;
 1554|      4|		root = 1;
 1555|      4|		break;
 1556|      0|	    case XML_OP_NS:
  ------------------
  |  Branch (1556:6): [True: 0, False: 160]
  ------------------
 1557|      0|		s = xmlStreamCompAddStep(stream, NULL, step.value,
 1558|      0|		    XML_ELEMENT_NODE, flags);
 1559|      0|		if (s < 0)
  ------------------
  |  Branch (1559:7): [True: 0, False: 0]
  ------------------
 1560|      0|		    goto error;
 1561|      0|		prevs = s;
 1562|      0|		flags = 0;
 1563|      0|		break;
 1564|      0|	    case XML_OP_ATTR:
  ------------------
  |  Branch (1564:6): [True: 0, False: 160]
  ------------------
 1565|      0|		flags |= XML_STREAM_STEP_ATTR;
  ------------------
  |  |   48|      0|#define XML_STREAM_STEP_ATTR	8
  ------------------
 1566|      0|		prevs = -1;
 1567|      0|		s = xmlStreamCompAddStep(stream,
 1568|      0|		    step.value, step.value2, XML_ATTRIBUTE_NODE, flags);
 1569|      0|		flags = 0;
 1570|      0|		if (s < 0)
  ------------------
  |  Branch (1570:7): [True: 0, False: 0]
  ------------------
 1571|      0|		    goto error;
 1572|      0|		break;
 1573|     80|	    case XML_OP_ELEM:
  ------------------
  |  Branch (1573:6): [True: 80, False: 80]
  ------------------
 1574|     80|	        if ((step.value == NULL) && (step.value2 == NULL)) {
  ------------------
  |  Branch (1574:14): [True: 0, False: 80]
  |  Branch (1574:38): [True: 0, False: 0]
  ------------------
 1575|       |		    /*
 1576|       |		    * We have a "." or "self::node()" here.
 1577|       |		    * Eliminate redundant self::node() tests like in "/./."
 1578|       |		    * or "//./"
 1579|       |		    * The only case we won't eliminate is "//.", i.e. if
 1580|       |		    * self::node() is the last node test and we had
 1581|       |		    * continuation somewhere beforehand.
 1582|       |		    */
 1583|      0|		    if ((comp->nbStep == i + 1) &&
  ------------------
  |  Branch (1583:11): [True: 0, False: 0]
  ------------------
 1584|      0|			(flags & XML_STREAM_STEP_DESC)) {
  ------------------
  |  |   45|      0|#define XML_STREAM_STEP_DESC	1
  ------------------
  |  Branch (1584:4): [True: 0, False: 0]
  ------------------
 1585|       |			/*
 1586|       |			* Mark the special case where the expression resolves
 1587|       |			* to any type of node.
 1588|       |			*/
 1589|      0|			if (comp->nbStep == i + 1) {
  ------------------
  |  Branch (1589:8): [True: 0, False: 0]
  ------------------
 1590|      0|			    stream->flags |= XML_STREAM_FINAL_IS_ANY_NODE;
  ------------------
  |  |   58|      0|#define XML_STREAM_FINAL_IS_ANY_NODE 1<<14
  ------------------
 1591|      0|			}
 1592|      0|			flags |= XML_STREAM_STEP_NODE;
  ------------------
  |  |   49|      0|#define XML_STREAM_STEP_NODE	16
  ------------------
 1593|      0|			s = xmlStreamCompAddStep(stream, NULL, NULL,
 1594|      0|			    XML_STREAM_ANY_NODE, flags);
  ------------------
  |  |   66|      0|#define XML_STREAM_ANY_NODE 100
  ------------------
 1595|      0|			if (s < 0)
  ------------------
  |  Branch (1595:8): [True: 0, False: 0]
  ------------------
 1596|      0|			    goto error;
 1597|      0|			flags = 0;
 1598|       |			/*
 1599|       |			* If there was a previous step, mark it to be added to
 1600|       |			* the result node-set; this is needed since only
 1601|       |			* the last step will be marked as "final" and only
 1602|       |			* "final" nodes are added to the resulting set.
 1603|       |			*/
 1604|      0|			if (prevs != -1) {
  ------------------
  |  Branch (1604:8): [True: 0, False: 0]
  ------------------
 1605|      0|			    stream->steps[prevs].flags |= XML_STREAM_STEP_IN_SET;
  ------------------
  |  |   50|      0|#define XML_STREAM_STEP_IN_SET	32
  ------------------
 1606|      0|			    prevs = -1;
 1607|      0|			}
 1608|      0|			break;
 1609|       |
 1610|      0|		    } else {
 1611|       |			/* Just skip this one. */
 1612|      0|			continue;
 1613|      0|		    }
 1614|      0|		}
 1615|       |		/* An element node. */
 1616|     80|	        s = xmlStreamCompAddStep(stream, step.value, step.value2,
 1617|     80|		    XML_ELEMENT_NODE, flags);
 1618|     80|		if (s < 0)
  ------------------
  |  Branch (1618:7): [True: 0, False: 80]
  ------------------
 1619|      0|		    goto error;
 1620|     80|		prevs = s;
 1621|     80|		flags = 0;
 1622|     80|		break;
 1623|      0|	    case XML_OP_CHILD:
  ------------------
  |  Branch (1623:6): [True: 0, False: 160]
  ------------------
 1624|       |		/* An element node child. */
 1625|      0|	        s = xmlStreamCompAddStep(stream, step.value, step.value2,
 1626|      0|		    XML_ELEMENT_NODE, flags);
 1627|      0|		if (s < 0)
  ------------------
  |  Branch (1627:7): [True: 0, False: 0]
  ------------------
 1628|      0|		    goto error;
 1629|      0|		prevs = s;
 1630|      0|		flags = 0;
 1631|      0|		break;
 1632|      0|	    case XML_OP_ALL:
  ------------------
  |  Branch (1632:6): [True: 0, False: 160]
  ------------------
 1633|      0|	        s = xmlStreamCompAddStep(stream, NULL, NULL,
 1634|      0|		    XML_ELEMENT_NODE, flags);
 1635|      0|		if (s < 0)
  ------------------
  |  Branch (1635:7): [True: 0, False: 0]
  ------------------
 1636|      0|		    goto error;
 1637|      0|		prevs = s;
 1638|      0|		flags = 0;
 1639|      0|		break;
 1640|      0|	    case XML_OP_PARENT:
  ------------------
  |  Branch (1640:6): [True: 0, False: 160]
  ------------------
 1641|      0|	        break;
 1642|     76|	    case XML_OP_ANCESTOR:
  ------------------
  |  Branch (1642:6): [True: 76, False: 84]
  ------------------
 1643|       |		/* Skip redundant continuations. */
 1644|     76|		if (flags & XML_STREAM_STEP_DESC)
  ------------------
  |  |   45|     76|#define XML_STREAM_STEP_DESC	1
  ------------------
  |  Branch (1644:7): [True: 0, False: 76]
  ------------------
 1645|      0|		    break;
 1646|     76|	        flags |= XML_STREAM_STEP_DESC;
  ------------------
  |  |   45|     76|#define XML_STREAM_STEP_DESC	1
  ------------------
 1647|       |		/*
 1648|       |		* Mark the expression as having "//".
 1649|       |		*/
 1650|     76|		if ((stream->flags & XML_STREAM_DESC) == 0)
  ------------------
  |  |   60|     76|#define XML_STREAM_DESC 1<<16
  ------------------
  |  Branch (1650:7): [True: 76, False: 0]
  ------------------
 1651|     76|		    stream->flags |= XML_STREAM_DESC;
  ------------------
  |  |   60|     76|#define XML_STREAM_DESC 1<<16
  ------------------
 1652|     76|		break;
 1653|    160|	}
 1654|    160|    }
 1655|     80|    if ((! root) && (comp->flags & XML_PATTERN_NOTPATTERN) == 0) {
  ------------------
  |  |   68|     76|#define XML_PATTERN_NOTPATTERN  (XML_PATTERN_XPATH | \
  |  |   69|     76|				 XML_PATTERN_XSSEL | \
  |  |   70|     76|				 XML_PATTERN_XSFIELD)
  ------------------
  |  Branch (1655:9): [True: 76, False: 4]
  |  Branch (1655:21): [True: 0, False: 76]
  ------------------
 1656|       |	/*
 1657|       |	* If this should behave like a real pattern, we will mark
 1658|       |	* the first step as having "//", to be reentrant on every
 1659|       |	* tree level.
 1660|       |	*/
 1661|      0|	if ((stream->flags & XML_STREAM_DESC) == 0)
  ------------------
  |  |   60|      0|#define XML_STREAM_DESC 1<<16
  ------------------
  |  Branch (1661:6): [True: 0, False: 0]
  ------------------
 1662|      0|	    stream->flags |= XML_STREAM_DESC;
  ------------------
  |  |   60|      0|#define XML_STREAM_DESC 1<<16
  ------------------
 1663|       |
 1664|      0|	if (stream->nbStep > 0) {
  ------------------
  |  Branch (1664:6): [True: 0, False: 0]
  ------------------
 1665|      0|	    if ((stream->steps[0].flags & XML_STREAM_STEP_DESC) == 0)
  ------------------
  |  |   45|      0|#define XML_STREAM_STEP_DESC	1
  ------------------
  |  Branch (1665:10): [True: 0, False: 0]
  ------------------
 1666|      0|		stream->steps[0].flags |= XML_STREAM_STEP_DESC;
  ------------------
  |  |   45|      0|#define XML_STREAM_STEP_DESC	1
  ------------------
 1667|      0|	}
 1668|      0|    }
 1669|     80|    if (stream->nbStep <= s)
  ------------------
  |  Branch (1669:9): [True: 0, False: 80]
  ------------------
 1670|      0|	goto error;
 1671|     80|    stream->steps[s].flags |= XML_STREAM_STEP_FINAL;
  ------------------
  |  |   46|     80|#define XML_STREAM_STEP_FINAL	2
  ------------------
 1672|     80|    if (root)
  ------------------
  |  Branch (1672:9): [True: 4, False: 76]
  ------------------
 1673|      4|	stream->steps[0].flags |= XML_STREAM_STEP_ROOT;
  ------------------
  |  |   47|      4|#define XML_STREAM_STEP_ROOT	4
  ------------------
 1674|     80|    comp->stream = stream;
 1675|     80|    return(0);
 1676|      0|error:
 1677|      0|    xmlFreeStreamComp(stream);
 1678|      0|    return(0);
 1679|     80|}
pattern.c:xmlNewStreamComp:
 1425|     80|xmlNewStreamComp(int size) {
 1426|     80|    xmlStreamCompPtr cur;
 1427|       |
 1428|     80|    if (size < 4)
  ------------------
  |  Branch (1428:9): [True: 80, False: 0]
  ------------------
 1429|     80|        size  = 4;
 1430|       |
 1431|     80|    cur = (xmlStreamCompPtr) xmlMalloc(sizeof(xmlStreamComp));
 1432|     80|    if (cur == NULL) {
  ------------------
  |  Branch (1432:9): [True: 0, False: 80]
  ------------------
 1433|      0|	ERROR(NULL, NULL, NULL,
 1434|      0|		"xmlNewStreamComp: malloc failed\n");
 1435|      0|	return(NULL);
 1436|      0|    }
 1437|     80|    memset(cur, 0, sizeof(xmlStreamComp));
 1438|     80|    cur->steps = (xmlStreamStepPtr) xmlMalloc(size * sizeof(xmlStreamStep));
 1439|     80|    if (cur->steps == NULL) {
  ------------------
  |  Branch (1439:9): [True: 0, False: 80]
  ------------------
 1440|      0|	xmlFree(cur);
 1441|      0|	ERROR(NULL, NULL, NULL,
 1442|      0|	      "xmlNewStreamComp: malloc failed\n");
 1443|      0|	return(NULL);
 1444|      0|    }
 1445|     80|    cur->nbStep = 0;
 1446|     80|    cur->maxStep = size;
 1447|     80|    return(cur);
 1448|     80|}
pattern.c:xmlStreamCompAddStep:
 1480|     80|                     const xmlChar *ns, int nodeType, int flags) {
 1481|     80|    xmlStreamStepPtr cur;
 1482|       |
 1483|     80|    if (comp->nbStep >= comp->maxStep) {
  ------------------
  |  Branch (1483:9): [True: 0, False: 80]
  ------------------
 1484|      0|	cur = (xmlStreamStepPtr) xmlRealloc(comp->steps,
 1485|      0|				 comp->maxStep * 2 * sizeof(xmlStreamStep));
 1486|      0|	if (cur == NULL) {
  ------------------
  |  Branch (1486:6): [True: 0, False: 0]
  ------------------
 1487|      0|	    ERROR(NULL, NULL, NULL,
 1488|      0|		  "xmlNewStreamComp: malloc failed\n");
 1489|      0|	    return(-1);
 1490|      0|	}
 1491|      0|	comp->steps = cur;
 1492|      0|        comp->maxStep *= 2;
 1493|      0|    }
 1494|     80|    cur = &comp->steps[comp->nbStep++];
 1495|     80|    cur->flags = flags;
 1496|     80|    cur->name = name;
 1497|     80|    cur->ns = ns;
 1498|     80|    cur->nodeType = nodeType;
 1499|     80|    return(comp->nbStep - 1);
 1500|     80|}
pattern.c:xmlReversePattern:
  408|     80|xmlReversePattern(xmlPatternPtr comp) {
  409|     80|    int i, j;
  410|       |
  411|       |    /*
  412|       |     * remove the leading // for //a or .//a
  413|       |     */
  414|     80|    if ((comp->nbStep > 0) && (comp->steps[0].op == XML_OP_ANCESTOR)) {
  ------------------
  |  Branch (414:9): [True: 80, False: 0]
  |  Branch (414:31): [True: 76, False: 4]
  ------------------
  415|    152|        for (i = 0, j = 1;j < comp->nbStep;i++,j++) {
  ------------------
  |  Branch (415:27): [True: 76, False: 76]
  ------------------
  416|     76|	    comp->steps[i].value = comp->steps[j].value;
  417|     76|	    comp->steps[i].value2 = comp->steps[j].value2;
  418|     76|	    comp->steps[i].op = comp->steps[j].op;
  419|     76|	}
  420|     76|	comp->nbStep--;
  421|     76|    }
  422|     80|    if (comp->nbStep >= comp->maxStep) {
  ------------------
  |  Branch (422:9): [True: 0, False: 80]
  ------------------
  423|      0|        xmlStepOpPtr temp;
  424|      0|	temp = (xmlStepOpPtr) xmlRealloc(comp->steps, comp->maxStep * 2 *
  425|      0|	                                 sizeof(xmlStepOp));
  426|      0|        if (temp == NULL) {
  ------------------
  |  Branch (426:13): [True: 0, False: 0]
  ------------------
  427|      0|	    ERROR(ctxt, NULL, NULL,
  428|      0|			     "xmlReversePattern: realloc failed\n");
  429|      0|	    return (-1);
  430|      0|	}
  431|      0|	comp->steps = temp;
  432|      0|	comp->maxStep *= 2;
  433|      0|    }
  434|     80|    i = 0;
  435|     80|    j = comp->nbStep - 1;
  436|     84|    while (j > i) {
  ------------------
  |  Branch (436:12): [True: 4, False: 80]
  ------------------
  437|      4|	register const xmlChar *tmp;
  438|      4|	register xmlPatOp op;
  439|      4|	tmp = comp->steps[i].value;
  440|      4|	comp->steps[i].value = comp->steps[j].value;
  441|      4|	comp->steps[j].value = tmp;
  442|      4|	tmp = comp->steps[i].value2;
  443|      4|	comp->steps[i].value2 = comp->steps[j].value2;
  444|      4|	comp->steps[j].value2 = tmp;
  445|      4|	op = comp->steps[i].op;
  446|      4|	comp->steps[i].op = comp->steps[j].op;
  447|      4|	comp->steps[j].op = op;
  448|      4|	j--;
  449|      4|	i++;
  450|      4|    }
  451|     80|    comp->steps[comp->nbStep].value = NULL;
  452|     80|    comp->steps[comp->nbStep].value2 = NULL;
  453|     80|    comp->steps[comp->nbStep++].op = XML_OP_END;
  454|     80|    return(0);
  455|     80|}
pattern.c:xmlFreeStreamComp:
 1457|     80|xmlFreeStreamComp(xmlStreamCompPtr comp) {
 1458|     80|    if (comp != NULL) {
  ------------------
  |  Branch (1458:9): [True: 80, False: 0]
  ------------------
 1459|     80|        if (comp->steps != NULL)
  ------------------
  |  Branch (1459:13): [True: 80, False: 0]
  ------------------
 1460|     80|	    xmlFree(comp->steps);
 1461|     80|	if (comp->dict != NULL)
  ------------------
  |  Branch (1461:6): [True: 0, False: 80]
  ------------------
 1462|      0|	    xmlDictFree(comp->dict);
 1463|     80|        xmlFree(comp);
 1464|     80|    }
 1465|     80|}
pattern.c:xmlNewStreamCtxt:
 1690|     80|xmlNewStreamCtxt(xmlStreamCompPtr stream) {
 1691|     80|    xmlStreamCtxtPtr cur;
 1692|       |
 1693|     80|    cur = (xmlStreamCtxtPtr) xmlMalloc(sizeof(xmlStreamCtxt));
 1694|     80|    if (cur == NULL) {
  ------------------
  |  Branch (1694:9): [True: 0, False: 80]
  ------------------
 1695|      0|	ERROR(NULL, NULL, NULL,
 1696|      0|		"xmlNewStreamCtxt: malloc failed\n");
 1697|      0|	return(NULL);
 1698|      0|    }
 1699|     80|    memset(cur, 0, sizeof(xmlStreamCtxt));
 1700|     80|    cur->states = (int *) xmlMalloc(4 * 2 * sizeof(int));
 1701|     80|    if (cur->states == NULL) {
  ------------------
  |  Branch (1701:9): [True: 0, False: 80]
  ------------------
 1702|      0|	xmlFree(cur);
 1703|      0|	ERROR(NULL, NULL, NULL,
 1704|      0|	      "xmlNewStreamCtxt: malloc failed\n");
 1705|      0|	return(NULL);
 1706|      0|    }
 1707|     80|    cur->nbState = 0;
 1708|     80|    cur->maxState = 4;
 1709|     80|    cur->level = 0;
 1710|     80|    cur->comp = stream;
 1711|     80|    cur->blockLevel = -1;
 1712|     80|    return(cur);
 1713|     80|}

xmlInitMutex:
  129|      8|{
  130|      8|#ifdef HAVE_POSIX_THREADS
  131|      8|    if (XML_IS_NEVER_THREADED() == 0)
  ------------------
  |  |   85|      8|#define XML_IS_NEVER_THREADED() (!libxml_is_threaded)
  ------------------
  |  Branch (131:9): [True: 8, False: 0]
  ------------------
  132|      8|        pthread_mutex_init(&mutex->lock, NULL);
  133|       |#elif defined HAVE_WIN32_THREADS
  134|       |    InitializeCriticalSection(&mutex->cs);
  135|       |#else
  136|       |    (void) mutex;
  137|       |#endif
  138|      8|}
xmlMutexLock:
  202|  1.45k|{
  203|  1.45k|    if (tok == NULL)
  ------------------
  |  Branch (203:9): [True: 0, False: 1.45k]
  ------------------
  204|      0|        return;
  205|  1.45k|#ifdef HAVE_POSIX_THREADS
  206|       |    /*
  207|       |     * This assumes that __libc_single_threaded won't change while the
  208|       |     * lock is held.
  209|       |     */
  210|  1.45k|    if (XML_IS_THREADED() != 0)
  ------------------
  |  |   84|  1.45k|#define XML_IS_THREADED() libxml_is_threaded
  ------------------
  |  Branch (210:9): [True: 1.45k, False: 0]
  ------------------
  211|  1.45k|        pthread_mutex_lock(&tok->lock);
  212|       |#elif defined HAVE_WIN32_THREADS
  213|       |    EnterCriticalSection(&tok->cs);
  214|       |#endif
  215|       |
  216|  1.45k|}
xmlMutexUnlock:
  226|  1.45k|{
  227|  1.45k|    if (tok == NULL)
  ------------------
  |  Branch (227:9): [True: 0, False: 1.45k]
  ------------------
  228|      0|        return;
  229|  1.45k|#ifdef HAVE_POSIX_THREADS
  230|  1.45k|    if (XML_IS_THREADED() != 0)
  ------------------
  |  |   84|  1.45k|#define XML_IS_THREADED() libxml_is_threaded
  ------------------
  |  Branch (230:9): [True: 1.45k, False: 0]
  ------------------
  231|  1.45k|        pthread_mutex_unlock(&tok->lock);
  232|       |#elif defined HAVE_WIN32_THREADS
  233|       |    LeaveCriticalSection(&tok->cs);
  234|       |#endif
  235|  1.45k|}
xmlNewRMutex:
  249|      2|{
  250|      2|    xmlRMutexPtr tok;
  251|       |
  252|      2|    if ((tok = malloc(sizeof(xmlRMutex))) == NULL)
  ------------------
  |  Branch (252:9): [True: 0, False: 2]
  ------------------
  253|      0|        return (NULL);
  254|      2|#ifdef HAVE_POSIX_THREADS
  255|      2|    if (XML_IS_NEVER_THREADED() == 0) {
  ------------------
  |  |   85|      2|#define XML_IS_NEVER_THREADED() (!libxml_is_threaded)
  ------------------
  |  Branch (255:9): [True: 2, False: 0]
  ------------------
  256|      2|        pthread_mutex_init(&tok->lock, NULL);
  257|      2|        tok->held = 0;
  258|      2|        tok->waiters = 0;
  259|      2|        pthread_cond_init(&tok->cv, NULL);
  260|      2|    }
  261|       |#elif defined HAVE_WIN32_THREADS
  262|       |    InitializeCriticalSection(&tok->cs);
  263|       |#endif
  264|      2|    return (tok);
  265|      2|}
xmlRMutexLock:
  298|      2|{
  299|      2|    if (tok == NULL)
  ------------------
  |  Branch (299:9): [True: 0, False: 2]
  ------------------
  300|      0|        return;
  301|      2|#ifdef HAVE_POSIX_THREADS
  302|      2|    if (XML_IS_THREADED() == 0)
  ------------------
  |  |   84|      2|#define XML_IS_THREADED() libxml_is_threaded
  ------------------
  |  Branch (302:9): [True: 0, False: 2]
  ------------------
  303|      0|        return;
  304|       |
  305|      2|    pthread_mutex_lock(&tok->lock);
  306|      2|    if (tok->held) {
  ------------------
  |  Branch (306:9): [True: 0, False: 2]
  ------------------
  307|      0|        if (pthread_equal(tok->tid, pthread_self())) {
  ------------------
  |  Branch (307:13): [True: 0, False: 0]
  ------------------
  308|      0|            tok->held++;
  309|      0|            pthread_mutex_unlock(&tok->lock);
  310|      0|            return;
  311|      0|        } else {
  312|      0|            tok->waiters++;
  313|      0|            while (tok->held)
  ------------------
  |  Branch (313:20): [True: 0, False: 0]
  ------------------
  314|      0|                pthread_cond_wait(&tok->cv, &tok->lock);
  315|      0|            tok->waiters--;
  316|      0|        }
  317|      0|    }
  318|      2|    tok->tid = pthread_self();
  319|      2|    tok->held = 1;
  320|      2|    pthread_mutex_unlock(&tok->lock);
  321|       |#elif defined HAVE_WIN32_THREADS
  322|       |    EnterCriticalSection(&tok->cs);
  323|       |#endif
  324|      2|}
xmlRMutexUnlock:
  334|      2|{
  335|      2|    if (tok == NULL)
  ------------------
  |  Branch (335:9): [True: 0, False: 2]
  ------------------
  336|      0|        return;
  337|      2|#ifdef HAVE_POSIX_THREADS
  338|      2|    if (XML_IS_THREADED() == 0)
  ------------------
  |  |   84|      2|#define XML_IS_THREADED() libxml_is_threaded
  ------------------
  |  Branch (338:9): [True: 0, False: 2]
  ------------------
  339|      0|        return;
  340|       |
  341|      2|    pthread_mutex_lock(&tok->lock);
  342|      2|    tok->held--;
  343|      2|    if (tok->held == 0) {
  ------------------
  |  Branch (343:9): [True: 2, False: 0]
  ------------------
  344|      2|        if (tok->waiters)
  ------------------
  |  Branch (344:13): [True: 0, False: 2]
  ------------------
  345|      0|            pthread_cond_signal(&tok->cv);
  346|      2|        memset(&tok->tid, 0, sizeof(tok->tid));
  347|      2|    }
  348|      2|    pthread_mutex_unlock(&tok->lock);
  349|       |#elif defined HAVE_WIN32_THREADS
  350|       |    LeaveCriticalSection(&tok->cs);
  351|       |#endif
  352|      2|}
xmlInitParser:
  569|  1.76k|xmlInitParser(void) {
  570|       |    /*
  571|       |     * Note that the initialization code must not make memory allocations.
  572|       |     */
  573|  1.76k|    if (xmlParserInitialized != 0)
  ------------------
  |  Branch (573:9): [True: 1.76k, False: 2]
  ------------------
  574|  1.76k|        return;
  575|       |
  576|      2|    xmlGlobalInitMutexLock();
  577|       |
  578|      2|    if (xmlParserInnerInitialized == 0) {
  ------------------
  |  Branch (578:9): [True: 2, False: 0]
  ------------------
  579|       |#if defined(_WIN32) && \
  580|       |    !defined(LIBXML_THREAD_ALLOC_ENABLED) && \
  581|       |    (!defined(LIBXML_STATIC) || defined(LIBXML_STATIC_FOR_DLL))
  582|       |        if (xmlFree == free)
  583|       |            atexit(xmlCleanupParser);
  584|       |#endif
  585|       |
  586|      2|        xmlInitMemoryInternal(); /* Should come second */
  587|      2|        xmlInitGlobalsInternal();
  588|      2|        xmlInitRandom();
  589|      2|        xmlInitDictInternal();
  590|      2|        xmlInitEncodingInternal();
  591|      2|#if defined(LIBXML_XPATH_ENABLED) || defined(LIBXML_SCHEMAS_ENABLED)
  592|      2|        xmlInitXPathInternal();
  593|      2|#endif
  594|       |
  595|      2|        xmlRegisterDefaultInputCallbacks();
  596|      2|#ifdef LIBXML_OUTPUT_ENABLED
  597|      2|        xmlRegisterDefaultOutputCallbacks();
  598|      2|#endif /* LIBXML_OUTPUT_ENABLED */
  599|       |
  600|      2|        xmlParserInnerInitialized = 1;
  601|      2|    }
  602|       |
  603|      2|    xmlGlobalInitMutexUnlock();
  604|       |
  605|      2|    xmlParserInitialized = 1;
  606|      2|}
threads.c:xmlGlobalInitMutexLock:
  462|      2|xmlGlobalInitMutexLock(void) {
  463|      2|#ifdef HAVE_POSIX_THREADS
  464|       |
  465|      2|#ifdef XML_PTHREAD_WEAK
  466|       |    /*
  467|       |     * This is somewhat unreliable since libpthread could be loaded
  468|       |     * later with dlopen() and threads could be created. But it's
  469|       |     * long-standing behavior and hard to work around.
  470|       |     */
  471|      2|    if (libxml_is_threaded == -1)
  ------------------
  |  Branch (471:9): [True: 2, False: 0]
  ------------------
  472|      2|        libxml_is_threaded =
  473|      2|            (pthread_mutex_init != NULL) &&
  ------------------
  |  Branch (473:13): [True: 2, False: 0]
  ------------------
  474|      2|            (pthread_mutex_destroy != NULL) &&
  ------------------
  |  Branch (474:13): [True: 2, False: 0]
  ------------------
  475|      2|            (pthread_mutex_lock != NULL) &&
  ------------------
  |  Branch (475:13): [True: 2, False: 0]
  ------------------
  476|      2|            (pthread_mutex_unlock != NULL) &&
  ------------------
  |  Branch (476:13): [True: 2, False: 0]
  ------------------
  477|      2|            (pthread_cond_init != NULL) &&
  ------------------
  |  Branch (477:13): [True: 2, False: 0]
  ------------------
  478|      2|            (pthread_cond_destroy != NULL) &&
  ------------------
  |  Branch (478:13): [True: 2, False: 0]
  ------------------
  479|      2|            (pthread_cond_wait != NULL) &&
  ------------------
  |  Branch (479:13): [True: 2, False: 0]
  ------------------
  480|       |            /*
  481|       |             * pthread_equal can be inline, resuting in -Waddress warnings.
  482|       |             * Let's assume it's available if all the other functions are.
  483|       |             */
  484|       |            /* (pthread_equal != NULL) && */
  485|      2|            (pthread_self != NULL) &&
  ------------------
  |  Branch (485:13): [True: 2, False: 0]
  ------------------
  486|      2|            (pthread_cond_signal != NULL);
  ------------------
  |  Branch (486:13): [True: 2, False: 0]
  ------------------
  487|      2|#endif
  488|       |
  489|       |    /* The mutex is statically initialized, so we just lock it. */
  490|      2|    if (XML_IS_THREADED() != 0)
  ------------------
  |  |   84|      2|#define XML_IS_THREADED() libxml_is_threaded
  ------------------
  |  Branch (490:9): [True: 2, False: 0]
  ------------------
  491|      2|        pthread_mutex_lock(&global_init_lock);
  492|       |
  493|       |#elif defined HAVE_WIN32_THREADS
  494|       |
  495|       |    LPCRITICAL_SECTION cs;
  496|       |
  497|       |    /* Create a new critical section */
  498|       |    if (global_init_lock == NULL) {
  499|       |        cs = malloc(sizeof(CRITICAL_SECTION));
  500|       |        if (cs == NULL) {
  501|       |            xmlGenericError(xmlGenericErrorContext,
  502|       |                            "xmlGlobalInitMutexLock: out of memory\n");
  503|       |            return;
  504|       |        }
  505|       |        InitializeCriticalSection(cs);
  506|       |
  507|       |        /* Swap it into the global_init_lock */
  508|       |#ifdef InterlockedCompareExchangePointer
  509|       |        InterlockedCompareExchangePointer((void **) &global_init_lock,
  510|       |                                          cs, NULL);
  511|       |#else /* Use older void* version */
  512|       |        InterlockedCompareExchange((void **) &global_init_lock,
  513|       |                                   (void *) cs, NULL);
  514|       |#endif /* InterlockedCompareExchangePointer */
  515|       |
  516|       |        /* If another thread successfully recorded its critical
  517|       |         * section in the global_init_lock then discard the one
  518|       |         * allocated by this thread. */
  519|       |        if (global_init_lock != cs) {
  520|       |            DeleteCriticalSection(cs);
  521|       |            free(cs);
  522|       |        }
  523|       |    }
  524|       |
  525|       |    /* Lock the chosen critical section */
  526|       |    EnterCriticalSection(global_init_lock);
  527|       |
  528|       |#endif
  529|      2|}
threads.c:xmlGlobalInitMutexUnlock:
  532|      2|xmlGlobalInitMutexUnlock(void) {
  533|      2|#ifdef HAVE_POSIX_THREADS
  534|      2|    if (XML_IS_THREADED() != 0)
  ------------------
  |  |   84|      2|#define XML_IS_THREADED() libxml_is_threaded
  ------------------
  |  Branch (534:9): [True: 2, False: 0]
  ------------------
  535|      2|        pthread_mutex_unlock(&global_init_lock);
  536|       |#elif defined HAVE_WIN32_THREADS
  537|       |    if (global_init_lock != NULL)
  538|       |	LeaveCriticalSection(global_init_lock);
  539|       |#endif
  540|      2|}

xmlBuildQName:
  218|      6|	      xmlChar *memory, int len) {
  219|      6|    int lenn, lenp;
  220|      6|    xmlChar *ret;
  221|       |
  222|      6|    if (ncname == NULL) return(NULL);
  ------------------
  |  Branch (222:9): [True: 0, False: 6]
  ------------------
  223|      6|    if (prefix == NULL) return((xmlChar *) ncname);
  ------------------
  |  Branch (223:9): [True: 0, False: 6]
  ------------------
  224|       |
  225|      6|    lenn = strlen((char *) ncname);
  226|      6|    lenp = strlen((char *) prefix);
  227|       |
  228|      6|    if ((memory == NULL) || (len < lenn + lenp + 2)) {
  ------------------
  |  Branch (228:9): [True: 0, False: 6]
  |  Branch (228:29): [True: 0, False: 6]
  ------------------
  229|      0|	ret = (xmlChar *) xmlMallocAtomic(lenn + lenp + 2);
  230|      0|	if (ret == NULL) {
  ------------------
  |  Branch (230:6): [True: 0, False: 0]
  ------------------
  231|      0|	    xmlTreeErrMemory("building QName");
  232|      0|	    return(NULL);
  233|      0|	}
  234|      6|    } else {
  235|      6|	ret = memory;
  236|      6|    }
  237|      6|    memcpy(&ret[0], prefix, lenp);
  238|      6|    ret[lenp] = ':';
  239|      6|    memcpy(&ret[lenp + 1], ncname, lenn);
  240|      6|    ret[lenn + lenp + 1] = 0;
  241|      6|    return(ret);
  242|      6|}
xmlSplitQName2:
  262|     74|xmlSplitQName2(const xmlChar *name, xmlChar **prefix) {
  263|     74|    int len = 0;
  264|     74|    xmlChar *ret = NULL;
  265|       |
  266|     74|    if (prefix == NULL) return(NULL);
  ------------------
  |  Branch (266:9): [True: 0, False: 74]
  ------------------
  267|     74|    *prefix = NULL;
  268|     74|    if (name == NULL) return(NULL);
  ------------------
  |  Branch (268:9): [True: 0, False: 74]
  ------------------
  269|       |
  270|       |#ifndef XML_XML_NAMESPACE
  271|       |    /* xml: prefix is not really a namespace */
  272|       |    if ((name[0] == 'x') && (name[1] == 'm') &&
  273|       |        (name[2] == 'l') && (name[3] == ':'))
  274|       |	return(NULL);
  275|       |#endif
  276|       |
  277|       |    /* nasty but valid */
  278|     74|    if (name[0] == ':')
  ------------------
  |  Branch (278:9): [True: 0, False: 74]
  ------------------
  279|      0|	return(NULL);
  280|       |
  281|       |    /*
  282|       |     * we are not trying to validate but just to cut, and yes it will
  283|       |     * work even if this is as set of UTF-8 encoded chars
  284|       |     */
  285|    366|    while ((name[len] != 0) && (name[len] != ':'))
  ------------------
  |  Branch (285:12): [True: 294, False: 72]
  |  Branch (285:32): [True: 292, False: 2]
  ------------------
  286|    292|	len++;
  287|       |
  288|     74|    if (name[len] == 0)
  ------------------
  |  Branch (288:9): [True: 72, False: 2]
  ------------------
  289|     72|	return(NULL);
  290|       |
  291|      2|    *prefix = xmlStrndup(name, len);
  292|      2|    if (*prefix == NULL) {
  ------------------
  |  Branch (292:9): [True: 0, False: 2]
  ------------------
  293|      0|	xmlTreeErrMemory("QName split");
  294|      0|	return(NULL);
  295|      0|    }
  296|      2|    ret = xmlStrdup(&name[len + 1]);
  297|      2|    if (ret == NULL) {
  ------------------
  |  Branch (297:9): [True: 0, False: 2]
  ------------------
  298|      0|	xmlTreeErrMemory("QName split");
  299|      0|	if (*prefix != NULL) {
  ------------------
  |  Branch (299:6): [True: 0, False: 0]
  ------------------
  300|      0|	    xmlFree(*prefix);
  301|      0|	    *prefix = NULL;
  302|      0|	}
  303|      0|	return(NULL);
  304|      0|    }
  305|       |
  306|      2|    return(ret);
  307|      2|}
xmlSplitQName3:
  322|     14|xmlSplitQName3(const xmlChar *name, int *len) {
  323|     14|    int l = 0;
  324|       |
  325|     14|    if (name == NULL) return(NULL);
  ------------------
  |  Branch (325:9): [True: 0, False: 14]
  ------------------
  326|     14|    if (len == NULL) return(NULL);
  ------------------
  |  Branch (326:9): [True: 0, False: 14]
  ------------------
  327|       |
  328|       |    /* nasty but valid */
  329|     14|    if (name[0] == ':')
  ------------------
  |  Branch (329:9): [True: 0, False: 14]
  ------------------
  330|      0|	return(NULL);
  331|       |
  332|       |    /*
  333|       |     * we are not trying to validate but just to cut, and yes it will
  334|       |     * work even if this is as set of UTF-8 encoded chars
  335|       |     */
  336|     64|    while ((name[l] != 0) && (name[l] != ':'))
  ------------------
  |  Branch (336:12): [True: 50, False: 14]
  |  Branch (336:30): [True: 50, False: 0]
  ------------------
  337|     50|	l++;
  338|       |
  339|     14|    if (name[l] == 0)
  ------------------
  |  Branch (339:9): [True: 14, False: 0]
  ------------------
  340|     14|	return(NULL);
  341|       |
  342|      0|    *len = l;
  343|       |
  344|      0|    return(&name[l+1]);
  345|     14|}
xmlValidateNCName:
  366|     12|xmlValidateNCName(const xmlChar *value, int space) {
  367|     12|    const xmlChar *cur = value;
  368|     12|    int c,l;
  369|       |
  370|     12|    if (value == NULL)
  ------------------
  |  Branch (370:9): [True: 0, False: 12]
  ------------------
  371|      0|        return(-1);
  372|       |
  373|       |    /*
  374|       |     * First quick algorithm for ASCII range
  375|       |     */
  376|     12|    if (space)
  ------------------
  |  Branch (376:9): [True: 12, False: 0]
  ------------------
  377|     12|	while (IS_BLANK_CH(*cur)) cur++;
  378|     12|    if (((*cur >= 'a') && (*cur <= 'z')) || ((*cur >= 'A') && (*cur <= 'Z')) ||
  ------------------
  |  Branch (378:10): [True: 12, False: 0]
  |  Branch (378:27): [True: 12, False: 0]
  |  Branch (378:46): [True: 0, False: 0]
  |  Branch (378:63): [True: 0, False: 0]
  ------------------
  379|     12|	(*cur == '_'))
  ------------------
  |  Branch (379:2): [True: 0, False: 0]
  ------------------
  380|     12|	cur++;
  381|      0|    else
  382|      0|	goto try_complex;
  383|     24|    while (((*cur >= 'a') && (*cur <= 'z')) ||
  ------------------
  |  Branch (383:13): [True: 0, False: 24]
  |  Branch (383:30): [True: 0, False: 0]
  ------------------
  384|     24|	   ((*cur >= 'A') && (*cur <= 'Z')) ||
  ------------------
  |  Branch (384:6): [True: 0, False: 24]
  |  Branch (384:23): [True: 0, False: 0]
  ------------------
  385|     24|	   ((*cur >= '0') && (*cur <= '9')) ||
  ------------------
  |  Branch (385:6): [True: 12, False: 12]
  |  Branch (385:23): [True: 12, False: 0]
  ------------------
  386|     24|	   (*cur == '_') || (*cur == '-') || (*cur == '.'))
  ------------------
  |  Branch (386:5): [True: 0, False: 12]
  |  Branch (386:22): [True: 0, False: 12]
  |  Branch (386:39): [True: 0, False: 12]
  ------------------
  387|     12|	cur++;
  388|     12|    if (space)
  ------------------
  |  Branch (388:9): [True: 12, False: 0]
  ------------------
  389|     12|	while (IS_BLANK_CH(*cur)) cur++;
  390|     12|    if (*cur == 0)
  ------------------
  |  Branch (390:9): [True: 12, False: 0]
  ------------------
  391|     12|	return(0);
  392|       |
  393|      0|try_complex:
  394|       |    /*
  395|       |     * Second check for chars outside the ASCII range
  396|       |     */
  397|      0|    cur = value;
  398|      0|    c = CUR_SCHAR(cur, l);
  ------------------
  |  |  353|      0|#define CUR_SCHAR(s, l) xmlStringCurrentChar(NULL, s, &l)
  ------------------
  399|      0|    if (space) {
  ------------------
  |  Branch (399:9): [True: 0, False: 0]
  ------------------
  400|      0|	while (IS_BLANK(c)) {
  401|      0|	    cur += l;
  402|      0|	    c = CUR_SCHAR(cur, l);
  ------------------
  |  |  353|      0|#define CUR_SCHAR(s, l) xmlStringCurrentChar(NULL, s, &l)
  ------------------
  403|      0|	}
  404|      0|    }
  405|      0|    if ((!IS_LETTER(c)) && (c != '_'))
  ------------------
  |  |  240|      0|#define IS_LETTER(c) (IS_BASECHAR(c) || IS_IDEOGRAPHIC(c))
  |  |  ------------------
  |  |  |  |  161|      0|#define IS_BASECHAR(c) xmlIsBaseCharQ(c)
  |  |  |  |  ------------------
  |  |  |  |  |  |   76|      0|#define xmlIsBaseCharQ(c)	(((c) < 0x100) ? \
  |  |  |  |  |  |  ------------------
  |  |  |  |  |  |  |  Branch (76:27): [True: 0, False: 0]
  |  |  |  |  |  |  |  Branch (76:28): [True: 0, False: 0]
  |  |  |  |  |  |  ------------------
  |  |  |  |  |  |   77|      0|				 xmlIsBaseChar_ch((c)) : \
  |  |  |  |  |  |  ------------------
  |  |  |  |  |  |  |  |   64|      0|#define xmlIsBaseChar_ch(c)	(((0x41 <= (c)) && ((c) <= 0x5a)) || \
  |  |  |  |  |  |  |  |  ------------------
  |  |  |  |  |  |  |  |  |  Branch (64:31): [True: 0, False: 0]
  |  |  |  |  |  |  |  |  |  Branch (64:48): [True: 0, False: 0]
  |  |  |  |  |  |  |  |  ------------------
  |  |  |  |  |  |  |  |   65|      0|				 ((0x61 <= (c)) && ((c) <= 0x7a)) || \
  |  |  |  |  |  |  |  |  ------------------
  |  |  |  |  |  |  |  |  |  Branch (65:7): [True: 0, False: 0]
  |  |  |  |  |  |  |  |  |  Branch (65:24): [True: 0, False: 0]
  |  |  |  |  |  |  |  |  ------------------
  |  |  |  |  |  |  |  |   66|      0|				 ((0xc0 <= (c)) && ((c) <= 0xd6)) || \
  |  |  |  |  |  |  |  |  ------------------
  |  |  |  |  |  |  |  |  |  Branch (66:7): [True: 0, False: 0]
  |  |  |  |  |  |  |  |  |  Branch (66:24): [True: 0, False: 0]
  |  |  |  |  |  |  |  |  ------------------
  |  |  |  |  |  |  |  |   67|      0|				 ((0xd8 <= (c)) && ((c) <= 0xf6)) || \
  |  |  |  |  |  |  |  |  ------------------
  |  |  |  |  |  |  |  |  |  Branch (67:7): [True: 0, False: 0]
  |  |  |  |  |  |  |  |  |  Branch (67:24): [True: 0, False: 0]
  |  |  |  |  |  |  |  |  ------------------
  |  |  |  |  |  |  |  |   68|      0|				  (0xf8 <= (c)))
  |  |  |  |  |  |  |  |  ------------------
  |  |  |  |  |  |  |  |  |  Branch (68:7): [True: 0, False: 0]
  |  |  |  |  |  |  |  |  ------------------
  |  |  |  |  |  |  ------------------
  |  |  |  |  |  |   78|      0|				 xmlCharInRange((c), &xmlIsBaseCharGroup))
  |  |  |  |  ------------------
  |  |  ------------------
  |  |               #define IS_LETTER(c) (IS_BASECHAR(c) || IS_IDEOGRAPHIC(c))
  |  |  ------------------
  |  |  |  |  229|      0|#define IS_IDEOGRAPHIC(c) xmlIsIdeographicQ(c)
  |  |  |  |  ------------------
  |  |  |  |  |  |  184|      0|#define xmlIsIdeographicQ(c)	(((c) < 0x100) ? \
  |  |  |  |  |  |  ------------------
  |  |  |  |  |  |  |  Branch (184:30): [True: 0, False: 0]
  |  |  |  |  |  |  |  Branch (184:31): [True: 0, False: 0]
  |  |  |  |  |  |  ------------------
  |  |  |  |  |  |  185|      0|				 0 :\
  |  |  |  |  |  |  186|      0|				(((0x4e00 <= (c)) && ((c) <= 0x9fa5)) || \
  |  |  |  |  |  |  ------------------
  |  |  |  |  |  |  |  Branch (186:7): [True: 0, False: 0]
  |  |  |  |  |  |  |  Branch (186:26): [True: 0, False: 0]
  |  |  |  |  |  |  ------------------
  |  |  |  |  |  |  187|      0|				 ((c) == 0x3007) || \
  |  |  |  |  |  |  ------------------
  |  |  |  |  |  |  |  Branch (187:6): [True: 0, False: 0]
  |  |  |  |  |  |  ------------------
  |  |  |  |  |  |  188|      0|				 ((0x3021 <= (c)) && ((c) <= 0x3029))))
  |  |  |  |  |  |  ------------------
  |  |  |  |  |  |  |  Branch (188:7): [True: 0, False: 0]
  |  |  |  |  |  |  |  Branch (188:26): [True: 0, False: 0]
  |  |  |  |  |  |  ------------------
  |  |  |  |  ------------------
  |  |  ------------------
  ------------------
  |  Branch (405:28): [True: 0, False: 0]
  ------------------
  406|      0|	return(1);
  407|      0|    cur += l;
  408|      0|    c = CUR_SCHAR(cur, l);
  ------------------
  |  |  353|      0|#define CUR_SCHAR(s, l) xmlStringCurrentChar(NULL, s, &l)
  ------------------
  409|      0|    while (IS_LETTER(c) || IS_DIGIT(c) || (c == '.') ||
  ------------------
  |  |  240|      0|#define IS_LETTER(c) (IS_BASECHAR(c) || IS_IDEOGRAPHIC(c))
  |  |  ------------------
  |  |  |  |  161|      0|#define IS_BASECHAR(c) xmlIsBaseCharQ(c)
  |  |  |  |  ------------------
  |  |  |  |  |  |   76|      0|#define xmlIsBaseCharQ(c)	(((c) < 0x100) ? \
  |  |  |  |  |  |  ------------------
  |  |  |  |  |  |  |  Branch (76:27): [True: 0, False: 0]
  |  |  |  |  |  |  |  Branch (76:28): [True: 0, False: 0]
  |  |  |  |  |  |  ------------------
  |  |  |  |  |  |   77|      0|				 xmlIsBaseChar_ch((c)) : \
  |  |  |  |  |  |  ------------------
  |  |  |  |  |  |  |  |   64|      0|#define xmlIsBaseChar_ch(c)	(((0x41 <= (c)) && ((c) <= 0x5a)) || \
  |  |  |  |  |  |  |  |  ------------------
  |  |  |  |  |  |  |  |  |  Branch (64:31): [True: 0, False: 0]
  |  |  |  |  |  |  |  |  |  Branch (64:48): [True: 0, False: 0]
  |  |  |  |  |  |  |  |  ------------------
  |  |  |  |  |  |  |  |   65|      0|				 ((0x61 <= (c)) && ((c) <= 0x7a)) || \
  |  |  |  |  |  |  |  |  ------------------
  |  |  |  |  |  |  |  |  |  Branch (65:7): [True: 0, False: 0]
  |  |  |  |  |  |  |  |  |  Branch (65:24): [True: 0, False: 0]
  |  |  |  |  |  |  |  |  ------------------
  |  |  |  |  |  |  |  |   66|      0|				 ((0xc0 <= (c)) && ((c) <= 0xd6)) || \
  |  |  |  |  |  |  |  |  ------------------
  |  |  |  |  |  |  |  |  |  Branch (66:7): [True: 0, False: 0]
  |  |  |  |  |  |  |  |  |  Branch (66:24): [True: 0, False: 0]
  |  |  |  |  |  |  |  |  ------------------
  |  |  |  |  |  |  |  |   67|      0|				 ((0xd8 <= (c)) && ((c) <= 0xf6)) || \
  |  |  |  |  |  |  |  |  ------------------
  |  |  |  |  |  |  |  |  |  Branch (67:7): [True: 0, False: 0]
  |  |  |  |  |  |  |  |  |  Branch (67:24): [True: 0, False: 0]
  |  |  |  |  |  |  |  |  ------------------
  |  |  |  |  |  |  |  |   68|      0|				  (0xf8 <= (c)))
  |  |  |  |  |  |  |  |  ------------------
  |  |  |  |  |  |  |  |  |  Branch (68:7): [True: 0, False: 0]
  |  |  |  |  |  |  |  |  ------------------
  |  |  |  |  |  |  ------------------
  |  |  |  |  |  |   78|      0|				 xmlCharInRange((c), &xmlIsBaseCharGroup))
  |  |  |  |  ------------------
  |  |  ------------------
  |  |               #define IS_LETTER(c) (IS_BASECHAR(c) || IS_IDEOGRAPHIC(c))
  |  |  ------------------
  |  |  |  |  229|      0|#define IS_IDEOGRAPHIC(c) xmlIsIdeographicQ(c)
  |  |  |  |  ------------------
  |  |  |  |  |  |  184|      0|#define xmlIsIdeographicQ(c)	(((c) < 0x100) ? \
  |  |  |  |  |  |  ------------------
  |  |  |  |  |  |  |  Branch (184:30): [True: 0, False: 0]
  |  |  |  |  |  |  |  Branch (184:31): [True: 0, False: 0]
  |  |  |  |  |  |  ------------------
  |  |  |  |  |  |  185|      0|				 0 :\
  |  |  |  |  |  |  186|      0|				(((0x4e00 <= (c)) && ((c) <= 0x9fa5)) || \
  |  |  |  |  |  |  ------------------
  |  |  |  |  |  |  |  Branch (186:7): [True: 0, False: 0]
  |  |  |  |  |  |  |  Branch (186:26): [True: 0, False: 0]
  |  |  |  |  |  |  ------------------
  |  |  |  |  |  |  187|      0|				 ((c) == 0x3007) || \
  |  |  |  |  |  |  ------------------
  |  |  |  |  |  |  |  Branch (187:6): [True: 0, False: 0]
  |  |  |  |  |  |  ------------------
  |  |  |  |  |  |  188|      0|				 ((0x3021 <= (c)) && ((c) <= 0x3029))))
  |  |  |  |  |  |  ------------------
  |  |  |  |  |  |  |  Branch (188:7): [True: 0, False: 0]
  |  |  |  |  |  |  |  Branch (188:26): [True: 0, False: 0]
  |  |  |  |  |  |  ------------------
  |  |  |  |  ------------------
  |  |  ------------------
  ------------------
                  while (IS_LETTER(c) || IS_DIGIT(c) || (c == '.') ||
  ------------------
  |  |  171|      0|#define IS_DIGIT(c) xmlIsDigitQ(c)
  |  |  ------------------
  |  |  |  |  152|      0|#define xmlIsDigitQ(c)		(((c) < 0x100) ? \
  |  |  |  |  ------------------
  |  |  |  |  |  Branch (152:25): [True: 0, False: 0]
  |  |  |  |  |  Branch (152:26): [True: 0, False: 0]
  |  |  |  |  ------------------
  |  |  |  |  153|      0|				 xmlIsDigit_ch((c)) : \
  |  |  |  |  ------------------
  |  |  |  |  |  |  144|      0|#define xmlIsDigit_ch(c)	(((0x30 <= (c)) && ((c) <= 0x39)))
  |  |  |  |  |  |  ------------------
  |  |  |  |  |  |  |  Branch (144:28): [True: 0, False: 0]
  |  |  |  |  |  |  |  Branch (144:45): [True: 0, False: 0]
  |  |  |  |  |  |  ------------------
  |  |  |  |  ------------------
  |  |  |  |  154|      0|				 xmlCharInRange((c), &xmlIsDigitGroup))
  |  |  ------------------
  ------------------
  |  Branch (409:43): [True: 0, False: 0]
  ------------------
  410|      0|	   (c == '-') || (c == '_') || IS_COMBINING(c) ||
  ------------------
  |  |  189|      0|#define IS_COMBINING(c) xmlIsCombiningQ(c)
  |  |  ------------------
  |  |  |  |  132|      0|#define xmlIsCombiningQ(c)	(((c) < 0x100) ? \
  |  |  |  |  ------------------
  |  |  |  |  |  Branch (132:28): [True: 0, False: 0]
  |  |  |  |  |  Branch (132:29): [True: 0, False: 0]
  |  |  |  |  ------------------
  |  |  |  |  133|      0|				 0 : \
  |  |  |  |  134|      0|				 xmlCharInRange((c), &xmlIsCombiningGroup))
  |  |  ------------------
  ------------------
  |  Branch (410:5): [True: 0, False: 0]
  |  Branch (410:19): [True: 0, False: 0]
  ------------------
  411|      0|	   IS_EXTENDER(c)) {
  ------------------
  |  |  210|      0|#define IS_EXTENDER(c) xmlIsExtenderQ(c)
  |  |  ------------------
  |  |  |  |  172|      0|#define xmlIsExtenderQ(c)	(((c) < 0x100) ? \
  |  |  |  |  ------------------
  |  |  |  |  |  Branch (172:27): [True: 0, False: 0]
  |  |  |  |  |  Branch (172:28): [True: 0, False: 0]
  |  |  |  |  ------------------
  |  |  |  |  173|      0|				 xmlIsExtender_ch((c)) : \
  |  |  |  |  ------------------
  |  |  |  |  |  |  164|      0|#define xmlIsExtender_ch(c)	(((c) == 0xb7))
  |  |  |  |  ------------------
  |  |  |  |  174|      0|				 xmlCharInRange((c), &xmlIsExtenderGroup))
  |  |  ------------------
  ------------------
  412|      0|	cur += l;
  413|      0|	c = CUR_SCHAR(cur, l);
  ------------------
  |  |  353|      0|#define CUR_SCHAR(s, l) xmlStringCurrentChar(NULL, s, &l)
  ------------------
  414|      0|    }
  415|      0|    if (space) {
  ------------------
  |  Branch (415:9): [True: 0, False: 0]
  ------------------
  416|      0|	while (IS_BLANK(c)) {
  417|      0|	    cur += l;
  418|      0|	    c = CUR_SCHAR(cur, l);
  ------------------
  |  |  353|      0|#define CUR_SCHAR(s, l) xmlStringCurrentChar(NULL, s, &l)
  ------------------
  419|      0|	}
  420|      0|    }
  421|      0|    if (c != 0)
  ------------------
  |  Branch (421:9): [True: 0, False: 0]
  ------------------
  422|      0|	return(1);
  423|       |
  424|      0|    return(0);
  425|      0|}
xmlNewNs:
  726|    275|xmlNewNs(xmlNodePtr node, const xmlChar *href, const xmlChar *prefix) {
  727|    275|    xmlNsPtr cur;
  728|       |
  729|    275|    if ((node != NULL) && (node->type != XML_ELEMENT_NODE))
  ------------------
  |  Branch (729:9): [True: 5, False: 270]
  |  Branch (729:27): [True: 0, False: 5]
  ------------------
  730|      0|	return(NULL);
  731|       |
  732|    275|    if ((prefix != NULL) && (xmlStrEqual(prefix, BAD_CAST "xml"))) {
  ------------------
  |  |   35|    275|#define BAD_CAST (xmlChar *)
  ------------------
  |  Branch (732:9): [True: 275, False: 0]
  |  Branch (732:29): [True: 0, False: 275]
  ------------------
  733|       |        /* xml namespace is predefined, no need to add it */
  734|      0|        if (xmlStrEqual(href, XML_XML_NAMESPACE))
  ------------------
  |  |  143|      0|    (const xmlChar *) "http://www.w3.org/XML/1998/namespace"
  ------------------
  |  Branch (734:13): [True: 0, False: 0]
  ------------------
  735|      0|            return(NULL);
  736|       |
  737|       |        /*
  738|       |         * Problem, this is an attempt to bind xml prefix to a wrong
  739|       |         * namespace, which breaks
  740|       |         * Namespace constraint: Reserved Prefixes and Namespace Names
  741|       |         * from XML namespace. But documents authors may not care in
  742|       |         * their context so let's proceed.
  743|       |         */
  744|      0|    }
  745|       |
  746|       |    /*
  747|       |     * Allocate a new Namespace and fill the fields.
  748|       |     */
  749|    275|    cur = (xmlNsPtr) xmlMalloc(sizeof(xmlNs));
  750|    275|    if (cur == NULL) {
  ------------------
  |  Branch (750:9): [True: 0, False: 275]
  ------------------
  751|      0|	xmlTreeErrMemory("building namespace");
  752|      0|	return(NULL);
  753|      0|    }
  754|    275|    memset(cur, 0, sizeof(xmlNs));
  755|    275|    cur->type = XML_LOCAL_NAMESPACE;
  ------------------
  |  |  370|    275|#define XML_LOCAL_NAMESPACE XML_NAMESPACE_DECL
  ------------------
  756|       |
  757|    275|    if (href != NULL)
  ------------------
  |  Branch (757:9): [True: 275, False: 0]
  ------------------
  758|    275|	cur->href = xmlStrdup(href);
  759|    275|    if (prefix != NULL)
  ------------------
  |  Branch (759:9): [True: 275, False: 0]
  ------------------
  760|    275|	cur->prefix = xmlStrdup(prefix);
  761|       |
  762|       |    /*
  763|       |     * Add it at the end to preserve parsing order ...
  764|       |     * and checks for existing use of the prefix
  765|       |     */
  766|    275|    if (node != NULL) {
  ------------------
  |  Branch (766:9): [True: 5, False: 270]
  ------------------
  767|      5|	if (node->nsDef == NULL) {
  ------------------
  |  Branch (767:6): [True: 5, False: 0]
  ------------------
  768|      5|	    node->nsDef = cur;
  769|      5|	} else {
  770|      0|	    xmlNsPtr prev = node->nsDef;
  771|       |
  772|      0|	    if (((prev->prefix == NULL) && (cur->prefix == NULL)) ||
  ------------------
  |  Branch (772:11): [True: 0, False: 0]
  |  Branch (772:37): [True: 0, False: 0]
  ------------------
  773|      0|		(xmlStrEqual(prev->prefix, cur->prefix))) {
  ------------------
  |  Branch (773:3): [True: 0, False: 0]
  ------------------
  774|      0|		xmlFreeNs(cur);
  775|      0|		return(NULL);
  776|      0|	    }
  777|      0|	    while (prev->next != NULL) {
  ------------------
  |  Branch (777:13): [True: 0, False: 0]
  ------------------
  778|      0|	        prev = prev->next;
  779|      0|		if (((prev->prefix == NULL) && (cur->prefix == NULL)) ||
  ------------------
  |  Branch (779:8): [True: 0, False: 0]
  |  Branch (779:34): [True: 0, False: 0]
  ------------------
  780|      0|		    (xmlStrEqual(prev->prefix, cur->prefix))) {
  ------------------
  |  Branch (780:7): [True: 0, False: 0]
  ------------------
  781|      0|		    xmlFreeNs(cur);
  782|      0|		    return(NULL);
  783|      0|		}
  784|      0|	    }
  785|      0|	    prev->next = cur;
  786|      0|	}
  787|      5|    }
  788|    275|    return(cur);
  789|    275|}
xmlSetNs:
  799|      2|xmlSetNs(xmlNodePtr node, xmlNsPtr ns) {
  800|      2|    if (node == NULL) {
  ------------------
  |  Branch (800:9): [True: 0, False: 2]
  ------------------
  801|      0|	return;
  802|      0|    }
  803|      2|    if ((node->type == XML_ELEMENT_NODE) ||
  ------------------
  |  Branch (803:9): [True: 2, False: 0]
  ------------------
  804|      2|        (node->type == XML_ATTRIBUTE_NODE))
  ------------------
  |  Branch (804:9): [True: 0, False: 0]
  ------------------
  805|      2|	node->ns = ns;
  806|      2|}
xmlFreeNs:
  815|    305|xmlFreeNs(xmlNsPtr cur) {
  816|    305|    if (cur == NULL) {
  ------------------
  |  Branch (816:9): [True: 0, False: 305]
  ------------------
  817|      0|	return;
  818|      0|    }
  819|    305|    if (cur->href != NULL) xmlFree((char *) cur->href);
  ------------------
  |  Branch (819:9): [True: 305, False: 0]
  ------------------
  820|    305|    if (cur->prefix != NULL) xmlFree((char *) cur->prefix);
  ------------------
  |  Branch (820:9): [True: 305, False: 0]
  ------------------
  821|    305|    xmlFree(cur);
  822|    305|}
xmlFreeNsList:
  831|    301|xmlFreeNsList(xmlNsPtr cur) {
  832|    301|    xmlNsPtr next;
  833|    301|    if (cur == NULL) {
  ------------------
  |  Branch (833:9): [True: 0, False: 301]
  ------------------
  834|      0|	return;
  835|      0|    }
  836|    606|    while (cur != NULL) {
  ------------------
  |  Branch (836:12): [True: 305, False: 301]
  ------------------
  837|    305|        next = cur->next;
  838|    305|        xmlFreeNs(cur);
  839|    305|	cur = next;
  840|    305|    }
  841|    301|}
xmlGetIntSubset:
  899|     16|xmlGetIntSubset(const xmlDoc *doc) {
  900|     16|    xmlNodePtr cur;
  901|       |
  902|     16|    if (doc == NULL)
  ------------------
  |  Branch (902:9): [True: 0, False: 16]
  ------------------
  903|      0|	return(NULL);
  904|     16|    cur = doc->children;
  905|     16|    while (cur != NULL) {
  ------------------
  |  Branch (905:12): [True: 0, False: 16]
  ------------------
  906|      0|	if (cur->type == XML_DTD_NODE)
  ------------------
  |  Branch (906:6): [True: 0, False: 0]
  ------------------
  907|      0|	    return((xmlDtdPtr) cur);
  908|      0|	cur = cur->next;
  909|      0|    }
  910|     16|    return((xmlDtdPtr) doc->intSubset);
  911|     16|}
xmlCreateIntSubset:
  925|      8|                   const xmlChar *ExternalID, const xmlChar *SystemID) {
  926|      8|    xmlDtdPtr cur;
  927|       |
  928|      8|    if ((doc != NULL) && (xmlGetIntSubset(doc) != NULL)) {
  ------------------
  |  Branch (928:9): [True: 8, False: 0]
  |  Branch (928:26): [True: 0, False: 8]
  ------------------
  929|      0|	return(NULL);
  930|      0|    }
  931|       |
  932|       |    /*
  933|       |     * Allocate a new DTD and fill the fields.
  934|       |     */
  935|      8|    cur = (xmlDtdPtr) xmlMalloc(sizeof(xmlDtd));
  936|      8|    if (cur == NULL) {
  ------------------
  |  Branch (936:9): [True: 0, False: 8]
  ------------------
  937|      0|	xmlTreeErrMemory("building internal subset");
  938|      0|	return(NULL);
  939|      0|    }
  940|      8|    memset(cur, 0, sizeof(xmlDtd));
  941|      8|    cur->type = XML_DTD_NODE;
  942|       |
  943|      8|    if (name != NULL) {
  ------------------
  |  Branch (943:9): [True: 8, False: 0]
  ------------------
  944|      8|	cur->name = xmlStrdup(name);
  945|      8|	if (cur->name == NULL) {
  ------------------
  |  Branch (945:6): [True: 0, False: 8]
  ------------------
  946|      0|	    xmlTreeErrMemory("building internal subset");
  947|      0|	    xmlFree(cur);
  948|      0|	    return(NULL);
  949|      0|	}
  950|      8|    }
  951|      8|    if (ExternalID != NULL) {
  ------------------
  |  Branch (951:9): [True: 0, False: 8]
  ------------------
  952|      0|	cur->ExternalID = xmlStrdup(ExternalID);
  953|      0|	if (cur->ExternalID  == NULL) {
  ------------------
  |  Branch (953:6): [True: 0, False: 0]
  ------------------
  954|      0|	    xmlTreeErrMemory("building internal subset");
  955|      0|	    if (cur->name != NULL)
  ------------------
  |  Branch (955:10): [True: 0, False: 0]
  ------------------
  956|      0|	        xmlFree((char *)cur->name);
  957|      0|	    xmlFree(cur);
  958|      0|	    return(NULL);
  959|      0|	}
  960|      0|    }
  961|      8|    if (SystemID != NULL) {
  ------------------
  |  Branch (961:9): [True: 0, False: 8]
  ------------------
  962|      0|	cur->SystemID = xmlStrdup(SystemID);
  963|      0|	if (cur->SystemID == NULL) {
  ------------------
  |  Branch (963:6): [True: 0, False: 0]
  ------------------
  964|      0|	    xmlTreeErrMemory("building internal subset");
  965|      0|	    if (cur->name != NULL)
  ------------------
  |  Branch (965:10): [True: 0, False: 0]
  ------------------
  966|      0|	        xmlFree((char *)cur->name);
  967|      0|	    if (cur->ExternalID != NULL)
  ------------------
  |  Branch (967:10): [True: 0, False: 0]
  ------------------
  968|      0|	        xmlFree((char *)cur->ExternalID);
  969|      0|	    xmlFree(cur);
  970|      0|	    return(NULL);
  971|      0|	}
  972|      0|    }
  973|      8|    if (doc != NULL) {
  ------------------
  |  Branch (973:9): [True: 8, False: 0]
  ------------------
  974|      8|	doc->intSubset = cur;
  975|      8|	cur->parent = doc;
  976|      8|	cur->doc = doc;
  977|      8|	if (doc->children == NULL) {
  ------------------
  |  Branch (977:6): [True: 8, False: 0]
  ------------------
  978|      8|	    doc->children = (xmlNodePtr) cur;
  979|      8|	    doc->last = (xmlNodePtr) cur;
  980|      8|	} else {
  981|      0|	    if (doc->type == XML_HTML_DOCUMENT_NODE) {
  ------------------
  |  Branch (981:10): [True: 0, False: 0]
  ------------------
  982|      0|		xmlNodePtr prev;
  983|       |
  984|      0|		prev = doc->children;
  985|      0|		prev->prev = (xmlNodePtr) cur;
  986|      0|		cur->next = prev;
  987|      0|		doc->children = (xmlNodePtr) cur;
  988|      0|	    } else {
  989|      0|		xmlNodePtr next;
  990|       |
  991|      0|		next = doc->children;
  992|      0|		while ((next != NULL) && (next->type != XML_ELEMENT_NODE))
  ------------------
  |  Branch (992:10): [True: 0, False: 0]
  |  Branch (992:28): [True: 0, False: 0]
  ------------------
  993|      0|		    next = next->next;
  994|      0|		if (next == NULL) {
  ------------------
  |  Branch (994:7): [True: 0, False: 0]
  ------------------
  995|      0|		    cur->prev = doc->last;
  996|      0|		    cur->prev->next = (xmlNodePtr) cur;
  997|      0|		    cur->next = NULL;
  998|      0|		    doc->last = (xmlNodePtr) cur;
  999|      0|		} else {
 1000|      0|		    cur->next = next;
 1001|      0|		    cur->prev = next->prev;
 1002|      0|		    if (cur->prev == NULL)
  ------------------
  |  Branch (1002:11): [True: 0, False: 0]
  ------------------
 1003|      0|			doc->children = (xmlNodePtr) cur;
 1004|      0|		    else
 1005|      0|			cur->prev->next = (xmlNodePtr) cur;
 1006|      0|		    next->prev = (xmlNodePtr) cur;
 1007|      0|		}
 1008|      0|	    }
 1009|      0|	}
 1010|      8|    }
 1011|       |
 1012|      8|    if ((__xmlRegisterCallbacks) && (xmlRegisterNodeDefaultValue))
  ------------------
  |  |  682|      0|    XML_GLOBAL_MACRO(xmlRegisterNodeDefaultValue)
  |  |  ------------------
  |  |  |  |  500|      0|  #define XML_GLOBAL_MACRO(name) (*__##name())
  |  |  ------------------
  ------------------
  |  Branch (1012:9): [True: 0, False: 8]
  |  Branch (1012:37): [True: 0, False: 0]
  ------------------
 1013|      0|	xmlRegisterNodeDefaultValue((xmlNodePtr)cur);
  ------------------
  |  |  682|      0|    XML_GLOBAL_MACRO(xmlRegisterNodeDefaultValue)
  |  |  ------------------
  |  |  |  |  500|      0|  #define XML_GLOBAL_MACRO(name) (*__##name())
  |  |  ------------------
  ------------------
 1014|      8|    return(cur);
 1015|      8|}
xmlFreeDtd:
 1072|      8|xmlFreeDtd(xmlDtdPtr cur) {
 1073|      8|    xmlDictPtr dict = NULL;
 1074|       |
 1075|      8|    if (cur == NULL) {
  ------------------
  |  Branch (1075:9): [True: 0, False: 8]
  ------------------
 1076|      0|	return;
 1077|      0|    }
 1078|      8|    if (cur->doc != NULL) dict = cur->doc->dict;
  ------------------
  |  Branch (1078:9): [True: 8, False: 0]
  ------------------
 1079|       |
 1080|      8|    if ((__xmlRegisterCallbacks) && (xmlDeregisterNodeDefaultValue))
  ------------------
  |  |  684|      0|    XML_GLOBAL_MACRO(xmlDeregisterNodeDefaultValue)
  |  |  ------------------
  |  |  |  |  500|      0|  #define XML_GLOBAL_MACRO(name) (*__##name())
  |  |  ------------------
  ------------------
  |  Branch (1080:9): [True: 0, False: 8]
  |  Branch (1080:37): [True: 0, False: 0]
  ------------------
 1081|      0|	xmlDeregisterNodeDefaultValue((xmlNodePtr)cur);
  ------------------
  |  |  684|      0|    XML_GLOBAL_MACRO(xmlDeregisterNodeDefaultValue)
  |  |  ------------------
  |  |  |  |  500|      0|  #define XML_GLOBAL_MACRO(name) (*__##name())
  |  |  ------------------
  ------------------
 1082|       |
 1083|      8|    if (cur->children != NULL) {
  ------------------
  |  Branch (1083:9): [True: 8, False: 0]
  ------------------
 1084|      8|	xmlNodePtr next, c = cur->children;
 1085|       |
 1086|       |	/*
 1087|       |	 * Cleanup all nodes which are not part of the specific lists
 1088|       |	 * of notations, elements, attributes and entities.
 1089|       |	 */
 1090|     38|        while (c != NULL) {
  ------------------
  |  Branch (1090:16): [True: 30, False: 8]
  ------------------
 1091|     30|	    next = c->next;
 1092|     30|	    if ((c->type != XML_NOTATION_NODE) &&
  ------------------
  |  Branch (1092:10): [True: 30, False: 0]
  ------------------
 1093|     30|	        (c->type != XML_ELEMENT_DECL) &&
  ------------------
  |  Branch (1093:10): [True: 8, False: 22]
  ------------------
 1094|     30|		(c->type != XML_ATTRIBUTE_DECL) &&
  ------------------
  |  Branch (1094:3): [True: 0, False: 8]
  ------------------
 1095|     30|		(c->type != XML_ENTITY_DECL)) {
  ------------------
  |  Branch (1095:3): [True: 0, False: 0]
  ------------------
 1096|      0|		xmlUnlinkNode(c);
 1097|      0|		xmlFreeNode(c);
 1098|      0|	    }
 1099|     30|	    c = next;
 1100|     30|	}
 1101|      8|    }
 1102|      8|    DICT_FREE(cur->name)
  ------------------
  |  | 1025|      8|	if ((str) && ((!dict) ||				\
  |  |  ------------------
  |  |  |  Branch (1025:6): [True: 8, False: 0]
  |  |  |  Branch (1025:16): [True: 0, False: 8]
  |  |  ------------------
  |  | 1026|      8|	    (xmlDictOwns(dict, (const xmlChar *)(str)) == 0)))	\
  |  |  ------------------
  |  |  |  Branch (1026:6): [True: 8, False: 0]
  |  |  ------------------
  |  | 1027|      8|	    xmlFree((char *)(str));
  ------------------
 1103|      8|    DICT_FREE(cur->SystemID)
  ------------------
  |  | 1025|      8|	if ((str) && ((!dict) ||				\
  |  |  ------------------
  |  |  |  Branch (1025:6): [True: 0, False: 8]
  |  |  |  Branch (1025:16): [True: 0, False: 0]
  |  |  ------------------
  |  | 1026|      0|	    (xmlDictOwns(dict, (const xmlChar *)(str)) == 0)))	\
  |  |  ------------------
  |  |  |  Branch (1026:6): [True: 0, False: 0]
  |  |  ------------------
  |  | 1027|      8|	    xmlFree((char *)(str));
  ------------------
 1104|      8|    DICT_FREE(cur->ExternalID)
  ------------------
  |  | 1025|      8|	if ((str) && ((!dict) ||				\
  |  |  ------------------
  |  |  |  Branch (1025:6): [True: 0, False: 8]
  |  |  |  Branch (1025:16): [True: 0, False: 0]
  |  |  ------------------
  |  | 1026|      0|	    (xmlDictOwns(dict, (const xmlChar *)(str)) == 0)))	\
  |  |  ------------------
  |  |  |  Branch (1026:6): [True: 0, False: 0]
  |  |  ------------------
  |  | 1027|      8|	    xmlFree((char *)(str));
  ------------------
 1105|       |    /* TODO !!! */
 1106|      8|    if (cur->notations != NULL)
  ------------------
  |  Branch (1106:9): [True: 0, False: 8]
  ------------------
 1107|      0|        xmlFreeNotationTable((xmlNotationTablePtr) cur->notations);
 1108|       |
 1109|      8|    if (cur->elements != NULL)
  ------------------
  |  Branch (1109:9): [True: 8, False: 0]
  ------------------
 1110|      8|        xmlFreeElementTable((xmlElementTablePtr) cur->elements);
 1111|      8|    if (cur->attributes != NULL)
  ------------------
  |  Branch (1111:9): [True: 8, False: 0]
  ------------------
 1112|      8|        xmlFreeAttributeTable((xmlAttributeTablePtr) cur->attributes);
 1113|      8|    if (cur->entities != NULL)
  ------------------
  |  Branch (1113:9): [True: 0, False: 8]
  ------------------
 1114|      0|        xmlFreeEntitiesTable((xmlEntitiesTablePtr) cur->entities);
 1115|      8|    if (cur->pentities != NULL)
  ------------------
  |  Branch (1115:9): [True: 0, False: 8]
  ------------------
 1116|      0|        xmlFreeEntitiesTable((xmlEntitiesTablePtr) cur->pentities);
 1117|       |
 1118|      8|    xmlFree(cur);
 1119|      8|}
xmlNewDoc:
 1130|    349|xmlNewDoc(const xmlChar *version) {
 1131|    349|    xmlDocPtr cur;
 1132|       |
 1133|    349|    if (version == NULL)
  ------------------
  |  Branch (1133:9): [True: 0, False: 349]
  ------------------
 1134|      0|	version = (const xmlChar *) "1.0";
 1135|       |
 1136|       |    /*
 1137|       |     * Allocate a new document and fill the fields.
 1138|       |     */
 1139|    349|    cur = (xmlDocPtr) xmlMalloc(sizeof(xmlDoc));
 1140|    349|    if (cur == NULL) {
  ------------------
  |  Branch (1140:9): [True: 0, False: 349]
  ------------------
 1141|      0|	xmlTreeErrMemory("building doc");
 1142|      0|	return(NULL);
 1143|      0|    }
 1144|    349|    memset(cur, 0, sizeof(xmlDoc));
 1145|    349|    cur->type = XML_DOCUMENT_NODE;
 1146|       |
 1147|    349|    cur->version = xmlStrdup(version);
 1148|    349|    if (cur->version == NULL) {
  ------------------
  |  Branch (1148:9): [True: 0, False: 349]
  ------------------
 1149|      0|	xmlTreeErrMemory("building doc");
 1150|      0|	xmlFree(cur);
 1151|      0|	return(NULL);
 1152|      0|    }
 1153|    349|    cur->standalone = -1;
 1154|    349|    cur->compression = -1; /* not initialized */
 1155|    349|    cur->doc = cur;
 1156|    349|    cur->parseFlags = 0;
 1157|    349|    cur->properties = XML_DOC_USERBUILT;
 1158|       |    /*
 1159|       |     * The in memory encoding is always UTF8
 1160|       |     * This field will never change and would
 1161|       |     * be obsolete if not for binary compatibility.
 1162|       |     */
 1163|    349|    cur->charset = XML_CHAR_ENCODING_UTF8;
 1164|       |
 1165|    349|    if ((__xmlRegisterCallbacks) && (xmlRegisterNodeDefaultValue))
  ------------------
  |  |  682|      0|    XML_GLOBAL_MACRO(xmlRegisterNodeDefaultValue)
  |  |  ------------------
  |  |  |  |  500|      0|  #define XML_GLOBAL_MACRO(name) (*__##name())
  |  |  ------------------
  ------------------
  |  Branch (1165:9): [True: 0, False: 349]
  |  Branch (1165:37): [True: 0, False: 0]
  ------------------
 1166|      0|	xmlRegisterNodeDefaultValue((xmlNodePtr)cur);
  ------------------
  |  |  682|      0|    XML_GLOBAL_MACRO(xmlRegisterNodeDefaultValue)
  |  |  ------------------
  |  |  |  |  500|      0|  #define XML_GLOBAL_MACRO(name) (*__##name())
  |  |  ------------------
  ------------------
 1167|    349|    return(cur);
 1168|    349|}
xmlFreeDoc:
 1177|    407|xmlFreeDoc(xmlDocPtr cur) {
 1178|    407|    xmlDtdPtr extSubset, intSubset;
 1179|    407|    xmlDictPtr dict = NULL;
 1180|       |
 1181|    407|    if (cur == NULL) {
  ------------------
  |  Branch (1181:9): [True: 218, False: 189]
  ------------------
 1182|    218|	return;
 1183|    218|    }
 1184|       |
 1185|    189|    if (cur != NULL) dict = cur->dict;
  ------------------
  |  Branch (1185:9): [True: 189, False: 0]
  ------------------
 1186|       |
 1187|    189|    if ((__xmlRegisterCallbacks) && (xmlDeregisterNodeDefaultValue))
  ------------------
  |  |  684|      0|    XML_GLOBAL_MACRO(xmlDeregisterNodeDefaultValue)
  |  |  ------------------
  |  |  |  |  500|      0|  #define XML_GLOBAL_MACRO(name) (*__##name())
  |  |  ------------------
  ------------------
  |  Branch (1187:9): [True: 0, False: 189]
  |  Branch (1187:37): [True: 0, False: 0]
  ------------------
 1188|      0|	xmlDeregisterNodeDefaultValue((xmlNodePtr)cur);
  ------------------
  |  |  684|      0|    XML_GLOBAL_MACRO(xmlDeregisterNodeDefaultValue)
  |  |  ------------------
  |  |  |  |  500|      0|  #define XML_GLOBAL_MACRO(name) (*__##name())
  |  |  ------------------
  ------------------
 1189|       |
 1190|       |    /*
 1191|       |     * Do this before freeing the children list to avoid ID lookups
 1192|       |     */
 1193|    189|    if (cur->ids != NULL) xmlFreeIDTable((xmlIDTablePtr) cur->ids);
  ------------------
  |  Branch (1193:9): [True: 11, False: 178]
  ------------------
 1194|    189|    cur->ids = NULL;
 1195|    189|    if (cur->refs != NULL) xmlFreeRefTable((xmlRefTablePtr) cur->refs);
  ------------------
  |  Branch (1195:9): [True: 0, False: 189]
  ------------------
 1196|    189|    cur->refs = NULL;
 1197|    189|    extSubset = cur->extSubset;
 1198|    189|    intSubset = cur->intSubset;
 1199|    189|    if (intSubset == extSubset)
  ------------------
  |  Branch (1199:9): [True: 184, False: 5]
  ------------------
 1200|    184|	extSubset = NULL;
 1201|    189|    if (extSubset != NULL) {
  ------------------
  |  Branch (1201:9): [True: 0, False: 189]
  ------------------
 1202|      0|	xmlUnlinkNode((xmlNodePtr) cur->extSubset);
 1203|      0|	cur->extSubset = NULL;
 1204|      0|	xmlFreeDtd(extSubset);
 1205|      0|    }
 1206|    189|    if (intSubset != NULL) {
  ------------------
  |  Branch (1206:9): [True: 5, False: 184]
  ------------------
 1207|      5|	xmlUnlinkNode((xmlNodePtr) cur->intSubset);
 1208|      5|	cur->intSubset = NULL;
 1209|      5|	xmlFreeDtd(intSubset);
 1210|      5|    }
 1211|       |
 1212|    189|    if (cur->children != NULL) xmlFreeNodeList(cur->children);
  ------------------
  |  Branch (1212:9): [True: 150, False: 39]
  ------------------
 1213|    189|    if (cur->oldNs != NULL) xmlFreeNsList(cur->oldNs);
  ------------------
  |  Branch (1213:9): [True: 15, False: 174]
  ------------------
 1214|       |
 1215|    189|    DICT_FREE(cur->version)
  ------------------
  |  | 1025|    189|	if ((str) && ((!dict) ||				\
  |  |  ------------------
  |  |  |  Branch (1025:6): [True: 189, False: 0]
  |  |  |  Branch (1025:16): [True: 2, False: 187]
  |  |  ------------------
  |  | 1026|    189|	    (xmlDictOwns(dict, (const xmlChar *)(str)) == 0)))	\
  |  |  ------------------
  |  |  |  Branch (1026:6): [True: 187, False: 0]
  |  |  ------------------
  |  | 1027|    189|	    xmlFree((char *)(str));
  ------------------
 1216|    189|    DICT_FREE(cur->name)
  ------------------
  |  | 1025|    189|	if ((str) && ((!dict) ||				\
  |  |  ------------------
  |  |  |  Branch (1025:6): [True: 0, False: 189]
  |  |  |  Branch (1025:16): [True: 0, False: 0]
  |  |  ------------------
  |  | 1026|      0|	    (xmlDictOwns(dict, (const xmlChar *)(str)) == 0)))	\
  |  |  ------------------
  |  |  |  Branch (1026:6): [True: 0, False: 0]
  |  |  ------------------
  |  | 1027|    189|	    xmlFree((char *)(str));
  ------------------
 1217|    189|    DICT_FREE(cur->encoding)
  ------------------
  |  | 1025|    189|	if ((str) && ((!dict) ||				\
  |  |  ------------------
  |  |  |  Branch (1025:6): [True: 14, False: 175]
  |  |  |  Branch (1025:16): [True: 0, False: 14]
  |  |  ------------------
  |  | 1026|     14|	    (xmlDictOwns(dict, (const xmlChar *)(str)) == 0)))	\
  |  |  ------------------
  |  |  |  Branch (1026:6): [True: 14, False: 0]
  |  |  ------------------
  |  | 1027|    189|	    xmlFree((char *)(str));
  ------------------
 1218|    189|    DICT_FREE(cur->URL)
  ------------------
  |  | 1025|    189|	if ((str) && ((!dict) ||				\
  |  |  ------------------
  |  |  |  Branch (1025:6): [True: 189, False: 0]
  |  |  |  Branch (1025:16): [True: 2, False: 187]
  |  |  ------------------
  |  | 1026|    189|	    (xmlDictOwns(dict, (const xmlChar *)(str)) == 0)))	\
  |  |  ------------------
  |  |  |  Branch (1026:6): [True: 187, False: 0]
  |  |  ------------------
  |  | 1027|    189|	    xmlFree((char *)(str));
  ------------------
 1219|    189|    xmlFree(cur);
 1220|    189|    if (dict) xmlDictFree(dict);
  ------------------
  |  Branch (1220:9): [True: 187, False: 2]
  ------------------
 1221|    189|}
xmlStringGetNodeList:
 1464|      2|xmlStringGetNodeList(const xmlDoc *doc, const xmlChar *value) {
 1465|      2|    xmlNodePtr ret = NULL, head = NULL, last = NULL;
 1466|      2|    xmlNodePtr node;
 1467|      2|    xmlChar *val = NULL;
 1468|      2|    const xmlChar *cur = value;
 1469|      2|    const xmlChar *q;
 1470|      2|    xmlEntityPtr ent;
 1471|      2|    xmlBufPtr buf;
 1472|       |
 1473|      2|    if (value == NULL) return(NULL);
  ------------------
  |  Branch (1473:9): [True: 0, False: 2]
  ------------------
 1474|       |
 1475|      2|    buf = xmlBufCreateSize(0);
 1476|      2|    if (buf == NULL) return(NULL);
  ------------------
  |  Branch (1476:9): [True: 0, False: 2]
  ------------------
 1477|      2|    xmlBufSetAllocationScheme(buf, XML_BUFFER_ALLOC_DOUBLEIT);
 1478|       |
 1479|      2|    q = cur;
 1480|     72|    while (*cur != 0) {
  ------------------
  |  Branch (1480:12): [True: 70, False: 2]
  ------------------
 1481|     70|	if (cur[0] == '&') {
  ------------------
  |  Branch (1481:6): [True: 0, False: 70]
  ------------------
 1482|      0|	    int charval = 0;
 1483|      0|	    xmlChar tmp;
 1484|       |
 1485|       |	    /*
 1486|       |	     * Save the current text.
 1487|       |	     */
 1488|      0|            if (cur != q) {
  ------------------
  |  Branch (1488:17): [True: 0, False: 0]
  ------------------
 1489|      0|		if (xmlBufAdd(buf, q, cur - q))
  ------------------
  |  Branch (1489:7): [True: 0, False: 0]
  ------------------
 1490|      0|		    goto out;
 1491|      0|	    }
 1492|      0|	    q = cur;
 1493|      0|	    if ((cur[1] == '#') && (cur[2] == 'x')) {
  ------------------
  |  Branch (1493:10): [True: 0, False: 0]
  |  Branch (1493:29): [True: 0, False: 0]
  ------------------
 1494|      0|		cur += 3;
 1495|      0|		tmp = *cur;
 1496|      0|		while (tmp != ';') { /* Non input consuming loop */
  ------------------
  |  Branch (1496:10): [True: 0, False: 0]
  ------------------
 1497|       |                    /* Don't check for integer overflow, see above. */
 1498|      0|		    if ((tmp >= '0') && (tmp <= '9'))
  ------------------
  |  Branch (1498:11): [True: 0, False: 0]
  |  Branch (1498:27): [True: 0, False: 0]
  ------------------
 1499|      0|			charval = charval * 16 + (tmp - '0');
 1500|      0|		    else if ((tmp >= 'a') && (tmp <= 'f'))
  ------------------
  |  Branch (1500:16): [True: 0, False: 0]
  |  Branch (1500:32): [True: 0, False: 0]
  ------------------
 1501|      0|			charval = charval * 16 + (tmp - 'a') + 10;
 1502|      0|		    else if ((tmp >= 'A') && (tmp <= 'F'))
  ------------------
  |  Branch (1502:16): [True: 0, False: 0]
  |  Branch (1502:32): [True: 0, False: 0]
  ------------------
 1503|      0|			charval = charval * 16 + (tmp - 'A') + 10;
 1504|      0|		    else {
 1505|      0|			xmlTreeErr(XML_TREE_INVALID_HEX, (xmlNodePtr) doc,
 1506|      0|			           NULL);
 1507|      0|			charval = 0;
 1508|      0|			break;
 1509|      0|		    }
 1510|      0|		    cur++;
 1511|      0|		    tmp = *cur;
 1512|      0|		}
 1513|      0|		if (tmp == ';')
  ------------------
  |  Branch (1513:7): [True: 0, False: 0]
  ------------------
 1514|      0|		    cur++;
 1515|      0|		q = cur;
 1516|      0|	    } else if  (cur[1] == '#') {
  ------------------
  |  Branch (1516:18): [True: 0, False: 0]
  ------------------
 1517|      0|		cur += 2;
 1518|      0|		tmp = *cur;
 1519|      0|		while (tmp != ';') { /* Non input consuming loops */
  ------------------
  |  Branch (1519:10): [True: 0, False: 0]
  ------------------
 1520|       |                    /* Don't check for integer overflow, see above. */
 1521|      0|		    if ((tmp >= '0') && (tmp <= '9'))
  ------------------
  |  Branch (1521:11): [True: 0, False: 0]
  |  Branch (1521:27): [True: 0, False: 0]
  ------------------
 1522|      0|			charval = charval * 10 + (tmp - '0');
 1523|      0|		    else {
 1524|      0|			xmlTreeErr(XML_TREE_INVALID_DEC, (xmlNodePtr) doc,
 1525|      0|			           NULL);
 1526|      0|			charval = 0;
 1527|      0|			break;
 1528|      0|		    }
 1529|      0|		    cur++;
 1530|      0|		    tmp = *cur;
 1531|      0|		}
 1532|      0|		if (tmp == ';')
  ------------------
  |  Branch (1532:7): [True: 0, False: 0]
  ------------------
 1533|      0|		    cur++;
 1534|      0|		q = cur;
 1535|      0|	    } else {
 1536|       |		/*
 1537|       |		 * Read the entity string
 1538|       |		 */
 1539|      0|		cur++;
 1540|      0|		q = cur;
 1541|      0|		while ((*cur != 0) && (*cur != ';')) cur++;
  ------------------
  |  Branch (1541:10): [True: 0, False: 0]
  |  Branch (1541:25): [True: 0, False: 0]
  ------------------
 1542|      0|		if (*cur == 0) {
  ------------------
  |  Branch (1542:7): [True: 0, False: 0]
  ------------------
 1543|      0|		    xmlTreeErr(XML_TREE_UNTERMINATED_ENTITY,
 1544|      0|		               (xmlNodePtr) doc, (const char *) q);
 1545|      0|		    goto out;
 1546|      0|		}
 1547|      0|		if (cur != q) {
  ------------------
  |  Branch (1547:7): [True: 0, False: 0]
  ------------------
 1548|       |		    /*
 1549|       |		     * Predefined entities don't generate nodes
 1550|       |		     */
 1551|      0|		    val = xmlStrndup(q, cur - q);
 1552|      0|		    ent = xmlGetDocEntity(doc, val);
 1553|      0|		    if ((ent != NULL) &&
  ------------------
  |  Branch (1553:11): [True: 0, False: 0]
  ------------------
 1554|      0|			(ent->etype == XML_INTERNAL_PREDEFINED_ENTITY)) {
  ------------------
  |  Branch (1554:4): [True: 0, False: 0]
  ------------------
 1555|       |
 1556|      0|			if (xmlBufCat(buf, ent->content))
  ------------------
  |  Branch (1556:8): [True: 0, False: 0]
  ------------------
 1557|      0|			    goto out;
 1558|       |
 1559|      0|		    } else {
 1560|       |			/*
 1561|       |			 * Flush buffer so far
 1562|       |			 */
 1563|      0|			if (!xmlBufIsEmpty(buf)) {
  ------------------
  |  Branch (1563:8): [True: 0, False: 0]
  ------------------
 1564|      0|			    node = xmlNewDocText(doc, NULL);
 1565|      0|                            if (node == NULL)
  ------------------
  |  Branch (1565:33): [True: 0, False: 0]
  ------------------
 1566|      0|                                goto out;
 1567|      0|			    node->content = xmlBufDetach(buf);
 1568|       |
 1569|      0|			    if (last == NULL) {
  ------------------
  |  Branch (1569:12): [True: 0, False: 0]
  ------------------
 1570|      0|				last = head = node;
 1571|      0|			    } else {
 1572|      0|				last = xmlAddNextSibling(last, node);
 1573|      0|			    }
 1574|      0|			}
 1575|       |
 1576|       |			/*
 1577|       |			 * Create a new REFERENCE_REF node
 1578|       |			 */
 1579|      0|			node = xmlNewReference(doc, val);
 1580|      0|			if (node == NULL)
  ------------------
  |  Branch (1580:8): [True: 0, False: 0]
  ------------------
 1581|      0|			    goto out;
 1582|      0|			if ((ent != NULL) &&
  ------------------
  |  Branch (1582:8): [True: 0, False: 0]
  ------------------
 1583|      0|                            ((ent->flags & XML_ENT_PARSED) == 0) &&
  ------------------
  |  |   14|      0|#define XML_ENT_PARSED      (1<<0)
  ------------------
  |  Branch (1583:29): [True: 0, False: 0]
  ------------------
 1584|      0|                            ((ent->flags & XML_ENT_EXPANDING) == 0)) {
  ------------------
  |  |   16|      0|#define XML_ENT_EXPANDING   (1<<2)
  ------------------
  |  Branch (1584:29): [True: 0, False: 0]
  ------------------
 1585|      0|			    xmlNodePtr temp;
 1586|       |
 1587|       |                            /*
 1588|       |                             * The entity should have been checked already,
 1589|       |                             * but set the flag anyway to avoid recursion.
 1590|       |                             */
 1591|      0|			    ent->flags |= XML_ENT_EXPANDING;
  ------------------
  |  |   16|      0|#define XML_ENT_EXPANDING   (1<<2)
  ------------------
 1592|      0|			    ent->children = xmlStringGetNodeList(doc,
 1593|      0|				    (const xmlChar*)node->content);
 1594|      0|			    ent->owner = 1;
 1595|      0|			    ent->flags &= ~XML_ENT_EXPANDING;
  ------------------
  |  |   16|      0|#define XML_ENT_EXPANDING   (1<<2)
  ------------------
 1596|      0|                            ent->flags |= XML_ENT_PARSED;
  ------------------
  |  |   14|      0|#define XML_ENT_PARSED      (1<<0)
  ------------------
 1597|      0|			    temp = ent->children;
 1598|      0|			    while (temp) {
  ------------------
  |  Branch (1598:15): [True: 0, False: 0]
  ------------------
 1599|      0|				temp->parent = (xmlNodePtr)ent;
 1600|      0|				ent->last = temp;
 1601|      0|				temp = temp->next;
 1602|      0|			    }
 1603|      0|			}
 1604|      0|			if (last == NULL) {
  ------------------
  |  Branch (1604:8): [True: 0, False: 0]
  ------------------
 1605|      0|			    last = head = node;
 1606|      0|			} else {
 1607|      0|			    last = xmlAddNextSibling(last, node);
 1608|      0|			}
 1609|      0|		    }
 1610|      0|		    xmlFree(val);
 1611|      0|                    val = NULL;
 1612|      0|		}
 1613|      0|		cur++;
 1614|      0|		q = cur;
 1615|      0|	    }
 1616|      0|	    if (charval != 0) {
  ------------------
  |  Branch (1616:10): [True: 0, False: 0]
  ------------------
 1617|      0|		xmlChar buffer[10];
 1618|      0|		int len;
 1619|       |
 1620|      0|		len = xmlCopyCharMultiByte(buffer, charval);
 1621|      0|		buffer[len] = 0;
 1622|       |
 1623|      0|		if (xmlBufCat(buf, buffer))
  ------------------
  |  Branch (1623:7): [True: 0, False: 0]
  ------------------
 1624|      0|		    goto out;
 1625|      0|		charval = 0;
 1626|      0|	    }
 1627|      0|	} else
 1628|     70|	    cur++;
 1629|     70|    }
 1630|      2|    if ((cur != q) || (head == NULL)) {
  ------------------
  |  Branch (1630:9): [True: 2, False: 0]
  |  Branch (1630:23): [True: 0, False: 0]
  ------------------
 1631|       |        /*
 1632|       |	 * Handle the last piece of text.
 1633|       |	 */
 1634|      2|	xmlBufAdd(buf, q, cur - q);
 1635|      2|    }
 1636|       |
 1637|      2|    if (!xmlBufIsEmpty(buf)) {
  ------------------
  |  Branch (1637:9): [True: 2, False: 0]
  ------------------
 1638|      2|	node = xmlNewDocText(doc, NULL);
 1639|      2|        if (node == NULL)
  ------------------
  |  Branch (1639:13): [True: 0, False: 2]
  ------------------
 1640|      0|            goto out;
 1641|      2|	node->content = xmlBufDetach(buf);
 1642|       |
 1643|      2|	if (last == NULL) {
  ------------------
  |  Branch (1643:6): [True: 2, False: 0]
  ------------------
 1644|      2|	    head = node;
 1645|      2|	} else {
 1646|      0|	    xmlAddNextSibling(last, node);
 1647|      0|	}
 1648|      2|    }
 1649|       |
 1650|      2|    ret = head;
 1651|      2|    head = NULL;
 1652|       |
 1653|      2|out:
 1654|      2|    xmlBufFree(buf);
 1655|      2|    if (val != NULL) xmlFree(val);
  ------------------
  |  Branch (1655:9): [True: 0, False: 2]
  ------------------
 1656|      2|    if (head != NULL) xmlFreeNodeList(head);
  ------------------
  |  Branch (1656:9): [True: 0, False: 2]
  ------------------
 1657|      2|    return(ret);
 1658|      2|}
xmlNodeListGetString:
 1673|      8|{
 1674|      8|    const xmlNode *node = list;
 1675|      8|    xmlChar *ret = NULL;
 1676|      8|    xmlEntityPtr ent;
 1677|      8|    int attr;
 1678|       |
 1679|      8|    if (list == NULL)
  ------------------
  |  Branch (1679:9): [True: 0, False: 8]
  ------------------
 1680|      0|        return (NULL);
 1681|      8|    if ((list->parent != NULL) && (list->parent->type == XML_ATTRIBUTE_NODE))
  ------------------
  |  Branch (1681:9): [True: 8, False: 0]
  |  Branch (1681:35): [True: 8, False: 0]
  ------------------
 1682|      8|        attr = 1;
 1683|      0|    else
 1684|      0|        attr = 0;
 1685|       |
 1686|     16|    while (node != NULL) {
  ------------------
  |  Branch (1686:12): [True: 8, False: 8]
  ------------------
 1687|      8|        if ((node->type == XML_TEXT_NODE) ||
  ------------------
  |  Branch (1687:13): [True: 8, False: 0]
  ------------------
 1688|      8|            (node->type == XML_CDATA_SECTION_NODE)) {
  ------------------
  |  Branch (1688:13): [True: 0, False: 0]
  ------------------
 1689|      8|            if (inLine) {
  ------------------
  |  Branch (1689:17): [True: 8, False: 0]
  ------------------
 1690|      8|                ret = xmlStrcat(ret, node->content);
 1691|      8|            } else {
 1692|      0|                xmlChar *buffer;
 1693|       |
 1694|      0|		if (attr)
  ------------------
  |  Branch (1694:7): [True: 0, False: 0]
  ------------------
 1695|      0|		    buffer = xmlEncodeAttributeEntities(doc, node->content);
 1696|      0|		else
 1697|      0|		    buffer = xmlEncodeEntitiesReentrant(doc, node->content);
 1698|      0|                if (buffer != NULL) {
  ------------------
  |  Branch (1698:21): [True: 0, False: 0]
  ------------------
 1699|      0|                    ret = xmlStrcat(ret, buffer);
 1700|      0|                    xmlFree(buffer);
 1701|      0|                }
 1702|      0|            }
 1703|      8|        } else if (node->type == XML_ENTITY_REF_NODE) {
  ------------------
  |  Branch (1703:20): [True: 0, False: 0]
  ------------------
 1704|      0|            if (inLine) {
  ------------------
  |  Branch (1704:17): [True: 0, False: 0]
  ------------------
 1705|      0|                ent = xmlGetDocEntity(doc, node->name);
 1706|      0|                if (ent != NULL) {
  ------------------
  |  Branch (1706:21): [True: 0, False: 0]
  ------------------
 1707|      0|                    xmlChar *buffer;
 1708|       |
 1709|       |                    /* an entity content can be any "well balanced chunk",
 1710|       |                     * i.e. the result of the content [43] production:
 1711|       |                     * http://www.w3.org/TR/REC-xml#NT-content.
 1712|       |                     * So it can contain text, CDATA section or nested
 1713|       |                     * entity reference nodes (among others).
 1714|       |                     * -> we recursive  call xmlNodeListGetString()
 1715|       |                     * which handles these types */
 1716|      0|                    buffer = xmlNodeListGetString(doc, ent->children, 1);
 1717|      0|                    if (buffer != NULL) {
  ------------------
  |  Branch (1717:25): [True: 0, False: 0]
  ------------------
 1718|      0|                        ret = xmlStrcat(ret, buffer);
 1719|      0|                        xmlFree(buffer);
 1720|      0|                    }
 1721|      0|                } else {
 1722|      0|                    ret = xmlStrcat(ret, node->content);
 1723|      0|                }
 1724|      0|            } else {
 1725|      0|                xmlChar buf[2];
 1726|       |
 1727|      0|                buf[0] = '&';
 1728|      0|                buf[1] = 0;
 1729|      0|                ret = xmlStrncat(ret, buf, 1);
 1730|      0|                ret = xmlStrcat(ret, node->name);
 1731|      0|                buf[0] = ';';
 1732|      0|                buf[1] = 0;
 1733|      0|                ret = xmlStrncat(ret, buf, 1);
 1734|      0|            }
 1735|      0|        }
 1736|       |#if 0
 1737|       |        else {
 1738|       |            xmlGenericError(xmlGenericErrorContext,
 1739|       |                            "xmlGetNodeListString : invalid node type %d\n",
 1740|       |                            node->type);
 1741|       |        }
 1742|       |#endif
 1743|      8|        node = node->next;
 1744|      8|    }
 1745|      8|    return (ret);
 1746|      8|}
xmlNewNsPropEatName:
 1973|      2|           const xmlChar *value) {
 1974|       |
 1975|      2|    if (name == NULL) {
  ------------------
  |  Branch (1975:9): [True: 0, False: 2]
  ------------------
 1976|      0|	return(NULL);
 1977|      0|    }
 1978|       |
 1979|      2|    return xmlNewPropInternal(node, ns, name, value, 1);
 1980|      2|}
xmlNewDocProp:
 1997|     12|xmlNewDocProp(xmlDocPtr doc, const xmlChar *name, const xmlChar *value) {
 1998|     12|    xmlAttrPtr cur;
 1999|       |
 2000|     12|    if (name == NULL) {
  ------------------
  |  Branch (2000:9): [True: 0, False: 12]
  ------------------
 2001|      0|	return(NULL);
 2002|      0|    }
 2003|       |
 2004|       |    /*
 2005|       |     * Allocate a new property and fill the fields.
 2006|       |     */
 2007|     12|    cur = (xmlAttrPtr) xmlMalloc(sizeof(xmlAttr));
 2008|     12|    if (cur == NULL) {
  ------------------
  |  Branch (2008:9): [True: 0, False: 12]
  ------------------
 2009|      0|	xmlTreeErrMemory("building attribute");
 2010|      0|	return(NULL);
 2011|      0|    }
 2012|     12|    memset(cur, 0, sizeof(xmlAttr));
 2013|     12|    cur->type = XML_ATTRIBUTE_NODE;
 2014|       |
 2015|     12|    if ((doc != NULL) && (doc->dict != NULL))
  ------------------
  |  Branch (2015:9): [True: 12, False: 0]
  |  Branch (2015:26): [True: 12, False: 0]
  ------------------
 2016|     12|	cur->name = xmlDictLookup(doc->dict, name, -1);
 2017|      0|    else
 2018|      0|	cur->name = xmlStrdup(name);
 2019|     12|    cur->doc = doc;
 2020|     12|    if (value != NULL) {
  ------------------
  |  Branch (2020:9): [True: 0, False: 12]
  ------------------
 2021|      0|	xmlNodePtr tmp;
 2022|       |
 2023|      0|	cur->children = xmlStringGetNodeList(doc, value);
 2024|      0|	cur->last = NULL;
 2025|       |
 2026|      0|	tmp = cur->children;
 2027|      0|	while (tmp != NULL) {
  ------------------
  |  Branch (2027:9): [True: 0, False: 0]
  ------------------
 2028|      0|	    tmp->parent = (xmlNodePtr) cur;
 2029|      0|	    if (tmp->next == NULL)
  ------------------
  |  Branch (2029:10): [True: 0, False: 0]
  ------------------
 2030|      0|		cur->last = tmp;
 2031|      0|	    tmp = tmp->next;
 2032|      0|	}
 2033|      0|    }
 2034|       |
 2035|     12|    if ((__xmlRegisterCallbacks) && (xmlRegisterNodeDefaultValue))
  ------------------
  |  |  682|      0|    XML_GLOBAL_MACRO(xmlRegisterNodeDefaultValue)
  |  |  ------------------
  |  |  |  |  500|      0|  #define XML_GLOBAL_MACRO(name) (*__##name())
  |  |  ------------------
  ------------------
  |  Branch (2035:9): [True: 0, False: 12]
  |  Branch (2035:37): [True: 0, False: 0]
  ------------------
 2036|      0|	xmlRegisterNodeDefaultValue((xmlNodePtr)cur);
  ------------------
  |  |  682|      0|    XML_GLOBAL_MACRO(xmlRegisterNodeDefaultValue)
  |  |  ------------------
  |  |  |  |  500|      0|  #define XML_GLOBAL_MACRO(name) (*__##name())
  |  |  ------------------
  ------------------
 2037|     12|    return(cur);
 2038|     12|}
xmlFreePropList:
 2047|    510|xmlFreePropList(xmlAttrPtr cur) {
 2048|    510|    xmlAttrPtr next;
 2049|    510|    if (cur == NULL) return;
  ------------------
  |  Branch (2049:9): [True: 0, False: 510]
  ------------------
 2050|  1.03k|    while (cur != NULL) {
  ------------------
  |  Branch (2050:12): [True: 523, False: 510]
  ------------------
 2051|    523|        next = cur->next;
 2052|    523|        xmlFreeProp(cur);
 2053|    523|	cur = next;
 2054|    523|    }
 2055|    510|}
xmlFreeProp:
 2064|    549|xmlFreeProp(xmlAttrPtr cur) {
 2065|    549|    xmlDictPtr dict = NULL;
 2066|    549|    if (cur == NULL) return;
  ------------------
  |  Branch (2066:9): [True: 0, False: 549]
  ------------------
 2067|       |
 2068|    549|    if (cur->doc != NULL) dict = cur->doc->dict;
  ------------------
  |  Branch (2068:9): [True: 549, False: 0]
  ------------------
 2069|       |
 2070|    549|    if ((__xmlRegisterCallbacks) && (xmlDeregisterNodeDefaultValue))
  ------------------
  |  |  684|      0|    XML_GLOBAL_MACRO(xmlDeregisterNodeDefaultValue)
  |  |  ------------------
  |  |  |  |  500|      0|  #define XML_GLOBAL_MACRO(name) (*__##name())
  |  |  ------------------
  ------------------
  |  Branch (2070:9): [True: 0, False: 549]
  |  Branch (2070:37): [True: 0, False: 0]
  ------------------
 2071|      0|	xmlDeregisterNodeDefaultValue((xmlNodePtr)cur);
  ------------------
  |  |  684|      0|    XML_GLOBAL_MACRO(xmlDeregisterNodeDefaultValue)
  |  |  ------------------
  |  |  |  |  500|      0|  #define XML_GLOBAL_MACRO(name) (*__##name())
  |  |  ------------------
  ------------------
 2072|       |
 2073|       |    /* Check for ID removal -> leading to invalid references ! */
 2074|    549|    if ((cur->doc != NULL) && (cur->atype == XML_ATTRIBUTE_ID)) {
  ------------------
  |  Branch (2074:9): [True: 549, False: 0]
  |  Branch (2074:31): [True: 20, False: 529]
  ------------------
 2075|     20|	    xmlRemoveID(cur->doc, cur);
 2076|     20|    }
 2077|    549|    if (cur->children != NULL) xmlFreeNodeList(cur->children);
  ------------------
  |  Branch (2077:9): [True: 549, False: 0]
  ------------------
 2078|    549|    DICT_FREE(cur->name)
  ------------------
  |  | 1025|    549|	if ((str) && ((!dict) ||				\
  |  |  ------------------
  |  |  |  Branch (1025:6): [True: 549, False: 0]
  |  |  |  Branch (1025:16): [True: 1, False: 548]
  |  |  ------------------
  |  | 1026|    549|	    (xmlDictOwns(dict, (const xmlChar *)(str)) == 0)))	\
  |  |  ------------------
  |  |  |  Branch (1026:6): [True: 0, False: 548]
  |  |  ------------------
  |  | 1027|    549|	    xmlFree((char *)(str));
  ------------------
 2079|    549|    xmlFree(cur);
 2080|    549|}
xmlNewDocPI:
 2131|      2|xmlNewDocPI(xmlDocPtr doc, const xmlChar *name, const xmlChar *content) {
 2132|      2|    xmlNodePtr cur;
 2133|       |
 2134|      2|    if (name == NULL) {
  ------------------
  |  Branch (2134:9): [True: 0, False: 2]
  ------------------
 2135|      0|	return(NULL);
 2136|      0|    }
 2137|       |
 2138|       |    /*
 2139|       |     * Allocate a new node and fill the fields.
 2140|       |     */
 2141|      2|    cur = (xmlNodePtr) xmlMalloc(sizeof(xmlNode));
 2142|      2|    if (cur == NULL) {
  ------------------
  |  Branch (2142:9): [True: 0, False: 2]
  ------------------
 2143|      0|	xmlTreeErrMemory("building PI");
 2144|      0|	return(NULL);
 2145|      0|    }
 2146|      2|    memset(cur, 0, sizeof(xmlNode));
 2147|      2|    cur->type = XML_PI_NODE;
 2148|       |
 2149|      2|    if ((doc != NULL) && (doc->dict != NULL))
  ------------------
  |  Branch (2149:9): [True: 2, False: 0]
  |  Branch (2149:26): [True: 2, False: 0]
  ------------------
 2150|      2|        cur->name = xmlDictLookup(doc->dict, name, -1);
 2151|      0|    else
 2152|      0|	cur->name = xmlStrdup(name);
 2153|      2|    if (content != NULL) {
  ------------------
  |  Branch (2153:9): [True: 2, False: 0]
  ------------------
 2154|      2|	cur->content = xmlStrdup(content);
 2155|      2|    }
 2156|      2|    cur->doc = doc;
 2157|       |
 2158|      2|    if ((__xmlRegisterCallbacks) && (xmlRegisterNodeDefaultValue))
  ------------------
  |  |  682|      0|    XML_GLOBAL_MACRO(xmlRegisterNodeDefaultValue)
  |  |  ------------------
  |  |  |  |  500|      0|  #define XML_GLOBAL_MACRO(name) (*__##name())
  |  |  ------------------
  ------------------
  |  Branch (2158:9): [True: 0, False: 2]
  |  Branch (2158:37): [True: 0, False: 0]
  ------------------
 2159|      0|	xmlRegisterNodeDefaultValue((xmlNodePtr)cur);
  ------------------
  |  |  682|      0|    XML_GLOBAL_MACRO(xmlRegisterNodeDefaultValue)
  |  |  ------------------
  |  |  |  |  500|      0|  #define XML_GLOBAL_MACRO(name) (*__##name())
  |  |  ------------------
  ------------------
 2160|      2|    return(cur);
 2161|      2|}
xmlNewNodeEatName:
 2232|  2.24k|xmlNewNodeEatName(xmlNsPtr ns, xmlChar *name) {
 2233|  2.24k|    xmlNodePtr cur;
 2234|       |
 2235|  2.24k|    if (name == NULL) {
  ------------------
  |  Branch (2235:9): [True: 0, False: 2.24k]
  ------------------
 2236|      0|	return(NULL);
 2237|      0|    }
 2238|       |
 2239|       |    /*
 2240|       |     * Allocate a new node and fill the fields.
 2241|       |     */
 2242|  2.24k|    cur = (xmlNodePtr) xmlMalloc(sizeof(xmlNode));
 2243|  2.24k|    if (cur == NULL) {
  ------------------
  |  Branch (2243:9): [True: 0, False: 2.24k]
  ------------------
 2244|      0|	xmlTreeErrMemory("building node");
 2245|       |	/* we can't check here that name comes from the doc dictionary */
 2246|      0|	return(NULL);
 2247|      0|    }
 2248|  2.24k|    memset(cur, 0, sizeof(xmlNode));
 2249|  2.24k|    cur->type = XML_ELEMENT_NODE;
 2250|       |
 2251|  2.24k|    cur->name = name;
 2252|  2.24k|    cur->ns = ns;
 2253|       |
 2254|  2.24k|    if ((__xmlRegisterCallbacks) && (xmlRegisterNodeDefaultValue))
  ------------------
  |  |  682|      0|    XML_GLOBAL_MACRO(xmlRegisterNodeDefaultValue)
  |  |  ------------------
  |  |  |  |  500|      0|  #define XML_GLOBAL_MACRO(name) (*__##name())
  |  |  ------------------
  ------------------
  |  Branch (2254:9): [True: 0, False: 2.24k]
  |  Branch (2254:37): [True: 0, False: 0]
  ------------------
 2255|      0|	xmlRegisterNodeDefaultValue((xmlNodePtr)cur);
  ------------------
  |  |  682|      0|    XML_GLOBAL_MACRO(xmlRegisterNodeDefaultValue)
  |  |  ------------------
  |  |  |  |  500|      0|  #define XML_GLOBAL_MACRO(name) (*__##name())
  |  |  ------------------
  ------------------
 2256|  2.24k|    return(cur);
 2257|  2.24k|}
xmlNewDocNode:
 2277|     65|              const xmlChar *name, const xmlChar *content) {
 2278|     65|    xmlNodePtr cur;
 2279|       |
 2280|     65|    if ((doc != NULL) && (doc->dict != NULL))
  ------------------
  |  Branch (2280:9): [True: 65, False: 0]
  |  Branch (2280:26): [True: 65, False: 0]
  ------------------
 2281|     65|        cur = xmlNewNodeEatName(ns, (xmlChar *)
 2282|     65|	                        xmlDictLookup(doc->dict, name, -1));
 2283|      0|    else
 2284|      0|	cur = xmlNewNode(ns, name);
 2285|     65|    if (cur != NULL) {
  ------------------
  |  Branch (2285:9): [True: 65, False: 0]
  ------------------
 2286|     65|        cur->doc = doc;
 2287|     65|	if (content != NULL) {
  ------------------
  |  Branch (2287:6): [True: 0, False: 65]
  ------------------
 2288|      0|	    cur->children = xmlStringGetNodeList(doc, content);
 2289|      0|	    UPDATE_LAST_CHILD_AND_PARENT(cur)
  ------------------
  |  |  127|      0|#define UPDATE_LAST_CHILD_AND_PARENT(n) if ((n) != NULL) {		\
  |  |  ------------------
  |  |  |  Branch (127:45): [True: 0, False: 0]
  |  |  ------------------
  |  |  128|      0|    xmlNodePtr ulccur = (n)->children;					\
  |  |  129|      0|    if (ulccur == NULL) {						\
  |  |  ------------------
  |  |  |  Branch (129:9): [True: 0, False: 0]
  |  |  ------------------
  |  |  130|      0|        (n)->last = NULL;						\
  |  |  131|      0|    } else {								\
  |  |  132|      0|        while (ulccur->next != NULL) {					\
  |  |  ------------------
  |  |  |  Branch (132:16): [True: 0, False: 0]
  |  |  ------------------
  |  |  133|      0|		ulccur->parent = (n);					\
  |  |  134|      0|		ulccur = ulccur->next;					\
  |  |  135|      0|	}								\
  |  |  136|      0|	ulccur->parent = (n);						\
  |  |  137|      0|	(n)->last = ulccur;						\
  |  |  138|      0|}}
  ------------------
 2290|      0|	}
 2291|     65|    }
 2292|       |
 2293|     65|    return(cur);
 2294|     65|}
xmlNewDocNodeEatName:
 2314|  2.18k|              xmlChar *name, const xmlChar *content) {
 2315|  2.18k|    xmlNodePtr cur;
 2316|       |
 2317|  2.18k|    cur = xmlNewNodeEatName(ns, name);
 2318|  2.18k|    if (cur != NULL) {
  ------------------
  |  Branch (2318:9): [True: 2.18k, False: 0]
  ------------------
 2319|  2.18k|        cur->doc = doc;
 2320|  2.18k|	if (content != NULL) {
  ------------------
  |  Branch (2320:6): [True: 0, False: 2.18k]
  ------------------
 2321|      0|	    cur->children = xmlStringGetNodeList(doc, content);
 2322|      0|	    UPDATE_LAST_CHILD_AND_PARENT(cur)
  ------------------
  |  |  127|      0|#define UPDATE_LAST_CHILD_AND_PARENT(n) if ((n) != NULL) {		\
  |  |  ------------------
  |  |  |  Branch (127:45): [True: 0, False: 0]
  |  |  ------------------
  |  |  128|      0|    xmlNodePtr ulccur = (n)->children;					\
  |  |  129|      0|    if (ulccur == NULL) {						\
  |  |  ------------------
  |  |  |  Branch (129:9): [True: 0, False: 0]
  |  |  ------------------
  |  |  130|      0|        (n)->last = NULL;						\
  |  |  131|      0|    } else {								\
  |  |  132|      0|        while (ulccur->next != NULL) {					\
  |  |  ------------------
  |  |  |  Branch (132:16): [True: 0, False: 0]
  |  |  ------------------
  |  |  133|      0|		ulccur->parent = (n);					\
  |  |  134|      0|		ulccur = ulccur->next;					\
  |  |  135|      0|	}								\
  |  |  136|      0|	ulccur->parent = (n);						\
  |  |  137|      0|	(n)->last = ulccur;						\
  |  |  138|      0|}}
  ------------------
 2323|      0|	}
 2324|  2.18k|    } else {
 2325|       |        /* if name don't come from the doc dictionary free it here */
 2326|      0|        if ((name != NULL) &&
  ------------------
  |  Branch (2326:13): [True: 0, False: 0]
  ------------------
 2327|      0|            ((doc == NULL) || (doc->dict == NULL) ||
  ------------------
  |  Branch (2327:14): [True: 0, False: 0]
  |  Branch (2327:31): [True: 0, False: 0]
  ------------------
 2328|      0|	     (!(xmlDictOwns(doc->dict, name)))))
  ------------------
  |  Branch (2328:7): [True: 0, False: 0]
  ------------------
 2329|      0|	    xmlFree(name);
 2330|      0|    }
 2331|  2.18k|    return(cur);
 2332|  2.18k|}
xmlNewText:
 2404|     87|xmlNewText(const xmlChar *content) {
 2405|     87|    xmlNodePtr cur;
 2406|       |
 2407|       |    /*
 2408|       |     * Allocate a new node and fill the fields.
 2409|       |     */
 2410|     87|    cur = (xmlNodePtr) xmlMalloc(sizeof(xmlNode));
 2411|     87|    if (cur == NULL) {
  ------------------
  |  Branch (2411:9): [True: 0, False: 87]
  ------------------
 2412|      0|	xmlTreeErrMemory("building text");
 2413|      0|	return(NULL);
 2414|      0|    }
 2415|     87|    memset(cur, 0, sizeof(xmlNode));
 2416|     87|    cur->type = XML_TEXT_NODE;
 2417|       |
 2418|     87|    cur->name = xmlStringText;
 2419|     87|    if (content != NULL) {
  ------------------
  |  Branch (2419:9): [True: 75, False: 12]
  ------------------
 2420|     75|	cur->content = xmlStrdup(content);
 2421|     75|    }
 2422|       |
 2423|     87|    if ((__xmlRegisterCallbacks) && (xmlRegisterNodeDefaultValue))
  ------------------
  |  |  682|      0|    XML_GLOBAL_MACRO(xmlRegisterNodeDefaultValue)
  |  |  ------------------
  |  |  |  |  500|      0|  #define XML_GLOBAL_MACRO(name) (*__##name())
  |  |  ------------------
  ------------------
  |  Branch (2423:9): [True: 0, False: 87]
  |  Branch (2423:37): [True: 0, False: 0]
  ------------------
 2424|      0|	xmlRegisterNodeDefaultValue(cur);
  ------------------
  |  |  682|      0|    XML_GLOBAL_MACRO(xmlRegisterNodeDefaultValue)
  |  |  ------------------
  |  |  |  |  500|      0|  #define XML_GLOBAL_MACRO(name) (*__##name())
  |  |  ------------------
  ------------------
 2425|     87|    return(cur);
 2426|     87|}
xmlNewDocText:
 2610|     87|xmlNewDocText(const xmlDoc *doc, const xmlChar *content) {
 2611|     87|    xmlNodePtr cur;
 2612|       |
 2613|     87|    cur = xmlNewText(content);
 2614|     87|    if (cur != NULL) cur->doc = (xmlDoc *)doc;
  ------------------
  |  Branch (2614:9): [True: 87, False: 0]
  ------------------
 2615|     87|    return(cur);
 2616|     87|}
xmlNewComment:
 2682|     38|xmlNewComment(const xmlChar *content) {
 2683|     38|    xmlNodePtr cur;
 2684|       |
 2685|       |    /*
 2686|       |     * Allocate a new node and fill the fields.
 2687|       |     */
 2688|     38|    cur = (xmlNodePtr) xmlMalloc(sizeof(xmlNode));
 2689|     38|    if (cur == NULL) {
  ------------------
  |  Branch (2689:9): [True: 0, False: 38]
  ------------------
 2690|      0|	xmlTreeErrMemory("building comment");
 2691|      0|	return(NULL);
 2692|      0|    }
 2693|     38|    memset(cur, 0, sizeof(xmlNode));
 2694|     38|    cur->type = XML_COMMENT_NODE;
 2695|       |
 2696|     38|    cur->name = xmlStringComment;
 2697|     38|    if (content != NULL) {
  ------------------
  |  Branch (2697:9): [True: 38, False: 0]
  ------------------
 2698|     38|	cur->content = xmlStrdup(content);
 2699|     38|    }
 2700|       |
 2701|     38|    if ((__xmlRegisterCallbacks) && (xmlRegisterNodeDefaultValue))
  ------------------
  |  |  682|      0|    XML_GLOBAL_MACRO(xmlRegisterNodeDefaultValue)
  |  |  ------------------
  |  |  |  |  500|      0|  #define XML_GLOBAL_MACRO(name) (*__##name())
  |  |  ------------------
  ------------------
  |  Branch (2701:9): [True: 0, False: 38]
  |  Branch (2701:37): [True: 0, False: 0]
  ------------------
 2702|      0|	xmlRegisterNodeDefaultValue(cur);
  ------------------
  |  |  682|      0|    XML_GLOBAL_MACRO(xmlRegisterNodeDefaultValue)
  |  |  ------------------
  |  |  |  |  500|      0|  #define XML_GLOBAL_MACRO(name) (*__##name())
  |  |  ------------------
  ------------------
 2703|     38|    return(cur);
 2704|     38|}
xmlNewDocComment:
 2749|     38|xmlNewDocComment(xmlDocPtr doc, const xmlChar *content) {
 2750|     38|    xmlNodePtr cur;
 2751|       |
 2752|     38|    cur = xmlNewComment(content);
 2753|     38|    if (cur != NULL) cur->doc = doc;
  ------------------
  |  Branch (2753:9): [True: 38, False: 0]
  ------------------
 2754|     38|    return(cur);
 2755|     38|}
xmlAddNextSibling:
 2999|     65|xmlAddNextSibling(xmlNodePtr cur, xmlNodePtr elem) {
 3000|     65|    if ((cur == NULL) || (cur->type == XML_NAMESPACE_DECL)) {
  ------------------
  |  Branch (3000:9): [True: 0, False: 65]
  |  Branch (3000:26): [True: 0, False: 65]
  ------------------
 3001|      0|	return(NULL);
 3002|      0|    }
 3003|     65|    if ((elem == NULL) || (elem->type == XML_NAMESPACE_DECL)) {
  ------------------
  |  Branch (3003:9): [True: 0, False: 65]
  |  Branch (3003:27): [True: 0, False: 65]
  ------------------
 3004|      0|	return(NULL);
 3005|      0|    }
 3006|       |
 3007|     65|    if (cur == elem) {
  ------------------
  |  Branch (3007:9): [True: 0, False: 65]
  ------------------
 3008|      0|	return(NULL);
 3009|      0|    }
 3010|       |
 3011|     65|    xmlUnlinkNode(elem);
 3012|       |
 3013|     65|    if (elem->type == XML_TEXT_NODE) {
  ------------------
  |  Branch (3013:9): [True: 0, False: 65]
  ------------------
 3014|      0|	if (cur->type == XML_TEXT_NODE) {
  ------------------
  |  Branch (3014:6): [True: 0, False: 0]
  ------------------
 3015|      0|	    xmlNodeAddContent(cur, elem->content);
 3016|      0|	    xmlFreeNode(elem);
 3017|      0|	    return(cur);
 3018|      0|	}
 3019|      0|	if ((cur->next != NULL) && (cur->next->type == XML_TEXT_NODE) &&
  ------------------
  |  Branch (3019:6): [True: 0, False: 0]
  |  Branch (3019:29): [True: 0, False: 0]
  ------------------
 3020|      0|            (cur->name == cur->next->name)) {
  ------------------
  |  Branch (3020:13): [True: 0, False: 0]
  ------------------
 3021|      0|	    xmlChar *tmp;
 3022|       |
 3023|      0|	    tmp = xmlStrdup(elem->content);
 3024|      0|	    tmp = xmlStrcat(tmp, cur->next->content);
 3025|      0|	    xmlNodeSetContent(cur->next, tmp);
 3026|      0|	    xmlFree(tmp);
 3027|      0|	    xmlFreeNode(elem);
 3028|      0|	    return(cur->next);
 3029|      0|	}
 3030|     65|    } else if (elem->type == XML_ATTRIBUTE_NODE) {
  ------------------
  |  Branch (3030:16): [True: 0, False: 65]
  ------------------
 3031|      0|		return xmlAddPropSibling(cur, cur, elem);
 3032|      0|    }
 3033|       |
 3034|     65|    if (elem->doc != cur->doc) {
  ------------------
  |  Branch (3034:9): [True: 0, False: 65]
  ------------------
 3035|      0|	xmlSetTreeDoc(elem, cur->doc);
 3036|      0|    }
 3037|     65|    elem->parent = cur->parent;
 3038|     65|    elem->prev = cur;
 3039|     65|    elem->next = cur->next;
 3040|     65|    cur->next = elem;
 3041|     65|    if (elem->next != NULL)
  ------------------
  |  Branch (3041:9): [True: 52, False: 13]
  ------------------
 3042|     52|	elem->next->prev = elem;
 3043|     65|    if ((elem->parent != NULL) && (elem->parent->last == cur))
  ------------------
  |  Branch (3043:9): [True: 65, False: 0]
  |  Branch (3043:35): [True: 13, False: 52]
  ------------------
 3044|     13|	elem->parent->last = elem;
 3045|     65|    return(elem);
 3046|     65|}
xmlAddPrevSibling:
 3067|    275|xmlAddPrevSibling(xmlNodePtr cur, xmlNodePtr elem) {
 3068|    275|    if ((cur == NULL) || (cur->type == XML_NAMESPACE_DECL)) {
  ------------------
  |  Branch (3068:9): [True: 0, False: 275]
  |  Branch (3068:26): [True: 0, False: 275]
  ------------------
 3069|      0|	return(NULL);
 3070|      0|    }
 3071|    275|    if ((elem == NULL) || (elem->type == XML_NAMESPACE_DECL)) {
  ------------------
  |  Branch (3071:9): [True: 0, False: 275]
  |  Branch (3071:27): [True: 0, False: 275]
  ------------------
 3072|      0|	return(NULL);
 3073|      0|    }
 3074|       |
 3075|    275|    if (cur == elem) {
  ------------------
  |  Branch (3075:9): [True: 0, False: 275]
  ------------------
 3076|      0|	return(NULL);
 3077|      0|    }
 3078|       |
 3079|    275|    xmlUnlinkNode(elem);
 3080|       |
 3081|    275|    if (elem->type == XML_TEXT_NODE) {
  ------------------
  |  Branch (3081:9): [True: 181, False: 94]
  ------------------
 3082|    181|	if (cur->type == XML_TEXT_NODE) {
  ------------------
  |  Branch (3082:6): [True: 0, False: 181]
  ------------------
 3083|      0|	    xmlChar *tmp;
 3084|       |
 3085|      0|	    tmp = xmlStrdup(elem->content);
 3086|      0|	    tmp = xmlStrcat(tmp, cur->content);
 3087|      0|	    xmlNodeSetContent(cur, tmp);
 3088|      0|	    xmlFree(tmp);
 3089|      0|	    xmlFreeNode(elem);
 3090|      0|	    return(cur);
 3091|      0|	}
 3092|    181|	if ((cur->prev != NULL) && (cur->prev->type == XML_TEXT_NODE) &&
  ------------------
  |  Branch (3092:6): [True: 181, False: 0]
  |  Branch (3092:29): [True: 94, False: 87]
  ------------------
 3093|    181|            (cur->name == cur->prev->name)) {
  ------------------
  |  Branch (3093:13): [True: 0, False: 94]
  ------------------
 3094|      0|	    xmlNodeAddContent(cur->prev, elem->content);
 3095|      0|	    xmlFreeNode(elem);
 3096|      0|	    return(cur->prev);
 3097|      0|	}
 3098|    181|    } else if (elem->type == XML_ATTRIBUTE_NODE) {
  ------------------
  |  Branch (3098:16): [True: 0, False: 94]
  ------------------
 3099|      0|		return xmlAddPropSibling(cur->prev, cur, elem);
 3100|      0|    }
 3101|       |
 3102|    275|    if (elem->doc != cur->doc) {
  ------------------
  |  Branch (3102:9): [True: 0, False: 275]
  ------------------
 3103|      0|	xmlSetTreeDoc(elem, cur->doc);
 3104|      0|    }
 3105|    275|    elem->parent = cur->parent;
 3106|    275|    elem->next = cur;
 3107|    275|    elem->prev = cur->prev;
 3108|    275|    cur->prev = elem;
 3109|    275|    if (elem->prev != NULL)
  ------------------
  |  Branch (3109:9): [True: 275, False: 0]
  ------------------
 3110|    275|	elem->prev->next = elem;
 3111|    275|    if ((elem->parent != NULL) && (elem->parent->children == cur)) {
  ------------------
  |  Branch (3111:9): [True: 275, False: 0]
  |  Branch (3111:35): [True: 0, False: 275]
  ------------------
 3112|      0|		elem->parent->children = elem;
 3113|      0|    }
 3114|    275|    return(elem);
 3115|    275|}
xmlAddChild:
 3279|  4.10k|xmlAddChild(xmlNodePtr parent, xmlNodePtr cur) {
 3280|  4.10k|    xmlNodePtr prev;
 3281|       |
 3282|  4.10k|    if ((parent == NULL) || (parent->type == XML_NAMESPACE_DECL)) {
  ------------------
  |  Branch (3282:9): [True: 0, False: 4.10k]
  |  Branch (3282:29): [True: 0, False: 4.10k]
  ------------------
 3283|      0|	return(NULL);
 3284|      0|    }
 3285|       |
 3286|  4.10k|    if ((cur == NULL) || (cur->type == XML_NAMESPACE_DECL)) {
  ------------------
  |  Branch (3286:9): [True: 0, False: 4.10k]
  |  Branch (3286:26): [True: 0, False: 4.10k]
  ------------------
 3287|      0|	return(NULL);
 3288|      0|    }
 3289|       |
 3290|  4.10k|    if (parent == cur) {
  ------------------
  |  Branch (3290:9): [True: 0, False: 4.10k]
  ------------------
 3291|      0|	return(NULL);
 3292|      0|    }
 3293|       |    /*
 3294|       |     * If cur is a TEXT node, merge its content with adjacent TEXT nodes
 3295|       |     * cur is then freed.
 3296|       |     */
 3297|  4.10k|    if (cur->type == XML_TEXT_NODE) {
  ------------------
  |  Branch (3297:9): [True: 1.30k, False: 2.80k]
  ------------------
 3298|  1.30k|	if ((parent->type == XML_TEXT_NODE) &&
  ------------------
  |  Branch (3298:6): [True: 0, False: 1.30k]
  ------------------
 3299|  1.30k|	    (parent->content != NULL) &&
  ------------------
  |  Branch (3299:6): [True: 0, False: 0]
  ------------------
 3300|  1.30k|	    (parent->name == cur->name)) {
  ------------------
  |  Branch (3300:6): [True: 0, False: 0]
  ------------------
 3301|      0|	    xmlNodeAddContent(parent, cur->content);
 3302|      0|	    xmlFreeNode(cur);
 3303|      0|	    return(parent);
 3304|      0|	}
 3305|  1.30k|	if ((parent->last != NULL) && (parent->last->type == XML_TEXT_NODE) &&
  ------------------
  |  Branch (3305:6): [True: 1.20k, False: 94]
  |  Branch (3305:32): [True: 0, False: 1.20k]
  ------------------
 3306|  1.30k|	    (parent->last->name == cur->name) &&
  ------------------
  |  Branch (3306:6): [True: 0, False: 0]
  ------------------
 3307|  1.30k|	    (parent->last != cur)) {
  ------------------
  |  Branch (3307:6): [True: 0, False: 0]
  ------------------
 3308|      0|	    xmlNodeAddContent(parent->last, cur->content);
 3309|      0|	    xmlFreeNode(cur);
 3310|      0|	    return(parent->last);
 3311|      0|	}
 3312|  1.30k|    }
 3313|       |
 3314|       |    /*
 3315|       |     * add the new element at the end of the children list.
 3316|       |     */
 3317|  4.10k|    prev = cur->parent;
 3318|  4.10k|    cur->parent = parent;
 3319|  4.10k|    if (cur->doc != parent->doc) {
  ------------------
  |  Branch (3319:9): [True: 0, False: 4.10k]
  ------------------
 3320|      0|	xmlSetTreeDoc(cur, parent->doc);
 3321|      0|    }
 3322|       |    /* this check prevents a loop on tree-traversions if a developer
 3323|       |     * tries to add a node to its parent multiple times
 3324|       |     */
 3325|  4.10k|    if (prev == parent)
  ------------------
  |  Branch (3325:9): [True: 686, False: 3.42k]
  ------------------
 3326|    686|	return(cur);
 3327|       |
 3328|       |    /*
 3329|       |     * Coalescing
 3330|       |     */
 3331|  3.42k|    if ((parent->type == XML_TEXT_NODE) &&
  ------------------
  |  Branch (3331:9): [True: 0, False: 3.42k]
  ------------------
 3332|  3.42k|	(parent->content != NULL) &&
  ------------------
  |  Branch (3332:2): [True: 0, False: 0]
  ------------------
 3333|  3.42k|	(parent != cur)) {
  ------------------
  |  Branch (3333:2): [True: 0, False: 0]
  ------------------
 3334|      0|	xmlNodeAddContent(parent, cur->content);
 3335|      0|	xmlFreeNode(cur);
 3336|      0|	return(parent);
 3337|      0|    }
 3338|  3.42k|    if (cur->type == XML_ATTRIBUTE_NODE) {
  ------------------
  |  Branch (3338:9): [True: 0, False: 3.42k]
  ------------------
 3339|      0|		if (parent->type != XML_ELEMENT_NODE)
  ------------------
  |  Branch (3339:7): [True: 0, False: 0]
  ------------------
 3340|      0|			return(NULL);
 3341|      0|	if (parent->properties != NULL) {
  ------------------
  |  Branch (3341:6): [True: 0, False: 0]
  ------------------
 3342|       |	    /* check if an attribute with the same name exists */
 3343|      0|	    xmlAttrPtr lastattr;
 3344|       |
 3345|      0|	    if (cur->ns == NULL)
  ------------------
  |  Branch (3345:10): [True: 0, False: 0]
  ------------------
 3346|      0|		lastattr = xmlHasNsProp(parent, cur->name, NULL);
 3347|      0|	    else
 3348|      0|		lastattr = xmlHasNsProp(parent, cur->name, cur->ns->href);
 3349|      0|	    if ((lastattr != NULL) && (lastattr != (xmlAttrPtr) cur) && (lastattr->type != XML_ATTRIBUTE_DECL)) {
  ------------------
  |  Branch (3349:10): [True: 0, False: 0]
  |  Branch (3349:32): [True: 0, False: 0]
  |  Branch (3349:66): [True: 0, False: 0]
  ------------------
 3350|       |		/* different instance, destroy it (attributes must be unique) */
 3351|      0|			xmlUnlinkNode((xmlNodePtr) lastattr);
 3352|      0|		xmlFreeProp(lastattr);
 3353|      0|	    }
 3354|      0|		if (lastattr == (xmlAttrPtr) cur)
  ------------------
  |  Branch (3354:7): [True: 0, False: 0]
  ------------------
 3355|      0|			return(cur);
 3356|       |
 3357|      0|	}
 3358|      0|	if (parent->properties == NULL) {
  ------------------
  |  Branch (3358:6): [True: 0, False: 0]
  ------------------
 3359|      0|	    parent->properties = (xmlAttrPtr) cur;
 3360|      0|	} else {
 3361|       |	    /* find the end */
 3362|      0|	    xmlAttrPtr lastattr = parent->properties;
 3363|      0|	    while (lastattr->next != NULL) {
  ------------------
  |  Branch (3363:13): [True: 0, False: 0]
  ------------------
 3364|      0|		lastattr = lastattr->next;
 3365|      0|	    }
 3366|      0|	    lastattr->next = (xmlAttrPtr) cur;
 3367|      0|	    ((xmlAttrPtr) cur)->prev = lastattr;
 3368|      0|	}
 3369|  3.42k|    } else {
 3370|  3.42k|	if (parent->children == NULL) {
  ------------------
  |  Branch (3370:6): [True: 927, False: 2.49k]
  ------------------
 3371|    927|	    parent->children = cur;
 3372|    927|	    parent->last = cur;
 3373|  2.49k|	} else {
 3374|  2.49k|	    prev = parent->last;
 3375|  2.49k|	    prev->next = cur;
 3376|  2.49k|	    cur->prev = prev;
 3377|  2.49k|	    parent->last = cur;
 3378|  2.49k|	}
 3379|  3.42k|    }
 3380|  3.42k|    return(cur);
 3381|  3.42k|}
xmlFreeNodeList:
 3602|    847|xmlFreeNodeList(xmlNodePtr cur) {
 3603|    847|    xmlNodePtr next;
 3604|    847|    xmlNodePtr parent;
 3605|    847|    xmlDictPtr dict = NULL;
 3606|    847|    size_t depth = 0;
 3607|       |
 3608|    847|    if (cur == NULL) return;
  ------------------
  |  Branch (3608:9): [True: 5, False: 842]
  ------------------
 3609|    842|    if (cur->type == XML_NAMESPACE_DECL) {
  ------------------
  |  Branch (3609:9): [True: 0, False: 842]
  ------------------
 3610|      0|	xmlFreeNsList((xmlNsPtr) cur);
 3611|      0|	return;
 3612|      0|    }
 3613|    842|    if (cur->doc != NULL) dict = cur->doc->dict;
  ------------------
  |  Branch (3613:9): [True: 842, False: 0]
  ------------------
 3614|  4.94k|    while (1) {
  ------------------
  |  Branch (3614:12): [Folded - Ignored]
  ------------------
 3615|  6.25k|        while ((cur->children != NULL) &&
  ------------------
  |  Branch (3615:16): [True: 1.31k, False: 4.94k]
  ------------------
 3616|  6.25k|               (cur->type != XML_DOCUMENT_NODE) &&
  ------------------
  |  Branch (3616:16): [True: 1.31k, False: 0]
  ------------------
 3617|  6.25k|               (cur->type != XML_HTML_DOCUMENT_NODE) &&
  ------------------
  |  Branch (3617:16): [True: 1.31k, False: 0]
  ------------------
 3618|  6.25k|               (cur->type != XML_DTD_NODE) &&
  ------------------
  |  Branch (3618:16): [True: 1.31k, False: 0]
  ------------------
 3619|  6.25k|               (cur->type != XML_ENTITY_REF_NODE)) {
  ------------------
  |  Branch (3619:16): [True: 1.31k, False: 0]
  ------------------
 3620|  1.31k|            cur = cur->children;
 3621|  1.31k|            depth += 1;
 3622|  1.31k|        }
 3623|       |
 3624|  4.94k|        next = cur->next;
 3625|  4.94k|        parent = cur->parent;
 3626|  4.94k|	if ((cur->type == XML_DOCUMENT_NODE) ||
  ------------------
  |  Branch (3626:6): [True: 0, False: 4.94k]
  ------------------
 3627|  4.94k|            (cur->type == XML_HTML_DOCUMENT_NODE)) {
  ------------------
  |  Branch (3627:13): [True: 0, False: 4.94k]
  ------------------
 3628|      0|            xmlFreeDoc((xmlDocPtr) cur);
 3629|  4.94k|        } else if (cur->type != XML_DTD_NODE) {
  ------------------
  |  Branch (3629:20): [True: 4.94k, False: 0]
  ------------------
 3630|       |
 3631|  4.94k|	    if ((__xmlRegisterCallbacks) && (xmlDeregisterNodeDefaultValue))
  ------------------
  |  |  684|      0|    XML_GLOBAL_MACRO(xmlDeregisterNodeDefaultValue)
  |  |  ------------------
  |  |  |  |  500|      0|  #define XML_GLOBAL_MACRO(name) (*__##name())
  |  |  ------------------
  ------------------
  |  Branch (3631:10): [True: 0, False: 4.94k]
  |  Branch (3631:38): [True: 0, False: 0]
  ------------------
 3632|      0|		xmlDeregisterNodeDefaultValue(cur);
  ------------------
  |  |  684|      0|    XML_GLOBAL_MACRO(xmlDeregisterNodeDefaultValue)
  |  |  ------------------
  |  |  |  |  500|      0|  #define XML_GLOBAL_MACRO(name) (*__##name())
  |  |  ------------------
  ------------------
 3633|       |
 3634|  4.94k|	    if (((cur->type == XML_ELEMENT_NODE) ||
  ------------------
  |  Branch (3634:11): [True: 2.14k, False: 2.79k]
  ------------------
 3635|  4.94k|		 (cur->type == XML_XINCLUDE_START) ||
  ------------------
  |  Branch (3635:4): [True: 43, False: 2.75k]
  ------------------
 3636|  4.94k|		 (cur->type == XML_XINCLUDE_END)) &&
  ------------------
  |  Branch (3636:4): [True: 43, False: 2.70k]
  ------------------
 3637|  4.94k|		(cur->properties != NULL))
  ------------------
  |  Branch (3637:3): [True: 510, False: 1.72k]
  ------------------
 3638|    510|		xmlFreePropList(cur->properties);
 3639|  4.94k|	    if ((cur->type != XML_ELEMENT_NODE) &&
  ------------------
  |  Branch (3639:10): [True: 2.79k, False: 2.14k]
  ------------------
 3640|  4.94k|		(cur->type != XML_XINCLUDE_START) &&
  ------------------
  |  Branch (3640:3): [True: 2.75k, False: 43]
  ------------------
 3641|  4.94k|		(cur->type != XML_XINCLUDE_END) &&
  ------------------
  |  Branch (3641:3): [True: 2.70k, False: 43]
  ------------------
 3642|  4.94k|		(cur->type != XML_ENTITY_REF_NODE) &&
  ------------------
  |  Branch (3642:3): [True: 2.70k, False: 0]
  ------------------
 3643|  4.94k|		(cur->content != (xmlChar *) &(cur->properties))) {
  ------------------
  |  Branch (3643:3): [True: 2.52k, False: 184]
  ------------------
 3644|  2.52k|		DICT_FREE(cur->content)
  ------------------
  |  | 1025|  2.52k|	if ((str) && ((!dict) ||				\
  |  |  ------------------
  |  |  |  Branch (1025:6): [True: 2.52k, False: 0]
  |  |  |  Branch (1025:16): [True: 5, False: 2.51k]
  |  |  ------------------
  |  | 1026|  2.52k|	    (xmlDictOwns(dict, (const xmlChar *)(str)) == 0)))	\
  |  |  ------------------
  |  |  |  Branch (1026:6): [True: 1.63k, False: 886]
  |  |  ------------------
  |  | 1027|  2.52k|	    xmlFree((char *)(str));
  ------------------
 3645|  2.52k|	    }
 3646|  4.94k|	    if (((cur->type == XML_ELEMENT_NODE) ||
  ------------------
  |  Branch (3646:11): [True: 2.14k, False: 2.79k]
  ------------------
 3647|  4.94k|	         (cur->type == XML_XINCLUDE_START) ||
  ------------------
  |  Branch (3647:11): [True: 43, False: 2.75k]
  ------------------
 3648|  4.94k|		 (cur->type == XML_XINCLUDE_END)) &&
  ------------------
  |  Branch (3648:4): [True: 43, False: 2.70k]
  ------------------
 3649|  4.94k|		(cur->nsDef != NULL))
  ------------------
  |  Branch (3649:3): [True: 138, False: 2.09k]
  ------------------
 3650|    138|		xmlFreeNsList(cur->nsDef);
 3651|       |
 3652|       |	    /*
 3653|       |	     * When a node is a text node or a comment, it uses a global static
 3654|       |	     * variable for the name of the node.
 3655|       |	     * Otherwise the node name might come from the document's
 3656|       |	     * dictionary
 3657|       |	     */
 3658|  4.94k|	    if ((cur->name != NULL) &&
  ------------------
  |  Branch (3658:10): [True: 4.94k, False: 0]
  ------------------
 3659|  4.94k|		(cur->type != XML_TEXT_NODE) &&
  ------------------
  |  Branch (3659:3): [True: 2.25k, False: 2.68k]
  ------------------
 3660|  4.94k|		(cur->type != XML_COMMENT_NODE))
  ------------------
  |  Branch (3660:3): [True: 2.23k, False: 19]
  ------------------
 3661|  2.23k|		DICT_FREE(cur->name)
  ------------------
  |  | 1025|  2.23k|	if ((str) && ((!dict) ||				\
  |  |  ------------------
  |  |  |  Branch (1025:6): [True: 2.23k, False: 0]
  |  |  |  Branch (1025:16): [True: 3, False: 2.23k]
  |  |  ------------------
  |  | 1026|  2.23k|	    (xmlDictOwns(dict, (const xmlChar *)(str)) == 0)))	\
  |  |  ------------------
  |  |  |  Branch (1026:6): [True: 0, False: 2.23k]
  |  |  ------------------
  |  | 1027|  2.23k|	    xmlFree((char *)(str));
  ------------------
 3662|  4.94k|	    xmlFree(cur);
 3663|  4.94k|	}
 3664|       |
 3665|  4.94k|        if (next != NULL) {
  ------------------
  |  Branch (3665:13): [True: 2.78k, False: 2.15k]
  ------------------
 3666|  2.78k|	    cur = next;
 3667|  2.78k|        } else {
 3668|  2.15k|            if ((depth == 0) || (parent == NULL))
  ------------------
  |  Branch (3668:17): [True: 842, False: 1.31k]
  |  Branch (3668:33): [True: 0, False: 1.31k]
  ------------------
 3669|    842|                break;
 3670|  1.31k|            depth -= 1;
 3671|  1.31k|            cur = parent;
 3672|  1.31k|            cur->children = NULL;
 3673|  1.31k|        }
 3674|  4.94k|    }
 3675|    842|}
xmlFreeNode:
 3685|    142|xmlFreeNode(xmlNodePtr cur) {
 3686|    142|    xmlDictPtr dict = NULL;
 3687|       |
 3688|    142|    if (cur == NULL) return;
  ------------------
  |  Branch (3688:9): [True: 8, False: 134]
  ------------------
 3689|       |
 3690|       |    /* use xmlFreeDtd for DTD nodes */
 3691|    134|    if (cur->type == XML_DTD_NODE) {
  ------------------
  |  Branch (3691:9): [True: 0, False: 134]
  ------------------
 3692|      0|	xmlFreeDtd((xmlDtdPtr) cur);
 3693|      0|	return;
 3694|      0|    }
 3695|    134|    if (cur->type == XML_NAMESPACE_DECL) {
  ------------------
  |  Branch (3695:9): [True: 0, False: 134]
  ------------------
 3696|      0|	xmlFreeNs((xmlNsPtr) cur);
 3697|      0|        return;
 3698|      0|    }
 3699|    134|    if (cur->type == XML_ATTRIBUTE_NODE) {
  ------------------
  |  Branch (3699:9): [True: 0, False: 134]
  ------------------
 3700|      0|	xmlFreeProp((xmlAttrPtr) cur);
 3701|      0|	return;
 3702|      0|    }
 3703|       |
 3704|    134|    if ((__xmlRegisterCallbacks) && (xmlDeregisterNodeDefaultValue))
  ------------------
  |  |  684|      0|    XML_GLOBAL_MACRO(xmlDeregisterNodeDefaultValue)
  |  |  ------------------
  |  |  |  |  500|      0|  #define XML_GLOBAL_MACRO(name) (*__##name())
  |  |  ------------------
  ------------------
  |  Branch (3704:9): [True: 0, False: 134]
  |  Branch (3704:37): [True: 0, False: 0]
  ------------------
 3705|      0|	xmlDeregisterNodeDefaultValue(cur);
  ------------------
  |  |  684|      0|    XML_GLOBAL_MACRO(xmlDeregisterNodeDefaultValue)
  |  |  ------------------
  |  |  |  |  500|      0|  #define XML_GLOBAL_MACRO(name) (*__##name())
  |  |  ------------------
  ------------------
 3706|       |
 3707|    134|    if (cur->doc != NULL) dict = cur->doc->dict;
  ------------------
  |  Branch (3707:9): [True: 134, False: 0]
  ------------------
 3708|       |
 3709|    134|    if (cur->type == XML_ENTITY_DECL) {
  ------------------
  |  Branch (3709:9): [True: 0, False: 134]
  ------------------
 3710|      0|        xmlEntityPtr ent = (xmlEntityPtr) cur;
 3711|      0|	DICT_FREE(ent->SystemID);
  ------------------
  |  | 1025|      0|	if ((str) && ((!dict) ||				\
  |  |  ------------------
  |  |  |  Branch (1025:6): [True: 0, False: 0]
  |  |  |  Branch (1025:16): [True: 0, False: 0]
  |  |  ------------------
  |  | 1026|      0|	    (xmlDictOwns(dict, (const xmlChar *)(str)) == 0)))	\
  |  |  ------------------
  |  |  |  Branch (1026:6): [True: 0, False: 0]
  |  |  ------------------
  |  | 1027|      0|	    xmlFree((char *)(str));
  ------------------
 3712|      0|	DICT_FREE(ent->ExternalID);
  ------------------
  |  | 1025|      0|	if ((str) && ((!dict) ||				\
  |  |  ------------------
  |  |  |  Branch (1025:6): [True: 0, False: 0]
  |  |  |  Branch (1025:16): [True: 0, False: 0]
  |  |  ------------------
  |  | 1026|      0|	    (xmlDictOwns(dict, (const xmlChar *)(str)) == 0)))	\
  |  |  ------------------
  |  |  |  Branch (1026:6): [True: 0, False: 0]
  |  |  ------------------
  |  | 1027|      0|	    xmlFree((char *)(str));
  ------------------
 3713|      0|    }
 3714|    134|    if ((cur->children != NULL) &&
  ------------------
  |  Branch (3714:9): [True: 28, False: 106]
  ------------------
 3715|    134|	(cur->type != XML_ENTITY_REF_NODE))
  ------------------
  |  Branch (3715:2): [True: 28, False: 0]
  ------------------
 3716|     28|	xmlFreeNodeList(cur->children);
 3717|       |
 3718|    134|    if ((cur->type == XML_ELEMENT_NODE) ||
  ------------------
  |  Branch (3718:9): [True: 28, False: 106]
  ------------------
 3719|    134|        (cur->type == XML_XINCLUDE_START) ||
  ------------------
  |  Branch (3719:9): [True: 0, False: 106]
  ------------------
 3720|    134|        (cur->type == XML_XINCLUDE_END)) {
  ------------------
  |  Branch (3720:9): [True: 0, False: 106]
  ------------------
 3721|     28|        if (cur->properties != NULL)
  ------------------
  |  Branch (3721:13): [True: 0, False: 28]
  ------------------
 3722|      0|            xmlFreePropList(cur->properties);
 3723|     28|        if (cur->nsDef != NULL)
  ------------------
  |  Branch (3723:13): [True: 2, False: 26]
  ------------------
 3724|      2|            xmlFreeNsList(cur->nsDef);
 3725|    106|    } else if ((cur->content != NULL) &&
  ------------------
  |  Branch (3725:16): [True: 104, False: 2]
  ------------------
 3726|    106|               (cur->type != XML_ENTITY_REF_NODE) &&
  ------------------
  |  Branch (3726:16): [True: 104, False: 0]
  ------------------
 3727|    106|               (cur->content != (xmlChar *) &(cur->properties))) {
  ------------------
  |  Branch (3727:16): [True: 81, False: 23]
  ------------------
 3728|     81|        DICT_FREE(cur->content)
  ------------------
  |  | 1025|     81|	if ((str) && ((!dict) ||				\
  |  |  ------------------
  |  |  |  Branch (1025:6): [True: 81, False: 0]
  |  |  |  Branch (1025:16): [True: 0, False: 81]
  |  |  ------------------
  |  | 1026|     81|	    (xmlDictOwns(dict, (const xmlChar *)(str)) == 0)))	\
  |  |  ------------------
  |  |  |  Branch (1026:6): [True: 49, False: 32]
  |  |  ------------------
  |  | 1027|     81|	    xmlFree((char *)(str));
  ------------------
 3729|     81|    }
 3730|       |
 3731|       |    /*
 3732|       |     * When a node is a text node or a comment, it uses a global static
 3733|       |     * variable for the name of the node.
 3734|       |     * Otherwise the node name might come from the document's dictionary
 3735|       |     */
 3736|    134|    if ((cur->name != NULL) &&
  ------------------
  |  Branch (3736:9): [True: 134, False: 0]
  ------------------
 3737|    134|        (cur->type != XML_TEXT_NODE) &&
  ------------------
  |  Branch (3737:9): [True: 28, False: 106]
  ------------------
 3738|    134|        (cur->type != XML_COMMENT_NODE))
  ------------------
  |  Branch (3738:9): [True: 28, False: 0]
  ------------------
 3739|     28|	DICT_FREE(cur->name)
  ------------------
  |  | 1025|     28|	if ((str) && ((!dict) ||				\
  |  |  ------------------
  |  |  |  Branch (1025:6): [True: 28, False: 0]
  |  |  |  Branch (1025:16): [True: 0, False: 28]
  |  |  ------------------
  |  | 1026|     28|	    (xmlDictOwns(dict, (const xmlChar *)(str)) == 0)))	\
  |  |  ------------------
  |  |  |  Branch (1026:6): [True: 0, False: 28]
  |  |  ------------------
  |  | 1027|     28|	    xmlFree((char *)(str));
  ------------------
 3740|       |
 3741|    134|    xmlFree(cur);
 3742|    134|}
xmlUnlinkNode:
 3755|  1.74k|xmlUnlinkNode(xmlNodePtr cur) {
 3756|  1.74k|    if (cur == NULL) {
  ------------------
  |  Branch (3756:9): [True: 0, False: 1.74k]
  ------------------
 3757|      0|	return;
 3758|      0|    }
 3759|  1.74k|    if (cur->type == XML_NAMESPACE_DECL)
  ------------------
  |  Branch (3759:9): [True: 0, False: 1.74k]
  ------------------
 3760|      0|        return;
 3761|  1.74k|    if (cur->type == XML_DTD_NODE) {
  ------------------
  |  Branch (3761:9): [True: 8, False: 1.73k]
  ------------------
 3762|      8|	xmlDocPtr doc;
 3763|      8|	doc = cur->doc;
 3764|      8|	if (doc != NULL) {
  ------------------
  |  Branch (3764:6): [True: 8, False: 0]
  ------------------
 3765|      8|	    if (doc->intSubset == (xmlDtdPtr) cur)
  ------------------
  |  Branch (3765:10): [True: 8, False: 0]
  ------------------
 3766|      8|		doc->intSubset = NULL;
 3767|      8|	    if (doc->extSubset == (xmlDtdPtr) cur)
  ------------------
  |  Branch (3767:10): [True: 0, False: 8]
  ------------------
 3768|      0|		doc->extSubset = NULL;
 3769|      8|	}
 3770|      8|    }
 3771|  1.74k|    if (cur->type == XML_ENTITY_DECL) {
  ------------------
  |  Branch (3771:9): [True: 0, False: 1.74k]
  ------------------
 3772|      0|        xmlDocPtr doc;
 3773|      0|	doc = cur->doc;
 3774|      0|	if (doc != NULL) {
  ------------------
  |  Branch (3774:6): [True: 0, False: 0]
  ------------------
 3775|      0|	    if (doc->intSubset != NULL) {
  ------------------
  |  Branch (3775:10): [True: 0, False: 0]
  ------------------
 3776|      0|	        if (xmlHashLookup(doc->intSubset->entities, cur->name) == cur)
  ------------------
  |  Branch (3776:14): [True: 0, False: 0]
  ------------------
 3777|      0|		    xmlHashRemoveEntry(doc->intSubset->entities, cur->name,
 3778|      0|		                       NULL);
 3779|      0|	        if (xmlHashLookup(doc->intSubset->pentities, cur->name) == cur)
  ------------------
  |  Branch (3779:14): [True: 0, False: 0]
  ------------------
 3780|      0|		    xmlHashRemoveEntry(doc->intSubset->pentities, cur->name,
 3781|      0|		                       NULL);
 3782|      0|	    }
 3783|      0|	    if (doc->extSubset != NULL) {
  ------------------
  |  Branch (3783:10): [True: 0, False: 0]
  ------------------
 3784|      0|	        if (xmlHashLookup(doc->extSubset->entities, cur->name) == cur)
  ------------------
  |  Branch (3784:14): [True: 0, False: 0]
  ------------------
 3785|      0|		    xmlHashRemoveEntry(doc->extSubset->entities, cur->name,
 3786|      0|		                       NULL);
 3787|      0|	        if (xmlHashLookup(doc->extSubset->pentities, cur->name) == cur)
  ------------------
  |  Branch (3787:14): [True: 0, False: 0]
  ------------------
 3788|      0|		    xmlHashRemoveEntry(doc->extSubset->pentities, cur->name,
 3789|      0|		                       NULL);
 3790|      0|	    }
 3791|      0|	}
 3792|      0|    }
 3793|  1.74k|    if (cur->parent != NULL) {
  ------------------
  |  Branch (3793:9): [True: 1.40k, False: 340]
  ------------------
 3794|  1.40k|	xmlNodePtr parent;
 3795|  1.40k|	parent = cur->parent;
 3796|  1.40k|	if (cur->type == XML_ATTRIBUTE_NODE) {
  ------------------
  |  Branch (3796:6): [True: 26, False: 1.37k]
  ------------------
 3797|     26|	    if (parent->properties == (xmlAttrPtr) cur)
  ------------------
  |  Branch (3797:10): [True: 26, False: 0]
  ------------------
 3798|     26|		parent->properties = ((xmlAttrPtr) cur)->next;
 3799|  1.37k|	} else {
 3800|  1.37k|	    if (parent->children == cur)
  ------------------
  |  Branch (3800:10): [True: 1.33k, False: 42]
  ------------------
 3801|  1.33k|		parent->children = cur->next;
 3802|  1.37k|	    if (parent->last == cur)
  ------------------
  |  Branch (3802:10): [True: 459, False: 919]
  ------------------
 3803|    459|		parent->last = cur->prev;
 3804|  1.37k|	}
 3805|  1.40k|	cur->parent = NULL;
 3806|  1.40k|    }
 3807|  1.74k|    if (cur->next != NULL)
  ------------------
  |  Branch (3807:9): [True: 1.13k, False: 613]
  ------------------
 3808|  1.13k|        cur->next->prev = cur->prev;
 3809|  1.74k|    if (cur->prev != NULL)
  ------------------
  |  Branch (3809:9): [True: 42, False: 1.70k]
  ------------------
 3810|     42|        cur->prev->next = cur->next;
 3811|  1.74k|    cur->next = cur->prev = NULL;
 3812|  1.74k|}
xmlCopyNamespace:
 3889|      6|xmlCopyNamespace(xmlNsPtr cur) {
 3890|      6|    xmlNsPtr ret;
 3891|       |
 3892|      6|    if (cur == NULL) return(NULL);
  ------------------
  |  Branch (3892:9): [True: 0, False: 6]
  ------------------
 3893|      6|    switch (cur->type) {
 3894|      6|	case XML_LOCAL_NAMESPACE:
  ------------------
  |  |  370|      6|#define XML_LOCAL_NAMESPACE XML_NAMESPACE_DECL
  ------------------
  |  Branch (3894:2): [True: 6, False: 0]
  ------------------
 3895|      6|	    ret = xmlNewNs(NULL, cur->href, cur->prefix);
 3896|      6|	    break;
 3897|      0|	default:
  ------------------
  |  Branch (3897:2): [True: 0, False: 6]
  ------------------
 3898|      0|	    return(NULL);
 3899|      6|    }
 3900|      6|    return(ret);
 3901|      6|}
xmlCopyNamespaceList:
 3912|      6|xmlCopyNamespaceList(xmlNsPtr cur) {
 3913|      6|    xmlNsPtr ret = NULL;
 3914|      6|    xmlNsPtr p = NULL,q;
 3915|       |
 3916|     12|    while (cur != NULL) {
  ------------------
  |  Branch (3916:12): [True: 6, False: 6]
  ------------------
 3917|      6|        q = xmlCopyNamespace(cur);
 3918|      6|        if (q == NULL) {
  ------------------
  |  Branch (3918:13): [True: 0, False: 6]
  ------------------
 3919|      0|            xmlFreeNsList(ret);
 3920|      0|            return(NULL);
 3921|      0|        }
 3922|      6|	if (p == NULL) {
  ------------------
  |  Branch (3922:6): [True: 6, False: 0]
  ------------------
 3923|      6|	    ret = p = q;
 3924|      6|	} else {
 3925|      0|	    p->next = q;
 3926|      0|	    p = q;
 3927|      0|	}
 3928|      6|	cur = cur->next;
 3929|      6|    }
 3930|      6|    return(ret);
 3931|      6|}
xmlCopyProp:
 4041|     12|xmlCopyProp(xmlNodePtr target, xmlAttrPtr cur) {
 4042|     12|	return xmlCopyPropInternal(NULL, target, cur);
 4043|     12|}
xmlCopyPropList:
 4055|     16|xmlCopyPropList(xmlNodePtr target, xmlAttrPtr cur) {
 4056|     16|    xmlAttrPtr ret = NULL;
 4057|     16|    xmlAttrPtr p = NULL,q;
 4058|       |
 4059|     16|    if ((target != NULL) && (target->type != XML_ELEMENT_NODE))
  ------------------
  |  Branch (4059:9): [True: 16, False: 0]
  |  Branch (4059:29): [True: 4, False: 12]
  ------------------
 4060|      4|        return(NULL);
 4061|     24|    while (cur != NULL) {
  ------------------
  |  Branch (4061:12): [True: 12, False: 12]
  ------------------
 4062|     12|        q = xmlCopyProp(target, cur);
 4063|     12|	if (q == NULL) {
  ------------------
  |  Branch (4063:6): [True: 0, False: 12]
  ------------------
 4064|      0|            xmlFreePropList(ret);
 4065|      0|	    return(NULL);
 4066|      0|        }
 4067|     12|	if (p == NULL) {
  ------------------
  |  Branch (4067:6): [True: 12, False: 0]
  ------------------
 4068|     12|	    ret = p = q;
 4069|     12|	} else {
 4070|      0|	    p->next = q;
 4071|      0|	    q->prev = p;
 4072|      0|	    p = q;
 4073|      0|	}
 4074|     12|	cur = cur->next;
 4075|     12|    }
 4076|     12|    return(ret);
 4077|     12|}
xmlStaticCopyNode:
 4100|  2.18k|                  int extended) {
 4101|  2.18k|    xmlNodePtr ret;
 4102|       |
 4103|  2.18k|    if (node == NULL) return(NULL);
  ------------------
  |  Branch (4103:9): [True: 0, False: 2.18k]
  ------------------
 4104|  2.18k|    switch (node->type) {
  ------------------
  |  Branch (4104:13): [True: 0, False: 2.18k]
  ------------------
 4105|  1.15k|        case XML_TEXT_NODE:
  ------------------
  |  Branch (4105:9): [True: 1.15k, False: 1.02k]
  ------------------
 4106|  1.15k|        case XML_CDATA_SECTION_NODE:
  ------------------
  |  Branch (4106:9): [True: 0, False: 2.18k]
  ------------------
 4107|  2.17k|        case XML_ELEMENT_NODE:
  ------------------
  |  Branch (4107:9): [True: 1.01k, False: 1.16k]
  ------------------
 4108|  2.17k|        case XML_DOCUMENT_FRAG_NODE:
  ------------------
  |  Branch (4108:9): [True: 0, False: 2.18k]
  ------------------
 4109|  2.17k|        case XML_ENTITY_REF_NODE:
  ------------------
  |  Branch (4109:9): [True: 0, False: 2.18k]
  ------------------
 4110|  2.17k|        case XML_ENTITY_NODE:
  ------------------
  |  Branch (4110:9): [True: 0, False: 2.18k]
  ------------------
 4111|  2.17k|        case XML_PI_NODE:
  ------------------
  |  Branch (4111:9): [True: 0, False: 2.18k]
  ------------------
 4112|  2.17k|        case XML_COMMENT_NODE:
  ------------------
  |  Branch (4112:9): [True: 0, False: 2.18k]
  ------------------
 4113|  2.17k|        case XML_XINCLUDE_START:
  ------------------
  |  Branch (4113:9): [True: 4, False: 2.17k]
  ------------------
 4114|  2.18k|        case XML_XINCLUDE_END:
  ------------------
  |  Branch (4114:9): [True: 4, False: 2.17k]
  ------------------
 4115|  2.18k|	    break;
 4116|      0|        case XML_ATTRIBUTE_NODE:
  ------------------
  |  Branch (4116:9): [True: 0, False: 2.18k]
  ------------------
 4117|      0|		return((xmlNodePtr) xmlCopyPropInternal(doc, parent, (xmlAttrPtr) node));
 4118|      0|        case XML_NAMESPACE_DECL:
  ------------------
  |  Branch (4118:9): [True: 0, False: 2.18k]
  ------------------
 4119|      0|	    return((xmlNodePtr) xmlCopyNamespaceList((xmlNsPtr) node));
 4120|       |
 4121|      0|        case XML_DOCUMENT_NODE:
  ------------------
  |  Branch (4121:9): [True: 0, False: 2.18k]
  ------------------
 4122|      0|        case XML_HTML_DOCUMENT_NODE:
  ------------------
  |  Branch (4122:9): [True: 0, False: 2.18k]
  ------------------
 4123|      0|#ifdef LIBXML_TREE_ENABLED
 4124|      0|	    return((xmlNodePtr) xmlCopyDoc((xmlDocPtr) node, extended));
 4125|      0|#endif /* LIBXML_TREE_ENABLED */
 4126|      0|        case XML_DOCUMENT_TYPE_NODE:
  ------------------
  |  Branch (4126:9): [True: 0, False: 2.18k]
  ------------------
 4127|      0|        case XML_NOTATION_NODE:
  ------------------
  |  Branch (4127:9): [True: 0, False: 2.18k]
  ------------------
 4128|      0|        case XML_DTD_NODE:
  ------------------
  |  Branch (4128:9): [True: 0, False: 2.18k]
  ------------------
 4129|      0|        case XML_ELEMENT_DECL:
  ------------------
  |  Branch (4129:9): [True: 0, False: 2.18k]
  ------------------
 4130|      0|        case XML_ATTRIBUTE_DECL:
  ------------------
  |  Branch (4130:9): [True: 0, False: 2.18k]
  ------------------
 4131|      0|        case XML_ENTITY_DECL:
  ------------------
  |  Branch (4131:9): [True: 0, False: 2.18k]
  ------------------
 4132|      0|            return(NULL);
 4133|  2.18k|    }
 4134|       |
 4135|       |    /*
 4136|       |     * Allocate a new node and fill the fields.
 4137|       |     */
 4138|  2.18k|    ret = (xmlNodePtr) xmlMalloc(sizeof(xmlNode));
 4139|  2.18k|    if (ret == NULL) {
  ------------------
  |  Branch (4139:9): [True: 0, False: 2.18k]
  ------------------
 4140|      0|	xmlTreeErrMemory("copying node");
 4141|      0|	return(NULL);
 4142|      0|    }
 4143|  2.18k|    memset(ret, 0, sizeof(xmlNode));
 4144|  2.18k|    ret->type = node->type;
 4145|       |
 4146|  2.18k|    ret->doc = doc;
 4147|  2.18k|    ret->parent = parent;
 4148|  2.18k|    if (node->name == xmlStringText)
  ------------------
  |  Branch (4148:9): [True: 1.15k, False: 1.02k]
  ------------------
 4149|  1.15k|	ret->name = xmlStringText;
 4150|  1.02k|    else if (node->name == xmlStringTextNoenc)
  ------------------
  |  Branch (4150:14): [True: 0, False: 1.02k]
  ------------------
 4151|      0|	ret->name = xmlStringTextNoenc;
 4152|  1.02k|    else if (node->name == xmlStringComment)
  ------------------
  |  Branch (4152:14): [True: 0, False: 1.02k]
  ------------------
 4153|      0|	ret->name = xmlStringComment;
 4154|  1.02k|    else if (node->name != NULL) {
  ------------------
  |  Branch (4154:14): [True: 1.02k, False: 0]
  ------------------
 4155|  1.02k|        if ((doc != NULL) && (doc->dict != NULL))
  ------------------
  |  Branch (4155:13): [True: 1.02k, False: 0]
  |  Branch (4155:30): [True: 1.02k, False: 0]
  ------------------
 4156|  1.02k|	    ret->name = xmlDictLookup(doc->dict, node->name, -1);
 4157|      0|	else
 4158|      0|	    ret->name = xmlStrdup(node->name);
 4159|  1.02k|    }
 4160|  2.18k|    if ((node->type != XML_ELEMENT_NODE) &&
  ------------------
  |  Branch (4160:9): [True: 1.16k, False: 1.01k]
  ------------------
 4161|  2.18k|	(node->content != NULL) &&
  ------------------
  |  Branch (4161:2): [True: 1.15k, False: 8]
  ------------------
 4162|  2.18k|	(node->type != XML_ENTITY_REF_NODE) &&
  ------------------
  |  Branch (4162:2): [True: 1.15k, False: 0]
  ------------------
 4163|  2.18k|	(node->type != XML_XINCLUDE_END) &&
  ------------------
  |  Branch (4163:2): [True: 1.15k, False: 0]
  ------------------
 4164|  2.18k|	(node->type != XML_XINCLUDE_START)) {
  ------------------
  |  Branch (4164:2): [True: 1.15k, False: 0]
  ------------------
 4165|  1.15k|	ret->content = xmlStrdup(node->content);
 4166|  1.15k|    }else{
 4167|  1.02k|      if (node->type == XML_ELEMENT_NODE)
  ------------------
  |  Branch (4167:11): [True: 1.01k, False: 8]
  ------------------
 4168|  1.01k|        ret->line = node->line;
 4169|  1.02k|    }
 4170|  2.18k|    if (parent != NULL) {
  ------------------
  |  Branch (4170:9): [True: 686, False: 1.49k]
  ------------------
 4171|    686|	xmlNodePtr tmp;
 4172|       |
 4173|       |	/*
 4174|       |	 * this is a tricky part for the node register thing:
 4175|       |	 * in case ret does get coalesced in xmlAddChild
 4176|       |	 * the deregister-node callback is called; so we register ret now already
 4177|       |	 */
 4178|    686|	if ((__xmlRegisterCallbacks) && (xmlRegisterNodeDefaultValue))
  ------------------
  |  |  682|      0|    XML_GLOBAL_MACRO(xmlRegisterNodeDefaultValue)
  |  |  ------------------
  |  |  |  |  500|      0|  #define XML_GLOBAL_MACRO(name) (*__##name())
  |  |  ------------------
  ------------------
  |  Branch (4178:6): [True: 0, False: 686]
  |  Branch (4178:34): [True: 0, False: 0]
  ------------------
 4179|      0|	    xmlRegisterNodeDefaultValue((xmlNodePtr)ret);
  ------------------
  |  |  682|      0|    XML_GLOBAL_MACRO(xmlRegisterNodeDefaultValue)
  |  |  ------------------
  |  |  |  |  500|      0|  #define XML_GLOBAL_MACRO(name) (*__##name())
  |  |  ------------------
  ------------------
 4180|       |
 4181|       |        /*
 4182|       |         * Note that since ret->parent is already set, xmlAddChild will
 4183|       |         * return early and not actually insert the node. It will only
 4184|       |         * coalesce text nodes and unnecessarily call xmlSetTreeDoc.
 4185|       |         * Assuming that the subtree to be copied always has its text
 4186|       |         * nodes coalesced, the somewhat confusing call to xmlAddChild
 4187|       |         * could be removed.
 4188|       |         */
 4189|    686|        tmp = xmlAddChild(parent, ret);
 4190|       |	/* node could have coalesced */
 4191|    686|	if (tmp != ret)
  ------------------
  |  Branch (4191:6): [True: 0, False: 686]
  ------------------
 4192|      0|	    return(tmp);
 4193|    686|    }
 4194|       |
 4195|  2.18k|    if (!extended)
  ------------------
  |  Branch (4195:9): [True: 0, False: 2.18k]
  ------------------
 4196|      0|	goto out;
 4197|  2.18k|    if (((node->type == XML_ELEMENT_NODE) ||
  ------------------
  |  Branch (4197:10): [True: 1.01k, False: 1.16k]
  ------------------
 4198|  2.18k|         (node->type == XML_XINCLUDE_START)) && (node->nsDef != NULL))
  ------------------
  |  Branch (4198:10): [True: 4, False: 1.16k]
  |  Branch (4198:49): [True: 6, False: 1.01k]
  ------------------
 4199|      6|        ret->nsDef = xmlCopyNamespaceList(node->nsDef);
 4200|       |
 4201|  2.18k|    if (node->ns != NULL) {
  ------------------
  |  Branch (4201:9): [True: 13, False: 2.16k]
  ------------------
 4202|     13|        xmlNsPtr ns;
 4203|       |
 4204|     13|	ns = xmlSearchNs(doc, ret, node->ns->prefix);
 4205|     13|	if (ns == NULL) {
  ------------------
  |  Branch (4205:6): [True: 7, False: 6]
  ------------------
 4206|       |	    /*
 4207|       |	     * Humm, we are copying an element whose namespace is defined
 4208|       |	     * out of the new tree scope. Search it in the original tree
 4209|       |	     * and add it at the top of the new tree.
 4210|       |             *
 4211|       |             * TODO: Searching the original tree seems unnecessary. We
 4212|       |             * already have a namespace URI.
 4213|       |	     */
 4214|      7|	    ns = xmlSearchNs(node->doc, node, node->ns->prefix);
 4215|      7|	    if (ns != NULL) {
  ------------------
  |  Branch (4215:10): [True: 3, False: 4]
  ------------------
 4216|      3|	        xmlNodePtr root = ret;
 4217|       |
 4218|      3|		while (root->parent != NULL) root = root->parent;
  ------------------
  |  Branch (4218:10): [True: 0, False: 3]
  ------------------
 4219|      3|		ret->ns = xmlNewNs(root, ns->href, ns->prefix);
 4220|      4|            } else {
 4221|      4|                ret->ns = xmlNewReconciledNs(doc, ret, node->ns);
 4222|      4|	    }
 4223|      7|	} else {
 4224|       |	    /*
 4225|       |	     * reference the existing namespace definition in our own tree.
 4226|       |	     */
 4227|      6|	    ret->ns = ns;
 4228|      6|	}
 4229|     13|    }
 4230|  2.18k|    if (((node->type == XML_ELEMENT_NODE) ||
  ------------------
  |  Branch (4230:10): [True: 1.01k, False: 1.16k]
  ------------------
 4231|  2.18k|         (node->type == XML_XINCLUDE_START)) && (node->properties != NULL))
  ------------------
  |  Branch (4231:10): [True: 4, False: 1.16k]
  |  Branch (4231:49): [True: 16, False: 1.00k]
  ------------------
 4232|     16|        ret->properties = xmlCopyPropList(ret, node->properties);
 4233|  2.18k|    if (node->type == XML_ENTITY_REF_NODE) {
  ------------------
  |  Branch (4233:9): [True: 0, False: 2.18k]
  ------------------
 4234|      0|	if ((doc == NULL) || (node->doc != doc)) {
  ------------------
  |  Branch (4234:6): [True: 0, False: 0]
  |  Branch (4234:23): [True: 0, False: 0]
  ------------------
 4235|       |	    /*
 4236|       |	     * The copied node will go into a separate document, so
 4237|       |	     * to avoid dangling references to the ENTITY_DECL node
 4238|       |	     * we cannot keep the reference. Try to find it in the
 4239|       |	     * target document.
 4240|       |	     */
 4241|      0|	    ret->children = (xmlNodePtr) xmlGetDocEntity(doc, ret->name);
 4242|      0|	} else {
 4243|      0|            ret->children = node->children;
 4244|      0|	}
 4245|      0|	ret->last = ret->children;
 4246|  2.18k|    } else if ((node->children != NULL) && (extended != 2)) {
  ------------------
  |  Branch (4246:16): [True: 597, False: 1.58k]
  |  Branch (4246:44): [True: 70, False: 527]
  ------------------
 4247|     70|        xmlNodePtr cur, insert;
 4248|       |
 4249|     70|        cur = node->children;
 4250|     70|        insert = ret;
 4251|    636|        while (cur != NULL) {
  ------------------
  |  Branch (4251:16): [True: 566, False: 70]
  ------------------
 4252|    566|            xmlNodePtr copy = xmlStaticCopyNode(cur, doc, insert, 2);
 4253|    566|            if (copy == NULL) {
  ------------------
  |  Branch (4253:17): [True: 0, False: 566]
  ------------------
 4254|      0|                xmlFreeNode(ret);
 4255|      0|                return(NULL);
 4256|      0|            }
 4257|       |
 4258|       |            /* Check for coalesced text nodes */
 4259|    566|            if (insert->last != copy) {
  ------------------
  |  Branch (4259:17): [True: 566, False: 0]
  ------------------
 4260|    566|                if (insert->last == NULL) {
  ------------------
  |  Branch (4260:21): [True: 502, False: 64]
  ------------------
 4261|    502|                    insert->children = copy;
 4262|    502|                } else {
 4263|     64|                    copy->prev = insert->last;
 4264|     64|                    insert->last->next = copy;
 4265|     64|                }
 4266|    566|                insert->last = copy;
 4267|    566|            }
 4268|       |
 4269|    566|            if ((cur->type != XML_ENTITY_REF_NODE) &&
  ------------------
  |  Branch (4269:17): [True: 566, False: 0]
  ------------------
 4270|    566|                (cur->children != NULL)) {
  ------------------
  |  Branch (4270:17): [True: 432, False: 134]
  ------------------
 4271|    432|                cur = cur->children;
 4272|    432|                insert = copy;
 4273|    432|                continue;
 4274|    432|            }
 4275|       |
 4276|    566|            while (1) {
  ------------------
  |  Branch (4276:20): [Folded - Ignored]
  ------------------
 4277|    566|                if (cur->next != NULL) {
  ------------------
  |  Branch (4277:21): [True: 64, False: 502]
  ------------------
 4278|     64|                    cur = cur->next;
 4279|     64|                    break;
 4280|     64|                }
 4281|       |
 4282|    502|                cur = cur->parent;
 4283|    502|                insert = insert->parent;
 4284|    502|                if (cur == node) {
  ------------------
  |  Branch (4284:21): [True: 70, False: 432]
  ------------------
 4285|     70|                    cur = NULL;
 4286|     70|                    break;
 4287|     70|                }
 4288|    502|            }
 4289|    134|        }
 4290|     70|    }
 4291|       |
 4292|  2.18k|out:
 4293|       |    /* if parent != NULL we already registered the node above */
 4294|  2.18k|    if ((parent == NULL) &&
  ------------------
  |  Branch (4294:9): [True: 1.49k, False: 686]
  ------------------
 4295|  2.18k|        ((__xmlRegisterCallbacks) && (xmlRegisterNodeDefaultValue)))
  ------------------
  |  |  682|      0|    XML_GLOBAL_MACRO(xmlRegisterNodeDefaultValue)
  |  |  ------------------
  |  |  |  |  500|      0|  #define XML_GLOBAL_MACRO(name) (*__##name())
  |  |  ------------------
  ------------------
  |  Branch (4295:10): [True: 0, False: 1.49k]
  |  Branch (4295:38): [True: 0, False: 0]
  ------------------
 4296|      0|	xmlRegisterNodeDefaultValue((xmlNodePtr)ret);
  ------------------
  |  |  682|      0|    XML_GLOBAL_MACRO(xmlRegisterNodeDefaultValue)
  |  |  ------------------
  |  |  |  |  500|      0|  #define XML_GLOBAL_MACRO(name) (*__##name())
  |  |  ------------------
  ------------------
 4297|  2.18k|    return(ret);
 4298|  2.18k|}
xmlStaticCopyNodeList:
 4301|    125|xmlStaticCopyNodeList(xmlNodePtr node, xmlDocPtr doc, xmlNodePtr parent) {
 4302|    125|    xmlNodePtr ret = NULL;
 4303|    125|    xmlNodePtr p = NULL,q;
 4304|    125|    xmlDtdPtr newSubset = NULL;
 4305|       |
 4306|  1.36k|    while (node != NULL) {
  ------------------
  |  Branch (4306:12): [True: 1.23k, False: 125]
  ------------------
 4307|  1.23k|	if (node->type == XML_DTD_NODE ) {
  ------------------
  |  Branch (4307:6): [True: 0, False: 1.23k]
  ------------------
 4308|      0|#ifdef LIBXML_TREE_ENABLED
 4309|      0|	    if ((doc == NULL) || (doc->intSubset != NULL)) {
  ------------------
  |  Branch (4309:10): [True: 0, False: 0]
  |  Branch (4309:27): [True: 0, False: 0]
  ------------------
 4310|      0|		node = node->next;
 4311|      0|		continue;
 4312|      0|	    }
 4313|      0|            q = (xmlNodePtr) xmlCopyDtd( (xmlDtdPtr) node );
 4314|      0|            if (q == NULL) goto error;
  ------------------
  |  Branch (4314:17): [True: 0, False: 0]
  ------------------
 4315|      0|            q->doc = doc;
 4316|      0|            q->parent = parent;
 4317|      0|            newSubset = (xmlDtdPtr) q;
 4318|       |#else
 4319|       |            node = node->next;
 4320|       |            continue;
 4321|       |#endif /* LIBXML_TREE_ENABLED */
 4322|  1.23k|	} else {
 4323|  1.23k|	    q = xmlStaticCopyNode(node, doc, parent, 1);
 4324|  1.23k|	    if (q == NULL) goto error;
  ------------------
  |  Branch (4324:10): [True: 0, False: 1.23k]
  ------------------
 4325|  1.23k|        }
 4326|  1.23k|	if (ret == NULL) {
  ------------------
  |  Branch (4326:6): [True: 125, False: 1.11k]
  ------------------
 4327|    125|	    q->prev = NULL;
 4328|    125|	    ret = p = q;
 4329|  1.11k|	} else if (p != q) {
  ------------------
  |  Branch (4329:13): [True: 1.11k, False: 0]
  ------------------
 4330|       |	/* the test is required if xmlStaticCopyNode coalesced 2 text nodes */
 4331|  1.11k|	    p->next = q;
 4332|  1.11k|	    q->prev = p;
 4333|  1.11k|	    p = q;
 4334|  1.11k|	}
 4335|  1.23k|	node = node->next;
 4336|  1.23k|    }
 4337|    125|    if (newSubset != NULL)
  ------------------
  |  Branch (4337:9): [True: 0, False: 125]
  ------------------
 4338|      0|        doc->intSubset = newSubset;
 4339|    125|    return(ret);
 4340|      0|error:
 4341|      0|    xmlFreeNodeList(ret);
 4342|      0|    return(NULL);
 4343|    125|}
xmlDocCopyNode:
 4377|     10|xmlDocCopyNode(xmlNodePtr node, xmlDocPtr doc, int extended) {
 4378|     10|    xmlNodePtr ret;
 4379|       |
 4380|     10|    ret = xmlStaticCopyNode(node, doc, NULL, extended);
 4381|     10|    return(ret);
 4382|     10|}
xmlGetLineNo:
 4629|     38|{
 4630|     38|    return(xmlGetLineNoInternal(node, 0));
 4631|     38|}
xmlDocGetRootElement:
 4892|     71|xmlDocGetRootElement(const xmlDoc *doc) {
 4893|     71|    xmlNodePtr ret;
 4894|       |
 4895|     71|    if (doc == NULL) return(NULL);
  ------------------
  |  Branch (4895:9): [True: 0, False: 71]
  ------------------
 4896|     71|    ret = doc->children;
 4897|     76|    while (ret != NULL) {
  ------------------
  |  Branch (4897:12): [True: 76, False: 0]
  ------------------
 4898|     76|	if (ret->type == XML_ELEMENT_NODE)
  ------------------
  |  Branch (4898:6): [True: 71, False: 5]
  ------------------
 4899|     71|	    return(ret);
 4900|      5|        ret = ret->next;
 4901|      5|    }
 4902|      0|    return(ret);
 4903|     71|}
xmlNodeGetSpacePreserve:
 5081|    538|xmlNodeGetSpacePreserve(const xmlNode *cur) {
 5082|    538|    xmlChar *space;
 5083|       |
 5084|    538|    if ((cur == NULL) || (cur->type != XML_ELEMENT_NODE))
  ------------------
  |  Branch (5084:9): [True: 0, False: 538]
  |  Branch (5084:26): [True: 538, False: 0]
  ------------------
 5085|    538|        return(-1);
 5086|      0|    while (cur != NULL) {
  ------------------
  |  Branch (5086:12): [True: 0, False: 0]
  ------------------
 5087|      0|	space = xmlGetNsProp(cur, BAD_CAST "space", XML_XML_NAMESPACE);
  ------------------
  |  |   35|      0|#define BAD_CAST (xmlChar *)
  ------------------
              	space = xmlGetNsProp(cur, BAD_CAST "space", XML_XML_NAMESPACE);
  ------------------
  |  |  143|      0|    (const xmlChar *) "http://www.w3.org/XML/1998/namespace"
  ------------------
 5088|      0|	if (space != NULL) {
  ------------------
  |  Branch (5088:6): [True: 0, False: 0]
  ------------------
 5089|      0|	    if (xmlStrEqual(space, BAD_CAST "preserve")) {
  ------------------
  |  |   35|      0|#define BAD_CAST (xmlChar *)
  ------------------
  |  Branch (5089:10): [True: 0, False: 0]
  ------------------
 5090|      0|		xmlFree(space);
 5091|      0|		return(1);
 5092|      0|	    }
 5093|      0|	    if (xmlStrEqual(space, BAD_CAST "default")) {
  ------------------
  |  |   35|      0|#define BAD_CAST (xmlChar *)
  ------------------
  |  Branch (5093:10): [True: 0, False: 0]
  ------------------
 5094|      0|		xmlFree(space);
 5095|      0|		return(0);
 5096|      0|	    }
 5097|      0|	    xmlFree(space);
 5098|      0|	}
 5099|      0|	cur = cur->parent;
 5100|      0|    }
 5101|      0|    return(-1);
 5102|      0|}
xmlNodeSetBase:
 5174|     26|xmlNodeSetBase(xmlNodePtr cur, const xmlChar* uri) {
 5175|     26|    xmlNsPtr ns;
 5176|     26|    xmlChar* fixed;
 5177|       |
 5178|     26|    if (cur == NULL) return;
  ------------------
  |  Branch (5178:9): [True: 0, False: 26]
  ------------------
 5179|     26|    switch(cur->type) {
  ------------------
  |  Branch (5179:12): [True: 0, False: 26]
  ------------------
 5180|      0|        case XML_TEXT_NODE:
  ------------------
  |  Branch (5180:9): [True: 0, False: 26]
  ------------------
 5181|      0|        case XML_CDATA_SECTION_NODE:
  ------------------
  |  Branch (5181:9): [True: 0, False: 26]
  ------------------
 5182|      0|        case XML_COMMENT_NODE:
  ------------------
  |  Branch (5182:9): [True: 0, False: 26]
  ------------------
 5183|      0|        case XML_DOCUMENT_TYPE_NODE:
  ------------------
  |  Branch (5183:9): [True: 0, False: 26]
  ------------------
 5184|      0|        case XML_DOCUMENT_FRAG_NODE:
  ------------------
  |  Branch (5184:9): [True: 0, False: 26]
  ------------------
 5185|      0|        case XML_NOTATION_NODE:
  ------------------
  |  Branch (5185:9): [True: 0, False: 26]
  ------------------
 5186|      0|        case XML_DTD_NODE:
  ------------------
  |  Branch (5186:9): [True: 0, False: 26]
  ------------------
 5187|      0|        case XML_ELEMENT_DECL:
  ------------------
  |  Branch (5187:9): [True: 0, False: 26]
  ------------------
 5188|      0|        case XML_ATTRIBUTE_DECL:
  ------------------
  |  Branch (5188:9): [True: 0, False: 26]
  ------------------
 5189|      0|        case XML_ENTITY_DECL:
  ------------------
  |  Branch (5189:9): [True: 0, False: 26]
  ------------------
 5190|      0|        case XML_PI_NODE:
  ------------------
  |  Branch (5190:9): [True: 0, False: 26]
  ------------------
 5191|      0|        case XML_ENTITY_REF_NODE:
  ------------------
  |  Branch (5191:9): [True: 0, False: 26]
  ------------------
 5192|      0|        case XML_ENTITY_NODE:
  ------------------
  |  Branch (5192:9): [True: 0, False: 26]
  ------------------
 5193|      0|	case XML_NAMESPACE_DECL:
  ------------------
  |  Branch (5193:2): [True: 0, False: 26]
  ------------------
 5194|      0|	case XML_XINCLUDE_START:
  ------------------
  |  Branch (5194:2): [True: 0, False: 26]
  ------------------
 5195|      0|	case XML_XINCLUDE_END:
  ------------------
  |  Branch (5195:2): [True: 0, False: 26]
  ------------------
 5196|      0|	    return;
 5197|     26|        case XML_ELEMENT_NODE:
  ------------------
  |  Branch (5197:9): [True: 26, False: 0]
  ------------------
 5198|     26|        case XML_ATTRIBUTE_NODE:
  ------------------
  |  Branch (5198:9): [True: 0, False: 26]
  ------------------
 5199|     26|	    break;
 5200|      0|        case XML_DOCUMENT_NODE:
  ------------------
  |  Branch (5200:9): [True: 0, False: 26]
  ------------------
 5201|      0|        case XML_HTML_DOCUMENT_NODE: {
  ------------------
  |  Branch (5201:9): [True: 0, False: 26]
  ------------------
 5202|      0|	    xmlDocPtr doc = (xmlDocPtr) cur;
 5203|       |
 5204|      0|	    if (doc->URL != NULL)
  ------------------
  |  Branch (5204:10): [True: 0, False: 0]
  ------------------
 5205|      0|		xmlFree((xmlChar *) doc->URL);
 5206|      0|	    if (uri == NULL)
  ------------------
  |  Branch (5206:10): [True: 0, False: 0]
  ------------------
 5207|      0|		doc->URL = NULL;
 5208|      0|	    else
 5209|      0|		doc->URL = xmlPathToURI(uri);
 5210|      0|	    return;
 5211|      0|	}
 5212|     26|    }
 5213|       |
 5214|     26|    ns = xmlSearchNsByHref(cur->doc, cur, XML_XML_NAMESPACE);
  ------------------
  |  |  143|     26|    (const xmlChar *) "http://www.w3.org/XML/1998/namespace"
  ------------------
 5215|     26|    if (ns == NULL)
  ------------------
  |  Branch (5215:9): [True: 0, False: 26]
  ------------------
 5216|      0|	return;
 5217|     26|    fixed = xmlPathToURI(uri);
 5218|     26|    if (fixed != NULL) {
  ------------------
  |  Branch (5218:9): [True: 26, False: 0]
  ------------------
 5219|     26|	xmlSetNsProp(cur, ns, BAD_CAST "base", fixed);
  ------------------
  |  |   35|     26|#define BAD_CAST (xmlChar *)
  ------------------
 5220|     26|	xmlFree(fixed);
 5221|     26|    } else {
 5222|      0|	xmlSetNsProp(cur, ns, BAD_CAST "base", uri);
  ------------------
  |  |   35|      0|#define BAD_CAST (xmlChar *)
  ------------------
 5223|      0|    }
 5224|     26|}
xmlNodeGetBase:
 5245|    510|xmlNodeGetBase(const xmlDoc *doc, const xmlNode *cur) {
 5246|    510|    xmlChar *oldbase = NULL;
 5247|    510|    xmlChar *base, *newbase;
 5248|       |
 5249|    510|    if ((cur == NULL) && (doc == NULL))
  ------------------
  |  Branch (5249:9): [True: 0, False: 510]
  |  Branch (5249:26): [True: 0, False: 0]
  ------------------
 5250|      0|        return(NULL);
 5251|    510|    if ((cur != NULL) && (cur->type == XML_NAMESPACE_DECL))
  ------------------
  |  Branch (5251:9): [True: 510, False: 0]
  |  Branch (5251:26): [True: 0, False: 510]
  ------------------
 5252|      0|        return(NULL);
 5253|    510|    if (doc == NULL) doc = cur->doc;
  ------------------
  |  Branch (5253:9): [True: 0, False: 510]
  ------------------
 5254|    510|    if ((doc != NULL) && (doc->type == XML_HTML_DOCUMENT_NODE)) {
  ------------------
  |  Branch (5254:9): [True: 510, False: 0]
  |  Branch (5254:26): [True: 0, False: 510]
  ------------------
 5255|      0|        cur = doc->children;
 5256|      0|	while ((cur != NULL) && (cur->name != NULL)) {
  ------------------
  |  Branch (5256:9): [True: 0, False: 0]
  |  Branch (5256:26): [True: 0, False: 0]
  ------------------
 5257|      0|	    if (cur->type != XML_ELEMENT_NODE) {
  ------------------
  |  Branch (5257:10): [True: 0, False: 0]
  ------------------
 5258|      0|	        cur = cur->next;
 5259|      0|		continue;
 5260|      0|	    }
 5261|      0|	    if (!xmlStrcasecmp(cur->name, BAD_CAST "html")) {
  ------------------
  |  |   35|      0|#define BAD_CAST (xmlChar *)
  ------------------
  |  Branch (5261:10): [True: 0, False: 0]
  ------------------
 5262|      0|	        cur = cur->children;
 5263|      0|		continue;
 5264|      0|	    }
 5265|      0|	    if (!xmlStrcasecmp(cur->name, BAD_CAST "head")) {
  ------------------
  |  |   35|      0|#define BAD_CAST (xmlChar *)
  ------------------
  |  Branch (5265:10): [True: 0, False: 0]
  ------------------
 5266|      0|	        cur = cur->children;
 5267|      0|		continue;
 5268|      0|	    }
 5269|      0|	    if (!xmlStrcasecmp(cur->name, BAD_CAST "base")) {
  ------------------
  |  |   35|      0|#define BAD_CAST (xmlChar *)
  ------------------
  |  Branch (5269:10): [True: 0, False: 0]
  ------------------
 5270|      0|                return(xmlGetProp(cur, BAD_CAST "href"));
  ------------------
  |  |   35|      0|#define BAD_CAST (xmlChar *)
  ------------------
 5271|      0|	    }
 5272|      0|	    cur = cur->next;
 5273|      0|	}
 5274|      0|	return(NULL);
 5275|      0|    }
 5276|  3.57k|    while (cur != NULL) {
  ------------------
  |  Branch (5276:12): [True: 3.06k, False: 510]
  ------------------
 5277|  3.06k|	if (cur->type == XML_ENTITY_DECL) {
  ------------------
  |  Branch (5277:6): [True: 0, False: 3.06k]
  ------------------
 5278|      0|	    xmlEntityPtr ent = (xmlEntityPtr) cur;
 5279|      0|	    return(xmlStrdup(ent->URI));
 5280|      0|	}
 5281|  3.06k|	if (cur->type == XML_ELEMENT_NODE) {
  ------------------
  |  Branch (5281:6): [True: 2.58k, False: 484]
  ------------------
 5282|  2.58k|	    base = xmlGetNsProp(cur, BAD_CAST "base", XML_XML_NAMESPACE);
  ------------------
  |  |   35|  2.58k|#define BAD_CAST (xmlChar *)
  ------------------
              	    base = xmlGetNsProp(cur, BAD_CAST "base", XML_XML_NAMESPACE);
  ------------------
  |  |  143|  2.58k|    (const xmlChar *) "http://www.w3.org/XML/1998/namespace"
  ------------------
 5283|  2.58k|	    if (base != NULL) {
  ------------------
  |  Branch (5283:10): [True: 0, False: 2.58k]
  ------------------
 5284|      0|		if (oldbase != NULL) {
  ------------------
  |  Branch (5284:7): [True: 0, False: 0]
  ------------------
 5285|      0|		    newbase = xmlBuildURI(oldbase, base);
 5286|      0|		    if (newbase != NULL) {
  ------------------
  |  Branch (5286:11): [True: 0, False: 0]
  ------------------
 5287|      0|			xmlFree(oldbase);
 5288|      0|			xmlFree(base);
 5289|      0|			oldbase = newbase;
 5290|      0|		    } else {
 5291|      0|			xmlFree(oldbase);
 5292|      0|			xmlFree(base);
 5293|      0|			return(NULL);
 5294|      0|		    }
 5295|      0|		} else {
 5296|      0|		    oldbase = base;
 5297|      0|		}
 5298|      0|		if ((!xmlStrncmp(oldbase, BAD_CAST "http://", 7)) ||
  ------------------
  |  |   35|      0|#define BAD_CAST (xmlChar *)
  ------------------
  |  Branch (5298:7): [True: 0, False: 0]
  ------------------
 5299|      0|		    (!xmlStrncmp(oldbase, BAD_CAST "ftp://", 6)) ||
  ------------------
  |  |   35|      0|#define BAD_CAST (xmlChar *)
  ------------------
  |  Branch (5299:7): [True: 0, False: 0]
  ------------------
 5300|      0|		    (!xmlStrncmp(oldbase, BAD_CAST "urn:", 4)))
  ------------------
  |  |   35|      0|#define BAD_CAST (xmlChar *)
  ------------------
  |  Branch (5300:7): [True: 0, False: 0]
  ------------------
 5301|      0|		    return(oldbase);
 5302|      0|	    }
 5303|  2.58k|	}
 5304|  3.06k|	cur = cur->parent;
 5305|  3.06k|    }
 5306|    510|    if ((doc != NULL) && (doc->URL != NULL)) {
  ------------------
  |  Branch (5306:9): [True: 510, False: 0]
  |  Branch (5306:26): [True: 271, False: 239]
  ------------------
 5307|    271|	if (oldbase == NULL)
  ------------------
  |  Branch (5307:6): [True: 271, False: 0]
  ------------------
 5308|    271|	    return(xmlStrdup(doc->URL));
 5309|      0|	newbase = xmlBuildURI(oldbase, doc->URL);
 5310|      0|	xmlFree(oldbase);
 5311|      0|	return(newbase);
 5312|    271|    }
 5313|    239|    return(oldbase);
 5314|    510|}
xmlNodeAddContentLen:
 5736|      8|xmlNodeAddContentLen(xmlNodePtr cur, const xmlChar *content, int len) {
 5737|      8|    if (cur == NULL) {
  ------------------
  |  Branch (5737:9): [True: 0, False: 8]
  ------------------
 5738|      0|	return;
 5739|      0|    }
 5740|      8|    if (len <= 0) return;
  ------------------
  |  Branch (5740:9): [True: 0, False: 8]
  ------------------
 5741|      8|    switch (cur->type) {
  ------------------
  |  Branch (5741:13): [True: 0, False: 8]
  ------------------
 5742|      0|        case XML_DOCUMENT_FRAG_NODE:
  ------------------
  |  Branch (5742:9): [True: 0, False: 8]
  ------------------
 5743|      0|        case XML_ELEMENT_NODE: {
  ------------------
  |  Branch (5743:9): [True: 0, False: 8]
  ------------------
 5744|      0|	    xmlNodePtr last, newNode, tmp;
 5745|       |
 5746|      0|	    last = cur->last;
 5747|      0|	    newNode = xmlNewDocTextLen(cur->doc, content, len);
 5748|      0|	    if (newNode != NULL) {
  ------------------
  |  Branch (5748:10): [True: 0, False: 0]
  ------------------
 5749|      0|		tmp = xmlAddChild(cur, newNode);
 5750|      0|		if (tmp != newNode)
  ------------------
  |  Branch (5750:7): [True: 0, False: 0]
  ------------------
 5751|      0|		    return;
 5752|      0|	        if ((last != NULL) && (last->next == newNode)) {
  ------------------
  |  Branch (5752:14): [True: 0, False: 0]
  |  Branch (5752:32): [True: 0, False: 0]
  ------------------
 5753|      0|		    xmlTextMerge(last, newNode);
 5754|      0|		}
 5755|      0|	    }
 5756|      0|	    break;
 5757|      0|	}
 5758|      0|        case XML_ATTRIBUTE_NODE:
  ------------------
  |  Branch (5758:9): [True: 0, False: 8]
  ------------------
 5759|      0|	    break;
 5760|      8|        case XML_TEXT_NODE:
  ------------------
  |  Branch (5760:9): [True: 8, False: 0]
  ------------------
 5761|      8|        case XML_CDATA_SECTION_NODE:
  ------------------
  |  Branch (5761:9): [True: 0, False: 8]
  ------------------
 5762|      8|        case XML_ENTITY_REF_NODE:
  ------------------
  |  Branch (5762:9): [True: 0, False: 8]
  ------------------
 5763|      8|        case XML_ENTITY_NODE:
  ------------------
  |  Branch (5763:9): [True: 0, False: 8]
  ------------------
 5764|      8|        case XML_PI_NODE:
  ------------------
  |  Branch (5764:9): [True: 0, False: 8]
  ------------------
 5765|      8|        case XML_COMMENT_NODE:
  ------------------
  |  Branch (5765:9): [True: 0, False: 8]
  ------------------
 5766|      8|        case XML_NOTATION_NODE:
  ------------------
  |  Branch (5766:9): [True: 0, False: 8]
  ------------------
 5767|      8|	    if (content != NULL) {
  ------------------
  |  Branch (5767:10): [True: 8, False: 0]
  ------------------
 5768|      8|	        if ((cur->content == (xmlChar *) &(cur->properties)) ||
  ------------------
  |  Branch (5768:14): [True: 0, False: 8]
  ------------------
 5769|      8|		    ((cur->doc != NULL) && (cur->doc->dict != NULL) &&
  ------------------
  |  Branch (5769:8): [True: 8, False: 0]
  |  Branch (5769:30): [True: 8, False: 0]
  ------------------
 5770|      8|			    xmlDictOwns(cur->doc->dict, cur->content))) {
  ------------------
  |  Branch (5770:8): [True: 8, False: 0]
  ------------------
 5771|      8|		    cur->content = xmlStrncatNew(cur->content, content, len);
 5772|      8|		    cur->properties = NULL;
 5773|      8|		} else {
 5774|      0|		    cur->content = xmlStrncat(cur->content, content, len);
 5775|      0|                }
 5776|      8|            }
 5777|      8|	    break;
 5778|      0|        case XML_DOCUMENT_NODE:
  ------------------
  |  Branch (5778:9): [True: 0, False: 8]
  ------------------
 5779|      0|        case XML_DTD_NODE:
  ------------------
  |  Branch (5779:9): [True: 0, False: 8]
  ------------------
 5780|      0|        case XML_HTML_DOCUMENT_NODE:
  ------------------
  |  Branch (5780:9): [True: 0, False: 8]
  ------------------
 5781|      0|        case XML_DOCUMENT_TYPE_NODE:
  ------------------
  |  Branch (5781:9): [True: 0, False: 8]
  ------------------
 5782|      0|	case XML_NAMESPACE_DECL:
  ------------------
  |  Branch (5782:2): [True: 0, False: 8]
  ------------------
 5783|      0|	case XML_XINCLUDE_START:
  ------------------
  |  Branch (5783:2): [True: 0, False: 8]
  ------------------
 5784|      0|	case XML_XINCLUDE_END:
  ------------------
  |  Branch (5784:2): [True: 0, False: 8]
  ------------------
 5785|      0|	    break;
 5786|      0|        case XML_ELEMENT_DECL:
  ------------------
  |  Branch (5786:9): [True: 0, False: 8]
  ------------------
 5787|      0|        case XML_ATTRIBUTE_DECL:
  ------------------
  |  Branch (5787:9): [True: 0, False: 8]
  ------------------
 5788|      0|        case XML_ENTITY_DECL:
  ------------------
  |  Branch (5788:9): [True: 0, False: 8]
  ------------------
 5789|      0|	    break;
 5790|      8|    }
 5791|      8|}
xmlGetNsList:
 5850|     20|{
 5851|     20|    xmlNsPtr cur;
 5852|     20|    xmlNsPtr *ret = NULL;
 5853|     20|    int nbns = 0;
 5854|     20|    int maxns = 0;
 5855|     20|    int i;
 5856|       |
 5857|     20|    if ((node == NULL) || (node->type == XML_NAMESPACE_DECL))
  ------------------
  |  Branch (5857:9): [True: 0, False: 20]
  |  Branch (5857:27): [True: 0, False: 20]
  ------------------
 5858|      0|        return(NULL);
 5859|       |
 5860|     80|    while (node != NULL) {
  ------------------
  |  Branch (5860:12): [True: 60, False: 20]
  ------------------
 5861|     60|        if (node->type == XML_ELEMENT_NODE) {
  ------------------
  |  Branch (5861:13): [True: 40, False: 20]
  ------------------
 5862|     40|            cur = node->nsDef;
 5863|     60|            while (cur != NULL) {
  ------------------
  |  Branch (5863:20): [True: 20, False: 40]
  ------------------
 5864|     20|                for (i = 0; i < nbns; i++) {
  ------------------
  |  Branch (5864:29): [True: 0, False: 20]
  ------------------
 5865|      0|                    if ((cur->prefix == ret[i]->prefix) ||
  ------------------
  |  Branch (5865:25): [True: 0, False: 0]
  ------------------
 5866|      0|                        (xmlStrEqual(cur->prefix, ret[i]->prefix)))
  ------------------
  |  Branch (5866:25): [True: 0, False: 0]
  ------------------
 5867|      0|                        break;
 5868|      0|                }
 5869|     20|                if (i >= nbns) {
  ------------------
  |  Branch (5869:21): [True: 20, False: 0]
  ------------------
 5870|     20|                    if (nbns >= maxns) {
  ------------------
  |  Branch (5870:25): [True: 20, False: 0]
  ------------------
 5871|     20|                        xmlNsPtr *tmp;
 5872|       |
 5873|     20|                        maxns = maxns ? maxns * 2 : 10;
  ------------------
  |  Branch (5873:33): [True: 0, False: 20]
  ------------------
 5874|     20|                        tmp = (xmlNsPtr *) xmlRealloc(ret,
 5875|     20|                                                      (maxns + 1) *
 5876|     20|                                                      sizeof(xmlNsPtr));
 5877|     20|                        if (tmp == NULL) {
  ------------------
  |  Branch (5877:29): [True: 0, False: 20]
  ------------------
 5878|      0|			    xmlTreeErrMemory("getting namespace list");
 5879|      0|                            xmlFree(ret);
 5880|      0|                            return (NULL);
 5881|      0|                        }
 5882|     20|                        ret = tmp;
 5883|     20|                    }
 5884|     20|                    ret[nbns++] = cur;
 5885|     20|                    ret[nbns] = NULL;
 5886|     20|                }
 5887|       |
 5888|     20|                cur = cur->next;
 5889|     20|            }
 5890|     40|        }
 5891|     60|        node = node->parent;
 5892|     60|    }
 5893|     20|    return (ret);
 5894|     20|}
xmlSearchNs:
 5946|     44|xmlSearchNs(xmlDocPtr doc, xmlNodePtr node, const xmlChar *nameSpace) {
 5947|       |
 5948|     44|    xmlNsPtr cur;
 5949|     44|    const xmlNode *orig = node;
 5950|       |
 5951|     44|    if ((node == NULL) || (node->type == XML_NAMESPACE_DECL)) return(NULL);
  ------------------
  |  Branch (5951:9): [True: 0, False: 44]
  |  Branch (5951:27): [True: 0, False: 44]
  ------------------
 5952|     44|    if ((nameSpace != NULL) &&
  ------------------
  |  Branch (5952:9): [True: 38, False: 6]
  ------------------
 5953|     44|	(xmlStrEqual(nameSpace, (const xmlChar *)"xml"))) {
  ------------------
  |  Branch (5953:2): [True: 16, False: 22]
  ------------------
 5954|     16|	if ((doc == NULL) && (node->type == XML_ELEMENT_NODE)) {
  ------------------
  |  Branch (5954:6): [True: 0, False: 16]
  |  Branch (5954:23): [True: 0, False: 0]
  ------------------
 5955|       |	    /*
 5956|       |	     * The XML-1.0 namespace is normally held on the root
 5957|       |	     * element. In this case exceptionally create it on the
 5958|       |	     * node element.
 5959|       |	     */
 5960|      0|	    cur = (xmlNsPtr) xmlMalloc(sizeof(xmlNs));
 5961|      0|	    if (cur == NULL) {
  ------------------
  |  Branch (5961:10): [True: 0, False: 0]
  ------------------
 5962|      0|		xmlTreeErrMemory("searching namespace");
 5963|      0|		return(NULL);
 5964|      0|	    }
 5965|      0|	    memset(cur, 0, sizeof(xmlNs));
 5966|      0|	    cur->type = XML_LOCAL_NAMESPACE;
  ------------------
  |  |  370|      0|#define XML_LOCAL_NAMESPACE XML_NAMESPACE_DECL
  ------------------
 5967|      0|	    cur->href = xmlStrdup(XML_XML_NAMESPACE);
  ------------------
  |  |  143|      0|    (const xmlChar *) "http://www.w3.org/XML/1998/namespace"
  ------------------
 5968|      0|	    cur->prefix = xmlStrdup((const xmlChar *)"xml");
 5969|      0|	    cur->next = node->nsDef;
 5970|      0|	    node->nsDef = cur;
 5971|      0|	    return(cur);
 5972|      0|	}
 5973|     16|	if (doc == NULL) {
  ------------------
  |  Branch (5973:6): [True: 0, False: 16]
  ------------------
 5974|      0|	    doc = node->doc;
 5975|      0|	    if (doc == NULL)
  ------------------
  |  Branch (5975:10): [True: 0, False: 0]
  ------------------
 5976|      0|		return(NULL);
 5977|      0|	}
 5978|       |	/*
 5979|       |	* Return the XML namespace declaration held by the doc.
 5980|       |	*/
 5981|     16|	if (doc->oldNs == NULL)
  ------------------
  |  Branch (5981:6): [True: 12, False: 4]
  ------------------
 5982|     12|	    return(xmlTreeEnsureXMLDecl(doc));
 5983|      4|	else
 5984|      4|	    return(doc->oldNs);
 5985|     16|    }
 5986|     71|    while (node != NULL) {
  ------------------
  |  Branch (5986:12): [True: 54, False: 17]
  ------------------
 5987|     54|	if ((node->type == XML_ENTITY_REF_NODE) ||
  ------------------
  |  Branch (5987:6): [True: 0, False: 54]
  ------------------
 5988|     54|	    (node->type == XML_ENTITY_NODE) ||
  ------------------
  |  Branch (5988:6): [True: 0, False: 54]
  ------------------
 5989|     54|	    (node->type == XML_ENTITY_DECL))
  ------------------
  |  Branch (5989:6): [True: 0, False: 54]
  ------------------
 5990|      0|	    return(NULL);
 5991|     54|	if (node->type == XML_ELEMENT_NODE) {
  ------------------
  |  Branch (5991:6): [True: 32, False: 22]
  ------------------
 5992|     32|	    cur = node->nsDef;
 5993|     34|	    while (cur != NULL) {
  ------------------
  |  Branch (5993:13): [True: 13, False: 21]
  ------------------
 5994|     13|		if ((cur->prefix == NULL) && (nameSpace == NULL) &&
  ------------------
  |  Branch (5994:7): [True: 0, False: 13]
  |  Branch (5994:32): [True: 0, False: 0]
  ------------------
 5995|     13|		    (cur->href != NULL))
  ------------------
  |  Branch (5995:7): [True: 0, False: 0]
  ------------------
 5996|      0|		    return(cur);
 5997|     13|		if ((cur->prefix != NULL) && (nameSpace != NULL) &&
  ------------------
  |  Branch (5997:7): [True: 13, False: 0]
  |  Branch (5997:32): [True: 11, False: 2]
  ------------------
 5998|     13|		    (cur->href != NULL) &&
  ------------------
  |  Branch (5998:7): [True: 11, False: 0]
  ------------------
 5999|     13|		    (xmlStrEqual(cur->prefix, nameSpace)))
  ------------------
  |  Branch (5999:7): [True: 11, False: 0]
  ------------------
 6000|     11|		    return(cur);
 6001|      2|		cur = cur->next;
 6002|      2|	    }
 6003|     21|	    if (orig != node) {
  ------------------
  |  Branch (6003:10): [True: 8, False: 13]
  ------------------
 6004|      8|	        cur = node->ns;
 6005|      8|	        if (cur != NULL) {
  ------------------
  |  Branch (6005:14): [True: 0, False: 8]
  ------------------
 6006|      0|		    if ((cur->prefix == NULL) && (nameSpace == NULL) &&
  ------------------
  |  Branch (6006:11): [True: 0, False: 0]
  |  Branch (6006:36): [True: 0, False: 0]
  ------------------
 6007|      0|		        (cur->href != NULL))
  ------------------
  |  Branch (6007:11): [True: 0, False: 0]
  ------------------
 6008|      0|		        return(cur);
 6009|      0|		    if ((cur->prefix != NULL) && (nameSpace != NULL) &&
  ------------------
  |  Branch (6009:11): [True: 0, False: 0]
  |  Branch (6009:36): [True: 0, False: 0]
  ------------------
 6010|      0|		        (cur->href != NULL) &&
  ------------------
  |  Branch (6010:11): [True: 0, False: 0]
  ------------------
 6011|      0|		        (xmlStrEqual(cur->prefix, nameSpace)))
  ------------------
  |  Branch (6011:11): [True: 0, False: 0]
  ------------------
 6012|      0|		        return(cur);
 6013|      0|	        }
 6014|      8|	    }
 6015|     21|	}
 6016|     43|	node = node->parent;
 6017|     43|    }
 6018|     17|    return(NULL);
 6019|     28|}
xmlSearchNsByHref:
 6076|     26|{
 6077|     26|    xmlNsPtr cur;
 6078|     26|    xmlNodePtr orig = node;
 6079|     26|    int is_attr;
 6080|       |
 6081|     26|    if ((node == NULL) || (node->type == XML_NAMESPACE_DECL) || (href == NULL))
  ------------------
  |  Branch (6081:9): [True: 0, False: 26]
  |  Branch (6081:27): [True: 0, False: 26]
  |  Branch (6081:65): [True: 0, False: 26]
  ------------------
 6082|      0|        return (NULL);
 6083|     26|    if (xmlStrEqual(href, XML_XML_NAMESPACE)) {
  ------------------
  |  |  143|     26|    (const xmlChar *) "http://www.w3.org/XML/1998/namespace"
  ------------------
  |  Branch (6083:9): [True: 26, False: 0]
  ------------------
 6084|       |        /*
 6085|       |         * Only the document can hold the XML spec namespace.
 6086|       |         */
 6087|     26|        if ((doc == NULL) && (node->type == XML_ELEMENT_NODE)) {
  ------------------
  |  Branch (6087:13): [True: 0, False: 26]
  |  Branch (6087:30): [True: 0, False: 0]
  ------------------
 6088|       |            /*
 6089|       |             * The XML-1.0 namespace is normally held on the root
 6090|       |             * element. In this case exceptionally create it on the
 6091|       |             * node element.
 6092|       |             */
 6093|      0|            cur = (xmlNsPtr) xmlMalloc(sizeof(xmlNs));
 6094|      0|            if (cur == NULL) {
  ------------------
  |  Branch (6094:17): [True: 0, False: 0]
  ------------------
 6095|      0|		xmlTreeErrMemory("searching namespace");
 6096|      0|                return (NULL);
 6097|      0|            }
 6098|      0|            memset(cur, 0, sizeof(xmlNs));
 6099|      0|            cur->type = XML_LOCAL_NAMESPACE;
  ------------------
  |  |  370|      0|#define XML_LOCAL_NAMESPACE XML_NAMESPACE_DECL
  ------------------
 6100|      0|            cur->href = xmlStrdup(XML_XML_NAMESPACE);
  ------------------
  |  |  143|      0|    (const xmlChar *) "http://www.w3.org/XML/1998/namespace"
  ------------------
 6101|      0|            cur->prefix = xmlStrdup((const xmlChar *) "xml");
 6102|      0|            cur->next = node->nsDef;
 6103|      0|            node->nsDef = cur;
 6104|      0|            return (cur);
 6105|      0|        }
 6106|     26|	if (doc == NULL) {
  ------------------
  |  Branch (6106:6): [True: 0, False: 26]
  ------------------
 6107|      0|	    doc = node->doc;
 6108|      0|	    if (doc == NULL)
  ------------------
  |  Branch (6108:10): [True: 0, False: 0]
  ------------------
 6109|      0|		return(NULL);
 6110|      0|	}
 6111|       |	/*
 6112|       |	* Return the XML namespace declaration held by the doc.
 6113|       |	*/
 6114|     26|	if (doc->oldNs == NULL)
  ------------------
  |  Branch (6114:6): [True: 18, False: 8]
  ------------------
 6115|     18|	    return(xmlTreeEnsureXMLDecl(doc));
 6116|      8|	else
 6117|      8|	    return(doc->oldNs);
 6118|     26|    }
 6119|      0|    is_attr = (node->type == XML_ATTRIBUTE_NODE);
 6120|      0|    while (node != NULL) {
  ------------------
  |  Branch (6120:12): [True: 0, False: 0]
  ------------------
 6121|      0|        if ((node->type == XML_ENTITY_REF_NODE) ||
  ------------------
  |  Branch (6121:13): [True: 0, False: 0]
  ------------------
 6122|      0|            (node->type == XML_ENTITY_NODE) ||
  ------------------
  |  Branch (6122:13): [True: 0, False: 0]
  ------------------
 6123|      0|            (node->type == XML_ENTITY_DECL))
  ------------------
  |  Branch (6123:13): [True: 0, False: 0]
  ------------------
 6124|      0|            return (NULL);
 6125|      0|        if (node->type == XML_ELEMENT_NODE) {
  ------------------
  |  Branch (6125:13): [True: 0, False: 0]
  ------------------
 6126|      0|            cur = node->nsDef;
 6127|      0|            while (cur != NULL) {
  ------------------
  |  Branch (6127:20): [True: 0, False: 0]
  ------------------
 6128|      0|                if ((cur->href != NULL) && (href != NULL) &&
  ------------------
  |  Branch (6128:21): [True: 0, False: 0]
  |  Branch (6128:44): [True: 0, False: 0]
  ------------------
 6129|      0|                    (xmlStrEqual(cur->href, href))) {
  ------------------
  |  Branch (6129:21): [True: 0, False: 0]
  ------------------
 6130|      0|		    if (((!is_attr) || (cur->prefix != NULL)) &&
  ------------------
  |  Branch (6130:12): [True: 0, False: 0]
  |  Branch (6130:26): [True: 0, False: 0]
  ------------------
 6131|      0|		        (xmlNsInScope(doc, orig, node, cur->prefix) == 1))
  ------------------
  |  Branch (6131:11): [True: 0, False: 0]
  ------------------
 6132|      0|			return (cur);
 6133|      0|                }
 6134|      0|                cur = cur->next;
 6135|      0|            }
 6136|      0|            if (orig != node) {
  ------------------
  |  Branch (6136:17): [True: 0, False: 0]
  ------------------
 6137|      0|                cur = node->ns;
 6138|      0|                if (cur != NULL) {
  ------------------
  |  Branch (6138:21): [True: 0, False: 0]
  ------------------
 6139|      0|                    if ((cur->href != NULL) && (href != NULL) &&
  ------------------
  |  Branch (6139:25): [True: 0, False: 0]
  |  Branch (6139:48): [True: 0, False: 0]
  ------------------
 6140|      0|                        (xmlStrEqual(cur->href, href))) {
  ------------------
  |  Branch (6140:25): [True: 0, False: 0]
  ------------------
 6141|      0|			if (((!is_attr) || (cur->prefix != NULL)) &&
  ------------------
  |  Branch (6141:9): [True: 0, False: 0]
  |  Branch (6141:23): [True: 0, False: 0]
  ------------------
 6142|      0|		            (xmlNsInScope(doc, orig, node, cur->prefix) == 1))
  ------------------
  |  Branch (6142:15): [True: 0, False: 0]
  ------------------
 6143|      0|			    return (cur);
 6144|      0|                    }
 6145|      0|                }
 6146|      0|            }
 6147|      0|        }
 6148|      0|        node = node->parent;
 6149|      0|    }
 6150|      0|    return (NULL);
 6151|      0|}
xmlHasProp:
 6583|  1.18k|xmlHasProp(const xmlNode *node, const xmlChar *name) {
 6584|  1.18k|    xmlAttrPtr prop;
 6585|  1.18k|    xmlDocPtr doc;
 6586|       |
 6587|  1.18k|    if ((node == NULL) || (node->type != XML_ELEMENT_NODE) || (name == NULL))
  ------------------
  |  Branch (6587:9): [True: 0, False: 1.18k]
  |  Branch (6587:27): [True: 0, False: 1.18k]
  |  Branch (6587:63): [True: 0, False: 1.18k]
  ------------------
 6588|      0|        return(NULL);
 6589|       |    /*
 6590|       |     * Check on the properties attached to the node
 6591|       |     */
 6592|  1.18k|    prop = node->properties;
 6593|  2.07k|    while (prop != NULL) {
  ------------------
  |  Branch (6593:12): [True: 1.25k, False: 815]
  ------------------
 6594|  1.25k|        if (xmlStrEqual(prop->name, name))  {
  ------------------
  |  Branch (6594:13): [True: 366, False: 889]
  ------------------
 6595|    366|	    return(prop);
 6596|    366|        }
 6597|    889|	prop = prop->next;
 6598|    889|    }
 6599|    815|    if (!xmlCheckDTD) return(NULL);
  ------------------
  |  Branch (6599:9): [True: 0, False: 815]
  ------------------
 6600|       |
 6601|       |    /*
 6602|       |     * Check if there is a default declaration in the internal
 6603|       |     * or external subsets
 6604|       |     */
 6605|    815|    doc =  node->doc;
 6606|    815|    if (doc != NULL) {
  ------------------
  |  Branch (6606:9): [True: 815, False: 0]
  ------------------
 6607|    815|        xmlAttributePtr attrDecl;
 6608|    815|        if (doc->intSubset != NULL) {
  ------------------
  |  Branch (6608:13): [True: 6, False: 809]
  ------------------
 6609|      6|	    attrDecl = xmlGetDtdAttrDesc(doc->intSubset, node->name, name);
 6610|      6|	    if ((attrDecl == NULL) && (doc->extSubset != NULL))
  ------------------
  |  Branch (6610:10): [True: 6, False: 0]
  |  Branch (6610:32): [True: 0, False: 6]
  ------------------
 6611|      0|		attrDecl = xmlGetDtdAttrDesc(doc->extSubset, node->name, name);
 6612|      6|            if ((attrDecl != NULL) && (attrDecl->defaultValue != NULL))
  ------------------
  |  Branch (6612:17): [True: 0, False: 6]
  |  Branch (6612:39): [True: 0, False: 0]
  ------------------
 6613|       |              /* return attribute declaration only if a default value is given
 6614|       |                 (that includes #FIXED declarations) */
 6615|      0|		return((xmlAttrPtr) attrDecl);
 6616|      6|	}
 6617|    815|    }
 6618|    815|    return(NULL);
 6619|    815|}
xmlGetProp:
 6660|  1.18k|xmlGetProp(const xmlNode *node, const xmlChar *name) {
 6661|  1.18k|    xmlAttrPtr prop;
 6662|       |
 6663|  1.18k|    prop = xmlHasProp(node, name);
 6664|  1.18k|    if (prop == NULL)
  ------------------
  |  Branch (6664:9): [True: 815, False: 366]
  ------------------
 6665|    815|	return(NULL);
 6666|    366|    return(xmlGetPropNodeValueInternal(prop));
 6667|  1.18k|}
xmlGetNsProp:
 6710|  5.00k|xmlGetNsProp(const xmlNode *node, const xmlChar *name, const xmlChar *nameSpace) {
 6711|  5.00k|    xmlAttrPtr prop;
 6712|       |
 6713|  5.00k|    prop = xmlGetPropNodeInternal(node, name, nameSpace, xmlCheckDTD);
 6714|  5.00k|    if (prop == NULL)
  ------------------
  |  Branch (6714:9): [True: 5.00k, False: 0]
  ------------------
 6715|  5.00k|	return(NULL);
 6716|      0|    return(xmlGetPropNodeValueInternal(prop));
 6717|  5.00k|}
xmlUnsetProp:
 6730|     26|xmlUnsetProp(xmlNodePtr node, const xmlChar *name) {
 6731|     26|    xmlAttrPtr prop;
 6732|       |
 6733|     26|    prop = xmlGetPropNodeInternal(node, name, NULL, 0);
 6734|     26|    if (prop == NULL)
  ------------------
  |  Branch (6734:9): [True: 0, False: 26]
  ------------------
 6735|      0|	return(-1);
 6736|     26|    xmlUnlinkNode((xmlNodePtr) prop);
 6737|     26|    xmlFreeProp(prop);
 6738|     26|    return(0);
 6739|     26|}
xmlSetNsProp:
 6817|     26|{
 6818|     26|    xmlAttrPtr prop;
 6819|       |
 6820|     26|    if (ns && (ns->href == NULL))
  ------------------
  |  Branch (6820:9): [True: 26, False: 0]
  |  Branch (6820:15): [True: 0, False: 26]
  ------------------
 6821|      0|	return(NULL);
 6822|     26|    prop = xmlGetPropNodeInternal(node, name, (ns != NULL) ? ns->href : NULL, 0);
  ------------------
  |  Branch (6822:47): [True: 26, False: 0]
  ------------------
 6823|     26|    if (prop != NULL) {
  ------------------
  |  Branch (6823:9): [True: 0, False: 26]
  ------------------
 6824|       |	/*
 6825|       |	* Modify the attribute's value.
 6826|       |	*/
 6827|      0|	if (prop->atype == XML_ATTRIBUTE_ID) {
  ------------------
  |  Branch (6827:6): [True: 0, False: 0]
  ------------------
 6828|      0|	    xmlRemoveID(node->doc, prop);
 6829|      0|	    prop->atype = XML_ATTRIBUTE_ID;
 6830|      0|	}
 6831|      0|	if (prop->children != NULL)
  ------------------
  |  Branch (6831:6): [True: 0, False: 0]
  ------------------
 6832|      0|	    xmlFreeNodeList(prop->children);
 6833|      0|	prop->children = NULL;
 6834|      0|	prop->last = NULL;
 6835|      0|	prop->ns = ns;
 6836|      0|	if (value != NULL) {
  ------------------
  |  Branch (6836:6): [True: 0, False: 0]
  ------------------
 6837|      0|	    xmlNodePtr tmp;
 6838|       |
 6839|      0|	    prop->children = xmlNewDocText(node->doc, value);
 6840|      0|	    prop->last = NULL;
 6841|      0|	    tmp = prop->children;
 6842|      0|	    while (tmp != NULL) {
  ------------------
  |  Branch (6842:13): [True: 0, False: 0]
  ------------------
 6843|      0|		tmp->parent = (xmlNodePtr) prop;
 6844|      0|		if (tmp->next == NULL)
  ------------------
  |  Branch (6844:7): [True: 0, False: 0]
  ------------------
 6845|      0|		    prop->last = tmp;
 6846|      0|		tmp = tmp->next;
 6847|      0|	    }
 6848|      0|	}
 6849|      0|	if (prop->atype == XML_ATTRIBUTE_ID)
  ------------------
  |  Branch (6849:6): [True: 0, False: 0]
  ------------------
 6850|      0|	    xmlAddID(NULL, node->doc, value, prop);
 6851|      0|	return(prop);
 6852|      0|    }
 6853|       |    /*
 6854|       |    * No equal attr found; create a new one.
 6855|       |    */
 6856|     26|    return(xmlNewPropInternal(node, ns, name, value, 0));
 6857|     26|}
xmlIsBlankNode:
 6886|    583|xmlIsBlankNode(const xmlNode *node) {
 6887|    583|    const xmlChar *cur;
 6888|    583|    if (node == NULL) return(0);
  ------------------
  |  Branch (6888:9): [True: 0, False: 583]
  ------------------
 6889|       |
 6890|    583|    if ((node->type != XML_TEXT_NODE) &&
  ------------------
  |  Branch (6890:9): [True: 0, False: 583]
  ------------------
 6891|    583|        (node->type != XML_CDATA_SECTION_NODE))
  ------------------
  |  Branch (6891:9): [True: 0, False: 0]
  ------------------
 6892|      0|	return(0);
 6893|    583|    if (node->content == NULL) return(1);
  ------------------
  |  Branch (6893:9): [True: 0, False: 583]
  ------------------
 6894|    583|    cur = node->content;
 6895|  2.58k|    while (*cur != 0) {
  ------------------
  |  Branch (6895:12): [True: 2.04k, False: 538]
  ------------------
 6896|  2.04k|	if (!IS_BLANK_CH(*cur)) return(0);
  ------------------
  |  |  151|  2.04k|#define IS_BLANK_CH(c)  xmlIsBlank_ch(c)
  |  |  ------------------
  |  |  |  |   88|  2.04k|#define xmlIsBlank_ch(c)	(((c) == 0x20) || \
  |  |  |  |  ------------------
  |  |  |  |  |  Branch (88:27): [True: 1.45k, False: 590]
  |  |  |  |  ------------------
  |  |  |  |   89|  2.04k|				 ((0x9 <= (c)) && ((c) <= 0xa)) || \
  |  |  |  |  ------------------
  |  |  |  |  |  Branch (89:7): [True: 590, False: 0]
  |  |  |  |  |  Branch (89:23): [True: 545, False: 45]
  |  |  |  |  ------------------
  |  |  |  |   90|  2.04k|				 ((c) == 0xd))
  |  |  |  |  ------------------
  |  |  |  |  |  Branch (90:6): [True: 0, False: 45]
  |  |  |  |  ------------------
  |  |  ------------------
  ------------------
 6897|  1.99k|	cur++;
 6898|  1.99k|    }
 6899|       |
 6900|    538|    return(1);
 6901|    583|}
tree.c:xmlNewPropInternal:
 1836|     28|{
 1837|     28|    xmlAttrPtr cur;
 1838|     28|    xmlDocPtr doc = NULL;
 1839|       |
 1840|     28|    if ((node != NULL) && (node->type != XML_ELEMENT_NODE)) {
  ------------------
  |  Branch (1840:9): [True: 28, False: 0]
  |  Branch (1840:27): [True: 0, False: 28]
  ------------------
 1841|      0|        if ((eatname == 1) &&
  ------------------
  |  Branch (1841:13): [True: 0, False: 0]
  ------------------
 1842|      0|	    ((node->doc == NULL) || (node->doc->dict == NULL) ||
  ------------------
  |  Branch (1842:7): [True: 0, False: 0]
  |  Branch (1842:30): [True: 0, False: 0]
  ------------------
 1843|      0|	     (!(xmlDictOwns(node->doc->dict, name)))))
  ------------------
  |  Branch (1843:7): [True: 0, False: 0]
  ------------------
 1844|      0|            xmlFree((xmlChar *) name);
 1845|      0|        return (NULL);
 1846|      0|    }
 1847|       |
 1848|       |    /*
 1849|       |     * Allocate a new property and fill the fields.
 1850|       |     */
 1851|     28|    cur = (xmlAttrPtr) xmlMalloc(sizeof(xmlAttr));
 1852|     28|    if (cur == NULL) {
  ------------------
  |  Branch (1852:9): [True: 0, False: 28]
  ------------------
 1853|      0|        if ((eatname == 1) &&
  ------------------
  |  Branch (1853:13): [True: 0, False: 0]
  ------------------
 1854|      0|	    ((node == NULL) || (node->doc == NULL) ||
  ------------------
  |  Branch (1854:7): [True: 0, False: 0]
  |  Branch (1854:25): [True: 0, False: 0]
  ------------------
 1855|      0|             (node->doc->dict == NULL) ||
  ------------------
  |  Branch (1855:14): [True: 0, False: 0]
  ------------------
 1856|      0|	     (!(xmlDictOwns(node->doc->dict, name)))))
  ------------------
  |  Branch (1856:7): [True: 0, False: 0]
  ------------------
 1857|      0|            xmlFree((xmlChar *) name);
 1858|      0|        xmlTreeErrMemory("building attribute");
 1859|      0|        return (NULL);
 1860|      0|    }
 1861|     28|    memset(cur, 0, sizeof(xmlAttr));
 1862|     28|    cur->type = XML_ATTRIBUTE_NODE;
 1863|       |
 1864|     28|    cur->parent = node;
 1865|     28|    if (node != NULL) {
  ------------------
  |  Branch (1865:9): [True: 28, False: 0]
  ------------------
 1866|     28|        doc = node->doc;
 1867|     28|        cur->doc = doc;
 1868|     28|    }
 1869|     28|    cur->ns = ns;
 1870|       |
 1871|     28|    if (eatname == 0) {
  ------------------
  |  Branch (1871:9): [True: 26, False: 2]
  ------------------
 1872|     26|        if ((doc != NULL) && (doc->dict != NULL))
  ------------------
  |  Branch (1872:13): [True: 26, False: 0]
  |  Branch (1872:30): [True: 26, False: 0]
  ------------------
 1873|     26|            cur->name = (xmlChar *) xmlDictLookup(doc->dict, name, -1);
 1874|      0|        else
 1875|      0|            cur->name = xmlStrdup(name);
 1876|     26|    } else
 1877|      2|        cur->name = name;
 1878|       |
 1879|     28|    if (value != NULL) {
  ------------------
  |  Branch (1879:9): [True: 26, False: 2]
  ------------------
 1880|     26|        xmlNodePtr tmp;
 1881|       |
 1882|     26|        cur->children = xmlNewDocText(doc, value);
 1883|     26|        cur->last = NULL;
 1884|     26|        tmp = cur->children;
 1885|     52|        while (tmp != NULL) {
  ------------------
  |  Branch (1885:16): [True: 26, False: 26]
  ------------------
 1886|     26|            tmp->parent = (xmlNodePtr) cur;
 1887|     26|            if (tmp->next == NULL)
  ------------------
  |  Branch (1887:17): [True: 26, False: 0]
  ------------------
 1888|     26|                cur->last = tmp;
 1889|     26|            tmp = tmp->next;
 1890|     26|        }
 1891|     26|    }
 1892|       |
 1893|       |    /*
 1894|       |     * Add it at the end to preserve parsing order ...
 1895|       |     */
 1896|     28|    if (node != NULL) {
  ------------------
  |  Branch (1896:9): [True: 28, False: 0]
  ------------------
 1897|     28|        if (node->properties == NULL) {
  ------------------
  |  Branch (1897:13): [True: 28, False: 0]
  ------------------
 1898|     28|            node->properties = cur;
 1899|     28|        } else {
 1900|      0|            xmlAttrPtr prev = node->properties;
 1901|       |
 1902|      0|            while (prev->next != NULL)
  ------------------
  |  Branch (1902:20): [True: 0, False: 0]
  ------------------
 1903|      0|                prev = prev->next;
 1904|      0|            prev->next = cur;
 1905|      0|            cur->prev = prev;
 1906|      0|        }
 1907|     28|    }
 1908|       |
 1909|     28|    if ((value != NULL) && (node != NULL) &&
  ------------------
  |  Branch (1909:9): [True: 26, False: 2]
  |  Branch (1909:28): [True: 26, False: 0]
  ------------------
 1910|     28|        (xmlIsID(node->doc, node, cur) == 1))
  ------------------
  |  Branch (1910:9): [True: 0, False: 26]
  ------------------
 1911|      0|        xmlAddID(NULL, node->doc, value, cur);
 1912|       |
 1913|     28|    if ((__xmlRegisterCallbacks) && (xmlRegisterNodeDefaultValue))
  ------------------
  |  |  682|      0|    XML_GLOBAL_MACRO(xmlRegisterNodeDefaultValue)
  |  |  ------------------
  |  |  |  |  500|      0|  #define XML_GLOBAL_MACRO(name) (*__##name())
  |  |  ------------------
  ------------------
  |  Branch (1913:9): [True: 0, False: 28]
  |  Branch (1913:37): [True: 0, False: 0]
  ------------------
 1914|      0|        xmlRegisterNodeDefaultValue((xmlNodePtr) cur);
  ------------------
  |  |  682|      0|    XML_GLOBAL_MACRO(xmlRegisterNodeDefaultValue)
  |  |  ------------------
  |  |  |  |  500|      0|  #define XML_GLOBAL_MACRO(name) (*__##name())
  |  |  ------------------
  ------------------
 1915|     28|    return (cur);
 1916|     28|}
tree.c:xmlCopyPropInternal:
 3934|     12|xmlCopyPropInternal(xmlDocPtr doc, xmlNodePtr target, xmlAttrPtr cur) {
 3935|     12|    xmlAttrPtr ret;
 3936|       |
 3937|     12|    if (cur == NULL) return(NULL);
  ------------------
  |  Branch (3937:9): [True: 0, False: 12]
  ------------------
 3938|     12|    if ((target != NULL) && (target->type != XML_ELEMENT_NODE))
  ------------------
  |  Branch (3938:9): [True: 12, False: 0]
  |  Branch (3938:29): [True: 0, False: 12]
  ------------------
 3939|      0|        return(NULL);
 3940|     12|    if (target != NULL)
  ------------------
  |  Branch (3940:9): [True: 12, False: 0]
  ------------------
 3941|     12|	ret = xmlNewDocProp(target->doc, cur->name, NULL);
 3942|      0|    else if (doc != NULL)
  ------------------
  |  Branch (3942:14): [True: 0, False: 0]
  ------------------
 3943|      0|	ret = xmlNewDocProp(doc, cur->name, NULL);
 3944|      0|    else if (cur->parent != NULL)
  ------------------
  |  Branch (3944:14): [True: 0, False: 0]
  ------------------
 3945|      0|	ret = xmlNewDocProp(cur->parent->doc, cur->name, NULL);
 3946|      0|    else if (cur->children != NULL)
  ------------------
  |  Branch (3946:14): [True: 0, False: 0]
  ------------------
 3947|      0|	ret = xmlNewDocProp(cur->children->doc, cur->name, NULL);
 3948|      0|    else
 3949|      0|	ret = xmlNewDocProp(NULL, cur->name, NULL);
 3950|     12|    if (ret == NULL) return(NULL);
  ------------------
  |  Branch (3950:9): [True: 0, False: 12]
  ------------------
 3951|     12|    ret->parent = target;
 3952|       |
 3953|     12|    if ((cur->ns != NULL) && (target != NULL)) {
  ------------------
  |  Branch (3953:9): [True: 4, False: 8]
  |  Branch (3953:30): [True: 4, False: 0]
  ------------------
 3954|      4|      xmlNsPtr ns;
 3955|       |
 3956|      4|      ns = xmlSearchNs(target->doc, target, cur->ns->prefix);
 3957|      4|      if (ns == NULL) {
  ------------------
  |  Branch (3957:11): [True: 0, False: 4]
  ------------------
 3958|       |        /*
 3959|       |         * Humm, we are copying an element whose namespace is defined
 3960|       |         * out of the new tree scope. Search it in the original tree
 3961|       |         * and add it at the top of the new tree
 3962|       |         */
 3963|      0|        ns = xmlSearchNs(cur->doc, cur->parent, cur->ns->prefix);
 3964|      0|        if (ns != NULL) {
  ------------------
  |  Branch (3964:13): [True: 0, False: 0]
  ------------------
 3965|      0|          xmlNodePtr root = target;
 3966|      0|          xmlNodePtr pred = NULL;
 3967|       |
 3968|      0|          while (root->parent != NULL) {
  ------------------
  |  Branch (3968:18): [True: 0, False: 0]
  ------------------
 3969|      0|            pred = root;
 3970|      0|            root = root->parent;
 3971|      0|          }
 3972|      0|          if (root == (xmlNodePtr) target->doc) {
  ------------------
  |  Branch (3972:15): [True: 0, False: 0]
  ------------------
 3973|       |            /* correct possibly cycling above the document elt */
 3974|      0|            root = pred;
 3975|      0|          }
 3976|      0|          ret->ns = xmlNewNs(root, ns->href, ns->prefix);
 3977|      0|        }
 3978|      4|      } else {
 3979|       |        /*
 3980|       |         * we have to find something appropriate here since
 3981|       |         * we can't be sure, that the namespace we found is identified
 3982|       |         * by the prefix
 3983|       |         */
 3984|      4|        if (xmlStrEqual(ns->href, cur->ns->href)) {
  ------------------
  |  Branch (3984:13): [True: 4, False: 0]
  ------------------
 3985|       |          /* this is the nice case */
 3986|      4|          ret->ns = ns;
 3987|      4|        } else {
 3988|       |          /*
 3989|       |           * we are in trouble: we need a new reconciled namespace.
 3990|       |           * This is expensive
 3991|       |           */
 3992|      0|          ret->ns = xmlNewReconciledNs(target->doc, target, cur->ns);
 3993|      0|        }
 3994|      4|      }
 3995|       |
 3996|      4|    } else
 3997|      8|        ret->ns = NULL;
 3998|       |
 3999|     12|    if (cur->children != NULL) {
  ------------------
  |  Branch (3999:9): [True: 12, False: 0]
  ------------------
 4000|     12|	xmlNodePtr tmp;
 4001|       |
 4002|     12|	ret->children = xmlStaticCopyNodeList(cur->children, ret->doc, (xmlNodePtr) ret);
 4003|     12|	ret->last = NULL;
 4004|     12|	tmp = ret->children;
 4005|     24|	while (tmp != NULL) {
  ------------------
  |  Branch (4005:9): [True: 12, False: 12]
  ------------------
 4006|       |	    /* tmp->parent = (xmlNodePtr)ret; */
 4007|     12|	    if (tmp->next == NULL)
  ------------------
  |  Branch (4007:10): [True: 12, False: 0]
  ------------------
 4008|     12|	        ret->last = tmp;
 4009|     12|	    tmp = tmp->next;
 4010|     12|	}
 4011|     12|    }
 4012|       |    /*
 4013|       |     * Try to handle IDs
 4014|       |     */
 4015|     12|    if ((target!= NULL) && (cur!= NULL) &&
  ------------------
  |  Branch (4015:9): [True: 12, False: 0]
  |  Branch (4015:28): [True: 12, False: 0]
  ------------------
 4016|     12|	(target->doc != NULL) && (cur->doc != NULL) &&
  ------------------
  |  Branch (4016:2): [True: 12, False: 0]
  |  Branch (4016:27): [True: 12, False: 0]
  ------------------
 4017|     12|	(cur->doc->ids != NULL) && (cur->parent != NULL)) {
  ------------------
  |  Branch (4017:2): [True: 8, False: 4]
  |  Branch (4017:29): [True: 8, False: 0]
  ------------------
 4018|      8|	if (xmlIsID(cur->doc, cur->parent, cur)) {
  ------------------
  |  Branch (4018:6): [True: 8, False: 0]
  ------------------
 4019|      8|	    xmlChar *id;
 4020|       |
 4021|      8|	    id = xmlNodeListGetString(cur->doc, cur->children, 1);
 4022|      8|	    if (id != NULL) {
  ------------------
  |  Branch (4022:10): [True: 8, False: 0]
  ------------------
 4023|      8|		xmlAddID(NULL, target->doc, id, ret);
 4024|      8|		xmlFree(id);
 4025|      8|	    }
 4026|      8|	}
 4027|      8|    }
 4028|     12|    return(ret);
 4029|     12|}
tree.c:xmlGetLineNoInternal:
 4579|     38|{
 4580|     38|    long result = -1;
 4581|       |
 4582|     38|    if (depth >= 5)
  ------------------
  |  Branch (4582:9): [True: 0, False: 38]
  ------------------
 4583|      0|        return(-1);
 4584|       |
 4585|     38|    if (!node)
  ------------------
  |  Branch (4585:9): [True: 0, False: 38]
  ------------------
 4586|      0|        return result;
 4587|     38|    if ((node->type == XML_ELEMENT_NODE) ||
  ------------------
  |  Branch (4587:9): [True: 38, False: 0]
  ------------------
 4588|     38|        (node->type == XML_TEXT_NODE) ||
  ------------------
  |  Branch (4588:9): [True: 0, False: 0]
  ------------------
 4589|     38|	(node->type == XML_COMMENT_NODE) ||
  ------------------
  |  Branch (4589:2): [True: 0, False: 0]
  ------------------
 4590|     38|	(node->type == XML_PI_NODE)) {
  ------------------
  |  Branch (4590:2): [True: 0, False: 0]
  ------------------
 4591|     38|	if (node->line == 65535) {
  ------------------
  |  Branch (4591:6): [True: 0, False: 38]
  ------------------
 4592|      0|	    if ((node->type == XML_TEXT_NODE) && (node->psvi != NULL))
  ------------------
  |  Branch (4592:10): [True: 0, False: 0]
  |  Branch (4592:43): [True: 0, False: 0]
  ------------------
 4593|      0|	        result = (long) (ptrdiff_t) node->psvi;
 4594|      0|	    else if ((node->type == XML_ELEMENT_NODE) &&
  ------------------
  |  Branch (4594:15): [True: 0, False: 0]
  ------------------
 4595|      0|	             (node->children != NULL))
  ------------------
  |  Branch (4595:15): [True: 0, False: 0]
  ------------------
 4596|      0|	        result = xmlGetLineNoInternal(node->children, depth + 1);
 4597|      0|	    else if (node->next != NULL)
  ------------------
  |  Branch (4597:15): [True: 0, False: 0]
  ------------------
 4598|      0|	        result = xmlGetLineNoInternal(node->next, depth + 1);
 4599|      0|	    else if (node->prev != NULL)
  ------------------
  |  Branch (4599:15): [True: 0, False: 0]
  ------------------
 4600|      0|	        result = xmlGetLineNoInternal(node->prev, depth + 1);
 4601|      0|	}
 4602|     38|	if ((result == -1) || (result == 65535))
  ------------------
  |  Branch (4602:6): [True: 38, False: 0]
  |  Branch (4602:24): [True: 0, False: 0]
  ------------------
 4603|     38|	    result = (long) node->line;
 4604|     38|    } else if ((node->prev != NULL) &&
  ------------------
  |  Branch (4604:16): [True: 0, False: 0]
  ------------------
 4605|      0|             ((node->prev->type == XML_ELEMENT_NODE) ||
  ------------------
  |  Branch (4605:15): [True: 0, False: 0]
  ------------------
 4606|      0|	      (node->prev->type == XML_TEXT_NODE) ||
  ------------------
  |  Branch (4606:8): [True: 0, False: 0]
  ------------------
 4607|      0|	      (node->prev->type == XML_COMMENT_NODE) ||
  ------------------
  |  Branch (4607:8): [True: 0, False: 0]
  ------------------
 4608|      0|	      (node->prev->type == XML_PI_NODE)))
  ------------------
  |  Branch (4608:8): [True: 0, False: 0]
  ------------------
 4609|      0|        result = xmlGetLineNoInternal(node->prev, depth + 1);
 4610|      0|    else if ((node->parent != NULL) &&
  ------------------
  |  Branch (4610:14): [True: 0, False: 0]
  ------------------
 4611|      0|             (node->parent->type == XML_ELEMENT_NODE))
  ------------------
  |  Branch (4611:14): [True: 0, False: 0]
  ------------------
 4612|      0|        result = xmlGetLineNoInternal(node->parent, depth + 1);
 4613|       |
 4614|     38|    return result;
 4615|     38|}
tree.c:xmlTreeEnsureXMLDecl:
 5907|     30|{
 5908|     30|    if (doc == NULL)
  ------------------
  |  Branch (5908:9): [True: 0, False: 30]
  ------------------
 5909|      0|	return (NULL);
 5910|     30|    if (doc->oldNs != NULL)
  ------------------
  |  Branch (5910:9): [True: 0, False: 30]
  ------------------
 5911|      0|	return (doc->oldNs);
 5912|     30|    {
 5913|     30|	xmlNsPtr ns;
 5914|     30|	ns = (xmlNsPtr) xmlMalloc(sizeof(xmlNs));
 5915|     30|	if (ns == NULL) {
  ------------------
  |  Branch (5915:6): [True: 0, False: 30]
  ------------------
 5916|      0|	    xmlTreeErrMemory(
 5917|      0|		"allocating the XML namespace");
 5918|      0|	    return (NULL);
 5919|      0|	}
 5920|     30|	memset(ns, 0, sizeof(xmlNs));
 5921|     30|	ns->type = XML_LOCAL_NAMESPACE;
  ------------------
  |  |  370|     30|#define XML_LOCAL_NAMESPACE XML_NAMESPACE_DECL
  ------------------
 5922|     30|	ns->href = xmlStrdup(XML_XML_NAMESPACE);
  ------------------
  |  |  143|     30|    (const xmlChar *) "http://www.w3.org/XML/1998/namespace"
  ------------------
 5923|     30|	ns->prefix = xmlStrdup((const xmlChar *)"xml");
 5924|     30|	doc->oldNs = ns;
 5925|     30|	return (ns);
 5926|     30|    }
 5927|     30|}
tree.c:xmlNewReconciledNs:
 6167|      4|xmlNewReconciledNs(xmlDocPtr doc, xmlNodePtr tree, xmlNsPtr ns) {
 6168|      4|    xmlNsPtr def;
 6169|      4|    xmlChar prefix[50];
 6170|      4|    int counter = 1;
 6171|       |
 6172|      4|    if ((tree == NULL) || (tree->type != XML_ELEMENT_NODE)) {
  ------------------
  |  Branch (6172:9): [True: 0, False: 4]
  |  Branch (6172:27): [True: 4, False: 0]
  ------------------
 6173|      4|	return(NULL);
 6174|      4|    }
 6175|      0|    if ((ns == NULL) || (ns->type != XML_NAMESPACE_DECL)) {
  ------------------
  |  Branch (6175:9): [True: 0, False: 0]
  |  Branch (6175:25): [True: 0, False: 0]
  ------------------
 6176|      0|	return(NULL);
 6177|      0|    }
 6178|       |    /*
 6179|       |     * Search an existing namespace definition inherited.
 6180|       |     */
 6181|      0|    def = xmlSearchNsByHref(doc, tree, ns->href);
 6182|      0|    if (def != NULL)
  ------------------
  |  Branch (6182:9): [True: 0, False: 0]
  ------------------
 6183|      0|        return(def);
 6184|       |
 6185|       |    /*
 6186|       |     * Find a close prefix which is not already in use.
 6187|       |     * Let's strip namespace prefixes longer than 20 chars !
 6188|       |     */
 6189|      0|    if (ns->prefix == NULL)
  ------------------
  |  Branch (6189:9): [True: 0, False: 0]
  ------------------
 6190|      0|	snprintf((char *) prefix, sizeof(prefix), "default");
 6191|      0|    else
 6192|      0|	snprintf((char *) prefix, sizeof(prefix), "%.20s", (char *)ns->prefix);
 6193|       |
 6194|      0|    def = xmlSearchNs(doc, tree, prefix);
 6195|      0|    while (def != NULL) {
  ------------------
  |  Branch (6195:12): [True: 0, False: 0]
  ------------------
 6196|      0|        if (counter > 1000) return(NULL);
  ------------------
  |  Branch (6196:13): [True: 0, False: 0]
  ------------------
 6197|      0|	if (ns->prefix == NULL)
  ------------------
  |  Branch (6197:6): [True: 0, False: 0]
  ------------------
 6198|      0|	    snprintf((char *) prefix, sizeof(prefix), "default%d", counter++);
 6199|      0|	else
 6200|      0|	    snprintf((char *) prefix, sizeof(prefix), "%.20s%d",
 6201|      0|		(char *)ns->prefix, counter++);
 6202|      0|	def = xmlSearchNs(doc, tree, prefix);
 6203|      0|    }
 6204|       |
 6205|       |    /*
 6206|       |     * OK, now we are ready to create a new one.
 6207|       |     */
 6208|      0|    def = xmlNewNs(tree, ns->href, prefix);
 6209|      0|    return(def);
 6210|      0|}
tree.c:xmlGetPropNodeValueInternal:
 6538|    366|{
 6539|    366|    if (prop == NULL)
  ------------------
  |  Branch (6539:9): [True: 0, False: 366]
  ------------------
 6540|      0|	return(NULL);
 6541|    366|    if (prop->type == XML_ATTRIBUTE_NODE) {
  ------------------
  |  Branch (6541:9): [True: 366, False: 0]
  ------------------
 6542|       |	/*
 6543|       |	* Note that we return at least the empty string.
 6544|       |	*   TODO: Do we really always want that?
 6545|       |	*/
 6546|    366|	if (prop->children != NULL) {
  ------------------
  |  Branch (6546:6): [True: 366, False: 0]
  ------------------
 6547|    366|	    if ((prop->children->next == NULL) &&
  ------------------
  |  Branch (6547:10): [True: 366, False: 0]
  ------------------
 6548|    366|		((prop->children->type == XML_TEXT_NODE) ||
  ------------------
  |  Branch (6548:4): [True: 366, False: 0]
  ------------------
 6549|    366|		(prop->children->type == XML_CDATA_SECTION_NODE)))
  ------------------
  |  Branch (6549:3): [True: 0, False: 0]
  ------------------
 6550|    366|	    {
 6551|       |		/*
 6552|       |		* Optimization for the common case: only 1 text node.
 6553|       |		*/
 6554|    366|		return(xmlStrdup(prop->children->content));
 6555|    366|	    } else {
 6556|      0|		xmlChar *ret;
 6557|       |
 6558|      0|		ret = xmlNodeListGetString(prop->doc, prop->children, 1);
 6559|      0|		if (ret != NULL)
  ------------------
  |  Branch (6559:7): [True: 0, False: 0]
  ------------------
 6560|      0|		    return(ret);
 6561|      0|	    }
 6562|    366|	}
 6563|      0|	return(xmlStrdup((xmlChar *)""));
 6564|    366|    } else if (prop->type == XML_ATTRIBUTE_DECL) {
  ------------------
  |  Branch (6564:16): [True: 0, False: 0]
  ------------------
 6565|      0|	return(xmlStrdup(((xmlAttributePtr)prop)->defaultValue));
 6566|      0|    }
 6567|      0|    return(NULL);
 6568|    366|}
tree.c:xmlGetPropNodeInternal:
 6412|  5.05k|{
 6413|  5.05k|    xmlAttrPtr prop;
 6414|       |
 6415|       |    /* Avoid unused variable warning if features are disabled. */
 6416|  5.05k|    (void) useDTD;
 6417|       |
 6418|  5.05k|    if ((node == NULL) || (node->type != XML_ELEMENT_NODE) || (name == NULL))
  ------------------
  |  Branch (6418:9): [True: 0, False: 5.05k]
  |  Branch (6418:27): [True: 0, False: 5.05k]
  |  Branch (6418:63): [True: 0, False: 5.05k]
  ------------------
 6419|      0|	return(NULL);
 6420|       |
 6421|  5.05k|    if (node->properties != NULL) {
  ------------------
  |  Branch (6421:9): [True: 3.62k, False: 1.43k]
  ------------------
 6422|  3.62k|	prop = node->properties;
 6423|  3.62k|	if (nsName == NULL) {
  ------------------
  |  Branch (6423:6): [True: 26, False: 3.59k]
  ------------------
 6424|       |	    /*
 6425|       |	    * We want the attr to be in no namespace.
 6426|       |	    */
 6427|     26|	    do {
 6428|     26|		if ((prop->ns == NULL) && xmlStrEqual(prop->name, name)) {
  ------------------
  |  Branch (6428:7): [True: 26, False: 0]
  |  Branch (6428:29): [True: 26, False: 0]
  ------------------
 6429|     26|		    return(prop);
 6430|     26|		}
 6431|      0|		prop = prop->next;
 6432|      0|	    } while (prop != NULL);
  ------------------
  |  Branch (6432:15): [True: 0, False: 0]
  ------------------
 6433|  3.59k|	} else {
 6434|       |	    /*
 6435|       |	    * We want the attr to be in the specified namespace.
 6436|       |	    */
 6437|  3.85k|	    do {
 6438|  3.85k|		if ((prop->ns != NULL) && xmlStrEqual(prop->name, name) &&
  ------------------
  |  Branch (6438:7): [True: 0, False: 3.85k]
  |  Branch (6438:29): [True: 0, False: 0]
  ------------------
 6439|  3.85k|		    ((prop->ns->href == nsName) ||
  ------------------
  |  Branch (6439:8): [True: 0, False: 0]
  ------------------
 6440|      0|		     xmlStrEqual(prop->ns->href, nsName)))
  ------------------
  |  Branch (6440:8): [True: 0, False: 0]
  ------------------
 6441|      0|		{
 6442|      0|		    return(prop);
 6443|      0|		}
 6444|  3.85k|		prop = prop->next;
 6445|  3.85k|	    } while (prop != NULL);
  ------------------
  |  Branch (6445:15): [True: 260, False: 3.59k]
  ------------------
 6446|  3.59k|	}
 6447|  3.62k|    }
 6448|       |
 6449|  5.02k|#ifdef LIBXML_TREE_ENABLED
 6450|  5.02k|    if (! useDTD)
  ------------------
  |  Branch (6450:9): [True: 26, False: 5.00k]
  ------------------
 6451|     26|	return(NULL);
 6452|       |    /*
 6453|       |     * Check if there is a default/fixed attribute declaration in
 6454|       |     * the internal or external subset.
 6455|       |     */
 6456|  5.00k|    if ((node->doc != NULL) && (node->doc->intSubset != NULL)) {
  ------------------
  |  Branch (6456:9): [True: 5.00k, False: 0]
  |  Branch (6456:32): [True: 32, False: 4.97k]
  ------------------
 6457|     32|	xmlDocPtr doc = node->doc;
 6458|     32|	xmlAttributePtr attrDecl = NULL;
 6459|     32|	xmlChar *elemQName, *tmpstr = NULL;
 6460|       |
 6461|       |	/*
 6462|       |	* We need the QName of the element for the DTD-lookup.
 6463|       |	*/
 6464|     32|	if ((node->ns != NULL) && (node->ns->prefix != NULL)) {
  ------------------
  |  Branch (6464:6): [True: 26, False: 6]
  |  Branch (6464:28): [True: 26, False: 0]
  ------------------
 6465|     26|	    tmpstr = xmlStrdup(node->ns->prefix);
 6466|     26|	    tmpstr = xmlStrcat(tmpstr, BAD_CAST ":");
  ------------------
  |  |   35|     26|#define BAD_CAST (xmlChar *)
  ------------------
 6467|     26|	    tmpstr = xmlStrcat(tmpstr, node->name);
 6468|     26|	    if (tmpstr == NULL)
  ------------------
  |  Branch (6468:10): [True: 0, False: 26]
  ------------------
 6469|      0|		return(NULL);
 6470|     26|	    elemQName = tmpstr;
 6471|     26|	} else
 6472|      6|	    elemQName = (xmlChar *) node->name;
 6473|     32|	if (nsName == NULL) {
  ------------------
  |  Branch (6473:6): [True: 0, False: 32]
  ------------------
 6474|       |	    /*
 6475|       |	    * The common and nice case: Attr in no namespace.
 6476|       |	    */
 6477|      0|	    attrDecl = xmlGetDtdQAttrDesc(doc->intSubset,
 6478|      0|		elemQName, name, NULL);
 6479|      0|	    if ((attrDecl == NULL) && (doc->extSubset != NULL)) {
  ------------------
  |  Branch (6479:10): [True: 0, False: 0]
  |  Branch (6479:32): [True: 0, False: 0]
  ------------------
 6480|      0|		attrDecl = xmlGetDtdQAttrDesc(doc->extSubset,
 6481|      0|		    elemQName, name, NULL);
 6482|      0|	    }
 6483|     32|        } else if (xmlStrEqual(nsName, XML_XML_NAMESPACE)) {
  ------------------
  |  |  143|     32|    (const xmlChar *) "http://www.w3.org/XML/1998/namespace"
  ------------------
  |  Branch (6483:20): [True: 12, False: 20]
  ------------------
 6484|       |	    /*
 6485|       |	    * The XML namespace must be bound to prefix 'xml'.
 6486|       |	    */
 6487|     12|	    attrDecl = xmlGetDtdQAttrDesc(doc->intSubset,
 6488|     12|		elemQName, name, BAD_CAST "xml");
  ------------------
  |  |   35|     12|#define BAD_CAST (xmlChar *)
  ------------------
 6489|     12|	    if ((attrDecl == NULL) && (doc->extSubset != NULL)) {
  ------------------
  |  Branch (6489:10): [True: 12, False: 0]
  |  Branch (6489:32): [True: 0, False: 12]
  ------------------
 6490|      0|		attrDecl = xmlGetDtdQAttrDesc(doc->extSubset,
 6491|      0|		    elemQName, name, BAD_CAST "xml");
  ------------------
  |  |   35|      0|#define BAD_CAST (xmlChar *)
  ------------------
 6492|      0|	    }
 6493|     20|	} else {
 6494|     20|	    xmlNsPtr *nsList, *cur;
 6495|       |
 6496|       |	    /*
 6497|       |	    * The ugly case: Search using the prefixes of in-scope
 6498|       |	    * ns-decls corresponding to @nsName.
 6499|       |	    */
 6500|     20|	    nsList = xmlGetNsList(node->doc, node);
 6501|     20|	    if (nsList == NULL) {
  ------------------
  |  Branch (6501:10): [True: 0, False: 20]
  ------------------
 6502|      0|		if (tmpstr != NULL)
  ------------------
  |  Branch (6502:7): [True: 0, False: 0]
  ------------------
 6503|      0|		    xmlFree(tmpstr);
 6504|      0|		return(NULL);
 6505|      0|	    }
 6506|     20|	    cur = nsList;
 6507|     40|	    while (*cur != NULL) {
  ------------------
  |  Branch (6507:13): [True: 20, False: 20]
  ------------------
 6508|     20|		if (xmlStrEqual((*cur)->href, nsName)) {
  ------------------
  |  Branch (6508:7): [True: 0, False: 20]
  ------------------
 6509|      0|		    attrDecl = xmlGetDtdQAttrDesc(doc->intSubset, elemQName,
 6510|      0|			name, (*cur)->prefix);
 6511|      0|		    if (attrDecl)
  ------------------
  |  Branch (6511:11): [True: 0, False: 0]
  ------------------
 6512|      0|			break;
 6513|      0|		    if (doc->extSubset != NULL) {
  ------------------
  |  Branch (6513:11): [True: 0, False: 0]
  ------------------
 6514|      0|			attrDecl = xmlGetDtdQAttrDesc(doc->extSubset, elemQName,
 6515|      0|			    name, (*cur)->prefix);
 6516|      0|			if (attrDecl)
  ------------------
  |  Branch (6516:8): [True: 0, False: 0]
  ------------------
 6517|      0|			    break;
 6518|      0|		    }
 6519|      0|		}
 6520|     20|		cur++;
 6521|     20|	    }
 6522|     20|	    xmlFree(nsList);
 6523|     20|	}
 6524|     32|	if (tmpstr != NULL)
  ------------------
  |  Branch (6524:6): [True: 26, False: 6]
  ------------------
 6525|     26|	    xmlFree(tmpstr);
 6526|       |	/*
 6527|       |	* Only default/fixed attrs are relevant.
 6528|       |	*/
 6529|     32|	if ((attrDecl != NULL) && (attrDecl->defaultValue != NULL))
  ------------------
  |  Branch (6529:6): [True: 0, False: 32]
  |  Branch (6529:28): [True: 0, False: 0]
  ------------------
 6530|      0|	    return((xmlAttrPtr) attrDecl);
 6531|     32|    }
 6532|  5.00k|#endif /* LIBXML_TREE_ENABLED */
 6533|  5.00k|    return(NULL);
 6534|  5.00k|}

xmlParseURI:
  947|  1.06k|xmlParseURI(const char *str) {
  948|  1.06k|    xmlURIPtr uri;
  949|  1.06k|    int ret;
  950|       |
  951|  1.06k|    if (str == NULL)
  ------------------
  |  Branch (951:9): [True: 0, False: 1.06k]
  ------------------
  952|      0|	return(NULL);
  953|  1.06k|    uri = xmlCreateURI();
  954|  1.06k|    if (uri != NULL) {
  ------------------
  |  Branch (954:9): [True: 1.06k, False: 0]
  ------------------
  955|  1.06k|	ret = xmlParse3986URIReference(uri, str);
  956|  1.06k|        if (ret) {
  ------------------
  |  Branch (956:13): [True: 36, False: 1.02k]
  ------------------
  957|     36|	    xmlFreeURI(uri);
  958|     36|	    return(NULL);
  959|     36|	}
  960|  1.06k|    }
  961|  1.02k|    return(uri);
  962|  1.06k|}
xmlParseURIReference:
  977|    751|xmlParseURIReference(xmlURIPtr uri, const char *str) {
  978|    751|    return(xmlParse3986URIReference(uri, str));
  979|    751|}
xmlCreateURI:
 1027|  1.94k|xmlCreateURI(void) {
 1028|  1.94k|    xmlURIPtr ret;
 1029|       |
 1030|  1.94k|    ret = (xmlURIPtr) xmlMalloc(sizeof(xmlURI));
 1031|  1.94k|    if (ret == NULL) {
  ------------------
  |  Branch (1031:9): [True: 2, False: 1.94k]
  ------------------
 1032|      2|        xmlURIErrMemory("creating URI structure\n");
 1033|      2|	return(NULL);
 1034|      2|    }
 1035|  1.94k|    memset(ret, 0, sizeof(xmlURI));
 1036|  1.94k|    ret->port = PORT_EMPTY;
  ------------------
  |  |   37|  1.94k|#define PORT_EMPTY           0
  ------------------
 1037|  1.94k|    return(ret);
 1038|  1.94k|}
xmlSaveUri:
 1074|    810|xmlSaveUri(xmlURIPtr uri) {
 1075|    810|    xmlChar *ret = NULL;
 1076|    810|    xmlChar *temp;
 1077|    810|    const char *p;
 1078|    810|    int len;
 1079|    810|    int max;
 1080|       |
 1081|    810|    if (uri == NULL) return(NULL);
  ------------------
  |  Branch (1081:9): [True: 0, False: 810]
  ------------------
 1082|       |
 1083|       |
 1084|    810|    max = 80;
 1085|    810|    ret = (xmlChar *) xmlMallocAtomic(max + 1);
 1086|    810|    if (ret == NULL) {
  ------------------
  |  Branch (1086:9): [True: 0, False: 810]
  ------------------
 1087|      0|        xmlURIErrMemory("saving URI\n");
 1088|      0|	return(NULL);
 1089|      0|    }
 1090|    810|    len = 0;
 1091|       |
 1092|    810|    if (uri->scheme != NULL) {
  ------------------
  |  Branch (1092:9): [True: 0, False: 810]
  ------------------
 1093|      0|	p = uri->scheme;
 1094|      0|	while (*p != 0) {
  ------------------
  |  Branch (1094:9): [True: 0, False: 0]
  ------------------
 1095|      0|	    if (len >= max) {
  ------------------
  |  Branch (1095:10): [True: 0, False: 0]
  ------------------
 1096|      0|                temp = xmlSaveUriRealloc(ret, &max);
 1097|      0|                if (temp == NULL) goto mem_error;
  ------------------
  |  Branch (1097:21): [True: 0, False: 0]
  ------------------
 1098|      0|		ret = temp;
 1099|      0|	    }
 1100|      0|	    ret[len++] = *p++;
 1101|      0|	}
 1102|      0|	if (len >= max) {
  ------------------
  |  Branch (1102:6): [True: 0, False: 0]
  ------------------
 1103|      0|            temp = xmlSaveUriRealloc(ret, &max);
 1104|      0|            if (temp == NULL) goto mem_error;
  ------------------
  |  Branch (1104:17): [True: 0, False: 0]
  ------------------
 1105|      0|            ret = temp;
 1106|      0|	}
 1107|      0|	ret[len++] = ':';
 1108|      0|    }
 1109|    810|    if (uri->opaque != NULL) {
  ------------------
  |  Branch (1109:9): [True: 0, False: 810]
  ------------------
 1110|      0|	p = uri->opaque;
 1111|      0|	while (*p != 0) {
  ------------------
  |  Branch (1111:9): [True: 0, False: 0]
  ------------------
 1112|      0|	    if (len + 3 >= max) {
  ------------------
  |  Branch (1112:10): [True: 0, False: 0]
  ------------------
 1113|      0|                temp = xmlSaveUriRealloc(ret, &max);
 1114|      0|                if (temp == NULL) goto mem_error;
  ------------------
  |  Branch (1114:21): [True: 0, False: 0]
  ------------------
 1115|      0|                ret = temp;
 1116|      0|	    }
 1117|      0|	    if (IS_RESERVED(*(p)) || IS_UNRESERVED(*(p)))
  ------------------
  |  |  116|      0|#define IS_RESERVED(x) (((x) == ';') || ((x) == '/') || ((x) == '?') || \
  |  |  ------------------
  |  |  |  Branch (116:25): [True: 0, False: 0]
  |  |  |  Branch (116:41): [True: 0, False: 0]
  |  |  |  Branch (116:57): [True: 0, False: 0]
  |  |  ------------------
  |  |  117|      0|        ((x) == ':') || ((x) == '@') || ((x) == '&') || ((x) == '=') || \
  |  |  ------------------
  |  |  |  Branch (117:9): [True: 0, False: 0]
  |  |  |  Branch (117:25): [True: 0, False: 0]
  |  |  |  Branch (117:41): [True: 0, False: 0]
  |  |  |  Branch (117:57): [True: 0, False: 0]
  |  |  ------------------
  |  |  118|      0|        ((x) == '+') || ((x) == '$') || ((x) == ',') || ((x) == '[') || \
  |  |  ------------------
  |  |  |  Branch (118:9): [True: 0, False: 0]
  |  |  |  Branch (118:25): [True: 0, False: 0]
  |  |  |  Branch (118:41): [True: 0, False: 0]
  |  |  |  Branch (118:57): [True: 0, False: 0]
  |  |  ------------------
  |  |  119|      0|        ((x) == ']'))
  |  |  ------------------
  |  |  |  Branch (119:9): [True: 0, False: 0]
  |  |  ------------------
  ------------------
              	    if (IS_RESERVED(*(p)) || IS_UNRESERVED(*(p)))
  ------------------
  |  |  125|      0|#define IS_UNRESERVED(x) (IS_ALPHANUM(x) || IS_MARK(x))
  |  |  ------------------
  |  |  |  |   93|      0|#define IS_ALPHANUM(x) (IS_ALPHA(x) || IS_DIGIT(x))
  |  |  |  |  ------------------
  |  |  |  |  |  |   63|      0|#define IS_ALPHA(x) (IS_LOWALPHA(x) || IS_UPALPHA(x))
  |  |  |  |  |  |  ------------------
  |  |  |  |  |  |  |  |   72|      0|#define IS_LOWALPHA(x) (((x) >= 'a') && ((x) <= 'z'))
  |  |  |  |  |  |  |  |  ------------------
  |  |  |  |  |  |  |  |  |  Branch (72:25): [True: 0, False: 0]
  |  |  |  |  |  |  |  |  |  Branch (72:41): [True: 0, False: 0]
  |  |  |  |  |  |  |  |  ------------------
  |  |  |  |  |  |  ------------------
  |  |  |  |  |  |               #define IS_ALPHA(x) (IS_LOWALPHA(x) || IS_UPALPHA(x))
  |  |  |  |  |  |  ------------------
  |  |  |  |  |  |  |  |   79|      0|#define IS_UPALPHA(x) (((x) >= 'A') && ((x) <= 'Z'))
  |  |  |  |  |  |  |  |  ------------------
  |  |  |  |  |  |  |  |  |  Branch (79:24): [True: 0, False: 0]
  |  |  |  |  |  |  |  |  |  Branch (79:40): [True: 0, False: 0]
  |  |  |  |  |  |  |  |  ------------------
  |  |  |  |  |  |  ------------------
  |  |  |  |  ------------------
  |  |  |  |               #define IS_ALPHANUM(x) (IS_ALPHA(x) || IS_DIGIT(x))
  |  |  |  |  ------------------
  |  |  |  |  |  |   87|      0|#define IS_DIGIT(x) (((x) >= '0') && ((x) <= '9'))
  |  |  |  |  |  |  ------------------
  |  |  |  |  |  |  |  Branch (87:22): [True: 0, False: 0]
  |  |  |  |  |  |  |  Branch (87:38): [True: 0, False: 0]
  |  |  |  |  |  |  ------------------
  |  |  |  |  ------------------
  |  |  ------------------
  |  |               #define IS_UNRESERVED(x) (IS_ALPHANUM(x) || IS_MARK(x))
  |  |  ------------------
  |  |  |  |   99|      0|#define IS_MARK(x) (((x) == '-') || ((x) == '_') || ((x) == '.') ||     \
  |  |  |  |  ------------------
  |  |  |  |  |  Branch (99:21): [True: 0, False: 0]
  |  |  |  |  |  Branch (99:37): [True: 0, False: 0]
  |  |  |  |  |  Branch (99:53): [True: 0, False: 0]
  |  |  |  |  ------------------
  |  |  |  |  100|      0|    ((x) == '!') || ((x) == '~') || ((x) == '*') || ((x) == '\'') ||    \
  |  |  |  |  ------------------
  |  |  |  |  |  Branch (100:5): [True: 0, False: 0]
  |  |  |  |  |  Branch (100:21): [True: 0, False: 0]
  |  |  |  |  |  Branch (100:37): [True: 0, False: 0]
  |  |  |  |  |  Branch (100:53): [True: 0, False: 0]
  |  |  |  |  ------------------
  |  |  |  |  101|      0|    ((x) == '(') || ((x) == ')'))
  |  |  |  |  ------------------
  |  |  |  |  |  Branch (101:5): [True: 0, False: 0]
  |  |  |  |  |  Branch (101:21): [True: 0, False: 0]
  |  |  |  |  ------------------
  |  |  ------------------
  ------------------
 1118|      0|		ret[len++] = *p++;
 1119|      0|	    else {
 1120|      0|		int val = *(unsigned char *)p++;
 1121|      0|		int hi = val / 0x10, lo = val % 0x10;
 1122|      0|		ret[len++] = '%';
 1123|      0|		ret[len++] = hi + (hi > 9? 'A'-10 : '0');
  ------------------
  |  Branch (1123:22): [True: 0, False: 0]
  ------------------
 1124|      0|		ret[len++] = lo + (lo > 9? 'A'-10 : '0');
  ------------------
  |  Branch (1124:22): [True: 0, False: 0]
  ------------------
 1125|      0|	    }
 1126|      0|	}
 1127|    810|    } else {
 1128|    810|	if ((uri->server != NULL) || (uri->port != PORT_EMPTY)) {
  ------------------
  |  |   37|    810|#define PORT_EMPTY           0
  ------------------
  |  Branch (1128:6): [True: 0, False: 810]
  |  Branch (1128:31): [True: 0, False: 810]
  ------------------
 1129|      0|	    if (len + 3 >= max) {
  ------------------
  |  Branch (1129:10): [True: 0, False: 0]
  ------------------
 1130|      0|                temp = xmlSaveUriRealloc(ret, &max);
 1131|      0|                if (temp == NULL) goto mem_error;
  ------------------
  |  Branch (1131:21): [True: 0, False: 0]
  ------------------
 1132|      0|                ret = temp;
 1133|      0|	    }
 1134|      0|	    ret[len++] = '/';
 1135|      0|	    ret[len++] = '/';
 1136|      0|	    if (uri->user != NULL) {
  ------------------
  |  Branch (1136:10): [True: 0, False: 0]
  ------------------
 1137|      0|		p = uri->user;
 1138|      0|		while (*p != 0) {
  ------------------
  |  Branch (1138:10): [True: 0, False: 0]
  ------------------
 1139|      0|		    if (len + 3 >= max) {
  ------------------
  |  Branch (1139:11): [True: 0, False: 0]
  ------------------
 1140|      0|                        temp = xmlSaveUriRealloc(ret, &max);
 1141|      0|                        if (temp == NULL) goto mem_error;
  ------------------
  |  Branch (1141:29): [True: 0, False: 0]
  ------------------
 1142|      0|                        ret = temp;
 1143|      0|		    }
 1144|      0|		    if ((IS_UNRESERVED(*(p))) ||
  ------------------
  |  |  125|      0|#define IS_UNRESERVED(x) (IS_ALPHANUM(x) || IS_MARK(x))
  |  |  ------------------
  |  |  |  |   93|      0|#define IS_ALPHANUM(x) (IS_ALPHA(x) || IS_DIGIT(x))
  |  |  |  |  ------------------
  |  |  |  |  |  |   63|      0|#define IS_ALPHA(x) (IS_LOWALPHA(x) || IS_UPALPHA(x))
  |  |  |  |  |  |  ------------------
  |  |  |  |  |  |  |  |   72|      0|#define IS_LOWALPHA(x) (((x) >= 'a') && ((x) <= 'z'))
  |  |  |  |  |  |  |  |  ------------------
  |  |  |  |  |  |  |  |  |  Branch (72:25): [True: 0, False: 0]
  |  |  |  |  |  |  |  |  |  Branch (72:41): [True: 0, False: 0]
  |  |  |  |  |  |  |  |  ------------------
  |  |  |  |  |  |  ------------------
  |  |  |  |  |  |               #define IS_ALPHA(x) (IS_LOWALPHA(x) || IS_UPALPHA(x))
  |  |  |  |  |  |  ------------------
  |  |  |  |  |  |  |  |   79|      0|#define IS_UPALPHA(x) (((x) >= 'A') && ((x) <= 'Z'))
  |  |  |  |  |  |  |  |  ------------------
  |  |  |  |  |  |  |  |  |  Branch (79:24): [True: 0, False: 0]
  |  |  |  |  |  |  |  |  |  Branch (79:40): [True: 0, False: 0]
  |  |  |  |  |  |  |  |  ------------------
  |  |  |  |  |  |  ------------------
  |  |  |  |  ------------------
  |  |  |  |               #define IS_ALPHANUM(x) (IS_ALPHA(x) || IS_DIGIT(x))
  |  |  |  |  ------------------
  |  |  |  |  |  |   87|      0|#define IS_DIGIT(x) (((x) >= '0') && ((x) <= '9'))
  |  |  |  |  |  |  ------------------
  |  |  |  |  |  |  |  Branch (87:22): [True: 0, False: 0]
  |  |  |  |  |  |  |  Branch (87:38): [True: 0, False: 0]
  |  |  |  |  |  |  ------------------
  |  |  |  |  ------------------
  |  |  ------------------
  |  |               #define IS_UNRESERVED(x) (IS_ALPHANUM(x) || IS_MARK(x))
  |  |  ------------------
  |  |  |  |   99|      0|#define IS_MARK(x) (((x) == '-') || ((x) == '_') || ((x) == '.') ||     \
  |  |  |  |  ------------------
  |  |  |  |  |  Branch (99:21): [True: 0, False: 0]
  |  |  |  |  |  Branch (99:37): [True: 0, False: 0]
  |  |  |  |  |  Branch (99:53): [True: 0, False: 0]
  |  |  |  |  ------------------
  |  |  |  |  100|      0|    ((x) == '!') || ((x) == '~') || ((x) == '*') || ((x) == '\'') ||    \
  |  |  |  |  ------------------
  |  |  |  |  |  Branch (100:5): [True: 0, False: 0]
  |  |  |  |  |  Branch (100:21): [True: 0, False: 0]
  |  |  |  |  |  Branch (100:37): [True: 0, False: 0]
  |  |  |  |  |  Branch (100:53): [True: 0, False: 0]
  |  |  |  |  ------------------
  |  |  |  |  101|      0|    ((x) == '(') || ((x) == ')'))
  |  |  |  |  ------------------
  |  |  |  |  |  Branch (101:5): [True: 0, False: 0]
  |  |  |  |  |  Branch (101:21): [True: 0, False: 0]
  |  |  |  |  ------------------
  |  |  ------------------
  ------------------
 1145|      0|			((*(p) == ';')) || ((*(p) == ':')) ||
  ------------------
  |  Branch (1145:4): [True: 0, False: 0]
  |  Branch (1145:23): [True: 0, False: 0]
  ------------------
 1146|      0|			((*(p) == '&')) || ((*(p) == '=')) ||
  ------------------
  |  Branch (1146:4): [True: 0, False: 0]
  |  Branch (1146:23): [True: 0, False: 0]
  ------------------
 1147|      0|			((*(p) == '+')) || ((*(p) == '$')) ||
  ------------------
  |  Branch (1147:4): [True: 0, False: 0]
  |  Branch (1147:23): [True: 0, False: 0]
  ------------------
 1148|      0|			((*(p) == ',')))
  ------------------
  |  Branch (1148:4): [True: 0, False: 0]
  ------------------
 1149|      0|			ret[len++] = *p++;
 1150|      0|		    else {
 1151|      0|			int val = *(unsigned char *)p++;
 1152|      0|			int hi = val / 0x10, lo = val % 0x10;
 1153|      0|			ret[len++] = '%';
 1154|      0|			ret[len++] = hi + (hi > 9? 'A'-10 : '0');
  ------------------
  |  Branch (1154:23): [True: 0, False: 0]
  ------------------
 1155|      0|			ret[len++] = lo + (lo > 9? 'A'-10 : '0');
  ------------------
  |  Branch (1155:23): [True: 0, False: 0]
  ------------------
 1156|      0|		    }
 1157|      0|		}
 1158|      0|		if (len + 3 >= max) {
  ------------------
  |  Branch (1158:7): [True: 0, False: 0]
  ------------------
 1159|      0|                    temp = xmlSaveUriRealloc(ret, &max);
 1160|      0|                    if (temp == NULL) goto mem_error;
  ------------------
  |  Branch (1160:25): [True: 0, False: 0]
  ------------------
 1161|      0|                    ret = temp;
 1162|      0|		}
 1163|      0|		ret[len++] = '@';
 1164|      0|	    }
 1165|      0|	    if (uri->server != NULL) {
  ------------------
  |  Branch (1165:10): [True: 0, False: 0]
  ------------------
 1166|      0|		p = uri->server;
 1167|      0|		while (*p != 0) {
  ------------------
  |  Branch (1167:10): [True: 0, False: 0]
  ------------------
 1168|      0|		    if (len >= max) {
  ------------------
  |  Branch (1168:11): [True: 0, False: 0]
  ------------------
 1169|      0|			temp = xmlSaveUriRealloc(ret, &max);
 1170|      0|			if (temp == NULL) goto mem_error;
  ------------------
  |  Branch (1170:8): [True: 0, False: 0]
  ------------------
 1171|      0|			ret = temp;
 1172|      0|		    }
 1173|       |                    /* TODO: escaping? */
 1174|      0|		    ret[len++] = (xmlChar) *p++;
 1175|      0|		}
 1176|      0|	    }
 1177|      0|            if (uri->port > 0) {
  ------------------
  |  Branch (1177:17): [True: 0, False: 0]
  ------------------
 1178|      0|                if (len + 10 >= max) {
  ------------------
  |  Branch (1178:21): [True: 0, False: 0]
  ------------------
 1179|      0|                    temp = xmlSaveUriRealloc(ret, &max);
 1180|      0|                    if (temp == NULL) goto mem_error;
  ------------------
  |  Branch (1180:25): [True: 0, False: 0]
  ------------------
 1181|      0|                    ret = temp;
 1182|      0|                }
 1183|      0|                len += snprintf((char *) &ret[len], max - len, ":%d", uri->port);
 1184|      0|            }
 1185|    810|	} else if (uri->authority != NULL) {
  ------------------
  |  Branch (1185:13): [True: 0, False: 810]
  ------------------
 1186|      0|	    if (len + 3 >= max) {
  ------------------
  |  Branch (1186:10): [True: 0, False: 0]
  ------------------
 1187|      0|                temp = xmlSaveUriRealloc(ret, &max);
 1188|      0|                if (temp == NULL) goto mem_error;
  ------------------
  |  Branch (1188:21): [True: 0, False: 0]
  ------------------
 1189|      0|                ret = temp;
 1190|      0|	    }
 1191|      0|	    ret[len++] = '/';
 1192|      0|	    ret[len++] = '/';
 1193|      0|	    p = uri->authority;
 1194|      0|	    while (*p != 0) {
  ------------------
  |  Branch (1194:13): [True: 0, False: 0]
  ------------------
 1195|      0|		if (len + 3 >= max) {
  ------------------
  |  Branch (1195:7): [True: 0, False: 0]
  ------------------
 1196|      0|                    temp = xmlSaveUriRealloc(ret, &max);
 1197|      0|                    if (temp == NULL) goto mem_error;
  ------------------
  |  Branch (1197:25): [True: 0, False: 0]
  ------------------
 1198|      0|                    ret = temp;
 1199|      0|		}
 1200|      0|		if ((IS_UNRESERVED(*(p))) ||
  ------------------
  |  |  125|      0|#define IS_UNRESERVED(x) (IS_ALPHANUM(x) || IS_MARK(x))
  |  |  ------------------
  |  |  |  |   93|      0|#define IS_ALPHANUM(x) (IS_ALPHA(x) || IS_DIGIT(x))
  |  |  |  |  ------------------
  |  |  |  |  |  |   63|      0|#define IS_ALPHA(x) (IS_LOWALPHA(x) || IS_UPALPHA(x))
  |  |  |  |  |  |  ------------------
  |  |  |  |  |  |  |  |   72|      0|#define IS_LOWALPHA(x) (((x) >= 'a') && ((x) <= 'z'))
  |  |  |  |  |  |  |  |  ------------------
  |  |  |  |  |  |  |  |  |  Branch (72:25): [True: 0, False: 0]
  |  |  |  |  |  |  |  |  |  Branch (72:41): [True: 0, False: 0]
  |  |  |  |  |  |  |  |  ------------------
  |  |  |  |  |  |  ------------------
  |  |  |  |  |  |               #define IS_ALPHA(x) (IS_LOWALPHA(x) || IS_UPALPHA(x))
  |  |  |  |  |  |  ------------------
  |  |  |  |  |  |  |  |   79|      0|#define IS_UPALPHA(x) (((x) >= 'A') && ((x) <= 'Z'))
  |  |  |  |  |  |  |  |  ------------------
  |  |  |  |  |  |  |  |  |  Branch (79:24): [True: 0, False: 0]
  |  |  |  |  |  |  |  |  |  Branch (79:40): [True: 0, False: 0]
  |  |  |  |  |  |  |  |  ------------------
  |  |  |  |  |  |  ------------------
  |  |  |  |  ------------------
  |  |  |  |               #define IS_ALPHANUM(x) (IS_ALPHA(x) || IS_DIGIT(x))
  |  |  |  |  ------------------
  |  |  |  |  |  |   87|      0|#define IS_DIGIT(x) (((x) >= '0') && ((x) <= '9'))
  |  |  |  |  |  |  ------------------
  |  |  |  |  |  |  |  Branch (87:22): [True: 0, False: 0]
  |  |  |  |  |  |  |  Branch (87:38): [True: 0, False: 0]
  |  |  |  |  |  |  ------------------
  |  |  |  |  ------------------
  |  |  ------------------
  |  |               #define IS_UNRESERVED(x) (IS_ALPHANUM(x) || IS_MARK(x))
  |  |  ------------------
  |  |  |  |   99|      0|#define IS_MARK(x) (((x) == '-') || ((x) == '_') || ((x) == '.') ||     \
  |  |  |  |  ------------------
  |  |  |  |  |  Branch (99:21): [True: 0, False: 0]
  |  |  |  |  |  Branch (99:37): [True: 0, False: 0]
  |  |  |  |  |  Branch (99:53): [True: 0, False: 0]
  |  |  |  |  ------------------
  |  |  |  |  100|      0|    ((x) == '!') || ((x) == '~') || ((x) == '*') || ((x) == '\'') ||    \
  |  |  |  |  ------------------
  |  |  |  |  |  Branch (100:5): [True: 0, False: 0]
  |  |  |  |  |  Branch (100:21): [True: 0, False: 0]
  |  |  |  |  |  Branch (100:37): [True: 0, False: 0]
  |  |  |  |  |  Branch (100:53): [True: 0, False: 0]
  |  |  |  |  ------------------
  |  |  |  |  101|      0|    ((x) == '(') || ((x) == ')'))
  |  |  |  |  ------------------
  |  |  |  |  |  Branch (101:5): [True: 0, False: 0]
  |  |  |  |  |  Branch (101:21): [True: 0, False: 0]
  |  |  |  |  ------------------
  |  |  ------------------
  ------------------
 1201|      0|                    ((*(p) == '$')) || ((*(p) == ',')) || ((*(p) == ';')) ||
  ------------------
  |  Branch (1201:21): [True: 0, False: 0]
  |  Branch (1201:40): [True: 0, False: 0]
  |  Branch (1201:59): [True: 0, False: 0]
  ------------------
 1202|      0|                    ((*(p) == ':')) || ((*(p) == '@')) || ((*(p) == '&')) ||
  ------------------
  |  Branch (1202:21): [True: 0, False: 0]
  |  Branch (1202:40): [True: 0, False: 0]
  |  Branch (1202:59): [True: 0, False: 0]
  ------------------
 1203|      0|                    ((*(p) == '=')) || ((*(p) == '+')))
  ------------------
  |  Branch (1203:21): [True: 0, False: 0]
  |  Branch (1203:40): [True: 0, False: 0]
  ------------------
 1204|      0|		    ret[len++] = *p++;
 1205|      0|		else {
 1206|      0|		    int val = *(unsigned char *)p++;
 1207|      0|		    int hi = val / 0x10, lo = val % 0x10;
 1208|      0|		    ret[len++] = '%';
 1209|      0|		    ret[len++] = hi + (hi > 9? 'A'-10 : '0');
  ------------------
  |  Branch (1209:26): [True: 0, False: 0]
  ------------------
 1210|      0|		    ret[len++] = lo + (lo > 9? 'A'-10 : '0');
  ------------------
  |  Branch (1210:26): [True: 0, False: 0]
  ------------------
 1211|      0|		}
 1212|      0|	    }
 1213|    810|	} else if (uri->scheme != NULL) {
  ------------------
  |  Branch (1213:13): [True: 0, False: 810]
  ------------------
 1214|      0|	    if (len + 3 >= max) {
  ------------------
  |  Branch (1214:10): [True: 0, False: 0]
  ------------------
 1215|      0|                temp = xmlSaveUriRealloc(ret, &max);
 1216|      0|                if (temp == NULL) goto mem_error;
  ------------------
  |  Branch (1216:21): [True: 0, False: 0]
  ------------------
 1217|      0|                ret = temp;
 1218|      0|	    }
 1219|      0|	}
 1220|    810|	if (uri->path != NULL) {
  ------------------
  |  Branch (1220:6): [True: 798, False: 12]
  ------------------
 1221|    798|	    p = uri->path;
 1222|       |	    /*
 1223|       |	     * the colon in file:///d: should not be escaped or
 1224|       |	     * Windows accesses fail later.
 1225|       |	     */
 1226|    798|	    if ((uri->scheme != NULL) &&
  ------------------
  |  Branch (1226:10): [True: 0, False: 798]
  ------------------
 1227|    798|		(p[0] == '/') &&
  ------------------
  |  Branch (1227:3): [True: 0, False: 0]
  ------------------
 1228|    798|		(((p[1] >= 'a') && (p[1] <= 'z')) ||
  ------------------
  |  Branch (1228:5): [True: 0, False: 0]
  |  Branch (1228:22): [True: 0, False: 0]
  ------------------
 1229|      0|		 ((p[1] >= 'A') && (p[1] <= 'Z'))) &&
  ------------------
  |  Branch (1229:5): [True: 0, False: 0]
  |  Branch (1229:22): [True: 0, False: 0]
  ------------------
 1230|    798|		(p[2] == ':') &&
  ------------------
  |  Branch (1230:3): [True: 0, False: 0]
  ------------------
 1231|    798|	        (xmlStrEqual(BAD_CAST uri->scheme, BAD_CAST "file"))) {
  ------------------
  |  |   35|      0|#define BAD_CAST (xmlChar *)
  ------------------
              	        (xmlStrEqual(BAD_CAST uri->scheme, BAD_CAST "file"))) {
  ------------------
  |  |   35|      0|#define BAD_CAST (xmlChar *)
  ------------------
  |  Branch (1231:10): [True: 0, False: 0]
  ------------------
 1232|      0|		if (len + 3 >= max) {
  ------------------
  |  Branch (1232:7): [True: 0, False: 0]
  ------------------
 1233|      0|                    temp = xmlSaveUriRealloc(ret, &max);
 1234|      0|                    if (temp == NULL) goto mem_error;
  ------------------
  |  Branch (1234:25): [True: 0, False: 0]
  ------------------
 1235|      0|                    ret = temp;
 1236|      0|		}
 1237|      0|		ret[len++] = *p++;
 1238|      0|		ret[len++] = *p++;
 1239|      0|		ret[len++] = *p++;
 1240|      0|	    }
 1241|  11.9k|	    while (*p != 0) {
  ------------------
  |  Branch (1241:13): [True: 11.1k, False: 798]
  ------------------
 1242|  11.1k|		if (len + 3 >= max) {
  ------------------
  |  Branch (1242:7): [True: 12, False: 11.1k]
  ------------------
 1243|     12|                    temp = xmlSaveUriRealloc(ret, &max);
 1244|     12|                    if (temp == NULL) goto mem_error;
  ------------------
  |  Branch (1244:25): [True: 0, False: 12]
  ------------------
 1245|     12|                    ret = temp;
 1246|     12|		}
 1247|  11.1k|		if ((IS_UNRESERVED(*(p))) || ((*(p) == '/')) ||
  ------------------
  |  |  125|  11.1k|#define IS_UNRESERVED(x) (IS_ALPHANUM(x) || IS_MARK(x))
  |  |  ------------------
  |  |  |  |   93|  22.2k|#define IS_ALPHANUM(x) (IS_ALPHA(x) || IS_DIGIT(x))
  |  |  |  |  ------------------
  |  |  |  |  |  |   63|  22.2k|#define IS_ALPHA(x) (IS_LOWALPHA(x) || IS_UPALPHA(x))
  |  |  |  |  |  |  ------------------
  |  |  |  |  |  |  |  |   72|  22.2k|#define IS_LOWALPHA(x) (((x) >= 'a') && ((x) <= 'z'))
  |  |  |  |  |  |  |  |  ------------------
  |  |  |  |  |  |  |  |  |  Branch (72:25): [True: 8.18k, False: 2.95k]
  |  |  |  |  |  |  |  |  |  Branch (72:41): [True: 8.18k, False: 0]
  |  |  |  |  |  |  |  |  ------------------
  |  |  |  |  |  |  ------------------
  |  |  |  |  |  |               #define IS_ALPHA(x) (IS_LOWALPHA(x) || IS_UPALPHA(x))
  |  |  |  |  |  |  ------------------
  |  |  |  |  |  |  |  |   79|  2.95k|#define IS_UPALPHA(x) (((x) >= 'A') && ((x) <= 'Z'))
  |  |  |  |  |  |  |  |  ------------------
  |  |  |  |  |  |  |  |  |  Branch (79:24): [True: 110, False: 2.84k]
  |  |  |  |  |  |  |  |  |  Branch (79:40): [True: 99, False: 11]
  |  |  |  |  |  |  |  |  ------------------
  |  |  |  |  |  |  ------------------
  |  |  |  |  ------------------
  |  |  |  |               #define IS_ALPHANUM(x) (IS_ALPHA(x) || IS_DIGIT(x))
  |  |  |  |  ------------------
  |  |  |  |  |  |   87|  2.85k|#define IS_DIGIT(x) (((x) >= '0') && ((x) <= '9'))
  |  |  |  |  |  |  ------------------
  |  |  |  |  |  |  |  Branch (87:22): [True: 742, False: 2.11k]
  |  |  |  |  |  |  |  Branch (87:38): [True: 659, False: 83]
  |  |  |  |  |  |  ------------------
  |  |  |  |  ------------------
  |  |  ------------------
  |  |               #define IS_UNRESERVED(x) (IS_ALPHANUM(x) || IS_MARK(x))
  |  |  ------------------
  |  |  |  |   99|  2.19k|#define IS_MARK(x) (((x) == '-') || ((x) == '_') || ((x) == '.') ||     \
  |  |  |  |  ------------------
  |  |  |  |  |  Branch (99:21): [True: 291, False: 1.90k]
  |  |  |  |  |  Branch (99:37): [True: 8, False: 1.89k]
  |  |  |  |  |  Branch (99:53): [True: 1.18k, False: 712]
  |  |  |  |  ------------------
  |  |  |  |  100|  2.19k|    ((x) == '!') || ((x) == '~') || ((x) == '*') || ((x) == '\'') ||    \
  |  |  |  |  ------------------
  |  |  |  |  |  Branch (100:5): [True: 2, False: 710]
  |  |  |  |  |  Branch (100:21): [True: 0, False: 710]
  |  |  |  |  |  Branch (100:37): [True: 0, False: 710]
  |  |  |  |  |  Branch (100:53): [True: 4, False: 706]
  |  |  |  |  ------------------
  |  |  |  |  101|  2.19k|    ((x) == '(') || ((x) == ')'))
  |  |  |  |  ------------------
  |  |  |  |  |  Branch (101:5): [True: 4, False: 702]
  |  |  |  |  |  Branch (101:21): [True: 5, False: 697]
  |  |  |  |  ------------------
  |  |  ------------------
  ------------------
  |  Branch (1247:32): [True: 410, False: 287]
  ------------------
 1248|  11.1k|                    ((*(p) == ';')) || ((*(p) == '@')) || ((*(p) == '&')) ||
  ------------------
  |  Branch (1248:21): [True: 0, False: 287]
  |  Branch (1248:40): [True: 0, False: 287]
  |  Branch (1248:59): [True: 0, False: 287]
  ------------------
 1249|  11.1k|	            ((*(p) == '=')) || ((*(p) == '+')) || ((*(p) == '$')) ||
  ------------------
  |  Branch (1249:14): [True: 15, False: 272]
  |  Branch (1249:33): [True: 0, False: 272]
  |  Branch (1249:52): [True: 0, False: 272]
  ------------------
 1250|  11.1k|	            ((*(p) == ',')))
  ------------------
  |  Branch (1250:14): [True: 0, False: 272]
  ------------------
 1251|  10.8k|		    ret[len++] = *p++;
 1252|    272|		else {
 1253|    272|		    int val = *(unsigned char *)p++;
 1254|    272|		    int hi = val / 0x10, lo = val % 0x10;
 1255|    272|		    ret[len++] = '%';
 1256|    272|		    ret[len++] = hi + (hi > 9? 'A'-10 : '0');
  ------------------
  |  Branch (1256:26): [True: 48, False: 224]
  ------------------
 1257|    272|		    ret[len++] = lo + (lo > 9? 'A'-10 : '0');
  ------------------
  |  Branch (1257:26): [True: 128, False: 144]
  ------------------
 1258|    272|		}
 1259|  11.1k|	    }
 1260|    798|	}
 1261|    810|	if (uri->query_raw != NULL) {
  ------------------
  |  Branch (1261:6): [True: 0, False: 810]
  ------------------
 1262|      0|	    if (len + 1 >= max) {
  ------------------
  |  Branch (1262:10): [True: 0, False: 0]
  ------------------
 1263|      0|                temp = xmlSaveUriRealloc(ret, &max);
 1264|      0|                if (temp == NULL) goto mem_error;
  ------------------
  |  Branch (1264:21): [True: 0, False: 0]
  ------------------
 1265|      0|                ret = temp;
 1266|      0|	    }
 1267|      0|	    ret[len++] = '?';
 1268|      0|	    p = uri->query_raw;
 1269|      0|	    while (*p != 0) {
  ------------------
  |  Branch (1269:13): [True: 0, False: 0]
  ------------------
 1270|      0|		if (len + 1 >= max) {
  ------------------
  |  Branch (1270:7): [True: 0, False: 0]
  ------------------
 1271|      0|                    temp = xmlSaveUriRealloc(ret, &max);
 1272|      0|                    if (temp == NULL) goto mem_error;
  ------------------
  |  Branch (1272:25): [True: 0, False: 0]
  ------------------
 1273|      0|                    ret = temp;
 1274|      0|		}
 1275|      0|		ret[len++] = *p++;
 1276|      0|	    }
 1277|    810|	} else if (uri->query != NULL) {
  ------------------
  |  Branch (1277:13): [True: 0, False: 810]
  ------------------
 1278|      0|	    if (len + 3 >= max) {
  ------------------
  |  Branch (1278:10): [True: 0, False: 0]
  ------------------
 1279|      0|                temp = xmlSaveUriRealloc(ret, &max);
 1280|      0|                if (temp == NULL) goto mem_error;
  ------------------
  |  Branch (1280:21): [True: 0, False: 0]
  ------------------
 1281|      0|                ret = temp;
 1282|      0|	    }
 1283|      0|	    ret[len++] = '?';
 1284|      0|	    p = uri->query;
 1285|      0|	    while (*p != 0) {
  ------------------
  |  Branch (1285:13): [True: 0, False: 0]
  ------------------
 1286|      0|		if (len + 3 >= max) {
  ------------------
  |  Branch (1286:7): [True: 0, False: 0]
  ------------------
 1287|      0|                    temp = xmlSaveUriRealloc(ret, &max);
 1288|      0|                    if (temp == NULL) goto mem_error;
  ------------------
  |  Branch (1288:25): [True: 0, False: 0]
  ------------------
 1289|      0|                    ret = temp;
 1290|      0|		}
 1291|      0|		if ((IS_UNRESERVED(*(p))) || (IS_RESERVED(*(p))))
  ------------------
  |  |  125|      0|#define IS_UNRESERVED(x) (IS_ALPHANUM(x) || IS_MARK(x))
  |  |  ------------------
  |  |  |  |   93|      0|#define IS_ALPHANUM(x) (IS_ALPHA(x) || IS_DIGIT(x))
  |  |  |  |  ------------------
  |  |  |  |  |  |   63|      0|#define IS_ALPHA(x) (IS_LOWALPHA(x) || IS_UPALPHA(x))
  |  |  |  |  |  |  ------------------
  |  |  |  |  |  |  |  |   72|      0|#define IS_LOWALPHA(x) (((x) >= 'a') && ((x) <= 'z'))
  |  |  |  |  |  |  |  |  ------------------
  |  |  |  |  |  |  |  |  |  Branch (72:25): [True: 0, False: 0]
  |  |  |  |  |  |  |  |  |  Branch (72:41): [True: 0, False: 0]
  |  |  |  |  |  |  |  |  ------------------
  |  |  |  |  |  |  ------------------
  |  |  |  |  |  |               #define IS_ALPHA(x) (IS_LOWALPHA(x) || IS_UPALPHA(x))
  |  |  |  |  |  |  ------------------
  |  |  |  |  |  |  |  |   79|      0|#define IS_UPALPHA(x) (((x) >= 'A') && ((x) <= 'Z'))
  |  |  |  |  |  |  |  |  ------------------
  |  |  |  |  |  |  |  |  |  Branch (79:24): [True: 0, False: 0]
  |  |  |  |  |  |  |  |  |  Branch (79:40): [True: 0, False: 0]
  |  |  |  |  |  |  |  |  ------------------
  |  |  |  |  |  |  ------------------
  |  |  |  |  ------------------
  |  |  |  |               #define IS_ALPHANUM(x) (IS_ALPHA(x) || IS_DIGIT(x))
  |  |  |  |  ------------------
  |  |  |  |  |  |   87|      0|#define IS_DIGIT(x) (((x) >= '0') && ((x) <= '9'))
  |  |  |  |  |  |  ------------------
  |  |  |  |  |  |  |  Branch (87:22): [True: 0, False: 0]
  |  |  |  |  |  |  |  Branch (87:38): [True: 0, False: 0]
  |  |  |  |  |  |  ------------------
  |  |  |  |  ------------------
  |  |  ------------------
  |  |               #define IS_UNRESERVED(x) (IS_ALPHANUM(x) || IS_MARK(x))
  |  |  ------------------
  |  |  |  |   99|      0|#define IS_MARK(x) (((x) == '-') || ((x) == '_') || ((x) == '.') ||     \
  |  |  |  |  ------------------
  |  |  |  |  |  Branch (99:21): [True: 0, False: 0]
  |  |  |  |  |  Branch (99:37): [True: 0, False: 0]
  |  |  |  |  |  Branch (99:53): [True: 0, False: 0]
  |  |  |  |  ------------------
  |  |  |  |  100|      0|    ((x) == '!') || ((x) == '~') || ((x) == '*') || ((x) == '\'') ||    \
  |  |  |  |  ------------------
  |  |  |  |  |  Branch (100:5): [True: 0, False: 0]
  |  |  |  |  |  Branch (100:21): [True: 0, False: 0]
  |  |  |  |  |  Branch (100:37): [True: 0, False: 0]
  |  |  |  |  |  Branch (100:53): [True: 0, False: 0]
  |  |  |  |  ------------------
  |  |  |  |  101|      0|    ((x) == '(') || ((x) == ')'))
  |  |  |  |  ------------------
  |  |  |  |  |  Branch (101:5): [True: 0, False: 0]
  |  |  |  |  |  Branch (101:21): [True: 0, False: 0]
  |  |  |  |  ------------------
  |  |  ------------------
  ------------------
              		if ((IS_UNRESERVED(*(p))) || (IS_RESERVED(*(p))))
  ------------------
  |  |  116|      0|#define IS_RESERVED(x) (((x) == ';') || ((x) == '/') || ((x) == '?') || \
  |  |  ------------------
  |  |  |  Branch (116:25): [True: 0, False: 0]
  |  |  |  Branch (116:41): [True: 0, False: 0]
  |  |  |  Branch (116:57): [True: 0, False: 0]
  |  |  ------------------
  |  |  117|      0|        ((x) == ':') || ((x) == '@') || ((x) == '&') || ((x) == '=') || \
  |  |  ------------------
  |  |  |  Branch (117:9): [True: 0, False: 0]
  |  |  |  Branch (117:25): [True: 0, False: 0]
  |  |  |  Branch (117:41): [True: 0, False: 0]
  |  |  |  Branch (117:57): [True: 0, False: 0]
  |  |  ------------------
  |  |  118|      0|        ((x) == '+') || ((x) == '$') || ((x) == ',') || ((x) == '[') || \
  |  |  ------------------
  |  |  |  Branch (118:9): [True: 0, False: 0]
  |  |  |  Branch (118:25): [True: 0, False: 0]
  |  |  |  Branch (118:41): [True: 0, False: 0]
  |  |  |  Branch (118:57): [True: 0, False: 0]
  |  |  ------------------
  |  |  119|      0|        ((x) == ']'))
  |  |  ------------------
  |  |  |  Branch (119:9): [True: 0, False: 0]
  |  |  ------------------
  ------------------
 1292|      0|		    ret[len++] = *p++;
 1293|      0|		else {
 1294|      0|		    int val = *(unsigned char *)p++;
 1295|      0|		    int hi = val / 0x10, lo = val % 0x10;
 1296|      0|		    ret[len++] = '%';
 1297|      0|		    ret[len++] = hi + (hi > 9? 'A'-10 : '0');
  ------------------
  |  Branch (1297:26): [True: 0, False: 0]
  ------------------
 1298|      0|		    ret[len++] = lo + (lo > 9? 'A'-10 : '0');
  ------------------
  |  Branch (1298:26): [True: 0, False: 0]
  ------------------
 1299|      0|		}
 1300|      0|	    }
 1301|      0|	}
 1302|    810|    }
 1303|    810|    if (uri->fragment != NULL) {
  ------------------
  |  Branch (1303:9): [True: 38, False: 772]
  ------------------
 1304|     38|	if (len + 3 >= max) {
  ------------------
  |  Branch (1304:6): [True: 0, False: 38]
  ------------------
 1305|      0|            temp = xmlSaveUriRealloc(ret, &max);
 1306|      0|            if (temp == NULL) goto mem_error;
  ------------------
  |  Branch (1306:17): [True: 0, False: 0]
  ------------------
 1307|      0|            ret = temp;
 1308|      0|	}
 1309|     38|	ret[len++] = '#';
 1310|     38|	p = uri->fragment;
 1311|    516|	while (*p != 0) {
  ------------------
  |  Branch (1311:9): [True: 478, False: 38]
  ------------------
 1312|    478|	    if (len + 3 >= max) {
  ------------------
  |  Branch (1312:10): [True: 0, False: 478]
  ------------------
 1313|      0|                temp = xmlSaveUriRealloc(ret, &max);
 1314|      0|                if (temp == NULL) goto mem_error;
  ------------------
  |  Branch (1314:21): [True: 0, False: 0]
  ------------------
 1315|      0|                ret = temp;
 1316|      0|	    }
 1317|    478|	    if ((IS_UNRESERVED(*(p))) || (IS_RESERVED(*(p))))
  ------------------
  |  |  125|    478|#define IS_UNRESERVED(x) (IS_ALPHANUM(x) || IS_MARK(x))
  |  |  ------------------
  |  |  |  |   93|    956|#define IS_ALPHANUM(x) (IS_ALPHA(x) || IS_DIGIT(x))
  |  |  |  |  ------------------
  |  |  |  |  |  |   63|    956|#define IS_ALPHA(x) (IS_LOWALPHA(x) || IS_UPALPHA(x))
  |  |  |  |  |  |  ------------------
  |  |  |  |  |  |  |  |   72|    956|#define IS_LOWALPHA(x) (((x) >= 'a') && ((x) <= 'z'))
  |  |  |  |  |  |  |  |  ------------------
  |  |  |  |  |  |  |  |  |  Branch (72:25): [True: 310, False: 168]
  |  |  |  |  |  |  |  |  |  Branch (72:41): [True: 310, False: 0]
  |  |  |  |  |  |  |  |  ------------------
  |  |  |  |  |  |  ------------------
  |  |  |  |  |  |               #define IS_ALPHA(x) (IS_LOWALPHA(x) || IS_UPALPHA(x))
  |  |  |  |  |  |  ------------------
  |  |  |  |  |  |  |  |   79|    168|#define IS_UPALPHA(x) (((x) >= 'A') && ((x) <= 'Z'))
  |  |  |  |  |  |  |  |  ------------------
  |  |  |  |  |  |  |  |  |  Branch (79:24): [True: 8, False: 160]
  |  |  |  |  |  |  |  |  |  Branch (79:40): [True: 0, False: 8]
  |  |  |  |  |  |  |  |  ------------------
  |  |  |  |  |  |  ------------------
  |  |  |  |  ------------------
  |  |  |  |               #define IS_ALPHANUM(x) (IS_ALPHA(x) || IS_DIGIT(x))
  |  |  |  |  ------------------
  |  |  |  |  |  |   87|    168|#define IS_DIGIT(x) (((x) >= '0') && ((x) <= '9'))
  |  |  |  |  |  |  ------------------
  |  |  |  |  |  |  |  Branch (87:22): [True: 32, False: 136]
  |  |  |  |  |  |  |  Branch (87:38): [True: 24, False: 8]
  |  |  |  |  |  |  ------------------
  |  |  |  |  ------------------
  |  |  ------------------
  |  |               #define IS_UNRESERVED(x) (IS_ALPHANUM(x) || IS_MARK(x))
  |  |  ------------------
  |  |  |  |   99|    144|#define IS_MARK(x) (((x) == '-') || ((x) == '_') || ((x) == '.') ||     \
  |  |  |  |  ------------------
  |  |  |  |  |  Branch (99:21): [True: 0, False: 144]
  |  |  |  |  |  Branch (99:37): [True: 0, False: 144]
  |  |  |  |  |  Branch (99:53): [True: 0, False: 144]
  |  |  |  |  ------------------
  |  |  |  |  100|    144|    ((x) == '!') || ((x) == '~') || ((x) == '*') || ((x) == '\'') ||    \
  |  |  |  |  ------------------
  |  |  |  |  |  Branch (100:5): [True: 0, False: 144]
  |  |  |  |  |  Branch (100:21): [True: 0, False: 144]
  |  |  |  |  |  Branch (100:37): [True: 0, False: 144]
  |  |  |  |  |  Branch (100:53): [True: 0, False: 144]
  |  |  |  |  ------------------
  |  |  |  |  101|    144|    ((x) == '(') || ((x) == ')'))
  |  |  |  |  ------------------
  |  |  |  |  |  Branch (101:5): [True: 36, False: 108]
  |  |  |  |  |  Branch (101:21): [True: 52, False: 56]
  |  |  |  |  ------------------
  |  |  ------------------
  ------------------
              	    if ((IS_UNRESERVED(*(p))) || (IS_RESERVED(*(p))))
  ------------------
  |  |  116|     56|#define IS_RESERVED(x) (((x) == ';') || ((x) == '/') || ((x) == '?') || \
  |  |  ------------------
  |  |  |  Branch (116:25): [True: 0, False: 56]
  |  |  |  Branch (116:41): [True: 48, False: 8]
  |  |  |  Branch (116:57): [True: 0, False: 8]
  |  |  ------------------
  |  |  117|     56|        ((x) == ':') || ((x) == '@') || ((x) == '&') || ((x) == '=') || \
  |  |  ------------------
  |  |  |  Branch (117:9): [True: 0, False: 8]
  |  |  |  Branch (117:25): [True: 0, False: 8]
  |  |  |  Branch (117:41): [True: 0, False: 8]
  |  |  |  Branch (117:57): [True: 0, False: 8]
  |  |  ------------------
  |  |  118|     56|        ((x) == '+') || ((x) == '$') || ((x) == ',') || ((x) == '[') || \
  |  |  ------------------
  |  |  |  Branch (118:9): [True: 0, False: 8]
  |  |  |  Branch (118:25): [True: 0, False: 8]
  |  |  |  Branch (118:41): [True: 0, False: 8]
  |  |  |  Branch (118:57): [True: 4, False: 4]
  |  |  ------------------
  |  |  119|     56|        ((x) == ']'))
  |  |  ------------------
  |  |  |  Branch (119:9): [True: 4, False: 0]
  |  |  ------------------
  ------------------
 1318|    478|		ret[len++] = *p++;
 1319|      0|	    else {
 1320|      0|		int val = *(unsigned char *)p++;
 1321|      0|		int hi = val / 0x10, lo = val % 0x10;
 1322|      0|		ret[len++] = '%';
 1323|      0|		ret[len++] = hi + (hi > 9? 'A'-10 : '0');
  ------------------
  |  Branch (1323:22): [True: 0, False: 0]
  ------------------
 1324|      0|		ret[len++] = lo + (lo > 9? 'A'-10 : '0');
  ------------------
  |  Branch (1324:22): [True: 0, False: 0]
  ------------------
 1325|      0|	    }
 1326|    478|	}
 1327|     38|    }
 1328|    810|    if (len >= max) {
  ------------------
  |  Branch (1328:9): [True: 0, False: 810]
  ------------------
 1329|      0|        temp = xmlSaveUriRealloc(ret, &max);
 1330|      0|        if (temp == NULL) goto mem_error;
  ------------------
  |  Branch (1330:13): [True: 0, False: 0]
  ------------------
 1331|      0|        ret = temp;
 1332|      0|    }
 1333|    810|    ret[len] = 0;
 1334|    810|    return(ret);
 1335|       |
 1336|      0|mem_error:
 1337|      0|    xmlFree(ret);
 1338|      0|    return(NULL);
 1339|    810|}
xmlFreeURI:
 1396|  1.94k|xmlFreeURI(xmlURIPtr uri) {
 1397|  1.94k|    if (uri == NULL) return;
  ------------------
  |  Branch (1397:9): [True: 0, False: 1.94k]
  ------------------
 1398|       |
 1399|  1.94k|    if (uri->scheme != NULL) xmlFree(uri->scheme);
  ------------------
  |  Branch (1399:9): [True: 294, False: 1.65k]
  ------------------
 1400|  1.94k|    if (uri->server != NULL) xmlFree(uri->server);
  ------------------
  |  Branch (1400:9): [True: 271, False: 1.67k]
  ------------------
 1401|  1.94k|    if (uri->user != NULL) xmlFree(uri->user);
  ------------------
  |  Branch (1401:9): [True: 0, False: 1.94k]
  ------------------
 1402|  1.94k|    if (uri->path != NULL) xmlFree(uri->path);
  ------------------
  |  Branch (1402:9): [True: 1.79k, False: 148]
  ------------------
 1403|  1.94k|    if (uri->fragment != NULL) xmlFree(uri->fragment);
  ------------------
  |  Branch (1403:9): [True: 61, False: 1.88k]
  ------------------
 1404|  1.94k|    if (uri->opaque != NULL) xmlFree(uri->opaque);
  ------------------
  |  Branch (1404:9): [True: 0, False: 1.94k]
  ------------------
 1405|  1.94k|    if (uri->authority != NULL) xmlFree(uri->authority);
  ------------------
  |  Branch (1405:9): [True: 0, False: 1.94k]
  ------------------
 1406|  1.94k|    if (uri->query != NULL) xmlFree(uri->query);
  ------------------
  |  Branch (1406:9): [True: 0, False: 1.94k]
  ------------------
 1407|  1.94k|    if (uri->query_raw != NULL) xmlFree(uri->query_raw);
  ------------------
  |  Branch (1407:9): [True: 0, False: 1.94k]
  ------------------
 1408|  1.94k|    xmlFree(uri);
 1409|  1.94k|}
xmlNormalizeURIPath:
 1429|    107|xmlNormalizeURIPath(char *path) {
 1430|    107|    char *cur, *out;
 1431|       |
 1432|    107|    if (path == NULL)
  ------------------
  |  Branch (1432:9): [True: 0, False: 107]
  ------------------
 1433|      0|	return(-1);
 1434|       |
 1435|       |    /* Skip all initial "/" chars.  We want to get to the beginning of the
 1436|       |     * first non-empty segment.
 1437|       |     */
 1438|    107|    cur = path;
 1439|    107|    while (cur[0] == '/')
  ------------------
  |  Branch (1439:12): [True: 0, False: 107]
  ------------------
 1440|      0|      ++cur;
 1441|    107|    if (cur[0] == '\0')
  ------------------
  |  Branch (1441:9): [True: 0, False: 107]
  ------------------
 1442|      0|      return(0);
 1443|       |
 1444|       |    /* Keep everything we've seen so far.  */
 1445|    107|    out = cur;
 1446|       |
 1447|       |    /*
 1448|       |     * Analyze each segment in sequence for cases (c) and (d).
 1449|       |     */
 1450|    203|    while (cur[0] != '\0') {
  ------------------
  |  Branch (1450:12): [True: 203, False: 0]
  ------------------
 1451|       |	/*
 1452|       |	 * c) All occurrences of "./", where "." is a complete path segment,
 1453|       |	 *    are removed from the buffer string.
 1454|       |	 */
 1455|    203|	if ((cur[0] == '.') && (cur[1] == '/')) {
  ------------------
  |  Branch (1455:6): [True: 49, False: 154]
  |  Branch (1455:25): [True: 2, False: 47]
  ------------------
 1456|      2|	    cur += 2;
 1457|       |	    /* '//' normalization should be done at this point too */
 1458|      2|	    while (cur[0] == '/')
  ------------------
  |  Branch (1458:13): [True: 0, False: 2]
  ------------------
 1459|      0|		cur++;
 1460|      2|	    continue;
 1461|      2|	}
 1462|       |
 1463|       |	/*
 1464|       |	 * d) If the buffer string ends with "." as a complete path segment,
 1465|       |	 *    that "." is removed.
 1466|       |	 */
 1467|    201|	if ((cur[0] == '.') && (cur[1] == '\0'))
  ------------------
  |  Branch (1467:6): [True: 47, False: 154]
  |  Branch (1467:25): [True: 0, False: 47]
  ------------------
 1468|      0|	    break;
 1469|       |
 1470|       |	/* Otherwise keep the segment.  */
 1471|  1.47k|	while (cur[0] != '/') {
  ------------------
  |  Branch (1471:9): [True: 1.37k, False: 94]
  ------------------
 1472|  1.37k|            if (cur[0] == '\0')
  ------------------
  |  Branch (1472:17): [True: 107, False: 1.26k]
  ------------------
 1473|    107|              goto done_cd;
 1474|  1.26k|	    (out++)[0] = (cur++)[0];
 1475|  1.26k|	}
 1476|       |	/* normalize // */
 1477|     94|	while ((cur[0] == '/') && (cur[1] == '/'))
  ------------------
  |  Branch (1477:9): [True: 94, False: 0]
  |  Branch (1477:28): [True: 0, False: 94]
  ------------------
 1478|      0|	    cur++;
 1479|       |
 1480|     94|        (out++)[0] = (cur++)[0];
 1481|     94|    }
 1482|    107| done_cd:
 1483|    107|    out[0] = '\0';
 1484|       |
 1485|       |    /* Reset to the beginning of the first segment for the next sequence.  */
 1486|    107|    cur = path;
 1487|    107|    while (cur[0] == '/')
  ------------------
  |  Branch (1487:12): [True: 0, False: 107]
  ------------------
 1488|      0|      ++cur;
 1489|    107|    if (cur[0] == '\0')
  ------------------
  |  Branch (1489:9): [True: 0, False: 107]
  ------------------
 1490|      0|	return(0);
 1491|       |
 1492|       |    /*
 1493|       |     * Analyze each segment in sequence for cases (e) and (f).
 1494|       |     *
 1495|       |     * e) All occurrences of "<segment>/../", where <segment> is a
 1496|       |     *    complete path segment not equal to "..", are removed from the
 1497|       |     *    buffer string.  Removal of these path segments is performed
 1498|       |     *    iteratively, removing the leftmost matching pattern on each
 1499|       |     *    iteration, until no matching pattern remains.
 1500|       |     *
 1501|       |     * f) If the buffer string ends with "<segment>/..", where <segment>
 1502|       |     *    is a complete path segment not equal to "..", that
 1503|       |     *    "<segment>/.." is removed.
 1504|       |     *
 1505|       |     * To satisfy the "iterative" clause in (e), we need to collapse the
 1506|       |     * string every time we find something that needs to be removed.  Thus,
 1507|       |     * we don't need to keep two pointers into the string: we only need a
 1508|       |     * "current position" pointer.
 1509|       |     */
 1510|    201|    while (1) {
  ------------------
  |  Branch (1510:12): [Folded - Ignored]
  ------------------
 1511|    201|        char *segp, *tmp;
 1512|       |
 1513|       |        /* At the beginning of each iteration of this loop, "cur" points to
 1514|       |         * the first character of the segment we want to examine.
 1515|       |         */
 1516|       |
 1517|       |        /* Find the end of the current segment.  */
 1518|    201|        segp = cur;
 1519|  1.47k|        while ((segp[0] != '/') && (segp[0] != '\0'))
  ------------------
  |  Branch (1519:16): [True: 1.37k, False: 94]
  |  Branch (1519:36): [True: 1.26k, False: 107]
  ------------------
 1520|  1.26k|          ++segp;
 1521|       |
 1522|       |        /* If this is the last segment, we're done (we need at least two
 1523|       |         * segments to meet the criteria for the (e) and (f) cases).
 1524|       |         */
 1525|    201|        if (segp[0] == '\0')
  ------------------
  |  Branch (1525:13): [True: 107, False: 94]
  ------------------
 1526|    107|          break;
 1527|       |
 1528|       |        /* If the first segment is "..", or if the next segment _isn't_ "..",
 1529|       |         * keep this segment and try the next one.
 1530|       |         */
 1531|     94|        ++segp;
 1532|     94|        if (((cur[0] == '.') && (cur[1] == '.') && (segp == cur+3))
  ------------------
  |  Branch (1532:14): [True: 47, False: 47]
  |  Branch (1532:33): [True: 47, False: 0]
  |  Branch (1532:52): [True: 47, False: 0]
  ------------------
 1533|     94|            || ((segp[0] != '.') || (segp[1] != '.')
  ------------------
  |  Branch (1533:17): [True: 47, False: 0]
  |  Branch (1533:37): [True: 0, False: 0]
  ------------------
 1534|     94|                || ((segp[2] != '/') && (segp[2] != '\0')))) {
  ------------------
  |  Branch (1534:21): [True: 0, False: 0]
  |  Branch (1534:41): [True: 0, False: 0]
  ------------------
 1535|     94|          cur = segp;
 1536|     94|          continue;
 1537|     94|        }
 1538|       |
 1539|       |        /* If we get here, remove this segment and the next one and back up
 1540|       |         * to the previous segment (if there is one), to implement the
 1541|       |         * "iteratively" clause.  It's pretty much impossible to back up
 1542|       |         * while maintaining two pointers into the buffer, so just compact
 1543|       |         * the whole buffer now.
 1544|       |         */
 1545|       |
 1546|       |        /* If this is the end of the buffer, we're done.  */
 1547|      0|        if (segp[2] == '\0') {
  ------------------
  |  Branch (1547:13): [True: 0, False: 0]
  ------------------
 1548|      0|          cur[0] = '\0';
 1549|      0|          break;
 1550|      0|        }
 1551|       |        /* Valgrind complained, strcpy(cur, segp + 3); */
 1552|       |        /* string will overlap, do not use strcpy */
 1553|      0|        tmp = cur;
 1554|      0|        segp += 3;
 1555|      0|        while ((*tmp++ = *segp++) != 0)
  ------------------
  |  Branch (1555:16): [True: 0, False: 0]
  ------------------
 1556|      0|          ;
 1557|       |
 1558|       |        /* If there are no previous segments, then keep going from here.  */
 1559|      0|        segp = cur;
 1560|      0|        while ((segp > path) && ((--segp)[0] == '/'))
  ------------------
  |  Branch (1560:16): [True: 0, False: 0]
  |  Branch (1560:33): [True: 0, False: 0]
  ------------------
 1561|      0|          ;
 1562|      0|        if (segp == path)
  ------------------
  |  Branch (1562:13): [True: 0, False: 0]
  ------------------
 1563|      0|          continue;
 1564|       |
 1565|       |        /* "segp" is pointing to the end of a previous segment; find it's
 1566|       |         * start.  We need to back up to the previous segment and start
 1567|       |         * over with that to handle things like "foo/bar/../..".  If we
 1568|       |         * don't do this, then on the first pass we'll remove the "bar/..",
 1569|       |         * but be pointing at the second ".." so we won't realize we can also
 1570|       |         * remove the "foo/..".
 1571|       |         */
 1572|      0|        cur = segp;
 1573|      0|        while ((cur > path) && (cur[-1] != '/'))
  ------------------
  |  Branch (1573:16): [True: 0, False: 0]
  |  Branch (1573:32): [True: 0, False: 0]
  ------------------
 1574|      0|          --cur;
 1575|      0|    }
 1576|    107|    out[0] = '\0';
 1577|       |
 1578|       |    /*
 1579|       |     * g) If the resulting buffer string still begins with one or more
 1580|       |     *    complete path segments of "..", then the reference is
 1581|       |     *    considered to be in error. Implementations may handle this
 1582|       |     *    error by retaining these components in the resolved path (i.e.,
 1583|       |     *    treating them as part of the final URI), by removing them from
 1584|       |     *    the resolved path (i.e., discarding relative levels above the
 1585|       |     *    root), or by avoiding traversal of the reference.
 1586|       |     *
 1587|       |     * We discard them from the final path.
 1588|       |     */
 1589|    107|    if (path[0] == '/') {
  ------------------
  |  Branch (1589:9): [True: 0, False: 107]
  ------------------
 1590|      0|      cur = path;
 1591|      0|      while ((cur[0] == '/') && (cur[1] == '.') && (cur[2] == '.')
  ------------------
  |  Branch (1591:14): [True: 0, False: 0]
  |  Branch (1591:33): [True: 0, False: 0]
  |  Branch (1591:52): [True: 0, False: 0]
  ------------------
 1592|      0|             && ((cur[3] == '/') || (cur[3] == '\0')))
  ------------------
  |  Branch (1592:18): [True: 0, False: 0]
  |  Branch (1592:37): [True: 0, False: 0]
  ------------------
 1593|      0|	cur += 3;
 1594|       |
 1595|      0|      if (cur != path) {
  ------------------
  |  Branch (1595:11): [True: 0, False: 0]
  ------------------
 1596|      0|	out = path;
 1597|      0|	while (cur[0] != '\0')
  ------------------
  |  Branch (1597:9): [True: 0, False: 0]
  ------------------
 1598|      0|          (out++)[0] = (cur++)[0];
 1599|      0|	out[0] = 0;
 1600|      0|      }
 1601|      0|    }
 1602|       |
 1603|    107|    return(0);
 1604|    107|}
xmlURIUnescapeString:
 1629|  2.05k|xmlURIUnescapeString(const char *str, int len, char *target) {
 1630|  2.05k|    char *ret, *out;
 1631|  2.05k|    const char *in;
 1632|       |
 1633|  2.05k|    if (str == NULL)
  ------------------
  |  Branch (1633:9): [True: 0, False: 2.05k]
  ------------------
 1634|      0|	return(NULL);
 1635|  2.05k|    if (len <= 0) len = strlen(str);
  ------------------
  |  Branch (1635:9): [True: 0, False: 2.05k]
  ------------------
 1636|  2.05k|    if (len < 0) return(NULL);
  ------------------
  |  Branch (1636:9): [True: 0, False: 2.05k]
  ------------------
 1637|       |
 1638|  2.05k|    if (target == NULL) {
  ------------------
  |  Branch (1638:9): [True: 2.05k, False: 0]
  ------------------
 1639|  2.05k|	ret = (char *) xmlMallocAtomic(len + 1);
 1640|  2.05k|	if (ret == NULL) {
  ------------------
  |  Branch (1640:6): [True: 0, False: 2.05k]
  ------------------
 1641|      0|            xmlURIErrMemory("unescaping URI value\n");
 1642|      0|	    return(NULL);
 1643|      0|	}
 1644|  2.05k|    } else
 1645|      0|	ret = target;
 1646|  2.05k|    in = str;
 1647|  2.05k|    out = ret;
 1648|  27.7k|    while(len > 0) {
  ------------------
  |  Branch (1648:11): [True: 25.6k, False: 2.05k]
  ------------------
 1649|  25.6k|	if ((len > 2) && (*in == '%') && (is_hex(in[1])) && (is_hex(in[2]))) {
  ------------------
  |  Branch (1649:6): [True: 21.5k, False: 4.09k]
  |  Branch (1649:19): [True: 0, False: 21.5k]
  |  Branch (1649:35): [True: 0, False: 0]
  |  Branch (1649:54): [True: 0, False: 0]
  ------------------
 1650|      0|            int c = 0;
 1651|      0|	    in++;
 1652|      0|	    if ((*in >= '0') && (*in <= '9'))
  ------------------
  |  Branch (1652:10): [True: 0, False: 0]
  |  Branch (1652:26): [True: 0, False: 0]
  ------------------
 1653|      0|	        c = (*in - '0');
 1654|      0|	    else if ((*in >= 'a') && (*in <= 'f'))
  ------------------
  |  Branch (1654:15): [True: 0, False: 0]
  |  Branch (1654:31): [True: 0, False: 0]
  ------------------
 1655|      0|	        c = (*in - 'a') + 10;
 1656|      0|	    else if ((*in >= 'A') && (*in <= 'F'))
  ------------------
  |  Branch (1656:15): [True: 0, False: 0]
  |  Branch (1656:31): [True: 0, False: 0]
  ------------------
 1657|      0|	        c = (*in - 'A') + 10;
 1658|      0|	    in++;
 1659|      0|	    if ((*in >= '0') && (*in <= '9'))
  ------------------
  |  Branch (1659:10): [True: 0, False: 0]
  |  Branch (1659:26): [True: 0, False: 0]
  ------------------
 1660|      0|	        c = c * 16 + (*in - '0');
 1661|      0|	    else if ((*in >= 'a') && (*in <= 'f'))
  ------------------
  |  Branch (1661:15): [True: 0, False: 0]
  |  Branch (1661:31): [True: 0, False: 0]
  ------------------
 1662|      0|	        c = c * 16 + (*in - 'a') + 10;
 1663|      0|	    else if ((*in >= 'A') && (*in <= 'F'))
  ------------------
  |  Branch (1663:15): [True: 0, False: 0]
  |  Branch (1663:31): [True: 0, False: 0]
  ------------------
 1664|      0|	        c = c * 16 + (*in - 'A') + 10;
 1665|      0|	    in++;
 1666|      0|	    len -= 3;
 1667|       |            /* Explicit sign change */
 1668|      0|	    *out++ = (char) c;
 1669|  25.6k|	} else {
 1670|  25.6k|	    *out++ = *in++;
 1671|  25.6k|	    len--;
 1672|  25.6k|	}
 1673|  25.6k|    }
 1674|  2.05k|    *out = 0;
 1675|  2.05k|    return(ret);
 1676|  2.05k|}
xmlURIEscapeStr:
 1689|      9|xmlURIEscapeStr(const xmlChar *str, const xmlChar *list) {
 1690|      9|    xmlChar *ret, ch;
 1691|      9|    xmlChar *temp;
 1692|      9|    const xmlChar *in;
 1693|      9|    int len, out;
 1694|       |
 1695|      9|    if (str == NULL)
  ------------------
  |  Branch (1695:9): [True: 0, False: 9]
  ------------------
 1696|      0|	return(NULL);
 1697|      9|    if (str[0] == 0)
  ------------------
  |  Branch (1697:9): [True: 0, False: 9]
  ------------------
 1698|      0|	return(xmlStrdup(str));
 1699|      9|    len = xmlStrlen(str);
 1700|      9|    if (!(len > 0)) return(NULL);
  ------------------
  |  Branch (1700:9): [True: 0, False: 9]
  ------------------
 1701|       |
 1702|      9|    len += 20;
 1703|      9|    ret = (xmlChar *) xmlMallocAtomic(len);
 1704|      9|    if (ret == NULL) {
  ------------------
  |  Branch (1704:9): [True: 0, False: 9]
  ------------------
 1705|      0|        xmlURIErrMemory("escaping URI value\n");
 1706|      0|	return(NULL);
 1707|      0|    }
 1708|      9|    in = (const xmlChar *) str;
 1709|      9|    out = 0;
 1710|    190|    while(*in != 0) {
  ------------------
  |  Branch (1710:11): [True: 181, False: 9]
  ------------------
 1711|    181|	if (len - out <= 3) {
  ------------------
  |  Branch (1711:6): [True: 0, False: 181]
  ------------------
 1712|      0|            temp = xmlSaveUriRealloc(ret, &len);
 1713|      0|	    if (temp == NULL) {
  ------------------
  |  Branch (1713:10): [True: 0, False: 0]
  ------------------
 1714|      0|                xmlURIErrMemory("escaping URI value\n");
 1715|      0|		xmlFree(ret);
 1716|      0|		return(NULL);
 1717|      0|	    }
 1718|      0|	    ret = temp;
 1719|      0|	}
 1720|       |
 1721|    181|	ch = *in;
 1722|       |
 1723|    181|	if ((ch != '@') && (!IS_UNRESERVED(ch)) && (!xmlStrchr(list, ch))) {
  ------------------
  |  |  125|    181|#define IS_UNRESERVED(x) (IS_ALPHANUM(x) || IS_MARK(x))
  |  |  ------------------
  |  |  |  |   93|    362|#define IS_ALPHANUM(x) (IS_ALPHA(x) || IS_DIGIT(x))
  |  |  |  |  ------------------
  |  |  |  |  |  |   63|    362|#define IS_ALPHA(x) (IS_LOWALPHA(x) || IS_UPALPHA(x))
  |  |  |  |  |  |  ------------------
  |  |  |  |  |  |  |  |   72|    362|#define IS_LOWALPHA(x) (((x) >= 'a') && ((x) <= 'z'))
  |  |  |  |  |  |  |  |  ------------------
  |  |  |  |  |  |  |  |  |  Branch (72:25): [True: 133, False: 48]
  |  |  |  |  |  |  |  |  |  Branch (72:41): [True: 133, False: 0]
  |  |  |  |  |  |  |  |  ------------------
  |  |  |  |  |  |  ------------------
  |  |  |  |  |  |               #define IS_ALPHA(x) (IS_LOWALPHA(x) || IS_UPALPHA(x))
  |  |  |  |  |  |  ------------------
  |  |  |  |  |  |  |  |   79|     48|#define IS_UPALPHA(x) (((x) >= 'A') && ((x) <= 'Z'))
  |  |  |  |  |  |  |  |  ------------------
  |  |  |  |  |  |  |  |  |  Branch (79:24): [True: 0, False: 48]
  |  |  |  |  |  |  |  |  |  Branch (79:40): [True: 0, False: 0]
  |  |  |  |  |  |  |  |  ------------------
  |  |  |  |  |  |  ------------------
  |  |  |  |  ------------------
  |  |  |  |               #define IS_ALPHANUM(x) (IS_ALPHA(x) || IS_DIGIT(x))
  |  |  |  |  ------------------
  |  |  |  |  |  |   87|     48|#define IS_DIGIT(x) (((x) >= '0') && ((x) <= '9'))
  |  |  |  |  |  |  ------------------
  |  |  |  |  |  |  |  Branch (87:22): [True: 2, False: 46]
  |  |  |  |  |  |  |  Branch (87:38): [True: 2, False: 0]
  |  |  |  |  |  |  ------------------
  |  |  |  |  ------------------
  |  |  ------------------
  |  |               #define IS_UNRESERVED(x) (IS_ALPHANUM(x) || IS_MARK(x))
  |  |  ------------------
  |  |  |  |   99|     46|#define IS_MARK(x) (((x) == '-') || ((x) == '_') || ((x) == '.') ||     \
  |  |  |  |  ------------------
  |  |  |  |  |  Branch (99:21): [True: 1, False: 45]
  |  |  |  |  |  Branch (99:37): [True: 0, False: 45]
  |  |  |  |  |  Branch (99:53): [True: 27, False: 18]
  |  |  |  |  ------------------
  |  |  |  |  100|     46|    ((x) == '!') || ((x) == '~') || ((x) == '*') || ((x) == '\'') ||    \
  |  |  |  |  ------------------
  |  |  |  |  |  Branch (100:5): [True: 0, False: 18]
  |  |  |  |  |  Branch (100:21): [True: 0, False: 18]
  |  |  |  |  |  Branch (100:37): [True: 0, False: 18]
  |  |  |  |  |  Branch (100:53): [True: 0, False: 18]
  |  |  |  |  ------------------
  |  |  |  |  101|     46|    ((x) == '(') || ((x) == ')'))
  |  |  |  |  ------------------
  |  |  |  |  |  Branch (101:5): [True: 0, False: 18]
  |  |  |  |  |  Branch (101:21): [True: 0, False: 18]
  |  |  |  |  ------------------
  |  |  ------------------
  ------------------
  |  Branch (1723:6): [True: 181, False: 0]
  |  Branch (1723:45): [True: 0, False: 18]
  ------------------
 1724|      0|	    unsigned char val;
 1725|      0|	    ret[out++] = '%';
 1726|      0|	    val = ch >> 4;
 1727|      0|	    if (val <= 9)
  ------------------
  |  Branch (1727:10): [True: 0, False: 0]
  ------------------
 1728|      0|		ret[out++] = '0' + val;
 1729|      0|	    else
 1730|      0|		ret[out++] = 'A' + val - 0xA;
 1731|      0|	    val = ch & 0xF;
 1732|      0|	    if (val <= 9)
  ------------------
  |  Branch (1732:10): [True: 0, False: 0]
  ------------------
 1733|      0|		ret[out++] = '0' + val;
 1734|      0|	    else
 1735|      0|		ret[out++] = 'A' + val - 0xA;
 1736|      0|	    in++;
 1737|    181|	} else {
 1738|    181|	    ret[out++] = *in++;
 1739|    181|	}
 1740|       |
 1741|    181|    }
 1742|      9|    ret[out] = 0;
 1743|      9|    return(ret);
 1744|      9|}
xmlURIEscape:
 1763|    164|{
 1764|    164|    xmlChar *ret, *segment = NULL;
 1765|    164|    xmlURIPtr uri;
 1766|    164|    int ret2;
 1767|       |
 1768|    164|    if (str == NULL)
  ------------------
  |  Branch (1768:9): [True: 82, False: 82]
  ------------------
 1769|     82|        return (NULL);
 1770|       |
 1771|     82|    uri = xmlCreateURI();
 1772|     82|    if (uri != NULL) {
  ------------------
  |  Branch (1772:9): [True: 81, False: 1]
  ------------------
 1773|       |	/*
 1774|       |	 * Allow escaping errors in the unescaped form
 1775|       |	 */
 1776|     81|        uri->cleanup = 1;
 1777|     81|        ret2 = xmlParseURIReference(uri, (const char *)str);
 1778|     81|        if (ret2) {
  ------------------
  |  Branch (1778:13): [True: 0, False: 81]
  ------------------
 1779|      0|            xmlFreeURI(uri);
 1780|      0|            return (NULL);
 1781|      0|        }
 1782|     81|    }
 1783|       |
 1784|     82|    if (!uri)
  ------------------
  |  Branch (1784:9): [True: 1, False: 81]
  ------------------
 1785|      1|        return NULL;
 1786|       |
 1787|     81|    ret = NULL;
 1788|       |
 1789|     81|#define NULLCHK(p) if(!p) { \
 1790|     81|         xmlURIErrMemory("escaping URI value\n"); \
 1791|     81|         xmlFreeURI(uri); \
 1792|     81|         xmlFree(ret); \
 1793|     81|         return NULL; } \
 1794|     81|
 1795|     81|    if (uri->scheme) {
  ------------------
  |  Branch (1795:9): [True: 0, False: 81]
  ------------------
 1796|      0|        segment = xmlURIEscapeStr(BAD_CAST uri->scheme, BAD_CAST "+-.");
  ------------------
  |  |   35|      0|#define BAD_CAST (xmlChar *)
  ------------------
                      segment = xmlURIEscapeStr(BAD_CAST uri->scheme, BAD_CAST "+-.");
  ------------------
  |  |   35|      0|#define BAD_CAST (xmlChar *)
  ------------------
 1797|      0|        NULLCHK(segment)
  ------------------
  |  | 1789|      0|#define NULLCHK(p) if(!p) { \
  |  |  ------------------
  |  |  |  Branch (1789:23): [True: 0, False: 0]
  |  |  ------------------
  |  | 1790|      0|         xmlURIErrMemory("escaping URI value\n"); \
  |  | 1791|      0|         xmlFreeURI(uri); \
  |  | 1792|      0|         xmlFree(ret); \
  |  | 1793|      0|         return NULL; } \
  ------------------
 1798|      0|        ret = xmlStrcat(ret, segment);
 1799|      0|        ret = xmlStrcat(ret, BAD_CAST ":");
  ------------------
  |  |   35|      0|#define BAD_CAST (xmlChar *)
  ------------------
 1800|      0|        xmlFree(segment);
 1801|      0|    }
 1802|       |
 1803|     81|    if (uri->authority) {
  ------------------
  |  Branch (1803:9): [True: 0, False: 81]
  ------------------
 1804|      0|        segment =
 1805|      0|            xmlURIEscapeStr(BAD_CAST uri->authority, BAD_CAST "/?;:@");
  ------------------
  |  |   35|      0|#define BAD_CAST (xmlChar *)
  ------------------
                          xmlURIEscapeStr(BAD_CAST uri->authority, BAD_CAST "/?;:@");
  ------------------
  |  |   35|      0|#define BAD_CAST (xmlChar *)
  ------------------
 1806|      0|        NULLCHK(segment)
  ------------------
  |  | 1789|      0|#define NULLCHK(p) if(!p) { \
  |  |  ------------------
  |  |  |  Branch (1789:23): [True: 0, False: 0]
  |  |  ------------------
  |  | 1790|      0|         xmlURIErrMemory("escaping URI value\n"); \
  |  | 1791|      0|         xmlFreeURI(uri); \
  |  | 1792|      0|         xmlFree(ret); \
  |  | 1793|      0|         return NULL; } \
  ------------------
 1807|      0|        ret = xmlStrcat(ret, BAD_CAST "//");
  ------------------
  |  |   35|      0|#define BAD_CAST (xmlChar *)
  ------------------
 1808|      0|        ret = xmlStrcat(ret, segment);
 1809|      0|        xmlFree(segment);
 1810|      0|    }
 1811|       |
 1812|     81|    if (uri->user) {
  ------------------
  |  Branch (1812:9): [True: 0, False: 81]
  ------------------
 1813|      0|        segment = xmlURIEscapeStr(BAD_CAST uri->user, BAD_CAST ";:&=+$,");
  ------------------
  |  |   35|      0|#define BAD_CAST (xmlChar *)
  ------------------
                      segment = xmlURIEscapeStr(BAD_CAST uri->user, BAD_CAST ";:&=+$,");
  ------------------
  |  |   35|      0|#define BAD_CAST (xmlChar *)
  ------------------
 1814|      0|        NULLCHK(segment)
  ------------------
  |  | 1789|      0|#define NULLCHK(p) if(!p) { \
  |  |  ------------------
  |  |  |  Branch (1789:23): [True: 0, False: 0]
  |  |  ------------------
  |  | 1790|      0|         xmlURIErrMemory("escaping URI value\n"); \
  |  | 1791|      0|         xmlFreeURI(uri); \
  |  | 1792|      0|         xmlFree(ret); \
  |  | 1793|      0|         return NULL; } \
  ------------------
 1815|      0|        ret = xmlStrcat(ret,BAD_CAST "//");
  ------------------
  |  |   35|      0|#define BAD_CAST (xmlChar *)
  ------------------
 1816|      0|        ret = xmlStrcat(ret, segment);
 1817|      0|        ret = xmlStrcat(ret, BAD_CAST "@");
  ------------------
  |  |   35|      0|#define BAD_CAST (xmlChar *)
  ------------------
 1818|      0|        xmlFree(segment);
 1819|      0|    }
 1820|       |
 1821|     81|    if (uri->server) {
  ------------------
  |  Branch (1821:9): [True: 0, False: 81]
  ------------------
 1822|      0|        segment = xmlURIEscapeStr(BAD_CAST uri->server, BAD_CAST "/?;:@");
  ------------------
  |  |   35|      0|#define BAD_CAST (xmlChar *)
  ------------------
                      segment = xmlURIEscapeStr(BAD_CAST uri->server, BAD_CAST "/?;:@");
  ------------------
  |  |   35|      0|#define BAD_CAST (xmlChar *)
  ------------------
 1823|      0|        NULLCHK(segment)
  ------------------
  |  | 1789|      0|#define NULLCHK(p) if(!p) { \
  |  |  ------------------
  |  |  |  Branch (1789:23): [True: 0, False: 0]
  |  |  ------------------
  |  | 1790|      0|         xmlURIErrMemory("escaping URI value\n"); \
  |  | 1791|      0|         xmlFreeURI(uri); \
  |  | 1792|      0|         xmlFree(ret); \
  |  | 1793|      0|         return NULL; } \
  ------------------
 1824|      0|        if (uri->user == NULL)
  ------------------
  |  Branch (1824:13): [True: 0, False: 0]
  ------------------
 1825|      0|            ret = xmlStrcat(ret, BAD_CAST "//");
  ------------------
  |  |   35|      0|#define BAD_CAST (xmlChar *)
  ------------------
 1826|      0|        ret = xmlStrcat(ret, segment);
 1827|      0|        xmlFree(segment);
 1828|      0|    }
 1829|       |
 1830|     81|    if (uri->port > 0) {
  ------------------
  |  Branch (1830:9): [True: 0, False: 81]
  ------------------
 1831|      0|        xmlChar port[11];
 1832|       |
 1833|      0|        snprintf((char *) port, 11, "%d", uri->port);
 1834|      0|        ret = xmlStrcat(ret, BAD_CAST ":");
  ------------------
  |  |   35|      0|#define BAD_CAST (xmlChar *)
  ------------------
 1835|      0|        ret = xmlStrcat(ret, port);
 1836|      0|    }
 1837|       |
 1838|     81|    if (uri->path) {
  ------------------
  |  Branch (1838:9): [True: 0, False: 81]
  ------------------
 1839|      0|        segment =
 1840|      0|            xmlURIEscapeStr(BAD_CAST uri->path, BAD_CAST ":@&=+$,/?;");
  ------------------
  |  |   35|      0|#define BAD_CAST (xmlChar *)
  ------------------
                          xmlURIEscapeStr(BAD_CAST uri->path, BAD_CAST ":@&=+$,/?;");
  ------------------
  |  |   35|      0|#define BAD_CAST (xmlChar *)
  ------------------
 1841|      0|        NULLCHK(segment)
  ------------------
  |  | 1789|      0|#define NULLCHK(p) if(!p) { \
  |  |  ------------------
  |  |  |  Branch (1789:23): [True: 0, False: 0]
  |  |  ------------------
  |  | 1790|      0|         xmlURIErrMemory("escaping URI value\n"); \
  |  | 1791|      0|         xmlFreeURI(uri); \
  |  | 1792|      0|         xmlFree(ret); \
  |  | 1793|      0|         return NULL; } \
  ------------------
 1842|      0|        ret = xmlStrcat(ret, segment);
 1843|      0|        xmlFree(segment);
 1844|      0|    }
 1845|       |
 1846|     81|    if (uri->query_raw) {
  ------------------
  |  Branch (1846:9): [True: 0, False: 81]
  ------------------
 1847|      0|        ret = xmlStrcat(ret, BAD_CAST "?");
  ------------------
  |  |   35|      0|#define BAD_CAST (xmlChar *)
  ------------------
 1848|      0|        ret = xmlStrcat(ret, BAD_CAST uri->query_raw);
  ------------------
  |  |   35|      0|#define BAD_CAST (xmlChar *)
  ------------------
 1849|      0|    }
 1850|     81|    else if (uri->query) {
  ------------------
  |  Branch (1850:14): [True: 0, False: 81]
  ------------------
 1851|      0|        segment =
 1852|      0|            xmlURIEscapeStr(BAD_CAST uri->query, BAD_CAST ";/?:@&=+,$");
  ------------------
  |  |   35|      0|#define BAD_CAST (xmlChar *)
  ------------------
                          xmlURIEscapeStr(BAD_CAST uri->query, BAD_CAST ";/?:@&=+,$");
  ------------------
  |  |   35|      0|#define BAD_CAST (xmlChar *)
  ------------------
 1853|      0|        NULLCHK(segment)
  ------------------
  |  | 1789|      0|#define NULLCHK(p) if(!p) { \
  |  |  ------------------
  |  |  |  Branch (1789:23): [True: 0, False: 0]
  |  |  ------------------
  |  | 1790|      0|         xmlURIErrMemory("escaping URI value\n"); \
  |  | 1791|      0|         xmlFreeURI(uri); \
  |  | 1792|      0|         xmlFree(ret); \
  |  | 1793|      0|         return NULL; } \
  ------------------
 1854|      0|        ret = xmlStrcat(ret, BAD_CAST "?");
  ------------------
  |  |   35|      0|#define BAD_CAST (xmlChar *)
  ------------------
 1855|      0|        ret = xmlStrcat(ret, segment);
 1856|      0|        xmlFree(segment);
 1857|      0|    }
 1858|       |
 1859|     81|    if (uri->opaque) {
  ------------------
  |  Branch (1859:9): [True: 0, False: 81]
  ------------------
 1860|      0|        segment = xmlURIEscapeStr(BAD_CAST uri->opaque, BAD_CAST "");
  ------------------
  |  |   35|      0|#define BAD_CAST (xmlChar *)
  ------------------
                      segment = xmlURIEscapeStr(BAD_CAST uri->opaque, BAD_CAST "");
  ------------------
  |  |   35|      0|#define BAD_CAST (xmlChar *)
  ------------------
 1861|      0|        NULLCHK(segment)
  ------------------
  |  | 1789|      0|#define NULLCHK(p) if(!p) { \
  |  |  ------------------
  |  |  |  Branch (1789:23): [True: 0, False: 0]
  |  |  ------------------
  |  | 1790|      0|         xmlURIErrMemory("escaping URI value\n"); \
  |  | 1791|      0|         xmlFreeURI(uri); \
  |  | 1792|      0|         xmlFree(ret); \
  |  | 1793|      0|         return NULL; } \
  ------------------
 1862|      0|        ret = xmlStrcat(ret, segment);
 1863|      0|        xmlFree(segment);
 1864|      0|    }
 1865|       |
 1866|     81|    if (uri->fragment) {
  ------------------
  |  Branch (1866:9): [True: 0, False: 81]
  ------------------
 1867|      0|        segment = xmlURIEscapeStr(BAD_CAST uri->fragment, BAD_CAST "#");
  ------------------
  |  |   35|      0|#define BAD_CAST (xmlChar *)
  ------------------
                      segment = xmlURIEscapeStr(BAD_CAST uri->fragment, BAD_CAST "#");
  ------------------
  |  |   35|      0|#define BAD_CAST (xmlChar *)
  ------------------
 1868|      0|        NULLCHK(segment)
  ------------------
  |  | 1789|      0|#define NULLCHK(p) if(!p) { \
  |  |  ------------------
  |  |  |  Branch (1789:23): [True: 0, False: 0]
  |  |  ------------------
  |  | 1790|      0|         xmlURIErrMemory("escaping URI value\n"); \
  |  | 1791|      0|         xmlFreeURI(uri); \
  |  | 1792|      0|         xmlFree(ret); \
  |  | 1793|      0|         return NULL; } \
  ------------------
 1869|      0|        ret = xmlStrcat(ret, BAD_CAST "#");
  ------------------
  |  |   35|      0|#define BAD_CAST (xmlChar *)
  ------------------
 1870|      0|        ret = xmlStrcat(ret, segment);
 1871|      0|        xmlFree(segment);
 1872|      0|    }
 1873|       |
 1874|     81|    xmlFreeURI(uri);
 1875|     81|#undef NULLCHK
 1876|       |
 1877|     81|    return (ret);
 1878|     81|}
xmlBuildURI:
 1902|    566|xmlBuildURI(const xmlChar *URI, const xmlChar *base) {
 1903|    566|    xmlChar *val = NULL;
 1904|    566|    int ret, len, indx, cur, out;
 1905|    566|    xmlURIPtr ref = NULL;
 1906|    566|    xmlURIPtr bas = NULL;
 1907|    566|    xmlURIPtr res = NULL;
 1908|       |
 1909|       |    /*
 1910|       |     * 1) The URI reference is parsed into the potential four components and
 1911|       |     *    fragment identifier, as described in Section 4.3.
 1912|       |     *
 1913|       |     *    NOTE that a completely empty URI is treated by modern browsers
 1914|       |     *    as a reference to "." rather than as a synonym for the current
 1915|       |     *    URI.  Should we do that here?
 1916|       |     */
 1917|    566|    if (URI == NULL)
  ------------------
  |  Branch (1917:9): [True: 82, False: 484]
  ------------------
 1918|     82|	ret = -1;
 1919|    484|    else {
 1920|    484|	if (*URI) {
  ------------------
  |  Branch (1920:6): [True: 258, False: 226]
  ------------------
 1921|    258|	    ref = xmlCreateURI();
 1922|    258|	    if (ref == NULL)
  ------------------
  |  Branch (1922:10): [True: 0, False: 258]
  ------------------
 1923|      0|		goto done;
 1924|    258|	    ret = xmlParseURIReference(ref, (const char *) URI);
 1925|    258|	}
 1926|    226|	else
 1927|    226|	    ret = 0;
 1928|    484|    }
 1929|    566|    if (ret != 0)
  ------------------
  |  Branch (1929:9): [True: 82, False: 484]
  ------------------
 1930|     82|	goto done;
 1931|    484|    if ((ref != NULL) && (ref->scheme != NULL)) {
  ------------------
  |  Branch (1931:9): [True: 258, False: 226]
  |  Branch (1931:26): [True: 0, False: 258]
  ------------------
 1932|       |	/*
 1933|       |	 * The URI is absolute don't modify.
 1934|       |	 */
 1935|      0|	val = xmlStrdup(URI);
 1936|      0|	goto done;
 1937|      0|    }
 1938|    484|    if (base == NULL)
  ------------------
  |  Branch (1938:9): [True: 226, False: 258]
  ------------------
 1939|    226|	ret = -1;
 1940|    258|    else {
 1941|    258|	bas = xmlCreateURI();
 1942|    258|	if (bas == NULL)
  ------------------
  |  Branch (1942:6): [True: 1, False: 257]
  ------------------
 1943|      1|	    goto done;
 1944|    257|	ret = xmlParseURIReference(bas, (const char *) base);
 1945|    257|    }
 1946|    483|    if (ret != 0) {
  ------------------
  |  Branch (1946:9): [True: 226, False: 257]
  ------------------
 1947|    226|	if (ref)
  ------------------
  |  Branch (1947:6): [True: 145, False: 81]
  ------------------
 1948|    145|	    val = xmlSaveUri(ref);
 1949|    226|	goto done;
 1950|    226|    }
 1951|    257|    if (ref == NULL) {
  ------------------
  |  Branch (1951:9): [True: 144, False: 113]
  ------------------
 1952|       |	/*
 1953|       |	 * the base fragment must be ignored
 1954|       |	 */
 1955|    144|	if (bas->fragment != NULL) {
  ------------------
  |  Branch (1955:6): [True: 0, False: 144]
  ------------------
 1956|      0|	    xmlFree(bas->fragment);
 1957|      0|	    bas->fragment = NULL;
 1958|      0|	}
 1959|    144|	val = xmlSaveUri(bas);
 1960|    144|	goto done;
 1961|    144|    }
 1962|       |
 1963|       |    /*
 1964|       |     * 2) If the path component is empty and the scheme, authority, and
 1965|       |     *    query components are undefined, then it is a reference to the
 1966|       |     *    current document and we are done.  Otherwise, the reference URI's
 1967|       |     *    query and fragment components are defined as found (or not found)
 1968|       |     *    within the URI reference and not inherited from the base URI.
 1969|       |     *
 1970|       |     *    NOTE that in modern browsers, the parsing differs from the above
 1971|       |     *    in the following aspect:  the query component is allowed to be
 1972|       |     *    defined while still treating this as a reference to the current
 1973|       |     *    document.
 1974|       |     */
 1975|    113|    res = xmlCreateURI();
 1976|    113|    if (res == NULL)
  ------------------
  |  Branch (1976:9): [True: 0, False: 113]
  ------------------
 1977|      0|	goto done;
 1978|    113|    if ((ref->scheme == NULL) && (ref->path == NULL) &&
  ------------------
  |  Branch (1978:9): [True: 113, False: 0]
  |  Branch (1978:34): [True: 6, False: 107]
  ------------------
 1979|    113|	((ref->authority == NULL) && (ref->server == NULL) &&
  ------------------
  |  Branch (1979:3): [True: 6, False: 0]
  |  Branch (1979:31): [True: 6, False: 0]
  ------------------
 1980|      6|         (ref->port == PORT_EMPTY))) {
  ------------------
  |  |   37|      6|#define PORT_EMPTY           0
  ------------------
  |  Branch (1980:10): [True: 6, False: 0]
  ------------------
 1981|      6|	if (bas->scheme != NULL)
  ------------------
  |  Branch (1981:6): [True: 0, False: 6]
  ------------------
 1982|      0|	    res->scheme = xmlMemStrdup(bas->scheme);
 1983|      6|	if (bas->authority != NULL)
  ------------------
  |  Branch (1983:6): [True: 0, False: 6]
  ------------------
 1984|      0|	    res->authority = xmlMemStrdup(bas->authority);
 1985|      6|	else {
 1986|      6|	    if (bas->server != NULL)
  ------------------
  |  Branch (1986:10): [True: 0, False: 6]
  ------------------
 1987|      0|		res->server = xmlMemStrdup(bas->server);
 1988|      6|	    if (bas->user != NULL)
  ------------------
  |  Branch (1988:10): [True: 0, False: 6]
  ------------------
 1989|      0|		res->user = xmlMemStrdup(bas->user);
 1990|      6|	    res->port = bas->port;
 1991|      6|	}
 1992|      6|	if (bas->path != NULL)
  ------------------
  |  Branch (1992:6): [True: 6, False: 0]
  ------------------
 1993|      6|	    res->path = xmlMemStrdup(bas->path);
 1994|      6|	if (ref->query_raw != NULL)
  ------------------
  |  Branch (1994:6): [True: 0, False: 6]
  ------------------
 1995|      0|	    res->query_raw = xmlMemStrdup (ref->query_raw);
 1996|      6|	else if (ref->query != NULL)
  ------------------
  |  Branch (1996:11): [True: 0, False: 6]
  ------------------
 1997|      0|	    res->query = xmlMemStrdup(ref->query);
 1998|      6|	else if (bas->query_raw != NULL)
  ------------------
  |  Branch (1998:11): [True: 0, False: 6]
  ------------------
 1999|      0|	    res->query_raw = xmlMemStrdup(bas->query_raw);
 2000|      6|	else if (bas->query != NULL)
  ------------------
  |  Branch (2000:11): [True: 0, False: 6]
  ------------------
 2001|      0|	    res->query = xmlMemStrdup(bas->query);
 2002|      6|	if (ref->fragment != NULL)
  ------------------
  |  Branch (2002:6): [True: 6, False: 0]
  ------------------
 2003|      6|	    res->fragment = xmlMemStrdup(ref->fragment);
 2004|      6|	goto step_7;
 2005|      6|    }
 2006|       |
 2007|       |    /*
 2008|       |     * 3) If the scheme component is defined, indicating that the reference
 2009|       |     *    starts with a scheme name, then the reference is interpreted as an
 2010|       |     *    absolute URI and we are done.  Otherwise, the reference URI's
 2011|       |     *    scheme is inherited from the base URI's scheme component.
 2012|       |     */
 2013|    107|    if (ref->scheme != NULL) {
  ------------------
  |  Branch (2013:9): [True: 0, False: 107]
  ------------------
 2014|      0|	val = xmlSaveUri(ref);
 2015|      0|	goto done;
 2016|      0|    }
 2017|    107|    if (bas->scheme != NULL)
  ------------------
  |  Branch (2017:9): [True: 0, False: 107]
  ------------------
 2018|      0|	res->scheme = xmlMemStrdup(bas->scheme);
 2019|       |
 2020|    107|    if (ref->query_raw != NULL)
  ------------------
  |  Branch (2020:9): [True: 0, False: 107]
  ------------------
 2021|      0|	res->query_raw = xmlMemStrdup(ref->query_raw);
 2022|    107|    else if (ref->query != NULL)
  ------------------
  |  Branch (2022:14): [True: 0, False: 107]
  ------------------
 2023|      0|	res->query = xmlMemStrdup(ref->query);
 2024|    107|    if (ref->fragment != NULL)
  ------------------
  |  Branch (2024:9): [True: 15, False: 92]
  ------------------
 2025|     15|	res->fragment = xmlMemStrdup(ref->fragment);
 2026|       |
 2027|       |    /*
 2028|       |     * 4) If the authority component is defined, then the reference is a
 2029|       |     *    network-path and we skip to step 7.  Otherwise, the reference
 2030|       |     *    URI's authority is inherited from the base URI's authority
 2031|       |     *    component, which will also be undefined if the URI scheme does not
 2032|       |     *    use an authority component.
 2033|       |     */
 2034|    107|    if ((ref->authority != NULL) || (ref->server != NULL) ||
  ------------------
  |  Branch (2034:9): [True: 0, False: 107]
  |  Branch (2034:37): [True: 0, False: 107]
  ------------------
 2035|    107|         (ref->port != PORT_EMPTY)) {
  ------------------
  |  |   37|    107|#define PORT_EMPTY           0
  ------------------
  |  Branch (2035:10): [True: 0, False: 107]
  ------------------
 2036|      0|	if (ref->authority != NULL)
  ------------------
  |  Branch (2036:6): [True: 0, False: 0]
  ------------------
 2037|      0|	    res->authority = xmlMemStrdup(ref->authority);
 2038|      0|	else {
 2039|      0|            if (ref->server != NULL)
  ------------------
  |  Branch (2039:17): [True: 0, False: 0]
  ------------------
 2040|      0|                res->server = xmlMemStrdup(ref->server);
 2041|      0|	    if (ref->user != NULL)
  ------------------
  |  Branch (2041:10): [True: 0, False: 0]
  ------------------
 2042|      0|		res->user = xmlMemStrdup(ref->user);
 2043|      0|            res->port = ref->port;
 2044|      0|	}
 2045|      0|	if (ref->path != NULL)
  ------------------
  |  Branch (2045:6): [True: 0, False: 0]
  ------------------
 2046|      0|	    res->path = xmlMemStrdup(ref->path);
 2047|      0|	goto step_7;
 2048|      0|    }
 2049|    107|    if (bas->authority != NULL)
  ------------------
  |  Branch (2049:9): [True: 0, False: 107]
  ------------------
 2050|      0|	res->authority = xmlMemStrdup(bas->authority);
 2051|    107|    else if ((bas->server != NULL) || (bas->port != PORT_EMPTY)) {
  ------------------
  |  |   37|    107|#define PORT_EMPTY           0
  ------------------
  |  Branch (2051:14): [True: 0, False: 107]
  |  Branch (2051:39): [True: 0, False: 107]
  ------------------
 2052|      0|	if (bas->server != NULL)
  ------------------
  |  Branch (2052:6): [True: 0, False: 0]
  ------------------
 2053|      0|	    res->server = xmlMemStrdup(bas->server);
 2054|      0|	if (bas->user != NULL)
  ------------------
  |  Branch (2054:6): [True: 0, False: 0]
  ------------------
 2055|      0|	    res->user = xmlMemStrdup(bas->user);
 2056|      0|	res->port = bas->port;
 2057|      0|    }
 2058|       |
 2059|       |    /*
 2060|       |     * 5) If the path component begins with a slash character ("/"), then
 2061|       |     *    the reference is an absolute-path and we skip to step 7.
 2062|       |     */
 2063|    107|    if ((ref->path != NULL) && (ref->path[0] == '/')) {
  ------------------
  |  Branch (2063:9): [True: 107, False: 0]
  |  Branch (2063:32): [True: 0, False: 107]
  ------------------
 2064|      0|	res->path = xmlMemStrdup(ref->path);
 2065|      0|	goto step_7;
 2066|      0|    }
 2067|       |
 2068|       |
 2069|       |    /*
 2070|       |     * 6) If this step is reached, then we are resolving a relative-path
 2071|       |     *    reference.  The relative path needs to be merged with the base
 2072|       |     *    URI's path.  Although there are many ways to do this, we will
 2073|       |     *    describe a simple method using a separate string buffer.
 2074|       |     *
 2075|       |     * Allocate a buffer large enough for the result string.
 2076|       |     */
 2077|    107|    len = 2; /* extra / and 0 */
 2078|    107|    if (ref->path != NULL)
  ------------------
  |  Branch (2078:9): [True: 107, False: 0]
  ------------------
 2079|    107|	len += strlen(ref->path);
 2080|    107|    if (bas->path != NULL)
  ------------------
  |  Branch (2080:9): [True: 107, False: 0]
  ------------------
 2081|    107|	len += strlen(bas->path);
 2082|    107|    res->path = (char *) xmlMallocAtomic(len);
 2083|    107|    if (res->path == NULL) {
  ------------------
  |  Branch (2083:9): [True: 0, False: 107]
  ------------------
 2084|      0|        xmlURIErrMemory("resolving URI against base\n");
 2085|      0|	goto done;
 2086|      0|    }
 2087|    107|    res->path[0] = 0;
 2088|       |
 2089|       |    /*
 2090|       |     * a) All but the last segment of the base URI's path component is
 2091|       |     *    copied to the buffer.  In other words, any characters after the
 2092|       |     *    last (right-most) slash character, if any, are excluded.
 2093|       |     */
 2094|    107|    cur = 0;
 2095|    107|    out = 0;
 2096|    107|    if (bas->path != NULL) {
  ------------------
  |  Branch (2096:9): [True: 107, False: 0]
  ------------------
 2097|    115|	while (bas->path[cur] != 0) {
  ------------------
  |  Branch (2097:9): [True: 115, False: 0]
  ------------------
 2098|  1.45k|	    while ((bas->path[cur] != 0) && (bas->path[cur] != '/'))
  ------------------
  |  Branch (2098:13): [True: 1.35k, False: 107]
  |  Branch (2098:38): [True: 1.34k, False: 8]
  ------------------
 2099|  1.34k|		cur++;
 2100|    115|	    if (bas->path[cur] == 0)
  ------------------
  |  Branch (2100:10): [True: 107, False: 8]
  ------------------
 2101|    107|		break;
 2102|       |
 2103|      8|	    cur++;
 2104|     40|	    while (out < cur) {
  ------------------
  |  Branch (2104:13): [True: 32, False: 8]
  ------------------
 2105|     32|		res->path[out] = bas->path[out];
 2106|     32|		out++;
 2107|     32|	    }
 2108|      8|	}
 2109|    107|    }
 2110|    107|    res->path[out] = 0;
 2111|       |
 2112|       |    /*
 2113|       |     * b) The reference's path component is appended to the buffer
 2114|       |     *    string.
 2115|       |     */
 2116|    107|    if (ref->path != NULL && ref->path[0] != 0) {
  ------------------
  |  Branch (2116:9): [True: 107, False: 0]
  |  Branch (2116:30): [True: 107, False: 0]
  ------------------
 2117|    107|	indx = 0;
 2118|       |	/*
 2119|       |	 * Ensure the path includes a '/'
 2120|       |	 */
 2121|    107|	if ((out == 0) && ((bas->server != NULL) || bas->port != PORT_EMPTY))
  ------------------
  |  |   37|    103|#define PORT_EMPTY           0
  ------------------
  |  Branch (2121:6): [True: 103, False: 4]
  |  Branch (2121:21): [True: 0, False: 103]
  |  Branch (2121:46): [True: 0, False: 103]
  ------------------
 2122|      0|	    res->path[out++] = '/';
 2123|  1.44k|	while (ref->path[indx] != 0) {
  ------------------
  |  Branch (2123:9): [True: 1.33k, False: 107]
  ------------------
 2124|  1.33k|	    res->path[out++] = ref->path[indx++];
 2125|  1.33k|	}
 2126|    107|    }
 2127|    107|    res->path[out] = 0;
 2128|       |
 2129|       |    /*
 2130|       |     * Steps c) to h) are really path normalization steps
 2131|       |     */
 2132|    107|    xmlNormalizeURIPath(res->path);
 2133|       |
 2134|    113|step_7:
 2135|       |
 2136|       |    /*
 2137|       |     * 7) The resulting URI components, including any inherited from the
 2138|       |     *    base URI, are recombined to give the absolute form of the URI
 2139|       |     *    reference.
 2140|       |     */
 2141|    113|    val = xmlSaveUri(res);
 2142|       |
 2143|    566|done:
 2144|    566|    if (ref != NULL)
  ------------------
  |  Branch (2144:9): [True: 258, False: 308]
  ------------------
 2145|    258|	xmlFreeURI(ref);
 2146|    566|    if (bas != NULL)
  ------------------
  |  Branch (2146:9): [True: 257, False: 309]
  ------------------
 2147|    257|	xmlFreeURI(bas);
 2148|    566|    if (res != NULL)
  ------------------
  |  Branch (2148:9): [True: 113, False: 453]
  ------------------
 2149|    113|	xmlFreeURI(res);
 2150|    566|    return(val);
 2151|    113|}
xmlBuildRelativeURI:
 2187|     94|{
 2188|     94|    xmlChar *val = NULL;
 2189|     94|    int ret;
 2190|     94|    int ix;
 2191|     94|    int nbslash = 0;
 2192|     94|    int len;
 2193|     94|    xmlURIPtr ref = NULL;
 2194|     94|    xmlURIPtr bas = NULL;
 2195|     94|    xmlChar *bptr, *uptr, *vptr;
 2196|     94|    int remove_path = 0;
 2197|       |
 2198|     94|    if ((URI == NULL) || (*URI == 0))
  ------------------
  |  Branch (2198:9): [True: 0, False: 94]
  |  Branch (2198:26): [True: 1, False: 93]
  ------------------
 2199|      1|	return NULL;
 2200|       |
 2201|       |    /*
 2202|       |     * First parse URI into a standard form
 2203|       |     */
 2204|     93|    ref = xmlCreateURI ();
 2205|     93|    if (ref == NULL)
  ------------------
  |  Branch (2205:9): [True: 0, False: 93]
  ------------------
 2206|      0|	return NULL;
 2207|       |    /* If URI not already in "relative" form */
 2208|     93|    if (URI[0] != '.') {
  ------------------
  |  Branch (2208:9): [True: 73, False: 20]
  ------------------
 2209|     73|	ret = xmlParseURIReference (ref, (const char *) URI);
 2210|     73|	if (ret != 0)
  ------------------
  |  Branch (2210:6): [True: 0, False: 73]
  ------------------
 2211|      0|	    goto done;		/* Error in URI, return NULL */
 2212|     73|    } else
 2213|     20|	ref->path = (char *)xmlStrdup(URI);
 2214|       |
 2215|       |    /*
 2216|       |     * Next parse base into the same standard form
 2217|       |     */
 2218|     93|    if ((base == NULL) || (*base == 0)) {
  ------------------
  |  Branch (2218:9): [True: 9, False: 84]
  |  Branch (2218:27): [True: 0, False: 84]
  ------------------
 2219|      9|	val = xmlStrdup (URI);
 2220|      9|	goto done;
 2221|      9|    }
 2222|     84|    bas = xmlCreateURI ();
 2223|     84|    if (bas == NULL)
  ------------------
  |  Branch (2223:9): [True: 0, False: 84]
  ------------------
 2224|      0|	goto done;
 2225|     84|    if (base[0] != '.') {
  ------------------
  |  Branch (2225:9): [True: 82, False: 2]
  ------------------
 2226|     82|	ret = xmlParseURIReference (bas, (const char *) base);
 2227|     82|	if (ret != 0)
  ------------------
  |  Branch (2227:6): [True: 0, False: 82]
  ------------------
 2228|      0|	    goto done;		/* Error in base, return NULL */
 2229|     82|    } else
 2230|      2|	bas->path = (char *)xmlStrdup(base);
 2231|       |
 2232|       |    /*
 2233|       |     * If the scheme / server on the URI differs from the base,
 2234|       |     * just return the URI
 2235|       |     */
 2236|     84|    if ((ref->scheme != NULL) &&
  ------------------
  |  Branch (2236:9): [True: 0, False: 84]
  ------------------
 2237|     84|	((bas->scheme == NULL) ||
  ------------------
  |  Branch (2237:3): [True: 0, False: 0]
  ------------------
 2238|      0|	 (xmlStrcmp ((xmlChar *)bas->scheme, (xmlChar *)ref->scheme)) ||
  ------------------
  |  Branch (2238:3): [True: 0, False: 0]
  ------------------
 2239|      0|	 (xmlStrcmp ((xmlChar *)bas->server, (xmlChar *)ref->server)) ||
  ------------------
  |  Branch (2239:3): [True: 0, False: 0]
  ------------------
 2240|      0|         (bas->port != ref->port))) {
  ------------------
  |  Branch (2240:10): [True: 0, False: 0]
  ------------------
 2241|      0|	val = xmlStrdup (URI);
 2242|      0|	goto done;
 2243|      0|    }
 2244|     84|    if (xmlStrEqual((xmlChar *)bas->path, (xmlChar *)ref->path)) {
  ------------------
  |  Branch (2244:9): [True: 75, False: 9]
  ------------------
 2245|     75|	val = xmlStrdup(BAD_CAST "");
  ------------------
  |  |   35|     75|#define BAD_CAST (xmlChar *)
  ------------------
 2246|     75|	goto done;
 2247|     75|    }
 2248|      9|    if (bas->path == NULL) {
  ------------------
  |  Branch (2248:9): [True: 0, False: 9]
  ------------------
 2249|      0|	val = xmlStrdup((xmlChar *)ref->path);
 2250|      0|	goto done;
 2251|      0|    }
 2252|      9|    if (ref->path == NULL) {
  ------------------
  |  Branch (2252:9): [True: 0, False: 9]
  ------------------
 2253|      0|        ref->path = (char *) "/";
 2254|      0|	remove_path = 1;
 2255|      0|    }
 2256|       |
 2257|       |    /*
 2258|       |     * At this point (at last!) we can compare the two paths
 2259|       |     *
 2260|       |     * First we take care of the special case where either of the
 2261|       |     * two path components may be missing (bug 316224)
 2262|       |     */
 2263|      9|    bptr = (xmlChar *)bas->path;
 2264|      9|    {
 2265|      9|        xmlChar *rptr = (xmlChar *) ref->path;
 2266|      9|        int pos = 0;
 2267|       |
 2268|       |        /*
 2269|       |         * Next we compare the two strings and find where they first differ
 2270|       |         */
 2271|      9|	if ((*rptr == '.') && (rptr[1] == '/'))
  ------------------
  |  Branch (2271:6): [True: 9, False: 0]
  |  Branch (2271:24): [True: 0, False: 9]
  ------------------
 2272|      0|            rptr += 2;
 2273|      9|	if ((*bptr == '.') && (bptr[1] == '/'))
  ------------------
  |  Branch (2273:6): [True: 0, False: 9]
  |  Branch (2273:24): [True: 0, False: 0]
  ------------------
 2274|      0|            bptr += 2;
 2275|      9|	else if ((*bptr == '/') && (*rptr != '/'))
  ------------------
  |  Branch (2275:11): [True: 0, False: 9]
  |  Branch (2275:29): [True: 0, False: 0]
  ------------------
 2276|      0|	    bptr++;
 2277|      9|	while ((bptr[pos] == rptr[pos]) && (bptr[pos] != 0))
  ------------------
  |  Branch (2277:9): [True: 0, False: 9]
  |  Branch (2277:37): [True: 0, False: 0]
  ------------------
 2278|      0|	    pos++;
 2279|       |
 2280|      9|	if (bptr[pos] == rptr[pos]) {
  ------------------
  |  Branch (2280:6): [True: 0, False: 9]
  ------------------
 2281|      0|	    val = xmlStrdup(BAD_CAST "");
  ------------------
  |  |   35|      0|#define BAD_CAST (xmlChar *)
  ------------------
 2282|      0|	    goto done;		/* (I can't imagine why anyone would do this) */
 2283|      0|	}
 2284|       |
 2285|       |	/*
 2286|       |	 * In URI, "back up" to the last '/' encountered.  This will be the
 2287|       |	 * beginning of the "unique" suffix of URI
 2288|       |	 */
 2289|      9|	ix = pos;
 2290|      9|	for (; ix > 0; ix--) {
  ------------------
  |  Branch (2290:9): [True: 0, False: 9]
  ------------------
 2291|      0|	    if (rptr[ix - 1] == '/')
  ------------------
  |  Branch (2291:10): [True: 0, False: 0]
  ------------------
 2292|      0|		break;
 2293|      0|	}
 2294|      9|	uptr = (xmlChar *)&rptr[ix];
 2295|       |
 2296|       |	/*
 2297|       |	 * In base, count the number of '/' from the differing point
 2298|       |	 */
 2299|    112|	for (; bptr[ix] != 0; ix++) {
  ------------------
  |  Branch (2299:9): [True: 103, False: 9]
  ------------------
 2300|    103|	    if (bptr[ix] == '/')
  ------------------
  |  Branch (2300:10): [True: 0, False: 103]
  ------------------
 2301|      0|		nbslash++;
 2302|    103|	}
 2303|       |
 2304|       |	/*
 2305|       |	 * e.g: URI="foo/" base="foo/bar" -> "./"
 2306|       |	 */
 2307|      9|	if (nbslash == 0 && !uptr[0]) {
  ------------------
  |  Branch (2307:6): [True: 9, False: 0]
  |  Branch (2307:22): [True: 0, False: 9]
  ------------------
 2308|      0|	    val = xmlStrdup(BAD_CAST "./");
  ------------------
  |  |   35|      0|#define BAD_CAST (xmlChar *)
  ------------------
 2309|      0|	    goto done;
 2310|      0|	}
 2311|       |
 2312|      9|	len = xmlStrlen (uptr) + 1;
 2313|      9|    }
 2314|       |
 2315|      9|    if (nbslash == 0) {
  ------------------
  |  Branch (2315:9): [True: 9, False: 0]
  ------------------
 2316|      9|	if (uptr != NULL)
  ------------------
  |  Branch (2316:6): [True: 9, False: 0]
  ------------------
 2317|       |	    /* exception characters from xmlSaveUri */
 2318|      9|	    val = xmlURIEscapeStr(uptr, BAD_CAST "/;&=+$,");
  ------------------
  |  |   35|      9|#define BAD_CAST (xmlChar *)
  ------------------
 2319|      9|	goto done;
 2320|      9|    }
 2321|       |
 2322|       |    /*
 2323|       |     * Allocate just enough space for the returned string -
 2324|       |     * length of the remainder of the URI, plus enough space
 2325|       |     * for the "../" groups, plus one for the terminator
 2326|       |     */
 2327|      0|    val = (xmlChar *) xmlMalloc (len + 3 * nbslash);
 2328|      0|    if (val == NULL) {
  ------------------
  |  Branch (2328:9): [True: 0, False: 0]
  ------------------
 2329|      0|        xmlURIErrMemory("building relative URI\n");
 2330|      0|	goto done;
 2331|      0|    }
 2332|      0|    vptr = val;
 2333|       |    /*
 2334|       |     * Put in as many "../" as needed
 2335|       |     */
 2336|      0|    for (; nbslash>0; nbslash--) {
  ------------------
  |  Branch (2336:12): [True: 0, False: 0]
  ------------------
 2337|      0|	*vptr++ = '.';
 2338|      0|	*vptr++ = '.';
 2339|      0|	*vptr++ = '/';
 2340|      0|    }
 2341|       |    /*
 2342|       |     * Finish up with the end of the URI
 2343|       |     */
 2344|      0|    if (uptr != NULL) {
  ------------------
  |  Branch (2344:9): [True: 0, False: 0]
  ------------------
 2345|      0|        if ((vptr > val) && (len > 0) &&
  ------------------
  |  Branch (2345:13): [True: 0, False: 0]
  |  Branch (2345:29): [True: 0, False: 0]
  ------------------
 2346|      0|	    (uptr[0] == '/') && (vptr[-1] == '/')) {
  ------------------
  |  Branch (2346:6): [True: 0, False: 0]
  |  Branch (2346:26): [True: 0, False: 0]
  ------------------
 2347|      0|	    memcpy (vptr, uptr + 1, len - 1);
 2348|      0|	    vptr[len - 2] = 0;
 2349|      0|	} else {
 2350|      0|	    memcpy (vptr, uptr, len);
 2351|      0|	    vptr[len - 1] = 0;
 2352|      0|	}
 2353|      0|    } else {
 2354|      0|	vptr[len - 1] = 0;
 2355|      0|    }
 2356|       |
 2357|       |    /* escape the freshly-built path */
 2358|      0|    vptr = val;
 2359|       |	/* exception characters from xmlSaveUri */
 2360|      0|    val = xmlURIEscapeStr(vptr, BAD_CAST "/;&=+$,");
  ------------------
  |  |   35|      0|#define BAD_CAST (xmlChar *)
  ------------------
 2361|      0|    xmlFree(vptr);
 2362|       |
 2363|     93|done:
 2364|       |    /*
 2365|       |     * Free the working variables
 2366|       |     */
 2367|     93|    if (remove_path != 0)
  ------------------
  |  Branch (2367:9): [True: 0, False: 93]
  ------------------
 2368|      0|        ref->path = NULL;
 2369|     93|    if (ref != NULL)
  ------------------
  |  Branch (2369:9): [True: 93, False: 0]
  ------------------
 2370|     93|	xmlFreeURI (ref);
 2371|     93|    if (bas != NULL)
  ------------------
  |  Branch (2371:9): [True: 84, False: 9]
  ------------------
 2372|     84|	xmlFreeURI (bas);
 2373|       |
 2374|     93|    return val;
 2375|      0|}
xmlCanonicPath:
 2395|    128|{
 2396|       |/*
 2397|       | * For Windows implementations, additional work needs to be done to
 2398|       | * replace backslashes in pathnames with "forward slashes"
 2399|       | */
 2400|       |#if defined(_WIN32)
 2401|       |    int len = 0;
 2402|       |    char *p = NULL;
 2403|       |#endif
 2404|    128|    xmlURIPtr uri;
 2405|    128|    xmlChar *ret;
 2406|    128|    const xmlChar *absuri;
 2407|       |
 2408|    128|    if (path == NULL)
  ------------------
  |  Branch (2408:9): [True: 0, False: 128]
  ------------------
 2409|      0|	return(NULL);
 2410|       |
 2411|       |#if defined(_WIN32)
 2412|       |    /*
 2413|       |     * We must not change the backslashes to slashes if the the path
 2414|       |     * starts with \\?\
 2415|       |     * Those paths can be up to 32k characters long.
 2416|       |     * Was added specifically for OpenOffice, those paths can't be converted
 2417|       |     * to URIs anyway.
 2418|       |     */
 2419|       |    if ((path[0] == '\\') && (path[1] == '\\') && (path[2] == '?') &&
 2420|       |        (path[3] == '\\') )
 2421|       |	return xmlStrdup((const xmlChar *) path);
 2422|       |#endif
 2423|       |
 2424|       |	/* sanitize filename starting with // so it can be used as URI */
 2425|    128|    if ((path[0] == '/') && (path[1] == '/') && (path[2] != '/'))
  ------------------
  |  Branch (2425:9): [True: 0, False: 128]
  |  Branch (2425:29): [True: 0, False: 0]
  |  Branch (2425:49): [True: 0, False: 0]
  ------------------
 2426|      0|        path++;
 2427|       |
 2428|    128|    if ((uri = xmlParseURI((const char *) path)) != NULL) {
  ------------------
  |  Branch (2428:9): [True: 120, False: 8]
  ------------------
 2429|    120|	xmlFreeURI(uri);
 2430|    120|	return xmlStrdup(path);
 2431|    120|    }
 2432|       |
 2433|       |    /* Check if this is an "absolute uri" */
 2434|      8|    absuri = xmlStrstr(path, BAD_CAST "://");
  ------------------
  |  |   35|      8|#define BAD_CAST (xmlChar *)
  ------------------
 2435|      8|    if (absuri != NULL) {
  ------------------
  |  Branch (2435:9): [True: 3, False: 5]
  ------------------
 2436|      3|        int l, j;
 2437|      3|	unsigned char c;
 2438|      3|	xmlChar *escURI;
 2439|       |
 2440|       |        /*
 2441|       |	 * this looks like an URI where some parts have not been
 2442|       |	 * escaped leading to a parsing problem.  Check that the first
 2443|       |	 * part matches a protocol.
 2444|       |	 */
 2445|      3|	l = absuri - path;
 2446|       |	/* Bypass if first part (part before the '://') is > 20 chars */
 2447|      3|	if ((l <= 0) || (l > 20))
  ------------------
  |  Branch (2447:6): [True: 0, False: 3]
  |  Branch (2447:18): [True: 3, False: 0]
  ------------------
 2448|      3|	    goto path_processing;
 2449|       |	/* Bypass if any non-alpha characters are present in first part */
 2450|      0|	for (j = 0;j < l;j++) {
  ------------------
  |  Branch (2450:13): [True: 0, False: 0]
  ------------------
 2451|      0|	    c = path[j];
 2452|      0|	    if (!(((c >= 'a') && (c <= 'z')) || ((c >= 'A') && (c <= 'Z'))))
  ------------------
  |  Branch (2452:13): [True: 0, False: 0]
  |  Branch (2452:27): [True: 0, False: 0]
  |  Branch (2452:43): [True: 0, False: 0]
  |  Branch (2452:57): [True: 0, False: 0]
  ------------------
 2453|      0|	        goto path_processing;
 2454|      0|	}
 2455|       |
 2456|       |	/* Escape all except the characters specified in the supplied path */
 2457|      0|        escURI = xmlURIEscapeStr(path, BAD_CAST ":/?_.#&;=");
  ------------------
  |  |   35|      0|#define BAD_CAST (xmlChar *)
  ------------------
 2458|      0|	if (escURI != NULL) {
  ------------------
  |  Branch (2458:6): [True: 0, False: 0]
  ------------------
 2459|       |	    /* Try parsing the escaped path */
 2460|      0|	    uri = xmlParseURI((const char *) escURI);
 2461|       |	    /* If successful, return the escaped string */
 2462|      0|	    if (uri != NULL) {
  ------------------
  |  Branch (2462:10): [True: 0, False: 0]
  ------------------
 2463|      0|	        xmlFreeURI(uri);
 2464|      0|		return escURI;
 2465|      0|	    }
 2466|      0|            xmlFree(escURI);
 2467|      0|	}
 2468|      0|    }
 2469|       |
 2470|      8|path_processing:
 2471|       |/* For Windows implementations, replace backslashes with 'forward slashes' */
 2472|       |#if defined(_WIN32)
 2473|       |    /*
 2474|       |     * Create a URI structure
 2475|       |     */
 2476|       |    uri = xmlCreateURI();
 2477|       |    if (uri == NULL) {		/* Guard against 'out of memory' */
 2478|       |        return(NULL);
 2479|       |    }
 2480|       |
 2481|       |    len = xmlStrlen(path);
 2482|       |    if ((len > 2) && IS_WINDOWS_PATH(path)) {
 2483|       |        /* make the scheme 'file' */
 2484|       |	uri->scheme = (char *) xmlStrdup(BAD_CAST "file");
 2485|       |	/* allocate space for leading '/' + path + string terminator */
 2486|       |	uri->path = xmlMallocAtomic(len + 2);
 2487|       |	if (uri->path == NULL) {
 2488|       |	    xmlFreeURI(uri);	/* Guard against 'out of memory' */
 2489|       |	    return(NULL);
 2490|       |	}
 2491|       |	/* Put in leading '/' plus path */
 2492|       |	uri->path[0] = '/';
 2493|       |	p = uri->path + 1;
 2494|       |	strncpy(p, (char *) path, len + 1);
 2495|       |    } else {
 2496|       |	uri->path = (char *) xmlStrdup(path);
 2497|       |	if (uri->path == NULL) {
 2498|       |	    xmlFreeURI(uri);
 2499|       |	    return(NULL);
 2500|       |	}
 2501|       |	p = uri->path;
 2502|       |    }
 2503|       |    /* Now change all occurrences of '\' to '/' */
 2504|       |    while (*p != '\0') {
 2505|       |	if (*p == '\\')
 2506|       |	    *p = '/';
 2507|       |	p++;
 2508|       |    }
 2509|       |
 2510|       |    if (uri->scheme == NULL) {
 2511|       |	ret = xmlStrdup((const xmlChar *) uri->path);
 2512|       |    } else {
 2513|       |	ret = xmlSaveUri(uri);
 2514|       |    }
 2515|       |
 2516|       |    xmlFreeURI(uri);
 2517|       |#else
 2518|      8|    ret = xmlStrdup((const xmlChar *) path);
 2519|      8|#endif
 2520|      8|    return(ret);
 2521|      8|}
xmlPathToURI:
 2536|    215|{
 2537|    215|    xmlURIPtr uri;
 2538|    215|    xmlURI temp;
 2539|    215|    xmlChar *ret, *cal;
 2540|       |
 2541|    215|    if (path == NULL)
  ------------------
  |  Branch (2541:9): [True: 0, False: 215]
  ------------------
 2542|      0|        return(NULL);
 2543|       |
 2544|    215|    if ((uri = xmlParseURI((const char *) path)) != NULL) {
  ------------------
  |  Branch (2544:9): [True: 207, False: 8]
  ------------------
 2545|    207|	xmlFreeURI(uri);
 2546|    207|	return xmlStrdup(path);
 2547|    207|    }
 2548|      8|    cal = xmlCanonicPath(path);
 2549|      8|    if (cal == NULL)
  ------------------
  |  Branch (2549:9): [True: 0, False: 8]
  ------------------
 2550|      0|        return(NULL);
 2551|       |#if defined(_WIN32)
 2552|       |    /* xmlCanonicPath can return an URI on Windows (is that the intended behaviour?)
 2553|       |       If 'cal' is a valid URI already then we are done here, as continuing would make
 2554|       |       it invalid. */
 2555|       |    if ((uri = xmlParseURI((const char *) cal)) != NULL) {
 2556|       |	xmlFreeURI(uri);
 2557|       |	return cal;
 2558|       |    }
 2559|       |    /* 'cal' can contain a relative path with backslashes. If that is processed
 2560|       |       by xmlSaveURI, they will be escaped and the external entity loader machinery
 2561|       |       will fail. So convert them to slashes. Misuse 'ret' for walking. */
 2562|       |    ret = cal;
 2563|       |    while (*ret != '\0') {
 2564|       |	if (*ret == '\\')
 2565|       |	    *ret = '/';
 2566|       |	ret++;
 2567|       |    }
 2568|       |#endif
 2569|      8|    memset(&temp, 0, sizeof(temp));
 2570|      8|    temp.path = (char *) cal;
 2571|      8|    ret = xmlSaveUri(&temp);
 2572|      8|    xmlFree(cal);
 2573|      8|    return(ret);
 2574|      8|}
uri.c:xmlParse3986URIReference:
  913|  1.81k|xmlParse3986URIReference(xmlURIPtr uri, const char *str) {
  914|  1.81k|    int ret;
  915|       |
  916|  1.81k|    if (str == NULL)
  ------------------
  |  Branch (916:9): [True: 0, False: 1.81k]
  ------------------
  917|      0|	return(-1);
  918|  1.81k|    xmlCleanURI(uri);
  919|       |
  920|       |    /*
  921|       |     * Try first to parse absolute refs, then fallback to relative if
  922|       |     * it fails.
  923|       |     */
  924|  1.81k|    ret = xmlParse3986URI(uri, str);
  925|  1.81k|    if (ret != 0) {
  ------------------
  |  Branch (925:9): [True: 1.51k, False: 294]
  ------------------
  926|  1.51k|	xmlCleanURI(uri);
  927|  1.51k|        ret = xmlParse3986RelativeRef(uri, str);
  928|  1.51k|	if (ret != 0) {
  ------------------
  |  Branch (928:6): [True: 36, False: 1.48k]
  ------------------
  929|     36|	    xmlCleanURI(uri);
  930|     36|	    return(ret);
  931|     36|	}
  932|  1.51k|    }
  933|  1.77k|    return(0);
  934|  1.81k|}
uri.c:xmlCleanURI:
 1366|  3.41k|xmlCleanURI(xmlURIPtr uri) {
 1367|  3.41k|    if (uri == NULL) return;
  ------------------
  |  Branch (1367:9): [True: 0, False: 3.41k]
  ------------------
 1368|       |
 1369|  3.41k|    if (uri->scheme != NULL) xmlFree(uri->scheme);
  ------------------
  |  Branch (1369:9): [True: 1.09k, False: 2.31k]
  ------------------
 1370|  3.41k|    uri->scheme = NULL;
 1371|  3.41k|    if (uri->server != NULL) xmlFree(uri->server);
  ------------------
  |  Branch (1371:9): [True: 14, False: 3.40k]
  ------------------
 1372|  3.41k|    uri->server = NULL;
 1373|  3.41k|    if (uri->user != NULL) xmlFree(uri->user);
  ------------------
  |  Branch (1373:9): [True: 0, False: 3.41k]
  ------------------
 1374|  3.41k|    uri->user = NULL;
 1375|  3.41k|    if (uri->path != NULL) xmlFree(uri->path);
  ------------------
  |  Branch (1375:9): [True: 34, False: 3.38k]
  ------------------
 1376|  3.41k|    uri->path = NULL;
 1377|  3.41k|    if (uri->fragment != NULL) xmlFree(uri->fragment);
  ------------------
  |  Branch (1377:9): [True: 0, False: 3.41k]
  ------------------
 1378|  3.41k|    uri->fragment = NULL;
 1379|  3.41k|    if (uri->opaque != NULL) xmlFree(uri->opaque);
  ------------------
  |  Branch (1379:9): [True: 0, False: 3.41k]
  ------------------
 1380|  3.41k|    uri->opaque = NULL;
 1381|  3.41k|    if (uri->authority != NULL) xmlFree(uri->authority);
  ------------------
  |  Branch (1381:9): [True: 0, False: 3.41k]
  ------------------
 1382|  3.41k|    uri->authority = NULL;
 1383|  3.41k|    if (uri->query != NULL) xmlFree(uri->query);
  ------------------
  |  Branch (1383:9): [True: 0, False: 3.41k]
  ------------------
 1384|  3.41k|    uri->query = NULL;
 1385|  3.41k|    if (uri->query_raw != NULL) xmlFree(uri->query_raw);
  ------------------
  |  Branch (1385:9): [True: 0, False: 3.41k]
  ------------------
 1386|  3.41k|    uri->query_raw = NULL;
 1387|  3.41k|}
uri.c:xmlParse3986URI:
  872|  1.81k|xmlParse3986URI(xmlURIPtr uri, const char *str) {
  873|  1.81k|    int ret;
  874|       |
  875|  1.81k|    ret = xmlParse3986Scheme(uri, &str);
  876|  1.81k|    if (ret != 0) return(ret);
  ------------------
  |  Branch (876:9): [True: 419, False: 1.39k]
  ------------------
  877|  1.39k|    if (*str != ':') {
  ------------------
  |  Branch (877:9): [True: 1.08k, False: 308]
  ------------------
  878|  1.08k|	return(1);
  879|  1.08k|    }
  880|    308|    str++;
  881|    308|    ret = xmlParse3986HierPart(uri, &str);
  882|    308|    if (ret != 0) return(ret);
  ------------------
  |  Branch (882:9): [True: 0, False: 308]
  ------------------
  883|    308|    if (*str == '?') {
  ------------------
  |  Branch (883:9): [True: 0, False: 308]
  ------------------
  884|      0|	str++;
  885|      0|	ret = xmlParse3986Query(uri, &str);
  886|      0|	if (ret != 0) return(ret);
  ------------------
  |  Branch (886:6): [True: 0, False: 0]
  ------------------
  887|      0|    }
  888|    308|    if (*str == '#') {
  ------------------
  |  Branch (888:9): [True: 0, False: 308]
  ------------------
  889|      0|	str++;
  890|      0|	ret = xmlParse3986Fragment(uri, &str);
  891|      0|	if (ret != 0) return(ret);
  ------------------
  |  Branch (891:6): [True: 0, False: 0]
  ------------------
  892|      0|    }
  893|    308|    if (*str != 0) {
  ------------------
  |  Branch (893:9): [True: 14, False: 294]
  ------------------
  894|     14|	xmlCleanURI(uri);
  895|     14|	return(1);
  896|     14|    }
  897|    294|    return(0);
  898|    308|}
uri.c:xmlParse3986Scheme:
  213|  1.81k|xmlParse3986Scheme(xmlURIPtr uri, const char **str) {
  214|  1.81k|    const char *cur;
  215|       |
  216|  1.81k|    if (str == NULL)
  ------------------
  |  Branch (216:9): [True: 0, False: 1.81k]
  ------------------
  217|      0|	return(-1);
  218|       |
  219|  1.81k|    cur = *str;
  220|  1.81k|    if (!ISA_ALPHA(cur))
  ------------------
  |  |  152|  1.81k|#define ISA_ALPHA(p) (((*(p) >= 'a') && (*(p) <= 'z')) ||		\
  |  |  ------------------
  |  |  |  Branch (152:24): [True: 1.39k, False: 421]
  |  |  |  Branch (152:41): [True: 1.39k, False: 0]
  |  |  ------------------
  |  |  153|  1.81k|                      ((*(p) >= 'A') && (*(p) <= 'Z')))
  |  |  ------------------
  |  |  |  Branch (153:24): [True: 2, False: 419]
  |  |  |  Branch (153:41): [True: 2, False: 0]
  |  |  ------------------
  ------------------
  221|    419|	return(2);
  222|  1.39k|    cur++;
  223|  13.1k|    while (ISA_ALPHA(cur) || ISA_DIGIT(cur) ||
  ------------------
  |  |  152|  26.3k|#define ISA_ALPHA(p) (((*(p) >= 'a') && (*(p) <= 'z')) ||		\
  |  |  ------------------
  |  |  |  Branch (152:24): [True: 9.41k, False: 3.78k]
  |  |  |  Branch (152:41): [True: 9.41k, False: 2]
  |  |  ------------------
  |  |  153|  26.3k|                      ((*(p) >= 'A') && (*(p) <= 'Z')))
  |  |  ------------------
  |  |  |  Branch (153:24): [True: 34, False: 3.75k]
  |  |  |  Branch (153:41): [True: 24, False: 10]
  |  |  ------------------
  ------------------
                  while (ISA_ALPHA(cur) || ISA_DIGIT(cur) ||
  ------------------
  |  |  151|  16.9k|#define ISA_DIGIT(p) ((*(p) >= '0') && (*(p) <= '9'))
  |  |  ------------------
  |  |  |  Branch (151:23): [True: 1.21k, False: 2.55k]
  |  |  |  Branch (151:40): [True: 889, False: 322]
  |  |  ------------------
  ------------------
  224|  13.1k|           (*cur == '+') || (*cur == '-') || (*cur == '.')) cur++;
  ------------------
  |  Branch (224:12): [True: 0, False: 2.87k]
  |  Branch (224:29): [True: 419, False: 2.45k]
  |  Branch (224:46): [True: 1.06k, False: 1.39k]
  ------------------
  225|  1.39k|    if (uri != NULL) {
  ------------------
  |  Branch (225:9): [True: 1.39k, False: 0]
  ------------------
  226|  1.39k|	if (uri->scheme != NULL) xmlFree(uri->scheme);
  ------------------
  |  Branch (226:6): [True: 0, False: 1.39k]
  ------------------
  227|  1.39k|	uri->scheme = STRNDUP(*str, cur - *str);
  ------------------
  |  |  143|  1.39k|#define STRNDUP(s, n) (char *) xmlStrndup((const xmlChar *)(s), (n))
  ------------------
  228|  1.39k|    }
  229|  1.39k|    *str = cur;
  230|  1.39k|    return(0);
  231|  1.81k|}
uri.c:xmlParse3986HierPart:
  765|    308|{
  766|    308|    const char *cur;
  767|    308|    int ret;
  768|       |
  769|    308|    cur = *str;
  770|       |
  771|    308|    if ((*cur == '/') && (*(cur + 1) == '/')) {
  ------------------
  |  Branch (771:9): [True: 291, False: 17]
  |  Branch (771:26): [True: 287, False: 4]
  ------------------
  772|    287|        cur += 2;
  773|    287|	ret = xmlParse3986Authority(uri, &cur);
  774|    287|	if (ret != 0) return(ret);
  ------------------
  |  Branch (774:6): [True: 0, False: 287]
  ------------------
  775|       |        /*
  776|       |         * An empty server is marked with a special URI value.
  777|       |         */
  778|    287|	if ((uri->server == NULL) && (uri->port == PORT_EMPTY))
  ------------------
  |  |   37|      2|#define PORT_EMPTY           0
  ------------------
  |  Branch (778:6): [True: 2, False: 285]
  |  Branch (778:31): [True: 2, False: 0]
  ------------------
  779|      2|	    uri->port = PORT_EMPTY_SERVER;
  ------------------
  |  |   38|      2|#define PORT_EMPTY_SERVER   -1
  ------------------
  780|    287|	ret = xmlParse3986PathAbEmpty(uri, &cur);
  781|    287|	if (ret != 0) return(ret);
  ------------------
  |  Branch (781:6): [True: 0, False: 287]
  ------------------
  782|    287|	*str = cur;
  783|    287|	return(0);
  784|    287|    } else if (*cur == '/') {
  ------------------
  |  Branch (784:16): [True: 4, False: 17]
  ------------------
  785|      4|        ret = xmlParse3986PathAbsolute(uri, &cur);
  786|      4|	if (ret != 0) return(ret);
  ------------------
  |  Branch (786:6): [True: 0, False: 4]
  ------------------
  787|     17|    } else if (ISA_PCHAR(cur)) {
  ------------------
  |  |  198|     17|     (ISA_UNRESERVED(p) || ISA_PCT_ENCODED(p) || ISA_SUB_DELIM(p) ||	\
  |  |  ------------------
  |  |  |  |  185|     34|      ((ISA_ALPHA(p)) || (ISA_DIGIT(p)) || ((*(p) == '-')) ||		\
  |  |  |  |  ------------------
  |  |  |  |  |  |  152|     17|#define ISA_ALPHA(p) (((*(p) >= 'a') && (*(p) <= 'z')) ||		\
  |  |  |  |  |  |  ------------------
  |  |  |  |  |  |  |  Branch (152:24): [True: 15, False: 2]
  |  |  |  |  |  |  |  Branch (152:41): [True: 15, False: 0]
  |  |  |  |  |  |  ------------------
  |  |  |  |  |  |  153|     17|                      ((*(p) >= 'A') && (*(p) <= 'Z')))
  |  |  |  |  |  |  ------------------
  |  |  |  |  |  |  |  Branch (153:24): [True: 0, False: 2]
  |  |  |  |  |  |  |  Branch (153:41): [True: 0, False: 0]
  |  |  |  |  |  |  ------------------
  |  |  |  |  ------------------
  |  |  |  |                     ((ISA_ALPHA(p)) || (ISA_DIGIT(p)) || ((*(p) == '-')) ||		\
  |  |  |  |  ------------------
  |  |  |  |  |  |  151|      2|#define ISA_DIGIT(p) ((*(p) >= '0') && (*(p) <= '9'))
  |  |  |  |  |  |  ------------------
  |  |  |  |  |  |  |  Branch (151:23): [True: 0, False: 2]
  |  |  |  |  |  |  |  Branch (151:40): [True: 0, False: 0]
  |  |  |  |  |  |  ------------------
  |  |  |  |  ------------------
  |  |  |  |  |  Branch (185:44): [True: 0, False: 2]
  |  |  |  |  ------------------
  |  |  |  |  186|     17|       ((*(p) == '.')) || ((*(p) == '_')) || ((*(p) == '~')))
  |  |  |  |  ------------------
  |  |  |  |  |  Branch (186:8): [True: 0, False: 2]
  |  |  |  |  |  Branch (186:27): [True: 0, False: 2]
  |  |  |  |  |  Branch (186:46): [True: 0, False: 2]
  |  |  |  |  ------------------
  |  |  ------------------
  |  |                    (ISA_UNRESERVED(p) || ISA_PCT_ENCODED(p) || ISA_SUB_DELIM(p) ||	\
  |  |  ------------------
  |  |  |  |  192|     19|     ((*(p) == '%') && (ISA_HEXDIG(p + 1)) && (ISA_HEXDIG(p + 2)))
  |  |  |  |  ------------------
  |  |  |  |  |  |  155|      0|       (ISA_DIGIT(p) || ((*(p) >= 'a') && (*(p) <= 'f')) ||		\
  |  |  |  |  |  |  ------------------
  |  |  |  |  |  |  |  |  151|      0|#define ISA_DIGIT(p) ((*(p) >= '0') && (*(p) <= '9'))
  |  |  |  |  |  |  |  |  ------------------
  |  |  |  |  |  |  |  |  |  Branch (151:23): [True: 0, False: 0]
  |  |  |  |  |  |  |  |  |  Branch (151:40): [True: 0, False: 0]
  |  |  |  |  |  |  |  |  ------------------
  |  |  |  |  |  |  ------------------
  |  |  |  |  |  |  |  Branch (155:26): [True: 0, False: 0]
  |  |  |  |  |  |  |  Branch (155:43): [True: 0, False: 0]
  |  |  |  |  |  |  ------------------
  |  |  |  |  |  |  156|      0|        ((*(p) >= 'A') && (*(p) <= 'F')))
  |  |  |  |  |  |  ------------------
  |  |  |  |  |  |  |  Branch (156:10): [True: 0, False: 0]
  |  |  |  |  |  |  |  Branch (156:27): [True: 0, False: 0]
  |  |  |  |  |  |  ------------------
  |  |  |  |  ------------------
  |  |  |  |                    ((*(p) == '%') && (ISA_HEXDIG(p + 1)) && (ISA_HEXDIG(p + 2)))
  |  |  |  |  ------------------
  |  |  |  |  |  |  155|      0|       (ISA_DIGIT(p) || ((*(p) >= 'a') && (*(p) <= 'f')) ||		\
  |  |  |  |  |  |  ------------------
  |  |  |  |  |  |  |  |  151|      0|#define ISA_DIGIT(p) ((*(p) >= '0') && (*(p) <= '9'))
  |  |  |  |  |  |  |  |  ------------------
  |  |  |  |  |  |  |  |  |  Branch (151:23): [True: 0, False: 0]
  |  |  |  |  |  |  |  |  |  Branch (151:40): [True: 0, False: 0]
  |  |  |  |  |  |  |  |  ------------------
  |  |  |  |  |  |  ------------------
  |  |  |  |  |  |  |  Branch (155:26): [True: 0, False: 0]
  |  |  |  |  |  |  |  Branch (155:43): [True: 0, False: 0]
  |  |  |  |  |  |  ------------------
  |  |  |  |  |  |  156|      0|        ((*(p) >= 'A') && (*(p) <= 'F')))
  |  |  |  |  |  |  ------------------
  |  |  |  |  |  |  |  Branch (156:10): [True: 0, False: 0]
  |  |  |  |  |  |  |  Branch (156:27): [True: 0, False: 0]
  |  |  |  |  |  |  ------------------
  |  |  |  |  ------------------
  |  |  |  |  |  Branch (192:7): [True: 0, False: 2]
  |  |  |  |  ------------------
  |  |  ------------------
  |  |                    (ISA_UNRESERVED(p) || ISA_PCT_ENCODED(p) || ISA_SUB_DELIM(p) ||	\
  |  |  ------------------
  |  |  |  |  163|     19|      (((*(p) == '!')) || ((*(p) == '$')) || ((*(p) == '&')) ||		\
  |  |  |  |  ------------------
  |  |  |  |  |  Branch (163:8): [True: 0, False: 2]
  |  |  |  |  |  Branch (163:27): [True: 0, False: 2]
  |  |  |  |  |  Branch (163:46): [True: 0, False: 2]
  |  |  |  |  ------------------
  |  |  |  |  164|      2|       ((*(p) == '(')) || ((*(p) == ')')) || ((*(p) == '*')) ||		\
  |  |  |  |  ------------------
  |  |  |  |  |  Branch (164:8): [True: 0, False: 2]
  |  |  |  |  |  Branch (164:27): [True: 0, False: 2]
  |  |  |  |  |  Branch (164:46): [True: 0, False: 2]
  |  |  |  |  ------------------
  |  |  |  |  165|      2|       ((*(p) == '+')) || ((*(p) == ',')) || ((*(p) == ';')) ||		\
  |  |  |  |  ------------------
  |  |  |  |  |  Branch (165:8): [True: 0, False: 2]
  |  |  |  |  |  Branch (165:27): [True: 0, False: 2]
  |  |  |  |  |  Branch (165:46): [True: 0, False: 2]
  |  |  |  |  ------------------
  |  |  |  |  166|      2|       ((*(p) == '=')) || ((*(p) == '\'')))
  |  |  |  |  ------------------
  |  |  |  |  |  Branch (166:8): [True: 0, False: 2]
  |  |  |  |  |  Branch (166:27): [True: 0, False: 2]
  |  |  |  |  ------------------
  |  |  ------------------
  |  |  199|     17|      ((*(p) == ':')) || ((*(p) == '@')))
  |  |  ------------------
  |  |  |  Branch (199:7): [True: 0, False: 2]
  |  |  |  Branch (199:26): [True: 0, False: 2]
  |  |  ------------------
  ------------------
  788|     15|        ret = xmlParse3986PathRootless(uri, &cur);
  789|     15|	if (ret != 0) return(ret);
  ------------------
  |  Branch (789:6): [True: 0, False: 15]
  ------------------
  790|     15|    } else {
  791|       |	/* path-empty is effectively empty */
  792|      2|	if (uri != NULL) {
  ------------------
  |  Branch (792:6): [True: 2, False: 0]
  ------------------
  793|      2|	    if (uri->path != NULL) xmlFree(uri->path);
  ------------------
  |  Branch (793:10): [True: 0, False: 2]
  ------------------
  794|      2|	    uri->path = NULL;
  795|      2|	}
  796|      2|    }
  797|     21|    *str = cur;
  798|     21|    return (0);
  799|    308|}
uri.c:xmlParse3986Authority:
  521|    287|{
  522|    287|    const char *cur;
  523|    287|    int ret;
  524|       |
  525|    287|    cur = *str;
  526|       |    /*
  527|       |     * try to parse an userinfo and check for the trailing @
  528|       |     */
  529|    287|    ret = xmlParse3986Userinfo(uri, &cur);
  530|    287|    if ((ret != 0) || (*cur != '@'))
  ------------------
  |  Branch (530:9): [True: 287, False: 0]
  |  Branch (530:23): [True: 0, False: 0]
  ------------------
  531|    287|        cur = *str;
  532|      0|    else
  533|      0|        cur++;
  534|    287|    ret = xmlParse3986Host(uri, &cur);
  535|    287|    if (ret != 0) return(ret);
  ------------------
  |  Branch (535:9): [True: 0, False: 287]
  ------------------
  536|    287|    if (*cur == ':') {
  ------------------
  |  Branch (536:9): [True: 0, False: 287]
  ------------------
  537|      0|        cur++;
  538|      0|        ret = xmlParse3986Port(uri, &cur);
  539|      0|	if (ret != 0) return(ret);
  ------------------
  |  Branch (539:6): [True: 0, False: 0]
  ------------------
  540|      0|    }
  541|    287|    *str = cur;
  542|    287|    return(0);
  543|    287|}
uri.c:xmlParse3986Userinfo:
  370|    287|{
  371|    287|    const char *cur;
  372|       |
  373|    287|    cur = *str;
  374|  3.05k|    while (ISA_UNRESERVED(cur) || ISA_PCT_ENCODED(cur) ||
  ------------------
  |  |  185|  6.11k|      ((ISA_ALPHA(p)) || (ISA_DIGIT(p)) || ((*(p) == '-')) ||		\
  |  |  ------------------
  |  |  |  |  152|  3.05k|#define ISA_ALPHA(p) (((*(p) >= 'a') && (*(p) <= 'z')) ||		\
  |  |  |  |  ------------------
  |  |  |  |  |  Branch (152:24): [True: 1.92k, False: 1.13k]
  |  |  |  |  |  Branch (152:41): [True: 1.92k, False: 0]
  |  |  |  |  ------------------
  |  |  |  |  153|  3.05k|                      ((*(p) >= 'A') && (*(p) <= 'Z')))
  |  |  |  |  ------------------
  |  |  |  |  |  Branch (153:24): [True: 4, False: 1.13k]
  |  |  |  |  |  Branch (153:41): [True: 4, False: 0]
  |  |  |  |  ------------------
  |  |  ------------------
  |  |                     ((ISA_ALPHA(p)) || (ISA_DIGIT(p)) || ((*(p) == '-')) ||		\
  |  |  ------------------
  |  |  |  |  151|  1.13k|#define ISA_DIGIT(p) ((*(p) >= '0') && (*(p) <= '9'))
  |  |  |  |  ------------------
  |  |  |  |  |  Branch (151:23): [True: 283, False: 851]
  |  |  |  |  |  Branch (151:40): [True: 283, False: 0]
  |  |  |  |  ------------------
  |  |  ------------------
  |  |  |  Branch (185:44): [True: 0, False: 851]
  |  |  ------------------
  |  |  186|  3.05k|       ((*(p) == '.')) || ((*(p) == '_')) || ((*(p) == '~')))
  |  |  ------------------
  |  |  |  Branch (186:8): [True: 562, False: 289]
  |  |  |  Branch (186:27): [True: 0, False: 289]
  |  |  |  Branch (186:46): [True: 0, False: 289]
  |  |  ------------------
  ------------------
                  while (ISA_UNRESERVED(cur) || ISA_PCT_ENCODED(cur) ||
  ------------------
  |  |  192|  3.34k|     ((*(p) == '%') && (ISA_HEXDIG(p + 1)) && (ISA_HEXDIG(p + 2)))
  |  |  ------------------
  |  |  |  |  155|      0|       (ISA_DIGIT(p) || ((*(p) >= 'a') && (*(p) <= 'f')) ||		\
  |  |  |  |  ------------------
  |  |  |  |  |  |  151|      0|#define ISA_DIGIT(p) ((*(p) >= '0') && (*(p) <= '9'))
  |  |  |  |  |  |  ------------------
  |  |  |  |  |  |  |  Branch (151:23): [True: 0, False: 0]
  |  |  |  |  |  |  |  Branch (151:40): [True: 0, False: 0]
  |  |  |  |  |  |  ------------------
  |  |  |  |  ------------------
  |  |  |  |  |  Branch (155:26): [True: 0, False: 0]
  |  |  |  |  |  Branch (155:43): [True: 0, False: 0]
  |  |  |  |  ------------------
  |  |  |  |  156|      0|        ((*(p) >= 'A') && (*(p) <= 'F')))
  |  |  |  |  ------------------
  |  |  |  |  |  Branch (156:10): [True: 0, False: 0]
  |  |  |  |  |  Branch (156:27): [True: 0, False: 0]
  |  |  |  |  ------------------
  |  |  ------------------
  |  |                    ((*(p) == '%') && (ISA_HEXDIG(p + 1)) && (ISA_HEXDIG(p + 2)))
  |  |  ------------------
  |  |  |  |  155|      0|       (ISA_DIGIT(p) || ((*(p) >= 'a') && (*(p) <= 'f')) ||		\
  |  |  |  |  ------------------
  |  |  |  |  |  |  151|      0|#define ISA_DIGIT(p) ((*(p) >= '0') && (*(p) <= '9'))
  |  |  |  |  |  |  ------------------
  |  |  |  |  |  |  |  Branch (151:23): [True: 0, False: 0]
  |  |  |  |  |  |  |  Branch (151:40): [True: 0, False: 0]
  |  |  |  |  |  |  ------------------
  |  |  |  |  ------------------
  |  |  |  |  |  Branch (155:26): [True: 0, False: 0]
  |  |  |  |  |  Branch (155:43): [True: 0, False: 0]
  |  |  |  |  ------------------
  |  |  |  |  156|      0|        ((*(p) >= 'A') && (*(p) <= 'F')))
  |  |  |  |  ------------------
  |  |  |  |  |  Branch (156:10): [True: 0, False: 0]
  |  |  |  |  |  Branch (156:27): [True: 0, False: 0]
  |  |  |  |  ------------------
  |  |  ------------------
  |  |  |  Branch (192:7): [True: 0, False: 289]
  |  |  ------------------
  ------------------
  375|  3.05k|           ISA_SUB_DELIM(cur) || (*cur == ':'))
  ------------------
  |  |  163|  3.34k|      (((*(p) == '!')) || ((*(p) == '$')) || ((*(p) == '&')) ||		\
  |  |  ------------------
  |  |  |  Branch (163:8): [True: 0, False: 289]
  |  |  |  Branch (163:27): [True: 0, False: 289]
  |  |  |  Branch (163:46): [True: 0, False: 289]
  |  |  ------------------
  |  |  164|    289|       ((*(p) == '(')) || ((*(p) == ')')) || ((*(p) == '*')) ||		\
  |  |  ------------------
  |  |  |  Branch (164:8): [True: 2, False: 287]
  |  |  |  Branch (164:27): [True: 0, False: 287]
  |  |  |  Branch (164:46): [True: 0, False: 287]
  |  |  ------------------
  |  |  165|    289|       ((*(p) == '+')) || ((*(p) == ',')) || ((*(p) == ';')) ||		\
  |  |  ------------------
  |  |  |  Branch (165:8): [True: 0, False: 287]
  |  |  |  Branch (165:27): [True: 0, False: 287]
  |  |  |  Branch (165:46): [True: 0, False: 287]
  |  |  ------------------
  |  |  166|    289|       ((*(p) == '=')) || ((*(p) == '\'')))
  |  |  ------------------
  |  |  |  Branch (166:8): [True: 0, False: 287]
  |  |  |  Branch (166:27): [True: 0, False: 287]
  |  |  ------------------
  ------------------
  |  Branch (375:34): [True: 0, False: 287]
  ------------------
  376|  2.77k|	NEXT(cur);
  ------------------
  |  |  131|  2.77k|#define NEXT(p) ((*p == '%')? p += 3 : p++)
  |  |  ------------------
  |  |  |  Branch (131:18): [True: 0, False: 2.77k]
  |  |  ------------------
  ------------------
  377|    287|    if (*cur == '@') {
  ------------------
  |  Branch (377:9): [True: 0, False: 287]
  ------------------
  378|      0|	if (uri != NULL) {
  ------------------
  |  Branch (378:6): [True: 0, False: 0]
  ------------------
  379|      0|	    if (uri->user != NULL) xmlFree(uri->user);
  ------------------
  |  Branch (379:10): [True: 0, False: 0]
  ------------------
  380|      0|	    if (uri->cleanup & 2)
  ------------------
  |  Branch (380:10): [True: 0, False: 0]
  ------------------
  381|      0|		uri->user = STRNDUP(*str, cur - *str);
  ------------------
  |  |  143|      0|#define STRNDUP(s, n) (char *) xmlStrndup((const xmlChar *)(s), (n))
  ------------------
  382|      0|	    else
  383|      0|		uri->user = xmlURIUnescapeString(*str, cur - *str, NULL);
  384|      0|	}
  385|      0|	*str = cur;
  386|      0|	return(0);
  387|      0|    }
  388|    287|    return(1);
  389|    287|}
uri.c:xmlParse3986Host:
  445|    287|{
  446|    287|    const char *cur = *str;
  447|    287|    const char *host;
  448|       |
  449|    287|    host = cur;
  450|       |    /*
  451|       |     * IPv6 and future addressing scheme are enclosed between brackets
  452|       |     */
  453|    287|    if (*cur == '[') {
  ------------------
  |  Branch (453:9): [True: 0, False: 287]
  ------------------
  454|      0|        cur++;
  455|      0|	while ((*cur != ']') && (*cur != 0))
  ------------------
  |  Branch (455:9): [True: 0, False: 0]
  |  Branch (455:26): [True: 0, False: 0]
  ------------------
  456|      0|	    cur++;
  457|      0|	if (*cur != ']')
  ------------------
  |  Branch (457:6): [True: 0, False: 0]
  ------------------
  458|      0|	    return(1);
  459|      0|	cur++;
  460|      0|	goto found;
  461|      0|    }
  462|       |    /*
  463|       |     * try to parse an IPv4
  464|       |     */
  465|    287|    if (ISA_DIGIT(cur)) {
  ------------------
  |  |  151|    287|#define ISA_DIGIT(p) ((*(p) >= '0') && (*(p) <= '9'))
  |  |  ------------------
  |  |  |  Branch (151:23): [True: 285, False: 2]
  |  |  |  Branch (151:40): [True: 0, False: 285]
  |  |  ------------------
  ------------------
  466|      0|        if (xmlParse3986DecOctet(&cur) != 0)
  ------------------
  |  Branch (466:13): [True: 0, False: 0]
  ------------------
  467|      0|	    goto not_ipv4;
  468|      0|	if (*cur != '.')
  ------------------
  |  Branch (468:6): [True: 0, False: 0]
  ------------------
  469|      0|	    goto not_ipv4;
  470|      0|	cur++;
  471|      0|        if (xmlParse3986DecOctet(&cur) != 0)
  ------------------
  |  Branch (471:13): [True: 0, False: 0]
  ------------------
  472|      0|	    goto not_ipv4;
  473|      0|	if (*cur != '.')
  ------------------
  |  Branch (473:6): [True: 0, False: 0]
  ------------------
  474|      0|	    goto not_ipv4;
  475|      0|        if (xmlParse3986DecOctet(&cur) != 0)
  ------------------
  |  Branch (475:13): [True: 0, False: 0]
  ------------------
  476|      0|	    goto not_ipv4;
  477|      0|	if (*cur != '.')
  ------------------
  |  Branch (477:6): [True: 0, False: 0]
  ------------------
  478|      0|	    goto not_ipv4;
  479|      0|        if (xmlParse3986DecOctet(&cur) != 0)
  ------------------
  |  Branch (479:13): [True: 0, False: 0]
  ------------------
  480|      0|	    goto not_ipv4;
  481|      0|	goto found;
  482|      0|not_ipv4:
  483|      0|        cur = *str;
  484|      0|    }
  485|       |    /*
  486|       |     * then this should be a hostname which can be empty
  487|       |     */
  488|  3.05k|    while (ISA_UNRESERVED(cur) || ISA_PCT_ENCODED(cur) || ISA_SUB_DELIM(cur))
  ------------------
  |  |  185|  6.11k|      ((ISA_ALPHA(p)) || (ISA_DIGIT(p)) || ((*(p) == '-')) ||		\
  |  |  ------------------
  |  |  |  |  152|  3.05k|#define ISA_ALPHA(p) (((*(p) >= 'a') && (*(p) <= 'z')) ||		\
  |  |  |  |  ------------------
  |  |  |  |  |  Branch (152:24): [True: 1.92k, False: 1.13k]
  |  |  |  |  |  Branch (152:41): [True: 1.92k, False: 0]
  |  |  |  |  ------------------
  |  |  |  |  153|  3.05k|                      ((*(p) >= 'A') && (*(p) <= 'Z')))
  |  |  |  |  ------------------
  |  |  |  |  |  Branch (153:24): [True: 4, False: 1.13k]
  |  |  |  |  |  Branch (153:41): [True: 4, False: 0]
  |  |  |  |  ------------------
  |  |  ------------------
  |  |                     ((ISA_ALPHA(p)) || (ISA_DIGIT(p)) || ((*(p) == '-')) ||		\
  |  |  ------------------
  |  |  |  |  151|  1.13k|#define ISA_DIGIT(p) ((*(p) >= '0') && (*(p) <= '9'))
  |  |  |  |  ------------------
  |  |  |  |  |  Branch (151:23): [True: 283, False: 851]
  |  |  |  |  |  Branch (151:40): [True: 283, False: 0]
  |  |  |  |  ------------------
  |  |  ------------------
  |  |  |  Branch (185:44): [True: 0, False: 851]
  |  |  ------------------
  |  |  186|  3.05k|       ((*(p) == '.')) || ((*(p) == '_')) || ((*(p) == '~')))
  |  |  ------------------
  |  |  |  Branch (186:8): [True: 562, False: 289]
  |  |  |  Branch (186:27): [True: 0, False: 289]
  |  |  |  Branch (186:46): [True: 0, False: 289]
  |  |  ------------------
  ------------------
                  while (ISA_UNRESERVED(cur) || ISA_PCT_ENCODED(cur) || ISA_SUB_DELIM(cur))
  ------------------
  |  |  192|  3.34k|     ((*(p) == '%') && (ISA_HEXDIG(p + 1)) && (ISA_HEXDIG(p + 2)))
  |  |  ------------------
  |  |  |  |  155|      0|       (ISA_DIGIT(p) || ((*(p) >= 'a') && (*(p) <= 'f')) ||		\
  |  |  |  |  ------------------
  |  |  |  |  |  |  151|      0|#define ISA_DIGIT(p) ((*(p) >= '0') && (*(p) <= '9'))
  |  |  |  |  |  |  ------------------
  |  |  |  |  |  |  |  Branch (151:23): [True: 0, False: 0]
  |  |  |  |  |  |  |  Branch (151:40): [True: 0, False: 0]
  |  |  |  |  |  |  ------------------
  |  |  |  |  ------------------
  |  |  |  |  |  Branch (155:26): [True: 0, False: 0]
  |  |  |  |  |  Branch (155:43): [True: 0, False: 0]
  |  |  |  |  ------------------
  |  |  |  |  156|      0|        ((*(p) >= 'A') && (*(p) <= 'F')))
  |  |  |  |  ------------------
  |  |  |  |  |  Branch (156:10): [True: 0, False: 0]
  |  |  |  |  |  Branch (156:27): [True: 0, False: 0]
  |  |  |  |  ------------------
  |  |  ------------------
  |  |                    ((*(p) == '%') && (ISA_HEXDIG(p + 1)) && (ISA_HEXDIG(p + 2)))
  |  |  ------------------
  |  |  |  |  155|      0|       (ISA_DIGIT(p) || ((*(p) >= 'a') && (*(p) <= 'f')) ||		\
  |  |  |  |  ------------------
  |  |  |  |  |  |  151|      0|#define ISA_DIGIT(p) ((*(p) >= '0') && (*(p) <= '9'))
  |  |  |  |  |  |  ------------------
  |  |  |  |  |  |  |  Branch (151:23): [True: 0, False: 0]
  |  |  |  |  |  |  |  Branch (151:40): [True: 0, False: 0]
  |  |  |  |  |  |  ------------------
  |  |  |  |  ------------------
  |  |  |  |  |  Branch (155:26): [True: 0, False: 0]
  |  |  |  |  |  Branch (155:43): [True: 0, False: 0]
  |  |  |  |  ------------------
  |  |  |  |  156|      0|        ((*(p) >= 'A') && (*(p) <= 'F')))
  |  |  |  |  ------------------
  |  |  |  |  |  Branch (156:10): [True: 0, False: 0]
  |  |  |  |  |  Branch (156:27): [True: 0, False: 0]
  |  |  |  |  ------------------
  |  |  ------------------
  |  |  |  Branch (192:7): [True: 0, False: 289]
  |  |  ------------------
  ------------------
                  while (ISA_UNRESERVED(cur) || ISA_PCT_ENCODED(cur) || ISA_SUB_DELIM(cur))
  ------------------
  |  |  163|    289|      (((*(p) == '!')) || ((*(p) == '$')) || ((*(p) == '&')) ||		\
  |  |  ------------------
  |  |  |  Branch (163:8): [True: 0, False: 289]
  |  |  |  Branch (163:27): [True: 0, False: 289]
  |  |  |  Branch (163:46): [True: 0, False: 289]
  |  |  ------------------
  |  |  164|    289|       ((*(p) == '(')) || ((*(p) == ')')) || ((*(p) == '*')) ||		\
  |  |  ------------------
  |  |  |  Branch (164:8): [True: 2, False: 287]
  |  |  |  Branch (164:27): [True: 0, False: 287]
  |  |  |  Branch (164:46): [True: 0, False: 287]
  |  |  ------------------
  |  |  165|    289|       ((*(p) == '+')) || ((*(p) == ',')) || ((*(p) == ';')) ||		\
  |  |  ------------------
  |  |  |  Branch (165:8): [True: 0, False: 287]
  |  |  |  Branch (165:27): [True: 0, False: 287]
  |  |  |  Branch (165:46): [True: 0, False: 287]
  |  |  ------------------
  |  |  166|    289|       ((*(p) == '=')) || ((*(p) == '\'')))
  |  |  ------------------
  |  |  |  Branch (166:8): [True: 0, False: 287]
  |  |  |  Branch (166:27): [True: 0, False: 287]
  |  |  ------------------
  ------------------
  489|  2.77k|        NEXT(cur);
  ------------------
  |  |  131|  3.05k|#define NEXT(p) ((*p == '%')? p += 3 : p++)
  |  |  ------------------
  |  |  |  Branch (131:18): [True: 0, False: 2.77k]
  |  |  ------------------
  ------------------
  490|    287|found:
  491|    287|    if (uri != NULL) {
  ------------------
  |  Branch (491:9): [True: 287, False: 0]
  ------------------
  492|    287|	if (uri->authority != NULL) xmlFree(uri->authority);
  ------------------
  |  Branch (492:6): [True: 0, False: 287]
  ------------------
  493|    287|	uri->authority = NULL;
  494|    287|	if (uri->server != NULL) xmlFree(uri->server);
  ------------------
  |  Branch (494:6): [True: 0, False: 287]
  ------------------
  495|    287|	if (cur != host) {
  ------------------
  |  Branch (495:6): [True: 285, False: 2]
  ------------------
  496|    285|	    if (uri->cleanup & 2)
  ------------------
  |  Branch (496:10): [True: 0, False: 285]
  ------------------
  497|      0|		uri->server = STRNDUP(host, cur - host);
  ------------------
  |  |  143|      0|#define STRNDUP(s, n) (char *) xmlStrndup((const xmlChar *)(s), (n))
  ------------------
  498|    285|	    else
  499|    285|		uri->server = xmlURIUnescapeString(host, cur - host, NULL);
  500|    285|	} else
  501|      2|	    uri->server = NULL;
  502|    287|    }
  503|    287|    *str = cur;
  504|    287|    return(0);
  505|    287|}
uri.c:xmlParse3986PathAbEmpty:
  592|    287|{
  593|    287|    const char *cur;
  594|    287|    int ret;
  595|       |
  596|    287|    cur = *str;
  597|       |
  598|    795|    while (*cur == '/') {
  ------------------
  |  Branch (598:12): [True: 508, False: 287]
  ------------------
  599|    508|        cur++;
  600|    508|	ret = xmlParse3986Segment(&cur, 0, 1);
  601|    508|	if (ret != 0) return(ret);
  ------------------
  |  Branch (601:6): [True: 0, False: 508]
  ------------------
  602|    508|    }
  603|    287|    if (uri != NULL) {
  ------------------
  |  Branch (603:9): [True: 287, False: 0]
  ------------------
  604|    287|	if (uri->path != NULL) xmlFree(uri->path);
  ------------------
  |  Branch (604:6): [True: 0, False: 287]
  ------------------
  605|    287|        if (*str != cur) {
  ------------------
  |  Branch (605:13): [True: 263, False: 24]
  ------------------
  606|    263|            if (uri->cleanup & 2)
  ------------------
  |  Branch (606:17): [True: 0, False: 263]
  ------------------
  607|      0|                uri->path = STRNDUP(*str, cur - *str);
  ------------------
  |  |  143|      0|#define STRNDUP(s, n) (char *) xmlStrndup((const xmlChar *)(s), (n))
  ------------------
  608|    263|            else
  609|    263|                uri->path = xmlURIUnescapeString(*str, cur - *str, NULL);
  610|    263|        } else {
  611|     24|            uri->path = NULL;
  612|     24|        }
  613|    287|    }
  614|    287|    *str = cur;
  615|    287|    return (0);
  616|    287|}
uri.c:xmlParse3986Segment:
  563|  2.51k|{
  564|  2.51k|    const char *cur;
  565|       |
  566|  2.51k|    cur = *str;
  567|  2.51k|    if (!ISA_PCHAR(cur)) {
  ------------------
  |  |  198|  2.51k|     (ISA_UNRESERVED(p) || ISA_PCT_ENCODED(p) || ISA_SUB_DELIM(p) ||	\
  |  |  ------------------
  |  |  |  |  185|  5.02k|      ((ISA_ALPHA(p)) || (ISA_DIGIT(p)) || ((*(p) == '-')) ||		\
  |  |  |  |  ------------------
  |  |  |  |  |  |  152|  2.51k|#define ISA_ALPHA(p) (((*(p) >= 'a') && (*(p) <= 'z')) ||		\
  |  |  |  |  |  |  ------------------
  |  |  |  |  |  |  |  Branch (152:24): [True: 1.69k, False: 824]
  |  |  |  |  |  |  |  Branch (152:41): [True: 1.69k, False: 0]
  |  |  |  |  |  |  ------------------
  |  |  |  |  |  |  153|  2.51k|                      ((*(p) >= 'A') && (*(p) <= 'Z')))
  |  |  |  |  |  |  ------------------
  |  |  |  |  |  |  |  Branch (153:24): [True: 242, False: 582]
  |  |  |  |  |  |  |  Branch (153:41): [True: 242, False: 0]
  |  |  |  |  |  |  ------------------
  |  |  |  |  ------------------
  |  |  |  |                     ((ISA_ALPHA(p)) || (ISA_DIGIT(p)) || ((*(p) == '-')) ||		\
  |  |  |  |  ------------------
  |  |  |  |  |  |  151|    582|#define ISA_DIGIT(p) ((*(p) >= '0') && (*(p) <= '9'))
  |  |  |  |  |  |  ------------------
  |  |  |  |  |  |  |  Branch (151:23): [True: 287, False: 295]
  |  |  |  |  |  |  |  Branch (151:40): [True: 283, False: 4]
  |  |  |  |  |  |  ------------------
  |  |  |  |  ------------------
  |  |  |  |  |  Branch (185:44): [True: 0, False: 299]
  |  |  |  |  ------------------
  |  |  |  |  186|  2.51k|       ((*(p) == '.')) || ((*(p) == '_')) || ((*(p) == '~')))
  |  |  |  |  ------------------
  |  |  |  |  |  Branch (186:8): [True: 289, False: 10]
  |  |  |  |  |  Branch (186:27): [True: 0, False: 10]
  |  |  |  |  |  Branch (186:46): [True: 0, False: 10]
  |  |  |  |  ------------------
  |  |  ------------------
  |  |                    (ISA_UNRESERVED(p) || ISA_PCT_ENCODED(p) || ISA_SUB_DELIM(p) ||	\
  |  |  ------------------
  |  |  |  |  192|  2.52k|     ((*(p) == '%') && (ISA_HEXDIG(p + 1)) && (ISA_HEXDIG(p + 2)))
  |  |  |  |  ------------------
  |  |  |  |  |  |  155|      0|       (ISA_DIGIT(p) || ((*(p) >= 'a') && (*(p) <= 'f')) ||		\
  |  |  |  |  |  |  ------------------
  |  |  |  |  |  |  |  |  151|      0|#define ISA_DIGIT(p) ((*(p) >= '0') && (*(p) <= '9'))
  |  |  |  |  |  |  |  |  ------------------
  |  |  |  |  |  |  |  |  |  Branch (151:23): [True: 0, False: 0]
  |  |  |  |  |  |  |  |  |  Branch (151:40): [True: 0, False: 0]
  |  |  |  |  |  |  |  |  ------------------
  |  |  |  |  |  |  ------------------
  |  |  |  |  |  |  |  Branch (155:26): [True: 0, False: 0]
  |  |  |  |  |  |  |  Branch (155:43): [True: 0, False: 0]
  |  |  |  |  |  |  ------------------
  |  |  |  |  |  |  156|      0|        ((*(p) >= 'A') && (*(p) <= 'F')))
  |  |  |  |  |  |  ------------------
  |  |  |  |  |  |  |  Branch (156:10): [True: 0, False: 0]
  |  |  |  |  |  |  |  Branch (156:27): [True: 0, False: 0]
  |  |  |  |  |  |  ------------------
  |  |  |  |  ------------------
  |  |  |  |                    ((*(p) == '%') && (ISA_HEXDIG(p + 1)) && (ISA_HEXDIG(p + 2)))
  |  |  |  |  ------------------
  |  |  |  |  |  |  155|      0|       (ISA_DIGIT(p) || ((*(p) >= 'a') && (*(p) <= 'f')) ||		\
  |  |  |  |  |  |  ------------------
  |  |  |  |  |  |  |  |  151|      0|#define ISA_DIGIT(p) ((*(p) >= '0') && (*(p) <= '9'))
  |  |  |  |  |  |  |  |  ------------------
  |  |  |  |  |  |  |  |  |  Branch (151:23): [True: 0, False: 0]
  |  |  |  |  |  |  |  |  |  Branch (151:40): [True: 0, False: 0]
  |  |  |  |  |  |  |  |  ------------------
  |  |  |  |  |  |  ------------------
  |  |  |  |  |  |  |  Branch (155:26): [True: 0, False: 0]
  |  |  |  |  |  |  |  Branch (155:43): [True: 0, False: 0]
  |  |  |  |  |  |  ------------------
  |  |  |  |  |  |  156|      0|        ((*(p) >= 'A') && (*(p) <= 'F')))
  |  |  |  |  |  |  ------------------
  |  |  |  |  |  |  |  Branch (156:10): [True: 0, False: 0]
  |  |  |  |  |  |  |  Branch (156:27): [True: 0, False: 0]
  |  |  |  |  |  |  ------------------
  |  |  |  |  ------------------
  |  |  |  |  |  Branch (192:7): [True: 0, False: 10]
  |  |  |  |  ------------------
  |  |  ------------------
  |  |                    (ISA_UNRESERVED(p) || ISA_PCT_ENCODED(p) || ISA_SUB_DELIM(p) ||	\
  |  |  ------------------
  |  |  |  |  163|  2.52k|      (((*(p) == '!')) || ((*(p) == '$')) || ((*(p) == '&')) ||		\
  |  |  |  |  ------------------
  |  |  |  |  |  Branch (163:8): [True: 0, False: 10]
  |  |  |  |  |  Branch (163:27): [True: 0, False: 10]
  |  |  |  |  |  Branch (163:46): [True: 0, False: 10]
  |  |  |  |  ------------------
  |  |  |  |  164|     10|       ((*(p) == '(')) || ((*(p) == ')')) || ((*(p) == '*')) ||		\
  |  |  |  |  ------------------
  |  |  |  |  |  Branch (164:8): [True: 0, False: 10]
  |  |  |  |  |  Branch (164:27): [True: 0, False: 10]
  |  |  |  |  |  Branch (164:46): [True: 0, False: 10]
  |  |  |  |  ------------------
  |  |  |  |  165|     10|       ((*(p) == '+')) || ((*(p) == ',')) || ((*(p) == ';')) ||		\
  |  |  |  |  ------------------
  |  |  |  |  |  Branch (165:8): [True: 0, False: 10]
  |  |  |  |  |  Branch (165:27): [True: 0, False: 10]
  |  |  |  |  |  Branch (165:46): [True: 0, False: 10]
  |  |  |  |  ------------------
  |  |  |  |  166|     10|       ((*(p) == '=')) || ((*(p) == '\'')))
  |  |  |  |  ------------------
  |  |  |  |  |  Branch (166:8): [True: 0, False: 10]
  |  |  |  |  |  Branch (166:27): [True: 4, False: 6]
  |  |  |  |  ------------------
  |  |  ------------------
  |  |  199|  2.51k|      ((*(p) == ':')) || ((*(p) == '@')))
  |  |  ------------------
  |  |  |  Branch (199:7): [True: 4, False: 2]
  |  |  |  Branch (199:26): [True: 0, False: 2]
  |  |  ------------------
  ------------------
  568|      2|        if (empty)
  ------------------
  |  Branch (568:13): [True: 2, False: 0]
  ------------------
  569|      2|	    return(0);
  570|      0|	return(1);
  571|      2|    }
  572|  23.3k|    while (ISA_PCHAR(cur) && (*cur != forbid))
  ------------------
  |  |  198|  46.7k|     (ISA_UNRESERVED(p) || ISA_PCT_ENCODED(p) || ISA_SUB_DELIM(p) ||	\
  |  |  ------------------
  |  |  |  |  185|  46.7k|      ((ISA_ALPHA(p)) || (ISA_DIGIT(p)) || ((*(p) == '-')) ||		\
  |  |  |  |  ------------------
  |  |  |  |  |  |  152|  23.3k|#define ISA_ALPHA(p) (((*(p) >= 'a') && (*(p) <= 'z')) ||		\
  |  |  |  |  |  |  ------------------
  |  |  |  |  |  |  |  Branch (152:24): [True: 15.6k, False: 7.66k]
  |  |  |  |  |  |  |  Branch (152:41): [True: 15.6k, False: 2]
  |  |  |  |  |  |  ------------------
  |  |  |  |  |  |  153|  23.3k|                      ((*(p) >= 'A') && (*(p) <= 'Z')))
  |  |  |  |  |  |  ------------------
  |  |  |  |  |  |  |  Branch (153:24): [True: 610, False: 7.05k]
  |  |  |  |  |  |  |  Branch (153:41): [True: 590, False: 20]
  |  |  |  |  |  |  ------------------
  |  |  |  |  ------------------
  |  |  |  |                     ((ISA_ALPHA(p)) || (ISA_DIGIT(p)) || ((*(p) == '-')) ||		\
  |  |  |  |  ------------------
  |  |  |  |  |  |  151|  7.07k|#define ISA_DIGIT(p) ((*(p) >= '0') && (*(p) <= '9'))
  |  |  |  |  |  |  ------------------
  |  |  |  |  |  |  |  Branch (151:23): [True: 2.15k, False: 4.92k]
  |  |  |  |  |  |  |  Branch (151:40): [True: 2.10k, False: 44]
  |  |  |  |  |  |  ------------------
  |  |  |  |  ------------------
  |  |  |  |  |  Branch (185:44): [True: 473, False: 4.49k]
  |  |  |  |  ------------------
  |  |  |  |  186|  23.3k|       ((*(p) == '.')) || ((*(p) == '_')) || ((*(p) == '~')))
  |  |  |  |  ------------------
  |  |  |  |  |  Branch (186:8): [True: 1.95k, False: 2.54k]
  |  |  |  |  |  Branch (186:27): [True: 14, False: 2.52k]
  |  |  |  |  |  Branch (186:46): [True: 2, False: 2.52k]
  |  |  |  |  ------------------
  |  |  ------------------
  |  |                    (ISA_UNRESERVED(p) || ISA_PCT_ENCODED(p) || ISA_SUB_DELIM(p) ||	\
  |  |  ------------------
  |  |  |  |  192|  25.8k|     ((*(p) == '%') && (ISA_HEXDIG(p + 1)) && (ISA_HEXDIG(p + 2)))
  |  |  |  |  ------------------
  |  |  |  |  |  |  155|      0|       (ISA_DIGIT(p) || ((*(p) >= 'a') && (*(p) <= 'f')) ||		\
  |  |  |  |  |  |  ------------------
  |  |  |  |  |  |  |  |  151|      0|#define ISA_DIGIT(p) ((*(p) >= '0') && (*(p) <= '9'))
  |  |  |  |  |  |  |  |  ------------------
  |  |  |  |  |  |  |  |  |  Branch (151:23): [True: 0, False: 0]
  |  |  |  |  |  |  |  |  |  Branch (151:40): [True: 0, False: 0]
  |  |  |  |  |  |  |  |  ------------------
  |  |  |  |  |  |  ------------------
  |  |  |  |  |  |  |  Branch (155:26): [True: 0, False: 0]
  |  |  |  |  |  |  |  Branch (155:43): [True: 0, False: 0]
  |  |  |  |  |  |  ------------------
  |  |  |  |  |  |  156|      0|        ((*(p) >= 'A') && (*(p) <= 'F')))
  |  |  |  |  |  |  ------------------
  |  |  |  |  |  |  |  Branch (156:10): [True: 0, False: 0]
  |  |  |  |  |  |  |  Branch (156:27): [True: 0, False: 0]
  |  |  |  |  |  |  ------------------
  |  |  |  |  ------------------
  |  |  |  |                    ((*(p) == '%') && (ISA_HEXDIG(p + 1)) && (ISA_HEXDIG(p + 2)))
  |  |  |  |  ------------------
  |  |  |  |  |  |  155|      0|       (ISA_DIGIT(p) || ((*(p) >= 'a') && (*(p) <= 'f')) ||		\
  |  |  |  |  |  |  ------------------
  |  |  |  |  |  |  |  |  151|      0|#define ISA_DIGIT(p) ((*(p) >= '0') && (*(p) <= '9'))
  |  |  |  |  |  |  |  |  ------------------
  |  |  |  |  |  |  |  |  |  Branch (151:23): [True: 0, False: 0]
  |  |  |  |  |  |  |  |  |  Branch (151:40): [True: 0, False: 0]
  |  |  |  |  |  |  |  |  ------------------
  |  |  |  |  |  |  ------------------
  |  |  |  |  |  |  |  Branch (155:26): [True: 0, False: 0]
  |  |  |  |  |  |  |  Branch (155:43): [True: 0, False: 0]
  |  |  |  |  |  |  ------------------
  |  |  |  |  |  |  156|      0|        ((*(p) >= 'A') && (*(p) <= 'F')))
  |  |  |  |  |  |  ------------------
  |  |  |  |  |  |  |  Branch (156:10): [True: 0, False: 0]
  |  |  |  |  |  |  |  Branch (156:27): [True: 0, False: 0]
  |  |  |  |  |  |  ------------------
  |  |  |  |  ------------------
  |  |  |  |  |  Branch (192:7): [True: 0, False: 2.52k]
  |  |  |  |  ------------------
  |  |  ------------------
  |  |                    (ISA_UNRESERVED(p) || ISA_PCT_ENCODED(p) || ISA_SUB_DELIM(p) ||	\
  |  |  ------------------
  |  |  |  |  163|  25.8k|      (((*(p) == '!')) || ((*(p) == '$')) || ((*(p) == '&')) ||		\
  |  |  |  |  ------------------
  |  |  |  |  |  Branch (163:8): [True: 0, False: 2.52k]
  |  |  |  |  |  Branch (163:27): [True: 0, False: 2.52k]
  |  |  |  |  |  Branch (163:46): [True: 0, False: 2.52k]
  |  |  |  |  ------------------
  |  |  |  |  164|  2.52k|       ((*(p) == '(')) || ((*(p) == ')')) || ((*(p) == '*')) ||		\
  |  |  |  |  ------------------
  |  |  |  |  |  Branch (164:8): [True: 0, False: 2.52k]
  |  |  |  |  |  Branch (164:27): [True: 0, False: 2.52k]
  |  |  |  |  |  Branch (164:46): [True: 0, False: 2.52k]
  |  |  |  |  ------------------
  |  |  |  |  165|  2.52k|       ((*(p) == '+')) || ((*(p) == ',')) || ((*(p) == ';')) ||		\
  |  |  |  |  ------------------
  |  |  |  |  |  Branch (165:8): [True: 0, False: 2.52k]
  |  |  |  |  |  Branch (165:27): [True: 0, False: 2.52k]
  |  |  |  |  |  Branch (165:46): [True: 2, False: 2.52k]
  |  |  |  |  ------------------
  |  |  |  |  166|  2.52k|       ((*(p) == '=')) || ((*(p) == '\'')))
  |  |  |  |  ------------------
  |  |  |  |  |  Branch (166:8): [True: 2, False: 2.52k]
  |  |  |  |  |  Branch (166:27): [True: 4, False: 2.51k]
  |  |  |  |  ------------------
  |  |  ------------------
  |  |  199|  23.3k|      ((*(p) == ':')) || ((*(p) == '@')))
  |  |  ------------------
  |  |  |  Branch (199:7): [True: 18, False: 2.49k]
  |  |  |  Branch (199:26): [True: 0, False: 2.49k]
  |  |  ------------------
  ------------------
  |  Branch (572:30): [True: 20.8k, False: 14]
  ------------------
  573|  20.8k|        NEXT(cur);
  ------------------
  |  |  131|  23.3k|#define NEXT(p) ((*p == '%')? p += 3 : p++)
  |  |  ------------------
  |  |  |  Branch (131:18): [True: 0, False: 20.8k]
  |  |  ------------------
  ------------------
  574|  2.51k|    *str = cur;
  575|  2.51k|    return (0);
  576|  2.51k|}
uri.c:xmlParse3986PathAbsolute:
  632|      4|{
  633|      4|    const char *cur;
  634|      4|    int ret;
  635|       |
  636|      4|    cur = *str;
  637|       |
  638|      4|    if (*cur != '/')
  ------------------
  |  Branch (638:9): [True: 0, False: 4]
  ------------------
  639|      0|        return(1);
  640|      4|    cur++;
  641|      4|    ret = xmlParse3986Segment(&cur, 0, 0);
  642|      4|    if (ret == 0) {
  ------------------
  |  Branch (642:9): [True: 4, False: 0]
  ------------------
  643|      4|	while (*cur == '/') {
  ------------------
  |  Branch (643:9): [True: 0, False: 4]
  ------------------
  644|      0|	    cur++;
  645|      0|	    ret = xmlParse3986Segment(&cur, 0, 1);
  646|      0|	    if (ret != 0) return(ret);
  ------------------
  |  Branch (646:10): [True: 0, False: 0]
  ------------------
  647|      0|	}
  648|      4|    }
  649|      4|    if (uri != NULL) {
  ------------------
  |  Branch (649:9): [True: 4, False: 0]
  ------------------
  650|      4|	if (uri->path != NULL) xmlFree(uri->path);
  ------------------
  |  Branch (650:6): [True: 0, False: 4]
  ------------------
  651|      4|        if (cur != *str) {
  ------------------
  |  Branch (651:13): [True: 4, False: 0]
  ------------------
  652|      4|            if (uri->cleanup & 2)
  ------------------
  |  Branch (652:17): [True: 0, False: 4]
  ------------------
  653|      0|                uri->path = STRNDUP(*str, cur - *str);
  ------------------
  |  |  143|      0|#define STRNDUP(s, n) (char *) xmlStrndup((const xmlChar *)(s), (n))
  ------------------
  654|      4|            else
  655|      4|                uri->path = xmlURIUnescapeString(*str, cur - *str, NULL);
  656|      4|        } else {
  657|      0|            uri->path = NULL;
  658|      0|        }
  659|      4|    }
  660|      4|    *str = cur;
  661|      4|    return (0);
  662|      4|}
uri.c:xmlParse3986PathRootless:
  678|     15|{
  679|     15|    const char *cur;
  680|     15|    int ret;
  681|       |
  682|     15|    cur = *str;
  683|       |
  684|     15|    ret = xmlParse3986Segment(&cur, 0, 0);
  685|     15|    if (ret != 0) return(ret);
  ------------------
  |  Branch (685:9): [True: 0, False: 15]
  ------------------
  686|     15|    while (*cur == '/') {
  ------------------
  |  Branch (686:12): [True: 0, False: 15]
  ------------------
  687|      0|        cur++;
  688|      0|	ret = xmlParse3986Segment(&cur, 0, 1);
  689|      0|	if (ret != 0) return(ret);
  ------------------
  |  Branch (689:6): [True: 0, False: 0]
  ------------------
  690|      0|    }
  691|     15|    if (uri != NULL) {
  ------------------
  |  Branch (691:9): [True: 15, False: 0]
  ------------------
  692|     15|	if (uri->path != NULL) xmlFree(uri->path);
  ------------------
  |  Branch (692:6): [True: 0, False: 15]
  ------------------
  693|     15|        if (cur != *str) {
  ------------------
  |  Branch (693:13): [True: 15, False: 0]
  ------------------
  694|     15|            if (uri->cleanup & 2)
  ------------------
  |  Branch (694:17): [True: 0, False: 15]
  ------------------
  695|      0|                uri->path = STRNDUP(*str, cur - *str);
  ------------------
  |  |  143|      0|#define STRNDUP(s, n) (char *) xmlStrndup((const xmlChar *)(s), (n))
  ------------------
  696|     15|            else
  697|     15|                uri->path = xmlURIUnescapeString(*str, cur - *str, NULL);
  698|     15|        } else {
  699|      0|            uri->path = NULL;
  700|      0|        }
  701|     15|    }
  702|     15|    *str = cur;
  703|     15|    return (0);
  704|     15|}
uri.c:xmlParse3986Fragment:
  250|     76|{
  251|     76|    const char *cur;
  252|       |
  253|     76|    if (str == NULL)
  ------------------
  |  Branch (253:9): [True: 0, False: 76]
  ------------------
  254|      0|        return (-1);
  255|       |
  256|     76|    cur = *str;
  257|       |
  258|  1.03k|    while ((ISA_PCHAR(cur)) || (*cur == '/') || (*cur == '?') ||
  ------------------
  |  |  198|  1.03k|     (ISA_UNRESERVED(p) || ISA_PCT_ENCODED(p) || ISA_SUB_DELIM(p) ||	\
  |  |  ------------------
  |  |  |  |  185|  2.06k|      ((ISA_ALPHA(p)) || (ISA_DIGIT(p)) || ((*(p) == '-')) ||		\
  |  |  |  |  ------------------
  |  |  |  |  |  |  152|  1.03k|#define ISA_ALPHA(p) (((*(p) >= 'a') && (*(p) <= 'z')) ||		\
  |  |  |  |  |  |  ------------------
  |  |  |  |  |  |  |  Branch (152:24): [True: 620, False: 412]
  |  |  |  |  |  |  |  Branch (152:41): [True: 620, False: 0]
  |  |  |  |  |  |  ------------------
  |  |  |  |  |  |  153|  1.03k|                      ((*(p) >= 'A') && (*(p) <= 'Z')))
  |  |  |  |  |  |  ------------------
  |  |  |  |  |  |  |  Branch (153:24): [True: 16, False: 396]
  |  |  |  |  |  |  |  Branch (153:41): [True: 0, False: 16]
  |  |  |  |  |  |  ------------------
  |  |  |  |  ------------------
  |  |  |  |                     ((ISA_ALPHA(p)) || (ISA_DIGIT(p)) || ((*(p) == '-')) ||		\
  |  |  |  |  ------------------
  |  |  |  |  |  |  151|    412|#define ISA_DIGIT(p) ((*(p) >= '0') && (*(p) <= '9'))
  |  |  |  |  |  |  ------------------
  |  |  |  |  |  |  |  Branch (151:23): [True: 64, False: 348]
  |  |  |  |  |  |  |  Branch (151:40): [True: 48, False: 16]
  |  |  |  |  |  |  ------------------
  |  |  |  |  ------------------
  |  |  |  |  |  Branch (185:44): [True: 0, False: 364]
  |  |  |  |  ------------------
  |  |  |  |  186|  1.03k|       ((*(p) == '.')) || ((*(p) == '_')) || ((*(p) == '~')))
  |  |  |  |  ------------------
  |  |  |  |  |  Branch (186:8): [True: 0, False: 364]
  |  |  |  |  |  Branch (186:27): [True: 0, False: 364]
  |  |  |  |  |  Branch (186:46): [True: 0, False: 364]
  |  |  |  |  ------------------
  |  |  ------------------
  |  |                    (ISA_UNRESERVED(p) || ISA_PCT_ENCODED(p) || ISA_SUB_DELIM(p) ||	\
  |  |  ------------------
  |  |  |  |  192|  1.39k|     ((*(p) == '%') && (ISA_HEXDIG(p + 1)) && (ISA_HEXDIG(p + 2)))
  |  |  |  |  ------------------
  |  |  |  |  |  |  155|      0|       (ISA_DIGIT(p) || ((*(p) >= 'a') && (*(p) <= 'f')) ||		\
  |  |  |  |  |  |  ------------------
  |  |  |  |  |  |  |  |  151|      0|#define ISA_DIGIT(p) ((*(p) >= '0') && (*(p) <= '9'))
  |  |  |  |  |  |  |  |  ------------------
  |  |  |  |  |  |  |  |  |  Branch (151:23): [True: 0, False: 0]
  |  |  |  |  |  |  |  |  |  Branch (151:40): [True: 0, False: 0]
  |  |  |  |  |  |  |  |  ------------------
  |  |  |  |  |  |  ------------------
  |  |  |  |  |  |  |  Branch (155:26): [True: 0, False: 0]
  |  |  |  |  |  |  |  Branch (155:43): [True: 0, False: 0]
  |  |  |  |  |  |  ------------------
  |  |  |  |  |  |  156|      0|        ((*(p) >= 'A') && (*(p) <= 'F')))
  |  |  |  |  |  |  ------------------
  |  |  |  |  |  |  |  Branch (156:10): [True: 0, False: 0]
  |  |  |  |  |  |  |  Branch (156:27): [True: 0, False: 0]
  |  |  |  |  |  |  ------------------
  |  |  |  |  ------------------
  |  |  |  |                    ((*(p) == '%') && (ISA_HEXDIG(p + 1)) && (ISA_HEXDIG(p + 2)))
  |  |  |  |  ------------------
  |  |  |  |  |  |  155|      0|       (ISA_DIGIT(p) || ((*(p) >= 'a') && (*(p) <= 'f')) ||		\
  |  |  |  |  |  |  ------------------
  |  |  |  |  |  |  |  |  151|      0|#define ISA_DIGIT(p) ((*(p) >= '0') && (*(p) <= '9'))
  |  |  |  |  |  |  |  |  ------------------
  |  |  |  |  |  |  |  |  |  Branch (151:23): [True: 0, False: 0]
  |  |  |  |  |  |  |  |  |  Branch (151:40): [True: 0, False: 0]
  |  |  |  |  |  |  |  |  ------------------
  |  |  |  |  |  |  ------------------
  |  |  |  |  |  |  |  Branch (155:26): [True: 0, False: 0]
  |  |  |  |  |  |  |  Branch (155:43): [True: 0, False: 0]
  |  |  |  |  |  |  ------------------
  |  |  |  |  |  |  156|      0|        ((*(p) >= 'A') && (*(p) <= 'F')))
  |  |  |  |  |  |  ------------------
  |  |  |  |  |  |  |  Branch (156:10): [True: 0, False: 0]
  |  |  |  |  |  |  |  Branch (156:27): [True: 0, False: 0]
  |  |  |  |  |  |  ------------------
  |  |  |  |  ------------------
  |  |  |  |  |  Branch (192:7): [True: 0, False: 364]
  |  |  |  |  ------------------
  |  |  ------------------
  |  |                    (ISA_UNRESERVED(p) || ISA_PCT_ENCODED(p) || ISA_SUB_DELIM(p) ||	\
  |  |  ------------------
  |  |  |  |  163|  1.39k|      (((*(p) == '!')) || ((*(p) == '$')) || ((*(p) == '&')) ||		\
  |  |  |  |  ------------------
  |  |  |  |  |  Branch (163:8): [True: 0, False: 364]
  |  |  |  |  |  Branch (163:27): [True: 0, False: 364]
  |  |  |  |  |  Branch (163:46): [True: 0, False: 364]
  |  |  |  |  ------------------
  |  |  |  |  164|    364|       ((*(p) == '(')) || ((*(p) == ')')) || ((*(p) == '*')) ||		\
  |  |  |  |  ------------------
  |  |  |  |  |  Branch (164:8): [True: 72, False: 292]
  |  |  |  |  |  Branch (164:27): [True: 104, False: 188]
  |  |  |  |  |  Branch (164:46): [True: 0, False: 188]
  |  |  |  |  ------------------
  |  |  |  |  165|    364|       ((*(p) == '+')) || ((*(p) == ',')) || ((*(p) == ';')) ||		\
  |  |  |  |  ------------------
  |  |  |  |  |  Branch (165:8): [True: 0, False: 188]
  |  |  |  |  |  Branch (165:27): [True: 0, False: 188]
  |  |  |  |  |  Branch (165:46): [True: 0, False: 188]
  |  |  |  |  ------------------
  |  |  |  |  166|    364|       ((*(p) == '=')) || ((*(p) == '\'')))
  |  |  |  |  ------------------
  |  |  |  |  |  Branch (166:8): [True: 0, False: 188]
  |  |  |  |  |  Branch (166:27): [True: 0, False: 188]
  |  |  |  |  ------------------
  |  |  ------------------
  |  |  199|  1.03k|      ((*(p) == ':')) || ((*(p) == '@')))
  |  |  ------------------
  |  |  |  Branch (199:7): [True: 0, False: 188]
  |  |  |  Branch (199:26): [True: 0, False: 188]
  |  |  ------------------
  ------------------
  |  Branch (258:32): [True: 96, False: 92]
  |  Branch (258:49): [True: 0, False: 92]
  ------------------
  259|  1.03k|           (*cur == '[') || (*cur == ']') ||
  ------------------
  |  Branch (259:12): [True: 8, False: 84]
  |  Branch (259:29): [True: 8, False: 76]
  ------------------
  260|  1.03k|           ((uri != NULL) && (uri->cleanup & 1) && (IS_UNWISE(cur))))
  ------------------
  |  |  108|      0|      (((*(p) == '{')) || ((*(p) == '}')) || ((*(p) == '|')) ||         \
  |  |  ------------------
  |  |  |  Branch (108:8): [True: 0, False: 0]
  |  |  |  Branch (108:27): [True: 0, False: 0]
  |  |  |  Branch (108:46): [True: 0, False: 0]
  |  |  ------------------
  |  |  109|      0|       ((*(p) == '\\')) || ((*(p) == '^')) || ((*(p) == '[')) ||        \
  |  |  ------------------
  |  |  |  Branch (109:8): [True: 0, False: 0]
  |  |  |  Branch (109:28): [True: 0, False: 0]
  |  |  |  Branch (109:47): [True: 0, False: 0]
  |  |  ------------------
  |  |  110|      0|       ((*(p) == ']')) || ((*(p) == '`')))
  |  |  ------------------
  |  |  |  Branch (110:8): [True: 0, False: 0]
  |  |  |  Branch (110:27): [True: 0, False: 0]
  |  |  ------------------
  ------------------
  |  Branch (260:13): [True: 76, False: 0]
  |  Branch (260:30): [True: 0, False: 76]
  ------------------
  261|    956|        NEXT(cur);
  ------------------
  |  |  131|  1.03k|#define NEXT(p) ((*p == '%')? p += 3 : p++)
  |  |  ------------------
  |  |  |  Branch (131:18): [True: 0, False: 956]
  |  |  ------------------
  ------------------
  262|     76|    if (uri != NULL) {
  ------------------
  |  Branch (262:9): [True: 76, False: 0]
  ------------------
  263|     76|        if (uri->fragment != NULL)
  ------------------
  |  Branch (263:13): [True: 0, False: 76]
  ------------------
  264|      0|            xmlFree(uri->fragment);
  265|     76|	if (uri->cleanup & 2)
  ------------------
  |  Branch (265:6): [True: 0, False: 76]
  ------------------
  266|      0|	    uri->fragment = STRNDUP(*str, cur - *str);
  ------------------
  |  |  143|      0|#define STRNDUP(s, n) (char *) xmlStrndup((const xmlChar *)(s), (n))
  ------------------
  267|     76|	else
  268|     76|	    uri->fragment = xmlURIUnescapeString(*str, cur - *str, NULL);
  269|     76|    }
  270|     76|    *str = cur;
  271|     76|    return (0);
  272|     76|}
uri.c:xmlParse3986RelativeRef:
  818|  1.51k|xmlParse3986RelativeRef(xmlURIPtr uri, const char *str) {
  819|  1.51k|    int ret;
  820|       |
  821|  1.51k|    if ((*str == '/') && (*(str + 1) == '/')) {
  ------------------
  |  Branch (821:9): [True: 0, False: 1.51k]
  |  Branch (821:26): [True: 0, False: 0]
  ------------------
  822|      0|        str += 2;
  823|      0|	ret = xmlParse3986Authority(uri, &str);
  824|      0|	if (ret != 0) return(ret);
  ------------------
  |  Branch (824:6): [True: 0, False: 0]
  ------------------
  825|      0|	ret = xmlParse3986PathAbEmpty(uri, &str);
  826|      0|	if (ret != 0) return(ret);
  ------------------
  |  Branch (826:6): [True: 0, False: 0]
  ------------------
  827|  1.51k|    } else if (*str == '/') {
  ------------------
  |  Branch (827:16): [True: 0, False: 1.51k]
  ------------------
  828|      0|	ret = xmlParse3986PathAbsolute(uri, &str);
  829|      0|	if (ret != 0) return(ret);
  ------------------
  |  Branch (829:6): [True: 0, False: 0]
  ------------------
  830|  1.51k|    } else if (ISA_PCHAR(str)) {
  ------------------
  |  |  198|  1.51k|     (ISA_UNRESERVED(p) || ISA_PCT_ENCODED(p) || ISA_SUB_DELIM(p) ||	\
  |  |  ------------------
  |  |  |  |  185|  3.03k|      ((ISA_ALPHA(p)) || (ISA_DIGIT(p)) || ((*(p) == '-')) ||		\
  |  |  |  |  ------------------
  |  |  |  |  |  |  152|  1.51k|#define ISA_ALPHA(p) (((*(p) >= 'a') && (*(p) <= 'z')) ||		\
  |  |  |  |  |  |  ------------------
  |  |  |  |  |  |  |  Branch (152:24): [True: 1.09k, False: 421]
  |  |  |  |  |  |  |  Branch (152:41): [True: 1.09k, False: 0]
  |  |  |  |  |  |  ------------------
  |  |  |  |  |  |  153|  1.51k|                      ((*(p) >= 'A') && (*(p) <= 'Z')))
  |  |  |  |  |  |  ------------------
  |  |  |  |  |  |  |  Branch (153:24): [True: 2, False: 419]
  |  |  |  |  |  |  |  Branch (153:41): [True: 2, False: 0]
  |  |  |  |  |  |  ------------------
  |  |  |  |  ------------------
  |  |  |  |                     ((ISA_ALPHA(p)) || (ISA_DIGIT(p)) || ((*(p) == '-')) ||		\
  |  |  |  |  ------------------
  |  |  |  |  |  |  151|    419|#define ISA_DIGIT(p) ((*(p) >= '0') && (*(p) <= '9'))
  |  |  |  |  |  |  ------------------
  |  |  |  |  |  |  |  Branch (151:23): [True: 28, False: 391]
  |  |  |  |  |  |  |  Branch (151:40): [True: 28, False: 0]
  |  |  |  |  |  |  ------------------
  |  |  |  |  ------------------
  |  |  |  |  |  Branch (185:44): [True: 0, False: 391]
  |  |  |  |  ------------------
  |  |  |  |  186|  1.51k|       ((*(p) == '.')) || ((*(p) == '_')) || ((*(p) == '~')))
  |  |  |  |  ------------------
  |  |  |  |  |  Branch (186:8): [True: 289, False: 102]
  |  |  |  |  |  Branch (186:27): [True: 0, False: 102]
  |  |  |  |  |  Branch (186:46): [True: 0, False: 102]
  |  |  |  |  ------------------
  |  |  ------------------
  |  |                    (ISA_UNRESERVED(p) || ISA_PCT_ENCODED(p) || ISA_SUB_DELIM(p) ||	\
  |  |  ------------------
  |  |  |  |  192|  1.62k|     ((*(p) == '%') && (ISA_HEXDIG(p + 1)) && (ISA_HEXDIG(p + 2)))
  |  |  |  |  ------------------
  |  |  |  |  |  |  155|      0|       (ISA_DIGIT(p) || ((*(p) >= 'a') && (*(p) <= 'f')) ||		\
  |  |  |  |  |  |  ------------------
  |  |  |  |  |  |  |  |  151|      0|#define ISA_DIGIT(p) ((*(p) >= '0') && (*(p) <= '9'))
  |  |  |  |  |  |  |  |  ------------------
  |  |  |  |  |  |  |  |  |  Branch (151:23): [True: 0, False: 0]
  |  |  |  |  |  |  |  |  |  Branch (151:40): [True: 0, False: 0]
  |  |  |  |  |  |  |  |  ------------------
  |  |  |  |  |  |  ------------------
  |  |  |  |  |  |  |  Branch (155:26): [True: 0, False: 0]
  |  |  |  |  |  |  |  Branch (155:43): [True: 0, False: 0]
  |  |  |  |  |  |  ------------------
  |  |  |  |  |  |  156|      0|        ((*(p) >= 'A') && (*(p) <= 'F')))
  |  |  |  |  |  |  ------------------
  |  |  |  |  |  |  |  Branch (156:10): [True: 0, False: 0]
  |  |  |  |  |  |  |  Branch (156:27): [True: 0, False: 0]
  |  |  |  |  |  |  ------------------
  |  |  |  |  ------------------
  |  |  |  |                    ((*(p) == '%') && (ISA_HEXDIG(p + 1)) && (ISA_HEXDIG(p + 2)))
  |  |  |  |  ------------------
  |  |  |  |  |  |  155|      0|       (ISA_DIGIT(p) || ((*(p) >= 'a') && (*(p) <= 'f')) ||		\
  |  |  |  |  |  |  ------------------
  |  |  |  |  |  |  |  |  151|      0|#define ISA_DIGIT(p) ((*(p) >= '0') && (*(p) <= '9'))
  |  |  |  |  |  |  |  |  ------------------
  |  |  |  |  |  |  |  |  |  Branch (151:23): [True: 0, False: 0]
  |  |  |  |  |  |  |  |  |  Branch (151:40): [True: 0, False: 0]
  |  |  |  |  |  |  |  |  ------------------
  |  |  |  |  |  |  ------------------
  |  |  |  |  |  |  |  Branch (155:26): [True: 0, False: 0]
  |  |  |  |  |  |  |  Branch (155:43): [True: 0, False: 0]
  |  |  |  |  |  |  ------------------
  |  |  |  |  |  |  156|      0|        ((*(p) >= 'A') && (*(p) <= 'F')))
  |  |  |  |  |  |  ------------------
  |  |  |  |  |  |  |  Branch (156:10): [True: 0, False: 0]
  |  |  |  |  |  |  |  Branch (156:27): [True: 0, False: 0]
  |  |  |  |  |  |  ------------------
  |  |  |  |  ------------------
  |  |  |  |  |  Branch (192:7): [True: 0, False: 102]
  |  |  |  |  ------------------
  |  |  ------------------
  |  |                    (ISA_UNRESERVED(p) || ISA_PCT_ENCODED(p) || ISA_SUB_DELIM(p) ||	\
  |  |  ------------------
  |  |  |  |  163|  1.62k|      (((*(p) == '!')) || ((*(p) == '$')) || ((*(p) == '&')) ||		\
  |  |  |  |  ------------------
  |  |  |  |  |  Branch (163:8): [True: 0, False: 102]
  |  |  |  |  |  Branch (163:27): [True: 0, False: 102]
  |  |  |  |  |  Branch (163:46): [True: 0, False: 102]
  |  |  |  |  ------------------
  |  |  |  |  164|    102|       ((*(p) == '(')) || ((*(p) == ')')) || ((*(p) == '*')) ||		\
  |  |  |  |  ------------------
  |  |  |  |  |  Branch (164:8): [True: 0, False: 102]
  |  |  |  |  |  Branch (164:27): [True: 0, False: 102]
  |  |  |  |  |  Branch (164:46): [True: 0, False: 102]
  |  |  |  |  ------------------
  |  |  |  |  165|    102|       ((*(p) == '+')) || ((*(p) == ',')) || ((*(p) == ';')) ||		\
  |  |  |  |  ------------------
  |  |  |  |  |  Branch (165:8): [True: 0, False: 102]
  |  |  |  |  |  Branch (165:27): [True: 0, False: 102]
  |  |  |  |  |  Branch (165:46): [True: 0, False: 102]
  |  |  |  |  ------------------
  |  |  |  |  166|    102|       ((*(p) == '=')) || ((*(p) == '\'')))
  |  |  |  |  ------------------
  |  |  |  |  |  Branch (166:8): [True: 0, False: 102]
  |  |  |  |  |  Branch (166:27): [True: 0, False: 102]
  |  |  |  |  ------------------
  |  |  ------------------
  |  |  199|  1.51k|      ((*(p) == ':')) || ((*(p) == '@')))
  |  |  ------------------
  |  |  |  Branch (199:7): [True: 0, False: 102]
  |  |  |  Branch (199:26): [True: 0, False: 102]
  |  |  ------------------
  ------------------
  831|  1.41k|        ret = xmlParse3986PathNoScheme(uri, &str);
  832|  1.41k|	if (ret != 0) return(ret);
  ------------------
  |  Branch (832:6): [True: 0, False: 1.41k]
  ------------------
  833|  1.41k|    } else {
  834|       |	/* path-empty is effectively empty */
  835|    102|	if (uri != NULL) {
  ------------------
  |  Branch (835:6): [True: 102, False: 0]
  ------------------
  836|    102|	    if (uri->path != NULL) xmlFree(uri->path);
  ------------------
  |  Branch (836:10): [True: 0, False: 102]
  ------------------
  837|    102|	    uri->path = NULL;
  838|    102|	}
  839|    102|    }
  840|       |
  841|  1.51k|    if (*str == '?') {
  ------------------
  |  Branch (841:9): [True: 0, False: 1.51k]
  ------------------
  842|      0|	str++;
  843|      0|	ret = xmlParse3986Query(uri, &str);
  844|      0|	if (ret != 0) return(ret);
  ------------------
  |  Branch (844:6): [True: 0, False: 0]
  ------------------
  845|      0|    }
  846|  1.51k|    if (*str == '#') {
  ------------------
  |  Branch (846:9): [True: 76, False: 1.44k]
  ------------------
  847|     76|	str++;
  848|     76|	ret = xmlParse3986Fragment(uri, &str);
  849|     76|	if (ret != 0) return(ret);
  ------------------
  |  Branch (849:6): [True: 0, False: 76]
  ------------------
  850|     76|    }
  851|  1.51k|    if (*str != 0) {
  ------------------
  |  Branch (851:9): [True: 36, False: 1.48k]
  ------------------
  852|     36|	xmlCleanURI(uri);
  853|     36|	return(1);
  854|     36|    }
  855|  1.48k|    return(0);
  856|  1.51k|}
uri.c:xmlParse3986PathNoScheme:
  720|  1.41k|{
  721|  1.41k|    const char *cur;
  722|  1.41k|    int ret;
  723|       |
  724|  1.41k|    cur = *str;
  725|       |
  726|  1.41k|    ret = xmlParse3986Segment(&cur, ':', 0);
  727|  1.41k|    if (ret != 0) return(ret);
  ------------------
  |  Branch (727:9): [True: 0, False: 1.41k]
  ------------------
  728|  1.98k|    while (*cur == '/') {
  ------------------
  |  Branch (728:12): [True: 571, False: 1.41k]
  ------------------
  729|    571|        cur++;
  730|    571|	ret = xmlParse3986Segment(&cur, 0, 1);
  731|    571|	if (ret != 0) return(ret);
  ------------------
  |  Branch (731:6): [True: 0, False: 571]
  ------------------
  732|    571|    }
  733|  1.41k|    if (uri != NULL) {
  ------------------
  |  Branch (733:9): [True: 1.41k, False: 0]
  ------------------
  734|  1.41k|	if (uri->path != NULL) xmlFree(uri->path);
  ------------------
  |  Branch (734:6): [True: 0, False: 1.41k]
  ------------------
  735|  1.41k|        if (cur != *str) {
  ------------------
  |  Branch (735:13): [True: 1.41k, False: 0]
  ------------------
  736|  1.41k|            if (uri->cleanup & 2)
  ------------------
  |  Branch (736:17): [True: 0, False: 1.41k]
  ------------------
  737|      0|                uri->path = STRNDUP(*str, cur - *str);
  ------------------
  |  |  143|      0|#define STRNDUP(s, n) (char *) xmlStrndup((const xmlChar *)(s), (n))
  ------------------
  738|  1.41k|            else
  739|  1.41k|                uri->path = xmlURIUnescapeString(*str, cur - *str, NULL);
  740|  1.41k|        } else {
  741|      0|            uri->path = NULL;
  742|      0|        }
  743|  1.41k|    }
  744|  1.41k|    *str = cur;
  745|  1.41k|    return (0);
  746|  1.41k|}
uri.c:xmlURIErrMemory:
   42|      2|{
   43|      2|    if (extra)
  ------------------
  |  Branch (43:9): [True: 2, False: 0]
  ------------------
   44|      2|        __xmlRaiseError(NULL, NULL, NULL,
   45|      2|                        NULL, NULL, XML_FROM_URI,
   46|      2|                        XML_ERR_NO_MEMORY, XML_ERR_FATAL, NULL, 0,
   47|      2|                        extra, NULL, NULL, 0, 0,
   48|      2|                        "Memory allocation failed : %s\n", extra);
   49|      0|    else
   50|      0|        __xmlRaiseError(NULL, NULL, NULL,
   51|      0|                        NULL, NULL, XML_FROM_URI,
   52|      0|                        XML_ERR_NO_MEMORY, XML_ERR_FATAL, NULL, 0,
   53|      0|                        NULL, NULL, NULL, 0, 0,
   54|      0|                        "Memory allocation failed\n");
   55|      2|}
uri.c:xmlSaveUriRealloc:
 1047|     12|xmlSaveUriRealloc(xmlChar *ret, int *max) {
 1048|     12|    xmlChar *temp;
 1049|     12|    int tmp;
 1050|       |
 1051|     12|    if (*max > MAX_URI_LENGTH) {
  ------------------
  |  |   35|     12|#define MAX_URI_LENGTH 1024 * 1024
  ------------------
  |  Branch (1051:9): [True: 0, False: 12]
  ------------------
 1052|      0|        xmlURIErrMemory("reaching arbitrary MAX_URI_LENGTH limit\n");
 1053|      0|        return(NULL);
 1054|      0|    }
 1055|     12|    tmp = *max * 2;
 1056|     12|    temp = (xmlChar *) xmlRealloc(ret, (tmp + 1));
 1057|     12|    if (temp == NULL) {
  ------------------
  |  Branch (1057:9): [True: 0, False: 12]
  ------------------
 1058|      0|        xmlURIErrMemory("saving URI\n");
 1059|      0|        return(NULL);
 1060|      0|    }
 1061|     12|    *max = tmp;
 1062|     12|    return(temp);
 1063|     12|}

xmlNewDocElementContent:
  754|     14|                        xmlElementContentType type) {
  755|     14|    xmlElementContentPtr ret;
  756|     14|    xmlDictPtr dict = NULL;
  757|       |
  758|     14|    if (doc != NULL)
  ------------------
  |  Branch (758:9): [True: 14, False: 0]
  ------------------
  759|     14|        dict = doc->dict;
  760|       |
  761|     14|    switch(type) {
  762|     14|	case XML_ELEMENT_CONTENT_ELEMENT:
  ------------------
  |  Branch (762:2): [True: 14, False: 0]
  ------------------
  763|     14|	    if (name == NULL) {
  ------------------
  |  Branch (763:10): [True: 0, False: 14]
  ------------------
  764|      0|	        xmlErrValid(NULL, XML_ERR_INTERNAL_ERROR,
  765|      0|			"xmlNewElementContent : name == NULL !\n",
  766|      0|			NULL);
  767|      0|	    }
  768|     14|	    break;
  769|      0|        case XML_ELEMENT_CONTENT_PCDATA:
  ------------------
  |  Branch (769:9): [True: 0, False: 14]
  ------------------
  770|      0|	case XML_ELEMENT_CONTENT_SEQ:
  ------------------
  |  Branch (770:2): [True: 0, False: 14]
  ------------------
  771|      0|	case XML_ELEMENT_CONTENT_OR:
  ------------------
  |  Branch (771:2): [True: 0, False: 14]
  ------------------
  772|      0|	    if (name != NULL) {
  ------------------
  |  Branch (772:10): [True: 0, False: 0]
  ------------------
  773|      0|	        xmlErrValid(NULL, XML_ERR_INTERNAL_ERROR,
  774|      0|			"xmlNewElementContent : name != NULL !\n",
  775|      0|			NULL);
  776|      0|	    }
  777|      0|	    break;
  778|      0|	default:
  ------------------
  |  Branch (778:2): [True: 0, False: 14]
  ------------------
  779|      0|	    xmlErrValid(NULL, XML_ERR_INTERNAL_ERROR,
  780|      0|		    "Internal: ELEMENT content corrupted invalid type\n",
  781|      0|		    NULL);
  782|      0|	    return(NULL);
  783|     14|    }
  784|     14|    ret = (xmlElementContentPtr) xmlMalloc(sizeof(xmlElementContent));
  785|     14|    if (ret == NULL) {
  ------------------
  |  Branch (785:9): [True: 0, False: 14]
  ------------------
  786|      0|	xmlVErrMemory(NULL, "malloc failed");
  787|      0|	return(NULL);
  788|      0|    }
  789|     14|    memset(ret, 0, sizeof(xmlElementContent));
  790|     14|    ret->type = type;
  791|     14|    ret->ocur = XML_ELEMENT_CONTENT_ONCE;
  792|     14|    if (name != NULL) {
  ------------------
  |  Branch (792:9): [True: 14, False: 0]
  ------------------
  793|     14|        int l;
  794|     14|	const xmlChar *tmp;
  795|       |
  796|     14|	tmp = xmlSplitQName3(name, &l);
  797|     14|	if (tmp == NULL) {
  ------------------
  |  Branch (797:6): [True: 14, False: 0]
  ------------------
  798|     14|	    if (dict == NULL)
  ------------------
  |  Branch (798:10): [True: 0, False: 14]
  ------------------
  799|      0|		ret->name = xmlStrdup(name);
  800|     14|	    else
  801|     14|	        ret->name = xmlDictLookup(dict, name, -1);
  802|     14|	} else {
  803|      0|	    if (dict == NULL) {
  ------------------
  |  Branch (803:10): [True: 0, False: 0]
  ------------------
  804|      0|		ret->prefix = xmlStrndup(name, l);
  805|      0|		ret->name = xmlStrdup(tmp);
  806|      0|	    } else {
  807|      0|	        ret->prefix = xmlDictLookup(dict, name, l);
  808|      0|		ret->name = xmlDictLookup(dict, tmp, -1);
  809|      0|	    }
  810|      0|	}
  811|     14|    }
  812|     14|    return(ret);
  813|     14|}
xmlFreeDocElementContent:
  934|     22|xmlFreeDocElementContent(xmlDocPtr doc, xmlElementContentPtr cur) {
  935|     22|    xmlDictPtr dict = NULL;
  936|     22|    size_t depth = 0;
  937|       |
  938|     22|    if (cur == NULL)
  ------------------
  |  Branch (938:9): [True: 8, False: 14]
  ------------------
  939|      8|        return;
  940|     14|    if (doc != NULL)
  ------------------
  |  Branch (940:9): [True: 14, False: 0]
  ------------------
  941|     14|        dict = doc->dict;
  942|       |
  943|     14|    while (1) {
  ------------------
  |  Branch (943:12): [Folded - Ignored]
  ------------------
  944|     14|        xmlElementContentPtr parent;
  945|       |
  946|     14|        while ((cur->c1 != NULL) || (cur->c2 != NULL)) {
  ------------------
  |  Branch (946:16): [True: 0, False: 14]
  |  Branch (946:37): [True: 0, False: 14]
  ------------------
  947|      0|            cur = (cur->c1 != NULL) ? cur->c1 : cur->c2;
  ------------------
  |  Branch (947:19): [True: 0, False: 0]
  ------------------
  948|      0|            depth += 1;
  949|      0|        }
  950|       |
  951|     14|	switch (cur->type) {
  952|      0|	    case XML_ELEMENT_CONTENT_PCDATA:
  ------------------
  |  Branch (952:6): [True: 0, False: 14]
  ------------------
  953|     14|	    case XML_ELEMENT_CONTENT_ELEMENT:
  ------------------
  |  Branch (953:6): [True: 14, False: 0]
  ------------------
  954|     14|	    case XML_ELEMENT_CONTENT_SEQ:
  ------------------
  |  Branch (954:6): [True: 0, False: 14]
  ------------------
  955|     14|	    case XML_ELEMENT_CONTENT_OR:
  ------------------
  |  Branch (955:6): [True: 0, False: 14]
  ------------------
  956|     14|		break;
  957|      0|	    default:
  ------------------
  |  Branch (957:6): [True: 0, False: 14]
  ------------------
  958|      0|		xmlErrValid(NULL, XML_ERR_INTERNAL_ERROR,
  959|      0|			"Internal: ELEMENT content corrupted invalid type\n",
  960|      0|			NULL);
  961|      0|		return;
  962|     14|	}
  963|     14|	if (dict) {
  ------------------
  |  Branch (963:6): [True: 14, False: 0]
  ------------------
  964|     14|	    if ((cur->name != NULL) && (!xmlDictOwns(dict, cur->name)))
  ------------------
  |  Branch (964:10): [True: 14, False: 0]
  |  Branch (964:33): [True: 0, False: 14]
  ------------------
  965|      0|	        xmlFree((xmlChar *) cur->name);
  966|     14|	    if ((cur->prefix != NULL) && (!xmlDictOwns(dict, cur->prefix)))
  ------------------
  |  Branch (966:10): [True: 0, False: 14]
  |  Branch (966:35): [True: 0, False: 0]
  ------------------
  967|      0|	        xmlFree((xmlChar *) cur->prefix);
  968|     14|	} else {
  969|      0|	    if (cur->name != NULL) xmlFree((xmlChar *) cur->name);
  ------------------
  |  Branch (969:10): [True: 0, False: 0]
  ------------------
  970|      0|	    if (cur->prefix != NULL) xmlFree((xmlChar *) cur->prefix);
  ------------------
  |  Branch (970:10): [True: 0, False: 0]
  ------------------
  971|      0|	}
  972|     14|        parent = cur->parent;
  973|     14|        if ((depth == 0) || (parent == NULL)) {
  ------------------
  |  Branch (973:13): [True: 14, False: 0]
  |  Branch (973:29): [True: 0, False: 0]
  ------------------
  974|     14|            xmlFree(cur);
  975|     14|            break;
  976|     14|        }
  977|      0|        if (cur == parent->c1)
  ------------------
  |  Branch (977:13): [True: 0, False: 0]
  ------------------
  978|      0|            parent->c1 = NULL;
  979|      0|        else
  980|      0|            parent->c2 = NULL;
  981|      0|	xmlFree(cur);
  982|       |
  983|      0|        if (parent->c2 != NULL) {
  ------------------
  |  Branch (983:13): [True: 0, False: 0]
  ------------------
  984|      0|	    cur = parent->c2;
  985|      0|        } else {
  986|      0|            depth -= 1;
  987|      0|            cur = parent;
  988|      0|        }
  989|      0|    }
  990|     14|}
xmlAddElementDecl:
 1266|     22|		  xmlElementContentPtr content) {
 1267|     22|    xmlElementPtr ret;
 1268|     22|    xmlElementTablePtr table;
 1269|     22|    xmlAttributePtr oldAttributes = NULL;
 1270|     22|    xmlChar *ns, *uqname;
 1271|       |
 1272|     22|    if (dtd == NULL) {
  ------------------
  |  Branch (1272:9): [True: 0, False: 22]
  ------------------
 1273|      0|	return(NULL);
 1274|      0|    }
 1275|     22|    if (name == NULL) {
  ------------------
  |  Branch (1275:9): [True: 0, False: 22]
  ------------------
 1276|      0|	return(NULL);
 1277|      0|    }
 1278|       |
 1279|     22|    switch (type) {
 1280|      8|        case XML_ELEMENT_TYPE_EMPTY:
  ------------------
  |  Branch (1280:9): [True: 8, False: 14]
  ------------------
 1281|      8|	    if (content != NULL) {
  ------------------
  |  Branch (1281:10): [True: 0, False: 8]
  ------------------
 1282|      0|		xmlErrValid(ctxt, XML_ERR_INTERNAL_ERROR,
 1283|      0|		        "xmlAddElementDecl: content != NULL for EMPTY\n",
 1284|      0|			NULL);
 1285|      0|		return(NULL);
 1286|      0|	    }
 1287|      8|	    break;
 1288|      8|	case XML_ELEMENT_TYPE_ANY:
  ------------------
  |  Branch (1288:2): [True: 0, False: 22]
  ------------------
 1289|      0|	    if (content != NULL) {
  ------------------
  |  Branch (1289:10): [True: 0, False: 0]
  ------------------
 1290|      0|		xmlErrValid(ctxt, XML_ERR_INTERNAL_ERROR,
 1291|      0|		        "xmlAddElementDecl: content != NULL for ANY\n",
 1292|      0|			NULL);
 1293|      0|		return(NULL);
 1294|      0|	    }
 1295|      0|	    break;
 1296|      0|	case XML_ELEMENT_TYPE_MIXED:
  ------------------
  |  Branch (1296:2): [True: 0, False: 22]
  ------------------
 1297|      0|	    if (content == NULL) {
  ------------------
  |  Branch (1297:10): [True: 0, False: 0]
  ------------------
 1298|      0|		xmlErrValid(ctxt, XML_ERR_INTERNAL_ERROR,
 1299|      0|		        "xmlAddElementDecl: content == NULL for MIXED\n",
 1300|      0|			NULL);
 1301|      0|		return(NULL);
 1302|      0|	    }
 1303|      0|	    break;
 1304|     14|	case XML_ELEMENT_TYPE_ELEMENT:
  ------------------
  |  Branch (1304:2): [True: 14, False: 8]
  ------------------
 1305|     14|	    if (content == NULL) {
  ------------------
  |  Branch (1305:10): [True: 0, False: 14]
  ------------------
 1306|      0|		xmlErrValid(ctxt, XML_ERR_INTERNAL_ERROR,
 1307|      0|		        "xmlAddElementDecl: content == NULL for ELEMENT\n",
 1308|      0|			NULL);
 1309|      0|		return(NULL);
 1310|      0|	    }
 1311|     14|	    break;
 1312|     14|	default:
  ------------------
  |  Branch (1312:2): [True: 0, False: 22]
  ------------------
 1313|      0|	    xmlErrValid(ctxt, XML_ERR_INTERNAL_ERROR,
 1314|      0|		    "Internal: ELEMENT decl corrupted invalid type\n",
 1315|      0|		    NULL);
 1316|      0|	    return(NULL);
 1317|     22|    }
 1318|       |
 1319|       |    /*
 1320|       |     * check if name is a QName
 1321|       |     */
 1322|     22|    uqname = xmlSplitQName2(name, &ns);
 1323|     22|    if (uqname != NULL)
  ------------------
  |  Branch (1323:9): [True: 0, False: 22]
  ------------------
 1324|      0|	name = uqname;
 1325|       |
 1326|       |    /*
 1327|       |     * Create the Element table if needed.
 1328|       |     */
 1329|     22|    table = (xmlElementTablePtr) dtd->elements;
 1330|     22|    if (table == NULL) {
  ------------------
  |  Branch (1330:9): [True: 8, False: 14]
  ------------------
 1331|      8|	xmlDictPtr dict = NULL;
 1332|       |
 1333|      8|	if (dtd->doc != NULL)
  ------------------
  |  Branch (1333:6): [True: 8, False: 0]
  ------------------
 1334|      8|	    dict = dtd->doc->dict;
 1335|      8|        table = xmlHashCreateDict(0, dict);
 1336|      8|	dtd->elements = (void *) table;
 1337|      8|    }
 1338|     22|    if (table == NULL) {
  ------------------
  |  Branch (1338:9): [True: 0, False: 22]
  ------------------
 1339|      0|	xmlVErrMemory(ctxt,
 1340|      0|            "xmlAddElementDecl: Table creation failed!\n");
 1341|      0|	if (uqname != NULL)
  ------------------
  |  Branch (1341:6): [True: 0, False: 0]
  ------------------
 1342|      0|	    xmlFree(uqname);
 1343|      0|	if (ns != NULL)
  ------------------
  |  Branch (1343:6): [True: 0, False: 0]
  ------------------
 1344|      0|	    xmlFree(ns);
 1345|      0|        return(NULL);
 1346|      0|    }
 1347|       |
 1348|       |    /*
 1349|       |     * lookup old attributes inserted on an undefined element in the
 1350|       |     * internal subset.
 1351|       |     */
 1352|     22|    if ((dtd->doc != NULL) && (dtd->doc->intSubset != NULL)) {
  ------------------
  |  Branch (1352:9): [True: 22, False: 0]
  |  Branch (1352:31): [True: 22, False: 0]
  ------------------
 1353|     22|	ret = xmlHashLookup2(dtd->doc->intSubset->elements, name, ns);
 1354|     22|	if ((ret != NULL) && (ret->etype == XML_ELEMENT_TYPE_UNDEFINED)) {
  ------------------
  |  Branch (1354:6): [True: 0, False: 22]
  |  Branch (1354:23): [True: 0, False: 0]
  ------------------
 1355|      0|	    oldAttributes = ret->attributes;
 1356|      0|	    ret->attributes = NULL;
 1357|      0|	    xmlHashRemoveEntry2(dtd->doc->intSubset->elements, name, ns, NULL);
 1358|      0|	    xmlFreeElement(ret);
 1359|      0|	}
 1360|     22|    }
 1361|       |
 1362|       |    /*
 1363|       |     * The element may already be present if one of its attribute
 1364|       |     * was registered first
 1365|       |     */
 1366|     22|    ret = xmlHashLookup2(table, name, ns);
 1367|     22|    if (ret != NULL) {
  ------------------
  |  Branch (1367:9): [True: 0, False: 22]
  ------------------
 1368|      0|	if (ret->etype != XML_ELEMENT_TYPE_UNDEFINED) {
  ------------------
  |  Branch (1368:6): [True: 0, False: 0]
  ------------------
 1369|      0|#ifdef LIBXML_VALID_ENABLED
 1370|       |	    /*
 1371|       |	     * The element is already defined in this DTD.
 1372|       |	     */
 1373|      0|	    xmlErrValidNode(ctxt, (xmlNodePtr) dtd, XML_DTD_ELEM_REDEFINED,
 1374|      0|	                    "Redefinition of element %s\n",
 1375|      0|			    name, NULL, NULL);
 1376|      0|#endif /* LIBXML_VALID_ENABLED */
 1377|      0|	    if (uqname != NULL)
  ------------------
  |  Branch (1377:10): [True: 0, False: 0]
  ------------------
 1378|      0|		xmlFree(uqname);
 1379|      0|            if (ns != NULL)
  ------------------
  |  Branch (1379:17): [True: 0, False: 0]
  ------------------
 1380|      0|	        xmlFree(ns);
 1381|      0|	    return(NULL);
 1382|      0|	}
 1383|      0|	if (ns != NULL) {
  ------------------
  |  Branch (1383:6): [True: 0, False: 0]
  ------------------
 1384|      0|	    xmlFree(ns);
 1385|      0|	    ns = NULL;
 1386|      0|	}
 1387|     22|    } else {
 1388|     22|	ret = (xmlElementPtr) xmlMalloc(sizeof(xmlElement));
 1389|     22|	if (ret == NULL) {
  ------------------
  |  Branch (1389:6): [True: 0, False: 22]
  ------------------
 1390|      0|	    xmlVErrMemory(ctxt, "malloc failed");
 1391|      0|	    if (uqname != NULL)
  ------------------
  |  Branch (1391:10): [True: 0, False: 0]
  ------------------
 1392|      0|		xmlFree(uqname);
 1393|      0|            if (ns != NULL)
  ------------------
  |  Branch (1393:17): [True: 0, False: 0]
  ------------------
 1394|      0|	        xmlFree(ns);
 1395|      0|	    return(NULL);
 1396|      0|	}
 1397|     22|	memset(ret, 0, sizeof(xmlElement));
 1398|     22|	ret->type = XML_ELEMENT_DECL;
 1399|       |
 1400|       |	/*
 1401|       |	 * fill the structure.
 1402|       |	 */
 1403|     22|	ret->name = xmlStrdup(name);
 1404|     22|	if (ret->name == NULL) {
  ------------------
  |  Branch (1404:6): [True: 0, False: 22]
  ------------------
 1405|      0|	    xmlVErrMemory(ctxt, "malloc failed");
 1406|      0|	    if (uqname != NULL)
  ------------------
  |  Branch (1406:10): [True: 0, False: 0]
  ------------------
 1407|      0|		xmlFree(uqname);
 1408|      0|            if (ns != NULL)
  ------------------
  |  Branch (1408:17): [True: 0, False: 0]
  ------------------
 1409|      0|	        xmlFree(ns);
 1410|      0|	    xmlFree(ret);
 1411|      0|	    return(NULL);
 1412|      0|	}
 1413|     22|	ret->prefix = ns;
 1414|       |
 1415|       |	/*
 1416|       |	 * Validity Check:
 1417|       |	 * Insertion must not fail
 1418|       |	 */
 1419|     22|	if (xmlHashAddEntry2(table, name, ns, ret)) {
  ------------------
  |  Branch (1419:6): [True: 0, False: 22]
  ------------------
 1420|      0|#ifdef LIBXML_VALID_ENABLED
 1421|       |	    /*
 1422|       |	     * The element is already defined in this DTD.
 1423|       |	     */
 1424|      0|	    xmlErrValidNode(ctxt, (xmlNodePtr) dtd, XML_DTD_ELEM_REDEFINED,
 1425|      0|	                    "Redefinition of element %s\n",
 1426|      0|			    name, NULL, NULL);
 1427|      0|#endif /* LIBXML_VALID_ENABLED */
 1428|      0|	    xmlFreeElement(ret);
 1429|      0|	    if (uqname != NULL)
  ------------------
  |  Branch (1429:10): [True: 0, False: 0]
  ------------------
 1430|      0|		xmlFree(uqname);
 1431|      0|	    return(NULL);
 1432|      0|	}
 1433|       |	/*
 1434|       |	 * For new element, may have attributes from earlier
 1435|       |	 * definition in internal subset
 1436|       |	 */
 1437|     22|	ret->attributes = oldAttributes;
 1438|     22|    }
 1439|       |
 1440|       |    /*
 1441|       |     * Finish to fill the structure.
 1442|       |     */
 1443|     22|    ret->etype = type;
 1444|       |    /*
 1445|       |     * Avoid a stupid copy when called by the parser
 1446|       |     * and flag it by setting a special parent value
 1447|       |     * so the parser doesn't unallocate it.
 1448|       |     */
 1449|     22|    if ((ctxt != NULL) && (ctxt->flags & XML_VCTXT_USE_PCTXT)) {
  ------------------
  |  |   18|     22|#define XML_VCTXT_USE_PCTXT (1u << 1)
  ------------------
  |  Branch (1449:9): [True: 22, False: 0]
  |  Branch (1449:27): [True: 22, False: 0]
  ------------------
 1450|     22|	ret->content = content;
 1451|     22|	if (content != NULL)
  ------------------
  |  Branch (1451:6): [True: 14, False: 8]
  ------------------
 1452|     14|	    content->parent = (xmlElementContentPtr) 1;
 1453|     22|    } else {
 1454|      0|	ret->content = xmlCopyDocElementContent(dtd->doc, content);
 1455|      0|    }
 1456|       |
 1457|       |    /*
 1458|       |     * Link it to the DTD
 1459|       |     */
 1460|     22|    ret->parent = dtd;
 1461|     22|    ret->doc = dtd->doc;
 1462|     22|    if (dtd->last == NULL) {
  ------------------
  |  Branch (1462:9): [True: 8, False: 14]
  ------------------
 1463|      8|	dtd->children = dtd->last = (xmlNodePtr) ret;
 1464|     14|    } else {
 1465|     14|        dtd->last->next = (xmlNodePtr) ret;
 1466|     14|	ret->prev = dtd->last;
 1467|     14|	dtd->last = (xmlNodePtr) ret;
 1468|     14|    }
 1469|     22|    if (uqname != NULL)
  ------------------
  |  Branch (1469:9): [True: 0, False: 22]
  ------------------
 1470|      0|	xmlFree(uqname);
 1471|     22|    return(ret);
 1472|     22|}
xmlFreeElementTable:
 1486|      8|xmlFreeElementTable(xmlElementTablePtr table) {
 1487|      8|    xmlHashFree(table, xmlFreeElementTableEntry);
 1488|      8|}
xmlAddAttributeDecl:
 1816|      8|		    const xmlChar *defaultValue, xmlEnumerationPtr tree) {
 1817|      8|    xmlAttributePtr ret;
 1818|      8|    xmlAttributeTablePtr table;
 1819|      8|    xmlElementPtr elemDef;
 1820|      8|    xmlDictPtr dict = NULL;
 1821|       |
 1822|      8|    if (dtd == NULL) {
  ------------------
  |  Branch (1822:9): [True: 0, False: 8]
  ------------------
 1823|      0|	xmlFreeEnumeration(tree);
 1824|      0|	return(NULL);
 1825|      0|    }
 1826|      8|    if (name == NULL) {
  ------------------
  |  Branch (1826:9): [True: 0, False: 8]
  ------------------
 1827|      0|	xmlFreeEnumeration(tree);
 1828|      0|	return(NULL);
 1829|      0|    }
 1830|      8|    if (elem == NULL) {
  ------------------
  |  Branch (1830:9): [True: 0, False: 8]
  ------------------
 1831|      0|	xmlFreeEnumeration(tree);
 1832|      0|	return(NULL);
 1833|      0|    }
 1834|      8|    if (dtd->doc != NULL)
  ------------------
  |  Branch (1834:9): [True: 8, False: 0]
  ------------------
 1835|      8|	dict = dtd->doc->dict;
 1836|       |
 1837|      8|#ifdef LIBXML_VALID_ENABLED
 1838|       |    /*
 1839|       |     * Check the type and possibly the default value.
 1840|       |     */
 1841|      8|    switch (type) {
 1842|      0|        case XML_ATTRIBUTE_CDATA:
  ------------------
  |  Branch (1842:9): [True: 0, False: 8]
  ------------------
 1843|      0|	    break;
 1844|      8|        case XML_ATTRIBUTE_ID:
  ------------------
  |  Branch (1844:9): [True: 8, False: 0]
  ------------------
 1845|      8|	    break;
 1846|      0|        case XML_ATTRIBUTE_IDREF:
  ------------------
  |  Branch (1846:9): [True: 0, False: 8]
  ------------------
 1847|      0|	    break;
 1848|      0|        case XML_ATTRIBUTE_IDREFS:
  ------------------
  |  Branch (1848:9): [True: 0, False: 8]
  ------------------
 1849|      0|	    break;
 1850|      0|        case XML_ATTRIBUTE_ENTITY:
  ------------------
  |  Branch (1850:9): [True: 0, False: 8]
  ------------------
 1851|      0|	    break;
 1852|      0|        case XML_ATTRIBUTE_ENTITIES:
  ------------------
  |  Branch (1852:9): [True: 0, False: 8]
  ------------------
 1853|      0|	    break;
 1854|      0|        case XML_ATTRIBUTE_NMTOKEN:
  ------------------
  |  Branch (1854:9): [True: 0, False: 8]
  ------------------
 1855|      0|	    break;
 1856|      0|        case XML_ATTRIBUTE_NMTOKENS:
  ------------------
  |  Branch (1856:9): [True: 0, False: 8]
  ------------------
 1857|      0|	    break;
 1858|      0|        case XML_ATTRIBUTE_ENUMERATION:
  ------------------
  |  Branch (1858:9): [True: 0, False: 8]
  ------------------
 1859|      0|	    break;
 1860|      0|        case XML_ATTRIBUTE_NOTATION:
  ------------------
  |  Branch (1860:9): [True: 0, False: 8]
  ------------------
 1861|      0|	    break;
 1862|      0|	default:
  ------------------
  |  Branch (1862:2): [True: 0, False: 8]
  ------------------
 1863|      0|	    xmlErrValid(ctxt, XML_ERR_INTERNAL_ERROR,
 1864|      0|		    "Internal: ATTRIBUTE struct corrupted invalid type\n",
 1865|      0|		    NULL);
 1866|      0|	    xmlFreeEnumeration(tree);
 1867|      0|	    return(NULL);
 1868|      8|    }
 1869|      8|    if ((defaultValue != NULL) &&
  ------------------
  |  Branch (1869:9): [True: 0, False: 8]
  ------------------
 1870|      8|        (!xmlValidateAttributeValueInternal(dtd->doc, type, defaultValue))) {
  ------------------
  |  Branch (1870:9): [True: 0, False: 0]
  ------------------
 1871|      0|	xmlErrValidNode(ctxt, (xmlNodePtr) dtd, XML_DTD_ATTRIBUTE_DEFAULT,
 1872|      0|	                "Attribute %s of %s: invalid default value\n",
 1873|      0|	                elem, name, defaultValue);
 1874|      0|	defaultValue = NULL;
 1875|      0|	if (ctxt != NULL)
  ------------------
  |  Branch (1875:6): [True: 0, False: 0]
  ------------------
 1876|      0|	    ctxt->valid = 0;
 1877|      0|    }
 1878|      8|#endif /* LIBXML_VALID_ENABLED */
 1879|       |
 1880|       |    /*
 1881|       |     * Check first that an attribute defined in the external subset wasn't
 1882|       |     * already defined in the internal subset
 1883|       |     */
 1884|      8|    if ((dtd->doc != NULL) && (dtd->doc->extSubset == dtd) &&
  ------------------
  |  Branch (1884:9): [True: 8, False: 0]
  |  Branch (1884:31): [True: 0, False: 8]
  ------------------
 1885|      8|	(dtd->doc->intSubset != NULL) &&
  ------------------
  |  Branch (1885:2): [True: 0, False: 0]
  ------------------
 1886|      8|	(dtd->doc->intSubset->attributes != NULL)) {
  ------------------
  |  Branch (1886:2): [True: 0, False: 0]
  ------------------
 1887|      0|        ret = xmlHashLookup3(dtd->doc->intSubset->attributes, name, ns, elem);
 1888|      0|	if (ret != NULL) {
  ------------------
  |  Branch (1888:6): [True: 0, False: 0]
  ------------------
 1889|      0|	    xmlFreeEnumeration(tree);
 1890|      0|	    return(NULL);
 1891|      0|	}
 1892|      0|    }
 1893|       |
 1894|       |    /*
 1895|       |     * Create the Attribute table if needed.
 1896|       |     */
 1897|      8|    table = (xmlAttributeTablePtr) dtd->attributes;
 1898|      8|    if (table == NULL) {
  ------------------
  |  Branch (1898:9): [True: 8, False: 0]
  ------------------
 1899|      8|        table = xmlHashCreateDict(0, dict);
 1900|      8|	dtd->attributes = (void *) table;
 1901|      8|    }
 1902|      8|    if (table == NULL) {
  ------------------
  |  Branch (1902:9): [True: 0, False: 8]
  ------------------
 1903|      0|	xmlVErrMemory(ctxt,
 1904|      0|            "xmlAddAttributeDecl: Table creation failed!\n");
 1905|      0|	xmlFreeEnumeration(tree);
 1906|      0|        return(NULL);
 1907|      0|    }
 1908|       |
 1909|       |
 1910|      8|    ret = (xmlAttributePtr) xmlMalloc(sizeof(xmlAttribute));
 1911|      8|    if (ret == NULL) {
  ------------------
  |  Branch (1911:9): [True: 0, False: 8]
  ------------------
 1912|      0|	xmlVErrMemory(ctxt, "malloc failed");
 1913|      0|	xmlFreeEnumeration(tree);
 1914|      0|	return(NULL);
 1915|      0|    }
 1916|      8|    memset(ret, 0, sizeof(xmlAttribute));
 1917|      8|    ret->type = XML_ATTRIBUTE_DECL;
 1918|       |
 1919|       |    /*
 1920|       |     * fill the structure.
 1921|       |     */
 1922|      8|    ret->atype = type;
 1923|       |    /*
 1924|       |     * doc must be set before possible error causes call
 1925|       |     * to xmlFreeAttribute (because it's used to check on
 1926|       |     * dict use)
 1927|       |     */
 1928|      8|    ret->doc = dtd->doc;
 1929|      8|    if (dict) {
  ------------------
  |  Branch (1929:9): [True: 8, False: 0]
  ------------------
 1930|      8|	ret->name = xmlDictLookup(dict, name, -1);
 1931|      8|	ret->prefix = xmlDictLookup(dict, ns, -1);
 1932|      8|	ret->elem = xmlDictLookup(dict, elem, -1);
 1933|      8|    } else {
 1934|      0|	ret->name = xmlStrdup(name);
 1935|      0|	ret->prefix = xmlStrdup(ns);
 1936|      0|	ret->elem = xmlStrdup(elem);
 1937|      0|    }
 1938|      8|    ret->def = def;
 1939|      8|    ret->tree = tree;
 1940|      8|    if (defaultValue != NULL) {
  ------------------
  |  Branch (1940:9): [True: 0, False: 8]
  ------------------
 1941|      0|        if (dict)
  ------------------
  |  Branch (1941:13): [True: 0, False: 0]
  ------------------
 1942|      0|	    ret->defaultValue = xmlDictLookup(dict, defaultValue, -1);
 1943|      0|	else
 1944|      0|	    ret->defaultValue = xmlStrdup(defaultValue);
 1945|      0|    }
 1946|       |
 1947|       |    /*
 1948|       |     * Validity Check:
 1949|       |     * Search the DTD for previous declarations of the ATTLIST
 1950|       |     */
 1951|      8|    if (xmlHashAddEntry3(table, ret->name, ret->prefix, ret->elem, ret) < 0) {
  ------------------
  |  Branch (1951:9): [True: 0, False: 8]
  ------------------
 1952|      0|#ifdef LIBXML_VALID_ENABLED
 1953|       |	/*
 1954|       |	 * The attribute is already defined in this DTD.
 1955|       |	 */
 1956|      0|	xmlErrValidWarning(ctxt, (xmlNodePtr) dtd, XML_DTD_ATTRIBUTE_REDEFINED,
 1957|      0|		 "Attribute %s of element %s: already defined\n",
 1958|      0|		 name, elem, NULL);
 1959|      0|#endif /* LIBXML_VALID_ENABLED */
 1960|      0|	xmlFreeAttribute(ret);
 1961|      0|	return(NULL);
 1962|      0|    }
 1963|       |
 1964|       |    /*
 1965|       |     * Validity Check:
 1966|       |     * Multiple ID per element
 1967|       |     */
 1968|      8|    elemDef = xmlGetDtdElementDesc2(ctxt, dtd, elem, 1);
 1969|      8|    if (elemDef != NULL) {
  ------------------
  |  Branch (1969:9): [True: 8, False: 0]
  ------------------
 1970|       |
 1971|      8|#ifdef LIBXML_VALID_ENABLED
 1972|      8|        if ((type == XML_ATTRIBUTE_ID) &&
  ------------------
  |  Branch (1972:13): [True: 8, False: 0]
  ------------------
 1973|      8|	    (xmlScanIDAttributeDecl(NULL, elemDef, 1) != 0)) {
  ------------------
  |  Branch (1973:6): [True: 0, False: 8]
  ------------------
 1974|      0|	    xmlErrValidNode(ctxt, (xmlNodePtr) dtd, XML_DTD_MULTIPLE_ID,
 1975|      0|	   "Element %s has too may ID attributes defined : %s\n",
 1976|      0|		   elem, name, NULL);
 1977|      0|	    if (ctxt != NULL)
  ------------------
  |  Branch (1977:10): [True: 0, False: 0]
  ------------------
 1978|      0|		ctxt->valid = 0;
 1979|      0|	}
 1980|      8|#endif /* LIBXML_VALID_ENABLED */
 1981|       |
 1982|       |	/*
 1983|       |	 * Insert namespace default def first they need to be
 1984|       |	 * processed first.
 1985|       |	 */
 1986|      8|	if ((xmlStrEqual(ret->name, BAD_CAST "xmlns")) ||
  ------------------
  |  |   35|      8|#define BAD_CAST (xmlChar *)
  ------------------
  |  Branch (1986:6): [True: 0, False: 8]
  ------------------
 1987|      8|	    ((ret->prefix != NULL &&
  ------------------
  |  Branch (1987:8): [True: 0, False: 8]
  ------------------
 1988|      8|	     (xmlStrEqual(ret->prefix, BAD_CAST "xmlns"))))) {
  ------------------
  |  |   35|      0|#define BAD_CAST (xmlChar *)
  ------------------
  |  Branch (1988:7): [True: 0, False: 0]
  ------------------
 1989|      0|	    ret->nexth = elemDef->attributes;
 1990|      0|	    elemDef->attributes = ret;
 1991|      8|	} else {
 1992|      8|	    xmlAttributePtr tmp = elemDef->attributes;
 1993|       |
 1994|      8|	    while ((tmp != NULL) &&
  ------------------
  |  Branch (1994:13): [True: 0, False: 8]
  ------------------
 1995|      8|		   ((xmlStrEqual(tmp->name, BAD_CAST "xmlns")) ||
  ------------------
  |  |   35|      0|#define BAD_CAST (xmlChar *)
  ------------------
  |  Branch (1995:7): [True: 0, False: 0]
  ------------------
 1996|      0|		    ((ret->prefix != NULL &&
  ------------------
  |  Branch (1996:9): [True: 0, False: 0]
  ------------------
 1997|      0|		     (xmlStrEqual(ret->prefix, BAD_CAST "xmlns")))))) {
  ------------------
  |  |   35|      0|#define BAD_CAST (xmlChar *)
  ------------------
  |  Branch (1997:8): [True: 0, False: 0]
  ------------------
 1998|      0|		if (tmp->nexth == NULL)
  ------------------
  |  Branch (1998:7): [True: 0, False: 0]
  ------------------
 1999|      0|		    break;
 2000|      0|		tmp = tmp->nexth;
 2001|      0|	    }
 2002|      8|	    if (tmp != NULL) {
  ------------------
  |  Branch (2002:10): [True: 0, False: 8]
  ------------------
 2003|      0|		ret->nexth = tmp->nexth;
 2004|      0|	        tmp->nexth = ret;
 2005|      8|	    } else {
 2006|      8|		ret->nexth = elemDef->attributes;
 2007|      8|		elemDef->attributes = ret;
 2008|      8|	    }
 2009|      8|	}
 2010|      8|    }
 2011|       |
 2012|       |    /*
 2013|       |     * Link it to the DTD
 2014|       |     */
 2015|      8|    ret->parent = dtd;
 2016|      8|    if (dtd->last == NULL) {
  ------------------
  |  Branch (2016:9): [True: 0, False: 8]
  ------------------
 2017|      0|	dtd->children = dtd->last = (xmlNodePtr) ret;
 2018|      8|    } else {
 2019|      8|        dtd->last->next = (xmlNodePtr) ret;
 2020|      8|	ret->prev = dtd->last;
 2021|      8|	dtd->last = (xmlNodePtr) ret;
 2022|      8|    }
 2023|      8|    return(ret);
 2024|      8|}
xmlFreeAttributeTable:
 2038|      8|xmlFreeAttributeTable(xmlAttributeTablePtr table) {
 2039|      8|    xmlHashFree(table, xmlFreeAttributeTableEntry);
 2040|      8|}
xmlAddID:
 2518|     38|         xmlAttrPtr attr) {
 2519|     38|    xmlIDPtr ret;
 2520|     38|    xmlIDTablePtr table;
 2521|       |
 2522|     38|    if (doc == NULL) {
  ------------------
  |  Branch (2522:9): [True: 0, False: 38]
  ------------------
 2523|      0|	return(NULL);
 2524|      0|    }
 2525|     38|    if ((value == NULL) || (value[0] == 0)) {
  ------------------
  |  Branch (2525:9): [True: 0, False: 38]
  |  Branch (2525:28): [True: 0, False: 38]
  ------------------
 2526|      0|	return(NULL);
 2527|      0|    }
 2528|     38|    if (attr == NULL) {
  ------------------
  |  Branch (2528:9): [True: 0, False: 38]
  ------------------
 2529|      0|	return(NULL);
 2530|      0|    }
 2531|       |
 2532|       |    /*
 2533|       |     * Create the ID table if needed.
 2534|       |     */
 2535|     38|    table = (xmlIDTablePtr) doc->ids;
 2536|     38|    if (table == NULL)  {
  ------------------
  |  Branch (2536:9): [True: 20, False: 18]
  ------------------
 2537|     20|        doc->ids = table = xmlHashCreateDict(0, doc->dict);
 2538|     20|    }
 2539|     38|    if (table == NULL) {
  ------------------
  |  Branch (2539:9): [True: 0, False: 38]
  ------------------
 2540|      0|	xmlVErrMemory(ctxt,
 2541|      0|		"xmlAddID: Table creation failed!\n");
 2542|      0|        return(NULL);
 2543|      0|    }
 2544|       |
 2545|     38|    ret = (xmlIDPtr) xmlMalloc(sizeof(xmlID));
 2546|     38|    if (ret == NULL) {
  ------------------
  |  Branch (2546:9): [True: 0, False: 38]
  ------------------
 2547|      0|	xmlVErrMemory(ctxt, "malloc failed");
 2548|      0|	return(NULL);
 2549|      0|    }
 2550|       |
 2551|       |    /*
 2552|       |     * fill the structure.
 2553|       |     */
 2554|     38|    ret->value = xmlStrdup(value);
 2555|     38|    ret->doc = doc;
 2556|     38|    if (xmlIsStreaming(ctxt)) {
  ------------------
  |  Branch (2556:9): [True: 12, False: 26]
  ------------------
 2557|       |	/*
 2558|       |	 * Operating in streaming mode, attr is gonna disappear
 2559|       |	 */
 2560|     12|	if (doc->dict != NULL)
  ------------------
  |  Branch (2560:6): [True: 12, False: 0]
  ------------------
 2561|     12|	    ret->name = xmlDictLookup(doc->dict, attr->name, -1);
 2562|      0|	else
 2563|      0|	    ret->name = xmlStrdup(attr->name);
 2564|     12|	ret->attr = NULL;
 2565|     26|    } else {
 2566|     26|	ret->attr = attr;
 2567|     26|	ret->name = NULL;
 2568|     26|    }
 2569|     38|    ret->lineno = xmlGetLineNo(attr->parent);
 2570|       |
 2571|     38|    if (xmlHashAddEntry(table, value, ret) < 0) {
  ------------------
  |  Branch (2571:9): [True: 4, False: 34]
  ------------------
 2572|      4|#ifdef LIBXML_VALID_ENABLED
 2573|       |	/*
 2574|       |	 * The id is already defined in this DTD.
 2575|       |	 */
 2576|      4|	if (ctxt != NULL) {
  ------------------
  |  Branch (2576:6): [True: 0, False: 4]
  ------------------
 2577|      0|	    xmlErrValidNode(ctxt, attr->parent, XML_DTD_ID_REDEFINED,
 2578|      0|			    "ID %s already defined\n", value, NULL, NULL);
 2579|      0|	}
 2580|      4|#endif /* LIBXML_VALID_ENABLED */
 2581|      4|	xmlFreeID(ret);
 2582|      4|	return(NULL);
 2583|      4|    }
 2584|     34|    if (attr != NULL)
  ------------------
  |  Branch (2584:9): [True: 34, False: 0]
  ------------------
 2585|     34|	attr->atype = XML_ATTRIBUTE_ID;
 2586|     34|    return(ret);
 2587|     38|}
xmlFreeIDTable:
 2601|     20|xmlFreeIDTable(xmlIDTablePtr table) {
 2602|     20|    xmlHashFree(table, xmlFreeIDTableEntry);
 2603|     20|}
xmlIsID:
 2619|    964|xmlIsID(xmlDocPtr doc, xmlNodePtr elem, xmlAttrPtr attr) {
 2620|    964|    if ((attr == NULL) || (attr->name == NULL)) return(0);
  ------------------
  |  Branch (2620:9): [True: 0, False: 964]
  |  Branch (2620:27): [True: 0, False: 964]
  ------------------
 2621|    964|    if ((attr->ns != NULL) && (attr->ns->prefix != NULL) &&
  ------------------
  |  Branch (2621:9): [True: 28, False: 936]
  |  Branch (2621:31): [True: 28, False: 0]
  ------------------
 2622|    964|        (!strcmp((char *) attr->name, "id")) &&
  ------------------
  |  Branch (2622:9): [True: 2, False: 26]
  ------------------
 2623|    964|        (!strcmp((char *) attr->ns->prefix, "xml")))
  ------------------
  |  Branch (2623:9): [True: 2, False: 0]
  ------------------
 2624|      2|	return(1);
 2625|    962|    if (doc == NULL) return(0);
  ------------------
  |  Branch (2625:9): [True: 0, False: 962]
  ------------------
 2626|    962|    if ((doc->intSubset == NULL) && (doc->extSubset == NULL) &&
  ------------------
  |  Branch (2626:9): [True: 934, False: 28]
  |  Branch (2626:37): [True: 934, False: 0]
  ------------------
 2627|    962|        (doc->type != XML_HTML_DOCUMENT_NODE)) {
  ------------------
  |  Branch (2627:9): [True: 934, False: 0]
  ------------------
 2628|    934|	return(0);
 2629|    934|    } else if (doc->type == XML_HTML_DOCUMENT_NODE) {
  ------------------
  |  Branch (2629:16): [True: 0, False: 28]
  ------------------
 2630|      0|        if ((xmlStrEqual(BAD_CAST "id", attr->name)) ||
  ------------------
  |  |   35|      0|#define BAD_CAST (xmlChar *)
  ------------------
  |  Branch (2630:13): [True: 0, False: 0]
  ------------------
 2631|      0|	    ((xmlStrEqual(BAD_CAST "name", attr->name)) &&
  ------------------
  |  |   35|      0|#define BAD_CAST (xmlChar *)
  ------------------
  |  Branch (2631:7): [True: 0, False: 0]
  ------------------
 2632|      0|	    ((elem == NULL) || (xmlStrEqual(elem->name, BAD_CAST "a")))))
  ------------------
  |  |   35|      0|#define BAD_CAST (xmlChar *)
  ------------------
  |  Branch (2632:7): [True: 0, False: 0]
  |  Branch (2632:25): [True: 0, False: 0]
  ------------------
 2633|      0|	    return(1);
 2634|      0|	return(0);
 2635|     28|    } else if (elem == NULL) {
  ------------------
  |  Branch (2635:16): [True: 0, False: 28]
  ------------------
 2636|      0|	return(0);
 2637|     28|    } else {
 2638|     28|	xmlAttributePtr attrDecl = NULL;
 2639|       |
 2640|     28|	xmlChar felem[50], fattr[50];
 2641|     28|	xmlChar *fullelemname, *fullattrname;
 2642|       |
 2643|     28|	fullelemname = (elem->ns != NULL && elem->ns->prefix != NULL) ?
  ------------------
  |  Branch (2643:18): [True: 2, False: 26]
  |  Branch (2643:38): [True: 2, False: 0]
  ------------------
 2644|      2|	    xmlBuildQName(elem->name, elem->ns->prefix, felem, 50) :
 2645|     28|	    (xmlChar *)elem->name;
 2646|       |
 2647|     28|	fullattrname = (attr->ns != NULL && attr->ns->prefix != NULL) ?
  ------------------
  |  Branch (2647:18): [True: 2, False: 26]
  |  Branch (2647:38): [True: 2, False: 0]
  ------------------
 2648|      2|	    xmlBuildQName(attr->name, attr->ns->prefix, fattr, 50) :
 2649|     28|	    (xmlChar *)attr->name;
 2650|       |
 2651|     28|	if (fullelemname != NULL && fullattrname != NULL) {
  ------------------
  |  Branch (2651:6): [True: 28, False: 0]
  |  Branch (2651:30): [True: 28, False: 0]
  ------------------
 2652|     28|	    attrDecl = xmlGetDtdAttrDesc(doc->intSubset, fullelemname,
 2653|     28|		                         fullattrname);
 2654|     28|	    if ((attrDecl == NULL) && (doc->extSubset != NULL))
  ------------------
  |  Branch (2654:10): [True: 4, False: 24]
  |  Branch (2654:32): [True: 0, False: 4]
  ------------------
 2655|      0|		attrDecl = xmlGetDtdAttrDesc(doc->extSubset, fullelemname,
 2656|      0|					     fullattrname);
 2657|     28|	}
 2658|       |
 2659|     28|	if ((fullattrname != fattr) && (fullattrname != attr->name))
  ------------------
  |  Branch (2659:6): [True: 26, False: 2]
  |  Branch (2659:33): [True: 0, False: 26]
  ------------------
 2660|      0|	    xmlFree(fullattrname);
 2661|     28|	if ((fullelemname != felem) && (fullelemname != elem->name))
  ------------------
  |  Branch (2661:6): [True: 26, False: 2]
  |  Branch (2661:33): [True: 0, False: 26]
  ------------------
 2662|      0|	    xmlFree(fullelemname);
 2663|       |
 2664|     28|        if ((attrDecl != NULL) && (attrDecl->atype == XML_ATTRIBUTE_ID))
  ------------------
  |  Branch (2664:13): [True: 24, False: 4]
  |  Branch (2664:35): [True: 24, False: 0]
  ------------------
 2665|     24|	    return(1);
 2666|     28|    }
 2667|      4|    return(0);
 2668|    962|}
xmlRemoveID:
 2680|     20|xmlRemoveID(xmlDocPtr doc, xmlAttrPtr attr) {
 2681|     20|    xmlIDTablePtr table;
 2682|     20|    xmlIDPtr id;
 2683|     20|    xmlChar *ID;
 2684|       |
 2685|     20|    if (doc == NULL) return(-1);
  ------------------
  |  Branch (2685:9): [True: 0, False: 20]
  ------------------
 2686|     20|    if (attr == NULL) return(-1);
  ------------------
  |  Branch (2686:9): [True: 0, False: 20]
  ------------------
 2687|       |
 2688|     20|    table = (xmlIDTablePtr) doc->ids;
 2689|     20|    if (table == NULL)
  ------------------
  |  Branch (2689:9): [True: 20, False: 0]
  ------------------
 2690|     20|        return(-1);
 2691|       |
 2692|      0|    ID = xmlNodeListGetString(doc, attr->children, 1);
 2693|      0|    if (ID == NULL)
  ------------------
  |  Branch (2693:9): [True: 0, False: 0]
  ------------------
 2694|      0|        return(-1);
 2695|      0|    xmlValidNormalizeString(ID);
 2696|       |
 2697|      0|    id = xmlHashLookup(table, ID);
 2698|      0|    if (id == NULL || id->attr != attr) {
  ------------------
  |  Branch (2698:9): [True: 0, False: 0]
  |  Branch (2698:23): [True: 0, False: 0]
  ------------------
 2699|      0|        xmlFree(ID);
 2700|      0|        return(-1);
 2701|      0|    }
 2702|       |
 2703|      0|    xmlHashRemoveEntry(table, ID, xmlFreeIDTableEntry);
 2704|      0|    xmlFree(ID);
 2705|      0|    attr->atype = 0;
 2706|      0|    return(0);
 2707|      0|}
xmlGetID:
 2719|      2|xmlGetID(xmlDocPtr doc, const xmlChar *ID) {
 2720|      2|    xmlIDTablePtr table;
 2721|      2|    xmlIDPtr id;
 2722|       |
 2723|      2|    if (doc == NULL) {
  ------------------
  |  Branch (2723:9): [True: 0, False: 2]
  ------------------
 2724|      0|	return(NULL);
 2725|      0|    }
 2726|       |
 2727|      2|    if (ID == NULL) {
  ------------------
  |  Branch (2727:9): [True: 0, False: 2]
  ------------------
 2728|      0|	return(NULL);
 2729|      0|    }
 2730|       |
 2731|      2|    table = (xmlIDTablePtr) doc->ids;
 2732|      2|    if (table == NULL)
  ------------------
  |  Branch (2732:9): [True: 0, False: 2]
  ------------------
 2733|      0|        return(NULL);
 2734|       |
 2735|      2|    id = xmlHashLookup(table, ID);
 2736|      2|    if (id == NULL)
  ------------------
  |  Branch (2736:9): [True: 0, False: 2]
  ------------------
 2737|      0|	return(NULL);
 2738|      2|    if (id->attr == NULL) {
  ------------------
  |  Branch (2738:9): [True: 0, False: 2]
  ------------------
 2739|       |	/*
 2740|       |	 * We are operating on a stream, return a well known reference
 2741|       |	 * since the attribute node doesn't exist anymore
 2742|       |	 */
 2743|      0|	return((xmlAttrPtr) doc);
 2744|      0|    }
 2745|      2|    return(id->attr);
 2746|      2|}
xmlIsRef:
 2967|    912|xmlIsRef(xmlDocPtr doc, xmlNodePtr elem, xmlAttrPtr attr) {
 2968|    912|    if (attr == NULL)
  ------------------
  |  Branch (2968:9): [True: 0, False: 912]
  ------------------
 2969|      0|        return(0);
 2970|    912|    if (doc == NULL) {
  ------------------
  |  Branch (2970:9): [True: 0, False: 912]
  ------------------
 2971|      0|        doc = attr->doc;
 2972|      0|	if (doc == NULL) return(0);
  ------------------
  |  Branch (2972:6): [True: 0, False: 0]
  ------------------
 2973|      0|    }
 2974|       |
 2975|    912|    if ((doc->intSubset == NULL) && (doc->extSubset == NULL)) {
  ------------------
  |  Branch (2975:9): [True: 910, False: 2]
  |  Branch (2975:37): [True: 910, False: 0]
  ------------------
 2976|    910|        return(0);
 2977|    910|    } else if (doc->type == XML_HTML_DOCUMENT_NODE) {
  ------------------
  |  Branch (2977:16): [True: 0, False: 2]
  ------------------
 2978|       |        /* TODO @@@ */
 2979|      0|        return(0);
 2980|      2|    } else {
 2981|      2|        xmlAttributePtr attrDecl;
 2982|       |
 2983|      2|        if (elem == NULL) return(0);
  ------------------
  |  Branch (2983:13): [True: 0, False: 2]
  ------------------
 2984|      2|        attrDecl = xmlGetDtdAttrDesc(doc->intSubset, elem->name, attr->name);
 2985|      2|        if ((attrDecl == NULL) && (doc->extSubset != NULL))
  ------------------
  |  Branch (2985:13): [True: 2, False: 0]
  |  Branch (2985:35): [True: 0, False: 2]
  ------------------
 2986|      0|            attrDecl = xmlGetDtdAttrDesc(doc->extSubset,
 2987|      0|		                         elem->name, attr->name);
 2988|       |
 2989|      2|	if ((attrDecl != NULL) &&
  ------------------
  |  Branch (2989:6): [True: 0, False: 2]
  ------------------
 2990|      2|	    (attrDecl->atype == XML_ATTRIBUTE_IDREF ||
  ------------------
  |  Branch (2990:7): [True: 0, False: 0]
  ------------------
 2991|      0|	     attrDecl->atype == XML_ATTRIBUTE_IDREFS))
  ------------------
  |  Branch (2991:7): [True: 0, False: 0]
  ------------------
 2992|      0|	return(1);
 2993|      2|    }
 2994|      2|    return(0);
 2995|    912|}
xmlGetDtdElementDesc:
 3102|      8|xmlGetDtdElementDesc(xmlDtdPtr dtd, const xmlChar *name) {
 3103|      8|    xmlElementTablePtr table;
 3104|      8|    xmlElementPtr cur;
 3105|      8|    xmlChar *uqname = NULL, *prefix = NULL;
 3106|       |
 3107|      8|    if ((dtd == NULL) || (name == NULL)) return(NULL);
  ------------------
  |  Branch (3107:9): [True: 0, False: 8]
  |  Branch (3107:26): [True: 0, False: 8]
  ------------------
 3108|      8|    if (dtd->elements == NULL)
  ------------------
  |  Branch (3108:9): [True: 0, False: 8]
  ------------------
 3109|      0|	return(NULL);
 3110|      8|    table = (xmlElementTablePtr) dtd->elements;
 3111|       |
 3112|      8|    uqname = xmlSplitQName2(name, &prefix);
 3113|      8|    if (uqname != NULL)
  ------------------
  |  Branch (3113:9): [True: 0, False: 8]
  ------------------
 3114|      0|        name = uqname;
 3115|      8|    cur = xmlHashLookup2(table, name, prefix);
 3116|      8|    if (prefix != NULL) xmlFree(prefix);
  ------------------
  |  Branch (3116:9): [True: 0, False: 8]
  ------------------
 3117|      8|    if (uqname != NULL) xmlFree(uqname);
  ------------------
  |  Branch (3117:9): [True: 0, False: 8]
  ------------------
 3118|      8|    return(cur);
 3119|      8|}
xmlGetDtdAttrDesc:
 3230|     38|xmlGetDtdAttrDesc(xmlDtdPtr dtd, const xmlChar *elem, const xmlChar *name) {
 3231|     38|    xmlAttributeTablePtr table;
 3232|     38|    xmlAttributePtr cur;
 3233|     38|    xmlChar *uqname = NULL, *prefix = NULL;
 3234|       |
 3235|     38|    if (dtd == NULL) return(NULL);
  ------------------
  |  Branch (3235:9): [True: 2, False: 36]
  ------------------
 3236|     36|    if (dtd->attributes == NULL) return(NULL);
  ------------------
  |  Branch (3236:9): [True: 0, False: 36]
  ------------------
 3237|       |
 3238|     36|    table = (xmlAttributeTablePtr) dtd->attributes;
 3239|     36|    if (table == NULL)
  ------------------
  |  Branch (3239:9): [True: 0, False: 36]
  ------------------
 3240|      0|	return(NULL);
 3241|       |
 3242|     36|    uqname = xmlSplitQName2(name, &prefix);
 3243|       |
 3244|     36|    if (uqname != NULL) {
  ------------------
  |  Branch (3244:9): [True: 2, False: 34]
  ------------------
 3245|      2|	cur = xmlHashLookup3(table, uqname, prefix, elem);
 3246|      2|	if (prefix != NULL) xmlFree(prefix);
  ------------------
  |  Branch (3246:6): [True: 2, False: 0]
  ------------------
 3247|      2|	if (uqname != NULL) xmlFree(uqname);
  ------------------
  |  Branch (3247:6): [True: 2, False: 0]
  ------------------
 3248|      2|    } else
 3249|     34|	cur = xmlHashLookup3(table, name, NULL, elem);
 3250|     36|    return(cur);
 3251|     36|}
xmlGetDtdQAttrDesc:
 3268|     12|	          const xmlChar *prefix) {
 3269|     12|    xmlAttributeTablePtr table;
 3270|       |
 3271|     12|    if (dtd == NULL) return(NULL);
  ------------------
  |  Branch (3271:9): [True: 0, False: 12]
  ------------------
 3272|     12|    if (dtd->attributes == NULL) return(NULL);
  ------------------
  |  Branch (3272:9): [True: 0, False: 12]
  ------------------
 3273|     12|    table = (xmlAttributeTablePtr) dtd->attributes;
 3274|       |
 3275|     12|    return(xmlHashLookup3(table, name, prefix, elem));
 3276|     12|}
xmlIsMixedElement:
 3345|     10|xmlIsMixedElement(xmlDocPtr doc, const xmlChar *name) {
 3346|     10|    xmlElementPtr elemDecl;
 3347|       |
 3348|     10|    if ((doc == NULL) || (doc->intSubset == NULL)) return(-1);
  ------------------
  |  Branch (3348:9): [True: 0, False: 10]
  |  Branch (3348:26): [True: 2, False: 8]
  ------------------
 3349|       |
 3350|      8|    elemDecl = xmlGetDtdElementDesc(doc->intSubset, name);
 3351|      8|    if ((elemDecl == NULL) && (doc->extSubset != NULL))
  ------------------
  |  Branch (3351:9): [True: 0, False: 8]
  |  Branch (3351:31): [True: 0, False: 0]
  ------------------
 3352|      0|	elemDecl = xmlGetDtdElementDesc(doc->extSubset, name);
 3353|      8|    if (elemDecl == NULL) return(-1);
  ------------------
  |  Branch (3353:9): [True: 0, False: 8]
  ------------------
 3354|      8|    switch (elemDecl->etype) {
  ------------------
  |  Branch (3354:13): [True: 0, False: 8]
  ------------------
 3355|      0|	case XML_ELEMENT_TYPE_UNDEFINED:
  ------------------
  |  Branch (3355:2): [True: 0, False: 8]
  ------------------
 3356|      0|	    return(-1);
 3357|      8|	case XML_ELEMENT_TYPE_ELEMENT:
  ------------------
  |  Branch (3357:2): [True: 8, False: 0]
  ------------------
 3358|      8|	    return(0);
 3359|      0|        case XML_ELEMENT_TYPE_EMPTY:
  ------------------
  |  Branch (3359:9): [True: 0, False: 8]
  ------------------
 3360|       |	    /*
 3361|       |	     * return 1 for EMPTY since we want VC error to pop up
 3362|       |	     * on <empty>     </empty> for example
 3363|       |	     */
 3364|      0|	case XML_ELEMENT_TYPE_ANY:
  ------------------
  |  Branch (3364:2): [True: 0, False: 8]
  ------------------
 3365|      0|	case XML_ELEMENT_TYPE_MIXED:
  ------------------
  |  Branch (3365:2): [True: 0, False: 8]
  ------------------
 3366|      0|	    return(1);
 3367|      8|    }
 3368|      0|    return(1);
 3369|      8|}
xmlValidCtxtNormalizeAttributeValue:
 3919|      4|	     xmlNodePtr elem, const xmlChar *name, const xmlChar *value) {
 3920|      4|    xmlChar *ret;
 3921|      4|    xmlAttributePtr attrDecl = NULL;
 3922|      4|    int extsubset = 0;
 3923|       |
 3924|      4|    if (doc == NULL) return(NULL);
  ------------------
  |  Branch (3924:9): [True: 0, False: 4]
  ------------------
 3925|      4|    if (elem == NULL) return(NULL);
  ------------------
  |  Branch (3925:9): [True: 0, False: 4]
  ------------------
 3926|      4|    if (name == NULL) return(NULL);
  ------------------
  |  Branch (3926:9): [True: 0, False: 4]
  ------------------
 3927|      4|    if (value == NULL) return(NULL);
  ------------------
  |  Branch (3927:9): [True: 0, False: 4]
  ------------------
 3928|       |
 3929|      4|    if ((elem->ns != NULL) && (elem->ns->prefix != NULL)) {
  ------------------
  |  Branch (3929:9): [True: 2, False: 2]
  |  Branch (3929:31): [True: 2, False: 0]
  ------------------
 3930|      2|	xmlChar fn[50];
 3931|      2|	xmlChar *fullname;
 3932|       |
 3933|      2|	fullname = xmlBuildQName(elem->name, elem->ns->prefix, fn, 50);
 3934|      2|	if (fullname == NULL)
  ------------------
  |  Branch (3934:6): [True: 0, False: 2]
  ------------------
 3935|      0|	    return(NULL);
 3936|      2|	attrDecl = xmlGetDtdAttrDesc(doc->intSubset, fullname, name);
 3937|      2|	if ((attrDecl == NULL) && (doc->extSubset != NULL)) {
  ------------------
  |  Branch (3937:6): [True: 2, False: 0]
  |  Branch (3937:28): [True: 0, False: 2]
  ------------------
 3938|      0|	    attrDecl = xmlGetDtdAttrDesc(doc->extSubset, fullname, name);
 3939|      0|	    if (attrDecl != NULL)
  ------------------
  |  Branch (3939:10): [True: 0, False: 0]
  ------------------
 3940|      0|		extsubset = 1;
 3941|      0|	}
 3942|      2|	if ((fullname != fn) && (fullname != elem->name))
  ------------------
  |  Branch (3942:6): [True: 0, False: 2]
  |  Branch (3942:26): [True: 0, False: 0]
  ------------------
 3943|      0|	    xmlFree(fullname);
 3944|      2|    }
 3945|      4|    if ((attrDecl == NULL) && (doc->intSubset != NULL))
  ------------------
  |  Branch (3945:9): [True: 4, False: 0]
  |  Branch (3945:31): [True: 0, False: 4]
  ------------------
 3946|      0|	attrDecl = xmlGetDtdAttrDesc(doc->intSubset, elem->name, name);
 3947|      4|    if ((attrDecl == NULL) && (doc->extSubset != NULL)) {
  ------------------
  |  Branch (3947:9): [True: 4, False: 0]
  |  Branch (3947:31): [True: 0, False: 4]
  ------------------
 3948|      0|	attrDecl = xmlGetDtdAttrDesc(doc->extSubset, elem->name, name);
 3949|      0|	if (attrDecl != NULL)
  ------------------
  |  Branch (3949:6): [True: 0, False: 0]
  ------------------
 3950|      0|	    extsubset = 1;
 3951|      0|    }
 3952|       |
 3953|      4|    if (attrDecl == NULL)
  ------------------
  |  Branch (3953:9): [True: 4, False: 0]
  ------------------
 3954|      4|	return(NULL);
 3955|      0|    if (attrDecl->atype == XML_ATTRIBUTE_CDATA)
  ------------------
  |  Branch (3955:9): [True: 0, False: 0]
  ------------------
 3956|      0|	return(NULL);
 3957|       |
 3958|      0|    ret = xmlStrdup(value);
 3959|      0|    if (ret == NULL)
  ------------------
  |  Branch (3959:9): [True: 0, False: 0]
  ------------------
 3960|      0|	return(NULL);
 3961|      0|    xmlValidNormalizeString(ret);
 3962|      0|    if ((doc->standalone) && (extsubset == 1) && (!xmlStrEqual(value, ret))) {
  ------------------
  |  Branch (3962:9): [True: 0, False: 0]
  |  Branch (3962:30): [True: 0, False: 0]
  |  Branch (3962:50): [True: 0, False: 0]
  ------------------
 3963|      0|	xmlErrValidNode(ctxt, elem, XML_DTD_NOT_STANDALONE,
 3964|      0|"standalone: %s on %s value had to be normalized based on external subset declaration\n",
 3965|      0|	       name, elem->name, NULL);
 3966|      0|	ctxt->valid = 0;
 3967|      0|    }
 3968|      0|    return(ret);
 3969|      0|}
valid.c:xmlFreeElement:
 1234|     22|xmlFreeElement(xmlElementPtr elem) {
 1235|     22|    if (elem == NULL) return;
  ------------------
  |  Branch (1235:9): [True: 0, False: 22]
  ------------------
 1236|     22|    xmlUnlinkNode((xmlNodePtr) elem);
 1237|     22|    xmlFreeDocElementContent(elem->doc, elem->content);
 1238|     22|    if (elem->name != NULL)
  ------------------
  |  Branch (1238:9): [True: 22, False: 0]
  ------------------
 1239|     22|	xmlFree((xmlChar *) elem->name);
 1240|     22|    if (elem->prefix != NULL)
  ------------------
  |  Branch (1240:9): [True: 0, False: 22]
  ------------------
 1241|      0|	xmlFree((xmlChar *) elem->prefix);
 1242|     22|#ifdef LIBXML_REGEXP_ENABLED
 1243|     22|    if (elem->contModel != NULL)
  ------------------
  |  Branch (1243:9): [True: 0, False: 22]
  ------------------
 1244|      0|	xmlRegFreeRegexp(elem->contModel);
 1245|     22|#endif
 1246|     22|    xmlFree(elem);
 1247|     22|}
valid.c:xmlFreeElementTableEntry:
 1475|     22|xmlFreeElementTableEntry(void *elem, const xmlChar *name ATTRIBUTE_UNUSED) {
 1476|     22|    xmlFreeElement((xmlElementPtr) elem);
 1477|     22|}
valid.c:xmlFreeAttribute:
 1759|      8|xmlFreeAttribute(xmlAttributePtr attr) {
 1760|      8|    xmlDictPtr dict;
 1761|       |
 1762|      8|    if (attr == NULL) return;
  ------------------
  |  Branch (1762:9): [True: 0, False: 8]
  ------------------
 1763|      8|    if (attr->doc != NULL)
  ------------------
  |  Branch (1763:9): [True: 8, False: 0]
  ------------------
 1764|      8|	dict = attr->doc->dict;
 1765|      0|    else
 1766|      0|	dict = NULL;
 1767|      8|    xmlUnlinkNode((xmlNodePtr) attr);
 1768|      8|    if (attr->tree != NULL)
  ------------------
  |  Branch (1768:9): [True: 0, False: 8]
  ------------------
 1769|      0|        xmlFreeEnumeration(attr->tree);
 1770|      8|    if (dict) {
  ------------------
  |  Branch (1770:9): [True: 8, False: 0]
  ------------------
 1771|      8|        if ((attr->elem != NULL) && (!xmlDictOwns(dict, attr->elem)))
  ------------------
  |  Branch (1771:13): [True: 8, False: 0]
  |  Branch (1771:37): [True: 0, False: 8]
  ------------------
 1772|      0|	    xmlFree((xmlChar *) attr->elem);
 1773|      8|        if ((attr->name != NULL) && (!xmlDictOwns(dict, attr->name)))
  ------------------
  |  Branch (1773:13): [True: 8, False: 0]
  |  Branch (1773:37): [True: 0, False: 8]
  ------------------
 1774|      0|	    xmlFree((xmlChar *) attr->name);
 1775|      8|        if ((attr->prefix != NULL) && (!xmlDictOwns(dict, attr->prefix)))
  ------------------
  |  Branch (1775:13): [True: 0, False: 8]
  |  Branch (1775:39): [True: 0, False: 0]
  ------------------
 1776|      0|	    xmlFree((xmlChar *) attr->prefix);
 1777|      8|        if ((attr->defaultValue != NULL) &&
  ------------------
  |  Branch (1777:13): [True: 0, False: 8]
  ------------------
 1778|      8|	    (!xmlDictOwns(dict, attr->defaultValue)))
  ------------------
  |  Branch (1778:6): [True: 0, False: 0]
  ------------------
 1779|      0|	    xmlFree((xmlChar *) attr->defaultValue);
 1780|      8|    } else {
 1781|      0|	if (attr->elem != NULL)
  ------------------
  |  Branch (1781:6): [True: 0, False: 0]
  ------------------
 1782|      0|	    xmlFree((xmlChar *) attr->elem);
 1783|      0|	if (attr->name != NULL)
  ------------------
  |  Branch (1783:6): [True: 0, False: 0]
  ------------------
 1784|      0|	    xmlFree((xmlChar *) attr->name);
 1785|      0|	if (attr->defaultValue != NULL)
  ------------------
  |  Branch (1785:6): [True: 0, False: 0]
  ------------------
 1786|      0|	    xmlFree((xmlChar *) attr->defaultValue);
 1787|      0|	if (attr->prefix != NULL)
  ------------------
  |  Branch (1787:6): [True: 0, False: 0]
  ------------------
 1788|      0|	    xmlFree((xmlChar *) attr->prefix);
 1789|      0|    }
 1790|      8|    xmlFree(attr);
 1791|      8|}
valid.c:xmlScanIDAttributeDecl:
 1732|      8|xmlScanIDAttributeDecl(xmlValidCtxtPtr ctxt, xmlElementPtr elem, int err) {
 1733|      8|    xmlAttributePtr cur;
 1734|      8|    int ret = 0;
 1735|       |
 1736|      8|    if (elem == NULL) return(0);
  ------------------
  |  Branch (1736:9): [True: 0, False: 8]
  ------------------
 1737|      8|    cur = elem->attributes;
 1738|      8|    while (cur != NULL) {
  ------------------
  |  Branch (1738:12): [True: 0, False: 8]
  ------------------
 1739|      0|        if (cur->atype == XML_ATTRIBUTE_ID) {
  ------------------
  |  Branch (1739:13): [True: 0, False: 0]
  ------------------
 1740|      0|	    ret ++;
 1741|      0|	    if ((ret > 1) && (err))
  ------------------
  |  Branch (1741:10): [True: 0, False: 0]
  |  Branch (1741:23): [True: 0, False: 0]
  ------------------
 1742|      0|		xmlErrValidNode(ctxt, (xmlNodePtr) elem, XML_DTD_MULTIPLE_ID,
 1743|      0|	       "Element %s has too many ID attributes defined : %s\n",
 1744|      0|		       elem->name, cur->name, NULL);
 1745|      0|	}
 1746|      0|	cur = cur->nexth;
 1747|      0|    }
 1748|      8|    return(ret);
 1749|      8|}
valid.c:xmlFreeAttributeTableEntry:
 2027|      8|xmlFreeAttributeTableEntry(void *attr, const xmlChar *name ATTRIBUTE_UNUSED) {
 2028|      8|    xmlFreeAttribute((xmlAttributePtr) attr);
 2029|      8|}
valid.c:xmlIsStreaming:
 2471|     38|xmlIsStreaming(xmlValidCtxtPtr ctxt) {
 2472|     38|    xmlParserCtxtPtr pctxt;
 2473|       |
 2474|     38|    if (ctxt == NULL)
  ------------------
  |  Branch (2474:9): [True: 8, False: 30]
  ------------------
 2475|      8|        return(0);
 2476|     30|    if ((ctxt->flags & XML_VCTXT_USE_PCTXT) == 0)
  ------------------
  |  |   18|     30|#define XML_VCTXT_USE_PCTXT (1u << 1)
  ------------------
  |  Branch (2476:9): [True: 0, False: 30]
  ------------------
 2477|      0|        return(0);
 2478|     30|    pctxt = ctxt->userData;
 2479|     30|    return(pctxt->parseMode == XML_PARSE_READER);
 2480|     30|}
valid.c:xmlFreeID:
 2489|     38|xmlFreeID(xmlIDPtr id) {
 2490|     38|    xmlDictPtr dict = NULL;
 2491|       |
 2492|     38|    if (id == NULL) return;
  ------------------
  |  Branch (2492:9): [True: 0, False: 38]
  ------------------
 2493|       |
 2494|     38|    if (id->doc != NULL)
  ------------------
  |  Branch (2494:9): [True: 38, False: 0]
  ------------------
 2495|     38|        dict = id->doc->dict;
 2496|       |
 2497|     38|    if (id->value != NULL)
  ------------------
  |  Branch (2497:9): [True: 38, False: 0]
  ------------------
 2498|     38|	DICT_FREE(id->value)
  ------------------
  |  | 2437|     38|	if ((str) && ((!dict) ||				\
  |  |  ------------------
  |  |  |  Branch (2437:6): [True: 38, False: 0]
  |  |  |  Branch (2437:16): [True: 0, False: 38]
  |  |  ------------------
  |  | 2438|     38|	    (xmlDictOwns(dict, (const xmlChar *)(str)) == 0)))	\
  |  |  ------------------
  |  |  |  Branch (2438:6): [True: 38, False: 0]
  |  |  ------------------
  |  | 2439|     38|	    xmlFree((char *)(str));
  ------------------
 2499|     38|    if (id->name != NULL)
  ------------------
  |  Branch (2499:9): [True: 12, False: 26]
  ------------------
 2500|     12|	DICT_FREE(id->name)
  ------------------
  |  | 2437|     12|	if ((str) && ((!dict) ||				\
  |  |  ------------------
  |  |  |  Branch (2437:6): [True: 12, False: 0]
  |  |  |  Branch (2437:16): [True: 0, False: 12]
  |  |  ------------------
  |  | 2438|     12|	    (xmlDictOwns(dict, (const xmlChar *)(str)) == 0)))	\
  |  |  ------------------
  |  |  |  Branch (2438:6): [True: 0, False: 12]
  |  |  ------------------
  |  | 2439|     12|	    xmlFree((char *)(str));
  ------------------
 2501|     38|    xmlFree(id);
 2502|     38|}
valid.c:xmlFreeIDTableEntry:
 2590|     34|xmlFreeIDTableEntry(void *id, const xmlChar *name ATTRIBUTE_UNUSED) {
 2591|     34|    xmlFreeID((xmlIDPtr) id);
 2592|     34|}
valid.c:xmlGetDtdElementDesc2:
 3133|      8|                      int create) {
 3134|      8|    xmlElementTablePtr table;
 3135|      8|    xmlElementPtr cur;
 3136|      8|    xmlChar *uqname = NULL, *prefix = NULL;
 3137|       |
 3138|      8|    if (dtd == NULL) return(NULL);
  ------------------
  |  Branch (3138:9): [True: 0, False: 8]
  ------------------
 3139|      8|    if (dtd->elements == NULL) {
  ------------------
  |  Branch (3139:9): [True: 0, False: 8]
  ------------------
 3140|      0|	xmlDictPtr dict = NULL;
 3141|       |
 3142|      0|	if (dtd->doc != NULL)
  ------------------
  |  Branch (3142:6): [True: 0, False: 0]
  ------------------
 3143|      0|	    dict = dtd->doc->dict;
 3144|       |
 3145|      0|	if (!create)
  ------------------
  |  Branch (3145:6): [True: 0, False: 0]
  ------------------
 3146|      0|	    return(NULL);
 3147|       |	/*
 3148|       |	 * Create the Element table if needed.
 3149|       |	 */
 3150|      0|	table = (xmlElementTablePtr) dtd->elements;
 3151|      0|	if (table == NULL) {
  ------------------
  |  Branch (3151:6): [True: 0, False: 0]
  ------------------
 3152|      0|	    table = xmlHashCreateDict(0, dict);
 3153|      0|	    dtd->elements = (void *) table;
 3154|      0|	}
 3155|      0|	if (table == NULL) {
  ------------------
  |  Branch (3155:6): [True: 0, False: 0]
  ------------------
 3156|      0|	    xmlVErrMemory(ctxt, "element table allocation failed");
 3157|      0|	    return(NULL);
 3158|      0|	}
 3159|      0|    }
 3160|      8|    table = (xmlElementTablePtr) dtd->elements;
 3161|       |
 3162|      8|    uqname = xmlSplitQName2(name, &prefix);
 3163|      8|    if (uqname != NULL)
  ------------------
  |  Branch (3163:9): [True: 0, False: 8]
  ------------------
 3164|      0|        name = uqname;
 3165|      8|    cur = xmlHashLookup2(table, name, prefix);
 3166|      8|    if ((cur == NULL) && (create)) {
  ------------------
  |  Branch (3166:9): [True: 0, False: 8]
  |  Branch (3166:26): [True: 0, False: 0]
  ------------------
 3167|      0|	cur = (xmlElementPtr) xmlMalloc(sizeof(xmlElement));
 3168|      0|	if (cur == NULL) {
  ------------------
  |  Branch (3168:6): [True: 0, False: 0]
  ------------------
 3169|      0|	    xmlVErrMemory(ctxt, "malloc failed");
 3170|      0|	    goto error;
 3171|      0|	}
 3172|      0|	memset(cur, 0, sizeof(xmlElement));
 3173|      0|	cur->type = XML_ELEMENT_DECL;
 3174|       |
 3175|       |	/*
 3176|       |	 * fill the structure.
 3177|       |	 */
 3178|      0|	cur->name = xmlStrdup(name);
 3179|      0|	cur->prefix = xmlStrdup(prefix);
 3180|      0|	cur->etype = XML_ELEMENT_TYPE_UNDEFINED;
 3181|       |
 3182|      0|	if (xmlHashAddEntry2(table, name, prefix, cur) < 0) {
  ------------------
  |  Branch (3182:6): [True: 0, False: 0]
  ------------------
 3183|      0|	    xmlVErrMemory(ctxt, "adding entry failed");
 3184|      0|            xmlFreeElement(cur);
 3185|      0|            cur = NULL;
 3186|      0|        }
 3187|      0|    }
 3188|      8|error:
 3189|      8|    if (prefix != NULL) xmlFree(prefix);
  ------------------
  |  Branch (3189:9): [True: 0, False: 8]
  ------------------
 3190|      8|    if (uqname != NULL) xmlFree(uqname);
  ------------------
  |  Branch (3190:9): [True: 0, False: 8]
  ------------------
 3191|      8|    return(cur);
 3192|      8|}

xmlXIncludeNewContext:
  284|     87|xmlXIncludeNewContext(xmlDocPtr doc) {
  285|     87|    xmlXIncludeCtxtPtr ret;
  286|       |
  287|     87|    if (doc == NULL)
  ------------------
  |  Branch (287:9): [True: 0, False: 87]
  ------------------
  288|      0|	return(NULL);
  289|     87|    ret = (xmlXIncludeCtxtPtr) xmlMalloc(sizeof(xmlXIncludeCtxt));
  290|     87|    if (ret == NULL) {
  ------------------
  |  Branch (290:9): [True: 0, False: 87]
  ------------------
  291|      0|	xmlXIncludeErrMemory(NULL, (xmlNodePtr) doc,
  292|      0|	                     "creating XInclude context");
  293|      0|	return(NULL);
  294|      0|    }
  295|     87|    memset(ret, 0, sizeof(xmlXIncludeCtxt));
  296|     87|    ret->doc = doc;
  297|     87|    ret->incNr = 0;
  298|     87|    ret->incMax = 0;
  299|     87|    ret->incTab = NULL;
  300|     87|    ret->nbErrors = 0;
  301|     87|    return(ret);
  302|     87|}
xmlXIncludeFreeContext:
  311|     87|xmlXIncludeFreeContext(xmlXIncludeCtxtPtr ctxt) {
  312|     87|    int i;
  313|       |
  314|     87|    if (ctxt == NULL)
  ------------------
  |  Branch (314:9): [True: 0, False: 87]
  ------------------
  315|      0|	return;
  316|     87|    if (ctxt->urlTab != NULL) {
  ------------------
  |  Branch (316:9): [True: 52, False: 35]
  ------------------
  317|    162|	for (i = 0; i < ctxt->urlNr; i++) {
  ------------------
  |  Branch (317:14): [True: 110, False: 52]
  ------------------
  318|    110|	    xmlFreeDoc(ctxt->urlTab[i].doc);
  319|    110|	    xmlFree(ctxt->urlTab[i].url);
  320|    110|	}
  321|     52|	xmlFree(ctxt->urlTab);
  322|     52|    }
  323|    211|    for (i = 0;i < ctxt->incNr;i++) {
  ------------------
  |  Branch (323:16): [True: 124, False: 87]
  ------------------
  324|    124|	if (ctxt->incTab[i] != NULL)
  ------------------
  |  Branch (324:6): [True: 124, False: 0]
  ------------------
  325|    124|	    xmlXIncludeFreeRef(ctxt->incTab[i]);
  326|    124|    }
  327|     87|    if (ctxt->incTab != NULL)
  ------------------
  |  Branch (327:9): [True: 69, False: 18]
  ------------------
  328|     69|	xmlFree(ctxt->incTab);
  329|     87|    if (ctxt->txtTab != NULL) {
  ------------------
  |  Branch (329:9): [True: 8, False: 79]
  ------------------
  330|     16|	for (i = 0;i < ctxt->txtNr;i++) {
  ------------------
  |  Branch (330:13): [True: 8, False: 8]
  ------------------
  331|      8|	    xmlFree(ctxt->txtTab[i].text);
  332|      8|	    xmlFree(ctxt->txtTab[i].url);
  333|      8|	}
  334|      8|	xmlFree(ctxt->txtTab);
  335|      8|    }
  336|     87|    if (ctxt->base != NULL) {
  ------------------
  |  Branch (336:9): [True: 41, False: 46]
  ------------------
  337|     41|        xmlFree(ctxt->base);
  338|     41|    }
  339|     87|    xmlFree(ctxt);
  340|     87|}
xmlXIncludeSetFlags:
 2309|     87|xmlXIncludeSetFlags(xmlXIncludeCtxtPtr ctxt, int flags) {
 2310|     87|    if (ctxt == NULL)
  ------------------
  |  Branch (2310:9): [True: 0, False: 87]
  ------------------
 2311|      0|        return(-1);
 2312|     87|    ctxt->parseFlags = flags;
 2313|     87|    return(0);
 2314|     87|}
xmlXIncludeSetStreamingMode:
 2326|     46|xmlXIncludeSetStreamingMode(xmlXIncludeCtxtPtr ctxt, int mode) {
 2327|     46|    if (ctxt == NULL)
  ------------------
  |  Branch (2327:9): [True: 0, False: 46]
  ------------------
 2328|      0|        return(-1);
 2329|     46|    ctxt->isStream = !!mode;
 2330|     46|    return(0);
 2331|     46|}
xmlXIncludeProcessTreeFlagsData:
 2347|     41|xmlXIncludeProcessTreeFlagsData(xmlNodePtr tree, int flags, void *data) {
 2348|     41|    xmlXIncludeCtxtPtr ctxt;
 2349|     41|    int ret = 0;
 2350|       |
 2351|     41|    if ((tree == NULL) || (tree->type == XML_NAMESPACE_DECL) ||
  ------------------
  |  Branch (2351:9): [True: 0, False: 41]
  |  Branch (2351:27): [True: 0, False: 41]
  ------------------
 2352|     41|        (tree->doc == NULL))
  ------------------
  |  Branch (2352:9): [True: 0, False: 41]
  ------------------
 2353|      0|        return(-1);
 2354|       |
 2355|     41|    ctxt = xmlXIncludeNewContext(tree->doc);
 2356|     41|    if (ctxt == NULL)
  ------------------
  |  Branch (2356:9): [True: 0, False: 41]
  ------------------
 2357|      0|        return(-1);
 2358|     41|    ctxt->_private = data;
 2359|     41|    ctxt->base = xmlStrdup((xmlChar *)tree->doc->URL);
 2360|     41|    xmlXIncludeSetFlags(ctxt, flags);
 2361|     41|    ret = xmlXIncludeDoProcess(ctxt, tree);
 2362|     41|    if ((ret >= 0) && (ctxt->nbErrors > 0))
  ------------------
  |  Branch (2362:9): [True: 41, False: 0]
  |  Branch (2362:23): [True: 10, False: 31]
  ------------------
 2363|     10|        ret = -1;
 2364|       |
 2365|     41|    xmlXIncludeFreeContext(ctxt);
 2366|     41|    return(ret);
 2367|     41|}
xmlXIncludeProcessFlagsData:
 2382|    167|xmlXIncludeProcessFlagsData(xmlDocPtr doc, int flags, void *data) {
 2383|    167|    xmlNodePtr tree;
 2384|       |
 2385|    167|    if (doc == NULL)
  ------------------
  |  Branch (2385:9): [True: 126, False: 41]
  ------------------
 2386|    126|	return(-1);
 2387|     41|    tree = xmlDocGetRootElement(doc);
 2388|     41|    if (tree == NULL)
  ------------------
  |  Branch (2388:9): [True: 0, False: 41]
  ------------------
 2389|      0|	return(-1);
 2390|     41|    return(xmlXIncludeProcessTreeFlagsData(tree, flags, data));
 2391|     41|}
xmlXIncludeProcessFlags:
 2404|    167|xmlXIncludeProcessFlags(xmlDocPtr doc, int flags) {
 2405|    167|    return xmlXIncludeProcessFlagsData(doc, flags, NULL);
 2406|    167|}
xmlXIncludeProcessNode:
 2479|    361|xmlXIncludeProcessNode(xmlXIncludeCtxtPtr ctxt, xmlNodePtr node) {
 2480|    361|    int ret = 0;
 2481|       |
 2482|    361|    if ((node == NULL) || (node->type == XML_NAMESPACE_DECL) ||
  ------------------
  |  Branch (2482:9): [True: 0, False: 361]
  |  Branch (2482:27): [True: 0, False: 361]
  ------------------
 2483|    361|        (node->doc == NULL) || (ctxt == NULL))
  ------------------
  |  Branch (2483:9): [True: 0, False: 361]
  |  Branch (2483:32): [True: 0, False: 361]
  ------------------
 2484|      0|	return(-1);
 2485|    361|    ret = xmlXIncludeDoProcess(ctxt, node);
 2486|    361|    if ((ret >= 0) && (ctxt->nbErrors > 0))
  ------------------
  |  Branch (2486:9): [True: 361, False: 0]
  |  Branch (2486:23): [True: 338, False: 23]
  ------------------
 2487|    338|	ret = -1;
 2488|    361|    return(ret);
 2489|    361|}
xinclude.c:xmlXIncludeFreeRef:
  214|    200|xmlXIncludeFreeRef(xmlXIncludeRefPtr ref) {
  215|    200|    if (ref == NULL)
  ------------------
  |  Branch (215:9): [True: 0, False: 200]
  ------------------
  216|      0|	return;
  217|    200|    if (ref->URI != NULL)
  ------------------
  |  Branch (217:9): [True: 200, False: 0]
  ------------------
  218|    200|	xmlFree(ref->URI);
  219|    200|    if (ref->fragment != NULL)
  ------------------
  |  Branch (219:9): [True: 94, False: 106]
  ------------------
  220|     94|	xmlFree(ref->fragment);
  221|    200|    xmlFree(ref);
  222|    200|}
xinclude.c:xmlXIncludeDoProcess:
 2219|    420|xmlXIncludeDoProcess(xmlXIncludeCtxtPtr ctxt, xmlNodePtr tree) {
 2220|    420|    xmlXIncludeRefPtr ref;
 2221|    420|    xmlNodePtr cur;
 2222|    420|    int ret = 0;
 2223|    420|    int i, start;
 2224|       |
 2225|    420|    if ((tree == NULL) || (tree->type == XML_NAMESPACE_DECL))
  ------------------
  |  Branch (2225:9): [True: 0, False: 420]
  |  Branch (2225:27): [True: 0, False: 420]
  ------------------
 2226|      0|	return(-1);
 2227|    420|    if (ctxt == NULL)
  ------------------
  |  Branch (2227:9): [True: 0, False: 420]
  ------------------
 2228|      0|	return(-1);
 2229|       |
 2230|       |    /*
 2231|       |     * First phase: lookup the elements in the document
 2232|       |     */
 2233|    420|    start = ctxt->incNr;
 2234|    420|    cur = tree;
 2235|  1.70k|    do {
 2236|       |	/* TODO: need to work on entities -> stack */
 2237|  1.70k|        if (xmlXIncludeTestNode(ctxt, cur) == 1) {
  ------------------
  |  Branch (2237:13): [True: 708, False: 994]
  ------------------
 2238|    708|            ref = xmlXIncludeExpandNode(ctxt, cur);
 2239|       |            /*
 2240|       |             * Mark direct includes.
 2241|       |             */
 2242|    708|            if (ref != NULL)
  ------------------
  |  Branch (2242:17): [True: 85, False: 623]
  ------------------
 2243|     85|                ref->replace = 1;
 2244|    994|        } else if ((cur->children != NULL) &&
  ------------------
  |  Branch (2244:20): [True: 419, False: 575]
  ------------------
 2245|    994|                   ((cur->type == XML_DOCUMENT_NODE) ||
  ------------------
  |  Branch (2245:21): [True: 0, False: 419]
  ------------------
 2246|    419|                    (cur->type == XML_ELEMENT_NODE))) {
  ------------------
  |  Branch (2246:21): [True: 419, False: 0]
  ------------------
 2247|    419|            cur = cur->children;
 2248|    419|            continue;
 2249|    419|        }
 2250|  1.70k|        do {
 2251|  1.70k|            if (cur == tree)
  ------------------
  |  Branch (2251:17): [True: 420, False: 1.28k]
  ------------------
 2252|    420|                break;
 2253|  1.28k|            if (cur->next != NULL) {
  ------------------
  |  Branch (2253:17): [True: 863, False: 419]
  ------------------
 2254|    863|                cur = cur->next;
 2255|    863|                break;
 2256|    863|            }
 2257|    419|            cur = cur->parent;
 2258|    419|        } while (cur != NULL);
  ------------------
  |  Branch (2258:18): [True: 419, False: 0]
  ------------------
 2259|  1.70k|    } while ((cur != NULL) && (cur != tree));
  ------------------
  |  Branch (2259:14): [True: 1.70k, False: 0]
  |  Branch (2259:31): [True: 1.28k, False: 420]
  ------------------
 2260|       |
 2261|       |    /*
 2262|       |     * Second phase: extend the original document infoset.
 2263|       |     */
 2264|    620|    for (i = start; i < ctxt->incNr; i++) {
  ------------------
  |  Branch (2264:21): [True: 200, False: 420]
  ------------------
 2265|    200|	if (ctxt->incTab[i]->replace != 0) {
  ------------------
  |  Branch (2265:6): [True: 85, False: 115]
  ------------------
 2266|     85|            if ((ctxt->incTab[i]->inc != NULL) ||
  ------------------
  |  Branch (2266:17): [True: 63, False: 22]
  ------------------
 2267|     85|                (ctxt->incTab[i]->emptyFb != 0)) {	/* (empty fallback) */
  ------------------
  |  Branch (2267:17): [True: 2, False: 20]
  ------------------
 2268|     65|                xmlXIncludeIncludeNode(ctxt, ctxt->incTab[i]);
 2269|     65|            }
 2270|     85|            ctxt->incTab[i]->replace = 0;
 2271|    115|        } else {
 2272|       |            /*
 2273|       |             * Ignore includes which were added indirectly, for example
 2274|       |             * inside xi:fallback elements.
 2275|       |             */
 2276|    115|            if (ctxt->incTab[i]->inc != NULL) {
  ------------------
  |  Branch (2276:17): [True: 108, False: 7]
  ------------------
 2277|    108|                xmlFreeNodeList(ctxt->incTab[i]->inc);
 2278|    108|                ctxt->incTab[i]->inc = NULL;
 2279|    108|            }
 2280|    115|        }
 2281|    200|	ret++;
 2282|    200|    }
 2283|       |
 2284|    420|    if (ctxt->isStream) {
  ------------------
  |  Branch (2284:9): [True: 361, False: 59]
  ------------------
 2285|       |        /*
 2286|       |         * incTab references nodes which will eventually be deleted in
 2287|       |         * streaming mode. The table is only required for XPointer
 2288|       |         * expressions which aren't allowed in streaming mode.
 2289|       |         */
 2290|    433|        for (i = 0;i < ctxt->incNr;i++) {
  ------------------
  |  Branch (2290:20): [True: 72, False: 361]
  ------------------
 2291|     72|            xmlXIncludeFreeRef(ctxt->incTab[i]);
 2292|     72|        }
 2293|    361|        ctxt->incNr = 0;
 2294|    361|    }
 2295|       |
 2296|    420|    return(ret);
 2297|    420|}
xinclude.c:xmlXIncludeTestNode:
 2142|  1.70k|xmlXIncludeTestNode(xmlXIncludeCtxtPtr ctxt, xmlNodePtr node) {
 2143|  1.70k|    if (node == NULL)
  ------------------
  |  Branch (2143:9): [True: 0, False: 1.70k]
  ------------------
 2144|      0|	return(0);
 2145|  1.70k|    if (node->type != XML_ELEMENT_NODE)
  ------------------
  |  Branch (2145:9): [True: 548, False: 1.15k]
  ------------------
 2146|    548|	return(0);
 2147|  1.15k|    if (node->ns == NULL)
  ------------------
  |  Branch (2147:9): [True: 425, False: 729]
  ------------------
 2148|    425|	return(0);
 2149|    729|    if ((xmlStrEqual(node->ns->href, XINCLUDE_NS)) ||
  ------------------
  |  |   30|    729|#define XINCLUDE_NS (const xmlChar *) "http://www.w3.org/2003/XInclude"
  ------------------
  |  Branch (2149:9): [True: 4, False: 725]
  ------------------
 2150|    729|        (xmlStrEqual(node->ns->href, XINCLUDE_OLD_NS))) {
  ------------------
  |  |   36|    725|#define XINCLUDE_OLD_NS (const xmlChar *) "http://www.w3.org/2001/XInclude"
  ------------------
  |  Branch (2150:9): [True: 712, False: 13]
  ------------------
 2151|    716|	if (xmlStrEqual(node->ns->href, XINCLUDE_OLD_NS)) {
  ------------------
  |  |   36|    716|#define XINCLUDE_OLD_NS (const xmlChar *) "http://www.w3.org/2001/XInclude"
  ------------------
  |  Branch (2151:6): [True: 712, False: 4]
  ------------------
 2152|    712|	    if (ctxt->legacy == 0) {
  ------------------
  |  Branch (2152:10): [True: 77, False: 635]
  ------------------
 2153|       |#if 0 /* wait for the XML Core Working Group to get something stable ! */
 2154|       |		xmlXIncludeWarn(ctxt, node, XML_XINCLUDE_DEPRECATED_NS,
 2155|       |	               "Deprecated XInclude namespace found, use %s",
 2156|       |		                XINCLUDE_NS);
 2157|       |#endif
 2158|     77|	        ctxt->legacy = 1;
 2159|     77|	    }
 2160|    712|	}
 2161|    716|	if (xmlStrEqual(node->name, XINCLUDE_NODE)) {
  ------------------
  |  |   42|    716|#define XINCLUDE_NODE (const xmlChar *) "include"
  ------------------
  |  Branch (2161:6): [True: 708, False: 8]
  ------------------
 2162|    708|	    xmlNodePtr child = node->children;
 2163|    708|	    int nb_fallback = 0;
 2164|       |
 2165|    797|	    while (child != NULL) {
  ------------------
  |  Branch (2165:13): [True: 89, False: 708]
  ------------------
 2166|     89|		if ((child->type == XML_ELEMENT_NODE) &&
  ------------------
  |  Branch (2166:7): [True: 30, False: 59]
  ------------------
 2167|     89|		    (child->ns != NULL) &&
  ------------------
  |  Branch (2167:7): [True: 30, False: 0]
  ------------------
 2168|     89|		    ((xmlStrEqual(child->ns->href, XINCLUDE_NS)) ||
  ------------------
  |  |   30|     30|#define XINCLUDE_NS (const xmlChar *) "http://www.w3.org/2003/XInclude"
  ------------------
  |  Branch (2168:8): [True: 0, False: 30]
  ------------------
 2169|     30|		     (xmlStrEqual(child->ns->href, XINCLUDE_OLD_NS)))) {
  ------------------
  |  |   36|     30|#define XINCLUDE_OLD_NS (const xmlChar *) "http://www.w3.org/2001/XInclude"
  ------------------
  |  Branch (2169:8): [True: 30, False: 0]
  ------------------
 2170|     30|		    if (xmlStrEqual(child->name, XINCLUDE_NODE)) {
  ------------------
  |  |   42|     30|#define XINCLUDE_NODE (const xmlChar *) "include"
  ------------------
  |  Branch (2170:11): [True: 0, False: 30]
  ------------------
 2171|      0|			xmlXIncludeErr(ctxt, node,
 2172|      0|			               XML_XINCLUDE_INCLUDE_IN_INCLUDE,
 2173|      0|				       "%s has an 'include' child\n",
 2174|      0|				       XINCLUDE_NODE);
  ------------------
  |  |   42|      0|#define XINCLUDE_NODE (const xmlChar *) "include"
  ------------------
 2175|      0|			return(0);
 2176|      0|		    }
 2177|     30|		    if (xmlStrEqual(child->name, XINCLUDE_FALLBACK)) {
  ------------------
  |  |   48|     30|#define XINCLUDE_FALLBACK (const xmlChar *) "fallback"
  ------------------
  |  Branch (2177:11): [True: 30, False: 0]
  ------------------
 2178|     30|			nb_fallback++;
 2179|     30|		    }
 2180|     30|		}
 2181|     89|		child = child->next;
 2182|     89|	    }
 2183|    708|	    if (nb_fallback > 1) {
  ------------------
  |  Branch (2183:10): [True: 0, False: 708]
  ------------------
 2184|      0|		xmlXIncludeErr(ctxt, node, XML_XINCLUDE_FALLBACKS_IN_INCLUDE,
 2185|      0|			       "%s has multiple fallback children\n",
 2186|      0|		               XINCLUDE_NODE);
  ------------------
  |  |   42|      0|#define XINCLUDE_NODE (const xmlChar *) "include"
  ------------------
 2187|      0|		return(0);
 2188|      0|	    }
 2189|    708|	    return(1);
 2190|    708|	}
 2191|      8|	if (xmlStrEqual(node->name, XINCLUDE_FALLBACK)) {
  ------------------
  |  |   48|      8|#define XINCLUDE_FALLBACK (const xmlChar *) "fallback"
  ------------------
  |  Branch (2191:6): [True: 6, False: 2]
  ------------------
 2192|      6|	    if ((node->parent == NULL) ||
  ------------------
  |  Branch (2192:10): [True: 0, False: 6]
  ------------------
 2193|      6|		(node->parent->type != XML_ELEMENT_NODE) ||
  ------------------
  |  Branch (2193:3): [True: 0, False: 6]
  ------------------
 2194|      6|		(node->parent->ns == NULL) ||
  ------------------
  |  Branch (2194:3): [True: 0, False: 6]
  ------------------
 2195|      6|		((!xmlStrEqual(node->parent->ns->href, XINCLUDE_NS)) &&
  ------------------
  |  |   30|      6|#define XINCLUDE_NS (const xmlChar *) "http://www.w3.org/2003/XInclude"
  ------------------
  |  Branch (2195:4): [True: 6, False: 0]
  ------------------
 2196|      6|		 (!xmlStrEqual(node->parent->ns->href, XINCLUDE_OLD_NS))) ||
  ------------------
  |  |   36|      6|#define XINCLUDE_OLD_NS (const xmlChar *) "http://www.w3.org/2001/XInclude"
  ------------------
  |  Branch (2196:4): [True: 0, False: 6]
  ------------------
 2197|      6|		(!xmlStrEqual(node->parent->name, XINCLUDE_NODE))) {
  ------------------
  |  |   42|      6|#define XINCLUDE_NODE (const xmlChar *) "include"
  ------------------
  |  Branch (2197:3): [True: 0, False: 6]
  ------------------
 2198|      0|		xmlXIncludeErr(ctxt, node,
 2199|      0|		               XML_XINCLUDE_FALLBACK_NOT_IN_INCLUDE,
 2200|      0|			       "%s is not the child of an 'include'\n",
 2201|      0|			       XINCLUDE_FALLBACK);
  ------------------
  |  |   48|      0|#define XINCLUDE_FALLBACK (const xmlChar *) "fallback"
  ------------------
 2202|      0|	    }
 2203|      6|	}
 2204|      8|    }
 2205|     21|    return(0);
 2206|    729|}
xinclude.c:xmlXIncludeErr:
  151|    112|{
  152|    112|    if (ctxt != NULL)
  ------------------
  |  Branch (152:9): [True: 112, False: 0]
  ------------------
  153|    112|	ctxt->nbErrors++;
  154|    112|    __xmlRaiseError(NULL, NULL, NULL, ctxt, node, XML_FROM_XINCLUDE,
  155|    112|                    error, XML_ERR_ERROR, NULL, 0,
  156|    112|		    (const char *) extra, NULL, NULL, 0, 0,
  157|    112|		    msg, (const char *) extra);
  158|    112|}
xinclude.c:xmlXIncludeExpandNode:
 1826|    836|xmlXIncludeExpandNode(xmlXIncludeCtxtPtr ctxt, xmlNodePtr node) {
 1827|    836|    xmlXIncludeRefPtr ref;
 1828|    836|    int i;
 1829|       |
 1830|    836|    if (ctxt->fatalErr)
  ------------------
  |  Branch (1830:9): [True: 0, False: 836]
  ------------------
 1831|      0|        return(NULL);
 1832|    836|    if (ctxt->depth >= XINCLUDE_MAX_DEPTH) {
  ------------------
  |  |   34|    836|#define XINCLUDE_MAX_DEPTH 40
  ------------------
  |  Branch (1832:9): [True: 0, False: 836]
  ------------------
 1833|      0|        xmlXIncludeErr(ctxt, node, XML_XINCLUDE_RECURSION,
 1834|      0|                       "maximum recursion depth exceeded\n", NULL);
 1835|      0|        ctxt->fatalErr = 1;
 1836|      0|        return(NULL);
 1837|      0|    }
 1838|       |
 1839|    836|#ifdef FUZZING_BUILD_MODE_UNSAFE_FOR_PRODUCTION
 1840|       |    /*
 1841|       |     * The XInclude engine offers no protection against exponential
 1842|       |     * expansion attacks similar to "billion laughs". Avoid timeouts by
 1843|       |     * limiting the total number of replacements when fuzzing.
 1844|       |     *
 1845|       |     * Unfortuately, a single XInclude can already result in quadratic
 1846|       |     * behavior:
 1847|       |     *
 1848|       |     *     <doc xmlns:xi="http://www.w3.org/2001/XInclude">
 1849|       |     *       <xi:include xpointer="xpointer(//e)"/>
 1850|       |     *       <e>
 1851|       |     *         <e>
 1852|       |     *           <e>
 1853|       |     *             <!-- more nested elements -->
 1854|       |     *           </e>
 1855|       |     *         </e>
 1856|       |     *       </e>
 1857|       |     *     </doc>
 1858|       |     */
 1859|    836|    if (ctxt->incTotal >= 20)
  ------------------
  |  Branch (1859:9): [True: 544, False: 292]
  ------------------
 1860|    544|        return(NULL);
 1861|    292|    ctxt->incTotal++;
 1862|    292|#endif
 1863|       |
 1864|  1.20k|    for (i = 0; i < ctxt->incNr; i++) {
  ------------------
  |  Branch (1864:17): [True: 922, False: 285]
  ------------------
 1865|    922|        if (ctxt->incTab[i]->elem == node) {
  ------------------
  |  Branch (1865:13): [True: 7, False: 915]
  ------------------
 1866|      7|            if (ctxt->incTab[i]->expanding) {
  ------------------
  |  Branch (1866:17): [True: 1, False: 6]
  ------------------
 1867|      1|                xmlXIncludeErr(ctxt, node, XML_XINCLUDE_RECURSION,
 1868|      1|                               "inclusion loop detected\n", NULL);
 1869|      1|                return(NULL);
 1870|      1|            }
 1871|      6|            return(ctxt->incTab[i]);
 1872|      7|        }
 1873|    922|    }
 1874|       |
 1875|    285|    ref = xmlXIncludeAddNode(ctxt, node);
 1876|    285|    if (ref == NULL)
  ------------------
  |  Branch (1876:9): [True: 85, False: 200]
  ------------------
 1877|     85|        return(NULL);
 1878|    200|    ref->expanding = 1;
 1879|    200|    ctxt->depth++;
 1880|    200|    xmlXIncludeLoadNode(ctxt, ref);
 1881|    200|    ctxt->depth--;
 1882|    200|    ref->expanding = 0;
 1883|       |
 1884|    200|    return(ref);
 1885|    285|}
xinclude.c:xmlXIncludeAddNode:
  422|    285|xmlXIncludeAddNode(xmlXIncludeCtxtPtr ctxt, xmlNodePtr cur) {
  423|    285|    xmlXIncludeRefPtr ref;
  424|    285|    xmlURIPtr uri;
  425|    285|    xmlChar *URL;
  426|    285|    xmlChar *fragment = NULL;
  427|    285|    xmlChar *href;
  428|    285|    xmlChar *parse;
  429|    285|    xmlChar *base;
  430|    285|    xmlChar *URI;
  431|    285|    int xml = 1;
  432|    285|    int local = 0;
  433|       |
  434|       |
  435|    285|    if (ctxt == NULL)
  ------------------
  |  Branch (435:9): [True: 0, False: 285]
  ------------------
  436|      0|	return(NULL);
  437|    285|    if (cur == NULL)
  ------------------
  |  Branch (437:9): [True: 0, False: 285]
  ------------------
  438|      0|	return(NULL);
  439|       |
  440|       |    /*
  441|       |     * read the attributes
  442|       |     */
  443|    285|    href = xmlXIncludeGetProp(ctxt, cur, XINCLUDE_HREF);
  ------------------
  |  |   54|    285|#define XINCLUDE_HREF (const xmlChar *) "href"
  ------------------
  444|    285|    if (href == NULL) {
  ------------------
  |  Branch (444:9): [True: 155, False: 130]
  ------------------
  445|    155|	href = xmlStrdup(BAD_CAST ""); /* @@@@ href is now optional */
  ------------------
  |  |   35|    155|#define BAD_CAST (xmlChar *)
  ------------------
  446|    155|	if (href == NULL)
  ------------------
  |  Branch (446:6): [True: 1, False: 154]
  ------------------
  447|      1|	    return(NULL);
  448|    155|    }
  449|    284|    parse = xmlXIncludeGetProp(ctxt, cur, XINCLUDE_PARSE);
  ------------------
  |  |   60|    284|#define XINCLUDE_PARSE (const xmlChar *) "parse"
  ------------------
  450|    284|    if (parse != NULL) {
  ------------------
  |  Branch (450:9): [True: 14, False: 270]
  ------------------
  451|     14|	if (xmlStrEqual(parse, XINCLUDE_PARSE_XML))
  ------------------
  |  |   66|     14|#define XINCLUDE_PARSE_XML (const xmlChar *) "xml"
  ------------------
  |  Branch (451:6): [True: 4, False: 10]
  ------------------
  452|      4|	    xml = 1;
  453|     10|	else if (xmlStrEqual(parse, XINCLUDE_PARSE_TEXT))
  ------------------
  |  |   72|     10|#define XINCLUDE_PARSE_TEXT (const xmlChar *) "text"
  ------------------
  |  Branch (453:11): [True: 10, False: 0]
  ------------------
  454|     10|	    xml = 0;
  455|      0|	else {
  456|      0|	    xmlXIncludeErr(ctxt, cur, XML_XINCLUDE_PARSE_VALUE,
  457|      0|	                   "invalid value %s for 'parse'\n", parse);
  458|      0|	    if (href != NULL)
  ------------------
  |  Branch (458:10): [True: 0, False: 0]
  ------------------
  459|      0|		xmlFree(href);
  460|      0|	    if (parse != NULL)
  ------------------
  |  Branch (460:10): [True: 0, False: 0]
  ------------------
  461|      0|		xmlFree(parse);
  462|      0|	    return(NULL);
  463|      0|	}
  464|     14|    }
  465|       |
  466|       |    /*
  467|       |     * compute the URI
  468|       |     */
  469|    284|    base = xmlNodeGetBase(ctxt->doc, cur);
  470|    284|    if (base == NULL) {
  ------------------
  |  Branch (470:9): [True: 155, False: 129]
  ------------------
  471|    155|	URI = xmlBuildURI(href, ctxt->doc->URL);
  472|    155|    } else {
  473|    129|	URI = xmlBuildURI(href, base);
  474|    129|    }
  475|    284|    if (URI == NULL) {
  ------------------
  |  Branch (475:9): [True: 82, False: 202]
  ------------------
  476|     82|	xmlChar *escbase;
  477|     82|	xmlChar *eschref;
  478|       |	/*
  479|       |	 * Some escaping may be needed
  480|       |	 */
  481|     82|	escbase = xmlURIEscape(base);
  482|     82|	eschref = xmlURIEscape(href);
  483|     82|	URI = xmlBuildURI(eschref, escbase);
  484|     82|	if (escbase != NULL)
  ------------------
  |  Branch (484:6): [True: 0, False: 82]
  ------------------
  485|      0|	    xmlFree(escbase);
  486|     82|	if (eschref != NULL)
  ------------------
  |  Branch (486:6): [True: 0, False: 82]
  ------------------
  487|      0|	    xmlFree(eschref);
  488|     82|    }
  489|    284|    if (parse != NULL)
  ------------------
  |  Branch (489:9): [True: 14, False: 270]
  ------------------
  490|     14|	xmlFree(parse);
  491|    284|    if (href != NULL)
  ------------------
  |  Branch (491:9): [True: 284, False: 0]
  ------------------
  492|    284|	xmlFree(href);
  493|    284|    if (base != NULL)
  ------------------
  |  Branch (493:9): [True: 129, False: 155]
  ------------------
  494|    129|	xmlFree(base);
  495|    284|    if (URI == NULL) {
  ------------------
  |  Branch (495:9): [True: 82, False: 202]
  ------------------
  496|     82|	xmlXIncludeErr(ctxt, cur, XML_XINCLUDE_HREF_URI,
  497|     82|	               "failed build URL\n", NULL);
  498|     82|	return(NULL);
  499|     82|    }
  500|    202|    fragment = xmlXIncludeGetProp(ctxt, cur, XINCLUDE_PARSE_XPOINTER);
  ------------------
  |  |   84|    202|#define XINCLUDE_PARSE_XPOINTER (const xmlChar *) "xpointer"
  ------------------
  501|       |
  502|       |    /*
  503|       |     * Check the URL and remove any fragment identifier
  504|       |     */
  505|    202|    uri = xmlParseURI((const char *)URI);
  506|    202|    if (uri == NULL) {
  ------------------
  |  Branch (506:9): [True: 0, False: 202]
  ------------------
  507|      0|	xmlXIncludeErr(ctxt, cur, XML_XINCLUDE_HREF_URI,
  508|      0|	               "invalid value URI %s\n", URI);
  509|      0|	if (fragment != NULL)
  ------------------
  |  Branch (509:6): [True: 0, False: 0]
  ------------------
  510|      0|	    xmlFree(fragment);
  511|      0|	xmlFree(URI);
  512|      0|	return(NULL);
  513|      0|    }
  514|       |
  515|    202|    if (uri->fragment != NULL) {
  ------------------
  |  Branch (515:9): [True: 20, False: 182]
  ------------------
  516|     20|        if (ctxt->legacy != 0) {
  ------------------
  |  Branch (516:13): [True: 18, False: 2]
  ------------------
  517|     18|	    if (fragment == NULL) {
  ------------------
  |  Branch (517:10): [True: 18, False: 0]
  ------------------
  518|     18|		fragment = (xmlChar *) uri->fragment;
  519|     18|	    } else {
  520|      0|		xmlFree(uri->fragment);
  521|      0|	    }
  522|     18|	} else {
  523|      2|	    xmlXIncludeErr(ctxt, cur, XML_XINCLUDE_FRAGMENT_ID,
  524|      2|       "Invalid fragment identifier in URI %s use the xpointer attribute\n",
  525|      2|                           URI);
  526|      2|	    if (fragment != NULL)
  ------------------
  |  Branch (526:10): [True: 0, False: 2]
  ------------------
  527|      0|	        xmlFree(fragment);
  528|      2|	    xmlFreeURI(uri);
  529|      2|	    xmlFree(URI);
  530|      2|	    return(NULL);
  531|      2|	}
  532|     18|	uri->fragment = NULL;
  533|     18|    }
  534|    200|    URL = xmlSaveUri(uri);
  535|    200|    xmlFreeURI(uri);
  536|    200|    if (URL == NULL) {
  ------------------
  |  Branch (536:9): [True: 0, False: 200]
  ------------------
  537|      0|	xmlXIncludeErr(ctxt, cur, XML_XINCLUDE_HREF_URI,
  538|      0|	               "invalid value URI %s\n", URI);
  539|      0|	if (fragment != NULL)
  ------------------
  |  Branch (539:6): [True: 0, False: 0]
  ------------------
  540|      0|	    xmlFree(fragment);
  541|      0|        xmlFree(URI);
  542|      0|	return(NULL);
  543|      0|    }
  544|    200|    xmlFree(URI);
  545|       |
  546|    200|    if (xmlStrEqual(URL, ctxt->doc->URL))
  ------------------
  |  Branch (546:9): [True: 76, False: 124]
  ------------------
  547|     76|	local = 1;
  548|       |
  549|       |    /*
  550|       |     * If local and xml then we need a fragment
  551|       |     */
  552|    200|    if ((local == 1) && (xml == 1) &&
  ------------------
  |  Branch (552:9): [True: 76, False: 124]
  |  Branch (552:25): [True: 76, False: 0]
  ------------------
  553|    200|        ((fragment == NULL) || (fragment[0] == 0))) {
  ------------------
  |  Branch (553:10): [True: 0, False: 76]
  |  Branch (553:32): [True: 0, False: 76]
  ------------------
  554|      0|	xmlXIncludeErr(ctxt, cur, XML_XINCLUDE_RECURSION,
  555|      0|	               "detected a local recursion with no xpointer in %s\n",
  556|      0|		       URL);
  557|      0|        xmlFree(URL);
  558|      0|        xmlFree(fragment);
  559|      0|	return(NULL);
  560|      0|    }
  561|       |
  562|    200|    ref = xmlXIncludeNewRef(ctxt, URL, cur);
  563|    200|    xmlFree(URL);
  564|    200|    if (ref == NULL) {
  ------------------
  |  Branch (564:9): [True: 0, False: 200]
  ------------------
  565|      0|        xmlFree(fragment);
  566|      0|	return(NULL);
  567|      0|    }
  568|    200|    ref->fragment = fragment;
  569|    200|    ref->xml = xml;
  570|    200|    return(ref);
  571|    200|}
xinclude.c:xmlXIncludeGetProp:
  193|  1.17k|                   const xmlChar *name) {
  194|  1.17k|    xmlChar *ret;
  195|       |
  196|  1.17k|    ret = xmlGetNsProp(cur, XINCLUDE_NS, name);
  ------------------
  |  |   30|  1.17k|#define XINCLUDE_NS (const xmlChar *) "http://www.w3.org/2003/XInclude"
  ------------------
  197|  1.17k|    if (ret != NULL)
  ------------------
  |  Branch (197:9): [True: 0, False: 1.17k]
  ------------------
  198|      0|        return(ret);
  199|  1.17k|    if (ctxt->legacy != 0) {
  ------------------
  |  Branch (199:9): [True: 1.15k, False: 16]
  ------------------
  200|  1.15k|	ret = xmlGetNsProp(cur, XINCLUDE_OLD_NS, name);
  ------------------
  |  |   36|  1.15k|#define XINCLUDE_OLD_NS (const xmlChar *) "http://www.w3.org/2001/XInclude"
  ------------------
  201|  1.15k|	if (ret != NULL)
  ------------------
  |  Branch (201:6): [True: 0, False: 1.15k]
  ------------------
  202|      0|	    return(ret);
  203|  1.15k|    }
  204|  1.17k|    ret = xmlGetProp(cur, name);
  205|  1.17k|    return(ret);
  206|  1.17k|}
xinclude.c:xmlXIncludeNewRef:
  236|    200|	          xmlNodePtr elem) {
  237|    200|    xmlXIncludeRefPtr ret;
  238|       |
  239|    200|    ret = (xmlXIncludeRefPtr) xmlMalloc(sizeof(xmlXIncludeRef));
  240|    200|    if (ret == NULL) {
  ------------------
  |  Branch (240:9): [True: 0, False: 200]
  ------------------
  241|      0|        xmlXIncludeErrMemory(ctxt, elem, "growing XInclude context");
  242|      0|	return(NULL);
  243|      0|    }
  244|    200|    memset(ret, 0, sizeof(xmlXIncludeRef));
  245|    200|    if (URI == NULL)
  ------------------
  |  Branch (245:9): [True: 0, False: 200]
  ------------------
  246|      0|	ret->URI = NULL;
  247|    200|    else
  248|    200|	ret->URI = xmlStrdup(URI);
  249|    200|    ret->fragment = NULL;
  250|    200|    ret->elem = elem;
  251|    200|    ret->xml = 0;
  252|    200|    ret->inc = NULL;
  253|    200|    if (ctxt->incNr >= ctxt->incMax) {
  ------------------
  |  Branch (253:9): [True: 123, False: 77]
  ------------------
  254|    123|        xmlXIncludeRefPtr *tmp;
  255|    123|#ifdef FUZZING_BUILD_MODE_UNSAFE_FOR_PRODUCTION
  256|    123|        size_t newSize = ctxt->incMax ? ctxt->incMax * 2 : 1;
  ------------------
  |  Branch (256:26): [True: 50, False: 73]
  ------------------
  257|       |#else
  258|       |        size_t newSize = ctxt->incMax ? ctxt->incMax * 2 : 4;
  259|       |#endif
  260|       |
  261|    123|        tmp = (xmlXIncludeRefPtr *) xmlRealloc(ctxt->incTab,
  262|    123|	             newSize * sizeof(ctxt->incTab[0]));
  263|    123|        if (tmp == NULL) {
  ------------------
  |  Branch (263:13): [True: 0, False: 123]
  ------------------
  264|      0|	    xmlXIncludeErrMemory(ctxt, elem, "growing XInclude context");
  265|      0|	    xmlXIncludeFreeRef(ret);
  266|      0|	    return(NULL);
  267|      0|	}
  268|    123|        ctxt->incTab = tmp;
  269|    123|        ctxt->incMax = newSize;
  270|    123|    }
  271|    200|    ctxt->incTab[ctxt->incNr++] = ret;
  272|    200|    return(ret);
  273|    200|}
xinclude.c:xmlXIncludeLoadNode:
 1897|    200|xmlXIncludeLoadNode(xmlXIncludeCtxtPtr ctxt, xmlXIncludeRefPtr ref) {
 1898|    200|    xmlNodePtr cur;
 1899|    200|    xmlChar *href;
 1900|    200|    xmlChar *parse;
 1901|    200|    xmlChar *base;
 1902|    200|    xmlChar *oldBase;
 1903|    200|    xmlChar *URI;
 1904|    200|    int xml = 1; /* default Issue 64 */
 1905|    200|    int ret;
 1906|       |
 1907|    200|    if ((ctxt == NULL) || (ref == NULL))
  ------------------
  |  Branch (1907:9): [True: 0, False: 200]
  |  Branch (1907:27): [True: 0, False: 200]
  ------------------
 1908|      0|	return(-1);
 1909|    200|    cur = ref->elem;
 1910|    200|    if (cur == NULL)
  ------------------
  |  Branch (1910:9): [True: 0, False: 200]
  ------------------
 1911|      0|	return(-1);
 1912|       |
 1913|       |    /*
 1914|       |     * read the attributes
 1915|       |     */
 1916|    200|    href = xmlXIncludeGetProp(ctxt, cur, XINCLUDE_HREF);
  ------------------
  |  |   54|    200|#define XINCLUDE_HREF (const xmlChar *) "href"
  ------------------
 1917|    200|    if (href == NULL) {
  ------------------
  |  Branch (1917:9): [True: 72, False: 128]
  ------------------
 1918|     72|	href = xmlStrdup(BAD_CAST ""); /* @@@@ href is now optional */
  ------------------
  |  |   35|     72|#define BAD_CAST (xmlChar *)
  ------------------
 1919|     72|	if (href == NULL)
  ------------------
  |  Branch (1919:6): [True: 0, False: 72]
  ------------------
 1920|      0|	    return(-1);
 1921|     72|    }
 1922|    200|    parse = xmlXIncludeGetProp(ctxt, cur, XINCLUDE_PARSE);
  ------------------
  |  |   60|    200|#define XINCLUDE_PARSE (const xmlChar *) "parse"
  ------------------
 1923|    200|    if (parse != NULL) {
  ------------------
  |  Branch (1923:9): [True: 14, False: 186]
  ------------------
 1924|     14|	if (xmlStrEqual(parse, XINCLUDE_PARSE_XML))
  ------------------
  |  |   66|     14|#define XINCLUDE_PARSE_XML (const xmlChar *) "xml"
  ------------------
  |  Branch (1924:6): [True: 4, False: 10]
  ------------------
 1925|      4|	    xml = 1;
 1926|     10|	else if (xmlStrEqual(parse, XINCLUDE_PARSE_TEXT))
  ------------------
  |  |   72|     10|#define XINCLUDE_PARSE_TEXT (const xmlChar *) "text"
  ------------------
  |  Branch (1926:11): [True: 10, False: 0]
  ------------------
 1927|     10|	    xml = 0;
 1928|      0|	else {
 1929|      0|	    xmlXIncludeErr(ctxt, cur, XML_XINCLUDE_PARSE_VALUE,
 1930|      0|			   "invalid value %s for 'parse'\n", parse);
 1931|      0|	    if (href != NULL)
  ------------------
  |  Branch (1931:10): [True: 0, False: 0]
  ------------------
 1932|      0|		xmlFree(href);
 1933|      0|	    if (parse != NULL)
  ------------------
  |  Branch (1933:10): [True: 0, False: 0]
  ------------------
 1934|      0|		xmlFree(parse);
 1935|      0|	    return(-1);
 1936|      0|	}
 1937|     14|    }
 1938|       |
 1939|       |    /*
 1940|       |     * compute the URI
 1941|       |     */
 1942|    200|    base = xmlNodeGetBase(ctxt->doc, cur);
 1943|    200|    if (base == NULL) {
  ------------------
  |  Branch (1943:9): [True: 72, False: 128]
  ------------------
 1944|     72|	URI = xmlBuildURI(href, ctxt->doc->URL);
 1945|    128|    } else {
 1946|    128|	URI = xmlBuildURI(href, base);
 1947|    128|    }
 1948|    200|    if (URI == NULL) {
  ------------------
  |  Branch (1948:9): [True: 0, False: 200]
  ------------------
 1949|      0|	xmlChar *escbase;
 1950|      0|	xmlChar *eschref;
 1951|       |	/*
 1952|       |	 * Some escaping may be needed
 1953|       |	 */
 1954|      0|	escbase = xmlURIEscape(base);
 1955|      0|	eschref = xmlURIEscape(href);
 1956|      0|	URI = xmlBuildURI(eschref, escbase);
 1957|      0|	if (escbase != NULL)
  ------------------
  |  Branch (1957:6): [True: 0, False: 0]
  ------------------
 1958|      0|	    xmlFree(escbase);
 1959|      0|	if (eschref != NULL)
  ------------------
  |  Branch (1959:6): [True: 0, False: 0]
  ------------------
 1960|      0|	    xmlFree(eschref);
 1961|      0|    }
 1962|    200|    if (URI == NULL) {
  ------------------
  |  Branch (1962:9): [True: 0, False: 200]
  ------------------
 1963|      0|	xmlXIncludeErr(ctxt, cur, XML_XINCLUDE_HREF_URI,
 1964|      0|                       "failed build URL\n", NULL);
 1965|      0|	if (parse != NULL)
  ------------------
  |  Branch (1965:6): [True: 0, False: 0]
  ------------------
 1966|      0|	    xmlFree(parse);
 1967|      0|	if (href != NULL)
  ------------------
  |  Branch (1967:6): [True: 0, False: 0]
  ------------------
 1968|      0|	    xmlFree(href);
 1969|      0|	if (base != NULL)
  ------------------
  |  Branch (1969:6): [True: 0, False: 0]
  ------------------
 1970|      0|	    xmlFree(base);
 1971|      0|	return(-1);
 1972|      0|    }
 1973|       |
 1974|       |    /*
 1975|       |     * Save the base for this include (saving the current one)
 1976|       |     */
 1977|    200|    oldBase = ctxt->base;
 1978|    200|    ctxt->base = base;
 1979|       |
 1980|    200|    if (xml) {
  ------------------
  |  Branch (1980:9): [True: 190, False: 10]
  ------------------
 1981|    190|	ret = xmlXIncludeLoadDoc(ctxt, URI, ref);
 1982|       |	/* xmlXIncludeGetFragment(ctxt, cur, URI); */
 1983|    190|    } else {
 1984|     10|	ret = xmlXIncludeLoadTxt(ctxt, URI, ref);
 1985|     10|    }
 1986|       |
 1987|       |    /*
 1988|       |     * Restore the original base before checking for fallback
 1989|       |     */
 1990|    200|    ctxt->base = oldBase;
 1991|       |
 1992|    200|    if (ret < 0) {
  ------------------
  |  Branch (1992:9): [True: 98, False: 102]
  ------------------
 1993|     98|	xmlNodePtr children;
 1994|       |
 1995|       |	/*
 1996|       |	 * Time to try a fallback if available
 1997|       |	 */
 1998|     98|	children = cur->children;
 1999|    178|	while (children != NULL) {
  ------------------
  |  Branch (1999:9): [True: 160, False: 18]
  ------------------
 2000|    160|	    if ((children->type == XML_ELEMENT_NODE) &&
  ------------------
  |  Branch (2000:10): [True: 80, False: 80]
  ------------------
 2001|    160|		(children->ns != NULL) &&
  ------------------
  |  Branch (2001:3): [True: 80, False: 0]
  ------------------
 2002|    160|		(xmlStrEqual(children->name, XINCLUDE_FALLBACK)) &&
  ------------------
  |  |   48|     80|#define XINCLUDE_FALLBACK (const xmlChar *) "fallback"
  ------------------
  |  Branch (2002:3): [True: 80, False: 0]
  ------------------
 2003|    160|		((xmlStrEqual(children->ns->href, XINCLUDE_NS)) ||
  ------------------
  |  |   30|     80|#define XINCLUDE_NS (const xmlChar *) "http://www.w3.org/2003/XInclude"
  ------------------
  |  Branch (2003:4): [True: 0, False: 80]
  ------------------
 2004|     80|		 (xmlStrEqual(children->ns->href, XINCLUDE_OLD_NS)))) {
  ------------------
  |  |   36|     80|#define XINCLUDE_OLD_NS (const xmlChar *) "http://www.w3.org/2001/XInclude"
  ------------------
  |  Branch (2004:4): [True: 80, False: 0]
  ------------------
 2005|     80|		ret = xmlXIncludeLoadFallback(ctxt, children, ref);
 2006|     80|		break;
 2007|     80|	    }
 2008|     80|	    children = children->next;
 2009|     80|	}
 2010|     98|    }
 2011|    200|    if (ret < 0) {
  ------------------
  |  Branch (2011:9): [True: 22, False: 178]
  ------------------
 2012|     22|	xmlXIncludeErr(ctxt, cur, XML_XINCLUDE_NO_FALLBACK,
 2013|     22|		       "could not load %s, and no fallback was found\n",
 2014|     22|		       URI);
 2015|     22|    }
 2016|       |
 2017|       |    /*
 2018|       |     * Cleanup
 2019|       |     */
 2020|    200|    if (URI != NULL)
  ------------------
  |  Branch (2020:9): [True: 200, False: 0]
  ------------------
 2021|    200|	xmlFree(URI);
 2022|    200|    if (parse != NULL)
  ------------------
  |  Branch (2022:9): [True: 14, False: 186]
  ------------------
 2023|     14|	xmlFree(parse);
 2024|    200|    if (href != NULL)
  ------------------
  |  Branch (2024:9): [True: 200, False: 0]
  ------------------
 2025|    200|	xmlFree(href);
 2026|    200|    if (base != NULL)
  ------------------
  |  Branch (2026:9): [True: 128, False: 72]
  ------------------
 2027|    128|	xmlFree(base);
 2028|    200|    return(0);
 2029|    200|}
xinclude.c:xmlXIncludeLoadDoc:
 1232|    190|                   xmlXIncludeRefPtr ref) {
 1233|    190|    xmlXIncludeDocPtr cache;
 1234|    190|    xmlDocPtr doc;
 1235|    190|    xmlURIPtr uri;
 1236|    190|    xmlChar *URL = NULL;
 1237|    190|    xmlChar *fragment = NULL;
 1238|    190|    int i = 0;
 1239|    190|    int ret = -1;
 1240|    190|    int cacheNr;
 1241|    190|#ifdef LIBXML_XPTR_ENABLED
 1242|    190|    int saveFlags;
 1243|    190|#endif
 1244|       |
 1245|       |    /*
 1246|       |     * Check the URL and remove any fragment identifier
 1247|       |     */
 1248|    190|    uri = xmlParseURI((const char *)url);
 1249|    190|    if (uri == NULL) {
  ------------------
  |  Branch (1249:9): [True: 0, False: 190]
  ------------------
 1250|      0|	xmlXIncludeErr(ctxt, ref->elem, XML_XINCLUDE_HREF_URI,
 1251|      0|		       "invalid value URI %s\n", url);
 1252|      0|        goto error;
 1253|      0|    }
 1254|    190|    if (uri->fragment != NULL) {
  ------------------
  |  Branch (1254:9): [True: 18, False: 172]
  ------------------
 1255|     18|	fragment = (xmlChar *) uri->fragment;
 1256|     18|	uri->fragment = NULL;
 1257|     18|    }
 1258|    190|    if (ref->fragment != NULL) {
  ------------------
  |  Branch (1258:9): [True: 94, False: 96]
  ------------------
 1259|     94|	if (fragment != NULL) xmlFree(fragment);
  ------------------
  |  Branch (1259:6): [True: 18, False: 76]
  ------------------
 1260|     94|	fragment = xmlStrdup(ref->fragment);
 1261|     94|    }
 1262|    190|    URL = xmlSaveUri(uri);
 1263|    190|    xmlFreeURI(uri);
 1264|    190|    if (URL == NULL) {
  ------------------
  |  Branch (1264:9): [True: 0, False: 190]
  ------------------
 1265|      0|        xmlXIncludeErr(ctxt, ref->elem, XML_XINCLUDE_HREF_URI,
 1266|      0|                       "invalid value URI %s\n", url);
 1267|      0|        goto error;
 1268|      0|    }
 1269|       |
 1270|       |    /*
 1271|       |     * Handling of references to the local document are done
 1272|       |     * directly through ctxt->doc.
 1273|       |     */
 1274|    190|    if ((URL[0] == 0) || (URL[0] == '#') ||
  ------------------
  |  Branch (1274:9): [True: 3, False: 187]
  |  Branch (1274:26): [True: 0, False: 187]
  ------------------
 1275|    190|	((ctxt->doc != NULL) && (xmlStrEqual(URL, ctxt->doc->URL)))) {
  ------------------
  |  Branch (1275:3): [True: 187, False: 0]
  |  Branch (1275:26): [True: 75, False: 112]
  ------------------
 1276|     78|	doc = ctxt->doc;
 1277|     78|        goto loaded;
 1278|     78|    }
 1279|       |
 1280|       |    /*
 1281|       |     * Prevent reloading the document twice.
 1282|       |     */
 1283|    436|    for (i = 0; i < ctxt->urlNr; i++) {
  ------------------
  |  Branch (1283:17): [True: 326, False: 110]
  ------------------
 1284|    326|	if (xmlStrEqual(URL, ctxt->urlTab[i].url)) {
  ------------------
  |  Branch (1284:6): [True: 2, False: 324]
  ------------------
 1285|      2|            if (ctxt->urlTab[i].expanding) {
  ------------------
  |  Branch (1285:17): [True: 0, False: 2]
  ------------------
 1286|      0|                xmlXIncludeErr(ctxt, ref->elem, XML_XINCLUDE_RECURSION,
 1287|      0|                               "inclusion loop detected\n", NULL);
 1288|      0|                goto error;
 1289|      0|            }
 1290|      2|	    doc = ctxt->urlTab[i].doc;
 1291|      2|            if (doc == NULL)
  ------------------
  |  Branch (1291:17): [True: 2, False: 0]
  ------------------
 1292|      2|                goto error;
 1293|      0|	    goto loaded;
 1294|      2|	}
 1295|    326|    }
 1296|       |
 1297|       |    /*
 1298|       |     * Load it.
 1299|       |     */
 1300|    110|#ifdef LIBXML_XPTR_ENABLED
 1301|       |    /*
 1302|       |     * If this is an XPointer evaluation, we want to assure that
 1303|       |     * all entities have been resolved prior to processing the
 1304|       |     * referenced document
 1305|       |     */
 1306|    110|    saveFlags = ctxt->parseFlags;
 1307|    110|    if (fragment != NULL) {	/* if this is an XPointer eval */
  ------------------
  |  Branch (1307:9): [True: 16, False: 94]
  ------------------
 1308|     16|	ctxt->parseFlags |= XML_PARSE_NOENT;
 1309|     16|    }
 1310|    110|#endif
 1311|       |
 1312|    110|    doc = xmlXIncludeParseFile(ctxt, (const char *)URL);
 1313|    110|#ifdef LIBXML_XPTR_ENABLED
 1314|    110|    ctxt->parseFlags = saveFlags;
 1315|    110|#endif
 1316|       |
 1317|       |    /* Also cache NULL docs */
 1318|    110|    if (ctxt->urlNr >= ctxt->urlMax) {
  ------------------
  |  Branch (1318:9): [True: 80, False: 30]
  ------------------
 1319|     80|        xmlXIncludeDoc *tmp;
 1320|     80|#ifdef FUZZING_BUILD_MODE_UNSAFE_FOR_PRODUCTION
 1321|     80|        size_t newSize = ctxt->urlMax ? ctxt->urlMax * 2 : 1;
  ------------------
  |  Branch (1321:26): [True: 28, False: 52]
  ------------------
 1322|       |#else
 1323|       |        size_t newSize = ctxt->urlMax ? ctxt->urlMax * 2 : 8;
 1324|       |#endif
 1325|       |
 1326|     80|        tmp = xmlRealloc(ctxt->urlTab, sizeof(xmlXIncludeDoc) * newSize);
 1327|     80|        if (tmp == NULL) {
  ------------------
  |  Branch (1327:13): [True: 0, False: 80]
  ------------------
 1328|      0|            xmlXIncludeErrMemory(ctxt, ref->elem,
 1329|      0|                                 "growing XInclude URL table");
 1330|      0|            xmlFreeDoc(doc);
 1331|      0|            goto error;
 1332|      0|        }
 1333|     80|        ctxt->urlMax = newSize;
 1334|     80|        ctxt->urlTab = tmp;
 1335|     80|    }
 1336|    110|    cacheNr = ctxt->urlNr++;
 1337|    110|    cache = &ctxt->urlTab[cacheNr];
 1338|    110|    cache->doc = doc;
 1339|    110|    cache->url = xmlStrdup(URL);
 1340|    110|    cache->expanding = 0;
 1341|       |
 1342|    110|    if (doc == NULL)
  ------------------
  |  Branch (1342:9): [True: 92, False: 18]
  ------------------
 1343|     92|        goto error;
 1344|       |    /*
 1345|       |     * It's possible that the requested URL has been mapped to a
 1346|       |     * completely different location (e.g. through a catalog entry).
 1347|       |     * To check for this, we compare the URL with that of the doc
 1348|       |     * and change it if they disagree (bug 146988).
 1349|       |     */
 1350|     18|   if (!xmlStrEqual(URL, doc->URL)) {
  ------------------
  |  Branch (1350:8): [True: 0, False: 18]
  ------------------
 1351|      0|       xmlFree(URL);
 1352|      0|       URL = xmlStrdup(doc->URL);
 1353|      0|   }
 1354|       |
 1355|       |    /*
 1356|       |     * Make sure we have all entities fixed up
 1357|       |     */
 1358|     18|    xmlXIncludeMergeEntities(ctxt, ctxt->doc, doc);
 1359|       |
 1360|       |    /*
 1361|       |     * We don't need the DTD anymore, free up space
 1362|       |    if (doc->intSubset != NULL) {
 1363|       |	xmlUnlinkNode((xmlNodePtr) doc->intSubset);
 1364|       |	xmlFreeNode((xmlNodePtr) doc->intSubset);
 1365|       |	doc->intSubset = NULL;
 1366|       |    }
 1367|       |    if (doc->extSubset != NULL) {
 1368|       |	xmlUnlinkNode((xmlNodePtr) doc->extSubset);
 1369|       |	xmlFreeNode((xmlNodePtr) doc->extSubset);
 1370|       |	doc->extSubset = NULL;
 1371|       |    }
 1372|       |     */
 1373|     18|    cache->expanding = 1;
 1374|     18|    xmlXIncludeRecurseDoc(ctxt, doc, URL);
 1375|       |    /* urlTab might be reallocated. */
 1376|     18|    cache = &ctxt->urlTab[cacheNr];
 1377|     18|    cache->expanding = 0;
 1378|       |
 1379|     96|loaded:
 1380|     96|    if (fragment == NULL) {
  ------------------
  |  Branch (1380:9): [True: 10, False: 86]
  ------------------
 1381|       |	/*
 1382|       |	 * Add the top children list as the replacement copy.
 1383|       |	 */
 1384|     10|        ref->inc = xmlDocCopyNode(xmlDocGetRootElement(doc), ctxt->doc, 1);
 1385|     10|    }
 1386|     86|#ifdef LIBXML_XPTR_ENABLED
 1387|     86|    else {
 1388|       |	/*
 1389|       |	 * Computes the XPointer expression and make a copy used
 1390|       |	 * as the replacement copy.
 1391|       |	 */
 1392|     86|	xmlXPathObjectPtr xptr;
 1393|     86|	xmlXPathContextPtr xptrctxt;
 1394|     86|	xmlNodeSetPtr set;
 1395|       |
 1396|     86|        if (ctxt->isStream && doc == ctxt->doc) {
  ------------------
  |  Branch (1396:13): [True: 6, False: 80]
  |  Branch (1396:31): [True: 2, False: 4]
  ------------------
 1397|      2|	    xmlXIncludeErr(ctxt, ref->elem, XML_XINCLUDE_XPTR_FAILED,
 1398|      2|			   "XPointer expressions not allowed in streaming"
 1399|      2|                           " mode\n", NULL);
 1400|      2|            goto error;
 1401|      2|        }
 1402|       |
 1403|     84|	xptrctxt = xmlXPtrNewContext(doc, NULL, NULL);
 1404|     84|	if (xptrctxt == NULL) {
  ------------------
  |  Branch (1404:6): [True: 0, False: 84]
  ------------------
 1405|      0|	    xmlXIncludeErr(ctxt, ref->elem, XML_XINCLUDE_XPTR_FAILED,
 1406|      0|			   "could not create XPointer context\n", NULL);
 1407|      0|            goto error;
 1408|      0|	}
 1409|     84|	xptr = xmlXPtrEval(fragment, xptrctxt);
 1410|     84|	if (xptr == NULL) {
  ------------------
  |  Branch (1410:6): [True: 0, False: 84]
  ------------------
 1411|      0|	    xmlXIncludeErr(ctxt, ref->elem, XML_XINCLUDE_XPTR_FAILED,
 1412|      0|			   "XPointer evaluation failed: #%s\n",
 1413|      0|			   fragment);
 1414|      0|	    xmlXPathFreeContext(xptrctxt);
 1415|      0|            goto error;
 1416|      0|	}
 1417|     84|	switch (xptr->type) {
  ------------------
  |  Branch (1417:10): [True: 0, False: 84]
  ------------------
 1418|      0|	    case XPATH_UNDEFINED:
  ------------------
  |  Branch (1418:6): [True: 0, False: 84]
  ------------------
 1419|      0|	    case XPATH_BOOLEAN:
  ------------------
  |  Branch (1419:6): [True: 0, False: 84]
  ------------------
 1420|      0|	    case XPATH_NUMBER:
  ------------------
  |  Branch (1420:6): [True: 0, False: 84]
  ------------------
 1421|      0|	    case XPATH_STRING:
  ------------------
  |  Branch (1421:6): [True: 0, False: 84]
  ------------------
 1422|       |#ifdef LIBXML_XPTR_LOCS_ENABLED
 1423|       |	    case XPATH_POINT:
 1424|       |#endif
 1425|      0|	    case XPATH_USERS:
  ------------------
  |  Branch (1425:6): [True: 0, False: 84]
  ------------------
 1426|      0|	    case XPATH_XSLT_TREE:
  ------------------
  |  Branch (1426:6): [True: 0, False: 84]
  ------------------
 1427|      0|		xmlXIncludeErr(ctxt, ref->elem, XML_XINCLUDE_XPTR_RESULT,
 1428|      0|			       "XPointer is not a range: #%s\n",
 1429|      0|			       fragment);
 1430|      0|                xmlXPathFreeObject(xptr);
 1431|      0|		xmlXPathFreeContext(xptrctxt);
 1432|      0|                goto error;
 1433|     84|	    case XPATH_NODESET:
  ------------------
  |  Branch (1433:6): [True: 84, False: 0]
  ------------------
 1434|     84|	        if ((xptr->nodesetval == NULL) ||
  ------------------
  |  Branch (1434:14): [True: 0, False: 84]
  ------------------
 1435|     84|		    (xptr->nodesetval->nodeNr <= 0)) {
  ------------------
  |  Branch (1435:7): [True: 0, False: 84]
  ------------------
 1436|      0|                    xmlXPathFreeObject(xptr);
 1437|      0|		    xmlXPathFreeContext(xptrctxt);
 1438|      0|                    goto error;
 1439|      0|		}
 1440|       |
 1441|       |#ifdef LIBXML_XPTR_LOCS_ENABLED
 1442|       |	    case XPATH_RANGE:
 1443|       |	    case XPATH_LOCATIONSET:
 1444|       |		break;
 1445|       |#endif
 1446|     84|	}
 1447|     84|	set = xptr->nodesetval;
 1448|     84|	if (set != NULL) {
  ------------------
  |  Branch (1448:6): [True: 84, False: 0]
  ------------------
 1449|    176|	    for (i = 0;i < set->nodeNr;i++) {
  ------------------
  |  Branch (1449:17): [True: 92, False: 84]
  ------------------
 1450|     92|		if (set->nodeTab[i] == NULL)
  ------------------
  |  Branch (1450:7): [True: 0, False: 92]
  ------------------
 1451|      0|		    continue;
 1452|     92|		switch (set->nodeTab[i]->type) {
  ------------------
  |  Branch (1452:11): [True: 0, False: 92]
  ------------------
 1453|     90|		    case XML_ELEMENT_NODE:
  ------------------
  |  Branch (1453:7): [True: 90, False: 2]
  ------------------
 1454|     92|		    case XML_TEXT_NODE:
  ------------------
  |  Branch (1454:7): [True: 2, False: 90]
  ------------------
 1455|     92|		    case XML_CDATA_SECTION_NODE:
  ------------------
  |  Branch (1455:7): [True: 0, False: 92]
  ------------------
 1456|     92|		    case XML_ENTITY_REF_NODE:
  ------------------
  |  Branch (1456:7): [True: 0, False: 92]
  ------------------
 1457|     92|		    case XML_ENTITY_NODE:
  ------------------
  |  Branch (1457:7): [True: 0, False: 92]
  ------------------
 1458|     92|		    case XML_PI_NODE:
  ------------------
  |  Branch (1458:7): [True: 0, False: 92]
  ------------------
 1459|     92|		    case XML_COMMENT_NODE:
  ------------------
  |  Branch (1459:7): [True: 0, False: 92]
  ------------------
 1460|     92|		    case XML_DOCUMENT_NODE:
  ------------------
  |  Branch (1460:7): [True: 0, False: 92]
  ------------------
 1461|     92|		    case XML_HTML_DOCUMENT_NODE:
  ------------------
  |  Branch (1461:7): [True: 0, False: 92]
  ------------------
 1462|     92|			continue;
 1463|       |
 1464|      0|		    case XML_ATTRIBUTE_NODE:
  ------------------
  |  Branch (1464:7): [True: 0, False: 92]
  ------------------
 1465|      0|			xmlXIncludeErr(ctxt, ref->elem,
 1466|      0|			               XML_XINCLUDE_XPTR_RESULT,
 1467|      0|				       "XPointer selects an attribute: #%s\n",
 1468|      0|				       fragment);
 1469|      0|			set->nodeTab[i] = NULL;
 1470|      0|			continue;
 1471|      0|		    case XML_NAMESPACE_DECL:
  ------------------
  |  Branch (1471:7): [True: 0, False: 92]
  ------------------
 1472|      0|			xmlXIncludeErr(ctxt, ref->elem,
 1473|      0|			               XML_XINCLUDE_XPTR_RESULT,
 1474|      0|				       "XPointer selects a namespace: #%s\n",
 1475|      0|				       fragment);
 1476|      0|			set->nodeTab[i] = NULL;
 1477|      0|			continue;
 1478|      0|		    case XML_DOCUMENT_TYPE_NODE:
  ------------------
  |  Branch (1478:7): [True: 0, False: 92]
  ------------------
 1479|      0|		    case XML_DOCUMENT_FRAG_NODE:
  ------------------
  |  Branch (1479:7): [True: 0, False: 92]
  ------------------
 1480|      0|		    case XML_NOTATION_NODE:
  ------------------
  |  Branch (1480:7): [True: 0, False: 92]
  ------------------
 1481|      0|		    case XML_DTD_NODE:
  ------------------
  |  Branch (1481:7): [True: 0, False: 92]
  ------------------
 1482|      0|		    case XML_ELEMENT_DECL:
  ------------------
  |  Branch (1482:7): [True: 0, False: 92]
  ------------------
 1483|      0|		    case XML_ATTRIBUTE_DECL:
  ------------------
  |  Branch (1483:7): [True: 0, False: 92]
  ------------------
 1484|      0|		    case XML_ENTITY_DECL:
  ------------------
  |  Branch (1484:7): [True: 0, False: 92]
  ------------------
 1485|      0|		    case XML_XINCLUDE_START:
  ------------------
  |  Branch (1485:7): [True: 0, False: 92]
  ------------------
 1486|      0|		    case XML_XINCLUDE_END:
  ------------------
  |  Branch (1486:7): [True: 0, False: 92]
  ------------------
 1487|      0|			xmlXIncludeErr(ctxt, ref->elem,
 1488|      0|			               XML_XINCLUDE_XPTR_RESULT,
 1489|      0|				   "XPointer selects unexpected nodes: #%s\n",
 1490|      0|				       fragment);
 1491|      0|			set->nodeTab[i] = NULL;
 1492|      0|			set->nodeTab[i] = NULL;
 1493|      0|			continue; /* for */
 1494|     92|		}
 1495|     92|	    }
 1496|     84|	}
 1497|     84|        ref->inc = xmlXIncludeCopyXPointer(ctxt, xptr);
 1498|     84|        xmlXPathFreeObject(xptr);
 1499|     84|	xmlXPathFreeContext(xptrctxt);
 1500|     84|    }
 1501|     94|#endif
 1502|       |
 1503|       |    /*
 1504|       |     * Do the xml:base fixup if needed
 1505|       |     */
 1506|     94|    if ((doc != NULL) && (URL != NULL) &&
  ------------------
  |  Branch (1506:9): [True: 94, False: 0]
  |  Branch (1506:26): [True: 94, False: 0]
  ------------------
 1507|     94|        (!(ctxt->parseFlags & XML_PARSE_NOBASEFIX)) &&
  ------------------
  |  Branch (1507:9): [True: 94, False: 0]
  ------------------
 1508|     94|	(!(doc->parseFlags & XML_PARSE_NOBASEFIX))) {
  ------------------
  |  Branch (1508:2): [True: 94, False: 0]
  ------------------
 1509|     94|	xmlNodePtr node;
 1510|     94|	xmlChar *base;
 1511|     94|	xmlChar *curBase;
 1512|       |
 1513|       |	/*
 1514|       |	 * The base is only adjusted if "necessary", i.e. if the xinclude node
 1515|       |	 * has a base specified, or the URL is relative
 1516|       |	 */
 1517|     94|	base = xmlGetNsProp(ref->elem, BAD_CAST "base", XML_XML_NAMESPACE);
  ------------------
  |  |   35|     94|#define BAD_CAST (xmlChar *)
  ------------------
              	base = xmlGetNsProp(ref->elem, BAD_CAST "base", XML_XML_NAMESPACE);
  ------------------
  |  |  143|     94|    (const xmlChar *) "http://www.w3.org/XML/1998/namespace"
  ------------------
 1518|     94|	if (base == NULL) {
  ------------------
  |  Branch (1518:6): [True: 94, False: 0]
  ------------------
 1519|       |	    /*
 1520|       |	     * No xml:base on the xinclude node, so we check whether the
 1521|       |	     * URI base is different than (relative to) the context base
 1522|       |	     */
 1523|     94|	    curBase = xmlBuildRelativeURI(URL, ctxt->base);
 1524|     94|	    if (curBase == NULL) {	/* Error return */
  ------------------
  |  Branch (1524:10): [True: 1, False: 93]
  ------------------
 1525|      1|	        xmlXIncludeErr(ctxt, ref->elem, XML_XINCLUDE_HREF_URI,
 1526|      1|		       "trying to build relative URI from %s\n", URL);
 1527|     93|	    } else {
 1528|       |		/* If the URI doesn't contain a slash, it's not relative */
 1529|     93|	        if (!xmlStrchr(curBase, '/'))
  ------------------
  |  Branch (1529:14): [True: 75, False: 18]
  ------------------
 1530|     75|		    xmlFree(curBase);
 1531|     18|		else
 1532|     18|		    base = curBase;
 1533|     93|	    }
 1534|     94|	}
 1535|     94|	if (base != NULL) {	/* Adjustment may be needed */
  ------------------
  |  Branch (1535:6): [True: 18, False: 76]
  ------------------
 1536|     18|	    node = ref->inc;
 1537|     44|	    while (node != NULL) {
  ------------------
  |  Branch (1537:13): [True: 26, False: 18]
  ------------------
 1538|       |		/* Only work on element nodes */
 1539|     26|		if (node->type == XML_ELEMENT_NODE) {
  ------------------
  |  Branch (1539:7): [True: 26, False: 0]
  ------------------
 1540|     26|		    curBase = xmlNodeGetBase(node->doc, node);
 1541|       |		    /* If no current base, set it */
 1542|     26|		    if (curBase == NULL) {
  ------------------
  |  Branch (1542:11): [True: 13, False: 13]
  ------------------
 1543|     13|			xmlNodeSetBase(node, base);
 1544|     13|		    } else {
 1545|       |			/*
 1546|       |			 * If the current base is the same as the
 1547|       |			 * URL of the document, then reset it to be
 1548|       |			 * the specified xml:base or the relative URI
 1549|       |			 */
 1550|     13|			if (xmlStrEqual(curBase, node->doc->URL)) {
  ------------------
  |  Branch (1550:8): [True: 13, False: 0]
  ------------------
 1551|     13|			    xmlNodeSetBase(node, base);
 1552|     13|			} else {
 1553|       |			    /*
 1554|       |			     * If the element already has an xml:base
 1555|       |			     * set, then relativise it if necessary
 1556|       |			     */
 1557|      0|			    xmlChar *xmlBase;
 1558|      0|			    xmlBase = xmlGetNsProp(node,
 1559|      0|					    BAD_CAST "base",
  ------------------
  |  |   35|      0|#define BAD_CAST (xmlChar *)
  ------------------
 1560|      0|					    XML_XML_NAMESPACE);
  ------------------
  |  |  143|      0|    (const xmlChar *) "http://www.w3.org/XML/1998/namespace"
  ------------------
 1561|      0|			    if (xmlBase != NULL) {
  ------------------
  |  Branch (1561:12): [True: 0, False: 0]
  ------------------
 1562|      0|				xmlChar *relBase;
 1563|      0|				relBase = xmlBuildURI(xmlBase, base);
 1564|      0|				if (relBase == NULL) { /* error */
  ------------------
  |  Branch (1564:9): [True: 0, False: 0]
  ------------------
 1565|      0|				    xmlXIncludeErr(ctxt,
 1566|      0|						ref->elem,
 1567|      0|						XML_XINCLUDE_HREF_URI,
 1568|      0|					"trying to rebuild base from %s\n",
 1569|      0|						xmlBase);
 1570|      0|				} else {
 1571|      0|				    xmlNodeSetBase(node, relBase);
 1572|      0|				    xmlFree(relBase);
 1573|      0|				}
 1574|      0|				xmlFree(xmlBase);
 1575|      0|			    }
 1576|      0|			}
 1577|     13|			xmlFree(curBase);
 1578|     13|		    }
 1579|     26|		}
 1580|     26|	        node = node->next;
 1581|     26|	    }
 1582|     18|	    xmlFree(base);
 1583|     18|	}
 1584|     94|    }
 1585|     94|    ret = 0;
 1586|       |
 1587|    190|error:
 1588|    190|    xmlFree(URL);
 1589|    190|    xmlFree(fragment);
 1590|    190|    return(ret);
 1591|     94|}
xinclude.c:xmlXIncludeParseFile:
  350|    110|xmlXIncludeParseFile(xmlXIncludeCtxtPtr ctxt, const char *URL) {
  351|    110|    xmlDocPtr ret;
  352|    110|    xmlParserCtxtPtr pctxt;
  353|    110|    xmlParserInputPtr inputStream;
  354|       |
  355|    110|    xmlInitParser();
  356|       |
  357|    110|    pctxt = xmlNewParserCtxt();
  358|    110|    if (pctxt == NULL) {
  ------------------
  |  Branch (358:9): [True: 0, False: 110]
  ------------------
  359|      0|	xmlXIncludeErrMemory(ctxt, NULL, "cannot allocate parser context");
  360|      0|	return(NULL);
  361|      0|    }
  362|       |
  363|       |    /*
  364|       |     * pass in the application data to the parser context.
  365|       |     */
  366|    110|    pctxt->_private = ctxt->_private;
  367|       |
  368|       |    /*
  369|       |     * try to ensure that new documents included are actually
  370|       |     * built with the same dictionary as the including document.
  371|       |     */
  372|    110|    if ((ctxt->doc != NULL) && (ctxt->doc->dict != NULL)) {
  ------------------
  |  Branch (372:9): [True: 110, False: 0]
  |  Branch (372:32): [True: 109, False: 1]
  ------------------
  373|    109|       if (pctxt->dict != NULL)
  ------------------
  |  Branch (373:12): [True: 109, False: 0]
  ------------------
  374|    109|            xmlDictFree(pctxt->dict);
  375|    109|	pctxt->dict = ctxt->doc->dict;
  376|    109|	xmlDictReference(pctxt->dict);
  377|    109|    }
  378|       |
  379|    110|    xmlCtxtUseOptions(pctxt, ctxt->parseFlags | XML_PARSE_DTDLOAD);
  380|       |
  381|       |    /* Don't read from stdin. */
  382|    110|    if ((URL != NULL) && (strcmp(URL, "-") == 0))
  ------------------
  |  Branch (382:9): [True: 110, False: 0]
  |  Branch (382:26): [True: 0, False: 110]
  ------------------
  383|      0|        URL = "./-";
  384|       |
  385|    110|    inputStream = xmlLoadExternalEntity(URL, NULL, pctxt);
  386|    110|    if (inputStream == NULL) {
  ------------------
  |  Branch (386:9): [True: 81, False: 29]
  ------------------
  387|     81|	xmlFreeParserCtxt(pctxt);
  388|     81|	return(NULL);
  389|     81|    }
  390|       |
  391|     29|    inputPush(pctxt, inputStream);
  392|       |
  393|     29|    if (pctxt->directory == NULL)
  ------------------
  |  Branch (393:9): [True: 29, False: 0]
  ------------------
  394|     29|        pctxt->directory = xmlParserGetDirectory(URL);
  395|       |
  396|     29|    pctxt->loadsubset |= XML_DETECT_IDS;
  ------------------
  |  |  141|     29|#define XML_DETECT_IDS		2
  ------------------
  397|       |
  398|     29|    xmlParseDocument(pctxt);
  399|       |
  400|     29|    if (pctxt->wellFormed) {
  ------------------
  |  Branch (400:9): [True: 18, False: 11]
  ------------------
  401|     18|        ret = pctxt->myDoc;
  402|     18|    }
  403|     11|    else {
  404|     11|        ret = NULL;
  405|     11|	if (pctxt->myDoc != NULL)
  ------------------
  |  Branch (405:6): [True: 11, False: 0]
  ------------------
  406|     11|	    xmlFreeDoc(pctxt->myDoc);
  407|     11|        pctxt->myDoc = NULL;
  408|     11|    }
  409|     29|    xmlFreeParserCtxt(pctxt);
  410|       |
  411|     29|    return(ret);
  412|    110|}
xinclude.c:xmlXIncludeMergeEntities:
 1171|     18|	                 xmlDocPtr from) {
 1172|     18|    xmlNodePtr cur;
 1173|     18|    xmlDtdPtr target, source;
 1174|       |
 1175|     18|    if (ctxt == NULL)
  ------------------
  |  Branch (1175:9): [True: 0, False: 18]
  ------------------
 1176|      0|	return(-1);
 1177|       |
 1178|     18|    if ((from == NULL) || (from->intSubset == NULL))
  ------------------
  |  Branch (1178:9): [True: 0, False: 18]
  |  Branch (1178:27): [True: 16, False: 2]
  ------------------
 1179|     16|	return(0);
 1180|       |
 1181|      2|    target = doc->intSubset;
 1182|      2|    if (target == NULL) {
  ------------------
  |  Branch (1182:9): [True: 0, False: 2]
  ------------------
 1183|      0|	cur = xmlDocGetRootElement(doc);
 1184|      0|	if (cur == NULL)
  ------------------
  |  Branch (1184:6): [True: 0, False: 0]
  ------------------
 1185|      0|	    return(-1);
 1186|      0|        target = xmlCreateIntSubset(doc, cur->name, NULL, NULL);
 1187|      0|	if (target == NULL)
  ------------------
  |  Branch (1187:6): [True: 0, False: 0]
  ------------------
 1188|      0|	    return(-1);
 1189|      0|    }
 1190|       |
 1191|      2|    source = from->intSubset;
 1192|      2|    if ((source != NULL) && (source->entities != NULL)) {
  ------------------
  |  Branch (1192:9): [True: 2, False: 0]
  |  Branch (1192:29): [True: 0, False: 2]
  ------------------
 1193|      0|	xmlXIncludeMergeData data;
 1194|       |
 1195|      0|	data.ctxt = ctxt;
 1196|      0|	data.doc = doc;
 1197|       |
 1198|      0|	xmlHashScan((xmlHashTablePtr) source->entities,
 1199|      0|		    xmlXIncludeMergeEntity, &data);
 1200|      0|    }
 1201|      2|    source = from->extSubset;
 1202|      2|    if ((source != NULL) && (source->entities != NULL)) {
  ------------------
  |  Branch (1202:9): [True: 0, False: 2]
  |  Branch (1202:29): [True: 0, False: 0]
  ------------------
 1203|      0|	xmlXIncludeMergeData data;
 1204|       |
 1205|      0|	data.ctxt = ctxt;
 1206|      0|	data.doc = doc;
 1207|       |
 1208|       |	/*
 1209|       |	 * don't duplicate existing stuff when external subsets are the same
 1210|       |	 */
 1211|      0|	if ((!xmlStrEqual(target->ExternalID, source->ExternalID)) &&
  ------------------
  |  Branch (1211:6): [True: 0, False: 0]
  ------------------
 1212|      0|	    (!xmlStrEqual(target->SystemID, source->SystemID))) {
  ------------------
  |  Branch (1212:6): [True: 0, False: 0]
  ------------------
 1213|      0|	    xmlHashScan((xmlHashTablePtr) source->entities,
 1214|      0|			xmlXIncludeMergeEntity, &data);
 1215|      0|	}
 1216|      0|    }
 1217|      2|    return(0);
 1218|      2|}
xinclude.c:xmlXIncludeRecurseDoc:
  583|     18|	              const xmlURL url ATTRIBUTE_UNUSED) {
  584|     18|    xmlDocPtr oldDoc;
  585|     18|    xmlXIncludeRefPtr *oldIncTab;
  586|     18|    int oldIncMax, oldIncNr, oldIsStream;
  587|     18|    int i;
  588|       |
  589|     18|    oldDoc = ctxt->doc;
  590|     18|    oldIncMax = ctxt->incMax;
  591|     18|    oldIncNr = ctxt->incNr;
  592|     18|    oldIncTab = ctxt->incTab;
  593|     18|    oldIsStream = ctxt->isStream;
  594|     18|    ctxt->doc = doc;
  595|     18|    ctxt->incMax = 0;
  596|     18|    ctxt->incNr = 0;
  597|     18|    ctxt->incTab = NULL;
  598|     18|    ctxt->isStream = 0;
  599|       |
  600|     18|    xmlXIncludeDoProcess(ctxt, xmlDocGetRootElement(doc));
  601|       |
  602|     18|    if (ctxt->incTab != NULL) {
  ------------------
  |  Branch (602:9): [True: 4, False: 14]
  ------------------
  603|      8|        for (i = 0; i < ctxt->incNr; i++)
  ------------------
  |  Branch (603:21): [True: 4, False: 4]
  ------------------
  604|      4|            xmlXIncludeFreeRef(ctxt->incTab[i]);
  605|      4|        xmlFree(ctxt->incTab);
  606|      4|    }
  607|       |
  608|     18|    ctxt->doc = oldDoc;
  609|     18|    ctxt->incMax = oldIncMax;
  610|     18|    ctxt->incNr = oldIncNr;
  611|     18|    ctxt->incTab = oldIncTab;
  612|     18|    ctxt->isStream = oldIsStream;
  613|     18|}
xinclude.c:xmlXIncludeCopyXPointer:
  974|     84|xmlXIncludeCopyXPointer(xmlXIncludeCtxtPtr ctxt, xmlXPathObjectPtr obj) {
  975|     84|    xmlNodePtr list = NULL, last = NULL, copy;
  976|     84|    int i;
  977|       |
  978|     84|    if ((ctxt == NULL) || (obj == NULL))
  ------------------
  |  Branch (978:9): [True: 0, False: 84]
  |  Branch (978:27): [True: 0, False: 84]
  ------------------
  979|      0|	return(NULL);
  980|     84|    switch (obj->type) {
  981|     84|        case XPATH_NODESET: {
  ------------------
  |  Branch (981:9): [True: 84, False: 0]
  ------------------
  982|     84|	    xmlNodeSetPtr set = obj->nodesetval;
  983|     84|	    if (set == NULL)
  ------------------
  |  Branch (983:10): [True: 0, False: 84]
  ------------------
  984|      0|		return(NULL);
  985|    171|	    for (i = 0;i < set->nodeNr;i++) {
  ------------------
  |  Branch (985:17): [True: 92, False: 79]
  ------------------
  986|     92|                xmlNodePtr node;
  987|       |
  988|     92|		if (set->nodeTab[i] == NULL)
  ------------------
  |  Branch (988:7): [True: 0, False: 92]
  ------------------
  989|      0|		    continue;
  990|     92|		switch (set->nodeTab[i]->type) {
  991|      0|		    case XML_DOCUMENT_NODE:
  ------------------
  |  Branch (991:7): [True: 0, False: 92]
  ------------------
  992|      0|		    case XML_HTML_DOCUMENT_NODE:
  ------------------
  |  Branch (992:7): [True: 0, False: 92]
  ------------------
  993|      0|                        node = xmlDocGetRootElement(
  994|      0|                                (xmlDocPtr) set->nodeTab[i]);
  995|      0|                        if (node == NULL) {
  ------------------
  |  Branch (995:29): [True: 0, False: 0]
  ------------------
  996|      0|                            xmlXIncludeErr(ctxt, set->nodeTab[i],
  997|      0|                                           XML_ERR_INTERNAL_ERROR,
  998|      0|                                           "document without root\n", NULL);
  999|      0|                            continue;
 1000|      0|                        }
 1001|      0|                        break;
 1002|      2|		    case XML_TEXT_NODE:
  ------------------
  |  Branch (1002:7): [True: 2, False: 90]
  ------------------
 1003|      2|		    case XML_CDATA_SECTION_NODE:
  ------------------
  |  Branch (1003:7): [True: 0, False: 92]
  ------------------
 1004|     92|		    case XML_ELEMENT_NODE:
  ------------------
  |  Branch (1004:7): [True: 90, False: 2]
  ------------------
 1005|     92|		    case XML_PI_NODE:
  ------------------
  |  Branch (1005:7): [True: 0, False: 92]
  ------------------
 1006|     92|		    case XML_COMMENT_NODE:
  ------------------
  |  Branch (1006:7): [True: 0, False: 92]
  ------------------
 1007|     92|                        node = set->nodeTab[i];
 1008|     92|			break;
 1009|      0|                    default:
  ------------------
  |  Branch (1009:21): [True: 0, False: 92]
  ------------------
 1010|      0|                        xmlXIncludeErr(ctxt, set->nodeTab[i],
 1011|      0|                                       XML_XINCLUDE_XPTR_RESULT,
 1012|      0|                                       "invalid node type in XPtr result\n",
 1013|      0|                                       NULL);
 1014|      0|			continue; /* for */
 1015|     92|		}
 1016|       |                /*
 1017|       |                 * OPTIMIZE TODO: External documents should already be
 1018|       |                 * expanded, so xmlDocCopyNode should work as well.
 1019|       |                 * xmlXIncludeCopyNode is only required for the initial
 1020|       |                 * document.
 1021|       |                 */
 1022|     92|		copy = xmlXIncludeCopyNode(ctxt, node, 0);
 1023|     92|                if (copy == NULL) {
  ------------------
  |  Branch (1023:21): [True: 5, False: 87]
  ------------------
 1024|      5|                    xmlFreeNodeList(list);
 1025|      5|                    return(NULL);
 1026|      5|                }
 1027|     87|		if (last == NULL) {
  ------------------
  |  Branch (1027:7): [True: 79, False: 8]
  ------------------
 1028|     79|                    list = copy;
 1029|     79|                } else {
 1030|      8|                    while (last->next != NULL)
  ------------------
  |  Branch (1030:28): [True: 0, False: 8]
  ------------------
 1031|      0|                        last = last->next;
 1032|      8|                    copy->prev = last;
 1033|      8|                    last->next = copy;
 1034|      8|		}
 1035|     87|                last = copy;
 1036|     87|	    }
 1037|     79|	    break;
 1038|     84|	}
 1039|       |#ifdef LIBXML_XPTR_LOCS_ENABLED
 1040|       |	case XPATH_LOCATIONSET: {
 1041|       |	    xmlLocationSetPtr set = (xmlLocationSetPtr) obj->user;
 1042|       |	    if (set == NULL)
 1043|       |		return(NULL);
 1044|       |	    for (i = 0;i < set->locNr;i++) {
 1045|       |		if (last == NULL)
 1046|       |		    list = last = xmlXIncludeCopyXPointer(ctxt,
 1047|       |			                                  set->locTab[i]);
 1048|       |		else
 1049|       |		    xmlAddNextSibling(last,
 1050|       |			    xmlXIncludeCopyXPointer(ctxt, set->locTab[i]));
 1051|       |		if (last != NULL) {
 1052|       |		    while (last->next != NULL)
 1053|       |			last = last->next;
 1054|       |		}
 1055|       |	    }
 1056|       |	    break;
 1057|       |	}
 1058|       |	case XPATH_RANGE:
 1059|       |	    return(xmlXIncludeCopyRange(ctxt, obj));
 1060|       |	case XPATH_POINT:
 1061|       |	    /* points are ignored in XInclude */
 1062|       |	    break;
 1063|       |#endif
 1064|     79|	default:
  ------------------
  |  Branch (1064:2): [True: 0, False: 84]
  ------------------
 1065|      0|	    break;
 1066|     84|    }
 1067|     79|    return(list);
 1068|     84|}
xinclude.c:xmlXIncludeCopyNode:
  633|    170|                    int copyChildren) {
  634|    170|    xmlNodePtr result = NULL;
  635|    170|    xmlNodePtr insertParent = NULL;
  636|    170|    xmlNodePtr insertLast = NULL;
  637|    170|    xmlNodePtr cur;
  638|       |
  639|    170|    if (copyChildren) {
  ------------------
  |  Branch (639:9): [True: 78, False: 92]
  ------------------
  640|     78|        cur = elem->children;
  641|     78|        if (cur == NULL)
  ------------------
  |  Branch (641:13): [True: 0, False: 78]
  ------------------
  642|      0|            return(NULL);
  643|     92|    } else {
  644|     92|        cur = elem;
  645|     92|    }
  646|       |
  647|    497|    while (1) {
  ------------------
  |  Branch (647:12): [Folded - Ignored]
  ------------------
  648|    497|        xmlNodePtr copy = NULL;
  649|    497|        int recurse = 0;
  650|       |
  651|    497|        if ((cur->type == XML_DOCUMENT_NODE) ||
  ------------------
  |  Branch (651:13): [True: 0, False: 497]
  ------------------
  652|    497|            (cur->type == XML_DTD_NODE)) {
  ------------------
  |  Branch (652:13): [True: 0, False: 497]
  ------------------
  653|      0|            ;
  654|    497|        } else if ((cur->type == XML_ELEMENT_NODE) &&
  ------------------
  |  Branch (654:20): [True: 277, False: 220]
  ------------------
  655|    497|                   (cur->ns != NULL) &&
  ------------------
  |  Branch (655:20): [True: 133, False: 144]
  ------------------
  656|    497|                   (xmlStrEqual(cur->name, XINCLUDE_NODE)) &&
  ------------------
  |  |   42|    133|#define XINCLUDE_NODE (const xmlChar *) "include"
  ------------------
  |  Branch (656:20): [True: 130, False: 3]
  ------------------
  657|    497|                   ((xmlStrEqual(cur->ns->href, XINCLUDE_NS)) ||
  ------------------
  |  |   30|    130|#define XINCLUDE_NS (const xmlChar *) "http://www.w3.org/2003/XInclude"
  ------------------
  |  Branch (657:21): [True: 0, False: 130]
  ------------------
  658|    130|                    (xmlStrEqual(cur->ns->href, XINCLUDE_OLD_NS)))) {
  ------------------
  |  |   36|    130|#define XINCLUDE_OLD_NS (const xmlChar *) "http://www.w3.org/2001/XInclude"
  ------------------
  |  Branch (658:21): [True: 128, False: 2]
  ------------------
  659|    128|            xmlXIncludeRefPtr ref = xmlXIncludeExpandNode(ctxt, cur);
  660|       |
  661|    128|            if (ref == NULL)
  ------------------
  |  Branch (661:17): [True: 7, False: 121]
  ------------------
  662|      7|                goto error;
  663|       |            /*
  664|       |             * TODO: Insert XML_XINCLUDE_START and XML_XINCLUDE_END nodes
  665|       |             */
  666|    121|            if (ref->inc != NULL) {
  ------------------
  |  Branch (666:17): [True: 113, False: 8]
  ------------------
  667|    113|                copy = xmlStaticCopyNodeList(ref->inc, ctxt->doc,
  668|    113|                                             insertParent);
  669|    113|                if (copy == NULL)
  ------------------
  |  Branch (669:21): [True: 0, False: 113]
  ------------------
  670|      0|                    goto error;
  671|    113|            }
  672|    369|        } else {
  673|    369|            copy = xmlStaticCopyNode(cur, ctxt->doc, insertParent, 2);
  674|    369|            if (copy == NULL)
  ------------------
  |  Branch (674:17): [True: 0, False: 369]
  ------------------
  675|      0|                goto error;
  676|       |
  677|    369|            recurse = (cur->type != XML_ENTITY_REF_NODE) &&
  ------------------
  |  Branch (677:23): [True: 369, False: 0]
  ------------------
  678|    369|                      (cur->children != NULL);
  ------------------
  |  Branch (678:23): [True: 95, False: 274]
  ------------------
  679|    369|        }
  680|       |
  681|    490|        if (copy != NULL) {
  ------------------
  |  Branch (681:13): [True: 482, False: 8]
  ------------------
  682|    482|            if (result == NULL)
  ------------------
  |  Branch (682:17): [True: 168, False: 314]
  ------------------
  683|    168|                result = copy;
  684|    482|            if (insertLast != NULL) {
  ------------------
  |  Branch (684:17): [True: 228, False: 254]
  ------------------
  685|    228|                insertLast->next = copy;
  686|    228|                copy->prev = insertLast;
  687|    254|            } else if (insertParent != NULL) {
  ------------------
  |  Branch (687:24): [True: 86, False: 168]
  ------------------
  688|     86|                insertParent->children = copy;
  689|     86|            }
  690|    482|            insertLast = copy;
  691|  1.59k|            while (insertLast->next != NULL) {
  ------------------
  |  Branch (691:20): [True: 1.11k, False: 482]
  ------------------
  692|  1.11k|                insertLast = insertLast->next;
  693|  1.11k|            }
  694|    482|        }
  695|       |
  696|    490|        if (recurse) {
  ------------------
  |  Branch (696:13): [True: 95, False: 395]
  ------------------
  697|     95|            cur = cur->children;
  698|     95|            insertParent = insertLast;
  699|     95|            insertLast = NULL;
  700|     95|            continue;
  701|     95|        }
  702|       |
  703|    395|        if (cur == elem)
  ------------------
  |  Branch (703:13): [True: 3, False: 392]
  ------------------
  704|      3|            return(result);
  705|       |
  706|    396|        while (cur->next == NULL) {
  ------------------
  |  Branch (706:16): [True: 164, False: 232]
  ------------------
  707|    164|            if (insertParent != NULL)
  ------------------
  |  Branch (707:17): [True: 88, False: 76]
  ------------------
  708|     88|                insertParent->last = insertLast;
  709|    164|            cur = cur->parent;
  710|    164|            if (cur == elem)
  ------------------
  |  Branch (710:17): [True: 160, False: 4]
  ------------------
  711|    160|                return(result);
  712|      4|            insertLast = insertParent;
  713|      4|            insertParent = insertParent->parent;
  714|      4|        }
  715|       |
  716|    232|        cur = cur->next;
  717|    232|    }
  718|       |
  719|      7|error:
  720|      7|    xmlFreeNodeList(result);
  721|      7|    return(NULL);
  722|    170|}
xinclude.c:xmlXIncludeLoadTxt:
 1605|     10|                   xmlXIncludeRefPtr ref) {
 1606|     10|    xmlParserInputBufferPtr buf;
 1607|     10|    xmlNodePtr node = NULL;
 1608|     10|    xmlURIPtr uri = NULL;
 1609|     10|    xmlChar *URL = NULL;
 1610|     10|    int i;
 1611|     10|    int ret = -1;
 1612|     10|    xmlChar *encoding = NULL;
 1613|     10|    xmlCharEncoding enc = (xmlCharEncoding) 0;
 1614|     10|    xmlParserCtxtPtr pctxt = NULL;
 1615|     10|    xmlParserInputPtr inputStream = NULL;
 1616|     10|    int len;
 1617|     10|    const xmlChar *content;
 1618|       |
 1619|       |
 1620|       |    /* Don't read from stdin. */
 1621|     10|    if (xmlStrcmp(url, BAD_CAST "-") == 0)
  ------------------
  |  |   35|     10|#define BAD_CAST (xmlChar *)
  ------------------
  |  Branch (1621:9): [True: 0, False: 10]
  ------------------
 1622|      0|        url = BAD_CAST "./-";
  ------------------
  |  |   35|      0|#define BAD_CAST (xmlChar *)
  ------------------
 1623|       |
 1624|       |    /*
 1625|       |     * Check the URL and remove any fragment identifier
 1626|       |     */
 1627|     10|    uri = xmlParseURI((const char *)url);
 1628|     10|    if (uri == NULL) {
  ------------------
  |  Branch (1628:9): [True: 0, False: 10]
  ------------------
 1629|      0|	xmlXIncludeErr(ctxt, ref->elem, XML_XINCLUDE_HREF_URI,
 1630|      0|	               "invalid value URI %s\n", url);
 1631|      0|	goto error;
 1632|      0|    }
 1633|     10|    if (uri->fragment != NULL) {
  ------------------
  |  Branch (1633:9): [True: 0, False: 10]
  ------------------
 1634|      0|	xmlXIncludeErr(ctxt, ref->elem, XML_XINCLUDE_TEXT_FRAGMENT,
 1635|      0|	               "fragment identifier forbidden for text: %s\n",
 1636|      0|		       (const xmlChar *) uri->fragment);
 1637|      0|	goto error;
 1638|      0|    }
 1639|     10|    URL = xmlSaveUri(uri);
 1640|     10|    if (URL == NULL) {
  ------------------
  |  Branch (1640:9): [True: 0, False: 10]
  ------------------
 1641|      0|	xmlXIncludeErr(ctxt, ref->elem, XML_XINCLUDE_HREF_URI,
 1642|      0|	               "invalid value URI %s\n", url);
 1643|      0|	goto error;
 1644|      0|    }
 1645|       |
 1646|       |    /*
 1647|       |     * Handling of references to the local document are done
 1648|       |     * directly through ctxt->doc.
 1649|       |     */
 1650|     10|    if (URL[0] == 0) {
  ------------------
  |  Branch (1650:9): [True: 0, False: 10]
  ------------------
 1651|      0|	xmlXIncludeErr(ctxt, ref->elem, XML_XINCLUDE_TEXT_DOCUMENT,
 1652|      0|		       "text serialization of document not available\n", NULL);
 1653|      0|	goto error;
 1654|      0|    }
 1655|       |
 1656|       |    /*
 1657|       |     * Prevent reloading the document twice.
 1658|       |     */
 1659|     10|    for (i = 0; i < ctxt->txtNr; i++) {
  ------------------
  |  Branch (1659:17): [True: 0, False: 10]
  ------------------
 1660|      0|	if (xmlStrEqual(URL, ctxt->txtTab[i].url)) {
  ------------------
  |  Branch (1660:6): [True: 0, False: 0]
  ------------------
 1661|      0|            node = xmlNewDocText(ctxt->doc, ctxt->txtTab[i].text);
 1662|      0|	    goto loaded;
 1663|      0|	}
 1664|      0|    }
 1665|       |
 1666|       |    /*
 1667|       |     * Try to get the encoding if available
 1668|       |     */
 1669|     10|    if (ref->elem != NULL) {
  ------------------
  |  Branch (1669:9): [True: 10, False: 0]
  ------------------
 1670|     10|	encoding = xmlGetProp(ref->elem, XINCLUDE_PARSE_ENCODING);
  ------------------
  |  |   78|     10|#define XINCLUDE_PARSE_ENCODING (const xmlChar *) "encoding"
  ------------------
 1671|     10|    }
 1672|     10|    if (encoding != NULL) {
  ------------------
  |  Branch (1672:9): [True: 4, False: 6]
  ------------------
 1673|       |	/*
 1674|       |	 * TODO: we should not have to remap to the xmlCharEncoding
 1675|       |	 *       predefined set, a better interface than
 1676|       |	 *       xmlParserInputBufferCreateFilename should allow any
 1677|       |	 *       encoding supported by iconv
 1678|       |	 */
 1679|      4|        enc = xmlParseCharEncoding((const char *) encoding);
 1680|      4|	if (enc == XML_CHAR_ENCODING_ERROR) {
  ------------------
  |  Branch (1680:6): [True: 0, False: 4]
  ------------------
 1681|      0|	    xmlXIncludeErr(ctxt, ref->elem, XML_XINCLUDE_UNKNOWN_ENCODING,
 1682|      0|			   "encoding %s not supported\n", encoding);
 1683|      0|	    goto error;
 1684|      0|	}
 1685|      4|    }
 1686|       |
 1687|       |    /*
 1688|       |     * Load it.
 1689|       |     */
 1690|     10|    pctxt = xmlNewParserCtxt();
 1691|     10|    inputStream = xmlLoadExternalEntity((const char*)URL, NULL, pctxt);
 1692|     10|    if(inputStream == NULL)
  ------------------
  |  Branch (1692:8): [True: 0, False: 10]
  ------------------
 1693|      0|	goto error;
 1694|     10|    buf = inputStream->buf;
 1695|     10|    if (buf == NULL)
  ------------------
  |  Branch (1695:9): [True: 0, False: 10]
  ------------------
 1696|      0|	goto error;
 1697|     10|    if (buf->encoder)
  ------------------
  |  Branch (1697:9): [True: 0, False: 10]
  ------------------
 1698|      0|	xmlCharEncCloseFunc(buf->encoder);
 1699|     10|    buf->encoder = xmlGetCharEncodingHandler(enc);
 1700|     10|    node = xmlNewDocText(ctxt->doc, NULL);
 1701|     10|    if (node == NULL) {
  ------------------
  |  Branch (1701:9): [True: 0, False: 10]
  ------------------
 1702|      0|        xmlXIncludeErrMemory(ctxt, ref->elem, NULL);
 1703|      0|	goto error;
 1704|      0|    }
 1705|       |
 1706|       |    /*
 1707|       |     * Scan all chars from the resource and add the to the node
 1708|       |     */
 1709|     20|    while (xmlParserInputBufferRead(buf, 4096) > 0)
  ------------------
  |  Branch (1709:12): [True: 10, False: 10]
  ------------------
 1710|     10|        ;
 1711|       |
 1712|     10|    content = xmlBufContent(buf->buffer);
 1713|     10|    len = xmlBufLength(buf->buffer);
 1714|    266|    for (i = 0; i < len;) {
  ------------------
  |  Branch (1714:17): [True: 258, False: 8]
  ------------------
 1715|    258|        int cur;
 1716|    258|        int l;
 1717|       |
 1718|    258|        l = len - i;
 1719|    258|        cur = xmlGetUTF8Char(&content[i], &l);
 1720|    258|        if ((cur < 0) || (!IS_CHAR(cur))) {
  ------------------
  |  |  125|    256|#define IS_CHAR(c)   xmlIsCharQ(c)
  |  |  ------------------
  |  |  |  |  118|    256|#define xmlIsCharQ(c)		(((c) < 0x100) ? \
  |  |  |  |  ------------------
  |  |  |  |  |  Branch (118:25): [True: 256, False: 0]
  |  |  |  |  ------------------
  |  |  |  |  119|    256|				 xmlIsChar_ch((c)) :\
  |  |  |  |  ------------------
  |  |  |  |  |  |  108|    256|#define xmlIsChar_ch(c)		(((0x9 <= (c)) && ((c) <= 0xa)) || \
  |  |  |  |  |  |  ------------------
  |  |  |  |  |  |  |  Branch (108:28): [True: 256, False: 0]
  |  |  |  |  |  |  |  Branch (108:44): [True: 8, False: 248]
  |  |  |  |  |  |  ------------------
  |  |  |  |  |  |  109|    256|				 ((c) == 0xd) || \
  |  |  |  |  |  |  ------------------
  |  |  |  |  |  |  |  Branch (109:6): [True: 0, False: 248]
  |  |  |  |  |  |  ------------------
  |  |  |  |  |  |  110|    256|				  (0x20 <= (c)))
  |  |  |  |  |  |  ------------------
  |  |  |  |  |  |  |  Branch (110:7): [True: 248, False: 0]
  |  |  |  |  |  |  ------------------
  |  |  |  |  ------------------
  |  |  |  |  120|    256|				(((0x100 <= (c)) && ((c) <= 0xd7ff)) || \
  |  |  |  |  ------------------
  |  |  |  |  |  Branch (120:7): [True: 0, False: 0]
  |  |  |  |  |  Branch (120:25): [True: 0, False: 0]
  |  |  |  |  ------------------
  |  |  |  |  121|      0|				 ((0xe000 <= (c)) && ((c) <= 0xfffd)) || \
  |  |  |  |  ------------------
  |  |  |  |  |  Branch (121:7): [True: 0, False: 0]
  |  |  |  |  |  Branch (121:26): [True: 0, False: 0]
  |  |  |  |  ------------------
  |  |  |  |  122|      0|				 ((0x10000 <= (c)) && ((c) <= 0x10ffff))))
  |  |  |  |  ------------------
  |  |  |  |  |  Branch (122:7): [True: 0, False: 0]
  |  |  |  |  |  Branch (122:27): [True: 0, False: 0]
  |  |  |  |  ------------------
  |  |  ------------------
  ------------------
  |  Branch (1720:13): [True: 2, False: 256]
  |  Branch (1720:26): [True: 0, False: 256]
  ------------------
 1721|      2|            xmlXIncludeErr(ctxt, ref->elem, XML_XINCLUDE_INVALID_CHAR,
 1722|      2|                           "%s contains invalid char\n", URL);
 1723|      2|            goto error;
 1724|      2|        }
 1725|       |
 1726|    256|        i += l;
 1727|    256|    }
 1728|       |
 1729|      8|    xmlNodeAddContentLen(node, content, len);
 1730|       |
 1731|      8|    if (ctxt->txtNr >= ctxt->txtMax) {
  ------------------
  |  Branch (1731:9): [True: 8, False: 0]
  ------------------
 1732|      8|        xmlXIncludeTxt *tmp;
 1733|      8|#ifdef FUZZING_BUILD_MODE_UNSAFE_FOR_PRODUCTION
 1734|      8|        size_t newSize = ctxt->txtMax ? ctxt->txtMax * 2 : 1;
  ------------------
  |  Branch (1734:26): [True: 0, False: 8]
  ------------------
 1735|       |#else
 1736|       |        size_t newSize = ctxt->txtMax ? ctxt->txtMax * 2 : 8;
 1737|       |#endif
 1738|       |
 1739|      8|        tmp = xmlRealloc(ctxt->txtTab, sizeof(xmlXIncludeTxt) * newSize);
 1740|      8|        if (tmp == NULL) {
  ------------------
  |  Branch (1740:13): [True: 0, False: 8]
  ------------------
 1741|      0|            xmlXIncludeErrMemory(ctxt, ref->elem,
 1742|      0|                                 "growing XInclude text table");
 1743|      0|	    goto error;
 1744|      0|        }
 1745|      8|        ctxt->txtMax = newSize;
 1746|      8|        ctxt->txtTab = tmp;
 1747|      8|    }
 1748|      8|    ctxt->txtTab[ctxt->txtNr].text = xmlStrdup(node->content);
 1749|      8|    ctxt->txtTab[ctxt->txtNr].url = xmlStrdup(URL);
 1750|      8|    ctxt->txtNr++;
 1751|       |
 1752|      8|loaded:
 1753|       |    /*
 1754|       |     * Add the element as the replacement copy.
 1755|       |     */
 1756|      8|    ref->inc = node;
 1757|      8|    node = NULL;
 1758|      8|    ret = 0;
 1759|       |
 1760|     10|error:
 1761|     10|    xmlFreeNode(node);
 1762|     10|    xmlFreeInputStream(inputStream);
 1763|     10|    xmlFreeParserCtxt(pctxt);
 1764|     10|    xmlFree(encoding);
 1765|     10|    xmlFreeURI(uri);
 1766|     10|    xmlFree(URL);
 1767|     10|    return(ret);
 1768|      8|}
xinclude.c:xmlXIncludeLoadFallback:
 1783|     80|                        xmlXIncludeRefPtr ref) {
 1784|     80|    int ret = 0;
 1785|     80|    int oldNbErrors;
 1786|       |
 1787|     80|    if ((fallback == NULL) || (fallback->type == XML_NAMESPACE_DECL) ||
  ------------------
  |  Branch (1787:9): [True: 0, False: 80]
  |  Branch (1787:31): [True: 0, False: 80]
  ------------------
 1788|     80|        (ctxt == NULL))
  ------------------
  |  Branch (1788:9): [True: 0, False: 80]
  ------------------
 1789|      0|	return(-1);
 1790|     80|    if (fallback->children != NULL) {
  ------------------
  |  Branch (1790:9): [True: 78, False: 2]
  ------------------
 1791|       |	/*
 1792|       |	 * It's possible that the fallback also has 'includes'
 1793|       |	 * (Bug 129969), so we re-process the fallback just in case
 1794|       |	 */
 1795|     78|        oldNbErrors = ctxt->nbErrors;
 1796|     78|	ref->inc = xmlXIncludeCopyNode(ctxt, fallback, 1);
 1797|     78|	if (ctxt->nbErrors > oldNbErrors)
  ------------------
  |  Branch (1797:6): [True: 4, False: 74]
  ------------------
 1798|      4|	    ret = -1;
 1799|     74|        else if (ref->inc == NULL)
  ------------------
  |  Branch (1799:18): [True: 2, False: 72]
  ------------------
 1800|      2|            ref->emptyFb = 1;
 1801|     78|    } else {
 1802|      2|        ref->inc = NULL;
 1803|      2|	ref->emptyFb = 1;	/* flag empty callback */
 1804|      2|    }
 1805|     80|    ref->fallback = 1;
 1806|     80|    return(ret);
 1807|     80|}
xinclude.c:xmlXIncludeIncludeNode:
 2041|     65|xmlXIncludeIncludeNode(xmlXIncludeCtxtPtr ctxt, xmlXIncludeRefPtr ref) {
 2042|     65|    xmlNodePtr cur, end, list, tmp;
 2043|       |
 2044|     65|    if ((ctxt == NULL) || (ref == NULL))
  ------------------
  |  Branch (2044:9): [True: 0, False: 65]
  |  Branch (2044:27): [True: 0, False: 65]
  ------------------
 2045|      0|	return(-1);
 2046|     65|    cur = ref->elem;
 2047|     65|    if ((cur == NULL) || (cur->type == XML_NAMESPACE_DECL))
  ------------------
  |  Branch (2047:9): [True: 0, False: 65]
  |  Branch (2047:26): [True: 0, False: 65]
  ------------------
 2048|      0|	return(-1);
 2049|       |
 2050|     65|    list = ref->inc;
 2051|     65|    ref->inc = NULL;
 2052|     65|    ref->emptyFb = 0;
 2053|       |
 2054|       |    /*
 2055|       |     * Check against the risk of generating a multi-rooted document
 2056|       |     */
 2057|     65|    if ((cur->parent != NULL) &&
  ------------------
  |  Branch (2057:9): [True: 65, False: 0]
  ------------------
 2058|     65|	(cur->parent->type != XML_ELEMENT_NODE)) {
  ------------------
  |  Branch (2058:2): [True: 2, False: 63]
  ------------------
 2059|      2|	int nb_elem = 0;
 2060|       |
 2061|      2|	tmp = list;
 2062|      2|	while (tmp != NULL) {
  ------------------
  |  Branch (2062:9): [True: 0, False: 2]
  ------------------
 2063|      0|	    if (tmp->type == XML_ELEMENT_NODE)
  ------------------
  |  Branch (2063:10): [True: 0, False: 0]
  ------------------
 2064|      0|		nb_elem++;
 2065|      0|	    tmp = tmp->next;
 2066|      0|	}
 2067|      2|	if (nb_elem > 1) {
  ------------------
  |  Branch (2067:6): [True: 0, False: 2]
  ------------------
 2068|      0|	    xmlXIncludeErr(ctxt, ref->elem, XML_XINCLUDE_MULTIPLE_ROOT,
 2069|      0|		       "XInclude error: would result in multiple root nodes\n",
 2070|      0|			   NULL);
 2071|      0|            xmlFreeNodeList(list);
 2072|      0|	    return(-1);
 2073|      0|	}
 2074|      2|    }
 2075|       |
 2076|     65|    if (ctxt->parseFlags & XML_PARSE_NOXINCNODE) {
  ------------------
  |  Branch (2076:9): [True: 0, False: 65]
  ------------------
 2077|       |	/*
 2078|       |	 * Add the list of nodes
 2079|       |	 */
 2080|      0|	while (list != NULL) {
  ------------------
  |  Branch (2080:9): [True: 0, False: 0]
  ------------------
 2081|      0|	    end = list;
 2082|      0|	    list = list->next;
 2083|       |
 2084|      0|	    xmlAddPrevSibling(cur, end);
 2085|      0|	}
 2086|       |        /*
 2087|       |         * FIXME: xmlUnlinkNode doesn't coalesce text nodes.
 2088|       |         */
 2089|      0|	xmlUnlinkNode(cur);
 2090|      0|	xmlFreeNode(cur);
 2091|     65|    } else {
 2092|     65|        xmlNodePtr child, next;
 2093|       |
 2094|       |	/*
 2095|       |	 * Change the current node as an XInclude start one, and add an
 2096|       |	 * XInclude end one
 2097|       |	 */
 2098|     65|        if (ref->fallback)
  ------------------
  |  Branch (2098:13): [True: 26, False: 39]
  ------------------
 2099|     26|            xmlUnsetProp(cur, BAD_CAST "href");
  ------------------
  |  |   35|     26|#define BAD_CAST (xmlChar *)
  ------------------
 2100|     65|	cur->type = XML_XINCLUDE_START;
 2101|       |        /* Remove fallback children */
 2102|    148|        for (child = cur->children; child != NULL; child = next) {
  ------------------
  |  Branch (2102:37): [True: 83, False: 65]
  ------------------
 2103|     83|            next = child->next;
 2104|     83|            xmlUnlinkNode(child);
 2105|     83|            xmlFreeNode(child);
 2106|     83|        }
 2107|     65|	end = xmlNewDocNode(cur->doc, cur->ns, cur->name, NULL);
 2108|     65|	if (end == NULL) {
  ------------------
  |  Branch (2108:6): [True: 0, False: 65]
  ------------------
 2109|      0|	    xmlXIncludeErr(ctxt, ref->elem, XML_XINCLUDE_BUILD_FAILED,
 2110|      0|			   "failed to build node\n", NULL);
 2111|      0|            xmlFreeNodeList(list);
 2112|      0|	    return(-1);
 2113|      0|	}
 2114|     65|	end->type = XML_XINCLUDE_END;
 2115|     65|	xmlAddNextSibling(cur, end);
 2116|       |
 2117|       |	/*
 2118|       |	 * Add the list of nodes
 2119|       |	 */
 2120|    340|	while (list != NULL) {
  ------------------
  |  Branch (2120:9): [True: 275, False: 65]
  ------------------
 2121|    275|	    cur = list;
 2122|    275|	    list = list->next;
 2123|       |
 2124|    275|	    xmlAddPrevSibling(end, cur);
 2125|    275|	}
 2126|     65|    }
 2127|       |
 2128|       |
 2129|     65|    return(0);
 2130|     65|}

xmlCheckFilename:
  679|    120|{
  680|    120|#ifdef HAVE_STAT
  681|       |#if defined(_WIN32)
  682|       |    struct _stat stat_buffer;
  683|       |#else
  684|    120|    struct stat stat_buffer;
  685|    120|#endif
  686|    120|#endif
  687|    120|    if (path == NULL)
  ------------------
  |  Branch (687:9): [True: 0, False: 120]
  ------------------
  688|      0|	return(0);
  689|       |
  690|    120|#ifdef HAVE_STAT
  691|       |#if defined(_WIN32)
  692|       |    /*
  693|       |     * On Windows stat and wstat do not work with long pathname,
  694|       |     * which start with '\\?\'
  695|       |     */
  696|       |    if ((path[0] == '\\') && (path[1] == '\\') && (path[2] == '?') &&
  697|       |	(path[3] == '\\') )
  698|       |	    return 1;
  699|       |
  700|       |    if (xmlWrapStatUtf8(path, &stat_buffer) == -1)
  701|       |        return 0;
  702|       |#else
  703|    120|    if (stat(path, &stat_buffer) == -1)
  ------------------
  |  Branch (703:9): [True: 120, False: 0]
  ------------------
  704|    120|        return 0;
  705|      0|#endif
  706|      0|#ifdef S_ISDIR
  707|      0|    if (S_ISDIR(stat_buffer.st_mode))
  708|      0|        return 2;
  709|      0|#endif
  710|      0|#endif /* HAVE_STAT */
  711|      0|    return 1;
  712|      0|}
xmlRegisterInputCallbacks:
 2102|      6|	xmlInputCloseCallback closeFunc) {
 2103|      6|    if (xmlInputCallbackNr >= MAX_INPUT_CALLBACK) {
  ------------------
  |  |   85|      6|#define MAX_INPUT_CALLBACK 15
  ------------------
  |  Branch (2103:9): [True: 0, False: 6]
  ------------------
 2104|      0|	return(-1);
 2105|      0|    }
 2106|      6|    xmlInputCallbackTable[xmlInputCallbackNr].matchcallback = matchFunc;
 2107|      6|    xmlInputCallbackTable[xmlInputCallbackNr].opencallback = openFunc;
 2108|      6|    xmlInputCallbackTable[xmlInputCallbackNr].readcallback = readFunc;
 2109|      6|    xmlInputCallbackTable[xmlInputCallbackNr].closecallback = closeFunc;
 2110|      6|    xmlInputCallbackInitialized = 1;
 2111|      6|    return(xmlInputCallbackNr++);
 2112|      6|}
xmlRegisterOutputCallbacks:
 2129|      2|	xmlOutputCloseCallback closeFunc) {
 2130|      2|    if (xmlOutputCallbackNr >= MAX_OUTPUT_CALLBACK) {
  ------------------
  |  |  102|      2|#define MAX_OUTPUT_CALLBACK 15
  ------------------
  |  Branch (2130:9): [True: 0, False: 2]
  ------------------
 2131|      0|	return(-1);
 2132|      0|    }
 2133|      2|    xmlOutputCallbackTable[xmlOutputCallbackNr].matchcallback = matchFunc;
 2134|      2|    xmlOutputCallbackTable[xmlOutputCallbackNr].opencallback = openFunc;
 2135|      2|    xmlOutputCallbackTable[xmlOutputCallbackNr].writecallback = writeFunc;
 2136|      2|    xmlOutputCallbackTable[xmlOutputCallbackNr].closecallback = closeFunc;
 2137|      2|    xmlOutputCallbackInitialized = 1;
 2138|      2|    return(xmlOutputCallbackNr++);
 2139|      2|}
xmlRegisterDefaultInputCallbacks:
 2148|      2|xmlRegisterDefaultInputCallbacks(void) {
 2149|      2|    if (xmlInputCallbackInitialized)
  ------------------
  |  Branch (2149:9): [True: 0, False: 2]
  ------------------
 2150|      0|	return;
 2151|       |
 2152|      2|    xmlRegisterInputCallbacks(xmlFileMatch, xmlFileOpen,
 2153|      2|	                      xmlFileRead, xmlFileClose);
 2154|      2|#ifdef LIBXML_ZLIB_ENABLED
 2155|      2|    xmlRegisterInputCallbacks(xmlGzfileMatch, xmlGzfileOpen,
 2156|      2|	                      xmlGzfileRead, xmlGzfileClose);
 2157|      2|#endif /* LIBXML_ZLIB_ENABLED */
 2158|      2|#ifdef LIBXML_LZMA_ENABLED
 2159|      2|    xmlRegisterInputCallbacks(xmlXzfileMatch, xmlXzfileOpen,
 2160|      2|	                      xmlXzfileRead, xmlXzfileClose);
 2161|      2|#endif /* LIBXML_LZMA_ENABLED */
 2162|       |
 2163|       |#ifdef LIBXML_HTTP_ENABLED
 2164|       |    xmlRegisterInputCallbacks(xmlIOHTTPMatch, xmlIOHTTPOpen,
 2165|       |	                      xmlIOHTTPRead, xmlIOHTTPClose);
 2166|       |#endif /* LIBXML_HTTP_ENABLED */
 2167|       |
 2168|       |#ifdef LIBXML_FTP_ENABLED
 2169|       |    xmlRegisterInputCallbacks(xmlIOFTPMatch, xmlIOFTPOpen,
 2170|       |	                      xmlIOFTPRead, xmlIOFTPClose);
 2171|       |#endif /* LIBXML_FTP_ENABLED */
 2172|      2|    xmlInputCallbackInitialized = 1;
 2173|      2|}
xmlRegisterDefaultOutputCallbacks:
 2182|      2|xmlRegisterDefaultOutputCallbacks (void) {
 2183|      2|    if (xmlOutputCallbackInitialized)
  ------------------
  |  Branch (2183:9): [True: 0, False: 2]
  ------------------
 2184|      0|	return;
 2185|       |
 2186|      2|    xmlRegisterOutputCallbacks(xmlFileMatch, xmlFileOpenW,
 2187|      2|	                      xmlFileWrite, xmlFileClose);
 2188|       |
 2189|       |#ifdef LIBXML_HTTP_ENABLED
 2190|       |    xmlRegisterOutputCallbacks(xmlIOHTTPMatch, xmlIOHTTPDfltOpenW,
 2191|       |	                       xmlIOHTTPWrite, xmlIOHTTPClosePut);
 2192|       |#endif
 2193|       |
 2194|       |/*********************************
 2195|       | No way a-priori to distinguish between gzipped files from
 2196|       | uncompressed ones except opening if existing then closing
 2197|       | and saving with same compression ratio ... a pain.
 2198|       |
 2199|       |#ifdef LIBXML_ZLIB_ENABLED
 2200|       |    xmlRegisterOutputCallbacks(xmlGzfileMatch, xmlGzfileOpen,
 2201|       |	                       xmlGzfileWrite, xmlGzfileClose);
 2202|       |#endif
 2203|       |
 2204|       | Nor FTP PUT ....
 2205|       |#ifdef LIBXML_FTP_ENABLED
 2206|       |    xmlRegisterOutputCallbacks(xmlIOFTPMatch, xmlIOFTPOpen,
 2207|       |	                       xmlIOFTPWrite, xmlIOFTPClose);
 2208|       |#endif
 2209|       | **********************************/
 2210|      2|    xmlOutputCallbackInitialized = 1;
 2211|      2|}
xmlAllocParserInputBuffer:
 2246|    540|xmlAllocParserInputBuffer(xmlCharEncoding enc) {
 2247|    540|    xmlParserInputBufferPtr ret;
 2248|       |
 2249|    540|    ret = (xmlParserInputBufferPtr) xmlMalloc(sizeof(xmlParserInputBuffer));
 2250|    540|    if (ret == NULL) {
  ------------------
  |  Branch (2250:9): [True: 0, False: 540]
  ------------------
 2251|      0|	return(NULL);
 2252|      0|    }
 2253|    540|    memset(ret, 0, sizeof(xmlParserInputBuffer));
 2254|    540|    ret->buffer = xmlBufCreateSize(2 * xmlDefaultBufferSize);
  ------------------
  |  |  680|    540|  #define xmlDefaultBufferSize XML_GLOBAL_MACRO(xmlDefaultBufferSize)
  |  |  ------------------
  |  |  |  |  500|    540|  #define XML_GLOBAL_MACRO(name) (*__##name())
  |  |  ------------------
  ------------------
 2255|    540|    if (ret->buffer == NULL) {
  ------------------
  |  Branch (2255:9): [True: 0, False: 540]
  ------------------
 2256|      0|        xmlFree(ret);
 2257|      0|	return(NULL);
 2258|      0|    }
 2259|    540|    xmlBufSetAllocationScheme(ret->buffer, XML_BUFFER_ALLOC_DOUBLEIT);
 2260|    540|    ret->encoder = xmlGetCharEncodingHandler(enc);
 2261|    540|    if (ret->encoder != NULL)
  ------------------
  |  Branch (2261:9): [True: 0, False: 540]
  ------------------
 2262|      0|        ret->raw = xmlBufCreateSize(2 * xmlDefaultBufferSize);
  ------------------
  |  |  680|      0|  #define xmlDefaultBufferSize XML_GLOBAL_MACRO(xmlDefaultBufferSize)
  |  |  ------------------
  |  |  |  |  500|      0|  #define XML_GLOBAL_MACRO(name) (*__##name())
  |  |  ------------------
  ------------------
 2263|    540|    else
 2264|    540|        ret->raw = NULL;
 2265|    540|    ret->readcallback = NULL;
 2266|    540|    ret->closecallback = NULL;
 2267|    540|    ret->context = NULL;
 2268|    540|    ret->compressed = -1;
 2269|    540|    ret->rawconsumed = 0;
 2270|       |
 2271|    540|    return(ret);
 2272|    540|}
xmlFreeParserInputBuffer:
 2383|    540|xmlFreeParserInputBuffer(xmlParserInputBufferPtr in) {
 2384|    540|    if (in == NULL) return;
  ------------------
  |  Branch (2384:9): [True: 0, False: 540]
  ------------------
 2385|       |
 2386|    540|    if (in->raw) {
  ------------------
  |  Branch (2386:9): [True: 18, False: 522]
  ------------------
 2387|     18|        xmlBufFree(in->raw);
 2388|     18|	in->raw = NULL;
 2389|     18|    }
 2390|    540|    if (in->encoder != NULL) {
  ------------------
  |  Branch (2390:9): [True: 18, False: 522]
  ------------------
 2391|     18|        xmlCharEncCloseFunc(in->encoder);
 2392|     18|    }
 2393|    540|    if (in->closecallback != NULL) {
  ------------------
  |  Branch (2393:9): [True: 373, False: 167]
  ------------------
 2394|    373|	in->closecallback(in->context);
 2395|    373|    }
 2396|    540|    if (in->buffer != NULL) {
  ------------------
  |  Branch (2396:9): [True: 540, False: 0]
  ------------------
 2397|    540|        xmlBufFree(in->buffer);
 2398|    540|	in->buffer = NULL;
 2399|    540|    }
 2400|       |
 2401|    540|    xmlFree(in);
 2402|    540|}
xmlParserInputBufferCreateMem:
 2870|    373|xmlParserInputBufferCreateMem(const char *mem, int size, xmlCharEncoding enc) {
 2871|    373|    xmlParserInputBufferPtr ret;
 2872|    373|    xmlMemIOCtxt *ctxt;
 2873|       |
 2874|    373|    if (size < 0) return(NULL);
  ------------------
  |  Branch (2874:9): [True: 0, False: 373]
  ------------------
 2875|    373|    if (mem == NULL) return(NULL);
  ------------------
  |  Branch (2875:9): [True: 0, False: 373]
  ------------------
 2876|       |
 2877|    373|    ret = xmlAllocParserInputBuffer(enc);
 2878|    373|    if (ret == NULL)
  ------------------
  |  Branch (2878:9): [True: 0, False: 373]
  ------------------
 2879|      0|        return(NULL);
 2880|       |
 2881|    373|    ctxt = xmlMalloc(sizeof(*ctxt));
 2882|    373|    if (ctxt == NULL) {
  ------------------
  |  Branch (2882:9): [True: 0, False: 373]
  ------------------
 2883|      0|        xmlFreeParserInputBuffer(ret);
 2884|      0|        return(NULL);
 2885|      0|    }
 2886|    373|    ctxt->mem = mem;
 2887|    373|    ctxt->size = size;
 2888|       |
 2889|    373|    ret->context = ctxt;
 2890|    373|    ret->readcallback = xmlMemRead;
 2891|    373|    ret->closecallback = xmlMemClose;
 2892|       |
 2893|    373|    return(ret);
 2894|    373|}
xmlParserInputBufferPush:
 3116|    374|	                 int len, const char *buf) {
 3117|    374|    int nbchars = 0;
 3118|    374|    int ret;
 3119|       |
 3120|    374|    if (len < 0) return(0);
  ------------------
  |  Branch (3120:9): [True: 0, False: 374]
  ------------------
 3121|    374|    if ((in == NULL) || (in->error)) return(-1);
  ------------------
  |  Branch (3121:9): [True: 0, False: 374]
  |  Branch (3121:25): [True: 0, False: 374]
  ------------------
 3122|    374|    if (in->encoder != NULL) {
  ------------------
  |  Branch (3122:9): [True: 0, False: 374]
  ------------------
 3123|       |        /*
 3124|       |	 * Store the data in the incoming raw buffer
 3125|       |	 */
 3126|      0|        if (in->raw == NULL) {
  ------------------
  |  Branch (3126:13): [True: 0, False: 0]
  ------------------
 3127|      0|	    in->raw = xmlBufCreate();
 3128|      0|            if (in->raw == NULL) {
  ------------------
  |  Branch (3128:17): [True: 0, False: 0]
  ------------------
 3129|      0|                in->error = XML_ERR_NO_MEMORY;
 3130|      0|                return(-1);
 3131|      0|            }
 3132|      0|	}
 3133|      0|	ret = xmlBufAdd(in->raw, (const xmlChar *) buf, len);
 3134|      0|	if (ret != 0) {
  ------------------
  |  Branch (3134:6): [True: 0, False: 0]
  ------------------
 3135|      0|            in->error = XML_ERR_NO_MEMORY;
 3136|      0|	    return(-1);
 3137|      0|        }
 3138|       |
 3139|       |	/*
 3140|       |	 * convert as much as possible to the parser reading buffer.
 3141|       |	 */
 3142|      0|	nbchars = xmlCharEncInput(in);
 3143|      0|	if (nbchars < 0)
  ------------------
  |  Branch (3143:6): [True: 0, False: 0]
  ------------------
 3144|      0|	    return(-1);
 3145|    374|    } else {
 3146|    374|	nbchars = len;
 3147|    374|        ret = xmlBufAdd(in->buffer, (xmlChar *) buf, nbchars);
 3148|    374|	if (ret != 0) {
  ------------------
  |  Branch (3148:6): [True: 0, False: 374]
  ------------------
 3149|      0|            in->error = XML_ERR_NO_MEMORY;
 3150|      0|	    return(-1);
 3151|      0|        }
 3152|    374|    }
 3153|    374|    return(nbchars);
 3154|    374|}
xmlParserInputBufferGrow:
 3185|  14.5k|xmlParserInputBufferGrow(xmlParserInputBufferPtr in, int len) {
 3186|  14.5k|    xmlBufPtr buf;
 3187|  14.5k|    int res = 0;
 3188|       |
 3189|  14.5k|    if ((in == NULL) || (in->error)) return(-1);
  ------------------
  |  Branch (3189:9): [True: 0, False: 14.5k]
  |  Branch (3189:25): [True: 0, False: 14.5k]
  ------------------
 3190|  14.5k|    if ((len <= MINLEN) && (len != 4))
  ------------------
  |  |   73|  14.5k|#define MINLEN 4000
  ------------------
  |  Branch (3190:9): [True: 14.0k, False: 504]
  |  Branch (3190:28): [True: 13.8k, False: 167]
  ------------------
 3191|  13.8k|        len = MINLEN;
  ------------------
  |  |   73|  13.8k|#define MINLEN 4000
  ------------------
 3192|       |
 3193|  14.5k|    if (in->encoder == NULL) {
  ------------------
  |  Branch (3193:9): [True: 14.1k, False: 432]
  ------------------
 3194|  14.1k|        if (in->readcallback == NULL)
  ------------------
  |  Branch (3194:13): [True: 0, False: 14.1k]
  ------------------
 3195|      0|            return(0);
 3196|  14.1k|        buf = in->buffer;
 3197|  14.1k|    } else {
 3198|    432|        if (in->raw == NULL) {
  ------------------
  |  Branch (3198:13): [True: 4, False: 428]
  ------------------
 3199|      4|	    in->raw = xmlBufCreate();
 3200|      4|	}
 3201|    432|        buf = in->raw;
 3202|    432|    }
 3203|       |
 3204|       |    /*
 3205|       |     * Call the read method for this I/O type.
 3206|       |     */
 3207|  14.5k|    if (in->readcallback != NULL) {
  ------------------
  |  Branch (3207:9): [True: 14.5k, False: 0]
  ------------------
 3208|  14.5k|        if (xmlBufGrow(buf, len + 1) < 0) {
  ------------------
  |  Branch (3208:13): [True: 0, False: 14.5k]
  ------------------
 3209|      0|            in->error = XML_ERR_NO_MEMORY;
 3210|      0|            return(-1);
 3211|      0|        }
 3212|       |
 3213|  14.5k|	res = in->readcallback(in->context, (char *)xmlBufEnd(buf), len);
 3214|  14.5k|	if (res <= 0)
  ------------------
  |  Branch (3214:6): [True: 14.0k, False: 547]
  ------------------
 3215|  14.0k|	    in->readcallback = endOfInput;
 3216|  14.5k|        if (res < 0) {
  ------------------
  |  Branch (3216:13): [True: 0, False: 14.5k]
  ------------------
 3217|      0|            in->error = XML_IO_UNKNOWN;
 3218|      0|            return(-1);
 3219|      0|        }
 3220|       |
 3221|  14.5k|        if (xmlBufAddLen(buf, res) < 0) {
  ------------------
  |  Branch (3221:13): [True: 0, False: 14.5k]
  ------------------
 3222|      0|            in->error = XML_ERR_NO_MEMORY;
 3223|      0|            return(-1);
 3224|      0|        }
 3225|  14.5k|    }
 3226|       |
 3227|       |    /*
 3228|       |     * try to establish compressed status of input if not done already
 3229|       |     */
 3230|  14.5k|    if (in->compressed == -1) {
  ------------------
  |  Branch (3230:9): [True: 14.5k, False: 0]
  ------------------
 3231|  14.5k|#ifdef LIBXML_LZMA_ENABLED
 3232|  14.5k|	if (in->readcallback == xmlXzfileRead)
  ------------------
  |  Branch (3232:6): [True: 0, False: 14.5k]
  ------------------
 3233|      0|            in->compressed = __libxml2_xzcompressed(in->context);
 3234|  14.5k|#endif
 3235|  14.5k|    }
 3236|       |
 3237|  14.5k|    if (in->encoder != NULL) {
  ------------------
  |  Branch (3237:9): [True: 432, False: 14.1k]
  ------------------
 3238|    432|	res = xmlCharEncInput(in);
 3239|    432|	if (res < 0)
  ------------------
  |  Branch (3239:6): [True: 0, False: 432]
  ------------------
 3240|      0|	    return(-1);
 3241|    432|    }
 3242|  14.5k|    return(res);
 3243|  14.5k|}
xmlParserInputBufferRead:
 3258|    671|xmlParserInputBufferRead(xmlParserInputBufferPtr in, int len) {
 3259|    671|    return(xmlParserInputBufferGrow(in, len));
 3260|    671|}
xmlParserGetDirectory:
 3663|     29|xmlParserGetDirectory(const char *filename) {
 3664|     29|    char *ret = NULL;
 3665|     29|    char dir[1024];
 3666|     29|    char *cur;
 3667|       |
 3668|     29|    if (xmlInputCallbackInitialized == 0)
  ------------------
  |  Branch (3668:9): [True: 0, False: 29]
  ------------------
 3669|      0|	xmlRegisterDefaultInputCallbacks();
 3670|       |
 3671|     29|    if (filename == NULL) return(NULL);
  ------------------
  |  Branch (3671:9): [True: 0, False: 29]
  ------------------
 3672|       |
 3673|       |#if defined(_WIN32)
 3674|       |#   define IS_XMLPGD_SEP(ch) ((ch=='/')||(ch=='\\'))
 3675|       |#else
 3676|     29|#   define IS_XMLPGD_SEP(ch) (ch=='/')
 3677|     29|#endif
 3678|       |
 3679|     29|    strncpy(dir, filename, 1023);
 3680|     29|    dir[1023] = 0;
 3681|     29|    cur = &dir[strlen(dir)];
 3682|    419|    while (cur > dir) {
  ------------------
  |  Branch (3682:12): [True: 419, False: 0]
  ------------------
 3683|    419|         if (IS_XMLPGD_SEP(*cur)) break;
  ------------------
  |  | 3676|    419|#   define IS_XMLPGD_SEP(ch) (ch=='/')
  |  |  ------------------
  |  |  |  Branch (3676:30): [True: 29, False: 390]
  |  |  ------------------
  ------------------
 3684|    390|	 cur --;
 3685|    390|    }
 3686|     29|    if (IS_XMLPGD_SEP(*cur)) {
  ------------------
  |  | 3676|     29|#   define IS_XMLPGD_SEP(ch) (ch=='/')
  |  |  ------------------
  |  |  |  Branch (3676:30): [True: 29, False: 0]
  |  |  ------------------
  ------------------
 3687|     29|        if (cur == dir) dir[1] = 0;
  ------------------
  |  Branch (3687:13): [True: 0, False: 29]
  ------------------
 3688|     29|	else *cur = 0;
 3689|     29|	ret = xmlMemStrdup(dir);
 3690|     29|    } else {
 3691|      0|        if (getcwd(dir, 1024) != NULL) {
  ------------------
  |  Branch (3691:13): [True: 0, False: 0]
  ------------------
 3692|      0|	    dir[1023] = 0;
 3693|      0|	    ret = xmlMemStrdup(dir);
 3694|      0|	}
 3695|      0|    }
 3696|     29|    return(ret);
 3697|     29|#undef IS_XMLPGD_SEP
 3698|     29|}
xmlSetExternalEntityLoader:
 3937|      2|xmlSetExternalEntityLoader(xmlExternalEntityLoader f) {
 3938|      2|    xmlCurrentExternalEntityLoader = f;
 3939|      2|}
xmlLoadExternalEntity:
 3966|    120|                      xmlParserCtxtPtr ctxt) {
 3967|    120|    if ((URL != NULL) && (xmlNoNetExists(URL) == 0)) {
  ------------------
  |  Branch (3967:9): [True: 120, False: 0]
  |  Branch (3967:26): [True: 120, False: 0]
  ------------------
 3968|    120|	char *canonicFilename;
 3969|    120|	xmlParserInputPtr ret;
 3970|       |
 3971|    120|	canonicFilename = (char *) xmlCanonicPath((const xmlChar *) URL);
 3972|    120|	if (canonicFilename == NULL) {
  ------------------
  |  Branch (3972:6): [True: 0, False: 120]
  ------------------
 3973|      0|            xmlErrMemory(ctxt, "building canonical path\n");
 3974|      0|	    return(NULL);
 3975|      0|	}
 3976|       |
 3977|    120|	ret = xmlCurrentExternalEntityLoader(canonicFilename, ID, ctxt);
 3978|    120|	xmlFree(canonicFilename);
 3979|    120|	return(ret);
 3980|    120|    }
 3981|      0|    return(xmlCurrentExternalEntityLoader(URL, ID, ctxt));
 3982|    120|}
xmlIO.c:xmlMemRead:
 2839|    826|xmlMemRead(void *vctxt, char *buf, int size) {
 2840|    826|    xmlMemIOCtxt *ctxt = vctxt;
 2841|       |
 2842|    826|    if ((size_t) size > ctxt->size)
  ------------------
  |  Branch (2842:9): [True: 651, False: 175]
  ------------------
 2843|    651|        size = ctxt->size;
 2844|       |
 2845|    826|    memcpy(buf, ctxt->mem, size);
 2846|    826|    ctxt->mem += size;
 2847|    826|    ctxt->size -= size;
 2848|       |
 2849|    826|    return size;
 2850|    826|}
xmlIO.c:xmlMemClose:
 2853|    373|xmlMemClose(void *vctxt) {
 2854|    373|    xmlFree(vctxt);
 2855|    373|    return(0);
 2856|    373|}
xmlIO.c:endOfInput:
 3165|  13.7k|	    int len ATTRIBUTE_UNUSED) {
 3166|  13.7k|    return(0);
 3167|  13.7k|}
xmlIO.c:xmlNoNetExists:
 3781|    120|static int xmlNoNetExists(const char *URL) {
 3782|    120|    const char *path;
 3783|       |
 3784|    120|    if (URL == NULL)
  ------------------
  |  Branch (3784:9): [True: 0, False: 120]
  ------------------
 3785|      0|	return(0);
 3786|       |
 3787|    120|    if (!xmlStrncasecmp(BAD_CAST URL, BAD_CAST "file://localhost/", 17))
  ------------------
  |  |   35|    120|#define BAD_CAST (xmlChar *)
  ------------------
                  if (!xmlStrncasecmp(BAD_CAST URL, BAD_CAST "file://localhost/", 17))
  ------------------
  |  |   35|    120|#define BAD_CAST (xmlChar *)
  ------------------
  |  Branch (3787:9): [True: 0, False: 120]
  ------------------
 3788|       |#if defined (_WIN32)
 3789|       |	path = &URL[17];
 3790|       |#else
 3791|      0|	path = &URL[16];
 3792|    120|#endif
 3793|    120|    else if (!xmlStrncasecmp(BAD_CAST URL, BAD_CAST "file:///", 8)) {
  ------------------
  |  |   35|    120|#define BAD_CAST (xmlChar *)
  ------------------
                  else if (!xmlStrncasecmp(BAD_CAST URL, BAD_CAST "file:///", 8)) {
  ------------------
  |  |   35|    120|#define BAD_CAST (xmlChar *)
  ------------------
  |  Branch (3793:14): [True: 0, False: 120]
  ------------------
 3794|       |#if defined (_WIN32)
 3795|       |	path = &URL[8];
 3796|       |#else
 3797|      0|	path = &URL[7];
 3798|      0|#endif
 3799|      0|    } else
 3800|    120|	path = URL;
 3801|       |
 3802|    120|    return xmlCheckFilename(path);
 3803|    120|}

xmlInitMemoryInternal:
  846|      2|xmlInitMemoryInternal(void) {
  847|      2|     char *breakpoint;
  848|      2|     xmlInitMutex(&xmlMemMutex);
  849|       |
  850|      2|     breakpoint = getenv("XML_MEM_BREAKPOINT");
  851|      2|     if (breakpoint != NULL) {
  ------------------
  |  Branch (851:10): [True: 0, False: 2]
  ------------------
  852|      0|         sscanf(breakpoint, "%ud", &xmlMemStopAtBlock);
  853|      0|     }
  854|      2|     breakpoint = getenv("XML_MEM_TRACE");
  855|      2|     if (breakpoint != NULL) {
  ------------------
  |  Branch (855:10): [True: 0, False: 2]
  ------------------
  856|      0|         sscanf(breakpoint, "%p", &xmlMemTraceBlockAt);
  857|      0|     }
  858|       |
  859|      2|}
xmlMemSetup:
  910|      2|            xmlReallocFunc reallocFunc, xmlStrdupFunc strdupFunc) {
  911|      2|    if (freeFunc == NULL)
  ------------------
  |  Branch (911:9): [True: 0, False: 2]
  ------------------
  912|      0|	return(-1);
  913|      2|    if (mallocFunc == NULL)
  ------------------
  |  Branch (913:9): [True: 0, False: 2]
  ------------------
  914|      0|	return(-1);
  915|      2|    if (reallocFunc == NULL)
  ------------------
  |  Branch (915:9): [True: 0, False: 2]
  ------------------
  916|      0|	return(-1);
  917|      2|    if (strdupFunc == NULL)
  ------------------
  |  Branch (917:9): [True: 0, False: 2]
  ------------------
  918|      0|	return(-1);
  919|      2|    xmlFree = freeFunc;
  920|      2|    xmlMalloc = mallocFunc;
  921|      2|    xmlMallocAtomic = mallocFunc;
  922|      2|    xmlRealloc = reallocFunc;
  923|      2|    xmlMemStrdup = strdupFunc;
  924|      2|    return(0);
  925|      2|}

xmlTextReaderRead:
 1160|  3.63k|xmlTextReaderRead(xmlTextReaderPtr reader) {
 1161|  3.63k|    int val, olddepth = 0;
 1162|  3.63k|    xmlTextReaderState oldstate = XML_TEXTREADER_START;
 1163|  3.63k|    xmlNodePtr oldnode = NULL;
 1164|       |
 1165|       |
 1166|  3.63k|    if (reader == NULL)
  ------------------
  |  Branch (1166:9): [True: 0, False: 3.63k]
  ------------------
 1167|      0|	return(-1);
 1168|  3.63k|    reader->curnode = NULL;
 1169|  3.63k|    if (reader->doc != NULL)
  ------------------
  |  Branch (1169:9): [True: 0, False: 3.63k]
  ------------------
 1170|      0|        return(xmlTextReaderReadTree(reader));
 1171|  3.63k|    if (reader->ctxt == NULL)
  ------------------
  |  Branch (1171:9): [True: 0, False: 3.63k]
  ------------------
 1172|      0|	return(-1);
 1173|       |
 1174|  3.63k|    if (reader->mode == XML_TEXTREADER_MODE_INITIAL) {
  ------------------
  |  Branch (1174:9): [True: 167, False: 3.47k]
  ------------------
 1175|    167|	reader->mode = XML_TEXTREADER_MODE_INTERACTIVE;
 1176|       |	/*
 1177|       |	 * Initial state
 1178|       |	 */
 1179|    220|	do {
 1180|    220|	    val = xmlTextReaderPushData(reader);
 1181|    220|		if (val < 0){
  ------------------
  |  Branch (1181:7): [True: 101, False: 119]
  ------------------
 1182|    101|			reader->mode = XML_TEXTREADER_MODE_ERROR;
 1183|    101|			reader->state = XML_TEXTREADER_ERROR;
 1184|    101|		return(-1);
 1185|    101|		}
 1186|    220|	} while ((reader->ctxt->node == NULL) &&
  ------------------
  |  Branch (1186:11): [True: 89, False: 30]
  ------------------
 1187|    119|		 ((reader->mode != XML_TEXTREADER_MODE_EOF) &&
  ------------------
  |  Branch (1187:5): [True: 53, False: 36]
  ------------------
 1188|     89|		  (reader->state != XML_TEXTREADER_DONE)));
  ------------------
  |  Branch (1188:5): [True: 53, False: 0]
  ------------------
 1189|     66|	if (reader->ctxt->node == NULL) {
  ------------------
  |  Branch (1189:6): [True: 36, False: 30]
  ------------------
 1190|     36|	    if (reader->ctxt->myDoc != NULL) {
  ------------------
  |  Branch (1190:10): [True: 36, False: 0]
  ------------------
 1191|     36|		reader->node = reader->ctxt->myDoc->children;
 1192|     36|	    }
 1193|     36|	    if (reader->node == NULL){
  ------------------
  |  Branch (1193:10): [True: 0, False: 36]
  ------------------
 1194|      0|			reader->mode = XML_TEXTREADER_MODE_ERROR;
 1195|      0|			reader->state = XML_TEXTREADER_ERROR;
 1196|      0|		return(-1);
 1197|      0|		}
 1198|     36|	    reader->state = XML_TEXTREADER_ELEMENT;
 1199|     36|	} else {
 1200|     30|	    if (reader->ctxt->myDoc != NULL) {
  ------------------
  |  Branch (1200:10): [True: 30, False: 0]
  ------------------
 1201|     30|		reader->node = reader->ctxt->myDoc->children;
 1202|     30|	    }
 1203|     30|	    if (reader->node == NULL)
  ------------------
  |  Branch (1203:10): [True: 0, False: 30]
  ------------------
 1204|      0|		reader->node = reader->ctxt->nodeTab[0];
 1205|     30|	    reader->state = XML_TEXTREADER_ELEMENT;
 1206|     30|	}
 1207|     66|	reader->depth = 0;
 1208|     66|	reader->ctxt->parseMode = XML_PARSE_READER;
 1209|     66|	goto node_found;
 1210|     66|    }
 1211|  3.47k|    oldstate = reader->state;
 1212|  3.47k|    olddepth = reader->ctxt->nodeNr;
 1213|  3.47k|    oldnode = reader->node;
 1214|       |
 1215|  3.52k|get_next_node:
 1216|  3.52k|    if (reader->node == NULL) {
  ------------------
  |  Branch (1216:9): [True: 1.41k, False: 2.11k]
  ------------------
 1217|  1.41k|	if (reader->mode == XML_TEXTREADER_MODE_EOF)
  ------------------
  |  Branch (1217:6): [True: 400, False: 1.01k]
  ------------------
 1218|    400|	    return(0);
 1219|  1.01k|	else
 1220|  1.01k|	    return(-1);
 1221|  1.41k|    }
 1222|       |
 1223|       |    /*
 1224|       |     * If we are not backtracking on ancestors or examined nodes,
 1225|       |     * that the parser didn't finished or that we aren't at the end
 1226|       |     * of stream, continue processing.
 1227|       |     */
 1228|  2.13k|    while ((reader->node != NULL) && (reader->node->next == NULL) &&
  ------------------
  |  Branch (1228:12): [True: 2.13k, False: 0]
  |  Branch (1228:38): [True: 778, False: 1.35k]
  ------------------
 1229|  2.13k|	   (reader->ctxt->nodeNr == olddepth) &&
  ------------------
  |  Branch (1229:5): [True: 778, False: 0]
  ------------------
 1230|  2.13k|           ((oldstate == XML_TEXTREADER_BACKTRACK) ||
  ------------------
  |  Branch (1230:13): [True: 41, False: 737]
  ------------------
 1231|    778|            (reader->node->children == NULL) ||
  ------------------
  |  Branch (1231:13): [True: 535, False: 202]
  ------------------
 1232|    778|	    (reader->node->type == XML_ENTITY_REF_NODE) ||
  ------------------
  |  Branch (1232:6): [True: 0, False: 202]
  ------------------
 1233|    778|	    ((reader->node->children != NULL) &&
  ------------------
  |  Branch (1233:7): [True: 202, False: 0]
  ------------------
 1234|    202|	     (reader->node->children->type == XML_TEXT_NODE) &&
  ------------------
  |  Branch (1234:7): [True: 192, False: 10]
  ------------------
 1235|    202|	     (reader->node->children->next == NULL)) ||
  ------------------
  |  Branch (1235:7): [True: 130, False: 62]
  ------------------
 1236|    778|	    (reader->node->type == XML_DTD_NODE) ||
  ------------------
  |  Branch (1236:6): [True: 0, False: 72]
  ------------------
 1237|    778|	    (reader->node->type == XML_DOCUMENT_NODE) ||
  ------------------
  |  Branch (1237:6): [True: 0, False: 72]
  ------------------
 1238|    778|	    (reader->node->type == XML_HTML_DOCUMENT_NODE)) &&
  ------------------
  |  Branch (1238:6): [True: 0, False: 72]
  ------------------
 1239|  2.13k|	   ((reader->ctxt->node == NULL) ||
  ------------------
  |  Branch (1239:6): [True: 216, False: 490]
  ------------------
 1240|    706|	    (reader->ctxt->node == reader->node) ||
  ------------------
  |  Branch (1240:6): [True: 112, False: 378]
  ------------------
 1241|    706|	    (reader->ctxt->node == reader->node->parent)) &&
  ------------------
  |  Branch (1241:6): [True: 74, False: 304]
  ------------------
 1242|  2.13k|	   (reader->ctxt->instate != XML_PARSER_EOF)) {
  ------------------
  |  Branch (1242:5): [True: 260, False: 142]
  ------------------
 1243|    260|	val = xmlTextReaderPushData(reader);
 1244|    260|	if (val < 0){
  ------------------
  |  Branch (1244:6): [True: 235, False: 25]
  ------------------
 1245|    235|		reader->mode = XML_TEXTREADER_MODE_ERROR;
 1246|    235|		reader->state = XML_TEXTREADER_ERROR;
 1247|    235|	    return(-1);
 1248|    235|	}
 1249|     25|	if (reader->node == NULL)
  ------------------
  |  Branch (1249:6): [True: 0, False: 25]
  ------------------
 1250|      0|	    goto node_end;
 1251|     25|    }
 1252|  1.87k|    if (oldstate != XML_TEXTREADER_BACKTRACK) {
  ------------------
  |  Branch (1252:9): [True: 1.46k, False: 413]
  ------------------
 1253|  1.46k|	if ((reader->node->children != NULL) &&
  ------------------
  |  Branch (1253:6): [True: 436, False: 1.02k]
  ------------------
 1254|  1.46k|	    (reader->node->type != XML_ENTITY_REF_NODE) &&
  ------------------
  |  Branch (1254:6): [True: 436, False: 0]
  ------------------
 1255|  1.46k|	    (reader->node->type != XML_XINCLUDE_START) &&
  ------------------
  |  Branch (1255:6): [True: 436, False: 0]
  ------------------
 1256|  1.46k|	    (reader->node->type != XML_DTD_NODE)) {
  ------------------
  |  Branch (1256:6): [True: 433, False: 3]
  ------------------
 1257|    433|	    reader->node = reader->node->children;
 1258|    433|	    reader->depth++;
 1259|    433|	    reader->state = XML_TEXTREADER_ELEMENT;
 1260|    433|	    goto node_found;
 1261|    433|	}
 1262|  1.46k|    }
 1263|  1.44k|    if (reader->node->next != NULL) {
  ------------------
  |  Branch (1263:9): [True: 998, False: 446]
  ------------------
 1264|    998|	if ((oldstate == XML_TEXTREADER_ELEMENT) &&
  ------------------
  |  Branch (1264:6): [True: 623, False: 375]
  ------------------
 1265|    998|            (reader->node->type == XML_ELEMENT_NODE) &&
  ------------------
  |  Branch (1265:13): [True: 57, False: 566]
  ------------------
 1266|    998|	    (reader->node->children == NULL) &&
  ------------------
  |  Branch (1266:6): [True: 57, False: 0]
  ------------------
 1267|    998|	    ((reader->node->extra & NODE_IS_EMPTY) == 0)
  ------------------
  |  |  186|     57|#define NODE_IS_EMPTY		0x1
  ------------------
  |  Branch (1267:6): [True: 23, False: 34]
  ------------------
 1268|    998|#ifdef LIBXML_XINCLUDE_ENABLED
 1269|    998|	    && (reader->in_xinclude <= 0)
  ------------------
  |  Branch (1269:9): [True: 0, False: 23]
  ------------------
 1270|    998|#endif
 1271|    998|	    ) {
 1272|      0|	    reader->state = XML_TEXTREADER_END;
 1273|      0|	    goto node_found;
 1274|      0|	}
 1275|    998|#ifdef LIBXML_REGEXP_ENABLED
 1276|    998|	if ((reader->validate) &&
  ------------------
  |  Branch (1276:6): [True: 0, False: 998]
  ------------------
 1277|    998|	    (reader->node->type == XML_ELEMENT_NODE))
  ------------------
  |  Branch (1277:6): [True: 0, False: 0]
  ------------------
 1278|      0|	    xmlTextReaderValidatePop(reader);
 1279|    998|#endif /* LIBXML_REGEXP_ENABLED */
 1280|    998|        if ((reader->preserves > 0) &&
  ------------------
  |  Branch (1280:13): [True: 0, False: 998]
  ------------------
 1281|    998|	    (reader->node->extra & NODE_IS_SPRESERVED))
  ------------------
  |  |  188|      0|#define NODE_IS_SPRESERVED	0x4
  ------------------
  |  Branch (1281:6): [True: 0, False: 0]
  ------------------
 1282|      0|	    reader->preserves--;
 1283|    998|	reader->node = reader->node->next;
 1284|    998|	reader->state = XML_TEXTREADER_ELEMENT;
 1285|       |
 1286|       |	/*
 1287|       |	 * Cleanup of the old node
 1288|       |	 */
 1289|    998|	if ((reader->preserves == 0) &&
  ------------------
  |  Branch (1289:6): [True: 998, False: 0]
  ------------------
 1290|    998|#ifdef LIBXML_XINCLUDE_ENABLED
 1291|    998|	    (reader->in_xinclude == 0) &&
  ------------------
  |  Branch (1291:6): [True: 838, False: 160]
  ------------------
 1292|    998|#endif
 1293|    998|	    (reader->entNr == 0) &&
  ------------------
  |  Branch (1293:6): [True: 838, False: 0]
  ------------------
 1294|    998|	    (reader->node->prev != NULL) &&
  ------------------
  |  Branch (1294:6): [True: 838, False: 0]
  ------------------
 1295|    998|            (reader->node->prev->type != XML_DTD_NODE)) {
  ------------------
  |  Branch (1295:13): [True: 835, False: 3]
  ------------------
 1296|    835|	    xmlNodePtr tmp = reader->node->prev;
 1297|    835|	    if ((tmp->extra & NODE_IS_PRESERVED) == 0) {
  ------------------
  |  |  187|    835|#define NODE_IS_PRESERVED	0x2
  ------------------
  |  Branch (1297:10): [True: 835, False: 0]
  ------------------
 1298|    835|                if (oldnode == tmp)
  ------------------
  |  Branch (1298:21): [True: 815, False: 20]
  ------------------
 1299|    815|                    oldnode = NULL;
 1300|    835|		xmlUnlinkNode(tmp);
 1301|    835|		xmlTextReaderFreeNode(reader, tmp);
 1302|    835|	    }
 1303|    835|	}
 1304|       |
 1305|    998|	goto node_found;
 1306|    998|    }
 1307|    446|    if ((oldstate == XML_TEXTREADER_ELEMENT) &&
  ------------------
  |  Branch (1307:9): [True: 404, False: 42]
  ------------------
 1308|    446|	(reader->node->type == XML_ELEMENT_NODE) &&
  ------------------
  |  Branch (1308:2): [True: 313, False: 91]
  ------------------
 1309|    446|	(reader->node->children == NULL) &&
  ------------------
  |  Branch (1309:2): [True: 313, False: 0]
  ------------------
 1310|    446|	((reader->node->extra & NODE_IS_EMPTY) == 0)) {;
  ------------------
  |  |  186|    313|#define NODE_IS_EMPTY		0x1
  ------------------
  |  Branch (1310:2): [True: 0, False: 313]
  ------------------
 1311|      0|	reader->state = XML_TEXTREADER_END;
 1312|      0|	goto node_found;
 1313|      0|    }
 1314|    446|#ifdef LIBXML_REGEXP_ENABLED
 1315|    446|    if ((reader->validate != XML_TEXTREADER_NOT_VALIDATE) && (reader->node->type == XML_ELEMENT_NODE))
  ------------------
  |  Branch (1315:9): [True: 0, False: 446]
  |  Branch (1315:62): [True: 0, False: 0]
  ------------------
 1316|      0|	xmlTextReaderValidatePop(reader);
 1317|    446|#endif /* LIBXML_REGEXP_ENABLED */
 1318|    446|    if ((reader->preserves > 0) &&
  ------------------
  |  Branch (1318:9): [True: 0, False: 446]
  ------------------
 1319|    446|	(reader->node->extra & NODE_IS_SPRESERVED))
  ------------------
  |  |  188|      0|#define NODE_IS_SPRESERVED	0x4
  ------------------
  |  Branch (1319:2): [True: 0, False: 0]
  ------------------
 1320|      0|	reader->preserves--;
 1321|    446|    reader->node = reader->node->parent;
 1322|    446|    if ((reader->node == NULL) ||
  ------------------
  |  Branch (1322:9): [True: 0, False: 446]
  ------------------
 1323|    446|	(reader->node->type == XML_DOCUMENT_NODE) ||
  ------------------
  |  Branch (1323:2): [True: 40, False: 406]
  ------------------
 1324|    446|	(reader->node->type == XML_HTML_DOCUMENT_NODE)) {
  ------------------
  |  Branch (1324:2): [True: 0, False: 406]
  ------------------
 1325|     40|	if (reader->mode != XML_TEXTREADER_MODE_EOF) {
  ------------------
  |  Branch (1325:6): [True: 0, False: 40]
  ------------------
 1326|      0|	    val = xmlParseChunk(reader->ctxt, "", 0, 1);
 1327|      0|	    reader->state = XML_TEXTREADER_DONE;
 1328|      0|	    if (val != 0)
  ------------------
  |  Branch (1328:10): [True: 0, False: 0]
  ------------------
 1329|      0|	        return(-1);
 1330|      0|	}
 1331|     40|	reader->node = NULL;
 1332|     40|	reader->depth = -1;
 1333|       |
 1334|       |	/*
 1335|       |	 * Cleanup of the old node
 1336|       |	 */
 1337|     40|	if ((oldnode != NULL) && (reader->preserves == 0) &&
  ------------------
  |  Branch (1337:6): [True: 39, False: 1]
  |  Branch (1337:27): [True: 39, False: 0]
  ------------------
 1338|     40|#ifdef LIBXML_XINCLUDE_ENABLED
 1339|     40|	    (reader->in_xinclude == 0) &&
  ------------------
  |  Branch (1339:6): [True: 39, False: 0]
  ------------------
 1340|     40|#endif
 1341|     40|	    (reader->entNr == 0) &&
  ------------------
  |  Branch (1341:6): [True: 39, False: 0]
  ------------------
 1342|     40|	    (oldnode->type != XML_DTD_NODE) &&
  ------------------
  |  Branch (1342:6): [True: 39, False: 0]
  ------------------
 1343|     40|	    ((oldnode->extra & NODE_IS_PRESERVED) == 0)) {
  ------------------
  |  |  187|     39|#define NODE_IS_PRESERVED	0x2
  ------------------
  |  Branch (1343:6): [True: 39, False: 0]
  ------------------
 1344|     39|	    xmlUnlinkNode(oldnode);
 1345|     39|	    xmlTextReaderFreeNode(reader, oldnode);
 1346|     39|	}
 1347|       |
 1348|     40|	goto node_end;
 1349|     40|    }
 1350|    406|    if ((reader->preserves == 0) &&
  ------------------
  |  Branch (1350:9): [True: 406, False: 0]
  ------------------
 1351|    406|#ifdef LIBXML_XINCLUDE_ENABLED
 1352|    406|        (reader->in_xinclude == 0) &&
  ------------------
  |  Branch (1352:9): [True: 383, False: 23]
  ------------------
 1353|    406|#endif
 1354|    406|	(reader->entNr == 0) &&
  ------------------
  |  Branch (1354:2): [True: 383, False: 0]
  ------------------
 1355|    406|        (reader->node->last != NULL) &&
  ------------------
  |  Branch (1355:9): [True: 383, False: 0]
  ------------------
 1356|    406|        ((reader->node->last->extra & NODE_IS_PRESERVED) == 0)) {
  ------------------
  |  |  187|    383|#define NODE_IS_PRESERVED	0x2
  ------------------
  |  Branch (1356:9): [True: 383, False: 0]
  ------------------
 1357|    383|	xmlNodePtr tmp = reader->node->last;
 1358|    383|	xmlUnlinkNode(tmp);
 1359|    383|	xmlTextReaderFreeNode(reader, tmp);
 1360|    383|    }
 1361|    406|    reader->depth--;
 1362|    406|    reader->state = XML_TEXTREADER_BACKTRACK;
 1363|       |
 1364|  1.90k|node_found:
 1365|       |    /*
 1366|       |     * If we are in the middle of a piece of CDATA make sure it's finished
 1367|       |     */
 1368|  1.90k|    if ((reader->node != NULL) &&
  ------------------
  |  Branch (1368:9): [True: 1.90k, False: 0]
  ------------------
 1369|  1.90k|        (reader->node->next == NULL) &&
  ------------------
  |  Branch (1369:9): [True: 571, False: 1.33k]
  ------------------
 1370|  1.90k|        ((reader->node->type == XML_TEXT_NODE) ||
  ------------------
  |  Branch (1370:10): [True: 102, False: 469]
  ------------------
 1371|    571|	 (reader->node->type == XML_CDATA_SECTION_NODE))) {
  ------------------
  |  Branch (1371:3): [True: 0, False: 469]
  ------------------
 1372|    102|            if (xmlTextReaderExpand(reader) == NULL)
  ------------------
  |  Branch (1372:17): [True: 9, False: 93]
  ------------------
 1373|      9|	        return -1;
 1374|    102|    }
 1375|       |
 1376|  1.89k|#ifdef LIBXML_XINCLUDE_ENABLED
 1377|       |    /*
 1378|       |     * Handle XInclude if asked for
 1379|       |     */
 1380|  1.89k|    if ((reader->xinclude) && (reader->in_xinclude == 0) &&
  ------------------
  |  Branch (1380:9): [True: 1.89k, False: 0]
  |  Branch (1380:31): [True: 1.68k, False: 206]
  ------------------
 1381|  1.89k|        (reader->node != NULL) &&
  ------------------
  |  Branch (1381:9): [True: 1.68k, False: 0]
  ------------------
 1382|  1.89k|	(reader->node->type == XML_ELEMENT_NODE) &&
  ------------------
  |  Branch (1382:2): [True: 1.17k, False: 511]
  ------------------
 1383|  1.89k|	(reader->node->ns != NULL) &&
  ------------------
  |  Branch (1383:2): [True: 387, False: 790]
  ------------------
 1384|  1.89k|	((xmlStrEqual(reader->node->ns->href, XINCLUDE_NS)) ||
  ------------------
  |  |   30|    387|#define XINCLUDE_NS (const xmlChar *) "http://www.w3.org/2003/XInclude"
  ------------------
  |  Branch (1384:3): [True: 2, False: 385]
  ------------------
 1385|    387|	 (xmlStrEqual(reader->node->ns->href, XINCLUDE_OLD_NS)))) {
  ------------------
  |  |   36|    385|#define XINCLUDE_OLD_NS (const xmlChar *) "http://www.w3.org/2001/XInclude"
  ------------------
  |  Branch (1385:3): [True: 368, False: 17]
  ------------------
 1386|    370|	if (reader->xincctxt == NULL) {
  ------------------
  |  Branch (1386:6): [True: 46, False: 324]
  ------------------
 1387|     46|	    reader->xincctxt = xmlXIncludeNewContext(reader->ctxt->myDoc);
 1388|     46|	    xmlXIncludeSetFlags(reader->xincctxt,
 1389|     46|	                        reader->parserFlags & (~XML_PARSE_NOXINCNODE));
 1390|     46|            xmlXIncludeSetStreamingMode(reader->xincctxt, 1);
 1391|     46|	}
 1392|       |	/*
 1393|       |	 * expand that node and process it
 1394|       |	 */
 1395|    370|	if (xmlTextReaderExpand(reader) == NULL)
  ------------------
  |  Branch (1395:6): [True: 9, False: 361]
  ------------------
 1396|      9|	    return -1;
 1397|    361|	xmlXIncludeProcessNode(reader->xincctxt, reader->node);
 1398|    361|    }
 1399|  1.88k|    if ((reader->node != NULL) && (reader->node->type == XML_XINCLUDE_START)) {
  ------------------
  |  Branch (1399:9): [True: 1.88k, False: 0]
  |  Branch (1399:35): [True: 26, False: 1.85k]
  ------------------
 1400|     26|        reader->in_xinclude++;
 1401|     26|	goto get_next_node;
 1402|     26|    }
 1403|  1.85k|    if ((reader->node != NULL) && (reader->node->type == XML_XINCLUDE_END)) {
  ------------------
  |  Branch (1403:9): [True: 1.85k, False: 0]
  |  Branch (1403:35): [True: 24, False: 1.83k]
  ------------------
 1404|     24|        reader->in_xinclude--;
 1405|     24|	goto get_next_node;
 1406|     24|    }
 1407|  1.83k|#endif
 1408|       |    /*
 1409|       |     * Handle entities enter and exit when in entity replacement mode
 1410|       |     */
 1411|  1.83k|    if ((reader->node != NULL) &&
  ------------------
  |  Branch (1411:9): [True: 1.83k, False: 0]
  ------------------
 1412|  1.83k|	(reader->node->type == XML_ENTITY_REF_NODE) &&
  ------------------
  |  Branch (1412:2): [True: 0, False: 1.83k]
  ------------------
 1413|  1.83k|	(reader->ctxt != NULL) && (reader->ctxt->replaceEntities == 1)) {
  ------------------
  |  Branch (1413:2): [True: 0, False: 0]
  |  Branch (1413:28): [True: 0, False: 0]
  ------------------
 1414|      0|	if ((reader->node->children != NULL) &&
  ------------------
  |  Branch (1414:6): [True: 0, False: 0]
  ------------------
 1415|      0|	    (reader->node->children->type == XML_ENTITY_DECL) &&
  ------------------
  |  Branch (1415:6): [True: 0, False: 0]
  ------------------
 1416|      0|	    (reader->node->children->children != NULL)) {
  ------------------
  |  Branch (1416:6): [True: 0, False: 0]
  ------------------
 1417|      0|	    if (xmlTextReaderEntPush(reader, reader->node) < 0)
  ------------------
  |  Branch (1417:10): [True: 0, False: 0]
  ------------------
 1418|      0|                goto get_next_node;
 1419|      0|	    reader->node = reader->node->children->children;
 1420|      0|	}
 1421|      0|#ifdef LIBXML_REGEXP_ENABLED
 1422|  1.83k|    } else if ((reader->node != NULL) &&
  ------------------
  |  Branch (1422:16): [True: 1.83k, False: 0]
  ------------------
 1423|  1.83k|	       (reader->node->type == XML_ENTITY_REF_NODE) &&
  ------------------
  |  Branch (1423:9): [True: 0, False: 1.83k]
  ------------------
 1424|  1.83k|	       (reader->ctxt != NULL) && (reader->validate)) {
  ------------------
  |  Branch (1424:9): [True: 0, False: 0]
  |  Branch (1424:35): [True: 0, False: 0]
  ------------------
 1425|      0|	xmlTextReaderValidateEntity(reader);
 1426|      0|#endif /* LIBXML_REGEXP_ENABLED */
 1427|      0|    }
 1428|  1.83k|    if ((reader->node != NULL) &&
  ------------------
  |  Branch (1428:9): [True: 1.83k, False: 0]
  ------------------
 1429|  1.83k|	(reader->node->type == XML_ENTITY_DECL) &&
  ------------------
  |  Branch (1429:2): [True: 0, False: 1.83k]
  ------------------
 1430|  1.83k|	(reader->ent != NULL) && (reader->ent->children == reader->node)) {
  ------------------
  |  Branch (1430:2): [True: 0, False: 0]
  |  Branch (1430:27): [True: 0, False: 0]
  ------------------
 1431|      0|	reader->node = xmlTextReaderEntPop(reader);
 1432|      0|	reader->depth++;
 1433|      0|        goto get_next_node;
 1434|      0|    }
 1435|  1.83k|#ifdef LIBXML_REGEXP_ENABLED
 1436|  1.83k|    if ((reader->validate != XML_TEXTREADER_NOT_VALIDATE) && (reader->node != NULL)) {
  ------------------
  |  Branch (1436:9): [True: 0, False: 1.83k]
  |  Branch (1436:62): [True: 0, False: 0]
  ------------------
 1437|      0|	xmlNodePtr node = reader->node;
 1438|       |
 1439|      0|	if ((node->type == XML_ELEMENT_NODE) &&
  ------------------
  |  Branch (1439:6): [True: 0, False: 0]
  ------------------
 1440|      0|            ((reader->state != XML_TEXTREADER_END) &&
  ------------------
  |  Branch (1440:14): [True: 0, False: 0]
  ------------------
 1441|      0|	     (reader->state != XML_TEXTREADER_BACKTRACK))) {
  ------------------
  |  Branch (1441:7): [True: 0, False: 0]
  ------------------
 1442|      0|	    xmlTextReaderValidatePush(reader);
 1443|      0|	} else if ((node->type == XML_TEXT_NODE) ||
  ------------------
  |  Branch (1443:13): [True: 0, False: 0]
  ------------------
 1444|      0|		   (node->type == XML_CDATA_SECTION_NODE)) {
  ------------------
  |  Branch (1444:6): [True: 0, False: 0]
  ------------------
 1445|      0|            xmlTextReaderValidateCData(reader, node->content,
 1446|      0|	                               xmlStrlen(node->content));
 1447|      0|	}
 1448|      0|    }
 1449|  1.83k|#endif /* LIBXML_REGEXP_ENABLED */
 1450|  1.83k|#ifdef LIBXML_PATTERN_ENABLED
 1451|  1.83k|    if ((reader->patternNr > 0) && (reader->state != XML_TEXTREADER_END) &&
  ------------------
  |  Branch (1451:9): [True: 0, False: 1.83k]
  |  Branch (1451:36): [True: 0, False: 0]
  ------------------
 1452|  1.83k|        (reader->state != XML_TEXTREADER_BACKTRACK)) {
  ------------------
  |  Branch (1452:9): [True: 0, False: 0]
  ------------------
 1453|      0|        int i;
 1454|      0|	for (i = 0;i < reader->patternNr;i++) {
  ------------------
  |  Branch (1454:13): [True: 0, False: 0]
  ------------------
 1455|      0|	     if (xmlPatternMatch(reader->patternTab[i], reader->node) == 1) {
  ------------------
  |  Branch (1455:11): [True: 0, False: 0]
  ------------------
 1456|      0|	         xmlTextReaderPreserve(reader);
 1457|      0|		 break;
 1458|      0|             }
 1459|      0|	}
 1460|      0|    }
 1461|  1.83k|#endif /* LIBXML_PATTERN_ENABLED */
 1462|  1.83k|#ifdef LIBXML_SCHEMAS_ENABLED
 1463|  1.83k|    if ((reader->validate == XML_TEXTREADER_VALIDATE_XSD) &&
  ------------------
  |  Branch (1463:9): [True: 0, False: 1.83k]
  ------------------
 1464|  1.83k|        (reader->xsdValidErrors == 0) &&
  ------------------
  |  Branch (1464:9): [True: 0, False: 0]
  ------------------
 1465|  1.83k|	(reader->xsdValidCtxt != NULL)) {
  ------------------
  |  Branch (1465:2): [True: 0, False: 0]
  ------------------
 1466|      0|	reader->xsdValidErrors = !xmlSchemaIsValid(reader->xsdValidCtxt);
 1467|      0|    }
 1468|  1.83k|#endif /* LIBXML_PATTERN_ENABLED */
 1469|  1.83k|    return(1);
 1470|     40|node_end:
 1471|     40|    reader->state = XML_TEXTREADER_DONE;
 1472|     40|    return(0);
 1473|  1.83k|}
xmlTextReaderExpand:
 1501|    472|xmlTextReaderExpand(xmlTextReaderPtr reader) {
 1502|    472|    if ((reader == NULL) || (reader->node == NULL))
  ------------------
  |  Branch (1502:9): [True: 0, False: 472]
  |  Branch (1502:29): [True: 0, False: 472]
  ------------------
 1503|      0|        return(NULL);
 1504|    472|    if (reader->doc != NULL)
  ------------------
  |  Branch (1504:9): [True: 0, False: 472]
  ------------------
 1505|      0|        return(reader->node);
 1506|    472|    if (reader->ctxt == NULL)
  ------------------
  |  Branch (1506:9): [True: 0, False: 472]
  ------------------
 1507|      0|        return(NULL);
 1508|    472|    if (xmlTextReaderDoExpand(reader) < 0)
  ------------------
  |  Branch (1508:9): [True: 18, False: 454]
  ------------------
 1509|     18|        return(NULL);
 1510|    454|    return(reader->node);
 1511|    472|}
xmlNewTextReader:
 1935|    167|xmlNewTextReader(xmlParserInputBufferPtr input, const char *URI) {
 1936|    167|    xmlTextReaderPtr ret;
 1937|       |
 1938|    167|    if (input == NULL)
  ------------------
  |  Branch (1938:9): [True: 0, False: 167]
  ------------------
 1939|      0|	return(NULL);
 1940|    167|    ret = xmlMalloc(sizeof(xmlTextReader));
 1941|    167|    if (ret == NULL) {
  ------------------
  |  Branch (1941:9): [True: 0, False: 167]
  ------------------
 1942|      0|        xmlGenericError(xmlGenericErrorContext,
  ------------------
  |  |  875|      0|  #define xmlGenericError XML_GLOBAL_MACRO(xmlGenericError)
  |  |  ------------------
  |  |  |  |  500|      0|  #define XML_GLOBAL_MACRO(name) (*__##name())
  |  |  ------------------
  ------------------
                      xmlGenericError(xmlGenericErrorContext,
  ------------------
  |  |  876|      0|  #define xmlGenericErrorContext XML_GLOBAL_MACRO(xmlGenericErrorContext)
  |  |  ------------------
  |  |  |  |  500|      0|  #define XML_GLOBAL_MACRO(name) (*__##name())
  |  |  ------------------
  ------------------
 1943|      0|		"xmlNewTextReader : malloc failed\n");
 1944|      0|	return(NULL);
 1945|      0|    }
 1946|    167|    memset(ret, 0, sizeof(xmlTextReader));
 1947|    167|    ret->doc = NULL;
 1948|    167|    ret->entTab = NULL;
 1949|    167|    ret->entMax = 0;
 1950|    167|    ret->entNr = 0;
 1951|    167|    ret->input = input;
 1952|    167|    ret->buffer = xmlBufCreateSize(100);
 1953|    167|    if (ret->buffer == NULL) {
  ------------------
  |  Branch (1953:9): [True: 0, False: 167]
  ------------------
 1954|      0|        xmlFree(ret);
 1955|      0|        xmlGenericError(xmlGenericErrorContext,
  ------------------
  |  |  875|      0|  #define xmlGenericError XML_GLOBAL_MACRO(xmlGenericError)
  |  |  ------------------
  |  |  |  |  500|      0|  #define XML_GLOBAL_MACRO(name) (*__##name())
  |  |  ------------------
  ------------------
                      xmlGenericError(xmlGenericErrorContext,
  ------------------
  |  |  876|      0|  #define xmlGenericErrorContext XML_GLOBAL_MACRO(xmlGenericErrorContext)
  |  |  ------------------
  |  |  |  |  500|      0|  #define XML_GLOBAL_MACRO(name) (*__##name())
  |  |  ------------------
  ------------------
 1956|      0|		"xmlNewTextReader : malloc failed\n");
 1957|      0|	return(NULL);
 1958|      0|    }
 1959|       |    /* no operation on a reader should require a huge buffer */
 1960|    167|    xmlBufSetAllocationScheme(ret->buffer,
 1961|    167|			      XML_BUFFER_ALLOC_DOUBLEIT);
 1962|    167|    ret->sax = (xmlSAXHandler *) xmlMalloc(sizeof(xmlSAXHandler));
 1963|    167|    if (ret->sax == NULL) {
  ------------------
  |  Branch (1963:9): [True: 0, False: 167]
  ------------------
 1964|      0|	xmlBufFree(ret->buffer);
 1965|      0|	xmlFree(ret);
 1966|      0|        xmlGenericError(xmlGenericErrorContext,
  ------------------
  |  |  875|      0|  #define xmlGenericError XML_GLOBAL_MACRO(xmlGenericError)
  |  |  ------------------
  |  |  |  |  500|      0|  #define XML_GLOBAL_MACRO(name) (*__##name())
  |  |  ------------------
  ------------------
                      xmlGenericError(xmlGenericErrorContext,
  ------------------
  |  |  876|      0|  #define xmlGenericErrorContext XML_GLOBAL_MACRO(xmlGenericErrorContext)
  |  |  ------------------
  |  |  |  |  500|      0|  #define XML_GLOBAL_MACRO(name) (*__##name())
  |  |  ------------------
  ------------------
 1967|      0|		"xmlNewTextReader : malloc failed\n");
 1968|      0|	return(NULL);
 1969|      0|    }
 1970|    167|    xmlSAXVersion(ret->sax, 2);
 1971|    167|    ret->startElement = ret->sax->startElement;
 1972|    167|    ret->sax->startElement = xmlTextReaderStartElement;
 1973|    167|    ret->endElement = ret->sax->endElement;
 1974|    167|    ret->sax->endElement = xmlTextReaderEndElement;
 1975|    167|#ifdef LIBXML_SAX1_ENABLED
 1976|    167|    if (ret->sax->initialized == XML_SAX2_MAGIC) {
  ------------------
  |  |  685|    167|#define XML_SAX2_MAGIC 0xDEEDBEAF
  ------------------
  |  Branch (1976:9): [True: 167, False: 0]
  ------------------
 1977|    167|#endif /* LIBXML_SAX1_ENABLED */
 1978|    167|	ret->startElementNs = ret->sax->startElementNs;
 1979|    167|	ret->sax->startElementNs = xmlTextReaderStartElementNs;
 1980|    167|	ret->endElementNs = ret->sax->endElementNs;
 1981|    167|	ret->sax->endElementNs = xmlTextReaderEndElementNs;
 1982|    167|#ifdef LIBXML_SAX1_ENABLED
 1983|    167|    } else {
 1984|      0|	ret->startElementNs = NULL;
 1985|      0|	ret->endElementNs = NULL;
 1986|      0|    }
 1987|    167|#endif /* LIBXML_SAX1_ENABLED */
 1988|    167|    ret->characters = ret->sax->characters;
 1989|    167|    ret->sax->characters = xmlTextReaderCharacters;
 1990|    167|    ret->sax->ignorableWhitespace = xmlTextReaderCharacters;
 1991|    167|    ret->cdataBlock = ret->sax->cdataBlock;
 1992|    167|    ret->sax->cdataBlock = xmlTextReaderCDataBlock;
 1993|       |
 1994|    167|    ret->mode = XML_TEXTREADER_MODE_INITIAL;
 1995|    167|    ret->node = NULL;
 1996|    167|    ret->curnode = NULL;
 1997|    167|    if (xmlBufUse(ret->input->buffer) < 4) {
  ------------------
  |  Branch (1997:9): [True: 167, False: 0]
  ------------------
 1998|    167|	xmlParserInputBufferRead(input, 4);
 1999|    167|    }
 2000|    167|    if (xmlBufUse(ret->input->buffer) >= 4) {
  ------------------
  |  Branch (2000:9): [True: 167, False: 0]
  ------------------
 2001|    167|	ret->ctxt = xmlCreatePushParserCtxt(ret->sax, NULL,
 2002|    167|			     (const char *) xmlBufContent(ret->input->buffer),
 2003|    167|                                            4, URI);
 2004|    167|	ret->base = 0;
 2005|    167|	ret->cur = 4;
 2006|    167|    } else {
 2007|      0|	ret->ctxt = xmlCreatePushParserCtxt(ret->sax, NULL, NULL, 0, URI);
 2008|      0|	ret->base = 0;
 2009|      0|	ret->cur = 0;
 2010|      0|    }
 2011|       |
 2012|    167|    if (ret->ctxt == NULL) {
  ------------------
  |  Branch (2012:9): [True: 0, False: 167]
  ------------------
 2013|      0|        xmlGenericError(xmlGenericErrorContext,
  ------------------
  |  |  875|      0|  #define xmlGenericError XML_GLOBAL_MACRO(xmlGenericError)
  |  |  ------------------
  |  |  |  |  500|      0|  #define XML_GLOBAL_MACRO(name) (*__##name())
  |  |  ------------------
  ------------------
                      xmlGenericError(xmlGenericErrorContext,
  ------------------
  |  |  876|      0|  #define xmlGenericErrorContext XML_GLOBAL_MACRO(xmlGenericErrorContext)
  |  |  ------------------
  |  |  |  |  500|      0|  #define XML_GLOBAL_MACRO(name) (*__##name())
  |  |  ------------------
  ------------------
 2014|      0|		"xmlNewTextReader : malloc failed\n");
 2015|      0|	xmlBufFree(ret->buffer);
 2016|      0|	xmlFree(ret->sax);
 2017|      0|	xmlFree(ret);
 2018|      0|	return(NULL);
 2019|      0|    }
 2020|    167|    ret->ctxt->parseMode = XML_PARSE_READER;
 2021|    167|    ret->ctxt->_private = ret;
 2022|    167|    ret->ctxt->linenumbers = 1;
 2023|    167|    ret->ctxt->dictNames = 1;
 2024|    167|    ret->allocs = XML_TEXTREADER_CTXT;
  ------------------
  |  |   99|    167|#define XML_TEXTREADER_CTXT	2
  ------------------
 2025|       |    /*
 2026|       |     * use the parser dictionary to allocate all elements and attributes names
 2027|       |     */
 2028|    167|    ret->ctxt->docdict = 1;
 2029|    167|    ret->dict = ret->ctxt->dict;
 2030|    167|#ifdef LIBXML_XINCLUDE_ENABLED
 2031|    167|    ret->xinclude = 0;
 2032|    167|#endif
 2033|    167|#ifdef LIBXML_PATTERN_ENABLED
 2034|    167|    ret->patternMax = 0;
 2035|    167|    ret->patternTab = NULL;
 2036|    167|#endif
 2037|    167|    return(ret);
 2038|    167|}
xmlFreeTextReader:
 2079|    167|xmlFreeTextReader(xmlTextReaderPtr reader) {
 2080|    167|    if (reader == NULL)
  ------------------
  |  Branch (2080:9): [True: 0, False: 167]
  ------------------
 2081|      0|	return;
 2082|    167|#ifdef LIBXML_SCHEMAS_ENABLED
 2083|    167|    if (reader->rngSchemas != NULL) {
  ------------------
  |  Branch (2083:9): [True: 0, False: 167]
  ------------------
 2084|      0|	xmlRelaxNGFree(reader->rngSchemas);
 2085|      0|	reader->rngSchemas = NULL;
 2086|      0|    }
 2087|    167|    if (reader->rngValidCtxt != NULL) {
  ------------------
  |  Branch (2087:9): [True: 0, False: 167]
  ------------------
 2088|      0|	if (! reader->rngPreserveCtxt)
  ------------------
  |  Branch (2088:6): [True: 0, False: 0]
  ------------------
 2089|      0|	    xmlRelaxNGFreeValidCtxt(reader->rngValidCtxt);
 2090|      0|	reader->rngValidCtxt = NULL;
 2091|      0|    }
 2092|    167|    if (reader->xsdPlug != NULL) {
  ------------------
  |  Branch (2092:9): [True: 0, False: 167]
  ------------------
 2093|      0|	xmlSchemaSAXUnplug(reader->xsdPlug);
 2094|      0|	reader->xsdPlug = NULL;
 2095|      0|    }
 2096|    167|    if (reader->xsdValidCtxt != NULL) {
  ------------------
  |  Branch (2096:9): [True: 0, False: 167]
  ------------------
 2097|      0|	if (! reader->xsdPreserveCtxt)
  ------------------
  |  Branch (2097:6): [True: 0, False: 0]
  ------------------
 2098|      0|	    xmlSchemaFreeValidCtxt(reader->xsdValidCtxt);
 2099|      0|	reader->xsdValidCtxt = NULL;
 2100|      0|    }
 2101|    167|    if (reader->xsdSchemas != NULL) {
  ------------------
  |  Branch (2101:9): [True: 0, False: 167]
  ------------------
 2102|      0|	xmlSchemaFree(reader->xsdSchemas);
 2103|      0|	reader->xsdSchemas = NULL;
 2104|      0|    }
 2105|    167|#endif
 2106|    167|#ifdef LIBXML_XINCLUDE_ENABLED
 2107|    167|    if (reader->xincctxt != NULL)
  ------------------
  |  Branch (2107:9): [True: 46, False: 121]
  ------------------
 2108|     46|	xmlXIncludeFreeContext(reader->xincctxt);
 2109|    167|#endif
 2110|    167|#ifdef LIBXML_PATTERN_ENABLED
 2111|    167|    if (reader->patternTab != NULL) {
  ------------------
  |  Branch (2111:9): [True: 0, False: 167]
  ------------------
 2112|      0|        int i;
 2113|      0|	for (i = 0;i < reader->patternNr;i++) {
  ------------------
  |  Branch (2113:13): [True: 0, False: 0]
  ------------------
 2114|      0|	    if (reader->patternTab[i] != NULL)
  ------------------
  |  Branch (2114:10): [True: 0, False: 0]
  ------------------
 2115|      0|	        xmlFreePattern(reader->patternTab[i]);
 2116|      0|	}
 2117|      0|	xmlFree(reader->patternTab);
 2118|      0|    }
 2119|    167|#endif
 2120|    167|    if (reader->mode != XML_TEXTREADER_MODE_CLOSED)
  ------------------
  |  Branch (2120:9): [True: 167, False: 0]
  ------------------
 2121|    167|        xmlTextReaderClose(reader);
 2122|    167|    if (reader->ctxt != NULL) {
  ------------------
  |  Branch (2122:9): [True: 167, False: 0]
  ------------------
 2123|    167|        if (reader->dict == reader->ctxt->dict)
  ------------------
  |  Branch (2123:13): [True: 167, False: 0]
  ------------------
 2124|    167|	    reader->dict = NULL;
 2125|    167|	if (reader->allocs & XML_TEXTREADER_CTXT)
  ------------------
  |  |   99|    167|#define XML_TEXTREADER_CTXT	2
  ------------------
  |  Branch (2125:6): [True: 167, False: 0]
  ------------------
 2126|    167|	    xmlFreeParserCtxt(reader->ctxt);
 2127|    167|    }
 2128|    167|    if (reader->sax != NULL)
  ------------------
  |  Branch (2128:9): [True: 167, False: 0]
  ------------------
 2129|    167|	xmlFree(reader->sax);
 2130|    167|    if (reader->buffer != NULL)
  ------------------
  |  Branch (2130:9): [True: 167, False: 0]
  ------------------
 2131|    167|        xmlBufFree(reader->buffer);
 2132|    167|    if (reader->entTab != NULL)
  ------------------
  |  Branch (2132:9): [True: 0, False: 167]
  ------------------
 2133|      0|	xmlFree(reader->entTab);
 2134|    167|    if (reader->dict != NULL)
  ------------------
  |  Branch (2134:9): [True: 0, False: 167]
  ------------------
 2135|      0|        xmlDictFree(reader->dict);
 2136|    167|    xmlFree(reader);
 2137|    167|}
xmlTextReaderClose:
 2154|    167|xmlTextReaderClose(xmlTextReaderPtr reader) {
 2155|    167|    if (reader == NULL)
  ------------------
  |  Branch (2155:9): [True: 0, False: 167]
  ------------------
 2156|      0|	return(-1);
 2157|    167|    reader->node = NULL;
 2158|    167|    reader->curnode = NULL;
 2159|    167|    reader->mode = XML_TEXTREADER_MODE_CLOSED;
 2160|    167|    if (reader->faketext != NULL) {
  ------------------
  |  Branch (2160:9): [True: 49, False: 118]
  ------------------
 2161|     49|        xmlFreeNode(reader->faketext);
 2162|     49|        reader->faketext = NULL;
 2163|     49|    }
 2164|    167|    if (reader->ctxt != NULL) {
  ------------------
  |  Branch (2164:9): [True: 167, False: 0]
  ------------------
 2165|    167|#ifdef LIBXML_VALID_ENABLED
 2166|    167|	if ((reader->ctxt->vctxt.vstateTab != NULL) &&
  ------------------
  |  Branch (2166:6): [True: 0, False: 167]
  ------------------
 2167|    167|	    (reader->ctxt->vctxt.vstateMax > 0)){
  ------------------
  |  Branch (2167:6): [True: 0, False: 0]
  ------------------
 2168|      0|#ifdef LIBXML_REGEXP_ENABLED
 2169|      0|            while (reader->ctxt->vctxt.vstateNr > 0)
  ------------------
  |  Branch (2169:20): [True: 0, False: 0]
  ------------------
 2170|      0|                xmlValidatePopElement(&reader->ctxt->vctxt, NULL, NULL, NULL);
 2171|      0|#endif /* LIBXML_REGEXP_ENABLED */
 2172|      0|	    xmlFree(reader->ctxt->vctxt.vstateTab);
 2173|      0|	    reader->ctxt->vctxt.vstateTab = NULL;
 2174|      0|	    reader->ctxt->vctxt.vstateMax = 0;
 2175|      0|	}
 2176|    167|#endif /* LIBXML_VALID_ENABLED */
 2177|    167|	xmlStopParser(reader->ctxt);
 2178|    167|	if (reader->ctxt->myDoc != NULL) {
  ------------------
  |  Branch (2178:6): [True: 160, False: 7]
  ------------------
 2179|    160|	    if (reader->preserve == 0)
  ------------------
  |  Branch (2179:10): [True: 160, False: 0]
  ------------------
 2180|    160|		xmlTextReaderFreeDoc(reader, reader->ctxt->myDoc);
 2181|    160|	    reader->ctxt->myDoc = NULL;
 2182|    160|	}
 2183|    167|    }
 2184|    167|    if ((reader->input != NULL)  && (reader->allocs & XML_TEXTREADER_INPUT)) {
  ------------------
  |  |   98|    167|#define XML_TEXTREADER_INPUT	1
  ------------------
  |  Branch (2184:9): [True: 167, False: 0]
  |  Branch (2184:37): [True: 167, False: 0]
  ------------------
 2185|    167|	xmlFreeParserInputBuffer(reader->input);
 2186|    167|	reader->allocs -= XML_TEXTREADER_INPUT;
  ------------------
  |  |   98|    167|#define XML_TEXTREADER_INPUT	1
  ------------------
 2187|    167|    }
 2188|    167|    return(0);
 2189|    167|}
xmlTextReaderMoveToAttributeNo:
 2448|    425|xmlTextReaderMoveToAttributeNo(xmlTextReaderPtr reader, int no) {
 2449|    425|    int i;
 2450|    425|    xmlAttrPtr cur;
 2451|    425|    xmlNsPtr ns;
 2452|       |
 2453|    425|    if (reader == NULL)
  ------------------
  |  Branch (2453:9): [True: 0, False: 425]
  ------------------
 2454|      0|	return(-1);
 2455|    425|    if (reader->node == NULL)
  ------------------
  |  Branch (2455:9): [True: 0, False: 425]
  ------------------
 2456|      0|	return(-1);
 2457|       |    /* TODO: handle the xmlDecl */
 2458|    425|    if (reader->node->type != XML_ELEMENT_NODE)
  ------------------
  |  Branch (2458:9): [True: 0, False: 425]
  ------------------
 2459|      0|	return(-1);
 2460|       |
 2461|    425|    reader->curnode = NULL;
 2462|       |
 2463|    425|    ns = reader->node->nsDef;
 2464|    431|    for (i = 0;(i < no) && (ns != NULL);i++) {
  ------------------
  |  Branch (2464:16): [True: 10, False: 421]
  |  Branch (2464:28): [True: 6, False: 4]
  ------------------
 2465|      6|	ns = ns->next;
 2466|      6|    }
 2467|    425|    if (ns != NULL) {
  ------------------
  |  Branch (2467:9): [True: 57, False: 368]
  ------------------
 2468|     57|	reader->curnode = (xmlNodePtr) ns;
 2469|     57|	return(1);
 2470|     57|    }
 2471|       |
 2472|    368|    cur = reader->node->properties;
 2473|    368|    if (cur == NULL)
  ------------------
  |  Branch (2473:9): [True: 0, False: 368]
  ------------------
 2474|      0|	return(0);
 2475|    373|    for (;i < no;i++) {
  ------------------
  |  Branch (2475:11): [True: 5, False: 368]
  ------------------
 2476|      5|	cur = cur->next;
 2477|      5|	if (cur == NULL)
  ------------------
  |  Branch (2477:6): [True: 0, False: 5]
  ------------------
 2478|      0|	    return(0);
 2479|      5|    }
 2480|       |    /* TODO walk the DTD if present */
 2481|       |
 2482|    368|    reader->curnode = (xmlNodePtr) cur;
 2483|    368|    return(1);
 2484|    368|}
xmlTextReaderReadAttributeValue:
 2753|    850|xmlTextReaderReadAttributeValue(xmlTextReaderPtr reader) {
 2754|    850|    if (reader == NULL)
  ------------------
  |  Branch (2754:9): [True: 0, False: 850]
  ------------------
 2755|      0|	return(-1);
 2756|    850|    if (reader->node == NULL)
  ------------------
  |  Branch (2756:9): [True: 0, False: 850]
  ------------------
 2757|      0|	return(-1);
 2758|    850|    if (reader->curnode == NULL)
  ------------------
  |  Branch (2758:9): [True: 0, False: 850]
  ------------------
 2759|      0|	return(0);
 2760|    850|    if (reader->curnode->type == XML_ATTRIBUTE_NODE) {
  ------------------
  |  Branch (2760:9): [True: 368, False: 482]
  ------------------
 2761|    368|	if (reader->curnode->children == NULL)
  ------------------
  |  Branch (2761:6): [True: 0, False: 368]
  ------------------
 2762|      0|	    return(0);
 2763|    368|	reader->curnode = reader->curnode->children;
 2764|    482|    } else if (reader->curnode->type == XML_NAMESPACE_DECL) {
  ------------------
  |  Branch (2764:16): [True: 57, False: 425]
  ------------------
 2765|     57|	xmlNsPtr ns = (xmlNsPtr) reader->curnode;
 2766|       |
 2767|     57|	if (reader->faketext == NULL) {
  ------------------
  |  Branch (2767:6): [True: 49, False: 8]
  ------------------
 2768|     49|	    reader->faketext = xmlNewDocText(reader->node->doc,
 2769|     49|		                             ns->href);
 2770|     49|	} else {
 2771|      8|            if ((reader->faketext->content != NULL) &&
  ------------------
  |  Branch (2771:17): [True: 8, False: 0]
  ------------------
 2772|      8|	        (reader->faketext->content !=
  ------------------
  |  Branch (2772:10): [True: 8, False: 0]
  ------------------
 2773|      8|		 (xmlChar *) &(reader->faketext->properties)))
 2774|      8|		xmlFree(reader->faketext->content);
 2775|      8|	    reader->faketext->content = xmlStrdup(ns->href);
 2776|      8|	}
 2777|     57|	reader->curnode = reader->faketext;
 2778|    425|    } else {
 2779|    425|	if (reader->curnode->next == NULL)
  ------------------
  |  Branch (2779:6): [True: 425, False: 0]
  ------------------
 2780|    425|	    return(0);
 2781|      0|	reader->curnode = reader->curnode->next;
 2782|      0|    }
 2783|    425|    return(1);
 2784|    850|}
xmlTextReaderAttributeCount:
 2828|    800|xmlTextReaderAttributeCount(xmlTextReaderPtr reader) {
 2829|    800|    int ret;
 2830|    800|    xmlAttrPtr attr;
 2831|    800|    xmlNsPtr ns;
 2832|    800|    xmlNodePtr node;
 2833|       |
 2834|    800|    if (reader == NULL)
  ------------------
  |  Branch (2834:9): [True: 0, False: 800]
  ------------------
 2835|      0|	return(-1);
 2836|    800|    if (reader->node == NULL)
  ------------------
  |  Branch (2836:9): [True: 0, False: 800]
  ------------------
 2837|      0|	return(0);
 2838|       |
 2839|    800|    if (reader->curnode != NULL)
  ------------------
  |  Branch (2839:9): [True: 0, False: 800]
  ------------------
 2840|      0|	node = reader->curnode;
 2841|    800|    else
 2842|    800|	node = reader->node;
 2843|       |
 2844|    800|    if (node->type != XML_ELEMENT_NODE)
  ------------------
  |  Branch (2844:9): [True: 0, False: 800]
  ------------------
 2845|      0|	return(0);
 2846|    800|    if ((reader->state == XML_TEXTREADER_END) ||
  ------------------
  |  Branch (2846:9): [True: 0, False: 800]
  ------------------
 2847|    800|	(reader->state == XML_TEXTREADER_BACKTRACK))
  ------------------
  |  Branch (2847:2): [True: 0, False: 800]
  ------------------
 2848|      0|	return(0);
 2849|    800|    ret = 0;
 2850|    800|    attr = node->properties;
 2851|  1.16k|    while (attr != NULL) {
  ------------------
  |  Branch (2851:12): [True: 368, False: 800]
  ------------------
 2852|    368|	ret++;
 2853|    368|	attr = attr->next;
 2854|    368|    }
 2855|    800|    ns = node->nsDef;
 2856|    857|    while (ns != NULL) {
  ------------------
  |  Branch (2856:12): [True: 57, False: 800]
  ------------------
 2857|     57|	ret++;
 2858|     57|	ns = ns->next;
 2859|     57|    }
 2860|    800|    return(ret);
 2861|    800|}
xmlTextReaderNodeType:
 2874|  1.80k|xmlTextReaderNodeType(xmlTextReaderPtr reader) {
 2875|  1.80k|    xmlNodePtr node;
 2876|       |
 2877|  1.80k|    if (reader == NULL)
  ------------------
  |  Branch (2877:9): [True: 0, False: 1.80k]
  ------------------
 2878|      0|	return(-1);
 2879|  1.80k|    if (reader->node == NULL)
  ------------------
  |  Branch (2879:9): [True: 0, False: 1.80k]
  ------------------
 2880|      0|	return(XML_READER_TYPE_NONE);
 2881|  1.80k|    if (reader->curnode != NULL)
  ------------------
  |  Branch (2881:9): [True: 0, False: 1.80k]
  ------------------
 2882|      0|	node = reader->curnode;
 2883|  1.80k|    else
 2884|  1.80k|	node = reader->node;
 2885|  1.80k|    switch (node->type) {
  ------------------
  |  Branch (2885:13): [True: 0, False: 1.80k]
  ------------------
 2886|  1.20k|        case XML_ELEMENT_NODE:
  ------------------
  |  Branch (2886:9): [True: 1.20k, False: 599]
  ------------------
 2887|  1.20k|	    if ((reader->state == XML_TEXTREADER_END) ||
  ------------------
  |  Branch (2887:10): [True: 0, False: 1.20k]
  ------------------
 2888|  1.20k|		(reader->state == XML_TEXTREADER_BACKTRACK))
  ------------------
  |  Branch (2888:3): [True: 403, False: 800]
  ------------------
 2889|    403|		return(XML_READER_TYPE_END_ELEMENT);
 2890|    800|	    return(XML_READER_TYPE_ELEMENT);
 2891|      0|        case XML_NAMESPACE_DECL:
  ------------------
  |  Branch (2891:9): [True: 0, False: 1.80k]
  ------------------
 2892|      0|        case XML_ATTRIBUTE_NODE:
  ------------------
  |  Branch (2892:9): [True: 0, False: 1.80k]
  ------------------
 2893|      0|	    return(XML_READER_TYPE_ATTRIBUTE);
 2894|    583|        case XML_TEXT_NODE:
  ------------------
  |  Branch (2894:9): [True: 583, False: 1.21k]
  ------------------
 2895|    583|	    if (xmlIsBlankNode(reader->node)) {
  ------------------
  |  Branch (2895:10): [True: 538, False: 45]
  ------------------
 2896|    538|		if (xmlNodeGetSpacePreserve(reader->node))
  ------------------
  |  Branch (2896:7): [True: 538, False: 0]
  ------------------
 2897|    538|		    return(XML_READER_TYPE_SIGNIFICANT_WHITESPACE);
 2898|      0|		else
 2899|      0|		    return(XML_READER_TYPE_WHITESPACE);
 2900|    538|	    } else {
 2901|     45|		return(XML_READER_TYPE_TEXT);
 2902|     45|	    }
 2903|      0|        case XML_CDATA_SECTION_NODE:
  ------------------
  |  Branch (2903:9): [True: 0, False: 1.80k]
  ------------------
 2904|      0|	    return(XML_READER_TYPE_CDATA);
 2905|      0|        case XML_ENTITY_REF_NODE:
  ------------------
  |  Branch (2905:9): [True: 0, False: 1.80k]
  ------------------
 2906|      0|	    return(XML_READER_TYPE_ENTITY_REFERENCE);
 2907|      0|        case XML_ENTITY_NODE:
  ------------------
  |  Branch (2907:9): [True: 0, False: 1.80k]
  ------------------
 2908|      0|	    return(XML_READER_TYPE_ENTITY);
 2909|      0|        case XML_PI_NODE:
  ------------------
  |  Branch (2909:9): [True: 0, False: 1.80k]
  ------------------
 2910|      0|	    return(XML_READER_TYPE_PROCESSING_INSTRUCTION);
 2911|     13|        case XML_COMMENT_NODE:
  ------------------
  |  Branch (2911:9): [True: 13, False: 1.78k]
  ------------------
 2912|     13|	    return(XML_READER_TYPE_COMMENT);
 2913|      0|        case XML_DOCUMENT_NODE:
  ------------------
  |  Branch (2913:9): [True: 0, False: 1.80k]
  ------------------
 2914|      0|        case XML_HTML_DOCUMENT_NODE:
  ------------------
  |  Branch (2914:9): [True: 0, False: 1.80k]
  ------------------
 2915|      0|	    return(XML_READER_TYPE_DOCUMENT);
 2916|      0|        case XML_DOCUMENT_FRAG_NODE:
  ------------------
  |  Branch (2916:9): [True: 0, False: 1.80k]
  ------------------
 2917|      0|	    return(XML_READER_TYPE_DOCUMENT_FRAGMENT);
 2918|      0|        case XML_NOTATION_NODE:
  ------------------
  |  Branch (2918:9): [True: 0, False: 1.80k]
  ------------------
 2919|      0|	    return(XML_READER_TYPE_NOTATION);
 2920|      0|        case XML_DOCUMENT_TYPE_NODE:
  ------------------
  |  Branch (2920:9): [True: 0, False: 1.80k]
  ------------------
 2921|      3|        case XML_DTD_NODE:
  ------------------
  |  Branch (2921:9): [True: 3, False: 1.79k]
  ------------------
 2922|      3|	    return(XML_READER_TYPE_DOCUMENT_TYPE);
 2923|       |
 2924|      0|        case XML_ELEMENT_DECL:
  ------------------
  |  Branch (2924:9): [True: 0, False: 1.80k]
  ------------------
 2925|      0|        case XML_ATTRIBUTE_DECL:
  ------------------
  |  Branch (2925:9): [True: 0, False: 1.80k]
  ------------------
 2926|      0|        case XML_ENTITY_DECL:
  ------------------
  |  Branch (2926:9): [True: 0, False: 1.80k]
  ------------------
 2927|      0|        case XML_XINCLUDE_START:
  ------------------
  |  Branch (2927:9): [True: 0, False: 1.80k]
  ------------------
 2928|      0|        case XML_XINCLUDE_END:
  ------------------
  |  Branch (2928:9): [True: 0, False: 1.80k]
  ------------------
 2929|      0|	    return(XML_READER_TYPE_NONE);
 2930|  1.80k|    }
 2931|      0|    return(-1);
 2932|  1.80k|}
xmlTextReaderSetup:
 4983|    167|{
 4984|    167|    if (reader == NULL) {
  ------------------
  |  Branch (4984:9): [True: 0, False: 167]
  ------------------
 4985|      0|        if (input != NULL)
  ------------------
  |  Branch (4985:13): [True: 0, False: 0]
  ------------------
 4986|      0|	    xmlFreeParserInputBuffer(input);
 4987|      0|        return (-1);
 4988|      0|    }
 4989|       |
 4990|       |    /*
 4991|       |     * we force the generation of compact text nodes on the reader
 4992|       |     * since usr applications should never modify the tree
 4993|       |     */
 4994|    167|    options |= XML_PARSE_COMPACT;
 4995|       |
 4996|    167|    reader->doc = NULL;
 4997|    167|    reader->entNr = 0;
 4998|    167|    reader->parserFlags = options;
 4999|    167|    reader->validate = XML_TEXTREADER_NOT_VALIDATE;
 5000|    167|    if ((input != NULL) && (reader->input != NULL) &&
  ------------------
  |  Branch (5000:9): [True: 0, False: 167]
  |  Branch (5000:28): [True: 0, False: 0]
  ------------------
 5001|    167|        (reader->allocs & XML_TEXTREADER_INPUT)) {
  ------------------
  |  |   98|      0|#define XML_TEXTREADER_INPUT	1
  ------------------
  |  Branch (5001:9): [True: 0, False: 0]
  ------------------
 5002|      0|	xmlFreeParserInputBuffer(reader->input);
 5003|      0|	reader->input = NULL;
 5004|      0|	reader->allocs -= XML_TEXTREADER_INPUT;
  ------------------
  |  |   98|      0|#define XML_TEXTREADER_INPUT	1
  ------------------
 5005|      0|    }
 5006|    167|    if (input != NULL) {
  ------------------
  |  Branch (5006:9): [True: 0, False: 167]
  ------------------
 5007|      0|	reader->input = input;
 5008|      0|	reader->allocs |= XML_TEXTREADER_INPUT;
  ------------------
  |  |   98|      0|#define XML_TEXTREADER_INPUT	1
  ------------------
 5009|      0|    }
 5010|    167|    if (reader->buffer == NULL)
  ------------------
  |  Branch (5010:9): [True: 0, False: 167]
  ------------------
 5011|      0|        reader->buffer = xmlBufCreateSize(100);
 5012|    167|    if (reader->buffer == NULL) {
  ------------------
  |  Branch (5012:9): [True: 0, False: 167]
  ------------------
 5013|      0|        xmlGenericError(xmlGenericErrorContext,
  ------------------
  |  |  875|      0|  #define xmlGenericError XML_GLOBAL_MACRO(xmlGenericError)
  |  |  ------------------
  |  |  |  |  500|      0|  #define XML_GLOBAL_MACRO(name) (*__##name())
  |  |  ------------------
  ------------------
                      xmlGenericError(xmlGenericErrorContext,
  ------------------
  |  |  876|      0|  #define xmlGenericErrorContext XML_GLOBAL_MACRO(xmlGenericErrorContext)
  |  |  ------------------
  |  |  |  |  500|      0|  #define XML_GLOBAL_MACRO(name) (*__##name())
  |  |  ------------------
  ------------------
 5014|      0|                        "xmlTextReaderSetup : malloc failed\n");
 5015|      0|        return (-1);
 5016|      0|    }
 5017|       |    /* no operation on a reader should require a huge buffer */
 5018|    167|    xmlBufSetAllocationScheme(reader->buffer,
 5019|    167|			      XML_BUFFER_ALLOC_DOUBLEIT);
 5020|    167|    if (reader->sax == NULL)
  ------------------
  |  Branch (5020:9): [True: 0, False: 167]
  ------------------
 5021|      0|	reader->sax = (xmlSAXHandler *) xmlMalloc(sizeof(xmlSAXHandler));
 5022|    167|    if (reader->sax == NULL) {
  ------------------
  |  Branch (5022:9): [True: 0, False: 167]
  ------------------
 5023|      0|        xmlGenericError(xmlGenericErrorContext,
  ------------------
  |  |  875|      0|  #define xmlGenericError XML_GLOBAL_MACRO(xmlGenericError)
  |  |  ------------------
  |  |  |  |  500|      0|  #define XML_GLOBAL_MACRO(name) (*__##name())
  |  |  ------------------
  ------------------
                      xmlGenericError(xmlGenericErrorContext,
  ------------------
  |  |  876|      0|  #define xmlGenericErrorContext XML_GLOBAL_MACRO(xmlGenericErrorContext)
  |  |  ------------------
  |  |  |  |  500|      0|  #define XML_GLOBAL_MACRO(name) (*__##name())
  |  |  ------------------
  ------------------
 5024|      0|                        "xmlTextReaderSetup : malloc failed\n");
 5025|      0|        return (-1);
 5026|      0|    }
 5027|    167|    xmlSAXVersion(reader->sax, 2);
 5028|    167|    reader->startElement = reader->sax->startElement;
 5029|    167|    reader->sax->startElement = xmlTextReaderStartElement;
 5030|    167|    reader->endElement = reader->sax->endElement;
 5031|    167|    reader->sax->endElement = xmlTextReaderEndElement;
 5032|    167|#ifdef LIBXML_SAX1_ENABLED
 5033|    167|    if (reader->sax->initialized == XML_SAX2_MAGIC) {
  ------------------
  |  |  685|    167|#define XML_SAX2_MAGIC 0xDEEDBEAF
  ------------------
  |  Branch (5033:9): [True: 167, False: 0]
  ------------------
 5034|    167|#endif /* LIBXML_SAX1_ENABLED */
 5035|    167|        reader->startElementNs = reader->sax->startElementNs;
 5036|    167|        reader->sax->startElementNs = xmlTextReaderStartElementNs;
 5037|    167|        reader->endElementNs = reader->sax->endElementNs;
 5038|    167|        reader->sax->endElementNs = xmlTextReaderEndElementNs;
 5039|    167|#ifdef LIBXML_SAX1_ENABLED
 5040|    167|    } else {
 5041|      0|        reader->startElementNs = NULL;
 5042|      0|        reader->endElementNs = NULL;
 5043|      0|    }
 5044|    167|#endif /* LIBXML_SAX1_ENABLED */
 5045|    167|    reader->characters = reader->sax->characters;
 5046|    167|    reader->sax->characters = xmlTextReaderCharacters;
 5047|    167|    reader->sax->ignorableWhitespace = xmlTextReaderCharacters;
 5048|    167|    reader->cdataBlock = reader->sax->cdataBlock;
 5049|    167|    reader->sax->cdataBlock = xmlTextReaderCDataBlock;
 5050|       |
 5051|    167|    reader->mode = XML_TEXTREADER_MODE_INITIAL;
 5052|    167|    reader->node = NULL;
 5053|    167|    reader->curnode = NULL;
 5054|    167|    if (input != NULL) {
  ------------------
  |  Branch (5054:9): [True: 0, False: 167]
  ------------------
 5055|      0|        if (xmlBufUse(reader->input->buffer) < 4) {
  ------------------
  |  Branch (5055:13): [True: 0, False: 0]
  ------------------
 5056|      0|            xmlParserInputBufferRead(input, 4);
 5057|      0|        }
 5058|      0|        if (reader->ctxt == NULL) {
  ------------------
  |  Branch (5058:13): [True: 0, False: 0]
  ------------------
 5059|      0|            if (xmlBufUse(reader->input->buffer) >= 4) {
  ------------------
  |  Branch (5059:17): [True: 0, False: 0]
  ------------------
 5060|      0|                reader->ctxt = xmlCreatePushParserCtxt(reader->sax, NULL,
 5061|      0|		       (const char *) xmlBufContent(reader->input->buffer),
 5062|      0|                                      4, URL);
 5063|      0|                reader->base = 0;
 5064|      0|                reader->cur = 4;
 5065|      0|            } else {
 5066|      0|                reader->ctxt =
 5067|      0|                    xmlCreatePushParserCtxt(reader->sax, NULL, NULL, 0, URL);
 5068|      0|                reader->base = 0;
 5069|      0|                reader->cur = 0;
 5070|      0|            }
 5071|      0|        } else {
 5072|      0|	    xmlParserInputPtr inputStream;
 5073|      0|	    xmlParserInputBufferPtr buf;
 5074|      0|	    xmlCharEncoding enc = XML_CHAR_ENCODING_NONE;
 5075|       |
 5076|      0|	    xmlCtxtReset(reader->ctxt);
 5077|      0|	    buf = xmlAllocParserInputBuffer(enc);
 5078|      0|	    if (buf == NULL) return(-1);
  ------------------
  |  Branch (5078:10): [True: 0, False: 0]
  ------------------
 5079|      0|	    inputStream = xmlNewInputStream(reader->ctxt);
 5080|      0|	    if (inputStream == NULL) {
  ------------------
  |  Branch (5080:10): [True: 0, False: 0]
  ------------------
 5081|      0|		xmlFreeParserInputBuffer(buf);
 5082|      0|		return(-1);
 5083|      0|	    }
 5084|       |
 5085|      0|	    if (URL == NULL)
  ------------------
  |  Branch (5085:10): [True: 0, False: 0]
  ------------------
 5086|      0|		inputStream->filename = NULL;
 5087|      0|	    else
 5088|      0|		inputStream->filename = (char *)
 5089|      0|		    xmlCanonicPath((const xmlChar *) URL);
 5090|      0|	    inputStream->buf = buf;
 5091|      0|            xmlBufResetInput(buf->buffer, inputStream);
 5092|       |
 5093|      0|	    inputPush(reader->ctxt, inputStream);
 5094|      0|	    reader->cur = 0;
 5095|      0|	}
 5096|      0|        if (reader->ctxt == NULL) {
  ------------------
  |  Branch (5096:13): [True: 0, False: 0]
  ------------------
 5097|      0|            xmlGenericError(xmlGenericErrorContext,
  ------------------
  |  |  875|      0|  #define xmlGenericError XML_GLOBAL_MACRO(xmlGenericError)
  |  |  ------------------
  |  |  |  |  500|      0|  #define XML_GLOBAL_MACRO(name) (*__##name())
  |  |  ------------------
  ------------------
                          xmlGenericError(xmlGenericErrorContext,
  ------------------
  |  |  876|      0|  #define xmlGenericErrorContext XML_GLOBAL_MACRO(xmlGenericErrorContext)
  |  |  ------------------
  |  |  |  |  500|      0|  #define XML_GLOBAL_MACRO(name) (*__##name())
  |  |  ------------------
  ------------------
 5098|      0|                            "xmlTextReaderSetup : malloc failed\n");
 5099|      0|            return (-1);
 5100|      0|        }
 5101|      0|    }
 5102|    167|    if (reader->dict != NULL) {
  ------------------
  |  Branch (5102:9): [True: 167, False: 0]
  ------------------
 5103|    167|        if (reader->ctxt->dict != NULL) {
  ------------------
  |  Branch (5103:13): [True: 167, False: 0]
  ------------------
 5104|    167|	    if (reader->dict != reader->ctxt->dict) {
  ------------------
  |  Branch (5104:10): [True: 0, False: 167]
  ------------------
 5105|      0|		xmlDictFree(reader->dict);
 5106|      0|		reader->dict = reader->ctxt->dict;
 5107|      0|	    }
 5108|    167|	} else {
 5109|      0|	    reader->ctxt->dict = reader->dict;
 5110|      0|	}
 5111|    167|    } else {
 5112|      0|	if (reader->ctxt->dict == NULL)
  ------------------
  |  Branch (5112:6): [True: 0, False: 0]
  ------------------
 5113|      0|	    reader->ctxt->dict = xmlDictCreate();
 5114|      0|        reader->dict = reader->ctxt->dict;
 5115|      0|    }
 5116|    167|    reader->ctxt->_private = reader;
 5117|    167|    reader->ctxt->linenumbers = 1;
 5118|    167|    reader->ctxt->dictNames = 1;
 5119|       |    /*
 5120|       |     * use the parser dictionary to allocate all elements and attributes names
 5121|       |     */
 5122|    167|    reader->ctxt->docdict = 1;
 5123|    167|    reader->ctxt->parseMode = XML_PARSE_READER;
 5124|       |
 5125|    167|#ifdef LIBXML_XINCLUDE_ENABLED
 5126|    167|    if (reader->xincctxt != NULL) {
  ------------------
  |  Branch (5126:9): [True: 0, False: 167]
  ------------------
 5127|      0|	xmlXIncludeFreeContext(reader->xincctxt);
 5128|      0|	reader->xincctxt = NULL;
 5129|      0|    }
 5130|    167|    if (options & XML_PARSE_XINCLUDE) {
  ------------------
  |  Branch (5130:9): [True: 167, False: 0]
  ------------------
 5131|    167|        reader->xinclude = 1;
 5132|    167|	reader->xinclude_name = xmlDictLookup(reader->dict, XINCLUDE_NODE, -1);
  ------------------
  |  |   42|    167|#define XINCLUDE_NODE (const xmlChar *) "include"
  ------------------
 5133|    167|	options -= XML_PARSE_XINCLUDE;
 5134|    167|    } else
 5135|      0|        reader->xinclude = 0;
 5136|    167|    reader->in_xinclude = 0;
 5137|    167|#endif
 5138|    167|#ifdef LIBXML_PATTERN_ENABLED
 5139|    167|    if (reader->patternTab == NULL) {
  ------------------
  |  Branch (5139:9): [True: 167, False: 0]
  ------------------
 5140|    167|        reader->patternNr = 0;
 5141|    167|	reader->patternMax = 0;
 5142|    167|    }
 5143|    167|    while (reader->patternNr > 0) {
  ------------------
  |  Branch (5143:12): [True: 0, False: 167]
  ------------------
 5144|      0|        reader->patternNr--;
 5145|      0|	if (reader->patternTab[reader->patternNr] != NULL) {
  ------------------
  |  Branch (5145:6): [True: 0, False: 0]
  ------------------
 5146|      0|	    xmlFreePattern(reader->patternTab[reader->patternNr]);
 5147|      0|            reader->patternTab[reader->patternNr] = NULL;
 5148|      0|	}
 5149|      0|    }
 5150|    167|#endif
 5151|       |
 5152|    167|    if (options & XML_PARSE_DTDVALID)
  ------------------
  |  Branch (5152:9): [True: 0, False: 167]
  ------------------
 5153|      0|        reader->validate = XML_TEXTREADER_VALIDATE_DTD;
 5154|       |
 5155|    167|    xmlCtxtUseOptions(reader->ctxt, options);
 5156|    167|    if (encoding != NULL) {
  ------------------
  |  Branch (5156:9): [True: 0, False: 167]
  ------------------
 5157|      0|        xmlCharEncodingHandlerPtr hdlr;
 5158|       |
 5159|      0|        hdlr = xmlFindCharEncodingHandler(encoding);
 5160|      0|        if (hdlr != NULL)
  ------------------
  |  Branch (5160:13): [True: 0, False: 0]
  ------------------
 5161|      0|            xmlSwitchToEncoding(reader->ctxt, hdlr);
 5162|      0|    }
 5163|    167|    if ((URL != NULL) && (reader->ctxt->input != NULL) &&
  ------------------
  |  Branch (5163:9): [True: 0, False: 167]
  |  Branch (5163:26): [True: 0, False: 0]
  ------------------
 5164|    167|        (reader->ctxt->input->filename == NULL))
  ------------------
  |  Branch (5164:9): [True: 0, False: 0]
  ------------------
 5165|      0|        reader->ctxt->input->filename = (char *)
 5166|      0|            xmlStrdup((const xmlChar *) URL);
 5167|       |
 5168|    167|    reader->doc = NULL;
 5169|       |
 5170|    167|    return (0);
 5171|    167|}
xmlReaderForMemory:
 5309|    167|{
 5310|    167|    xmlTextReaderPtr reader;
 5311|    167|    xmlParserInputBufferPtr buf;
 5312|       |
 5313|    167|    buf = xmlParserInputBufferCreateMem(buffer, size, XML_CHAR_ENCODING_NONE);
 5314|    167|    if (buf == NULL) {
  ------------------
  |  Branch (5314:9): [True: 0, False: 167]
  ------------------
 5315|      0|        return (NULL);
 5316|      0|    }
 5317|    167|    reader = xmlNewTextReader(buf, URL);
 5318|    167|    if (reader == NULL) {
  ------------------
  |  Branch (5318:9): [True: 0, False: 167]
  ------------------
 5319|      0|        xmlFreeParserInputBuffer(buf);
 5320|      0|        return (NULL);
 5321|      0|    }
 5322|    167|    reader->allocs |= XML_TEXTREADER_INPUT;
  ------------------
  |  |   98|    167|#define XML_TEXTREADER_INPUT	1
  ------------------
 5323|    167|    xmlTextReaderSetup(reader, NULL, URL, encoding, options);
 5324|    167|    return (reader);
 5325|    167|}
xmlreader.c:xmlTextReaderPushData:
  711|    512|xmlTextReaderPushData(xmlTextReaderPtr reader) {
  712|    512|    xmlBufPtr inbuf;
  713|    512|    int val, s;
  714|    512|    xmlTextReaderState oldstate;
  715|       |
  716|    512|    if ((reader->input == NULL) || (reader->input->buffer == NULL))
  ------------------
  |  Branch (716:9): [True: 0, False: 512]
  |  Branch (716:36): [True: 0, False: 512]
  ------------------
  717|      0|	return(-1);
  718|       |
  719|    512|    oldstate = reader->state;
  720|    512|    reader->state = XML_TEXTREADER_NONE;
  721|    512|    inbuf = reader->input->buffer;
  722|       |
  723|    552|    while (reader->state == XML_TEXTREADER_NONE) {
  ------------------
  |  Branch (723:12): [True: 515, False: 37]
  ------------------
  724|    515|	if (xmlBufUse(inbuf) < reader->cur + CHUNK_SIZE) {
  ------------------
  |  |   90|    515|#define CHUNK_SIZE 512
  ------------------
  |  Branch (724:6): [True: 484, False: 31]
  ------------------
  725|       |	    /*
  726|       |	     * Refill the buffer unless we are at the end of the stream
  727|       |	     */
  728|    484|	    if (reader->mode != XML_TEXTREADER_MODE_EOF) {
  ------------------
  |  Branch (728:10): [True: 484, False: 0]
  ------------------
  729|    484|		val = xmlParserInputBufferRead(reader->input, 4096);
  730|    484|		if (val == 0) {
  ------------------
  |  Branch (730:7): [True: 314, False: 170]
  ------------------
  731|    314|		    if (xmlBufUse(inbuf) == reader->cur) {
  ------------------
  |  Branch (731:11): [True: 308, False: 6]
  ------------------
  732|    308|			reader->mode = XML_TEXTREADER_MODE_EOF;
  733|    308|                        break;
  734|    308|		    }
  735|    314|		} else if (val < 0) {
  ------------------
  |  Branch (735:14): [True: 0, False: 170]
  ------------------
  736|      0|                    xmlGenericError(xmlGenericErrorContext,
  ------------------
  |  |  875|      0|  #define xmlGenericError XML_GLOBAL_MACRO(xmlGenericError)
  |  |  ------------------
  |  |  |  |  500|      0|  #define XML_GLOBAL_MACRO(name) (*__##name())
  |  |  ------------------
  ------------------
                                  xmlGenericError(xmlGenericErrorContext,
  ------------------
  |  |  876|      0|  #define xmlGenericErrorContext XML_GLOBAL_MACRO(xmlGenericErrorContext)
  |  |  ------------------
  |  |  |  |  500|      0|  #define XML_GLOBAL_MACRO(name) (*__##name())
  |  |  ------------------
  ------------------
  737|      0|                                    "xmlParserInputBufferRead failed\n");
  738|      0|		    reader->mode = XML_TEXTREADER_MODE_EOF;
  739|      0|		    reader->state = oldstate;
  740|      0|		    return(val);
  741|      0|		}
  742|       |
  743|    484|	    } else
  744|      0|		break;
  745|    484|	}
  746|       |	/*
  747|       |	 * parse by block of CHUNK_SIZE bytes, various tests show that
  748|       |	 * it's the best tradeoff at least on a 1.2GH Duron
  749|       |	 */
  750|    207|	if (xmlBufUse(inbuf) >= reader->cur + CHUNK_SIZE) {
  ------------------
  |  |   90|    207|#define CHUNK_SIZE 512
  ------------------
  |  Branch (750:6): [True: 43, False: 164]
  ------------------
  751|     43|	    val = xmlParseChunk(reader->ctxt,
  752|     43|                 (const char *) xmlBufContent(inbuf) + reader->cur,
  753|     43|                                CHUNK_SIZE, 0);
  ------------------
  |  |   90|     43|#define CHUNK_SIZE 512
  ------------------
  754|     43|	    reader->cur += CHUNK_SIZE;
  ------------------
  |  |   90|     43|#define CHUNK_SIZE 512
  ------------------
  755|     43|	    if (val != 0)
  ------------------
  |  Branch (755:10): [True: 3, False: 40]
  ------------------
  756|      3|		reader->ctxt->wellFormed = 0;
  757|     43|	    if (reader->ctxt->wellFormed == 0)
  ------------------
  |  Branch (757:10): [True: 3, False: 40]
  ------------------
  758|      3|		break;
  759|    164|	} else {
  760|    164|	    s = xmlBufUse(inbuf) - reader->cur;
  761|    164|	    val = xmlParseChunk(reader->ctxt,
  762|    164|		 (const char *) xmlBufContent(inbuf) + reader->cur,
  763|    164|			        s, 0);
  764|    164|	    reader->cur += s;
  765|    164|	    if (val != 0)
  ------------------
  |  Branch (765:10): [True: 83, False: 81]
  ------------------
  766|     83|		reader->ctxt->wellFormed = 0;
  767|    164|	    break;
  768|    164|	}
  769|    207|    }
  770|    512|    reader->state = oldstate;
  771|       |
  772|       |    /*
  773|       |     * Discard the consumed input when needed and possible
  774|       |     */
  775|    512|    if (reader->mode == XML_TEXTREADER_MODE_INTERACTIVE) {
  ------------------
  |  Branch (775:9): [True: 204, False: 308]
  ------------------
  776|    204|        if (reader->input->readcallback != NULL) {
  ------------------
  |  Branch (776:13): [True: 204, False: 0]
  ------------------
  777|    204|	    if ((reader->cur >= 4096) &&
  ------------------
  |  Branch (777:10): [True: 3, False: 201]
  ------------------
  778|    204|		(xmlBufUse(inbuf) - reader->cur <= CHUNK_SIZE)) {
  ------------------
  |  |   90|      3|#define CHUNK_SIZE 512
  ------------------
  |  Branch (778:3): [True: 3, False: 0]
  ------------------
  779|      3|		val = xmlBufShrink(inbuf, reader->cur);
  780|      3|		if (val >= 0) {
  ------------------
  |  Branch (780:7): [True: 3, False: 0]
  ------------------
  781|      3|		    reader->cur -= val;
  782|      3|		}
  783|      3|	    }
  784|    204|	}
  785|    204|    }
  786|       |
  787|       |    /*
  788|       |     * At the end of the stream signal that the work is done to the Push
  789|       |     * parser.
  790|       |     */
  791|    308|    else if (reader->mode == XML_TEXTREADER_MODE_EOF) {
  ------------------
  |  Branch (791:14): [True: 308, False: 0]
  ------------------
  792|    308|	if (reader->state != XML_TEXTREADER_DONE) {
  ------------------
  |  Branch (792:6): [True: 298, False: 10]
  ------------------
  793|    298|	    s = xmlBufUse(inbuf) - reader->cur;
  794|    298|	    val = xmlParseChunk(reader->ctxt,
  795|    298|		 (const char *) xmlBufContent(inbuf) + reader->cur,
  796|    298|			        s, 1);
  797|    298|	    reader->cur = xmlBufUse(inbuf);
  798|    298|	    reader->state  = XML_TEXTREADER_DONE;
  799|    298|	    if (val != 0) {
  ------------------
  |  Branch (799:10): [True: 258, False: 40]
  ------------------
  800|    258|	        if (reader->ctxt->wellFormed)
  ------------------
  |  Branch (800:14): [True: 0, False: 258]
  ------------------
  801|      0|		    reader->ctxt->wellFormed = 0;
  802|    258|		else
  803|    258|		    return(-1);
  804|    258|	    }
  805|    298|	}
  806|    308|    }
  807|    254|    if (reader->ctxt->wellFormed == 0) {
  ------------------
  |  Branch (807:9): [True: 96, False: 158]
  ------------------
  808|     96|	reader->mode = XML_TEXTREADER_MODE_EOF;
  809|     96|        return(-1);
  810|     96|    }
  811|       |
  812|    158|    return(0);
  813|    254|}
xmlreader.c:xmlTextReaderFreeNode:
  377|  1.25k|xmlTextReaderFreeNode(xmlTextReaderPtr reader, xmlNodePtr cur) {
  378|  1.25k|    xmlDictPtr dict;
  379|       |
  380|  1.25k|    if ((reader != NULL) && (reader->ctxt != NULL))
  ------------------
  |  Branch (380:9): [True: 1.25k, False: 0]
  |  Branch (380:29): [True: 1.25k, False: 0]
  ------------------
  381|  1.25k|	dict = reader->ctxt->dict;
  382|      0|    else
  383|      0|        dict = NULL;
  384|  1.25k|    if (cur->type == XML_DTD_NODE) {
  ------------------
  |  Branch (384:9): [True: 0, False: 1.25k]
  ------------------
  385|      0|	xmlFreeDtd((xmlDtdPtr) cur);
  386|      0|	return;
  387|      0|    }
  388|  1.25k|    if (cur->type == XML_NAMESPACE_DECL) {
  ------------------
  |  Branch (388:9): [True: 0, False: 1.25k]
  ------------------
  389|      0|	xmlFreeNs((xmlNsPtr) cur);
  390|      0|        return;
  391|      0|    }
  392|  1.25k|    if (cur->type == XML_ATTRIBUTE_NODE) {
  ------------------
  |  Branch (392:9): [True: 0, False: 1.25k]
  ------------------
  393|      0|	xmlTextReaderFreeProp(reader, (xmlAttrPtr) cur);
  394|      0|	return;
  395|      0|    }
  396|       |
  397|  1.25k|    if ((cur->children != NULL) &&
  ------------------
  |  Branch (397:9): [True: 20, False: 1.23k]
  ------------------
  398|  1.25k|	(cur->type != XML_ENTITY_REF_NODE)) {
  ------------------
  |  Branch (398:2): [True: 20, False: 0]
  ------------------
  399|     20|	if (cur->children->parent == cur)
  ------------------
  |  Branch (399:6): [True: 20, False: 0]
  ------------------
  400|     20|	    xmlTextReaderFreeNodeList(reader, cur->children);
  401|     20|	cur->children = NULL;
  402|     20|    }
  403|       |
  404|  1.25k|    if ((__xmlRegisterCallbacks) && (xmlDeregisterNodeDefaultValue))
  ------------------
  |  |  684|      0|    XML_GLOBAL_MACRO(xmlDeregisterNodeDefaultValue)
  |  |  ------------------
  |  |  |  |  500|      0|  #define XML_GLOBAL_MACRO(name) (*__##name())
  |  |  ------------------
  ------------------
  |  Branch (404:9): [True: 0, False: 1.25k]
  |  Branch (404:37): [True: 0, False: 0]
  ------------------
  405|      0|	xmlDeregisterNodeDefaultValue(cur);
  ------------------
  |  |  684|      0|    XML_GLOBAL_MACRO(xmlDeregisterNodeDefaultValue)
  |  |  ------------------
  |  |  |  |  500|      0|  #define XML_GLOBAL_MACRO(name) (*__##name())
  |  |  ------------------
  ------------------
  406|       |
  407|  1.25k|    if (((cur->type == XML_ELEMENT_NODE) ||
  ------------------
  |  Branch (407:10): [True: 728, False: 529]
  ------------------
  408|  1.25k|	 (cur->type == XML_XINCLUDE_START) ||
  ------------------
  |  Branch (408:3): [True: 0, False: 529]
  ------------------
  409|  1.25k|	 (cur->type == XML_XINCLUDE_END)) &&
  ------------------
  |  Branch (409:3): [True: 21, False: 508]
  ------------------
  410|  1.25k|	(cur->properties != NULL))
  ------------------
  |  Branch (410:2): [True: 346, False: 403]
  ------------------
  411|    346|	xmlTextReaderFreePropList(reader, cur->properties);
  412|  1.25k|    if ((cur->content != (xmlChar *) &(cur->properties)) &&
  ------------------
  |  Branch (412:9): [True: 767, False: 490]
  ------------------
  413|  1.25k|        (cur->type != XML_ELEMENT_NODE) &&
  ------------------
  |  Branch (413:9): [True: 39, False: 728]
  ------------------
  414|  1.25k|	(cur->type != XML_XINCLUDE_START) &&
  ------------------
  |  Branch (414:2): [True: 39, False: 0]
  ------------------
  415|  1.25k|	(cur->type != XML_XINCLUDE_END) &&
  ------------------
  |  Branch (415:2): [True: 18, False: 21]
  ------------------
  416|  1.25k|	(cur->type != XML_ENTITY_REF_NODE)) {
  ------------------
  |  Branch (416:2): [True: 18, False: 0]
  ------------------
  417|     18|	DICT_FREE(cur->content);
  ------------------
  |  |  214|     18|	if ((str) && ((!dict) ||				\
  |  |  ------------------
  |  |  |  Branch (214:6): [True: 18, False: 0]
  |  |  |  Branch (214:16): [True: 0, False: 18]
  |  |  ------------------
  |  |  215|     18|	    (xmlDictOwns(dict, (const xmlChar *)(str)) == 0)))	\
  |  |  ------------------
  |  |  |  Branch (215:6): [True: 14, False: 4]
  |  |  ------------------
  |  |  216|     18|	    xmlFree((char *)(str));
  ------------------
  418|     18|    }
  419|  1.25k|    if (((cur->type == XML_ELEMENT_NODE) ||
  ------------------
  |  Branch (419:10): [True: 728, False: 529]
  ------------------
  420|  1.25k|	 (cur->type == XML_XINCLUDE_START) ||
  ------------------
  |  Branch (420:3): [True: 0, False: 529]
  ------------------
  421|  1.25k|	 (cur->type == XML_XINCLUDE_END)) &&
  ------------------
  |  Branch (421:3): [True: 21, False: 508]
  ------------------
  422|  1.25k|	(cur->nsDef != NULL))
  ------------------
  |  Branch (422:2): [True: 33, False: 716]
  ------------------
  423|     33|	xmlFreeNsList(cur->nsDef);
  424|       |
  425|       |    /*
  426|       |     * we don't free names here they are interned now
  427|       |     */
  428|  1.25k|    if ((cur->type != XML_TEXT_NODE) &&
  ------------------
  |  Branch (428:9): [True: 762, False: 495]
  ------------------
  429|  1.25k|        (cur->type != XML_COMMENT_NODE))
  ------------------
  |  Branch (429:9): [True: 749, False: 13]
  ------------------
  430|    749|	DICT_FREE(cur->name);
  ------------------
  |  |  214|    749|	if ((str) && ((!dict) ||				\
  |  |  ------------------
  |  |  |  Branch (214:6): [True: 749, False: 0]
  |  |  |  Branch (214:16): [True: 0, False: 749]
  |  |  ------------------
  |  |  215|    749|	    (xmlDictOwns(dict, (const xmlChar *)(str)) == 0)))	\
  |  |  ------------------
  |  |  |  Branch (215:6): [True: 0, False: 749]
  |  |  ------------------
  |  |  216|    749|	    xmlFree((char *)(str));
  ------------------
  431|       |
  432|  1.25k|    if (((cur->type == XML_ELEMENT_NODE) ||
  ------------------
  |  Branch (432:10): [True: 728, False: 529]
  ------------------
  433|  1.25k|	 (cur->type == XML_TEXT_NODE)) &&
  ------------------
  |  Branch (433:3): [True: 495, False: 34]
  ------------------
  434|  1.25k|	(reader != NULL) && (reader->ctxt != NULL) &&
  ------------------
  |  Branch (434:2): [True: 1.22k, False: 0]
  |  Branch (434:22): [True: 1.22k, False: 0]
  ------------------
  435|  1.25k|	(reader->ctxt->freeElemsNr < MAX_FREE_NODES)) {
  ------------------
  |  |   52|  1.22k|#define MAX_FREE_NODES 1
  ------------------
  |  Branch (435:2): [True: 62, False: 1.16k]
  ------------------
  436|     62|	cur->next = reader->ctxt->freeElems;
  437|     62|	reader->ctxt->freeElems = cur;
  438|     62|	reader->ctxt->freeElemsNr++;
  439|  1.19k|    } else {
  440|  1.19k|	xmlFree(cur);
  441|  1.19k|    }
  442|  1.25k|}
xmlreader.c:xmlTextReaderFreeProp:
  229|    431|xmlTextReaderFreeProp(xmlTextReaderPtr reader, xmlAttrPtr cur) {
  230|    431|    xmlDictPtr dict;
  231|       |
  232|    431|    if ((reader != NULL) && (reader->ctxt != NULL))
  ------------------
  |  Branch (232:9): [True: 431, False: 0]
  |  Branch (232:29): [True: 431, False: 0]
  ------------------
  233|    431|	dict = reader->ctxt->dict;
  234|      0|    else
  235|      0|        dict = NULL;
  236|    431|    if (cur == NULL) return;
  ------------------
  |  Branch (236:9): [True: 0, False: 431]
  ------------------
  237|       |
  238|    431|    if ((__xmlRegisterCallbacks) && (xmlDeregisterNodeDefaultValue))
  ------------------
  |  |  684|      0|    XML_GLOBAL_MACRO(xmlDeregisterNodeDefaultValue)
  |  |  ------------------
  |  |  |  |  500|      0|  #define XML_GLOBAL_MACRO(name) (*__##name())
  |  |  ------------------
  ------------------
  |  Branch (238:9): [True: 0, False: 431]
  |  Branch (238:37): [True: 0, False: 0]
  ------------------
  239|      0|	xmlDeregisterNodeDefaultValue((xmlNodePtr) cur);
  ------------------
  |  |  684|      0|    XML_GLOBAL_MACRO(xmlDeregisterNodeDefaultValue)
  |  |  ------------------
  |  |  |  |  500|      0|  #define XML_GLOBAL_MACRO(name) (*__##name())
  |  |  ------------------
  ------------------
  240|       |
  241|    431|    if (cur->children != NULL)
  ------------------
  |  Branch (241:9): [True: 431, False: 0]
  ------------------
  242|    431|        xmlTextReaderFreeNodeList(reader, cur->children);
  243|       |
  244|    431|    DICT_FREE(cur->name);
  ------------------
  |  |  214|    431|	if ((str) && ((!dict) ||				\
  |  |  ------------------
  |  |  |  Branch (214:6): [True: 431, False: 0]
  |  |  |  Branch (214:16): [True: 0, False: 431]
  |  |  ------------------
  |  |  215|    431|	    (xmlDictOwns(dict, (const xmlChar *)(str)) == 0)))	\
  |  |  ------------------
  |  |  |  Branch (215:6): [True: 1, False: 430]
  |  |  ------------------
  |  |  216|    431|	    xmlFree((char *)(str));
  ------------------
  245|    431|    if ((reader != NULL) && (reader->ctxt != NULL) &&
  ------------------
  |  Branch (245:9): [True: 431, False: 0]
  |  Branch (245:29): [True: 431, False: 0]
  ------------------
  246|    431|        (reader->ctxt->freeAttrsNr < MAX_FREE_NODES)) {
  ------------------
  |  |   52|    431|#define MAX_FREE_NODES 1
  ------------------
  |  Branch (246:9): [True: 99, False: 332]
  ------------------
  247|     99|        cur->next = reader->ctxt->freeAttrs;
  248|     99|	reader->ctxt->freeAttrs = cur;
  249|     99|	reader->ctxt->freeAttrsNr++;
  250|    332|    } else {
  251|    332|	xmlFree(cur);
  252|    332|    }
  253|    431|}
xmlreader.c:xmlTextReaderFreeNodeList:
  282|    537|xmlTextReaderFreeNodeList(xmlTextReaderPtr reader, xmlNodePtr cur) {
  283|    537|    xmlNodePtr next;
  284|    537|    xmlNodePtr parent;
  285|    537|    xmlDictPtr dict;
  286|    537|    size_t depth = 0;
  287|       |
  288|    537|    if ((reader != NULL) && (reader->ctxt != NULL))
  ------------------
  |  Branch (288:9): [True: 537, False: 0]
  |  Branch (288:29): [True: 537, False: 0]
  ------------------
  289|    537|	dict = reader->ctxt->dict;
  290|      0|    else
  291|      0|        dict = NULL;
  292|    537|    if (cur == NULL) return;
  ------------------
  |  Branch (292:9): [True: 0, False: 537]
  ------------------
  293|    537|    if (cur->type == XML_NAMESPACE_DECL) {
  ------------------
  |  Branch (293:9): [True: 0, False: 537]
  ------------------
  294|      0|	xmlFreeNsList((xmlNsPtr) cur);
  295|      0|	return;
  296|      0|    }
  297|    537|    if ((cur->type == XML_DOCUMENT_NODE) ||
  ------------------
  |  Branch (297:9): [True: 0, False: 537]
  ------------------
  298|    537|	(cur->type == XML_HTML_DOCUMENT_NODE)) {
  ------------------
  |  Branch (298:2): [True: 0, False: 537]
  ------------------
  299|      0|	xmlFreeDoc((xmlDocPtr) cur);
  300|      0|	return;
  301|      0|    }
  302|  1.05k|    while (1) {
  ------------------
  |  Branch (302:12): [Folded - Ignored]
  ------------------
  303|  1.23k|        while ((cur->type != XML_DTD_NODE) &&
  ------------------
  |  Branch (303:16): [True: 1.23k, False: 0]
  ------------------
  304|  1.23k|               (cur->type != XML_ENTITY_REF_NODE) &&
  ------------------
  |  Branch (304:16): [True: 1.23k, False: 0]
  ------------------
  305|  1.23k|               (cur->children != NULL) &&
  ------------------
  |  Branch (305:16): [True: 184, False: 1.05k]
  ------------------
  306|  1.23k|               (cur->children->parent == cur)) {
  ------------------
  |  Branch (306:16): [True: 184, False: 0]
  ------------------
  307|    184|            cur = cur->children;
  308|    184|            depth += 1;
  309|    184|        }
  310|       |
  311|  1.05k|        next = cur->next;
  312|  1.05k|        parent = cur->parent;
  313|       |
  314|       |	/* unroll to speed up freeing the document */
  315|  1.05k|	if (cur->type != XML_DTD_NODE) {
  ------------------
  |  Branch (315:6): [True: 1.05k, False: 0]
  ------------------
  316|       |
  317|  1.05k|	    if ((__xmlRegisterCallbacks) && (xmlDeregisterNodeDefaultValue))
  ------------------
  |  |  684|      0|    XML_GLOBAL_MACRO(xmlDeregisterNodeDefaultValue)
  |  |  ------------------
  |  |  |  |  500|      0|  #define XML_GLOBAL_MACRO(name) (*__##name())
  |  |  ------------------
  ------------------
  |  Branch (317:10): [True: 0, False: 1.05k]
  |  Branch (317:38): [True: 0, False: 0]
  ------------------
  318|      0|		xmlDeregisterNodeDefaultValue(cur);
  ------------------
  |  |  684|      0|    XML_GLOBAL_MACRO(xmlDeregisterNodeDefaultValue)
  |  |  ------------------
  |  |  |  |  500|      0|  #define XML_GLOBAL_MACRO(name) (*__##name())
  |  |  ------------------
  ------------------
  319|       |
  320|  1.05k|	    if (((cur->type == XML_ELEMENT_NODE) ||
  ------------------
  |  Branch (320:11): [True: 253, False: 798]
  ------------------
  321|  1.05k|		 (cur->type == XML_XINCLUDE_START) ||
  ------------------
  |  Branch (321:4): [True: 26, False: 772]
  ------------------
  322|  1.05k|		 (cur->type == XML_XINCLUDE_END)) &&
  ------------------
  |  Branch (322:4): [True: 5, False: 767]
  ------------------
  323|  1.05k|		(cur->properties != NULL))
  ------------------
  |  Branch (323:3): [True: 74, False: 210]
  ------------------
  324|     74|		xmlTextReaderFreePropList(reader, cur->properties);
  325|  1.05k|	    if ((cur->content != (xmlChar *) &(cur->properties)) &&
  ------------------
  |  Branch (325:10): [True: 492, False: 559]
  ------------------
  326|  1.05k|	        (cur->type != XML_ELEMENT_NODE) &&
  ------------------
  |  Branch (326:10): [True: 239, False: 253]
  ------------------
  327|  1.05k|		(cur->type != XML_XINCLUDE_START) &&
  ------------------
  |  Branch (327:3): [True: 213, False: 26]
  ------------------
  328|  1.05k|		(cur->type != XML_XINCLUDE_END) &&
  ------------------
  |  Branch (328:3): [True: 208, False: 5]
  ------------------
  329|  1.05k|		(cur->type != XML_ENTITY_REF_NODE)) {
  ------------------
  |  Branch (329:3): [True: 208, False: 0]
  ------------------
  330|    208|		DICT_FREE(cur->content);
  ------------------
  |  |  214|    208|	if ((str) && ((!dict) ||				\
  |  |  ------------------
  |  |  |  Branch (214:6): [True: 208, False: 0]
  |  |  |  Branch (214:16): [True: 0, False: 208]
  |  |  ------------------
  |  |  215|    208|	    (xmlDictOwns(dict, (const xmlChar *)(str)) == 0)))	\
  |  |  ------------------
  |  |  |  Branch (215:6): [True: 205, False: 3]
  |  |  ------------------
  |  |  216|    208|	    xmlFree((char *)(str));
  ------------------
  331|    208|	    }
  332|  1.05k|	    if (((cur->type == XML_ELEMENT_NODE) ||
  ------------------
  |  Branch (332:11): [True: 253, False: 798]
  ------------------
  333|  1.05k|	         (cur->type == XML_XINCLUDE_START) ||
  ------------------
  |  Branch (333:11): [True: 26, False: 772]
  ------------------
  334|  1.05k|		 (cur->type == XML_XINCLUDE_END)) &&
  ------------------
  |  Branch (334:4): [True: 5, False: 767]
  ------------------
  335|  1.05k|		(cur->nsDef != NULL))
  ------------------
  |  Branch (335:3): [True: 98, False: 186]
  ------------------
  336|     98|		xmlFreeNsList(cur->nsDef);
  337|       |
  338|       |	    /*
  339|       |	     * we don't free element names here they are interned now
  340|       |	     */
  341|  1.05k|	    if ((cur->type != XML_TEXT_NODE) &&
  ------------------
  |  Branch (341:10): [True: 291, False: 760]
  ------------------
  342|  1.05k|		(cur->type != XML_COMMENT_NODE))
  ------------------
  |  Branch (342:3): [True: 285, False: 6]
  ------------------
  343|    285|		DICT_FREE(cur->name);
  ------------------
  |  |  214|    285|	if ((str) && ((!dict) ||				\
  |  |  ------------------
  |  |  |  Branch (214:6): [True: 285, False: 0]
  |  |  |  Branch (214:16): [True: 0, False: 285]
  |  |  ------------------
  |  |  215|    285|	    (xmlDictOwns(dict, (const xmlChar *)(str)) == 0)))	\
  |  |  ------------------
  |  |  |  Branch (215:6): [True: 2, False: 283]
  |  |  ------------------
  |  |  216|    285|	    xmlFree((char *)(str));
  ------------------
  344|  1.05k|	    if (((cur->type == XML_ELEMENT_NODE) ||
  ------------------
  |  Branch (344:11): [True: 253, False: 798]
  ------------------
  345|  1.05k|		 (cur->type == XML_TEXT_NODE)) &&
  ------------------
  |  Branch (345:4): [True: 760, False: 38]
  ------------------
  346|  1.05k|	        (reader != NULL) && (reader->ctxt != NULL) &&
  ------------------
  |  Branch (346:10): [True: 1.01k, False: 0]
  |  Branch (346:30): [True: 1.01k, False: 0]
  ------------------
  347|  1.05k|		(reader->ctxt->freeElemsNr < MAX_FREE_NODES)) {
  ------------------
  |  |   52|  1.01k|#define MAX_FREE_NODES 1
  ------------------
  |  Branch (347:3): [True: 98, False: 915]
  ------------------
  348|     98|	        cur->next = reader->ctxt->freeElems;
  349|     98|		reader->ctxt->freeElems = cur;
  350|     98|		reader->ctxt->freeElemsNr++;
  351|    953|	    } else {
  352|    953|		xmlFree(cur);
  353|    953|	    }
  354|  1.05k|	}
  355|       |
  356|  1.05k|        if (next != NULL) {
  ------------------
  |  Branch (356:13): [True: 330, False: 721]
  ------------------
  357|    330|	    cur = next;
  358|    721|        } else {
  359|    721|            if ((depth == 0) || (parent == NULL))
  ------------------
  |  Branch (359:17): [True: 537, False: 184]
  |  Branch (359:33): [True: 0, False: 184]
  ------------------
  360|    537|                break;
  361|    184|            depth -= 1;
  362|    184|            cur = parent;
  363|    184|            cur->children = NULL;
  364|    184|        }
  365|  1.05k|    }
  366|    537|}
xmlreader.c:xmlTextReaderFreePropList:
  263|    420|xmlTextReaderFreePropList(xmlTextReaderPtr reader, xmlAttrPtr cur) {
  264|    420|    xmlAttrPtr next;
  265|       |
  266|    851|    while (cur != NULL) {
  ------------------
  |  Branch (266:12): [True: 431, False: 420]
  ------------------
  267|    431|        next = cur->next;
  268|    431|        xmlTextReaderFreeProp(reader, cur);
  269|    431|	cur = next;
  270|    431|    }
  271|    420|}
xmlreader.c:xmlTextReaderDoExpand:
 1078|    472|xmlTextReaderDoExpand(xmlTextReaderPtr reader) {
 1079|    472|    int val;
 1080|       |
 1081|    472|    if ((reader == NULL) || (reader->node == NULL) || (reader->ctxt == NULL))
  ------------------
  |  Branch (1081:9): [True: 0, False: 472]
  |  Branch (1081:29): [True: 0, False: 472]
  |  Branch (1081:55): [True: 0, False: 472]
  ------------------
 1082|      0|        return(-1);
 1083|    486|    do {
 1084|    486|	if (reader->ctxt->instate == XML_PARSER_EOF) return(1);
  ------------------
  |  Branch (1084:6): [True: 140, False: 346]
  ------------------
 1085|       |
 1086|    346|        if (xmlTextReaderGetSuccessor(reader->node) != NULL)
  ------------------
  |  Branch (1086:13): [True: 312, False: 34]
  ------------------
 1087|    312|	    return(1);
 1088|     34|	if (reader->ctxt->nodeNr < reader->depth)
  ------------------
  |  Branch (1088:6): [True: 2, False: 32]
  ------------------
 1089|      2|	    return(1);
 1090|     32|	if (reader->mode == XML_TEXTREADER_MODE_EOF)
  ------------------
  |  Branch (1090:6): [True: 0, False: 32]
  ------------------
 1091|      0|	    return(1);
 1092|     32|	val = xmlTextReaderPushData(reader);
 1093|     32|	if (val < 0){
  ------------------
  |  Branch (1093:6): [True: 18, False: 14]
  ------------------
 1094|     18|	    reader->mode = XML_TEXTREADER_MODE_ERROR;
 1095|     18|	    return(-1);
 1096|     18|	}
 1097|     32|    } while(reader->mode != XML_TEXTREADER_MODE_EOF);
  ------------------
  |  Branch (1097:13): [True: 14, False: 0]
  ------------------
 1098|      0|    return(1);
 1099|    472|}
xmlreader.c:xmlTextReaderGetSuccessor:
 1055|    346|xmlTextReaderGetSuccessor(xmlNodePtr cur) {
 1056|    346|    if (cur == NULL) return(NULL) ; /* ERROR */
  ------------------
  |  Branch (1056:9): [True: 0, False: 346]
  ------------------
 1057|    346|    if (cur->next != NULL) return(cur->next) ;
  ------------------
  |  Branch (1057:9): [True: 8, False: 338]
  ------------------
 1058|    420|    do {
 1059|    420|        cur = cur->parent;
 1060|    420|        if (cur == NULL) break;
  ------------------
  |  Branch (1060:13): [True: 34, False: 386]
  ------------------
 1061|    386|        if (cur->next != NULL) return(cur->next);
  ------------------
  |  Branch (1061:13): [True: 304, False: 82]
  ------------------
 1062|    386|    } while (cur != NULL);
  ------------------
  |  Branch (1062:14): [True: 82, False: 0]
  ------------------
 1063|     34|    return(cur);
 1064|    338|}
xmlreader.c:xmlTextReaderStartElement:
  565|      2|	                  const xmlChar **atts) {
  566|      2|    xmlParserCtxtPtr ctxt = (xmlParserCtxtPtr) ctx;
  567|      2|    xmlTextReaderPtr reader = ctxt->_private;
  568|       |
  569|      2|    if ((reader != NULL) && (reader->startElement != NULL)) {
  ------------------
  |  Branch (569:9): [True: 2, False: 0]
  |  Branch (569:29): [True: 2, False: 0]
  ------------------
  570|      2|	reader->startElement(ctx, fullname, atts);
  571|      2|	if ((ctxt->node != NULL) && (ctxt->input != NULL) &&
  ------------------
  |  Branch (571:6): [True: 2, False: 0]
  |  Branch (571:30): [True: 2, False: 0]
  ------------------
  572|      2|	    (ctxt->input->cur != NULL) && (ctxt->input->cur[0] == '/') &&
  ------------------
  |  Branch (572:6): [True: 2, False: 0]
  |  Branch (572:36): [True: 1, False: 1]
  ------------------
  573|      2|	    (ctxt->input->cur[1] == '>'))
  ------------------
  |  Branch (573:6): [True: 1, False: 0]
  ------------------
  574|      1|	    ctxt->node->extra = NODE_IS_EMPTY;
  ------------------
  |  |  186|      1|#define NODE_IS_EMPTY		0x1
  ------------------
  575|      2|    }
  576|      2|    if (reader != NULL)
  ------------------
  |  Branch (576:9): [True: 2, False: 0]
  ------------------
  577|      2|	reader->state = XML_TEXTREADER_ELEMENT;
  578|      2|}
xmlreader.c:xmlTextReaderEndElement:
  588|      2|xmlTextReaderEndElement(void *ctx, const xmlChar *fullname) {
  589|      2|    xmlParserCtxtPtr ctxt = (xmlParserCtxtPtr) ctx;
  590|      2|    xmlTextReaderPtr reader = ctxt->_private;
  591|       |
  592|      2|    if ((reader != NULL) && (reader->endElement != NULL)) {
  ------------------
  |  Branch (592:9): [True: 2, False: 0]
  |  Branch (592:29): [True: 2, False: 0]
  ------------------
  593|      2|	reader->endElement(ctx, fullname);
  594|      2|    }
  595|      2|}
xmlreader.c:xmlTextReaderStartElementNs:
  622|  1.06k|{
  623|  1.06k|    xmlParserCtxtPtr ctxt = (xmlParserCtxtPtr) ctx;
  624|  1.06k|    xmlTextReaderPtr reader = ctxt->_private;
  625|       |
  626|  1.06k|    if ((reader != NULL) && (reader->startElementNs != NULL)) {
  ------------------
  |  Branch (626:9): [True: 1.06k, False: 0]
  |  Branch (626:29): [True: 1.06k, False: 0]
  ------------------
  627|  1.06k|	reader->startElementNs(ctx, localname, prefix, URI, nb_namespaces,
  628|  1.06k|	                       namespaces, nb_attributes, nb_defaulted,
  629|  1.06k|			       attributes);
  630|  1.06k|	if ((ctxt->node != NULL) && (ctxt->input != NULL) &&
  ------------------
  |  Branch (630:6): [True: 1.06k, False: 0]
  |  Branch (630:30): [True: 1.06k, False: 0]
  ------------------
  631|  1.06k|	    (ctxt->input->cur != NULL) && (ctxt->input->cur[0] == '/') &&
  ------------------
  |  Branch (631:6): [True: 1.06k, False: 0]
  |  Branch (631:36): [True: 417, False: 646]
  ------------------
  632|  1.06k|	    (ctxt->input->cur[1] == '>'))
  ------------------
  |  Branch (632:6): [True: 417, False: 0]
  ------------------
  633|    417|	    ctxt->node->extra = NODE_IS_EMPTY;
  ------------------
  |  |  186|    417|#define NODE_IS_EMPTY		0x1
  ------------------
  634|  1.06k|    }
  635|  1.06k|    if (reader != NULL)
  ------------------
  |  Branch (635:9): [True: 1.06k, False: 0]
  ------------------
  636|  1.06k|	reader->state = XML_TEXTREADER_ELEMENT;
  637|  1.06k|}
xmlreader.c:xmlTextReaderEndElementNs:
  653|    909|{
  654|    909|    xmlParserCtxtPtr ctxt = (xmlParserCtxtPtr) ctx;
  655|    909|    xmlTextReaderPtr reader = ctxt->_private;
  656|       |
  657|    909|    if ((reader != NULL) && (reader->endElementNs != NULL)) {
  ------------------
  |  Branch (657:9): [True: 909, False: 0]
  |  Branch (657:29): [True: 909, False: 0]
  ------------------
  658|    909|	reader->endElementNs(ctx, localname, prefix, URI);
  659|    909|    }
  660|    909|}
xmlreader.c:xmlTextReaderCharacters:
  673|    878|{
  674|    878|    xmlParserCtxtPtr ctxt = (xmlParserCtxtPtr) ctx;
  675|    878|    xmlTextReaderPtr reader = ctxt->_private;
  676|       |
  677|    878|    if ((reader != NULL) && (reader->characters != NULL)) {
  ------------------
  |  Branch (677:9): [True: 878, False: 0]
  |  Branch (677:29): [True: 878, False: 0]
  ------------------
  678|    878|	reader->characters(ctx, ch, len);
  679|    878|    }
  680|    878|}
xmlreader.c:xmlTextReaderFreeDoc:
  452|    160|xmlTextReaderFreeDoc(xmlTextReaderPtr reader, xmlDocPtr cur) {
  453|    160|    xmlDtdPtr extSubset, intSubset;
  454|       |
  455|    160|    if (cur == NULL) return;
  ------------------
  |  Branch (455:9): [True: 0, False: 160]
  ------------------
  456|       |
  457|    160|    if ((__xmlRegisterCallbacks) && (xmlDeregisterNodeDefaultValue))
  ------------------
  |  |  684|      0|    XML_GLOBAL_MACRO(xmlDeregisterNodeDefaultValue)
  |  |  ------------------
  |  |  |  |  500|      0|  #define XML_GLOBAL_MACRO(name) (*__##name())
  |  |  ------------------
  ------------------
  |  Branch (457:9): [True: 0, False: 160]
  |  Branch (457:37): [True: 0, False: 0]
  ------------------
  458|      0|	xmlDeregisterNodeDefaultValue((xmlNodePtr) cur);
  ------------------
  |  |  684|      0|    XML_GLOBAL_MACRO(xmlDeregisterNodeDefaultValue)
  |  |  ------------------
  |  |  |  |  500|      0|  #define XML_GLOBAL_MACRO(name) (*__##name())
  |  |  ------------------
  ------------------
  459|       |
  460|       |    /*
  461|       |     * Do this before freeing the children list to avoid ID lookups
  462|       |     */
  463|    160|    if (cur->ids != NULL) xmlFreeIDTable((xmlIDTablePtr) cur->ids);
  ------------------
  |  Branch (463:9): [True: 9, False: 151]
  ------------------
  464|    160|    cur->ids = NULL;
  465|    160|    if (cur->refs != NULL) xmlFreeRefTable((xmlRefTablePtr) cur->refs);
  ------------------
  |  Branch (465:9): [True: 0, False: 160]
  ------------------
  466|    160|    cur->refs = NULL;
  467|    160|    extSubset = cur->extSubset;
  468|    160|    intSubset = cur->intSubset;
  469|    160|    if (intSubset == extSubset)
  ------------------
  |  Branch (469:9): [True: 157, False: 3]
  ------------------
  470|    157|	extSubset = NULL;
  471|    160|    if (extSubset != NULL) {
  ------------------
  |  Branch (471:9): [True: 0, False: 160]
  ------------------
  472|      0|	xmlUnlinkNode((xmlNodePtr) cur->extSubset);
  473|      0|	cur->extSubset = NULL;
  474|      0|	xmlFreeDtd(extSubset);
  475|      0|    }
  476|    160|    if (intSubset != NULL) {
  ------------------
  |  Branch (476:9): [True: 3, False: 157]
  ------------------
  477|      3|	xmlUnlinkNode((xmlNodePtr) cur->intSubset);
  478|      3|	cur->intSubset = NULL;
  479|      3|	xmlFreeDtd(intSubset);
  480|      3|    }
  481|       |
  482|    160|    if (cur->children != NULL) xmlTextReaderFreeNodeList(reader, cur->children);
  ------------------
  |  Branch (482:9): [True: 86, False: 74]
  ------------------
  483|       |
  484|    160|    if (cur->version != NULL) xmlFree((char *) cur->version);
  ------------------
  |  Branch (484:9): [True: 160, False: 0]
  ------------------
  485|    160|    if (cur->name != NULL) xmlFree((char *) cur->name);
  ------------------
  |  Branch (485:9): [True: 0, False: 160]
  ------------------
  486|    160|    if (cur->encoding != NULL) xmlFree((char *) cur->encoding);
  ------------------
  |  Branch (486:9): [True: 7, False: 153]
  ------------------
  487|    160|    if (cur->oldNs != NULL) xmlFreeNsList(cur->oldNs);
  ------------------
  |  Branch (487:9): [True: 15, False: 145]
  ------------------
  488|    160|    if (cur->URL != NULL) xmlFree((char *) cur->URL);
  ------------------
  |  Branch (488:9): [True: 0, False: 160]
  ------------------
  489|    160|    if (cur->dict != NULL) xmlDictFree(cur->dict);
  ------------------
  |  Branch (489:9): [True: 159, False: 1]
  ------------------
  490|       |
  491|    160|    xmlFree(cur);
  492|    160|}

xmlStrndup:
   45|  12.5k|xmlStrndup(const xmlChar *cur, int len) {
   46|  12.5k|    xmlChar *ret;
   47|       |
   48|  12.5k|    if ((cur == NULL) || (len < 0)) return(NULL);
  ------------------
  |  Branch (48:9): [True: 0, False: 12.5k]
  |  Branch (48:26): [True: 0, False: 12.5k]
  ------------------
   49|  12.5k|    ret = (xmlChar *) xmlMallocAtomic((size_t) len + 1);
   50|  12.5k|    if (ret == NULL) {
  ------------------
  |  Branch (50:9): [True: 9, False: 12.5k]
  ------------------
   51|      9|        return(NULL);
   52|      9|    }
   53|  12.5k|    memcpy(ret, cur, len);
   54|  12.5k|    ret[len] = 0;
   55|  12.5k|    return(ret);
   56|  12.5k|}
xmlStrdup:
   69|  15.9k|xmlStrdup(const xmlChar *cur) {
   70|  15.9k|    const xmlChar *p = cur;
   71|       |
   72|  15.9k|    if (cur == NULL) return(NULL);
  ------------------
  |  Branch (72:9): [True: 5.61k, False: 10.3k]
  ------------------
   73|   188k|    while (*p != 0) p++; /* non input consuming */
  ------------------
  |  Branch (73:12): [True: 178k, False: 10.3k]
  ------------------
   74|  10.3k|    return(xmlStrndup(cur, p - cur));
   75|  15.9k|}
xmlCharStrndup:
   88|    386|xmlCharStrndup(const char *cur, int len) {
   89|    386|    int i;
   90|    386|    xmlChar *ret;
   91|       |
   92|    386|    if ((cur == NULL) || (len < 0)) return(NULL);
  ------------------
  |  Branch (92:9): [True: 0, False: 386]
  |  Branch (92:26): [True: 0, False: 386]
  ------------------
   93|    386|    ret = (xmlChar *) xmlMallocAtomic((size_t) len + 1);
   94|    386|    if (ret == NULL) {
  ------------------
  |  Branch (94:9): [True: 0, False: 386]
  ------------------
   95|      0|        return(NULL);
   96|      0|    }
   97|  2.65k|    for (i = 0;i < len;i++) {
  ------------------
  |  Branch (97:16): [True: 2.26k, False: 386]
  ------------------
   98|       |        /* Explicit sign change */
   99|  2.26k|        ret[i] = (xmlChar) cur[i];
  100|  2.26k|        if (ret[i] == 0) return(ret);
  ------------------
  |  Branch (100:13): [True: 0, False: 2.26k]
  ------------------
  101|  2.26k|    }
  102|    386|    ret[len] = 0;
  103|    386|    return(ret);
  104|    386|}
xmlCharStrdup:
  116|    386|xmlCharStrdup(const char *cur) {
  117|    386|    const char *p = cur;
  118|       |
  119|    386|    if (cur == NULL) return(NULL);
  ------------------
  |  Branch (119:9): [True: 0, False: 386]
  ------------------
  120|  2.65k|    while (*p != '\0') p++; /* non input consuming */
  ------------------
  |  Branch (120:12): [True: 2.26k, False: 386]
  ------------------
  121|    386|    return(xmlCharStrndup(cur, p - cur));
  122|    386|}
xmlStrcmp:
  135|     10|xmlStrcmp(const xmlChar *str1, const xmlChar *str2) {
  136|     10|    if (str1 == str2) return(0);
  ------------------
  |  Branch (136:9): [True: 0, False: 10]
  ------------------
  137|     10|    if (str1 == NULL) return(-1);
  ------------------
  |  Branch (137:9): [True: 0, False: 10]
  ------------------
  138|     10|    if (str2 == NULL) return(1);
  ------------------
  |  Branch (138:9): [True: 0, False: 10]
  ------------------
  139|     10|#ifdef FUZZING_BUILD_MODE_UNSAFE_FOR_PRODUCTION
  140|     10|    return(strcmp((const char *)str1, (const char *)str2));
  141|       |#else
  142|       |    do {
  143|       |        int tmp = *str1++ - *str2;
  144|       |        if (tmp != 0) return(tmp);
  145|       |    } while (*str2++ != 0);
  146|       |    return 0;
  147|       |#endif
  148|     10|}
xmlStrEqual:
  162|  13.6k|xmlStrEqual(const xmlChar *str1, const xmlChar *str2) {
  163|  13.6k|    if (str1 == str2) return(1);
  ------------------
  |  Branch (163:9): [True: 99, False: 13.5k]
  ------------------
  164|  13.5k|    if (str1 == NULL) return(0);
  ------------------
  |  Branch (164:9): [True: 0, False: 13.5k]
  ------------------
  165|  13.5k|    if (str2 == NULL) return(0);
  ------------------
  |  Branch (165:9): [True: 138, False: 13.3k]
  ------------------
  166|  13.3k|#ifdef FUZZING_BUILD_MODE_UNSAFE_FOR_PRODUCTION
  167|  13.3k|    return(strcmp((const char *)str1, (const char *)str2) == 0);
  168|       |#else
  169|       |    do {
  170|       |        if (*str1++ != *str2) return(0);
  171|       |    } while (*str2++);
  172|       |    return(1);
  173|       |#endif
  174|  13.5k|}
xmlStrQEqual:
  188|     54|xmlStrQEqual(const xmlChar *pref, const xmlChar *name, const xmlChar *str) {
  189|     54|    if (pref == NULL) return(xmlStrEqual(name, str));
  ------------------
  |  Branch (189:9): [True: 54, False: 0]
  ------------------
  190|      0|    if (name == NULL) return(0);
  ------------------
  |  Branch (190:9): [True: 0, False: 0]
  ------------------
  191|      0|    if (str == NULL) return(0);
  ------------------
  |  Branch (191:9): [True: 0, False: 0]
  ------------------
  192|       |
  193|      0|    do {
  194|      0|        if (*pref++ != *str) return(0);
  ------------------
  |  Branch (194:13): [True: 0, False: 0]
  ------------------
  195|      0|    } while ((*str++) && (*pref));
  ------------------
  |  Branch (195:14): [True: 0, False: 0]
  |  Branch (195:26): [True: 0, False: 0]
  ------------------
  196|      0|    if (*str++ != ':') return(0);
  ------------------
  |  Branch (196:9): [True: 0, False: 0]
  ------------------
  197|      0|    do {
  198|      0|        if (*name++ != *str) return(0);
  ------------------
  |  Branch (198:13): [True: 0, False: 0]
  ------------------
  199|      0|    } while (*str++);
  ------------------
  |  Branch (199:14): [True: 0, False: 0]
  ------------------
  200|      0|    return(1);
  201|      0|}
xmlStrncmp:
  215|      9|xmlStrncmp(const xmlChar *str1, const xmlChar *str2, int len) {
  216|      9|    if (len <= 0) return(0);
  ------------------
  |  Branch (216:9): [True: 0, False: 9]
  ------------------
  217|      9|    if (str1 == str2) return(0);
  ------------------
  |  Branch (217:9): [True: 0, False: 9]
  ------------------
  218|      9|    if (str1 == NULL) return(-1);
  ------------------
  |  Branch (218:9): [True: 0, False: 9]
  ------------------
  219|      9|    if (str2 == NULL) return(1);
  ------------------
  |  Branch (219:9): [True: 0, False: 9]
  ------------------
  220|      9|#ifdef FUZZING_BUILD_MODE_UNSAFE_FOR_PRODUCTION
  221|      9|    return(strncmp((const char *)str1, (const char *)str2, len));
  222|       |#else
  223|       |    do {
  224|       |        int tmp = *str1++ - *str2;
  225|       |        if (tmp != 0 || --len == 0) return(tmp);
  226|       |    } while (*str2++ != 0);
  227|       |    return 0;
  228|       |#endif
  229|      9|}
xmlStrcasecmp:
  277|     28|xmlStrcasecmp(const xmlChar *str1, const xmlChar *str2) {
  278|     28|    register int tmp;
  279|       |
  280|     28|    if (str1 == str2) return(0);
  ------------------
  |  Branch (280:9): [True: 14, False: 14]
  ------------------
  281|     14|    if (str1 == NULL) return(-1);
  ------------------
  |  Branch (281:9): [True: 0, False: 14]
  ------------------
  282|     14|    if (str2 == NULL) return(1);
  ------------------
  |  Branch (282:9): [True: 0, False: 14]
  ------------------
  283|     14|    do {
  284|     14|        tmp = casemap[*str1++] - casemap[*str2];
  285|     14|        if (tmp != 0) return(tmp);
  ------------------
  |  Branch (285:13): [True: 14, False: 0]
  ------------------
  286|     14|    } while (*str2++ != 0);
  ------------------
  |  Branch (286:14): [True: 0, False: 0]
  ------------------
  287|      0|    return 0;
  288|     14|}
xmlStrncasecmp:
  302|    240|xmlStrncasecmp(const xmlChar *str1, const xmlChar *str2, int len) {
  303|    240|    register int tmp;
  304|       |
  305|    240|    if (len <= 0) return(0);
  ------------------
  |  Branch (305:9): [True: 0, False: 240]
  ------------------
  306|    240|    if (str1 == str2) return(0);
  ------------------
  |  Branch (306:9): [True: 0, False: 240]
  ------------------
  307|    240|    if (str1 == NULL) return(-1);
  ------------------
  |  Branch (307:9): [True: 0, False: 240]
  ------------------
  308|    240|    if (str2 == NULL) return(1);
  ------------------
  |  Branch (308:9): [True: 0, False: 240]
  ------------------
  309|    240|    do {
  310|    240|        tmp = casemap[*str1++] - casemap[*str2];
  311|    240|        if (tmp != 0 || --len == 0) return(tmp);
  ------------------
  |  Branch (311:13): [True: 240, False: 0]
  |  Branch (311:25): [True: 0, False: 0]
  ------------------
  312|    240|    } while (*str2++ != 0);
  ------------------
  |  Branch (312:14): [True: 0, False: 0]
  ------------------
  313|      0|    return 0;
  314|    240|}
xmlStrchr:
  327|    435|xmlStrchr(const xmlChar *str, xmlChar val) {
  328|    435|    if (str == NULL) return(NULL);
  ------------------
  |  Branch (328:9): [True: 0, False: 435]
  ------------------
  329|  1.93k|    while (*str != 0) { /* non input consuming */
  ------------------
  |  Branch (329:12): [True: 1.54k, False: 397]
  ------------------
  330|  1.54k|        if (*str == val) return((xmlChar *) str);
  ------------------
  |  Branch (330:13): [True: 38, False: 1.50k]
  ------------------
  331|  1.50k|        str++;
  332|  1.50k|    }
  333|    397|    return(NULL);
  334|    435|}
xmlStrstr:
  347|      8|xmlStrstr(const xmlChar *str, const xmlChar *val) {
  348|      8|    int n;
  349|       |
  350|      8|    if (str == NULL) return(NULL);
  ------------------
  |  Branch (350:9): [True: 0, False: 8]
  ------------------
  351|      8|    if (val == NULL) return(NULL);
  ------------------
  |  Branch (351:9): [True: 0, False: 8]
  ------------------
  352|      8|    n = xmlStrlen(val);
  353|       |
  354|      8|    if (n == 0) return(str);
  ------------------
  |  Branch (354:9): [True: 0, False: 8]
  ------------------
  355|    572|    while (*str != 0) { /* non input consuming */
  ------------------
  |  Branch (355:12): [True: 567, False: 5]
  ------------------
  356|    567|        if (*str == *val) {
  ------------------
  |  Branch (356:13): [True: 9, False: 558]
  ------------------
  357|      9|            if (!xmlStrncmp(str, val, n)) return((const xmlChar *) str);
  ------------------
  |  Branch (357:17): [True: 3, False: 6]
  ------------------
  358|      9|        }
  359|    564|        str++;
  360|    564|    }
  361|      5|    return(NULL);
  362|      8|}
xmlStrlen:
  428|  2.07k|xmlStrlen(const xmlChar *str) {
  429|  2.07k|    size_t len = str ? strlen((const char *)str) : 0;
  ------------------
  |  Branch (429:18): [True: 2.07k, False: 0]
  ------------------
  430|  2.07k|    return(len > INT_MAX ? 0 : len);
  ------------------
  |  Branch (430:12): [True: 0, False: 2.07k]
  ------------------
  431|  2.07k|}
xmlStrncat:
  448|     52|xmlStrncat(xmlChar *cur, const xmlChar *add, int len) {
  449|     52|    int size;
  450|     52|    xmlChar *ret;
  451|       |
  452|     52|    if ((add == NULL) || (len == 0))
  ------------------
  |  Branch (452:9): [True: 0, False: 52]
  |  Branch (452:26): [True: 0, False: 52]
  ------------------
  453|      0|        return(cur);
  454|     52|    if (len < 0)
  ------------------
  |  Branch (454:9): [True: 0, False: 52]
  ------------------
  455|      0|	return(NULL);
  456|     52|    if (cur == NULL)
  ------------------
  |  Branch (456:9): [True: 0, False: 52]
  ------------------
  457|      0|        return(xmlStrndup(add, len));
  458|       |
  459|     52|    size = xmlStrlen(cur);
  460|     52|    if ((size < 0) || (size > INT_MAX - len))
  ------------------
  |  Branch (460:9): [True: 0, False: 52]
  |  Branch (460:23): [True: 0, False: 52]
  ------------------
  461|      0|        return(NULL);
  462|     52|    ret = (xmlChar *) xmlRealloc(cur, (size_t) size + len + 1);
  463|     52|    if (ret == NULL) {
  ------------------
  |  Branch (463:9): [True: 0, False: 52]
  ------------------
  464|      0|        return(cur);
  465|      0|    }
  466|     52|    memcpy(&ret[size], add, len);
  467|     52|    ret[size + len] = 0;
  468|     52|    return(ret);
  469|     52|}
xmlStrncatNew:
  484|      8|xmlStrncatNew(const xmlChar *str1, const xmlChar *str2, int len) {
  485|      8|    int size;
  486|      8|    xmlChar *ret;
  487|       |
  488|      8|    if (len < 0) {
  ------------------
  |  Branch (488:9): [True: 0, False: 8]
  ------------------
  489|      0|        len = xmlStrlen(str2);
  490|      0|        if (len < 0)
  ------------------
  |  Branch (490:13): [True: 0, False: 0]
  ------------------
  491|      0|            return(NULL);
  492|      0|    }
  493|      8|    if ((str2 == NULL) || (len == 0))
  ------------------
  |  Branch (493:9): [True: 0, False: 8]
  |  Branch (493:27): [True: 0, False: 8]
  ------------------
  494|      0|        return(xmlStrdup(str1));
  495|      8|    if (str1 == NULL)
  ------------------
  |  Branch (495:9): [True: 8, False: 0]
  ------------------
  496|      8|        return(xmlStrndup(str2, len));
  497|       |
  498|      0|    size = xmlStrlen(str1);
  499|      0|    if ((size < 0) || (size > INT_MAX - len))
  ------------------
  |  Branch (499:9): [True: 0, False: 0]
  |  Branch (499:23): [True: 0, False: 0]
  ------------------
  500|      0|        return(NULL);
  501|      0|    ret = (xmlChar *) xmlMalloc((size_t) size + len + 1);
  502|      0|    if (ret == NULL) {
  ------------------
  |  Branch (502:9): [True: 0, False: 0]
  ------------------
  503|      0|        return(xmlStrndup(str1, size));
  504|      0|    }
  505|      0|    memcpy(ret, str1, size);
  506|      0|    memcpy(&ret[size], str2, len);
  507|      0|    ret[size + len] = 0;
  508|      0|    return(ret);
  509|      0|}
xmlStrcat:
  524|     60|xmlStrcat(xmlChar *cur, const xmlChar *add) {
  525|     60|    const xmlChar *p = add;
  526|       |
  527|     60|    if (add == NULL) return(cur);
  ------------------
  |  Branch (527:9): [True: 0, False: 60]
  ------------------
  528|     60|    if (cur == NULL)
  ------------------
  |  Branch (528:9): [True: 8, False: 52]
  ------------------
  529|      8|        return(xmlStrdup(add));
  530|       |
  531|    260|    while (*p != 0) p++; /* non input consuming */
  ------------------
  |  Branch (531:12): [True: 208, False: 52]
  ------------------
  532|     52|    return(xmlStrncat(cur, add, p - add));
  533|     60|}
xmlGetUTF8Char:
  708|  34.1k|xmlGetUTF8Char(const unsigned char *utf, int *len) {
  709|  34.1k|    unsigned int c;
  710|       |
  711|  34.1k|    if (utf == NULL)
  ------------------
  |  Branch (711:9): [True: 0, False: 34.1k]
  ------------------
  712|      0|        goto error;
  713|  34.1k|    if (len == NULL)
  ------------------
  |  Branch (713:9): [True: 0, False: 34.1k]
  ------------------
  714|      0|        goto error;
  715|       |
  716|  34.1k|    c = utf[0];
  717|  34.1k|    if (c < 0x80) {
  ------------------
  |  Branch (717:9): [True: 34.0k, False: 168]
  ------------------
  718|  34.0k|        if (*len < 1)
  ------------------
  |  Branch (718:13): [True: 0, False: 34.0k]
  ------------------
  719|      0|            goto error;
  720|       |        /* 1-byte code */
  721|  34.0k|        *len = 1;
  722|  34.0k|    } else {
  723|    168|        if ((*len < 2) || ((utf[1] & 0xc0) != 0x80))
  ------------------
  |  Branch (723:13): [True: 2, False: 166]
  |  Branch (723:27): [True: 116, False: 50]
  ------------------
  724|    118|            goto error;
  725|     50|        if (c < 0xe0) {
  ------------------
  |  Branch (725:13): [True: 50, False: 0]
  ------------------
  726|     50|            if (c < 0xc2)
  ------------------
  |  Branch (726:17): [True: 23, False: 27]
  ------------------
  727|     23|                goto error;
  728|       |            /* 2-byte code */
  729|     27|            *len = 2;
  730|     27|            c = (c & 0x1f) << 6;
  731|     27|            c |= utf[1] & 0x3f;
  732|     27|        } else {
  733|      0|            if ((*len < 3) || ((utf[2] & 0xc0) != 0x80))
  ------------------
  |  Branch (733:17): [True: 0, False: 0]
  |  Branch (733:31): [True: 0, False: 0]
  ------------------
  734|      0|                goto error;
  735|      0|            if (c < 0xf0) {
  ------------------
  |  Branch (735:17): [True: 0, False: 0]
  ------------------
  736|       |                /* 3-byte code */
  737|      0|                *len = 3;
  738|      0|                c = (c & 0xf) << 12;
  739|      0|                c |= (utf[1] & 0x3f) << 6;
  740|      0|                c |= utf[2] & 0x3f;
  741|      0|                if ((c < 0x800) || ((c >= 0xd800) && (c < 0xe000)))
  ------------------
  |  Branch (741:21): [True: 0, False: 0]
  |  Branch (741:37): [True: 0, False: 0]
  |  Branch (741:54): [True: 0, False: 0]
  ------------------
  742|      0|                    goto error;
  743|      0|            } else {
  744|      0|                if ((*len < 4) || ((utf[3] & 0xc0) != 0x80))
  ------------------
  |  Branch (744:21): [True: 0, False: 0]
  |  Branch (744:35): [True: 0, False: 0]
  ------------------
  745|      0|                    goto error;
  746|      0|                *len = 4;
  747|       |                /* 4-byte code */
  748|      0|                c = (c & 0x7) << 18;
  749|      0|                c |= (utf[1] & 0x3f) << 12;
  750|      0|                c |= (utf[2] & 0x3f) << 6;
  751|      0|                c |= utf[3] & 0x3f;
  752|      0|                if ((c < 0x10000) || (c >= 0x110000))
  ------------------
  |  Branch (752:21): [True: 0, False: 0]
  |  Branch (752:38): [True: 0, False: 0]
  ------------------
  753|      0|                    goto error;
  754|      0|            }
  755|      0|        }
  756|     50|    }
  757|  34.0k|    return(c);
  758|       |
  759|    141|error:
  760|    141|    if (len != NULL)
  ------------------
  |  Branch (760:9): [True: 141, False: 0]
  ------------------
  761|    141|	*len = 0;
  762|    141|    return(-1);
  763|  34.1k|}

xmlInitXPathInternal:
  168|      2|xmlInitXPathInternal(void) {
  169|      2|#if defined(NAN) && defined(INFINITY)
  170|      2|    xmlXPathNAN = NAN;
  171|      2|    xmlXPathPINF = INFINITY;
  172|      2|    xmlXPathNINF = -INFINITY;
  173|       |#else
  174|       |    /* MSVC doesn't allow division by zero in constant expressions. */
  175|       |    double zero = 0.0;
  176|       |    xmlXPathNAN = 0.0 / zero;
  177|       |    xmlXPathPINF = 1.0 / zero;
  178|       |    xmlXPathNINF = -xmlXPathPINF;
  179|       |#endif
  180|      2|}
xmlXPathFreeCompExpr:
 1044|    164|{
 1045|    164|    xmlXPathStepOpPtr op;
 1046|    164|    int i;
 1047|       |
 1048|    164|    if (comp == NULL)
  ------------------
  |  Branch (1048:9): [True: 0, False: 164]
  ------------------
 1049|      0|        return;
 1050|    164|    if (comp->dict == NULL) {
  ------------------
  |  Branch (1050:9): [True: 164, False: 0]
  ------------------
 1051|    176|	for (i = 0; i < comp->nbStep; i++) {
  ------------------
  |  Branch (1051:14): [True: 12, False: 164]
  ------------------
 1052|     12|	    op = &comp->steps[i];
 1053|     12|	    if (op->value4 != NULL) {
  ------------------
  |  Branch (1053:10): [True: 2, False: 10]
  ------------------
 1054|      2|		if (op->op == XPATH_OP_VALUE)
  ------------------
  |  Branch (1054:7): [True: 2, False: 0]
  ------------------
 1055|      2|		    xmlXPathFreeObject(op->value4);
 1056|      0|		else
 1057|      0|		    xmlFree(op->value4);
 1058|      2|	    }
 1059|     12|	    if (op->value5 != NULL)
  ------------------
  |  Branch (1059:10): [True: 4, False: 8]
  ------------------
 1060|      4|		xmlFree(op->value5);
 1061|     12|	}
 1062|    164|    } else {
 1063|      0|	for (i = 0; i < comp->nbStep; i++) {
  ------------------
  |  Branch (1063:14): [True: 0, False: 0]
  ------------------
 1064|      0|	    op = &comp->steps[i];
 1065|      0|	    if (op->value4 != NULL) {
  ------------------
  |  Branch (1065:10): [True: 0, False: 0]
  ------------------
 1066|      0|		if (op->op == XPATH_OP_VALUE)
  ------------------
  |  Branch (1066:7): [True: 0, False: 0]
  ------------------
 1067|      0|		    xmlXPathFreeObject(op->value4);
 1068|      0|	    }
 1069|      0|	}
 1070|      0|        xmlDictFree(comp->dict);
 1071|      0|    }
 1072|    164|    if (comp->steps != NULL) {
  ------------------
  |  Branch (1072:9): [True: 164, False: 0]
  ------------------
 1073|    164|        xmlFree(comp->steps);
 1074|    164|    }
 1075|    164|#ifdef XPATH_STREAMING
 1076|    164|    if (comp->stream != NULL) {
  ------------------
  |  Branch (1076:9): [True: 0, False: 164]
  ------------------
 1077|      0|        xmlFreePatternList(comp->stream);
 1078|      0|    }
 1079|    164|#endif
 1080|    164|    if (comp->expr != NULL) {
  ------------------
  |  Branch (1080:9): [True: 0, False: 164]
  ------------------
 1081|      0|        xmlFree(comp->expr);
 1082|      0|    }
 1083|       |
 1084|    164|    xmlFree(comp);
 1085|    164|}
valuePop:
 2265|    174|{
 2266|    174|    xmlXPathObjectPtr ret;
 2267|       |
 2268|    174|    if ((ctxt == NULL) || (ctxt->valueNr <= 0))
  ------------------
  |  Branch (2268:9): [True: 0, False: 174]
  |  Branch (2268:27): [True: 84, False: 90]
  ------------------
 2269|     84|        return (NULL);
 2270|       |
 2271|     90|    ctxt->valueNr--;
 2272|     90|    if (ctxt->valueNr > 0)
  ------------------
  |  Branch (2272:9): [True: 0, False: 90]
  ------------------
 2273|      0|        ctxt->value = ctxt->valueTab[ctxt->valueNr - 1];
 2274|     90|    else
 2275|     90|        ctxt->value = NULL;
 2276|     90|    ret = ctxt->valueTab[ctxt->valueNr];
 2277|     90|    ctxt->valueTab[ctxt->valueNr] = NULL;
 2278|     90|    return (ret);
 2279|    174|}
valuePush:
 2294|     90|{
 2295|     90|    if (ctxt == NULL) return(-1);
  ------------------
  |  Branch (2295:9): [True: 0, False: 90]
  ------------------
 2296|     90|    if (value == NULL) {
  ------------------
  |  Branch (2296:9): [True: 0, False: 90]
  ------------------
 2297|       |        /*
 2298|       |         * A NULL value typically indicates that a memory allocation failed,
 2299|       |         * so we set ctxt->error here to propagate the error.
 2300|       |         */
 2301|      0|	ctxt->error = XPATH_MEMORY_ERROR;
 2302|      0|        return(-1);
 2303|      0|    }
 2304|     90|    if (ctxt->valueNr >= ctxt->valueMax) {
  ------------------
  |  Branch (2304:9): [True: 0, False: 90]
  ------------------
 2305|      0|        xmlXPathObjectPtr *tmp;
 2306|       |
 2307|      0|        if (ctxt->valueMax >= XPATH_MAX_STACK_DEPTH) {
  ------------------
  |  |  106|      0|#define XPATH_MAX_STACK_DEPTH 1000000
  ------------------
  |  Branch (2307:13): [True: 0, False: 0]
  ------------------
 2308|      0|            xmlXPathPErrMemory(ctxt, "XPath stack depth limit reached\n");
 2309|      0|            xmlXPathFreeObject(value);
 2310|      0|            return (-1);
 2311|      0|        }
 2312|      0|        tmp = (xmlXPathObjectPtr *) xmlRealloc(ctxt->valueTab,
 2313|      0|                                             2 * ctxt->valueMax *
 2314|      0|                                             sizeof(ctxt->valueTab[0]));
 2315|      0|        if (tmp == NULL) {
  ------------------
  |  Branch (2315:13): [True: 0, False: 0]
  ------------------
 2316|      0|            xmlXPathPErrMemory(ctxt, "pushing value\n");
 2317|      0|            xmlXPathFreeObject(value);
 2318|      0|            return (-1);
 2319|      0|        }
 2320|      0|        ctxt->valueMax *= 2;
 2321|      0|	ctxt->valueTab = tmp;
 2322|      0|    }
 2323|     90|    ctxt->valueTab[ctxt->valueNr] = value;
 2324|     90|    ctxt->value = value;
 2325|     90|    return (ctxt->valueNr++);
 2326|     90|}
xmlXPathNodeSetCreate:
 2978|     88|xmlXPathNodeSetCreate(xmlNodePtr val) {
 2979|     88|    xmlNodeSetPtr ret;
 2980|       |
 2981|     88|    ret = (xmlNodeSetPtr) xmlMalloc(sizeof(xmlNodeSet));
 2982|     88|    if (ret == NULL) {
  ------------------
  |  Branch (2982:9): [True: 0, False: 88]
  ------------------
 2983|      0|        xmlXPathErrMemory(NULL, "creating nodeset\n");
 2984|      0|	return(NULL);
 2985|      0|    }
 2986|     88|    memset(ret, 0 , sizeof(xmlNodeSet));
 2987|     88|    if (val != NULL) {
  ------------------
  |  Branch (2987:9): [True: 2, False: 86]
  ------------------
 2988|      2|        ret->nodeTab = (xmlNodePtr *) xmlMalloc(XML_NODESET_DEFAULT *
  ------------------
  |  | 2908|      2|#define XML_NODESET_DEFAULT	10
  ------------------
 2989|      2|					     sizeof(xmlNodePtr));
 2990|      2|	if (ret->nodeTab == NULL) {
  ------------------
  |  Branch (2990:6): [True: 0, False: 2]
  ------------------
 2991|      0|	    xmlXPathErrMemory(NULL, "creating nodeset\n");
 2992|      0|	    xmlFree(ret);
 2993|      0|	    return(NULL);
 2994|      0|	}
 2995|      2|	memset(ret->nodeTab, 0 ,
 2996|      2|	       XML_NODESET_DEFAULT * sizeof(xmlNodePtr));
  ------------------
  |  | 2908|      2|#define XML_NODESET_DEFAULT	10
  ------------------
 2997|      2|        ret->nodeMax = XML_NODESET_DEFAULT;
  ------------------
  |  | 2908|      2|#define XML_NODESET_DEFAULT	10
  ------------------
 2998|      2|	if (val->type == XML_NAMESPACE_DECL) {
  ------------------
  |  Branch (2998:6): [True: 0, False: 2]
  ------------------
 2999|      0|	    xmlNsPtr ns = (xmlNsPtr) val;
 3000|      0|            xmlNodePtr nsNode = xmlXPathNodeSetDupNs((xmlNodePtr) ns->next, ns);
 3001|       |
 3002|      0|            if (nsNode == NULL) {
  ------------------
  |  Branch (3002:17): [True: 0, False: 0]
  ------------------
 3003|      0|                xmlXPathFreeNodeSet(ret);
 3004|      0|                return(NULL);
 3005|      0|            }
 3006|      0|	    ret->nodeTab[ret->nodeNr++] = nsNode;
 3007|      0|	} else
 3008|      2|	    ret->nodeTab[ret->nodeNr++] = val;
 3009|      2|    }
 3010|     88|    return(ret);
 3011|     88|}
xmlXPathNodeSetAdd:
 3128|      2|xmlXPathNodeSetAdd(xmlNodeSetPtr cur, xmlNodePtr val) {
 3129|      2|    int i;
 3130|       |
 3131|      2|    if ((cur == NULL) || (val == NULL)) return(-1);
  ------------------
  |  Branch (3131:9): [True: 0, False: 2]
  |  Branch (3131:26): [True: 0, False: 2]
  ------------------
 3132|       |
 3133|       |    /* @@ with_ns to check whether namespace nodes should be looked at @@ */
 3134|       |    /*
 3135|       |     * prevent duplicates
 3136|       |     */
 3137|      2|    for (i = 0;i < cur->nodeNr;i++)
  ------------------
  |  Branch (3137:16): [True: 0, False: 2]
  ------------------
 3138|      0|        if (cur->nodeTab[i] == val) return(0);
  ------------------
  |  Branch (3138:13): [True: 0, False: 0]
  ------------------
 3139|       |
 3140|       |    /*
 3141|       |     * grow the nodeTab if needed
 3142|       |     */
 3143|      2|    if (cur->nodeMax == 0) {
  ------------------
  |  Branch (3143:9): [True: 2, False: 0]
  ------------------
 3144|      2|        cur->nodeTab = (xmlNodePtr *) xmlMalloc(XML_NODESET_DEFAULT *
  ------------------
  |  | 2908|      2|#define XML_NODESET_DEFAULT	10
  ------------------
 3145|      2|					     sizeof(xmlNodePtr));
 3146|      2|	if (cur->nodeTab == NULL) {
  ------------------
  |  Branch (3146:6): [True: 0, False: 2]
  ------------------
 3147|      0|	    xmlXPathErrMemory(NULL, "growing nodeset\n");
 3148|      0|	    return(-1);
 3149|      0|	}
 3150|      2|	memset(cur->nodeTab, 0 ,
 3151|      2|	       XML_NODESET_DEFAULT * sizeof(xmlNodePtr));
  ------------------
  |  | 2908|      2|#define XML_NODESET_DEFAULT	10
  ------------------
 3152|      2|        cur->nodeMax = XML_NODESET_DEFAULT;
  ------------------
  |  | 2908|      2|#define XML_NODESET_DEFAULT	10
  ------------------
 3153|      2|    } else if (cur->nodeNr == cur->nodeMax) {
  ------------------
  |  Branch (3153:16): [True: 0, False: 0]
  ------------------
 3154|      0|        xmlNodePtr *temp;
 3155|       |
 3156|      0|        if (cur->nodeMax >= XPATH_MAX_NODESET_LENGTH) {
  ------------------
  |  |  116|      0|#define XPATH_MAX_NODESET_LENGTH 10000000
  ------------------
  |  Branch (3156:13): [True: 0, False: 0]
  ------------------
 3157|      0|            xmlXPathErrMemory(NULL, "growing nodeset hit limit\n");
 3158|      0|            return(-1);
 3159|      0|        }
 3160|      0|	temp = (xmlNodePtr *) xmlRealloc(cur->nodeTab, cur->nodeMax * 2 *
 3161|      0|				      sizeof(xmlNodePtr));
 3162|      0|	if (temp == NULL) {
  ------------------
  |  Branch (3162:6): [True: 0, False: 0]
  ------------------
 3163|      0|	    xmlXPathErrMemory(NULL, "growing nodeset\n");
 3164|      0|	    return(-1);
 3165|      0|	}
 3166|      0|        cur->nodeMax *= 2;
 3167|      0|	cur->nodeTab = temp;
 3168|      0|    }
 3169|      2|    if (val->type == XML_NAMESPACE_DECL) {
  ------------------
  |  Branch (3169:9): [True: 0, False: 2]
  ------------------
 3170|      0|	xmlNsPtr ns = (xmlNsPtr) val;
 3171|      0|        xmlNodePtr nsNode = xmlXPathNodeSetDupNs((xmlNodePtr) ns->next, ns);
 3172|       |
 3173|      0|        if (nsNode == NULL)
  ------------------
  |  Branch (3173:13): [True: 0, False: 0]
  ------------------
 3174|      0|            return(-1);
 3175|      0|	cur->nodeTab[cur->nodeNr++] = nsNode;
 3176|      0|    } else
 3177|      2|	cur->nodeTab[cur->nodeNr++] = val;
 3178|      2|    return(0);
 3179|      2|}
xmlXPathNodeSetAddUnique:
 3192|     92|xmlXPathNodeSetAddUnique(xmlNodeSetPtr cur, xmlNodePtr val) {
 3193|     92|    if ((cur == NULL) || (val == NULL)) return(-1);
  ------------------
  |  Branch (3193:9): [True: 0, False: 92]
  |  Branch (3193:26): [True: 0, False: 92]
  ------------------
 3194|       |
 3195|       |    /* @@ with_ns to check whether namespace nodes should be looked at @@ */
 3196|       |    /*
 3197|       |     * grow the nodeTab if needed
 3198|       |     */
 3199|     92|    if (cur->nodeMax == 0) {
  ------------------
  |  Branch (3199:9): [True: 84, False: 8]
  ------------------
 3200|     84|        cur->nodeTab = (xmlNodePtr *) xmlMalloc(XML_NODESET_DEFAULT *
  ------------------
  |  | 2908|     84|#define XML_NODESET_DEFAULT	10
  ------------------
 3201|     84|					     sizeof(xmlNodePtr));
 3202|     84|	if (cur->nodeTab == NULL) {
  ------------------
  |  Branch (3202:6): [True: 0, False: 84]
  ------------------
 3203|      0|	    xmlXPathErrMemory(NULL, "growing nodeset\n");
 3204|      0|	    return(-1);
 3205|      0|	}
 3206|     84|	memset(cur->nodeTab, 0 ,
 3207|     84|	       XML_NODESET_DEFAULT * sizeof(xmlNodePtr));
  ------------------
  |  | 2908|     84|#define XML_NODESET_DEFAULT	10
  ------------------
 3208|     84|        cur->nodeMax = XML_NODESET_DEFAULT;
  ------------------
  |  | 2908|     84|#define XML_NODESET_DEFAULT	10
  ------------------
 3209|     84|    } else if (cur->nodeNr == cur->nodeMax) {
  ------------------
  |  Branch (3209:16): [True: 0, False: 8]
  ------------------
 3210|      0|        xmlNodePtr *temp;
 3211|       |
 3212|      0|        if (cur->nodeMax >= XPATH_MAX_NODESET_LENGTH) {
  ------------------
  |  |  116|      0|#define XPATH_MAX_NODESET_LENGTH 10000000
  ------------------
  |  Branch (3212:13): [True: 0, False: 0]
  ------------------
 3213|      0|            xmlXPathErrMemory(NULL, "growing nodeset hit limit\n");
 3214|      0|            return(-1);
 3215|      0|        }
 3216|      0|	temp = (xmlNodePtr *) xmlRealloc(cur->nodeTab, cur->nodeMax * 2 *
 3217|      0|				      sizeof(xmlNodePtr));
 3218|      0|	if (temp == NULL) {
  ------------------
  |  Branch (3218:6): [True: 0, False: 0]
  ------------------
 3219|      0|	    xmlXPathErrMemory(NULL, "growing nodeset\n");
 3220|      0|	    return(-1);
 3221|      0|	}
 3222|      0|	cur->nodeTab = temp;
 3223|      0|        cur->nodeMax *= 2;
 3224|      0|    }
 3225|     92|    if (val->type == XML_NAMESPACE_DECL) {
  ------------------
  |  Branch (3225:9): [True: 0, False: 92]
  ------------------
 3226|      0|	xmlNsPtr ns = (xmlNsPtr) val;
 3227|      0|        xmlNodePtr nsNode = xmlXPathNodeSetDupNs((xmlNodePtr) ns->next, ns);
 3228|       |
 3229|      0|        if (nsNode == NULL)
  ------------------
  |  Branch (3229:13): [True: 0, False: 0]
  ------------------
 3230|      0|            return(-1);
 3231|      0|	cur->nodeTab[cur->nodeNr++] = nsNode;
 3232|      0|    } else
 3233|     92|	cur->nodeTab[cur->nodeNr++] = val;
 3234|     92|    return(0);
 3235|     92|}
xmlXPathFreeNodeSet:
 3543|     88|xmlXPathFreeNodeSet(xmlNodeSetPtr obj) {
 3544|     88|    if (obj == NULL) return;
  ------------------
  |  Branch (3544:9): [True: 0, False: 88]
  ------------------
 3545|     88|    if (obj->nodeTab != NULL) {
  ------------------
  |  Branch (3545:9): [True: 88, False: 0]
  ------------------
 3546|     88|	int i;
 3547|       |
 3548|       |	/* @@ with_ns to check whether namespace nodes should be looked at @@ */
 3549|    184|	for (i = 0;i < obj->nodeNr;i++)
  ------------------
  |  Branch (3549:13): [True: 96, False: 88]
  ------------------
 3550|     96|	    if ((obj->nodeTab[i] != NULL) &&
  ------------------
  |  Branch (3550:10): [True: 96, False: 0]
  ------------------
 3551|     96|		(obj->nodeTab[i]->type == XML_NAMESPACE_DECL))
  ------------------
  |  Branch (3551:3): [True: 0, False: 96]
  ------------------
 3552|      0|		xmlXPathNodeSetFreeNs((xmlNsPtr) obj->nodeTab[i]);
 3553|     88|	xmlFree(obj->nodeTab);
 3554|     88|    }
 3555|     88|    xmlFree(obj);
 3556|     88|}
xmlXPathNewNodeSet:
 3664|     82|xmlXPathNewNodeSet(xmlNodePtr val) {
 3665|     82|    xmlXPathObjectPtr ret;
 3666|       |
 3667|     82|    ret = (xmlXPathObjectPtr) xmlMalloc(sizeof(xmlXPathObject));
 3668|     82|    if (ret == NULL) {
  ------------------
  |  Branch (3668:9): [True: 0, False: 82]
  ------------------
 3669|      0|        xmlXPathErrMemory(NULL, "creating nodeset\n");
 3670|      0|	return(NULL);
 3671|      0|    }
 3672|     82|    memset(ret, 0 , sizeof(xmlXPathObject));
 3673|     82|    ret->type = XPATH_NODESET;
 3674|     82|    ret->boolval = 0;
 3675|       |    /* TODO: Check memory error. */
 3676|     82|    ret->nodesetval = xmlXPathNodeSetCreate(val);
 3677|       |    /* @@ with_ns to check whether namespace nodes should be looked at @@ */
 3678|     82|    return(ret);
 3679|     82|}
xmlXPathWrapNodeSet:
 3751|      6|xmlXPathWrapNodeSet(xmlNodeSetPtr val) {
 3752|      6|    xmlXPathObjectPtr ret;
 3753|       |
 3754|      6|    ret = (xmlXPathObjectPtr) xmlMalloc(sizeof(xmlXPathObject));
 3755|      6|    if (ret == NULL) {
  ------------------
  |  Branch (3755:9): [True: 0, False: 6]
  ------------------
 3756|      0|        xmlXPathErrMemory(NULL, "creating node set object\n");
 3757|      0|        xmlXPathFreeNodeSet(val);
 3758|      0|	return(NULL);
 3759|      0|    }
 3760|      6|    memset(ret, 0 , sizeof(xmlXPathObject));
 3761|      6|    ret->type = XPATH_NODESET;
 3762|      6|    ret->nodesetval = val;
 3763|      6|    return(ret);
 3764|      6|}
xmlXPathRegisterFunc:
 4184|  2.26k|		     xmlXPathFunction f) {
 4185|  2.26k|    return(xmlXPathRegisterFuncNS(ctxt, name, NULL, f));
 4186|  2.26k|}
xmlXPathRegisterFuncNS:
 4201|  2.35k|		       const xmlChar *ns_uri, xmlXPathFunction f) {
 4202|  2.35k|    if (ctxt == NULL)
  ------------------
  |  Branch (4202:9): [True: 0, False: 2.35k]
  ------------------
 4203|      0|	return(-1);
 4204|  2.35k|    if (name == NULL)
  ------------------
  |  Branch (4204:9): [True: 0, False: 2.35k]
  ------------------
 4205|      0|	return(-1);
 4206|       |
 4207|  2.35k|    if (ctxt->funcHash == NULL)
  ------------------
  |  Branch (4207:9): [True: 0, False: 2.35k]
  ------------------
 4208|      0|	ctxt->funcHash = xmlHashCreate(0);
 4209|  2.35k|    if (ctxt->funcHash == NULL)
  ------------------
  |  Branch (4209:9): [True: 0, False: 2.35k]
  ------------------
 4210|      0|	return(-1);
 4211|  2.35k|    if (f == NULL)
  ------------------
  |  Branch (4211:9): [True: 0, False: 2.35k]
  ------------------
 4212|      0|        return(xmlHashRemoveEntry2(ctxt->funcHash, name, ns_uri, NULL));
 4213|  2.35k|XML_IGNORE_FPTR_CAST_WARNINGS
 4214|  2.35k|    return(xmlHashAddEntry2(ctxt->funcHash, name, ns_uri, (void *) f));
 4215|  2.35k|XML_POP_WARNINGS
 4216|  2.35k|}
xmlXPathRegisteredFuncsCleanup:
 4309|     84|xmlXPathRegisteredFuncsCleanup(xmlXPathContextPtr ctxt) {
 4310|     84|    if (ctxt == NULL)
  ------------------
  |  Branch (4310:9): [True: 0, False: 84]
  ------------------
 4311|      0|	return;
 4312|       |
 4313|     84|    xmlHashFree(ctxt->funcHash, NULL);
 4314|     84|    ctxt->funcHash = NULL;
 4315|     84|}
xmlXPathRegisteredVariablesCleanup:
 4455|     84|xmlXPathRegisteredVariablesCleanup(xmlXPathContextPtr ctxt) {
 4456|     84|    if (ctxt == NULL)
  ------------------
  |  Branch (4456:9): [True: 0, False: 84]
  ------------------
 4457|      0|	return;
 4458|       |
 4459|     84|    xmlHashFree(ctxt->varHash, xmlXPathFreeObjectEntry);
 4460|     84|    ctxt->varHash = NULL;
 4461|     84|}
xmlXPathRegisteredNsCleanup:
 4548|     84|xmlXPathRegisteredNsCleanup(xmlXPathContextPtr ctxt) {
 4549|     84|    if (ctxt == NULL)
  ------------------
  |  Branch (4549:9): [True: 0, False: 84]
  ------------------
 4550|      0|	return;
 4551|       |
 4552|     84|    xmlHashFree(ctxt->nsHash, xmlHashDefaultDeallocator);
 4553|     84|    ctxt->nsHash = NULL;
 4554|     84|}
xmlXPathNewFloat:
 4573|      2|xmlXPathNewFloat(double val) {
 4574|      2|    xmlXPathObjectPtr ret;
 4575|       |
 4576|      2|    ret = (xmlXPathObjectPtr) xmlMalloc(sizeof(xmlXPathObject));
 4577|      2|    if (ret == NULL) {
  ------------------
  |  Branch (4577:9): [True: 0, False: 2]
  ------------------
 4578|      0|        xmlXPathErrMemory(NULL, "creating float object\n");
 4579|      0|	return(NULL);
 4580|      0|    }
 4581|      2|    memset(ret, 0 , sizeof(xmlXPathObject));
 4582|      2|    ret->type = XPATH_NUMBER;
 4583|      2|    ret->floatval = val;
 4584|      2|    return(ret);
 4585|      2|}
xmlXPathNewString:
 4619|      2|xmlXPathNewString(const xmlChar *val) {
 4620|      2|    xmlXPathObjectPtr ret;
 4621|       |
 4622|      2|    ret = (xmlXPathObjectPtr) xmlMalloc(sizeof(xmlXPathObject));
 4623|      2|    if (ret == NULL) {
  ------------------
  |  Branch (4623:9): [True: 0, False: 2]
  ------------------
 4624|      0|        xmlXPathErrMemory(NULL, "creating string object\n");
 4625|      0|	return(NULL);
 4626|      0|    }
 4627|      2|    memset(ret, 0 , sizeof(xmlXPathObject));
 4628|      2|    ret->type = XPATH_STRING;
 4629|      2|    if (val == NULL)
  ------------------
  |  Branch (4629:9): [True: 0, False: 2]
  ------------------
 4630|      0|        val = BAD_CAST "";
  ------------------
  |  |   35|      0|#define BAD_CAST (xmlChar *)
  ------------------
 4631|      2|    ret->stringval = xmlStrdup(val);
 4632|      2|    if (ret->stringval == NULL) {
  ------------------
  |  Branch (4632:9): [True: 0, False: 2]
  ------------------
 4633|      0|        xmlFree(ret);
 4634|      0|        return(NULL);
 4635|      0|    }
 4636|      2|    return(ret);
 4637|      2|}
xmlXPathFreeObject:
 4816|     92|xmlXPathFreeObject(xmlXPathObjectPtr obj) {
 4817|     92|    if (obj == NULL) return;
  ------------------
  |  Branch (4817:9): [True: 0, False: 92]
  ------------------
 4818|     92|    if ((obj->type == XPATH_NODESET) || (obj->type == XPATH_XSLT_TREE)) {
  ------------------
  |  Branch (4818:9): [True: 88, False: 4]
  |  Branch (4818:41): [True: 0, False: 4]
  ------------------
 4819|     88|	if (obj->boolval) {
  ------------------
  |  Branch (4819:6): [True: 0, False: 88]
  ------------------
 4820|       |#if 0
 4821|       |	    if (obj->user != NULL) {
 4822|       |                xmlXPathFreeNodeSet(obj->nodesetval);
 4823|       |		xmlFreeNodeList((xmlNodePtr) obj->user);
 4824|       |	    } else
 4825|       |#endif
 4826|      0|	    obj->type = XPATH_XSLT_TREE; /* TODO: Just for debugging. */
 4827|      0|	    if (obj->nodesetval != NULL)
  ------------------
  |  Branch (4827:10): [True: 0, False: 0]
  ------------------
 4828|      0|		xmlXPathFreeValueTree(obj->nodesetval);
 4829|     88|	} else {
 4830|     88|	    if (obj->nodesetval != NULL)
  ------------------
  |  Branch (4830:10): [True: 88, False: 0]
  ------------------
 4831|     88|		xmlXPathFreeNodeSet(obj->nodesetval);
 4832|     88|	}
 4833|       |#ifdef LIBXML_XPTR_LOCS_ENABLED
 4834|       |    } else if (obj->type == XPATH_LOCATIONSET) {
 4835|       |	if (obj->user != NULL)
 4836|       |	    xmlXPtrFreeLocationSet(obj->user);
 4837|       |#endif
 4838|     88|    } else if (obj->type == XPATH_STRING) {
  ------------------
  |  Branch (4838:16): [True: 2, False: 2]
  ------------------
 4839|      2|	if (obj->stringval != NULL)
  ------------------
  |  Branch (4839:6): [True: 2, False: 0]
  ------------------
 4840|      2|	    xmlFree(obj->stringval);
 4841|      2|    }
 4842|     92|    xmlFree(obj);
 4843|     92|}
xmlXPathNewContext:
 5436|     84|xmlXPathNewContext(xmlDocPtr doc) {
 5437|     84|    xmlXPathContextPtr ret;
 5438|       |
 5439|     84|    ret = (xmlXPathContextPtr) xmlMalloc(sizeof(xmlXPathContext));
 5440|     84|    if (ret == NULL) {
  ------------------
  |  Branch (5440:9): [True: 0, False: 84]
  ------------------
 5441|      0|        xmlXPathErrMemory(NULL, "creating context\n");
 5442|      0|	return(NULL);
 5443|      0|    }
 5444|     84|    memset(ret, 0 , sizeof(xmlXPathContext));
 5445|     84|    ret->doc = doc;
 5446|     84|    ret->node = NULL;
 5447|       |
 5448|     84|    ret->varHash = NULL;
 5449|       |
 5450|     84|    ret->nb_types = 0;
 5451|     84|    ret->max_types = 0;
 5452|     84|    ret->types = NULL;
 5453|       |
 5454|     84|    ret->funcHash = xmlHashCreate(0);
 5455|       |
 5456|     84|    ret->nb_axis = 0;
 5457|     84|    ret->max_axis = 0;
 5458|     84|    ret->axis = NULL;
 5459|       |
 5460|     84|    ret->nsHash = NULL;
 5461|     84|    ret->user = NULL;
 5462|       |
 5463|     84|    ret->contextSize = -1;
 5464|     84|    ret->proximityPosition = -1;
 5465|       |
 5466|       |#ifdef XP_DEFAULT_CACHE_ON
 5467|       |    if (xmlXPathContextSetCache(ret, 1, -1, 0) == -1) {
 5468|       |	xmlXPathFreeContext(ret);
 5469|       |	return(NULL);
 5470|       |    }
 5471|       |#endif
 5472|       |
 5473|     84|    xmlXPathRegisterAllFunctions(ret);
 5474|       |
 5475|     84|    return(ret);
 5476|     84|}
xmlXPathFreeContext:
 5485|     84|xmlXPathFreeContext(xmlXPathContextPtr ctxt) {
 5486|     84|    if (ctxt == NULL) return;
  ------------------
  |  Branch (5486:9): [True: 0, False: 84]
  ------------------
 5487|       |
 5488|     84|    if (ctxt->cache != NULL)
  ------------------
  |  Branch (5488:9): [True: 0, False: 84]
  ------------------
 5489|      0|	xmlXPathFreeCache((xmlXPathContextCachePtr) ctxt->cache);
 5490|     84|    xmlXPathRegisteredNsCleanup(ctxt);
 5491|     84|    xmlXPathRegisteredFuncsCleanup(ctxt);
 5492|     84|    xmlXPathRegisteredVariablesCleanup(ctxt);
 5493|     84|    xmlResetError(&ctxt->lastError);
 5494|     84|    xmlFree(ctxt);
 5495|     84|}
xmlXPathNewParserContext:
 5544|     84|xmlXPathNewParserContext(const xmlChar *str, xmlXPathContextPtr ctxt) {
 5545|     84|    xmlXPathParserContextPtr ret;
 5546|       |
 5547|     84|    ret = (xmlXPathParserContextPtr) xmlMalloc(sizeof(xmlXPathParserContext));
 5548|     84|    if (ret == NULL) {
  ------------------
  |  Branch (5548:9): [True: 0, False: 84]
  ------------------
 5549|      0|        xmlXPathErrMemory(ctxt, "creating parser context\n");
 5550|      0|	return(NULL);
 5551|      0|    }
 5552|     84|    memset(ret, 0 , sizeof(xmlXPathParserContext));
 5553|     84|    ret->cur = ret->base = str;
 5554|     84|    ret->context = ctxt;
 5555|       |
 5556|     84|    ret->comp = xmlXPathNewCompExpr();
 5557|     84|    if (ret->comp == NULL) {
  ------------------
  |  Branch (5557:9): [True: 0, False: 84]
  ------------------
 5558|      0|	xmlFree(ret->valueTab);
 5559|      0|	xmlFree(ret);
 5560|      0|	return(NULL);
 5561|      0|    }
 5562|     84|    if ((ctxt != NULL) && (ctxt->dict != NULL)) {
  ------------------
  |  Branch (5562:9): [True: 84, False: 0]
  |  Branch (5562:27): [True: 0, False: 84]
  ------------------
 5563|      0|        ret->comp->dict = ctxt->dict;
 5564|      0|	xmlDictReference(ret->comp->dict);
 5565|      0|    }
 5566|       |
 5567|     84|    return(ret);
 5568|     84|}
xmlXPathFreeParserContext:
 5615|     84|xmlXPathFreeParserContext(xmlXPathParserContextPtr ctxt) {
 5616|     84|    int i;
 5617|       |
 5618|     84|    if (ctxt->valueTab != NULL) {
  ------------------
  |  Branch (5618:9): [True: 84, False: 0]
  ------------------
 5619|     84|        for (i = 0; i < ctxt->valueNr; i++) {
  ------------------
  |  Branch (5619:21): [True: 0, False: 84]
  ------------------
 5620|      0|            if (ctxt->context)
  ------------------
  |  Branch (5620:17): [True: 0, False: 0]
  ------------------
 5621|      0|                xmlXPathReleaseObject(ctxt->context, ctxt->valueTab[i]);
 5622|      0|            else
 5623|      0|                xmlXPathFreeObject(ctxt->valueTab[i]);
 5624|      0|        }
 5625|     84|        xmlFree(ctxt->valueTab);
 5626|     84|    }
 5627|     84|    if (ctxt->comp != NULL) {
  ------------------
  |  Branch (5627:9): [True: 84, False: 0]
  ------------------
 5628|     84|#ifdef XPATH_STREAMING
 5629|     84|	if (ctxt->comp->stream != NULL) {
  ------------------
  |  Branch (5629:6): [True: 80, False: 4]
  ------------------
 5630|     80|	    xmlFreePatternList(ctxt->comp->stream);
 5631|     80|	    ctxt->comp->stream = NULL;
 5632|     80|	}
 5633|     84|#endif
 5634|     84|	xmlXPathFreeCompExpr(ctxt->comp);
 5635|     84|    }
 5636|     84|    xmlFree(ctxt);
 5637|     84|}
xmlXPathNextChild:
 6943|      2|xmlXPathNextChild(xmlXPathParserContextPtr ctxt, xmlNodePtr cur) {
 6944|      2|    if ((ctxt == NULL) || (ctxt->context == NULL)) return(NULL);
  ------------------
  |  Branch (6944:9): [True: 0, False: 2]
  |  Branch (6944:27): [True: 0, False: 2]
  ------------------
 6945|      2|    if (cur == NULL) {
  ------------------
  |  Branch (6945:9): [True: 2, False: 0]
  ------------------
 6946|      2|	if (ctxt->context->node == NULL) return(NULL);
  ------------------
  |  Branch (6946:6): [True: 0, False: 2]
  ------------------
 6947|      2|	switch (ctxt->context->node->type) {
  ------------------
  |  Branch (6947:10): [True: 0, False: 2]
  ------------------
 6948|      2|            case XML_ELEMENT_NODE:
  ------------------
  |  Branch (6948:13): [True: 2, False: 0]
  ------------------
 6949|      2|            case XML_TEXT_NODE:
  ------------------
  |  Branch (6949:13): [True: 0, False: 2]
  ------------------
 6950|      2|            case XML_CDATA_SECTION_NODE:
  ------------------
  |  Branch (6950:13): [True: 0, False: 2]
  ------------------
 6951|      2|            case XML_ENTITY_REF_NODE:
  ------------------
  |  Branch (6951:13): [True: 0, False: 2]
  ------------------
 6952|      2|            case XML_ENTITY_NODE:
  ------------------
  |  Branch (6952:13): [True: 0, False: 2]
  ------------------
 6953|      2|            case XML_PI_NODE:
  ------------------
  |  Branch (6953:13): [True: 0, False: 2]
  ------------------
 6954|      2|            case XML_COMMENT_NODE:
  ------------------
  |  Branch (6954:13): [True: 0, False: 2]
  ------------------
 6955|      2|            case XML_NOTATION_NODE:
  ------------------
  |  Branch (6955:13): [True: 0, False: 2]
  ------------------
 6956|      2|            case XML_DTD_NODE:
  ------------------
  |  Branch (6956:13): [True: 0, False: 2]
  ------------------
 6957|      2|		return(ctxt->context->node->children);
 6958|      0|            case XML_DOCUMENT_NODE:
  ------------------
  |  Branch (6958:13): [True: 0, False: 2]
  ------------------
 6959|      0|            case XML_DOCUMENT_TYPE_NODE:
  ------------------
  |  Branch (6959:13): [True: 0, False: 2]
  ------------------
 6960|      0|            case XML_DOCUMENT_FRAG_NODE:
  ------------------
  |  Branch (6960:13): [True: 0, False: 2]
  ------------------
 6961|      0|            case XML_HTML_DOCUMENT_NODE:
  ------------------
  |  Branch (6961:13): [True: 0, False: 2]
  ------------------
 6962|      0|		return(((xmlDocPtr) ctxt->context->node)->children);
 6963|      0|	    case XML_ELEMENT_DECL:
  ------------------
  |  Branch (6963:6): [True: 0, False: 2]
  ------------------
 6964|      0|	    case XML_ATTRIBUTE_DECL:
  ------------------
  |  Branch (6964:6): [True: 0, False: 2]
  ------------------
 6965|      0|	    case XML_ENTITY_DECL:
  ------------------
  |  Branch (6965:6): [True: 0, False: 2]
  ------------------
 6966|      0|            case XML_ATTRIBUTE_NODE:
  ------------------
  |  Branch (6966:13): [True: 0, False: 2]
  ------------------
 6967|      0|	    case XML_NAMESPACE_DECL:
  ------------------
  |  Branch (6967:6): [True: 0, False: 2]
  ------------------
 6968|      0|	    case XML_XINCLUDE_START:
  ------------------
  |  Branch (6968:6): [True: 0, False: 2]
  ------------------
 6969|      0|	    case XML_XINCLUDE_END:
  ------------------
  |  Branch (6969:6): [True: 0, False: 2]
  ------------------
 6970|      0|		return(NULL);
 6971|      2|	}
 6972|      0|	return(NULL);
 6973|      2|    }
 6974|      0|    if ((cur->type == XML_DOCUMENT_NODE) ||
  ------------------
  |  Branch (6974:9): [True: 0, False: 0]
  ------------------
 6975|      0|        (cur->type == XML_HTML_DOCUMENT_NODE))
  ------------------
  |  Branch (6975:9): [True: 0, False: 0]
  ------------------
 6976|      0|	return(NULL);
 6977|      0|    return(cur->next);
 6978|      0|}
xmlXPathRoot:
 7741|      2|xmlXPathRoot(xmlXPathParserContextPtr ctxt) {
 7742|      2|    if ((ctxt == NULL) || (ctxt->context == NULL))
  ------------------
  |  Branch (7742:9): [True: 0, False: 2]
  |  Branch (7742:27): [True: 0, False: 2]
  ------------------
 7743|      0|	return;
 7744|      2|    valuePush(ctxt, xmlXPathCacheNewNodeSet(ctxt->context,
 7745|      2|	(xmlNodePtr) ctxt->context->doc));
 7746|      2|}
xmlXPathIdFunction:
 7904|      2|xmlXPathIdFunction(xmlXPathParserContextPtr ctxt, int nargs) {
 7905|      2|    xmlChar *tokens;
 7906|      2|    xmlNodeSetPtr ret;
 7907|      2|    xmlXPathObjectPtr obj;
 7908|       |
 7909|      6|    CHECK_ARITY(1);
  ------------------
  |  |  298|      2|    if (ctxt == NULL) return;						\
  |  |  ------------------
  |  |  |  Branch (298:9): [True: 0, False: 2]
  |  |  ------------------
  |  |  299|      2|    if (nargs != (x))							\
  |  |  ------------------
  |  |  |  Branch (299:9): [True: 0, False: 2]
  |  |  ------------------
  |  |  300|      2|        XP_ERROR(XPATH_INVALID_ARITY);					\
  |  |  ------------------
  |  |  |  |  258|      0|    { xmlXPathErr(ctxt, X); return; }
  |  |  ------------------
  |  |  301|      2|    if (ctxt->valueNr < (x))						\
  |  |  ------------------
  |  |  |  Branch (301:9): [True: 0, False: 2]
  |  |  ------------------
  |  |  302|      2|        XP_ERROR(XPATH_STACK_ERROR);
  |  |  ------------------
  |  |  |  |  258|      0|    { xmlXPathErr(ctxt, X); return; }
  |  |  ------------------
  ------------------
 7910|      6|    obj = valuePop(ctxt);
 7911|      6|    if (obj == NULL) XP_ERROR(XPATH_INVALID_OPERAND);
  ------------------
  |  |  258|      0|    { xmlXPathErr(ctxt, X); return; }
  ------------------
  |  Branch (7911:9): [True: 0, False: 2]
  ------------------
 7912|      2|    if ((obj->type == XPATH_NODESET) || (obj->type == XPATH_XSLT_TREE)) {
  ------------------
  |  Branch (7912:9): [True: 0, False: 2]
  |  Branch (7912:41): [True: 0, False: 2]
  ------------------
 7913|      0|	xmlNodeSetPtr ns;
 7914|      0|	int i;
 7915|       |
 7916|       |        /* TODO: Check memory error. */
 7917|      0|	ret = xmlXPathNodeSetCreate(NULL);
 7918|       |
 7919|      0|	if (obj->nodesetval != NULL) {
  ------------------
  |  Branch (7919:6): [True: 0, False: 0]
  ------------------
 7920|      0|	    for (i = 0; i < obj->nodesetval->nodeNr; i++) {
  ------------------
  |  Branch (7920:18): [True: 0, False: 0]
  ------------------
 7921|      0|		tokens =
 7922|      0|		    xmlXPathCastNodeToString(obj->nodesetval->nodeTab[i]);
 7923|      0|		ns = xmlXPathGetElementsByIds(ctxt->context->doc, tokens);
 7924|       |                /* TODO: Check memory error. */
 7925|      0|		ret = xmlXPathNodeSetMerge(ret, ns);
 7926|      0|		xmlXPathFreeNodeSet(ns);
 7927|      0|		if (tokens != NULL)
  ------------------
  |  Branch (7927:7): [True: 0, False: 0]
  ------------------
 7928|      0|		    xmlFree(tokens);
 7929|      0|	    }
 7930|      0|	}
 7931|      0|	xmlXPathReleaseObject(ctxt->context, obj);
 7932|      0|	valuePush(ctxt, xmlXPathCacheWrapNodeSet(ctxt->context, ret));
 7933|      0|	return;
 7934|      0|    }
 7935|      2|    obj = xmlXPathCacheConvertString(ctxt->context, obj);
 7936|      2|    if (obj == NULL) return;
  ------------------
  |  Branch (7936:9): [True: 0, False: 2]
  ------------------
 7937|      2|    ret = xmlXPathGetElementsByIds(ctxt->context->doc, obj->stringval);
 7938|      2|    valuePush(ctxt, xmlXPathCacheWrapNodeSet(ctxt->context, ret));
 7939|      2|    xmlXPathReleaseObject(ctxt->context, obj);
 7940|      2|    return;
 7941|      2|}
xmlXPathParseNCName:
 9045|      4|xmlXPathParseNCName(xmlXPathParserContextPtr ctxt) {
 9046|      4|    const xmlChar *in;
 9047|      4|    xmlChar *ret;
 9048|      4|    int count = 0;
 9049|       |
 9050|      4|    if ((ctxt == NULL) || (ctxt->cur == NULL)) return(NULL);
  ------------------
  |  Branch (9050:9): [True: 0, False: 4]
  |  Branch (9050:27): [True: 0, False: 4]
  ------------------
 9051|       |    /*
 9052|       |     * Accelerator for simple ASCII names
 9053|       |     */
 9054|      4|    in = ctxt->cur;
 9055|      4|    if (((*in >= 0x61) && (*in <= 0x7A)) ||
  ------------------
  |  Branch (9055:10): [True: 4, False: 0]
  |  Branch (9055:27): [True: 4, False: 0]
  ------------------
 9056|      4|	((*in >= 0x41) && (*in <= 0x5A)) ||
  ------------------
  |  Branch (9056:3): [True: 0, False: 0]
  |  Branch (9056:20): [True: 0, False: 0]
  ------------------
 9057|      4|	(*in == '_')) {
  ------------------
  |  Branch (9057:2): [True: 0, False: 0]
  ------------------
 9058|      4|	in++;
 9059|     12|	while (((*in >= 0x61) && (*in <= 0x7A)) ||
  ------------------
  |  Branch (9059:10): [True: 6, False: 6]
  |  Branch (9059:27): [True: 6, False: 0]
  ------------------
 9060|     12|	       ((*in >= 0x41) && (*in <= 0x5A)) ||
  ------------------
  |  Branch (9060:10): [True: 0, False: 6]
  |  Branch (9060:27): [True: 0, False: 0]
  ------------------
 9061|     12|	       ((*in >= 0x30) && (*in <= 0x39)) ||
  ------------------
  |  Branch (9061:10): [True: 2, False: 4]
  |  Branch (9061:27): [True: 2, False: 0]
  ------------------
 9062|     12|	       (*in == '_') || (*in == '.') ||
  ------------------
  |  Branch (9062:9): [True: 0, False: 4]
  |  Branch (9062:25): [True: 0, False: 4]
  ------------------
 9063|     12|	       (*in == '-'))
  ------------------
  |  Branch (9063:9): [True: 0, False: 4]
  ------------------
 9064|      8|	    in++;
 9065|      4|	if ((*in == ' ') || (*in == '>') || (*in == '/') ||
  ------------------
  |  Branch (9065:6): [True: 0, False: 4]
  |  Branch (9065:22): [True: 0, False: 4]
  |  Branch (9065:38): [True: 2, False: 2]
  ------------------
 9066|      4|            (*in == '[') || (*in == ']') || (*in == ':') ||
  ------------------
  |  Branch (9066:13): [True: 0, False: 2]
  |  Branch (9066:29): [True: 0, False: 2]
  |  Branch (9066:45): [True: 0, False: 2]
  ------------------
 9067|      4|            (*in == '@') || (*in == '*')) {
  ------------------
  |  Branch (9067:13): [True: 0, False: 2]
  |  Branch (9067:29): [True: 0, False: 2]
  ------------------
 9068|      2|	    count = in - ctxt->cur;
 9069|      2|	    if (count == 0)
  ------------------
  |  Branch (9069:10): [True: 0, False: 2]
  ------------------
 9070|      0|		return(NULL);
 9071|      2|	    ret = xmlStrndup(ctxt->cur, count);
 9072|      2|	    ctxt->cur = in;
 9073|      2|	    return(ret);
 9074|      2|	}
 9075|      4|    }
 9076|      2|    return(xmlXPathParseNameComplex(ctxt, 0));
 9077|      4|}
xmlXPathParseName:
 9126|     84|xmlXPathParseName(xmlXPathParserContextPtr ctxt) {
 9127|     84|    const xmlChar *in;
 9128|     84|    xmlChar *ret;
 9129|     84|    size_t count = 0;
 9130|       |
 9131|     84|    if ((ctxt == NULL) || (ctxt->cur == NULL)) return(NULL);
  ------------------
  |  Branch (9131:9): [True: 0, False: 84]
  |  Branch (9131:27): [True: 0, False: 84]
  ------------------
 9132|       |    /*
 9133|       |     * Accelerator for simple ASCII names
 9134|       |     */
 9135|     84|    in = ctxt->cur;
 9136|     84|    if (((*in >= 0x61) && (*in <= 0x7A)) ||
  ------------------
  |  Branch (9136:10): [True: 84, False: 0]
  |  Branch (9136:27): [True: 84, False: 0]
  ------------------
 9137|     84|	((*in >= 0x41) && (*in <= 0x5A)) ||
  ------------------
  |  Branch (9137:3): [True: 0, False: 0]
  |  Branch (9137:20): [True: 0, False: 0]
  ------------------
 9138|     84|	(*in == '_') || (*in == ':')) {
  ------------------
  |  Branch (9138:2): [True: 0, False: 0]
  |  Branch (9138:18): [True: 0, False: 0]
  ------------------
 9139|     84|	in++;
 9140|    661|	while (((*in >= 0x61) && (*in <= 0x7A)) ||
  ------------------
  |  Branch (9140:10): [True: 574, False: 87]
  |  Branch (9140:27): [True: 574, False: 0]
  ------------------
 9141|    661|	       ((*in >= 0x41) && (*in <= 0x5A)) ||
  ------------------
  |  Branch (9141:10): [True: 0, False: 87]
  |  Branch (9141:27): [True: 0, False: 0]
  ------------------
 9142|    661|	       ((*in >= 0x30) && (*in <= 0x39)) ||
  ------------------
  |  Branch (9142:10): [True: 3, False: 84]
  |  Branch (9142:27): [True: 3, False: 0]
  ------------------
 9143|    661|	       (*in == '_') || (*in == '-') ||
  ------------------
  |  Branch (9143:9): [True: 0, False: 84]
  |  Branch (9143:25): [True: 0, False: 84]
  ------------------
 9144|    661|	       (*in == ':') || (*in == '.'))
  ------------------
  |  Branch (9144:9): [True: 0, False: 84]
  |  Branch (9144:25): [True: 0, False: 84]
  ------------------
 9145|    577|	    in++;
 9146|     84|	if ((*in > 0) && (*in < 0x80)) {
  ------------------
  |  Branch (9146:6): [True: 82, False: 2]
  |  Branch (9146:19): [True: 82, False: 0]
  ------------------
 9147|     82|	    count = in - ctxt->cur;
 9148|     82|            if (count > XML_MAX_NAME_LENGTH) {
  ------------------
  |  |   61|     82|#define XML_MAX_NAME_LENGTH 50000
  ------------------
  |  Branch (9148:17): [True: 0, False: 82]
  ------------------
 9149|      0|                ctxt->cur = in;
 9150|      0|                XP_ERRORNULL(XPATH_EXPR_ERROR);
  ------------------
  |  |  589|      0|    { xmlXPathErr(ctxt, X); return(NULL); }
  ------------------
 9151|      0|            }
 9152|     82|	    ret = xmlStrndup(ctxt->cur, count);
 9153|     82|	    ctxt->cur = in;
 9154|     82|	    return(ret);
 9155|     82|	}
 9156|     84|    }
 9157|      2|    return(xmlXPathParseNameComplex(ctxt, 1));
 9158|     84|}
xmlXPathEvalExpr:
13510|     82|xmlXPathEvalExpr(xmlXPathParserContextPtr ctxt) {
13511|     82|#ifdef XPATH_STREAMING
13512|     82|    xmlXPathCompExprPtr comp;
13513|     82|#endif
13514|     82|    int oldDepth = 0;
13515|       |
13516|     82|    if (ctxt == NULL) return;
  ------------------
  |  Branch (13516:9): [True: 0, False: 82]
  ------------------
13517|       |
13518|     82|#ifdef XPATH_STREAMING
13519|     82|    comp = xmlXPathTryStreamCompile(ctxt->context, ctxt->base);
13520|     82|    if (comp != NULL) {
  ------------------
  |  Branch (13520:9): [True: 80, False: 2]
  ------------------
13521|     80|        if (ctxt->comp != NULL)
  ------------------
  |  Branch (13521:13): [True: 80, False: 0]
  ------------------
13522|     80|	    xmlXPathFreeCompExpr(ctxt->comp);
13523|     80|        ctxt->comp = comp;
13524|     80|    } else
13525|      2|#endif
13526|      2|    {
13527|      2|        if (ctxt->context != NULL)
  ------------------
  |  Branch (13527:13): [True: 2, False: 0]
  ------------------
13528|      2|            oldDepth = ctxt->context->depth;
13529|      2|	xmlXPathCompileExpr(ctxt, 1);
13530|      2|        if (ctxt->context != NULL)
  ------------------
  |  Branch (13530:13): [True: 2, False: 0]
  ------------------
13531|      2|            ctxt->context->depth = oldDepth;
13532|      2|        CHECK_ERROR;
  ------------------
  |  |  241|      2|    if (ctxt->error != XPATH_EXPRESSION_OK) return
  |  |  ------------------
  |  |  |  Branch (241:9): [True: 0, False: 2]
  |  |  ------------------
  ------------------
13533|       |
13534|       |        /* Check for trailing characters. */
13535|      2|        if (*ctxt->cur != 0)
  ------------------
  |  Branch (13535:13): [True: 0, False: 2]
  ------------------
13536|      2|            XP_ERROR(XPATH_EXPR_ERROR);
  ------------------
  |  |  258|      0|    { xmlXPathErr(ctxt, X); return; }
  ------------------
13537|       |
13538|      2|	if ((ctxt->comp->nbStep > 1) && (ctxt->comp->last >= 0)) {
  ------------------
  |  Branch (13538:6): [True: 2, False: 0]
  |  Branch (13538:34): [True: 2, False: 0]
  ------------------
13539|      2|            if (ctxt->context != NULL)
  ------------------
  |  Branch (13539:17): [True: 2, False: 0]
  ------------------
13540|      2|                oldDepth = ctxt->context->depth;
13541|      2|	    xmlXPathOptimizeExpression(ctxt,
13542|      2|		&ctxt->comp->steps[ctxt->comp->last]);
13543|      2|            if (ctxt->context != NULL)
  ------------------
  |  Branch (13543:17): [True: 2, False: 0]
  ------------------
13544|      2|                ctxt->context->depth = oldDepth;
13545|      2|        }
13546|      2|    }
13547|       |
13548|     82|    xmlXPathRunEval(ctxt, 0);
13549|     82|}
xmlXPathRegisterAllFunctions:
13773|     84|{
13774|     84|    xmlXPathRegisterFunc(ctxt, (const xmlChar *)"boolean",
13775|     84|                         xmlXPathBooleanFunction);
13776|     84|    xmlXPathRegisterFunc(ctxt, (const xmlChar *)"ceiling",
13777|     84|                         xmlXPathCeilingFunction);
13778|     84|    xmlXPathRegisterFunc(ctxt, (const xmlChar *)"count",
13779|     84|                         xmlXPathCountFunction);
13780|     84|    xmlXPathRegisterFunc(ctxt, (const xmlChar *)"concat",
13781|     84|                         xmlXPathConcatFunction);
13782|     84|    xmlXPathRegisterFunc(ctxt, (const xmlChar *)"contains",
13783|     84|                         xmlXPathContainsFunction);
13784|     84|    xmlXPathRegisterFunc(ctxt, (const xmlChar *)"id",
13785|     84|                         xmlXPathIdFunction);
13786|     84|    xmlXPathRegisterFunc(ctxt, (const xmlChar *)"false",
13787|     84|                         xmlXPathFalseFunction);
13788|     84|    xmlXPathRegisterFunc(ctxt, (const xmlChar *)"floor",
13789|     84|                         xmlXPathFloorFunction);
13790|     84|    xmlXPathRegisterFunc(ctxt, (const xmlChar *)"last",
13791|     84|                         xmlXPathLastFunction);
13792|     84|    xmlXPathRegisterFunc(ctxt, (const xmlChar *)"lang",
13793|     84|                         xmlXPathLangFunction);
13794|     84|    xmlXPathRegisterFunc(ctxt, (const xmlChar *)"local-name",
13795|     84|                         xmlXPathLocalNameFunction);
13796|     84|    xmlXPathRegisterFunc(ctxt, (const xmlChar *)"not",
13797|     84|                         xmlXPathNotFunction);
13798|     84|    xmlXPathRegisterFunc(ctxt, (const xmlChar *)"name",
13799|     84|                         xmlXPathNameFunction);
13800|     84|    xmlXPathRegisterFunc(ctxt, (const xmlChar *)"namespace-uri",
13801|     84|                         xmlXPathNamespaceURIFunction);
13802|     84|    xmlXPathRegisterFunc(ctxt, (const xmlChar *)"normalize-space",
13803|     84|                         xmlXPathNormalizeFunction);
13804|     84|    xmlXPathRegisterFunc(ctxt, (const xmlChar *)"number",
13805|     84|                         xmlXPathNumberFunction);
13806|     84|    xmlXPathRegisterFunc(ctxt, (const xmlChar *)"position",
13807|     84|                         xmlXPathPositionFunction);
13808|     84|    xmlXPathRegisterFunc(ctxt, (const xmlChar *)"round",
13809|     84|                         xmlXPathRoundFunction);
13810|     84|    xmlXPathRegisterFunc(ctxt, (const xmlChar *)"string",
13811|     84|                         xmlXPathStringFunction);
13812|     84|    xmlXPathRegisterFunc(ctxt, (const xmlChar *)"string-length",
13813|     84|                         xmlXPathStringLengthFunction);
13814|     84|    xmlXPathRegisterFunc(ctxt, (const xmlChar *)"starts-with",
13815|     84|                         xmlXPathStartsWithFunction);
13816|     84|    xmlXPathRegisterFunc(ctxt, (const xmlChar *)"substring",
13817|     84|                         xmlXPathSubstringFunction);
13818|     84|    xmlXPathRegisterFunc(ctxt, (const xmlChar *)"substring-before",
13819|     84|                         xmlXPathSubstringBeforeFunction);
13820|     84|    xmlXPathRegisterFunc(ctxt, (const xmlChar *)"substring-after",
13821|     84|                         xmlXPathSubstringAfterFunction);
13822|     84|    xmlXPathRegisterFunc(ctxt, (const xmlChar *)"sum",
13823|     84|                         xmlXPathSumFunction);
13824|     84|    xmlXPathRegisterFunc(ctxt, (const xmlChar *)"true",
13825|     84|                         xmlXPathTrueFunction);
13826|     84|    xmlXPathRegisterFunc(ctxt, (const xmlChar *)"translate",
13827|     84|                         xmlXPathTranslateFunction);
13828|       |
13829|     84|    xmlXPathRegisterFuncNS(ctxt, (const xmlChar *)"escape-uri",
13830|     84|	 (const xmlChar *)"http://www.w3.org/2002/08/xquery-functions",
13831|     84|                         xmlXPathEscapeUriFunction);
13832|     84|}
xpath.c:xmlXPathReleaseObject:
 4859|      6|{
 4860|      6|#define XP_CACHE_ADD(sl, o) if (sl == NULL) { \
 4861|      6|	sl = xmlPointerListCreate(10); if (sl == NULL) goto free_obj; } \
 4862|      6|    if (xmlPointerListAddSize(sl, obj, 0) == -1) goto free_obj;
 4863|       |
 4864|      6|#define XP_CACHE_WANTS(sl, n) ((sl == NULL) || ((sl)->number < n))
 4865|       |
 4866|      6|    if (obj == NULL)
  ------------------
  |  Branch (4866:9): [True: 0, False: 6]
  ------------------
 4867|      0|	return;
 4868|      6|    if ((ctxt == NULL) || (ctxt->cache == NULL)) {
  ------------------
  |  Branch (4868:9): [True: 0, False: 6]
  |  Branch (4868:27): [True: 6, False: 0]
  ------------------
 4869|      6|	 xmlXPathFreeObject(obj);
 4870|      6|    } else {
 4871|      0|	xmlXPathContextCachePtr cache =
 4872|      0|	    (xmlXPathContextCachePtr) ctxt->cache;
 4873|       |
 4874|      0|	switch (obj->type) {
 4875|      0|	    case XPATH_NODESET:
  ------------------
  |  Branch (4875:6): [True: 0, False: 0]
  ------------------
 4876|      0|	    case XPATH_XSLT_TREE:
  ------------------
  |  Branch (4876:6): [True: 0, False: 0]
  ------------------
 4877|      0|		if (obj->nodesetval != NULL) {
  ------------------
  |  Branch (4877:7): [True: 0, False: 0]
  ------------------
 4878|      0|		    if (obj->boolval) {
  ------------------
  |  Branch (4878:11): [True: 0, False: 0]
  ------------------
 4879|       |			/*
 4880|       |			* It looks like the @boolval is used for
 4881|       |			* evaluation if this an XSLT Result Tree Fragment.
 4882|       |			* TODO: Check if this assumption is correct.
 4883|       |			*/
 4884|      0|			obj->type = XPATH_XSLT_TREE; /* just for debugging */
 4885|      0|			xmlXPathFreeValueTree(obj->nodesetval);
 4886|      0|			obj->nodesetval = NULL;
 4887|      0|		    } else if ((obj->nodesetval->nodeMax <= 40) &&
  ------------------
  |  Branch (4887:18): [True: 0, False: 0]
  ------------------
 4888|      0|			(XP_CACHE_WANTS(cache->nodesetObjs,
  ------------------
  |  | 4864|      0|#define XP_CACHE_WANTS(sl, n) ((sl == NULL) || ((sl)->number < n))
  |  |  ------------------
  |  |  |  Branch (4864:32): [True: 0, False: 0]
  |  |  |  Branch (4864:48): [True: 0, False: 0]
  |  |  ------------------
  ------------------
 4889|      0|					cache->maxNodeset)))
 4890|      0|		    {
 4891|      0|			XP_CACHE_ADD(cache->nodesetObjs, obj);
  ------------------
  |  | 4860|      0|#define XP_CACHE_ADD(sl, o) if (sl == NULL) { \
  |  |  ------------------
  |  |  |  Branch (4860:33): [True: 0, False: 0]
  |  |  ------------------
  |  | 4861|      0|	sl = xmlPointerListCreate(10); if (sl == NULL) goto free_obj; } \
  |  |  ------------------
  |  |  |  Branch (4861:37): [True: 0, False: 0]
  |  |  ------------------
  |  | 4862|      0|    if (xmlPointerListAddSize(sl, obj, 0) == -1) goto free_obj;
  |  |  ------------------
  |  |  |  Branch (4862:9): [True: 0, False: 0]
  |  |  ------------------
  ------------------
 4892|      0|			goto obj_cached;
 4893|      0|		    } else {
 4894|      0|			xmlXPathFreeNodeSet(obj->nodesetval);
 4895|      0|			obj->nodesetval = NULL;
 4896|      0|		    }
 4897|      0|		}
 4898|      0|		break;
 4899|      0|	    case XPATH_STRING:
  ------------------
  |  Branch (4899:6): [True: 0, False: 0]
  ------------------
 4900|      0|		if (obj->stringval != NULL)
  ------------------
  |  Branch (4900:7): [True: 0, False: 0]
  ------------------
 4901|      0|		    xmlFree(obj->stringval);
 4902|       |
 4903|      0|		if (XP_CACHE_WANTS(cache->stringObjs, cache->maxString)) {
  ------------------
  |  | 4864|      0|#define XP_CACHE_WANTS(sl, n) ((sl == NULL) || ((sl)->number < n))
  |  |  ------------------
  |  |  |  Branch (4864:32): [True: 0, False: 0]
  |  |  |  Branch (4864:48): [True: 0, False: 0]
  |  |  ------------------
  ------------------
 4904|      0|		    XP_CACHE_ADD(cache->stringObjs, obj);
  ------------------
  |  | 4860|      0|#define XP_CACHE_ADD(sl, o) if (sl == NULL) { \
  |  |  ------------------
  |  |  |  Branch (4860:33): [True: 0, False: 0]
  |  |  ------------------
  |  | 4861|      0|	sl = xmlPointerListCreate(10); if (sl == NULL) goto free_obj; } \
  |  |  ------------------
  |  |  |  Branch (4861:37): [True: 0, False: 0]
  |  |  ------------------
  |  | 4862|      0|    if (xmlPointerListAddSize(sl, obj, 0) == -1) goto free_obj;
  |  |  ------------------
  |  |  |  Branch (4862:9): [True: 0, False: 0]
  |  |  ------------------
  ------------------
 4905|      0|		    goto obj_cached;
 4906|      0|		}
 4907|      0|		break;
 4908|      0|	    case XPATH_BOOLEAN:
  ------------------
  |  Branch (4908:6): [True: 0, False: 0]
  ------------------
 4909|      0|		if (XP_CACHE_WANTS(cache->booleanObjs, cache->maxBoolean)) {
  ------------------
  |  | 4864|      0|#define XP_CACHE_WANTS(sl, n) ((sl == NULL) || ((sl)->number < n))
  |  |  ------------------
  |  |  |  Branch (4864:32): [True: 0, False: 0]
  |  |  |  Branch (4864:48): [True: 0, False: 0]
  |  |  ------------------
  ------------------
 4910|      0|		    XP_CACHE_ADD(cache->booleanObjs, obj);
  ------------------
  |  | 4860|      0|#define XP_CACHE_ADD(sl, o) if (sl == NULL) { \
  |  |  ------------------
  |  |  |  Branch (4860:33): [True: 0, False: 0]
  |  |  ------------------
  |  | 4861|      0|	sl = xmlPointerListCreate(10); if (sl == NULL) goto free_obj; } \
  |  |  ------------------
  |  |  |  Branch (4861:37): [True: 0, False: 0]
  |  |  ------------------
  |  | 4862|      0|    if (xmlPointerListAddSize(sl, obj, 0) == -1) goto free_obj;
  |  |  ------------------
  |  |  |  Branch (4862:9): [True: 0, False: 0]
  |  |  ------------------
  ------------------
 4911|      0|		    goto obj_cached;
 4912|      0|		}
 4913|      0|		break;
 4914|      0|	    case XPATH_NUMBER:
  ------------------
  |  Branch (4914:6): [True: 0, False: 0]
  ------------------
 4915|      0|		if (XP_CACHE_WANTS(cache->numberObjs, cache->maxNumber)) {
  ------------------
  |  | 4864|      0|#define XP_CACHE_WANTS(sl, n) ((sl == NULL) || ((sl)->number < n))
  |  |  ------------------
  |  |  |  Branch (4864:32): [True: 0, False: 0]
  |  |  |  Branch (4864:48): [True: 0, False: 0]
  |  |  ------------------
  ------------------
 4916|      0|		    XP_CACHE_ADD(cache->numberObjs, obj);
  ------------------
  |  | 4860|      0|#define XP_CACHE_ADD(sl, o) if (sl == NULL) { \
  |  |  ------------------
  |  |  |  Branch (4860:33): [True: 0, False: 0]
  |  |  ------------------
  |  | 4861|      0|	sl = xmlPointerListCreate(10); if (sl == NULL) goto free_obj; } \
  |  |  ------------------
  |  |  |  Branch (4861:37): [True: 0, False: 0]
  |  |  ------------------
  |  | 4862|      0|    if (xmlPointerListAddSize(sl, obj, 0) == -1) goto free_obj;
  |  |  ------------------
  |  |  |  Branch (4862:9): [True: 0, False: 0]
  |  |  ------------------
  ------------------
 4917|      0|		    goto obj_cached;
 4918|      0|		}
 4919|      0|		break;
 4920|       |#ifdef LIBXML_XPTR_LOCS_ENABLED
 4921|       |	    case XPATH_LOCATIONSET:
 4922|       |		if (obj->user != NULL) {
 4923|       |		    xmlXPtrFreeLocationSet(obj->user);
 4924|       |		}
 4925|       |		goto free_obj;
 4926|       |#endif
 4927|      0|	    default:
  ------------------
  |  Branch (4927:6): [True: 0, False: 0]
  ------------------
 4928|      0|		goto free_obj;
 4929|      0|	}
 4930|       |
 4931|       |	/*
 4932|       |	* Fallback to adding to the misc-objects slot.
 4933|       |	*/
 4934|      0|	if (XP_CACHE_WANTS(cache->miscObjs, cache->maxMisc)) {
  ------------------
  |  | 4864|      0|#define XP_CACHE_WANTS(sl, n) ((sl == NULL) || ((sl)->number < n))
  |  |  ------------------
  |  |  |  Branch (4864:32): [True: 0, False: 0]
  |  |  |  Branch (4864:48): [True: 0, False: 0]
  |  |  ------------------
  ------------------
 4935|      0|	    XP_CACHE_ADD(cache->miscObjs, obj);
  ------------------
  |  | 4860|      0|#define XP_CACHE_ADD(sl, o) if (sl == NULL) { \
  |  |  ------------------
  |  |  |  Branch (4860:33): [True: 0, False: 0]
  |  |  ------------------
  |  | 4861|      0|	sl = xmlPointerListCreate(10); if (sl == NULL) goto free_obj; } \
  |  |  ------------------
  |  |  |  Branch (4861:37): [True: 0, False: 0]
  |  |  ------------------
  |  | 4862|      0|    if (xmlPointerListAddSize(sl, obj, 0) == -1) goto free_obj;
  |  |  ------------------
  |  |  |  Branch (4862:9): [True: 0, False: 0]
  |  |  ------------------
  ------------------
 4936|      0|	} else
 4937|      0|	    goto free_obj;
 4938|       |
 4939|      0|obj_cached:
 4940|      0|	if (obj->nodesetval != NULL) {
  ------------------
  |  Branch (4940:6): [True: 0, False: 0]
  ------------------
 4941|      0|	    xmlNodeSetPtr tmpset = obj->nodesetval;
 4942|       |
 4943|       |	    /*
 4944|       |	    * TODO: Due to those nasty ns-nodes, we need to traverse
 4945|       |	    *  the list and free the ns-nodes.
 4946|       |	    * URGENT TODO: Check if it's actually slowing things down.
 4947|       |	    *  Maybe we shouldn't try to preserve the list.
 4948|       |	    */
 4949|      0|	    if (tmpset->nodeNr > 1) {
  ------------------
  |  Branch (4949:10): [True: 0, False: 0]
  ------------------
 4950|      0|		int i;
 4951|      0|		xmlNodePtr node;
 4952|       |
 4953|      0|		for (i = 0; i < tmpset->nodeNr; i++) {
  ------------------
  |  Branch (4953:15): [True: 0, False: 0]
  ------------------
 4954|      0|		    node = tmpset->nodeTab[i];
 4955|      0|		    if ((node != NULL) &&
  ------------------
  |  Branch (4955:11): [True: 0, False: 0]
  ------------------
 4956|      0|			(node->type == XML_NAMESPACE_DECL))
  ------------------
  |  Branch (4956:4): [True: 0, False: 0]
  ------------------
 4957|      0|		    {
 4958|      0|			xmlXPathNodeSetFreeNs((xmlNsPtr) node);
 4959|      0|		    }
 4960|      0|		}
 4961|      0|	    } else if (tmpset->nodeNr == 1) {
  ------------------
  |  Branch (4961:17): [True: 0, False: 0]
  ------------------
 4962|      0|		if ((tmpset->nodeTab[0] != NULL) &&
  ------------------
  |  Branch (4962:7): [True: 0, False: 0]
  ------------------
 4963|      0|		    (tmpset->nodeTab[0]->type == XML_NAMESPACE_DECL))
  ------------------
  |  Branch (4963:7): [True: 0, False: 0]
  ------------------
 4964|      0|		    xmlXPathNodeSetFreeNs((xmlNsPtr) tmpset->nodeTab[0]);
 4965|      0|	    }
 4966|      0|	    tmpset->nodeNr = 0;
 4967|      0|	    memset(obj, 0, sizeof(xmlXPathObject));
 4968|      0|	    obj->nodesetval = tmpset;
 4969|      0|	} else
 4970|      0|	    memset(obj, 0, sizeof(xmlXPathObject));
 4971|       |
 4972|      0|	return;
 4973|       |
 4974|      0|free_obj:
 4975|       |	/*
 4976|       |	* Cache is full; free the object.
 4977|       |	*/
 4978|      0|	if (obj->nodesetval != NULL)
  ------------------
  |  Branch (4978:6): [True: 0, False: 0]
  ------------------
 4979|      0|	    xmlXPathFreeNodeSet(obj->nodesetval);
 4980|      0|	xmlFree(obj);
 4981|      0|    }
 4982|      6|    return;
 4983|      6|}
xpath.c:xmlXPathNewCompExpr:
 1013|    164|xmlXPathNewCompExpr(void) {
 1014|    164|    xmlXPathCompExprPtr cur;
 1015|       |
 1016|    164|    cur = (xmlXPathCompExprPtr) xmlMalloc(sizeof(xmlXPathCompExpr));
 1017|    164|    if (cur == NULL) {
  ------------------
  |  Branch (1017:9): [True: 0, False: 164]
  ------------------
 1018|      0|        xmlXPathErrMemory(NULL, "allocating component\n");
 1019|      0|	return(NULL);
 1020|      0|    }
 1021|    164|    memset(cur, 0, sizeof(xmlXPathCompExpr));
 1022|    164|    cur->maxStep = 10;
 1023|    164|    cur->nbStep = 0;
 1024|    164|    cur->steps = (xmlXPathStepOp *) xmlMalloc(cur->maxStep *
 1025|    164|	                                   sizeof(xmlXPathStepOp));
 1026|    164|    if (cur->steps == NULL) {
  ------------------
  |  Branch (1026:9): [True: 0, False: 164]
  ------------------
 1027|      0|        xmlXPathErrMemory(NULL, "allocating steps\n");
 1028|      0|	xmlFree(cur);
 1029|      0|	return(NULL);
 1030|      0|    }
 1031|    164|    memset(cur->steps, 0, cur->maxStep * sizeof(xmlXPathStepOp));
 1032|    164|    cur->last = -1;
 1033|    164|    return(cur);
 1034|    164|}
xpath.c:xmlXPathCacheNewNodeSet:
 1903|     82|{
 1904|     82|    if ((ctxt != NULL) && (ctxt->cache)) {
  ------------------
  |  Branch (1904:9): [True: 82, False: 0]
  |  Branch (1904:27): [True: 0, False: 82]
  ------------------
 1905|      0|	xmlXPathContextCachePtr cache = (xmlXPathContextCachePtr) ctxt->cache;
 1906|       |
 1907|      0|	if ((cache->nodesetObjs != NULL) &&
  ------------------
  |  Branch (1907:6): [True: 0, False: 0]
  ------------------
 1908|      0|	    (cache->nodesetObjs->number != 0))
  ------------------
  |  Branch (1908:6): [True: 0, False: 0]
  ------------------
 1909|      0|	{
 1910|      0|	    xmlXPathObjectPtr ret;
 1911|       |	    /*
 1912|       |	    * Use the nodeset-cache.
 1913|       |	    */
 1914|      0|	    ret = (xmlXPathObjectPtr)
 1915|      0|		cache->nodesetObjs->items[--cache->nodesetObjs->number];
 1916|      0|	    ret->type = XPATH_NODESET;
 1917|      0|	    ret->boolval = 0;
 1918|      0|	    if (val) {
  ------------------
  |  Branch (1918:10): [True: 0, False: 0]
  ------------------
 1919|      0|		if ((ret->nodesetval->nodeMax == 0) ||
  ------------------
  |  Branch (1919:7): [True: 0, False: 0]
  ------------------
 1920|      0|		    (val->type == XML_NAMESPACE_DECL))
  ------------------
  |  Branch (1920:7): [True: 0, False: 0]
  ------------------
 1921|      0|		{
 1922|       |                    /* TODO: Check memory error. */
 1923|      0|		    xmlXPathNodeSetAddUnique(ret->nodesetval, val);
 1924|      0|		} else {
 1925|      0|		    ret->nodesetval->nodeTab[0] = val;
 1926|      0|		    ret->nodesetval->nodeNr = 1;
 1927|      0|		}
 1928|      0|	    }
 1929|      0|	    return(ret);
 1930|      0|	} else if ((cache->miscObjs != NULL) &&
  ------------------
  |  Branch (1930:13): [True: 0, False: 0]
  ------------------
 1931|      0|	    (cache->miscObjs->number != 0))
  ------------------
  |  Branch (1931:6): [True: 0, False: 0]
  ------------------
 1932|      0|	{
 1933|      0|	    xmlXPathObjectPtr ret;
 1934|      0|            xmlNodeSetPtr set;
 1935|       |	    /*
 1936|       |	    * Fallback to misc-cache.
 1937|       |	    */
 1938|       |
 1939|      0|	    set = xmlXPathNodeSetCreate(val);
 1940|      0|	    if (set == NULL) {
  ------------------
  |  Branch (1940:10): [True: 0, False: 0]
  ------------------
 1941|      0|		ctxt->lastError.domain = XML_FROM_XPATH;
 1942|      0|		ctxt->lastError.code = XML_ERR_NO_MEMORY;
 1943|      0|		return(NULL);
 1944|      0|	    }
 1945|       |
 1946|      0|	    ret = (xmlXPathObjectPtr)
 1947|      0|		cache->miscObjs->items[--cache->miscObjs->number];
 1948|       |
 1949|      0|	    ret->type = XPATH_NODESET;
 1950|      0|	    ret->boolval = 0;
 1951|      0|	    ret->nodesetval = set;
 1952|      0|	    return(ret);
 1953|      0|	}
 1954|      0|    }
 1955|     82|    return(xmlXPathNewNodeSet(val));
 1956|     82|}
xpath.c:xmlXPathCacheNewFloat:
 2088|      2|{
 2089|      2|     if ((ctxt != NULL) && (ctxt->cache)) {
  ------------------
  |  Branch (2089:10): [True: 2, False: 0]
  |  Branch (2089:28): [True: 0, False: 2]
  ------------------
 2090|      0|	xmlXPathContextCachePtr cache = (xmlXPathContextCachePtr) ctxt->cache;
 2091|       |
 2092|      0|	if ((cache->numberObjs != NULL) &&
  ------------------
  |  Branch (2092:6): [True: 0, False: 0]
  ------------------
 2093|      0|	    (cache->numberObjs->number != 0))
  ------------------
  |  Branch (2093:6): [True: 0, False: 0]
  ------------------
 2094|      0|	{
 2095|      0|	    xmlXPathObjectPtr ret;
 2096|       |
 2097|      0|	    ret = (xmlXPathObjectPtr)
 2098|      0|		cache->numberObjs->items[--cache->numberObjs->number];
 2099|      0|	    ret->type = XPATH_NUMBER;
 2100|      0|	    ret->floatval = val;
 2101|      0|	    return(ret);
 2102|      0|	} else if ((cache->miscObjs != NULL) &&
  ------------------
  |  Branch (2102:13): [True: 0, False: 0]
  ------------------
 2103|      0|	    (cache->miscObjs->number != 0))
  ------------------
  |  Branch (2103:6): [True: 0, False: 0]
  ------------------
 2104|      0|	{
 2105|      0|	    xmlXPathObjectPtr ret;
 2106|       |
 2107|      0|	    ret = (xmlXPathObjectPtr)
 2108|      0|		cache->miscObjs->items[--cache->miscObjs->number];
 2109|       |
 2110|      0|	    ret->type = XPATH_NUMBER;
 2111|      0|	    ret->floatval = val;
 2112|      0|	    return(ret);
 2113|      0|	}
 2114|      0|    }
 2115|      2|    return(xmlXPathNewFloat(val));
 2116|      2|}
xpath.c:xmlXPathGetElementsByIds:
 7837|      2|xmlXPathGetElementsByIds (xmlDocPtr doc, const xmlChar *ids) {
 7838|      2|    xmlNodeSetPtr ret;
 7839|      2|    const xmlChar *cur = ids;
 7840|      2|    xmlChar *ID;
 7841|      2|    xmlAttrPtr attr;
 7842|      2|    xmlNodePtr elem = NULL;
 7843|       |
 7844|      2|    if (ids == NULL) return(NULL);
  ------------------
  |  Branch (7844:9): [True: 0, False: 2]
  ------------------
 7845|       |
 7846|      2|    ret = xmlXPathNodeSetCreate(NULL);
 7847|      2|    if (ret == NULL)
  ------------------
  |  Branch (7847:9): [True: 0, False: 2]
  ------------------
 7848|      0|        return(ret);
 7849|       |
 7850|      2|    while (IS_BLANK_CH(*cur)) cur++;
 7851|      4|    while (*cur != 0) {
  ------------------
  |  Branch (7851:12): [True: 2, False: 2]
  ------------------
 7852|      7|	while ((!IS_BLANK_CH(*cur)) && (*cur != 0))
  ------------------
  |  |  151|      7|#define IS_BLANK_CH(c)  xmlIsBlank_ch(c)
  |  |  ------------------
  |  |  |  |   88|      7|#define xmlIsBlank_ch(c)	(((c) == 0x20) || \
  |  |  |  |  ------------------
  |  |  |  |  |  Branch (88:27): [True: 0, False: 7]
  |  |  |  |  ------------------
  |  |  |  |   89|      7|				 ((0x9 <= (c)) && ((c) <= 0xa)) || \
  |  |  |  |  ------------------
  |  |  |  |  |  Branch (89:7): [True: 5, False: 2]
  |  |  |  |  |  Branch (89:23): [True: 0, False: 5]
  |  |  |  |  ------------------
  |  |  |  |   90|      7|				 ((c) == 0xd))
  |  |  |  |  ------------------
  |  |  |  |  |  Branch (90:6): [True: 0, False: 7]
  |  |  |  |  ------------------
  |  |  ------------------
  ------------------
  |  Branch (7852:33): [True: 5, False: 2]
  ------------------
 7853|      5|	    cur++;
 7854|       |
 7855|      2|        ID = xmlStrndup(ids, cur - ids);
 7856|      2|	if (ID != NULL) {
  ------------------
  |  Branch (7856:6): [True: 2, False: 0]
  ------------------
 7857|       |	    /*
 7858|       |	     * We used to check the fact that the value passed
 7859|       |	     * was an NCName, but this generated much troubles for
 7860|       |	     * me and Aleksey Sanin, people blatantly violated that
 7861|       |	     * constraint, like Visa3D spec.
 7862|       |	     * if (xmlValidateNCName(ID, 1) == 0)
 7863|       |	     */
 7864|      2|	    attr = xmlGetID(doc, ID);
 7865|      2|	    if (attr != NULL) {
  ------------------
  |  Branch (7865:10): [True: 2, False: 0]
  ------------------
 7866|      2|		if (attr->type == XML_ATTRIBUTE_NODE)
  ------------------
  |  Branch (7866:7): [True: 2, False: 0]
  ------------------
 7867|      2|		    elem = attr->parent;
 7868|      0|		else if (attr->type == XML_ELEMENT_NODE)
  ------------------
  |  Branch (7868:12): [True: 0, False: 0]
  ------------------
 7869|      0|		    elem = (xmlNodePtr) attr;
 7870|      0|		else
 7871|      0|		    elem = NULL;
 7872|       |                /* TODO: Check memory error. */
 7873|      2|		if (elem != NULL)
  ------------------
  |  Branch (7873:7): [True: 2, False: 0]
  ------------------
 7874|      2|		    xmlXPathNodeSetAdd(ret, elem);
 7875|      2|	    }
 7876|      2|	    xmlFree(ID);
 7877|      2|	}
 7878|       |
 7879|      2|	while (IS_BLANK_CH(*cur)) cur++;
 7880|      2|	ids = cur;
 7881|      2|    }
 7882|      2|    return(ret);
 7883|      2|}
xpath.c:xmlXPathCacheWrapNodeSet:
 1823|      6|{
 1824|      6|    if ((ctxt != NULL) && (ctxt->cache != NULL)) {
  ------------------
  |  Branch (1824:9): [True: 6, False: 0]
  |  Branch (1824:27): [True: 0, False: 6]
  ------------------
 1825|      0|	xmlXPathContextCachePtr cache =
 1826|      0|	    (xmlXPathContextCachePtr) ctxt->cache;
 1827|       |
 1828|      0|	if ((cache->miscObjs != NULL) &&
  ------------------
  |  Branch (1828:6): [True: 0, False: 0]
  ------------------
 1829|      0|	    (cache->miscObjs->number != 0))
  ------------------
  |  Branch (1829:6): [True: 0, False: 0]
  ------------------
 1830|      0|	{
 1831|      0|	    xmlXPathObjectPtr ret;
 1832|       |
 1833|      0|	    ret = (xmlXPathObjectPtr)
 1834|      0|		cache->miscObjs->items[--cache->miscObjs->number];
 1835|      0|	    ret->type = XPATH_NODESET;
 1836|      0|	    ret->nodesetval = val;
 1837|      0|	    return(ret);
 1838|      0|	}
 1839|      0|    }
 1840|       |
 1841|      6|    return(xmlXPathWrapNodeSet(val));
 1842|       |
 1843|      6|}
xpath.c:xmlXPathCacheConvertString:
 2131|      2|xmlXPathCacheConvertString(xmlXPathContextPtr ctxt, xmlXPathObjectPtr val) {
 2132|      2|    xmlChar *res = NULL;
 2133|       |
 2134|      2|    if (val == NULL)
  ------------------
  |  Branch (2134:9): [True: 0, False: 2]
  ------------------
 2135|      0|	return(xmlXPathCacheNewCString(ctxt, ""));
 2136|       |
 2137|      2|    switch (val->type) {
  ------------------
  |  Branch (2137:13): [True: 0, False: 2]
  ------------------
 2138|      0|    case XPATH_UNDEFINED:
  ------------------
  |  Branch (2138:5): [True: 0, False: 2]
  ------------------
 2139|      0|	break;
 2140|      0|    case XPATH_NODESET:
  ------------------
  |  Branch (2140:5): [True: 0, False: 2]
  ------------------
 2141|      0|    case XPATH_XSLT_TREE:
  ------------------
  |  Branch (2141:5): [True: 0, False: 2]
  ------------------
 2142|      0|	res = xmlXPathCastNodeSetToString(val->nodesetval);
 2143|      0|	break;
 2144|      2|    case XPATH_STRING:
  ------------------
  |  Branch (2144:5): [True: 2, False: 0]
  ------------------
 2145|      2|	return(val);
 2146|      0|    case XPATH_BOOLEAN:
  ------------------
  |  Branch (2146:5): [True: 0, False: 2]
  ------------------
 2147|      0|	res = xmlXPathCastBooleanToString(val->boolval);
 2148|      0|	break;
 2149|      0|    case XPATH_NUMBER:
  ------------------
  |  Branch (2149:5): [True: 0, False: 2]
  ------------------
 2150|      0|	res = xmlXPathCastNumberToString(val->floatval);
 2151|      0|	break;
 2152|      0|    case XPATH_USERS:
  ------------------
  |  Branch (2152:5): [True: 0, False: 2]
  ------------------
 2153|       |#ifdef LIBXML_XPTR_LOCS_ENABLED
 2154|       |    case XPATH_POINT:
 2155|       |    case XPATH_RANGE:
 2156|       |    case XPATH_LOCATIONSET:
 2157|       |#endif /* LIBXML_XPTR_LOCS_ENABLED */
 2158|      0|	TODO;
  ------------------
  |  |   59|      0|    xmlGenericError(xmlGenericErrorContext,				\
  |  |  ------------------
  |  |  |  |  875|      0|  #define xmlGenericError XML_GLOBAL_MACRO(xmlGenericError)
  |  |  |  |  ------------------
  |  |  |  |  |  |  500|      0|  #define XML_GLOBAL_MACRO(name) (*__##name())
  |  |  |  |  ------------------
  |  |  ------------------
  |  |                   xmlGenericError(xmlGenericErrorContext,				\
  |  |  ------------------
  |  |  |  |  876|      0|  #define xmlGenericErrorContext XML_GLOBAL_MACRO(xmlGenericErrorContext)
  |  |  |  |  ------------------
  |  |  |  |  |  |  500|      0|  #define XML_GLOBAL_MACRO(name) (*__##name())
  |  |  |  |  ------------------
  |  |  ------------------
  |  |   60|      0|	    "Unimplemented block at %s:%d\n",				\
  |  |   61|      0|            __FILE__, __LINE__);
  ------------------
 2159|      0|	break;
 2160|      2|    }
 2161|      0|    xmlXPathReleaseObject(ctxt, val);
 2162|      0|    if (res == NULL)
  ------------------
  |  Branch (2162:9): [True: 0, False: 0]
  ------------------
 2163|      0|	return(xmlXPathCacheNewCString(ctxt, ""));
 2164|      0|    return(xmlXPathCacheWrapString(ctxt, res));
 2165|      0|}
xpath.c:xmlXPathParseNameComplex:
 9161|      4|xmlXPathParseNameComplex(xmlXPathParserContextPtr ctxt, int qualified) {
 9162|      4|    xmlChar buf[XML_MAX_NAMELEN + 5];
 9163|      4|    int len = 0, l;
 9164|      4|    int c;
 9165|       |
 9166|       |    /*
 9167|       |     * Handler for more complex cases
 9168|       |     */
 9169|      4|    c = CUR_CHAR(l);
  ------------------
  |  | 2500|      4|#define CUR_CHAR(l) xmlXPathCurrentChar(ctxt, &l)
  ------------------
 9170|      4|    if ((c == ' ') || (c == '>') || (c == '/') || /* accelerators */
  ------------------
  |  Branch (9170:9): [True: 0, False: 4]
  |  Branch (9170:23): [True: 0, False: 4]
  |  Branch (9170:37): [True: 0, False: 4]
  ------------------
 9171|      4|        (c == '[') || (c == ']') || (c == '@') || /* accelerators */
  ------------------
  |  Branch (9171:9): [True: 0, False: 4]
  |  Branch (9171:23): [True: 0, False: 4]
  |  Branch (9171:37): [True: 0, False: 4]
  ------------------
 9172|      4|        (c == '*') || /* accelerators */
  ------------------
  |  Branch (9172:9): [True: 0, False: 4]
  ------------------
 9173|      4|	(!IS_LETTER(c) && (c != '_') &&
  ------------------
  |  |  240|      8|#define IS_LETTER(c) (IS_BASECHAR(c) || IS_IDEOGRAPHIC(c))
  |  |  ------------------
  |  |  |  |  161|      4|#define IS_BASECHAR(c) xmlIsBaseCharQ(c)
  |  |  |  |  ------------------
  |  |  |  |  |  |   76|      8|#define xmlIsBaseCharQ(c)	(((c) < 0x100) ? \
  |  |  |  |  |  |  ------------------
  |  |  |  |  |  |  |  Branch (76:27): [True: 4, False: 0]
  |  |  |  |  |  |  |  Branch (76:28): [True: 4, False: 0]
  |  |  |  |  |  |  ------------------
  |  |  |  |  |  |   77|      8|				 xmlIsBaseChar_ch((c)) : \
  |  |  |  |  |  |  ------------------
  |  |  |  |  |  |  |  |   64|      4|#define xmlIsBaseChar_ch(c)	(((0x41 <= (c)) && ((c) <= 0x5a)) || \
  |  |  |  |  |  |  |  |  ------------------
  |  |  |  |  |  |  |  |  |  Branch (64:31): [True: 4, False: 0]
  |  |  |  |  |  |  |  |  |  Branch (64:48): [True: 0, False: 4]
  |  |  |  |  |  |  |  |  ------------------
  |  |  |  |  |  |  |  |   65|      4|				 ((0x61 <= (c)) && ((c) <= 0x7a)) || \
  |  |  |  |  |  |  |  |  ------------------
  |  |  |  |  |  |  |  |  |  Branch (65:7): [True: 4, False: 0]
  |  |  |  |  |  |  |  |  |  Branch (65:24): [True: 4, False: 0]
  |  |  |  |  |  |  |  |  ------------------
  |  |  |  |  |  |  |  |   66|      4|				 ((0xc0 <= (c)) && ((c) <= 0xd6)) || \
  |  |  |  |  |  |  |  |  ------------------
  |  |  |  |  |  |  |  |  |  Branch (66:7): [True: 0, False: 0]
  |  |  |  |  |  |  |  |  |  Branch (66:24): [True: 0, False: 0]
  |  |  |  |  |  |  |  |  ------------------
  |  |  |  |  |  |  |  |   67|      4|				 ((0xd8 <= (c)) && ((c) <= 0xf6)) || \
  |  |  |  |  |  |  |  |  ------------------
  |  |  |  |  |  |  |  |  |  Branch (67:7): [True: 0, False: 0]
  |  |  |  |  |  |  |  |  |  Branch (67:24): [True: 0, False: 0]
  |  |  |  |  |  |  |  |  ------------------
  |  |  |  |  |  |  |  |   68|      4|				  (0xf8 <= (c)))
  |  |  |  |  |  |  |  |  ------------------
  |  |  |  |  |  |  |  |  |  Branch (68:7): [True: 0, False: 0]
  |  |  |  |  |  |  |  |  ------------------
  |  |  |  |  |  |  ------------------
  |  |  |  |  |  |   78|      8|				 xmlCharInRange((c), &xmlIsBaseCharGroup))
  |  |  |  |  ------------------
  |  |  ------------------
  |  |               #define IS_LETTER(c) (IS_BASECHAR(c) || IS_IDEOGRAPHIC(c))
  |  |  ------------------
  |  |  |  |  229|      0|#define IS_IDEOGRAPHIC(c) xmlIsIdeographicQ(c)
  |  |  |  |  ------------------
  |  |  |  |  |  |  184|      0|#define xmlIsIdeographicQ(c)	(((c) < 0x100) ? \
  |  |  |  |  |  |  ------------------
  |  |  |  |  |  |  |  Branch (184:30): [True: 0, False: 0]
  |  |  |  |  |  |  |  Branch (184:31): [True: 0, False: 0]
  |  |  |  |  |  |  ------------------
  |  |  |  |  |  |  185|      0|				 0 :\
  |  |  |  |  |  |  186|      0|				(((0x4e00 <= (c)) && ((c) <= 0x9fa5)) || \
  |  |  |  |  |  |  ------------------
  |  |  |  |  |  |  |  Branch (186:7): [True: 0, False: 0]
  |  |  |  |  |  |  |  Branch (186:26): [True: 0, False: 0]
  |  |  |  |  |  |  ------------------
  |  |  |  |  |  |  187|      0|				 ((c) == 0x3007) || \
  |  |  |  |  |  |  ------------------
  |  |  |  |  |  |  |  Branch (187:6): [True: 0, False: 0]
  |  |  |  |  |  |  ------------------
  |  |  |  |  |  |  188|      0|				 ((0x3021 <= (c)) && ((c) <= 0x3029))))
  |  |  |  |  |  |  ------------------
  |  |  |  |  |  |  |  Branch (188:7): [True: 0, False: 0]
  |  |  |  |  |  |  |  Branch (188:26): [True: 0, False: 0]
  |  |  |  |  |  |  ------------------
  |  |  |  |  ------------------
  |  |  ------------------
  ------------------
  |  Branch (9173:20): [True: 0, False: 0]
  ------------------
 9174|      4|         ((!qualified) || (c != ':')))) {
  ------------------
  |  Branch (9174:11): [True: 0, False: 0]
  |  Branch (9174:27): [True: 0, False: 0]
  ------------------
 9175|      0|	return(NULL);
 9176|      0|    }
 9177|       |
 9178|     17|    while ((c != ' ') && (c != '>') && (c != '/') && /* test bigname.xml */
  ------------------
  |  Branch (9178:12): [True: 17, False: 0]
  |  Branch (9178:26): [True: 17, False: 0]
  |  Branch (9178:40): [True: 17, False: 0]
  ------------------
 9179|     17|	   ((IS_LETTER(c)) || (IS_DIGIT(c)) ||
  ------------------
  |  |  240|     17|#define IS_LETTER(c) (IS_BASECHAR(c) || IS_IDEOGRAPHIC(c))
  |  |  ------------------
  |  |  |  |  161|     17|#define IS_BASECHAR(c) xmlIsBaseCharQ(c)
  |  |  |  |  ------------------
  |  |  |  |  |  |   76|     34|#define xmlIsBaseCharQ(c)	(((c) < 0x100) ? \
  |  |  |  |  |  |  ------------------
  |  |  |  |  |  |  |  Branch (76:27): [True: 10, False: 7]
  |  |  |  |  |  |  |  Branch (76:28): [True: 17, False: 0]
  |  |  |  |  |  |  ------------------
  |  |  |  |  |  |   77|     34|				 xmlIsBaseChar_ch((c)) : \
  |  |  |  |  |  |  ------------------
  |  |  |  |  |  |  |  |   64|     17|#define xmlIsBaseChar_ch(c)	(((0x41 <= (c)) && ((c) <= 0x5a)) || \
  |  |  |  |  |  |  |  |  ------------------
  |  |  |  |  |  |  |  |  |  Branch (64:31): [True: 10, False: 7]
  |  |  |  |  |  |  |  |  |  Branch (64:48): [True: 0, False: 10]
  |  |  |  |  |  |  |  |  ------------------
  |  |  |  |  |  |  |  |   65|     17|				 ((0x61 <= (c)) && ((c) <= 0x7a)) || \
  |  |  |  |  |  |  |  |  ------------------
  |  |  |  |  |  |  |  |  |  Branch (65:7): [True: 10, False: 7]
  |  |  |  |  |  |  |  |  |  Branch (65:24): [True: 10, False: 0]
  |  |  |  |  |  |  |  |  ------------------
  |  |  |  |  |  |  |  |   66|     17|				 ((0xc0 <= (c)) && ((c) <= 0xd6)) || \
  |  |  |  |  |  |  |  |  ------------------
  |  |  |  |  |  |  |  |  |  Branch (66:7): [True: 0, False: 7]
  |  |  |  |  |  |  |  |  |  Branch (66:24): [True: 0, False: 0]
  |  |  |  |  |  |  |  |  ------------------
  |  |  |  |  |  |  |  |   67|     17|				 ((0xd8 <= (c)) && ((c) <= 0xf6)) || \
  |  |  |  |  |  |  |  |  ------------------
  |  |  |  |  |  |  |  |  |  Branch (67:7): [True: 0, False: 7]
  |  |  |  |  |  |  |  |  |  Branch (67:24): [True: 0, False: 0]
  |  |  |  |  |  |  |  |  ------------------
  |  |  |  |  |  |  |  |   68|     17|				  (0xf8 <= (c)))
  |  |  |  |  |  |  |  |  ------------------
  |  |  |  |  |  |  |  |  |  Branch (68:7): [True: 0, False: 7]
  |  |  |  |  |  |  |  |  ------------------
  |  |  |  |  |  |  ------------------
  |  |  |  |  |  |   78|     34|				 xmlCharInRange((c), &xmlIsBaseCharGroup))
  |  |  |  |  ------------------
  |  |  ------------------
  |  |               #define IS_LETTER(c) (IS_BASECHAR(c) || IS_IDEOGRAPHIC(c))
  |  |  ------------------
  |  |  |  |  229|      7|#define IS_IDEOGRAPHIC(c) xmlIsIdeographicQ(c)
  |  |  |  |  ------------------
  |  |  |  |  |  |  184|      7|#define xmlIsIdeographicQ(c)	(((c) < 0x100) ? \
  |  |  |  |  |  |  ------------------
  |  |  |  |  |  |  |  Branch (184:30): [True: 0, False: 7]
  |  |  |  |  |  |  |  Branch (184:31): [True: 7, False: 0]
  |  |  |  |  |  |  ------------------
  |  |  |  |  |  |  185|      7|				 0 :\
  |  |  |  |  |  |  186|      7|				(((0x4e00 <= (c)) && ((c) <= 0x9fa5)) || \
  |  |  |  |  |  |  ------------------
  |  |  |  |  |  |  |  Branch (186:7): [True: 0, False: 0]
  |  |  |  |  |  |  |  Branch (186:26): [True: 0, False: 0]
  |  |  |  |  |  |  ------------------
  |  |  |  |  |  |  187|      0|				 ((c) == 0x3007) || \
  |  |  |  |  |  |  ------------------
  |  |  |  |  |  |  |  Branch (187:6): [True: 0, False: 0]
  |  |  |  |  |  |  ------------------
  |  |  |  |  |  |  188|      0|				 ((0x3021 <= (c)) && ((c) <= 0x3029))))
  |  |  |  |  |  |  ------------------
  |  |  |  |  |  |  |  Branch (188:7): [True: 0, False: 0]
  |  |  |  |  |  |  |  Branch (188:26): [True: 0, False: 0]
  |  |  |  |  |  |  ------------------
  |  |  |  |  ------------------
  |  |  ------------------
  ------------------
              	   ((IS_LETTER(c)) || (IS_DIGIT(c)) ||
  ------------------
  |  |  171|      7|#define IS_DIGIT(c) xmlIsDigitQ(c)
  |  |  ------------------
  |  |  |  |  152|      7|#define xmlIsDigitQ(c)		(((c) < 0x100) ? \
  |  |  |  |  ------------------
  |  |  |  |  |  Branch (152:26): [True: 7, False: 0]
  |  |  |  |  ------------------
  |  |  |  |  153|      7|				 xmlIsDigit_ch((c)) : \
  |  |  |  |  ------------------
  |  |  |  |  |  |  144|      7|#define xmlIsDigit_ch(c)	(((0x30 <= (c)) && ((c) <= 0x39)))
  |  |  |  |  |  |  ------------------
  |  |  |  |  |  |  |  Branch (144:28): [True: 3, False: 4]
  |  |  |  |  |  |  |  Branch (144:45): [True: 3, False: 0]
  |  |  |  |  |  |  ------------------
  |  |  |  |  ------------------
  |  |  |  |  154|      7|				 xmlCharInRange((c), &xmlIsDigitGroup))
  |  |  ------------------
  ------------------
  |  Branch (9179:24): [True: 3, False: 4]
  ------------------
 9180|     17|            (c == '.') || (c == '-') ||
  ------------------
  |  Branch (9180:13): [True: 0, False: 4]
  |  Branch (9180:27): [True: 0, False: 4]
  ------------------
 9181|     17|	    (c == '_') || ((qualified) && (c == ':')) ||
  ------------------
  |  Branch (9181:6): [True: 0, False: 4]
  |  Branch (9181:21): [True: 2, False: 2]
  |  Branch (9181:36): [True: 0, False: 2]
  ------------------
 9182|     17|	    (IS_COMBINING(c)) ||
  ------------------
  |  |  189|      4|#define IS_COMBINING(c) xmlIsCombiningQ(c)
  |  |  ------------------
  |  |  |  |  132|      4|#define xmlIsCombiningQ(c)	(((c) < 0x100) ? \
  |  |  |  |  ------------------
  |  |  |  |  |  Branch (132:29): [True: 4, False: 0]
  |  |  |  |  ------------------
  |  |  |  |  133|      4|				 0 : \
  |  |  |  |  134|      4|				 xmlCharInRange((c), &xmlIsCombiningGroup))
  |  |  ------------------
  ------------------
  |  Branch (9182:6): [True: 0, False: 4]
  ------------------
 9183|     17|	    (IS_EXTENDER(c)))) {
  ------------------
  |  |  210|      4|#define IS_EXTENDER(c) xmlIsExtenderQ(c)
  |  |  ------------------
  |  |  |  |  172|      4|#define xmlIsExtenderQ(c)	(((c) < 0x100) ? \
  |  |  |  |  ------------------
  |  |  |  |  |  Branch (172:28): [True: 4, False: 0]
  |  |  |  |  ------------------
  |  |  |  |  173|      4|				 xmlIsExtender_ch((c)) : \
  |  |  |  |  ------------------
  |  |  |  |  |  |  164|      4|#define xmlIsExtender_ch(c)	(((c) == 0xb7))
  |  |  |  |  ------------------
  |  |  |  |  174|      4|				 xmlCharInRange((c), &xmlIsExtenderGroup))
  |  |  ------------------
  ------------------
  |  Branch (9183:6): [True: 0, False: 4]
  ------------------
 9184|     13|	COPY_BUF(l,buf,len,c);
  ------------------
  |  | 2503|     13|    if (l == 1) b[i++] = v;                                            \
  |  |  ------------------
  |  |  |  Branch (2503:9): [True: 13, False: 0]
  |  |  ------------------
  |  | 2504|     13|    else i += xmlCopyChar(l,&b[i],v)
  ------------------
 9185|     13|	NEXTL(l);
  ------------------
  |  | 2506|     13|#define NEXTL(l)  ctxt->cur += l
  ------------------
 9186|     13|	c = CUR_CHAR(l);
  ------------------
  |  | 2500|     13|#define CUR_CHAR(l) xmlXPathCurrentChar(ctxt, &l)
  ------------------
 9187|     13|	if (len >= XML_MAX_NAMELEN) {
  ------------------
  |  |   89|     13|#define XML_MAX_NAMELEN 100
  ------------------
  |  Branch (9187:6): [True: 0, False: 13]
  ------------------
 9188|       |	    /*
 9189|       |	     * Okay someone managed to make a huge name, so he's ready to pay
 9190|       |	     * for the processing speed.
 9191|       |	     */
 9192|      0|	    xmlChar *buffer;
 9193|      0|	    int max = len * 2;
 9194|       |
 9195|      0|            if (len > XML_MAX_NAME_LENGTH) {
  ------------------
  |  |   61|      0|#define XML_MAX_NAME_LENGTH 50000
  ------------------
  |  Branch (9195:17): [True: 0, False: 0]
  ------------------
 9196|      0|                XP_ERRORNULL(XPATH_EXPR_ERROR);
  ------------------
  |  |  589|      0|    { xmlXPathErr(ctxt, X); return(NULL); }
  ------------------
 9197|      0|            }
 9198|      0|	    buffer = (xmlChar *) xmlMallocAtomic(max);
 9199|      0|	    if (buffer == NULL) {
  ------------------
  |  Branch (9199:10): [True: 0, False: 0]
  ------------------
 9200|      0|		XP_ERRORNULL(XPATH_MEMORY_ERROR);
  ------------------
  |  |  589|      0|    { xmlXPathErr(ctxt, X); return(NULL); }
  ------------------
 9201|      0|	    }
 9202|      0|	    memcpy(buffer, buf, len);
 9203|      0|	    while ((IS_LETTER(c)) || (IS_DIGIT(c)) || /* test bigname.xml */
  ------------------
  |  |  240|      0|#define IS_LETTER(c) (IS_BASECHAR(c) || IS_IDEOGRAPHIC(c))
  |  |  ------------------
  |  |  |  |  161|      0|#define IS_BASECHAR(c) xmlIsBaseCharQ(c)
  |  |  |  |  ------------------
  |  |  |  |  |  |   76|      0|#define xmlIsBaseCharQ(c)	(((c) < 0x100) ? \
  |  |  |  |  |  |  ------------------
  |  |  |  |  |  |  |  Branch (76:27): [True: 0, False: 0]
  |  |  |  |  |  |  |  Branch (76:28): [True: 0, False: 0]
  |  |  |  |  |  |  ------------------
  |  |  |  |  |  |   77|      0|				 xmlIsBaseChar_ch((c)) : \
  |  |  |  |  |  |  ------------------
  |  |  |  |  |  |  |  |   64|      0|#define xmlIsBaseChar_ch(c)	(((0x41 <= (c)) && ((c) <= 0x5a)) || \
  |  |  |  |  |  |  |  |  ------------------
  |  |  |  |  |  |  |  |  |  Branch (64:31): [True: 0, False: 0]
  |  |  |  |  |  |  |  |  |  Branch (64:48): [True: 0, False: 0]
  |  |  |  |  |  |  |  |  ------------------
  |  |  |  |  |  |  |  |   65|      0|				 ((0x61 <= (c)) && ((c) <= 0x7a)) || \
  |  |  |  |  |  |  |  |  ------------------
  |  |  |  |  |  |  |  |  |  Branch (65:7): [True: 0, False: 0]
  |  |  |  |  |  |  |  |  |  Branch (65:24): [True: 0, False: 0]
  |  |  |  |  |  |  |  |  ------------------
  |  |  |  |  |  |  |  |   66|      0|				 ((0xc0 <= (c)) && ((c) <= 0xd6)) || \
  |  |  |  |  |  |  |  |  ------------------
  |  |  |  |  |  |  |  |  |  Branch (66:7): [True: 0, False: 0]
  |  |  |  |  |  |  |  |  |  Branch (66:24): [True: 0, False: 0]
  |  |  |  |  |  |  |  |  ------------------
  |  |  |  |  |  |  |  |   67|      0|				 ((0xd8 <= (c)) && ((c) <= 0xf6)) || \
  |  |  |  |  |  |  |  |  ------------------
  |  |  |  |  |  |  |  |  |  Branch (67:7): [True: 0, False: 0]
  |  |  |  |  |  |  |  |  |  Branch (67:24): [True: 0, False: 0]
  |  |  |  |  |  |  |  |  ------------------
  |  |  |  |  |  |  |  |   68|      0|				  (0xf8 <= (c)))
  |  |  |  |  |  |  |  |  ------------------
  |  |  |  |  |  |  |  |  |  Branch (68:7): [True: 0, False: 0]
  |  |  |  |  |  |  |  |  ------------------
  |  |  |  |  |  |  ------------------
  |  |  |  |  |  |   78|      0|				 xmlCharInRange((c), &xmlIsBaseCharGroup))
  |  |  |  |  ------------------
  |  |  ------------------
  |  |               #define IS_LETTER(c) (IS_BASECHAR(c) || IS_IDEOGRAPHIC(c))
  |  |  ------------------
  |  |  |  |  229|      0|#define IS_IDEOGRAPHIC(c) xmlIsIdeographicQ(c)
  |  |  |  |  ------------------
  |  |  |  |  |  |  184|      0|#define xmlIsIdeographicQ(c)	(((c) < 0x100) ? \
  |  |  |  |  |  |  ------------------
  |  |  |  |  |  |  |  Branch (184:30): [True: 0, False: 0]
  |  |  |  |  |  |  |  Branch (184:31): [True: 0, False: 0]
  |  |  |  |  |  |  ------------------
  |  |  |  |  |  |  185|      0|				 0 :\
  |  |  |  |  |  |  186|      0|				(((0x4e00 <= (c)) && ((c) <= 0x9fa5)) || \
  |  |  |  |  |  |  ------------------
  |  |  |  |  |  |  |  Branch (186:7): [True: 0, False: 0]
  |  |  |  |  |  |  |  Branch (186:26): [True: 0, False: 0]
  |  |  |  |  |  |  ------------------
  |  |  |  |  |  |  187|      0|				 ((c) == 0x3007) || \
  |  |  |  |  |  |  ------------------
  |  |  |  |  |  |  |  Branch (187:6): [True: 0, False: 0]
  |  |  |  |  |  |  ------------------
  |  |  |  |  |  |  188|      0|				 ((0x3021 <= (c)) && ((c) <= 0x3029))))
  |  |  |  |  |  |  ------------------
  |  |  |  |  |  |  |  Branch (188:7): [True: 0, False: 0]
  |  |  |  |  |  |  |  Branch (188:26): [True: 0, False: 0]
  |  |  |  |  |  |  ------------------
  |  |  |  |  ------------------
  |  |  ------------------
  ------------------
              	    while ((IS_LETTER(c)) || (IS_DIGIT(c)) || /* test bigname.xml */
  ------------------
  |  |  171|      0|#define IS_DIGIT(c) xmlIsDigitQ(c)
  |  |  ------------------
  |  |  |  |  152|      0|#define xmlIsDigitQ(c)		(((c) < 0x100) ? \
  |  |  |  |  ------------------
  |  |  |  |  |  Branch (152:26): [True: 0, False: 0]
  |  |  |  |  ------------------
  |  |  |  |  153|      0|				 xmlIsDigit_ch((c)) : \
  |  |  |  |  ------------------
  |  |  |  |  |  |  144|      0|#define xmlIsDigit_ch(c)	(((0x30 <= (c)) && ((c) <= 0x39)))
  |  |  |  |  |  |  ------------------
  |  |  |  |  |  |  |  Branch (144:28): [True: 0, False: 0]
  |  |  |  |  |  |  |  Branch (144:45): [True: 0, False: 0]
  |  |  |  |  |  |  ------------------
  |  |  |  |  ------------------
  |  |  |  |  154|      0|				 xmlCharInRange((c), &xmlIsDigitGroup))
  |  |  ------------------
  ------------------
  |  Branch (9203:31): [True: 0, False: 0]
  ------------------
 9204|      0|		   (c == '.') || (c == '-') ||
  ------------------
  |  Branch (9204:6): [True: 0, False: 0]
  |  Branch (9204:20): [True: 0, False: 0]
  ------------------
 9205|      0|		   (c == '_') || ((qualified) && (c == ':')) ||
  ------------------
  |  Branch (9205:6): [True: 0, False: 0]
  |  Branch (9205:21): [True: 0, False: 0]
  |  Branch (9205:36): [True: 0, False: 0]
  ------------------
 9206|      0|		   (IS_COMBINING(c)) ||
  ------------------
  |  |  189|      0|#define IS_COMBINING(c) xmlIsCombiningQ(c)
  |  |  ------------------
  |  |  |  |  132|      0|#define xmlIsCombiningQ(c)	(((c) < 0x100) ? \
  |  |  |  |  ------------------
  |  |  |  |  |  Branch (132:29): [True: 0, False: 0]
  |  |  |  |  ------------------
  |  |  |  |  133|      0|				 0 : \
  |  |  |  |  134|      0|				 xmlCharInRange((c), &xmlIsCombiningGroup))
  |  |  ------------------
  ------------------
  |  Branch (9206:6): [True: 0, False: 0]
  ------------------
 9207|      0|		   (IS_EXTENDER(c))) {
  ------------------
  |  |  210|      0|#define IS_EXTENDER(c) xmlIsExtenderQ(c)
  |  |  ------------------
  |  |  |  |  172|      0|#define xmlIsExtenderQ(c)	(((c) < 0x100) ? \
  |  |  |  |  ------------------
  |  |  |  |  |  Branch (172:28): [True: 0, False: 0]
  |  |  |  |  ------------------
  |  |  |  |  173|      0|				 xmlIsExtender_ch((c)) : \
  |  |  |  |  ------------------
  |  |  |  |  |  |  164|      0|#define xmlIsExtender_ch(c)	(((c) == 0xb7))
  |  |  |  |  ------------------
  |  |  |  |  174|      0|				 xmlCharInRange((c), &xmlIsExtenderGroup))
  |  |  ------------------
  ------------------
  |  Branch (9207:6): [True: 0, False: 0]
  ------------------
 9208|      0|		if (len + 10 > max) {
  ------------------
  |  Branch (9208:7): [True: 0, False: 0]
  ------------------
 9209|      0|                    xmlChar *tmp;
 9210|      0|                    if (max > XML_MAX_NAME_LENGTH) {
  ------------------
  |  |   61|      0|#define XML_MAX_NAME_LENGTH 50000
  ------------------
  |  Branch (9210:25): [True: 0, False: 0]
  ------------------
 9211|      0|                        xmlFree(buffer);
 9212|      0|                        XP_ERRORNULL(XPATH_EXPR_ERROR);
  ------------------
  |  |  589|      0|    { xmlXPathErr(ctxt, X); return(NULL); }
  ------------------
 9213|      0|                    }
 9214|      0|		    max *= 2;
 9215|      0|		    tmp = (xmlChar *) xmlRealloc(buffer, max);
 9216|      0|		    if (tmp == NULL) {
  ------------------
  |  Branch (9216:11): [True: 0, False: 0]
  ------------------
 9217|      0|                        xmlFree(buffer);
 9218|      0|			XP_ERRORNULL(XPATH_MEMORY_ERROR);
  ------------------
  |  |  589|      0|    { xmlXPathErr(ctxt, X); return(NULL); }
  ------------------
 9219|      0|		    }
 9220|      0|                    buffer = tmp;
 9221|      0|		}
 9222|      0|		COPY_BUF(l,buffer,len,c);
  ------------------
  |  | 2503|      0|    if (l == 1) b[i++] = v;                                            \
  |  |  ------------------
  |  |  |  Branch (2503:9): [True: 0, False: 0]
  |  |  ------------------
  |  | 2504|      0|    else i += xmlCopyChar(l,&b[i],v)
  ------------------
 9223|      0|		NEXTL(l);
  ------------------
  |  | 2506|      0|#define NEXTL(l)  ctxt->cur += l
  ------------------
 9224|      0|		c = CUR_CHAR(l);
  ------------------
  |  | 2500|      0|#define CUR_CHAR(l) xmlXPathCurrentChar(ctxt, &l)
  ------------------
 9225|      0|	    }
 9226|      0|	    buffer[len] = 0;
 9227|      0|	    return(buffer);
 9228|      0|	}
 9229|     13|    }
 9230|      4|    if (len == 0)
  ------------------
  |  Branch (9230:9): [True: 0, False: 4]
  ------------------
 9231|      0|	return(NULL);
 9232|      4|    return(xmlStrndup(buf, len));
 9233|      4|}
xpath.c:xmlXPathCurrentChar:
 8958|     17|xmlXPathCurrentChar(xmlXPathParserContextPtr ctxt, int *len) {
 8959|     17|    unsigned char c;
 8960|     17|    unsigned int val;
 8961|     17|    const xmlChar *cur;
 8962|       |
 8963|     17|    if (ctxt == NULL)
  ------------------
  |  Branch (8963:9): [True: 0, False: 17]
  ------------------
 8964|      0|	return(0);
 8965|     17|    cur = ctxt->cur;
 8966|       |
 8967|       |    /*
 8968|       |     * We are supposed to handle UTF8, check it's valid
 8969|       |     * From rfc2044: encoding of the Unicode values on UTF-8:
 8970|       |     *
 8971|       |     * UCS-4 range (hex.)           UTF-8 octet sequence (binary)
 8972|       |     * 0000 0000-0000 007F   0xxxxxxx
 8973|       |     * 0000 0080-0000 07FF   110xxxxx 10xxxxxx
 8974|       |     * 0000 0800-0000 FFFF   1110xxxx 10xxxxxx 10xxxxxx
 8975|       |     *
 8976|       |     * Check for the 0x110000 limit too
 8977|       |     */
 8978|     17|    c = *cur;
 8979|     17|    if (c & 0x80) {
  ------------------
  |  Branch (8979:9): [True: 0, False: 17]
  ------------------
 8980|      0|	if ((cur[1] & 0xc0) != 0x80)
  ------------------
  |  Branch (8980:6): [True: 0, False: 0]
  ------------------
 8981|      0|	    goto encoding_error;
 8982|      0|	if ((c & 0xe0) == 0xe0) {
  ------------------
  |  Branch (8982:6): [True: 0, False: 0]
  ------------------
 8983|       |
 8984|      0|	    if ((cur[2] & 0xc0) != 0x80)
  ------------------
  |  Branch (8984:10): [True: 0, False: 0]
  ------------------
 8985|      0|		goto encoding_error;
 8986|      0|	    if ((c & 0xf0) == 0xf0) {
  ------------------
  |  Branch (8986:10): [True: 0, False: 0]
  ------------------
 8987|      0|		if (((c & 0xf8) != 0xf0) ||
  ------------------
  |  Branch (8987:7): [True: 0, False: 0]
  ------------------
 8988|      0|		    ((cur[3] & 0xc0) != 0x80))
  ------------------
  |  Branch (8988:7): [True: 0, False: 0]
  ------------------
 8989|      0|		    goto encoding_error;
 8990|       |		/* 4-byte code */
 8991|      0|		*len = 4;
 8992|      0|		val = (cur[0] & 0x7) << 18;
 8993|      0|		val |= (cur[1] & 0x3f) << 12;
 8994|      0|		val |= (cur[2] & 0x3f) << 6;
 8995|      0|		val |= cur[3] & 0x3f;
 8996|      0|	    } else {
 8997|       |	      /* 3-byte code */
 8998|      0|		*len = 3;
 8999|      0|		val = (cur[0] & 0xf) << 12;
 9000|      0|		val |= (cur[1] & 0x3f) << 6;
 9001|      0|		val |= cur[2] & 0x3f;
 9002|      0|	    }
 9003|      0|	} else {
 9004|       |	  /* 2-byte code */
 9005|      0|	    *len = 2;
 9006|      0|	    val = (cur[0] & 0x1f) << 6;
 9007|      0|	    val |= cur[1] & 0x3f;
 9008|      0|	}
 9009|      0|	if (!IS_CHAR(val)) {
  ------------------
  |  |  125|      0|#define IS_CHAR(c)   xmlIsCharQ(c)
  |  |  ------------------
  |  |  |  |  118|      0|#define xmlIsCharQ(c)		(((c) < 0x100) ? \
  |  |  |  |  ------------------
  |  |  |  |  |  Branch (118:25): [True: 0, False: 0]
  |  |  |  |  ------------------
  |  |  |  |  119|      0|				 xmlIsChar_ch((c)) :\
  |  |  |  |  ------------------
  |  |  |  |  |  |  108|      0|#define xmlIsChar_ch(c)		(((0x9 <= (c)) && ((c) <= 0xa)) || \
  |  |  |  |  |  |  ------------------
  |  |  |  |  |  |  |  Branch (108:28): [True: 0, False: 0]
  |  |  |  |  |  |  |  Branch (108:44): [True: 0, False: 0]
  |  |  |  |  |  |  ------------------
  |  |  |  |  |  |  109|      0|				 ((c) == 0xd) || \
  |  |  |  |  |  |  ------------------
  |  |  |  |  |  |  |  Branch (109:6): [True: 0, False: 0]
  |  |  |  |  |  |  ------------------
  |  |  |  |  |  |  110|      0|				  (0x20 <= (c)))
  |  |  |  |  |  |  ------------------
  |  |  |  |  |  |  |  Branch (110:7): [True: 0, False: 0]
  |  |  |  |  |  |  ------------------
  |  |  |  |  ------------------
  |  |  |  |  120|      0|				(((0x100 <= (c)) && ((c) <= 0xd7ff)) || \
  |  |  |  |  ------------------
  |  |  |  |  |  Branch (120:7): [True: 0, False: 0]
  |  |  |  |  |  Branch (120:25): [True: 0, False: 0]
  |  |  |  |  ------------------
  |  |  |  |  121|      0|				 ((0xe000 <= (c)) && ((c) <= 0xfffd)) || \
  |  |  |  |  ------------------
  |  |  |  |  |  Branch (121:7): [True: 0, False: 0]
  |  |  |  |  |  Branch (121:26): [True: 0, False: 0]
  |  |  |  |  ------------------
  |  |  |  |  122|      0|				 ((0x10000 <= (c)) && ((c) <= 0x10ffff))))
  |  |  |  |  ------------------
  |  |  |  |  |  Branch (122:7): [True: 0, False: 0]
  |  |  |  |  |  Branch (122:27): [True: 0, False: 0]
  |  |  |  |  ------------------
  |  |  ------------------
  ------------------
  |  Branch (9009:6): [True: 0, False: 0]
  ------------------
 9010|      0|	    XP_ERROR0(XPATH_INVALID_CHAR_ERROR);
  ------------------
  |  |  267|      0|    { xmlXPathErr(ctxt, X); return(0); }
  ------------------
 9011|      0|	}
 9012|      0|	return(val);
 9013|     17|    } else {
 9014|       |	/* 1-byte code */
 9015|     17|	*len = 1;
 9016|     17|	return(*cur);
 9017|     17|    }
 9018|      0|encoding_error:
 9019|       |    /*
 9020|       |     * If we detect an UTF8 error that probably means that the
 9021|       |     * input encoding didn't get properly advertised in the
 9022|       |     * declaration header. Report the error and switch the encoding
 9023|       |     * to ISO-Latin-1 (if you don't like this policy, just declare the
 9024|       |     * encoding !)
 9025|       |     */
 9026|      0|    *len = 0;
 9027|      0|    XP_ERROR0(XPATH_ENCODING_ERROR);
  ------------------
  |  |  267|      0|    { xmlXPathErr(ctxt, X); return(0); }
  ------------------
 9028|      0|}
xpath.c:xmlXPathTryStreamCompile:
13165|     82|xmlXPathTryStreamCompile(xmlXPathContextPtr ctxt, const xmlChar *str) {
13166|       |    /*
13167|       |     * Optimization: use streaming patterns when the XPath expression can
13168|       |     * be compiled to a stream lookup
13169|       |     */
13170|     82|    xmlPatternPtr stream;
13171|     82|    xmlXPathCompExprPtr comp;
13172|     82|    xmlDictPtr dict = NULL;
13173|     82|    const xmlChar **namespaces = NULL;
13174|     82|    xmlNsPtr ns;
13175|     82|    int i, j;
13176|       |
13177|     82|    if ((!xmlStrchr(str, '[')) && (!xmlStrchr(str, '(')) &&
  ------------------
  |  Branch (13177:9): [True: 80, False: 2]
  |  Branch (13177:35): [True: 80, False: 0]
  ------------------
13178|     82|        (!xmlStrchr(str, '@'))) {
  ------------------
  |  Branch (13178:9): [True: 80, False: 0]
  ------------------
13179|     80|	const xmlChar *tmp;
13180|       |
13181|       |	/*
13182|       |	 * We don't try to handle expressions using the verbose axis
13183|       |	 * specifiers ("::"), just the simplified form at this point.
13184|       |	 * Additionally, if there is no list of namespaces available and
13185|       |	 *  there's a ":" in the expression, indicating a prefixed QName,
13186|       |	 *  then we won't try to compile either. xmlPatterncompile() needs
13187|       |	 *  to have a list of namespaces at compilation time in order to
13188|       |	 *  compile prefixed name tests.
13189|       |	 */
13190|     80|	tmp = xmlStrchr(str, ':');
13191|     80|	if ((tmp != NULL) &&
  ------------------
  |  Branch (13191:6): [True: 0, False: 80]
  ------------------
13192|     80|	    ((ctxt == NULL) || (ctxt->nsNr == 0) || (tmp[1] == ':')))
  ------------------
  |  Branch (13192:7): [True: 0, False: 0]
  |  Branch (13192:25): [True: 0, False: 0]
  |  Branch (13192:46): [True: 0, False: 0]
  ------------------
13193|      0|	    return(NULL);
13194|       |
13195|     80|	if (ctxt != NULL) {
  ------------------
  |  Branch (13195:6): [True: 80, False: 0]
  ------------------
13196|     80|	    dict = ctxt->dict;
13197|     80|	    if (ctxt->nsNr > 0) {
  ------------------
  |  Branch (13197:10): [True: 0, False: 80]
  ------------------
13198|      0|		namespaces = xmlMalloc(2 * (ctxt->nsNr + 1) * sizeof(xmlChar*));
13199|      0|		if (namespaces == NULL) {
  ------------------
  |  Branch (13199:7): [True: 0, False: 0]
  ------------------
13200|      0|		    xmlXPathErrMemory(ctxt, "allocating namespaces array\n");
13201|      0|		    return(NULL);
13202|      0|		}
13203|      0|		for (i = 0, j = 0; (j < ctxt->nsNr); j++) {
  ------------------
  |  Branch (13203:22): [True: 0, False: 0]
  ------------------
13204|      0|		    ns = ctxt->namespaces[j];
13205|      0|		    namespaces[i++] = ns->href;
13206|      0|		    namespaces[i++] = ns->prefix;
13207|      0|		}
13208|      0|		namespaces[i++] = NULL;
13209|      0|		namespaces[i] = NULL;
13210|      0|	    }
13211|     80|	}
13212|       |
13213|     80|	stream = xmlPatterncompile(str, dict, XML_PATTERN_XPATH, namespaces);
13214|     80|	if (namespaces != NULL) {
  ------------------
  |  Branch (13214:6): [True: 0, False: 80]
  ------------------
13215|      0|	    xmlFree((xmlChar **)namespaces);
13216|      0|	}
13217|     80|	if ((stream != NULL) && (xmlPatternStreamable(stream) == 1)) {
  ------------------
  |  Branch (13217:6): [True: 80, False: 0]
  |  Branch (13217:26): [True: 80, False: 0]
  ------------------
13218|     80|	    comp = xmlXPathNewCompExpr();
13219|     80|	    if (comp == NULL) {
  ------------------
  |  Branch (13219:10): [True: 0, False: 80]
  ------------------
13220|      0|		xmlXPathErrMemory(ctxt, "allocating streamable expression\n");
13221|      0|	        xmlFreePattern(stream);
13222|      0|		return(NULL);
13223|      0|	    }
13224|     80|	    comp->stream = stream;
13225|     80|	    comp->dict = dict;
13226|     80|	    if (comp->dict)
  ------------------
  |  Branch (13226:10): [True: 0, False: 80]
  ------------------
13227|      0|		xmlDictReference(comp->dict);
13228|     80|	    return(comp);
13229|     80|	}
13230|      0|	xmlFreePattern(stream);
13231|      0|    }
13232|      2|    return(NULL);
13233|     82|}
xpath.c:xmlXPathCompileExpr:
10186|      4|xmlXPathCompileExpr(xmlXPathParserContextPtr ctxt, int sort) {
10187|      4|    xmlXPathContextPtr xpctxt = ctxt->context;
10188|       |
10189|      4|    if (xpctxt != NULL) {
  ------------------
  |  Branch (10189:9): [True: 4, False: 0]
  ------------------
10190|      4|        if (xpctxt->depth >= XPATH_MAX_RECURSION_DEPTH)
  ------------------
  |  |  124|      4|#define XPATH_MAX_RECURSION_DEPTH 500
  ------------------
  |  Branch (10190:13): [True: 0, False: 4]
  ------------------
10191|      4|            XP_ERROR(XPATH_RECURSION_LIMIT_EXCEEDED);
  ------------------
  |  |  258|      0|    { xmlXPathErr(ctxt, X); return; }
  ------------------
10192|       |        /*
10193|       |         * Parsing a single '(' pushes about 10 functions on the call stack
10194|       |         * before recursing!
10195|       |         */
10196|      4|        xpctxt->depth += 10;
10197|      4|    }
10198|       |
10199|      4|    xmlXPathCompAndExpr(ctxt);
10200|      4|    CHECK_ERROR;
  ------------------
  |  |  241|      4|    if (ctxt->error != XPATH_EXPRESSION_OK) return
  |  |  ------------------
  |  |  |  Branch (241:9): [True: 0, False: 4]
  |  |  ------------------
  ------------------
10201|      4|    SKIP_BLANKS;
  ------------------
  |  | 2509|      4|    while (IS_BLANK_CH(*(ctxt->cur))) NEXT
  |  |  ------------------
  |  |  |  | 2512|      4|#define NEXT ((*ctxt->cur) ?  ctxt->cur++: ctxt->cur)
  |  |  |  |  ------------------
  |  |  |  |  |  Branch (2512:15): [True: 0, False: 0]
  |  |  |  |  ------------------
  |  |  ------------------
  ------------------
10202|      4|    while ((CUR == 'o') && (NXT(1) == 'r')) {
  ------------------
  |  | 2496|      4|#define CUR (*ctxt->cur)
  ------------------
                  while ((CUR == 'o') && (NXT(1) == 'r')) {
  ------------------
  |  | 2498|      0|#define NXT(val) ctxt->cur[(val)]
  ------------------
  |  Branch (10202:12): [True: 0, False: 4]
  |  Branch (10202:28): [True: 0, False: 0]
  ------------------
10203|      0|	int op1 = ctxt->comp->last;
10204|      0|        SKIP(2);
  ------------------
  |  | 2497|      0|#define SKIP(val) ctxt->cur += (val)
  ------------------
10205|      0|	SKIP_BLANKS;
  ------------------
  |  | 2509|      0|    while (IS_BLANK_CH(*(ctxt->cur))) NEXT
  |  |  ------------------
  |  |  |  | 2512|      0|#define NEXT ((*ctxt->cur) ?  ctxt->cur++: ctxt->cur)
  |  |  |  |  ------------------
  |  |  |  |  |  Branch (2512:15): [True: 0, False: 0]
  |  |  |  |  ------------------
  |  |  ------------------
  ------------------
10206|      0|        xmlXPathCompAndExpr(ctxt);
10207|      0|	CHECK_ERROR;
  ------------------
  |  |  241|      0|    if (ctxt->error != XPATH_EXPRESSION_OK) return
  |  |  ------------------
  |  |  |  Branch (241:9): [True: 0, False: 0]
  |  |  ------------------
  ------------------
10208|      0|	PUSH_BINARY_EXPR(XPATH_OP_OR, op1, ctxt->comp->last, 0, 0);
  ------------------
  |  | 1194|      0|#define PUSH_BINARY_EXPR(op, ch1, ch2, val, val2)			\
  |  | 1195|      0|xmlXPathCompExprAdd(ctxt, (ch1), (ch2), (op),			\
  |  | 1196|      0|			(val), (val2), 0 ,NULL ,NULL)
  ------------------
10209|      0|	SKIP_BLANKS;
  ------------------
  |  | 2509|      0|    while (IS_BLANK_CH(*(ctxt->cur))) NEXT
  |  |  ------------------
  |  |  |  | 2512|      0|#define NEXT ((*ctxt->cur) ?  ctxt->cur++: ctxt->cur)
  |  |  |  |  ------------------
  |  |  |  |  |  Branch (2512:15): [True: 0, False: 0]
  |  |  |  |  ------------------
  |  |  ------------------
  ------------------
10210|      0|    }
10211|      4|    if ((sort) && (ctxt->comp->steps[ctxt->comp->last].op != XPATH_OP_VALUE)) {
  ------------------
  |  Branch (10211:9): [True: 2, False: 2]
  |  Branch (10211:19): [True: 2, False: 0]
  ------------------
10212|       |	/* more ops could be optimized too */
10213|       |	/*
10214|       |	* This is the main place to eliminate sorting for
10215|       |	* operations which don't require a sorted node-set.
10216|       |	* E.g. count().
10217|       |	*/
10218|      2|	PUSH_UNARY_EXPR(XPATH_OP_SORT, ctxt->comp->last , 0, 0);
  ------------------
  |  | 1191|      2|#define PUSH_UNARY_EXPR(op, ch, val, val2)				\
  |  | 1192|      2|xmlXPathCompExprAdd(ctxt, (ch), -1, (op), (val), (val2), 0 ,NULL ,NULL)
  ------------------
10219|      2|    }
10220|       |
10221|      4|    if (xpctxt != NULL)
  ------------------
  |  Branch (10221:9): [True: 4, False: 0]
  ------------------
10222|      4|        xpctxt->depth -= 10;
10223|      4|}
xpath.c:xmlXPathCompAndExpr:
10160|      4|xmlXPathCompAndExpr(xmlXPathParserContextPtr ctxt) {
10161|      4|    xmlXPathCompEqualityExpr(ctxt);
10162|      4|    CHECK_ERROR;
  ------------------
  |  |  241|      4|    if (ctxt->error != XPATH_EXPRESSION_OK) return
  |  |  ------------------
  |  |  |  Branch (241:9): [True: 0, False: 4]
  |  |  ------------------
  ------------------
10163|      4|    SKIP_BLANKS;
  ------------------
  |  | 2509|      4|    while (IS_BLANK_CH(*(ctxt->cur))) NEXT
  |  |  ------------------
  |  |  |  | 2512|      4|#define NEXT ((*ctxt->cur) ?  ctxt->cur++: ctxt->cur)
  |  |  |  |  ------------------
  |  |  |  |  |  Branch (2512:15): [True: 0, False: 0]
  |  |  |  |  ------------------
  |  |  ------------------
  ------------------
10164|      4|    while ((CUR == 'a') && (NXT(1) == 'n') && (NXT(2) == 'd')) {
  ------------------
  |  | 2496|      4|#define CUR (*ctxt->cur)
  ------------------
                  while ((CUR == 'a') && (NXT(1) == 'n') && (NXT(2) == 'd')) {
  ------------------
  |  | 2498|      0|#define NXT(val) ctxt->cur[(val)]
  ------------------
                  while ((CUR == 'a') && (NXT(1) == 'n') && (NXT(2) == 'd')) {
  ------------------
  |  | 2498|      0|#define NXT(val) ctxt->cur[(val)]
  ------------------
  |  Branch (10164:12): [True: 0, False: 4]
  |  Branch (10164:28): [True: 0, False: 0]
  |  Branch (10164:47): [True: 0, False: 0]
  ------------------
10165|      0|	int op1 = ctxt->comp->last;
10166|      0|        SKIP(3);
  ------------------
  |  | 2497|      0|#define SKIP(val) ctxt->cur += (val)
  ------------------
10167|      0|	SKIP_BLANKS;
  ------------------
  |  | 2509|      0|    while (IS_BLANK_CH(*(ctxt->cur))) NEXT
  |  |  ------------------
  |  |  |  | 2512|      0|#define NEXT ((*ctxt->cur) ?  ctxt->cur++: ctxt->cur)
  |  |  |  |  ------------------
  |  |  |  |  |  Branch (2512:15): [True: 0, False: 0]
  |  |  |  |  ------------------
  |  |  ------------------
  ------------------
10168|      0|        xmlXPathCompEqualityExpr(ctxt);
10169|      0|	CHECK_ERROR;
  ------------------
  |  |  241|      0|    if (ctxt->error != XPATH_EXPRESSION_OK) return
  |  |  ------------------
  |  |  |  Branch (241:9): [True: 0, False: 0]
  |  |  ------------------
  ------------------
10170|      0|	PUSH_BINARY_EXPR(XPATH_OP_AND, op1, ctxt->comp->last, 0, 0);
  ------------------
  |  | 1194|      0|#define PUSH_BINARY_EXPR(op, ch1, ch2, val, val2)			\
  |  | 1195|      0|xmlXPathCompExprAdd(ctxt, (ch1), (ch2), (op),			\
  |  | 1196|      0|			(val), (val2), 0 ,NULL ,NULL)
  ------------------
10171|      0|	SKIP_BLANKS;
  ------------------
  |  | 2509|      0|    while (IS_BLANK_CH(*(ctxt->cur))) NEXT
  |  |  ------------------
  |  |  |  | 2512|      0|#define NEXT ((*ctxt->cur) ?  ctxt->cur++: ctxt->cur)
  |  |  |  |  ------------------
  |  |  |  |  |  Branch (2512:15): [True: 0, False: 0]
  |  |  |  |  ------------------
  |  |  ------------------
  ------------------
10172|      0|    }
10173|      4|}
xpath.c:xmlXPathCompEqualityExpr:
10129|      4|xmlXPathCompEqualityExpr(xmlXPathParserContextPtr ctxt) {
10130|      4|    xmlXPathCompRelationalExpr(ctxt);
10131|      4|    CHECK_ERROR;
  ------------------
  |  |  241|      4|    if (ctxt->error != XPATH_EXPRESSION_OK) return
  |  |  ------------------
  |  |  |  Branch (241:9): [True: 0, False: 4]
  |  |  ------------------
  ------------------
10132|      4|    SKIP_BLANKS;
  ------------------
  |  | 2509|      4|    while (IS_BLANK_CH(*(ctxt->cur))) NEXT
  |  |  ------------------
  |  |  |  | 2512|      4|#define NEXT ((*ctxt->cur) ?  ctxt->cur++: ctxt->cur)
  |  |  |  |  ------------------
  |  |  |  |  |  Branch (2512:15): [True: 0, False: 0]
  |  |  |  |  ------------------
  |  |  ------------------
  ------------------
10133|      4|    while ((CUR == '=') || ((CUR == '!') && (NXT(1) == '='))) {
  ------------------
  |  | 2496|      4|#define CUR (*ctxt->cur)
  ------------------
                  while ((CUR == '=') || ((CUR == '!') && (NXT(1) == '='))) {
  ------------------
  |  | 2496|      4|#define CUR (*ctxt->cur)
  ------------------
                  while ((CUR == '=') || ((CUR == '!') && (NXT(1) == '='))) {
  ------------------
  |  | 2498|      0|#define NXT(val) ctxt->cur[(val)]
  ------------------
  |  Branch (10133:12): [True: 0, False: 4]
  |  Branch (10133:29): [True: 0, False: 4]
  |  Branch (10133:45): [True: 0, False: 0]
  ------------------
10134|      0|	int eq;
10135|      0|	int op1 = ctxt->comp->last;
10136|       |
10137|      0|        if (CUR == '=') eq = 1;
  ------------------
  |  | 2496|      0|#define CUR (*ctxt->cur)
  ------------------
  |  Branch (10137:13): [True: 0, False: 0]
  ------------------
10138|      0|	else eq = 0;
10139|      0|	NEXT;
  ------------------
  |  | 2512|      0|#define NEXT ((*ctxt->cur) ?  ctxt->cur++: ctxt->cur)
  |  |  ------------------
  |  |  |  Branch (2512:15): [True: 0, False: 0]
  |  |  ------------------
  ------------------
10140|      0|	if (!eq) NEXT;
  ------------------
  |  | 2512|      0|#define NEXT ((*ctxt->cur) ?  ctxt->cur++: ctxt->cur)
  |  |  ------------------
  |  |  |  Branch (2512:15): [True: 0, False: 0]
  |  |  ------------------
  ------------------
  |  Branch (10140:6): [True: 0, False: 0]
  ------------------
10141|      0|	SKIP_BLANKS;
  ------------------
  |  | 2509|      0|    while (IS_BLANK_CH(*(ctxt->cur))) NEXT
  |  |  ------------------
  |  |  |  | 2512|      0|#define NEXT ((*ctxt->cur) ?  ctxt->cur++: ctxt->cur)
  |  |  |  |  ------------------
  |  |  |  |  |  Branch (2512:15): [True: 0, False: 0]
  |  |  |  |  ------------------
  |  |  ------------------
  ------------------
10142|      0|        xmlXPathCompRelationalExpr(ctxt);
10143|      0|	CHECK_ERROR;
  ------------------
  |  |  241|      0|    if (ctxt->error != XPATH_EXPRESSION_OK) return
  |  |  ------------------
  |  |  |  Branch (241:9): [True: 0, False: 0]
  |  |  ------------------
  ------------------
10144|      0|	PUSH_BINARY_EXPR(XPATH_OP_EQUAL, op1, ctxt->comp->last, eq, 0);
  ------------------
  |  | 1194|      0|#define PUSH_BINARY_EXPR(op, ch1, ch2, val, val2)			\
  |  | 1195|      0|xmlXPathCompExprAdd(ctxt, (ch1), (ch2), (op),			\
  |  | 1196|      0|			(val), (val2), 0 ,NULL ,NULL)
  ------------------
10145|      0|	SKIP_BLANKS;
  ------------------
  |  | 2509|      0|    while (IS_BLANK_CH(*(ctxt->cur))) NEXT
  |  |  ------------------
  |  |  |  | 2512|      0|#define NEXT ((*ctxt->cur) ?  ctxt->cur++: ctxt->cur)
  |  |  |  |  ------------------
  |  |  |  |  |  Branch (2512:15): [True: 0, False: 0]
  |  |  |  |  ------------------
  |  |  ------------------
  ------------------
10146|      0|    }
10147|      4|}
xpath.c:xmlXPathCompRelationalExpr:
10090|      4|xmlXPathCompRelationalExpr(xmlXPathParserContextPtr ctxt) {
10091|      4|    xmlXPathCompAdditiveExpr(ctxt);
10092|      4|    CHECK_ERROR;
  ------------------
  |  |  241|      4|    if (ctxt->error != XPATH_EXPRESSION_OK) return
  |  |  ------------------
  |  |  |  Branch (241:9): [True: 0, False: 4]
  |  |  ------------------
  ------------------
10093|      4|    SKIP_BLANKS;
  ------------------
  |  | 2509|      4|    while (IS_BLANK_CH(*(ctxt->cur))) NEXT
  |  |  ------------------
  |  |  |  | 2512|      4|#define NEXT ((*ctxt->cur) ?  ctxt->cur++: ctxt->cur)
  |  |  |  |  ------------------
  |  |  |  |  |  Branch (2512:15): [True: 0, False: 0]
  |  |  |  |  ------------------
  |  |  ------------------
  ------------------
10094|      4|    while ((CUR == '<') || (CUR == '>')) {
  ------------------
  |  | 2496|      4|#define CUR (*ctxt->cur)
  ------------------
                  while ((CUR == '<') || (CUR == '>')) {
  ------------------
  |  | 2496|      4|#define CUR (*ctxt->cur)
  ------------------
  |  Branch (10094:12): [True: 0, False: 4]
  |  Branch (10094:28): [True: 0, False: 4]
  ------------------
10095|      0|	int inf, strict;
10096|      0|	int op1 = ctxt->comp->last;
10097|       |
10098|      0|        if (CUR == '<') inf = 1;
  ------------------
  |  | 2496|      0|#define CUR (*ctxt->cur)
  ------------------
  |  Branch (10098:13): [True: 0, False: 0]
  ------------------
10099|      0|	else inf = 0;
10100|      0|	if (NXT(1) == '=') strict = 0;
  ------------------
  |  | 2498|      0|#define NXT(val) ctxt->cur[(val)]
  ------------------
  |  Branch (10100:6): [True: 0, False: 0]
  ------------------
10101|      0|	else strict = 1;
10102|      0|	NEXT;
  ------------------
  |  | 2512|      0|#define NEXT ((*ctxt->cur) ?  ctxt->cur++: ctxt->cur)
  |  |  ------------------
  |  |  |  Branch (2512:15): [True: 0, False: 0]
  |  |  ------------------
  ------------------
10103|      0|	if (!strict) NEXT;
  ------------------
  |  | 2512|      0|#define NEXT ((*ctxt->cur) ?  ctxt->cur++: ctxt->cur)
  |  |  ------------------
  |  |  |  Branch (2512:15): [True: 0, False: 0]
  |  |  ------------------
  ------------------
  |  Branch (10103:6): [True: 0, False: 0]
  ------------------
10104|      0|	SKIP_BLANKS;
  ------------------
  |  | 2509|      0|    while (IS_BLANK_CH(*(ctxt->cur))) NEXT
  |  |  ------------------
  |  |  |  | 2512|      0|#define NEXT ((*ctxt->cur) ?  ctxt->cur++: ctxt->cur)
  |  |  |  |  ------------------
  |  |  |  |  |  Branch (2512:15): [True: 0, False: 0]
  |  |  |  |  ------------------
  |  |  ------------------
  ------------------
10105|      0|        xmlXPathCompAdditiveExpr(ctxt);
10106|      0|	CHECK_ERROR;
  ------------------
  |  |  241|      0|    if (ctxt->error != XPATH_EXPRESSION_OK) return
  |  |  ------------------
  |  |  |  Branch (241:9): [True: 0, False: 0]
  |  |  ------------------
  ------------------
10107|      0|	PUSH_BINARY_EXPR(XPATH_OP_CMP, op1, ctxt->comp->last, inf, strict);
  ------------------
  |  | 1194|      0|#define PUSH_BINARY_EXPR(op, ch1, ch2, val, val2)			\
  |  | 1195|      0|xmlXPathCompExprAdd(ctxt, (ch1), (ch2), (op),			\
  |  | 1196|      0|			(val), (val2), 0 ,NULL ,NULL)
  ------------------
10108|      0|	SKIP_BLANKS;
  ------------------
  |  | 2509|      0|    while (IS_BLANK_CH(*(ctxt->cur))) NEXT
  |  |  ------------------
  |  |  |  | 2512|      0|#define NEXT ((*ctxt->cur) ?  ctxt->cur++: ctxt->cur)
  |  |  |  |  ------------------
  |  |  |  |  |  Branch (2512:15): [True: 0, False: 0]
  |  |  |  |  ------------------
  |  |  ------------------
  ------------------
10109|      0|    }
10110|      4|}
xpath.c:xmlXPathCompAdditiveExpr:
10051|      4|xmlXPathCompAdditiveExpr(xmlXPathParserContextPtr ctxt) {
10052|       |
10053|      4|    xmlXPathCompMultiplicativeExpr(ctxt);
10054|      4|    CHECK_ERROR;
  ------------------
  |  |  241|      4|    if (ctxt->error != XPATH_EXPRESSION_OK) return
  |  |  ------------------
  |  |  |  Branch (241:9): [True: 0, False: 4]
  |  |  ------------------
  ------------------
10055|      4|    SKIP_BLANKS;
  ------------------
  |  | 2509|      4|    while (IS_BLANK_CH(*(ctxt->cur))) NEXT
  |  |  ------------------
  |  |  |  | 2512|      4|#define NEXT ((*ctxt->cur) ?  ctxt->cur++: ctxt->cur)
  |  |  |  |  ------------------
  |  |  |  |  |  Branch (2512:15): [True: 0, False: 0]
  |  |  |  |  ------------------
  |  |  ------------------
  ------------------
10056|      4|    while ((CUR == '+') || (CUR == '-')) {
  ------------------
  |  | 2496|      4|#define CUR (*ctxt->cur)
  ------------------
                  while ((CUR == '+') || (CUR == '-')) {
  ------------------
  |  | 2496|      4|#define CUR (*ctxt->cur)
  ------------------
  |  Branch (10056:12): [True: 0, False: 4]
  |  Branch (10056:28): [True: 0, False: 4]
  ------------------
10057|      0|	int plus;
10058|      0|	int op1 = ctxt->comp->last;
10059|       |
10060|      0|        if (CUR == '+') plus = 1;
  ------------------
  |  | 2496|      0|#define CUR (*ctxt->cur)
  ------------------
  |  Branch (10060:13): [True: 0, False: 0]
  ------------------
10061|      0|	else plus = 0;
10062|      0|	NEXT;
  ------------------
  |  | 2512|      0|#define NEXT ((*ctxt->cur) ?  ctxt->cur++: ctxt->cur)
  |  |  ------------------
  |  |  |  Branch (2512:15): [True: 0, False: 0]
  |  |  ------------------
  ------------------
10063|      0|	SKIP_BLANKS;
  ------------------
  |  | 2509|      0|    while (IS_BLANK_CH(*(ctxt->cur))) NEXT
  |  |  ------------------
  |  |  |  | 2512|      0|#define NEXT ((*ctxt->cur) ?  ctxt->cur++: ctxt->cur)
  |  |  |  |  ------------------
  |  |  |  |  |  Branch (2512:15): [True: 0, False: 0]
  |  |  |  |  ------------------
  |  |  ------------------
  ------------------
10064|      0|        xmlXPathCompMultiplicativeExpr(ctxt);
10065|      0|	CHECK_ERROR;
  ------------------
  |  |  241|      0|    if (ctxt->error != XPATH_EXPRESSION_OK) return
  |  |  ------------------
  |  |  |  Branch (241:9): [True: 0, False: 0]
  |  |  ------------------
  ------------------
10066|      0|	PUSH_BINARY_EXPR(XPATH_OP_PLUS, op1, ctxt->comp->last, plus, 0);
  ------------------
  |  | 1194|      0|#define PUSH_BINARY_EXPR(op, ch1, ch2, val, val2)			\
  |  | 1195|      0|xmlXPathCompExprAdd(ctxt, (ch1), (ch2), (op),			\
  |  | 1196|      0|			(val), (val2), 0 ,NULL ,NULL)
  ------------------
10067|      0|	SKIP_BLANKS;
  ------------------
  |  | 2509|      0|    while (IS_BLANK_CH(*(ctxt->cur))) NEXT
  |  |  ------------------
  |  |  |  | 2512|      0|#define NEXT ((*ctxt->cur) ?  ctxt->cur++: ctxt->cur)
  |  |  |  |  ------------------
  |  |  |  |  |  Branch (2512:15): [True: 0, False: 0]
  |  |  |  |  ------------------
  |  |  ------------------
  ------------------
10068|      0|    }
10069|      4|}
xpath.c:xmlXPathCompMultiplicativeExpr:
10011|      4|xmlXPathCompMultiplicativeExpr(xmlXPathParserContextPtr ctxt) {
10012|      4|    xmlXPathCompUnaryExpr(ctxt);
10013|      4|    CHECK_ERROR;
  ------------------
  |  |  241|      4|    if (ctxt->error != XPATH_EXPRESSION_OK) return
  |  |  ------------------
  |  |  |  Branch (241:9): [True: 0, False: 4]
  |  |  ------------------
  ------------------
10014|      4|    SKIP_BLANKS;
  ------------------
  |  | 2509|      4|    while (IS_BLANK_CH(*(ctxt->cur))) NEXT
  |  |  ------------------
  |  |  |  | 2512|      4|#define NEXT ((*ctxt->cur) ?  ctxt->cur++: ctxt->cur)
  |  |  |  |  ------------------
  |  |  |  |  |  Branch (2512:15): [True: 0, False: 0]
  |  |  |  |  ------------------
  |  |  ------------------
  ------------------
10015|      4|    while ((CUR == '*') ||
  ------------------
  |  | 2496|      4|#define CUR (*ctxt->cur)
  ------------------
  |  Branch (10015:12): [True: 0, False: 4]
  ------------------
10016|      4|           ((CUR == 'd') && (NXT(1) == 'i') && (NXT(2) == 'v')) ||
  ------------------
  |  | 2496|      4|#define CUR (*ctxt->cur)
  ------------------
                         ((CUR == 'd') && (NXT(1) == 'i') && (NXT(2) == 'v')) ||
  ------------------
  |  | 2498|      0|#define NXT(val) ctxt->cur[(val)]
  ------------------
                         ((CUR == 'd') && (NXT(1) == 'i') && (NXT(2) == 'v')) ||
  ------------------
  |  | 2498|      0|#define NXT(val) ctxt->cur[(val)]
  ------------------
  |  Branch (10016:13): [True: 0, False: 4]
  |  Branch (10016:29): [True: 0, False: 0]
  |  Branch (10016:48): [True: 0, False: 0]
  ------------------
10017|      4|           ((CUR == 'm') && (NXT(1) == 'o') && (NXT(2) == 'd'))) {
  ------------------
  |  | 2496|      4|#define CUR (*ctxt->cur)
  ------------------
                         ((CUR == 'm') && (NXT(1) == 'o') && (NXT(2) == 'd'))) {
  ------------------
  |  | 2498|      0|#define NXT(val) ctxt->cur[(val)]
  ------------------
                         ((CUR == 'm') && (NXT(1) == 'o') && (NXT(2) == 'd'))) {
  ------------------
  |  | 2498|      0|#define NXT(val) ctxt->cur[(val)]
  ------------------
  |  Branch (10017:13): [True: 0, False: 4]
  |  Branch (10017:29): [True: 0, False: 0]
  |  Branch (10017:48): [True: 0, False: 0]
  ------------------
10018|      0|	int op = -1;
10019|      0|	int op1 = ctxt->comp->last;
10020|       |
10021|      0|        if (CUR == '*') {
  ------------------
  |  | 2496|      0|#define CUR (*ctxt->cur)
  ------------------
  |  Branch (10021:13): [True: 0, False: 0]
  ------------------
10022|      0|	    op = 0;
10023|      0|	    NEXT;
  ------------------
  |  | 2512|      0|#define NEXT ((*ctxt->cur) ?  ctxt->cur++: ctxt->cur)
  |  |  ------------------
  |  |  |  Branch (2512:15): [True: 0, False: 0]
  |  |  ------------------
  ------------------
10024|      0|	} else if (CUR == 'd') {
  ------------------
  |  | 2496|      0|#define CUR (*ctxt->cur)
  ------------------
  |  Branch (10024:13): [True: 0, False: 0]
  ------------------
10025|      0|	    op = 1;
10026|      0|	    SKIP(3);
  ------------------
  |  | 2497|      0|#define SKIP(val) ctxt->cur += (val)
  ------------------
10027|      0|	} else if (CUR == 'm') {
  ------------------
  |  | 2496|      0|#define CUR (*ctxt->cur)
  ------------------
  |  Branch (10027:13): [True: 0, False: 0]
  ------------------
10028|      0|	    op = 2;
10029|      0|	    SKIP(3);
  ------------------
  |  | 2497|      0|#define SKIP(val) ctxt->cur += (val)
  ------------------
10030|      0|	}
10031|      0|	SKIP_BLANKS;
  ------------------
  |  | 2509|      0|    while (IS_BLANK_CH(*(ctxt->cur))) NEXT
  |  |  ------------------
  |  |  |  | 2512|      0|#define NEXT ((*ctxt->cur) ?  ctxt->cur++: ctxt->cur)
  |  |  |  |  ------------------
  |  |  |  |  |  Branch (2512:15): [True: 0, False: 0]
  |  |  |  |  ------------------
  |  |  ------------------
  ------------------
10032|      0|        xmlXPathCompUnaryExpr(ctxt);
10033|      0|	CHECK_ERROR;
  ------------------
  |  |  241|      0|    if (ctxt->error != XPATH_EXPRESSION_OK) return
  |  |  ------------------
  |  |  |  Branch (241:9): [True: 0, False: 0]
  |  |  ------------------
  ------------------
10034|      0|	PUSH_BINARY_EXPR(XPATH_OP_MULT, op1, ctxt->comp->last, op, 0);
  ------------------
  |  | 1194|      0|#define PUSH_BINARY_EXPR(op, ch1, ch2, val, val2)			\
  |  | 1195|      0|xmlXPathCompExprAdd(ctxt, (ch1), (ch2), (op),			\
  |  | 1196|      0|			(val), (val2), 0 ,NULL ,NULL)
  ------------------
10035|      0|	SKIP_BLANKS;
  ------------------
  |  | 2509|      0|    while (IS_BLANK_CH(*(ctxt->cur))) NEXT
  |  |  ------------------
  |  |  |  | 2512|      0|#define NEXT ((*ctxt->cur) ?  ctxt->cur++: ctxt->cur)
  |  |  |  |  ------------------
  |  |  |  |  |  Branch (2512:15): [True: 0, False: 0]
  |  |  |  |  ------------------
  |  |  ------------------
  ------------------
10036|      0|    }
10037|      4|}
xpath.c:xmlXPathCompUnaryExpr:
 9975|      4|xmlXPathCompUnaryExpr(xmlXPathParserContextPtr ctxt) {
 9976|      4|    int minus = 0;
 9977|      4|    int found = 0;
 9978|       |
 9979|      4|    SKIP_BLANKS;
  ------------------
  |  | 2509|      4|    while (IS_BLANK_CH(*(ctxt->cur))) NEXT
  |  |  ------------------
  |  |  |  | 2512|      0|#define NEXT ((*ctxt->cur) ?  ctxt->cur++: ctxt->cur)
  |  |  |  |  ------------------
  |  |  |  |  |  Branch (2512:15): [True: 0, False: 0]
  |  |  |  |  ------------------
  |  |  ------------------
  ------------------
 9980|      4|    while (CUR == '-') {
  ------------------
  |  | 2496|      4|#define CUR (*ctxt->cur)
  ------------------
  |  Branch (9980:12): [True: 0, False: 4]
  ------------------
 9981|      0|        minus = 1 - minus;
 9982|      0|	found = 1;
 9983|      0|	NEXT;
  ------------------
  |  | 2512|      0|#define NEXT ((*ctxt->cur) ?  ctxt->cur++: ctxt->cur)
  |  |  ------------------
  |  |  |  Branch (2512:15): [True: 0, False: 0]
  |  |  ------------------
  ------------------
 9984|      0|	SKIP_BLANKS;
  ------------------
  |  | 2509|      0|    while (IS_BLANK_CH(*(ctxt->cur))) NEXT
  |  |  ------------------
  |  |  |  | 2512|      0|#define NEXT ((*ctxt->cur) ?  ctxt->cur++: ctxt->cur)
  |  |  |  |  ------------------
  |  |  |  |  |  Branch (2512:15): [True: 0, False: 0]
  |  |  |  |  ------------------
  |  |  ------------------
  ------------------
 9985|      0|    }
 9986|       |
 9987|      4|    xmlXPathCompUnionExpr(ctxt);
 9988|      4|    CHECK_ERROR;
  ------------------
  |  |  241|      4|    if (ctxt->error != XPATH_EXPRESSION_OK) return
  |  |  ------------------
  |  |  |  Branch (241:9): [True: 0, False: 4]
  |  |  ------------------
  ------------------
 9989|      4|    if (found) {
  ------------------
  |  Branch (9989:9): [True: 0, False: 4]
  ------------------
 9990|      0|	if (minus)
  ------------------
  |  Branch (9990:6): [True: 0, False: 0]
  ------------------
 9991|      0|	    PUSH_UNARY_EXPR(XPATH_OP_PLUS, ctxt->comp->last, 2, 0);
  ------------------
  |  | 1191|      0|#define PUSH_UNARY_EXPR(op, ch, val, val2)				\
  |  | 1192|      0|xmlXPathCompExprAdd(ctxt, (ch), -1, (op), (val), (val2), 0 ,NULL ,NULL)
  ------------------
 9992|      0|	else
 9993|      0|	    PUSH_UNARY_EXPR(XPATH_OP_PLUS, ctxt->comp->last, 3, 0);
  ------------------
  |  | 1191|      0|#define PUSH_UNARY_EXPR(op, ch, val, val2)				\
  |  | 1192|      0|xmlXPathCompExprAdd(ctxt, (ch), -1, (op), (val), (val2), 0 ,NULL ,NULL)
  ------------------
 9994|      0|    }
 9995|      4|}
xpath.c:xmlXPathCompUnionExpr:
 9946|      4|xmlXPathCompUnionExpr(xmlXPathParserContextPtr ctxt) {
 9947|      4|    xmlXPathCompPathExpr(ctxt);
 9948|      4|    CHECK_ERROR;
  ------------------
  |  |  241|      4|    if (ctxt->error != XPATH_EXPRESSION_OK) return
  |  |  ------------------
  |  |  |  Branch (241:9): [True: 0, False: 4]
  |  |  ------------------
  ------------------
 9949|      4|    SKIP_BLANKS;
  ------------------
  |  | 2509|      4|    while (IS_BLANK_CH(*(ctxt->cur))) NEXT
  |  |  ------------------
  |  |  |  | 2512|      4|#define NEXT ((*ctxt->cur) ?  ctxt->cur++: ctxt->cur)
  |  |  |  |  ------------------
  |  |  |  |  |  Branch (2512:15): [True: 0, False: 0]
  |  |  |  |  ------------------
  |  |  ------------------
  ------------------
 9950|      4|    while (CUR == '|') {
  ------------------
  |  | 2496|      4|#define CUR (*ctxt->cur)
  ------------------
  |  Branch (9950:12): [True: 0, False: 4]
  ------------------
 9951|      0|	int op1 = ctxt->comp->last;
 9952|      0|	PUSH_LEAVE_EXPR(XPATH_OP_NODE, 0, 0);
  ------------------
  |  | 1188|      0|#define PUSH_LEAVE_EXPR(op, val, val2)					\
  |  | 1189|      0|xmlXPathCompExprAdd(ctxt, -1, -1, (op), (val), (val2), 0 ,NULL ,NULL)
  ------------------
 9953|       |
 9954|      0|	NEXT;
  ------------------
  |  | 2512|      0|#define NEXT ((*ctxt->cur) ?  ctxt->cur++: ctxt->cur)
  |  |  ------------------
  |  |  |  Branch (2512:15): [True: 0, False: 0]
  |  |  ------------------
  ------------------
 9955|      0|	SKIP_BLANKS;
  ------------------
  |  | 2509|      0|    while (IS_BLANK_CH(*(ctxt->cur))) NEXT
  |  |  ------------------
  |  |  |  | 2512|      0|#define NEXT ((*ctxt->cur) ?  ctxt->cur++: ctxt->cur)
  |  |  |  |  ------------------
  |  |  |  |  |  Branch (2512:15): [True: 0, False: 0]
  |  |  |  |  ------------------
  |  |  ------------------
  ------------------
 9956|      0|	xmlXPathCompPathExpr(ctxt);
 9957|       |
 9958|      0|	PUSH_BINARY_EXPR(XPATH_OP_UNION, op1, ctxt->comp->last, 0, 0);
  ------------------
  |  | 1194|      0|#define PUSH_BINARY_EXPR(op, ch1, ch2, val, val2)			\
  |  | 1195|      0|xmlXPathCompExprAdd(ctxt, (ch1), (ch2), (op),			\
  |  | 1196|      0|			(val), (val2), 0 ,NULL ,NULL)
  ------------------
 9959|       |
 9960|      0|	SKIP_BLANKS;
  ------------------
  |  | 2509|      0|    while (IS_BLANK_CH(*(ctxt->cur))) NEXT
  |  |  ------------------
  |  |  |  | 2512|      0|#define NEXT ((*ctxt->cur) ?  ctxt->cur++: ctxt->cur)
  |  |  |  |  ------------------
  |  |  |  |  |  Branch (2512:15): [True: 0, False: 0]
  |  |  |  |  ------------------
  |  |  ------------------
  ------------------
 9961|      0|    }
 9962|      4|}
xpath.c:xmlXPathCompPathExpr:
 9818|      4|xmlXPathCompPathExpr(xmlXPathParserContextPtr ctxt) {
 9819|      4|    int lc = 1;           /* Should we branch to LocationPath ?         */
 9820|      4|    xmlChar *name = NULL; /* we may have to preparse a name to find out */
 9821|       |
 9822|      4|    SKIP_BLANKS;
  ------------------
  |  | 2509|      4|    while (IS_BLANK_CH(*(ctxt->cur))) NEXT
  |  |  ------------------
  |  |  |  | 2512|      0|#define NEXT ((*ctxt->cur) ?  ctxt->cur++: ctxt->cur)
  |  |  |  |  ------------------
  |  |  |  |  |  Branch (2512:15): [True: 0, False: 0]
  |  |  |  |  ------------------
  |  |  ------------------
  ------------------
 9823|      4|    if ((CUR == '$') || (CUR == '(') ||
  ------------------
  |  | 2496|      4|#define CUR (*ctxt->cur)
  ------------------
                  if ((CUR == '$') || (CUR == '(') ||
  ------------------
  |  | 2496|      4|#define CUR (*ctxt->cur)
  ------------------
  |  Branch (9823:9): [True: 0, False: 4]
  |  Branch (9823:25): [True: 0, False: 4]
  ------------------
 9824|      4|	(IS_ASCII_DIGIT(CUR)) ||
  ------------------
  |  |  268|      4|#define IS_ASCII_DIGIT(c)	((0x30 <= (c)) && ((c) <= 0x39))
  |  |  ------------------
  |  |  |  Branch (268:28): [True: 2, False: 2]
  |  |  |  Branch (268:45): [True: 2, False: 0]
  |  |  ------------------
  ------------------
 9825|      4|        (CUR == '\'') || (CUR == '"') ||
  ------------------
  |  | 2496|      2|#define CUR (*ctxt->cur)
  ------------------
                      (CUR == '\'') || (CUR == '"') ||
  ------------------
  |  | 2496|      2|#define CUR (*ctxt->cur)
  ------------------
  |  Branch (9825:9): [True: 0, False: 2]
  |  Branch (9825:26): [True: 0, False: 2]
  ------------------
 9826|      4|	(CUR == '.' && IS_ASCII_DIGIT(NXT(1)))) {
  ------------------
  |  | 2496|      2|#define CUR (*ctxt->cur)
  ------------------
              	(CUR == '.' && IS_ASCII_DIGIT(NXT(1)))) {
  ------------------
  |  |  268|      0|#define IS_ASCII_DIGIT(c)	((0x30 <= (c)) && ((c) <= 0x39))
  |  |  ------------------
  |  |  |  Branch (268:28): [True: 0, False: 0]
  |  |  |  Branch (268:45): [True: 0, False: 0]
  |  |  ------------------
  ------------------
  |  Branch (9826:3): [True: 0, False: 2]
  ------------------
 9827|      2|	lc = 0;
 9828|      2|    } else if (CUR == '*') {
  ------------------
  |  | 2496|      2|#define CUR (*ctxt->cur)
  ------------------
  |  Branch (9828:16): [True: 0, False: 2]
  ------------------
 9829|       |	/* relative or absolute location path */
 9830|      0|	lc = 1;
 9831|      2|    } else if (CUR == '/') {
  ------------------
  |  | 2496|      2|#define CUR (*ctxt->cur)
  ------------------
  |  Branch (9831:16): [True: 2, False: 0]
  ------------------
 9832|       |	/* relative or absolute location path */
 9833|      2|	lc = 1;
 9834|      2|    } else if (CUR == '@') {
  ------------------
  |  | 2496|      0|#define CUR (*ctxt->cur)
  ------------------
  |  Branch (9834:16): [True: 0, False: 0]
  ------------------
 9835|       |	/* relative abbreviated attribute location path */
 9836|      0|	lc = 1;
 9837|      0|    } else if (CUR == '.') {
  ------------------
  |  | 2496|      0|#define CUR (*ctxt->cur)
  ------------------
  |  Branch (9837:16): [True: 0, False: 0]
  ------------------
 9838|       |	/* relative abbreviated attribute location path */
 9839|      0|	lc = 1;
 9840|      0|    } else {
 9841|       |	/*
 9842|       |	 * Problem is finding if we have a name here whether it's:
 9843|       |	 *   - a nodetype
 9844|       |	 *   - a function call in which case it's followed by '('
 9845|       |	 *   - an axis in which case it's followed by ':'
 9846|       |	 *   - a element name
 9847|       |	 * We do an a priori analysis here rather than having to
 9848|       |	 * maintain parsed token content through the recursive function
 9849|       |	 * calls. This looks uglier but makes the code easier to
 9850|       |	 * read/write/debug.
 9851|       |	 */
 9852|      0|	SKIP_BLANKS;
  ------------------
  |  | 2509|      0|    while (IS_BLANK_CH(*(ctxt->cur))) NEXT
  |  |  ------------------
  |  |  |  | 2512|      0|#define NEXT ((*ctxt->cur) ?  ctxt->cur++: ctxt->cur)
  |  |  |  |  ------------------
  |  |  |  |  |  Branch (2512:15): [True: 0, False: 0]
  |  |  |  |  ------------------
  |  |  ------------------
  ------------------
 9853|      0|	name = xmlXPathScanName(ctxt);
 9854|      0|	if ((name != NULL) && (xmlStrstr(name, (xmlChar *) "::") != NULL)) {
  ------------------
  |  Branch (9854:6): [True: 0, False: 0]
  |  Branch (9854:24): [True: 0, False: 0]
  ------------------
 9855|      0|	    lc = 1;
 9856|      0|	    xmlFree(name);
 9857|      0|	} else if (name != NULL) {
  ------------------
  |  Branch (9857:13): [True: 0, False: 0]
  ------------------
 9858|      0|	    int len =xmlStrlen(name);
 9859|       |
 9860|       |
 9861|      0|	    while (NXT(len) != 0) {
  ------------------
  |  | 2498|      0|#define NXT(val) ctxt->cur[(val)]
  ------------------
  |  Branch (9861:13): [True: 0, False: 0]
  ------------------
 9862|      0|		if (NXT(len) == '/') {
  ------------------
  |  | 2498|      0|#define NXT(val) ctxt->cur[(val)]
  ------------------
  |  Branch (9862:7): [True: 0, False: 0]
  ------------------
 9863|       |		    /* element name */
 9864|      0|		    lc = 1;
 9865|      0|		    break;
 9866|      0|		} else if (IS_BLANK_CH(NXT(len))) {
  ------------------
  |  |  151|      0|#define IS_BLANK_CH(c)  xmlIsBlank_ch(c)
  |  |  ------------------
  |  |  |  |   88|      0|#define xmlIsBlank_ch(c)	(((c) == 0x20) || \
  |  |  |  |  ------------------
  |  |  |  |  |  Branch (88:27): [True: 0, False: 0]
  |  |  |  |  ------------------
  |  |  |  |   89|      0|				 ((0x9 <= (c)) && ((c) <= 0xa)) || \
  |  |  |  |  ------------------
  |  |  |  |  |  Branch (89:7): [True: 0, False: 0]
  |  |  |  |  |  Branch (89:23): [True: 0, False: 0]
  |  |  |  |  ------------------
  |  |  |  |   90|      0|				 ((c) == 0xd))
  |  |  |  |  ------------------
  |  |  |  |  |  Branch (90:6): [True: 0, False: 0]
  |  |  |  |  ------------------
  |  |  ------------------
  ------------------
 9867|       |		    /* ignore blanks */
 9868|      0|		    ;
 9869|      0|		} else if (NXT(len) == ':') {
  ------------------
  |  | 2498|      0|#define NXT(val) ctxt->cur[(val)]
  ------------------
  |  Branch (9869:14): [True: 0, False: 0]
  ------------------
 9870|      0|		    lc = 1;
 9871|      0|		    break;
 9872|      0|		} else if ((NXT(len) == '(')) {
  ------------------
  |  | 2498|      0|#define NXT(val) ctxt->cur[(val)]
  ------------------
  |  Branch (9872:14): [True: 0, False: 0]
  ------------------
 9873|       |		    /* Node Type or Function */
 9874|      0|		    if (xmlXPathIsNodeType(name)) {
  ------------------
  |  Branch (9874:11): [True: 0, False: 0]
  ------------------
 9875|      0|			lc = 1;
 9876|       |#ifdef LIBXML_XPTR_LOCS_ENABLED
 9877|       |                    } else if (ctxt->xptr &&
 9878|       |                               xmlStrEqual(name, BAD_CAST "range-to")) {
 9879|       |                        lc = 1;
 9880|       |#endif
 9881|      0|		    } else {
 9882|      0|			lc = 0;
 9883|      0|		    }
 9884|      0|                    break;
 9885|      0|		} else if ((NXT(len) == '[')) {
  ------------------
  |  | 2498|      0|#define NXT(val) ctxt->cur[(val)]
  ------------------
  |  Branch (9885:14): [True: 0, False: 0]
  ------------------
 9886|       |		    /* element name */
 9887|      0|		    lc = 1;
 9888|      0|		    break;
 9889|      0|		} else if ((NXT(len) == '<') || (NXT(len) == '>') ||
  ------------------
  |  | 2498|      0|#define NXT(val) ctxt->cur[(val)]
  ------------------
              		} else if ((NXT(len) == '<') || (NXT(len) == '>') ||
  ------------------
  |  | 2498|      0|#define NXT(val) ctxt->cur[(val)]
  ------------------
  |  Branch (9889:14): [True: 0, False: 0]
  |  Branch (9889:35): [True: 0, False: 0]
  ------------------
 9890|      0|			   (NXT(len) == '=')) {
  ------------------
  |  | 2498|      0|#define NXT(val) ctxt->cur[(val)]
  ------------------
  |  Branch (9890:7): [True: 0, False: 0]
  ------------------
 9891|      0|		    lc = 1;
 9892|      0|		    break;
 9893|      0|		} else {
 9894|      0|		    lc = 1;
 9895|      0|		    break;
 9896|      0|		}
 9897|      0|		len++;
 9898|      0|	    }
 9899|      0|	    if (NXT(len) == 0) {
  ------------------
  |  | 2498|      0|#define NXT(val) ctxt->cur[(val)]
  ------------------
  |  Branch (9899:10): [True: 0, False: 0]
  ------------------
 9900|       |		/* element name */
 9901|      0|		lc = 1;
 9902|      0|	    }
 9903|      0|	    xmlFree(name);
 9904|      0|	} else {
 9905|       |	    /* make sure all cases are covered explicitly */
 9906|      0|	    XP_ERROR(XPATH_EXPR_ERROR);
  ------------------
  |  |  258|      0|    { xmlXPathErr(ctxt, X); return; }
  ------------------
 9907|      0|	}
 9908|      0|    }
 9909|       |
 9910|      4|    if (lc) {
  ------------------
  |  Branch (9910:9): [True: 2, False: 2]
  ------------------
 9911|      2|	if (CUR == '/') {
  ------------------
  |  | 2496|      2|#define CUR (*ctxt->cur)
  ------------------
  |  Branch (9911:6): [True: 2, False: 0]
  ------------------
 9912|      2|	    PUSH_LEAVE_EXPR(XPATH_OP_ROOT, 0, 0);
  ------------------
  |  | 1188|      2|#define PUSH_LEAVE_EXPR(op, val, val2)					\
  |  | 1189|      2|xmlXPathCompExprAdd(ctxt, -1, -1, (op), (val), (val2), 0 ,NULL ,NULL)
  ------------------
 9913|      2|	} else {
 9914|      0|	    PUSH_LEAVE_EXPR(XPATH_OP_NODE, 0, 0);
  ------------------
  |  | 1188|      0|#define PUSH_LEAVE_EXPR(op, val, val2)					\
  |  | 1189|      0|xmlXPathCompExprAdd(ctxt, -1, -1, (op), (val), (val2), 0 ,NULL ,NULL)
  ------------------
 9915|      0|	}
 9916|      2|	xmlXPathCompLocationPath(ctxt);
 9917|      2|    } else {
 9918|      2|	xmlXPathCompFilterExpr(ctxt);
 9919|      2|	CHECK_ERROR;
  ------------------
  |  |  241|      2|    if (ctxt->error != XPATH_EXPRESSION_OK) return
  |  |  ------------------
  |  |  |  Branch (241:9): [True: 0, False: 2]
  |  |  ------------------
  ------------------
 9920|      2|	if ((CUR == '/') && (NXT(1) == '/')) {
  ------------------
  |  | 2496|      2|#define CUR (*ctxt->cur)
  ------------------
              	if ((CUR == '/') && (NXT(1) == '/')) {
  ------------------
  |  | 2498|      0|#define NXT(val) ctxt->cur[(val)]
  ------------------
  |  Branch (9920:6): [True: 0, False: 2]
  |  Branch (9920:22): [True: 0, False: 0]
  ------------------
 9921|      0|	    SKIP(2);
  ------------------
  |  | 2497|      0|#define SKIP(val) ctxt->cur += (val)
  ------------------
 9922|      0|	    SKIP_BLANKS;
  ------------------
  |  | 2509|      0|    while (IS_BLANK_CH(*(ctxt->cur))) NEXT
  |  |  ------------------
  |  |  |  | 2512|      0|#define NEXT ((*ctxt->cur) ?  ctxt->cur++: ctxt->cur)
  |  |  |  |  ------------------
  |  |  |  |  |  Branch (2512:15): [True: 0, False: 0]
  |  |  |  |  ------------------
  |  |  ------------------
  ------------------
 9923|       |
 9924|      0|	    PUSH_LONG_EXPR(XPATH_OP_COLLECT, AXIS_DESCENDANT_OR_SELF,
  ------------------
  |  | 1185|      0|    xmlXPathCompExprAdd(ctxt, ctxt->comp->last, -1,		\
  |  | 1186|      0|	                (op), (val), (val2), (val3), (val4), (val5))
  ------------------
 9925|      0|		    NODE_TEST_TYPE, NODE_TYPE_NODE, NULL, NULL);
 9926|       |
 9927|      0|	    xmlXPathCompRelativeLocationPath(ctxt);
 9928|      2|	} else if (CUR == '/') {
  ------------------
  |  | 2496|      2|#define CUR (*ctxt->cur)
  ------------------
  |  Branch (9928:13): [True: 0, False: 2]
  ------------------
 9929|      0|	    xmlXPathCompRelativeLocationPath(ctxt);
 9930|      0|	}
 9931|      2|    }
 9932|      4|    SKIP_BLANKS;
  ------------------
  |  | 2509|      4|    while (IS_BLANK_CH(*(ctxt->cur))) NEXT
  |  |  ------------------
  |  |  |  | 2512|      4|#define NEXT ((*ctxt->cur) ?  ctxt->cur++: ctxt->cur)
  |  |  |  |  ------------------
  |  |  |  |  |  Branch (2512:15): [True: 0, False: 0]
  |  |  |  |  ------------------
  |  |  ------------------
  ------------------
 9933|      4|}
xpath.c:xmlXPathCompLocationPath:
10700|      2|xmlXPathCompLocationPath(xmlXPathParserContextPtr ctxt) {
10701|      2|    SKIP_BLANKS;
  ------------------
  |  | 2509|      2|    while (IS_BLANK_CH(*(ctxt->cur))) NEXT
  |  |  ------------------
  |  |  |  | 2512|      0|#define NEXT ((*ctxt->cur) ?  ctxt->cur++: ctxt->cur)
  |  |  |  |  ------------------
  |  |  |  |  |  Branch (2512:15): [True: 0, False: 0]
  |  |  |  |  ------------------
  |  |  ------------------
  ------------------
10702|      2|    if (CUR != '/') {
  ------------------
  |  | 2496|      2|#define CUR (*ctxt->cur)
  ------------------
  |  Branch (10702:9): [True: 0, False: 2]
  ------------------
10703|      0|        xmlXPathCompRelativeLocationPath(ctxt);
10704|      2|    } else {
10705|      4|	while (CUR == '/') {
  ------------------
  |  | 2496|      4|#define CUR (*ctxt->cur)
  ------------------
  |  Branch (10705:9): [True: 2, False: 2]
  ------------------
10706|      2|	    if ((CUR == '/') && (NXT(1) == '/')) {
  ------------------
  |  | 2496|      2|#define CUR (*ctxt->cur)
  ------------------
              	    if ((CUR == '/') && (NXT(1) == '/')) {
  ------------------
  |  | 2498|      2|#define NXT(val) ctxt->cur[(val)]
  ------------------
  |  Branch (10706:10): [True: 2, False: 0]
  |  Branch (10706:26): [True: 0, False: 2]
  ------------------
10707|      0|		SKIP(2);
  ------------------
  |  | 2497|      0|#define SKIP(val) ctxt->cur += (val)
  ------------------
10708|      0|		SKIP_BLANKS;
  ------------------
  |  | 2509|      0|    while (IS_BLANK_CH(*(ctxt->cur))) NEXT
  |  |  ------------------
  |  |  |  | 2512|      0|#define NEXT ((*ctxt->cur) ?  ctxt->cur++: ctxt->cur)
  |  |  |  |  ------------------
  |  |  |  |  |  Branch (2512:15): [True: 0, False: 0]
  |  |  |  |  ------------------
  |  |  ------------------
  ------------------
10709|      0|		PUSH_LONG_EXPR(XPATH_OP_COLLECT, AXIS_DESCENDANT_OR_SELF,
  ------------------
  |  | 1185|      0|    xmlXPathCompExprAdd(ctxt, ctxt->comp->last, -1,		\
  |  | 1186|      0|	                (op), (val), (val2), (val3), (val4), (val5))
  ------------------
10710|      0|			     NODE_TEST_TYPE, NODE_TYPE_NODE, NULL, NULL);
10711|      0|		xmlXPathCompRelativeLocationPath(ctxt);
10712|      2|	    } else if (CUR == '/') {
  ------------------
  |  | 2496|      2|#define CUR (*ctxt->cur)
  ------------------
  |  Branch (10712:17): [True: 2, False: 0]
  ------------------
10713|      2|		NEXT;
  ------------------
  |  | 2512|      2|#define NEXT ((*ctxt->cur) ?  ctxt->cur++: ctxt->cur)
  |  |  ------------------
  |  |  |  Branch (2512:15): [True: 2, False: 0]
  |  |  ------------------
  ------------------
10714|      2|		SKIP_BLANKS;
  ------------------
  |  | 2509|      2|    while (IS_BLANK_CH(*(ctxt->cur))) NEXT
  |  |  ------------------
  |  |  |  | 2512|      0|#define NEXT ((*ctxt->cur) ?  ctxt->cur++: ctxt->cur)
  |  |  |  |  ------------------
  |  |  |  |  |  Branch (2512:15): [True: 0, False: 0]
  |  |  |  |  ------------------
  |  |  ------------------
  ------------------
10715|      2|		if ((CUR != 0 ) &&
  ------------------
  |  | 2496|      2|#define CUR (*ctxt->cur)
  ------------------
  |  Branch (10715:7): [True: 2, False: 0]
  ------------------
10716|      2|		    ((IS_ASCII_LETTER(CUR)) || (CUR == '_') || (CUR == '.') ||
  ------------------
  |  |  258|      2|#define IS_ASCII_LETTER(c)	(((0x41 <= (c)) && ((c) <= 0x5a)) || \
  |  |  ------------------
  |  |  |  Branch (258:30): [True: 2, False: 0]
  |  |  |  Branch (258:47): [True: 0, False: 2]
  |  |  ------------------
  |  |  259|      2|				 ((0x61 <= (c)) && ((c) <= 0x7a)))
  |  |  ------------------
  |  |  |  Branch (259:7): [True: 2, False: 0]
  |  |  |  Branch (259:24): [True: 2, False: 0]
  |  |  ------------------
  ------------------
              		    ((IS_ASCII_LETTER(CUR)) || (CUR == '_') || (CUR == '.') ||
  ------------------
  |  | 2496|      0|#define CUR (*ctxt->cur)
  ------------------
              		    ((IS_ASCII_LETTER(CUR)) || (CUR == '_') || (CUR == '.') ||
  ------------------
  |  | 2496|      0|#define CUR (*ctxt->cur)
  ------------------
  |  Branch (10716:34): [True: 0, False: 0]
  |  Branch (10716:50): [True: 0, False: 0]
  ------------------
10717|      2|		     (CUR == '@') || (CUR == '*')))
  ------------------
  |  | 2496|      0|#define CUR (*ctxt->cur)
  ------------------
              		     (CUR == '@') || (CUR == '*')))
  ------------------
  |  | 2496|      0|#define CUR (*ctxt->cur)
  ------------------
  |  Branch (10717:8): [True: 0, False: 0]
  |  Branch (10717:24): [True: 0, False: 0]
  ------------------
10718|      2|		    xmlXPathCompRelativeLocationPath(ctxt);
10719|      2|	    }
10720|      2|	    CHECK_ERROR;
  ------------------
  |  |  241|      2|    if (ctxt->error != XPATH_EXPRESSION_OK) return
  |  |  ------------------
  |  |  |  Branch (241:9): [True: 0, False: 2]
  |  |  ------------------
  ------------------
10721|      2|	}
10722|      2|    }
10723|      2|}
xpath.c:xmlXPathCompFilterExpr:
 9739|      2|xmlXPathCompFilterExpr(xmlXPathParserContextPtr ctxt) {
 9740|      2|    xmlXPathCompPrimaryExpr(ctxt);
 9741|      2|    CHECK_ERROR;
  ------------------
  |  |  241|      2|    if (ctxt->error != XPATH_EXPRESSION_OK) return
  |  |  ------------------
  |  |  |  Branch (241:9): [True: 0, False: 2]
  |  |  ------------------
  ------------------
 9742|      2|    SKIP_BLANKS;
  ------------------
  |  | 2509|      2|    while (IS_BLANK_CH(*(ctxt->cur))) NEXT
  |  |  ------------------
  |  |  |  | 2512|      2|#define NEXT ((*ctxt->cur) ?  ctxt->cur++: ctxt->cur)
  |  |  |  |  ------------------
  |  |  |  |  |  Branch (2512:15): [True: 0, False: 0]
  |  |  |  |  ------------------
  |  |  ------------------
  ------------------
 9743|       |
 9744|      2|    while (CUR == '[') {
  ------------------
  |  | 2496|      2|#define CUR (*ctxt->cur)
  ------------------
  |  Branch (9744:12): [True: 0, False: 2]
  ------------------
 9745|      0|	xmlXPathCompPredicate(ctxt, 1);
 9746|      0|	SKIP_BLANKS;
  ------------------
  |  | 2509|      0|    while (IS_BLANK_CH(*(ctxt->cur))) NEXT
  |  |  ------------------
  |  |  |  | 2512|      0|#define NEXT ((*ctxt->cur) ?  ctxt->cur++: ctxt->cur)
  |  |  |  |  ------------------
  |  |  |  |  |  Branch (2512:15): [True: 0, False: 0]
  |  |  |  |  ------------------
  |  |  ------------------
  ------------------
 9747|      0|    }
 9748|       |
 9749|       |
 9750|      2|}
xpath.c:xmlXPathCompPrimaryExpr:
 9700|      2|xmlXPathCompPrimaryExpr(xmlXPathParserContextPtr ctxt) {
 9701|      2|    SKIP_BLANKS;
  ------------------
  |  | 2509|      2|    while (IS_BLANK_CH(*(ctxt->cur))) NEXT
  |  |  ------------------
  |  |  |  | 2512|      0|#define NEXT ((*ctxt->cur) ?  ctxt->cur++: ctxt->cur)
  |  |  |  |  ------------------
  |  |  |  |  |  Branch (2512:15): [True: 0, False: 0]
  |  |  |  |  ------------------
  |  |  ------------------
  ------------------
 9702|      2|    if (CUR == '$') xmlXPathCompVariableReference(ctxt);
  ------------------
  |  | 2496|      2|#define CUR (*ctxt->cur)
  ------------------
  |  Branch (9702:9): [True: 0, False: 2]
  ------------------
 9703|      2|    else if (CUR == '(') {
  ------------------
  |  | 2496|      2|#define CUR (*ctxt->cur)
  ------------------
  |  Branch (9703:14): [True: 0, False: 2]
  ------------------
 9704|      0|	NEXT;
  ------------------
  |  | 2512|      0|#define NEXT ((*ctxt->cur) ?  ctxt->cur++: ctxt->cur)
  |  |  ------------------
  |  |  |  Branch (2512:15): [True: 0, False: 0]
  |  |  ------------------
  ------------------
 9705|      0|	SKIP_BLANKS;
  ------------------
  |  | 2509|      0|    while (IS_BLANK_CH(*(ctxt->cur))) NEXT
  |  |  ------------------
  |  |  |  | 2512|      0|#define NEXT ((*ctxt->cur) ?  ctxt->cur++: ctxt->cur)
  |  |  |  |  ------------------
  |  |  |  |  |  Branch (2512:15): [True: 0, False: 0]
  |  |  |  |  ------------------
  |  |  ------------------
  ------------------
 9706|      0|	xmlXPathCompileExpr(ctxt, 1);
 9707|      0|	CHECK_ERROR;
  ------------------
  |  |  241|      0|    if (ctxt->error != XPATH_EXPRESSION_OK) return
  |  |  ------------------
  |  |  |  Branch (241:9): [True: 0, False: 0]
  |  |  ------------------
  ------------------
 9708|      0|	if (CUR != ')') {
  ------------------
  |  | 2496|      0|#define CUR (*ctxt->cur)
  ------------------
  |  Branch (9708:6): [True: 0, False: 0]
  ------------------
 9709|      0|	    XP_ERROR(XPATH_EXPR_ERROR);
  ------------------
  |  |  258|      0|    { xmlXPathErr(ctxt, X); return; }
  ------------------
 9710|      0|	}
 9711|      0|	NEXT;
  ------------------
  |  | 2512|      0|#define NEXT ((*ctxt->cur) ?  ctxt->cur++: ctxt->cur)
  |  |  ------------------
  |  |  |  Branch (2512:15): [True: 0, False: 0]
  |  |  ------------------
  ------------------
 9712|      0|	SKIP_BLANKS;
  ------------------
  |  | 2509|      0|    while (IS_BLANK_CH(*(ctxt->cur))) NEXT
  |  |  ------------------
  |  |  |  | 2512|      0|#define NEXT ((*ctxt->cur) ?  ctxt->cur++: ctxt->cur)
  |  |  |  |  ------------------
  |  |  |  |  |  Branch (2512:15): [True: 0, False: 0]
  |  |  |  |  ------------------
  |  |  ------------------
  ------------------
 9713|      2|    } else if (IS_ASCII_DIGIT(CUR) || (CUR == '.' && IS_ASCII_DIGIT(NXT(1)))) {
  ------------------
  |  |  268|      4|#define IS_ASCII_DIGIT(c)	((0x30 <= (c)) && ((c) <= 0x39))
  |  |  ------------------
  |  |  |  Branch (268:28): [True: 2, False: 0]
  |  |  |  Branch (268:45): [True: 2, False: 0]
  |  |  ------------------
  ------------------
                  } else if (IS_ASCII_DIGIT(CUR) || (CUR == '.' && IS_ASCII_DIGIT(NXT(1)))) {
  ------------------
  |  | 2496|      0|#define CUR (*ctxt->cur)
  ------------------
                  } else if (IS_ASCII_DIGIT(CUR) || (CUR == '.' && IS_ASCII_DIGIT(NXT(1)))) {
  ------------------
  |  |  268|      0|#define IS_ASCII_DIGIT(c)	((0x30 <= (c)) && ((c) <= 0x39))
  |  |  ------------------
  |  |  |  Branch (268:28): [True: 0, False: 0]
  |  |  |  Branch (268:45): [True: 0, False: 0]
  |  |  ------------------
  ------------------
  |  Branch (9713:40): [True: 0, False: 0]
  ------------------
 9714|      2|	xmlXPathCompNumber(ctxt);
 9715|      2|    } else if ((CUR == '\'') || (CUR == '"')) {
  ------------------
  |  | 2496|      0|#define CUR (*ctxt->cur)
  ------------------
                  } else if ((CUR == '\'') || (CUR == '"')) {
  ------------------
  |  | 2496|      0|#define CUR (*ctxt->cur)
  ------------------
  |  Branch (9715:16): [True: 0, False: 0]
  |  Branch (9715:33): [True: 0, False: 0]
  ------------------
 9716|      0|	xmlXPathCompLiteral(ctxt);
 9717|      0|    } else {
 9718|      0|	xmlXPathCompFunctionCall(ctxt);
 9719|      0|    }
 9720|      2|    SKIP_BLANKS;
  ------------------
  |  | 2509|      2|    while (IS_BLANK_CH(*(ctxt->cur))) NEXT
  |  |  ------------------
  |  |  |  | 2512|      2|#define NEXT ((*ctxt->cur) ?  ctxt->cur++: ctxt->cur)
  |  |  |  |  ------------------
  |  |  |  |  |  Branch (2512:15): [True: 0, False: 0]
  |  |  |  |  ------------------
  |  |  ------------------
  ------------------
 9721|      2|}
xpath.c:xmlXPathCompNumber:
 9357|      2|{
 9358|      2|    double ret = 0.0;
 9359|      2|    int ok = 0;
 9360|      2|    int exponent = 0;
 9361|      2|    int is_exponent_negative = 0;
 9362|      2|    xmlXPathObjectPtr num;
 9363|      2|#ifdef __GNUC__
 9364|      2|    unsigned long tmp = 0;
 9365|      2|    double temp;
 9366|      2|#endif
 9367|       |
 9368|      2|    CHECK_ERROR;
  ------------------
  |  |  241|      2|    if (ctxt->error != XPATH_EXPRESSION_OK) return
  |  |  ------------------
  |  |  |  Branch (241:9): [True: 0, False: 2]
  |  |  ------------------
  ------------------
 9369|      2|    if ((CUR != '.') && ((CUR < '0') || (CUR > '9'))) {
  ------------------
  |  | 2496|      2|#define CUR (*ctxt->cur)
  ------------------
                  if ((CUR != '.') && ((CUR < '0') || (CUR > '9'))) {
  ------------------
  |  | 2496|      2|#define CUR (*ctxt->cur)
  ------------------
                  if ((CUR != '.') && ((CUR < '0') || (CUR > '9'))) {
  ------------------
  |  | 2496|      2|#define CUR (*ctxt->cur)
  ------------------
  |  Branch (9369:9): [True: 2, False: 0]
  |  Branch (9369:26): [True: 0, False: 2]
  |  Branch (9369:41): [True: 0, False: 2]
  ------------------
 9370|      0|        XP_ERROR(XPATH_NUMBER_ERROR);
  ------------------
  |  |  258|      0|    { xmlXPathErr(ctxt, X); return; }
  ------------------
 9371|      0|    }
 9372|      2|#ifdef __GNUC__
 9373|       |    /*
 9374|       |     * tmp/temp is a workaround against a gcc compiler bug
 9375|       |     * http://veillard.com/gcc.bug
 9376|       |     */
 9377|      2|    ret = 0;
 9378|      4|    while ((CUR >= '0') && (CUR <= '9')) {
  ------------------
  |  | 2496|      4|#define CUR (*ctxt->cur)
  ------------------
                  while ((CUR >= '0') && (CUR <= '9')) {
  ------------------
  |  | 2496|      4|#define CUR (*ctxt->cur)
  ------------------
  |  Branch (9378:12): [True: 4, False: 0]
  |  Branch (9378:28): [True: 2, False: 2]
  ------------------
 9379|      2|	ret = ret * 10;
 9380|      2|	tmp = (CUR - '0');
  ------------------
  |  | 2496|      2|#define CUR (*ctxt->cur)
  ------------------
 9381|      2|        ok = 1;
 9382|      2|        NEXT;
  ------------------
  |  | 2512|      2|#define NEXT ((*ctxt->cur) ?  ctxt->cur++: ctxt->cur)
  |  |  ------------------
  |  |  |  Branch (2512:15): [True: 2, False: 0]
  |  |  ------------------
  ------------------
 9383|      2|	temp = (double) tmp;
 9384|      2|	ret = ret + temp;
 9385|      2|    }
 9386|       |#else
 9387|       |    ret = 0;
 9388|       |    while ((CUR >= '0') && (CUR <= '9')) {
 9389|       |	ret = ret * 10 + (CUR - '0');
 9390|       |	ok = 1;
 9391|       |	NEXT;
 9392|       |    }
 9393|       |#endif
 9394|      2|    if (CUR == '.') {
  ------------------
  |  | 2496|      2|#define CUR (*ctxt->cur)
  ------------------
  |  Branch (9394:9): [True: 0, False: 2]
  ------------------
 9395|      0|	int v, frac = 0, max;
 9396|      0|	double fraction = 0;
 9397|       |
 9398|      0|        NEXT;
  ------------------
  |  | 2512|      0|#define NEXT ((*ctxt->cur) ?  ctxt->cur++: ctxt->cur)
  |  |  ------------------
  |  |  |  Branch (2512:15): [True: 0, False: 0]
  |  |  ------------------
  ------------------
 9399|      0|        if (((CUR < '0') || (CUR > '9')) && (!ok)) {
  ------------------
  |  | 2496|      0|#define CUR (*ctxt->cur)
  ------------------
                      if (((CUR < '0') || (CUR > '9')) && (!ok)) {
  ------------------
  |  | 2496|      0|#define CUR (*ctxt->cur)
  ------------------
  |  Branch (9399:14): [True: 0, False: 0]
  |  Branch (9399:29): [True: 0, False: 0]
  |  Branch (9399:45): [True: 0, False: 0]
  ------------------
 9400|      0|            XP_ERROR(XPATH_NUMBER_ERROR);
  ------------------
  |  |  258|      0|    { xmlXPathErr(ctxt, X); return; }
  ------------------
 9401|      0|        }
 9402|      0|        while (CUR == '0') {
  ------------------
  |  | 2496|      0|#define CUR (*ctxt->cur)
  ------------------
  |  Branch (9402:16): [True: 0, False: 0]
  ------------------
 9403|      0|            frac = frac + 1;
 9404|      0|            NEXT;
  ------------------
  |  | 2512|      0|#define NEXT ((*ctxt->cur) ?  ctxt->cur++: ctxt->cur)
  |  |  ------------------
  |  |  |  Branch (2512:15): [True: 0, False: 0]
  |  |  ------------------
  ------------------
 9405|      0|        }
 9406|      0|        max = frac + MAX_FRAC;
  ------------------
  |  | 9235|      0|#define MAX_FRAC 20
  ------------------
 9407|      0|        while ((CUR >= '0') && (CUR <= '9') && (frac < max)) {
  ------------------
  |  | 2496|      0|#define CUR (*ctxt->cur)
  ------------------
                      while ((CUR >= '0') && (CUR <= '9') && (frac < max)) {
  ------------------
  |  | 2496|      0|#define CUR (*ctxt->cur)
  ------------------
  |  Branch (9407:16): [True: 0, False: 0]
  |  Branch (9407:32): [True: 0, False: 0]
  |  Branch (9407:48): [True: 0, False: 0]
  ------------------
 9408|      0|	    v = (CUR - '0');
  ------------------
  |  | 2496|      0|#define CUR (*ctxt->cur)
  ------------------
 9409|      0|	    fraction = fraction * 10 + v;
 9410|      0|	    frac = frac + 1;
 9411|      0|            NEXT;
  ------------------
  |  | 2512|      0|#define NEXT ((*ctxt->cur) ?  ctxt->cur++: ctxt->cur)
  |  |  ------------------
  |  |  |  Branch (2512:15): [True: 0, False: 0]
  |  |  ------------------
  ------------------
 9412|      0|        }
 9413|      0|        fraction /= pow(10.0, frac);
 9414|      0|        ret = ret + fraction;
 9415|      0|        while ((CUR >= '0') && (CUR <= '9'))
  ------------------
  |  | 2496|      0|#define CUR (*ctxt->cur)
  ------------------
                      while ((CUR >= '0') && (CUR <= '9'))
  ------------------
  |  | 2496|      0|#define CUR (*ctxt->cur)
  ------------------
  |  Branch (9415:16): [True: 0, False: 0]
  |  Branch (9415:32): [True: 0, False: 0]
  ------------------
 9416|      0|            NEXT;
  ------------------
  |  | 2512|      0|#define NEXT ((*ctxt->cur) ?  ctxt->cur++: ctxt->cur)
  |  |  ------------------
  |  |  |  Branch (2512:15): [True: 0, False: 0]
  |  |  ------------------
  ------------------
 9417|      0|    }
 9418|      2|    if ((CUR == 'e') || (CUR == 'E')) {
  ------------------
  |  | 2496|      2|#define CUR (*ctxt->cur)
  ------------------
                  if ((CUR == 'e') || (CUR == 'E')) {
  ------------------
  |  | 2496|      2|#define CUR (*ctxt->cur)
  ------------------
  |  Branch (9418:9): [True: 0, False: 2]
  |  Branch (9418:25): [True: 0, False: 2]
  ------------------
 9419|      0|        NEXT;
  ------------------
  |  | 2512|      0|#define NEXT ((*ctxt->cur) ?  ctxt->cur++: ctxt->cur)
  |  |  ------------------
  |  |  |  Branch (2512:15): [True: 0, False: 0]
  |  |  ------------------
  ------------------
 9420|      0|        if (CUR == '-') {
  ------------------
  |  | 2496|      0|#define CUR (*ctxt->cur)
  ------------------
  |  Branch (9420:13): [True: 0, False: 0]
  ------------------
 9421|      0|            is_exponent_negative = 1;
 9422|      0|            NEXT;
  ------------------
  |  | 2512|      0|#define NEXT ((*ctxt->cur) ?  ctxt->cur++: ctxt->cur)
  |  |  ------------------
  |  |  |  Branch (2512:15): [True: 0, False: 0]
  |  |  ------------------
  ------------------
 9423|      0|        } else if (CUR == '+') {
  ------------------
  |  | 2496|      0|#define CUR (*ctxt->cur)
  ------------------
  |  Branch (9423:20): [True: 0, False: 0]
  ------------------
 9424|      0|	    NEXT;
  ------------------
  |  | 2512|      0|#define NEXT ((*ctxt->cur) ?  ctxt->cur++: ctxt->cur)
  |  |  ------------------
  |  |  |  Branch (2512:15): [True: 0, False: 0]
  |  |  ------------------
  ------------------
 9425|      0|	}
 9426|      0|        while ((CUR >= '0') && (CUR <= '9')) {
  ------------------
  |  | 2496|      0|#define CUR (*ctxt->cur)
  ------------------
                      while ((CUR >= '0') && (CUR <= '9')) {
  ------------------
  |  | 2496|      0|#define CUR (*ctxt->cur)
  ------------------
  |  Branch (9426:16): [True: 0, False: 0]
  |  Branch (9426:32): [True: 0, False: 0]
  ------------------
 9427|      0|            if (exponent < 1000000)
  ------------------
  |  Branch (9427:17): [True: 0, False: 0]
  ------------------
 9428|      0|                exponent = exponent * 10 + (CUR - '0');
  ------------------
  |  | 2496|      0|#define CUR (*ctxt->cur)
  ------------------
 9429|      0|            NEXT;
  ------------------
  |  | 2512|      0|#define NEXT ((*ctxt->cur) ?  ctxt->cur++: ctxt->cur)
  |  |  ------------------
  |  |  |  Branch (2512:15): [True: 0, False: 0]
  |  |  ------------------
  ------------------
 9430|      0|        }
 9431|      0|        if (is_exponent_negative)
  ------------------
  |  Branch (9431:13): [True: 0, False: 0]
  ------------------
 9432|      0|            exponent = -exponent;
 9433|      0|        ret *= pow(10.0, (double) exponent);
 9434|      0|    }
 9435|      2|    num = xmlXPathCacheNewFloat(ctxt->context, ret);
 9436|      2|    if (num == NULL) {
  ------------------
  |  Branch (9436:9): [True: 0, False: 2]
  ------------------
 9437|      0|	ctxt->error = XPATH_MEMORY_ERROR;
 9438|      2|    } else if (PUSH_LONG_EXPR(XPATH_OP_VALUE, XPATH_NUMBER, 0, 0, num,
  ------------------
  |  | 1185|      2|    xmlXPathCompExprAdd(ctxt, ctxt->comp->last, -1,		\
  |  | 1186|      2|	                (op), (val), (val2), (val3), (val4), (val5))
  ------------------
  |  Branch (9438:16): [True: 0, False: 2]
  ------------------
 9439|      2|                              NULL) == -1) {
 9440|      0|        xmlXPathReleaseObject(ctxt->context, num);
 9441|      0|    }
 9442|      2|}
xpath.c:xmlXPathCompPredicate:
10236|      2|xmlXPathCompPredicate(xmlXPathParserContextPtr ctxt, int filter) {
10237|      2|    int op1 = ctxt->comp->last;
10238|       |
10239|      2|    SKIP_BLANKS;
  ------------------
  |  | 2509|      2|    while (IS_BLANK_CH(*(ctxt->cur))) NEXT
  |  |  ------------------
  |  |  |  | 2512|      0|#define NEXT ((*ctxt->cur) ?  ctxt->cur++: ctxt->cur)
  |  |  |  |  ------------------
  |  |  |  |  |  Branch (2512:15): [True: 0, False: 0]
  |  |  |  |  ------------------
  |  |  ------------------
  ------------------
10240|      2|    if (CUR != '[') {
  ------------------
  |  | 2496|      2|#define CUR (*ctxt->cur)
  ------------------
  |  Branch (10240:9): [True: 0, False: 2]
  ------------------
10241|      0|	XP_ERROR(XPATH_INVALID_PREDICATE_ERROR);
  ------------------
  |  |  258|      0|    { xmlXPathErr(ctxt, X); return; }
  ------------------
10242|      0|    }
10243|      2|    NEXT;
  ------------------
  |  | 2512|      2|#define NEXT ((*ctxt->cur) ?  ctxt->cur++: ctxt->cur)
  |  |  ------------------
  |  |  |  Branch (2512:15): [True: 2, False: 0]
  |  |  ------------------
  ------------------
10244|      2|    SKIP_BLANKS;
  ------------------
  |  | 2509|      2|    while (IS_BLANK_CH(*(ctxt->cur))) NEXT
  |  |  ------------------
  |  |  |  | 2512|      2|#define NEXT ((*ctxt->cur) ?  ctxt->cur++: ctxt->cur)
  |  |  |  |  ------------------
  |  |  |  |  |  Branch (2512:15): [True: 0, False: 0]
  |  |  |  |  ------------------
  |  |  ------------------
  ------------------
10245|       |
10246|      2|    ctxt->comp->last = -1;
10247|       |    /*
10248|       |    * This call to xmlXPathCompileExpr() will deactivate sorting
10249|       |    * of the predicate result.
10250|       |    * TODO: Sorting is still activated for filters, since I'm not
10251|       |    *  sure if needed. Normally sorting should not be needed, since
10252|       |    *  a filter can only diminish the number of items in a sequence,
10253|       |    *  but won't change its order; so if the initial sequence is sorted,
10254|       |    *  subsequent sorting is not needed.
10255|       |    */
10256|      2|    if (! filter)
  ------------------
  |  Branch (10256:9): [True: 2, False: 0]
  ------------------
10257|      2|	xmlXPathCompileExpr(ctxt, 0);
10258|      0|    else
10259|      0|	xmlXPathCompileExpr(ctxt, 1);
10260|      2|    CHECK_ERROR;
  ------------------
  |  |  241|      2|    if (ctxt->error != XPATH_EXPRESSION_OK) return
  |  |  ------------------
  |  |  |  Branch (241:9): [True: 0, False: 2]
  |  |  ------------------
  ------------------
10261|       |
10262|      2|    if (CUR != ']') {
  ------------------
  |  | 2496|      2|#define CUR (*ctxt->cur)
  ------------------
  |  Branch (10262:9): [True: 0, False: 2]
  ------------------
10263|      0|	XP_ERROR(XPATH_INVALID_PREDICATE_ERROR);
  ------------------
  |  |  258|      0|    { xmlXPathErr(ctxt, X); return; }
  ------------------
10264|      0|    }
10265|       |
10266|      2|    if (filter)
  ------------------
  |  Branch (10266:9): [True: 0, False: 2]
  ------------------
10267|      0|	PUSH_BINARY_EXPR(XPATH_OP_FILTER, op1, ctxt->comp->last, 0, 0);
  ------------------
  |  | 1194|      0|#define PUSH_BINARY_EXPR(op, ch1, ch2, val, val2)			\
  |  | 1195|      0|xmlXPathCompExprAdd(ctxt, (ch1), (ch2), (op),			\
  |  | 1196|      0|			(val), (val2), 0 ,NULL ,NULL)
  ------------------
10268|      2|    else
10269|      2|	PUSH_BINARY_EXPR(XPATH_OP_PREDICATE, op1, ctxt->comp->last, 0, 0);
  ------------------
  |  | 1194|      2|#define PUSH_BINARY_EXPR(op, ch1, ch2, val, val2)			\
  |  | 1195|      2|xmlXPathCompExprAdd(ctxt, (ch1), (ch2), (op),			\
  |  | 1196|      2|			(val), (val2), 0 ,NULL ,NULL)
  ------------------
10270|       |
10271|      2|    NEXT;
  ------------------
  |  | 2512|      2|#define NEXT ((*ctxt->cur) ?  ctxt->cur++: ctxt->cur)
  |  |  ------------------
  |  |  |  Branch (2512:15): [True: 2, False: 0]
  |  |  ------------------
  ------------------
10272|      2|    SKIP_BLANKS;
  ------------------
  |  | 2509|      2|    while (IS_BLANK_CH(*(ctxt->cur))) NEXT
  |  |  ------------------
  |  |  |  | 2512|      2|#define NEXT ((*ctxt->cur) ?  ctxt->cur++: ctxt->cur)
  |  |  |  |  ------------------
  |  |  |  |  |  Branch (2512:15): [True: 0, False: 0]
  |  |  |  |  ------------------
  |  |  ------------------
  ------------------
10273|      2|}
xpath.c:xmlXPathCompRelativeLocationPath:
10648|      2|(xmlXPathParserContextPtr ctxt) {
10649|      2|    SKIP_BLANKS;
  ------------------
  |  | 2509|      2|    while (IS_BLANK_CH(*(ctxt->cur))) NEXT
  |  |  ------------------
  |  |  |  | 2512|      0|#define NEXT ((*ctxt->cur) ?  ctxt->cur++: ctxt->cur)
  |  |  |  |  ------------------
  |  |  |  |  |  Branch (2512:15): [True: 0, False: 0]
  |  |  |  |  ------------------
  |  |  ------------------
  ------------------
10650|      2|    if ((CUR == '/') && (NXT(1) == '/')) {
  ------------------
  |  | 2496|      2|#define CUR (*ctxt->cur)
  ------------------
                  if ((CUR == '/') && (NXT(1) == '/')) {
  ------------------
  |  | 2498|      0|#define NXT(val) ctxt->cur[(val)]
  ------------------
  |  Branch (10650:9): [True: 0, False: 2]
  |  Branch (10650:25): [True: 0, False: 0]
  ------------------
10651|      0|	SKIP(2);
  ------------------
  |  | 2497|      0|#define SKIP(val) ctxt->cur += (val)
  ------------------
10652|      0|	SKIP_BLANKS;
  ------------------
  |  | 2509|      0|    while (IS_BLANK_CH(*(ctxt->cur))) NEXT
  |  |  ------------------
  |  |  |  | 2512|      0|#define NEXT ((*ctxt->cur) ?  ctxt->cur++: ctxt->cur)
  |  |  |  |  ------------------
  |  |  |  |  |  Branch (2512:15): [True: 0, False: 0]
  |  |  |  |  ------------------
  |  |  ------------------
  ------------------
10653|      0|	PUSH_LONG_EXPR(XPATH_OP_COLLECT, AXIS_DESCENDANT_OR_SELF,
  ------------------
  |  | 1185|      0|    xmlXPathCompExprAdd(ctxt, ctxt->comp->last, -1,		\
  |  | 1186|      0|	                (op), (val), (val2), (val3), (val4), (val5))
  ------------------
10654|      0|		         NODE_TEST_TYPE, NODE_TYPE_NODE, NULL, NULL);
10655|      2|    } else if (CUR == '/') {
  ------------------
  |  | 2496|      2|#define CUR (*ctxt->cur)
  ------------------
  |  Branch (10655:16): [True: 0, False: 2]
  ------------------
10656|      0|	    NEXT;
  ------------------
  |  | 2512|      0|#define NEXT ((*ctxt->cur) ?  ctxt->cur++: ctxt->cur)
  |  |  ------------------
  |  |  |  Branch (2512:15): [True: 0, False: 0]
  |  |  ------------------
  ------------------
10657|      0|	SKIP_BLANKS;
  ------------------
  |  | 2509|      0|    while (IS_BLANK_CH(*(ctxt->cur))) NEXT
  |  |  ------------------
  |  |  |  | 2512|      0|#define NEXT ((*ctxt->cur) ?  ctxt->cur++: ctxt->cur)
  |  |  |  |  ------------------
  |  |  |  |  |  Branch (2512:15): [True: 0, False: 0]
  |  |  |  |  ------------------
  |  |  ------------------
  ------------------
10658|      0|    }
10659|      2|    xmlXPathCompStep(ctxt);
10660|      2|    CHECK_ERROR;
  ------------------
  |  |  241|      2|    if (ctxt->error != XPATH_EXPRESSION_OK) return
  |  |  ------------------
  |  |  |  Branch (241:9): [True: 0, False: 2]
  |  |  ------------------
  ------------------
10661|      2|    SKIP_BLANKS;
  ------------------
  |  | 2509|      2|    while (IS_BLANK_CH(*(ctxt->cur))) NEXT
  |  |  ------------------
  |  |  |  | 2512|      2|#define NEXT ((*ctxt->cur) ?  ctxt->cur++: ctxt->cur)
  |  |  |  |  ------------------
  |  |  |  |  |  Branch (2512:15): [True: 0, False: 0]
  |  |  |  |  ------------------
  |  |  ------------------
  ------------------
10662|      4|    while (CUR == '/') {
  ------------------
  |  | 2496|      4|#define CUR (*ctxt->cur)
  ------------------
  |  Branch (10662:12): [True: 2, False: 2]
  ------------------
10663|      2|	if ((CUR == '/') && (NXT(1) == '/')) {
  ------------------
  |  | 2496|      2|#define CUR (*ctxt->cur)
  ------------------
              	if ((CUR == '/') && (NXT(1) == '/')) {
  ------------------
  |  | 2498|      2|#define NXT(val) ctxt->cur[(val)]
  ------------------
  |  Branch (10663:6): [True: 2, False: 0]
  |  Branch (10663:22): [True: 0, False: 2]
  ------------------
10664|      0|	    SKIP(2);
  ------------------
  |  | 2497|      0|#define SKIP(val) ctxt->cur += (val)
  ------------------
10665|      0|	    SKIP_BLANKS;
  ------------------
  |  | 2509|      0|    while (IS_BLANK_CH(*(ctxt->cur))) NEXT
  |  |  ------------------
  |  |  |  | 2512|      0|#define NEXT ((*ctxt->cur) ?  ctxt->cur++: ctxt->cur)
  |  |  |  |  ------------------
  |  |  |  |  |  Branch (2512:15): [True: 0, False: 0]
  |  |  |  |  ------------------
  |  |  ------------------
  ------------------
10666|      0|	    PUSH_LONG_EXPR(XPATH_OP_COLLECT, AXIS_DESCENDANT_OR_SELF,
  ------------------
  |  | 1185|      0|    xmlXPathCompExprAdd(ctxt, ctxt->comp->last, -1,		\
  |  | 1186|      0|	                (op), (val), (val2), (val3), (val4), (val5))
  ------------------
10667|      0|			     NODE_TEST_TYPE, NODE_TYPE_NODE, NULL, NULL);
10668|      0|	    xmlXPathCompStep(ctxt);
10669|      2|	} else if (CUR == '/') {
  ------------------
  |  | 2496|      2|#define CUR (*ctxt->cur)
  ------------------
  |  Branch (10669:13): [True: 2, False: 0]
  ------------------
10670|      2|	    NEXT;
  ------------------
  |  | 2512|      2|#define NEXT ((*ctxt->cur) ?  ctxt->cur++: ctxt->cur)
  |  |  ------------------
  |  |  |  Branch (2512:15): [True: 2, False: 0]
  |  |  ------------------
  ------------------
10671|      2|	    SKIP_BLANKS;
  ------------------
  |  | 2509|      2|    while (IS_BLANK_CH(*(ctxt->cur))) NEXT
  |  |  ------------------
  |  |  |  | 2512|      0|#define NEXT ((*ctxt->cur) ?  ctxt->cur++: ctxt->cur)
  |  |  |  |  ------------------
  |  |  |  |  |  Branch (2512:15): [True: 0, False: 0]
  |  |  |  |  ------------------
  |  |  ------------------
  ------------------
10672|      2|	    xmlXPathCompStep(ctxt);
10673|      2|	}
10674|      2|	SKIP_BLANKS;
  ------------------
  |  | 2509|      2|    while (IS_BLANK_CH(*(ctxt->cur))) NEXT
  |  |  ------------------
  |  |  |  | 2512|      0|#define NEXT ((*ctxt->cur) ?  ctxt->cur++: ctxt->cur)
  |  |  |  |  ------------------
  |  |  |  |  |  Branch (2512:15): [True: 0, False: 0]
  |  |  |  |  ------------------
  |  |  ------------------
  ------------------
10675|      2|    }
10676|      2|}
xpath.c:xmlXPathCompStep:
10514|      4|xmlXPathCompStep(xmlXPathParserContextPtr ctxt) {
10515|       |#ifdef LIBXML_XPTR_LOCS_ENABLED
10516|       |    int rangeto = 0;
10517|       |    int op2 = -1;
10518|       |#endif
10519|       |
10520|      4|    SKIP_BLANKS;
  ------------------
  |  | 2509|      4|    while (IS_BLANK_CH(*(ctxt->cur))) NEXT
  |  |  ------------------
  |  |  |  | 2512|      0|#define NEXT ((*ctxt->cur) ?  ctxt->cur++: ctxt->cur)
  |  |  |  |  ------------------
  |  |  |  |  |  Branch (2512:15): [True: 0, False: 0]
  |  |  |  |  ------------------
  |  |  ------------------
  ------------------
10521|      4|    if ((CUR == '.') && (NXT(1) == '.')) {
  ------------------
  |  | 2496|      4|#define CUR (*ctxt->cur)
  ------------------
                  if ((CUR == '.') && (NXT(1) == '.')) {
  ------------------
  |  | 2498|      0|#define NXT(val) ctxt->cur[(val)]
  ------------------
  |  Branch (10521:9): [True: 0, False: 4]
  |  Branch (10521:25): [True: 0, False: 0]
  ------------------
10522|      0|	SKIP(2);
  ------------------
  |  | 2497|      0|#define SKIP(val) ctxt->cur += (val)
  ------------------
10523|      0|	SKIP_BLANKS;
  ------------------
  |  | 2509|      0|    while (IS_BLANK_CH(*(ctxt->cur))) NEXT
  |  |  ------------------
  |  |  |  | 2512|      0|#define NEXT ((*ctxt->cur) ?  ctxt->cur++: ctxt->cur)
  |  |  |  |  ------------------
  |  |  |  |  |  Branch (2512:15): [True: 0, False: 0]
  |  |  |  |  ------------------
  |  |  ------------------
  ------------------
10524|      0|	PUSH_LONG_EXPR(XPATH_OP_COLLECT, AXIS_PARENT,
  ------------------
  |  | 1185|      0|    xmlXPathCompExprAdd(ctxt, ctxt->comp->last, -1,		\
  |  | 1186|      0|	                (op), (val), (val2), (val3), (val4), (val5))
  ------------------
10525|      0|		    NODE_TEST_TYPE, NODE_TYPE_NODE, NULL, NULL);
10526|      4|    } else if (CUR == '.') {
  ------------------
  |  | 2496|      4|#define CUR (*ctxt->cur)
  ------------------
  |  Branch (10526:16): [True: 0, False: 4]
  ------------------
10527|      0|	NEXT;
  ------------------
  |  | 2512|      0|#define NEXT ((*ctxt->cur) ?  ctxt->cur++: ctxt->cur)
  |  |  ------------------
  |  |  |  Branch (2512:15): [True: 0, False: 0]
  |  |  ------------------
  ------------------
10528|      0|	SKIP_BLANKS;
  ------------------
  |  | 2509|      0|    while (IS_BLANK_CH(*(ctxt->cur))) NEXT
  |  |  ------------------
  |  |  |  | 2512|      0|#define NEXT ((*ctxt->cur) ?  ctxt->cur++: ctxt->cur)
  |  |  |  |  ------------------
  |  |  |  |  |  Branch (2512:15): [True: 0, False: 0]
  |  |  |  |  ------------------
  |  |  ------------------
  ------------------
10529|      4|    } else {
10530|      4|	xmlChar *name = NULL;
10531|      4|	xmlChar *prefix = NULL;
10532|      4|	xmlXPathTestVal test = (xmlXPathTestVal) 0;
10533|      4|	xmlXPathAxisVal axis = (xmlXPathAxisVal) 0;
10534|      4|	xmlXPathTypeVal type = (xmlXPathTypeVal) 0;
10535|      4|	int op1;
10536|       |
10537|       |	/*
10538|       |	 * The modification needed for XPointer change to the production
10539|       |	 */
10540|       |#ifdef LIBXML_XPTR_LOCS_ENABLED
10541|       |	if (ctxt->xptr) {
10542|       |	    name = xmlXPathParseNCName(ctxt);
10543|       |	    if ((name != NULL) && (xmlStrEqual(name, BAD_CAST "range-to"))) {
10544|       |                op2 = ctxt->comp->last;
10545|       |		xmlFree(name);
10546|       |		SKIP_BLANKS;
10547|       |		if (CUR != '(') {
10548|       |		    XP_ERROR(XPATH_EXPR_ERROR);
10549|       |		}
10550|       |		NEXT;
10551|       |		SKIP_BLANKS;
10552|       |
10553|       |		xmlXPathCompileExpr(ctxt, 1);
10554|       |		/* PUSH_BINARY_EXPR(XPATH_OP_RANGETO, op2, ctxt->comp->last, 0, 0); */
10555|       |		CHECK_ERROR;
10556|       |
10557|       |		SKIP_BLANKS;
10558|       |		if (CUR != ')') {
10559|       |		    XP_ERROR(XPATH_EXPR_ERROR);
10560|       |		}
10561|       |		NEXT;
10562|       |		rangeto = 1;
10563|       |		goto eval_predicates;
10564|       |	    }
10565|       |	}
10566|       |#endif
10567|      4|	if (CUR == '*') {
  ------------------
  |  | 2496|      4|#define CUR (*ctxt->cur)
  ------------------
  |  Branch (10567:6): [True: 0, False: 4]
  ------------------
10568|      0|	    axis = AXIS_CHILD;
10569|      4|	} else {
10570|      4|	    if (name == NULL)
  ------------------
  |  Branch (10570:10): [True: 4, False: 0]
  ------------------
10571|      4|		name = xmlXPathParseNCName(ctxt);
10572|      4|	    if (name != NULL) {
  ------------------
  |  Branch (10572:10): [True: 4, False: 0]
  ------------------
10573|      4|		axis = xmlXPathIsAxisName(name);
10574|      4|		if (axis != 0) {
  ------------------
  |  Branch (10574:7): [True: 0, False: 4]
  ------------------
10575|      0|		    SKIP_BLANKS;
  ------------------
  |  | 2509|      0|    while (IS_BLANK_CH(*(ctxt->cur))) NEXT
  |  |  ------------------
  |  |  |  | 2512|      0|#define NEXT ((*ctxt->cur) ?  ctxt->cur++: ctxt->cur)
  |  |  |  |  ------------------
  |  |  |  |  |  Branch (2512:15): [True: 0, False: 0]
  |  |  |  |  ------------------
  |  |  ------------------
  ------------------
10576|      0|		    if ((CUR == ':') && (NXT(1) == ':')) {
  ------------------
  |  | 2496|      0|#define CUR (*ctxt->cur)
  ------------------
              		    if ((CUR == ':') && (NXT(1) == ':')) {
  ------------------
  |  | 2498|      0|#define NXT(val) ctxt->cur[(val)]
  ------------------
  |  Branch (10576:11): [True: 0, False: 0]
  |  Branch (10576:27): [True: 0, False: 0]
  ------------------
10577|      0|			SKIP(2);
  ------------------
  |  | 2497|      0|#define SKIP(val) ctxt->cur += (val)
  ------------------
10578|      0|			xmlFree(name);
10579|      0|			name = NULL;
10580|      0|		    } else {
10581|       |			/* an element name can conflict with an axis one :-\ */
10582|      0|			axis = AXIS_CHILD;
10583|      0|		    }
10584|      4|		} else {
10585|      4|		    axis = AXIS_CHILD;
10586|      4|		}
10587|      4|	    } else if (CUR == '@') {
  ------------------
  |  | 2496|      0|#define CUR (*ctxt->cur)
  ------------------
  |  Branch (10587:17): [True: 0, False: 0]
  ------------------
10588|      0|		NEXT;
  ------------------
  |  | 2512|      0|#define NEXT ((*ctxt->cur) ?  ctxt->cur++: ctxt->cur)
  |  |  ------------------
  |  |  |  Branch (2512:15): [True: 0, False: 0]
  |  |  ------------------
  ------------------
10589|      0|		axis = AXIS_ATTRIBUTE;
10590|      0|	    } else {
10591|      0|		axis = AXIS_CHILD;
10592|      0|	    }
10593|      4|	}
10594|       |
10595|      4|        if (ctxt->error != XPATH_EXPRESSION_OK) {
  ------------------
  |  Branch (10595:13): [True: 0, False: 4]
  ------------------
10596|      0|            xmlFree(name);
10597|      0|            return;
10598|      0|        }
10599|       |
10600|      4|	name = xmlXPathCompNodeTest(ctxt, &test, &type, &prefix, name);
10601|      4|	if (test == 0)
  ------------------
  |  Branch (10601:6): [True: 0, False: 4]
  ------------------
10602|      0|	    return;
10603|       |
10604|      4|        if ((prefix != NULL) && (ctxt->context != NULL) &&
  ------------------
  |  Branch (10604:13): [True: 0, False: 4]
  |  Branch (10604:33): [True: 0, False: 0]
  ------------------
10605|      4|	    (ctxt->context->flags & XML_XPATH_CHECKNS)) {
  ------------------
  |  |  275|      0|#define XML_XPATH_CHECKNS (1<<0)
  ------------------
  |  Branch (10605:6): [True: 0, False: 0]
  ------------------
10606|      0|	    if (xmlXPathNsLookup(ctxt->context, prefix) == NULL) {
  ------------------
  |  Branch (10606:10): [True: 0, False: 0]
  ------------------
10607|      0|		xmlXPathErr(ctxt, XPATH_UNDEF_PREFIX_ERROR);
10608|      0|	    }
10609|      0|	}
10610|       |
10611|       |#ifdef LIBXML_XPTR_LOCS_ENABLED
10612|       |eval_predicates:
10613|       |#endif
10614|      4|	op1 = ctxt->comp->last;
10615|      4|	ctxt->comp->last = -1;
10616|       |
10617|      4|	SKIP_BLANKS;
  ------------------
  |  | 2509|      4|    while (IS_BLANK_CH(*(ctxt->cur))) NEXT
  |  |  ------------------
  |  |  |  | 2512|      4|#define NEXT ((*ctxt->cur) ?  ctxt->cur++: ctxt->cur)
  |  |  |  |  ------------------
  |  |  |  |  |  Branch (2512:15): [True: 0, False: 0]
  |  |  |  |  ------------------
  |  |  ------------------
  ------------------
10618|      6|	while (CUR == '[') {
  ------------------
  |  | 2496|      6|#define CUR (*ctxt->cur)
  ------------------
  |  Branch (10618:9): [True: 2, False: 4]
  ------------------
10619|      2|	    xmlXPathCompPredicate(ctxt, 0);
10620|      2|	}
10621|       |
10622|       |#ifdef LIBXML_XPTR_LOCS_ENABLED
10623|       |	if (rangeto) {
10624|       |	    PUSH_BINARY_EXPR(XPATH_OP_RANGETO, op2, op1, 0, 0);
10625|       |	} else
10626|       |#endif
10627|      4|        if (PUSH_FULL_EXPR(XPATH_OP_COLLECT, op1, ctxt->comp->last, axis,
  ------------------
  |  | 1182|      4|    xmlXPathCompExprAdd(ctxt, (op1), (op2),			\
  |  | 1183|      4|	                (op), (val), (val2), (val3), (val4), (val5))
  ------------------
  |  Branch (10627:13): [True: 0, False: 4]
  ------------------
10628|      4|                           test, type, (void *)prefix, (void *)name) == -1) {
10629|      0|            xmlFree(prefix);
10630|      0|            xmlFree(name);
10631|      0|        }
10632|      4|    }
10633|      4|}
xpath.c:xmlXPathIsAxisName:
10434|      4|xmlXPathIsAxisName(const xmlChar *name) {
10435|      4|    xmlXPathAxisVal ret = (xmlXPathAxisVal) 0;
10436|      4|    switch (name[0]) {
  ------------------
  |  Branch (10436:13): [True: 4, False: 0]
  ------------------
10437|      0|	case 'a':
  ------------------
  |  Branch (10437:2): [True: 0, False: 4]
  ------------------
10438|      0|	    if (xmlStrEqual(name, BAD_CAST "ancestor"))
  ------------------
  |  |   35|      0|#define BAD_CAST (xmlChar *)
  ------------------
  |  Branch (10438:10): [True: 0, False: 0]
  ------------------
10439|      0|		ret = AXIS_ANCESTOR;
10440|      0|	    if (xmlStrEqual(name, BAD_CAST "ancestor-or-self"))
  ------------------
  |  |   35|      0|#define BAD_CAST (xmlChar *)
  ------------------
  |  Branch (10440:10): [True: 0, False: 0]
  ------------------
10441|      0|		ret = AXIS_ANCESTOR_OR_SELF;
10442|      0|	    if (xmlStrEqual(name, BAD_CAST "attribute"))
  ------------------
  |  |   35|      0|#define BAD_CAST (xmlChar *)
  ------------------
  |  Branch (10442:10): [True: 0, False: 0]
  ------------------
10443|      0|		ret = AXIS_ATTRIBUTE;
10444|      0|	    break;
10445|      0|	case 'c':
  ------------------
  |  Branch (10445:2): [True: 0, False: 4]
  ------------------
10446|      0|	    if (xmlStrEqual(name, BAD_CAST "child"))
  ------------------
  |  |   35|      0|#define BAD_CAST (xmlChar *)
  ------------------
  |  Branch (10446:10): [True: 0, False: 0]
  ------------------
10447|      0|		ret = AXIS_CHILD;
10448|      0|	    break;
10449|      0|	case 'd':
  ------------------
  |  Branch (10449:2): [True: 0, False: 4]
  ------------------
10450|      0|	    if (xmlStrEqual(name, BAD_CAST "descendant"))
  ------------------
  |  |   35|      0|#define BAD_CAST (xmlChar *)
  ------------------
  |  Branch (10450:10): [True: 0, False: 0]
  ------------------
10451|      0|		ret = AXIS_DESCENDANT;
10452|      0|	    if (xmlStrEqual(name, BAD_CAST "descendant-or-self"))
  ------------------
  |  |   35|      0|#define BAD_CAST (xmlChar *)
  ------------------
  |  Branch (10452:10): [True: 0, False: 0]
  ------------------
10453|      0|		ret = AXIS_DESCENDANT_OR_SELF;
10454|      0|	    break;
10455|      0|	case 'f':
  ------------------
  |  Branch (10455:2): [True: 0, False: 4]
  ------------------
10456|      0|	    if (xmlStrEqual(name, BAD_CAST "following"))
  ------------------
  |  |   35|      0|#define BAD_CAST (xmlChar *)
  ------------------
  |  Branch (10456:10): [True: 0, False: 0]
  ------------------
10457|      0|		ret = AXIS_FOLLOWING;
10458|      0|	    if (xmlStrEqual(name, BAD_CAST "following-sibling"))
  ------------------
  |  |   35|      0|#define BAD_CAST (xmlChar *)
  ------------------
  |  Branch (10458:10): [True: 0, False: 0]
  ------------------
10459|      0|		ret = AXIS_FOLLOWING_SIBLING;
10460|      0|	    break;
10461|      0|	case 'n':
  ------------------
  |  Branch (10461:2): [True: 0, False: 4]
  ------------------
10462|      0|	    if (xmlStrEqual(name, BAD_CAST "namespace"))
  ------------------
  |  |   35|      0|#define BAD_CAST (xmlChar *)
  ------------------
  |  Branch (10462:10): [True: 0, False: 0]
  ------------------
10463|      0|		ret = AXIS_NAMESPACE;
10464|      0|	    break;
10465|      0|	case 'p':
  ------------------
  |  Branch (10465:2): [True: 0, False: 4]
  ------------------
10466|      0|	    if (xmlStrEqual(name, BAD_CAST "parent"))
  ------------------
  |  |   35|      0|#define BAD_CAST (xmlChar *)
  ------------------
  |  Branch (10466:10): [True: 0, False: 0]
  ------------------
10467|      0|		ret = AXIS_PARENT;
10468|      0|	    if (xmlStrEqual(name, BAD_CAST "preceding"))
  ------------------
  |  |   35|      0|#define BAD_CAST (xmlChar *)
  ------------------
  |  Branch (10468:10): [True: 0, False: 0]
  ------------------
10469|      0|		ret = AXIS_PRECEDING;
10470|      0|	    if (xmlStrEqual(name, BAD_CAST "preceding-sibling"))
  ------------------
  |  |   35|      0|#define BAD_CAST (xmlChar *)
  ------------------
  |  Branch (10470:10): [True: 0, False: 0]
  ------------------
10471|      0|		ret = AXIS_PRECEDING_SIBLING;
10472|      0|	    break;
10473|      0|	case 's':
  ------------------
  |  Branch (10473:2): [True: 0, False: 4]
  ------------------
10474|      0|	    if (xmlStrEqual(name, BAD_CAST "self"))
  ------------------
  |  |   35|      0|#define BAD_CAST (xmlChar *)
  ------------------
  |  Branch (10474:10): [True: 0, False: 0]
  ------------------
10475|      0|		ret = AXIS_SELF;
10476|      0|	    break;
10477|      4|    }
10478|      4|    return(ret);
10479|      4|}
xpath.c:xmlXPathCompNodeTest:
10299|      4|		     xmlChar *name) {
10300|      4|    int blanks;
10301|       |
10302|      4|    if ((test == NULL) || (type == NULL) || (prefix == NULL)) {
  ------------------
  |  Branch (10302:9): [True: 0, False: 4]
  |  Branch (10302:27): [True: 0, False: 4]
  |  Branch (10302:45): [True: 0, False: 4]
  ------------------
10303|      0|	STRANGE;
  ------------------
  |  | 1230|      0|    xmlGenericError(xmlGenericErrorContext,				\
  |  |  ------------------
  |  |  |  |  875|      0|  #define xmlGenericError XML_GLOBAL_MACRO(xmlGenericError)
  |  |  |  |  ------------------
  |  |  |  |  |  |  500|      0|  #define XML_GLOBAL_MACRO(name) (*__##name())
  |  |  |  |  ------------------
  |  |  ------------------
  |  |                   xmlGenericError(xmlGenericErrorContext,				\
  |  |  ------------------
  |  |  |  |  876|      0|  #define xmlGenericErrorContext XML_GLOBAL_MACRO(xmlGenericErrorContext)
  |  |  |  |  ------------------
  |  |  |  |  |  |  500|      0|  #define XML_GLOBAL_MACRO(name) (*__##name())
  |  |  |  |  ------------------
  |  |  ------------------
  |  | 1231|      0|	    "Internal error at %s:%d\n",				\
  |  | 1232|      0|            __FILE__, __LINE__);
  ------------------
10304|      0|	return(NULL);
10305|      0|    }
10306|      4|    *type = (xmlXPathTypeVal) 0;
10307|      4|    *test = (xmlXPathTestVal) 0;
10308|      4|    *prefix = NULL;
10309|      4|    SKIP_BLANKS;
  ------------------
  |  | 2509|      4|    while (IS_BLANK_CH(*(ctxt->cur))) NEXT
  |  |  ------------------
  |  |  |  | 2512|      4|#define NEXT ((*ctxt->cur) ?  ctxt->cur++: ctxt->cur)
  |  |  |  |  ------------------
  |  |  |  |  |  Branch (2512:15): [True: 0, False: 0]
  |  |  |  |  ------------------
  |  |  ------------------
  ------------------
10310|       |
10311|      4|    if ((name == NULL) && (CUR == '*')) {
  ------------------
  |  | 2496|      0|#define CUR (*ctxt->cur)
  ------------------
  |  Branch (10311:9): [True: 0, False: 4]
  |  Branch (10311:27): [True: 0, False: 0]
  ------------------
10312|       |	/*
10313|       |	 * All elements
10314|       |	 */
10315|      0|	NEXT;
  ------------------
  |  | 2512|      0|#define NEXT ((*ctxt->cur) ?  ctxt->cur++: ctxt->cur)
  |  |  ------------------
  |  |  |  Branch (2512:15): [True: 0, False: 0]
  |  |  ------------------
  ------------------
10316|      0|	*test = NODE_TEST_ALL;
10317|      0|	return(NULL);
10318|      0|    }
10319|       |
10320|      4|    if (name == NULL)
  ------------------
  |  Branch (10320:9): [True: 0, False: 4]
  ------------------
10321|      0|	name = xmlXPathParseNCName(ctxt);
10322|      4|    if (name == NULL) {
  ------------------
  |  Branch (10322:9): [True: 0, False: 4]
  ------------------
10323|      0|	XP_ERRORNULL(XPATH_EXPR_ERROR);
  ------------------
  |  |  589|      0|    { xmlXPathErr(ctxt, X); return(NULL); }
  ------------------
10324|      0|    }
10325|       |
10326|      4|    blanks = IS_BLANK_CH(CUR);
  ------------------
  |  |  151|      4|#define IS_BLANK_CH(c)  xmlIsBlank_ch(c)
  |  |  ------------------
  |  |  |  |   88|      4|#define xmlIsBlank_ch(c)	(((c) == 0x20) || \
  |  |  |  |  ------------------
  |  |  |  |  |  Branch (88:27): [True: 0, False: 4]
  |  |  |  |  ------------------
  |  |  |  |   89|      4|				 ((0x9 <= (c)) && ((c) <= 0xa)) || \
  |  |  |  |  ------------------
  |  |  |  |  |  Branch (89:7): [True: 4, False: 0]
  |  |  |  |  |  Branch (89:23): [True: 0, False: 4]
  |  |  |  |  ------------------
  |  |  |  |   90|      4|				 ((c) == 0xd))
  |  |  |  |  ------------------
  |  |  |  |  |  Branch (90:6): [True: 0, False: 4]
  |  |  |  |  ------------------
  |  |  ------------------
  ------------------
10327|      4|    SKIP_BLANKS;
  ------------------
  |  | 2509|      4|    while (IS_BLANK_CH(*(ctxt->cur))) NEXT
  |  |  ------------------
  |  |  |  | 2512|      4|#define NEXT ((*ctxt->cur) ?  ctxt->cur++: ctxt->cur)
  |  |  |  |  ------------------
  |  |  |  |  |  Branch (2512:15): [True: 0, False: 0]
  |  |  |  |  ------------------
  |  |  ------------------
  ------------------
10328|      4|    if (CUR == '(') {
  ------------------
  |  | 2496|      4|#define CUR (*ctxt->cur)
  ------------------
  |  Branch (10328:9): [True: 2, False: 2]
  ------------------
10329|      2|	NEXT;
  ------------------
  |  | 2512|      2|#define NEXT ((*ctxt->cur) ?  ctxt->cur++: ctxt->cur)
  |  |  ------------------
  |  |  |  Branch (2512:15): [True: 2, False: 0]
  |  |  ------------------
  ------------------
10330|       |	/*
10331|       |	 * NodeType or PI search
10332|       |	 */
10333|      2|	if (xmlStrEqual(name, BAD_CAST "comment"))
  ------------------
  |  |   35|      2|#define BAD_CAST (xmlChar *)
  ------------------
  |  Branch (10333:6): [True: 0, False: 2]
  ------------------
10334|      0|	    *type = NODE_TYPE_COMMENT;
10335|      2|	else if (xmlStrEqual(name, BAD_CAST "node"))
  ------------------
  |  |   35|      2|#define BAD_CAST (xmlChar *)
  ------------------
  |  Branch (10335:11): [True: 0, False: 2]
  ------------------
10336|      0|	    *type = NODE_TYPE_NODE;
10337|      2|	else if (xmlStrEqual(name, BAD_CAST "processing-instruction"))
  ------------------
  |  |   35|      2|#define BAD_CAST (xmlChar *)
  ------------------
  |  Branch (10337:11): [True: 0, False: 2]
  ------------------
10338|      0|	    *type = NODE_TYPE_PI;
10339|      2|	else if (xmlStrEqual(name, BAD_CAST "text"))
  ------------------
  |  |   35|      2|#define BAD_CAST (xmlChar *)
  ------------------
  |  Branch (10339:11): [True: 2, False: 0]
  ------------------
10340|      2|	    *type = NODE_TYPE_TEXT;
10341|      0|	else {
10342|      0|	    if (name != NULL)
  ------------------
  |  Branch (10342:10): [True: 0, False: 0]
  ------------------
10343|      0|		xmlFree(name);
10344|      0|	    XP_ERRORNULL(XPATH_EXPR_ERROR);
  ------------------
  |  |  589|      0|    { xmlXPathErr(ctxt, X); return(NULL); }
  ------------------
10345|      0|	}
10346|       |
10347|      2|	*test = NODE_TEST_TYPE;
10348|       |
10349|      2|	SKIP_BLANKS;
  ------------------
  |  | 2509|      2|    while (IS_BLANK_CH(*(ctxt->cur))) NEXT
  |  |  ------------------
  |  |  |  | 2512|      2|#define NEXT ((*ctxt->cur) ?  ctxt->cur++: ctxt->cur)
  |  |  |  |  ------------------
  |  |  |  |  |  Branch (2512:15): [True: 0, False: 0]
  |  |  |  |  ------------------
  |  |  ------------------
  ------------------
10350|      2|	if (*type == NODE_TYPE_PI) {
  ------------------
  |  Branch (10350:6): [True: 0, False: 2]
  ------------------
10351|       |	    /*
10352|       |	     * Specific case: search a PI by name.
10353|       |	     */
10354|      0|	    if (name != NULL)
  ------------------
  |  Branch (10354:10): [True: 0, False: 0]
  ------------------
10355|      0|		xmlFree(name);
10356|      0|	    name = NULL;
10357|      0|	    if (CUR != ')') {
  ------------------
  |  | 2496|      0|#define CUR (*ctxt->cur)
  ------------------
  |  Branch (10357:10): [True: 0, False: 0]
  ------------------
10358|      0|		name = xmlXPathParseLiteral(ctxt);
10359|      0|                if (name == NULL) {
  ------------------
  |  Branch (10359:21): [True: 0, False: 0]
  ------------------
10360|      0|	            XP_ERRORNULL(XPATH_EXPR_ERROR);
  ------------------
  |  |  589|      0|    { xmlXPathErr(ctxt, X); return(NULL); }
  ------------------
10361|      0|                }
10362|      0|		*test = NODE_TEST_PI;
10363|      0|		SKIP_BLANKS;
  ------------------
  |  | 2509|      0|    while (IS_BLANK_CH(*(ctxt->cur))) NEXT
  |  |  ------------------
  |  |  |  | 2512|      0|#define NEXT ((*ctxt->cur) ?  ctxt->cur++: ctxt->cur)
  |  |  |  |  ------------------
  |  |  |  |  |  Branch (2512:15): [True: 0, False: 0]
  |  |  |  |  ------------------
  |  |  ------------------
  ------------------
10364|      0|	    }
10365|      0|	}
10366|      2|	if (CUR != ')') {
  ------------------
  |  | 2496|      2|#define CUR (*ctxt->cur)
  ------------------
  |  Branch (10366:6): [True: 0, False: 2]
  ------------------
10367|      0|	    if (name != NULL)
  ------------------
  |  Branch (10367:10): [True: 0, False: 0]
  ------------------
10368|      0|		xmlFree(name);
10369|      0|	    XP_ERRORNULL(XPATH_UNCLOSED_ERROR);
  ------------------
  |  |  589|      0|    { xmlXPathErr(ctxt, X); return(NULL); }
  ------------------
10370|      0|	}
10371|      2|	NEXT;
  ------------------
  |  | 2512|      2|#define NEXT ((*ctxt->cur) ?  ctxt->cur++: ctxt->cur)
  |  |  ------------------
  |  |  |  Branch (2512:15): [True: 2, False: 0]
  |  |  ------------------
  ------------------
10372|      2|	return(name);
10373|      2|    }
10374|      2|    *test = NODE_TEST_NAME;
10375|      2|    if ((!blanks) && (CUR == ':')) {
  ------------------
  |  | 2496|      2|#define CUR (*ctxt->cur)
  ------------------
  |  Branch (10375:9): [True: 2, False: 0]
  |  Branch (10375:22): [True: 0, False: 2]
  ------------------
10376|      0|	NEXT;
  ------------------
  |  | 2512|      0|#define NEXT ((*ctxt->cur) ?  ctxt->cur++: ctxt->cur)
  |  |  ------------------
  |  |  |  Branch (2512:15): [True: 0, False: 0]
  |  |  ------------------
  ------------------
10377|       |
10378|       |	/*
10379|       |	 * Since currently the parser context don't have a
10380|       |	 * namespace list associated:
10381|       |	 * The namespace name for this prefix can be computed
10382|       |	 * only at evaluation time. The compilation is done
10383|       |	 * outside of any context.
10384|       |	 */
10385|       |#if 0
10386|       |	*prefix = xmlXPathNsLookup(ctxt->context, name);
10387|       |	if (name != NULL)
10388|       |	    xmlFree(name);
10389|       |	if (*prefix == NULL) {
10390|       |	    XP_ERROR0(XPATH_UNDEF_PREFIX_ERROR);
10391|       |	}
10392|       |#else
10393|      0|	*prefix = name;
10394|      0|#endif
10395|       |
10396|      0|	if (CUR == '*') {
  ------------------
  |  | 2496|      0|#define CUR (*ctxt->cur)
  ------------------
  |  Branch (10396:6): [True: 0, False: 0]
  ------------------
10397|       |	    /*
10398|       |	     * All elements
10399|       |	     */
10400|      0|	    NEXT;
  ------------------
  |  | 2512|      0|#define NEXT ((*ctxt->cur) ?  ctxt->cur++: ctxt->cur)
  |  |  ------------------
  |  |  |  Branch (2512:15): [True: 0, False: 0]
  |  |  ------------------
  ------------------
10401|      0|	    *test = NODE_TEST_ALL;
10402|      0|	    return(NULL);
10403|      0|	}
10404|       |
10405|      0|	name = xmlXPathParseNCName(ctxt);
10406|      0|	if (name == NULL) {
  ------------------
  |  Branch (10406:6): [True: 0, False: 0]
  ------------------
10407|      0|	    XP_ERRORNULL(XPATH_EXPR_ERROR);
  ------------------
  |  |  589|      0|    { xmlXPathErr(ctxt, X); return(NULL); }
  ------------------
10408|      0|	}
10409|      0|    }
10410|      2|    return(name);
10411|      2|}
xpath.c:xmlXPathCompExprAdd:
 1106|     12|   int value2, int value3, void *value4, void *value5) {
 1107|     12|    xmlXPathCompExprPtr comp = ctxt->comp;
 1108|     12|    if (comp->nbStep >= comp->maxStep) {
  ------------------
  |  Branch (1108:9): [True: 0, False: 12]
  ------------------
 1109|      0|	xmlXPathStepOp *real;
 1110|       |
 1111|      0|        if (comp->maxStep >= XPATH_MAX_STEPS) {
  ------------------
  |  |   97|      0|#define XPATH_MAX_STEPS 1000000
  ------------------
  |  Branch (1111:13): [True: 0, False: 0]
  ------------------
 1112|      0|	    xmlXPathPErrMemory(ctxt, "adding step\n");
 1113|      0|	    return(-1);
 1114|      0|        }
 1115|      0|	comp->maxStep *= 2;
 1116|      0|	real = (xmlXPathStepOp *) xmlRealloc(comp->steps,
 1117|      0|		                      comp->maxStep * sizeof(xmlXPathStepOp));
 1118|      0|	if (real == NULL) {
  ------------------
  |  Branch (1118:6): [True: 0, False: 0]
  ------------------
 1119|      0|	    comp->maxStep /= 2;
 1120|      0|	    xmlXPathPErrMemory(ctxt, "adding step\n");
 1121|      0|	    return(-1);
 1122|      0|	}
 1123|      0|	comp->steps = real;
 1124|      0|    }
 1125|     12|    comp->last = comp->nbStep;
 1126|     12|    comp->steps[comp->nbStep].ch1 = ch1;
 1127|     12|    comp->steps[comp->nbStep].ch2 = ch2;
 1128|     12|    comp->steps[comp->nbStep].op = op;
 1129|     12|    comp->steps[comp->nbStep].value = value;
 1130|     12|    comp->steps[comp->nbStep].value2 = value2;
 1131|     12|    comp->steps[comp->nbStep].value3 = value3;
 1132|     12|    if ((comp->dict != NULL) &&
  ------------------
  |  Branch (1132:9): [True: 0, False: 12]
  ------------------
 1133|     12|        ((op == XPATH_OP_FUNCTION) || (op == XPATH_OP_VARIABLE) ||
  ------------------
  |  Branch (1133:10): [True: 0, False: 0]
  |  Branch (1133:39): [True: 0, False: 0]
  ------------------
 1134|      0|	 (op == XPATH_OP_COLLECT))) {
  ------------------
  |  Branch (1134:3): [True: 0, False: 0]
  ------------------
 1135|      0|        if (value4 != NULL) {
  ------------------
  |  Branch (1135:13): [True: 0, False: 0]
  ------------------
 1136|      0|	    comp->steps[comp->nbStep].value4 = (xmlChar *)
 1137|      0|	        (void *)xmlDictLookup(comp->dict, value4, -1);
 1138|      0|	    xmlFree(value4);
 1139|      0|	} else
 1140|      0|	    comp->steps[comp->nbStep].value4 = NULL;
 1141|      0|        if (value5 != NULL) {
  ------------------
  |  Branch (1141:13): [True: 0, False: 0]
  ------------------
 1142|      0|	    comp->steps[comp->nbStep].value5 = (xmlChar *)
 1143|      0|	        (void *)xmlDictLookup(comp->dict, value5, -1);
 1144|      0|	    xmlFree(value5);
 1145|      0|	} else
 1146|      0|	    comp->steps[comp->nbStep].value5 = NULL;
 1147|     12|    } else {
 1148|     12|	comp->steps[comp->nbStep].value4 = value4;
 1149|     12|	comp->steps[comp->nbStep].value5 = value5;
 1150|     12|    }
 1151|     12|    comp->steps[comp->nbStep].cache = NULL;
 1152|     12|    return(comp->nbStep++);
 1153|     12|}
xpath.c:xmlXPathOptimizeExpression:
13239|     12|{
13240|     12|    xmlXPathCompExprPtr comp = pctxt->comp;
13241|     12|    xmlXPathContextPtr ctxt;
13242|       |
13243|       |    /*
13244|       |    * Try to rewrite "descendant-or-self::node()/foo" to an optimized
13245|       |    * internal representation.
13246|       |    */
13247|       |
13248|     12|    if ((op->op == XPATH_OP_COLLECT /* 11 */) &&
  ------------------
  |  Branch (13248:9): [True: 4, False: 8]
  ------------------
13249|     12|        (op->ch1 != -1) &&
  ------------------
  |  Branch (13249:9): [True: 4, False: 0]
  ------------------
13250|     12|        (op->ch2 == -1 /* no predicate */))
  ------------------
  |  Branch (13250:9): [True: 2, False: 2]
  ------------------
13251|      2|    {
13252|      2|        xmlXPathStepOpPtr prevop = &comp->steps[op->ch1];
13253|       |
13254|      2|        if ((prevop->op == XPATH_OP_COLLECT /* 11 */) &&
  ------------------
  |  Branch (13254:13): [True: 0, False: 2]
  ------------------
13255|      2|            ((xmlXPathAxisVal) prevop->value ==
  ------------------
  |  Branch (13255:13): [True: 0, False: 0]
  ------------------
13256|      0|                AXIS_DESCENDANT_OR_SELF) &&
13257|      2|            (prevop->ch2 == -1) &&
  ------------------
  |  Branch (13257:13): [True: 0, False: 0]
  ------------------
13258|      2|            ((xmlXPathTestVal) prevop->value2 == NODE_TEST_TYPE) &&
  ------------------
  |  Branch (13258:13): [True: 0, False: 0]
  ------------------
13259|      2|            ((xmlXPathTypeVal) prevop->value3 == NODE_TYPE_NODE))
  ------------------
  |  Branch (13259:13): [True: 0, False: 0]
  ------------------
13260|      0|        {
13261|       |            /*
13262|       |            * This is a "descendant-or-self::node()" without predicates.
13263|       |            * Try to eliminate it.
13264|       |            */
13265|       |
13266|      0|            switch ((xmlXPathAxisVal) op->value) {
13267|      0|                case AXIS_CHILD:
  ------------------
  |  Branch (13267:17): [True: 0, False: 0]
  ------------------
13268|      0|                case AXIS_DESCENDANT:
  ------------------
  |  Branch (13268:17): [True: 0, False: 0]
  ------------------
13269|       |                    /*
13270|       |                    * Convert "descendant-or-self::node()/child::" or
13271|       |                    * "descendant-or-self::node()/descendant::" to
13272|       |                    * "descendant::"
13273|       |                    */
13274|      0|                    op->ch1   = prevop->ch1;
13275|      0|                    op->value = AXIS_DESCENDANT;
13276|      0|                    break;
13277|      0|                case AXIS_SELF:
  ------------------
  |  Branch (13277:17): [True: 0, False: 0]
  ------------------
13278|      0|                case AXIS_DESCENDANT_OR_SELF:
  ------------------
  |  Branch (13278:17): [True: 0, False: 0]
  ------------------
13279|       |                    /*
13280|       |                    * Convert "descendant-or-self::node()/self::" or
13281|       |                    * "descendant-or-self::node()/descendant-or-self::" to
13282|       |                    * to "descendant-or-self::"
13283|       |                    */
13284|      0|                    op->ch1   = prevop->ch1;
13285|      0|                    op->value = AXIS_DESCENDANT_OR_SELF;
13286|      0|                    break;
13287|      0|                default:
  ------------------
  |  Branch (13287:17): [True: 0, False: 0]
  ------------------
13288|      0|                    break;
13289|      0|            }
13290|      0|	}
13291|      2|    }
13292|       |
13293|       |    /* OP_VALUE has invalid ch1. */
13294|     12|    if (op->op == XPATH_OP_VALUE)
  ------------------
  |  Branch (13294:9): [True: 2, False: 10]
  ------------------
13295|      2|        return;
13296|       |
13297|       |    /* Recurse */
13298|     10|    ctxt = pctxt->context;
13299|     10|    if (ctxt != NULL) {
  ------------------
  |  Branch (13299:9): [True: 10, False: 0]
  ------------------
13300|     10|        if (ctxt->depth >= XPATH_MAX_RECURSION_DEPTH)
  ------------------
  |  |  124|     10|#define XPATH_MAX_RECURSION_DEPTH 500
  ------------------
  |  Branch (13300:13): [True: 0, False: 10]
  ------------------
13301|      0|            return;
13302|     10|        ctxt->depth += 1;
13303|     10|    }
13304|     10|    if (op->ch1 != -1)
  ------------------
  |  Branch (13304:9): [True: 6, False: 4]
  ------------------
13305|      6|        xmlXPathOptimizeExpression(pctxt, &comp->steps[op->ch1]);
13306|     10|    if (op->ch2 != -1)
  ------------------
  |  Branch (13306:9): [True: 4, False: 6]
  ------------------
13307|      4|	xmlXPathOptimizeExpression(pctxt, &comp->steps[op->ch2]);
13308|     10|    if (ctxt != NULL)
  ------------------
  |  Branch (13308:9): [True: 10, False: 0]
  ------------------
13309|     10|        ctxt->depth -= 1;
13310|     10|}
xpath.c:xmlXPathRunEval:
12989|     82|{
12990|     82|    xmlXPathCompExprPtr comp;
12991|     82|    int oldDepth;
12992|       |
12993|     82|    if ((ctxt == NULL) || (ctxt->comp == NULL))
  ------------------
  |  Branch (12993:9): [True: 0, False: 82]
  |  Branch (12993:27): [True: 0, False: 82]
  ------------------
12994|      0|	return(-1);
12995|       |
12996|     82|    if (ctxt->valueTab == NULL) {
  ------------------
  |  Branch (12996:9): [True: 0, False: 82]
  ------------------
12997|       |	/* Allocate the value stack */
12998|      0|	ctxt->valueTab = (xmlXPathObjectPtr *)
12999|      0|			 xmlMalloc(10 * sizeof(xmlXPathObjectPtr));
13000|      0|	if (ctxt->valueTab == NULL) {
  ------------------
  |  Branch (13000:6): [True: 0, False: 0]
  ------------------
13001|      0|	    xmlXPathPErrMemory(ctxt, "creating evaluation context\n");
13002|      0|	    return(-1);
13003|      0|	}
13004|      0|	ctxt->valueNr = 0;
13005|      0|	ctxt->valueMax = 10;
13006|      0|	ctxt->value = NULL;
13007|      0|    }
13008|     82|#ifdef XPATH_STREAMING
13009|     82|    if (ctxt->comp->stream) {
  ------------------
  |  Branch (13009:9): [True: 80, False: 2]
  ------------------
13010|     80|	int res;
13011|       |
13012|     80|	if (toBool) {
  ------------------
  |  Branch (13012:6): [True: 0, False: 80]
  ------------------
13013|       |	    /*
13014|       |	    * Evaluation to boolean result.
13015|       |	    */
13016|      0|	    res = xmlXPathRunStreamEval(ctxt->context,
13017|      0|		ctxt->comp->stream, NULL, 1);
13018|      0|	    if (res != -1)
  ------------------
  |  Branch (13018:10): [True: 0, False: 0]
  ------------------
13019|      0|		return(res);
13020|     80|	} else {
13021|     80|	    xmlXPathObjectPtr resObj = NULL;
13022|       |
13023|       |	    /*
13024|       |	    * Evaluation to a sequence.
13025|       |	    */
13026|     80|	    res = xmlXPathRunStreamEval(ctxt->context,
13027|     80|		ctxt->comp->stream, &resObj, 0);
13028|       |
13029|     80|	    if ((res != -1) && (resObj != NULL)) {
  ------------------
  |  Branch (13029:10): [True: 80, False: 0]
  |  Branch (13029:25): [True: 80, False: 0]
  ------------------
13030|     80|		valuePush(ctxt, resObj);
13031|     80|		return(0);
13032|     80|	    }
13033|      0|	    if (resObj != NULL)
  ------------------
  |  Branch (13033:10): [True: 0, False: 0]
  ------------------
13034|      0|		xmlXPathReleaseObject(ctxt->context, resObj);
13035|      0|	}
13036|       |	/*
13037|       |	* QUESTION TODO: This falls back to normal XPath evaluation
13038|       |	* if res == -1. Is this intended?
13039|       |	*/
13040|     80|    }
13041|      2|#endif
13042|      2|    comp = ctxt->comp;
13043|      2|    if (comp->last < 0) {
  ------------------
  |  Branch (13043:9): [True: 0, False: 2]
  ------------------
13044|      0|	xmlGenericError(xmlGenericErrorContext,
  ------------------
  |  |  875|      0|  #define xmlGenericError XML_GLOBAL_MACRO(xmlGenericError)
  |  |  ------------------
  |  |  |  |  500|      0|  #define XML_GLOBAL_MACRO(name) (*__##name())
  |  |  ------------------
  ------------------
              	xmlGenericError(xmlGenericErrorContext,
  ------------------
  |  |  876|      0|  #define xmlGenericErrorContext XML_GLOBAL_MACRO(xmlGenericErrorContext)
  |  |  ------------------
  |  |  |  |  500|      0|  #define XML_GLOBAL_MACRO(name) (*__##name())
  |  |  ------------------
  ------------------
13045|      0|	    "xmlXPathRunEval: last is less than zero\n");
13046|      0|	return(-1);
13047|      0|    }
13048|      2|    oldDepth = ctxt->context->depth;
13049|      2|    if (toBool)
  ------------------
  |  Branch (13049:9): [True: 0, False: 2]
  ------------------
13050|      0|	return(xmlXPathCompOpEvalToBoolean(ctxt,
13051|      0|	    &comp->steps[comp->last], 0));
13052|      2|    else
13053|      2|	xmlXPathCompOpEval(ctxt, &comp->steps[comp->last]);
13054|      2|    ctxt->context->depth = oldDepth;
13055|       |
13056|      2|    return(0);
13057|      2|}
xpath.c:xmlXPathRunStreamEval:
12754|     80|{
12755|     80|    int max_depth, min_depth;
12756|     80|    int from_root;
12757|     80|    int ret, depth;
12758|     80|    int eval_all_nodes;
12759|     80|    xmlNodePtr cur = NULL, limit = NULL;
12760|     80|    xmlStreamCtxtPtr patstream = NULL;
12761|       |
12762|     80|    if ((ctxt == NULL) || (comp == NULL))
  ------------------
  |  Branch (12762:9): [True: 0, False: 80]
  |  Branch (12762:27): [True: 0, False: 80]
  ------------------
12763|      0|        return(-1);
12764|     80|    max_depth = xmlPatternMaxDepth(comp);
12765|     80|    if (max_depth == -1)
  ------------------
  |  Branch (12765:9): [True: 0, False: 80]
  ------------------
12766|      0|        return(-1);
12767|     80|    if (max_depth == -2)
  ------------------
  |  Branch (12767:9): [True: 76, False: 4]
  ------------------
12768|     76|        max_depth = 10000;
12769|     80|    min_depth = xmlPatternMinDepth(comp);
12770|     80|    if (min_depth == -1)
  ------------------
  |  Branch (12770:9): [True: 0, False: 80]
  ------------------
12771|      0|        return(-1);
12772|     80|    from_root = xmlPatternFromRoot(comp);
12773|     80|    if (from_root < 0)
  ------------------
  |  Branch (12773:9): [True: 0, False: 80]
  ------------------
12774|      0|        return(-1);
12775|       |#if 0
12776|       |    printf("stream eval: depth %d from root %d\n", max_depth, from_root);
12777|       |#endif
12778|       |
12779|     80|    if (! toBool) {
  ------------------
  |  Branch (12779:9): [True: 80, False: 0]
  ------------------
12780|     80|	if (resultSeq == NULL)
  ------------------
  |  Branch (12780:6): [True: 0, False: 80]
  ------------------
12781|      0|	    return(-1);
12782|     80|	*resultSeq = xmlXPathCacheNewNodeSet(ctxt, NULL);
12783|     80|	if (*resultSeq == NULL)
  ------------------
  |  Branch (12783:6): [True: 0, False: 80]
  ------------------
12784|      0|	    return(-1);
12785|     80|    }
12786|       |
12787|       |    /*
12788|       |     * handle the special cases of "/" amd "." being matched
12789|       |     */
12790|     80|    if (min_depth == 0) {
  ------------------
  |  Branch (12790:9): [True: 0, False: 80]
  ------------------
12791|      0|	if (from_root) {
  ------------------
  |  Branch (12791:6): [True: 0, False: 0]
  ------------------
12792|       |	    /* Select "/" */
12793|      0|	    if (toBool)
  ------------------
  |  Branch (12793:10): [True: 0, False: 0]
  ------------------
12794|      0|		return(1);
12795|       |            /* TODO: Check memory error. */
12796|      0|	    xmlXPathNodeSetAddUnique((*resultSeq)->nodesetval,
12797|      0|		                     (xmlNodePtr) ctxt->doc);
12798|      0|	} else {
12799|       |	    /* Select "self::node()" */
12800|      0|	    if (toBool)
  ------------------
  |  Branch (12800:10): [True: 0, False: 0]
  ------------------
12801|      0|		return(1);
12802|       |            /* TODO: Check memory error. */
12803|      0|	    xmlXPathNodeSetAddUnique((*resultSeq)->nodesetval, ctxt->node);
12804|      0|	}
12805|      0|    }
12806|     80|    if (max_depth == 0) {
  ------------------
  |  Branch (12806:9): [True: 0, False: 80]
  ------------------
12807|      0|	return(0);
12808|      0|    }
12809|       |
12810|     80|    if (from_root) {
  ------------------
  |  Branch (12810:9): [True: 80, False: 0]
  ------------------
12811|     80|        cur = (xmlNodePtr)ctxt->doc;
12812|     80|    } else if (ctxt->node != NULL) {
  ------------------
  |  Branch (12812:16): [True: 0, False: 0]
  ------------------
12813|      0|        switch (ctxt->node->type) {
  ------------------
  |  Branch (12813:17): [True: 0, False: 0]
  ------------------
12814|      0|            case XML_ELEMENT_NODE:
  ------------------
  |  Branch (12814:13): [True: 0, False: 0]
  ------------------
12815|      0|            case XML_DOCUMENT_NODE:
  ------------------
  |  Branch (12815:13): [True: 0, False: 0]
  ------------------
12816|      0|            case XML_DOCUMENT_FRAG_NODE:
  ------------------
  |  Branch (12816:13): [True: 0, False: 0]
  ------------------
12817|      0|            case XML_HTML_DOCUMENT_NODE:
  ------------------
  |  Branch (12817:13): [True: 0, False: 0]
  ------------------
12818|      0|	        cur = ctxt->node;
12819|      0|		break;
12820|      0|            case XML_ATTRIBUTE_NODE:
  ------------------
  |  Branch (12820:13): [True: 0, False: 0]
  ------------------
12821|      0|            case XML_TEXT_NODE:
  ------------------
  |  Branch (12821:13): [True: 0, False: 0]
  ------------------
12822|      0|            case XML_CDATA_SECTION_NODE:
  ------------------
  |  Branch (12822:13): [True: 0, False: 0]
  ------------------
12823|      0|            case XML_ENTITY_REF_NODE:
  ------------------
  |  Branch (12823:13): [True: 0, False: 0]
  ------------------
12824|      0|            case XML_ENTITY_NODE:
  ------------------
  |  Branch (12824:13): [True: 0, False: 0]
  ------------------
12825|      0|            case XML_PI_NODE:
  ------------------
  |  Branch (12825:13): [True: 0, False: 0]
  ------------------
12826|      0|            case XML_COMMENT_NODE:
  ------------------
  |  Branch (12826:13): [True: 0, False: 0]
  ------------------
12827|      0|            case XML_NOTATION_NODE:
  ------------------
  |  Branch (12827:13): [True: 0, False: 0]
  ------------------
12828|      0|            case XML_DTD_NODE:
  ------------------
  |  Branch (12828:13): [True: 0, False: 0]
  ------------------
12829|      0|            case XML_DOCUMENT_TYPE_NODE:
  ------------------
  |  Branch (12829:13): [True: 0, False: 0]
  ------------------
12830|      0|            case XML_ELEMENT_DECL:
  ------------------
  |  Branch (12830:13): [True: 0, False: 0]
  ------------------
12831|      0|            case XML_ATTRIBUTE_DECL:
  ------------------
  |  Branch (12831:13): [True: 0, False: 0]
  ------------------
12832|      0|            case XML_ENTITY_DECL:
  ------------------
  |  Branch (12832:13): [True: 0, False: 0]
  ------------------
12833|      0|            case XML_NAMESPACE_DECL:
  ------------------
  |  Branch (12833:13): [True: 0, False: 0]
  ------------------
12834|      0|            case XML_XINCLUDE_START:
  ------------------
  |  Branch (12834:13): [True: 0, False: 0]
  ------------------
12835|      0|            case XML_XINCLUDE_END:
  ------------------
  |  Branch (12835:13): [True: 0, False: 0]
  ------------------
12836|      0|		break;
12837|      0|	}
12838|      0|	limit = cur;
12839|      0|    }
12840|     80|    if (cur == NULL) {
  ------------------
  |  Branch (12840:9): [True: 0, False: 80]
  ------------------
12841|      0|        return(0);
12842|      0|    }
12843|       |
12844|     80|    patstream = xmlPatternGetStreamCtxt(comp);
12845|     80|    if (patstream == NULL) {
  ------------------
  |  Branch (12845:9): [True: 0, False: 80]
  ------------------
12846|       |	/*
12847|       |	* QUESTION TODO: Is this an error?
12848|       |	*/
12849|      0|	return(0);
12850|      0|    }
12851|       |
12852|     80|    eval_all_nodes = xmlStreamWantsAnyNode(patstream);
12853|       |
12854|     80|    if (from_root) {
  ------------------
  |  Branch (12854:9): [True: 80, False: 0]
  ------------------
12855|     80|	ret = xmlStreamPush(patstream, NULL, NULL);
12856|     80|	if (ret < 0) {
  ------------------
  |  Branch (12856:6): [True: 0, False: 80]
  ------------------
12857|     80|	} else if (ret == 1) {
  ------------------
  |  Branch (12857:13): [True: 0, False: 80]
  ------------------
12858|      0|	    if (toBool)
  ------------------
  |  Branch (12858:10): [True: 0, False: 0]
  ------------------
12859|      0|		goto return_1;
12860|       |            /* TODO: Check memory error. */
12861|      0|	    xmlXPathNodeSetAddUnique((*resultSeq)->nodesetval, cur);
12862|      0|	}
12863|     80|    }
12864|     80|    depth = 0;
12865|     80|    goto scan_children;
12866|  6.26k|next_node:
12867|  18.6k|    do {
12868|  18.6k|        if (ctxt->opLimit != 0) {
  ------------------
  |  Branch (12868:13): [True: 0, False: 18.6k]
  ------------------
12869|      0|            if (ctxt->opCount >= ctxt->opLimit) {
  ------------------
  |  Branch (12869:17): [True: 0, False: 0]
  ------------------
12870|      0|                xmlGenericError(xmlGenericErrorContext,
  ------------------
  |  |  875|      0|  #define xmlGenericError XML_GLOBAL_MACRO(xmlGenericError)
  |  |  ------------------
  |  |  |  |  500|      0|  #define XML_GLOBAL_MACRO(name) (*__##name())
  |  |  ------------------
  ------------------
                              xmlGenericError(xmlGenericErrorContext,
  ------------------
  |  |  876|      0|  #define xmlGenericErrorContext XML_GLOBAL_MACRO(xmlGenericErrorContext)
  |  |  ------------------
  |  |  |  |  500|      0|  #define XML_GLOBAL_MACRO(name) (*__##name())
  |  |  ------------------
  ------------------
12871|      0|                        "XPath operation limit exceeded\n");
12872|      0|                xmlFreeStreamCtxt(patstream);
12873|      0|                return(-1);
12874|      0|            }
12875|      0|            ctxt->opCount++;
12876|      0|        }
12877|       |
12878|  18.6k|	switch (cur->type) {
12879|  12.3k|	    case XML_ELEMENT_NODE:
  ------------------
  |  Branch (12879:6): [True: 12.3k, False: 6.29k]
  ------------------
12880|  18.6k|	    case XML_TEXT_NODE:
  ------------------
  |  Branch (12880:6): [True: 6.29k, False: 12.3k]
  ------------------
12881|  18.6k|	    case XML_CDATA_SECTION_NODE:
  ------------------
  |  Branch (12881:6): [True: 0, False: 18.6k]
  ------------------
12882|  18.6k|	    case XML_COMMENT_NODE:
  ------------------
  |  Branch (12882:6): [True: 0, False: 18.6k]
  ------------------
12883|  18.6k|	    case XML_PI_NODE:
  ------------------
  |  Branch (12883:6): [True: 0, False: 18.6k]
  ------------------
12884|  18.6k|		if (cur->type == XML_ELEMENT_NODE) {
  ------------------
  |  Branch (12884:7): [True: 12.3k, False: 6.29k]
  ------------------
12885|  12.3k|		    ret = xmlStreamPush(patstream, cur->name,
12886|  12.3k|				(cur->ns ? cur->ns->href : NULL));
  ------------------
  |  Branch (12886:6): [True: 6.07k, False: 6.25k]
  ------------------
12887|  12.3k|		} else if (eval_all_nodes)
  ------------------
  |  Branch (12887:14): [True: 0, False: 6.29k]
  ------------------
12888|      0|		    ret = xmlStreamPushNode(patstream, NULL, NULL, cur->type);
12889|  6.29k|		else
12890|  6.29k|		    break;
12891|       |
12892|  12.3k|		if (ret < 0) {
  ------------------
  |  Branch (12892:7): [True: 0, False: 12.3k]
  ------------------
12893|       |		    /* NOP. */
12894|  12.3k|		} else if (ret == 1) {
  ------------------
  |  Branch (12894:14): [True: 88, False: 12.2k]
  ------------------
12895|     88|		    if (toBool)
  ------------------
  |  Branch (12895:11): [True: 0, False: 88]
  ------------------
12896|      0|			goto return_1;
12897|     88|		    if (xmlXPathNodeSetAddUnique((*resultSeq)->nodesetval, cur)
  ------------------
  |  Branch (12897:11): [True: 0, False: 88]
  ------------------
12898|     88|		        < 0) {
12899|      0|			ctxt->lastError.domain = XML_FROM_XPATH;
12900|      0|			ctxt->lastError.code = XML_ERR_NO_MEMORY;
12901|      0|		    }
12902|     88|		}
12903|  12.3k|		if ((cur->children == NULL) || (depth >= max_depth)) {
  ------------------
  |  Branch (12903:7): [True: 6.14k, False: 6.18k]
  |  Branch (12903:34): [True: 4, False: 6.18k]
  ------------------
12904|  6.15k|		    ret = xmlStreamPop(patstream);
12905|  6.15k|		    while (cur->next != NULL) {
  ------------------
  |  Branch (12905:14): [True: 79, False: 6.07k]
  ------------------
12906|     79|			cur = cur->next;
12907|     79|			if ((cur->type != XML_ENTITY_DECL) &&
  ------------------
  |  Branch (12907:8): [True: 79, False: 0]
  ------------------
12908|     79|			    (cur->type != XML_DTD_NODE))
  ------------------
  |  Branch (12908:8): [True: 79, False: 0]
  ------------------
12909|     79|			    goto next_node;
12910|     79|		    }
12911|  6.15k|		}
12912|  12.2k|	    default:
  ------------------
  |  Branch (12912:6): [True: 0, False: 18.6k]
  ------------------
12913|  12.2k|		break;
12914|  18.6k|	}
12915|       |
12916|  18.6k|scan_children:
12917|  18.6k|	if (cur->type == XML_NAMESPACE_DECL) break;
  ------------------
  |  Branch (12917:6): [True: 0, False: 18.6k]
  ------------------
12918|  18.6k|	if ((cur->children != NULL) && (depth < max_depth)) {
  ------------------
  |  Branch (12918:6): [True: 6.26k, False: 12.3k]
  |  Branch (12918:33): [True: 6.26k, False: 4]
  ------------------
12919|       |	    /*
12920|       |	     * Do not descend on entities declarations
12921|       |	     */
12922|  6.26k|	    if (cur->children->type != XML_ENTITY_DECL) {
  ------------------
  |  Branch (12922:10): [True: 6.26k, False: 0]
  ------------------
12923|  6.26k|		cur = cur->children;
12924|  6.26k|		depth++;
12925|       |		/*
12926|       |		 * Skip DTDs
12927|       |		 */
12928|  6.26k|		if (cur->type != XML_DTD_NODE)
  ------------------
  |  Branch (12928:7): [True: 6.26k, False: 0]
  ------------------
12929|  6.26k|		    continue;
12930|  6.26k|	    }
12931|  6.26k|	}
12932|       |
12933|  12.3k|	if (cur == limit)
  ------------------
  |  Branch (12933:6): [True: 0, False: 12.3k]
  ------------------
12934|      0|	    break;
12935|       |
12936|  12.3k|	while (cur->next != NULL) {
  ------------------
  |  Branch (12936:9): [True: 6.18k, False: 6.18k]
  ------------------
12937|  6.18k|	    cur = cur->next;
12938|  6.18k|	    if ((cur->type != XML_ENTITY_DECL) &&
  ------------------
  |  Branch (12938:10): [True: 6.18k, False: 0]
  ------------------
12939|  6.18k|		(cur->type != XML_DTD_NODE))
  ------------------
  |  Branch (12939:3): [True: 6.18k, False: 0]
  ------------------
12940|  6.18k|		goto next_node;
12941|  6.18k|	}
12942|       |
12943|  6.26k|	do {
12944|  6.26k|	    cur = cur->parent;
12945|  6.26k|	    depth--;
12946|  6.26k|	    if ((cur == NULL) || (cur == limit) ||
  ------------------
  |  Branch (12946:10): [True: 0, False: 6.26k]
  |  Branch (12946:27): [True: 0, False: 6.26k]
  ------------------
12947|  6.26k|                (cur->type == XML_DOCUMENT_NODE))
  ------------------
  |  Branch (12947:17): [True: 80, False: 6.18k]
  ------------------
12948|     80|	        goto done;
12949|  6.18k|	    if (cur->type == XML_ELEMENT_NODE) {
  ------------------
  |  Branch (12949:10): [True: 6.18k, False: 0]
  ------------------
12950|  6.18k|		ret = xmlStreamPop(patstream);
12951|  6.18k|	    } else if ((eval_all_nodes) &&
  ------------------
  |  Branch (12951:17): [True: 0, False: 0]
  ------------------
12952|      0|		((cur->type == XML_TEXT_NODE) ||
  ------------------
  |  Branch (12952:4): [True: 0, False: 0]
  ------------------
12953|      0|		 (cur->type == XML_CDATA_SECTION_NODE) ||
  ------------------
  |  Branch (12953:4): [True: 0, False: 0]
  ------------------
12954|      0|		 (cur->type == XML_COMMENT_NODE) ||
  ------------------
  |  Branch (12954:4): [True: 0, False: 0]
  ------------------
12955|      0|		 (cur->type == XML_PI_NODE)))
  ------------------
  |  Branch (12955:4): [True: 0, False: 0]
  ------------------
12956|      0|	    {
12957|      0|		ret = xmlStreamPop(patstream);
12958|      0|	    }
12959|  6.18k|	    if (cur->next != NULL) {
  ------------------
  |  Branch (12959:10): [True: 6.10k, False: 76]
  ------------------
12960|  6.10k|		cur = cur->next;
12961|  6.10k|		break;
12962|  6.10k|	    }
12963|  6.18k|	} while (cur != NULL);
  ------------------
  |  Branch (12963:11): [True: 76, False: 0]
  ------------------
12964|       |
12965|  12.3k|    } while ((cur != NULL) && (depth >= 0));
  ------------------
  |  Branch (12965:14): [True: 12.3k, False: 0]
  |  Branch (12965:31): [True: 12.3k, False: 0]
  ------------------
12966|       |
12967|     80|done:
12968|       |
12969|     80|    if (patstream)
  ------------------
  |  Branch (12969:9): [True: 80, False: 0]
  ------------------
12970|     80|	xmlFreeStreamCtxt(patstream);
12971|     80|    return(0);
12972|       |
12973|      0|return_1:
12974|      0|    if (patstream)
  ------------------
  |  Branch (12974:9): [True: 0, False: 0]
  ------------------
12975|      0|	xmlFreeStreamCtxt(patstream);
12976|      0|    return(1);
12977|  6.26k|}
xpath.c:xmlXPathNodeCollectAndTest:
11091|      4|{
11092|       |
11093|      4|#define XP_TEST_HIT \
11094|      4|    if (hasAxisRange != 0) { \
11095|      4|	if (++pos == maxPos) { \
11096|      4|	    if (addNode(seq, cur) < 0) \
11097|      4|	        ctxt->error = XPATH_MEMORY_ERROR; \
11098|      4|	    goto axis_range_end; } \
11099|      4|    } else { \
11100|      4|	if (addNode(seq, cur) < 0) \
11101|      4|	    ctxt->error = XPATH_MEMORY_ERROR; \
11102|      4|	if (breakOnFirstHit) goto first_hit; }
11103|       |
11104|      4|#define XP_TEST_HIT_NS \
11105|      4|    if (hasAxisRange != 0) { \
11106|      4|	if (++pos == maxPos) { \
11107|      4|	    hasNsNodes = 1; \
11108|      4|	    if (xmlXPathNodeSetAddNs(seq, xpctxt->node, (xmlNsPtr) cur) < 0) \
11109|      4|	        ctxt->error = XPATH_MEMORY_ERROR; \
11110|      4|	goto axis_range_end; } \
11111|      4|    } else { \
11112|      4|	hasNsNodes = 1; \
11113|      4|	if (xmlXPathNodeSetAddNs(seq, xpctxt->node, (xmlNsPtr) cur) < 0) \
11114|      4|	    ctxt->error = XPATH_MEMORY_ERROR; \
11115|      4|	if (breakOnFirstHit) goto first_hit; }
11116|       |
11117|      4|    xmlXPathAxisVal axis = (xmlXPathAxisVal) op->value;
11118|      4|    xmlXPathTestVal test = (xmlXPathTestVal) op->value2;
11119|      4|    xmlXPathTypeVal type = (xmlXPathTypeVal) op->value3;
11120|      4|    const xmlChar *prefix = op->value4;
11121|      4|    const xmlChar *name = op->value5;
11122|      4|    const xmlChar *URI = NULL;
11123|       |
11124|      4|    int total = 0, hasNsNodes = 0;
11125|       |    /* The popped object holding the context nodes */
11126|      4|    xmlXPathObjectPtr obj;
11127|       |    /* The set of context nodes for the node tests */
11128|      4|    xmlNodeSetPtr contextSeq;
11129|      4|    int contextIdx;
11130|      4|    xmlNodePtr contextNode;
11131|       |    /* The final resulting node set wrt to all context nodes */
11132|      4|    xmlNodeSetPtr outSeq;
11133|       |    /*
11134|       |    * The temporary resulting node set wrt 1 context node.
11135|       |    * Used to feed predicate evaluation.
11136|       |    */
11137|      4|    xmlNodeSetPtr seq;
11138|      4|    xmlNodePtr cur;
11139|       |    /* First predicate operator */
11140|      4|    xmlXPathStepOpPtr predOp;
11141|      4|    int maxPos; /* The requested position() (when a "[n]" predicate) */
11142|      4|    int hasPredicateRange, hasAxisRange, pos;
11143|      4|    int breakOnFirstHit;
11144|       |
11145|      4|    xmlXPathTraversalFunction next = NULL;
11146|      4|    int (*addNode) (xmlNodeSetPtr, xmlNodePtr);
11147|      4|    xmlXPathNodeSetMergeFunction mergeAndClear;
11148|      4|    xmlNodePtr oldContextNode;
11149|      4|    xmlXPathContextPtr xpctxt = ctxt->context;
11150|       |
11151|       |
11152|      4|    CHECK_TYPE0(XPATH_NODESET);
  ------------------
  |  |  288|      4|    if ((ctxt->value == NULL) || (ctxt->value->type != typeval))	\
  |  |  ------------------
  |  |  |  Branch (288:9): [True: 0, False: 4]
  |  |  |  Branch (288:34): [True: 0, False: 4]
  |  |  ------------------
  |  |  289|      4|        XP_ERROR0(XPATH_INVALID_TYPE)
  |  |  ------------------
  |  |  |  |  267|      0|    { xmlXPathErr(ctxt, X); return(0); }
  |  |  ------------------
  ------------------
11153|      4|    obj = valuePop(ctxt);
11154|       |    /*
11155|       |    * Setup namespaces.
11156|       |    */
11157|      4|    if (prefix != NULL) {
  ------------------
  |  Branch (11157:9): [True: 0, False: 4]
  ------------------
11158|      0|        URI = xmlXPathNsLookup(xpctxt, prefix);
11159|      0|        if (URI == NULL) {
  ------------------
  |  Branch (11159:13): [True: 0, False: 0]
  ------------------
11160|      0|	    xmlXPathReleaseObject(xpctxt, obj);
11161|      0|            XP_ERROR0(XPATH_UNDEF_PREFIX_ERROR);
  ------------------
  |  |  267|      0|    { xmlXPathErr(ctxt, X); return(0); }
  ------------------
11162|      0|	}
11163|      0|    }
11164|       |    /*
11165|       |    * Setup axis.
11166|       |    *
11167|       |    * MAYBE FUTURE TODO: merging optimizations:
11168|       |    * - If the nodes to be traversed wrt to the initial nodes and
11169|       |    *   the current axis cannot overlap, then we could avoid searching
11170|       |    *   for duplicates during the merge.
11171|       |    *   But the question is how/when to evaluate if they cannot overlap.
11172|       |    *   Example: if we know that for two initial nodes, the one is
11173|       |    *   not in the ancestor-or-self axis of the other, then we could safely
11174|       |    *   avoid a duplicate-aware merge, if the axis to be traversed is e.g.
11175|       |    *   the descendant-or-self axis.
11176|       |    */
11177|      4|    mergeAndClear = xmlXPathNodeSetMergeAndClear;
11178|      4|    switch (axis) {
  ------------------
  |  Branch (11178:13): [True: 0, False: 4]
  ------------------
11179|      0|        case AXIS_ANCESTOR:
  ------------------
  |  Branch (11179:9): [True: 0, False: 4]
  ------------------
11180|      0|            first = NULL;
11181|      0|            next = xmlXPathNextAncestor;
11182|      0|            break;
11183|      0|        case AXIS_ANCESTOR_OR_SELF:
  ------------------
  |  Branch (11183:9): [True: 0, False: 4]
  ------------------
11184|      0|            first = NULL;
11185|      0|            next = xmlXPathNextAncestorOrSelf;
11186|      0|            break;
11187|      0|        case AXIS_ATTRIBUTE:
  ------------------
  |  Branch (11187:9): [True: 0, False: 4]
  ------------------
11188|      0|            first = NULL;
11189|      0|	    last = NULL;
11190|      0|            next = xmlXPathNextAttribute;
11191|      0|	    mergeAndClear = xmlXPathNodeSetMergeAndClearNoDupls;
11192|      0|            break;
11193|      4|        case AXIS_CHILD:
  ------------------
  |  Branch (11193:9): [True: 4, False: 0]
  ------------------
11194|      4|	    last = NULL;
11195|      4|	    if (((test == NODE_TEST_NAME) || (test == NODE_TEST_ALL)) &&
  ------------------
  |  Branch (11195:11): [True: 2, False: 2]
  |  Branch (11195:39): [True: 0, False: 2]
  ------------------
11196|      4|		(type == NODE_TYPE_NODE))
  ------------------
  |  Branch (11196:3): [True: 2, False: 0]
  ------------------
11197|      2|	    {
11198|       |		/*
11199|       |		* Optimization if an element node type is 'element'.
11200|       |		*/
11201|      2|		next = xmlXPathNextChildElement;
11202|      2|	    } else
11203|      2|		next = xmlXPathNextChild;
11204|      4|	    mergeAndClear = xmlXPathNodeSetMergeAndClearNoDupls;
11205|      4|            break;
11206|      0|        case AXIS_DESCENDANT:
  ------------------
  |  Branch (11206:9): [True: 0, False: 4]
  ------------------
11207|      0|	    last = NULL;
11208|      0|            next = xmlXPathNextDescendant;
11209|      0|            break;
11210|      0|        case AXIS_DESCENDANT_OR_SELF:
  ------------------
  |  Branch (11210:9): [True: 0, False: 4]
  ------------------
11211|      0|	    last = NULL;
11212|      0|            next = xmlXPathNextDescendantOrSelf;
11213|      0|            break;
11214|      0|        case AXIS_FOLLOWING:
  ------------------
  |  Branch (11214:9): [True: 0, False: 4]
  ------------------
11215|      0|	    last = NULL;
11216|      0|            next = xmlXPathNextFollowing;
11217|      0|            break;
11218|      0|        case AXIS_FOLLOWING_SIBLING:
  ------------------
  |  Branch (11218:9): [True: 0, False: 4]
  ------------------
11219|      0|	    last = NULL;
11220|      0|            next = xmlXPathNextFollowingSibling;
11221|      0|            break;
11222|      0|        case AXIS_NAMESPACE:
  ------------------
  |  Branch (11222:9): [True: 0, False: 4]
  ------------------
11223|      0|            first = NULL;
11224|      0|	    last = NULL;
11225|      0|            next = (xmlXPathTraversalFunction) xmlXPathNextNamespace;
11226|      0|	    mergeAndClear = xmlXPathNodeSetMergeAndClearNoDupls;
11227|      0|            break;
11228|      0|        case AXIS_PARENT:
  ------------------
  |  Branch (11228:9): [True: 0, False: 4]
  ------------------
11229|      0|            first = NULL;
11230|      0|            next = xmlXPathNextParent;
11231|      0|            break;
11232|      0|        case AXIS_PRECEDING:
  ------------------
  |  Branch (11232:9): [True: 0, False: 4]
  ------------------
11233|      0|            first = NULL;
11234|      0|            next = xmlXPathNextPrecedingInternal;
11235|      0|            break;
11236|      0|        case AXIS_PRECEDING_SIBLING:
  ------------------
  |  Branch (11236:9): [True: 0, False: 4]
  ------------------
11237|      0|            first = NULL;
11238|      0|            next = xmlXPathNextPrecedingSibling;
11239|      0|            break;
11240|      0|        case AXIS_SELF:
  ------------------
  |  Branch (11240:9): [True: 0, False: 4]
  ------------------
11241|      0|            first = NULL;
11242|      0|	    last = NULL;
11243|      0|            next = xmlXPathNextSelf;
11244|      0|	    mergeAndClear = xmlXPathNodeSetMergeAndClearNoDupls;
11245|      0|            break;
11246|      4|    }
11247|       |
11248|      4|    if (next == NULL) {
  ------------------
  |  Branch (11248:9): [True: 0, False: 4]
  ------------------
11249|      0|	xmlXPathReleaseObject(xpctxt, obj);
11250|      0|        return(0);
11251|      0|    }
11252|      4|    contextSeq = obj->nodesetval;
11253|      4|    if ((contextSeq == NULL) || (contextSeq->nodeNr <= 0)) {
  ------------------
  |  Branch (11253:9): [True: 0, False: 4]
  |  Branch (11253:33): [True: 0, False: 4]
  ------------------
11254|      0|	xmlXPathReleaseObject(xpctxt, obj);
11255|      0|        valuePush(ctxt, xmlXPathCacheWrapNodeSet(xpctxt, NULL));
11256|      0|        return(0);
11257|      0|    }
11258|       |    /*
11259|       |    * Predicate optimization ---------------------------------------------
11260|       |    * If this step has a last predicate, which contains a position(),
11261|       |    * then we'll optimize (although not exactly "position()", but only
11262|       |    * the  short-hand form, i.e., "[n]".
11263|       |    *
11264|       |    * Example - expression "/foo[parent::bar][1]":
11265|       |    *
11266|       |    * COLLECT 'child' 'name' 'node' foo    -- op (we are here)
11267|       |    *   ROOT                               -- op->ch1
11268|       |    *   PREDICATE                          -- op->ch2 (predOp)
11269|       |    *     PREDICATE                          -- predOp->ch1 = [parent::bar]
11270|       |    *       SORT
11271|       |    *         COLLECT  'parent' 'name' 'node' bar
11272|       |    *           NODE
11273|       |    *     ELEM Object is a number : 1        -- predOp->ch2 = [1]
11274|       |    *
11275|       |    */
11276|      4|    maxPos = 0;
11277|      4|    predOp = NULL;
11278|      4|    hasPredicateRange = 0;
11279|      4|    hasAxisRange = 0;
11280|      4|    if (op->ch2 != -1) {
  ------------------
  |  Branch (11280:9): [True: 2, False: 2]
  ------------------
11281|       |	/*
11282|       |	* There's at least one predicate. 16 == XPATH_OP_PREDICATE
11283|       |	*/
11284|      2|	predOp = &ctxt->comp->steps[op->ch2];
11285|      2|	if (xmlXPathIsPositionalPredicate(ctxt, predOp, &maxPos)) {
  ------------------
  |  Branch (11285:6): [True: 2, False: 0]
  ------------------
11286|      2|	    if (predOp->ch1 != -1) {
  ------------------
  |  Branch (11286:10): [True: 0, False: 2]
  ------------------
11287|       |		/*
11288|       |		* Use the next inner predicate operator.
11289|       |		*/
11290|      0|		predOp = &ctxt->comp->steps[predOp->ch1];
11291|      0|		hasPredicateRange = 1;
11292|      2|	    } else {
11293|       |		/*
11294|       |		* There's no other predicate than the [n] predicate.
11295|       |		*/
11296|      2|		predOp = NULL;
11297|      2|		hasAxisRange = 1;
11298|      2|	    }
11299|      2|	}
11300|      2|    }
11301|      4|    breakOnFirstHit = ((toBool) && (predOp == NULL)) ? 1 : 0;
  ------------------
  |  Branch (11301:24): [True: 0, False: 4]
  |  Branch (11301:36): [True: 0, False: 0]
  ------------------
11302|       |    /*
11303|       |    * Axis traversal -----------------------------------------------------
11304|       |    */
11305|       |    /*
11306|       |     * 2.3 Node Tests
11307|       |     *  - For the attribute axis, the principal node type is attribute.
11308|       |     *  - For the namespace axis, the principal node type is namespace.
11309|       |     *  - For other axes, the principal node type is element.
11310|       |     *
11311|       |     * A node test * is true for any node of the
11312|       |     * principal node type. For example, child::* will
11313|       |     * select all element children of the context node
11314|       |     */
11315|      4|    oldContextNode = xpctxt->node;
11316|      4|    addNode = xmlXPathNodeSetAddUnique;
11317|      4|    outSeq = NULL;
11318|      4|    seq = NULL;
11319|      4|    contextNode = NULL;
11320|      4|    contextIdx = 0;
11321|       |
11322|       |
11323|      8|    while (((contextIdx < contextSeq->nodeNr) || (contextNode != NULL)) &&
  ------------------
  |  Branch (11323:13): [True: 4, False: 4]
  |  Branch (11323:50): [True: 0, False: 4]
  ------------------
11324|      8|           (ctxt->error == XPATH_EXPRESSION_OK)) {
  ------------------
  |  Branch (11324:12): [True: 4, False: 0]
  ------------------
11325|      4|	xpctxt->node = contextSeq->nodeTab[contextIdx++];
11326|       |
11327|      4|	if (seq == NULL) {
  ------------------
  |  Branch (11327:6): [True: 4, False: 0]
  ------------------
11328|      4|	    seq = xmlXPathNodeSetCreate(NULL);
11329|      4|	    if (seq == NULL) {
  ------------------
  |  Branch (11329:10): [True: 0, False: 4]
  ------------------
11330|       |                /* TODO: Propagate memory error. */
11331|      0|		total = 0;
11332|      0|		goto error;
11333|      0|	    }
11334|      4|	}
11335|       |	/*
11336|       |	* Traverse the axis and test the nodes.
11337|       |	*/
11338|      4|	pos = 0;
11339|      4|	cur = NULL;
11340|      4|	hasNsNodes = 0;
11341|      6|        do {
11342|      6|            if (OP_LIMIT_EXCEEDED(ctxt, 1))
  ------------------
  |  |  787|      6|    ((ctxt->context->opLimit != 0) && (xmlXPathCheckOpLimit(ctxt, n) < 0))
  |  |  ------------------
  |  |  |  Branch (787:6): [True: 0, False: 6]
  |  |  |  Branch (787:39): [True: 0, False: 0]
  |  |  ------------------
  ------------------
11343|      0|                goto error;
11344|       |
11345|      6|            cur = next(ctxt, cur);
11346|      6|            if (cur == NULL)
  ------------------
  |  Branch (11346:17): [True: 2, False: 4]
  ------------------
11347|      2|                break;
11348|       |
11349|       |	    /*
11350|       |	    * QUESTION TODO: What does the "first" and "last" stuff do?
11351|       |	    */
11352|      4|            if ((first != NULL) && (*first != NULL)) {
  ------------------
  |  Branch (11352:17): [True: 0, False: 4]
  |  Branch (11352:36): [True: 0, False: 0]
  ------------------
11353|      0|		if (*first == cur)
  ------------------
  |  Branch (11353:7): [True: 0, False: 0]
  ------------------
11354|      0|		    break;
11355|      0|		if (((total % 256) == 0) &&
  ------------------
  |  Branch (11355:7): [True: 0, False: 0]
  ------------------
11356|      0|#ifdef XP_OPTIMIZED_NON_ELEM_COMPARISON
11357|      0|		    (xmlXPathCmpNodesExt(*first, cur) >= 0))
  ------------------
  |  Branch (11357:7): [True: 0, False: 0]
  ------------------
11358|       |#else
11359|       |		    (xmlXPathCmpNodes(*first, cur) >= 0))
11360|       |#endif
11361|      0|		{
11362|      0|		    break;
11363|      0|		}
11364|      0|	    }
11365|      4|	    if ((last != NULL) && (*last != NULL)) {
  ------------------
  |  Branch (11365:10): [True: 0, False: 4]
  |  Branch (11365:28): [True: 0, False: 0]
  ------------------
11366|      0|		if (*last == cur)
  ------------------
  |  Branch (11366:7): [True: 0, False: 0]
  ------------------
11367|      0|		    break;
11368|      0|		if (((total % 256) == 0) &&
  ------------------
  |  Branch (11368:7): [True: 0, False: 0]
  ------------------
11369|      0|#ifdef XP_OPTIMIZED_NON_ELEM_COMPARISON
11370|      0|		    (xmlXPathCmpNodesExt(cur, *last) >= 0))
  ------------------
  |  Branch (11370:7): [True: 0, False: 0]
  ------------------
11371|       |#else
11372|       |		    (xmlXPathCmpNodes(cur, *last) >= 0))
11373|       |#endif
11374|      0|		{
11375|      0|		    break;
11376|      0|		}
11377|      0|	    }
11378|       |
11379|      4|            total++;
11380|       |
11381|      4|	    switch (test) {
  ------------------
  |  Branch (11381:14): [True: 0, False: 4]
  ------------------
11382|      0|                case NODE_TEST_NONE:
  ------------------
  |  Branch (11382:17): [True: 0, False: 4]
  ------------------
11383|      0|		    total = 0;
11384|      0|                    STRANGE
  ------------------
  |  | 1230|      0|    xmlGenericError(xmlGenericErrorContext,				\
  |  |  ------------------
  |  |  |  |  875|      0|  #define xmlGenericError XML_GLOBAL_MACRO(xmlGenericError)
  |  |  |  |  ------------------
  |  |  |  |  |  |  500|      0|  #define XML_GLOBAL_MACRO(name) (*__##name())
  |  |  |  |  ------------------
  |  |  ------------------
  |  |                   xmlGenericError(xmlGenericErrorContext,				\
  |  |  ------------------
  |  |  |  |  876|      0|  #define xmlGenericErrorContext XML_GLOBAL_MACRO(xmlGenericErrorContext)
  |  |  |  |  ------------------
  |  |  |  |  |  |  500|      0|  #define XML_GLOBAL_MACRO(name) (*__##name())
  |  |  |  |  ------------------
  |  |  ------------------
  |  | 1231|      0|	    "Internal error at %s:%d\n",				\
  |  | 1232|      0|            __FILE__, __LINE__);
  ------------------
11385|      0|		    goto error;
11386|      2|                case NODE_TEST_TYPE:
  ------------------
  |  Branch (11386:17): [True: 2, False: 2]
  ------------------
11387|      2|		    if (type == NODE_TYPE_NODE) {
  ------------------
  |  Branch (11387:11): [True: 0, False: 2]
  ------------------
11388|      0|			switch (cur->type) {
11389|      0|			    case XML_DOCUMENT_NODE:
  ------------------
  |  Branch (11389:8): [True: 0, False: 0]
  ------------------
11390|      0|			    case XML_HTML_DOCUMENT_NODE:
  ------------------
  |  Branch (11390:8): [True: 0, False: 0]
  ------------------
11391|      0|			    case XML_ELEMENT_NODE:
  ------------------
  |  Branch (11391:8): [True: 0, False: 0]
  ------------------
11392|      0|			    case XML_ATTRIBUTE_NODE:
  ------------------
  |  Branch (11392:8): [True: 0, False: 0]
  ------------------
11393|      0|			    case XML_PI_NODE:
  ------------------
  |  Branch (11393:8): [True: 0, False: 0]
  ------------------
11394|      0|			    case XML_COMMENT_NODE:
  ------------------
  |  Branch (11394:8): [True: 0, False: 0]
  ------------------
11395|      0|			    case XML_CDATA_SECTION_NODE:
  ------------------
  |  Branch (11395:8): [True: 0, False: 0]
  ------------------
11396|      0|			    case XML_TEXT_NODE:
  ------------------
  |  Branch (11396:8): [True: 0, False: 0]
  ------------------
11397|      0|				XP_TEST_HIT
  ------------------
  |  |11094|      0|    if (hasAxisRange != 0) { \
  |  |  ------------------
  |  |  |  Branch (11094:9): [True: 0, False: 0]
  |  |  ------------------
  |  |11095|      0|	if (++pos == maxPos) { \
  |  |  ------------------
  |  |  |  Branch (11095:6): [True: 0, False: 0]
  |  |  ------------------
  |  |11096|      0|	    if (addNode(seq, cur) < 0) \
  |  |  ------------------
  |  |  |  Branch (11096:10): [True: 0, False: 0]
  |  |  ------------------
  |  |11097|      0|	        ctxt->error = XPATH_MEMORY_ERROR; \
  |  |11098|      0|	    goto axis_range_end; } \
  |  |11099|      0|    } else { \
  |  |11100|      0|	if (addNode(seq, cur) < 0) \
  |  |  ------------------
  |  |  |  Branch (11100:6): [True: 0, False: 0]
  |  |  ------------------
  |  |11101|      0|	    ctxt->error = XPATH_MEMORY_ERROR; \
  |  |11102|      0|	if (breakOnFirstHit) goto first_hit; }
  |  |  ------------------
  |  |  |  Branch (11102:6): [True: 0, False: 0]
  |  |  ------------------
  ------------------
11398|      0|				break;
11399|      0|			    case XML_NAMESPACE_DECL: {
  ------------------
  |  Branch (11399:8): [True: 0, False: 0]
  ------------------
11400|      0|				if (axis == AXIS_NAMESPACE) {
  ------------------
  |  Branch (11400:9): [True: 0, False: 0]
  ------------------
11401|      0|				    XP_TEST_HIT_NS
  ------------------
  |  |11105|      0|    if (hasAxisRange != 0) { \
  |  |  ------------------
  |  |  |  Branch (11105:9): [True: 0, False: 0]
  |  |  ------------------
  |  |11106|      0|	if (++pos == maxPos) { \
  |  |  ------------------
  |  |  |  Branch (11106:6): [True: 0, False: 0]
  |  |  ------------------
  |  |11107|      0|	    hasNsNodes = 1; \
  |  |11108|      0|	    if (xmlXPathNodeSetAddNs(seq, xpctxt->node, (xmlNsPtr) cur) < 0) \
  |  |  ------------------
  |  |  |  Branch (11108:10): [True: 0, False: 0]
  |  |  ------------------
  |  |11109|      0|	        ctxt->error = XPATH_MEMORY_ERROR; \
  |  |11110|      0|	goto axis_range_end; } \
  |  |11111|      0|    } else { \
  |  |11112|      0|	hasNsNodes = 1; \
  |  |11113|      0|	if (xmlXPathNodeSetAddNs(seq, xpctxt->node, (xmlNsPtr) cur) < 0) \
  |  |  ------------------
  |  |  |  Branch (11113:6): [True: 0, False: 0]
  |  |  ------------------
  |  |11114|      0|	    ctxt->error = XPATH_MEMORY_ERROR; \
  |  |11115|      0|	if (breakOnFirstHit) goto first_hit; }
  |  |  ------------------
  |  |  |  Branch (11115:6): [True: 0, False: 0]
  |  |  ------------------
  ------------------
11402|      0|				} else {
11403|      0|	                            hasNsNodes = 1;
11404|      0|				    XP_TEST_HIT
  ------------------
  |  |11094|      0|    if (hasAxisRange != 0) { \
  |  |  ------------------
  |  |  |  Branch (11094:9): [True: 0, False: 0]
  |  |  ------------------
  |  |11095|      0|	if (++pos == maxPos) { \
  |  |  ------------------
  |  |  |  Branch (11095:6): [True: 0, False: 0]
  |  |  ------------------
  |  |11096|      0|	    if (addNode(seq, cur) < 0) \
  |  |  ------------------
  |  |  |  Branch (11096:10): [True: 0, False: 0]
  |  |  ------------------
  |  |11097|      0|	        ctxt->error = XPATH_MEMORY_ERROR; \
  |  |11098|      0|	    goto axis_range_end; } \
  |  |11099|      0|    } else { \
  |  |11100|      0|	if (addNode(seq, cur) < 0) \
  |  |  ------------------
  |  |  |  Branch (11100:6): [True: 0, False: 0]
  |  |  ------------------
  |  |11101|      0|	    ctxt->error = XPATH_MEMORY_ERROR; \
  |  |11102|      0|	if (breakOnFirstHit) goto first_hit; }
  |  |  ------------------
  |  |  |  Branch (11102:6): [True: 0, False: 0]
  |  |  ------------------
  ------------------
11405|      0|				}
11406|      0|				break;
11407|      0|                            }
11408|      0|			    default:
  ------------------
  |  Branch (11408:8): [True: 0, False: 0]
  ------------------
11409|      0|				break;
11410|      0|			}
11411|      2|		    } else if (cur->type == (xmlElementType) type) {
  ------------------
  |  Branch (11411:18): [True: 2, False: 0]
  ------------------
11412|      2|			if (cur->type == XML_NAMESPACE_DECL)
  ------------------
  |  Branch (11412:8): [True: 0, False: 2]
  ------------------
11413|      0|			    XP_TEST_HIT_NS
  ------------------
  |  |11105|      0|    if (hasAxisRange != 0) { \
  |  |  ------------------
  |  |  |  Branch (11105:9): [True: 0, False: 0]
  |  |  ------------------
  |  |11106|      0|	if (++pos == maxPos) { \
  |  |  ------------------
  |  |  |  Branch (11106:6): [True: 0, False: 0]
  |  |  ------------------
  |  |11107|      0|	    hasNsNodes = 1; \
  |  |11108|      0|	    if (xmlXPathNodeSetAddNs(seq, xpctxt->node, (xmlNsPtr) cur) < 0) \
  |  |  ------------------
  |  |  |  Branch (11108:10): [True: 0, False: 0]
  |  |  ------------------
  |  |11109|      0|	        ctxt->error = XPATH_MEMORY_ERROR; \
  |  |11110|      0|	goto axis_range_end; } \
  |  |11111|      0|    } else { \
  |  |11112|      0|	hasNsNodes = 1; \
  |  |11113|      0|	if (xmlXPathNodeSetAddNs(seq, xpctxt->node, (xmlNsPtr) cur) < 0) \
  |  |  ------------------
  |  |  |  Branch (11113:6): [True: 0, False: 0]
  |  |  ------------------
  |  |11114|      0|	    ctxt->error = XPATH_MEMORY_ERROR; \
  |  |11115|      0|	if (breakOnFirstHit) goto first_hit; }
  |  |  ------------------
  |  |  |  Branch (11115:6): [True: 0, False: 0]
  |  |  ------------------
  ------------------
11414|      2|			else
11415|      2|			    XP_TEST_HIT
  ------------------
  |  |11094|      2|    if (hasAxisRange != 0) { \
  |  |  ------------------
  |  |  |  Branch (11094:9): [True: 2, False: 0]
  |  |  ------------------
  |  |11095|      2|	if (++pos == maxPos) { \
  |  |  ------------------
  |  |  |  Branch (11095:6): [True: 2, False: 0]
  |  |  ------------------
  |  |11096|      2|	    if (addNode(seq, cur) < 0) \
  |  |  ------------------
  |  |  |  Branch (11096:10): [True: 0, False: 2]
  |  |  ------------------
  |  |11097|      2|	        ctxt->error = XPATH_MEMORY_ERROR; \
  |  |11098|      2|	    goto axis_range_end; } \
  |  |11099|      2|    } else { \
  |  |11100|      0|	if (addNode(seq, cur) < 0) \
  |  |  ------------------
  |  |  |  Branch (11100:6): [True: 0, False: 0]
  |  |  ------------------
  |  |11101|      0|	    ctxt->error = XPATH_MEMORY_ERROR; \
  |  |11102|      0|	if (breakOnFirstHit) goto first_hit; }
  |  |  ------------------
  |  |  |  Branch (11102:6): [True: 0, False: 0]
  |  |  ------------------
  ------------------
11416|      2|		    } else if ((type == NODE_TYPE_TEXT) &&
  ------------------
  |  Branch (11416:18): [True: 0, False: 0]
  ------------------
11417|      0|			 (cur->type == XML_CDATA_SECTION_NODE))
  ------------------
  |  Branch (11417:5): [True: 0, False: 0]
  ------------------
11418|      0|		    {
11419|      0|			XP_TEST_HIT
  ------------------
  |  |11094|      0|    if (hasAxisRange != 0) { \
  |  |  ------------------
  |  |  |  Branch (11094:9): [True: 0, False: 0]
  |  |  ------------------
  |  |11095|      0|	if (++pos == maxPos) { \
  |  |  ------------------
  |  |  |  Branch (11095:6): [True: 0, False: 0]
  |  |  ------------------
  |  |11096|      0|	    if (addNode(seq, cur) < 0) \
  |  |  ------------------
  |  |  |  Branch (11096:10): [True: 0, False: 0]
  |  |  ------------------
  |  |11097|      0|	        ctxt->error = XPATH_MEMORY_ERROR; \
  |  |11098|      0|	    goto axis_range_end; } \
  |  |11099|      0|    } else { \
  |  |11100|      0|	if (addNode(seq, cur) < 0) \
  |  |  ------------------
  |  |  |  Branch (11100:6): [True: 0, False: 0]
  |  |  ------------------
  |  |11101|      0|	    ctxt->error = XPATH_MEMORY_ERROR; \
  |  |11102|      0|	if (breakOnFirstHit) goto first_hit; }
  |  |  ------------------
  |  |  |  Branch (11102:6): [True: 0, False: 0]
  |  |  ------------------
  ------------------
11420|      0|		    }
11421|      0|		    break;
11422|      0|                case NODE_TEST_PI:
  ------------------
  |  Branch (11422:17): [True: 0, False: 4]
  ------------------
11423|      0|                    if ((cur->type == XML_PI_NODE) &&
  ------------------
  |  Branch (11423:25): [True: 0, False: 0]
  ------------------
11424|      0|                        ((name == NULL) || xmlStrEqual(name, cur->name)))
  ------------------
  |  Branch (11424:26): [True: 0, False: 0]
  |  Branch (11424:44): [True: 0, False: 0]
  ------------------
11425|      0|		    {
11426|      0|			XP_TEST_HIT
  ------------------
  |  |11094|      0|    if (hasAxisRange != 0) { \
  |  |  ------------------
  |  |  |  Branch (11094:9): [True: 0, False: 0]
  |  |  ------------------
  |  |11095|      0|	if (++pos == maxPos) { \
  |  |  ------------------
  |  |  |  Branch (11095:6): [True: 0, False: 0]
  |  |  ------------------
  |  |11096|      0|	    if (addNode(seq, cur) < 0) \
  |  |  ------------------
  |  |  |  Branch (11096:10): [True: 0, False: 0]
  |  |  ------------------
  |  |11097|      0|	        ctxt->error = XPATH_MEMORY_ERROR; \
  |  |11098|      0|	    goto axis_range_end; } \
  |  |11099|      0|    } else { \
  |  |11100|      0|	if (addNode(seq, cur) < 0) \
  |  |  ------------------
  |  |  |  Branch (11100:6): [True: 0, False: 0]
  |  |  ------------------
  |  |11101|      0|	    ctxt->error = XPATH_MEMORY_ERROR; \
  |  |11102|      0|	if (breakOnFirstHit) goto first_hit; }
  |  |  ------------------
  |  |  |  Branch (11102:6): [True: 0, False: 0]
  |  |  ------------------
  ------------------
11427|      0|                    }
11428|      0|                    break;
11429|      0|                case NODE_TEST_ALL:
  ------------------
  |  Branch (11429:17): [True: 0, False: 4]
  ------------------
11430|      0|                    if (axis == AXIS_ATTRIBUTE) {
  ------------------
  |  Branch (11430:25): [True: 0, False: 0]
  ------------------
11431|      0|                        if (cur->type == XML_ATTRIBUTE_NODE)
  ------------------
  |  Branch (11431:29): [True: 0, False: 0]
  ------------------
11432|      0|			{
11433|      0|                            if (prefix == NULL)
  ------------------
  |  Branch (11433:33): [True: 0, False: 0]
  ------------------
11434|      0|			    {
11435|      0|				XP_TEST_HIT
  ------------------
  |  |11094|      0|    if (hasAxisRange != 0) { \
  |  |  ------------------
  |  |  |  Branch (11094:9): [True: 0, False: 0]
  |  |  ------------------
  |  |11095|      0|	if (++pos == maxPos) { \
  |  |  ------------------
  |  |  |  Branch (11095:6): [True: 0, False: 0]
  |  |  ------------------
  |  |11096|      0|	    if (addNode(seq, cur) < 0) \
  |  |  ------------------
  |  |  |  Branch (11096:10): [True: 0, False: 0]
  |  |  ------------------
  |  |11097|      0|	        ctxt->error = XPATH_MEMORY_ERROR; \
  |  |11098|      0|	    goto axis_range_end; } \
  |  |11099|      0|    } else { \
  |  |11100|      0|	if (addNode(seq, cur) < 0) \
  |  |  ------------------
  |  |  |  Branch (11100:6): [True: 0, False: 0]
  |  |  ------------------
  |  |11101|      0|	    ctxt->error = XPATH_MEMORY_ERROR; \
  |  |11102|      0|	if (breakOnFirstHit) goto first_hit; }
  |  |  ------------------
  |  |  |  Branch (11102:6): [True: 0, False: 0]
  |  |  ------------------
  ------------------
11436|      0|                            } else if ((cur->ns != NULL) &&
  ------------------
  |  Branch (11436:40): [True: 0, False: 0]
  ------------------
11437|      0|				(xmlStrEqual(URI, cur->ns->href)))
  ------------------
  |  Branch (11437:5): [True: 0, False: 0]
  ------------------
11438|      0|			    {
11439|      0|				XP_TEST_HIT
  ------------------
  |  |11094|      0|    if (hasAxisRange != 0) { \
  |  |  ------------------
  |  |  |  Branch (11094:9): [True: 0, False: 0]
  |  |  ------------------
  |  |11095|      0|	if (++pos == maxPos) { \
  |  |  ------------------
  |  |  |  Branch (11095:6): [True: 0, False: 0]
  |  |  ------------------
  |  |11096|      0|	    if (addNode(seq, cur) < 0) \
  |  |  ------------------
  |  |  |  Branch (11096:10): [True: 0, False: 0]
  |  |  ------------------
  |  |11097|      0|	        ctxt->error = XPATH_MEMORY_ERROR; \
  |  |11098|      0|	    goto axis_range_end; } \
  |  |11099|      0|    } else { \
  |  |11100|      0|	if (addNode(seq, cur) < 0) \
  |  |  ------------------
  |  |  |  Branch (11100:6): [True: 0, False: 0]
  |  |  ------------------
  |  |11101|      0|	    ctxt->error = XPATH_MEMORY_ERROR; \
  |  |11102|      0|	if (breakOnFirstHit) goto first_hit; }
  |  |  ------------------
  |  |  |  Branch (11102:6): [True: 0, False: 0]
  |  |  ------------------
  ------------------
11440|      0|                            }
11441|      0|                        }
11442|      0|                    } else if (axis == AXIS_NAMESPACE) {
  ------------------
  |  Branch (11442:32): [True: 0, False: 0]
  ------------------
11443|      0|                        if (cur->type == XML_NAMESPACE_DECL)
  ------------------
  |  Branch (11443:29): [True: 0, False: 0]
  ------------------
11444|      0|			{
11445|      0|			    XP_TEST_HIT_NS
  ------------------
  |  |11105|      0|    if (hasAxisRange != 0) { \
  |  |  ------------------
  |  |  |  Branch (11105:9): [True: 0, False: 0]
  |  |  ------------------
  |  |11106|      0|	if (++pos == maxPos) { \
  |  |  ------------------
  |  |  |  Branch (11106:6): [True: 0, False: 0]
  |  |  ------------------
  |  |11107|      0|	    hasNsNodes = 1; \
  |  |11108|      0|	    if (xmlXPathNodeSetAddNs(seq, xpctxt->node, (xmlNsPtr) cur) < 0) \
  |  |  ------------------
  |  |  |  Branch (11108:10): [True: 0, False: 0]
  |  |  ------------------
  |  |11109|      0|	        ctxt->error = XPATH_MEMORY_ERROR; \
  |  |11110|      0|	goto axis_range_end; } \
  |  |11111|      0|    } else { \
  |  |11112|      0|	hasNsNodes = 1; \
  |  |11113|      0|	if (xmlXPathNodeSetAddNs(seq, xpctxt->node, (xmlNsPtr) cur) < 0) \
  |  |  ------------------
  |  |  |  Branch (11113:6): [True: 0, False: 0]
  |  |  ------------------
  |  |11114|      0|	    ctxt->error = XPATH_MEMORY_ERROR; \
  |  |11115|      0|	if (breakOnFirstHit) goto first_hit; }
  |  |  ------------------
  |  |  |  Branch (11115:6): [True: 0, False: 0]
  |  |  ------------------
  ------------------
11446|      0|                        }
11447|      0|                    } else {
11448|      0|                        if (cur->type == XML_ELEMENT_NODE) {
  ------------------
  |  Branch (11448:29): [True: 0, False: 0]
  ------------------
11449|      0|                            if (prefix == NULL)
  ------------------
  |  Branch (11449:33): [True: 0, False: 0]
  ------------------
11450|      0|			    {
11451|      0|				XP_TEST_HIT
  ------------------
  |  |11094|      0|    if (hasAxisRange != 0) { \
  |  |  ------------------
  |  |  |  Branch (11094:9): [True: 0, False: 0]
  |  |  ------------------
  |  |11095|      0|	if (++pos == maxPos) { \
  |  |  ------------------
  |  |  |  Branch (11095:6): [True: 0, False: 0]
  |  |  ------------------
  |  |11096|      0|	    if (addNode(seq, cur) < 0) \
  |  |  ------------------
  |  |  |  Branch (11096:10): [True: 0, False: 0]
  |  |  ------------------
  |  |11097|      0|	        ctxt->error = XPATH_MEMORY_ERROR; \
  |  |11098|      0|	    goto axis_range_end; } \
  |  |11099|      0|    } else { \
  |  |11100|      0|	if (addNode(seq, cur) < 0) \
  |  |  ------------------
  |  |  |  Branch (11100:6): [True: 0, False: 0]
  |  |  ------------------
  |  |11101|      0|	    ctxt->error = XPATH_MEMORY_ERROR; \
  |  |11102|      0|	if (breakOnFirstHit) goto first_hit; }
  |  |  ------------------
  |  |  |  Branch (11102:6): [True: 0, False: 0]
  |  |  ------------------
  ------------------
11452|       |
11453|      0|                            } else if ((cur->ns != NULL) &&
  ------------------
  |  Branch (11453:40): [True: 0, False: 0]
  ------------------
11454|      0|				(xmlStrEqual(URI, cur->ns->href)))
  ------------------
  |  Branch (11454:5): [True: 0, False: 0]
  ------------------
11455|      0|			    {
11456|      0|				XP_TEST_HIT
  ------------------
  |  |11094|      0|    if (hasAxisRange != 0) { \
  |  |  ------------------
  |  |  |  Branch (11094:9): [True: 0, False: 0]
  |  |  ------------------
  |  |11095|      0|	if (++pos == maxPos) { \
  |  |  ------------------
  |  |  |  Branch (11095:6): [True: 0, False: 0]
  |  |  ------------------
  |  |11096|      0|	    if (addNode(seq, cur) < 0) \
  |  |  ------------------
  |  |  |  Branch (11096:10): [True: 0, False: 0]
  |  |  ------------------
  |  |11097|      0|	        ctxt->error = XPATH_MEMORY_ERROR; \
  |  |11098|      0|	    goto axis_range_end; } \
  |  |11099|      0|    } else { \
  |  |11100|      0|	if (addNode(seq, cur) < 0) \
  |  |  ------------------
  |  |  |  Branch (11100:6): [True: 0, False: 0]
  |  |  ------------------
  |  |11101|      0|	    ctxt->error = XPATH_MEMORY_ERROR; \
  |  |11102|      0|	if (breakOnFirstHit) goto first_hit; }
  |  |  ------------------
  |  |  |  Branch (11102:6): [True: 0, False: 0]
  |  |  ------------------
  ------------------
11457|      0|                            }
11458|      0|                        }
11459|      0|                    }
11460|      0|                    break;
11461|      0|                case NODE_TEST_NS:{
  ------------------
  |  Branch (11461:17): [True: 0, False: 4]
  ------------------
11462|      0|                        TODO;
  ------------------
  |  |   59|      0|    xmlGenericError(xmlGenericErrorContext,				\
  |  |  ------------------
  |  |  |  |  875|      0|  #define xmlGenericError XML_GLOBAL_MACRO(xmlGenericError)
  |  |  |  |  ------------------
  |  |  |  |  |  |  500|      0|  #define XML_GLOBAL_MACRO(name) (*__##name())
  |  |  |  |  ------------------
  |  |  ------------------
  |  |                   xmlGenericError(xmlGenericErrorContext,				\
  |  |  ------------------
  |  |  |  |  876|      0|  #define xmlGenericErrorContext XML_GLOBAL_MACRO(xmlGenericErrorContext)
  |  |  |  |  ------------------
  |  |  |  |  |  |  500|      0|  #define XML_GLOBAL_MACRO(name) (*__##name())
  |  |  |  |  ------------------
  |  |  ------------------
  |  |   60|      0|	    "Unimplemented block at %s:%d\n",				\
  |  |   61|      0|            __FILE__, __LINE__);
  ------------------
11463|      0|                        break;
11464|      0|                    }
11465|      2|                case NODE_TEST_NAME:
  ------------------
  |  Branch (11465:17): [True: 2, False: 2]
  ------------------
11466|      2|                    if (axis == AXIS_ATTRIBUTE) {
  ------------------
  |  Branch (11466:25): [True: 0, False: 2]
  ------------------
11467|      0|                        if (cur->type != XML_ATTRIBUTE_NODE)
  ------------------
  |  Branch (11467:29): [True: 0, False: 0]
  ------------------
11468|      0|			    break;
11469|      2|		    } else if (axis == AXIS_NAMESPACE) {
  ------------------
  |  Branch (11469:18): [True: 0, False: 2]
  ------------------
11470|      0|                        if (cur->type != XML_NAMESPACE_DECL)
  ------------------
  |  Branch (11470:29): [True: 0, False: 0]
  ------------------
11471|      0|			    break;
11472|      2|		    } else {
11473|      2|		        if (cur->type != XML_ELEMENT_NODE)
  ------------------
  |  Branch (11473:15): [True: 0, False: 2]
  ------------------
11474|      0|			    break;
11475|      2|		    }
11476|      2|                    switch (cur->type) {
11477|      2|                        case XML_ELEMENT_NODE:
  ------------------
  |  Branch (11477:25): [True: 2, False: 0]
  ------------------
11478|      2|                            if (xmlStrEqual(name, cur->name)) {
  ------------------
  |  Branch (11478:33): [True: 2, False: 0]
  ------------------
11479|      2|                                if (prefix == NULL) {
  ------------------
  |  Branch (11479:37): [True: 2, False: 0]
  ------------------
11480|      2|                                    if (cur->ns == NULL)
  ------------------
  |  Branch (11480:41): [True: 2, False: 0]
  ------------------
11481|      2|				    {
11482|      2|					XP_TEST_HIT
  ------------------
  |  |11094|      2|    if (hasAxisRange != 0) { \
  |  |  ------------------
  |  |  |  Branch (11094:9): [True: 0, False: 2]
  |  |  ------------------
  |  |11095|      0|	if (++pos == maxPos) { \
  |  |  ------------------
  |  |  |  Branch (11095:6): [True: 0, False: 0]
  |  |  ------------------
  |  |11096|      0|	    if (addNode(seq, cur) < 0) \
  |  |  ------------------
  |  |  |  Branch (11096:10): [True: 0, False: 0]
  |  |  ------------------
  |  |11097|      0|	        ctxt->error = XPATH_MEMORY_ERROR; \
  |  |11098|      0|	    goto axis_range_end; } \
  |  |11099|      2|    } else { \
  |  |11100|      2|	if (addNode(seq, cur) < 0) \
  |  |  ------------------
  |  |  |  Branch (11100:6): [True: 0, False: 2]
  |  |  ------------------
  |  |11101|      2|	    ctxt->error = XPATH_MEMORY_ERROR; \
  |  |11102|      2|	if (breakOnFirstHit) goto first_hit; }
  |  |  ------------------
  |  |  |  Branch (11102:6): [True: 0, False: 2]
  |  |  ------------------
  ------------------
11483|      2|                                    }
11484|      2|                                } else {
11485|      0|                                    if ((cur->ns != NULL) &&
  ------------------
  |  Branch (11485:41): [True: 0, False: 0]
  ------------------
11486|      0|                                        (xmlStrEqual(URI, cur->ns->href)))
  ------------------
  |  Branch (11486:41): [True: 0, False: 0]
  ------------------
11487|      0|				    {
11488|      0|					XP_TEST_HIT
  ------------------
  |  |11094|      0|    if (hasAxisRange != 0) { \
  |  |  ------------------
  |  |  |  Branch (11094:9): [True: 0, False: 0]
  |  |  ------------------
  |  |11095|      0|	if (++pos == maxPos) { \
  |  |  ------------------
  |  |  |  Branch (11095:6): [True: 0, False: 0]
  |  |  ------------------
  |  |11096|      0|	    if (addNode(seq, cur) < 0) \
  |  |  ------------------
  |  |  |  Branch (11096:10): [True: 0, False: 0]
  |  |  ------------------
  |  |11097|      0|	        ctxt->error = XPATH_MEMORY_ERROR; \
  |  |11098|      0|	    goto axis_range_end; } \
  |  |11099|      0|    } else { \
  |  |11100|      0|	if (addNode(seq, cur) < 0) \
  |  |  ------------------
  |  |  |  Branch (11100:6): [True: 0, False: 0]
  |  |  ------------------
  |  |11101|      0|	    ctxt->error = XPATH_MEMORY_ERROR; \
  |  |11102|      0|	if (breakOnFirstHit) goto first_hit; }
  |  |  ------------------
  |  |  |  Branch (11102:6): [True: 0, False: 0]
  |  |  ------------------
  ------------------
11489|      0|                                    }
11490|      0|                                }
11491|      2|                            }
11492|      2|                            break;
11493|      2|                        case XML_ATTRIBUTE_NODE:{
  ------------------
  |  Branch (11493:25): [True: 0, False: 2]
  ------------------
11494|      0|                                xmlAttrPtr attr = (xmlAttrPtr) cur;
11495|       |
11496|      0|                                if (xmlStrEqual(name, attr->name)) {
  ------------------
  |  Branch (11496:37): [True: 0, False: 0]
  ------------------
11497|      0|                                    if (prefix == NULL) {
  ------------------
  |  Branch (11497:41): [True: 0, False: 0]
  ------------------
11498|      0|                                        if ((attr->ns == NULL) ||
  ------------------
  |  Branch (11498:45): [True: 0, False: 0]
  ------------------
11499|      0|                                            (attr->ns->prefix == NULL))
  ------------------
  |  Branch (11499:45): [True: 0, False: 0]
  ------------------
11500|      0|					{
11501|      0|					    XP_TEST_HIT
  ------------------
  |  |11094|      0|    if (hasAxisRange != 0) { \
  |  |  ------------------
  |  |  |  Branch (11094:9): [True: 0, False: 0]
  |  |  ------------------
  |  |11095|      0|	if (++pos == maxPos) { \
  |  |  ------------------
  |  |  |  Branch (11095:6): [True: 0, False: 0]
  |  |  ------------------
  |  |11096|      0|	    if (addNode(seq, cur) < 0) \
  |  |  ------------------
  |  |  |  Branch (11096:10): [True: 0, False: 0]
  |  |  ------------------
  |  |11097|      0|	        ctxt->error = XPATH_MEMORY_ERROR; \
  |  |11098|      0|	    goto axis_range_end; } \
  |  |11099|      0|    } else { \
  |  |11100|      0|	if (addNode(seq, cur) < 0) \
  |  |  ------------------
  |  |  |  Branch (11100:6): [True: 0, False: 0]
  |  |  ------------------
  |  |11101|      0|	    ctxt->error = XPATH_MEMORY_ERROR; \
  |  |11102|      0|	if (breakOnFirstHit) goto first_hit; }
  |  |  ------------------
  |  |  |  Branch (11102:6): [True: 0, False: 0]
  |  |  ------------------
  ------------------
11502|      0|                                        }
11503|      0|                                    } else {
11504|      0|                                        if ((attr->ns != NULL) &&
  ------------------
  |  Branch (11504:45): [True: 0, False: 0]
  ------------------
11505|      0|                                            (xmlStrEqual(URI,
  ------------------
  |  Branch (11505:45): [True: 0, False: 0]
  ------------------
11506|      0|					      attr->ns->href)))
11507|      0|					{
11508|      0|					    XP_TEST_HIT
  ------------------
  |  |11094|      0|    if (hasAxisRange != 0) { \
  |  |  ------------------
  |  |  |  Branch (11094:9): [True: 0, False: 0]
  |  |  ------------------
  |  |11095|      0|	if (++pos == maxPos) { \
  |  |  ------------------
  |  |  |  Branch (11095:6): [True: 0, False: 0]
  |  |  ------------------
  |  |11096|      0|	    if (addNode(seq, cur) < 0) \
  |  |  ------------------
  |  |  |  Branch (11096:10): [True: 0, False: 0]
  |  |  ------------------
  |  |11097|      0|	        ctxt->error = XPATH_MEMORY_ERROR; \
  |  |11098|      0|	    goto axis_range_end; } \
  |  |11099|      0|    } else { \
  |  |11100|      0|	if (addNode(seq, cur) < 0) \
  |  |  ------------------
  |  |  |  Branch (11100:6): [True: 0, False: 0]
  |  |  ------------------
  |  |11101|      0|	    ctxt->error = XPATH_MEMORY_ERROR; \
  |  |11102|      0|	if (breakOnFirstHit) goto first_hit; }
  |  |  ------------------
  |  |  |  Branch (11102:6): [True: 0, False: 0]
  |  |  ------------------
  ------------------
11509|      0|                                        }
11510|      0|                                    }
11511|      0|                                }
11512|      0|                                break;
11513|      0|                            }
11514|      0|                        case XML_NAMESPACE_DECL:
  ------------------
  |  Branch (11514:25): [True: 0, False: 2]
  ------------------
11515|      0|                            if (cur->type == XML_NAMESPACE_DECL) {
  ------------------
  |  Branch (11515:33): [True: 0, False: 0]
  ------------------
11516|      0|                                xmlNsPtr ns = (xmlNsPtr) cur;
11517|       |
11518|      0|                                if ((ns->prefix != NULL) && (name != NULL)
  ------------------
  |  Branch (11518:37): [True: 0, False: 0]
  |  Branch (11518:61): [True: 0, False: 0]
  ------------------
11519|      0|                                    && (xmlStrEqual(ns->prefix, name)))
  ------------------
  |  Branch (11519:40): [True: 0, False: 0]
  ------------------
11520|      0|				{
11521|      0|				    XP_TEST_HIT_NS
  ------------------
  |  |11105|      0|    if (hasAxisRange != 0) { \
  |  |  ------------------
  |  |  |  Branch (11105:9): [True: 0, False: 0]
  |  |  ------------------
  |  |11106|      0|	if (++pos == maxPos) { \
  |  |  ------------------
  |  |  |  Branch (11106:6): [True: 0, False: 0]
  |  |  ------------------
  |  |11107|      0|	    hasNsNodes = 1; \
  |  |11108|      0|	    if (xmlXPathNodeSetAddNs(seq, xpctxt->node, (xmlNsPtr) cur) < 0) \
  |  |  ------------------
  |  |  |  Branch (11108:10): [True: 0, False: 0]
  |  |  ------------------
  |  |11109|      0|	        ctxt->error = XPATH_MEMORY_ERROR; \
  |  |11110|      0|	goto axis_range_end; } \
  |  |11111|      0|    } else { \
  |  |11112|      0|	hasNsNodes = 1; \
  |  |11113|      0|	if (xmlXPathNodeSetAddNs(seq, xpctxt->node, (xmlNsPtr) cur) < 0) \
  |  |  ------------------
  |  |  |  Branch (11113:6): [True: 0, False: 0]
  |  |  ------------------
  |  |11114|      0|	    ctxt->error = XPATH_MEMORY_ERROR; \
  |  |11115|      0|	if (breakOnFirstHit) goto first_hit; }
  |  |  ------------------
  |  |  |  Branch (11115:6): [True: 0, False: 0]
  |  |  ------------------
  ------------------
11522|      0|                                }
11523|      0|                            }
11524|      0|                            break;
11525|      0|                        default:
  ------------------
  |  Branch (11525:25): [True: 0, False: 2]
  ------------------
11526|      0|                            break;
11527|      2|                    }
11528|      2|                    break;
11529|      4|	    } /* switch(test) */
11530|      4|        } while ((cur != NULL) && (ctxt->error == XPATH_EXPRESSION_OK));
  ------------------
  |  Branch (11530:18): [True: 2, False: 0]
  |  Branch (11530:35): [True: 2, False: 0]
  ------------------
11531|       |
11532|      2|	goto apply_predicates;
11533|       |
11534|      2|axis_range_end: /* ----------------------------------------------------- */
11535|       |	/*
11536|       |	* We have a "/foo[n]", and position() = n was reached.
11537|       |	* Note that we can have as well "/foo/::parent::foo[1]", so
11538|       |	* a duplicate-aware merge is still needed.
11539|       |	* Merge with the result.
11540|       |	*/
11541|      2|	if (outSeq == NULL) {
  ------------------
  |  Branch (11541:6): [True: 2, False: 0]
  ------------------
11542|      2|	    outSeq = seq;
11543|      2|	    seq = NULL;
11544|      2|	} else
11545|       |            /* TODO: Check memory error. */
11546|      0|	    outSeq = mergeAndClear(outSeq, seq);
11547|       |	/*
11548|       |	* Break if only a true/false result was requested.
11549|       |	*/
11550|      2|	if (toBool)
  ------------------
  |  Branch (11550:6): [True: 0, False: 2]
  ------------------
11551|      0|	    break;
11552|      2|	continue;
11553|       |
11554|      2|first_hit: /* ---------------------------------------------------------- */
11555|       |	/*
11556|       |	* Break if only a true/false result was requested and
11557|       |	* no predicates existed and a node test succeeded.
11558|       |	*/
11559|      0|	if (outSeq == NULL) {
  ------------------
  |  Branch (11559:6): [True: 0, False: 0]
  ------------------
11560|      0|	    outSeq = seq;
11561|      0|	    seq = NULL;
11562|      0|	} else
11563|       |            /* TODO: Check memory error. */
11564|      0|	    outSeq = mergeAndClear(outSeq, seq);
11565|      0|	break;
11566|       |
11567|      2|apply_predicates: /* --------------------------------------------------- */
11568|      2|        if (ctxt->error != XPATH_EXPRESSION_OK)
  ------------------
  |  Branch (11568:13): [True: 0, False: 2]
  ------------------
11569|      0|	    goto error;
11570|       |
11571|       |        /*
11572|       |	* Apply predicates.
11573|       |	*/
11574|      2|        if ((predOp != NULL) && (seq->nodeNr > 0)) {
  ------------------
  |  Branch (11574:13): [True: 0, False: 2]
  |  Branch (11574:33): [True: 0, False: 0]
  ------------------
11575|       |	    /*
11576|       |	    * E.g. when we have a "/foo[some expression][n]".
11577|       |	    */
11578|       |	    /*
11579|       |	    * QUESTION TODO: The old predicate evaluation took into
11580|       |	    *  account location-sets.
11581|       |	    *  (E.g. ctxt->value->type == XPATH_LOCATIONSET)
11582|       |	    *  Do we expect such a set here?
11583|       |	    *  All what I learned now from the evaluation semantics
11584|       |	    *  does not indicate that a location-set will be processed
11585|       |	    *  here, so this looks OK.
11586|       |	    */
11587|       |	    /*
11588|       |	    * Iterate over all predicates, starting with the outermost
11589|       |	    * predicate.
11590|       |	    * TODO: Problem: we cannot execute the inner predicates first
11591|       |	    *  since we cannot go back *up* the operator tree!
11592|       |	    *  Options we have:
11593|       |	    *  1) Use of recursive functions (like is it currently done
11594|       |	    *     via xmlXPathCompOpEval())
11595|       |	    *  2) Add a predicate evaluation information stack to the
11596|       |	    *     context struct
11597|       |	    *  3) Change the way the operators are linked; we need a
11598|       |	    *     "parent" field on xmlXPathStepOp
11599|       |	    *
11600|       |	    * For the moment, I'll try to solve this with a recursive
11601|       |	    * function: xmlXPathCompOpEvalPredicate().
11602|       |	    */
11603|      0|	    if (hasPredicateRange != 0)
  ------------------
  |  Branch (11603:10): [True: 0, False: 0]
  ------------------
11604|      0|		xmlXPathCompOpEvalPredicate(ctxt, predOp, seq, maxPos, maxPos,
11605|      0|					    hasNsNodes);
11606|      0|	    else
11607|      0|		xmlXPathCompOpEvalPredicate(ctxt, predOp, seq, 1, seq->nodeNr,
11608|      0|					    hasNsNodes);
11609|       |
11610|      0|	    if (ctxt->error != XPATH_EXPRESSION_OK) {
  ------------------
  |  Branch (11610:10): [True: 0, False: 0]
  ------------------
11611|      0|		total = 0;
11612|      0|		goto error;
11613|      0|	    }
11614|      0|        }
11615|       |
11616|      2|        if (seq->nodeNr > 0) {
  ------------------
  |  Branch (11616:13): [True: 2, False: 0]
  ------------------
11617|       |	    /*
11618|       |	    * Add to result set.
11619|       |	    */
11620|      2|	    if (outSeq == NULL) {
  ------------------
  |  Branch (11620:10): [True: 2, False: 0]
  ------------------
11621|      2|		outSeq = seq;
11622|      2|		seq = NULL;
11623|      2|	    } else {
11624|       |                /* TODO: Check memory error. */
11625|      0|		outSeq = mergeAndClear(outSeq, seq);
11626|      0|	    }
11627|       |
11628|      2|            if (toBool)
  ------------------
  |  Branch (11628:17): [True: 0, False: 2]
  ------------------
11629|      0|                break;
11630|      2|	}
11631|      2|    }
11632|       |
11633|      4|error:
11634|      4|    if ((obj->boolval) && (obj->user != NULL)) {
  ------------------
  |  Branch (11634:9): [True: 0, False: 4]
  |  Branch (11634:27): [True: 0, False: 0]
  ------------------
11635|       |	/*
11636|       |	* QUESTION TODO: What does this do and why?
11637|       |	* TODO: Do we have to do this also for the "error"
11638|       |	* cleanup further down?
11639|       |	*/
11640|      0|	ctxt->value->boolval = 1;
11641|      0|	ctxt->value->user = obj->user;
11642|      0|	obj->user = NULL;
11643|      0|	obj->boolval = 0;
11644|      0|    }
11645|      4|    xmlXPathReleaseObject(xpctxt, obj);
11646|       |
11647|       |    /*
11648|       |    * Ensure we return at least an empty set.
11649|       |    */
11650|      4|    if (outSeq == NULL) {
  ------------------
  |  Branch (11650:9): [True: 0, False: 4]
  ------------------
11651|      0|	if ((seq != NULL) && (seq->nodeNr == 0))
  ------------------
  |  Branch (11651:6): [True: 0, False: 0]
  |  Branch (11651:23): [True: 0, False: 0]
  ------------------
11652|      0|	    outSeq = seq;
11653|      0|	else
11654|       |            /* TODO: Check memory error. */
11655|      0|	    outSeq = xmlXPathNodeSetCreate(NULL);
11656|      0|    }
11657|      4|    if ((seq != NULL) && (seq != outSeq)) {
  ------------------
  |  Branch (11657:9): [True: 0, False: 4]
  |  Branch (11657:26): [True: 0, False: 0]
  ------------------
11658|      0|	 xmlXPathFreeNodeSet(seq);
11659|      0|    }
11660|       |    /*
11661|       |    * Hand over the result. Better to push the set also in
11662|       |    * case of errors.
11663|       |    */
11664|      4|    valuePush(ctxt, xmlXPathCacheWrapNodeSet(xpctxt, outSeq));
11665|       |    /*
11666|       |    * Reset the context node.
11667|       |    */
11668|      4|    xpctxt->node = oldContextNode;
11669|       |    /*
11670|       |    * When traversing the namespace axis in "toBool" mode, it's
11671|       |    * possible that tmpNsList wasn't freed.
11672|       |    */
11673|      4|    if (xpctxt->tmpNsList != NULL) {
  ------------------
  |  Branch (11673:9): [True: 0, False: 4]
  ------------------
11674|      0|        xmlFree(xpctxt->tmpNsList);
11675|      0|        xpctxt->tmpNsList = NULL;
11676|      0|    }
11677|       |
11678|      4|    return(total);
11679|      4|}
xpath.c:xmlXPathNextChildElement:
 6991|      4|xmlXPathNextChildElement(xmlXPathParserContextPtr ctxt, xmlNodePtr cur) {
 6992|      4|    if ((ctxt == NULL) || (ctxt->context == NULL)) return(NULL);
  ------------------
  |  Branch (6992:9): [True: 0, False: 4]
  |  Branch (6992:27): [True: 0, False: 4]
  ------------------
 6993|      4|    if (cur == NULL) {
  ------------------
  |  Branch (6993:9): [True: 2, False: 2]
  ------------------
 6994|      2|	cur = ctxt->context->node;
 6995|      2|	if (cur == NULL) return(NULL);
  ------------------
  |  Branch (6995:6): [True: 0, False: 2]
  ------------------
 6996|       |	/*
 6997|       |	* Get the first element child.
 6998|       |	*/
 6999|      2|	switch (cur->type) {
 7000|      0|            case XML_ELEMENT_NODE:
  ------------------
  |  Branch (7000:13): [True: 0, False: 2]
  ------------------
 7001|      0|	    case XML_DOCUMENT_FRAG_NODE:
  ------------------
  |  Branch (7001:6): [True: 0, False: 2]
  ------------------
 7002|      0|	    case XML_ENTITY_REF_NODE: /* URGENT TODO: entify-refs as well? */
  ------------------
  |  Branch (7002:6): [True: 0, False: 2]
  ------------------
 7003|      0|            case XML_ENTITY_NODE:
  ------------------
  |  Branch (7003:13): [True: 0, False: 2]
  ------------------
 7004|      0|		cur = cur->children;
 7005|      0|		if (cur != NULL) {
  ------------------
  |  Branch (7005:7): [True: 0, False: 0]
  ------------------
 7006|      0|		    if (cur->type == XML_ELEMENT_NODE)
  ------------------
  |  Branch (7006:11): [True: 0, False: 0]
  ------------------
 7007|      0|			return(cur);
 7008|      0|		    do {
 7009|      0|			cur = cur->next;
 7010|      0|		    } while ((cur != NULL) &&
  ------------------
  |  Branch (7010:16): [True: 0, False: 0]
  ------------------
 7011|      0|			(cur->type != XML_ELEMENT_NODE));
  ------------------
  |  Branch (7011:4): [True: 0, False: 0]
  ------------------
 7012|      0|		    return(cur);
 7013|      0|		}
 7014|      0|		return(NULL);
 7015|      2|            case XML_DOCUMENT_NODE:
  ------------------
  |  Branch (7015:13): [True: 2, False: 0]
  ------------------
 7016|      2|            case XML_HTML_DOCUMENT_NODE:
  ------------------
  |  Branch (7016:13): [True: 0, False: 2]
  ------------------
 7017|      2|		return(xmlDocGetRootElement((xmlDocPtr) cur));
 7018|      0|	    default:
  ------------------
  |  Branch (7018:6): [True: 0, False: 2]
  ------------------
 7019|      0|		return(NULL);
 7020|      2|	}
 7021|      0|	return(NULL);
 7022|      2|    }
 7023|       |    /*
 7024|       |    * Get the next sibling element node.
 7025|       |    */
 7026|      2|    switch (cur->type) {
 7027|      2|	case XML_ELEMENT_NODE:
  ------------------
  |  Branch (7027:2): [True: 2, False: 0]
  ------------------
 7028|      2|	case XML_TEXT_NODE:
  ------------------
  |  Branch (7028:2): [True: 0, False: 2]
  ------------------
 7029|      2|	case XML_ENTITY_REF_NODE:
  ------------------
  |  Branch (7029:2): [True: 0, False: 2]
  ------------------
 7030|      2|	case XML_ENTITY_NODE:
  ------------------
  |  Branch (7030:2): [True: 0, False: 2]
  ------------------
 7031|      2|	case XML_CDATA_SECTION_NODE:
  ------------------
  |  Branch (7031:2): [True: 0, False: 2]
  ------------------
 7032|      2|	case XML_PI_NODE:
  ------------------
  |  Branch (7032:2): [True: 0, False: 2]
  ------------------
 7033|      2|	case XML_COMMENT_NODE:
  ------------------
  |  Branch (7033:2): [True: 0, False: 2]
  ------------------
 7034|      2|	case XML_XINCLUDE_END:
  ------------------
  |  Branch (7034:2): [True: 0, False: 2]
  ------------------
 7035|      2|	    break;
 7036|       |	/* case XML_DTD_NODE: */ /* URGENT TODO: DTD-node as well? */
 7037|      0|	default:
  ------------------
  |  Branch (7037:2): [True: 0, False: 2]
  ------------------
 7038|      0|	    return(NULL);
 7039|      2|    }
 7040|      2|    if (cur->next != NULL) {
  ------------------
  |  Branch (7040:9): [True: 0, False: 2]
  ------------------
 7041|      0|	if (cur->next->type == XML_ELEMENT_NODE)
  ------------------
  |  Branch (7041:6): [True: 0, False: 0]
  ------------------
 7042|      0|	    return(cur->next);
 7043|      0|	cur = cur->next;
 7044|      0|	do {
 7045|      0|	    cur = cur->next;
 7046|      0|	} while ((cur != NULL) && (cur->type != XML_ELEMENT_NODE));
  ------------------
  |  Branch (7046:11): [True: 0, False: 0]
  |  Branch (7046:28): [True: 0, False: 0]
  ------------------
 7047|      0|	return(cur);
 7048|      0|    }
 7049|      2|    return(NULL);
 7050|      2|}
xpath.c:xmlXPathIsPositionalPredicate:
11034|      2|{
11035|       |
11036|      2|    xmlXPathStepOpPtr exprOp;
11037|       |
11038|       |    /*
11039|       |    * BIG NOTE: This is not intended for XPATH_OP_FILTER yet!
11040|       |    */
11041|       |
11042|       |    /*
11043|       |    * If not -1, then ch1 will point to:
11044|       |    * 1) For predicates (XPATH_OP_PREDICATE):
11045|       |    *    - an inner predicate operator
11046|       |    * 2) For filters (XPATH_OP_FILTER):
11047|       |    *    - an inner filter operator OR
11048|       |    *    - an expression selecting the node set.
11049|       |    *      E.g. "key('a', 'b')" or "(//foo | //bar)".
11050|       |    */
11051|      2|    if ((op->op != XPATH_OP_PREDICATE) && (op->op != XPATH_OP_FILTER))
  ------------------
  |  Branch (11051:9): [True: 0, False: 2]
  |  Branch (11051:43): [True: 0, False: 0]
  ------------------
11052|      0|	return(0);
11053|       |
11054|      2|    if (op->ch2 != -1) {
  ------------------
  |  Branch (11054:9): [True: 2, False: 0]
  ------------------
11055|      2|	exprOp = &ctxt->comp->steps[op->ch2];
11056|      2|    } else
11057|      0|	return(0);
11058|       |
11059|      2|    if ((exprOp != NULL) &&
  ------------------
  |  Branch (11059:9): [True: 2, False: 0]
  ------------------
11060|      2|	(exprOp->op == XPATH_OP_VALUE) &&
  ------------------
  |  Branch (11060:2): [True: 2, False: 0]
  ------------------
11061|      2|	(exprOp->value4 != NULL) &&
  ------------------
  |  Branch (11061:2): [True: 2, False: 0]
  ------------------
11062|      2|	(((xmlXPathObjectPtr) exprOp->value4)->type == XPATH_NUMBER))
  ------------------
  |  Branch (11062:2): [True: 2, False: 0]
  ------------------
11063|      2|    {
11064|      2|        double floatval = ((xmlXPathObjectPtr) exprOp->value4)->floatval;
11065|       |
11066|       |	/*
11067|       |	* We have a "[n]" predicate here.
11068|       |	* TODO: Unfortunately this simplistic test here is not
11069|       |	* able to detect a position() predicate in compound
11070|       |	* expressions like "[@attr = 'a" and position() = 1],
11071|       |	* and even not the usage of position() in
11072|       |	* "[position() = 1]"; thus - obviously - a position-range,
11073|       |	* like it "[position() < 5]", is also not detected.
11074|       |	* Maybe we could rewrite the AST to ease the optimization.
11075|       |	*/
11076|       |
11077|      2|        if ((floatval > INT_MIN) && (floatval < INT_MAX)) {
  ------------------
  |  Branch (11077:13): [True: 2, False: 0]
  |  Branch (11077:37): [True: 2, False: 0]
  ------------------
11078|      2|	    *maxPos = (int) floatval;
11079|      2|            if (floatval == (double) *maxPos)
  ------------------
  |  Branch (11079:17): [True: 2, False: 0]
  ------------------
11080|      2|                return(1);
11081|      2|        }
11082|      2|    }
11083|      0|    return(0);
11084|      2|}
xpath.c:xmlXPathCompOpEval:
12065|      8|{
12066|      8|    int total = 0;
12067|      8|    int equal, ret;
12068|      8|    xmlXPathCompExprPtr comp;
12069|      8|    xmlXPathObjectPtr arg1, arg2;
12070|       |
12071|      8|    CHECK_ERROR0;
  ------------------
  |  |  249|      8|    if (ctxt->error != XPATH_EXPRESSION_OK) return(0)
  |  |  ------------------
  |  |  |  Branch (249:9): [True: 0, False: 8]
  |  |  ------------------
  ------------------
12072|      8|    if (OP_LIMIT_EXCEEDED(ctxt, 1))
  ------------------
  |  |  787|      8|    ((ctxt->context->opLimit != 0) && (xmlXPathCheckOpLimit(ctxt, n) < 0))
  |  |  ------------------
  |  |  |  Branch (787:6): [True: 0, False: 8]
  |  |  |  Branch (787:39): [True: 0, False: 0]
  |  |  ------------------
  ------------------
12073|      0|        return(0);
12074|      8|    if (ctxt->context->depth >= XPATH_MAX_RECURSION_DEPTH)
  ------------------
  |  |  124|      8|#define XPATH_MAX_RECURSION_DEPTH 500
  ------------------
  |  Branch (12074:9): [True: 0, False: 8]
  ------------------
12075|      8|        XP_ERROR0(XPATH_RECURSION_LIMIT_EXCEEDED);
  ------------------
  |  |  267|      0|    { xmlXPathErr(ctxt, X); return(0); }
  ------------------
12076|      8|    ctxt->context->depth += 1;
12077|      8|    comp = ctxt->comp;
12078|      8|    switch (op->op) {
12079|      0|        case XPATH_OP_END:
  ------------------
  |  Branch (12079:9): [True: 0, False: 8]
  ------------------
12080|      0|            break;
12081|      0|        case XPATH_OP_AND:
  ------------------
  |  Branch (12081:9): [True: 0, False: 8]
  ------------------
12082|      0|            total += xmlXPathCompOpEval(ctxt, &comp->steps[op->ch1]);
12083|      0|	    CHECK_ERROR0;
  ------------------
  |  |  249|      0|    if (ctxt->error != XPATH_EXPRESSION_OK) return(0)
  |  |  ------------------
  |  |  |  Branch (249:9): [True: 0, False: 0]
  |  |  ------------------
  ------------------
12084|      0|            xmlXPathBooleanFunction(ctxt, 1);
12085|      0|            if ((ctxt->value == NULL) || (ctxt->value->boolval == 0))
  ------------------
  |  Branch (12085:17): [True: 0, False: 0]
  |  Branch (12085:42): [True: 0, False: 0]
  ------------------
12086|      0|                break;
12087|      0|            arg2 = valuePop(ctxt);
12088|      0|            total += xmlXPathCompOpEval(ctxt, &comp->steps[op->ch2]);
12089|      0|	    if (ctxt->error) {
  ------------------
  |  Branch (12089:10): [True: 0, False: 0]
  ------------------
12090|      0|		xmlXPathFreeObject(arg2);
12091|      0|		break;
12092|      0|	    }
12093|      0|            xmlXPathBooleanFunction(ctxt, 1);
12094|      0|            if (ctxt->value != NULL)
  ------------------
  |  Branch (12094:17): [True: 0, False: 0]
  ------------------
12095|      0|                ctxt->value->boolval &= arg2->boolval;
12096|      0|	    xmlXPathReleaseObject(ctxt->context, arg2);
12097|      0|            break;
12098|      0|        case XPATH_OP_OR:
  ------------------
  |  Branch (12098:9): [True: 0, False: 8]
  ------------------
12099|      0|            total += xmlXPathCompOpEval(ctxt, &comp->steps[op->ch1]);
12100|      0|	    CHECK_ERROR0;
  ------------------
  |  |  249|      0|    if (ctxt->error != XPATH_EXPRESSION_OK) return(0)
  |  |  ------------------
  |  |  |  Branch (249:9): [True: 0, False: 0]
  |  |  ------------------
  ------------------
12101|      0|            xmlXPathBooleanFunction(ctxt, 1);
12102|      0|            if ((ctxt->value == NULL) || (ctxt->value->boolval == 1))
  ------------------
  |  Branch (12102:17): [True: 0, False: 0]
  |  Branch (12102:42): [True: 0, False: 0]
  ------------------
12103|      0|                break;
12104|      0|            arg2 = valuePop(ctxt);
12105|      0|            total += xmlXPathCompOpEval(ctxt, &comp->steps[op->ch2]);
12106|      0|	    if (ctxt->error) {
  ------------------
  |  Branch (12106:10): [True: 0, False: 0]
  ------------------
12107|      0|		xmlXPathFreeObject(arg2);
12108|      0|		break;
12109|      0|	    }
12110|      0|            xmlXPathBooleanFunction(ctxt, 1);
12111|      0|            if (ctxt->value != NULL)
  ------------------
  |  Branch (12111:17): [True: 0, False: 0]
  ------------------
12112|      0|                ctxt->value->boolval |= arg2->boolval;
12113|      0|	    xmlXPathReleaseObject(ctxt->context, arg2);
12114|      0|            break;
12115|      0|        case XPATH_OP_EQUAL:
  ------------------
  |  Branch (12115:9): [True: 0, False: 8]
  ------------------
12116|      0|            total += xmlXPathCompOpEval(ctxt, &comp->steps[op->ch1]);
12117|      0|	    CHECK_ERROR0;
  ------------------
  |  |  249|      0|    if (ctxt->error != XPATH_EXPRESSION_OK) return(0)
  |  |  ------------------
  |  |  |  Branch (249:9): [True: 0, False: 0]
  |  |  ------------------
  ------------------
12118|      0|            total += xmlXPathCompOpEval(ctxt, &comp->steps[op->ch2]);
12119|      0|	    CHECK_ERROR0;
  ------------------
  |  |  249|      0|    if (ctxt->error != XPATH_EXPRESSION_OK) return(0)
  |  |  ------------------
  |  |  |  Branch (249:9): [True: 0, False: 0]
  |  |  ------------------
  ------------------
12120|      0|	    if (op->value)
  ------------------
  |  Branch (12120:10): [True: 0, False: 0]
  ------------------
12121|      0|		equal = xmlXPathEqualValues(ctxt);
12122|      0|	    else
12123|      0|		equal = xmlXPathNotEqualValues(ctxt);
12124|      0|	    valuePush(ctxt, xmlXPathCacheNewBoolean(ctxt->context, equal));
12125|      0|            break;
12126|      0|        case XPATH_OP_CMP:
  ------------------
  |  Branch (12126:9): [True: 0, False: 8]
  ------------------
12127|      0|            total += xmlXPathCompOpEval(ctxt, &comp->steps[op->ch1]);
12128|      0|	    CHECK_ERROR0;
  ------------------
  |  |  249|      0|    if (ctxt->error != XPATH_EXPRESSION_OK) return(0)
  |  |  ------------------
  |  |  |  Branch (249:9): [True: 0, False: 0]
  |  |  ------------------
  ------------------
12129|      0|            total += xmlXPathCompOpEval(ctxt, &comp->steps[op->ch2]);
12130|      0|	    CHECK_ERROR0;
  ------------------
  |  |  249|      0|    if (ctxt->error != XPATH_EXPRESSION_OK) return(0)
  |  |  ------------------
  |  |  |  Branch (249:9): [True: 0, False: 0]
  |  |  ------------------
  ------------------
12131|      0|            ret = xmlXPathCompareValues(ctxt, op->value, op->value2);
12132|      0|	    valuePush(ctxt, xmlXPathCacheNewBoolean(ctxt->context, ret));
12133|      0|            break;
12134|      0|        case XPATH_OP_PLUS:
  ------------------
  |  Branch (12134:9): [True: 0, False: 8]
  ------------------
12135|      0|            total += xmlXPathCompOpEval(ctxt, &comp->steps[op->ch1]);
12136|      0|	    CHECK_ERROR0;
  ------------------
  |  |  249|      0|    if (ctxt->error != XPATH_EXPRESSION_OK) return(0)
  |  |  ------------------
  |  |  |  Branch (249:9): [True: 0, False: 0]
  |  |  ------------------
  ------------------
12137|      0|            if (op->ch2 != -1) {
  ------------------
  |  Branch (12137:17): [True: 0, False: 0]
  ------------------
12138|      0|                total += xmlXPathCompOpEval(ctxt, &comp->steps[op->ch2]);
12139|      0|	    }
12140|      0|	    CHECK_ERROR0;
  ------------------
  |  |  249|      0|    if (ctxt->error != XPATH_EXPRESSION_OK) return(0)
  |  |  ------------------
  |  |  |  Branch (249:9): [True: 0, False: 0]
  |  |  ------------------
  ------------------
12141|      0|            if (op->value == 0)
  ------------------
  |  Branch (12141:17): [True: 0, False: 0]
  ------------------
12142|      0|                xmlXPathSubValues(ctxt);
12143|      0|            else if (op->value == 1)
  ------------------
  |  Branch (12143:22): [True: 0, False: 0]
  ------------------
12144|      0|                xmlXPathAddValues(ctxt);
12145|      0|            else if (op->value == 2)
  ------------------
  |  Branch (12145:22): [True: 0, False: 0]
  ------------------
12146|      0|                xmlXPathValueFlipSign(ctxt);
12147|      0|            else if (op->value == 3) {
  ------------------
  |  Branch (12147:22): [True: 0, False: 0]
  ------------------
12148|      0|                CAST_TO_NUMBER;
  ------------------
  |  |  319|      0|    if ((ctxt->value != NULL) && (ctxt->value->type != XPATH_NUMBER))	\
  |  |  ------------------
  |  |  |  Branch (319:9): [True: 0, False: 0]
  |  |  |  Branch (319:34): [True: 0, False: 0]
  |  |  ------------------
  |  |  320|      0|        xmlXPathNumberFunction(ctxt, 1);
  ------------------
12149|      0|                CHECK_TYPE0(XPATH_NUMBER);
  ------------------
  |  |  288|      0|    if ((ctxt->value == NULL) || (ctxt->value->type != typeval))	\
  |  |  ------------------
  |  |  |  Branch (288:9): [True: 0, False: 0]
  |  |  |  Branch (288:34): [True: 0, False: 0]
  |  |  ------------------
  |  |  289|      0|        XP_ERROR0(XPATH_INVALID_TYPE)
  |  |  ------------------
  |  |  |  |  267|      0|    { xmlXPathErr(ctxt, X); return(0); }
  |  |  ------------------
  ------------------
12150|      0|            }
12151|      0|            break;
12152|      0|        case XPATH_OP_MULT:
  ------------------
  |  Branch (12152:9): [True: 0, False: 8]
  ------------------
12153|      0|            total += xmlXPathCompOpEval(ctxt, &comp->steps[op->ch1]);
12154|      0|	    CHECK_ERROR0;
  ------------------
  |  |  249|      0|    if (ctxt->error != XPATH_EXPRESSION_OK) return(0)
  |  |  ------------------
  |  |  |  Branch (249:9): [True: 0, False: 0]
  |  |  ------------------
  ------------------
12155|      0|            total += xmlXPathCompOpEval(ctxt, &comp->steps[op->ch2]);
12156|      0|	    CHECK_ERROR0;
  ------------------
  |  |  249|      0|    if (ctxt->error != XPATH_EXPRESSION_OK) return(0)
  |  |  ------------------
  |  |  |  Branch (249:9): [True: 0, False: 0]
  |  |  ------------------
  ------------------
12157|      0|            if (op->value == 0)
  ------------------
  |  Branch (12157:17): [True: 0, False: 0]
  ------------------
12158|      0|                xmlXPathMultValues(ctxt);
12159|      0|            else if (op->value == 1)
  ------------------
  |  Branch (12159:22): [True: 0, False: 0]
  ------------------
12160|      0|                xmlXPathDivValues(ctxt);
12161|      0|            else if (op->value == 2)
  ------------------
  |  Branch (12161:22): [True: 0, False: 0]
  ------------------
12162|      0|                xmlXPathModValues(ctxt);
12163|      0|            break;
12164|      0|        case XPATH_OP_UNION:
  ------------------
  |  Branch (12164:9): [True: 0, False: 8]
  ------------------
12165|      0|            total += xmlXPathCompOpEval(ctxt, &comp->steps[op->ch1]);
12166|      0|	    CHECK_ERROR0;
  ------------------
  |  |  249|      0|    if (ctxt->error != XPATH_EXPRESSION_OK) return(0)
  |  |  ------------------
  |  |  |  Branch (249:9): [True: 0, False: 0]
  |  |  ------------------
  ------------------
12167|      0|            total += xmlXPathCompOpEval(ctxt, &comp->steps[op->ch2]);
12168|      0|	    CHECK_ERROR0;
  ------------------
  |  |  249|      0|    if (ctxt->error != XPATH_EXPRESSION_OK) return(0)
  |  |  ------------------
  |  |  |  Branch (249:9): [True: 0, False: 0]
  |  |  ------------------
  ------------------
12169|       |
12170|      0|            arg2 = valuePop(ctxt);
12171|      0|            arg1 = valuePop(ctxt);
12172|      0|            if ((arg1 == NULL) || (arg1->type != XPATH_NODESET) ||
  ------------------
  |  Branch (12172:17): [True: 0, False: 0]
  |  Branch (12172:35): [True: 0, False: 0]
  ------------------
12173|      0|                (arg2 == NULL) || (arg2->type != XPATH_NODESET)) {
  ------------------
  |  Branch (12173:17): [True: 0, False: 0]
  |  Branch (12173:35): [True: 0, False: 0]
  ------------------
12174|      0|	        xmlXPathReleaseObject(ctxt->context, arg1);
12175|      0|	        xmlXPathReleaseObject(ctxt->context, arg2);
12176|      0|                XP_ERROR0(XPATH_INVALID_TYPE);
  ------------------
  |  |  267|      0|    { xmlXPathErr(ctxt, X); return(0); }
  ------------------
12177|      0|            }
12178|      0|            if ((ctxt->context->opLimit != 0) &&
  ------------------
  |  Branch (12178:17): [True: 0, False: 0]
  ------------------
12179|      0|                (((arg1->nodesetval != NULL) &&
  ------------------
  |  Branch (12179:19): [True: 0, False: 0]
  ------------------
12180|      0|                  (xmlXPathCheckOpLimit(ctxt,
  ------------------
  |  Branch (12180:19): [True: 0, False: 0]
  ------------------
12181|      0|                                        arg1->nodesetval->nodeNr) < 0)) ||
12182|      0|                 ((arg2->nodesetval != NULL) &&
  ------------------
  |  Branch (12182:19): [True: 0, False: 0]
  ------------------
12183|      0|                  (xmlXPathCheckOpLimit(ctxt,
  ------------------
  |  Branch (12183:19): [True: 0, False: 0]
  ------------------
12184|      0|                                        arg2->nodesetval->nodeNr) < 0)))) {
12185|      0|	        xmlXPathReleaseObject(ctxt->context, arg1);
12186|      0|	        xmlXPathReleaseObject(ctxt->context, arg2);
12187|      0|                break;
12188|      0|            }
12189|       |
12190|      0|	    if ((arg1->nodesetval == NULL) ||
  ------------------
  |  Branch (12190:10): [True: 0, False: 0]
  ------------------
12191|      0|		((arg2->nodesetval != NULL) &&
  ------------------
  |  Branch (12191:4): [True: 0, False: 0]
  ------------------
12192|      0|		 (arg2->nodesetval->nodeNr != 0)))
  ------------------
  |  Branch (12192:4): [True: 0, False: 0]
  ------------------
12193|      0|	    {
12194|       |                /* TODO: Check memory error. */
12195|      0|		arg1->nodesetval = xmlXPathNodeSetMerge(arg1->nodesetval,
12196|      0|							arg2->nodesetval);
12197|      0|	    }
12198|       |
12199|      0|            valuePush(ctxt, arg1);
12200|      0|	    xmlXPathReleaseObject(ctxt->context, arg2);
12201|      0|            break;
12202|      2|        case XPATH_OP_ROOT:
  ------------------
  |  Branch (12202:9): [True: 2, False: 6]
  ------------------
12203|      2|            xmlXPathRoot(ctxt);
12204|      2|            break;
12205|      0|        case XPATH_OP_NODE:
  ------------------
  |  Branch (12205:9): [True: 0, False: 8]
  ------------------
12206|      0|            if (op->ch1 != -1)
  ------------------
  |  Branch (12206:17): [True: 0, False: 0]
  ------------------
12207|      0|                total += xmlXPathCompOpEval(ctxt, &comp->steps[op->ch1]);
12208|      0|	    CHECK_ERROR0;
  ------------------
  |  |  249|      0|    if (ctxt->error != XPATH_EXPRESSION_OK) return(0)
  |  |  ------------------
  |  |  |  Branch (249:9): [True: 0, False: 0]
  |  |  ------------------
  ------------------
12209|      0|            if (op->ch2 != -1)
  ------------------
  |  Branch (12209:17): [True: 0, False: 0]
  ------------------
12210|      0|                total += xmlXPathCompOpEval(ctxt, &comp->steps[op->ch2]);
12211|      0|	    CHECK_ERROR0;
  ------------------
  |  |  249|      0|    if (ctxt->error != XPATH_EXPRESSION_OK) return(0)
  |  |  ------------------
  |  |  |  Branch (249:9): [True: 0, False: 0]
  |  |  ------------------
  ------------------
12212|      0|	    valuePush(ctxt, xmlXPathCacheNewNodeSet(ctxt->context,
12213|      0|		ctxt->context->node));
12214|      0|            break;
12215|      4|        case XPATH_OP_COLLECT:{
  ------------------
  |  Branch (12215:9): [True: 4, False: 4]
  ------------------
12216|      4|                if (op->ch1 == -1)
  ------------------
  |  Branch (12216:21): [True: 0, False: 4]
  ------------------
12217|      0|                    break;
12218|       |
12219|      4|                total += xmlXPathCompOpEval(ctxt, &comp->steps[op->ch1]);
12220|      4|		CHECK_ERROR0;
  ------------------
  |  |  249|      4|    if (ctxt->error != XPATH_EXPRESSION_OK) return(0)
  |  |  ------------------
  |  |  |  Branch (249:9): [True: 0, False: 4]
  |  |  ------------------
  ------------------
12221|       |
12222|      4|                total += xmlXPathNodeCollectAndTest(ctxt, op, NULL, NULL, 0);
12223|      4|                break;
12224|      4|            }
12225|      0|        case XPATH_OP_VALUE:
  ------------------
  |  Branch (12225:9): [True: 0, False: 8]
  ------------------
12226|      0|            valuePush(ctxt,
12227|      0|                      xmlXPathCacheObjectCopy(ctxt->context,
12228|      0|			(xmlXPathObjectPtr) op->value4));
12229|      0|            break;
12230|      0|        case XPATH_OP_VARIABLE:{
  ------------------
  |  Branch (12230:9): [True: 0, False: 8]
  ------------------
12231|      0|		xmlXPathObjectPtr val;
12232|       |
12233|      0|                if (op->ch1 != -1)
  ------------------
  |  Branch (12233:21): [True: 0, False: 0]
  ------------------
12234|      0|                    total +=
12235|      0|                        xmlXPathCompOpEval(ctxt, &comp->steps[op->ch1]);
12236|      0|                if (op->value5 == NULL) {
  ------------------
  |  Branch (12236:21): [True: 0, False: 0]
  ------------------
12237|      0|		    val = xmlXPathVariableLookup(ctxt->context, op->value4);
12238|      0|		    if (val == NULL)
  ------------------
  |  Branch (12238:11): [True: 0, False: 0]
  ------------------
12239|      0|			XP_ERROR0(XPATH_UNDEF_VARIABLE_ERROR);
  ------------------
  |  |  267|      0|    { xmlXPathErr(ctxt, X); return(0); }
  ------------------
12240|      0|                    valuePush(ctxt, val);
12241|      0|		} else {
12242|      0|                    const xmlChar *URI;
12243|       |
12244|      0|                    URI = xmlXPathNsLookup(ctxt->context, op->value5);
12245|      0|                    if (URI == NULL) {
  ------------------
  |  Branch (12245:25): [True: 0, False: 0]
  ------------------
12246|      0|                        xmlGenericError(xmlGenericErrorContext,
  ------------------
  |  |  875|      0|  #define xmlGenericError XML_GLOBAL_MACRO(xmlGenericError)
  |  |  ------------------
  |  |  |  |  500|      0|  #define XML_GLOBAL_MACRO(name) (*__##name())
  |  |  ------------------
  ------------------
                                      xmlGenericError(xmlGenericErrorContext,
  ------------------
  |  |  876|      0|  #define xmlGenericErrorContext XML_GLOBAL_MACRO(xmlGenericErrorContext)
  |  |  ------------------
  |  |  |  |  500|      0|  #define XML_GLOBAL_MACRO(name) (*__##name())
  |  |  ------------------
  ------------------
12247|      0|            "xmlXPathCompOpEval: variable %s bound to undefined prefix %s\n",
12248|      0|                                    (char *) op->value4, (char *)op->value5);
12249|      0|                        ctxt->error = XPATH_UNDEF_PREFIX_ERROR;
12250|      0|                        break;
12251|      0|                    }
12252|      0|		    val = xmlXPathVariableLookupNS(ctxt->context,
12253|      0|                                                       op->value4, URI);
12254|      0|		    if (val == NULL)
  ------------------
  |  Branch (12254:11): [True: 0, False: 0]
  ------------------
12255|      0|			XP_ERROR0(XPATH_UNDEF_VARIABLE_ERROR);
  ------------------
  |  |  267|      0|    { xmlXPathErr(ctxt, X); return(0); }
  ------------------
12256|      0|                    valuePush(ctxt, val);
12257|      0|                }
12258|      0|                break;
12259|      0|            }
12260|      0|        case XPATH_OP_FUNCTION:{
  ------------------
  |  Branch (12260:9): [True: 0, False: 8]
  ------------------
12261|      0|                xmlXPathFunction func;
12262|      0|                const xmlChar *oldFunc, *oldFuncURI;
12263|      0|		int i;
12264|      0|                int frame;
12265|       |
12266|      0|                frame = ctxt->valueNr;
12267|      0|                if (op->ch1 != -1) {
  ------------------
  |  Branch (12267:21): [True: 0, False: 0]
  ------------------
12268|      0|                    total +=
12269|      0|                        xmlXPathCompOpEval(ctxt, &comp->steps[op->ch1]);
12270|      0|                    if (ctxt->error != XPATH_EXPRESSION_OK)
  ------------------
  |  Branch (12270:25): [True: 0, False: 0]
  ------------------
12271|      0|                        break;
12272|      0|                }
12273|      0|		if (ctxt->valueNr < frame + op->value) {
  ------------------
  |  Branch (12273:7): [True: 0, False: 0]
  ------------------
12274|      0|		    xmlGenericError(xmlGenericErrorContext,
  ------------------
  |  |  875|      0|  #define xmlGenericError XML_GLOBAL_MACRO(xmlGenericError)
  |  |  ------------------
  |  |  |  |  500|      0|  #define XML_GLOBAL_MACRO(name) (*__##name())
  |  |  ------------------
  ------------------
              		    xmlGenericError(xmlGenericErrorContext,
  ------------------
  |  |  876|      0|  #define xmlGenericErrorContext XML_GLOBAL_MACRO(xmlGenericErrorContext)
  |  |  ------------------
  |  |  |  |  500|      0|  #define XML_GLOBAL_MACRO(name) (*__##name())
  |  |  ------------------
  ------------------
12275|      0|			    "xmlXPathCompOpEval: parameter error\n");
12276|      0|		    ctxt->error = XPATH_INVALID_OPERAND;
12277|      0|		    break;
12278|      0|		}
12279|      0|		for (i = 0; i < op->value; i++) {
  ------------------
  |  Branch (12279:15): [True: 0, False: 0]
  ------------------
12280|      0|		    if (ctxt->valueTab[(ctxt->valueNr - 1) - i] == NULL) {
  ------------------
  |  Branch (12280:11): [True: 0, False: 0]
  ------------------
12281|      0|			xmlGenericError(xmlGenericErrorContext,
  ------------------
  |  |  875|      0|  #define xmlGenericError XML_GLOBAL_MACRO(xmlGenericError)
  |  |  ------------------
  |  |  |  |  500|      0|  #define XML_GLOBAL_MACRO(name) (*__##name())
  |  |  ------------------
  ------------------
              			xmlGenericError(xmlGenericErrorContext,
  ------------------
  |  |  876|      0|  #define xmlGenericErrorContext XML_GLOBAL_MACRO(xmlGenericErrorContext)
  |  |  ------------------
  |  |  |  |  500|      0|  #define XML_GLOBAL_MACRO(name) (*__##name())
  |  |  ------------------
  ------------------
12282|      0|				"xmlXPathCompOpEval: parameter error\n");
12283|      0|			ctxt->error = XPATH_INVALID_OPERAND;
12284|      0|			break;
12285|      0|		    }
12286|      0|                }
12287|      0|                if (op->cache != NULL)
  ------------------
  |  Branch (12287:21): [True: 0, False: 0]
  ------------------
12288|      0|                    func = op->cache;
12289|      0|                else {
12290|      0|                    const xmlChar *URI = NULL;
12291|       |
12292|      0|                    if (op->value5 == NULL)
  ------------------
  |  Branch (12292:25): [True: 0, False: 0]
  ------------------
12293|      0|                        func =
12294|      0|                            xmlXPathFunctionLookup(ctxt->context,
12295|      0|                                                   op->value4);
12296|      0|                    else {
12297|      0|                        URI = xmlXPathNsLookup(ctxt->context, op->value5);
12298|      0|                        if (URI == NULL) {
  ------------------
  |  Branch (12298:29): [True: 0, False: 0]
  ------------------
12299|      0|                            xmlGenericError(xmlGenericErrorContext,
  ------------------
  |  |  875|      0|  #define xmlGenericError XML_GLOBAL_MACRO(xmlGenericError)
  |  |  ------------------
  |  |  |  |  500|      0|  #define XML_GLOBAL_MACRO(name) (*__##name())
  |  |  ------------------
  ------------------
                                          xmlGenericError(xmlGenericErrorContext,
  ------------------
  |  |  876|      0|  #define xmlGenericErrorContext XML_GLOBAL_MACRO(xmlGenericErrorContext)
  |  |  ------------------
  |  |  |  |  500|      0|  #define XML_GLOBAL_MACRO(name) (*__##name())
  |  |  ------------------
  ------------------
12300|      0|            "xmlXPathCompOpEval: function %s bound to undefined prefix %s\n",
12301|      0|                                    (char *)op->value4, (char *)op->value5);
12302|      0|                            ctxt->error = XPATH_UNDEF_PREFIX_ERROR;
12303|      0|                            break;
12304|      0|                        }
12305|      0|                        func = xmlXPathFunctionLookupNS(ctxt->context,
12306|      0|                                                        op->value4, URI);
12307|      0|                    }
12308|      0|                    if (func == NULL) {
  ------------------
  |  Branch (12308:25): [True: 0, False: 0]
  ------------------
12309|      0|                        xmlGenericError(xmlGenericErrorContext,
  ------------------
  |  |  875|      0|  #define xmlGenericError XML_GLOBAL_MACRO(xmlGenericError)
  |  |  ------------------
  |  |  |  |  500|      0|  #define XML_GLOBAL_MACRO(name) (*__##name())
  |  |  ------------------
  ------------------
                                      xmlGenericError(xmlGenericErrorContext,
  ------------------
  |  |  876|      0|  #define xmlGenericErrorContext XML_GLOBAL_MACRO(xmlGenericErrorContext)
  |  |  ------------------
  |  |  |  |  500|      0|  #define XML_GLOBAL_MACRO(name) (*__##name())
  |  |  ------------------
  ------------------
12310|      0|                                "xmlXPathCompOpEval: function %s not found\n",
12311|      0|                                        (char *)op->value4);
12312|      0|                        XP_ERROR0(XPATH_UNKNOWN_FUNC_ERROR);
  ------------------
  |  |  267|      0|    { xmlXPathErr(ctxt, X); return(0); }
  ------------------
12313|      0|                    }
12314|      0|                    op->cache = func;
12315|      0|                    op->cacheURI = (void *) URI;
12316|      0|                }
12317|      0|                oldFunc = ctxt->context->function;
12318|      0|                oldFuncURI = ctxt->context->functionURI;
12319|      0|                ctxt->context->function = op->value4;
12320|      0|                ctxt->context->functionURI = op->cacheURI;
12321|      0|                func(ctxt, op->value);
12322|      0|                ctxt->context->function = oldFunc;
12323|      0|                ctxt->context->functionURI = oldFuncURI;
12324|      0|                if ((ctxt->error == XPATH_EXPRESSION_OK) &&
  ------------------
  |  Branch (12324:21): [True: 0, False: 0]
  ------------------
12325|      0|                    (ctxt->valueNr != frame + 1))
  ------------------
  |  Branch (12325:21): [True: 0, False: 0]
  ------------------
12326|      0|                    XP_ERROR0(XPATH_STACK_ERROR);
  ------------------
  |  |  267|      0|    { xmlXPathErr(ctxt, X); return(0); }
  ------------------
12327|      0|                break;
12328|      0|            }
12329|      0|        case XPATH_OP_ARG:
  ------------------
  |  Branch (12329:9): [True: 0, False: 8]
  ------------------
12330|      0|            if (op->ch1 != -1) {
  ------------------
  |  Branch (12330:17): [True: 0, False: 0]
  ------------------
12331|      0|                total += xmlXPathCompOpEval(ctxt, &comp->steps[op->ch1]);
12332|      0|	        CHECK_ERROR0;
  ------------------
  |  |  249|      0|    if (ctxt->error != XPATH_EXPRESSION_OK) return(0)
  |  |  ------------------
  |  |  |  Branch (249:9): [True: 0, False: 0]
  |  |  ------------------
  ------------------
12333|      0|            }
12334|      0|            if (op->ch2 != -1) {
  ------------------
  |  Branch (12334:17): [True: 0, False: 0]
  ------------------
12335|      0|                total += xmlXPathCompOpEval(ctxt, &comp->steps[op->ch2]);
12336|      0|	        CHECK_ERROR0;
  ------------------
  |  |  249|      0|    if (ctxt->error != XPATH_EXPRESSION_OK) return(0)
  |  |  ------------------
  |  |  |  Branch (249:9): [True: 0, False: 0]
  |  |  ------------------
  ------------------
12337|      0|	    }
12338|      0|            break;
12339|      0|        case XPATH_OP_PREDICATE:
  ------------------
  |  Branch (12339:9): [True: 0, False: 8]
  ------------------
12340|      0|        case XPATH_OP_FILTER:{
  ------------------
  |  Branch (12340:9): [True: 0, False: 8]
  ------------------
12341|      0|                xmlXPathObjectPtr obj;
12342|      0|                xmlNodeSetPtr set;
12343|       |
12344|       |                /*
12345|       |                 * Optimization for ()[1] selection i.e. the first elem
12346|       |                 */
12347|      0|                if ((op->ch1 != -1) && (op->ch2 != -1) &&
  ------------------
  |  Branch (12347:21): [True: 0, False: 0]
  |  Branch (12347:40): [True: 0, False: 0]
  ------------------
12348|      0|#ifdef XP_OPTIMIZED_FILTER_FIRST
12349|       |		    /*
12350|       |		    * FILTER TODO: Can we assume that the inner processing
12351|       |		    *  will result in an ordered list if we have an
12352|       |		    *  XPATH_OP_FILTER?
12353|       |		    *  What about an additional field or flag on
12354|       |		    *  xmlXPathObject like @sorted ? This way we wouldn't need
12355|       |		    *  to assume anything, so it would be more robust and
12356|       |		    *  easier to optimize.
12357|       |		    */
12358|      0|                    ((comp->steps[op->ch1].op == XPATH_OP_SORT) || /* 18 */
  ------------------
  |  Branch (12358:22): [True: 0, False: 0]
  ------------------
12359|      0|		     (comp->steps[op->ch1].op == XPATH_OP_FILTER)) && /* 17 */
  ------------------
  |  Branch (12359:8): [True: 0, False: 0]
  ------------------
12360|       |#else
12361|       |		    (comp->steps[op->ch1].op == XPATH_OP_SORT) &&
12362|       |#endif
12363|      0|                    (comp->steps[op->ch2].op == XPATH_OP_VALUE)) { /* 12 */
  ------------------
  |  Branch (12363:21): [True: 0, False: 0]
  ------------------
12364|      0|                    xmlXPathObjectPtr val;
12365|       |
12366|      0|                    val = comp->steps[op->ch2].value4;
12367|      0|                    if ((val != NULL) && (val->type == XPATH_NUMBER) &&
  ------------------
  |  Branch (12367:25): [True: 0, False: 0]
  |  Branch (12367:42): [True: 0, False: 0]
  ------------------
12368|      0|                        (val->floatval == 1.0)) {
  ------------------
  |  Branch (12368:25): [True: 0, False: 0]
  ------------------
12369|      0|                        xmlNodePtr first = NULL;
12370|       |
12371|      0|                        total +=
12372|      0|                            xmlXPathCompOpEvalFirst(ctxt,
12373|      0|                                                    &comp->steps[op->ch1],
12374|      0|                                                    &first);
12375|      0|			CHECK_ERROR0;
  ------------------
  |  |  249|      0|    if (ctxt->error != XPATH_EXPRESSION_OK) return(0)
  |  |  ------------------
  |  |  |  Branch (249:9): [True: 0, False: 0]
  |  |  ------------------
  ------------------
12376|       |                        /*
12377|       |                         * The nodeset should be in document order,
12378|       |                         * Keep only the first value
12379|       |                         */
12380|      0|                        if ((ctxt->value != NULL) &&
  ------------------
  |  Branch (12380:29): [True: 0, False: 0]
  ------------------
12381|      0|                            (ctxt->value->type == XPATH_NODESET) &&
  ------------------
  |  Branch (12381:29): [True: 0, False: 0]
  ------------------
12382|      0|                            (ctxt->value->nodesetval != NULL) &&
  ------------------
  |  Branch (12382:29): [True: 0, False: 0]
  ------------------
12383|      0|                            (ctxt->value->nodesetval->nodeNr > 1))
  ------------------
  |  Branch (12383:29): [True: 0, False: 0]
  ------------------
12384|      0|                            xmlXPathNodeSetClearFromPos(ctxt->value->nodesetval,
12385|      0|                                                        1, 1);
12386|      0|                        break;
12387|      0|                    }
12388|      0|                }
12389|       |                /*
12390|       |                 * Optimization for ()[last()] selection i.e. the last elem
12391|       |                 */
12392|      0|                if ((op->ch1 != -1) && (op->ch2 != -1) &&
  ------------------
  |  Branch (12392:21): [True: 0, False: 0]
  |  Branch (12392:40): [True: 0, False: 0]
  ------------------
12393|      0|                    (comp->steps[op->ch1].op == XPATH_OP_SORT) &&
  ------------------
  |  Branch (12393:21): [True: 0, False: 0]
  ------------------
12394|      0|                    (comp->steps[op->ch2].op == XPATH_OP_SORT)) {
  ------------------
  |  Branch (12394:21): [True: 0, False: 0]
  ------------------
12395|      0|                    int f = comp->steps[op->ch2].ch1;
12396|       |
12397|      0|                    if ((f != -1) &&
  ------------------
  |  Branch (12397:25): [True: 0, False: 0]
  ------------------
12398|      0|                        (comp->steps[f].op == XPATH_OP_FUNCTION) &&
  ------------------
  |  Branch (12398:25): [True: 0, False: 0]
  ------------------
12399|      0|                        (comp->steps[f].value5 == NULL) &&
  ------------------
  |  Branch (12399:25): [True: 0, False: 0]
  ------------------
12400|      0|                        (comp->steps[f].value == 0) &&
  ------------------
  |  Branch (12400:25): [True: 0, False: 0]
  ------------------
12401|      0|                        (comp->steps[f].value4 != NULL) &&
  ------------------
  |  Branch (12401:25): [True: 0, False: 0]
  ------------------
12402|      0|                        (xmlStrEqual
  ------------------
  |  Branch (12402:25): [True: 0, False: 0]
  ------------------
12403|      0|                         (comp->steps[f].value4, BAD_CAST "last"))) {
  ------------------
  |  |   35|      0|#define BAD_CAST (xmlChar *)
  ------------------
12404|      0|                        xmlNodePtr last = NULL;
12405|       |
12406|      0|                        total +=
12407|      0|                            xmlXPathCompOpEvalLast(ctxt,
12408|      0|                                                   &comp->steps[op->ch1],
12409|      0|                                                   &last);
12410|      0|			CHECK_ERROR0;
  ------------------
  |  |  249|      0|    if (ctxt->error != XPATH_EXPRESSION_OK) return(0)
  |  |  ------------------
  |  |  |  Branch (249:9): [True: 0, False: 0]
  |  |  ------------------
  ------------------
12411|       |                        /*
12412|       |                         * The nodeset should be in document order,
12413|       |                         * Keep only the last value
12414|       |                         */
12415|      0|                        if ((ctxt->value != NULL) &&
  ------------------
  |  Branch (12415:29): [True: 0, False: 0]
  ------------------
12416|      0|                            (ctxt->value->type == XPATH_NODESET) &&
  ------------------
  |  Branch (12416:29): [True: 0, False: 0]
  ------------------
12417|      0|                            (ctxt->value->nodesetval != NULL) &&
  ------------------
  |  Branch (12417:29): [True: 0, False: 0]
  ------------------
12418|      0|                            (ctxt->value->nodesetval->nodeTab != NULL) &&
  ------------------
  |  Branch (12418:29): [True: 0, False: 0]
  ------------------
12419|      0|                            (ctxt->value->nodesetval->nodeNr > 1))
  ------------------
  |  Branch (12419:29): [True: 0, False: 0]
  ------------------
12420|      0|                            xmlXPathNodeSetKeepLast(ctxt->value->nodesetval);
12421|      0|                        break;
12422|      0|                    }
12423|      0|                }
12424|       |		/*
12425|       |		* Process inner predicates first.
12426|       |		* Example "index[parent::book][1]":
12427|       |		* ...
12428|       |		*   PREDICATE   <-- we are here "[1]"
12429|       |		*     PREDICATE <-- process "[parent::book]" first
12430|       |		*       SORT
12431|       |		*         COLLECT  'parent' 'name' 'node' book
12432|       |		*           NODE
12433|       |		*     ELEM Object is a number : 1
12434|       |		*/
12435|      0|                if (op->ch1 != -1)
  ------------------
  |  Branch (12435:21): [True: 0, False: 0]
  ------------------
12436|      0|                    total +=
12437|      0|                        xmlXPathCompOpEval(ctxt, &comp->steps[op->ch1]);
12438|      0|		CHECK_ERROR0;
  ------------------
  |  |  249|      0|    if (ctxt->error != XPATH_EXPRESSION_OK) return(0)
  |  |  ------------------
  |  |  |  Branch (249:9): [True: 0, False: 0]
  |  |  ------------------
  ------------------
12439|      0|                if (op->ch2 == -1)
  ------------------
  |  Branch (12439:21): [True: 0, False: 0]
  ------------------
12440|      0|                    break;
12441|      0|                if (ctxt->value == NULL)
  ------------------
  |  Branch (12441:21): [True: 0, False: 0]
  ------------------
12442|      0|                    break;
12443|       |
12444|       |#ifdef LIBXML_XPTR_LOCS_ENABLED
12445|       |                /*
12446|       |                 * Hum are we filtering the result of an XPointer expression
12447|       |                 */
12448|       |                if (ctxt->value->type == XPATH_LOCATIONSET) {
12449|       |                    xmlLocationSetPtr locset = ctxt->value->user;
12450|       |                    xmlXPathLocationSetFilter(ctxt, locset, op->ch2,
12451|       |                                              1, locset->locNr);
12452|       |                    break;
12453|       |                }
12454|       |#endif /* LIBXML_XPTR_LOCS_ENABLED */
12455|       |
12456|       |                /*
12457|       |                 * In case of errors, xmlXPathNodeSetFilter can pop additional
12458|       |                 * nodes from the stack. We have to temporarily remove the
12459|       |                 * nodeset object from the stack to avoid freeing it
12460|       |                 * prematurely.
12461|       |                 */
12462|      0|                CHECK_TYPE0(XPATH_NODESET);
  ------------------
  |  |  288|      0|    if ((ctxt->value == NULL) || (ctxt->value->type != typeval))	\
  |  |  ------------------
  |  |  |  Branch (288:9): [True: 0, False: 0]
  |  |  |  Branch (288:34): [True: 0, False: 0]
  |  |  ------------------
  |  |  289|      0|        XP_ERROR0(XPATH_INVALID_TYPE)
  |  |  ------------------
  |  |  |  |  267|      0|    { xmlXPathErr(ctxt, X); return(0); }
  |  |  ------------------
  ------------------
12463|      0|                obj = valuePop(ctxt);
12464|      0|                set = obj->nodesetval;
12465|      0|                if (set != NULL)
  ------------------
  |  Branch (12465:21): [True: 0, False: 0]
  ------------------
12466|      0|                    xmlXPathNodeSetFilter(ctxt, set, op->ch2,
12467|      0|                                          1, set->nodeNr, 1);
12468|      0|                valuePush(ctxt, obj);
12469|      0|                break;
12470|      0|            }
12471|      2|        case XPATH_OP_SORT:
  ------------------
  |  Branch (12471:9): [True: 2, False: 6]
  ------------------
12472|      2|            if (op->ch1 != -1)
  ------------------
  |  Branch (12472:17): [True: 2, False: 0]
  ------------------
12473|      2|                total += xmlXPathCompOpEval(ctxt, &comp->steps[op->ch1]);
12474|      2|	    CHECK_ERROR0;
  ------------------
  |  |  249|      2|    if (ctxt->error != XPATH_EXPRESSION_OK) return(0)
  |  |  ------------------
  |  |  |  Branch (249:9): [True: 0, False: 2]
  |  |  ------------------
  ------------------
12475|      2|            if ((ctxt->value != NULL) &&
  ------------------
  |  Branch (12475:17): [True: 2, False: 0]
  ------------------
12476|      2|                (ctxt->value->type == XPATH_NODESET) &&
  ------------------
  |  Branch (12476:17): [True: 2, False: 0]
  ------------------
12477|      2|                (ctxt->value->nodesetval != NULL) &&
  ------------------
  |  Branch (12477:17): [True: 2, False: 0]
  ------------------
12478|      2|		(ctxt->value->nodesetval->nodeNr > 1))
  ------------------
  |  Branch (12478:3): [True: 0, False: 2]
  ------------------
12479|      0|	    {
12480|      0|                xmlXPathNodeSetSort(ctxt->value->nodesetval);
12481|      0|	    }
12482|      2|            break;
12483|       |#ifdef LIBXML_XPTR_LOCS_ENABLED
12484|       |        case XPATH_OP_RANGETO:{
12485|       |                xmlXPathObjectPtr range;
12486|       |                xmlXPathObjectPtr res, obj;
12487|       |                xmlXPathObjectPtr tmp;
12488|       |                xmlLocationSetPtr newlocset = NULL;
12489|       |		    xmlLocationSetPtr oldlocset;
12490|       |                xmlNodeSetPtr oldset;
12491|       |                xmlNodePtr oldnode = ctxt->context->node;
12492|       |                int oldcs = ctxt->context->contextSize;
12493|       |                int oldpp = ctxt->context->proximityPosition;
12494|       |                int i, j;
12495|       |
12496|       |                if (op->ch1 != -1) {
12497|       |                    total +=
12498|       |                        xmlXPathCompOpEval(ctxt, &comp->steps[op->ch1]);
12499|       |                    CHECK_ERROR0;
12500|       |                }
12501|       |                if (ctxt->value == NULL) {
12502|       |                    XP_ERROR0(XPATH_INVALID_OPERAND);
12503|       |                }
12504|       |                if (op->ch2 == -1)
12505|       |                    break;
12506|       |
12507|       |                if (ctxt->value->type == XPATH_LOCATIONSET) {
12508|       |                    /*
12509|       |                     * Extract the old locset, and then evaluate the result of the
12510|       |                     * expression for all the element in the locset. use it to grow
12511|       |                     * up a new locset.
12512|       |                     */
12513|       |                    CHECK_TYPE0(XPATH_LOCATIONSET);
12514|       |
12515|       |                    if ((ctxt->value->user == NULL) ||
12516|       |                        (((xmlLocationSetPtr) ctxt->value->user)->locNr == 0))
12517|       |                        break;
12518|       |
12519|       |                    obj = valuePop(ctxt);
12520|       |                    oldlocset = obj->user;
12521|       |
12522|       |                    newlocset = xmlXPtrLocationSetCreate(NULL);
12523|       |
12524|       |                    for (i = 0; i < oldlocset->locNr; i++) {
12525|       |                        /*
12526|       |                         * Run the evaluation with a node list made of a
12527|       |                         * single item in the nodelocset.
12528|       |                         */
12529|       |                        ctxt->context->node = oldlocset->locTab[i]->user;
12530|       |                        ctxt->context->contextSize = oldlocset->locNr;
12531|       |                        ctxt->context->proximityPosition = i + 1;
12532|       |			tmp = xmlXPathCacheNewNodeSet(ctxt->context,
12533|       |			    ctxt->context->node);
12534|       |                        valuePush(ctxt, tmp);
12535|       |
12536|       |                        if (op->ch2 != -1)
12537|       |                            total +=
12538|       |                                xmlXPathCompOpEval(ctxt,
12539|       |                                                   &comp->steps[op->ch2]);
12540|       |			if (ctxt->error != XPATH_EXPRESSION_OK) {
12541|       |                            xmlXPtrFreeLocationSet(newlocset);
12542|       |                            goto rangeto_error;
12543|       |			}
12544|       |
12545|       |                        res = valuePop(ctxt);
12546|       |			if (res->type == XPATH_LOCATIONSET) {
12547|       |			    xmlLocationSetPtr rloc =
12548|       |			        (xmlLocationSetPtr)res->user;
12549|       |			    for (j=0; j<rloc->locNr; j++) {
12550|       |			        range = xmlXPtrNewRange(
12551|       |				  oldlocset->locTab[i]->user,
12552|       |				  oldlocset->locTab[i]->index,
12553|       |				  rloc->locTab[j]->user2,
12554|       |				  rloc->locTab[j]->index2);
12555|       |				if (range != NULL) {
12556|       |				    xmlXPtrLocationSetAdd(newlocset, range);
12557|       |				}
12558|       |			    }
12559|       |			} else {
12560|       |			    range = xmlXPtrNewRangeNodeObject(
12561|       |				(xmlNodePtr)oldlocset->locTab[i]->user, res);
12562|       |                            if (range != NULL) {
12563|       |                                xmlXPtrLocationSetAdd(newlocset,range);
12564|       |			    }
12565|       |                        }
12566|       |
12567|       |                        /*
12568|       |                         * Cleanup
12569|       |                         */
12570|       |                        if (res != NULL) {
12571|       |			    xmlXPathReleaseObject(ctxt->context, res);
12572|       |			}
12573|       |                        if (ctxt->value == tmp) {
12574|       |                            res = valuePop(ctxt);
12575|       |			    xmlXPathReleaseObject(ctxt->context, res);
12576|       |                        }
12577|       |                    }
12578|       |		} else {	/* Not a location set */
12579|       |                    CHECK_TYPE0(XPATH_NODESET);
12580|       |                    obj = valuePop(ctxt);
12581|       |                    oldset = obj->nodesetval;
12582|       |
12583|       |                    newlocset = xmlXPtrLocationSetCreate(NULL);
12584|       |
12585|       |                    if (oldset != NULL) {
12586|       |                        for (i = 0; i < oldset->nodeNr; i++) {
12587|       |                            /*
12588|       |                             * Run the evaluation with a node list made of a single item
12589|       |                             * in the nodeset.
12590|       |                             */
12591|       |                            ctxt->context->node = oldset->nodeTab[i];
12592|       |			    /*
12593|       |			    * OPTIMIZE TODO: Avoid recreation for every iteration.
12594|       |			    */
12595|       |			    tmp = xmlXPathCacheNewNodeSet(ctxt->context,
12596|       |				ctxt->context->node);
12597|       |                            valuePush(ctxt, tmp);
12598|       |
12599|       |                            if (op->ch2 != -1)
12600|       |                                total +=
12601|       |                                    xmlXPathCompOpEval(ctxt,
12602|       |                                                   &comp->steps[op->ch2]);
12603|       |			    if (ctxt->error != XPATH_EXPRESSION_OK) {
12604|       |                                xmlXPtrFreeLocationSet(newlocset);
12605|       |                                goto rangeto_error;
12606|       |			    }
12607|       |
12608|       |                            res = valuePop(ctxt);
12609|       |                            range =
12610|       |                                xmlXPtrNewRangeNodeObject(oldset->nodeTab[i],
12611|       |                                                      res);
12612|       |                            if (range != NULL) {
12613|       |                                xmlXPtrLocationSetAdd(newlocset, range);
12614|       |                            }
12615|       |
12616|       |                            /*
12617|       |                             * Cleanup
12618|       |                             */
12619|       |                            if (res != NULL) {
12620|       |				xmlXPathReleaseObject(ctxt->context, res);
12621|       |			    }
12622|       |                            if (ctxt->value == tmp) {
12623|       |                                res = valuePop(ctxt);
12624|       |				xmlXPathReleaseObject(ctxt->context, res);
12625|       |                            }
12626|       |                        }
12627|       |                    }
12628|       |                }
12629|       |
12630|       |                /*
12631|       |                 * The result is used as the new evaluation set.
12632|       |                 */
12633|       |                valuePush(ctxt, xmlXPtrWrapLocationSet(newlocset));
12634|       |rangeto_error:
12635|       |		xmlXPathReleaseObject(ctxt->context, obj);
12636|       |                ctxt->context->node = oldnode;
12637|       |                ctxt->context->contextSize = oldcs;
12638|       |                ctxt->context->proximityPosition = oldpp;
12639|       |                break;
12640|       |            }
12641|       |#endif /* LIBXML_XPTR_LOCS_ENABLED */
12642|      0|        default:
  ------------------
  |  Branch (12642:9): [True: 0, False: 8]
  ------------------
12643|      0|            xmlGenericError(xmlGenericErrorContext,
  ------------------
  |  |  875|      0|  #define xmlGenericError XML_GLOBAL_MACRO(xmlGenericError)
  |  |  ------------------
  |  |  |  |  500|      0|  #define XML_GLOBAL_MACRO(name) (*__##name())
  |  |  ------------------
  ------------------
                          xmlGenericError(xmlGenericErrorContext,
  ------------------
  |  |  876|      0|  #define xmlGenericErrorContext XML_GLOBAL_MACRO(xmlGenericErrorContext)
  |  |  ------------------
  |  |  |  |  500|      0|  #define XML_GLOBAL_MACRO(name) (*__##name())
  |  |  ------------------
  ------------------
12644|      0|                            "XPath: unknown precompiled operation %d\n", op->op);
12645|      0|            ctxt->error = XPATH_INVALID_OPERAND;
12646|      0|            break;
12647|      8|    }
12648|       |
12649|      8|    ctxt->context->depth -= 1;
12650|      8|    return (total);
12651|      8|}

xmlXPtrNewContext:
 1300|     84|xmlXPtrNewContext(xmlDocPtr doc, xmlNodePtr here, xmlNodePtr origin) {
 1301|     84|    xmlXPathContextPtr ret;
 1302|     84|    (void) here;
 1303|     84|    (void) origin;
 1304|       |
 1305|     84|    ret = xmlXPathNewContext(doc);
 1306|     84|    if (ret == NULL)
  ------------------
  |  Branch (1306:9): [True: 0, False: 84]
  ------------------
 1307|      0|	return(ret);
 1308|       |#ifdef LIBXML_XPTR_LOCS_ENABLED
 1309|       |    ret->xptr = 1;
 1310|       |    ret->here = here;
 1311|       |    ret->origin = origin;
 1312|       |
 1313|       |    xmlXPathRegisterFunc(ret, (xmlChar *)"range",
 1314|       |	                 xmlXPtrRangeFunction);
 1315|       |    xmlXPathRegisterFunc(ret, (xmlChar *)"range-inside",
 1316|       |	                 xmlXPtrRangeInsideFunction);
 1317|       |    xmlXPathRegisterFunc(ret, (xmlChar *)"string-range",
 1318|       |	                 xmlXPtrStringRangeFunction);
 1319|       |    xmlXPathRegisterFunc(ret, (xmlChar *)"start-point",
 1320|       |	                 xmlXPtrStartPointFunction);
 1321|       |    xmlXPathRegisterFunc(ret, (xmlChar *)"end-point",
 1322|       |	                 xmlXPtrEndPointFunction);
 1323|       |    xmlXPathRegisterFunc(ret, (xmlChar *)"here",
 1324|       |	                 xmlXPtrHereFunction);
 1325|       |    xmlXPathRegisterFunc(ret, (xmlChar *)" origin",
 1326|       |	                 xmlXPtrOriginFunction);
 1327|       |#endif /* LIBXML_XPTR_LOCS_ENABLED */
 1328|       |
 1329|     84|    return(ret);
 1330|     84|}
xmlXPtrEval:
 1343|     84|xmlXPtrEval(const xmlChar *str, xmlXPathContextPtr ctx) {
 1344|     84|    xmlXPathParserContextPtr ctxt;
 1345|     84|    xmlXPathObjectPtr res = NULL, tmp;
 1346|     84|    xmlXPathObjectPtr init = NULL;
 1347|     84|    int stack = 0;
 1348|       |
 1349|     84|    xmlInitParser();
 1350|       |
 1351|     84|    if ((ctx == NULL) || (str == NULL))
  ------------------
  |  Branch (1351:9): [True: 0, False: 84]
  |  Branch (1351:26): [True: 0, False: 84]
  ------------------
 1352|      0|	return(NULL);
 1353|       |
 1354|     84|    ctxt = xmlXPathNewParserContext(str, ctx);
 1355|     84|    if (ctxt == NULL)
  ------------------
  |  Branch (1355:9): [True: 0, False: 84]
  ------------------
 1356|      0|	return(NULL);
 1357|     84|    xmlXPtrEvalXPointer(ctxt);
 1358|       |
 1359|     84|    if ((ctxt->value != NULL) &&
  ------------------
  |  Branch (1359:9): [True: 84, False: 0]
  ------------------
 1360|       |#ifdef LIBXML_XPTR_LOCS_ENABLED
 1361|       |	(ctxt->value->type != XPATH_LOCATIONSET) &&
 1362|       |#endif
 1363|     84|	(ctxt->value->type != XPATH_NODESET)) {
  ------------------
  |  Branch (1363:2): [True: 0, False: 84]
  ------------------
 1364|      0|        xmlXPtrErr(ctxt, XML_XPTR_EVAL_FAILED,
 1365|      0|		"xmlXPtrEval: evaluation failed to return a node set\n",
 1366|      0|		   NULL);
 1367|     84|    } else {
 1368|     84|	res = valuePop(ctxt);
 1369|     84|    }
 1370|       |
 1371|     84|    do {
 1372|     84|        tmp = valuePop(ctxt);
 1373|     84|	if (tmp != NULL) {
  ------------------
  |  Branch (1373:6): [True: 0, False: 84]
  ------------------
 1374|      0|	    if (tmp != init) {
  ------------------
  |  Branch (1374:10): [True: 0, False: 0]
  ------------------
 1375|      0|		if (tmp->type == XPATH_NODESET) {
  ------------------
  |  Branch (1375:7): [True: 0, False: 0]
  ------------------
 1376|       |		    /*
 1377|       |		     * Evaluation may push a root nodeset which is unused
 1378|       |		     */
 1379|      0|		    xmlNodeSetPtr set;
 1380|      0|		    set = tmp->nodesetval;
 1381|      0|		    if ((set == NULL) || (set->nodeNr != 1) ||
  ------------------
  |  Branch (1381:11): [True: 0, False: 0]
  |  Branch (1381:28): [True: 0, False: 0]
  ------------------
 1382|      0|			(set->nodeTab[0] != (xmlNodePtr) ctx->doc))
  ------------------
  |  Branch (1382:4): [True: 0, False: 0]
  ------------------
 1383|      0|			stack++;
 1384|      0|		} else
 1385|      0|		    stack++;
 1386|      0|	    }
 1387|      0|	    xmlXPathFreeObject(tmp);
 1388|      0|        }
 1389|     84|    } while (tmp != NULL);
  ------------------
  |  Branch (1389:14): [True: 0, False: 84]
  ------------------
 1390|     84|    if (stack != 0) {
  ------------------
  |  Branch (1390:9): [True: 0, False: 84]
  ------------------
 1391|      0|        xmlXPtrErr(ctxt, XML_XPTR_EXTRA_OBJECTS,
 1392|      0|		   "xmlXPtrEval: object(s) left on the eval stack\n",
 1393|      0|		   NULL);
 1394|      0|    }
 1395|     84|    if (ctxt->error != XPATH_EXPRESSION_OK) {
  ------------------
  |  Branch (1395:9): [True: 0, False: 84]
  ------------------
 1396|      0|	xmlXPathFreeObject(res);
 1397|      0|	res = NULL;
 1398|      0|    }
 1399|       |
 1400|     84|    xmlXPathFreeParserContext(ctxt);
 1401|     84|    return(res);
 1402|     84|}
xpointer.c:xmlXPtrEvalXPointer:
 1227|     84|xmlXPtrEvalXPointer(xmlXPathParserContextPtr ctxt) {
 1228|     84|    if (ctxt->valueTab == NULL) {
  ------------------
  |  Branch (1228:9): [True: 84, False: 0]
  ------------------
 1229|       |	/* Allocate the value stack */
 1230|     84|	ctxt->valueTab = (xmlXPathObjectPtr *)
 1231|     84|			 xmlMalloc(10 * sizeof(xmlXPathObjectPtr));
 1232|     84|	if (ctxt->valueTab == NULL) {
  ------------------
  |  Branch (1232:6): [True: 0, False: 84]
  ------------------
 1233|      0|	    xmlXPtrErrMemory("allocating evaluation context");
 1234|      0|	    return;
 1235|      0|	}
 1236|     84|	ctxt->valueNr = 0;
 1237|     84|	ctxt->valueMax = 10;
 1238|     84|	ctxt->value = NULL;
 1239|     84|    }
 1240|     84|    SKIP_BLANKS;
  ------------------
  |  |  869|     84|    while (IS_BLANK_CH(*(ctxt->cur))) NEXT
  |  |  ------------------
  |  |  |  |  872|     84|#define NEXT ((*ctxt->cur) ?  ctxt->cur++: ctxt->cur)
  |  |  |  |  ------------------
  |  |  |  |  |  Branch (872:15): [True: 0, False: 0]
  |  |  |  |  ------------------
  |  |  ------------------
  ------------------
 1241|     84|    if (CUR == '/') {
  ------------------
  |  |  864|     84|#define CUR (*ctxt->cur)
  ------------------
  |  Branch (1241:9): [True: 0, False: 84]
  ------------------
 1242|      0|	xmlXPathRoot(ctxt);
 1243|      0|        xmlXPtrEvalChildSeq(ctxt, NULL);
 1244|     84|    } else {
 1245|     84|	xmlChar *name;
 1246|       |
 1247|     84|	name = xmlXPathParseName(ctxt);
 1248|     84|	if (name == NULL)
  ------------------
  |  Branch (1248:6): [True: 0, False: 84]
  ------------------
 1249|     84|	    XP_ERROR(XPATH_EXPR_ERROR);
  ------------------
  |  |  258|      0|    { xmlXPathErr(ctxt, X); return; }
  ------------------
 1250|     84|	if (CUR == '(') {
  ------------------
  |  |  864|     84|#define CUR (*ctxt->cur)
  ------------------
  |  Branch (1250:6): [True: 82, False: 2]
  ------------------
 1251|     82|	    xmlXPtrEvalFullXPtr(ctxt, name);
 1252|       |	    /* Short evaluation */
 1253|     82|	    return;
 1254|     82|	} else {
 1255|       |	    /* this handle both Bare Names and Child Sequences */
 1256|      2|	    xmlXPtrEvalChildSeq(ctxt, name);
 1257|      2|	}
 1258|     84|    }
 1259|      2|    SKIP_BLANKS;
  ------------------
  |  |  869|      2|    while (IS_BLANK_CH(*(ctxt->cur))) NEXT
  |  |  ------------------
  |  |  |  |  872|     84|#define NEXT ((*ctxt->cur) ?  ctxt->cur++: ctxt->cur)
  |  |  |  |  ------------------
  |  |  |  |  |  Branch (872:15): [True: 0, False: 0]
  |  |  |  |  ------------------
  |  |  ------------------
  ------------------
 1260|      2|    if (CUR != 0)
  ------------------
  |  |  864|      2|#define CUR (*ctxt->cur)
  ------------------
  |  Branch (1260:9): [True: 0, False: 2]
  ------------------
 1261|      2|	XP_ERROR(XPATH_EXPR_ERROR);
  ------------------
  |  |  258|      0|    { xmlXPathErr(ctxt, X); return; }
  ------------------
 1262|      2|}
xpointer.c:xmlXPtrEvalChildSeq:
 1176|      2|xmlXPtrEvalChildSeq(xmlXPathParserContextPtr ctxt, xmlChar *name) {
 1177|       |    /*
 1178|       |     * XPointer don't allow by syntax to address in multirooted trees
 1179|       |     * this might prove useful in some cases, warn about it.
 1180|       |     */
 1181|      2|    if ((name == NULL) && (CUR == '/') && (NXT(1) != '1')) {
  ------------------
  |  |  864|      0|#define CUR (*ctxt->cur)
  ------------------
                  if ((name == NULL) && (CUR == '/') && (NXT(1) != '1')) {
  ------------------
  |  |  866|      0|#define NXT(val) ctxt->cur[(val)]
  ------------------
  |  Branch (1181:9): [True: 0, False: 2]
  |  Branch (1181:27): [True: 0, False: 0]
  |  Branch (1181:43): [True: 0, False: 0]
  ------------------
 1182|      0|        xmlXPtrErr(ctxt, XML_XPTR_CHILDSEQ_START,
 1183|      0|		   "warning: ChildSeq not starting by /1\n", NULL);
 1184|      0|    }
 1185|       |
 1186|      2|    if (name != NULL) {
  ------------------
  |  Branch (1186:9): [True: 2, False: 0]
  ------------------
 1187|      2|	valuePush(ctxt, xmlXPathNewString(name));
 1188|      2|	xmlFree(name);
 1189|      2|	xmlXPathIdFunction(ctxt, 1);
 1190|      2|	CHECK_ERROR;
  ------------------
  |  |  241|      2|    if (ctxt->error != XPATH_EXPRESSION_OK) return
  |  |  ------------------
  |  |  |  Branch (241:9): [True: 0, False: 2]
  |  |  ------------------
  ------------------
 1191|      2|    }
 1192|       |
 1193|      2|    while (CUR == '/') {
  ------------------
  |  |  864|      2|#define CUR (*ctxt->cur)
  ------------------
  |  Branch (1193:12): [True: 0, False: 2]
  ------------------
 1194|      0|	int child = 0, overflow = 0;
 1195|      0|	NEXT;
  ------------------
  |  |  872|      0|#define NEXT ((*ctxt->cur) ?  ctxt->cur++: ctxt->cur)
  |  |  ------------------
  |  |  |  Branch (872:15): [True: 0, False: 0]
  |  |  ------------------
  ------------------
 1196|       |
 1197|      0|	while ((CUR >= '0') && (CUR <= '9')) {
  ------------------
  |  |  864|      0|#define CUR (*ctxt->cur)
  ------------------
              	while ((CUR >= '0') && (CUR <= '9')) {
  ------------------
  |  |  864|      0|#define CUR (*ctxt->cur)
  ------------------
  |  Branch (1197:9): [True: 0, False: 0]
  |  Branch (1197:25): [True: 0, False: 0]
  ------------------
 1198|      0|            int d = CUR - '0';
  ------------------
  |  |  864|      0|#define CUR (*ctxt->cur)
  ------------------
 1199|      0|            if (child > INT_MAX / 10)
  ------------------
  |  Branch (1199:17): [True: 0, False: 0]
  ------------------
 1200|      0|                overflow = 1;
 1201|      0|            else
 1202|      0|                child *= 10;
 1203|      0|            if (child > INT_MAX - d)
  ------------------
  |  Branch (1203:17): [True: 0, False: 0]
  ------------------
 1204|      0|                overflow = 1;
 1205|      0|            else
 1206|      0|                child += d;
 1207|      0|	    NEXT;
  ------------------
  |  |  872|      0|#define NEXT ((*ctxt->cur) ?  ctxt->cur++: ctxt->cur)
  |  |  ------------------
  |  |  |  Branch (872:15): [True: 0, False: 0]
  |  |  ------------------
  ------------------
 1208|      0|	}
 1209|      0|        if (overflow)
  ------------------
  |  Branch (1209:13): [True: 0, False: 0]
  ------------------
 1210|      0|            child = 0;
 1211|      0|	xmlXPtrGetChildNo(ctxt, child);
 1212|      0|    }
 1213|      2|}
xpointer.c:xmlXPtrEvalFullXPtr:
 1104|     82|xmlXPtrEvalFullXPtr(xmlXPathParserContextPtr ctxt, xmlChar *name) {
 1105|     82|    if (name == NULL)
  ------------------
  |  Branch (1105:9): [True: 0, False: 82]
  ------------------
 1106|      0|    name = xmlXPathParseName(ctxt);
 1107|     82|    if (name == NULL)
  ------------------
  |  Branch (1107:9): [True: 0, False: 82]
  ------------------
 1108|     82|	XP_ERROR(XPATH_EXPR_ERROR);
  ------------------
  |  |  258|      0|    { xmlXPathErr(ctxt, X); return; }
  ------------------
 1109|     82|    while (name != NULL) {
  ------------------
  |  Branch (1109:12): [True: 82, False: 0]
  ------------------
 1110|     82|	ctxt->error = XPATH_EXPRESSION_OK;
 1111|     82|	xmlXPtrEvalXPtrPart(ctxt, name);
 1112|       |
 1113|       |	/* in case of syntax error, break here */
 1114|     82|	if ((ctxt->error != XPATH_EXPRESSION_OK) &&
  ------------------
  |  Branch (1114:6): [True: 0, False: 82]
  ------------------
 1115|     82|            (ctxt->error != XML_XPTR_UNKNOWN_SCHEME))
  ------------------
  |  Branch (1115:13): [True: 0, False: 0]
  ------------------
 1116|      0|	    return;
 1117|       |
 1118|       |	/*
 1119|       |	 * If the returned value is a non-empty nodeset
 1120|       |	 * or location set, return here.
 1121|       |	 */
 1122|     82|	if (ctxt->value != NULL) {
  ------------------
  |  Branch (1122:6): [True: 82, False: 0]
  ------------------
 1123|     82|	    xmlXPathObjectPtr obj = ctxt->value;
 1124|       |
 1125|     82|	    switch (obj->type) {
 1126|       |#ifdef LIBXML_XPTR_LOCS_ENABLED
 1127|       |		case XPATH_LOCATIONSET: {
 1128|       |		    xmlLocationSetPtr loc = ctxt->value->user;
 1129|       |		    if ((loc != NULL) && (loc->locNr > 0))
 1130|       |			return;
 1131|       |		    break;
 1132|       |		}
 1133|       |#endif
 1134|     82|		case XPATH_NODESET: {
  ------------------
  |  Branch (1134:3): [True: 82, False: 0]
  ------------------
 1135|     82|		    xmlNodeSetPtr loc = ctxt->value->nodesetval;
 1136|     82|		    if ((loc != NULL) && (loc->nodeNr > 0))
  ------------------
  |  Branch (1136:11): [True: 82, False: 0]
  |  Branch (1136:28): [True: 82, False: 0]
  ------------------
 1137|     82|			return;
 1138|      0|		    break;
 1139|     82|		}
 1140|      0|		default:
  ------------------
  |  Branch (1140:3): [True: 0, False: 82]
  ------------------
 1141|      0|		    break;
 1142|     82|	    }
 1143|       |
 1144|       |	    /*
 1145|       |	     * Evaluating to improper values is equivalent to
 1146|       |	     * a sub-resource error, clean-up the stack
 1147|       |	     */
 1148|      0|	    do {
 1149|      0|		obj = valuePop(ctxt);
 1150|      0|		if (obj != NULL) {
  ------------------
  |  Branch (1150:7): [True: 0, False: 0]
  ------------------
 1151|      0|		    xmlXPathFreeObject(obj);
 1152|      0|		}
 1153|      0|	    } while (obj != NULL);
  ------------------
  |  Branch (1153:15): [True: 0, False: 0]
  ------------------
 1154|      0|	}
 1155|       |
 1156|       |	/*
 1157|       |	 * Is there another XPointer part.
 1158|       |	 */
 1159|      0|	SKIP_BLANKS;
  ------------------
  |  |  869|      0|    while (IS_BLANK_CH(*(ctxt->cur))) NEXT
  |  |  ------------------
  |  |  |  |  872|     82|#define NEXT ((*ctxt->cur) ?  ctxt->cur++: ctxt->cur)
  |  |  |  |  ------------------
  |  |  |  |  |  Branch (872:15): [True: 0, False: 0]
  |  |  |  |  ------------------
  |  |  ------------------
  ------------------
 1160|      0|	name = xmlXPathParseName(ctxt);
 1161|      0|    }
 1162|     82|}
xpointer.c:xmlXPtrEvalXPtrPart:
  941|     82|xmlXPtrEvalXPtrPart(xmlXPathParserContextPtr ctxt, xmlChar *name) {
  942|     82|    xmlChar *buffer, *cur;
  943|     82|    int len;
  944|     82|    int level;
  945|       |
  946|     82|    if (name == NULL)
  ------------------
  |  Branch (946:9): [True: 0, False: 82]
  ------------------
  947|      0|    name = xmlXPathParseName(ctxt);
  948|     82|    if (name == NULL)
  ------------------
  |  Branch (948:9): [True: 0, False: 82]
  ------------------
  949|     82|	XP_ERROR(XPATH_EXPR_ERROR);
  ------------------
  |  |  258|      0|    { xmlXPathErr(ctxt, X); return; }
  ------------------
  950|       |
  951|     82|    if (CUR != '(') {
  ------------------
  |  |  864|     82|#define CUR (*ctxt->cur)
  ------------------
  |  Branch (951:9): [True: 0, False: 82]
  ------------------
  952|      0|        xmlFree(name);
  953|      0|	XP_ERROR(XPATH_EXPR_ERROR);
  ------------------
  |  |  258|      0|    { xmlXPathErr(ctxt, X); return; }
  ------------------
  954|      0|    }
  955|     82|    NEXT;
  ------------------
  |  |  872|     82|#define NEXT ((*ctxt->cur) ?  ctxt->cur++: ctxt->cur)
  |  |  ------------------
  |  |  |  Branch (872:15): [True: 82, False: 0]
  |  |  ------------------
  ------------------
  956|     82|    level = 1;
  957|       |
  958|     82|    len = xmlStrlen(ctxt->cur);
  959|     82|    len++;
  960|     82|    buffer = (xmlChar *) xmlMallocAtomic(len);
  961|     82|    if (buffer == NULL) {
  ------------------
  |  Branch (961:9): [True: 0, False: 82]
  ------------------
  962|      0|        xmlXPtrErrMemory("allocating buffer");
  963|      0|        xmlFree(name);
  964|      0|	return;
  965|      0|    }
  966|       |
  967|     82|    cur = buffer;
  968|    468|    while (CUR != 0) {
  ------------------
  |  |  864|    468|#define CUR (*ctxt->cur)
  ------------------
  |  Branch (968:12): [True: 468, False: 0]
  ------------------
  969|    468|	if (CUR == ')') {
  ------------------
  |  |  864|    468|#define CUR (*ctxt->cur)
  ------------------
  |  Branch (969:6): [True: 84, False: 384]
  ------------------
  970|     84|	    level--;
  971|     84|	    if (level == 0) {
  ------------------
  |  Branch (971:10): [True: 82, False: 2]
  ------------------
  972|     82|		NEXT;
  ------------------
  |  |  872|     82|#define NEXT ((*ctxt->cur) ?  ctxt->cur++: ctxt->cur)
  |  |  ------------------
  |  |  |  Branch (872:15): [True: 82, False: 0]
  |  |  ------------------
  ------------------
  973|     82|		break;
  974|     82|	    }
  975|    384|	} else if (CUR == '(') {
  ------------------
  |  |  864|    384|#define CUR (*ctxt->cur)
  ------------------
  |  Branch (975:13): [True: 2, False: 382]
  ------------------
  976|      2|	    level++;
  977|    382|	} else if (CUR == '^') {
  ------------------
  |  |  864|    382|#define CUR (*ctxt->cur)
  ------------------
  |  Branch (977:13): [True: 0, False: 382]
  ------------------
  978|      0|            if ((NXT(1) == ')') || (NXT(1) == '(') || (NXT(1) == '^')) {
  ------------------
  |  |  866|      0|#define NXT(val) ctxt->cur[(val)]
  ------------------
                          if ((NXT(1) == ')') || (NXT(1) == '(') || (NXT(1) == '^')) {
  ------------------
  |  |  866|      0|#define NXT(val) ctxt->cur[(val)]
  ------------------
                          if ((NXT(1) == ')') || (NXT(1) == '(') || (NXT(1) == '^')) {
  ------------------
  |  |  866|      0|#define NXT(val) ctxt->cur[(val)]
  ------------------
  |  Branch (978:17): [True: 0, False: 0]
  |  Branch (978:36): [True: 0, False: 0]
  |  Branch (978:55): [True: 0, False: 0]
  ------------------
  979|      0|                NEXT;
  ------------------
  |  |  872|      0|#define NEXT ((*ctxt->cur) ?  ctxt->cur++: ctxt->cur)
  |  |  ------------------
  |  |  |  Branch (872:15): [True: 0, False: 0]
  |  |  ------------------
  ------------------
  980|      0|            }
  981|      0|	}
  982|    386|        *cur++ = CUR;
  ------------------
  |  |  864|    386|#define CUR (*ctxt->cur)
  ------------------
  983|    386|	NEXT;
  ------------------
  |  |  872|    386|#define NEXT ((*ctxt->cur) ?  ctxt->cur++: ctxt->cur)
  |  |  ------------------
  |  |  |  Branch (872:15): [True: 386, False: 0]
  |  |  ------------------
  ------------------
  984|    386|    }
  985|     82|    *cur = 0;
  986|       |
  987|     82|    if ((level != 0) && (CUR == 0)) {
  ------------------
  |  |  864|      0|#define CUR (*ctxt->cur)
  ------------------
  |  Branch (987:9): [True: 0, False: 82]
  |  Branch (987:25): [True: 0, False: 0]
  ------------------
  988|      0|        xmlFree(name);
  989|      0|	xmlFree(buffer);
  990|      0|	XP_ERROR(XPTR_SYNTAX_ERROR);
  ------------------
  |  |  258|      0|    { xmlXPathErr(ctxt, X); return; }
  ------------------
  991|      0|    }
  992|       |
  993|     82|    if (xmlStrEqual(name, (xmlChar *) "xpointer") ||
  ------------------
  |  Branch (993:9): [True: 82, False: 0]
  ------------------
  994|     82|        xmlStrEqual(name, (xmlChar *) "xpath1")) {
  ------------------
  |  Branch (994:9): [True: 0, False: 0]
  ------------------
  995|     82|	const xmlChar *oldBase = ctxt->base;
  996|     82|	const xmlChar *oldCur = ctxt->cur;
  997|       |
  998|     82|	ctxt->cur = ctxt->base = buffer;
  999|       |	/*
 1000|       |	 * To evaluate an xpointer scheme element (4.3) we need:
 1001|       |	 *   context initialized to the root
 1002|       |	 *   context position initialized to 1
 1003|       |	 *   context size initialized to 1
 1004|       |	 */
 1005|     82|	ctxt->context->node = (xmlNodePtr)ctxt->context->doc;
 1006|     82|	ctxt->context->proximityPosition = 1;
 1007|     82|	ctxt->context->contextSize = 1;
 1008|       |#ifdef LIBXML_XPTR_LOCS_ENABLED
 1009|       |        ctxt->xptr = xmlStrEqual(name, (xmlChar *) "xpointer");
 1010|       |#endif
 1011|     82|	xmlXPathEvalExpr(ctxt);
 1012|     82|	ctxt->base = oldBase;
 1013|     82|        ctxt->cur = oldCur;
 1014|     82|    } else if (xmlStrEqual(name, (xmlChar *) "element")) {
  ------------------
  |  Branch (1014:16): [True: 0, False: 0]
  ------------------
 1015|      0|	const xmlChar *oldBase = ctxt->base;
 1016|      0|	const xmlChar *oldCur = ctxt->cur;
 1017|      0|	xmlChar *name2;
 1018|       |
 1019|      0|	ctxt->cur = ctxt->base = buffer;
 1020|      0|	if (buffer[0] == '/') {
  ------------------
  |  Branch (1020:6): [True: 0, False: 0]
  ------------------
 1021|      0|	    xmlXPathRoot(ctxt);
 1022|      0|	    xmlXPtrEvalChildSeq(ctxt, NULL);
 1023|      0|	} else {
 1024|      0|	    name2 = xmlXPathParseName(ctxt);
 1025|      0|	    if (name2 == NULL) {
  ------------------
  |  Branch (1025:10): [True: 0, False: 0]
  ------------------
 1026|      0|                ctxt->base = oldBase;
 1027|      0|                ctxt->cur = oldCur;
 1028|      0|		xmlFree(buffer);
 1029|      0|                xmlFree(name);
 1030|      0|		XP_ERROR(XPATH_EXPR_ERROR);
  ------------------
  |  |  258|      0|    { xmlXPathErr(ctxt, X); return; }
  ------------------
 1031|      0|	    }
 1032|      0|	    xmlXPtrEvalChildSeq(ctxt, name2);
 1033|      0|	}
 1034|      0|	ctxt->base = oldBase;
 1035|      0|        ctxt->cur = oldCur;
 1036|      0|#ifdef XPTR_XMLNS_SCHEME
 1037|      0|    } else if (xmlStrEqual(name, (xmlChar *) "xmlns")) {
  ------------------
  |  Branch (1037:16): [True: 0, False: 0]
  ------------------
 1038|      0|	const xmlChar *oldBase = ctxt->base;
 1039|      0|	const xmlChar *oldCur = ctxt->cur;
 1040|      0|	xmlChar *prefix;
 1041|       |
 1042|      0|	ctxt->cur = ctxt->base = buffer;
 1043|      0|        prefix = xmlXPathParseNCName(ctxt);
 1044|      0|	if (prefix == NULL) {
  ------------------
  |  Branch (1044:6): [True: 0, False: 0]
  ------------------
 1045|      0|            ctxt->base = oldBase;
 1046|      0|            ctxt->cur = oldCur;
 1047|      0|	    xmlFree(buffer);
 1048|      0|	    xmlFree(name);
 1049|      0|	    XP_ERROR(XPTR_SYNTAX_ERROR);
  ------------------
  |  |  258|      0|    { xmlXPathErr(ctxt, X); return; }
  ------------------
 1050|      0|	}
 1051|      0|	SKIP_BLANKS;
  ------------------
  |  |  869|      0|    while (IS_BLANK_CH(*(ctxt->cur))) NEXT
  |  |  ------------------
  |  |  |  |  872|      0|#define NEXT ((*ctxt->cur) ?  ctxt->cur++: ctxt->cur)
  |  |  |  |  ------------------
  |  |  |  |  |  Branch (872:15): [True: 0, False: 0]
  |  |  |  |  ------------------
  |  |  ------------------
  ------------------
 1052|      0|	if (CUR != '=') {
  ------------------
  |  |  864|      0|#define CUR (*ctxt->cur)
  ------------------
  |  Branch (1052:6): [True: 0, False: 0]
  ------------------
 1053|      0|            ctxt->base = oldBase;
 1054|      0|            ctxt->cur = oldCur;
 1055|      0|	    xmlFree(prefix);
 1056|      0|	    xmlFree(buffer);
 1057|      0|	    xmlFree(name);
 1058|      0|	    XP_ERROR(XPTR_SYNTAX_ERROR);
  ------------------
  |  |  258|      0|    { xmlXPathErr(ctxt, X); return; }
  ------------------
 1059|      0|	}
 1060|      0|	NEXT;
  ------------------
  |  |  872|      0|#define NEXT ((*ctxt->cur) ?  ctxt->cur++: ctxt->cur)
  |  |  ------------------
  |  |  |  Branch (872:15): [True: 0, False: 0]
  |  |  ------------------
  ------------------
 1061|      0|	SKIP_BLANKS;
  ------------------
  |  |  869|      0|    while (IS_BLANK_CH(*(ctxt->cur))) NEXT
  |  |  ------------------
  |  |  |  |  872|      0|#define NEXT ((*ctxt->cur) ?  ctxt->cur++: ctxt->cur)
  |  |  |  |  ------------------
  |  |  |  |  |  Branch (872:15): [True: 0, False: 0]
  |  |  |  |  ------------------
  |  |  ------------------
  ------------------
 1062|       |
 1063|      0|	xmlXPathRegisterNs(ctxt->context, prefix, ctxt->cur);
 1064|      0|        ctxt->base = oldBase;
 1065|      0|        ctxt->cur = oldCur;
 1066|      0|	xmlFree(prefix);
 1067|      0|#endif /* XPTR_XMLNS_SCHEME */
 1068|      0|    } else {
 1069|      0|        xmlXPtrErr(ctxt, XML_XPTR_UNKNOWN_SCHEME,
 1070|      0|		   "unsupported scheme '%s'\n", name);
 1071|      0|    }
 1072|     82|    xmlFree(buffer);
 1073|     82|    xmlFree(name);
 1074|     82|}

